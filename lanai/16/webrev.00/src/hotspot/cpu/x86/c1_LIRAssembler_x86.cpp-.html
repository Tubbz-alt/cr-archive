<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  30 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  31 #include &quot;c1/c1_Runtime1.hpp&quot;
  32 #include &quot;c1/c1_ValueStack.hpp&quot;
  33 #include &quot;ci/ciArrayKlass.hpp&quot;
  34 #include &quot;ci/ciInstance.hpp&quot;
  35 #include &quot;gc/shared/collectedHeap.hpp&quot;
  36 #include &quot;nativeInst_x86.hpp&quot;
  37 #include &quot;oops/objArrayKlass.hpp&quot;
  38 #include &quot;runtime/frame.inline.hpp&quot;
  39 #include &quot;runtime/safepointMechanism.hpp&quot;
  40 #include &quot;runtime/sharedRuntime.hpp&quot;
  41 #include &quot;vmreg_x86.inline.hpp&quot;
  42 
  43 
  44 // These masks are used to provide 128-bit aligned bitmasks to the XMM
  45 // instructions, to allow sign-masking or sign-bit flipping.  They allow
  46 // fast versions of NegF/NegD and AbsF/AbsD.
  47 
  48 // Note: &#39;double&#39; and &#39;long long&#39; have 32-bits alignment on x86.
  49 static jlong* double_quadword(jlong *adr, jlong lo, jlong hi) {
  50   // Use the expression (adr)&amp;(~0xF) to provide 128-bits aligned address
  51   // of 128-bits operands for SSE instructions.
  52   jlong *operand = (jlong*)(((intptr_t)adr) &amp; ((intptr_t)(~0xF)));
  53   // Store the value to a 128-bits operand.
  54   operand[0] = lo;
  55   operand[1] = hi;
  56   return operand;
  57 }
  58 
  59 // Buffer for 128-bits masks used by SSE instructions.
  60 static jlong fp_signmask_pool[(4+1)*2]; // 4*128bits(data) + 128bits(alignment)
  61 
  62 // Static initialization during VM startup.
  63 static jlong *float_signmask_pool  = double_quadword(&amp;fp_signmask_pool[1*2],         CONST64(0x7FFFFFFF7FFFFFFF),         CONST64(0x7FFFFFFF7FFFFFFF));
  64 static jlong *double_signmask_pool = double_quadword(&amp;fp_signmask_pool[2*2],         CONST64(0x7FFFFFFFFFFFFFFF),         CONST64(0x7FFFFFFFFFFFFFFF));
  65 static jlong *float_signflip_pool  = double_quadword(&amp;fp_signmask_pool[3*2], (jlong)UCONST64(0x8000000080000000), (jlong)UCONST64(0x8000000080000000));
  66 static jlong *double_signflip_pool = double_quadword(&amp;fp_signmask_pool[4*2], (jlong)UCONST64(0x8000000000000000), (jlong)UCONST64(0x8000000000000000));
  67 
  68 
  69 NEEDS_CLEANUP // remove this definitions ?
  70 const Register IC_Klass    = rax;   // where the IC klass is cached
  71 const Register SYNC_header = rax;   // synchronization header
  72 const Register SHIFT_count = rcx;   // where count for shift operations must be
  73 
  74 #define __ _masm-&gt;
  75 
  76 
  77 static void select_different_registers(Register preserve,
  78                                        Register extra,
  79                                        Register &amp;tmp1,
  80                                        Register &amp;tmp2) {
  81   if (tmp1 == preserve) {
  82     assert_different_registers(tmp1, tmp2, extra);
  83     tmp1 = extra;
  84   } else if (tmp2 == preserve) {
  85     assert_different_registers(tmp1, tmp2, extra);
  86     tmp2 = extra;
  87   }
  88   assert_different_registers(preserve, tmp1, tmp2);
  89 }
  90 
  91 
  92 
  93 static void select_different_registers(Register preserve,
  94                                        Register extra,
  95                                        Register &amp;tmp1,
  96                                        Register &amp;tmp2,
  97                                        Register &amp;tmp3) {
  98   if (tmp1 == preserve) {
  99     assert_different_registers(tmp1, tmp2, tmp3, extra);
 100     tmp1 = extra;
 101   } else if (tmp2 == preserve) {
 102     assert_different_registers(tmp1, tmp2, tmp3, extra);
 103     tmp2 = extra;
 104   } else if (tmp3 == preserve) {
 105     assert_different_registers(tmp1, tmp2, tmp3, extra);
 106     tmp3 = extra;
 107   }
 108   assert_different_registers(preserve, tmp1, tmp2, tmp3);
 109 }
 110 
 111 
 112 
 113 bool LIR_Assembler::is_small_constant(LIR_Opr opr) {
 114   if (opr-&gt;is_constant()) {
 115     LIR_Const* constant = opr-&gt;as_constant_ptr();
 116     switch (constant-&gt;type()) {
 117       case T_INT: {
 118         return true;
 119       }
 120 
 121       default:
 122         return false;
 123     }
 124   }
 125   return false;
 126 }
 127 
 128 
 129 LIR_Opr LIR_Assembler::receiverOpr() {
 130   return FrameMap::receiver_opr;
 131 }
 132 
 133 LIR_Opr LIR_Assembler::osrBufferPointer() {
 134   return FrameMap::as_pointer_opr(receiverOpr()-&gt;as_register());
 135 }
 136 
 137 //--------------fpu register translations-----------------------
 138 
 139 
 140 address LIR_Assembler::float_constant(float f) {
 141   address const_addr = __ float_constant(f);
 142   if (const_addr == NULL) {
 143     bailout(&quot;const section overflow&quot;);
 144     return __ code()-&gt;consts()-&gt;start();
 145   } else {
 146     return const_addr;
 147   }
 148 }
 149 
 150 
 151 address LIR_Assembler::double_constant(double d) {
 152   address const_addr = __ double_constant(d);
 153   if (const_addr == NULL) {
 154     bailout(&quot;const section overflow&quot;);
 155     return __ code()-&gt;consts()-&gt;start();
 156   } else {
 157     return const_addr;
 158   }
 159 }
 160 
 161 #ifndef _LP64
 162 void LIR_Assembler::fpop() {
 163   __ fpop();
 164 }
 165 
 166 void LIR_Assembler::fxch(int i) {
 167   __ fxch(i);
 168 }
 169 
 170 void LIR_Assembler::fld(int i) {
 171   __ fld_s(i);
 172 }
 173 
 174 void LIR_Assembler::ffree(int i) {
 175   __ ffree(i);
 176 }
 177 #endif // !_LP64
 178 
 179 void LIR_Assembler::breakpoint() {
 180   __ int3();
 181 }
 182 
 183 void LIR_Assembler::push(LIR_Opr opr) {
 184   if (opr-&gt;is_single_cpu()) {
 185     __ push_reg(opr-&gt;as_register());
 186   } else if (opr-&gt;is_double_cpu()) {
 187     NOT_LP64(__ push_reg(opr-&gt;as_register_hi()));
 188     __ push_reg(opr-&gt;as_register_lo());
 189   } else if (opr-&gt;is_stack()) {
 190     __ push_addr(frame_map()-&gt;address_for_slot(opr-&gt;single_stack_ix()));
 191   } else if (opr-&gt;is_constant()) {
 192     LIR_Const* const_opr = opr-&gt;as_constant_ptr();
 193     if (const_opr-&gt;type() == T_OBJECT) {
 194       __ push_oop(const_opr-&gt;as_jobject());
 195     } else if (const_opr-&gt;type() == T_INT) {
 196       __ push_jint(const_opr-&gt;as_jint());
 197     } else {
 198       ShouldNotReachHere();
 199     }
 200 
 201   } else {
 202     ShouldNotReachHere();
 203   }
 204 }
 205 
 206 void LIR_Assembler::pop(LIR_Opr opr) {
 207   if (opr-&gt;is_single_cpu()) {
 208     __ pop_reg(opr-&gt;as_register());
 209   } else {
 210     ShouldNotReachHere();
 211   }
 212 }
 213 
 214 bool LIR_Assembler::is_literal_address(LIR_Address* addr) {
 215   return addr-&gt;base()-&gt;is_illegal() &amp;&amp; addr-&gt;index()-&gt;is_illegal();
 216 }
 217 
 218 //-------------------------------------------
 219 
 220 Address LIR_Assembler::as_Address(LIR_Address* addr) {
 221   return as_Address(addr, rscratch1);
 222 }
 223 
 224 Address LIR_Assembler::as_Address(LIR_Address* addr, Register tmp) {
 225   if (addr-&gt;base()-&gt;is_illegal()) {
 226     assert(addr-&gt;index()-&gt;is_illegal(), &quot;must be illegal too&quot;);
 227     AddressLiteral laddr((address)addr-&gt;disp(), relocInfo::none);
 228     if (! __ reachable(laddr)) {
 229       __ movptr(tmp, laddr.addr());
 230       Address res(tmp, 0);
 231       return res;
 232     } else {
 233       return __ as_Address(laddr);
 234     }
 235   }
 236 
 237   Register base = addr-&gt;base()-&gt;as_pointer_register();
 238 
 239   if (addr-&gt;index()-&gt;is_illegal()) {
 240     return Address( base, addr-&gt;disp());
 241   } else if (addr-&gt;index()-&gt;is_cpu_register()) {
 242     Register index = addr-&gt;index()-&gt;as_pointer_register();
 243     return Address(base, index, (Address::ScaleFactor) addr-&gt;scale(), addr-&gt;disp());
 244   } else if (addr-&gt;index()-&gt;is_constant()) {
 245     intptr_t addr_offset = (addr-&gt;index()-&gt;as_constant_ptr()-&gt;as_jint() &lt;&lt; addr-&gt;scale()) + addr-&gt;disp();
 246     assert(Assembler::is_simm32(addr_offset), &quot;must be&quot;);
 247 
 248     return Address(base, addr_offset);
 249   } else {
 250     Unimplemented();
 251     return Address();
 252   }
 253 }
 254 
 255 
 256 Address LIR_Assembler::as_Address_hi(LIR_Address* addr) {
 257   Address base = as_Address(addr);
 258   return Address(base._base, base._index, base._scale, base._disp + BytesPerWord);
 259 }
 260 
 261 
 262 Address LIR_Assembler::as_Address_lo(LIR_Address* addr) {
 263   return as_Address(addr);
 264 }
 265 
 266 
 267 void LIR_Assembler::osr_entry() {
 268   offsets()-&gt;set_value(CodeOffsets::OSR_Entry, code_offset());
 269   BlockBegin* osr_entry = compilation()-&gt;hir()-&gt;osr_entry();
 270   ValueStack* entry_state = osr_entry-&gt;state();
 271   int number_of_locks = entry_state-&gt;locks_size();
 272 
 273   // we jump here if osr happens with the interpreter
 274   // state set up to continue at the beginning of the
 275   // loop that triggered osr - in particular, we have
 276   // the following registers setup:
 277   //
 278   // rcx: osr buffer
 279   //
 280 
 281   // build frame
 282   ciMethod* m = compilation()-&gt;method();
 283   __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());
 284 
 285   // OSR buffer is
 286   //
 287   // locals[nlocals-1..0]
 288   // monitors[0..number_of_locks]
 289   //
 290   // locals is a direct copy of the interpreter frame so in the osr buffer
 291   // so first slot in the local array is the last local from the interpreter
 292   // and last slot is local[0] (receiver) from the interpreter
 293   //
 294   // Similarly with locks. The first lock slot in the osr buffer is the nth lock
 295   // from the interpreter frame, the nth lock slot in the osr buffer is 0th lock
 296   // in the interpreter frame (the method lock if a sync method)
 297 
 298   // Initialize monitors in the compiled activation.
 299   //   rcx: pointer to osr buffer
 300   //
 301   // All other registers are dead at this point and the locals will be
 302   // copied into place by code emitted in the IR.
 303 
 304   Register OSR_buf = osrBufferPointer()-&gt;as_pointer_register();
 305   { assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), &quot;adjust code below&quot;);
 306     int monitor_offset = BytesPerWord * method()-&gt;max_locals() +
 307       (BasicObjectLock::size() * BytesPerWord) * (number_of_locks - 1);
 308     // SharedRuntime::OSR_migration_begin() packs BasicObjectLocks in
 309     // the OSR buffer using 2 word entries: first the lock and then
 310     // the oop.
 311     for (int i = 0; i &lt; number_of_locks; i++) {
 312       int slot_offset = monitor_offset - ((i * 2) * BytesPerWord);
 313 #ifdef ASSERT
 314       // verify the interpreter&#39;s monitor has a non-null object
 315       {
 316         Label L;
 317         __ cmpptr(Address(OSR_buf, slot_offset + 1*BytesPerWord), (int32_t)NULL_WORD);
 318         __ jcc(Assembler::notZero, L);
 319         __ stop(&quot;locked object is NULL&quot;);
 320         __ bind(L);
 321       }
 322 #endif
 323       __ movptr(rbx, Address(OSR_buf, slot_offset + 0));
 324       __ movptr(frame_map()-&gt;address_for_monitor_lock(i), rbx);
 325       __ movptr(rbx, Address(OSR_buf, slot_offset + 1*BytesPerWord));
 326       __ movptr(frame_map()-&gt;address_for_monitor_object(i), rbx);
 327     }
 328   }
 329 }
 330 
 331 
 332 // inline cache check; done before the frame is built.
 333 int LIR_Assembler::check_icache() {
 334   Register receiver = FrameMap::receiver_opr-&gt;as_register();
 335   Register ic_klass = IC_Klass;
 336   const int ic_cmp_size = LP64_ONLY(10) NOT_LP64(9);
 337   const bool do_post_padding = VerifyOops || UseCompressedClassPointers;
 338   if (!do_post_padding) {
 339     // insert some nops so that the verified entry point is aligned on CodeEntryAlignment
 340     __ align(CodeEntryAlignment, __ offset() + ic_cmp_size);
 341   }
 342   int offset = __ offset();
 343   __ inline_cache_check(receiver, IC_Klass);
 344   assert(__ offset() % CodeEntryAlignment == 0 || do_post_padding, &quot;alignment must be correct&quot;);
 345   if (do_post_padding) {
 346     // force alignment after the cache check.
 347     // It&#39;s been verified to be aligned if !VerifyOops
 348     __ align(CodeEntryAlignment);
 349   }
 350   return offset;
 351 }
 352 
 353 void LIR_Assembler::clinit_barrier(ciMethod* method) {
 354   assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
 355   assert(!method-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
 356 
 357   Label L_skip_barrier;
 358   Register klass = rscratch1;
 359   Register thread = LP64_ONLY( r15_thread ) NOT_LP64( noreg );
 360   assert(thread != noreg, &quot;x86_32 not implemented&quot;);
 361 
 362   __ mov_metadata(klass, method-&gt;holder()-&gt;constant_encoding());
 363   __ clinit_barrier(klass, thread, &amp;L_skip_barrier /*L_fast_path*/);
 364 
 365   __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));
 366 
 367   __ bind(L_skip_barrier);
 368 }
 369 
 370 void LIR_Assembler::jobject2reg_with_patching(Register reg, CodeEmitInfo* info) {
 371   jobject o = NULL;
 372   PatchingStub* patch = new PatchingStub(_masm, patching_id(info));
 373   __ movoop(reg, o);
 374   patching_epilog(patch, lir_patch_normal, reg, info);
 375 }
 376 
 377 void LIR_Assembler::klass2reg_with_patching(Register reg, CodeEmitInfo* info) {
 378   Metadata* o = NULL;
 379   PatchingStub* patch = new PatchingStub(_masm, PatchingStub::load_klass_id);
 380   __ mov_metadata(reg, o);
 381   patching_epilog(patch, lir_patch_normal, reg, info);
 382 }
 383 
 384 // This specifies the rsp decrement needed to build the frame
 385 int LIR_Assembler::initial_frame_size_in_bytes() const {
 386   // if rounding, must let FrameMap know!
 387 
 388   // The frame_map records size in slots (32bit word)
 389 
 390   // subtract two words to account for return address and link
 391   return (frame_map()-&gt;framesize() - (2*VMRegImpl::slots_per_word))  * VMRegImpl::stack_slot_size;
 392 }
 393 
 394 
 395 int LIR_Assembler::emit_exception_handler() {
 396   // if the last instruction is a call (typically to do a throw which
 397   // is coming at the end after block reordering) the return address
 398   // must still point into the code area in order to avoid assertion
 399   // failures when searching for the corresponding bci =&gt; add a nop
 400   // (was bug 5/14/1999 - gri)
 401   __ nop();
 402 
 403   // generate code for exception handler
 404   address handler_base = __ start_a_stub(exception_handler_size());
 405   if (handler_base == NULL) {
 406     // not enough space left for the handler
 407     bailout(&quot;exception handler overflow&quot;);
 408     return -1;
 409   }
 410 
 411   int offset = code_offset();
 412 
 413   // the exception oop and pc are in rax, and rdx
 414   // no other registers need to be preserved, so invalidate them
 415   __ invalidate_registers(false, true, true, false, true, true);
 416 
 417   // check that there is really an exception
 418   __ verify_not_null_oop(rax);
 419 
 420   // search an exception handler (rax: exception oop, rdx: throwing pc)
 421   __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::handle_exception_from_callee_id)));
 422   __ should_not_reach_here();
 423   guarantee(code_offset() - offset &lt;= exception_handler_size(), &quot;overflow&quot;);
 424   __ end_a_stub();
 425 
 426   return offset;
 427 }
 428 
 429 
 430 // Emit the code to remove the frame from the stack in the exception
 431 // unwind path.
 432 int LIR_Assembler::emit_unwind_handler() {
 433 #ifndef PRODUCT
 434   if (CommentedAssembly) {
 435     _masm-&gt;block_comment(&quot;Unwind handler&quot;);
 436   }
 437 #endif
 438 
 439   int offset = code_offset();
 440 
 441   // Fetch the exception from TLS and clear out exception related thread state
 442   Register thread = NOT_LP64(rsi) LP64_ONLY(r15_thread);
 443   NOT_LP64(__ get_thread(rsi));
 444   __ movptr(rax, Address(thread, JavaThread::exception_oop_offset()));
 445   __ movptr(Address(thread, JavaThread::exception_oop_offset()), (intptr_t)NULL_WORD);
 446   __ movptr(Address(thread, JavaThread::exception_pc_offset()), (intptr_t)NULL_WORD);
 447 
 448   __ bind(_unwind_handler_entry);
 449   __ verify_not_null_oop(rax);
 450   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 451     __ mov(rbx, rax);  // Preserve the exception (rbx is always callee-saved)
 452   }
 453 
 454   // Preform needed unlocking
 455   MonitorExitStub* stub = NULL;
 456   if (method()-&gt;is_synchronized()) {
 457     monitor_address(0, FrameMap::rax_opr);
 458     stub = new MonitorExitStub(FrameMap::rax_opr, true, 0);
 459     __ unlock_object(rdi, rsi, rax, *stub-&gt;entry());
 460     __ bind(*stub-&gt;continuation());
 461   }
 462 
 463   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 464 #ifdef _LP64
 465     __ mov(rdi, r15_thread);
 466     __ mov_metadata(rsi, method()-&gt;constant_encoding());
 467 #else
 468     __ get_thread(rax);
 469     __ movptr(Address(rsp, 0), rax);
 470     __ mov_metadata(Address(rsp, sizeof(void*)), method()-&gt;constant_encoding());
 471 #endif
 472     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit)));
 473   }
 474 
 475   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 476     __ mov(rax, rbx);  // Restore the exception
 477   }
 478 
 479   // remove the activation and dispatch to the unwind handler
 480   __ remove_frame(initial_frame_size_in_bytes());
 481   __ jump(RuntimeAddress(Runtime1::entry_for(Runtime1::unwind_exception_id)));
 482 
 483   // Emit the slow path assembly
 484   if (stub != NULL) {
 485     stub-&gt;emit_code(this);
 486   }
 487 
 488   return offset;
 489 }
 490 
 491 
 492 int LIR_Assembler::emit_deopt_handler() {
 493   // if the last instruction is a call (typically to do a throw which
 494   // is coming at the end after block reordering) the return address
 495   // must still point into the code area in order to avoid assertion
 496   // failures when searching for the corresponding bci =&gt; add a nop
 497   // (was bug 5/14/1999 - gri)
 498   __ nop();
 499 
 500   // generate code for exception handler
 501   address handler_base = __ start_a_stub(deopt_handler_size());
 502   if (handler_base == NULL) {
 503     // not enough space left for the handler
 504     bailout(&quot;deopt handler overflow&quot;);
 505     return -1;
 506   }
 507 
 508   int offset = code_offset();
 509   InternalAddress here(__ pc());
 510 
 511   __ pushptr(here.addr());
 512   __ jump(RuntimeAddress(SharedRuntime::deopt_blob()-&gt;unpack()));
 513   guarantee(code_offset() - offset &lt;= deopt_handler_size(), &quot;overflow&quot;);
 514   __ end_a_stub();
 515 
 516   return offset;
 517 }
 518 
 519 
 520 void LIR_Assembler::return_op(LIR_Opr result) {
 521   assert(result-&gt;is_illegal() || !result-&gt;is_single_cpu() || result-&gt;as_register() == rax, &quot;word returns are in rax,&quot;);
 522   if (!result-&gt;is_illegal() &amp;&amp; result-&gt;is_float_kind() &amp;&amp; !result-&gt;is_xmm_register()) {
 523     assert(result-&gt;fpu() == 0, &quot;result must already be on TOS&quot;);
 524   }
 525 
 526   // Pop the stack before the safepoint code
 527   __ remove_frame(initial_frame_size_in_bytes());
 528 
 529   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
 530     __ reserved_stack_check();
 531   }
 532 
 533   bool result_is_oop = result-&gt;is_valid() ? result-&gt;is_oop() : false;
 534 
 535   // Note: we do not need to round double result; float result has the right precision
 536   // the poll sets the condition code, but no data registers
 537 
 538   if (SafepointMechanism::uses_thread_local_poll()) {
 539 #ifdef _LP64
 540     const Register poll_addr = rscratch1;
 541     __ movptr(poll_addr, Address(r15_thread, Thread::polling_page_offset()));
 542 #else
 543     const Register poll_addr = rbx;
 544     assert(FrameMap::is_caller_save_register(poll_addr), &quot;will overwrite&quot;);
 545     __ get_thread(poll_addr);
 546     __ movptr(poll_addr, Address(poll_addr, Thread::polling_page_offset()));
 547 #endif
 548     __ relocate(relocInfo::poll_return_type);
 549     __ testl(rax, Address(poll_addr, 0));
 550   } else {
 551     AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_return_type);
 552 
 553     if (Assembler::is_polling_page_far()) {
 554       __ lea(rscratch1, polling_page);
 555       __ relocate(relocInfo::poll_return_type);
 556       __ testl(rax, Address(rscratch1, 0));
 557     } else {
 558       __ testl(rax, polling_page);
 559     }
 560   }
 561   __ ret(0);
 562 }
 563 
 564 
 565 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
 566   guarantee(info != NULL, &quot;Shouldn&#39;t be NULL&quot;);
 567   int offset = __ offset();
 568   if (SafepointMechanism::uses_thread_local_poll()) {
 569 #ifdef _LP64
 570     const Register poll_addr = rscratch1;
 571     __ movptr(poll_addr, Address(r15_thread, Thread::polling_page_offset()));
 572 #else
 573     assert(tmp-&gt;is_cpu_register(), &quot;needed&quot;);
 574     const Register poll_addr = tmp-&gt;as_register();
 575     __ get_thread(poll_addr);
 576     __ movptr(poll_addr, Address(poll_addr, in_bytes(Thread::polling_page_offset())));
 577 #endif
 578     add_debug_info_for_branch(info);
 579     __ relocate(relocInfo::poll_type);
 580     address pre_pc = __ pc();
 581     __ testl(rax, Address(poll_addr, 0));
 582     address post_pc = __ pc();
 583     guarantee(pointer_delta(post_pc, pre_pc, 1) == 2 LP64_ONLY(+1), &quot;must be exact length&quot;);
 584   } else {
 585     AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_type);
 586     if (Assembler::is_polling_page_far()) {
 587       __ lea(rscratch1, polling_page);
 588       offset = __ offset();
 589       add_debug_info_for_branch(info);
 590       __ relocate(relocInfo::poll_type);
 591       __ testl(rax, Address(rscratch1, 0));
 592     } else {
 593       add_debug_info_for_branch(info);
 594       __ testl(rax, polling_page);
 595     }
 596   }
 597   return offset;
 598 }
 599 
 600 
 601 void LIR_Assembler::move_regs(Register from_reg, Register to_reg) {
 602   if (from_reg != to_reg) __ mov(to_reg, from_reg);
 603 }
 604 
 605 void LIR_Assembler::swap_reg(Register a, Register b) {
 606   __ xchgptr(a, b);
 607 }
 608 
 609 
 610 void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
 611   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 612   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 613   LIR_Const* c = src-&gt;as_constant_ptr();
 614 
 615   switch (c-&gt;type()) {
 616     case T_INT: {
 617       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 618       __ movl(dest-&gt;as_register(), c-&gt;as_jint());
 619       break;
 620     }
 621 
 622     case T_ADDRESS: {
 623       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 624       __ movptr(dest-&gt;as_register(), c-&gt;as_jint());
 625       break;
 626     }
 627 
 628     case T_LONG: {
 629       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 630 #ifdef _LP64
 631       __ movptr(dest-&gt;as_register_lo(), (intptr_t)c-&gt;as_jlong());
 632 #else
 633       __ movptr(dest-&gt;as_register_lo(), c-&gt;as_jint_lo());
 634       __ movptr(dest-&gt;as_register_hi(), c-&gt;as_jint_hi());
 635 #endif // _LP64
 636       break;
 637     }
 638 
 639     case T_OBJECT: {
 640       if (patch_code != lir_patch_none) {
 641         jobject2reg_with_patching(dest-&gt;as_register(), info);
 642       } else {
 643         __ movoop(dest-&gt;as_register(), c-&gt;as_jobject());
 644       }
 645       break;
 646     }
 647 
 648     case T_METADATA: {
 649       if (patch_code != lir_patch_none) {
 650         klass2reg_with_patching(dest-&gt;as_register(), info);
 651       } else {
 652         __ mov_metadata(dest-&gt;as_register(), c-&gt;as_metadata());
 653       }
 654       break;
 655     }
 656 
 657     case T_FLOAT: {
 658       if (dest-&gt;is_single_xmm()) {
 659         if (LP64_ONLY(UseAVX &lt;= 2 &amp;&amp;) c-&gt;is_zero_float()) {
 660           __ xorps(dest-&gt;as_xmm_float_reg(), dest-&gt;as_xmm_float_reg());
 661         } else {
 662           __ movflt(dest-&gt;as_xmm_float_reg(),
 663                    InternalAddress(float_constant(c-&gt;as_jfloat())));
 664         }
 665       } else {
 666 #ifndef _LP64
 667         assert(dest-&gt;is_single_fpu(), &quot;must be&quot;);
 668         assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
 669         if (c-&gt;is_zero_float()) {
 670           __ fldz();
 671         } else if (c-&gt;is_one_float()) {
 672           __ fld1();
 673         } else {
 674           __ fld_s (InternalAddress(float_constant(c-&gt;as_jfloat())));
 675         }
 676 #else
 677         ShouldNotReachHere();
 678 #endif // !_LP64
 679       }
 680       break;
 681     }
 682 
 683     case T_DOUBLE: {
 684       if (dest-&gt;is_double_xmm()) {
 685         if (LP64_ONLY(UseAVX &lt;= 2 &amp;&amp;) c-&gt;is_zero_double()) {
 686           __ xorpd(dest-&gt;as_xmm_double_reg(), dest-&gt;as_xmm_double_reg());
 687         } else {
 688           __ movdbl(dest-&gt;as_xmm_double_reg(),
 689                     InternalAddress(double_constant(c-&gt;as_jdouble())));
 690         }
 691       } else {
 692 #ifndef _LP64
 693         assert(dest-&gt;is_double_fpu(), &quot;must be&quot;);
 694         assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
 695         if (c-&gt;is_zero_double()) {
 696           __ fldz();
 697         } else if (c-&gt;is_one_double()) {
 698           __ fld1();
 699         } else {
 700           __ fld_d (InternalAddress(double_constant(c-&gt;as_jdouble())));
 701         }
 702 #else
 703         ShouldNotReachHere();
 704 #endif // !_LP64
 705       }
 706       break;
 707     }
 708 
 709     default:
 710       ShouldNotReachHere();
 711   }
 712 }
 713 
 714 void LIR_Assembler::const2stack(LIR_Opr src, LIR_Opr dest) {
 715   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 716   assert(dest-&gt;is_stack(), &quot;should not call otherwise&quot;);
 717   LIR_Const* c = src-&gt;as_constant_ptr();
 718 
 719   switch (c-&gt;type()) {
 720     case T_INT:  // fall through
 721     case T_FLOAT:
 722       __ movl(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jint_bits());
 723       break;
 724 
 725     case T_ADDRESS:
 726       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jint_bits());
 727       break;
 728 
 729     case T_OBJECT:
 730       __ movoop(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jobject());
 731       break;
 732 
 733     case T_LONG:  // fall through
 734     case T_DOUBLE:
 735 #ifdef _LP64
 736       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 737                                             lo_word_offset_in_bytes), (intptr_t)c-&gt;as_jlong_bits());
 738 #else
 739       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 740                                               lo_word_offset_in_bytes), c-&gt;as_jint_lo_bits());
 741       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 742                                               hi_word_offset_in_bytes), c-&gt;as_jint_hi_bits());
 743 #endif // _LP64
 744       break;
 745 
 746     default:
 747       ShouldNotReachHere();
 748   }
 749 }
 750 
 751 void LIR_Assembler::const2mem(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info, bool wide) {
 752   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 753   assert(dest-&gt;is_address(), &quot;should not call otherwise&quot;);
 754   LIR_Const* c = src-&gt;as_constant_ptr();
 755   LIR_Address* addr = dest-&gt;as_address_ptr();
 756 
 757   int null_check_here = code_offset();
 758   switch (type) {
 759     case T_INT:    // fall through
 760     case T_FLOAT:
 761       __ movl(as_Address(addr), c-&gt;as_jint_bits());
 762       break;
 763 
 764     case T_ADDRESS:
 765       __ movptr(as_Address(addr), c-&gt;as_jint_bits());
 766       break;
 767 
 768     case T_OBJECT:  // fall through
 769     case T_ARRAY:
 770       if (c-&gt;as_jobject() == NULL) {
 771         if (UseCompressedOops &amp;&amp; !wide) {
 772           __ movl(as_Address(addr), (int32_t)NULL_WORD);
 773         } else {
 774 #ifdef _LP64
 775           __ xorptr(rscratch1, rscratch1);
 776           null_check_here = code_offset();
 777           __ movptr(as_Address(addr), rscratch1);
 778 #else
 779           __ movptr(as_Address(addr), NULL_WORD);
 780 #endif
 781         }
 782       } else {
 783         if (is_literal_address(addr)) {
 784           ShouldNotReachHere();
 785           __ movoop(as_Address(addr, noreg), c-&gt;as_jobject());
 786         } else {
 787 #ifdef _LP64
 788           __ movoop(rscratch1, c-&gt;as_jobject());
 789           if (UseCompressedOops &amp;&amp; !wide) {
 790             __ encode_heap_oop(rscratch1);
 791             null_check_here = code_offset();
 792             __ movl(as_Address_lo(addr), rscratch1);
 793           } else {
 794             null_check_here = code_offset();
 795             __ movptr(as_Address_lo(addr), rscratch1);
 796           }
 797 #else
 798           __ movoop(as_Address(addr), c-&gt;as_jobject());
 799 #endif
 800         }
 801       }
 802       break;
 803 
 804     case T_LONG:    // fall through
 805     case T_DOUBLE:
 806 #ifdef _LP64
 807       if (is_literal_address(addr)) {
 808         ShouldNotReachHere();
 809         __ movptr(as_Address(addr, r15_thread), (intptr_t)c-&gt;as_jlong_bits());
 810       } else {
 811         __ movptr(r10, (intptr_t)c-&gt;as_jlong_bits());
 812         null_check_here = code_offset();
 813         __ movptr(as_Address_lo(addr), r10);
 814       }
 815 #else
 816       // Always reachable in 32bit so this doesn&#39;t produce useless move literal
 817       __ movptr(as_Address_hi(addr), c-&gt;as_jint_hi_bits());
 818       __ movptr(as_Address_lo(addr), c-&gt;as_jint_lo_bits());
 819 #endif // _LP64
 820       break;
 821 
 822     case T_BOOLEAN: // fall through
 823     case T_BYTE:
 824       __ movb(as_Address(addr), c-&gt;as_jint() &amp; 0xFF);
 825       break;
 826 
 827     case T_CHAR:    // fall through
 828     case T_SHORT:
 829       __ movw(as_Address(addr), c-&gt;as_jint() &amp; 0xFFFF);
 830       break;
 831 
 832     default:
 833       ShouldNotReachHere();
 834   };
 835 
 836   if (info != NULL) {
 837     add_debug_info_for_null_check(null_check_here, info);
 838   }
 839 }
 840 
 841 
 842 void LIR_Assembler::reg2reg(LIR_Opr src, LIR_Opr dest) {
 843   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
 844   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 845 
 846   // move between cpu-registers
 847   if (dest-&gt;is_single_cpu()) {
 848 #ifdef _LP64
 849     if (src-&gt;type() == T_LONG) {
 850       // Can do LONG -&gt; OBJECT
 851       move_regs(src-&gt;as_register_lo(), dest-&gt;as_register());
 852       return;
 853     }
 854 #endif
 855     assert(src-&gt;is_single_cpu(), &quot;must match&quot;);
 856     if (src-&gt;type() == T_OBJECT) {
 857       __ verify_oop(src-&gt;as_register());
 858     }
 859     move_regs(src-&gt;as_register(), dest-&gt;as_register());
 860 
 861   } else if (dest-&gt;is_double_cpu()) {
 862 #ifdef _LP64
 863     if (is_reference_type(src-&gt;type())) {
 864       // Surprising to me but we can see move of a long to t_object
 865       __ verify_oop(src-&gt;as_register());
 866       move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
 867       return;
 868     }
 869 #endif
 870     assert(src-&gt;is_double_cpu(), &quot;must match&quot;);
 871     Register f_lo = src-&gt;as_register_lo();
 872     Register f_hi = src-&gt;as_register_hi();
 873     Register t_lo = dest-&gt;as_register_lo();
 874     Register t_hi = dest-&gt;as_register_hi();
 875 #ifdef _LP64
 876     assert(f_hi == f_lo, &quot;must be same&quot;);
 877     assert(t_hi == t_lo, &quot;must be same&quot;);
 878     move_regs(f_lo, t_lo);
 879 #else
 880     assert(f_lo != f_hi &amp;&amp; t_lo != t_hi, &quot;invalid register allocation&quot;);
 881 
 882 
 883     if (f_lo == t_hi &amp;&amp; f_hi == t_lo) {
 884       swap_reg(f_lo, f_hi);
 885     } else if (f_hi == t_lo) {
 886       assert(f_lo != t_hi, &quot;overwriting register&quot;);
 887       move_regs(f_hi, t_hi);
 888       move_regs(f_lo, t_lo);
 889     } else {
 890       assert(f_hi != t_lo, &quot;overwriting register&quot;);
 891       move_regs(f_lo, t_lo);
 892       move_regs(f_hi, t_hi);
 893     }
 894 #endif // LP64
 895 
 896 #ifndef _LP64
 897     // special moves from fpu-register to xmm-register
 898     // necessary for method results
 899   } else if (src-&gt;is_single_xmm() &amp;&amp; !dest-&gt;is_single_xmm()) {
 900     __ movflt(Address(rsp, 0), src-&gt;as_xmm_float_reg());
 901     __ fld_s(Address(rsp, 0));
 902   } else if (src-&gt;is_double_xmm() &amp;&amp; !dest-&gt;is_double_xmm()) {
 903     __ movdbl(Address(rsp, 0), src-&gt;as_xmm_double_reg());
 904     __ fld_d(Address(rsp, 0));
 905   } else if (dest-&gt;is_single_xmm() &amp;&amp; !src-&gt;is_single_xmm()) {
 906     __ fstp_s(Address(rsp, 0));
 907     __ movflt(dest-&gt;as_xmm_float_reg(), Address(rsp, 0));
 908   } else if (dest-&gt;is_double_xmm() &amp;&amp; !src-&gt;is_double_xmm()) {
 909     __ fstp_d(Address(rsp, 0));
 910     __ movdbl(dest-&gt;as_xmm_double_reg(), Address(rsp, 0));
 911 
 912   // move between fpu-registers (no instruction necessary because of fpu-stack)
 913   } else if (dest-&gt;is_single_fpu() || dest-&gt;is_double_fpu()) {
 914     assert(src-&gt;is_single_fpu() || src-&gt;is_double_fpu(), &quot;must match&quot;);
 915     assert(src-&gt;fpu() == dest-&gt;fpu(), &quot;currently should be nothing to do&quot;);
 916 #endif // !_LP64
 917 
 918     // move between xmm-registers
 919   } else if (dest-&gt;is_single_xmm()) {
 920     assert(src-&gt;is_single_xmm(), &quot;must match&quot;);
 921     __ movflt(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_float_reg());
 922   } else if (dest-&gt;is_double_xmm()) {
 923     assert(src-&gt;is_double_xmm(), &quot;must match&quot;);
 924     __ movdbl(dest-&gt;as_xmm_double_reg(), src-&gt;as_xmm_double_reg());
 925 
 926   } else {
 927     ShouldNotReachHere();
 928   }
 929 }
 930 
 931 void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {
 932   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
 933   assert(dest-&gt;is_stack(), &quot;should not call otherwise&quot;);
 934 
 935   if (src-&gt;is_single_cpu()) {
 936     Address dst = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 937     if (is_reference_type(type)) {
 938       __ verify_oop(src-&gt;as_register());
 939       __ movptr (dst, src-&gt;as_register());
 940     } else if (type == T_METADATA || type == T_ADDRESS) {
 941       __ movptr (dst, src-&gt;as_register());
 942     } else {
 943       __ movl (dst, src-&gt;as_register());
 944     }
 945 
 946   } else if (src-&gt;is_double_cpu()) {
 947     Address dstLO = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), lo_word_offset_in_bytes);
 948     Address dstHI = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), hi_word_offset_in_bytes);
 949     __ movptr (dstLO, src-&gt;as_register_lo());
 950     NOT_LP64(__ movptr (dstHI, src-&gt;as_register_hi()));
 951 
 952   } else if (src-&gt;is_single_xmm()) {
 953     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 954     __ movflt(dst_addr, src-&gt;as_xmm_float_reg());
 955 
 956   } else if (src-&gt;is_double_xmm()) {
 957     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
 958     __ movdbl(dst_addr, src-&gt;as_xmm_double_reg());
 959 
 960 #ifndef _LP64
 961   } else if (src-&gt;is_single_fpu()) {
 962     assert(src-&gt;fpu_regnr() == 0, &quot;argument must be on TOS&quot;);
 963     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 964     if (pop_fpu_stack)     __ fstp_s (dst_addr);
 965     else                   __ fst_s  (dst_addr);
 966 
 967   } else if (src-&gt;is_double_fpu()) {
 968     assert(src-&gt;fpu_regnrLo() == 0, &quot;argument must be on TOS&quot;);
 969     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
 970     if (pop_fpu_stack)     __ fstp_d (dst_addr);
 971     else                   __ fst_d  (dst_addr);
 972 #endif // !_LP64
 973 
 974   } else {
 975     ShouldNotReachHere();
 976   }
 977 }
 978 
 979 
 980 void LIR_Assembler::reg2mem(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool wide, bool /* unaligned */) {
 981   LIR_Address* to_addr = dest-&gt;as_address_ptr();
 982   PatchingStub* patch = NULL;
 983   Register compressed_src = rscratch1;
 984 
 985   if (is_reference_type(type)) {
 986     __ verify_oop(src-&gt;as_register());
 987 #ifdef _LP64
 988     if (UseCompressedOops &amp;&amp; !wide) {
 989       __ movptr(compressed_src, src-&gt;as_register());
 990       __ encode_heap_oop(compressed_src);
 991       if (patch_code != lir_patch_none) {
 992         info-&gt;oop_map()-&gt;set_narrowoop(compressed_src-&gt;as_VMReg());
 993       }
 994     }
 995 #endif
 996   }
 997 
 998   if (patch_code != lir_patch_none) {
 999     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1000     Address toa = as_Address(to_addr);
1001     assert(toa.disp() != 0, &quot;must have&quot;);
1002   }
1003 
1004   int null_check_here = code_offset();
1005   switch (type) {
1006     case T_FLOAT: {
1007 #ifdef _LP64
1008       assert(src-&gt;is_single_xmm(), &quot;not a float&quot;);
1009       __ movflt(as_Address(to_addr), src-&gt;as_xmm_float_reg());
1010 #else
1011       if (src-&gt;is_single_xmm()) {
1012         __ movflt(as_Address(to_addr), src-&gt;as_xmm_float_reg());
1013       } else {
1014         assert(src-&gt;is_single_fpu(), &quot;must be&quot;);
1015         assert(src-&gt;fpu_regnr() == 0, &quot;argument must be on TOS&quot;);
1016         if (pop_fpu_stack)      __ fstp_s(as_Address(to_addr));
1017         else                    __ fst_s (as_Address(to_addr));
1018       }
1019 #endif // _LP64
1020       break;
1021     }
1022 
1023     case T_DOUBLE: {
1024 #ifdef _LP64
1025       assert(src-&gt;is_double_xmm(), &quot;not a double&quot;);
1026       __ movdbl(as_Address(to_addr), src-&gt;as_xmm_double_reg());
1027 #else
1028       if (src-&gt;is_double_xmm()) {
1029         __ movdbl(as_Address(to_addr), src-&gt;as_xmm_double_reg());
1030       } else {
1031         assert(src-&gt;is_double_fpu(), &quot;must be&quot;);
1032         assert(src-&gt;fpu_regnrLo() == 0, &quot;argument must be on TOS&quot;);
1033         if (pop_fpu_stack)      __ fstp_d(as_Address(to_addr));
1034         else                    __ fst_d (as_Address(to_addr));
1035       }
1036 #endif // _LP64
1037       break;
1038     }
1039 
1040     case T_ARRAY:   // fall through
1041     case T_OBJECT:  // fall through
1042       if (UseCompressedOops &amp;&amp; !wide) {
1043         __ movl(as_Address(to_addr), compressed_src);
1044       } else {
1045         __ movptr(as_Address(to_addr), src-&gt;as_register());
1046       }
1047       break;
1048     case T_METADATA:
1049       // We get here to store a method pointer to the stack to pass to
1050       // a dtrace runtime call. This can&#39;t work on 64 bit with
1051       // compressed klass ptrs: T_METADATA can be a compressed klass
1052       // ptr or a 64 bit method pointer.
1053       LP64_ONLY(ShouldNotReachHere());
1054       __ movptr(as_Address(to_addr), src-&gt;as_register());
1055       break;
1056     case T_ADDRESS:
1057       __ movptr(as_Address(to_addr), src-&gt;as_register());
1058       break;
1059     case T_INT:
1060       __ movl(as_Address(to_addr), src-&gt;as_register());
1061       break;
1062 
1063     case T_LONG: {
1064       Register from_lo = src-&gt;as_register_lo();
1065       Register from_hi = src-&gt;as_register_hi();
1066 #ifdef _LP64
1067       __ movptr(as_Address_lo(to_addr), from_lo);
1068 #else
1069       Register base = to_addr-&gt;base()-&gt;as_register();
1070       Register index = noreg;
1071       if (to_addr-&gt;index()-&gt;is_register()) {
1072         index = to_addr-&gt;index()-&gt;as_register();
1073       }
1074       if (base == from_lo || index == from_lo) {
1075         assert(base != from_hi, &quot;can&#39;t be&quot;);
1076         assert(index == noreg || (index != base &amp;&amp; index != from_hi), &quot;can&#39;t handle this&quot;);
1077         __ movl(as_Address_hi(to_addr), from_hi);
1078         if (patch != NULL) {
1079           patching_epilog(patch, lir_patch_high, base, info);
1080           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1081           patch_code = lir_patch_low;
1082         }
1083         __ movl(as_Address_lo(to_addr), from_lo);
1084       } else {
1085         assert(index == noreg || (index != base &amp;&amp; index != from_lo), &quot;can&#39;t handle this&quot;);
1086         __ movl(as_Address_lo(to_addr), from_lo);
1087         if (patch != NULL) {
1088           patching_epilog(patch, lir_patch_low, base, info);
1089           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1090           patch_code = lir_patch_high;
1091         }
1092         __ movl(as_Address_hi(to_addr), from_hi);
1093       }
1094 #endif // _LP64
1095       break;
1096     }
1097 
1098     case T_BYTE:    // fall through
1099     case T_BOOLEAN: {
1100       Register src_reg = src-&gt;as_register();
1101       Address dst_addr = as_Address(to_addr);
1102       assert(VM_Version::is_P6() || src_reg-&gt;has_byte_register(), &quot;must use byte registers if not P6&quot;);
1103       __ movb(dst_addr, src_reg);
1104       break;
1105     }
1106 
1107     case T_CHAR:    // fall through
1108     case T_SHORT:
1109       __ movw(as_Address(to_addr), src-&gt;as_register());
1110       break;
1111 
1112     default:
1113       ShouldNotReachHere();
1114   }
1115   if (info != NULL) {
1116     add_debug_info_for_null_check(null_check_here, info);
1117   }
1118 
1119   if (patch_code != lir_patch_none) {
1120     patching_epilog(patch, patch_code, to_addr-&gt;base()-&gt;as_register(), info);
1121   }
1122 }
1123 
1124 
1125 void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
1126   assert(src-&gt;is_stack(), &quot;should not call otherwise&quot;);
1127   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
1128 
1129   if (dest-&gt;is_single_cpu()) {
1130     if (is_reference_type(type)) {
1131       __ movptr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
1132       __ verify_oop(dest-&gt;as_register());
1133     } else if (type == T_METADATA || type == T_ADDRESS) {
1134       __ movptr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
1135     } else {
1136       __ movl(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
1137     }
1138 
1139   } else if (dest-&gt;is_double_cpu()) {
1140     Address src_addr_LO = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix(), lo_word_offset_in_bytes);
1141     Address src_addr_HI = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix(), hi_word_offset_in_bytes);
1142     __ movptr(dest-&gt;as_register_lo(), src_addr_LO);
1143     NOT_LP64(__ movptr(dest-&gt;as_register_hi(), src_addr_HI));
1144 
1145   } else if (dest-&gt;is_single_xmm()) {
1146     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1147     __ movflt(dest-&gt;as_xmm_float_reg(), src_addr);
1148 
1149   } else if (dest-&gt;is_double_xmm()) {
1150     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
1151     __ movdbl(dest-&gt;as_xmm_double_reg(), src_addr);
1152 
1153 #ifndef _LP64
1154   } else if (dest-&gt;is_single_fpu()) {
1155     assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
1156     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1157     __ fld_s(src_addr);
1158 
1159   } else if (dest-&gt;is_double_fpu()) {
1160     assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
1161     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
1162     __ fld_d(src_addr);
1163 #endif // _LP64
1164 
1165   } else {
1166     ShouldNotReachHere();
1167   }
1168 }
1169 
1170 
1171 void LIR_Assembler::stack2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {
1172   if (src-&gt;is_single_stack()) {
1173     if (is_reference_type(type)) {
1174       __ pushptr(frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
1175       __ popptr (frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
1176     } else {
1177 #ifndef _LP64
1178       __ pushl(frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
1179       __ popl (frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
1180 #else
1181       //no pushl on 64bits
1182       __ movl(rscratch1, frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
1183       __ movl(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), rscratch1);
1184 #endif
1185     }
1186 
1187   } else if (src-&gt;is_double_stack()) {
1188 #ifdef _LP64
1189     __ pushptr(frame_map()-&gt;address_for_slot(src -&gt;double_stack_ix()));
1190     __ popptr (frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix()));
1191 #else
1192     __ pushl(frame_map()-&gt;address_for_slot(src -&gt;double_stack_ix(), 0));
1193     // push and pop the part at src + wordSize, adding wordSize for the previous push
1194     __ pushl(frame_map()-&gt;address_for_slot(src -&gt;double_stack_ix(), 2 * wordSize));
1195     __ popl (frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), 2 * wordSize));
1196     __ popl (frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), 0));
1197 #endif // _LP64
1198 
1199   } else {
1200     ShouldNotReachHere();
1201   }
1202 }
1203 
1204 
1205 void LIR_Assembler::mem2reg(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide, bool /* unaligned */) {
1206   assert(src-&gt;is_address(), &quot;should not call otherwise&quot;);
1207   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
1208 
1209   LIR_Address* addr = src-&gt;as_address_ptr();
1210   Address from_addr = as_Address(addr);
1211 
1212   if (addr-&gt;base()-&gt;type() == T_OBJECT) {
1213     __ verify_oop(addr-&gt;base()-&gt;as_pointer_register());
1214   }
1215 
1216   switch (type) {
1217     case T_BOOLEAN: // fall through
1218     case T_BYTE:    // fall through
1219     case T_CHAR:    // fall through
1220     case T_SHORT:
1221       if (!VM_Version::is_P6() &amp;&amp; !from_addr.uses(dest-&gt;as_register())) {
1222         // on pre P6 processors we may get partial register stalls
1223         // so blow away the value of to_rinfo before loading a
1224         // partial word into it.  Do it here so that it precedes
1225         // the potential patch point below.
1226         __ xorptr(dest-&gt;as_register(), dest-&gt;as_register());
1227       }
1228       break;
1229    default:
1230      break;
1231   }
1232 
1233   PatchingStub* patch = NULL;
1234   if (patch_code != lir_patch_none) {
1235     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1236     assert(from_addr.disp() != 0, &quot;must have&quot;);
1237   }
1238   if (info != NULL) {
1239     add_debug_info_for_null_check_here(info);
1240   }
1241 
1242   switch (type) {
1243     case T_FLOAT: {
1244       if (dest-&gt;is_single_xmm()) {
1245         __ movflt(dest-&gt;as_xmm_float_reg(), from_addr);
1246       } else {
1247 #ifndef _LP64
1248         assert(dest-&gt;is_single_fpu(), &quot;must be&quot;);
1249         assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
1250         __ fld_s(from_addr);
1251 #else
1252         ShouldNotReachHere();
1253 #endif // !LP64
1254       }
1255       break;
1256     }
1257 
1258     case T_DOUBLE: {
1259       if (dest-&gt;is_double_xmm()) {
1260         __ movdbl(dest-&gt;as_xmm_double_reg(), from_addr);
1261       } else {
1262 #ifndef _LP64
1263         assert(dest-&gt;is_double_fpu(), &quot;must be&quot;);
1264         assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
1265         __ fld_d(from_addr);
1266 #else
1267         ShouldNotReachHere();
1268 #endif // !LP64
1269       }
1270       break;
1271     }
1272 
1273     case T_OBJECT:  // fall through
1274     case T_ARRAY:   // fall through
1275       if (UseCompressedOops &amp;&amp; !wide) {
1276         __ movl(dest-&gt;as_register(), from_addr);
1277       } else {
1278         __ movptr(dest-&gt;as_register(), from_addr);
1279       }
1280       break;
1281 
1282     case T_ADDRESS:
1283       if (UseCompressedClassPointers &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
1284         __ movl(dest-&gt;as_register(), from_addr);
1285       } else {
1286         __ movptr(dest-&gt;as_register(), from_addr);
1287       }
1288       break;
1289     case T_INT:
1290       __ movl(dest-&gt;as_register(), from_addr);
1291       break;
1292 
1293     case T_LONG: {
1294       Register to_lo = dest-&gt;as_register_lo();
1295       Register to_hi = dest-&gt;as_register_hi();
1296 #ifdef _LP64
1297       __ movptr(to_lo, as_Address_lo(addr));
1298 #else
1299       Register base = addr-&gt;base()-&gt;as_register();
1300       Register index = noreg;
1301       if (addr-&gt;index()-&gt;is_register()) {
1302         index = addr-&gt;index()-&gt;as_register();
1303       }
1304       if ((base == to_lo &amp;&amp; index == to_hi) ||
1305           (base == to_hi &amp;&amp; index == to_lo)) {
1306         // addresses with 2 registers are only formed as a result of
1307         // array access so this code will never have to deal with
1308         // patches or null checks.
1309         assert(info == NULL &amp;&amp; patch == NULL, &quot;must be&quot;);
1310         __ lea(to_hi, as_Address(addr));
1311         __ movl(to_lo, Address(to_hi, 0));
1312         __ movl(to_hi, Address(to_hi, BytesPerWord));
1313       } else if (base == to_lo || index == to_lo) {
1314         assert(base != to_hi, &quot;can&#39;t be&quot;);
1315         assert(index == noreg || (index != base &amp;&amp; index != to_hi), &quot;can&#39;t handle this&quot;);
1316         __ movl(to_hi, as_Address_hi(addr));
1317         if (patch != NULL) {
1318           patching_epilog(patch, lir_patch_high, base, info);
1319           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1320           patch_code = lir_patch_low;
1321         }
1322         __ movl(to_lo, as_Address_lo(addr));
1323       } else {
1324         assert(index == noreg || (index != base &amp;&amp; index != to_lo), &quot;can&#39;t handle this&quot;);
1325         __ movl(to_lo, as_Address_lo(addr));
1326         if (patch != NULL) {
1327           patching_epilog(patch, lir_patch_low, base, info);
1328           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1329           patch_code = lir_patch_high;
1330         }
1331         __ movl(to_hi, as_Address_hi(addr));
1332       }
1333 #endif // _LP64
1334       break;
1335     }
1336 
1337     case T_BOOLEAN: // fall through
1338     case T_BYTE: {
1339       Register dest_reg = dest-&gt;as_register();
1340       assert(VM_Version::is_P6() || dest_reg-&gt;has_byte_register(), &quot;must use byte registers if not P6&quot;);
1341       if (VM_Version::is_P6() || from_addr.uses(dest_reg)) {
1342         __ movsbl(dest_reg, from_addr);
1343       } else {
1344         __ movb(dest_reg, from_addr);
1345         __ shll(dest_reg, 24);
1346         __ sarl(dest_reg, 24);
1347       }
1348       break;
1349     }
1350 
1351     case T_CHAR: {
1352       Register dest_reg = dest-&gt;as_register();
1353       assert(VM_Version::is_P6() || dest_reg-&gt;has_byte_register(), &quot;must use byte registers if not P6&quot;);
1354       if (VM_Version::is_P6() || from_addr.uses(dest_reg)) {
1355         __ movzwl(dest_reg, from_addr);
1356       } else {
1357         __ movw(dest_reg, from_addr);
1358       }
1359       break;
1360     }
1361 
1362     case T_SHORT: {
1363       Register dest_reg = dest-&gt;as_register();
1364       if (VM_Version::is_P6() || from_addr.uses(dest_reg)) {
1365         __ movswl(dest_reg, from_addr);
1366       } else {
1367         __ movw(dest_reg, from_addr);
1368         __ shll(dest_reg, 16);
1369         __ sarl(dest_reg, 16);
1370       }
1371       break;
1372     }
1373 
1374     default:
1375       ShouldNotReachHere();
1376   }
1377 
1378   if (patch != NULL) {
1379     patching_epilog(patch, patch_code, addr-&gt;base()-&gt;as_register(), info);
1380   }
1381 
1382   if (is_reference_type(type)) {
1383 #ifdef _LP64
1384     if (UseCompressedOops &amp;&amp; !wide) {
1385       __ decode_heap_oop(dest-&gt;as_register());
1386     }
1387 #endif
1388 
1389     // Load barrier has not yet been applied, so ZGC can&#39;t verify the oop here
1390     if (!UseZGC) {
1391       __ verify_oop(dest-&gt;as_register());
1392     }
1393   } else if (type == T_ADDRESS &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
1394 #ifdef _LP64
1395     if (UseCompressedClassPointers) {
1396       __ decode_klass_not_null(dest-&gt;as_register());
1397     }
1398 #endif
1399   }
1400 }
1401 
1402 
1403 NEEDS_CLEANUP; // This could be static?
1404 Address::ScaleFactor LIR_Assembler::array_element_size(BasicType type) const {
1405   int elem_size = type2aelembytes(type);
1406   switch (elem_size) {
1407     case 1: return Address::times_1;
1408     case 2: return Address::times_2;
1409     case 4: return Address::times_4;
1410     case 8: return Address::times_8;
1411   }
1412   ShouldNotReachHere();
1413   return Address::no_scale;
1414 }
1415 
1416 
1417 void LIR_Assembler::emit_op3(LIR_Op3* op) {
1418   switch (op-&gt;code()) {
1419     case lir_idiv:
1420     case lir_irem:
1421       arithmetic_idiv(op-&gt;code(),
1422                       op-&gt;in_opr1(),
1423                       op-&gt;in_opr2(),
1424                       op-&gt;in_opr3(),
1425                       op-&gt;result_opr(),
1426                       op-&gt;info());
1427       break;
1428     case lir_fmad:
1429       __ fmad(op-&gt;result_opr()-&gt;as_xmm_double_reg(),
1430               op-&gt;in_opr1()-&gt;as_xmm_double_reg(),
1431               op-&gt;in_opr2()-&gt;as_xmm_double_reg(),
1432               op-&gt;in_opr3()-&gt;as_xmm_double_reg());
1433       break;
1434     case lir_fmaf:
1435       __ fmaf(op-&gt;result_opr()-&gt;as_xmm_float_reg(),
1436               op-&gt;in_opr1()-&gt;as_xmm_float_reg(),
1437               op-&gt;in_opr2()-&gt;as_xmm_float_reg(),
1438               op-&gt;in_opr3()-&gt;as_xmm_float_reg());
1439       break;
1440     default:      ShouldNotReachHere(); break;
1441   }
1442 }
1443 
1444 void LIR_Assembler::emit_opBranch(LIR_OpBranch* op) {
1445 #ifdef ASSERT
1446   assert(op-&gt;block() == NULL || op-&gt;block()-&gt;label() == op-&gt;label(), &quot;wrong label&quot;);
1447   if (op-&gt;block() != NULL)  _branch_target_blocks.append(op-&gt;block());
1448   if (op-&gt;ublock() != NULL) _branch_target_blocks.append(op-&gt;ublock());
1449 #endif
1450 
1451   if (op-&gt;cond() == lir_cond_always) {
1452     if (op-&gt;info() != NULL) add_debug_info_for_branch(op-&gt;info());
1453     __ jmp (*(op-&gt;label()));
1454   } else {
1455     Assembler::Condition acond = Assembler::zero;
1456     if (op-&gt;code() == lir_cond_float_branch) {
1457       assert(op-&gt;ublock() != NULL, &quot;must have unordered successor&quot;);
1458       __ jcc(Assembler::parity, *(op-&gt;ublock()-&gt;label()));
1459       switch(op-&gt;cond()) {
1460         case lir_cond_equal:        acond = Assembler::equal;      break;
1461         case lir_cond_notEqual:     acond = Assembler::notEqual;   break;
1462         case lir_cond_less:         acond = Assembler::below;      break;
1463         case lir_cond_lessEqual:    acond = Assembler::belowEqual; break;
1464         case lir_cond_greaterEqual: acond = Assembler::aboveEqual; break;
1465         case lir_cond_greater:      acond = Assembler::above;      break;
1466         default:                         ShouldNotReachHere();
1467       }
1468     } else {
1469       switch (op-&gt;cond()) {
1470         case lir_cond_equal:        acond = Assembler::equal;       break;
1471         case lir_cond_notEqual:     acond = Assembler::notEqual;    break;
1472         case lir_cond_less:         acond = Assembler::less;        break;
1473         case lir_cond_lessEqual:    acond = Assembler::lessEqual;   break;
1474         case lir_cond_greaterEqual: acond = Assembler::greaterEqual;break;
1475         case lir_cond_greater:      acond = Assembler::greater;     break;
1476         case lir_cond_belowEqual:   acond = Assembler::belowEqual;  break;
1477         case lir_cond_aboveEqual:   acond = Assembler::aboveEqual;  break;
1478         default:                         ShouldNotReachHere();
1479       }
1480     }
1481     __ jcc(acond,*(op-&gt;label()));
1482   }
1483 }
1484 
1485 void LIR_Assembler::emit_opConvert(LIR_OpConvert* op) {
1486   LIR_Opr src  = op-&gt;in_opr();
1487   LIR_Opr dest = op-&gt;result_opr();
1488 
1489   switch (op-&gt;bytecode()) {
1490     case Bytecodes::_i2l:
1491 #ifdef _LP64
1492       __ movl2ptr(dest-&gt;as_register_lo(), src-&gt;as_register());
1493 #else
1494       move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
1495       move_regs(src-&gt;as_register(), dest-&gt;as_register_hi());
1496       __ sarl(dest-&gt;as_register_hi(), 31);
1497 #endif // LP64
1498       break;
1499 
1500     case Bytecodes::_l2i:
1501 #ifdef _LP64
1502       __ movl(dest-&gt;as_register(), src-&gt;as_register_lo());
1503 #else
1504       move_regs(src-&gt;as_register_lo(), dest-&gt;as_register());
1505 #endif
1506       break;
1507 
1508     case Bytecodes::_i2b:
1509       move_regs(src-&gt;as_register(), dest-&gt;as_register());
1510       __ sign_extend_byte(dest-&gt;as_register());
1511       break;
1512 
1513     case Bytecodes::_i2c:
1514       move_regs(src-&gt;as_register(), dest-&gt;as_register());
1515       __ andl(dest-&gt;as_register(), 0xFFFF);
1516       break;
1517 
1518     case Bytecodes::_i2s:
1519       move_regs(src-&gt;as_register(), dest-&gt;as_register());
1520       __ sign_extend_short(dest-&gt;as_register());
1521       break;
1522 
1523 
1524 #ifdef _LP64
1525     case Bytecodes::_f2d:
1526       __ cvtss2sd(dest-&gt;as_xmm_double_reg(), src-&gt;as_xmm_float_reg());
1527       break;
1528 
1529     case Bytecodes::_d2f:
1530       __ cvtsd2ss(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_double_reg());
1531       break;
1532 
1533     case Bytecodes::_i2f:
1534       __ cvtsi2ssl(dest-&gt;as_xmm_float_reg(), src-&gt;as_register());
1535       break;
1536 
1537     case Bytecodes::_i2d:
1538       __ cvtsi2sdl(dest-&gt;as_xmm_double_reg(), src-&gt;as_register());
1539       break;
1540 
1541     case Bytecodes::_l2f:
1542       __ cvtsi2ssq(dest-&gt;as_xmm_float_reg(), src-&gt;as_register_lo());
1543       break;
1544 
1545     case Bytecodes::_l2d:
1546       __ cvtsi2sdq(dest-&gt;as_xmm_double_reg(), src-&gt;as_register_lo());
1547       break;
1548 
1549     case Bytecodes::_f2i:
1550       __ convert_f2i(dest-&gt;as_register(), src-&gt;as_xmm_float_reg());
1551       break;
1552 
1553     case Bytecodes::_d2i:
1554       __ convert_d2i(dest-&gt;as_register(), src-&gt;as_xmm_double_reg());
1555       break;
1556 
1557     case Bytecodes::_f2l:
1558       __ convert_f2l(dest-&gt;as_register_lo(), src-&gt;as_xmm_float_reg());
1559       break;
1560 
1561     case Bytecodes::_d2l:
1562       __ convert_d2l(dest-&gt;as_register_lo(), src-&gt;as_xmm_double_reg());
1563       break;
1564 #else
1565     case Bytecodes::_f2d:
1566     case Bytecodes::_d2f:
1567       if (dest-&gt;is_single_xmm()) {
1568         __ cvtsd2ss(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_double_reg());
1569       } else if (dest-&gt;is_double_xmm()) {
1570         __ cvtss2sd(dest-&gt;as_xmm_double_reg(), src-&gt;as_xmm_float_reg());
1571       } else {
1572         assert(src-&gt;fpu() == dest-&gt;fpu(), &quot;register must be equal&quot;);
1573         // do nothing (float result is rounded later through spilling)
1574       }
1575       break;
1576 
1577     case Bytecodes::_i2f:
1578     case Bytecodes::_i2d:
1579       if (dest-&gt;is_single_xmm()) {
1580         __ cvtsi2ssl(dest-&gt;as_xmm_float_reg(), src-&gt;as_register());
1581       } else if (dest-&gt;is_double_xmm()) {
1582         __ cvtsi2sdl(dest-&gt;as_xmm_double_reg(), src-&gt;as_register());
1583       } else {
1584         assert(dest-&gt;fpu() == 0, &quot;result must be on TOS&quot;);
1585         __ movl(Address(rsp, 0), src-&gt;as_register());
1586         __ fild_s(Address(rsp, 0));
1587       }
1588       break;
1589 
1590     case Bytecodes::_l2f:
1591     case Bytecodes::_l2d:
1592       assert(!dest-&gt;is_xmm_register(), &quot;result in xmm register not supported (no SSE instruction present)&quot;);
1593       assert(dest-&gt;fpu() == 0, &quot;result must be on TOS&quot;);
1594       __ movptr(Address(rsp, 0),          src-&gt;as_register_lo());
1595       __ movl(Address(rsp, BytesPerWord), src-&gt;as_register_hi());
1596       __ fild_d(Address(rsp, 0));
1597       // float result is rounded later through spilling
1598 
1599     case Bytecodes::_f2i:
1600     case Bytecodes::_d2i:
1601       if (src-&gt;is_single_xmm()) {
1602         __ cvttss2sil(dest-&gt;as_register(), src-&gt;as_xmm_float_reg());
1603       } else if (src-&gt;is_double_xmm()) {
1604         __ cvttsd2sil(dest-&gt;as_register(), src-&gt;as_xmm_double_reg());
1605       } else {
1606         assert(src-&gt;fpu() == 0, &quot;input must be on TOS&quot;);
1607         __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_trunc()));
1608         __ fist_s(Address(rsp, 0));
1609         __ movl(dest-&gt;as_register(), Address(rsp, 0));
1610         __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
1611       }
1612       // IA32 conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
1613       assert(op-&gt;stub() != NULL, &quot;stub required&quot;);
1614       __ cmpl(dest-&gt;as_register(), 0x80000000);
1615       __ jcc(Assembler::equal, *op-&gt;stub()-&gt;entry());
1616       __ bind(*op-&gt;stub()-&gt;continuation());
1617       break;
1618 
1619     case Bytecodes::_f2l:
1620     case Bytecodes::_d2l:
1621       assert(!src-&gt;is_xmm_register(), &quot;input in xmm register not supported (no SSE instruction present)&quot;);
1622       assert(src-&gt;fpu() == 0, &quot;input must be on TOS&quot;);
1623       assert(dest == FrameMap::long0_opr, &quot;runtime stub places result in these registers&quot;);
1624 
1625       // instruction sequence too long to inline it here
1626       {
1627         __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::fpu2long_stub_id)));
1628       }
1629       break;
1630 #endif // _LP64
1631 
1632     default: ShouldNotReachHere();
1633   }
1634 }
1635 
1636 void LIR_Assembler::emit_alloc_obj(LIR_OpAllocObj* op) {
1637   if (op-&gt;init_check()) {
1638     add_debug_info_for_null_check_here(op-&gt;stub()-&gt;info());
1639     __ cmpb(Address(op-&gt;klass()-&gt;as_register(),
1640                     InstanceKlass::init_state_offset()),
1641                     InstanceKlass::fully_initialized);
1642     __ jcc(Assembler::notEqual, *op-&gt;stub()-&gt;entry());
1643   }
1644   __ allocate_object(op-&gt;obj()-&gt;as_register(),
1645                      op-&gt;tmp1()-&gt;as_register(),
1646                      op-&gt;tmp2()-&gt;as_register(),
1647                      op-&gt;header_size(),
1648                      op-&gt;object_size(),
1649                      op-&gt;klass()-&gt;as_register(),
1650                      *op-&gt;stub()-&gt;entry());
1651   __ bind(*op-&gt;stub()-&gt;continuation());
1652 }
1653 
1654 void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
1655   Register len =  op-&gt;len()-&gt;as_register();
1656   LP64_ONLY( __ movslq(len, len); )
1657 
1658   if (UseSlowPath ||
1659       (!UseFastNewObjectArray &amp;&amp; is_reference_type(op-&gt;type())) ||
1660       (!UseFastNewTypeArray   &amp;&amp; !is_reference_type(op-&gt;type()))) {
1661     __ jmp(*op-&gt;stub()-&gt;entry());
1662   } else {
1663     Register tmp1 = op-&gt;tmp1()-&gt;as_register();
1664     Register tmp2 = op-&gt;tmp2()-&gt;as_register();
1665     Register tmp3 = op-&gt;tmp3()-&gt;as_register();
1666     if (len == tmp1) {
1667       tmp1 = tmp3;
1668     } else if (len == tmp2) {
1669       tmp2 = tmp3;
1670     } else if (len == tmp3) {
1671       // everything is ok
1672     } else {
1673       __ mov(tmp3, len);
1674     }
1675     __ allocate_array(op-&gt;obj()-&gt;as_register(),
1676                       len,
1677                       tmp1,
1678                       tmp2,
1679                       arrayOopDesc::header_size(op-&gt;type()),
1680                       array_element_size(op-&gt;type()),
1681                       op-&gt;klass()-&gt;as_register(),
1682                       *op-&gt;stub()-&gt;entry());
1683   }
1684   __ bind(*op-&gt;stub()-&gt;continuation());
1685 }
1686 
1687 void LIR_Assembler::type_profile_helper(Register mdo,
1688                                         ciMethodData *md, ciProfileData *data,
1689                                         Register recv, Label* update_done) {
1690   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1691     Label next_test;
1692     // See if the receiver is receiver[n].
1693     __ cmpptr(recv, Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i))));
1694     __ jccb(Assembler::notEqual, next_test);
1695     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)));
1696     __ addptr(data_addr, DataLayout::counter_increment);
1697     __ jmp(*update_done);
1698     __ bind(next_test);
1699   }
1700 
1701   // Didn&#39;t find receiver; find next empty slot and fill it in
1702   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1703     Label next_test;
1704     Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)));
1705     __ cmpptr(recv_addr, (intptr_t)NULL_WORD);
1706     __ jccb(Assembler::notEqual, next_test);
1707     __ movptr(recv_addr, recv);
1708     __ movptr(Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i))), DataLayout::counter_increment);
1709     __ jmp(*update_done);
1710     __ bind(next_test);
1711   }
1712 }
1713 
1714 void LIR_Assembler::emit_typecheck_helper(LIR_OpTypeCheck *op, Label* success, Label* failure, Label* obj_is_null) {
1715   // we always need a stub for the failure case.
1716   CodeStub* stub = op-&gt;stub();
1717   Register obj = op-&gt;object()-&gt;as_register();
1718   Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1719   Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1720   Register dst = op-&gt;result_opr()-&gt;as_register();
1721   ciKlass* k = op-&gt;klass();
1722   Register Rtmp1 = noreg;
1723 
1724   // check if it needs to be profiled
1725   ciMethodData* md = NULL;
1726   ciProfileData* data = NULL;
1727 
1728   if (op-&gt;should_profile()) {
1729     ciMethod* method = op-&gt;profiled_method();
1730     assert(method != NULL, &quot;Should have method&quot;);
1731     int bci = op-&gt;profiled_bci();
1732     md = method-&gt;method_data_or_null();
1733     assert(md != NULL, &quot;Sanity&quot;);
1734     data = md-&gt;bci_to_data(bci);
1735     assert(data != NULL,                &quot;need data for type check&quot;);
1736     assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1737   }
1738   Label profile_cast_success, profile_cast_failure;
1739   Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : success;
1740   Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : failure;
1741 
1742   if (obj == k_RInfo) {
1743     k_RInfo = dst;
1744   } else if (obj == klass_RInfo) {
1745     klass_RInfo = dst;
1746   }
1747   if (k-&gt;is_loaded() &amp;&amp; !UseCompressedClassPointers) {
1748     select_different_registers(obj, dst, k_RInfo, klass_RInfo);
1749   } else {
1750     Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1751     select_different_registers(obj, dst, k_RInfo, klass_RInfo, Rtmp1);
1752   }
1753 
1754   assert_different_registers(obj, k_RInfo, klass_RInfo);
1755 
1756   __ cmpptr(obj, (int32_t)NULL_WORD);
1757   if (op-&gt;should_profile()) {
1758     Label not_null;
1759     __ jccb(Assembler::notEqual, not_null);
1760     // Object is null; update MDO and exit
1761     Register mdo  = klass_RInfo;
1762     __ mov_metadata(mdo, md-&gt;constant_encoding());
1763     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()));
1764     int header_bits = BitData::null_seen_byte_constant();
1765     __ orb(data_addr, header_bits);
1766     __ jmp(*obj_is_null);
1767     __ bind(not_null);
1768   } else {
1769     __ jcc(Assembler::equal, *obj_is_null);
1770   }
1771 
1772   if (!k-&gt;is_loaded()) {
1773     klass2reg_with_patching(k_RInfo, op-&gt;info_for_patch());
1774   } else {
1775 #ifdef _LP64
1776     __ mov_metadata(k_RInfo, k-&gt;constant_encoding());
1777 #endif // _LP64
1778   }
1779   __ verify_oop(obj);
1780 
1781   if (op-&gt;fast_check()) {
1782     // get object class
1783     // not a safepoint as obj null check happens earlier
1784 #ifdef _LP64
1785     if (UseCompressedClassPointers) {
1786       __ load_klass(Rtmp1, obj);
1787       __ cmpptr(k_RInfo, Rtmp1);
1788     } else {
1789       __ cmpptr(k_RInfo, Address(obj, oopDesc::klass_offset_in_bytes()));
1790     }
1791 #else
1792     if (k-&gt;is_loaded()) {
1793       __ cmpklass(Address(obj, oopDesc::klass_offset_in_bytes()), k-&gt;constant_encoding());
1794     } else {
1795       __ cmpptr(k_RInfo, Address(obj, oopDesc::klass_offset_in_bytes()));
1796     }
1797 #endif
1798     __ jcc(Assembler::notEqual, *failure_target);
1799     // successful cast, fall through to profile or jump
1800   } else {
1801     // get object class
1802     // not a safepoint as obj null check happens earlier
1803     __ load_klass(klass_RInfo, obj);
1804     if (k-&gt;is_loaded()) {
1805       // See if we get an immediate positive hit
1806 #ifdef _LP64
1807       __ cmpptr(k_RInfo, Address(klass_RInfo, k-&gt;super_check_offset()));
1808 #else
1809       __ cmpklass(Address(klass_RInfo, k-&gt;super_check_offset()), k-&gt;constant_encoding());
1810 #endif // _LP64
1811       if ((juint)in_bytes(Klass::secondary_super_cache_offset()) != k-&gt;super_check_offset()) {
1812         __ jcc(Assembler::notEqual, *failure_target);
1813         // successful cast, fall through to profile or jump
1814       } else {
1815         // See if we get an immediate positive hit
1816         __ jcc(Assembler::equal, *success_target);
1817         // check for self
1818 #ifdef _LP64
1819         __ cmpptr(klass_RInfo, k_RInfo);
1820 #else
1821         __ cmpklass(klass_RInfo, k-&gt;constant_encoding());
1822 #endif // _LP64
1823         __ jcc(Assembler::equal, *success_target);
1824 
1825         __ push(klass_RInfo);
1826 #ifdef _LP64
1827         __ push(k_RInfo);
1828 #else
1829         __ pushklass(k-&gt;constant_encoding());
1830 #endif // _LP64
1831         __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1832         __ pop(klass_RInfo);
1833         __ pop(klass_RInfo);
1834         // result is a boolean
1835         __ cmpl(klass_RInfo, 0);
1836         __ jcc(Assembler::equal, *failure_target);
1837         // successful cast, fall through to profile or jump
1838       }
1839     } else {
1840       // perform the fast part of the checking logic
1841       __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1842       // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1843       __ push(klass_RInfo);
1844       __ push(k_RInfo);
1845       __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1846       __ pop(klass_RInfo);
1847       __ pop(k_RInfo);
1848       // result is a boolean
1849       __ cmpl(k_RInfo, 0);
1850       __ jcc(Assembler::equal, *failure_target);
1851       // successful cast, fall through to profile or jump
1852     }
1853   }
1854   if (op-&gt;should_profile()) {
1855     Register mdo  = klass_RInfo, recv = k_RInfo;
1856     __ bind(profile_cast_success);
1857     __ mov_metadata(mdo, md-&gt;constant_encoding());
1858     __ load_klass(recv, obj);
1859     type_profile_helper(mdo, md, data, recv, success);
1860     __ jmp(*success);
1861 
1862     __ bind(profile_cast_failure);
1863     __ mov_metadata(mdo, md-&gt;constant_encoding());
1864     Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
1865     __ subptr(counter_addr, DataLayout::counter_increment);
1866     __ jmp(*failure);
1867   }
1868   __ jmp(*success);
1869 }
1870 
1871 
1872 void LIR_Assembler::emit_opTypeCheck(LIR_OpTypeCheck* op) {
1873   LIR_Code code = op-&gt;code();
1874   if (code == lir_store_check) {
1875     Register value = op-&gt;object()-&gt;as_register();
1876     Register array = op-&gt;array()-&gt;as_register();
1877     Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1878     Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1879     Register Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1880 
1881     CodeStub* stub = op-&gt;stub();
1882 
1883     // check if it needs to be profiled
1884     ciMethodData* md = NULL;
1885     ciProfileData* data = NULL;
1886 
1887     if (op-&gt;should_profile()) {
1888       ciMethod* method = op-&gt;profiled_method();
1889       assert(method != NULL, &quot;Should have method&quot;);
1890       int bci = op-&gt;profiled_bci();
1891       md = method-&gt;method_data_or_null();
1892       assert(md != NULL, &quot;Sanity&quot;);
1893       data = md-&gt;bci_to_data(bci);
1894       assert(data != NULL,                &quot;need data for type check&quot;);
1895       assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1896     }
1897     Label profile_cast_success, profile_cast_failure, done;
1898     Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : &amp;done;
1899     Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : stub-&gt;entry();
1900 
1901     __ cmpptr(value, (int32_t)NULL_WORD);
1902     if (op-&gt;should_profile()) {
1903       Label not_null;
1904       __ jccb(Assembler::notEqual, not_null);
1905       // Object is null; update MDO and exit
1906       Register mdo  = klass_RInfo;
1907       __ mov_metadata(mdo, md-&gt;constant_encoding());
1908       Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()));
1909       int header_bits = BitData::null_seen_byte_constant();
1910       __ orb(data_addr, header_bits);
1911       __ jmp(done);
1912       __ bind(not_null);
1913     } else {
1914       __ jcc(Assembler::equal, done);
1915     }
1916 
1917     add_debug_info_for_null_check_here(op-&gt;info_for_exception());
1918     __ load_klass(k_RInfo, array);
1919     __ load_klass(klass_RInfo, value);
1920 
1921     // get instance klass (it&#39;s already uncompressed)
1922     __ movptr(k_RInfo, Address(k_RInfo, ObjArrayKlass::element_klass_offset()));
1923     // perform the fast part of the checking logic
1924     __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1925     // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1926     __ push(klass_RInfo);
1927     __ push(k_RInfo);
1928     __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1929     __ pop(klass_RInfo);
1930     __ pop(k_RInfo);
1931     // result is a boolean
1932     __ cmpl(k_RInfo, 0);
1933     __ jcc(Assembler::equal, *failure_target);
1934     // fall through to the success case
1935 
1936     if (op-&gt;should_profile()) {
1937       Register mdo  = klass_RInfo, recv = k_RInfo;
1938       __ bind(profile_cast_success);
1939       __ mov_metadata(mdo, md-&gt;constant_encoding());
1940       __ load_klass(recv, value);
1941       type_profile_helper(mdo, md, data, recv, &amp;done);
1942       __ jmpb(done);
1943 
1944       __ bind(profile_cast_failure);
1945       __ mov_metadata(mdo, md-&gt;constant_encoding());
1946       Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
1947       __ subptr(counter_addr, DataLayout::counter_increment);
1948       __ jmp(*stub-&gt;entry());
1949     }
1950 
1951     __ bind(done);
1952   } else
1953     if (code == lir_checkcast) {
1954       Register obj = op-&gt;object()-&gt;as_register();
1955       Register dst = op-&gt;result_opr()-&gt;as_register();
1956       Label success;
1957       emit_typecheck_helper(op, &amp;success, op-&gt;stub()-&gt;entry(), &amp;success);
1958       __ bind(success);
1959       if (dst != obj) {
1960         __ mov(dst, obj);
1961       }
1962     } else
1963       if (code == lir_instanceof) {
1964         Register obj = op-&gt;object()-&gt;as_register();
1965         Register dst = op-&gt;result_opr()-&gt;as_register();
1966         Label success, failure, done;
1967         emit_typecheck_helper(op, &amp;success, &amp;failure, &amp;failure);
1968         __ bind(failure);
1969         __ xorptr(dst, dst);
1970         __ jmpb(done);
1971         __ bind(success);
1972         __ movptr(dst, 1);
1973         __ bind(done);
1974       } else {
1975         ShouldNotReachHere();
1976       }
1977 
1978 }
1979 
1980 
1981 void LIR_Assembler::emit_compare_and_swap(LIR_OpCompareAndSwap* op) {
1982   if (LP64_ONLY(false &amp;&amp;) op-&gt;code() == lir_cas_long &amp;&amp; VM_Version::supports_cx8()) {
1983     assert(op-&gt;cmp_value()-&gt;as_register_lo() == rax, &quot;wrong register&quot;);
1984     assert(op-&gt;cmp_value()-&gt;as_register_hi() == rdx, &quot;wrong register&quot;);
1985     assert(op-&gt;new_value()-&gt;as_register_lo() == rbx, &quot;wrong register&quot;);
1986     assert(op-&gt;new_value()-&gt;as_register_hi() == rcx, &quot;wrong register&quot;);
1987     Register addr = op-&gt;addr()-&gt;as_register();
1988     __ lock();
1989     NOT_LP64(__ cmpxchg8(Address(addr, 0)));
1990 
1991   } else if (op-&gt;code() == lir_cas_int || op-&gt;code() == lir_cas_obj ) {
1992     NOT_LP64(assert(op-&gt;addr()-&gt;is_single_cpu(), &quot;must be single&quot;);)
1993     Register addr = (op-&gt;addr()-&gt;is_single_cpu() ? op-&gt;addr()-&gt;as_register() : op-&gt;addr()-&gt;as_register_lo());
1994     Register newval = op-&gt;new_value()-&gt;as_register();
1995     Register cmpval = op-&gt;cmp_value()-&gt;as_register();
1996     assert(cmpval == rax, &quot;wrong register&quot;);
1997     assert(newval != NULL, &quot;new val must be register&quot;);
1998     assert(cmpval != newval, &quot;cmp and new values must be in different registers&quot;);
1999     assert(cmpval != addr, &quot;cmp and addr must be in different registers&quot;);
2000     assert(newval != addr, &quot;new value and addr must be in different registers&quot;);
2001 
2002     if ( op-&gt;code() == lir_cas_obj) {
2003 #ifdef _LP64
2004       if (UseCompressedOops) {
2005         __ encode_heap_oop(cmpval);
2006         __ mov(rscratch1, newval);
2007         __ encode_heap_oop(rscratch1);
2008         __ lock();
2009         // cmpval (rax) is implicitly used by this instruction
2010         __ cmpxchgl(rscratch1, Address(addr, 0));
2011       } else
2012 #endif
2013       {
2014         __ lock();
2015         __ cmpxchgptr(newval, Address(addr, 0));
2016       }
2017     } else {
2018       assert(op-&gt;code() == lir_cas_int, &quot;lir_cas_int expected&quot;);
2019       __ lock();
2020       __ cmpxchgl(newval, Address(addr, 0));
2021     }
2022 #ifdef _LP64
2023   } else if (op-&gt;code() == lir_cas_long) {
2024     Register addr = (op-&gt;addr()-&gt;is_single_cpu() ? op-&gt;addr()-&gt;as_register() : op-&gt;addr()-&gt;as_register_lo());
2025     Register newval = op-&gt;new_value()-&gt;as_register_lo();
2026     Register cmpval = op-&gt;cmp_value()-&gt;as_register_lo();
2027     assert(cmpval == rax, &quot;wrong register&quot;);
2028     assert(newval != NULL, &quot;new val must be register&quot;);
2029     assert(cmpval != newval, &quot;cmp and new values must be in different registers&quot;);
2030     assert(cmpval != addr, &quot;cmp and addr must be in different registers&quot;);
2031     assert(newval != addr, &quot;new value and addr must be in different registers&quot;);
2032     __ lock();
2033     __ cmpxchgq(newval, Address(addr, 0));
2034 #endif // _LP64
2035   } else {
2036     Unimplemented();
2037   }
2038 }
2039 
2040 void LIR_Assembler::cmove(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr result, BasicType type) {
2041   Assembler::Condition acond, ncond;
2042   switch (condition) {
2043     case lir_cond_equal:        acond = Assembler::equal;        ncond = Assembler::notEqual;     break;
2044     case lir_cond_notEqual:     acond = Assembler::notEqual;     ncond = Assembler::equal;        break;
2045     case lir_cond_less:         acond = Assembler::less;         ncond = Assembler::greaterEqual; break;
2046     case lir_cond_lessEqual:    acond = Assembler::lessEqual;    ncond = Assembler::greater;      break;
2047     case lir_cond_greaterEqual: acond = Assembler::greaterEqual; ncond = Assembler::less;         break;
2048     case lir_cond_greater:      acond = Assembler::greater;      ncond = Assembler::lessEqual;    break;
2049     case lir_cond_belowEqual:   acond = Assembler::belowEqual;   ncond = Assembler::above;        break;
2050     case lir_cond_aboveEqual:   acond = Assembler::aboveEqual;   ncond = Assembler::below;        break;
2051     default:                    acond = Assembler::equal;        ncond = Assembler::notEqual;
2052                                 ShouldNotReachHere();
2053   }
2054 
2055   if (opr1-&gt;is_cpu_register()) {
2056     reg2reg(opr1, result);
2057   } else if (opr1-&gt;is_stack()) {
2058     stack2reg(opr1, result, result-&gt;type());
2059   } else if (opr1-&gt;is_constant()) {
2060     const2reg(opr1, result, lir_patch_none, NULL);
2061   } else {
2062     ShouldNotReachHere();
2063   }
2064 
2065   if (VM_Version::supports_cmov() &amp;&amp; !opr2-&gt;is_constant()) {
2066     // optimized version that does not require a branch
2067     if (opr2-&gt;is_single_cpu()) {
2068       assert(opr2-&gt;cpu_regnr() != result-&gt;cpu_regnr(), &quot;opr2 already overwritten by previous move&quot;);
2069       __ cmov(ncond, result-&gt;as_register(), opr2-&gt;as_register());
2070     } else if (opr2-&gt;is_double_cpu()) {
2071       assert(opr2-&gt;cpu_regnrLo() != result-&gt;cpu_regnrLo() &amp;&amp; opr2-&gt;cpu_regnrLo() != result-&gt;cpu_regnrHi(), &quot;opr2 already overwritten by previous move&quot;);
2072       assert(opr2-&gt;cpu_regnrHi() != result-&gt;cpu_regnrLo() &amp;&amp; opr2-&gt;cpu_regnrHi() != result-&gt;cpu_regnrHi(), &quot;opr2 already overwritten by previous move&quot;);
2073       __ cmovptr(ncond, result-&gt;as_register_lo(), opr2-&gt;as_register_lo());
2074       NOT_LP64(__ cmovptr(ncond, result-&gt;as_register_hi(), opr2-&gt;as_register_hi());)
2075     } else if (opr2-&gt;is_single_stack()) {
2076       __ cmovl(ncond, result-&gt;as_register(), frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2077     } else if (opr2-&gt;is_double_stack()) {
2078       __ cmovptr(ncond, result-&gt;as_register_lo(), frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix(), lo_word_offset_in_bytes));
2079       NOT_LP64(__ cmovptr(ncond, result-&gt;as_register_hi(), frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix(), hi_word_offset_in_bytes));)
2080     } else {
2081       ShouldNotReachHere();
2082     }
2083 
2084   } else {
2085     Label skip;
2086     __ jcc (acond, skip);
2087     if (opr2-&gt;is_cpu_register()) {
2088       reg2reg(opr2, result);
2089     } else if (opr2-&gt;is_stack()) {
2090       stack2reg(opr2, result, result-&gt;type());
2091     } else if (opr2-&gt;is_constant()) {
2092       const2reg(opr2, result, lir_patch_none, NULL);
2093     } else {
2094       ShouldNotReachHere();
2095     }
2096     __ bind(skip);
2097   }
2098 }
2099 
2100 
2101 void LIR_Assembler::arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest, CodeEmitInfo* info, bool pop_fpu_stack) {
2102   assert(info == NULL, &quot;should never be used, idiv/irem and ldiv/lrem not handled by this method&quot;);
2103 
2104   if (left-&gt;is_single_cpu()) {
2105     assert(left == dest, &quot;left and dest must be equal&quot;);
2106     Register lreg = left-&gt;as_register();
2107 
2108     if (right-&gt;is_single_cpu()) {
2109       // cpu register - cpu register
2110       Register rreg = right-&gt;as_register();
2111       switch (code) {
2112         case lir_add: __ addl (lreg, rreg); break;
2113         case lir_sub: __ subl (lreg, rreg); break;
2114         case lir_mul: __ imull(lreg, rreg); break;
2115         default:      ShouldNotReachHere();
2116       }
2117 
2118     } else if (right-&gt;is_stack()) {
2119       // cpu register - stack
2120       Address raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2121       switch (code) {
2122         case lir_add: __ addl(lreg, raddr); break;
2123         case lir_sub: __ subl(lreg, raddr); break;
2124         default:      ShouldNotReachHere();
2125       }
2126 
2127     } else if (right-&gt;is_constant()) {
2128       // cpu register - constant
2129       jint c = right-&gt;as_constant_ptr()-&gt;as_jint();
2130       switch (code) {
2131         case lir_add: {
2132           __ incrementl(lreg, c);
2133           break;
2134         }
2135         case lir_sub: {
2136           __ decrementl(lreg, c);
2137           break;
2138         }
2139         default: ShouldNotReachHere();
2140       }
2141 
2142     } else {
2143       ShouldNotReachHere();
2144     }
2145 
2146   } else if (left-&gt;is_double_cpu()) {
2147     assert(left == dest, &quot;left and dest must be equal&quot;);
2148     Register lreg_lo = left-&gt;as_register_lo();
2149     Register lreg_hi = left-&gt;as_register_hi();
2150 
2151     if (right-&gt;is_double_cpu()) {
2152       // cpu register - cpu register
2153       Register rreg_lo = right-&gt;as_register_lo();
2154       Register rreg_hi = right-&gt;as_register_hi();
2155       NOT_LP64(assert_different_registers(lreg_lo, lreg_hi, rreg_lo, rreg_hi));
2156       LP64_ONLY(assert_different_registers(lreg_lo, rreg_lo));
2157       switch (code) {
2158         case lir_add:
2159           __ addptr(lreg_lo, rreg_lo);
2160           NOT_LP64(__ adcl(lreg_hi, rreg_hi));
2161           break;
2162         case lir_sub:
2163           __ subptr(lreg_lo, rreg_lo);
2164           NOT_LP64(__ sbbl(lreg_hi, rreg_hi));
2165           break;
2166         case lir_mul:
2167 #ifdef _LP64
2168           __ imulq(lreg_lo, rreg_lo);
2169 #else
2170           assert(lreg_lo == rax &amp;&amp; lreg_hi == rdx, &quot;must be&quot;);
2171           __ imull(lreg_hi, rreg_lo);
2172           __ imull(rreg_hi, lreg_lo);
2173           __ addl (rreg_hi, lreg_hi);
2174           __ mull (rreg_lo);
2175           __ addl (lreg_hi, rreg_hi);
2176 #endif // _LP64
2177           break;
2178         default:
2179           ShouldNotReachHere();
2180       }
2181 
2182     } else if (right-&gt;is_constant()) {
2183       // cpu register - constant
2184 #ifdef _LP64
2185       jlong c = right-&gt;as_constant_ptr()-&gt;as_jlong_bits();
2186       __ movptr(r10, (intptr_t) c);
2187       switch (code) {
2188         case lir_add:
2189           __ addptr(lreg_lo, r10);
2190           break;
2191         case lir_sub:
2192           __ subptr(lreg_lo, r10);
2193           break;
2194         default:
2195           ShouldNotReachHere();
2196       }
2197 #else
2198       jint c_lo = right-&gt;as_constant_ptr()-&gt;as_jint_lo();
2199       jint c_hi = right-&gt;as_constant_ptr()-&gt;as_jint_hi();
2200       switch (code) {
2201         case lir_add:
2202           __ addptr(lreg_lo, c_lo);
2203           __ adcl(lreg_hi, c_hi);
2204           break;
2205         case lir_sub:
2206           __ subptr(lreg_lo, c_lo);
2207           __ sbbl(lreg_hi, c_hi);
2208           break;
2209         default:
2210           ShouldNotReachHere();
2211       }
2212 #endif // _LP64
2213 
2214     } else {
2215       ShouldNotReachHere();
2216     }
2217 
2218   } else if (left-&gt;is_single_xmm()) {
2219     assert(left == dest, &quot;left and dest must be equal&quot;);
2220     XMMRegister lreg = left-&gt;as_xmm_float_reg();
2221 
2222     if (right-&gt;is_single_xmm()) {
2223       XMMRegister rreg = right-&gt;as_xmm_float_reg();
2224       switch (code) {
2225         case lir_add: __ addss(lreg, rreg);  break;
2226         case lir_sub: __ subss(lreg, rreg);  break;
2227         case lir_mul_strictfp: // fall through
2228         case lir_mul: __ mulss(lreg, rreg);  break;
2229         case lir_div_strictfp: // fall through
2230         case lir_div: __ divss(lreg, rreg);  break;
2231         default: ShouldNotReachHere();
2232       }
2233     } else {
2234       Address raddr;
2235       if (right-&gt;is_single_stack()) {
2236         raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2237       } else if (right-&gt;is_constant()) {
2238         // hack for now
2239         raddr = __ as_Address(InternalAddress(float_constant(right-&gt;as_jfloat())));
2240       } else {
2241         ShouldNotReachHere();
2242       }
2243       switch (code) {
2244         case lir_add: __ addss(lreg, raddr);  break;
2245         case lir_sub: __ subss(lreg, raddr);  break;
2246         case lir_mul_strictfp: // fall through
2247         case lir_mul: __ mulss(lreg, raddr);  break;
2248         case lir_div_strictfp: // fall through
2249         case lir_div: __ divss(lreg, raddr);  break;
2250         default: ShouldNotReachHere();
2251       }
2252     }
2253 
2254   } else if (left-&gt;is_double_xmm()) {
2255     assert(left == dest, &quot;left and dest must be equal&quot;);
2256 
2257     XMMRegister lreg = left-&gt;as_xmm_double_reg();
2258     if (right-&gt;is_double_xmm()) {
2259       XMMRegister rreg = right-&gt;as_xmm_double_reg();
2260       switch (code) {
2261         case lir_add: __ addsd(lreg, rreg);  break;
2262         case lir_sub: __ subsd(lreg, rreg);  break;
2263         case lir_mul_strictfp: // fall through
2264         case lir_mul: __ mulsd(lreg, rreg);  break;
2265         case lir_div_strictfp: // fall through
2266         case lir_div: __ divsd(lreg, rreg);  break;
2267         default: ShouldNotReachHere();
2268       }
2269     } else {
2270       Address raddr;
2271       if (right-&gt;is_double_stack()) {
2272         raddr = frame_map()-&gt;address_for_slot(right-&gt;double_stack_ix());
2273       } else if (right-&gt;is_constant()) {
2274         // hack for now
2275         raddr = __ as_Address(InternalAddress(double_constant(right-&gt;as_jdouble())));
2276       } else {
2277         ShouldNotReachHere();
2278       }
2279       switch (code) {
2280         case lir_add: __ addsd(lreg, raddr);  break;
2281         case lir_sub: __ subsd(lreg, raddr);  break;
2282         case lir_mul_strictfp: // fall through
2283         case lir_mul: __ mulsd(lreg, raddr);  break;
2284         case lir_div_strictfp: // fall through
2285         case lir_div: __ divsd(lreg, raddr);  break;
2286         default: ShouldNotReachHere();
2287       }
2288     }
2289 
2290 #ifndef _LP64
2291   } else if (left-&gt;is_single_fpu()) {
2292     assert(dest-&gt;is_single_fpu(),  &quot;fpu stack allocation required&quot;);
2293 
2294     if (right-&gt;is_single_fpu()) {
2295       arith_fpu_implementation(code, left-&gt;fpu_regnr(), right-&gt;fpu_regnr(), dest-&gt;fpu_regnr(), pop_fpu_stack);
2296 
2297     } else {
2298       assert(left-&gt;fpu_regnr() == 0, &quot;left must be on TOS&quot;);
2299       assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be on TOS&quot;);
2300 
2301       Address raddr;
2302       if (right-&gt;is_single_stack()) {
2303         raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2304       } else if (right-&gt;is_constant()) {
2305         address const_addr = float_constant(right-&gt;as_jfloat());
2306         assert(const_addr != NULL, &quot;incorrect float/double constant maintainance&quot;);
2307         // hack for now
2308         raddr = __ as_Address(InternalAddress(const_addr));
2309       } else {
2310         ShouldNotReachHere();
2311       }
2312 
2313       switch (code) {
2314         case lir_add: __ fadd_s(raddr); break;
2315         case lir_sub: __ fsub_s(raddr); break;
2316         case lir_mul_strictfp: // fall through
2317         case lir_mul: __ fmul_s(raddr); break;
2318         case lir_div_strictfp: // fall through
2319         case lir_div: __ fdiv_s(raddr); break;
2320         default:      ShouldNotReachHere();
2321       }
2322     }
2323 
2324   } else if (left-&gt;is_double_fpu()) {
2325     assert(dest-&gt;is_double_fpu(),  &quot;fpu stack allocation required&quot;);
2326 
2327     if (code == lir_mul_strictfp || code == lir_div_strictfp) {
2328       // Double values require special handling for strictfp mul/div on x86
2329       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias1()));
2330       __ fmulp(left-&gt;fpu_regnrLo() + 1);
2331     }
2332 
2333     if (right-&gt;is_double_fpu()) {
2334       arith_fpu_implementation(code, left-&gt;fpu_regnrLo(), right-&gt;fpu_regnrLo(), dest-&gt;fpu_regnrLo(), pop_fpu_stack);
2335 
2336     } else {
2337       assert(left-&gt;fpu_regnrLo() == 0, &quot;left must be on TOS&quot;);
2338       assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be on TOS&quot;);
2339 
2340       Address raddr;
2341       if (right-&gt;is_double_stack()) {
2342         raddr = frame_map()-&gt;address_for_slot(right-&gt;double_stack_ix());
2343       } else if (right-&gt;is_constant()) {
2344         // hack for now
2345         raddr = __ as_Address(InternalAddress(double_constant(right-&gt;as_jdouble())));
2346       } else {
2347         ShouldNotReachHere();
2348       }
2349 
2350       switch (code) {
2351         case lir_add: __ fadd_d(raddr); break;
2352         case lir_sub: __ fsub_d(raddr); break;
2353         case lir_mul_strictfp: // fall through
2354         case lir_mul: __ fmul_d(raddr); break;
2355         case lir_div_strictfp: // fall through
2356         case lir_div: __ fdiv_d(raddr); break;
2357         default: ShouldNotReachHere();
2358       }
2359     }
2360 
2361     if (code == lir_mul_strictfp || code == lir_div_strictfp) {
2362       // Double values require special handling for strictfp mul/div on x86
2363       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias2()));
2364       __ fmulp(dest-&gt;fpu_regnrLo() + 1);
2365     }
2366 #endif // !_LP64
2367 
2368   } else if (left-&gt;is_single_stack() || left-&gt;is_address()) {
2369     assert(left == dest, &quot;left and dest must be equal&quot;);
2370 
2371     Address laddr;
2372     if (left-&gt;is_single_stack()) {
2373       laddr = frame_map()-&gt;address_for_slot(left-&gt;single_stack_ix());
2374     } else if (left-&gt;is_address()) {
2375       laddr = as_Address(left-&gt;as_address_ptr());
2376     } else {
2377       ShouldNotReachHere();
2378     }
2379 
2380     if (right-&gt;is_single_cpu()) {
2381       Register rreg = right-&gt;as_register();
2382       switch (code) {
2383         case lir_add: __ addl(laddr, rreg); break;
2384         case lir_sub: __ subl(laddr, rreg); break;
2385         default:      ShouldNotReachHere();
2386       }
2387     } else if (right-&gt;is_constant()) {
2388       jint c = right-&gt;as_constant_ptr()-&gt;as_jint();
2389       switch (code) {
2390         case lir_add: {
2391           __ incrementl(laddr, c);
2392           break;
2393         }
2394         case lir_sub: {
2395           __ decrementl(laddr, c);
2396           break;
2397         }
2398         default: ShouldNotReachHere();
2399       }
2400     } else {
2401       ShouldNotReachHere();
2402     }
2403 
2404   } else {
2405     ShouldNotReachHere();
2406   }
2407 }
2408 
2409 #ifndef _LP64
2410 void LIR_Assembler::arith_fpu_implementation(LIR_Code code, int left_index, int right_index, int dest_index, bool pop_fpu_stack) {
2411   assert(pop_fpu_stack  || (left_index     == dest_index || right_index     == dest_index), &quot;invalid LIR&quot;);
2412   assert(!pop_fpu_stack || (left_index - 1 == dest_index || right_index - 1 == dest_index), &quot;invalid LIR&quot;);
2413   assert(left_index == 0 || right_index == 0, &quot;either must be on top of stack&quot;);
2414 
2415   bool left_is_tos = (left_index == 0);
2416   bool dest_is_tos = (dest_index == 0);
2417   int non_tos_index = (left_is_tos ? right_index : left_index);
2418 
2419   switch (code) {
2420     case lir_add:
2421       if (pop_fpu_stack)       __ faddp(non_tos_index);
2422       else if (dest_is_tos)    __ fadd (non_tos_index);
2423       else                     __ fadda(non_tos_index);
2424       break;
2425 
2426     case lir_sub:
2427       if (left_is_tos) {
2428         if (pop_fpu_stack)     __ fsubrp(non_tos_index);
2429         else if (dest_is_tos)  __ fsub  (non_tos_index);
2430         else                   __ fsubra(non_tos_index);
2431       } else {
2432         if (pop_fpu_stack)     __ fsubp (non_tos_index);
2433         else if (dest_is_tos)  __ fsubr (non_tos_index);
2434         else                   __ fsuba (non_tos_index);
2435       }
2436       break;
2437 
2438     case lir_mul_strictfp: // fall through
2439     case lir_mul:
2440       if (pop_fpu_stack)       __ fmulp(non_tos_index);
2441       else if (dest_is_tos)    __ fmul (non_tos_index);
2442       else                     __ fmula(non_tos_index);
2443       break;
2444 
2445     case lir_div_strictfp: // fall through
2446     case lir_div:
2447       if (left_is_tos) {
2448         if (pop_fpu_stack)     __ fdivrp(non_tos_index);
2449         else if (dest_is_tos)  __ fdiv  (non_tos_index);
2450         else                   __ fdivra(non_tos_index);
2451       } else {
2452         if (pop_fpu_stack)     __ fdivp (non_tos_index);
2453         else if (dest_is_tos)  __ fdivr (non_tos_index);
2454         else                   __ fdiva (non_tos_index);
2455       }
2456       break;
2457 
2458     case lir_rem:
2459       assert(left_is_tos &amp;&amp; dest_is_tos &amp;&amp; right_index == 1, &quot;must be guaranteed by FPU stack allocation&quot;);
2460       __ fremr(noreg);
2461       break;
2462 
2463     default:
2464       ShouldNotReachHere();
2465   }
2466 }
2467 #endif // _LP64
2468 
2469 
2470 void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr tmp, LIR_Opr dest, LIR_Op* op) {
2471   if (value-&gt;is_double_xmm()) {
2472     switch(code) {
2473       case lir_abs :
2474         {
2475 #ifdef _LP64
2476           if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
2477             assert(tmp-&gt;is_valid(), &quot;need temporary&quot;);
2478             __ vpandn(dest-&gt;as_xmm_double_reg(), tmp-&gt;as_xmm_double_reg(), value-&gt;as_xmm_double_reg(), 2);
2479           } else
2480 #endif
2481           {
2482             if (dest-&gt;as_xmm_double_reg() != value-&gt;as_xmm_double_reg()) {
2483               __ movdbl(dest-&gt;as_xmm_double_reg(), value-&gt;as_xmm_double_reg());
2484             }
2485             assert(!tmp-&gt;is_valid(), &quot;do not need temporary&quot;);
2486             __ andpd(dest-&gt;as_xmm_double_reg(),
2487                      ExternalAddress((address)double_signmask_pool));
2488           }
2489         }
2490         break;
2491 
2492       case lir_sqrt: __ sqrtsd(dest-&gt;as_xmm_double_reg(), value-&gt;as_xmm_double_reg()); break;
2493       // all other intrinsics are not available in the SSE instruction set, so FPU is used
2494       default      : ShouldNotReachHere();
2495     }
2496 
2497 #ifndef _LP64
2498   } else if (value-&gt;is_double_fpu()) {
2499     assert(value-&gt;fpu_regnrLo() == 0 &amp;&amp; dest-&gt;fpu_regnrLo() == 0, &quot;both must be on TOS&quot;);
2500     switch(code) {
2501       case lir_abs   : __ fabs() ; break;
2502       case lir_sqrt  : __ fsqrt(); break;
2503       default      : ShouldNotReachHere();
2504     }
2505 #endif // !_LP64
2506   } else {
2507     Unimplemented();
2508   }
2509 }
2510 
2511 void LIR_Assembler::logic_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst) {
2512   // assert(left-&gt;destroys_register(), &quot;check&quot;);
2513   if (left-&gt;is_single_cpu()) {
2514     Register reg = left-&gt;as_register();
2515     if (right-&gt;is_constant()) {
2516       int val = right-&gt;as_constant_ptr()-&gt;as_jint();
2517       switch (code) {
2518         case lir_logic_and: __ andl (reg, val); break;
2519         case lir_logic_or:  __ orl  (reg, val); break;
2520         case lir_logic_xor: __ xorl (reg, val); break;
2521         default: ShouldNotReachHere();
2522       }
2523     } else if (right-&gt;is_stack()) {
2524       // added support for stack operands
2525       Address raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2526       switch (code) {
2527         case lir_logic_and: __ andl (reg, raddr); break;
2528         case lir_logic_or:  __ orl  (reg, raddr); break;
2529         case lir_logic_xor: __ xorl (reg, raddr); break;
2530         default: ShouldNotReachHere();
2531       }
2532     } else {
2533       Register rright = right-&gt;as_register();
2534       switch (code) {
2535         case lir_logic_and: __ andptr (reg, rright); break;
2536         case lir_logic_or : __ orptr  (reg, rright); break;
2537         case lir_logic_xor: __ xorptr (reg, rright); break;
2538         default: ShouldNotReachHere();
2539       }
2540     }
2541     move_regs(reg, dst-&gt;as_register());
2542   } else {
2543     Register l_lo = left-&gt;as_register_lo();
2544     Register l_hi = left-&gt;as_register_hi();
2545     if (right-&gt;is_constant()) {
2546 #ifdef _LP64
2547       __ mov64(rscratch1, right-&gt;as_constant_ptr()-&gt;as_jlong());
2548       switch (code) {
2549         case lir_logic_and:
2550           __ andq(l_lo, rscratch1);
2551           break;
2552         case lir_logic_or:
2553           __ orq(l_lo, rscratch1);
2554           break;
2555         case lir_logic_xor:
2556           __ xorq(l_lo, rscratch1);
2557           break;
2558         default: ShouldNotReachHere();
2559       }
2560 #else
2561       int r_lo = right-&gt;as_constant_ptr()-&gt;as_jint_lo();
2562       int r_hi = right-&gt;as_constant_ptr()-&gt;as_jint_hi();
2563       switch (code) {
2564         case lir_logic_and:
2565           __ andl(l_lo, r_lo);
2566           __ andl(l_hi, r_hi);
2567           break;
2568         case lir_logic_or:
2569           __ orl(l_lo, r_lo);
2570           __ orl(l_hi, r_hi);
2571           break;
2572         case lir_logic_xor:
2573           __ xorl(l_lo, r_lo);
2574           __ xorl(l_hi, r_hi);
2575           break;
2576         default: ShouldNotReachHere();
2577       }
2578 #endif // _LP64
2579     } else {
2580 #ifdef _LP64
2581       Register r_lo;
2582       if (is_reference_type(right-&gt;type())) {
2583         r_lo = right-&gt;as_register();
2584       } else {
2585         r_lo = right-&gt;as_register_lo();
2586       }
2587 #else
2588       Register r_lo = right-&gt;as_register_lo();
2589       Register r_hi = right-&gt;as_register_hi();
2590       assert(l_lo != r_hi, &quot;overwriting registers&quot;);
2591 #endif
2592       switch (code) {
2593         case lir_logic_and:
2594           __ andptr(l_lo, r_lo);
2595           NOT_LP64(__ andptr(l_hi, r_hi);)
2596           break;
2597         case lir_logic_or:
2598           __ orptr(l_lo, r_lo);
2599           NOT_LP64(__ orptr(l_hi, r_hi);)
2600           break;
2601         case lir_logic_xor:
2602           __ xorptr(l_lo, r_lo);
2603           NOT_LP64(__ xorptr(l_hi, r_hi);)
2604           break;
2605         default: ShouldNotReachHere();
2606       }
2607     }
2608 
2609     Register dst_lo = dst-&gt;as_register_lo();
2610     Register dst_hi = dst-&gt;as_register_hi();
2611 
2612 #ifdef _LP64
2613     move_regs(l_lo, dst_lo);
2614 #else
2615     if (dst_lo == l_hi) {
2616       assert(dst_hi != l_lo, &quot;overwriting registers&quot;);
2617       move_regs(l_hi, dst_hi);
2618       move_regs(l_lo, dst_lo);
2619     } else {
2620       assert(dst_lo != l_hi, &quot;overwriting registers&quot;);
2621       move_regs(l_lo, dst_lo);
2622       move_regs(l_hi, dst_hi);
2623     }
2624 #endif // _LP64
2625   }
2626 }
2627 
2628 
2629 // we assume that rax, and rdx can be overwritten
2630 void LIR_Assembler::arithmetic_idiv(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr temp, LIR_Opr result, CodeEmitInfo* info) {
2631 
2632   assert(left-&gt;is_single_cpu(),   &quot;left must be register&quot;);
2633   assert(right-&gt;is_single_cpu() || right-&gt;is_constant(),  &quot;right must be register or constant&quot;);
2634   assert(result-&gt;is_single_cpu(), &quot;result must be register&quot;);
2635 
2636   //  assert(left-&gt;destroys_register(), &quot;check&quot;);
2637   //  assert(right-&gt;destroys_register(), &quot;check&quot;);
2638 
2639   Register lreg = left-&gt;as_register();
2640   Register dreg = result-&gt;as_register();
2641 
2642   if (right-&gt;is_constant()) {
2643     jint divisor = right-&gt;as_constant_ptr()-&gt;as_jint();
2644     assert(divisor &gt; 0 &amp;&amp; is_power_of_2(divisor), &quot;must be&quot;);
2645     if (code == lir_idiv) {
2646       assert(lreg == rax, &quot;must be rax,&quot;);
2647       assert(temp-&gt;as_register() == rdx, &quot;tmp register must be rdx&quot;);
2648       __ cdql(); // sign extend into rdx:rax
2649       if (divisor == 2) {
2650         __ subl(lreg, rdx);
2651       } else {
2652         __ andl(rdx, divisor - 1);
2653         __ addl(lreg, rdx);
2654       }
2655       __ sarl(lreg, log2_jint(divisor));
2656       move_regs(lreg, dreg);
2657     } else if (code == lir_irem) {
2658       Label done;
2659       __ mov(dreg, lreg);
2660       __ andl(dreg, 0x80000000 | (divisor - 1));
2661       __ jcc(Assembler::positive, done);
2662       __ decrement(dreg);
2663       __ orl(dreg, ~(divisor - 1));
2664       __ increment(dreg);
2665       __ bind(done);
2666     } else {
2667       ShouldNotReachHere();
2668     }
2669   } else {
2670     Register rreg = right-&gt;as_register();
2671     assert(lreg == rax, &quot;left register must be rax,&quot;);
2672     assert(rreg != rdx, &quot;right register must not be rdx&quot;);
2673     assert(temp-&gt;as_register() == rdx, &quot;tmp register must be rdx&quot;);
2674 
2675     move_regs(lreg, rax);
2676 
2677     int idivl_offset = __ corrected_idivl(rreg);
2678     if (ImplicitDiv0Checks) {
2679       add_debug_info_for_div0(idivl_offset, info);
2680     }
2681     if (code == lir_irem) {
2682       move_regs(rdx, dreg); // result is in rdx
2683     } else {
2684       move_regs(rax, dreg);
2685     }
2686   }
2687 }
2688 
2689 
2690 void LIR_Assembler::comp_op(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Op2* op) {
2691   if (opr1-&gt;is_single_cpu()) {
2692     Register reg1 = opr1-&gt;as_register();
2693     if (opr2-&gt;is_single_cpu()) {
2694       // cpu register - cpu register
2695       if (is_reference_type(opr1-&gt;type())) {
2696         __ cmpoop(reg1, opr2-&gt;as_register());
2697       } else {
2698         assert(!is_reference_type(opr2-&gt;type()), &quot;cmp int, oop?&quot;);
2699         __ cmpl(reg1, opr2-&gt;as_register());
2700       }
2701     } else if (opr2-&gt;is_stack()) {
2702       // cpu register - stack
2703       if (is_reference_type(opr1-&gt;type())) {
2704         __ cmpoop(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2705       } else {
2706         __ cmpl(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2707       }
2708     } else if (opr2-&gt;is_constant()) {
2709       // cpu register - constant
2710       LIR_Const* c = opr2-&gt;as_constant_ptr();
2711       if (c-&gt;type() == T_INT) {
2712         __ cmpl(reg1, c-&gt;as_jint());
2713       } else if (c-&gt;type() == T_METADATA) {
2714         // All we need for now is a comparison with NULL for equality.
2715         assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;oops&quot;);
2716         Metadata* m = c-&gt;as_metadata();
2717         if (m == NULL) {
2718           __ cmpptr(reg1, (int32_t)0);
2719         } else {
2720           ShouldNotReachHere();
2721         }
2722       } else if (is_reference_type(c-&gt;type())) {
2723         // In 64bit oops are single register
2724         jobject o = c-&gt;as_jobject();
2725         if (o == NULL) {
2726           __ cmpptr(reg1, (int32_t)NULL_WORD);
2727         } else {
2728           __ cmpoop(reg1, o);
2729         }
2730       } else {
2731         fatal(&quot;unexpected type: %s&quot;, basictype_to_str(c-&gt;type()));
2732       }
2733       // cpu register - address
2734     } else if (opr2-&gt;is_address()) {
2735       if (op-&gt;info() != NULL) {
2736         add_debug_info_for_null_check_here(op-&gt;info());
2737       }
2738       __ cmpl(reg1, as_Address(opr2-&gt;as_address_ptr()));
2739     } else {
2740       ShouldNotReachHere();
2741     }
2742 
2743   } else if(opr1-&gt;is_double_cpu()) {
2744     Register xlo = opr1-&gt;as_register_lo();
2745     Register xhi = opr1-&gt;as_register_hi();
2746     if (opr2-&gt;is_double_cpu()) {
2747 #ifdef _LP64
2748       __ cmpptr(xlo, opr2-&gt;as_register_lo());
2749 #else
2750       // cpu register - cpu register
2751       Register ylo = opr2-&gt;as_register_lo();
2752       Register yhi = opr2-&gt;as_register_hi();
2753       __ subl(xlo, ylo);
2754       __ sbbl(xhi, yhi);
2755       if (condition == lir_cond_equal || condition == lir_cond_notEqual) {
2756         __ orl(xhi, xlo);
2757       }
2758 #endif // _LP64
2759     } else if (opr2-&gt;is_constant()) {
2760       // cpu register - constant 0
2761       assert(opr2-&gt;as_jlong() == (jlong)0, &quot;only handles zero&quot;);
2762 #ifdef _LP64
2763       __ cmpptr(xlo, (int32_t)opr2-&gt;as_jlong());
2764 #else
2765       assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;only handles equals case&quot;);
2766       __ orl(xhi, xlo);
2767 #endif // _LP64
2768     } else {
2769       ShouldNotReachHere();
2770     }
2771 
2772   } else if (opr1-&gt;is_single_xmm()) {
2773     XMMRegister reg1 = opr1-&gt;as_xmm_float_reg();
2774     if (opr2-&gt;is_single_xmm()) {
2775       // xmm register - xmm register
2776       __ ucomiss(reg1, opr2-&gt;as_xmm_float_reg());
2777     } else if (opr2-&gt;is_stack()) {
2778       // xmm register - stack
2779       __ ucomiss(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2780     } else if (opr2-&gt;is_constant()) {
2781       // xmm register - constant
2782       __ ucomiss(reg1, InternalAddress(float_constant(opr2-&gt;as_jfloat())));
2783     } else if (opr2-&gt;is_address()) {
2784       // xmm register - address
2785       if (op-&gt;info() != NULL) {
2786         add_debug_info_for_null_check_here(op-&gt;info());
2787       }
2788       __ ucomiss(reg1, as_Address(opr2-&gt;as_address_ptr()));
2789     } else {
2790       ShouldNotReachHere();
2791     }
2792 
2793   } else if (opr1-&gt;is_double_xmm()) {
2794     XMMRegister reg1 = opr1-&gt;as_xmm_double_reg();
2795     if (opr2-&gt;is_double_xmm()) {
2796       // xmm register - xmm register
2797       __ ucomisd(reg1, opr2-&gt;as_xmm_double_reg());
2798     } else if (opr2-&gt;is_stack()) {
2799       // xmm register - stack
2800       __ ucomisd(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix()));
2801     } else if (opr2-&gt;is_constant()) {
2802       // xmm register - constant
2803       __ ucomisd(reg1, InternalAddress(double_constant(opr2-&gt;as_jdouble())));
2804     } else if (opr2-&gt;is_address()) {
2805       // xmm register - address
2806       if (op-&gt;info() != NULL) {
2807         add_debug_info_for_null_check_here(op-&gt;info());
2808       }
2809       __ ucomisd(reg1, as_Address(opr2-&gt;pointer()-&gt;as_address()));
2810     } else {
2811       ShouldNotReachHere();
2812     }
2813 
2814 #ifndef _LP64
2815   } else if(opr1-&gt;is_single_fpu() || opr1-&gt;is_double_fpu()) {
2816     assert(opr1-&gt;is_fpu_register() &amp;&amp; opr1-&gt;fpu() == 0, &quot;currently left-hand side must be on TOS (relax this restriction)&quot;);
2817     assert(opr2-&gt;is_fpu_register(), &quot;both must be registers&quot;);
2818     __ fcmp(noreg, opr2-&gt;fpu(), op-&gt;fpu_pop_count() &gt; 0, op-&gt;fpu_pop_count() &gt; 1);
2819 #endif // LP64
2820 
2821   } else if (opr1-&gt;is_address() &amp;&amp; opr2-&gt;is_constant()) {
2822     LIR_Const* c = opr2-&gt;as_constant_ptr();
2823 #ifdef _LP64
2824     if (is_reference_type(c-&gt;type())) {
2825       assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;need to reverse&quot;);
2826       __ movoop(rscratch1, c-&gt;as_jobject());
2827     }
2828 #endif // LP64
2829     if (op-&gt;info() != NULL) {
2830       add_debug_info_for_null_check_here(op-&gt;info());
2831     }
2832     // special case: address - constant
2833     LIR_Address* addr = opr1-&gt;as_address_ptr();
2834     if (c-&gt;type() == T_INT) {
2835       __ cmpl(as_Address(addr), c-&gt;as_jint());
2836     } else if (is_reference_type(c-&gt;type())) {
2837 #ifdef _LP64
2838       // %%% Make this explode if addr isn&#39;t reachable until we figure out a
2839       // better strategy by giving noreg as the temp for as_Address
2840       __ cmpoop(rscratch1, as_Address(addr, noreg));
2841 #else
2842       __ cmpoop(as_Address(addr), c-&gt;as_jobject());
2843 #endif // _LP64
2844     } else {
2845       ShouldNotReachHere();
2846     }
2847 
2848   } else {
2849     ShouldNotReachHere();
2850   }
2851 }
2852 
2853 void LIR_Assembler::comp_fl2i(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst, LIR_Op2* op) {
2854   if (code == lir_cmp_fd2i || code == lir_ucmp_fd2i) {
2855     if (left-&gt;is_single_xmm()) {
2856       assert(right-&gt;is_single_xmm(), &quot;must match&quot;);
2857       __ cmpss2int(left-&gt;as_xmm_float_reg(), right-&gt;as_xmm_float_reg(), dst-&gt;as_register(), code == lir_ucmp_fd2i);
2858     } else if (left-&gt;is_double_xmm()) {
2859       assert(right-&gt;is_double_xmm(), &quot;must match&quot;);
2860       __ cmpsd2int(left-&gt;as_xmm_double_reg(), right-&gt;as_xmm_double_reg(), dst-&gt;as_register(), code == lir_ucmp_fd2i);
2861 
2862     } else {
2863 #ifdef _LP64
2864       ShouldNotReachHere();
2865 #else
2866       assert(left-&gt;is_single_fpu() || left-&gt;is_double_fpu(), &quot;must be&quot;);
2867       assert(right-&gt;is_single_fpu() || right-&gt;is_double_fpu(), &quot;must match&quot;);
2868 
2869       assert(left-&gt;fpu() == 0, &quot;left must be on TOS&quot;);
2870       __ fcmp2int(dst-&gt;as_register(), code == lir_ucmp_fd2i, right-&gt;fpu(),
2871                   op-&gt;fpu_pop_count() &gt; 0, op-&gt;fpu_pop_count() &gt; 1);
2872 #endif // LP64
2873     }
2874   } else {
2875     assert(code == lir_cmp_l2i, &quot;check&quot;);
2876 #ifdef _LP64
2877     Label done;
2878     Register dest = dst-&gt;as_register();
2879     __ cmpptr(left-&gt;as_register_lo(), right-&gt;as_register_lo());
2880     __ movl(dest, -1);
2881     __ jccb(Assembler::less, done);
2882     __ set_byte_if_not_zero(dest);
2883     __ movzbl(dest, dest);
2884     __ bind(done);
2885 #else
2886     __ lcmp2int(left-&gt;as_register_hi(),
2887                 left-&gt;as_register_lo(),
2888                 right-&gt;as_register_hi(),
2889                 right-&gt;as_register_lo());
2890     move_regs(left-&gt;as_register_hi(), dst-&gt;as_register());
2891 #endif // _LP64
2892   }
2893 }
2894 
2895 
2896 void LIR_Assembler::align_call(LIR_Code code) {
2897   // make sure that the displacement word of the call ends up word aligned
2898   int offset = __ offset();
2899   switch (code) {
2900   case lir_static_call:
2901   case lir_optvirtual_call:
2902   case lir_dynamic_call:
2903     offset += NativeCall::displacement_offset;
2904     break;
2905   case lir_icvirtual_call:
2906     offset += NativeCall::displacement_offset + NativeMovConstReg::instruction_size;
2907     break;
2908   case lir_virtual_call:  // currently, sparc-specific for niagara
2909   default: ShouldNotReachHere();
2910   }
2911   __ align(BytesPerWord, offset);
2912 }
2913 
2914 
2915 void LIR_Assembler::call(LIR_OpJavaCall* op, relocInfo::relocType rtype) {
2916   assert((__ offset() + NativeCall::displacement_offset) % BytesPerWord == 0,
2917          &quot;must be aligned&quot;);
2918   __ call(AddressLiteral(op-&gt;addr(), rtype));
2919   add_call_info(code_offset(), op-&gt;info());
2920 }
2921 
2922 
2923 void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {
2924   __ ic_call(op-&gt;addr());
2925   add_call_info(code_offset(), op-&gt;info());
2926   assert((__ offset() - NativeCall::instruction_size + NativeCall::displacement_offset) % BytesPerWord == 0,
2927          &quot;must be aligned&quot;);
2928 }
2929 
2930 
2931 /* Currently, vtable-dispatch is only enabled for sparc platforms */
2932 void LIR_Assembler::vtable_call(LIR_OpJavaCall* op) {
2933   ShouldNotReachHere();
2934 }
2935 
2936 
2937 void LIR_Assembler::emit_static_call_stub() {
2938   address call_pc = __ pc();
2939   address stub = __ start_a_stub(call_stub_size());
2940   if (stub == NULL) {
2941     bailout(&quot;static call stub overflow&quot;);
2942     return;
2943   }
2944 
2945   int start = __ offset();
2946 
2947   // make sure that the displacement word of the call ends up word aligned
2948   __ align(BytesPerWord, __ offset() + NativeMovConstReg::instruction_size + NativeCall::displacement_offset);
2949   __ relocate(static_stub_Relocation::spec(call_pc, false /* is_aot */));
2950   __ mov_metadata(rbx, (Metadata*)NULL);
2951   // must be set to -1 at code generation time
2952   assert(((__ offset() + 1) % BytesPerWord) == 0, &quot;must be aligned&quot;);
2953   // On 64bit this will die since it will take a movq &amp; jmp, must be only a jmp
2954   __ jump(RuntimeAddress(__ pc()));
2955 
2956   if (UseAOT) {
2957     // Trampoline to aot code
2958     __ relocate(static_stub_Relocation::spec(call_pc, true /* is_aot */));
2959 #ifdef _LP64
2960     __ mov64(rax, CONST64(0));  // address is zapped till fixup time.
2961 #else
2962     __ movl(rax, 0xdeadffff);  // address is zapped till fixup time.
2963 #endif
2964     __ jmp(rax);
2965   }
2966   assert(__ offset() - start &lt;= call_stub_size(), &quot;stub too big&quot;);
2967   __ end_a_stub();
2968 }
2969 
2970 
2971 void LIR_Assembler::throw_op(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info) {
2972   assert(exceptionOop-&gt;as_register() == rax, &quot;must match&quot;);
2973   assert(exceptionPC-&gt;as_register() == rdx, &quot;must match&quot;);
2974 
2975   // exception object is not added to oop map by LinearScan
2976   // (LinearScan assumes that no oops are in fixed registers)
2977   info-&gt;add_register_oop(exceptionOop);
2978   Runtime1::StubID unwind_id;
2979 
2980   // get current pc information
2981   // pc is only needed if the method has an exception handler, the unwind code does not need it.
2982   int pc_for_athrow_offset = __ offset();
2983   InternalAddress pc_for_athrow(__ pc());
2984   __ lea(exceptionPC-&gt;as_register(), pc_for_athrow);
2985   add_call_info(pc_for_athrow_offset, info); // for exception handler
2986 
2987   __ verify_not_null_oop(rax);
2988   // search an exception handler (rax: exception oop, rdx: throwing pc)
2989   if (compilation()-&gt;has_fpu_code()) {
2990     unwind_id = Runtime1::handle_exception_id;
2991   } else {
2992     unwind_id = Runtime1::handle_exception_nofpu_id;
2993   }
2994   __ call(RuntimeAddress(Runtime1::entry_for(unwind_id)));
2995 
2996   // enough room for two byte trap
2997   __ nop();
2998 }
2999 
3000 
3001 void LIR_Assembler::unwind_op(LIR_Opr exceptionOop) {
3002   assert(exceptionOop-&gt;as_register() == rax, &quot;must match&quot;);
3003 
3004   __ jmp(_unwind_handler_entry);
3005 }
3006 
3007 
3008 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, LIR_Opr count, LIR_Opr dest, LIR_Opr tmp) {
3009 
3010   // optimized version for linear scan:
3011   // * count must be already in ECX (guaranteed by LinearScan)
3012   // * left and dest must be equal
3013   // * tmp must be unused
3014   assert(count-&gt;as_register() == SHIFT_count, &quot;count must be in ECX&quot;);
3015   assert(left == dest, &quot;left and dest must be equal&quot;);
3016   assert(tmp-&gt;is_illegal(), &quot;wasting a register if tmp is allocated&quot;);
3017 
3018   if (left-&gt;is_single_cpu()) {
3019     Register value = left-&gt;as_register();
3020     assert(value != SHIFT_count, &quot;left cannot be ECX&quot;);
3021 
3022     switch (code) {
3023       case lir_shl:  __ shll(value); break;
3024       case lir_shr:  __ sarl(value); break;
3025       case lir_ushr: __ shrl(value); break;
3026       default: ShouldNotReachHere();
3027     }
3028   } else if (left-&gt;is_double_cpu()) {
3029     Register lo = left-&gt;as_register_lo();
3030     Register hi = left-&gt;as_register_hi();
3031     assert(lo != SHIFT_count &amp;&amp; hi != SHIFT_count, &quot;left cannot be ECX&quot;);
3032 #ifdef _LP64
3033     switch (code) {
3034       case lir_shl:  __ shlptr(lo);        break;
3035       case lir_shr:  __ sarptr(lo);        break;
3036       case lir_ushr: __ shrptr(lo);        break;
3037       default: ShouldNotReachHere();
3038     }
3039 #else
3040 
3041     switch (code) {
3042       case lir_shl:  __ lshl(hi, lo);        break;
3043       case lir_shr:  __ lshr(hi, lo, true);  break;
3044       case lir_ushr: __ lshr(hi, lo, false); break;
3045       default: ShouldNotReachHere();
3046     }
3047 #endif // LP64
3048   } else {
3049     ShouldNotReachHere();
3050   }
3051 }
3052 
3053 
3054 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, jint count, LIR_Opr dest) {
3055   if (dest-&gt;is_single_cpu()) {
3056     // first move left into dest so that left is not destroyed by the shift
3057     Register value = dest-&gt;as_register();
3058     count = count &amp; 0x1F; // Java spec
3059 
3060     move_regs(left-&gt;as_register(), value);
3061     switch (code) {
3062       case lir_shl:  __ shll(value, count); break;
3063       case lir_shr:  __ sarl(value, count); break;
3064       case lir_ushr: __ shrl(value, count); break;
3065       default: ShouldNotReachHere();
3066     }
3067   } else if (dest-&gt;is_double_cpu()) {
3068 #ifndef _LP64
3069     Unimplemented();
3070 #else
3071     // first move left into dest so that left is not destroyed by the shift
3072     Register value = dest-&gt;as_register_lo();
3073     count = count &amp; 0x1F; // Java spec
3074 
3075     move_regs(left-&gt;as_register_lo(), value);
3076     switch (code) {
3077       case lir_shl:  __ shlptr(value, count); break;
3078       case lir_shr:  __ sarptr(value, count); break;
3079       case lir_ushr: __ shrptr(value, count); break;
3080       default: ShouldNotReachHere();
3081     }
3082 #endif // _LP64
3083   } else {
3084     ShouldNotReachHere();
3085   }
3086 }
3087 
3088 
3089 void LIR_Assembler::store_parameter(Register r, int offset_from_rsp_in_words) {
3090   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3091   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3092   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3093   __ movptr (Address(rsp, offset_from_rsp_in_bytes), r);
3094 }
3095 
3096 
3097 void LIR_Assembler::store_parameter(jint c,     int offset_from_rsp_in_words) {
3098   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3099   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3100   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3101   __ movptr (Address(rsp, offset_from_rsp_in_bytes), c);
3102 }
3103 
3104 
3105 void LIR_Assembler::store_parameter(jobject o,  int offset_from_rsp_in_words) {
3106   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3107   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3108   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3109   __ movoop (Address(rsp, offset_from_rsp_in_bytes), o);
3110 }
3111 
3112 
3113 void LIR_Assembler::store_parameter(Metadata* m,  int offset_from_rsp_in_words) {
3114   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3115   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3116   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3117   __ mov_metadata(Address(rsp, offset_from_rsp_in_bytes), m);
3118 }
3119 
3120 
3121 // This code replaces a call to arraycopy; no exception may
3122 // be thrown in this code, they must be thrown in the System.arraycopy
3123 // activation frame; we could save some checks if this would not be the case
3124 void LIR_Assembler::emit_arraycopy(LIR_OpArrayCopy* op) {
3125   ciArrayKlass* default_type = op-&gt;expected_type();
3126   Register src = op-&gt;src()-&gt;as_register();
3127   Register dst = op-&gt;dst()-&gt;as_register();
3128   Register src_pos = op-&gt;src_pos()-&gt;as_register();
3129   Register dst_pos = op-&gt;dst_pos()-&gt;as_register();
3130   Register length  = op-&gt;length()-&gt;as_register();
3131   Register tmp = op-&gt;tmp()-&gt;as_register();
3132 
3133   __ resolve(ACCESS_READ, src);
3134   __ resolve(ACCESS_WRITE, dst);
3135 
3136   CodeStub* stub = op-&gt;stub();
3137   int flags = op-&gt;flags();
3138   BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
3139   if (is_reference_type(basic_type)) basic_type = T_OBJECT;
3140 
3141   // if we don&#39;t know anything, just go through the generic arraycopy
3142   if (default_type == NULL) {
3143     // save outgoing arguments on stack in case call to System.arraycopy is needed
3144     // HACK ALERT. This code used to push the parameters in a hardwired fashion
3145     // for interpreter calling conventions. Now we have to do it in new style conventions.
3146     // For the moment until C1 gets the new register allocator I just force all the
3147     // args to the right place (except the register args) and then on the back side
3148     // reload the register args properly if we go slow path. Yuck
3149 
3150     // These are proper for the calling convention
3151     store_parameter(length, 2);
3152     store_parameter(dst_pos, 1);
3153     store_parameter(dst, 0);
3154 
3155     // these are just temporary placements until we need to reload
3156     store_parameter(src_pos, 3);
3157     store_parameter(src, 4);
3158     NOT_LP64(assert(src == rcx &amp;&amp; src_pos == rdx, &quot;mismatch in calling convention&quot;);)
3159 
3160     address copyfunc_addr = StubRoutines::generic_arraycopy();
3161     assert(copyfunc_addr != NULL, &quot;generic arraycopy stub required&quot;);
3162 
3163     // pass arguments: may push as this is not a safepoint; SP must be fix at each safepoint
3164 #ifdef _LP64
3165     // The arguments are in java calling convention so we can trivially shift them to C
3166     // convention
3167     assert_different_registers(c_rarg0, j_rarg1, j_rarg2, j_rarg3, j_rarg4);
3168     __ mov(c_rarg0, j_rarg0);
3169     assert_different_registers(c_rarg1, j_rarg2, j_rarg3, j_rarg4);
3170     __ mov(c_rarg1, j_rarg1);
3171     assert_different_registers(c_rarg2, j_rarg3, j_rarg4);
3172     __ mov(c_rarg2, j_rarg2);
3173     assert_different_registers(c_rarg3, j_rarg4);
3174     __ mov(c_rarg3, j_rarg3);
3175 #ifdef _WIN64
3176     // Allocate abi space for args but be sure to keep stack aligned
3177     __ subptr(rsp, 6*wordSize);
3178     store_parameter(j_rarg4, 4);
3179 #ifndef PRODUCT
3180     if (PrintC1Statistics) {
3181       __ incrementl(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
3182     }
3183 #endif
3184     __ call(RuntimeAddress(copyfunc_addr));
3185     __ addptr(rsp, 6*wordSize);
3186 #else
3187     __ mov(c_rarg4, j_rarg4);
3188 #ifndef PRODUCT
3189     if (PrintC1Statistics) {
3190       __ incrementl(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
3191     }
3192 #endif
3193     __ call(RuntimeAddress(copyfunc_addr));
3194 #endif // _WIN64
3195 #else
3196     __ push(length);
3197     __ push(dst_pos);
3198     __ push(dst);
3199     __ push(src_pos);
3200     __ push(src);
3201 
3202 #ifndef PRODUCT
3203     if (PrintC1Statistics) {
3204       __ incrementl(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
3205     }
3206 #endif
3207     __ call_VM_leaf(copyfunc_addr, 5); // removes pushed parameter from the stack
3208 
3209 #endif // _LP64
3210 
3211     __ cmpl(rax, 0);
3212     __ jcc(Assembler::equal, *stub-&gt;continuation());
3213 
3214     __ mov(tmp, rax);
3215     __ xorl(tmp, -1);
3216 
3217     // Reload values from the stack so they are where the stub
3218     // expects them.
3219     __ movptr   (dst,     Address(rsp, 0*BytesPerWord));
3220     __ movptr   (dst_pos, Address(rsp, 1*BytesPerWord));
3221     __ movptr   (length,  Address(rsp, 2*BytesPerWord));
3222     __ movptr   (src_pos, Address(rsp, 3*BytesPerWord));
3223     __ movptr   (src,     Address(rsp, 4*BytesPerWord));
3224 
3225     __ subl(length, tmp);
3226     __ addl(src_pos, tmp);
3227     __ addl(dst_pos, tmp);
3228     __ jmp(*stub-&gt;entry());
3229 
3230     __ bind(*stub-&gt;continuation());
3231     return;
3232   }
3233 
3234   assert(default_type != NULL &amp;&amp; default_type-&gt;is_array_klass() &amp;&amp; default_type-&gt;is_loaded(), &quot;must be true at this point&quot;);
3235 
3236   int elem_size = type2aelembytes(basic_type);
3237   Address::ScaleFactor scale;
3238 
3239   switch (elem_size) {
3240     case 1 :
3241       scale = Address::times_1;
3242       break;
3243     case 2 :
3244       scale = Address::times_2;
3245       break;
3246     case 4 :
3247       scale = Address::times_4;
3248       break;
3249     case 8 :
3250       scale = Address::times_8;
3251       break;
3252     default:
3253       scale = Address::no_scale;
3254       ShouldNotReachHere();
3255   }
3256 
3257   Address src_length_addr = Address(src, arrayOopDesc::length_offset_in_bytes());
3258   Address dst_length_addr = Address(dst, arrayOopDesc::length_offset_in_bytes());
3259   Address src_klass_addr = Address(src, oopDesc::klass_offset_in_bytes());
3260   Address dst_klass_addr = Address(dst, oopDesc::klass_offset_in_bytes());
3261 
3262   // length and pos&#39;s are all sign extended at this point on 64bit
3263 
3264   // test for NULL
3265   if (flags &amp; LIR_OpArrayCopy::src_null_check) {
3266     __ testptr(src, src);
3267     __ jcc(Assembler::zero, *stub-&gt;entry());
3268   }
3269   if (flags &amp; LIR_OpArrayCopy::dst_null_check) {
3270     __ testptr(dst, dst);
3271     __ jcc(Assembler::zero, *stub-&gt;entry());
3272   }
3273 
3274   // If the compiler was not able to prove that exact type of the source or the destination
3275   // of the arraycopy is an array type, check at runtime if the source or the destination is
3276   // an instance type.
3277   if (flags &amp; LIR_OpArrayCopy::type_check) {
3278     if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
3279       __ load_klass(tmp, dst);
3280       __ cmpl(Address(tmp, in_bytes(Klass::layout_helper_offset())), Klass::_lh_neutral_value);
3281       __ jcc(Assembler::greaterEqual, *stub-&gt;entry());
3282     }
3283 
3284     if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
3285       __ load_klass(tmp, src);
3286       __ cmpl(Address(tmp, in_bytes(Klass::layout_helper_offset())), Klass::_lh_neutral_value);
3287       __ jcc(Assembler::greaterEqual, *stub-&gt;entry());
3288     }
3289   }
3290 
3291   // check if negative
3292   if (flags &amp; LIR_OpArrayCopy::src_pos_positive_check) {
3293     __ testl(src_pos, src_pos);
3294     __ jcc(Assembler::less, *stub-&gt;entry());
3295   }
3296   if (flags &amp; LIR_OpArrayCopy::dst_pos_positive_check) {
3297     __ testl(dst_pos, dst_pos);
3298     __ jcc(Assembler::less, *stub-&gt;entry());
3299   }
3300 
3301   if (flags &amp; LIR_OpArrayCopy::src_range_check) {
3302     __ lea(tmp, Address(src_pos, length, Address::times_1, 0));
3303     __ cmpl(tmp, src_length_addr);
3304     __ jcc(Assembler::above, *stub-&gt;entry());
3305   }
3306   if (flags &amp; LIR_OpArrayCopy::dst_range_check) {
3307     __ lea(tmp, Address(dst_pos, length, Address::times_1, 0));
3308     __ cmpl(tmp, dst_length_addr);
3309     __ jcc(Assembler::above, *stub-&gt;entry());
3310   }
3311 
3312   if (flags &amp; LIR_OpArrayCopy::length_positive_check) {
3313     __ testl(length, length);
3314     __ jcc(Assembler::less, *stub-&gt;entry());
3315   }
3316 
3317 #ifdef _LP64
3318   __ movl2ptr(src_pos, src_pos); //higher 32bits must be null
3319   __ movl2ptr(dst_pos, dst_pos); //higher 32bits must be null
3320 #endif
3321 
3322   if (flags &amp; LIR_OpArrayCopy::type_check) {
3323     // We don&#39;t know the array types are compatible
3324     if (basic_type != T_OBJECT) {
3325       // Simple test for basic type arrays
3326       if (UseCompressedClassPointers) {
3327         __ movl(tmp, src_klass_addr);
3328         __ cmpl(tmp, dst_klass_addr);
3329       } else {
3330         __ movptr(tmp, src_klass_addr);
3331         __ cmpptr(tmp, dst_klass_addr);
3332       }
3333       __ jcc(Assembler::notEqual, *stub-&gt;entry());
3334     } else {
3335       // For object arrays, if src is a sub class of dst then we can
3336       // safely do the copy.
3337       Label cont, slow;
3338 
3339       __ push(src);
3340       __ push(dst);
3341 
3342       __ load_klass(src, src);
3343       __ load_klass(dst, dst);
3344 
3345       __ check_klass_subtype_fast_path(src, dst, tmp, &amp;cont, &amp;slow, NULL);
3346 
3347       __ push(src);
3348       __ push(dst);
3349       __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
3350       __ pop(dst);
3351       __ pop(src);
3352 
3353       __ cmpl(src, 0);
3354       __ jcc(Assembler::notEqual, cont);
3355 
3356       __ bind(slow);
3357       __ pop(dst);
3358       __ pop(src);
3359 
3360       address copyfunc_addr = StubRoutines::checkcast_arraycopy();
3361       if (copyfunc_addr != NULL) { // use stub if available
3362         // src is not a sub class of dst so we have to do a
3363         // per-element check.
3364 
3365         int mask = LIR_OpArrayCopy::src_objarray|LIR_OpArrayCopy::dst_objarray;
3366         if ((flags &amp; mask) != mask) {
3367           // Check that at least both of them object arrays.
3368           assert(flags &amp; mask, &quot;one of the two should be known to be an object array&quot;);
3369 
3370           if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
3371             __ load_klass(tmp, src);
3372           } else if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
3373             __ load_klass(tmp, dst);
3374           }
3375           int lh_offset = in_bytes(Klass::layout_helper_offset());
3376           Address klass_lh_addr(tmp, lh_offset);
3377           jint objArray_lh = Klass::array_layout_helper(T_OBJECT);
3378           __ cmpl(klass_lh_addr, objArray_lh);
3379           __ jcc(Assembler::notEqual, *stub-&gt;entry());
3380         }
3381 
3382        // Spill because stubs can use any register they like and it&#39;s
3383        // easier to restore just those that we care about.
3384        store_parameter(dst, 0);
3385        store_parameter(dst_pos, 1);
3386        store_parameter(length, 2);
3387        store_parameter(src_pos, 3);
3388        store_parameter(src, 4);
3389 
3390 #ifndef _LP64
3391         __ movptr(tmp, dst_klass_addr);
3392         __ movptr(tmp, Address(tmp, ObjArrayKlass::element_klass_offset()));
3393         __ push(tmp);
3394         __ movl(tmp, Address(tmp, Klass::super_check_offset_offset()));
3395         __ push(tmp);
3396         __ push(length);
3397         __ lea(tmp, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3398         __ push(tmp);
3399         __ lea(tmp, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3400         __ push(tmp);
3401 
3402         __ call_VM_leaf(copyfunc_addr, 5);
3403 #else
3404         __ movl2ptr(length, length); //higher 32bits must be null
3405 
3406         __ lea(c_rarg0, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3407         assert_different_registers(c_rarg0, dst, dst_pos, length);
3408         __ lea(c_rarg1, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3409         assert_different_registers(c_rarg1, dst, length);
3410 
3411         __ mov(c_rarg2, length);
3412         assert_different_registers(c_rarg2, dst);
3413 
3414 #ifdef _WIN64
3415         // Allocate abi space for args but be sure to keep stack aligned
3416         __ subptr(rsp, 6*wordSize);
3417         __ load_klass(c_rarg3, dst);
3418         __ movptr(c_rarg3, Address(c_rarg3, ObjArrayKlass::element_klass_offset()));
3419         store_parameter(c_rarg3, 4);
3420         __ movl(c_rarg3, Address(c_rarg3, Klass::super_check_offset_offset()));
3421         __ call(RuntimeAddress(copyfunc_addr));
3422         __ addptr(rsp, 6*wordSize);
3423 #else
3424         __ load_klass(c_rarg4, dst);
3425         __ movptr(c_rarg4, Address(c_rarg4, ObjArrayKlass::element_klass_offset()));
3426         __ movl(c_rarg3, Address(c_rarg4, Klass::super_check_offset_offset()));
3427         __ call(RuntimeAddress(copyfunc_addr));
3428 #endif
3429 
3430 #endif
3431 
3432 #ifndef PRODUCT
3433         if (PrintC1Statistics) {
3434           Label failed;
3435           __ testl(rax, rax);
3436           __ jcc(Assembler::notZero, failed);
3437           __ incrementl(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_cnt));
3438           __ bind(failed);
3439         }
3440 #endif
3441 
3442         __ testl(rax, rax);
3443         __ jcc(Assembler::zero, *stub-&gt;continuation());
3444 
3445 #ifndef PRODUCT
3446         if (PrintC1Statistics) {
3447           __ incrementl(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_attempt_cnt));
3448         }
3449 #endif
3450 
3451         __ mov(tmp, rax);
3452 
3453         __ xorl(tmp, -1);
3454 
3455         // Restore previously spilled arguments
3456         __ movptr   (dst,     Address(rsp, 0*BytesPerWord));
3457         __ movptr   (dst_pos, Address(rsp, 1*BytesPerWord));
3458         __ movptr   (length,  Address(rsp, 2*BytesPerWord));
3459         __ movptr   (src_pos, Address(rsp, 3*BytesPerWord));
3460         __ movptr   (src,     Address(rsp, 4*BytesPerWord));
3461 
3462 
3463         __ subl(length, tmp);
3464         __ addl(src_pos, tmp);
3465         __ addl(dst_pos, tmp);
3466       }
3467 
3468       __ jmp(*stub-&gt;entry());
3469 
3470       __ bind(cont);
3471       __ pop(dst);
3472       __ pop(src);
3473     }
3474   }
3475 
3476 #ifdef ASSERT
3477   if (basic_type != T_OBJECT || !(flags &amp; LIR_OpArrayCopy::type_check)) {
3478     // Sanity check the known type with the incoming class.  For the
3479     // primitive case the types must match exactly with src.klass and
3480     // dst.klass each exactly matching the default type.  For the
3481     // object array case, if no type check is needed then either the
3482     // dst type is exactly the expected type and the src type is a
3483     // subtype which we can&#39;t check or src is the same array as dst
3484     // but not necessarily exactly of type default_type.
3485     Label known_ok, halt;
3486     __ mov_metadata(tmp, default_type-&gt;constant_encoding());
3487 #ifdef _LP64
3488     if (UseCompressedClassPointers) {
3489       __ encode_klass_not_null(tmp);
3490     }
3491 #endif
3492 
3493     if (basic_type != T_OBJECT) {
3494 
3495       if (UseCompressedClassPointers)          __ cmpl(tmp, dst_klass_addr);
3496       else                   __ cmpptr(tmp, dst_klass_addr);
3497       __ jcc(Assembler::notEqual, halt);
3498       if (UseCompressedClassPointers)          __ cmpl(tmp, src_klass_addr);
3499       else                   __ cmpptr(tmp, src_klass_addr);
3500       __ jcc(Assembler::equal, known_ok);
3501     } else {
3502       if (UseCompressedClassPointers)          __ cmpl(tmp, dst_klass_addr);
3503       else                   __ cmpptr(tmp, dst_klass_addr);
3504       __ jcc(Assembler::equal, known_ok);
3505       __ cmpptr(src, dst);
3506       __ jcc(Assembler::equal, known_ok);
3507     }
3508     __ bind(halt);
3509     __ stop(&quot;incorrect type information in arraycopy&quot;);
3510     __ bind(known_ok);
3511   }
3512 #endif
3513 
3514 #ifndef PRODUCT
3515   if (PrintC1Statistics) {
3516     __ incrementl(ExternalAddress(Runtime1::arraycopy_count_address(basic_type)));
3517   }
3518 #endif
3519 
3520 #ifdef _LP64
3521   assert_different_registers(c_rarg0, dst, dst_pos, length);
3522   __ lea(c_rarg0, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3523   assert_different_registers(c_rarg1, length);
3524   __ lea(c_rarg1, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3525   __ mov(c_rarg2, length);
3526 
3527 #else
3528   __ lea(tmp, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3529   store_parameter(tmp, 0);
3530   __ lea(tmp, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3531   store_parameter(tmp, 1);
3532   store_parameter(length, 2);
3533 #endif // _LP64
3534 
3535   bool disjoint = (flags &amp; LIR_OpArrayCopy::overlapping) == 0;
3536   bool aligned = (flags &amp; LIR_OpArrayCopy::unaligned) == 0;
3537   const char *name;
3538   address entry = StubRoutines::select_arraycopy_function(basic_type, aligned, disjoint, name, false);
3539   __ call_VM_leaf(entry, 0);
3540 
3541   __ bind(*stub-&gt;continuation());
3542 }
3543 
3544 void LIR_Assembler::emit_updatecrc32(LIR_OpUpdateCRC32* op) {
3545   assert(op-&gt;crc()-&gt;is_single_cpu(),  &quot;crc must be register&quot;);
3546   assert(op-&gt;val()-&gt;is_single_cpu(),  &quot;byte value must be register&quot;);
3547   assert(op-&gt;result_opr()-&gt;is_single_cpu(), &quot;result must be register&quot;);
3548   Register crc = op-&gt;crc()-&gt;as_register();
3549   Register val = op-&gt;val()-&gt;as_register();
3550   Register res = op-&gt;result_opr()-&gt;as_register();
3551 
3552   assert_different_registers(val, crc, res);
3553 
3554   __ lea(res, ExternalAddress(StubRoutines::crc_table_addr()));
3555   __ notl(crc); // ~crc
3556   __ update_byte_crc32(crc, val, res);
3557   __ notl(crc); // ~crc
3558   __ mov(res, crc);
3559 }
3560 
3561 void LIR_Assembler::emit_lock(LIR_OpLock* op) {
3562   Register obj = op-&gt;obj_opr()-&gt;as_register();  // may not be an oop
3563   Register hdr = op-&gt;hdr_opr()-&gt;as_register();
3564   Register lock = op-&gt;lock_opr()-&gt;as_register();
3565   if (!UseFastLocking) {
3566     __ jmp(*op-&gt;stub()-&gt;entry());
3567   } else if (op-&gt;code() == lir_lock) {
3568     Register scratch = noreg;
3569     if (UseBiasedLocking) {
3570       scratch = op-&gt;scratch_opr()-&gt;as_register();
3571     }
3572     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
3573     __ resolve(ACCESS_READ | ACCESS_WRITE, obj);
3574     // add debug info for NullPointerException only if one is possible
3575     int null_check_offset = __ lock_object(hdr, obj, lock, scratch, *op-&gt;stub()-&gt;entry());
3576     if (op-&gt;info() != NULL) {
3577       add_debug_info_for_null_check(null_check_offset, op-&gt;info());
3578     }
3579     // done
3580   } else if (op-&gt;code() == lir_unlock) {
3581     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
3582     __ unlock_object(hdr, obj, lock, *op-&gt;stub()-&gt;entry());
3583   } else {
3584     Unimplemented();
3585   }
3586   __ bind(*op-&gt;stub()-&gt;continuation());
3587 }
3588 
3589 
3590 void LIR_Assembler::emit_profile_call(LIR_OpProfileCall* op) {
3591   ciMethod* method = op-&gt;profiled_method();
3592   int bci          = op-&gt;profiled_bci();
3593   ciMethod* callee = op-&gt;profiled_callee();
3594 
3595   // Update counter for all call types
3596   ciMethodData* md = method-&gt;method_data_or_null();
3597   assert(md != NULL, &quot;Sanity&quot;);
3598   ciProfileData* data = md-&gt;bci_to_data(bci);
3599   assert(data != NULL &amp;&amp; data-&gt;is_CounterData(), &quot;need CounterData for calls&quot;);
3600   assert(op-&gt;mdo()-&gt;is_single_cpu(),  &quot;mdo must be allocated&quot;);
3601   Register mdo  = op-&gt;mdo()-&gt;as_register();
3602   __ mov_metadata(mdo, md-&gt;constant_encoding());
3603   Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
3604   // Perform additional virtual call profiling for invokevirtual and
3605   // invokeinterface bytecodes
3606   if (op-&gt;should_profile_receiver_type()) {
3607     assert(op-&gt;recv()-&gt;is_single_cpu(), &quot;recv must be allocated&quot;);
3608     Register recv = op-&gt;recv()-&gt;as_register();
3609     assert_different_registers(mdo, recv);
3610     assert(data-&gt;is_VirtualCallData(), &quot;need VirtualCallData for virtual calls&quot;);
3611     ciKlass* known_klass = op-&gt;known_holder();
3612     if (C1OptimizeVirtualCallProfiling &amp;&amp; known_klass != NULL) {
3613       // We know the type that will be seen at this call site; we can
3614       // statically update the MethodData* rather than needing to do
3615       // dynamic tests on the receiver type
3616 
3617       // NOTE: we should probably put a lock around this search to
3618       // avoid collisions by concurrent compilations
3619       ciVirtualCallData* vc_data = (ciVirtualCallData*) data;
3620       uint i;
3621       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
3622         ciKlass* receiver = vc_data-&gt;receiver(i);
3623         if (known_klass-&gt;equals(receiver)) {
3624           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
3625           __ addptr(data_addr, DataLayout::counter_increment);
3626           return;
3627         }
3628       }
3629 
3630       // Receiver type not found in profile data; select an empty slot
3631 
3632       // Note that this is less efficient than it should be because it
3633       // always does a write to the receiver part of the
3634       // VirtualCallData rather than just the first time
3635       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
3636         ciKlass* receiver = vc_data-&gt;receiver(i);
3637         if (receiver == NULL) {
3638           Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_offset(i)));
3639           __ mov_metadata(recv_addr, known_klass-&gt;constant_encoding());
3640           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
3641           __ addptr(data_addr, DataLayout::counter_increment);
3642           return;
3643         }
3644       }
3645     } else {
3646       __ load_klass(recv, recv);
3647       Label update_done;
3648       type_profile_helper(mdo, md, data, recv, &amp;update_done);
3649       // Receiver did not match any saved receiver and there is no empty row for it.
3650       // Increment total counter to indicate polymorphic case.
3651       __ addptr(counter_addr, DataLayout::counter_increment);
3652 
3653       __ bind(update_done);
3654     }
3655   } else {
3656     // Static call
3657     __ addptr(counter_addr, DataLayout::counter_increment);
3658   }
3659 }
3660 
3661 void LIR_Assembler::emit_profile_type(LIR_OpProfileType* op) {
3662   Register obj = op-&gt;obj()-&gt;as_register();
3663   Register tmp = op-&gt;tmp()-&gt;as_pointer_register();
3664   Address mdo_addr = as_Address(op-&gt;mdp()-&gt;as_address_ptr());
3665   ciKlass* exact_klass = op-&gt;exact_klass();
3666   intptr_t current_klass = op-&gt;current_klass();
3667   bool not_null = op-&gt;not_null();
3668   bool no_conflict = op-&gt;no_conflict();
3669 
3670   Label update, next, none;
3671 
3672   bool do_null = !not_null;
3673   bool exact_klass_set = exact_klass != NULL &amp;&amp; ciTypeEntries::valid_ciklass(current_klass) == exact_klass;
3674   bool do_update = !TypeEntries::is_type_unknown(current_klass) &amp;&amp; !exact_klass_set;
3675 
3676   assert(do_null || do_update, &quot;why are we here?&quot;);
3677   assert(!TypeEntries::was_null_seen(current_klass) || do_update, &quot;why are we here?&quot;);
3678 
3679   __ verify_oop(obj);
3680 
3681   if (tmp != obj) {
3682     __ mov(tmp, obj);
3683   }
3684   if (do_null) {
3685     __ testptr(tmp, tmp);
3686     __ jccb(Assembler::notZero, update);
3687     if (!TypeEntries::was_null_seen(current_klass)) {
3688       __ orptr(mdo_addr, TypeEntries::null_seen);
3689     }
3690     if (do_update) {
3691 #ifndef ASSERT
3692       __ jmpb(next);
3693     }
3694 #else
3695       __ jmp(next);
3696     }
3697   } else {
3698     __ testptr(tmp, tmp);
3699     __ jcc(Assembler::notZero, update);
3700     __ stop(&quot;unexpect null obj&quot;);
3701 #endif
3702   }
3703 
3704   __ bind(update);
3705 
3706   if (do_update) {
3707 #ifdef ASSERT
3708     if (exact_klass != NULL) {
3709       Label ok;
3710       __ load_klass(tmp, tmp);
3711       __ push(tmp);
3712       __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3713       __ cmpptr(tmp, Address(rsp, 0));
3714       __ jcc(Assembler::equal, ok);
3715       __ stop(&quot;exact klass and actual klass differ&quot;);
3716       __ bind(ok);
3717       __ pop(tmp);
3718     }
3719 #endif
3720     if (!no_conflict) {
3721       if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {
3722         if (exact_klass != NULL) {
3723           __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3724         } else {
3725           __ load_klass(tmp, tmp);
3726         }
3727 
3728         __ xorptr(tmp, mdo_addr);
3729         __ testptr(tmp, TypeEntries::type_klass_mask);
3730         // klass seen before, nothing to do. The unknown bit may have been
3731         // set already but no need to check.
3732         __ jccb(Assembler::zero, next);
3733 
3734         __ testptr(tmp, TypeEntries::type_unknown);
3735         __ jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
3736 
3737         if (TypeEntries::is_type_none(current_klass)) {
3738           __ cmpptr(mdo_addr, 0);
3739           __ jccb(Assembler::equal, none);
3740           __ cmpptr(mdo_addr, TypeEntries::null_seen);
3741           __ jccb(Assembler::equal, none);
3742           // There is a chance that the checks above (re-reading profiling
3743           // data from memory) fail if another thread has just set the
3744           // profiling to this obj&#39;s klass
3745           __ xorptr(tmp, mdo_addr);
3746           __ testptr(tmp, TypeEntries::type_klass_mask);
3747           __ jccb(Assembler::zero, next);
3748         }
3749       } else {
3750         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3751                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;conflict only&quot;);
3752 
3753         __ movptr(tmp, mdo_addr);
3754         __ testptr(tmp, TypeEntries::type_unknown);
3755         __ jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
3756       }
3757 
3758       // different than before. Cannot keep accurate profile.
3759       __ orptr(mdo_addr, TypeEntries::type_unknown);
3760 
3761       if (TypeEntries::is_type_none(current_klass)) {
3762         __ jmpb(next);
3763 
3764         __ bind(none);
3765         // first time here. Set profile type.
3766         __ movptr(mdo_addr, tmp);
3767       }
3768     } else {
3769       // There&#39;s a single possible klass at this profile point
3770       assert(exact_klass != NULL, &quot;should be&quot;);
3771       if (TypeEntries::is_type_none(current_klass)) {
3772         __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3773         __ xorptr(tmp, mdo_addr);
3774         __ testptr(tmp, TypeEntries::type_klass_mask);
3775 #ifdef ASSERT
3776         __ jcc(Assembler::zero, next);
3777 
3778         {
3779           Label ok;
3780           __ push(tmp);
3781           __ cmpptr(mdo_addr, 0);
3782           __ jcc(Assembler::equal, ok);
3783           __ cmpptr(mdo_addr, TypeEntries::null_seen);
3784           __ jcc(Assembler::equal, ok);
3785           // may have been set by another thread
3786           __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3787           __ xorptr(tmp, mdo_addr);
3788           __ testptr(tmp, TypeEntries::type_mask);
3789           __ jcc(Assembler::zero, ok);
3790 
3791           __ stop(&quot;unexpected profiling mismatch&quot;);
3792           __ bind(ok);
3793           __ pop(tmp);
3794         }
3795 #else
3796         __ jccb(Assembler::zero, next);
3797 #endif
3798         // first time here. Set profile type.
3799         __ movptr(mdo_addr, tmp);
3800       } else {
3801         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3802                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;inconsistent&quot;);
3803 
3804         __ movptr(tmp, mdo_addr);
3805         __ testptr(tmp, TypeEntries::type_unknown);
3806         __ jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
3807 
3808         __ orptr(mdo_addr, TypeEntries::type_unknown);
3809       }
3810     }
3811 
3812     __ bind(next);
3813   }
3814 }
3815 
3816 void LIR_Assembler::emit_delay(LIR_OpDelay*) {
3817   Unimplemented();
3818 }
3819 
3820 
3821 void LIR_Assembler::monitor_address(int monitor_no, LIR_Opr dst) {
3822   __ lea(dst-&gt;as_register(), frame_map()-&gt;address_for_monitor_lock(monitor_no));
3823 }
3824 
3825 
3826 void LIR_Assembler::align_backward_branch_target() {
3827   __ align(BytesPerWord);
3828 }
3829 
3830 
3831 void LIR_Assembler::negate(LIR_Opr left, LIR_Opr dest, LIR_Opr tmp) {
3832   if (left-&gt;is_single_cpu()) {
3833     __ negl(left-&gt;as_register());
3834     move_regs(left-&gt;as_register(), dest-&gt;as_register());
3835 
3836   } else if (left-&gt;is_double_cpu()) {
3837     Register lo = left-&gt;as_register_lo();
3838 #ifdef _LP64
3839     Register dst = dest-&gt;as_register_lo();
3840     __ movptr(dst, lo);
3841     __ negptr(dst);
3842 #else
3843     Register hi = left-&gt;as_register_hi();
3844     __ lneg(hi, lo);
3845     if (dest-&gt;as_register_lo() == hi) {
3846       assert(dest-&gt;as_register_hi() != lo, &quot;destroying register&quot;);
3847       move_regs(hi, dest-&gt;as_register_hi());
3848       move_regs(lo, dest-&gt;as_register_lo());
3849     } else {
3850       move_regs(lo, dest-&gt;as_register_lo());
3851       move_regs(hi, dest-&gt;as_register_hi());
3852     }
3853 #endif // _LP64
3854 
3855   } else if (dest-&gt;is_single_xmm()) {
3856 #ifdef _LP64
3857     if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
3858       assert(tmp-&gt;is_valid(), &quot;need temporary&quot;);
3859       assert_different_registers(left-&gt;as_xmm_float_reg(), tmp-&gt;as_xmm_float_reg());
3860       __ vpxor(dest-&gt;as_xmm_float_reg(), tmp-&gt;as_xmm_float_reg(), left-&gt;as_xmm_float_reg(), 2);
3861     }
3862     else
3863 #endif
3864     {
3865       assert(!tmp-&gt;is_valid(), &quot;do not need temporary&quot;);
3866       if (left-&gt;as_xmm_float_reg() != dest-&gt;as_xmm_float_reg()) {
3867         __ movflt(dest-&gt;as_xmm_float_reg(), left-&gt;as_xmm_float_reg());
3868       }
3869       __ xorps(dest-&gt;as_xmm_float_reg(),
3870                ExternalAddress((address)float_signflip_pool));
3871     }
3872   } else if (dest-&gt;is_double_xmm()) {
3873 #ifdef _LP64
3874     if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
3875       assert(tmp-&gt;is_valid(), &quot;need temporary&quot;);
3876       assert_different_registers(left-&gt;as_xmm_double_reg(), tmp-&gt;as_xmm_double_reg());
3877       __ vpxor(dest-&gt;as_xmm_double_reg(), tmp-&gt;as_xmm_double_reg(), left-&gt;as_xmm_double_reg(), 2);
3878     }
3879     else
3880 #endif
3881     {
3882       assert(!tmp-&gt;is_valid(), &quot;do not need temporary&quot;);
3883       if (left-&gt;as_xmm_double_reg() != dest-&gt;as_xmm_double_reg()) {
3884         __ movdbl(dest-&gt;as_xmm_double_reg(), left-&gt;as_xmm_double_reg());
3885       }
3886       __ xorpd(dest-&gt;as_xmm_double_reg(),
3887                ExternalAddress((address)double_signflip_pool));
3888     }
3889 #ifndef _LP64
3890   } else if (left-&gt;is_single_fpu() || left-&gt;is_double_fpu()) {
3891     assert(left-&gt;fpu() == 0, &quot;arg must be on TOS&quot;);
3892     assert(dest-&gt;fpu() == 0, &quot;dest must be TOS&quot;);
3893     __ fchs();
3894 #endif // !_LP64
3895 
3896   } else {
3897     ShouldNotReachHere();
3898   }
3899 }
3900 
3901 
3902 void LIR_Assembler::leal(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
3903   assert(src-&gt;is_address(), &quot;must be an address&quot;);
3904   assert(dest-&gt;is_register(), &quot;must be a register&quot;);
3905 
3906   PatchingStub* patch = NULL;
3907   if (patch_code != lir_patch_none) {
3908     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
3909   }
3910 
3911   Register reg = dest-&gt;as_pointer_register();
3912   LIR_Address* addr = src-&gt;as_address_ptr();
3913   __ lea(reg, as_Address(addr));
3914 
3915   if (patch != NULL) {
3916     patching_epilog(patch, patch_code, addr-&gt;base()-&gt;as_register(), info);
3917   }
3918 }
3919 
3920 
3921 
3922 void LIR_Assembler::rt_call(LIR_Opr result, address dest, const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
3923   assert(!tmp-&gt;is_valid(), &quot;don&#39;t need temporary&quot;);
3924   __ call(RuntimeAddress(dest));
3925   if (info != NULL) {
3926     add_call_info_here(info);
3927   }
3928 }
3929 
3930 
3931 void LIR_Assembler::volatile_move_op(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info) {
3932   assert(type == T_LONG, &quot;only for volatile long fields&quot;);
3933 
3934   if (info != NULL) {
3935     add_debug_info_for_null_check_here(info);
3936   }
3937 
3938   if (src-&gt;is_double_xmm()) {
3939     if (dest-&gt;is_double_cpu()) {
3940 #ifdef _LP64
3941       __ movdq(dest-&gt;as_register_lo(), src-&gt;as_xmm_double_reg());
3942 #else
3943       __ movdl(dest-&gt;as_register_lo(), src-&gt;as_xmm_double_reg());
3944       __ psrlq(src-&gt;as_xmm_double_reg(), 32);
3945       __ movdl(dest-&gt;as_register_hi(), src-&gt;as_xmm_double_reg());
3946 #endif // _LP64
3947     } else if (dest-&gt;is_double_stack()) {
3948       __ movdbl(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix()), src-&gt;as_xmm_double_reg());
3949     } else if (dest-&gt;is_address()) {
3950       __ movdbl(as_Address(dest-&gt;as_address_ptr()), src-&gt;as_xmm_double_reg());
3951     } else {
3952       ShouldNotReachHere();
3953     }
3954 
3955   } else if (dest-&gt;is_double_xmm()) {
3956     if (src-&gt;is_double_stack()) {
3957       __ movdbl(dest-&gt;as_xmm_double_reg(), frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix()));
3958     } else if (src-&gt;is_address()) {
3959       __ movdbl(dest-&gt;as_xmm_double_reg(), as_Address(src-&gt;as_address_ptr()));
3960     } else {
3961       ShouldNotReachHere();
3962     }
3963 
3964 #ifndef _LP64
3965   } else if (src-&gt;is_double_fpu()) {
3966     assert(src-&gt;fpu_regnrLo() == 0, &quot;must be TOS&quot;);
3967     if (dest-&gt;is_double_stack()) {
3968       __ fistp_d(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix()));
3969     } else if (dest-&gt;is_address()) {
3970       __ fistp_d(as_Address(dest-&gt;as_address_ptr()));
3971     } else {
3972       ShouldNotReachHere();
3973     }
3974 
3975   } else if (dest-&gt;is_double_fpu()) {
3976     assert(dest-&gt;fpu_regnrLo() == 0, &quot;must be TOS&quot;);
3977     if (src-&gt;is_double_stack()) {
3978       __ fild_d(frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix()));
3979     } else if (src-&gt;is_address()) {
3980       __ fild_d(as_Address(src-&gt;as_address_ptr()));
3981     } else {
3982       ShouldNotReachHere();
3983     }
3984 #endif // !_LP64
3985 
3986   } else {
3987     ShouldNotReachHere();
3988   }
3989 }
3990 
3991 #ifdef ASSERT
3992 // emit run-time assertion
3993 void LIR_Assembler::emit_assert(LIR_OpAssert* op) {
3994   assert(op-&gt;code() == lir_assert, &quot;must be&quot;);
3995 
3996   if (op-&gt;in_opr1()-&gt;is_valid()) {
3997     assert(op-&gt;in_opr2()-&gt;is_valid(), &quot;both operands must be valid&quot;);
3998     comp_op(op-&gt;condition(), op-&gt;in_opr1(), op-&gt;in_opr2(), op);
3999   } else {
4000     assert(op-&gt;in_opr2()-&gt;is_illegal(), &quot;both operands must be illegal&quot;);
4001     assert(op-&gt;condition() == lir_cond_always, &quot;no other conditions allowed&quot;);
4002   }
4003 
4004   Label ok;
4005   if (op-&gt;condition() != lir_cond_always) {
4006     Assembler::Condition acond = Assembler::zero;
4007     switch (op-&gt;condition()) {
4008       case lir_cond_equal:        acond = Assembler::equal;       break;
4009       case lir_cond_notEqual:     acond = Assembler::notEqual;    break;
4010       case lir_cond_less:         acond = Assembler::less;        break;
4011       case lir_cond_lessEqual:    acond = Assembler::lessEqual;   break;
4012       case lir_cond_greaterEqual: acond = Assembler::greaterEqual;break;
4013       case lir_cond_greater:      acond = Assembler::greater;     break;
4014       case lir_cond_belowEqual:   acond = Assembler::belowEqual;  break;
4015       case lir_cond_aboveEqual:   acond = Assembler::aboveEqual;  break;
4016       default:                    ShouldNotReachHere();
4017     }
4018     __ jcc(acond, ok);
4019   }
4020   if (op-&gt;halt()) {
4021     const char* str = __ code_string(op-&gt;msg());
4022     __ stop(str);
4023   } else {
4024     breakpoint();
4025   }
4026   __ bind(ok);
4027 }
4028 #endif
4029 
4030 void LIR_Assembler::membar() {
4031   // QQQ sparc TSO uses this,
4032   __ membar( Assembler::Membar_mask_bits(Assembler::StoreLoad));
4033 }
4034 
4035 void LIR_Assembler::membar_acquire() {
4036   // No x86 machines currently require load fences
4037 }
4038 
4039 void LIR_Assembler::membar_release() {
4040   // No x86 machines currently require store fences
4041 }
4042 
4043 void LIR_Assembler::membar_loadload() {
4044   // no-op
4045   //__ membar(Assembler::Membar_mask_bits(Assembler::loadload));
4046 }
4047 
4048 void LIR_Assembler::membar_storestore() {
4049   // no-op
4050   //__ membar(Assembler::Membar_mask_bits(Assembler::storestore));
4051 }
4052 
4053 void LIR_Assembler::membar_loadstore() {
4054   // no-op
4055   //__ membar(Assembler::Membar_mask_bits(Assembler::loadstore));
4056 }
4057 
4058 void LIR_Assembler::membar_storeload() {
4059   __ membar(Assembler::Membar_mask_bits(Assembler::StoreLoad));
4060 }
4061 
4062 void LIR_Assembler::on_spin_wait() {
4063   __ pause ();
4064 }
4065 
4066 void LIR_Assembler::get_thread(LIR_Opr result_reg) {
4067   assert(result_reg-&gt;is_register(), &quot;check&quot;);
4068 #ifdef _LP64
4069   // __ get_thread(result_reg-&gt;as_register_lo());
4070   __ mov(result_reg-&gt;as_register(), r15_thread);
4071 #else
4072   __ get_thread(result_reg-&gt;as_register());
4073 #endif // _LP64
4074 }
4075 
4076 
4077 void LIR_Assembler::peephole(LIR_List*) {
4078   // do nothing for now
4079 }
4080 
4081 void LIR_Assembler::atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp) {
4082   assert(data == dest, &quot;xchg/xadd uses only 2 operands&quot;);
4083 
4084   if (data-&gt;type() == T_INT) {
4085     if (code == lir_xadd) {
4086       __ lock();
4087       __ xaddl(as_Address(src-&gt;as_address_ptr()), data-&gt;as_register());
4088     } else {
4089       __ xchgl(data-&gt;as_register(), as_Address(src-&gt;as_address_ptr()));
4090     }
4091   } else if (data-&gt;is_oop()) {
4092     assert (code == lir_xchg, &quot;xadd for oops&quot;);
4093     Register obj = data-&gt;as_register();
4094 #ifdef _LP64
4095     if (UseCompressedOops) {
4096       __ encode_heap_oop(obj);
4097       __ xchgl(obj, as_Address(src-&gt;as_address_ptr()));
4098       __ decode_heap_oop(obj);
4099     } else {
4100       __ xchgptr(obj, as_Address(src-&gt;as_address_ptr()));
4101     }
4102 #else
4103     __ xchgl(obj, as_Address(src-&gt;as_address_ptr()));
4104 #endif
4105   } else if (data-&gt;type() == T_LONG) {
4106 #ifdef _LP64
4107     assert(data-&gt;as_register_lo() == data-&gt;as_register_hi(), &quot;should be a single register&quot;);
4108     if (code == lir_xadd) {
4109       __ lock();
4110       __ xaddq(as_Address(src-&gt;as_address_ptr()), data-&gt;as_register_lo());
4111     } else {
4112       __ xchgq(data-&gt;as_register_lo(), as_Address(src-&gt;as_address_ptr()));
4113     }
4114 #else
4115     ShouldNotReachHere();
4116 #endif
4117   } else {
4118     ShouldNotReachHere();
4119   }
4120 }
4121 
4122 #undef __
    </pre>
  </body>
</html>
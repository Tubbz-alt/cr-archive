<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/linux/os_linux.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="gc/z/zPhysicalMemoryBacking_linux.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../solaris/dtrace/jhelper.d.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/linux/os_linux.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
  57 #include &quot;runtime/perfMemory.hpp&quot;
  58 #include &quot;runtime/sharedRuntime.hpp&quot;
  59 #include &quot;runtime/statSampler.hpp&quot;
  60 #include &quot;runtime/stubRoutines.hpp&quot;
  61 #include &quot;runtime/thread.inline.hpp&quot;
  62 #include &quot;runtime/threadCritical.hpp&quot;
  63 #include &quot;runtime/threadSMR.hpp&quot;
  64 #include &quot;runtime/timer.hpp&quot;
  65 #include &quot;runtime/vm_version.hpp&quot;
  66 #include &quot;semaphore_posix.hpp&quot;
  67 #include &quot;services/attachListener.hpp&quot;
  68 #include &quot;services/memTracker.hpp&quot;
  69 #include &quot;services/runtimeService.hpp&quot;
  70 #include &quot;utilities/align.hpp&quot;
  71 #include &quot;utilities/decoder.hpp&quot;
  72 #include &quot;utilities/defaultStream.hpp&quot;
  73 #include &quot;utilities/events.hpp&quot;
  74 #include &quot;utilities/elfFile.hpp&quot;
  75 #include &quot;utilities/growableArray.hpp&quot;
  76 #include &quot;utilities/macros.hpp&quot;

  77 #include &quot;utilities/vmError.hpp&quot;
  78 
  79 // put OS-includes here
  80 # include &lt;sys/types.h&gt;
  81 # include &lt;sys/mman.h&gt;
  82 # include &lt;sys/stat.h&gt;
  83 # include &lt;sys/select.h&gt;
  84 # include &lt;pthread.h&gt;
  85 # include &lt;signal.h&gt;
  86 # include &lt;endian.h&gt;
  87 # include &lt;errno.h&gt;
  88 # include &lt;dlfcn.h&gt;
  89 # include &lt;stdio.h&gt;
  90 # include &lt;unistd.h&gt;
  91 # include &lt;sys/resource.h&gt;
  92 # include &lt;pthread.h&gt;
  93 # include &lt;sys/stat.h&gt;
  94 # include &lt;sys/time.h&gt;
  95 # include &lt;sys/times.h&gt;
  96 # include &lt;sys/utsname.h&gt;
</pre>
<hr />
<pre>
 700   // will alloca() a little more space than necessary, which is OK. Don&#39;t use
 701   // os::current_stack_pointer(), as its result can be slightly below current
 702   // stack pointer, causing us to not alloca enough to reach &quot;bottom&quot;.
 703   sp = (address)&amp;sp;
 704 
 705   if (sp &gt; bottom) {
 706     size = sp - bottom;
 707     p = (volatile char *)alloca(size);
 708     assert(p != NULL &amp;&amp; p &lt;= (volatile char *)bottom, &quot;alloca problem?&quot;);
 709     p[0] = &#39;\0&#39;;
 710   }
 711 }
 712 
 713 void os::Linux::expand_stack_to(address bottom) {
 714   _expand_stack_to(bottom);
 715 }
 716 
 717 bool os::Linux::manually_expand_stack(JavaThread * t, address addr) {
 718   assert(t!=NULL, &quot;just checking&quot;);
 719   assert(t-&gt;osthread()-&gt;expanding_stack(), &quot;expand should be set&quot;);
<span class="line-removed"> 720   assert(t-&gt;stack_base() != NULL, &quot;stack_base was not initialized&quot;);</span>
 721 
<span class="line-modified"> 722   if (addr &lt;  t-&gt;stack_base() &amp;&amp; addr &gt;= t-&gt;stack_reserved_zone_base()) {</span>
 723     sigset_t mask_all, old_sigset;
 724     sigfillset(&amp;mask_all);
 725     pthread_sigmask(SIG_SETMASK, &amp;mask_all, &amp;old_sigset);
 726     _expand_stack_to(addr);
 727     pthread_sigmask(SIG_SETMASK, &amp;old_sigset, NULL);
 728     return true;
 729   }
 730   return false;
 731 }
 732 
 733 //////////////////////////////////////////////////////////////////////////////
 734 // create new thread
 735 
 736 // Thread start routine for all newly created threads
 737 static void *thread_native_entry(Thread *thread) {
 738 
 739   thread-&gt;record_stack_base_and_size();
 740 
 741   // Try to randomize the cache line index of hot stack frames.
 742   // This helps when threads of the same stack traces evict each other&#39;s
</pre>
<hr />
<pre>
2285   st-&gt;print_cr(&quot;/proc/sys/kernel/threads-max (system-wide limit on the number of threads):&quot;);
2286   _print_ascii_file(&quot;/proc/sys/kernel/threads-max&quot;, st);
2287   st-&gt;cr();
2288   st-&gt;cr();
2289 
2290   st-&gt;print_cr(&quot;/proc/sys/vm/max_map_count (maximum number of memory map areas a process may have):&quot;);
2291   _print_ascii_file(&quot;/proc/sys/vm/max_map_count&quot;, st);
2292   st-&gt;cr();
2293   st-&gt;cr();
2294 
2295   st-&gt;print_cr(&quot;/proc/sys/kernel/pid_max (system-wide limit on number of process identifiers):&quot;);
2296   _print_ascii_file(&quot;/proc/sys/kernel/pid_max&quot;, st);
2297   st-&gt;cr();
2298   st-&gt;cr();
2299 }
2300 
2301 void os::Linux::print_full_memory_info(outputStream* st) {
2302   st-&gt;print(&quot;\n/proc/meminfo:\n&quot;);
2303   _print_ascii_file(&quot;/proc/meminfo&quot;, st);
2304   st-&gt;cr();













2305 }
2306 
2307 void os::Linux::print_ld_preload_file(outputStream* st) {
2308   _print_ascii_file(&quot;/etc/ld.so.preload&quot;, st, &quot;\n/etc/ld.so.preload:&quot;);
2309   st-&gt;cr();
2310 }
2311 
2312 void os::Linux::print_uptime_info(outputStream* st) {
2313   struct sysinfo sinfo;
2314   int ret = sysinfo(&amp;sinfo);
2315   if (ret == 0) {
2316     os::print_dhm(st, &quot;OS uptime:&quot;, (long) sinfo.uptime);
2317   }
2318 }
2319 
2320 
2321 void os::Linux::print_container_info(outputStream* st) {
2322   if (!OSContainer::is_containerized()) {
2323     return;
2324   }
</pre>
<hr />
<pre>
4302    4,              // 1 MinPriority
4303    3,              // 2
4304    2,              // 3
4305 
4306    1,              // 4
4307    0,              // 5 NormPriority
4308   -1,              // 6
4309 
4310   -2,              // 7
4311   -3,              // 8
4312   -4,              // 9 NearMaxPriority
4313 
4314   -5,              // 10 MaxPriority
4315 
4316   -5               // 11 CriticalPriority
4317 };
4318 
4319 static int prio_init() {
4320   if (ThreadPriorityPolicy == 1) {
4321     if (geteuid() != 0) {
<span class="line-modified">4322       if (!FLAG_IS_DEFAULT(ThreadPriorityPolicy)) {</span>
4323         warning(&quot;-XX:ThreadPriorityPolicy=1 may require system level permission, &quot; \
4324                 &quot;e.g., being the root user. If the necessary permission is not &quot; \
4325                 &quot;possessed, changes to priority will be silently ignored.&quot;);
4326       }
4327     }
4328   }
4329   if (UseCriticalJavaThreadPriority) {
4330     os::java_to_os_priority[MaxPriority] = os::java_to_os_priority[CriticalPriority];
4331   }
4332   return 0;
4333 }
4334 
4335 OSReturn os::set_native_priority(Thread* thread, int newpri) {
4336   if (!UseThreadPriorities || ThreadPriorityPolicy == 0) return OS_OK;
4337 
4338   int ret = setpriority(PRIO_PROCESS, thread-&gt;osthread()-&gt;thread_id(), newpri);
4339   return (ret == 0) ? OS_OK : OS_ERR;
4340 }
4341 
4342 OSReturn os::get_native_priority(const Thread* const thread,
</pre>
<hr />
<pre>
5109   // Java can be invoked as
5110   // 1. Without numactl and heap will be allocated/configured on all nodes as
5111   //    per the system policy.
5112   // 2. With numactl --interleave:
5113   //      Use numa_get_interleave_mask(v2) API to get nodes bitmask. The same
5114   //      API for membind case bitmask is reset.
5115   //      Interleave is only hint and Kernel can fallback to other nodes if
5116   //      no memory is available on the target nodes.
5117   // 3. With numactl --membind:
5118   //      Use numa_get_membind(v2) API to get nodes bitmask. The same API for
5119   //      interleave case returns bitmask of all nodes.
5120   // numa_all_nodes_ptr holds bitmask of all nodes.
5121   // numa_get_interleave_mask(v2) and numa_get_membind(v2) APIs returns correct
5122   // bitmask when externally configured to run on all or fewer nodes.
5123 
5124   if (!Linux::libnuma_init()) {
5125     UseNUMA = false;
5126   } else {
5127     if ((Linux::numa_max_node() &lt; 1) || Linux::is_bound_to_single_node()) {
5128       // If there&#39;s only one node (they start from 0) or if the process
<span class="line-modified">5129       // is bound explicitly to a single node using membind, disable NUMA.</span>
<span class="line-modified">5130       UseNUMA = false;</span>

5131     } else {
5132 
5133       LogTarget(Info,os) log;
5134       LogStream ls(log);
5135 
5136       Linux::set_configured_numa_policy(Linux::identify_numa_policy());
5137 
5138       struct bitmask* bmp = Linux::_numa_membind_bitmask;
5139       const char* numa_mode = &quot;membind&quot;;
5140 
5141       if (Linux::is_running_in_interleave_mode()) {
5142         bmp = Linux::_numa_interleave_bitmask;
5143         numa_mode = &quot;interleave&quot;;
5144       }
5145 
5146       ls.print(&quot;UseNUMA is enabled and invoked in &#39;%s&#39; mode.&quot;
5147                &quot; Heap will be configured using NUMA memory nodes:&quot;, numa_mode);
5148 
5149       for (int node = 0; node &lt;= Linux::numa_max_node(); node++) {
5150         if (Linux::_numa_bitmask_isbitset(bmp, node)) {
5151           ls.print(&quot; %d&quot;, node);
5152         }
5153       }
5154     }
5155   }
5156 
5157   if (UseParallelGC &amp;&amp; UseNUMA &amp;&amp; UseLargePages &amp;&amp; !can_commit_large_page_memory()) {
5158     // With SHM and HugeTLBFS large pages we cannot uncommit a page, so there&#39;s no way
5159     // we can make the adaptive lgrp chunk resizing work. If the user specified both
5160     // UseNUMA and UseLargePages (or UseSHM/UseHugeTLBFS) on the command line - warn
5161     // and disable adaptive resizing.
5162     if (UseAdaptiveSizePolicy || UseAdaptiveNUMAChunkSizing) {
5163       warning(&quot;UseNUMA is not fully compatible with SHM/HugeTLBFS large pages, &quot;
5164               &quot;disabling adaptive resizing (-XX:-UseAdaptiveSizePolicy -XX:-UseAdaptiveNUMAChunkSizing)&quot;);
5165       UseAdaptiveSizePolicy = false;
5166       UseAdaptiveNUMAChunkSizing = false;
5167     }
5168   }
<span class="line-removed">5169 </span>
<span class="line-removed">5170   if (!UseNUMA &amp;&amp; ForceNUMA) {</span>
<span class="line-removed">5171     UseNUMA = true;</span>
<span class="line-removed">5172   }</span>
5173 }
5174 
5175 // this is called _after_ the global arguments have been parsed
5176 jint os::init_2(void) {
5177 
5178   // This could be set after os::Posix::init() but all platforms
5179   // have to set it the same so we have to mirror Solaris.
5180   DEBUG_ONLY(os::set_mutex_init_done();)
5181 
5182   os::Posix::init_2();
5183 
5184   Linux::fast_thread_clock_init();
5185 
5186   // initialize suspend/resume support - must do this before signal_sets_init()
5187   if (SR_initialize() != 0) {
5188     perror(&quot;SR_initialize failed&quot;);
5189     return JNI_ERR;
5190   }
5191 
5192   Linux::signal_sets_init();
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
  57 #include &quot;runtime/perfMemory.hpp&quot;
  58 #include &quot;runtime/sharedRuntime.hpp&quot;
  59 #include &quot;runtime/statSampler.hpp&quot;
  60 #include &quot;runtime/stubRoutines.hpp&quot;
  61 #include &quot;runtime/thread.inline.hpp&quot;
  62 #include &quot;runtime/threadCritical.hpp&quot;
  63 #include &quot;runtime/threadSMR.hpp&quot;
  64 #include &quot;runtime/timer.hpp&quot;
  65 #include &quot;runtime/vm_version.hpp&quot;
  66 #include &quot;semaphore_posix.hpp&quot;
  67 #include &quot;services/attachListener.hpp&quot;
  68 #include &quot;services/memTracker.hpp&quot;
  69 #include &quot;services/runtimeService.hpp&quot;
  70 #include &quot;utilities/align.hpp&quot;
  71 #include &quot;utilities/decoder.hpp&quot;
  72 #include &quot;utilities/defaultStream.hpp&quot;
  73 #include &quot;utilities/events.hpp&quot;
  74 #include &quot;utilities/elfFile.hpp&quot;
  75 #include &quot;utilities/growableArray.hpp&quot;
  76 #include &quot;utilities/macros.hpp&quot;
<span class="line-added">  77 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  78 #include &quot;utilities/vmError.hpp&quot;
  79 
  80 // put OS-includes here
  81 # include &lt;sys/types.h&gt;
  82 # include &lt;sys/mman.h&gt;
  83 # include &lt;sys/stat.h&gt;
  84 # include &lt;sys/select.h&gt;
  85 # include &lt;pthread.h&gt;
  86 # include &lt;signal.h&gt;
  87 # include &lt;endian.h&gt;
  88 # include &lt;errno.h&gt;
  89 # include &lt;dlfcn.h&gt;
  90 # include &lt;stdio.h&gt;
  91 # include &lt;unistd.h&gt;
  92 # include &lt;sys/resource.h&gt;
  93 # include &lt;pthread.h&gt;
  94 # include &lt;sys/stat.h&gt;
  95 # include &lt;sys/time.h&gt;
  96 # include &lt;sys/times.h&gt;
  97 # include &lt;sys/utsname.h&gt;
</pre>
<hr />
<pre>
 701   // will alloca() a little more space than necessary, which is OK. Don&#39;t use
 702   // os::current_stack_pointer(), as its result can be slightly below current
 703   // stack pointer, causing us to not alloca enough to reach &quot;bottom&quot;.
 704   sp = (address)&amp;sp;
 705 
 706   if (sp &gt; bottom) {
 707     size = sp - bottom;
 708     p = (volatile char *)alloca(size);
 709     assert(p != NULL &amp;&amp; p &lt;= (volatile char *)bottom, &quot;alloca problem?&quot;);
 710     p[0] = &#39;\0&#39;;
 711   }
 712 }
 713 
 714 void os::Linux::expand_stack_to(address bottom) {
 715   _expand_stack_to(bottom);
 716 }
 717 
 718 bool os::Linux::manually_expand_stack(JavaThread * t, address addr) {
 719   assert(t!=NULL, &quot;just checking&quot;);
 720   assert(t-&gt;osthread()-&gt;expanding_stack(), &quot;expand should be set&quot;);

 721 
<span class="line-modified"> 722   if (t-&gt;is_in_usable_stack(addr)) {</span>
 723     sigset_t mask_all, old_sigset;
 724     sigfillset(&amp;mask_all);
 725     pthread_sigmask(SIG_SETMASK, &amp;mask_all, &amp;old_sigset);
 726     _expand_stack_to(addr);
 727     pthread_sigmask(SIG_SETMASK, &amp;old_sigset, NULL);
 728     return true;
 729   }
 730   return false;
 731 }
 732 
 733 //////////////////////////////////////////////////////////////////////////////
 734 // create new thread
 735 
 736 // Thread start routine for all newly created threads
 737 static void *thread_native_entry(Thread *thread) {
 738 
 739   thread-&gt;record_stack_base_and_size();
 740 
 741   // Try to randomize the cache line index of hot stack frames.
 742   // This helps when threads of the same stack traces evict each other&#39;s
</pre>
<hr />
<pre>
2285   st-&gt;print_cr(&quot;/proc/sys/kernel/threads-max (system-wide limit on the number of threads):&quot;);
2286   _print_ascii_file(&quot;/proc/sys/kernel/threads-max&quot;, st);
2287   st-&gt;cr();
2288   st-&gt;cr();
2289 
2290   st-&gt;print_cr(&quot;/proc/sys/vm/max_map_count (maximum number of memory map areas a process may have):&quot;);
2291   _print_ascii_file(&quot;/proc/sys/vm/max_map_count&quot;, st);
2292   st-&gt;cr();
2293   st-&gt;cr();
2294 
2295   st-&gt;print_cr(&quot;/proc/sys/kernel/pid_max (system-wide limit on number of process identifiers):&quot;);
2296   _print_ascii_file(&quot;/proc/sys/kernel/pid_max&quot;, st);
2297   st-&gt;cr();
2298   st-&gt;cr();
2299 }
2300 
2301 void os::Linux::print_full_memory_info(outputStream* st) {
2302   st-&gt;print(&quot;\n/proc/meminfo:\n&quot;);
2303   _print_ascii_file(&quot;/proc/meminfo&quot;, st);
2304   st-&gt;cr();
<span class="line-added">2305 </span>
<span class="line-added">2306   // some information regarding THPs; for details see</span>
<span class="line-added">2307   // https://www.kernel.org/doc/Documentation/vm/transhuge.txt</span>
<span class="line-added">2308   st-&gt;print_cr(&quot;/sys/kernel/mm/transparent_hugepage/enabled:&quot;);</span>
<span class="line-added">2309   if (!_print_ascii_file(&quot;/sys/kernel/mm/transparent_hugepage/enabled&quot;, st)) {</span>
<span class="line-added">2310     st-&gt;print_cr(&quot;  &lt;Not Available&gt;&quot;);</span>
<span class="line-added">2311   }</span>
<span class="line-added">2312   st-&gt;cr();</span>
<span class="line-added">2313   st-&gt;print_cr(&quot;/sys/kernel/mm/transparent_hugepage/defrag (defrag/compaction efforts parameter):&quot;);</span>
<span class="line-added">2314   if (!_print_ascii_file(&quot;/sys/kernel/mm/transparent_hugepage/defrag&quot;, st)) {</span>
<span class="line-added">2315     st-&gt;print_cr(&quot;  &lt;Not Available&gt;&quot;);</span>
<span class="line-added">2316   }</span>
<span class="line-added">2317   st-&gt;cr();</span>
2318 }
2319 
2320 void os::Linux::print_ld_preload_file(outputStream* st) {
2321   _print_ascii_file(&quot;/etc/ld.so.preload&quot;, st, &quot;\n/etc/ld.so.preload:&quot;);
2322   st-&gt;cr();
2323 }
2324 
2325 void os::Linux::print_uptime_info(outputStream* st) {
2326   struct sysinfo sinfo;
2327   int ret = sysinfo(&amp;sinfo);
2328   if (ret == 0) {
2329     os::print_dhm(st, &quot;OS uptime:&quot;, (long) sinfo.uptime);
2330   }
2331 }
2332 
2333 
2334 void os::Linux::print_container_info(outputStream* st) {
2335   if (!OSContainer::is_containerized()) {
2336     return;
2337   }
</pre>
<hr />
<pre>
4315    4,              // 1 MinPriority
4316    3,              // 2
4317    2,              // 3
4318 
4319    1,              // 4
4320    0,              // 5 NormPriority
4321   -1,              // 6
4322 
4323   -2,              // 7
4324   -3,              // 8
4325   -4,              // 9 NearMaxPriority
4326 
4327   -5,              // 10 MaxPriority
4328 
4329   -5               // 11 CriticalPriority
4330 };
4331 
4332 static int prio_init() {
4333   if (ThreadPriorityPolicy == 1) {
4334     if (geteuid() != 0) {
<span class="line-modified">4335       if (!FLAG_IS_DEFAULT(ThreadPriorityPolicy) &amp;&amp; !FLAG_IS_JIMAGE_RESOURCE(ThreadPriorityPolicy)) {</span>
4336         warning(&quot;-XX:ThreadPriorityPolicy=1 may require system level permission, &quot; \
4337                 &quot;e.g., being the root user. If the necessary permission is not &quot; \
4338                 &quot;possessed, changes to priority will be silently ignored.&quot;);
4339       }
4340     }
4341   }
4342   if (UseCriticalJavaThreadPriority) {
4343     os::java_to_os_priority[MaxPriority] = os::java_to_os_priority[CriticalPriority];
4344   }
4345   return 0;
4346 }
4347 
4348 OSReturn os::set_native_priority(Thread* thread, int newpri) {
4349   if (!UseThreadPriorities || ThreadPriorityPolicy == 0) return OS_OK;
4350 
4351   int ret = setpriority(PRIO_PROCESS, thread-&gt;osthread()-&gt;thread_id(), newpri);
4352   return (ret == 0) ? OS_OK : OS_ERR;
4353 }
4354 
4355 OSReturn os::get_native_priority(const Thread* const thread,
</pre>
<hr />
<pre>
5122   // Java can be invoked as
5123   // 1. Without numactl and heap will be allocated/configured on all nodes as
5124   //    per the system policy.
5125   // 2. With numactl --interleave:
5126   //      Use numa_get_interleave_mask(v2) API to get nodes bitmask. The same
5127   //      API for membind case bitmask is reset.
5128   //      Interleave is only hint and Kernel can fallback to other nodes if
5129   //      no memory is available on the target nodes.
5130   // 3. With numactl --membind:
5131   //      Use numa_get_membind(v2) API to get nodes bitmask. The same API for
5132   //      interleave case returns bitmask of all nodes.
5133   // numa_all_nodes_ptr holds bitmask of all nodes.
5134   // numa_get_interleave_mask(v2) and numa_get_membind(v2) APIs returns correct
5135   // bitmask when externally configured to run on all or fewer nodes.
5136 
5137   if (!Linux::libnuma_init()) {
5138     UseNUMA = false;
5139   } else {
5140     if ((Linux::numa_max_node() &lt; 1) || Linux::is_bound_to_single_node()) {
5141       // If there&#39;s only one node (they start from 0) or if the process
<span class="line-modified">5142       // is bound explicitly to a single node using membind, disable NUMA unless</span>
<span class="line-modified">5143       // user explicilty forces NUMA optimizations on single-node/UMA systems</span>
<span class="line-added">5144       UseNUMA = ForceNUMA;</span>
5145     } else {
5146 
5147       LogTarget(Info,os) log;
5148       LogStream ls(log);
5149 
5150       Linux::set_configured_numa_policy(Linux::identify_numa_policy());
5151 
5152       struct bitmask* bmp = Linux::_numa_membind_bitmask;
5153       const char* numa_mode = &quot;membind&quot;;
5154 
5155       if (Linux::is_running_in_interleave_mode()) {
5156         bmp = Linux::_numa_interleave_bitmask;
5157         numa_mode = &quot;interleave&quot;;
5158       }
5159 
5160       ls.print(&quot;UseNUMA is enabled and invoked in &#39;%s&#39; mode.&quot;
5161                &quot; Heap will be configured using NUMA memory nodes:&quot;, numa_mode);
5162 
5163       for (int node = 0; node &lt;= Linux::numa_max_node(); node++) {
5164         if (Linux::_numa_bitmask_isbitset(bmp, node)) {
5165           ls.print(&quot; %d&quot;, node);
5166         }
5167       }
5168     }
5169   }
5170 
5171   if (UseParallelGC &amp;&amp; UseNUMA &amp;&amp; UseLargePages &amp;&amp; !can_commit_large_page_memory()) {
5172     // With SHM and HugeTLBFS large pages we cannot uncommit a page, so there&#39;s no way
5173     // we can make the adaptive lgrp chunk resizing work. If the user specified both
5174     // UseNUMA and UseLargePages (or UseSHM/UseHugeTLBFS) on the command line - warn
5175     // and disable adaptive resizing.
5176     if (UseAdaptiveSizePolicy || UseAdaptiveNUMAChunkSizing) {
5177       warning(&quot;UseNUMA is not fully compatible with SHM/HugeTLBFS large pages, &quot;
5178               &quot;disabling adaptive resizing (-XX:-UseAdaptiveSizePolicy -XX:-UseAdaptiveNUMAChunkSizing)&quot;);
5179       UseAdaptiveSizePolicy = false;
5180       UseAdaptiveNUMAChunkSizing = false;
5181     }
5182   }




5183 }
5184 
5185 // this is called _after_ the global arguments have been parsed
5186 jint os::init_2(void) {
5187 
5188   // This could be set after os::Posix::init() but all platforms
5189   // have to set it the same so we have to mirror Solaris.
5190   DEBUG_ONLY(os::set_mutex_init_done();)
5191 
5192   os::Posix::init_2();
5193 
5194   Linux::fast_thread_clock_init();
5195 
5196   // initialize suspend/resume support - must do this before signal_sets_init()
5197   if (SR_initialize() != 0) {
5198     perror(&quot;SR_initialize failed&quot;);
5199     return JNI_ERR;
5200   }
5201 
5202   Linux::signal_sets_init();
</pre>
</td>
</tr>
</table>
<center><a href="gc/z/zPhysicalMemoryBacking_linux.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../solaris/dtrace/jhelper.d.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
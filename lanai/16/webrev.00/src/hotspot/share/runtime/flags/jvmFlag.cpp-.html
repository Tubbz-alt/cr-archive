<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/runtime/flags/jvmFlag.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jfr/jfrEvents.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;runtime/arguments.hpp&quot;
  29 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  30 #include &quot;runtime/flags/jvmFlagConstraintList.hpp&quot;
  31 #include &quot;runtime/flags/jvmFlagRangeList.hpp&quot;
  32 #include &quot;runtime/globals_extension.hpp&quot;
  33 #include &quot;utilities/defaultStream.hpp&quot;
  34 #include &quot;utilities/stringUtils.hpp&quot;
  35 
  36 #define DEFAULT_RANGE_STR_CHUNK_SIZE 64
  37 static char* create_range_str(const char *fmt, ...) {
  38   static size_t string_length = DEFAULT_RANGE_STR_CHUNK_SIZE;
  39   static char* range_string = NEW_C_HEAP_ARRAY(char, string_length, mtLogging);
  40 
  41   int size_needed = 0;
  42   do {
  43     va_list args;
  44     va_start(args, fmt);
  45     size_needed = jio_vsnprintf(range_string, string_length, fmt, args);
  46     va_end(args);
  47 
  48     if (size_needed &lt; 0) {
  49       string_length += DEFAULT_RANGE_STR_CHUNK_SIZE;
  50       range_string = REALLOC_C_HEAP_ARRAY(char, range_string, string_length, mtLogging);
  51       guarantee(range_string != NULL, &quot;create_range_str string should not be NULL&quot;);
  52     }
  53   } while (size_needed &lt; 0);
  54 
  55   return range_string;
  56 }
  57 
  58 const char* JVMFlag::get_int_default_range_str() {
  59   return create_range_str(&quot;[ &quot; INT32_FORMAT_W(-25) &quot; ... &quot; INT32_FORMAT_W(25) &quot; ]&quot;, INT_MIN, INT_MAX);
  60 }
  61 
  62 const char* JVMFlag::get_uint_default_range_str() {
  63   return create_range_str(&quot;[ &quot; UINT32_FORMAT_W(-25) &quot; ... &quot; UINT32_FORMAT_W(25) &quot; ]&quot;, 0, UINT_MAX);
  64 }
  65 
  66 const char* JVMFlag::get_intx_default_range_str() {
  67   return create_range_str(&quot;[ &quot; INTX_FORMAT_W(-25) &quot; ... &quot; INTX_FORMAT_W(25) &quot; ]&quot;, min_intx, max_intx);
  68 }
  69 
  70 const char* JVMFlag::get_uintx_default_range_str() {
  71   return create_range_str(&quot;[ &quot; UINTX_FORMAT_W(-25) &quot; ... &quot; UINTX_FORMAT_W(25) &quot; ]&quot;, 0, max_uintx);
  72 }
  73 
  74 const char* JVMFlag::get_uint64_t_default_range_str() {
  75   return create_range_str(&quot;[ &quot; UINT64_FORMAT_W(-25) &quot; ... &quot; UINT64_FORMAT_W(25) &quot; ]&quot;, 0, uint64_t(max_juint));
  76 }
  77 
  78 const char* JVMFlag::get_size_t_default_range_str() {
  79   return create_range_str(&quot;[ &quot; SIZE_FORMAT_W(-25) &quot; ... &quot; SIZE_FORMAT_W(25) &quot; ]&quot;, 0, SIZE_MAX);
  80 }
  81 
  82 const char* JVMFlag::get_double_default_range_str() {
  83   return create_range_str(&quot;[ %-25.3f ... %25.3f ]&quot;, DBL_MIN, DBL_MAX);
  84 }
  85 
  86 static bool is_product_build() {
  87 #ifdef PRODUCT
  88   return true;
  89 #else
  90   return false;
  91 #endif
  92 }
  93 
  94 bool JVMFlag::is_bool() const {
  95   return strcmp(_type, &quot;bool&quot;) == 0;
  96 }
  97 
  98 bool JVMFlag::is_int() const {
  99   return strcmp(_type, &quot;int&quot;)  == 0;
 100 }
 101 
 102 bool JVMFlag::is_uint() const {
 103   return strcmp(_type, &quot;uint&quot;)  == 0;
 104 }
 105 
 106 bool JVMFlag::is_intx() const {
 107   return strcmp(_type, &quot;intx&quot;)  == 0;
 108 }
 109 
 110 bool JVMFlag::is_uintx() const {
 111   return strcmp(_type, &quot;uintx&quot;) == 0;
 112 }
 113 
 114 bool JVMFlag::is_uint64_t() const {
 115   return strcmp(_type, &quot;uint64_t&quot;) == 0;
 116 }
 117 
 118 bool JVMFlag::is_size_t() const {
 119   return strcmp(_type, &quot;size_t&quot;) == 0;
 120 }
 121 
 122 bool JVMFlag::is_double() const {
 123   return strcmp(_type, &quot;double&quot;) == 0;
 124 }
 125 
 126 bool JVMFlag::is_ccstr() const {
 127   return strcmp(_type, &quot;ccstr&quot;) == 0 || strcmp(_type, &quot;ccstrlist&quot;) == 0;
 128 }
 129 
 130 bool JVMFlag::ccstr_accumulates() const {
 131   return strcmp(_type, &quot;ccstrlist&quot;) == 0;
 132 }
 133 
 134 JVMFlag::Flags JVMFlag::get_origin() {
 135   return Flags(_flags &amp; VALUE_ORIGIN_MASK);
 136 }
 137 
 138 void JVMFlag::set_origin(Flags origin) {
 139   assert((origin &amp; VALUE_ORIGIN_MASK) == origin, &quot;sanity&quot;);
 140   Flags new_origin = Flags((origin == COMMAND_LINE) ? Flags(origin | ORIG_COMMAND_LINE) : origin);
 141   _flags = Flags((_flags &amp; ~VALUE_ORIGIN_MASK) | new_origin);
 142 }
 143 
 144 bool JVMFlag::is_default() {
 145   return (get_origin() == DEFAULT);
 146 }
 147 
 148 bool JVMFlag::is_ergonomic() {
 149   return (get_origin() == ERGONOMIC);
 150 }
 151 
 152 bool JVMFlag::is_command_line() {
 153   return (_flags &amp; ORIG_COMMAND_LINE) != 0;
 154 }
 155 
 156 void JVMFlag::set_command_line() {
 157   _flags = Flags(_flags | ORIG_COMMAND_LINE);
 158 }
 159 
 160 bool JVMFlag::is_product() const {
 161   return (_flags &amp; KIND_PRODUCT) != 0;
 162 }
 163 
 164 bool JVMFlag::is_manageable() const {
 165   return (_flags &amp; KIND_MANAGEABLE) != 0;
 166 }
 167 
 168 bool JVMFlag::is_diagnostic() const {
 169   return (_flags &amp; KIND_DIAGNOSTIC) != 0;
 170 }
 171 
 172 bool JVMFlag::is_experimental() const {
 173   return (_flags &amp; KIND_EXPERIMENTAL) != 0;
 174 }
 175 
 176 bool JVMFlag::is_notproduct() const {
 177   return (_flags &amp; KIND_NOT_PRODUCT) != 0;
 178 }
 179 
 180 bool JVMFlag::is_develop() const {
 181   return (_flags &amp; KIND_DEVELOP) != 0;
 182 }
 183 
 184 bool JVMFlag::is_read_write() const {
 185   return (_flags &amp; KIND_READ_WRITE) != 0;
 186 }
 187 
 188 /**
 189  * Returns if this flag is a constant in the binary.  Right now this is
 190  * true for notproduct and develop flags in product builds.
 191  */
 192 bool JVMFlag::is_constant_in_binary() const {
 193 #ifdef PRODUCT
 194   return is_notproduct() || is_develop();
 195 #else
 196   return false;
 197 #endif
 198 }
 199 
 200 bool JVMFlag::is_unlocker() const {
 201   return strcmp(_name, &quot;UnlockDiagnosticVMOptions&quot;) == 0 ||
 202          strcmp(_name, &quot;UnlockExperimentalVMOptions&quot;) == 0;
 203 }
 204 
 205 bool JVMFlag::is_unlocked() const {
 206   if (is_diagnostic()) {
 207     return UnlockDiagnosticVMOptions;
 208   }
 209   if (is_experimental()) {
 210     return UnlockExperimentalVMOptions;
 211   }
 212   return true;
 213 }
 214 
 215 void JVMFlag::clear_diagnostic() {
 216   assert(is_diagnostic(), &quot;sanity&quot;);
 217   _flags = Flags(_flags &amp; ~KIND_DIAGNOSTIC);
 218   assert(!is_diagnostic(), &quot;sanity&quot;);
 219 }
 220 
 221 void JVMFlag::clear_experimental() {
 222   assert(is_experimental(), &quot;sanity&quot;);
 223  _flags = Flags(_flags &amp; ~KIND_EXPERIMENTAL);
 224   assert(!is_experimental(), &quot;sanity&quot;);
 225 }
 226 
 227 void JVMFlag::set_product() {
 228   assert(!is_product(), &quot;sanity&quot;);
 229  _flags = Flags(_flags | KIND_PRODUCT);
 230   assert(is_product(), &quot;sanity&quot;);
 231 }
 232 
 233 // Get custom message for this locked flag, or NULL if
 234 // none is available. Returns message type produced.
 235 JVMFlag::MsgType JVMFlag::get_locked_message(char* buf, int buflen) const {
 236   buf[0] = &#39;\0&#39;;
 237   if (is_diagnostic() &amp;&amp; !is_unlocked()) {
 238     jio_snprintf(buf, buflen,
 239                  &quot;Error: VM option &#39;%s&#39; is diagnostic and must be enabled via -XX:+UnlockDiagnosticVMOptions.\n&quot;
 240                  &quot;Error: The unlock option must precede &#39;%s&#39;.\n&quot;,
 241                  _name, _name);
 242     return JVMFlag::DIAGNOSTIC_FLAG_BUT_LOCKED;
 243   }
 244   if (is_experimental() &amp;&amp; !is_unlocked()) {
 245     jio_snprintf(buf, buflen,
 246                  &quot;Error: VM option &#39;%s&#39; is experimental and must be enabled via -XX:+UnlockExperimentalVMOptions.\n&quot;
 247                  &quot;Error: The unlock option must precede &#39;%s&#39;.\n&quot;,
 248                  _name, _name);
 249     return JVMFlag::EXPERIMENTAL_FLAG_BUT_LOCKED;
 250   }
 251   if (is_develop() &amp;&amp; is_product_build()) {
 252     jio_snprintf(buf, buflen, &quot;Error: VM option &#39;%s&#39; is develop and is available only in debug version of VM.\n&quot;,
 253                  _name);
 254     return JVMFlag::DEVELOPER_FLAG_BUT_PRODUCT_BUILD;
 255   }
 256   if (is_notproduct() &amp;&amp; is_product_build()) {
 257     jio_snprintf(buf, buflen, &quot;Error: VM option &#39;%s&#39; is notproduct and is available only in debug version of VM.\n&quot;,
 258                  _name);
 259     return JVMFlag::NOTPRODUCT_FLAG_BUT_PRODUCT_BUILD;
 260   }
 261   return JVMFlag::NONE;
 262 }
 263 
 264 bool JVMFlag::is_writeable() const {
 265   return is_manageable() || (is_product() &amp;&amp; is_read_write());
 266 }
 267 
 268 // All flags except &quot;manageable&quot; are assumed to be internal flags.
 269 // Long term, we need to define a mechanism to specify which flags
 270 // are external/stable and change this function accordingly.
 271 bool JVMFlag::is_external() const {
 272   return is_manageable();
 273 }
 274 
 275 // Helper function for JVMFlag::print_on().
 276 // Fills current line up to requested position.
 277 // Should the current position already be past the requested position,
 278 // one separator blank is enforced.
 279 void fill_to_pos(outputStream* st, unsigned int req_pos) {
 280   if ((unsigned int)st-&gt;position() &lt; req_pos) {
 281     st-&gt;fill_to(req_pos);  // need to fill with blanks to reach req_pos
 282   } else {
 283     st-&gt;print(&quot; &quot;);        // enforce blank separation. Previous field too long.
 284   }
 285 }
 286 
 287 void JVMFlag::print_on(outputStream* st, bool withComments, bool printRanges) {
 288   // Don&#39;t print notproduct and develop flags in a product build.
 289   if (is_constant_in_binary()) {
 290     return;
 291   }
 292 
 293   if (!printRanges) {
 294     // The command line options -XX:+PrintFlags* cause this function to be called
 295     // for each existing flag to print information pertinent to this flag. The data
 296     // is displayed in columnar form, with the following layout:
 297     //  col1 - data type, right-justified
 298     //  col2 - name,      left-justified
 299     //  col3 - &#39; =&#39;       double-char, leading space to align with possible &#39;+=&#39;
 300     //  col4 - value      left-justified
 301     //  col5 - kind       right-justified
 302     //  col6 - origin     left-justified
 303     //  col7 - comments   left-justified
 304     //
 305     //  The column widths are fixed. They are defined such that, for most cases,
 306     //  an eye-pleasing tabular output is created.
 307     //
 308     //  Sample output:
 309     //       bool ThreadPriorityVerbose                    = false                                     {product} {default}
 310     //      uintx ThresholdTolerance                       = 10                                        {product} {default}
 311     //     size_t TLABSize                                 = 0                                         {product} {default}
 312     //      uintx SurvivorRatio                            = 8                                         {product} {default}
 313     //     double InitialRAMPercentage                     = 1.562500                                  {product} {default}
 314     //      ccstr CompileCommandFile                       = MyFile.cmd                                {product} {command line}
 315     //  ccstrlist CompileOnly                              = Method1
 316     //            CompileOnly                             += Method2                                   {product} {command line}
 317     //  |         |                                       |  |                              |                    |               |
 318     //  |         |                                       |  |                              |                    |               +-- col7
 319     //  |         |                                       |  |                              |                    +-- col6
 320     //  |         |                                       |  |                              +-- col5
 321     //  |         |                                       |  +-- col4
 322     //  |         |                                       +-- col3
 323     //  |         +-- col2
 324     //  +-- col1
 325 
 326     const unsigned int col_spacing = 1;
 327     const unsigned int col1_pos    = 0;
 328     const unsigned int col1_width  = 9;
 329     const unsigned int col2_pos    = col1_pos + col1_width + col_spacing;
 330     const unsigned int col2_width  = 39;
 331     const unsigned int col3_pos    = col2_pos + col2_width + col_spacing;
 332     const unsigned int col3_width  = 2;
 333     const unsigned int col4_pos    = col3_pos + col3_width + col_spacing;
 334     const unsigned int col4_width  = 30;
 335     const unsigned int col5_pos    = col4_pos + col4_width + col_spacing;
 336     const unsigned int col5_width  = 20;
 337     const unsigned int col6_pos    = col5_pos + col5_width + col_spacing;
 338     const unsigned int col6_width  = 15;
 339     const unsigned int col7_pos    = col6_pos + col6_width + col_spacing;
 340     const unsigned int col7_width  = 1;
 341 
 342     st-&gt;fill_to(col1_pos);
 343     st-&gt;print(&quot;%*s&quot;, col1_width, _type);  // right-justified, therefore width is required.
 344 
 345     fill_to_pos(st, col2_pos);
 346     st-&gt;print(&quot;%s&quot;, _name);
 347 
 348     fill_to_pos(st, col3_pos);
 349     st-&gt;print(&quot; =&quot;);  // use &quot; =&quot; for proper alignment with multiline ccstr output.
 350 
 351     fill_to_pos(st, col4_pos);
 352     if (is_bool()) {
 353       st-&gt;print(&quot;%s&quot;, get_bool() ? &quot;true&quot; : &quot;false&quot;);
 354     } else if (is_int()) {
 355       st-&gt;print(&quot;%d&quot;, get_int());
 356     } else if (is_uint()) {
 357       st-&gt;print(&quot;%u&quot;, get_uint());
 358     } else if (is_intx()) {
 359       st-&gt;print(INTX_FORMAT, get_intx());
 360     } else if (is_uintx()) {
 361       st-&gt;print(UINTX_FORMAT, get_uintx());
 362     } else if (is_uint64_t()) {
 363       st-&gt;print(UINT64_FORMAT, get_uint64_t());
 364     } else if (is_size_t()) {
 365       st-&gt;print(SIZE_FORMAT, get_size_t());
 366     } else if (is_double()) {
 367       st-&gt;print(&quot;%f&quot;, get_double());
 368     } else if (is_ccstr()) {
 369       // Honor &lt;newline&gt; characters in ccstr: print multiple lines.
 370       const char* cp = get_ccstr();
 371       if (cp != NULL) {
 372         const char* eol;
 373         while ((eol = strchr(cp, &#39;\n&#39;)) != NULL) {
 374           size_t llen = pointer_delta(eol, cp, sizeof(char));
 375           st-&gt;print(&quot;%.*s&quot;, (int)llen, cp);
 376           st-&gt;cr();
 377           cp = eol+1;
 378           fill_to_pos(st, col2_pos);
 379           st-&gt;print(&quot;%s&quot;, _name);
 380           fill_to_pos(st, col3_pos);
 381           st-&gt;print(&quot;+=&quot;);
 382           fill_to_pos(st, col4_pos);
 383         }
 384         st-&gt;print(&quot;%s&quot;, cp);
 385       }
 386     } else {
 387       st-&gt;print(&quot;unhandled  type %s&quot;, _type);
 388       st-&gt;cr();
 389       return;
 390     }
 391 
 392     fill_to_pos(st, col5_pos);
 393     print_kind(st, col5_width);
 394 
 395     fill_to_pos(st, col6_pos);
 396     print_origin(st, col6_width);
 397 
 398 #ifndef PRODUCT
 399     if (withComments) {
 400       fill_to_pos(st, col7_pos);
 401       st-&gt;print(&quot;%s&quot;, _doc);
 402     }
 403 #endif
 404     st-&gt;cr();
 405   } else if (!is_bool() &amp;&amp; !is_ccstr()) {
 406     // The command line options -XX:+PrintFlags* cause this function to be called
 407     // for each existing flag to print information pertinent to this flag. The data
 408     // is displayed in columnar form, with the following layout:
 409     //  col1 - data type, right-justified
 410     //  col2 - name,      left-justified
 411     //  col4 - range      [ min ... max]
 412     //  col5 - kind       right-justified
 413     //  col6 - origin     left-justified
 414     //  col7 - comments   left-justified
 415     //
 416     //  The column widths are fixed. They are defined such that, for most cases,
 417     //  an eye-pleasing tabular output is created.
 418     //
 419     //  Sample output:
 420     //       intx MinPassesBeforeFlush                               [ 0                         ...       9223372036854775807 ]                         {diagnostic} {default}
 421     //      uintx MinRAMFraction                                     [ 1                         ...      18446744073709551615 ]                            {product} {default}
 422     //     double MinRAMPercentage                                   [ 0.000                     ...                   100.000 ]                            {product} {default}
 423     //      uintx MinSurvivorRatio                                   [ 3                         ...      18446744073709551615 ]                            {product} {default}
 424     //     size_t MinTLABSize                                        [ 1                         ...       9223372036854775807 ]                            {product} {default}
 425     //       intx MonitorBound                                       [ 0                         ...                2147483647 ]                            {product} {default}
 426     //  |         |                                                  |                                                           |                                    |               |
 427     //  |         |                                                  |                                                           |                                    |               +-- col7
 428     //  |         |                                                  |                                                           |                                    +-- col6
 429     //  |         |                                                  |                                                           +-- col5
 430     //  |         |                                                  +-- col4
 431     //  |         +-- col2
 432     //  +-- col1
 433 
 434     const unsigned int col_spacing = 1;
 435     const unsigned int col1_pos    = 0;
 436     const unsigned int col1_width  = 9;
 437     const unsigned int col2_pos    = col1_pos + col1_width + col_spacing;
 438     const unsigned int col2_width  = 49;
 439     const unsigned int col3_pos    = col2_pos + col2_width + col_spacing;
 440     const unsigned int col3_width  = 0;
 441     const unsigned int col4_pos    = col3_pos + col3_width + col_spacing;
 442     const unsigned int col4_width  = 60;
 443     const unsigned int col5_pos    = col4_pos + col4_width + col_spacing;
 444     const unsigned int col5_width  = 35;
 445     const unsigned int col6_pos    = col5_pos + col5_width + col_spacing;
 446     const unsigned int col6_width  = 15;
 447     const unsigned int col7_pos    = col6_pos + col6_width + col_spacing;
 448     const unsigned int col7_width  = 1;
 449 
 450     st-&gt;fill_to(col1_pos);
 451     st-&gt;print(&quot;%*s&quot;, col1_width, _type);  // right-justified, therefore width is required.
 452 
 453     fill_to_pos(st, col2_pos);
 454     st-&gt;print(&quot;%s&quot;, _name);
 455 
 456     fill_to_pos(st, col4_pos);
 457     RangeStrFunc func = NULL;
 458     if (is_int()) {
 459       func = JVMFlag::get_int_default_range_str;
 460     } else if (is_uint()) {
 461       func = JVMFlag::get_uint_default_range_str;
 462     } else if (is_intx()) {
 463       func = JVMFlag::get_intx_default_range_str;
 464     } else if (is_uintx()) {
 465       func = JVMFlag::get_uintx_default_range_str;
 466     } else if (is_uint64_t()) {
 467       func = JVMFlag::get_uint64_t_default_range_str;
 468     } else if (is_size_t()) {
 469       func = JVMFlag::get_size_t_default_range_str;
 470     } else if (is_double()) {
 471       func = JVMFlag::get_double_default_range_str;
 472     } else {
 473       st-&gt;print(&quot;unhandled  type %s&quot;, _type);
 474       st-&gt;cr();
 475       return;
 476     }
 477     JVMFlagRangeList::print(st, this, func);
 478 
 479     fill_to_pos(st, col5_pos);
 480     print_kind(st, col5_width);
 481 
 482     fill_to_pos(st, col6_pos);
 483     print_origin(st, col6_width);
 484 
 485 #ifndef PRODUCT
 486     if (withComments) {
 487       fill_to_pos(st, col7_pos);
 488       st-&gt;print(&quot;%s&quot;, _doc);
 489     }
 490 #endif
 491     st-&gt;cr();
 492   }
 493 }
 494 
 495 void JVMFlag::print_kind(outputStream* st, unsigned int width) {
 496   struct Data {
 497     int flag;
 498     const char* name;
 499   };
 500 
 501   Data data[] = {
 502     { KIND_JVMCI, &quot;JVMCI&quot; },
 503     { KIND_C1, &quot;C1&quot; },
 504     { KIND_C2, &quot;C2&quot; },
 505     { KIND_ARCH, &quot;ARCH&quot; },
 506     { KIND_PLATFORM_DEPENDENT, &quot;pd&quot; },
 507     { KIND_PRODUCT, &quot;product&quot; },
 508     { KIND_MANAGEABLE, &quot;manageable&quot; },
 509     { KIND_DIAGNOSTIC, &quot;diagnostic&quot; },
 510     { KIND_EXPERIMENTAL, &quot;experimental&quot; },
 511     { KIND_NOT_PRODUCT, &quot;notproduct&quot; },
 512     { KIND_DEVELOP, &quot;develop&quot; },
 513     { KIND_LP64_PRODUCT, &quot;lp64_product&quot; },
 514     { KIND_READ_WRITE, &quot;rw&quot; },
 515     { -1, &quot;&quot; }
 516   };
 517 
 518   if ((_flags &amp; KIND_MASK) != 0) {
 519     bool is_first = true;
 520     const size_t buffer_size = 64;
 521     size_t buffer_used = 0;
 522     char kind[buffer_size];
 523 
 524     jio_snprintf(kind, buffer_size, &quot;{&quot;);
 525     buffer_used++;
 526     for (int i = 0; data[i].flag != -1; i++) {
 527       Data d = data[i];
 528       if ((_flags &amp; d.flag) != 0) {
 529         if (is_first) {
 530           is_first = false;
 531         } else {
 532           assert(buffer_used + 1 &lt; buffer_size, &quot;Too small buffer&quot;);
 533           jio_snprintf(kind + buffer_used, buffer_size - buffer_used, &quot; &quot;);
 534           buffer_used++;
 535         }
 536         size_t length = strlen(d.name);
 537         assert(buffer_used + length &lt; buffer_size, &quot;Too small buffer&quot;);
 538         jio_snprintf(kind + buffer_used, buffer_size - buffer_used, &quot;%s&quot;, d.name);
 539         buffer_used += length;
 540       }
 541     }
 542     assert(buffer_used + 2 &lt;= buffer_size, &quot;Too small buffer&quot;);
 543     jio_snprintf(kind + buffer_used, buffer_size - buffer_used, &quot;}&quot;);
 544     st-&gt;print(&quot;%*s&quot;, width, kind);
 545   }
 546 }
 547 
 548 void JVMFlag::print_origin(outputStream* st, unsigned int width) {
 549   int origin = _flags &amp; VALUE_ORIGIN_MASK;
 550   st-&gt;print(&quot;{&quot;);
 551   switch(origin) {
 552     case DEFAULT:
 553       st-&gt;print(&quot;default&quot;); break;
 554     case COMMAND_LINE:
 555       st-&gt;print(&quot;command line&quot;); break;
 556     case ENVIRON_VAR:
 557       st-&gt;print(&quot;environment&quot;); break;
 558     case CONFIG_FILE:
 559       st-&gt;print(&quot;config file&quot;); break;
 560     case MANAGEMENT:
 561       st-&gt;print(&quot;management&quot;); break;
 562     case ERGONOMIC:
 563       if (_flags &amp; ORIG_COMMAND_LINE) {
 564         st-&gt;print(&quot;command line, &quot;);
 565       }
 566       st-&gt;print(&quot;ergonomic&quot;); break;
 567     case ATTACH_ON_DEMAND:
 568       st-&gt;print(&quot;attach&quot;); break;
 569     case INTERNAL:
 570       st-&gt;print(&quot;internal&quot;); break;
 571     case JIMAGE_RESOURCE:
 572       st-&gt;print(&quot;jimage&quot;); break;
 573   }
 574   st-&gt;print(&quot;}&quot;);
 575 }
 576 
 577 void JVMFlag::print_as_flag(outputStream* st) {
 578   if (is_bool()) {
 579     st-&gt;print(&quot;-XX:%s%s&quot;, get_bool() ? &quot;+&quot; : &quot;-&quot;, _name);
 580   } else if (is_int()) {
 581     st-&gt;print(&quot;-XX:%s=%d&quot;, _name, get_int());
 582   } else if (is_uint()) {
 583     st-&gt;print(&quot;-XX:%s=%u&quot;, _name, get_uint());
 584   } else if (is_intx()) {
 585     st-&gt;print(&quot;-XX:%s=&quot; INTX_FORMAT, _name, get_intx());
 586   } else if (is_uintx()) {
 587     st-&gt;print(&quot;-XX:%s=&quot; UINTX_FORMAT, _name, get_uintx());
 588   } else if (is_uint64_t()) {
 589     st-&gt;print(&quot;-XX:%s=&quot; UINT64_FORMAT, _name, get_uint64_t());
 590   } else if (is_size_t()) {
 591     st-&gt;print(&quot;-XX:%s=&quot; SIZE_FORMAT, _name, get_size_t());
 592   } else if (is_double()) {
 593     st-&gt;print(&quot;-XX:%s=%f&quot;, _name, get_double());
 594   } else if (is_ccstr()) {
 595     st-&gt;print(&quot;-XX:%s=&quot;, _name);
 596     const char* cp = get_ccstr();
 597     if (cp != NULL) {
 598       // Need to turn embedded &#39;\n&#39;s back into separate arguments
 599       // Not so efficient to print one character at a time,
 600       // but the choice is to do the transformation to a buffer
 601       // and print that.  And this need not be efficient.
 602       for (; *cp != &#39;\0&#39;; cp += 1) {
 603         switch (*cp) {
 604           default:
 605             st-&gt;print(&quot;%c&quot;, *cp);
 606             break;
 607           case &#39;\n&#39;:
 608             st-&gt;print(&quot; -XX:%s=&quot;, _name);
 609             break;
 610         }
 611       }
 612     }
 613   } else {
 614     ShouldNotReachHere();
 615   }
 616 }
 617 
 618 const char* JVMFlag::flag_error_str(JVMFlag::Error error) {
 619   switch (error) {
 620     case JVMFlag::MISSING_NAME: return &quot;MISSING_NAME&quot;;
 621     case JVMFlag::MISSING_VALUE: return &quot;MISSING_VALUE&quot;;
 622     case JVMFlag::NON_WRITABLE: return &quot;NON_WRITABLE&quot;;
 623     case JVMFlag::OUT_OF_BOUNDS: return &quot;OUT_OF_BOUNDS&quot;;
 624     case JVMFlag::VIOLATES_CONSTRAINT: return &quot;VIOLATES_CONSTRAINT&quot;;
 625     case JVMFlag::INVALID_FLAG: return &quot;INVALID_FLAG&quot;;
 626     case JVMFlag::ERR_OTHER: return &quot;ERR_OTHER&quot;;
 627     case JVMFlag::SUCCESS: return &quot;SUCCESS&quot;;
 628     default: ShouldNotReachHere(); return &quot;NULL&quot;;
 629   }
 630 }
 631 
 632 // 4991491 do not &quot;optimize out&quot; the was_set false values: omitting them
 633 // tickles a Microsoft compiler bug causing flagTable to be malformed
 634 
 635 #define RUNTIME_PRODUCT_FLAG_STRUCT(     type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_PRODUCT) },
 636 #define RUNTIME_PD_PRODUCT_FLAG_STRUCT(  type, name,        doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_PRODUCT | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 637 #define RUNTIME_DIAGNOSTIC_FLAG_STRUCT(  type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_DIAGNOSTIC) },
 638 #define RUNTIME_PD_DIAGNOSTIC_FLAG_STRUCT(type, name,       doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_DIAGNOSTIC | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 639 #define RUNTIME_EXPERIMENTAL_FLAG_STRUCT(type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_EXPERIMENTAL) },
 640 #define RUNTIME_MANAGEABLE_FLAG_STRUCT(  type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_MANAGEABLE) },
 641 #define RUNTIME_PRODUCT_RW_FLAG_STRUCT(  type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_PRODUCT | JVMFlag::KIND_READ_WRITE) },
 642 #define RUNTIME_DEVELOP_FLAG_STRUCT(     type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_DEVELOP) },
 643 #define RUNTIME_PD_DEVELOP_FLAG_STRUCT(  type, name,        doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_DEVELOP | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 644 #define RUNTIME_NOTPRODUCT_FLAG_STRUCT(  type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_NOT_PRODUCT) },
 645 
 646 #define JVMCI_PRODUCT_FLAG_STRUCT(       type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_PRODUCT) },
 647 #define JVMCI_PD_PRODUCT_FLAG_STRUCT(    type, name,        doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_PRODUCT | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 648 #define JVMCI_DIAGNOSTIC_FLAG_STRUCT(    type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_DIAGNOSTIC) },
 649 #define JVMCI_PD_DIAGNOSTIC_FLAG_STRUCT( type, name,        doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_DIAGNOSTIC | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 650 #define JVMCI_EXPERIMENTAL_FLAG_STRUCT(  type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_EXPERIMENTAL) },
 651 #define JVMCI_DEVELOP_FLAG_STRUCT(       type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_DEVELOP) },
 652 #define JVMCI_PD_DEVELOP_FLAG_STRUCT(    type, name,        doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_DEVELOP | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 653 #define JVMCI_NOTPRODUCT_FLAG_STRUCT(    type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_JVMCI | JVMFlag::KIND_NOT_PRODUCT) },
 654 
 655 #ifdef _LP64
 656 #define RUNTIME_LP64_PRODUCT_FLAG_STRUCT(type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_LP64_PRODUCT) },
 657 #else
 658 #define RUNTIME_LP64_PRODUCT_FLAG_STRUCT(type, name, value, doc) /* flag is constant */
 659 #endif // _LP64
 660 
 661 #define C1_PRODUCT_FLAG_STRUCT(          type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C1 | JVMFlag::KIND_PRODUCT) },
 662 #define C1_PD_PRODUCT_FLAG_STRUCT(       type, name,        doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C1 | JVMFlag::KIND_PRODUCT | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 663 #define C1_DIAGNOSTIC_FLAG_STRUCT(       type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C1 | JVMFlag::KIND_DIAGNOSTIC) },
 664 #define C1_PD_DIAGNOSTIC_FLAG_STRUCT(    type, name,        doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C1 | JVMFlag::KIND_DIAGNOSTIC | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 665 #define C1_DEVELOP_FLAG_STRUCT(          type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C1 | JVMFlag::KIND_DEVELOP) },
 666 #define C1_PD_DEVELOP_FLAG_STRUCT(       type, name,        doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C1 | JVMFlag::KIND_DEVELOP | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 667 #define C1_NOTPRODUCT_FLAG_STRUCT(       type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C1 | JVMFlag::KIND_NOT_PRODUCT) },
 668 
 669 #define C2_PRODUCT_FLAG_STRUCT(          type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_PRODUCT) },
 670 #define C2_PD_PRODUCT_FLAG_STRUCT(       type, name,        doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_PRODUCT | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 671 #define C2_DIAGNOSTIC_FLAG_STRUCT(       type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_DIAGNOSTIC) },
 672 #define C2_PD_DIAGNOSTIC_FLAG_STRUCT(    type, name,        doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_DIAGNOSTIC | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 673 #define C2_EXPERIMENTAL_FLAG_STRUCT(     type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_EXPERIMENTAL) },
 674 #define C2_DEVELOP_FLAG_STRUCT(          type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_DEVELOP) },
 675 #define C2_PD_DEVELOP_FLAG_STRUCT(       type, name,        doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_DEVELOP | JVMFlag::KIND_PLATFORM_DEPENDENT) },
 676 #define C2_NOTPRODUCT_FLAG_STRUCT(       type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_C2 | JVMFlag::KIND_NOT_PRODUCT) },
 677 
 678 #define ARCH_PRODUCT_FLAG_STRUCT(        type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_ARCH | JVMFlag::KIND_PRODUCT) },
 679 #define ARCH_DIAGNOSTIC_FLAG_STRUCT(     type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_ARCH | JVMFlag::KIND_DIAGNOSTIC) },
 680 #define ARCH_EXPERIMENTAL_FLAG_STRUCT(   type, name, value, doc) { #type, XSTR(name), &amp;name,         NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_ARCH | JVMFlag::KIND_EXPERIMENTAL) },
 681 #define ARCH_DEVELOP_FLAG_STRUCT(        type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_ARCH | JVMFlag::KIND_DEVELOP) },
 682 #define ARCH_NOTPRODUCT_FLAG_STRUCT(     type, name, value, doc) { #type, XSTR(name), (void*) &amp;name, NOT_PRODUCT_ARG(doc) JVMFlag::Flags(JVMFlag::DEFAULT | JVMFlag::KIND_ARCH | JVMFlag::KIND_NOT_PRODUCT) },
 683 
 684 static JVMFlag flagTable[] = {
 685   VM_FLAGS(RUNTIME_DEVELOP_FLAG_STRUCT, \
 686            RUNTIME_PD_DEVELOP_FLAG_STRUCT, \
 687            RUNTIME_PRODUCT_FLAG_STRUCT, \
 688            RUNTIME_PD_PRODUCT_FLAG_STRUCT, \
 689            RUNTIME_DIAGNOSTIC_FLAG_STRUCT, \
 690            RUNTIME_PD_DIAGNOSTIC_FLAG_STRUCT, \
 691            RUNTIME_EXPERIMENTAL_FLAG_STRUCT, \
 692            RUNTIME_NOTPRODUCT_FLAG_STRUCT, \
 693            RUNTIME_MANAGEABLE_FLAG_STRUCT, \
 694            RUNTIME_PRODUCT_RW_FLAG_STRUCT, \
 695            RUNTIME_LP64_PRODUCT_FLAG_STRUCT, \
 696            IGNORE_RANGE, \
 697            IGNORE_CONSTRAINT)
 698 
 699   RUNTIME_OS_FLAGS(RUNTIME_DEVELOP_FLAG_STRUCT, \
 700                    RUNTIME_PD_DEVELOP_FLAG_STRUCT, \
 701                    RUNTIME_PRODUCT_FLAG_STRUCT, \
 702                    RUNTIME_PD_PRODUCT_FLAG_STRUCT, \
 703                    RUNTIME_DIAGNOSTIC_FLAG_STRUCT, \
 704                    RUNTIME_PD_DIAGNOSTIC_FLAG_STRUCT, \
 705                    RUNTIME_NOTPRODUCT_FLAG_STRUCT, \
 706                    IGNORE_RANGE, \
 707                    IGNORE_CONSTRAINT)
 708 #if INCLUDE_JVMCI
 709   JVMCI_FLAGS(JVMCI_DEVELOP_FLAG_STRUCT, \
 710               JVMCI_PD_DEVELOP_FLAG_STRUCT, \
 711               JVMCI_PRODUCT_FLAG_STRUCT, \
 712               JVMCI_PD_PRODUCT_FLAG_STRUCT, \
 713               JVMCI_DIAGNOSTIC_FLAG_STRUCT, \
 714               JVMCI_PD_DIAGNOSTIC_FLAG_STRUCT, \
 715               JVMCI_EXPERIMENTAL_FLAG_STRUCT, \
 716               JVMCI_NOTPRODUCT_FLAG_STRUCT, \
 717               IGNORE_RANGE, \
 718               IGNORE_CONSTRAINT)
 719 #endif // INCLUDE_JVMCI
 720 #ifdef COMPILER1
 721   C1_FLAGS(C1_DEVELOP_FLAG_STRUCT, \
 722            C1_PD_DEVELOP_FLAG_STRUCT, \
 723            C1_PRODUCT_FLAG_STRUCT, \
 724            C1_PD_PRODUCT_FLAG_STRUCT, \
 725            C1_DIAGNOSTIC_FLAG_STRUCT, \
 726            C1_PD_DIAGNOSTIC_FLAG_STRUCT, \
 727            C1_NOTPRODUCT_FLAG_STRUCT, \
 728            IGNORE_RANGE, \
 729            IGNORE_CONSTRAINT)
 730 #endif // COMPILER1
 731 #ifdef COMPILER2
 732   C2_FLAGS(C2_DEVELOP_FLAG_STRUCT, \
 733            C2_PD_DEVELOP_FLAG_STRUCT, \
 734            C2_PRODUCT_FLAG_STRUCT, \
 735            C2_PD_PRODUCT_FLAG_STRUCT, \
 736            C2_DIAGNOSTIC_FLAG_STRUCT, \
 737            C2_PD_DIAGNOSTIC_FLAG_STRUCT, \
 738            C2_EXPERIMENTAL_FLAG_STRUCT, \
 739            C2_NOTPRODUCT_FLAG_STRUCT, \
 740            IGNORE_RANGE, \
 741            IGNORE_CONSTRAINT)
 742 #endif // COMPILER2
 743   ARCH_FLAGS(ARCH_DEVELOP_FLAG_STRUCT, \
 744              ARCH_PRODUCT_FLAG_STRUCT, \
 745              ARCH_DIAGNOSTIC_FLAG_STRUCT, \
 746              ARCH_EXPERIMENTAL_FLAG_STRUCT, \
 747              ARCH_NOTPRODUCT_FLAG_STRUCT, \
 748              IGNORE_RANGE, \
 749              IGNORE_CONSTRAINT)
 750   {0, NULL, NULL}
 751 };
 752 
 753 JVMFlag* JVMFlag::flags = flagTable;
 754 size_t JVMFlag::numFlags = (sizeof(flagTable) / sizeof(JVMFlag));
 755 
 756 inline bool str_equal(const char* s, size_t s_len, const char* q, size_t q_len) {
 757   if (s_len != q_len) return false;
 758   return memcmp(s, q, q_len) == 0;
 759 }
 760 
 761 // Search the flag table for a named flag
 762 JVMFlag* JVMFlag::find_flag(const char* name, size_t length, bool allow_locked, bool return_flag) {
 763   for (JVMFlag* current = &amp;flagTable[0]; current-&gt;_name != NULL; current++) {
 764     if (str_equal(current-&gt;_name, current-&gt;get_name_length(), name, length)) {
 765       // Found a matching entry.
 766       // Don&#39;t report notproduct and develop flags in product builds.
 767       if (current-&gt;is_constant_in_binary()) {
 768         return (return_flag ? current : NULL);
 769       }
 770       // Report locked flags only if allowed.
 771       if (!(current-&gt;is_unlocked() || current-&gt;is_unlocker())) {
 772         if (!allow_locked) {
 773           // disable use of locked flags, e.g. diagnostic, experimental,
 774           // etc. until they are explicitly unlocked
 775           return NULL;
 776         }
 777       }
 778       return current;
 779     }
 780   }
 781   // JVMFlag name is not in the flag table
 782   return NULL;
 783 }
 784 
 785 // Get or compute the flag name length
 786 size_t JVMFlag::get_name_length() {
 787   if (_name_len == 0) {
 788     _name_len = strlen(_name);
 789   }
 790   return _name_len;
 791 }
 792 
 793 JVMFlag* JVMFlag::fuzzy_match(const char* name, size_t length, bool allow_locked) {
 794   float VMOptionsFuzzyMatchSimilarity = 0.7f;
 795   JVMFlag* match = NULL;
 796   float score;
 797   float max_score = -1;
 798 
 799   for (JVMFlag* current = &amp;flagTable[0]; current-&gt;_name != NULL; current++) {
 800     score = StringUtils::similarity(current-&gt;_name, strlen(current-&gt;_name), name, length);
 801     if (score &gt; max_score) {
 802       max_score = score;
 803       match = current;
 804     }
 805   }
 806 
 807   if (match == NULL) {
 808     return NULL;
 809   }
 810 
 811   if (!(match-&gt;is_unlocked() || match-&gt;is_unlocker())) {
 812     if (!allow_locked) {
 813       return NULL;
 814     }
 815   }
 816 
 817   if (max_score &lt; VMOptionsFuzzyMatchSimilarity) {
 818     return NULL;
 819   }
 820 
 821   return match;
 822 }
 823 
 824 // Returns the address of the index&#39;th element
 825 JVMFlag* JVMFlagEx::flag_from_enum(JVMFlagsEnum flag) {
 826   assert((size_t)flag &lt; JVMFlag::numFlags, &quot;bad command line flag index&quot;);
 827   return &amp;JVMFlag::flags[flag];
 828 }
 829 
 830 bool JVMFlagEx::is_default(JVMFlagsEnum flag) {
 831   return flag_from_enum(flag)-&gt;is_default();
 832 }
 833 
 834 bool JVMFlagEx::is_ergo(JVMFlagsEnum flag) {
 835   return flag_from_enum(flag)-&gt;is_ergonomic();
 836 }
 837 
 838 bool JVMFlagEx::is_cmdline(JVMFlagsEnum flag) {
 839   return flag_from_enum(flag)-&gt;is_command_line();
 840 }
 841 
 842 void JVMFlagEx::setOnCmdLine(JVMFlagsEnum flag) {
 843   JVMFlag* faddr = flag_from_enum(flag);
 844   assert(faddr != NULL, &quot;Unknown flag&quot;);
 845   faddr-&gt;set_command_line();
 846 }
 847 
 848 template&lt;class E, class T&gt;
 849 static void trace_flag_changed(const JVMFlag* flag, const T old_value, const T new_value, const JVMFlag::Flags origin) {
 850   E e;
 851   e.set_name(flag-&gt;_name);
 852   e.set_oldValue(old_value);
 853   e.set_newValue(new_value);
 854   e.set_origin(origin);
 855   e.commit();
 856 }
 857 
 858 static JVMFlag::Error apply_constraint_and_check_range_bool(const JVMFlag* flag, bool new_value, bool verbose) {
 859   JVMFlag::Error status = JVMFlag::SUCCESS;
 860   JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);
 861   if (constraint != NULL) {
 862     status = constraint-&gt;apply_bool(new_value, verbose);
 863   }
 864   return status;
 865 }
 866 
 867 JVMFlag::Error JVMFlag::boolAt(const JVMFlag* flag, bool* value) {
 868   if (flag == NULL) return JVMFlag::INVALID_FLAG;
 869   if (!flag-&gt;is_bool()) return JVMFlag::WRONG_FORMAT;
 870   *value = flag-&gt;get_bool();
 871   return JVMFlag::SUCCESS;
 872 }
 873 
 874 JVMFlag::Error JVMFlag::boolAtPut(JVMFlag* flag, bool* value, JVMFlag::Flags origin) {
 875   if (flag == NULL) return JVMFlag::INVALID_FLAG;
 876   if (!flag-&gt;is_bool()) return JVMFlag::WRONG_FORMAT;
 877   JVMFlag::Error check = apply_constraint_and_check_range_bool(flag, *value, !JVMFlagConstraintList::validated_after_ergo());
 878   if (check != JVMFlag::SUCCESS) return check;
 879   bool old_value = flag-&gt;get_bool();
 880   trace_flag_changed&lt;EventBooleanFlagChanged, bool&gt;(flag, old_value, *value, origin);
 881   flag-&gt;set_bool(*value);
 882   *value = old_value;
 883   flag-&gt;set_origin(origin);
 884   return JVMFlag::SUCCESS;
 885 }
 886 
 887 JVMFlag::Error JVMFlagEx::boolAtPut(JVMFlagsEnum flag, bool value, JVMFlag::Flags origin) {
 888   JVMFlag* faddr = flag_from_enum(flag);
 889   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_bool(), &quot;wrong flag type&quot;);
 890   return JVMFlag::boolAtPut(faddr, &amp;value, origin);
 891 }
 892 
 893 static JVMFlag::Error apply_constraint_and_check_range_int(const JVMFlag* flag, int new_value, bool verbose) {
 894   JVMFlag::Error status = JVMFlag::SUCCESS;
 895   JVMFlagRange* range = JVMFlagRangeList::find(flag);
 896   if (range != NULL) {
 897     status = range-&gt;check_int(new_value, verbose);
 898   }
 899   if (status == JVMFlag::SUCCESS) {
 900     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);
 901     if (constraint != NULL) {
 902       status = constraint-&gt;apply_int(new_value, verbose);
 903     }
 904   }
 905   return status;
 906 }
 907 
 908 JVMFlag::Error JVMFlag::intAt(const JVMFlag* flag, int* value) {
 909   if (flag == NULL) return JVMFlag::INVALID_FLAG;
 910   if (!flag-&gt;is_int()) return JVMFlag::WRONG_FORMAT;
 911   *value = flag-&gt;get_int();
 912   return JVMFlag::SUCCESS;
 913 }
 914 
 915 JVMFlag::Error JVMFlag::intAtPut(JVMFlag* flag, int* value, JVMFlag::Flags origin) {
 916   if (flag == NULL) return JVMFlag::INVALID_FLAG;
 917   if (!flag-&gt;is_int()) return JVMFlag::WRONG_FORMAT;
 918   JVMFlag::Error check = apply_constraint_and_check_range_int(flag, *value, !JVMFlagConstraintList::validated_after_ergo());
 919   if (check != JVMFlag::SUCCESS) return check;
 920   int old_value = flag-&gt;get_int();
 921   trace_flag_changed&lt;EventIntFlagChanged, s4&gt;(flag, old_value, *value, origin);
 922   flag-&gt;set_int(*value);
 923   *value = old_value;
 924   flag-&gt;set_origin(origin);
 925   return JVMFlag::SUCCESS;
 926 }
 927 
 928 JVMFlag::Error JVMFlagEx::intAtPut(JVMFlagsEnum flag, int value, JVMFlag::Flags origin) {
 929   JVMFlag* faddr = flag_from_enum(flag);
 930   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_int(), &quot;wrong flag type&quot;);
 931   return JVMFlag::intAtPut(faddr, &amp;value, origin);
 932 }
 933 
 934 static JVMFlag::Error apply_constraint_and_check_range_uint(const JVMFlag* flag, uint new_value, bool verbose) {
 935   JVMFlag::Error status = JVMFlag::SUCCESS;
 936   JVMFlagRange* range = JVMFlagRangeList::find(flag);
 937   if (range != NULL) {
 938     status = range-&gt;check_uint(new_value, verbose);
 939   }
 940   if (status == JVMFlag::SUCCESS) {
 941     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);
 942     if (constraint != NULL) {
 943       status = constraint-&gt;apply_uint(new_value, verbose);
 944     }
 945   }
 946   return status;
 947 }
 948 
 949 JVMFlag::Error JVMFlag::uintAt(const JVMFlag* flag, uint* value) {
 950   if (flag == NULL) return JVMFlag::INVALID_FLAG;
 951   if (!flag-&gt;is_uint()) return JVMFlag::WRONG_FORMAT;
 952   *value = flag-&gt;get_uint();
 953   return JVMFlag::SUCCESS;
 954 }
 955 
 956 JVMFlag::Error JVMFlag::uintAtPut(JVMFlag* flag, uint* value, JVMFlag::Flags origin) {
 957   if (flag == NULL) return JVMFlag::INVALID_FLAG;
 958   if (!flag-&gt;is_uint()) return JVMFlag::WRONG_FORMAT;
 959   JVMFlag::Error check = apply_constraint_and_check_range_uint(flag, *value, !JVMFlagConstraintList::validated_after_ergo());
 960   if (check != JVMFlag::SUCCESS) return check;
 961   uint old_value = flag-&gt;get_uint();
 962   trace_flag_changed&lt;EventUnsignedIntFlagChanged, u4&gt;(flag, old_value, *value, origin);
 963   flag-&gt;set_uint(*value);
 964   *value = old_value;
 965   flag-&gt;set_origin(origin);
 966   return JVMFlag::SUCCESS;
 967 }
 968 
 969 JVMFlag::Error JVMFlagEx::uintAtPut(JVMFlagsEnum flag, uint value, JVMFlag::Flags origin) {
 970   JVMFlag* faddr = flag_from_enum(flag);
 971   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_uint(), &quot;wrong flag type&quot;);
 972   return JVMFlag::uintAtPut(faddr, &amp;value, origin);
 973 }
 974 
 975 JVMFlag::Error JVMFlag::intxAt(const JVMFlag* flag, intx* value) {
 976   if (flag == NULL) return JVMFlag::INVALID_FLAG;
 977   if (!flag-&gt;is_intx()) return JVMFlag::WRONG_FORMAT;
 978   *value = flag-&gt;get_intx();
 979   return JVMFlag::SUCCESS;
 980 }
 981 
 982 static JVMFlag::Error apply_constraint_and_check_range_intx(const JVMFlag* flag, intx new_value, bool verbose) {
 983   JVMFlag::Error status = JVMFlag::SUCCESS;
 984   JVMFlagRange* range = JVMFlagRangeList::find(flag);
 985   if (range != NULL) {
 986     status = range-&gt;check_intx(new_value, verbose);
 987   }
 988   if (status == JVMFlag::SUCCESS) {
 989     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);
 990     if (constraint != NULL) {
 991       status = constraint-&gt;apply_intx(new_value, verbose);
 992     }
 993   }
 994   return status;
 995 }
 996 
 997 JVMFlag::Error JVMFlag::intxAtPut(JVMFlag* flag, intx* value, JVMFlag::Flags origin) {
 998   if (flag == NULL) return JVMFlag::INVALID_FLAG;
 999   if (!flag-&gt;is_intx()) return JVMFlag::WRONG_FORMAT;
1000   JVMFlag::Error check = apply_constraint_and_check_range_intx(flag, *value, !JVMFlagConstraintList::validated_after_ergo());
1001   if (check != JVMFlag::SUCCESS) return check;
1002   intx old_value = flag-&gt;get_intx();
1003   trace_flag_changed&lt;EventLongFlagChanged, intx&gt;(flag, old_value, *value, origin);
1004   flag-&gt;set_intx(*value);
1005   *value = old_value;
1006   flag-&gt;set_origin(origin);
1007   return JVMFlag::SUCCESS;
1008 }
1009 
1010 JVMFlag::Error JVMFlagEx::intxAtPut(JVMFlagsEnum flag, intx value, JVMFlag::Flags origin) {
1011   JVMFlag* faddr = flag_from_enum(flag);
1012   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_intx(), &quot;wrong flag type&quot;);
1013   return JVMFlag::intxAtPut(faddr, &amp;value, origin);
1014 }
1015 
1016 JVMFlag::Error JVMFlag::uintxAt(const JVMFlag* flag, uintx* value) {
1017   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1018   if (!flag-&gt;is_uintx()) return JVMFlag::WRONG_FORMAT;
1019   *value = flag-&gt;get_uintx();
1020   return JVMFlag::SUCCESS;
1021 }
1022 
1023 static JVMFlag::Error apply_constraint_and_check_range_uintx(const JVMFlag* flag, uintx new_value, bool verbose) {
1024   JVMFlag::Error status = JVMFlag::SUCCESS;
1025   JVMFlagRange* range = JVMFlagRangeList::find(flag);
1026   if (range != NULL) {
1027     status = range-&gt;check_uintx(new_value, verbose);
1028   }
1029   if (status == JVMFlag::SUCCESS) {
1030     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);
1031     if (constraint != NULL) {
1032       status = constraint-&gt;apply_uintx(new_value, verbose);
1033     }
1034   }
1035   return status;
1036 }
1037 
1038 JVMFlag::Error JVMFlag::uintxAtPut(JVMFlag* flag, uintx* value, JVMFlag::Flags origin) {
1039   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1040   if (!flag-&gt;is_uintx()) return JVMFlag::WRONG_FORMAT;
1041   JVMFlag::Error check = apply_constraint_and_check_range_uintx(flag, *value, !JVMFlagConstraintList::validated_after_ergo());
1042   if (check != JVMFlag::SUCCESS) return check;
1043   uintx old_value = flag-&gt;get_uintx();
1044   trace_flag_changed&lt;EventUnsignedLongFlagChanged, u8&gt;(flag, old_value, *value, origin);
1045   flag-&gt;set_uintx(*value);
1046   *value = old_value;
1047   flag-&gt;set_origin(origin);
1048   return JVMFlag::SUCCESS;
1049 }
1050 
1051 JVMFlag::Error JVMFlagEx::uintxAtPut(JVMFlagsEnum flag, uintx value, JVMFlag::Flags origin) {
1052   JVMFlag* faddr = flag_from_enum(flag);
1053   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_uintx(), &quot;wrong flag type&quot;);
1054   return JVMFlag::uintxAtPut(faddr, &amp;value, origin);
1055 }
1056 
1057 JVMFlag::Error JVMFlag::uint64_tAt(const JVMFlag* flag, uint64_t* value) {
1058   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1059   if (!flag-&gt;is_uint64_t()) return JVMFlag::WRONG_FORMAT;
1060   *value = flag-&gt;get_uint64_t();
1061   return JVMFlag::SUCCESS;
1062 }
1063 
1064 static JVMFlag::Error apply_constraint_and_check_range_uint64_t(const JVMFlag* flag, uint64_t new_value, bool verbose) {
1065   JVMFlag::Error status = JVMFlag::SUCCESS;
1066   JVMFlagRange* range = JVMFlagRangeList::find(flag);
1067   if (range != NULL) {
1068     status = range-&gt;check_uint64_t(new_value, verbose);
1069   }
1070   if (status == JVMFlag::SUCCESS) {
1071     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);
1072     if (constraint != NULL) {
1073       status = constraint-&gt;apply_uint64_t(new_value, verbose);
1074     }
1075   }
1076   return status;
1077 }
1078 
1079 JVMFlag::Error JVMFlag::uint64_tAtPut(JVMFlag* flag, uint64_t* value, JVMFlag::Flags origin) {
1080   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1081   if (!flag-&gt;is_uint64_t()) return JVMFlag::WRONG_FORMAT;
1082   JVMFlag::Error check = apply_constraint_and_check_range_uint64_t(flag, *value, !JVMFlagConstraintList::validated_after_ergo());
1083   if (check != JVMFlag::SUCCESS) return check;
1084   uint64_t old_value = flag-&gt;get_uint64_t();
1085   trace_flag_changed&lt;EventUnsignedLongFlagChanged, u8&gt;(flag, old_value, *value, origin);
1086   flag-&gt;set_uint64_t(*value);
1087   *value = old_value;
1088   flag-&gt;set_origin(origin);
1089   return JVMFlag::SUCCESS;
1090 }
1091 
1092 JVMFlag::Error JVMFlagEx::uint64_tAtPut(JVMFlagsEnum flag, uint64_t value, JVMFlag::Flags origin) {
1093   JVMFlag* faddr = flag_from_enum(flag);
1094   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_uint64_t(), &quot;wrong flag type&quot;);
1095   return JVMFlag::uint64_tAtPut(faddr, &amp;value, origin);
1096 }
1097 
1098 JVMFlag::Error JVMFlag::size_tAt(const JVMFlag* flag, size_t* value) {
1099   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1100   if (!flag-&gt;is_size_t()) return JVMFlag::WRONG_FORMAT;
1101   *value = flag-&gt;get_size_t();
1102   return JVMFlag::SUCCESS;
1103 }
1104 
1105 static JVMFlag::Error apply_constraint_and_check_range_size_t(const JVMFlag* flag, size_t new_value, bool verbose) {
1106   JVMFlag::Error status = JVMFlag::SUCCESS;
1107   JVMFlagRange* range = JVMFlagRangeList::find(flag);
1108   if (range != NULL) {
1109     status = range-&gt;check_size_t(new_value, verbose);
1110   }
1111   if (status == JVMFlag::SUCCESS) {
1112     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);
1113     if (constraint != NULL) {
1114       status = constraint-&gt;apply_size_t(new_value, verbose);
1115     }
1116   }
1117   return status;
1118 }
1119 
1120 
1121 JVMFlag::Error JVMFlag::size_tAtPut(JVMFlag* flag, size_t* value, JVMFlag::Flags origin) {
1122   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1123   if (!flag-&gt;is_size_t()) return JVMFlag::WRONG_FORMAT;
1124   JVMFlag::Error check = apply_constraint_and_check_range_size_t(flag, *value, !JVMFlagConstraintList::validated_after_ergo());
1125   if (check != JVMFlag::SUCCESS) return check;
1126   size_t old_value = flag-&gt;get_size_t();
1127   trace_flag_changed&lt;EventUnsignedLongFlagChanged, u8&gt;(flag, old_value, *value, origin);
1128   flag-&gt;set_size_t(*value);
1129   *value = old_value;
1130   flag-&gt;set_origin(origin);
1131   return JVMFlag::SUCCESS;
1132 }
1133 
1134 JVMFlag::Error JVMFlagEx::size_tAtPut(JVMFlagsEnum flag, size_t value, JVMFlag::Flags origin) {
1135   JVMFlag* faddr = flag_from_enum(flag);
1136   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_size_t(), &quot;wrong flag type&quot;);
1137   return JVMFlag::size_tAtPut(faddr, &amp;value, origin);
1138 }
1139 
1140 JVMFlag::Error JVMFlag::doubleAt(const JVMFlag* flag, double* value) {
1141   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1142   if (!flag-&gt;is_double()) return JVMFlag::WRONG_FORMAT;
1143   *value = flag-&gt;get_double();
1144   return JVMFlag::SUCCESS;
1145 }
1146 
1147 static JVMFlag::Error apply_constraint_and_check_range_double(const JVMFlag* flag, double new_value, bool verbose) {
1148   JVMFlag::Error status = JVMFlag::SUCCESS;
1149   JVMFlagRange* range = JVMFlagRangeList::find(flag);
1150   if (range != NULL) {
1151     status = range-&gt;check_double(new_value, verbose);
1152   }
1153   if (status == JVMFlag::SUCCESS) {
1154     JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);
1155     if (constraint != NULL) {
1156       status = constraint-&gt;apply_double(new_value, verbose);
1157     }
1158   }
1159   return status;
1160 }
1161 
1162 JVMFlag::Error JVMFlag::doubleAtPut(JVMFlag* flag, double* value, JVMFlag::Flags origin) {
1163   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1164   if (!flag-&gt;is_double()) return JVMFlag::WRONG_FORMAT;
1165   JVMFlag::Error check = apply_constraint_and_check_range_double(flag, *value, !JVMFlagConstraintList::validated_after_ergo());
1166   if (check != JVMFlag::SUCCESS) return check;
1167   double old_value = flag-&gt;get_double();
1168   trace_flag_changed&lt;EventDoubleFlagChanged, double&gt;(flag, old_value, *value, origin);
1169   flag-&gt;set_double(*value);
1170   *value = old_value;
1171   flag-&gt;set_origin(origin);
1172   return JVMFlag::SUCCESS;
1173 }
1174 
1175 JVMFlag::Error JVMFlagEx::doubleAtPut(JVMFlagsEnum flag, double value, JVMFlag::Flags origin) {
1176   JVMFlag* faddr = flag_from_enum(flag);
1177   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_double(), &quot;wrong flag type&quot;);
1178   return JVMFlag::doubleAtPut(faddr, &amp;value, origin);
1179 }
1180 
1181 JVMFlag::Error JVMFlag::ccstrAt(const JVMFlag* flag, ccstr* value) {
1182   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1183   if (!flag-&gt;is_ccstr()) return JVMFlag::WRONG_FORMAT;
1184   *value = flag-&gt;get_ccstr();
1185   return JVMFlag::SUCCESS;
1186 }
1187 
1188 JVMFlag::Error JVMFlag::ccstrAtPut(JVMFlag* flag, ccstr* value, JVMFlag::Flags origin) {
1189   if (flag == NULL) return JVMFlag::INVALID_FLAG;
1190   if (!flag-&gt;is_ccstr()) return JVMFlag::WRONG_FORMAT;
1191   ccstr old_value = flag-&gt;get_ccstr();
1192   trace_flag_changed&lt;EventStringFlagChanged, const char*&gt;(flag, old_value, *value, origin);
1193   char* new_value = NULL;
1194   if (*value != NULL) {
1195     new_value = os::strdup_check_oom(*value);
1196   }
1197   flag-&gt;set_ccstr(new_value);
1198   if (flag-&gt;is_default() &amp;&amp; old_value != NULL) {
1199     // Prior value is NOT heap allocated, but was a literal constant.
1200     old_value = os::strdup_check_oom(old_value);
1201   }
1202   *value = old_value;
1203   flag-&gt;set_origin(origin);
1204   return JVMFlag::SUCCESS;
1205 }
1206 
1207 JVMFlag::Error JVMFlagEx::ccstrAtPut(JVMFlagsEnum flag, ccstr value, JVMFlag::Flags origin) {
1208   JVMFlag* faddr = flag_from_enum(flag);
1209   guarantee(faddr != NULL &amp;&amp; faddr-&gt;is_ccstr(), &quot;wrong flag type&quot;);
1210   ccstr old_value = faddr-&gt;get_ccstr();
1211   trace_flag_changed&lt;EventStringFlagChanged, const char*&gt;(faddr, old_value, value, origin);
1212   char* new_value = os::strdup_check_oom(value);
1213   faddr-&gt;set_ccstr(new_value);
1214   if (!faddr-&gt;is_default() &amp;&amp; old_value != NULL) {
1215     // Prior value is heap allocated so free it.
1216     FREE_C_HEAP_ARRAY(char, old_value);
1217   }
1218   faddr-&gt;set_origin(origin);
1219   return JVMFlag::SUCCESS;
1220 }
1221 
1222 extern &quot;C&quot; {
1223   static int compare_flags(const void* void_a, const void* void_b) {
1224     return strcmp((*((JVMFlag**) void_a))-&gt;_name, (*((JVMFlag**) void_b))-&gt;_name);
1225   }
1226 }
1227 
1228 void JVMFlag::printSetFlags(outputStream* out) {
1229   // Print which flags were set on the command line
1230   // note: this method is called before the thread structure is in place
1231   //       which means resource allocation cannot be used.
1232 
1233   // The last entry is the null entry.
1234   const size_t length = JVMFlag::numFlags - 1;
1235 
1236   // Sort
1237   JVMFlag** array = NEW_C_HEAP_ARRAY(JVMFlag*, length, mtArguments);
1238   for (size_t i = 0; i &lt; length; i++) {
1239     array[i] = &amp;flagTable[i];
1240   }
1241   qsort(array, length, sizeof(JVMFlag*), compare_flags);
1242 
1243   // Print
1244   for (size_t i = 0; i &lt; length; i++) {
1245     if (array[i]-&gt;get_origin() /* naked field! */) {
1246       array[i]-&gt;print_as_flag(out);
1247       out-&gt;print(&quot; &quot;);
1248     }
1249   }
1250   out-&gt;cr();
1251   FREE_C_HEAP_ARRAY(JVMFlag*, array);
1252 }
1253 
1254 #ifndef PRODUCT
1255 
1256 void JVMFlag::verify() {
1257   assert(Arguments::check_vm_args_consistency(), &quot;Some flag settings conflict&quot;);
1258 }
1259 
1260 #endif // PRODUCT
1261 
1262 void JVMFlag::printFlags(outputStream* out, bool withComments, bool printRanges, bool skipDefaults) {
1263   // Print the flags sorted by name
1264   // Note: This method may be called before the thread structure is in place
1265   //       which means resource allocation cannot be used. Also, it may be
1266   //       called as part of error reporting, so handle native OOMs gracefully.
1267 
1268   // The last entry is the null entry.
1269   const size_t length = JVMFlag::numFlags - 1;
1270 
1271   // Print
1272   if (!printRanges) {
1273     out-&gt;print_cr(&quot;[Global flags]&quot;);
1274   } else {
1275     out-&gt;print_cr(&quot;[Global flags ranges]&quot;);
1276   }
1277 
1278   // Sort
1279   JVMFlag** array = NEW_C_HEAP_ARRAY_RETURN_NULL(JVMFlag*, length, mtArguments);
1280   if (array != NULL) {
1281     for (size_t i = 0; i &lt; length; i++) {
1282       array[i] = &amp;flagTable[i];
1283     }
1284     qsort(array, length, sizeof(JVMFlag*), compare_flags);
1285 
1286     for (size_t i = 0; i &lt; length; i++) {
1287       if (array[i]-&gt;is_unlocked() &amp;&amp; !(skipDefaults &amp;&amp; array[i]-&gt;is_default())) {
1288         array[i]-&gt;print_on(out, withComments, printRanges);
1289       }
1290     }
1291     FREE_C_HEAP_ARRAY(JVMFlag*, array);
1292   } else {
1293     // OOM? Print unsorted.
1294     for (size_t i = 0; i &lt; length; i++) {
1295       if (flagTable[i].is_unlocked() &amp;&amp; !(skipDefaults &amp;&amp; flagTable[i].is_default())) {
1296         flagTable[i].print_on(out, withComments, printRanges);
1297       }
1298     }
1299   }
1300 }
1301 
1302 void JVMFlag::printError(bool verbose, const char* msg, ...) {
1303   if (verbose) {
1304     va_list listPointer;
1305     va_start(listPointer, msg);
1306     jio_vfprintf(defaultStream::error_stream(), msg, listPointer);
1307     va_end(listPointer);
1308   }
1309 }
    </pre>
  </body>
</html>
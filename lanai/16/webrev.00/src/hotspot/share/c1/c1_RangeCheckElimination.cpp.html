<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/c1/c1_RangeCheckElimination.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_ValueStack.hpp&quot;
  27 #include &quot;c1/c1_RangeCheckElimination.hpp&quot;
  28 #include &quot;c1/c1_IR.hpp&quot;
  29 #include &quot;c1/c1_Canonicalizer.hpp&quot;
  30 #include &quot;c1/c1_ValueMap.hpp&quot;
  31 #include &quot;ci/ciMethodData.hpp&quot;
  32 #include &quot;runtime/deoptimization.hpp&quot;
  33 #ifdef ASSERT
  34 #include &quot;utilities/bitMap.inline.hpp&quot;
  35 #endif
  36 
  37 // Macros for the Trace and the Assertion flag
  38 #ifdef ASSERT
  39 #define TRACE_RANGE_CHECK_ELIMINATION(code) if (TraceRangeCheckElimination) { code; }
  40 #define ASSERT_RANGE_CHECK_ELIMINATION(code) if (AssertRangeCheckElimination) { code; }
  41 #define TRACE_OR_ASSERT_RANGE_CHECK_ELIMINATION(code) if (TraceRangeCheckElimination || AssertRangeCheckElimination) { code; }
  42 #else
  43 #define TRACE_RANGE_CHECK_ELIMINATION(code)
  44 #define ASSERT_RANGE_CHECK_ELIMINATION(code)
  45 #define TRACE_OR_ASSERT_RANGE_CHECK_ELIMINATION(code)
  46 #endif
  47 
  48 // Entry point for the optimization
  49 void RangeCheckElimination::eliminate(IR *ir) {
  50   bool do_elimination = ir-&gt;compilation()-&gt;has_access_indexed();
  51   ASSERT_RANGE_CHECK_ELIMINATION(do_elimination = true);
  52   if (do_elimination) {
  53     RangeCheckEliminator rce(ir);
  54   }
  55 }
  56 
  57 // Constructor
  58 RangeCheckEliminator::RangeCheckEliminator(IR *ir) :
  59   _bounds(Instruction::number_of_instructions(), Instruction::number_of_instructions(), NULL),
  60   _access_indexed_info(Instruction::number_of_instructions(), Instruction::number_of_instructions(), NULL)
  61 {
  62   _visitor.set_range_check_eliminator(this);
  63   _ir = ir;
  64   _number_of_instructions = Instruction::number_of_instructions();
  65   _optimistic = ir-&gt;compilation()-&gt;is_optimistic();
  66 
  67   TRACE_RANGE_CHECK_ELIMINATION(
  68     tty-&gt;cr();
  69     tty-&gt;print_cr(&quot;Range check elimination&quot;);
  70     ir-&gt;method()-&gt;print_name(tty);
  71     tty-&gt;cr();
  72   );
  73 
  74   TRACE_RANGE_CHECK_ELIMINATION(
  75     tty-&gt;print_cr(&quot;optimistic=%d&quot;, (int)_optimistic);
  76   );
  77 
  78 #ifdef ASSERT
  79   // Verifies several conditions that must be true on the IR-input. Only used for debugging purposes.
  80   TRACE_RANGE_CHECK_ELIMINATION(
  81     tty-&gt;print_cr(&quot;Verification of IR . . .&quot;);
  82   );
  83   Verification verification(ir);
  84 #endif
  85 
  86   // Set process block flags
  87   // Optimization so a blocks is only processed if it contains an access indexed instruction or if
  88   // one of its children in the dominator tree contains an access indexed instruction.
  89   set_process_block_flags(ir-&gt;start());
  90 
  91   // Pass over instructions in the dominator tree
  92   TRACE_RANGE_CHECK_ELIMINATION(
  93     tty-&gt;print_cr(&quot;Starting pass over dominator tree . . .&quot;)
  94   );
  95   calc_bounds(ir-&gt;start(), NULL);
  96 
  97   TRACE_RANGE_CHECK_ELIMINATION(
  98     tty-&gt;print_cr(&quot;Finished!&quot;)
  99   );
 100 }
 101 
 102 // Instruction specific work for some instructions
 103 // Constant
 104 void RangeCheckEliminator::Visitor::do_Constant(Constant *c) {
 105   IntConstant *ic = c-&gt;type()-&gt;as_IntConstant();
 106   if (ic != NULL) {
 107     int value = ic-&gt;value();
 108     _bound = new Bound(value, NULL, value, NULL);
 109   }
 110 }
 111 
 112 // LogicOp
 113 void RangeCheckEliminator::Visitor::do_LogicOp(LogicOp *lo) {
 114   if (lo-&gt;type()-&gt;as_IntType() &amp;&amp; lo-&gt;op() == Bytecodes::_iand &amp;&amp; (lo-&gt;x()-&gt;as_Constant() || lo-&gt;y()-&gt;as_Constant())) {
 115     int constant = 0;
 116     Constant *c = lo-&gt;x()-&gt;as_Constant();
 117     if (c != NULL) {
 118       constant = c-&gt;type()-&gt;as_IntConstant()-&gt;value();
 119     } else {
 120       constant = lo-&gt;y()-&gt;as_Constant()-&gt;type()-&gt;as_IntConstant()-&gt;value();
 121     }
 122     if (constant &gt;= 0) {
 123       _bound = new Bound(0, NULL, constant, NULL);
 124     }
 125   }
 126 }
 127 
 128 // Phi
 129 void RangeCheckEliminator::Visitor::do_Phi(Phi *phi) {
 130   if (!phi-&gt;type()-&gt;as_IntType() &amp;&amp; !phi-&gt;type()-&gt;as_ObjectType()) return;
 131 
 132   BlockBegin *block = phi-&gt;block();
 133   int op_count = phi-&gt;operand_count();
 134   bool has_upper = true;
 135   bool has_lower = true;
 136   assert(phi, &quot;Phi must not be null&quot;);
 137   Bound *bound = NULL;
 138 
 139   // TODO: support more difficult phis
 140   for (int i=0; i&lt;op_count; i++) {
 141     Value v = phi-&gt;operand_at(i);
 142 
 143     if (v == phi) continue;
 144 
 145     // Check if instruction is connected with phi itself
 146     Op2 *op2 = v-&gt;as_Op2();
 147     if (op2 != NULL) {
 148       Value x = op2-&gt;x();
 149       Value y = op2-&gt;y();
 150       if ((x == phi || y == phi)) {
 151         Value other = x;
 152         if (other == phi) {
 153           other = y;
 154         }
 155         ArithmeticOp *ao = v-&gt;as_ArithmeticOp();
 156         if (ao != NULL &amp;&amp; ao-&gt;op() == Bytecodes::_iadd) {
 157           assert(ao-&gt;op() == Bytecodes::_iadd, &quot;Has to be add!&quot;);
 158           if (ao-&gt;type()-&gt;as_IntType()) {
 159             Constant *c = other-&gt;as_Constant();
 160             if (c != NULL) {
 161               assert(c-&gt;type()-&gt;as_IntConstant(), &quot;Constant has to be of type integer&quot;);
 162               int value = c-&gt;type()-&gt;as_IntConstant()-&gt;value();
 163               if (value == 1) {
 164                 has_upper = false;
 165               } else if (value &gt; 1) {
 166                 // Overflow not guaranteed
 167                 has_upper = false;
 168                 has_lower = false;
 169               } else if (value &lt; 0) {
 170                 has_lower = false;
 171               }
 172               continue;
 173             }
 174           }
 175         }
 176       }
 177     }
 178 
 179     // No connection -&gt; new bound
 180     Bound *v_bound = _rce-&gt;get_bound(v);
 181     Bound *cur_bound;
 182     int cur_constant = 0;
 183     Value cur_value = v;
 184 
 185     if (v-&gt;type()-&gt;as_IntConstant()) {
 186       cur_constant = v-&gt;type()-&gt;as_IntConstant()-&gt;value();
 187       cur_value = NULL;
 188     }
 189     if (!v_bound-&gt;has_upper() || !v_bound-&gt;has_lower()) {
 190       cur_bound = new Bound(cur_constant, cur_value, cur_constant, cur_value);
 191     } else {
 192       cur_bound = v_bound;
 193     }
 194     if (cur_bound) {
 195       if (!bound) {
 196         bound = cur_bound-&gt;copy();
 197       } else {
 198         bound-&gt;or_op(cur_bound);
 199       }
 200     } else {
 201       // No bound!
 202       bound = NULL;
 203       break;
 204     }
 205   }
 206 
 207   if (bound) {
 208     if (!has_upper) {
 209       bound-&gt;remove_upper();
 210     }
 211     if (!has_lower) {
 212       bound-&gt;remove_lower();
 213     }
 214     _bound = bound;
 215   } else {
 216     _bound = new Bound();
 217   }
 218 }
 219 
 220 
 221 // ArithmeticOp
 222 void RangeCheckEliminator::Visitor::do_ArithmeticOp(ArithmeticOp *ao) {
 223   Value x = ao-&gt;x();
 224   Value y = ao-&gt;y();
 225 
 226   if (ao-&gt;op() == Bytecodes::_irem) {
 227     Bound* x_bound = _rce-&gt;get_bound(x);
 228     Bound* y_bound = _rce-&gt;get_bound(y);
 229     if (x_bound-&gt;lower() &gt;= 0 &amp;&amp; x_bound-&gt;lower_instr() == NULL &amp;&amp; y-&gt;as_ArrayLength() != NULL) {
 230       _bound = new Bound(0, NULL, -1, y);
 231     } else {
 232       _bound = new Bound();
 233     }
 234   } else if (!x-&gt;as_Constant() || !y-&gt;as_Constant()) {
 235     assert(!x-&gt;as_Constant() || !y-&gt;as_Constant(), &quot;One of the operands must be non-constant!&quot;);
 236     if (((x-&gt;as_Constant() || y-&gt;as_Constant()) &amp;&amp; (ao-&gt;op() == Bytecodes::_iadd)) || (y-&gt;as_Constant() &amp;&amp; ao-&gt;op() == Bytecodes::_isub)) {
 237       assert(ao-&gt;op() == Bytecodes::_iadd || ao-&gt;op() == Bytecodes::_isub, &quot;Operand must be iadd or isub&quot;);
 238 
 239       if (y-&gt;as_Constant()) {
 240         Value tmp = x;
 241         x = y;
 242         y = tmp;
 243       }
 244       assert(x-&gt;as_Constant()-&gt;type()-&gt;as_IntConstant(), &quot;Constant must be int constant!&quot;);
 245 
 246       // Constant now in x
 247       int const_value = x-&gt;as_Constant()-&gt;type()-&gt;as_IntConstant()-&gt;value();
 248       if (ao-&gt;op() == Bytecodes::_iadd || const_value != min_jint) {
 249         if (ao-&gt;op() == Bytecodes::_isub) {
 250           const_value = -const_value;
 251         }
 252 
 253         Bound * bound = _rce-&gt;get_bound(y);
 254         if (bound-&gt;has_upper() &amp;&amp; bound-&gt;has_lower()) {
 255           int new_lower = bound-&gt;lower() + const_value;
 256           jlong new_lowerl = ((jlong)bound-&gt;lower()) + const_value;
 257           int new_upper = bound-&gt;upper() + const_value;
 258           jlong new_upperl = ((jlong)bound-&gt;upper()) + const_value;
 259 
 260           if (((jlong)new_lower) == new_lowerl &amp;&amp; ((jlong)new_upper == new_upperl)) {
 261             Bound *newBound = new Bound(new_lower, bound-&gt;lower_instr(), new_upper, bound-&gt;upper_instr());
 262             _bound = newBound;
 263           } else {
 264             // overflow
 265             _bound = new Bound();
 266           }
 267         } else {
 268           _bound = new Bound();
 269         }
 270       } else {
 271         _bound = new Bound();
 272       }
 273     } else {
 274       Bound *bound = _rce-&gt;get_bound(x);
 275       if (ao-&gt;op() == Bytecodes::_isub) {
 276         if (bound-&gt;lower_instr() == y) {
 277           _bound = new Bound(Instruction::geq, NULL, bound-&gt;lower());
 278         } else {
 279           _bound = new Bound();
 280         }
 281       } else {
 282         _bound = new Bound();
 283       }
 284     }
 285   }
 286 }
 287 
 288 // IfOp
 289 void RangeCheckEliminator::Visitor::do_IfOp(IfOp *ifOp)
 290 {
 291   if (ifOp-&gt;tval()-&gt;type()-&gt;as_IntConstant() &amp;&amp; ifOp-&gt;fval()-&gt;type()-&gt;as_IntConstant()) {
 292     int min = ifOp-&gt;tval()-&gt;type()-&gt;as_IntConstant()-&gt;value();
 293     int max = ifOp-&gt;fval()-&gt;type()-&gt;as_IntConstant()-&gt;value();
 294     if (min &gt; max) {
 295       // min ^= max ^= min ^= max;
 296       int tmp = min;
 297       min = max;
 298       max = tmp;
 299     }
 300     _bound = new Bound(min, NULL, max, NULL);
 301   }
 302 }
 303 
 304 // Get bound. Returns the current bound on Value v. Normally this is the topmost element on the bound stack.
 305 RangeCheckEliminator::Bound *RangeCheckEliminator::get_bound(Value v) {
 306   // Wrong type or NULL -&gt; No bound
 307   if (!v || (!v-&gt;type()-&gt;as_IntType() &amp;&amp; !v-&gt;type()-&gt;as_ObjectType())) return NULL;
 308 
 309   if (!_bounds.at(v-&gt;id())) {
 310     // First (default) bound is calculated
 311     // Create BoundStack
 312     _bounds.at_put(v-&gt;id(), new BoundStack());
 313     _visitor.clear_bound();
 314     Value visit_value = v;
 315     visit_value-&gt;visit(&amp;_visitor);
 316     Bound *bound = _visitor.bound();
 317     if (bound) {
 318       _bounds.at(v-&gt;id())-&gt;push(bound);
 319     }
 320     if (_bounds.at(v-&gt;id())-&gt;length() == 0) {
 321       assert(!(v-&gt;as_Constant() &amp;&amp; v-&gt;type()-&gt;as_IntConstant()), &quot;constants not handled here&quot;);
 322       _bounds.at(v-&gt;id())-&gt;push(new Bound());
 323     }
 324   } else if (_bounds.at(v-&gt;id())-&gt;length() == 0) {
 325     // To avoid endless loops, bound is currently in calculation -&gt; nothing known about it
 326     return new Bound();
 327   }
 328 
 329   // Return bound
 330   return _bounds.at(v-&gt;id())-&gt;top();
 331 }
 332 
 333 // Update bound
 334 void RangeCheckEliminator::update_bound(IntegerStack &amp;pushed, Value v, Instruction::Condition cond, Value value, int constant) {
 335   if (cond == Instruction::gtr) {
 336     cond = Instruction::geq;
 337     constant++;
 338   } else if (cond == Instruction::lss) {
 339     cond = Instruction::leq;
 340     constant--;
 341   }
 342   Bound *bound = new Bound(cond, value, constant);
 343   update_bound(pushed, v, bound);
 344 }
 345 
 346 // Checks for loop invariance. Returns true if the instruction is outside of the loop which is identified by loop_header.
 347 bool RangeCheckEliminator::loop_invariant(BlockBegin *loop_header, Instruction *instruction) {
 348   assert(loop_header, &quot;Loop header must not be null!&quot;);
 349   if (!instruction) return true;
 350   return instruction-&gt;dominator_depth() &lt; loop_header-&gt;dominator_depth();
 351 }
 352 
 353 // Update bound. Pushes a new bound onto the stack. Tries to do a conjunction with the current bound.
 354 void RangeCheckEliminator::update_bound(IntegerStack &amp;pushed, Value v, Bound *bound) {
 355   if (v-&gt;as_Constant()) {
 356     // No bound update for constants
 357     return;
 358   }
 359   if (!_bounds.at(v-&gt;id())) {
 360     get_bound(v);
 361     assert(_bounds.at(v-&gt;id()), &quot;Now Stack must exist&quot;);
 362   }
 363   Bound *top = NULL;
 364   if (_bounds.at(v-&gt;id())-&gt;length() &gt; 0) {
 365     top = _bounds.at(v-&gt;id())-&gt;top();
 366   }
 367   if (top) {
 368     bound-&gt;and_op(top);
 369   }
 370   _bounds.at(v-&gt;id())-&gt;push(bound);
 371   pushed.append(v-&gt;id());
 372 }
 373 
 374 // Add instruction + idx for in block motion
 375 void RangeCheckEliminator::add_access_indexed_info(InstructionList &amp;indices, int idx, Value instruction, AccessIndexed *ai) {
 376   int id = instruction-&gt;id();
 377   AccessIndexedInfo *aii = _access_indexed_info.at(id);
 378   if (aii == NULL) {
 379     aii = new AccessIndexedInfo();
 380     _access_indexed_info.at_put(id, aii);
 381     indices.append(instruction);
 382     aii-&gt;_min = idx;
 383     aii-&gt;_max = idx;
 384     aii-&gt;_list = new AccessIndexedList();
 385   } else if (idx &gt;= aii-&gt;_min &amp;&amp; idx &lt;= aii-&gt;_max) {
 386     remove_range_check(ai);
 387     return;
 388   }
 389   aii-&gt;_min = MIN2(aii-&gt;_min, idx);
 390   aii-&gt;_max = MAX2(aii-&gt;_max, idx);
 391   aii-&gt;_list-&gt;append(ai);
 392 }
 393 
 394 // In block motion. Tries to reorder checks in order to reduce some of them.
 395 // Example:
 396 // a[i] = 0;
 397 // a[i+2] = 0;
 398 // a[i+1] = 0;
 399 // In this example the check for a[i+1] would be considered as unnecessary during the first iteration.
 400 // After this i is only checked once for i &gt;= 0 and i+2 &lt; a.length before the first array access. If this
 401 // check fails, deoptimization is called.
 402 void RangeCheckEliminator::in_block_motion(BlockBegin *block, AccessIndexedList &amp;accessIndexed, InstructionList &amp;arrays) {
 403   InstructionList indices;
 404 
 405   // Now iterate over all arrays
 406   for (int i=0; i&lt;arrays.length(); i++) {
 407     int max_constant = -1;
 408     AccessIndexedList list_constant;
 409     Value array = arrays.at(i);
 410 
 411     // For all AccessIndexed-instructions in this block concerning the current array.
 412     for(int j=0; j&lt;accessIndexed.length(); j++) {
 413       AccessIndexed *ai = accessIndexed.at(j);
 414       if (ai-&gt;array() != array || !ai-&gt;check_flag(Instruction::NeedsRangeCheckFlag)) continue;
 415 
 416       Value index = ai-&gt;index();
 417       Constant *c = index-&gt;as_Constant();
 418       if (c != NULL) {
 419         int constant_value = c-&gt;type()-&gt;as_IntConstant()-&gt;value();
 420         if (constant_value &gt;= 0) {
 421           if (constant_value &lt;= max_constant) {
 422             // No range check needed for this
 423             remove_range_check(ai);
 424           } else {
 425             max_constant = constant_value;
 426             list_constant.append(ai);
 427           }
 428         }
 429       } else {
 430         int last_integer = 0;
 431         Instruction *last_instruction = index;
 432         int base = 0;
 433         ArithmeticOp *ao = index-&gt;as_ArithmeticOp();
 434 
 435         while (ao != NULL &amp;&amp; (ao-&gt;x()-&gt;as_Constant() || ao-&gt;y()-&gt;as_Constant()) &amp;&amp; (ao-&gt;op() == Bytecodes::_iadd || ao-&gt;op() == Bytecodes::_isub)) {
 436           c = ao-&gt;y()-&gt;as_Constant();
 437           Instruction *other = ao-&gt;x();
 438           if (!c &amp;&amp; ao-&gt;op() == Bytecodes::_iadd) {
 439             c = ao-&gt;x()-&gt;as_Constant();
 440             other = ao-&gt;y();
 441           }
 442 
 443           if (c) {
 444             int value = c-&gt;type()-&gt;as_IntConstant()-&gt;value();
 445             if (value != min_jint) {
 446               if (ao-&gt;op() == Bytecodes::_isub) {
 447                 value = -value;
 448               }
 449               base += value;
 450               last_integer = base;
 451               last_instruction = other;
 452             }
 453             index = other;
 454           } else {
 455             break;
 456           }
 457           ao = index-&gt;as_ArithmeticOp();
 458         }
 459         add_access_indexed_info(indices, last_integer, last_instruction, ai);
 460       }
 461     }
 462 
 463     // Iterate over all different indices
 464     if (_optimistic) {
 465       for (int i = 0; i &lt; indices.length(); i++) {
 466         Instruction *index_instruction = indices.at(i);
 467         AccessIndexedInfo *info = _access_indexed_info.at(index_instruction-&gt;id());
 468         assert(info != NULL, &quot;Info must not be null&quot;);
 469 
 470         // if idx &lt; 0, max &gt; 0, max + idx may fall between 0 and
 471         // length-1 and if min &lt; 0, min + idx may overflow and be &gt;=
 472         // 0. The predicate wouldn&#39;t trigger but some accesses could
 473         // be with a negative index. This test guarantees that for the
 474         // min and max value that are kept the predicate can&#39;t let
 475         // some incorrect accesses happen.
 476         bool range_cond = (info-&gt;_max &lt; 0 || info-&gt;_max + min_jint &lt;= info-&gt;_min);
 477 
 478         // Generate code only if more than 2 range checks can be eliminated because of that.
 479         // 2 because at least 2 comparisons are done
 480         if (info-&gt;_list-&gt;length() &gt; 2 &amp;&amp; range_cond) {
 481           AccessIndexed *first = info-&gt;_list-&gt;at(0);
 482           Instruction *insert_position = first-&gt;prev();
 483           assert(insert_position-&gt;next() == first, &quot;prev was calculated&quot;);
 484           ValueStack *state = first-&gt;state_before();
 485 
 486           // Load min Constant
 487           Constant *min_constant = NULL;
 488           if (info-&gt;_min != 0) {
 489             min_constant = new Constant(new IntConstant(info-&gt;_min));
 490             NOT_PRODUCT(min_constant-&gt;set_printable_bci(first-&gt;printable_bci()));
 491             insert_position = insert_position-&gt;insert_after(min_constant);
 492           }
 493 
 494           // Load max Constant
 495           Constant *max_constant = NULL;
 496           if (info-&gt;_max != 0) {
 497             max_constant = new Constant(new IntConstant(info-&gt;_max));
 498             NOT_PRODUCT(max_constant-&gt;set_printable_bci(first-&gt;printable_bci()));
 499             insert_position = insert_position-&gt;insert_after(max_constant);
 500           }
 501 
 502           // Load array length
 503           Value length_instr = first-&gt;length();
 504           if (!length_instr) {
 505             ArrayLength *length = new ArrayLength(array, first-&gt;state_before()-&gt;copy());
 506             length-&gt;set_exception_state(length-&gt;state_before());
 507             length-&gt;set_flag(Instruction::DeoptimizeOnException, true);
 508             insert_position = insert_position-&gt;insert_after_same_bci(length);
 509             length_instr = length;
 510           }
 511 
 512           // Calculate lower bound
 513           Instruction *lower_compare = index_instruction;
 514           if (min_constant) {
 515             ArithmeticOp *ao = new ArithmeticOp(Bytecodes::_iadd, min_constant, lower_compare, false, NULL);
 516             insert_position = insert_position-&gt;insert_after_same_bci(ao);
 517             lower_compare = ao;
 518           }
 519 
 520           // Calculate upper bound
 521           Instruction *upper_compare = index_instruction;
 522           if (max_constant) {
 523             ArithmeticOp *ao = new ArithmeticOp(Bytecodes::_iadd, max_constant, upper_compare, false, NULL);
 524             insert_position = insert_position-&gt;insert_after_same_bci(ao);
 525             upper_compare = ao;
 526           }
 527 
 528           // Trick with unsigned compare is done
 529           int bci = NOT_PRODUCT(first-&gt;printable_bci()) PRODUCT_ONLY(-1);
 530           insert_position = predicate(upper_compare, Instruction::aeq, length_instr, state, insert_position, bci);
 531           insert_position = predicate_cmp_with_const(lower_compare, Instruction::leq, -1, state, insert_position);
 532           for (int j = 0; j&lt;info-&gt;_list-&gt;length(); j++) {
 533             AccessIndexed *ai = info-&gt;_list-&gt;at(j);
 534             remove_range_check(ai);
 535           }
 536         }
 537       }
 538 
 539       if (list_constant.length() &gt; 1) {
 540         AccessIndexed *first = list_constant.at(0);
 541         Instruction *insert_position = first-&gt;prev();
 542         ValueStack *state = first-&gt;state_before();
 543         // Load max Constant
 544         Constant *constant = new Constant(new IntConstant(max_constant));
 545         NOT_PRODUCT(constant-&gt;set_printable_bci(first-&gt;printable_bci()));
 546         insert_position = insert_position-&gt;insert_after(constant);
 547         Instruction *compare_instr = constant;
 548         Value length_instr = first-&gt;length();
 549         if (!length_instr) {
 550           ArrayLength *length = new ArrayLength(array, state-&gt;copy());
 551           length-&gt;set_exception_state(length-&gt;state_before());
 552           length-&gt;set_flag(Instruction::DeoptimizeOnException, true);
 553           insert_position = insert_position-&gt;insert_after_same_bci(length);
 554           length_instr = length;
 555         }
 556         // Compare for greater or equal to array length
 557         insert_position = predicate(compare_instr, Instruction::geq, length_instr, state, insert_position);
 558         for (int j = 0; j&lt;list_constant.length(); j++) {
 559           AccessIndexed *ai = list_constant.at(j);
 560           remove_range_check(ai);
 561         }
 562       }
 563     }
 564 
 565     // Clear data structures for next array
 566     for (int i = 0; i &lt; indices.length(); i++) {
 567       Instruction *index_instruction = indices.at(i);
 568       _access_indexed_info.at_put(index_instruction-&gt;id(), NULL);
 569     }
 570     indices.clear();
 571   }
 572 }
 573 
 574 bool RangeCheckEliminator::set_process_block_flags(BlockBegin *block) {
 575   Instruction *cur = block;
 576   bool process = false;
 577 
 578   while (cur) {
 579     process |= (cur-&gt;as_AccessIndexed() != NULL);
 580     cur = cur-&gt;next();
 581   }
 582 
 583   BlockList *dominates = block-&gt;dominates();
 584   for (int i=0; i&lt;dominates-&gt;length(); i++) {
 585     BlockBegin *next = dominates-&gt;at(i);
 586     process |= set_process_block_flags(next);
 587   }
 588 
 589   if (!process) {
 590     block-&gt;set(BlockBegin::donot_eliminate_range_checks);
 591   }
 592   return process;
 593 }
 594 
 595 bool RangeCheckEliminator::is_ok_for_deoptimization(Instruction *insert_position, Instruction *array_instr, Instruction *length_instr, Instruction *lower_instr, int lower, Instruction *upper_instr, int upper) {
 596   bool upper_check = true;
 597   assert(lower_instr || lower &gt;= 0, &quot;If no lower_instr present, lower must be greater 0&quot;);
 598   assert(!lower_instr || lower_instr-&gt;dominator_depth() &lt;= insert_position-&gt;dominator_depth(), &quot;Dominator depth must be smaller&quot;);
 599   assert(!upper_instr || upper_instr-&gt;dominator_depth() &lt;= insert_position-&gt;dominator_depth(), &quot;Dominator depth must be smaller&quot;);
 600   assert(array_instr, &quot;Array instruction must exist&quot;);
 601   assert(array_instr-&gt;dominator_depth() &lt;= insert_position-&gt;dominator_depth(), &quot;Dominator depth must be smaller&quot;);
 602   assert(!length_instr || length_instr-&gt;dominator_depth() &lt;= insert_position-&gt;dominator_depth(), &quot;Dominator depth must be smaller&quot;);
 603 
 604   if (upper_instr &amp;&amp; upper_instr-&gt;as_ArrayLength() &amp;&amp; upper_instr-&gt;as_ArrayLength()-&gt;array() == array_instr) {
 605     // static check
 606     if (upper &gt;= 0) return false; // would always trigger a deopt:
 607                                   // array_length + x &gt;= array_length, x &gt;= 0 is always true
 608     upper_check = false;
 609   }
 610   if (lower_instr &amp;&amp; lower_instr-&gt;as_ArrayLength() &amp;&amp; lower_instr-&gt;as_ArrayLength()-&gt;array() == array_instr) {
 611     if (lower &gt; 0) return false;
 612   }
 613   // No upper check required -&gt; skip
 614   if (upper_check &amp;&amp; upper_instr &amp;&amp; upper_instr-&gt;type()-&gt;as_ObjectType() &amp;&amp; upper_instr == array_instr) {
 615     // upper_instr is object means that the upper bound is the length
 616     // of the upper_instr.
 617     return false;
 618   }
 619   return true;
 620 }
 621 
 622 Instruction* RangeCheckEliminator::insert_after(Instruction* insert_position, Instruction* instr, int bci) {
 623   if (bci != -1) {
 624     NOT_PRODUCT(instr-&gt;set_printable_bci(bci));
 625     return insert_position-&gt;insert_after(instr);
 626   } else {
 627     return insert_position-&gt;insert_after_same_bci(instr);
 628   }
 629 }
 630 
 631 Instruction* RangeCheckEliminator::predicate(Instruction* left, Instruction::Condition cond, Instruction* right, ValueStack* state, Instruction *insert_position, int bci) {
 632   RangeCheckPredicate *deoptimize = new RangeCheckPredicate(left, cond, true, right, state-&gt;copy());
 633   return insert_after(insert_position, deoptimize, bci);
 634 }
 635 
 636 Instruction* RangeCheckEliminator::predicate_cmp_with_const(Instruction* instr, Instruction::Condition cond, int constant, ValueStack* state, Instruction *insert_position, int bci) {
 637   Constant *const_instr = new Constant(new IntConstant(constant));
 638   insert_position = insert_after(insert_position, const_instr, bci);
 639   return predicate(instr, cond, const_instr, state, insert_position);
 640 }
 641 
 642 Instruction* RangeCheckEliminator::predicate_add(Instruction* left, int left_const, Instruction::Condition cond, Instruction* right, ValueStack* state, Instruction *insert_position, int bci) {
 643   Constant *constant = new Constant(new IntConstant(left_const));
 644   insert_position = insert_after(insert_position, constant, bci);
 645   ArithmeticOp *ao = new ArithmeticOp(Bytecodes::_iadd, constant, left, false, NULL);
 646   insert_position = insert_position-&gt;insert_after_same_bci(ao);
 647   return predicate(ao, cond, right, state, insert_position);
 648 }
 649 
 650 Instruction* RangeCheckEliminator::predicate_add_cmp_with_const(Instruction* left, int left_const, Instruction::Condition cond, int constant, ValueStack* state, Instruction *insert_position, int bci) {
 651   Constant *const_instr = new Constant(new IntConstant(constant));
 652   insert_position = insert_after(insert_position, const_instr, bci);
 653   return predicate_add(left, left_const, cond, const_instr, state, insert_position);
 654 }
 655 
 656 // Insert deoptimization
 657 void RangeCheckEliminator::insert_deoptimization(ValueStack *state, Instruction *insert_position, Instruction *array_instr, Instruction *length_instr, Instruction *lower_instr, int lower, Instruction *upper_instr, int upper, AccessIndexed *ai) {
 658   assert(is_ok_for_deoptimization(insert_position, array_instr, length_instr, lower_instr, lower, upper_instr, upper), &quot;should have been tested before&quot;);
 659   bool upper_check = !(upper_instr &amp;&amp; upper_instr-&gt;as_ArrayLength() &amp;&amp; upper_instr-&gt;as_ArrayLength()-&gt;array() == array_instr);
 660 
 661   int bci = NOT_PRODUCT(ai-&gt;printable_bci()) PRODUCT_ONLY(-1);
 662   if (lower_instr) {
 663     assert(!lower_instr-&gt;type()-&gt;as_ObjectType(), &quot;Must not be object type&quot;);
 664     if (lower == 0) {
 665       // Compare for less than 0
 666       insert_position = predicate_cmp_with_const(lower_instr, Instruction::lss, 0, state, insert_position, bci);
 667     } else if (lower &gt; 0) {
 668       // Compare for smaller 0
 669       insert_position = predicate_add_cmp_with_const(lower_instr, lower, Instruction::lss, 0, state, insert_position, bci);
 670     } else {
 671       assert(lower &lt; 0, &quot;&quot;);
 672       // Add 1
 673       lower++;
 674       lower = -lower;
 675       // Compare for smaller or equal 0
 676       insert_position = predicate_cmp_with_const(lower_instr, Instruction::leq, lower, state, insert_position, bci);
 677     }
 678   }
 679 
 680   // No upper check required -&gt; skip
 681   if (!upper_check) return;
 682 
 683   // We need to know length of array
 684   if (!length_instr) {
 685     // Load length if necessary
 686     ArrayLength *length = new ArrayLength(array_instr, state-&gt;copy());
 687     NOT_PRODUCT(length-&gt;set_printable_bci(ai-&gt;printable_bci()));
 688     length-&gt;set_exception_state(length-&gt;state_before());
 689     length-&gt;set_flag(Instruction::DeoptimizeOnException, true);
 690     insert_position = insert_position-&gt;insert_after(length);
 691     length_instr = length;
 692   }
 693 
 694   if (!upper_instr) {
 695     // Compare for geq array.length
 696     insert_position = predicate_cmp_with_const(length_instr, Instruction::leq, upper, state, insert_position, bci);
 697   } else {
 698     if (upper_instr-&gt;type()-&gt;as_ObjectType()) {
 699       assert(state, &quot;must not be null&quot;);
 700       assert(upper_instr != array_instr, &quot;should be&quot;);
 701       ArrayLength *length = new ArrayLength(upper_instr, state-&gt;copy());
 702       NOT_PRODUCT(length-&gt;set_printable_bci(ai-&gt;printable_bci()));
 703       length-&gt;set_flag(Instruction::DeoptimizeOnException, true);
 704       length-&gt;set_exception_state(length-&gt;state_before());
 705       insert_position = insert_position-&gt;insert_after(length);
 706       upper_instr = length;
 707     }
 708     assert(upper_instr-&gt;type()-&gt;as_IntType(), &quot;Must not be object type!&quot;);
 709 
 710     if (upper == 0) {
 711       // Compare for geq array.length
 712       insert_position = predicate(upper_instr, Instruction::geq, length_instr, state, insert_position, bci);
 713     } else if (upper &lt; 0) {
 714       // Compare for geq array.length
 715       insert_position = predicate_add(upper_instr, upper, Instruction::geq, length_instr, state, insert_position, bci);
 716     } else {
 717       assert(upper &gt; 0, &quot;&quot;);
 718       upper = -upper;
 719       // Compare for geq array.length
 720       insert_position = predicate_add(length_instr, upper, Instruction::leq, upper_instr, state, insert_position, bci);
 721     }
 722   }
 723 }
 724 
 725 // Add if condition
 726 void RangeCheckEliminator::add_if_condition(IntegerStack &amp;pushed, Value x, Value y, Instruction::Condition condition) {
 727   if (y-&gt;as_Constant()) return;
 728 
 729   int const_value = 0;
 730   Value instr_value = x;
 731   Constant *c = x-&gt;as_Constant();
 732   ArithmeticOp *ao = x-&gt;as_ArithmeticOp();
 733 
 734   if (c != NULL) {
 735     const_value = c-&gt;type()-&gt;as_IntConstant()-&gt;value();
 736     instr_value = NULL;
 737   } else if (ao != NULL &amp;&amp;  (!ao-&gt;x()-&gt;as_Constant() || !ao-&gt;y()-&gt;as_Constant()) &amp;&amp; ((ao-&gt;op() == Bytecodes::_isub &amp;&amp; ao-&gt;y()-&gt;as_Constant()) || ao-&gt;op() == Bytecodes::_iadd)) {
 738     assert(!ao-&gt;x()-&gt;as_Constant() || !ao-&gt;y()-&gt;as_Constant(), &quot;At least one operator must be non-constant!&quot;);
 739     assert(ao-&gt;op() == Bytecodes::_isub || ao-&gt;op() == Bytecodes::_iadd, &quot;Operation has to be add or sub!&quot;);
 740     c = ao-&gt;x()-&gt;as_Constant();
 741     if (c != NULL) {
 742       const_value = c-&gt;type()-&gt;as_IntConstant()-&gt;value();
 743       instr_value = ao-&gt;y();
 744     } else {
 745       c = ao-&gt;y()-&gt;as_Constant();
 746       if (c != NULL) {
 747         const_value = c-&gt;type()-&gt;as_IntConstant()-&gt;value();
 748         instr_value = ao-&gt;x();
 749       }
 750     }
 751     if (ao-&gt;op() == Bytecodes::_isub) {
 752       assert(ao-&gt;y()-&gt;as_Constant(), &quot;1 - x not supported, only x - 1 is valid!&quot;);
 753       if (const_value &gt; min_jint) {
 754         const_value = -const_value;
 755       } else {
 756         const_value = 0;
 757         instr_value = x;
 758       }
 759     }
 760   }
 761 
 762   update_bound(pushed, y, condition, instr_value, const_value);
 763 }
 764 
 765 // Process If
 766 void RangeCheckEliminator::process_if(IntegerStack &amp;pushed, BlockBegin *block, If *cond) {
 767   // Only if we are direct true / false successor and NOT both ! (even this may occur)
 768   if ((cond-&gt;tsux() == block || cond-&gt;fsux() == block) &amp;&amp; cond-&gt;tsux() != cond-&gt;fsux()) {
 769     Instruction::Condition condition = cond-&gt;cond();
 770     if (cond-&gt;fsux() == block) {
 771       condition = Instruction::negate(condition);
 772     }
 773     Value x = cond-&gt;x();
 774     Value y = cond-&gt;y();
 775     if (x-&gt;type()-&gt;as_IntType() &amp;&amp; y-&gt;type()-&gt;as_IntType()) {
 776       add_if_condition(pushed, y, x, condition);
 777       add_if_condition(pushed, x, y, Instruction::mirror(condition));
 778     }
 779   }
 780 }
 781 
 782 // Process access indexed
 783 void RangeCheckEliminator::process_access_indexed(BlockBegin *loop_header, BlockBegin *block, AccessIndexed *ai) {
 784   TRACE_RANGE_CHECK_ELIMINATION(
 785     tty-&gt;fill_to(block-&gt;dominator_depth()*2)
 786   );
 787   TRACE_RANGE_CHECK_ELIMINATION(
 788     tty-&gt;print_cr(&quot;Access indexed: index=%d length=%d&quot;, ai-&gt;index()-&gt;id(), (ai-&gt;length() != NULL ? ai-&gt;length()-&gt;id() :-1 ))
 789   );
 790 
 791   if (ai-&gt;check_flag(Instruction::NeedsRangeCheckFlag)) {
 792     Bound *index_bound = get_bound(ai-&gt;index());
 793     if (!index_bound-&gt;has_lower() || !index_bound-&gt;has_upper()) {
 794       TRACE_RANGE_CHECK_ELIMINATION(
 795         tty-&gt;fill_to(block-&gt;dominator_depth()*2);
 796         tty-&gt;print_cr(&quot;Index instruction %d has no lower and/or no upper bound!&quot;, ai-&gt;index()-&gt;id())
 797       );
 798       return;
 799     }
 800 
 801     Bound *array_bound;
 802     if (ai-&gt;length()) {
 803       array_bound = get_bound(ai-&gt;length());
 804     } else {
 805       array_bound = get_bound(ai-&gt;array());
 806     }
 807 
 808     if (in_array_bound(index_bound, ai-&gt;array()) ||
 809       (index_bound &amp;&amp; array_bound &amp;&amp; index_bound-&gt;is_smaller(array_bound) &amp;&amp; !index_bound-&gt;lower_instr() &amp;&amp; index_bound-&gt;lower() &gt;= 0)) {
 810         TRACE_RANGE_CHECK_ELIMINATION(
 811           tty-&gt;fill_to(block-&gt;dominator_depth()*2);
 812           tty-&gt;print_cr(&quot;Bounds check for instruction %d in block B%d can be fully eliminated!&quot;, ai-&gt;id(), ai-&gt;block()-&gt;block_id())
 813         );
 814 
 815         remove_range_check(ai);
 816     } else if (_optimistic &amp;&amp; loop_header) {
 817       assert(ai-&gt;array(), &quot;Array must not be null!&quot;);
 818       assert(ai-&gt;index(), &quot;Index must not be null!&quot;);
 819 
 820       // Array instruction
 821       Instruction *array_instr = ai-&gt;array();
 822       if (!loop_invariant(loop_header, array_instr)) {
 823         TRACE_RANGE_CHECK_ELIMINATION(
 824           tty-&gt;fill_to(block-&gt;dominator_depth()*2);
 825           tty-&gt;print_cr(&quot;Array %d is not loop invariant to header B%d&quot;, ai-&gt;array()-&gt;id(), loop_header-&gt;block_id())
 826         );
 827         return;
 828       }
 829 
 830       // Lower instruction
 831       Value index_instr = ai-&gt;index();
 832       Value lower_instr = index_bound-&gt;lower_instr();
 833       if (!loop_invariant(loop_header, lower_instr)) {
 834         TRACE_RANGE_CHECK_ELIMINATION(
 835           tty-&gt;fill_to(block-&gt;dominator_depth()*2);
 836           tty-&gt;print_cr(&quot;Lower instruction %d not loop invariant!&quot;, lower_instr-&gt;id())
 837         );
 838         return;
 839       }
 840       if (!lower_instr &amp;&amp; index_bound-&gt;lower() &lt; 0) {
 841         TRACE_RANGE_CHECK_ELIMINATION(
 842           tty-&gt;fill_to(block-&gt;dominator_depth()*2);
 843           tty-&gt;print_cr(&quot;Lower bound smaller than 0 (%d)!&quot;, index_bound-&gt;lower())
 844         );
 845         return;
 846       }
 847 
 848       // Upper instruction
 849       Value upper_instr = index_bound-&gt;upper_instr();
 850       if (!loop_invariant(loop_header, upper_instr)) {
 851         TRACE_RANGE_CHECK_ELIMINATION(
 852           tty-&gt;fill_to(block-&gt;dominator_depth()*2);
 853           tty-&gt;print_cr(&quot;Upper instruction %d not loop invariant!&quot;, upper_instr-&gt;id())
 854         );
 855         return;
 856       }
 857 
 858       // Length instruction
 859       Value length_instr = ai-&gt;length();
 860       if (!loop_invariant(loop_header, length_instr)) {
 861         // Generate length instruction yourself!
 862         length_instr = NULL;
 863       }
 864 
 865       TRACE_RANGE_CHECK_ELIMINATION(
 866         tty-&gt;fill_to(block-&gt;dominator_depth()*2);
 867         tty-&gt;print_cr(&quot;LOOP INVARIANT access indexed %d found in block B%d!&quot;, ai-&gt;id(), ai-&gt;block()-&gt;block_id())
 868       );
 869 
 870       BlockBegin *pred_block = loop_header-&gt;dominator();
 871       assert(pred_block != NULL, &quot;Every loop header has a dominator!&quot;);
 872       BlockEnd *pred_block_end = pred_block-&gt;end();
 873       Instruction *insert_position = pred_block_end-&gt;prev();
 874       ValueStack *state = pred_block_end-&gt;state_before();
 875       if (pred_block_end-&gt;as_Goto() &amp;&amp; state == NULL) state = pred_block_end-&gt;state();
 876       assert(state, &quot;State must not be null&quot;);
 877 
 878       // Add deoptimization to dominator of loop header
 879       TRACE_RANGE_CHECK_ELIMINATION(
 880         tty-&gt;fill_to(block-&gt;dominator_depth()*2);
 881         tty-&gt;print_cr(&quot;Inserting deopt at bci %d in block B%d!&quot;, state-&gt;bci(), insert_position-&gt;block()-&gt;block_id())
 882       );
 883 
 884       if (!is_ok_for_deoptimization(insert_position, array_instr, length_instr, lower_instr, index_bound-&gt;lower(), upper_instr, index_bound-&gt;upper())) {
 885         TRACE_RANGE_CHECK_ELIMINATION(
 886           tty-&gt;fill_to(block-&gt;dominator_depth()*2);
 887           tty-&gt;print_cr(&quot;Could not eliminate because of static analysis!&quot;)
 888         );
 889         return;
 890       }
 891 
 892       insert_deoptimization(state, insert_position, array_instr, length_instr, lower_instr, index_bound-&gt;lower(), upper_instr, index_bound-&gt;upper(), ai);
 893 
 894       // Finally remove the range check!
 895       remove_range_check(ai);
 896     }
 897   }
 898 }
 899 
 900 void RangeCheckEliminator::remove_range_check(AccessIndexed *ai) {
 901   ai-&gt;set_flag(Instruction::NeedsRangeCheckFlag, false);
 902   // no range check, no need for the length instruction anymore
 903   ai-&gt;clear_length();
 904 
 905   TRACE_RANGE_CHECK_ELIMINATION(
 906     tty-&gt;fill_to(ai-&gt;dominator_depth()*2);
 907     tty-&gt;print_cr(&quot;Range check for instruction %d eliminated!&quot;, ai-&gt;id());
 908   );
 909 
 910   ASSERT_RANGE_CHECK_ELIMINATION(
 911     Value array_length = ai-&gt;length();
 912     if (!array_length) {
 913       array_length = ai-&gt;array();
 914       assert(array_length-&gt;type()-&gt;as_ObjectType(), &quot;Has to be object type!&quot;);
 915     }
 916     int cur_constant = -1;
 917     Value cur_value = array_length;
 918     if (cur_value-&gt;type()-&gt;as_IntConstant()) {
 919       cur_constant += cur_value-&gt;type()-&gt;as_IntConstant()-&gt;value();
 920       cur_value = NULL;
 921     }
 922     Bound *new_index_bound = new Bound(0, NULL, cur_constant, cur_value);
 923     add_assertions(new_index_bound, ai-&gt;index(), ai);
 924   );
 925 }
 926 
 927 // Calculate bounds for instruction in this block and children blocks in the dominator tree
 928 void RangeCheckEliminator::calc_bounds(BlockBegin *block, BlockBegin *loop_header) {
 929   // Ensures a valid loop_header
 930   assert(!loop_header || loop_header-&gt;is_set(BlockBegin::linear_scan_loop_header_flag), &quot;Loop header has to be real !&quot;);
 931 
 932   // Tracing output
 933   TRACE_RANGE_CHECK_ELIMINATION(
 934     tty-&gt;fill_to(block-&gt;dominator_depth()*2);
 935     tty-&gt;print_cr(&quot;Block B%d&quot;, block-&gt;block_id());
 936   );
 937 
 938   // Pushed stack for conditions
 939   IntegerStack pushed;
 940   // Process If
 941   BlockBegin *parent = block-&gt;dominator();
 942   if (parent != NULL) {
 943     If *cond = parent-&gt;end()-&gt;as_If();
 944     if (cond != NULL) {
 945       process_if(pushed, block, cond);
 946     }
 947   }
 948 
 949   // Interate over current block
 950   InstructionList arrays;
 951   AccessIndexedList accessIndexed;
 952   Instruction *cur = block;
 953 
 954   while (cur) {
 955     // Ensure cur wasn&#39;t inserted during the elimination
 956     if (cur-&gt;id() &lt; this-&gt;_bounds.length()) {
 957       // Process only if it is an access indexed instruction
 958       AccessIndexed *ai = cur-&gt;as_AccessIndexed();
 959       if (ai != NULL) {
 960         process_access_indexed(loop_header, block, ai);
 961         accessIndexed.append(ai);
 962         if (!arrays.contains(ai-&gt;array())) {
 963           arrays.append(ai-&gt;array());
 964         }
 965         Bound *b = get_bound(ai-&gt;index());
 966         if (!b-&gt;lower_instr()) {
 967           // Lower bound is constant
 968           update_bound(pushed, ai-&gt;index(), Instruction::geq, NULL, 0);
 969         }
 970         if (!b-&gt;has_upper()) {
 971           if (ai-&gt;length() &amp;&amp; ai-&gt;length()-&gt;type()-&gt;as_IntConstant()) {
 972             int value = ai-&gt;length()-&gt;type()-&gt;as_IntConstant()-&gt;value();
 973             update_bound(pushed, ai-&gt;index(), Instruction::lss, NULL, value);
 974           } else {
 975             // Has no upper bound
 976             Instruction *instr = ai-&gt;length();
 977             if (instr != NULL) instr = ai-&gt;array();
 978             update_bound(pushed, ai-&gt;index(), Instruction::lss, instr, 0);
 979           }
 980         }
 981       }
 982     }
 983     cur = cur-&gt;next();
 984   }
 985 
 986   // Output current condition stack
 987   TRACE_RANGE_CHECK_ELIMINATION(dump_condition_stack(block));
 988 
 989   // Do in block motion of range checks
 990   in_block_motion(block, accessIndexed, arrays);
 991 
 992   // Call all dominated blocks
 993   for (int i=0; i&lt;block-&gt;dominates()-&gt;length(); i++) {
 994     BlockBegin *next = block-&gt;dominates()-&gt;at(i);
 995     if (!next-&gt;is_set(BlockBegin::donot_eliminate_range_checks)) {
 996       // if current block is a loop header and:
 997       // - next block belongs to the same loop
 998       // or
 999       // - next block belongs to an inner loop
1000       // then current block is the loop header for next block
1001       if (block-&gt;is_set(BlockBegin::linear_scan_loop_header_flag) &amp;&amp; (block-&gt;loop_index() == next-&gt;loop_index() || next-&gt;loop_depth() &gt; block-&gt;loop_depth())) {
1002         calc_bounds(next, block);
1003       } else {
1004         calc_bounds(next, loop_header);
1005       }
1006     }
1007   }
1008 
1009   // Reset stack
1010   for (int i=0; i&lt;pushed.length(); i++) {
1011     _bounds.at(pushed.at(i))-&gt;pop();
1012   }
1013 }
1014 
1015 #ifndef PRODUCT
1016 // Dump condition stack
1017 void RangeCheckEliminator::dump_condition_stack(BlockBegin *block) {
1018   for (int i=0; i&lt;_ir-&gt;linear_scan_order()-&gt;length(); i++) {
1019     BlockBegin *cur_block = _ir-&gt;linear_scan_order()-&gt;at(i);
1020     Instruction *instr = cur_block;
1021     for_each_phi_fun(cur_block, phi,
1022                      BoundStack *bound_stack = _bounds.at(phi-&gt;id());
1023                      if (bound_stack &amp;&amp; bound_stack-&gt;length() &gt; 0) {
1024                        Bound *bound = bound_stack-&gt;top();
1025                        if ((bound-&gt;has_lower() || bound-&gt;has_upper()) &amp;&amp; (bound-&gt;lower_instr() != phi || bound-&gt;upper_instr() != phi || bound-&gt;lower() != 0 || bound-&gt;upper() != 0)) {
1026                            TRACE_RANGE_CHECK_ELIMINATION(tty-&gt;fill_to(2*block-&gt;dominator_depth());
1027                                                          tty-&gt;print(&quot;i%d&quot;, phi-&gt;id());
1028                                                          tty-&gt;print(&quot;: &quot;);
1029                                                          bound-&gt;print();
1030                                                          tty-&gt;cr();
1031                            );
1032                          }
1033                      });
1034 
1035     while (!instr-&gt;as_BlockEnd()) {
1036       if (instr-&gt;id() &lt; _bounds.length()) {
1037         BoundStack *bound_stack = _bounds.at(instr-&gt;id());
1038         if (bound_stack &amp;&amp; bound_stack-&gt;length() &gt; 0) {
1039           Bound *bound = bound_stack-&gt;top();
1040           if ((bound-&gt;has_lower() || bound-&gt;has_upper()) &amp;&amp; (bound-&gt;lower_instr() != instr || bound-&gt;upper_instr() != instr || bound-&gt;lower() != 0 || bound-&gt;upper() != 0)) {
1041               TRACE_RANGE_CHECK_ELIMINATION(tty-&gt;fill_to(2*block-&gt;dominator_depth());
1042                                             tty-&gt;print(&quot;i%d&quot;, instr-&gt;id());
1043                                             tty-&gt;print(&quot;: &quot;);
1044                                             bound-&gt;print();
1045                                             tty-&gt;cr();
1046               );
1047           }
1048         }
1049       }
1050       instr = instr-&gt;next();
1051     }
1052   }
1053 }
1054 #endif
1055 
1056 #ifdef ASSERT
1057 // Verification or the IR
1058 RangeCheckEliminator::Verification::Verification(IR *ir) : _used(BlockBegin::number_of_blocks(), BlockBegin::number_of_blocks(), false) {
1059   this-&gt;_ir = ir;
1060   ir-&gt;iterate_linear_scan_order(this);
1061 }
1062 
1063 // Verify this block
1064 void RangeCheckEliminator::Verification::block_do(BlockBegin *block) {
1065   If *cond = block-&gt;end()-&gt;as_If();
1066   // Watch out: tsux and fsux can be the same!
1067   if (block-&gt;number_of_sux() &gt; 1) {
1068     for (int i=0; i&lt;block-&gt;number_of_sux(); i++) {
1069       BlockBegin *sux = block-&gt;sux_at(i);
1070       BlockBegin *pred = NULL;
1071       for (int j=0; j&lt;sux-&gt;number_of_preds(); j++) {
1072         BlockBegin *cur = sux-&gt;pred_at(j);
1073         assert(cur != NULL, &quot;Predecessor must not be null&quot;);
1074         if (!pred) {
1075           pred = cur;
1076         }
1077         assert(cur == pred, &quot;Block must not have more than one predecessor if its predecessor has more than one successor&quot;);
1078       }
1079       assert(sux-&gt;number_of_preds() &gt;= 1, &quot;Block must have at least one predecessor&quot;);
1080       assert(sux-&gt;pred_at(0) == block, &quot;Wrong successor&quot;);
1081     }
1082   }
1083 
1084   BlockBegin *dominator = block-&gt;dominator();
1085   if (dominator) {
1086     assert(block != _ir-&gt;start(), &quot;Start block must not have a dominator!&quot;);
1087     assert(can_reach(dominator, block), &quot;Dominator can&#39;t reach his block !&quot;);
1088     assert(can_reach(_ir-&gt;start(), dominator), &quot;Dominator is unreachable !&quot;);
1089     assert(!can_reach(_ir-&gt;start(), block, dominator), &quot;Wrong dominator ! Block can be reached anyway !&quot;);
1090     BlockList *all_blocks = _ir-&gt;linear_scan_order();
1091     for (int i=0; i&lt;all_blocks-&gt;length(); i++) {
1092       BlockBegin *cur = all_blocks-&gt;at(i);
1093       if (cur != dominator &amp;&amp; cur != block) {
1094         assert(can_reach(dominator, block, cur), &quot;There has to be another dominator!&quot;);
1095       }
1096     }
1097   } else {
1098     assert(block == _ir-&gt;start(), &quot;Only start block must not have a dominator&quot;);
1099   }
1100 
1101   if (block-&gt;is_set(BlockBegin::linear_scan_loop_header_flag)) {
1102     int loop_index = block-&gt;loop_index();
1103     BlockList *all_blocks = _ir-&gt;linear_scan_order();
1104     assert(block-&gt;number_of_preds() &gt;= 1, &quot;Block must have at least one predecessor&quot;);
1105     assert(!block-&gt;is_set(BlockBegin::exception_entry_flag), &quot;Loop header must not be exception handler!&quot;);
1106 
1107     bool loop_through_xhandler = false;
1108     for (int i=0; i&lt;block-&gt;number_of_sux(); i++) {
1109       BlockBegin *sux = block-&gt;sux_at(i);
1110       if (!loop_through_xhandler) {
1111         if (sux-&gt;loop_depth() == block-&gt;loop_depth() &amp;&amp; sux-&gt;loop_index() != block-&gt;loop_index()) {
1112           loop_through_xhandler = is_backbranch_from_xhandler(block);
1113           assert(loop_through_xhandler, &quot;Loop indices have to be the same if same depths but no backbranch from xhandler&quot;);
1114         }
1115       }
1116       assert(sux-&gt;loop_depth() == block-&gt;loop_depth() || sux-&gt;loop_index() != block-&gt;loop_index(), &quot;Loop index has to be different&quot;);
1117     }
1118 
1119     for (int i=0; i&lt;all_blocks-&gt;length(); i++) {
1120       BlockBegin *cur = all_blocks-&gt;at(i);
1121       if (cur-&gt;loop_index() == loop_index &amp;&amp; cur != block) {
1122         assert(dominates(block-&gt;dominator(), cur), &quot;Dominator of loop header must dominate all loop blocks&quot;);
1123       }
1124     }
1125   }
1126 
1127   Instruction *cur = block;
1128   while (cur) {
1129     assert(cur-&gt;block() == block, &quot;Block begin has to be set correctly!&quot;);
1130     cur = cur-&gt;next();
1131   }
1132 }
1133 
1134 // Called when a successor of a block has the same loop depth but a different loop index. This can happen if a backbranch comes from
1135 // an exception handler of a loop head block, for example, when a loop is only executed once on the non-exceptional path but is
1136 // repeated in case of an exception. In this case, the edge block-&gt;sux is not critical and was not split before.
1137 // Check if there is such a backbranch from an xhandler of &#39;block&#39;.
1138 bool RangeCheckEliminator::Verification::is_backbranch_from_xhandler(BlockBegin* block) {
1139   for (int i = 0; i &lt; block-&gt;number_of_exception_handlers(); i++) {
1140     BlockBegin *xhandler = block-&gt;exception_handler_at(i);
1141     for (int j = 0; j &lt; block-&gt;number_of_preds(); j++) {
1142       if (dominates(xhandler, block-&gt;pred_at(j)) || xhandler == block-&gt;pred_at(j)) {
1143         return true;
1144       }
1145     }
1146   }
1147 
1148   // In case of nested xhandlers, we need to walk through the loop (and all blocks belonging to exception handlers)
1149   // to find an xhandler of &#39;block&#39;.
1150   if (block-&gt;number_of_exception_handlers() &gt; 0) {
1151     for (int i = 0; i &lt; block-&gt;number_of_preds(); i++) {
1152       BlockBegin* pred = block-&gt;pred_at(i);
1153       if (pred-&gt;loop_index() == block-&gt;loop_index()) {
1154         // Only check blocks that belong to the loop
1155         // Do a BFS to find an xhandler block of &#39;block&#39; starting from &#39;pred&#39;
1156         ResourceMark rm;
1157         ResourceBitMap visited(BlockBegin::number_of_blocks());
1158         BlockBeginList list;
1159         list.push(pred);
1160         while (!list.is_empty()) {
1161           BlockBegin* next = list.pop();
1162           if (!visited.at(next-&gt;block_id())) {
1163             visited.set_bit(next-&gt;block_id());
1164             for (int j = 0; j &lt; block-&gt;number_of_exception_handlers(); j++) {
1165                if (next == block-&gt;exception_handler_at(j)) {
1166                  return true;
1167                }
1168             }
1169             for (int j = 0; j &lt; next-&gt;number_of_preds(); j++) {
1170                if (next-&gt;pred_at(j) != block) {
1171                  list.push(next-&gt;pred_at(j));
1172                }
1173             }
1174           }
1175         }
1176       }
1177     }
1178   }
1179   return false;
1180 }
1181 
1182 // Loop header must dominate all loop blocks
1183 bool RangeCheckEliminator::Verification::dominates(BlockBegin *dominator, BlockBegin *block) {
1184   BlockBegin *cur = block-&gt;dominator();
1185   while (cur &amp;&amp; cur != dominator) {
1186     cur = cur-&gt;dominator();
1187   }
1188   return cur == dominator;
1189 }
1190 
1191 // Try to reach Block end beginning in Block start and not using Block dont_use
1192 bool RangeCheckEliminator::Verification::can_reach(BlockBegin *start, BlockBegin *end, BlockBegin *dont_use /* = NULL */) {
1193   if (start == end) return start != dont_use;
1194   // Simple BSF from start to end
1195   //  BlockBeginList _current;
1196   for (int i=0; i &lt; _used.length(); i++) {
1197     _used.at_put(i, false);
1198   }
1199   _current.trunc_to(0);
1200   _successors.trunc_to(0);
1201   if (start != dont_use) {
1202     _current.push(start);
1203     _used.at_put(start-&gt;block_id(), true);
1204   }
1205 
1206   //  BlockBeginList _successors;
1207   while (_current.length() &gt; 0) {
1208     BlockBegin *cur = _current.pop();
1209     // Add exception handlers to list
1210     for (int i=0; i&lt;cur-&gt;number_of_exception_handlers(); i++) {
1211       BlockBegin *xhandler = cur-&gt;exception_handler_at(i);
1212       _successors.push(xhandler);
1213       // Add exception handlers of _successors to list
1214       for (int j=0; j&lt;xhandler-&gt;number_of_exception_handlers(); j++) {
1215         BlockBegin *sux_xhandler = xhandler-&gt;exception_handler_at(j);
1216         _successors.push(sux_xhandler);
1217       }
1218     }
1219     // Add normal _successors to list
1220     for (int i=0; i&lt;cur-&gt;number_of_sux(); i++) {
1221       BlockBegin *sux = cur-&gt;sux_at(i);
1222       _successors.push(sux);
1223       // Add exception handlers of _successors to list
1224       for (int j=0; j&lt;sux-&gt;number_of_exception_handlers(); j++) {
1225         BlockBegin *xhandler = sux-&gt;exception_handler_at(j);
1226         _successors.push(xhandler);
1227       }
1228     }
1229     for (int i=0; i&lt;_successors.length(); i++) {
1230       BlockBegin *sux = _successors.at(i);
1231       assert(sux != NULL, &quot;Successor must not be NULL!&quot;);
1232       if (sux == end) {
1233         return true;
1234       }
1235       if (sux != dont_use &amp;&amp; !_used.at(sux-&gt;block_id())) {
1236         _used.at_put(sux-&gt;block_id(), true);
1237         _current.push(sux);
1238       }
1239     }
1240     _successors.trunc_to(0);
1241   }
1242 
1243   return false;
1244 }
1245 #endif // ASSERT
1246 
1247 // Bound
1248 RangeCheckEliminator::Bound::~Bound() {
1249 }
1250 
1251 // Bound constructor
1252 RangeCheckEliminator::Bound::Bound() {
1253   init();
1254   this-&gt;_lower = min_jint;
1255   this-&gt;_upper = max_jint;
1256   this-&gt;_lower_instr = NULL;
1257   this-&gt;_upper_instr = NULL;
1258 }
1259 
1260 // Bound constructor
1261 RangeCheckEliminator::Bound::Bound(int lower, Value lower_instr, int upper, Value upper_instr) {
1262   init();
1263   assert(!lower_instr || !lower_instr-&gt;as_Constant() || !lower_instr-&gt;type()-&gt;as_IntConstant(), &quot;Must not be constant!&quot;);
1264   assert(!upper_instr || !upper_instr-&gt;as_Constant() || !upper_instr-&gt;type()-&gt;as_IntConstant(), &quot;Must not be constant!&quot;);
1265   this-&gt;_lower = lower;
1266   this-&gt;_upper = upper;
1267   this-&gt;_lower_instr = lower_instr;
1268   this-&gt;_upper_instr = upper_instr;
1269 }
1270 
1271 // Bound constructor
1272 RangeCheckEliminator::Bound::Bound(Instruction::Condition cond, Value v, int constant) {
1273   assert(!v || (v-&gt;type() &amp;&amp; (v-&gt;type()-&gt;as_IntType() || v-&gt;type()-&gt;as_ObjectType())), &quot;Type must be array or integer!&quot;);
1274   assert(!v || !v-&gt;as_Constant() || !v-&gt;type()-&gt;as_IntConstant(), &quot;Must not be constant!&quot;);
1275 
1276   init();
1277   if (cond == Instruction::eql) {
1278     _lower = constant;
1279     _lower_instr = v;
1280     _upper = constant;
1281     _upper_instr = v;
1282   } else if (cond == Instruction::neq) {
1283     _lower = min_jint;
1284     _upper = max_jint;
1285     _lower_instr = NULL;
1286     _upper_instr = NULL;
1287     if (v == NULL) {
1288       if (constant == min_jint) {
1289         _lower++;
1290       }
1291       if (constant == max_jint) {
1292         _upper--;
1293       }
1294     }
1295   } else if (cond == Instruction::geq) {
1296     _lower = constant;
1297     _lower_instr = v;
1298     _upper = max_jint;
1299     _upper_instr = NULL;
1300   } else if (cond == Instruction::leq) {
1301     _lower = min_jint;
1302     _lower_instr = NULL;
1303     _upper = constant;
1304     _upper_instr = v;
1305   } else {
1306     ShouldNotReachHere();
1307   }
1308 }
1309 
1310 // Set lower
1311 void RangeCheckEliminator::Bound::set_lower(int value, Value v) {
1312   assert(!v || !v-&gt;as_Constant() || !v-&gt;type()-&gt;as_IntConstant(), &quot;Must not be constant!&quot;);
1313   this-&gt;_lower = value;
1314   this-&gt;_lower_instr = v;
1315 }
1316 
1317 // Set upper
1318 void RangeCheckEliminator::Bound::set_upper(int value, Value v) {
1319   assert(!v || !v-&gt;as_Constant() || !v-&gt;type()-&gt;as_IntConstant(), &quot;Must not be constant!&quot;);
1320   this-&gt;_upper = value;
1321   this-&gt;_upper_instr = v;
1322 }
1323 
1324 // Add constant -&gt; no overflow may occur
1325 void RangeCheckEliminator::Bound::add_constant(int value) {
1326   this-&gt;_lower += value;
1327   this-&gt;_upper += value;
1328 }
1329 
1330 // Init
1331 void RangeCheckEliminator::Bound::init() {
1332 }
1333 
1334 // or
1335 void RangeCheckEliminator::Bound::or_op(Bound *b) {
1336   // Watch out, bound is not guaranteed not to overflow!
1337   // Update lower bound
1338   if (_lower_instr != b-&gt;_lower_instr || (_lower_instr &amp;&amp; _lower != b-&gt;_lower)) {
1339     _lower_instr = NULL;
1340     _lower = min_jint;
1341   } else {
1342     _lower = MIN2(_lower, b-&gt;_lower);
1343   }
1344   // Update upper bound
1345   if (_upper_instr != b-&gt;_upper_instr || (_upper_instr &amp;&amp; _upper != b-&gt;_upper)) {
1346     _upper_instr = NULL;
1347     _upper = max_jint;
1348   } else {
1349     _upper = MAX2(_upper, b-&gt;_upper);
1350   }
1351 }
1352 
1353 // and
1354 void RangeCheckEliminator::Bound::and_op(Bound *b) {
1355   // Update lower bound
1356   if (_lower_instr == b-&gt;_lower_instr) {
1357     _lower = MAX2(_lower, b-&gt;_lower);
1358   }
1359   if (b-&gt;has_lower()) {
1360     bool set = true;
1361     if (_lower_instr != NULL &amp;&amp; b-&gt;_lower_instr != NULL) {
1362       set = (_lower_instr-&gt;dominator_depth() &gt; b-&gt;_lower_instr-&gt;dominator_depth());
1363     }
1364     if (set) {
1365       _lower = b-&gt;_lower;
1366       _lower_instr = b-&gt;_lower_instr;
1367     }
1368   }
1369   // Update upper bound
1370   if (_upper_instr == b-&gt;_upper_instr) {
1371     _upper = MIN2(_upper, b-&gt;_upper);
1372   }
1373   if (b-&gt;has_upper()) {
1374     bool set = true;
1375     if (_upper_instr != NULL &amp;&amp; b-&gt;_upper_instr != NULL) {
1376       set = (_upper_instr-&gt;dominator_depth() &gt; b-&gt;_upper_instr-&gt;dominator_depth());
1377     }
1378     if (set) {
1379       _upper = b-&gt;_upper;
1380       _upper_instr = b-&gt;_upper_instr;
1381     }
1382   }
1383 }
1384 
1385 // has_upper
1386 bool RangeCheckEliminator::Bound::has_upper() {
1387   return _upper_instr != NULL || _upper &lt; max_jint;
1388 }
1389 
1390 // is_smaller
1391 bool RangeCheckEliminator::Bound::is_smaller(Bound *b) {
1392   if (b-&gt;_lower_instr != _upper_instr) {
1393     return false;
1394   }
1395   return _upper &lt; b-&gt;_lower;
1396 }
1397 
1398 // has_lower
1399 bool RangeCheckEliminator::Bound::has_lower() {
1400   return _lower_instr != NULL || _lower &gt; min_jint;
1401 }
1402 
1403 // in_array_bound
1404 bool RangeCheckEliminator::in_array_bound(Bound *bound, Value array){
1405   if (!bound) return false;
1406   assert(array != NULL, &quot;Must not be null!&quot;);
1407   assert(bound != NULL, &quot;Must not be null!&quot;);
1408   if (bound-&gt;lower() &gt;=0 &amp;&amp; bound-&gt;lower_instr() == NULL &amp;&amp; bound-&gt;upper() &lt; 0 &amp;&amp; bound-&gt;upper_instr() != NULL) {
1409     ArrayLength *len = bound-&gt;upper_instr()-&gt;as_ArrayLength();
1410     if (bound-&gt;upper_instr() == array || (len != NULL &amp;&amp; len-&gt;array() == array)) {
1411       return true;
1412     }
1413   }
1414   return false;
1415 }
1416 
1417 // remove_lower
1418 void RangeCheckEliminator::Bound::remove_lower() {
1419   _lower = min_jint;
1420   _lower_instr = NULL;
1421 }
1422 
1423 // remove_upper
1424 void RangeCheckEliminator::Bound::remove_upper() {
1425   _upper = max_jint;
1426   _upper_instr = NULL;
1427 }
1428 
1429 // upper
1430 int RangeCheckEliminator::Bound::upper() {
1431   return _upper;
1432 }
1433 
1434 // lower
1435 int RangeCheckEliminator::Bound::lower() {
1436   return _lower;
1437 }
1438 
1439 // upper_instr
1440 Value RangeCheckEliminator::Bound::upper_instr() {
1441   return _upper_instr;
1442 }
1443 
1444 // lower_instr
1445 Value RangeCheckEliminator::Bound::lower_instr() {
1446   return _lower_instr;
1447 }
1448 
1449 // print
1450 void RangeCheckEliminator::Bound::print() {
1451   tty-&gt;print(&quot;%s&quot;, &quot;&quot;);
1452   if (this-&gt;_lower_instr || this-&gt;_lower != min_jint) {
1453     if (this-&gt;_lower_instr) {
1454       tty-&gt;print(&quot;i%d&quot;, this-&gt;_lower_instr-&gt;id());
1455       if (this-&gt;_lower &gt; 0) {
1456         tty-&gt;print(&quot;+%d&quot;, _lower);
1457       }
1458       if (this-&gt;_lower &lt; 0) {
1459         tty-&gt;print(&quot;%d&quot;, _lower);
1460       }
1461     } else {
1462       tty-&gt;print(&quot;%d&quot;, _lower);
1463     }
1464     tty-&gt;print(&quot; &lt;= &quot;);
1465   }
1466   tty-&gt;print(&quot;x&quot;);
1467   if (this-&gt;_upper_instr || this-&gt;_upper != max_jint) {
1468     tty-&gt;print(&quot; &lt;= &quot;);
1469     if (this-&gt;_upper_instr) {
1470       tty-&gt;print(&quot;i%d&quot;, this-&gt;_upper_instr-&gt;id());
1471       if (this-&gt;_upper &gt; 0) {
1472         tty-&gt;print(&quot;+%d&quot;, _upper);
1473       }
1474       if (this-&gt;_upper &lt; 0) {
1475         tty-&gt;print(&quot;%d&quot;, _upper);
1476       }
1477     } else {
1478       tty-&gt;print(&quot;%d&quot;, _upper);
1479     }
1480   }
1481 }
1482 
1483 // Copy
1484 RangeCheckEliminator::Bound *RangeCheckEliminator::Bound::copy() {
1485   Bound *b = new Bound();
1486   b-&gt;_lower = _lower;
1487   b-&gt;_lower_instr = _lower_instr;
1488   b-&gt;_upper = _upper;
1489   b-&gt;_upper_instr = _upper_instr;
1490   return b;
1491 }
1492 
1493 #ifdef ASSERT
1494 // Add assertion
1495 void RangeCheckEliminator::Bound::add_assertion(Instruction *instruction, Instruction *position, int i, Value instr, Instruction::Condition cond) {
1496   Instruction *result = position;
1497   Instruction *compare_with = NULL;
1498   ValueStack *state = position-&gt;state_before();
1499   if (position-&gt;as_BlockEnd() &amp;&amp; !position-&gt;as_Goto()) {
1500     state = position-&gt;as_BlockEnd()-&gt;state_before();
1501   }
1502   Instruction *instruction_before = position-&gt;prev();
1503   if (position-&gt;as_Return() &amp;&amp; Compilation::current()-&gt;method()-&gt;is_synchronized() &amp;&amp; instruction_before-&gt;as_MonitorExit()) {
1504     instruction_before = instruction_before-&gt;prev();
1505   }
1506   result = instruction_before;
1507   // Load constant only if needed
1508   Constant *constant = NULL;
1509   if (i != 0 || !instr) {
1510     constant = new Constant(new IntConstant(i));
1511     NOT_PRODUCT(constant-&gt;set_printable_bci(position-&gt;printable_bci()));
1512     result = result-&gt;insert_after(constant);
1513     compare_with = constant;
1514   }
1515 
1516   if (instr) {
1517     assert(instr-&gt;type()-&gt;as_ObjectType() || instr-&gt;type()-&gt;as_IntType(), &quot;Type must be array or integer!&quot;);
1518     compare_with = instr;
1519     // Load array length if necessary
1520     Instruction *op = instr;
1521     if (instr-&gt;type()-&gt;as_ObjectType()) {
1522       assert(state, &quot;must not be null&quot;);
1523       ArrayLength *length = new ArrayLength(instr, state-&gt;copy());
1524       NOT_PRODUCT(length-&gt;set_printable_bci(position-&gt;printable_bci()));
1525       length-&gt;set_exception_state(length-&gt;state_before());
1526       result = result-&gt;insert_after(length);
1527       op = length;
1528       compare_with = length;
1529     }
1530     // Add operation only if necessary
1531     if (constant) {
1532       ArithmeticOp *ao = new ArithmeticOp(Bytecodes::_iadd, constant, op, false, NULL);
1533       NOT_PRODUCT(ao-&gt;set_printable_bci(position-&gt;printable_bci()));
1534       result = result-&gt;insert_after(ao);
1535       compare_with = ao;
1536       // TODO: Check that add operation does not overflow!
1537     }
1538   }
1539   assert(compare_with != NULL, &quot;You have to compare with something!&quot;);
1540   assert(instruction != NULL, &quot;Instruction must not be null!&quot;);
1541 
1542   if (instruction-&gt;type()-&gt;as_ObjectType()) {
1543     // Load array length if necessary
1544     Instruction *op = instruction;
1545     assert(state, &quot;must not be null&quot;);
1546     ArrayLength *length = new ArrayLength(instruction, state-&gt;copy());
1547     length-&gt;set_exception_state(length-&gt;state_before());
1548     NOT_PRODUCT(length-&gt;set_printable_bci(position-&gt;printable_bci()));
1549     result = result-&gt;insert_after(length);
1550     instruction = length;
1551   }
1552 
1553   Assert *assert = new Assert(instruction, cond, false, compare_with);
1554   NOT_PRODUCT(assert-&gt;set_printable_bci(position-&gt;printable_bci()));
1555   result-&gt;insert_after(assert);
1556 }
1557 
1558 // Add assertions
1559 void RangeCheckEliminator::add_assertions(Bound *bound, Instruction *instruction, Instruction *position) {
1560   // Add lower bound assertion
1561   if (bound-&gt;has_lower()) {
1562     bound-&gt;add_assertion(instruction, position, bound-&gt;lower(), bound-&gt;lower_instr(), Instruction::geq);
1563   }
1564   // Add upper bound assertion
1565   if (bound-&gt;has_upper()) {
1566     bound-&gt;add_assertion(instruction, position, bound-&gt;upper(), bound-&gt;upper_instr(), Instruction::leq);
1567   }
1568 }
1569 #endif
1570 
    </pre>
  </body>
</html>
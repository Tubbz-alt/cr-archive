<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jni.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../opto/vectornode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvm.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jni.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;jni.h&quot;
  28 #include &quot;jvm.h&quot;
  29 #include &quot;ci/ciReplay.hpp&quot;
  30 #include &quot;classfile/altHashing.hpp&quot;
  31 #include &quot;classfile/classFileStream.hpp&quot;
  32 #include &quot;classfile/classLoader.hpp&quot;
  33 #include &quot;classfile/javaClasses.hpp&quot;
  34 #include &quot;classfile/javaClasses.inline.hpp&quot;

  35 #include &quot;classfile/modules.hpp&quot;
  36 #include &quot;classfile/symbolTable.hpp&quot;
  37 #include &quot;classfile/systemDictionary.hpp&quot;
  38 #include &quot;classfile/vmSymbols.hpp&quot;
  39 #include &quot;gc/shared/gcLocker.inline.hpp&quot;
  40 #include &quot;interpreter/linkResolver.hpp&quot;
  41 #include &quot;jfr/jfrEvents.hpp&quot;
  42 #include &quot;jfr/support/jfrThreadId.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;memory/allocation.hpp&quot;
  45 #include &quot;memory/allocation.inline.hpp&quot;
  46 #include &quot;memory/oopFactory.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/access.inline.hpp&quot;
  50 #include &quot;oops/arrayOop.inline.hpp&quot;
  51 #include &quot;oops/instanceKlass.hpp&quot;
  52 #include &quot;oops/instanceOop.hpp&quot;
  53 #include &quot;oops/markWord.hpp&quot;
  54 #include &quot;oops/method.hpp&quot;
</pre>
<hr />
<pre>
 380   }
 381   if ((int)strlen(name) &gt; Symbol::max_length()) {
 382     Exceptions::fthrow(THREAD_AND_LOCATION,
 383                        vmSymbols::java_lang_NoClassDefFoundError(),
 384                        &quot;Class name exceeds maximum length of %d: %s&quot;,
 385                        Symbol::max_length(),
 386                        name);
 387     return 0;
 388   }
 389 
 390   //%note jni_3
 391   Handle protection_domain;
 392   // Find calling class
 393   Klass* k = thread-&gt;security_get_caller_class(0);
 394   // default to the system loader when no context
 395   Handle loader(THREAD, SystemDictionary::java_system_loader());
 396   if (k != NULL) {
 397     // Special handling to make sure JNI_OnLoad and JNI_OnUnload are executed
 398     // in the correct class context.
 399     if (k-&gt;class_loader() == NULL &amp;&amp;
<span class="line-modified"> 400         k-&gt;name() == vmSymbols::java_lang_ClassLoader_NativeLibrary()) {</span>
 401       JavaValue result(T_OBJECT);
 402       JavaCalls::call_static(&amp;result, k,
 403                              vmSymbols::getFromClass_name(),
 404                              vmSymbols::void_class_signature(),
 405                              CHECK_NULL);
<span class="line-modified"> 406       // When invoked from JNI_OnLoad, NativeLibrary::getFromClass returns</span>
 407       // a non-NULL Class object.  When invoked from JNI_OnUnload,
 408       // it will return NULL to indicate no context.
 409       oop mirror = (oop) result.get_jobject();
 410       if (mirror != NULL) {
 411         Klass* fromClass = java_lang_Class::as_Klass(mirror);
 412         loader = Handle(THREAD, fromClass-&gt;class_loader());
 413         protection_domain = Handle(THREAD, fromClass-&gt;protection_domain());
 414       }
 415     } else {
 416       loader = Handle(THREAD, k-&gt;class_loader());
 417     }
 418   }
 419 
 420   TempNewSymbol sym = SymbolTable::new_symbol(name);
 421   result = find_class_from_class_loader(env, sym, true, loader,
 422                                         protection_domain, true, thread);
 423 
 424   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 425     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
 426   }
</pre>
<hr />
<pre>
2523     ss.print(&quot;Index %d out of bounds for length %d&quot;, index, a-&gt;length());
2524     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2525   }
2526 JNI_END
2527 
2528 
2529 
2530 #define DEFINE_NEWSCALARARRAY(Return,Allocator,Result \
2531                               ,EntryProbe,ReturnProbe)  \
2532 \
2533   DT_RETURN_MARK_DECL(New##Result##Array, Return \
2534                       , ReturnProbe); \
2535 \
2536 JNI_ENTRY(Return, \
2537           jni_New##Result##Array(JNIEnv *env, jsize len)) \
2538   JNIWrapper(&quot;New&quot; XSTR(Result) &quot;Array&quot;); \
2539   EntryProbe; \
2540   Return ret = NULL;\
2541   DT_RETURN_MARK(New##Result##Array, Return, (const Return&amp;)ret);\
2542 \
<span class="line-modified">2543   oop obj= oopFactory::Allocator(len, CHECK_0); \</span>
2544   ret = (Return) JNIHandles::make_local(env, obj); \
2545   return ret;\
2546 JNI_END
2547 
2548 DEFINE_NEWSCALARARRAY(jbooleanArray, new_boolArray,   Boolean,
2549                       HOTSPOT_JNI_NEWBOOLEANARRAY_ENTRY(env, len),
2550                       HOTSPOT_JNI_NEWBOOLEANARRAY_RETURN(_ret_ref))
2551 DEFINE_NEWSCALARARRAY(jbyteArray,    new_byteArray,   Byte,
2552                       HOTSPOT_JNI_NEWBYTEARRAY_ENTRY(env, len),
2553                       HOTSPOT_JNI_NEWBYTEARRAY_RETURN(_ret_ref))
2554 DEFINE_NEWSCALARARRAY(jshortArray,   new_shortArray,  Short,
2555                       HOTSPOT_JNI_NEWSHORTARRAY_ENTRY(env, len),
2556                       HOTSPOT_JNI_NEWSHORTARRAY_RETURN(_ret_ref))
2557 DEFINE_NEWSCALARARRAY(jcharArray,    new_charArray,   Char,
2558                       HOTSPOT_JNI_NEWCHARARRAY_ENTRY(env, len),
2559                       HOTSPOT_JNI_NEWCHARARRAY_RETURN(_ret_ref))
2560 DEFINE_NEWSCALARARRAY(jintArray,     new_intArray,    Int,
2561                       HOTSPOT_JNI_NEWINTARRAY_ENTRY(env, len),
2562                       HOTSPOT_JNI_NEWINTARRAY_RETURN(_ret_ref))
2563 DEFINE_NEWSCALARARRAY(jlongArray,    new_longArray,   Long,
</pre>
<hr />
<pre>
2794                             , HOTSPOT_JNI_SETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
2795                             HOTSPOT_JNI_SETFLOATARRAYREGION_RETURN())
2796 DEFINE_SETSCALARARRAYREGION(T_DOUBLE,  jdouble,  Double,  double
2797                             , HOTSPOT_JNI_SETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
2798                             HOTSPOT_JNI_SETDOUBLEARRAYREGION_RETURN())
2799 
2800 
2801 DT_RETURN_MARK_DECL(RegisterNatives, jint
2802                     , HOTSPOT_JNI_REGISTERNATIVES_RETURN(_ret_ref));
2803 
2804 JNI_ENTRY(jint, jni_RegisterNatives(JNIEnv *env, jclass clazz,
2805                                     const JNINativeMethod *methods,
2806                                     jint nMethods))
2807   JNIWrapper(&quot;RegisterNatives&quot;);
2808   HOTSPOT_JNI_REGISTERNATIVES_ENTRY(env, clazz, (void *) methods, nMethods);
2809   jint ret = 0;
2810   DT_RETURN_MARK(RegisterNatives, jint, (const jint&amp;)ret);
2811 
2812   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2813 
<span class="line-modified">2814   // There are no restrictions on native code registering native methods, which</span>
<span class="line-modified">2815   // allows agents to redefine the bindings to native methods. But we issue a</span>
<span class="line-modified">2816   // warning if any code running outside of the boot/platform loader is rebinding</span>
<span class="line-modified">2817   // any native methods in classes loaded by the boot/platform loader.</span>
<span class="line-modified">2818   Klass* caller = thread-&gt;security_get_caller_class(1);</span>

2819   bool do_warning = false;
<span class="line-modified">2820   oop cl = k-&gt;class_loader();</span>
<span class="line-modified">2821   if (cl ==  NULL || SystemDictionary::is_platform_class_loader(cl)) {</span>
<span class="line-modified">2822     // If no caller class, or caller class has a different loader, then</span>
<span class="line-modified">2823     // issue a warning below.</span>
<span class="line-modified">2824     do_warning = (caller == NULL) || caller-&gt;class_loader() != cl;</span>








2825   }
2826 
2827 
2828   for (int index = 0; index &lt; nMethods; index++) {
2829     const char* meth_name = methods[index].name;
2830     const char* meth_sig = methods[index].signature;
2831     int meth_name_len = (int)strlen(meth_name);
2832 
2833     // The class should have been loaded (we have an instance of the class
2834     // passed in) so the method and signature should already be in the symbol
2835     // table.  If they&#39;re not there, the method doesn&#39;t exist.
2836     TempNewSymbol  name = SymbolTable::probe(meth_name, meth_name_len);
2837     TempNewSymbol  signature = SymbolTable::probe(meth_sig, (int)strlen(meth_sig));
2838 
2839     if (name == NULL || signature == NULL) {
2840       ResourceMark rm(THREAD);
2841       stringStream st;
2842       st.print(&quot;Method %s.%s%s not found&quot;, k-&gt;external_name(), meth_name, meth_sig);
2843       // Must return negative value on failure
2844       THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), -1);
</pre>
<hr />
<pre>
3642 }
3643 
3644 // Returns the function structure
3645 struct JNINativeInterface_* jni_functions() {
3646 #if INCLUDE_JNI_CHECK
3647   if (CheckJNICalls) return jni_functions_check();
3648 #endif // INCLUDE_JNI_CHECK
3649   return &amp;jni_NativeInterface;
3650 }
3651 
3652 // Returns the function structure
3653 struct JNINativeInterface_* jni_functions_nocheck() {
3654   return &amp;jni_NativeInterface;
3655 }
3656 
3657 static void post_thread_start_event(const JavaThread* jt) {
3658   assert(jt != NULL, &quot;invariant&quot;);
3659   EventThreadStart event;
3660   if (event.should_commit()) {
3661     event.set_thread(JFR_THREAD_ID(jt));
<span class="line-modified">3662     event.commit();</span>










3663   }
3664 }
3665 
3666 // Invocation API
3667 
3668 
3669 // Forward declaration
3670 extern const struct JNIInvokeInterface_ jni_InvokeInterface;
3671 
3672 // Global invocation API vars
3673 volatile int vm_created = 0;
<span class="line-modified">3674 // Indicate whether it is safe to recreate VM</span>

3675 volatile int safe_to_recreate_vm = 1;
3676 struct JavaVM_ main_vm = {&amp;jni_InvokeInterface};
3677 
3678 
3679 #define JAVASTACKSIZE (400 * 1024)    /* Default size of a thread java stack */
3680 enum { VERIFY_NONE, VERIFY_REMOTE, VERIFY_ALL };
3681 
3682 DT_RETURN_MARK_DECL(GetDefaultJavaVMInitArgs, jint
3683                     , HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_RETURN(_ret_ref));
3684 
3685 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *args_) {
3686   HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_ENTRY(args_);
3687   JDK1_1InitArgs *args = (JDK1_1InitArgs *)args_;
3688   jint ret = JNI_ERR;
3689   DT_RETURN_MARK(GetDefaultJavaVMInitArgs, jint, (const jint&amp;)ret);
3690 
3691   if (Threads::is_supported_jni_version(args-&gt;version)) {
3692     ret = JNI_OK;
3693   }
3694   // 1.1 style no longer supported in hotspot.
</pre>
<hr />
<pre>
3724     void *c = &amp;a;
3725     void *d = Atomic::xchg(&amp;c, &amp;b);
3726     assert(a == (jint) 0xdeadbeef &amp;&amp; b == (jint) 0xcafebabe, &quot;Atomic::xchg() works&quot;);
3727     assert(c == &amp;b &amp;&amp; d == &amp;a, &quot;Atomic::xchg() works&quot;);
3728   }
3729 #endif // ZERO &amp;&amp; ASSERT
3730 
3731   // At the moment it&#39;s only possible to have one Java VM,
3732   // since some of the runtime state is in global variables.
3733 
3734   // We cannot use our mutex locks here, since they only work on
3735   // Threads. We do an atomic compare and exchange to ensure only
3736   // one thread can call this method at a time
3737 
3738   // We use Atomic::xchg rather than Atomic::add/dec since on some platforms
3739   // the add/dec implementations are dependent on whether we are running
3740   // on a multiprocessor Atomic::xchg does not have this problem.
3741   if (Atomic::xchg(&amp;vm_created, 1) == 1) {
3742     return JNI_EEXIST;   // already created, or create attempt in progress
3743   }






3744   if (Atomic::xchg(&amp;safe_to_recreate_vm, 0) == 0) {
<span class="line-modified">3745     return JNI_ERR;  // someone tried and failed and retry not allowed.</span>
3746   }
3747 
3748   assert(vm_created == 1, &quot;vm_created is true during the creation&quot;);
3749 
3750   /**
3751    * Certain errors during initialization are recoverable and do not
3752    * prevent this method from being called again at a later time
3753    * (perhaps with different arguments).  However, at a certain
3754    * point during initialization if an error occurs we cannot allow
3755    * this function to be called again (or it will crash).  In those
3756    * situations, the &#39;canTryAgain&#39; flag is set to false, which atomically
3757    * sets safe_to_recreate_vm to 1, such that any new call to
3758    * JNI_CreateJavaVM will immediately fail using the above logic.
3759    */
3760   bool can_try_again = true;
3761 
3762   result = Threads::create_vm((JavaVMInitArgs*) args, &amp;can_try_again);
3763   if (result == JNI_OK) {
3764     JavaThread *thread = JavaThread::current();
3765     assert(!thread-&gt;has_pending_exception(), &quot;should have returned not OK&quot;);
</pre>
<hr />
<pre>
3918 #ifdef _WIN32
3919   } __except(topLevelExceptionFilter((_EXCEPTION_POINTERS*)_exception_info())) {
3920     // Nothing to do.
3921   }
3922 #endif
3923   return result;
3924 }
3925 
3926 static jint attach_current_thread(JavaVM *vm, void **penv, void *_args, bool daemon) {
3927   JavaVMAttachArgs *args = (JavaVMAttachArgs *) _args;
3928 
3929   // Check below commented out from JDK1.2fcs as well
3930   /*
3931   if (args &amp;&amp; (args-&gt;version != JNI_VERSION_1_1 || args-&gt;version != JNI_VERSION_1_2)) {
3932     return JNI_EVERSION;
3933   }
3934   */
3935 
3936   Thread* t = Thread::current_or_null();
3937   if (t != NULL) {
<span class="line-modified">3938     // If the thread has been attached this operation is a no-op</span>
<span class="line-modified">3939     *(JNIEnv**)penv = ((JavaThread*) t)-&gt;jni_environment();</span>
<span class="line-modified">3940     return JNI_OK;</span>





3941   }
3942 
3943   // Create a thread and mark it as attaching so it will be skipped by the
3944   // ThreadsListEnumerator - see CR 6404306
3945   JavaThread* thread = new JavaThread(true);
3946 
3947   // Set correct safepoint info. The thread is going to call into Java when
3948   // initializing the Java level thread object. Hence, the correct state must
3949   // be set in order for the Safepoint code to deal with it correctly.
3950   thread-&gt;set_thread_state(_thread_in_vm);
3951   thread-&gt;record_stack_base_and_size();
3952   thread-&gt;register_thread_stack_with_NMT();
3953   thread-&gt;initialize_thread_current();
3954 
3955   if (!os::create_attached_thread(thread)) {
3956     thread-&gt;smr_delete();
3957     return JNI_ERR;
3958   }
3959   // Enable stack overflow checks
3960   thread-&gt;create_stack_guard_pages();
</pre>
<hr />
<pre>
4018 
4019   *(JNIEnv**)penv = thread-&gt;jni_environment();
4020 
4021   // Now leaving the VM, so change thread_state. This is normally automatically taken care
4022   // of in the JVM_ENTRY. But in this situation we have to do it manually. Notice, that by
4023   // using ThreadStateTransition::transition, we do a callback to the safepoint code if
4024   // needed.
4025 
4026   ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);
4027 
4028   // Perform any platform dependent FPU setup
4029   os::setup_fpu();
4030 
4031   return JNI_OK;
4032 }
4033 
4034 
4035 jint JNICALL jni_AttachCurrentThread(JavaVM *vm, void **penv, void *_args) {
4036   HOTSPOT_JNI_ATTACHCURRENTTHREAD_ENTRY(vm, penv, _args);
4037   if (vm_created == 0) {
<span class="line-modified">4038   HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);</span>
4039     return JNI_ERR;
4040   }
4041 
4042   JNIWrapper(&quot;AttachCurrentThread&quot;);
4043   jint ret = attach_current_thread(vm, penv, _args, false);
4044   HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN(ret);
4045   return ret;
4046 }
4047 
4048 
4049 jint JNICALL jni_DetachCurrentThread(JavaVM *vm)  {
4050   HOTSPOT_JNI_DETACHCURRENTTHREAD_ENTRY(vm);




4051 
4052   JNIWrapper(&quot;DetachCurrentThread&quot;);
4053 


4054   // If the thread has already been detached the operation is a no-op
<span class="line-modified">4055   if (Thread::current_or_null() == NULL) {</span>
4056     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_OK);
4057     return JNI_OK;
4058   }
4059 






4060   VM_Exit::block_if_vm_exited();
4061 
<span class="line-modified">4062   JavaThread* thread = JavaThread::current();</span>
4063   if (thread-&gt;has_last_Java_frame()) {
4064     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);
4065     // Can&#39;t detach a thread that&#39;s running java, that can&#39;t work.
4066     return JNI_ERR;
4067   }
4068 
4069   // Safepoint support. Have to do call-back to safepoint code, if in the
4070   // middle of a safepoint operation
4071   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
4072 
4073   // XXX: Note that JavaThread::exit() call below removes the guards on the
4074   // stack pages set up via enable_stack_{red,yellow}_zone() calls
4075   // above in jni_AttachCurrentThread. Unfortunately, while the setting
4076   // of the guards is visible in jni_AttachCurrentThread above,
4077   // the removal of the guards is buried below in JavaThread::exit()
4078   // here. The abstraction should be more symmetrically either exposed
4079   // or hidden (e.g. it could probably be hidden in the same
4080   // (platform-dependent) methods where we do alternate stack
4081   // maintenance work?)
4082   thread-&gt;exit(false, JavaThread::jni_detach);
</pre>
</td>
<td>
<hr />
<pre>
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;jni.h&quot;
  28 #include &quot;jvm.h&quot;
  29 #include &quot;ci/ciReplay.hpp&quot;
  30 #include &quot;classfile/altHashing.hpp&quot;
  31 #include &quot;classfile/classFileStream.hpp&quot;
  32 #include &quot;classfile/classLoader.hpp&quot;
  33 #include &quot;classfile/javaClasses.hpp&quot;
  34 #include &quot;classfile/javaClasses.inline.hpp&quot;
<span class="line-added">  35 #include &quot;classfile/moduleEntry.hpp&quot;</span>
  36 #include &quot;classfile/modules.hpp&quot;
  37 #include &quot;classfile/symbolTable.hpp&quot;
  38 #include &quot;classfile/systemDictionary.hpp&quot;
  39 #include &quot;classfile/vmSymbols.hpp&quot;
  40 #include &quot;gc/shared/gcLocker.inline.hpp&quot;
  41 #include &quot;interpreter/linkResolver.hpp&quot;
  42 #include &quot;jfr/jfrEvents.hpp&quot;
  43 #include &quot;jfr/support/jfrThreadId.hpp&quot;
  44 #include &quot;logging/log.hpp&quot;
  45 #include &quot;memory/allocation.hpp&quot;
  46 #include &quot;memory/allocation.inline.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;oops/access.inline.hpp&quot;
  51 #include &quot;oops/arrayOop.inline.hpp&quot;
  52 #include &quot;oops/instanceKlass.hpp&quot;
  53 #include &quot;oops/instanceOop.hpp&quot;
  54 #include &quot;oops/markWord.hpp&quot;
  55 #include &quot;oops/method.hpp&quot;
</pre>
<hr />
<pre>
 381   }
 382   if ((int)strlen(name) &gt; Symbol::max_length()) {
 383     Exceptions::fthrow(THREAD_AND_LOCATION,
 384                        vmSymbols::java_lang_NoClassDefFoundError(),
 385                        &quot;Class name exceeds maximum length of %d: %s&quot;,
 386                        Symbol::max_length(),
 387                        name);
 388     return 0;
 389   }
 390 
 391   //%note jni_3
 392   Handle protection_domain;
 393   // Find calling class
 394   Klass* k = thread-&gt;security_get_caller_class(0);
 395   // default to the system loader when no context
 396   Handle loader(THREAD, SystemDictionary::java_system_loader());
 397   if (k != NULL) {
 398     // Special handling to make sure JNI_OnLoad and JNI_OnUnload are executed
 399     // in the correct class context.
 400     if (k-&gt;class_loader() == NULL &amp;&amp;
<span class="line-modified"> 401         k-&gt;name() == vmSymbols::jdk_internal_loader_NativeLibraries()) {</span>
 402       JavaValue result(T_OBJECT);
 403       JavaCalls::call_static(&amp;result, k,
 404                              vmSymbols::getFromClass_name(),
 405                              vmSymbols::void_class_signature(),
 406                              CHECK_NULL);
<span class="line-modified"> 407       // When invoked from JNI_OnLoad, NativeLibraries::getFromClass returns</span>
 408       // a non-NULL Class object.  When invoked from JNI_OnUnload,
 409       // it will return NULL to indicate no context.
 410       oop mirror = (oop) result.get_jobject();
 411       if (mirror != NULL) {
 412         Klass* fromClass = java_lang_Class::as_Klass(mirror);
 413         loader = Handle(THREAD, fromClass-&gt;class_loader());
 414         protection_domain = Handle(THREAD, fromClass-&gt;protection_domain());
 415       }
 416     } else {
 417       loader = Handle(THREAD, k-&gt;class_loader());
 418     }
 419   }
 420 
 421   TempNewSymbol sym = SymbolTable::new_symbol(name);
 422   result = find_class_from_class_loader(env, sym, true, loader,
 423                                         protection_domain, true, thread);
 424 
 425   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 426     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
 427   }
</pre>
<hr />
<pre>
2524     ss.print(&quot;Index %d out of bounds for length %d&quot;, index, a-&gt;length());
2525     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2526   }
2527 JNI_END
2528 
2529 
2530 
2531 #define DEFINE_NEWSCALARARRAY(Return,Allocator,Result \
2532                               ,EntryProbe,ReturnProbe)  \
2533 \
2534   DT_RETURN_MARK_DECL(New##Result##Array, Return \
2535                       , ReturnProbe); \
2536 \
2537 JNI_ENTRY(Return, \
2538           jni_New##Result##Array(JNIEnv *env, jsize len)) \
2539   JNIWrapper(&quot;New&quot; XSTR(Result) &quot;Array&quot;); \
2540   EntryProbe; \
2541   Return ret = NULL;\
2542   DT_RETURN_MARK(New##Result##Array, Return, (const Return&amp;)ret);\
2543 \
<span class="line-modified">2544   oop obj= oopFactory::Allocator(len, CHECK_NULL); \</span>
2545   ret = (Return) JNIHandles::make_local(env, obj); \
2546   return ret;\
2547 JNI_END
2548 
2549 DEFINE_NEWSCALARARRAY(jbooleanArray, new_boolArray,   Boolean,
2550                       HOTSPOT_JNI_NEWBOOLEANARRAY_ENTRY(env, len),
2551                       HOTSPOT_JNI_NEWBOOLEANARRAY_RETURN(_ret_ref))
2552 DEFINE_NEWSCALARARRAY(jbyteArray,    new_byteArray,   Byte,
2553                       HOTSPOT_JNI_NEWBYTEARRAY_ENTRY(env, len),
2554                       HOTSPOT_JNI_NEWBYTEARRAY_RETURN(_ret_ref))
2555 DEFINE_NEWSCALARARRAY(jshortArray,   new_shortArray,  Short,
2556                       HOTSPOT_JNI_NEWSHORTARRAY_ENTRY(env, len),
2557                       HOTSPOT_JNI_NEWSHORTARRAY_RETURN(_ret_ref))
2558 DEFINE_NEWSCALARARRAY(jcharArray,    new_charArray,   Char,
2559                       HOTSPOT_JNI_NEWCHARARRAY_ENTRY(env, len),
2560                       HOTSPOT_JNI_NEWCHARARRAY_RETURN(_ret_ref))
2561 DEFINE_NEWSCALARARRAY(jintArray,     new_intArray,    Int,
2562                       HOTSPOT_JNI_NEWINTARRAY_ENTRY(env, len),
2563                       HOTSPOT_JNI_NEWINTARRAY_RETURN(_ret_ref))
2564 DEFINE_NEWSCALARARRAY(jlongArray,    new_longArray,   Long,
</pre>
<hr />
<pre>
2795                             , HOTSPOT_JNI_SETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
2796                             HOTSPOT_JNI_SETFLOATARRAYREGION_RETURN())
2797 DEFINE_SETSCALARARRAYREGION(T_DOUBLE,  jdouble,  Double,  double
2798                             , HOTSPOT_JNI_SETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
2799                             HOTSPOT_JNI_SETDOUBLEARRAYREGION_RETURN())
2800 
2801 
2802 DT_RETURN_MARK_DECL(RegisterNatives, jint
2803                     , HOTSPOT_JNI_REGISTERNATIVES_RETURN(_ret_ref));
2804 
2805 JNI_ENTRY(jint, jni_RegisterNatives(JNIEnv *env, jclass clazz,
2806                                     const JNINativeMethod *methods,
2807                                     jint nMethods))
2808   JNIWrapper(&quot;RegisterNatives&quot;);
2809   HOTSPOT_JNI_REGISTERNATIVES_ENTRY(env, clazz, (void *) methods, nMethods);
2810   jint ret = 0;
2811   DT_RETURN_MARK(RegisterNatives, jint, (const jint&amp;)ret);
2812 
2813   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2814 
<span class="line-modified">2815   // There are no restrictions on native code registering native methods,</span>
<span class="line-modified">2816   // which allows agents to redefine the bindings to native methods, however</span>
<span class="line-modified">2817   // we issue a warning if any code running outside of the boot/platform</span>
<span class="line-modified">2818   // loader is rebinding any native methods in classes loaded by the</span>
<span class="line-modified">2819   // boot/platform loader that are in named modules. That will catch changes</span>
<span class="line-added">2820   // to platform classes while excluding classes added to the bootclasspath.</span>
2821   bool do_warning = false;
<span class="line-modified">2822 </span>
<span class="line-modified">2823   // Only instanceKlasses can have native methods</span>
<span class="line-modified">2824   if (k-&gt;is_instance_klass()) {</span>
<span class="line-modified">2825     oop cl = k-&gt;class_loader();</span>
<span class="line-modified">2826     InstanceKlass* ik = InstanceKlass::cast(k);</span>
<span class="line-added">2827     // Check for a platform class</span>
<span class="line-added">2828     if ((cl ==  NULL || SystemDictionary::is_platform_class_loader(cl)) &amp;&amp;</span>
<span class="line-added">2829         ik-&gt;module()-&gt;is_named()) {</span>
<span class="line-added">2830       Klass* caller = thread-&gt;security_get_caller_class(1);</span>
<span class="line-added">2831       // If no caller class, or caller class has a different loader, then</span>
<span class="line-added">2832       // issue a warning below.</span>
<span class="line-added">2833       do_warning = (caller == NULL) || caller-&gt;class_loader() != cl;</span>
<span class="line-added">2834     }</span>
2835   }
2836 
2837 
2838   for (int index = 0; index &lt; nMethods; index++) {
2839     const char* meth_name = methods[index].name;
2840     const char* meth_sig = methods[index].signature;
2841     int meth_name_len = (int)strlen(meth_name);
2842 
2843     // The class should have been loaded (we have an instance of the class
2844     // passed in) so the method and signature should already be in the symbol
2845     // table.  If they&#39;re not there, the method doesn&#39;t exist.
2846     TempNewSymbol  name = SymbolTable::probe(meth_name, meth_name_len);
2847     TempNewSymbol  signature = SymbolTable::probe(meth_sig, (int)strlen(meth_sig));
2848 
2849     if (name == NULL || signature == NULL) {
2850       ResourceMark rm(THREAD);
2851       stringStream st;
2852       st.print(&quot;Method %s.%s%s not found&quot;, k-&gt;external_name(), meth_name, meth_sig);
2853       // Must return negative value on failure
2854       THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), -1);
</pre>
<hr />
<pre>
3652 }
3653 
3654 // Returns the function structure
3655 struct JNINativeInterface_* jni_functions() {
3656 #if INCLUDE_JNI_CHECK
3657   if (CheckJNICalls) return jni_functions_check();
3658 #endif // INCLUDE_JNI_CHECK
3659   return &amp;jni_NativeInterface;
3660 }
3661 
3662 // Returns the function structure
3663 struct JNINativeInterface_* jni_functions_nocheck() {
3664   return &amp;jni_NativeInterface;
3665 }
3666 
3667 static void post_thread_start_event(const JavaThread* jt) {
3668   assert(jt != NULL, &quot;invariant&quot;);
3669   EventThreadStart event;
3670   if (event.should_commit()) {
3671     event.set_thread(JFR_THREAD_ID(jt));
<span class="line-modified">3672     event.set_parentThread((traceid)0);</span>
<span class="line-added">3673 #if INCLUDE_JFR</span>
<span class="line-added">3674     if (EventThreadStart::is_stacktrace_enabled()) {</span>
<span class="line-added">3675       jt-&gt;jfr_thread_local()-&gt;set_cached_stack_trace_id((traceid)0);</span>
<span class="line-added">3676       event.commit();</span>
<span class="line-added">3677       jt-&gt;jfr_thread_local()-&gt;clear_cached_stack_trace();</span>
<span class="line-added">3678     } else</span>
<span class="line-added">3679 #endif</span>
<span class="line-added">3680     {</span>
<span class="line-added">3681       event.commit();</span>
<span class="line-added">3682     }</span>
3683   }
3684 }
3685 
3686 // Invocation API
3687 
3688 
3689 // Forward declaration
3690 extern const struct JNIInvokeInterface_ jni_InvokeInterface;
3691 
3692 // Global invocation API vars
3693 volatile int vm_created = 0;
<span class="line-modified">3694 // Indicate whether it is safe to recreate VM. Recreation is only</span>
<span class="line-added">3695 // possible after a failed initial creation attempt in some cases.</span>
3696 volatile int safe_to_recreate_vm = 1;
3697 struct JavaVM_ main_vm = {&amp;jni_InvokeInterface};
3698 
3699 
3700 #define JAVASTACKSIZE (400 * 1024)    /* Default size of a thread java stack */
3701 enum { VERIFY_NONE, VERIFY_REMOTE, VERIFY_ALL };
3702 
3703 DT_RETURN_MARK_DECL(GetDefaultJavaVMInitArgs, jint
3704                     , HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_RETURN(_ret_ref));
3705 
3706 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *args_) {
3707   HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_ENTRY(args_);
3708   JDK1_1InitArgs *args = (JDK1_1InitArgs *)args_;
3709   jint ret = JNI_ERR;
3710   DT_RETURN_MARK(GetDefaultJavaVMInitArgs, jint, (const jint&amp;)ret);
3711 
3712   if (Threads::is_supported_jni_version(args-&gt;version)) {
3713     ret = JNI_OK;
3714   }
3715   // 1.1 style no longer supported in hotspot.
</pre>
<hr />
<pre>
3745     void *c = &amp;a;
3746     void *d = Atomic::xchg(&amp;c, &amp;b);
3747     assert(a == (jint) 0xdeadbeef &amp;&amp; b == (jint) 0xcafebabe, &quot;Atomic::xchg() works&quot;);
3748     assert(c == &amp;b &amp;&amp; d == &amp;a, &quot;Atomic::xchg() works&quot;);
3749   }
3750 #endif // ZERO &amp;&amp; ASSERT
3751 
3752   // At the moment it&#39;s only possible to have one Java VM,
3753   // since some of the runtime state is in global variables.
3754 
3755   // We cannot use our mutex locks here, since they only work on
3756   // Threads. We do an atomic compare and exchange to ensure only
3757   // one thread can call this method at a time
3758 
3759   // We use Atomic::xchg rather than Atomic::add/dec since on some platforms
3760   // the add/dec implementations are dependent on whether we are running
3761   // on a multiprocessor Atomic::xchg does not have this problem.
3762   if (Atomic::xchg(&amp;vm_created, 1) == 1) {
3763     return JNI_EEXIST;   // already created, or create attempt in progress
3764   }
<span class="line-added">3765 </span>
<span class="line-added">3766   // If a previous creation attempt failed but can be retried safely,</span>
<span class="line-added">3767   // then safe_to_recreate_vm will have been reset to 1 after being</span>
<span class="line-added">3768   // cleared here. If a previous creation attempt succeeded and we then</span>
<span class="line-added">3769   // destroyed that VM, we will be prevented from trying to recreate</span>
<span class="line-added">3770   // the VM in the same process, as the value will still be 0.</span>
3771   if (Atomic::xchg(&amp;safe_to_recreate_vm, 0) == 0) {
<span class="line-modified">3772     return JNI_ERR;</span>
3773   }
3774 
3775   assert(vm_created == 1, &quot;vm_created is true during the creation&quot;);
3776 
3777   /**
3778    * Certain errors during initialization are recoverable and do not
3779    * prevent this method from being called again at a later time
3780    * (perhaps with different arguments).  However, at a certain
3781    * point during initialization if an error occurs we cannot allow
3782    * this function to be called again (or it will crash).  In those
3783    * situations, the &#39;canTryAgain&#39; flag is set to false, which atomically
3784    * sets safe_to_recreate_vm to 1, such that any new call to
3785    * JNI_CreateJavaVM will immediately fail using the above logic.
3786    */
3787   bool can_try_again = true;
3788 
3789   result = Threads::create_vm((JavaVMInitArgs*) args, &amp;can_try_again);
3790   if (result == JNI_OK) {
3791     JavaThread *thread = JavaThread::current();
3792     assert(!thread-&gt;has_pending_exception(), &quot;should have returned not OK&quot;);
</pre>
<hr />
<pre>
3945 #ifdef _WIN32
3946   } __except(topLevelExceptionFilter((_EXCEPTION_POINTERS*)_exception_info())) {
3947     // Nothing to do.
3948   }
3949 #endif
3950   return result;
3951 }
3952 
3953 static jint attach_current_thread(JavaVM *vm, void **penv, void *_args, bool daemon) {
3954   JavaVMAttachArgs *args = (JavaVMAttachArgs *) _args;
3955 
3956   // Check below commented out from JDK1.2fcs as well
3957   /*
3958   if (args &amp;&amp; (args-&gt;version != JNI_VERSION_1_1 || args-&gt;version != JNI_VERSION_1_2)) {
3959     return JNI_EVERSION;
3960   }
3961   */
3962 
3963   Thread* t = Thread::current_or_null();
3964   if (t != NULL) {
<span class="line-modified">3965     // If executing from an atexit hook we may be in the VMThread.</span>
<span class="line-modified">3966     if (t-&gt;is_Java_thread()) {</span>
<span class="line-modified">3967       // If the thread has been attached this operation is a no-op</span>
<span class="line-added">3968       *(JNIEnv**)penv = ((JavaThread*) t)-&gt;jni_environment();</span>
<span class="line-added">3969       return JNI_OK;</span>
<span class="line-added">3970     } else {</span>
<span class="line-added">3971       return JNI_ERR;</span>
<span class="line-added">3972     }</span>
3973   }
3974 
3975   // Create a thread and mark it as attaching so it will be skipped by the
3976   // ThreadsListEnumerator - see CR 6404306
3977   JavaThread* thread = new JavaThread(true);
3978 
3979   // Set correct safepoint info. The thread is going to call into Java when
3980   // initializing the Java level thread object. Hence, the correct state must
3981   // be set in order for the Safepoint code to deal with it correctly.
3982   thread-&gt;set_thread_state(_thread_in_vm);
3983   thread-&gt;record_stack_base_and_size();
3984   thread-&gt;register_thread_stack_with_NMT();
3985   thread-&gt;initialize_thread_current();
3986 
3987   if (!os::create_attached_thread(thread)) {
3988     thread-&gt;smr_delete();
3989     return JNI_ERR;
3990   }
3991   // Enable stack overflow checks
3992   thread-&gt;create_stack_guard_pages();
</pre>
<hr />
<pre>
4050 
4051   *(JNIEnv**)penv = thread-&gt;jni_environment();
4052 
4053   // Now leaving the VM, so change thread_state. This is normally automatically taken care
4054   // of in the JVM_ENTRY. But in this situation we have to do it manually. Notice, that by
4055   // using ThreadStateTransition::transition, we do a callback to the safepoint code if
4056   // needed.
4057 
4058   ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);
4059 
4060   // Perform any platform dependent FPU setup
4061   os::setup_fpu();
4062 
4063   return JNI_OK;
4064 }
4065 
4066 
4067 jint JNICALL jni_AttachCurrentThread(JavaVM *vm, void **penv, void *_args) {
4068   HOTSPOT_JNI_ATTACHCURRENTTHREAD_ENTRY(vm, penv, _args);
4069   if (vm_created == 0) {
<span class="line-modified">4070     HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);</span>
4071     return JNI_ERR;
4072   }
4073 
4074   JNIWrapper(&quot;AttachCurrentThread&quot;);
4075   jint ret = attach_current_thread(vm, penv, _args, false);
4076   HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN(ret);
4077   return ret;
4078 }
4079 
4080 
4081 jint JNICALL jni_DetachCurrentThread(JavaVM *vm)  {
4082   HOTSPOT_JNI_DETACHCURRENTTHREAD_ENTRY(vm);
<span class="line-added">4083   if (vm_created == 0) {</span>
<span class="line-added">4084     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_ERR);</span>
<span class="line-added">4085     return JNI_ERR;</span>
<span class="line-added">4086   }</span>
4087 
4088   JNIWrapper(&quot;DetachCurrentThread&quot;);
4089 
<span class="line-added">4090   Thread* current = Thread::current_or_null();</span>
<span class="line-added">4091 </span>
4092   // If the thread has already been detached the operation is a no-op
<span class="line-modified">4093   if (current == NULL) {</span>
4094     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_OK);
4095     return JNI_OK;
4096   }
4097 
<span class="line-added">4098   // If executing from an atexit hook we may be in the VMThread.</span>
<span class="line-added">4099   if (!current-&gt;is_Java_thread()) {</span>
<span class="line-added">4100     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);</span>
<span class="line-added">4101     return JNI_ERR;</span>
<span class="line-added">4102   }</span>
<span class="line-added">4103 </span>
4104   VM_Exit::block_if_vm_exited();
4105 
<span class="line-modified">4106   JavaThread* thread = (JavaThread*) current;</span>
4107   if (thread-&gt;has_last_Java_frame()) {
4108     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);
4109     // Can&#39;t detach a thread that&#39;s running java, that can&#39;t work.
4110     return JNI_ERR;
4111   }
4112 
4113   // Safepoint support. Have to do call-back to safepoint code, if in the
4114   // middle of a safepoint operation
4115   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
4116 
4117   // XXX: Note that JavaThread::exit() call below removes the guards on the
4118   // stack pages set up via enable_stack_{red,yellow}_zone() calls
4119   // above in jni_AttachCurrentThread. Unfortunately, while the setting
4120   // of the guards is visible in jni_AttachCurrentThread above,
4121   // the removal of the guards is buried below in JavaThread::exit()
4122   // here. The abstraction should be more symmetrically either exposed
4123   // or hidden (e.g. it could probably be hidden in the same
4124   // (platform-dependent) methods where we do alternate stack
4125   // maintenance work?)
4126   thread-&gt;exit(false, JavaThread::jni_detach);
</pre>
</td>
</tr>
</table>
<center><a href="../opto/vectornode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvm.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
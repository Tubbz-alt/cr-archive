<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeSet.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../periodic/sampling/jfrThreadSampler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../storage/jfrStorage.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeSet.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 137 
 138 static traceid cld_id(CldPtr cld, bool leakp) {
 139   assert(cld != NULL, &quot;invariant&quot;);
 140   assert(!cld-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);
 141   if (leakp) {
 142     SET_LEAKP(cld);
 143   } else {
 144     SET_TRANSIENT(cld);
 145   }
 146   return artifact_id(cld);
 147 }
 148 
 149 template &lt;typename T&gt;
 150 static s4 get_flags(const T* ptr) {
 151   assert(ptr != NULL, &quot;invariant&quot;);
 152   return ptr-&gt;access_flags().get_flags();
 153 }
 154 
 155 static bool is_unsafe_anonymous(const Klass* klass) {
 156   assert(klass != NULL, &quot;invariant&quot;);
<span class="line-modified"> 157   return klass-&gt;is_instance_klass() &amp;&amp; ((const InstanceKlass*)klass)-&gt;is_unsafe_anonymous();</span>

 158 }
 159 
 160 static ClassLoaderData* get_cld(const Klass* klass) {
 161   assert(klass != NULL, &quot;invariant&quot;);



 162   return is_unsafe_anonymous(klass) ?
 163     InstanceKlass::cast(klass)-&gt;unsafe_anonymous_host()-&gt;class_loader_data() : klass-&gt;class_loader_data();
 164 }
 165 
 166 template &lt;typename T&gt;
 167 static void set_serialized(const T* ptr) {
 168   assert(ptr != NULL, &quot;invariant&quot;);
 169   SET_SERIALIZED(ptr);
 170   assert(IS_SERIALIZED(ptr), &quot;invariant&quot;);
 171   CLEAR_THIS_EPOCH_CLEARED_BIT(ptr);
 172 }
 173 
 174 /*
 175  * In C++03, functions used as template parameters must have external linkage;
 176  * this restriction was removed in C++11. Change back to &quot;static&quot; and
 177  * rename functions when C++11 becomes available.
 178  *
 179  * The weird naming is an effort to decrease the risk of name clashes.
 180  */
 181 
 182 static int write_klass(JfrCheckpointWriter* writer, KlassPtr klass, bool leakp) {
 183   assert(writer != NULL, &quot;invariant&quot;);
 184   assert(_artifacts != NULL, &quot;invariant&quot;);
 185   assert(klass != NULL, &quot;invariant&quot;);
<span class="line-removed"> 186   traceid pkg_id = 0;</span>
<span class="line-removed"> 187   KlassPtr theklass = klass;</span>
<span class="line-removed"> 188   if (theklass-&gt;is_objArray_klass()) {</span>
<span class="line-removed"> 189     const ObjArrayKlass* obj_arr_klass = ObjArrayKlass::cast(klass);</span>
<span class="line-removed"> 190     theklass = obj_arr_klass-&gt;bottom_klass();</span>
<span class="line-removed"> 191   }</span>
<span class="line-removed"> 192   if (theklass-&gt;is_instance_klass()) {</span>
<span class="line-removed"> 193     pkg_id = package_id(theklass, leakp);</span>
<span class="line-removed"> 194   } else {</span>
<span class="line-removed"> 195     assert(theklass-&gt;is_typeArray_klass(), &quot;invariant&quot;);</span>
<span class="line-removed"> 196   }</span>
 197   writer-&gt;write(artifact_id(klass));
 198   writer-&gt;write(cld_id(get_cld(klass), leakp));
 199   writer-&gt;write(mark_symbol(klass, leakp));
<span class="line-modified"> 200   writer-&gt;write(pkg_id);</span>
 201   writer-&gt;write(get_flags(klass));
 202   return 1;
 203 }
 204 
 205 int write__klass(JfrCheckpointWriter* writer, const void* k) {
 206   assert(k != NULL, &quot;invariant&quot;);
 207   KlassPtr klass = (KlassPtr)k;
 208   set_serialized(klass);
 209   return write_klass(writer, klass, false);
 210 }
 211 
 212 int write__klass__leakp(JfrCheckpointWriter* writer, const void* k) {
 213   assert(k != NULL, &quot;invariant&quot;);
 214   KlassPtr klass = (KlassPtr)k;
 215   return write_klass(writer, klass, true);
 216 }
 217 
 218 static bool is_implied(const Klass* klass) {
 219   assert(klass != NULL, &quot;invariant&quot;);
 220   return klass-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass()) || klass == SystemDictionary::Object_klass();
</pre>
<hr />
<pre>
 374 int write__package__leakp(JfrCheckpointWriter* writer, const void* p) {
 375   assert(p != NULL, &quot;invariant&quot;);
 376   PkgPtr pkg = (PkgPtr)p;
 377   CLEAR_LEAKP(pkg);
 378   return write_package(writer, pkg, true);
 379 }
 380 
 381 static void do_package(PackageEntry* entry) {
 382   do_previous_epoch_artifact(_subsystem_callback, entry);
 383 }
 384 
 385 static void do_packages() {
 386   ClassLoaderDataGraph::packages_do(&amp;do_package);
 387 }
 388 
 389 class PackageFieldSelector {
 390  public:
 391   typedef PkgPtr TypePtr;
 392   static TypePtr select(KlassPtr klass) {
 393     assert(klass != NULL, &quot;invariant&quot;);
<span class="line-modified"> 394     return ((InstanceKlass*)klass)-&gt;package();</span>
 395   }
 396 };
 397 
 398 typedef SerializePredicate&lt;PkgPtr&gt; PackagePredicate;
 399 typedef JfrPredicatedTypeWriterImplHost&lt;PkgPtr, PackagePredicate, write__package&gt; PackageWriterImpl;
 400 typedef JfrTypeWriterHost&lt;PackageWriterImpl, TYPE_PACKAGE&gt; PackageWriter;
 401 typedef CompositeFunctor&lt;PkgPtr, PackageWriter, ClearArtifact&lt;PkgPtr&gt; &gt; PackageWriterWithClear;
 402 typedef KlassToFieldEnvelope&lt;PackageFieldSelector, PackageWriter&gt; KlassPackageWriter;
 403 typedef JfrArtifactCallbackHost&lt;PkgPtr, PackageWriterWithClear&gt; PackageCallback;
 404 
 405 typedef LeakPredicate&lt;PkgPtr&gt; LeakPackagePredicate;
 406 typedef JfrPredicatedTypeWriterImplHost&lt;PkgPtr, LeakPackagePredicate, write__package__leakp&gt; LeakPackageWriterImpl;
 407 typedef JfrTypeWriterHost&lt;LeakPackageWriterImpl, TYPE_PACKAGE&gt; LeakPackageWriter;
 408 
 409 typedef CompositeFunctor&lt;PkgPtr, LeakPackageWriter, PackageWriter&gt; CompositePackageWriter;
 410 typedef KlassToFieldEnvelope&lt;PackageFieldSelector, CompositePackageWriter&gt; KlassCompositePackageWriter;
 411 typedef KlassToFieldEnvelope&lt;PackageFieldSelector, PackageWriterWithClear&gt; KlassPackageWriterWithClear;
 412 typedef CompositeFunctor&lt;PkgPtr, CompositePackageWriter, ClearArtifact&lt;PkgPtr&gt; &gt; CompositePackageWriterWithClear;
 413 typedef JfrArtifactCallbackHost&lt;PkgPtr, CompositePackageWriterWithClear&gt; CompositePackageCallback;
 414 
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 137 
 138 static traceid cld_id(CldPtr cld, bool leakp) {
 139   assert(cld != NULL, &quot;invariant&quot;);
 140   assert(!cld-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);
 141   if (leakp) {
 142     SET_LEAKP(cld);
 143   } else {
 144     SET_TRANSIENT(cld);
 145   }
 146   return artifact_id(cld);
 147 }
 148 
 149 template &lt;typename T&gt;
 150 static s4 get_flags(const T* ptr) {
 151   assert(ptr != NULL, &quot;invariant&quot;);
 152   return ptr-&gt;access_flags().get_flags();
 153 }
 154 
 155 static bool is_unsafe_anonymous(const Klass* klass) {
 156   assert(klass != NULL, &quot;invariant&quot;);
<span class="line-modified"> 157   assert(!klass-&gt;is_objArray_klass(), &quot;invariant&quot;);</span>
<span class="line-added"> 158   return klass-&gt;is_instance_klass() &amp;&amp; InstanceKlass::cast(klass)-&gt;is_unsafe_anonymous();</span>
 159 }
 160 
 161 static ClassLoaderData* get_cld(const Klass* klass) {
 162   assert(klass != NULL, &quot;invariant&quot;);
<span class="line-added"> 163   if (klass-&gt;is_objArray_klass()) {</span>
<span class="line-added"> 164     klass = ObjArrayKlass::cast(klass)-&gt;bottom_klass();</span>
<span class="line-added"> 165   }</span>
 166   return is_unsafe_anonymous(klass) ?
 167     InstanceKlass::cast(klass)-&gt;unsafe_anonymous_host()-&gt;class_loader_data() : klass-&gt;class_loader_data();
 168 }
 169 
 170 template &lt;typename T&gt;
 171 static void set_serialized(const T* ptr) {
 172   assert(ptr != NULL, &quot;invariant&quot;);
 173   SET_SERIALIZED(ptr);
 174   assert(IS_SERIALIZED(ptr), &quot;invariant&quot;);
 175   CLEAR_THIS_EPOCH_CLEARED_BIT(ptr);
 176 }
 177 
 178 /*
 179  * In C++03, functions used as template parameters must have external linkage;
 180  * this restriction was removed in C++11. Change back to &quot;static&quot; and
 181  * rename functions when C++11 becomes available.
 182  *
 183  * The weird naming is an effort to decrease the risk of name clashes.
 184  */
 185 
 186 static int write_klass(JfrCheckpointWriter* writer, KlassPtr klass, bool leakp) {
 187   assert(writer != NULL, &quot;invariant&quot;);
 188   assert(_artifacts != NULL, &quot;invariant&quot;);
 189   assert(klass != NULL, &quot;invariant&quot;);











 190   writer-&gt;write(artifact_id(klass));
 191   writer-&gt;write(cld_id(get_cld(klass), leakp));
 192   writer-&gt;write(mark_symbol(klass, leakp));
<span class="line-modified"> 193   writer-&gt;write(package_id(klass, leakp));</span>
 194   writer-&gt;write(get_flags(klass));
 195   return 1;
 196 }
 197 
 198 int write__klass(JfrCheckpointWriter* writer, const void* k) {
 199   assert(k != NULL, &quot;invariant&quot;);
 200   KlassPtr klass = (KlassPtr)k;
 201   set_serialized(klass);
 202   return write_klass(writer, klass, false);
 203 }
 204 
 205 int write__klass__leakp(JfrCheckpointWriter* writer, const void* k) {
 206   assert(k != NULL, &quot;invariant&quot;);
 207   KlassPtr klass = (KlassPtr)k;
 208   return write_klass(writer, klass, true);
 209 }
 210 
 211 static bool is_implied(const Klass* klass) {
 212   assert(klass != NULL, &quot;invariant&quot;);
 213   return klass-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass()) || klass == SystemDictionary::Object_klass();
</pre>
<hr />
<pre>
 367 int write__package__leakp(JfrCheckpointWriter* writer, const void* p) {
 368   assert(p != NULL, &quot;invariant&quot;);
 369   PkgPtr pkg = (PkgPtr)p;
 370   CLEAR_LEAKP(pkg);
 371   return write_package(writer, pkg, true);
 372 }
 373 
 374 static void do_package(PackageEntry* entry) {
 375   do_previous_epoch_artifact(_subsystem_callback, entry);
 376 }
 377 
 378 static void do_packages() {
 379   ClassLoaderDataGraph::packages_do(&amp;do_package);
 380 }
 381 
 382 class PackageFieldSelector {
 383  public:
 384   typedef PkgPtr TypePtr;
 385   static TypePtr select(KlassPtr klass) {
 386     assert(klass != NULL, &quot;invariant&quot;);
<span class="line-modified"> 387     return klass-&gt;package();</span>
 388   }
 389 };
 390 
 391 typedef SerializePredicate&lt;PkgPtr&gt; PackagePredicate;
 392 typedef JfrPredicatedTypeWriterImplHost&lt;PkgPtr, PackagePredicate, write__package&gt; PackageWriterImpl;
 393 typedef JfrTypeWriterHost&lt;PackageWriterImpl, TYPE_PACKAGE&gt; PackageWriter;
 394 typedef CompositeFunctor&lt;PkgPtr, PackageWriter, ClearArtifact&lt;PkgPtr&gt; &gt; PackageWriterWithClear;
 395 typedef KlassToFieldEnvelope&lt;PackageFieldSelector, PackageWriter&gt; KlassPackageWriter;
 396 typedef JfrArtifactCallbackHost&lt;PkgPtr, PackageWriterWithClear&gt; PackageCallback;
 397 
 398 typedef LeakPredicate&lt;PkgPtr&gt; LeakPackagePredicate;
 399 typedef JfrPredicatedTypeWriterImplHost&lt;PkgPtr, LeakPackagePredicate, write__package__leakp&gt; LeakPackageWriterImpl;
 400 typedef JfrTypeWriterHost&lt;LeakPackageWriterImpl, TYPE_PACKAGE&gt; LeakPackageWriter;
 401 
 402 typedef CompositeFunctor&lt;PkgPtr, LeakPackageWriter, PackageWriter&gt; CompositePackageWriter;
 403 typedef KlassToFieldEnvelope&lt;PackageFieldSelector, CompositePackageWriter&gt; KlassCompositePackageWriter;
 404 typedef KlassToFieldEnvelope&lt;PackageFieldSelector, PackageWriterWithClear&gt; KlassPackageWriterWithClear;
 405 typedef CompositeFunctor&lt;PkgPtr, CompositePackageWriter, ClearArtifact&lt;PkgPtr&gt; &gt; CompositePackageWriterWithClear;
 406 typedef JfrArtifactCallbackHost&lt;PkgPtr, CompositePackageWriterWithClear&gt; CompositePackageCallback;
 407 
</pre>
</td>
</tr>
</table>
<center><a href="../../../periodic/sampling/jfrThreadSampler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../storage/jfrStorage.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
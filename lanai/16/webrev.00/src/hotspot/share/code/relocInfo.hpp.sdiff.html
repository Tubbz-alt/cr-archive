<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/code/relocInfo.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="relocInfo.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vtableStubs.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/relocInfo.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 498 //   RelocIterator iter(nm);
 499 //   while (iter.next()) {
 500 //     iter.reloc()-&gt;some_operation();
 501 //   }
 502 // or:
 503 //   RelocIterator iter(nm);
 504 //   while (iter.next()) {
 505 //     switch (iter.type()) {
 506 //      case relocInfo::oop_type          :
 507 //      case relocInfo::ic_type           :
 508 //      case relocInfo::prim_type         :
 509 //      case relocInfo::uncommon_type     :
 510 //      case relocInfo::runtime_call_type :
 511 //      case relocInfo::internal_word_type:
 512 //      case relocInfo::external_word_type:
 513 //      ...
 514 //     }
 515 //   }
 516 
 517 class RelocIterator : public StackObj {

 518   enum { SECT_LIMIT = 3 };  // must be equal to CodeBuffer::SECT_LIMIT, checked in ctor
 519   friend class Relocation;
<span class="line-modified"> 520   friend class relocInfo;       // for change_reloc_info_for_address only</span>
 521   typedef relocInfo::relocType relocType;
 522 
 523  private:
 524   address         _limit;   // stop producing relocations after this _addr
 525   relocInfo*      _current; // the current relocation information
 526   relocInfo*      _end;     // end marker; we&#39;re done iterating when _current == _end
 527   CompiledMethod* _code;    // compiled method containing _addr
 528   address         _addr;    // instruction to which the relocation applies
 529   short           _databuf; // spare buffer for compressed data
 530   short*          _data;    // pointer to the relocation&#39;s data
 531   short           _datalen; // number of halfwords in _data
 532 
 533   // Base addresses needed to compute targets of section_word_type relocs.
 534   address _section_start[SECT_LIMIT];
 535   address _section_end  [SECT_LIMIT];
 536 
 537   void set_has_current(bool b) {
 538     _datalen = !b ? -1 : 0;
 539     debug_only(_data = NULL);
 540   }
</pre>
<hr />
<pre>
 620   // generic relocation accessor; switches on type to call the above
 621   Relocation* reloc();
 622 
 623 #ifndef PRODUCT
 624  public:
 625   void print();
 626   void print_current();
 627 #endif
 628 };
 629 
 630 
 631 // A Relocation is a flyweight object allocated within a RelocationHolder.
 632 // It represents the relocation data of relocation record.
 633 // So, the RelocIterator unpacks relocInfos into Relocations.
 634 
 635 class Relocation {
 636   friend class RelocationHolder;
 637   friend class RelocIterator;
 638 
 639  private:
<span class="line-removed"> 640   static void guarantee_size();</span>
<span class="line-removed"> 641 </span>
 642   // When a relocation has been created by a RelocIterator,
 643   // this field is non-null.  It allows the relocation to know
 644   // its context, such as the address to which it applies.
 645   RelocIterator* _binding;
 646 


 647  protected:
 648   RelocIterator* binding() const {
 649     assert(_binding != NULL, &quot;must be bound&quot;);
 650     return _binding;
 651   }
 652   void set_binding(RelocIterator* b) {
 653     assert(_binding == NULL, &quot;must be unbound&quot;);
 654     _binding = b;
 655     assert(_binding != NULL, &quot;must now be bound&quot;);
 656   }
 657 
<span class="line-modified"> 658   Relocation() {</span>
<span class="line-removed"> 659     _binding = NULL;</span>
<span class="line-removed"> 660   }</span>
 661 
 662   static RelocationHolder newHolder() {
 663     return RelocationHolder();
 664   }
 665 
 666  public:
 667   void* operator new(size_t size, const RelocationHolder&amp; holder) throw() {
<span class="line-modified"> 668     if (size &gt; sizeof(holder._relocbuf)) guarantee_size();</span>
 669     assert((void* const *)holder.reloc() == &amp;holder._relocbuf[0], &quot;ptrs must agree&quot;);
 670     return holder.reloc();
 671   }
 672 
 673   // make a generic relocation for a given type (if possible)
 674   static RelocationHolder spec_simple(relocInfo::relocType rtype);
 675 
 676   // here is the type-specific hook which writes relocation data:
 677   virtual void pack_data_to(CodeSection* dest) { }
 678 
 679   // here is the type-specific hook which reads (unpacks) relocation data:
 680   virtual void unpack_data() {
 681     assert(datalen()==0 || type()==relocInfo::none, &quot;no data here&quot;);
 682   }
 683 
 684  protected:
 685   // Helper functions for pack_data_to() and unpack_data().
 686 
 687   // Most of the compression logic is confined here.
 688   // (The &quot;immediate data&quot; mechanism of relocInfo works independently
</pre>
<hr />
<pre>
 775     int byte_offset = -( offset * relocInfo::addr_unit() );
 776     return base + byte_offset;
 777   }
 778 
 779   // helpers for mapping between old and new addresses after a move or resize
 780   address old_addr_for(address newa, const CodeBuffer* src, CodeBuffer* dest);
 781   address new_addr_for(address olda, const CodeBuffer* src, CodeBuffer* dest);
 782   void normalize_address(address&amp; addr, const CodeSection* dest, bool allow_other_sections = false);
 783 
 784  public:
 785   // accessors which only make sense for a bound Relocation
 786   address         addr()            const { return binding()-&gt;addr(); }
 787   CompiledMethod* code()            const { return binding()-&gt;code(); }
 788   bool            addr_in_const()   const { return binding()-&gt;addr_in_const(); }
 789  protected:
 790   short*   data()         const { return binding()-&gt;data(); }
 791   int      datalen()      const { return binding()-&gt;datalen(); }
 792   int      format()       const { return binding()-&gt;format(); }
 793 
 794  public:
<span class="line-modified"> 795   virtual relocInfo::relocType type()            { return relocInfo::none; }</span>
 796 
 797   // is it a call instruction?
 798   virtual bool is_call()                         { return false; }
 799 
 800   // is it a data movement instruction?
 801   virtual bool is_data()                         { return false; }
 802 
 803   // some relocations can compute their own values
 804   virtual address  value();
 805 
 806   // all relocations are able to reassert their values
 807   virtual void set_value(address x);
 808 
 809   virtual bool clear_inline_cache()              { return true; }
 810 
 811   // This method assumes that all virtual/static (inline) caches are cleared (since for static_call_type and
 812   // ic_call_type is not always posisition dependent (depending on the state of the cache)). However, this is
 813   // probably a reasonable assumption, since empty caches simplifies code reloacation.
 814   virtual void fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest) { }
 815 };
 816 
 817 
 818 // certain inlines must be deferred until class Relocation is defined:
 819 
 820 inline RelocationHolder::RelocationHolder() {
 821   // initialize the vtbl, just to keep things type-safe
<span class="line-modified"> 822   new(*this) Relocation();</span>
 823 }
 824 
 825 
 826 inline RelocationHolder::RelocationHolder(Relocation* r) {
 827   // wordwise copy from r (ok if it copies garbage after r)
 828   for (int i = 0; i &lt; _relocbuf_size; i++) {
 829     _relocbuf[i] = ((void**)r)[i];
 830   }
 831 }
 832 
<span class="line-removed"> 833 </span>
 834 relocInfo::relocType RelocationHolder::type() const {
 835   return reloc()-&gt;type();
 836 }
 837 
 838 // A DataRelocation always points at a memory or load-constant instruction..
 839 // It is absolute on most machines, and the constant is split on RISCs.
 840 // The specific subtypes are oop, external_word, and internal_word.
 841 // By convention, the &quot;value&quot; does not include a separately reckoned &quot;offset&quot;.
 842 class DataRelocation : public Relocation {
 843  public:


 844   bool          is_data()                      { return true; }
 845 
 846   // both target and offset must be computed somehow from relocation data
 847   virtual int    offset()                      { return 0; }
 848   address         value()                      = 0;
 849   void        set_value(address x)             { set_value(x, offset()); }
 850   void        set_value(address x, intptr_t o) {
 851     if (addr_in_const())
 852       const_set_data_value(x);
 853     else
 854       pd_set_data_value(x, o);
 855   }
 856   void        verify_value(address x) {
 857     if (addr_in_const())
 858       const_verify_data_value(x);
 859     else
 860       pd_verify_data_value(x, offset());
 861   }
 862 
 863   // The &quot;o&quot; (displacement) argument is relevant only to split relocations
 864   // on RISC machines.  In some CPUs (SPARC), the set-hi and set-lo ins&#39;ns
 865   // can encode more than 32 bits between them.  This allows compilers to
 866   // share set-hi instructions between addresses that differ by a small
 867   // offset (e.g., different static variables in the same class).
 868   // On such machines, the &quot;x&quot; argument to set_value on all set-lo
 869   // instructions must be the same as the &quot;x&quot; argument for the
 870   // corresponding set-hi instructions.  The &quot;o&quot; arguments for the
 871   // set-hi instructions are ignored, and must not affect the high-half
 872   // immediate constant.  The &quot;o&quot; arguments for the set-lo instructions are
 873   // added into the low-half immediate constant, and must not overflow it.
 874 };
 875 
 876 // A CallRelocation always points at a call instruction.
 877 // It is PC-relative on most machines.
 878 class CallRelocation : public Relocation {
 879  public:


 880   bool is_call() { return true; }
 881 
 882   address  destination()                    { return pd_call_destination(); }
 883   void     set_destination(address x); // pd_set_call_destination
 884 
 885   void     fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest);
 886   address  value()                          { return destination();  }
 887   void     set_value(address x)             { set_destination(x); }
 888 };
 889 
 890 class oop_Relocation : public DataRelocation {
<span class="line-removed"> 891   relocInfo::relocType type() { return relocInfo::oop_type; }</span>
<span class="line-removed"> 892 </span>
 893  public:
 894   // encode in one of these formats:  [] [n] [n l] [Nn l] [Nn Ll]
 895   // an oop in the CodeBlob&#39;s oop pool
 896   static RelocationHolder spec(int oop_index, int offset = 0) {
 897     assert(oop_index &gt; 0, &quot;must be a pool-resident oop&quot;);
 898     RelocationHolder rh = newHolder();
 899     new(rh) oop_Relocation(oop_index, offset);
 900     return rh;
 901   }
 902   // an oop in the instruction stream
 903   static RelocationHolder spec_for_immediate() {
 904     // If no immediate oops are generated, we can skip some walks over nmethods.
 905     // Assert that they don&#39;t get generated accidently!
 906     assert(relocInfo::mustIterateImmediateOopsInCode(),
 907            &quot;Must return true so we will search for oops as roots etc. in the code.&quot;);
 908     const int oop_index = 0;
 909     const int offset    = 0;    // if you want an offset, use the oop pool
 910     RelocationHolder rh = newHolder();
 911     new(rh) oop_Relocation(oop_index, offset);
 912     return rh;
 913   }
 914 
 915  private:
 916   jint _oop_index;                  // if &gt; 0, index into CodeBlob::oop_at
 917   jint _offset;                     // byte offset to apply to the oop itself
 918 
<span class="line-modified"> 919   oop_Relocation(int oop_index, int offset) {</span>
<span class="line-modified"> 920     _oop_index = oop_index; _offset = offset;</span>
<span class="line-removed"> 921   }</span>
 922 
 923   friend class RelocIterator;
<span class="line-modified"> 924   oop_Relocation() { }</span>
 925 
 926  public:
 927   int oop_index() { return _oop_index; }
 928   int offset()    { return _offset; }
 929 
 930   // data is packed in &quot;2_ints&quot; format:  [i o] or [Ii Oo]
 931   void pack_data_to(CodeSection* dest);
 932   void unpack_data();
 933 
 934   void fix_oop_relocation();        // reasserts oop value
 935 
 936   void verify_oop_relocation();
 937 
 938   address value()  { return cast_from_oop&lt;address&gt;(*oop_addr()); }
 939 
 940   bool oop_is_immediate()  { return oop_index() == 0; }
 941 
 942   oop* oop_addr();                  // addr or &amp;pool[jint_data]
 943   oop  oop_value();                 // *oop_addr
 944   // Note:  oop_value transparently converts Universe::non_oop_word to NULL.
 945 };
 946 
 947 
 948 // copy of oop_Relocation for now but may delete stuff in both/either
 949 class metadata_Relocation : public DataRelocation {
<span class="line-removed"> 950   relocInfo::relocType type() { return relocInfo::metadata_type; }</span>
 951 
 952  public:
 953   // encode in one of these formats:  [] [n] [n l] [Nn l] [Nn Ll]
 954   // an metadata in the CodeBlob&#39;s metadata pool
 955   static RelocationHolder spec(int metadata_index, int offset = 0) {
 956     assert(metadata_index &gt; 0, &quot;must be a pool-resident metadata&quot;);
 957     RelocationHolder rh = newHolder();
 958     new(rh) metadata_Relocation(metadata_index, offset);
 959     return rh;
 960   }
 961   // an metadata in the instruction stream
 962   static RelocationHolder spec_for_immediate() {
 963     const int metadata_index = 0;
 964     const int offset    = 0;    // if you want an offset, use the metadata pool
 965     RelocationHolder rh = newHolder();
 966     new(rh) metadata_Relocation(metadata_index, offset);
 967     return rh;
 968   }
 969 
 970  private:
 971   jint _metadata_index;            // if &gt; 0, index into nmethod::metadata_at
 972   jint _offset;                     // byte offset to apply to the metadata itself
 973 
<span class="line-modified"> 974   metadata_Relocation(int metadata_index, int offset) {</span>
<span class="line-modified"> 975     _metadata_index = metadata_index; _offset = offset;</span>
<span class="line-removed"> 976   }</span>
 977 
 978   friend class RelocIterator;
<span class="line-modified"> 979   metadata_Relocation() { }</span>
 980 
 981   // Fixes a Metadata pointer in the code. Most platforms embeds the
 982   // Metadata pointer in the code at compile time so this is empty
 983   // for them.
 984   void pd_fix_value(address x);
 985 
 986  public:
 987   int metadata_index() { return _metadata_index; }
 988   int offset()    { return _offset; }
 989 
 990   // data is packed in &quot;2_ints&quot; format:  [i o] or [Ii Oo]
 991   void pack_data_to(CodeSection* dest);
 992   void unpack_data();
 993 
 994   void fix_metadata_relocation();        // reasserts metadata value
 995 
 996   address value()  { return (address) *metadata_addr(); }
 997 
 998   bool metadata_is_immediate()  { return metadata_index() == 0; }
 999 
1000   Metadata**   metadata_addr();                  // addr or &amp;pool[jint_data]
1001   Metadata*    metadata_value();                 // *metadata_addr
1002   // Note:  metadata_value transparently converts Universe::non_metadata_word to NULL.
1003 };
1004 
1005 
1006 class virtual_call_Relocation : public CallRelocation {
<span class="line-removed">1007   relocInfo::relocType type() { return relocInfo::virtual_call_type; }</span>
1008 
1009  public:
1010   // &quot;cached_value&quot; points to the first associated set-oop.
1011   // The oop_limit helps find the last associated set-oop.
1012   // (See comments at the top of this file.)
1013   static RelocationHolder spec(address cached_value, jint method_index = 0) {
1014     RelocationHolder rh = newHolder();
1015     new(rh) virtual_call_Relocation(cached_value, method_index);
1016     return rh;
1017   }
1018 
1019  private:
1020   address _cached_value; // location of set-value instruction
1021   jint    _method_index; // resolved method for a Java call
1022 
<span class="line-modified">1023   virtual_call_Relocation(address cached_value, int method_index) {</span>
<span class="line-modified">1024     _cached_value = cached_value;</span>
<span class="line-modified">1025     _method_index = method_index;</span>

1026     assert(cached_value != NULL, &quot;first oop address must be specified&quot;);
1027   }
1028 
1029   friend class RelocIterator;
<span class="line-modified">1030   virtual_call_Relocation() { }</span>
1031 
1032  public:
1033   address cached_value();
1034 
1035   int     method_index() { return _method_index; }
1036   Method* method_value();
1037 
1038   // data is packed as scaled offsets in &quot;2_ints&quot; format:  [f l] or [Ff Ll]
1039   // oop_limit is set to 0 if the limit falls somewhere within the call.
1040   // When unpacking, a zero oop_limit is taken to refer to the end of the call.
1041   // (This has the effect of bringing in the call&#39;s delay slot on SPARC.)
1042   void pack_data_to(CodeSection* dest);
1043   void unpack_data();
1044 
1045   bool clear_inline_cache();
1046 };
1047 
1048 
1049 class opt_virtual_call_Relocation : public CallRelocation {
<span class="line-removed">1050   relocInfo::relocType type() { return relocInfo::opt_virtual_call_type; }</span>
<span class="line-removed">1051 </span>
1052  public:
1053   static RelocationHolder spec(int method_index = 0) {
1054     RelocationHolder rh = newHolder();
1055     new(rh) opt_virtual_call_Relocation(method_index);
1056     return rh;
1057   }
1058 
1059  private:
1060   jint _method_index; // resolved method for a Java call
1061 
<span class="line-modified">1062   opt_virtual_call_Relocation(int method_index) {</span>
<span class="line-modified">1063     _method_index = method_index;</span>
<span class="line-modified">1064   }</span>
1065 
1066   friend class RelocIterator;
<span class="line-modified">1067   opt_virtual_call_Relocation() {}</span>
1068 
1069  public:
1070   int     method_index() { return _method_index; }
1071   Method* method_value();
1072 
1073   void pack_data_to(CodeSection* dest);
1074   void unpack_data();
1075 
1076   bool clear_inline_cache();
1077 
1078   // find the matching static_stub
1079   address static_stub(bool is_aot);
1080 };
1081 
1082 
1083 class static_call_Relocation : public CallRelocation {
<span class="line-removed">1084   relocInfo::relocType type() { return relocInfo::static_call_type; }</span>
<span class="line-removed">1085 </span>
1086  public:
1087   static RelocationHolder spec(int method_index = 0) {
1088     RelocationHolder rh = newHolder();
1089     new(rh) static_call_Relocation(method_index);
1090     return rh;
1091   }
1092 
1093  private:
1094   jint _method_index; // resolved method for a Java call
1095 
<span class="line-modified">1096   static_call_Relocation(int method_index) {</span>
<span class="line-modified">1097     _method_index = method_index;</span>
<span class="line-modified">1098   }</span>
1099 
1100   friend class RelocIterator;
<span class="line-modified">1101   static_call_Relocation() {}</span>
1102 
1103  public:
1104   int     method_index() { return _method_index; }
1105   Method* method_value();
1106 
1107   void pack_data_to(CodeSection* dest);
1108   void unpack_data();
1109 
1110   bool clear_inline_cache();
1111 
1112   // find the matching static_stub
1113   address static_stub(bool is_aot);
1114 };
1115 
1116 class static_stub_Relocation : public Relocation {
<span class="line-removed">1117   relocInfo::relocType type() { return relocInfo::static_stub_type; }</span>
<span class="line-removed">1118 </span>
1119  public:
1120   static RelocationHolder spec(address static_call, bool is_aot = false) {
1121     RelocationHolder rh = newHolder();
1122     new(rh) static_stub_Relocation(static_call, is_aot);
1123     return rh;
1124   }
1125 
1126  private:
1127   address _static_call;  // location of corresponding static_call
1128   bool _is_aot;          // trampoline to aot code
1129 
<span class="line-modified">1130   static_stub_Relocation(address static_call, bool is_aot) {</span>
<span class="line-modified">1131     _static_call = static_call;</span>
<span class="line-modified">1132     _is_aot = is_aot;</span>
<span class="line-removed">1133   }</span>
1134 
1135   friend class RelocIterator;
<span class="line-modified">1136   static_stub_Relocation() { }</span>
1137 
1138  public:
1139   bool clear_inline_cache();
1140 
1141   address static_call() { return _static_call; }
1142   bool is_aot() { return _is_aot; }
1143 
1144   // data is packed as a scaled offset in &quot;1_int&quot; format:  [c] or [Cc]
1145   void pack_data_to(CodeSection* dest);
1146   void unpack_data();
1147 };
1148 
1149 class runtime_call_Relocation : public CallRelocation {
<span class="line-removed">1150   relocInfo::relocType type() { return relocInfo::runtime_call_type; }</span>
1151 
1152  public:
1153   static RelocationHolder spec() {
1154     RelocationHolder rh = newHolder();
1155     new(rh) runtime_call_Relocation();
1156     return rh;
1157   }
1158 
1159  private:
1160   friend class RelocIterator;
<span class="line-modified">1161   runtime_call_Relocation() { }</span>
1162 
1163  public:
1164 };
1165 
1166 
1167 class runtime_call_w_cp_Relocation : public CallRelocation {
<span class="line-removed">1168   relocInfo::relocType type() { return relocInfo::runtime_call_w_cp_type; }</span>
<span class="line-removed">1169 </span>
1170  public:
1171   static RelocationHolder spec() {
1172     RelocationHolder rh = newHolder();
1173     new(rh) runtime_call_w_cp_Relocation();
1174     return rh;
1175   }
1176 
1177  private:
1178   friend class RelocIterator;
<span class="line-modified">1179   runtime_call_w_cp_Relocation() { _offset = -4; /* &lt;0 = invalid */ }</span>



1180   // On z/Architecture, runtime calls are either a sequence
1181   // of two instructions (load destination of call from constant pool + do call)
1182   // or a pc-relative call. The pc-relative call is faster, but it can only
1183   // be used if the destination of the call is not too far away.
1184   // In order to be able to patch a pc-relative call back into one using
1185   // the constant pool, we have to remember the location of the call&#39;s destination
1186   // in the constant pool.
1187   int _offset;
1188 
1189  public:
1190   void set_constant_pool_offset(int offset) { _offset = offset; }
1191   int get_constant_pool_offset() { return _offset; }
1192   void pack_data_to(CodeSection * dest);
1193   void unpack_data();
1194 };
1195 
1196 // Trampoline Relocations.
1197 // A trampoline allows to encode a small branch in the code, even if there
1198 // is the chance that this branch can not reach all possible code locations.
1199 // If the relocation finds that a branch is too far for the instruction
1200 // in the code, it can patch it to jump to the trampoline where is
1201 // sufficient space for a far branch. Needed on PPC.
1202 class trampoline_stub_Relocation : public Relocation {
<span class="line-removed">1203   relocInfo::relocType type() { return relocInfo::trampoline_stub_type; }</span>
<span class="line-removed">1204 </span>
1205  public:
1206   static RelocationHolder spec(address static_call) {
1207     RelocationHolder rh = newHolder();
1208     return (new (rh) trampoline_stub_Relocation(static_call));
1209   }
1210 
1211  private:
1212   address _owner;    // Address of the NativeCall that owns the trampoline.
1213 
<span class="line-modified">1214   trampoline_stub_Relocation(address owner) {</span>
<span class="line-modified">1215     _owner = owner;</span>
<span class="line-modified">1216   }</span>
1217 
1218   friend class RelocIterator;
<span class="line-modified">1219   trampoline_stub_Relocation() { }</span>
1220 
1221  public:
1222 
1223   // Return the address of the NativeCall that owns the trampoline.
1224   address owner() { return _owner; }
1225 
1226   void pack_data_to(CodeSection * dest);
1227   void unpack_data();
1228 
1229   // Find the trampoline stub for a call.
1230   static address get_trampoline_for(address call, nmethod* code);
1231 };
1232 
1233 class external_word_Relocation : public DataRelocation {
<span class="line-removed">1234   relocInfo::relocType type() { return relocInfo::external_word_type; }</span>
<span class="line-removed">1235 </span>
1236  public:
1237   static RelocationHolder spec(address target) {
1238     assert(target != NULL, &quot;must not be null&quot;);
1239     RelocationHolder rh = newHolder();
1240     new(rh) external_word_Relocation(target);
1241     return rh;
1242   }
1243 
1244   // Use this one where all 32/64 bits of the target live in the code stream.
1245   // The target must be an intptr_t, and must be absolute (not relative).
1246   static RelocationHolder spec_for_immediate() {
1247     RelocationHolder rh = newHolder();
1248     new(rh) external_word_Relocation(NULL);
1249     return rh;
1250   }
1251 
1252   // Some address looking values aren&#39;t safe to treat as relocations
1253   // and should just be treated as constants.
1254   static bool can_be_relocated(address target) {
1255     assert(target == NULL || (uintptr_t)target &gt;= (uintptr_t)os::vm_page_size(), INTPTR_FORMAT, (intptr_t)target);
1256     return target != NULL;
1257   }
1258 
1259  private:
1260   address _target;                  // address in runtime
1261 
<span class="line-modified">1262   external_word_Relocation(address target) {</span>
<span class="line-modified">1263     _target = target;</span>
<span class="line-removed">1264   }</span>
1265 
1266   friend class RelocIterator;
<span class="line-modified">1267   external_word_Relocation() { }</span>
1268 
1269  public:
1270   // data is packed as a well-known address in &quot;1_int&quot; format:  [a] or [Aa]
1271   // The function runtime_address_to_index is used to turn full addresses
1272   // to short indexes, if they are pre-registered by the stub mechanism.
1273   // If the &quot;a&quot; value is 0 (i.e., _target is NULL), the address is stored
1274   // in the code stream.  See external_word_Relocation::target().
1275   void pack_data_to(CodeSection* dest);
1276   void unpack_data();
1277 
1278   void fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest);
1279   address  target();        // if _target==NULL, fetch addr from code stream
1280   address  value()          { return target(); }
1281 };
1282 
1283 class internal_word_Relocation : public DataRelocation {
<span class="line-removed">1284   relocInfo::relocType type() { return relocInfo::internal_word_type; }</span>
1285 
1286  public:
1287   static RelocationHolder spec(address target) {
1288     assert(target != NULL, &quot;must not be null&quot;);
1289     RelocationHolder rh = newHolder();
1290     new(rh) internal_word_Relocation(target);
1291     return rh;
1292   }
1293 
1294   // use this one where all the bits of the target can fit in the code stream:
1295   static RelocationHolder spec_for_immediate() {
1296     RelocationHolder rh = newHolder();
1297     new(rh) internal_word_Relocation(NULL);
1298     return rh;
1299   }
1300 
<span class="line-modified">1301   internal_word_Relocation(address target) {</span>
<span class="line-modified">1302     _target  = target;</span>
<span class="line-modified">1303     _section = -1;  // self-relative</span>
<span class="line-modified">1304   }</span>
1305 
1306  protected:
1307   address _target;                  // address in CodeBlob
1308   int     _section;                 // section providing base address, if any
1309 
1310   friend class RelocIterator;
<span class="line-modified">1311   internal_word_Relocation() { }</span>

1312 
1313   // bit-width of LSB field in packed offset, if section &gt;= 0
1314   enum { section_width = 2 }; // must equal CodeBuffer::sect_bits
1315 
1316  public:
1317   // data is packed as a scaled offset in &quot;1_int&quot; format:  [o] or [Oo]
1318   // If the &quot;o&quot; value is 0 (i.e., _target is NULL), the offset is stored
1319   // in the code stream.  See internal_word_Relocation::target().
1320   // If _section is not -1, it is appended to the low bits of the offset.
1321   void pack_data_to(CodeSection* dest);
1322   void unpack_data();
1323 
1324   void fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest);
1325   address  target();        // if _target==NULL, fetch addr from code stream
1326   int      section()        { return _section;   }
1327   address  value()          { return target();   }
1328 };
1329 
1330 class section_word_Relocation : public internal_word_Relocation {
<span class="line-removed">1331   relocInfo::relocType type() { return relocInfo::section_word_type; }</span>
<span class="line-removed">1332 </span>
1333  public:
1334   static RelocationHolder spec(address target, int section) {
1335     RelocationHolder rh = newHolder();
1336     new(rh) section_word_Relocation(target, section);
1337     return rh;
1338   }
1339 
<span class="line-modified">1340   section_word_Relocation(address target, int section) {</span>

1341     assert(target != NULL, &quot;must not be null&quot;);
<span class="line-modified">1342     assert(section &gt;= 0, &quot;must be a valid section&quot;);</span>
<span class="line-removed">1343     _target  = target;</span>
<span class="line-removed">1344     _section = section;</span>
1345   }
1346 
1347   //void pack_data_to -- inherited
1348   void unpack_data();
1349 
1350  private:
1351   friend class RelocIterator;
<span class="line-modified">1352   section_word_Relocation() { }</span>
1353 };
1354 
1355 
1356 class poll_Relocation : public Relocation {
1357   bool          is_data()                      { return true; }
<span class="line-removed">1358   relocInfo::relocType type() { return relocInfo::poll_type; }</span>
1359   void     fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest);


1360 };
1361 
1362 class poll_return_Relocation : public poll_Relocation {
<span class="line-modified">1363   relocInfo::relocType type() { return relocInfo::poll_return_type; }</span>

1364 };
1365 
1366 // We know all the xxx_Relocation classes, so now we can define these:
1367 #define EACH_CASE(name)                                         \
1368 inline name##_Relocation* RelocIterator::name##_reloc() {       \
1369   assert(type() == relocInfo::name##_type, &quot;type must agree&quot;);  \
1370   /* The purpose of the placed &quot;new&quot; is to re-use the same */   \
1371   /* stack storage for each new iteration. */                   \
1372   name##_Relocation* r = new(_rh) name##_Relocation();          \
1373   r-&gt;set_binding(this);                                         \
1374   r-&gt;name##_Relocation::unpack_data();                          \
1375   return r;                                                     \
1376 }
1377 APPLY_TO_RELOCATIONS(EACH_CASE);
1378 #undef EACH_CASE
1379 
1380 inline RelocIterator::RelocIterator(CompiledMethod* nm, address begin, address limit) {
1381   initialize(nm, begin, limit);
1382 }
1383 
</pre>
</td>
<td>
<hr />
<pre>
 498 //   RelocIterator iter(nm);
 499 //   while (iter.next()) {
 500 //     iter.reloc()-&gt;some_operation();
 501 //   }
 502 // or:
 503 //   RelocIterator iter(nm);
 504 //   while (iter.next()) {
 505 //     switch (iter.type()) {
 506 //      case relocInfo::oop_type          :
 507 //      case relocInfo::ic_type           :
 508 //      case relocInfo::prim_type         :
 509 //      case relocInfo::uncommon_type     :
 510 //      case relocInfo::runtime_call_type :
 511 //      case relocInfo::internal_word_type:
 512 //      case relocInfo::external_word_type:
 513 //      ...
 514 //     }
 515 //   }
 516 
 517 class RelocIterator : public StackObj {
<span class="line-added"> 518   friend class section_word_Relocation; // for section verification</span>
 519   enum { SECT_LIMIT = 3 };  // must be equal to CodeBuffer::SECT_LIMIT, checked in ctor
 520   friend class Relocation;
<span class="line-modified"> 521   friend class relocInfo;   // for change_reloc_info_for_address only</span>
 522   typedef relocInfo::relocType relocType;
 523 
 524  private:
 525   address         _limit;   // stop producing relocations after this _addr
 526   relocInfo*      _current; // the current relocation information
 527   relocInfo*      _end;     // end marker; we&#39;re done iterating when _current == _end
 528   CompiledMethod* _code;    // compiled method containing _addr
 529   address         _addr;    // instruction to which the relocation applies
 530   short           _databuf; // spare buffer for compressed data
 531   short*          _data;    // pointer to the relocation&#39;s data
 532   short           _datalen; // number of halfwords in _data
 533 
 534   // Base addresses needed to compute targets of section_word_type relocs.
 535   address _section_start[SECT_LIMIT];
 536   address _section_end  [SECT_LIMIT];
 537 
 538   void set_has_current(bool b) {
 539     _datalen = !b ? -1 : 0;
 540     debug_only(_data = NULL);
 541   }
</pre>
<hr />
<pre>
 621   // generic relocation accessor; switches on type to call the above
 622   Relocation* reloc();
 623 
 624 #ifndef PRODUCT
 625  public:
 626   void print();
 627   void print_current();
 628 #endif
 629 };
 630 
 631 
 632 // A Relocation is a flyweight object allocated within a RelocationHolder.
 633 // It represents the relocation data of relocation record.
 634 // So, the RelocIterator unpacks relocInfos into Relocations.
 635 
 636 class Relocation {
 637   friend class RelocationHolder;
 638   friend class RelocIterator;
 639 
 640  private:


 641   // When a relocation has been created by a RelocIterator,
 642   // this field is non-null.  It allows the relocation to know
 643   // its context, such as the address to which it applies.
 644   RelocIterator* _binding;
 645 
<span class="line-added"> 646   relocInfo::relocType _rtype;</span>
<span class="line-added"> 647 </span>
 648  protected:
 649   RelocIterator* binding() const {
 650     assert(_binding != NULL, &quot;must be bound&quot;);
 651     return _binding;
 652   }
 653   void set_binding(RelocIterator* b) {
 654     assert(_binding == NULL, &quot;must be unbound&quot;);
 655     _binding = b;
 656     assert(_binding != NULL, &quot;must now be bound&quot;);
 657   }
 658 
<span class="line-modified"> 659   Relocation(relocInfo::relocType rtype) : _binding(NULL), _rtype(rtype) { }</span>


 660 
 661   static RelocationHolder newHolder() {
 662     return RelocationHolder();
 663   }
 664 
 665  public:
 666   void* operator new(size_t size, const RelocationHolder&amp; holder) throw() {
<span class="line-modified"> 667     assert(size &lt;= sizeof(holder._relocbuf), &quot;Make _relocbuf bigger!&quot;);</span>
 668     assert((void* const *)holder.reloc() == &amp;holder._relocbuf[0], &quot;ptrs must agree&quot;);
 669     return holder.reloc();
 670   }
 671 
 672   // make a generic relocation for a given type (if possible)
 673   static RelocationHolder spec_simple(relocInfo::relocType rtype);
 674 
 675   // here is the type-specific hook which writes relocation data:
 676   virtual void pack_data_to(CodeSection* dest) { }
 677 
 678   // here is the type-specific hook which reads (unpacks) relocation data:
 679   virtual void unpack_data() {
 680     assert(datalen()==0 || type()==relocInfo::none, &quot;no data here&quot;);
 681   }
 682 
 683  protected:
 684   // Helper functions for pack_data_to() and unpack_data().
 685 
 686   // Most of the compression logic is confined here.
 687   // (The &quot;immediate data&quot; mechanism of relocInfo works independently
</pre>
<hr />
<pre>
 774     int byte_offset = -( offset * relocInfo::addr_unit() );
 775     return base + byte_offset;
 776   }
 777 
 778   // helpers for mapping between old and new addresses after a move or resize
 779   address old_addr_for(address newa, const CodeBuffer* src, CodeBuffer* dest);
 780   address new_addr_for(address olda, const CodeBuffer* src, CodeBuffer* dest);
 781   void normalize_address(address&amp; addr, const CodeSection* dest, bool allow_other_sections = false);
 782 
 783  public:
 784   // accessors which only make sense for a bound Relocation
 785   address         addr()            const { return binding()-&gt;addr(); }
 786   CompiledMethod* code()            const { return binding()-&gt;code(); }
 787   bool            addr_in_const()   const { return binding()-&gt;addr_in_const(); }
 788  protected:
 789   short*   data()         const { return binding()-&gt;data(); }
 790   int      datalen()      const { return binding()-&gt;datalen(); }
 791   int      format()       const { return binding()-&gt;format(); }
 792 
 793  public:
<span class="line-modified"> 794   relocInfo::relocType type()              const { return _rtype; }</span>
 795 
 796   // is it a call instruction?
 797   virtual bool is_call()                         { return false; }
 798 
 799   // is it a data movement instruction?
 800   virtual bool is_data()                         { return false; }
 801 
 802   // some relocations can compute their own values
 803   virtual address  value();
 804 
 805   // all relocations are able to reassert their values
 806   virtual void set_value(address x);
 807 
 808   virtual bool clear_inline_cache()              { return true; }
 809 
 810   // This method assumes that all virtual/static (inline) caches are cleared (since for static_call_type and
 811   // ic_call_type is not always posisition dependent (depending on the state of the cache)). However, this is
 812   // probably a reasonable assumption, since empty caches simplifies code reloacation.
 813   virtual void fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest) { }
 814 };
 815 
 816 
 817 // certain inlines must be deferred until class Relocation is defined:
 818 
 819 inline RelocationHolder::RelocationHolder() {
 820   // initialize the vtbl, just to keep things type-safe
<span class="line-modified"> 821   new(*this) Relocation(relocInfo::none);</span>
 822 }
 823 
 824 
 825 inline RelocationHolder::RelocationHolder(Relocation* r) {
 826   // wordwise copy from r (ok if it copies garbage after r)
 827   for (int i = 0; i &lt; _relocbuf_size; i++) {
 828     _relocbuf[i] = ((void**)r)[i];
 829   }
 830 }
 831 

 832 relocInfo::relocType RelocationHolder::type() const {
 833   return reloc()-&gt;type();
 834 }
 835 
 836 // A DataRelocation always points at a memory or load-constant instruction..
 837 // It is absolute on most machines, and the constant is split on RISCs.
 838 // The specific subtypes are oop, external_word, and internal_word.
 839 // By convention, the &quot;value&quot; does not include a separately reckoned &quot;offset&quot;.
 840 class DataRelocation : public Relocation {
 841  public:
<span class="line-added"> 842   DataRelocation(relocInfo::relocType type) : Relocation(type) {}</span>
<span class="line-added"> 843 </span>
 844   bool          is_data()                      { return true; }
 845 
 846   // both target and offset must be computed somehow from relocation data
 847   virtual int    offset()                      { return 0; }
 848   address         value()                      = 0;
 849   void        set_value(address x)             { set_value(x, offset()); }
 850   void        set_value(address x, intptr_t o) {
 851     if (addr_in_const())
 852       const_set_data_value(x);
 853     else
 854       pd_set_data_value(x, o);
 855   }
 856   void        verify_value(address x) {
 857     if (addr_in_const())
 858       const_verify_data_value(x);
 859     else
 860       pd_verify_data_value(x, offset());
 861   }
 862 
 863   // The &quot;o&quot; (displacement) argument is relevant only to split relocations
 864   // on RISC machines.  In some CPUs (SPARC), the set-hi and set-lo ins&#39;ns
 865   // can encode more than 32 bits between them.  This allows compilers to
 866   // share set-hi instructions between addresses that differ by a small
 867   // offset (e.g., different static variables in the same class).
 868   // On such machines, the &quot;x&quot; argument to set_value on all set-lo
 869   // instructions must be the same as the &quot;x&quot; argument for the
 870   // corresponding set-hi instructions.  The &quot;o&quot; arguments for the
 871   // set-hi instructions are ignored, and must not affect the high-half
 872   // immediate constant.  The &quot;o&quot; arguments for the set-lo instructions are
 873   // added into the low-half immediate constant, and must not overflow it.
 874 };
 875 
 876 // A CallRelocation always points at a call instruction.
 877 // It is PC-relative on most machines.
 878 class CallRelocation : public Relocation {
 879  public:
<span class="line-added"> 880   CallRelocation(relocInfo::relocType type) : Relocation(type) { }</span>
<span class="line-added"> 881 </span>
 882   bool is_call() { return true; }
 883 
 884   address  destination()                    { return pd_call_destination(); }
 885   void     set_destination(address x); // pd_set_call_destination
 886 
 887   void     fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest);
 888   address  value()                          { return destination();  }
 889   void     set_value(address x)             { set_destination(x); }
 890 };
 891 
 892 class oop_Relocation : public DataRelocation {


 893  public:
 894   // encode in one of these formats:  [] [n] [n l] [Nn l] [Nn Ll]
 895   // an oop in the CodeBlob&#39;s oop pool
 896   static RelocationHolder spec(int oop_index, int offset = 0) {
 897     assert(oop_index &gt; 0, &quot;must be a pool-resident oop&quot;);
 898     RelocationHolder rh = newHolder();
 899     new(rh) oop_Relocation(oop_index, offset);
 900     return rh;
 901   }
 902   // an oop in the instruction stream
 903   static RelocationHolder spec_for_immediate() {
 904     // If no immediate oops are generated, we can skip some walks over nmethods.
 905     // Assert that they don&#39;t get generated accidently!
 906     assert(relocInfo::mustIterateImmediateOopsInCode(),
 907            &quot;Must return true so we will search for oops as roots etc. in the code.&quot;);
 908     const int oop_index = 0;
 909     const int offset    = 0;    // if you want an offset, use the oop pool
 910     RelocationHolder rh = newHolder();
 911     new(rh) oop_Relocation(oop_index, offset);
 912     return rh;
 913   }
 914 
 915  private:
 916   jint _oop_index;                  // if &gt; 0, index into CodeBlob::oop_at
 917   jint _offset;                     // byte offset to apply to the oop itself
 918 
<span class="line-modified"> 919   oop_Relocation(int oop_index, int offset)</span>
<span class="line-modified"> 920     : DataRelocation(relocInfo::oop_type), _oop_index(oop_index), _offset(offset) { }</span>

 921 
 922   friend class RelocIterator;
<span class="line-modified"> 923   oop_Relocation() : DataRelocation(relocInfo::oop_type) {}</span>
 924 
 925  public:
 926   int oop_index() { return _oop_index; }
 927   int offset()    { return _offset; }
 928 
 929   // data is packed in &quot;2_ints&quot; format:  [i o] or [Ii Oo]
 930   void pack_data_to(CodeSection* dest);
 931   void unpack_data();
 932 
 933   void fix_oop_relocation();        // reasserts oop value
 934 
 935   void verify_oop_relocation();
 936 
 937   address value()  { return cast_from_oop&lt;address&gt;(*oop_addr()); }
 938 
 939   bool oop_is_immediate()  { return oop_index() == 0; }
 940 
 941   oop* oop_addr();                  // addr or &amp;pool[jint_data]
 942   oop  oop_value();                 // *oop_addr
 943   // Note:  oop_value transparently converts Universe::non_oop_word to NULL.
 944 };
 945 
 946 
 947 // copy of oop_Relocation for now but may delete stuff in both/either
 948 class metadata_Relocation : public DataRelocation {

 949 
 950  public:
 951   // encode in one of these formats:  [] [n] [n l] [Nn l] [Nn Ll]
 952   // an metadata in the CodeBlob&#39;s metadata pool
 953   static RelocationHolder spec(int metadata_index, int offset = 0) {
 954     assert(metadata_index &gt; 0, &quot;must be a pool-resident metadata&quot;);
 955     RelocationHolder rh = newHolder();
 956     new(rh) metadata_Relocation(metadata_index, offset);
 957     return rh;
 958   }
 959   // an metadata in the instruction stream
 960   static RelocationHolder spec_for_immediate() {
 961     const int metadata_index = 0;
 962     const int offset    = 0;    // if you want an offset, use the metadata pool
 963     RelocationHolder rh = newHolder();
 964     new(rh) metadata_Relocation(metadata_index, offset);
 965     return rh;
 966   }
 967 
 968  private:
 969   jint _metadata_index;            // if &gt; 0, index into nmethod::metadata_at
 970   jint _offset;                     // byte offset to apply to the metadata itself
 971 
<span class="line-modified"> 972   metadata_Relocation(int metadata_index, int offset)</span>
<span class="line-modified"> 973     : DataRelocation(relocInfo::metadata_type), _metadata_index(metadata_index), _offset(offset) { }</span>

 974 
 975   friend class RelocIterator;
<span class="line-modified"> 976   metadata_Relocation() : DataRelocation(relocInfo::metadata_type) { }</span>
 977 
 978   // Fixes a Metadata pointer in the code. Most platforms embeds the
 979   // Metadata pointer in the code at compile time so this is empty
 980   // for them.
 981   void pd_fix_value(address x);
 982 
 983  public:
 984   int metadata_index() { return _metadata_index; }
 985   int offset()    { return _offset; }
 986 
 987   // data is packed in &quot;2_ints&quot; format:  [i o] or [Ii Oo]
 988   void pack_data_to(CodeSection* dest);
 989   void unpack_data();
 990 
 991   void fix_metadata_relocation();        // reasserts metadata value
 992 
 993   address value()  { return (address) *metadata_addr(); }
 994 
 995   bool metadata_is_immediate()  { return metadata_index() == 0; }
 996 
 997   Metadata**   metadata_addr();                  // addr or &amp;pool[jint_data]
 998   Metadata*    metadata_value();                 // *metadata_addr
 999   // Note:  metadata_value transparently converts Universe::non_metadata_word to NULL.
1000 };
1001 
1002 
1003 class virtual_call_Relocation : public CallRelocation {

1004 
1005  public:
1006   // &quot;cached_value&quot; points to the first associated set-oop.
1007   // The oop_limit helps find the last associated set-oop.
1008   // (See comments at the top of this file.)
1009   static RelocationHolder spec(address cached_value, jint method_index = 0) {
1010     RelocationHolder rh = newHolder();
1011     new(rh) virtual_call_Relocation(cached_value, method_index);
1012     return rh;
1013   }
1014 
1015  private:
1016   address _cached_value; // location of set-value instruction
1017   jint    _method_index; // resolved method for a Java call
1018 
<span class="line-modified">1019   virtual_call_Relocation(address cached_value, int method_index)</span>
<span class="line-modified">1020     : CallRelocation(relocInfo::virtual_call_type),</span>
<span class="line-modified">1021       _cached_value(cached_value),</span>
<span class="line-added">1022       _method_index(method_index) {</span>
1023     assert(cached_value != NULL, &quot;first oop address must be specified&quot;);
1024   }
1025 
1026   friend class RelocIterator;
<span class="line-modified">1027   virtual_call_Relocation() : CallRelocation(relocInfo::virtual_call_type) { }</span>
1028 
1029  public:
1030   address cached_value();
1031 
1032   int     method_index() { return _method_index; }
1033   Method* method_value();
1034 
1035   // data is packed as scaled offsets in &quot;2_ints&quot; format:  [f l] or [Ff Ll]
1036   // oop_limit is set to 0 if the limit falls somewhere within the call.
1037   // When unpacking, a zero oop_limit is taken to refer to the end of the call.
1038   // (This has the effect of bringing in the call&#39;s delay slot on SPARC.)
1039   void pack_data_to(CodeSection* dest);
1040   void unpack_data();
1041 
1042   bool clear_inline_cache();
1043 };
1044 
1045 
1046 class opt_virtual_call_Relocation : public CallRelocation {


1047  public:
1048   static RelocationHolder spec(int method_index = 0) {
1049     RelocationHolder rh = newHolder();
1050     new(rh) opt_virtual_call_Relocation(method_index);
1051     return rh;
1052   }
1053 
1054  private:
1055   jint _method_index; // resolved method for a Java call
1056 
<span class="line-modified">1057   opt_virtual_call_Relocation(int method_index)</span>
<span class="line-modified">1058     : CallRelocation(relocInfo::opt_virtual_call_type),</span>
<span class="line-modified">1059       _method_index(method_index) { }</span>
1060 
1061   friend class RelocIterator;
<span class="line-modified">1062   opt_virtual_call_Relocation() : CallRelocation(relocInfo::opt_virtual_call_type) {}</span>
1063 
1064  public:
1065   int     method_index() { return _method_index; }
1066   Method* method_value();
1067 
1068   void pack_data_to(CodeSection* dest);
1069   void unpack_data();
1070 
1071   bool clear_inline_cache();
1072 
1073   // find the matching static_stub
1074   address static_stub(bool is_aot);
1075 };
1076 
1077 
1078 class static_call_Relocation : public CallRelocation {


1079  public:
1080   static RelocationHolder spec(int method_index = 0) {
1081     RelocationHolder rh = newHolder();
1082     new(rh) static_call_Relocation(method_index);
1083     return rh;
1084   }
1085 
1086  private:
1087   jint _method_index; // resolved method for a Java call
1088 
<span class="line-modified">1089   static_call_Relocation(int method_index)</span>
<span class="line-modified">1090     : CallRelocation(relocInfo::static_call_type),</span>
<span class="line-modified">1091     _method_index(method_index) { }</span>
1092 
1093   friend class RelocIterator;
<span class="line-modified">1094   static_call_Relocation() : CallRelocation(relocInfo::static_call_type) {}</span>
1095 
1096  public:
1097   int     method_index() { return _method_index; }
1098   Method* method_value();
1099 
1100   void pack_data_to(CodeSection* dest);
1101   void unpack_data();
1102 
1103   bool clear_inline_cache();
1104 
1105   // find the matching static_stub
1106   address static_stub(bool is_aot);
1107 };
1108 
1109 class static_stub_Relocation : public Relocation {


1110  public:
1111   static RelocationHolder spec(address static_call, bool is_aot = false) {
1112     RelocationHolder rh = newHolder();
1113     new(rh) static_stub_Relocation(static_call, is_aot);
1114     return rh;
1115   }
1116 
1117  private:
1118   address _static_call;  // location of corresponding static_call
1119   bool _is_aot;          // trampoline to aot code
1120 
<span class="line-modified">1121   static_stub_Relocation(address static_call, bool is_aot)</span>
<span class="line-modified">1122     : Relocation(relocInfo::static_stub_type),</span>
<span class="line-modified">1123       _static_call(static_call), _is_aot(is_aot) { }</span>

1124 
1125   friend class RelocIterator;
<span class="line-modified">1126   static_stub_Relocation() : Relocation(relocInfo::static_stub_type) { }</span>
1127 
1128  public:
1129   bool clear_inline_cache();
1130 
1131   address static_call() { return _static_call; }
1132   bool is_aot() { return _is_aot; }
1133 
1134   // data is packed as a scaled offset in &quot;1_int&quot; format:  [c] or [Cc]
1135   void pack_data_to(CodeSection* dest);
1136   void unpack_data();
1137 };
1138 
1139 class runtime_call_Relocation : public CallRelocation {

1140 
1141  public:
1142   static RelocationHolder spec() {
1143     RelocationHolder rh = newHolder();
1144     new(rh) runtime_call_Relocation();
1145     return rh;
1146   }
1147 
1148  private:
1149   friend class RelocIterator;
<span class="line-modified">1150   runtime_call_Relocation() : CallRelocation(relocInfo::runtime_call_type) { }</span>
1151 
1152  public:
1153 };
1154 
1155 
1156 class runtime_call_w_cp_Relocation : public CallRelocation {


1157  public:
1158   static RelocationHolder spec() {
1159     RelocationHolder rh = newHolder();
1160     new(rh) runtime_call_w_cp_Relocation();
1161     return rh;
1162   }
1163 
1164  private:
1165   friend class RelocIterator;
<span class="line-modified">1166   runtime_call_w_cp_Relocation()</span>
<span class="line-added">1167     : CallRelocation(relocInfo::runtime_call_w_cp_type),</span>
<span class="line-added">1168       _offset(-4) /* &lt;0 = invalid */ { }</span>
<span class="line-added">1169 </span>
1170   // On z/Architecture, runtime calls are either a sequence
1171   // of two instructions (load destination of call from constant pool + do call)
1172   // or a pc-relative call. The pc-relative call is faster, but it can only
1173   // be used if the destination of the call is not too far away.
1174   // In order to be able to patch a pc-relative call back into one using
1175   // the constant pool, we have to remember the location of the call&#39;s destination
1176   // in the constant pool.
1177   int _offset;
1178 
1179  public:
1180   void set_constant_pool_offset(int offset) { _offset = offset; }
1181   int get_constant_pool_offset() { return _offset; }
1182   void pack_data_to(CodeSection * dest);
1183   void unpack_data();
1184 };
1185 
1186 // Trampoline Relocations.
1187 // A trampoline allows to encode a small branch in the code, even if there
1188 // is the chance that this branch can not reach all possible code locations.
1189 // If the relocation finds that a branch is too far for the instruction
1190 // in the code, it can patch it to jump to the trampoline where is
1191 // sufficient space for a far branch. Needed on PPC.
1192 class trampoline_stub_Relocation : public Relocation {


1193  public:
1194   static RelocationHolder spec(address static_call) {
1195     RelocationHolder rh = newHolder();
1196     return (new (rh) trampoline_stub_Relocation(static_call));
1197   }
1198 
1199  private:
1200   address _owner;    // Address of the NativeCall that owns the trampoline.
1201 
<span class="line-modified">1202   trampoline_stub_Relocation(address owner)</span>
<span class="line-modified">1203     : Relocation(relocInfo::trampoline_stub_type),</span>
<span class="line-modified">1204       _owner(owner) { }</span>
1205 
1206   friend class RelocIterator;
<span class="line-modified">1207   trampoline_stub_Relocation() : Relocation(relocInfo::trampoline_stub_type) { }</span>
1208 
1209  public:
1210 
1211   // Return the address of the NativeCall that owns the trampoline.
1212   address owner() { return _owner; }
1213 
1214   void pack_data_to(CodeSection * dest);
1215   void unpack_data();
1216 
1217   // Find the trampoline stub for a call.
1218   static address get_trampoline_for(address call, nmethod* code);
1219 };
1220 
1221 class external_word_Relocation : public DataRelocation {


1222  public:
1223   static RelocationHolder spec(address target) {
1224     assert(target != NULL, &quot;must not be null&quot;);
1225     RelocationHolder rh = newHolder();
1226     new(rh) external_word_Relocation(target);
1227     return rh;
1228   }
1229 
1230   // Use this one where all 32/64 bits of the target live in the code stream.
1231   // The target must be an intptr_t, and must be absolute (not relative).
1232   static RelocationHolder spec_for_immediate() {
1233     RelocationHolder rh = newHolder();
1234     new(rh) external_word_Relocation(NULL);
1235     return rh;
1236   }
1237 
1238   // Some address looking values aren&#39;t safe to treat as relocations
1239   // and should just be treated as constants.
1240   static bool can_be_relocated(address target) {
1241     assert(target == NULL || (uintptr_t)target &gt;= (uintptr_t)os::vm_page_size(), INTPTR_FORMAT, (intptr_t)target);
1242     return target != NULL;
1243   }
1244 
1245  private:
1246   address _target;                  // address in runtime
1247 
<span class="line-modified">1248   external_word_Relocation(address target)</span>
<span class="line-modified">1249     : DataRelocation(relocInfo::external_word_type), _target(target) { }</span>

1250 
1251   friend class RelocIterator;
<span class="line-modified">1252   external_word_Relocation() : DataRelocation(relocInfo::external_word_type) { }</span>
1253 
1254  public:
1255   // data is packed as a well-known address in &quot;1_int&quot; format:  [a] or [Aa]
1256   // The function runtime_address_to_index is used to turn full addresses
1257   // to short indexes, if they are pre-registered by the stub mechanism.
1258   // If the &quot;a&quot; value is 0 (i.e., _target is NULL), the address is stored
1259   // in the code stream.  See external_word_Relocation::target().
1260   void pack_data_to(CodeSection* dest);
1261   void unpack_data();
1262 
1263   void fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest);
1264   address  target();        // if _target==NULL, fetch addr from code stream
1265   address  value()          { return target(); }
1266 };
1267 
1268 class internal_word_Relocation : public DataRelocation {

1269 
1270  public:
1271   static RelocationHolder spec(address target) {
1272     assert(target != NULL, &quot;must not be null&quot;);
1273     RelocationHolder rh = newHolder();
1274     new(rh) internal_word_Relocation(target);
1275     return rh;
1276   }
1277 
1278   // use this one where all the bits of the target can fit in the code stream:
1279   static RelocationHolder spec_for_immediate() {
1280     RelocationHolder rh = newHolder();
1281     new(rh) internal_word_Relocation(NULL);
1282     return rh;
1283   }
1284 
<span class="line-modified">1285   // default section -1 means self-relative</span>
<span class="line-modified">1286   internal_word_Relocation(address target, int section = -1,</span>
<span class="line-modified">1287     relocInfo::relocType type = relocInfo::internal_word_type)</span>
<span class="line-modified">1288     : DataRelocation(type), _target(target), _section(section) { }</span>
1289 
1290  protected:
1291   address _target;                  // address in CodeBlob
1292   int     _section;                 // section providing base address, if any
1293 
1294   friend class RelocIterator;
<span class="line-modified">1295   internal_word_Relocation(relocInfo::relocType type = relocInfo::internal_word_type)</span>
<span class="line-added">1296     : DataRelocation(type) { }</span>
1297 
1298   // bit-width of LSB field in packed offset, if section &gt;= 0
1299   enum { section_width = 2 }; // must equal CodeBuffer::sect_bits
1300 
1301  public:
1302   // data is packed as a scaled offset in &quot;1_int&quot; format:  [o] or [Oo]
1303   // If the &quot;o&quot; value is 0 (i.e., _target is NULL), the offset is stored
1304   // in the code stream.  See internal_word_Relocation::target().
1305   // If _section is not -1, it is appended to the low bits of the offset.
1306   void pack_data_to(CodeSection* dest);
1307   void unpack_data();
1308 
1309   void fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest);
1310   address  target();        // if _target==NULL, fetch addr from code stream
1311   int      section()        { return _section;   }
1312   address  value()          { return target();   }
1313 };
1314 
1315 class section_word_Relocation : public internal_word_Relocation {


1316  public:
1317   static RelocationHolder spec(address target, int section) {
1318     RelocationHolder rh = newHolder();
1319     new(rh) section_word_Relocation(target, section);
1320     return rh;
1321   }
1322 
<span class="line-modified">1323   section_word_Relocation(address target, int section)</span>
<span class="line-added">1324     : internal_word_Relocation(target, section, relocInfo::section_word_type) {</span>
1325     assert(target != NULL, &quot;must not be null&quot;);
<span class="line-modified">1326     assert(section &gt;= 0 &amp;&amp; section &lt; RelocIterator::SECT_LIMIT, &quot;must be a valid section&quot;);</span>


1327   }
1328 
1329   //void pack_data_to -- inherited
1330   void unpack_data();
1331 
1332  private:
1333   friend class RelocIterator;
<span class="line-modified">1334   section_word_Relocation() : internal_word_Relocation(relocInfo::section_word_type) { }</span>
1335 };
1336 
1337 
1338 class poll_Relocation : public Relocation {
1339   bool          is_data()                      { return true; }

1340   void     fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest);
<span class="line-added">1341  public:</span>
<span class="line-added">1342   poll_Relocation(relocInfo::relocType type = relocInfo::poll_type) : Relocation(type) { }</span>
1343 };
1344 
1345 class poll_return_Relocation : public poll_Relocation {
<span class="line-modified">1346  public:</span>
<span class="line-added">1347   poll_return_Relocation() : poll_Relocation(relocInfo::relocInfo::poll_return_type) { }</span>
1348 };
1349 
1350 // We know all the xxx_Relocation classes, so now we can define these:
1351 #define EACH_CASE(name)                                         \
1352 inline name##_Relocation* RelocIterator::name##_reloc() {       \
1353   assert(type() == relocInfo::name##_type, &quot;type must agree&quot;);  \
1354   /* The purpose of the placed &quot;new&quot; is to re-use the same */   \
1355   /* stack storage for each new iteration. */                   \
1356   name##_Relocation* r = new(_rh) name##_Relocation();          \
1357   r-&gt;set_binding(this);                                         \
1358   r-&gt;name##_Relocation::unpack_data();                          \
1359   return r;                                                     \
1360 }
1361 APPLY_TO_RELOCATIONS(EACH_CASE);
1362 #undef EACH_CASE
1363 
1364 inline RelocIterator::RelocIterator(CompiledMethod* nm, address begin, address limit) {
1365   initialize(nm, begin, limit);
1366 }
1367 
</pre>
</td>
</tr>
</table>
<center><a href="relocInfo.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vtableStubs.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
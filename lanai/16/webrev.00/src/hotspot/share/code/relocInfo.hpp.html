<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/code/relocInfo.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_CODE_RELOCINFO_HPP
  26 #define SHARE_CODE_RELOCINFO_HPP
  27 
  28 #include &quot;runtime/os.hpp&quot;
  29 #include &quot;utilities/macros.hpp&quot;
  30 
  31 class nmethod;
  32 class CodeBlob;
  33 class CompiledMethod;
  34 class Metadata;
  35 class NativeMovConstReg;
  36 
  37 // Types in this file:
  38 //    relocInfo
  39 //      One element of an array of halfwords encoding compressed relocations.
  40 //      Also, the source of relocation types (relocInfo::oop_type, ...).
  41 //    Relocation
  42 //      A flyweight object representing a single relocation.
  43 //      It is fully unpacked from the compressed relocation array.
  44 //    metadata_Relocation, ... (subclasses of Relocation)
  45 //      The location of some type-specific operations (metadata_addr, ...).
  46 //      Also, the source of relocation specs (metadata_Relocation::spec, ...).
  47 //    oop_Relocation, ... (subclasses of Relocation)
  48 //      oops in the code stream (strings, class loaders)
  49 //      Also, the source of relocation specs (oop_Relocation::spec, ...).
  50 //    RelocationHolder
  51 //      A value type which acts as a union holding a Relocation object.
  52 //      Represents a relocation spec passed into a CodeBuffer during assembly.
  53 //    RelocIterator
  54 //      A StackObj which iterates over the relocations associated with
  55 //      a range of code addresses.  Can be used to operate a copy of code.
  56 //    BoundRelocation
  57 //      An _internal_ type shared by packers and unpackers of relocations.
  58 //      It pastes together a RelocationHolder with some pointers into
  59 //      code and relocInfo streams.
  60 
  61 
  62 // Notes on relocType:
  63 //
  64 // These hold enough information to read or write a value embedded in
  65 // the instructions of an CodeBlob.  They&#39;re used to update:
  66 //
  67 //   1) embedded oops     (isOop()          == true)
  68 //   2) inline caches     (isIC()           == true)
  69 //   3) runtime calls     (isRuntimeCall()  == true)
  70 //   4) internal word ref (isInternalWord() == true)
  71 //   5) external word ref (isExternalWord() == true)
  72 //
  73 // when objects move (GC) or if code moves (compacting the code heap).
  74 // They are also used to patch the code (if a call site must change)
  75 //
  76 // A relocInfo is represented in 16 bits:
  77 //   4 bits indicating the relocation type
  78 //  12 bits indicating the offset from the previous relocInfo address
  79 //
  80 // The offsets accumulate along the relocInfo stream to encode the
  81 // address within the CodeBlob, which is named RelocIterator::addr().
  82 // The address of a particular relocInfo always points to the first
  83 // byte of the relevant instruction (and not to any of its subfields
  84 // or embedded immediate constants).
  85 //
  86 // The offset value is scaled appropriately for the target machine.
  87 // (See relocInfo_&lt;arch&gt;.hpp for the offset scaling.)
  88 //
  89 // On some machines, there may also be a &quot;format&quot; field which may provide
  90 // additional information about the format of the instruction stream
  91 // at the corresponding code address.  The format value is usually zero.
  92 // Any machine (such as Intel) whose instructions can sometimes contain
  93 // more than one relocatable constant needs format codes to distinguish
  94 // which operand goes with a given relocation.
  95 //
  96 // If the target machine needs N format bits, the offset has 12-N bits,
  97 // the format is encoded between the offset and the type, and the
  98 // relocInfo_&lt;arch&gt;.hpp file has manifest constants for the format codes.
  99 //
 100 // If the type is &quot;data_prefix_tag&quot; then the offset bits are further encoded,
 101 // and in fact represent not a code-stream offset but some inline data.
 102 // The data takes the form of a counted sequence of halfwords, which
 103 // precedes the actual relocation record.  (Clients never see it directly.)
 104 // The interpetation of this extra data depends on the relocation type.
 105 //
 106 // On machines that have 32-bit immediate fields, there is usually
 107 // little need for relocation &quot;prefix&quot; data, because the instruction stream
 108 // is a perfectly reasonable place to store the value.  On machines in
 109 // which 32-bit values must be &quot;split&quot; across instructions, the relocation
 110 // data is the &quot;true&quot; specification of the value, which is then applied
 111 // to some field of the instruction (22 or 13 bits, on SPARC).
 112 //
 113 // Whenever the location of the CodeBlob changes, any PC-relative
 114 // relocations, and any internal_word_type relocations, must be reapplied.
 115 // After the GC runs, oop_type relocations must be reapplied.
 116 //
 117 //
 118 // Here are meanings of the types:
 119 //
 120 // relocInfo::none -- a filler record
 121 //   Value:  none
 122 //   Instruction: The corresponding code address is ignored
 123 //   Data:  Any data prefix and format code are ignored
 124 //   (This means that any relocInfo can be disabled by setting
 125 //   its type to none.  See relocInfo::remove.)
 126 //
 127 // relocInfo::oop_type, relocInfo::metadata_type -- a reference to an oop or meta data
 128 //   Value:  an oop, or else the address (handle) of an oop
 129 //   Instruction types: memory (load), set (load address)
 130 //   Data:  []       an oop stored in 4 bytes of instruction
 131 //          [n]      n is the index of an oop in the CodeBlob&#39;s oop pool
 132 //          [[N]n l] and l is a byte offset to be applied to the oop
 133 //          [Nn Ll]  both index and offset may be 32 bits if necessary
 134 //   Here is a special hack, used only by the old compiler:
 135 //          [[N]n 00] the value is the __address__ of the nth oop in the pool
 136 //   (Note that the offset allows optimal references to class variables.)
 137 //
 138 // relocInfo::internal_word_type -- an address within the same CodeBlob
 139 // relocInfo::section_word_type -- same, but can refer to another section
 140 //   Value:  an address in the CodeBlob&#39;s code or constants section
 141 //   Instruction types: memory (load), set (load address)
 142 //   Data:  []     stored in 4 bytes of instruction
 143 //          [[L]l] a relative offset (see [About Offsets] below)
 144 //   In the case of section_word_type, the offset is relative to a section
 145 //   base address, and the section number (e.g., SECT_INSTS) is encoded
 146 //   into the low two bits of the offset L.
 147 //
 148 // relocInfo::external_word_type -- a fixed address in the runtime system
 149 //   Value:  an address
 150 //   Instruction types: memory (load), set (load address)
 151 //   Data:  []   stored in 4 bytes of instruction
 152 //          [n]  the index of a &quot;well-known&quot; stub (usual case on RISC)
 153 //          [Ll] a 32-bit address
 154 //
 155 // relocInfo::runtime_call_type -- a fixed subroutine in the runtime system
 156 //   Value:  an address
 157 //   Instruction types: PC-relative call (or a PC-relative branch)
 158 //   Data:  []   stored in 4 bytes of instruction
 159 //
 160 // relocInfo::static_call_type -- a static call
 161 //   Value:  an CodeBlob, a stub, or a fixup routine
 162 //   Instruction types: a call
 163 //   Data:  []
 164 //   The identity of the callee is extracted from debugging information.
 165 //   //%note reloc_3
 166 //
 167 // relocInfo::virtual_call_type -- a virtual call site (which includes an inline
 168 //                                 cache)
 169 //   Value:  an CodeBlob, a stub, the interpreter, or a fixup routine
 170 //   Instruction types: a call, plus some associated set-oop instructions
 171 //   Data:  []       the associated set-oops are adjacent to the call
 172 //          [n]      n is a relative offset to the first set-oop
 173 //          [[N]n l] and l is a limit within which the set-oops occur
 174 //          [Nn Ll]  both n and l may be 32 bits if necessary
 175 //   The identity of the callee is extracted from debugging information.
 176 //
 177 // relocInfo::opt_virtual_call_type -- a virtual call site that is statically bound
 178 //
 179 //    Same info as a static_call_type. We use a special type, so the handling of
 180 //    virtuals and statics are separated.
 181 //
 182 //
 183 //   The offset n points to the first set-oop.  (See [About Offsets] below.)
 184 //   In turn, the set-oop instruction specifies or contains an oop cell devoted
 185 //   exclusively to the IC call, which can be patched along with the call.
 186 //
 187 //   The locations of any other set-oops are found by searching the relocation
 188 //   information starting at the first set-oop, and continuing until all
 189 //   relocations up through l have been inspected.  The value l is another
 190 //   relative offset.  (Both n and l are relative to the call&#39;s first byte.)
 191 //
 192 //   The limit l of the search is exclusive.  However, if it points within
 193 //   the call (e.g., offset zero), it is adjusted to point after the call and
 194 //   any associated machine-specific delay slot.
 195 //
 196 //   Since the offsets could be as wide as 32-bits, these conventions
 197 //   put no restrictions whatever upon code reorganization.
 198 //
 199 //   The compiler is responsible for ensuring that transition from a clean
 200 //   state to a monomorphic compiled state is MP-safe.  This implies that
 201 //   the system must respond well to intermediate states where a random
 202 //   subset of the set-oops has been correctly from the clean state
 203 //   upon entry to the VEP of the compiled method.  In the case of a
 204 //   machine (Intel) with a single set-oop instruction, the 32-bit
 205 //   immediate field must not straddle a unit of memory coherence.
 206 //   //%note reloc_3
 207 //
 208 // relocInfo::static_stub_type -- an extra stub for each static_call_type
 209 //   Value:  none
 210 //   Instruction types: a virtual call:  { set_oop; jump; }
 211 //   Data:  [[N]n]  the offset of the associated static_call reloc
 212 //   This stub becomes the target of a static call which must be upgraded
 213 //   to a virtual call (because the callee is interpreted).
 214 //   See [About Offsets] below.
 215 //   //%note reloc_2
 216 //
 217 // relocInfo::poll_[return_]type -- a safepoint poll
 218 //   Value:  none
 219 //   Instruction types: memory load or test
 220 //   Data:  none
 221 //
 222 // For example:
 223 //
 224 //   INSTRUCTIONS                        RELOC: TYPE    PREFIX DATA
 225 //   ------------                               ----    -----------
 226 // sethi      %hi(myObject),  R               oop_type [n(myObject)]
 227 // ld      [R+%lo(myObject)+fldOffset], R2    oop_type [n(myObject) fldOffset]
 228 // add R2, 1, R2
 229 // st  R2, [R+%lo(myObject)+fldOffset]        oop_type [n(myObject) fldOffset]
 230 //%note reloc_1
 231 //
 232 // This uses 4 instruction words, 8 relocation halfwords,
 233 // and an entry (which is sharable) in the CodeBlob&#39;s oop pool,
 234 // for a total of 36 bytes.
 235 //
 236 // Note that the compiler is responsible for ensuring the &quot;fldOffset&quot; when
 237 // added to &quot;%lo(myObject)&quot; does not overflow the immediate fields of the
 238 // memory instructions.
 239 //
 240 //
 241 // [About Offsets] Relative offsets are supplied to this module as
 242 // positive byte offsets, but they may be internally stored scaled
 243 // and/or negated, depending on what is most compact for the target
 244 // system.  Since the object pointed to by the offset typically
 245 // precedes the relocation address, it is profitable to store
 246 // these negative offsets as positive numbers, but this decision
 247 // is internal to the relocation information abstractions.
 248 //
 249 
 250 class Relocation;
 251 class CodeBuffer;
 252 class CodeSection;
 253 class RelocIterator;
 254 
 255 class relocInfo {
 256   friend class RelocIterator;
 257  public:
 258   enum relocType {
 259     none                    =  0, // Used when no relocation should be generated
 260     oop_type                =  1, // embedded oop
 261     virtual_call_type       =  2, // a standard inline cache call for a virtual send
 262     opt_virtual_call_type   =  3, // a virtual call that has been statically bound (i.e., no IC cache)
 263     static_call_type        =  4, // a static send
 264     static_stub_type        =  5, // stub-entry for static send  (takes care of interpreter case)
 265     runtime_call_type       =  6, // call to fixed external routine
 266     external_word_type      =  7, // reference to fixed external address
 267     internal_word_type      =  8, // reference within the current code blob
 268     section_word_type       =  9, // internal, but a cross-section reference
 269     poll_type               = 10, // polling instruction for safepoints
 270     poll_return_type        = 11, // polling instruction for safepoints at return
 271     metadata_type           = 12, // metadata that used to be oops
 272     trampoline_stub_type    = 13, // stub-entry for trampoline
 273     runtime_call_w_cp_type  = 14, // Runtime call which may load its target from the constant pool
 274     data_prefix_tag         = 15, // tag for a prefix (carries data arguments)
 275     type_mask               = 15  // A mask which selects only the above values
 276   };
 277 
 278  protected:
 279   unsigned short _value;
 280 
 281   enum RawBitsToken { RAW_BITS };
 282   relocInfo(relocType type, RawBitsToken ignore, int bits)
 283     : _value((type &lt;&lt; nontype_width) + bits) { }
 284 
 285   relocInfo(relocType type, RawBitsToken ignore, int off, int f)
 286     : _value((type &lt;&lt; nontype_width) + (off / (unsigned)offset_unit) + (f &lt;&lt; offset_width)) { }
 287 
 288  public:
 289   // constructor
 290   relocInfo(relocType type, int offset, int format = 0)
 291 #ifndef ASSERT
 292   {
 293     (*this) = relocInfo(type, RAW_BITS, offset, format);
 294   }
 295 #else
 296   // Put a bunch of assertions out-of-line.
 297   ;
 298 #endif
 299 
 300   #define APPLY_TO_RELOCATIONS(visitor) \
 301     visitor(oop) \
 302     visitor(metadata) \
 303     visitor(virtual_call) \
 304     visitor(opt_virtual_call) \
 305     visitor(static_call) \
 306     visitor(static_stub) \
 307     visitor(runtime_call) \
 308     visitor(runtime_call_w_cp) \
 309     visitor(external_word) \
 310     visitor(internal_word) \
 311     visitor(poll) \
 312     visitor(poll_return) \
 313     visitor(section_word) \
 314     visitor(trampoline_stub) \
 315 
 316 
 317  public:
 318   enum {
 319     value_width             = sizeof(unsigned short) * BitsPerByte,
 320     type_width              = 4,   // == log2(type_mask+1)
 321     nontype_width           = value_width - type_width,
 322     datalen_width           = nontype_width-1,
 323     datalen_tag             = 1 &lt;&lt; datalen_width,  // or-ed into _value
 324     datalen_limit           = 1 &lt;&lt; datalen_width,
 325     datalen_mask            = (1 &lt;&lt; datalen_width)-1
 326   };
 327 
 328   // accessors
 329  public:
 330   relocType  type()       const { return (relocType)((unsigned)_value &gt;&gt; nontype_width); }
 331   int  format()           const { return format_mask==0? 0: format_mask &amp;
 332                                          ((unsigned)_value &gt;&gt; offset_width); }
 333   int  addr_offset()      const { assert(!is_prefix(), &quot;must have offset&quot;);
 334                                   return (_value &amp; offset_mask)*offset_unit; }
 335 
 336  protected:
 337   const short* data()     const { assert(is_datalen(), &quot;must have data&quot;);
 338                                   return (const short*)(this + 1); }
 339   int          datalen()  const { assert(is_datalen(), &quot;must have data&quot;);
 340                                   return (_value &amp; datalen_mask); }
 341   int         immediate() const { assert(is_immediate(), &quot;must have immed&quot;);
 342                                   return (_value &amp; datalen_mask); }
 343  public:
 344   static int addr_unit()        { return offset_unit; }
 345   static int offset_limit()     { return (1 &lt;&lt; offset_width) * offset_unit; }
 346 
 347   void set_type(relocType type);
 348 
 349   void remove() { set_type(none); }
 350 
 351  protected:
 352   bool is_none()                const { return type() == none; }
 353   bool is_prefix()              const { return type() == data_prefix_tag; }
 354   bool is_datalen()             const { assert(is_prefix(), &quot;must be prefix&quot;);
 355                                         return (_value &amp; datalen_tag) != 0; }
 356   bool is_immediate()           const { assert(is_prefix(), &quot;must be prefix&quot;);
 357                                         return (_value &amp; datalen_tag) == 0; }
 358 
 359  public:
 360   // Occasionally records of type relocInfo::none will appear in the stream.
 361   // We do not bother to filter these out, but clients should ignore them.
 362   // These records serve as &quot;filler&quot; in three ways:
 363   //  - to skip large spans of unrelocated code (this is rare)
 364   //  - to pad out the relocInfo array to the required oop alignment
 365   //  - to disable old relocation information which is no longer applicable
 366 
 367   inline friend relocInfo filler_relocInfo();
 368 
 369   // Every non-prefix relocation may be preceded by at most one prefix,
 370   // which supplies 1 or more halfwords of associated data.  Conventionally,
 371   // an int is represented by 0, 1, or 2 halfwords, depending on how
 372   // many bits are required to represent the value.  (In addition,
 373   // if the sole halfword is a 10-bit unsigned number, it is made
 374   // &quot;immediate&quot; in the prefix header word itself.  This optimization
 375   // is invisible outside this module.)
 376 
 377   inline friend relocInfo prefix_relocInfo(int datalen);
 378 
 379  protected:
 380   // an immediate relocInfo optimizes a prefix with one 10-bit unsigned value
 381   static relocInfo immediate_relocInfo(int data0) {
 382     assert(fits_into_immediate(data0), &quot;data0 in limits&quot;);
 383     return relocInfo(relocInfo::data_prefix_tag, RAW_BITS, data0);
 384   }
 385   static bool fits_into_immediate(int data0) {
 386     return (data0 &gt;= 0 &amp;&amp; data0 &lt; datalen_limit);
 387   }
 388 
 389  public:
 390   // Support routines for compilers.
 391 
 392   // This routine takes an infant relocInfo (unprefixed) and
 393   // edits in its prefix, if any.  It also updates dest.locs_end.
 394   void initialize(CodeSection* dest, Relocation* reloc);
 395 
 396   // This routine updates a prefix and returns the limit pointer.
 397   // It tries to compress the prefix from 32 to 16 bits, and if
 398   // successful returns a reduced &quot;prefix_limit&quot; pointer.
 399   relocInfo* finish_prefix(short* prefix_limit);
 400 
 401   // bit-packers for the data array:
 402 
 403   // As it happens, the bytes within the shorts are ordered natively,
 404   // but the shorts within the word are ordered big-endian.
 405   // This is an arbitrary choice, made this way mainly to ease debugging.
 406   static int data0_from_int(jint x)         { return x &gt;&gt; value_width; }
 407   static int data1_from_int(jint x)         { return (short)x; }
 408   static jint jint_from_data(short* data) {
 409     return (data[0] &lt;&lt; value_width) + (unsigned short)data[1];
 410   }
 411 
 412   static jint short_data_at(int n, short* data, int datalen) {
 413     return datalen &gt; n ? data[n] : 0;
 414   }
 415 
 416   static jint jint_data_at(int n, short* data, int datalen) {
 417     return datalen &gt; n+1 ? jint_from_data(&amp;data[n]) : short_data_at(n, data, datalen);
 418   }
 419 
 420   // Update methods for relocation information
 421   // (since code is dynamically patched, we also need to dynamically update the relocation info)
 422   // Both methods takes old_type, so it is able to performe sanity checks on the information removed.
 423   static void change_reloc_info_for_address(RelocIterator *itr, address pc, relocType old_type, relocType new_type);
 424 
 425   // Machine dependent stuff
 426 #include CPU_HEADER(relocInfo)
 427 
 428  protected:
 429   // Derived constant, based on format_width which is PD:
 430   enum {
 431     offset_width       = nontype_width - format_width,
 432     offset_mask        = (1&lt;&lt;offset_width) - 1,
 433     format_mask        = (1&lt;&lt;format_width) - 1
 434   };
 435  public:
 436   enum {
 437 #ifdef _LP64
 438     // for use in format
 439     // format_width must be at least 1 on _LP64
 440     narrow_oop_in_const = 1,
 441 #endif
 442     // Conservatively large estimate of maximum length (in shorts)
 443     // of any relocation record.
 444     // Extended format is length prefix, data words, and tag/offset suffix.
 445     length_limit       = 1 + 1 + (3*BytesPerWord/BytesPerShort) + 1,
 446     have_format        = format_width &gt; 0
 447   };
 448 };
 449 
 450 #define FORWARD_DECLARE_EACH_CLASS(name)              \
 451 class name##_Relocation;
 452 APPLY_TO_RELOCATIONS(FORWARD_DECLARE_EACH_CLASS)
 453 #undef FORWARD_DECLARE_EACH_CLASS
 454 
 455 
 456 
 457 inline relocInfo filler_relocInfo() {
 458   return relocInfo(relocInfo::none, relocInfo::offset_limit() - relocInfo::offset_unit);
 459 }
 460 
 461 inline relocInfo prefix_relocInfo(int datalen = 0) {
 462   assert(relocInfo::fits_into_immediate(datalen), &quot;datalen in limits&quot;);
 463   return relocInfo(relocInfo::data_prefix_tag, relocInfo::RAW_BITS, relocInfo::datalen_tag | datalen);
 464 }
 465 
 466 
 467 // Holder for flyweight relocation objects.
 468 // Although the flyweight subclasses are of varying sizes,
 469 // the holder is &quot;one size fits all&quot;.
 470 class RelocationHolder {
 471   friend class Relocation;
 472   friend class CodeSection;
 473 
 474  private:
 475   // this preallocated memory must accommodate all subclasses of Relocation
 476   // (this number is assertion-checked in Relocation::operator new)
 477   enum { _relocbuf_size = 5 };
 478   void* _relocbuf[ _relocbuf_size ];
 479 
 480  public:
 481   Relocation* reloc() const { return (Relocation*) &amp;_relocbuf[0]; }
 482   inline relocInfo::relocType type() const;
 483 
 484   // Add a constant offset to a relocation.  Helper for class Address.
 485   RelocationHolder plus(int offset) const;
 486 
 487   inline RelocationHolder();                // initializes type to none
 488 
 489   inline RelocationHolder(Relocation* r);   // make a copy
 490 
 491   static const RelocationHolder none;
 492 };
 493 
 494 // A RelocIterator iterates through the relocation information of a CodeBlob.
 495 // It is a variable BoundRelocation which is able to take on successive
 496 // values as it is advanced through a code stream.
 497 // Usage:
 498 //   RelocIterator iter(nm);
 499 //   while (iter.next()) {
 500 //     iter.reloc()-&gt;some_operation();
 501 //   }
 502 // or:
 503 //   RelocIterator iter(nm);
 504 //   while (iter.next()) {
 505 //     switch (iter.type()) {
 506 //      case relocInfo::oop_type          :
 507 //      case relocInfo::ic_type           :
 508 //      case relocInfo::prim_type         :
 509 //      case relocInfo::uncommon_type     :
 510 //      case relocInfo::runtime_call_type :
 511 //      case relocInfo::internal_word_type:
 512 //      case relocInfo::external_word_type:
 513 //      ...
 514 //     }
 515 //   }
 516 
 517 class RelocIterator : public StackObj {
 518   friend class section_word_Relocation; // for section verification
 519   enum { SECT_LIMIT = 3 };  // must be equal to CodeBuffer::SECT_LIMIT, checked in ctor
 520   friend class Relocation;
 521   friend class relocInfo;   // for change_reloc_info_for_address only
 522   typedef relocInfo::relocType relocType;
 523 
 524  private:
 525   address         _limit;   // stop producing relocations after this _addr
 526   relocInfo*      _current; // the current relocation information
 527   relocInfo*      _end;     // end marker; we&#39;re done iterating when _current == _end
 528   CompiledMethod* _code;    // compiled method containing _addr
 529   address         _addr;    // instruction to which the relocation applies
 530   short           _databuf; // spare buffer for compressed data
 531   short*          _data;    // pointer to the relocation&#39;s data
 532   short           _datalen; // number of halfwords in _data
 533 
 534   // Base addresses needed to compute targets of section_word_type relocs.
 535   address _section_start[SECT_LIMIT];
 536   address _section_end  [SECT_LIMIT];
 537 
 538   void set_has_current(bool b) {
 539     _datalen = !b ? -1 : 0;
 540     debug_only(_data = NULL);
 541   }
 542   void set_current(relocInfo&amp; ri) {
 543     _current = &amp;ri;
 544     set_has_current(true);
 545   }
 546 
 547   RelocationHolder _rh; // where the current relocation is allocated
 548 
 549   relocInfo* current() const { assert(has_current(), &quot;must have current&quot;);
 550                                return _current; }
 551 
 552   void set_limits(address begin, address limit);
 553 
 554   void advance_over_prefix();    // helper method
 555 
 556   void initialize_misc();
 557 
 558   void initialize(CompiledMethod* nm, address begin, address limit);
 559 
 560   RelocIterator() { initialize_misc(); }
 561 
 562  public:
 563   // constructor
 564   RelocIterator(CompiledMethod* nm, address begin = NULL, address limit = NULL);
 565   RelocIterator(CodeSection* cb, address begin = NULL, address limit = NULL);
 566 
 567   // get next reloc info, return !eos
 568   bool next() {
 569     _current++;
 570     assert(_current &lt;= _end, &quot;must not overrun relocInfo&quot;);
 571     if (_current == _end) {
 572       set_has_current(false);
 573       return false;
 574     }
 575     set_has_current(true);
 576 
 577     if (_current-&gt;is_prefix()) {
 578       advance_over_prefix();
 579       assert(!current()-&gt;is_prefix(), &quot;only one prefix at a time&quot;);
 580     }
 581 
 582     _addr += _current-&gt;addr_offset();
 583 
 584     if (_limit != NULL &amp;&amp; _addr &gt;= _limit) {
 585       set_has_current(false);
 586       return false;
 587     }
 588 
 589     return true;
 590   }
 591 
 592   // accessors
 593   address      limit()        const { return _limit; }
 594   relocType    type()         const { return current()-&gt;type(); }
 595   int          format()       const { return (relocInfo::have_format) ? current()-&gt;format() : 0; }
 596   address      addr()         const { return _addr; }
 597   CompiledMethod*     code()  const { return _code; }
 598   short*       data()         const { return _data; }
 599   int          datalen()      const { return _datalen; }
 600   bool     has_current()      const { return _datalen &gt;= 0; }
 601   bool   addr_in_const()      const;
 602 
 603   address section_start(int n) const {
 604     assert(_section_start[n], &quot;must be initialized&quot;);
 605     return _section_start[n];
 606   }
 607   address section_end(int n) const {
 608     assert(_section_end[n], &quot;must be initialized&quot;);
 609     return _section_end[n];
 610   }
 611 
 612   // The address points to the affected displacement part of the instruction.
 613   // For RISC, this is just the whole instruction.
 614   // For Intel, this is an unaligned 32-bit word.
 615 
 616   // type-specific relocation accessors:  oop_Relocation* oop_reloc(), etc.
 617   #define EACH_TYPE(name)                               \
 618   inline name##_Relocation* name##_reloc();
 619   APPLY_TO_RELOCATIONS(EACH_TYPE)
 620   #undef EACH_TYPE
 621   // generic relocation accessor; switches on type to call the above
 622   Relocation* reloc();
 623 
 624 #ifndef PRODUCT
 625  public:
 626   void print();
 627   void print_current();
 628 #endif
 629 };
 630 
 631 
 632 // A Relocation is a flyweight object allocated within a RelocationHolder.
 633 // It represents the relocation data of relocation record.
 634 // So, the RelocIterator unpacks relocInfos into Relocations.
 635 
 636 class Relocation {
 637   friend class RelocationHolder;
 638   friend class RelocIterator;
 639 
 640  private:
 641   // When a relocation has been created by a RelocIterator,
 642   // this field is non-null.  It allows the relocation to know
 643   // its context, such as the address to which it applies.
 644   RelocIterator* _binding;
 645 
 646   relocInfo::relocType _rtype;
 647 
 648  protected:
 649   RelocIterator* binding() const {
 650     assert(_binding != NULL, &quot;must be bound&quot;);
 651     return _binding;
 652   }
 653   void set_binding(RelocIterator* b) {
 654     assert(_binding == NULL, &quot;must be unbound&quot;);
 655     _binding = b;
 656     assert(_binding != NULL, &quot;must now be bound&quot;);
 657   }
 658 
 659   Relocation(relocInfo::relocType rtype) : _binding(NULL), _rtype(rtype) { }
 660 
 661   static RelocationHolder newHolder() {
 662     return RelocationHolder();
 663   }
 664 
 665  public:
 666   void* operator new(size_t size, const RelocationHolder&amp; holder) throw() {
 667     assert(size &lt;= sizeof(holder._relocbuf), &quot;Make _relocbuf bigger!&quot;);
 668     assert((void* const *)holder.reloc() == &amp;holder._relocbuf[0], &quot;ptrs must agree&quot;);
 669     return holder.reloc();
 670   }
 671 
 672   // make a generic relocation for a given type (if possible)
 673   static RelocationHolder spec_simple(relocInfo::relocType rtype);
 674 
 675   // here is the type-specific hook which writes relocation data:
 676   virtual void pack_data_to(CodeSection* dest) { }
 677 
 678   // here is the type-specific hook which reads (unpacks) relocation data:
 679   virtual void unpack_data() {
 680     assert(datalen()==0 || type()==relocInfo::none, &quot;no data here&quot;);
 681   }
 682 
 683  protected:
 684   // Helper functions for pack_data_to() and unpack_data().
 685 
 686   // Most of the compression logic is confined here.
 687   // (The &quot;immediate data&quot; mechanism of relocInfo works independently
 688   // of this stuff, and acts to further compress most 1-word data prefixes.)
 689 
 690   // A variable-width int is encoded as a short if it will fit in 16 bits.
 691   // The decoder looks at datalen to decide whether to unpack short or jint.
 692   // Most relocation records are quite simple, containing at most two ints.
 693 
 694   static bool is_short(jint x) { return x == (short)x; }
 695   static short* add_short(short* p, int x)  { *p++ = x; return p; }
 696   static short* add_jint (short* p, jint x) {
 697     *p++ = relocInfo::data0_from_int(x); *p++ = relocInfo::data1_from_int(x);
 698     return p;
 699   }
 700   static short* add_var_int(short* p, jint x) {   // add a variable-width int
 701     if (is_short(x))  p = add_short(p, x);
 702     else              p = add_jint (p, x);
 703     return p;
 704   }
 705 
 706   static short* pack_1_int_to(short* p, jint x0) {
 707     // Format is one of:  [] [x] [Xx]
 708     if (x0 != 0)  p = add_var_int(p, x0);
 709     return p;
 710   }
 711   int unpack_1_int() {
 712     assert(datalen() &lt;= 2, &quot;too much data&quot;);
 713     return relocInfo::jint_data_at(0, data(), datalen());
 714   }
 715 
 716   // With two ints, the short form is used only if both ints are short.
 717   short* pack_2_ints_to(short* p, jint x0, jint x1) {
 718     // Format is one of:  [] [x y?] [Xx Y?y]
 719     if (x0 == 0 &amp;&amp; x1 == 0) {
 720       // no halfwords needed to store zeroes
 721     } else if (is_short(x0) &amp;&amp; is_short(x1)) {
 722       // 1-2 halfwords needed to store shorts
 723       p = add_short(p, x0); if (x1!=0) p = add_short(p, x1);
 724     } else {
 725       // 3-4 halfwords needed to store jints
 726       p = add_jint(p, x0);             p = add_var_int(p, x1);
 727     }
 728     return p;
 729   }
 730   void unpack_2_ints(jint&amp; x0, jint&amp; x1) {
 731     int    dlen = datalen();
 732     short* dp  = data();
 733     if (dlen &lt;= 2) {
 734       x0 = relocInfo::short_data_at(0, dp, dlen);
 735       x1 = relocInfo::short_data_at(1, dp, dlen);
 736     } else {
 737       assert(dlen &lt;= 4, &quot;too much data&quot;);
 738       x0 = relocInfo::jint_data_at(0, dp, dlen);
 739       x1 = relocInfo::jint_data_at(2, dp, dlen);
 740     }
 741   }
 742 
 743  protected:
 744   // platform-independent utility for patching constant section
 745   void       const_set_data_value    (address x);
 746   void       const_verify_data_value (address x);
 747   // platform-dependent utilities for decoding and patching instructions
 748   void       pd_set_data_value       (address x, intptr_t off, bool verify_only = false); // a set or mem-ref
 749   void       pd_verify_data_value    (address x, intptr_t off) { pd_set_data_value(x, off, true); }
 750   address    pd_call_destination     (address orig_addr = NULL);
 751   void       pd_set_call_destination (address x);
 752 
 753   // this extracts the address of an address in the code stream instead of the reloc data
 754   address* pd_address_in_code       ();
 755 
 756   // this extracts an address from the code stream instead of the reloc data
 757   address  pd_get_address_from_code ();
 758 
 759   // these convert from byte offsets, to scaled offsets, to addresses
 760   static jint scaled_offset(address x, address base) {
 761     int byte_offset = x - base;
 762     int offset = -byte_offset / relocInfo::addr_unit();
 763     assert(address_from_scaled_offset(offset, base) == x, &quot;just checkin&#39;&quot;);
 764     return offset;
 765   }
 766   static jint scaled_offset_null_special(address x, address base) {
 767     // Some relocations treat offset=0 as meaning NULL.
 768     // Handle this extra convention carefully.
 769     if (x == NULL)  return 0;
 770     assert(x != base, &quot;offset must not be zero&quot;);
 771     return scaled_offset(x, base);
 772   }
 773   static address address_from_scaled_offset(jint offset, address base) {
 774     int byte_offset = -( offset * relocInfo::addr_unit() );
 775     return base + byte_offset;
 776   }
 777 
 778   // helpers for mapping between old and new addresses after a move or resize
 779   address old_addr_for(address newa, const CodeBuffer* src, CodeBuffer* dest);
 780   address new_addr_for(address olda, const CodeBuffer* src, CodeBuffer* dest);
 781   void normalize_address(address&amp; addr, const CodeSection* dest, bool allow_other_sections = false);
 782 
 783  public:
 784   // accessors which only make sense for a bound Relocation
 785   address         addr()            const { return binding()-&gt;addr(); }
 786   CompiledMethod* code()            const { return binding()-&gt;code(); }
 787   bool            addr_in_const()   const { return binding()-&gt;addr_in_const(); }
 788  protected:
 789   short*   data()         const { return binding()-&gt;data(); }
 790   int      datalen()      const { return binding()-&gt;datalen(); }
 791   int      format()       const { return binding()-&gt;format(); }
 792 
 793  public:
 794   relocInfo::relocType type()              const { return _rtype; }
 795 
 796   // is it a call instruction?
 797   virtual bool is_call()                         { return false; }
 798 
 799   // is it a data movement instruction?
 800   virtual bool is_data()                         { return false; }
 801 
 802   // some relocations can compute their own values
 803   virtual address  value();
 804 
 805   // all relocations are able to reassert their values
 806   virtual void set_value(address x);
 807 
 808   virtual bool clear_inline_cache()              { return true; }
 809 
 810   // This method assumes that all virtual/static (inline) caches are cleared (since for static_call_type and
 811   // ic_call_type is not always posisition dependent (depending on the state of the cache)). However, this is
 812   // probably a reasonable assumption, since empty caches simplifies code reloacation.
 813   virtual void fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest) { }
 814 };
 815 
 816 
 817 // certain inlines must be deferred until class Relocation is defined:
 818 
 819 inline RelocationHolder::RelocationHolder() {
 820   // initialize the vtbl, just to keep things type-safe
 821   new(*this) Relocation(relocInfo::none);
 822 }
 823 
 824 
 825 inline RelocationHolder::RelocationHolder(Relocation* r) {
 826   // wordwise copy from r (ok if it copies garbage after r)
 827   for (int i = 0; i &lt; _relocbuf_size; i++) {
 828     _relocbuf[i] = ((void**)r)[i];
 829   }
 830 }
 831 
 832 relocInfo::relocType RelocationHolder::type() const {
 833   return reloc()-&gt;type();
 834 }
 835 
 836 // A DataRelocation always points at a memory or load-constant instruction..
 837 // It is absolute on most machines, and the constant is split on RISCs.
 838 // The specific subtypes are oop, external_word, and internal_word.
 839 // By convention, the &quot;value&quot; does not include a separately reckoned &quot;offset&quot;.
 840 class DataRelocation : public Relocation {
 841  public:
 842   DataRelocation(relocInfo::relocType type) : Relocation(type) {}
 843 
 844   bool          is_data()                      { return true; }
 845 
 846   // both target and offset must be computed somehow from relocation data
 847   virtual int    offset()                      { return 0; }
 848   address         value()                      = 0;
 849   void        set_value(address x)             { set_value(x, offset()); }
 850   void        set_value(address x, intptr_t o) {
 851     if (addr_in_const())
 852       const_set_data_value(x);
 853     else
 854       pd_set_data_value(x, o);
 855   }
 856   void        verify_value(address x) {
 857     if (addr_in_const())
 858       const_verify_data_value(x);
 859     else
 860       pd_verify_data_value(x, offset());
 861   }
 862 
 863   // The &quot;o&quot; (displacement) argument is relevant only to split relocations
 864   // on RISC machines.  In some CPUs (SPARC), the set-hi and set-lo ins&#39;ns
 865   // can encode more than 32 bits between them.  This allows compilers to
 866   // share set-hi instructions between addresses that differ by a small
 867   // offset (e.g., different static variables in the same class).
 868   // On such machines, the &quot;x&quot; argument to set_value on all set-lo
 869   // instructions must be the same as the &quot;x&quot; argument for the
 870   // corresponding set-hi instructions.  The &quot;o&quot; arguments for the
 871   // set-hi instructions are ignored, and must not affect the high-half
 872   // immediate constant.  The &quot;o&quot; arguments for the set-lo instructions are
 873   // added into the low-half immediate constant, and must not overflow it.
 874 };
 875 
 876 // A CallRelocation always points at a call instruction.
 877 // It is PC-relative on most machines.
 878 class CallRelocation : public Relocation {
 879  public:
 880   CallRelocation(relocInfo::relocType type) : Relocation(type) { }
 881 
 882   bool is_call() { return true; }
 883 
 884   address  destination()                    { return pd_call_destination(); }
 885   void     set_destination(address x); // pd_set_call_destination
 886 
 887   void     fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest);
 888   address  value()                          { return destination();  }
 889   void     set_value(address x)             { set_destination(x); }
 890 };
 891 
 892 class oop_Relocation : public DataRelocation {
 893  public:
 894   // encode in one of these formats:  [] [n] [n l] [Nn l] [Nn Ll]
 895   // an oop in the CodeBlob&#39;s oop pool
 896   static RelocationHolder spec(int oop_index, int offset = 0) {
 897     assert(oop_index &gt; 0, &quot;must be a pool-resident oop&quot;);
 898     RelocationHolder rh = newHolder();
 899     new(rh) oop_Relocation(oop_index, offset);
 900     return rh;
 901   }
 902   // an oop in the instruction stream
 903   static RelocationHolder spec_for_immediate() {
 904     // If no immediate oops are generated, we can skip some walks over nmethods.
 905     // Assert that they don&#39;t get generated accidently!
 906     assert(relocInfo::mustIterateImmediateOopsInCode(),
 907            &quot;Must return true so we will search for oops as roots etc. in the code.&quot;);
 908     const int oop_index = 0;
 909     const int offset    = 0;    // if you want an offset, use the oop pool
 910     RelocationHolder rh = newHolder();
 911     new(rh) oop_Relocation(oop_index, offset);
 912     return rh;
 913   }
 914 
 915  private:
 916   jint _oop_index;                  // if &gt; 0, index into CodeBlob::oop_at
 917   jint _offset;                     // byte offset to apply to the oop itself
 918 
 919   oop_Relocation(int oop_index, int offset)
 920     : DataRelocation(relocInfo::oop_type), _oop_index(oop_index), _offset(offset) { }
 921 
 922   friend class RelocIterator;
 923   oop_Relocation() : DataRelocation(relocInfo::oop_type) {}
 924 
 925  public:
 926   int oop_index() { return _oop_index; }
 927   int offset()    { return _offset; }
 928 
 929   // data is packed in &quot;2_ints&quot; format:  [i o] or [Ii Oo]
 930   void pack_data_to(CodeSection* dest);
 931   void unpack_data();
 932 
 933   void fix_oop_relocation();        // reasserts oop value
 934 
 935   void verify_oop_relocation();
 936 
 937   address value()  { return cast_from_oop&lt;address&gt;(*oop_addr()); }
 938 
 939   bool oop_is_immediate()  { return oop_index() == 0; }
 940 
 941   oop* oop_addr();                  // addr or &amp;pool[jint_data]
 942   oop  oop_value();                 // *oop_addr
 943   // Note:  oop_value transparently converts Universe::non_oop_word to NULL.
 944 };
 945 
 946 
 947 // copy of oop_Relocation for now but may delete stuff in both/either
 948 class metadata_Relocation : public DataRelocation {
 949 
 950  public:
 951   // encode in one of these formats:  [] [n] [n l] [Nn l] [Nn Ll]
 952   // an metadata in the CodeBlob&#39;s metadata pool
 953   static RelocationHolder spec(int metadata_index, int offset = 0) {
 954     assert(metadata_index &gt; 0, &quot;must be a pool-resident metadata&quot;);
 955     RelocationHolder rh = newHolder();
 956     new(rh) metadata_Relocation(metadata_index, offset);
 957     return rh;
 958   }
 959   // an metadata in the instruction stream
 960   static RelocationHolder spec_for_immediate() {
 961     const int metadata_index = 0;
 962     const int offset    = 0;    // if you want an offset, use the metadata pool
 963     RelocationHolder rh = newHolder();
 964     new(rh) metadata_Relocation(metadata_index, offset);
 965     return rh;
 966   }
 967 
 968  private:
 969   jint _metadata_index;            // if &gt; 0, index into nmethod::metadata_at
 970   jint _offset;                     // byte offset to apply to the metadata itself
 971 
 972   metadata_Relocation(int metadata_index, int offset)
 973     : DataRelocation(relocInfo::metadata_type), _metadata_index(metadata_index), _offset(offset) { }
 974 
 975   friend class RelocIterator;
 976   metadata_Relocation() : DataRelocation(relocInfo::metadata_type) { }
 977 
 978   // Fixes a Metadata pointer in the code. Most platforms embeds the
 979   // Metadata pointer in the code at compile time so this is empty
 980   // for them.
 981   void pd_fix_value(address x);
 982 
 983  public:
 984   int metadata_index() { return _metadata_index; }
 985   int offset()    { return _offset; }
 986 
 987   // data is packed in &quot;2_ints&quot; format:  [i o] or [Ii Oo]
 988   void pack_data_to(CodeSection* dest);
 989   void unpack_data();
 990 
 991   void fix_metadata_relocation();        // reasserts metadata value
 992 
 993   address value()  { return (address) *metadata_addr(); }
 994 
 995   bool metadata_is_immediate()  { return metadata_index() == 0; }
 996 
 997   Metadata**   metadata_addr();                  // addr or &amp;pool[jint_data]
 998   Metadata*    metadata_value();                 // *metadata_addr
 999   // Note:  metadata_value transparently converts Universe::non_metadata_word to NULL.
1000 };
1001 
1002 
1003 class virtual_call_Relocation : public CallRelocation {
1004 
1005  public:
1006   // &quot;cached_value&quot; points to the first associated set-oop.
1007   // The oop_limit helps find the last associated set-oop.
1008   // (See comments at the top of this file.)
1009   static RelocationHolder spec(address cached_value, jint method_index = 0) {
1010     RelocationHolder rh = newHolder();
1011     new(rh) virtual_call_Relocation(cached_value, method_index);
1012     return rh;
1013   }
1014 
1015  private:
1016   address _cached_value; // location of set-value instruction
1017   jint    _method_index; // resolved method for a Java call
1018 
1019   virtual_call_Relocation(address cached_value, int method_index)
1020     : CallRelocation(relocInfo::virtual_call_type),
1021       _cached_value(cached_value),
1022       _method_index(method_index) {
1023     assert(cached_value != NULL, &quot;first oop address must be specified&quot;);
1024   }
1025 
1026   friend class RelocIterator;
1027   virtual_call_Relocation() : CallRelocation(relocInfo::virtual_call_type) { }
1028 
1029  public:
1030   address cached_value();
1031 
1032   int     method_index() { return _method_index; }
1033   Method* method_value();
1034 
1035   // data is packed as scaled offsets in &quot;2_ints&quot; format:  [f l] or [Ff Ll]
1036   // oop_limit is set to 0 if the limit falls somewhere within the call.
1037   // When unpacking, a zero oop_limit is taken to refer to the end of the call.
1038   // (This has the effect of bringing in the call&#39;s delay slot on SPARC.)
1039   void pack_data_to(CodeSection* dest);
1040   void unpack_data();
1041 
1042   bool clear_inline_cache();
1043 };
1044 
1045 
1046 class opt_virtual_call_Relocation : public CallRelocation {
1047  public:
1048   static RelocationHolder spec(int method_index = 0) {
1049     RelocationHolder rh = newHolder();
1050     new(rh) opt_virtual_call_Relocation(method_index);
1051     return rh;
1052   }
1053 
1054  private:
1055   jint _method_index; // resolved method for a Java call
1056 
1057   opt_virtual_call_Relocation(int method_index)
1058     : CallRelocation(relocInfo::opt_virtual_call_type),
1059       _method_index(method_index) { }
1060 
1061   friend class RelocIterator;
1062   opt_virtual_call_Relocation() : CallRelocation(relocInfo::opt_virtual_call_type) {}
1063 
1064  public:
1065   int     method_index() { return _method_index; }
1066   Method* method_value();
1067 
1068   void pack_data_to(CodeSection* dest);
1069   void unpack_data();
1070 
1071   bool clear_inline_cache();
1072 
1073   // find the matching static_stub
1074   address static_stub(bool is_aot);
1075 };
1076 
1077 
1078 class static_call_Relocation : public CallRelocation {
1079  public:
1080   static RelocationHolder spec(int method_index = 0) {
1081     RelocationHolder rh = newHolder();
1082     new(rh) static_call_Relocation(method_index);
1083     return rh;
1084   }
1085 
1086  private:
1087   jint _method_index; // resolved method for a Java call
1088 
1089   static_call_Relocation(int method_index)
1090     : CallRelocation(relocInfo::static_call_type),
1091     _method_index(method_index) { }
1092 
1093   friend class RelocIterator;
1094   static_call_Relocation() : CallRelocation(relocInfo::static_call_type) {}
1095 
1096  public:
1097   int     method_index() { return _method_index; }
1098   Method* method_value();
1099 
1100   void pack_data_to(CodeSection* dest);
1101   void unpack_data();
1102 
1103   bool clear_inline_cache();
1104 
1105   // find the matching static_stub
1106   address static_stub(bool is_aot);
1107 };
1108 
1109 class static_stub_Relocation : public Relocation {
1110  public:
1111   static RelocationHolder spec(address static_call, bool is_aot = false) {
1112     RelocationHolder rh = newHolder();
1113     new(rh) static_stub_Relocation(static_call, is_aot);
1114     return rh;
1115   }
1116 
1117  private:
1118   address _static_call;  // location of corresponding static_call
1119   bool _is_aot;          // trampoline to aot code
1120 
1121   static_stub_Relocation(address static_call, bool is_aot)
1122     : Relocation(relocInfo::static_stub_type),
1123       _static_call(static_call), _is_aot(is_aot) { }
1124 
1125   friend class RelocIterator;
1126   static_stub_Relocation() : Relocation(relocInfo::static_stub_type) { }
1127 
1128  public:
1129   bool clear_inline_cache();
1130 
1131   address static_call() { return _static_call; }
1132   bool is_aot() { return _is_aot; }
1133 
1134   // data is packed as a scaled offset in &quot;1_int&quot; format:  [c] or [Cc]
1135   void pack_data_to(CodeSection* dest);
1136   void unpack_data();
1137 };
1138 
1139 class runtime_call_Relocation : public CallRelocation {
1140 
1141  public:
1142   static RelocationHolder spec() {
1143     RelocationHolder rh = newHolder();
1144     new(rh) runtime_call_Relocation();
1145     return rh;
1146   }
1147 
1148  private:
1149   friend class RelocIterator;
1150   runtime_call_Relocation() : CallRelocation(relocInfo::runtime_call_type) { }
1151 
1152  public:
1153 };
1154 
1155 
1156 class runtime_call_w_cp_Relocation : public CallRelocation {
1157  public:
1158   static RelocationHolder spec() {
1159     RelocationHolder rh = newHolder();
1160     new(rh) runtime_call_w_cp_Relocation();
1161     return rh;
1162   }
1163 
1164  private:
1165   friend class RelocIterator;
1166   runtime_call_w_cp_Relocation()
1167     : CallRelocation(relocInfo::runtime_call_w_cp_type),
1168       _offset(-4) /* &lt;0 = invalid */ { }
1169 
1170   // On z/Architecture, runtime calls are either a sequence
1171   // of two instructions (load destination of call from constant pool + do call)
1172   // or a pc-relative call. The pc-relative call is faster, but it can only
1173   // be used if the destination of the call is not too far away.
1174   // In order to be able to patch a pc-relative call back into one using
1175   // the constant pool, we have to remember the location of the call&#39;s destination
1176   // in the constant pool.
1177   int _offset;
1178 
1179  public:
1180   void set_constant_pool_offset(int offset) { _offset = offset; }
1181   int get_constant_pool_offset() { return _offset; }
1182   void pack_data_to(CodeSection * dest);
1183   void unpack_data();
1184 };
1185 
1186 // Trampoline Relocations.
1187 // A trampoline allows to encode a small branch in the code, even if there
1188 // is the chance that this branch can not reach all possible code locations.
1189 // If the relocation finds that a branch is too far for the instruction
1190 // in the code, it can patch it to jump to the trampoline where is
1191 // sufficient space for a far branch. Needed on PPC.
1192 class trampoline_stub_Relocation : public Relocation {
1193  public:
1194   static RelocationHolder spec(address static_call) {
1195     RelocationHolder rh = newHolder();
1196     return (new (rh) trampoline_stub_Relocation(static_call));
1197   }
1198 
1199  private:
1200   address _owner;    // Address of the NativeCall that owns the trampoline.
1201 
1202   trampoline_stub_Relocation(address owner)
1203     : Relocation(relocInfo::trampoline_stub_type),
1204       _owner(owner) { }
1205 
1206   friend class RelocIterator;
1207   trampoline_stub_Relocation() : Relocation(relocInfo::trampoline_stub_type) { }
1208 
1209  public:
1210 
1211   // Return the address of the NativeCall that owns the trampoline.
1212   address owner() { return _owner; }
1213 
1214   void pack_data_to(CodeSection * dest);
1215   void unpack_data();
1216 
1217   // Find the trampoline stub for a call.
1218   static address get_trampoline_for(address call, nmethod* code);
1219 };
1220 
1221 class external_word_Relocation : public DataRelocation {
1222  public:
1223   static RelocationHolder spec(address target) {
1224     assert(target != NULL, &quot;must not be null&quot;);
1225     RelocationHolder rh = newHolder();
1226     new(rh) external_word_Relocation(target);
1227     return rh;
1228   }
1229 
1230   // Use this one where all 32/64 bits of the target live in the code stream.
1231   // The target must be an intptr_t, and must be absolute (not relative).
1232   static RelocationHolder spec_for_immediate() {
1233     RelocationHolder rh = newHolder();
1234     new(rh) external_word_Relocation(NULL);
1235     return rh;
1236   }
1237 
1238   // Some address looking values aren&#39;t safe to treat as relocations
1239   // and should just be treated as constants.
1240   static bool can_be_relocated(address target) {
1241     assert(target == NULL || (uintptr_t)target &gt;= (uintptr_t)os::vm_page_size(), INTPTR_FORMAT, (intptr_t)target);
1242     return target != NULL;
1243   }
1244 
1245  private:
1246   address _target;                  // address in runtime
1247 
1248   external_word_Relocation(address target)
1249     : DataRelocation(relocInfo::external_word_type), _target(target) { }
1250 
1251   friend class RelocIterator;
1252   external_word_Relocation() : DataRelocation(relocInfo::external_word_type) { }
1253 
1254  public:
1255   // data is packed as a well-known address in &quot;1_int&quot; format:  [a] or [Aa]
1256   // The function runtime_address_to_index is used to turn full addresses
1257   // to short indexes, if they are pre-registered by the stub mechanism.
1258   // If the &quot;a&quot; value is 0 (i.e., _target is NULL), the address is stored
1259   // in the code stream.  See external_word_Relocation::target().
1260   void pack_data_to(CodeSection* dest);
1261   void unpack_data();
1262 
1263   void fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest);
1264   address  target();        // if _target==NULL, fetch addr from code stream
1265   address  value()          { return target(); }
1266 };
1267 
1268 class internal_word_Relocation : public DataRelocation {
1269 
1270  public:
1271   static RelocationHolder spec(address target) {
1272     assert(target != NULL, &quot;must not be null&quot;);
1273     RelocationHolder rh = newHolder();
1274     new(rh) internal_word_Relocation(target);
1275     return rh;
1276   }
1277 
1278   // use this one where all the bits of the target can fit in the code stream:
1279   static RelocationHolder spec_for_immediate() {
1280     RelocationHolder rh = newHolder();
1281     new(rh) internal_word_Relocation(NULL);
1282     return rh;
1283   }
1284 
1285   // default section -1 means self-relative
1286   internal_word_Relocation(address target, int section = -1,
1287     relocInfo::relocType type = relocInfo::internal_word_type)
1288     : DataRelocation(type), _target(target), _section(section) { }
1289 
1290  protected:
1291   address _target;                  // address in CodeBlob
1292   int     _section;                 // section providing base address, if any
1293 
1294   friend class RelocIterator;
1295   internal_word_Relocation(relocInfo::relocType type = relocInfo::internal_word_type)
1296     : DataRelocation(type) { }
1297 
1298   // bit-width of LSB field in packed offset, if section &gt;= 0
1299   enum { section_width = 2 }; // must equal CodeBuffer::sect_bits
1300 
1301  public:
1302   // data is packed as a scaled offset in &quot;1_int&quot; format:  [o] or [Oo]
1303   // If the &quot;o&quot; value is 0 (i.e., _target is NULL), the offset is stored
1304   // in the code stream.  See internal_word_Relocation::target().
1305   // If _section is not -1, it is appended to the low bits of the offset.
1306   void pack_data_to(CodeSection* dest);
1307   void unpack_data();
1308 
1309   void fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest);
1310   address  target();        // if _target==NULL, fetch addr from code stream
1311   int      section()        { return _section;   }
1312   address  value()          { return target();   }
1313 };
1314 
1315 class section_word_Relocation : public internal_word_Relocation {
1316  public:
1317   static RelocationHolder spec(address target, int section) {
1318     RelocationHolder rh = newHolder();
1319     new(rh) section_word_Relocation(target, section);
1320     return rh;
1321   }
1322 
1323   section_word_Relocation(address target, int section)
1324     : internal_word_Relocation(target, section, relocInfo::section_word_type) {
1325     assert(target != NULL, &quot;must not be null&quot;);
1326     assert(section &gt;= 0 &amp;&amp; section &lt; RelocIterator::SECT_LIMIT, &quot;must be a valid section&quot;);
1327   }
1328 
1329   //void pack_data_to -- inherited
1330   void unpack_data();
1331 
1332  private:
1333   friend class RelocIterator;
1334   section_word_Relocation() : internal_word_Relocation(relocInfo::section_word_type) { }
1335 };
1336 
1337 
1338 class poll_Relocation : public Relocation {
1339   bool          is_data()                      { return true; }
1340   void     fix_relocation_after_move(const CodeBuffer* src, CodeBuffer* dest);
1341  public:
1342   poll_Relocation(relocInfo::relocType type = relocInfo::poll_type) : Relocation(type) { }
1343 };
1344 
1345 class poll_return_Relocation : public poll_Relocation {
1346  public:
1347   poll_return_Relocation() : poll_Relocation(relocInfo::relocInfo::poll_return_type) { }
1348 };
1349 
1350 // We know all the xxx_Relocation classes, so now we can define these:
1351 #define EACH_CASE(name)                                         \
1352 inline name##_Relocation* RelocIterator::name##_reloc() {       \
1353   assert(type() == relocInfo::name##_type, &quot;type must agree&quot;);  \
1354   /* The purpose of the placed &quot;new&quot; is to re-use the same */   \
1355   /* stack storage for each new iteration. */                   \
1356   name##_Relocation* r = new(_rh) name##_Relocation();          \
1357   r-&gt;set_binding(this);                                         \
1358   r-&gt;name##_Relocation::unpack_data();                          \
1359   return r;                                                     \
1360 }
1361 APPLY_TO_RELOCATIONS(EACH_CASE);
1362 #undef EACH_CASE
1363 
1364 inline RelocIterator::RelocIterator(CompiledMethod* nm, address begin, address limit) {
1365   initialize(nm, begin, limit);
1366 }
1367 
1368 #endif // SHARE_CODE_RELOCINFO_HPP
    </pre>
  </body>
</html>
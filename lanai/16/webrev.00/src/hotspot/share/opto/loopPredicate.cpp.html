<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/opto/loopPredicate.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;opto/loopnode.hpp&quot;
  27 #include &quot;opto/addnode.hpp&quot;
  28 #include &quot;opto/callnode.hpp&quot;
  29 #include &quot;opto/connode.hpp&quot;
  30 #include &quot;opto/convertnode.hpp&quot;
  31 #include &quot;opto/loopnode.hpp&quot;
  32 #include &quot;opto/matcher.hpp&quot;
  33 #include &quot;opto/mulnode.hpp&quot;
  34 #include &quot;opto/opaquenode.hpp&quot;
  35 #include &quot;opto/rootnode.hpp&quot;
  36 #include &quot;opto/subnode.hpp&quot;
  37 #include &lt;fenv.h&gt;
  38 #include &lt;math.h&gt;
  39 
  40 /*
  41  * The general idea of Loop Predication is to insert a predicate on the entry
  42  * path to a loop, and raise a uncommon trap if the check of the condition fails.
  43  * The condition checks are promoted from inside the loop body, and thus
  44  * the checks inside the loop could be eliminated. Currently, loop predication
  45  * optimization has been applied to remove array range check and loop invariant
  46  * checks (such as null checks).
  47 */
  48 
  49 //-------------------------------register_control-------------------------
  50 void PhaseIdealLoop::register_control(Node* n, IdealLoopTree *loop, Node* pred) {
  51   assert(n-&gt;is_CFG(), &quot;must be control node&quot;);
  52   _igvn.register_new_node_with_optimizer(n);
  53   loop-&gt;_body.push(n);
  54   set_loop(n, loop);
  55   // When called from beautify_loops() idom is not constructed yet.
  56   if (_idom != NULL) {
  57     set_idom(n, pred, dom_depth(pred));
  58   }
  59 }
  60 
  61 //------------------------------create_new_if_for_predicate------------------------
  62 // create a new if above the uct_if_pattern for the predicate to be promoted.
  63 //
  64 //          before                                after
  65 //        ----------                           ----------
  66 //           ctrl                                 ctrl
  67 //            |                                     |
  68 //            |                                     |
  69 //            v                                     v
  70 //           iff                                 new_iff
  71 //          /    \                                /      \
  72 //         /      \                              /        \
  73 //        v        v                            v          v
  74 //  uncommon_proj cont_proj                   if_uct     if_cont
  75 // \      |        |                           |          |
  76 //  \     |        |                           |          |
  77 //   v    v        v                           |          v
  78 //     rgn       loop                          |         iff
  79 //      |                                      |        /     \
  80 //      |                                      |       /       \
  81 //      v                                      |      v         v
  82 // uncommon_trap                               | uncommon_proj cont_proj
  83 //                                           \  \    |           |
  84 //                                            \  \   |           |
  85 //                                             v  v  v           v
  86 //                                               rgn           loop
  87 //                                                |
  88 //                                                |
  89 //                                                v
  90 //                                           uncommon_trap
  91 //
  92 //
  93 // We will create a region to guard the uct call if there is no one there.
  94 // The continuation projection (if_cont) of the new_iff is returned which
  95 // is by default a true projection if &#39;if_cont_is_true_proj&#39; is true.
  96 // Otherwise, the continuation projection is set up to be the false
  97 // projection. This code is also used to clone predicates to cloned loops.
  98 ProjNode* PhaseIdealLoop::create_new_if_for_predicate(ProjNode* cont_proj, Node* new_entry,
  99                                                       Deoptimization::DeoptReason reason,
 100                                                       int opcode, bool if_cont_is_true_proj) {
 101   assert(cont_proj-&gt;is_uncommon_trap_if_pattern(reason), &quot;must be a uct if pattern!&quot;);
 102   IfNode* iff = cont_proj-&gt;in(0)-&gt;as_If();
 103 
 104   ProjNode *uncommon_proj = iff-&gt;proj_out(1 - cont_proj-&gt;_con);
 105   Node     *rgn   = uncommon_proj-&gt;unique_ctrl_out();
 106   assert(rgn-&gt;is_Region() || rgn-&gt;is_Call(), &quot;must be a region or call uct&quot;);
 107 
 108   uint proj_index = 1; // region&#39;s edge corresponding to uncommon_proj
 109   if (!rgn-&gt;is_Region()) { // create a region to guard the call
 110     assert(rgn-&gt;is_Call(), &quot;must be call uct&quot;);
 111     CallNode* call = rgn-&gt;as_Call();
 112     IdealLoopTree* loop = get_loop(call);
 113     rgn = new RegionNode(1);
 114     rgn-&gt;add_req(uncommon_proj);
 115     register_control(rgn, loop, uncommon_proj);
 116     _igvn.replace_input_of(call, 0, rgn);
 117     // When called from beautify_loops() idom is not constructed yet.
 118     if (_idom != NULL) {
 119       set_idom(call, rgn, dom_depth(rgn));
 120     }
 121     for (DUIterator_Fast imax, i = uncommon_proj-&gt;fast_outs(imax); i &lt; imax; i++) {
 122       Node* n = uncommon_proj-&gt;fast_out(i);
 123       if (n-&gt;is_Load() || n-&gt;is_Store()) {
 124         _igvn.replace_input_of(n, 0, rgn);
 125         --i; --imax;
 126       }
 127     }
 128   } else {
 129     // Find region&#39;s edge corresponding to uncommon_proj
 130     for (; proj_index &lt; rgn-&gt;req(); proj_index++)
 131       if (rgn-&gt;in(proj_index) == uncommon_proj) break;
 132     assert(proj_index &lt; rgn-&gt;req(), &quot;sanity&quot;);
 133   }
 134 
 135   Node* entry = iff-&gt;in(0);
 136   if (new_entry != NULL) {
 137     // Clonning the predicate to new location.
 138     entry = new_entry;
 139   }
 140   // Create new_iff
 141   IdealLoopTree* lp = get_loop(entry);
 142   IfNode* new_iff = NULL;
 143   if (opcode == Op_If) {
 144     new_iff = new IfNode(entry, iff-&gt;in(1), iff-&gt;_prob, iff-&gt;_fcnt);
 145   } else {
 146     assert(opcode == Op_RangeCheck, &quot;no other if variant here&quot;);
 147     new_iff = new RangeCheckNode(entry, iff-&gt;in(1), iff-&gt;_prob, iff-&gt;_fcnt);
 148   }
 149   register_control(new_iff, lp, entry);
 150   Node* if_cont;
 151   Node* if_uct;
 152   if (if_cont_is_true_proj) {
 153     if_cont = new IfTrueNode(new_iff);
 154     if_uct  = new IfFalseNode(new_iff);
 155   } else {
 156     if_uct  = new IfTrueNode(new_iff);
 157     if_cont = new IfFalseNode(new_iff);
 158   }
 159 
 160   if (cont_proj-&gt;is_IfFalse()) {
 161     // Swap
 162     Node* tmp = if_uct; if_uct = if_cont; if_cont = tmp;
 163   }
 164   register_control(if_cont, lp, new_iff);
 165   register_control(if_uct, get_loop(rgn), new_iff);
 166 
 167   // if_uct to rgn
 168   _igvn.hash_delete(rgn);
 169   rgn-&gt;add_req(if_uct);
 170   // When called from beautify_loops() idom is not constructed yet.
 171   if (_idom != NULL) {
 172     Node* ridom = idom(rgn);
 173     Node* nrdom = dom_lca_internal(ridom, new_iff);
 174     set_idom(rgn, nrdom, dom_depth(rgn));
 175   }
 176 
 177   // If rgn has phis add new edges which has the same
 178   // value as on original uncommon_proj pass.
 179   assert(rgn-&gt;in(rgn-&gt;req() -1) == if_uct, &quot;new edge should be last&quot;);
 180   bool has_phi = false;
 181   for (DUIterator_Fast imax, i = rgn-&gt;fast_outs(imax); i &lt; imax; i++) {
 182     Node* use = rgn-&gt;fast_out(i);
 183     if (use-&gt;is_Phi() &amp;&amp; use-&gt;outcnt() &gt; 0) {
 184       assert(use-&gt;in(0) == rgn, &quot;&quot;);
 185       _igvn.rehash_node_delayed(use);
 186       use-&gt;add_req(use-&gt;in(proj_index));
 187       has_phi = true;
 188     }
 189   }
 190   assert(!has_phi || rgn-&gt;req() &gt; 3, &quot;no phis when region is created&quot;);
 191 
 192   if (new_entry == NULL) {
 193     // Attach if_cont to iff
 194     _igvn.replace_input_of(iff, 0, if_cont);
 195     if (_idom != NULL) {
 196       set_idom(iff, if_cont, dom_depth(iff));
 197     }
 198   }
 199   return if_cont-&gt;as_Proj();
 200 }
 201 
 202 //--------------------------clone_predicate-----------------------
 203 ProjNode* PhaseIdealLoop::clone_loop_predicate(ProjNode* predicate_proj, Node* new_entry, Deoptimization::DeoptReason reason,
 204                                                bool is_slow_loop, uint idx_before_clone, Node_List &amp;old_new) {
 205   ProjNode* new_predicate_proj = create_new_if_for_predicate(predicate_proj, new_entry, reason, Op_If);
 206   IfNode* iff = new_predicate_proj-&gt;in(0)-&gt;as_If();
 207   Node* ctrl  = iff-&gt;in(0);
 208 
 209   // Match original condition since predicate&#39;s projections could be swapped.
 210   assert(predicate_proj-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;Opcode()==Op_Opaque1, &quot;must be&quot;);
 211   Node* opq = new Opaque1Node(C, predicate_proj-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1));
 212   C-&gt;add_predicate_opaq(opq);
 213   Node* bol = new Conv2BNode(opq);
 214   register_new_node(opq, ctrl);
 215   register_new_node(bol, ctrl);
 216   _igvn.hash_delete(iff);
 217   iff-&gt;set_req(1, bol);
 218   clone_concrete_loop_predicates(reason, predicate_proj, new_predicate_proj, is_slow_loop, idx_before_clone, old_new);
 219   return new_predicate_proj;
 220 }
 221 
 222 // Clones all non-empty loop predicates (including skeleton predicates) starting at &#39;old_predicate_proj&#39; to &#39;new_predicate_proj&#39;
 223 // and rewires the control edges of data nodes in the loop to the old predicates to the new cloned predicates.
 224 void PhaseIdealLoop::clone_concrete_loop_predicates(Deoptimization::DeoptReason reason, ProjNode* old_predicate_proj,
 225                                                     ProjNode* new_predicate_proj, bool is_slow_loop, uint idx_before_clone,
 226                                                     Node_List &amp;old_new) {
 227   assert(old_predicate_proj-&gt;is_Proj(), &quot;must be projection&quot;);
 228   IfNode* iff = old_predicate_proj-&gt;in(0)-&gt;as_If();
 229   ProjNode* uncommon_proj = iff-&gt;proj_out(1 - old_predicate_proj-&gt;as_Proj()-&gt;_con);
 230   Node* rgn = uncommon_proj-&gt;unique_ctrl_out();
 231   assert(rgn-&gt;is_Region() || rgn-&gt;is_Call(), &quot;must be a region or call uct&quot;);
 232   assert(iff-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_Opaque1, &quot;unexpected predicate shape&quot;);
 233   Node* predicate = iff-&gt;in(0);
 234   Node* current_proj = old_predicate_proj;
 235   Node* prev_proj = current_proj;
 236   Unique_Node_List list;
 237   while (predicate != NULL &amp;&amp; predicate-&gt;is_Proj() &amp;&amp; predicate-&gt;in(0)-&gt;is_If()) {
 238     iff = predicate-&gt;in(0)-&gt;as_If();
 239     uncommon_proj = iff-&gt;proj_out(1 - predicate-&gt;as_Proj()-&gt;_con);
 240     if (uncommon_proj-&gt;unique_ctrl_out() != rgn)
 241       break;
 242     if (iff-&gt;is_RangeCheck()) {
 243       // Only need to clone range check predicates as those can be changed and duplicated by inserting pre/main/post loops
 244       // and doing loop unrolling. Push the original predicates on a list to later process them in reverse order to keep the
 245       // original predicate order.
 246       list.push(predicate);
 247 #ifdef ASSERT
 248     } else {
 249       // All other If predicates should not have a control input to nodes belonging to the original loop
 250       for (DUIterator i = predicate-&gt;outs(); predicate-&gt;has_out(i); i++) {
 251         Node* old_node = predicate-&gt;out(i);
 252         Node* new_node = old_new[old_node-&gt;_idx];
 253         if (!old_node-&gt;is_CFG() &amp;&amp; new_node != NULL &amp;&amp; old_node-&gt;_idx &gt;= idx_before_clone) {
 254           assert(false, &quot;should not be part of the original loop&quot;);
 255         }
 256       }
 257 #endif
 258     }
 259     predicate = predicate-&gt;in(0)-&gt;in(0);
 260   }
 261 
 262   // Process in reverse order such that &#39;create_new_if_for_predicate&#39; can be used and the original order is maintained
 263   for (int i = list.size()-1; i &gt;= 0; i--) {
 264     predicate = list.at(i);
 265     assert(predicate-&gt;in(0)-&gt;is_If(), &quot;must be If node&quot;);
 266     iff = predicate-&gt;in(0)-&gt;as_If();
 267     assert(predicate-&gt;is_Proj() &amp;&amp; predicate-&gt;as_Proj()-&gt;is_IfProj() &amp;&amp; iff-&gt;is_RangeCheck(), &quot;predicate must be a projection of a range check&quot;);
 268     IfProjNode* predicate_proj = predicate-&gt;as_IfProj();
 269 
 270     // cloned_proj is the same type of projection as the original predicate projection (IfTrue or IfFalse)
 271     ProjNode* cloned_proj = create_new_if_for_predicate(new_predicate_proj, NULL, reason, Op_RangeCheck, predicate_proj-&gt;is_IfTrue());
 272 
 273     // Replace bool input by input from original predicate
 274     _igvn.replace_input_of(cloned_proj-&gt;in(0), 1, iff-&gt;in(1));
 275 
 276     if (is_slow_loop) {
 277       for (DUIterator i = predicate-&gt;outs(); predicate-&gt;has_out(i); i++) {
 278         Node* slow_node = predicate-&gt;out(i);
 279         Node* fast_node = old_new[slow_node-&gt;_idx];
 280         if (!slow_node-&gt;is_CFG() &amp;&amp; fast_node != NULL &amp;&amp; slow_node-&gt;_idx &gt; idx_before_clone) {
 281           // &#39;slow_node&#39; is a data node and part of the slow loop. This is a clone of the fast loop node
 282           // which was temporarily added below in order to verify that &#39;slow_node&#39; is a clone of &#39;fast_node&#39;.
 283           // Update the control input and reset the mapping for &#39;slow_node&#39; back to NULL.
 284           _igvn.replace_input_of(slow_node, 0, cloned_proj);
 285           old_new.map(slow_node-&gt;_idx, NULL);
 286           --i;
 287         }
 288         assert(slow_node-&gt;_idx &lt;= idx_before_clone || old_new[slow_node-&gt;_idx] == NULL, &quot;mapping of cloned nodes must be null&quot;);
 289       }
 290 
 291       // Let old predicates before unswitched loops which were cloned die if all their control edges were rewired
 292       // to the cloned predicates in the unswitched loops.
 293       if (predicate-&gt;outcnt() == 1) {
 294         _igvn.replace_input_of(iff, 1, _igvn.intcon(predicate_proj-&gt;_con));
 295       }
 296     } else {
 297       // Fast loop
 298       for (DUIterator i = predicate-&gt;outs(); predicate-&gt;has_out(i); i++) {
 299         Node* fast_node = predicate-&gt;out(i);
 300         Node* slow_node = old_new[fast_node-&gt;_idx];
 301         if (!fast_node-&gt;is_CFG() &amp;&amp; slow_node != NULL &amp;&amp; slow_node-&gt;_idx &gt; idx_before_clone) {
 302           // &#39;fast_node&#39; is a data node and part of the fast loop. Add the clone of the fast loop node
 303           // to the &#39;old_new&#39; mapping in order to verify later when cloning the predicates for the slow loop
 304           // that &#39;slow_node&#39; is a clone of &#39;fast_node&#39;. Update the control input for &#39;fast_node&#39;.
 305           _igvn.replace_input_of(fast_node, 0, cloned_proj);
 306           assert(old_new[slow_node-&gt;_idx] == NULL, &quot;mapping must be null for cloned nodes&quot;);
 307           old_new.map(slow_node-&gt;_idx, fast_node);
 308           --i;
 309         }
 310       }
 311     }
 312   }
 313 }
 314 
 315 //--------------------------clone_loop_predicates-----------------------
 316 // Clone loop predicates to cloned loops when unswitching a loop.
 317 Node* PhaseIdealLoop::clone_loop_predicates(Node* old_entry, Node* new_entry, bool clone_limit_check,
 318                                             bool is_slow_loop, uint idx_before_clone, Node_List &amp;old_new) {
 319 #ifdef ASSERT
 320   assert(LoopUnswitching, &quot;sanity - only called when unswitching a loop&quot;);
 321   if (new_entry == NULL || !(new_entry-&gt;is_Proj() || new_entry-&gt;is_Region() || new_entry-&gt;is_SafePoint())) {
 322     if (new_entry != NULL)
 323       new_entry-&gt;dump();
 324     assert(false, &quot;not IfTrue, IfFalse, Region or SafePoint&quot;);
 325   }
 326 #endif
 327   // Search original predicates
 328   Node* entry = old_entry;
 329   ProjNode* limit_check_proj = NULL;
 330   limit_check_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
 331   if (limit_check_proj != NULL) {
 332     entry = skip_loop_predicates(entry);
 333   }
 334   ProjNode* profile_predicate_proj = NULL;
 335   ProjNode* predicate_proj = NULL;
 336   if (UseProfiledLoopPredicate) {
 337     profile_predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);
 338     if (profile_predicate_proj != NULL) {
 339       entry = skip_loop_predicates(entry);
 340     }
 341   }
 342   if (UseLoopPredicate) {
 343     predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
 344   }
 345   if (predicate_proj != NULL) { // right pattern that can be used by loop predication
 346     // clone predicate
 347     new_entry = clone_loop_predicate(predicate_proj, new_entry, Deoptimization::Reason_predicate, is_slow_loop,
 348                                      idx_before_clone, old_new);
 349     assert(new_entry != NULL &amp;&amp; new_entry-&gt;is_Proj(), &quot;IfTrue or IfFalse after clone predicate&quot;);
 350     if (TraceLoopPredicate) {
 351       tty-&gt;print(&quot;Loop Predicate cloned: &quot;);
 352       debug_only( new_entry-&gt;in(0)-&gt;dump(); );
 353     }
 354   }
 355   if (profile_predicate_proj != NULL) { // right pattern that can be used by loop predication
 356     // clone predicate
 357     new_entry = clone_loop_predicate(profile_predicate_proj, new_entry,Deoptimization::Reason_profile_predicate,
 358                                      is_slow_loop, idx_before_clone, old_new);
 359     assert(new_entry != NULL &amp;&amp; new_entry-&gt;is_Proj(), &quot;IfTrue or IfFalse after clone predicate&quot;);
 360     if (TraceLoopPredicate) {
 361       tty-&gt;print(&quot;Loop Predicate cloned: &quot;);
 362       debug_only( new_entry-&gt;in(0)-&gt;dump(); );
 363     }
 364   }
 365   if (limit_check_proj != NULL &amp;&amp; clone_limit_check) {
 366     // Clone loop limit check last to insert it before loop.
 367     // Don&#39;t clone a limit check which was already finalized
 368     // for this counted loop (only one limit check is needed).
 369     new_entry = clone_loop_predicate(limit_check_proj, new_entry, Deoptimization::Reason_loop_limit_check,
 370                                      is_slow_loop, idx_before_clone, old_new);
 371     assert(new_entry != NULL &amp;&amp; new_entry-&gt;is_Proj(), &quot;IfTrue or IfFalse after clone limit check&quot;);
 372     if (TraceLoopLimitCheck) {
 373       tty-&gt;print(&quot;Loop Limit Check cloned: &quot;);
 374       debug_only( new_entry-&gt;in(0)-&gt;dump(); )
 375     }
 376   }
 377   return new_entry;
 378 }
 379 
 380 //--------------------------skip_loop_predicates------------------------------
 381 // Skip related predicates.
 382 Node* PhaseIdealLoop::skip_loop_predicates(Node* entry) {
 383   IfNode* iff = entry-&gt;in(0)-&gt;as_If();
 384   ProjNode* uncommon_proj = iff-&gt;proj_out(1 - entry-&gt;as_Proj()-&gt;_con);
 385   Node* rgn = uncommon_proj-&gt;unique_ctrl_out();
 386   assert(rgn-&gt;is_Region() || rgn-&gt;is_Call(), &quot;must be a region or call uct&quot;);
 387   entry = entry-&gt;in(0)-&gt;in(0);
 388   while (entry != NULL &amp;&amp; entry-&gt;is_Proj() &amp;&amp; entry-&gt;in(0)-&gt;is_If()) {
 389     uncommon_proj = entry-&gt;in(0)-&gt;as_If()-&gt;proj_out(1 - entry-&gt;as_Proj()-&gt;_con);
 390     if (uncommon_proj-&gt;unique_ctrl_out() != rgn)
 391       break;
 392     entry = entry-&gt;in(0)-&gt;in(0);
 393   }
 394   return entry;
 395 }
 396 
 397 Node* PhaseIdealLoop::skip_all_loop_predicates(Node* entry) {
 398   Node* predicate = NULL;
 399   predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
 400   if (predicate != NULL) {
 401     entry = skip_loop_predicates(entry);
 402   }
 403   if (UseProfiledLoopPredicate) {
 404     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);
 405     if (predicate != NULL) { // right pattern that can be used by loop predication
 406       entry = skip_loop_predicates(entry);
 407     }
 408   }
 409   if (UseLoopPredicate) {
 410     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
 411     if (predicate != NULL) { // right pattern that can be used by loop predication
 412       entry = skip_loop_predicates(entry);
 413     }
 414   }
 415   return entry;
 416 }
 417 
 418 //--------------------------find_predicate_insertion_point-------------------
 419 // Find a good location to insert a predicate
 420 ProjNode* PhaseIdealLoop::find_predicate_insertion_point(Node* start_c, Deoptimization::DeoptReason reason) {
 421   if (start_c == NULL || !start_c-&gt;is_Proj())
 422     return NULL;
 423   if (start_c-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(reason)) {
 424     return start_c-&gt;as_Proj();
 425   }
 426   return NULL;
 427 }
 428 
 429 //--------------------------find_predicate------------------------------------
 430 // Find a predicate
 431 Node* PhaseIdealLoop::find_predicate(Node* entry) {
 432   Node* predicate = NULL;
 433   predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
 434   if (predicate != NULL) { // right pattern that can be used by loop predication
 435     return entry;
 436   }
 437   if (UseLoopPredicate) {
 438     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
 439     if (predicate != NULL) { // right pattern that can be used by loop predication
 440       return entry;
 441     }
 442   }
 443   if (UseProfiledLoopPredicate) {
 444     predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);
 445     if (predicate != NULL) { // right pattern that can be used by loop predication
 446       return entry;
 447     }
 448   }
 449   return NULL;
 450 }
 451 
 452 //------------------------------Invariance-----------------------------------
 453 // Helper class for loop_predication_impl to compute invariance on the fly and
 454 // clone invariants.
 455 class Invariance : public StackObj {
 456   VectorSet _visited, _invariant;
 457   Node_Stack _stack;
 458   VectorSet _clone_visited;
 459   Node_List _old_new; // map of old to new (clone)
 460   IdealLoopTree* _lpt;
 461   PhaseIdealLoop* _phase;
 462 
 463   // Helper function to set up the invariance for invariance computation
 464   // If n is a known invariant, set up directly. Otherwise, look up the
 465   // the possibility to push n onto the stack for further processing.
 466   void visit(Node* use, Node* n) {
 467     if (_lpt-&gt;is_invariant(n)) { // known invariant
 468       _invariant.set(n-&gt;_idx);
 469     } else if (!n-&gt;is_CFG()) {
 470       Node *n_ctrl = _phase-&gt;ctrl_or_self(n);
 471       Node *u_ctrl = _phase-&gt;ctrl_or_self(use); // self if use is a CFG
 472       if (_phase-&gt;is_dominator(n_ctrl, u_ctrl)) {
 473         _stack.push(n, n-&gt;in(0) == NULL ? 1 : 0);
 474       }
 475     }
 476   }
 477 
 478   // Compute invariance for &quot;the_node&quot; and (possibly) all its inputs recursively
 479   // on the fly
 480   void compute_invariance(Node* n) {
 481     assert(_visited.test(n-&gt;_idx), &quot;must be&quot;);
 482     visit(n, n);
 483     while (_stack.is_nonempty()) {
 484       Node*  n = _stack.node();
 485       uint idx = _stack.index();
 486       if (idx == n-&gt;req()) { // all inputs are processed
 487         _stack.pop();
 488         // n is invariant if it&#39;s inputs are all invariant
 489         bool all_inputs_invariant = true;
 490         for (uint i = 0; i &lt; n-&gt;req(); i++) {
 491           Node* in = n-&gt;in(i);
 492           if (in == NULL) continue;
 493           assert(_visited.test(in-&gt;_idx), &quot;must have visited input&quot;);
 494           if (!_invariant.test(in-&gt;_idx)) { // bad guy
 495             all_inputs_invariant = false;
 496             break;
 497           }
 498         }
 499         if (all_inputs_invariant) {
 500           // If n&#39;s control is a predicate that was moved out of the
 501           // loop, it was marked invariant but n is only invariant if
 502           // it depends only on that test. Otherwise, unless that test
 503           // is out of the loop, it&#39;s not invariant.
 504           if (n-&gt;is_CFG() || n-&gt;depends_only_on_test() || n-&gt;in(0) == NULL || !_phase-&gt;is_member(_lpt, n-&gt;in(0))) {
 505             _invariant.set(n-&gt;_idx); // I am a invariant too
 506           }
 507         }
 508       } else { // process next input
 509         _stack.set_index(idx + 1);
 510         Node* m = n-&gt;in(idx);
 511         if (m != NULL &amp;&amp; !_visited.test_set(m-&gt;_idx)) {
 512           visit(n, m);
 513         }
 514       }
 515     }
 516   }
 517 
 518   // Helper function to set up _old_new map for clone_nodes.
 519   // If n is a known invariant, set up directly (&quot;clone&quot; of n == n).
 520   // Otherwise, push n onto the stack for real cloning.
 521   void clone_visit(Node* n) {
 522     assert(_invariant.test(n-&gt;_idx), &quot;must be invariant&quot;);
 523     if (_lpt-&gt;is_invariant(n)) { // known invariant
 524       _old_new.map(n-&gt;_idx, n);
 525     } else { // to be cloned
 526       assert(!n-&gt;is_CFG(), &quot;should not see CFG here&quot;);
 527       _stack.push(n, n-&gt;in(0) == NULL ? 1 : 0);
 528     }
 529   }
 530 
 531   // Clone &quot;n&quot; and (possibly) all its inputs recursively
 532   void clone_nodes(Node* n, Node* ctrl) {
 533     clone_visit(n);
 534     while (_stack.is_nonempty()) {
 535       Node*  n = _stack.node();
 536       uint idx = _stack.index();
 537       if (idx == n-&gt;req()) { // all inputs processed, clone n!
 538         _stack.pop();
 539         // clone invariant node
 540         Node* n_cl = n-&gt;clone();
 541         _old_new.map(n-&gt;_idx, n_cl);
 542         _phase-&gt;register_new_node(n_cl, ctrl);
 543         for (uint i = 0; i &lt; n-&gt;req(); i++) {
 544           Node* in = n_cl-&gt;in(i);
 545           if (in == NULL) continue;
 546           n_cl-&gt;set_req(i, _old_new[in-&gt;_idx]);
 547         }
 548       } else { // process next input
 549         _stack.set_index(idx + 1);
 550         Node* m = n-&gt;in(idx);
 551         if (m != NULL &amp;&amp; !_clone_visited.test_set(m-&gt;_idx)) {
 552           clone_visit(m); // visit the input
 553         }
 554       }
 555     }
 556   }
 557 
 558  public:
 559   Invariance(Arena* area, IdealLoopTree* lpt) :
 560     _visited(area), _invariant(area),
 561     _stack(area, 10 /* guess */),
 562     _clone_visited(area), _old_new(area),
 563     _lpt(lpt), _phase(lpt-&gt;_phase)
 564   {
 565     LoopNode* head = _lpt-&gt;_head-&gt;as_Loop();
 566     Node* entry = head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
 567     if (entry-&gt;outcnt() != 1) {
 568       // If a node is pinned between the predicates and the loop
 569       // entry, we won&#39;t be able to move any node in the loop that
 570       // depends on it above it in a predicate. Mark all those nodes
 571       // as non loop invariatnt.
 572       Unique_Node_List wq;
 573       wq.push(entry);
 574       for (uint next = 0; next &lt; wq.size(); ++next) {
 575         Node *n = wq.at(next);
 576         for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
 577           Node* u = n-&gt;fast_out(i);
 578           if (!u-&gt;is_CFG()) {
 579             Node* c = _phase-&gt;get_ctrl(u);
 580             if (_lpt-&gt;is_member(_phase-&gt;get_loop(c)) || _phase-&gt;is_dominator(c, head)) {
 581               _visited.set(u-&gt;_idx);
 582               wq.push(u);
 583             }
 584           }
 585         }
 586       }
 587     }
 588   }
 589 
 590   // Map old to n for invariance computation and clone
 591   void map_ctrl(Node* old, Node* n) {
 592     assert(old-&gt;is_CFG() &amp;&amp; n-&gt;is_CFG(), &quot;must be&quot;);
 593     _old_new.map(old-&gt;_idx, n); // &quot;clone&quot; of old is n
 594     _invariant.set(old-&gt;_idx);  // old is invariant
 595     _clone_visited.set(old-&gt;_idx);
 596   }
 597 
 598   // Driver function to compute invariance
 599   bool is_invariant(Node* n) {
 600     if (!_visited.test_set(n-&gt;_idx))
 601       compute_invariance(n);
 602     return (_invariant.test(n-&gt;_idx) != 0);
 603   }
 604 
 605   // Driver function to clone invariant
 606   Node* clone(Node* n, Node* ctrl) {
 607     assert(ctrl-&gt;is_CFG(), &quot;must be&quot;);
 608     assert(_invariant.test(n-&gt;_idx), &quot;must be an invariant&quot;);
 609     if (!_clone_visited.test(n-&gt;_idx))
 610       clone_nodes(n, ctrl);
 611     return _old_new[n-&gt;_idx];
 612   }
 613 };
 614 
 615 //------------------------------is_range_check_if -----------------------------------
 616 // Returns true if the predicate of iff is in &quot;scale*iv + offset u&lt; load_range(ptr)&quot; format
 617 // Note: this function is particularly designed for loop predication. We require load_range
 618 //       and offset to be loop invariant computed on the fly by &quot;invar&quot;
 619 bool IdealLoopTree::is_range_check_if(IfNode *iff, PhaseIdealLoop *phase, Invariance&amp; invar) const {
 620   if (!is_loop_exit(iff)) {
 621     return false;
 622   }
 623   if (!iff-&gt;in(1)-&gt;is_Bool()) {
 624     return false;
 625   }
 626   const BoolNode *bol = iff-&gt;in(1)-&gt;as_Bool();
 627   if (bol-&gt;_test._test != BoolTest::lt) {
 628     return false;
 629   }
 630   if (!bol-&gt;in(1)-&gt;is_Cmp()) {
 631     return false;
 632   }
 633   const CmpNode *cmp = bol-&gt;in(1)-&gt;as_Cmp();
 634   if (cmp-&gt;Opcode() != Op_CmpU) {
 635     return false;
 636   }
 637   Node* range = cmp-&gt;in(2);
 638   if (range-&gt;Opcode() != Op_LoadRange &amp;&amp; !iff-&gt;is_RangeCheck()) {
 639     const TypeInt* tint = phase-&gt;_igvn.type(range)-&gt;isa_int();
 640     if (tint == NULL || tint-&gt;empty() || tint-&gt;_lo &lt; 0) {
 641       // Allow predication on positive values that aren&#39;t LoadRanges.
 642       // This allows optimization of loops where the length of the
 643       // array is a known value and doesn&#39;t need to be loaded back
 644       // from the array.
 645       return false;
 646     }
 647   }
 648   if (!invar.is_invariant(range)) {
 649     return false;
 650   }
 651   Node *iv     = _head-&gt;as_CountedLoop()-&gt;phi();
 652   int   scale  = 0;
 653   Node *offset = NULL;
 654   if (!phase-&gt;is_scaled_iv_plus_offset(cmp-&gt;in(1), iv, &amp;scale, &amp;offset)) {
 655     return false;
 656   }
 657   if (offset &amp;&amp; !invar.is_invariant(offset)) { // offset must be invariant
 658     return false;
 659   }
 660   return true;
 661 }
 662 
 663 //------------------------------rc_predicate-----------------------------------
 664 // Create a range check predicate
 665 //
 666 // for (i = init; i &lt; limit; i += stride) {
 667 //    a[scale*i+offset]
 668 // }
 669 //
 670 // Compute max(scale*i + offset) for init &lt;= i &lt; limit and build the predicate
 671 // as &quot;max(scale*i + offset) u&lt; a.length&quot;.
 672 //
 673 // There are two cases for max(scale*i + offset):
 674 // (1) stride*scale &gt; 0
 675 //   max(scale*i + offset) = scale*(limit-stride) + offset
 676 // (2) stride*scale &lt; 0
 677 //   max(scale*i + offset) = scale*init + offset
 678 BoolNode* PhaseIdealLoop::rc_predicate(IdealLoopTree *loop, Node* ctrl,
 679                                        int scale, Node* offset,
 680                                        Node* init, Node* limit, jint stride,
 681                                        Node* range, bool upper, bool &amp;overflow) {
 682   jint con_limit  = (limit != NULL &amp;&amp; limit-&gt;is_Con())  ? limit-&gt;get_int()  : 0;
 683   jint con_init   = init-&gt;is_Con()   ? init-&gt;get_int()   : 0;
 684   jint con_offset = offset-&gt;is_Con() ? offset-&gt;get_int() : 0;
 685 
 686   stringStream* predString = NULL;
 687   if (TraceLoopPredicate) {
 688     predString = new stringStream();
 689     predString-&gt;print(&quot;rc_predicate &quot;);
 690   }
 691 
 692   overflow = false;
 693   Node* max_idx_expr = NULL;
 694   const TypeInt* idx_type = TypeInt::INT;
 695   if ((stride &gt; 0) == (scale &gt; 0) == upper) {
 696     guarantee(limit != NULL, &quot;sanity&quot;);
 697     if (TraceLoopPredicate) {
 698       if (limit-&gt;is_Con()) {
 699         predString-&gt;print(&quot;(%d &quot;, con_limit);
 700       } else {
 701         predString-&gt;print(&quot;(limit &quot;);
 702       }
 703       predString-&gt;print(&quot;- %d) &quot;, stride);
 704     }
 705     // Check if (limit - stride) may overflow
 706     const TypeInt* limit_type = _igvn.type(limit)-&gt;isa_int();
 707     jint limit_lo = limit_type-&gt;_lo;
 708     jint limit_hi = limit_type-&gt;_hi;
 709     if ((stride &gt; 0 &amp;&amp; (java_subtract(limit_lo, stride) &lt; limit_lo)) ||
 710         (stride &lt; 0 &amp;&amp; (java_subtract(limit_hi, stride) &gt; limit_hi))) {
 711       // No overflow possible
 712       ConINode* con_stride = _igvn.intcon(stride);
 713       set_ctrl(con_stride, C-&gt;root());
 714       max_idx_expr = new SubINode(limit, con_stride);
 715       idx_type = TypeInt::make(limit_lo - stride, limit_hi - stride, limit_type-&gt;_widen);
 716     } else {
 717       // May overflow
 718       overflow = true;
 719       limit = new ConvI2LNode(limit);
 720       register_new_node(limit, ctrl);
 721       ConLNode* con_stride = _igvn.longcon(stride);
 722       set_ctrl(con_stride, C-&gt;root());
 723       max_idx_expr = new SubLNode(limit, con_stride);
 724     }
 725     register_new_node(max_idx_expr, ctrl);
 726   } else {
 727     if (TraceLoopPredicate) {
 728       if (init-&gt;is_Con()) {
 729         predString-&gt;print(&quot;%d &quot;, con_init);
 730       } else {
 731         predString-&gt;print(&quot;init &quot;);
 732       }
 733     }
 734     idx_type = _igvn.type(init)-&gt;isa_int();
 735     max_idx_expr = init;
 736   }
 737 
 738   if (scale != 1) {
 739     ConNode* con_scale = _igvn.intcon(scale);
 740     set_ctrl(con_scale, C-&gt;root());
 741     if (TraceLoopPredicate) {
 742       predString-&gt;print(&quot;* %d &quot;, scale);
 743     }
 744     // Check if (scale * max_idx_expr) may overflow
 745     const TypeInt* scale_type = TypeInt::make(scale);
 746     MulINode* mul = new MulINode(max_idx_expr, con_scale);
 747     idx_type = (TypeInt*)mul-&gt;mul_ring(idx_type, scale_type);
 748     if (overflow || TypeInt::INT-&gt;higher_equal(idx_type)) {
 749       // May overflow
 750       mul-&gt;destruct();
 751       if (!overflow) {
 752         max_idx_expr = new ConvI2LNode(max_idx_expr);
 753         register_new_node(max_idx_expr, ctrl);
 754       }
 755       overflow = true;
 756       con_scale = _igvn.longcon(scale);
 757       set_ctrl(con_scale, C-&gt;root());
 758       max_idx_expr = new MulLNode(max_idx_expr, con_scale);
 759     } else {
 760       // No overflow possible
 761       max_idx_expr = mul;
 762     }
 763     register_new_node(max_idx_expr, ctrl);
 764   }
 765 
 766   if (offset &amp;&amp; (!offset-&gt;is_Con() || con_offset != 0)){
 767     if (TraceLoopPredicate) {
 768       if (offset-&gt;is_Con()) {
 769         predString-&gt;print(&quot;+ %d &quot;, con_offset);
 770       } else {
 771         predString-&gt;print(&quot;+ offset&quot;);
 772       }
 773     }
 774     // Check if (max_idx_expr + offset) may overflow
 775     const TypeInt* offset_type = _igvn.type(offset)-&gt;isa_int();
 776     jint lo = java_add(idx_type-&gt;_lo, offset_type-&gt;_lo);
 777     jint hi = java_add(idx_type-&gt;_hi, offset_type-&gt;_hi);
 778     if (overflow || (lo &gt; hi) ||
 779         ((idx_type-&gt;_lo &amp; offset_type-&gt;_lo) &lt; 0 &amp;&amp; lo &gt;= 0) ||
 780         ((~(idx_type-&gt;_hi | offset_type-&gt;_hi)) &lt; 0 &amp;&amp; hi &lt; 0)) {
 781       // May overflow
 782       if (!overflow) {
 783         max_idx_expr = new ConvI2LNode(max_idx_expr);
 784         register_new_node(max_idx_expr, ctrl);
 785       }
 786       overflow = true;
 787       offset = new ConvI2LNode(offset);
 788       register_new_node(offset, ctrl);
 789       max_idx_expr = new AddLNode(max_idx_expr, offset);
 790     } else {
 791       // No overflow possible
 792       max_idx_expr = new AddINode(max_idx_expr, offset);
 793     }
 794     register_new_node(max_idx_expr, ctrl);
 795   }
 796 
 797   CmpNode* cmp = NULL;
 798   if (overflow) {
 799     // Integer expressions may overflow, do long comparison
 800     range = new ConvI2LNode(range);
 801     register_new_node(range, ctrl);
 802     cmp = new CmpULNode(max_idx_expr, range);
 803   } else {
 804     cmp = new CmpUNode(max_idx_expr, range);
 805   }
 806   register_new_node(cmp, ctrl);
 807   BoolNode* bol = new BoolNode(cmp, BoolTest::lt);
 808   register_new_node(bol, ctrl);
 809 
 810   if (TraceLoopPredicate) {
 811     predString-&gt;print_cr(&quot;&lt;u range&quot;);
 812     tty-&gt;print(&quot;%s&quot;, predString-&gt;base());
 813     predString-&gt;~stringStream();
 814   }
 815   return bol;
 816 }
 817 
 818 // Should loop predication look not only in the path from tail to head
 819 // but also in branches of the loop body?
 820 bool PhaseIdealLoop::loop_predication_should_follow_branches(IdealLoopTree *loop, ProjNode *predicate_proj, float&amp; loop_trip_cnt) {
 821   if (!UseProfiledLoopPredicate) {
 822     return false;
 823   }
 824 
 825   if (predicate_proj == NULL) {
 826     return false;
 827   }
 828 
 829   LoopNode* head = loop-&gt;_head-&gt;as_Loop();
 830   bool follow_branches = true;
 831   IdealLoopTree* l = loop-&gt;_child;
 832   // For leaf loops and loops with a single inner loop
 833   while (l != NULL &amp;&amp; follow_branches) {
 834     IdealLoopTree* child = l;
 835     if (child-&gt;_child != NULL &amp;&amp;
 836         child-&gt;_head-&gt;is_OuterStripMinedLoop()) {
 837       assert(child-&gt;_child-&gt;_next == NULL, &quot;only one inner loop for strip mined loop&quot;);
 838       assert(child-&gt;_child-&gt;_head-&gt;is_CountedLoop() &amp;&amp; child-&gt;_child-&gt;_head-&gt;as_CountedLoop()-&gt;is_strip_mined(), &quot;inner loop should be strip mined&quot;);
 839       child = child-&gt;_child;
 840     }
 841     if (child-&gt;_child != NULL || child-&gt;_irreducible) {
 842       follow_branches = false;
 843     }
 844     l = l-&gt;_next;
 845   }
 846   if (follow_branches) {
 847     loop-&gt;compute_profile_trip_cnt(this);
 848     if (head-&gt;is_profile_trip_failed()) {
 849       follow_branches = false;
 850     } else {
 851       loop_trip_cnt = head-&gt;profile_trip_cnt();
 852       if (head-&gt;is_CountedLoop()) {
 853         CountedLoopNode* cl = head-&gt;as_CountedLoop();
 854         if (cl-&gt;phi() != NULL) {
 855           const TypeInt* t = _igvn.type(cl-&gt;phi())-&gt;is_int();
 856           float worst_case_trip_cnt = ((float)t-&gt;_hi - t-&gt;_lo) / ABS(cl-&gt;stride_con());
 857           if (worst_case_trip_cnt &lt; loop_trip_cnt) {
 858             loop_trip_cnt = worst_case_trip_cnt;
 859           }
 860         }
 861       }
 862     }
 863   }
 864   return follow_branches;
 865 }
 866 
 867 // Compute probability of reaching some CFG node from a fixed
 868 // dominating CFG node
 869 class PathFrequency {
 870 private:
 871   Node* _dom; // frequencies are computed relative to this node
 872   Node_Stack _stack;
 873   GrowableArray&lt;float&gt; _freqs_stack; // keep track of intermediate result at regions
 874   GrowableArray&lt;float&gt; _freqs; // cache frequencies
 875   PhaseIdealLoop* _phase;
 876 
 877   void set_rounding(int mode) {
 878     // fesetround is broken on windows
 879     NOT_WINDOWS(fesetround(mode);)
 880   }
 881 
 882   void check_frequency(float f) {
 883     NOT_WINDOWS(assert(f &lt;= 1 &amp;&amp; f &gt;= 0, &quot;Incorrect frequency&quot;);)
 884   }
 885 
 886 public:
 887   PathFrequency(Node* dom, PhaseIdealLoop* phase)
 888     : _dom(dom), _stack(0), _phase(phase) {
 889   }
 890 
 891   float to(Node* n) {
 892     // post order walk on the CFG graph from n to _dom
 893     set_rounding(FE_TOWARDZERO); // make sure rounding doesn&#39;t push frequency above 1
 894     IdealLoopTree* loop = _phase-&gt;get_loop(_dom);
 895     Node* c = n;
 896     for (;;) {
 897       assert(_phase-&gt;get_loop(c) == loop, &quot;have to be in the same loop&quot;);
 898       if (c == _dom || _freqs.at_grow(c-&gt;_idx, -1) &gt;= 0) {
 899         float f = c == _dom ? 1 : _freqs.at(c-&gt;_idx);
 900         Node* prev = c;
 901         while (_stack.size() &gt; 0 &amp;&amp; prev == c) {
 902           Node* n = _stack.node();
 903           if (!n-&gt;is_Region()) {
 904             if (_phase-&gt;get_loop(n) != _phase-&gt;get_loop(n-&gt;in(0))) {
 905               // Found an inner loop: compute frequency of reaching this
 906               // exit from the loop head by looking at the number of
 907               // times each loop exit was taken
 908               IdealLoopTree* inner_loop = _phase-&gt;get_loop(n-&gt;in(0));
 909               LoopNode* inner_head = inner_loop-&gt;_head-&gt;as_Loop();
 910               assert(_phase-&gt;get_loop(n) == loop, &quot;only 1 inner loop&quot;);
 911               if (inner_head-&gt;is_OuterStripMinedLoop()) {
 912                 inner_head-&gt;verify_strip_mined(1);
 913                 if (n-&gt;in(0) == inner_head-&gt;in(LoopNode::LoopBackControl)-&gt;in(0)) {
 914                   n = n-&gt;in(0)-&gt;in(0)-&gt;in(0);
 915                 }
 916                 inner_loop = inner_loop-&gt;_child;
 917                 inner_head = inner_loop-&gt;_head-&gt;as_Loop();
 918                 inner_head-&gt;verify_strip_mined(1);
 919               }
 920               set_rounding(FE_UPWARD);  // make sure rounding doesn&#39;t push frequency above 1
 921               float loop_exit_cnt = 0.0f;
 922               for (uint i = 0; i &lt; inner_loop-&gt;_body.size(); i++) {
 923                 Node *n = inner_loop-&gt;_body[i];
 924                 float c = inner_loop-&gt;compute_profile_trip_cnt_helper(n);
 925                 loop_exit_cnt += c;
 926               }
 927               set_rounding(FE_TOWARDZERO);
 928               float cnt = -1;
 929               if (n-&gt;in(0)-&gt;is_If()) {
 930                 IfNode* iff = n-&gt;in(0)-&gt;as_If();
 931                 float p = n-&gt;in(0)-&gt;as_If()-&gt;_prob;
 932                 if (n-&gt;Opcode() == Op_IfFalse) {
 933                   p = 1 - p;
 934                 }
 935                 if (p &gt; PROB_MIN) {
 936                   cnt = p * iff-&gt;_fcnt;
 937                 } else {
 938                   cnt = 0;
 939                 }
 940               } else {
 941                 assert(n-&gt;in(0)-&gt;is_Jump(), &quot;unsupported node kind&quot;);
 942                 JumpNode* jmp = n-&gt;in(0)-&gt;as_Jump();
 943                 float p = n-&gt;in(0)-&gt;as_Jump()-&gt;_probs[n-&gt;as_JumpProj()-&gt;_con];
 944                 cnt = p * jmp-&gt;_fcnt;
 945               }
 946               float this_exit_f = cnt &gt; 0 ? cnt / loop_exit_cnt : 0;
 947               check_frequency(this_exit_f);
 948               f = f * this_exit_f;
 949               check_frequency(f);
 950             } else {
 951               float p = -1;
 952               if (n-&gt;in(0)-&gt;is_If()) {
 953                 p = n-&gt;in(0)-&gt;as_If()-&gt;_prob;
 954                 if (n-&gt;Opcode() == Op_IfFalse) {
 955                   p = 1 - p;
 956                 }
 957               } else {
 958                 assert(n-&gt;in(0)-&gt;is_Jump(), &quot;unsupported node kind&quot;);
 959                 p = n-&gt;in(0)-&gt;as_Jump()-&gt;_probs[n-&gt;as_JumpProj()-&gt;_con];
 960               }
 961               f = f * p;
 962               check_frequency(f);
 963             }
 964             _freqs.at_put_grow(n-&gt;_idx, (float)f, -1);
 965             _stack.pop();
 966           } else {
 967             float prev_f = _freqs_stack.pop();
 968             float new_f = f;
 969             f = new_f + prev_f;
 970             check_frequency(f);
 971             uint i = _stack.index();
 972             if (i &lt; n-&gt;req()) {
 973               c = n-&gt;in(i);
 974               _stack.set_index(i+1);
 975               _freqs_stack.push(f);
 976             } else {
 977               _freqs.at_put_grow(n-&gt;_idx, f, -1);
 978               _stack.pop();
 979             }
 980           }
 981         }
 982         if (_stack.size() == 0) {
 983           set_rounding(FE_TONEAREST);
 984           check_frequency(f);
 985           return f;
 986         }
 987       } else if (c-&gt;is_Loop()) {
 988         ShouldNotReachHere();
 989         c = c-&gt;in(LoopNode::EntryControl);
 990       } else if (c-&gt;is_Region()) {
 991         _freqs_stack.push(0);
 992         _stack.push(c, 2);
 993         c = c-&gt;in(1);
 994       } else {
 995         if (c-&gt;is_IfProj()) {
 996           IfNode* iff = c-&gt;in(0)-&gt;as_If();
 997           if (iff-&gt;_prob == PROB_UNKNOWN) {
 998             // assume never taken
 999             _freqs.at_put_grow(c-&gt;_idx, 0, -1);
1000           } else if (_phase-&gt;get_loop(c) != _phase-&gt;get_loop(iff)) {
1001             if (iff-&gt;_fcnt == COUNT_UNKNOWN) {
1002               // assume never taken
1003               _freqs.at_put_grow(c-&gt;_idx, 0, -1);
1004             } else {
1005               // skip over loop
1006               _stack.push(c, 1);
1007               c = _phase-&gt;get_loop(c-&gt;in(0))-&gt;_head-&gt;as_Loop()-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
1008             }
1009           } else {
1010             _stack.push(c, 1);
1011             c = iff;
1012           }
1013         } else if (c-&gt;is_JumpProj()) {
1014           JumpNode* jmp = c-&gt;in(0)-&gt;as_Jump();
1015           if (_phase-&gt;get_loop(c) != _phase-&gt;get_loop(jmp)) {
1016             if (jmp-&gt;_fcnt == COUNT_UNKNOWN) {
1017               // assume never taken
1018               _freqs.at_put_grow(c-&gt;_idx, 0, -1);
1019             } else {
1020               // skip over loop
1021               _stack.push(c, 1);
1022               c = _phase-&gt;get_loop(c-&gt;in(0))-&gt;_head-&gt;as_Loop()-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
1023             }
1024           } else {
1025             _stack.push(c, 1);
1026             c = jmp;
1027           }
1028         } else if (c-&gt;Opcode() == Op_CatchProj &amp;&amp;
1029                    c-&gt;in(0)-&gt;Opcode() == Op_Catch &amp;&amp;
1030                    c-&gt;in(0)-&gt;in(0)-&gt;is_Proj() &amp;&amp;
1031                    c-&gt;in(0)-&gt;in(0)-&gt;in(0)-&gt;is_Call()) {
1032           // assume exceptions are never thrown
1033           uint con = c-&gt;as_Proj()-&gt;_con;
1034           if (con == CatchProjNode::fall_through_index) {
1035             Node* call = c-&gt;in(0)-&gt;in(0)-&gt;in(0)-&gt;in(0);
1036             if (_phase-&gt;get_loop(call) != _phase-&gt;get_loop(c)) {
1037               _freqs.at_put_grow(c-&gt;_idx, 0, -1);
1038             } else {
1039               c = call;
1040             }
1041           } else {
1042             assert(con &gt;= CatchProjNode::catch_all_index, &quot;what else?&quot;);
1043             _freqs.at_put_grow(c-&gt;_idx, 0, -1);
1044           }
1045         } else if (c-&gt;unique_ctrl_out() == NULL &amp;&amp; !c-&gt;is_If() &amp;&amp; !c-&gt;is_Jump()) {
1046           ShouldNotReachHere();
1047         } else {
1048           c = c-&gt;in(0);
1049         }
1050       }
1051     }
1052     ShouldNotReachHere();
1053     return -1;
1054   }
1055 };
1056 
1057 void PhaseIdealLoop::loop_predication_follow_branches(Node *n, IdealLoopTree *loop, float loop_trip_cnt,
1058                                                       PathFrequency&amp; pf, Node_Stack&amp; stack, VectorSet&amp; seen,
1059                                                       Node_List&amp; if_proj_list) {
1060   assert(n-&gt;is_Region(), &quot;start from a region&quot;);
1061   Node* tail = loop-&gt;tail();
1062   stack.push(n, 1);
1063   do {
1064     Node* c = stack.node();
1065     assert(c-&gt;is_Region() || c-&gt;is_IfProj(), &quot;only region here&quot;);
1066     uint i = stack.index();
1067 
1068     if (i &lt; c-&gt;req()) {
1069       stack.set_index(i+1);
1070       Node* in = c-&gt;in(i);
1071       while (!is_dominator(in, tail) &amp;&amp; !seen.test_set(in-&gt;_idx)) {
1072         IdealLoopTree* in_loop = get_loop(in);
1073         if (in_loop != loop) {
1074           in = in_loop-&gt;_head-&gt;in(LoopNode::EntryControl);
1075         } else if (in-&gt;is_Region()) {
1076           stack.push(in, 1);
1077           break;
1078         } else if (in-&gt;is_IfProj() &amp;&amp;
1079                    in-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;
1080                    (in-&gt;in(0)-&gt;Opcode() == Op_If ||
1081                     in-&gt;in(0)-&gt;Opcode() == Op_RangeCheck)) {
1082           if (pf.to(in) * loop_trip_cnt &gt;= 1) {
1083             stack.push(in, 1);
1084           }
1085           in = in-&gt;in(0);
1086         } else {
1087           in = in-&gt;in(0);
1088         }
1089       }
1090     } else {
1091       if (c-&gt;is_IfProj()) {
1092         if_proj_list.push(c);
1093       }
1094       stack.pop();
1095     }
1096 
1097   } while (stack.size() &gt; 0);
1098 }
1099 
1100 
1101 bool PhaseIdealLoop::loop_predication_impl_helper(IdealLoopTree *loop, ProjNode* proj, ProjNode *predicate_proj,
1102                                                   CountedLoopNode *cl, ConNode* zero, Invariance&amp; invar,
1103                                                   Deoptimization::DeoptReason reason) {
1104   // Following are changed to nonnull when a predicate can be hoisted
1105   ProjNode* new_predicate_proj = NULL;
1106   IfNode*   iff  = proj-&gt;in(0)-&gt;as_If();
1107   Node*     test = iff-&gt;in(1);
1108   if (!test-&gt;is_Bool()){ //Conv2B, ...
1109     return false;
1110   }
1111   BoolNode* bol = test-&gt;as_Bool();
1112   if (invar.is_invariant(bol)) {
1113     // Invariant test
1114     new_predicate_proj = create_new_if_for_predicate(predicate_proj, NULL,
1115                                                      reason,
1116                                                      iff-&gt;Opcode());
1117     Node* ctrl = new_predicate_proj-&gt;in(0)-&gt;as_If()-&gt;in(0);
1118     BoolNode* new_predicate_bol = invar.clone(bol, ctrl)-&gt;as_Bool();
1119 
1120     // Negate test if necessary
1121     bool negated = false;
1122     if (proj-&gt;_con != predicate_proj-&gt;_con) {
1123       new_predicate_bol = new BoolNode(new_predicate_bol-&gt;in(1), new_predicate_bol-&gt;_test.negate());
1124       register_new_node(new_predicate_bol, ctrl);
1125       negated = true;
1126     }
1127     IfNode* new_predicate_iff = new_predicate_proj-&gt;in(0)-&gt;as_If();
1128     _igvn.hash_delete(new_predicate_iff);
1129     new_predicate_iff-&gt;set_req(1, new_predicate_bol);
1130 #ifndef PRODUCT
1131     if (TraceLoopPredicate) {
1132       tty-&gt;print(&quot;Predicate invariant if%s: %d &quot;, negated ? &quot; negated&quot; : &quot;&quot;, new_predicate_iff-&gt;_idx);
1133       loop-&gt;dump_head();
1134     } else if (TraceLoopOpts) {
1135       tty-&gt;print(&quot;Predicate IC &quot;);
1136       loop-&gt;dump_head();
1137     }
1138 #endif
1139   } else if (cl != NULL &amp;&amp; loop-&gt;is_range_check_if(iff, this, invar)) {
1140     // Range check for counted loops
1141     const Node*    cmp    = bol-&gt;in(1)-&gt;as_Cmp();
1142     Node*          idx    = cmp-&gt;in(1);
1143     assert(!invar.is_invariant(idx), &quot;index is variant&quot;);
1144     Node* rng = cmp-&gt;in(2);
1145     assert(rng-&gt;Opcode() == Op_LoadRange || iff-&gt;is_RangeCheck() || _igvn.type(rng)-&gt;is_int()-&gt;_lo &gt;= 0, &quot;must be&quot;);
1146     assert(invar.is_invariant(rng), &quot;range must be invariant&quot;);
1147     int scale    = 1;
1148     Node* offset = zero;
1149     bool ok = is_scaled_iv_plus_offset(idx, cl-&gt;phi(), &amp;scale, &amp;offset);
1150     assert(ok, &quot;must be index expression&quot;);
1151 
1152     Node* init    = cl-&gt;init_trip();
1153     // Limit is not exact.
1154     // Calculate exact limit here.
1155     // Note, counted loop&#39;s test is &#39;&lt;&#39; or &#39;&gt;&#39;.
1156     Node* limit   = exact_limit(loop);
1157     int  stride   = cl-&gt;stride()-&gt;get_int();
1158 
1159     // Build if&#39;s for the upper and lower bound tests.  The
1160     // lower_bound test will dominate the upper bound test and all
1161     // cloned or created nodes will use the lower bound test as
1162     // their declared control.
1163 
1164     // Perform cloning to keep Invariance state correct since the
1165     // late schedule will place invariant things in the loop.
1166     Node *ctrl = predicate_proj-&gt;in(0)-&gt;as_If()-&gt;in(0);
1167     rng = invar.clone(rng, ctrl);
1168     if (offset &amp;&amp; offset != zero) {
1169       assert(invar.is_invariant(offset), &quot;offset must be loop invariant&quot;);
1170       offset = invar.clone(offset, ctrl);
1171     }
1172     // If predicate expressions may overflow in the integer range, longs are used.
1173     bool overflow = false;
1174 
1175     // Test the lower bound
1176     BoolNode* lower_bound_bol = rc_predicate(loop, ctrl, scale, offset, init, limit, stride, rng, false, overflow);
1177     // Negate test if necessary
1178     bool negated = false;
1179     if (proj-&gt;_con != predicate_proj-&gt;_con) {
1180       lower_bound_bol = new BoolNode(lower_bound_bol-&gt;in(1), lower_bound_bol-&gt;_test.negate());
1181       register_new_node(lower_bound_bol, ctrl);
1182       negated = true;
1183     }
1184     ProjNode* lower_bound_proj = create_new_if_for_predicate(predicate_proj, NULL, reason, overflow ? Op_If : iff-&gt;Opcode());
1185     IfNode* lower_bound_iff = lower_bound_proj-&gt;in(0)-&gt;as_If();
1186     _igvn.hash_delete(lower_bound_iff);
1187     lower_bound_iff-&gt;set_req(1, lower_bound_bol);
1188     if (TraceLoopPredicate) tty-&gt;print_cr(&quot;lower bound check if: %s %d &quot;, negated ? &quot; negated&quot; : &quot;&quot;, lower_bound_iff-&gt;_idx);
1189 
1190     // Test the upper bound
1191     BoolNode* upper_bound_bol = rc_predicate(loop, lower_bound_proj, scale, offset, init, limit, stride, rng, true, overflow);
1192     negated = false;
1193     if (proj-&gt;_con != predicate_proj-&gt;_con) {
1194       upper_bound_bol = new BoolNode(upper_bound_bol-&gt;in(1), upper_bound_bol-&gt;_test.negate());
1195       register_new_node(upper_bound_bol, ctrl);
1196       negated = true;
1197     }
1198     ProjNode* upper_bound_proj = create_new_if_for_predicate(predicate_proj, NULL, reason, overflow ? Op_If : iff-&gt;Opcode());
1199     assert(upper_bound_proj-&gt;in(0)-&gt;as_If()-&gt;in(0) == lower_bound_proj, &quot;should dominate&quot;);
1200     IfNode* upper_bound_iff = upper_bound_proj-&gt;in(0)-&gt;as_If();
1201     _igvn.hash_delete(upper_bound_iff);
1202     upper_bound_iff-&gt;set_req(1, upper_bound_bol);
1203     if (TraceLoopPredicate) tty-&gt;print_cr(&quot;upper bound check if: %s %d &quot;, negated ? &quot; negated&quot; : &quot;&quot;, lower_bound_iff-&gt;_idx);
1204 
1205     // Fall through into rest of the clean up code which will move
1206     // any dependent nodes onto the upper bound test.
1207     new_predicate_proj = upper_bound_proj;
1208 
1209     if (iff-&gt;is_RangeCheck()) {
1210       new_predicate_proj = insert_skeleton_predicate(iff, loop, proj, predicate_proj, upper_bound_proj, scale, offset, init, limit, stride, rng, overflow, reason);
1211     }
1212 
1213 #ifndef PRODUCT
1214     if (TraceLoopOpts &amp;&amp; !TraceLoopPredicate) {
1215       tty-&gt;print(&quot;Predicate RC &quot;);
1216       loop-&gt;dump_head();
1217     }
1218 #endif
1219   } else {
1220     // Loop variant check (for example, range check in non-counted loop)
1221     // with uncommon trap.
1222     return false;
1223   }
1224   assert(new_predicate_proj != NULL, &quot;sanity&quot;);
1225   // Success - attach condition (new_predicate_bol) to predicate if
1226   invar.map_ctrl(proj, new_predicate_proj); // so that invariance test can be appropriate
1227 
1228   // Eliminate the old If in the loop body
1229   dominated_by( new_predicate_proj, iff, proj-&gt;_con != new_predicate_proj-&gt;_con );
1230 
1231   C-&gt;set_major_progress();
1232   return true;
1233 }
1234 
1235 
1236 // After pre/main/post loops are created, we&#39;ll put a copy of some
1237 // range checks between the pre and main loop to validate the value
1238 // of the main loop induction variable. Make a copy of the predicates
1239 // here with an opaque node as a place holder for the value (will be
1240 // updated by PhaseIdealLoop::clone_skeleton_predicate()).
1241 ProjNode* PhaseIdealLoop::insert_skeleton_predicate(IfNode* iff, IdealLoopTree *loop,
1242                                                     ProjNode* proj, ProjNode *predicate_proj,
1243                                                     ProjNode* upper_bound_proj,
1244                                                     int scale, Node* offset,
1245                                                     Node* init, Node* limit, jint stride,
1246                                                     Node* rng, bool &amp;overflow,
1247                                                     Deoptimization::DeoptReason reason) {
1248   assert(proj-&gt;_con &amp;&amp; predicate_proj-&gt;_con, &quot;not a range check?&quot;);
1249   Node* opaque_init = new Opaque1Node(C, init);
1250   register_new_node(opaque_init, upper_bound_proj);
1251   BoolNode* bol = rc_predicate(loop, upper_bound_proj, scale, offset, opaque_init, limit, stride, rng, (stride &gt; 0) != (scale &gt; 0), overflow);
1252   Node* opaque_bol = new Opaque4Node(C, bol, _igvn.intcon(1)); // This will go away once loop opts are over
1253   register_new_node(opaque_bol, upper_bound_proj);
1254   ProjNode* new_proj = create_new_if_for_predicate(predicate_proj, NULL, reason, overflow ? Op_If : iff-&gt;Opcode());
1255   _igvn.replace_input_of(new_proj-&gt;in(0), 1, opaque_bol);
1256   assert(opaque_init-&gt;outcnt() &gt; 0, &quot;should be used&quot;);
1257   return new_proj;
1258 }
1259 
1260 //------------------------------ loop_predication_impl--------------------------
1261 // Insert loop predicates for null checks and range checks
1262 bool PhaseIdealLoop::loop_predication_impl(IdealLoopTree *loop) {
1263   if (!UseLoopPredicate) return false;
1264 
1265   if (!loop-&gt;_head-&gt;is_Loop()) {
1266     // Could be a simple region when irreducible loops are present.
1267     return false;
1268   }
1269   LoopNode* head = loop-&gt;_head-&gt;as_Loop();
1270 
1271   if (head-&gt;unique_ctrl_out()-&gt;Opcode() == Op_NeverBranch) {
1272     // do nothing for infinite loops
1273     return false;
1274   }
1275 
1276   if (head-&gt;is_OuterStripMinedLoop()) {
1277     return false;
1278   }
1279 
1280   CountedLoopNode *cl = NULL;
1281   if (head-&gt;is_valid_counted_loop()) {
1282     cl = head-&gt;as_CountedLoop();
1283     // do nothing for iteration-splitted loops
1284     if (!cl-&gt;is_normal_loop()) return false;
1285     // Avoid RCE if Counted loop&#39;s test is &#39;!=&#39;.
1286     BoolTest::mask bt = cl-&gt;loopexit()-&gt;test_trip();
1287     if (bt != BoolTest::lt &amp;&amp; bt != BoolTest::gt)
1288       cl = NULL;
1289   }
1290 
1291   Node* entry = head-&gt;skip_strip_mined()-&gt;in(LoopNode::EntryControl);
1292   ProjNode *loop_limit_proj = NULL;
1293   ProjNode *predicate_proj = NULL;
1294   ProjNode *profile_predicate_proj = NULL;
1295   // Loop limit check predicate should be near the loop.
1296   loop_limit_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
1297   if (loop_limit_proj != NULL) {
1298     entry = skip_loop_predicates(loop_limit_proj);
1299   }
1300   bool has_profile_predicates = false;
1301   profile_predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);
1302   if (profile_predicate_proj != NULL) {
1303     Node* n = skip_loop_predicates(entry);
1304     // Check if predicates were already added to the profile predicate
1305     // block
1306     if (n != entry-&gt;in(0)-&gt;in(0) || n-&gt;outcnt() != 1) {
1307       has_profile_predicates = true;
1308     }
1309     entry = n;
1310   }
1311   predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);
1312 
1313   float loop_trip_cnt = -1;
1314   bool follow_branches = loop_predication_should_follow_branches(loop, profile_predicate_proj, loop_trip_cnt);
1315   assert(!follow_branches || loop_trip_cnt &gt;= 0, &quot;negative trip count?&quot;);
1316 
1317   if (predicate_proj == NULL &amp;&amp; !follow_branches) {
1318 #ifndef PRODUCT
1319     if (TraceLoopPredicate) {
1320       tty-&gt;print(&quot;missing predicate:&quot;);
1321       loop-&gt;dump_head();
1322       head-&gt;dump(1);
1323     }
1324 #endif
1325     return false;
1326   }
1327   ConNode* zero = _igvn.intcon(0);
1328   set_ctrl(zero, C-&gt;root());
1329 
1330   ResourceArea *area = Thread::current()-&gt;resource_area();
1331   Invariance invar(area, loop);
1332 
1333   // Create list of if-projs such that a newer proj dominates all older
1334   // projs in the list, and they all dominate loop-&gt;tail()
1335   Node_List if_proj_list(area);
1336   Node_List regions(area);
1337   Node *current_proj = loop-&gt;tail(); //start from tail
1338 
1339 
1340   Node_List controls(area);
1341   while (current_proj != head) {
1342     if (loop == get_loop(current_proj) &amp;&amp; // still in the loop ?
1343         current_proj-&gt;is_Proj()        &amp;&amp; // is a projection  ?
1344         (current_proj-&gt;in(0)-&gt;Opcode() == Op_If ||
1345          current_proj-&gt;in(0)-&gt;Opcode() == Op_RangeCheck)) { // is a if projection ?
1346       if_proj_list.push(current_proj);
1347     }
1348     if (follow_branches &amp;&amp;
1349         current_proj-&gt;Opcode() == Op_Region &amp;&amp;
1350         loop == get_loop(current_proj)) {
1351       regions.push(current_proj);
1352     }
1353     current_proj = idom(current_proj);
1354   }
1355 
1356   bool hoisted = false; // true if at least one proj is promoted
1357 
1358   if (!has_profile_predicates) {
1359     while (if_proj_list.size() &gt; 0) {
1360       Node* n = if_proj_list.pop();
1361 
1362       ProjNode* proj = n-&gt;as_Proj();
1363       IfNode*   iff  = proj-&gt;in(0)-&gt;as_If();
1364 
1365       CallStaticJavaNode* call = proj-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);
1366       if (call == NULL) {
1367         if (loop-&gt;is_loop_exit(iff)) {
1368           // stop processing the remaining projs in the list because the execution of them
1369           // depends on the condition of &quot;iff&quot; (iff-&gt;in(1)).
1370           break;
1371         } else {
1372           // Both arms are inside the loop. There are two cases:
1373           // (1) there is one backward branch. In this case, any remaining proj
1374           //     in the if_proj list post-dominates &quot;iff&quot;. So, the condition of &quot;iff&quot;
1375           //     does not determine the execution the remining projs directly, and we
1376           //     can safely continue.
1377           // (2) both arms are forwarded, i.e. a diamond shape. In this case, &quot;proj&quot;
1378           //     does not dominate loop-&gt;tail(), so it can not be in the if_proj list.
1379           continue;
1380         }
1381       }
1382       Deoptimization::DeoptReason reason = Deoptimization::trap_request_reason(call-&gt;uncommon_trap_request());
1383       if (reason == Deoptimization::Reason_predicate) {
1384         break;
1385       }
1386 
1387       if (predicate_proj != NULL) {
1388         hoisted = loop_predication_impl_helper(loop, proj, predicate_proj, cl, zero, invar, Deoptimization::Reason_predicate) | hoisted;
1389       }
1390     } // end while
1391   }
1392 
1393   if (follow_branches) {
1394     PathFrequency pf(loop-&gt;_head, this);
1395 
1396     // Some projections were skipped by regular predicates because of
1397     // an early loop exit. Try them with profile data.
1398     while (if_proj_list.size() &gt; 0) {
1399       Node* proj = if_proj_list.pop();
1400       float f = pf.to(proj);
1401       if (proj-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;
1402           f * loop_trip_cnt &gt;= 1) {
1403         hoisted = loop_predication_impl_helper(loop, proj-&gt;as_Proj(), profile_predicate_proj, cl, zero, invar, Deoptimization::Reason_profile_predicate) | hoisted;
1404       }
1405     }
1406 
1407     // And look into all branches
1408     Node_Stack stack(0);
1409     VectorSet seen(Thread::current()-&gt;resource_area());
1410     Node_List if_proj_list_freq(area);
1411     while (regions.size() &gt; 0) {
1412       Node* c = regions.pop();
1413       loop_predication_follow_branches(c, loop, loop_trip_cnt, pf, stack, seen, if_proj_list_freq);
1414     }
1415 
1416     for (uint i = 0; i &lt; if_proj_list_freq.size(); i++) {
1417       ProjNode* proj = if_proj_list_freq.at(i)-&gt;as_Proj();
1418       hoisted = loop_predication_impl_helper(loop, proj, profile_predicate_proj, cl, zero, invar, Deoptimization::Reason_profile_predicate) | hoisted;
1419     }
1420   }
1421 
1422 #ifndef PRODUCT
1423   // report that the loop predication has been actually performed
1424   // for this loop
1425   if (TraceLoopPredicate &amp;&amp; hoisted) {
1426     tty-&gt;print(&quot;Loop Predication Performed:&quot;);
1427     loop-&gt;dump_head();
1428   }
1429 #endif
1430 
1431   head-&gt;verify_strip_mined(1);
1432 
1433   return hoisted;
1434 }
1435 
1436 //------------------------------loop_predication--------------------------------
1437 // driver routine for loop predication optimization
1438 bool IdealLoopTree::loop_predication( PhaseIdealLoop *phase) {
1439   bool hoisted = false;
1440   // Recursively promote predicates
1441   if (_child) {
1442     hoisted = _child-&gt;loop_predication( phase);
1443   }
1444 
1445   // self
1446   if (!_irreducible &amp;&amp; !tail()-&gt;is_top()) {
1447     hoisted |= phase-&gt;loop_predication_impl(this);
1448   }
1449 
1450   if (_next) { //sibling
1451     hoisted |= _next-&gt;loop_predication( phase);
1452   }
1453 
1454   return hoisted;
1455 }
    </pre>
  </body>
</html>
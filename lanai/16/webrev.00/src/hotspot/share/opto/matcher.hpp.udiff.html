<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/opto/matcher.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="matcher.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="memnode.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/matcher.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -123,10 +123,12 @@</span>
  
  #ifdef X86
    bool is_bmi_pattern(Node *n, Node *m);
  #endif
  
<span class="udiff-line-added">+   bool is_vshift_con_pattern(Node *n, Node *m);</span>
<span class="udiff-line-added">+ </span>
    // Debug and profile information for nodes in old space:
    GrowableArray&lt;Node_Notes*&gt;* _old_node_note_array;
  
    // Node labeling iterator for instruction selection
    Node *Label_Root( const Node *n, State *svec, Node *control, const Node *mem );
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -515,11 +517,11 @@</span>
  
    void specialize_generic_vector_operands();
    void specialize_mach_node(MachNode* m);
    void specialize_temp_node(MachTempNode* tmp, MachNode* use, uint idx);
    MachOper* specialize_vector_operand(MachNode* m, uint opnd_idx);
<span class="udiff-line-modified-removed">-   MachOper* specialize_vector_operand_helper(MachNode* m, uint opnd_idx, const Type* t);</span>
<span class="udiff-line-modified-added">+   MachOper* specialize_vector_operand_helper(MachNode* m, uint opnd_idx, const TypeVect* vt);</span>
  
    static MachOper* specialize_generic_vector_operand(MachOper* generic_opnd, uint ideal_reg, bool is_temp);
  
    static bool is_generic_reg2reg_move(MachNode* m);
    static bool is_generic_vector(MachOper* opnd);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -532,12 +534,11 @@</span>
   public:
    // Perform a platform dependent implicit null fixup.  This is needed
    // on windows95 to take care of some unusual register constraints.
    void pd_implicit_null_fixup(MachNode *load, uint idx);
  
<span class="udiff-line-modified-removed">-   // Advertise here if the CPU requires explicit rounding operations</span>
<span class="udiff-line-removed">-   // to implement the UseStrictFP mode.</span>
<span class="udiff-line-modified-added">+   // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.</span>
    static const bool strict_fp_requires_explicit_rounding;
  
    // Are floats conerted to double when stored to stack during deoptimization?
    static bool float_in_double();
    // Do ints take an entire long register or just half?
</pre>
<center><a href="matcher.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="memnode.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/compile.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OPTO_COMPILE_HPP
  26 #define SHARE_OPTO_COMPILE_HPP
  27 
  28 #include &quot;asm/codeBuffer.hpp&quot;
  29 #include &quot;ci/compilerInterface.hpp&quot;
  30 #include &quot;code/debugInfoRec.hpp&quot;
<a name="1" id="anc1"></a><span class="line-removed">  31 #include &quot;code/exceptionHandlerTable.hpp&quot;</span>
  32 #include &quot;compiler/compilerOracle.hpp&quot;
  33 #include &quot;compiler/compileBroker.hpp&quot;
  34 #include &quot;libadt/dict.hpp&quot;
  35 #include &quot;libadt/vectset.hpp&quot;
  36 #include &quot;jfr/jfrEvents.hpp&quot;
  37 #include &quot;memory/resourceArea.hpp&quot;
  38 #include &quot;oops/methodData.hpp&quot;
  39 #include &quot;opto/idealGraphPrinter.hpp&quot;
  40 #include &quot;opto/phasetype.hpp&quot;
  41 #include &quot;opto/phase.hpp&quot;
  42 #include &quot;opto/regmask.hpp&quot;
  43 #include &quot;runtime/deoptimization.hpp&quot;
  44 #include &quot;runtime/timerTrace.hpp&quot;
  45 #include &quot;runtime/vmThread.hpp&quot;
  46 #include &quot;utilities/ticks.hpp&quot;
  47 
  48 class AddPNode;
  49 class Block;
  50 class Bundle;
<a name="2" id="anc2"></a><span class="line-removed">  51 class C2Compiler;</span>
  52 class CallGenerator;
  53 class CloneMap;
  54 class ConnectionGraph;
  55 class IdealGraphPrinter;
  56 class InlineTree;
  57 class Int_Array;
  58 class Matcher;
  59 class MachConstantNode;
  60 class MachConstantBaseNode;
  61 class MachNode;
  62 class MachOper;
  63 class MachSafePointNode;
  64 class Node;
  65 class Node_Array;
  66 class Node_Notes;
  67 class NodeCloneInfo;
  68 class OptoReg;
  69 class PhaseCFG;
  70 class PhaseGVN;
  71 class PhaseIterGVN;
  72 class PhaseRegAlloc;
  73 class PhaseCCP;
  74 class PhaseCCP_DCE;
<a name="3" id="anc3"></a>
  75 class RootNode;
  76 class relocInfo;
  77 class Scope;
  78 class StartNode;
  79 class SafePointNode;
  80 class JVMState;
  81 class Type;
  82 class TypeData;
  83 class TypeInt;
  84 class TypePtr;
  85 class TypeOopPtr;
  86 class TypeFunc;
  87 class Unique_Node_List;
  88 class nmethod;
  89 class WarmCallInfo;
  90 class Node_Stack;
  91 struct Final_Reshape_Counts;
  92 
  93 enum LoopOptsMode {
  94   LoopOptsDefault,
  95   LoopOptsNone,
  96   LoopOptsMaxUnroll,
  97   LoopOptsShenandoahExpand,
  98   LoopOptsShenandoahPostExpand,
  99   LoopOptsSkipSplitIf,
 100   LoopOptsVerify
 101 };
 102 
 103 typedef unsigned int node_idx_t;
 104 class NodeCloneInfo {
 105  private:
 106   uint64_t _idx_clone_orig;
 107  public:
 108 
 109   void set_idx(node_idx_t idx) {
 110     _idx_clone_orig = (_idx_clone_orig &amp; CONST64(0xFFFFFFFF00000000)) | idx;
 111   }
 112   node_idx_t idx() const { return (node_idx_t)(_idx_clone_orig &amp; 0xFFFFFFFF); }
 113 
 114   void set_gen(int generation) {
 115     uint64_t g = (uint64_t)generation &lt;&lt; 32;
 116     _idx_clone_orig = (_idx_clone_orig &amp; 0xFFFFFFFF) | g;
 117   }
 118   int gen() const { return (int)(_idx_clone_orig &gt;&gt; 32); }
 119 
 120   void set(uint64_t x) { _idx_clone_orig = x; }
 121   void set(node_idx_t x, int g) { set_idx(x); set_gen(g); }
 122   uint64_t get() const { return _idx_clone_orig; }
 123 
 124   NodeCloneInfo(uint64_t idx_clone_orig) : _idx_clone_orig(idx_clone_orig) {}
 125   NodeCloneInfo(node_idx_t x, int g) : _idx_clone_orig(0) { set(x, g); }
 126 
 127   void dump() const;
 128 };
 129 
 130 class CloneMap {
 131   friend class Compile;
 132  private:
 133   bool      _debug;
 134   Dict*     _dict;
 135   int       _clone_idx;   // current cloning iteration/generation in loop unroll
 136  public:
 137   void*     _2p(node_idx_t key)   const          { return (void*)(intptr_t)key; } // 2 conversion functions to make gcc happy
 138   node_idx_t _2_node_idx_t(const void* k) const  { return (node_idx_t)(intptr_t)k; }
 139   Dict*     dict()                const          { return _dict; }
 140   void insert(node_idx_t key, uint64_t val)      { assert(_dict-&gt;operator[](_2p(key)) == NULL, &quot;key existed&quot;); _dict-&gt;Insert(_2p(key), (void*)val); }
 141   void insert(node_idx_t key, NodeCloneInfo&amp; ci) { insert(key, ci.get()); }
 142   void remove(node_idx_t key)                    { _dict-&gt;Delete(_2p(key)); }
 143   uint64_t value(node_idx_t key)  const          { return (uint64_t)_dict-&gt;operator[](_2p(key)); }
 144   node_idx_t idx(node_idx_t key)  const          { return NodeCloneInfo(value(key)).idx(); }
 145   int gen(node_idx_t key)         const          { return NodeCloneInfo(value(key)).gen(); }
 146   int gen(const void* k)          const          { return gen(_2_node_idx_t(k)); }
 147   int max_gen()                   const;
 148   void clone(Node* old, Node* nnn, int gen);
 149   void verify_insert_and_clone(Node* old, Node* nnn, int gen);
 150   void dump(node_idx_t key)       const;
 151 
 152   int  clone_idx() const                         { return _clone_idx; }
 153   void set_clone_idx(int x)                      { _clone_idx = x; }
 154   bool is_debug()                 const          { return _debug; }
 155   void set_debug(bool debug)                     { _debug = debug; }
 156   static const char* debug_option_name;
 157 
 158   bool same_idx(node_idx_t k1, node_idx_t k2)  const { return idx(k1) == idx(k2); }
 159   bool same_gen(node_idx_t k1, node_idx_t k2)  const { return gen(k1) == gen(k2); }
 160 };
 161 
 162 //------------------------------Compile----------------------------------------
 163 // This class defines a top-level Compiler invocation.
 164 
 165 class Compile : public Phase {
 166   friend class VMStructs;
 167 
 168  public:
 169   // Fixed alias indexes.  (See also MergeMemNode.)
 170   enum {
 171     AliasIdxTop = 1,  // pseudo-index, aliases to nothing (used as sentinel value)
 172     AliasIdxBot = 2,  // pseudo-index, aliases to everything
 173     AliasIdxRaw = 3   // hard-wired index for TypeRawPtr::BOTTOM
 174   };
 175 
 176   // Variant of TraceTime(NULL, &amp;_t_accumulator, CITime);
 177   // Integrated with logging.  If logging is turned on, and CITimeVerbose is true,
 178   // then brackets are put into the log, with time stamps and node counts.
 179   // (The time collection itself is always conditionalized on CITime.)
 180   class TracePhase : public TraceTime {
 181    private:
 182     Compile*    C;
 183     CompileLog* _log;
 184     const char* _phase_name;
 185     bool _dolog;
 186    public:
 187     TracePhase(const char* name, elapsedTimer* accumulator);
 188     ~TracePhase();
 189   };
 190 
 191   // Information per category of alias (memory slice)
 192   class AliasType {
 193    private:
 194     friend class Compile;
 195 
 196     int             _index;         // unique index, used with MergeMemNode
 197     const TypePtr*  _adr_type;      // normalized address type
 198     ciField*        _field;         // relevant instance field, or null if none
 199     const Type*     _element;       // relevant array element type, or null if none
 200     bool            _is_rewritable; // false if the memory is write-once only
 201     int             _general_index; // if this is type is an instance, the general
 202                                     // type that this is an instance of
 203 
 204     void Init(int i, const TypePtr* at);
 205 
 206    public:
 207     int             index()         const { return _index; }
 208     const TypePtr*  adr_type()      const { return _adr_type; }
 209     ciField*        field()         const { return _field; }
 210     const Type*     element()       const { return _element; }
 211     bool            is_rewritable() const { return _is_rewritable; }
 212     bool            is_volatile()   const { return (_field ? _field-&gt;is_volatile() : false); }
 213     int             general_index() const { return (_general_index != 0) ? _general_index : _index; }
 214 
 215     void set_rewritable(bool z) { _is_rewritable = z; }
 216     void set_field(ciField* f) {
 217       assert(!_field,&quot;&quot;);
 218       _field = f;
 219       if (f-&gt;is_final() || f-&gt;is_stable()) {
 220         // In the case of @Stable, multiple writes are possible but may be assumed to be no-ops.
 221         _is_rewritable = false;
 222       }
 223     }
 224     void set_element(const Type* e) {
 225       assert(_element == NULL, &quot;&quot;);
 226       _element = e;
 227     }
 228 
 229     BasicType basic_type() const;
 230 
 231     void print_on(outputStream* st) PRODUCT_RETURN;
 232   };
 233 
 234   enum {
 235     logAliasCacheSize = 6,
 236     AliasCacheSize = (1&lt;&lt;logAliasCacheSize)
 237   };
 238   struct AliasCacheEntry { const TypePtr* _adr_type; int _index; };  // simple duple type
 239   enum {
 240     trapHistLength = MethodData::_trap_hist_limit
 241   };
 242 
<a name="4" id="anc4"></a><span class="line-removed"> 243   // Constant entry of the constant table.</span>
<span class="line-removed"> 244   class Constant {</span>
<span class="line-removed"> 245   private:</span>
<span class="line-removed"> 246     BasicType _type;</span>
<span class="line-removed"> 247     union {</span>
<span class="line-removed"> 248       jvalue    _value;</span>
<span class="line-removed"> 249       Metadata* _metadata;</span>
<span class="line-removed"> 250     } _v;</span>
<span class="line-removed"> 251     int       _offset;         // offset of this constant (in bytes) relative to the constant table base.</span>
<span class="line-removed"> 252     float     _freq;</span>
<span class="line-removed"> 253     bool      _can_be_reused;  // true (default) if the value can be shared with other users.</span>
<span class="line-removed"> 254 </span>
<span class="line-removed"> 255   public:</span>
<span class="line-removed"> 256     Constant() : _type(T_ILLEGAL), _offset(-1), _freq(0.0f), _can_be_reused(true) { _v._value.l = 0; }</span>
<span class="line-removed"> 257     Constant(BasicType type, jvalue value, float freq = 0.0f, bool can_be_reused = true) :</span>
<span class="line-removed"> 258       _type(type),</span>
<span class="line-removed"> 259       _offset(-1),</span>
<span class="line-removed"> 260       _freq(freq),</span>
<span class="line-removed"> 261       _can_be_reused(can_be_reused)</span>
<span class="line-removed"> 262     {</span>
<span class="line-removed"> 263       assert(type != T_METADATA, &quot;wrong constructor&quot;);</span>
<span class="line-removed"> 264       _v._value = value;</span>
<span class="line-removed"> 265     }</span>
<span class="line-removed"> 266     Constant(Metadata* metadata, bool can_be_reused = true) :</span>
<span class="line-removed"> 267       _type(T_METADATA),</span>
<span class="line-removed"> 268       _offset(-1),</span>
<span class="line-removed"> 269       _freq(0.0f),</span>
<span class="line-removed"> 270       _can_be_reused(can_be_reused)</span>
<span class="line-removed"> 271     {</span>
<span class="line-removed"> 272       _v._metadata = metadata;</span>
<span class="line-removed"> 273     }</span>
<span class="line-removed"> 274 </span>
<span class="line-removed"> 275     bool operator==(const Constant&amp; other);</span>
<span class="line-removed"> 276 </span>
<span class="line-removed"> 277     BasicType type()      const    { return _type; }</span>
<span class="line-removed"> 278 </span>
<span class="line-removed"> 279     jint    get_jint()    const    { return _v._value.i; }</span>
<span class="line-removed"> 280     jlong   get_jlong()   const    { return _v._value.j; }</span>
<span class="line-removed"> 281     jfloat  get_jfloat()  const    { return _v._value.f; }</span>
<span class="line-removed"> 282     jdouble get_jdouble() const    { return _v._value.d; }</span>
<span class="line-removed"> 283     jobject get_jobject() const    { return _v._value.l; }</span>
<span class="line-removed"> 284 </span>
<span class="line-removed"> 285     Metadata* get_metadata() const { return _v._metadata; }</span>
<span class="line-removed"> 286 </span>
<span class="line-removed"> 287     int         offset()  const    { return _offset; }</span>
<span class="line-removed"> 288     void    set_offset(int offset) {        _offset = offset; }</span>
<span class="line-removed"> 289 </span>
<span class="line-removed"> 290     float       freq()    const    { return _freq;         }</span>
<span class="line-removed"> 291     void    inc_freq(float freq)   {        _freq += freq; }</span>
<span class="line-removed"> 292 </span>
<span class="line-removed"> 293     bool    can_be_reused() const  { return _can_be_reused; }</span>
<span class="line-removed"> 294   };</span>
<span class="line-removed"> 295 </span>
<span class="line-removed"> 296   // Constant table.</span>
<span class="line-removed"> 297   class ConstantTable {</span>
<span class="line-removed"> 298   private:</span>
<span class="line-removed"> 299     GrowableArray&lt;Constant&gt; _constants;          // Constants of this table.</span>
<span class="line-removed"> 300     int                     _size;               // Size in bytes the emitted constant table takes (including padding).</span>
<span class="line-removed"> 301     int                     _table_base_offset;  // Offset of the table base that gets added to the constant offsets.</span>
<span class="line-removed"> 302     int                     _nof_jump_tables;    // Number of jump-tables in this constant table.</span>
<span class="line-removed"> 303 </span>
<span class="line-removed"> 304     static int qsort_comparator(Constant* a, Constant* b);</span>
<span class="line-removed"> 305 </span>
<span class="line-removed"> 306     // We use negative frequencies to keep the order of the</span>
<span class="line-removed"> 307     // jump-tables in which they were added.  Otherwise we get into</span>
<span class="line-removed"> 308     // trouble with relocation.</span>
<span class="line-removed"> 309     float next_jump_table_freq() { return -1.0f * (++_nof_jump_tables); }</span>
<span class="line-removed"> 310 </span>
<span class="line-removed"> 311   public:</span>
<span class="line-removed"> 312     ConstantTable() :</span>
<span class="line-removed"> 313       _size(-1),</span>
<span class="line-removed"> 314       _table_base_offset(-1),  // We can use -1 here since the constant table is always bigger than 2 bytes (-(size / 2), see MachConstantBaseNode::emit).</span>
<span class="line-removed"> 315       _nof_jump_tables(0)</span>
<span class="line-removed"> 316     {}</span>
<span class="line-removed"> 317 </span>
<span class="line-removed"> 318     int size() const { assert(_size != -1, &quot;not calculated yet&quot;); return _size; }</span>
<span class="line-removed"> 319 </span>
<span class="line-removed"> 320     int calculate_table_base_offset() const;  // AD specific</span>
<span class="line-removed"> 321     void set_table_base_offset(int x)  { assert(_table_base_offset == -1 || x == _table_base_offset, &quot;can&#39;t change&quot;); _table_base_offset = x; }</span>
<span class="line-removed"> 322     int      table_base_offset() const { assert(_table_base_offset != -1, &quot;not set yet&quot;);                      return _table_base_offset; }</span>
<span class="line-removed"> 323 </span>
<span class="line-removed"> 324     void emit(CodeBuffer&amp; cb);</span>
<span class="line-removed"> 325 </span>
<span class="line-removed"> 326     // Returns the offset of the last entry (the top) of the constant table.</span>
<span class="line-removed"> 327     int  top_offset() const { assert(_constants.top().offset() != -1, &quot;not bound yet&quot;); return _constants.top().offset(); }</span>
<span class="line-removed"> 328 </span>
<span class="line-removed"> 329     void calculate_offsets_and_size();</span>
<span class="line-removed"> 330     int  find_offset(Constant&amp; con) const;</span>
<span class="line-removed"> 331 </span>
<span class="line-removed"> 332     void     add(Constant&amp; con);</span>
<span class="line-removed"> 333     Constant add(MachConstantNode* n, BasicType type, jvalue value);</span>
<span class="line-removed"> 334     Constant add(Metadata* metadata);</span>
<span class="line-removed"> 335     Constant add(MachConstantNode* n, MachOper* oper);</span>
<span class="line-removed"> 336     Constant add(MachConstantNode* n, jint i) {</span>
<span class="line-removed"> 337       jvalue value; value.i = i;</span>
<span class="line-removed"> 338       return add(n, T_INT, value);</span>
<span class="line-removed"> 339     }</span>
<span class="line-removed"> 340     Constant add(MachConstantNode* n, jlong j) {</span>
<span class="line-removed"> 341       jvalue value; value.j = j;</span>
<span class="line-removed"> 342       return add(n, T_LONG, value);</span>
<span class="line-removed"> 343     }</span>
<span class="line-removed"> 344     Constant add(MachConstantNode* n, jfloat f) {</span>
<span class="line-removed"> 345       jvalue value; value.f = f;</span>
<span class="line-removed"> 346       return add(n, T_FLOAT, value);</span>
<span class="line-removed"> 347     }</span>
<span class="line-removed"> 348     Constant add(MachConstantNode* n, jdouble d) {</span>
<span class="line-removed"> 349       jvalue value; value.d = d;</span>
<span class="line-removed"> 350       return add(n, T_DOUBLE, value);</span>
<span class="line-removed"> 351     }</span>
<span class="line-removed"> 352 </span>
<span class="line-removed"> 353     // Jump-table</span>
<span class="line-removed"> 354     Constant  add_jump_table(MachConstantNode* n);</span>
<span class="line-removed"> 355     void     fill_jump_table(CodeBuffer&amp; cb, MachConstantNode* n, GrowableArray&lt;Label*&gt; labels) const;</span>
<span class="line-removed"> 356   };</span>
<span class="line-removed"> 357 </span>
 358  private:
 359   // Fixed parameters to this compilation.
 360   const int             _compile_id;
 361   const bool            _save_argument_registers; // save/restore arg regs for trampolines
 362   const bool            _subsume_loads;         // Load can be matched as part of a larger op.
 363   const bool            _do_escape_analysis;    // Do escape analysis.
 364   const bool            _eliminate_boxing;      // Do boxing elimination.
 365   ciMethod*             _method;                // The method being compiled.
 366   int                   _entry_bci;             // entry bci for osr methods.
 367   const TypeFunc*       _tf;                    // My kind of signature
 368   InlineTree*           _ilt;                   // Ditto (temporary).
 369   address               _stub_function;         // VM entry for stub being compiled, or NULL
 370   const char*           _stub_name;             // Name of stub or adapter being compiled, or NULL
 371   address               _stub_entry_point;      // Compile code entry for generated stub, or NULL
 372 
 373   // Control of this compilation.
 374   int                   _max_inline_size;       // Max inline size for this compilation
 375   int                   _freq_inline_size;      // Max hot method inline size for this compilation
 376   int                   _fixed_slots;           // count of frame slots not allocated by the register
 377                                                 // allocator i.e. locks, original deopt pc, etc.
 378   uintx                 _max_node_limit;        // Max unique node count during a single compilation.
<a name="5" id="anc5"></a><span class="line-removed"> 379   // For deopt</span>
<span class="line-removed"> 380   int                   _orig_pc_slot;</span>
<span class="line-removed"> 381   int                   _orig_pc_slot_offset_in_bytes;</span>
 382 
 383   int                   _major_progress;        // Count of something big happening
 384   bool                  _inlining_progress;     // progress doing incremental inlining?
 385   bool                  _inlining_incrementally;// Are we doing incremental inlining (post parse)
 386   bool                  _do_cleanup;            // Cleanup is needed before proceeding with incremental inlining
 387   bool                  _has_loops;             // True if the method _may_ have some loops
 388   bool                  _has_split_ifs;         // True if the method _may_ have some split-if
 389   bool                  _has_unsafe_access;     // True if the method _may_ produce faults in unsafe loads or stores.
 390   bool                  _has_stringbuilder;     // True StringBuffers or StringBuilders are allocated
 391   bool                  _has_boxed_value;       // True if a boxed object is allocated
 392   bool                  _has_reserved_stack_access; // True if the method or an inlined method is annotated with ReservedStackAccess
 393   uint                  _max_vector_size;       // Maximum size of generated vectors
 394   bool                  _clear_upper_avx;       // Clear upper bits of ymm registers using vzeroupper
 395   uint                  _trap_hist[trapHistLength];  // Cumulative traps
 396   bool                  _trap_can_recompile;    // Have we emitted a recompiling trap?
 397   uint                  _decompile_count;       // Cumulative decompilation counts.
 398   bool                  _do_inlining;           // True if we intend to do inlining
 399   bool                  _do_scheduling;         // True if we intend to do scheduling
 400   bool                  _do_freq_based_layout;  // True if we intend to do frequency based block layout
 401   bool                  _do_count_invocations;  // True if we generate code to count invocations
 402   bool                  _do_method_data_update; // True if we generate code to update MethodData*s
 403   bool                  _do_vector_loop;        // True if allowed to execute loop in parallel iterations
 404   bool                  _use_cmove;             // True if CMove should be used without profitability analysis
 405   bool                  _age_code;              // True if we need to profile code age (decrement the aging counter)
 406   int                   _AliasLevel;            // Locally-adjusted version of AliasLevel flag.
 407   bool                  _print_assembly;        // True if we should dump assembly code for this compilation
 408   bool                  _print_inlining;        // True if we should print inlining for this compilation
 409   bool                  _print_intrinsics;      // True if we should print intrinsics for this compilation
 410 #ifndef PRODUCT
 411   bool                  _trace_opto_output;
 412   bool                  _print_ideal;
 413   bool                  _parsed_irreducible_loop; // True if ciTypeFlow detected irreducible loops during parsing
 414 #endif
 415   bool                  _has_irreducible_loop;  // Found irreducible loops
 416   // JSR 292
 417   bool                  _has_method_handle_invokes; // True if this method has MethodHandle invokes.
 418   RTMState              _rtm_state;             // State of Restricted Transactional Memory usage
 419   int                   _loop_opts_cnt;         // loop opts round
 420   bool                  _clinit_barrier_on_entry; // True if clinit barrier is needed on nmethod entry
 421 
 422   // Compilation environment.
 423   Arena                 _comp_arena;            // Arena with lifetime equivalent to Compile
 424   void*                 _barrier_set_state;     // Potential GC barrier state for Compile
 425   ciEnv*                _env;                   // CI interface
 426   DirectiveSet*         _directive;             // Compiler directive
 427   CompileLog*           _log;                   // from CompilerThread
 428   const char*           _failure_reason;        // for record_failure/failing pattern
 429   GrowableArray&lt;CallGenerator*&gt;* _intrinsics;   // List of intrinsics.
 430   GrowableArray&lt;Node*&gt;* _macro_nodes;           // List of nodes which need to be expanded before matching.
 431   GrowableArray&lt;Node*&gt;* _predicate_opaqs;       // List of Opaque1 nodes for the loop predicates.
 432   GrowableArray&lt;Node*&gt;* _expensive_nodes;       // List of nodes that are expensive to compute and that we&#39;d better not let the GVN freely common
 433   GrowableArray&lt;Node*&gt;* _range_check_casts;     // List of CastII nodes with a range check dependency
 434   GrowableArray&lt;Node*&gt;* _opaque4_nodes;         // List of Opaque4 nodes that have a default value
 435   ConnectionGraph*      _congraph;
 436 #ifndef PRODUCT
 437   IdealGraphPrinter*    _printer;
 438 #endif
 439 
 440 
 441   // Node management
 442   uint                  _unique;                // Counter for unique Node indices
 443   VectorSet             _dead_node_list;        // Set of dead nodes
 444   uint                  _dead_node_count;       // Number of dead nodes; VectorSet::Size() is O(N).
 445                                                 // So use this to keep count and make the call O(1).
 446   DEBUG_ONLY( Unique_Node_List* _modified_nodes; )  // List of nodes which inputs were modified
 447 
 448   debug_only(static int _debug_idx;)            // Monotonic counter (not reset), use -XX:BreakAtNode=&lt;idx&gt;
 449   Arena                 _node_arena;            // Arena for new-space Nodes
 450   Arena                 _old_arena;             // Arena for old-space Nodes, lifetime during xform
 451   RootNode*             _root;                  // Unique root of compilation, or NULL after bail-out.
 452   Node*                 _top;                   // Unique top node.  (Reset by various phases.)
 453 
 454   Node*                 _immutable_memory;      // Initial memory state
 455 
 456   Node*                 _recent_alloc_obj;
 457   Node*                 _recent_alloc_ctl;
 458 
 459   // Constant table
<a name="6" id="anc6"></a><span class="line-removed"> 460   ConstantTable         _constant_table;        // The constant table for this compile.</span>
 461   MachConstantBaseNode* _mach_constant_base_node;  // Constant table base node singleton.
 462 
 463 
 464   // Blocked array of debugging and profiling information,
 465   // tracked per node.
 466   enum { _log2_node_notes_block_size = 8,
 467          _node_notes_block_size = (1&lt;&lt;_log2_node_notes_block_size)
 468   };
 469   GrowableArray&lt;Node_Notes*&gt;* _node_note_array;
 470   Node_Notes*           _default_node_notes;  // default notes for new nodes
 471 
 472   // After parsing and every bulk phase we hang onto the Root instruction.
 473   // The RootNode instruction is where the whole program begins.  It produces
 474   // the initial Control and BOTTOM for everybody else.
 475 
 476   // Type management
 477   Arena                 _Compile_types;         // Arena for all types
 478   Arena*                _type_arena;            // Alias for _Compile_types except in Initialize_shared()
 479   Dict*                 _type_dict;             // Intern table
 480   CloneMap              _clone_map;             // used for recording history of cloned nodes
 481   size_t                _type_last_size;        // Last allocation size (see Type::operator new/delete)
 482   ciMethod*             _last_tf_m;             // Cache for
 483   const TypeFunc*       _last_tf;               //  TypeFunc::make
 484   AliasType**           _alias_types;           // List of alias types seen so far.
 485   int                   _num_alias_types;       // Logical length of _alias_types
 486   int                   _max_alias_types;       // Physical length of _alias_types
 487   AliasCacheEntry       _alias_cache[AliasCacheSize]; // Gets aliases w/o data structure walking
 488 
 489   // Parsing, optimization
 490   PhaseGVN*             _initial_gvn;           // Results of parse-time PhaseGVN
 491   Unique_Node_List*     _for_igvn;              // Initial work-list for next round of Iterative GVN
 492   WarmCallInfo*         _warm_calls;            // Sorted work-list for heat-based inlining.
 493 
 494   GrowableArray&lt;CallGenerator*&gt; _late_inlines;        // List of CallGenerators to be revisited after
 495                                                       // main parsing has finished.
 496   GrowableArray&lt;CallGenerator*&gt; _string_late_inlines; // same but for string operations
 497 
 498   GrowableArray&lt;CallGenerator*&gt; _boxing_late_inlines; // same but for boxing operations
 499 
 500   int                           _late_inlines_pos;    // Where in the queue should the next late inlining candidate go (emulate depth first inlining)
 501   uint                          _number_of_mh_late_inlines; // number of method handle late inlining still pending
 502 
 503 
 504   // Inlining may not happen in parse order which would make
 505   // PrintInlining output confusing. Keep track of PrintInlining
 506   // pieces in order.
 507   class PrintInliningBuffer : public ResourceObj {
 508    private:
 509     CallGenerator* _cg;
 510     stringStream* _ss;
 511 
 512    public:
 513     PrintInliningBuffer()
 514       : _cg(NULL) { _ss = new stringStream(); }
 515 
 516     void freeStream() { _ss-&gt;~stringStream(); _ss = NULL; }
 517 
 518     stringStream* ss() const { return _ss; }
 519     CallGenerator* cg() const { return _cg; }
 520     void set_cg(CallGenerator* cg) { _cg = cg; }
 521   };
 522 
 523   stringStream* _print_inlining_stream;
 524   GrowableArray&lt;PrintInliningBuffer&gt;* _print_inlining_list;
 525   int _print_inlining_idx;
 526   char* _print_inlining_output;
 527 
 528   // Only keep nodes in the expensive node list that need to be optimized
 529   void cleanup_expensive_nodes(PhaseIterGVN &amp;igvn);
 530   // Use for sorting expensive nodes to bring similar nodes together
 531   static int cmp_expensive_nodes(Node** n1, Node** n2);
 532   // Expensive nodes list already sorted?
 533   bool expensive_nodes_sorted() const;
 534   // Remove the speculative part of types and clean up the graph
 535   void remove_speculative_types(PhaseIterGVN &amp;igvn);
 536 
 537   void* _replay_inline_data; // Pointer to data loaded from file
 538 
 539   void print_inlining_stream_free();
 540   void print_inlining_init();
 541   void print_inlining_reinit();
 542   void print_inlining_commit();
 543   void print_inlining_push();
 544   PrintInliningBuffer&amp; print_inlining_current();
 545 
 546   void log_late_inline_failure(CallGenerator* cg, const char* msg);
 547 
 548  public:
 549 
 550   void* barrier_set_state() const { return _barrier_set_state; }
 551 
 552   outputStream* print_inlining_stream() const {
 553     assert(print_inlining() || print_intrinsics(), &quot;PrintInlining off?&quot;);
 554     return _print_inlining_stream;
 555   }
 556 
 557   void print_inlining_update(CallGenerator* cg);
 558   void print_inlining_update_delayed(CallGenerator* cg);
 559   void print_inlining_move_to(CallGenerator* cg);
 560   void print_inlining_assert_ready();
 561   void print_inlining_reset();
 562 
 563   void print_inlining(ciMethod* method, int inline_level, int bci, const char* msg = NULL) {
 564     stringStream ss;
 565     CompileTask::print_inlining_inner(&amp;ss, method, inline_level, bci, msg);
 566     print_inlining_stream()-&gt;print(&quot;%s&quot;, ss.as_string());
 567   }
 568 
 569 #ifndef PRODUCT
 570   IdealGraphPrinter* printer() { return _printer; }
 571 #endif
 572 
 573   void log_late_inline(CallGenerator* cg);
 574   void log_inline_id(CallGenerator* cg);
 575   void log_inline_failure(const char* msg);
 576 
 577   void* replay_inline_data() const { return _replay_inline_data; }
 578 
 579   // Dump inlining replay data to the stream.
 580   void dump_inline_data(outputStream* out);
 581 
 582  private:
 583   // Matching, CFG layout, allocation, code generation
 584   PhaseCFG*             _cfg;                   // Results of CFG finding
<a name="7" id="anc7"></a><span class="line-removed"> 585   bool                  _select_24_bit_instr;   // We selected an instruction with a 24-bit result</span>
<span class="line-removed"> 586   bool                  _in_24_bit_fp_mode;     // We are emitting instructions with 24-bit results</span>
 587   int                   _java_calls;            // Number of java calls in the method
 588   int                   _inner_loops;           // Number of inner loops in the method
 589   Matcher*              _matcher;               // Engine to map ideal to machine instructions
 590   PhaseRegAlloc*        _regalloc;              // Results of register allocation.
<a name="8" id="anc8"></a><span class="line-removed"> 591   int                   _frame_slots;           // Size of total frame in stack slots</span>
<span class="line-removed"> 592   CodeOffsets           _code_offsets;          // Offsets into the code for various interesting entries</span>
 593   RegMask               _FIRST_STACK_mask;      // All stack slots usable for spills (depends on frame layout)
 594   Arena*                _indexSet_arena;        // control IndexSet allocation within PhaseChaitin
 595   void*                 _indexSet_free_block_list; // free list of IndexSet bit blocks
 596   int                   _interpreter_frame_size;
 597 
<a name="9" id="anc9"></a><span class="line-modified"> 598   uint                  _node_bundling_limit;</span>
<span class="line-removed"> 599   Bundle*               _node_bundling_base;    // Information for instruction bundling</span>
<span class="line-removed"> 600 </span>
<span class="line-removed"> 601   // Instruction bits passed off to the VM</span>
<span class="line-removed"> 602   int                   _method_size;           // Size of nmethod code segment in bytes</span>
<span class="line-removed"> 603   CodeBuffer            _code_buffer;           // Where the code is assembled</span>
<span class="line-removed"> 604   int                   _first_block_size;      // Size of unvalidated entry point code / OSR poison code</span>
<span class="line-removed"> 605   ExceptionHandlerTable _handler_table;         // Table of native-code exception handlers</span>
<span class="line-removed"> 606   ImplicitExceptionTable _inc_table;            // Table of implicit null checks in native code</span>
<span class="line-removed"> 607   OopMapSet*            _oop_map_set;           // Table of oop maps (one for each safepoint location)</span>
<span class="line-removed"> 608   static int            _CompiledZap_count;     // counter compared against CompileZap[First/Last]</span>
<span class="line-removed"> 609   BufferBlob*           _scratch_buffer_blob;   // For temporary code buffers.</span>
<span class="line-removed"> 610   relocInfo*            _scratch_locs_memory;   // For temporary code buffers.</span>
<span class="line-removed"> 611   int                   _scratch_const_size;    // For temporary code buffers.</span>
<span class="line-removed"> 612   bool                  _in_scratch_emit_size;  // true when in scratch_emit_size.</span>
 613 
 614   void reshape_address(AddPNode* n);
 615 
 616  public:
 617   // Accessors
 618 
 619   // The Compile instance currently active in this (compiler) thread.
 620   static Compile* current() {
 621     return (Compile*) ciEnv::current()-&gt;compiler_data();
 622   }
 623 
<a name="10" id="anc10"></a>




 624   // ID for this compilation.  Useful for setting breakpoints in the debugger.
 625   int               compile_id() const          { return _compile_id; }
 626   DirectiveSet*     directive() const           { return _directive; }
 627 
 628   // Does this compilation allow instructions to subsume loads?  User
 629   // instructions that subsume a load may result in an unschedulable
 630   // instruction sequence.
 631   bool              subsume_loads() const       { return _subsume_loads; }
 632   /** Do escape analysis. */
 633   bool              do_escape_analysis() const  { return _do_escape_analysis; }
 634   /** Do boxing elimination. */
 635   bool              eliminate_boxing() const    { return _eliminate_boxing; }
 636   /** Do aggressive boxing elimination. */
 637   bool              aggressive_unboxing() const { return _eliminate_boxing &amp;&amp; AggressiveUnboxing; }
 638   bool              save_argument_registers() const { return _save_argument_registers; }
 639 
 640 
 641   // Other fixed compilation parameters.
 642   ciMethod*         method() const              { return _method; }
 643   int               entry_bci() const           { return _entry_bci; }
 644   bool              is_osr_compilation() const  { return _entry_bci != InvocationEntryBci; }
 645   bool              is_method_compilation() const { return (_method != NULL &amp;&amp; !_method-&gt;flags().is_native()); }
 646   const TypeFunc*   tf() const                  { assert(_tf!=NULL, &quot;&quot;); return _tf; }
 647   void         init_tf(const TypeFunc* tf)      { assert(_tf==NULL, &quot;&quot;); _tf = tf; }
 648   InlineTree*       ilt() const                 { return _ilt; }
 649   address           stub_function() const       { return _stub_function; }
 650   const char*       stub_name() const           { return _stub_name; }
 651   address           stub_entry_point() const    { return _stub_entry_point; }
<a name="11" id="anc11"></a>
 652 
 653   // Control of this compilation.
 654   int               fixed_slots() const         { assert(_fixed_slots &gt;= 0, &quot;&quot;);         return _fixed_slots; }
 655   void          set_fixed_slots(int n)          { _fixed_slots = n; }
 656   int               major_progress() const      { return _major_progress; }
 657   void          set_inlining_progress(bool z)   { _inlining_progress = z; }
 658   int               inlining_progress() const   { return _inlining_progress; }
 659   void          set_inlining_incrementally(bool z) { _inlining_incrementally = z; }
 660   int               inlining_incrementally() const { return _inlining_incrementally; }
 661   void          set_do_cleanup(bool z)          { _do_cleanup = z; }
 662   int               do_cleanup() const          { return _do_cleanup; }
 663   void          set_major_progress()            { _major_progress++; }
 664   void          restore_major_progress(int progress) { _major_progress += progress; }
 665   void        clear_major_progress()            { _major_progress = 0; }
 666   int               max_inline_size() const     { return _max_inline_size; }
 667   void          set_freq_inline_size(int n)     { _freq_inline_size = n; }
 668   int               freq_inline_size() const    { return _freq_inline_size; }
 669   void          set_max_inline_size(int n)      { _max_inline_size = n; }
 670   bool              has_loops() const           { return _has_loops; }
 671   void          set_has_loops(bool z)           { _has_loops = z; }
 672   bool              has_split_ifs() const       { return _has_split_ifs; }
 673   void          set_has_split_ifs(bool z)       { _has_split_ifs = z; }
 674   bool              has_unsafe_access() const   { return _has_unsafe_access; }
 675   void          set_has_unsafe_access(bool z)   { _has_unsafe_access = z; }
 676   bool              has_stringbuilder() const   { return _has_stringbuilder; }
 677   void          set_has_stringbuilder(bool z)   { _has_stringbuilder = z; }
 678   bool              has_boxed_value() const     { return _has_boxed_value; }
 679   void          set_has_boxed_value(bool z)     { _has_boxed_value = z; }
 680   bool              has_reserved_stack_access() const { return _has_reserved_stack_access; }
 681   void          set_has_reserved_stack_access(bool z) { _has_reserved_stack_access = z; }
 682   uint              max_vector_size() const     { return _max_vector_size; }
 683   void          set_max_vector_size(uint s)     { _max_vector_size = s; }
 684   bool              clear_upper_avx() const     { return _clear_upper_avx; }
 685   void          set_clear_upper_avx(bool s)     { _clear_upper_avx = s; }
 686   void          set_trap_count(uint r, uint c)  { assert(r &lt; trapHistLength, &quot;oob&quot;);        _trap_hist[r] = c; }
 687   uint              trap_count(uint r) const    { assert(r &lt; trapHistLength, &quot;oob&quot;); return _trap_hist[r]; }
 688   bool              trap_can_recompile() const  { return _trap_can_recompile; }
 689   void          set_trap_can_recompile(bool z)  { _trap_can_recompile = z; }
 690   uint              decompile_count() const     { return _decompile_count; }
 691   void          set_decompile_count(uint c)     { _decompile_count = c; }
 692   bool              allow_range_check_smearing() const;
 693   bool              do_inlining() const         { return _do_inlining; }
 694   void          set_do_inlining(bool z)         { _do_inlining = z; }
 695   bool              do_scheduling() const       { return _do_scheduling; }
 696   void          set_do_scheduling(bool z)       { _do_scheduling = z; }
 697   bool              do_freq_based_layout() const{ return _do_freq_based_layout; }
 698   void          set_do_freq_based_layout(bool z){ _do_freq_based_layout = z; }
 699   bool              do_count_invocations() const{ return _do_count_invocations; }
 700   void          set_do_count_invocations(bool z){ _do_count_invocations = z; }
 701   bool              do_method_data_update() const { return _do_method_data_update; }
 702   void          set_do_method_data_update(bool z) { _do_method_data_update = z; }
 703   bool              do_vector_loop() const      { return _do_vector_loop; }
 704   void          set_do_vector_loop(bool z)      { _do_vector_loop = z; }
 705   bool              use_cmove() const           { return _use_cmove; }
 706   void          set_use_cmove(bool z)           { _use_cmove = z; }
 707   bool              age_code() const             { return _age_code; }
 708   void          set_age_code(bool z)             { _age_code = z; }
 709   int               AliasLevel() const           { return _AliasLevel; }
 710   bool              print_assembly() const       { return _print_assembly; }
 711   void          set_print_assembly(bool z)       { _print_assembly = z; }
 712   bool              print_inlining() const       { return _print_inlining; }
 713   void          set_print_inlining(bool z)       { _print_inlining = z; }
 714   bool              print_intrinsics() const     { return _print_intrinsics; }
 715   void          set_print_intrinsics(bool z)     { _print_intrinsics = z; }
 716   RTMState          rtm_state()  const           { return _rtm_state; }
 717   void          set_rtm_state(RTMState s)        { _rtm_state = s; }
 718   bool              use_rtm() const              { return (_rtm_state &amp; NoRTM) == 0; }
 719   bool          profile_rtm() const              { return _rtm_state == ProfileRTM; }
 720   uint              max_node_limit() const       { return (uint)_max_node_limit; }
 721   void          set_max_node_limit(uint n)       { _max_node_limit = n; }
 722   bool              clinit_barrier_on_entry()       { return _clinit_barrier_on_entry; }
 723   void          set_clinit_barrier_on_entry(bool z) { _clinit_barrier_on_entry = z; }
 724 
 725   // check the CompilerOracle for special behaviours for this compile
 726   bool          method_has_option(const char * option) {
 727     return method() != NULL &amp;&amp; method()-&gt;has_option(option);
 728   }
 729 
 730 #ifndef PRODUCT
 731   bool          trace_opto_output() const       { return _trace_opto_output; }
 732   bool          print_ideal() const             { return _print_ideal; }
 733   bool              parsed_irreducible_loop() const { return _parsed_irreducible_loop; }
 734   void          set_parsed_irreducible_loop(bool z) { _parsed_irreducible_loop = z; }
 735   int _in_dump_cnt;  // Required for dumping ir nodes.
 736 #endif
 737   bool              has_irreducible_loop() const { return _has_irreducible_loop; }
 738   void          set_has_irreducible_loop(bool z) { _has_irreducible_loop = z; }
 739 
 740   // JSR 292
 741   bool              has_method_handle_invokes() const { return _has_method_handle_invokes;     }
 742   void          set_has_method_handle_invokes(bool z) {        _has_method_handle_invokes = z; }
 743 
 744   Ticks _latest_stage_start_counter;
 745 
 746   void begin_method() {
 747 #ifndef PRODUCT
 748     if (_printer &amp;&amp; _printer-&gt;should_print(1)) {
 749       _printer-&gt;begin_method();
 750     }
 751 #endif
 752     C-&gt;_latest_stage_start_counter.stamp();
 753   }
 754 
 755   bool should_print(int level = 1) {
 756 #ifndef PRODUCT
 757     return (_printer &amp;&amp; _printer-&gt;should_print(level));
 758 #else
 759     return false;
 760 #endif
 761   }
 762 
 763   void print_method(CompilerPhaseType cpt, int level = 1, int idx = 0) {
 764     EventCompilerPhase event;
 765     if (event.should_commit()) {
 766       event.set_starttime(C-&gt;_latest_stage_start_counter);
 767       event.set_phase((u1) cpt);
 768       event.set_compileId(C-&gt;_compile_id);
 769       event.set_phaseLevel(level);
 770       event.commit();
 771     }
 772 
 773 #ifndef PRODUCT
 774     if (should_print(level)) {
 775       char output[1024];
 776       if (idx != 0) {
 777         sprintf(output, &quot;%s:%d&quot;, CompilerPhaseTypeHelper::to_string(cpt), idx);
 778       } else {
 779         sprintf(output, &quot;%s&quot;, CompilerPhaseTypeHelper::to_string(cpt));
 780       }
 781       _printer-&gt;print_method(output, level);
 782     }
 783 #endif
 784     C-&gt;_latest_stage_start_counter.stamp();
 785   }
 786 
 787   void end_method(int level = 1) {
 788     EventCompilerPhase event;
 789     if (event.should_commit()) {
 790       event.set_starttime(C-&gt;_latest_stage_start_counter);
 791       event.set_phase((u1) PHASE_END);
 792       event.set_compileId(C-&gt;_compile_id);
 793       event.set_phaseLevel(level);
 794       event.commit();
 795     }
 796 #ifndef PRODUCT
 797     if (_printer &amp;&amp; _printer-&gt;should_print(level)) {
 798       _printer-&gt;end_method();
 799     }
 800 #endif
 801   }
 802 
 803   int           macro_count()             const { return _macro_nodes-&gt;length(); }
 804   int           predicate_count()         const { return _predicate_opaqs-&gt;length();}
 805   int           expensive_count()         const { return _expensive_nodes-&gt;length(); }
 806   Node*         macro_node(int idx)       const { return _macro_nodes-&gt;at(idx); }
 807   Node*         predicate_opaque1_node(int idx) const { return _predicate_opaqs-&gt;at(idx);}
 808   Node*         expensive_node(int idx)   const { return _expensive_nodes-&gt;at(idx); }
 809   ConnectionGraph* congraph()                   { return _congraph;}
 810   void set_congraph(ConnectionGraph* congraph)  { _congraph = congraph;}
 811   void add_macro_node(Node * n) {
 812     //assert(n-&gt;is_macro(), &quot;must be a macro node&quot;);
 813     assert(!_macro_nodes-&gt;contains(n), &quot;duplicate entry in expand list&quot;);
 814     _macro_nodes-&gt;append(n);
 815   }
 816   void remove_macro_node(Node * n) {
 817     // this function may be called twice for a node so check
 818     // that the node is in the array before attempting to remove it
 819     if (_macro_nodes-&gt;contains(n))
 820       _macro_nodes-&gt;remove(n);
 821     // remove from _predicate_opaqs list also if it is there
 822     if (predicate_count() &gt; 0 &amp;&amp; _predicate_opaqs-&gt;contains(n)){
 823       _predicate_opaqs-&gt;remove(n);
 824     }
 825   }
 826   void add_expensive_node(Node * n);
 827   void remove_expensive_node(Node * n) {
 828     if (_expensive_nodes-&gt;contains(n)) {
 829       _expensive_nodes-&gt;remove(n);
 830     }
 831   }
 832   void add_predicate_opaq(Node * n) {
 833     assert(!_predicate_opaqs-&gt;contains(n), &quot;duplicate entry in predicate opaque1&quot;);
 834     assert(_macro_nodes-&gt;contains(n), &quot;should have already been in macro list&quot;);
 835     _predicate_opaqs-&gt;append(n);
 836   }
 837 
 838   // Range check dependent CastII nodes that can be removed after loop optimizations
 839   void add_range_check_cast(Node* n);
 840   void remove_range_check_cast(Node* n) {
 841     if (_range_check_casts-&gt;contains(n)) {
 842       _range_check_casts-&gt;remove(n);
 843     }
 844   }
 845   Node* range_check_cast_node(int idx) const { return _range_check_casts-&gt;at(idx);  }
 846   int   range_check_cast_count()       const { return _range_check_casts-&gt;length(); }
 847   // Remove all range check dependent CastIINodes.
 848   void  remove_range_check_casts(PhaseIterGVN &amp;igvn);
 849 
 850   void add_opaque4_node(Node* n);
 851   void remove_opaque4_node(Node* n) {
 852     if (_opaque4_nodes-&gt;contains(n)) {
 853       _opaque4_nodes-&gt;remove(n);
 854     }
 855   }
 856   Node* opaque4_node(int idx) const { return _opaque4_nodes-&gt;at(idx);  }
 857   int   opaque4_count()       const { return _opaque4_nodes-&gt;length(); }
 858   void  remove_opaque4_nodes(PhaseIterGVN &amp;igvn);
 859 
 860   // remove the opaque nodes that protect the predicates so that the unused checks and
 861   // uncommon traps will be eliminated from the graph.
 862   void cleanup_loop_predicates(PhaseIterGVN &amp;igvn);
 863   bool is_predicate_opaq(Node * n) {
 864     return _predicate_opaqs-&gt;contains(n);
 865   }
 866 
 867   // Are there candidate expensive nodes for optimization?
 868   bool should_optimize_expensive_nodes(PhaseIterGVN &amp;igvn);
 869   // Check whether n1 and n2 are similar
 870   static int cmp_expensive_nodes(Node* n1, Node* n2);
 871   // Sort expensive nodes to locate similar expensive nodes
 872   void sort_expensive_nodes();
 873 
 874   // Compilation environment.
 875   Arena*      comp_arena()           { return &amp;_comp_arena; }
 876   ciEnv*      env() const            { return _env; }
 877   CompileLog* log() const            { return _log; }
 878   bool        failing() const        { return _env-&gt;failing() || _failure_reason != NULL; }
 879   const char* failure_reason() const { return (_env-&gt;failing()) ? _env-&gt;failure_reason() : _failure_reason; }
 880 
 881   bool failure_reason_is(const char* r) const {
 882     return (r == _failure_reason) || (r != NULL &amp;&amp; _failure_reason != NULL &amp;&amp; strcmp(r, _failure_reason) == 0);
 883   }
 884 
 885   void record_failure(const char* reason);
 886   void record_method_not_compilable(const char* reason) {
 887     // Bailouts cover &quot;all_tiers&quot; when TieredCompilation is off.
 888     env()-&gt;record_method_not_compilable(reason, !TieredCompilation);
 889     // Record failure reason.
 890     record_failure(reason);
 891   }
 892   bool check_node_count(uint margin, const char* reason) {
 893     if (live_nodes() + margin &gt; max_node_limit()) {
 894       record_method_not_compilable(reason);
 895       return true;
 896     } else {
 897       return false;
 898     }
 899   }
 900 
 901   // Node management
 902   uint         unique() const              { return _unique; }
 903   uint         next_unique()               { return _unique++; }
 904   void         set_unique(uint i)          { _unique = i; }
 905   static int   debug_idx()                 { return debug_only(_debug_idx)+0; }
 906   static void  set_debug_idx(int i)        { debug_only(_debug_idx = i); }
 907   Arena*       node_arena()                { return &amp;_node_arena; }
 908   Arena*       old_arena()                 { return &amp;_old_arena; }
 909   RootNode*    root() const                { return _root; }
 910   void         set_root(RootNode* r)       { _root = r; }
 911   StartNode*   start() const;              // (Derived from root.)
 912   void         init_start(StartNode* s);
 913   Node*        immutable_memory();
 914 
 915   Node*        recent_alloc_ctl() const    { return _recent_alloc_ctl; }
 916   Node*        recent_alloc_obj() const    { return _recent_alloc_obj; }
 917   void         set_recent_alloc(Node* ctl, Node* obj) {
 918                                                   _recent_alloc_ctl = ctl;
 919                                                   _recent_alloc_obj = obj;
 920                                            }
 921   void         record_dead_node(uint idx)  { if (_dead_node_list.test_set(idx)) return;
 922                                              _dead_node_count++;
 923                                            }
 924   void         reset_dead_node_list()      { _dead_node_list.reset();
 925                                              _dead_node_count = 0;
 926                                            }
 927   uint          live_nodes() const         {
 928     int  val = _unique - _dead_node_count;
 929     assert (val &gt;= 0, &quot;number of tracked dead nodes %d more than created nodes %d&quot;, _unique, _dead_node_count);
 930             return (uint) val;
 931                                            }
 932 #ifdef ASSERT
 933   uint         count_live_nodes_by_graph_walk();
 934   void         print_missing_nodes();
 935 #endif
 936 
 937   // Record modified nodes to check that they are put on IGVN worklist
 938   void         record_modified_node(Node* n) NOT_DEBUG_RETURN;
 939   void         remove_modified_node(Node* n) NOT_DEBUG_RETURN;
 940   DEBUG_ONLY( Unique_Node_List*   modified_nodes() const { return _modified_nodes; } )
 941 
<a name="12" id="anc12"></a><span class="line-removed"> 942   // Constant table</span>
<span class="line-removed"> 943   ConstantTable&amp;   constant_table() { return _constant_table; }</span>
<span class="line-removed"> 944 </span>
 945   MachConstantBaseNode*     mach_constant_base_node();
 946   bool                  has_mach_constant_base_node() const { return _mach_constant_base_node != NULL; }
 947   // Generated by adlc, true if CallNode requires MachConstantBase.
 948   bool                      needs_clone_jvms();
 949 
 950   // Handy undefined Node
 951   Node*             top() const                 { return _top; }
 952 
 953   // these are used by guys who need to know about creation and transformation of top:
 954   Node*             cached_top_node()           { return _top; }
 955   void          set_cached_top_node(Node* tn);
 956 
 957   GrowableArray&lt;Node_Notes*&gt;* node_note_array() const { return _node_note_array; }
 958   void set_node_note_array(GrowableArray&lt;Node_Notes*&gt;* arr) { _node_note_array = arr; }
 959   Node_Notes* default_node_notes() const        { return _default_node_notes; }
 960   void    set_default_node_notes(Node_Notes* n) { _default_node_notes = n; }
 961 
 962   Node_Notes*       node_notes_at(int idx) {
 963     return locate_node_notes(_node_note_array, idx, false);
 964   }
 965   inline bool   set_node_notes_at(int idx, Node_Notes* value);
 966 
 967   // Copy notes from source to dest, if they exist.
 968   // Overwrite dest only if source provides something.
 969   // Return true if information was moved.
 970   bool copy_node_notes_to(Node* dest, Node* source);
 971 
 972   // Workhorse function to sort out the blocked Node_Notes array:
 973   inline Node_Notes* locate_node_notes(GrowableArray&lt;Node_Notes*&gt;* arr,
 974                                        int idx, bool can_grow = false);
 975 
 976   void grow_node_notes(GrowableArray&lt;Node_Notes*&gt;* arr, int grow_by);
 977 
 978   // Type management
 979   Arena*            type_arena()                { return _type_arena; }
 980   Dict*             type_dict()                 { return _type_dict; }
 981   size_t            type_last_size()            { return _type_last_size; }
 982   int               num_alias_types()           { return _num_alias_types; }
 983 
 984   void          init_type_arena()                       { _type_arena = &amp;_Compile_types; }
 985   void          set_type_arena(Arena* a)                { _type_arena = a; }
 986   void          set_type_dict(Dict* d)                  { _type_dict = d; }
 987   void          set_type_last_size(size_t sz)           { _type_last_size = sz; }
 988 
 989   const TypeFunc* last_tf(ciMethod* m) {
 990     return (m == _last_tf_m) ? _last_tf : NULL;
 991   }
 992   void set_last_tf(ciMethod* m, const TypeFunc* tf) {
 993     assert(m != NULL || tf == NULL, &quot;&quot;);
 994     _last_tf_m = m;
 995     _last_tf = tf;
 996   }
 997 
 998   AliasType*        alias_type(int                idx)  { assert(idx &lt; num_alias_types(), &quot;oob&quot;); return _alias_types[idx]; }
 999   AliasType*        alias_type(const TypePtr* adr_type, ciField* field = NULL) { return find_alias_type(adr_type, false, field); }
1000   bool         have_alias_type(const TypePtr* adr_type);
1001   AliasType*        alias_type(ciField*         field);
1002 
1003   int               get_alias_index(const TypePtr* at)  { return alias_type(at)-&gt;index(); }
1004   const TypePtr*    get_adr_type(uint aidx)             { return alias_type(aidx)-&gt;adr_type(); }
1005   int               get_general_index(uint aidx)        { return alias_type(aidx)-&gt;general_index(); }
1006 
1007   // Building nodes
1008   void              rethrow_exceptions(JVMState* jvms);
1009   void              return_values(JVMState* jvms);
1010   JVMState*         build_start_state(StartNode* start, const TypeFunc* tf);
1011 
1012   // Decide how to build a call.
1013   // The profile factor is a discount to apply to this site&#39;s interp. profile.
1014   CallGenerator*    call_generator(ciMethod* call_method, int vtable_index, bool call_does_dispatch,
1015                                    JVMState* jvms, bool allow_inline, float profile_factor, ciKlass* speculative_receiver_type = NULL,
1016                                    bool allow_intrinsics = true, bool delayed_forbidden = false);
1017   bool should_delay_inlining(ciMethod* call_method, JVMState* jvms) {
1018     return should_delay_string_inlining(call_method, jvms) ||
1019            should_delay_boxing_inlining(call_method, jvms);
1020   }
1021   bool should_delay_string_inlining(ciMethod* call_method, JVMState* jvms);
1022   bool should_delay_boxing_inlining(ciMethod* call_method, JVMState* jvms);
1023 
1024   // Helper functions to identify inlining potential at call-site
1025   ciMethod* optimize_virtual_call(ciMethod* caller, int bci, ciInstanceKlass* klass,
1026                                   ciKlass* holder, ciMethod* callee,
1027                                   const TypeOopPtr* receiver_type, bool is_virtual,
1028                                   bool &amp;call_does_dispatch, int &amp;vtable_index,
1029                                   bool check_access = true);
1030   ciMethod* optimize_inlining(ciMethod* caller, int bci, ciInstanceKlass* klass,
1031                               ciMethod* callee, const TypeOopPtr* receiver_type,
1032                               bool check_access = true);
1033 
1034   // Report if there were too many traps at a current method and bci.
1035   // Report if a trap was recorded, and/or PerMethodTrapLimit was exceeded.
1036   // If there is no MDO at all, report no trap unless told to assume it.
1037   bool too_many_traps(ciMethod* method, int bci, Deoptimization::DeoptReason reason);
1038   // This version, unspecific to a particular bci, asks if
1039   // PerMethodTrapLimit was exceeded for all inlined methods seen so far.
1040   bool too_many_traps(Deoptimization::DeoptReason reason,
1041                       // Privately used parameter for logging:
1042                       ciMethodData* logmd = NULL);
1043   // Report if there were too many recompiles at a method and bci.
1044   bool too_many_recompiles(ciMethod* method, int bci, Deoptimization::DeoptReason reason);
1045   // Report if there were too many traps or recompiles at a method and bci.
1046   bool too_many_traps_or_recompiles(ciMethod* method, int bci, Deoptimization::DeoptReason reason) {
1047     return too_many_traps(method, bci, reason) ||
1048            too_many_recompiles(method, bci, reason);
1049   }
1050   // Return a bitset with the reasons where deoptimization is allowed,
1051   // i.e., where there were not too many uncommon traps.
1052   int _allowed_reasons;
1053   int      allowed_deopt_reasons() { return _allowed_reasons; }
1054   void set_allowed_deopt_reasons();
1055 
1056   // Parsing, optimization
1057   PhaseGVN*         initial_gvn()               { return _initial_gvn; }
1058   Unique_Node_List* for_igvn()                  { return _for_igvn; }
1059   inline void       record_for_igvn(Node* n);   // Body is after class Unique_Node_List.
1060   void          set_initial_gvn(PhaseGVN *gvn)           { _initial_gvn = gvn; }
1061   void          set_for_igvn(Unique_Node_List *for_igvn) { _for_igvn = for_igvn; }
1062 
1063   // Replace n by nn using initial_gvn, calling hash_delete and
1064   // record_for_igvn as needed.
1065   void gvn_replace_by(Node* n, Node* nn);
1066 
1067 
1068   void              identify_useful_nodes(Unique_Node_List &amp;useful);
1069   void              update_dead_node_list(Unique_Node_List &amp;useful);
1070   void              remove_useless_nodes (Unique_Node_List &amp;useful);
1071 
1072   WarmCallInfo*     warm_calls() const          { return _warm_calls; }
1073   void          set_warm_calls(WarmCallInfo* l) { _warm_calls = l; }
1074   WarmCallInfo* pop_warm_call();
1075 
1076   // Record this CallGenerator for inlining at the end of parsing.
1077   void              add_late_inline(CallGenerator* cg)        {
1078     _late_inlines.insert_before(_late_inlines_pos, cg);
1079     _late_inlines_pos++;
1080   }
1081 
1082   void              prepend_late_inline(CallGenerator* cg)    {
1083     _late_inlines.insert_before(0, cg);
1084   }
1085 
1086   void              add_string_late_inline(CallGenerator* cg) {
1087     _string_late_inlines.push(cg);
1088   }
1089 
1090   void              add_boxing_late_inline(CallGenerator* cg) {
1091     _boxing_late_inlines.push(cg);
1092   }
1093 
1094   void remove_useless_late_inlines(GrowableArray&lt;CallGenerator*&gt;* inlines, Unique_Node_List &amp;useful);
1095 
1096   void process_print_inlining();
1097   void dump_print_inlining();
1098 
1099   bool over_inlining_cutoff() const {
1100     if (!inlining_incrementally()) {
1101       return unique() &gt; (uint)NodeCountInliningCutoff;
1102     } else {
1103       // Give some room for incremental inlining algorithm to &quot;breathe&quot;
1104       // and avoid thrashing when live node count is close to the limit.
1105       // Keep in mind that live_nodes() isn&#39;t accurate during inlining until
1106       // dead node elimination step happens (see Compile::inline_incrementally).
1107       return live_nodes() &gt; (uint)LiveNodeCountInliningCutoff * 11 / 10;
1108     }
1109   }
1110 
1111   void inc_number_of_mh_late_inlines() { _number_of_mh_late_inlines++; }
1112   void dec_number_of_mh_late_inlines() { assert(_number_of_mh_late_inlines &gt; 0, &quot;_number_of_mh_late_inlines &lt; 0 !&quot;); _number_of_mh_late_inlines--; }
1113   bool has_mh_late_inlines() const     { return _number_of_mh_late_inlines &gt; 0; }
1114 
1115   bool inline_incrementally_one();
1116   void inline_incrementally_cleanup(PhaseIterGVN&amp; igvn);
1117   void inline_incrementally(PhaseIterGVN&amp; igvn);
1118   void inline_string_calls(bool parse_time);
1119   void inline_boxing_calls(PhaseIterGVN&amp; igvn);
1120   bool optimize_loops(PhaseIterGVN&amp; igvn, LoopOptsMode mode);
1121   void remove_root_to_sfpts_edges(PhaseIterGVN&amp; igvn);
1122 
1123   // Matching, CFG layout, allocation, code generation
1124   PhaseCFG*         cfg()                       { return _cfg; }
<a name="13" id="anc13"></a><span class="line-removed">1125   bool              select_24_bit_instr() const { return _select_24_bit_instr; }</span>
<span class="line-removed">1126   bool              in_24_bit_fp_mode() const   { return _in_24_bit_fp_mode; }</span>
1127   bool              has_java_calls() const      { return _java_calls &gt; 0; }
1128   int               java_calls() const          { return _java_calls; }
1129   int               inner_loops() const         { return _inner_loops; }
1130   Matcher*          matcher()                   { return _matcher; }
1131   PhaseRegAlloc*    regalloc()                  { return _regalloc; }
<a name="14" id="anc14"></a><span class="line-removed">1132   int               frame_slots() const         { return _frame_slots; }</span>
<span class="line-removed">1133   int               frame_size_in_words() const; // frame_slots in units of the polymorphic &#39;words&#39;</span>
<span class="line-removed">1134   int               frame_size_in_bytes() const { return _frame_slots &lt;&lt; LogBytesPerInt; }</span>
1135   RegMask&amp;          FIRST_STACK_mask()          { return _FIRST_STACK_mask; }
1136   Arena*            indexSet_arena()            { return _indexSet_arena; }
1137   void*             indexSet_free_block_list()  { return _indexSet_free_block_list; }
<a name="15" id="anc15"></a><span class="line-modified">1138   uint              node_bundling_limit()       { return _node_bundling_limit; }</span>
<span class="line-removed">1139   Bundle*           node_bundling_base()        { return _node_bundling_base; }</span>
<span class="line-removed">1140   void          set_node_bundling_limit(uint n) { _node_bundling_limit = n; }</span>
<span class="line-removed">1141   void          set_node_bundling_base(Bundle* b) { _node_bundling_base = b; }</span>
<span class="line-removed">1142   bool          starts_bundle(const Node *n) const;</span>
<span class="line-removed">1143   bool          need_stack_bang(int frame_size_in_bytes) const;</span>
<span class="line-removed">1144   bool          need_register_stack_bang() const;</span>
1145 
1146   void  update_interpreter_frame_size(int size) {
1147     if (_interpreter_frame_size &lt; size) {
1148       _interpreter_frame_size = size;
1149     }
1150   }
<a name="16" id="anc16"></a><span class="line-removed">1151   int           bang_size_in_bytes() const;</span>
1152 
1153   void          set_matcher(Matcher* m)                 { _matcher = m; }
1154 //void          set_regalloc(PhaseRegAlloc* ra)           { _regalloc = ra; }
1155   void          set_indexSet_arena(Arena* a)            { _indexSet_arena = a; }
1156   void          set_indexSet_free_block_list(void* p)   { _indexSet_free_block_list = p; }
1157 
<a name="17" id="anc17"></a><span class="line-removed">1158   // Remember if this compilation changes hardware mode to 24-bit precision</span>
<span class="line-removed">1159   void set_24_bit_selection_and_mode(bool selection, bool mode) {</span>
<span class="line-removed">1160     _select_24_bit_instr = selection;</span>
<span class="line-removed">1161     _in_24_bit_fp_mode   = mode;</span>
<span class="line-removed">1162   }</span>
<span class="line-removed">1163 </span>
1164   void  set_java_calls(int z) { _java_calls  = z; }
1165   void set_inner_loops(int z) { _inner_loops = z; }
1166 
<a name="18" id="anc18"></a><span class="line-modified">1167   // Instruction bits passed off to the VM</span>
<span class="line-removed">1168   int               code_size()                 { return _method_size; }</span>
<span class="line-removed">1169   CodeBuffer*       code_buffer()               { return &amp;_code_buffer; }</span>
<span class="line-removed">1170   int               first_block_size()          { return _first_block_size; }</span>
<span class="line-removed">1171   void              set_frame_complete(int off) { if (!in_scratch_emit_size()) { _code_offsets.set_value(CodeOffsets::Frame_Complete, off); } }</span>
<span class="line-removed">1172   ExceptionHandlerTable*  handler_table()       { return &amp;_handler_table; }</span>
<span class="line-removed">1173   ImplicitExceptionTable* inc_table()           { return &amp;_inc_table; }</span>
<span class="line-removed">1174   OopMapSet*        oop_map_set()               { return _oop_map_set; }</span>
<span class="line-removed">1175   DebugInformationRecorder* debug_info()        { return env()-&gt;debug_info(); }</span>
<span class="line-removed">1176   Dependencies*     dependencies()              { return env()-&gt;dependencies(); }</span>
<span class="line-removed">1177   static int        CompiledZap_count()         { return _CompiledZap_count; }</span>
<span class="line-removed">1178   BufferBlob*       scratch_buffer_blob()       { return _scratch_buffer_blob; }</span>
<span class="line-removed">1179   void         init_scratch_buffer_blob(int const_size);</span>
<span class="line-removed">1180   void        clear_scratch_buffer_blob();</span>
<span class="line-removed">1181   void          set_scratch_buffer_blob(BufferBlob* b) { _scratch_buffer_blob = b; }</span>
<span class="line-removed">1182   relocInfo*        scratch_locs_memory()       { return _scratch_locs_memory; }</span>
<span class="line-removed">1183   void          set_scratch_locs_memory(relocInfo* b)  { _scratch_locs_memory = b; }</span>
<span class="line-removed">1184 </span>
<span class="line-removed">1185   // emit to scratch blob, report resulting size</span>
<span class="line-removed">1186   uint              scratch_emit_size(const Node* n);</span>
<span class="line-removed">1187   void       set_in_scratch_emit_size(bool x)   {        _in_scratch_emit_size = x; }</span>
<span class="line-removed">1188   bool           in_scratch_emit_size() const   { return _in_scratch_emit_size;     }</span>
<span class="line-removed">1189 </span>
<span class="line-removed">1190   enum ScratchBufferBlob {</span>
<span class="line-removed">1191     MAX_inst_size       = 2048,</span>
<span class="line-removed">1192     MAX_locs_size       = 128, // number of relocInfo elements</span>
<span class="line-removed">1193     MAX_const_size      = 128,</span>
<span class="line-removed">1194     MAX_stubs_size      = 128</span>
<span class="line-removed">1195   };</span>
1196 
1197   // Major entry point.  Given a Scope, compile the associated method.
1198   // For normal compilations, entry_bci is InvocationEntryBci.  For on stack
1199   // replacement, entry_bci indicates the bytecode for which to compile a
1200   // continuation.
<a name="19" id="anc19"></a><span class="line-modified">1201   Compile(ciEnv* ci_env, C2Compiler* compiler, ciMethod* target,</span>
1202           int entry_bci, bool subsume_loads, bool do_escape_analysis,
1203           bool eliminate_boxing, DirectiveSet* directive);
1204 
1205   // Second major entry point.  From the TypeFunc signature, generate code
1206   // to pass arguments from the Java calling convention to the C calling
1207   // convention.
1208   Compile(ciEnv* ci_env, const TypeFunc *(*gen)(),
1209           address stub_function, const char *stub_name,
1210           int is_fancy_jump, bool pass_tls,
1211           bool save_arg_registers, bool return_pc, DirectiveSet* directive);
1212 
1213   // From the TypeFunc signature, generate code to pass arguments
1214   // from Compiled calling convention to Interpreter&#39;s calling convention
1215   void Generate_Compiled_To_Interpreter_Graph(const TypeFunc *tf, address interpreter_entry);
1216 
1217   // From the TypeFunc signature, generate code to pass arguments
1218   // from Interpreter&#39;s calling convention to Compiler&#39;s calling convention
1219   void Generate_Interpreter_To_Compiled_Graph(const TypeFunc *tf);
1220 
1221   // Are we compiling a method?
1222   bool has_method() { return method() != NULL; }
1223 
1224   // Maybe print some information about this compile.
1225   void print_compile_messages();
1226 
1227   // Final graph reshaping, a post-pass after the regular optimizer is done.
1228   bool final_graph_reshaping();
1229 
1230   // returns true if adr is completely contained in the given alias category
1231   bool must_alias(const TypePtr* adr, int alias_idx);
1232 
1233   // returns true if adr overlaps with the given alias category
1234   bool can_alias(const TypePtr* adr, int alias_idx);
1235 
<a name="20" id="anc20"></a><span class="line-removed">1236   // Driver for converting compiler&#39;s IR into machine code bits</span>
<span class="line-removed">1237   void Output();</span>
<span class="line-removed">1238 </span>
<span class="line-removed">1239   // Accessors for node bundling info.</span>
<span class="line-removed">1240   Bundle* node_bundling(const Node *n);</span>
<span class="line-removed">1241   bool valid_bundle_info(const Node *n);</span>
<span class="line-removed">1242 </span>
<span class="line-removed">1243   // Schedule and Bundle the instructions</span>
<span class="line-removed">1244   void ScheduleAndBundle();</span>
<span class="line-removed">1245 </span>
<span class="line-removed">1246   // Build OopMaps for each GC point</span>
<span class="line-removed">1247   void BuildOopMaps();</span>
<span class="line-removed">1248 </span>
<span class="line-removed">1249   // Append debug info for the node &quot;local&quot; at safepoint node &quot;sfpt&quot; to the</span>
<span class="line-removed">1250   // &quot;array&quot;,   May also consult and add to &quot;objs&quot;, which describes the</span>
<span class="line-removed">1251   // scalar-replaced objects.</span>
<span class="line-removed">1252   void FillLocArray( int idx, MachSafePointNode* sfpt,</span>
<span class="line-removed">1253                      Node *local, GrowableArray&lt;ScopeValue*&gt; *array,</span>
<span class="line-removed">1254                      GrowableArray&lt;ScopeValue*&gt; *objs );</span>
<span class="line-removed">1255 </span>
1256   // If &quot;objs&quot; contains an ObjectValue whose id is &quot;id&quot;, returns it, else NULL.
1257   static ObjectValue* sv_for_node_id(GrowableArray&lt;ScopeValue*&gt; *objs, int id);
<a name="21" id="anc21"></a><span class="line-removed">1258   // Requres that &quot;objs&quot; does not contains an ObjectValue whose id matches</span>
<span class="line-removed">1259   // that of &quot;sv.  Appends &quot;sv&quot;.</span>
<span class="line-removed">1260   static void set_sv_for_object_node(GrowableArray&lt;ScopeValue*&gt; *objs,</span>
<span class="line-removed">1261                                      ObjectValue* sv );</span>
<span class="line-removed">1262 </span>
<span class="line-removed">1263   // Process an OopMap Element while emitting nodes</span>
<span class="line-removed">1264   void Process_OopMap_Node(MachNode *mach, int code_offset);</span>
<span class="line-removed">1265 </span>
<span class="line-removed">1266   class BufferSizingData {</span>
<span class="line-removed">1267   public:</span>
<span class="line-removed">1268     int _stub;</span>
<span class="line-removed">1269     int _code;</span>
<span class="line-removed">1270     int _const;</span>
<span class="line-removed">1271     int _reloc;</span>
<span class="line-removed">1272 </span>
<span class="line-removed">1273       BufferSizingData() :</span>
<span class="line-removed">1274       _stub(0),</span>
<span class="line-removed">1275       _code(0),</span>
<span class="line-removed">1276       _const(0),</span>
<span class="line-removed">1277       _reloc(0)</span>
<span class="line-removed">1278       { };</span>
<span class="line-removed">1279   };</span>
<span class="line-removed">1280 </span>
<span class="line-removed">1281   // Initialize code buffer</span>
<span class="line-removed">1282   void        estimate_buffer_size(int&amp; const_req);</span>
<span class="line-removed">1283   CodeBuffer* init_buffer(BufferSizingData&amp; buf_sizes);</span>
<span class="line-removed">1284 </span>
<span class="line-removed">1285   // Write out basic block data to code buffer</span>
<span class="line-removed">1286   void fill_buffer(CodeBuffer* cb, uint* blk_starts);</span>
<span class="line-removed">1287 </span>
<span class="line-removed">1288   // Determine which variable sized branches can be shortened</span>
<span class="line-removed">1289   void shorten_branches(uint* blk_starts, BufferSizingData&amp; buf_sizes);</span>
<span class="line-removed">1290 </span>
<span class="line-removed">1291   // Compute the size of first NumberOfLoopInstrToAlign instructions</span>
<span class="line-removed">1292   // at the head of a loop.</span>
<span class="line-removed">1293   void compute_loop_first_inst_sizes();</span>
<span class="line-removed">1294 </span>
<span class="line-removed">1295   // Compute the information for the exception tables</span>
<span class="line-removed">1296   void FillExceptionTables(uint cnt, uint *call_returns, uint *inct_starts, Label *blk_labels);</span>
1297 
1298   // Stack slots that may be unused by the calling convention but must
1299   // otherwise be preserved.  On Intel this includes the return address.
1300   // On PowerPC it includes the 4 words holding the old TOC &amp; LR glue.
1301   uint in_preserve_stack_slots();
1302 
1303   // &quot;Top of Stack&quot; slots that may be unused by the calling convention but must
1304   // otherwise be preserved.
1305   // On Intel these are not necessary and the value can be zero.
1306   // On Sparc this describes the words reserved for storing a register window
1307   // when an interrupt occurs.
1308   static uint out_preserve_stack_slots();
1309 
1310   // Number of outgoing stack slots killed above the out_preserve_stack_slots
1311   // for calls to C.  Supports the var-args backing area for register parms.
1312   uint varargs_C_out_slots_killed() const;
1313 
1314   // Number of Stack Slots consumed by a synchronization entry
1315   int sync_stack_slots() const;
1316 
1317   // Compute the name of old_SP.  See &lt;arch&gt;.ad for frame layout.
1318   OptoReg::Name compute_old_SP();
1319 
1320  private:
1321   // Phase control:
1322   void Init(int aliaslevel);                     // Prepare for a single compilation
1323   int  Inline_Warm();                            // Find more inlining work.
1324   void Finish_Warm();                            // Give up on further inlines.
1325   void Optimize();                               // Given a graph, optimize it
1326   void Code_Gen();                               // Generate code from a graph
1327 
1328   // Management of the AliasType table.
1329   void grow_alias_types();
1330   AliasCacheEntry* probe_alias_cache(const TypePtr* adr_type);
1331   const TypePtr *flatten_alias_type(const TypePtr* adr_type) const;
1332   AliasType* find_alias_type(const TypePtr* adr_type, bool no_create, ciField* field);
1333 
1334   void verify_top(Node*) const PRODUCT_RETURN;
1335 
1336   // Intrinsic setup.
1337   void           register_library_intrinsics();                            // initializer
1338   CallGenerator* make_vm_intrinsic(ciMethod* m, bool is_virtual);          // constructor
1339   int            intrinsic_insertion_index(ciMethod* m, bool is_virtual, bool&amp; found);  // helper
1340   CallGenerator* find_intrinsic(ciMethod* m, bool is_virtual);             // query fn
1341   void           register_intrinsic(CallGenerator* cg);                    // update fn
1342 
1343 #ifndef PRODUCT
1344   static juint  _intrinsic_hist_count[vmIntrinsics::ID_LIMIT];
1345   static jubyte _intrinsic_hist_flags[vmIntrinsics::ID_LIMIT];
1346 #endif
1347   // Function calls made by the public function final_graph_reshaping.
1348   // No need to be made public as they are not called elsewhere.
1349   void final_graph_reshaping_impl( Node *n, Final_Reshape_Counts &amp;frc);
1350   void final_graph_reshaping_main_switch(Node* n, Final_Reshape_Counts&amp; frc, uint nop);
1351   void final_graph_reshaping_walk( Node_Stack &amp;nstack, Node *root, Final_Reshape_Counts &amp;frc );
1352   void eliminate_redundant_card_marks(Node* n);
1353 
1354  public:
1355 
1356   // Note:  Histogram array size is about 1 Kb.
1357   enum {                        // flag bits:
1358     _intrinsic_worked = 1,      // succeeded at least once
1359     _intrinsic_failed = 2,      // tried it but it failed
1360     _intrinsic_disabled = 4,    // was requested but disabled (e.g., -XX:-InlineUnsafeOps)
1361     _intrinsic_virtual = 8,     // was seen in the virtual form (rare)
1362     _intrinsic_both = 16        // was seen in the non-virtual form (usual)
1363   };
1364   // Update histogram.  Return boolean if this is a first-time occurrence.
1365   static bool gather_intrinsic_statistics(vmIntrinsics::ID id,
1366                                           bool is_virtual, int flags) PRODUCT_RETURN0;
1367   static void print_intrinsic_statistics() PRODUCT_RETURN;
1368 
1369   // Graph verification code
1370   // Walk the node list, verifying that there is a one-to-one
1371   // correspondence between Use-Def edges and Def-Use edges
1372   // The option no_dead_code enables stronger checks that the
1373   // graph is strongly connected from root in both directions.
1374   void verify_graph_edges(bool no_dead_code = false) PRODUCT_RETURN;
1375 
1376   // End-of-run dumps.
1377   static void print_statistics() PRODUCT_RETURN;
1378 
<a name="22" id="anc22"></a><span class="line-removed">1379   // Dump formatted assembly</span>
<span class="line-removed">1380 #if defined(SUPPORT_OPTO_ASSEMBLY)</span>
<span class="line-removed">1381   void dump_asm_on(outputStream* ost, int* pcs, uint pc_limit);</span>
<span class="line-removed">1382   void dump_asm(int* pcs = NULL, uint pc_limit = 0) { dump_asm_on(tty, pcs, pc_limit); }</span>
<span class="line-removed">1383 #else</span>
<span class="line-removed">1384   void dump_asm_on(outputStream* ost, int* pcs, uint pc_limit) { return; }</span>
<span class="line-removed">1385   void dump_asm(int* pcs = NULL, uint pc_limit = 0) { return; }</span>
<span class="line-removed">1386 #endif</span>
<span class="line-removed">1387   void dump_pc(int *pcs, int pc_limit, Node *n);</span>
<span class="line-removed">1388 </span>
1389   // Verify ADLC assumptions during startup
1390   static void adlc_verification() PRODUCT_RETURN;
1391 
1392   // Definitions of pd methods
1393   static void pd_compiler2_init();
1394 
1395   // Static parse-time type checking logic for gen_subtype_check:
1396   enum { SSC_always_false, SSC_always_true, SSC_easy_test, SSC_full_test };
1397   int static_subtype_check(ciKlass* superk, ciKlass* subk);
1398 
1399   static Node* conv_I2X_index(PhaseGVN* phase, Node* offset, const TypeInt* sizetype,
1400                               // Optional control dependency (for example, on range check)
1401                               Node* ctrl = NULL);
1402 
1403   // Convert integer value to a narrowed long type dependent on ctrl (for example, a range check)
1404   static Node* constrained_convI2L(PhaseGVN* phase, Node* value, const TypeInt* itype, Node* ctrl);
1405 
1406   // Auxiliary method for randomized fuzzing/stressing
1407   static bool randomized_select(int count);
1408 
1409   // supporting clone_map
1410   CloneMap&amp;     clone_map();
1411   void          set_clone_map(Dict* d);
1412 
1413   bool needs_clinit_barrier(ciField* ik,         ciMethod* accessing_method);
1414   bool needs_clinit_barrier(ciMethod* ik,        ciMethod* accessing_method);
1415   bool needs_clinit_barrier(ciInstanceKlass* ik, ciMethod* accessing_method);
<a name="23" id="anc23"></a>















1416 };
1417 
1418 #endif // SHARE_OPTO_COMPILE_HPP
<a name="24" id="anc24"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="24" type="hidden" />
</body>
</html>
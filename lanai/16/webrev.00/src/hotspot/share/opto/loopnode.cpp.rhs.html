<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/loopnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciMethodData.hpp&quot;
  27 #include &quot;compiler/compileLog.hpp&quot;
  28 #include &quot;gc/shared/barrierSet.hpp&quot;
  29 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  30 #include &quot;libadt/vectset.hpp&quot;
  31 #include &quot;memory/allocation.inline.hpp&quot;
  32 #include &quot;memory/resourceArea.hpp&quot;
  33 #include &quot;opto/addnode.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added">  34 #include &quot;opto/arraycopynode.hpp&quot;</span>
  35 #include &quot;opto/callnode.hpp&quot;
  36 #include &quot;opto/connode.hpp&quot;
  37 #include &quot;opto/convertnode.hpp&quot;
  38 #include &quot;opto/divnode.hpp&quot;
  39 #include &quot;opto/idealGraphPrinter.hpp&quot;
  40 #include &quot;opto/loopnode.hpp&quot;
  41 #include &quot;opto/mulnode.hpp&quot;
  42 #include &quot;opto/rootnode.hpp&quot;
  43 #include &quot;opto/superword.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added">  44 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  45 
  46 //=============================================================================
  47 //--------------------------is_cloop_ind_var-----------------------------------
  48 // Determine if a node is a counted loop induction variable.
  49 // NOTE: The method is declared in &quot;node.hpp&quot;.
  50 bool Node::is_cloop_ind_var() const {
  51   return (is_Phi() &amp;&amp; !as_Phi()-&gt;is_copy() &amp;&amp;
  52           as_Phi()-&gt;region()-&gt;is_CountedLoop() &amp;&amp;
  53           as_Phi()-&gt;region()-&gt;as_CountedLoop()-&gt;phi() == this);
  54 }
  55 
  56 //=============================================================================
  57 //------------------------------dump_spec--------------------------------------
  58 // Dump special per-node info
  59 #ifndef PRODUCT
  60 void LoopNode::dump_spec(outputStream *st) const {
  61   if (is_inner_loop()) st-&gt;print( &quot;inner &quot; );
  62   if (is_partial_peel_loop()) st-&gt;print( &quot;partial_peel &quot; );
  63   if (partial_peel_has_failed()) st-&gt;print( &quot;partial_peel_failed &quot; );
  64 }
  65 #endif
  66 
  67 //------------------------------is_valid_counted_loop-------------------------
  68 bool LoopNode::is_valid_counted_loop() const {
  69   if (is_CountedLoop()) {
  70     CountedLoopNode*    l  = as_CountedLoop();
  71     CountedLoopEndNode* le = l-&gt;loopexit_or_null();
  72     if (le != NULL &amp;&amp;
  73         le-&gt;proj_out_or_null(1 /* true */) == l-&gt;in(LoopNode::LoopBackControl)) {
  74       Node* phi  = l-&gt;phi();
  75       Node* exit = le-&gt;proj_out_or_null(0 /* false */);
  76       if (exit != NULL &amp;&amp; exit-&gt;Opcode() == Op_IfFalse &amp;&amp;
  77           phi != NULL &amp;&amp; phi-&gt;is_Phi() &amp;&amp;
  78           phi-&gt;in(LoopNode::LoopBackControl) == l-&gt;incr() &amp;&amp;
  79           le-&gt;loopnode() == l &amp;&amp; le-&gt;stride_is_con()) {
  80         return true;
  81       }
  82     }
  83   }
  84   return false;
  85 }
  86 
  87 //------------------------------get_early_ctrl---------------------------------
  88 // Compute earliest legal control
  89 Node *PhaseIdealLoop::get_early_ctrl( Node *n ) {
  90   assert( !n-&gt;is_Phi() &amp;&amp; !n-&gt;is_CFG(), &quot;this code only handles data nodes&quot; );
  91   uint i;
  92   Node *early;
  93   if (n-&gt;in(0) &amp;&amp; !n-&gt;is_expensive()) {
  94     early = n-&gt;in(0);
  95     if (!early-&gt;is_CFG()) // Might be a non-CFG multi-def
  96       early = get_ctrl(early);        // So treat input as a straight data input
  97     i = 1;
  98   } else {
  99     early = get_ctrl(n-&gt;in(1));
 100     i = 2;
 101   }
 102   uint e_d = dom_depth(early);
 103   assert( early, &quot;&quot; );
 104   for (; i &lt; n-&gt;req(); i++) {
 105     Node *cin = get_ctrl(n-&gt;in(i));
 106     assert( cin, &quot;&quot; );
 107     // Keep deepest dominator depth
 108     uint c_d = dom_depth(cin);
 109     if (c_d &gt; e_d) {           // Deeper guy?
 110       early = cin;              // Keep deepest found so far
 111       e_d = c_d;
 112     } else if (c_d == e_d &amp;&amp;    // Same depth?
 113                early != cin) { // If not equal, must use slower algorithm
 114       // If same depth but not equal, one _must_ dominate the other
 115       // and we want the deeper (i.e., dominated) guy.
 116       Node *n1 = early;
 117       Node *n2 = cin;
 118       while (1) {
 119         n1 = idom(n1);          // Walk up until break cycle
 120         n2 = idom(n2);
 121         if (n1 == cin ||        // Walked early up to cin
 122             dom_depth(n2) &lt; c_d)
 123           break;                // early is deeper; keep him
 124         if (n2 == early ||      // Walked cin up to early
 125             dom_depth(n1) &lt; c_d) {
 126           early = cin;          // cin is deeper; keep him
 127           break;
 128         }
 129       }
 130       e_d = dom_depth(early);   // Reset depth register cache
 131     }
 132   }
 133 
 134   // Return earliest legal location
 135   assert(early == find_non_split_ctrl(early), &quot;unexpected early control&quot;);
 136 
 137   if (n-&gt;is_expensive() &amp;&amp; !_verify_only &amp;&amp; !_verify_me) {
 138     assert(n-&gt;in(0), &quot;should have control input&quot;);
 139     early = get_early_ctrl_for_expensive(n, early);
 140   }
 141 
 142   return early;
 143 }
 144 
 145 //------------------------------get_early_ctrl_for_expensive---------------------------------
 146 // Move node up the dominator tree as high as legal while still beneficial
 147 Node *PhaseIdealLoop::get_early_ctrl_for_expensive(Node *n, Node* earliest) {
 148   assert(n-&gt;in(0) &amp;&amp; n-&gt;is_expensive(), &quot;expensive node with control input here&quot;);
 149   assert(OptimizeExpensiveOps, &quot;optimization off?&quot;);
 150 
 151   Node* ctl = n-&gt;in(0);
 152   assert(ctl-&gt;is_CFG(), &quot;expensive input 0 must be cfg&quot;);
 153   uint min_dom_depth = dom_depth(earliest);
 154 #ifdef ASSERT
 155   if (!is_dominator(ctl, earliest) &amp;&amp; !is_dominator(earliest, ctl)) {
 156     dump_bad_graph(&quot;Bad graph detected in get_early_ctrl_for_expensive&quot;, n, earliest, ctl);
 157     assert(false, &quot;Bad graph detected in get_early_ctrl_for_expensive&quot;);
 158   }
 159 #endif
 160   if (dom_depth(ctl) &lt; min_dom_depth) {
 161     return earliest;
 162   }
 163 
 164   while (1) {
 165     Node *next = ctl;
 166     // Moving the node out of a loop on the projection of a If
 167     // confuses loop predication. So once we hit a Loop in a If branch
 168     // that doesn&#39;t branch to an UNC, we stop. The code that process
 169     // expensive nodes will notice the loop and skip over it to try to
 170     // move the node further up.
 171     if (ctl-&gt;is_CountedLoop() &amp;&amp; ctl-&gt;in(1) != NULL &amp;&amp; ctl-&gt;in(1)-&gt;in(0) != NULL &amp;&amp; ctl-&gt;in(1)-&gt;in(0)-&gt;is_If()) {
 172       if (!ctl-&gt;in(1)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none)) {
 173         break;
 174       }
 175       next = idom(ctl-&gt;in(1)-&gt;in(0));
 176     } else if (ctl-&gt;is_Proj()) {
 177       // We only move it up along a projection if the projection is
 178       // the single control projection for its parent: same code path,
 179       // if it&#39;s a If with UNC or fallthrough of a call.
 180       Node* parent_ctl = ctl-&gt;in(0);
 181       if (parent_ctl == NULL) {
 182         break;
 183       } else if (parent_ctl-&gt;is_CountedLoopEnd() &amp;&amp; parent_ctl-&gt;as_CountedLoopEnd()-&gt;loopnode() != NULL) {
 184         next = parent_ctl-&gt;as_CountedLoopEnd()-&gt;loopnode()-&gt;init_control();
 185       } else if (parent_ctl-&gt;is_If()) {
 186         if (!ctl-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none)) {
 187           break;
 188         }
 189         assert(idom(ctl) == parent_ctl, &quot;strange&quot;);
 190         next = idom(parent_ctl);
 191       } else if (ctl-&gt;is_CatchProj()) {
 192         if (ctl-&gt;as_Proj()-&gt;_con != CatchProjNode::fall_through_index) {
 193           break;
 194         }
 195         assert(parent_ctl-&gt;in(0)-&gt;in(0)-&gt;is_Call(), &quot;strange graph&quot;);
 196         next = parent_ctl-&gt;in(0)-&gt;in(0)-&gt;in(0);
 197       } else {
 198         // Check if parent control has a single projection (this
 199         // control is the only possible successor of the parent
 200         // control). If so, we can try to move the node above the
 201         // parent control.
 202         int nb_ctl_proj = 0;
 203         for (DUIterator_Fast imax, i = parent_ctl-&gt;fast_outs(imax); i &lt; imax; i++) {
 204           Node *p = parent_ctl-&gt;fast_out(i);
 205           if (p-&gt;is_Proj() &amp;&amp; p-&gt;is_CFG()) {
 206             nb_ctl_proj++;
 207             if (nb_ctl_proj &gt; 1) {
 208               break;
 209             }
 210           }
 211         }
 212 
 213         if (nb_ctl_proj &gt; 1) {
 214           break;
 215         }
 216         assert(parent_ctl-&gt;is_Start() || parent_ctl-&gt;is_MemBar() || parent_ctl-&gt;is_Call() ||
 217                BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;is_gc_barrier_node(parent_ctl), &quot;unexpected node&quot;);
 218         assert(idom(ctl) == parent_ctl, &quot;strange&quot;);
 219         next = idom(parent_ctl);
 220       }
 221     } else {
 222       next = idom(ctl);
 223     }
 224     if (next-&gt;is_Root() || next-&gt;is_Start() || dom_depth(next) &lt; min_dom_depth) {
 225       break;
 226     }
 227     ctl = next;
 228   }
 229 
 230   if (ctl != n-&gt;in(0)) {
 231     _igvn.replace_input_of(n, 0, ctl);
 232     _igvn.hash_insert(n);
 233   }
 234 
 235   return ctl;
 236 }
 237 
 238 
 239 //------------------------------set_early_ctrl---------------------------------
 240 // Set earliest legal control
 241 void PhaseIdealLoop::set_early_ctrl( Node *n ) {
 242   Node *early = get_early_ctrl(n);
 243 
 244   // Record earliest legal location
 245   set_ctrl(n, early);
 246 }
 247 
 248 //------------------------------set_subtree_ctrl-------------------------------
 249 // set missing _ctrl entries on new nodes
 250 void PhaseIdealLoop::set_subtree_ctrl( Node *n ) {
 251   // Already set?  Get out.
 252   if( _nodes[n-&gt;_idx] ) return;
 253   // Recursively set _nodes array to indicate where the Node goes
 254   uint i;
 255   for( i = 0; i &lt; n-&gt;req(); ++i ) {
 256     Node *m = n-&gt;in(i);
 257     if( m &amp;&amp; m != C-&gt;root() )
 258       set_subtree_ctrl( m );
 259   }
 260 
 261   // Fixup self
 262   set_early_ctrl( n );
 263 }
 264 
 265 // Create a skeleton strip mined outer loop: a Loop head before the
 266 // inner strip mined loop, a safepoint and an exit condition guarded
 267 // by an opaque node after the inner strip mined loop with a backedge
 268 // to the loop head. The inner strip mined loop is left as it is. Only
 269 // once loop optimizations are over, do we adjust the inner loop exit
 270 // condition to limit its number of iterations, set the outer loop
 271 // exit condition and add Phis to the outer loop head. Some loop
 272 // optimizations that operate on the inner strip mined loop need to be
 273 // aware of the outer strip mined loop: loop unswitching needs to
 274 // clone the outer loop as well as the inner, unrolling needs to only
 275 // clone the inner loop etc. No optimizations need to change the outer
 276 // strip mined loop as it is only a skeleton.
 277 IdealLoopTree* PhaseIdealLoop::create_outer_strip_mined_loop(BoolNode *test, Node *cmp, Node *init_control,
 278                                                              IdealLoopTree* loop, float cl_prob, float le_fcnt,
 279                                                              Node*&amp; entry_control, Node*&amp; iffalse) {
 280   Node* outer_test = _igvn.intcon(0);
 281   set_ctrl(outer_test, C-&gt;root());
 282   Node *orig = iffalse;
 283   iffalse = iffalse-&gt;clone();
 284   _igvn.register_new_node_with_optimizer(iffalse);
 285   set_idom(iffalse, idom(orig), dom_depth(orig));
 286 
 287   IfNode *outer_le = new OuterStripMinedLoopEndNode(iffalse, outer_test, cl_prob, le_fcnt);
 288   Node *outer_ift = new IfTrueNode (outer_le);
 289   Node* outer_iff = orig;
 290   _igvn.replace_input_of(outer_iff, 0, outer_le);
 291 
 292   LoopNode *outer_l = new OuterStripMinedLoopNode(C, init_control, outer_ift);
 293   entry_control = outer_l;
 294 
 295   IdealLoopTree* outer_ilt = new IdealLoopTree(this, outer_l, outer_ift);
 296   IdealLoopTree* parent = loop-&gt;_parent;
 297   IdealLoopTree* sibling = parent-&gt;_child;
 298   if (sibling == loop) {
 299     parent-&gt;_child = outer_ilt;
 300   } else {
 301     while (sibling-&gt;_next != loop) {
 302       sibling = sibling-&gt;_next;
 303     }
 304     sibling-&gt;_next = outer_ilt;
 305   }
 306   outer_ilt-&gt;_next = loop-&gt;_next;
 307   outer_ilt-&gt;_parent = parent;
 308   outer_ilt-&gt;_child = loop;
 309   outer_ilt-&gt;_nest = loop-&gt;_nest;
 310   loop-&gt;_parent = outer_ilt;
 311   loop-&gt;_next = NULL;
 312   loop-&gt;_nest++;
 313 
 314   set_loop(iffalse, outer_ilt);
 315   register_control(outer_le, outer_ilt, iffalse);
 316   register_control(outer_ift, outer_ilt, outer_le);
 317   set_idom(outer_iff, outer_le, dom_depth(outer_le));
 318   _igvn.register_new_node_with_optimizer(outer_l);
 319   set_loop(outer_l, outer_ilt);
 320   set_idom(outer_l, init_control, dom_depth(init_control)+1);
 321 
 322   return outer_ilt;
 323 }
 324 
 325 void PhaseIdealLoop::insert_loop_limit_check(ProjNode* limit_check_proj, Node* cmp_limit, Node* bol) {
 326   Node* new_predicate_proj = create_new_if_for_predicate(limit_check_proj, NULL,
 327                                                          Deoptimization::Reason_loop_limit_check,
 328                                                          Op_If);
 329   Node* iff = new_predicate_proj-&gt;in(0);
 330   assert(iff-&gt;Opcode() == Op_If, &quot;bad graph shape&quot;);
 331   Node* conv = iff-&gt;in(1);
 332   assert(conv-&gt;Opcode() == Op_Conv2B, &quot;bad graph shape&quot;);
 333   Node* opaq = conv-&gt;in(1);
 334   assert(opaq-&gt;Opcode() == Op_Opaque1, &quot;bad graph shape&quot;);
 335   cmp_limit = _igvn.register_new_node_with_optimizer(cmp_limit);
 336   bol = _igvn.register_new_node_with_optimizer(bol);
 337   set_subtree_ctrl(bol);
 338   _igvn.replace_input_of(iff, 1, bol);
 339 
 340 #ifndef PRODUCT
 341   // report that the loop predication has been actually performed
 342   // for this loop
 343   if (TraceLoopLimitCheck) {
 344     tty-&gt;print_cr(&quot;Counted Loop Limit Check generated:&quot;);
 345     debug_only( bol-&gt;dump(2); )
 346   }
 347 #endif
 348 }
 349 
 350 //------------------------------is_counted_loop--------------------------------
 351 bool PhaseIdealLoop::is_counted_loop(Node* x, IdealLoopTree*&amp; loop) {
 352   PhaseGVN *gvn = &amp;_igvn;
 353 
 354   // Counted loop head must be a good RegionNode with only 3 not NULL
 355   // control input edges: Self, Entry, LoopBack.
 356   if (x-&gt;in(LoopNode::Self) == NULL || x-&gt;req() != 3 || loop-&gt;_irreducible) {
 357     return false;
 358   }
 359   Node *init_control = x-&gt;in(LoopNode::EntryControl);
 360   Node *back_control = x-&gt;in(LoopNode::LoopBackControl);
 361   if (init_control == NULL || back_control == NULL)    // Partially dead
 362     return false;
 363   // Must also check for TOP when looking for a dead loop
 364   if (init_control-&gt;is_top() || back_control-&gt;is_top())
 365     return false;
 366 
 367   // Allow funny placement of Safepoint
 368   if (back_control-&gt;Opcode() == Op_SafePoint) {
 369     if (LoopStripMiningIter != 0) {
 370       // Leaving the safepoint on the backedge and creating a
 371       // CountedLoop will confuse optimizations. We can&#39;t move the
 372       // safepoint around because its jvm state wouldn&#39;t match a new
 373       // location. Give up on that loop.
 374       return false;
 375     }
 376     back_control = back_control-&gt;in(TypeFunc::Control);
 377   }
 378 
 379   // Controlling test for loop
 380   Node *iftrue = back_control;
 381   uint iftrue_op = iftrue-&gt;Opcode();
 382   if (iftrue_op != Op_IfTrue &amp;&amp;
 383       iftrue_op != Op_IfFalse)
 384     // I have a weird back-control.  Probably the loop-exit test is in
 385     // the middle of the loop and I am looking at some trailing control-flow
 386     // merge point.  To fix this I would have to partially peel the loop.
 387     return false; // Obscure back-control
 388 
 389   // Get boolean guarding loop-back test
 390   Node *iff = iftrue-&gt;in(0);
 391   if (get_loop(iff) != loop || !iff-&gt;in(1)-&gt;is_Bool())
 392     return false;
 393   BoolNode *test = iff-&gt;in(1)-&gt;as_Bool();
 394   BoolTest::mask bt = test-&gt;_test._test;
 395   float cl_prob = iff-&gt;as_If()-&gt;_prob;
 396   if (iftrue_op == Op_IfFalse) {
 397     bt = BoolTest(bt).negate();
 398     cl_prob = 1.0 - cl_prob;
 399   }
 400   // Get backedge compare
 401   Node *cmp = test-&gt;in(1);
 402   int cmp_op = cmp-&gt;Opcode();
 403   if (cmp_op != Op_CmpI)
 404     return false;                // Avoid pointer &amp; float compares
 405 
 406   // Find the trip-counter increment &amp; limit.  Limit must be loop invariant.
 407   Node *incr  = cmp-&gt;in(1);
 408   Node *limit = cmp-&gt;in(2);
 409 
 410   // ---------
 411   // need &#39;loop()&#39; test to tell if limit is loop invariant
 412   // ---------
 413 
 414   if (!is_member(loop, get_ctrl(incr))) { // Swapped trip counter and limit?
 415     Node *tmp = incr;            // Then reverse order into the CmpI
 416     incr = limit;
 417     limit = tmp;
 418     bt = BoolTest(bt).commute(); // And commute the exit test
 419   }
 420   if (is_member(loop, get_ctrl(limit))) // Limit must be loop-invariant
 421     return false;
 422   if (!is_member(loop, get_ctrl(incr))) // Trip counter must be loop-variant
 423     return false;
 424 
 425   Node* phi_incr = NULL;
 426   // Trip-counter increment must be commutative &amp; associative.
 427   if (incr-&gt;Opcode() == Op_CastII) {
 428     incr = incr-&gt;in(1);
 429   }
 430   if (incr-&gt;is_Phi()) {
 431     if (incr-&gt;as_Phi()-&gt;region() != x || incr-&gt;req() != 3)
 432       return false; // Not simple trip counter expression
 433     phi_incr = incr;
 434     incr = phi_incr-&gt;in(LoopNode::LoopBackControl); // Assume incr is on backedge of Phi
 435     if (!is_member(loop, get_ctrl(incr))) // Trip counter must be loop-variant
 436       return false;
 437   }
 438 
 439   Node* trunc1 = NULL;
 440   Node* trunc2 = NULL;
 441   const TypeInt* iv_trunc_t = NULL;
 442   Node* orig_incr = incr;
 443   if (!(incr = CountedLoopNode::match_incr_with_optional_truncation(incr, &amp;trunc1, &amp;trunc2, &amp;iv_trunc_t))) {
 444     return false; // Funny increment opcode
 445   }
 446   assert(incr-&gt;Opcode() == Op_AddI, &quot;wrong increment code&quot;);
 447 
 448   const TypeInt* limit_t = gvn-&gt;type(limit)-&gt;is_int();
 449   if (trunc1 != NULL) {
 450     // When there is a truncation, we must be sure that after the truncation
 451     // the trip counter will end up higher than the limit, otherwise we are looking
 452     // at an endless loop. Can happen with range checks.
 453 
 454     // Example:
 455     // int i = 0;
 456     // while (true)
 457     //    sum + = array[i];
 458     //    i++;
 459     //    i = i &amp;&amp; 0x7fff;
 460     //  }
 461     //
 462     // If the array is shorter than 0x8000 this exits through a AIOOB
 463     //  - Counted loop transformation is ok
 464     // If the array is longer then this is an endless loop
 465     //  - No transformation can be done.
 466 
 467     const TypeInt* incr_t = gvn-&gt;type(orig_incr)-&gt;is_int();
 468     if (limit_t-&gt;_hi &gt; incr_t-&gt;_hi) {
 469       // if the limit can have a higher value than the increment (before the phi)
 470       return false;
 471     }
 472   }
 473 
 474   // Get merge point
 475   Node *xphi = incr-&gt;in(1);
 476   Node *stride = incr-&gt;in(2);
 477   if (!stride-&gt;is_Con()) {     // Oops, swap these
 478     if (!xphi-&gt;is_Con())       // Is the other guy a constant?
 479       return false;             // Nope, unknown stride, bail out
 480     Node *tmp = xphi;           // &#39;incr&#39; is commutative, so ok to swap
 481     xphi = stride;
 482     stride = tmp;
 483   }
 484   if (xphi-&gt;Opcode() == Op_CastII) {
 485     xphi = xphi-&gt;in(1);
 486   }
 487   // Stride must be constant
 488   int stride_con = stride-&gt;get_int();
 489   if (stride_con == 0)
 490     return false; // missed some peephole opt
 491 
 492   if (!xphi-&gt;is_Phi())
 493     return false; // Too much math on the trip counter
 494   if (phi_incr != NULL &amp;&amp; phi_incr != xphi)
 495     return false;
 496   PhiNode *phi = xphi-&gt;as_Phi();
 497 
 498   // Phi must be of loop header; backedge must wrap to increment
 499   if (phi-&gt;region() != x)
 500     return false;
 501   if ((trunc1 == NULL &amp;&amp; phi-&gt;in(LoopNode::LoopBackControl) != incr) ||
 502       (trunc1 != NULL &amp;&amp; phi-&gt;in(LoopNode::LoopBackControl) != trunc1)) {
 503     return false;
 504   }
 505   Node *init_trip = phi-&gt;in(LoopNode::EntryControl);
 506 
 507   // If iv trunc type is smaller than int, check for possible wrap.
 508   if (!TypeInt::INT-&gt;higher_equal(iv_trunc_t)) {
 509     assert(trunc1 != NULL, &quot;must have found some truncation&quot;);
 510 
 511     // Get a better type for the phi (filtered thru if&#39;s)
 512     const TypeInt* phi_ft = filtered_type(phi);
 513 
 514     // Can iv take on a value that will wrap?
 515     //
 516     // Ensure iv&#39;s limit is not within &quot;stride&quot; of the wrap value.
 517     //
 518     // Example for &quot;short&quot; type
 519     //    Truncation ensures value is in the range -32768..32767 (iv_trunc_t)
 520     //    If the stride is +10, then the last value of the induction
 521     //    variable before the increment (phi_ft-&gt;_hi) must be
 522     //    &lt;= 32767 - 10 and (phi_ft-&gt;_lo) must be &gt;= -32768 to
 523     //    ensure no truncation occurs after the increment.
 524 
 525     if (stride_con &gt; 0) {
 526       if (iv_trunc_t-&gt;_hi - phi_ft-&gt;_hi &lt; stride_con ||
 527           iv_trunc_t-&gt;_lo &gt; phi_ft-&gt;_lo) {
 528         return false;  // truncation may occur
 529       }
 530     } else if (stride_con &lt; 0) {
 531       if (iv_trunc_t-&gt;_lo - phi_ft-&gt;_lo &gt; stride_con ||
 532           iv_trunc_t-&gt;_hi &lt; phi_ft-&gt;_hi) {
 533         return false;  // truncation may occur
 534       }
 535     }
 536     // No possibility of wrap so truncation can be discarded
 537     // Promote iv type to Int
 538   } else {
 539     assert(trunc1 == NULL &amp;&amp; trunc2 == NULL, &quot;no truncation for int&quot;);
 540   }
 541 
 542   // If the condition is inverted and we will be rolling
 543   // through MININT to MAXINT, then bail out.
 544   if (bt == BoolTest::eq || // Bail out, but this loop trips at most twice!
 545       // Odd stride
 546       (bt == BoolTest::ne &amp;&amp; stride_con != 1 &amp;&amp; stride_con != -1) ||
 547       // Count down loop rolls through MAXINT
 548       ((bt == BoolTest::le || bt == BoolTest::lt) &amp;&amp; stride_con &lt; 0) ||
 549       // Count up loop rolls through MININT
 550       ((bt == BoolTest::ge || bt == BoolTest::gt) &amp;&amp; stride_con &gt; 0)) {
 551     return false; // Bail out
 552   }
 553 
 554   const TypeInt* init_t = gvn-&gt;type(init_trip)-&gt;is_int();
 555 
 556   if (stride_con &gt; 0) {
 557     jlong init_p = (jlong)init_t-&gt;_lo + stride_con;
 558     if (init_p &gt; (jlong)max_jint || init_p &gt; (jlong)limit_t-&gt;_hi)
 559       return false; // cyclic loop or this loop trips only once
 560   } else {
 561     jlong init_p = (jlong)init_t-&gt;_hi + stride_con;
 562     if (init_p &lt; (jlong)min_jint || init_p &lt; (jlong)limit_t-&gt;_lo)
 563       return false; // cyclic loop or this loop trips only once
 564   }
 565 
 566   if (phi_incr != NULL &amp;&amp; bt != BoolTest::ne) {
 567     // check if there is a possiblity of IV overflowing after the first increment
 568     if (stride_con &gt; 0) {
 569       if (init_t-&gt;_hi &gt; max_jint - stride_con) {
 570         return false;
 571       }
 572     } else {
 573       if (init_t-&gt;_lo &lt; min_jint - stride_con) {
 574         return false;
 575       }
 576     }
 577   }
 578 
 579   // =================================================
 580   // ---- SUCCESS!   Found A Trip-Counted Loop!  -----
 581   //
 582   assert(x-&gt;Opcode() == Op_Loop, &quot;regular loops only&quot;);
 583   C-&gt;print_method(PHASE_BEFORE_CLOOPS, 3);
 584 
 585   Node *hook = new Node(6);
 586 
 587   // ===================================================
 588   // Generate loop limit check to avoid integer overflow
 589   // in cases like next (cyclic loops):
 590   //
 591   // for (i=0; i &lt;= max_jint; i++) {}
 592   // for (i=0; i &lt;  max_jint; i+=2) {}
 593   //
 594   //
 595   // Limit check predicate depends on the loop test:
 596   //
 597   // for(;i != limit; i++)       --&gt; limit &lt;= (max_jint)
 598   // for(;i &lt;  limit; i+=stride) --&gt; limit &lt;= (max_jint - stride + 1)
 599   // for(;i &lt;= limit; i+=stride) --&gt; limit &lt;= (max_jint - stride    )
 600   //
 601 
 602   // Check if limit is excluded to do more precise int overflow check.
 603   bool incl_limit = (bt == BoolTest::le || bt == BoolTest::ge);
 604   int stride_m  = stride_con - (incl_limit ? 0 : (stride_con &gt; 0 ? 1 : -1));
 605 
 606   // If compare points directly to the phi we need to adjust
 607   // the compare so that it points to the incr. Limit have
 608   // to be adjusted to keep trip count the same and the
 609   // adjusted limit should be checked for int overflow.
 610   if (phi_incr != NULL) {
 611     stride_m  += stride_con;
 612   }
 613 
 614   if (limit-&gt;is_Con()) {
 615     int limit_con = limit-&gt;get_int();
 616     if ((stride_con &gt; 0 &amp;&amp; limit_con &gt; (max_jint - stride_m)) ||
 617         (stride_con &lt; 0 &amp;&amp; limit_con &lt; (min_jint - stride_m))) {
 618       // Bailout: it could be integer overflow.
 619       return false;
 620     }
 621   } else if ((stride_con &gt; 0 &amp;&amp; limit_t-&gt;_hi &lt;= (max_jint - stride_m)) ||
 622              (stride_con &lt; 0 &amp;&amp; limit_t-&gt;_lo &gt;= (min_jint - stride_m))) {
 623       // Limit&#39;s type may satisfy the condition, for example,
 624       // when it is an array length.
 625   } else {
 626     // Generate loop&#39;s limit check.
 627     // Loop limit check predicate should be near the loop.
 628     ProjNode *limit_check_proj = find_predicate_insertion_point(init_control, Deoptimization::Reason_loop_limit_check);
 629     if (!limit_check_proj) {
 630       // The limit check predicate is not generated if this method trapped here before.
 631 #ifdef ASSERT
 632       if (TraceLoopLimitCheck) {
 633         tty-&gt;print(&quot;missing loop limit check:&quot;);
 634         loop-&gt;dump_head();
 635         x-&gt;dump(1);
 636       }
 637 #endif
 638       return false;
 639     }
 640 
 641     IfNode* check_iff = limit_check_proj-&gt;in(0)-&gt;as_If();
 642 
 643     if (!is_dominator(get_ctrl(limit), check_iff-&gt;in(0))) {
 644       return false;
 645     }
 646 
 647     Node* cmp_limit;
 648     Node* bol;
 649 
 650     if (stride_con &gt; 0) {
 651       cmp_limit = new CmpINode(limit, _igvn.intcon(max_jint - stride_m));
 652       bol = new BoolNode(cmp_limit, BoolTest::le);
 653     } else {
 654       cmp_limit = new CmpINode(limit, _igvn.intcon(min_jint - stride_m));
 655       bol = new BoolNode(cmp_limit, BoolTest::ge);
 656     }
 657 
 658     insert_loop_limit_check(limit_check_proj, cmp_limit, bol);
 659   }
 660 
 661   // Now we need to canonicalize loop condition.
 662   if (bt == BoolTest::ne) {
 663     assert(stride_con == 1 || stride_con == -1, &quot;simple increment only&quot;);
 664     if (stride_con &gt; 0 &amp;&amp; init_t-&gt;_hi &lt; limit_t-&gt;_lo) {
 665       // &#39;ne&#39; can be replaced with &#39;lt&#39; only when init &lt; limit.
 666       bt = BoolTest::lt;
 667     } else if (stride_con &lt; 0 &amp;&amp; init_t-&gt;_lo &gt; limit_t-&gt;_hi) {
 668       // &#39;ne&#39; can be replaced with &#39;gt&#39; only when init &gt; limit.
 669       bt = BoolTest::gt;
 670     } else {
 671       ProjNode *limit_check_proj = find_predicate_insertion_point(init_control, Deoptimization::Reason_loop_limit_check);
 672       if (!limit_check_proj) {
 673         // The limit check predicate is not generated if this method trapped here before.
 674 #ifdef ASSERT
 675         if (TraceLoopLimitCheck) {
 676           tty-&gt;print(&quot;missing loop limit check:&quot;);
 677           loop-&gt;dump_head();
 678           x-&gt;dump(1);
 679         }
 680 #endif
 681         return false;
 682       }
 683       IfNode* check_iff = limit_check_proj-&gt;in(0)-&gt;as_If();
 684 
 685       if (!is_dominator(get_ctrl(limit), check_iff-&gt;in(0)) ||
 686           !is_dominator(get_ctrl(init_trip), check_iff-&gt;in(0))) {
 687         return false;
 688       }
 689 
 690       Node* cmp_limit;
 691       Node* bol;
 692 
 693       if (stride_con &gt; 0) {
 694         cmp_limit = new CmpINode(init_trip, limit);
 695         bol = new BoolNode(cmp_limit, BoolTest::lt);
 696       } else {
 697         cmp_limit = new CmpINode(init_trip, limit);
 698         bol = new BoolNode(cmp_limit, BoolTest::gt);
 699       }
 700 
 701       insert_loop_limit_check(limit_check_proj, cmp_limit, bol);
 702 
 703       if (stride_con &gt; 0) {
 704         // &#39;ne&#39; can be replaced with &#39;lt&#39; only when init &lt; limit.
 705         bt = BoolTest::lt;
 706       } else if (stride_con &lt; 0) {
 707         // &#39;ne&#39; can be replaced with &#39;gt&#39; only when init &gt; limit.
 708         bt = BoolTest::gt;
 709       }
 710     }
 711   }
 712 
 713   if (phi_incr != NULL) {
 714     // If compare points directly to the phi we need to adjust
 715     // the compare so that it points to the incr. Limit have
 716     // to be adjusted to keep trip count the same and we
 717     // should avoid int overflow.
 718     //
 719     //   i = init; do {} while(i++ &lt; limit);
 720     // is converted to
 721     //   i = init; do {} while(++i &lt; limit+1);
 722     //
 723     limit = gvn-&gt;transform(new AddINode(limit, stride));
 724   }
 725 
 726   if (incl_limit) {
 727     // The limit check guaranties that &#39;limit &lt;= (max_jint - stride)&#39; so
 728     // we can convert &#39;i &lt;= limit&#39; to &#39;i &lt; limit+1&#39; since stride != 0.
 729     //
 730     Node* one = (stride_con &gt; 0) ? gvn-&gt;intcon( 1) : gvn-&gt;intcon(-1);
 731     limit = gvn-&gt;transform(new AddINode(limit, one));
 732     if (bt == BoolTest::le)
 733       bt = BoolTest::lt;
 734     else if (bt == BoolTest::ge)
 735       bt = BoolTest::gt;
 736     else
 737       ShouldNotReachHere();
 738   }
 739   set_subtree_ctrl( limit );
 740 
 741   if (LoopStripMiningIter == 0) {
 742     // Check for SafePoint on backedge and remove
 743     Node *sfpt = x-&gt;in(LoopNode::LoopBackControl);
 744     if (sfpt-&gt;Opcode() == Op_SafePoint &amp;&amp; is_deleteable_safept(sfpt)) {
 745       lazy_replace( sfpt, iftrue );
 746       if (loop-&gt;_safepts != NULL) {
 747         loop-&gt;_safepts-&gt;yank(sfpt);
 748       }
 749       loop-&gt;_tail = iftrue;
 750     }
 751   }
 752 
 753   // Build a canonical trip test.
 754   // Clone code, as old values may be in use.
 755   incr = incr-&gt;clone();
 756   incr-&gt;set_req(1,phi);
 757   incr-&gt;set_req(2,stride);
 758   incr = _igvn.register_new_node_with_optimizer(incr);
 759   set_early_ctrl( incr );
 760   _igvn.rehash_node_delayed(phi);
 761   phi-&gt;set_req_X( LoopNode::LoopBackControl, incr, &amp;_igvn );
 762 
 763   // If phi type is more restrictive than Int, raise to
 764   // Int to prevent (almost) infinite recursion in igvn
 765   // which can only handle integer types for constants or minint..maxint.
 766   if (!TypeInt::INT-&gt;higher_equal(phi-&gt;bottom_type())) {
 767     Node* nphi = PhiNode::make(phi-&gt;in(0), phi-&gt;in(LoopNode::EntryControl), TypeInt::INT);
 768     nphi-&gt;set_req(LoopNode::LoopBackControl, phi-&gt;in(LoopNode::LoopBackControl));
 769     nphi = _igvn.register_new_node_with_optimizer(nphi);
 770     set_ctrl(nphi, get_ctrl(phi));
 771     _igvn.replace_node(phi, nphi);
 772     phi = nphi-&gt;as_Phi();
 773   }
 774   cmp = cmp-&gt;clone();
 775   cmp-&gt;set_req(1,incr);
 776   cmp-&gt;set_req(2,limit);
 777   cmp = _igvn.register_new_node_with_optimizer(cmp);
 778   set_ctrl(cmp, iff-&gt;in(0));
 779 
 780   test = test-&gt;clone()-&gt;as_Bool();
 781   (*(BoolTest*)&amp;test-&gt;_test)._test = bt;
 782   test-&gt;set_req(1,cmp);
 783   _igvn.register_new_node_with_optimizer(test);
 784   set_ctrl(test, iff-&gt;in(0));
 785 
 786   // Replace the old IfNode with a new LoopEndNode
 787   Node *lex = _igvn.register_new_node_with_optimizer(new CountedLoopEndNode( iff-&gt;in(0), test, cl_prob, iff-&gt;as_If()-&gt;_fcnt ));
 788   IfNode *le = lex-&gt;as_If();
 789   uint dd = dom_depth(iff);
 790   set_idom(le, le-&gt;in(0), dd); // Update dominance for loop exit
 791   set_loop(le, loop);
 792 
 793   // Get the loop-exit control
 794   Node *iffalse = iff-&gt;as_If()-&gt;proj_out(!(iftrue_op == Op_IfTrue));
 795 
 796   // Need to swap loop-exit and loop-back control?
 797   if (iftrue_op == Op_IfFalse) {
 798     Node *ift2=_igvn.register_new_node_with_optimizer(new IfTrueNode (le));
 799     Node *iff2=_igvn.register_new_node_with_optimizer(new IfFalseNode(le));
 800 
 801     loop-&gt;_tail = back_control = ift2;
 802     set_loop(ift2, loop);
 803     set_loop(iff2, get_loop(iffalse));
 804 
 805     // Lazy update of &#39;get_ctrl&#39; mechanism.
 806     lazy_replace(iffalse, iff2);
 807     lazy_replace(iftrue,  ift2);
 808 
 809     // Swap names
 810     iffalse = iff2;
 811     iftrue  = ift2;
 812   } else {
 813     _igvn.rehash_node_delayed(iffalse);
 814     _igvn.rehash_node_delayed(iftrue);
 815     iffalse-&gt;set_req_X( 0, le, &amp;_igvn );
 816     iftrue -&gt;set_req_X( 0, le, &amp;_igvn );
 817   }
 818 
 819   set_idom(iftrue,  le, dd+1);
 820   set_idom(iffalse, le, dd+1);
 821   assert(iff-&gt;outcnt() == 0, &quot;should be dead now&quot;);
 822   lazy_replace( iff, le ); // fix &#39;get_ctrl&#39;
 823 
 824   Node *sfpt2 = le-&gt;in(0);
 825 
 826   Node* entry_control = init_control;
 827   bool strip_mine_loop = LoopStripMiningIter &gt; 1 &amp;&amp; loop-&gt;_child == NULL &amp;&amp;
 828     sfpt2-&gt;Opcode() == Op_SafePoint &amp;&amp; !loop-&gt;_has_call;
 829   IdealLoopTree* outer_ilt = NULL;
 830   if (strip_mine_loop) {
 831     outer_ilt = create_outer_strip_mined_loop(test, cmp, init_control, loop,
 832                                               cl_prob, le-&gt;_fcnt, entry_control,
 833                                               iffalse);
 834   }
 835 
 836   // Now setup a new CountedLoopNode to replace the existing LoopNode
 837   CountedLoopNode *l = new CountedLoopNode(entry_control, back_control);
 838   l-&gt;set_unswitch_count(x-&gt;as_Loop()-&gt;unswitch_count()); // Preserve
 839   // The following assert is approximately true, and defines the intention
 840   // of can_be_counted_loop.  It fails, however, because phase-&gt;type
 841   // is not yet initialized for this loop and its parts.
 842   //assert(l-&gt;can_be_counted_loop(this), &quot;sanity&quot;);
 843   _igvn.register_new_node_with_optimizer(l);
 844   set_loop(l, loop);
 845   loop-&gt;_head = l;
 846   // Fix all data nodes placed at the old loop head.
 847   // Uses the lazy-update mechanism of &#39;get_ctrl&#39;.
 848   lazy_replace( x, l );
 849   set_idom(l, entry_control, dom_depth(entry_control) + 1);
 850 
 851   if (LoopStripMiningIter == 0 || strip_mine_loop) {
 852     // Check for immediately preceding SafePoint and remove
 853     if (sfpt2-&gt;Opcode() == Op_SafePoint &amp;&amp; (LoopStripMiningIter != 0 || is_deleteable_safept(sfpt2))) {
 854       if (strip_mine_loop) {
 855         Node* outer_le = outer_ilt-&gt;_tail-&gt;in(0);
 856         Node* sfpt = sfpt2-&gt;clone();
 857         sfpt-&gt;set_req(0, iffalse);
 858         outer_le-&gt;set_req(0, sfpt);
 859         register_control(sfpt, outer_ilt, iffalse);
 860         set_idom(outer_le, sfpt, dom_depth(sfpt));
 861       }
 862       lazy_replace( sfpt2, sfpt2-&gt;in(TypeFunc::Control));
 863       if (loop-&gt;_safepts != NULL) {
 864         loop-&gt;_safepts-&gt;yank(sfpt2);
 865       }
 866     }
 867   }
 868 
 869   // Free up intermediate goo
 870   _igvn.remove_dead_node(hook);
 871 
 872 #ifdef ASSERT
 873   assert(l-&gt;is_valid_counted_loop(), &quot;counted loop shape is messed up&quot;);
 874   assert(l == loop-&gt;_head &amp;&amp; l-&gt;phi() == phi &amp;&amp; l-&gt;loopexit_or_null() == lex, &quot;&quot; );
 875 #endif
 876 #ifndef PRODUCT
 877   if (TraceLoopOpts) {
 878     tty-&gt;print(&quot;Counted      &quot;);
 879     loop-&gt;dump_head();
 880   }
 881 #endif
 882 
 883   C-&gt;print_method(PHASE_AFTER_CLOOPS, 3);
 884 
 885   // Capture bounds of the loop in the induction variable Phi before
 886   // subsequent transformation (iteration splitting) obscures the
 887   // bounds
 888   l-&gt;phi()-&gt;as_Phi()-&gt;set_type(l-&gt;phi()-&gt;Value(&amp;_igvn));
 889 
 890   if (strip_mine_loop) {
 891     l-&gt;mark_strip_mined();
 892     l-&gt;verify_strip_mined(1);
 893     outer_ilt-&gt;_head-&gt;as_Loop()-&gt;verify_strip_mined(1);
 894     loop = outer_ilt;
 895   }
 896 
 897   return true;
 898 }
 899 
 900 //----------------------exact_limit-------------------------------------------
 901 Node* PhaseIdealLoop::exact_limit( IdealLoopTree *loop ) {
 902   assert(loop-&gt;_head-&gt;is_CountedLoop(), &quot;&quot;);
 903   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
 904   assert(cl-&gt;is_valid_counted_loop(), &quot;&quot;);
 905 
 906   if (ABS(cl-&gt;stride_con()) == 1 ||
 907       cl-&gt;limit()-&gt;Opcode() == Op_LoopLimit) {
 908     // Old code has exact limit (it could be incorrect in case of int overflow).
 909     // Loop limit is exact with stride == 1. And loop may already have exact limit.
 910     return cl-&gt;limit();
 911   }
 912   Node *limit = NULL;
 913 #ifdef ASSERT
 914   BoolTest::mask bt = cl-&gt;loopexit()-&gt;test_trip();
 915   assert(bt == BoolTest::lt || bt == BoolTest::gt, &quot;canonical test is expected&quot;);
 916 #endif
 917   if (cl-&gt;has_exact_trip_count()) {
 918     // Simple case: loop has constant boundaries.
 919     // Use jlongs to avoid integer overflow.
 920     int stride_con = cl-&gt;stride_con();
 921     jlong  init_con = cl-&gt;init_trip()-&gt;get_int();
 922     jlong limit_con = cl-&gt;limit()-&gt;get_int();
 923     julong trip_cnt = cl-&gt;trip_count();
 924     jlong final_con = init_con + trip_cnt*stride_con;
 925     int final_int = (int)final_con;
 926     // The final value should be in integer range since the loop
 927     // is counted and the limit was checked for overflow.
 928     assert(final_con == (jlong)final_int, &quot;final value should be integer&quot;);
 929     limit = _igvn.intcon(final_int);
 930   } else {
 931     // Create new LoopLimit node to get exact limit (final iv value).
 932     limit = new LoopLimitNode(C, cl-&gt;init_trip(), cl-&gt;limit(), cl-&gt;stride());
 933     register_new_node(limit, cl-&gt;in(LoopNode::EntryControl));
 934   }
 935   assert(limit != NULL, &quot;sanity&quot;);
 936   return limit;
 937 }
 938 
 939 //------------------------------Ideal------------------------------------------
 940 // Return a node which is more &quot;ideal&quot; than the current node.
 941 // Attempt to convert into a counted-loop.
 942 Node *LoopNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 943   if (!can_be_counted_loop(phase) &amp;&amp; !is_OuterStripMinedLoop()) {
 944     phase-&gt;C-&gt;set_major_progress();
 945   }
 946   return RegionNode::Ideal(phase, can_reshape);
 947 }
 948 
 949 #ifdef ASSERT
 950 void LoopNode::verify_strip_mined(int expect_skeleton) const {
 951   const OuterStripMinedLoopNode* outer = NULL;
 952   const CountedLoopNode* inner = NULL;
 953   if (is_strip_mined()) {
 954     if (!is_valid_counted_loop()) {
 955       return; // Skip malformed counted loop
 956     }
 957     assert(is_CountedLoop(), &quot;no Loop should be marked strip mined&quot;);
 958     inner = as_CountedLoop();
 959     outer = inner-&gt;in(LoopNode::EntryControl)-&gt;as_OuterStripMinedLoop();
 960   } else if (is_OuterStripMinedLoop()) {
 961     outer = this-&gt;as_OuterStripMinedLoop();
 962     inner = outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop();
 963     assert(inner-&gt;is_valid_counted_loop() &amp;&amp; inner-&gt;is_strip_mined(), &quot;OuterStripMinedLoop should have been removed&quot;);
 964     assert(!is_strip_mined(), &quot;outer loop shouldn&#39;t be marked strip mined&quot;);
 965   }
 966   if (inner != NULL || outer != NULL) {
 967     assert(inner != NULL &amp;&amp; outer != NULL, &quot;missing loop in strip mined nest&quot;);
 968     Node* outer_tail = outer-&gt;in(LoopNode::LoopBackControl);
 969     Node* outer_le = outer_tail-&gt;in(0);
 970     assert(outer_le-&gt;Opcode() == Op_OuterStripMinedLoopEnd, &quot;tail of outer loop should be an If&quot;);
 971     Node* sfpt = outer_le-&gt;in(0);
 972     assert(sfpt-&gt;Opcode() == Op_SafePoint, &quot;where&#39;s the safepoint?&quot;);
 973     Node* inner_out = sfpt-&gt;in(0);
 974     if (inner_out-&gt;outcnt() != 1) {
 975       ResourceMark rm;
 976       Unique_Node_List wq;
 977 
 978       for (DUIterator_Fast imax, i = inner_out-&gt;fast_outs(imax); i &lt; imax; i++) {
 979         Node* u = inner_out-&gt;fast_out(i);
 980         if (u == sfpt) {
 981           continue;
 982         }
 983         wq.clear();
 984         wq.push(u);
 985         bool found_sfpt = false;
 986         for (uint next = 0; next &lt; wq.size() &amp;&amp; !found_sfpt; next++) {
 987           Node* n = wq.at(next);
 988           for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax &amp;&amp; !found_sfpt; i++) {
 989             Node* u = n-&gt;fast_out(i);
 990             if (u == sfpt) {
 991               found_sfpt = true;
 992             }
 993             if (!u-&gt;is_CFG()) {
 994               wq.push(u);
 995             }
 996           }
 997         }
 998         assert(found_sfpt, &quot;no node in loop that&#39;s not input to safepoint&quot;);
 999       }
1000     }
1001 
1002     CountedLoopEndNode* cle = inner_out-&gt;in(0)-&gt;as_CountedLoopEnd();
1003     assert(cle == inner-&gt;loopexit_or_null(), &quot;mismatch&quot;);
1004     bool has_skeleton = outer_le-&gt;in(1)-&gt;bottom_type()-&gt;singleton() &amp;&amp; outer_le-&gt;in(1)-&gt;bottom_type()-&gt;is_int()-&gt;get_con() == 0;
1005     if (has_skeleton) {
1006       assert(expect_skeleton == 1 || expect_skeleton == -1, &quot;unexpected skeleton node&quot;);
1007       assert(outer-&gt;outcnt() == 2, &quot;only phis&quot;);
1008     } else {
1009       assert(expect_skeleton == 0 || expect_skeleton == -1, &quot;no skeleton node?&quot;);
1010       uint phis = 0;
1011       for (DUIterator_Fast imax, i = inner-&gt;fast_outs(imax); i &lt; imax; i++) {
1012         Node* u = inner-&gt;fast_out(i);
1013         if (u-&gt;is_Phi()) {
1014           phis++;
1015         }
1016       }
1017       for (DUIterator_Fast imax, i = outer-&gt;fast_outs(imax); i &lt; imax; i++) {
1018         Node* u = outer-&gt;fast_out(i);
1019         assert(u == outer || u == inner || u-&gt;is_Phi(), &quot;nothing between inner and outer loop&quot;);
1020       }
1021       uint stores = 0;
1022       for (DUIterator_Fast imax, i = inner_out-&gt;fast_outs(imax); i &lt; imax; i++) {
1023         Node* u = inner_out-&gt;fast_out(i);
1024         if (u-&gt;is_Store()) {
1025           stores++;
1026         }
1027       }
1028       assert(outer-&gt;outcnt() &gt;= phis + 2 &amp;&amp; outer-&gt;outcnt() &lt;= phis + 2 + stores + 1, &quot;only phis&quot;);
1029     }
1030     assert(sfpt-&gt;outcnt() == 1, &quot;no data node&quot;);
1031     assert(outer_tail-&gt;outcnt() == 1 || !has_skeleton, &quot;no data node&quot;);
1032   }
1033 }
1034 #endif
1035 
1036 //=============================================================================
1037 //------------------------------Ideal------------------------------------------
1038 // Return a node which is more &quot;ideal&quot; than the current node.
1039 // Attempt to convert into a counted-loop.
1040 Node *CountedLoopNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1041   return RegionNode::Ideal(phase, can_reshape);
1042 }
1043 
1044 //------------------------------dump_spec--------------------------------------
1045 // Dump special per-node info
1046 #ifndef PRODUCT
1047 void CountedLoopNode::dump_spec(outputStream *st) const {
1048   LoopNode::dump_spec(st);
1049   if (stride_is_con()) {
1050     st-&gt;print(&quot;stride: %d &quot;,stride_con());
1051   }
1052   if (is_pre_loop ()) st-&gt;print(&quot;pre of N%d&quot; , _main_idx);
1053   if (is_main_loop()) st-&gt;print(&quot;main of N%d&quot;, _idx);
1054   if (is_post_loop()) st-&gt;print(&quot;post of N%d&quot;, _main_idx);
1055   if (is_strip_mined()) st-&gt;print(&quot; strip mined&quot;);
1056 }
1057 #endif
1058 
1059 //=============================================================================
1060 int CountedLoopEndNode::stride_con() const {
1061   return stride()-&gt;bottom_type()-&gt;is_int()-&gt;get_con();
1062 }
1063 
1064 //=============================================================================
1065 //------------------------------Value-----------------------------------------
1066 const Type* LoopLimitNode::Value(PhaseGVN* phase) const {
1067   const Type* init_t   = phase-&gt;type(in(Init));
1068   const Type* limit_t  = phase-&gt;type(in(Limit));
1069   const Type* stride_t = phase-&gt;type(in(Stride));
1070   // Either input is TOP ==&gt; the result is TOP
1071   if (init_t   == Type::TOP) return Type::TOP;
1072   if (limit_t  == Type::TOP) return Type::TOP;
1073   if (stride_t == Type::TOP) return Type::TOP;
1074 
1075   int stride_con = stride_t-&gt;is_int()-&gt;get_con();
1076   if (stride_con == 1)
1077     return NULL;  // Identity
1078 
1079   if (init_t-&gt;is_int()-&gt;is_con() &amp;&amp; limit_t-&gt;is_int()-&gt;is_con()) {
1080     // Use jlongs to avoid integer overflow.
1081     jlong init_con   =  init_t-&gt;is_int()-&gt;get_con();
1082     jlong limit_con  = limit_t-&gt;is_int()-&gt;get_con();
1083     int  stride_m   = stride_con - (stride_con &gt; 0 ? 1 : -1);
1084     jlong trip_count = (limit_con - init_con + stride_m)/stride_con;
1085     jlong final_con  = init_con + stride_con*trip_count;
1086     int final_int = (int)final_con;
1087     // The final value should be in integer range since the loop
1088     // is counted and the limit was checked for overflow.
1089     assert(final_con == (jlong)final_int, &quot;final value should be integer&quot;);
1090     return TypeInt::make(final_int);
1091   }
1092 
1093   return bottom_type(); // TypeInt::INT
1094 }
1095 
1096 //------------------------------Ideal------------------------------------------
1097 // Return a node which is more &quot;ideal&quot; than the current node.
1098 Node *LoopLimitNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1099   if (phase-&gt;type(in(Init))   == Type::TOP ||
1100       phase-&gt;type(in(Limit))  == Type::TOP ||
1101       phase-&gt;type(in(Stride)) == Type::TOP)
1102     return NULL;  // Dead
1103 
1104   int stride_con = phase-&gt;type(in(Stride))-&gt;is_int()-&gt;get_con();
1105   if (stride_con == 1)
1106     return NULL;  // Identity
1107 
1108   if (in(Init)-&gt;is_Con() &amp;&amp; in(Limit)-&gt;is_Con())
1109     return NULL;  // Value
1110 
1111   // Delay following optimizations until all loop optimizations
1112   // done to keep Ideal graph simple.
1113   if (!can_reshape || phase-&gt;C-&gt;major_progress())
1114     return NULL;
1115 
1116   const TypeInt* init_t  = phase-&gt;type(in(Init) )-&gt;is_int();
1117   const TypeInt* limit_t = phase-&gt;type(in(Limit))-&gt;is_int();
1118   int stride_p;
1119   jlong lim, ini;
1120   julong max;
1121   if (stride_con &gt; 0) {
1122     stride_p = stride_con;
1123     lim = limit_t-&gt;_hi;
1124     ini = init_t-&gt;_lo;
1125     max = (julong)max_jint;
1126   } else {
1127     stride_p = -stride_con;
1128     lim = init_t-&gt;_hi;
1129     ini = limit_t-&gt;_lo;
1130     max = (julong)min_jint;
1131   }
1132   julong range = lim - ini + stride_p;
1133   if (range &lt;= max) {
1134     // Convert to integer expression if it is not overflow.
1135     Node* stride_m = phase-&gt;intcon(stride_con - (stride_con &gt; 0 ? 1 : -1));
1136     Node *range = phase-&gt;transform(new SubINode(in(Limit), in(Init)));
1137     Node *bias  = phase-&gt;transform(new AddINode(range, stride_m));
1138     Node *trip  = phase-&gt;transform(new DivINode(0, bias, in(Stride)));
1139     Node *span  = phase-&gt;transform(new MulINode(trip, in(Stride)));
1140     return new AddINode(span, in(Init)); // exact limit
1141   }
1142 
1143   if (is_power_of_2(stride_p) ||                // divisor is 2^n
1144       !Matcher::has_match_rule(Op_LoopLimit)) { // or no specialized Mach node?
1145     // Convert to long expression to avoid integer overflow
1146     // and let igvn optimizer convert this division.
1147     //
1148     Node*   init   = phase-&gt;transform( new ConvI2LNode(in(Init)));
1149     Node*  limit   = phase-&gt;transform( new ConvI2LNode(in(Limit)));
1150     Node* stride   = phase-&gt;longcon(stride_con);
1151     Node* stride_m = phase-&gt;longcon(stride_con - (stride_con &gt; 0 ? 1 : -1));
1152 
1153     Node *range = phase-&gt;transform(new SubLNode(limit, init));
1154     Node *bias  = phase-&gt;transform(new AddLNode(range, stride_m));
1155     Node *span;
1156     if (stride_con &gt; 0 &amp;&amp; is_power_of_2(stride_p)) {
1157       // bias &gt;= 0 if stride &gt;0, so if stride is 2^n we can use &amp;(-stride)
1158       // and avoid generating rounding for division. Zero trip guard should
1159       // guarantee that init &lt; limit but sometimes the guard is missing and
1160       // we can get situation when init &gt; limit. Note, for the empty loop
1161       // optimization zero trip guard is generated explicitly which leaves
1162       // only RCE predicate where exact limit is used and the predicate
1163       // will simply fail forcing recompilation.
1164       Node* neg_stride   = phase-&gt;longcon(-stride_con);
1165       span = phase-&gt;transform(new AndLNode(bias, neg_stride));
1166     } else {
1167       Node *trip  = phase-&gt;transform(new DivLNode(0, bias, stride));
1168       span = phase-&gt;transform(new MulLNode(trip, stride));
1169     }
1170     // Convert back to int
1171     Node *span_int = phase-&gt;transform(new ConvL2INode(span));
1172     return new AddINode(span_int, in(Init)); // exact limit
1173   }
1174 
1175   return NULL;    // No progress
1176 }
1177 
1178 //------------------------------Identity---------------------------------------
1179 // If stride == 1 return limit node.
1180 Node* LoopLimitNode::Identity(PhaseGVN* phase) {
1181   int stride_con = phase-&gt;type(in(Stride))-&gt;is_int()-&gt;get_con();
1182   if (stride_con == 1 || stride_con == -1)
1183     return in(Limit);
1184   return this;
1185 }
1186 
1187 //=============================================================================
1188 //----------------------match_incr_with_optional_truncation--------------------
1189 // Match increment with optional truncation:
1190 // CHAR: (i+1)&amp;0x7fff, BYTE: ((i+1)&lt;&lt;8)&gt;&gt;8, or SHORT: ((i+1)&lt;&lt;16)&gt;&gt;16
1191 // Return NULL for failure. Success returns the increment node.
1192 Node* CountedLoopNode::match_incr_with_optional_truncation(
1193                       Node* expr, Node** trunc1, Node** trunc2, const TypeInt** trunc_type) {
1194   // Quick cutouts:
1195   if (expr == NULL || expr-&gt;req() != 3)  return NULL;
1196 
1197   Node *t1 = NULL;
1198   Node *t2 = NULL;
1199   const TypeInt* trunc_t = TypeInt::INT;
1200   Node* n1 = expr;
1201   int   n1op = n1-&gt;Opcode();
1202 
1203   // Try to strip (n1 &amp; M) or (n1 &lt;&lt; N &gt;&gt; N) from n1.
1204   if (n1op == Op_AndI &amp;&amp;
1205       n1-&gt;in(2)-&gt;is_Con() &amp;&amp;
1206       n1-&gt;in(2)-&gt;bottom_type()-&gt;is_int()-&gt;get_con() == 0x7fff) {
1207     // %%% This check should match any mask of 2**K-1.
1208     t1 = n1;
1209     n1 = t1-&gt;in(1);
1210     n1op = n1-&gt;Opcode();
1211     trunc_t = TypeInt::CHAR;
1212   } else if (n1op == Op_RShiftI &amp;&amp;
1213              n1-&gt;in(1) != NULL &amp;&amp;
1214              n1-&gt;in(1)-&gt;Opcode() == Op_LShiftI &amp;&amp;
1215              n1-&gt;in(2) == n1-&gt;in(1)-&gt;in(2) &amp;&amp;
1216              n1-&gt;in(2)-&gt;is_Con()) {
1217     jint shift = n1-&gt;in(2)-&gt;bottom_type()-&gt;is_int()-&gt;get_con();
1218     // %%% This check should match any shift in [1..31].
1219     if (shift == 16 || shift == 8) {
1220       t1 = n1;
1221       t2 = t1-&gt;in(1);
1222       n1 = t2-&gt;in(1);
1223       n1op = n1-&gt;Opcode();
1224       if (shift == 16) {
1225         trunc_t = TypeInt::SHORT;
1226       } else if (shift == 8) {
1227         trunc_t = TypeInt::BYTE;
1228       }
1229     }
1230   }
1231 
1232   // If (maybe after stripping) it is an AddI, we won:
1233   if (n1op == Op_AddI) {
1234     *trunc1 = t1;
1235     *trunc2 = t2;
1236     *trunc_type = trunc_t;
1237     return n1;
1238   }
1239 
1240   // failed
1241   return NULL;
1242 }
1243 
1244 LoopNode* CountedLoopNode::skip_strip_mined(int expect_skeleton) {
1245   if (is_strip_mined() &amp;&amp; is_valid_counted_loop()) {
1246     verify_strip_mined(expect_skeleton);
1247     return in(EntryControl)-&gt;as_Loop();
1248   }
1249   return this;
1250 }
1251 
1252 OuterStripMinedLoopNode* CountedLoopNode::outer_loop() const {
1253   assert(is_strip_mined(), &quot;not a strip mined loop&quot;);
1254   Node* c = in(EntryControl);
1255   if (c == NULL || c-&gt;is_top() || !c-&gt;is_OuterStripMinedLoop()) {
1256     return NULL;
1257   }
1258   return c-&gt;as_OuterStripMinedLoop();
1259 }
1260 
1261 IfTrueNode* OuterStripMinedLoopNode::outer_loop_tail() const {
1262   Node* c = in(LoopBackControl);
1263   if (c == NULL || c-&gt;is_top()) {
1264     return NULL;
1265   }
1266   return c-&gt;as_IfTrue();
1267 }
1268 
1269 IfTrueNode* CountedLoopNode::outer_loop_tail() const {
1270   LoopNode* l = outer_loop();
1271   if (l == NULL) {
1272     return NULL;
1273   }
1274   return l-&gt;outer_loop_tail();
1275 }
1276 
1277 OuterStripMinedLoopEndNode* OuterStripMinedLoopNode::outer_loop_end() const {
1278   IfTrueNode* proj = outer_loop_tail();
1279   if (proj == NULL) {
1280     return NULL;
1281   }
1282   Node* c = proj-&gt;in(0);
1283   if (c == NULL || c-&gt;is_top() || c-&gt;outcnt() != 2) {
1284     return NULL;
1285   }
1286   return c-&gt;as_OuterStripMinedLoopEnd();
1287 }
1288 
1289 OuterStripMinedLoopEndNode* CountedLoopNode::outer_loop_end() const {
1290   LoopNode* l = outer_loop();
1291   if (l == NULL) {
1292     return NULL;
1293   }
1294   return l-&gt;outer_loop_end();
1295 }
1296 
1297 IfFalseNode* OuterStripMinedLoopNode::outer_loop_exit() const {
1298   IfNode* le = outer_loop_end();
1299   if (le == NULL) {
1300     return NULL;
1301   }
1302   Node* c = le-&gt;proj_out_or_null(false);
1303   if (c == NULL) {
1304     return NULL;
1305   }
1306   return c-&gt;as_IfFalse();
1307 }
1308 
1309 IfFalseNode* CountedLoopNode::outer_loop_exit() const {
1310   LoopNode* l = outer_loop();
1311   if (l == NULL) {
1312     return NULL;
1313   }
1314   return l-&gt;outer_loop_exit();
1315 }
1316 
1317 SafePointNode* OuterStripMinedLoopNode::outer_safepoint() const {
1318   IfNode* le = outer_loop_end();
1319   if (le == NULL) {
1320     return NULL;
1321   }
1322   Node* c = le-&gt;in(0);
1323   if (c == NULL || c-&gt;is_top()) {
1324     return NULL;
1325   }
1326   assert(c-&gt;Opcode() == Op_SafePoint, &quot;broken outer loop&quot;);
1327   return c-&gt;as_SafePoint();
1328 }
1329 
1330 SafePointNode* CountedLoopNode::outer_safepoint() const {
1331   LoopNode* l = outer_loop();
1332   if (l == NULL) {
1333     return NULL;
1334   }
1335   return l-&gt;outer_safepoint();
1336 }
1337 
1338 Node* CountedLoopNode::skip_predicates_from_entry(Node* ctrl) {
1339     while (ctrl != NULL &amp;&amp; ctrl-&gt;is_Proj() &amp;&amp; ctrl-&gt;in(0)-&gt;is_If() &amp;&amp;
1340            ctrl-&gt;in(0)-&gt;as_If()-&gt;proj_out(1-ctrl-&gt;as_Proj()-&gt;_con)-&gt;outcnt() == 1 &amp;&amp;
1341            ctrl-&gt;in(0)-&gt;as_If()-&gt;proj_out(1-ctrl-&gt;as_Proj()-&gt;_con)-&gt;unique_out()-&gt;Opcode() == Op_Halt) {
1342       ctrl = ctrl-&gt;in(0)-&gt;in(0);
1343     }
1344 
1345     return ctrl;
1346   }
1347 
1348 Node* CountedLoopNode::skip_predicates() {
1349   if (is_main_loop()) {
1350     Node* ctrl = skip_strip_mined()-&gt;in(LoopNode::EntryControl);
1351 
1352     return skip_predicates_from_entry(ctrl);
1353   }
1354   return in(LoopNode::EntryControl);
1355 }
1356 
1357 void OuterStripMinedLoopNode::adjust_strip_mined_loop(PhaseIterGVN* igvn) {
1358   // Look for the outer &amp; inner strip mined loop, reduce number of
1359   // iterations of the inner loop, set exit condition of outer loop,
1360   // construct required phi nodes for outer loop.
1361   CountedLoopNode* inner_cl = unique_ctrl_out()-&gt;as_CountedLoop();
1362   assert(inner_cl-&gt;is_strip_mined(), &quot;inner loop should be strip mined&quot;);
1363   Node* inner_iv_phi = inner_cl-&gt;phi();
1364   if (inner_iv_phi == NULL) {
1365     IfNode* outer_le = outer_loop_end();
1366     Node* iff = igvn-&gt;transform(new IfNode(outer_le-&gt;in(0), outer_le-&gt;in(1), outer_le-&gt;_prob, outer_le-&gt;_fcnt));
1367     igvn-&gt;replace_node(outer_le, iff);
1368     inner_cl-&gt;clear_strip_mined();
1369     return;
1370   }
1371   CountedLoopEndNode* inner_cle = inner_cl-&gt;loopexit();
1372 
1373   int stride = inner_cl-&gt;stride_con();
1374   jlong scaled_iters_long = ((jlong)LoopStripMiningIter) * ABS(stride);
1375   int scaled_iters = (int)scaled_iters_long;
1376   int short_scaled_iters = LoopStripMiningIterShortLoop* ABS(stride);
1377   const TypeInt* inner_iv_t = igvn-&gt;type(inner_iv_phi)-&gt;is_int();
1378   jlong iter_estimate = (jlong)inner_iv_t-&gt;_hi - (jlong)inner_iv_t-&gt;_lo;
1379   assert(iter_estimate &gt; 0, &quot;broken&quot;);
1380   if ((jlong)scaled_iters != scaled_iters_long || iter_estimate &lt;= short_scaled_iters) {
1381     // Remove outer loop and safepoint (too few iterations)
1382     Node* outer_sfpt = outer_safepoint();
1383     Node* outer_out = outer_loop_exit();
1384     igvn-&gt;replace_node(outer_out, outer_sfpt-&gt;in(0));
1385     igvn-&gt;replace_input_of(outer_sfpt, 0, igvn-&gt;C-&gt;top());
1386     inner_cl-&gt;clear_strip_mined();
1387     return;
1388   }
1389   if (iter_estimate &lt;= scaled_iters_long) {
1390     // We would only go through one iteration of
1391     // the outer loop: drop the outer loop but
1392     // keep the safepoint so we don&#39;t run for
1393     // too long without a safepoint
1394     IfNode* outer_le = outer_loop_end();
1395     Node* iff = igvn-&gt;transform(new IfNode(outer_le-&gt;in(0), outer_le-&gt;in(1), outer_le-&gt;_prob, outer_le-&gt;_fcnt));
1396     igvn-&gt;replace_node(outer_le, iff);
1397     inner_cl-&gt;clear_strip_mined();
1398     return;
1399   }
1400 
1401   Node* cle_tail = inner_cle-&gt;proj_out(true);
1402   ResourceMark rm;
1403   Node_List old_new;
1404   if (cle_tail-&gt;outcnt() &gt; 1) {
1405     // Look for nodes on backedge of inner loop and clone them
1406     Unique_Node_List backedge_nodes;
1407     for (DUIterator_Fast imax, i = cle_tail-&gt;fast_outs(imax); i &lt; imax; i++) {
1408       Node* u = cle_tail-&gt;fast_out(i);
1409       if (u != inner_cl) {
1410         assert(!u-&gt;is_CFG(), &quot;control flow on the backedge?&quot;);
1411         backedge_nodes.push(u);
1412       }
1413     }
1414     uint last = igvn-&gt;C-&gt;unique();
1415     for (uint next = 0; next &lt; backedge_nodes.size(); next++) {
1416       Node* n = backedge_nodes.at(next);
1417       old_new.map(n-&gt;_idx, n-&gt;clone());
1418       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1419         Node* u = n-&gt;fast_out(i);
1420         assert(!u-&gt;is_CFG(), &quot;broken&quot;);
1421         if (u-&gt;_idx &gt;= last) {
1422           continue;
1423         }
1424         if (!u-&gt;is_Phi()) {
1425           backedge_nodes.push(u);
1426         } else {
1427           assert(u-&gt;in(0) == inner_cl, &quot;strange phi on the backedge&quot;);
1428         }
1429       }
1430     }
1431     // Put the clones on the outer loop backedge
1432     Node* le_tail = outer_loop_tail();
1433     for (uint next = 0; next &lt; backedge_nodes.size(); next++) {
1434       Node *n = old_new[backedge_nodes.at(next)-&gt;_idx];
1435       for (uint i = 1; i &lt; n-&gt;req(); i++) {
1436         if (n-&gt;in(i) != NULL &amp;&amp; old_new[n-&gt;in(i)-&gt;_idx] != NULL) {
1437           n-&gt;set_req(i, old_new[n-&gt;in(i)-&gt;_idx]);
1438         }
1439       }
1440       if (n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0) == cle_tail) {
1441         n-&gt;set_req(0, le_tail);
1442       }
1443       igvn-&gt;register_new_node_with_optimizer(n);
1444     }
1445   }
1446 
1447   Node* iv_phi = NULL;
1448   // Make a clone of each phi in the inner loop
1449   // for the outer loop
1450   for (uint i = 0; i &lt; inner_cl-&gt;outcnt(); i++) {
1451     Node* u = inner_cl-&gt;raw_out(i);
1452     if (u-&gt;is_Phi()) {
1453       assert(u-&gt;in(0) == inner_cl, &quot;inconsistent&quot;);
1454       Node* phi = u-&gt;clone();
1455       phi-&gt;set_req(0, this);
1456       Node* be = old_new[phi-&gt;in(LoopNode::LoopBackControl)-&gt;_idx];
1457       if (be != NULL) {
1458         phi-&gt;set_req(LoopNode::LoopBackControl, be);
1459       }
1460       phi = igvn-&gt;transform(phi);
1461       igvn-&gt;replace_input_of(u, LoopNode::EntryControl, phi);
1462       if (u == inner_iv_phi) {
1463         iv_phi = phi;
1464       }
1465     }
1466   }
1467   Node* cle_out = inner_cle-&gt;proj_out(false);
1468   if (cle_out-&gt;outcnt() &gt; 1) {
1469     // Look for chains of stores that were sunk
1470     // out of the inner loop and are in the outer loop
1471     for (DUIterator_Fast imax, i = cle_out-&gt;fast_outs(imax); i &lt; imax; i++) {
1472       Node* u = cle_out-&gt;fast_out(i);
1473       if (u-&gt;is_Store()) {
1474         Node* first = u;
1475         for(;;) {
1476           Node* next = first-&gt;in(MemNode::Memory);
1477           if (!next-&gt;is_Store() || next-&gt;in(0) != cle_out) {
1478             break;
1479           }
1480           first = next;
1481         }
1482         Node* last = u;
1483         for(;;) {
1484           Node* next = NULL;
1485           for (DUIterator_Fast jmax, j = last-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1486             Node* uu = last-&gt;fast_out(j);
1487             if (uu-&gt;is_Store() &amp;&amp; uu-&gt;in(0) == cle_out) {
1488               assert(next == NULL, &quot;only one in the outer loop&quot;);
1489               next = uu;
1490             }
1491           }
1492           if (next == NULL) {
1493             break;
1494           }
1495           last = next;
1496         }
1497         Node* phi = NULL;
1498         for (DUIterator_Fast jmax, j = fast_outs(jmax); j &lt; jmax; j++) {
1499           Node* uu = fast_out(j);
1500           if (uu-&gt;is_Phi()) {
1501             Node* be = uu-&gt;in(LoopNode::LoopBackControl);
1502             if (be-&gt;is_Store() &amp;&amp; old_new[be-&gt;_idx] != NULL) {
1503               assert(false, &quot;store on the backedge + sunk stores: unsupported&quot;);
1504               // drop outer loop
1505               IfNode* outer_le = outer_loop_end();
1506               Node* iff = igvn-&gt;transform(new IfNode(outer_le-&gt;in(0), outer_le-&gt;in(1), outer_le-&gt;_prob, outer_le-&gt;_fcnt));
1507               igvn-&gt;replace_node(outer_le, iff);
1508               inner_cl-&gt;clear_strip_mined();
1509               return;
1510             }
1511             if (be == last || be == first-&gt;in(MemNode::Memory)) {
1512               assert(phi == NULL, &quot;only one phi&quot;);
1513               phi = uu;
1514             }
1515           }
1516         }
1517 #ifdef ASSERT
1518         for (DUIterator_Fast jmax, j = fast_outs(jmax); j &lt; jmax; j++) {
1519           Node* uu = fast_out(j);
1520           if (uu-&gt;is_Phi() &amp;&amp; uu-&gt;bottom_type() == Type::MEMORY) {
1521             if (uu-&gt;adr_type() == igvn-&gt;C-&gt;get_adr_type(igvn-&gt;C-&gt;get_alias_index(u-&gt;adr_type()))) {
1522               assert(phi == uu, &quot;what&#39;s that phi?&quot;);
1523             } else if (uu-&gt;adr_type() == TypePtr::BOTTOM) {
1524               Node* n = uu-&gt;in(LoopNode::LoopBackControl);
1525               uint limit = igvn-&gt;C-&gt;live_nodes();
1526               uint i = 0;
1527               while (n != uu) {
1528                 i++;
1529                 assert(i &lt; limit, &quot;infinite loop&quot;);
1530                 if (n-&gt;is_Proj()) {
1531                   n = n-&gt;in(0);
1532                 } else if (n-&gt;is_SafePoint() || n-&gt;is_MemBar()) {
1533                   n = n-&gt;in(TypeFunc::Memory);
1534                 } else if (n-&gt;is_Phi()) {
1535                   n = n-&gt;in(1);
1536                 } else if (n-&gt;is_MergeMem()) {
1537                   n = n-&gt;as_MergeMem()-&gt;memory_at(igvn-&gt;C-&gt;get_alias_index(u-&gt;adr_type()));
1538                 } else if (n-&gt;is_Store() || n-&gt;is_LoadStore() || n-&gt;is_ClearArray()) {
1539                   n = n-&gt;in(MemNode::Memory);
1540                 } else {
1541                   n-&gt;dump();
1542                   ShouldNotReachHere();
1543                 }
1544               }
1545             }
1546           }
1547         }
1548 #endif
1549         if (phi == NULL) {
1550           // If the an entire chains was sunk, the
1551           // inner loop has no phi for that memory
1552           // slice, create one for the outer loop
1553           phi = PhiNode::make(this, first-&gt;in(MemNode::Memory), Type::MEMORY,
1554                               igvn-&gt;C-&gt;get_adr_type(igvn-&gt;C-&gt;get_alias_index(u-&gt;adr_type())));
1555           phi-&gt;set_req(LoopNode::LoopBackControl, last);
1556           phi = igvn-&gt;transform(phi);
1557           igvn-&gt;replace_input_of(first, MemNode::Memory, phi);
1558         } else {
1559           // Or fix the outer loop fix to include
1560           // that chain of stores.
1561           Node* be = phi-&gt;in(LoopNode::LoopBackControl);
1562           assert(!(be-&gt;is_Store() &amp;&amp; old_new[be-&gt;_idx] != NULL), &quot;store on the backedge + sunk stores: unsupported&quot;);
1563           if (be == first-&gt;in(MemNode::Memory)) {
1564             if (be == phi-&gt;in(LoopNode::LoopBackControl)) {
1565               igvn-&gt;replace_input_of(phi, LoopNode::LoopBackControl, last);
1566             } else {
1567               igvn-&gt;replace_input_of(be, MemNode::Memory, last);
1568             }
1569           } else {
1570 #ifdef ASSERT
1571             if (be == phi-&gt;in(LoopNode::LoopBackControl)) {
1572               assert(phi-&gt;in(LoopNode::LoopBackControl) == last, &quot;&quot;);
1573             } else {
1574               assert(be-&gt;in(MemNode::Memory) == last, &quot;&quot;);
1575             }
1576 #endif
1577           }
1578         }
1579       }
1580     }
1581   }
1582 
1583   if (iv_phi != NULL) {
1584     // Now adjust the inner loop&#39;s exit condition
1585     Node* limit = inner_cl-&gt;limit();
1586     Node* sub = NULL;
1587     if (stride &gt; 0) {
1588       sub = igvn-&gt;transform(new SubINode(limit, iv_phi));
1589     } else {
1590       sub = igvn-&gt;transform(new SubINode(iv_phi, limit));
1591     }
1592     Node* min = igvn-&gt;transform(new MinINode(sub, igvn-&gt;intcon(scaled_iters)));
1593     Node* new_limit = NULL;
1594     if (stride &gt; 0) {
1595       new_limit = igvn-&gt;transform(new AddINode(min, iv_phi));
1596     } else {
1597       new_limit = igvn-&gt;transform(new SubINode(iv_phi, min));
1598     }
1599     Node* inner_cmp = inner_cle-&gt;cmp_node();
1600     Node* inner_bol = inner_cle-&gt;in(CountedLoopEndNode::TestValue);
1601     Node* outer_bol = inner_bol;
1602     // cmp node for inner loop may be shared
1603     inner_cmp = inner_cmp-&gt;clone();
1604     inner_cmp-&gt;set_req(2, new_limit);
1605     inner_bol = inner_bol-&gt;clone();
1606     inner_bol-&gt;set_req(1, igvn-&gt;transform(inner_cmp));
1607     igvn-&gt;replace_input_of(inner_cle, CountedLoopEndNode::TestValue, igvn-&gt;transform(inner_bol));
1608     // Set the outer loop&#39;s exit condition too
1609     igvn-&gt;replace_input_of(outer_loop_end(), 1, outer_bol);
1610   } else {
1611     assert(false, &quot;should be able to adjust outer loop&quot;);
1612     IfNode* outer_le = outer_loop_end();
1613     Node* iff = igvn-&gt;transform(new IfNode(outer_le-&gt;in(0), outer_le-&gt;in(1), outer_le-&gt;_prob, outer_le-&gt;_fcnt));
1614     igvn-&gt;replace_node(outer_le, iff);
1615     inner_cl-&gt;clear_strip_mined();
1616   }
1617 }
1618 
1619 const Type* OuterStripMinedLoopEndNode::Value(PhaseGVN* phase) const {
1620   if (!in(0)) return Type::TOP;
1621   if (phase-&gt;type(in(0)) == Type::TOP)
1622     return Type::TOP;
1623 
1624   return TypeTuple::IFBOTH;
1625 }
1626 
1627 Node *OuterStripMinedLoopEndNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1628   if (remove_dead_region(phase, can_reshape))  return this;
1629 
1630   return NULL;
1631 }
1632 
1633 //------------------------------filtered_type--------------------------------
1634 // Return a type based on condition control flow
1635 // A successful return will be a type that is restricted due
1636 // to a series of dominating if-tests, such as:
1637 //    if (i &lt; 10) {
1638 //       if (i &gt; 0) {
1639 //          here: &quot;i&quot; type is [1..10)
1640 //       }
1641 //    }
1642 // or a control flow merge
1643 //    if (i &lt; 10) {
1644 //       do {
1645 //          phi( , ) -- at top of loop type is [min_int..10)
1646 //         i = ?
1647 //       } while ( i &lt; 10)
1648 //
1649 const TypeInt* PhaseIdealLoop::filtered_type( Node *n, Node* n_ctrl) {
1650   assert(n &amp;&amp; n-&gt;bottom_type()-&gt;is_int(), &quot;must be int&quot;);
1651   const TypeInt* filtered_t = NULL;
1652   if (!n-&gt;is_Phi()) {
1653     assert(n_ctrl != NULL || n_ctrl == C-&gt;top(), &quot;valid control&quot;);
1654     filtered_t = filtered_type_from_dominators(n, n_ctrl);
1655 
1656   } else {
1657     Node* phi    = n-&gt;as_Phi();
1658     Node* region = phi-&gt;in(0);
1659     assert(n_ctrl == NULL || n_ctrl == region, &quot;ctrl parameter must be region&quot;);
1660     if (region &amp;&amp; region != C-&gt;top()) {
1661       for (uint i = 1; i &lt; phi-&gt;req(); i++) {
1662         Node* val   = phi-&gt;in(i);
1663         Node* use_c = region-&gt;in(i);
1664         const TypeInt* val_t = filtered_type_from_dominators(val, use_c);
1665         if (val_t != NULL) {
1666           if (filtered_t == NULL) {
1667             filtered_t = val_t;
1668           } else {
1669             filtered_t = filtered_t-&gt;meet(val_t)-&gt;is_int();
1670           }
1671         }
1672       }
1673     }
1674   }
1675   const TypeInt* n_t = _igvn.type(n)-&gt;is_int();
1676   if (filtered_t != NULL) {
1677     n_t = n_t-&gt;join(filtered_t)-&gt;is_int();
1678   }
1679   return n_t;
1680 }
1681 
1682 
1683 //------------------------------filtered_type_from_dominators--------------------------------
1684 // Return a possibly more restrictive type for val based on condition control flow of dominators
1685 const TypeInt* PhaseIdealLoop::filtered_type_from_dominators( Node* val, Node *use_ctrl) {
1686   if (val-&gt;is_Con()) {
1687      return val-&gt;bottom_type()-&gt;is_int();
1688   }
1689   uint if_limit = 10; // Max number of dominating if&#39;s visited
1690   const TypeInt* rtn_t = NULL;
1691 
1692   if (use_ctrl &amp;&amp; use_ctrl != C-&gt;top()) {
1693     Node* val_ctrl = get_ctrl(val);
1694     uint val_dom_depth = dom_depth(val_ctrl);
1695     Node* pred = use_ctrl;
1696     uint if_cnt = 0;
1697     while (if_cnt &lt; if_limit) {
1698       if ((pred-&gt;Opcode() == Op_IfTrue || pred-&gt;Opcode() == Op_IfFalse)) {
1699         if_cnt++;
1700         const TypeInt* if_t = IfNode::filtered_int_type(&amp;_igvn, val, pred);
1701         if (if_t != NULL) {
1702           if (rtn_t == NULL) {
1703             rtn_t = if_t;
1704           } else {
1705             rtn_t = rtn_t-&gt;join(if_t)-&gt;is_int();
1706           }
1707         }
1708       }
1709       pred = idom(pred);
1710       if (pred == NULL || pred == C-&gt;top()) {
1711         break;
1712       }
1713       // Stop if going beyond definition block of val
1714       if (dom_depth(pred) &lt; val_dom_depth) {
1715         break;
1716       }
1717     }
1718   }
1719   return rtn_t;
1720 }
1721 
1722 
1723 //------------------------------dump_spec--------------------------------------
1724 // Dump special per-node info
1725 #ifndef PRODUCT
1726 void CountedLoopEndNode::dump_spec(outputStream *st) const {
1727   if( in(TestValue) != NULL &amp;&amp; in(TestValue)-&gt;is_Bool() ) {
1728     BoolTest bt( test_trip()); // Added this for g++.
1729 
1730     st-&gt;print(&quot;[&quot;);
1731     bt.dump_on(st);
1732     st-&gt;print(&quot;]&quot;);
1733   }
1734   st-&gt;print(&quot; &quot;);
1735   IfNode::dump_spec(st);
1736 }
1737 #endif
1738 
1739 //=============================================================================
1740 //------------------------------is_member--------------------------------------
1741 // Is &#39;l&#39; a member of &#39;this&#39;?
1742 bool IdealLoopTree::is_member(const IdealLoopTree *l) const {
1743   while( l-&gt;_nest &gt; _nest ) l = l-&gt;_parent;
1744   return l == this;
1745 }
1746 
1747 //------------------------------set_nest---------------------------------------
1748 // Set loop tree nesting depth.  Accumulate _has_call bits.
1749 int IdealLoopTree::set_nest( uint depth ) {
1750   _nest = depth;
1751   int bits = _has_call;
1752   if( _child ) bits |= _child-&gt;set_nest(depth+1);
1753   if( bits ) _has_call = 1;
1754   if( _next  ) bits |= _next -&gt;set_nest(depth  );
1755   return bits;
1756 }
1757 
1758 //------------------------------split_fall_in----------------------------------
1759 // Split out multiple fall-in edges from the loop header.  Move them to a
1760 // private RegionNode before the loop.  This becomes the loop landing pad.
1761 void IdealLoopTree::split_fall_in( PhaseIdealLoop *phase, int fall_in_cnt ) {
1762   PhaseIterGVN &amp;igvn = phase-&gt;_igvn;
1763   uint i;
1764 
1765   // Make a new RegionNode to be the landing pad.
1766   Node *landing_pad = new RegionNode( fall_in_cnt+1 );
1767   phase-&gt;set_loop(landing_pad,_parent);
1768   // Gather all the fall-in control paths into the landing pad
1769   uint icnt = fall_in_cnt;
1770   uint oreq = _head-&gt;req();
1771   for( i = oreq-1; i&gt;0; i-- )
1772     if( !phase-&gt;is_member( this, _head-&gt;in(i) ) )
1773       landing_pad-&gt;set_req(icnt--,_head-&gt;in(i));
1774 
1775   // Peel off PhiNode edges as well
1776   for (DUIterator_Fast jmax, j = _head-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1777     Node *oj = _head-&gt;fast_out(j);
1778     if( oj-&gt;is_Phi() ) {
1779       PhiNode* old_phi = oj-&gt;as_Phi();
1780       assert( old_phi-&gt;region() == _head, &quot;&quot; );
1781       igvn.hash_delete(old_phi);   // Yank from hash before hacking edges
1782       Node *p = PhiNode::make_blank(landing_pad, old_phi);
1783       uint icnt = fall_in_cnt;
1784       for( i = oreq-1; i&gt;0; i-- ) {
1785         if( !phase-&gt;is_member( this, _head-&gt;in(i) ) ) {
1786           p-&gt;init_req(icnt--, old_phi-&gt;in(i));
1787           // Go ahead and clean out old edges from old phi
1788           old_phi-&gt;del_req(i);
1789         }
1790       }
1791       // Search for CSE&#39;s here, because ZKM.jar does a lot of
1792       // loop hackery and we need to be a little incremental
1793       // with the CSE to avoid O(N^2) node blow-up.
1794       Node *p2 = igvn.hash_find_insert(p); // Look for a CSE
1795       if( p2 ) {                // Found CSE
1796         p-&gt;destruct();          // Recover useless new node
1797         p = p2;                 // Use old node
1798       } else {
1799         igvn.register_new_node_with_optimizer(p, old_phi);
1800       }
1801       // Make old Phi refer to new Phi.
1802       old_phi-&gt;add_req(p);
1803       // Check for the special case of making the old phi useless and
1804       // disappear it.  In JavaGrande I have a case where this useless
1805       // Phi is the loop limit and prevents recognizing a CountedLoop
1806       // which in turn prevents removing an empty loop.
1807       Node *id_old_phi = old_phi-&gt;Identity(&amp;igvn);
1808       if( id_old_phi != old_phi ) { // Found a simple identity?
1809         // Note that I cannot call &#39;replace_node&#39; here, because
1810         // that will yank the edge from old_phi to the Region and
1811         // I&#39;m mid-iteration over the Region&#39;s uses.
1812         for (DUIterator_Last imin, i = old_phi-&gt;last_outs(imin); i &gt;= imin; ) {
1813           Node* use = old_phi-&gt;last_out(i);
1814           igvn.rehash_node_delayed(use);
1815           uint uses_found = 0;
1816           for (uint j = 0; j &lt; use-&gt;len(); j++) {
1817             if (use-&gt;in(j) == old_phi) {
1818               if (j &lt; use-&gt;req()) use-&gt;set_req (j, id_old_phi);
1819               else                use-&gt;set_prec(j, id_old_phi);
1820               uses_found++;
1821             }
1822           }
1823           i -= uses_found;    // we deleted 1 or more copies of this edge
1824         }
1825       }
1826       igvn._worklist.push(old_phi);
1827     }
1828   }
1829   // Finally clean out the fall-in edges from the RegionNode
1830   for( i = oreq-1; i&gt;0; i-- ) {
1831     if( !phase-&gt;is_member( this, _head-&gt;in(i) ) ) {
1832       _head-&gt;del_req(i);
1833     }
1834   }
1835   igvn.rehash_node_delayed(_head);
1836   // Transform landing pad
1837   igvn.register_new_node_with_optimizer(landing_pad, _head);
1838   // Insert landing pad into the header
1839   _head-&gt;add_req(landing_pad);
1840 }
1841 
1842 //------------------------------split_outer_loop-------------------------------
1843 // Split out the outermost loop from this shared header.
1844 void IdealLoopTree::split_outer_loop( PhaseIdealLoop *phase ) {
1845   PhaseIterGVN &amp;igvn = phase-&gt;_igvn;
1846 
1847   // Find index of outermost loop; it should also be my tail.
1848   uint outer_idx = 1;
1849   while( _head-&gt;in(outer_idx) != _tail ) outer_idx++;
1850 
1851   // Make a LoopNode for the outermost loop.
1852   Node *ctl = _head-&gt;in(LoopNode::EntryControl);
1853   Node *outer = new LoopNode( ctl, _head-&gt;in(outer_idx) );
1854   outer = igvn.register_new_node_with_optimizer(outer, _head);
1855   phase-&gt;set_created_loop_node();
1856 
1857   // Outermost loop falls into &#39;_head&#39; loop
1858   _head-&gt;set_req(LoopNode::EntryControl, outer);
1859   _head-&gt;del_req(outer_idx);
1860   // Split all the Phis up between &#39;_head&#39; loop and &#39;outer&#39; loop.
1861   for (DUIterator_Fast jmax, j = _head-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1862     Node *out = _head-&gt;fast_out(j);
1863     if( out-&gt;is_Phi() ) {
1864       PhiNode *old_phi = out-&gt;as_Phi();
1865       assert( old_phi-&gt;region() == _head, &quot;&quot; );
1866       Node *phi = PhiNode::make_blank(outer, old_phi);
1867       phi-&gt;init_req(LoopNode::EntryControl,    old_phi-&gt;in(LoopNode::EntryControl));
1868       phi-&gt;init_req(LoopNode::LoopBackControl, old_phi-&gt;in(outer_idx));
1869       phi = igvn.register_new_node_with_optimizer(phi, old_phi);
1870       // Make old Phi point to new Phi on the fall-in path
1871       igvn.replace_input_of(old_phi, LoopNode::EntryControl, phi);
1872       old_phi-&gt;del_req(outer_idx);
1873     }
1874   }
1875 
1876   // Use the new loop head instead of the old shared one
1877   _head = outer;
1878   phase-&gt;set_loop(_head, this);
1879 }
1880 
1881 //------------------------------fix_parent-------------------------------------
1882 static void fix_parent( IdealLoopTree *loop, IdealLoopTree *parent ) {
1883   loop-&gt;_parent = parent;
1884   if( loop-&gt;_child ) fix_parent( loop-&gt;_child, loop   );
1885   if( loop-&gt;_next  ) fix_parent( loop-&gt;_next , parent );
1886 }
1887 
1888 //------------------------------estimate_path_freq-----------------------------
1889 static float estimate_path_freq( Node *n ) {
1890   // Try to extract some path frequency info
1891   IfNode *iff;
1892   for( int i = 0; i &lt; 50; i++ ) { // Skip through a bunch of uncommon tests
1893     uint nop = n-&gt;Opcode();
1894     if( nop == Op_SafePoint ) {   // Skip any safepoint
1895       n = n-&gt;in(0);
1896       continue;
1897     }
1898     if( nop == Op_CatchProj ) {   // Get count from a prior call
1899       // Assume call does not always throw exceptions: means the call-site
1900       // count is also the frequency of the fall-through path.
1901       assert( n-&gt;is_CatchProj(), &quot;&quot; );
1902       if( ((CatchProjNode*)n)-&gt;_con != CatchProjNode::fall_through_index )
1903         return 0.0f;            // Assume call exception path is rare
1904       Node *call = n-&gt;in(0)-&gt;in(0)-&gt;in(0);
1905       assert( call-&gt;is_Call(), &quot;expect a call here&quot; );
1906       const JVMState *jvms = ((CallNode*)call)-&gt;jvms();
1907       ciMethodData* methodData = jvms-&gt;method()-&gt;method_data();
1908       if (!methodData-&gt;is_mature())  return 0.0f; // No call-site data
1909       ciProfileData* data = methodData-&gt;bci_to_data(jvms-&gt;bci());
1910       if ((data == NULL) || !data-&gt;is_CounterData()) {
1911         // no call profile available, try call&#39;s control input
1912         n = n-&gt;in(0);
1913         continue;
1914       }
1915       return data-&gt;as_CounterData()-&gt;count()/FreqCountInvocations;
1916     }
1917     // See if there&#39;s a gating IF test
1918     Node *n_c = n-&gt;in(0);
1919     if( !n_c-&gt;is_If() ) break;       // No estimate available
1920     iff = n_c-&gt;as_If();
1921     if( iff-&gt;_fcnt != COUNT_UNKNOWN )   // Have a valid count?
1922       // Compute how much count comes on this path
1923       return ((nop == Op_IfTrue) ? iff-&gt;_prob : 1.0f - iff-&gt;_prob) * iff-&gt;_fcnt;
1924     // Have no count info.  Skip dull uncommon-trap like branches.
1925     if( (nop == Op_IfTrue  &amp;&amp; iff-&gt;_prob &lt; PROB_LIKELY_MAG(5)) ||
1926         (nop == Op_IfFalse &amp;&amp; iff-&gt;_prob &gt; PROB_UNLIKELY_MAG(5)) )
1927       break;
1928     // Skip through never-taken branch; look for a real loop exit.
1929     n = iff-&gt;in(0);
1930   }
1931   return 0.0f;                  // No estimate available
1932 }
1933 
1934 //------------------------------merge_many_backedges---------------------------
1935 // Merge all the backedges from the shared header into a private Region.
1936 // Feed that region as the one backedge to this loop.
1937 void IdealLoopTree::merge_many_backedges( PhaseIdealLoop *phase ) {
1938   uint i;
1939 
1940   // Scan for the top 2 hottest backedges
1941   float hotcnt = 0.0f;
1942   float warmcnt = 0.0f;
1943   uint hot_idx = 0;
1944   // Loop starts at 2 because slot 1 is the fall-in path
1945   for( i = 2; i &lt; _head-&gt;req(); i++ ) {
1946     float cnt = estimate_path_freq(_head-&gt;in(i));
1947     if( cnt &gt; hotcnt ) {       // Grab hottest path
1948       warmcnt = hotcnt;
1949       hotcnt = cnt;
1950       hot_idx = i;
1951     } else if( cnt &gt; warmcnt ) { // And 2nd hottest path
1952       warmcnt = cnt;
1953     }
1954   }
1955 
1956   // See if the hottest backedge is worthy of being an inner loop
1957   // by being much hotter than the next hottest backedge.
1958   if( hotcnt &lt;= 0.0001 ||
1959       hotcnt &lt; 2.0*warmcnt ) hot_idx = 0;// No hot backedge
1960 
1961   // Peel out the backedges into a private merge point; peel
1962   // them all except optionally hot_idx.
1963   PhaseIterGVN &amp;igvn = phase-&gt;_igvn;
1964 
1965   Node *hot_tail = NULL;
1966   // Make a Region for the merge point
1967   Node *r = new RegionNode(1);
1968   for( i = 2; i &lt; _head-&gt;req(); i++ ) {
1969     if( i != hot_idx )
1970       r-&gt;add_req( _head-&gt;in(i) );
1971     else hot_tail = _head-&gt;in(i);
1972   }
1973   igvn.register_new_node_with_optimizer(r, _head);
1974   // Plug region into end of loop _head, followed by hot_tail
1975   while( _head-&gt;req() &gt; 3 ) _head-&gt;del_req( _head-&gt;req()-1 );
1976   igvn.replace_input_of(_head, 2, r);
1977   if( hot_idx ) _head-&gt;add_req(hot_tail);
1978 
1979   // Split all the Phis up between &#39;_head&#39; loop and the Region &#39;r&#39;
1980   for (DUIterator_Fast jmax, j = _head-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1981     Node *out = _head-&gt;fast_out(j);
1982     if( out-&gt;is_Phi() ) {
1983       PhiNode* n = out-&gt;as_Phi();
1984       igvn.hash_delete(n);      // Delete from hash before hacking edges
1985       Node *hot_phi = NULL;
1986       Node *phi = new PhiNode(r, n-&gt;type(), n-&gt;adr_type());
1987       // Check all inputs for the ones to peel out
1988       uint j = 1;
1989       for( uint i = 2; i &lt; n-&gt;req(); i++ ) {
1990         if( i != hot_idx )
1991           phi-&gt;set_req( j++, n-&gt;in(i) );
1992         else hot_phi = n-&gt;in(i);
1993       }
1994       // Register the phi but do not transform until whole place transforms
1995       igvn.register_new_node_with_optimizer(phi, n);
1996       // Add the merge phi to the old Phi
1997       while( n-&gt;req() &gt; 3 ) n-&gt;del_req( n-&gt;req()-1 );
1998       igvn.replace_input_of(n, 2, phi);
1999       if( hot_idx ) n-&gt;add_req(hot_phi);
2000     }
2001   }
2002 
2003 
2004   // Insert a new IdealLoopTree inserted below me.  Turn it into a clone
2005   // of self loop tree.  Turn self into a loop headed by _head and with
2006   // tail being the new merge point.
2007   IdealLoopTree *ilt = new IdealLoopTree( phase, _head, _tail );
2008   phase-&gt;set_loop(_tail,ilt);   // Adjust tail
2009   _tail = r;                    // Self&#39;s tail is new merge point
2010   phase-&gt;set_loop(r,this);
2011   ilt-&gt;_child = _child;         // New guy has my children
2012   _child = ilt;                 // Self has new guy as only child
2013   ilt-&gt;_parent = this;          // new guy has self for parent
2014   ilt-&gt;_nest = _nest;           // Same nesting depth (for now)
2015 
2016   // Starting with &#39;ilt&#39;, look for child loop trees using the same shared
2017   // header.  Flatten these out; they will no longer be loops in the end.
2018   IdealLoopTree **pilt = &amp;_child;
2019   while( ilt ) {
2020     if( ilt-&gt;_head == _head ) {
2021       uint i;
2022       for( i = 2; i &lt; _head-&gt;req(); i++ )
2023         if( _head-&gt;in(i) == ilt-&gt;_tail )
2024           break;                // Still a loop
2025       if( i == _head-&gt;req() ) { // No longer a loop
2026         // Flatten ilt.  Hang ilt&#39;s &quot;_next&quot; list from the end of
2027         // ilt&#39;s &#39;_child&#39; list.  Move the ilt&#39;s _child up to replace ilt.
2028         IdealLoopTree **cp = &amp;ilt-&gt;_child;
2029         while( *cp ) cp = &amp;(*cp)-&gt;_next;   // Find end of child list
2030         *cp = ilt-&gt;_next;       // Hang next list at end of child list
2031         *pilt = ilt-&gt;_child;    // Move child up to replace ilt
2032         ilt-&gt;_head = NULL;      // Flag as a loop UNIONED into parent
2033         ilt = ilt-&gt;_child;      // Repeat using new ilt
2034         continue;               // do not advance over ilt-&gt;_child
2035       }
2036       assert( ilt-&gt;_tail == hot_tail, &quot;expected to only find the hot inner loop here&quot; );
2037       phase-&gt;set_loop(_head,ilt);
2038     }
2039     pilt = &amp;ilt-&gt;_child;        // Advance to next
2040     ilt = *pilt;
2041   }
2042 
2043   if( _child ) fix_parent( _child, this );
2044 }
2045 
2046 //------------------------------beautify_loops---------------------------------
2047 // Split shared headers and insert loop landing pads.
2048 // Insert a LoopNode to replace the RegionNode.
2049 // Return TRUE if loop tree is structurally changed.
2050 bool IdealLoopTree::beautify_loops( PhaseIdealLoop *phase ) {
2051   bool result = false;
2052   // Cache parts in locals for easy
2053   PhaseIterGVN &amp;igvn = phase-&gt;_igvn;
2054 
2055   igvn.hash_delete(_head);      // Yank from hash before hacking edges
2056 
2057   // Check for multiple fall-in paths.  Peel off a landing pad if need be.
2058   int fall_in_cnt = 0;
2059   for( uint i = 1; i &lt; _head-&gt;req(); i++ )
2060     if( !phase-&gt;is_member( this, _head-&gt;in(i) ) )
2061       fall_in_cnt++;
2062   assert( fall_in_cnt, &quot;at least 1 fall-in path&quot; );
2063   if( fall_in_cnt &gt; 1 )         // Need a loop landing pad to merge fall-ins
2064     split_fall_in( phase, fall_in_cnt );
2065 
2066   // Swap inputs to the _head and all Phis to move the fall-in edge to
2067   // the left.
2068   fall_in_cnt = 1;
2069   while( phase-&gt;is_member( this, _head-&gt;in(fall_in_cnt) ) )
2070     fall_in_cnt++;
2071   if( fall_in_cnt &gt; 1 ) {
2072     // Since I am just swapping inputs I do not need to update def-use info
2073     Node *tmp = _head-&gt;in(1);
2074     igvn.rehash_node_delayed(_head);
2075     _head-&gt;set_req( 1, _head-&gt;in(fall_in_cnt) );
2076     _head-&gt;set_req( fall_in_cnt, tmp );
2077     // Swap also all Phis
2078     for (DUIterator_Fast imax, i = _head-&gt;fast_outs(imax); i &lt; imax; i++) {
2079       Node* phi = _head-&gt;fast_out(i);
2080       if( phi-&gt;is_Phi() ) {
2081         igvn.rehash_node_delayed(phi); // Yank from hash before hacking edges
2082         tmp = phi-&gt;in(1);
2083         phi-&gt;set_req( 1, phi-&gt;in(fall_in_cnt) );
2084         phi-&gt;set_req( fall_in_cnt, tmp );
2085       }
2086     }
2087   }
2088   assert( !phase-&gt;is_member( this, _head-&gt;in(1) ), &quot;left edge is fall-in&quot; );
2089   assert(  phase-&gt;is_member( this, _head-&gt;in(2) ), &quot;right edge is loop&quot; );
2090 
2091   // If I am a shared header (multiple backedges), peel off the many
2092   // backedges into a private merge point and use the merge point as
2093   // the one true backedge.
<a name="3" id="anc3"></a><span class="line-modified">2094   if (_head-&gt;req() &gt; 3 &amp;&amp; !_irreducible) {</span>
2095     // Merge the many backedges into a single backedge but leave
2096     // the hottest backedge as separate edge for the following peel.
2097     merge_many_backedges( phase );
2098     result = true;
2099   }
2100 
2101   // If I have one hot backedge, peel off myself loop.
2102   // I better be the outermost loop.
2103   if (_head-&gt;req() &gt; 3 &amp;&amp; !_irreducible) {
2104     split_outer_loop( phase );
2105     result = true;
2106 
2107   } else if (!_head-&gt;is_Loop() &amp;&amp; !_irreducible) {
2108     // Make a new LoopNode to replace the old loop head
2109     Node *l = new LoopNode( _head-&gt;in(1), _head-&gt;in(2) );
2110     l = igvn.register_new_node_with_optimizer(l, _head);
2111     phase-&gt;set_created_loop_node();
2112     // Go ahead and replace _head
2113     phase-&gt;_igvn.replace_node( _head, l );
2114     _head = l;
2115     phase-&gt;set_loop(_head, this);
2116   }
2117 
2118   // Now recursively beautify nested loops
2119   if( _child ) result |= _child-&gt;beautify_loops( phase );
2120   if( _next  ) result |= _next -&gt;beautify_loops( phase );
2121   return result;
2122 }
2123 
2124 //------------------------------allpaths_check_safepts----------------------------
2125 // Allpaths backwards scan from loop tail, terminating each path at first safepoint
2126 // encountered.  Helper for check_safepts.
2127 void IdealLoopTree::allpaths_check_safepts(VectorSet &amp;visited, Node_List &amp;stack) {
2128   assert(stack.size() == 0, &quot;empty stack&quot;);
2129   stack.push(_tail);
2130   visited.clear();
2131   visited.set(_tail-&gt;_idx);
2132   while (stack.size() &gt; 0) {
2133     Node* n = stack.pop();
2134     if (n-&gt;is_Call() &amp;&amp; n-&gt;as_Call()-&gt;guaranteed_safepoint()) {
2135       // Terminate this path
2136     } else if (n-&gt;Opcode() == Op_SafePoint) {
2137       if (_phase-&gt;get_loop(n) != this) {
2138         if (_required_safept == NULL) _required_safept = new Node_List();
2139         _required_safept-&gt;push(n);  // save the one closest to the tail
2140       }
2141       // Terminate this path
2142     } else {
2143       uint start = n-&gt;is_Region() ? 1 : 0;
2144       uint end   = n-&gt;is_Region() &amp;&amp; !n-&gt;is_Loop() ? n-&gt;req() : start + 1;
2145       for (uint i = start; i &lt; end; i++) {
2146         Node* in = n-&gt;in(i);
2147         assert(in-&gt;is_CFG(), &quot;must be&quot;);
2148         if (!visited.test_set(in-&gt;_idx) &amp;&amp; is_member(_phase-&gt;get_loop(in))) {
2149           stack.push(in);
2150         }
2151       }
2152     }
2153   }
2154 }
2155 
2156 //------------------------------check_safepts----------------------------
2157 // Given dominators, try to find loops with calls that must always be
2158 // executed (call dominates loop tail).  These loops do not need non-call
2159 // safepoints (ncsfpt).
2160 //
2161 // A complication is that a safepoint in a inner loop may be needed
2162 // by an outer loop. In the following, the inner loop sees it has a
2163 // call (block 3) on every path from the head (block 2) to the
2164 // backedge (arc 3-&gt;2).  So it deletes the ncsfpt (non-call safepoint)
2165 // in block 2, _but_ this leaves the outer loop without a safepoint.
2166 //
2167 //          entry  0
2168 //                 |
2169 //                 v
2170 // outer 1,2    +-&gt;1
2171 //              |  |
2172 //              |  v
2173 //              |  2&lt;---+  ncsfpt in 2
2174 //              |_/|\   |
2175 //                 | v  |
2176 // inner 2,3      /  3  |  call in 3
2177 //               /   |  |
2178 //              v    +--+
2179 //        exit  4
2180 //
2181 //
2182 // This method creates a list (_required_safept) of ncsfpt nodes that must
2183 // be protected is created for each loop. When a ncsfpt maybe deleted, it
2184 // is first looked for in the lists for the outer loops of the current loop.
2185 //
2186 // The insights into the problem:
2187 //  A) counted loops are okay
2188 //  B) innermost loops are okay (only an inner loop can delete
2189 //     a ncsfpt needed by an outer loop)
2190 //  C) a loop is immune from an inner loop deleting a safepoint
2191 //     if the loop has a call on the idom-path
2192 //  D) a loop is also immune if it has a ncsfpt (non-call safepoint) on the
2193 //     idom-path that is not in a nested loop
2194 //  E) otherwise, an ncsfpt on the idom-path that is nested in an inner
2195 //     loop needs to be prevented from deletion by an inner loop
2196 //
2197 // There are two analyses:
2198 //  1) The first, and cheaper one, scans the loop body from
2199 //     tail to head following the idom (immediate dominator)
2200 //     chain, looking for the cases (C,D,E) above.
2201 //     Since inner loops are scanned before outer loops, there is summary
2202 //     information about inner loops.  Inner loops can be skipped over
2203 //     when the tail of an inner loop is encountered.
2204 //
2205 //  2) The second, invoked if the first fails to find a call or ncsfpt on
2206 //     the idom path (which is rare), scans all predecessor control paths
2207 //     from the tail to the head, terminating a path when a call or sfpt
2208 //     is encountered, to find the ncsfpt&#39;s that are closest to the tail.
2209 //
2210 void IdealLoopTree::check_safepts(VectorSet &amp;visited, Node_List &amp;stack) {
2211   // Bottom up traversal
2212   IdealLoopTree* ch = _child;
2213   if (_child) _child-&gt;check_safepts(visited, stack);
2214   if (_next)  _next -&gt;check_safepts(visited, stack);
2215 
2216   if (!_head-&gt;is_CountedLoop() &amp;&amp; !_has_sfpt &amp;&amp; _parent != NULL &amp;&amp; !_irreducible) {
2217     bool  has_call         = false; // call on dom-path
2218     bool  has_local_ncsfpt = false; // ncsfpt on dom-path at this loop depth
2219     Node* nonlocal_ncsfpt  = NULL;  // ncsfpt on dom-path at a deeper depth
2220     // Scan the dom-path nodes from tail to head
2221     for (Node* n = tail(); n != _head; n = _phase-&gt;idom(n)) {
2222       if (n-&gt;is_Call() &amp;&amp; n-&gt;as_Call()-&gt;guaranteed_safepoint()) {
2223         has_call = true;
2224         _has_sfpt = 1;          // Then no need for a safept!
2225         break;
2226       } else if (n-&gt;Opcode() == Op_SafePoint) {
2227         if (_phase-&gt;get_loop(n) == this) {
2228           has_local_ncsfpt = true;
2229           break;
2230         }
2231         if (nonlocal_ncsfpt == NULL) {
2232           nonlocal_ncsfpt = n; // save the one closest to the tail
2233         }
2234       } else {
2235         IdealLoopTree* nlpt = _phase-&gt;get_loop(n);
2236         if (this != nlpt) {
2237           // If at an inner loop tail, see if the inner loop has already
2238           // recorded seeing a call on the dom-path (and stop.)  If not,
2239           // jump to the head of the inner loop.
2240           assert(is_member(nlpt), &quot;nested loop&quot;);
2241           Node* tail = nlpt-&gt;_tail;
2242           if (tail-&gt;in(0)-&gt;is_If()) tail = tail-&gt;in(0);
2243           if (n == tail) {
2244             // If inner loop has call on dom-path, so does outer loop
2245             if (nlpt-&gt;_has_sfpt) {
2246               has_call = true;
2247               _has_sfpt = 1;
2248               break;
2249             }
2250             // Skip to head of inner loop
2251             assert(_phase-&gt;is_dominator(_head, nlpt-&gt;_head), &quot;inner head dominated by outer head&quot;);
2252             n = nlpt-&gt;_head;
2253           }
2254         }
2255       }
2256     }
2257     // Record safept&#39;s that this loop needs preserved when an
2258     // inner loop attempts to delete it&#39;s safepoints.
2259     if (_child != NULL &amp;&amp; !has_call &amp;&amp; !has_local_ncsfpt) {
2260       if (nonlocal_ncsfpt != NULL) {
2261         if (_required_safept == NULL) _required_safept = new Node_List();
2262         _required_safept-&gt;push(nonlocal_ncsfpt);
2263       } else {
2264         // Failed to find a suitable safept on the dom-path.  Now use
2265         // an all paths walk from tail to head, looking for safepoints to preserve.
2266         allpaths_check_safepts(visited, stack);
2267       }
2268     }
2269   }
2270 }
2271 
2272 //---------------------------is_deleteable_safept----------------------------
2273 // Is safept not required by an outer loop?
2274 bool PhaseIdealLoop::is_deleteable_safept(Node* sfpt) {
2275   assert(sfpt-&gt;Opcode() == Op_SafePoint, &quot;&quot;);
2276   IdealLoopTree* lp = get_loop(sfpt)-&gt;_parent;
2277   while (lp != NULL) {
2278     Node_List* sfpts = lp-&gt;_required_safept;
2279     if (sfpts != NULL) {
2280       for (uint i = 0; i &lt; sfpts-&gt;size(); i++) {
2281         if (sfpt == sfpts-&gt;at(i))
2282           return false;
2283       }
2284     }
2285     lp = lp-&gt;_parent;
2286   }
2287   return true;
2288 }
2289 
2290 //---------------------------replace_parallel_iv-------------------------------
2291 // Replace parallel induction variable (parallel to trip counter)
2292 void PhaseIdealLoop::replace_parallel_iv(IdealLoopTree *loop) {
2293   assert(loop-&gt;_head-&gt;is_CountedLoop(), &quot;&quot;);
2294   CountedLoopNode *cl = loop-&gt;_head-&gt;as_CountedLoop();
2295   if (!cl-&gt;is_valid_counted_loop())
2296     return;         // skip malformed counted loop
2297   Node *incr = cl-&gt;incr();
2298   if (incr == NULL)
2299     return;         // Dead loop?
2300   Node *init = cl-&gt;init_trip();
2301   Node *phi  = cl-&gt;phi();
2302   int stride_con = cl-&gt;stride_con();
2303 
2304   // Visit all children, looking for Phis
2305   for (DUIterator i = cl-&gt;outs(); cl-&gt;has_out(i); i++) {
2306     Node *out = cl-&gt;out(i);
2307     // Look for other phis (secondary IVs). Skip dead ones
2308     if (!out-&gt;is_Phi() || out == phi || !has_node(out))
2309       continue;
2310     PhiNode* phi2 = out-&gt;as_Phi();
2311     Node *incr2 = phi2-&gt;in( LoopNode::LoopBackControl );
2312     // Look for induction variables of the form:  X += constant
2313     if (phi2-&gt;region() != loop-&gt;_head ||
2314         incr2-&gt;req() != 3 ||
2315         incr2-&gt;in(1) != phi2 ||
2316         incr2 == incr ||
2317         incr2-&gt;Opcode() != Op_AddI ||
2318         !incr2-&gt;in(2)-&gt;is_Con())
2319       continue;
2320 
2321     // Check for parallel induction variable (parallel to trip counter)
2322     // via an affine function.  In particular, count-down loops with
2323     // count-up array indices are common. We only RCE references off
2324     // the trip-counter, so we need to convert all these to trip-counter
2325     // expressions.
2326     Node *init2 = phi2-&gt;in( LoopNode::EntryControl );
2327     int stride_con2 = incr2-&gt;in(2)-&gt;get_int();
2328 
2329     // The ratio of the two strides cannot be represented as an int
2330     // if stride_con2 is min_int and stride_con is -1.
2331     if (stride_con2 == min_jint &amp;&amp; stride_con == -1) {
2332       continue;
2333     }
2334 
2335     // The general case here gets a little tricky.  We want to find the
2336     // GCD of all possible parallel IV&#39;s and make a new IV using this
2337     // GCD for the loop.  Then all possible IVs are simple multiples of
2338     // the GCD.  In practice, this will cover very few extra loops.
2339     // Instead we require &#39;stride_con2&#39; to be a multiple of &#39;stride_con&#39;,
2340     // where +/-1 is the common case, but other integer multiples are
2341     // also easy to handle.
2342     int ratio_con = stride_con2/stride_con;
2343 
2344     if ((ratio_con * stride_con) == stride_con2) { // Check for exact
2345 #ifndef PRODUCT
2346       if (TraceLoopOpts) {
2347         tty-&gt;print(&quot;Parallel IV: %d &quot;, phi2-&gt;_idx);
2348         loop-&gt;dump_head();
2349       }
2350 #endif
2351       // Convert to using the trip counter.  The parallel induction
2352       // variable differs from the trip counter by a loop-invariant
2353       // amount, the difference between their respective initial values.
2354       // It is scaled by the &#39;ratio_con&#39;.
2355       Node* ratio = _igvn.intcon(ratio_con);
2356       set_ctrl(ratio, C-&gt;root());
2357       Node* ratio_init = new MulINode(init, ratio);
2358       _igvn.register_new_node_with_optimizer(ratio_init, init);
2359       set_early_ctrl(ratio_init);
2360       Node* diff = new SubINode(init2, ratio_init);
2361       _igvn.register_new_node_with_optimizer(diff, init2);
2362       set_early_ctrl(diff);
2363       Node* ratio_idx = new MulINode(phi, ratio);
2364       _igvn.register_new_node_with_optimizer(ratio_idx, phi);
2365       set_ctrl(ratio_idx, cl);
2366       Node* add = new AddINode(ratio_idx, diff);
2367       _igvn.register_new_node_with_optimizer(add);
2368       set_ctrl(add, cl);
2369       _igvn.replace_node( phi2, add );
2370       // Sometimes an induction variable is unused
2371       if (add-&gt;outcnt() == 0) {
2372         _igvn.remove_dead_node(add);
2373       }
2374       --i; // deleted this phi; rescan starting with next position
2375       continue;
2376     }
2377   }
2378 }
2379 
2380 void IdealLoopTree::remove_safepoints(PhaseIdealLoop* phase, bool keep_one) {
2381   Node* keep = NULL;
2382   if (keep_one) {
2383     // Look for a safepoint on the idom-path.
2384     for (Node* i = tail(); i != _head; i = phase-&gt;idom(i)) {
2385       if (i-&gt;Opcode() == Op_SafePoint &amp;&amp; phase-&gt;get_loop(i) == this) {
2386         keep = i;
2387         break; // Found one
2388       }
2389     }
2390   }
2391 
2392   // Don&#39;t remove any safepoints if it is requested to keep a single safepoint and
2393   // no safepoint was found on idom-path. It is not safe to remove any safepoint
2394   // in this case since there&#39;s no safepoint dominating all paths in the loop body.
2395   bool prune = !keep_one || keep != NULL;
2396 
2397   // Delete other safepoints in this loop.
2398   Node_List* sfpts = _safepts;
2399   if (prune &amp;&amp; sfpts != NULL) {
2400     assert(keep == NULL || keep-&gt;Opcode() == Op_SafePoint, &quot;not safepoint&quot;);
2401     for (uint i = 0; i &lt; sfpts-&gt;size(); i++) {
2402       Node* n = sfpts-&gt;at(i);
2403       assert(phase-&gt;get_loop(n) == this, &quot;&quot;);
2404       if (n != keep &amp;&amp; phase-&gt;is_deleteable_safept(n)) {
2405         phase-&gt;lazy_replace(n, n-&gt;in(TypeFunc::Control));
2406       }
2407     }
2408   }
2409 }
2410 
2411 //------------------------------counted_loop-----------------------------------
2412 // Convert to counted loops where possible
2413 void IdealLoopTree::counted_loop( PhaseIdealLoop *phase ) {
2414 
2415   // For grins, set the inner-loop flag here
2416   if (!_child) {
2417     if (_head-&gt;is_Loop()) _head-&gt;as_Loop()-&gt;set_inner_loop();
2418   }
2419 
2420   IdealLoopTree* loop = this;
2421   if (_head-&gt;is_CountedLoop() ||
2422       phase-&gt;is_counted_loop(_head, loop)) {
2423 
2424     if (LoopStripMiningIter == 0 || (LoopStripMiningIter &gt; 1 &amp;&amp; _child == NULL)) {
2425       // Indicate we do not need a safepoint here
2426       _has_sfpt = 1;
2427     }
2428 
2429     // Remove safepoints
2430     bool keep_one_sfpt = !(_has_call || _has_sfpt);
2431     remove_safepoints(phase, keep_one_sfpt);
2432 
2433     // Look for induction variables
2434     phase-&gt;replace_parallel_iv(this);
2435 
2436   } else if (_parent != NULL &amp;&amp; !_irreducible) {
2437     // Not a counted loop. Keep one safepoint.
2438     bool keep_one_sfpt = true;
2439     remove_safepoints(phase, keep_one_sfpt);
2440   }
2441 
2442   // Recursively
2443   assert(loop-&gt;_child != this || (loop-&gt;_head-&gt;as_Loop()-&gt;is_OuterStripMinedLoop() &amp;&amp; _head-&gt;as_CountedLoop()-&gt;is_strip_mined()), &quot;what kind of loop was added?&quot;);
2444   assert(loop-&gt;_child != this || (loop-&gt;_child-&gt;_child == NULL &amp;&amp; loop-&gt;_child-&gt;_next == NULL), &quot;would miss some loops&quot;);
2445   if (loop-&gt;_child &amp;&amp; loop-&gt;_child != this) loop-&gt;_child-&gt;counted_loop(phase);
2446   if (loop-&gt;_next)  loop-&gt;_next -&gt;counted_loop(phase);
2447 }
2448 
2449 
2450 // The Estimated Loop Clone Size:
2451 //   CloneFactor * (~112% * BodySize + BC) + CC + FanOutTerm,
2452 // where  BC and  CC are  totally ad-hoc/magic  &quot;body&quot; and &quot;clone&quot; constants,
2453 // respectively, used to ensure that the node usage estimates made are on the
2454 // safe side, for the most part. The FanOutTerm is an attempt to estimate the
2455 // possible additional/excessive nodes generated due to data and control flow
2456 // merging, for edges reaching outside the loop.
2457 uint IdealLoopTree::est_loop_clone_sz(uint factor) const {
2458 
2459   precond(0 &lt; factor &amp;&amp; factor &lt; 16);
2460 
2461   uint const bc = 13;
2462   uint const cc = 17;
2463   uint const sz = _body.size() + (_body.size() + 7) / 8;
2464   uint estimate = factor * (sz + bc) + cc;
2465 
2466   assert((estimate - cc) / factor == sz + bc, &quot;overflow&quot;);
2467 
2468   return estimate + est_loop_flow_merge_sz();
2469 }
2470 
2471 // The Estimated Loop (full-) Unroll Size:
2472 //   UnrollFactor * (~106% * BodySize) + CC + FanOutTerm,
2473 // where CC is a (totally) ad-hoc/magic &quot;clone&quot; constant, used to ensure that
2474 // node usage estimates made are on the safe side, for the most part. This is
2475 // a &quot;light&quot; version of the loop clone size calculation (above), based on the
2476 // assumption that most of the loop-construct overhead will be unraveled when
2477 // (fully) unrolled. Defined for unroll factors larger or equal to one (&gt;=1),
2478 // including an overflow check and returning UINT_MAX in case of an overflow.
2479 uint IdealLoopTree::est_loop_unroll_sz(uint factor) const {
2480 
2481   precond(factor &gt; 0);
2482 
2483   // Take into account that after unroll conjoined heads and tails will fold.
2484   uint const b0 = _body.size() - EMPTY_LOOP_SIZE;
2485   uint const cc = 7;
2486   uint const sz = b0 + (b0 + 15) / 16;
2487   uint estimate = factor * sz + cc;
2488 
2489   if ((estimate - cc) / factor != sz) {
2490     return UINT_MAX;
2491   }
2492 
2493   return estimate + est_loop_flow_merge_sz();
2494 }
2495 
2496 // Estimate the growth effect (in nodes) of merging control and data flow when
2497 // cloning a loop body, based on the amount of  control and data flow reaching
2498 // outside of the (current) loop body.
2499 uint IdealLoopTree::est_loop_flow_merge_sz() const {
2500 
2501   uint ctrl_edge_out_cnt = 0;
2502   uint data_edge_out_cnt = 0;
2503 
2504   for (uint i = 0; i &lt; _body.size(); i++) {
2505     Node* node = _body.at(i);
2506     uint outcnt = node-&gt;outcnt();
2507 
2508     for (uint k = 0; k &lt; outcnt; k++) {
2509       Node* out = node-&gt;raw_out(k);
2510       if (out == NULL) continue;
2511       if (out-&gt;is_CFG()) {
2512         if (!is_member(_phase-&gt;get_loop(out))) {
2513           ctrl_edge_out_cnt++;
2514         }
2515       } else if (_phase-&gt;has_ctrl(out)) {
2516         Node* ctrl = _phase-&gt;get_ctrl(out);
2517         assert(ctrl != NULL, &quot;must be&quot;);
2518         assert(ctrl-&gt;is_CFG(), &quot;must be&quot;);
2519         if (!is_member(_phase-&gt;get_loop(ctrl))) {
2520           data_edge_out_cnt++;
2521         }
2522       }
2523     }
2524   }
2525   // Use data and control count (x2.0) in estimate iff both are &gt; 0. This is
2526   // a rather pessimistic estimate for the most part, in particular for some
2527   // complex loops, but still not enough to capture all loops.
2528   if (ctrl_edge_out_cnt &gt; 0 &amp;&amp; data_edge_out_cnt &gt; 0) {
2529     return 2 * (ctrl_edge_out_cnt + data_edge_out_cnt);
2530   }
2531   return 0;
2532 }
2533 
2534 #ifndef PRODUCT
2535 //------------------------------dump_head--------------------------------------
2536 // Dump 1 liner for loop header info
2537 void IdealLoopTree::dump_head() const {
2538   tty-&gt;sp(2 * _nest);
2539   tty-&gt;print(&quot;Loop: N%d/N%d &quot;, _head-&gt;_idx, _tail-&gt;_idx);
2540   if (_irreducible) tty-&gt;print(&quot; IRREDUCIBLE&quot;);
2541   Node* entry = _head-&gt;is_Loop() ? _head-&gt;as_Loop()-&gt;skip_strip_mined(-1)-&gt;in(LoopNode::EntryControl) : _head-&gt;in(LoopNode::EntryControl);
2542   Node* predicate = PhaseIdealLoop::find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);
2543   if (predicate != NULL ) {
2544     tty-&gt;print(&quot; limit_check&quot;);
2545     entry = PhaseIdealLoop::skip_loop_predicates(entry);
2546   }
<a name="4" id="anc4"></a><span class="line-modified">2547   if (UseProfiledLoopPredicate) {</span>
<span class="line-modified">2548     predicate = PhaseIdealLoop::find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);</span>
<span class="line-modified">2549     if (predicate != NULL) {</span>
<span class="line-modified">2550       tty-&gt;print(&quot; profile_predicated&quot;);</span>
2551       entry = PhaseIdealLoop::skip_loop_predicates(entry);
2552     }
2553   }
<a name="5" id="anc5"></a><span class="line-modified">2554   if (UseLoopPredicate) {</span>
<span class="line-modified">2555     predicate = PhaseIdealLoop::find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);</span>
<span class="line-modified">2556     if (predicate != NULL) {</span>
<span class="line-modified">2557       tty-&gt;print(&quot; predicated&quot;);</span>
2558     }
2559   }
2560   if (_head-&gt;is_CountedLoop()) {
2561     CountedLoopNode *cl = _head-&gt;as_CountedLoop();
2562     tty-&gt;print(&quot; counted&quot;);
2563 
2564     Node* init_n = cl-&gt;init_trip();
2565     if (init_n  != NULL &amp;&amp;  init_n-&gt;is_Con())
2566       tty-&gt;print(&quot; [%d,&quot;, cl-&gt;init_trip()-&gt;get_int());
2567     else
2568       tty-&gt;print(&quot; [int,&quot;);
2569     Node* limit_n = cl-&gt;limit();
2570     if (limit_n  != NULL &amp;&amp;  limit_n-&gt;is_Con())
2571       tty-&gt;print(&quot;%d),&quot;, cl-&gt;limit()-&gt;get_int());
2572     else
2573       tty-&gt;print(&quot;int),&quot;);
2574     int stride_con  = cl-&gt;stride_con();
2575     if (stride_con &gt; 0) tty-&gt;print(&quot;+&quot;);
2576     tty-&gt;print(&quot;%d&quot;, stride_con);
2577 
2578     tty-&gt;print(&quot; (%0.f iters) &quot;, cl-&gt;profile_trip_cnt());
2579 
2580     if (cl-&gt;is_pre_loop ()) tty-&gt;print(&quot; pre&quot; );
2581     if (cl-&gt;is_main_loop()) tty-&gt;print(&quot; main&quot;);
2582     if (cl-&gt;is_post_loop()) tty-&gt;print(&quot; post&quot;);
2583     if (cl-&gt;is_vectorized_loop()) tty-&gt;print(&quot; vector&quot;);
2584     if (cl-&gt;range_checks_present()) tty-&gt;print(&quot; rc &quot;);
2585     if (cl-&gt;is_multiversioned()) tty-&gt;print(&quot; multi &quot;);
2586   }
2587   if (_has_call) tty-&gt;print(&quot; has_call&quot;);
2588   if (_has_sfpt) tty-&gt;print(&quot; has_sfpt&quot;);
2589   if (_rce_candidate) tty-&gt;print(&quot; rce&quot;);
2590   if (_safepts != NULL &amp;&amp; _safepts-&gt;size() &gt; 0) {
2591     tty-&gt;print(&quot; sfpts={&quot;); _safepts-&gt;dump_simple(); tty-&gt;print(&quot; }&quot;);
2592   }
2593   if (_required_safept != NULL &amp;&amp; _required_safept-&gt;size() &gt; 0) {
2594     tty-&gt;print(&quot; req={&quot;); _required_safept-&gt;dump_simple(); tty-&gt;print(&quot; }&quot;);
2595   }
2596   if (Verbose) {
2597     tty-&gt;print(&quot; body={&quot;); _body.dump_simple(); tty-&gt;print(&quot; }&quot;);
2598   }
2599   if (_head-&gt;is_Loop() &amp;&amp; _head-&gt;as_Loop()-&gt;is_strip_mined()) {
2600     tty-&gt;print(&quot; strip_mined&quot;);
2601   }
2602   tty-&gt;cr();
2603 }
2604 
2605 //------------------------------dump-------------------------------------------
2606 // Dump loops by loop tree
2607 void IdealLoopTree::dump() const {
2608   dump_head();
2609   if (_child) _child-&gt;dump();
2610   if (_next)  _next -&gt;dump();
2611 }
2612 
2613 #endif
2614 
2615 static void log_loop_tree(IdealLoopTree* root, IdealLoopTree* loop, CompileLog* log) {
2616   if (loop == root) {
2617     if (loop-&gt;_child != NULL) {
2618       log-&gt;begin_head(&quot;loop_tree&quot;);
2619       log-&gt;end_head();
2620       if( loop-&gt;_child ) log_loop_tree(root, loop-&gt;_child, log);
2621       log-&gt;tail(&quot;loop_tree&quot;);
2622       assert(loop-&gt;_next == NULL, &quot;what?&quot;);
2623     }
2624   } else {
2625     Node* head = loop-&gt;_head;
2626     log-&gt;begin_head(&quot;loop&quot;);
2627     log-&gt;print(&quot; idx=&#39;%d&#39; &quot;, head-&gt;_idx);
2628     if (loop-&gt;_irreducible) log-&gt;print(&quot;irreducible=&#39;1&#39; &quot;);
2629     if (head-&gt;is_Loop()) {
2630       if (head-&gt;as_Loop()-&gt;is_inner_loop()) log-&gt;print(&quot;inner_loop=&#39;1&#39; &quot;);
2631       if (head-&gt;as_Loop()-&gt;is_partial_peel_loop()) log-&gt;print(&quot;partial_peel_loop=&#39;1&#39; &quot;);
2632     }
2633     if (head-&gt;is_CountedLoop()) {
2634       CountedLoopNode* cl = head-&gt;as_CountedLoop();
2635       if (cl-&gt;is_pre_loop())  log-&gt;print(&quot;pre_loop=&#39;%d&#39; &quot;,  cl-&gt;main_idx());
2636       if (cl-&gt;is_main_loop()) log-&gt;print(&quot;main_loop=&#39;%d&#39; &quot;, cl-&gt;_idx);
2637       if (cl-&gt;is_post_loop()) log-&gt;print(&quot;post_loop=&#39;%d&#39; &quot;,  cl-&gt;main_idx());
2638     }
2639     log-&gt;end_head();
2640     if( loop-&gt;_child ) log_loop_tree(root, loop-&gt;_child, log);
2641     log-&gt;tail(&quot;loop&quot;);
2642     if( loop-&gt;_next  ) log_loop_tree(root, loop-&gt;_next, log);
2643   }
2644 }
2645 
2646 //---------------------collect_potentially_useful_predicates-----------------------
2647 // Helper function to collect potentially useful predicates to prevent them from
2648 // being eliminated by PhaseIdealLoop::eliminate_useless_predicates
2649 void PhaseIdealLoop::collect_potentially_useful_predicates(
2650                          IdealLoopTree * loop, Unique_Node_List &amp;useful_predicates) {
2651   if (loop-&gt;_child) { // child
2652     collect_potentially_useful_predicates(loop-&gt;_child, useful_predicates);
2653   }
2654 
2655   // self (only loops that we can apply loop predication may use their predicates)
2656   if (loop-&gt;_head-&gt;is_Loop() &amp;&amp;
2657       !loop-&gt;_irreducible    &amp;&amp;
2658       !loop-&gt;tail()-&gt;is_top()) {
2659     LoopNode* lpn = loop-&gt;_head-&gt;as_Loop();
2660     Node* entry = lpn-&gt;in(LoopNode::EntryControl);
2661     Node* predicate_proj = find_predicate(entry); // loop_limit_check first
<a name="6" id="anc6"></a><span class="line-modified">2662     if (predicate_proj != NULL) { // right pattern that can be used by loop predication</span>
2663       assert(entry-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_Opaque1, &quot;must be&quot;);
2664       useful_predicates.push(entry-&gt;in(0)-&gt;in(1)-&gt;in(1)); // good one
2665       entry = skip_loop_predicates(entry);
2666     }
<a name="7" id="anc7"></a>




2667     if (UseProfiledLoopPredicate) {
2668       predicate_proj = find_predicate(entry); // Predicate
<a name="8" id="anc8"></a><span class="line-modified">2669       if (predicate_proj != NULL) {</span>
2670         useful_predicates.push(entry-&gt;in(0)-&gt;in(1)-&gt;in(1)); // good one
<a name="9" id="anc9"></a><span class="line-added">2671         entry = skip_loop_predicates(entry);</span>
2672       }
2673     }
<a name="10" id="anc10"></a><span class="line-added">2674     predicate_proj = find_predicate(entry); // Predicate</span>
<span class="line-added">2675     if (predicate_proj != NULL) {</span>
<span class="line-added">2676       useful_predicates.push(entry-&gt;in(0)-&gt;in(1)-&gt;in(1)); // good one</span>
<span class="line-added">2677     }</span>
2678   }
2679 
2680   if (loop-&gt;_next) { // sibling
2681     collect_potentially_useful_predicates(loop-&gt;_next, useful_predicates);
2682   }
2683 }
2684 
2685 //------------------------eliminate_useless_predicates-----------------------------
2686 // Eliminate all inserted predicates if they could not be used by loop predication.
2687 // Note: it will also eliminates loop limits check predicate since it also uses
2688 // Opaque1 node (see Parse::add_predicate()).
2689 void PhaseIdealLoop::eliminate_useless_predicates() {
2690   if (C-&gt;predicate_count() == 0)
2691     return; // no predicate left
2692 
2693   Unique_Node_List useful_predicates; // to store useful predicates
2694   if (C-&gt;has_loops()) {
2695     collect_potentially_useful_predicates(_ltree_root-&gt;_child, useful_predicates);
2696   }
2697 
2698   for (int i = C-&gt;predicate_count(); i &gt; 0; i--) {
2699      Node * n = C-&gt;predicate_opaque1_node(i-1);
2700      assert(n-&gt;Opcode() == Op_Opaque1, &quot;must be&quot;);
2701      if (!useful_predicates.member(n)) { // not in the useful list
2702        _igvn.replace_node(n, n-&gt;in(1));
2703      }
2704   }
2705 }
2706 
2707 //------------------------process_expensive_nodes-----------------------------
2708 // Expensive nodes have their control input set to prevent the GVN
2709 // from commoning them and as a result forcing the resulting node to
2710 // be in a more frequent path. Use CFG information here, to change the
2711 // control inputs so that some expensive nodes can be commoned while
2712 // not executed more frequently.
2713 bool PhaseIdealLoop::process_expensive_nodes() {
2714   assert(OptimizeExpensiveOps, &quot;optimization off?&quot;);
2715 
2716   // Sort nodes to bring similar nodes together
2717   C-&gt;sort_expensive_nodes();
2718 
2719   bool progress = false;
2720 
2721   for (int i = 0; i &lt; C-&gt;expensive_count(); ) {
2722     Node* n = C-&gt;expensive_node(i);
2723     int start = i;
2724     // Find nodes similar to n
2725     i++;
2726     for (; i &lt; C-&gt;expensive_count() &amp;&amp; Compile::cmp_expensive_nodes(n, C-&gt;expensive_node(i)) == 0; i++);
2727     int end = i;
2728     // And compare them two by two
2729     for (int j = start; j &lt; end; j++) {
2730       Node* n1 = C-&gt;expensive_node(j);
2731       if (is_node_unreachable(n1)) {
2732         continue;
2733       }
2734       for (int k = j+1; k &lt; end; k++) {
2735         Node* n2 = C-&gt;expensive_node(k);
2736         if (is_node_unreachable(n2)) {
2737           continue;
2738         }
2739 
2740         assert(n1 != n2, &quot;should be pair of nodes&quot;);
2741 
2742         Node* c1 = n1-&gt;in(0);
2743         Node* c2 = n2-&gt;in(0);
2744 
2745         Node* parent_c1 = c1;
2746         Node* parent_c2 = c2;
2747 
2748         // The call to get_early_ctrl_for_expensive() moves the
2749         // expensive nodes up but stops at loops that are in a if
2750         // branch. See whether we can exit the loop and move above the
2751         // If.
2752         if (c1-&gt;is_Loop()) {
2753           parent_c1 = c1-&gt;in(1);
2754         }
2755         if (c2-&gt;is_Loop()) {
2756           parent_c2 = c2-&gt;in(1);
2757         }
2758 
2759         if (parent_c1 == parent_c2) {
2760           _igvn._worklist.push(n1);
2761           _igvn._worklist.push(n2);
2762           continue;
2763         }
2764 
2765         // Look for identical expensive node up the dominator chain.
2766         if (is_dominator(c1, c2)) {
2767           c2 = c1;
2768         } else if (is_dominator(c2, c1)) {
2769           c1 = c2;
2770         } else if (parent_c1-&gt;is_Proj() &amp;&amp; parent_c1-&gt;in(0)-&gt;is_If() &amp;&amp;
2771                    parent_c2-&gt;is_Proj() &amp;&amp; parent_c1-&gt;in(0) == parent_c2-&gt;in(0)) {
2772           // Both branches have the same expensive node so move it up
2773           // before the if.
2774           c1 = c2 = idom(parent_c1-&gt;in(0));
2775         }
2776         // Do the actual moves
2777         if (n1-&gt;in(0) != c1) {
2778           _igvn.hash_delete(n1);
2779           n1-&gt;set_req(0, c1);
2780           _igvn.hash_insert(n1);
2781           _igvn._worklist.push(n1);
2782           progress = true;
2783         }
2784         if (n2-&gt;in(0) != c2) {
2785           _igvn.hash_delete(n2);
2786           n2-&gt;set_req(0, c2);
2787           _igvn.hash_insert(n2);
2788           _igvn._worklist.push(n2);
2789           progress = true;
2790         }
2791       }
2792     }
2793   }
2794 
2795   return progress;
2796 }
2797 
2798 
2799 //=============================================================================
2800 //----------------------------build_and_optimize-------------------------------
2801 // Create a PhaseLoop.  Build the ideal Loop tree.  Map each Ideal Node to
2802 // its corresponding LoopNode.  If &#39;optimize&#39; is true, do some loop cleanups.
2803 void PhaseIdealLoop::build_and_optimize(LoopOptsMode mode) {
2804   bool do_split_ifs = (mode == LoopOptsDefault);
2805   bool skip_loop_opts = (mode == LoopOptsNone);
2806 
2807   int old_progress = C-&gt;major_progress();
2808   uint orig_worklist_size = _igvn._worklist.size();
2809 
2810   // Reset major-progress flag for the driver&#39;s heuristics
2811   C-&gt;clear_major_progress();
2812 
2813 #ifndef PRODUCT
2814   // Capture for later assert
2815   uint unique = C-&gt;unique();
2816   _loop_invokes++;
2817   _loop_work += unique;
2818 #endif
2819 
2820   // True if the method has at least 1 irreducible loop
2821   _has_irreducible_loops = false;
2822 
2823   _created_loop_node = false;
2824 
2825   Arena *a = Thread::current()-&gt;resource_area();
2826   VectorSet visited(a);
2827   // Pre-grow the mapping from Nodes to IdealLoopTrees.
2828   _nodes.map(C-&gt;unique(), NULL);
2829   memset(_nodes.adr(), 0, wordSize * C-&gt;unique());
2830 
2831   // Pre-build the top-level outermost loop tree entry
2832   _ltree_root = new IdealLoopTree( this, C-&gt;root(), C-&gt;root() );
2833   // Do not need a safepoint at the top level
2834   _ltree_root-&gt;_has_sfpt = 1;
2835 
2836   // Initialize Dominators.
2837   // Checked in clone_loop_predicate() during beautify_loops().
2838   _idom_size = 0;
2839   _idom      = NULL;
2840   _dom_depth = NULL;
2841   _dom_stk   = NULL;
2842 
2843   // Empty pre-order array
2844   allocate_preorders();
2845 
2846   // Build a loop tree on the fly.  Build a mapping from CFG nodes to
2847   // IdealLoopTree entries.  Data nodes are NOT walked.
2848   build_loop_tree();
2849   // Check for bailout, and return
2850   if (C-&gt;failing()) {
2851     return;
2852   }
2853 
2854   // No loops after all
2855   if( !_ltree_root-&gt;_child &amp;&amp; !_verify_only ) C-&gt;set_has_loops(false);
2856 
2857   // There should always be an outer loop containing the Root and Return nodes.
2858   // If not, we have a degenerate empty program.  Bail out in this case.
2859   if (!has_node(C-&gt;root())) {
2860     if (!_verify_only) {
2861       C-&gt;clear_major_progress();
2862       C-&gt;record_method_not_compilable(&quot;empty program detected during loop optimization&quot;);
2863     }
2864     return;
2865   }
2866 
2867   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
2868   // Nothing to do, so get out
2869   bool stop_early = !C-&gt;has_loops() &amp;&amp; !skip_loop_opts &amp;&amp; !do_split_ifs &amp;&amp; !_verify_me &amp;&amp; !_verify_only &amp;&amp;
2870     !bs-&gt;is_gc_specific_loop_opts_pass(mode);
2871   bool do_expensive_nodes = C-&gt;should_optimize_expensive_nodes(_igvn);
2872   bool strip_mined_loops_expanded = bs-&gt;strip_mined_loops_expanded(mode);
2873   if (stop_early &amp;&amp; !do_expensive_nodes) {
2874     _igvn.optimize();           // Cleanup NeverBranches
2875     return;
2876   }
2877 
2878   // Set loop nesting depth
2879   _ltree_root-&gt;set_nest( 0 );
2880 
2881   // Split shared headers and insert loop landing pads.
2882   // Do not bother doing this on the Root loop of course.
2883   if( !_verify_me &amp;&amp; !_verify_only &amp;&amp; _ltree_root-&gt;_child ) {
2884     C-&gt;print_method(PHASE_BEFORE_BEAUTIFY_LOOPS, 3);
2885     if( _ltree_root-&gt;_child-&gt;beautify_loops( this ) ) {
2886       // Re-build loop tree!
2887       _ltree_root-&gt;_child = NULL;
2888       _nodes.clear();
2889       reallocate_preorders();
2890       build_loop_tree();
2891       // Check for bailout, and return
2892       if (C-&gt;failing()) {
2893         return;
2894       }
2895       // Reset loop nesting depth
2896       _ltree_root-&gt;set_nest( 0 );
2897 
2898       C-&gt;print_method(PHASE_AFTER_BEAUTIFY_LOOPS, 3);
2899     }
2900   }
2901 
2902   // Build Dominators for elision of NULL checks &amp; loop finding.
2903   // Since nodes do not have a slot for immediate dominator, make
2904   // a persistent side array for that info indexed on node-&gt;_idx.
2905   _idom_size = C-&gt;unique();
2906   _idom      = NEW_RESOURCE_ARRAY( Node*, _idom_size );
2907   _dom_depth = NEW_RESOURCE_ARRAY( uint,  _idom_size );
2908   _dom_stk   = NULL; // Allocated on demand in recompute_dom_depth
2909   memset( _dom_depth, 0, _idom_size * sizeof(uint) );
2910 
2911   Dominators();
2912 
2913   if (!_verify_only) {
2914     // As a side effect, Dominators removed any unreachable CFG paths
2915     // into RegionNodes.  It doesn&#39;t do this test against Root, so
2916     // we do it here.
2917     for( uint i = 1; i &lt; C-&gt;root()-&gt;req(); i++ ) {
2918       if( !_nodes[C-&gt;root()-&gt;in(i)-&gt;_idx] ) {    // Dead path into Root?
2919         _igvn.delete_input_of(C-&gt;root(), i);
2920         i--;                      // Rerun same iteration on compressed edges
2921       }
2922     }
2923 
2924     // Given dominators, try to find inner loops with calls that must
2925     // always be executed (call dominates loop tail).  These loops do
2926     // not need a separate safepoint.
2927     Node_List cisstack(a);
2928     _ltree_root-&gt;check_safepts(visited, cisstack);
2929   }
2930 
2931   // Walk the DATA nodes and place into loops.  Find earliest control
2932   // node.  For CFG nodes, the _nodes array starts out and remains
2933   // holding the associated IdealLoopTree pointer.  For DATA nodes, the
2934   // _nodes array holds the earliest legal controlling CFG node.
2935 
2936   // Allocate stack with enough space to avoid frequent realloc
2937   int stack_size = (C-&gt;live_nodes() &gt;&gt; 1) + 16; // (live_nodes&gt;&gt;1)+16 from Java2D stats
2938   Node_Stack nstack( a, stack_size );
2939 
2940   visited.clear();
2941   Node_List worklist(a);
2942   // Don&#39;t need C-&gt;root() on worklist since
2943   // it will be processed among C-&gt;top() inputs
2944   worklist.push(C-&gt;top());
2945   visited.set(C-&gt;top()-&gt;_idx); // Set C-&gt;top() as visited now
2946   build_loop_early( visited, worklist, nstack );
2947 
2948   // Given early legal placement, try finding counted loops.  This placement
2949   // is good enough to discover most loop invariants.
2950   if (!_verify_me &amp;&amp; !_verify_only &amp;&amp; !strip_mined_loops_expanded) {
2951     _ltree_root-&gt;counted_loop( this );
2952   }
2953 
2954   // Find latest loop placement.  Find ideal loop placement.
2955   visited.clear();
2956   init_dom_lca_tags();
2957   // Need C-&gt;root() on worklist when processing outs
2958   worklist.push(C-&gt;root());
2959   NOT_PRODUCT( C-&gt;verify_graph_edges(); )
2960   worklist.push(C-&gt;top());
2961   build_loop_late( visited, worklist, nstack );
2962 
2963   if (_verify_only) {
2964     C-&gt;restore_major_progress(old_progress);
2965     assert(C-&gt;unique() == unique, &quot;verification mode made Nodes? ? ?&quot;);
2966     assert(_igvn._worklist.size() == orig_worklist_size, &quot;shouldn&#39;t push anything&quot;);
2967     return;
2968   }
2969 
2970   // clear out the dead code after build_loop_late
2971   while (_deadlist.size()) {
2972     _igvn.remove_globally_dead_node(_deadlist.pop());
2973   }
2974 
2975   if (stop_early) {
2976     assert(do_expensive_nodes, &quot;why are we here?&quot;);
2977     if (process_expensive_nodes()) {
2978       // If we made some progress when processing expensive nodes then
2979       // the IGVN may modify the graph in a way that will allow us to
2980       // make some more progress: we need to try processing expensive
2981       // nodes again.
2982       C-&gt;set_major_progress();
2983     }
2984     _igvn.optimize();
2985     return;
2986   }
2987 
2988   // Some parser-inserted loop predicates could never be used by loop
2989   // predication or they were moved away from loop during some optimizations.
2990   // For example, peeling. Eliminate them before next loop optimizations.
2991   eliminate_useless_predicates();
2992 
2993 #ifndef PRODUCT
2994   C-&gt;verify_graph_edges();
2995   if (_verify_me) {             // Nested verify pass?
2996     // Check to see if the verify mode is broken
2997     assert(C-&gt;unique() == unique, &quot;non-optimize mode made Nodes? ? ?&quot;);
2998     return;
2999   }
3000   if (VerifyLoopOptimizations) verify();
3001   if (TraceLoopOpts &amp;&amp; C-&gt;has_loops()) {
3002     _ltree_root-&gt;dump();
3003   }
3004 #endif
3005 
3006   if (skip_loop_opts) {
3007     // restore major progress flag
3008     C-&gt;restore_major_progress(old_progress);
3009 
3010     // Cleanup any modified bits
3011     _igvn.optimize();
3012 
3013     if (C-&gt;log() != NULL) {
3014       log_loop_tree(_ltree_root, _ltree_root, C-&gt;log());
3015     }
3016     return;
3017   }
3018 
3019   if (mode == LoopOptsMaxUnroll) {
3020     for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {
3021       IdealLoopTree* lpt = iter.current();
3022       if (lpt-&gt;is_innermost() &amp;&amp; lpt-&gt;_allow_optimizations &amp;&amp; !lpt-&gt;_has_call &amp;&amp; lpt-&gt;is_counted()) {
3023         lpt-&gt;compute_trip_count(this);
3024         if (!lpt-&gt;do_one_iteration_loop(this) &amp;&amp;
3025             !lpt-&gt;do_remove_empty_loop(this)) {
3026           AutoNodeBudget node_budget(this);
3027           if (lpt-&gt;_head-&gt;as_CountedLoop()-&gt;is_normal_loop() &amp;&amp;
3028               lpt-&gt;policy_maximally_unroll(this)) {
3029             memset( worklist.adr(), 0, worklist.Size()*sizeof(Node*) );
3030             do_maximally_unroll(lpt, worklist);
3031           }
3032         }
3033       }
3034     }
3035 
3036     C-&gt;restore_major_progress(old_progress);
3037 
3038     _igvn.optimize();
3039 
3040     if (C-&gt;log() != NULL) {
3041       log_loop_tree(_ltree_root, _ltree_root, C-&gt;log());
3042     }
3043     return;
3044   }
3045 
3046   if (bs-&gt;optimize_loops(this, mode, visited, nstack, worklist)) {
3047     _igvn.optimize();
3048     if (C-&gt;log() != NULL) {
3049       log_loop_tree(_ltree_root, _ltree_root, C-&gt;log());
3050     }
3051     return;
3052   }
3053 
3054   if (ReassociateInvariants) {
3055     // Reassociate invariants and prep for split_thru_phi
3056     for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {
3057       IdealLoopTree* lpt = iter.current();
3058       bool is_counted = lpt-&gt;is_counted();
3059       if (!is_counted || !lpt-&gt;is_innermost()) continue;
3060 
3061       // check for vectorized loops, any reassociation of invariants was already done
3062       if (is_counted &amp;&amp; lpt-&gt;_head-&gt;as_CountedLoop()-&gt;is_unroll_only()) {
3063         continue;
3064       } else {
3065         AutoNodeBudget node_budget(this);
3066         lpt-&gt;reassociate_invariants(this);
3067       }
3068       // Because RCE opportunities can be masked by split_thru_phi,
3069       // look for RCE candidates and inhibit split_thru_phi
3070       // on just their loop-phi&#39;s for this pass of loop opts
3071       if (SplitIfBlocks &amp;&amp; do_split_ifs) {
3072         AutoNodeBudget node_budget(this, AutoNodeBudget::NO_BUDGET_CHECK);
3073         if (lpt-&gt;policy_range_check(this)) {
3074           lpt-&gt;_rce_candidate = 1; // = true
3075         }
3076       }
3077     }
3078   }
3079 
3080   // Check for aggressive application of split-if and other transforms
3081   // that require basic-block info (like cloning through Phi&#39;s)
3082   if( SplitIfBlocks &amp;&amp; do_split_ifs ) {
3083     visited.clear();
3084     split_if_with_blocks( visited, nstack);
3085     NOT_PRODUCT( if( VerifyLoopOptimizations ) verify(); );
3086   }
3087 
3088   if (!C-&gt;major_progress() &amp;&amp; do_expensive_nodes &amp;&amp; process_expensive_nodes()) {
3089     C-&gt;set_major_progress();
3090   }
3091 
3092   // Perform loop predication before iteration splitting
3093   if (C-&gt;has_loops() &amp;&amp; !C-&gt;major_progress() &amp;&amp; (C-&gt;predicate_count() &gt; 0)) {
3094     _ltree_root-&gt;_child-&gt;loop_predication(this);
3095   }
3096 
3097   if (OptimizeFill &amp;&amp; UseLoopPredicate &amp;&amp; C-&gt;has_loops() &amp;&amp; !C-&gt;major_progress()) {
3098     if (do_intrinsify_fill()) {
3099       C-&gt;set_major_progress();
3100     }
3101   }
3102 
3103   // Perform iteration-splitting on inner loops.  Split iterations to avoid
3104   // range checks or one-shot null checks.
3105 
3106   // If split-if&#39;s didn&#39;t hack the graph too bad (no CFG changes)
3107   // then do loop opts.
3108   if (C-&gt;has_loops() &amp;&amp; !C-&gt;major_progress()) {
3109     memset( worklist.adr(), 0, worklist.Size()*sizeof(Node*) );
3110     _ltree_root-&gt;_child-&gt;iteration_split( this, worklist );
3111     // No verify after peeling!  GCM has hoisted code out of the loop.
3112     // After peeling, the hoisted code could sink inside the peeled area.
3113     // The peeling code does not try to recompute the best location for
3114     // all the code before the peeled area, so the verify pass will always
3115     // complain about it.
3116   }
3117   // Do verify graph edges in any case
3118   NOT_PRODUCT( C-&gt;verify_graph_edges(); );
3119 
3120   if (!do_split_ifs) {
3121     // We saw major progress in Split-If to get here.  We forced a
3122     // pass with unrolling and not split-if, however more split-if&#39;s
3123     // might make progress.  If the unrolling didn&#39;t make progress
3124     // then the major-progress flag got cleared and we won&#39;t try
3125     // another round of Split-If.  In particular the ever-common
3126     // instance-of/check-cast pattern requires at least 2 rounds of
3127     // Split-If to clear out.
3128     C-&gt;set_major_progress();
3129   }
3130 
3131   // Repeat loop optimizations if new loops were seen
3132   if (created_loop_node()) {
3133     C-&gt;set_major_progress();
3134   }
3135 
3136   // Keep loop predicates and perform optimizations with them
3137   // until no more loop optimizations could be done.
3138   // After that switch predicates off and do more loop optimizations.
3139   if (!C-&gt;major_progress() &amp;&amp; (C-&gt;predicate_count() &gt; 0)) {
3140      C-&gt;cleanup_loop_predicates(_igvn);
3141      if (TraceLoopOpts) {
3142        tty-&gt;print_cr(&quot;PredicatesOff&quot;);
3143      }
3144      C-&gt;set_major_progress();
3145   }
3146 
3147   // Convert scalar to superword operations at the end of all loop opts.
3148   if (UseSuperWord &amp;&amp; C-&gt;has_loops() &amp;&amp; !C-&gt;major_progress()) {
3149     // SuperWord transform
3150     SuperWord sw(this);
3151     for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {
3152       IdealLoopTree* lpt = iter.current();
3153       if (lpt-&gt;is_counted()) {
3154         CountedLoopNode *cl = lpt-&gt;_head-&gt;as_CountedLoop();
3155 
3156         if (PostLoopMultiversioning &amp;&amp; cl-&gt;is_rce_post_loop() &amp;&amp; !cl-&gt;is_vectorized_loop()) {
3157           // Check that the rce&#39;d post loop is encountered first, multiversion after all
3158           // major main loop optimization are concluded
3159           if (!C-&gt;major_progress()) {
3160             IdealLoopTree *lpt_next = lpt-&gt;_next;
3161             if (lpt_next &amp;&amp; lpt_next-&gt;is_counted()) {
3162               CountedLoopNode *cl = lpt_next-&gt;_head-&gt;as_CountedLoop();
3163               has_range_checks(lpt_next);
3164               if (cl-&gt;is_post_loop() &amp;&amp; cl-&gt;range_checks_present()) {
3165                 if (!cl-&gt;is_multiversioned()) {
3166                   if (multi_version_post_loops(lpt, lpt_next) == false) {
3167                     // Cause the rce loop to be optimized away if we fail
3168                     cl-&gt;mark_is_multiversioned();
3169                     cl-&gt;set_slp_max_unroll(0);
3170                     poison_rce_post_loop(lpt);
3171                   }
3172                 }
3173               }
3174             }
3175             sw.transform_loop(lpt, true);
3176           }
3177         } else if (cl-&gt;is_main_loop()) {
3178           sw.transform_loop(lpt, true);
3179         }
3180       }
3181     }
3182   }
3183 
3184   // Cleanup any modified bits
3185   _igvn.optimize();
3186 
3187   // disable assert until issue with split_flow_path is resolved (6742111)
3188   // assert(!_has_irreducible_loops || C-&gt;parsed_irreducible_loop() || C-&gt;is_osr_compilation(),
3189   //        &quot;shouldn&#39;t introduce irreducible loops&quot;);
3190 
3191   if (C-&gt;log() != NULL) {
3192     log_loop_tree(_ltree_root, _ltree_root, C-&gt;log());
3193   }
3194 }
3195 
3196 #ifndef PRODUCT
3197 //------------------------------print_statistics-------------------------------
3198 int PhaseIdealLoop::_loop_invokes=0;// Count of PhaseIdealLoop invokes
3199 int PhaseIdealLoop::_loop_work=0; // Sum of PhaseIdealLoop x unique
3200 void PhaseIdealLoop::print_statistics() {
3201   tty-&gt;print_cr(&quot;PhaseIdealLoop=%d, sum _unique=%d&quot;, _loop_invokes, _loop_work);
3202 }
3203 
3204 //------------------------------verify-----------------------------------------
3205 // Build a verify-only PhaseIdealLoop, and see that it agrees with me.
3206 static int fail;                // debug only, so its multi-thread dont care
3207 void PhaseIdealLoop::verify() const {
3208   int old_progress = C-&gt;major_progress();
3209   ResourceMark rm;
3210   PhaseIdealLoop loop_verify( _igvn, this );
3211   VectorSet visited(Thread::current()-&gt;resource_area());
3212 
3213   fail = 0;
3214   verify_compare( C-&gt;root(), &amp;loop_verify, visited );
3215   assert( fail == 0, &quot;verify loops failed&quot; );
3216   // Verify loop structure is the same
3217   _ltree_root-&gt;verify_tree(loop_verify._ltree_root, NULL);
3218   // Reset major-progress.  It was cleared by creating a verify version of
3219   // PhaseIdealLoop.
3220   C-&gt;restore_major_progress(old_progress);
3221 }
3222 
3223 //------------------------------verify_compare---------------------------------
3224 // Make sure me and the given PhaseIdealLoop agree on key data structures
3225 void PhaseIdealLoop::verify_compare( Node *n, const PhaseIdealLoop *loop_verify, VectorSet &amp;visited ) const {
3226   if( !n ) return;
3227   if( visited.test_set( n-&gt;_idx ) ) return;
3228   if( !_nodes[n-&gt;_idx] ) {      // Unreachable
3229     assert( !loop_verify-&gt;_nodes[n-&gt;_idx], &quot;both should be unreachable&quot; );
3230     return;
3231   }
3232 
3233   uint i;
3234   for( i = 0; i &lt; n-&gt;req(); i++ )
3235     verify_compare( n-&gt;in(i), loop_verify, visited );
3236 
3237   // Check the &#39;_nodes&#39; block/loop structure
3238   i = n-&gt;_idx;
3239   if( has_ctrl(n) ) {           // We have control; verify has loop or ctrl
3240     if( _nodes[i] != loop_verify-&gt;_nodes[i] &amp;&amp;
3241         get_ctrl_no_update(n) != loop_verify-&gt;get_ctrl_no_update(n) ) {
3242       tty-&gt;print(&quot;Mismatched control setting for: &quot;);
3243       n-&gt;dump();
3244       if( fail++ &gt; 10 ) return;
3245       Node *c = get_ctrl_no_update(n);
3246       tty-&gt;print(&quot;We have it as: &quot;);
3247       if( c-&gt;in(0) ) c-&gt;dump();
3248         else tty-&gt;print_cr(&quot;N%d&quot;,c-&gt;_idx);
3249       tty-&gt;print(&quot;Verify thinks: &quot;);
3250       if( loop_verify-&gt;has_ctrl(n) )
3251         loop_verify-&gt;get_ctrl_no_update(n)-&gt;dump();
3252       else
3253         loop_verify-&gt;get_loop_idx(n)-&gt;dump();
3254       tty-&gt;cr();
3255     }
3256   } else {                    // We have a loop
3257     IdealLoopTree *us = get_loop_idx(n);
3258     if( loop_verify-&gt;has_ctrl(n) ) {
3259       tty-&gt;print(&quot;Mismatched loop setting for: &quot;);
3260       n-&gt;dump();
3261       if( fail++ &gt; 10 ) return;
3262       tty-&gt;print(&quot;We have it as: &quot;);
3263       us-&gt;dump();
3264       tty-&gt;print(&quot;Verify thinks: &quot;);
3265       loop_verify-&gt;get_ctrl_no_update(n)-&gt;dump();
3266       tty-&gt;cr();
3267     } else if (!C-&gt;major_progress()) {
3268       // Loop selection can be messed up if we did a major progress
3269       // operation, like split-if.  Do not verify in that case.
3270       IdealLoopTree *them = loop_verify-&gt;get_loop_idx(n);
3271       if( us-&gt;_head != them-&gt;_head ||  us-&gt;_tail != them-&gt;_tail ) {
3272         tty-&gt;print(&quot;Unequals loops for: &quot;);
3273         n-&gt;dump();
3274         if( fail++ &gt; 10 ) return;
3275         tty-&gt;print(&quot;We have it as: &quot;);
3276         us-&gt;dump();
3277         tty-&gt;print(&quot;Verify thinks: &quot;);
3278         them-&gt;dump();
3279         tty-&gt;cr();
3280       }
3281     }
3282   }
3283 
3284   // Check for immediate dominators being equal
3285   if( i &gt;= _idom_size ) {
3286     if( !n-&gt;is_CFG() ) return;
3287     tty-&gt;print(&quot;CFG Node with no idom: &quot;);
3288     n-&gt;dump();
3289     return;
3290   }
3291   if( !n-&gt;is_CFG() ) return;
3292   if( n == C-&gt;root() ) return; // No IDOM here
3293 
3294   assert(n-&gt;_idx == i, &quot;sanity&quot;);
3295   Node *id = idom_no_update(n);
3296   if( id != loop_verify-&gt;idom_no_update(n) ) {
3297     tty-&gt;print(&quot;Unequals idoms for: &quot;);
3298     n-&gt;dump();
3299     if( fail++ &gt; 10 ) return;
3300     tty-&gt;print(&quot;We have it as: &quot;);
3301     id-&gt;dump();
3302     tty-&gt;print(&quot;Verify thinks: &quot;);
3303     loop_verify-&gt;idom_no_update(n)-&gt;dump();
3304     tty-&gt;cr();
3305   }
3306 
3307 }
3308 
3309 //------------------------------verify_tree------------------------------------
3310 // Verify that tree structures match.  Because the CFG can change, siblings
3311 // within the loop tree can be reordered.  We attempt to deal with that by
3312 // reordering the verify&#39;s loop tree if possible.
3313 void IdealLoopTree::verify_tree(IdealLoopTree *loop, const IdealLoopTree *parent) const {
3314   assert( _parent == parent, &quot;Badly formed loop tree&quot; );
3315 
3316   // Siblings not in same order?  Attempt to re-order.
3317   if( _head != loop-&gt;_head ) {
3318     // Find _next pointer to update
3319     IdealLoopTree **pp = &amp;loop-&gt;_parent-&gt;_child;
3320     while( *pp != loop )
3321       pp = &amp;((*pp)-&gt;_next);
3322     // Find proper sibling to be next
3323     IdealLoopTree **nn = &amp;loop-&gt;_next;
3324     while( (*nn) &amp;&amp; (*nn)-&gt;_head != _head )
3325       nn = &amp;((*nn)-&gt;_next);
3326 
3327     // Check for no match.
3328     if( !(*nn) ) {
3329       // Annoyingly, irreducible loops can pick different headers
3330       // after a major_progress operation, so the rest of the loop
3331       // tree cannot be matched.
3332       if (_irreducible &amp;&amp; Compile::current()-&gt;major_progress())  return;
3333       assert( 0, &quot;failed to match loop tree&quot; );
3334     }
3335 
3336     // Move (*nn) to (*pp)
3337     IdealLoopTree *hit = *nn;
3338     *nn = hit-&gt;_next;
3339     hit-&gt;_next = loop;
3340     *pp = loop;
3341     loop = hit;
3342     // Now try again to verify
3343   }
3344 
3345   assert( _head  == loop-&gt;_head , &quot;mismatched loop head&quot; );
3346   Node *tail = _tail;           // Inline a non-updating version of
3347   while( !tail-&gt;in(0) )         // the &#39;tail()&#39; call.
3348     tail = tail-&gt;in(1);
3349   assert( tail == loop-&gt;_tail, &quot;mismatched loop tail&quot; );
3350 
3351   // Counted loops that are guarded should be able to find their guards
3352   if( _head-&gt;is_CountedLoop() &amp;&amp; _head-&gt;as_CountedLoop()-&gt;is_main_loop() ) {
3353     CountedLoopNode *cl = _head-&gt;as_CountedLoop();
3354     Node *init = cl-&gt;init_trip();
3355     Node *ctrl = cl-&gt;in(LoopNode::EntryControl);
3356     assert( ctrl-&gt;Opcode() == Op_IfTrue || ctrl-&gt;Opcode() == Op_IfFalse, &quot;&quot; );
3357     Node *iff  = ctrl-&gt;in(0);
3358     assert( iff-&gt;Opcode() == Op_If, &quot;&quot; );
3359     Node *bol  = iff-&gt;in(1);
3360     assert( bol-&gt;Opcode() == Op_Bool, &quot;&quot; );
3361     Node *cmp  = bol-&gt;in(1);
3362     assert( cmp-&gt;Opcode() == Op_CmpI, &quot;&quot; );
3363     Node *add  = cmp-&gt;in(1);
3364     Node *opaq;
3365     if( add-&gt;Opcode() == Op_Opaque1 ) {
3366       opaq = add;
3367     } else {
3368       assert( add-&gt;Opcode() == Op_AddI || add-&gt;Opcode() == Op_ConI , &quot;&quot; );
3369       assert( add == init, &quot;&quot; );
3370       opaq = cmp-&gt;in(2);
3371     }
3372     assert( opaq-&gt;Opcode() == Op_Opaque1, &quot;&quot; );
3373 
3374   }
3375 
3376   if (_child != NULL)  _child-&gt;verify_tree(loop-&gt;_child, this);
3377   if (_next  != NULL)  _next -&gt;verify_tree(loop-&gt;_next,  parent);
3378   // Innermost loops need to verify loop bodies,
3379   // but only if no &#39;major_progress&#39;
3380   int fail = 0;
3381   if (!Compile::current()-&gt;major_progress() &amp;&amp; _child == NULL) {
3382     for( uint i = 0; i &lt; _body.size(); i++ ) {
3383       Node *n = _body.at(i);
3384       if (n-&gt;outcnt() == 0)  continue; // Ignore dead
3385       uint j;
3386       for( j = 0; j &lt; loop-&gt;_body.size(); j++ )
3387         if( loop-&gt;_body.at(j) == n )
3388           break;
3389       if( j == loop-&gt;_body.size() ) { // Not found in loop body
3390         // Last ditch effort to avoid assertion: Its possible that we
3391         // have some users (so outcnt not zero) but are still dead.
3392         // Try to find from root.
3393         if (Compile::current()-&gt;root()-&gt;find(n-&gt;_idx)) {
3394           fail++;
3395           tty-&gt;print(&quot;We have that verify does not: &quot;);
3396           n-&gt;dump();
3397         }
3398       }
3399     }
3400     for( uint i2 = 0; i2 &lt; loop-&gt;_body.size(); i2++ ) {
3401       Node *n = loop-&gt;_body.at(i2);
3402       if (n-&gt;outcnt() == 0)  continue; // Ignore dead
3403       uint j;
3404       for( j = 0; j &lt; _body.size(); j++ )
3405         if( _body.at(j) == n )
3406           break;
3407       if( j == _body.size() ) { // Not found in loop body
3408         // Last ditch effort to avoid assertion: Its possible that we
3409         // have some users (so outcnt not zero) but are still dead.
3410         // Try to find from root.
3411         if (Compile::current()-&gt;root()-&gt;find(n-&gt;_idx)) {
3412           fail++;
3413           tty-&gt;print(&quot;Verify has that we do not: &quot;);
3414           n-&gt;dump();
3415         }
3416       }
3417     }
3418     assert( !fail, &quot;loop body mismatch&quot; );
3419   }
3420 }
3421 
3422 #endif
3423 
3424 //------------------------------set_idom---------------------------------------
3425 void PhaseIdealLoop::set_idom(Node* d, Node* n, uint dom_depth) {
3426   uint idx = d-&gt;_idx;
3427   if (idx &gt;= _idom_size) {
3428     uint newsize = next_power_of_2(idx);
3429     _idom      = REALLOC_RESOURCE_ARRAY( Node*,     _idom,_idom_size,newsize);
3430     _dom_depth = REALLOC_RESOURCE_ARRAY( uint, _dom_depth,_idom_size,newsize);
3431     memset( _dom_depth + _idom_size, 0, (newsize - _idom_size) * sizeof(uint) );
3432     _idom_size = newsize;
3433   }
3434   _idom[idx] = n;
3435   _dom_depth[idx] = dom_depth;
3436 }
3437 
3438 //------------------------------recompute_dom_depth---------------------------------------
3439 // The dominator tree is constructed with only parent pointers.
3440 // This recomputes the depth in the tree by first tagging all
3441 // nodes as &quot;no depth yet&quot; marker.  The next pass then runs up
3442 // the dom tree from each node marked &quot;no depth yet&quot;, and computes
3443 // the depth on the way back down.
3444 void PhaseIdealLoop::recompute_dom_depth() {
3445   uint no_depth_marker = C-&gt;unique();
3446   uint i;
3447   // Initialize depth to &quot;no depth yet&quot; and realize all lazy updates
3448   for (i = 0; i &lt; _idom_size; i++) {
3449     // Only indices with a _dom_depth has a Node* or NULL (otherwise uninitalized).
3450     if (_dom_depth[i] &gt; 0 &amp;&amp; _idom[i] != NULL) {
3451       _dom_depth[i] = no_depth_marker;
3452 
3453       // heal _idom if it has a fwd mapping in _nodes
3454       if (_idom[i]-&gt;in(0) == NULL) {
3455         idom(i);
3456       }
3457     }
3458   }
3459   if (_dom_stk == NULL) {
3460     uint init_size = C-&gt;live_nodes() / 100; // Guess that 1/100 is a reasonable initial size.
3461     if (init_size &lt; 10) init_size = 10;
3462     _dom_stk = new GrowableArray&lt;uint&gt;(init_size);
3463   }
3464   // Compute new depth for each node.
3465   for (i = 0; i &lt; _idom_size; i++) {
3466     uint j = i;
3467     // Run up the dom tree to find a node with a depth
3468     while (_dom_depth[j] == no_depth_marker) {
3469       _dom_stk-&gt;push(j);
3470       j = _idom[j]-&gt;_idx;
3471     }
3472     // Compute the depth on the way back down this tree branch
3473     uint dd = _dom_depth[j] + 1;
3474     while (_dom_stk-&gt;length() &gt; 0) {
3475       uint j = _dom_stk-&gt;pop();
3476       _dom_depth[j] = dd;
3477       dd++;
3478     }
3479   }
3480 }
3481 
3482 //------------------------------sort-------------------------------------------
3483 // Insert &#39;loop&#39; into the existing loop tree.  &#39;innermost&#39; is a leaf of the
3484 // loop tree, not the root.
3485 IdealLoopTree *PhaseIdealLoop::sort( IdealLoopTree *loop, IdealLoopTree *innermost ) {
3486   if( !innermost ) return loop; // New innermost loop
3487 
3488   int loop_preorder = get_preorder(loop-&gt;_head); // Cache pre-order number
3489   assert( loop_preorder, &quot;not yet post-walked loop&quot; );
3490   IdealLoopTree **pp = &amp;innermost;      // Pointer to previous next-pointer
3491   IdealLoopTree *l = *pp;               // Do I go before or after &#39;l&#39;?
3492 
3493   // Insert at start of list
3494   while( l ) {                  // Insertion sort based on pre-order
3495     if( l == loop ) return innermost; // Already on list!
3496     int l_preorder = get_preorder(l-&gt;_head); // Cache pre-order number
3497     assert( l_preorder, &quot;not yet post-walked l&quot; );
3498     // Check header pre-order number to figure proper nesting
3499     if( loop_preorder &gt; l_preorder )
3500       break;                    // End of insertion
3501     // If headers tie (e.g., shared headers) check tail pre-order numbers.
3502     // Since I split shared headers, you&#39;d think this could not happen.
3503     // BUT: I must first do the preorder numbering before I can discover I
3504     // have shared headers, so the split headers all get the same preorder
3505     // number as the RegionNode they split from.
3506     if( loop_preorder == l_preorder &amp;&amp;
3507         get_preorder(loop-&gt;_tail) &lt; get_preorder(l-&gt;_tail) )
3508       break;                    // Also check for shared headers (same pre#)
3509     pp = &amp;l-&gt;_parent;           // Chain up list
3510     l = *pp;
3511   }
3512   // Link into list
3513   // Point predecessor to me
3514   *pp = loop;
3515   // Point me to successor
3516   IdealLoopTree *p = loop-&gt;_parent;
3517   loop-&gt;_parent = l;            // Point me to successor
3518   if( p ) sort( p, innermost ); // Insert my parents into list as well
3519   return innermost;
3520 }
3521 
3522 //------------------------------build_loop_tree--------------------------------
3523 // I use a modified Vick/Tarjan algorithm.  I need pre- and a post- visit
3524 // bits.  The _nodes[] array is mapped by Node index and holds a NULL for
3525 // not-yet-pre-walked, pre-order # for pre-but-not-post-walked and holds the
3526 // tightest enclosing IdealLoopTree for post-walked.
3527 //
3528 // During my forward walk I do a short 1-layer lookahead to see if I can find
3529 // a loop backedge with that doesn&#39;t have any work on the backedge.  This
3530 // helps me construct nested loops with shared headers better.
3531 //
3532 // Once I&#39;ve done the forward recursion, I do the post-work.  For each child
3533 // I check to see if there is a backedge.  Backedges define a loop!  I
3534 // insert an IdealLoopTree at the target of the backedge.
3535 //
3536 // During the post-work I also check to see if I have several children
3537 // belonging to different loops.  If so, then this Node is a decision point
3538 // where control flow can choose to change loop nests.  It is at this
3539 // decision point where I can figure out how loops are nested.  At this
3540 // time I can properly order the different loop nests from my children.
3541 // Note that there may not be any backedges at the decision point!
3542 //
3543 // Since the decision point can be far removed from the backedges, I can&#39;t
3544 // order my loops at the time I discover them.  Thus at the decision point
3545 // I need to inspect loop header pre-order numbers to properly nest my
3546 // loops.  This means I need to sort my childrens&#39; loops by pre-order.
3547 // The sort is of size number-of-control-children, which generally limits
3548 // it to size 2 (i.e., I just choose between my 2 target loops).
3549 void PhaseIdealLoop::build_loop_tree() {
3550   // Allocate stack of size C-&gt;live_nodes()/2 to avoid frequent realloc
3551   GrowableArray &lt;Node *&gt; bltstack(C-&gt;live_nodes() &gt;&gt; 1);
3552   Node *n = C-&gt;root();
3553   bltstack.push(n);
3554   int pre_order = 1;
3555   int stack_size;
3556 
3557   while ( ( stack_size = bltstack.length() ) != 0 ) {
3558     n = bltstack.top(); // Leave node on stack
3559     if ( !is_visited(n) ) {
3560       // ---- Pre-pass Work ----
3561       // Pre-walked but not post-walked nodes need a pre_order number.
3562 
3563       set_preorder_visited( n, pre_order ); // set as visited
3564 
3565       // ---- Scan over children ----
3566       // Scan first over control projections that lead to loop headers.
3567       // This helps us find inner-to-outer loops with shared headers better.
3568 
3569       // Scan children&#39;s children for loop headers.
3570       for ( int i = n-&gt;outcnt() - 1; i &gt;= 0; --i ) {
3571         Node* m = n-&gt;raw_out(i);       // Child
3572         if( m-&gt;is_CFG() &amp;&amp; !is_visited(m) ) { // Only for CFG children
3573           // Scan over children&#39;s children to find loop
3574           for (DUIterator_Fast jmax, j = m-&gt;fast_outs(jmax); j &lt; jmax; j++) {
3575             Node* l = m-&gt;fast_out(j);
3576             if( is_visited(l) &amp;&amp;       // Been visited?
3577                 !is_postvisited(l) &amp;&amp;  // But not post-visited
3578                 get_preorder(l) &lt; pre_order ) { // And smaller pre-order
3579               // Found!  Scan the DFS down this path before doing other paths
3580               bltstack.push(m);
3581               break;
3582             }
3583           }
3584         }
3585       }
3586       pre_order++;
3587     }
3588     else if ( !is_postvisited(n) ) {
3589       // Note: build_loop_tree_impl() adds out edges on rare occasions,
3590       // such as com.sun.rsasign.am::a.
3591       // For non-recursive version, first, process current children.
3592       // On next iteration, check if additional children were added.
3593       for ( int k = n-&gt;outcnt() - 1; k &gt;= 0; --k ) {
3594         Node* u = n-&gt;raw_out(k);
3595         if ( u-&gt;is_CFG() &amp;&amp; !is_visited(u) ) {
3596           bltstack.push(u);
3597         }
3598       }
3599       if ( bltstack.length() == stack_size ) {
3600         // There were no additional children, post visit node now
3601         (void)bltstack.pop(); // Remove node from stack
3602         pre_order = build_loop_tree_impl( n, pre_order );
3603         // Check for bailout
3604         if (C-&gt;failing()) {
3605           return;
3606         }
3607         // Check to grow _preorders[] array for the case when
3608         // build_loop_tree_impl() adds new nodes.
3609         check_grow_preorders();
3610       }
3611     }
3612     else {
3613       (void)bltstack.pop(); // Remove post-visited node from stack
3614     }
3615   }
3616 }
3617 
3618 //------------------------------build_loop_tree_impl---------------------------
3619 int PhaseIdealLoop::build_loop_tree_impl( Node *n, int pre_order ) {
3620   // ---- Post-pass Work ----
3621   // Pre-walked but not post-walked nodes need a pre_order number.
3622 
3623   // Tightest enclosing loop for this Node
3624   IdealLoopTree *innermost = NULL;
3625 
3626   // For all children, see if any edge is a backedge.  If so, make a loop
3627   // for it.  Then find the tightest enclosing loop for the self Node.
3628   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
3629     Node* m = n-&gt;fast_out(i);   // Child
3630     if( n == m ) continue;      // Ignore control self-cycles
3631     if( !m-&gt;is_CFG() ) continue;// Ignore non-CFG edges
3632 
3633     IdealLoopTree *l;           // Child&#39;s loop
3634     if( !is_postvisited(m) ) {  // Child visited but not post-visited?
3635       // Found a backedge
3636       assert( get_preorder(m) &lt; pre_order, &quot;should be backedge&quot; );
3637       // Check for the RootNode, which is already a LoopNode and is allowed
3638       // to have multiple &quot;backedges&quot;.
3639       if( m == C-&gt;root()) {     // Found the root?
3640         l = _ltree_root;        // Root is the outermost LoopNode
3641       } else {                  // Else found a nested loop
3642         // Insert a LoopNode to mark this loop.
3643         l = new IdealLoopTree(this, m, n);
3644       } // End of Else found a nested loop
3645       if( !has_loop(m) )        // If &#39;m&#39; does not already have a loop set
3646         set_loop(m, l);         // Set loop header to loop now
3647 
3648     } else {                    // Else not a nested loop
3649       if( !_nodes[m-&gt;_idx] ) continue; // Dead code has no loop
3650       l = get_loop(m);          // Get previously determined loop
3651       // If successor is header of a loop (nest), move up-loop till it
3652       // is a member of some outer enclosing loop.  Since there are no
3653       // shared headers (I&#39;ve split them already) I only need to go up
3654       // at most 1 level.
3655       while( l &amp;&amp; l-&gt;_head == m ) // Successor heads loop?
3656         l = l-&gt;_parent;         // Move up 1 for me
3657       // If this loop is not properly parented, then this loop
3658       // has no exit path out, i.e. its an infinite loop.
3659       if( !l ) {
3660         // Make loop &quot;reachable&quot; from root so the CFG is reachable.  Basically
3661         // insert a bogus loop exit that is never taken.  &#39;m&#39;, the loop head,
3662         // points to &#39;n&#39;, one (of possibly many) fall-in paths.  There may be
3663         // many backedges as well.
3664 
3665         // Here I set the loop to be the root loop.  I could have, after
3666         // inserting a bogus loop exit, restarted the recursion and found my
3667         // new loop exit.  This would make the infinite loop a first-class
3668         // loop and it would then get properly optimized.  What&#39;s the use of
3669         // optimizing an infinite loop?
3670         l = _ltree_root;        // Oops, found infinite loop
3671 
3672         if (!_verify_only) {
3673           // Insert the NeverBranch between &#39;m&#39; and it&#39;s control user.
3674           NeverBranchNode *iff = new NeverBranchNode( m );
3675           _igvn.register_new_node_with_optimizer(iff);
3676           set_loop(iff, l);
3677           Node *if_t = new CProjNode( iff, 0 );
3678           _igvn.register_new_node_with_optimizer(if_t);
3679           set_loop(if_t, l);
3680 
3681           Node* cfg = NULL;       // Find the One True Control User of m
3682           for (DUIterator_Fast jmax, j = m-&gt;fast_outs(jmax); j &lt; jmax; j++) {
3683             Node* x = m-&gt;fast_out(j);
3684             if (x-&gt;is_CFG() &amp;&amp; x != m &amp;&amp; x != iff)
3685               { cfg = x; break; }
3686           }
3687           assert(cfg != NULL, &quot;must find the control user of m&quot;);
3688           uint k = 0;             // Probably cfg-&gt;in(0)
3689           while( cfg-&gt;in(k) != m ) k++; // But check incase cfg is a Region
3690           cfg-&gt;set_req( k, if_t ); // Now point to NeverBranch
3691           _igvn._worklist.push(cfg);
3692 
3693           // Now create the never-taken loop exit
3694           Node *if_f = new CProjNode( iff, 1 );
3695           _igvn.register_new_node_with_optimizer(if_f);
3696           set_loop(if_f, l);
3697           // Find frame ptr for Halt.  Relies on the optimizer
3698           // V-N&#39;ing.  Easier and quicker than searching through
3699           // the program structure.
3700           Node *frame = new ParmNode( C-&gt;start(), TypeFunc::FramePtr );
3701           _igvn.register_new_node_with_optimizer(frame);
3702           // Halt &amp; Catch Fire
3703           Node* halt = new HaltNode(if_f, frame, &quot;never-taken loop exit reached&quot;);
3704           _igvn.register_new_node_with_optimizer(halt);
3705           set_loop(halt, l);
3706           C-&gt;root()-&gt;add_req(halt);
3707         }
3708         set_loop(C-&gt;root(), _ltree_root);
3709       }
3710     }
3711     // Weeny check for irreducible.  This child was already visited (this
3712     // IS the post-work phase).  Is this child&#39;s loop header post-visited
3713     // as well?  If so, then I found another entry into the loop.
3714     if (!_verify_only) {
3715       while( is_postvisited(l-&gt;_head) ) {
3716         // found irreducible
3717         l-&gt;_irreducible = 1; // = true
3718         l = l-&gt;_parent;
3719         _has_irreducible_loops = true;
3720         // Check for bad CFG here to prevent crash, and bailout of compile
3721         if (l == NULL) {
3722           C-&gt;record_method_not_compilable(&quot;unhandled CFG detected during loop optimization&quot;);
3723           return pre_order;
3724         }
3725       }
3726       C-&gt;set_has_irreducible_loop(_has_irreducible_loops);
3727     }
3728 
3729     // This Node might be a decision point for loops.  It is only if
3730     // it&#39;s children belong to several different loops.  The sort call
3731     // does a trivial amount of work if there is only 1 child or all
3732     // children belong to the same loop.  If however, the children
3733     // belong to different loops, the sort call will properly set the
3734     // _parent pointers to show how the loops nest.
3735     //
3736     // In any case, it returns the tightest enclosing loop.
3737     innermost = sort( l, innermost );
3738   }
3739 
3740   // Def-use info will have some dead stuff; dead stuff will have no
3741   // loop decided on.
3742 
3743   // Am I a loop header?  If so fix up my parent&#39;s child and next ptrs.
3744   if( innermost &amp;&amp; innermost-&gt;_head == n ) {
3745     assert( get_loop(n) == innermost, &quot;&quot; );
3746     IdealLoopTree *p = innermost-&gt;_parent;
3747     IdealLoopTree *l = innermost;
3748     while( p &amp;&amp; l-&gt;_head == n ) {
3749       l-&gt;_next = p-&gt;_child;     // Put self on parents &#39;next child&#39;
3750       p-&gt;_child = l;            // Make self as first child of parent
3751       l = p;                    // Now walk up the parent chain
3752       p = l-&gt;_parent;
3753     }
3754   } else {
3755     // Note that it is possible for a LoopNode to reach here, if the
3756     // backedge has been made unreachable (hence the LoopNode no longer
3757     // denotes a Loop, and will eventually be removed).
3758 
3759     // Record tightest enclosing loop for self.  Mark as post-visited.
3760     set_loop(n, innermost);
3761     // Also record has_call flag early on
3762     if( innermost ) {
3763       if( n-&gt;is_Call() &amp;&amp; !n-&gt;is_CallLeaf() &amp;&amp; !n-&gt;is_macro() ) {
3764         // Do not count uncommon calls
3765         if( !n-&gt;is_CallStaticJava() || !n-&gt;as_CallStaticJava()-&gt;_name ) {
3766           Node *iff = n-&gt;in(0)-&gt;in(0);
3767           // No any calls for vectorized loops.
3768           if( UseSuperWord || !iff-&gt;is_If() ||
3769               (n-&gt;in(0)-&gt;Opcode() == Op_IfFalse &amp;&amp;
3770                (1.0 - iff-&gt;as_If()-&gt;_prob) &gt;= 0.01) ||
3771               (iff-&gt;as_If()-&gt;_prob &gt;= 0.01) )
3772             innermost-&gt;_has_call = 1;
3773         }
3774       } else if( n-&gt;is_Allocate() &amp;&amp; n-&gt;as_Allocate()-&gt;_is_scalar_replaceable ) {
3775         // Disable loop optimizations if the loop has a scalar replaceable
3776         // allocation. This disabling may cause a potential performance lost
3777         // if the allocation is not eliminated for some reason.
3778         innermost-&gt;_allow_optimizations = false;
3779         innermost-&gt;_has_call = 1; // = true
3780       } else if (n-&gt;Opcode() == Op_SafePoint) {
3781         // Record all safepoints in this loop.
3782         if (innermost-&gt;_safepts == NULL) innermost-&gt;_safepts = new Node_List();
3783         innermost-&gt;_safepts-&gt;push(n);
3784       }
3785     }
3786   }
3787 
3788   // Flag as post-visited now
3789   set_postvisited(n);
3790   return pre_order;
3791 }
3792 
3793 
3794 //------------------------------build_loop_early-------------------------------
3795 // Put Data nodes into some loop nest, by setting the _nodes[]-&gt;loop mapping.
3796 // First pass computes the earliest controlling node possible.  This is the
3797 // controlling input with the deepest dominating depth.
3798 void PhaseIdealLoop::build_loop_early( VectorSet &amp;visited, Node_List &amp;worklist, Node_Stack &amp;nstack ) {
3799   while (worklist.size() != 0) {
3800     // Use local variables nstack_top_n &amp; nstack_top_i to cache values
3801     // on nstack&#39;s top.
3802     Node *nstack_top_n = worklist.pop();
3803     uint  nstack_top_i = 0;
3804 //while_nstack_nonempty:
3805     while (true) {
3806       // Get parent node and next input&#39;s index from stack&#39;s top.
3807       Node  *n = nstack_top_n;
3808       uint   i = nstack_top_i;
3809       uint cnt = n-&gt;req(); // Count of inputs
3810       if (i == 0) {        // Pre-process the node.
3811         if( has_node(n) &amp;&amp;            // Have either loop or control already?
3812             !has_ctrl(n) ) {          // Have loop picked out already?
3813           // During &quot;merge_many_backedges&quot; we fold up several nested loops
3814           // into a single loop.  This makes the members of the original
3815           // loop bodies pointing to dead loops; they need to move up
3816           // to the new UNION&#39;d larger loop.  I set the _head field of these
3817           // dead loops to NULL and the _parent field points to the owning
3818           // loop.  Shades of UNION-FIND algorithm.
3819           IdealLoopTree *ilt;
3820           while( !(ilt = get_loop(n))-&gt;_head ) {
3821             // Normally I would use a set_loop here.  But in this one special
3822             // case, it is legal (and expected) to change what loop a Node
3823             // belongs to.
3824             _nodes.map(n-&gt;_idx, (Node*)(ilt-&gt;_parent) );
3825           }
3826           // Remove safepoints ONLY if I&#39;ve already seen I don&#39;t need one.
3827           // (the old code here would yank a 2nd safepoint after seeing a
3828           // first one, even though the 1st did not dominate in the loop body
3829           // and thus could be avoided indefinitely)
3830           if( !_verify_only &amp;&amp; !_verify_me &amp;&amp; ilt-&gt;_has_sfpt &amp;&amp; n-&gt;Opcode() == Op_SafePoint &amp;&amp;
3831               is_deleteable_safept(n)) {
3832             Node *in = n-&gt;in(TypeFunc::Control);
3833             lazy_replace(n,in);       // Pull safepoint now
3834             if (ilt-&gt;_safepts != NULL) {
3835               ilt-&gt;_safepts-&gt;yank(n);
3836             }
3837             // Carry on with the recursion &quot;as if&quot; we are walking
3838             // only the control input
3839             if( !visited.test_set( in-&gt;_idx ) ) {
3840               worklist.push(in);      // Visit this guy later, using worklist
3841             }
3842             // Get next node from nstack:
3843             // - skip n&#39;s inputs processing by setting i &gt; cnt;
3844             // - we also will not call set_early_ctrl(n) since
3845             //   has_node(n) == true (see the condition above).
3846             i = cnt + 1;
3847           }
3848         }
3849       } // if (i == 0)
3850 
3851       // Visit all inputs
3852       bool done = true;       // Assume all n&#39;s inputs will be processed
3853       while (i &lt; cnt) {
3854         Node *in = n-&gt;in(i);
3855         ++i;
3856         if (in == NULL) continue;
3857         if (in-&gt;pinned() &amp;&amp; !in-&gt;is_CFG())
3858           set_ctrl(in, in-&gt;in(0));
3859         int is_visited = visited.test_set( in-&gt;_idx );
3860         if (!has_node(in)) {  // No controlling input yet?
3861           assert( !in-&gt;is_CFG(), &quot;CFG Node with no controlling input?&quot; );
3862           assert( !is_visited, &quot;visit only once&quot; );
3863           nstack.push(n, i);  // Save parent node and next input&#39;s index.
3864           nstack_top_n = in;  // Process current input now.
3865           nstack_top_i = 0;
3866           done = false;       // Not all n&#39;s inputs processed.
3867           break; // continue while_nstack_nonempty;
3868         } else if (!is_visited) {
3869           // This guy has a location picked out for him, but has not yet
3870           // been visited.  Happens to all CFG nodes, for instance.
3871           // Visit him using the worklist instead of recursion, to break
3872           // cycles.  Since he has a location already we do not need to
3873           // find his location before proceeding with the current Node.
3874           worklist.push(in);  // Visit this guy later, using worklist
3875         }
3876       }
3877       if (done) {
3878         // All of n&#39;s inputs have been processed, complete post-processing.
3879 
3880         // Compute earliest point this Node can go.
3881         // CFG, Phi, pinned nodes already know their controlling input.
3882         if (!has_node(n)) {
3883           // Record earliest legal location
3884           set_early_ctrl( n );
3885         }
3886         if (nstack.is_empty()) {
3887           // Finished all nodes on stack.
3888           // Process next node on the worklist.
3889           break;
3890         }
3891         // Get saved parent node and next input&#39;s index.
3892         nstack_top_n = nstack.node();
3893         nstack_top_i = nstack.index();
3894         nstack.pop();
3895       }
3896     } // while (true)
3897   }
3898 }
3899 
3900 //------------------------------dom_lca_internal--------------------------------
3901 // Pair-wise LCA
3902 Node *PhaseIdealLoop::dom_lca_internal( Node *n1, Node *n2 ) const {
3903   if( !n1 ) return n2;          // Handle NULL original LCA
3904   assert( n1-&gt;is_CFG(), &quot;&quot; );
3905   assert( n2-&gt;is_CFG(), &quot;&quot; );
3906   // find LCA of all uses
3907   uint d1 = dom_depth(n1);
3908   uint d2 = dom_depth(n2);
3909   while (n1 != n2) {
3910     if (d1 &gt; d2) {
3911       n1 =      idom(n1);
3912       d1 = dom_depth(n1);
3913     } else if (d1 &lt; d2) {
3914       n2 =      idom(n2);
3915       d2 = dom_depth(n2);
3916     } else {
3917       // Here d1 == d2.  Due to edits of the dominator-tree, sections
3918       // of the tree might have the same depth.  These sections have
3919       // to be searched more carefully.
3920 
3921       // Scan up all the n1&#39;s with equal depth, looking for n2.
3922       Node *t1 = idom(n1);
3923       while (dom_depth(t1) == d1) {
3924         if (t1 == n2)  return n2;
3925         t1 = idom(t1);
3926       }
3927       // Scan up all the n2&#39;s with equal depth, looking for n1.
3928       Node *t2 = idom(n2);
3929       while (dom_depth(t2) == d2) {
3930         if (t2 == n1)  return n1;
3931         t2 = idom(t2);
3932       }
3933       // Move up to a new dominator-depth value as well as up the dom-tree.
3934       n1 = t1;
3935       n2 = t2;
3936       d1 = dom_depth(n1);
3937       d2 = dom_depth(n2);
3938     }
3939   }
3940   return n1;
3941 }
3942 
3943 //------------------------------compute_idom-----------------------------------
3944 // Locally compute IDOM using dom_lca call.  Correct only if the incoming
3945 // IDOMs are correct.
3946 Node *PhaseIdealLoop::compute_idom( Node *region ) const {
3947   assert( region-&gt;is_Region(), &quot;&quot; );
3948   Node *LCA = NULL;
3949   for( uint i = 1; i &lt; region-&gt;req(); i++ ) {
3950     if( region-&gt;in(i) != C-&gt;top() )
3951       LCA = dom_lca( LCA, region-&gt;in(i) );
3952   }
3953   return LCA;
3954 }
3955 
3956 bool PhaseIdealLoop::verify_dominance(Node* n, Node* use, Node* LCA, Node* early) {
3957   bool had_error = false;
3958 #ifdef ASSERT
3959   if (early != C-&gt;root()) {
3960     // Make sure that there&#39;s a dominance path from LCA to early
3961     Node* d = LCA;
3962     while (d != early) {
3963       if (d == C-&gt;root()) {
3964         dump_bad_graph(&quot;Bad graph detected in compute_lca_of_uses&quot;, n, early, LCA);
3965         tty-&gt;print_cr(&quot;*** Use %d isn&#39;t dominated by def %d ***&quot;, use-&gt;_idx, n-&gt;_idx);
3966         had_error = true;
3967         break;
3968       }
3969       d = idom(d);
3970     }
3971   }
3972 #endif
3973   return had_error;
3974 }
3975 
3976 
3977 Node* PhaseIdealLoop::compute_lca_of_uses(Node* n, Node* early, bool verify) {
3978   // Compute LCA over list of uses
3979   bool had_error = false;
3980   Node *LCA = NULL;
3981   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax &amp;&amp; LCA != early; i++) {
3982     Node* c = n-&gt;fast_out(i);
3983     if (_nodes[c-&gt;_idx] == NULL)
3984       continue;                 // Skip the occasional dead node
3985     if( c-&gt;is_Phi() ) {         // For Phis, we must land above on the path
3986       for( uint j=1; j&lt;c-&gt;req(); j++ ) {// For all inputs
3987         if( c-&gt;in(j) == n ) {   // Found matching input?
3988           Node *use = c-&gt;in(0)-&gt;in(j);
3989           if (_verify_only &amp;&amp; use-&gt;is_top()) continue;
3990           LCA = dom_lca_for_get_late_ctrl( LCA, use, n );
3991           if (verify) had_error = verify_dominance(n, use, LCA, early) || had_error;
3992         }
3993       }
3994     } else {
3995       // For CFG data-users, use is in the block just prior
3996       Node *use = has_ctrl(c) ? get_ctrl(c) : c-&gt;in(0);
3997       LCA = dom_lca_for_get_late_ctrl( LCA, use, n );
3998       if (verify) had_error = verify_dominance(n, use, LCA, early) || had_error;
3999     }
4000   }
4001   assert(!had_error, &quot;bad dominance&quot;);
4002   return LCA;
4003 }
4004 
4005 // Check the shape of the graph at the loop entry. In some cases,
4006 // the shape of the graph does not match the shape outlined below.
4007 // That is caused by the Opaque1 node &quot;protecting&quot; the shape of
4008 // the graph being removed by, for example, the IGVN performed
4009 // in PhaseIdealLoop::build_and_optimize().
4010 //
4011 // After the Opaque1 node has been removed, optimizations (e.g., split-if,
4012 // loop unswitching, and IGVN, or a combination of them) can freely change
4013 // the graph&#39;s shape. As a result, the graph shape outlined below cannot
4014 // be guaranteed anymore.
4015 bool PhaseIdealLoop::is_canonical_loop_entry(CountedLoopNode* cl) {
4016   if (!cl-&gt;is_main_loop() &amp;&amp; !cl-&gt;is_post_loop()) {
4017     return false;
4018   }
4019   Node* ctrl = cl-&gt;skip_predicates();
4020 
4021   if (ctrl == NULL || (!ctrl-&gt;is_IfTrue() &amp;&amp; !ctrl-&gt;is_IfFalse())) {
4022     return false;
4023   }
4024   Node* iffm = ctrl-&gt;in(0);
4025   if (iffm == NULL || !iffm-&gt;is_If()) {
4026     return false;
4027   }
4028   Node* bolzm = iffm-&gt;in(1);
4029   if (bolzm == NULL || !bolzm-&gt;is_Bool()) {
4030     return false;
4031   }
4032   Node* cmpzm = bolzm-&gt;in(1);
4033   if (cmpzm == NULL || !cmpzm-&gt;is_Cmp()) {
4034     return false;
4035   }
4036   // compares can get conditionally flipped
4037   bool found_opaque = false;
4038   for (uint i = 1; i &lt; cmpzm-&gt;req(); i++) {
4039     Node* opnd = cmpzm-&gt;in(i);
4040     if (opnd &amp;&amp; opnd-&gt;Opcode() == Op_Opaque1) {
4041       found_opaque = true;
4042       break;
4043     }
4044   }
4045   if (!found_opaque) {
4046     return false;
4047   }
4048   return true;
4049 }
4050 
4051 //------------------------------get_late_ctrl----------------------------------
4052 // Compute latest legal control.
4053 Node *PhaseIdealLoop::get_late_ctrl( Node *n, Node *early ) {
4054   assert(early != NULL, &quot;early control should not be NULL&quot;);
4055 
4056   Node* LCA = compute_lca_of_uses(n, early);
4057 #ifdef ASSERT
4058   if (LCA == C-&gt;root() &amp;&amp; LCA != early) {
4059     // def doesn&#39;t dominate uses so print some useful debugging output
4060     compute_lca_of_uses(n, early, true);
4061   }
4062 #endif
4063 
4064   // if this is a load, check for anti-dependent stores
4065   // We use a conservative algorithm to identify potential interfering
4066   // instructions and for rescheduling the load.  The users of the memory
4067   // input of this load are examined.  Any use which is not a load and is
4068   // dominated by early is considered a potentially interfering store.
4069   // This can produce false positives.
4070   if (n-&gt;is_Load() &amp;&amp; LCA != early) {
4071     int load_alias_idx = C-&gt;get_alias_index(n-&gt;adr_type());
4072     if (C-&gt;alias_type(load_alias_idx)-&gt;is_rewritable()) {
4073 
4074       Node_List worklist;
4075 
4076       Node *mem = n-&gt;in(MemNode::Memory);
4077       for (DUIterator_Fast imax, i = mem-&gt;fast_outs(imax); i &lt; imax; i++) {
4078         Node* s = mem-&gt;fast_out(i);
4079         worklist.push(s);
4080       }
4081       while(worklist.size() != 0 &amp;&amp; LCA != early) {
4082         Node* s = worklist.pop();
4083         if (s-&gt;is_Load() || s-&gt;Opcode() == Op_SafePoint ||
4084             (s-&gt;is_CallStaticJava() &amp;&amp; s-&gt;as_CallStaticJava()-&gt;uncommon_trap_request() != 0)) {
4085           continue;
4086         } else if (s-&gt;is_MergeMem()) {
4087           for (DUIterator_Fast imax, i = s-&gt;fast_outs(imax); i &lt; imax; i++) {
4088             Node* s1 = s-&gt;fast_out(i);
4089             worklist.push(s1);
4090           }
4091         } else {
4092           Node *sctrl = has_ctrl(s) ? get_ctrl(s) : s-&gt;in(0);
<a name="11" id="anc11"></a><span class="line-modified">4093           const TypePtr* adr_type = s-&gt;adr_type();</span>
<span class="line-modified">4094           if (s-&gt;is_ArrayCopy()) {</span>
<span class="line-added">4095             // Copy to known instance needs destination type to test for aliasing</span>
<span class="line-added">4096             const TypePtr* dest_type = s-&gt;as_ArrayCopy()-&gt;_dest_type;</span>
<span class="line-added">4097             if (dest_type != TypeOopPtr::BOTTOM) {</span>
<span class="line-added">4098               adr_type = dest_type;</span>
<span class="line-added">4099             }</span>
<span class="line-added">4100           }</span>
<span class="line-added">4101           assert(sctrl != NULL || !s-&gt;is_reachable_from_root(), &quot;must have control&quot;);</span>
<span class="line-added">4102           if (sctrl != NULL &amp;&amp; !sctrl-&gt;is_top() &amp;&amp; C-&gt;can_alias(adr_type, load_alias_idx) &amp;&amp; is_dominator(early, sctrl)) {</span>
4103             LCA = dom_lca_for_get_late_ctrl(LCA, sctrl, n);
4104           }
4105         }
4106       }
4107     }
4108   }
4109 
4110   assert(LCA == find_non_split_ctrl(LCA), &quot;unexpected late control&quot;);
4111   return LCA;
4112 }
4113 
4114 // true if CFG node d dominates CFG node n
4115 bool PhaseIdealLoop::is_dominator(Node *d, Node *n) {
4116   if (d == n)
4117     return true;
4118   assert(d-&gt;is_CFG() &amp;&amp; n-&gt;is_CFG(), &quot;must have CFG nodes&quot;);
4119   uint dd = dom_depth(d);
4120   while (dom_depth(n) &gt;= dd) {
4121     if (n == d)
4122       return true;
4123     n = idom(n);
4124   }
4125   return false;
4126 }
4127 
4128 //------------------------------dom_lca_for_get_late_ctrl_internal-------------
4129 // Pair-wise LCA with tags.
4130 // Tag each index with the node &#39;tag&#39; currently being processed
4131 // before advancing up the dominator chain using idom().
4132 // Later calls that find a match to &#39;tag&#39; know that this path has already
4133 // been considered in the current LCA (which is input &#39;n1&#39; by convention).
4134 // Since get_late_ctrl() is only called once for each node, the tag array
4135 // does not need to be cleared between calls to get_late_ctrl().
4136 // Algorithm trades a larger constant factor for better asymptotic behavior
4137 //
4138 Node *PhaseIdealLoop::dom_lca_for_get_late_ctrl_internal( Node *n1, Node *n2, Node *tag ) {
4139   uint d1 = dom_depth(n1);
4140   uint d2 = dom_depth(n2);
4141 
4142   do {
4143     if (d1 &gt; d2) {
4144       // current lca is deeper than n2
4145       _dom_lca_tags.map(n1-&gt;_idx, tag);
4146       n1 =      idom(n1);
4147       d1 = dom_depth(n1);
4148     } else if (d1 &lt; d2) {
4149       // n2 is deeper than current lca
4150       Node *memo = _dom_lca_tags[n2-&gt;_idx];
4151       if( memo == tag ) {
4152         return n1;    // Return the current LCA
4153       }
4154       _dom_lca_tags.map(n2-&gt;_idx, tag);
4155       n2 =      idom(n2);
4156       d2 = dom_depth(n2);
4157     } else {
4158       // Here d1 == d2.  Due to edits of the dominator-tree, sections
4159       // of the tree might have the same depth.  These sections have
4160       // to be searched more carefully.
4161 
4162       // Scan up all the n1&#39;s with equal depth, looking for n2.
4163       _dom_lca_tags.map(n1-&gt;_idx, tag);
4164       Node *t1 = idom(n1);
4165       while (dom_depth(t1) == d1) {
4166         if (t1 == n2)  return n2;
4167         _dom_lca_tags.map(t1-&gt;_idx, tag);
4168         t1 = idom(t1);
4169       }
4170       // Scan up all the n2&#39;s with equal depth, looking for n1.
4171       _dom_lca_tags.map(n2-&gt;_idx, tag);
4172       Node *t2 = idom(n2);
4173       while (dom_depth(t2) == d2) {
4174         if (t2 == n1)  return n1;
4175         _dom_lca_tags.map(t2-&gt;_idx, tag);
4176         t2 = idom(t2);
4177       }
4178       // Move up to a new dominator-depth value as well as up the dom-tree.
4179       n1 = t1;
4180       n2 = t2;
4181       d1 = dom_depth(n1);
4182       d2 = dom_depth(n2);
4183     }
4184   } while (n1 != n2);
4185   return n1;
4186 }
4187 
4188 //------------------------------init_dom_lca_tags------------------------------
4189 // Tag could be a node&#39;s integer index, 32bits instead of 64bits in some cases
4190 // Intended use does not involve any growth for the array, so it could
4191 // be of fixed size.
4192 void PhaseIdealLoop::init_dom_lca_tags() {
4193   uint limit = C-&gt;unique() + 1;
4194   _dom_lca_tags.map( limit, NULL );
4195 #ifdef ASSERT
4196   for( uint i = 0; i &lt; limit; ++i ) {
4197     assert(_dom_lca_tags[i] == NULL, &quot;Must be distinct from each node pointer&quot;);
4198   }
4199 #endif // ASSERT
4200 }
4201 
4202 //------------------------------clear_dom_lca_tags------------------------------
4203 // Tag could be a node&#39;s integer index, 32bits instead of 64bits in some cases
4204 // Intended use does not involve any growth for the array, so it could
4205 // be of fixed size.
4206 void PhaseIdealLoop::clear_dom_lca_tags() {
4207   uint limit = C-&gt;unique() + 1;
4208   _dom_lca_tags.map( limit, NULL );
4209   _dom_lca_tags.clear();
4210 #ifdef ASSERT
4211   for( uint i = 0; i &lt; limit; ++i ) {
4212     assert(_dom_lca_tags[i] == NULL, &quot;Must be distinct from each node pointer&quot;);
4213   }
4214 #endif // ASSERT
4215 }
4216 
4217 //------------------------------build_loop_late--------------------------------
4218 // Put Data nodes into some loop nest, by setting the _nodes[]-&gt;loop mapping.
4219 // Second pass finds latest legal placement, and ideal loop placement.
4220 void PhaseIdealLoop::build_loop_late( VectorSet &amp;visited, Node_List &amp;worklist, Node_Stack &amp;nstack ) {
4221   while (worklist.size() != 0) {
4222     Node *n = worklist.pop();
4223     // Only visit once
4224     if (visited.test_set(n-&gt;_idx)) continue;
4225     uint cnt = n-&gt;outcnt();
4226     uint   i = 0;
4227     while (true) {
4228       assert( _nodes[n-&gt;_idx], &quot;no dead nodes&quot; );
4229       // Visit all children
4230       if (i &lt; cnt) {
4231         Node* use = n-&gt;raw_out(i);
4232         ++i;
4233         // Check for dead uses.  Aggressively prune such junk.  It might be
4234         // dead in the global sense, but still have local uses so I cannot
4235         // easily call &#39;remove_dead_node&#39;.
4236         if( _nodes[use-&gt;_idx] != NULL || use-&gt;is_top() ) { // Not dead?
4237           // Due to cycles, we might not hit the same fixed point in the verify
4238           // pass as we do in the regular pass.  Instead, visit such phis as
4239           // simple uses of the loop head.
4240           if( use-&gt;in(0) &amp;&amp; (use-&gt;is_CFG() || use-&gt;is_Phi()) ) {
4241             if( !visited.test(use-&gt;_idx) )
4242               worklist.push(use);
4243           } else if( !visited.test_set(use-&gt;_idx) ) {
4244             nstack.push(n, i); // Save parent and next use&#39;s index.
4245             n   = use;         // Process all children of current use.
4246             cnt = use-&gt;outcnt();
4247             i   = 0;
4248           }
4249         } else {
4250           // Do not visit around the backedge of loops via data edges.
4251           // push dead code onto a worklist
4252           _deadlist.push(use);
4253         }
4254       } else {
4255         // All of n&#39;s children have been processed, complete post-processing.
4256         build_loop_late_post(n);
4257         if (nstack.is_empty()) {
4258           // Finished all nodes on stack.
4259           // Process next node on the worklist.
4260           break;
4261         }
4262         // Get saved parent node and next use&#39;s index. Visit the rest of uses.
4263         n   = nstack.node();
4264         cnt = n-&gt;outcnt();
4265         i   = nstack.index();
4266         nstack.pop();
4267       }
4268     }
4269   }
4270 }
4271 
4272 // Verify that no data node is scheduled in the outer loop of a strip
4273 // mined loop.
4274 void PhaseIdealLoop::verify_strip_mined_scheduling(Node *n, Node* least) {
4275 #ifdef ASSERT
4276   if (get_loop(least)-&gt;_nest == 0) {
4277     return;
4278   }
4279   IdealLoopTree* loop = get_loop(least);
4280   Node* head = loop-&gt;_head;
4281   if (head-&gt;is_OuterStripMinedLoop() &amp;&amp;
4282       // Verification can&#39;t be applied to fully built strip mined loops
4283       head-&gt;as_Loop()-&gt;outer_loop_end()-&gt;in(1)-&gt;find_int_con(-1) == 0) {
4284     Node* sfpt = head-&gt;as_Loop()-&gt;outer_safepoint();
4285     ResourceMark rm;
4286     Unique_Node_List wq;
4287     wq.push(sfpt);
4288     for (uint i = 0; i &lt; wq.size(); i++) {
4289       Node *m = wq.at(i);
4290       for (uint i = 1; i &lt; m-&gt;req(); i++) {
4291         Node* nn = m-&gt;in(i);
4292         if (nn == n) {
4293           return;
4294         }
4295         if (nn != NULL &amp;&amp; has_ctrl(nn) &amp;&amp; get_loop(get_ctrl(nn)) == loop) {
4296           wq.push(nn);
4297         }
4298       }
4299     }
4300     ShouldNotReachHere();
4301   }
4302 #endif
4303 }
4304 
4305 
4306 //------------------------------build_loop_late_post---------------------------
4307 // Put Data nodes into some loop nest, by setting the _nodes[]-&gt;loop mapping.
4308 // Second pass finds latest legal placement, and ideal loop placement.
4309 void PhaseIdealLoop::build_loop_late_post(Node *n) {
4310   build_loop_late_post_work(n, true);
4311 }
4312 
4313 void PhaseIdealLoop::build_loop_late_post_work(Node *n, bool pinned) {
4314 
4315   if (n-&gt;req() == 2 &amp;&amp; (n-&gt;Opcode() == Op_ConvI2L || n-&gt;Opcode() == Op_CastII) &amp;&amp; !C-&gt;major_progress() &amp;&amp; !_verify_only) {
4316     _igvn._worklist.push(n);  // Maybe we&#39;ll normalize it, if no more loops.
4317   }
4318 
4319 #ifdef ASSERT
4320   if (_verify_only &amp;&amp; !n-&gt;is_CFG()) {
4321     // Check def-use domination.
4322     compute_lca_of_uses(n, get_ctrl(n), true /* verify */);
4323   }
4324 #endif
4325 
4326   // CFG and pinned nodes already handled
4327   if( n-&gt;in(0) ) {
4328     if( n-&gt;in(0)-&gt;is_top() ) return; // Dead?
4329 
4330     // We&#39;d like +VerifyLoopOptimizations to not believe that Mod&#39;s/Loads
4331     // _must_ be pinned (they have to observe their control edge of course).
4332     // Unlike Stores (which modify an unallocable resource, the memory
4333     // state), Mods/Loads can float around.  So free them up.
4334     switch( n-&gt;Opcode() ) {
4335     case Op_DivI:
4336     case Op_DivF:
4337     case Op_DivD:
4338     case Op_ModI:
4339     case Op_ModF:
4340     case Op_ModD:
4341     case Op_LoadB:              // Same with Loads; they can sink
4342     case Op_LoadUB:             // during loop optimizations.
4343     case Op_LoadUS:
4344     case Op_LoadD:
4345     case Op_LoadF:
4346     case Op_LoadI:
4347     case Op_LoadKlass:
4348     case Op_LoadNKlass:
4349     case Op_LoadL:
4350     case Op_LoadS:
4351     case Op_LoadP:
4352     case Op_LoadN:
4353     case Op_LoadRange:
4354     case Op_LoadD_unaligned:
4355     case Op_LoadL_unaligned:
4356     case Op_StrComp:            // Does a bunch of load-like effects
4357     case Op_StrEquals:
4358     case Op_StrIndexOf:
4359     case Op_StrIndexOfChar:
4360     case Op_AryEq:
4361     case Op_HasNegatives:
4362       pinned = false;
4363     }
4364     if (n-&gt;is_CMove()) {
4365       pinned = false;
4366     }
4367     if( pinned ) {
4368       IdealLoopTree *chosen_loop = get_loop(n-&gt;is_CFG() ? n : get_ctrl(n));
4369       if( !chosen_loop-&gt;_child )       // Inner loop?
4370         chosen_loop-&gt;_body.push(n); // Collect inner loops
4371       return;
4372     }
4373   } else {                      // No slot zero
4374     if( n-&gt;is_CFG() ) {         // CFG with no slot 0 is dead
4375       _nodes.map(n-&gt;_idx,0);    // No block setting, it&#39;s globally dead
4376       return;
4377     }
4378     assert(!n-&gt;is_CFG() || n-&gt;outcnt() == 0, &quot;&quot;);
4379   }
4380 
4381   // Do I have a &quot;safe range&quot; I can select over?
4382   Node *early = get_ctrl(n);// Early location already computed
4383 
4384   // Compute latest point this Node can go
4385   Node *LCA = get_late_ctrl( n, early );
4386   // LCA is NULL due to uses being dead
4387   if( LCA == NULL ) {
4388 #ifdef ASSERT
4389     for (DUIterator i1 = n-&gt;outs(); n-&gt;has_out(i1); i1++) {
4390       assert( _nodes[n-&gt;out(i1)-&gt;_idx] == NULL, &quot;all uses must also be dead&quot;);
4391     }
4392 #endif
4393     _nodes.map(n-&gt;_idx, 0);     // This node is useless
4394     _deadlist.push(n);
4395     return;
4396   }
4397   assert(LCA != NULL &amp;&amp; !LCA-&gt;is_top(), &quot;no dead nodes&quot;);
4398 
4399   Node *legal = LCA;            // Walk &#39;legal&#39; up the IDOM chain
4400   Node *least = legal;          // Best legal position so far
4401   while( early != legal ) {     // While not at earliest legal
4402 #ifdef ASSERT
4403     if (legal-&gt;is_Start() &amp;&amp; !early-&gt;is_Root()) {
4404       // Bad graph. Print idom path and fail.
4405       dump_bad_graph(&quot;Bad graph detected in build_loop_late&quot;, n, early, LCA);
4406       assert(false, &quot;Bad graph detected in build_loop_late&quot;);
4407     }
4408 #endif
4409     // Find least loop nesting depth
4410     legal = idom(legal);        // Bump up the IDOM tree
4411     // Check for lower nesting depth
4412     if( get_loop(legal)-&gt;_nest &lt; get_loop(least)-&gt;_nest )
4413       least = legal;
4414   }
4415   assert(early == legal || legal != C-&gt;root(), &quot;bad dominance of inputs&quot;);
4416 
4417   // Try not to place code on a loop entry projection
4418   // which can inhibit range check elimination.
4419   if (least != early) {
4420     Node* ctrl_out = least-&gt;unique_ctrl_out();
4421     if (ctrl_out &amp;&amp; ctrl_out-&gt;is_Loop() &amp;&amp;
4422         least == ctrl_out-&gt;in(LoopNode::EntryControl)) {
4423       // Move the node above predicates as far up as possible so a
4424       // following pass of loop predication doesn&#39;t hoist a predicate
4425       // that depends on it above that node.
4426       Node* new_ctrl = least;
4427       for (;;) {
4428         if (!new_ctrl-&gt;is_Proj()) {
4429           break;
4430         }
4431         CallStaticJavaNode* call = new_ctrl-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);
4432         if (call == NULL) {
4433           break;
4434         }
4435         int req = call-&gt;uncommon_trap_request();
4436         Deoptimization::DeoptReason trap_reason = Deoptimization::trap_request_reason(req);
4437         if (trap_reason != Deoptimization::Reason_loop_limit_check &amp;&amp;
4438             trap_reason != Deoptimization::Reason_predicate &amp;&amp;
4439             trap_reason != Deoptimization::Reason_profile_predicate) {
4440           break;
4441         }
4442         Node* c = new_ctrl-&gt;in(0)-&gt;in(0);
4443         if (is_dominator(c, early) &amp;&amp; c != early) {
4444           break;
4445         }
4446         new_ctrl = c;
4447       }
4448       least = new_ctrl;
4449     }
4450   }
4451 
4452 #ifdef ASSERT
4453   // If verifying, verify that &#39;verify_me&#39; has a legal location
4454   // and choose it as our location.
4455   if( _verify_me ) {
4456     Node *v_ctrl = _verify_me-&gt;get_ctrl_no_update(n);
4457     Node *legal = LCA;
4458     while( early != legal ) {   // While not at earliest legal
4459       if( legal == v_ctrl ) break;  // Check for prior good location
4460       legal = idom(legal)      ;// Bump up the IDOM tree
4461     }
4462     // Check for prior good location
4463     if( legal == v_ctrl ) least = legal; // Keep prior if found
4464   }
4465 #endif
4466 
4467   // Assign discovered &quot;here or above&quot; point
4468   least = find_non_split_ctrl(least);
4469   verify_strip_mined_scheduling(n, least);
4470   set_ctrl(n, least);
4471 
4472   // Collect inner loop bodies
4473   IdealLoopTree *chosen_loop = get_loop(least);
4474   if( !chosen_loop-&gt;_child )   // Inner loop?
4475     chosen_loop-&gt;_body.push(n);// Collect inner loops
4476 }
4477 
4478 #ifdef ASSERT
4479 void PhaseIdealLoop::dump_bad_graph(const char* msg, Node* n, Node* early, Node* LCA) {
4480   tty-&gt;print_cr(&quot;%s&quot;, msg);
4481   tty-&gt;print(&quot;n: &quot;); n-&gt;dump();
4482   tty-&gt;print(&quot;early(n): &quot;); early-&gt;dump();
4483   if (n-&gt;in(0) != NULL  &amp;&amp; !n-&gt;in(0)-&gt;is_top() &amp;&amp;
4484       n-&gt;in(0) != early &amp;&amp; !n-&gt;in(0)-&gt;is_Root()) {
4485     tty-&gt;print(&quot;n-&gt;in(0): &quot;); n-&gt;in(0)-&gt;dump();
4486   }
4487   for (uint i = 1; i &lt; n-&gt;req(); i++) {
4488     Node* in1 = n-&gt;in(i);
4489     if (in1 != NULL &amp;&amp; in1 != n &amp;&amp; !in1-&gt;is_top()) {
4490       tty-&gt;print(&quot;n-&gt;in(%d): &quot;, i); in1-&gt;dump();
4491       Node* in1_early = get_ctrl(in1);
4492       tty-&gt;print(&quot;early(n-&gt;in(%d)): &quot;, i); in1_early-&gt;dump();
4493       if (in1-&gt;in(0) != NULL     &amp;&amp; !in1-&gt;in(0)-&gt;is_top() &amp;&amp;
4494           in1-&gt;in(0) != in1_early &amp;&amp; !in1-&gt;in(0)-&gt;is_Root()) {
4495         tty-&gt;print(&quot;n-&gt;in(%d)-&gt;in(0): &quot;, i); in1-&gt;in(0)-&gt;dump();
4496       }
4497       for (uint j = 1; j &lt; in1-&gt;req(); j++) {
4498         Node* in2 = in1-&gt;in(j);
4499         if (in2 != NULL &amp;&amp; in2 != n &amp;&amp; in2 != in1 &amp;&amp; !in2-&gt;is_top()) {
4500           tty-&gt;print(&quot;n-&gt;in(%d)-&gt;in(%d): &quot;, i, j); in2-&gt;dump();
4501           Node* in2_early = get_ctrl(in2);
4502           tty-&gt;print(&quot;early(n-&gt;in(%d)-&gt;in(%d)): &quot;, i, j); in2_early-&gt;dump();
4503           if (in2-&gt;in(0) != NULL     &amp;&amp; !in2-&gt;in(0)-&gt;is_top() &amp;&amp;
4504               in2-&gt;in(0) != in2_early &amp;&amp; !in2-&gt;in(0)-&gt;is_Root()) {
4505             tty-&gt;print(&quot;n-&gt;in(%d)-&gt;in(%d)-&gt;in(0): &quot;, i, j); in2-&gt;in(0)-&gt;dump();
4506           }
4507         }
4508       }
4509     }
4510   }
4511   tty-&gt;cr();
4512   tty-&gt;print(&quot;LCA(n): &quot;); LCA-&gt;dump();
4513   for (uint i = 0; i &lt; n-&gt;outcnt(); i++) {
4514     Node* u1 = n-&gt;raw_out(i);
4515     if (u1 == n)
4516       continue;
4517     tty-&gt;print(&quot;n-&gt;out(%d): &quot;, i); u1-&gt;dump();
4518     if (u1-&gt;is_CFG()) {
4519       for (uint j = 0; j &lt; u1-&gt;outcnt(); j++) {
4520         Node* u2 = u1-&gt;raw_out(j);
4521         if (u2 != u1 &amp;&amp; u2 != n &amp;&amp; u2-&gt;is_CFG()) {
4522           tty-&gt;print(&quot;n-&gt;out(%d)-&gt;out(%d): &quot;, i, j); u2-&gt;dump();
4523         }
4524       }
4525     } else {
4526       Node* u1_later = get_ctrl(u1);
4527       tty-&gt;print(&quot;later(n-&gt;out(%d)): &quot;, i); u1_later-&gt;dump();
4528       if (u1-&gt;in(0) != NULL     &amp;&amp; !u1-&gt;in(0)-&gt;is_top() &amp;&amp;
4529           u1-&gt;in(0) != u1_later &amp;&amp; !u1-&gt;in(0)-&gt;is_Root()) {
4530         tty-&gt;print(&quot;n-&gt;out(%d)-&gt;in(0): &quot;, i); u1-&gt;in(0)-&gt;dump();
4531       }
4532       for (uint j = 0; j &lt; u1-&gt;outcnt(); j++) {
4533         Node* u2 = u1-&gt;raw_out(j);
4534         if (u2 == n || u2 == u1)
4535           continue;
4536         tty-&gt;print(&quot;n-&gt;out(%d)-&gt;out(%d): &quot;, i, j); u2-&gt;dump();
4537         if (!u2-&gt;is_CFG()) {
4538           Node* u2_later = get_ctrl(u2);
4539           tty-&gt;print(&quot;later(n-&gt;out(%d)-&gt;out(%d)): &quot;, i, j); u2_later-&gt;dump();
4540           if (u2-&gt;in(0) != NULL     &amp;&amp; !u2-&gt;in(0)-&gt;is_top() &amp;&amp;
4541               u2-&gt;in(0) != u2_later &amp;&amp; !u2-&gt;in(0)-&gt;is_Root()) {
4542             tty-&gt;print(&quot;n-&gt;out(%d)-&gt;in(0): &quot;, i); u2-&gt;in(0)-&gt;dump();
4543           }
4544         }
4545       }
4546     }
4547   }
4548   tty-&gt;cr();
4549   int ct = 0;
4550   Node *dbg_legal = LCA;
4551   while(!dbg_legal-&gt;is_Start() &amp;&amp; ct &lt; 100) {
4552     tty-&gt;print(&quot;idom[%d] &quot;,ct); dbg_legal-&gt;dump();
4553     ct++;
4554     dbg_legal = idom(dbg_legal);
4555   }
4556   tty-&gt;cr();
4557 }
4558 #endif
4559 
4560 #ifndef PRODUCT
4561 //------------------------------dump-------------------------------------------
4562 void PhaseIdealLoop::dump() const {
4563   ResourceMark rm;
4564   Arena* arena = Thread::current()-&gt;resource_area();
4565   Node_Stack stack(arena, C-&gt;live_nodes() &gt;&gt; 2);
4566   Node_List rpo_list;
4567   VectorSet visited(arena);
4568   visited.set(C-&gt;top()-&gt;_idx);
4569   rpo(C-&gt;root(), stack, visited, rpo_list);
4570   // Dump root loop indexed by last element in PO order
4571   dump(_ltree_root, rpo_list.size(), rpo_list);
4572 }
4573 
4574 void PhaseIdealLoop::dump(IdealLoopTree* loop, uint idx, Node_List &amp;rpo_list) const {
4575   loop-&gt;dump_head();
4576 
4577   // Now scan for CFG nodes in the same loop
4578   for (uint j = idx; j &gt; 0; j--) {
4579     Node* n = rpo_list[j-1];
4580     if (!_nodes[n-&gt;_idx])      // Skip dead nodes
4581       continue;
4582 
4583     if (get_loop(n) != loop) { // Wrong loop nest
4584       if (get_loop(n)-&gt;_head == n &amp;&amp;    // Found nested loop?
4585           get_loop(n)-&gt;_parent == loop)
4586         dump(get_loop(n), rpo_list.size(), rpo_list);     // Print it nested-ly
4587       continue;
4588     }
4589 
4590     // Dump controlling node
4591     tty-&gt;sp(2 * loop-&gt;_nest);
4592     tty-&gt;print(&quot;C&quot;);
4593     if (n == C-&gt;root()) {
4594       n-&gt;dump();
4595     } else {
4596       Node* cached_idom   = idom_no_update(n);
4597       Node* computed_idom = n-&gt;in(0);
4598       if (n-&gt;is_Region()) {
4599         computed_idom = compute_idom(n);
4600         // computed_idom() will return n-&gt;in(0) when idom(n) is an IfNode (or
4601         // any MultiBranch ctrl node), so apply a similar transform to
4602         // the cached idom returned from idom_no_update.
4603         cached_idom = find_non_split_ctrl(cached_idom);
4604       }
4605       tty-&gt;print(&quot; ID:%d&quot;, computed_idom-&gt;_idx);
4606       n-&gt;dump();
4607       if (cached_idom != computed_idom) {
4608         tty-&gt;print_cr(&quot;*** BROKEN IDOM!  Computed as: %d, cached as: %d&quot;,
4609                       computed_idom-&gt;_idx, cached_idom-&gt;_idx);
4610       }
4611     }
4612     // Dump nodes it controls
4613     for (uint k = 0; k &lt; _nodes.Size(); k++) {
4614       // (k &lt; C-&gt;unique() &amp;&amp; get_ctrl(find(k)) == n)
4615       if (k &lt; C-&gt;unique() &amp;&amp; _nodes[k] == (Node*)((intptr_t)n + 1)) {
4616         Node* m = C-&gt;root()-&gt;find(k);
4617         if (m &amp;&amp; m-&gt;outcnt() &gt; 0) {
4618           if (!(has_ctrl(m) &amp;&amp; get_ctrl_no_update(m) == n)) {
4619             tty-&gt;print_cr(&quot;*** BROKEN CTRL ACCESSOR!  _nodes[k] is %p, ctrl is %p&quot;,
4620                           _nodes[k], has_ctrl(m) ? get_ctrl_no_update(m) : NULL);
4621           }
4622           tty-&gt;sp(2 * loop-&gt;_nest + 1);
4623           m-&gt;dump();
4624         }
4625       }
4626     }
4627   }
4628 }
4629 #endif
4630 
4631 // Collect a R-P-O for the whole CFG.
4632 // Result list is in post-order (scan backwards for RPO)
4633 void PhaseIdealLoop::rpo(Node* start, Node_Stack &amp;stk, VectorSet &amp;visited, Node_List &amp;rpo_list) const {
4634   stk.push(start, 0);
4635   visited.set(start-&gt;_idx);
4636 
4637   while (stk.is_nonempty()) {
4638     Node* m   = stk.node();
4639     uint  idx = stk.index();
4640     if (idx &lt; m-&gt;outcnt()) {
4641       stk.set_index(idx + 1);
4642       Node* n = m-&gt;raw_out(idx);
4643       if (n-&gt;is_CFG() &amp;&amp; !visited.test_set(n-&gt;_idx)) {
4644         stk.push(n, 0);
4645       }
4646     } else {
4647       rpo_list.push(m);
4648       stk.pop();
4649     }
4650   }
4651 }
4652 
4653 
4654 //=============================================================================
4655 //------------------------------LoopTreeIterator-------------------------------
4656 
4657 // Advance to next loop tree using a preorder, left-to-right traversal.
4658 void LoopTreeIterator::next() {
4659   assert(!done(), &quot;must not be done.&quot;);
4660   if (_curnt-&gt;_child != NULL) {
4661     _curnt = _curnt-&gt;_child;
4662   } else if (_curnt-&gt;_next != NULL) {
4663     _curnt = _curnt-&gt;_next;
4664   } else {
4665     while (_curnt != _root &amp;&amp; _curnt-&gt;_next == NULL) {
4666       _curnt = _curnt-&gt;_parent;
4667     }
4668     if (_curnt == _root) {
4669       _curnt = NULL;
4670       assert(done(), &quot;must be done.&quot;);
4671     } else {
4672       assert(_curnt-&gt;_next != NULL, &quot;must be more to do&quot;);
4673       _curnt = _curnt-&gt;_next;
4674     }
4675   }
4676 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
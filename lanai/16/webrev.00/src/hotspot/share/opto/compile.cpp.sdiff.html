<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/compile.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classes.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compile.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/compile.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 233   #define PRINT_STAT_LINE(name, c, f) \
 234     tty-&gt;print_cr(&quot;  %4d (%4.1f%%) %s (%s)&quot;, (int)(c), ((c) * 100.0) / total, name, f);
 235   for (int index = 1 + (int)vmIntrinsics::_none; index &lt; (int)vmIntrinsics::ID_LIMIT; index++) {
 236     vmIntrinsics::ID id = (vmIntrinsics::ID) index;
 237     int   flags = _intrinsic_hist_flags[id];
 238     juint count = _intrinsic_hist_count[id];
 239     if ((flags | count) != 0) {
 240       PRINT_STAT_LINE(vmIntrinsics::name_at(id), count, format_flags(flags, flagsbuf));
 241     }
 242   }
 243   PRINT_STAT_LINE(&quot;total&quot;, total, format_flags(_intrinsic_hist_flags[vmIntrinsics::_none], flagsbuf));
 244   if (xtty != NULL)  xtty-&gt;tail(&quot;statistics&quot;);
 245 }
 246 
 247 void Compile::print_statistics() {
 248   { ttyLocker ttyl;
 249     if (xtty != NULL)  xtty-&gt;head(&quot;statistics type=&#39;opto&#39;&quot;);
 250     Parse::print_statistics();
 251     PhaseCCP::print_statistics();
 252     PhaseRegAlloc::print_statistics();
<span class="line-modified"> 253     Scheduling::print_statistics();</span>
 254     PhasePeephole::print_statistics();
 255     PhaseIdealLoop::print_statistics();
 256     if (xtty != NULL)  xtty-&gt;tail(&quot;statistics&quot;);
 257   }
 258   if (_intrinsic_hist_flags[vmIntrinsics::_none] != 0) {
 259     // put this under its own &lt;statistics&gt; element.
 260     print_intrinsic_statistics();
 261   }
 262 }
 263 #endif //PRODUCT
 264 
<span class="line-removed"> 265 // Support for bundling info</span>
<span class="line-removed"> 266 Bundle* Compile::node_bundling(const Node *n) {</span>
<span class="line-removed"> 267   assert(valid_bundle_info(n), &quot;oob&quot;);</span>
<span class="line-removed"> 268   return &amp;_node_bundling_base[n-&gt;_idx];</span>
<span class="line-removed"> 269 }</span>
<span class="line-removed"> 270 </span>
<span class="line-removed"> 271 bool Compile::valid_bundle_info(const Node *n) {</span>
<span class="line-removed"> 272   return (_node_bundling_limit &gt; n-&gt;_idx);</span>
<span class="line-removed"> 273 }</span>
<span class="line-removed"> 274 </span>
<span class="line-removed"> 275 </span>
 276 void Compile::gvn_replace_by(Node* n, Node* nn) {
 277   for (DUIterator_Last imin, i = n-&gt;last_outs(imin); i &gt;= imin; ) {
 278     Node* use = n-&gt;last_out(i);
 279     bool is_in_table = initial_gvn()-&gt;hash_delete(use);
 280     uint uses_found = 0;
 281     for (uint j = 0; j &lt; use-&gt;len(); j++) {
 282       if (use-&gt;in(j) == n) {
 283         if (j &lt; use-&gt;req())
 284           use-&gt;set_req(j, nn);
 285         else
 286           use-&gt;set_prec(j, nn);
 287         uses_found++;
 288       }
 289     }
 290     if (is_in_table) {
 291       // reinsert into table
 292       initial_gvn()-&gt;hash_find_insert(use);
 293     }
 294     record_for_igvn(use);
 295     i -= uses_found;    // we deleted 1 or more copies of this edge
</pre>
<hr />
<pre>
 406     if (!useful.member(n)) {
 407       remove_expensive_node(n);
 408     }
 409   }
 410   // Remove useless Opaque4 nodes
 411   for (int i = opaque4_count() - 1; i &gt;= 0; i--) {
 412     Node* opaq = opaque4_node(i);
 413     if (!useful.member(opaq)) {
 414       remove_opaque4_node(opaq);
 415     }
 416   }
 417   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 418   bs-&gt;eliminate_useless_gc_barriers(useful, this);
 419   // clean up the late inline lists
 420   remove_useless_late_inlines(&amp;_string_late_inlines, useful);
 421   remove_useless_late_inlines(&amp;_boxing_late_inlines, useful);
 422   remove_useless_late_inlines(&amp;_late_inlines, useful);
 423   debug_only(verify_graph_edges(true/*check for no_dead_code*/);)
 424 }
 425 
<span class="line-removed"> 426 //------------------------------frame_size_in_words-----------------------------</span>
<span class="line-removed"> 427 // frame_slots in units of words</span>
<span class="line-removed"> 428 int Compile::frame_size_in_words() const {</span>
<span class="line-removed"> 429   // shift is 0 in LP32 and 1 in LP64</span>
<span class="line-removed"> 430   const int shift = (LogBytesPerWord - LogBytesPerInt);</span>
<span class="line-removed"> 431   int words = _frame_slots &gt;&gt; shift;</span>
<span class="line-removed"> 432   assert( words &lt;&lt; shift == _frame_slots, &quot;frame size must be properly aligned in LP64&quot; );</span>
<span class="line-removed"> 433   return words;</span>
<span class="line-removed"> 434 }</span>
<span class="line-removed"> 435 </span>
<span class="line-removed"> 436 // To bang the stack of this compiled method we use the stack size</span>
<span class="line-removed"> 437 // that the interpreter would need in case of a deoptimization. This</span>
<span class="line-removed"> 438 // removes the need to bang the stack in the deoptimization blob which</span>
<span class="line-removed"> 439 // in turn simplifies stack overflow handling.</span>
<span class="line-removed"> 440 int Compile::bang_size_in_bytes() const {</span>
<span class="line-removed"> 441   return MAX2(frame_size_in_bytes() + os::extra_bang_size_in_bytes(), _interpreter_frame_size);</span>
<span class="line-removed"> 442 }</span>
<span class="line-removed"> 443 </span>
 444 // ============================================================================
 445 //------------------------------CompileWrapper---------------------------------
 446 class CompileWrapper : public StackObj {
 447   Compile *const _compile;
 448  public:
 449   CompileWrapper(Compile* compile);
 450 
 451   ~CompileWrapper();
 452 };
 453 
 454 CompileWrapper::CompileWrapper(Compile* compile) : _compile(compile) {
 455   // the Compile* pointer is stored in the current ciEnv:
 456   ciEnv* env = compile-&gt;env();
 457   assert(env == ciEnv::current(), &quot;must already be a ciEnv active&quot;);
 458   assert(env-&gt;compiler_data() == NULL, &quot;compile already active?&quot;);
 459   env-&gt;set_compiler_data(compile);
 460   assert(compile == Compile::current(), &quot;sanity&quot;);
 461 
 462   compile-&gt;set_type_dict(NULL);
 463   compile-&gt;set_clone_map(new Dict(cmpkey, hashkey, _compile-&gt;comp_arena()));
 464   compile-&gt;clone_map().set_clone_idx(0);
 465   compile-&gt;set_type_last_size(0);
 466   compile-&gt;set_last_tf(NULL, NULL);
 467   compile-&gt;set_indexSet_arena(NULL);
 468   compile-&gt;set_indexSet_free_block_list(NULL);
 469   compile-&gt;init_type_arena();
 470   Type::Initialize(compile);
<span class="line-removed"> 471   _compile-&gt;set_scratch_buffer_blob(NULL);</span>
 472   _compile-&gt;begin_method();
 473   _compile-&gt;clone_map().set_debug(_compile-&gt;has_method() &amp;&amp; _compile-&gt;directive()-&gt;CloneMapDebugOption);
 474 }
 475 CompileWrapper::~CompileWrapper() {
 476   _compile-&gt;end_method();
<span class="line-removed"> 477   if (_compile-&gt;scratch_buffer_blob() != NULL)</span>
<span class="line-removed"> 478     BufferBlob::free(_compile-&gt;scratch_buffer_blob());</span>
 479   _compile-&gt;env()-&gt;set_compiler_data(NULL);
 480 }
 481 
 482 
 483 //----------------------------print_compile_messages---------------------------
 484 void Compile::print_compile_messages() {
 485 #ifndef PRODUCT
 486   // Check if recompiling
 487   if (_subsume_loads == false &amp;&amp; PrintOpto) {
 488     // Recompiling without allowing machine instructions to subsume loads
 489     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 490     tty-&gt;print_cr(&quot;** Bailout: Recompile without subsuming loads          **&quot;);
 491     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 492   }
 493   if (_do_escape_analysis != DoEscapeAnalysis &amp;&amp; PrintOpto) {
 494     // Recompiling without escape analysis
 495     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 496     tty-&gt;print_cr(&quot;** Bailout: Recompile without escape analysis          **&quot;);
 497     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 498   }
</pre>
<hr />
<pre>
 503     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 504   }
 505   if (C-&gt;directive()-&gt;BreakAtCompileOption) {
 506     // Open the debugger when compiling this method.
 507     tty-&gt;print(&quot;### Breaking when compiling: &quot;);
 508     method()-&gt;print_short_name();
 509     tty-&gt;cr();
 510     BREAKPOINT;
 511   }
 512 
 513   if( PrintOpto ) {
 514     if (is_osr_compilation()) {
 515       tty-&gt;print(&quot;[OSR]%3d&quot;, _compile_id);
 516     } else {
 517       tty-&gt;print(&quot;%3d&quot;, _compile_id);
 518     }
 519   }
 520 #endif
 521 }
 522 
<span class="line-removed"> 523 </span>
<span class="line-removed"> 524 //-----------------------init_scratch_buffer_blob------------------------------</span>
<span class="line-removed"> 525 // Construct a temporary BufferBlob and cache it for this compile.</span>
<span class="line-removed"> 526 void Compile::init_scratch_buffer_blob(int const_size) {</span>
<span class="line-removed"> 527   // If there is already a scratch buffer blob allocated and the</span>
<span class="line-removed"> 528   // constant section is big enough, use it.  Otherwise free the</span>
<span class="line-removed"> 529   // current and allocate a new one.</span>
<span class="line-removed"> 530   BufferBlob* blob = scratch_buffer_blob();</span>
<span class="line-removed"> 531   if ((blob != NULL) &amp;&amp; (const_size &lt;= _scratch_const_size)) {</span>
<span class="line-removed"> 532     // Use the current blob.</span>
<span class="line-removed"> 533   } else {</span>
<span class="line-removed"> 534     if (blob != NULL) {</span>
<span class="line-removed"> 535       BufferBlob::free(blob);</span>
<span class="line-removed"> 536     }</span>
<span class="line-removed"> 537 </span>
<span class="line-removed"> 538     ResourceMark rm;</span>
<span class="line-removed"> 539     _scratch_const_size = const_size;</span>
<span class="line-removed"> 540     int size = C2Compiler::initial_code_buffer_size(const_size);</span>
<span class="line-removed"> 541     blob = BufferBlob::create(&quot;Compile::scratch_buffer&quot;, size);</span>
<span class="line-removed"> 542     // Record the buffer blob for next time.</span>
<span class="line-removed"> 543     set_scratch_buffer_blob(blob);</span>
<span class="line-removed"> 544     // Have we run out of code space?</span>
<span class="line-removed"> 545     if (scratch_buffer_blob() == NULL) {</span>
<span class="line-removed"> 546       // Let CompilerBroker disable further compilations.</span>
<span class="line-removed"> 547       record_failure(&quot;Not enough space for scratch buffer in CodeCache&quot;);</span>
<span class="line-removed"> 548       return;</span>
<span class="line-removed"> 549     }</span>
<span class="line-removed"> 550   }</span>
<span class="line-removed"> 551 </span>
<span class="line-removed"> 552   // Initialize the relocation buffers</span>
<span class="line-removed"> 553   relocInfo* locs_buf = (relocInfo*) blob-&gt;content_end() - MAX_locs_size;</span>
<span class="line-removed"> 554   set_scratch_locs_memory(locs_buf);</span>
<span class="line-removed"> 555 }</span>
<span class="line-removed"> 556 </span>
<span class="line-removed"> 557 </span>
<span class="line-removed"> 558 //-----------------------scratch_emit_size-------------------------------------</span>
<span class="line-removed"> 559 // Helper function that computes size by emitting code</span>
<span class="line-removed"> 560 uint Compile::scratch_emit_size(const Node* n) {</span>
<span class="line-removed"> 561   // Start scratch_emit_size section.</span>
<span class="line-removed"> 562   set_in_scratch_emit_size(true);</span>
<span class="line-removed"> 563 </span>
<span class="line-removed"> 564   // Emit into a trash buffer and count bytes emitted.</span>
<span class="line-removed"> 565   // This is a pretty expensive way to compute a size,</span>
<span class="line-removed"> 566   // but it works well enough if seldom used.</span>
<span class="line-removed"> 567   // All common fixed-size instructions are given a size</span>
<span class="line-removed"> 568   // method by the AD file.</span>
<span class="line-removed"> 569   // Note that the scratch buffer blob and locs memory are</span>
<span class="line-removed"> 570   // allocated at the beginning of the compile task, and</span>
<span class="line-removed"> 571   // may be shared by several calls to scratch_emit_size.</span>
<span class="line-removed"> 572   // The allocation of the scratch buffer blob is particularly</span>
<span class="line-removed"> 573   // expensive, since it has to grab the code cache lock.</span>
<span class="line-removed"> 574   BufferBlob* blob = this-&gt;scratch_buffer_blob();</span>
<span class="line-removed"> 575   assert(blob != NULL, &quot;Initialize BufferBlob at start&quot;);</span>
<span class="line-removed"> 576   assert(blob-&gt;size() &gt; MAX_inst_size, &quot;sanity&quot;);</span>
<span class="line-removed"> 577   relocInfo* locs_buf = scratch_locs_memory();</span>
<span class="line-removed"> 578   address blob_begin = blob-&gt;content_begin();</span>
<span class="line-removed"> 579   address blob_end   = (address)locs_buf;</span>
<span class="line-removed"> 580   assert(blob-&gt;contains(blob_end), &quot;sanity&quot;);</span>
<span class="line-removed"> 581   CodeBuffer buf(blob_begin, blob_end - blob_begin);</span>
<span class="line-removed"> 582   buf.initialize_consts_size(_scratch_const_size);</span>
<span class="line-removed"> 583   buf.initialize_stubs_size(MAX_stubs_size);</span>
<span class="line-removed"> 584   assert(locs_buf != NULL, &quot;sanity&quot;);</span>
<span class="line-removed"> 585   int lsize = MAX_locs_size / 3;</span>
<span class="line-removed"> 586   buf.consts()-&gt;initialize_shared_locs(&amp;locs_buf[lsize * 0], lsize);</span>
<span class="line-removed"> 587   buf.insts()-&gt;initialize_shared_locs( &amp;locs_buf[lsize * 1], lsize);</span>
<span class="line-removed"> 588   buf.stubs()-&gt;initialize_shared_locs( &amp;locs_buf[lsize * 2], lsize);</span>
<span class="line-removed"> 589   // Mark as scratch buffer.</span>
<span class="line-removed"> 590   buf.consts()-&gt;set_scratch_emit();</span>
<span class="line-removed"> 591   buf.insts()-&gt;set_scratch_emit();</span>
<span class="line-removed"> 592   buf.stubs()-&gt;set_scratch_emit();</span>
<span class="line-removed"> 593 </span>
<span class="line-removed"> 594   // Do the emission.</span>
<span class="line-removed"> 595 </span>
<span class="line-removed"> 596   Label fakeL; // Fake label for branch instructions.</span>
<span class="line-removed"> 597   Label*   saveL = NULL;</span>
<span class="line-removed"> 598   uint save_bnum = 0;</span>
<span class="line-removed"> 599   bool is_branch = n-&gt;is_MachBranch();</span>
<span class="line-removed"> 600   if (is_branch) {</span>
<span class="line-removed"> 601     MacroAssembler masm(&amp;buf);</span>
<span class="line-removed"> 602     masm.bind(fakeL);</span>
<span class="line-removed"> 603     n-&gt;as_MachBranch()-&gt;save_label(&amp;saveL, &amp;save_bnum);</span>
<span class="line-removed"> 604     n-&gt;as_MachBranch()-&gt;label_set(&amp;fakeL, 0);</span>
<span class="line-removed"> 605   }</span>
<span class="line-removed"> 606   n-&gt;emit(buf, this-&gt;regalloc());</span>
<span class="line-removed"> 607 </span>
<span class="line-removed"> 608   // Emitting into the scratch buffer should not fail</span>
<span class="line-removed"> 609   assert (!failing(), &quot;Must not have pending failure. Reason is: %s&quot;, failure_reason());</span>
<span class="line-removed"> 610 </span>
<span class="line-removed"> 611   if (is_branch) // Restore label.</span>
<span class="line-removed"> 612     n-&gt;as_MachBranch()-&gt;label_set(saveL, save_bnum);</span>
<span class="line-removed"> 613 </span>
<span class="line-removed"> 614   // End scratch_emit_size section.</span>
<span class="line-removed"> 615   set_in_scratch_emit_size(false);</span>
<span class="line-removed"> 616 </span>
<span class="line-removed"> 617   return buf.insts_size();</span>
<span class="line-removed"> 618 }</span>
<span class="line-removed"> 619 </span>
<span class="line-removed"> 620 </span>
 621 // ============================================================================
 622 //------------------------------Compile standard-------------------------------
 623 debug_only( int Compile::_debug_idx = 100000; )
 624 
 625 // Compile a method.  entry_bci is -1 for normal compilations and indicates
 626 // the continuation bci for on stack replacement.
 627 
 628 
<span class="line-modified"> 629 Compile::Compile( ciEnv* ci_env, C2Compiler* compiler, ciMethod* target, int osr_bci,</span>
 630                   bool subsume_loads, bool do_escape_analysis, bool eliminate_boxing, DirectiveSet* directive)
 631                 : Phase(Compiler),
 632                   _compile_id(ci_env-&gt;compile_id()),
 633                   _save_argument_registers(false),
 634                   _subsume_loads(subsume_loads),
 635                   _do_escape_analysis(do_escape_analysis),
 636                   _eliminate_boxing(eliminate_boxing),
 637                   _method(target),
 638                   _entry_bci(osr_bci),
 639                   _stub_function(NULL),
 640                   _stub_name(NULL),
 641                   _stub_entry_point(NULL),
 642                   _max_node_limit(MaxNodeLimit),
<span class="line-removed"> 643                   _orig_pc_slot(0),</span>
<span class="line-removed"> 644                   _orig_pc_slot_offset_in_bytes(0),</span>
 645                   _inlining_progress(false),
 646                   _inlining_incrementally(false),
 647                   _do_cleanup(false),
 648                   _has_reserved_stack_access(target-&gt;has_reserved_stack_access()),
 649 #ifndef PRODUCT
 650                   _trace_opto_output(directive-&gt;TraceOptoOutputOption),
 651                   _print_ideal(directive-&gt;PrintIdealOption),
 652 #endif
 653                   _has_method_handle_invokes(false),
 654                   _clinit_barrier_on_entry(false),
 655                   _comp_arena(mtCompiler),
 656                   _barrier_set_state(BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;create_barrier_state(comp_arena())),
 657                   _env(ci_env),
 658                   _directive(directive),
 659                   _log(ci_env-&gt;log()),
 660                   _failure_reason(NULL),
 661                   _congraph(NULL),
 662 #ifndef PRODUCT
 663                   _printer(IdealGraphPrinter::printer()),
 664 #endif
</pre>
<hr />
<pre>
 666                   _dead_node_count(0),
 667                   _node_arena(mtCompiler),
 668                   _old_arena(mtCompiler),
 669                   _mach_constant_base_node(NULL),
 670                   _Compile_types(mtCompiler),
 671                   _initial_gvn(NULL),
 672                   _for_igvn(NULL),
 673                   _warm_calls(NULL),
 674                   _late_inlines(comp_arena(), 2, 0, NULL),
 675                   _string_late_inlines(comp_arena(), 2, 0, NULL),
 676                   _boxing_late_inlines(comp_arena(), 2, 0, NULL),
 677                   _late_inlines_pos(0),
 678                   _number_of_mh_late_inlines(0),
 679                   _print_inlining_stream(NULL),
 680                   _print_inlining_list(NULL),
 681                   _print_inlining_idx(0),
 682                   _print_inlining_output(NULL),
 683                   _replay_inline_data(NULL),
 684                   _java_calls(0),
 685                   _inner_loops(0),
<span class="line-modified"> 686                   _interpreter_frame_size(0),</span>
<span class="line-removed"> 687                   _node_bundling_limit(0),</span>
<span class="line-removed"> 688                   _node_bundling_base(NULL),</span>
<span class="line-removed"> 689                   _code_buffer(&quot;Compile::Fill_buffer&quot;),</span>
<span class="line-removed"> 690                   _scratch_const_size(-1),</span>
<span class="line-removed"> 691                   _in_scratch_emit_size(false)</span>
 692 #ifndef PRODUCT
 693                   , _in_dump_cnt(0)
 694 #endif
 695 {
 696   C = this;
 697 #ifndef PRODUCT
 698   if (_printer != NULL) {
 699     _printer-&gt;set_compile(this);
 700   }
 701 #endif
 702   CompileWrapper cw(this);
 703 
 704   if (CITimeVerbose) {
 705     tty-&gt;print(&quot; &quot;);
 706     target-&gt;holder()-&gt;name()-&gt;print();
 707     tty-&gt;print(&quot;.&quot;);
 708     target-&gt;print_short_name();
 709     tty-&gt;print(&quot;  &quot;);
 710   }
 711   TraceTime t1(&quot;Total compilation time&quot;, &amp;_t_totalCompilation, CITime, CITimeVerbose);
</pre>
<hr />
<pre>
 889       xtty-&gt;tail(&quot;ideal&quot;);
 890     }
 891   }
 892 #endif
 893 
 894 #ifdef ASSERT
 895   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 896   bs-&gt;verify_gc_barriers(this, BarrierSetC2::BeforeCodeGen);
 897 #endif
 898 
 899   // Dump compilation data to replay it.
 900   if (directive-&gt;DumpReplayOption) {
 901     env()-&gt;dump_replay_data(_compile_id);
 902   }
 903   if (directive-&gt;DumpInlineOption &amp;&amp; (ilt() != NULL)) {
 904     env()-&gt;dump_inline_data(_compile_id);
 905   }
 906 
 907   // Now that we know the size of all the monitors we can add a fixed slot
 908   // for the original deopt pc.
<span class="line-modified"> 909 </span>
<span class="line-removed"> 910   _orig_pc_slot =  fixed_slots();</span>
<span class="line-removed"> 911   int next_slot = _orig_pc_slot + (sizeof(address) / VMRegImpl::stack_slot_size);</span>
 912   set_fixed_slots(next_slot);
 913 
 914   // Compute when to use implicit null checks. Used by matching trap based
 915   // nodes and NullCheck optimization.
 916   set_allowed_deopt_reasons();
 917 
 918   // Now generate code
 919   Code_Gen();
<span class="line-removed"> 920   if (failing())  return;</span>
<span class="line-removed"> 921 </span>
<span class="line-removed"> 922   // Check if we want to skip execution of all compiled code.</span>
<span class="line-removed"> 923   {</span>
<span class="line-removed"> 924 #ifndef PRODUCT</span>
<span class="line-removed"> 925     if (OptoNoExecute) {</span>
<span class="line-removed"> 926       record_method_not_compilable(&quot;+OptoNoExecute&quot;);  // Flag as failed</span>
<span class="line-removed"> 927       return;</span>
<span class="line-removed"> 928     }</span>
<span class="line-removed"> 929 #endif</span>
<span class="line-removed"> 930     TracePhase tp(&quot;install_code&quot;, &amp;timers[_t_registerMethod]);</span>
<span class="line-removed"> 931 </span>
<span class="line-removed"> 932     if (is_osr_compilation()) {</span>
<span class="line-removed"> 933       _code_offsets.set_value(CodeOffsets::Verified_Entry, 0);</span>
<span class="line-removed"> 934       _code_offsets.set_value(CodeOffsets::OSR_Entry, _first_block_size);</span>
<span class="line-removed"> 935     } else {</span>
<span class="line-removed"> 936       _code_offsets.set_value(CodeOffsets::Verified_Entry, _first_block_size);</span>
<span class="line-removed"> 937       _code_offsets.set_value(CodeOffsets::OSR_Entry, 0);</span>
<span class="line-removed"> 938     }</span>
<span class="line-removed"> 939 </span>
<span class="line-removed"> 940     env()-&gt;register_method(_method, _entry_bci,</span>
<span class="line-removed"> 941                            &amp;_code_offsets,</span>
<span class="line-removed"> 942                            _orig_pc_slot_offset_in_bytes,</span>
<span class="line-removed"> 943                            code_buffer(),</span>
<span class="line-removed"> 944                            frame_size_in_words(), _oop_map_set,</span>
<span class="line-removed"> 945                            &amp;_handler_table, &amp;_inc_table,</span>
<span class="line-removed"> 946                            compiler,</span>
<span class="line-removed"> 947                            has_unsafe_access(),</span>
<span class="line-removed"> 948                            SharedRuntime::is_wide_vector(max_vector_size()),</span>
<span class="line-removed"> 949                            rtm_state()</span>
<span class="line-removed"> 950                            );</span>
<span class="line-removed"> 951 </span>
<span class="line-removed"> 952     if (log() != NULL) // Print code cache state into compiler log</span>
<span class="line-removed"> 953       log()-&gt;code_cache_state();</span>
<span class="line-removed"> 954   }</span>
 955 }
 956 
 957 //------------------------------Compile----------------------------------------
 958 // Compile a runtime stub
 959 Compile::Compile( ciEnv* ci_env,
 960                   TypeFunc_generator generator,
 961                   address stub_function,
 962                   const char *stub_name,
 963                   int is_fancy_jump,
 964                   bool pass_tls,
 965                   bool save_arg_registers,
 966                   bool return_pc,
 967                   DirectiveSet* directive)
 968   : Phase(Compiler),
 969     _compile_id(0),
 970     _save_argument_registers(save_arg_registers),
 971     _subsume_loads(true),
 972     _do_escape_analysis(false),
 973     _eliminate_boxing(false),
 974     _method(NULL),
 975     _entry_bci(InvocationEntryBci),
 976     _stub_function(stub_function),
 977     _stub_name(stub_name),
 978     _stub_entry_point(NULL),
 979     _max_node_limit(MaxNodeLimit),
<span class="line-removed"> 980     _orig_pc_slot(0),</span>
<span class="line-removed"> 981     _orig_pc_slot_offset_in_bytes(0),</span>
 982     _inlining_progress(false),
 983     _inlining_incrementally(false),
 984     _has_reserved_stack_access(false),
 985 #ifndef PRODUCT
 986     _trace_opto_output(directive-&gt;TraceOptoOutputOption),
 987     _print_ideal(directive-&gt;PrintIdealOption),
 988 #endif
 989     _has_method_handle_invokes(false),
 990     _clinit_barrier_on_entry(false),
 991     _comp_arena(mtCompiler),
 992     _barrier_set_state(BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;create_barrier_state(comp_arena())),
 993     _env(ci_env),
 994     _directive(directive),
 995     _log(ci_env-&gt;log()),
 996     _failure_reason(NULL),
 997     _congraph(NULL),
 998 #ifndef PRODUCT
 999     _printer(NULL),
1000 #endif
1001     _dead_node_list(comp_arena()),
1002     _dead_node_count(0),
1003     _node_arena(mtCompiler),
1004     _old_arena(mtCompiler),
1005     _mach_constant_base_node(NULL),
1006     _Compile_types(mtCompiler),
1007     _initial_gvn(NULL),
1008     _for_igvn(NULL),
1009     _warm_calls(NULL),
1010     _number_of_mh_late_inlines(0),
1011     _print_inlining_stream(NULL),
1012     _print_inlining_list(NULL),
1013     _print_inlining_idx(0),
1014     _print_inlining_output(NULL),
1015     _replay_inline_data(NULL),
1016     _java_calls(0),
1017     _inner_loops(0),
1018     _interpreter_frame_size(0),
<span class="line-removed">1019     _node_bundling_limit(0),</span>
<span class="line-removed">1020     _node_bundling_base(NULL),</span>
<span class="line-removed">1021     _code_buffer(&quot;Compile::Fill_buffer&quot;),</span>
1022 #ifndef PRODUCT
1023     _in_dump_cnt(0),
1024 #endif
1025     _allowed_reasons(0) {
1026   C = this;
1027 
1028   TraceTime t1(NULL, &amp;_t_totalCompilation, CITime, false);
1029   TraceTime t2(NULL, &amp;_t_stubCompilation, CITime, false);
1030 
1031 #ifndef PRODUCT
1032   set_print_assembly(PrintFrameConverterAssembly);
1033   set_parsed_irreducible_loop(false);
1034 #else
1035   set_print_assembly(false); // Must initialize.
1036 #endif
1037   set_has_irreducible_loop(false); // no loops
1038 
1039   CompileWrapper cw(this);
1040   Init(/*AliasLevel=*/ 0);
1041   init_tf((*generator)());
1042 
1043   {
1044     // The following is a dummy for the sake of GraphKit::gen_stub
1045     Unique_Node_List for_igvn(comp_arena());
1046     set_for_igvn(&amp;for_igvn);  // not used, but some GraphKit guys push on this
1047     PhaseGVN gvn(Thread::current()-&gt;resource_area(),255);
1048     set_initial_gvn(&amp;gvn);    // not significant, but GraphKit guys use it pervasively
1049     gvn.transform_no_reclaim(top());
1050 
1051     GraphKit kit;
1052     kit.gen_stub(stub_function, stub_name, is_fancy_jump, pass_tls, return_pc);
1053   }
1054 
1055   NOT_PRODUCT( verify_graph_edges(); )
<span class="line-removed">1056   Code_Gen();</span>
<span class="line-removed">1057   if (failing())  return;</span>
<span class="line-removed">1058 </span>
<span class="line-removed">1059 </span>
<span class="line-removed">1060   // Entry point will be accessed using compile-&gt;stub_entry_point();</span>
<span class="line-removed">1061   if (code_buffer() == NULL) {</span>
<span class="line-removed">1062     Matcher::soft_match_failure();</span>
<span class="line-removed">1063   } else {</span>
<span class="line-removed">1064     if (PrintAssembly &amp;&amp; (WizardMode || Verbose))</span>
<span class="line-removed">1065       tty-&gt;print_cr(&quot;### Stub::%s&quot;, stub_name);</span>
1066 
<span class="line-modified">1067     if (!failing()) {</span>
<span class="line-removed">1068       assert(_fixed_slots == 0, &quot;no fixed slots used for runtime stubs&quot;);</span>
<span class="line-removed">1069 </span>
<span class="line-removed">1070       // Make the NMethod</span>
<span class="line-removed">1071       // For now we mark the frame as never safe for profile stackwalking</span>
<span class="line-removed">1072       RuntimeStub *rs = RuntimeStub::new_runtime_stub(stub_name,</span>
<span class="line-removed">1073                                                       code_buffer(),</span>
<span class="line-removed">1074                                                       CodeOffsets::frame_never_safe,</span>
<span class="line-removed">1075                                                       // _code_offsets.value(CodeOffsets::Frame_Complete),</span>
<span class="line-removed">1076                                                       frame_size_in_words(),</span>
<span class="line-removed">1077                                                       _oop_map_set,</span>
<span class="line-removed">1078                                                       save_arg_registers);</span>
<span class="line-removed">1079       assert(rs != NULL &amp;&amp; rs-&gt;is_runtime_stub(), &quot;sanity check&quot;);</span>
<span class="line-removed">1080 </span>
<span class="line-removed">1081       _stub_entry_point = rs-&gt;entry_point();</span>
<span class="line-removed">1082     }</span>
<span class="line-removed">1083   }</span>
1084 }
1085 
1086 //------------------------------Init-------------------------------------------
1087 // Prepare for a single compilation
1088 void Compile::Init(int aliaslevel) {
1089   _unique  = 0;
1090   _regalloc = NULL;
1091 
1092   _tf      = NULL;  // filled in later
1093   _top     = NULL;  // cached later
1094   _matcher = NULL;  // filled in later
1095   _cfg     = NULL;  // filled in later
1096 
<span class="line-modified">1097   set_24_bit_selection_and_mode(Use24BitFP, false);</span>
1098 
1099   _node_note_array = NULL;
1100   _default_node_notes = NULL;
1101   DEBUG_ONLY( _modified_nodes = NULL; ) // Used in Optimize()
1102 
1103   _immutable_memory = NULL; // filled in at first inquiry
1104 
1105   // Globally visible Nodes
1106   // First set TOP to NULL to give safe behavior during creation of RootNode
1107   set_cached_top_node(NULL);
1108   set_root(new RootNode());
1109   // Now that you have a Root to point to, create the real TOP
1110   set_cached_top_node( new ConNode(Type::TOP) );
1111   set_recent_alloc(NULL, NULL);
1112 
1113   // Create Debug Information Recorder to record scopes, oopmaps, etc.
1114   env()-&gt;set_oop_recorder(new OopRecorder(env()-&gt;arena()));
1115   env()-&gt;set_debug_info(new DebugInformationRecorder(env()-&gt;oop_recorder()));
1116   env()-&gt;set_dependencies(new Dependencies(env()));
1117 
</pre>
<hr />
<pre>
1791     }
1792     if (flat-&gt;isa_aryptr()) {
1793 #ifdef ASSERT
1794       const int header_size_min  = arrayOopDesc::base_offset_in_bytes(T_BYTE);
1795       // (T_BYTE has the weakest alignment and size restrictions...)
1796       assert(flat-&gt;offset() &lt; header_size_min, &quot;array body reference must be OffsetBot&quot;);
1797 #endif
1798       if (flat-&gt;offset() == TypePtr::OffsetBot) {
1799         alias_type(idx)-&gt;set_element(flat-&gt;is_aryptr()-&gt;elem());
1800       }
1801     }
1802     if (flat-&gt;isa_klassptr()) {
1803       if (flat-&gt;offset() == in_bytes(Klass::super_check_offset_offset()))
1804         alias_type(idx)-&gt;set_rewritable(false);
1805       if (flat-&gt;offset() == in_bytes(Klass::modifier_flags_offset()))
1806         alias_type(idx)-&gt;set_rewritable(false);
1807       if (flat-&gt;offset() == in_bytes(Klass::access_flags_offset()))
1808         alias_type(idx)-&gt;set_rewritable(false);
1809       if (flat-&gt;offset() == in_bytes(Klass::java_mirror_offset()))
1810         alias_type(idx)-&gt;set_rewritable(false);


1811     }
1812     // %%% (We would like to finalize JavaThread::threadObj_offset(),
1813     // but the base pointer type is not distinctive enough to identify
1814     // references into JavaThread.)
1815 
1816     // Check for final fields.
1817     const TypeInstPtr* tinst = flat-&gt;isa_instptr();
1818     if (tinst &amp;&amp; tinst-&gt;offset() &gt;= instanceOopDesc::base_offset_in_bytes()) {
1819       ciField* field;
1820       if (tinst-&gt;const_oop() != NULL &amp;&amp;
1821           tinst-&gt;klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
1822           tinst-&gt;offset() &gt;= (tinst-&gt;klass()-&gt;as_instance_klass()-&gt;size_helper() * wordSize)) {
1823         // static field
1824         ciInstanceKlass* k = tinst-&gt;const_oop()-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();
1825         field = k-&gt;get_field_by_offset(tinst-&gt;offset(), true);
1826       } else {
1827         ciInstanceKlass *k = tinst-&gt;klass()-&gt;as_instance_klass();
1828         field = k-&gt;get_field_by_offset(tinst-&gt;offset(), false);
1829       }
1830       assert(field == NULL ||
</pre>
<hr />
<pre>
1886   if (alias_idx == AliasIdxBot)         return true;  // the universal category
1887   if (adr_type == NULL)                 return true;  // NULL serves as TypePtr::TOP
1888   if (alias_idx == AliasIdxTop)         return false; // the empty category
1889   if (adr_type-&gt;base() == Type::AnyPtr) return false; // TypePtr::BOTTOM or its twins
1890 
1891   // the only remaining possible overlap is identity
1892   int adr_idx = get_alias_index(adr_type);
1893   assert(adr_idx != AliasIdxBot &amp;&amp; adr_idx != AliasIdxTop, &quot;&quot;);
1894   assert(adr_idx == alias_idx ||
1895          (alias_type(alias_idx)-&gt;adr_type() != TypeOopPtr::BOTTOM
1896           &amp;&amp; adr_type                       != TypeOopPtr::BOTTOM),
1897          &quot;should not be testing for overlap with an unsafe pointer&quot;);
1898   return adr_idx == alias_idx;
1899 }
1900 
1901 //------------------------------can_alias--------------------------------------
1902 // True if any values of the given address type are in the given alias category.
1903 bool Compile::can_alias(const TypePtr* adr_type, int alias_idx) {
1904   if (alias_idx == AliasIdxTop)         return false; // the empty category
1905   if (adr_type == NULL)                 return false; // NULL serves as TypePtr::TOP
<span class="line-modified">1906   if (alias_idx == AliasIdxBot)         return true;  // the universal category</span>
<span class="line-modified">1907   if (adr_type-&gt;base() == Type::AnyPtr) return true;  // TypePtr::BOTTOM or its twins</span>

1908 
1909   // the only remaining possible overlap is identity
1910   int adr_idx = get_alias_index(adr_type);
1911   assert(adr_idx != AliasIdxBot &amp;&amp; adr_idx != AliasIdxTop, &quot;&quot;);
1912   return adr_idx == alias_idx;
1913 }
1914 
1915 
1916 
1917 //---------------------------pop_warm_call-------------------------------------
1918 WarmCallInfo* Compile::pop_warm_call() {
1919   WarmCallInfo* wci = _warm_calls;
1920   if (wci != NULL)  _warm_calls = wci-&gt;remove_from(wci);
1921   return wci;
1922 }
1923 
1924 //----------------------------Inline_Warm--------------------------------------
1925 int Compile::Inline_Warm() {
1926   // If there is room, try to inline some more warm call sites.
1927   // %%% Do a graph index compaction pass when we think we&#39;re out of space?
</pre>
<hr />
<pre>
2526       cfg.set_loop_alignment();
2527     }
2528     cfg.fixup_flow();
2529   }
2530 
2531   // Apply peephole optimizations
2532   if( OptoPeephole ) {
2533     TracePhase tp(&quot;peephole&quot;, &amp;timers[_t_peephole]);
2534     PhasePeephole peep( _regalloc, cfg);
2535     peep.do_transform();
2536   }
2537 
2538   // Do late expand if CPU requires this.
2539   if (Matcher::require_postalloc_expand) {
2540     TracePhase tp(&quot;postalloc_expand&quot;, &amp;timers[_t_postalloc_expand]);
2541     cfg.postalloc_expand(_regalloc);
2542   }
2543 
2544   // Convert Nodes to instruction bits in a buffer
2545   {
<span class="line-modified">2546     TraceTime tp(&quot;output&quot;, &amp;timers[_t_output], CITime);</span>
<span class="line-modified">2547     Output();</span>



2548   }
2549 
2550   print_method(PHASE_FINAL_CODE);
2551 
2552   // He&#39;s dead, Jim.
2553   _cfg     = (PhaseCFG*)((intptr_t)0xdeadbeef);
2554   _regalloc = (PhaseChaitin*)((intptr_t)0xdeadbeef);
2555 }
2556 
<span class="line-removed">2557 </span>
<span class="line-removed">2558 //------------------------------dump_asm---------------------------------------</span>
<span class="line-removed">2559 // Dump formatted assembly</span>
<span class="line-removed">2560 #if defined(SUPPORT_OPTO_ASSEMBLY)</span>
<span class="line-removed">2561 void Compile::dump_asm_on(outputStream* st, int* pcs, uint pc_limit) {</span>
<span class="line-removed">2562 </span>
<span class="line-removed">2563   int pc_digits = 3; // #chars required for pc</span>
<span class="line-removed">2564   int sb_chars  = 3; // #chars for &quot;start bundle&quot; indicator</span>
<span class="line-removed">2565   int tab_size  = 8;</span>
<span class="line-removed">2566   if (pcs != NULL) {</span>
<span class="line-removed">2567     int max_pc = 0;</span>
<span class="line-removed">2568     for (uint i = 0; i &lt; pc_limit; i++) {</span>
<span class="line-removed">2569       max_pc = (max_pc &lt; pcs[i]) ? pcs[i] : max_pc;</span>
<span class="line-removed">2570     }</span>
<span class="line-removed">2571     pc_digits  = ((max_pc &lt; 4096) ? 3 : ((max_pc &lt; 65536) ? 4 : ((max_pc &lt; 65536*256) ? 6 : 8))); // #chars required for pc</span>
<span class="line-removed">2572   }</span>
<span class="line-removed">2573   int prefix_len = ((pc_digits + sb_chars + tab_size - 1)/tab_size)*tab_size;</span>
<span class="line-removed">2574 </span>
<span class="line-removed">2575   bool cut_short = false;</span>
<span class="line-removed">2576   st-&gt;print_cr(&quot;#&quot;);</span>
<span class="line-removed">2577   st-&gt;print(&quot;#  &quot;);  _tf-&gt;dump_on(st);  st-&gt;cr();</span>
<span class="line-removed">2578   st-&gt;print_cr(&quot;#&quot;);</span>
<span class="line-removed">2579 </span>
<span class="line-removed">2580   // For all blocks</span>
<span class="line-removed">2581   int pc = 0x0;                 // Program counter</span>
<span class="line-removed">2582   char starts_bundle = &#39; &#39;;</span>
<span class="line-removed">2583   _regalloc-&gt;dump_frame();</span>
<span class="line-removed">2584 </span>
<span class="line-removed">2585   Node *n = NULL;</span>
<span class="line-removed">2586   for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {</span>
<span class="line-removed">2587     if (VMThread::should_terminate()) {</span>
<span class="line-removed">2588       cut_short = true;</span>
<span class="line-removed">2589       break;</span>
<span class="line-removed">2590     }</span>
<span class="line-removed">2591     Block* block = _cfg-&gt;get_block(i);</span>
<span class="line-removed">2592     if (block-&gt;is_connector() &amp;&amp; !Verbose) {</span>
<span class="line-removed">2593       continue;</span>
<span class="line-removed">2594     }</span>
<span class="line-removed">2595     n = block-&gt;head();</span>
<span class="line-removed">2596     if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {</span>
<span class="line-removed">2597       pc = pcs[n-&gt;_idx];</span>
<span class="line-removed">2598       st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);</span>
<span class="line-removed">2599     }</span>
<span class="line-removed">2600     st-&gt;fill_to(prefix_len);</span>
<span class="line-removed">2601     block-&gt;dump_head(_cfg, st);</span>
<span class="line-removed">2602     if (block-&gt;is_connector()) {</span>
<span class="line-removed">2603       st-&gt;fill_to(prefix_len);</span>
<span class="line-removed">2604       st-&gt;print_cr(&quot;# Empty connector block&quot;);</span>
<span class="line-removed">2605     } else if (block-&gt;num_preds() == 2 &amp;&amp; block-&gt;pred(1)-&gt;is_CatchProj() &amp;&amp; block-&gt;pred(1)-&gt;as_CatchProj()-&gt;_con == CatchProjNode::fall_through_index) {</span>
<span class="line-removed">2606       st-&gt;fill_to(prefix_len);</span>
<span class="line-removed">2607       st-&gt;print_cr(&quot;# Block is sole successor of call&quot;);</span>
<span class="line-removed">2608     }</span>
<span class="line-removed">2609 </span>
<span class="line-removed">2610     // For all instructions</span>
<span class="line-removed">2611     Node *delay = NULL;</span>
<span class="line-removed">2612     for (uint j = 0; j &lt; block-&gt;number_of_nodes(); j++) {</span>
<span class="line-removed">2613       if (VMThread::should_terminate()) {</span>
<span class="line-removed">2614         cut_short = true;</span>
<span class="line-removed">2615         break;</span>
<span class="line-removed">2616       }</span>
<span class="line-removed">2617       n = block-&gt;get_node(j);</span>
<span class="line-removed">2618       if (valid_bundle_info(n)) {</span>
<span class="line-removed">2619         Bundle* bundle = node_bundling(n);</span>
<span class="line-removed">2620         if (bundle-&gt;used_in_unconditional_delay()) {</span>
<span class="line-removed">2621           delay = n;</span>
<span class="line-removed">2622           continue;</span>
<span class="line-removed">2623         }</span>
<span class="line-removed">2624         if (bundle-&gt;starts_bundle()) {</span>
<span class="line-removed">2625           starts_bundle = &#39;+&#39;;</span>
<span class="line-removed">2626         }</span>
<span class="line-removed">2627       }</span>
<span class="line-removed">2628 </span>
<span class="line-removed">2629       if (WizardMode) {</span>
<span class="line-removed">2630         n-&gt;dump();</span>
<span class="line-removed">2631       }</span>
<span class="line-removed">2632 </span>
<span class="line-removed">2633       if( !n-&gt;is_Region() &amp;&amp;    // Dont print in the Assembly</span>
<span class="line-removed">2634           !n-&gt;is_Phi() &amp;&amp;       // a few noisely useless nodes</span>
<span class="line-removed">2635           !n-&gt;is_Proj() &amp;&amp;</span>
<span class="line-removed">2636           !n-&gt;is_MachTemp() &amp;&amp;</span>
<span class="line-removed">2637           !n-&gt;is_SafePointScalarObject() &amp;&amp;</span>
<span class="line-removed">2638           !n-&gt;is_Catch() &amp;&amp;     // Would be nice to print exception table targets</span>
<span class="line-removed">2639           !n-&gt;is_MergeMem() &amp;&amp;  // Not very interesting</span>
<span class="line-removed">2640           !n-&gt;is_top() &amp;&amp;       // Debug info table constants</span>
<span class="line-removed">2641           !(n-&gt;is_Con() &amp;&amp; !n-&gt;is_Mach())// Debug info table constants</span>
<span class="line-removed">2642           ) {</span>
<span class="line-removed">2643         if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {</span>
<span class="line-removed">2644           pc = pcs[n-&gt;_idx];</span>
<span class="line-removed">2645           st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);</span>
<span class="line-removed">2646         } else {</span>
<span class="line-removed">2647           st-&gt;fill_to(pc_digits);</span>
<span class="line-removed">2648         }</span>
<span class="line-removed">2649         st-&gt;print(&quot; %c &quot;, starts_bundle);</span>
<span class="line-removed">2650         starts_bundle = &#39; &#39;;</span>
<span class="line-removed">2651         st-&gt;fill_to(prefix_len);</span>
<span class="line-removed">2652         n-&gt;format(_regalloc, st);</span>
<span class="line-removed">2653         st-&gt;cr();</span>
<span class="line-removed">2654       }</span>
<span class="line-removed">2655 </span>
<span class="line-removed">2656       // If we have an instruction with a delay slot, and have seen a delay,</span>
<span class="line-removed">2657       // then back up and print it</span>
<span class="line-removed">2658       if (valid_bundle_info(n) &amp;&amp; node_bundling(n)-&gt;use_unconditional_delay()) {</span>
<span class="line-removed">2659         // Coverity finding - Explicit null dereferenced.</span>
<span class="line-removed">2660         guarantee(delay != NULL, &quot;no unconditional delay instruction&quot;);</span>
<span class="line-removed">2661         if (WizardMode) delay-&gt;dump();</span>
<span class="line-removed">2662 </span>
<span class="line-removed">2663         if (node_bundling(delay)-&gt;starts_bundle())</span>
<span class="line-removed">2664           starts_bundle = &#39;+&#39;;</span>
<span class="line-removed">2665         if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {</span>
<span class="line-removed">2666           pc = pcs[n-&gt;_idx];</span>
<span class="line-removed">2667           st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);</span>
<span class="line-removed">2668         } else {</span>
<span class="line-removed">2669           st-&gt;fill_to(pc_digits);</span>
<span class="line-removed">2670         }</span>
<span class="line-removed">2671         st-&gt;print(&quot; %c &quot;, starts_bundle);</span>
<span class="line-removed">2672         starts_bundle = &#39; &#39;;</span>
<span class="line-removed">2673         st-&gt;fill_to(prefix_len);</span>
<span class="line-removed">2674         delay-&gt;format(_regalloc, st);</span>
<span class="line-removed">2675         st-&gt;cr();</span>
<span class="line-removed">2676         delay = NULL;</span>
<span class="line-removed">2677       }</span>
<span class="line-removed">2678 </span>
<span class="line-removed">2679       // Dump the exception table as well</span>
<span class="line-removed">2680       if( n-&gt;is_Catch() &amp;&amp; (Verbose || WizardMode) ) {</span>
<span class="line-removed">2681         // Print the exception table for this offset</span>
<span class="line-removed">2682         _handler_table.print_subtable_for(pc);</span>
<span class="line-removed">2683       }</span>
<span class="line-removed">2684       st-&gt;bol(); // Make sure we start on a new line</span>
<span class="line-removed">2685     }</span>
<span class="line-removed">2686     st-&gt;cr(); // one empty line between blocks</span>
<span class="line-removed">2687     assert(cut_short || delay == NULL, &quot;no unconditional delay branch&quot;);</span>
<span class="line-removed">2688   } // End of per-block dump</span>
<span class="line-removed">2689 </span>
<span class="line-removed">2690   if (cut_short)  st-&gt;print_cr(&quot;*** disassembly is cut short ***&quot;);</span>
<span class="line-removed">2691 }</span>
<span class="line-removed">2692 #endif</span>
<span class="line-removed">2693 </span>
2694 //------------------------------Final_Reshape_Counts---------------------------
2695 // This class defines counters to help identify when a method
2696 // may/must be executed using hardware with only 24-bit precision.
2697 struct Final_Reshape_Counts : public StackObj {
2698   int  _call_count;             // count non-inlined &#39;common&#39; calls
2699   int  _float_count;            // count float ops requiring 24-bit precision
2700   int  _double_count;           // count double ops requiring more precision
2701   int  _java_call_count;        // count non-inlined &#39;java&#39; calls
2702   int  _inner_loop_count;       // count loops which need alignment
2703   VectorSet _visited;           // Visitation flags
2704   Node_List _tests;             // Set of IfNodes &amp; PCTableNodes
2705 
2706   Final_Reshape_Counts() :
2707     _call_count(0), _float_count(0), _double_count(0),
2708     _java_call_count(0), _inner_loop_count(0),
2709     _visited( Thread::current()-&gt;resource_area() ) { }
2710 
2711   void inc_call_count  () { _call_count  ++; }
2712   void inc_float_count () { _float_count ++; }
2713   void inc_double_count() { _double_count++; }
</pre>
<hr />
<pre>
3696         return true;            // Not all targets reachable!
3697       }
3698     }
3699     // Check that I actually visited all kids.  Unreached kids
3700     // must be infinite loops.
3701     for (DUIterator_Fast jmax, j = n-&gt;fast_outs(jmax); j &lt; jmax; j++)
3702       if (!frc._visited.test(n-&gt;fast_out(j)-&gt;_idx)) {
3703         record_method_not_compilable(&quot;infinite loop&quot;);
3704         return true;            // Found unvisited kid; must be unreach
3705       }
3706 
3707     // Here so verification code in final_graph_reshaping_walk()
3708     // always see an OuterStripMinedLoopEnd
3709     if (n-&gt;is_OuterStripMinedLoopEnd()) {
3710       IfNode* init_iff = n-&gt;as_If();
3711       Node* iff = new IfNode(init_iff-&gt;in(0), init_iff-&gt;in(1), init_iff-&gt;_prob, init_iff-&gt;_fcnt);
3712       n-&gt;subsume_by(iff, this);
3713     }
3714   }
3715 

3716   // If original bytecodes contained a mixture of floats and doubles
3717   // check if the optimizer has made it homogenous, item (3).
<span class="line-modified">3718   if( Use24BitFPMode &amp;&amp; Use24BitFP &amp;&amp; UseSSE == 0 &amp;&amp;</span>
3719       frc.get_float_count() &gt; 32 &amp;&amp;
3720       frc.get_double_count() == 0 &amp;&amp;
3721       (10 * frc.get_call_count() &lt; frc.get_float_count()) ) {
<span class="line-modified">3722     set_24_bit_selection_and_mode( false,  true );</span>
3723   }

3724 
3725   set_java_calls(frc.get_java_call_count());
3726   set_inner_loops(frc.get_inner_loop_count());
3727 
3728   // No infinite loops, no reason to bail out.
3729   return false;
3730 }
3731 
3732 //-----------------------------too_many_traps----------------------------------
3733 // Report if there are too many traps at the current method and bci.
3734 // Return true if there was a trap, and/or PerMethodTrapLimit is exceeded.
3735 bool Compile::too_many_traps(ciMethod* method,
3736                              int bci,
3737                              Deoptimization::DeoptReason reason) {
3738   ciMethodData* md = method-&gt;method_data();
3739   if (md-&gt;is_empty()) {
3740     // Assume the trap has not occurred, or that it occurred only
3741     // because of a transient condition during start-up in the interpreter.
3742     return false;
3743   }
</pre>
<hr />
<pre>
3964   } else {
3965     _log = NULL;
3966   }
3967 
3968 #ifdef ASSERT
3969   if (PrintIdealNodeCount) {
3970     tty-&gt;print_cr(&quot;phase name=&#39;%s&#39; nodes=&#39;%d&#39; live=&#39;%d&#39; live_graph_walk=&#39;%d&#39;&quot;,
3971                   _phase_name, C-&gt;unique(), C-&gt;live_nodes(), C-&gt;count_live_nodes_by_graph_walk());
3972   }
3973 
3974   if (VerifyIdealNodeCount) {
3975     Compile::current()-&gt;print_missing_nodes();
3976   }
3977 #endif
3978 
3979   if (_log != NULL) {
3980     _log-&gt;done(&quot;phase name=&#39;%s&#39; nodes=&#39;%d&#39; live=&#39;%d&#39;&quot;, _phase_name, C-&gt;unique(), C-&gt;live_nodes());
3981   }
3982 }
3983 
<span class="line-removed">3984 //=============================================================================</span>
<span class="line-removed">3985 // Two Constant&#39;s are equal when the type and the value are equal.</span>
<span class="line-removed">3986 bool Compile::Constant::operator==(const Constant&amp; other) {</span>
<span class="line-removed">3987   if (type()          != other.type()         )  return false;</span>
<span class="line-removed">3988   if (can_be_reused() != other.can_be_reused())  return false;</span>
<span class="line-removed">3989   // For floating point values we compare the bit pattern.</span>
<span class="line-removed">3990   switch (type()) {</span>
<span class="line-removed">3991   case T_INT:</span>
<span class="line-removed">3992   case T_FLOAT:   return (_v._value.i == other._v._value.i);</span>
<span class="line-removed">3993   case T_LONG:</span>
<span class="line-removed">3994   case T_DOUBLE:  return (_v._value.j == other._v._value.j);</span>
<span class="line-removed">3995   case T_OBJECT:</span>
<span class="line-removed">3996   case T_ADDRESS: return (_v._value.l == other._v._value.l);</span>
<span class="line-removed">3997   case T_VOID:    return (_v._value.l == other._v._value.l);  // jump-table entries</span>
<span class="line-removed">3998   case T_METADATA: return (_v._metadata == other._v._metadata);</span>
<span class="line-removed">3999   default: ShouldNotReachHere(); return false;</span>
<span class="line-removed">4000   }</span>
<span class="line-removed">4001 }</span>
<span class="line-removed">4002 </span>
<span class="line-removed">4003 static int type_to_size_in_bytes(BasicType t) {</span>
<span class="line-removed">4004   switch (t) {</span>
<span class="line-removed">4005   case T_INT:     return sizeof(jint   );</span>
<span class="line-removed">4006   case T_LONG:    return sizeof(jlong  );</span>
<span class="line-removed">4007   case T_FLOAT:   return sizeof(jfloat );</span>
<span class="line-removed">4008   case T_DOUBLE:  return sizeof(jdouble);</span>
<span class="line-removed">4009   case T_METADATA: return sizeof(Metadata*);</span>
<span class="line-removed">4010     // We use T_VOID as marker for jump-table entries (labels) which</span>
<span class="line-removed">4011     // need an internal word relocation.</span>
<span class="line-removed">4012   case T_VOID:</span>
<span class="line-removed">4013   case T_ADDRESS:</span>
<span class="line-removed">4014   case T_OBJECT:  return sizeof(jobject);</span>
<span class="line-removed">4015   default:</span>
<span class="line-removed">4016     ShouldNotReachHere();</span>
<span class="line-removed">4017     return -1;</span>
<span class="line-removed">4018   }</span>
<span class="line-removed">4019 }</span>
<span class="line-removed">4020 </span>
<span class="line-removed">4021 int Compile::ConstantTable::qsort_comparator(Constant* a, Constant* b) {</span>
<span class="line-removed">4022   // sort descending</span>
<span class="line-removed">4023   if (a-&gt;freq() &gt; b-&gt;freq())  return -1;</span>
<span class="line-removed">4024   if (a-&gt;freq() &lt; b-&gt;freq())  return  1;</span>
<span class="line-removed">4025   return 0;</span>
<span class="line-removed">4026 }</span>
<span class="line-removed">4027 </span>
<span class="line-removed">4028 void Compile::ConstantTable::calculate_offsets_and_size() {</span>
<span class="line-removed">4029   // First, sort the array by frequencies.</span>
<span class="line-removed">4030   _constants.sort(qsort_comparator);</span>
<span class="line-removed">4031 </span>
<span class="line-removed">4032 #ifdef ASSERT</span>
<span class="line-removed">4033   // Make sure all jump-table entries were sorted to the end of the</span>
<span class="line-removed">4034   // array (they have a negative frequency).</span>
<span class="line-removed">4035   bool found_void = false;</span>
<span class="line-removed">4036   for (int i = 0; i &lt; _constants.length(); i++) {</span>
<span class="line-removed">4037     Constant con = _constants.at(i);</span>
<span class="line-removed">4038     if (con.type() == T_VOID)</span>
<span class="line-removed">4039       found_void = true;  // jump-tables</span>
<span class="line-removed">4040     else</span>
<span class="line-removed">4041       assert(!found_void, &quot;wrong sorting&quot;);</span>
<span class="line-removed">4042   }</span>
<span class="line-removed">4043 #endif</span>
<span class="line-removed">4044 </span>
<span class="line-removed">4045   int offset = 0;</span>
<span class="line-removed">4046   for (int i = 0; i &lt; _constants.length(); i++) {</span>
<span class="line-removed">4047     Constant* con = _constants.adr_at(i);</span>
<span class="line-removed">4048 </span>
<span class="line-removed">4049     // Align offset for type.</span>
<span class="line-removed">4050     int typesize = type_to_size_in_bytes(con-&gt;type());</span>
<span class="line-removed">4051     offset = align_up(offset, typesize);</span>
<span class="line-removed">4052     con-&gt;set_offset(offset);   // set constant&#39;s offset</span>
<span class="line-removed">4053 </span>
<span class="line-removed">4054     if (con-&gt;type() == T_VOID) {</span>
<span class="line-removed">4055       MachConstantNode* n = (MachConstantNode*) con-&gt;get_jobject();</span>
<span class="line-removed">4056       offset = offset + typesize * n-&gt;outcnt();  // expand jump-table</span>
<span class="line-removed">4057     } else {</span>
<span class="line-removed">4058       offset = offset + typesize;</span>
<span class="line-removed">4059     }</span>
<span class="line-removed">4060   }</span>
<span class="line-removed">4061 </span>
<span class="line-removed">4062   // Align size up to the next section start (which is insts; see</span>
<span class="line-removed">4063   // CodeBuffer::align_at_start).</span>
<span class="line-removed">4064   assert(_size == -1, &quot;already set?&quot;);</span>
<span class="line-removed">4065   _size = align_up(offset, (int)CodeEntryAlignment);</span>
<span class="line-removed">4066 }</span>
<span class="line-removed">4067 </span>
<span class="line-removed">4068 void Compile::ConstantTable::emit(CodeBuffer&amp; cb) {</span>
<span class="line-removed">4069   MacroAssembler _masm(&amp;cb);</span>
<span class="line-removed">4070   for (int i = 0; i &lt; _constants.length(); i++) {</span>
<span class="line-removed">4071     Constant con = _constants.at(i);</span>
<span class="line-removed">4072     address constant_addr = NULL;</span>
<span class="line-removed">4073     switch (con.type()) {</span>
<span class="line-removed">4074     case T_INT:    constant_addr = _masm.int_constant(   con.get_jint()   ); break;</span>
<span class="line-removed">4075     case T_LONG:   constant_addr = _masm.long_constant(  con.get_jlong()  ); break;</span>
<span class="line-removed">4076     case T_FLOAT:  constant_addr = _masm.float_constant( con.get_jfloat() ); break;</span>
<span class="line-removed">4077     case T_DOUBLE: constant_addr = _masm.double_constant(con.get_jdouble()); break;</span>
<span class="line-removed">4078     case T_OBJECT: {</span>
<span class="line-removed">4079       jobject obj = con.get_jobject();</span>
<span class="line-removed">4080       int oop_index = _masm.oop_recorder()-&gt;find_index(obj);</span>
<span class="line-removed">4081       constant_addr = _masm.address_constant((address) obj, oop_Relocation::spec(oop_index));</span>
<span class="line-removed">4082       break;</span>
<span class="line-removed">4083     }</span>
<span class="line-removed">4084     case T_ADDRESS: {</span>
<span class="line-removed">4085       address addr = (address) con.get_jobject();</span>
<span class="line-removed">4086       constant_addr = _masm.address_constant(addr);</span>
<span class="line-removed">4087       break;</span>
<span class="line-removed">4088     }</span>
<span class="line-removed">4089     // We use T_VOID as marker for jump-table entries (labels) which</span>
<span class="line-removed">4090     // need an internal word relocation.</span>
<span class="line-removed">4091     case T_VOID: {</span>
<span class="line-removed">4092       MachConstantNode* n = (MachConstantNode*) con.get_jobject();</span>
<span class="line-removed">4093       // Fill the jump-table with a dummy word.  The real value is</span>
<span class="line-removed">4094       // filled in later in fill_jump_table.</span>
<span class="line-removed">4095       address dummy = (address) n;</span>
<span class="line-removed">4096       constant_addr = _masm.address_constant(dummy);</span>
<span class="line-removed">4097       // Expand jump-table</span>
<span class="line-removed">4098       for (uint i = 1; i &lt; n-&gt;outcnt(); i++) {</span>
<span class="line-removed">4099         address temp_addr = _masm.address_constant(dummy + i);</span>
<span class="line-removed">4100         assert(temp_addr, &quot;consts section too small&quot;);</span>
<span class="line-removed">4101       }</span>
<span class="line-removed">4102       break;</span>
<span class="line-removed">4103     }</span>
<span class="line-removed">4104     case T_METADATA: {</span>
<span class="line-removed">4105       Metadata* obj = con.get_metadata();</span>
<span class="line-removed">4106       int metadata_index = _masm.oop_recorder()-&gt;find_index(obj);</span>
<span class="line-removed">4107       constant_addr = _masm.address_constant((address) obj, metadata_Relocation::spec(metadata_index));</span>
<span class="line-removed">4108       break;</span>
<span class="line-removed">4109     }</span>
<span class="line-removed">4110     default: ShouldNotReachHere();</span>
<span class="line-removed">4111     }</span>
<span class="line-removed">4112     assert(constant_addr, &quot;consts section too small&quot;);</span>
<span class="line-removed">4113     assert((constant_addr - _masm.code()-&gt;consts()-&gt;start()) == con.offset(),</span>
<span class="line-removed">4114             &quot;must be: %d == %d&quot;, (int) (constant_addr - _masm.code()-&gt;consts()-&gt;start()), (int)(con.offset()));</span>
<span class="line-removed">4115   }</span>
<span class="line-removed">4116 }</span>
<span class="line-removed">4117 </span>
<span class="line-removed">4118 int Compile::ConstantTable::find_offset(Constant&amp; con) const {</span>
<span class="line-removed">4119   int idx = _constants.find(con);</span>
<span class="line-removed">4120   guarantee(idx != -1, &quot;constant must be in constant table&quot;);</span>
<span class="line-removed">4121   int offset = _constants.at(idx).offset();</span>
<span class="line-removed">4122   guarantee(offset != -1, &quot;constant table not emitted yet?&quot;);</span>
<span class="line-removed">4123   return offset;</span>
<span class="line-removed">4124 }</span>
<span class="line-removed">4125 </span>
<span class="line-removed">4126 void Compile::ConstantTable::add(Constant&amp; con) {</span>
<span class="line-removed">4127   if (con.can_be_reused()) {</span>
<span class="line-removed">4128     int idx = _constants.find(con);</span>
<span class="line-removed">4129     if (idx != -1 &amp;&amp; _constants.at(idx).can_be_reused()) {</span>
<span class="line-removed">4130       _constants.adr_at(idx)-&gt;inc_freq(con.freq());  // increase the frequency by the current value</span>
<span class="line-removed">4131       return;</span>
<span class="line-removed">4132     }</span>
<span class="line-removed">4133   }</span>
<span class="line-removed">4134   (void) _constants.append(con);</span>
<span class="line-removed">4135 }</span>
<span class="line-removed">4136 </span>
<span class="line-removed">4137 Compile::Constant Compile::ConstantTable::add(MachConstantNode* n, BasicType type, jvalue value) {</span>
<span class="line-removed">4138   Block* b = Compile::current()-&gt;cfg()-&gt;get_block_for_node(n);</span>
<span class="line-removed">4139   Constant con(type, value, b-&gt;_freq);</span>
<span class="line-removed">4140   add(con);</span>
<span class="line-removed">4141   return con;</span>
<span class="line-removed">4142 }</span>
<span class="line-removed">4143 </span>
<span class="line-removed">4144 Compile::Constant Compile::ConstantTable::add(Metadata* metadata) {</span>
<span class="line-removed">4145   Constant con(metadata);</span>
<span class="line-removed">4146   add(con);</span>
<span class="line-removed">4147   return con;</span>
<span class="line-removed">4148 }</span>
<span class="line-removed">4149 </span>
<span class="line-removed">4150 Compile::Constant Compile::ConstantTable::add(MachConstantNode* n, MachOper* oper) {</span>
<span class="line-removed">4151   jvalue value;</span>
<span class="line-removed">4152   BasicType type = oper-&gt;type()-&gt;basic_type();</span>
<span class="line-removed">4153   switch (type) {</span>
<span class="line-removed">4154   case T_LONG:    value.j = oper-&gt;constantL(); break;</span>
<span class="line-removed">4155   case T_FLOAT:   value.f = oper-&gt;constantF(); break;</span>
<span class="line-removed">4156   case T_DOUBLE:  value.d = oper-&gt;constantD(); break;</span>
<span class="line-removed">4157   case T_OBJECT:</span>
<span class="line-removed">4158   case T_ADDRESS: value.l = (jobject) oper-&gt;constant(); break;</span>
<span class="line-removed">4159   case T_METADATA: return add((Metadata*)oper-&gt;constant()); break;</span>
<span class="line-removed">4160   default: guarantee(false, &quot;unhandled type: %s&quot;, type2name(type));</span>
<span class="line-removed">4161   }</span>
<span class="line-removed">4162   return add(n, type, value);</span>
<span class="line-removed">4163 }</span>
<span class="line-removed">4164 </span>
<span class="line-removed">4165 Compile::Constant Compile::ConstantTable::add_jump_table(MachConstantNode* n) {</span>
<span class="line-removed">4166   jvalue value;</span>
<span class="line-removed">4167   // We can use the node pointer here to identify the right jump-table</span>
<span class="line-removed">4168   // as this method is called from Compile::Fill_buffer right before</span>
<span class="line-removed">4169   // the MachNodes are emitted and the jump-table is filled (means the</span>
<span class="line-removed">4170   // MachNode pointers do not change anymore).</span>
<span class="line-removed">4171   value.l = (jobject) n;</span>
<span class="line-removed">4172   Constant con(T_VOID, value, next_jump_table_freq(), false);  // Labels of a jump-table cannot be reused.</span>
<span class="line-removed">4173   add(con);</span>
<span class="line-removed">4174   return con;</span>
<span class="line-removed">4175 }</span>
<span class="line-removed">4176 </span>
<span class="line-removed">4177 void Compile::ConstantTable::fill_jump_table(CodeBuffer&amp; cb, MachConstantNode* n, GrowableArray&lt;Label*&gt; labels) const {</span>
<span class="line-removed">4178   // If called from Compile::scratch_emit_size do nothing.</span>
<span class="line-removed">4179   if (Compile::current()-&gt;in_scratch_emit_size())  return;</span>
<span class="line-removed">4180 </span>
<span class="line-removed">4181   assert(labels.is_nonempty(), &quot;must be&quot;);</span>
<span class="line-removed">4182   assert((uint) labels.length() == n-&gt;outcnt(), &quot;must be equal: %d == %d&quot;, labels.length(), n-&gt;outcnt());</span>
<span class="line-removed">4183 </span>
<span class="line-removed">4184   // Since MachConstantNode::constant_offset() also contains</span>
<span class="line-removed">4185   // table_base_offset() we need to subtract the table_base_offset()</span>
<span class="line-removed">4186   // to get the plain offset into the constant table.</span>
<span class="line-removed">4187   int offset = n-&gt;constant_offset() - table_base_offset();</span>
<span class="line-removed">4188 </span>
<span class="line-removed">4189   MacroAssembler _masm(&amp;cb);</span>
<span class="line-removed">4190   address* jump_table_base = (address*) (_masm.code()-&gt;consts()-&gt;start() + offset);</span>
<span class="line-removed">4191 </span>
<span class="line-removed">4192   for (uint i = 0; i &lt; n-&gt;outcnt(); i++) {</span>
<span class="line-removed">4193     address* constant_addr = &amp;jump_table_base[i];</span>
<span class="line-removed">4194     assert(*constant_addr == (((address) n) + i), &quot;all jump-table entries must contain adjusted node pointer: &quot; INTPTR_FORMAT &quot; == &quot; INTPTR_FORMAT, p2i(*constant_addr), p2i(((address) n) + i));</span>
<span class="line-removed">4195     *constant_addr = cb.consts()-&gt;target(*labels.at(i), (address) constant_addr);</span>
<span class="line-removed">4196     cb.consts()-&gt;relocate((address) constant_addr, relocInfo::internal_word_type);</span>
<span class="line-removed">4197   }</span>
<span class="line-removed">4198 }</span>
<span class="line-removed">4199 </span>
4200 //----------------------------static_subtype_check-----------------------------
4201 // Shortcut important common cases when superklass is exact:
4202 // (0) superklass is java.lang.Object (can occur in reflective code)
4203 // (1) subklass is already limited to a subtype of superklass =&gt; always ok
4204 // (2) subklass does not overlap with superklass =&gt; always fail
4205 // (3) superklass has NO subtypes and we can check with a simple compare.
4206 int Compile::static_subtype_check(ciKlass* superk, ciKlass* subk) {
4207   if (StressReflectiveCode) {
4208     return SSC_full_test;       // Let caller generate the general case.
4209   }
4210 
4211   if (superk == env()-&gt;Object_klass()) {
4212     return SSC_always_true;     // (0) this test cannot fail
4213   }
4214 
4215   ciType* superelem = superk;
4216   if (superelem-&gt;is_array_klass())
4217     superelem = superelem-&gt;as_array_klass()-&gt;base_element_type();
4218 
4219   if (!subk-&gt;is_interface()) {  // cannot trust static interface types yet
</pre>
</td>
<td>
<hr />
<pre>
 233   #define PRINT_STAT_LINE(name, c, f) \
 234     tty-&gt;print_cr(&quot;  %4d (%4.1f%%) %s (%s)&quot;, (int)(c), ((c) * 100.0) / total, name, f);
 235   for (int index = 1 + (int)vmIntrinsics::_none; index &lt; (int)vmIntrinsics::ID_LIMIT; index++) {
 236     vmIntrinsics::ID id = (vmIntrinsics::ID) index;
 237     int   flags = _intrinsic_hist_flags[id];
 238     juint count = _intrinsic_hist_count[id];
 239     if ((flags | count) != 0) {
 240       PRINT_STAT_LINE(vmIntrinsics::name_at(id), count, format_flags(flags, flagsbuf));
 241     }
 242   }
 243   PRINT_STAT_LINE(&quot;total&quot;, total, format_flags(_intrinsic_hist_flags[vmIntrinsics::_none], flagsbuf));
 244   if (xtty != NULL)  xtty-&gt;tail(&quot;statistics&quot;);
 245 }
 246 
 247 void Compile::print_statistics() {
 248   { ttyLocker ttyl;
 249     if (xtty != NULL)  xtty-&gt;head(&quot;statistics type=&#39;opto&#39;&quot;);
 250     Parse::print_statistics();
 251     PhaseCCP::print_statistics();
 252     PhaseRegAlloc::print_statistics();
<span class="line-modified"> 253     PhaseOutput::print_statistics();</span>
 254     PhasePeephole::print_statistics();
 255     PhaseIdealLoop::print_statistics();
 256     if (xtty != NULL)  xtty-&gt;tail(&quot;statistics&quot;);
 257   }
 258   if (_intrinsic_hist_flags[vmIntrinsics::_none] != 0) {
 259     // put this under its own &lt;statistics&gt; element.
 260     print_intrinsic_statistics();
 261   }
 262 }
 263 #endif //PRODUCT
 264 











 265 void Compile::gvn_replace_by(Node* n, Node* nn) {
 266   for (DUIterator_Last imin, i = n-&gt;last_outs(imin); i &gt;= imin; ) {
 267     Node* use = n-&gt;last_out(i);
 268     bool is_in_table = initial_gvn()-&gt;hash_delete(use);
 269     uint uses_found = 0;
 270     for (uint j = 0; j &lt; use-&gt;len(); j++) {
 271       if (use-&gt;in(j) == n) {
 272         if (j &lt; use-&gt;req())
 273           use-&gt;set_req(j, nn);
 274         else
 275           use-&gt;set_prec(j, nn);
 276         uses_found++;
 277       }
 278     }
 279     if (is_in_table) {
 280       // reinsert into table
 281       initial_gvn()-&gt;hash_find_insert(use);
 282     }
 283     record_for_igvn(use);
 284     i -= uses_found;    // we deleted 1 or more copies of this edge
</pre>
<hr />
<pre>
 395     if (!useful.member(n)) {
 396       remove_expensive_node(n);
 397     }
 398   }
 399   // Remove useless Opaque4 nodes
 400   for (int i = opaque4_count() - 1; i &gt;= 0; i--) {
 401     Node* opaq = opaque4_node(i);
 402     if (!useful.member(opaq)) {
 403       remove_opaque4_node(opaq);
 404     }
 405   }
 406   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 407   bs-&gt;eliminate_useless_gc_barriers(useful, this);
 408   // clean up the late inline lists
 409   remove_useless_late_inlines(&amp;_string_late_inlines, useful);
 410   remove_useless_late_inlines(&amp;_boxing_late_inlines, useful);
 411   remove_useless_late_inlines(&amp;_late_inlines, useful);
 412   debug_only(verify_graph_edges(true/*check for no_dead_code*/);)
 413 }
 414 


















 415 // ============================================================================
 416 //------------------------------CompileWrapper---------------------------------
 417 class CompileWrapper : public StackObj {
 418   Compile *const _compile;
 419  public:
 420   CompileWrapper(Compile* compile);
 421 
 422   ~CompileWrapper();
 423 };
 424 
 425 CompileWrapper::CompileWrapper(Compile* compile) : _compile(compile) {
 426   // the Compile* pointer is stored in the current ciEnv:
 427   ciEnv* env = compile-&gt;env();
 428   assert(env == ciEnv::current(), &quot;must already be a ciEnv active&quot;);
 429   assert(env-&gt;compiler_data() == NULL, &quot;compile already active?&quot;);
 430   env-&gt;set_compiler_data(compile);
 431   assert(compile == Compile::current(), &quot;sanity&quot;);
 432 
 433   compile-&gt;set_type_dict(NULL);
 434   compile-&gt;set_clone_map(new Dict(cmpkey, hashkey, _compile-&gt;comp_arena()));
 435   compile-&gt;clone_map().set_clone_idx(0);
 436   compile-&gt;set_type_last_size(0);
 437   compile-&gt;set_last_tf(NULL, NULL);
 438   compile-&gt;set_indexSet_arena(NULL);
 439   compile-&gt;set_indexSet_free_block_list(NULL);
 440   compile-&gt;init_type_arena();
 441   Type::Initialize(compile);

 442   _compile-&gt;begin_method();
 443   _compile-&gt;clone_map().set_debug(_compile-&gt;has_method() &amp;&amp; _compile-&gt;directive()-&gt;CloneMapDebugOption);
 444 }
 445 CompileWrapper::~CompileWrapper() {
 446   _compile-&gt;end_method();


 447   _compile-&gt;env()-&gt;set_compiler_data(NULL);
 448 }
 449 
 450 
 451 //----------------------------print_compile_messages---------------------------
 452 void Compile::print_compile_messages() {
 453 #ifndef PRODUCT
 454   // Check if recompiling
 455   if (_subsume_loads == false &amp;&amp; PrintOpto) {
 456     // Recompiling without allowing machine instructions to subsume loads
 457     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 458     tty-&gt;print_cr(&quot;** Bailout: Recompile without subsuming loads          **&quot;);
 459     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 460   }
 461   if (_do_escape_analysis != DoEscapeAnalysis &amp;&amp; PrintOpto) {
 462     // Recompiling without escape analysis
 463     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 464     tty-&gt;print_cr(&quot;** Bailout: Recompile without escape analysis          **&quot;);
 465     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 466   }
</pre>
<hr />
<pre>
 471     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 472   }
 473   if (C-&gt;directive()-&gt;BreakAtCompileOption) {
 474     // Open the debugger when compiling this method.
 475     tty-&gt;print(&quot;### Breaking when compiling: &quot;);
 476     method()-&gt;print_short_name();
 477     tty-&gt;cr();
 478     BREAKPOINT;
 479   }
 480 
 481   if( PrintOpto ) {
 482     if (is_osr_compilation()) {
 483       tty-&gt;print(&quot;[OSR]%3d&quot;, _compile_id);
 484     } else {
 485       tty-&gt;print(&quot;%3d&quot;, _compile_id);
 486     }
 487   }
 488 #endif
 489 }
 490 


































































































 491 // ============================================================================
 492 //------------------------------Compile standard-------------------------------
 493 debug_only( int Compile::_debug_idx = 100000; )
 494 
 495 // Compile a method.  entry_bci is -1 for normal compilations and indicates
 496 // the continuation bci for on stack replacement.
 497 
 498 
<span class="line-modified"> 499 Compile::Compile( ciEnv* ci_env, ciMethod* target, int osr_bci,</span>
 500                   bool subsume_loads, bool do_escape_analysis, bool eliminate_boxing, DirectiveSet* directive)
 501                 : Phase(Compiler),
 502                   _compile_id(ci_env-&gt;compile_id()),
 503                   _save_argument_registers(false),
 504                   _subsume_loads(subsume_loads),
 505                   _do_escape_analysis(do_escape_analysis),
 506                   _eliminate_boxing(eliminate_boxing),
 507                   _method(target),
 508                   _entry_bci(osr_bci),
 509                   _stub_function(NULL),
 510                   _stub_name(NULL),
 511                   _stub_entry_point(NULL),
 512                   _max_node_limit(MaxNodeLimit),


 513                   _inlining_progress(false),
 514                   _inlining_incrementally(false),
 515                   _do_cleanup(false),
 516                   _has_reserved_stack_access(target-&gt;has_reserved_stack_access()),
 517 #ifndef PRODUCT
 518                   _trace_opto_output(directive-&gt;TraceOptoOutputOption),
 519                   _print_ideal(directive-&gt;PrintIdealOption),
 520 #endif
 521                   _has_method_handle_invokes(false),
 522                   _clinit_barrier_on_entry(false),
 523                   _comp_arena(mtCompiler),
 524                   _barrier_set_state(BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;create_barrier_state(comp_arena())),
 525                   _env(ci_env),
 526                   _directive(directive),
 527                   _log(ci_env-&gt;log()),
 528                   _failure_reason(NULL),
 529                   _congraph(NULL),
 530 #ifndef PRODUCT
 531                   _printer(IdealGraphPrinter::printer()),
 532 #endif
</pre>
<hr />
<pre>
 534                   _dead_node_count(0),
 535                   _node_arena(mtCompiler),
 536                   _old_arena(mtCompiler),
 537                   _mach_constant_base_node(NULL),
 538                   _Compile_types(mtCompiler),
 539                   _initial_gvn(NULL),
 540                   _for_igvn(NULL),
 541                   _warm_calls(NULL),
 542                   _late_inlines(comp_arena(), 2, 0, NULL),
 543                   _string_late_inlines(comp_arena(), 2, 0, NULL),
 544                   _boxing_late_inlines(comp_arena(), 2, 0, NULL),
 545                   _late_inlines_pos(0),
 546                   _number_of_mh_late_inlines(0),
 547                   _print_inlining_stream(NULL),
 548                   _print_inlining_list(NULL),
 549                   _print_inlining_idx(0),
 550                   _print_inlining_output(NULL),
 551                   _replay_inline_data(NULL),
 552                   _java_calls(0),
 553                   _inner_loops(0),
<span class="line-modified"> 554                   _interpreter_frame_size(0)</span>





 555 #ifndef PRODUCT
 556                   , _in_dump_cnt(0)
 557 #endif
 558 {
 559   C = this;
 560 #ifndef PRODUCT
 561   if (_printer != NULL) {
 562     _printer-&gt;set_compile(this);
 563   }
 564 #endif
 565   CompileWrapper cw(this);
 566 
 567   if (CITimeVerbose) {
 568     tty-&gt;print(&quot; &quot;);
 569     target-&gt;holder()-&gt;name()-&gt;print();
 570     tty-&gt;print(&quot;.&quot;);
 571     target-&gt;print_short_name();
 572     tty-&gt;print(&quot;  &quot;);
 573   }
 574   TraceTime t1(&quot;Total compilation time&quot;, &amp;_t_totalCompilation, CITime, CITimeVerbose);
</pre>
<hr />
<pre>
 752       xtty-&gt;tail(&quot;ideal&quot;);
 753     }
 754   }
 755 #endif
 756 
 757 #ifdef ASSERT
 758   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 759   bs-&gt;verify_gc_barriers(this, BarrierSetC2::BeforeCodeGen);
 760 #endif
 761 
 762   // Dump compilation data to replay it.
 763   if (directive-&gt;DumpReplayOption) {
 764     env()-&gt;dump_replay_data(_compile_id);
 765   }
 766   if (directive-&gt;DumpInlineOption &amp;&amp; (ilt() != NULL)) {
 767     env()-&gt;dump_inline_data(_compile_id);
 768   }
 769 
 770   // Now that we know the size of all the monitors we can add a fixed slot
 771   // for the original deopt pc.
<span class="line-modified"> 772   int next_slot = fixed_slots() + (sizeof(address) / VMRegImpl::stack_slot_size);</span>


 773   set_fixed_slots(next_slot);
 774 
 775   // Compute when to use implicit null checks. Used by matching trap based
 776   // nodes and NullCheck optimization.
 777   set_allowed_deopt_reasons();
 778 
 779   // Now generate code
 780   Code_Gen();



































 781 }
 782 
 783 //------------------------------Compile----------------------------------------
 784 // Compile a runtime stub
 785 Compile::Compile( ciEnv* ci_env,
 786                   TypeFunc_generator generator,
 787                   address stub_function,
 788                   const char *stub_name,
 789                   int is_fancy_jump,
 790                   bool pass_tls,
 791                   bool save_arg_registers,
 792                   bool return_pc,
 793                   DirectiveSet* directive)
 794   : Phase(Compiler),
 795     _compile_id(0),
 796     _save_argument_registers(save_arg_registers),
 797     _subsume_loads(true),
 798     _do_escape_analysis(false),
 799     _eliminate_boxing(false),
 800     _method(NULL),
 801     _entry_bci(InvocationEntryBci),
 802     _stub_function(stub_function),
 803     _stub_name(stub_name),
 804     _stub_entry_point(NULL),
 805     _max_node_limit(MaxNodeLimit),


 806     _inlining_progress(false),
 807     _inlining_incrementally(false),
 808     _has_reserved_stack_access(false),
 809 #ifndef PRODUCT
 810     _trace_opto_output(directive-&gt;TraceOptoOutputOption),
 811     _print_ideal(directive-&gt;PrintIdealOption),
 812 #endif
 813     _has_method_handle_invokes(false),
 814     _clinit_barrier_on_entry(false),
 815     _comp_arena(mtCompiler),
 816     _barrier_set_state(BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;create_barrier_state(comp_arena())),
 817     _env(ci_env),
 818     _directive(directive),
 819     _log(ci_env-&gt;log()),
 820     _failure_reason(NULL),
 821     _congraph(NULL),
 822 #ifndef PRODUCT
 823     _printer(NULL),
 824 #endif
 825     _dead_node_list(comp_arena()),
 826     _dead_node_count(0),
 827     _node_arena(mtCompiler),
 828     _old_arena(mtCompiler),
 829     _mach_constant_base_node(NULL),
 830     _Compile_types(mtCompiler),
 831     _initial_gvn(NULL),
 832     _for_igvn(NULL),
 833     _warm_calls(NULL),
 834     _number_of_mh_late_inlines(0),
 835     _print_inlining_stream(NULL),
 836     _print_inlining_list(NULL),
 837     _print_inlining_idx(0),
 838     _print_inlining_output(NULL),
 839     _replay_inline_data(NULL),
 840     _java_calls(0),
 841     _inner_loops(0),
 842     _interpreter_frame_size(0),



 843 #ifndef PRODUCT
 844     _in_dump_cnt(0),
 845 #endif
 846     _allowed_reasons(0) {
 847   C = this;
 848 
 849   TraceTime t1(NULL, &amp;_t_totalCompilation, CITime, false);
 850   TraceTime t2(NULL, &amp;_t_stubCompilation, CITime, false);
 851 
 852 #ifndef PRODUCT
 853   set_print_assembly(PrintFrameConverterAssembly);
 854   set_parsed_irreducible_loop(false);
 855 #else
 856   set_print_assembly(false); // Must initialize.
 857 #endif
 858   set_has_irreducible_loop(false); // no loops
 859 
 860   CompileWrapper cw(this);
 861   Init(/*AliasLevel=*/ 0);
 862   init_tf((*generator)());
 863 
 864   {
 865     // The following is a dummy for the sake of GraphKit::gen_stub
 866     Unique_Node_List for_igvn(comp_arena());
 867     set_for_igvn(&amp;for_igvn);  // not used, but some GraphKit guys push on this
 868     PhaseGVN gvn(Thread::current()-&gt;resource_area(),255);
 869     set_initial_gvn(&amp;gvn);    // not significant, but GraphKit guys use it pervasively
 870     gvn.transform_no_reclaim(top());
 871 
 872     GraphKit kit;
 873     kit.gen_stub(stub_function, stub_name, is_fancy_jump, pass_tls, return_pc);
 874   }
 875 
 876   NOT_PRODUCT( verify_graph_edges(); )










 877 
<span class="line-modified"> 878   Code_Gen();</span>
















 879 }
 880 
 881 //------------------------------Init-------------------------------------------
 882 // Prepare for a single compilation
 883 void Compile::Init(int aliaslevel) {
 884   _unique  = 0;
 885   _regalloc = NULL;
 886 
 887   _tf      = NULL;  // filled in later
 888   _top     = NULL;  // cached later
 889   _matcher = NULL;  // filled in later
 890   _cfg     = NULL;  // filled in later
 891 
<span class="line-modified"> 892   IA32_ONLY( set_24_bit_selection_and_mode(true, false); )</span>
 893 
 894   _node_note_array = NULL;
 895   _default_node_notes = NULL;
 896   DEBUG_ONLY( _modified_nodes = NULL; ) // Used in Optimize()
 897 
 898   _immutable_memory = NULL; // filled in at first inquiry
 899 
 900   // Globally visible Nodes
 901   // First set TOP to NULL to give safe behavior during creation of RootNode
 902   set_cached_top_node(NULL);
 903   set_root(new RootNode());
 904   // Now that you have a Root to point to, create the real TOP
 905   set_cached_top_node( new ConNode(Type::TOP) );
 906   set_recent_alloc(NULL, NULL);
 907 
 908   // Create Debug Information Recorder to record scopes, oopmaps, etc.
 909   env()-&gt;set_oop_recorder(new OopRecorder(env()-&gt;arena()));
 910   env()-&gt;set_debug_info(new DebugInformationRecorder(env()-&gt;oop_recorder()));
 911   env()-&gt;set_dependencies(new Dependencies(env()));
 912 
</pre>
<hr />
<pre>
1586     }
1587     if (flat-&gt;isa_aryptr()) {
1588 #ifdef ASSERT
1589       const int header_size_min  = arrayOopDesc::base_offset_in_bytes(T_BYTE);
1590       // (T_BYTE has the weakest alignment and size restrictions...)
1591       assert(flat-&gt;offset() &lt; header_size_min, &quot;array body reference must be OffsetBot&quot;);
1592 #endif
1593       if (flat-&gt;offset() == TypePtr::OffsetBot) {
1594         alias_type(idx)-&gt;set_element(flat-&gt;is_aryptr()-&gt;elem());
1595       }
1596     }
1597     if (flat-&gt;isa_klassptr()) {
1598       if (flat-&gt;offset() == in_bytes(Klass::super_check_offset_offset()))
1599         alias_type(idx)-&gt;set_rewritable(false);
1600       if (flat-&gt;offset() == in_bytes(Klass::modifier_flags_offset()))
1601         alias_type(idx)-&gt;set_rewritable(false);
1602       if (flat-&gt;offset() == in_bytes(Klass::access_flags_offset()))
1603         alias_type(idx)-&gt;set_rewritable(false);
1604       if (flat-&gt;offset() == in_bytes(Klass::java_mirror_offset()))
1605         alias_type(idx)-&gt;set_rewritable(false);
<span class="line-added">1606       if (flat-&gt;offset() == in_bytes(Klass::secondary_super_cache_offset()))</span>
<span class="line-added">1607         alias_type(idx)-&gt;set_rewritable(false);</span>
1608     }
1609     // %%% (We would like to finalize JavaThread::threadObj_offset(),
1610     // but the base pointer type is not distinctive enough to identify
1611     // references into JavaThread.)
1612 
1613     // Check for final fields.
1614     const TypeInstPtr* tinst = flat-&gt;isa_instptr();
1615     if (tinst &amp;&amp; tinst-&gt;offset() &gt;= instanceOopDesc::base_offset_in_bytes()) {
1616       ciField* field;
1617       if (tinst-&gt;const_oop() != NULL &amp;&amp;
1618           tinst-&gt;klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
1619           tinst-&gt;offset() &gt;= (tinst-&gt;klass()-&gt;as_instance_klass()-&gt;size_helper() * wordSize)) {
1620         // static field
1621         ciInstanceKlass* k = tinst-&gt;const_oop()-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();
1622         field = k-&gt;get_field_by_offset(tinst-&gt;offset(), true);
1623       } else {
1624         ciInstanceKlass *k = tinst-&gt;klass()-&gt;as_instance_klass();
1625         field = k-&gt;get_field_by_offset(tinst-&gt;offset(), false);
1626       }
1627       assert(field == NULL ||
</pre>
<hr />
<pre>
1683   if (alias_idx == AliasIdxBot)         return true;  // the universal category
1684   if (adr_type == NULL)                 return true;  // NULL serves as TypePtr::TOP
1685   if (alias_idx == AliasIdxTop)         return false; // the empty category
1686   if (adr_type-&gt;base() == Type::AnyPtr) return false; // TypePtr::BOTTOM or its twins
1687 
1688   // the only remaining possible overlap is identity
1689   int adr_idx = get_alias_index(adr_type);
1690   assert(adr_idx != AliasIdxBot &amp;&amp; adr_idx != AliasIdxTop, &quot;&quot;);
1691   assert(adr_idx == alias_idx ||
1692          (alias_type(alias_idx)-&gt;adr_type() != TypeOopPtr::BOTTOM
1693           &amp;&amp; adr_type                       != TypeOopPtr::BOTTOM),
1694          &quot;should not be testing for overlap with an unsafe pointer&quot;);
1695   return adr_idx == alias_idx;
1696 }
1697 
1698 //------------------------------can_alias--------------------------------------
1699 // True if any values of the given address type are in the given alias category.
1700 bool Compile::can_alias(const TypePtr* adr_type, int alias_idx) {
1701   if (alias_idx == AliasIdxTop)         return false; // the empty category
1702   if (adr_type == NULL)                 return false; // NULL serves as TypePtr::TOP
<span class="line-modified">1703   // Known instance doesn&#39;t alias with bottom memory</span>
<span class="line-modified">1704   if (alias_idx == AliasIdxBot)         return !adr_type-&gt;is_known_instance();                   // the universal category</span>
<span class="line-added">1705   if (adr_type-&gt;base() == Type::AnyPtr) return !C-&gt;get_adr_type(alias_idx)-&gt;is_known_instance(); // TypePtr::BOTTOM or its twins</span>
1706 
1707   // the only remaining possible overlap is identity
1708   int adr_idx = get_alias_index(adr_type);
1709   assert(adr_idx != AliasIdxBot &amp;&amp; adr_idx != AliasIdxTop, &quot;&quot;);
1710   return adr_idx == alias_idx;
1711 }
1712 
1713 
1714 
1715 //---------------------------pop_warm_call-------------------------------------
1716 WarmCallInfo* Compile::pop_warm_call() {
1717   WarmCallInfo* wci = _warm_calls;
1718   if (wci != NULL)  _warm_calls = wci-&gt;remove_from(wci);
1719   return wci;
1720 }
1721 
1722 //----------------------------Inline_Warm--------------------------------------
1723 int Compile::Inline_Warm() {
1724   // If there is room, try to inline some more warm call sites.
1725   // %%% Do a graph index compaction pass when we think we&#39;re out of space?
</pre>
<hr />
<pre>
2324       cfg.set_loop_alignment();
2325     }
2326     cfg.fixup_flow();
2327   }
2328 
2329   // Apply peephole optimizations
2330   if( OptoPeephole ) {
2331     TracePhase tp(&quot;peephole&quot;, &amp;timers[_t_peephole]);
2332     PhasePeephole peep( _regalloc, cfg);
2333     peep.do_transform();
2334   }
2335 
2336   // Do late expand if CPU requires this.
2337   if (Matcher::require_postalloc_expand) {
2338     TracePhase tp(&quot;postalloc_expand&quot;, &amp;timers[_t_postalloc_expand]);
2339     cfg.postalloc_expand(_regalloc);
2340   }
2341 
2342   // Convert Nodes to instruction bits in a buffer
2343   {
<span class="line-modified">2344     TracePhase tp(&quot;output&quot;, &amp;timers[_t_output]);</span>
<span class="line-modified">2345     PhaseOutput output;</span>
<span class="line-added">2346     output.Output();</span>
<span class="line-added">2347     if (failing())  return;</span>
<span class="line-added">2348     output.install();</span>
2349   }
2350 
2351   print_method(PHASE_FINAL_CODE);
2352 
2353   // He&#39;s dead, Jim.
2354   _cfg     = (PhaseCFG*)((intptr_t)0xdeadbeef);
2355   _regalloc = (PhaseChaitin*)((intptr_t)0xdeadbeef);
2356 }
2357 









































































































































2358 //------------------------------Final_Reshape_Counts---------------------------
2359 // This class defines counters to help identify when a method
2360 // may/must be executed using hardware with only 24-bit precision.
2361 struct Final_Reshape_Counts : public StackObj {
2362   int  _call_count;             // count non-inlined &#39;common&#39; calls
2363   int  _float_count;            // count float ops requiring 24-bit precision
2364   int  _double_count;           // count double ops requiring more precision
2365   int  _java_call_count;        // count non-inlined &#39;java&#39; calls
2366   int  _inner_loop_count;       // count loops which need alignment
2367   VectorSet _visited;           // Visitation flags
2368   Node_List _tests;             // Set of IfNodes &amp; PCTableNodes
2369 
2370   Final_Reshape_Counts() :
2371     _call_count(0), _float_count(0), _double_count(0),
2372     _java_call_count(0), _inner_loop_count(0),
2373     _visited( Thread::current()-&gt;resource_area() ) { }
2374 
2375   void inc_call_count  () { _call_count  ++; }
2376   void inc_float_count () { _float_count ++; }
2377   void inc_double_count() { _double_count++; }
</pre>
<hr />
<pre>
3360         return true;            // Not all targets reachable!
3361       }
3362     }
3363     // Check that I actually visited all kids.  Unreached kids
3364     // must be infinite loops.
3365     for (DUIterator_Fast jmax, j = n-&gt;fast_outs(jmax); j &lt; jmax; j++)
3366       if (!frc._visited.test(n-&gt;fast_out(j)-&gt;_idx)) {
3367         record_method_not_compilable(&quot;infinite loop&quot;);
3368         return true;            // Found unvisited kid; must be unreach
3369       }
3370 
3371     // Here so verification code in final_graph_reshaping_walk()
3372     // always see an OuterStripMinedLoopEnd
3373     if (n-&gt;is_OuterStripMinedLoopEnd()) {
3374       IfNode* init_iff = n-&gt;as_If();
3375       Node* iff = new IfNode(init_iff-&gt;in(0), init_iff-&gt;in(1), init_iff-&gt;_prob, init_iff-&gt;_fcnt);
3376       n-&gt;subsume_by(iff, this);
3377     }
3378   }
3379 
<span class="line-added">3380 #ifdef IA32</span>
3381   // If original bytecodes contained a mixture of floats and doubles
3382   // check if the optimizer has made it homogenous, item (3).
<span class="line-modified">3383   if (UseSSE == 0 &amp;&amp;</span>
3384       frc.get_float_count() &gt; 32 &amp;&amp;
3385       frc.get_double_count() == 0 &amp;&amp;
3386       (10 * frc.get_call_count() &lt; frc.get_float_count()) ) {
<span class="line-modified">3387     set_24_bit_selection_and_mode(false, true);</span>
3388   }
<span class="line-added">3389 #endif // IA32</span>
3390 
3391   set_java_calls(frc.get_java_call_count());
3392   set_inner_loops(frc.get_inner_loop_count());
3393 
3394   // No infinite loops, no reason to bail out.
3395   return false;
3396 }
3397 
3398 //-----------------------------too_many_traps----------------------------------
3399 // Report if there are too many traps at the current method and bci.
3400 // Return true if there was a trap, and/or PerMethodTrapLimit is exceeded.
3401 bool Compile::too_many_traps(ciMethod* method,
3402                              int bci,
3403                              Deoptimization::DeoptReason reason) {
3404   ciMethodData* md = method-&gt;method_data();
3405   if (md-&gt;is_empty()) {
3406     // Assume the trap has not occurred, or that it occurred only
3407     // because of a transient condition during start-up in the interpreter.
3408     return false;
3409   }
</pre>
<hr />
<pre>
3630   } else {
3631     _log = NULL;
3632   }
3633 
3634 #ifdef ASSERT
3635   if (PrintIdealNodeCount) {
3636     tty-&gt;print_cr(&quot;phase name=&#39;%s&#39; nodes=&#39;%d&#39; live=&#39;%d&#39; live_graph_walk=&#39;%d&#39;&quot;,
3637                   _phase_name, C-&gt;unique(), C-&gt;live_nodes(), C-&gt;count_live_nodes_by_graph_walk());
3638   }
3639 
3640   if (VerifyIdealNodeCount) {
3641     Compile::current()-&gt;print_missing_nodes();
3642   }
3643 #endif
3644 
3645   if (_log != NULL) {
3646     _log-&gt;done(&quot;phase name=&#39;%s&#39; nodes=&#39;%d&#39; live=&#39;%d&#39;&quot;, _phase_name, C-&gt;unique(), C-&gt;live_nodes());
3647   }
3648 }
3649 
























































































































































































































3650 //----------------------------static_subtype_check-----------------------------
3651 // Shortcut important common cases when superklass is exact:
3652 // (0) superklass is java.lang.Object (can occur in reflective code)
3653 // (1) subklass is already limited to a subtype of superklass =&gt; always ok
3654 // (2) subklass does not overlap with superklass =&gt; always fail
3655 // (3) superklass has NO subtypes and we can check with a simple compare.
3656 int Compile::static_subtype_check(ciKlass* superk, ciKlass* subk) {
3657   if (StressReflectiveCode) {
3658     return SSC_full_test;       // Let caller generate the general case.
3659   }
3660 
3661   if (superk == env()-&gt;Object_klass()) {
3662     return SSC_always_true;     // (0) this test cannot fail
3663   }
3664 
3665   ciType* superelem = superk;
3666   if (superelem-&gt;is_array_klass())
3667     superelem = superelem-&gt;as_array_klass()-&gt;base_element_type();
3668 
3669   if (!subk-&gt;is_interface()) {  // cannot trust static interface types yet
</pre>
</td>
</tr>
</table>
<center><a href="classes.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compile.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
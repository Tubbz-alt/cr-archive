<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/output.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="node.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="output.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/output.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/assembler.inline.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;code/compiledIC.hpp&quot;
  29 #include &quot;code/debugInfo.hpp&quot;
  30 #include &quot;code/debugInfoRec.hpp&quot;
  31 #include &quot;compiler/compileBroker.hpp&quot;
  32 #include &quot;compiler/compilerDirectives.hpp&quot;
  33 #include &quot;compiler/oopMap.hpp&quot;
  34 #include &quot;gc/shared/barrierSet.hpp&quot;
  35 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  36 #include &quot;memory/allocation.inline.hpp&quot;
  37 #include &quot;opto/ad.hpp&quot;


  38 #include &quot;opto/callnode.hpp&quot;
  39 #include &quot;opto/cfgnode.hpp&quot;
  40 #include &quot;opto/locknode.hpp&quot;
  41 #include &quot;opto/machnode.hpp&quot;

  42 #include &quot;opto/optoreg.hpp&quot;
  43 #include &quot;opto/output.hpp&quot;
  44 #include &quot;opto/regalloc.hpp&quot;
  45 #include &quot;opto/runtime.hpp&quot;
  46 #include &quot;opto/subnode.hpp&quot;
  47 #include &quot;opto/type.hpp&quot;
  48 #include &quot;runtime/handles.inline.hpp&quot;



  49 #include &quot;utilities/xmlstream.hpp&quot;



  50 
  51 #ifndef PRODUCT
  52 #define DEBUG_ARG(x) , x
  53 #else
  54 #define DEBUG_ARG(x)
  55 #endif
  56 


































































































































































































  57 // Convert Nodes to instruction bits and pass off to the VM
<span class="line-modified">  58 void Compile::Output() {</span>
  59   // RootNode goes
<span class="line-modified">  60   assert( _cfg-&gt;get_root_block()-&gt;number_of_nodes() == 0, &quot;&quot; );</span>
  61 
  62   // The number of new nodes (mostly MachNop) is proportional to
  63   // the number of java calls and inner loops which are aligned.
  64   if ( C-&gt;check_node_count((NodeLimitFudgeFactor + C-&gt;java_calls()*3 +
  65                             C-&gt;inner_loops()*(OptoLoopAlignment-1)),
  66                            &quot;out of nodes before code generation&quot; ) ) {
  67     return;
  68   }
  69   // Make sure I can find the Start Node
<span class="line-modified">  70   Block *entry = _cfg-&gt;get_block(1);</span>
<span class="line-modified">  71   Block *broot = _cfg-&gt;get_root_block();</span>
  72 
  73   const StartNode *start = entry-&gt;head()-&gt;as_Start();
  74 
  75   // Replace StartNode with prolog
  76   MachPrologNode *prolog = new MachPrologNode();
  77   entry-&gt;map_node(prolog, 0);
<span class="line-modified">  78   _cfg-&gt;map_node_to_block(prolog, entry);</span>
<span class="line-modified">  79   _cfg-&gt;unmap_node_from_block(start); // start is no longer in any block</span>
  80 
  81   // Virtual methods need an unverified entry point
  82 
<span class="line-modified">  83   if( is_osr_compilation() ) {</span>
  84     if( PoisonOSREntry ) {
  85       // TODO: Should use a ShouldNotReachHereNode...
<span class="line-modified">  86       _cfg-&gt;insert( broot, 0, new MachBreakpointNode() );</span>
  87     }
  88   } else {
<span class="line-modified">  89     if( _method &amp;&amp; !_method-&gt;flags().is_static() ) {</span>
  90       // Insert unvalidated entry point
<span class="line-modified">  91       _cfg-&gt;insert( broot, 0, new MachUEPNode() );</span>
  92     }
  93 
  94   }
  95 
  96   // Break before main entry point
<span class="line-modified">  97   if ((_method &amp;&amp; C-&gt;directive()-&gt;BreakAtExecuteOption) ||</span>
<span class="line-modified">  98       (OptoBreakpoint &amp;&amp; is_method_compilation())       ||</span>
<span class="line-modified">  99       (OptoBreakpointOSR &amp;&amp; is_osr_compilation())       ||</span>
<span class="line-modified"> 100       (OptoBreakpointC2R &amp;&amp; !_method)                   ) {</span>
<span class="line-modified"> 101     // checking for _method means that OptoBreakpoint does not apply to</span>
 102     // runtime stubs or frame converters
<span class="line-modified"> 103     _cfg-&gt;insert( entry, 1, new MachBreakpointNode() );</span>
 104   }
 105 
 106   // Insert epilogs before every return
<span class="line-modified"> 107   for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {</span>
<span class="line-modified"> 108     Block* block = _cfg-&gt;get_block(i);</span>
<span class="line-modified"> 109     if (!block-&gt;is_connector() &amp;&amp; block-&gt;non_connector_successor(0) == _cfg-&gt;get_root_block()) { // Found a program exit point?</span>
 110       Node* m = block-&gt;end();
 111       if (m-&gt;is_Mach() &amp;&amp; m-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Halt) {
 112         MachEpilogNode* epilog = new MachEpilogNode(m-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Return);
 113         block-&gt;add_inst(epilog);
<span class="line-modified"> 114         _cfg-&gt;map_node_to_block(epilog, block);</span>
 115       }
 116     }
 117   }
 118 
 119   // Keeper of sizing aspects
 120   BufferSizingData buf_sizes = BufferSizingData();
 121 
 122   // Initialize code buffer
 123   estimate_buffer_size(buf_sizes._const);
<span class="line-modified"> 124   if (failing()) return;</span>
 125 
 126   // Pre-compute the length of blocks and replace
 127   // long branches with short if machine supports it.
 128   // Must be done before ScheduleAndBundle due to SPARC delay slots
<span class="line-modified"> 129   uint* blk_starts = NEW_RESOURCE_ARRAY(uint, _cfg-&gt;number_of_blocks() + 1);</span>
 130   blk_starts[0] = 0;
 131   shorten_branches(blk_starts, buf_sizes);
 132 
 133   ScheduleAndBundle();
<span class="line-modified"> 134   if (failing()) {</span>
 135     return;
 136   }
 137 
 138   // Late barrier analysis must be done after schedule and bundle
 139   // Otherwise liveness based spilling will fail
 140   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 141   bs-&gt;late_barrier_analysis();
 142 







 143   // Complete sizing of codebuffer
 144   CodeBuffer* cb = init_buffer(buf_sizes);
<span class="line-modified"> 145   if (cb == NULL || failing()) {</span>
 146     return;
 147   }
 148 
 149   BuildOopMaps();
 150 
<span class="line-modified"> 151   if (failing())  {</span>
 152     return;
 153   }
 154 
 155   fill_buffer(cb, blk_starts);
 156 }
 157 
<span class="line-modified"> 158 bool Compile::need_stack_bang(int frame_size_in_bytes) const {</span>
 159   // Determine if we need to generate a stack overflow check.
 160   // Do it if the method is not a stub function and
 161   // has java calls or has frame size &gt; vm_page_size/8.
 162   // The debug VM checks that deoptimization doesn&#39;t trigger an
 163   // unexpected stack overflow (compiled method stack banging should
 164   // guarantee it doesn&#39;t happen) so we always need the stack bang in
 165   // a debug VM.
<span class="line-modified"> 166   return (UseStackBanging &amp;&amp; stub_function() == NULL &amp;&amp;</span>
<span class="line-modified"> 167           (has_java_calls() || frame_size_in_bytes &gt; os::vm_page_size()&gt;&gt;3</span>
 168            DEBUG_ONLY(|| true)));
 169 }
 170 
<span class="line-modified"> 171 bool Compile::need_register_stack_bang() const {</span>
 172   // Determine if we need to generate a register stack overflow check.
 173   // This is only used on architectures which have split register
 174   // and memory stacks (ie. IA64).
 175   // Bang if the method is not a stub function and has java calls
<span class="line-modified"> 176   return (stub_function() == NULL &amp;&amp; has_java_calls());</span>
 177 }
 178 
 179 
 180 // Compute the size of first NumberOfLoopInstrToAlign instructions at the top
 181 // of a loop. When aligning a loop we need to provide enough instructions
 182 // in cpu&#39;s fetch buffer to feed decoders. The loop alignment could be
 183 // avoided if we have enough instructions in fetch buffer at the head of a loop.
 184 // By default, the size is set to 999999 by Block&#39;s constructor so that
 185 // a loop will be aligned if the size is not reset here.
 186 //
 187 // Note: Mach instructions could contain several HW instructions
 188 // so the size is estimated only.
 189 //
<span class="line-modified"> 190 void Compile::compute_loop_first_inst_sizes() {</span>
 191   // The next condition is used to gate the loop alignment optimization.
 192   // Don&#39;t aligned a loop if there are enough instructions at the head of a loop
 193   // or alignment padding is larger then MaxLoopPad. By default, MaxLoopPad
 194   // is equal to OptoLoopAlignment-1 except on new Intel cpus, where it is
 195   // equal to 11 bytes which is the largest address NOP instruction.
 196   if (MaxLoopPad &lt; OptoLoopAlignment - 1) {
<span class="line-modified"> 197     uint last_block = _cfg-&gt;number_of_blocks() - 1;</span>
 198     for (uint i = 1; i &lt;= last_block; i++) {
<span class="line-modified"> 199       Block* block = _cfg-&gt;get_block(i);</span>
 200       // Check the first loop&#39;s block which requires an alignment.
 201       if (block-&gt;loop_alignment() &gt; (uint)relocInfo::addr_unit()) {
 202         uint sum_size = 0;
 203         uint inst_cnt = NumberOfLoopInstrToAlign;
<span class="line-modified"> 204         inst_cnt = block-&gt;compute_first_inst_size(sum_size, inst_cnt, _regalloc);</span>
 205 
 206         // Check subsequent fallthrough blocks if the loop&#39;s first
 207         // block(s) does not have enough instructions.
 208         Block *nb = block;
 209         while(inst_cnt &gt; 0 &amp;&amp;
 210               i &lt; last_block &amp;&amp;
<span class="line-modified"> 211               !_cfg-&gt;get_block(i + 1)-&gt;has_loop_alignment() &amp;&amp;</span>
 212               !nb-&gt;has_successor(block)) {
 213           i++;
<span class="line-modified"> 214           nb = _cfg-&gt;get_block(i);</span>
<span class="line-modified"> 215           inst_cnt  = nb-&gt;compute_first_inst_size(sum_size, inst_cnt, _regalloc);</span>
 216         } // while( inst_cnt &gt; 0 &amp;&amp; i &lt; last_block  )
 217 
 218         block-&gt;set_first_inst_size(sum_size);
 219       } // f( b-&gt;head()-&gt;is_Loop() )
 220     } // for( i &lt;= last_block )
 221   } // if( MaxLoopPad &lt; OptoLoopAlignment-1 )
 222 }
 223 
 224 // The architecture description provides short branch variants for some long
 225 // branch instructions. Replace eligible long branches with short branches.
<span class="line-modified"> 226 void Compile::shorten_branches(uint* blk_starts, BufferSizingData&amp; buf_sizes) {</span>
 227   // Compute size of each block, method size, and relocation information size
<span class="line-modified"> 228   uint nblocks  = _cfg-&gt;number_of_blocks();</span>
 229 
 230   uint*      jmp_offset = NEW_RESOURCE_ARRAY(uint,nblocks);
 231   uint*      jmp_size   = NEW_RESOURCE_ARRAY(uint,nblocks);
 232   int*       jmp_nidx   = NEW_RESOURCE_ARRAY(int ,nblocks);
 233 
 234   // Collect worst case block paddings
 235   int* block_worst_case_pad = NEW_RESOURCE_ARRAY(int, nblocks);
 236   memset(block_worst_case_pad, 0, nblocks * sizeof(int));
 237 
 238   DEBUG_ONLY( uint *jmp_target = NEW_RESOURCE_ARRAY(uint,nblocks); )
 239   DEBUG_ONLY( uint *jmp_rule = NEW_RESOURCE_ARRAY(uint,nblocks); )
 240 
 241   bool has_short_branch_candidate = false;
 242 
 243   // Initialize the sizes to 0
 244   int code_size  = 0;          // Size in bytes of generated code
 245   int stub_size  = 0;          // Size in bytes of all stub entries
 246   // Size in bytes of all relocation entries, including those in local stubs.
 247   // Start with 2-bytes of reloc info for the unvalidated entry point
 248   int reloc_size = 1;          // Number of relocation entries
 249 
 250   // Make three passes.  The first computes pessimistic blk_starts,
 251   // relative jmp_offset and reloc_size information.  The second performs
 252   // short branch substitution using the pessimistic sizing.  The
 253   // third inserts nops where needed.
 254 
 255   // Step one, perform a pessimistic sizing pass.
 256   uint last_call_adr = max_juint;
 257   uint last_avoid_back_to_back_adr = max_juint;
<span class="line-modified"> 258   uint nop_size = (new MachNopNode())-&gt;size(_regalloc);</span>
 259   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
<span class="line-modified"> 260     Block* block = _cfg-&gt;get_block(i);</span>
 261 
 262     // During short branch replacement, we store the relative (to blk_starts)
 263     // offset of jump in jmp_offset, rather than the absolute offset of jump.
 264     // This is so that we do not need to recompute sizes of all nodes when
 265     // we compute correct blk_starts in our next sizing pass.
 266     jmp_offset[i] = 0;
 267     jmp_size[i]   = 0;
 268     jmp_nidx[i]   = -1;
 269     DEBUG_ONLY( jmp_target[i] = 0; )
 270     DEBUG_ONLY( jmp_rule[i]   = 0; )
 271 
 272     // Sum all instruction sizes to compute block size
 273     uint last_inst = block-&gt;number_of_nodes();
 274     uint blk_size = 0;
 275     for (uint j = 0; j &lt; last_inst; j++) {
 276       Node* nj = block-&gt;get_node(j);
 277       // Handle machine instruction nodes
 278       if (nj-&gt;is_Mach()) {
 279         MachNode *mach = nj-&gt;as_Mach();
 280         blk_size += (mach-&gt;alignment_required() - 1) * relocInfo::addr_unit(); // assume worst case padding







 281         reloc_size += mach-&gt;reloc();
 282         if (mach-&gt;is_MachCall()) {
 283           // add size information for trampoline stub
 284           // class CallStubImpl is platform-specific and defined in the *.ad files.
 285           stub_size  += CallStubImpl::size_call_trampoline();
 286           reloc_size += CallStubImpl::reloc_call_trampoline();
 287 
 288           MachCallNode *mcall = mach-&gt;as_MachCall();
 289           // This destination address is NOT PC-relative
 290 
 291           mcall-&gt;method_set((intptr_t)mcall-&gt;entry_point());
 292 
 293           if (mcall-&gt;is_MachCallJava() &amp;&amp; mcall-&gt;as_MachCallJava()-&gt;_method) {
 294             stub_size  += CompiledStaticCall::to_interp_stub_size();
 295             reloc_size += CompiledStaticCall::reloc_to_interp_stub();
 296 #if INCLUDE_AOT
 297             stub_size  += CompiledStaticCall::to_aot_stub_size();
 298             reloc_size += CompiledStaticCall::reloc_to_aot_stub();
 299 #endif
 300           }
</pre>
<hr />
<pre>
 307             blk_size += nop_size;
 308           }
 309         }
 310         if (mach-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
 311           // Nop is inserted between &quot;avoid back to back&quot; instructions.
 312           // ScheduleAndBundle() can rearrange nodes in a block,
 313           // check for all offsets inside this block.
 314           if (last_avoid_back_to_back_adr &gt;= blk_starts[i]) {
 315             blk_size += nop_size;
 316           }
 317         }
 318         if (mach-&gt;may_be_short_branch()) {
 319           if (!nj-&gt;is_MachBranch()) {
 320 #ifndef PRODUCT
 321             nj-&gt;dump(3);
 322 #endif
 323             Unimplemented();
 324           }
 325           assert(jmp_nidx[i] == -1, &quot;block should have only one branch&quot;);
 326           jmp_offset[i] = blk_size;
<span class="line-modified"> 327           jmp_size[i]   = nj-&gt;size(_regalloc);</span>
 328           jmp_nidx[i]   = j;
 329           has_short_branch_candidate = true;
 330         }
 331       }
<span class="line-modified"> 332       blk_size += nj-&gt;size(_regalloc);</span>
 333       // Remember end of call offset
 334       if (nj-&gt;is_MachCall() &amp;&amp; !nj-&gt;is_MachCallLeaf()) {
 335         last_call_adr = blk_starts[i]+blk_size;
 336       }
 337       // Remember end of avoid_back_to_back offset
 338       if (nj-&gt;is_Mach() &amp;&amp; nj-&gt;as_Mach()-&gt;avoid_back_to_back(MachNode::AVOID_AFTER)) {
 339         last_avoid_back_to_back_adr = blk_starts[i]+blk_size;
 340       }
 341     }
 342 
 343     // When the next block starts a loop, we may insert pad NOP
 344     // instructions.  Since we cannot know our future alignment,
 345     // assume the worst.
 346     if (i &lt; nblocks - 1) {
<span class="line-modified"> 347       Block* nb = _cfg-&gt;get_block(i + 1);</span>
 348       int max_loop_pad = nb-&gt;code_alignment()-relocInfo::addr_unit();
 349       if (max_loop_pad &gt; 0) {
 350         assert(is_power_of_2(max_loop_pad+relocInfo::addr_unit()), &quot;&quot;);
 351         // Adjust last_call_adr and/or last_avoid_back_to_back_adr.
 352         // If either is the last instruction in this block, bump by
 353         // max_loop_pad in lock-step with blk_size, so sizing
 354         // calculations in subsequent blocks still can conservatively
 355         // detect that it may the last instruction in this block.
 356         if (last_call_adr == blk_starts[i]+blk_size) {
 357           last_call_adr += max_loop_pad;
 358         }
 359         if (last_avoid_back_to_back_adr == blk_starts[i]+blk_size) {
 360           last_avoid_back_to_back_adr += max_loop_pad;
 361         }
 362         blk_size += max_loop_pad;
 363         block_worst_case_pad[i + 1] = max_loop_pad;
 364       }
 365     }
 366 
 367     // Save block size; update total method size
 368     blk_starts[i+1] = blk_starts[i]+blk_size;
 369   }
 370 
 371   // Step two, replace eligible long jumps.
 372   bool progress = true;
 373   uint last_may_be_short_branch_adr = max_juint;
 374   while (has_short_branch_candidate &amp;&amp; progress) {
 375     progress = false;
 376     has_short_branch_candidate = false;
 377     int adjust_block_start = 0;
 378     for (uint i = 0; i &lt; nblocks; i++) {
<span class="line-modified"> 379       Block* block = _cfg-&gt;get_block(i);</span>
 380       int idx = jmp_nidx[i];
 381       MachNode* mach = (idx == -1) ? NULL: block-&gt;get_node(idx)-&gt;as_Mach();
 382       if (mach != NULL &amp;&amp; mach-&gt;may_be_short_branch()) {
 383 #ifdef ASSERT
 384         assert(jmp_size[i] &gt; 0 &amp;&amp; mach-&gt;is_MachBranch(), &quot;sanity&quot;);
 385         int j;
 386         // Find the branch; ignore trailing NOPs.
 387         for (j = block-&gt;number_of_nodes()-1; j&gt;=0; j--) {
 388           Node* n = block-&gt;get_node(j);
 389           if (!n-&gt;is_Mach() || n-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Con)
 390             break;
 391         }
 392         assert(j &gt;= 0 &amp;&amp; j == idx &amp;&amp; block-&gt;get_node(j) == (Node*)mach, &quot;sanity&quot;);
 393 #endif
 394         int br_size = jmp_size[i];
 395         int br_offs = blk_starts[i] + jmp_offset[i];
 396 
 397         // This requires the TRUE branch target be in succs[0]
 398         uint bnum = block-&gt;non_connector_successor(0)-&gt;_pre_order;
 399         int offset = blk_starts[bnum] - br_offs;
 400         if (bnum &gt; i) { // adjust following block&#39;s offset
 401           offset -= adjust_block_start;
 402         }
 403 
 404         // This block can be a loop header, account for the padding
 405         // in the previous block.
 406         int block_padding = block_worst_case_pad[i];
 407         assert(i == 0 || block_padding == 0 || br_offs &gt;= block_padding, &quot;Should have at least a padding on top&quot;);
 408         // In the following code a nop could be inserted before
 409         // the branch which will increase the backward distance.
 410         bool needs_padding = ((uint)(br_offs - block_padding) == last_may_be_short_branch_adr);
 411         assert(!needs_padding || jmp_offset[i] == 0, &quot;padding only branches at the beginning of block&quot;);
 412 
 413         if (needs_padding &amp;&amp; offset &lt;= 0)
 414           offset -= nop_size;
 415 
<span class="line-modified"> 416         if (_matcher-&gt;is_short_branch_offset(mach-&gt;rule(), br_size, offset)) {</span>
 417           // We&#39;ve got a winner.  Replace this branch.
 418           MachNode* replacement = mach-&gt;as_MachBranch()-&gt;short_branch_version();
 419 
 420           // Update the jmp_size.
<span class="line-modified"> 421           int new_size = replacement-&gt;size(_regalloc);</span>
 422           int diff     = br_size - new_size;
 423           assert(diff &gt;= (int)nop_size, &quot;short_branch size should be smaller&quot;);
 424           // Conservatively take into account padding between
 425           // avoid_back_to_back branches. Previous branch could be
 426           // converted into avoid_back_to_back branch during next
 427           // rounds.
 428           if (needs_padding &amp;&amp; replacement-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
 429             jmp_offset[i] += nop_size;
 430             diff -= nop_size;
 431           }
 432           adjust_block_start += diff;
 433           block-&gt;map_node(replacement, idx);
 434           mach-&gt;subsume_by(replacement, C);
 435           mach = replacement;
 436           progress = true;
 437 
 438           jmp_size[i] = new_size;
 439           DEBUG_ONLY( jmp_target[i] = bnum; );
 440           DEBUG_ONLY( jmp_rule[i] = mach-&gt;rule(); );
 441         } else {
 442           // The jump distance is not short, try again during next iteration.
 443           has_short_branch_candidate = true;
 444         }
 445       } // (mach-&gt;may_be_short_branch())
 446       if (mach != NULL &amp;&amp; (mach-&gt;may_be_short_branch() ||
 447                            mach-&gt;avoid_back_to_back(MachNode::AVOID_AFTER))) {
 448         last_may_be_short_branch_adr = blk_starts[i] + jmp_offset[i] + jmp_size[i];
 449       }
 450       blk_starts[i+1] -= adjust_block_start;
 451     }
 452   }
 453 
 454 #ifdef ASSERT
 455   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
 456     if (jmp_target[i] != 0) {
 457       int br_size = jmp_size[i];
 458       int offset = blk_starts[jmp_target[i]]-(blk_starts[i] + jmp_offset[i]);
<span class="line-modified"> 459       if (!_matcher-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset)) {</span>
 460         tty-&gt;print_cr(&quot;target (%d) - jmp_offset(%d) = offset (%d), jump_size(%d), jmp_block B%d, target_block B%d&quot;, blk_starts[jmp_target[i]], blk_starts[i] + jmp_offset[i], offset, br_size, i, jmp_target[i]);
 461       }
<span class="line-modified"> 462       assert(_matcher-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset), &quot;Displacement too large for short jmp&quot;);</span>
 463     }
 464   }
 465 #endif
 466 
 467   // Step 3, compute the offsets of all blocks, will be done in fill_buffer()
 468   // after ScheduleAndBundle().
 469 
 470   // ------------------
 471   // Compute size for code buffer
 472   code_size = blk_starts[nblocks];
 473 
 474   // Relocation records
 475   reloc_size += 1;              // Relo entry for exception handler
 476 
 477   // Adjust reloc_size to number of record of relocation info
 478   // Min is 2 bytes, max is probably 6 or 8, with a tax up to 25% for
 479   // a relocation index.
 480   // The CodeBuffer will expand the locs array if this estimate is too low.
 481   reloc_size *= 10 / sizeof(relocInfo);
 482 
 483   buf_sizes._reloc = reloc_size;
 484   buf_sizes._code  = code_size;
 485   buf_sizes._stub  = stub_size;
 486 }
 487 
 488 //------------------------------FillLocArray-----------------------------------
 489 // Create a bit of debug info and append it to the array.  The mapping is from
 490 // Java local or expression stack to constant, register or stack-slot.  For
 491 // doubles, insert 2 mappings and return 1 (to tell the caller that the next
 492 // entry has been taken care of and caller should skip it).
 493 static LocationValue *new_loc_value( PhaseRegAlloc *ra, OptoReg::Name regnum, Location::Type l_type ) {
 494   // This should never have accepted Bad before
 495   assert(OptoReg::is_valid(regnum), &quot;location must be valid&quot;);
 496   return (OptoReg::is_reg(regnum))
 497          ? new LocationValue(Location::new_reg_loc(l_type, OptoReg::as_VMReg(regnum)) )
 498          : new LocationValue(Location::new_stk_loc(l_type,  ra-&gt;reg2offset(regnum)));
 499 }
 500 
 501 
 502 ObjectValue*
<span class="line-modified"> 503 Compile::sv_for_node_id(GrowableArray&lt;ScopeValue*&gt; *objs, int id) {</span>
 504   for (int i = 0; i &lt; objs-&gt;length(); i++) {
 505     assert(objs-&gt;at(i)-&gt;is_object(), &quot;corrupt object cache&quot;);
 506     ObjectValue* sv = (ObjectValue*) objs-&gt;at(i);
 507     if (sv-&gt;id() == id) {
 508       return sv;
 509     }
 510   }
 511   // Otherwise..
 512   return NULL;
 513 }
 514 
<span class="line-modified"> 515 void Compile::set_sv_for_object_node(GrowableArray&lt;ScopeValue*&gt; *objs,</span>
 516                                      ObjectValue* sv ) {
 517   assert(sv_for_node_id(objs, sv-&gt;id()) == NULL, &quot;Precondition&quot;);
 518   objs-&gt;append(sv);
 519 }
 520 
 521 
<span class="line-modified"> 522 void Compile::FillLocArray( int idx, MachSafePointNode* sfpt, Node *local,</span>
 523                             GrowableArray&lt;ScopeValue*&gt; *array,
 524                             GrowableArray&lt;ScopeValue*&gt; *objs ) {
 525   assert( local, &quot;use _top instead of null&quot; );
 526   if (array-&gt;length() != idx) {
 527     assert(array-&gt;length() == idx + 1, &quot;Unexpected array count&quot;);
 528     // Old functionality:
 529     //   return
 530     // New functionality:
 531     //   Assert if the local is not top. In product mode let the new node
 532     //   override the old entry.
<span class="line-modified"> 533     assert(local == top(), &quot;LocArray collision&quot;);</span>
<span class="line-modified"> 534     if (local == top()) {</span>
 535       return;
 536     }
 537     array-&gt;pop();
 538   }
 539   const Type *t = local-&gt;bottom_type();
 540 
 541   // Is it a safepoint scalar object node?
 542   if (local-&gt;is_SafePointScalarObject()) {
 543     SafePointScalarObjectNode* spobj = local-&gt;as_SafePointScalarObject();
 544 
<span class="line-modified"> 545     ObjectValue* sv = Compile::sv_for_node_id(objs, spobj-&gt;_idx);</span>
 546     if (sv == NULL) {
 547       ciKlass* cik = t-&gt;is_oopptr()-&gt;klass();
 548       assert(cik-&gt;is_instance_klass() ||
 549              cik-&gt;is_array_klass(), &quot;Not supported allocation.&quot;);
 550       sv = new ObjectValue(spobj-&gt;_idx,
 551                            new ConstantOopWriteValue(cik-&gt;java_mirror()-&gt;constant_encoding()));
<span class="line-modified"> 552       Compile::set_sv_for_object_node(objs, sv);</span>
 553 
 554       uint first_ind = spobj-&gt;first_index(sfpt-&gt;jvms());
 555       for (uint i = 0; i &lt; spobj-&gt;n_fields(); i++) {
 556         Node* fld_node = sfpt-&gt;in(first_ind+i);
 557         (void)FillLocArray(sv-&gt;field_values()-&gt;length(), sfpt, fld_node, sv-&gt;field_values(), objs);
 558       }
 559     }
 560     array-&gt;append(sv);
 561     return;
 562   }
 563 
 564   // Grab the register number for the local
<span class="line-modified"> 565   OptoReg::Name regnum = _regalloc-&gt;get_reg_first(local);</span>
 566   if( OptoReg::is_valid(regnum) ) {// Got a register/stack?
 567     // Record the double as two float registers.
 568     // The register mask for such a value always specifies two adjacent
 569     // float registers, with the lower register number even.
 570     // Normally, the allocation of high and low words to these registers
 571     // is irrelevant, because nearly all operations on register pairs
 572     // (e.g., StoreD) treat them as a single unit.
 573     // Here, we assume in addition that the words in these two registers
 574     // stored &quot;naturally&quot; (by operations like StoreD and double stores
 575     // within the interpreter) such that the lower-numbered register
 576     // is written to the lower memory address.  This may seem like
 577     // a machine dependency, but it is not--it is a requirement on
 578     // the author of the &lt;arch&gt;.ad file to ensure that, for every
 579     // even/odd double-register pair to which a double may be allocated,
 580     // the word in the even single-register is stored to the first
 581     // memory word.  (Note that register numbers are completely
 582     // arbitrary, and are not tied to any machine-level encodings.)
 583 #ifdef _LP64
 584     if( t-&gt;base() == Type::DoubleBot || t-&gt;base() == Type::DoubleCon ) {
 585       array-&gt;append(new ConstantIntValue((jint)0));
<span class="line-modified"> 586       array-&gt;append(new_loc_value( _regalloc, regnum, Location::dbl ));</span>
 587     } else if ( t-&gt;base() == Type::Long ) {
 588       array-&gt;append(new ConstantIntValue((jint)0));
<span class="line-modified"> 589       array-&gt;append(new_loc_value( _regalloc, regnum, Location::lng ));</span>
 590     } else if ( t-&gt;base() == Type::RawPtr ) {
 591       // jsr/ret return address which must be restored into a the full
 592       // width 64-bit stack slot.
<span class="line-modified"> 593       array-&gt;append(new_loc_value( _regalloc, regnum, Location::lng ));</span>
 594     }
 595 #else //_LP64
 596 #ifdef SPARC
 597     if (t-&gt;base() == Type::Long &amp;&amp; OptoReg::is_reg(regnum)) {
 598       // For SPARC we have to swap high and low words for
 599       // long values stored in a single-register (g0-g7).
<span class="line-modified"> 600       array-&gt;append(new_loc_value( _regalloc,              regnum   , Location::normal ));</span>
<span class="line-modified"> 601       array-&gt;append(new_loc_value( _regalloc, OptoReg::add(regnum,1), Location::normal ));</span>
 602     } else
 603 #endif //SPARC
 604     if( t-&gt;base() == Type::DoubleBot || t-&gt;base() == Type::DoubleCon || t-&gt;base() == Type::Long ) {
 605       // Repack the double/long as two jints.
 606       // The convention the interpreter uses is that the second local
 607       // holds the first raw word of the native double representation.
 608       // This is actually reasonable, since locals and stack arrays
 609       // grow downwards in all implementations.
 610       // (If, on some machine, the interpreter&#39;s Java locals or stack
 611       // were to grow upwards, the embedded doubles would be word-swapped.)
<span class="line-modified"> 612       array-&gt;append(new_loc_value( _regalloc, OptoReg::add(regnum,1), Location::normal ));</span>
<span class="line-modified"> 613       array-&gt;append(new_loc_value( _regalloc,              regnum   , Location::normal ));</span>
 614     }
 615 #endif //_LP64
 616     else if( (t-&gt;base() == Type::FloatBot || t-&gt;base() == Type::FloatCon) &amp;&amp;
 617              OptoReg::is_reg(regnum) ) {
<span class="line-modified"> 618       array-&gt;append(new_loc_value( _regalloc, regnum, Matcher::float_in_double()</span>
 619                                                       ? Location::float_in_dbl : Location::normal ));
 620     } else if( t-&gt;base() == Type::Int &amp;&amp; OptoReg::is_reg(regnum) ) {
<span class="line-modified"> 621       array-&gt;append(new_loc_value( _regalloc, regnum, Matcher::int_in_long</span>
 622                                                       ? Location::int_in_long : Location::normal ));
 623     } else if( t-&gt;base() == Type::NarrowOop ) {
<span class="line-modified"> 624       array-&gt;append(new_loc_value( _regalloc, regnum, Location::narrowoop ));</span>
 625     } else {
<span class="line-modified"> 626       array-&gt;append(new_loc_value( _regalloc, regnum, _regalloc-&gt;is_oop(local) ? Location::oop : Location::normal ));</span>
 627     }
 628     return;
 629   }
 630 
 631   // No register.  It must be constant data.
 632   switch (t-&gt;base()) {
 633     case Type::Half:              // Second half of a double
 634       ShouldNotReachHere();       // Caller should skip 2nd halves
 635       break;
 636     case Type::AnyPtr:
 637       array-&gt;append(new ConstantOopWriteValue(NULL));
 638       break;
 639     case Type::AryPtr:
 640     case Type::InstPtr:          // fall through
 641       array-&gt;append(new ConstantOopWriteValue(t-&gt;isa_oopptr()-&gt;const_oop()-&gt;constant_encoding()));
 642       break;
 643     case Type::NarrowOop:
 644       if (t == TypeNarrowOop::NULL_PTR) {
 645         array-&gt;append(new ConstantOopWriteValue(NULL));
 646       } else {
</pre>
<hr />
<pre>
 698     // grow downwards in all implementations.
 699     // (If, on some machine, the interpreter&#39;s Java locals or stack
 700     // were to grow upwards, the embedded doubles would be word-swapped.)
 701     jlong_accessor acc;
 702     acc.long_value = d;
 703     array-&gt;append(new ConstantIntValue(acc.words[1]));
 704     array-&gt;append(new ConstantIntValue(acc.words[0]));
 705 #endif
 706       break;
 707     }
 708     case Type::Top:               // Add an illegal value here
 709       array-&gt;append(new LocationValue(Location()));
 710       break;
 711     default:
 712       ShouldNotReachHere();
 713       break;
 714   }
 715 }
 716 
 717 // Determine if this node starts a bundle
<span class="line-modified"> 718 bool Compile::starts_bundle(const Node *n) const {</span>
 719   return (_node_bundling_limit &gt; n-&gt;_idx &amp;&amp;
 720           _node_bundling_base[n-&gt;_idx].starts_bundle());
 721 }
 722 
 723 //--------------------------Process_OopMap_Node--------------------------------
<span class="line-modified"> 724 void Compile::Process_OopMap_Node(MachNode *mach, int current_offset) {</span>
<span class="line-removed"> 725 </span>
 726   // Handle special safepoint nodes for synchronization
 727   MachSafePointNode *sfn   = mach-&gt;as_MachSafePoint();
 728   MachCallNode      *mcall;
 729 
 730   int safepoint_pc_offset = current_offset;
 731   bool is_method_handle_invoke = false;
 732   bool return_oop = false;
 733 
 734   // Add the safepoint in the DebugInfoRecorder
 735   if( !mach-&gt;is_MachCall() ) {
 736     mcall = NULL;
<span class="line-modified"> 737     debug_info()-&gt;add_safepoint(safepoint_pc_offset, sfn-&gt;_oop_map);</span>
 738   } else {
 739     mcall = mach-&gt;as_MachCall();
 740 
 741     // Is the call a MethodHandle call?
 742     if (mcall-&gt;is_MachCallJava()) {
 743       if (mcall-&gt;as_MachCallJava()-&gt;_method_handle_invoke) {
<span class="line-modified"> 744         assert(has_method_handle_invokes(), &quot;must have been set during call generation&quot;);</span>
 745         is_method_handle_invoke = true;
 746       }
 747     }
 748 
 749     // Check if a call returns an object.
 750     if (mcall-&gt;returns_pointer()) {
 751       return_oop = true;
 752     }
 753     safepoint_pc_offset += mcall-&gt;ret_addr_offset();
<span class="line-modified"> 754     debug_info()-&gt;add_safepoint(safepoint_pc_offset, mcall-&gt;_oop_map);</span>
 755   }
 756 
 757   // Loop over the JVMState list to add scope information
 758   // Do not skip safepoints with a NULL method, they need monitor info
 759   JVMState* youngest_jvms = sfn-&gt;jvms();
 760   int max_depth = youngest_jvms-&gt;depth();
 761 
 762   // Allocate the object pool for scalar-replaced objects -- the map from
 763   // small-integer keys (which can be recorded in the local and ostack
 764   // arrays) to descriptions of the object state.
 765   GrowableArray&lt;ScopeValue*&gt; *objs = new GrowableArray&lt;ScopeValue*&gt;();
 766 
 767   // Visit scopes from oldest to youngest.
 768   for (int depth = 1; depth &lt;= max_depth; depth++) {
 769     JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
 770     int idx;
 771     ciMethod* method = jvms-&gt;has_method() ? jvms-&gt;method() : NULL;
 772     // Safepoints that do not have method() set only provide oop-map and monitor info
 773     // to support GC; these do not support deoptimization.
 774     int num_locs = (method == NULL) ? 0 : jvms-&gt;loc_size();
</pre>
<hr />
<pre>
 796             !method-&gt;is_synchronized() ||
 797             method-&gt;is_native() ||
 798             num_mon &gt; 0 ||
 799             !GenerateSynchronizationCode,
 800             &quot;monitors must always exist for synchronized methods&quot;);
 801 
 802     // Build the growable array of ScopeValues for exp stack
 803     GrowableArray&lt;MonitorValue*&gt; *monarray = new GrowableArray&lt;MonitorValue*&gt;(num_mon);
 804 
 805     // Loop over monitors and insert into array
 806     for (idx = 0; idx &lt; num_mon; idx++) {
 807       // Grab the node that defines this monitor
 808       Node* box_node = sfn-&gt;monitor_box(jvms, idx);
 809       Node* obj_node = sfn-&gt;monitor_obj(jvms, idx);
 810 
 811       // Create ScopeValue for object
 812       ScopeValue *scval = NULL;
 813 
 814       if (obj_node-&gt;is_SafePointScalarObject()) {
 815         SafePointScalarObjectNode* spobj = obj_node-&gt;as_SafePointScalarObject();
<span class="line-modified"> 816         scval = Compile::sv_for_node_id(objs, spobj-&gt;_idx);</span>
 817         if (scval == NULL) {
 818           const Type *t = spobj-&gt;bottom_type();
 819           ciKlass* cik = t-&gt;is_oopptr()-&gt;klass();
 820           assert(cik-&gt;is_instance_klass() ||
 821                  cik-&gt;is_array_klass(), &quot;Not supported allocation.&quot;);
 822           ObjectValue* sv = new ObjectValue(spobj-&gt;_idx,
 823                                             new ConstantOopWriteValue(cik-&gt;java_mirror()-&gt;constant_encoding()));
<span class="line-modified"> 824           Compile::set_sv_for_object_node(objs, sv);</span>
 825 
 826           uint first_ind = spobj-&gt;first_index(youngest_jvms);
 827           for (uint i = 0; i &lt; spobj-&gt;n_fields(); i++) {
 828             Node* fld_node = sfn-&gt;in(first_ind+i);
 829             (void)FillLocArray(sv-&gt;field_values()-&gt;length(), sfn, fld_node, sv-&gt;field_values(), objs);
 830           }
 831           scval = sv;
 832         }
 833       } else if (!obj_node-&gt;is_Con()) {
<span class="line-modified"> 834         OptoReg::Name obj_reg = _regalloc-&gt;get_reg_first(obj_node);</span>
 835         if( obj_node-&gt;bottom_type()-&gt;base() == Type::NarrowOop ) {
<span class="line-modified"> 836           scval = new_loc_value( _regalloc, obj_reg, Location::narrowoop );</span>
 837         } else {
<span class="line-modified"> 838           scval = new_loc_value( _regalloc, obj_reg, Location::oop );</span>
 839         }
 840       } else {
 841         const TypePtr *tp = obj_node-&gt;get_ptr_type();
 842         scval = new ConstantOopWriteValue(tp-&gt;is_oopptr()-&gt;const_oop()-&gt;constant_encoding());
 843       }
 844 
 845       OptoReg::Name box_reg = BoxLockNode::reg(box_node);
<span class="line-modified"> 846       Location basic_lock = Location::new_stk_loc(Location::normal,_regalloc-&gt;reg2offset(box_reg));</span>
 847       bool eliminated = (box_node-&gt;is_BoxLock() &amp;&amp; box_node-&gt;as_BoxLock()-&gt;is_eliminated());
 848       monarray-&gt;append(new MonitorValue(scval, basic_lock, eliminated));
 849     }
 850 
 851     // We dump the object pool first, since deoptimization reads it in first.
<span class="line-modified"> 852     debug_info()-&gt;dump_object_pool(objs);</span>
 853 
 854     // Build first class objects to pass to scope
<span class="line-modified"> 855     DebugToken *locvals = debug_info()-&gt;create_scope_values(locarray);</span>
<span class="line-modified"> 856     DebugToken *expvals = debug_info()-&gt;create_scope_values(exparray);</span>
<span class="line-modified"> 857     DebugToken *monvals = debug_info()-&gt;create_monitor_values(monarray);</span>
 858 
 859     // Make method available for all Safepoints
<span class="line-modified"> 860     ciMethod* scope_method = method ? method : _method;</span>
 861     // Describe the scope here
 862     assert(jvms-&gt;bci() &gt;= InvocationEntryBci &amp;&amp; jvms-&gt;bci() &lt;= 0x10000, &quot;must be a valid or entry BCI&quot;);
 863     assert(!jvms-&gt;should_reexecute() || depth == max_depth, &quot;reexecute allowed only for the youngest&quot;);
 864     // Now we can describe the scope.
 865     methodHandle null_mh;
 866     bool rethrow_exception = false;
<span class="line-modified"> 867     debug_info()-&gt;describe_scope(safepoint_pc_offset, null_mh, scope_method, jvms-&gt;bci(), jvms-&gt;should_reexecute(), rethrow_exception, is_method_handle_invoke, return_oop, locvals, expvals, monvals);</span>
 868   } // End jvms loop
 869 
 870   // Mark the end of the scope set.
<span class="line-modified"> 871   debug_info()-&gt;end_safepoint(safepoint_pc_offset);</span>
 872 }
 873 
 874 
 875 
 876 // A simplified version of Process_OopMap_Node, to handle non-safepoints.
 877 class NonSafepointEmitter {
 878     Compile*  C;
 879     JVMState* _pending_jvms;
 880     int       _pending_offset;
 881 
 882     void emit_non_safepoint();
 883 
 884  public:
 885     NonSafepointEmitter(Compile* compile) {
 886       this-&gt;C = compile;
 887       _pending_jvms = NULL;
 888       _pending_offset = 0;
 889     }
 890 
 891     void observe_instruction(Node* n, int pc_offset) {
</pre>
<hr />
<pre>
 939   DebugInformationRecorder* debug_info = C-&gt;debug_info();
 940   assert(debug_info-&gt;recording_non_safepoints(), &quot;sanity&quot;);
 941 
 942   debug_info-&gt;add_non_safepoint(pc_offset);
 943   int max_depth = youngest_jvms-&gt;depth();
 944 
 945   // Visit scopes from oldest to youngest.
 946   for (int depth = 1; depth &lt;= max_depth; depth++) {
 947     JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
 948     ciMethod* method = jvms-&gt;has_method() ? jvms-&gt;method() : NULL;
 949     assert(!jvms-&gt;should_reexecute() || depth==max_depth, &quot;reexecute allowed only for the youngest&quot;);
 950     methodHandle null_mh;
 951     debug_info-&gt;describe_scope(pc_offset, null_mh, method, jvms-&gt;bci(), jvms-&gt;should_reexecute());
 952   }
 953 
 954   // Mark the end of the scope set.
 955   debug_info-&gt;end_non_safepoint(pc_offset);
 956 }
 957 
 958 //------------------------------init_buffer------------------------------------
<span class="line-modified"> 959 void Compile::estimate_buffer_size(int&amp; const_req) {</span>
 960 
 961   // Set the initially allocated size
 962   const_req = initial_const_capacity;
 963 
 964   // The extra spacing after the code is necessary on some platforms.
 965   // Sometimes we need to patch in a jump after the last instruction,
 966   // if the nmethod has been deoptimized.  (See 4932387, 4894843.)
 967 
 968   // Compute the byte offset where we can store the deopt pc.
<span class="line-modified"> 969   if (fixed_slots() != 0) {</span>
<span class="line-modified"> 970     _orig_pc_slot_offset_in_bytes = _regalloc-&gt;reg2offset(OptoReg::stack2reg(_orig_pc_slot));</span>
 971   }
 972 
 973   // Compute prolog code size
 974   _method_size = 0;
<span class="line-modified"> 975   _frame_slots = OptoReg::reg2stack(_matcher-&gt;_old_SP) + _regalloc-&gt;_framesize;</span>
 976 #if defined(IA64) &amp;&amp; !defined(AIX)
 977   if (save_argument_registers()) {
 978     // 4815101: this is a stub with implicit and unknown precision fp args.
 979     // The usual spill mechanism can only generate stfd&#39;s in this case, which
 980     // doesn&#39;t work if the fp reg to spill contains a single-precision denorm.
 981     // Instead, we hack around the normal spill mechanism using stfspill&#39;s and
 982     // ldffill&#39;s in the MachProlog and MachEpilog emit methods.  We allocate
 983     // space here for the fp arg regs (f8-f15) we&#39;re going to thusly spill.
 984     //
 985     // If we ever implement 16-byte &#39;registers&#39; == stack slots, we can
 986     // get rid of this hack and have SpillCopy generate stfspill/ldffill
 987     // instead of stfd/stfs/ldfd/ldfs.
 988     _frame_slots += 8*(16/BytesPerInt);
 989   }
 990 #endif
 991   assert(_frame_slots &gt;= 0 &amp;&amp; _frame_slots &lt; 1000000, &quot;sanity check&quot;);
 992 
<span class="line-modified"> 993   if (has_mach_constant_base_node()) {</span>
 994     uint add_size = 0;
 995     // Fill the constant table.
 996     // Note:  This must happen before shorten_branches.
<span class="line-modified"> 997     for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {</span>
<span class="line-modified"> 998       Block* b = _cfg-&gt;get_block(i);</span>
 999 
1000       for (uint j = 0; j &lt; b-&gt;number_of_nodes(); j++) {
1001         Node* n = b-&gt;get_node(j);
1002 
1003         // If the node is a MachConstantNode evaluate the constant
1004         // value section.
1005         if (n-&gt;is_MachConstant()) {
1006           MachConstantNode* machcon = n-&gt;as_MachConstant();
1007           machcon-&gt;eval_constant(C);
1008         } else if (n-&gt;is_Mach()) {
1009           // On Power there are more nodes that issue constants.
1010           add_size += (n-&gt;as_Mach()-&gt;ins_num_consts() * 8);
1011         }
1012       }
1013     }
1014 
1015     // Calculate the offsets of the constants and the size of the
1016     // constant table (including the padding to the next section).
1017     constant_table().calculate_offsets_and_size();
1018     const_req = constant_table().size() + add_size;
1019   }
1020 
1021   // Initialize the space for the BufferBlob used to find and verify
1022   // instruction size in MachNode::emit_size()
1023   init_scratch_buffer_blob(const_req);
1024 }
1025 
<span class="line-modified">1026 CodeBuffer* Compile::init_buffer(BufferSizingData&amp; buf_sizes) {</span>
1027 
1028   int stub_req  = buf_sizes._stub;
1029   int code_req  = buf_sizes._code;
1030   int const_req = buf_sizes._const;
1031 
1032   int pad_req   = NativeCall::instruction_size;
1033 
1034   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1035   stub_req += bs-&gt;estimate_stub_size();
1036 
1037   // nmethod and CodeBuffer count stubs &amp; constants as part of method&#39;s code.
1038   // class HandlerImpl is platform-specific and defined in the *.ad files.
1039   int exception_handler_req = HandlerImpl::size_exception_handler() + MAX_stubs_size; // add marginal slop for handler
1040   int deopt_handler_req     = HandlerImpl::size_deopt_handler()     + MAX_stubs_size; // add marginal slop for handler
1041   stub_req += MAX_stubs_size;   // ensure per-stub margin
1042   code_req += MAX_inst_size;    // ensure per-instruction margin
1043 
1044   if (StressCodeBuffers)
1045     code_req = const_req = stub_req = exception_handler_req = deopt_handler_req = 0x10;  // force expansion
1046 
1047   int total_req =
1048           const_req +
1049           code_req +
1050           pad_req +
1051           stub_req +
1052           exception_handler_req +
1053           deopt_handler_req;               // deopt handler
1054 
<span class="line-modified">1055   if (has_method_handle_invokes())</span>
1056     total_req += deopt_handler_req;  // deopt MH handler
1057 
1058   CodeBuffer* cb = code_buffer();
1059   cb-&gt;initialize(total_req, buf_sizes._reloc);
1060 
1061   // Have we run out of code space?
1062   if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1063     C-&gt;record_failure(&quot;CodeCache is full&quot;);
1064     return NULL;
1065   }
1066   // Configure the code buffer.
1067   cb-&gt;initialize_consts_size(const_req);
1068   cb-&gt;initialize_stubs_size(stub_req);
<span class="line-modified">1069   cb-&gt;initialize_oop_recorder(env()-&gt;oop_recorder());</span>
1070 
1071   // fill in the nop array for bundling computations
1072   MachNode *_nop_list[Bundle::_nop_count];
1073   Bundle::initialize_nops(_nop_list);
1074 
1075   return cb;
1076 }
1077 
1078 //------------------------------fill_buffer------------------------------------
<span class="line-modified">1079 void Compile::fill_buffer(CodeBuffer* cb, uint* blk_starts) {</span>
1080   // blk_starts[] contains offsets calculated during short branches processing,
1081   // offsets should not be increased during following steps.
1082 
1083   // Compute the size of first NumberOfLoopInstrToAlign instructions at head
1084   // of a loop. It is used to determine the padding for loop alignment.
1085   compute_loop_first_inst_sizes();
1086 
1087   // Create oopmap set.
1088   _oop_map_set = new OopMapSet();
1089 
1090   // !!!!! This preserves old handling of oopmaps for now
<span class="line-modified">1091   debug_info()-&gt;set_oopmaps(_oop_map_set);</span>
1092 
<span class="line-modified">1093   uint nblocks  = _cfg-&gt;number_of_blocks();</span>
1094   // Count and start of implicit null check instructions
1095   uint inct_cnt = 0;
1096   uint *inct_starts = NEW_RESOURCE_ARRAY(uint, nblocks+1);
1097 
1098   // Count and start of calls
1099   uint *call_returns = NEW_RESOURCE_ARRAY(uint, nblocks+1);
1100 
1101   uint  return_offset = 0;
<span class="line-modified">1102   int nop_size = (new MachNopNode())-&gt;size(_regalloc);</span>
1103 
1104   int previous_offset = 0;
1105   int current_offset  = 0;
1106   int last_call_offset = -1;
1107   int last_avoid_back_to_back_offset = -1;
1108 #ifdef ASSERT
1109   uint* jmp_target = NEW_RESOURCE_ARRAY(uint,nblocks);
1110   uint* jmp_offset = NEW_RESOURCE_ARRAY(uint,nblocks);
1111   uint* jmp_size   = NEW_RESOURCE_ARRAY(uint,nblocks);
1112   uint* jmp_rule   = NEW_RESOURCE_ARRAY(uint,nblocks);
1113 #endif
1114 
1115   // Create an array of unused labels, one for each basic block, if printing is enabled
1116 #if defined(SUPPORT_OPTO_ASSEMBLY)
1117   int *node_offsets      = NULL;
<span class="line-modified">1118   uint node_offset_limit = unique();</span>
1119 
<span class="line-modified">1120   if (print_assembly()) {</span>
1121     node_offsets = NEW_RESOURCE_ARRAY(int, node_offset_limit);
1122   }
1123   if (node_offsets != NULL) {
1124     // We need to initialize. Unused array elements may contain garbage and mess up PrintOptoAssembly.
1125     memset(node_offsets, 0, node_offset_limit*sizeof(int));
1126   }
1127 #endif
1128 
<span class="line-modified">1129   NonSafepointEmitter non_safepoints(this);  // emit non-safepoints lazily</span>
1130 
1131   // Emit the constant table.
<span class="line-modified">1132   if (has_mach_constant_base_node()) {</span>
1133     constant_table().emit(*cb);
1134   }
1135 
1136   // Create an array of labels, one for each basic block
1137   Label *blk_labels = NEW_RESOURCE_ARRAY(Label, nblocks+1);
1138   for (uint i=0; i &lt;= nblocks; i++) {
1139     blk_labels[i].init();
1140   }
1141 
1142   // ------------------
1143   // Now fill in the code buffer
1144   Node *delay_slot = NULL;
1145 
1146   for (uint i = 0; i &lt; nblocks; i++) {
<span class="line-modified">1147     Block* block = _cfg-&gt;get_block(i);</span>
1148     Node* head = block-&gt;head();
1149 
1150     // If this block needs to start aligned (i.e, can be reached other
1151     // than by falling-thru from the previous block), then force the
1152     // start of a new bundle.
1153     if (Pipeline::requires_bundling() &amp;&amp; starts_bundle(head)) {
1154       cb-&gt;flush_bundle(true);
1155     }
1156 
1157 #ifdef ASSERT
1158     if (!block-&gt;is_connector()) {
1159       stringStream st;
<span class="line-modified">1160       block-&gt;dump_head(_cfg, &amp;st);</span>
1161       MacroAssembler(cb).block_comment(st.as_string());
1162     }
1163     jmp_target[i] = 0;
1164     jmp_offset[i] = 0;
1165     jmp_size[i]   = 0;
1166     jmp_rule[i]   = 0;
1167 #endif
1168     int blk_offset = current_offset;
1169 
1170     // Define the label at the beginning of the basic block
1171     MacroAssembler(cb).bind(blk_labels[block-&gt;_pre_order]);
1172 
1173     uint last_inst = block-&gt;number_of_nodes();
1174 
1175     // Emit block normally, except for last instruction.
1176     // Emit means &quot;dump code bits into code buffer&quot;.
1177     for (uint j = 0; j&lt;last_inst; j++) {
1178 
1179       // Get the node
1180       Node* n = block-&gt;get_node(j);
1181 
1182       // See if delay slots are supported
<span class="line-modified">1183       if (valid_bundle_info(n) &amp;&amp;</span>
<span class="line-removed">1184           node_bundling(n)-&gt;used_in_unconditional_delay()) {</span>
1185         assert(delay_slot == NULL, &quot;no use of delay slot node&quot;);
<span class="line-modified">1186         assert(n-&gt;size(_regalloc) == Pipeline::instr_unit_size(), &quot;delay slot instruction wrong size&quot;);</span>
1187 
1188         delay_slot = n;
1189         continue;
1190       }
1191 
1192       // If this starts a new instruction group, then flush the current one
1193       // (but allow split bundles)
1194       if (Pipeline::requires_bundling() &amp;&amp; starts_bundle(n))
1195         cb-&gt;flush_bundle(false);
1196 
1197       // Special handling for SafePoint/Call Nodes
1198       bool is_mcall = false;
1199       if (n-&gt;is_Mach()) {
1200         MachNode *mach = n-&gt;as_Mach();
1201         is_mcall = n-&gt;is_MachCall();
1202         bool is_sfn = n-&gt;is_MachSafePoint();
1203 
1204         // If this requires all previous instructions be flushed, then do so
1205         if (is_sfn || is_mcall || mach-&gt;alignment_required() != 1) {
1206           cb-&gt;flush_bundle(true);
1207           current_offset = cb-&gt;insts_size();
1208         }
1209 
1210         // A padding may be needed again since a previous instruction
1211         // could be moved to delay slot.
1212 
1213         // align the instruction if necessary
1214         int padding = mach-&gt;compute_padding(current_offset);
1215         // Make sure safepoint node for polling is distinct from a call&#39;s
1216         // return by adding a nop if needed.
1217         if (is_sfn &amp;&amp; !is_mcall &amp;&amp; padding == 0 &amp;&amp; current_offset == last_call_offset) {
1218           padding = nop_size;
1219         }
1220         if (padding == 0 &amp;&amp; mach-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE) &amp;&amp;
1221             current_offset == last_avoid_back_to_back_offset) {
1222           // Avoid back to back some instructions.
1223           padding = nop_size;
1224         }






1225 
1226         if (padding &gt; 0) {
1227           assert((padding % nop_size) == 0, &quot;padding is not a multiple of NOP size&quot;);
1228           int nops_cnt = padding / nop_size;
1229           MachNode *nop = new MachNopNode(nops_cnt);
1230           block-&gt;insert_node(nop, j++);
1231           last_inst++;
<span class="line-modified">1232           _cfg-&gt;map_node_to_block(nop, block);</span>
1233           // Ensure enough space.
1234           cb-&gt;insts()-&gt;maybe_expand_to_ensure_remaining(MAX_inst_size);
1235           if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1236             C-&gt;record_failure(&quot;CodeCache is full&quot;);
1237             return;
1238           }
<span class="line-modified">1239           nop-&gt;emit(*cb, _regalloc);</span>
1240           cb-&gt;flush_bundle(true);
1241           current_offset = cb-&gt;insts_size();
1242         }
1243 
1244         // Remember the start of the last call in a basic block
1245         if (is_mcall) {
1246           MachCallNode *mcall = mach-&gt;as_MachCall();
1247 
1248           // This destination address is NOT PC-relative
1249           mcall-&gt;method_set((intptr_t)mcall-&gt;entry_point());
1250 
1251           // Save the return address
1252           call_returns[block-&gt;_pre_order] = current_offset + mcall-&gt;ret_addr_offset();
1253 
1254           if (mcall-&gt;is_MachCallLeaf()) {
1255             is_mcall = false;
1256             is_sfn = false;
1257           }
1258         }
1259 
</pre>
<hr />
<pre>
1272 
1273           non_safepoints.observe_safepoint(mach-&gt;as_MachSafePoint()-&gt;jvms(),
1274                                            current_offset);
1275           Process_OopMap_Node(mach, current_offset);
1276         } // End if safepoint
1277 
1278           // If this is a null check, then add the start of the previous instruction to the list
1279         else if( mach-&gt;is_MachNullCheck() ) {
1280           inct_starts[inct_cnt++] = previous_offset;
1281         }
1282 
1283           // If this is a branch, then fill in the label with the target BB&#39;s label
1284         else if (mach-&gt;is_MachBranch()) {
1285           // This requires the TRUE branch target be in succs[0]
1286           uint block_num = block-&gt;non_connector_successor(0)-&gt;_pre_order;
1287 
1288           // Try to replace long branch if delay slot is not used,
1289           // it is mostly for back branches since forward branch&#39;s
1290           // distance is not updated yet.
1291           bool delay_slot_is_used = valid_bundle_info(n) &amp;&amp;
<span class="line-modified">1292                                     node_bundling(n)-&gt;use_unconditional_delay();</span>
1293           if (!delay_slot_is_used &amp;&amp; mach-&gt;may_be_short_branch()) {
1294             assert(delay_slot == NULL, &quot;not expecting delay slot node&quot;);
<span class="line-modified">1295             int br_size = n-&gt;size(_regalloc);</span>
1296             int offset = blk_starts[block_num] - current_offset;
1297             if (block_num &gt;= i) {
1298               // Current and following block&#39;s offset are not
1299               // finalized yet, adjust distance by the difference
1300               // between calculated and final offsets of current block.
1301               offset -= (blk_starts[i] - blk_offset);
1302             }
1303             // In the following code a nop could be inserted before
1304             // the branch which will increase the backward distance.
1305             bool needs_padding = (current_offset == last_avoid_back_to_back_offset);
1306             if (needs_padding &amp;&amp; offset &lt;= 0)
1307               offset -= nop_size;
1308 
<span class="line-modified">1309             if (_matcher-&gt;is_short_branch_offset(mach-&gt;rule(), br_size, offset)) {</span>
1310               // We&#39;ve got a winner.  Replace this branch.
1311               MachNode* replacement = mach-&gt;as_MachBranch()-&gt;short_branch_version();
1312 
1313               // Update the jmp_size.
<span class="line-modified">1314               int new_size = replacement-&gt;size(_regalloc);</span>
1315               assert((br_size - new_size) &gt;= (int)nop_size, &quot;short_branch size should be smaller&quot;);
1316               // Insert padding between avoid_back_to_back branches.
1317               if (needs_padding &amp;&amp; replacement-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
1318                 MachNode *nop = new MachNopNode();
1319                 block-&gt;insert_node(nop, j++);
<span class="line-modified">1320                 _cfg-&gt;map_node_to_block(nop, block);</span>
1321                 last_inst++;
<span class="line-modified">1322                 nop-&gt;emit(*cb, _regalloc);</span>
1323                 cb-&gt;flush_bundle(true);
1324                 current_offset = cb-&gt;insts_size();
1325               }
1326 #ifdef ASSERT
1327               jmp_target[i] = block_num;
1328               jmp_offset[i] = current_offset - blk_offset;
1329               jmp_size[i]   = new_size;
1330               jmp_rule[i]   = mach-&gt;rule();
1331 #endif
1332               block-&gt;map_node(replacement, j);
1333               mach-&gt;subsume_by(replacement, C);
1334               n    = replacement;
1335               mach = replacement;
1336             }
1337           }
1338           mach-&gt;as_MachBranch()-&gt;label_set( &amp;blk_labels[block_num], block_num );
1339         } else if (mach-&gt;ideal_Opcode() == Op_Jump) {
1340           for (uint h = 0; h &lt; block-&gt;_num_succs; h++) {
1341             Block* succs_block = block-&gt;_succs[h];
1342             for (uint j = 1; j &lt; succs_block-&gt;num_preds(); j++) {
</pre>
<hr />
<pre>
1384           inct_starts[inct_cnt++] = current_offset;
1385         }
1386       }
1387 
1388       // Verify that there is sufficient space remaining
1389       cb-&gt;insts()-&gt;maybe_expand_to_ensure_remaining(MAX_inst_size);
1390       if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1391         C-&gt;record_failure(&quot;CodeCache is full&quot;);
1392         return;
1393       }
1394 
1395       // Save the offset for the listing
1396 #if defined(SUPPORT_OPTO_ASSEMBLY)
1397       if ((node_offsets != NULL) &amp;&amp; (n-&gt;_idx &lt; node_offset_limit)) {
1398         node_offsets[n-&gt;_idx] = cb-&gt;insts_size();
1399       }
1400 #endif
1401 
1402       // &quot;Normal&quot; instruction case
1403       DEBUG_ONLY( uint instr_offset = cb-&gt;insts_size(); )
<span class="line-modified">1404       n-&gt;emit(*cb, _regalloc);</span>
1405       current_offset  = cb-&gt;insts_size();
1406 
1407       // Above we only verified that there is enough space in the instruction section.
1408       // However, the instruction may emit stubs that cause code buffer expansion.
1409       // Bail out here if expansion failed due to a lack of code cache space.
<span class="line-modified">1410       if (failing()) {</span>
1411         return;
1412       }
1413 
1414 #ifdef ASSERT
<span class="line-modified">1415       if (n-&gt;size(_regalloc) &lt; (current_offset-instr_offset)) {</span>
1416         n-&gt;dump();
1417         assert(false, &quot;wrong size of mach node&quot;);
1418       }
1419 #endif
1420       non_safepoints.observe_instruction(n, current_offset);
1421 
1422       // mcall is last &quot;call&quot; that can be a safepoint
1423       // record it so we can see if a poll will directly follow it
1424       // in which case we&#39;ll need a pad to make the PcDesc sites unique
1425       // see  5010568. This can be slightly inaccurate but conservative
1426       // in the case that return address is not actually at current_offset.
1427       // This is a small price to pay.
1428 
1429       if (is_mcall) {
1430         last_call_offset = current_offset;
1431       }
1432 
1433       if (n-&gt;is_Mach() &amp;&amp; n-&gt;as_Mach()-&gt;avoid_back_to_back(MachNode::AVOID_AFTER)) {
1434         // Avoid back to back some instructions.
1435         last_avoid_back_to_back_offset = current_offset;
</pre>
<hr />
<pre>
1450 #endif
1451 
1452         // Support a SafePoint in the delay slot
1453         if (delay_slot-&gt;is_MachSafePoint()) {
1454           MachNode *mach = delay_slot-&gt;as_Mach();
1455           // !!!!! Stubs only need an oopmap right now, so bail out
1456           if (!mach-&gt;is_MachCall() &amp;&amp; mach-&gt;as_MachSafePoint()-&gt;jvms()-&gt;method() == NULL) {
1457             // Write the oopmap directly to the code blob??!!
1458             delay_slot = NULL;
1459             continue;
1460           }
1461 
1462           int adjusted_offset = current_offset - Pipeline::instr_unit_size();
1463           non_safepoints.observe_safepoint(mach-&gt;as_MachSafePoint()-&gt;jvms(),
1464                                            adjusted_offset);
1465           // Generate an OopMap entry
1466           Process_OopMap_Node(mach, adjusted_offset);
1467         }
1468 
1469         // Insert the delay slot instruction
<span class="line-modified">1470         delay_slot-&gt;emit(*cb, _regalloc);</span>
1471 
1472         // Don&#39;t reuse it
1473         delay_slot = NULL;
1474       }
1475 
1476     } // End for all instructions in block
1477 
1478     // If the next block is the top of a loop, pad this block out to align
1479     // the loop top a little. Helps prevent pipe stalls at loop back branches.
1480     if (i &lt; nblocks-1) {
<span class="line-modified">1481       Block *nb = _cfg-&gt;get_block(i + 1);</span>
1482       int padding = nb-&gt;alignment_padding(current_offset);
1483       if( padding &gt; 0 ) {
1484         MachNode *nop = new MachNopNode(padding / nop_size);
1485         block-&gt;insert_node(nop, block-&gt;number_of_nodes());
<span class="line-modified">1486         _cfg-&gt;map_node_to_block(nop, block);</span>
<span class="line-modified">1487         nop-&gt;emit(*cb, _regalloc);</span>
1488         current_offset = cb-&gt;insts_size();
1489       }
1490     }
1491     // Verify that the distance for generated before forward
1492     // short branches is still valid.
1493     guarantee((int)(blk_starts[i+1] - blk_starts[i]) &gt;= (current_offset - blk_offset), &quot;shouldn&#39;t increase block size&quot;);
1494 
1495     // Save new block start offset
1496     blk_starts[i] = blk_offset;
1497   } // End of for all blocks
1498   blk_starts[nblocks] = current_offset;
1499 
1500   non_safepoints.flush_at_end();
1501 
1502   // Offset too large?
<span class="line-modified">1503   if (failing())  return;</span>
1504 
1505   // Define a pseudo-label at the end of the code
1506   MacroAssembler(cb).bind( blk_labels[nblocks] );
1507 
1508   // Compute the size of the first block
1509   _first_block_size = blk_labels[1].loc_pos() - blk_labels[0].loc_pos();
1510 
1511 #ifdef ASSERT
1512   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
1513     if (jmp_target[i] != 0) {
1514       int br_size = jmp_size[i];
1515       int offset = blk_starts[jmp_target[i]]-(blk_starts[i] + jmp_offset[i]);
<span class="line-modified">1516       if (!_matcher-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset)) {</span>
1517         tty-&gt;print_cr(&quot;target (%d) - jmp_offset(%d) = offset (%d), jump_size(%d), jmp_block B%d, target_block B%d&quot;, blk_starts[jmp_target[i]], blk_starts[i] + jmp_offset[i], offset, br_size, i, jmp_target[i]);
1518         assert(false, &quot;Displacement too large for short jmp&quot;);
1519       }
1520     }
1521   }
1522 #endif
1523 
1524   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1525   bs-&gt;emit_stubs(*cb);
<span class="line-modified">1526   if (failing())  return;</span>
1527 
1528 #ifndef PRODUCT
1529   // Information on the size of the method, without the extraneous code
1530   Scheduling::increment_method_size(cb-&gt;insts_size());
1531 #endif
1532 
1533   // ------------------
1534   // Fill in exception table entries.
1535   FillExceptionTables(inct_cnt, call_returns, inct_starts, blk_labels);
1536 
1537   // Only java methods have exception handlers and deopt handlers
1538   // class HandlerImpl is platform-specific and defined in the *.ad files.
<span class="line-modified">1539   if (_method) {</span>
1540     // Emit the exception handler code.
1541     _code_offsets.set_value(CodeOffsets::Exceptions, HandlerImpl::emit_exception_handler(*cb));
<span class="line-modified">1542     if (failing()) {</span>
1543       return; // CodeBuffer::expand failed
1544     }
1545     // Emit the deopt handler code.
1546     _code_offsets.set_value(CodeOffsets::Deopt, HandlerImpl::emit_deopt_handler(*cb));
1547 
1548     // Emit the MethodHandle deopt handler code (if required).
<span class="line-modified">1549     if (has_method_handle_invokes() &amp;&amp; !failing()) {</span>
1550       // We can use the same code as for the normal deopt handler, we
1551       // just need a different entry point address.
1552       _code_offsets.set_value(CodeOffsets::DeoptMH, HandlerImpl::emit_deopt_handler(*cb));
1553     }
1554   }
1555 
1556   // One last check for failed CodeBuffer::expand:
1557   if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1558     C-&gt;record_failure(&quot;CodeCache is full&quot;);
1559     return;
1560   }
1561 
1562 #if defined(SUPPORT_ABSTRACT_ASSEMBLY) || defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_OPTO_ASSEMBLY)
<span class="line-modified">1563   if (print_assembly()) {</span>
1564     tty-&gt;cr();
1565     tty-&gt;print_cr(&quot;============================= C2-compiled nmethod ==============================&quot;);
1566   }
1567 #endif
1568 
1569 #if defined(SUPPORT_OPTO_ASSEMBLY)
1570   // Dump the assembly code, including basic-block numbers
<span class="line-modified">1571   if (print_assembly()) {</span>
1572     ttyLocker ttyl;  // keep the following output all in one block
1573     if (!VMThread::should_terminate()) {  // test this under the tty lock
1574       // This output goes directly to the tty, not the compiler log.
1575       // To enable tools to match it up with the compilation activity,
1576       // be sure to tag this tty output with the compile ID.
1577       if (xtty != NULL) {
<span class="line-modified">1578         xtty-&gt;head(&quot;opto_assembly compile_id=&#39;%d&#39;%s&quot;, compile_id(),</span>
<span class="line-modified">1579                    is_osr_compilation()    ? &quot; compile_kind=&#39;osr&#39;&quot; :</span>
1580                    &quot;&quot;);
1581       }
<span class="line-modified">1582       if (method() != NULL) {</span>
<span class="line-modified">1583         tty-&gt;print_cr(&quot;----------------------- MetaData before Compile_id = %d ------------------------&quot;, compile_id());</span>
<span class="line-modified">1584         method()-&gt;print_metadata();</span>
<span class="line-modified">1585       } else if (stub_name() != NULL) {</span>
<span class="line-modified">1586         tty-&gt;print_cr(&quot;----------------------------- RuntimeStub %s -------------------------------&quot;, stub_name());</span>
1587       }
1588       tty-&gt;cr();
<span class="line-modified">1589       tty-&gt;print_cr(&quot;------------------------ OptoAssembly for Compile_id = %d -----------------------&quot;, compile_id());</span>
1590       dump_asm(node_offsets, node_offset_limit);
1591       tty-&gt;print_cr(&quot;--------------------------------------------------------------------------------&quot;);
1592       if (xtty != NULL) {
1593         // print_metadata and dump_asm above may safepoint which makes us loose the ttylock.
1594         // Retake lock too make sure the end tag is coherent, and that xmlStream-&gt;pop_tag is done
1595         // thread safe
1596         ttyLocker ttyl2;
1597         xtty-&gt;tail(&quot;opto_assembly&quot;);
1598       }
1599     }
1600   }
1601 #endif
1602 }
1603 
<span class="line-modified">1604 void Compile::FillExceptionTables(uint cnt, uint *call_returns, uint *inct_starts, Label *blk_labels) {</span>
1605   _inc_table.set_size(cnt);
1606 
1607   uint inct_cnt = 0;
<span class="line-modified">1608   for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {</span>
<span class="line-modified">1609     Block* block = _cfg-&gt;get_block(i);</span>
1610     Node *n = NULL;
1611     int j;
1612 
1613     // Find the branch; ignore trailing NOPs.
1614     for (j = block-&gt;number_of_nodes() - 1; j &gt;= 0; j--) {
1615       n = block-&gt;get_node(j);
1616       if (!n-&gt;is_Mach() || n-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Con) {
1617         break;
1618       }
1619     }
1620 
1621     // If we didn&#39;t find anything, continue
1622     if (j &lt; 0) {
1623       continue;
1624     }
1625 
1626     // Compute ExceptionHandlerTable subtable entry and add it
1627     // (skip empty blocks)
1628     if (n-&gt;is_Catch()) {
1629 
</pre>
<hr />
<pre>
1634       while (block-&gt;get_node(--j)-&gt;is_MachProj()) ;
1635       assert(block-&gt;get_node(j)-&gt;is_MachCall(), &quot;CatchProj must follow call&quot;);
1636 #endif
1637       // last instruction is a CatchNode, find it&#39;s CatchProjNodes
1638       int nof_succs = block-&gt;_num_succs;
1639       // allocate space
1640       GrowableArray&lt;intptr_t&gt; handler_bcis(nof_succs);
1641       GrowableArray&lt;intptr_t&gt; handler_pcos(nof_succs);
1642       // iterate through all successors
1643       for (int j = 0; j &lt; nof_succs; j++) {
1644         Block* s = block-&gt;_succs[j];
1645         bool found_p = false;
1646         for (uint k = 1; k &lt; s-&gt;num_preds(); k++) {
1647           Node* pk = s-&gt;pred(k);
1648           if (pk-&gt;is_CatchProj() &amp;&amp; pk-&gt;in(0) == n) {
1649             const CatchProjNode* p = pk-&gt;as_CatchProj();
1650             found_p = true;
1651             // add the corresponding handler bci &amp; pco information
1652             if (p-&gt;_con != CatchProjNode::fall_through_index) {
1653               // p leads to an exception handler (and is not fall through)
<span class="line-modified">1654               assert(s == _cfg-&gt;get_block(s-&gt;_pre_order), &quot;bad numbering&quot;);</span>
1655               // no duplicates, please
1656               if (!handler_bcis.contains(p-&gt;handler_bci())) {
1657                 uint block_num = s-&gt;non_connector()-&gt;_pre_order;
1658                 handler_bcis.append(p-&gt;handler_bci());
1659                 handler_pcos.append(blk_labels[block_num].loc_pos());
1660               }
1661             }
1662           }
1663         }
1664         assert(found_p, &quot;no matching predecessor found&quot;);
1665         // Note:  Due to empty block removal, one block may have
1666         // several CatchProj inputs, from the same Catch.
1667       }
1668 
1669       // Set the offset of the return from the call
1670       assert(handler_bcis.find(-1) != -1, &quot;must have default handler&quot;);
1671       _handler_table.add_subtable(call_return, &amp;handler_bcis, NULL, &amp;handler_pcos);
1672       continue;
1673     }
1674 
</pre>
<hr />
<pre>
1706           _available(arena),
1707           _reg_node(arena),
1708           _pinch_free_list(arena),
1709           _next_node(NULL),
1710           _bundle_instr_count(0),
1711           _bundle_cycle_number(0),
1712           _bundle_use(0, 0, resource_count, &amp;_bundle_use_elements[0])
1713 #ifndef PRODUCT
1714         , _branches(0)
1715         , _unconditional_delays(0)
1716 #endif
1717 {
1718   // Create a MachNopNode
1719   _nop = new MachNopNode();
1720 
1721   // Now that the nops are in the array, save the count
1722   // (but allow entries for the nops)
1723   _node_bundling_limit = compile.unique();
1724   uint node_max = _regalloc-&gt;node_regs_max_index();
1725 
<span class="line-modified">1726   compile.set_node_bundling_limit(_node_bundling_limit);</span>
1727 
1728   // This one is persistent within the Compile class
1729   _node_bundling_base = NEW_ARENA_ARRAY(compile.comp_arena(), Bundle, node_max);
1730 
1731   // Allocate space for fixed-size arrays
1732   _node_latency    = NEW_ARENA_ARRAY(arena, unsigned short, node_max);
1733   _uses            = NEW_ARENA_ARRAY(arena, short,          node_max);
1734   _current_latency = NEW_ARENA_ARRAY(arena, unsigned short, node_max);
1735 
1736   // Clear the arrays
1737   for (uint i = 0; i &lt; node_max; i++) {
1738     ::new (&amp;_node_bundling_base[i]) Bundle();
1739   }
1740   memset(_node_latency,       0, node_max * sizeof(unsigned short));
1741   memset(_uses,               0, node_max * sizeof(short));
1742   memset(_current_latency,    0, node_max * sizeof(unsigned short));
1743 
1744   // Clear the bundling information
1745   memcpy(_bundle_use_elements, Pipeline_Use::elaborated_elements, sizeof(Pipeline_Use::elaborated_elements));
1746 
</pre>
<hr />
<pre>
1782 
1783   // Update the bundle record
1784   if (_bundle_instr_count &gt; 0) {
1785     bundle-&gt;set_instr_count(_bundle_instr_count);
1786     bundle-&gt;set_resources_used(_bundle_use.resourcesUsed());
1787 
1788     _bundle_cycle_number += 1;
1789   }
1790 
1791   // Clear the bundling information
1792   _bundle_instr_count = 0;
1793   _bundle_use.reset();
1794 
1795   memcpy(_bundle_use_elements,
1796          Pipeline_Use::elaborated_elements,
1797          sizeof(Pipeline_Use::elaborated_elements));
1798 }
1799 
1800 // Perform instruction scheduling and bundling over the sequence of
1801 // instructions in backwards order.
<span class="line-modified">1802 void Compile::ScheduleAndBundle() {</span>
1803 
1804   // Don&#39;t optimize this if it isn&#39;t a method
<span class="line-modified">1805   if (!_method)</span>
1806     return;
1807 
1808   // Don&#39;t optimize this if scheduling is disabled
<span class="line-modified">1809   if (!do_scheduling())</span>
1810     return;
1811 
1812   // Scheduling code works only with pairs (16 bytes) maximum.
<span class="line-modified">1813   if (max_vector_size() &gt; 16)</span>
1814     return;
1815 
<span class="line-modified">1816   TracePhase tp(&quot;isched&quot;, &amp;timers[_t_instrSched]);</span>
1817 
1818   // Create a data structure for all the scheduling information
<span class="line-modified">1819   Scheduling scheduling(Thread::current()-&gt;resource_area(), *this);</span>
1820 
1821   // Walk backwards over each basic block, computing the needed alignment
1822   // Walk over all the basic blocks
1823   scheduling.DoScheduling();
1824 
1825 #ifndef PRODUCT
<span class="line-modified">1826   if (trace_opto_output()) {</span>
1827     tty-&gt;print(&quot;\n---- After ScheduleAndBundle ----\n&quot;);
<span class="line-modified">1828     for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {</span>
1829       tty-&gt;print(&quot;\nBB#%03d:\n&quot;, i);
<span class="line-modified">1830       Block* block = _cfg-&gt;get_block(i);</span>
1831       for (uint j = 0; j &lt; block-&gt;number_of_nodes(); j++) {
1832         Node* n = block-&gt;get_node(j);
<span class="line-modified">1833         OptoReg::Name reg = _regalloc-&gt;get_reg_first(n);</span>
1834         tty-&gt;print(&quot; %-6s &quot;, reg &gt;= 0 &amp;&amp; reg &lt; REG_COUNT ? Matcher::regName[reg] : &quot;&quot;);
1835         n-&gt;dump();
1836       }
1837     }
1838   }
1839 #endif
1840 }
1841 
1842 // Compute the latency of all the instructions.  This is fairly simple,
1843 // because we already have a legal ordering.  Walk over the instructions
1844 // from first to last, and compute the latency of the instruction based
1845 // on the latency of the preceding instruction(s).
1846 void Scheduling::ComputeLocalLatenciesForward(const Block *bb) {
1847 #ifndef PRODUCT
1848   if (_cfg-&gt;C-&gt;trace_opto_output())
1849     tty-&gt;print(&quot;# -&gt; ComputeLocalLatenciesForward\n&quot;);
1850 #endif
1851 
1852   // Walk over all the schedulable instructions
1853   for( uint j=_bb_start; j &lt; _bb_end; j++ ) {
</pre>
<hr />
<pre>
2355 #endif
2356   }
2357 
2358 #ifndef PRODUCT
2359   if (_cfg-&gt;C-&gt;trace_opto_output())
2360     tty-&gt;print(&quot;# &lt;- ComputeUseCount\n&quot;);
2361 #endif
2362 }
2363 
2364 // This routine performs scheduling on each basic block in reverse order,
2365 // using instruction latencies and taking into account function unit
2366 // availability.
2367 void Scheduling::DoScheduling() {
2368 #ifndef PRODUCT
2369   if (_cfg-&gt;C-&gt;trace_opto_output())
2370     tty-&gt;print(&quot;# -&gt; DoScheduling\n&quot;);
2371 #endif
2372 
2373   Block *succ_bb = NULL;
2374   Block *bb;

2375 
2376   // Walk over all the basic blocks in reverse order
2377   for (int i = _cfg-&gt;number_of_blocks() - 1; i &gt;= 0; succ_bb = bb, i--) {
2378     bb = _cfg-&gt;get_block(i);
2379 
2380 #ifndef PRODUCT
2381     if (_cfg-&gt;C-&gt;trace_opto_output()) {
2382       tty-&gt;print(&quot;#  Schedule BB#%03d (initial)\n&quot;, i);
2383       for (uint j = 0; j &lt; bb-&gt;number_of_nodes(); j++) {
2384         bb-&gt;get_node(j)-&gt;dump();
2385       }
2386     }
2387 #endif
2388 
2389     // On the head node, skip processing
2390     if (bb == _cfg-&gt;get_root_block()) {
2391       continue;
2392     }
2393 
2394     // Skip empty, connector blocks
</pre>
<hr />
<pre>
2442         (last-&gt;is_Mach() &amp;&amp; last-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Halt) ) {
2443       // There might be a prior call.  Skip it.
2444       while (_bb_start &lt; _bb_end &amp;&amp; bb-&gt;get_node(--_bb_end)-&gt;is_MachProj());
2445     } else if( last-&gt;is_MachNullCheck() ) {
2446       // Backup so the last null-checked memory instruction is
2447       // outside the schedulable range. Skip over the nullcheck,
2448       // projection, and the memory nodes.
2449       Node *mem = last-&gt;in(1);
2450       do {
2451         _bb_end--;
2452       } while (mem != bb-&gt;get_node(_bb_end));
2453     } else {
2454       // Set _bb_end to point after last schedulable inst.
2455       _bb_end++;
2456     }
2457 
2458     assert( _bb_start &lt;= _bb_end, &quot;inverted block ends&quot; );
2459 
2460     // Compute the register antidependencies for the basic block
2461     ComputeRegisterAntidependencies(bb);
<span class="line-modified">2462     if (_cfg-&gt;C-&gt;failing())  return;  // too many D-U pinch points</span>
2463 
2464     // Compute intra-bb latencies for the nodes
2465     ComputeLocalLatenciesForward(bb);
2466 
2467     // Compute the usage within the block, and set the list of all nodes
2468     // in the block that have no uses within the block.
2469     ComputeUseCount(bb);
2470 
2471     // Schedule the remaining instructions in the block
2472     while ( _available.size() &gt; 0 ) {
2473       Node *n = ChooseNodeToBundle();
2474       guarantee(n != NULL, &quot;no nodes available&quot;);
2475       AddNodeToBundle(n,bb);
2476     }
2477 
2478     assert( _scheduled.size() == _bb_end - _bb_start, &quot;wrong number of instructions&quot; );
2479 #ifdef ASSERT
2480     for( uint l = _bb_start; l &lt; _bb_end; l++ ) {
2481       Node *n = bb-&gt;get_node(l);
2482       uint m;
</pre>
<hr />
<pre>
2502           if (bundle-&gt;instr_count() &gt; 0 || bundle-&gt;flags() &gt; 0) {
2503             tty-&gt;print(&quot;*** Bundle: &quot;);
2504             bundle-&gt;dump();
2505           }
2506           n-&gt;dump();
2507         }
2508       }
2509     }
2510 #endif
2511 #ifdef ASSERT
2512     verify_good_schedule(bb,&quot;after block local scheduling&quot;);
2513 #endif
2514   }
2515 
2516 #ifndef PRODUCT
2517   if (_cfg-&gt;C-&gt;trace_opto_output())
2518     tty-&gt;print(&quot;# &lt;- DoScheduling\n&quot;);
2519 #endif
2520 
2521   // Record final node-bundling array location
<span class="line-modified">2522   _regalloc-&gt;C-&gt;set_node_bundling_base(_node_bundling_base);</span>
2523 
2524 } // end DoScheduling
2525 
2526 // Verify that no live-range used in the block is killed in the block by a
2527 // wrong DEF.  This doesn&#39;t verify live-ranges that span blocks.
2528 
2529 // Check for edge existence.  Used to avoid adding redundant precedence edges.
2530 static bool edge_from_to( Node *from, Node *to ) {
2531   for( uint i=0; i&lt;from-&gt;len(); i++ )
2532     if( from-&gt;in(i) == to )
2533       return true;
2534   return false;
2535 }
2536 
2537 #ifdef ASSERT
2538 void Scheduling::verify_do_def( Node *n, OptoReg::Name def, const char *msg ) {
2539   // Check for bad kills
2540   if( OptoReg::is_valid(def) ) { // Ignore stores &amp; control flow
2541     Node *prior_use = _reg_node[def];
2542     if( prior_use &amp;&amp; !edge_from_to(prior_use,n) ) {
</pre>
<hr />
<pre>
2609     from-&gt;add_prec(to);
2610 }
2611 
2612 void Scheduling::anti_do_def( Block *b, Node *def, OptoReg::Name def_reg, int is_def ) {
2613   if( !OptoReg::is_valid(def_reg) ) // Ignore stores &amp; control flow
2614     return;
2615 
2616   Node *pinch = _reg_node[def_reg]; // Get pinch point
2617   if ((pinch == NULL) || _cfg-&gt;get_block_for_node(pinch) != b || // No pinch-point yet?
2618       is_def ) {    // Check for a true def (not a kill)
2619     _reg_node.map(def_reg,def); // Record def/kill as the optimistic pinch-point
2620     return;
2621   }
2622 
2623   Node *kill = def;             // Rename &#39;def&#39; to more descriptive &#39;kill&#39;
2624   debug_only( def = (Node*)((intptr_t)0xdeadbeef); )
2625 
2626   // After some number of kills there _may_ be a later def
2627   Node *later_def = NULL;
2628 


2629   // Finding a kill requires a real pinch-point.
2630   // Check for not already having a pinch-point.
2631   // Pinch points are Op_Node&#39;s.
2632   if( pinch-&gt;Opcode() != Op_Node ) { // Or later-def/kill as pinch-point?
2633     later_def = pinch;            // Must be def/kill as optimistic pinch-point
2634     if ( _pinch_free_list.size() &gt; 0) {
2635       pinch = _pinch_free_list.pop();
2636     } else {
2637       pinch = new Node(1); // Pinch point to-be
2638     }
2639     if (pinch-&gt;_idx &gt;= _regalloc-&gt;node_regs_max_index()) {
2640       _cfg-&gt;C-&gt;record_method_not_compilable(&quot;too many D-U pinch points&quot;);
2641       return;
2642     }
2643     _cfg-&gt;map_node_to_block(pinch, b);      // Pretend it&#39;s valid in this block (lazy init)
2644     _reg_node.map(def_reg,pinch); // Record pinch-point
<span class="line-modified">2645     //_regalloc-&gt;set_bad(pinch-&gt;_idx); // Already initialized this way.</span>
2646     if( later_def-&gt;outcnt() == 0 || later_def-&gt;ideal_reg() == MachProjNode::fat_proj ) { // Distinguish def from kill
<span class="line-modified">2647       pinch-&gt;init_req(0, _cfg-&gt;C-&gt;top());     // set not NULL for the next call</span>
2648       add_prec_edge_from_to(later_def,pinch); // Add edge from kill to pinch
2649       later_def = NULL;           // and no later def
2650     }
2651     pinch-&gt;set_req(0,later_def);  // Hook later def so we can find it
2652   } else {                        // Else have valid pinch point
2653     if( pinch-&gt;in(0) )            // If there is a later-def
2654       later_def = pinch-&gt;in(0);   // Get it
2655   }
2656 
2657   // Add output-dependence edge from later def to kill
2658   if( later_def )               // If there is some original def
2659     add_prec_edge_from_to(later_def,kill); // Add edge from def to kill
2660 
2661   // See if current kill is also a use, and so is forced to be the pinch-point.
2662   if( pinch-&gt;Opcode() == Op_Node ) {
2663     Node *uses = kill-&gt;is_Proj() ? kill-&gt;in(0) : kill;
2664     for( uint i=1; i&lt;uses-&gt;req(); i++ ) {
2665       if( _regalloc-&gt;get_reg_first(uses-&gt;in(i)) == def_reg ||
2666           _regalloc-&gt;get_reg_second(uses-&gt;in(i)) == def_reg ) {
2667         // Yes, found a use/kill pinch-point
</pre>
<hr />
<pre>
2930                _total_branches, _total_unconditional_delays);
2931     if (_total_branches &gt; 0)
2932       tty-&gt;print(&quot;, for %.2f%%&quot;,
2933                  ((double)_total_unconditional_delays) / ((double)_total_branches) * 100.0);
2934     tty-&gt;print(&quot;\n&quot;);
2935   }
2936 
2937   uint total_instructions = 0, total_bundles = 0;
2938 
2939   for (uint i = 1; i &lt;= Pipeline::_max_instrs_per_cycle; i++) {
2940     uint bundle_count   = _total_instructions_per_bundle[i];
2941     total_instructions += bundle_count * i;
2942     total_bundles      += bundle_count;
2943   }
2944 
2945   if (total_bundles &gt; 0)
2946     tty-&gt;print(&quot;Average ILP (excluding nops) is %.2f\n&quot;,
2947                ((double)total_instructions) / ((double)total_bundles));
2948 }
2949 #endif































































































































































































































































































































































</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/assembler.inline.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;code/compiledIC.hpp&quot;
  29 #include &quot;code/debugInfo.hpp&quot;
  30 #include &quot;code/debugInfoRec.hpp&quot;
  31 #include &quot;compiler/compileBroker.hpp&quot;
  32 #include &quot;compiler/compilerDirectives.hpp&quot;
  33 #include &quot;compiler/oopMap.hpp&quot;
  34 #include &quot;gc/shared/barrierSet.hpp&quot;
  35 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  36 #include &quot;memory/allocation.inline.hpp&quot;
  37 #include &quot;opto/ad.hpp&quot;
<span class="line-added">  38 #include &quot;opto/block.hpp&quot;</span>
<span class="line-added">  39 #include &quot;opto/c2compiler.hpp&quot;</span>
  40 #include &quot;opto/callnode.hpp&quot;
  41 #include &quot;opto/cfgnode.hpp&quot;
  42 #include &quot;opto/locknode.hpp&quot;
  43 #include &quot;opto/machnode.hpp&quot;
<span class="line-added">  44 #include &quot;opto/node.hpp&quot;</span>
  45 #include &quot;opto/optoreg.hpp&quot;
  46 #include &quot;opto/output.hpp&quot;
  47 #include &quot;opto/regalloc.hpp&quot;
  48 #include &quot;opto/runtime.hpp&quot;
  49 #include &quot;opto/subnode.hpp&quot;
  50 #include &quot;opto/type.hpp&quot;
  51 #include &quot;runtime/handles.inline.hpp&quot;
<span class="line-added">  52 #include &quot;runtime/sharedRuntime.hpp&quot;</span>
<span class="line-added">  53 #include &quot;utilities/macros.hpp&quot;</span>
<span class="line-added">  54 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  55 #include &quot;utilities/xmlstream.hpp&quot;
<span class="line-added">  56 #ifdef X86</span>
<span class="line-added">  57 #include &quot;c2_intelJccErratum_x86.hpp&quot;</span>
<span class="line-added">  58 #endif</span>
  59 
  60 #ifndef PRODUCT
  61 #define DEBUG_ARG(x) , x
  62 #else
  63 #define DEBUG_ARG(x)
  64 #endif
  65 
<span class="line-added">  66 //------------------------------Scheduling----------------------------------</span>
<span class="line-added">  67 // This class contains all the information necessary to implement instruction</span>
<span class="line-added">  68 // scheduling and bundling.</span>
<span class="line-added">  69 class Scheduling {</span>
<span class="line-added">  70 </span>
<span class="line-added">  71 private:</span>
<span class="line-added">  72   // Arena to use</span>
<span class="line-added">  73   Arena *_arena;</span>
<span class="line-added">  74 </span>
<span class="line-added">  75   // Control-Flow Graph info</span>
<span class="line-added">  76   PhaseCFG *_cfg;</span>
<span class="line-added">  77 </span>
<span class="line-added">  78   // Register Allocation info</span>
<span class="line-added">  79   PhaseRegAlloc *_regalloc;</span>
<span class="line-added">  80 </span>
<span class="line-added">  81   // Number of nodes in the method</span>
<span class="line-added">  82   uint _node_bundling_limit;</span>
<span class="line-added">  83 </span>
<span class="line-added">  84   // List of scheduled nodes. Generated in reverse order</span>
<span class="line-added">  85   Node_List _scheduled;</span>
<span class="line-added">  86 </span>
<span class="line-added">  87   // List of nodes currently available for choosing for scheduling</span>
<span class="line-added">  88   Node_List _available;</span>
<span class="line-added">  89 </span>
<span class="line-added">  90   // For each instruction beginning a bundle, the number of following</span>
<span class="line-added">  91   // nodes to be bundled with it.</span>
<span class="line-added">  92   Bundle *_node_bundling_base;</span>
<span class="line-added">  93 </span>
<span class="line-added">  94   // Mapping from register to Node</span>
<span class="line-added">  95   Node_List _reg_node;</span>
<span class="line-added">  96 </span>
<span class="line-added">  97   // Free list for pinch nodes.</span>
<span class="line-added">  98   Node_List _pinch_free_list;</span>
<span class="line-added">  99 </span>
<span class="line-added"> 100   // Latency from the beginning of the containing basic block (base 1)</span>
<span class="line-added"> 101   // for each node.</span>
<span class="line-added"> 102   unsigned short *_node_latency;</span>
<span class="line-added"> 103 </span>
<span class="line-added"> 104   // Number of uses of this node within the containing basic block.</span>
<span class="line-added"> 105   short *_uses;</span>
<span class="line-added"> 106 </span>
<span class="line-added"> 107   // Schedulable portion of current block.  Skips Region/Phi/CreateEx up</span>
<span class="line-added"> 108   // front, branch+proj at end.  Also skips Catch/CProj (same as</span>
<span class="line-added"> 109   // branch-at-end), plus just-prior exception-throwing call.</span>
<span class="line-added"> 110   uint _bb_start, _bb_end;</span>
<span class="line-added"> 111 </span>
<span class="line-added"> 112   // Latency from the end of the basic block as scheduled</span>
<span class="line-added"> 113   unsigned short *_current_latency;</span>
<span class="line-added"> 114 </span>
<span class="line-added"> 115   // Remember the next node</span>
<span class="line-added"> 116   Node *_next_node;</span>
<span class="line-added"> 117 </span>
<span class="line-added"> 118   // Use this for an unconditional branch delay slot</span>
<span class="line-added"> 119   Node *_unconditional_delay_slot;</span>
<span class="line-added"> 120 </span>
<span class="line-added"> 121   // Pointer to a Nop</span>
<span class="line-added"> 122   MachNopNode *_nop;</span>
<span class="line-added"> 123 </span>
<span class="line-added"> 124   // Length of the current bundle, in instructions</span>
<span class="line-added"> 125   uint _bundle_instr_count;</span>
<span class="line-added"> 126 </span>
<span class="line-added"> 127   // Current Cycle number, for computing latencies and bundling</span>
<span class="line-added"> 128   uint _bundle_cycle_number;</span>
<span class="line-added"> 129 </span>
<span class="line-added"> 130   // Bundle information</span>
<span class="line-added"> 131   Pipeline_Use_Element _bundle_use_elements[resource_count];</span>
<span class="line-added"> 132   Pipeline_Use         _bundle_use;</span>
<span class="line-added"> 133 </span>
<span class="line-added"> 134   // Dump the available list</span>
<span class="line-added"> 135   void dump_available() const;</span>
<span class="line-added"> 136 </span>
<span class="line-added"> 137 public:</span>
<span class="line-added"> 138   Scheduling(Arena *arena, Compile &amp;compile);</span>
<span class="line-added"> 139 </span>
<span class="line-added"> 140   // Destructor</span>
<span class="line-added"> 141   NOT_PRODUCT( ~Scheduling(); )</span>
<span class="line-added"> 142 </span>
<span class="line-added"> 143   // Step ahead &quot;i&quot; cycles</span>
<span class="line-added"> 144   void step(uint i);</span>
<span class="line-added"> 145 </span>
<span class="line-added"> 146   // Step ahead 1 cycle, and clear the bundle state (for example,</span>
<span class="line-added"> 147   // at a branch target)</span>
<span class="line-added"> 148   void step_and_clear();</span>
<span class="line-added"> 149 </span>
<span class="line-added"> 150   Bundle* node_bundling(const Node *n) {</span>
<span class="line-added"> 151     assert(valid_bundle_info(n), &quot;oob&quot;);</span>
<span class="line-added"> 152     return (&amp;_node_bundling_base[n-&gt;_idx]);</span>
<span class="line-added"> 153   }</span>
<span class="line-added"> 154 </span>
<span class="line-added"> 155   bool valid_bundle_info(const Node *n) const {</span>
<span class="line-added"> 156     return (_node_bundling_limit &gt; n-&gt;_idx);</span>
<span class="line-added"> 157   }</span>
<span class="line-added"> 158 </span>
<span class="line-added"> 159   bool starts_bundle(const Node *n) const {</span>
<span class="line-added"> 160     return (_node_bundling_limit &gt; n-&gt;_idx &amp;&amp; _node_bundling_base[n-&gt;_idx].starts_bundle());</span>
<span class="line-added"> 161   }</span>
<span class="line-added"> 162 </span>
<span class="line-added"> 163   // Do the scheduling</span>
<span class="line-added"> 164   void DoScheduling();</span>
<span class="line-added"> 165 </span>
<span class="line-added"> 166   // Compute the local latencies walking forward over the list of</span>
<span class="line-added"> 167   // nodes for a basic block</span>
<span class="line-added"> 168   void ComputeLocalLatenciesForward(const Block *bb);</span>
<span class="line-added"> 169 </span>
<span class="line-added"> 170   // Compute the register antidependencies within a basic block</span>
<span class="line-added"> 171   void ComputeRegisterAntidependencies(Block *bb);</span>
<span class="line-added"> 172   void verify_do_def( Node *n, OptoReg::Name def, const char *msg );</span>
<span class="line-added"> 173   void verify_good_schedule( Block *b, const char *msg );</span>
<span class="line-added"> 174   void anti_do_def( Block *b, Node *def, OptoReg::Name def_reg, int is_def );</span>
<span class="line-added"> 175   void anti_do_use( Block *b, Node *use, OptoReg::Name use_reg );</span>
<span class="line-added"> 176 </span>
<span class="line-added"> 177   // Add a node to the current bundle</span>
<span class="line-added"> 178   void AddNodeToBundle(Node *n, const Block *bb);</span>
<span class="line-added"> 179 </span>
<span class="line-added"> 180   // Add a node to the list of available nodes</span>
<span class="line-added"> 181   void AddNodeToAvailableList(Node *n);</span>
<span class="line-added"> 182 </span>
<span class="line-added"> 183   // Compute the local use count for the nodes in a block, and compute</span>
<span class="line-added"> 184   // the list of instructions with no uses in the block as available</span>
<span class="line-added"> 185   void ComputeUseCount(const Block *bb);</span>
<span class="line-added"> 186 </span>
<span class="line-added"> 187   // Choose an instruction from the available list to add to the bundle</span>
<span class="line-added"> 188   Node * ChooseNodeToBundle();</span>
<span class="line-added"> 189 </span>
<span class="line-added"> 190   // See if this Node fits into the currently accumulating bundle</span>
<span class="line-added"> 191   bool NodeFitsInBundle(Node *n);</span>
<span class="line-added"> 192 </span>
<span class="line-added"> 193   // Decrement the use count for a node</span>
<span class="line-added"> 194  void DecrementUseCounts(Node *n, const Block *bb);</span>
<span class="line-added"> 195 </span>
<span class="line-added"> 196   // Garbage collect pinch nodes for reuse by other blocks.</span>
<span class="line-added"> 197   void garbage_collect_pinch_nodes();</span>
<span class="line-added"> 198   // Clean up a pinch node for reuse (helper for above).</span>
<span class="line-added"> 199   void cleanup_pinch( Node *pinch );</span>
<span class="line-added"> 200 </span>
<span class="line-added"> 201   // Information for statistics gathering</span>
<span class="line-added"> 202 #ifndef PRODUCT</span>
<span class="line-added"> 203 private:</span>
<span class="line-added"> 204   // Gather information on size of nops relative to total</span>
<span class="line-added"> 205   uint _branches, _unconditional_delays;</span>
<span class="line-added"> 206 </span>
<span class="line-added"> 207   static uint _total_nop_size, _total_method_size;</span>
<span class="line-added"> 208   static uint _total_branches, _total_unconditional_delays;</span>
<span class="line-added"> 209   static uint _total_instructions_per_bundle[Pipeline::_max_instrs_per_cycle+1];</span>
<span class="line-added"> 210 </span>
<span class="line-added"> 211 public:</span>
<span class="line-added"> 212   static void print_statistics();</span>
<span class="line-added"> 213 </span>
<span class="line-added"> 214   static void increment_instructions_per_bundle(uint i) {</span>
<span class="line-added"> 215     _total_instructions_per_bundle[i]++;</span>
<span class="line-added"> 216   }</span>
<span class="line-added"> 217 </span>
<span class="line-added"> 218   static void increment_nop_size(uint s) {</span>
<span class="line-added"> 219     _total_nop_size += s;</span>
<span class="line-added"> 220   }</span>
<span class="line-added"> 221 </span>
<span class="line-added"> 222   static void increment_method_size(uint s) {</span>
<span class="line-added"> 223     _total_method_size += s;</span>
<span class="line-added"> 224   }</span>
<span class="line-added"> 225 #endif</span>
<span class="line-added"> 226 </span>
<span class="line-added"> 227 };</span>
<span class="line-added"> 228 </span>
<span class="line-added"> 229 </span>
<span class="line-added"> 230 PhaseOutput::PhaseOutput()</span>
<span class="line-added"> 231   : Phase(Phase::Output),</span>
<span class="line-added"> 232     _code_buffer(&quot;Compile::Fill_buffer&quot;),</span>
<span class="line-added"> 233     _first_block_size(0),</span>
<span class="line-added"> 234     _handler_table(),</span>
<span class="line-added"> 235     _inc_table(),</span>
<span class="line-added"> 236     _oop_map_set(NULL),</span>
<span class="line-added"> 237     _scratch_buffer_blob(NULL),</span>
<span class="line-added"> 238     _scratch_locs_memory(NULL),</span>
<span class="line-added"> 239     _scratch_const_size(-1),</span>
<span class="line-added"> 240     _in_scratch_emit_size(false),</span>
<span class="line-added"> 241     _frame_slots(0),</span>
<span class="line-added"> 242     _code_offsets(),</span>
<span class="line-added"> 243     _node_bundling_limit(0),</span>
<span class="line-added"> 244     _node_bundling_base(NULL),</span>
<span class="line-added"> 245     _orig_pc_slot(0),</span>
<span class="line-added"> 246     _orig_pc_slot_offset_in_bytes(0) {</span>
<span class="line-added"> 247   C-&gt;set_output(this);</span>
<span class="line-added"> 248   if (C-&gt;stub_name() == NULL) {</span>
<span class="line-added"> 249     _orig_pc_slot = C-&gt;fixed_slots() - (sizeof(address) / VMRegImpl::stack_slot_size);</span>
<span class="line-added"> 250   }</span>
<span class="line-added"> 251 }</span>
<span class="line-added"> 252 </span>
<span class="line-added"> 253 PhaseOutput::~PhaseOutput() {</span>
<span class="line-added"> 254   C-&gt;set_output(NULL);</span>
<span class="line-added"> 255   if (_scratch_buffer_blob != NULL) {</span>
<span class="line-added"> 256     BufferBlob::free(_scratch_buffer_blob);</span>
<span class="line-added"> 257   }</span>
<span class="line-added"> 258 }</span>
<span class="line-added"> 259 </span>
 260 // Convert Nodes to instruction bits and pass off to the VM
<span class="line-modified"> 261 void PhaseOutput::Output() {</span>
 262   // RootNode goes
<span class="line-modified"> 263   assert( C-&gt;cfg()-&gt;get_root_block()-&gt;number_of_nodes() == 0, &quot;&quot; );</span>
 264 
 265   // The number of new nodes (mostly MachNop) is proportional to
 266   // the number of java calls and inner loops which are aligned.
 267   if ( C-&gt;check_node_count((NodeLimitFudgeFactor + C-&gt;java_calls()*3 +
 268                             C-&gt;inner_loops()*(OptoLoopAlignment-1)),
 269                            &quot;out of nodes before code generation&quot; ) ) {
 270     return;
 271   }
 272   // Make sure I can find the Start Node
<span class="line-modified"> 273   Block *entry = C-&gt;cfg()-&gt;get_block(1);</span>
<span class="line-modified"> 274   Block *broot = C-&gt;cfg()-&gt;get_root_block();</span>
 275 
 276   const StartNode *start = entry-&gt;head()-&gt;as_Start();
 277 
 278   // Replace StartNode with prolog
 279   MachPrologNode *prolog = new MachPrologNode();
 280   entry-&gt;map_node(prolog, 0);
<span class="line-modified"> 281   C-&gt;cfg()-&gt;map_node_to_block(prolog, entry);</span>
<span class="line-modified"> 282   C-&gt;cfg()-&gt;unmap_node_from_block(start); // start is no longer in any block</span>
 283 
 284   // Virtual methods need an unverified entry point
 285 
<span class="line-modified"> 286   if( C-&gt;is_osr_compilation() ) {</span>
 287     if( PoisonOSREntry ) {
 288       // TODO: Should use a ShouldNotReachHereNode...
<span class="line-modified"> 289       C-&gt;cfg()-&gt;insert( broot, 0, new MachBreakpointNode() );</span>
 290     }
 291   } else {
<span class="line-modified"> 292     if( C-&gt;method() &amp;&amp; !C-&gt;method()-&gt;flags().is_static() ) {</span>
 293       // Insert unvalidated entry point
<span class="line-modified"> 294       C-&gt;cfg()-&gt;insert( broot, 0, new MachUEPNode() );</span>
 295     }
 296 
 297   }
 298 
 299   // Break before main entry point
<span class="line-modified"> 300   if ((C-&gt;method() &amp;&amp; C-&gt;directive()-&gt;BreakAtExecuteOption) ||</span>
<span class="line-modified"> 301       (OptoBreakpoint &amp;&amp; C-&gt;is_method_compilation())       ||</span>
<span class="line-modified"> 302       (OptoBreakpointOSR &amp;&amp; C-&gt;is_osr_compilation())       ||</span>
<span class="line-modified"> 303       (OptoBreakpointC2R &amp;&amp; !C-&gt;method())                   ) {</span>
<span class="line-modified"> 304     // checking for C-&gt;method() means that OptoBreakpoint does not apply to</span>
 305     // runtime stubs or frame converters
<span class="line-modified"> 306     C-&gt;cfg()-&gt;insert( entry, 1, new MachBreakpointNode() );</span>
 307   }
 308 
 309   // Insert epilogs before every return
<span class="line-modified"> 310   for (uint i = 0; i &lt; C-&gt;cfg()-&gt;number_of_blocks(); i++) {</span>
<span class="line-modified"> 311     Block* block = C-&gt;cfg()-&gt;get_block(i);</span>
<span class="line-modified"> 312     if (!block-&gt;is_connector() &amp;&amp; block-&gt;non_connector_successor(0) == C-&gt;cfg()-&gt;get_root_block()) { // Found a program exit point?</span>
 313       Node* m = block-&gt;end();
 314       if (m-&gt;is_Mach() &amp;&amp; m-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Halt) {
 315         MachEpilogNode* epilog = new MachEpilogNode(m-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Return);
 316         block-&gt;add_inst(epilog);
<span class="line-modified"> 317         C-&gt;cfg()-&gt;map_node_to_block(epilog, block);</span>
 318       }
 319     }
 320   }
 321 
 322   // Keeper of sizing aspects
 323   BufferSizingData buf_sizes = BufferSizingData();
 324 
 325   // Initialize code buffer
 326   estimate_buffer_size(buf_sizes._const);
<span class="line-modified"> 327   if (C-&gt;failing()) return;</span>
 328 
 329   // Pre-compute the length of blocks and replace
 330   // long branches with short if machine supports it.
 331   // Must be done before ScheduleAndBundle due to SPARC delay slots
<span class="line-modified"> 332   uint* blk_starts = NEW_RESOURCE_ARRAY(uint, C-&gt;cfg()-&gt;number_of_blocks() + 1);</span>
 333   blk_starts[0] = 0;
 334   shorten_branches(blk_starts, buf_sizes);
 335 
 336   ScheduleAndBundle();
<span class="line-modified"> 337   if (C-&gt;failing()) {</span>
 338     return;
 339   }
 340 
 341   // Late barrier analysis must be done after schedule and bundle
 342   // Otherwise liveness based spilling will fail
 343   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 344   bs-&gt;late_barrier_analysis();
 345 
<span class="line-added"> 346 #ifdef X86</span>
<span class="line-added"> 347   if (VM_Version::has_intel_jcc_erratum()) {</span>
<span class="line-added"> 348     int extra_padding = IntelJccErratum::tag_affected_machnodes(C, C-&gt;cfg(), C-&gt;regalloc());</span>
<span class="line-added"> 349     buf_sizes._code += extra_padding;</span>
<span class="line-added"> 350   }</span>
<span class="line-added"> 351 #endif</span>
<span class="line-added"> 352 </span>
 353   // Complete sizing of codebuffer
 354   CodeBuffer* cb = init_buffer(buf_sizes);
<span class="line-modified"> 355   if (cb == NULL || C-&gt;failing()) {</span>
 356     return;
 357   }
 358 
 359   BuildOopMaps();
 360 
<span class="line-modified"> 361   if (C-&gt;failing())  {</span>
 362     return;
 363   }
 364 
 365   fill_buffer(cb, blk_starts);
 366 }
 367 
<span class="line-modified"> 368 bool PhaseOutput::need_stack_bang(int frame_size_in_bytes) const {</span>
 369   // Determine if we need to generate a stack overflow check.
 370   // Do it if the method is not a stub function and
 371   // has java calls or has frame size &gt; vm_page_size/8.
 372   // The debug VM checks that deoptimization doesn&#39;t trigger an
 373   // unexpected stack overflow (compiled method stack banging should
 374   // guarantee it doesn&#39;t happen) so we always need the stack bang in
 375   // a debug VM.
<span class="line-modified"> 376   return (UseStackBanging &amp;&amp; C-&gt;stub_function() == NULL &amp;&amp;</span>
<span class="line-modified"> 377           (C-&gt;has_java_calls() || frame_size_in_bytes &gt; os::vm_page_size()&gt;&gt;3</span>
 378            DEBUG_ONLY(|| true)));
 379 }
 380 
<span class="line-modified"> 381 bool PhaseOutput::need_register_stack_bang() const {</span>
 382   // Determine if we need to generate a register stack overflow check.
 383   // This is only used on architectures which have split register
 384   // and memory stacks (ie. IA64).
 385   // Bang if the method is not a stub function and has java calls
<span class="line-modified"> 386   return (C-&gt;stub_function() == NULL &amp;&amp; C-&gt;has_java_calls());</span>
 387 }
 388 
 389 
 390 // Compute the size of first NumberOfLoopInstrToAlign instructions at the top
 391 // of a loop. When aligning a loop we need to provide enough instructions
 392 // in cpu&#39;s fetch buffer to feed decoders. The loop alignment could be
 393 // avoided if we have enough instructions in fetch buffer at the head of a loop.
 394 // By default, the size is set to 999999 by Block&#39;s constructor so that
 395 // a loop will be aligned if the size is not reset here.
 396 //
 397 // Note: Mach instructions could contain several HW instructions
 398 // so the size is estimated only.
 399 //
<span class="line-modified"> 400 void PhaseOutput::compute_loop_first_inst_sizes() {</span>
 401   // The next condition is used to gate the loop alignment optimization.
 402   // Don&#39;t aligned a loop if there are enough instructions at the head of a loop
 403   // or alignment padding is larger then MaxLoopPad. By default, MaxLoopPad
 404   // is equal to OptoLoopAlignment-1 except on new Intel cpus, where it is
 405   // equal to 11 bytes which is the largest address NOP instruction.
 406   if (MaxLoopPad &lt; OptoLoopAlignment - 1) {
<span class="line-modified"> 407     uint last_block = C-&gt;cfg()-&gt;number_of_blocks() - 1;</span>
 408     for (uint i = 1; i &lt;= last_block; i++) {
<span class="line-modified"> 409       Block* block = C-&gt;cfg()-&gt;get_block(i);</span>
 410       // Check the first loop&#39;s block which requires an alignment.
 411       if (block-&gt;loop_alignment() &gt; (uint)relocInfo::addr_unit()) {
 412         uint sum_size = 0;
 413         uint inst_cnt = NumberOfLoopInstrToAlign;
<span class="line-modified"> 414         inst_cnt = block-&gt;compute_first_inst_size(sum_size, inst_cnt, C-&gt;regalloc());</span>
 415 
 416         // Check subsequent fallthrough blocks if the loop&#39;s first
 417         // block(s) does not have enough instructions.
 418         Block *nb = block;
 419         while(inst_cnt &gt; 0 &amp;&amp;
 420               i &lt; last_block &amp;&amp;
<span class="line-modified"> 421               !C-&gt;cfg()-&gt;get_block(i + 1)-&gt;has_loop_alignment() &amp;&amp;</span>
 422               !nb-&gt;has_successor(block)) {
 423           i++;
<span class="line-modified"> 424           nb = C-&gt;cfg()-&gt;get_block(i);</span>
<span class="line-modified"> 425           inst_cnt  = nb-&gt;compute_first_inst_size(sum_size, inst_cnt, C-&gt;regalloc());</span>
 426         } // while( inst_cnt &gt; 0 &amp;&amp; i &lt; last_block  )
 427 
 428         block-&gt;set_first_inst_size(sum_size);
 429       } // f( b-&gt;head()-&gt;is_Loop() )
 430     } // for( i &lt;= last_block )
 431   } // if( MaxLoopPad &lt; OptoLoopAlignment-1 )
 432 }
 433 
 434 // The architecture description provides short branch variants for some long
 435 // branch instructions. Replace eligible long branches with short branches.
<span class="line-modified"> 436 void PhaseOutput::shorten_branches(uint* blk_starts, BufferSizingData&amp; buf_sizes) {</span>
 437   // Compute size of each block, method size, and relocation information size
<span class="line-modified"> 438   uint nblocks  = C-&gt;cfg()-&gt;number_of_blocks();</span>
 439 
 440   uint*      jmp_offset = NEW_RESOURCE_ARRAY(uint,nblocks);
 441   uint*      jmp_size   = NEW_RESOURCE_ARRAY(uint,nblocks);
 442   int*       jmp_nidx   = NEW_RESOURCE_ARRAY(int ,nblocks);
 443 
 444   // Collect worst case block paddings
 445   int* block_worst_case_pad = NEW_RESOURCE_ARRAY(int, nblocks);
 446   memset(block_worst_case_pad, 0, nblocks * sizeof(int));
 447 
 448   DEBUG_ONLY( uint *jmp_target = NEW_RESOURCE_ARRAY(uint,nblocks); )
 449   DEBUG_ONLY( uint *jmp_rule = NEW_RESOURCE_ARRAY(uint,nblocks); )
 450 
 451   bool has_short_branch_candidate = false;
 452 
 453   // Initialize the sizes to 0
 454   int code_size  = 0;          // Size in bytes of generated code
 455   int stub_size  = 0;          // Size in bytes of all stub entries
 456   // Size in bytes of all relocation entries, including those in local stubs.
 457   // Start with 2-bytes of reloc info for the unvalidated entry point
 458   int reloc_size = 1;          // Number of relocation entries
 459 
 460   // Make three passes.  The first computes pessimistic blk_starts,
 461   // relative jmp_offset and reloc_size information.  The second performs
 462   // short branch substitution using the pessimistic sizing.  The
 463   // third inserts nops where needed.
 464 
 465   // Step one, perform a pessimistic sizing pass.
 466   uint last_call_adr = max_juint;
 467   uint last_avoid_back_to_back_adr = max_juint;
<span class="line-modified"> 468   uint nop_size = (new MachNopNode())-&gt;size(C-&gt;regalloc());</span>
 469   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
<span class="line-modified"> 470     Block* block = C-&gt;cfg()-&gt;get_block(i);</span>
 471 
 472     // During short branch replacement, we store the relative (to blk_starts)
 473     // offset of jump in jmp_offset, rather than the absolute offset of jump.
 474     // This is so that we do not need to recompute sizes of all nodes when
 475     // we compute correct blk_starts in our next sizing pass.
 476     jmp_offset[i] = 0;
 477     jmp_size[i]   = 0;
 478     jmp_nidx[i]   = -1;
 479     DEBUG_ONLY( jmp_target[i] = 0; )
 480     DEBUG_ONLY( jmp_rule[i]   = 0; )
 481 
 482     // Sum all instruction sizes to compute block size
 483     uint last_inst = block-&gt;number_of_nodes();
 484     uint blk_size = 0;
 485     for (uint j = 0; j &lt; last_inst; j++) {
 486       Node* nj = block-&gt;get_node(j);
 487       // Handle machine instruction nodes
 488       if (nj-&gt;is_Mach()) {
 489         MachNode *mach = nj-&gt;as_Mach();
 490         blk_size += (mach-&gt;alignment_required() - 1) * relocInfo::addr_unit(); // assume worst case padding
<span class="line-added"> 491 #ifdef X86</span>
<span class="line-added"> 492         if (VM_Version::has_intel_jcc_erratum() &amp;&amp; IntelJccErratum::is_jcc_erratum_branch(block, mach, j)) {</span>
<span class="line-added"> 493           // Conservatively add worst case padding</span>
<span class="line-added"> 494           blk_size += IntelJccErratum::largest_jcc_size();</span>
<span class="line-added"> 495         }</span>
<span class="line-added"> 496 #endif</span>
<span class="line-added"> 497 </span>
 498         reloc_size += mach-&gt;reloc();
 499         if (mach-&gt;is_MachCall()) {
 500           // add size information for trampoline stub
 501           // class CallStubImpl is platform-specific and defined in the *.ad files.
 502           stub_size  += CallStubImpl::size_call_trampoline();
 503           reloc_size += CallStubImpl::reloc_call_trampoline();
 504 
 505           MachCallNode *mcall = mach-&gt;as_MachCall();
 506           // This destination address is NOT PC-relative
 507 
 508           mcall-&gt;method_set((intptr_t)mcall-&gt;entry_point());
 509 
 510           if (mcall-&gt;is_MachCallJava() &amp;&amp; mcall-&gt;as_MachCallJava()-&gt;_method) {
 511             stub_size  += CompiledStaticCall::to_interp_stub_size();
 512             reloc_size += CompiledStaticCall::reloc_to_interp_stub();
 513 #if INCLUDE_AOT
 514             stub_size  += CompiledStaticCall::to_aot_stub_size();
 515             reloc_size += CompiledStaticCall::reloc_to_aot_stub();
 516 #endif
 517           }
</pre>
<hr />
<pre>
 524             blk_size += nop_size;
 525           }
 526         }
 527         if (mach-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
 528           // Nop is inserted between &quot;avoid back to back&quot; instructions.
 529           // ScheduleAndBundle() can rearrange nodes in a block,
 530           // check for all offsets inside this block.
 531           if (last_avoid_back_to_back_adr &gt;= blk_starts[i]) {
 532             blk_size += nop_size;
 533           }
 534         }
 535         if (mach-&gt;may_be_short_branch()) {
 536           if (!nj-&gt;is_MachBranch()) {
 537 #ifndef PRODUCT
 538             nj-&gt;dump(3);
 539 #endif
 540             Unimplemented();
 541           }
 542           assert(jmp_nidx[i] == -1, &quot;block should have only one branch&quot;);
 543           jmp_offset[i] = blk_size;
<span class="line-modified"> 544           jmp_size[i]   = nj-&gt;size(C-&gt;regalloc());</span>
 545           jmp_nidx[i]   = j;
 546           has_short_branch_candidate = true;
 547         }
 548       }
<span class="line-modified"> 549       blk_size += nj-&gt;size(C-&gt;regalloc());</span>
 550       // Remember end of call offset
 551       if (nj-&gt;is_MachCall() &amp;&amp; !nj-&gt;is_MachCallLeaf()) {
 552         last_call_adr = blk_starts[i]+blk_size;
 553       }
 554       // Remember end of avoid_back_to_back offset
 555       if (nj-&gt;is_Mach() &amp;&amp; nj-&gt;as_Mach()-&gt;avoid_back_to_back(MachNode::AVOID_AFTER)) {
 556         last_avoid_back_to_back_adr = blk_starts[i]+blk_size;
 557       }
 558     }
 559 
 560     // When the next block starts a loop, we may insert pad NOP
 561     // instructions.  Since we cannot know our future alignment,
 562     // assume the worst.
 563     if (i &lt; nblocks - 1) {
<span class="line-modified"> 564       Block* nb = C-&gt;cfg()-&gt;get_block(i + 1);</span>
 565       int max_loop_pad = nb-&gt;code_alignment()-relocInfo::addr_unit();
 566       if (max_loop_pad &gt; 0) {
 567         assert(is_power_of_2(max_loop_pad+relocInfo::addr_unit()), &quot;&quot;);
 568         // Adjust last_call_adr and/or last_avoid_back_to_back_adr.
 569         // If either is the last instruction in this block, bump by
 570         // max_loop_pad in lock-step with blk_size, so sizing
 571         // calculations in subsequent blocks still can conservatively
 572         // detect that it may the last instruction in this block.
 573         if (last_call_adr == blk_starts[i]+blk_size) {
 574           last_call_adr += max_loop_pad;
 575         }
 576         if (last_avoid_back_to_back_adr == blk_starts[i]+blk_size) {
 577           last_avoid_back_to_back_adr += max_loop_pad;
 578         }
 579         blk_size += max_loop_pad;
 580         block_worst_case_pad[i + 1] = max_loop_pad;
 581       }
 582     }
 583 
 584     // Save block size; update total method size
 585     blk_starts[i+1] = blk_starts[i]+blk_size;
 586   }
 587 
 588   // Step two, replace eligible long jumps.
 589   bool progress = true;
 590   uint last_may_be_short_branch_adr = max_juint;
 591   while (has_short_branch_candidate &amp;&amp; progress) {
 592     progress = false;
 593     has_short_branch_candidate = false;
 594     int adjust_block_start = 0;
 595     for (uint i = 0; i &lt; nblocks; i++) {
<span class="line-modified"> 596       Block* block = C-&gt;cfg()-&gt;get_block(i);</span>
 597       int idx = jmp_nidx[i];
 598       MachNode* mach = (idx == -1) ? NULL: block-&gt;get_node(idx)-&gt;as_Mach();
 599       if (mach != NULL &amp;&amp; mach-&gt;may_be_short_branch()) {
 600 #ifdef ASSERT
 601         assert(jmp_size[i] &gt; 0 &amp;&amp; mach-&gt;is_MachBranch(), &quot;sanity&quot;);
 602         int j;
 603         // Find the branch; ignore trailing NOPs.
 604         for (j = block-&gt;number_of_nodes()-1; j&gt;=0; j--) {
 605           Node* n = block-&gt;get_node(j);
 606           if (!n-&gt;is_Mach() || n-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Con)
 607             break;
 608         }
 609         assert(j &gt;= 0 &amp;&amp; j == idx &amp;&amp; block-&gt;get_node(j) == (Node*)mach, &quot;sanity&quot;);
 610 #endif
 611         int br_size = jmp_size[i];
 612         int br_offs = blk_starts[i] + jmp_offset[i];
 613 
 614         // This requires the TRUE branch target be in succs[0]
 615         uint bnum = block-&gt;non_connector_successor(0)-&gt;_pre_order;
 616         int offset = blk_starts[bnum] - br_offs;
 617         if (bnum &gt; i) { // adjust following block&#39;s offset
 618           offset -= adjust_block_start;
 619         }
 620 
 621         // This block can be a loop header, account for the padding
 622         // in the previous block.
 623         int block_padding = block_worst_case_pad[i];
 624         assert(i == 0 || block_padding == 0 || br_offs &gt;= block_padding, &quot;Should have at least a padding on top&quot;);
 625         // In the following code a nop could be inserted before
 626         // the branch which will increase the backward distance.
 627         bool needs_padding = ((uint)(br_offs - block_padding) == last_may_be_short_branch_adr);
 628         assert(!needs_padding || jmp_offset[i] == 0, &quot;padding only branches at the beginning of block&quot;);
 629 
 630         if (needs_padding &amp;&amp; offset &lt;= 0)
 631           offset -= nop_size;
 632 
<span class="line-modified"> 633         if (C-&gt;matcher()-&gt;is_short_branch_offset(mach-&gt;rule(), br_size, offset)) {</span>
 634           // We&#39;ve got a winner.  Replace this branch.
 635           MachNode* replacement = mach-&gt;as_MachBranch()-&gt;short_branch_version();
 636 
 637           // Update the jmp_size.
<span class="line-modified"> 638           int new_size = replacement-&gt;size(C-&gt;regalloc());</span>
 639           int diff     = br_size - new_size;
 640           assert(diff &gt;= (int)nop_size, &quot;short_branch size should be smaller&quot;);
 641           // Conservatively take into account padding between
 642           // avoid_back_to_back branches. Previous branch could be
 643           // converted into avoid_back_to_back branch during next
 644           // rounds.
 645           if (needs_padding &amp;&amp; replacement-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
 646             jmp_offset[i] += nop_size;
 647             diff -= nop_size;
 648           }
 649           adjust_block_start += diff;
 650           block-&gt;map_node(replacement, idx);
 651           mach-&gt;subsume_by(replacement, C);
 652           mach = replacement;
 653           progress = true;
 654 
 655           jmp_size[i] = new_size;
 656           DEBUG_ONLY( jmp_target[i] = bnum; );
 657           DEBUG_ONLY( jmp_rule[i] = mach-&gt;rule(); );
 658         } else {
 659           // The jump distance is not short, try again during next iteration.
 660           has_short_branch_candidate = true;
 661         }
 662       } // (mach-&gt;may_be_short_branch())
 663       if (mach != NULL &amp;&amp; (mach-&gt;may_be_short_branch() ||
 664                            mach-&gt;avoid_back_to_back(MachNode::AVOID_AFTER))) {
 665         last_may_be_short_branch_adr = blk_starts[i] + jmp_offset[i] + jmp_size[i];
 666       }
 667       blk_starts[i+1] -= adjust_block_start;
 668     }
 669   }
 670 
 671 #ifdef ASSERT
 672   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
 673     if (jmp_target[i] != 0) {
 674       int br_size = jmp_size[i];
 675       int offset = blk_starts[jmp_target[i]]-(blk_starts[i] + jmp_offset[i]);
<span class="line-modified"> 676       if (!C-&gt;matcher()-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset)) {</span>
 677         tty-&gt;print_cr(&quot;target (%d) - jmp_offset(%d) = offset (%d), jump_size(%d), jmp_block B%d, target_block B%d&quot;, blk_starts[jmp_target[i]], blk_starts[i] + jmp_offset[i], offset, br_size, i, jmp_target[i]);
 678       }
<span class="line-modified"> 679       assert(C-&gt;matcher()-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset), &quot;Displacement too large for short jmp&quot;);</span>
 680     }
 681   }
 682 #endif
 683 
 684   // Step 3, compute the offsets of all blocks, will be done in fill_buffer()
 685   // after ScheduleAndBundle().
 686 
 687   // ------------------
 688   // Compute size for code buffer
 689   code_size = blk_starts[nblocks];
 690 
 691   // Relocation records
 692   reloc_size += 1;              // Relo entry for exception handler
 693 
 694   // Adjust reloc_size to number of record of relocation info
 695   // Min is 2 bytes, max is probably 6 or 8, with a tax up to 25% for
 696   // a relocation index.
 697   // The CodeBuffer will expand the locs array if this estimate is too low.
 698   reloc_size *= 10 / sizeof(relocInfo);
 699 
 700   buf_sizes._reloc = reloc_size;
 701   buf_sizes._code  = code_size;
 702   buf_sizes._stub  = stub_size;
 703 }
 704 
 705 //------------------------------FillLocArray-----------------------------------
 706 // Create a bit of debug info and append it to the array.  The mapping is from
 707 // Java local or expression stack to constant, register or stack-slot.  For
 708 // doubles, insert 2 mappings and return 1 (to tell the caller that the next
 709 // entry has been taken care of and caller should skip it).
 710 static LocationValue *new_loc_value( PhaseRegAlloc *ra, OptoReg::Name regnum, Location::Type l_type ) {
 711   // This should never have accepted Bad before
 712   assert(OptoReg::is_valid(regnum), &quot;location must be valid&quot;);
 713   return (OptoReg::is_reg(regnum))
 714          ? new LocationValue(Location::new_reg_loc(l_type, OptoReg::as_VMReg(regnum)) )
 715          : new LocationValue(Location::new_stk_loc(l_type,  ra-&gt;reg2offset(regnum)));
 716 }
 717 
 718 
 719 ObjectValue*
<span class="line-modified"> 720 PhaseOutput::sv_for_node_id(GrowableArray&lt;ScopeValue*&gt; *objs, int id) {</span>
 721   for (int i = 0; i &lt; objs-&gt;length(); i++) {
 722     assert(objs-&gt;at(i)-&gt;is_object(), &quot;corrupt object cache&quot;);
 723     ObjectValue* sv = (ObjectValue*) objs-&gt;at(i);
 724     if (sv-&gt;id() == id) {
 725       return sv;
 726     }
 727   }
 728   // Otherwise..
 729   return NULL;
 730 }
 731 
<span class="line-modified"> 732 void PhaseOutput::set_sv_for_object_node(GrowableArray&lt;ScopeValue*&gt; *objs,</span>
 733                                      ObjectValue* sv ) {
 734   assert(sv_for_node_id(objs, sv-&gt;id()) == NULL, &quot;Precondition&quot;);
 735   objs-&gt;append(sv);
 736 }
 737 
 738 
<span class="line-modified"> 739 void PhaseOutput::FillLocArray( int idx, MachSafePointNode* sfpt, Node *local,</span>
 740                             GrowableArray&lt;ScopeValue*&gt; *array,
 741                             GrowableArray&lt;ScopeValue*&gt; *objs ) {
 742   assert( local, &quot;use _top instead of null&quot; );
 743   if (array-&gt;length() != idx) {
 744     assert(array-&gt;length() == idx + 1, &quot;Unexpected array count&quot;);
 745     // Old functionality:
 746     //   return
 747     // New functionality:
 748     //   Assert if the local is not top. In product mode let the new node
 749     //   override the old entry.
<span class="line-modified"> 750     assert(local == C-&gt;top(), &quot;LocArray collision&quot;);</span>
<span class="line-modified"> 751     if (local == C-&gt;top()) {</span>
 752       return;
 753     }
 754     array-&gt;pop();
 755   }
 756   const Type *t = local-&gt;bottom_type();
 757 
 758   // Is it a safepoint scalar object node?
 759   if (local-&gt;is_SafePointScalarObject()) {
 760     SafePointScalarObjectNode* spobj = local-&gt;as_SafePointScalarObject();
 761 
<span class="line-modified"> 762     ObjectValue* sv = sv_for_node_id(objs, spobj-&gt;_idx);</span>
 763     if (sv == NULL) {
 764       ciKlass* cik = t-&gt;is_oopptr()-&gt;klass();
 765       assert(cik-&gt;is_instance_klass() ||
 766              cik-&gt;is_array_klass(), &quot;Not supported allocation.&quot;);
 767       sv = new ObjectValue(spobj-&gt;_idx,
 768                            new ConstantOopWriteValue(cik-&gt;java_mirror()-&gt;constant_encoding()));
<span class="line-modified"> 769       set_sv_for_object_node(objs, sv);</span>
 770 
 771       uint first_ind = spobj-&gt;first_index(sfpt-&gt;jvms());
 772       for (uint i = 0; i &lt; spobj-&gt;n_fields(); i++) {
 773         Node* fld_node = sfpt-&gt;in(first_ind+i);
 774         (void)FillLocArray(sv-&gt;field_values()-&gt;length(), sfpt, fld_node, sv-&gt;field_values(), objs);
 775       }
 776     }
 777     array-&gt;append(sv);
 778     return;
 779   }
 780 
 781   // Grab the register number for the local
<span class="line-modified"> 782   OptoReg::Name regnum = C-&gt;regalloc()-&gt;get_reg_first(local);</span>
 783   if( OptoReg::is_valid(regnum) ) {// Got a register/stack?
 784     // Record the double as two float registers.
 785     // The register mask for such a value always specifies two adjacent
 786     // float registers, with the lower register number even.
 787     // Normally, the allocation of high and low words to these registers
 788     // is irrelevant, because nearly all operations on register pairs
 789     // (e.g., StoreD) treat them as a single unit.
 790     // Here, we assume in addition that the words in these two registers
 791     // stored &quot;naturally&quot; (by operations like StoreD and double stores
 792     // within the interpreter) such that the lower-numbered register
 793     // is written to the lower memory address.  This may seem like
 794     // a machine dependency, but it is not--it is a requirement on
 795     // the author of the &lt;arch&gt;.ad file to ensure that, for every
 796     // even/odd double-register pair to which a double may be allocated,
 797     // the word in the even single-register is stored to the first
 798     // memory word.  (Note that register numbers are completely
 799     // arbitrary, and are not tied to any machine-level encodings.)
 800 #ifdef _LP64
 801     if( t-&gt;base() == Type::DoubleBot || t-&gt;base() == Type::DoubleCon ) {
 802       array-&gt;append(new ConstantIntValue((jint)0));
<span class="line-modified"> 803       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, Location::dbl ));</span>
 804     } else if ( t-&gt;base() == Type::Long ) {
 805       array-&gt;append(new ConstantIntValue((jint)0));
<span class="line-modified"> 806       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, Location::lng ));</span>
 807     } else if ( t-&gt;base() == Type::RawPtr ) {
 808       // jsr/ret return address which must be restored into a the full
 809       // width 64-bit stack slot.
<span class="line-modified"> 810       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, Location::lng ));</span>
 811     }
 812 #else //_LP64
 813 #ifdef SPARC
 814     if (t-&gt;base() == Type::Long &amp;&amp; OptoReg::is_reg(regnum)) {
 815       // For SPARC we have to swap high and low words for
 816       // long values stored in a single-register (g0-g7).
<span class="line-modified"> 817       array-&gt;append(new_loc_value( C-&gt;regalloc(),              regnum   , Location::normal ));</span>
<span class="line-modified"> 818       array-&gt;append(new_loc_value( C-&gt;regalloc(), OptoReg::add(regnum,1), Location::normal ));</span>
 819     } else
 820 #endif //SPARC
 821     if( t-&gt;base() == Type::DoubleBot || t-&gt;base() == Type::DoubleCon || t-&gt;base() == Type::Long ) {
 822       // Repack the double/long as two jints.
 823       // The convention the interpreter uses is that the second local
 824       // holds the first raw word of the native double representation.
 825       // This is actually reasonable, since locals and stack arrays
 826       // grow downwards in all implementations.
 827       // (If, on some machine, the interpreter&#39;s Java locals or stack
 828       // were to grow upwards, the embedded doubles would be word-swapped.)
<span class="line-modified"> 829       array-&gt;append(new_loc_value( C-&gt;regalloc(), OptoReg::add(regnum,1), Location::normal ));</span>
<span class="line-modified"> 830       array-&gt;append(new_loc_value( C-&gt;regalloc(),              regnum   , Location::normal ));</span>
 831     }
 832 #endif //_LP64
 833     else if( (t-&gt;base() == Type::FloatBot || t-&gt;base() == Type::FloatCon) &amp;&amp;
 834              OptoReg::is_reg(regnum) ) {
<span class="line-modified"> 835       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, Matcher::float_in_double()</span>
 836                                                       ? Location::float_in_dbl : Location::normal ));
 837     } else if( t-&gt;base() == Type::Int &amp;&amp; OptoReg::is_reg(regnum) ) {
<span class="line-modified"> 838       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, Matcher::int_in_long</span>
 839                                                       ? Location::int_in_long : Location::normal ));
 840     } else if( t-&gt;base() == Type::NarrowOop ) {
<span class="line-modified"> 841       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, Location::narrowoop ));</span>
 842     } else {
<span class="line-modified"> 843       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, C-&gt;regalloc()-&gt;is_oop(local) ? Location::oop : Location::normal ));</span>
 844     }
 845     return;
 846   }
 847 
 848   // No register.  It must be constant data.
 849   switch (t-&gt;base()) {
 850     case Type::Half:              // Second half of a double
 851       ShouldNotReachHere();       // Caller should skip 2nd halves
 852       break;
 853     case Type::AnyPtr:
 854       array-&gt;append(new ConstantOopWriteValue(NULL));
 855       break;
 856     case Type::AryPtr:
 857     case Type::InstPtr:          // fall through
 858       array-&gt;append(new ConstantOopWriteValue(t-&gt;isa_oopptr()-&gt;const_oop()-&gt;constant_encoding()));
 859       break;
 860     case Type::NarrowOop:
 861       if (t == TypeNarrowOop::NULL_PTR) {
 862         array-&gt;append(new ConstantOopWriteValue(NULL));
 863       } else {
</pre>
<hr />
<pre>
 915     // grow downwards in all implementations.
 916     // (If, on some machine, the interpreter&#39;s Java locals or stack
 917     // were to grow upwards, the embedded doubles would be word-swapped.)
 918     jlong_accessor acc;
 919     acc.long_value = d;
 920     array-&gt;append(new ConstantIntValue(acc.words[1]));
 921     array-&gt;append(new ConstantIntValue(acc.words[0]));
 922 #endif
 923       break;
 924     }
 925     case Type::Top:               // Add an illegal value here
 926       array-&gt;append(new LocationValue(Location()));
 927       break;
 928     default:
 929       ShouldNotReachHere();
 930       break;
 931   }
 932 }
 933 
 934 // Determine if this node starts a bundle
<span class="line-modified"> 935 bool PhaseOutput::starts_bundle(const Node *n) const {</span>
 936   return (_node_bundling_limit &gt; n-&gt;_idx &amp;&amp;
 937           _node_bundling_base[n-&gt;_idx].starts_bundle());
 938 }
 939 
 940 //--------------------------Process_OopMap_Node--------------------------------
<span class="line-modified"> 941 void PhaseOutput::Process_OopMap_Node(MachNode *mach, int current_offset) {</span>

 942   // Handle special safepoint nodes for synchronization
 943   MachSafePointNode *sfn   = mach-&gt;as_MachSafePoint();
 944   MachCallNode      *mcall;
 945 
 946   int safepoint_pc_offset = current_offset;
 947   bool is_method_handle_invoke = false;
 948   bool return_oop = false;
 949 
 950   // Add the safepoint in the DebugInfoRecorder
 951   if( !mach-&gt;is_MachCall() ) {
 952     mcall = NULL;
<span class="line-modified"> 953     C-&gt;debug_info()-&gt;add_safepoint(safepoint_pc_offset, sfn-&gt;_oop_map);</span>
 954   } else {
 955     mcall = mach-&gt;as_MachCall();
 956 
 957     // Is the call a MethodHandle call?
 958     if (mcall-&gt;is_MachCallJava()) {
 959       if (mcall-&gt;as_MachCallJava()-&gt;_method_handle_invoke) {
<span class="line-modified"> 960         assert(C-&gt;has_method_handle_invokes(), &quot;must have been set during call generation&quot;);</span>
 961         is_method_handle_invoke = true;
 962       }
 963     }
 964 
 965     // Check if a call returns an object.
 966     if (mcall-&gt;returns_pointer()) {
 967       return_oop = true;
 968     }
 969     safepoint_pc_offset += mcall-&gt;ret_addr_offset();
<span class="line-modified"> 970     C-&gt;debug_info()-&gt;add_safepoint(safepoint_pc_offset, mcall-&gt;_oop_map);</span>
 971   }
 972 
 973   // Loop over the JVMState list to add scope information
 974   // Do not skip safepoints with a NULL method, they need monitor info
 975   JVMState* youngest_jvms = sfn-&gt;jvms();
 976   int max_depth = youngest_jvms-&gt;depth();
 977 
 978   // Allocate the object pool for scalar-replaced objects -- the map from
 979   // small-integer keys (which can be recorded in the local and ostack
 980   // arrays) to descriptions of the object state.
 981   GrowableArray&lt;ScopeValue*&gt; *objs = new GrowableArray&lt;ScopeValue*&gt;();
 982 
 983   // Visit scopes from oldest to youngest.
 984   for (int depth = 1; depth &lt;= max_depth; depth++) {
 985     JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
 986     int idx;
 987     ciMethod* method = jvms-&gt;has_method() ? jvms-&gt;method() : NULL;
 988     // Safepoints that do not have method() set only provide oop-map and monitor info
 989     // to support GC; these do not support deoptimization.
 990     int num_locs = (method == NULL) ? 0 : jvms-&gt;loc_size();
</pre>
<hr />
<pre>
1012             !method-&gt;is_synchronized() ||
1013             method-&gt;is_native() ||
1014             num_mon &gt; 0 ||
1015             !GenerateSynchronizationCode,
1016             &quot;monitors must always exist for synchronized methods&quot;);
1017 
1018     // Build the growable array of ScopeValues for exp stack
1019     GrowableArray&lt;MonitorValue*&gt; *monarray = new GrowableArray&lt;MonitorValue*&gt;(num_mon);
1020 
1021     // Loop over monitors and insert into array
1022     for (idx = 0; idx &lt; num_mon; idx++) {
1023       // Grab the node that defines this monitor
1024       Node* box_node = sfn-&gt;monitor_box(jvms, idx);
1025       Node* obj_node = sfn-&gt;monitor_obj(jvms, idx);
1026 
1027       // Create ScopeValue for object
1028       ScopeValue *scval = NULL;
1029 
1030       if (obj_node-&gt;is_SafePointScalarObject()) {
1031         SafePointScalarObjectNode* spobj = obj_node-&gt;as_SafePointScalarObject();
<span class="line-modified">1032         scval = PhaseOutput::sv_for_node_id(objs, spobj-&gt;_idx);</span>
1033         if (scval == NULL) {
1034           const Type *t = spobj-&gt;bottom_type();
1035           ciKlass* cik = t-&gt;is_oopptr()-&gt;klass();
1036           assert(cik-&gt;is_instance_klass() ||
1037                  cik-&gt;is_array_klass(), &quot;Not supported allocation.&quot;);
1038           ObjectValue* sv = new ObjectValue(spobj-&gt;_idx,
1039                                             new ConstantOopWriteValue(cik-&gt;java_mirror()-&gt;constant_encoding()));
<span class="line-modified">1040           PhaseOutput::set_sv_for_object_node(objs, sv);</span>
1041 
1042           uint first_ind = spobj-&gt;first_index(youngest_jvms);
1043           for (uint i = 0; i &lt; spobj-&gt;n_fields(); i++) {
1044             Node* fld_node = sfn-&gt;in(first_ind+i);
1045             (void)FillLocArray(sv-&gt;field_values()-&gt;length(), sfn, fld_node, sv-&gt;field_values(), objs);
1046           }
1047           scval = sv;
1048         }
1049       } else if (!obj_node-&gt;is_Con()) {
<span class="line-modified">1050         OptoReg::Name obj_reg = C-&gt;regalloc()-&gt;get_reg_first(obj_node);</span>
1051         if( obj_node-&gt;bottom_type()-&gt;base() == Type::NarrowOop ) {
<span class="line-modified">1052           scval = new_loc_value( C-&gt;regalloc(), obj_reg, Location::narrowoop );</span>
1053         } else {
<span class="line-modified">1054           scval = new_loc_value( C-&gt;regalloc(), obj_reg, Location::oop );</span>
1055         }
1056       } else {
1057         const TypePtr *tp = obj_node-&gt;get_ptr_type();
1058         scval = new ConstantOopWriteValue(tp-&gt;is_oopptr()-&gt;const_oop()-&gt;constant_encoding());
1059       }
1060 
1061       OptoReg::Name box_reg = BoxLockNode::reg(box_node);
<span class="line-modified">1062       Location basic_lock = Location::new_stk_loc(Location::normal,C-&gt;regalloc()-&gt;reg2offset(box_reg));</span>
1063       bool eliminated = (box_node-&gt;is_BoxLock() &amp;&amp; box_node-&gt;as_BoxLock()-&gt;is_eliminated());
1064       monarray-&gt;append(new MonitorValue(scval, basic_lock, eliminated));
1065     }
1066 
1067     // We dump the object pool first, since deoptimization reads it in first.
<span class="line-modified">1068     C-&gt;debug_info()-&gt;dump_object_pool(objs);</span>
1069 
1070     // Build first class objects to pass to scope
<span class="line-modified">1071     DebugToken *locvals = C-&gt;debug_info()-&gt;create_scope_values(locarray);</span>
<span class="line-modified">1072     DebugToken *expvals = C-&gt;debug_info()-&gt;create_scope_values(exparray);</span>
<span class="line-modified">1073     DebugToken *monvals = C-&gt;debug_info()-&gt;create_monitor_values(monarray);</span>
1074 
1075     // Make method available for all Safepoints
<span class="line-modified">1076     ciMethod* scope_method = method ? method : C-&gt;method();</span>
1077     // Describe the scope here
1078     assert(jvms-&gt;bci() &gt;= InvocationEntryBci &amp;&amp; jvms-&gt;bci() &lt;= 0x10000, &quot;must be a valid or entry BCI&quot;);
1079     assert(!jvms-&gt;should_reexecute() || depth == max_depth, &quot;reexecute allowed only for the youngest&quot;);
1080     // Now we can describe the scope.
1081     methodHandle null_mh;
1082     bool rethrow_exception = false;
<span class="line-modified">1083     C-&gt;debug_info()-&gt;describe_scope(safepoint_pc_offset, null_mh, scope_method, jvms-&gt;bci(), jvms-&gt;should_reexecute(), rethrow_exception, is_method_handle_invoke, return_oop, locvals, expvals, monvals);</span>
1084   } // End jvms loop
1085 
1086   // Mark the end of the scope set.
<span class="line-modified">1087   C-&gt;debug_info()-&gt;end_safepoint(safepoint_pc_offset);</span>
1088 }
1089 
1090 
1091 
1092 // A simplified version of Process_OopMap_Node, to handle non-safepoints.
1093 class NonSafepointEmitter {
1094     Compile*  C;
1095     JVMState* _pending_jvms;
1096     int       _pending_offset;
1097 
1098     void emit_non_safepoint();
1099 
1100  public:
1101     NonSafepointEmitter(Compile* compile) {
1102       this-&gt;C = compile;
1103       _pending_jvms = NULL;
1104       _pending_offset = 0;
1105     }
1106 
1107     void observe_instruction(Node* n, int pc_offset) {
</pre>
<hr />
<pre>
1155   DebugInformationRecorder* debug_info = C-&gt;debug_info();
1156   assert(debug_info-&gt;recording_non_safepoints(), &quot;sanity&quot;);
1157 
1158   debug_info-&gt;add_non_safepoint(pc_offset);
1159   int max_depth = youngest_jvms-&gt;depth();
1160 
1161   // Visit scopes from oldest to youngest.
1162   for (int depth = 1; depth &lt;= max_depth; depth++) {
1163     JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
1164     ciMethod* method = jvms-&gt;has_method() ? jvms-&gt;method() : NULL;
1165     assert(!jvms-&gt;should_reexecute() || depth==max_depth, &quot;reexecute allowed only for the youngest&quot;);
1166     methodHandle null_mh;
1167     debug_info-&gt;describe_scope(pc_offset, null_mh, method, jvms-&gt;bci(), jvms-&gt;should_reexecute());
1168   }
1169 
1170   // Mark the end of the scope set.
1171   debug_info-&gt;end_non_safepoint(pc_offset);
1172 }
1173 
1174 //------------------------------init_buffer------------------------------------
<span class="line-modified">1175 void PhaseOutput::estimate_buffer_size(int&amp; const_req) {</span>
1176 
1177   // Set the initially allocated size
1178   const_req = initial_const_capacity;
1179 
1180   // The extra spacing after the code is necessary on some platforms.
1181   // Sometimes we need to patch in a jump after the last instruction,
1182   // if the nmethod has been deoptimized.  (See 4932387, 4894843.)
1183 
1184   // Compute the byte offset where we can store the deopt pc.
<span class="line-modified">1185   if (C-&gt;fixed_slots() != 0) {</span>
<span class="line-modified">1186     _orig_pc_slot_offset_in_bytes = C-&gt;regalloc()-&gt;reg2offset(OptoReg::stack2reg(_orig_pc_slot));</span>
1187   }
1188 
1189   // Compute prolog code size
1190   _method_size = 0;
<span class="line-modified">1191   _frame_slots = OptoReg::reg2stack(C-&gt;matcher()-&gt;_old_SP) + C-&gt;regalloc()-&gt;_framesize;</span>
1192 #if defined(IA64) &amp;&amp; !defined(AIX)
1193   if (save_argument_registers()) {
1194     // 4815101: this is a stub with implicit and unknown precision fp args.
1195     // The usual spill mechanism can only generate stfd&#39;s in this case, which
1196     // doesn&#39;t work if the fp reg to spill contains a single-precision denorm.
1197     // Instead, we hack around the normal spill mechanism using stfspill&#39;s and
1198     // ldffill&#39;s in the MachProlog and MachEpilog emit methods.  We allocate
1199     // space here for the fp arg regs (f8-f15) we&#39;re going to thusly spill.
1200     //
1201     // If we ever implement 16-byte &#39;registers&#39; == stack slots, we can
1202     // get rid of this hack and have SpillCopy generate stfspill/ldffill
1203     // instead of stfd/stfs/ldfd/ldfs.
1204     _frame_slots += 8*(16/BytesPerInt);
1205   }
1206 #endif
1207   assert(_frame_slots &gt;= 0 &amp;&amp; _frame_slots &lt; 1000000, &quot;sanity check&quot;);
1208 
<span class="line-modified">1209   if (C-&gt;has_mach_constant_base_node()) {</span>
1210     uint add_size = 0;
1211     // Fill the constant table.
1212     // Note:  This must happen before shorten_branches.
<span class="line-modified">1213     for (uint i = 0; i &lt; C-&gt;cfg()-&gt;number_of_blocks(); i++) {</span>
<span class="line-modified">1214       Block* b = C-&gt;cfg()-&gt;get_block(i);</span>
1215 
1216       for (uint j = 0; j &lt; b-&gt;number_of_nodes(); j++) {
1217         Node* n = b-&gt;get_node(j);
1218 
1219         // If the node is a MachConstantNode evaluate the constant
1220         // value section.
1221         if (n-&gt;is_MachConstant()) {
1222           MachConstantNode* machcon = n-&gt;as_MachConstant();
1223           machcon-&gt;eval_constant(C);
1224         } else if (n-&gt;is_Mach()) {
1225           // On Power there are more nodes that issue constants.
1226           add_size += (n-&gt;as_Mach()-&gt;ins_num_consts() * 8);
1227         }
1228       }
1229     }
1230 
1231     // Calculate the offsets of the constants and the size of the
1232     // constant table (including the padding to the next section).
1233     constant_table().calculate_offsets_and_size();
1234     const_req = constant_table().size() + add_size;
1235   }
1236 
1237   // Initialize the space for the BufferBlob used to find and verify
1238   // instruction size in MachNode::emit_size()
1239   init_scratch_buffer_blob(const_req);
1240 }
1241 
<span class="line-modified">1242 CodeBuffer* PhaseOutput::init_buffer(BufferSizingData&amp; buf_sizes) {</span>
1243 
1244   int stub_req  = buf_sizes._stub;
1245   int code_req  = buf_sizes._code;
1246   int const_req = buf_sizes._const;
1247 
1248   int pad_req   = NativeCall::instruction_size;
1249 
1250   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1251   stub_req += bs-&gt;estimate_stub_size();
1252 
1253   // nmethod and CodeBuffer count stubs &amp; constants as part of method&#39;s code.
1254   // class HandlerImpl is platform-specific and defined in the *.ad files.
1255   int exception_handler_req = HandlerImpl::size_exception_handler() + MAX_stubs_size; // add marginal slop for handler
1256   int deopt_handler_req     = HandlerImpl::size_deopt_handler()     + MAX_stubs_size; // add marginal slop for handler
1257   stub_req += MAX_stubs_size;   // ensure per-stub margin
1258   code_req += MAX_inst_size;    // ensure per-instruction margin
1259 
1260   if (StressCodeBuffers)
1261     code_req = const_req = stub_req = exception_handler_req = deopt_handler_req = 0x10;  // force expansion
1262 
1263   int total_req =
1264           const_req +
1265           code_req +
1266           pad_req +
1267           stub_req +
1268           exception_handler_req +
1269           deopt_handler_req;               // deopt handler
1270 
<span class="line-modified">1271   if (C-&gt;has_method_handle_invokes())</span>
1272     total_req += deopt_handler_req;  // deopt MH handler
1273 
1274   CodeBuffer* cb = code_buffer();
1275   cb-&gt;initialize(total_req, buf_sizes._reloc);
1276 
1277   // Have we run out of code space?
1278   if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1279     C-&gt;record_failure(&quot;CodeCache is full&quot;);
1280     return NULL;
1281   }
1282   // Configure the code buffer.
1283   cb-&gt;initialize_consts_size(const_req);
1284   cb-&gt;initialize_stubs_size(stub_req);
<span class="line-modified">1285   cb-&gt;initialize_oop_recorder(C-&gt;env()-&gt;oop_recorder());</span>
1286 
1287   // fill in the nop array for bundling computations
1288   MachNode *_nop_list[Bundle::_nop_count];
1289   Bundle::initialize_nops(_nop_list);
1290 
1291   return cb;
1292 }
1293 
1294 //------------------------------fill_buffer------------------------------------
<span class="line-modified">1295 void PhaseOutput::fill_buffer(CodeBuffer* cb, uint* blk_starts) {</span>
1296   // blk_starts[] contains offsets calculated during short branches processing,
1297   // offsets should not be increased during following steps.
1298 
1299   // Compute the size of first NumberOfLoopInstrToAlign instructions at head
1300   // of a loop. It is used to determine the padding for loop alignment.
1301   compute_loop_first_inst_sizes();
1302 
1303   // Create oopmap set.
1304   _oop_map_set = new OopMapSet();
1305 
1306   // !!!!! This preserves old handling of oopmaps for now
<span class="line-modified">1307   C-&gt;debug_info()-&gt;set_oopmaps(_oop_map_set);</span>
1308 
<span class="line-modified">1309   uint nblocks  = C-&gt;cfg()-&gt;number_of_blocks();</span>
1310   // Count and start of implicit null check instructions
1311   uint inct_cnt = 0;
1312   uint *inct_starts = NEW_RESOURCE_ARRAY(uint, nblocks+1);
1313 
1314   // Count and start of calls
1315   uint *call_returns = NEW_RESOURCE_ARRAY(uint, nblocks+1);
1316 
1317   uint  return_offset = 0;
<span class="line-modified">1318   int nop_size = (new MachNopNode())-&gt;size(C-&gt;regalloc());</span>
1319 
1320   int previous_offset = 0;
1321   int current_offset  = 0;
1322   int last_call_offset = -1;
1323   int last_avoid_back_to_back_offset = -1;
1324 #ifdef ASSERT
1325   uint* jmp_target = NEW_RESOURCE_ARRAY(uint,nblocks);
1326   uint* jmp_offset = NEW_RESOURCE_ARRAY(uint,nblocks);
1327   uint* jmp_size   = NEW_RESOURCE_ARRAY(uint,nblocks);
1328   uint* jmp_rule   = NEW_RESOURCE_ARRAY(uint,nblocks);
1329 #endif
1330 
1331   // Create an array of unused labels, one for each basic block, if printing is enabled
1332 #if defined(SUPPORT_OPTO_ASSEMBLY)
1333   int *node_offsets      = NULL;
<span class="line-modified">1334   uint node_offset_limit = C-&gt;unique();</span>
1335 
<span class="line-modified">1336   if (C-&gt;print_assembly()) {</span>
1337     node_offsets = NEW_RESOURCE_ARRAY(int, node_offset_limit);
1338   }
1339   if (node_offsets != NULL) {
1340     // We need to initialize. Unused array elements may contain garbage and mess up PrintOptoAssembly.
1341     memset(node_offsets, 0, node_offset_limit*sizeof(int));
1342   }
1343 #endif
1344 
<span class="line-modified">1345   NonSafepointEmitter non_safepoints(C);  // emit non-safepoints lazily</span>
1346 
1347   // Emit the constant table.
<span class="line-modified">1348   if (C-&gt;has_mach_constant_base_node()) {</span>
1349     constant_table().emit(*cb);
1350   }
1351 
1352   // Create an array of labels, one for each basic block
1353   Label *blk_labels = NEW_RESOURCE_ARRAY(Label, nblocks+1);
1354   for (uint i=0; i &lt;= nblocks; i++) {
1355     blk_labels[i].init();
1356   }
1357 
1358   // ------------------
1359   // Now fill in the code buffer
1360   Node *delay_slot = NULL;
1361 
1362   for (uint i = 0; i &lt; nblocks; i++) {
<span class="line-modified">1363     Block* block = C-&gt;cfg()-&gt;get_block(i);</span>
1364     Node* head = block-&gt;head();
1365 
1366     // If this block needs to start aligned (i.e, can be reached other
1367     // than by falling-thru from the previous block), then force the
1368     // start of a new bundle.
1369     if (Pipeline::requires_bundling() &amp;&amp; starts_bundle(head)) {
1370       cb-&gt;flush_bundle(true);
1371     }
1372 
1373 #ifdef ASSERT
1374     if (!block-&gt;is_connector()) {
1375       stringStream st;
<span class="line-modified">1376       block-&gt;dump_head(C-&gt;cfg(), &amp;st);</span>
1377       MacroAssembler(cb).block_comment(st.as_string());
1378     }
1379     jmp_target[i] = 0;
1380     jmp_offset[i] = 0;
1381     jmp_size[i]   = 0;
1382     jmp_rule[i]   = 0;
1383 #endif
1384     int blk_offset = current_offset;
1385 
1386     // Define the label at the beginning of the basic block
1387     MacroAssembler(cb).bind(blk_labels[block-&gt;_pre_order]);
1388 
1389     uint last_inst = block-&gt;number_of_nodes();
1390 
1391     // Emit block normally, except for last instruction.
1392     // Emit means &quot;dump code bits into code buffer&quot;.
1393     for (uint j = 0; j&lt;last_inst; j++) {
1394 
1395       // Get the node
1396       Node* n = block-&gt;get_node(j);
1397 
1398       // See if delay slots are supported
<span class="line-modified">1399       if (valid_bundle_info(n) &amp;&amp; node_bundling(n)-&gt;used_in_unconditional_delay()) {</span>

1400         assert(delay_slot == NULL, &quot;no use of delay slot node&quot;);
<span class="line-modified">1401         assert(n-&gt;size(C-&gt;regalloc()) == Pipeline::instr_unit_size(), &quot;delay slot instruction wrong size&quot;);</span>
1402 
1403         delay_slot = n;
1404         continue;
1405       }
1406 
1407       // If this starts a new instruction group, then flush the current one
1408       // (but allow split bundles)
1409       if (Pipeline::requires_bundling() &amp;&amp; starts_bundle(n))
1410         cb-&gt;flush_bundle(false);
1411 
1412       // Special handling for SafePoint/Call Nodes
1413       bool is_mcall = false;
1414       if (n-&gt;is_Mach()) {
1415         MachNode *mach = n-&gt;as_Mach();
1416         is_mcall = n-&gt;is_MachCall();
1417         bool is_sfn = n-&gt;is_MachSafePoint();
1418 
1419         // If this requires all previous instructions be flushed, then do so
1420         if (is_sfn || is_mcall || mach-&gt;alignment_required() != 1) {
1421           cb-&gt;flush_bundle(true);
1422           current_offset = cb-&gt;insts_size();
1423         }
1424 
1425         // A padding may be needed again since a previous instruction
1426         // could be moved to delay slot.
1427 
1428         // align the instruction if necessary
1429         int padding = mach-&gt;compute_padding(current_offset);
1430         // Make sure safepoint node for polling is distinct from a call&#39;s
1431         // return by adding a nop if needed.
1432         if (is_sfn &amp;&amp; !is_mcall &amp;&amp; padding == 0 &amp;&amp; current_offset == last_call_offset) {
1433           padding = nop_size;
1434         }
1435         if (padding == 0 &amp;&amp; mach-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE) &amp;&amp;
1436             current_offset == last_avoid_back_to_back_offset) {
1437           // Avoid back to back some instructions.
1438           padding = nop_size;
1439         }
<span class="line-added">1440 #ifdef X86</span>
<span class="line-added">1441         if (mach-&gt;flags() &amp; Node::Flag_intel_jcc_erratum) {</span>
<span class="line-added">1442           assert(padding == 0, &quot;can&#39;t have contradicting padding requirements&quot;);</span>
<span class="line-added">1443           padding = IntelJccErratum::compute_padding(current_offset, mach, block, j, C-&gt;regalloc());</span>
<span class="line-added">1444         }</span>
<span class="line-added">1445 #endif</span>
1446 
1447         if (padding &gt; 0) {
1448           assert((padding % nop_size) == 0, &quot;padding is not a multiple of NOP size&quot;);
1449           int nops_cnt = padding / nop_size;
1450           MachNode *nop = new MachNopNode(nops_cnt);
1451           block-&gt;insert_node(nop, j++);
1452           last_inst++;
<span class="line-modified">1453           C-&gt;cfg()-&gt;map_node_to_block(nop, block);</span>
1454           // Ensure enough space.
1455           cb-&gt;insts()-&gt;maybe_expand_to_ensure_remaining(MAX_inst_size);
1456           if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1457             C-&gt;record_failure(&quot;CodeCache is full&quot;);
1458             return;
1459           }
<span class="line-modified">1460           nop-&gt;emit(*cb, C-&gt;regalloc());</span>
1461           cb-&gt;flush_bundle(true);
1462           current_offset = cb-&gt;insts_size();
1463         }
1464 
1465         // Remember the start of the last call in a basic block
1466         if (is_mcall) {
1467           MachCallNode *mcall = mach-&gt;as_MachCall();
1468 
1469           // This destination address is NOT PC-relative
1470           mcall-&gt;method_set((intptr_t)mcall-&gt;entry_point());
1471 
1472           // Save the return address
1473           call_returns[block-&gt;_pre_order] = current_offset + mcall-&gt;ret_addr_offset();
1474 
1475           if (mcall-&gt;is_MachCallLeaf()) {
1476             is_mcall = false;
1477             is_sfn = false;
1478           }
1479         }
1480 
</pre>
<hr />
<pre>
1493 
1494           non_safepoints.observe_safepoint(mach-&gt;as_MachSafePoint()-&gt;jvms(),
1495                                            current_offset);
1496           Process_OopMap_Node(mach, current_offset);
1497         } // End if safepoint
1498 
1499           // If this is a null check, then add the start of the previous instruction to the list
1500         else if( mach-&gt;is_MachNullCheck() ) {
1501           inct_starts[inct_cnt++] = previous_offset;
1502         }
1503 
1504           // If this is a branch, then fill in the label with the target BB&#39;s label
1505         else if (mach-&gt;is_MachBranch()) {
1506           // This requires the TRUE branch target be in succs[0]
1507           uint block_num = block-&gt;non_connector_successor(0)-&gt;_pre_order;
1508 
1509           // Try to replace long branch if delay slot is not used,
1510           // it is mostly for back branches since forward branch&#39;s
1511           // distance is not updated yet.
1512           bool delay_slot_is_used = valid_bundle_info(n) &amp;&amp;
<span class="line-modified">1513                                     C-&gt;output()-&gt;node_bundling(n)-&gt;use_unconditional_delay();</span>
1514           if (!delay_slot_is_used &amp;&amp; mach-&gt;may_be_short_branch()) {
1515             assert(delay_slot == NULL, &quot;not expecting delay slot node&quot;);
<span class="line-modified">1516             int br_size = n-&gt;size(C-&gt;regalloc());</span>
1517             int offset = blk_starts[block_num] - current_offset;
1518             if (block_num &gt;= i) {
1519               // Current and following block&#39;s offset are not
1520               // finalized yet, adjust distance by the difference
1521               // between calculated and final offsets of current block.
1522               offset -= (blk_starts[i] - blk_offset);
1523             }
1524             // In the following code a nop could be inserted before
1525             // the branch which will increase the backward distance.
1526             bool needs_padding = (current_offset == last_avoid_back_to_back_offset);
1527             if (needs_padding &amp;&amp; offset &lt;= 0)
1528               offset -= nop_size;
1529 
<span class="line-modified">1530             if (C-&gt;matcher()-&gt;is_short_branch_offset(mach-&gt;rule(), br_size, offset)) {</span>
1531               // We&#39;ve got a winner.  Replace this branch.
1532               MachNode* replacement = mach-&gt;as_MachBranch()-&gt;short_branch_version();
1533 
1534               // Update the jmp_size.
<span class="line-modified">1535               int new_size = replacement-&gt;size(C-&gt;regalloc());</span>
1536               assert((br_size - new_size) &gt;= (int)nop_size, &quot;short_branch size should be smaller&quot;);
1537               // Insert padding between avoid_back_to_back branches.
1538               if (needs_padding &amp;&amp; replacement-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
1539                 MachNode *nop = new MachNopNode();
1540                 block-&gt;insert_node(nop, j++);
<span class="line-modified">1541                 C-&gt;cfg()-&gt;map_node_to_block(nop, block);</span>
1542                 last_inst++;
<span class="line-modified">1543                 nop-&gt;emit(*cb, C-&gt;regalloc());</span>
1544                 cb-&gt;flush_bundle(true);
1545                 current_offset = cb-&gt;insts_size();
1546               }
1547 #ifdef ASSERT
1548               jmp_target[i] = block_num;
1549               jmp_offset[i] = current_offset - blk_offset;
1550               jmp_size[i]   = new_size;
1551               jmp_rule[i]   = mach-&gt;rule();
1552 #endif
1553               block-&gt;map_node(replacement, j);
1554               mach-&gt;subsume_by(replacement, C);
1555               n    = replacement;
1556               mach = replacement;
1557             }
1558           }
1559           mach-&gt;as_MachBranch()-&gt;label_set( &amp;blk_labels[block_num], block_num );
1560         } else if (mach-&gt;ideal_Opcode() == Op_Jump) {
1561           for (uint h = 0; h &lt; block-&gt;_num_succs; h++) {
1562             Block* succs_block = block-&gt;_succs[h];
1563             for (uint j = 1; j &lt; succs_block-&gt;num_preds(); j++) {
</pre>
<hr />
<pre>
1605           inct_starts[inct_cnt++] = current_offset;
1606         }
1607       }
1608 
1609       // Verify that there is sufficient space remaining
1610       cb-&gt;insts()-&gt;maybe_expand_to_ensure_remaining(MAX_inst_size);
1611       if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1612         C-&gt;record_failure(&quot;CodeCache is full&quot;);
1613         return;
1614       }
1615 
1616       // Save the offset for the listing
1617 #if defined(SUPPORT_OPTO_ASSEMBLY)
1618       if ((node_offsets != NULL) &amp;&amp; (n-&gt;_idx &lt; node_offset_limit)) {
1619         node_offsets[n-&gt;_idx] = cb-&gt;insts_size();
1620       }
1621 #endif
1622 
1623       // &quot;Normal&quot; instruction case
1624       DEBUG_ONLY( uint instr_offset = cb-&gt;insts_size(); )
<span class="line-modified">1625       n-&gt;emit(*cb, C-&gt;regalloc());</span>
1626       current_offset  = cb-&gt;insts_size();
1627 
1628       // Above we only verified that there is enough space in the instruction section.
1629       // However, the instruction may emit stubs that cause code buffer expansion.
1630       // Bail out here if expansion failed due to a lack of code cache space.
<span class="line-modified">1631       if (C-&gt;failing()) {</span>
1632         return;
1633       }
1634 
1635 #ifdef ASSERT
<span class="line-modified">1636       if (n-&gt;size(C-&gt;regalloc()) &lt; (current_offset-instr_offset)) {</span>
1637         n-&gt;dump();
1638         assert(false, &quot;wrong size of mach node&quot;);
1639       }
1640 #endif
1641       non_safepoints.observe_instruction(n, current_offset);
1642 
1643       // mcall is last &quot;call&quot; that can be a safepoint
1644       // record it so we can see if a poll will directly follow it
1645       // in which case we&#39;ll need a pad to make the PcDesc sites unique
1646       // see  5010568. This can be slightly inaccurate but conservative
1647       // in the case that return address is not actually at current_offset.
1648       // This is a small price to pay.
1649 
1650       if (is_mcall) {
1651         last_call_offset = current_offset;
1652       }
1653 
1654       if (n-&gt;is_Mach() &amp;&amp; n-&gt;as_Mach()-&gt;avoid_back_to_back(MachNode::AVOID_AFTER)) {
1655         // Avoid back to back some instructions.
1656         last_avoid_back_to_back_offset = current_offset;
</pre>
<hr />
<pre>
1671 #endif
1672 
1673         // Support a SafePoint in the delay slot
1674         if (delay_slot-&gt;is_MachSafePoint()) {
1675           MachNode *mach = delay_slot-&gt;as_Mach();
1676           // !!!!! Stubs only need an oopmap right now, so bail out
1677           if (!mach-&gt;is_MachCall() &amp;&amp; mach-&gt;as_MachSafePoint()-&gt;jvms()-&gt;method() == NULL) {
1678             // Write the oopmap directly to the code blob??!!
1679             delay_slot = NULL;
1680             continue;
1681           }
1682 
1683           int adjusted_offset = current_offset - Pipeline::instr_unit_size();
1684           non_safepoints.observe_safepoint(mach-&gt;as_MachSafePoint()-&gt;jvms(),
1685                                            adjusted_offset);
1686           // Generate an OopMap entry
1687           Process_OopMap_Node(mach, adjusted_offset);
1688         }
1689 
1690         // Insert the delay slot instruction
<span class="line-modified">1691         delay_slot-&gt;emit(*cb, C-&gt;regalloc());</span>
1692 
1693         // Don&#39;t reuse it
1694         delay_slot = NULL;
1695       }
1696 
1697     } // End for all instructions in block
1698 
1699     // If the next block is the top of a loop, pad this block out to align
1700     // the loop top a little. Helps prevent pipe stalls at loop back branches.
1701     if (i &lt; nblocks-1) {
<span class="line-modified">1702       Block *nb = C-&gt;cfg()-&gt;get_block(i + 1);</span>
1703       int padding = nb-&gt;alignment_padding(current_offset);
1704       if( padding &gt; 0 ) {
1705         MachNode *nop = new MachNopNode(padding / nop_size);
1706         block-&gt;insert_node(nop, block-&gt;number_of_nodes());
<span class="line-modified">1707         C-&gt;cfg()-&gt;map_node_to_block(nop, block);</span>
<span class="line-modified">1708         nop-&gt;emit(*cb, C-&gt;regalloc());</span>
1709         current_offset = cb-&gt;insts_size();
1710       }
1711     }
1712     // Verify that the distance for generated before forward
1713     // short branches is still valid.
1714     guarantee((int)(blk_starts[i+1] - blk_starts[i]) &gt;= (current_offset - blk_offset), &quot;shouldn&#39;t increase block size&quot;);
1715 
1716     // Save new block start offset
1717     blk_starts[i] = blk_offset;
1718   } // End of for all blocks
1719   blk_starts[nblocks] = current_offset;
1720 
1721   non_safepoints.flush_at_end();
1722 
1723   // Offset too large?
<span class="line-modified">1724   if (C-&gt;failing())  return;</span>
1725 
1726   // Define a pseudo-label at the end of the code
1727   MacroAssembler(cb).bind( blk_labels[nblocks] );
1728 
1729   // Compute the size of the first block
1730   _first_block_size = blk_labels[1].loc_pos() - blk_labels[0].loc_pos();
1731 
1732 #ifdef ASSERT
1733   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
1734     if (jmp_target[i] != 0) {
1735       int br_size = jmp_size[i];
1736       int offset = blk_starts[jmp_target[i]]-(blk_starts[i] + jmp_offset[i]);
<span class="line-modified">1737       if (!C-&gt;matcher()-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset)) {</span>
1738         tty-&gt;print_cr(&quot;target (%d) - jmp_offset(%d) = offset (%d), jump_size(%d), jmp_block B%d, target_block B%d&quot;, blk_starts[jmp_target[i]], blk_starts[i] + jmp_offset[i], offset, br_size, i, jmp_target[i]);
1739         assert(false, &quot;Displacement too large for short jmp&quot;);
1740       }
1741     }
1742   }
1743 #endif
1744 
1745   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1746   bs-&gt;emit_stubs(*cb);
<span class="line-modified">1747   if (C-&gt;failing())  return;</span>
1748 
1749 #ifndef PRODUCT
1750   // Information on the size of the method, without the extraneous code
1751   Scheduling::increment_method_size(cb-&gt;insts_size());
1752 #endif
1753 
1754   // ------------------
1755   // Fill in exception table entries.
1756   FillExceptionTables(inct_cnt, call_returns, inct_starts, blk_labels);
1757 
1758   // Only java methods have exception handlers and deopt handlers
1759   // class HandlerImpl is platform-specific and defined in the *.ad files.
<span class="line-modified">1760   if (C-&gt;method()) {</span>
1761     // Emit the exception handler code.
1762     _code_offsets.set_value(CodeOffsets::Exceptions, HandlerImpl::emit_exception_handler(*cb));
<span class="line-modified">1763     if (C-&gt;failing()) {</span>
1764       return; // CodeBuffer::expand failed
1765     }
1766     // Emit the deopt handler code.
1767     _code_offsets.set_value(CodeOffsets::Deopt, HandlerImpl::emit_deopt_handler(*cb));
1768 
1769     // Emit the MethodHandle deopt handler code (if required).
<span class="line-modified">1770     if (C-&gt;has_method_handle_invokes() &amp;&amp; !C-&gt;failing()) {</span>
1771       // We can use the same code as for the normal deopt handler, we
1772       // just need a different entry point address.
1773       _code_offsets.set_value(CodeOffsets::DeoptMH, HandlerImpl::emit_deopt_handler(*cb));
1774     }
1775   }
1776 
1777   // One last check for failed CodeBuffer::expand:
1778   if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1779     C-&gt;record_failure(&quot;CodeCache is full&quot;);
1780     return;
1781   }
1782 
1783 #if defined(SUPPORT_ABSTRACT_ASSEMBLY) || defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_OPTO_ASSEMBLY)
<span class="line-modified">1784   if (C-&gt;print_assembly()) {</span>
1785     tty-&gt;cr();
1786     tty-&gt;print_cr(&quot;============================= C2-compiled nmethod ==============================&quot;);
1787   }
1788 #endif
1789 
1790 #if defined(SUPPORT_OPTO_ASSEMBLY)
1791   // Dump the assembly code, including basic-block numbers
<span class="line-modified">1792   if (C-&gt;print_assembly()) {</span>
1793     ttyLocker ttyl;  // keep the following output all in one block
1794     if (!VMThread::should_terminate()) {  // test this under the tty lock
1795       // This output goes directly to the tty, not the compiler log.
1796       // To enable tools to match it up with the compilation activity,
1797       // be sure to tag this tty output with the compile ID.
1798       if (xtty != NULL) {
<span class="line-modified">1799         xtty-&gt;head(&quot;opto_assembly compile_id=&#39;%d&#39;%s&quot;, C-&gt;compile_id(),</span>
<span class="line-modified">1800                    C-&gt;is_osr_compilation()    ? &quot; compile_kind=&#39;osr&#39;&quot; :</span>
1801                    &quot;&quot;);
1802       }
<span class="line-modified">1803       if (C-&gt;method() != NULL) {</span>
<span class="line-modified">1804         tty-&gt;print_cr(&quot;----------------------- MetaData before Compile_id = %d ------------------------&quot;, C-&gt;compile_id());</span>
<span class="line-modified">1805         C-&gt;method()-&gt;print_metadata();</span>
<span class="line-modified">1806       } else if (C-&gt;stub_name() != NULL) {</span>
<span class="line-modified">1807         tty-&gt;print_cr(&quot;----------------------------- RuntimeStub %s -------------------------------&quot;, C-&gt;stub_name());</span>
1808       }
1809       tty-&gt;cr();
<span class="line-modified">1810       tty-&gt;print_cr(&quot;------------------------ OptoAssembly for Compile_id = %d -----------------------&quot;, C-&gt;compile_id());</span>
1811       dump_asm(node_offsets, node_offset_limit);
1812       tty-&gt;print_cr(&quot;--------------------------------------------------------------------------------&quot;);
1813       if (xtty != NULL) {
1814         // print_metadata and dump_asm above may safepoint which makes us loose the ttylock.
1815         // Retake lock too make sure the end tag is coherent, and that xmlStream-&gt;pop_tag is done
1816         // thread safe
1817         ttyLocker ttyl2;
1818         xtty-&gt;tail(&quot;opto_assembly&quot;);
1819       }
1820     }
1821   }
1822 #endif
1823 }
1824 
<span class="line-modified">1825 void PhaseOutput::FillExceptionTables(uint cnt, uint *call_returns, uint *inct_starts, Label *blk_labels) {</span>
1826   _inc_table.set_size(cnt);
1827 
1828   uint inct_cnt = 0;
<span class="line-modified">1829   for (uint i = 0; i &lt; C-&gt;cfg()-&gt;number_of_blocks(); i++) {</span>
<span class="line-modified">1830     Block* block = C-&gt;cfg()-&gt;get_block(i);</span>
1831     Node *n = NULL;
1832     int j;
1833 
1834     // Find the branch; ignore trailing NOPs.
1835     for (j = block-&gt;number_of_nodes() - 1; j &gt;= 0; j--) {
1836       n = block-&gt;get_node(j);
1837       if (!n-&gt;is_Mach() || n-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Con) {
1838         break;
1839       }
1840     }
1841 
1842     // If we didn&#39;t find anything, continue
1843     if (j &lt; 0) {
1844       continue;
1845     }
1846 
1847     // Compute ExceptionHandlerTable subtable entry and add it
1848     // (skip empty blocks)
1849     if (n-&gt;is_Catch()) {
1850 
</pre>
<hr />
<pre>
1855       while (block-&gt;get_node(--j)-&gt;is_MachProj()) ;
1856       assert(block-&gt;get_node(j)-&gt;is_MachCall(), &quot;CatchProj must follow call&quot;);
1857 #endif
1858       // last instruction is a CatchNode, find it&#39;s CatchProjNodes
1859       int nof_succs = block-&gt;_num_succs;
1860       // allocate space
1861       GrowableArray&lt;intptr_t&gt; handler_bcis(nof_succs);
1862       GrowableArray&lt;intptr_t&gt; handler_pcos(nof_succs);
1863       // iterate through all successors
1864       for (int j = 0; j &lt; nof_succs; j++) {
1865         Block* s = block-&gt;_succs[j];
1866         bool found_p = false;
1867         for (uint k = 1; k &lt; s-&gt;num_preds(); k++) {
1868           Node* pk = s-&gt;pred(k);
1869           if (pk-&gt;is_CatchProj() &amp;&amp; pk-&gt;in(0) == n) {
1870             const CatchProjNode* p = pk-&gt;as_CatchProj();
1871             found_p = true;
1872             // add the corresponding handler bci &amp; pco information
1873             if (p-&gt;_con != CatchProjNode::fall_through_index) {
1874               // p leads to an exception handler (and is not fall through)
<span class="line-modified">1875               assert(s == C-&gt;cfg()-&gt;get_block(s-&gt;_pre_order), &quot;bad numbering&quot;);</span>
1876               // no duplicates, please
1877               if (!handler_bcis.contains(p-&gt;handler_bci())) {
1878                 uint block_num = s-&gt;non_connector()-&gt;_pre_order;
1879                 handler_bcis.append(p-&gt;handler_bci());
1880                 handler_pcos.append(blk_labels[block_num].loc_pos());
1881               }
1882             }
1883           }
1884         }
1885         assert(found_p, &quot;no matching predecessor found&quot;);
1886         // Note:  Due to empty block removal, one block may have
1887         // several CatchProj inputs, from the same Catch.
1888       }
1889 
1890       // Set the offset of the return from the call
1891       assert(handler_bcis.find(-1) != -1, &quot;must have default handler&quot;);
1892       _handler_table.add_subtable(call_return, &amp;handler_bcis, NULL, &amp;handler_pcos);
1893       continue;
1894     }
1895 
</pre>
<hr />
<pre>
1927           _available(arena),
1928           _reg_node(arena),
1929           _pinch_free_list(arena),
1930           _next_node(NULL),
1931           _bundle_instr_count(0),
1932           _bundle_cycle_number(0),
1933           _bundle_use(0, 0, resource_count, &amp;_bundle_use_elements[0])
1934 #ifndef PRODUCT
1935         , _branches(0)
1936         , _unconditional_delays(0)
1937 #endif
1938 {
1939   // Create a MachNopNode
1940   _nop = new MachNopNode();
1941 
1942   // Now that the nops are in the array, save the count
1943   // (but allow entries for the nops)
1944   _node_bundling_limit = compile.unique();
1945   uint node_max = _regalloc-&gt;node_regs_max_index();
1946 
<span class="line-modified">1947   compile.output()-&gt;set_node_bundling_limit(_node_bundling_limit);</span>
1948 
1949   // This one is persistent within the Compile class
1950   _node_bundling_base = NEW_ARENA_ARRAY(compile.comp_arena(), Bundle, node_max);
1951 
1952   // Allocate space for fixed-size arrays
1953   _node_latency    = NEW_ARENA_ARRAY(arena, unsigned short, node_max);
1954   _uses            = NEW_ARENA_ARRAY(arena, short,          node_max);
1955   _current_latency = NEW_ARENA_ARRAY(arena, unsigned short, node_max);
1956 
1957   // Clear the arrays
1958   for (uint i = 0; i &lt; node_max; i++) {
1959     ::new (&amp;_node_bundling_base[i]) Bundle();
1960   }
1961   memset(_node_latency,       0, node_max * sizeof(unsigned short));
1962   memset(_uses,               0, node_max * sizeof(short));
1963   memset(_current_latency,    0, node_max * sizeof(unsigned short));
1964 
1965   // Clear the bundling information
1966   memcpy(_bundle_use_elements, Pipeline_Use::elaborated_elements, sizeof(Pipeline_Use::elaborated_elements));
1967 
</pre>
<hr />
<pre>
2003 
2004   // Update the bundle record
2005   if (_bundle_instr_count &gt; 0) {
2006     bundle-&gt;set_instr_count(_bundle_instr_count);
2007     bundle-&gt;set_resources_used(_bundle_use.resourcesUsed());
2008 
2009     _bundle_cycle_number += 1;
2010   }
2011 
2012   // Clear the bundling information
2013   _bundle_instr_count = 0;
2014   _bundle_use.reset();
2015 
2016   memcpy(_bundle_use_elements,
2017          Pipeline_Use::elaborated_elements,
2018          sizeof(Pipeline_Use::elaborated_elements));
2019 }
2020 
2021 // Perform instruction scheduling and bundling over the sequence of
2022 // instructions in backwards order.
<span class="line-modified">2023 void PhaseOutput::ScheduleAndBundle() {</span>
2024 
2025   // Don&#39;t optimize this if it isn&#39;t a method
<span class="line-modified">2026   if (!C-&gt;method())</span>
2027     return;
2028 
2029   // Don&#39;t optimize this if scheduling is disabled
<span class="line-modified">2030   if (!C-&gt;do_scheduling())</span>
2031     return;
2032 
2033   // Scheduling code works only with pairs (16 bytes) maximum.
<span class="line-modified">2034   if (C-&gt;max_vector_size() &gt; 16)</span>
2035     return;
2036 
<span class="line-modified">2037   Compile::TracePhase tp(&quot;isched&quot;, &amp;timers[_t_instrSched]);</span>
2038 
2039   // Create a data structure for all the scheduling information
<span class="line-modified">2040   Scheduling scheduling(Thread::current()-&gt;resource_area(), *C);</span>
2041 
2042   // Walk backwards over each basic block, computing the needed alignment
2043   // Walk over all the basic blocks
2044   scheduling.DoScheduling();
2045 
2046 #ifndef PRODUCT
<span class="line-modified">2047   if (C-&gt;trace_opto_output()) {</span>
2048     tty-&gt;print(&quot;\n---- After ScheduleAndBundle ----\n&quot;);
<span class="line-modified">2049     for (uint i = 0; i &lt; C-&gt;cfg()-&gt;number_of_blocks(); i++) {</span>
2050       tty-&gt;print(&quot;\nBB#%03d:\n&quot;, i);
<span class="line-modified">2051       Block* block = C-&gt;cfg()-&gt;get_block(i);</span>
2052       for (uint j = 0; j &lt; block-&gt;number_of_nodes(); j++) {
2053         Node* n = block-&gt;get_node(j);
<span class="line-modified">2054         OptoReg::Name reg = C-&gt;regalloc()-&gt;get_reg_first(n);</span>
2055         tty-&gt;print(&quot; %-6s &quot;, reg &gt;= 0 &amp;&amp; reg &lt; REG_COUNT ? Matcher::regName[reg] : &quot;&quot;);
2056         n-&gt;dump();
2057       }
2058     }
2059   }
2060 #endif
2061 }
2062 
2063 // Compute the latency of all the instructions.  This is fairly simple,
2064 // because we already have a legal ordering.  Walk over the instructions
2065 // from first to last, and compute the latency of the instruction based
2066 // on the latency of the preceding instruction(s).
2067 void Scheduling::ComputeLocalLatenciesForward(const Block *bb) {
2068 #ifndef PRODUCT
2069   if (_cfg-&gt;C-&gt;trace_opto_output())
2070     tty-&gt;print(&quot;# -&gt; ComputeLocalLatenciesForward\n&quot;);
2071 #endif
2072 
2073   // Walk over all the schedulable instructions
2074   for( uint j=_bb_start; j &lt; _bb_end; j++ ) {
</pre>
<hr />
<pre>
2576 #endif
2577   }
2578 
2579 #ifndef PRODUCT
2580   if (_cfg-&gt;C-&gt;trace_opto_output())
2581     tty-&gt;print(&quot;# &lt;- ComputeUseCount\n&quot;);
2582 #endif
2583 }
2584 
2585 // This routine performs scheduling on each basic block in reverse order,
2586 // using instruction latencies and taking into account function unit
2587 // availability.
2588 void Scheduling::DoScheduling() {
2589 #ifndef PRODUCT
2590   if (_cfg-&gt;C-&gt;trace_opto_output())
2591     tty-&gt;print(&quot;# -&gt; DoScheduling\n&quot;);
2592 #endif
2593 
2594   Block *succ_bb = NULL;
2595   Block *bb;
<span class="line-added">2596   Compile* C = Compile::current();</span>
2597 
2598   // Walk over all the basic blocks in reverse order
2599   for (int i = _cfg-&gt;number_of_blocks() - 1; i &gt;= 0; succ_bb = bb, i--) {
2600     bb = _cfg-&gt;get_block(i);
2601 
2602 #ifndef PRODUCT
2603     if (_cfg-&gt;C-&gt;trace_opto_output()) {
2604       tty-&gt;print(&quot;#  Schedule BB#%03d (initial)\n&quot;, i);
2605       for (uint j = 0; j &lt; bb-&gt;number_of_nodes(); j++) {
2606         bb-&gt;get_node(j)-&gt;dump();
2607       }
2608     }
2609 #endif
2610 
2611     // On the head node, skip processing
2612     if (bb == _cfg-&gt;get_root_block()) {
2613       continue;
2614     }
2615 
2616     // Skip empty, connector blocks
</pre>
<hr />
<pre>
2664         (last-&gt;is_Mach() &amp;&amp; last-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Halt) ) {
2665       // There might be a prior call.  Skip it.
2666       while (_bb_start &lt; _bb_end &amp;&amp; bb-&gt;get_node(--_bb_end)-&gt;is_MachProj());
2667     } else if( last-&gt;is_MachNullCheck() ) {
2668       // Backup so the last null-checked memory instruction is
2669       // outside the schedulable range. Skip over the nullcheck,
2670       // projection, and the memory nodes.
2671       Node *mem = last-&gt;in(1);
2672       do {
2673         _bb_end--;
2674       } while (mem != bb-&gt;get_node(_bb_end));
2675     } else {
2676       // Set _bb_end to point after last schedulable inst.
2677       _bb_end++;
2678     }
2679 
2680     assert( _bb_start &lt;= _bb_end, &quot;inverted block ends&quot; );
2681 
2682     // Compute the register antidependencies for the basic block
2683     ComputeRegisterAntidependencies(bb);
<span class="line-modified">2684     if (C-&gt;failing())  return;  // too many D-U pinch points</span>
2685 
2686     // Compute intra-bb latencies for the nodes
2687     ComputeLocalLatenciesForward(bb);
2688 
2689     // Compute the usage within the block, and set the list of all nodes
2690     // in the block that have no uses within the block.
2691     ComputeUseCount(bb);
2692 
2693     // Schedule the remaining instructions in the block
2694     while ( _available.size() &gt; 0 ) {
2695       Node *n = ChooseNodeToBundle();
2696       guarantee(n != NULL, &quot;no nodes available&quot;);
2697       AddNodeToBundle(n,bb);
2698     }
2699 
2700     assert( _scheduled.size() == _bb_end - _bb_start, &quot;wrong number of instructions&quot; );
2701 #ifdef ASSERT
2702     for( uint l = _bb_start; l &lt; _bb_end; l++ ) {
2703       Node *n = bb-&gt;get_node(l);
2704       uint m;
</pre>
<hr />
<pre>
2724           if (bundle-&gt;instr_count() &gt; 0 || bundle-&gt;flags() &gt; 0) {
2725             tty-&gt;print(&quot;*** Bundle: &quot;);
2726             bundle-&gt;dump();
2727           }
2728           n-&gt;dump();
2729         }
2730       }
2731     }
2732 #endif
2733 #ifdef ASSERT
2734     verify_good_schedule(bb,&quot;after block local scheduling&quot;);
2735 #endif
2736   }
2737 
2738 #ifndef PRODUCT
2739   if (_cfg-&gt;C-&gt;trace_opto_output())
2740     tty-&gt;print(&quot;# &lt;- DoScheduling\n&quot;);
2741 #endif
2742 
2743   // Record final node-bundling array location
<span class="line-modified">2744   _regalloc-&gt;C-&gt;output()-&gt;set_node_bundling_base(_node_bundling_base);</span>
2745 
2746 } // end DoScheduling
2747 
2748 // Verify that no live-range used in the block is killed in the block by a
2749 // wrong DEF.  This doesn&#39;t verify live-ranges that span blocks.
2750 
2751 // Check for edge existence.  Used to avoid adding redundant precedence edges.
2752 static bool edge_from_to( Node *from, Node *to ) {
2753   for( uint i=0; i&lt;from-&gt;len(); i++ )
2754     if( from-&gt;in(i) == to )
2755       return true;
2756   return false;
2757 }
2758 
2759 #ifdef ASSERT
2760 void Scheduling::verify_do_def( Node *n, OptoReg::Name def, const char *msg ) {
2761   // Check for bad kills
2762   if( OptoReg::is_valid(def) ) { // Ignore stores &amp; control flow
2763     Node *prior_use = _reg_node[def];
2764     if( prior_use &amp;&amp; !edge_from_to(prior_use,n) ) {
</pre>
<hr />
<pre>
2831     from-&gt;add_prec(to);
2832 }
2833 
2834 void Scheduling::anti_do_def( Block *b, Node *def, OptoReg::Name def_reg, int is_def ) {
2835   if( !OptoReg::is_valid(def_reg) ) // Ignore stores &amp; control flow
2836     return;
2837 
2838   Node *pinch = _reg_node[def_reg]; // Get pinch point
2839   if ((pinch == NULL) || _cfg-&gt;get_block_for_node(pinch) != b || // No pinch-point yet?
2840       is_def ) {    // Check for a true def (not a kill)
2841     _reg_node.map(def_reg,def); // Record def/kill as the optimistic pinch-point
2842     return;
2843   }
2844 
2845   Node *kill = def;             // Rename &#39;def&#39; to more descriptive &#39;kill&#39;
2846   debug_only( def = (Node*)((intptr_t)0xdeadbeef); )
2847 
2848   // After some number of kills there _may_ be a later def
2849   Node *later_def = NULL;
2850 
<span class="line-added">2851   Compile* C = Compile::current();</span>
<span class="line-added">2852 </span>
2853   // Finding a kill requires a real pinch-point.
2854   // Check for not already having a pinch-point.
2855   // Pinch points are Op_Node&#39;s.
2856   if( pinch-&gt;Opcode() != Op_Node ) { // Or later-def/kill as pinch-point?
2857     later_def = pinch;            // Must be def/kill as optimistic pinch-point
2858     if ( _pinch_free_list.size() &gt; 0) {
2859       pinch = _pinch_free_list.pop();
2860     } else {
2861       pinch = new Node(1); // Pinch point to-be
2862     }
2863     if (pinch-&gt;_idx &gt;= _regalloc-&gt;node_regs_max_index()) {
2864       _cfg-&gt;C-&gt;record_method_not_compilable(&quot;too many D-U pinch points&quot;);
2865       return;
2866     }
2867     _cfg-&gt;map_node_to_block(pinch, b);      // Pretend it&#39;s valid in this block (lazy init)
2868     _reg_node.map(def_reg,pinch); // Record pinch-point
<span class="line-modified">2869     //regalloc()-&gt;set_bad(pinch-&gt;_idx); // Already initialized this way.</span>
2870     if( later_def-&gt;outcnt() == 0 || later_def-&gt;ideal_reg() == MachProjNode::fat_proj ) { // Distinguish def from kill
<span class="line-modified">2871       pinch-&gt;init_req(0, C-&gt;top());     // set not NULL for the next call</span>
2872       add_prec_edge_from_to(later_def,pinch); // Add edge from kill to pinch
2873       later_def = NULL;           // and no later def
2874     }
2875     pinch-&gt;set_req(0,later_def);  // Hook later def so we can find it
2876   } else {                        // Else have valid pinch point
2877     if( pinch-&gt;in(0) )            // If there is a later-def
2878       later_def = pinch-&gt;in(0);   // Get it
2879   }
2880 
2881   // Add output-dependence edge from later def to kill
2882   if( later_def )               // If there is some original def
2883     add_prec_edge_from_to(later_def,kill); // Add edge from def to kill
2884 
2885   // See if current kill is also a use, and so is forced to be the pinch-point.
2886   if( pinch-&gt;Opcode() == Op_Node ) {
2887     Node *uses = kill-&gt;is_Proj() ? kill-&gt;in(0) : kill;
2888     for( uint i=1; i&lt;uses-&gt;req(); i++ ) {
2889       if( _regalloc-&gt;get_reg_first(uses-&gt;in(i)) == def_reg ||
2890           _regalloc-&gt;get_reg_second(uses-&gt;in(i)) == def_reg ) {
2891         // Yes, found a use/kill pinch-point
</pre>
<hr />
<pre>
3154                _total_branches, _total_unconditional_delays);
3155     if (_total_branches &gt; 0)
3156       tty-&gt;print(&quot;, for %.2f%%&quot;,
3157                  ((double)_total_unconditional_delays) / ((double)_total_branches) * 100.0);
3158     tty-&gt;print(&quot;\n&quot;);
3159   }
3160 
3161   uint total_instructions = 0, total_bundles = 0;
3162 
3163   for (uint i = 1; i &lt;= Pipeline::_max_instrs_per_cycle; i++) {
3164     uint bundle_count   = _total_instructions_per_bundle[i];
3165     total_instructions += bundle_count * i;
3166     total_bundles      += bundle_count;
3167   }
3168 
3169   if (total_bundles &gt; 0)
3170     tty-&gt;print(&quot;Average ILP (excluding nops) is %.2f\n&quot;,
3171                ((double)total_instructions) / ((double)total_bundles));
3172 }
3173 #endif
<span class="line-added">3174 </span>
<span class="line-added">3175 //-----------------------init_scratch_buffer_blob------------------------------</span>
<span class="line-added">3176 // Construct a temporary BufferBlob and cache it for this compile.</span>
<span class="line-added">3177 void PhaseOutput::init_scratch_buffer_blob(int const_size) {</span>
<span class="line-added">3178   // If there is already a scratch buffer blob allocated and the</span>
<span class="line-added">3179   // constant section is big enough, use it.  Otherwise free the</span>
<span class="line-added">3180   // current and allocate a new one.</span>
<span class="line-added">3181   BufferBlob* blob = scratch_buffer_blob();</span>
<span class="line-added">3182   if ((blob != NULL) &amp;&amp; (const_size &lt;= _scratch_const_size)) {</span>
<span class="line-added">3183     // Use the current blob.</span>
<span class="line-added">3184   } else {</span>
<span class="line-added">3185     if (blob != NULL) {</span>
<span class="line-added">3186       BufferBlob::free(blob);</span>
<span class="line-added">3187     }</span>
<span class="line-added">3188 </span>
<span class="line-added">3189     ResourceMark rm;</span>
<span class="line-added">3190     _scratch_const_size = const_size;</span>
<span class="line-added">3191     int size = C2Compiler::initial_code_buffer_size(const_size);</span>
<span class="line-added">3192     blob = BufferBlob::create(&quot;Compile::scratch_buffer&quot;, size);</span>
<span class="line-added">3193     // Record the buffer blob for next time.</span>
<span class="line-added">3194     set_scratch_buffer_blob(blob);</span>
<span class="line-added">3195     // Have we run out of code space?</span>
<span class="line-added">3196     if (scratch_buffer_blob() == NULL) {</span>
<span class="line-added">3197       // Let CompilerBroker disable further compilations.</span>
<span class="line-added">3198       C-&gt;record_failure(&quot;Not enough space for scratch buffer in CodeCache&quot;);</span>
<span class="line-added">3199       return;</span>
<span class="line-added">3200     }</span>
<span class="line-added">3201   }</span>
<span class="line-added">3202 </span>
<span class="line-added">3203   // Initialize the relocation buffers</span>
<span class="line-added">3204   relocInfo* locs_buf = (relocInfo*) blob-&gt;content_end() - MAX_locs_size;</span>
<span class="line-added">3205   set_scratch_locs_memory(locs_buf);</span>
<span class="line-added">3206 }</span>
<span class="line-added">3207 </span>
<span class="line-added">3208 </span>
<span class="line-added">3209 //-----------------------scratch_emit_size-------------------------------------</span>
<span class="line-added">3210 // Helper function that computes size by emitting code</span>
<span class="line-added">3211 uint PhaseOutput::scratch_emit_size(const Node* n) {</span>
<span class="line-added">3212   // Start scratch_emit_size section.</span>
<span class="line-added">3213   set_in_scratch_emit_size(true);</span>
<span class="line-added">3214 </span>
<span class="line-added">3215   // Emit into a trash buffer and count bytes emitted.</span>
<span class="line-added">3216   // This is a pretty expensive way to compute a size,</span>
<span class="line-added">3217   // but it works well enough if seldom used.</span>
<span class="line-added">3218   // All common fixed-size instructions are given a size</span>
<span class="line-added">3219   // method by the AD file.</span>
<span class="line-added">3220   // Note that the scratch buffer blob and locs memory are</span>
<span class="line-added">3221   // allocated at the beginning of the compile task, and</span>
<span class="line-added">3222   // may be shared by several calls to scratch_emit_size.</span>
<span class="line-added">3223   // The allocation of the scratch buffer blob is particularly</span>
<span class="line-added">3224   // expensive, since it has to grab the code cache lock.</span>
<span class="line-added">3225   BufferBlob* blob = this-&gt;scratch_buffer_blob();</span>
<span class="line-added">3226   assert(blob != NULL, &quot;Initialize BufferBlob at start&quot;);</span>
<span class="line-added">3227   assert(blob-&gt;size() &gt; MAX_inst_size, &quot;sanity&quot;);</span>
<span class="line-added">3228   relocInfo* locs_buf = scratch_locs_memory();</span>
<span class="line-added">3229   address blob_begin = blob-&gt;content_begin();</span>
<span class="line-added">3230   address blob_end   = (address)locs_buf;</span>
<span class="line-added">3231   assert(blob-&gt;contains(blob_end), &quot;sanity&quot;);</span>
<span class="line-added">3232   CodeBuffer buf(blob_begin, blob_end - blob_begin);</span>
<span class="line-added">3233   buf.initialize_consts_size(_scratch_const_size);</span>
<span class="line-added">3234   buf.initialize_stubs_size(MAX_stubs_size);</span>
<span class="line-added">3235   assert(locs_buf != NULL, &quot;sanity&quot;);</span>
<span class="line-added">3236   int lsize = MAX_locs_size / 3;</span>
<span class="line-added">3237   buf.consts()-&gt;initialize_shared_locs(&amp;locs_buf[lsize * 0], lsize);</span>
<span class="line-added">3238   buf.insts()-&gt;initialize_shared_locs( &amp;locs_buf[lsize * 1], lsize);</span>
<span class="line-added">3239   buf.stubs()-&gt;initialize_shared_locs( &amp;locs_buf[lsize * 2], lsize);</span>
<span class="line-added">3240   // Mark as scratch buffer.</span>
<span class="line-added">3241   buf.consts()-&gt;set_scratch_emit();</span>
<span class="line-added">3242   buf.insts()-&gt;set_scratch_emit();</span>
<span class="line-added">3243   buf.stubs()-&gt;set_scratch_emit();</span>
<span class="line-added">3244 </span>
<span class="line-added">3245   // Do the emission.</span>
<span class="line-added">3246 </span>
<span class="line-added">3247   Label fakeL; // Fake label for branch instructions.</span>
<span class="line-added">3248   Label*   saveL = NULL;</span>
<span class="line-added">3249   uint save_bnum = 0;</span>
<span class="line-added">3250   bool is_branch = n-&gt;is_MachBranch();</span>
<span class="line-added">3251   if (is_branch) {</span>
<span class="line-added">3252     MacroAssembler masm(&amp;buf);</span>
<span class="line-added">3253     masm.bind(fakeL);</span>
<span class="line-added">3254     n-&gt;as_MachBranch()-&gt;save_label(&amp;saveL, &amp;save_bnum);</span>
<span class="line-added">3255     n-&gt;as_MachBranch()-&gt;label_set(&amp;fakeL, 0);</span>
<span class="line-added">3256   }</span>
<span class="line-added">3257   n-&gt;emit(buf, C-&gt;regalloc());</span>
<span class="line-added">3258 </span>
<span class="line-added">3259   // Emitting into the scratch buffer should not fail</span>
<span class="line-added">3260   assert (!C-&gt;failing(), &quot;Must not have pending failure. Reason is: %s&quot;, C-&gt;failure_reason());</span>
<span class="line-added">3261 </span>
<span class="line-added">3262   if (is_branch) // Restore label.</span>
<span class="line-added">3263     n-&gt;as_MachBranch()-&gt;label_set(saveL, save_bnum);</span>
<span class="line-added">3264 </span>
<span class="line-added">3265   // End scratch_emit_size section.</span>
<span class="line-added">3266   set_in_scratch_emit_size(false);</span>
<span class="line-added">3267 </span>
<span class="line-added">3268   return buf.insts_size();</span>
<span class="line-added">3269 }</span>
<span class="line-added">3270 </span>
<span class="line-added">3271 void PhaseOutput::install() {</span>
<span class="line-added">3272   if (C-&gt;stub_function() != NULL) {</span>
<span class="line-added">3273     install_stub(C-&gt;stub_name(),</span>
<span class="line-added">3274                  C-&gt;save_argument_registers());</span>
<span class="line-added">3275   } else {</span>
<span class="line-added">3276     install_code(C-&gt;method(),</span>
<span class="line-added">3277                  C-&gt;entry_bci(),</span>
<span class="line-added">3278                  CompileBroker::compiler2(),</span>
<span class="line-added">3279                  C-&gt;has_unsafe_access(),</span>
<span class="line-added">3280                  SharedRuntime::is_wide_vector(C-&gt;max_vector_size()),</span>
<span class="line-added">3281                  C-&gt;rtm_state());</span>
<span class="line-added">3282   }</span>
<span class="line-added">3283 }</span>
<span class="line-added">3284 </span>
<span class="line-added">3285 void PhaseOutput::install_code(ciMethod*         target,</span>
<span class="line-added">3286                                int               entry_bci,</span>
<span class="line-added">3287                                AbstractCompiler* compiler,</span>
<span class="line-added">3288                                bool              has_unsafe_access,</span>
<span class="line-added">3289                                bool              has_wide_vectors,</span>
<span class="line-added">3290                                RTMState          rtm_state) {</span>
<span class="line-added">3291   // Check if we want to skip execution of all compiled code.</span>
<span class="line-added">3292   {</span>
<span class="line-added">3293 #ifndef PRODUCT</span>
<span class="line-added">3294     if (OptoNoExecute) {</span>
<span class="line-added">3295       C-&gt;record_method_not_compilable(&quot;+OptoNoExecute&quot;);  // Flag as failed</span>
<span class="line-added">3296       return;</span>
<span class="line-added">3297     }</span>
<span class="line-added">3298 #endif</span>
<span class="line-added">3299     Compile::TracePhase tp(&quot;install_code&quot;, &amp;timers[_t_registerMethod]);</span>
<span class="line-added">3300 </span>
<span class="line-added">3301     if (C-&gt;is_osr_compilation()) {</span>
<span class="line-added">3302       _code_offsets.set_value(CodeOffsets::Verified_Entry, 0);</span>
<span class="line-added">3303       _code_offsets.set_value(CodeOffsets::OSR_Entry, _first_block_size);</span>
<span class="line-added">3304     } else {</span>
<span class="line-added">3305       _code_offsets.set_value(CodeOffsets::Verified_Entry, _first_block_size);</span>
<span class="line-added">3306       _code_offsets.set_value(CodeOffsets::OSR_Entry, 0);</span>
<span class="line-added">3307     }</span>
<span class="line-added">3308 </span>
<span class="line-added">3309     C-&gt;env()-&gt;register_method(target,</span>
<span class="line-added">3310                                      entry_bci,</span>
<span class="line-added">3311                                      &amp;_code_offsets,</span>
<span class="line-added">3312                                      _orig_pc_slot_offset_in_bytes,</span>
<span class="line-added">3313                                      code_buffer(),</span>
<span class="line-added">3314                                      frame_size_in_words(),</span>
<span class="line-added">3315                                      oop_map_set(),</span>
<span class="line-added">3316                                      &amp;_handler_table,</span>
<span class="line-added">3317                                      inc_table(),</span>
<span class="line-added">3318                                      compiler,</span>
<span class="line-added">3319                                      has_unsafe_access,</span>
<span class="line-added">3320                                      SharedRuntime::is_wide_vector(C-&gt;max_vector_size()),</span>
<span class="line-added">3321                                      C-&gt;rtm_state());</span>
<span class="line-added">3322 </span>
<span class="line-added">3323     if (C-&gt;log() != NULL) { // Print code cache state into compiler log</span>
<span class="line-added">3324       C-&gt;log()-&gt;code_cache_state();</span>
<span class="line-added">3325     }</span>
<span class="line-added">3326   }</span>
<span class="line-added">3327 }</span>
<span class="line-added">3328 void PhaseOutput::install_stub(const char* stub_name,</span>
<span class="line-added">3329                                bool        caller_must_gc_arguments) {</span>
<span class="line-added">3330   // Entry point will be accessed using stub_entry_point();</span>
<span class="line-added">3331   if (code_buffer() == NULL) {</span>
<span class="line-added">3332     Matcher::soft_match_failure();</span>
<span class="line-added">3333   } else {</span>
<span class="line-added">3334     if (PrintAssembly &amp;&amp; (WizardMode || Verbose))</span>
<span class="line-added">3335       tty-&gt;print_cr(&quot;### Stub::%s&quot;, stub_name);</span>
<span class="line-added">3336 </span>
<span class="line-added">3337     if (!C-&gt;failing()) {</span>
<span class="line-added">3338       assert(C-&gt;fixed_slots() == 0, &quot;no fixed slots used for runtime stubs&quot;);</span>
<span class="line-added">3339 </span>
<span class="line-added">3340       // Make the NMethod</span>
<span class="line-added">3341       // For now we mark the frame as never safe for profile stackwalking</span>
<span class="line-added">3342       RuntimeStub *rs = RuntimeStub::new_runtime_stub(stub_name,</span>
<span class="line-added">3343                                                       code_buffer(),</span>
<span class="line-added">3344                                                       CodeOffsets::frame_never_safe,</span>
<span class="line-added">3345                                                       // _code_offsets.value(CodeOffsets::Frame_Complete),</span>
<span class="line-added">3346                                                       frame_size_in_words(),</span>
<span class="line-added">3347                                                       oop_map_set(),</span>
<span class="line-added">3348                                                       caller_must_gc_arguments);</span>
<span class="line-added">3349       assert(rs != NULL &amp;&amp; rs-&gt;is_runtime_stub(), &quot;sanity check&quot;);</span>
<span class="line-added">3350 </span>
<span class="line-added">3351       C-&gt;set_stub_entry_point(rs-&gt;entry_point());</span>
<span class="line-added">3352     }</span>
<span class="line-added">3353   }</span>
<span class="line-added">3354 }</span>
<span class="line-added">3355 </span>
<span class="line-added">3356 // Support for bundling info</span>
<span class="line-added">3357 Bundle* PhaseOutput::node_bundling(const Node *n) {</span>
<span class="line-added">3358   assert(valid_bundle_info(n), &quot;oob&quot;);</span>
<span class="line-added">3359   return &amp;_node_bundling_base[n-&gt;_idx];</span>
<span class="line-added">3360 }</span>
<span class="line-added">3361 </span>
<span class="line-added">3362 bool PhaseOutput::valid_bundle_info(const Node *n) {</span>
<span class="line-added">3363   return (_node_bundling_limit &gt; n-&gt;_idx);</span>
<span class="line-added">3364 }</span>
<span class="line-added">3365 </span>
<span class="line-added">3366 //------------------------------frame_size_in_words-----------------------------</span>
<span class="line-added">3367 // frame_slots in units of words</span>
<span class="line-added">3368 int PhaseOutput::frame_size_in_words() const {</span>
<span class="line-added">3369   // shift is 0 in LP32 and 1 in LP64</span>
<span class="line-added">3370   const int shift = (LogBytesPerWord - LogBytesPerInt);</span>
<span class="line-added">3371   int words = _frame_slots &gt;&gt; shift;</span>
<span class="line-added">3372   assert( words &lt;&lt; shift == _frame_slots, &quot;frame size must be properly aligned in LP64&quot; );</span>
<span class="line-added">3373   return words;</span>
<span class="line-added">3374 }</span>
<span class="line-added">3375 </span>
<span class="line-added">3376 // To bang the stack of this compiled method we use the stack size</span>
<span class="line-added">3377 // that the interpreter would need in case of a deoptimization. This</span>
<span class="line-added">3378 // removes the need to bang the stack in the deoptimization blob which</span>
<span class="line-added">3379 // in turn simplifies stack overflow handling.</span>
<span class="line-added">3380 int PhaseOutput::bang_size_in_bytes() const {</span>
<span class="line-added">3381   return MAX2(frame_size_in_bytes() + os::extra_bang_size_in_bytes(), C-&gt;interpreter_frame_size());</span>
<span class="line-added">3382 }</span>
<span class="line-added">3383 </span>
<span class="line-added">3384 //------------------------------dump_asm---------------------------------------</span>
<span class="line-added">3385 // Dump formatted assembly</span>
<span class="line-added">3386 #if defined(SUPPORT_OPTO_ASSEMBLY)</span>
<span class="line-added">3387 void PhaseOutput::dump_asm_on(outputStream* st, int* pcs, uint pc_limit) {</span>
<span class="line-added">3388 </span>
<span class="line-added">3389   int pc_digits = 3; // #chars required for pc</span>
<span class="line-added">3390   int sb_chars  = 3; // #chars for &quot;start bundle&quot; indicator</span>
<span class="line-added">3391   int tab_size  = 8;</span>
<span class="line-added">3392   if (pcs != NULL) {</span>
<span class="line-added">3393     int max_pc = 0;</span>
<span class="line-added">3394     for (uint i = 0; i &lt; pc_limit; i++) {</span>
<span class="line-added">3395       max_pc = (max_pc &lt; pcs[i]) ? pcs[i] : max_pc;</span>
<span class="line-added">3396     }</span>
<span class="line-added">3397     pc_digits  = ((max_pc &lt; 4096) ? 3 : ((max_pc &lt; 65536) ? 4 : ((max_pc &lt; 65536*256) ? 6 : 8))); // #chars required for pc</span>
<span class="line-added">3398   }</span>
<span class="line-added">3399   int prefix_len = ((pc_digits + sb_chars + tab_size - 1)/tab_size)*tab_size;</span>
<span class="line-added">3400 </span>
<span class="line-added">3401   bool cut_short = false;</span>
<span class="line-added">3402   st-&gt;print_cr(&quot;#&quot;);</span>
<span class="line-added">3403   st-&gt;print(&quot;#  &quot;);  C-&gt;tf()-&gt;dump_on(st);  st-&gt;cr();</span>
<span class="line-added">3404   st-&gt;print_cr(&quot;#&quot;);</span>
<span class="line-added">3405 </span>
<span class="line-added">3406   // For all blocks</span>
<span class="line-added">3407   int pc = 0x0;                 // Program counter</span>
<span class="line-added">3408   char starts_bundle = &#39; &#39;;</span>
<span class="line-added">3409   C-&gt;regalloc()-&gt;dump_frame();</span>
<span class="line-added">3410 </span>
<span class="line-added">3411   Node *n = NULL;</span>
<span class="line-added">3412   for (uint i = 0; i &lt; C-&gt;cfg()-&gt;number_of_blocks(); i++) {</span>
<span class="line-added">3413     if (VMThread::should_terminate()) {</span>
<span class="line-added">3414       cut_short = true;</span>
<span class="line-added">3415       break;</span>
<span class="line-added">3416     }</span>
<span class="line-added">3417     Block* block = C-&gt;cfg()-&gt;get_block(i);</span>
<span class="line-added">3418     if (block-&gt;is_connector() &amp;&amp; !Verbose) {</span>
<span class="line-added">3419       continue;</span>
<span class="line-added">3420     }</span>
<span class="line-added">3421     n = block-&gt;head();</span>
<span class="line-added">3422     if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {</span>
<span class="line-added">3423       pc = pcs[n-&gt;_idx];</span>
<span class="line-added">3424       st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);</span>
<span class="line-added">3425     }</span>
<span class="line-added">3426     st-&gt;fill_to(prefix_len);</span>
<span class="line-added">3427     block-&gt;dump_head(C-&gt;cfg(), st);</span>
<span class="line-added">3428     if (block-&gt;is_connector()) {</span>
<span class="line-added">3429       st-&gt;fill_to(prefix_len);</span>
<span class="line-added">3430       st-&gt;print_cr(&quot;# Empty connector block&quot;);</span>
<span class="line-added">3431     } else if (block-&gt;num_preds() == 2 &amp;&amp; block-&gt;pred(1)-&gt;is_CatchProj() &amp;&amp; block-&gt;pred(1)-&gt;as_CatchProj()-&gt;_con == CatchProjNode::fall_through_index) {</span>
<span class="line-added">3432       st-&gt;fill_to(prefix_len);</span>
<span class="line-added">3433       st-&gt;print_cr(&quot;# Block is sole successor of call&quot;);</span>
<span class="line-added">3434     }</span>
<span class="line-added">3435 </span>
<span class="line-added">3436     // For all instructions</span>
<span class="line-added">3437     Node *delay = NULL;</span>
<span class="line-added">3438     for (uint j = 0; j &lt; block-&gt;number_of_nodes(); j++) {</span>
<span class="line-added">3439       if (VMThread::should_terminate()) {</span>
<span class="line-added">3440         cut_short = true;</span>
<span class="line-added">3441         break;</span>
<span class="line-added">3442       }</span>
<span class="line-added">3443       n = block-&gt;get_node(j);</span>
<span class="line-added">3444       if (valid_bundle_info(n)) {</span>
<span class="line-added">3445         Bundle* bundle = node_bundling(n);</span>
<span class="line-added">3446         if (bundle-&gt;used_in_unconditional_delay()) {</span>
<span class="line-added">3447           delay = n;</span>
<span class="line-added">3448           continue;</span>
<span class="line-added">3449         }</span>
<span class="line-added">3450         if (bundle-&gt;starts_bundle()) {</span>
<span class="line-added">3451           starts_bundle = &#39;+&#39;;</span>
<span class="line-added">3452         }</span>
<span class="line-added">3453       }</span>
<span class="line-added">3454 </span>
<span class="line-added">3455       if (WizardMode) {</span>
<span class="line-added">3456         n-&gt;dump();</span>
<span class="line-added">3457       }</span>
<span class="line-added">3458 </span>
<span class="line-added">3459       if( !n-&gt;is_Region() &amp;&amp;    // Dont print in the Assembly</span>
<span class="line-added">3460           !n-&gt;is_Phi() &amp;&amp;       // a few noisely useless nodes</span>
<span class="line-added">3461           !n-&gt;is_Proj() &amp;&amp;</span>
<span class="line-added">3462           !n-&gt;is_MachTemp() &amp;&amp;</span>
<span class="line-added">3463           !n-&gt;is_SafePointScalarObject() &amp;&amp;</span>
<span class="line-added">3464           !n-&gt;is_Catch() &amp;&amp;     // Would be nice to print exception table targets</span>
<span class="line-added">3465           !n-&gt;is_MergeMem() &amp;&amp;  // Not very interesting</span>
<span class="line-added">3466           !n-&gt;is_top() &amp;&amp;       // Debug info table constants</span>
<span class="line-added">3467           !(n-&gt;is_Con() &amp;&amp; !n-&gt;is_Mach())// Debug info table constants</span>
<span class="line-added">3468           ) {</span>
<span class="line-added">3469         if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {</span>
<span class="line-added">3470           pc = pcs[n-&gt;_idx];</span>
<span class="line-added">3471           st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);</span>
<span class="line-added">3472         } else {</span>
<span class="line-added">3473           st-&gt;fill_to(pc_digits);</span>
<span class="line-added">3474         }</span>
<span class="line-added">3475         st-&gt;print(&quot; %c &quot;, starts_bundle);</span>
<span class="line-added">3476         starts_bundle = &#39; &#39;;</span>
<span class="line-added">3477         st-&gt;fill_to(prefix_len);</span>
<span class="line-added">3478         n-&gt;format(C-&gt;regalloc(), st);</span>
<span class="line-added">3479         st-&gt;cr();</span>
<span class="line-added">3480       }</span>
<span class="line-added">3481 </span>
<span class="line-added">3482       // If we have an instruction with a delay slot, and have seen a delay,</span>
<span class="line-added">3483       // then back up and print it</span>
<span class="line-added">3484       if (valid_bundle_info(n) &amp;&amp; node_bundling(n)-&gt;use_unconditional_delay()) {</span>
<span class="line-added">3485         // Coverity finding - Explicit null dereferenced.</span>
<span class="line-added">3486         guarantee(delay != NULL, &quot;no unconditional delay instruction&quot;);</span>
<span class="line-added">3487         if (WizardMode) delay-&gt;dump();</span>
<span class="line-added">3488 </span>
<span class="line-added">3489         if (node_bundling(delay)-&gt;starts_bundle())</span>
<span class="line-added">3490           starts_bundle = &#39;+&#39;;</span>
<span class="line-added">3491         if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {</span>
<span class="line-added">3492           pc = pcs[n-&gt;_idx];</span>
<span class="line-added">3493           st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);</span>
<span class="line-added">3494         } else {</span>
<span class="line-added">3495           st-&gt;fill_to(pc_digits);</span>
<span class="line-added">3496         }</span>
<span class="line-added">3497         st-&gt;print(&quot; %c &quot;, starts_bundle);</span>
<span class="line-added">3498         starts_bundle = &#39; &#39;;</span>
<span class="line-added">3499         st-&gt;fill_to(prefix_len);</span>
<span class="line-added">3500         delay-&gt;format(C-&gt;regalloc(), st);</span>
<span class="line-added">3501         st-&gt;cr();</span>
<span class="line-added">3502         delay = NULL;</span>
<span class="line-added">3503       }</span>
<span class="line-added">3504 </span>
<span class="line-added">3505       // Dump the exception table as well</span>
<span class="line-added">3506       if( n-&gt;is_Catch() &amp;&amp; (Verbose || WizardMode) ) {</span>
<span class="line-added">3507         // Print the exception table for this offset</span>
<span class="line-added">3508         _handler_table.print_subtable_for(pc);</span>
<span class="line-added">3509       }</span>
<span class="line-added">3510       st-&gt;bol(); // Make sure we start on a new line</span>
<span class="line-added">3511     }</span>
<span class="line-added">3512     st-&gt;cr(); // one empty line between blocks</span>
<span class="line-added">3513     assert(cut_short || delay == NULL, &quot;no unconditional delay branch&quot;);</span>
<span class="line-added">3514   } // End of per-block dump</span>
<span class="line-added">3515 </span>
<span class="line-added">3516   if (cut_short)  st-&gt;print_cr(&quot;*** disassembly is cut short ***&quot;);</span>
<span class="line-added">3517 }</span>
<span class="line-added">3518 #endif</span>
<span class="line-added">3519 </span>
<span class="line-added">3520 #ifndef PRODUCT</span>
<span class="line-added">3521 void PhaseOutput::print_statistics() {</span>
<span class="line-added">3522   Scheduling::print_statistics();</span>
<span class="line-added">3523 }</span>
<span class="line-added">3524 #endif</span>
</pre>
</td>
</tr>
</table>
<center><a href="node.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="output.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
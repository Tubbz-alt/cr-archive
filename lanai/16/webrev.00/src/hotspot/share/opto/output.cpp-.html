<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/output.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/assembler.inline.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;code/compiledIC.hpp&quot;
  29 #include &quot;code/debugInfo.hpp&quot;
  30 #include &quot;code/debugInfoRec.hpp&quot;
  31 #include &quot;compiler/compileBroker.hpp&quot;
  32 #include &quot;compiler/compilerDirectives.hpp&quot;
  33 #include &quot;compiler/oopMap.hpp&quot;
  34 #include &quot;gc/shared/barrierSet.hpp&quot;
  35 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  36 #include &quot;memory/allocation.inline.hpp&quot;
  37 #include &quot;opto/ad.hpp&quot;
  38 #include &quot;opto/callnode.hpp&quot;
  39 #include &quot;opto/cfgnode.hpp&quot;
  40 #include &quot;opto/locknode.hpp&quot;
  41 #include &quot;opto/machnode.hpp&quot;
  42 #include &quot;opto/optoreg.hpp&quot;
  43 #include &quot;opto/output.hpp&quot;
  44 #include &quot;opto/regalloc.hpp&quot;
  45 #include &quot;opto/runtime.hpp&quot;
  46 #include &quot;opto/subnode.hpp&quot;
  47 #include &quot;opto/type.hpp&quot;
  48 #include &quot;runtime/handles.inline.hpp&quot;
  49 #include &quot;utilities/xmlstream.hpp&quot;
  50 
  51 #ifndef PRODUCT
  52 #define DEBUG_ARG(x) , x
  53 #else
  54 #define DEBUG_ARG(x)
  55 #endif
  56 
  57 // Convert Nodes to instruction bits and pass off to the VM
  58 void Compile::Output() {
  59   // RootNode goes
  60   assert( _cfg-&gt;get_root_block()-&gt;number_of_nodes() == 0, &quot;&quot; );
  61 
  62   // The number of new nodes (mostly MachNop) is proportional to
  63   // the number of java calls and inner loops which are aligned.
  64   if ( C-&gt;check_node_count((NodeLimitFudgeFactor + C-&gt;java_calls()*3 +
  65                             C-&gt;inner_loops()*(OptoLoopAlignment-1)),
  66                            &quot;out of nodes before code generation&quot; ) ) {
  67     return;
  68   }
  69   // Make sure I can find the Start Node
  70   Block *entry = _cfg-&gt;get_block(1);
  71   Block *broot = _cfg-&gt;get_root_block();
  72 
  73   const StartNode *start = entry-&gt;head()-&gt;as_Start();
  74 
  75   // Replace StartNode with prolog
  76   MachPrologNode *prolog = new MachPrologNode();
  77   entry-&gt;map_node(prolog, 0);
  78   _cfg-&gt;map_node_to_block(prolog, entry);
  79   _cfg-&gt;unmap_node_from_block(start); // start is no longer in any block
  80 
  81   // Virtual methods need an unverified entry point
  82 
  83   if( is_osr_compilation() ) {
  84     if( PoisonOSREntry ) {
  85       // TODO: Should use a ShouldNotReachHereNode...
  86       _cfg-&gt;insert( broot, 0, new MachBreakpointNode() );
  87     }
  88   } else {
  89     if( _method &amp;&amp; !_method-&gt;flags().is_static() ) {
  90       // Insert unvalidated entry point
  91       _cfg-&gt;insert( broot, 0, new MachUEPNode() );
  92     }
  93 
  94   }
  95 
  96   // Break before main entry point
  97   if ((_method &amp;&amp; C-&gt;directive()-&gt;BreakAtExecuteOption) ||
  98       (OptoBreakpoint &amp;&amp; is_method_compilation())       ||
  99       (OptoBreakpointOSR &amp;&amp; is_osr_compilation())       ||
 100       (OptoBreakpointC2R &amp;&amp; !_method)                   ) {
 101     // checking for _method means that OptoBreakpoint does not apply to
 102     // runtime stubs or frame converters
 103     _cfg-&gt;insert( entry, 1, new MachBreakpointNode() );
 104   }
 105 
 106   // Insert epilogs before every return
 107   for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {
 108     Block* block = _cfg-&gt;get_block(i);
 109     if (!block-&gt;is_connector() &amp;&amp; block-&gt;non_connector_successor(0) == _cfg-&gt;get_root_block()) { // Found a program exit point?
 110       Node* m = block-&gt;end();
 111       if (m-&gt;is_Mach() &amp;&amp; m-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Halt) {
 112         MachEpilogNode* epilog = new MachEpilogNode(m-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Return);
 113         block-&gt;add_inst(epilog);
 114         _cfg-&gt;map_node_to_block(epilog, block);
 115       }
 116     }
 117   }
 118 
 119   // Keeper of sizing aspects
 120   BufferSizingData buf_sizes = BufferSizingData();
 121 
 122   // Initialize code buffer
 123   estimate_buffer_size(buf_sizes._const);
 124   if (failing()) return;
 125 
 126   // Pre-compute the length of blocks and replace
 127   // long branches with short if machine supports it.
 128   // Must be done before ScheduleAndBundle due to SPARC delay slots
 129   uint* blk_starts = NEW_RESOURCE_ARRAY(uint, _cfg-&gt;number_of_blocks() + 1);
 130   blk_starts[0] = 0;
 131   shorten_branches(blk_starts, buf_sizes);
 132 
 133   ScheduleAndBundle();
 134   if (failing()) {
 135     return;
 136   }
 137 
 138   // Late barrier analysis must be done after schedule and bundle
 139   // Otherwise liveness based spilling will fail
 140   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 141   bs-&gt;late_barrier_analysis();
 142 
 143   // Complete sizing of codebuffer
 144   CodeBuffer* cb = init_buffer(buf_sizes);
 145   if (cb == NULL || failing()) {
 146     return;
 147   }
 148 
 149   BuildOopMaps();
 150 
 151   if (failing())  {
 152     return;
 153   }
 154 
 155   fill_buffer(cb, blk_starts);
 156 }
 157 
 158 bool Compile::need_stack_bang(int frame_size_in_bytes) const {
 159   // Determine if we need to generate a stack overflow check.
 160   // Do it if the method is not a stub function and
 161   // has java calls or has frame size &gt; vm_page_size/8.
 162   // The debug VM checks that deoptimization doesn&#39;t trigger an
 163   // unexpected stack overflow (compiled method stack banging should
 164   // guarantee it doesn&#39;t happen) so we always need the stack bang in
 165   // a debug VM.
 166   return (UseStackBanging &amp;&amp; stub_function() == NULL &amp;&amp;
 167           (has_java_calls() || frame_size_in_bytes &gt; os::vm_page_size()&gt;&gt;3
 168            DEBUG_ONLY(|| true)));
 169 }
 170 
 171 bool Compile::need_register_stack_bang() const {
 172   // Determine if we need to generate a register stack overflow check.
 173   // This is only used on architectures which have split register
 174   // and memory stacks (ie. IA64).
 175   // Bang if the method is not a stub function and has java calls
 176   return (stub_function() == NULL &amp;&amp; has_java_calls());
 177 }
 178 
 179 
 180 // Compute the size of first NumberOfLoopInstrToAlign instructions at the top
 181 // of a loop. When aligning a loop we need to provide enough instructions
 182 // in cpu&#39;s fetch buffer to feed decoders. The loop alignment could be
 183 // avoided if we have enough instructions in fetch buffer at the head of a loop.
 184 // By default, the size is set to 999999 by Block&#39;s constructor so that
 185 // a loop will be aligned if the size is not reset here.
 186 //
 187 // Note: Mach instructions could contain several HW instructions
 188 // so the size is estimated only.
 189 //
 190 void Compile::compute_loop_first_inst_sizes() {
 191   // The next condition is used to gate the loop alignment optimization.
 192   // Don&#39;t aligned a loop if there are enough instructions at the head of a loop
 193   // or alignment padding is larger then MaxLoopPad. By default, MaxLoopPad
 194   // is equal to OptoLoopAlignment-1 except on new Intel cpus, where it is
 195   // equal to 11 bytes which is the largest address NOP instruction.
 196   if (MaxLoopPad &lt; OptoLoopAlignment - 1) {
 197     uint last_block = _cfg-&gt;number_of_blocks() - 1;
 198     for (uint i = 1; i &lt;= last_block; i++) {
 199       Block* block = _cfg-&gt;get_block(i);
 200       // Check the first loop&#39;s block which requires an alignment.
 201       if (block-&gt;loop_alignment() &gt; (uint)relocInfo::addr_unit()) {
 202         uint sum_size = 0;
 203         uint inst_cnt = NumberOfLoopInstrToAlign;
 204         inst_cnt = block-&gt;compute_first_inst_size(sum_size, inst_cnt, _regalloc);
 205 
 206         // Check subsequent fallthrough blocks if the loop&#39;s first
 207         // block(s) does not have enough instructions.
 208         Block *nb = block;
 209         while(inst_cnt &gt; 0 &amp;&amp;
 210               i &lt; last_block &amp;&amp;
 211               !_cfg-&gt;get_block(i + 1)-&gt;has_loop_alignment() &amp;&amp;
 212               !nb-&gt;has_successor(block)) {
 213           i++;
 214           nb = _cfg-&gt;get_block(i);
 215           inst_cnt  = nb-&gt;compute_first_inst_size(sum_size, inst_cnt, _regalloc);
 216         } // while( inst_cnt &gt; 0 &amp;&amp; i &lt; last_block  )
 217 
 218         block-&gt;set_first_inst_size(sum_size);
 219       } // f( b-&gt;head()-&gt;is_Loop() )
 220     } // for( i &lt;= last_block )
 221   } // if( MaxLoopPad &lt; OptoLoopAlignment-1 )
 222 }
 223 
 224 // The architecture description provides short branch variants for some long
 225 // branch instructions. Replace eligible long branches with short branches.
 226 void Compile::shorten_branches(uint* blk_starts, BufferSizingData&amp; buf_sizes) {
 227   // Compute size of each block, method size, and relocation information size
 228   uint nblocks  = _cfg-&gt;number_of_blocks();
 229 
 230   uint*      jmp_offset = NEW_RESOURCE_ARRAY(uint,nblocks);
 231   uint*      jmp_size   = NEW_RESOURCE_ARRAY(uint,nblocks);
 232   int*       jmp_nidx   = NEW_RESOURCE_ARRAY(int ,nblocks);
 233 
 234   // Collect worst case block paddings
 235   int* block_worst_case_pad = NEW_RESOURCE_ARRAY(int, nblocks);
 236   memset(block_worst_case_pad, 0, nblocks * sizeof(int));
 237 
 238   DEBUG_ONLY( uint *jmp_target = NEW_RESOURCE_ARRAY(uint,nblocks); )
 239   DEBUG_ONLY( uint *jmp_rule = NEW_RESOURCE_ARRAY(uint,nblocks); )
 240 
 241   bool has_short_branch_candidate = false;
 242 
 243   // Initialize the sizes to 0
 244   int code_size  = 0;          // Size in bytes of generated code
 245   int stub_size  = 0;          // Size in bytes of all stub entries
 246   // Size in bytes of all relocation entries, including those in local stubs.
 247   // Start with 2-bytes of reloc info for the unvalidated entry point
 248   int reloc_size = 1;          // Number of relocation entries
 249 
 250   // Make three passes.  The first computes pessimistic blk_starts,
 251   // relative jmp_offset and reloc_size information.  The second performs
 252   // short branch substitution using the pessimistic sizing.  The
 253   // third inserts nops where needed.
 254 
 255   // Step one, perform a pessimistic sizing pass.
 256   uint last_call_adr = max_juint;
 257   uint last_avoid_back_to_back_adr = max_juint;
 258   uint nop_size = (new MachNopNode())-&gt;size(_regalloc);
 259   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
 260     Block* block = _cfg-&gt;get_block(i);
 261 
 262     // During short branch replacement, we store the relative (to blk_starts)
 263     // offset of jump in jmp_offset, rather than the absolute offset of jump.
 264     // This is so that we do not need to recompute sizes of all nodes when
 265     // we compute correct blk_starts in our next sizing pass.
 266     jmp_offset[i] = 0;
 267     jmp_size[i]   = 0;
 268     jmp_nidx[i]   = -1;
 269     DEBUG_ONLY( jmp_target[i] = 0; )
 270     DEBUG_ONLY( jmp_rule[i]   = 0; )
 271 
 272     // Sum all instruction sizes to compute block size
 273     uint last_inst = block-&gt;number_of_nodes();
 274     uint blk_size = 0;
 275     for (uint j = 0; j &lt; last_inst; j++) {
 276       Node* nj = block-&gt;get_node(j);
 277       // Handle machine instruction nodes
 278       if (nj-&gt;is_Mach()) {
 279         MachNode *mach = nj-&gt;as_Mach();
 280         blk_size += (mach-&gt;alignment_required() - 1) * relocInfo::addr_unit(); // assume worst case padding
 281         reloc_size += mach-&gt;reloc();
 282         if (mach-&gt;is_MachCall()) {
 283           // add size information for trampoline stub
 284           // class CallStubImpl is platform-specific and defined in the *.ad files.
 285           stub_size  += CallStubImpl::size_call_trampoline();
 286           reloc_size += CallStubImpl::reloc_call_trampoline();
 287 
 288           MachCallNode *mcall = mach-&gt;as_MachCall();
 289           // This destination address is NOT PC-relative
 290 
 291           mcall-&gt;method_set((intptr_t)mcall-&gt;entry_point());
 292 
 293           if (mcall-&gt;is_MachCallJava() &amp;&amp; mcall-&gt;as_MachCallJava()-&gt;_method) {
 294             stub_size  += CompiledStaticCall::to_interp_stub_size();
 295             reloc_size += CompiledStaticCall::reloc_to_interp_stub();
 296 #if INCLUDE_AOT
 297             stub_size  += CompiledStaticCall::to_aot_stub_size();
 298             reloc_size += CompiledStaticCall::reloc_to_aot_stub();
 299 #endif
 300           }
 301         } else if (mach-&gt;is_MachSafePoint()) {
 302           // If call/safepoint are adjacent, account for possible
 303           // nop to disambiguate the two safepoints.
 304           // ScheduleAndBundle() can rearrange nodes in a block,
 305           // check for all offsets inside this block.
 306           if (last_call_adr &gt;= blk_starts[i]) {
 307             blk_size += nop_size;
 308           }
 309         }
 310         if (mach-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
 311           // Nop is inserted between &quot;avoid back to back&quot; instructions.
 312           // ScheduleAndBundle() can rearrange nodes in a block,
 313           // check for all offsets inside this block.
 314           if (last_avoid_back_to_back_adr &gt;= blk_starts[i]) {
 315             blk_size += nop_size;
 316           }
 317         }
 318         if (mach-&gt;may_be_short_branch()) {
 319           if (!nj-&gt;is_MachBranch()) {
 320 #ifndef PRODUCT
 321             nj-&gt;dump(3);
 322 #endif
 323             Unimplemented();
 324           }
 325           assert(jmp_nidx[i] == -1, &quot;block should have only one branch&quot;);
 326           jmp_offset[i] = blk_size;
 327           jmp_size[i]   = nj-&gt;size(_regalloc);
 328           jmp_nidx[i]   = j;
 329           has_short_branch_candidate = true;
 330         }
 331       }
 332       blk_size += nj-&gt;size(_regalloc);
 333       // Remember end of call offset
 334       if (nj-&gt;is_MachCall() &amp;&amp; !nj-&gt;is_MachCallLeaf()) {
 335         last_call_adr = blk_starts[i]+blk_size;
 336       }
 337       // Remember end of avoid_back_to_back offset
 338       if (nj-&gt;is_Mach() &amp;&amp; nj-&gt;as_Mach()-&gt;avoid_back_to_back(MachNode::AVOID_AFTER)) {
 339         last_avoid_back_to_back_adr = blk_starts[i]+blk_size;
 340       }
 341     }
 342 
 343     // When the next block starts a loop, we may insert pad NOP
 344     // instructions.  Since we cannot know our future alignment,
 345     // assume the worst.
 346     if (i &lt; nblocks - 1) {
 347       Block* nb = _cfg-&gt;get_block(i + 1);
 348       int max_loop_pad = nb-&gt;code_alignment()-relocInfo::addr_unit();
 349       if (max_loop_pad &gt; 0) {
 350         assert(is_power_of_2(max_loop_pad+relocInfo::addr_unit()), &quot;&quot;);
 351         // Adjust last_call_adr and/or last_avoid_back_to_back_adr.
 352         // If either is the last instruction in this block, bump by
 353         // max_loop_pad in lock-step with blk_size, so sizing
 354         // calculations in subsequent blocks still can conservatively
 355         // detect that it may the last instruction in this block.
 356         if (last_call_adr == blk_starts[i]+blk_size) {
 357           last_call_adr += max_loop_pad;
 358         }
 359         if (last_avoid_back_to_back_adr == blk_starts[i]+blk_size) {
 360           last_avoid_back_to_back_adr += max_loop_pad;
 361         }
 362         blk_size += max_loop_pad;
 363         block_worst_case_pad[i + 1] = max_loop_pad;
 364       }
 365     }
 366 
 367     // Save block size; update total method size
 368     blk_starts[i+1] = blk_starts[i]+blk_size;
 369   }
 370 
 371   // Step two, replace eligible long jumps.
 372   bool progress = true;
 373   uint last_may_be_short_branch_adr = max_juint;
 374   while (has_short_branch_candidate &amp;&amp; progress) {
 375     progress = false;
 376     has_short_branch_candidate = false;
 377     int adjust_block_start = 0;
 378     for (uint i = 0; i &lt; nblocks; i++) {
 379       Block* block = _cfg-&gt;get_block(i);
 380       int idx = jmp_nidx[i];
 381       MachNode* mach = (idx == -1) ? NULL: block-&gt;get_node(idx)-&gt;as_Mach();
 382       if (mach != NULL &amp;&amp; mach-&gt;may_be_short_branch()) {
 383 #ifdef ASSERT
 384         assert(jmp_size[i] &gt; 0 &amp;&amp; mach-&gt;is_MachBranch(), &quot;sanity&quot;);
 385         int j;
 386         // Find the branch; ignore trailing NOPs.
 387         for (j = block-&gt;number_of_nodes()-1; j&gt;=0; j--) {
 388           Node* n = block-&gt;get_node(j);
 389           if (!n-&gt;is_Mach() || n-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Con)
 390             break;
 391         }
 392         assert(j &gt;= 0 &amp;&amp; j == idx &amp;&amp; block-&gt;get_node(j) == (Node*)mach, &quot;sanity&quot;);
 393 #endif
 394         int br_size = jmp_size[i];
 395         int br_offs = blk_starts[i] + jmp_offset[i];
 396 
 397         // This requires the TRUE branch target be in succs[0]
 398         uint bnum = block-&gt;non_connector_successor(0)-&gt;_pre_order;
 399         int offset = blk_starts[bnum] - br_offs;
 400         if (bnum &gt; i) { // adjust following block&#39;s offset
 401           offset -= adjust_block_start;
 402         }
 403 
 404         // This block can be a loop header, account for the padding
 405         // in the previous block.
 406         int block_padding = block_worst_case_pad[i];
 407         assert(i == 0 || block_padding == 0 || br_offs &gt;= block_padding, &quot;Should have at least a padding on top&quot;);
 408         // In the following code a nop could be inserted before
 409         // the branch which will increase the backward distance.
 410         bool needs_padding = ((uint)(br_offs - block_padding) == last_may_be_short_branch_adr);
 411         assert(!needs_padding || jmp_offset[i] == 0, &quot;padding only branches at the beginning of block&quot;);
 412 
 413         if (needs_padding &amp;&amp; offset &lt;= 0)
 414           offset -= nop_size;
 415 
 416         if (_matcher-&gt;is_short_branch_offset(mach-&gt;rule(), br_size, offset)) {
 417           // We&#39;ve got a winner.  Replace this branch.
 418           MachNode* replacement = mach-&gt;as_MachBranch()-&gt;short_branch_version();
 419 
 420           // Update the jmp_size.
 421           int new_size = replacement-&gt;size(_regalloc);
 422           int diff     = br_size - new_size;
 423           assert(diff &gt;= (int)nop_size, &quot;short_branch size should be smaller&quot;);
 424           // Conservatively take into account padding between
 425           // avoid_back_to_back branches. Previous branch could be
 426           // converted into avoid_back_to_back branch during next
 427           // rounds.
 428           if (needs_padding &amp;&amp; replacement-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
 429             jmp_offset[i] += nop_size;
 430             diff -= nop_size;
 431           }
 432           adjust_block_start += diff;
 433           block-&gt;map_node(replacement, idx);
 434           mach-&gt;subsume_by(replacement, C);
 435           mach = replacement;
 436           progress = true;
 437 
 438           jmp_size[i] = new_size;
 439           DEBUG_ONLY( jmp_target[i] = bnum; );
 440           DEBUG_ONLY( jmp_rule[i] = mach-&gt;rule(); );
 441         } else {
 442           // The jump distance is not short, try again during next iteration.
 443           has_short_branch_candidate = true;
 444         }
 445       } // (mach-&gt;may_be_short_branch())
 446       if (mach != NULL &amp;&amp; (mach-&gt;may_be_short_branch() ||
 447                            mach-&gt;avoid_back_to_back(MachNode::AVOID_AFTER))) {
 448         last_may_be_short_branch_adr = blk_starts[i] + jmp_offset[i] + jmp_size[i];
 449       }
 450       blk_starts[i+1] -= adjust_block_start;
 451     }
 452   }
 453 
 454 #ifdef ASSERT
 455   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
 456     if (jmp_target[i] != 0) {
 457       int br_size = jmp_size[i];
 458       int offset = blk_starts[jmp_target[i]]-(blk_starts[i] + jmp_offset[i]);
 459       if (!_matcher-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset)) {
 460         tty-&gt;print_cr(&quot;target (%d) - jmp_offset(%d) = offset (%d), jump_size(%d), jmp_block B%d, target_block B%d&quot;, blk_starts[jmp_target[i]], blk_starts[i] + jmp_offset[i], offset, br_size, i, jmp_target[i]);
 461       }
 462       assert(_matcher-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset), &quot;Displacement too large for short jmp&quot;);
 463     }
 464   }
 465 #endif
 466 
 467   // Step 3, compute the offsets of all blocks, will be done in fill_buffer()
 468   // after ScheduleAndBundle().
 469 
 470   // ------------------
 471   // Compute size for code buffer
 472   code_size = blk_starts[nblocks];
 473 
 474   // Relocation records
 475   reloc_size += 1;              // Relo entry for exception handler
 476 
 477   // Adjust reloc_size to number of record of relocation info
 478   // Min is 2 bytes, max is probably 6 or 8, with a tax up to 25% for
 479   // a relocation index.
 480   // The CodeBuffer will expand the locs array if this estimate is too low.
 481   reloc_size *= 10 / sizeof(relocInfo);
 482 
 483   buf_sizes._reloc = reloc_size;
 484   buf_sizes._code  = code_size;
 485   buf_sizes._stub  = stub_size;
 486 }
 487 
 488 //------------------------------FillLocArray-----------------------------------
 489 // Create a bit of debug info and append it to the array.  The mapping is from
 490 // Java local or expression stack to constant, register or stack-slot.  For
 491 // doubles, insert 2 mappings and return 1 (to tell the caller that the next
 492 // entry has been taken care of and caller should skip it).
 493 static LocationValue *new_loc_value( PhaseRegAlloc *ra, OptoReg::Name regnum, Location::Type l_type ) {
 494   // This should never have accepted Bad before
 495   assert(OptoReg::is_valid(regnum), &quot;location must be valid&quot;);
 496   return (OptoReg::is_reg(regnum))
 497          ? new LocationValue(Location::new_reg_loc(l_type, OptoReg::as_VMReg(regnum)) )
 498          : new LocationValue(Location::new_stk_loc(l_type,  ra-&gt;reg2offset(regnum)));
 499 }
 500 
 501 
 502 ObjectValue*
 503 Compile::sv_for_node_id(GrowableArray&lt;ScopeValue*&gt; *objs, int id) {
 504   for (int i = 0; i &lt; objs-&gt;length(); i++) {
 505     assert(objs-&gt;at(i)-&gt;is_object(), &quot;corrupt object cache&quot;);
 506     ObjectValue* sv = (ObjectValue*) objs-&gt;at(i);
 507     if (sv-&gt;id() == id) {
 508       return sv;
 509     }
 510   }
 511   // Otherwise..
 512   return NULL;
 513 }
 514 
 515 void Compile::set_sv_for_object_node(GrowableArray&lt;ScopeValue*&gt; *objs,
 516                                      ObjectValue* sv ) {
 517   assert(sv_for_node_id(objs, sv-&gt;id()) == NULL, &quot;Precondition&quot;);
 518   objs-&gt;append(sv);
 519 }
 520 
 521 
 522 void Compile::FillLocArray( int idx, MachSafePointNode* sfpt, Node *local,
 523                             GrowableArray&lt;ScopeValue*&gt; *array,
 524                             GrowableArray&lt;ScopeValue*&gt; *objs ) {
 525   assert( local, &quot;use _top instead of null&quot; );
 526   if (array-&gt;length() != idx) {
 527     assert(array-&gt;length() == idx + 1, &quot;Unexpected array count&quot;);
 528     // Old functionality:
 529     //   return
 530     // New functionality:
 531     //   Assert if the local is not top. In product mode let the new node
 532     //   override the old entry.
 533     assert(local == top(), &quot;LocArray collision&quot;);
 534     if (local == top()) {
 535       return;
 536     }
 537     array-&gt;pop();
 538   }
 539   const Type *t = local-&gt;bottom_type();
 540 
 541   // Is it a safepoint scalar object node?
 542   if (local-&gt;is_SafePointScalarObject()) {
 543     SafePointScalarObjectNode* spobj = local-&gt;as_SafePointScalarObject();
 544 
 545     ObjectValue* sv = Compile::sv_for_node_id(objs, spobj-&gt;_idx);
 546     if (sv == NULL) {
 547       ciKlass* cik = t-&gt;is_oopptr()-&gt;klass();
 548       assert(cik-&gt;is_instance_klass() ||
 549              cik-&gt;is_array_klass(), &quot;Not supported allocation.&quot;);
 550       sv = new ObjectValue(spobj-&gt;_idx,
 551                            new ConstantOopWriteValue(cik-&gt;java_mirror()-&gt;constant_encoding()));
 552       Compile::set_sv_for_object_node(objs, sv);
 553 
 554       uint first_ind = spobj-&gt;first_index(sfpt-&gt;jvms());
 555       for (uint i = 0; i &lt; spobj-&gt;n_fields(); i++) {
 556         Node* fld_node = sfpt-&gt;in(first_ind+i);
 557         (void)FillLocArray(sv-&gt;field_values()-&gt;length(), sfpt, fld_node, sv-&gt;field_values(), objs);
 558       }
 559     }
 560     array-&gt;append(sv);
 561     return;
 562   }
 563 
 564   // Grab the register number for the local
 565   OptoReg::Name regnum = _regalloc-&gt;get_reg_first(local);
 566   if( OptoReg::is_valid(regnum) ) {// Got a register/stack?
 567     // Record the double as two float registers.
 568     // The register mask for such a value always specifies two adjacent
 569     // float registers, with the lower register number even.
 570     // Normally, the allocation of high and low words to these registers
 571     // is irrelevant, because nearly all operations on register pairs
 572     // (e.g., StoreD) treat them as a single unit.
 573     // Here, we assume in addition that the words in these two registers
 574     // stored &quot;naturally&quot; (by operations like StoreD and double stores
 575     // within the interpreter) such that the lower-numbered register
 576     // is written to the lower memory address.  This may seem like
 577     // a machine dependency, but it is not--it is a requirement on
 578     // the author of the &lt;arch&gt;.ad file to ensure that, for every
 579     // even/odd double-register pair to which a double may be allocated,
 580     // the word in the even single-register is stored to the first
 581     // memory word.  (Note that register numbers are completely
 582     // arbitrary, and are not tied to any machine-level encodings.)
 583 #ifdef _LP64
 584     if( t-&gt;base() == Type::DoubleBot || t-&gt;base() == Type::DoubleCon ) {
 585       array-&gt;append(new ConstantIntValue((jint)0));
 586       array-&gt;append(new_loc_value( _regalloc, regnum, Location::dbl ));
 587     } else if ( t-&gt;base() == Type::Long ) {
 588       array-&gt;append(new ConstantIntValue((jint)0));
 589       array-&gt;append(new_loc_value( _regalloc, regnum, Location::lng ));
 590     } else if ( t-&gt;base() == Type::RawPtr ) {
 591       // jsr/ret return address which must be restored into a the full
 592       // width 64-bit stack slot.
 593       array-&gt;append(new_loc_value( _regalloc, regnum, Location::lng ));
 594     }
 595 #else //_LP64
 596 #ifdef SPARC
 597     if (t-&gt;base() == Type::Long &amp;&amp; OptoReg::is_reg(regnum)) {
 598       // For SPARC we have to swap high and low words for
 599       // long values stored in a single-register (g0-g7).
 600       array-&gt;append(new_loc_value( _regalloc,              regnum   , Location::normal ));
 601       array-&gt;append(new_loc_value( _regalloc, OptoReg::add(regnum,1), Location::normal ));
 602     } else
 603 #endif //SPARC
 604     if( t-&gt;base() == Type::DoubleBot || t-&gt;base() == Type::DoubleCon || t-&gt;base() == Type::Long ) {
 605       // Repack the double/long as two jints.
 606       // The convention the interpreter uses is that the second local
 607       // holds the first raw word of the native double representation.
 608       // This is actually reasonable, since locals and stack arrays
 609       // grow downwards in all implementations.
 610       // (If, on some machine, the interpreter&#39;s Java locals or stack
 611       // were to grow upwards, the embedded doubles would be word-swapped.)
 612       array-&gt;append(new_loc_value( _regalloc, OptoReg::add(regnum,1), Location::normal ));
 613       array-&gt;append(new_loc_value( _regalloc,              regnum   , Location::normal ));
 614     }
 615 #endif //_LP64
 616     else if( (t-&gt;base() == Type::FloatBot || t-&gt;base() == Type::FloatCon) &amp;&amp;
 617              OptoReg::is_reg(regnum) ) {
 618       array-&gt;append(new_loc_value( _regalloc, regnum, Matcher::float_in_double()
 619                                                       ? Location::float_in_dbl : Location::normal ));
 620     } else if( t-&gt;base() == Type::Int &amp;&amp; OptoReg::is_reg(regnum) ) {
 621       array-&gt;append(new_loc_value( _regalloc, regnum, Matcher::int_in_long
 622                                                       ? Location::int_in_long : Location::normal ));
 623     } else if( t-&gt;base() == Type::NarrowOop ) {
 624       array-&gt;append(new_loc_value( _regalloc, regnum, Location::narrowoop ));
 625     } else {
 626       array-&gt;append(new_loc_value( _regalloc, regnum, _regalloc-&gt;is_oop(local) ? Location::oop : Location::normal ));
 627     }
 628     return;
 629   }
 630 
 631   // No register.  It must be constant data.
 632   switch (t-&gt;base()) {
 633     case Type::Half:              // Second half of a double
 634       ShouldNotReachHere();       // Caller should skip 2nd halves
 635       break;
 636     case Type::AnyPtr:
 637       array-&gt;append(new ConstantOopWriteValue(NULL));
 638       break;
 639     case Type::AryPtr:
 640     case Type::InstPtr:          // fall through
 641       array-&gt;append(new ConstantOopWriteValue(t-&gt;isa_oopptr()-&gt;const_oop()-&gt;constant_encoding()));
 642       break;
 643     case Type::NarrowOop:
 644       if (t == TypeNarrowOop::NULL_PTR) {
 645         array-&gt;append(new ConstantOopWriteValue(NULL));
 646       } else {
 647         array-&gt;append(new ConstantOopWriteValue(t-&gt;make_ptr()-&gt;isa_oopptr()-&gt;const_oop()-&gt;constant_encoding()));
 648       }
 649       break;
 650     case Type::Int:
 651       array-&gt;append(new ConstantIntValue(t-&gt;is_int()-&gt;get_con()));
 652       break;
 653     case Type::RawPtr:
 654       // A return address (T_ADDRESS).
 655       assert((intptr_t)t-&gt;is_ptr()-&gt;get_con() &lt; (intptr_t)0x10000, &quot;must be a valid BCI&quot;);
 656 #ifdef _LP64
 657       // Must be restored to the full-width 64-bit stack slot.
 658       array-&gt;append(new ConstantLongValue(t-&gt;is_ptr()-&gt;get_con()));
 659 #else
 660       array-&gt;append(new ConstantIntValue(t-&gt;is_ptr()-&gt;get_con()));
 661 #endif
 662       break;
 663     case Type::FloatCon: {
 664       float f = t-&gt;is_float_constant()-&gt;getf();
 665       array-&gt;append(new ConstantIntValue(jint_cast(f)));
 666       break;
 667     }
 668     case Type::DoubleCon: {
 669       jdouble d = t-&gt;is_double_constant()-&gt;getd();
 670 #ifdef _LP64
 671       array-&gt;append(new ConstantIntValue((jint)0));
 672       array-&gt;append(new ConstantDoubleValue(d));
 673 #else
 674       // Repack the double as two jints.
 675     // The convention the interpreter uses is that the second local
 676     // holds the first raw word of the native double representation.
 677     // This is actually reasonable, since locals and stack arrays
 678     // grow downwards in all implementations.
 679     // (If, on some machine, the interpreter&#39;s Java locals or stack
 680     // were to grow upwards, the embedded doubles would be word-swapped.)
 681     jlong_accessor acc;
 682     acc.long_value = jlong_cast(d);
 683     array-&gt;append(new ConstantIntValue(acc.words[1]));
 684     array-&gt;append(new ConstantIntValue(acc.words[0]));
 685 #endif
 686       break;
 687     }
 688     case Type::Long: {
 689       jlong d = t-&gt;is_long()-&gt;get_con();
 690 #ifdef _LP64
 691       array-&gt;append(new ConstantIntValue((jint)0));
 692       array-&gt;append(new ConstantLongValue(d));
 693 #else
 694       // Repack the long as two jints.
 695     // The convention the interpreter uses is that the second local
 696     // holds the first raw word of the native double representation.
 697     // This is actually reasonable, since locals and stack arrays
 698     // grow downwards in all implementations.
 699     // (If, on some machine, the interpreter&#39;s Java locals or stack
 700     // were to grow upwards, the embedded doubles would be word-swapped.)
 701     jlong_accessor acc;
 702     acc.long_value = d;
 703     array-&gt;append(new ConstantIntValue(acc.words[1]));
 704     array-&gt;append(new ConstantIntValue(acc.words[0]));
 705 #endif
 706       break;
 707     }
 708     case Type::Top:               // Add an illegal value here
 709       array-&gt;append(new LocationValue(Location()));
 710       break;
 711     default:
 712       ShouldNotReachHere();
 713       break;
 714   }
 715 }
 716 
 717 // Determine if this node starts a bundle
 718 bool Compile::starts_bundle(const Node *n) const {
 719   return (_node_bundling_limit &gt; n-&gt;_idx &amp;&amp;
 720           _node_bundling_base[n-&gt;_idx].starts_bundle());
 721 }
 722 
 723 //--------------------------Process_OopMap_Node--------------------------------
 724 void Compile::Process_OopMap_Node(MachNode *mach, int current_offset) {
 725 
 726   // Handle special safepoint nodes for synchronization
 727   MachSafePointNode *sfn   = mach-&gt;as_MachSafePoint();
 728   MachCallNode      *mcall;
 729 
 730   int safepoint_pc_offset = current_offset;
 731   bool is_method_handle_invoke = false;
 732   bool return_oop = false;
 733 
 734   // Add the safepoint in the DebugInfoRecorder
 735   if( !mach-&gt;is_MachCall() ) {
 736     mcall = NULL;
 737     debug_info()-&gt;add_safepoint(safepoint_pc_offset, sfn-&gt;_oop_map);
 738   } else {
 739     mcall = mach-&gt;as_MachCall();
 740 
 741     // Is the call a MethodHandle call?
 742     if (mcall-&gt;is_MachCallJava()) {
 743       if (mcall-&gt;as_MachCallJava()-&gt;_method_handle_invoke) {
 744         assert(has_method_handle_invokes(), &quot;must have been set during call generation&quot;);
 745         is_method_handle_invoke = true;
 746       }
 747     }
 748 
 749     // Check if a call returns an object.
 750     if (mcall-&gt;returns_pointer()) {
 751       return_oop = true;
 752     }
 753     safepoint_pc_offset += mcall-&gt;ret_addr_offset();
 754     debug_info()-&gt;add_safepoint(safepoint_pc_offset, mcall-&gt;_oop_map);
 755   }
 756 
 757   // Loop over the JVMState list to add scope information
 758   // Do not skip safepoints with a NULL method, they need monitor info
 759   JVMState* youngest_jvms = sfn-&gt;jvms();
 760   int max_depth = youngest_jvms-&gt;depth();
 761 
 762   // Allocate the object pool for scalar-replaced objects -- the map from
 763   // small-integer keys (which can be recorded in the local and ostack
 764   // arrays) to descriptions of the object state.
 765   GrowableArray&lt;ScopeValue*&gt; *objs = new GrowableArray&lt;ScopeValue*&gt;();
 766 
 767   // Visit scopes from oldest to youngest.
 768   for (int depth = 1; depth &lt;= max_depth; depth++) {
 769     JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
 770     int idx;
 771     ciMethod* method = jvms-&gt;has_method() ? jvms-&gt;method() : NULL;
 772     // Safepoints that do not have method() set only provide oop-map and monitor info
 773     // to support GC; these do not support deoptimization.
 774     int num_locs = (method == NULL) ? 0 : jvms-&gt;loc_size();
 775     int num_exps = (method == NULL) ? 0 : jvms-&gt;stk_size();
 776     int num_mon  = jvms-&gt;nof_monitors();
 777     assert(method == NULL || jvms-&gt;bci() &lt; 0 || num_locs == method-&gt;max_locals(),
 778            &quot;JVMS local count must match that of the method&quot;);
 779 
 780     // Add Local and Expression Stack Information
 781 
 782     // Insert locals into the locarray
 783     GrowableArray&lt;ScopeValue*&gt; *locarray = new GrowableArray&lt;ScopeValue*&gt;(num_locs);
 784     for( idx = 0; idx &lt; num_locs; idx++ ) {
 785       FillLocArray( idx, sfn, sfn-&gt;local(jvms, idx), locarray, objs );
 786     }
 787 
 788     // Insert expression stack entries into the exparray
 789     GrowableArray&lt;ScopeValue*&gt; *exparray = new GrowableArray&lt;ScopeValue*&gt;(num_exps);
 790     for( idx = 0; idx &lt; num_exps; idx++ ) {
 791       FillLocArray( idx,  sfn, sfn-&gt;stack(jvms, idx), exparray, objs );
 792     }
 793 
 794     // Add in mappings of the monitors
 795     assert( !method ||
 796             !method-&gt;is_synchronized() ||
 797             method-&gt;is_native() ||
 798             num_mon &gt; 0 ||
 799             !GenerateSynchronizationCode,
 800             &quot;monitors must always exist for synchronized methods&quot;);
 801 
 802     // Build the growable array of ScopeValues for exp stack
 803     GrowableArray&lt;MonitorValue*&gt; *monarray = new GrowableArray&lt;MonitorValue*&gt;(num_mon);
 804 
 805     // Loop over monitors and insert into array
 806     for (idx = 0; idx &lt; num_mon; idx++) {
 807       // Grab the node that defines this monitor
 808       Node* box_node = sfn-&gt;monitor_box(jvms, idx);
 809       Node* obj_node = sfn-&gt;monitor_obj(jvms, idx);
 810 
 811       // Create ScopeValue for object
 812       ScopeValue *scval = NULL;
 813 
 814       if (obj_node-&gt;is_SafePointScalarObject()) {
 815         SafePointScalarObjectNode* spobj = obj_node-&gt;as_SafePointScalarObject();
 816         scval = Compile::sv_for_node_id(objs, spobj-&gt;_idx);
 817         if (scval == NULL) {
 818           const Type *t = spobj-&gt;bottom_type();
 819           ciKlass* cik = t-&gt;is_oopptr()-&gt;klass();
 820           assert(cik-&gt;is_instance_klass() ||
 821                  cik-&gt;is_array_klass(), &quot;Not supported allocation.&quot;);
 822           ObjectValue* sv = new ObjectValue(spobj-&gt;_idx,
 823                                             new ConstantOopWriteValue(cik-&gt;java_mirror()-&gt;constant_encoding()));
 824           Compile::set_sv_for_object_node(objs, sv);
 825 
 826           uint first_ind = spobj-&gt;first_index(youngest_jvms);
 827           for (uint i = 0; i &lt; spobj-&gt;n_fields(); i++) {
 828             Node* fld_node = sfn-&gt;in(first_ind+i);
 829             (void)FillLocArray(sv-&gt;field_values()-&gt;length(), sfn, fld_node, sv-&gt;field_values(), objs);
 830           }
 831           scval = sv;
 832         }
 833       } else if (!obj_node-&gt;is_Con()) {
 834         OptoReg::Name obj_reg = _regalloc-&gt;get_reg_first(obj_node);
 835         if( obj_node-&gt;bottom_type()-&gt;base() == Type::NarrowOop ) {
 836           scval = new_loc_value( _regalloc, obj_reg, Location::narrowoop );
 837         } else {
 838           scval = new_loc_value( _regalloc, obj_reg, Location::oop );
 839         }
 840       } else {
 841         const TypePtr *tp = obj_node-&gt;get_ptr_type();
 842         scval = new ConstantOopWriteValue(tp-&gt;is_oopptr()-&gt;const_oop()-&gt;constant_encoding());
 843       }
 844 
 845       OptoReg::Name box_reg = BoxLockNode::reg(box_node);
 846       Location basic_lock = Location::new_stk_loc(Location::normal,_regalloc-&gt;reg2offset(box_reg));
 847       bool eliminated = (box_node-&gt;is_BoxLock() &amp;&amp; box_node-&gt;as_BoxLock()-&gt;is_eliminated());
 848       monarray-&gt;append(new MonitorValue(scval, basic_lock, eliminated));
 849     }
 850 
 851     // We dump the object pool first, since deoptimization reads it in first.
 852     debug_info()-&gt;dump_object_pool(objs);
 853 
 854     // Build first class objects to pass to scope
 855     DebugToken *locvals = debug_info()-&gt;create_scope_values(locarray);
 856     DebugToken *expvals = debug_info()-&gt;create_scope_values(exparray);
 857     DebugToken *monvals = debug_info()-&gt;create_monitor_values(monarray);
 858 
 859     // Make method available for all Safepoints
 860     ciMethod* scope_method = method ? method : _method;
 861     // Describe the scope here
 862     assert(jvms-&gt;bci() &gt;= InvocationEntryBci &amp;&amp; jvms-&gt;bci() &lt;= 0x10000, &quot;must be a valid or entry BCI&quot;);
 863     assert(!jvms-&gt;should_reexecute() || depth == max_depth, &quot;reexecute allowed only for the youngest&quot;);
 864     // Now we can describe the scope.
 865     methodHandle null_mh;
 866     bool rethrow_exception = false;
 867     debug_info()-&gt;describe_scope(safepoint_pc_offset, null_mh, scope_method, jvms-&gt;bci(), jvms-&gt;should_reexecute(), rethrow_exception, is_method_handle_invoke, return_oop, locvals, expvals, monvals);
 868   } // End jvms loop
 869 
 870   // Mark the end of the scope set.
 871   debug_info()-&gt;end_safepoint(safepoint_pc_offset);
 872 }
 873 
 874 
 875 
 876 // A simplified version of Process_OopMap_Node, to handle non-safepoints.
 877 class NonSafepointEmitter {
 878     Compile*  C;
 879     JVMState* _pending_jvms;
 880     int       _pending_offset;
 881 
 882     void emit_non_safepoint();
 883 
 884  public:
 885     NonSafepointEmitter(Compile* compile) {
 886       this-&gt;C = compile;
 887       _pending_jvms = NULL;
 888       _pending_offset = 0;
 889     }
 890 
 891     void observe_instruction(Node* n, int pc_offset) {
 892       if (!C-&gt;debug_info()-&gt;recording_non_safepoints())  return;
 893 
 894       Node_Notes* nn = C-&gt;node_notes_at(n-&gt;_idx);
 895       if (nn == NULL || nn-&gt;jvms() == NULL)  return;
 896       if (_pending_jvms != NULL &amp;&amp;
 897           _pending_jvms-&gt;same_calls_as(nn-&gt;jvms())) {
 898         // Repeated JVMS?  Stretch it up here.
 899         _pending_offset = pc_offset;
 900       } else {
 901         if (_pending_jvms != NULL &amp;&amp;
 902             _pending_offset &lt; pc_offset) {
 903           emit_non_safepoint();
 904         }
 905         _pending_jvms = NULL;
 906         if (pc_offset &gt; C-&gt;debug_info()-&gt;last_pc_offset()) {
 907           // This is the only way _pending_jvms can become non-NULL:
 908           _pending_jvms = nn-&gt;jvms();
 909           _pending_offset = pc_offset;
 910         }
 911       }
 912     }
 913 
 914     // Stay out of the way of real safepoints:
 915     void observe_safepoint(JVMState* jvms, int pc_offset) {
 916       if (_pending_jvms != NULL &amp;&amp;
 917           !_pending_jvms-&gt;same_calls_as(jvms) &amp;&amp;
 918           _pending_offset &lt; pc_offset) {
 919         emit_non_safepoint();
 920       }
 921       _pending_jvms = NULL;
 922     }
 923 
 924     void flush_at_end() {
 925       if (_pending_jvms != NULL) {
 926         emit_non_safepoint();
 927       }
 928       _pending_jvms = NULL;
 929     }
 930 };
 931 
 932 void NonSafepointEmitter::emit_non_safepoint() {
 933   JVMState* youngest_jvms = _pending_jvms;
 934   int       pc_offset     = _pending_offset;
 935 
 936   // Clear it now:
 937   _pending_jvms = NULL;
 938 
 939   DebugInformationRecorder* debug_info = C-&gt;debug_info();
 940   assert(debug_info-&gt;recording_non_safepoints(), &quot;sanity&quot;);
 941 
 942   debug_info-&gt;add_non_safepoint(pc_offset);
 943   int max_depth = youngest_jvms-&gt;depth();
 944 
 945   // Visit scopes from oldest to youngest.
 946   for (int depth = 1; depth &lt;= max_depth; depth++) {
 947     JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
 948     ciMethod* method = jvms-&gt;has_method() ? jvms-&gt;method() : NULL;
 949     assert(!jvms-&gt;should_reexecute() || depth==max_depth, &quot;reexecute allowed only for the youngest&quot;);
 950     methodHandle null_mh;
 951     debug_info-&gt;describe_scope(pc_offset, null_mh, method, jvms-&gt;bci(), jvms-&gt;should_reexecute());
 952   }
 953 
 954   // Mark the end of the scope set.
 955   debug_info-&gt;end_non_safepoint(pc_offset);
 956 }
 957 
 958 //------------------------------init_buffer------------------------------------
 959 void Compile::estimate_buffer_size(int&amp; const_req) {
 960 
 961   // Set the initially allocated size
 962   const_req = initial_const_capacity;
 963 
 964   // The extra spacing after the code is necessary on some platforms.
 965   // Sometimes we need to patch in a jump after the last instruction,
 966   // if the nmethod has been deoptimized.  (See 4932387, 4894843.)
 967 
 968   // Compute the byte offset where we can store the deopt pc.
 969   if (fixed_slots() != 0) {
 970     _orig_pc_slot_offset_in_bytes = _regalloc-&gt;reg2offset(OptoReg::stack2reg(_orig_pc_slot));
 971   }
 972 
 973   // Compute prolog code size
 974   _method_size = 0;
 975   _frame_slots = OptoReg::reg2stack(_matcher-&gt;_old_SP) + _regalloc-&gt;_framesize;
 976 #if defined(IA64) &amp;&amp; !defined(AIX)
 977   if (save_argument_registers()) {
 978     // 4815101: this is a stub with implicit and unknown precision fp args.
 979     // The usual spill mechanism can only generate stfd&#39;s in this case, which
 980     // doesn&#39;t work if the fp reg to spill contains a single-precision denorm.
 981     // Instead, we hack around the normal spill mechanism using stfspill&#39;s and
 982     // ldffill&#39;s in the MachProlog and MachEpilog emit methods.  We allocate
 983     // space here for the fp arg regs (f8-f15) we&#39;re going to thusly spill.
 984     //
 985     // If we ever implement 16-byte &#39;registers&#39; == stack slots, we can
 986     // get rid of this hack and have SpillCopy generate stfspill/ldffill
 987     // instead of stfd/stfs/ldfd/ldfs.
 988     _frame_slots += 8*(16/BytesPerInt);
 989   }
 990 #endif
 991   assert(_frame_slots &gt;= 0 &amp;&amp; _frame_slots &lt; 1000000, &quot;sanity check&quot;);
 992 
 993   if (has_mach_constant_base_node()) {
 994     uint add_size = 0;
 995     // Fill the constant table.
 996     // Note:  This must happen before shorten_branches.
 997     for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {
 998       Block* b = _cfg-&gt;get_block(i);
 999 
1000       for (uint j = 0; j &lt; b-&gt;number_of_nodes(); j++) {
1001         Node* n = b-&gt;get_node(j);
1002 
1003         // If the node is a MachConstantNode evaluate the constant
1004         // value section.
1005         if (n-&gt;is_MachConstant()) {
1006           MachConstantNode* machcon = n-&gt;as_MachConstant();
1007           machcon-&gt;eval_constant(C);
1008         } else if (n-&gt;is_Mach()) {
1009           // On Power there are more nodes that issue constants.
1010           add_size += (n-&gt;as_Mach()-&gt;ins_num_consts() * 8);
1011         }
1012       }
1013     }
1014 
1015     // Calculate the offsets of the constants and the size of the
1016     // constant table (including the padding to the next section).
1017     constant_table().calculate_offsets_and_size();
1018     const_req = constant_table().size() + add_size;
1019   }
1020 
1021   // Initialize the space for the BufferBlob used to find and verify
1022   // instruction size in MachNode::emit_size()
1023   init_scratch_buffer_blob(const_req);
1024 }
1025 
1026 CodeBuffer* Compile::init_buffer(BufferSizingData&amp; buf_sizes) {
1027 
1028   int stub_req  = buf_sizes._stub;
1029   int code_req  = buf_sizes._code;
1030   int const_req = buf_sizes._const;
1031 
1032   int pad_req   = NativeCall::instruction_size;
1033 
1034   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1035   stub_req += bs-&gt;estimate_stub_size();
1036 
1037   // nmethod and CodeBuffer count stubs &amp; constants as part of method&#39;s code.
1038   // class HandlerImpl is platform-specific and defined in the *.ad files.
1039   int exception_handler_req = HandlerImpl::size_exception_handler() + MAX_stubs_size; // add marginal slop for handler
1040   int deopt_handler_req     = HandlerImpl::size_deopt_handler()     + MAX_stubs_size; // add marginal slop for handler
1041   stub_req += MAX_stubs_size;   // ensure per-stub margin
1042   code_req += MAX_inst_size;    // ensure per-instruction margin
1043 
1044   if (StressCodeBuffers)
1045     code_req = const_req = stub_req = exception_handler_req = deopt_handler_req = 0x10;  // force expansion
1046 
1047   int total_req =
1048           const_req +
1049           code_req +
1050           pad_req +
1051           stub_req +
1052           exception_handler_req +
1053           deopt_handler_req;               // deopt handler
1054 
1055   if (has_method_handle_invokes())
1056     total_req += deopt_handler_req;  // deopt MH handler
1057 
1058   CodeBuffer* cb = code_buffer();
1059   cb-&gt;initialize(total_req, buf_sizes._reloc);
1060 
1061   // Have we run out of code space?
1062   if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1063     C-&gt;record_failure(&quot;CodeCache is full&quot;);
1064     return NULL;
1065   }
1066   // Configure the code buffer.
1067   cb-&gt;initialize_consts_size(const_req);
1068   cb-&gt;initialize_stubs_size(stub_req);
1069   cb-&gt;initialize_oop_recorder(env()-&gt;oop_recorder());
1070 
1071   // fill in the nop array for bundling computations
1072   MachNode *_nop_list[Bundle::_nop_count];
1073   Bundle::initialize_nops(_nop_list);
1074 
1075   return cb;
1076 }
1077 
1078 //------------------------------fill_buffer------------------------------------
1079 void Compile::fill_buffer(CodeBuffer* cb, uint* blk_starts) {
1080   // blk_starts[] contains offsets calculated during short branches processing,
1081   // offsets should not be increased during following steps.
1082 
1083   // Compute the size of first NumberOfLoopInstrToAlign instructions at head
1084   // of a loop. It is used to determine the padding for loop alignment.
1085   compute_loop_first_inst_sizes();
1086 
1087   // Create oopmap set.
1088   _oop_map_set = new OopMapSet();
1089 
1090   // !!!!! This preserves old handling of oopmaps for now
1091   debug_info()-&gt;set_oopmaps(_oop_map_set);
1092 
1093   uint nblocks  = _cfg-&gt;number_of_blocks();
1094   // Count and start of implicit null check instructions
1095   uint inct_cnt = 0;
1096   uint *inct_starts = NEW_RESOURCE_ARRAY(uint, nblocks+1);
1097 
1098   // Count and start of calls
1099   uint *call_returns = NEW_RESOURCE_ARRAY(uint, nblocks+1);
1100 
1101   uint  return_offset = 0;
1102   int nop_size = (new MachNopNode())-&gt;size(_regalloc);
1103 
1104   int previous_offset = 0;
1105   int current_offset  = 0;
1106   int last_call_offset = -1;
1107   int last_avoid_back_to_back_offset = -1;
1108 #ifdef ASSERT
1109   uint* jmp_target = NEW_RESOURCE_ARRAY(uint,nblocks);
1110   uint* jmp_offset = NEW_RESOURCE_ARRAY(uint,nblocks);
1111   uint* jmp_size   = NEW_RESOURCE_ARRAY(uint,nblocks);
1112   uint* jmp_rule   = NEW_RESOURCE_ARRAY(uint,nblocks);
1113 #endif
1114 
1115   // Create an array of unused labels, one for each basic block, if printing is enabled
1116 #if defined(SUPPORT_OPTO_ASSEMBLY)
1117   int *node_offsets      = NULL;
1118   uint node_offset_limit = unique();
1119 
1120   if (print_assembly()) {
1121     node_offsets = NEW_RESOURCE_ARRAY(int, node_offset_limit);
1122   }
1123   if (node_offsets != NULL) {
1124     // We need to initialize. Unused array elements may contain garbage and mess up PrintOptoAssembly.
1125     memset(node_offsets, 0, node_offset_limit*sizeof(int));
1126   }
1127 #endif
1128 
1129   NonSafepointEmitter non_safepoints(this);  // emit non-safepoints lazily
1130 
1131   // Emit the constant table.
1132   if (has_mach_constant_base_node()) {
1133     constant_table().emit(*cb);
1134   }
1135 
1136   // Create an array of labels, one for each basic block
1137   Label *blk_labels = NEW_RESOURCE_ARRAY(Label, nblocks+1);
1138   for (uint i=0; i &lt;= nblocks; i++) {
1139     blk_labels[i].init();
1140   }
1141 
1142   // ------------------
1143   // Now fill in the code buffer
1144   Node *delay_slot = NULL;
1145 
1146   for (uint i = 0; i &lt; nblocks; i++) {
1147     Block* block = _cfg-&gt;get_block(i);
1148     Node* head = block-&gt;head();
1149 
1150     // If this block needs to start aligned (i.e, can be reached other
1151     // than by falling-thru from the previous block), then force the
1152     // start of a new bundle.
1153     if (Pipeline::requires_bundling() &amp;&amp; starts_bundle(head)) {
1154       cb-&gt;flush_bundle(true);
1155     }
1156 
1157 #ifdef ASSERT
1158     if (!block-&gt;is_connector()) {
1159       stringStream st;
1160       block-&gt;dump_head(_cfg, &amp;st);
1161       MacroAssembler(cb).block_comment(st.as_string());
1162     }
1163     jmp_target[i] = 0;
1164     jmp_offset[i] = 0;
1165     jmp_size[i]   = 0;
1166     jmp_rule[i]   = 0;
1167 #endif
1168     int blk_offset = current_offset;
1169 
1170     // Define the label at the beginning of the basic block
1171     MacroAssembler(cb).bind(blk_labels[block-&gt;_pre_order]);
1172 
1173     uint last_inst = block-&gt;number_of_nodes();
1174 
1175     // Emit block normally, except for last instruction.
1176     // Emit means &quot;dump code bits into code buffer&quot;.
1177     for (uint j = 0; j&lt;last_inst; j++) {
1178 
1179       // Get the node
1180       Node* n = block-&gt;get_node(j);
1181 
1182       // See if delay slots are supported
1183       if (valid_bundle_info(n) &amp;&amp;
1184           node_bundling(n)-&gt;used_in_unconditional_delay()) {
1185         assert(delay_slot == NULL, &quot;no use of delay slot node&quot;);
1186         assert(n-&gt;size(_regalloc) == Pipeline::instr_unit_size(), &quot;delay slot instruction wrong size&quot;);
1187 
1188         delay_slot = n;
1189         continue;
1190       }
1191 
1192       // If this starts a new instruction group, then flush the current one
1193       // (but allow split bundles)
1194       if (Pipeline::requires_bundling() &amp;&amp; starts_bundle(n))
1195         cb-&gt;flush_bundle(false);
1196 
1197       // Special handling for SafePoint/Call Nodes
1198       bool is_mcall = false;
1199       if (n-&gt;is_Mach()) {
1200         MachNode *mach = n-&gt;as_Mach();
1201         is_mcall = n-&gt;is_MachCall();
1202         bool is_sfn = n-&gt;is_MachSafePoint();
1203 
1204         // If this requires all previous instructions be flushed, then do so
1205         if (is_sfn || is_mcall || mach-&gt;alignment_required() != 1) {
1206           cb-&gt;flush_bundle(true);
1207           current_offset = cb-&gt;insts_size();
1208         }
1209 
1210         // A padding may be needed again since a previous instruction
1211         // could be moved to delay slot.
1212 
1213         // align the instruction if necessary
1214         int padding = mach-&gt;compute_padding(current_offset);
1215         // Make sure safepoint node for polling is distinct from a call&#39;s
1216         // return by adding a nop if needed.
1217         if (is_sfn &amp;&amp; !is_mcall &amp;&amp; padding == 0 &amp;&amp; current_offset == last_call_offset) {
1218           padding = nop_size;
1219         }
1220         if (padding == 0 &amp;&amp; mach-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE) &amp;&amp;
1221             current_offset == last_avoid_back_to_back_offset) {
1222           // Avoid back to back some instructions.
1223           padding = nop_size;
1224         }
1225 
1226         if (padding &gt; 0) {
1227           assert((padding % nop_size) == 0, &quot;padding is not a multiple of NOP size&quot;);
1228           int nops_cnt = padding / nop_size;
1229           MachNode *nop = new MachNopNode(nops_cnt);
1230           block-&gt;insert_node(nop, j++);
1231           last_inst++;
1232           _cfg-&gt;map_node_to_block(nop, block);
1233           // Ensure enough space.
1234           cb-&gt;insts()-&gt;maybe_expand_to_ensure_remaining(MAX_inst_size);
1235           if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1236             C-&gt;record_failure(&quot;CodeCache is full&quot;);
1237             return;
1238           }
1239           nop-&gt;emit(*cb, _regalloc);
1240           cb-&gt;flush_bundle(true);
1241           current_offset = cb-&gt;insts_size();
1242         }
1243 
1244         // Remember the start of the last call in a basic block
1245         if (is_mcall) {
1246           MachCallNode *mcall = mach-&gt;as_MachCall();
1247 
1248           // This destination address is NOT PC-relative
1249           mcall-&gt;method_set((intptr_t)mcall-&gt;entry_point());
1250 
1251           // Save the return address
1252           call_returns[block-&gt;_pre_order] = current_offset + mcall-&gt;ret_addr_offset();
1253 
1254           if (mcall-&gt;is_MachCallLeaf()) {
1255             is_mcall = false;
1256             is_sfn = false;
1257           }
1258         }
1259 
1260         // sfn will be valid whenever mcall is valid now because of inheritance
1261         if (is_sfn || is_mcall) {
1262 
1263           // Handle special safepoint nodes for synchronization
1264           if (!is_mcall) {
1265             MachSafePointNode *sfn = mach-&gt;as_MachSafePoint();
1266             // !!!!! Stubs only need an oopmap right now, so bail out
1267             if (sfn-&gt;jvms()-&gt;method() == NULL) {
1268               // Write the oopmap directly to the code blob??!!
1269               continue;
1270             }
1271           } // End synchronization
1272 
1273           non_safepoints.observe_safepoint(mach-&gt;as_MachSafePoint()-&gt;jvms(),
1274                                            current_offset);
1275           Process_OopMap_Node(mach, current_offset);
1276         } // End if safepoint
1277 
1278           // If this is a null check, then add the start of the previous instruction to the list
1279         else if( mach-&gt;is_MachNullCheck() ) {
1280           inct_starts[inct_cnt++] = previous_offset;
1281         }
1282 
1283           // If this is a branch, then fill in the label with the target BB&#39;s label
1284         else if (mach-&gt;is_MachBranch()) {
1285           // This requires the TRUE branch target be in succs[0]
1286           uint block_num = block-&gt;non_connector_successor(0)-&gt;_pre_order;
1287 
1288           // Try to replace long branch if delay slot is not used,
1289           // it is mostly for back branches since forward branch&#39;s
1290           // distance is not updated yet.
1291           bool delay_slot_is_used = valid_bundle_info(n) &amp;&amp;
1292                                     node_bundling(n)-&gt;use_unconditional_delay();
1293           if (!delay_slot_is_used &amp;&amp; mach-&gt;may_be_short_branch()) {
1294             assert(delay_slot == NULL, &quot;not expecting delay slot node&quot;);
1295             int br_size = n-&gt;size(_regalloc);
1296             int offset = blk_starts[block_num] - current_offset;
1297             if (block_num &gt;= i) {
1298               // Current and following block&#39;s offset are not
1299               // finalized yet, adjust distance by the difference
1300               // between calculated and final offsets of current block.
1301               offset -= (blk_starts[i] - blk_offset);
1302             }
1303             // In the following code a nop could be inserted before
1304             // the branch which will increase the backward distance.
1305             bool needs_padding = (current_offset == last_avoid_back_to_back_offset);
1306             if (needs_padding &amp;&amp; offset &lt;= 0)
1307               offset -= nop_size;
1308 
1309             if (_matcher-&gt;is_short_branch_offset(mach-&gt;rule(), br_size, offset)) {
1310               // We&#39;ve got a winner.  Replace this branch.
1311               MachNode* replacement = mach-&gt;as_MachBranch()-&gt;short_branch_version();
1312 
1313               // Update the jmp_size.
1314               int new_size = replacement-&gt;size(_regalloc);
1315               assert((br_size - new_size) &gt;= (int)nop_size, &quot;short_branch size should be smaller&quot;);
1316               // Insert padding between avoid_back_to_back branches.
1317               if (needs_padding &amp;&amp; replacement-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
1318                 MachNode *nop = new MachNopNode();
1319                 block-&gt;insert_node(nop, j++);
1320                 _cfg-&gt;map_node_to_block(nop, block);
1321                 last_inst++;
1322                 nop-&gt;emit(*cb, _regalloc);
1323                 cb-&gt;flush_bundle(true);
1324                 current_offset = cb-&gt;insts_size();
1325               }
1326 #ifdef ASSERT
1327               jmp_target[i] = block_num;
1328               jmp_offset[i] = current_offset - blk_offset;
1329               jmp_size[i]   = new_size;
1330               jmp_rule[i]   = mach-&gt;rule();
1331 #endif
1332               block-&gt;map_node(replacement, j);
1333               mach-&gt;subsume_by(replacement, C);
1334               n    = replacement;
1335               mach = replacement;
1336             }
1337           }
1338           mach-&gt;as_MachBranch()-&gt;label_set( &amp;blk_labels[block_num], block_num );
1339         } else if (mach-&gt;ideal_Opcode() == Op_Jump) {
1340           for (uint h = 0; h &lt; block-&gt;_num_succs; h++) {
1341             Block* succs_block = block-&gt;_succs[h];
1342             for (uint j = 1; j &lt; succs_block-&gt;num_preds(); j++) {
1343               Node* jpn = succs_block-&gt;pred(j);
1344               if (jpn-&gt;is_JumpProj() &amp;&amp; jpn-&gt;in(0) == mach) {
1345                 uint block_num = succs_block-&gt;non_connector()-&gt;_pre_order;
1346                 Label *blkLabel = &amp;blk_labels[block_num];
1347                 mach-&gt;add_case_label(jpn-&gt;as_JumpProj()-&gt;proj_no(), blkLabel);
1348               }
1349             }
1350           }
1351         }
1352 #ifdef ASSERT
1353           // Check that oop-store precedes the card-mark
1354         else if (mach-&gt;ideal_Opcode() == Op_StoreCM) {
1355           uint storeCM_idx = j;
1356           int count = 0;
1357           for (uint prec = mach-&gt;req(); prec &lt; mach-&gt;len(); prec++) {
1358             Node *oop_store = mach-&gt;in(prec);  // Precedence edge
1359             if (oop_store == NULL) continue;
1360             count++;
1361             uint i4;
1362             for (i4 = 0; i4 &lt; last_inst; ++i4) {
1363               if (block-&gt;get_node(i4) == oop_store) {
1364                 break;
1365               }
1366             }
1367             // Note: This test can provide a false failure if other precedence
1368             // edges have been added to the storeCMNode.
1369             assert(i4 == last_inst || i4 &lt; storeCM_idx, &quot;CM card-mark executes before oop-store&quot;);
1370           }
1371           assert(count &gt; 0, &quot;storeCM expects at least one precedence edge&quot;);
1372         }
1373 #endif
1374         else if (!n-&gt;is_Proj()) {
1375           // Remember the beginning of the previous instruction, in case
1376           // it&#39;s followed by a flag-kill and a null-check.  Happens on
1377           // Intel all the time, with add-to-memory kind of opcodes.
1378           previous_offset = current_offset;
1379         }
1380 
1381         // Not an else-if!
1382         // If this is a trap based cmp then add its offset to the list.
1383         if (mach-&gt;is_TrapBasedCheckNode()) {
1384           inct_starts[inct_cnt++] = current_offset;
1385         }
1386       }
1387 
1388       // Verify that there is sufficient space remaining
1389       cb-&gt;insts()-&gt;maybe_expand_to_ensure_remaining(MAX_inst_size);
1390       if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1391         C-&gt;record_failure(&quot;CodeCache is full&quot;);
1392         return;
1393       }
1394 
1395       // Save the offset for the listing
1396 #if defined(SUPPORT_OPTO_ASSEMBLY)
1397       if ((node_offsets != NULL) &amp;&amp; (n-&gt;_idx &lt; node_offset_limit)) {
1398         node_offsets[n-&gt;_idx] = cb-&gt;insts_size();
1399       }
1400 #endif
1401 
1402       // &quot;Normal&quot; instruction case
1403       DEBUG_ONLY( uint instr_offset = cb-&gt;insts_size(); )
1404       n-&gt;emit(*cb, _regalloc);
1405       current_offset  = cb-&gt;insts_size();
1406 
1407       // Above we only verified that there is enough space in the instruction section.
1408       // However, the instruction may emit stubs that cause code buffer expansion.
1409       // Bail out here if expansion failed due to a lack of code cache space.
1410       if (failing()) {
1411         return;
1412       }
1413 
1414 #ifdef ASSERT
1415       if (n-&gt;size(_regalloc) &lt; (current_offset-instr_offset)) {
1416         n-&gt;dump();
1417         assert(false, &quot;wrong size of mach node&quot;);
1418       }
1419 #endif
1420       non_safepoints.observe_instruction(n, current_offset);
1421 
1422       // mcall is last &quot;call&quot; that can be a safepoint
1423       // record it so we can see if a poll will directly follow it
1424       // in which case we&#39;ll need a pad to make the PcDesc sites unique
1425       // see  5010568. This can be slightly inaccurate but conservative
1426       // in the case that return address is not actually at current_offset.
1427       // This is a small price to pay.
1428 
1429       if (is_mcall) {
1430         last_call_offset = current_offset;
1431       }
1432 
1433       if (n-&gt;is_Mach() &amp;&amp; n-&gt;as_Mach()-&gt;avoid_back_to_back(MachNode::AVOID_AFTER)) {
1434         // Avoid back to back some instructions.
1435         last_avoid_back_to_back_offset = current_offset;
1436       }
1437 
1438       // See if this instruction has a delay slot
1439       if (valid_bundle_info(n) &amp;&amp; node_bundling(n)-&gt;use_unconditional_delay()) {
1440         guarantee(delay_slot != NULL, &quot;expecting delay slot node&quot;);
1441 
1442         // Back up 1 instruction
1443         cb-&gt;set_insts_end(cb-&gt;insts_end() - Pipeline::instr_unit_size());
1444 
1445         // Save the offset for the listing
1446 #if defined(SUPPORT_OPTO_ASSEMBLY)
1447         if ((node_offsets != NULL) &amp;&amp; (delay_slot-&gt;_idx &lt; node_offset_limit)) {
1448           node_offsets[delay_slot-&gt;_idx] = cb-&gt;insts_size();
1449         }
1450 #endif
1451 
1452         // Support a SafePoint in the delay slot
1453         if (delay_slot-&gt;is_MachSafePoint()) {
1454           MachNode *mach = delay_slot-&gt;as_Mach();
1455           // !!!!! Stubs only need an oopmap right now, so bail out
1456           if (!mach-&gt;is_MachCall() &amp;&amp; mach-&gt;as_MachSafePoint()-&gt;jvms()-&gt;method() == NULL) {
1457             // Write the oopmap directly to the code blob??!!
1458             delay_slot = NULL;
1459             continue;
1460           }
1461 
1462           int adjusted_offset = current_offset - Pipeline::instr_unit_size();
1463           non_safepoints.observe_safepoint(mach-&gt;as_MachSafePoint()-&gt;jvms(),
1464                                            adjusted_offset);
1465           // Generate an OopMap entry
1466           Process_OopMap_Node(mach, adjusted_offset);
1467         }
1468 
1469         // Insert the delay slot instruction
1470         delay_slot-&gt;emit(*cb, _regalloc);
1471 
1472         // Don&#39;t reuse it
1473         delay_slot = NULL;
1474       }
1475 
1476     } // End for all instructions in block
1477 
1478     // If the next block is the top of a loop, pad this block out to align
1479     // the loop top a little. Helps prevent pipe stalls at loop back branches.
1480     if (i &lt; nblocks-1) {
1481       Block *nb = _cfg-&gt;get_block(i + 1);
1482       int padding = nb-&gt;alignment_padding(current_offset);
1483       if( padding &gt; 0 ) {
1484         MachNode *nop = new MachNopNode(padding / nop_size);
1485         block-&gt;insert_node(nop, block-&gt;number_of_nodes());
1486         _cfg-&gt;map_node_to_block(nop, block);
1487         nop-&gt;emit(*cb, _regalloc);
1488         current_offset = cb-&gt;insts_size();
1489       }
1490     }
1491     // Verify that the distance for generated before forward
1492     // short branches is still valid.
1493     guarantee((int)(blk_starts[i+1] - blk_starts[i]) &gt;= (current_offset - blk_offset), &quot;shouldn&#39;t increase block size&quot;);
1494 
1495     // Save new block start offset
1496     blk_starts[i] = blk_offset;
1497   } // End of for all blocks
1498   blk_starts[nblocks] = current_offset;
1499 
1500   non_safepoints.flush_at_end();
1501 
1502   // Offset too large?
1503   if (failing())  return;
1504 
1505   // Define a pseudo-label at the end of the code
1506   MacroAssembler(cb).bind( blk_labels[nblocks] );
1507 
1508   // Compute the size of the first block
1509   _first_block_size = blk_labels[1].loc_pos() - blk_labels[0].loc_pos();
1510 
1511 #ifdef ASSERT
1512   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
1513     if (jmp_target[i] != 0) {
1514       int br_size = jmp_size[i];
1515       int offset = blk_starts[jmp_target[i]]-(blk_starts[i] + jmp_offset[i]);
1516       if (!_matcher-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset)) {
1517         tty-&gt;print_cr(&quot;target (%d) - jmp_offset(%d) = offset (%d), jump_size(%d), jmp_block B%d, target_block B%d&quot;, blk_starts[jmp_target[i]], blk_starts[i] + jmp_offset[i], offset, br_size, i, jmp_target[i]);
1518         assert(false, &quot;Displacement too large for short jmp&quot;);
1519       }
1520     }
1521   }
1522 #endif
1523 
1524   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1525   bs-&gt;emit_stubs(*cb);
1526   if (failing())  return;
1527 
1528 #ifndef PRODUCT
1529   // Information on the size of the method, without the extraneous code
1530   Scheduling::increment_method_size(cb-&gt;insts_size());
1531 #endif
1532 
1533   // ------------------
1534   // Fill in exception table entries.
1535   FillExceptionTables(inct_cnt, call_returns, inct_starts, blk_labels);
1536 
1537   // Only java methods have exception handlers and deopt handlers
1538   // class HandlerImpl is platform-specific and defined in the *.ad files.
1539   if (_method) {
1540     // Emit the exception handler code.
1541     _code_offsets.set_value(CodeOffsets::Exceptions, HandlerImpl::emit_exception_handler(*cb));
1542     if (failing()) {
1543       return; // CodeBuffer::expand failed
1544     }
1545     // Emit the deopt handler code.
1546     _code_offsets.set_value(CodeOffsets::Deopt, HandlerImpl::emit_deopt_handler(*cb));
1547 
1548     // Emit the MethodHandle deopt handler code (if required).
1549     if (has_method_handle_invokes() &amp;&amp; !failing()) {
1550       // We can use the same code as for the normal deopt handler, we
1551       // just need a different entry point address.
1552       _code_offsets.set_value(CodeOffsets::DeoptMH, HandlerImpl::emit_deopt_handler(*cb));
1553     }
1554   }
1555 
1556   // One last check for failed CodeBuffer::expand:
1557   if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1558     C-&gt;record_failure(&quot;CodeCache is full&quot;);
1559     return;
1560   }
1561 
1562 #if defined(SUPPORT_ABSTRACT_ASSEMBLY) || defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_OPTO_ASSEMBLY)
1563   if (print_assembly()) {
1564     tty-&gt;cr();
1565     tty-&gt;print_cr(&quot;============================= C2-compiled nmethod ==============================&quot;);
1566   }
1567 #endif
1568 
1569 #if defined(SUPPORT_OPTO_ASSEMBLY)
1570   // Dump the assembly code, including basic-block numbers
1571   if (print_assembly()) {
1572     ttyLocker ttyl;  // keep the following output all in one block
1573     if (!VMThread::should_terminate()) {  // test this under the tty lock
1574       // This output goes directly to the tty, not the compiler log.
1575       // To enable tools to match it up with the compilation activity,
1576       // be sure to tag this tty output with the compile ID.
1577       if (xtty != NULL) {
1578         xtty-&gt;head(&quot;opto_assembly compile_id=&#39;%d&#39;%s&quot;, compile_id(),
1579                    is_osr_compilation()    ? &quot; compile_kind=&#39;osr&#39;&quot; :
1580                    &quot;&quot;);
1581       }
1582       if (method() != NULL) {
1583         tty-&gt;print_cr(&quot;----------------------- MetaData before Compile_id = %d ------------------------&quot;, compile_id());
1584         method()-&gt;print_metadata();
1585       } else if (stub_name() != NULL) {
1586         tty-&gt;print_cr(&quot;----------------------------- RuntimeStub %s -------------------------------&quot;, stub_name());
1587       }
1588       tty-&gt;cr();
1589       tty-&gt;print_cr(&quot;------------------------ OptoAssembly for Compile_id = %d -----------------------&quot;, compile_id());
1590       dump_asm(node_offsets, node_offset_limit);
1591       tty-&gt;print_cr(&quot;--------------------------------------------------------------------------------&quot;);
1592       if (xtty != NULL) {
1593         // print_metadata and dump_asm above may safepoint which makes us loose the ttylock.
1594         // Retake lock too make sure the end tag is coherent, and that xmlStream-&gt;pop_tag is done
1595         // thread safe
1596         ttyLocker ttyl2;
1597         xtty-&gt;tail(&quot;opto_assembly&quot;);
1598       }
1599     }
1600   }
1601 #endif
1602 }
1603 
1604 void Compile::FillExceptionTables(uint cnt, uint *call_returns, uint *inct_starts, Label *blk_labels) {
1605   _inc_table.set_size(cnt);
1606 
1607   uint inct_cnt = 0;
1608   for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {
1609     Block* block = _cfg-&gt;get_block(i);
1610     Node *n = NULL;
1611     int j;
1612 
1613     // Find the branch; ignore trailing NOPs.
1614     for (j = block-&gt;number_of_nodes() - 1; j &gt;= 0; j--) {
1615       n = block-&gt;get_node(j);
1616       if (!n-&gt;is_Mach() || n-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Con) {
1617         break;
1618       }
1619     }
1620 
1621     // If we didn&#39;t find anything, continue
1622     if (j &lt; 0) {
1623       continue;
1624     }
1625 
1626     // Compute ExceptionHandlerTable subtable entry and add it
1627     // (skip empty blocks)
1628     if (n-&gt;is_Catch()) {
1629 
1630       // Get the offset of the return from the call
1631       uint call_return = call_returns[block-&gt;_pre_order];
1632 #ifdef ASSERT
1633       assert( call_return &gt; 0, &quot;no call seen for this basic block&quot; );
1634       while (block-&gt;get_node(--j)-&gt;is_MachProj()) ;
1635       assert(block-&gt;get_node(j)-&gt;is_MachCall(), &quot;CatchProj must follow call&quot;);
1636 #endif
1637       // last instruction is a CatchNode, find it&#39;s CatchProjNodes
1638       int nof_succs = block-&gt;_num_succs;
1639       // allocate space
1640       GrowableArray&lt;intptr_t&gt; handler_bcis(nof_succs);
1641       GrowableArray&lt;intptr_t&gt; handler_pcos(nof_succs);
1642       // iterate through all successors
1643       for (int j = 0; j &lt; nof_succs; j++) {
1644         Block* s = block-&gt;_succs[j];
1645         bool found_p = false;
1646         for (uint k = 1; k &lt; s-&gt;num_preds(); k++) {
1647           Node* pk = s-&gt;pred(k);
1648           if (pk-&gt;is_CatchProj() &amp;&amp; pk-&gt;in(0) == n) {
1649             const CatchProjNode* p = pk-&gt;as_CatchProj();
1650             found_p = true;
1651             // add the corresponding handler bci &amp; pco information
1652             if (p-&gt;_con != CatchProjNode::fall_through_index) {
1653               // p leads to an exception handler (and is not fall through)
1654               assert(s == _cfg-&gt;get_block(s-&gt;_pre_order), &quot;bad numbering&quot;);
1655               // no duplicates, please
1656               if (!handler_bcis.contains(p-&gt;handler_bci())) {
1657                 uint block_num = s-&gt;non_connector()-&gt;_pre_order;
1658                 handler_bcis.append(p-&gt;handler_bci());
1659                 handler_pcos.append(blk_labels[block_num].loc_pos());
1660               }
1661             }
1662           }
1663         }
1664         assert(found_p, &quot;no matching predecessor found&quot;);
1665         // Note:  Due to empty block removal, one block may have
1666         // several CatchProj inputs, from the same Catch.
1667       }
1668 
1669       // Set the offset of the return from the call
1670       assert(handler_bcis.find(-1) != -1, &quot;must have default handler&quot;);
1671       _handler_table.add_subtable(call_return, &amp;handler_bcis, NULL, &amp;handler_pcos);
1672       continue;
1673     }
1674 
1675     // Handle implicit null exception table updates
1676     if (n-&gt;is_MachNullCheck()) {
1677       uint block_num = block-&gt;non_connector_successor(0)-&gt;_pre_order;
1678       _inc_table.append(inct_starts[inct_cnt++], blk_labels[block_num].loc_pos());
1679       continue;
1680     }
1681     // Handle implicit exception table updates: trap instructions.
1682     if (n-&gt;is_Mach() &amp;&amp; n-&gt;as_Mach()-&gt;is_TrapBasedCheckNode()) {
1683       uint block_num = block-&gt;non_connector_successor(0)-&gt;_pre_order;
1684       _inc_table.append(inct_starts[inct_cnt++], blk_labels[block_num].loc_pos());
1685       continue;
1686     }
1687   } // End of for all blocks fill in exception table entries
1688 }
1689 
1690 // Static Variables
1691 #ifndef PRODUCT
1692 uint Scheduling::_total_nop_size = 0;
1693 uint Scheduling::_total_method_size = 0;
1694 uint Scheduling::_total_branches = 0;
1695 uint Scheduling::_total_unconditional_delays = 0;
1696 uint Scheduling::_total_instructions_per_bundle[Pipeline::_max_instrs_per_cycle+1];
1697 #endif
1698 
1699 // Initializer for class Scheduling
1700 
1701 Scheduling::Scheduling(Arena *arena, Compile &amp;compile)
1702         : _arena(arena),
1703           _cfg(compile.cfg()),
1704           _regalloc(compile.regalloc()),
1705           _scheduled(arena),
1706           _available(arena),
1707           _reg_node(arena),
1708           _pinch_free_list(arena),
1709           _next_node(NULL),
1710           _bundle_instr_count(0),
1711           _bundle_cycle_number(0),
1712           _bundle_use(0, 0, resource_count, &amp;_bundle_use_elements[0])
1713 #ifndef PRODUCT
1714         , _branches(0)
1715         , _unconditional_delays(0)
1716 #endif
1717 {
1718   // Create a MachNopNode
1719   _nop = new MachNopNode();
1720 
1721   // Now that the nops are in the array, save the count
1722   // (but allow entries for the nops)
1723   _node_bundling_limit = compile.unique();
1724   uint node_max = _regalloc-&gt;node_regs_max_index();
1725 
1726   compile.set_node_bundling_limit(_node_bundling_limit);
1727 
1728   // This one is persistent within the Compile class
1729   _node_bundling_base = NEW_ARENA_ARRAY(compile.comp_arena(), Bundle, node_max);
1730 
1731   // Allocate space for fixed-size arrays
1732   _node_latency    = NEW_ARENA_ARRAY(arena, unsigned short, node_max);
1733   _uses            = NEW_ARENA_ARRAY(arena, short,          node_max);
1734   _current_latency = NEW_ARENA_ARRAY(arena, unsigned short, node_max);
1735 
1736   // Clear the arrays
1737   for (uint i = 0; i &lt; node_max; i++) {
1738     ::new (&amp;_node_bundling_base[i]) Bundle();
1739   }
1740   memset(_node_latency,       0, node_max * sizeof(unsigned short));
1741   memset(_uses,               0, node_max * sizeof(short));
1742   memset(_current_latency,    0, node_max * sizeof(unsigned short));
1743 
1744   // Clear the bundling information
1745   memcpy(_bundle_use_elements, Pipeline_Use::elaborated_elements, sizeof(Pipeline_Use::elaborated_elements));
1746 
1747   // Get the last node
1748   Block* block = _cfg-&gt;get_block(_cfg-&gt;number_of_blocks() - 1);
1749 
1750   _next_node = block-&gt;get_node(block-&gt;number_of_nodes() - 1);
1751 }
1752 
1753 #ifndef PRODUCT
1754 // Scheduling destructor
1755 Scheduling::~Scheduling() {
1756   _total_branches             += _branches;
1757   _total_unconditional_delays += _unconditional_delays;
1758 }
1759 #endif
1760 
1761 // Step ahead &quot;i&quot; cycles
1762 void Scheduling::step(uint i) {
1763 
1764   Bundle *bundle = node_bundling(_next_node);
1765   bundle-&gt;set_starts_bundle();
1766 
1767   // Update the bundle record, but leave the flags information alone
1768   if (_bundle_instr_count &gt; 0) {
1769     bundle-&gt;set_instr_count(_bundle_instr_count);
1770     bundle-&gt;set_resources_used(_bundle_use.resourcesUsed());
1771   }
1772 
1773   // Update the state information
1774   _bundle_instr_count = 0;
1775   _bundle_cycle_number += i;
1776   _bundle_use.step(i);
1777 }
1778 
1779 void Scheduling::step_and_clear() {
1780   Bundle *bundle = node_bundling(_next_node);
1781   bundle-&gt;set_starts_bundle();
1782 
1783   // Update the bundle record
1784   if (_bundle_instr_count &gt; 0) {
1785     bundle-&gt;set_instr_count(_bundle_instr_count);
1786     bundle-&gt;set_resources_used(_bundle_use.resourcesUsed());
1787 
1788     _bundle_cycle_number += 1;
1789   }
1790 
1791   // Clear the bundling information
1792   _bundle_instr_count = 0;
1793   _bundle_use.reset();
1794 
1795   memcpy(_bundle_use_elements,
1796          Pipeline_Use::elaborated_elements,
1797          sizeof(Pipeline_Use::elaborated_elements));
1798 }
1799 
1800 // Perform instruction scheduling and bundling over the sequence of
1801 // instructions in backwards order.
1802 void Compile::ScheduleAndBundle() {
1803 
1804   // Don&#39;t optimize this if it isn&#39;t a method
1805   if (!_method)
1806     return;
1807 
1808   // Don&#39;t optimize this if scheduling is disabled
1809   if (!do_scheduling())
1810     return;
1811 
1812   // Scheduling code works only with pairs (16 bytes) maximum.
1813   if (max_vector_size() &gt; 16)
1814     return;
1815 
1816   TracePhase tp(&quot;isched&quot;, &amp;timers[_t_instrSched]);
1817 
1818   // Create a data structure for all the scheduling information
1819   Scheduling scheduling(Thread::current()-&gt;resource_area(), *this);
1820 
1821   // Walk backwards over each basic block, computing the needed alignment
1822   // Walk over all the basic blocks
1823   scheduling.DoScheduling();
1824 
1825 #ifndef PRODUCT
1826   if (trace_opto_output()) {
1827     tty-&gt;print(&quot;\n---- After ScheduleAndBundle ----\n&quot;);
1828     for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {
1829       tty-&gt;print(&quot;\nBB#%03d:\n&quot;, i);
1830       Block* block = _cfg-&gt;get_block(i);
1831       for (uint j = 0; j &lt; block-&gt;number_of_nodes(); j++) {
1832         Node* n = block-&gt;get_node(j);
1833         OptoReg::Name reg = _regalloc-&gt;get_reg_first(n);
1834         tty-&gt;print(&quot; %-6s &quot;, reg &gt;= 0 &amp;&amp; reg &lt; REG_COUNT ? Matcher::regName[reg] : &quot;&quot;);
1835         n-&gt;dump();
1836       }
1837     }
1838   }
1839 #endif
1840 }
1841 
1842 // Compute the latency of all the instructions.  This is fairly simple,
1843 // because we already have a legal ordering.  Walk over the instructions
1844 // from first to last, and compute the latency of the instruction based
1845 // on the latency of the preceding instruction(s).
1846 void Scheduling::ComputeLocalLatenciesForward(const Block *bb) {
1847 #ifndef PRODUCT
1848   if (_cfg-&gt;C-&gt;trace_opto_output())
1849     tty-&gt;print(&quot;# -&gt; ComputeLocalLatenciesForward\n&quot;);
1850 #endif
1851 
1852   // Walk over all the schedulable instructions
1853   for( uint j=_bb_start; j &lt; _bb_end; j++ ) {
1854 
1855     // This is a kludge, forcing all latency calculations to start at 1.
1856     // Used to allow latency 0 to force an instruction to the beginning
1857     // of the bb
1858     uint latency = 1;
1859     Node *use = bb-&gt;get_node(j);
1860     uint nlen = use-&gt;len();
1861 
1862     // Walk over all the inputs
1863     for ( uint k=0; k &lt; nlen; k++ ) {
1864       Node *def = use-&gt;in(k);
1865       if (!def)
1866         continue;
1867 
1868       uint l = _node_latency[def-&gt;_idx] + use-&gt;latency(k);
1869       if (latency &lt; l)
1870         latency = l;
1871     }
1872 
1873     _node_latency[use-&gt;_idx] = latency;
1874 
1875 #ifndef PRODUCT
1876     if (_cfg-&gt;C-&gt;trace_opto_output()) {
1877       tty-&gt;print(&quot;# latency %4d: &quot;, latency);
1878       use-&gt;dump();
1879     }
1880 #endif
1881   }
1882 
1883 #ifndef PRODUCT
1884   if (_cfg-&gt;C-&gt;trace_opto_output())
1885     tty-&gt;print(&quot;# &lt;- ComputeLocalLatenciesForward\n&quot;);
1886 #endif
1887 
1888 } // end ComputeLocalLatenciesForward
1889 
1890 // See if this node fits into the present instruction bundle
1891 bool Scheduling::NodeFitsInBundle(Node *n) {
1892   uint n_idx = n-&gt;_idx;
1893 
1894   // If this is the unconditional delay instruction, then it fits
1895   if (n == _unconditional_delay_slot) {
1896 #ifndef PRODUCT
1897     if (_cfg-&gt;C-&gt;trace_opto_output())
1898       tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]: TRUE; is in unconditional delay slot\n&quot;, n-&gt;_idx);
1899 #endif
1900     return (true);
1901   }
1902 
1903   // If the node cannot be scheduled this cycle, skip it
1904   if (_current_latency[n_idx] &gt; _bundle_cycle_number) {
1905 #ifndef PRODUCT
1906     if (_cfg-&gt;C-&gt;trace_opto_output())
1907       tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]: FALSE; latency %4d &gt; %d\n&quot;,
1908                  n-&gt;_idx, _current_latency[n_idx], _bundle_cycle_number);
1909 #endif
1910     return (false);
1911   }
1912 
1913   const Pipeline *node_pipeline = n-&gt;pipeline();
1914 
1915   uint instruction_count = node_pipeline-&gt;instructionCount();
1916   if (node_pipeline-&gt;mayHaveNoCode() &amp;&amp; n-&gt;size(_regalloc) == 0)
1917     instruction_count = 0;
1918   else if (node_pipeline-&gt;hasBranchDelay() &amp;&amp; !_unconditional_delay_slot)
1919     instruction_count++;
1920 
1921   if (_bundle_instr_count + instruction_count &gt; Pipeline::_max_instrs_per_cycle) {
1922 #ifndef PRODUCT
1923     if (_cfg-&gt;C-&gt;trace_opto_output())
1924       tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]: FALSE; too many instructions: %d &gt; %d\n&quot;,
1925                  n-&gt;_idx, _bundle_instr_count + instruction_count, Pipeline::_max_instrs_per_cycle);
1926 #endif
1927     return (false);
1928   }
1929 
1930   // Don&#39;t allow non-machine nodes to be handled this way
1931   if (!n-&gt;is_Mach() &amp;&amp; instruction_count == 0)
1932     return (false);
1933 
1934   // See if there is any overlap
1935   uint delay = _bundle_use.full_latency(0, node_pipeline-&gt;resourceUse());
1936 
1937   if (delay &gt; 0) {
1938 #ifndef PRODUCT
1939     if (_cfg-&gt;C-&gt;trace_opto_output())
1940       tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]: FALSE; functional units overlap\n&quot;, n_idx);
1941 #endif
1942     return false;
1943   }
1944 
1945 #ifndef PRODUCT
1946   if (_cfg-&gt;C-&gt;trace_opto_output())
1947     tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]:  TRUE\n&quot;, n_idx);
1948 #endif
1949 
1950   return true;
1951 }
1952 
1953 Node * Scheduling::ChooseNodeToBundle() {
1954   uint siz = _available.size();
1955 
1956   if (siz == 0) {
1957 
1958 #ifndef PRODUCT
1959     if (_cfg-&gt;C-&gt;trace_opto_output())
1960       tty-&gt;print(&quot;#   ChooseNodeToBundle: NULL\n&quot;);
1961 #endif
1962     return (NULL);
1963   }
1964 
1965   // Fast path, if only 1 instruction in the bundle
1966   if (siz == 1) {
1967 #ifndef PRODUCT
1968     if (_cfg-&gt;C-&gt;trace_opto_output()) {
1969       tty-&gt;print(&quot;#   ChooseNodeToBundle (only 1): &quot;);
1970       _available[0]-&gt;dump();
1971     }
1972 #endif
1973     return (_available[0]);
1974   }
1975 
1976   // Don&#39;t bother, if the bundle is already full
1977   if (_bundle_instr_count &lt; Pipeline::_max_instrs_per_cycle) {
1978     for ( uint i = 0; i &lt; siz; i++ ) {
1979       Node *n = _available[i];
1980 
1981       // Skip projections, we&#39;ll handle them another way
1982       if (n-&gt;is_Proj())
1983         continue;
1984 
1985       // This presupposed that instructions are inserted into the
1986       // available list in a legality order; i.e. instructions that
1987       // must be inserted first are at the head of the list
1988       if (NodeFitsInBundle(n)) {
1989 #ifndef PRODUCT
1990         if (_cfg-&gt;C-&gt;trace_opto_output()) {
1991           tty-&gt;print(&quot;#   ChooseNodeToBundle: &quot;);
1992           n-&gt;dump();
1993         }
1994 #endif
1995         return (n);
1996       }
1997     }
1998   }
1999 
2000   // Nothing fits in this bundle, choose the highest priority
2001 #ifndef PRODUCT
2002   if (_cfg-&gt;C-&gt;trace_opto_output()) {
2003     tty-&gt;print(&quot;#   ChooseNodeToBundle: &quot;);
2004     _available[0]-&gt;dump();
2005   }
2006 #endif
2007 
2008   return _available[0];
2009 }
2010 
2011 void Scheduling::AddNodeToAvailableList(Node *n) {
2012   assert( !n-&gt;is_Proj(), &quot;projections never directly made available&quot; );
2013 #ifndef PRODUCT
2014   if (_cfg-&gt;C-&gt;trace_opto_output()) {
2015     tty-&gt;print(&quot;#   AddNodeToAvailableList: &quot;);
2016     n-&gt;dump();
2017   }
2018 #endif
2019 
2020   int latency = _current_latency[n-&gt;_idx];
2021 
2022   // Insert in latency order (insertion sort)
2023   uint i;
2024   for ( i=0; i &lt; _available.size(); i++ )
2025     if (_current_latency[_available[i]-&gt;_idx] &gt; latency)
2026       break;
2027 
2028   // Special Check for compares following branches
2029   if( n-&gt;is_Mach() &amp;&amp; _scheduled.size() &gt; 0 ) {
2030     int op = n-&gt;as_Mach()-&gt;ideal_Opcode();
2031     Node *last = _scheduled[0];
2032     if( last-&gt;is_MachIf() &amp;&amp; last-&gt;in(1) == n &amp;&amp;
2033         ( op == Op_CmpI ||
2034           op == Op_CmpU ||
2035           op == Op_CmpUL ||
2036           op == Op_CmpP ||
2037           op == Op_CmpF ||
2038           op == Op_CmpD ||
2039           op == Op_CmpL ) ) {
2040 
2041       // Recalculate position, moving to front of same latency
2042       for ( i=0 ; i &lt; _available.size(); i++ )
2043         if (_current_latency[_available[i]-&gt;_idx] &gt;= latency)
2044           break;
2045     }
2046   }
2047 
2048   // Insert the node in the available list
2049   _available.insert(i, n);
2050 
2051 #ifndef PRODUCT
2052   if (_cfg-&gt;C-&gt;trace_opto_output())
2053     dump_available();
2054 #endif
2055 }
2056 
2057 void Scheduling::DecrementUseCounts(Node *n, const Block *bb) {
2058   for ( uint i=0; i &lt; n-&gt;len(); i++ ) {
2059     Node *def = n-&gt;in(i);
2060     if (!def) continue;
2061     if( def-&gt;is_Proj() )        // If this is a machine projection, then
2062       def = def-&gt;in(0);         // propagate usage thru to the base instruction
2063 
2064     if(_cfg-&gt;get_block_for_node(def) != bb) { // Ignore if not block-local
2065       continue;
2066     }
2067 
2068     // Compute the latency
2069     uint l = _bundle_cycle_number + n-&gt;latency(i);
2070     if (_current_latency[def-&gt;_idx] &lt; l)
2071       _current_latency[def-&gt;_idx] = l;
2072 
2073     // If this does not have uses then schedule it
2074     if ((--_uses[def-&gt;_idx]) == 0)
2075       AddNodeToAvailableList(def);
2076   }
2077 }
2078 
2079 void Scheduling::AddNodeToBundle(Node *n, const Block *bb) {
2080 #ifndef PRODUCT
2081   if (_cfg-&gt;C-&gt;trace_opto_output()) {
2082     tty-&gt;print(&quot;#   AddNodeToBundle: &quot;);
2083     n-&gt;dump();
2084   }
2085 #endif
2086 
2087   // Remove this from the available list
2088   uint i;
2089   for (i = 0; i &lt; _available.size(); i++)
2090     if (_available[i] == n)
2091       break;
2092   assert(i &lt; _available.size(), &quot;entry in _available list not found&quot;);
2093   _available.remove(i);
2094 
2095   // See if this fits in the current bundle
2096   const Pipeline *node_pipeline = n-&gt;pipeline();
2097   const Pipeline_Use&amp; node_usage = node_pipeline-&gt;resourceUse();
2098 
2099   // Check for instructions to be placed in the delay slot. We
2100   // do this before we actually schedule the current instruction,
2101   // because the delay slot follows the current instruction.
2102   if (Pipeline::_branch_has_delay_slot &amp;&amp;
2103       node_pipeline-&gt;hasBranchDelay() &amp;&amp;
2104       !_unconditional_delay_slot) {
2105 
2106     uint siz = _available.size();
2107 
2108     // Conditional branches can support an instruction that
2109     // is unconditionally executed and not dependent by the
2110     // branch, OR a conditionally executed instruction if
2111     // the branch is taken.  In practice, this means that
2112     // the first instruction at the branch target is
2113     // copied to the delay slot, and the branch goes to
2114     // the instruction after that at the branch target
2115     if ( n-&gt;is_MachBranch() ) {
2116 
2117       assert( !n-&gt;is_MachNullCheck(), &quot;should not look for delay slot for Null Check&quot; );
2118       assert( !n-&gt;is_Catch(),         &quot;should not look for delay slot for Catch&quot; );
2119 
2120 #ifndef PRODUCT
2121       _branches++;
2122 #endif
2123 
2124       // At least 1 instruction is on the available list
2125       // that is not dependent on the branch
2126       for (uint i = 0; i &lt; siz; i++) {
2127         Node *d = _available[i];
2128         const Pipeline *avail_pipeline = d-&gt;pipeline();
2129 
2130         // Don&#39;t allow safepoints in the branch shadow, that will
2131         // cause a number of difficulties
2132         if ( avail_pipeline-&gt;instructionCount() == 1 &amp;&amp;
2133              !avail_pipeline-&gt;hasMultipleBundles() &amp;&amp;
2134              !avail_pipeline-&gt;hasBranchDelay() &amp;&amp;
2135              Pipeline::instr_has_unit_size() &amp;&amp;
2136              d-&gt;size(_regalloc) == Pipeline::instr_unit_size() &amp;&amp;
2137              NodeFitsInBundle(d) &amp;&amp;
2138              !node_bundling(d)-&gt;used_in_delay()) {
2139 
2140           if (d-&gt;is_Mach() &amp;&amp; !d-&gt;is_MachSafePoint()) {
2141             // A node that fits in the delay slot was found, so we need to
2142             // set the appropriate bits in the bundle pipeline information so
2143             // that it correctly indicates resource usage.  Later, when we
2144             // attempt to add this instruction to the bundle, we will skip
2145             // setting the resource usage.
2146             _unconditional_delay_slot = d;
2147             node_bundling(n)-&gt;set_use_unconditional_delay();
2148             node_bundling(d)-&gt;set_used_in_unconditional_delay();
2149             _bundle_use.add_usage(avail_pipeline-&gt;resourceUse());
2150             _current_latency[d-&gt;_idx] = _bundle_cycle_number;
2151             _next_node = d;
2152             ++_bundle_instr_count;
2153 #ifndef PRODUCT
2154             _unconditional_delays++;
2155 #endif
2156             break;
2157           }
2158         }
2159       }
2160     }
2161 
2162     // No delay slot, add a nop to the usage
2163     if (!_unconditional_delay_slot) {
2164       // See if adding an instruction in the delay slot will overflow
2165       // the bundle.
2166       if (!NodeFitsInBundle(_nop)) {
2167 #ifndef PRODUCT
2168         if (_cfg-&gt;C-&gt;trace_opto_output())
2169           tty-&gt;print(&quot;#  *** STEP(1 instruction for delay slot) ***\n&quot;);
2170 #endif
2171         step(1);
2172       }
2173 
2174       _bundle_use.add_usage(_nop-&gt;pipeline()-&gt;resourceUse());
2175       _next_node = _nop;
2176       ++_bundle_instr_count;
2177     }
2178 
2179     // See if the instruction in the delay slot requires a
2180     // step of the bundles
2181     if (!NodeFitsInBundle(n)) {
2182 #ifndef PRODUCT
2183       if (_cfg-&gt;C-&gt;trace_opto_output())
2184         tty-&gt;print(&quot;#  *** STEP(branch won&#39;t fit) ***\n&quot;);
2185 #endif
2186       // Update the state information
2187       _bundle_instr_count = 0;
2188       _bundle_cycle_number += 1;
2189       _bundle_use.step(1);
2190     }
2191   }
2192 
2193   // Get the number of instructions
2194   uint instruction_count = node_pipeline-&gt;instructionCount();
2195   if (node_pipeline-&gt;mayHaveNoCode() &amp;&amp; n-&gt;size(_regalloc) == 0)
2196     instruction_count = 0;
2197 
2198   // Compute the latency information
2199   uint delay = 0;
2200 
2201   if (instruction_count &gt; 0 || !node_pipeline-&gt;mayHaveNoCode()) {
2202     int relative_latency = _current_latency[n-&gt;_idx] - _bundle_cycle_number;
2203     if (relative_latency &lt; 0)
2204       relative_latency = 0;
2205 
2206     delay = _bundle_use.full_latency(relative_latency, node_usage);
2207 
2208     // Does not fit in this bundle, start a new one
2209     if (delay &gt; 0) {
2210       step(delay);
2211 
2212 #ifndef PRODUCT
2213       if (_cfg-&gt;C-&gt;trace_opto_output())
2214         tty-&gt;print(&quot;#  *** STEP(%d) ***\n&quot;, delay);
2215 #endif
2216     }
2217   }
2218 
2219   // If this was placed in the delay slot, ignore it
2220   if (n != _unconditional_delay_slot) {
2221 
2222     if (delay == 0) {
2223       if (node_pipeline-&gt;hasMultipleBundles()) {
2224 #ifndef PRODUCT
2225         if (_cfg-&gt;C-&gt;trace_opto_output())
2226           tty-&gt;print(&quot;#  *** STEP(multiple instructions) ***\n&quot;);
2227 #endif
2228         step(1);
2229       }
2230 
2231       else if (instruction_count + _bundle_instr_count &gt; Pipeline::_max_instrs_per_cycle) {
2232 #ifndef PRODUCT
2233         if (_cfg-&gt;C-&gt;trace_opto_output())
2234           tty-&gt;print(&quot;#  *** STEP(%d &gt;= %d instructions) ***\n&quot;,
2235                      instruction_count + _bundle_instr_count,
2236                      Pipeline::_max_instrs_per_cycle);
2237 #endif
2238         step(1);
2239       }
2240     }
2241 
2242     if (node_pipeline-&gt;hasBranchDelay() &amp;&amp; !_unconditional_delay_slot)
2243       _bundle_instr_count++;
2244 
2245     // Set the node&#39;s latency
2246     _current_latency[n-&gt;_idx] = _bundle_cycle_number;
2247 
2248     // Now merge the functional unit information
2249     if (instruction_count &gt; 0 || !node_pipeline-&gt;mayHaveNoCode())
2250       _bundle_use.add_usage(node_usage);
2251 
2252     // Increment the number of instructions in this bundle
2253     _bundle_instr_count += instruction_count;
2254 
2255     // Remember this node for later
2256     if (n-&gt;is_Mach())
2257       _next_node = n;
2258   }
2259 
2260   // It&#39;s possible to have a BoxLock in the graph and in the _bbs mapping but
2261   // not in the bb-&gt;_nodes array.  This happens for debug-info-only BoxLocks.
2262   // &#39;Schedule&#39; them (basically ignore in the schedule) but do not insert them
2263   // into the block.  All other scheduled nodes get put in the schedule here.
2264   int op = n-&gt;Opcode();
2265   if( (op == Op_Node &amp;&amp; n-&gt;req() == 0) || // anti-dependence node OR
2266       (op != Op_Node &amp;&amp;         // Not an unused antidepedence node and
2267        // not an unallocated boxlock
2268        (OptoReg::is_valid(_regalloc-&gt;get_reg_first(n)) || op != Op_BoxLock)) ) {
2269 
2270     // Push any trailing projections
2271     if( bb-&gt;get_node(bb-&gt;number_of_nodes()-1) != n ) {
2272       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
2273         Node *foi = n-&gt;fast_out(i);
2274         if( foi-&gt;is_Proj() )
2275           _scheduled.push(foi);
2276       }
2277     }
2278 
2279     // Put the instruction in the schedule list
2280     _scheduled.push(n);
2281   }
2282 
2283 #ifndef PRODUCT
2284   if (_cfg-&gt;C-&gt;trace_opto_output())
2285     dump_available();
2286 #endif
2287 
2288   // Walk all the definitions, decrementing use counts, and
2289   // if a definition has a 0 use count, place it in the available list.
2290   DecrementUseCounts(n,bb);
2291 }
2292 
2293 // This method sets the use count within a basic block.  We will ignore all
2294 // uses outside the current basic block.  As we are doing a backwards walk,
2295 // any node we reach that has a use count of 0 may be scheduled.  This also
2296 // avoids the problem of cyclic references from phi nodes, as long as phi
2297 // nodes are at the front of the basic block.  This method also initializes
2298 // the available list to the set of instructions that have no uses within this
2299 // basic block.
2300 void Scheduling::ComputeUseCount(const Block *bb) {
2301 #ifndef PRODUCT
2302   if (_cfg-&gt;C-&gt;trace_opto_output())
2303     tty-&gt;print(&quot;# -&gt; ComputeUseCount\n&quot;);
2304 #endif
2305 
2306   // Clear the list of available and scheduled instructions, just in case
2307   _available.clear();
2308   _scheduled.clear();
2309 
2310   // No delay slot specified
2311   _unconditional_delay_slot = NULL;
2312 
2313 #ifdef ASSERT
2314   for( uint i=0; i &lt; bb-&gt;number_of_nodes(); i++ )
2315     assert( _uses[bb-&gt;get_node(i)-&gt;_idx] == 0, &quot;_use array not clean&quot; );
2316 #endif
2317 
2318   // Force the _uses count to never go to zero for unscheduable pieces
2319   // of the block
2320   for( uint k = 0; k &lt; _bb_start; k++ )
2321     _uses[bb-&gt;get_node(k)-&gt;_idx] = 1;
2322   for( uint l = _bb_end; l &lt; bb-&gt;number_of_nodes(); l++ )
2323     _uses[bb-&gt;get_node(l)-&gt;_idx] = 1;
2324 
2325   // Iterate backwards over the instructions in the block.  Don&#39;t count the
2326   // branch projections at end or the block header instructions.
2327   for( uint j = _bb_end-1; j &gt;= _bb_start; j-- ) {
2328     Node *n = bb-&gt;get_node(j);
2329     if( n-&gt;is_Proj() ) continue; // Projections handled another way
2330 
2331     // Account for all uses
2332     for ( uint k = 0; k &lt; n-&gt;len(); k++ ) {
2333       Node *inp = n-&gt;in(k);
2334       if (!inp) continue;
2335       assert(inp != n, &quot;no cycles allowed&quot; );
2336       if (_cfg-&gt;get_block_for_node(inp) == bb) { // Block-local use?
2337         if (inp-&gt;is_Proj()) { // Skip through Proj&#39;s
2338           inp = inp-&gt;in(0);
2339         }
2340         ++_uses[inp-&gt;_idx];     // Count 1 block-local use
2341       }
2342     }
2343 
2344     // If this instruction has a 0 use count, then it is available
2345     if (!_uses[n-&gt;_idx]) {
2346       _current_latency[n-&gt;_idx] = _bundle_cycle_number;
2347       AddNodeToAvailableList(n);
2348     }
2349 
2350 #ifndef PRODUCT
2351     if (_cfg-&gt;C-&gt;trace_opto_output()) {
2352       tty-&gt;print(&quot;#   uses: %3d: &quot;, _uses[n-&gt;_idx]);
2353       n-&gt;dump();
2354     }
2355 #endif
2356   }
2357 
2358 #ifndef PRODUCT
2359   if (_cfg-&gt;C-&gt;trace_opto_output())
2360     tty-&gt;print(&quot;# &lt;- ComputeUseCount\n&quot;);
2361 #endif
2362 }
2363 
2364 // This routine performs scheduling on each basic block in reverse order,
2365 // using instruction latencies and taking into account function unit
2366 // availability.
2367 void Scheduling::DoScheduling() {
2368 #ifndef PRODUCT
2369   if (_cfg-&gt;C-&gt;trace_opto_output())
2370     tty-&gt;print(&quot;# -&gt; DoScheduling\n&quot;);
2371 #endif
2372 
2373   Block *succ_bb = NULL;
2374   Block *bb;
2375 
2376   // Walk over all the basic blocks in reverse order
2377   for (int i = _cfg-&gt;number_of_blocks() - 1; i &gt;= 0; succ_bb = bb, i--) {
2378     bb = _cfg-&gt;get_block(i);
2379 
2380 #ifndef PRODUCT
2381     if (_cfg-&gt;C-&gt;trace_opto_output()) {
2382       tty-&gt;print(&quot;#  Schedule BB#%03d (initial)\n&quot;, i);
2383       for (uint j = 0; j &lt; bb-&gt;number_of_nodes(); j++) {
2384         bb-&gt;get_node(j)-&gt;dump();
2385       }
2386     }
2387 #endif
2388 
2389     // On the head node, skip processing
2390     if (bb == _cfg-&gt;get_root_block()) {
2391       continue;
2392     }
2393 
2394     // Skip empty, connector blocks
2395     if (bb-&gt;is_connector())
2396       continue;
2397 
2398     // If the following block is not the sole successor of
2399     // this one, then reset the pipeline information
2400     if (bb-&gt;_num_succs != 1 || bb-&gt;non_connector_successor(0) != succ_bb) {
2401 #ifndef PRODUCT
2402       if (_cfg-&gt;C-&gt;trace_opto_output()) {
2403         tty-&gt;print(&quot;*** bundle start of next BB, node %d, for %d instructions\n&quot;,
2404                    _next_node-&gt;_idx, _bundle_instr_count);
2405       }
2406 #endif
2407       step_and_clear();
2408     }
2409 
2410     // Leave untouched the starting instruction, any Phis, a CreateEx node
2411     // or Top.  bb-&gt;get_node(_bb_start) is the first schedulable instruction.
2412     _bb_end = bb-&gt;number_of_nodes()-1;
2413     for( _bb_start=1; _bb_start &lt;= _bb_end; _bb_start++ ) {
2414       Node *n = bb-&gt;get_node(_bb_start);
2415       // Things not matched, like Phinodes and ProjNodes don&#39;t get scheduled.
2416       // Also, MachIdealNodes do not get scheduled
2417       if( !n-&gt;is_Mach() ) continue;     // Skip non-machine nodes
2418       MachNode *mach = n-&gt;as_Mach();
2419       int iop = mach-&gt;ideal_Opcode();
2420       if( iop == Op_CreateEx ) continue; // CreateEx is pinned
2421       if( iop == Op_Con ) continue;      // Do not schedule Top
2422       if( iop == Op_Node &amp;&amp;     // Do not schedule PhiNodes, ProjNodes
2423           mach-&gt;pipeline() == MachNode::pipeline_class() &amp;&amp;
2424           !n-&gt;is_SpillCopy() &amp;&amp; !n-&gt;is_MachMerge() )  // Breakpoints, Prolog, etc
2425         continue;
2426       break;                    // Funny loop structure to be sure...
2427     }
2428     // Compute last &quot;interesting&quot; instruction in block - last instruction we
2429     // might schedule.  _bb_end points just after last schedulable inst.  We
2430     // normally schedule conditional branches (despite them being forced last
2431     // in the block), because they have delay slots we can fill.  Calls all
2432     // have their delay slots filled in the template expansions, so we don&#39;t
2433     // bother scheduling them.
2434     Node *last = bb-&gt;get_node(_bb_end);
2435     // Ignore trailing NOPs.
2436     while (_bb_end &gt; 0 &amp;&amp; last-&gt;is_Mach() &amp;&amp;
2437            last-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Con) {
2438       last = bb-&gt;get_node(--_bb_end);
2439     }
2440     assert(!last-&gt;is_Mach() || last-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Con, &quot;&quot;);
2441     if( last-&gt;is_Catch() ||
2442         (last-&gt;is_Mach() &amp;&amp; last-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Halt) ) {
2443       // There might be a prior call.  Skip it.
2444       while (_bb_start &lt; _bb_end &amp;&amp; bb-&gt;get_node(--_bb_end)-&gt;is_MachProj());
2445     } else if( last-&gt;is_MachNullCheck() ) {
2446       // Backup so the last null-checked memory instruction is
2447       // outside the schedulable range. Skip over the nullcheck,
2448       // projection, and the memory nodes.
2449       Node *mem = last-&gt;in(1);
2450       do {
2451         _bb_end--;
2452       } while (mem != bb-&gt;get_node(_bb_end));
2453     } else {
2454       // Set _bb_end to point after last schedulable inst.
2455       _bb_end++;
2456     }
2457 
2458     assert( _bb_start &lt;= _bb_end, &quot;inverted block ends&quot; );
2459 
2460     // Compute the register antidependencies for the basic block
2461     ComputeRegisterAntidependencies(bb);
2462     if (_cfg-&gt;C-&gt;failing())  return;  // too many D-U pinch points
2463 
2464     // Compute intra-bb latencies for the nodes
2465     ComputeLocalLatenciesForward(bb);
2466 
2467     // Compute the usage within the block, and set the list of all nodes
2468     // in the block that have no uses within the block.
2469     ComputeUseCount(bb);
2470 
2471     // Schedule the remaining instructions in the block
2472     while ( _available.size() &gt; 0 ) {
2473       Node *n = ChooseNodeToBundle();
2474       guarantee(n != NULL, &quot;no nodes available&quot;);
2475       AddNodeToBundle(n,bb);
2476     }
2477 
2478     assert( _scheduled.size() == _bb_end - _bb_start, &quot;wrong number of instructions&quot; );
2479 #ifdef ASSERT
2480     for( uint l = _bb_start; l &lt; _bb_end; l++ ) {
2481       Node *n = bb-&gt;get_node(l);
2482       uint m;
2483       for( m = 0; m &lt; _bb_end-_bb_start; m++ )
2484         if( _scheduled[m] == n )
2485           break;
2486       assert( m &lt; _bb_end-_bb_start, &quot;instruction missing in schedule&quot; );
2487     }
2488 #endif
2489 
2490     // Now copy the instructions (in reverse order) back to the block
2491     for ( uint k = _bb_start; k &lt; _bb_end; k++ )
2492       bb-&gt;map_node(_scheduled[_bb_end-k-1], k);
2493 
2494 #ifndef PRODUCT
2495     if (_cfg-&gt;C-&gt;trace_opto_output()) {
2496       tty-&gt;print(&quot;#  Schedule BB#%03d (final)\n&quot;, i);
2497       uint current = 0;
2498       for (uint j = 0; j &lt; bb-&gt;number_of_nodes(); j++) {
2499         Node *n = bb-&gt;get_node(j);
2500         if( valid_bundle_info(n) ) {
2501           Bundle *bundle = node_bundling(n);
2502           if (bundle-&gt;instr_count() &gt; 0 || bundle-&gt;flags() &gt; 0) {
2503             tty-&gt;print(&quot;*** Bundle: &quot;);
2504             bundle-&gt;dump();
2505           }
2506           n-&gt;dump();
2507         }
2508       }
2509     }
2510 #endif
2511 #ifdef ASSERT
2512     verify_good_schedule(bb,&quot;after block local scheduling&quot;);
2513 #endif
2514   }
2515 
2516 #ifndef PRODUCT
2517   if (_cfg-&gt;C-&gt;trace_opto_output())
2518     tty-&gt;print(&quot;# &lt;- DoScheduling\n&quot;);
2519 #endif
2520 
2521   // Record final node-bundling array location
2522   _regalloc-&gt;C-&gt;set_node_bundling_base(_node_bundling_base);
2523 
2524 } // end DoScheduling
2525 
2526 // Verify that no live-range used in the block is killed in the block by a
2527 // wrong DEF.  This doesn&#39;t verify live-ranges that span blocks.
2528 
2529 // Check for edge existence.  Used to avoid adding redundant precedence edges.
2530 static bool edge_from_to( Node *from, Node *to ) {
2531   for( uint i=0; i&lt;from-&gt;len(); i++ )
2532     if( from-&gt;in(i) == to )
2533       return true;
2534   return false;
2535 }
2536 
2537 #ifdef ASSERT
2538 void Scheduling::verify_do_def( Node *n, OptoReg::Name def, const char *msg ) {
2539   // Check for bad kills
2540   if( OptoReg::is_valid(def) ) { // Ignore stores &amp; control flow
2541     Node *prior_use = _reg_node[def];
2542     if( prior_use &amp;&amp; !edge_from_to(prior_use,n) ) {
2543       tty-&gt;print(&quot;%s = &quot;,OptoReg::as_VMReg(def)-&gt;name());
2544       n-&gt;dump();
2545       tty-&gt;print_cr(&quot;...&quot;);
2546       prior_use-&gt;dump();
2547       assert(edge_from_to(prior_use,n), &quot;%s&quot;, msg);
2548     }
2549     _reg_node.map(def,NULL); // Kill live USEs
2550   }
2551 }
2552 
2553 void Scheduling::verify_good_schedule( Block *b, const char *msg ) {
2554 
2555   // Zap to something reasonable for the verify code
2556   _reg_node.clear();
2557 
2558   // Walk over the block backwards.  Check to make sure each DEF doesn&#39;t
2559   // kill a live value (other than the one it&#39;s supposed to).  Add each
2560   // USE to the live set.
2561   for( uint i = b-&gt;number_of_nodes()-1; i &gt;= _bb_start; i-- ) {
2562     Node *n = b-&gt;get_node(i);
2563     int n_op = n-&gt;Opcode();
2564     if( n_op == Op_MachProj &amp;&amp; n-&gt;ideal_reg() == MachProjNode::fat_proj ) {
2565       // Fat-proj kills a slew of registers
2566       RegMask rm = n-&gt;out_RegMask();// Make local copy
2567       while( rm.is_NotEmpty() ) {
2568         OptoReg::Name kill = rm.find_first_elem();
2569         rm.Remove(kill);
2570         verify_do_def( n, kill, msg );
2571       }
2572     } else if( n_op != Op_Node ) { // Avoid brand new antidependence nodes
2573       // Get DEF&#39;d registers the normal way
2574       verify_do_def( n, _regalloc-&gt;get_reg_first(n), msg );
2575       verify_do_def( n, _regalloc-&gt;get_reg_second(n), msg );
2576     }
2577 
2578     // Now make all USEs live
2579     for( uint i=1; i&lt;n-&gt;req(); i++ ) {
2580       Node *def = n-&gt;in(i);
2581       assert(def != 0, &quot;input edge required&quot;);
2582       OptoReg::Name reg_lo = _regalloc-&gt;get_reg_first(def);
2583       OptoReg::Name reg_hi = _regalloc-&gt;get_reg_second(def);
2584       if( OptoReg::is_valid(reg_lo) ) {
2585         assert(!_reg_node[reg_lo] || edge_from_to(_reg_node[reg_lo],def), &quot;%s&quot;, msg);
2586         _reg_node.map(reg_lo,n);
2587       }
2588       if( OptoReg::is_valid(reg_hi) ) {
2589         assert(!_reg_node[reg_hi] || edge_from_to(_reg_node[reg_hi],def), &quot;%s&quot;, msg);
2590         _reg_node.map(reg_hi,n);
2591       }
2592     }
2593 
2594   }
2595 
2596   // Zap to something reasonable for the Antidependence code
2597   _reg_node.clear();
2598 }
2599 #endif
2600 
2601 // Conditionally add precedence edges.  Avoid putting edges on Projs.
2602 static void add_prec_edge_from_to( Node *from, Node *to ) {
2603   if( from-&gt;is_Proj() ) {       // Put precedence edge on Proj&#39;s input
2604     assert( from-&gt;req() == 1 &amp;&amp; (from-&gt;len() == 1 || from-&gt;in(1)==0), &quot;no precedence edges on projections&quot; );
2605     from = from-&gt;in(0);
2606   }
2607   if( from != to &amp;&amp;             // No cycles (for things like LD L0,[L0+4] )
2608       !edge_from_to( from, to ) ) // Avoid duplicate edge
2609     from-&gt;add_prec(to);
2610 }
2611 
2612 void Scheduling::anti_do_def( Block *b, Node *def, OptoReg::Name def_reg, int is_def ) {
2613   if( !OptoReg::is_valid(def_reg) ) // Ignore stores &amp; control flow
2614     return;
2615 
2616   Node *pinch = _reg_node[def_reg]; // Get pinch point
2617   if ((pinch == NULL) || _cfg-&gt;get_block_for_node(pinch) != b || // No pinch-point yet?
2618       is_def ) {    // Check for a true def (not a kill)
2619     _reg_node.map(def_reg,def); // Record def/kill as the optimistic pinch-point
2620     return;
2621   }
2622 
2623   Node *kill = def;             // Rename &#39;def&#39; to more descriptive &#39;kill&#39;
2624   debug_only( def = (Node*)((intptr_t)0xdeadbeef); )
2625 
2626   // After some number of kills there _may_ be a later def
2627   Node *later_def = NULL;
2628 
2629   // Finding a kill requires a real pinch-point.
2630   // Check for not already having a pinch-point.
2631   // Pinch points are Op_Node&#39;s.
2632   if( pinch-&gt;Opcode() != Op_Node ) { // Or later-def/kill as pinch-point?
2633     later_def = pinch;            // Must be def/kill as optimistic pinch-point
2634     if ( _pinch_free_list.size() &gt; 0) {
2635       pinch = _pinch_free_list.pop();
2636     } else {
2637       pinch = new Node(1); // Pinch point to-be
2638     }
2639     if (pinch-&gt;_idx &gt;= _regalloc-&gt;node_regs_max_index()) {
2640       _cfg-&gt;C-&gt;record_method_not_compilable(&quot;too many D-U pinch points&quot;);
2641       return;
2642     }
2643     _cfg-&gt;map_node_to_block(pinch, b);      // Pretend it&#39;s valid in this block (lazy init)
2644     _reg_node.map(def_reg,pinch); // Record pinch-point
2645     //_regalloc-&gt;set_bad(pinch-&gt;_idx); // Already initialized this way.
2646     if( later_def-&gt;outcnt() == 0 || later_def-&gt;ideal_reg() == MachProjNode::fat_proj ) { // Distinguish def from kill
2647       pinch-&gt;init_req(0, _cfg-&gt;C-&gt;top());     // set not NULL for the next call
2648       add_prec_edge_from_to(later_def,pinch); // Add edge from kill to pinch
2649       later_def = NULL;           // and no later def
2650     }
2651     pinch-&gt;set_req(0,later_def);  // Hook later def so we can find it
2652   } else {                        // Else have valid pinch point
2653     if( pinch-&gt;in(0) )            // If there is a later-def
2654       later_def = pinch-&gt;in(0);   // Get it
2655   }
2656 
2657   // Add output-dependence edge from later def to kill
2658   if( later_def )               // If there is some original def
2659     add_prec_edge_from_to(later_def,kill); // Add edge from def to kill
2660 
2661   // See if current kill is also a use, and so is forced to be the pinch-point.
2662   if( pinch-&gt;Opcode() == Op_Node ) {
2663     Node *uses = kill-&gt;is_Proj() ? kill-&gt;in(0) : kill;
2664     for( uint i=1; i&lt;uses-&gt;req(); i++ ) {
2665       if( _regalloc-&gt;get_reg_first(uses-&gt;in(i)) == def_reg ||
2666           _regalloc-&gt;get_reg_second(uses-&gt;in(i)) == def_reg ) {
2667         // Yes, found a use/kill pinch-point
2668         pinch-&gt;set_req(0,NULL);  //
2669         pinch-&gt;replace_by(kill); // Move anti-dep edges up
2670         pinch = kill;
2671         _reg_node.map(def_reg,pinch);
2672         return;
2673       }
2674     }
2675   }
2676 
2677   // Add edge from kill to pinch-point
2678   add_prec_edge_from_to(kill,pinch);
2679 }
2680 
2681 void Scheduling::anti_do_use( Block *b, Node *use, OptoReg::Name use_reg ) {
2682   if( !OptoReg::is_valid(use_reg) ) // Ignore stores &amp; control flow
2683     return;
2684   Node *pinch = _reg_node[use_reg]; // Get pinch point
2685   // Check for no later def_reg/kill in block
2686   if ((pinch != NULL) &amp;&amp; _cfg-&gt;get_block_for_node(pinch) == b &amp;&amp;
2687       // Use has to be block-local as well
2688       _cfg-&gt;get_block_for_node(use) == b) {
2689     if( pinch-&gt;Opcode() == Op_Node &amp;&amp; // Real pinch-point (not optimistic?)
2690         pinch-&gt;req() == 1 ) {   // pinch not yet in block?
2691       pinch-&gt;del_req(0);        // yank pointer to later-def, also set flag
2692       // Insert the pinch-point in the block just after the last use
2693       b-&gt;insert_node(pinch, b-&gt;find_node(use) + 1);
2694       _bb_end++;                // Increase size scheduled region in block
2695     }
2696 
2697     add_prec_edge_from_to(pinch,use);
2698   }
2699 }
2700 
2701 // We insert antidependences between the reads and following write of
2702 // allocated registers to prevent illegal code motion. Hopefully, the
2703 // number of added references should be fairly small, especially as we
2704 // are only adding references within the current basic block.
2705 void Scheduling::ComputeRegisterAntidependencies(Block *b) {
2706 
2707 #ifdef ASSERT
2708   verify_good_schedule(b,&quot;before block local scheduling&quot;);
2709 #endif
2710 
2711   // A valid schedule, for each register independently, is an endless cycle
2712   // of: a def, then some uses (connected to the def by true dependencies),
2713   // then some kills (defs with no uses), finally the cycle repeats with a new
2714   // def.  The uses are allowed to float relative to each other, as are the
2715   // kills.  No use is allowed to slide past a kill (or def).  This requires
2716   // antidependencies between all uses of a single def and all kills that
2717   // follow, up to the next def.  More edges are redundant, because later defs
2718   // &amp; kills are already serialized with true or antidependencies.  To keep
2719   // the edge count down, we add a &#39;pinch point&#39; node if there&#39;s more than
2720   // one use or more than one kill/def.
2721 
2722   // We add dependencies in one bottom-up pass.
2723 
2724   // For each instruction we handle it&#39;s DEFs/KILLs, then it&#39;s USEs.
2725 
2726   // For each DEF/KILL, we check to see if there&#39;s a prior DEF/KILL for this
2727   // register.  If not, we record the DEF/KILL in _reg_node, the
2728   // register-to-def mapping.  If there is a prior DEF/KILL, we insert a
2729   // &quot;pinch point&quot;, a new Node that&#39;s in the graph but not in the block.
2730   // We put edges from the prior and current DEF/KILLs to the pinch point.
2731   // We put the pinch point in _reg_node.  If there&#39;s already a pinch point
2732   // we merely add an edge from the current DEF/KILL to the pinch point.
2733 
2734   // After doing the DEF/KILLs, we handle USEs.  For each used register, we
2735   // put an edge from the pinch point to the USE.
2736 
2737   // To be expedient, the _reg_node array is pre-allocated for the whole
2738   // compilation.  _reg_node is lazily initialized; it either contains a NULL,
2739   // or a valid def/kill/pinch-point, or a leftover node from some prior
2740   // block.  Leftover node from some prior block is treated like a NULL (no
2741   // prior def, so no anti-dependence needed).  Valid def is distinguished by
2742   // it being in the current block.
2743   bool fat_proj_seen = false;
2744   uint last_safept = _bb_end-1;
2745   Node* end_node         = (_bb_end-1 &gt;= _bb_start) ? b-&gt;get_node(last_safept) : NULL;
2746   Node* last_safept_node = end_node;
2747   for( uint i = _bb_end-1; i &gt;= _bb_start; i-- ) {
2748     Node *n = b-&gt;get_node(i);
2749     int is_def = n-&gt;outcnt();   // def if some uses prior to adding precedence edges
2750     if( n-&gt;is_MachProj() &amp;&amp; n-&gt;ideal_reg() == MachProjNode::fat_proj ) {
2751       // Fat-proj kills a slew of registers
2752       // This can add edges to &#39;n&#39; and obscure whether or not it was a def,
2753       // hence the is_def flag.
2754       fat_proj_seen = true;
2755       RegMask rm = n-&gt;out_RegMask();// Make local copy
2756       while( rm.is_NotEmpty() ) {
2757         OptoReg::Name kill = rm.find_first_elem();
2758         rm.Remove(kill);
2759         anti_do_def( b, n, kill, is_def );
2760       }
2761     } else {
2762       // Get DEF&#39;d registers the normal way
2763       anti_do_def( b, n, _regalloc-&gt;get_reg_first(n), is_def );
2764       anti_do_def( b, n, _regalloc-&gt;get_reg_second(n), is_def );
2765     }
2766 
2767     // Kill projections on a branch should appear to occur on the
2768     // branch, not afterwards, so grab the masks from the projections
2769     // and process them.
2770     if (n-&gt;is_MachBranch() || (n-&gt;is_Mach() &amp;&amp; n-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Jump)) {
2771       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
2772         Node* use = n-&gt;fast_out(i);
2773         if (use-&gt;is_Proj()) {
2774           RegMask rm = use-&gt;out_RegMask();// Make local copy
2775           while( rm.is_NotEmpty() ) {
2776             OptoReg::Name kill = rm.find_first_elem();
2777             rm.Remove(kill);
2778             anti_do_def( b, n, kill, false );
2779           }
2780         }
2781       }
2782     }
2783 
2784     // Check each register used by this instruction for a following DEF/KILL
2785     // that must occur afterward and requires an anti-dependence edge.
2786     for( uint j=0; j&lt;n-&gt;req(); j++ ) {
2787       Node *def = n-&gt;in(j);
2788       if( def ) {
2789         assert( !def-&gt;is_MachProj() || def-&gt;ideal_reg() != MachProjNode::fat_proj, &quot;&quot; );
2790         anti_do_use( b, n, _regalloc-&gt;get_reg_first(def) );
2791         anti_do_use( b, n, _regalloc-&gt;get_reg_second(def) );
2792       }
2793     }
2794     // Do not allow defs of new derived values to float above GC
2795     // points unless the base is definitely available at the GC point.
2796 
2797     Node *m = b-&gt;get_node(i);
2798 
2799     // Add precedence edge from following safepoint to use of derived pointer
2800     if( last_safept_node != end_node &amp;&amp;
2801         m != last_safept_node) {
2802       for (uint k = 1; k &lt; m-&gt;req(); k++) {
2803         const Type *t = m-&gt;in(k)-&gt;bottom_type();
2804         if( t-&gt;isa_oop_ptr() &amp;&amp;
2805             t-&gt;is_ptr()-&gt;offset() != 0 ) {
2806           last_safept_node-&gt;add_prec( m );
2807           break;
2808         }
2809       }
2810     }
2811 
2812     if( n-&gt;jvms() ) {           // Precedence edge from derived to safept
2813       // Check if last_safept_node was moved by pinch-point insertion in anti_do_use()
2814       if( b-&gt;get_node(last_safept) != last_safept_node ) {
2815         last_safept = b-&gt;find_node(last_safept_node);
2816       }
2817       for( uint j=last_safept; j &gt; i; j-- ) {
2818         Node *mach = b-&gt;get_node(j);
2819         if( mach-&gt;is_Mach() &amp;&amp; mach-&gt;as_Mach()-&gt;ideal_Opcode() == Op_AddP )
2820           mach-&gt;add_prec( n );
2821       }
2822       last_safept = i;
2823       last_safept_node = m;
2824     }
2825   }
2826 
2827   if (fat_proj_seen) {
2828     // Garbage collect pinch nodes that were not consumed.
2829     // They are usually created by a fat kill MachProj for a call.
2830     garbage_collect_pinch_nodes();
2831   }
2832 }
2833 
2834 // Garbage collect pinch nodes for reuse by other blocks.
2835 //
2836 // The block scheduler&#39;s insertion of anti-dependence
2837 // edges creates many pinch nodes when the block contains
2838 // 2 or more Calls.  A pinch node is used to prevent a
2839 // combinatorial explosion of edges.  If a set of kills for a
2840 // register is anti-dependent on a set of uses (or defs), rather
2841 // than adding an edge in the graph between each pair of kill
2842 // and use (or def), a pinch is inserted between them:
2843 //
2844 //            use1   use2  use3
2845 //                \   |   /
2846 //                 \  |  /
2847 //                  pinch
2848 //                 /  |  \
2849 //                /   |   \
2850 //            kill1 kill2 kill3
2851 //
2852 // One pinch node is created per register killed when
2853 // the second call is encountered during a backwards pass
2854 // over the block.  Most of these pinch nodes are never
2855 // wired into the graph because the register is never
2856 // used or def&#39;ed in the block.
2857 //
2858 void Scheduling::garbage_collect_pinch_nodes() {
2859 #ifndef PRODUCT
2860   if (_cfg-&gt;C-&gt;trace_opto_output()) tty-&gt;print(&quot;Reclaimed pinch nodes:&quot;);
2861 #endif
2862   int trace_cnt = 0;
2863   for (uint k = 0; k &lt; _reg_node.Size(); k++) {
2864     Node* pinch = _reg_node[k];
2865     if ((pinch != NULL) &amp;&amp; pinch-&gt;Opcode() == Op_Node &amp;&amp;
2866         // no predecence input edges
2867         (pinch-&gt;req() == pinch-&gt;len() || pinch-&gt;in(pinch-&gt;req()) == NULL) ) {
2868       cleanup_pinch(pinch);
2869       _pinch_free_list.push(pinch);
2870       _reg_node.map(k, NULL);
2871 #ifndef PRODUCT
2872       if (_cfg-&gt;C-&gt;trace_opto_output()) {
2873         trace_cnt++;
2874         if (trace_cnt &gt; 40) {
2875           tty-&gt;print(&quot;\n&quot;);
2876           trace_cnt = 0;
2877         }
2878         tty-&gt;print(&quot; %d&quot;, pinch-&gt;_idx);
2879       }
2880 #endif
2881     }
2882   }
2883 #ifndef PRODUCT
2884   if (_cfg-&gt;C-&gt;trace_opto_output()) tty-&gt;print(&quot;\n&quot;);
2885 #endif
2886 }
2887 
2888 // Clean up a pinch node for reuse.
2889 void Scheduling::cleanup_pinch( Node *pinch ) {
2890   assert (pinch &amp;&amp; pinch-&gt;Opcode() == Op_Node &amp;&amp; pinch-&gt;req() == 1, &quot;just checking&quot;);
2891 
2892   for (DUIterator_Last imin, i = pinch-&gt;last_outs(imin); i &gt;= imin; ) {
2893     Node* use = pinch-&gt;last_out(i);
2894     uint uses_found = 0;
2895     for (uint j = use-&gt;req(); j &lt; use-&gt;len(); j++) {
2896       if (use-&gt;in(j) == pinch) {
2897         use-&gt;rm_prec(j);
2898         uses_found++;
2899       }
2900     }
2901     assert(uses_found &gt; 0, &quot;must be a precedence edge&quot;);
2902     i -= uses_found;    // we deleted 1 or more copies of this edge
2903   }
2904   // May have a later_def entry
2905   pinch-&gt;set_req(0, NULL);
2906 }
2907 
2908 #ifndef PRODUCT
2909 
2910 void Scheduling::dump_available() const {
2911   tty-&gt;print(&quot;#Availist  &quot;);
2912   for (uint i = 0; i &lt; _available.size(); i++)
2913     tty-&gt;print(&quot; N%d/l%d&quot;, _available[i]-&gt;_idx,_current_latency[_available[i]-&gt;_idx]);
2914   tty-&gt;cr();
2915 }
2916 
2917 // Print Scheduling Statistics
2918 void Scheduling::print_statistics() {
2919   // Print the size added by nops for bundling
2920   tty-&gt;print(&quot;Nops added %d bytes to total of %d bytes&quot;,
2921              _total_nop_size, _total_method_size);
2922   if (_total_method_size &gt; 0)
2923     tty-&gt;print(&quot;, for %.2f%%&quot;,
2924                ((double)_total_nop_size) / ((double) _total_method_size) * 100.0);
2925   tty-&gt;print(&quot;\n&quot;);
2926 
2927   // Print the number of branch shadows filled
2928   if (Pipeline::_branch_has_delay_slot) {
2929     tty-&gt;print(&quot;Of %d branches, %d had unconditional delay slots filled&quot;,
2930                _total_branches, _total_unconditional_delays);
2931     if (_total_branches &gt; 0)
2932       tty-&gt;print(&quot;, for %.2f%%&quot;,
2933                  ((double)_total_unconditional_delays) / ((double)_total_branches) * 100.0);
2934     tty-&gt;print(&quot;\n&quot;);
2935   }
2936 
2937   uint total_instructions = 0, total_bundles = 0;
2938 
2939   for (uint i = 1; i &lt;= Pipeline::_max_instrs_per_cycle; i++) {
2940     uint bundle_count   = _total_instructions_per_bundle[i];
2941     total_instructions += bundle_count * i;
2942     total_bundles      += bundle_count;
2943   }
2944 
2945   if (total_bundles &gt; 0)
2946     tty-&gt;print(&quot;Average ILP (excluding nops) is %.2f\n&quot;,
2947                ((double)total_instructions) / ((double)total_bundles));
2948 }
2949 #endif
    </pre>
  </body>
</html>
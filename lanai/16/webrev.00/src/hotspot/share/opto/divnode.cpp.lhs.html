<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/divnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2015, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;memory/allocation.inline.hpp&quot;
  27 #include &quot;opto/addnode.hpp&quot;
  28 #include &quot;opto/connode.hpp&quot;
  29 #include &quot;opto/convertnode.hpp&quot;
  30 #include &quot;opto/divnode.hpp&quot;
  31 #include &quot;opto/machnode.hpp&quot;
  32 #include &quot;opto/movenode.hpp&quot;
  33 #include &quot;opto/matcher.hpp&quot;
  34 #include &quot;opto/mulnode.hpp&quot;
  35 #include &quot;opto/phaseX.hpp&quot;
  36 #include &quot;opto/subnode.hpp&quot;
<a name="1" id="anc1"></a>
  37 
  38 // Portions of code courtesy of Clifford Click
  39 
  40 // Optimization - Graph Style
  41 
  42 #include &lt;math.h&gt;
  43 
  44 //----------------------magic_int_divide_constants-----------------------------
  45 // Compute magic multiplier and shift constant for converting a 32 bit divide
  46 // by constant into a multiply/shift/add series. Return false if calculations
  47 // fail.
  48 //
  49 // Borrowed almost verbatim from Hacker&#39;s Delight by Henry S. Warren, Jr. with
  50 // minor type name and parameter changes.
  51 static bool magic_int_divide_constants(jint d, jint &amp;M, jint &amp;s) {
  52   int32_t p;
  53   uint32_t ad, anc, delta, q1, r1, q2, r2, t;
  54   const uint32_t two31 = 0x80000000L;     // 2**31.
  55 
  56   ad = ABS(d);
  57   if (d == 0 || d == 1) return false;
  58   t = two31 + ((uint32_t)d &gt;&gt; 31);
  59   anc = t - 1 - t%ad;     // Absolute value of nc.
  60   p = 31;                 // Init. p.
  61   q1 = two31/anc;         // Init. q1 = 2**p/|nc|.
  62   r1 = two31 - q1*anc;    // Init. r1 = rem(2**p, |nc|).
  63   q2 = two31/ad;          // Init. q2 = 2**p/|d|.
  64   r2 = two31 - q2*ad;     // Init. r2 = rem(2**p, |d|).
  65   do {
  66     p = p + 1;
  67     q1 = 2*q1;            // Update q1 = 2**p/|nc|.
  68     r1 = 2*r1;            // Update r1 = rem(2**p, |nc|).
  69     if (r1 &gt;= anc) {      // (Must be an unsigned
  70       q1 = q1 + 1;        // comparison here).
  71       r1 = r1 - anc;
  72     }
  73     q2 = 2*q2;            // Update q2 = 2**p/|d|.
  74     r2 = 2*r2;            // Update r2 = rem(2**p, |d|).
  75     if (r2 &gt;= ad) {       // (Must be an unsigned
  76       q2 = q2 + 1;        // comparison here).
  77       r2 = r2 - ad;
  78     }
  79     delta = ad - r2;
  80   } while (q1 &lt; delta || (q1 == delta &amp;&amp; r1 == 0));
  81 
  82   M = q2 + 1;
  83   if (d &lt; 0) M = -M;      // Magic number and
  84   s = p - 32;             // shift amount to return.
  85 
  86   return true;
  87 }
  88 
  89 //--------------------------transform_int_divide-------------------------------
  90 // Convert a division by constant divisor into an alternate Ideal graph.
  91 // Return NULL if no transformation occurs.
  92 static Node *transform_int_divide( PhaseGVN *phase, Node *dividend, jint divisor ) {
  93 
  94   // Check for invalid divisors
  95   assert( divisor != 0 &amp;&amp; divisor != min_jint,
  96           &quot;bad divisor for transforming to long multiply&quot; );
  97 
  98   bool d_pos = divisor &gt;= 0;
  99   jint d = d_pos ? divisor : -divisor;
 100   const int N = 32;
 101 
 102   // Result
 103   Node *q = NULL;
 104 
 105   if (d == 1) {
 106     // division by +/- 1
 107     if (!d_pos) {
 108       // Just negate the value
 109       q = new SubINode(phase-&gt;intcon(0), dividend);
 110     }
 111   } else if ( is_power_of_2(d) ) {
 112     // division by +/- a power of 2
 113 
 114     // See if we can simply do a shift without rounding
 115     bool needs_rounding = true;
 116     const Type *dt = phase-&gt;type(dividend);
 117     const TypeInt *dti = dt-&gt;isa_int();
 118     if (dti &amp;&amp; dti-&gt;_lo &gt;= 0) {
 119       // we don&#39;t need to round a positive dividend
 120       needs_rounding = false;
 121     } else if( dividend-&gt;Opcode() == Op_AndI ) {
 122       // An AND mask of sufficient size clears the low bits and
 123       // I can avoid rounding.
 124       const TypeInt *andconi_t = phase-&gt;type( dividend-&gt;in(2) )-&gt;isa_int();
 125       if( andconi_t &amp;&amp; andconi_t-&gt;is_con() ) {
 126         jint andconi = andconi_t-&gt;get_con();
 127         if( andconi &lt; 0 &amp;&amp; is_power_of_2(-andconi) &amp;&amp; (-andconi) &gt;= d ) {
 128           if( (-andconi) == d ) // Remove AND if it clears bits which will be shifted
 129             dividend = dividend-&gt;in(1);
 130           needs_rounding = false;
 131         }
 132       }
 133     }
 134 
 135     // Add rounding to the shift to handle the sign bit
 136     int l = log2_jint(d-1)+1;
 137     if (needs_rounding) {
 138       // Divide-by-power-of-2 can be made into a shift, but you have to do
 139       // more math for the rounding.  You need to add 0 for positive
 140       // numbers, and &quot;i-1&quot; for negative numbers.  Example: i=4, so the
 141       // shift is by 2.  You need to add 3 to negative dividends and 0 to
 142       // positive ones.  So (-7+3)&gt;&gt;2 becomes -1, (-4+3)&gt;&gt;2 becomes -1,
 143       // (-2+3)&gt;&gt;2 becomes 0, etc.
 144 
 145       // Compute 0 or -1, based on sign bit
 146       Node *sign = phase-&gt;transform(new RShiftINode(dividend, phase-&gt;intcon(N - 1)));
 147       // Mask sign bit to the low sign bits
 148       Node *round = phase-&gt;transform(new URShiftINode(sign, phase-&gt;intcon(N - l)));
 149       // Round up before shifting
 150       dividend = phase-&gt;transform(new AddINode(dividend, round));
 151     }
 152 
 153     // Shift for division
 154     q = new RShiftINode(dividend, phase-&gt;intcon(l));
 155 
 156     if (!d_pos) {
 157       q = new SubINode(phase-&gt;intcon(0), phase-&gt;transform(q));
 158     }
 159   } else {
 160     // Attempt the jint constant divide -&gt; multiply transform found in
 161     //   &quot;Division by Invariant Integers using Multiplication&quot;
 162     //     by Granlund and Montgomery
 163     // See also &quot;Hacker&#39;s Delight&quot;, chapter 10 by Warren.
 164 
 165     jint magic_const;
 166     jint shift_const;
 167     if (magic_int_divide_constants(d, magic_const, shift_const)) {
 168       Node *magic = phase-&gt;longcon(magic_const);
 169       Node *dividend_long = phase-&gt;transform(new ConvI2LNode(dividend));
 170 
 171       // Compute the high half of the dividend x magic multiplication
 172       Node *mul_hi = phase-&gt;transform(new MulLNode(dividend_long, magic));
 173 
 174       if (magic_const &lt; 0) {
 175         mul_hi = phase-&gt;transform(new RShiftLNode(mul_hi, phase-&gt;intcon(N)));
 176         mul_hi = phase-&gt;transform(new ConvL2INode(mul_hi));
 177 
 178         // The magic multiplier is too large for a 32 bit constant. We&#39;ve adjusted
 179         // it down by 2^32, but have to add 1 dividend back in after the multiplication.
 180         // This handles the &quot;overflow&quot; case described by Granlund and Montgomery.
 181         mul_hi = phase-&gt;transform(new AddINode(dividend, mul_hi));
 182 
 183         // Shift over the (adjusted) mulhi
 184         if (shift_const != 0) {
 185           mul_hi = phase-&gt;transform(new RShiftINode(mul_hi, phase-&gt;intcon(shift_const)));
 186         }
 187       } else {
 188         // No add is required, we can merge the shifts together.
 189         mul_hi = phase-&gt;transform(new RShiftLNode(mul_hi, phase-&gt;intcon(N + shift_const)));
 190         mul_hi = phase-&gt;transform(new ConvL2INode(mul_hi));
 191       }
 192 
 193       // Get a 0 or -1 from the sign of the dividend.
 194       Node *addend0 = mul_hi;
 195       Node *addend1 = phase-&gt;transform(new RShiftINode(dividend, phase-&gt;intcon(N-1)));
 196 
 197       // If the divisor is negative, swap the order of the input addends;
 198       // this has the effect of negating the quotient.
 199       if (!d_pos) {
 200         Node *temp = addend0; addend0 = addend1; addend1 = temp;
 201       }
 202 
 203       // Adjust the final quotient by subtracting -1 (adding 1)
 204       // from the mul_hi.
 205       q = new SubINode(addend0, addend1);
 206     }
 207   }
 208 
 209   return q;
 210 }
 211 
 212 //---------------------magic_long_divide_constants-----------------------------
 213 // Compute magic multiplier and shift constant for converting a 64 bit divide
 214 // by constant into a multiply/shift/add series. Return false if calculations
 215 // fail.
 216 //
 217 // Borrowed almost verbatim from Hacker&#39;s Delight by Henry S. Warren, Jr. with
 218 // minor type name and parameter changes.  Adjusted to 64 bit word width.
 219 static bool magic_long_divide_constants(jlong d, jlong &amp;M, jint &amp;s) {
 220   int64_t p;
 221   uint64_t ad, anc, delta, q1, r1, q2, r2, t;
 222   const uint64_t two63 = UCONST64(0x8000000000000000);     // 2**63.
 223 
 224   ad = ABS(d);
 225   if (d == 0 || d == 1) return false;
 226   t = two63 + ((uint64_t)d &gt;&gt; 63);
 227   anc = t - 1 - t%ad;     // Absolute value of nc.
 228   p = 63;                 // Init. p.
 229   q1 = two63/anc;         // Init. q1 = 2**p/|nc|.
 230   r1 = two63 - q1*anc;    // Init. r1 = rem(2**p, |nc|).
 231   q2 = two63/ad;          // Init. q2 = 2**p/|d|.
 232   r2 = two63 - q2*ad;     // Init. r2 = rem(2**p, |d|).
 233   do {
 234     p = p + 1;
 235     q1 = 2*q1;            // Update q1 = 2**p/|nc|.
 236     r1 = 2*r1;            // Update r1 = rem(2**p, |nc|).
 237     if (r1 &gt;= anc) {      // (Must be an unsigned
 238       q1 = q1 + 1;        // comparison here).
 239       r1 = r1 - anc;
 240     }
 241     q2 = 2*q2;            // Update q2 = 2**p/|d|.
 242     r2 = 2*r2;            // Update r2 = rem(2**p, |d|).
 243     if (r2 &gt;= ad) {       // (Must be an unsigned
 244       q2 = q2 + 1;        // comparison here).
 245       r2 = r2 - ad;
 246     }
 247     delta = ad - r2;
 248   } while (q1 &lt; delta || (q1 == delta &amp;&amp; r1 == 0));
 249 
 250   M = q2 + 1;
 251   if (d &lt; 0) M = -M;      // Magic number and
 252   s = p - 64;             // shift amount to return.
 253 
 254   return true;
 255 }
 256 
 257 //---------------------long_by_long_mulhi--------------------------------------
 258 // Generate ideal node graph for upper half of a 64 bit x 64 bit multiplication
 259 static Node* long_by_long_mulhi(PhaseGVN* phase, Node* dividend, jlong magic_const) {
 260   // If the architecture supports a 64x64 mulhi, there is
 261   // no need to synthesize it in ideal nodes.
 262   if (Matcher::has_match_rule(Op_MulHiL)) {
 263     Node* v = phase-&gt;longcon(magic_const);
 264     return new MulHiLNode(dividend, v);
 265   }
 266 
 267   // Taken from Hacker&#39;s Delight, Fig. 8-2. Multiply high signed.
 268   // (http://www.hackersdelight.org/HDcode/mulhs.c)
 269   //
 270   // int mulhs(int u, int v) {
 271   //    unsigned u0, v0, w0;
 272   //    int u1, v1, w1, w2, t;
 273   //
 274   //    u0 = u &amp; 0xFFFF;  u1 = u &gt;&gt; 16;
 275   //    v0 = v &amp; 0xFFFF;  v1 = v &gt;&gt; 16;
 276   //    w0 = u0*v0;
 277   //    t  = u1*v0 + (w0 &gt;&gt; 16);
 278   //    w1 = t &amp; 0xFFFF;
 279   //    w2 = t &gt;&gt; 16;
 280   //    w1 = u0*v1 + w1;
 281   //    return u1*v1 + w2 + (w1 &gt;&gt; 16);
 282   // }
 283   //
 284   // Note: The version above is for 32x32 multiplications, while the
 285   // following inline comments are adapted to 64x64.
 286 
 287   const int N = 64;
 288 
 289   // Dummy node to keep intermediate nodes alive during construction
 290   Node* hook = new Node(4);
 291 
 292   // u0 = u &amp; 0xFFFFFFFF;  u1 = u &gt;&gt; 32;
 293   Node* u0 = phase-&gt;transform(new AndLNode(dividend, phase-&gt;longcon(0xFFFFFFFF)));
 294   Node* u1 = phase-&gt;transform(new RShiftLNode(dividend, phase-&gt;intcon(N / 2)));
 295   hook-&gt;init_req(0, u0);
 296   hook-&gt;init_req(1, u1);
 297 
 298   // v0 = v &amp; 0xFFFFFFFF;  v1 = v &gt;&gt; 32;
 299   Node* v0 = phase-&gt;longcon(magic_const &amp; 0xFFFFFFFF);
 300   Node* v1 = phase-&gt;longcon(magic_const &gt;&gt; (N / 2));
 301 
 302   // w0 = u0*v0;
 303   Node* w0 = phase-&gt;transform(new MulLNode(u0, v0));
 304 
 305   // t = u1*v0 + (w0 &gt;&gt; 32);
 306   Node* u1v0 = phase-&gt;transform(new MulLNode(u1, v0));
 307   Node* temp = phase-&gt;transform(new URShiftLNode(w0, phase-&gt;intcon(N / 2)));
 308   Node* t    = phase-&gt;transform(new AddLNode(u1v0, temp));
 309   hook-&gt;init_req(2, t);
 310 
 311   // w1 = t &amp; 0xFFFFFFFF;
 312   Node* w1 = phase-&gt;transform(new AndLNode(t, phase-&gt;longcon(0xFFFFFFFF)));
 313   hook-&gt;init_req(3, w1);
 314 
 315   // w2 = t &gt;&gt; 32;
 316   Node* w2 = phase-&gt;transform(new RShiftLNode(t, phase-&gt;intcon(N / 2)));
 317 
 318   // w1 = u0*v1 + w1;
 319   Node* u0v1 = phase-&gt;transform(new MulLNode(u0, v1));
 320   w1         = phase-&gt;transform(new AddLNode(u0v1, w1));
 321 
 322   // return u1*v1 + w2 + (w1 &gt;&gt; 32);
 323   Node* u1v1  = phase-&gt;transform(new MulLNode(u1, v1));
 324   Node* temp1 = phase-&gt;transform(new AddLNode(u1v1, w2));
 325   Node* temp2 = phase-&gt;transform(new RShiftLNode(w1, phase-&gt;intcon(N / 2)));
 326 
 327   // Remove the bogus extra edges used to keep things alive
 328   PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
 329   if (igvn != NULL) {
 330     igvn-&gt;remove_dead_node(hook);
 331   } else {
 332     for (int i = 0; i &lt; 4; i++) {
 333       hook-&gt;set_req(i, NULL);
 334     }
 335   }
 336 
 337   return new AddLNode(temp1, temp2);
 338 }
 339 
 340 
 341 //--------------------------transform_long_divide------------------------------
 342 // Convert a division by constant divisor into an alternate Ideal graph.
 343 // Return NULL if no transformation occurs.
 344 static Node *transform_long_divide( PhaseGVN *phase, Node *dividend, jlong divisor ) {
 345   // Check for invalid divisors
 346   assert( divisor != 0L &amp;&amp; divisor != min_jlong,
 347           &quot;bad divisor for transforming to long multiply&quot; );
 348 
 349   bool d_pos = divisor &gt;= 0;
 350   jlong d = d_pos ? divisor : -divisor;
 351   const int N = 64;
 352 
 353   // Result
 354   Node *q = NULL;
 355 
 356   if (d == 1) {
 357     // division by +/- 1
 358     if (!d_pos) {
 359       // Just negate the value
 360       q = new SubLNode(phase-&gt;longcon(0), dividend);
 361     }
<a name="2" id="anc2"></a><span class="line-modified"> 362   } else if ( is_power_of_2_long(d) ) {</span>
 363 
 364     // division by +/- a power of 2
 365 
 366     // See if we can simply do a shift without rounding
 367     bool needs_rounding = true;
 368     const Type *dt = phase-&gt;type(dividend);
 369     const TypeLong *dtl = dt-&gt;isa_long();
 370 
 371     if (dtl &amp;&amp; dtl-&gt;_lo &gt; 0) {
 372       // we don&#39;t need to round a positive dividend
 373       needs_rounding = false;
 374     } else if( dividend-&gt;Opcode() == Op_AndL ) {
 375       // An AND mask of sufficient size clears the low bits and
 376       // I can avoid rounding.
 377       const TypeLong *andconl_t = phase-&gt;type( dividend-&gt;in(2) )-&gt;isa_long();
 378       if( andconl_t &amp;&amp; andconl_t-&gt;is_con() ) {
 379         jlong andconl = andconl_t-&gt;get_con();
<a name="3" id="anc3"></a><span class="line-modified"> 380         if( andconl &lt; 0 &amp;&amp; is_power_of_2_long(-andconl) &amp;&amp; (-andconl) &gt;= d ) {</span>
 381           if( (-andconl) == d ) // Remove AND if it clears bits which will be shifted
 382             dividend = dividend-&gt;in(1);
 383           needs_rounding = false;
 384         }
 385       }
 386     }
 387 
 388     // Add rounding to the shift to handle the sign bit
 389     int l = log2_long(d-1)+1;
 390     if (needs_rounding) {
 391       // Divide-by-power-of-2 can be made into a shift, but you have to do
 392       // more math for the rounding.  You need to add 0 for positive
 393       // numbers, and &quot;i-1&quot; for negative numbers.  Example: i=4, so the
 394       // shift is by 2.  You need to add 3 to negative dividends and 0 to
 395       // positive ones.  So (-7+3)&gt;&gt;2 becomes -1, (-4+3)&gt;&gt;2 becomes -1,
 396       // (-2+3)&gt;&gt;2 becomes 0, etc.
 397 
 398       // Compute 0 or -1, based on sign bit
 399       Node *sign = phase-&gt;transform(new RShiftLNode(dividend, phase-&gt;intcon(N - 1)));
 400       // Mask sign bit to the low sign bits
 401       Node *round = phase-&gt;transform(new URShiftLNode(sign, phase-&gt;intcon(N - l)));
 402       // Round up before shifting
 403       dividend = phase-&gt;transform(new AddLNode(dividend, round));
 404     }
 405 
 406     // Shift for division
 407     q = new RShiftLNode(dividend, phase-&gt;intcon(l));
 408 
 409     if (!d_pos) {
 410       q = new SubLNode(phase-&gt;longcon(0), phase-&gt;transform(q));
 411     }
 412   } else if ( !Matcher::use_asm_for_ldiv_by_con(d) ) { // Use hardware DIV instruction when
 413                                                        // it is faster than code generated below.
 414     // Attempt the jlong constant divide -&gt; multiply transform found in
 415     //   &quot;Division by Invariant Integers using Multiplication&quot;
 416     //     by Granlund and Montgomery
 417     // See also &quot;Hacker&#39;s Delight&quot;, chapter 10 by Warren.
 418 
 419     jlong magic_const;
 420     jint shift_const;
 421     if (magic_long_divide_constants(d, magic_const, shift_const)) {
 422       // Compute the high half of the dividend x magic multiplication
 423       Node *mul_hi = phase-&gt;transform(long_by_long_mulhi(phase, dividend, magic_const));
 424 
 425       // The high half of the 128-bit multiply is computed.
 426       if (magic_const &lt; 0) {
 427         // The magic multiplier is too large for a 64 bit constant. We&#39;ve adjusted
 428         // it down by 2^64, but have to add 1 dividend back in after the multiplication.
 429         // This handles the &quot;overflow&quot; case described by Granlund and Montgomery.
 430         mul_hi = phase-&gt;transform(new AddLNode(dividend, mul_hi));
 431       }
 432 
 433       // Shift over the (adjusted) mulhi
 434       if (shift_const != 0) {
 435         mul_hi = phase-&gt;transform(new RShiftLNode(mul_hi, phase-&gt;intcon(shift_const)));
 436       }
 437 
 438       // Get a 0 or -1 from the sign of the dividend.
 439       Node *addend0 = mul_hi;
 440       Node *addend1 = phase-&gt;transform(new RShiftLNode(dividend, phase-&gt;intcon(N-1)));
 441 
 442       // If the divisor is negative, swap the order of the input addends;
 443       // this has the effect of negating the quotient.
 444       if (!d_pos) {
 445         Node *temp = addend0; addend0 = addend1; addend1 = temp;
 446       }
 447 
 448       // Adjust the final quotient by subtracting -1 (adding 1)
 449       // from the mul_hi.
 450       q = new SubLNode(addend0, addend1);
 451     }
 452   }
 453 
 454   return q;
 455 }
 456 
 457 //=============================================================================
 458 //------------------------------Identity---------------------------------------
 459 // If the divisor is 1, we are an identity on the dividend.
 460 Node* DivINode::Identity(PhaseGVN* phase) {
 461   return (phase-&gt;type( in(2) )-&gt;higher_equal(TypeInt::ONE)) ? in(1) : this;
 462 }
 463 
 464 //------------------------------Idealize---------------------------------------
 465 // Divides can be changed to multiplies and/or shifts
 466 Node *DivINode::Ideal(PhaseGVN *phase, bool can_reshape) {
 467   if (in(0) &amp;&amp; remove_dead_region(phase, can_reshape))  return this;
 468   // Don&#39;t bother trying to transform a dead node
 469   if( in(0) &amp;&amp; in(0)-&gt;is_top() )  return NULL;
 470 
 471   const Type *t = phase-&gt;type( in(2) );
 472   if( t == TypeInt::ONE )       // Identity?
 473     return NULL;                // Skip it
 474 
 475   const TypeInt *ti = t-&gt;isa_int();
 476   if( !ti ) return NULL;
 477 
 478   // Check for useless control input
 479   // Check for excluding div-zero case
 480   if (in(0) &amp;&amp; (ti-&gt;_hi &lt; 0 || ti-&gt;_lo &gt; 0)) {
 481     set_req(0, NULL);           // Yank control input
 482     return this;
 483   }
 484 
 485   if( !ti-&gt;is_con() ) return NULL;
 486   jint i = ti-&gt;get_con();       // Get divisor
 487 
 488   if (i == 0) return NULL;      // Dividing by zero constant does not idealize
 489 
 490   // Dividing by MININT does not optimize as a power-of-2 shift.
 491   if( i == min_jint ) return NULL;
 492 
 493   return transform_int_divide( phase, in(1), i );
 494 }
 495 
 496 //------------------------------Value------------------------------------------
 497 // A DivINode divides its inputs.  The third input is a Control input, used to
 498 // prevent hoisting the divide above an unsafe test.
 499 const Type* DivINode::Value(PhaseGVN* phase) const {
 500   // Either input is TOP ==&gt; the result is TOP
 501   const Type *t1 = phase-&gt;type( in(1) );
 502   const Type *t2 = phase-&gt;type( in(2) );
 503   if( t1 == Type::TOP ) return Type::TOP;
 504   if( t2 == Type::TOP ) return Type::TOP;
 505 
 506   // x/x == 1 since we always generate the dynamic divisor check for 0.
 507   if( phase-&gt;eqv( in(1), in(2) ) )
 508     return TypeInt::ONE;
 509 
 510   // Either input is BOTTOM ==&gt; the result is the local BOTTOM
 511   const Type *bot = bottom_type();
 512   if( (t1 == bot) || (t2 == bot) ||
 513       (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )
 514     return bot;
 515 
 516   // Divide the two numbers.  We approximate.
 517   // If divisor is a constant and not zero
 518   const TypeInt *i1 = t1-&gt;is_int();
 519   const TypeInt *i2 = t2-&gt;is_int();
 520   int widen = MAX2(i1-&gt;_widen, i2-&gt;_widen);
 521 
 522   if( i2-&gt;is_con() &amp;&amp; i2-&gt;get_con() != 0 ) {
 523     int32_t d = i2-&gt;get_con(); // Divisor
 524     jint lo, hi;
 525     if( d &gt;= 0 ) {
 526       lo = i1-&gt;_lo/d;
 527       hi = i1-&gt;_hi/d;
 528     } else {
 529       if( d == -1 &amp;&amp; i1-&gt;_lo == min_jint ) {
 530         // &#39;min_jint/-1&#39; throws arithmetic exception during compilation
 531         lo = min_jint;
 532         // do not support holes, &#39;hi&#39; must go to either min_jint or max_jint:
 533         // [min_jint, -10]/[-1,-1] ==&gt; [min_jint] UNION [10,max_jint]
 534         hi = i1-&gt;_hi == min_jint ? min_jint : max_jint;
 535       } else {
 536         lo = i1-&gt;_hi/d;
 537         hi = i1-&gt;_lo/d;
 538       }
 539     }
 540     return TypeInt::make(lo, hi, widen);
 541   }
 542 
 543   // If the dividend is a constant
 544   if( i1-&gt;is_con() ) {
 545     int32_t d = i1-&gt;get_con();
 546     if( d &lt; 0 ) {
 547       if( d == min_jint ) {
 548         //  (-min_jint) == min_jint == (min_jint / -1)
 549         return TypeInt::make(min_jint, max_jint/2 + 1, widen);
 550       } else {
 551         return TypeInt::make(d, -d, widen);
 552       }
 553     }
 554     return TypeInt::make(-d, d, widen);
 555   }
 556 
 557   // Otherwise we give up all hope
 558   return TypeInt::INT;
 559 }
 560 
 561 
 562 //=============================================================================
 563 //------------------------------Identity---------------------------------------
 564 // If the divisor is 1, we are an identity on the dividend.
 565 Node* DivLNode::Identity(PhaseGVN* phase) {
 566   return (phase-&gt;type( in(2) )-&gt;higher_equal(TypeLong::ONE)) ? in(1) : this;
 567 }
 568 
 569 //------------------------------Idealize---------------------------------------
 570 // Dividing by a power of 2 is a shift.
 571 Node *DivLNode::Ideal( PhaseGVN *phase, bool can_reshape) {
 572   if (in(0) &amp;&amp; remove_dead_region(phase, can_reshape))  return this;
 573   // Don&#39;t bother trying to transform a dead node
 574   if( in(0) &amp;&amp; in(0)-&gt;is_top() )  return NULL;
 575 
 576   const Type *t = phase-&gt;type( in(2) );
 577   if( t == TypeLong::ONE )      // Identity?
 578     return NULL;                // Skip it
 579 
 580   const TypeLong *tl = t-&gt;isa_long();
 581   if( !tl ) return NULL;
 582 
 583   // Check for useless control input
 584   // Check for excluding div-zero case
 585   if (in(0) &amp;&amp; (tl-&gt;_hi &lt; 0 || tl-&gt;_lo &gt; 0)) {
 586     set_req(0, NULL);           // Yank control input
 587     return this;
 588   }
 589 
 590   if( !tl-&gt;is_con() ) return NULL;
 591   jlong l = tl-&gt;get_con();      // Get divisor
 592 
 593   if (l == 0) return NULL;      // Dividing by zero constant does not idealize
 594 
 595   // Dividing by MINLONG does not optimize as a power-of-2 shift.
 596   if( l == min_jlong ) return NULL;
 597 
 598   return transform_long_divide( phase, in(1), l );
 599 }
 600 
 601 //------------------------------Value------------------------------------------
 602 // A DivLNode divides its inputs.  The third input is a Control input, used to
 603 // prevent hoisting the divide above an unsafe test.
 604 const Type* DivLNode::Value(PhaseGVN* phase) const {
 605   // Either input is TOP ==&gt; the result is TOP
 606   const Type *t1 = phase-&gt;type( in(1) );
 607   const Type *t2 = phase-&gt;type( in(2) );
 608   if( t1 == Type::TOP ) return Type::TOP;
 609   if( t2 == Type::TOP ) return Type::TOP;
 610 
 611   // x/x == 1 since we always generate the dynamic divisor check for 0.
 612   if( phase-&gt;eqv( in(1), in(2) ) )
 613     return TypeLong::ONE;
 614 
 615   // Either input is BOTTOM ==&gt; the result is the local BOTTOM
 616   const Type *bot = bottom_type();
 617   if( (t1 == bot) || (t2 == bot) ||
 618       (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )
 619     return bot;
 620 
 621   // Divide the two numbers.  We approximate.
 622   // If divisor is a constant and not zero
 623   const TypeLong *i1 = t1-&gt;is_long();
 624   const TypeLong *i2 = t2-&gt;is_long();
 625   int widen = MAX2(i1-&gt;_widen, i2-&gt;_widen);
 626 
 627   if( i2-&gt;is_con() &amp;&amp; i2-&gt;get_con() != 0 ) {
 628     jlong d = i2-&gt;get_con();    // Divisor
 629     jlong lo, hi;
 630     if( d &gt;= 0 ) {
 631       lo = i1-&gt;_lo/d;
 632       hi = i1-&gt;_hi/d;
 633     } else {
 634       if( d == CONST64(-1) &amp;&amp; i1-&gt;_lo == min_jlong ) {
 635         // &#39;min_jlong/-1&#39; throws arithmetic exception during compilation
 636         lo = min_jlong;
 637         // do not support holes, &#39;hi&#39; must go to either min_jlong or max_jlong:
 638         // [min_jlong, -10]/[-1,-1] ==&gt; [min_jlong] UNION [10,max_jlong]
 639         hi = i1-&gt;_hi == min_jlong ? min_jlong : max_jlong;
 640       } else {
 641         lo = i1-&gt;_hi/d;
 642         hi = i1-&gt;_lo/d;
 643       }
 644     }
 645     return TypeLong::make(lo, hi, widen);
 646   }
 647 
 648   // If the dividend is a constant
 649   if( i1-&gt;is_con() ) {
 650     jlong d = i1-&gt;get_con();
 651     if( d &lt; 0 ) {
 652       if( d == min_jlong ) {
 653         //  (-min_jlong) == min_jlong == (min_jlong / -1)
 654         return TypeLong::make(min_jlong, max_jlong/2 + 1, widen);
 655       } else {
 656         return TypeLong::make(d, -d, widen);
 657       }
 658     }
 659     return TypeLong::make(-d, d, widen);
 660   }
 661 
 662   // Otherwise we give up all hope
 663   return TypeLong::LONG;
 664 }
 665 
 666 
 667 //=============================================================================
 668 //------------------------------Value------------------------------------------
 669 // An DivFNode divides its inputs.  The third input is a Control input, used to
 670 // prevent hoisting the divide above an unsafe test.
 671 const Type* DivFNode::Value(PhaseGVN* phase) const {
 672   // Either input is TOP ==&gt; the result is TOP
 673   const Type *t1 = phase-&gt;type( in(1) );
 674   const Type *t2 = phase-&gt;type( in(2) );
 675   if( t1 == Type::TOP ) return Type::TOP;
 676   if( t2 == Type::TOP ) return Type::TOP;
 677 
 678   // Either input is BOTTOM ==&gt; the result is the local BOTTOM
 679   const Type *bot = bottom_type();
 680   if( (t1 == bot) || (t2 == bot) ||
 681       (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )
 682     return bot;
 683 
 684   // x/x == 1, we ignore 0/0.
 685   // Note: if t1 and t2 are zero then result is NaN (JVMS page 213)
 686   // Does not work for variables because of NaN&#39;s
 687   if( phase-&gt;eqv( in(1), in(2) ) &amp;&amp; t1-&gt;base() == Type::FloatCon)
 688     if (!g_isnan(t1-&gt;getf()) &amp;&amp; g_isfinite(t1-&gt;getf()) &amp;&amp; t1-&gt;getf() != 0.0) // could be negative ZERO or NaN
 689       return TypeF::ONE;
 690 
 691   if( t2 == TypeF::ONE )
 692     return t1;
 693 
 694   // If divisor is a constant and not zero, divide them numbers
 695   if( t1-&gt;base() == Type::FloatCon &amp;&amp;
 696       t2-&gt;base() == Type::FloatCon &amp;&amp;
 697       t2-&gt;getf() != 0.0 ) // could be negative zero
 698     return TypeF::make( t1-&gt;getf()/t2-&gt;getf() );
 699 
 700   // If the dividend is a constant zero
 701   // Note: if t1 and t2 are zero then result is NaN (JVMS page 213)
 702   // Test TypeF::ZERO is not sufficient as it could be negative zero
 703 
 704   if( t1 == TypeF::ZERO &amp;&amp; !g_isnan(t2-&gt;getf()) &amp;&amp; t2-&gt;getf() != 0.0 )
 705     return TypeF::ZERO;
 706 
 707   // Otherwise we give up all hope
 708   return Type::FLOAT;
 709 }
 710 
 711 //------------------------------isA_Copy---------------------------------------
 712 // Dividing by self is 1.
 713 // If the divisor is 1, we are an identity on the dividend.
 714 Node* DivFNode::Identity(PhaseGVN* phase) {
 715   return (phase-&gt;type( in(2) ) == TypeF::ONE) ? in(1) : this;
 716 }
 717 
 718 
 719 //------------------------------Idealize---------------------------------------
 720 Node *DivFNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 721   if (in(0) &amp;&amp; remove_dead_region(phase, can_reshape))  return this;
 722   // Don&#39;t bother trying to transform a dead node
 723   if( in(0) &amp;&amp; in(0)-&gt;is_top() )  return NULL;
 724 
 725   const Type *t2 = phase-&gt;type( in(2) );
 726   if( t2 == TypeF::ONE )         // Identity?
 727     return NULL;                // Skip it
 728 
 729   const TypeF *tf = t2-&gt;isa_float_constant();
 730   if( !tf ) return NULL;
 731   if( tf-&gt;base() != Type::FloatCon ) return NULL;
 732 
 733   // Check for out of range values
 734   if( tf-&gt;is_nan() || !tf-&gt;is_finite() ) return NULL;
 735 
 736   // Get the value
 737   float f = tf-&gt;getf();
 738   int exp;
 739 
 740   // Only for special case of dividing by a power of 2
 741   if( frexp((double)f, &amp;exp) != 0.5 ) return NULL;
 742 
 743   // Limit the range of acceptable exponents
 744   if( exp &lt; -126 || exp &gt; 126 ) return NULL;
 745 
 746   // Compute the reciprocal
 747   float reciprocal = ((float)1.0) / f;
 748 
 749   assert( frexp((double)reciprocal, &amp;exp) == 0.5, &quot;reciprocal should be power of 2&quot; );
 750 
 751   // return multiplication by the reciprocal
 752   return (new MulFNode(in(1), phase-&gt;makecon(TypeF::make(reciprocal))));
 753 }
 754 
 755 //=============================================================================
 756 //------------------------------Value------------------------------------------
 757 // An DivDNode divides its inputs.  The third input is a Control input, used to
 758 // prevent hoisting the divide above an unsafe test.
 759 const Type* DivDNode::Value(PhaseGVN* phase) const {
 760   // Either input is TOP ==&gt; the result is TOP
 761   const Type *t1 = phase-&gt;type( in(1) );
 762   const Type *t2 = phase-&gt;type( in(2) );
 763   if( t1 == Type::TOP ) return Type::TOP;
 764   if( t2 == Type::TOP ) return Type::TOP;
 765 
 766   // Either input is BOTTOM ==&gt; the result is the local BOTTOM
 767   const Type *bot = bottom_type();
 768   if( (t1 == bot) || (t2 == bot) ||
 769       (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )
 770     return bot;
 771 
 772   // x/x == 1, we ignore 0/0.
 773   // Note: if t1 and t2 are zero then result is NaN (JVMS page 213)
 774   // Does not work for variables because of NaN&#39;s
 775   if( phase-&gt;eqv( in(1), in(2) ) &amp;&amp; t1-&gt;base() == Type::DoubleCon)
 776     if (!g_isnan(t1-&gt;getd()) &amp;&amp; g_isfinite(t1-&gt;getd()) &amp;&amp; t1-&gt;getd() != 0.0) // could be negative ZERO or NaN
 777       return TypeD::ONE;
 778 
 779   if( t2 == TypeD::ONE )
 780     return t1;
 781 
 782 #if defined(IA32)
 783   if (!phase-&gt;C-&gt;method()-&gt;is_strict())
 784     // Can&#39;t trust native compilers to properly fold strict double
 785     // division with round-to-zero on this platform.
 786 #endif
 787     {
 788       // If divisor is a constant and not zero, divide them numbers
 789       if( t1-&gt;base() == Type::DoubleCon &amp;&amp;
 790           t2-&gt;base() == Type::DoubleCon &amp;&amp;
 791           t2-&gt;getd() != 0.0 ) // could be negative zero
 792         return TypeD::make( t1-&gt;getd()/t2-&gt;getd() );
 793     }
 794 
 795   // If the dividend is a constant zero
 796   // Note: if t1 and t2 are zero then result is NaN (JVMS page 213)
 797   // Test TypeF::ZERO is not sufficient as it could be negative zero
 798   if( t1 == TypeD::ZERO &amp;&amp; !g_isnan(t2-&gt;getd()) &amp;&amp; t2-&gt;getd() != 0.0 )
 799     return TypeD::ZERO;
 800 
 801   // Otherwise we give up all hope
 802   return Type::DOUBLE;
 803 }
 804 
 805 
 806 //------------------------------isA_Copy---------------------------------------
 807 // Dividing by self is 1.
 808 // If the divisor is 1, we are an identity on the dividend.
 809 Node* DivDNode::Identity(PhaseGVN* phase) {
 810   return (phase-&gt;type( in(2) ) == TypeD::ONE) ? in(1) : this;
 811 }
 812 
 813 //------------------------------Idealize---------------------------------------
 814 Node *DivDNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 815   if (in(0) &amp;&amp; remove_dead_region(phase, can_reshape))  return this;
 816   // Don&#39;t bother trying to transform a dead node
 817   if( in(0) &amp;&amp; in(0)-&gt;is_top() )  return NULL;
 818 
 819   const Type *t2 = phase-&gt;type( in(2) );
 820   if( t2 == TypeD::ONE )         // Identity?
 821     return NULL;                // Skip it
 822 
 823   const TypeD *td = t2-&gt;isa_double_constant();
 824   if( !td ) return NULL;
 825   if( td-&gt;base() != Type::DoubleCon ) return NULL;
 826 
 827   // Check for out of range values
 828   if( td-&gt;is_nan() || !td-&gt;is_finite() ) return NULL;
 829 
 830   // Get the value
 831   double d = td-&gt;getd();
 832   int exp;
 833 
 834   // Only for special case of dividing by a power of 2
 835   if( frexp(d, &amp;exp) != 0.5 ) return NULL;
 836 
 837   // Limit the range of acceptable exponents
 838   if( exp &lt; -1021 || exp &gt; 1022 ) return NULL;
 839 
 840   // Compute the reciprocal
 841   double reciprocal = 1.0 / d;
 842 
 843   assert( frexp(reciprocal, &amp;exp) == 0.5, &quot;reciprocal should be power of 2&quot; );
 844 
 845   // return multiplication by the reciprocal
 846   return (new MulDNode(in(1), phase-&gt;makecon(TypeD::make(reciprocal))));
 847 }
 848 
 849 //=============================================================================
 850 //------------------------------Idealize---------------------------------------
 851 Node *ModINode::Ideal(PhaseGVN *phase, bool can_reshape) {
 852   // Check for dead control input
 853   if( in(0) &amp;&amp; remove_dead_region(phase, can_reshape) )  return this;
 854   // Don&#39;t bother trying to transform a dead node
 855   if( in(0) &amp;&amp; in(0)-&gt;is_top() )  return NULL;
 856 
 857   // Get the modulus
 858   const Type *t = phase-&gt;type( in(2) );
 859   if( t == Type::TOP ) return NULL;
 860   const TypeInt *ti = t-&gt;is_int();
 861 
 862   // Check for useless control input
 863   // Check for excluding mod-zero case
 864   if (in(0) &amp;&amp; (ti-&gt;_hi &lt; 0 || ti-&gt;_lo &gt; 0)) {
 865     set_req(0, NULL);        // Yank control input
 866     return this;
 867   }
 868 
 869   // See if we are MOD&#39;ing by 2^k or 2^k-1.
 870   if( !ti-&gt;is_con() ) return NULL;
 871   jint con = ti-&gt;get_con();
 872 
 873   Node *hook = new Node(1);
 874 
 875   // First, special check for modulo 2^k-1
 876   if( con &gt;= 0 &amp;&amp; con &lt; max_jint &amp;&amp; is_power_of_2(con+1) ) {
 877     uint k = exact_log2(con+1);  // Extract k
 878 
 879     // Basic algorithm by David Detlefs.  See fastmod_int.java for gory details.
 880     static int unroll_factor[] = { 999, 999, 29, 14, 9, 7, 5, 4, 4, 3, 3, 2, 2, 2, 2, 2, 1 /*past here we assume 1 forever*/};
 881     int trip_count = 1;
 882     if( k &lt; ARRAY_SIZE(unroll_factor))  trip_count = unroll_factor[k];
 883 
 884     // If the unroll factor is not too large, and if conditional moves are
 885     // ok, then use this case
 886     if( trip_count &lt;= 5 &amp;&amp; ConditionalMoveLimit != 0 ) {
 887       Node *x = in(1);            // Value being mod&#39;d
 888       Node *divisor = in(2);      // Also is mask
 889 
 890       hook-&gt;init_req(0, x);       // Add a use to x to prevent him from dying
 891       // Generate code to reduce X rapidly to nearly 2^k-1.
 892       for( int i = 0; i &lt; trip_count; i++ ) {
 893         Node *xl = phase-&gt;transform( new AndINode(x,divisor) );
 894         Node *xh = phase-&gt;transform( new RShiftINode(x,phase-&gt;intcon(k)) ); // Must be signed
 895         x = phase-&gt;transform( new AddINode(xh,xl) );
 896         hook-&gt;set_req(0, x);
 897       }
 898 
 899       // Generate sign-fixup code.  Was original value positive?
 900       // int hack_res = (i &gt;= 0) ? divisor : 1;
 901       Node *cmp1 = phase-&gt;transform( new CmpINode( in(1), phase-&gt;intcon(0) ) );
 902       Node *bol1 = phase-&gt;transform( new BoolNode( cmp1, BoolTest::ge ) );
 903       Node *cmov1= phase-&gt;transform( new CMoveINode(bol1, phase-&gt;intcon(1), divisor, TypeInt::POS) );
 904       // if( x &gt;= hack_res ) x -= divisor;
 905       Node *sub  = phase-&gt;transform( new SubINode( x, divisor ) );
 906       Node *cmp2 = phase-&gt;transform( new CmpINode( x, cmov1 ) );
 907       Node *bol2 = phase-&gt;transform( new BoolNode( cmp2, BoolTest::ge ) );
 908       // Convention is to not transform the return value of an Ideal
 909       // since Ideal is expected to return a modified &#39;this&#39; or a new node.
 910       Node *cmov2= new CMoveINode(bol2, x, sub, TypeInt::INT);
 911       // cmov2 is now the mod
 912 
 913       // Now remove the bogus extra edges used to keep things alive
 914       if (can_reshape) {
 915         phase-&gt;is_IterGVN()-&gt;remove_dead_node(hook);
 916       } else {
 917         hook-&gt;set_req(0, NULL);   // Just yank bogus edge during Parse phase
 918       }
 919       return cmov2;
 920     }
 921   }
 922 
 923   // Fell thru, the unroll case is not appropriate. Transform the modulo
 924   // into a long multiply/int multiply/subtract case
 925 
 926   // Cannot handle mod 0, and min_jint isn&#39;t handled by the transform
 927   if( con == 0 || con == min_jint ) return NULL;
 928 
 929   // Get the absolute value of the constant; at this point, we can use this
 930   jint pos_con = (con &gt;= 0) ? con : -con;
 931 
 932   // integer Mod 1 is always 0
 933   if( pos_con == 1 ) return new ConINode(TypeInt::ZERO);
 934 
 935   int log2_con = -1;
 936 
 937   // If this is a power of two, they maybe we can mask it
 938   if( is_power_of_2(pos_con) ) {
 939     log2_con = log2_intptr((intptr_t)pos_con);
 940 
 941     const Type *dt = phase-&gt;type(in(1));
 942     const TypeInt *dti = dt-&gt;isa_int();
 943 
 944     // See if this can be masked, if the dividend is non-negative
 945     if( dti &amp;&amp; dti-&gt;_lo &gt;= 0 )
 946       return ( new AndINode( in(1), phase-&gt;intcon( pos_con-1 ) ) );
 947   }
 948 
 949   // Save in(1) so that it cannot be changed or deleted
 950   hook-&gt;init_req(0, in(1));
 951 
 952   // Divide using the transform from DivI to MulL
 953   Node *result = transform_int_divide( phase, in(1), pos_con );
 954   if (result != NULL) {
 955     Node *divide = phase-&gt;transform(result);
 956 
 957     // Re-multiply, using a shift if this is a power of two
 958     Node *mult = NULL;
 959 
 960     if( log2_con &gt;= 0 )
 961       mult = phase-&gt;transform( new LShiftINode( divide, phase-&gt;intcon( log2_con ) ) );
 962     else
 963       mult = phase-&gt;transform( new MulINode( divide, phase-&gt;intcon( pos_con ) ) );
 964 
 965     // Finally, subtract the multiplied divided value from the original
 966     result = new SubINode( in(1), mult );
 967   }
 968 
 969   // Now remove the bogus extra edges used to keep things alive
 970   if (can_reshape) {
 971     phase-&gt;is_IterGVN()-&gt;remove_dead_node(hook);
 972   } else {
 973     hook-&gt;set_req(0, NULL);       // Just yank bogus edge during Parse phase
 974   }
 975 
 976   // return the value
 977   return result;
 978 }
 979 
 980 //------------------------------Value------------------------------------------
 981 const Type* ModINode::Value(PhaseGVN* phase) const {
 982   // Either input is TOP ==&gt; the result is TOP
 983   const Type *t1 = phase-&gt;type( in(1) );
 984   const Type *t2 = phase-&gt;type( in(2) );
 985   if( t1 == Type::TOP ) return Type::TOP;
 986   if( t2 == Type::TOP ) return Type::TOP;
 987 
 988   // We always generate the dynamic check for 0.
 989   // 0 MOD X is 0
 990   if( t1 == TypeInt::ZERO ) return TypeInt::ZERO;
 991   // X MOD X is 0
 992   if( phase-&gt;eqv( in(1), in(2) ) ) return TypeInt::ZERO;
 993 
 994   // Either input is BOTTOM ==&gt; the result is the local BOTTOM
 995   const Type *bot = bottom_type();
 996   if( (t1 == bot) || (t2 == bot) ||
 997       (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )
 998     return bot;
 999 
1000   const TypeInt *i1 = t1-&gt;is_int();
1001   const TypeInt *i2 = t2-&gt;is_int();
1002   if( !i1-&gt;is_con() || !i2-&gt;is_con() ) {
1003     if( i1-&gt;_lo &gt;= 0 &amp;&amp; i2-&gt;_lo &gt;= 0 )
1004       return TypeInt::POS;
1005     // If both numbers are not constants, we know little.
1006     return TypeInt::INT;
1007   }
1008   // Mod by zero?  Throw exception at runtime!
1009   if( !i2-&gt;get_con() ) return TypeInt::POS;
1010 
1011   // We must be modulo&#39;ing 2 float constants.
1012   // Check for min_jint % &#39;-1&#39;, result is defined to be &#39;0&#39;.
1013   if( i1-&gt;get_con() == min_jint &amp;&amp; i2-&gt;get_con() == -1 )
1014     return TypeInt::ZERO;
1015 
1016   return TypeInt::make( i1-&gt;get_con() % i2-&gt;get_con() );
1017 }
1018 
1019 
1020 //=============================================================================
1021 //------------------------------Idealize---------------------------------------
1022 Node *ModLNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1023   // Check for dead control input
1024   if( in(0) &amp;&amp; remove_dead_region(phase, can_reshape) )  return this;
1025   // Don&#39;t bother trying to transform a dead node
1026   if( in(0) &amp;&amp; in(0)-&gt;is_top() )  return NULL;
1027 
1028   // Get the modulus
1029   const Type *t = phase-&gt;type( in(2) );
1030   if( t == Type::TOP ) return NULL;
1031   const TypeLong *tl = t-&gt;is_long();
1032 
1033   // Check for useless control input
1034   // Check for excluding mod-zero case
1035   if (in(0) &amp;&amp; (tl-&gt;_hi &lt; 0 || tl-&gt;_lo &gt; 0)) {
1036     set_req(0, NULL);        // Yank control input
1037     return this;
1038   }
1039 
1040   // See if we are MOD&#39;ing by 2^k or 2^k-1.
1041   if( !tl-&gt;is_con() ) return NULL;
1042   jlong con = tl-&gt;get_con();
1043 
1044   Node *hook = new Node(1);
1045 
1046   // Expand mod
<a name="4" id="anc4"></a><span class="line-modified">1047   if( con &gt;= 0 &amp;&amp; con &lt; max_jlong &amp;&amp; is_power_of_2_long(con+1) ) {</span>
1048     uint k = exact_log2_long(con+1);  // Extract k
1049 
1050     // Basic algorithm by David Detlefs.  See fastmod_long.java for gory details.
1051     // Used to help a popular random number generator which does a long-mod
1052     // of 2^31-1 and shows up in SpecJBB and SciMark.
1053     static int unroll_factor[] = { 999, 999, 61, 30, 20, 15, 12, 10, 8, 7, 6, 6, 5, 5, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1 /*past here we assume 1 forever*/};
1054     int trip_count = 1;
1055     if( k &lt; ARRAY_SIZE(unroll_factor)) trip_count = unroll_factor[k];
1056 
1057     // If the unroll factor is not too large, and if conditional moves are
1058     // ok, then use this case
1059     if( trip_count &lt;= 5 &amp;&amp; ConditionalMoveLimit != 0 ) {
1060       Node *x = in(1);            // Value being mod&#39;d
1061       Node *divisor = in(2);      // Also is mask
1062 
1063       hook-&gt;init_req(0, x);       // Add a use to x to prevent him from dying
1064       // Generate code to reduce X rapidly to nearly 2^k-1.
1065       for( int i = 0; i &lt; trip_count; i++ ) {
1066         Node *xl = phase-&gt;transform( new AndLNode(x,divisor) );
1067         Node *xh = phase-&gt;transform( new RShiftLNode(x,phase-&gt;intcon(k)) ); // Must be signed
1068         x = phase-&gt;transform( new AddLNode(xh,xl) );
1069         hook-&gt;set_req(0, x);    // Add a use to x to prevent him from dying
1070       }
1071 
1072       // Generate sign-fixup code.  Was original value positive?
1073       // long hack_res = (i &gt;= 0) ? divisor : CONST64(1);
1074       Node *cmp1 = phase-&gt;transform( new CmpLNode( in(1), phase-&gt;longcon(0) ) );
1075       Node *bol1 = phase-&gt;transform( new BoolNode( cmp1, BoolTest::ge ) );
1076       Node *cmov1= phase-&gt;transform( new CMoveLNode(bol1, phase-&gt;longcon(1), divisor, TypeLong::LONG) );
1077       // if( x &gt;= hack_res ) x -= divisor;
1078       Node *sub  = phase-&gt;transform( new SubLNode( x, divisor ) );
1079       Node *cmp2 = phase-&gt;transform( new CmpLNode( x, cmov1 ) );
1080       Node *bol2 = phase-&gt;transform( new BoolNode( cmp2, BoolTest::ge ) );
1081       // Convention is to not transform the return value of an Ideal
1082       // since Ideal is expected to return a modified &#39;this&#39; or a new node.
1083       Node *cmov2= new CMoveLNode(bol2, x, sub, TypeLong::LONG);
1084       // cmov2 is now the mod
1085 
1086       // Now remove the bogus extra edges used to keep things alive
1087       if (can_reshape) {
1088         phase-&gt;is_IterGVN()-&gt;remove_dead_node(hook);
1089       } else {
1090         hook-&gt;set_req(0, NULL);   // Just yank bogus edge during Parse phase
1091       }
1092       return cmov2;
1093     }
1094   }
1095 
1096   // Fell thru, the unroll case is not appropriate. Transform the modulo
1097   // into a long multiply/int multiply/subtract case
1098 
1099   // Cannot handle mod 0, and min_jlong isn&#39;t handled by the transform
1100   if( con == 0 || con == min_jlong ) return NULL;
1101 
1102   // Get the absolute value of the constant; at this point, we can use this
1103   jlong pos_con = (con &gt;= 0) ? con : -con;
1104 
1105   // integer Mod 1 is always 0
1106   if( pos_con == 1 ) return new ConLNode(TypeLong::ZERO);
1107 
1108   int log2_con = -1;
1109 
1110   // If this is a power of two, then maybe we can mask it
<a name="5" id="anc5"></a><span class="line-modified">1111   if( is_power_of_2_long(pos_con) ) {</span>
1112     log2_con = exact_log2_long(pos_con);
1113 
1114     const Type *dt = phase-&gt;type(in(1));
1115     const TypeLong *dtl = dt-&gt;isa_long();
1116 
1117     // See if this can be masked, if the dividend is non-negative
1118     if( dtl &amp;&amp; dtl-&gt;_lo &gt;= 0 )
1119       return ( new AndLNode( in(1), phase-&gt;longcon( pos_con-1 ) ) );
1120   }
1121 
1122   // Save in(1) so that it cannot be changed or deleted
1123   hook-&gt;init_req(0, in(1));
1124 
1125   // Divide using the transform from DivL to MulL
1126   Node *result = transform_long_divide( phase, in(1), pos_con );
1127   if (result != NULL) {
1128     Node *divide = phase-&gt;transform(result);
1129 
1130     // Re-multiply, using a shift if this is a power of two
1131     Node *mult = NULL;
1132 
1133     if( log2_con &gt;= 0 )
1134       mult = phase-&gt;transform( new LShiftLNode( divide, phase-&gt;intcon( log2_con ) ) );
1135     else
1136       mult = phase-&gt;transform( new MulLNode( divide, phase-&gt;longcon( pos_con ) ) );
1137 
1138     // Finally, subtract the multiplied divided value from the original
1139     result = new SubLNode( in(1), mult );
1140   }
1141 
1142   // Now remove the bogus extra edges used to keep things alive
1143   if (can_reshape) {
1144     phase-&gt;is_IterGVN()-&gt;remove_dead_node(hook);
1145   } else {
1146     hook-&gt;set_req(0, NULL);       // Just yank bogus edge during Parse phase
1147   }
1148 
1149   // return the value
1150   return result;
1151 }
1152 
1153 //------------------------------Value------------------------------------------
1154 const Type* ModLNode::Value(PhaseGVN* phase) const {
1155   // Either input is TOP ==&gt; the result is TOP
1156   const Type *t1 = phase-&gt;type( in(1) );
1157   const Type *t2 = phase-&gt;type( in(2) );
1158   if( t1 == Type::TOP ) return Type::TOP;
1159   if( t2 == Type::TOP ) return Type::TOP;
1160 
1161   // We always generate the dynamic check for 0.
1162   // 0 MOD X is 0
1163   if( t1 == TypeLong::ZERO ) return TypeLong::ZERO;
1164   // X MOD X is 0
1165   if( phase-&gt;eqv( in(1), in(2) ) ) return TypeLong::ZERO;
1166 
1167   // Either input is BOTTOM ==&gt; the result is the local BOTTOM
1168   const Type *bot = bottom_type();
1169   if( (t1 == bot) || (t2 == bot) ||
1170       (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )
1171     return bot;
1172 
1173   const TypeLong *i1 = t1-&gt;is_long();
1174   const TypeLong *i2 = t2-&gt;is_long();
1175   if( !i1-&gt;is_con() || !i2-&gt;is_con() ) {
1176     if( i1-&gt;_lo &gt;= CONST64(0) &amp;&amp; i2-&gt;_lo &gt;= CONST64(0) )
1177       return TypeLong::POS;
1178     // If both numbers are not constants, we know little.
1179     return TypeLong::LONG;
1180   }
1181   // Mod by zero?  Throw exception at runtime!
1182   if( !i2-&gt;get_con() ) return TypeLong::POS;
1183 
1184   // We must be modulo&#39;ing 2 float constants.
1185   // Check for min_jint % &#39;-1&#39;, result is defined to be &#39;0&#39;.
1186   if( i1-&gt;get_con() == min_jlong &amp;&amp; i2-&gt;get_con() == -1 )
1187     return TypeLong::ZERO;
1188 
1189   return TypeLong::make( i1-&gt;get_con() % i2-&gt;get_con() );
1190 }
1191 
1192 
1193 //=============================================================================
1194 //------------------------------Value------------------------------------------
1195 const Type* ModFNode::Value(PhaseGVN* phase) const {
1196   // Either input is TOP ==&gt; the result is TOP
1197   const Type *t1 = phase-&gt;type( in(1) );
1198   const Type *t2 = phase-&gt;type( in(2) );
1199   if( t1 == Type::TOP ) return Type::TOP;
1200   if( t2 == Type::TOP ) return Type::TOP;
1201 
1202   // Either input is BOTTOM ==&gt; the result is the local BOTTOM
1203   const Type *bot = bottom_type();
1204   if( (t1 == bot) || (t2 == bot) ||
1205       (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )
1206     return bot;
1207 
1208   // If either number is not a constant, we know nothing.
1209   if ((t1-&gt;base() != Type::FloatCon) || (t2-&gt;base() != Type::FloatCon)) {
1210     return Type::FLOAT;         // note: x%x can be either NaN or 0
1211   }
1212 
1213   float f1 = t1-&gt;getf();
1214   float f2 = t2-&gt;getf();
1215   jint  x1 = jint_cast(f1);     // note:  *(int*)&amp;f1, not just (int)f1
1216   jint  x2 = jint_cast(f2);
1217 
1218   // If either is a NaN, return an input NaN
1219   if (g_isnan(f1))    return t1;
1220   if (g_isnan(f2))    return t2;
1221 
1222   // If an operand is infinity or the divisor is +/- zero, punt.
1223   if (!g_isfinite(f1) || !g_isfinite(f2) || x2 == 0 || x2 == min_jint)
1224     return Type::FLOAT;
1225 
1226   // We must be modulo&#39;ing 2 float constants.
1227   // Make sure that the sign of the fmod is equal to the sign of the dividend
1228   jint xr = jint_cast(fmod(f1, f2));
1229   if ((x1 ^ xr) &lt; 0) {
1230     xr ^= min_jint;
1231   }
1232 
1233   return TypeF::make(jfloat_cast(xr));
1234 }
1235 
1236 
1237 //=============================================================================
1238 //------------------------------Value------------------------------------------
1239 const Type* ModDNode::Value(PhaseGVN* phase) const {
1240   // Either input is TOP ==&gt; the result is TOP
1241   const Type *t1 = phase-&gt;type( in(1) );
1242   const Type *t2 = phase-&gt;type( in(2) );
1243   if( t1 == Type::TOP ) return Type::TOP;
1244   if( t2 == Type::TOP ) return Type::TOP;
1245 
1246   // Either input is BOTTOM ==&gt; the result is the local BOTTOM
1247   const Type *bot = bottom_type();
1248   if( (t1 == bot) || (t2 == bot) ||
1249       (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )
1250     return bot;
1251 
1252   // If either number is not a constant, we know nothing.
1253   if ((t1-&gt;base() != Type::DoubleCon) || (t2-&gt;base() != Type::DoubleCon)) {
1254     return Type::DOUBLE;        // note: x%x can be either NaN or 0
1255   }
1256 
1257   double f1 = t1-&gt;getd();
1258   double f2 = t2-&gt;getd();
1259   jlong  x1 = jlong_cast(f1);   // note:  *(long*)&amp;f1, not just (long)f1
1260   jlong  x2 = jlong_cast(f2);
1261 
1262   // If either is a NaN, return an input NaN
1263   if (g_isnan(f1))    return t1;
1264   if (g_isnan(f2))    return t2;
1265 
1266   // If an operand is infinity or the divisor is +/- zero, punt.
1267   if (!g_isfinite(f1) || !g_isfinite(f2) || x2 == 0 || x2 == min_jlong)
1268     return Type::DOUBLE;
1269 
1270   // We must be modulo&#39;ing 2 double constants.
1271   // Make sure that the sign of the fmod is equal to the sign of the dividend
1272   jlong xr = jlong_cast(fmod(f1, f2));
1273   if ((x1 ^ xr) &lt; 0) {
1274     xr ^= min_jlong;
1275   }
1276 
1277   return TypeD::make(jdouble_cast(xr));
1278 }
1279 
1280 //=============================================================================
1281 
1282 DivModNode::DivModNode( Node *c, Node *dividend, Node *divisor ) : MultiNode(3) {
1283   init_req(0, c);
1284   init_req(1, dividend);
1285   init_req(2, divisor);
1286 }
1287 
1288 //------------------------------make------------------------------------------
1289 DivModINode* DivModINode::make(Node* div_or_mod) {
1290   Node* n = div_or_mod;
1291   assert(n-&gt;Opcode() == Op_DivI || n-&gt;Opcode() == Op_ModI,
1292          &quot;only div or mod input pattern accepted&quot;);
1293 
1294   DivModINode* divmod = new DivModINode(n-&gt;in(0), n-&gt;in(1), n-&gt;in(2));
1295   Node*        dproj  = new ProjNode(divmod, DivModNode::div_proj_num);
1296   Node*        mproj  = new ProjNode(divmod, DivModNode::mod_proj_num);
1297   return divmod;
1298 }
1299 
1300 //------------------------------make------------------------------------------
1301 DivModLNode* DivModLNode::make(Node* div_or_mod) {
1302   Node* n = div_or_mod;
1303   assert(n-&gt;Opcode() == Op_DivL || n-&gt;Opcode() == Op_ModL,
1304          &quot;only div or mod input pattern accepted&quot;);
1305 
1306   DivModLNode* divmod = new DivModLNode(n-&gt;in(0), n-&gt;in(1), n-&gt;in(2));
1307   Node*        dproj  = new ProjNode(divmod, DivModNode::div_proj_num);
1308   Node*        mproj  = new ProjNode(divmod, DivModNode::mod_proj_num);
1309   return divmod;
1310 }
1311 
1312 //------------------------------match------------------------------------------
1313 // return result(s) along with their RegMask info
1314 Node *DivModINode::match( const ProjNode *proj, const Matcher *match ) {
1315   uint ideal_reg = proj-&gt;ideal_reg();
1316   RegMask rm;
1317   if (proj-&gt;_con == div_proj_num) {
1318     rm = match-&gt;divI_proj_mask();
1319   } else {
1320     assert(proj-&gt;_con == mod_proj_num, &quot;must be div or mod projection&quot;);
1321     rm = match-&gt;modI_proj_mask();
1322   }
1323   return new MachProjNode(this, proj-&gt;_con, rm, ideal_reg);
1324 }
1325 
1326 
1327 //------------------------------match------------------------------------------
1328 // return result(s) along with their RegMask info
1329 Node *DivModLNode::match( const ProjNode *proj, const Matcher *match ) {
1330   uint ideal_reg = proj-&gt;ideal_reg();
1331   RegMask rm;
1332   if (proj-&gt;_con == div_proj_num) {
1333     rm = match-&gt;divL_proj_mask();
1334   } else {
1335     assert(proj-&gt;_con == mod_proj_num, &quot;must be div or mod projection&quot;);
1336     rm = match-&gt;modL_proj_mask();
1337   }
1338   return new MachProjNode(this, proj-&gt;_con, rm, ideal_reg);
1339 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/superword.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="superword.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="type.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/superword.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
464   int est_savings(Node* s1, Node* s2);
465   int adjacent_profit(Node* s1, Node* s2);
466   int pack_cost(int ct);
467   int unpack_cost(int ct);
468   // Combine packs A and B with A.last == B.first into A.first..,A.last,B.second,..B.last
469   void combine_packs();
470   // Construct the map from nodes to packs.
471   void construct_my_pack_map();
472   // Remove packs that are not implemented or not profitable.
473   void filter_packs();
474   // Merge CMoveD into new vector-nodes
475   void merge_packs_to_cmovd();
476   // Adjust the memory graph for the packed operations
477   void schedule();
478   // Remove &quot;current&quot; from its current position in the memory graph and insert
479   // it after the appropriate insert points (lip or uip);
480   void remove_and_insert(MemNode *current, MemNode *prev, MemNode *lip, Node *uip, Unique_Node_List &amp;schd_before);
481   // Within a store pack, schedule stores together by moving out the sandwiched memory ops according
482   // to dependence info; and within a load pack, move loads down to the last executed load.
483   void co_locate_pack(Node_List* p);




484   // Convert packs into vector node operations
485   void output();
486   // Create a vector operand for the nodes in pack p for operand: in(opd_idx)
487   Node* vector_opd(Node_List* p, int opd_idx);
488   // Can code be generated for pack p?
489   bool implemented(Node_List* p);
490   // For pack p, are all operands and all uses (with in the block) vector?
491   bool profitable(Node_List* p);
492   // If a use of pack p is not a vector use, then replace the use with an extract operation.
493   void insert_extracts(Node_List* p);
494   // Is use-&gt;in(u_idx) a vector use?
495   bool is_vector_use(Node* use, int u_idx);
496   // Construct reverse postorder list of block members
497   bool construct_bb();
498   // Initialize per node info
499   void initialize_bb();
500   // Insert n into block after pos
501   void bb_insert_after(Node* n, int pos);
502   // Compute max depth for expressions from beginning of block
503   void compute_max_depth();
</pre>
</td>
<td>
<hr />
<pre>
464   int est_savings(Node* s1, Node* s2);
465   int adjacent_profit(Node* s1, Node* s2);
466   int pack_cost(int ct);
467   int unpack_cost(int ct);
468   // Combine packs A and B with A.last == B.first into A.first..,A.last,B.second,..B.last
469   void combine_packs();
470   // Construct the map from nodes to packs.
471   void construct_my_pack_map();
472   // Remove packs that are not implemented or not profitable.
473   void filter_packs();
474   // Merge CMoveD into new vector-nodes
475   void merge_packs_to_cmovd();
476   // Adjust the memory graph for the packed operations
477   void schedule();
478   // Remove &quot;current&quot; from its current position in the memory graph and insert
479   // it after the appropriate insert points (lip or uip);
480   void remove_and_insert(MemNode *current, MemNode *prev, MemNode *lip, Node *uip, Unique_Node_List &amp;schd_before);
481   // Within a store pack, schedule stores together by moving out the sandwiched memory ops according
482   // to dependence info; and within a load pack, move loads down to the last executed load.
483   void co_locate_pack(Node_List* p);
<span class="line-added">484   Node* pick_mem_state(Node_List* pk);</span>
<span class="line-added">485   Node* find_first_mem_state(Node_List* pk);</span>
<span class="line-added">486   Node* find_last_mem_state(Node_List* pk, Node* first_mem);</span>
<span class="line-added">487 </span>
488   // Convert packs into vector node operations
489   void output();
490   // Create a vector operand for the nodes in pack p for operand: in(opd_idx)
491   Node* vector_opd(Node_List* p, int opd_idx);
492   // Can code be generated for pack p?
493   bool implemented(Node_List* p);
494   // For pack p, are all operands and all uses (with in the block) vector?
495   bool profitable(Node_List* p);
496   // If a use of pack p is not a vector use, then replace the use with an extract operation.
497   void insert_extracts(Node_List* p);
498   // Is use-&gt;in(u_idx) a vector use?
499   bool is_vector_use(Node* use, int u_idx);
500   // Construct reverse postorder list of block members
501   bool construct_bb();
502   // Initialize per node info
503   void initialize_bb();
504   // Insert n into block after pos
505   void bb_insert_after(Node* n, int pos);
506   // Compute max depth for expressions from beginning of block
507   void compute_max_depth();
</pre>
</td>
</tr>
</table>
<center><a href="superword.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="type.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
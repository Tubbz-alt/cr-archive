<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/gc/parallel/psYoungGen.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/parallel/mutableNUMASpace.hpp&quot;
 27 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
 28 #include &quot;gc/parallel/psScavenge.hpp&quot;
 29 #include &quot;gc/parallel/psYoungGen.hpp&quot;
 30 #include &quot;gc/shared/gcUtil.hpp&quot;
 31 #include &quot;gc/shared/genArguments.hpp&quot;
 32 #include &quot;gc/shared/spaceDecorator.inline.hpp&quot;
 33 #include &quot;logging/log.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;runtime/java.hpp&quot;
 36 #include &quot;utilities/align.hpp&quot;
 37 
 38 PSYoungGen::PSYoungGen(size_t initial_size, size_t min_size, size_t max_size) :
 39   _reserved(),
 40   _virtual_space(NULL),
 41   _eden_space(NULL),
 42   _from_space(NULL),
 43   _to_space(NULL),
 44   _init_gen_size(initial_size),
 45   _min_gen_size(min_size),
 46   _max_gen_size(max_size),
 47   _gen_counters(NULL),
 48   _eden_counters(NULL),
 49   _from_counters(NULL),
 50   _to_counters(NULL)
 51 {}
 52 
 53 void PSYoungGen::initialize_virtual_space(ReservedSpace rs, size_t alignment) {
 54   assert(_init_gen_size != 0, &quot;Should have a finite size&quot;);
 55   _virtual_space = new PSVirtualSpace(rs, alignment);
 56   if (!virtual_space()-&gt;expand_by(_init_gen_size)) {
 57     vm_exit_during_initialization(&quot;Could not reserve enough space for &quot;
 58                                   &quot;object heap&quot;);
 59   }
 60 }
 61 
 62 void PSYoungGen::initialize(ReservedSpace rs, size_t alignment) {
 63   initialize_virtual_space(rs, alignment);
 64   initialize_work();
 65 }
 66 
 67 void PSYoungGen::initialize_work() {
 68 
 69   _reserved = MemRegion((HeapWord*)virtual_space()-&gt;low_boundary(),
 70                         (HeapWord*)virtual_space()-&gt;high_boundary());
 71 
 72   MemRegion cmr((HeapWord*)virtual_space()-&gt;low(),
 73                 (HeapWord*)virtual_space()-&gt;high());
 74   ParallelScavengeHeap::heap()-&gt;card_table()-&gt;resize_covered_region(cmr);
 75 
 76   if (ZapUnusedHeapArea) {
 77     // Mangle newly committed space immediately because it
 78     // can be done here more simply that after the new
 79     // spaces have been computed.
 80     SpaceMangler::mangle_region(cmr);
 81   }
 82 
 83   if (UseNUMA) {
 84     _eden_space = new MutableNUMASpace(virtual_space()-&gt;alignment());
 85   } else {
 86     _eden_space = new MutableSpace(virtual_space()-&gt;alignment());
 87   }
 88   _from_space = new MutableSpace(virtual_space()-&gt;alignment());
 89   _to_space   = new MutableSpace(virtual_space()-&gt;alignment());
 90 
 91   if (_eden_space == NULL || _from_space == NULL || _to_space == NULL) {
 92     vm_exit_during_initialization(&quot;Could not allocate a young gen space&quot;);
 93   }
 94 
 95   // Generation Counters - generation 0, 3 subspaces
 96   _gen_counters = new PSGenerationCounters(&quot;new&quot;, 0, 3, _min_gen_size,
 97                                            _max_gen_size, _virtual_space);
 98 
 99   // Compute maximum space sizes for performance counters
100   size_t alignment = SpaceAlignment;
101   size_t size = virtual_space()-&gt;reserved_size();
102 
103   size_t max_survivor_size;
104   size_t max_eden_size;
105 
106   if (UseAdaptiveSizePolicy) {
107     max_survivor_size = size / MinSurvivorRatio;
108 
109     // round the survivor space size down to the nearest alignment
110     // and make sure its size is greater than 0.
111     max_survivor_size = align_down(max_survivor_size, alignment);
112     max_survivor_size = MAX2(max_survivor_size, alignment);
113 
114     // set the maximum size of eden to be the size of the young gen
115     // less two times the minimum survivor size. The minimum survivor
116     // size for UseAdaptiveSizePolicy is one alignment.
117     max_eden_size = size - 2 * alignment;
118   } else {
119     max_survivor_size = size / InitialSurvivorRatio;
120 
121     // round the survivor space size down to the nearest alignment
122     // and make sure its size is greater than 0.
123     max_survivor_size = align_down(max_survivor_size, alignment);
124     max_survivor_size = MAX2(max_survivor_size, alignment);
125 
126     // set the maximum size of eden to be the size of the young gen
127     // less two times the survivor size when the generation is 100%
128     // committed. The minimum survivor size for -UseAdaptiveSizePolicy
129     // is dependent on the committed portion (current capacity) of the
130     // generation - the less space committed, the smaller the survivor
131     // space, possibly as small as an alignment. However, we are interested
132     // in the case where the young generation is 100% committed, as this
133     // is the point where eden reaches its maximum size. At this point,
134     // the size of a survivor space is max_survivor_size.
135     max_eden_size = size - 2 * max_survivor_size;
136   }
137 
138   _eden_counters = new SpaceCounters(&quot;eden&quot;, 0, max_eden_size, _eden_space,
139                                      _gen_counters);
140   _from_counters = new SpaceCounters(&quot;s0&quot;, 1, max_survivor_size, _from_space,
141                                      _gen_counters);
142   _to_counters = new SpaceCounters(&quot;s1&quot;, 2, max_survivor_size, _to_space,
143                                    _gen_counters);
144 
145   compute_initial_space_boundaries();
146 }
147 
148 void PSYoungGen::compute_initial_space_boundaries() {
149   // Compute sizes
150   size_t size = virtual_space()-&gt;committed_size();
151   assert(size &gt;= 3 * SpaceAlignment, &quot;Young space is not large enough for eden + 2 survivors&quot;);
152 
153   size_t survivor_size = size / InitialSurvivorRatio;
154   survivor_size = align_down(survivor_size, SpaceAlignment);
155   // ... but never less than an alignment
156   survivor_size = MAX2(survivor_size, SpaceAlignment);
157 
158   // Young generation is eden + 2 survivor spaces
159   size_t eden_size = size - (2 * survivor_size);
160 
161   // Now go ahead and set &#39;em.
162   set_space_boundaries(eden_size, survivor_size);
163   space_invariants();
164 
165   if (UsePerfData) {
166     _eden_counters-&gt;update_capacity();
167     _from_counters-&gt;update_capacity();
168     _to_counters-&gt;update_capacity();
169   }
170 }
171 
172 void PSYoungGen::set_space_boundaries(size_t eden_size, size_t survivor_size) {
173   assert(eden_size &lt; virtual_space()-&gt;committed_size(), &quot;just checking&quot;);
174   assert(eden_size &gt; 0  &amp;&amp; survivor_size &gt; 0, &quot;just checking&quot;);
175 
176   // Initial layout is Eden, to, from. After swapping survivor spaces,
177   // that leaves us with Eden, from, to, which is step one in our two
178   // step resize-with-live-data procedure.
179   char *eden_start = virtual_space()-&gt;low();
180   char *to_start   = eden_start + eden_size;
181   char *from_start = to_start   + survivor_size;
182   char *from_end   = from_start + survivor_size;
183 
184   assert(from_end == virtual_space()-&gt;high(), &quot;just checking&quot;);
185   assert(is_object_aligned(eden_start), &quot;checking alignment&quot;);
186   assert(is_object_aligned(to_start),   &quot;checking alignment&quot;);
187   assert(is_object_aligned(from_start), &quot;checking alignment&quot;);
188 
189   MemRegion eden_mr((HeapWord*)eden_start, (HeapWord*)to_start);
190   MemRegion to_mr  ((HeapWord*)to_start, (HeapWord*)from_start);
191   MemRegion from_mr((HeapWord*)from_start, (HeapWord*)from_end);
192 
193   eden_space()-&gt;initialize(eden_mr, true, ZapUnusedHeapArea);
194     to_space()-&gt;initialize(to_mr  , true, ZapUnusedHeapArea);
195   from_space()-&gt;initialize(from_mr, true, ZapUnusedHeapArea);
196 }
197 
198 #ifndef PRODUCT
199 void PSYoungGen::space_invariants() {
200   // Currently, our eden size cannot shrink to zero
201   guarantee(eden_space()-&gt;capacity_in_bytes() &gt;= SpaceAlignment, &quot;eden too small&quot;);
202   guarantee(from_space()-&gt;capacity_in_bytes() &gt;= SpaceAlignment, &quot;from too small&quot;);
203   guarantee(to_space()-&gt;capacity_in_bytes() &gt;= SpaceAlignment, &quot;to too small&quot;);
204 
205   // Relationship of spaces to each other
206   char* eden_start = (char*)eden_space()-&gt;bottom();
207   char* eden_end   = (char*)eden_space()-&gt;end();
208   char* from_start = (char*)from_space()-&gt;bottom();
209   char* from_end   = (char*)from_space()-&gt;end();
210   char* to_start   = (char*)to_space()-&gt;bottom();
211   char* to_end     = (char*)to_space()-&gt;end();
212 
213   guarantee(eden_start &gt;= virtual_space()-&gt;low(), &quot;eden bottom&quot;);
214   guarantee(eden_start &lt; eden_end, &quot;eden space consistency&quot;);
215   guarantee(from_start &lt; from_end, &quot;from space consistency&quot;);
216   guarantee(to_start &lt; to_end, &quot;to space consistency&quot;);
217 
218   // Check whether from space is below to space
219   if (from_start &lt; to_start) {
220     // Eden, from, to
221     guarantee(eden_end &lt;= from_start, &quot;eden/from boundary&quot;);
222     guarantee(from_end &lt;= to_start,   &quot;from/to boundary&quot;);
223     guarantee(to_end &lt;= virtual_space()-&gt;high(), &quot;to end&quot;);
224   } else {
225     // Eden, to, from
226     guarantee(eden_end &lt;= to_start, &quot;eden/to boundary&quot;);
227     guarantee(to_end &lt;= from_start, &quot;to/from boundary&quot;);
228     guarantee(from_end &lt;= virtual_space()-&gt;high(), &quot;from end&quot;);
229   }
230 
231   // More checks that the virtual space is consistent with the spaces
232   assert(virtual_space()-&gt;committed_size() &gt;=
233     (eden_space()-&gt;capacity_in_bytes() +
234      to_space()-&gt;capacity_in_bytes() +
235      from_space()-&gt;capacity_in_bytes()), &quot;Committed size is inconsistent&quot;);
236   assert(virtual_space()-&gt;committed_size() &lt;= virtual_space()-&gt;reserved_size(),
237     &quot;Space invariant&quot;);
238   char* eden_top = (char*)eden_space()-&gt;top();
239   char* from_top = (char*)from_space()-&gt;top();
240   char* to_top = (char*)to_space()-&gt;top();
241   assert(eden_top &lt;= virtual_space()-&gt;high(), &quot;eden top&quot;);
242   assert(from_top &lt;= virtual_space()-&gt;high(), &quot;from top&quot;);
243   assert(to_top &lt;= virtual_space()-&gt;high(), &quot;to top&quot;);
244 
245   virtual_space()-&gt;verify();
246 }
247 #endif
248 
249 void PSYoungGen::resize(size_t eden_size, size_t survivor_size) {
250   // Resize the generation if needed. If the generation resize
251   // reports false, do not attempt to resize the spaces.
252   if (resize_generation(eden_size, survivor_size)) {
253     // Then we lay out the spaces inside the generation
254     resize_spaces(eden_size, survivor_size);
255 
256     space_invariants();
257 
258     log_trace(gc, ergo)(&quot;Young generation size: &quot;
259                         &quot;desired eden: &quot; SIZE_FORMAT &quot; survivor: &quot; SIZE_FORMAT
260                         &quot; used: &quot; SIZE_FORMAT &quot; capacity: &quot; SIZE_FORMAT
261                         &quot; gen limits: &quot; SIZE_FORMAT &quot; / &quot; SIZE_FORMAT,
262                         eden_size, survivor_size, used_in_bytes(), capacity_in_bytes(),
263                         _max_gen_size, min_gen_size());
264   }
265 }
266 
267 
268 bool PSYoungGen::resize_generation(size_t eden_size, size_t survivor_size) {
269   const size_t alignment = virtual_space()-&gt;alignment();
270   size_t orig_size = virtual_space()-&gt;committed_size();
271   bool size_changed = false;
272 
273   // There used to be this guarantee there.
274   // guarantee ((eden_size + 2*survivor_size)  &lt;= _max_gen_size, &quot;incorrect input arguments&quot;);
275   // Code below forces this requirement.  In addition the desired eden
276   // size and desired survivor sizes are desired goals and may
277   // exceed the total generation size.
278 
279   assert(min_gen_size() &lt;= orig_size &amp;&amp; orig_size &lt;= max_size(), &quot;just checking&quot;);
280 
281   // Adjust new generation size
282   const size_t eden_plus_survivors =
283           align_up(eden_size + 2 * survivor_size, alignment);
284   size_t desired_size = clamp(eden_plus_survivors, min_gen_size(), max_size());
285   assert(desired_size &lt;= max_size(), &quot;just checking&quot;);
286 
287   if (desired_size &gt; orig_size) {
288     // Grow the generation
289     size_t change = desired_size - orig_size;
290     assert(change % alignment == 0, &quot;just checking&quot;);
291     HeapWord* prev_high = (HeapWord*) virtual_space()-&gt;high();
292     if (!virtual_space()-&gt;expand_by(change)) {
293       return false; // Error if we fail to resize!
294     }
295     if (ZapUnusedHeapArea) {
296       // Mangle newly committed space immediately because it
297       // can be done here more simply that after the new
298       // spaces have been computed.
299       HeapWord* new_high = (HeapWord*) virtual_space()-&gt;high();
300       MemRegion mangle_region(prev_high, new_high);
301       SpaceMangler::mangle_region(mangle_region);
302     }
303     size_changed = true;
304   } else if (desired_size &lt; orig_size) {
305     size_t desired_change = orig_size - desired_size;
306     assert(desired_change % alignment == 0, &quot;just checking&quot;);
307 
308     desired_change = limit_gen_shrink(desired_change);
309 
310     if (desired_change &gt; 0) {
311       virtual_space()-&gt;shrink_by(desired_change);
312       reset_survivors_after_shrink();
313 
314       size_changed = true;
315     }
316   } else {
317     if (orig_size == gen_size_limit()) {
318       log_trace(gc)(&quot;PSYoung generation size at maximum: &quot; SIZE_FORMAT &quot;K&quot;, orig_size/K);
319     } else if (orig_size == min_gen_size()) {
320       log_trace(gc)(&quot;PSYoung generation size at minium: &quot; SIZE_FORMAT &quot;K&quot;, orig_size/K);
321     }
322   }
323 
324   if (size_changed) {
325     post_resize();
326     log_trace(gc)(&quot;PSYoung generation size changed: &quot; SIZE_FORMAT &quot;K-&gt;&quot; SIZE_FORMAT &quot;K&quot;,
327                   orig_size/K, virtual_space()-&gt;committed_size()/K);
328   }
329 
330   guarantee(eden_plus_survivors &lt;= virtual_space()-&gt;committed_size() ||
331             virtual_space()-&gt;committed_size() == max_size(), &quot;Sanity&quot;);
332 
333   return true;
334 }
335 
336 #ifndef PRODUCT
337 // In the numa case eden is not mangled so a survivor space
338 // moving into a region previously occupied by a survivor
339 // may find an unmangled region.  Also in the PS case eden
340 // to-space and from-space may not touch (i.e., there may be
341 // gaps between them due to movement while resizing the
342 // spaces).  Those gaps must be mangled.
343 void PSYoungGen::mangle_survivors(MutableSpace* s1,
344                                   MemRegion s1MR,
345                                   MutableSpace* s2,
346                                   MemRegion s2MR) {
347   // Check eden and gap between eden and from-space, in deciding
348   // what to mangle in from-space.  Check the gap between from-space
349   // and to-space when deciding what to mangle.
350   //
351   //      +--------+   +----+    +---+
352   //      | eden   |   |s1  |    |s2 |
353   //      +--------+   +----+    +---+
354   //                 +-------+ +-----+
355   //                 |s1MR   | |s2MR |
356   //                 +-------+ +-----+
357   // All of survivor-space is properly mangled so find the
358   // upper bound on the mangling for any portion above current s1.
359   HeapWord* delta_end = MIN2(s1-&gt;bottom(), s1MR.end());
360   MemRegion delta1_left;
361   if (s1MR.start() &lt; delta_end) {
362     delta1_left = MemRegion(s1MR.start(), delta_end);
363     s1-&gt;mangle_region(delta1_left);
364   }
365   // Find any portion to the right of the current s1.
366   HeapWord* delta_start = MAX2(s1-&gt;end(), s1MR.start());
367   MemRegion delta1_right;
368   if (delta_start &lt; s1MR.end()) {
369     delta1_right = MemRegion(delta_start, s1MR.end());
370     s1-&gt;mangle_region(delta1_right);
371   }
372 
373   // Similarly for the second survivor space except that
374   // any of the new region that overlaps with the current
375   // region of the first survivor space has already been
376   // mangled.
377   delta_end = MIN2(s2-&gt;bottom(), s2MR.end());
378   delta_start = MAX2(s2MR.start(), s1-&gt;end());
379   MemRegion delta2_left;
380   if (s2MR.start() &lt; delta_end) {
381     delta2_left = MemRegion(s2MR.start(), delta_end);
382     s2-&gt;mangle_region(delta2_left);
383   }
384   delta_start = MAX2(s2-&gt;end(), s2MR.start());
385   MemRegion delta2_right;
386   if (delta_start &lt; s2MR.end()) {
387     s2-&gt;mangle_region(delta2_right);
388   }
389 
390   // s1
391   log_develop_trace(gc)(&quot;Current region: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;) &quot;
392     &quot;New region: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
393     p2i(s1-&gt;bottom()), p2i(s1-&gt;end()),
394     p2i(s1MR.start()), p2i(s1MR.end()));
395   log_develop_trace(gc)(&quot;    Mangle before: [&quot; PTR_FORMAT &quot;, &quot;
396     PTR_FORMAT &quot;)  Mangle after: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
397     p2i(delta1_left.start()), p2i(delta1_left.end()),
398     p2i(delta1_right.start()), p2i(delta1_right.end()));
399 
400   // s2
401   log_develop_trace(gc)(&quot;Current region: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;) &quot;
402     &quot;New region: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
403     p2i(s2-&gt;bottom()), p2i(s2-&gt;end()),
404     p2i(s2MR.start()), p2i(s2MR.end()));
405   log_develop_trace(gc)(&quot;    Mangle before: [&quot; PTR_FORMAT &quot;, &quot;
406     PTR_FORMAT &quot;)  Mangle after: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
407     p2i(delta2_left.start()), p2i(delta2_left.end()),
408     p2i(delta2_right.start()), p2i(delta2_right.end()));
409 }
410 #endif // NOT PRODUCT
411 
412 void PSYoungGen::resize_spaces(size_t requested_eden_size,
413                                size_t requested_survivor_size) {
414   assert(UseAdaptiveSizePolicy, &quot;sanity check&quot;);
415   assert(requested_eden_size &gt; 0  &amp;&amp; requested_survivor_size &gt; 0,
416          &quot;just checking&quot;);
417 
418   // We require eden and to space to be empty
419   if ((!eden_space()-&gt;is_empty()) || (!to_space()-&gt;is_empty())) {
420     return;
421   }
422 
423   log_trace(gc, ergo)(&quot;PSYoungGen::resize_spaces(requested_eden_size: &quot; SIZE_FORMAT &quot;, requested_survivor_size: &quot; SIZE_FORMAT &quot;)&quot;,
424                       requested_eden_size, requested_survivor_size);
425   log_trace(gc, ergo)(&quot;    eden: [&quot; PTR_FORMAT &quot;..&quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
426                       p2i(eden_space()-&gt;bottom()),
427                       p2i(eden_space()-&gt;end()),
428                       pointer_delta(eden_space()-&gt;end(),
429                                     eden_space()-&gt;bottom(),
430                                     sizeof(char)));
431   log_trace(gc, ergo)(&quot;    from: [&quot; PTR_FORMAT &quot;..&quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
432                       p2i(from_space()-&gt;bottom()),
433                       p2i(from_space()-&gt;end()),
434                       pointer_delta(from_space()-&gt;end(),
435                                     from_space()-&gt;bottom(),
436                                     sizeof(char)));
437   log_trace(gc, ergo)(&quot;      to: [&quot; PTR_FORMAT &quot;..&quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
438                       p2i(to_space()-&gt;bottom()),
439                       p2i(to_space()-&gt;end()),
440                       pointer_delta(  to_space()-&gt;end(),
441                                       to_space()-&gt;bottom(),
442                                       sizeof(char)));
443 
444   // There&#39;s nothing to do if the new sizes are the same as the current
445   if (requested_survivor_size == to_space()-&gt;capacity_in_bytes() &amp;&amp;
446       requested_survivor_size == from_space()-&gt;capacity_in_bytes() &amp;&amp;
447       requested_eden_size == eden_space()-&gt;capacity_in_bytes()) {
448     log_trace(gc, ergo)(&quot;    capacities are the right sizes, returning&quot;);
449     return;
450   }
451 
452   char* eden_start = (char*)eden_space()-&gt;bottom();
453   char* eden_end   = (char*)eden_space()-&gt;end();
454   char* from_start = (char*)from_space()-&gt;bottom();
455   char* from_end   = (char*)from_space()-&gt;end();
456   char* to_start   = (char*)to_space()-&gt;bottom();
457   char* to_end     = (char*)to_space()-&gt;end();
458 
459   const bool maintain_minimum =
460     (requested_eden_size + 2 * requested_survivor_size) &lt;= min_gen_size();
461 
462   bool eden_from_to_order = from_start &lt; to_start;
463   // Check whether from space is below to space
464   if (eden_from_to_order) {
465     // Eden, from, to
466     eden_from_to_order = true;
467     log_trace(gc, ergo)(&quot;  Eden, from, to:&quot;);
468 
469     // Set eden
470     // &quot;requested_eden_size&quot; is a goal for the size of eden
471     // and may not be attainable.  &quot;eden_size&quot; below is
472     // calculated based on the location of from-space and
473     // the goal for the size of eden.  from-space is
474     // fixed in place because it contains live data.
475     // The calculation is done this way to avoid 32bit
476     // overflow (i.e., eden_start + requested_eden_size
477     // may too large for representation in 32bits).
478     size_t eden_size;
479     if (maintain_minimum) {
480       // Only make eden larger than the requested size if
481       // the minimum size of the generation has to be maintained.
482       // This could be done in general but policy at a higher
483       // level is determining a requested size for eden and that
484       // should be honored unless there is a fundamental reason.
485       eden_size = pointer_delta(from_start,
486                                 eden_start,
487                                 sizeof(char));
488     } else {
489       eden_size = MIN2(requested_eden_size,
490                        pointer_delta(from_start, eden_start, sizeof(char)));
491     }
492 
493     eden_end = eden_start + eden_size;
494     assert(eden_end &gt;= eden_start, &quot;addition overflowed&quot;);
495 
496     // To may resize into from space as long as it is clear of live data.
497     // From space must remain page aligned, though, so we need to do some
498     // extra calculations.
499 
500     // First calculate an optimal to-space
501     to_end   = (char*)virtual_space()-&gt;high();
502     to_start = (char*)pointer_delta(to_end, (char*)requested_survivor_size,
503                                     sizeof(char));
504 
505     // Does the optimal to-space overlap from-space?
506     if (to_start &lt; (char*)from_space()-&gt;end()) {
507       // Calculate the minimum offset possible for from_end
508       size_t from_size = pointer_delta(from_space()-&gt;top(), from_start, sizeof(char));
509 
510       // Should we be in this method if from_space is empty? Why not the set_space method? FIX ME!
511       if (from_size == 0) {
512         from_size = SpaceAlignment;
513       } else {
514         from_size = align_up(from_size, SpaceAlignment);
515       }
516 
517       from_end = from_start + from_size;
518       assert(from_end &gt; from_start, &quot;addition overflow or from_size problem&quot;);
519 
520       guarantee(from_end &lt;= (char*)from_space()-&gt;end(), &quot;from_end moved to the right&quot;);
521 
522       // Now update to_start with the new from_end
523       to_start = MAX2(from_end, to_start);
524     }
525 
526     guarantee(to_start != to_end, &quot;to space is zero sized&quot;);
527 
528     log_trace(gc, ergo)(&quot;    [eden_start .. eden_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
529                         p2i(eden_start),
530                         p2i(eden_end),
531                         pointer_delta(eden_end, eden_start, sizeof(char)));
532     log_trace(gc, ergo)(&quot;    [from_start .. from_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
533                         p2i(from_start),
534                         p2i(from_end),
535                         pointer_delta(from_end, from_start, sizeof(char)));
536     log_trace(gc, ergo)(&quot;    [  to_start ..   to_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
537                         p2i(to_start),
538                         p2i(to_end),
539                         pointer_delta(  to_end,   to_start, sizeof(char)));
540   } else {
541     // Eden, to, from
542     log_trace(gc, ergo)(&quot;  Eden, to, from:&quot;);
543 
544     // To space gets priority over eden resizing. Note that we position
545     // to space as if we were able to resize from space, even though from
546     // space is not modified.
547     // Giving eden priority was tried and gave poorer performance.
548     to_end   = (char*)pointer_delta(virtual_space()-&gt;high(),
549                                     (char*)requested_survivor_size,
550                                     sizeof(char));
551     to_end   = MIN2(to_end, from_start);
552     to_start = (char*)pointer_delta(to_end, (char*)requested_survivor_size,
553                                     sizeof(char));
554     // if the space sizes are to be increased by several times then
555     // &#39;to_start&#39; will point beyond the young generation. In this case
556     // &#39;to_start&#39; should be adjusted.
557     to_start = MAX2(to_start, eden_start + SpaceAlignment);
558 
559     // Compute how big eden can be, then adjust end.
560     // See  comments above on calculating eden_end.
561     size_t eden_size;
562     if (maintain_minimum) {
563       eden_size = pointer_delta(to_start, eden_start, sizeof(char));
564     } else {
565       eden_size = MIN2(requested_eden_size,
566                        pointer_delta(to_start, eden_start, sizeof(char)));
567     }
568     eden_end = eden_start + eden_size;
569     assert(eden_end &gt;= eden_start, &quot;addition overflowed&quot;);
570 
571     // Could choose to not let eden shrink
572     // to_start = MAX2(to_start, eden_end);
573 
574     // Don&#39;t let eden shrink down to 0 or less.
575     eden_end = MAX2(eden_end, eden_start + SpaceAlignment);
576     to_start = MAX2(to_start, eden_end);
577 
578     log_trace(gc, ergo)(&quot;    [eden_start .. eden_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
579                         p2i(eden_start),
580                         p2i(eden_end),
581                         pointer_delta(eden_end, eden_start, sizeof(char)));
582     log_trace(gc, ergo)(&quot;    [  to_start ..   to_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
583                         p2i(to_start),
584                         p2i(to_end),
585                         pointer_delta(  to_end,   to_start, sizeof(char)));
586     log_trace(gc, ergo)(&quot;    [from_start .. from_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
587                         p2i(from_start),
588                         p2i(from_end),
589                         pointer_delta(from_end, from_start, sizeof(char)));
590   }
591 
592 
593   guarantee((HeapWord*)from_start &lt;= from_space()-&gt;bottom(),
594             &quot;from start moved to the right&quot;);
595   guarantee((HeapWord*)from_end &gt;= from_space()-&gt;top(),
596             &quot;from end moved into live data&quot;);
597   assert(is_object_aligned(eden_start), &quot;checking alignment&quot;);
598   assert(is_object_aligned(from_start), &quot;checking alignment&quot;);
599   assert(is_object_aligned(to_start), &quot;checking alignment&quot;);
600 
601   MemRegion edenMR((HeapWord*)eden_start, (HeapWord*)eden_end);
602   MemRegion toMR  ((HeapWord*)to_start,   (HeapWord*)to_end);
603   MemRegion fromMR((HeapWord*)from_start, (HeapWord*)from_end);
604 
605   // Let&#39;s make sure the call to initialize doesn&#39;t reset &quot;top&quot;!
606   HeapWord* old_from_top = from_space()-&gt;top();
607 
608   // For logging block  below
609   size_t old_from = from_space()-&gt;capacity_in_bytes();
610   size_t old_to   = to_space()-&gt;capacity_in_bytes();
611 
612   if (ZapUnusedHeapArea) {
613     // NUMA is a special case because a numa space is not mangled
614     // in order to not prematurely bind its address to memory to
615     // the wrong memory (i.e., don&#39;t want the GC thread to first
616     // touch the memory).  The survivor spaces are not numa
617     // spaces and are mangled.
618     if (UseNUMA) {
619       if (eden_from_to_order) {
620         mangle_survivors(from_space(), fromMR, to_space(), toMR);
621       } else {
622         mangle_survivors(to_space(), toMR, from_space(), fromMR);
623       }
624     }
625 
626     // If not mangling the spaces, do some checking to verify that
627     // the spaces are already mangled.
628     // The spaces should be correctly mangled at this point so
629     // do some checking here. Note that they are not being mangled
630     // in the calls to initialize().
631     // Must check mangling before the spaces are reshaped.  Otherwise,
632     // the bottom or end of one space may have moved into an area
633     // covered by another space and a failure of the check may
634     // not correctly indicate which space is not properly mangled.
635     HeapWord* limit = (HeapWord*) virtual_space()-&gt;high();
636     eden_space()-&gt;check_mangled_unused_area(limit);
637     from_space()-&gt;check_mangled_unused_area(limit);
638       to_space()-&gt;check_mangled_unused_area(limit);
639   }
640   // When an existing space is being initialized, it is not
641   // mangled because the space has been previously mangled.
642   eden_space()-&gt;initialize(edenMR,
643                            SpaceDecorator::Clear,
644                            SpaceDecorator::DontMangle);
645     to_space()-&gt;initialize(toMR,
646                            SpaceDecorator::Clear,
647                            SpaceDecorator::DontMangle);
648   from_space()-&gt;initialize(fromMR,
649                            SpaceDecorator::DontClear,
650                            SpaceDecorator::DontMangle);
651 
652   assert(from_space()-&gt;top() == old_from_top, &quot;from top changed!&quot;);
653 
654   log_trace(gc, ergo)(&quot;AdaptiveSizePolicy::survivor space sizes: collection: %d (&quot; SIZE_FORMAT &quot;, &quot; SIZE_FORMAT &quot;) -&gt; (&quot; SIZE_FORMAT &quot;, &quot; SIZE_FORMAT &quot;) &quot;,
655                       ParallelScavengeHeap::heap()-&gt;total_collections(),
656                       old_from, old_to,
657                       from_space()-&gt;capacity_in_bytes(),
658                       to_space()-&gt;capacity_in_bytes());
659 }
660 
661 void PSYoungGen::swap_spaces() {
662   MutableSpace* s    = from_space();
663   _from_space        = to_space();
664   _to_space          = s;
665 }
666 
667 size_t PSYoungGen::capacity_in_bytes() const {
668   return eden_space()-&gt;capacity_in_bytes()
669        + from_space()-&gt;capacity_in_bytes();  // to_space() is only used during scavenge
670 }
671 
672 
673 size_t PSYoungGen::used_in_bytes() const {
674   return eden_space()-&gt;used_in_bytes()
675        + from_space()-&gt;used_in_bytes();      // to_space() is only used during scavenge
676 }
677 
678 
679 size_t PSYoungGen::free_in_bytes() const {
680   return eden_space()-&gt;free_in_bytes()
681        + from_space()-&gt;free_in_bytes();      // to_space() is only used during scavenge
682 }
683 
684 size_t PSYoungGen::capacity_in_words() const {
685   return eden_space()-&gt;capacity_in_words()
686        + from_space()-&gt;capacity_in_words();  // to_space() is only used during scavenge
687 }
688 
689 
690 size_t PSYoungGen::used_in_words() const {
691   return eden_space()-&gt;used_in_words()
692        + from_space()-&gt;used_in_words();      // to_space() is only used during scavenge
693 }
694 
695 
696 size_t PSYoungGen::free_in_words() const {
697   return eden_space()-&gt;free_in_words()
698        + from_space()-&gt;free_in_words();      // to_space() is only used during scavenge
699 }
700 
701 void PSYoungGen::object_iterate(ObjectClosure* blk) {
702   eden_space()-&gt;object_iterate(blk);
703   from_space()-&gt;object_iterate(blk);
704   to_space()-&gt;object_iterate(blk);
705 }
706 
707 void PSYoungGen::print() const { print_on(tty); }
708 void PSYoungGen::print_on(outputStream* st) const {
709   st-&gt;print(&quot; %-15s&quot;, &quot;PSYoungGen&quot;);
710   st-&gt;print(&quot; total &quot; SIZE_FORMAT &quot;K, used &quot; SIZE_FORMAT &quot;K&quot;,
711              capacity_in_bytes()/K, used_in_bytes()/K);
712   virtual_space()-&gt;print_space_boundaries_on(st);
713   st-&gt;print(&quot;  eden&quot;); eden_space()-&gt;print_on(st);
714   st-&gt;print(&quot;  from&quot;); from_space()-&gt;print_on(st);
715   st-&gt;print(&quot;  to  &quot;); to_space()-&gt;print_on(st);
716 }
717 
718 size_t PSYoungGen::available_for_expansion() {
719   ShouldNotReachHere();
720   return 0;
721 }
722 
723 size_t PSYoungGen::available_for_contraction() {
724   ShouldNotReachHere();
725   return 0;
726 }
727 
728 size_t PSYoungGen::available_to_min_gen() {
729   assert(virtual_space()-&gt;committed_size() &gt;= min_gen_size(), &quot;Invariant&quot;);
730   return virtual_space()-&gt;committed_size() - min_gen_size();
731 }
732 
733 // This method assumes that from-space has live data and that
734 // any shrinkage of the young gen is limited by location of
735 // from-space.
736 size_t PSYoungGen::available_to_live() {
737   size_t delta_in_survivor = 0;
738   MutableSpace* space_shrinking = NULL;
739   if (from_space()-&gt;end() &gt; to_space()-&gt;end()) {
740     space_shrinking = from_space();
741   } else {
742     space_shrinking = to_space();
743   }
744 
745   // Include any space that is committed but not included in
746   // the survivor spaces.
747   assert(((HeapWord*)virtual_space()-&gt;high()) &gt;= space_shrinking-&gt;end(),
748     &quot;Survivor space beyond high end&quot;);
749   size_t unused_committed = pointer_delta(virtual_space()-&gt;high(),
750     space_shrinking-&gt;end(), sizeof(char));
751 
752   if (space_shrinking-&gt;is_empty()) {
753     // Don&#39;t let the space shrink to 0
754     assert(space_shrinking-&gt;capacity_in_bytes() &gt;= SpaceAlignment,
755       &quot;Space is too small&quot;);
756     delta_in_survivor = space_shrinking-&gt;capacity_in_bytes() - SpaceAlignment;
757   } else {
758     delta_in_survivor = pointer_delta(space_shrinking-&gt;end(),
759                                       space_shrinking-&gt;top(),
760                                       sizeof(char));
761   }
762 
763   size_t delta_in_bytes = unused_committed + delta_in_survivor;
764   delta_in_bytes = align_down(delta_in_bytes, GenAlignment);
765   return delta_in_bytes;
766 }
767 
768 // Return the number of bytes available for resizing down the young
769 // generation.  This is the minimum of
770 //      input &quot;bytes&quot;
771 //      bytes to the minimum young gen size
772 //      bytes to the size currently being used + some small extra
773 size_t PSYoungGen::limit_gen_shrink(size_t bytes) {
774   // Allow shrinkage into the current eden but keep eden large enough
775   // to maintain the minimum young gen size
776   bytes = MIN3(bytes, available_to_min_gen(), available_to_live());
777   return align_down(bytes, virtual_space()-&gt;alignment());
778 }
779 
780 void PSYoungGen::reset_after_change() {
781   ShouldNotReachHere();
782 }
783 
784 void PSYoungGen::reset_survivors_after_shrink() {
785   _reserved = MemRegion((HeapWord*)virtual_space()-&gt;low_boundary(),
786                         (HeapWord*)virtual_space()-&gt;high_boundary());
787   PSScavenge::set_subject_to_discovery_span(_reserved);
788 
789   MutableSpace* space_shrinking = NULL;
790   if (from_space()-&gt;end() &gt; to_space()-&gt;end()) {
791     space_shrinking = from_space();
792   } else {
793     space_shrinking = to_space();
794   }
795 
796   HeapWord* new_end = (HeapWord*)virtual_space()-&gt;high();
797   assert(new_end &gt;= space_shrinking-&gt;bottom(), &quot;Shrink was too large&quot;);
798   // Was there a shrink of the survivor space?
799   if (new_end &lt; space_shrinking-&gt;end()) {
800     MemRegion mr(space_shrinking-&gt;bottom(), new_end);
801     space_shrinking-&gt;initialize(mr,
802                                 SpaceDecorator::DontClear,
803                                 SpaceDecorator::Mangle);
804   }
805 }
806 
807 // This method currently does not expect to expand into eden (i.e.,
808 // the virtual space boundaries is expected to be consistent
809 // with the eden boundaries..
810 void PSYoungGen::post_resize() {
811   assert_locked_or_safepoint(Heap_lock);
812   assert((eden_space()-&gt;bottom() &lt; to_space()-&gt;bottom()) &amp;&amp;
813          (eden_space()-&gt;bottom() &lt; from_space()-&gt;bottom()),
814          &quot;Eden is assumed to be below the survivor spaces&quot;);
815 
816   MemRegion cmr((HeapWord*)virtual_space()-&gt;low(),
817                 (HeapWord*)virtual_space()-&gt;high());
818   ParallelScavengeHeap::heap()-&gt;card_table()-&gt;resize_covered_region(cmr);
819   space_invariants();
820 }
821 
822 
823 
824 void PSYoungGen::update_counters() {
825   if (UsePerfData) {
826     _eden_counters-&gt;update_all();
827     _from_counters-&gt;update_all();
828     _to_counters-&gt;update_all();
829     _gen_counters-&gt;update_all();
830   }
831 }
832 
833 void PSYoungGen::verify() {
834   eden_space()-&gt;verify();
835   from_space()-&gt;verify();
836   to_space()-&gt;verify();
837 }
838 
839 #ifndef PRODUCT
840 void PSYoungGen::record_spaces_top() {
841   assert(ZapUnusedHeapArea, &quot;Not mangling unused space&quot;);
842   eden_space()-&gt;set_top_for_allocations();
843   from_space()-&gt;set_top_for_allocations();
844   to_space()-&gt;set_top_for_allocations();
845 }
846 #endif
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/parallel/psYoungGen.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/parallel/mutableNUMASpace.hpp&quot;
 27 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
 28 #include &quot;gc/parallel/psScavenge.hpp&quot;
 29 #include &quot;gc/parallel/psYoungGen.hpp&quot;
 30 #include &quot;gc/shared/gcUtil.hpp&quot;
 31 #include &quot;gc/shared/genArguments.hpp&quot;
 32 #include &quot;gc/shared/spaceDecorator.inline.hpp&quot;
 33 #include &quot;logging/log.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;runtime/java.hpp&quot;
 36 #include &quot;utilities/align.hpp&quot;
 37 
 38 PSYoungGen::PSYoungGen(size_t initial_size, size_t min_size, size_t max_size) :
 39   _reserved(),
 40   _virtual_space(NULL),
 41   _eden_space(NULL),
 42   _from_space(NULL),
 43   _to_space(NULL),
 44   _init_gen_size(initial_size),
 45   _min_gen_size(min_size),
 46   _max_gen_size(max_size),
 47   _gen_counters(NULL),
 48   _eden_counters(NULL),
 49   _from_counters(NULL),
 50   _to_counters(NULL)
 51 {}
 52 
 53 void PSYoungGen::initialize_virtual_space(ReservedSpace rs, size_t alignment) {
 54   assert(_init_gen_size != 0, &quot;Should have a finite size&quot;);
 55   _virtual_space = new PSVirtualSpace(rs, alignment);
 56   if (!virtual_space()-&gt;expand_by(_init_gen_size)) {
 57     vm_exit_during_initialization(&quot;Could not reserve enough space for &quot;
 58                                   &quot;object heap&quot;);
 59   }
 60 }
 61 
 62 void PSYoungGen::initialize(ReservedSpace rs, size_t alignment) {
 63   initialize_virtual_space(rs, alignment);
 64   initialize_work();
 65 }
 66 
 67 void PSYoungGen::initialize_work() {
 68 
 69   _reserved = MemRegion((HeapWord*)virtual_space()-&gt;low_boundary(),
 70                         (HeapWord*)virtual_space()-&gt;high_boundary());
 71 
 72   MemRegion cmr((HeapWord*)virtual_space()-&gt;low(),
 73                 (HeapWord*)virtual_space()-&gt;high());
 74   ParallelScavengeHeap::heap()-&gt;card_table()-&gt;resize_covered_region(cmr);
 75 
 76   if (ZapUnusedHeapArea) {
 77     // Mangle newly committed space immediately because it
 78     // can be done here more simply that after the new
 79     // spaces have been computed.
 80     SpaceMangler::mangle_region(cmr);
 81   }
 82 
 83   if (UseNUMA) {
 84     _eden_space = new MutableNUMASpace(virtual_space()-&gt;alignment());
 85   } else {
 86     _eden_space = new MutableSpace(virtual_space()-&gt;alignment());
 87   }
 88   _from_space = new MutableSpace(virtual_space()-&gt;alignment());
 89   _to_space   = new MutableSpace(virtual_space()-&gt;alignment());
 90 
<a name="1" id="anc1"></a>



 91   // Generation Counters - generation 0, 3 subspaces
 92   _gen_counters = new PSGenerationCounters(&quot;new&quot;, 0, 3, _min_gen_size,
 93                                            _max_gen_size, _virtual_space);
 94 
 95   // Compute maximum space sizes for performance counters
 96   size_t alignment = SpaceAlignment;
 97   size_t size = virtual_space()-&gt;reserved_size();
 98 
 99   size_t max_survivor_size;
100   size_t max_eden_size;
101 
102   if (UseAdaptiveSizePolicy) {
103     max_survivor_size = size / MinSurvivorRatio;
104 
105     // round the survivor space size down to the nearest alignment
106     // and make sure its size is greater than 0.
107     max_survivor_size = align_down(max_survivor_size, alignment);
108     max_survivor_size = MAX2(max_survivor_size, alignment);
109 
110     // set the maximum size of eden to be the size of the young gen
111     // less two times the minimum survivor size. The minimum survivor
112     // size for UseAdaptiveSizePolicy is one alignment.
113     max_eden_size = size - 2 * alignment;
114   } else {
115     max_survivor_size = size / InitialSurvivorRatio;
116 
117     // round the survivor space size down to the nearest alignment
118     // and make sure its size is greater than 0.
119     max_survivor_size = align_down(max_survivor_size, alignment);
120     max_survivor_size = MAX2(max_survivor_size, alignment);
121 
122     // set the maximum size of eden to be the size of the young gen
123     // less two times the survivor size when the generation is 100%
124     // committed. The minimum survivor size for -UseAdaptiveSizePolicy
125     // is dependent on the committed portion (current capacity) of the
126     // generation - the less space committed, the smaller the survivor
127     // space, possibly as small as an alignment. However, we are interested
128     // in the case where the young generation is 100% committed, as this
129     // is the point where eden reaches its maximum size. At this point,
130     // the size of a survivor space is max_survivor_size.
131     max_eden_size = size - 2 * max_survivor_size;
132   }
133 
134   _eden_counters = new SpaceCounters(&quot;eden&quot;, 0, max_eden_size, _eden_space,
135                                      _gen_counters);
136   _from_counters = new SpaceCounters(&quot;s0&quot;, 1, max_survivor_size, _from_space,
137                                      _gen_counters);
138   _to_counters = new SpaceCounters(&quot;s1&quot;, 2, max_survivor_size, _to_space,
139                                    _gen_counters);
140 
141   compute_initial_space_boundaries();
142 }
143 
144 void PSYoungGen::compute_initial_space_boundaries() {
145   // Compute sizes
146   size_t size = virtual_space()-&gt;committed_size();
147   assert(size &gt;= 3 * SpaceAlignment, &quot;Young space is not large enough for eden + 2 survivors&quot;);
148 
149   size_t survivor_size = size / InitialSurvivorRatio;
150   survivor_size = align_down(survivor_size, SpaceAlignment);
151   // ... but never less than an alignment
152   survivor_size = MAX2(survivor_size, SpaceAlignment);
153 
154   // Young generation is eden + 2 survivor spaces
155   size_t eden_size = size - (2 * survivor_size);
156 
157   // Now go ahead and set &#39;em.
158   set_space_boundaries(eden_size, survivor_size);
159   space_invariants();
160 
161   if (UsePerfData) {
162     _eden_counters-&gt;update_capacity();
163     _from_counters-&gt;update_capacity();
164     _to_counters-&gt;update_capacity();
165   }
166 }
167 
168 void PSYoungGen::set_space_boundaries(size_t eden_size, size_t survivor_size) {
169   assert(eden_size &lt; virtual_space()-&gt;committed_size(), &quot;just checking&quot;);
170   assert(eden_size &gt; 0  &amp;&amp; survivor_size &gt; 0, &quot;just checking&quot;);
171 
172   // Initial layout is Eden, to, from. After swapping survivor spaces,
173   // that leaves us with Eden, from, to, which is step one in our two
174   // step resize-with-live-data procedure.
175   char *eden_start = virtual_space()-&gt;low();
176   char *to_start   = eden_start + eden_size;
177   char *from_start = to_start   + survivor_size;
178   char *from_end   = from_start + survivor_size;
179 
180   assert(from_end == virtual_space()-&gt;high(), &quot;just checking&quot;);
181   assert(is_object_aligned(eden_start), &quot;checking alignment&quot;);
182   assert(is_object_aligned(to_start),   &quot;checking alignment&quot;);
183   assert(is_object_aligned(from_start), &quot;checking alignment&quot;);
184 
185   MemRegion eden_mr((HeapWord*)eden_start, (HeapWord*)to_start);
186   MemRegion to_mr  ((HeapWord*)to_start, (HeapWord*)from_start);
187   MemRegion from_mr((HeapWord*)from_start, (HeapWord*)from_end);
188 
189   eden_space()-&gt;initialize(eden_mr, true, ZapUnusedHeapArea);
190     to_space()-&gt;initialize(to_mr  , true, ZapUnusedHeapArea);
191   from_space()-&gt;initialize(from_mr, true, ZapUnusedHeapArea);
192 }
193 
194 #ifndef PRODUCT
195 void PSYoungGen::space_invariants() {
196   // Currently, our eden size cannot shrink to zero
197   guarantee(eden_space()-&gt;capacity_in_bytes() &gt;= SpaceAlignment, &quot;eden too small&quot;);
198   guarantee(from_space()-&gt;capacity_in_bytes() &gt;= SpaceAlignment, &quot;from too small&quot;);
199   guarantee(to_space()-&gt;capacity_in_bytes() &gt;= SpaceAlignment, &quot;to too small&quot;);
200 
201   // Relationship of spaces to each other
202   char* eden_start = (char*)eden_space()-&gt;bottom();
203   char* eden_end   = (char*)eden_space()-&gt;end();
204   char* from_start = (char*)from_space()-&gt;bottom();
205   char* from_end   = (char*)from_space()-&gt;end();
206   char* to_start   = (char*)to_space()-&gt;bottom();
207   char* to_end     = (char*)to_space()-&gt;end();
208 
209   guarantee(eden_start &gt;= virtual_space()-&gt;low(), &quot;eden bottom&quot;);
210   guarantee(eden_start &lt; eden_end, &quot;eden space consistency&quot;);
211   guarantee(from_start &lt; from_end, &quot;from space consistency&quot;);
212   guarantee(to_start &lt; to_end, &quot;to space consistency&quot;);
213 
214   // Check whether from space is below to space
215   if (from_start &lt; to_start) {
216     // Eden, from, to
217     guarantee(eden_end &lt;= from_start, &quot;eden/from boundary&quot;);
218     guarantee(from_end &lt;= to_start,   &quot;from/to boundary&quot;);
219     guarantee(to_end &lt;= virtual_space()-&gt;high(), &quot;to end&quot;);
220   } else {
221     // Eden, to, from
222     guarantee(eden_end &lt;= to_start, &quot;eden/to boundary&quot;);
223     guarantee(to_end &lt;= from_start, &quot;to/from boundary&quot;);
224     guarantee(from_end &lt;= virtual_space()-&gt;high(), &quot;from end&quot;);
225   }
226 
227   // More checks that the virtual space is consistent with the spaces
228   assert(virtual_space()-&gt;committed_size() &gt;=
229     (eden_space()-&gt;capacity_in_bytes() +
230      to_space()-&gt;capacity_in_bytes() +
231      from_space()-&gt;capacity_in_bytes()), &quot;Committed size is inconsistent&quot;);
232   assert(virtual_space()-&gt;committed_size() &lt;= virtual_space()-&gt;reserved_size(),
233     &quot;Space invariant&quot;);
234   char* eden_top = (char*)eden_space()-&gt;top();
235   char* from_top = (char*)from_space()-&gt;top();
236   char* to_top = (char*)to_space()-&gt;top();
237   assert(eden_top &lt;= virtual_space()-&gt;high(), &quot;eden top&quot;);
238   assert(from_top &lt;= virtual_space()-&gt;high(), &quot;from top&quot;);
239   assert(to_top &lt;= virtual_space()-&gt;high(), &quot;to top&quot;);
240 
241   virtual_space()-&gt;verify();
242 }
243 #endif
244 
245 void PSYoungGen::resize(size_t eden_size, size_t survivor_size) {
246   // Resize the generation if needed. If the generation resize
247   // reports false, do not attempt to resize the spaces.
248   if (resize_generation(eden_size, survivor_size)) {
249     // Then we lay out the spaces inside the generation
250     resize_spaces(eden_size, survivor_size);
251 
252     space_invariants();
253 
254     log_trace(gc, ergo)(&quot;Young generation size: &quot;
255                         &quot;desired eden: &quot; SIZE_FORMAT &quot; survivor: &quot; SIZE_FORMAT
256                         &quot; used: &quot; SIZE_FORMAT &quot; capacity: &quot; SIZE_FORMAT
257                         &quot; gen limits: &quot; SIZE_FORMAT &quot; / &quot; SIZE_FORMAT,
258                         eden_size, survivor_size, used_in_bytes(), capacity_in_bytes(),
259                         _max_gen_size, min_gen_size());
260   }
261 }
262 
263 
264 bool PSYoungGen::resize_generation(size_t eden_size, size_t survivor_size) {
265   const size_t alignment = virtual_space()-&gt;alignment();
266   size_t orig_size = virtual_space()-&gt;committed_size();
267   bool size_changed = false;
268 
269   // There used to be this guarantee there.
270   // guarantee ((eden_size + 2*survivor_size)  &lt;= _max_gen_size, &quot;incorrect input arguments&quot;);
271   // Code below forces this requirement.  In addition the desired eden
272   // size and desired survivor sizes are desired goals and may
273   // exceed the total generation size.
274 
275   assert(min_gen_size() &lt;= orig_size &amp;&amp; orig_size &lt;= max_size(), &quot;just checking&quot;);
276 
277   // Adjust new generation size
278   const size_t eden_plus_survivors =
279           align_up(eden_size + 2 * survivor_size, alignment);
280   size_t desired_size = clamp(eden_plus_survivors, min_gen_size(), max_size());
281   assert(desired_size &lt;= max_size(), &quot;just checking&quot;);
282 
283   if (desired_size &gt; orig_size) {
284     // Grow the generation
285     size_t change = desired_size - orig_size;
286     assert(change % alignment == 0, &quot;just checking&quot;);
287     HeapWord* prev_high = (HeapWord*) virtual_space()-&gt;high();
288     if (!virtual_space()-&gt;expand_by(change)) {
289       return false; // Error if we fail to resize!
290     }
291     if (ZapUnusedHeapArea) {
292       // Mangle newly committed space immediately because it
293       // can be done here more simply that after the new
294       // spaces have been computed.
295       HeapWord* new_high = (HeapWord*) virtual_space()-&gt;high();
296       MemRegion mangle_region(prev_high, new_high);
297       SpaceMangler::mangle_region(mangle_region);
298     }
299     size_changed = true;
300   } else if (desired_size &lt; orig_size) {
301     size_t desired_change = orig_size - desired_size;
302     assert(desired_change % alignment == 0, &quot;just checking&quot;);
303 
304     desired_change = limit_gen_shrink(desired_change);
305 
306     if (desired_change &gt; 0) {
307       virtual_space()-&gt;shrink_by(desired_change);
308       reset_survivors_after_shrink();
309 
310       size_changed = true;
311     }
312   } else {
313     if (orig_size == gen_size_limit()) {
314       log_trace(gc)(&quot;PSYoung generation size at maximum: &quot; SIZE_FORMAT &quot;K&quot;, orig_size/K);
315     } else if (orig_size == min_gen_size()) {
316       log_trace(gc)(&quot;PSYoung generation size at minium: &quot; SIZE_FORMAT &quot;K&quot;, orig_size/K);
317     }
318   }
319 
320   if (size_changed) {
321     post_resize();
322     log_trace(gc)(&quot;PSYoung generation size changed: &quot; SIZE_FORMAT &quot;K-&gt;&quot; SIZE_FORMAT &quot;K&quot;,
323                   orig_size/K, virtual_space()-&gt;committed_size()/K);
324   }
325 
326   guarantee(eden_plus_survivors &lt;= virtual_space()-&gt;committed_size() ||
327             virtual_space()-&gt;committed_size() == max_size(), &quot;Sanity&quot;);
328 
329   return true;
330 }
331 
332 #ifndef PRODUCT
333 // In the numa case eden is not mangled so a survivor space
334 // moving into a region previously occupied by a survivor
335 // may find an unmangled region.  Also in the PS case eden
336 // to-space and from-space may not touch (i.e., there may be
337 // gaps between them due to movement while resizing the
338 // spaces).  Those gaps must be mangled.
339 void PSYoungGen::mangle_survivors(MutableSpace* s1,
340                                   MemRegion s1MR,
341                                   MutableSpace* s2,
342                                   MemRegion s2MR) {
343   // Check eden and gap between eden and from-space, in deciding
344   // what to mangle in from-space.  Check the gap between from-space
345   // and to-space when deciding what to mangle.
346   //
347   //      +--------+   +----+    +---+
348   //      | eden   |   |s1  |    |s2 |
349   //      +--------+   +----+    +---+
350   //                 +-------+ +-----+
351   //                 |s1MR   | |s2MR |
352   //                 +-------+ +-----+
353   // All of survivor-space is properly mangled so find the
354   // upper bound on the mangling for any portion above current s1.
355   HeapWord* delta_end = MIN2(s1-&gt;bottom(), s1MR.end());
356   MemRegion delta1_left;
357   if (s1MR.start() &lt; delta_end) {
358     delta1_left = MemRegion(s1MR.start(), delta_end);
359     s1-&gt;mangle_region(delta1_left);
360   }
361   // Find any portion to the right of the current s1.
362   HeapWord* delta_start = MAX2(s1-&gt;end(), s1MR.start());
363   MemRegion delta1_right;
364   if (delta_start &lt; s1MR.end()) {
365     delta1_right = MemRegion(delta_start, s1MR.end());
366     s1-&gt;mangle_region(delta1_right);
367   }
368 
369   // Similarly for the second survivor space except that
370   // any of the new region that overlaps with the current
371   // region of the first survivor space has already been
372   // mangled.
373   delta_end = MIN2(s2-&gt;bottom(), s2MR.end());
374   delta_start = MAX2(s2MR.start(), s1-&gt;end());
375   MemRegion delta2_left;
376   if (s2MR.start() &lt; delta_end) {
377     delta2_left = MemRegion(s2MR.start(), delta_end);
378     s2-&gt;mangle_region(delta2_left);
379   }
380   delta_start = MAX2(s2-&gt;end(), s2MR.start());
381   MemRegion delta2_right;
382   if (delta_start &lt; s2MR.end()) {
383     s2-&gt;mangle_region(delta2_right);
384   }
385 
386   // s1
387   log_develop_trace(gc)(&quot;Current region: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;) &quot;
388     &quot;New region: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
389     p2i(s1-&gt;bottom()), p2i(s1-&gt;end()),
390     p2i(s1MR.start()), p2i(s1MR.end()));
391   log_develop_trace(gc)(&quot;    Mangle before: [&quot; PTR_FORMAT &quot;, &quot;
392     PTR_FORMAT &quot;)  Mangle after: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
393     p2i(delta1_left.start()), p2i(delta1_left.end()),
394     p2i(delta1_right.start()), p2i(delta1_right.end()));
395 
396   // s2
397   log_develop_trace(gc)(&quot;Current region: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;) &quot;
398     &quot;New region: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
399     p2i(s2-&gt;bottom()), p2i(s2-&gt;end()),
400     p2i(s2MR.start()), p2i(s2MR.end()));
401   log_develop_trace(gc)(&quot;    Mangle before: [&quot; PTR_FORMAT &quot;, &quot;
402     PTR_FORMAT &quot;)  Mangle after: [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
403     p2i(delta2_left.start()), p2i(delta2_left.end()),
404     p2i(delta2_right.start()), p2i(delta2_right.end()));
405 }
406 #endif // NOT PRODUCT
407 
408 void PSYoungGen::resize_spaces(size_t requested_eden_size,
409                                size_t requested_survivor_size) {
410   assert(UseAdaptiveSizePolicy, &quot;sanity check&quot;);
411   assert(requested_eden_size &gt; 0  &amp;&amp; requested_survivor_size &gt; 0,
412          &quot;just checking&quot;);
413 
414   // We require eden and to space to be empty
415   if ((!eden_space()-&gt;is_empty()) || (!to_space()-&gt;is_empty())) {
416     return;
417   }
418 
419   log_trace(gc, ergo)(&quot;PSYoungGen::resize_spaces(requested_eden_size: &quot; SIZE_FORMAT &quot;, requested_survivor_size: &quot; SIZE_FORMAT &quot;)&quot;,
420                       requested_eden_size, requested_survivor_size);
421   log_trace(gc, ergo)(&quot;    eden: [&quot; PTR_FORMAT &quot;..&quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
422                       p2i(eden_space()-&gt;bottom()),
423                       p2i(eden_space()-&gt;end()),
424                       pointer_delta(eden_space()-&gt;end(),
425                                     eden_space()-&gt;bottom(),
426                                     sizeof(char)));
427   log_trace(gc, ergo)(&quot;    from: [&quot; PTR_FORMAT &quot;..&quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
428                       p2i(from_space()-&gt;bottom()),
429                       p2i(from_space()-&gt;end()),
430                       pointer_delta(from_space()-&gt;end(),
431                                     from_space()-&gt;bottom(),
432                                     sizeof(char)));
433   log_trace(gc, ergo)(&quot;      to: [&quot; PTR_FORMAT &quot;..&quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
434                       p2i(to_space()-&gt;bottom()),
435                       p2i(to_space()-&gt;end()),
436                       pointer_delta(  to_space()-&gt;end(),
437                                       to_space()-&gt;bottom(),
438                                       sizeof(char)));
439 
440   // There&#39;s nothing to do if the new sizes are the same as the current
441   if (requested_survivor_size == to_space()-&gt;capacity_in_bytes() &amp;&amp;
442       requested_survivor_size == from_space()-&gt;capacity_in_bytes() &amp;&amp;
443       requested_eden_size == eden_space()-&gt;capacity_in_bytes()) {
444     log_trace(gc, ergo)(&quot;    capacities are the right sizes, returning&quot;);
445     return;
446   }
447 
448   char* eden_start = (char*)eden_space()-&gt;bottom();
449   char* eden_end   = (char*)eden_space()-&gt;end();
450   char* from_start = (char*)from_space()-&gt;bottom();
451   char* from_end   = (char*)from_space()-&gt;end();
452   char* to_start   = (char*)to_space()-&gt;bottom();
453   char* to_end     = (char*)to_space()-&gt;end();
454 
455   const bool maintain_minimum =
456     (requested_eden_size + 2 * requested_survivor_size) &lt;= min_gen_size();
457 
458   bool eden_from_to_order = from_start &lt; to_start;
459   // Check whether from space is below to space
460   if (eden_from_to_order) {
461     // Eden, from, to
462     eden_from_to_order = true;
463     log_trace(gc, ergo)(&quot;  Eden, from, to:&quot;);
464 
465     // Set eden
466     // &quot;requested_eden_size&quot; is a goal for the size of eden
467     // and may not be attainable.  &quot;eden_size&quot; below is
468     // calculated based on the location of from-space and
469     // the goal for the size of eden.  from-space is
470     // fixed in place because it contains live data.
471     // The calculation is done this way to avoid 32bit
472     // overflow (i.e., eden_start + requested_eden_size
473     // may too large for representation in 32bits).
474     size_t eden_size;
475     if (maintain_minimum) {
476       // Only make eden larger than the requested size if
477       // the minimum size of the generation has to be maintained.
478       // This could be done in general but policy at a higher
479       // level is determining a requested size for eden and that
480       // should be honored unless there is a fundamental reason.
481       eden_size = pointer_delta(from_start,
482                                 eden_start,
483                                 sizeof(char));
484     } else {
485       eden_size = MIN2(requested_eden_size,
486                        pointer_delta(from_start, eden_start, sizeof(char)));
487     }
488 
489     eden_end = eden_start + eden_size;
490     assert(eden_end &gt;= eden_start, &quot;addition overflowed&quot;);
491 
492     // To may resize into from space as long as it is clear of live data.
493     // From space must remain page aligned, though, so we need to do some
494     // extra calculations.
495 
496     // First calculate an optimal to-space
497     to_end   = (char*)virtual_space()-&gt;high();
498     to_start = (char*)pointer_delta(to_end, (char*)requested_survivor_size,
499                                     sizeof(char));
500 
501     // Does the optimal to-space overlap from-space?
502     if (to_start &lt; (char*)from_space()-&gt;end()) {
503       // Calculate the minimum offset possible for from_end
504       size_t from_size = pointer_delta(from_space()-&gt;top(), from_start, sizeof(char));
505 
506       // Should we be in this method if from_space is empty? Why not the set_space method? FIX ME!
507       if (from_size == 0) {
508         from_size = SpaceAlignment;
509       } else {
510         from_size = align_up(from_size, SpaceAlignment);
511       }
512 
513       from_end = from_start + from_size;
514       assert(from_end &gt; from_start, &quot;addition overflow or from_size problem&quot;);
515 
516       guarantee(from_end &lt;= (char*)from_space()-&gt;end(), &quot;from_end moved to the right&quot;);
517 
518       // Now update to_start with the new from_end
519       to_start = MAX2(from_end, to_start);
520     }
521 
522     guarantee(to_start != to_end, &quot;to space is zero sized&quot;);
523 
524     log_trace(gc, ergo)(&quot;    [eden_start .. eden_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
525                         p2i(eden_start),
526                         p2i(eden_end),
527                         pointer_delta(eden_end, eden_start, sizeof(char)));
528     log_trace(gc, ergo)(&quot;    [from_start .. from_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
529                         p2i(from_start),
530                         p2i(from_end),
531                         pointer_delta(from_end, from_start, sizeof(char)));
532     log_trace(gc, ergo)(&quot;    [  to_start ..   to_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
533                         p2i(to_start),
534                         p2i(to_end),
535                         pointer_delta(  to_end,   to_start, sizeof(char)));
536   } else {
537     // Eden, to, from
538     log_trace(gc, ergo)(&quot;  Eden, to, from:&quot;);
539 
540     // To space gets priority over eden resizing. Note that we position
541     // to space as if we were able to resize from space, even though from
542     // space is not modified.
543     // Giving eden priority was tried and gave poorer performance.
544     to_end   = (char*)pointer_delta(virtual_space()-&gt;high(),
545                                     (char*)requested_survivor_size,
546                                     sizeof(char));
547     to_end   = MIN2(to_end, from_start);
548     to_start = (char*)pointer_delta(to_end, (char*)requested_survivor_size,
549                                     sizeof(char));
550     // if the space sizes are to be increased by several times then
551     // &#39;to_start&#39; will point beyond the young generation. In this case
552     // &#39;to_start&#39; should be adjusted.
553     to_start = MAX2(to_start, eden_start + SpaceAlignment);
554 
555     // Compute how big eden can be, then adjust end.
556     // See  comments above on calculating eden_end.
557     size_t eden_size;
558     if (maintain_minimum) {
559       eden_size = pointer_delta(to_start, eden_start, sizeof(char));
560     } else {
561       eden_size = MIN2(requested_eden_size,
562                        pointer_delta(to_start, eden_start, sizeof(char)));
563     }
564     eden_end = eden_start + eden_size;
565     assert(eden_end &gt;= eden_start, &quot;addition overflowed&quot;);
566 
567     // Could choose to not let eden shrink
568     // to_start = MAX2(to_start, eden_end);
569 
570     // Don&#39;t let eden shrink down to 0 or less.
571     eden_end = MAX2(eden_end, eden_start + SpaceAlignment);
572     to_start = MAX2(to_start, eden_end);
573 
574     log_trace(gc, ergo)(&quot;    [eden_start .. eden_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
575                         p2i(eden_start),
576                         p2i(eden_end),
577                         pointer_delta(eden_end, eden_start, sizeof(char)));
578     log_trace(gc, ergo)(&quot;    [  to_start ..   to_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
579                         p2i(to_start),
580                         p2i(to_end),
581                         pointer_delta(  to_end,   to_start, sizeof(char)));
582     log_trace(gc, ergo)(&quot;    [from_start .. from_end): [&quot; PTR_FORMAT &quot; .. &quot; PTR_FORMAT &quot;) &quot; SIZE_FORMAT,
583                         p2i(from_start),
584                         p2i(from_end),
585                         pointer_delta(from_end, from_start, sizeof(char)));
586   }
587 
588 
589   guarantee((HeapWord*)from_start &lt;= from_space()-&gt;bottom(),
590             &quot;from start moved to the right&quot;);
591   guarantee((HeapWord*)from_end &gt;= from_space()-&gt;top(),
592             &quot;from end moved into live data&quot;);
593   assert(is_object_aligned(eden_start), &quot;checking alignment&quot;);
594   assert(is_object_aligned(from_start), &quot;checking alignment&quot;);
595   assert(is_object_aligned(to_start), &quot;checking alignment&quot;);
596 
597   MemRegion edenMR((HeapWord*)eden_start, (HeapWord*)eden_end);
598   MemRegion toMR  ((HeapWord*)to_start,   (HeapWord*)to_end);
599   MemRegion fromMR((HeapWord*)from_start, (HeapWord*)from_end);
600 
601   // Let&#39;s make sure the call to initialize doesn&#39;t reset &quot;top&quot;!
602   HeapWord* old_from_top = from_space()-&gt;top();
603 
604   // For logging block  below
605   size_t old_from = from_space()-&gt;capacity_in_bytes();
606   size_t old_to   = to_space()-&gt;capacity_in_bytes();
607 
608   if (ZapUnusedHeapArea) {
609     // NUMA is a special case because a numa space is not mangled
610     // in order to not prematurely bind its address to memory to
611     // the wrong memory (i.e., don&#39;t want the GC thread to first
612     // touch the memory).  The survivor spaces are not numa
613     // spaces and are mangled.
614     if (UseNUMA) {
615       if (eden_from_to_order) {
616         mangle_survivors(from_space(), fromMR, to_space(), toMR);
617       } else {
618         mangle_survivors(to_space(), toMR, from_space(), fromMR);
619       }
620     }
621 
622     // If not mangling the spaces, do some checking to verify that
623     // the spaces are already mangled.
624     // The spaces should be correctly mangled at this point so
625     // do some checking here. Note that they are not being mangled
626     // in the calls to initialize().
627     // Must check mangling before the spaces are reshaped.  Otherwise,
628     // the bottom or end of one space may have moved into an area
629     // covered by another space and a failure of the check may
630     // not correctly indicate which space is not properly mangled.
631     HeapWord* limit = (HeapWord*) virtual_space()-&gt;high();
632     eden_space()-&gt;check_mangled_unused_area(limit);
633     from_space()-&gt;check_mangled_unused_area(limit);
634       to_space()-&gt;check_mangled_unused_area(limit);
635   }
636   // When an existing space is being initialized, it is not
637   // mangled because the space has been previously mangled.
638   eden_space()-&gt;initialize(edenMR,
639                            SpaceDecorator::Clear,
640                            SpaceDecorator::DontMangle);
641     to_space()-&gt;initialize(toMR,
642                            SpaceDecorator::Clear,
643                            SpaceDecorator::DontMangle);
644   from_space()-&gt;initialize(fromMR,
645                            SpaceDecorator::DontClear,
646                            SpaceDecorator::DontMangle);
647 
648   assert(from_space()-&gt;top() == old_from_top, &quot;from top changed!&quot;);
649 
650   log_trace(gc, ergo)(&quot;AdaptiveSizePolicy::survivor space sizes: collection: %d (&quot; SIZE_FORMAT &quot;, &quot; SIZE_FORMAT &quot;) -&gt; (&quot; SIZE_FORMAT &quot;, &quot; SIZE_FORMAT &quot;) &quot;,
651                       ParallelScavengeHeap::heap()-&gt;total_collections(),
652                       old_from, old_to,
653                       from_space()-&gt;capacity_in_bytes(),
654                       to_space()-&gt;capacity_in_bytes());
655 }
656 
657 void PSYoungGen::swap_spaces() {
658   MutableSpace* s    = from_space();
659   _from_space        = to_space();
660   _to_space          = s;
661 }
662 
663 size_t PSYoungGen::capacity_in_bytes() const {
664   return eden_space()-&gt;capacity_in_bytes()
665        + from_space()-&gt;capacity_in_bytes();  // to_space() is only used during scavenge
666 }
667 
668 
669 size_t PSYoungGen::used_in_bytes() const {
670   return eden_space()-&gt;used_in_bytes()
671        + from_space()-&gt;used_in_bytes();      // to_space() is only used during scavenge
672 }
673 
674 
675 size_t PSYoungGen::free_in_bytes() const {
676   return eden_space()-&gt;free_in_bytes()
677        + from_space()-&gt;free_in_bytes();      // to_space() is only used during scavenge
678 }
679 
680 size_t PSYoungGen::capacity_in_words() const {
681   return eden_space()-&gt;capacity_in_words()
682        + from_space()-&gt;capacity_in_words();  // to_space() is only used during scavenge
683 }
684 
685 
686 size_t PSYoungGen::used_in_words() const {
687   return eden_space()-&gt;used_in_words()
688        + from_space()-&gt;used_in_words();      // to_space() is only used during scavenge
689 }
690 
691 
692 size_t PSYoungGen::free_in_words() const {
693   return eden_space()-&gt;free_in_words()
694        + from_space()-&gt;free_in_words();      // to_space() is only used during scavenge
695 }
696 
697 void PSYoungGen::object_iterate(ObjectClosure* blk) {
698   eden_space()-&gt;object_iterate(blk);
699   from_space()-&gt;object_iterate(blk);
700   to_space()-&gt;object_iterate(blk);
701 }
702 
703 void PSYoungGen::print() const { print_on(tty); }
704 void PSYoungGen::print_on(outputStream* st) const {
705   st-&gt;print(&quot; %-15s&quot;, &quot;PSYoungGen&quot;);
706   st-&gt;print(&quot; total &quot; SIZE_FORMAT &quot;K, used &quot; SIZE_FORMAT &quot;K&quot;,
707              capacity_in_bytes()/K, used_in_bytes()/K);
708   virtual_space()-&gt;print_space_boundaries_on(st);
709   st-&gt;print(&quot;  eden&quot;); eden_space()-&gt;print_on(st);
710   st-&gt;print(&quot;  from&quot;); from_space()-&gt;print_on(st);
711   st-&gt;print(&quot;  to  &quot;); to_space()-&gt;print_on(st);
712 }
713 
714 size_t PSYoungGen::available_for_expansion() {
715   ShouldNotReachHere();
716   return 0;
717 }
718 
719 size_t PSYoungGen::available_for_contraction() {
720   ShouldNotReachHere();
721   return 0;
722 }
723 
724 size_t PSYoungGen::available_to_min_gen() {
725   assert(virtual_space()-&gt;committed_size() &gt;= min_gen_size(), &quot;Invariant&quot;);
726   return virtual_space()-&gt;committed_size() - min_gen_size();
727 }
728 
729 // This method assumes that from-space has live data and that
730 // any shrinkage of the young gen is limited by location of
731 // from-space.
732 size_t PSYoungGen::available_to_live() {
733   size_t delta_in_survivor = 0;
734   MutableSpace* space_shrinking = NULL;
735   if (from_space()-&gt;end() &gt; to_space()-&gt;end()) {
736     space_shrinking = from_space();
737   } else {
738     space_shrinking = to_space();
739   }
740 
741   // Include any space that is committed but not included in
742   // the survivor spaces.
743   assert(((HeapWord*)virtual_space()-&gt;high()) &gt;= space_shrinking-&gt;end(),
744     &quot;Survivor space beyond high end&quot;);
745   size_t unused_committed = pointer_delta(virtual_space()-&gt;high(),
746     space_shrinking-&gt;end(), sizeof(char));
747 
748   if (space_shrinking-&gt;is_empty()) {
749     // Don&#39;t let the space shrink to 0
750     assert(space_shrinking-&gt;capacity_in_bytes() &gt;= SpaceAlignment,
751       &quot;Space is too small&quot;);
752     delta_in_survivor = space_shrinking-&gt;capacity_in_bytes() - SpaceAlignment;
753   } else {
754     delta_in_survivor = pointer_delta(space_shrinking-&gt;end(),
755                                       space_shrinking-&gt;top(),
756                                       sizeof(char));
757   }
758 
759   size_t delta_in_bytes = unused_committed + delta_in_survivor;
760   delta_in_bytes = align_down(delta_in_bytes, GenAlignment);
761   return delta_in_bytes;
762 }
763 
764 // Return the number of bytes available for resizing down the young
765 // generation.  This is the minimum of
766 //      input &quot;bytes&quot;
767 //      bytes to the minimum young gen size
768 //      bytes to the size currently being used + some small extra
769 size_t PSYoungGen::limit_gen_shrink(size_t bytes) {
770   // Allow shrinkage into the current eden but keep eden large enough
771   // to maintain the minimum young gen size
772   bytes = MIN3(bytes, available_to_min_gen(), available_to_live());
773   return align_down(bytes, virtual_space()-&gt;alignment());
774 }
775 
776 void PSYoungGen::reset_after_change() {
777   ShouldNotReachHere();
778 }
779 
780 void PSYoungGen::reset_survivors_after_shrink() {
781   _reserved = MemRegion((HeapWord*)virtual_space()-&gt;low_boundary(),
782                         (HeapWord*)virtual_space()-&gt;high_boundary());
783   PSScavenge::set_subject_to_discovery_span(_reserved);
784 
785   MutableSpace* space_shrinking = NULL;
786   if (from_space()-&gt;end() &gt; to_space()-&gt;end()) {
787     space_shrinking = from_space();
788   } else {
789     space_shrinking = to_space();
790   }
791 
792   HeapWord* new_end = (HeapWord*)virtual_space()-&gt;high();
793   assert(new_end &gt;= space_shrinking-&gt;bottom(), &quot;Shrink was too large&quot;);
794   // Was there a shrink of the survivor space?
795   if (new_end &lt; space_shrinking-&gt;end()) {
796     MemRegion mr(space_shrinking-&gt;bottom(), new_end);
797     space_shrinking-&gt;initialize(mr,
798                                 SpaceDecorator::DontClear,
799                                 SpaceDecorator::Mangle);
800   }
801 }
802 
803 // This method currently does not expect to expand into eden (i.e.,
804 // the virtual space boundaries is expected to be consistent
805 // with the eden boundaries..
806 void PSYoungGen::post_resize() {
807   assert_locked_or_safepoint(Heap_lock);
808   assert((eden_space()-&gt;bottom() &lt; to_space()-&gt;bottom()) &amp;&amp;
809          (eden_space()-&gt;bottom() &lt; from_space()-&gt;bottom()),
810          &quot;Eden is assumed to be below the survivor spaces&quot;);
811 
812   MemRegion cmr((HeapWord*)virtual_space()-&gt;low(),
813                 (HeapWord*)virtual_space()-&gt;high());
814   ParallelScavengeHeap::heap()-&gt;card_table()-&gt;resize_covered_region(cmr);
815   space_invariants();
816 }
817 
818 
819 
820 void PSYoungGen::update_counters() {
821   if (UsePerfData) {
822     _eden_counters-&gt;update_all();
823     _from_counters-&gt;update_all();
824     _to_counters-&gt;update_all();
825     _gen_counters-&gt;update_all();
826   }
827 }
828 
829 void PSYoungGen::verify() {
830   eden_space()-&gt;verify();
831   from_space()-&gt;verify();
832   to_space()-&gt;verify();
833 }
834 
835 #ifndef PRODUCT
836 void PSYoungGen::record_spaces_top() {
837   assert(ZapUnusedHeapArea, &quot;Not mangling unused space&quot;);
838   eden_space()-&gt;set_top_for_allocations();
839   from_space()-&gt;set_top_for_allocations();
840   to_space()-&gt;set_top_for_allocations();
841 }
842 #endif
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
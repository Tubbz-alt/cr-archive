<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shenandoah/shenandoahConcurrentMark.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2013, 2020, Red Hat, Inc. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 
 27 #include &quot;classfile/symbolTable.hpp&quot;
 28 #include &quot;classfile/systemDictionary.hpp&quot;
 29 #include &quot;code/codeCache.hpp&quot;
 30 
 31 #include &quot;gc/shared/weakProcessor.inline.hpp&quot;
 32 #include &quot;gc/shared/gcTimer.hpp&quot;
 33 #include &quot;gc/shared/referenceProcessor.hpp&quot;
 34 #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
 35 #include &quot;gc/shared/strongRootsScope.hpp&quot;
 36 
 37 #include &quot;gc/shenandoah/shenandoahBarrierSet.inline.hpp&quot;
 38 #include &quot;gc/shenandoah/shenandoahClosures.inline.hpp&quot;
 39 #include &quot;gc/shenandoah/shenandoahConcurrentMark.inline.hpp&quot;
 40 #include &quot;gc/shenandoah/shenandoahMarkCompact.hpp&quot;
 41 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 42 #include &quot;gc/shenandoah/shenandoahRootProcessor.inline.hpp&quot;
 43 #include &quot;gc/shenandoah/shenandoahOopClosures.inline.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added"> 44 #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;</span>
 45 #include &quot;gc/shenandoah/shenandoahTaskqueue.inline.hpp&quot;
<a name="2" id="anc2"></a>
 46 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
 47 
 48 #include &quot;memory/iterator.inline.hpp&quot;
 49 #include &quot;memory/metaspace.hpp&quot;
 50 #include &quot;memory/resourceArea.hpp&quot;
 51 #include &quot;oops/oop.inline.hpp&quot;
 52 #include &quot;runtime/handles.inline.hpp&quot;
 53 
 54 template&lt;UpdateRefsMode UPDATE_REFS&gt;
 55 class ShenandoahInitMarkRootsClosure : public OopClosure {
 56 private:
 57   ShenandoahObjToScanQueue* _queue;
 58   ShenandoahHeap* _heap;
 59   ShenandoahMarkingContext* const _mark_context;
 60 
 61   template &lt;class T&gt;
 62   inline void do_oop_work(T* p) {
 63     ShenandoahConcurrentMark::mark_through_ref&lt;T, UPDATE_REFS, NO_DEDUP&gt;(p, _heap, _queue, _mark_context);
 64   }
 65 
 66 public:
 67   ShenandoahInitMarkRootsClosure(ShenandoahObjToScanQueue* q) :
 68     _queue(q),
 69     _heap(ShenandoahHeap::heap()),
 70     _mark_context(_heap-&gt;marking_context()) {};
 71 
 72   void do_oop(narrowOop* p) { do_oop_work(p); }
 73   void do_oop(oop* p)       { do_oop_work(p); }
 74 };
 75 
 76 ShenandoahMarkRefsSuperClosure::ShenandoahMarkRefsSuperClosure(ShenandoahObjToScanQueue* q, ReferenceProcessor* rp) :
 77   MetadataVisitingOopIterateClosure(rp),
 78   _queue(q),
 79   _heap(ShenandoahHeap::heap()),
 80   _mark_context(_heap-&gt;marking_context())
 81 { }
 82 
 83 template&lt;UpdateRefsMode UPDATE_REFS&gt;
 84 class ShenandoahInitMarkRootsTask : public AbstractGangTask {
 85 private:
 86   ShenandoahAllRootScanner* _rp;
<a name="3" id="anc3"></a>
 87 public:
<a name="4" id="anc4"></a><span class="line-modified"> 88   ShenandoahInitMarkRootsTask(ShenandoahAllRootScanner* rp) :</span>
 89     AbstractGangTask(&quot;Shenandoah init mark roots task&quot;),
<a name="5" id="anc5"></a><span class="line-modified"> 90     _rp(rp) {</span>

 91   }
 92 
 93   void work(uint worker_id) {
 94     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
 95     ShenandoahParallelWorkerSession worker_session(worker_id);
 96 
 97     ShenandoahHeap* heap = ShenandoahHeap::heap();
 98     ShenandoahObjToScanQueueSet* queues = heap-&gt;concurrent_mark()-&gt;task_queues();
 99     assert(queues-&gt;get_reserved() &gt; worker_id, &quot;Queue has not been reserved for worker id: %d&quot;, worker_id);
100 
101     ShenandoahObjToScanQueue* q = queues-&gt;queue(worker_id);
102 
103     ShenandoahInitMarkRootsClosure&lt;UPDATE_REFS&gt; mark_cl(q);
104     do_work(heap, &amp;mark_cl, worker_id);
105   }
106 
107 private:
108   void do_work(ShenandoahHeap* heap, OopClosure* oops, uint worker_id) {
109     // The rationale for selecting the roots to scan is as follows:
110     //   a. With unload_classes = true, we only want to scan the actual strong roots from the
111     //      code cache. This will allow us to identify the dead classes, unload them, *and*
112     //      invalidate the relevant code cache blobs. This could be only done together with
113     //      class unloading.
114     //   b. With unload_classes = false, we have to nominally retain all the references from code
115     //      cache, because there could be the case of embedded class/oop in the generated code,
116     //      which we will never visit during mark. Without code cache invalidation, as in (a),
117     //      we risk executing that code cache blob, and crashing.
118     if (heap-&gt;unload_classes()) {
119       _rp-&gt;strong_roots_do(worker_id, oops);
120     } else {
121       _rp-&gt;roots_do(worker_id, oops);
122     }
123   }
124 };
125 
126 class ShenandoahUpdateRootsTask : public AbstractGangTask {
127 private:
128   ShenandoahRootUpdater*  _root_updater;
129   bool                    _check_alive;
130 public:
131   ShenandoahUpdateRootsTask(ShenandoahRootUpdater* root_updater, bool check_alive) :
132     AbstractGangTask(&quot;Shenandoah update roots task&quot;),
133     _root_updater(root_updater),
134     _check_alive(check_alive){
135   }
136 
137   void work(uint worker_id) {
138     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
139     ShenandoahParallelWorkerSession worker_session(worker_id);
140 
141     ShenandoahHeap* heap = ShenandoahHeap::heap();
142     ShenandoahUpdateRefsClosure cl;
143     if (_check_alive) {
144       ShenandoahForwardedIsAliveClosure is_alive;
145       _root_updater-&gt;roots_do&lt;ShenandoahForwardedIsAliveClosure, ShenandoahUpdateRefsClosure&gt;(worker_id, &amp;is_alive, &amp;cl);
146     } else {
147       AlwaysTrueClosure always_true;;
148       _root_updater-&gt;roots_do&lt;AlwaysTrueClosure, ShenandoahUpdateRefsClosure&gt;(worker_id, &amp;always_true, &amp;cl);
149     }
150   }
151 };
152 
153 class ShenandoahConcurrentMarkingTask : public AbstractGangTask {
154 private:
155   ShenandoahConcurrentMark* _cm;
156   TaskTerminator* _terminator;
157 
158 public:
159   ShenandoahConcurrentMarkingTask(ShenandoahConcurrentMark* cm, TaskTerminator* terminator) :
160     AbstractGangTask(&quot;Root Region Scan&quot;), _cm(cm), _terminator(terminator) {
161   }
162 
163   void work(uint worker_id) {
164     ShenandoahHeap* heap = ShenandoahHeap::heap();
165     ShenandoahConcurrentWorkerSession worker_session(worker_id);
166     ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);
167     ShenandoahObjToScanQueue* q = _cm-&gt;get_queue(worker_id);
168     ReferenceProcessor* rp;
169     if (heap-&gt;process_references()) {
170       rp = heap-&gt;ref_processor();
171       shenandoah_assert_rp_isalive_installed();
172     } else {
173       rp = NULL;
174     }
175 
176     _cm-&gt;concurrent_scan_code_roots(worker_id, rp);
177     _cm-&gt;mark_loop(worker_id, _terminator, rp,
178                    true, // cancellable
179                    ShenandoahStringDedup::is_enabled()); // perform string dedup
180   }
181 };
182 
<a name="6" id="anc6"></a><span class="line-modified">183 class ShenandoahSATBAndRemarkCodeRootsThreadsClosure : public ThreadClosure {</span>
184 private:
185   ShenandoahSATBBufferClosure* _satb_cl;
<a name="7" id="anc7"></a><span class="line-added">186   MarkingCodeBlobClosure*      _code_cl;</span>
187   uintx _claim_token;
188 
189 public:
<a name="8" id="anc8"></a><span class="line-modified">190   ShenandoahSATBAndRemarkCodeRootsThreadsClosure(ShenandoahSATBBufferClosure* satb_cl, MarkingCodeBlobClosure* code_cl) :</span>
<span class="line-modified">191     _satb_cl(satb_cl), _code_cl(code_cl),</span>
192     _claim_token(Threads::thread_claim_token()) {}
193 
194   void do_thread(Thread* thread) {
195     if (thread-&gt;claim_threads_do(true, _claim_token)) {
196       ShenandoahThreadLocalData::satb_mark_queue(thread).apply_closure_and_empty(_satb_cl);
<a name="9" id="anc9"></a><span class="line-added">197       if (_code_cl != NULL &amp;&amp; thread-&gt;is_Java_thread()) {</span>
<span class="line-added">198         // In theory it should not be neccessary to explicitly walk the nmethods to find roots for concurrent marking</span>
<span class="line-added">199         // however the liveness of oops reachable from nmethods have very complex lifecycles:</span>
<span class="line-added">200         // * Alive if on the stack of an executing method</span>
<span class="line-added">201         // * Weakly reachable otherwise</span>
<span class="line-added">202         // Some objects reachable from nmethods, such as the class loader (or klass_holder) of the receiver should be</span>
<span class="line-added">203         // live by the SATB invariant but other oops recorded in nmethods may behave differently.</span>
<span class="line-added">204         JavaThread* jt = (JavaThread*)thread;</span>
<span class="line-added">205         jt-&gt;nmethods_do(_code_cl);</span>
<span class="line-added">206       }</span>
207     }
208   }
209 };
210 
211 class ShenandoahFinalMarkingTask : public AbstractGangTask {
212 private:
213   ShenandoahConcurrentMark* _cm;
214   TaskTerminator*           _terminator;
215   bool _dedup_string;
216 
217 public:
218   ShenandoahFinalMarkingTask(ShenandoahConcurrentMark* cm, TaskTerminator* terminator, bool dedup_string) :
219     AbstractGangTask(&quot;Shenandoah Final Marking&quot;), _cm(cm), _terminator(terminator), _dedup_string(dedup_string) {
220   }
221 
222   void work(uint worker_id) {
223     ShenandoahHeap* heap = ShenandoahHeap::heap();
224 
225     ShenandoahParallelWorkerSession worker_session(worker_id);
<a name="10" id="anc10"></a><span class="line-added">226     ReferenceProcessor* rp;</span>
<span class="line-added">227     if (heap-&gt;process_references()) {</span>
<span class="line-added">228       rp = heap-&gt;ref_processor();</span>
<span class="line-added">229       shenandoah_assert_rp_isalive_installed();</span>
<span class="line-added">230     } else {</span>
<span class="line-added">231       rp = NULL;</span>
<span class="line-added">232     }</span>
<span class="line-added">233 </span>
234     // First drain remaining SATB buffers.
235     // Notice that this is not strictly necessary for mark-compact. But since
236     // it requires a StrongRootsScope around the task, we need to claim the
237     // threads, and performance-wise it doesn&#39;t really matter. Adds about 1ms to
238     // full-gc.
239     {
240       ShenandoahObjToScanQueue* q = _cm-&gt;get_queue(worker_id);
<a name="11" id="anc11"></a><span class="line-added">241 </span>
242       ShenandoahSATBBufferClosure cl(q);
243       SATBMarkQueueSet&amp; satb_mq_set = ShenandoahBarrierSet::satb_mark_queue_set();
244       while (satb_mq_set.apply_closure_to_completed_buffer(&amp;cl));
<a name="12" id="anc12"></a>


245 
<a name="13" id="anc13"></a><span class="line-modified">246       if (heap-&gt;unload_classes() &amp;&amp; !ShenandoahConcurrentRoots::can_do_concurrent_class_unloading()) {</span>
<span class="line-modified">247         if (heap-&gt;has_forwarded_objects()) {</span>
<span class="line-modified">248           ShenandoahMarkResolveRefsClosure resolve_mark_cl(q, rp);</span>
<span class="line-modified">249           MarkingCodeBlobClosure blobsCl(&amp;resolve_mark_cl, !CodeBlobToOopClosure::FixRelocations);</span>
<span class="line-modified">250           ShenandoahSATBAndRemarkCodeRootsThreadsClosure tc(&amp;cl, &amp;blobsCl);</span>
<span class="line-modified">251           Threads::threads_do(&amp;tc);</span>
<span class="line-added">252         } else {</span>
<span class="line-added">253           ShenandoahMarkRefsClosure mark_cl(q, rp);</span>
<span class="line-added">254           MarkingCodeBlobClosure blobsCl(&amp;mark_cl, !CodeBlobToOopClosure::FixRelocations);</span>
<span class="line-added">255           ShenandoahSATBAndRemarkCodeRootsThreadsClosure tc(&amp;cl, &amp;blobsCl);</span>
<span class="line-added">256           Threads::threads_do(&amp;tc);</span>
<span class="line-added">257         }</span>
<span class="line-added">258       } else {</span>
<span class="line-added">259         ShenandoahSATBAndRemarkCodeRootsThreadsClosure tc(&amp;cl, NULL);</span>
<span class="line-added">260         Threads::threads_do(&amp;tc);</span>
<span class="line-added">261       }</span>
262     }
263 
264     if (heap-&gt;is_degenerated_gc_in_progress()) {
265       // Degenerated cycle may bypass concurrent cycle, so code roots might not be scanned,
266       // let&#39;s check here.
267       _cm-&gt;concurrent_scan_code_roots(worker_id, rp);
268     }
269 
270     _cm-&gt;mark_loop(worker_id, _terminator, rp,
271                    false, // not cancellable
272                    _dedup_string);
273 
274     assert(_cm-&gt;task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
275   }
276 };
277 
278 void ShenandoahConcurrentMark::mark_roots(ShenandoahPhaseTimings::Phase root_phase) {
279   assert(Thread::current()-&gt;is_VM_thread(), &quot;can only do this in VMThread&quot;);
280   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
281 
282   ShenandoahHeap* heap = ShenandoahHeap::heap();
283 
284   ShenandoahGCPhase phase(root_phase);
285 
286   WorkGang* workers = heap-&gt;workers();
287   uint nworkers = workers-&gt;active_workers();
288 
289   assert(nworkers &lt;= task_queues()-&gt;size(), &quot;Just check&quot;);
290 
291   ShenandoahAllRootScanner root_proc(nworkers, root_phase);
292   TASKQUEUE_STATS_ONLY(task_queues()-&gt;reset_taskqueue_stats());
293   task_queues()-&gt;reserve(nworkers);
294 
295   if (heap-&gt;has_forwarded_objects()) {
<a name="14" id="anc14"></a><span class="line-modified">296     ShenandoahInitMarkRootsTask&lt;RESOLVE&gt; mark_roots(&amp;root_proc);</span>
297     workers-&gt;run_task(&amp;mark_roots);
298   } else {
299     // No need to update references, which means the heap is stable.
300     // Can save time not walking through forwarding pointers.
<a name="15" id="anc15"></a><span class="line-modified">301     ShenandoahInitMarkRootsTask&lt;NONE&gt; mark_roots(&amp;root_proc);</span>
302     workers-&gt;run_task(&amp;mark_roots);
303   }
304 
305   if (ShenandoahConcurrentScanCodeRoots) {
306     clear_claim_codecache();
307   }
308 }
309 
310 void ShenandoahConcurrentMark::update_roots(ShenandoahPhaseTimings::Phase root_phase) {
311   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
312   assert(root_phase == ShenandoahPhaseTimings::full_gc_roots ||
313          root_phase == ShenandoahPhaseTimings::degen_gc_update_roots,
314          &quot;Only for these phases&quot;);
315 
316   ShenandoahGCPhase phase(root_phase);
317 
318   bool check_alive = root_phase == ShenandoahPhaseTimings::degen_gc_update_roots;
319 
320 #if COMPILER2_OR_JVMCI
321   DerivedPointerTable::clear();
322 #endif
323 
324   uint nworkers = _heap-&gt;workers()-&gt;active_workers();
325 
326   ShenandoahRootUpdater root_updater(nworkers, root_phase);
327   ShenandoahUpdateRootsTask update_roots(&amp;root_updater, check_alive);
328   _heap-&gt;workers()-&gt;run_task(&amp;update_roots);
329 
330 #if COMPILER2_OR_JVMCI
331   DerivedPointerTable::update_pointers();
332 #endif
333 }
334 
335 class ShenandoahUpdateThreadRootsTask : public AbstractGangTask {
336 private:
337   ShenandoahThreadRoots           _thread_roots;
338   ShenandoahPhaseTimings::Phase   _phase;
<a name="16" id="anc16"></a><span class="line-added">339   ShenandoahGCWorkerPhase         _worker_phase;</span>
340 public:
341   ShenandoahUpdateThreadRootsTask(bool is_par, ShenandoahPhaseTimings::Phase phase) :
342     AbstractGangTask(&quot;Shenandoah Update Thread Roots&quot;),
343     _thread_roots(is_par),
<a name="17" id="anc17"></a><span class="line-modified">344     _phase(phase),</span>
<span class="line-modified">345     _worker_phase(phase) {}</span>

346 
<a name="18" id="anc18"></a>


347   void work(uint worker_id) {
348     ShenandoahUpdateRefsClosure cl;
349     _thread_roots.oops_do(&amp;cl, NULL, worker_id);
350   }
351 };
352 
353 void ShenandoahConcurrentMark::update_thread_roots(ShenandoahPhaseTimings::Phase root_phase) {
354   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
355 
356   ShenandoahGCPhase phase(root_phase);
357 
358 #if COMPILER2_OR_JVMCI
359   DerivedPointerTable::clear();
360 #endif
361 
362   WorkGang* workers = _heap-&gt;workers();
363   bool is_par = workers-&gt;active_workers() &gt; 1;
364 
365   ShenandoahUpdateThreadRootsTask task(is_par, root_phase);
366   workers-&gt;run_task(&amp;task);
367 
368 #if COMPILER2_OR_JVMCI
369   DerivedPointerTable::update_pointers();
370 #endif
371 }
372 
373 void ShenandoahConcurrentMark::initialize(uint workers) {
374   _heap = ShenandoahHeap::heap();
375 
376   uint num_queues = MAX2(workers, 1U);
377 
378   _task_queues = new ShenandoahObjToScanQueueSet((int) num_queues);
379 
380   for (uint i = 0; i &lt; num_queues; ++i) {
381     ShenandoahObjToScanQueue* task_queue = new ShenandoahObjToScanQueue();
382     task_queue-&gt;initialize();
383     _task_queues-&gt;register_queue(i, task_queue);
384   }
385 }
386 
387 void ShenandoahConcurrentMark::concurrent_scan_code_roots(uint worker_id, ReferenceProcessor* rp) {
388   if (ShenandoahConcurrentScanCodeRoots &amp;&amp; claim_codecache()) {
389     ShenandoahObjToScanQueue* q = task_queues()-&gt;queue(worker_id);
390     if (!_heap-&gt;unload_classes()) {
391       MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
392       // TODO: We can not honor StringDeduplication here, due to lock ranking
393       // inversion. So, we may miss some deduplication candidates.
394       if (_heap-&gt;has_forwarded_objects()) {
395         ShenandoahMarkResolveRefsClosure cl(q, rp);
396         CodeBlobToOopClosure blobs(&amp;cl, !CodeBlobToOopClosure::FixRelocations);
397         CodeCache::blobs_do(&amp;blobs);
398       } else {
399         ShenandoahMarkRefsClosure cl(q, rp);
400         CodeBlobToOopClosure blobs(&amp;cl, !CodeBlobToOopClosure::FixRelocations);
401         CodeCache::blobs_do(&amp;blobs);
402       }
403     }
404   }
405 }
406 
407 void ShenandoahConcurrentMark::mark_from_roots() {
408   WorkGang* workers = _heap-&gt;workers();
409   uint nworkers = workers-&gt;active_workers();
410 
411   ShenandoahGCPhase conc_mark_phase(ShenandoahPhaseTimings::conc_mark);
412 
413   if (_heap-&gt;process_references()) {
414     ReferenceProcessor* rp = _heap-&gt;ref_processor();
415     rp-&gt;set_active_mt_degree(nworkers);
416 
417     // enable (&quot;weak&quot;) refs discovery
418     rp-&gt;enable_discovery(true /*verify_no_refs*/);
419     rp-&gt;setup_policy(_heap-&gt;soft_ref_policy()-&gt;should_clear_all_soft_refs());
420   }
421 
422   shenandoah_assert_rp_isalive_not_installed();
423   ShenandoahIsAliveSelector is_alive;
424   ReferenceProcessorIsAliveMutator fix_isalive(_heap-&gt;ref_processor(), is_alive.is_alive_closure());
425 
426   task_queues()-&gt;reserve(nworkers);
427 
428   {
<a name="19" id="anc19"></a>
429     TaskTerminator terminator(nworkers, task_queues());
430     ShenandoahConcurrentMarkingTask task(this, &amp;terminator);
431     workers-&gt;run_task(&amp;task);
432   }
433 
434   assert(task_queues()-&gt;is_empty() || _heap-&gt;cancelled_gc(), &quot;Should be empty when not cancelled&quot;);
435 }
436 
437 void ShenandoahConcurrentMark::finish_mark_from_roots(bool full_gc) {
438   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
439 
440   uint nworkers = _heap-&gt;workers()-&gt;active_workers();
441 
442   // Finally mark everything else we&#39;ve got in our queues during the previous steps.
443   // It does two different things for concurrent vs. mark-compact GC:
444   // - For concurrent GC, it starts with empty task queues, drains the remaining
445   //   SATB buffers, and then completes the marking closure.
446   // - For mark-compact GC, it starts out with the task queues seeded by initial
447   //   root scan, and completes the closure, thus marking through all live objects
448   // The implementation is the same, so it&#39;s shared here.
449   {
450     ShenandoahGCPhase phase(full_gc ?
451                             ShenandoahPhaseTimings::full_gc_mark_finish_queues :
452                             ShenandoahPhaseTimings::finish_queues);
453     task_queues()-&gt;reserve(nworkers);
454 
455     shenandoah_assert_rp_isalive_not_installed();
456     ShenandoahIsAliveSelector is_alive;
457     ReferenceProcessorIsAliveMutator fix_isalive(_heap-&gt;ref_processor(), is_alive.is_alive_closure());
458 
<a name="20" id="anc20"></a>



459     StrongRootsScope scope(nworkers);
460     TaskTerminator terminator(nworkers, task_queues());
461     ShenandoahFinalMarkingTask task(this, &amp;terminator, ShenandoahStringDedup::is_enabled());
462     _heap-&gt;workers()-&gt;run_task(&amp;task);
463   }
464 
465   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
466 
467   // When we&#39;re done marking everything, we process weak references.
468   if (_heap-&gt;process_references()) {
469     weak_refs_work(full_gc);
470   }
471 
472   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
473   TASKQUEUE_STATS_ONLY(task_queues()-&gt;print_taskqueue_stats());
474   TASKQUEUE_STATS_ONLY(task_queues()-&gt;reset_taskqueue_stats());
475 }
476 
477 // Weak Reference Closures
478 class ShenandoahCMDrainMarkingStackClosure: public VoidClosure {
479   uint _worker_id;
480   TaskTerminator* _terminator;
481   bool _reset_terminator;
482 
483 public:
484   ShenandoahCMDrainMarkingStackClosure(uint worker_id, TaskTerminator* t, bool reset_terminator = false):
485     _worker_id(worker_id),
486     _terminator(t),
487     _reset_terminator(reset_terminator) {
488   }
489 
490   void do_void() {
491     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
492 
493     ShenandoahHeap* sh = ShenandoahHeap::heap();
494     ShenandoahConcurrentMark* scm = sh-&gt;concurrent_mark();
495     assert(sh-&gt;process_references(), &quot;why else would we be here?&quot;);
496     ReferenceProcessor* rp = sh-&gt;ref_processor();
497 
498     shenandoah_assert_rp_isalive_installed();
499 
500     scm-&gt;mark_loop(_worker_id, _terminator, rp,
501                    false,   // not cancellable
502                    false);  // do not do strdedup
503 
504     if (_reset_terminator) {
505       _terminator-&gt;reset_for_reuse();
506     }
507   }
508 };
509 
510 class ShenandoahCMKeepAliveClosure : public OopClosure {
511 private:
512   ShenandoahObjToScanQueue* _queue;
513   ShenandoahHeap* _heap;
514   ShenandoahMarkingContext* const _mark_context;
515 
516   template &lt;class T&gt;
517   inline void do_oop_work(T* p) {
518     ShenandoahConcurrentMark::mark_through_ref&lt;T, NONE, NO_DEDUP&gt;(p, _heap, _queue, _mark_context);
519   }
520 
521 public:
522   ShenandoahCMKeepAliveClosure(ShenandoahObjToScanQueue* q) :
523     _queue(q),
524     _heap(ShenandoahHeap::heap()),
525     _mark_context(_heap-&gt;marking_context()) {}
526 
527   void do_oop(narrowOop* p) { do_oop_work(p); }
528   void do_oop(oop* p)       { do_oop_work(p); }
529 };
530 
531 class ShenandoahCMKeepAliveUpdateClosure : public OopClosure {
532 private:
533   ShenandoahObjToScanQueue* _queue;
534   ShenandoahHeap* _heap;
535   ShenandoahMarkingContext* const _mark_context;
536 
537   template &lt;class T&gt;
538   inline void do_oop_work(T* p) {
539     ShenandoahConcurrentMark::mark_through_ref&lt;T, SIMPLE, NO_DEDUP&gt;(p, _heap, _queue, _mark_context);
540   }
541 
542 public:
543   ShenandoahCMKeepAliveUpdateClosure(ShenandoahObjToScanQueue* q) :
544     _queue(q),
545     _heap(ShenandoahHeap::heap()),
546     _mark_context(_heap-&gt;marking_context()) {}
547 
548   void do_oop(narrowOop* p) { do_oop_work(p); }
549   void do_oop(oop* p)       { do_oop_work(p); }
550 };
551 
552 class ShenandoahWeakUpdateClosure : public OopClosure {
553 private:
554   ShenandoahHeap* const _heap;
555 
556   template &lt;class T&gt;
557   inline void do_oop_work(T* p) {
558     oop o = _heap-&gt;maybe_update_with_forwarded(p);
559     shenandoah_assert_marked_except(p, o, o == NULL);
560   }
561 
562 public:
563   ShenandoahWeakUpdateClosure() : _heap(ShenandoahHeap::heap()) {}
564 
565   void do_oop(narrowOop* p) { do_oop_work(p); }
566   void do_oop(oop* p)       { do_oop_work(p); }
567 };
568 
569 class ShenandoahRefProcTaskProxy : public AbstractGangTask {
570 private:
571   AbstractRefProcTaskExecutor::ProcessTask&amp; _proc_task;
572   TaskTerminator* _terminator;
573 
574 public:
575   ShenandoahRefProcTaskProxy(AbstractRefProcTaskExecutor::ProcessTask&amp; proc_task,
576                              TaskTerminator* t) :
577     AbstractGangTask(&quot;Process reference objects in parallel&quot;),
578     _proc_task(proc_task),
579     _terminator(t) {
580   }
581 
582   void work(uint worker_id) {
583     ResourceMark rm;
584     HandleMark hm;
585     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
586     ShenandoahHeap* heap = ShenandoahHeap::heap();
587     ShenandoahCMDrainMarkingStackClosure complete_gc(worker_id, _terminator);
588     if (heap-&gt;has_forwarded_objects()) {
589       ShenandoahForwardedIsAliveClosure is_alive;
590       ShenandoahCMKeepAliveUpdateClosure keep_alive(heap-&gt;concurrent_mark()-&gt;get_queue(worker_id));
591       _proc_task.work(worker_id, is_alive, keep_alive, complete_gc);
592     } else {
593       ShenandoahIsAliveClosure is_alive;
594       ShenandoahCMKeepAliveClosure keep_alive(heap-&gt;concurrent_mark()-&gt;get_queue(worker_id));
595       _proc_task.work(worker_id, is_alive, keep_alive, complete_gc);
596     }
597   }
598 };
599 
600 class ShenandoahRefProcTaskExecutor : public AbstractRefProcTaskExecutor {
601 private:
602   WorkGang* _workers;
603 
604 public:
605   ShenandoahRefProcTaskExecutor(WorkGang* workers) :
606     _workers(workers) {
607   }
608 
609   // Executes a task using worker threads.
610   void execute(ProcessTask&amp; task, uint ergo_workers) {
611     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
612 
613     ShenandoahHeap* heap = ShenandoahHeap::heap();
614     ShenandoahConcurrentMark* cm = heap-&gt;concurrent_mark();
615     ShenandoahPushWorkerQueuesScope scope(_workers, cm-&gt;task_queues(),
616                                           ergo_workers,
617                                           /* do_check = */ false);
618     uint nworkers = _workers-&gt;active_workers();
619     cm-&gt;task_queues()-&gt;reserve(nworkers);
620     TaskTerminator terminator(nworkers, cm-&gt;task_queues());
621     ShenandoahRefProcTaskProxy proc_task_proxy(task, &amp;terminator);
622     _workers-&gt;run_task(&amp;proc_task_proxy);
623   }
624 };
625 
626 void ShenandoahConcurrentMark::weak_refs_work(bool full_gc) {
627   assert(_heap-&gt;process_references(), &quot;sanity&quot;);
628 
629   ShenandoahPhaseTimings::Phase phase_root =
630           full_gc ?
631           ShenandoahPhaseTimings::full_gc_weakrefs :
632           ShenandoahPhaseTimings::weakrefs;
633 
634   ShenandoahGCPhase phase(phase_root);
635 
636   ReferenceProcessor* rp = _heap-&gt;ref_processor();
637 
638   // NOTE: We cannot shortcut on has_discovered_references() here, because
639   // we will miss marking JNI Weak refs then, see implementation in
640   // ReferenceProcessor::process_discovered_references.
641   weak_refs_work_doit(full_gc);
642 
643   rp-&gt;verify_no_references_recorded();
644   assert(!rp-&gt;discovery_enabled(), &quot;Post condition&quot;);
645 
646 }
647 
648 void ShenandoahConcurrentMark::weak_refs_work_doit(bool full_gc) {
649   ReferenceProcessor* rp = _heap-&gt;ref_processor();
650 
651   ShenandoahPhaseTimings::Phase phase_process =
652           full_gc ?
653           ShenandoahPhaseTimings::full_gc_weakrefs_process :
654           ShenandoahPhaseTimings::weakrefs_process;
655 
<a name="21" id="anc21"></a>




656   shenandoah_assert_rp_isalive_not_installed();
657   ShenandoahIsAliveSelector is_alive;
658   ReferenceProcessorIsAliveMutator fix_isalive(rp, is_alive.is_alive_closure());
659 
660   WorkGang* workers = _heap-&gt;workers();
661   uint nworkers = workers-&gt;active_workers();
662 
663   rp-&gt;setup_policy(_heap-&gt;soft_ref_policy()-&gt;should_clear_all_soft_refs());
664   rp-&gt;set_active_mt_degree(nworkers);
665 
666   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
667 
668   // complete_gc and keep_alive closures instantiated here are only needed for
669   // single-threaded path in RP. They share the queue 0 for tracking work, which
670   // simplifies implementation. Since RP may decide to call complete_gc several
671   // times, we need to be able to reuse the terminator.
672   uint serial_worker_id = 0;
673   TaskTerminator terminator(1, task_queues());
674   ShenandoahCMDrainMarkingStackClosure complete_gc(serial_worker_id, &amp;terminator, /* reset_terminator = */ true);
675 
676   ShenandoahRefProcTaskExecutor executor(workers);
677 
678   ReferenceProcessorPhaseTimes pt(_heap-&gt;gc_timer(), rp-&gt;num_queues());
679 
680   {
681     ShenandoahGCPhase phase(phase_process);
<a name="22" id="anc22"></a>
682 
683     if (_heap-&gt;has_forwarded_objects()) {
684       ShenandoahCMKeepAliveUpdateClosure keep_alive(get_queue(serial_worker_id));
685       rp-&gt;process_discovered_references(is_alive.is_alive_closure(), &amp;keep_alive,
686                                         &amp;complete_gc, &amp;executor,
687                                         &amp;pt);
688 
689     } else {
690       ShenandoahCMKeepAliveClosure keep_alive(get_queue(serial_worker_id));
691       rp-&gt;process_discovered_references(is_alive.is_alive_closure(), &amp;keep_alive,
692                                         &amp;complete_gc, &amp;executor,
693                                         &amp;pt);
694 
695     }
696 
697     pt.print_all_references();
698 
699     assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
700   }
701 }
702 
703 class ShenandoahCancelledGCYieldClosure : public YieldClosure {
704 private:
705   ShenandoahHeap* const _heap;
706 public:
707   ShenandoahCancelledGCYieldClosure() : _heap(ShenandoahHeap::heap()) {};
708   virtual bool should_return() { return _heap-&gt;cancelled_gc(); }
709 };
710 
711 class ShenandoahPrecleanCompleteGCClosure : public VoidClosure {
712 public:
713   void do_void() {
714     ShenandoahHeap* sh = ShenandoahHeap::heap();
715     ShenandoahConcurrentMark* scm = sh-&gt;concurrent_mark();
716     assert(sh-&gt;process_references(), &quot;why else would we be here?&quot;);
717     TaskTerminator terminator(1, scm-&gt;task_queues());
718 
719     ReferenceProcessor* rp = sh-&gt;ref_processor();
720     shenandoah_assert_rp_isalive_installed();
721 
722     scm-&gt;mark_loop(0, &amp;terminator, rp,
723                    false, // not cancellable
724                    false); // do not do strdedup
725   }
726 };
727 
<a name="23" id="anc23"></a>




















728 class ShenandoahPrecleanTask : public AbstractGangTask {
729 private:
730   ReferenceProcessor* _rp;
731 
732 public:
733   ShenandoahPrecleanTask(ReferenceProcessor* rp) :
734           AbstractGangTask(&quot;Precleaning task&quot;),
735           _rp(rp) {}
736 
737   void work(uint worker_id) {
738     assert(worker_id == 0, &quot;The code below is single-threaded, only one worker is expected&quot;);
739     ShenandoahParallelWorkerSession worker_session(worker_id);
740 
741     ShenandoahHeap* sh = ShenandoahHeap::heap();
<a name="24" id="anc24"></a><span class="line-added">742     assert(!sh-&gt;has_forwarded_objects(), &quot;No forwarded objects expected here&quot;);</span>
743 
744     ShenandoahObjToScanQueue* q = sh-&gt;concurrent_mark()-&gt;get_queue(worker_id);
745 
746     ShenandoahCancelledGCYieldClosure yield;
747     ShenandoahPrecleanCompleteGCClosure complete_gc;
748 
<a name="25" id="anc25"></a><span class="line-modified">749     ShenandoahIsAliveClosure is_alive;</span>
<span class="line-modified">750     ShenandoahCMKeepAliveClosure keep_alive(q);</span>
<span class="line-modified">751     ResourceMark rm;</span>
<span class="line-modified">752     _rp-&gt;preclean_discovered_references(&amp;is_alive, &amp;keep_alive,</span>
<span class="line-modified">753                                         &amp;complete_gc, &amp;yield,</span>
<span class="line-modified">754                                         NULL);</span>









755   }
756 };
757 
758 void ShenandoahConcurrentMark::preclean_weak_refs() {
759   // Pre-cleaning weak references before diving into STW makes sense at the
760   // end of concurrent mark. This will filter out the references which referents
761   // are alive. Note that ReferenceProcessor already filters out these on reference
762   // discovery, and the bulk of work is done here. This phase processes leftovers
763   // that missed the initial filtering, i.e. when referent was marked alive after
764   // reference was discovered by RP.
765 
766   assert(_heap-&gt;process_references(), &quot;sanity&quot;);
767 
768   // Shortcut if no references were discovered to avoid winding up threads.
769   ReferenceProcessor* rp = _heap-&gt;ref_processor();
770   if (!rp-&gt;has_discovered_references()) {
771     return;
772   }
773 
774   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
775 
776   ReferenceProcessorMTDiscoveryMutator fix_mt_discovery(rp, false);
777 
778   shenandoah_assert_rp_isalive_not_installed();
779   ShenandoahIsAliveSelector is_alive;
780   ReferenceProcessorIsAliveMutator fix_isalive(rp, is_alive.is_alive_closure());
781 
782   // Execute precleaning in the worker thread: it will give us GCLABs, String dedup
783   // queues and other goodies. When upstream ReferenceProcessor starts supporting
784   // parallel precleans, we can extend this to more threads.
785   WorkGang* workers = _heap-&gt;workers();
786   uint nworkers = workers-&gt;active_workers();
787   assert(nworkers == 1, &quot;This code uses only a single worker&quot;);
788   task_queues()-&gt;reserve(nworkers);
789 
790   ShenandoahPrecleanTask task(rp);
791   workers-&gt;run_task(&amp;task);
792 
793   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
794 }
795 
796 void ShenandoahConcurrentMark::cancel() {
797   // Clean up marking stacks.
798   ShenandoahObjToScanQueueSet* queues = task_queues();
799   queues-&gt;clear();
800 
801   // Cancel SATB buffers.
802   ShenandoahBarrierSet::satb_mark_queue_set().abandon_partial_marking();
803 }
804 
805 ShenandoahObjToScanQueue* ShenandoahConcurrentMark::get_queue(uint worker_id) {
806   assert(task_queues()-&gt;get_reserved() &gt; worker_id, &quot;No reserved queue for worker id: %d&quot;, worker_id);
807   return _task_queues-&gt;queue(worker_id);
808 }
809 
810 template &lt;bool CANCELLABLE&gt;
811 void ShenandoahConcurrentMark::mark_loop_prework(uint w, TaskTerminator *t, ReferenceProcessor *rp,
812                                                  bool strdedup) {
813   ShenandoahObjToScanQueue* q = get_queue(w);
814 
815   jushort* ld = _heap-&gt;get_liveness_cache(w);
816 
817   // TODO: We can clean up this if we figure out how to do templated oop closures that
818   // play nice with specialized_oop_iterators.
819   if (_heap-&gt;unload_classes()) {
820     if (_heap-&gt;has_forwarded_objects()) {
821       if (strdedup) {
822         ShenandoahMarkUpdateRefsMetadataDedupClosure cl(q, rp);
823         mark_loop_work&lt;ShenandoahMarkUpdateRefsMetadataDedupClosure, CANCELLABLE&gt;(&amp;cl, ld, w, t);
824       } else {
825         ShenandoahMarkUpdateRefsMetadataClosure cl(q, rp);
826         mark_loop_work&lt;ShenandoahMarkUpdateRefsMetadataClosure, CANCELLABLE&gt;(&amp;cl, ld, w, t);
827       }
828     } else {
829       if (strdedup) {
830         ShenandoahMarkRefsMetadataDedupClosure cl(q, rp);
831         mark_loop_work&lt;ShenandoahMarkRefsMetadataDedupClosure, CANCELLABLE&gt;(&amp;cl, ld, w, t);
832       } else {
833         ShenandoahMarkRefsMetadataClosure cl(q, rp);
834         mark_loop_work&lt;ShenandoahMarkRefsMetadataClosure, CANCELLABLE&gt;(&amp;cl, ld, w, t);
835       }
836     }
837   } else {
838     if (_heap-&gt;has_forwarded_objects()) {
839       if (strdedup) {
840         ShenandoahMarkUpdateRefsDedupClosure cl(q, rp);
841         mark_loop_work&lt;ShenandoahMarkUpdateRefsDedupClosure, CANCELLABLE&gt;(&amp;cl, ld, w, t);
842       } else {
843         ShenandoahMarkUpdateRefsClosure cl(q, rp);
844         mark_loop_work&lt;ShenandoahMarkUpdateRefsClosure, CANCELLABLE&gt;(&amp;cl, ld, w, t);
845       }
846     } else {
847       if (strdedup) {
848         ShenandoahMarkRefsDedupClosure cl(q, rp);
849         mark_loop_work&lt;ShenandoahMarkRefsDedupClosure, CANCELLABLE&gt;(&amp;cl, ld, w, t);
850       } else {
851         ShenandoahMarkRefsClosure cl(q, rp);
852         mark_loop_work&lt;ShenandoahMarkRefsClosure, CANCELLABLE&gt;(&amp;cl, ld, w, t);
853       }
854     }
855   }
856 
857   _heap-&gt;flush_liveness_cache(w);
858 }
859 
860 template &lt;class T, bool CANCELLABLE&gt;
861 void ShenandoahConcurrentMark::mark_loop_work(T* cl, jushort* live_data, uint worker_id, TaskTerminator *terminator) {
862   uintx stride = ShenandoahMarkLoopStride;
863 
864   ShenandoahHeap* heap = ShenandoahHeap::heap();
865   ShenandoahObjToScanQueueSet* queues = task_queues();
866   ShenandoahObjToScanQueue* q;
867   ShenandoahMarkTask t;
868 
869   /*
870    * Process outstanding queues, if any.
871    *
872    * There can be more queues than workers. To deal with the imbalance, we claim
873    * extra queues first. Since marking can push new tasks into the queue associated
874    * with this worker id, we come back to process this queue in the normal loop.
875    */
876   assert(queues-&gt;get_reserved() == heap-&gt;workers()-&gt;active_workers(),
877          &quot;Need to reserve proper number of queues: reserved: %u, active: %u&quot;, queues-&gt;get_reserved(), heap-&gt;workers()-&gt;active_workers());
878 
879   q = queues-&gt;claim_next();
880   while (q != NULL) {
881     if (CANCELLABLE &amp;&amp; heap-&gt;check_cancelled_gc_and_yield()) {
882       return;
883     }
884 
885     for (uint i = 0; i &lt; stride; i++) {
886       if (q-&gt;pop(t)) {
887         do_task&lt;T&gt;(q, cl, live_data, &amp;t);
888       } else {
889         assert(q-&gt;is_empty(), &quot;Must be empty&quot;);
890         q = queues-&gt;claim_next();
891         break;
892       }
893     }
894   }
895   q = get_queue(worker_id);
896 
897   ShenandoahSATBBufferClosure drain_satb(q);
898   SATBMarkQueueSet&amp; satb_mq_set = ShenandoahBarrierSet::satb_mark_queue_set();
899 
900   /*
901    * Normal marking loop:
902    */
903   while (true) {
904     if (CANCELLABLE &amp;&amp; heap-&gt;check_cancelled_gc_and_yield()) {
905       return;
906     }
907 
908     while (satb_mq_set.completed_buffers_num() &gt; 0) {
909       satb_mq_set.apply_closure_to_completed_buffer(&amp;drain_satb);
910     }
911 
912     uint work = 0;
913     for (uint i = 0; i &lt; stride; i++) {
914       if (q-&gt;pop(t) ||
915           queues-&gt;steal(worker_id, t)) {
916         do_task&lt;T&gt;(q, cl, live_data, &amp;t);
917         work++;
918       } else {
919         break;
920       }
921     }
922 
923     if (work == 0) {
924       // No work encountered in current stride, try to terminate.
925       // Need to leave the STS here otherwise it might block safepoints.
926       ShenandoahSuspendibleThreadSetLeaver stsl(CANCELLABLE &amp;&amp; ShenandoahSuspendibleWorkers);
<a name="26" id="anc26"></a>
927       ShenandoahTerminatorTerminator tt(heap);
928       if (terminator-&gt;offer_termination(&amp;tt)) return;
929     }
930   }
931 }
932 
933 bool ShenandoahConcurrentMark::claim_codecache() {
934   assert(ShenandoahConcurrentScanCodeRoots, &quot;must not be called otherwise&quot;);
935   return _claimed_codecache.try_set();
936 }
937 
938 void ShenandoahConcurrentMark::clear_claim_codecache() {
939   assert(ShenandoahConcurrentScanCodeRoots, &quot;must not be called otherwise&quot;);
940   _claimed_codecache.unset();
941 }
<a name="27" id="anc27"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="27" type="hidden" />
</body>
</html>
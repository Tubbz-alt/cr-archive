<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/shenandoah/shenandoahNMethod.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahMarkingContext.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahPacer.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahNMethod.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 173,19 ***</span>
    }
  
    return new ShenandoahNMethod(nm, oops, non_immediate_oops);
  }
  
  void ShenandoahNMethod::heal_nmethod(nmethod* nm) {
<span class="line-removed">-   assert(ShenandoahHeap::heap()-&gt;is_concurrent_root_in_progress(), &quot;Only this phase&quot;);</span>
    ShenandoahNMethod* data = gc_data(nm);
    assert(data != NULL, &quot;Sanity&quot;);
    assert(data-&gt;lock()-&gt;owned_by_self(), &quot;Must hold the lock&quot;);
  
<span class="line-modified">!   ShenandoahEvacOOMScope evac_scope;</span>
<span class="line-modified">!   ShenandoahEvacuateUpdateRootsClosure&lt;&gt; cl;</span>
<span class="line-modified">!   data-&gt;oops_do(&amp;cl, true /*fix relocation*/);</span>
  }
  
  #ifdef ASSERT
  void ShenandoahNMethod::assert_alive_and_correct() {
    assert(_nm-&gt;is_alive(), &quot;only alive nmethods here&quot;);
<span class="line-new-header">--- 173,58 ---</span>
    }
  
    return new ShenandoahNMethod(nm, oops, non_immediate_oops);
  }
  
<span class="line-added">+ template &lt;bool HAS_FWD&gt;</span>
<span class="line-added">+ class ShenandoahKeepNMethodMetadataAliveClosure : public OopClosure {</span>
<span class="line-added">+ private:</span>
<span class="line-added">+   ShenandoahBarrierSet* const _bs;</span>
<span class="line-added">+ public:</span>
<span class="line-added">+   ShenandoahKeepNMethodMetadataAliveClosure() :</span>
<span class="line-added">+     _bs(static_cast&lt;ShenandoahBarrierSet*&gt;(BarrierSet::barrier_set())) {</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   virtual void do_oop(oop* p) {</span>
<span class="line-added">+     oop obj = RawAccess&lt;&gt;::oop_load(p);</span>
<span class="line-added">+     if (!CompressedOops::is_null(obj)) {</span>
<span class="line-added">+       if (HAS_FWD) {</span>
<span class="line-added">+         obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);</span>
<span class="line-added">+       }</span>
<span class="line-added">+       _bs-&gt;enqueue(obj);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   virtual void do_oop(narrowOop* p) {</span>
<span class="line-added">+     ShouldNotReachHere();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
  void ShenandoahNMethod::heal_nmethod(nmethod* nm) {
    ShenandoahNMethod* data = gc_data(nm);
    assert(data != NULL, &quot;Sanity&quot;);
    assert(data-&gt;lock()-&gt;owned_by_self(), &quot;Must hold the lock&quot;);
  
<span class="line-modified">!   ShenandoahHeap* const heap = ShenandoahHeap::heap();</span>
<span class="line-modified">!   if (heap-&gt;is_concurrent_mark_in_progress()) {</span>
<span class="line-modified">!     if (heap-&gt;has_forwarded_objects()) {</span>
<span class="line-added">+       ShenandoahKeepNMethodMetadataAliveClosure&lt;true&gt; cl;</span>
<span class="line-added">+       data-&gt;oops_do(&amp;cl);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       ShenandoahKeepNMethodMetadataAliveClosure&lt;false&gt; cl;</span>
<span class="line-added">+       data-&gt;oops_do(&amp;cl);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   } else if (heap-&gt;is_concurrent_root_in_progress()) {</span>
<span class="line-added">+     ShenandoahEvacOOMScope evac_scope;</span>
<span class="line-added">+     ShenandoahEvacuateUpdateRootsClosure&lt;&gt; cl;</span>
<span class="line-added">+     data-&gt;oops_do(&amp;cl, true /*fix relocation*/);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     // There is possibility that GC is cancelled when it arrives final mark.</span>
<span class="line-added">+     // In this case, concurrent root phase is skipped and degenerated GC should be</span>
<span class="line-added">+     // followed, where nmethods are disarmed.</span>
<span class="line-added">+     assert(heap-&gt;cancelled_gc(), &quot;What else?&quot;);</span>
<span class="line-added">+   }</span>
  }
  
  #ifdef ASSERT
  void ShenandoahNMethod::assert_alive_and_correct() {
    assert(_nm-&gt;is_alive(), &quot;only alive nmethods here&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 235,19 ***</span>
    ShenandoahNMethodOopDetector detector;
    nm()-&gt;oops_do(&amp;detector, allow_dead);
  
    GrowableArray&lt;oop*&gt;* oops = detector.oops();
  
<span class="line-modified">!   assert(oops-&gt;length() == oop_count(), &quot;Must match&quot;);</span>
<span class="line-removed">- </span>
    for (int index = 0; index &lt; _oops_count; index ++) {
      assert(oops-&gt;contains(_oops[index]), &quot;Must contain this oop&quot;);
    }
  
    for (oop* p = nm()-&gt;oops_begin(); p &lt; nm()-&gt;oops_end(); p ++) {
      assert(oops-&gt;contains(p), &quot;Must contain this oop&quot;);
    }
  }
  
  void ShenandoahNMethod::assert_no_oops(nmethod* nm, bool allow_dead) {
    ShenandoahNMethodOopDetector detector;
    nm-&gt;oops_do(&amp;detector, allow_dead);
<span class="line-new-header">--- 274,41 ---</span>
    ShenandoahNMethodOopDetector detector;
    nm()-&gt;oops_do(&amp;detector, allow_dead);
  
    GrowableArray&lt;oop*&gt;* oops = detector.oops();
  
<span class="line-modified">!   int count = _oops_count;</span>
    for (int index = 0; index &lt; _oops_count; index ++) {
      assert(oops-&gt;contains(_oops[index]), &quot;Must contain this oop&quot;);
    }
  
    for (oop* p = nm()-&gt;oops_begin(); p &lt; nm()-&gt;oops_end(); p ++) {
<span class="line-added">+     if (*p == Universe::non_oop_word()) continue;</span>
<span class="line-added">+     count++;</span>
      assert(oops-&gt;contains(p), &quot;Must contain this oop&quot;);
    }
<span class="line-added">+ </span>
<span class="line-added">+   if (oops-&gt;length() &lt; count) {</span>
<span class="line-added">+     stringStream debug_stream;</span>
<span class="line-added">+     debug_stream.print_cr(&quot;detected locs: %d&quot;, oops-&gt;length());</span>
<span class="line-added">+     for (int i = 0; i &lt; oops-&gt;length(); i++) {</span>
<span class="line-added">+       debug_stream.print_cr(&quot;-&gt; &quot; PTR_FORMAT, p2i(oops-&gt;at(i)));</span>
<span class="line-added">+     }</span>
<span class="line-added">+     debug_stream.print_cr(&quot;recorded oops: %d&quot;, _oops_count);</span>
<span class="line-added">+     for (int i = 0; i &lt; _oops_count; i++) {</span>
<span class="line-added">+       debug_stream.print_cr(&quot;-&gt; &quot; PTR_FORMAT, p2i(_oops[i]));</span>
<span class="line-added">+     }</span>
<span class="line-added">+     GrowableArray&lt;oop*&gt; check;</span>
<span class="line-added">+     bool non_immed;</span>
<span class="line-added">+     detect_reloc_oops(nm(), check, non_immed);</span>
<span class="line-added">+     debug_stream.print_cr(&quot;check oops: %d&quot;, check.length());</span>
<span class="line-added">+     for (int i = 0; i &lt; check.length(); i++) {</span>
<span class="line-added">+       debug_stream.print_cr(&quot;-&gt; &quot; PTR_FORMAT, p2i(check.at(i)));</span>
<span class="line-added">+     }</span>
<span class="line-added">+     fatal(&quot;Must match #detected: %d, #recorded: %d, #total: %d, begin: &quot; PTR_FORMAT &quot;, end: &quot; PTR_FORMAT &quot;\n%s&quot;,</span>
<span class="line-added">+           oops-&gt;length(), _oops_count, count, p2i(nm()-&gt;oops_begin()), p2i(nm()-&gt;oops_end()), debug_stream.as_string());</span>
<span class="line-added">+   }</span>
  }
  
  void ShenandoahNMethod::assert_no_oops(nmethod* nm, bool allow_dead) {
    ShenandoahNMethodOopDetector detector;
    nm-&gt;oops_do(&amp;detector, allow_dead);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 275,10 ***</span>
<span class="line-new-header">--- 336,11 ---</span>
    ShenandoahNMethod* data = ShenandoahNMethod::gc_data(nm);
    ShenandoahReentrantLocker data_locker(data != NULL ? data-&gt;lock() : NULL);
  
    if (data != NULL) {
      assert(contain(nm), &quot;Must have been registered&quot;);
<span class="line-added">+     assert(nm == data-&gt;nm(), &quot;Must be same nmethod&quot;);</span>
      data-&gt;update();
    } else {
      data = ShenandoahNMethod::for_nmethod(nm);
      if (data == NULL) {
        assert(!ShenandoahConcurrentRoots::can_do_concurrent_class_unloading(),
</pre>
<center><a href="shenandoahMarkingContext.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahPacer.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
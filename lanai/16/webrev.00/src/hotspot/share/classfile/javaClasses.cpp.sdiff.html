<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/javaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="fieldLayoutBuilder.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="modules.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/javaClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 279       buffer-&gt;char_at_put(index, unicode[index]);
 280     }
 281   }
 282 
 283 #ifdef ASSERT
 284   {
 285     ResourceMark rm;
 286     char* expected = UNICODE::as_utf8(unicode, length);
 287     char* actual = as_utf8_string(h_obj());
 288     if (strcmp(expected, actual) != 0) {
 289       tty-&gt;print_cr(&quot;Unicode conversion failure: %s --&gt; %s&quot;, expected, actual);
 290       ShouldNotReachHere();
 291     }
 292   }
 293 #endif
 294 
 295   return h_obj;
 296 }
 297 
 298 oop java_lang_String::create_oop_from_unicode(const jchar* unicode, int length, TRAPS) {
<span class="line-modified"> 299   Handle h_obj = create_from_unicode(unicode, length, CHECK_0);</span>
 300   return h_obj();
 301 }
 302 
 303 Handle java_lang_String::create_from_str(const char* utf8_str, TRAPS) {
 304   if (utf8_str == NULL) {
 305     return Handle();
 306   }
 307   bool has_multibyte, is_latin1;
 308   int length = UTF8::unicode_length(utf8_str, is_latin1, has_multibyte);
 309   if (!CompactStrings) {
 310     has_multibyte = true;
 311     is_latin1 = false;
 312   }
 313 
 314   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 315   if (length &gt; 0) {
 316     if (!has_multibyte) {
 317       const jbyte* src = reinterpret_cast&lt;const jbyte*&gt;(utf8_str);
 318       ArrayAccess&lt;&gt;::arraycopy_from_native(src, value(h_obj()), typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), length);
 319     } else if (is_latin1) {
</pre>
<hr />
<pre>
 326 #ifdef ASSERT
 327   // This check is too strict because the input string is not necessarily valid UTF8.
 328   // For example, it may be created with arbitrary content via jni_NewStringUTF.
 329   /*
 330   {
 331     ResourceMark rm;
 332     const char* expected = utf8_str;
 333     char* actual = as_utf8_string(h_obj());
 334     if (strcmp(expected, actual) != 0) {
 335       tty-&gt;print_cr(&quot;String conversion failure: %s --&gt; %s&quot;, expected, actual);
 336       ShouldNotReachHere();
 337     }
 338   }
 339   */
 340 #endif
 341 
 342   return h_obj;
 343 }
 344 
 345 oop java_lang_String::create_oop_from_str(const char* utf8_str, TRAPS) {
<span class="line-modified"> 346   Handle h_obj = create_from_str(utf8_str, CHECK_0);</span>
 347   return h_obj();
 348 }
 349 
 350 Handle java_lang_String::create_from_symbol(Symbol* symbol, TRAPS) {
 351   const char* utf8_str = (char*)symbol-&gt;bytes();
 352   int utf8_len = symbol-&gt;utf8_length();
 353 
 354   bool has_multibyte, is_latin1;
 355   int length = UTF8::unicode_length(utf8_str, utf8_len, is_latin1, has_multibyte);
 356   if (!CompactStrings) {
 357     has_multibyte = true;
 358     is_latin1 = false;
 359   }
 360 
 361   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 362   if (length &gt; 0) {
 363     if (!has_multibyte) {
 364       const jbyte* src = reinterpret_cast&lt;const jbyte*&gt;(utf8_str);
 365       ArrayAccess&lt;&gt;::arraycopy_from_native(src, value(h_obj()), typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), length);
 366     } else if (is_latin1) {
</pre>
<hr />
<pre>
1424   if (o == NULL) {
1425     o = StringTable::intern(java_lang_Class::as_external_name(java_class()), THREAD);
1426     java_class-&gt;obj_field_put(_name_offset, o);
1427   }
1428   return o;
1429 }
1430 
1431 oop java_lang_Class::source_file(oop java_class) {
1432   assert(_source_file_offset != 0, &quot;must be set&quot;);
1433   return java_class-&gt;obj_field(_source_file_offset);
1434 }
1435 
1436 void java_lang_Class::set_source_file(oop java_class, oop source_file) {
1437   assert(_source_file_offset != 0, &quot;must be set&quot;);
1438   java_class-&gt;obj_field_put(_source_file_offset, source_file);
1439 }
1440 
1441 oop java_lang_Class::create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS) {
1442   // This should be improved by adding a field at the Java level or by
1443   // introducing a new VM klass (see comment in ClassFileParser)
<span class="line-modified">1444   oop java_class = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(NULL, CHECK_0);</span>
1445   if (type != T_VOID) {
1446     Klass* aklass = Universe::typeArrayKlassObj(type);
1447     assert(aklass != NULL, &quot;correct bootstrap&quot;);
1448     release_set_array_klass(java_class, aklass);
1449   }
1450 #ifdef ASSERT
1451   InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(SystemDictionary::Class_klass());
1452   assert(java_lang_Class::static_oop_field_count(java_class) == 0, &quot;should have been zeroed by allocation&quot;);
1453 #endif
1454   return java_class;
1455 }
1456 
1457 
1458 Klass* java_lang_Class::as_Klass(oop java_class) {
1459   //%note memory_2
1460   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1461   Klass* k = ((Klass*)java_class-&gt;metadata_field(_klass_offset));
1462   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);
1463   return k;
1464 }
</pre>
<hr />
<pre>
1997 
1998 static inline bool version_matches(Method* method, int version) {
1999   assert(version &lt; MAX_VERSION, &quot;version is too big&quot;);
2000   return method != NULL &amp;&amp; (method-&gt;constants()-&gt;version() == version);
2001 }
2002 
2003 // This class provides a simple wrapper over the internal structure of
2004 // exception backtrace to insulate users of the backtrace from needing
2005 // to know what it looks like.
2006 // The code of this class is not GC safe. Allocations can only happen
2007 // in expand().
2008 class BacktraceBuilder: public StackObj {
2009  friend class BacktraceIterator;
2010  private:
2011   Handle          _backtrace;
2012   objArrayOop     _head;
2013   typeArrayOop    _methods;
2014   typeArrayOop    _bcis;
2015   objArrayOop     _mirrors;
2016   typeArrayOop    _names; // Needed to insulate method name against redefinition.
<span class="line-modified">2017   // This is set to a java.lang.Boolean(true) if the top frame</span>
<span class="line-modified">2018   // of the backtrace is omitted because it shall be hidden.</span>
<span class="line-removed">2019   // Else it is null.</span>
<span class="line-removed">2020   oop             _has_hidden_top_frame;</span>
2021   int             _index;
2022   NoSafepointVerifier _nsv;
2023 
2024   enum {
2025     trace_methods_offset = java_lang_Throwable::trace_methods_offset,
2026     trace_bcis_offset    = java_lang_Throwable::trace_bcis_offset,
2027     trace_mirrors_offset = java_lang_Throwable::trace_mirrors_offset,
2028     trace_names_offset   = java_lang_Throwable::trace_names_offset,
2029     trace_next_offset    = java_lang_Throwable::trace_next_offset,
2030     trace_hidden_offset  = java_lang_Throwable::trace_hidden_offset,
2031     trace_size           = java_lang_Throwable::trace_size,
2032     trace_chunk_size     = java_lang_Throwable::trace_chunk_size
2033   };
2034 
2035   // get info out of chunks
2036   static typeArrayOop get_methods(objArrayHandle chunk) {
2037     typeArrayOop methods = typeArrayOop(chunk-&gt;obj_at(trace_methods_offset));
2038     assert(methods != NULL, &quot;method array should be initialized in backtrace&quot;);
2039     return methods;
2040   }
2041   static typeArrayOop get_bcis(objArrayHandle chunk) {
2042     typeArrayOop bcis = typeArrayOop(chunk-&gt;obj_at(trace_bcis_offset));
2043     assert(bcis != NULL, &quot;bci array should be initialized in backtrace&quot;);
2044     return bcis;
2045   }
2046   static objArrayOop get_mirrors(objArrayHandle chunk) {
2047     objArrayOop mirrors = objArrayOop(chunk-&gt;obj_at(trace_mirrors_offset));
2048     assert(mirrors != NULL, &quot;mirror array should be initialized in backtrace&quot;);
2049     return mirrors;
2050   }
2051   static typeArrayOop get_names(objArrayHandle chunk) {
2052     typeArrayOop names = typeArrayOop(chunk-&gt;obj_at(trace_names_offset));
2053     assert(names != NULL, &quot;names array should be initialized in backtrace&quot;);
2054     return names;
2055   }
<span class="line-modified">2056   static oop get_has_hidden_top_frame(objArrayHandle chunk) {</span>
2057     oop hidden = chunk-&gt;obj_at(trace_hidden_offset);
<span class="line-modified">2058     return hidden;</span>
2059   }
2060 
2061  public:
2062 
2063   // constructor for new backtrace
<span class="line-modified">2064   BacktraceBuilder(TRAPS): _head(NULL), _methods(NULL), _bcis(NULL), _mirrors(NULL), _names(NULL), _has_hidden_top_frame(NULL) {</span>
2065     expand(CHECK);
2066     _backtrace = Handle(THREAD, _head);
2067     _index = 0;
2068   }
2069 
2070   BacktraceBuilder(Thread* thread, objArrayHandle backtrace) {
2071     _methods = get_methods(backtrace);
2072     _bcis = get_bcis(backtrace);
2073     _mirrors = get_mirrors(backtrace);
2074     _names = get_names(backtrace);
<span class="line-modified">2075     _has_hidden_top_frame = get_has_hidden_top_frame(backtrace);</span>
2076     assert(_methods-&gt;length() == _bcis-&gt;length() &amp;&amp;
2077            _methods-&gt;length() == _mirrors-&gt;length() &amp;&amp;
2078            _mirrors-&gt;length() == _names-&gt;length(),
2079            &quot;method and source information arrays should match&quot;);
2080 
2081     // head is the preallocated backtrace
2082     _head = backtrace();
2083     _backtrace = Handle(thread, _head);
2084     _index = 0;
2085   }
2086 
2087   void expand(TRAPS) {
2088     objArrayHandle old_head(THREAD, _head);
2089     PauseNoSafepointVerifier pnsv(&amp;_nsv);
2090 
2091     objArrayOop head = oopFactory::new_objectArray(trace_size, CHECK);
2092     objArrayHandle new_head(THREAD, head);
2093 
2094     typeArrayOop methods = oopFactory::new_shortArray(trace_chunk_size, CHECK);
2095     typeArrayHandle new_methods(THREAD, methods);
</pre>
<hr />
<pre>
2135       expand(CHECK);
2136       method = mhandle();
2137     }
2138 
2139     _methods-&gt;ushort_at_put(_index, method-&gt;orig_method_idnum());
2140     _bcis-&gt;int_at_put(_index, Backtrace::merge_bci_and_version(bci, method-&gt;constants()-&gt;version()));
2141 
2142     // Note:this doesn&#39;t leak symbols because the mirror in the backtrace keeps the
2143     // klass owning the symbols alive so their refcounts aren&#39;t decremented.
2144     Symbol* name = method-&gt;name();
2145     _names-&gt;symbol_at_put(_index, name);
2146 
2147     // We need to save the mirrors in the backtrace to keep the class
2148     // from being unloaded while we still have this stack trace.
2149     assert(method-&gt;method_holder()-&gt;java_mirror() != NULL, &quot;never push null for mirror&quot;);
2150     _mirrors-&gt;obj_at_put(_index, method-&gt;method_holder()-&gt;java_mirror());
2151     _index++;
2152   }
2153 
2154   void set_has_hidden_top_frame(TRAPS) {
<span class="line-modified">2155     if (_has_hidden_top_frame == NULL) {</span>
2156       // It would be nice to add java/lang/Boolean::TRUE here
2157       // to indicate that this backtrace has a hidden top frame.
2158       // But this code is used before TRUE is allocated.
<span class="line-modified">2159       // Therefor let&#39;s just use an arbitrary legal oop</span>
<span class="line-modified">2160       // available right here. We only test for != null</span>
<span class="line-removed">2161       // anyways. _methods is a short[].</span>
2162       assert(_methods != NULL, &quot;we need a legal oop&quot;);
<span class="line-modified">2163       _has_hidden_top_frame = _methods;</span>
<span class="line-modified">2164       _head-&gt;obj_at_put(trace_hidden_offset, _has_hidden_top_frame);</span>
2165     }
2166   }
<span class="line-removed">2167 </span>
2168 };
2169 
2170 struct BacktraceElement : public StackObj {
2171   int _method_id;
2172   int _bci;
2173   int _version;
2174   Symbol* _name;
2175   Handle _mirror;
2176   BacktraceElement(Handle mirror, int mid, int version, int bci, Symbol* name) :
2177                    _method_id(mid), _bci(bci), _version(version), _name(name), _mirror(mirror) {}
2178 };
2179 
2180 class BacktraceIterator : public StackObj {
2181   int _index;
2182   objArrayHandle  _result;
2183   objArrayHandle  _mirrors;
2184   typeArrayHandle _methods;
2185   typeArrayHandle _bcis;
2186   typeArrayHandle _names;
2187 
</pre>
<hr />
<pre>
2630 
2631   InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(bte._mirror()));
2632   assert(holder != NULL, &quot;first element should be non-null&quot;);
2633   Method* m = holder-&gt;method_with_orig_idnum(bte._method_id, bte._version);
2634 
2635   // Original version is no longer available.
2636   if (m == NULL || !version_matches(m, bte._version)) {
2637     return false;
2638   }
2639 
2640   *method = m;
2641   *bci = bte._bci;
2642   return true;
2643 }
2644 
2645 oop java_lang_StackTraceElement::create(const methodHandle&amp; method, int bci, TRAPS) {
2646   // Allocate java.lang.StackTraceElement instance
2647   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
2648   assert(k != NULL, &quot;must be loaded in 1.4+&quot;);
2649   if (k-&gt;should_be_initialized()) {
<span class="line-modified">2650     k-&gt;initialize(CHECK_0);</span>
2651   }
2652 
<span class="line-modified">2653   Handle element = k-&gt;allocate_instance_handle(CHECK_0);</span>
2654 
2655   int version = method-&gt;constants()-&gt;version();
<span class="line-modified">2656   fill_in(element, method-&gt;method_holder(), method, version, bci, method-&gt;name(), CHECK_0);</span>
2657   return element();
2658 }
2659 
2660 void java_lang_StackTraceElement::fill_in(Handle element,
2661                                           InstanceKlass* holder, const methodHandle&amp; method,
2662                                           int version, int bci, Symbol* name, TRAPS) {
2663   assert(element-&gt;is_a(SystemDictionary::StackTraceElement_klass()), &quot;sanity check&quot;);
2664 
2665   ResourceMark rm(THREAD);
2666   HandleMark hm(THREAD);
2667 
2668   // Fill in class name
2669   Handle java_class(THREAD, holder-&gt;java_mirror());
2670   oop classname = java_lang_Class::name(java_class, CHECK);
2671   java_lang_StackTraceElement::set_declaringClass(element(), classname);
2672   java_lang_StackTraceElement::set_declaringClassObject(element(), java_class());
2673 
2674   oop loader = holder-&gt;class_loader();
2675   if (loader != NULL) {
2676     oop loader_name = java_lang_ClassLoader::name(loader);
</pre>
<hr />
<pre>
3382 }
3383 
3384 #define UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(macro) \
3385   macro(_base_offset, k, &quot;base&quot;, object_signature, false)
3386 
3387 void reflect_UnsafeStaticFieldAccessorImpl::compute_offsets() {
3388   InstanceKlass* k = SystemDictionary::reflect_UnsafeStaticFieldAccessorImpl_klass();
3389   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3390 }
3391 
3392 #if INCLUDE_CDS
3393 void reflect_UnsafeStaticFieldAccessorImpl::serialize_offsets(SerializeClosure* f) {
3394   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3395 }
3396 #endif
3397 
3398 oop java_lang_boxing_object::initialize_and_allocate(BasicType type, TRAPS) {
3399   Klass* k = SystemDictionary::box_klass(type);
3400   if (k == NULL)  return NULL;
3401   InstanceKlass* ik = InstanceKlass::cast(k);
<span class="line-modified">3402   if (!ik-&gt;is_initialized())  ik-&gt;initialize(CHECK_0);</span>
3403   return ik-&gt;allocate_instance(THREAD);
3404 }
3405 
3406 
3407 oop java_lang_boxing_object::create(BasicType type, jvalue* value, TRAPS) {
<span class="line-modified">3408   oop box = initialize_and_allocate(type, CHECK_0);</span>
3409   if (box == NULL)  return NULL;
3410   switch (type) {
3411     case T_BOOLEAN:
3412       box-&gt;bool_field_put(value_offset, value-&gt;z);
3413       break;
3414     case T_CHAR:
3415       box-&gt;char_field_put(value_offset, value-&gt;c);
3416       break;
3417     case T_FLOAT:
3418       box-&gt;float_field_put(value_offset, value-&gt;f);
3419       break;
3420     case T_DOUBLE:
3421       box-&gt;double_field_put(long_value_offset, value-&gt;d);
3422       break;
3423     case T_BYTE:
3424       box-&gt;byte_field_put(value_offset, value-&gt;b);
3425       break;
3426     case T_SHORT:
3427       box-&gt;short_field_put(value_offset, value-&gt;s);
3428       break;
</pre>
<hr />
<pre>
4019   macro(_privilegedContext_offset, k, &quot;privilegedContext&quot;, accesscontrolcontext_signature, false); \
4020   macro(_isPrivileged_offset,      k, &quot;isPrivileged&quot;, bool_signature, false); \
4021   macro(_isAuthorized_offset,      k, &quot;isAuthorized&quot;, bool_signature, false)
4022 
4023 void java_security_AccessControlContext::compute_offsets() {
4024   assert(_isPrivileged_offset == 0, &quot;offsets should be initialized only once&quot;);
4025   InstanceKlass* k = SystemDictionary::AccessControlContext_klass();
4026   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4027 }
4028 
4029 #if INCLUDE_CDS
4030 void java_security_AccessControlContext::serialize_offsets(SerializeClosure* f) {
4031   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4032 }
4033 #endif
4034 
4035 oop java_security_AccessControlContext::create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS) {
4036   assert(_isPrivileged_offset != 0, &quot;offsets should have been initialized&quot;);
4037   assert(_isAuthorized_offset != -1, &quot;offsets should have been initialized&quot;);
4038   // Ensure klass is initialized
<span class="line-modified">4039   SystemDictionary::AccessControlContext_klass()-&gt;initialize(CHECK_0);</span>
4040   // Allocate result
<span class="line-modified">4041   oop result = SystemDictionary::AccessControlContext_klass()-&gt;allocate_instance(CHECK_0);</span>
4042   // Fill in values
4043   result-&gt;obj_field_put(_context_offset, context());
4044   result-&gt;obj_field_put(_privilegedContext_offset, privileged_context());
4045   result-&gt;bool_field_put(_isPrivileged_offset, isPrivileged);
4046   // whitelist AccessControlContexts created by the JVM
4047   result-&gt;bool_field_put(_isAuthorized_offset, true);
4048   return result;
4049 }
4050 
4051 
4052 // Support for java_lang_ClassLoader
4053 
4054 bool java_lang_ClassLoader::offsets_computed = false;
4055 int  java_lang_ClassLoader::_loader_data_offset = -1;
4056 int  java_lang_ClassLoader::parallelCapable_offset = -1;
4057 int  java_lang_ClassLoader::name_offset = -1;
4058 int  java_lang_ClassLoader::nameAndId_offset = -1;
4059 int  java_lang_ClassLoader::unnamedModule_offset = -1;
4060 
4061 ClassLoaderData* java_lang_ClassLoader::loader_data_acquire(oop loader) {
</pre>
<hr />
<pre>
4765 // Invoked before SystemDictionary::initialize, so pre-loaded classes
4766 // are not available to determine the offset_of_static_fields.
4767 void JavaClasses::compute_hard_coded_offsets() {
4768 
4769   // java_lang_boxing_object
4770   java_lang_boxing_object::value_offset      = member_offset(java_lang_boxing_object::hc_value_offset);
4771   java_lang_boxing_object::long_value_offset = align_up(member_offset(java_lang_boxing_object::hc_value_offset), BytesPerLong);
4772 
4773   // java_lang_ref_Reference
4774   java_lang_ref_Reference::referent_offset    = member_offset(java_lang_ref_Reference::hc_referent_offset);
4775   java_lang_ref_Reference::queue_offset       = member_offset(java_lang_ref_Reference::hc_queue_offset);
4776   java_lang_ref_Reference::next_offset        = member_offset(java_lang_ref_Reference::hc_next_offset);
4777   java_lang_ref_Reference::discovered_offset  = member_offset(java_lang_ref_Reference::hc_discovered_offset);
4778 }
4779 
4780 #define DO_COMPUTE_OFFSETS(k) k::compute_offsets();
4781 
4782 // Compute non-hard-coded field offsets of all the classes in this file
4783 void JavaClasses::compute_offsets() {
4784   if (UseSharedSpaces) {
<span class="line-modified">4785     assert(JvmtiExport::is_early_phase() &amp;&amp; !(JvmtiExport::should_post_class_file_load_hook() &amp;&amp;</span>
<span class="line-modified">4786                                               JvmtiExport::has_early_class_hook_env()),</span>
<span class="line-modified">4787            &quot;JavaClasses::compute_offsets() must be called in early JVMTI phase.&quot;);</span>
4788     // None of the classes used by the rest of this function can be replaced by
4789     // JMVTI ClassFileLoadHook.
4790     // We are safe to use the archived offsets, which have already been restored
4791     // by JavaClasses::serialize_offsets, without computing the offsets again.
4792     return;
4793   }
4794 
4795   // We have already called the compute_offsets() of the
4796   // BASIC_JAVA_CLASSES_DO_PART1 classes (java_lang_String and java_lang_Class)
4797   // earlier inside SystemDictionary::resolve_well_known_classes()
4798   BASIC_JAVA_CLASSES_DO_PART2(DO_COMPUTE_OFFSETS);
4799 }
4800 
4801 #if INCLUDE_CDS
4802 #define DO_SERIALIZE_OFFSETS(k) k::serialize_offsets(soc);
4803 
4804 void JavaClasses::serialize_offsets(SerializeClosure* soc) {
4805   BASIC_JAVA_CLASSES_DO(DO_SERIALIZE_OFFSETS);
4806 }
4807 #endif
</pre>
</td>
<td>
<hr />
<pre>
 279       buffer-&gt;char_at_put(index, unicode[index]);
 280     }
 281   }
 282 
 283 #ifdef ASSERT
 284   {
 285     ResourceMark rm;
 286     char* expected = UNICODE::as_utf8(unicode, length);
 287     char* actual = as_utf8_string(h_obj());
 288     if (strcmp(expected, actual) != 0) {
 289       tty-&gt;print_cr(&quot;Unicode conversion failure: %s --&gt; %s&quot;, expected, actual);
 290       ShouldNotReachHere();
 291     }
 292   }
 293 #endif
 294 
 295   return h_obj;
 296 }
 297 
 298 oop java_lang_String::create_oop_from_unicode(const jchar* unicode, int length, TRAPS) {
<span class="line-modified"> 299   Handle h_obj = create_from_unicode(unicode, length, CHECK_NULL);</span>
 300   return h_obj();
 301 }
 302 
 303 Handle java_lang_String::create_from_str(const char* utf8_str, TRAPS) {
 304   if (utf8_str == NULL) {
 305     return Handle();
 306   }
 307   bool has_multibyte, is_latin1;
 308   int length = UTF8::unicode_length(utf8_str, is_latin1, has_multibyte);
 309   if (!CompactStrings) {
 310     has_multibyte = true;
 311     is_latin1 = false;
 312   }
 313 
 314   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 315   if (length &gt; 0) {
 316     if (!has_multibyte) {
 317       const jbyte* src = reinterpret_cast&lt;const jbyte*&gt;(utf8_str);
 318       ArrayAccess&lt;&gt;::arraycopy_from_native(src, value(h_obj()), typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), length);
 319     } else if (is_latin1) {
</pre>
<hr />
<pre>
 326 #ifdef ASSERT
 327   // This check is too strict because the input string is not necessarily valid UTF8.
 328   // For example, it may be created with arbitrary content via jni_NewStringUTF.
 329   /*
 330   {
 331     ResourceMark rm;
 332     const char* expected = utf8_str;
 333     char* actual = as_utf8_string(h_obj());
 334     if (strcmp(expected, actual) != 0) {
 335       tty-&gt;print_cr(&quot;String conversion failure: %s --&gt; %s&quot;, expected, actual);
 336       ShouldNotReachHere();
 337     }
 338   }
 339   */
 340 #endif
 341 
 342   return h_obj;
 343 }
 344 
 345 oop java_lang_String::create_oop_from_str(const char* utf8_str, TRAPS) {
<span class="line-modified"> 346   Handle h_obj = create_from_str(utf8_str, CHECK_NULL);</span>
 347   return h_obj();
 348 }
 349 
 350 Handle java_lang_String::create_from_symbol(Symbol* symbol, TRAPS) {
 351   const char* utf8_str = (char*)symbol-&gt;bytes();
 352   int utf8_len = symbol-&gt;utf8_length();
 353 
 354   bool has_multibyte, is_latin1;
 355   int length = UTF8::unicode_length(utf8_str, utf8_len, is_latin1, has_multibyte);
 356   if (!CompactStrings) {
 357     has_multibyte = true;
 358     is_latin1 = false;
 359   }
 360 
 361   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 362   if (length &gt; 0) {
 363     if (!has_multibyte) {
 364       const jbyte* src = reinterpret_cast&lt;const jbyte*&gt;(utf8_str);
 365       ArrayAccess&lt;&gt;::arraycopy_from_native(src, value(h_obj()), typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), length);
 366     } else if (is_latin1) {
</pre>
<hr />
<pre>
1424   if (o == NULL) {
1425     o = StringTable::intern(java_lang_Class::as_external_name(java_class()), THREAD);
1426     java_class-&gt;obj_field_put(_name_offset, o);
1427   }
1428   return o;
1429 }
1430 
1431 oop java_lang_Class::source_file(oop java_class) {
1432   assert(_source_file_offset != 0, &quot;must be set&quot;);
1433   return java_class-&gt;obj_field(_source_file_offset);
1434 }
1435 
1436 void java_lang_Class::set_source_file(oop java_class, oop source_file) {
1437   assert(_source_file_offset != 0, &quot;must be set&quot;);
1438   java_class-&gt;obj_field_put(_source_file_offset, source_file);
1439 }
1440 
1441 oop java_lang_Class::create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS) {
1442   // This should be improved by adding a field at the Java level or by
1443   // introducing a new VM klass (see comment in ClassFileParser)
<span class="line-modified">1444   oop java_class = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(NULL, CHECK_NULL);</span>
1445   if (type != T_VOID) {
1446     Klass* aklass = Universe::typeArrayKlassObj(type);
1447     assert(aklass != NULL, &quot;correct bootstrap&quot;);
1448     release_set_array_klass(java_class, aklass);
1449   }
1450 #ifdef ASSERT
1451   InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(SystemDictionary::Class_klass());
1452   assert(java_lang_Class::static_oop_field_count(java_class) == 0, &quot;should have been zeroed by allocation&quot;);
1453 #endif
1454   return java_class;
1455 }
1456 
1457 
1458 Klass* java_lang_Class::as_Klass(oop java_class) {
1459   //%note memory_2
1460   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1461   Klass* k = ((Klass*)java_class-&gt;metadata_field(_klass_offset));
1462   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);
1463   return k;
1464 }
</pre>
<hr />
<pre>
1997 
1998 static inline bool version_matches(Method* method, int version) {
1999   assert(version &lt; MAX_VERSION, &quot;version is too big&quot;);
2000   return method != NULL &amp;&amp; (method-&gt;constants()-&gt;version() == version);
2001 }
2002 
2003 // This class provides a simple wrapper over the internal structure of
2004 // exception backtrace to insulate users of the backtrace from needing
2005 // to know what it looks like.
2006 // The code of this class is not GC safe. Allocations can only happen
2007 // in expand().
2008 class BacktraceBuilder: public StackObj {
2009  friend class BacktraceIterator;
2010  private:
2011   Handle          _backtrace;
2012   objArrayOop     _head;
2013   typeArrayOop    _methods;
2014   typeArrayOop    _bcis;
2015   objArrayOop     _mirrors;
2016   typeArrayOop    _names; // Needed to insulate method name against redefinition.
<span class="line-modified">2017   // True if the top frame of the backtrace is omitted because it shall be hidden.</span>
<span class="line-modified">2018   bool            _has_hidden_top_frame;</span>


2019   int             _index;
2020   NoSafepointVerifier _nsv;
2021 
2022   enum {
2023     trace_methods_offset = java_lang_Throwable::trace_methods_offset,
2024     trace_bcis_offset    = java_lang_Throwable::trace_bcis_offset,
2025     trace_mirrors_offset = java_lang_Throwable::trace_mirrors_offset,
2026     trace_names_offset   = java_lang_Throwable::trace_names_offset,
2027     trace_next_offset    = java_lang_Throwable::trace_next_offset,
2028     trace_hidden_offset  = java_lang_Throwable::trace_hidden_offset,
2029     trace_size           = java_lang_Throwable::trace_size,
2030     trace_chunk_size     = java_lang_Throwable::trace_chunk_size
2031   };
2032 
2033   // get info out of chunks
2034   static typeArrayOop get_methods(objArrayHandle chunk) {
2035     typeArrayOop methods = typeArrayOop(chunk-&gt;obj_at(trace_methods_offset));
2036     assert(methods != NULL, &quot;method array should be initialized in backtrace&quot;);
2037     return methods;
2038   }
2039   static typeArrayOop get_bcis(objArrayHandle chunk) {
2040     typeArrayOop bcis = typeArrayOop(chunk-&gt;obj_at(trace_bcis_offset));
2041     assert(bcis != NULL, &quot;bci array should be initialized in backtrace&quot;);
2042     return bcis;
2043   }
2044   static objArrayOop get_mirrors(objArrayHandle chunk) {
2045     objArrayOop mirrors = objArrayOop(chunk-&gt;obj_at(trace_mirrors_offset));
2046     assert(mirrors != NULL, &quot;mirror array should be initialized in backtrace&quot;);
2047     return mirrors;
2048   }
2049   static typeArrayOop get_names(objArrayHandle chunk) {
2050     typeArrayOop names = typeArrayOop(chunk-&gt;obj_at(trace_names_offset));
2051     assert(names != NULL, &quot;names array should be initialized in backtrace&quot;);
2052     return names;
2053   }
<span class="line-modified">2054   static bool has_hidden_top_frame(objArrayHandle chunk) {</span>
2055     oop hidden = chunk-&gt;obj_at(trace_hidden_offset);
<span class="line-modified">2056     return hidden != NULL;</span>
2057   }
2058 
2059  public:
2060 
2061   // constructor for new backtrace
<span class="line-modified">2062   BacktraceBuilder(TRAPS): _head(NULL), _methods(NULL), _bcis(NULL), _mirrors(NULL), _names(NULL), _has_hidden_top_frame(false) {</span>
2063     expand(CHECK);
2064     _backtrace = Handle(THREAD, _head);
2065     _index = 0;
2066   }
2067 
2068   BacktraceBuilder(Thread* thread, objArrayHandle backtrace) {
2069     _methods = get_methods(backtrace);
2070     _bcis = get_bcis(backtrace);
2071     _mirrors = get_mirrors(backtrace);
2072     _names = get_names(backtrace);
<span class="line-modified">2073     _has_hidden_top_frame = has_hidden_top_frame(backtrace);</span>
2074     assert(_methods-&gt;length() == _bcis-&gt;length() &amp;&amp;
2075            _methods-&gt;length() == _mirrors-&gt;length() &amp;&amp;
2076            _mirrors-&gt;length() == _names-&gt;length(),
2077            &quot;method and source information arrays should match&quot;);
2078 
2079     // head is the preallocated backtrace
2080     _head = backtrace();
2081     _backtrace = Handle(thread, _head);
2082     _index = 0;
2083   }
2084 
2085   void expand(TRAPS) {
2086     objArrayHandle old_head(THREAD, _head);
2087     PauseNoSafepointVerifier pnsv(&amp;_nsv);
2088 
2089     objArrayOop head = oopFactory::new_objectArray(trace_size, CHECK);
2090     objArrayHandle new_head(THREAD, head);
2091 
2092     typeArrayOop methods = oopFactory::new_shortArray(trace_chunk_size, CHECK);
2093     typeArrayHandle new_methods(THREAD, methods);
</pre>
<hr />
<pre>
2133       expand(CHECK);
2134       method = mhandle();
2135     }
2136 
2137     _methods-&gt;ushort_at_put(_index, method-&gt;orig_method_idnum());
2138     _bcis-&gt;int_at_put(_index, Backtrace::merge_bci_and_version(bci, method-&gt;constants()-&gt;version()));
2139 
2140     // Note:this doesn&#39;t leak symbols because the mirror in the backtrace keeps the
2141     // klass owning the symbols alive so their refcounts aren&#39;t decremented.
2142     Symbol* name = method-&gt;name();
2143     _names-&gt;symbol_at_put(_index, name);
2144 
2145     // We need to save the mirrors in the backtrace to keep the class
2146     // from being unloaded while we still have this stack trace.
2147     assert(method-&gt;method_holder()-&gt;java_mirror() != NULL, &quot;never push null for mirror&quot;);
2148     _mirrors-&gt;obj_at_put(_index, method-&gt;method_holder()-&gt;java_mirror());
2149     _index++;
2150   }
2151 
2152   void set_has_hidden_top_frame(TRAPS) {
<span class="line-modified">2153     if (!_has_hidden_top_frame) {</span>
2154       // It would be nice to add java/lang/Boolean::TRUE here
2155       // to indicate that this backtrace has a hidden top frame.
2156       // But this code is used before TRUE is allocated.
<span class="line-modified">2157       // Therefore let&#39;s just use an arbitrary legal oop</span>
<span class="line-modified">2158       // available right here. _methods is a short[].</span>

2159       assert(_methods != NULL, &quot;we need a legal oop&quot;);
<span class="line-modified">2160       _has_hidden_top_frame = true;</span>
<span class="line-modified">2161       _head-&gt;obj_at_put(trace_hidden_offset, _methods);</span>
2162     }
2163   }

2164 };
2165 
2166 struct BacktraceElement : public StackObj {
2167   int _method_id;
2168   int _bci;
2169   int _version;
2170   Symbol* _name;
2171   Handle _mirror;
2172   BacktraceElement(Handle mirror, int mid, int version, int bci, Symbol* name) :
2173                    _method_id(mid), _bci(bci), _version(version), _name(name), _mirror(mirror) {}
2174 };
2175 
2176 class BacktraceIterator : public StackObj {
2177   int _index;
2178   objArrayHandle  _result;
2179   objArrayHandle  _mirrors;
2180   typeArrayHandle _methods;
2181   typeArrayHandle _bcis;
2182   typeArrayHandle _names;
2183 
</pre>
<hr />
<pre>
2626 
2627   InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(bte._mirror()));
2628   assert(holder != NULL, &quot;first element should be non-null&quot;);
2629   Method* m = holder-&gt;method_with_orig_idnum(bte._method_id, bte._version);
2630 
2631   // Original version is no longer available.
2632   if (m == NULL || !version_matches(m, bte._version)) {
2633     return false;
2634   }
2635 
2636   *method = m;
2637   *bci = bte._bci;
2638   return true;
2639 }
2640 
2641 oop java_lang_StackTraceElement::create(const methodHandle&amp; method, int bci, TRAPS) {
2642   // Allocate java.lang.StackTraceElement instance
2643   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
2644   assert(k != NULL, &quot;must be loaded in 1.4+&quot;);
2645   if (k-&gt;should_be_initialized()) {
<span class="line-modified">2646     k-&gt;initialize(CHECK_NULL);</span>
2647   }
2648 
<span class="line-modified">2649   Handle element = k-&gt;allocate_instance_handle(CHECK_NULL);</span>
2650 
2651   int version = method-&gt;constants()-&gt;version();
<span class="line-modified">2652   fill_in(element, method-&gt;method_holder(), method, version, bci, method-&gt;name(), CHECK_NULL);</span>
2653   return element();
2654 }
2655 
2656 void java_lang_StackTraceElement::fill_in(Handle element,
2657                                           InstanceKlass* holder, const methodHandle&amp; method,
2658                                           int version, int bci, Symbol* name, TRAPS) {
2659   assert(element-&gt;is_a(SystemDictionary::StackTraceElement_klass()), &quot;sanity check&quot;);
2660 
2661   ResourceMark rm(THREAD);
2662   HandleMark hm(THREAD);
2663 
2664   // Fill in class name
2665   Handle java_class(THREAD, holder-&gt;java_mirror());
2666   oop classname = java_lang_Class::name(java_class, CHECK);
2667   java_lang_StackTraceElement::set_declaringClass(element(), classname);
2668   java_lang_StackTraceElement::set_declaringClassObject(element(), java_class());
2669 
2670   oop loader = holder-&gt;class_loader();
2671   if (loader != NULL) {
2672     oop loader_name = java_lang_ClassLoader::name(loader);
</pre>
<hr />
<pre>
3378 }
3379 
3380 #define UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(macro) \
3381   macro(_base_offset, k, &quot;base&quot;, object_signature, false)
3382 
3383 void reflect_UnsafeStaticFieldAccessorImpl::compute_offsets() {
3384   InstanceKlass* k = SystemDictionary::reflect_UnsafeStaticFieldAccessorImpl_klass();
3385   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3386 }
3387 
3388 #if INCLUDE_CDS
3389 void reflect_UnsafeStaticFieldAccessorImpl::serialize_offsets(SerializeClosure* f) {
3390   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3391 }
3392 #endif
3393 
3394 oop java_lang_boxing_object::initialize_and_allocate(BasicType type, TRAPS) {
3395   Klass* k = SystemDictionary::box_klass(type);
3396   if (k == NULL)  return NULL;
3397   InstanceKlass* ik = InstanceKlass::cast(k);
<span class="line-modified">3398   if (!ik-&gt;is_initialized())  ik-&gt;initialize(CHECK_NULL);</span>
3399   return ik-&gt;allocate_instance(THREAD);
3400 }
3401 
3402 
3403 oop java_lang_boxing_object::create(BasicType type, jvalue* value, TRAPS) {
<span class="line-modified">3404   oop box = initialize_and_allocate(type, CHECK_NULL);</span>
3405   if (box == NULL)  return NULL;
3406   switch (type) {
3407     case T_BOOLEAN:
3408       box-&gt;bool_field_put(value_offset, value-&gt;z);
3409       break;
3410     case T_CHAR:
3411       box-&gt;char_field_put(value_offset, value-&gt;c);
3412       break;
3413     case T_FLOAT:
3414       box-&gt;float_field_put(value_offset, value-&gt;f);
3415       break;
3416     case T_DOUBLE:
3417       box-&gt;double_field_put(long_value_offset, value-&gt;d);
3418       break;
3419     case T_BYTE:
3420       box-&gt;byte_field_put(value_offset, value-&gt;b);
3421       break;
3422     case T_SHORT:
3423       box-&gt;short_field_put(value_offset, value-&gt;s);
3424       break;
</pre>
<hr />
<pre>
4015   macro(_privilegedContext_offset, k, &quot;privilegedContext&quot;, accesscontrolcontext_signature, false); \
4016   macro(_isPrivileged_offset,      k, &quot;isPrivileged&quot;, bool_signature, false); \
4017   macro(_isAuthorized_offset,      k, &quot;isAuthorized&quot;, bool_signature, false)
4018 
4019 void java_security_AccessControlContext::compute_offsets() {
4020   assert(_isPrivileged_offset == 0, &quot;offsets should be initialized only once&quot;);
4021   InstanceKlass* k = SystemDictionary::AccessControlContext_klass();
4022   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4023 }
4024 
4025 #if INCLUDE_CDS
4026 void java_security_AccessControlContext::serialize_offsets(SerializeClosure* f) {
4027   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4028 }
4029 #endif
4030 
4031 oop java_security_AccessControlContext::create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS) {
4032   assert(_isPrivileged_offset != 0, &quot;offsets should have been initialized&quot;);
4033   assert(_isAuthorized_offset != -1, &quot;offsets should have been initialized&quot;);
4034   // Ensure klass is initialized
<span class="line-modified">4035   SystemDictionary::AccessControlContext_klass()-&gt;initialize(CHECK_NULL);</span>
4036   // Allocate result
<span class="line-modified">4037   oop result = SystemDictionary::AccessControlContext_klass()-&gt;allocate_instance(CHECK_NULL);</span>
4038   // Fill in values
4039   result-&gt;obj_field_put(_context_offset, context());
4040   result-&gt;obj_field_put(_privilegedContext_offset, privileged_context());
4041   result-&gt;bool_field_put(_isPrivileged_offset, isPrivileged);
4042   // whitelist AccessControlContexts created by the JVM
4043   result-&gt;bool_field_put(_isAuthorized_offset, true);
4044   return result;
4045 }
4046 
4047 
4048 // Support for java_lang_ClassLoader
4049 
4050 bool java_lang_ClassLoader::offsets_computed = false;
4051 int  java_lang_ClassLoader::_loader_data_offset = -1;
4052 int  java_lang_ClassLoader::parallelCapable_offset = -1;
4053 int  java_lang_ClassLoader::name_offset = -1;
4054 int  java_lang_ClassLoader::nameAndId_offset = -1;
4055 int  java_lang_ClassLoader::unnamedModule_offset = -1;
4056 
4057 ClassLoaderData* java_lang_ClassLoader::loader_data_acquire(oop loader) {
</pre>
<hr />
<pre>
4761 // Invoked before SystemDictionary::initialize, so pre-loaded classes
4762 // are not available to determine the offset_of_static_fields.
4763 void JavaClasses::compute_hard_coded_offsets() {
4764 
4765   // java_lang_boxing_object
4766   java_lang_boxing_object::value_offset      = member_offset(java_lang_boxing_object::hc_value_offset);
4767   java_lang_boxing_object::long_value_offset = align_up(member_offset(java_lang_boxing_object::hc_value_offset), BytesPerLong);
4768 
4769   // java_lang_ref_Reference
4770   java_lang_ref_Reference::referent_offset    = member_offset(java_lang_ref_Reference::hc_referent_offset);
4771   java_lang_ref_Reference::queue_offset       = member_offset(java_lang_ref_Reference::hc_queue_offset);
4772   java_lang_ref_Reference::next_offset        = member_offset(java_lang_ref_Reference::hc_next_offset);
4773   java_lang_ref_Reference::discovered_offset  = member_offset(java_lang_ref_Reference::hc_discovered_offset);
4774 }
4775 
4776 #define DO_COMPUTE_OFFSETS(k) k::compute_offsets();
4777 
4778 // Compute non-hard-coded field offsets of all the classes in this file
4779 void JavaClasses::compute_offsets() {
4780   if (UseSharedSpaces) {
<span class="line-modified">4781     JVMTI_ONLY(assert(JvmtiExport::is_early_phase() &amp;&amp; !(JvmtiExport::should_post_class_file_load_hook() &amp;&amp;</span>
<span class="line-modified">4782                                                          JvmtiExport::has_early_class_hook_env()),</span>
<span class="line-modified">4783                       &quot;JavaClasses::compute_offsets() must be called in early JVMTI phase.&quot;));</span>
4784     // None of the classes used by the rest of this function can be replaced by
4785     // JMVTI ClassFileLoadHook.
4786     // We are safe to use the archived offsets, which have already been restored
4787     // by JavaClasses::serialize_offsets, without computing the offsets again.
4788     return;
4789   }
4790 
4791   // We have already called the compute_offsets() of the
4792   // BASIC_JAVA_CLASSES_DO_PART1 classes (java_lang_String and java_lang_Class)
4793   // earlier inside SystemDictionary::resolve_well_known_classes()
4794   BASIC_JAVA_CLASSES_DO_PART2(DO_COMPUTE_OFFSETS);
4795 }
4796 
4797 #if INCLUDE_CDS
4798 #define DO_SERIALIZE_OFFSETS(k) k::serialize_offsets(soc);
4799 
4800 void JavaClasses::serialize_offsets(SerializeClosure* soc) {
4801   BASIC_JAVA_CLASSES_DO(DO_SERIALIZE_OFFSETS);
4802 }
4803 #endif
</pre>
</td>
</tr>
</table>
<center><a href="fieldLayoutBuilder.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="modules.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/os_cpu/solaris_x86/os_solaris_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 // no precompiled headers
 26 #include &quot;jvm.h&quot;
 27 #include &quot;asm/macroAssembler.hpp&quot;
 28 #include &quot;classfile/classLoader.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;classfile/vmSymbols.hpp&quot;
 31 #include &quot;code/codeCache.hpp&quot;
 32 #include &quot;code/icBuffer.hpp&quot;
 33 #include &quot;code/vtableStubs.hpp&quot;
 34 #include &quot;interpreter/interpreter.hpp&quot;
 35 #include &quot;logging/log.hpp&quot;
 36 #include &quot;memory/allocation.inline.hpp&quot;
 37 #include &quot;os_share_solaris.hpp&quot;
 38 #include &quot;prims/jniFastGetField.hpp&quot;
 39 #include &quot;prims/jvm_misc.hpp&quot;
 40 #include &quot;runtime/arguments.hpp&quot;
 41 #include &quot;runtime/extendedPC.hpp&quot;
 42 #include &quot;runtime/frame.inline.hpp&quot;
 43 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 44 #include &quot;runtime/java.hpp&quot;
 45 #include &quot;runtime/javaCalls.hpp&quot;
 46 #include &quot;runtime/mutexLocker.hpp&quot;
 47 #include &quot;runtime/osThread.hpp&quot;
 48 #include &quot;runtime/sharedRuntime.hpp&quot;
 49 #include &quot;runtime/stubRoutines.hpp&quot;
 50 #include &quot;runtime/thread.inline.hpp&quot;
 51 #include &quot;runtime/timer.hpp&quot;
 52 #include &quot;utilities/align.hpp&quot;
 53 #include &quot;utilities/events.hpp&quot;
 54 #include &quot;utilities/vmError.hpp&quot;
 55 
 56 // put OS-includes here
 57 # include &lt;sys/types.h&gt;
 58 # include &lt;sys/mman.h&gt;
 59 # include &lt;pthread.h&gt;
 60 # include &lt;signal.h&gt;
 61 # include &lt;setjmp.h&gt;
 62 # include &lt;errno.h&gt;
 63 # include &lt;dlfcn.h&gt;
 64 # include &lt;stdio.h&gt;
 65 # include &lt;unistd.h&gt;
 66 # include &lt;sys/resource.h&gt;
 67 # include &lt;thread.h&gt;
 68 # include &lt;sys/stat.h&gt;
 69 # include &lt;sys/time.h&gt;
 70 # include &lt;sys/filio.h&gt;
 71 # include &lt;sys/utsname.h&gt;
 72 # include &lt;sys/systeminfo.h&gt;
 73 # include &lt;sys/socket.h&gt;
 74 # include &lt;sys/trap.h&gt;
 75 # include &lt;sys/lwp.h&gt;
 76 # include &lt;poll.h&gt;
 77 # include &lt;sys/lwp.h&gt;
 78 # include &lt;procfs.h&gt;     //  see comment in &lt;sys/procfs.h&gt;
 79 
 80 #ifndef AMD64
 81 // QQQ seems useless at this point
 82 # define _STRUCTURED_PROC 1  //  this gets us the new structured proc interfaces of 5.6 &amp; later
 83 #endif // AMD64
 84 # include &lt;sys/procfs.h&gt;     //  see comment in &lt;sys/procfs.h&gt;
 85 
 86 
 87 #define MAX_PATH (2 * K)
 88 
 89 // Minimum usable stack sizes required to get to user code. Space for
 90 // HotSpot guard pages is added later.
 91 #ifdef _LP64
 92 // The adlc generated method &#39;State::MachNodeGenerator(int)&#39; used by the C2 compiler
 93 // threads requires a large stack with the Solaris Studio C++ compiler version 5.13
 94 // and product VM builds (debug builds require significantly less stack space).
 95 size_t os::Posix::_compiler_thread_min_stack_allowed = 325 * K;
 96 size_t os::Posix::_java_thread_min_stack_allowed = 48 * K;
 97 size_t os::Posix::_vm_internal_thread_min_stack_allowed = 224 * K;
 98 #else
 99 size_t os::Posix::_compiler_thread_min_stack_allowed = 32 * K;
100 size_t os::Posix::_java_thread_min_stack_allowed = 32 * K;
101 size_t os::Posix::_vm_internal_thread_min_stack_allowed = 64 * K;
102 #endif // _LP64
103 
104 #ifdef AMD64
105 #define REG_SP REG_RSP
106 #define REG_PC REG_RIP
107 #define REG_FP REG_RBP
108 #else
109 #define REG_SP UESP
110 #define REG_PC EIP
111 #define REG_FP EBP
112 // 4900493 counter to prevent runaway LDTR refresh attempt
113 
114 static volatile int ldtr_refresh = 0;
115 // the libthread instruction that faults because of the stale LDTR
116 
117 static const unsigned char movlfs[] = { 0x8e, 0xe0    // movl %eax,%fs
118                        };
119 #endif // AMD64
120 
121 char* os::non_memory_address_word() {
122   // Must never look like an address returned by reserve_memory,
123   // even in its subfields (as defined by the CPU immediate fields,
124   // if the CPU splits constants across multiple instructions).
125   return (char*) -1;
126 }
127 
128 //
129 // Validate a ucontext retrieved from walking a uc_link of a ucontext.
130 // There are issues with libthread giving out uc_links for different threads
131 // on the same uc_link chain and bad or circular links.
132 //
133 bool os::Solaris::valid_ucontext(Thread* thread, const ucontext_t* valid, const ucontext_t* suspect) {
134   if (valid &gt;= suspect ||
135       valid-&gt;uc_stack.ss_flags != suspect-&gt;uc_stack.ss_flags ||
136       valid-&gt;uc_stack.ss_sp    != suspect-&gt;uc_stack.ss_sp    ||
137       valid-&gt;uc_stack.ss_size  != suspect-&gt;uc_stack.ss_size) {
138     DEBUG_ONLY(tty-&gt;print_cr(&quot;valid_ucontext: failed test 1&quot;);)
139     return false;
140   }
141 
142   if (thread-&gt;is_Java_thread()) {
<a name="2" id="anc2"></a><span class="line-modified">143     if (!thread-&gt;is_in_full_stack((address)suspect)) {</span>
144       DEBUG_ONLY(tty-&gt;print_cr(&quot;valid_ucontext: uc_link not in thread stack&quot;);)
145       return false;
146     }
<a name="3" id="anc3"></a><span class="line-modified">147     if (!thread-&gt;is_in_full_stack((address) suspect-&gt;uc_mcontext.gregs[REG_SP])) {</span>
148       DEBUG_ONLY(tty-&gt;print_cr(&quot;valid_ucontext: stackpointer not in thread stack&quot;);)
149       return false;
150     }
151   }
152   return true;
153 }
154 
155 // We will only follow one level of uc_link since there are libthread
156 // issues with ucontext linking and it is better to be safe and just
157 // let caller retry later.
158 const ucontext_t* os::Solaris::get_valid_uc_in_signal_handler(Thread *thread,
159   const ucontext_t *uc) {
160 
161   const ucontext_t *retuc = NULL;
162 
163   if (uc != NULL) {
164     if (uc-&gt;uc_link == NULL) {
165       // cannot validate without uc_link so accept current ucontext
166       retuc = uc;
167     } else if (os::Solaris::valid_ucontext(thread, uc, uc-&gt;uc_link)) {
168       // first ucontext is valid so try the next one
169       uc = uc-&gt;uc_link;
170       if (uc-&gt;uc_link == NULL) {
171         // cannot validate without uc_link so accept current ucontext
172         retuc = uc;
173       } else if (os::Solaris::valid_ucontext(thread, uc, uc-&gt;uc_link)) {
174         // the ucontext one level down is also valid so return it
175         retuc = uc;
176       }
177     }
178   }
179   return retuc;
180 }
181 
182 // Assumes ucontext is valid
183 ExtendedPC os::Solaris::ucontext_get_ExtendedPC(const ucontext_t *uc) {
184   return ExtendedPC((address)uc-&gt;uc_mcontext.gregs[REG_PC]);
185 }
186 
187 void os::Solaris::ucontext_set_pc(ucontext_t* uc, address pc) {
188   uc-&gt;uc_mcontext.gregs [REG_PC]  = (greg_t) pc;
189 }
190 
191 // Assumes ucontext is valid
192 intptr_t* os::Solaris::ucontext_get_sp(const ucontext_t *uc) {
193   return (intptr_t*)uc-&gt;uc_mcontext.gregs[REG_SP];
194 }
195 
196 // Assumes ucontext is valid
197 intptr_t* os::Solaris::ucontext_get_fp(const ucontext_t *uc) {
198   return (intptr_t*)uc-&gt;uc_mcontext.gregs[REG_FP];
199 }
200 
201 address os::Solaris::ucontext_get_pc(const ucontext_t *uc) {
202   return (address) uc-&gt;uc_mcontext.gregs[REG_PC];
203 }
204 
205 // For Forte Analyzer AsyncGetCallTrace profiling support - thread
206 // is currently interrupted by SIGPROF.
207 //
208 // The difference between this and os::fetch_frame_from_context() is that
209 // here we try to skip nested signal frames.
210 // This method is also used for stack overflow signal handling.
211 ExtendedPC os::Solaris::fetch_frame_from_ucontext(Thread* thread,
212   const ucontext_t* uc, intptr_t** ret_sp, intptr_t** ret_fp) {
213 
214   assert(thread != NULL, &quot;just checking&quot;);
215   assert(ret_sp != NULL, &quot;just checking&quot;);
216   assert(ret_fp != NULL, &quot;just checking&quot;);
217 
218   const ucontext_t *luc = os::Solaris::get_valid_uc_in_signal_handler(thread, uc);
219   return os::fetch_frame_from_context(luc, ret_sp, ret_fp);
220 }
221 
222 ExtendedPC os::fetch_frame_from_context(const void* ucVoid,
223                     intptr_t** ret_sp, intptr_t** ret_fp) {
224 
225   ExtendedPC  epc;
226   const ucontext_t *uc = (const ucontext_t*)ucVoid;
227 
228   if (uc != NULL) {
229     epc = os::Solaris::ucontext_get_ExtendedPC(uc);
230     if (ret_sp) *ret_sp = os::Solaris::ucontext_get_sp(uc);
231     if (ret_fp) *ret_fp = os::Solaris::ucontext_get_fp(uc);
232   } else {
233     // construct empty ExtendedPC for return value checking
234     epc = ExtendedPC(NULL);
235     if (ret_sp) *ret_sp = (intptr_t *)NULL;
236     if (ret_fp) *ret_fp = (intptr_t *)NULL;
237   }
238 
239   return epc;
240 }
241 
242 frame os::fetch_frame_from_context(const void* ucVoid) {
243   intptr_t* sp;
244   intptr_t* fp;
245   ExtendedPC epc = fetch_frame_from_context(ucVoid, &amp;sp, &amp;fp);
246   return frame(sp, fp, epc.pc());
247 }
248 
249 frame os::fetch_frame_from_ucontext(Thread* thread, void* ucVoid) {
250   intptr_t* sp;
251   intptr_t* fp;
252   ExtendedPC epc = os::Solaris::fetch_frame_from_ucontext(thread, (ucontext_t*)ucVoid, &amp;sp, &amp;fp);
253   return frame(sp, fp, epc.pc());
254 }
255 
256 bool os::Solaris::get_frame_at_stack_banging_point(JavaThread* thread, ucontext_t* uc, frame* fr) {
257  address pc = (address) os::Solaris::ucontext_get_pc(uc);
258   if (Interpreter::contains(pc)) {
259     // interpreter performs stack banging after the fixed frame header has
260     // been generated while the compilers perform it before. To maintain
261     // semantic consistency between interpreted and compiled frames, the
262     // method returns the Java sender of the current frame.
263     *fr = os::fetch_frame_from_ucontext(thread, uc);
264     if (!fr-&gt;is_first_java_frame()) {
265       // get_frame_at_stack_banging_point() is only called when we
266       // have well defined stacks so java_sender() calls do not need
267       // to assert safe_for_sender() first.
268       *fr = fr-&gt;java_sender();
269     }
270   } else {
271     // more complex code with compiled code
272     assert(!Interpreter::contains(pc), &quot;Interpreted methods should have been handled above&quot;);
273     CodeBlob* cb = CodeCache::find_blob(pc);
274     if (cb == NULL || !cb-&gt;is_nmethod() || cb-&gt;is_frame_complete_at(pc)) {
275       // Not sure where the pc points to, fallback to default
276       // stack overflow handling
277       return false;
278     } else {
279       // in compiled code, the stack banging is performed just after the return pc
280       // has been pushed on the stack
281       intptr_t* fp = os::Solaris::ucontext_get_fp(uc);
282       intptr_t* sp = os::Solaris::ucontext_get_sp(uc);
283       *fr = frame(sp + 1, fp, (address)*sp);
284       if (!fr-&gt;is_java_frame()) {
285         // See java_sender() comment above.
286         *fr = fr-&gt;java_sender();
287       }
288     }
289   }
290   assert(fr-&gt;is_java_frame(), &quot;Safety check&quot;);
291   return true;
292 }
293 
294 frame os::get_sender_for_C_frame(frame* fr) {
295   return frame(fr-&gt;sender_sp(), fr-&gt;link(), fr-&gt;sender_pc());
296 }
297 
298 extern &quot;C&quot; intptr_t *_get_current_sp();  // in .il file
299 
300 address os::current_stack_pointer() {
301   return (address)_get_current_sp();
302 }
303 
304 extern &quot;C&quot; intptr_t *_get_current_fp();  // in .il file
305 
306 frame os::current_frame() {
307   intptr_t* fp = _get_current_fp();  // it&#39;s inlined so want current fp
308   // fp is for os::current_frame. We want the fp for our caller.
309   frame myframe((intptr_t*)os::current_stack_pointer(),
310                 (intptr_t*)fp,
311                 CAST_FROM_FN_PTR(address, os::current_frame));
312   frame caller_frame = os::get_sender_for_C_frame(&amp;myframe);
313 
314   if (os::is_first_C_frame(&amp;caller_frame)) {
315     // stack is not walkable
316     frame ret; // This will be a null useless frame
317     return ret;
318   } else {
319     // return frame for our caller&#39;s caller
320     return os::get_sender_for_C_frame(&amp;caller_frame);
321   }
322 }
323 
324 #ifndef AMD64
325 
326 // Detecting SSE support by OS
327 // From solaris_i486.s
328 extern &quot;C&quot; bool sse_check();
329 extern &quot;C&quot; bool sse_unavailable();
330 
331 enum { SSE_UNKNOWN, SSE_NOT_SUPPORTED, SSE_SUPPORTED};
332 static int sse_status = SSE_UNKNOWN;
333 
334 
335 static void  check_for_sse_support() {
336   if (!VM_Version::supports_sse()) {
337     sse_status = SSE_NOT_SUPPORTED;
338     return;
339   }
340   // looking for _sse_hw in libc.so, if it does not exist or
341   // the value (int) is 0, OS has no support for SSE
342   int *sse_hwp;
343   void *h;
344 
345   if ((h=dlopen(&quot;/usr/lib/libc.so&quot;, RTLD_LAZY)) == NULL) {
346     //open failed, presume no support for SSE
347     sse_status = SSE_NOT_SUPPORTED;
348     return;
349   }
350   if ((sse_hwp = (int *)dlsym(h, &quot;_sse_hw&quot;)) == NULL) {
351     sse_status = SSE_NOT_SUPPORTED;
352   } else if (*sse_hwp == 0) {
353     sse_status = SSE_NOT_SUPPORTED;
354   }
355   dlclose(h);
356 
357   if (sse_status == SSE_UNKNOWN) {
358     bool (*try_sse)() = (bool (*)())sse_check;
359     sse_status = (*try_sse)() ? SSE_SUPPORTED : SSE_NOT_SUPPORTED;
360   }
361 
362 }
363 
364 #endif // AMD64
365 
366 bool os::supports_sse() {
367 #ifdef AMD64
368   return true;
369 #else
370   if (sse_status == SSE_UNKNOWN)
371     check_for_sse_support();
372   return sse_status == SSE_SUPPORTED;
373 #endif // AMD64
374 }
375 
376 bool os::is_allocatable(size_t bytes) {
377 #ifdef AMD64
378   return true;
379 #else
380 
381   if (bytes &lt; 2 * G) {
382     return true;
383   }
384 
385   char* addr = reserve_memory(bytes, NULL);
386 
387   if (addr != NULL) {
388     release_memory(addr, bytes);
389   }
390 
391   return addr != NULL;
392 #endif // AMD64
393 
394 }
395 
396 extern &quot;C&quot; JNIEXPORT int
397 JVM_handle_solaris_signal(int sig, siginfo_t* info, void* ucVoid,
398                           int abort_if_unrecognized) {
399   ucontext_t* uc = (ucontext_t*) ucVoid;
400 
401 #ifndef AMD64
402   if (sig == SIGILL &amp;&amp; info-&gt;si_addr == (caddr_t)sse_check) {
403     // the SSE instruction faulted. supports_sse() need return false.
404     uc-&gt;uc_mcontext.gregs[EIP] = (greg_t)sse_unavailable;
405     return true;
406   }
407 #endif // !AMD64
408 
409   Thread* t = Thread::current_or_null_safe();
410 
411   // Must do this before SignalHandlerMark, if crash protection installed we will longjmp away
412   // (no destructors can be run)
413   os::ThreadCrashProtection::check_crash_protection(sig, t);
414 
415   SignalHandlerMark shm(t);
416 
417   if(sig == SIGPIPE || sig == SIGXFSZ) {
418     if (os::Solaris::chained_handler(sig, info, ucVoid)) {
419       return true;
420     } else {
421       // Ignoring SIGPIPE/SIGXFSZ - see bugs 4229104 or 6499219
422       return true;
423     }
424   }
425 
426   JavaThread* thread = NULL;
427   VMThread* vmthread = NULL;
428 
429   if (os::Solaris::signal_handlers_are_installed) {
430     if (t != NULL ){
431       if(t-&gt;is_Java_thread()) {
432         thread = (JavaThread*)t;
433       }
434       else if(t-&gt;is_VM_thread()){
435         vmthread = (VMThread *)t;
436       }
437     }
438   }
439 
440   if (sig == ASYNC_SIGNAL) {
441     if(thread || vmthread){
442       OSThread::SR_handler(t, uc);
443       return true;
444     } else if (os::Solaris::chained_handler(sig, info, ucVoid)) {
445       return true;
446     } else {
447       // If ASYNC_SIGNAL not chained, and this is a non-vm and
448       // non-java thread
449       return true;
450     }
451   }
452 
453   if (info == NULL || info-&gt;si_code &lt;= 0 || info-&gt;si_code == SI_NOINFO) {
454     // can&#39;t decode this kind of signal
455     info = NULL;
456   } else {
457     assert(sig == info-&gt;si_signo, &quot;bad siginfo&quot;);
458   }
459 
460   // decide if this trap can be handled by a stub
461   address stub = NULL;
462 
463   address pc          = NULL;
464 
465   //%note os_trap_1
466   if (info != NULL &amp;&amp; uc != NULL &amp;&amp; thread != NULL) {
467     // factor me: getPCfromContext
468     pc = (address) uc-&gt;uc_mcontext.gregs[REG_PC];
469 
470     if (StubRoutines::is_safefetch_fault(pc)) {
471       os::Solaris::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));
472       return true;
473     }
474 
475     // Handle ALL stack overflow variations here
476     if (sig == SIGSEGV &amp;&amp; info-&gt;si_code == SEGV_ACCERR) {
477       address addr = (address) info-&gt;si_addr;
478       if (thread-&gt;in_stack_yellow_reserved_zone(addr)) {
479         if (thread-&gt;thread_state() == _thread_in_Java) {
480           if (thread-&gt;in_stack_reserved_zone(addr)) {
481             frame fr;
482             if (os::Solaris::get_frame_at_stack_banging_point(thread, uc, &amp;fr)) {
483               assert(fr.is_java_frame(), &quot;Must be Java frame&quot;);
484               frame activation = SharedRuntime::look_for_reserved_stack_annotated_method(thread, fr);
485               if (activation.sp() != NULL) {
486                 thread-&gt;disable_stack_reserved_zone();
487                 if (activation.is_interpreted_frame()) {
488                   thread-&gt;set_reserved_stack_activation((address)(
489                     activation.fp() + frame::interpreter_frame_initial_sp_offset));
490                 } else {
491                   thread-&gt;set_reserved_stack_activation((address)activation.unextended_sp());
492                 }
493                 return true;
494               }
495             }
496           }
497           // Throw a stack overflow exception.  Guard pages will be reenabled
498           // while unwinding the stack.
499           thread-&gt;disable_stack_yellow_reserved_zone();
500           stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW);
501         } else {
502           // Thread was in the vm or native code.  Return and try to finish.
503           thread-&gt;disable_stack_yellow_reserved_zone();
504           return true;
505         }
506       } else if (thread-&gt;in_stack_red_zone(addr)) {
507         // Fatal red zone violation.  Disable the guard pages and fall through
508         // to handle_unexpected_exception way down below.
509         thread-&gt;disable_stack_red_zone();
510         tty-&gt;print_raw_cr(&quot;An irrecoverable stack overflow has occurred.&quot;);
511       }
512     }
513 
514     if ((sig == SIGSEGV) &amp;&amp; VM_Version::is_cpuinfo_segv_addr(pc)) {
515       // Verify that OS save/restore AVX registers.
516       stub = VM_Version::cpuinfo_cont_addr();
517     }
518 
519     if (thread-&gt;thread_state() == _thread_in_vm ||
520          thread-&gt;thread_state() == _thread_in_native) {
521       if (sig == SIGBUS &amp;&amp; info-&gt;si_code == BUS_OBJERR &amp;&amp; thread-&gt;doing_unsafe_access()) {
522         address next_pc = Assembler::locate_next_instruction(pc);
523         if (UnsafeCopyMemory::contains_pc(pc)) {
524           next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);
525         }
526         stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
527       }
528     }
529 
530     if (thread-&gt;thread_state() == _thread_in_Java) {
531       // Support Safepoint Polling
532       if ( sig == SIGSEGV &amp;&amp; os::is_poll_address((address)info-&gt;si_addr)) {
533         stub = SharedRuntime::get_poll_stub(pc);
534       }
535       else if (sig == SIGBUS &amp;&amp; info-&gt;si_code == BUS_OBJERR) {
536         // BugId 4454115: A read from a MappedByteBuffer can fault
537         // here if the underlying file has been truncated.
538         // Do not crash the VM in such a case.
539         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
540         if (cb != NULL) {
541           CompiledMethod* nm = cb-&gt;as_compiled_method_or_null();
542           bool is_unsafe_arraycopy = thread-&gt;doing_unsafe_access() &amp;&amp; UnsafeCopyMemory::contains_pc(pc);
543           if ((nm != NULL &amp;&amp; nm-&gt;has_unsafe_access()) || is_unsafe_arraycopy) {
544             address next_pc = Assembler::locate_next_instruction(pc);
545             if (is_unsafe_arraycopy) {
546               next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);
547             }
548             stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
549           }
550         }
551       }
552       else
553       if (sig == SIGFPE &amp;&amp; info-&gt;si_code == FPE_INTDIV) {
554         // integer divide by zero
555         stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);
556       }
557 #ifndef AMD64
558       else if (sig == SIGFPE &amp;&amp; info-&gt;si_code == FPE_FLTDIV) {
559         // floating-point divide by zero
560         stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);
561       }
562       else if (sig == SIGFPE &amp;&amp; info-&gt;si_code == FPE_FLTINV) {
563         // The encoding of D2I in i486.ad can cause an exception prior
564         // to the fist instruction if there was an invalid operation
565         // pending. We want to dismiss that exception. From the win_32
566         // side it also seems that if it really was the fist causing
567         // the exception that we do the d2i by hand with different
568         // rounding. Seems kind of weird. QQQ TODO
569         // Note that we take the exception at the NEXT floating point instruction.
570         if (pc[0] == 0xDB) {
571             assert(pc[0] == 0xDB, &quot;not a FIST opcode&quot;);
572             assert(pc[1] == 0x14, &quot;not a FIST opcode&quot;);
573             assert(pc[2] == 0x24, &quot;not a FIST opcode&quot;);
574             return true;
575         } else {
576             assert(pc[-3] == 0xDB, &quot;not an flt invalid opcode&quot;);
577             assert(pc[-2] == 0x14, &quot;not an flt invalid opcode&quot;);
578             assert(pc[-1] == 0x24, &quot;not an flt invalid opcode&quot;);
579         }
580       }
581       else if (sig == SIGFPE ) {
582         tty-&gt;print_cr(&quot;caught SIGFPE, info 0x%x.&quot;, info-&gt;si_code);
583       }
584 #endif // !AMD64
585 
586         // QQQ It doesn&#39;t seem that we need to do this on x86 because we should be able
587         // to return properly from the handler without this extra stuff on the back side.
588 
589       else if (sig == SIGSEGV &amp;&amp; info-&gt;si_code &gt; 0 &amp;&amp;
590                MacroAssembler::uses_implicit_null_check(info-&gt;si_addr)) {
591         // Determination of interpreter/vtable stub/compiled code null exception
592         stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
593       }
594     }
595 
596     // jni_fast_Get&lt;Primitive&gt;Field can trap at certain pc&#39;s if a GC kicks in
597     // and the heap gets shrunk before the field access.
598     if ((sig == SIGSEGV) || (sig == SIGBUS)) {
599       address addr = JNI_FastGetField::find_slowcase_pc(pc);
600       if (addr != (address)-1) {
601         stub = addr;
602       }
603     }
604   }
605 
606   // Execution protection violation
607   //
608   // Preventative code for future versions of Solaris which may
609   // enable execution protection when running the 32-bit VM on AMD64.
610   //
611   // This should be kept as the last step in the triage.  We don&#39;t
612   // have a dedicated trap number for a no-execute fault, so be
613   // conservative and allow other handlers the first shot.
614   //
615   // Note: We don&#39;t test that info-&gt;si_code == SEGV_ACCERR here.
616   // this si_code is so generic that it is almost meaningless; and
617   // the si_code for this condition may change in the future.
618   // Furthermore, a false-positive should be harmless.
619   if (UnguardOnExecutionViolation &gt; 0 &amp;&amp;
620       (sig == SIGSEGV || sig == SIGBUS) &amp;&amp;
621       uc-&gt;uc_mcontext.gregs[TRAPNO] == T_PGFLT) {  // page fault
622     int page_size = os::vm_page_size();
623     address addr = (address) info-&gt;si_addr;
624     address pc = (address) uc-&gt;uc_mcontext.gregs[REG_PC];
625     // Make sure the pc and the faulting address are sane.
626     //
627     // If an instruction spans a page boundary, and the page containing
628     // the beginning of the instruction is executable but the following
629     // page is not, the pc and the faulting address might be slightly
630     // different - we still want to unguard the 2nd page in this case.
631     //
632     // 15 bytes seems to be a (very) safe value for max instruction size.
633     bool pc_is_near_addr =
634       (pointer_delta((void*) addr, (void*) pc, sizeof(char)) &lt; 15);
635     bool instr_spans_page_boundary =
636       (align_down((intptr_t) pc ^ (intptr_t) addr,
637                        (intptr_t) page_size) &gt; 0);
638 
639     if (pc == addr || (pc_is_near_addr &amp;&amp; instr_spans_page_boundary)) {
640       static volatile address last_addr =
641         (address) os::non_memory_address_word();
642 
643       // In conservative mode, don&#39;t unguard unless the address is in the VM
644       if (addr != last_addr &amp;&amp;
645           (UnguardOnExecutionViolation &gt; 1 || os::address_is_in_vm(addr))) {
646 
647         // Make memory rwx and retry
648         address page_start = align_down(addr, page_size);
649         bool res = os::protect_memory((char*) page_start, page_size,
650                                       os::MEM_PROT_RWX);
651 
652         log_debug(os)(&quot;Execution protection violation &quot;
653                       &quot;at &quot; INTPTR_FORMAT
654                       &quot;, unguarding &quot; INTPTR_FORMAT &quot;: %s, errno=%d&quot;, p2i(addr),
655                       p2i(page_start), (res ? &quot;success&quot; : &quot;failed&quot;), errno);
656         stub = pc;
657 
658         // Set last_addr so if we fault again at the same address, we don&#39;t end
659         // up in an endless loop.
660         //
661         // There are two potential complications here.  Two threads trapping at
662         // the same address at the same time could cause one of the threads to
663         // think it already unguarded, and abort the VM.  Likely very rare.
664         //
665         // The other race involves two threads alternately trapping at
666         // different addresses and failing to unguard the page, resulting in
667         // an endless loop.  This condition is probably even more unlikely than
668         // the first.
669         //
670         // Although both cases could be avoided by using locks or thread local
671         // last_addr, these solutions are unnecessary complication: this
672         // handler is a best-effort safety net, not a complete solution.  It is
673         // disabled by default and should only be used as a workaround in case
674         // we missed any no-execute-unsafe VM code.
675 
676         last_addr = addr;
677       }
678     }
679   }
680 
681   if (stub != NULL) {
682     // save all thread context in case we need to restore it
683 
684     if (thread != NULL) thread-&gt;set_saved_exception_pc(pc);
685     // 12/02/99: On Sparc it appears that the full context is also saved
686     // but as yet, no one looks at or restores that saved context
687     os::Solaris::ucontext_set_pc(uc, stub);
688     return true;
689   }
690 
691   // signal-chaining
692   if (os::Solaris::chained_handler(sig, info, ucVoid)) {
693     return true;
694   }
695 
696   if (!abort_if_unrecognized) {
697     // caller wants another chance, so give it to him
698     return false;
699   }
700 
701   if (!os::Solaris::libjsig_is_loaded) {
702     struct sigaction oldAct;
703     sigaction(sig, (struct sigaction *)0, &amp;oldAct);
704     if (oldAct.sa_sigaction != signalHandler) {
705       void* sighand = oldAct.sa_sigaction ? CAST_FROM_FN_PTR(void*,  oldAct.sa_sigaction)
706                                           : CAST_FROM_FN_PTR(void*, oldAct.sa_handler);
707       warning(&quot;Unexpected Signal %d occurred under user-defined signal handler %#lx&quot;, sig, (long)sighand);
708     }
709   }
710 
711   if (pc == NULL &amp;&amp; uc != NULL) {
712     pc = (address) uc-&gt;uc_mcontext.gregs[REG_PC];
713   }
714 
715   // unmask current signal
716   sigset_t newset;
717   sigemptyset(&amp;newset);
718   sigaddset(&amp;newset, sig);
719   sigprocmask(SIG_UNBLOCK, &amp;newset, NULL);
720 
721   // Determine which sort of error to throw.  Out of swap may signal
722   // on the thread stack, which could get a mapping error when touched.
723   address addr = (address) info-&gt;si_addr;
724   if (sig == SIGBUS &amp;&amp; info-&gt;si_code == BUS_OBJERR &amp;&amp; info-&gt;si_errno == ENOMEM) {
725     vm_exit_out_of_memory(0, OOM_MMAP_ERROR, &quot;Out of swap space to map in thread stack.&quot;);
726   }
727 
728   VMError::report_and_die(t, sig, pc, info, ucVoid);
729 
730   ShouldNotReachHere();
731   return false;
732 }
733 
734 void os::print_context(outputStream *st, const void *context) {
735   if (context == NULL) return;
736 
737   const ucontext_t *uc = (const ucontext_t*)context;
738   st-&gt;print_cr(&quot;Registers:&quot;);
739 #ifdef AMD64
740   st-&gt;print(  &quot;RAX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RAX]);
741   st-&gt;print(&quot;, RBX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RBX]);
742   st-&gt;print(&quot;, RCX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RCX]);
743   st-&gt;print(&quot;, RDX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RDX]);
744   st-&gt;cr();
745   st-&gt;print(  &quot;RSP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RSP]);
746   st-&gt;print(&quot;, RBP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RBP]);
747   st-&gt;print(&quot;, RSI=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RSI]);
748   st-&gt;print(&quot;, RDI=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RDI]);
749   st-&gt;cr();
750   st-&gt;print(  &quot;R8 =&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R8]);
751   st-&gt;print(&quot;, R9 =&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R9]);
752   st-&gt;print(&quot;, R10=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R10]);
753   st-&gt;print(&quot;, R11=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R11]);
754   st-&gt;cr();
755   st-&gt;print(  &quot;R12=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R12]);
756   st-&gt;print(&quot;, R13=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R13]);
757   st-&gt;print(&quot;, R14=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R14]);
758   st-&gt;print(&quot;, R15=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_R15]);
759   st-&gt;cr();
760   st-&gt;print(  &quot;RIP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RIP]);
761   st-&gt;print(&quot;, RFLAGS=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[REG_RFL]);
762 #else
763   st-&gt;print(  &quot;EAX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[EAX]);
764   st-&gt;print(&quot;, EBX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[EBX]);
765   st-&gt;print(&quot;, ECX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[ECX]);
766   st-&gt;print(&quot;, EDX=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[EDX]);
767   st-&gt;cr();
768   st-&gt;print(  &quot;ESP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[UESP]);
769   st-&gt;print(&quot;, EBP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[EBP]);
770   st-&gt;print(&quot;, ESI=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[ESI]);
771   st-&gt;print(&quot;, EDI=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[EDI]);
772   st-&gt;cr();
773   st-&gt;print(  &quot;EIP=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[EIP]);
774   st-&gt;print(&quot;, EFLAGS=&quot; INTPTR_FORMAT, uc-&gt;uc_mcontext.gregs[EFL]);
775 #endif // AMD64
776   st-&gt;cr();
777   st-&gt;cr();
778 
779   intptr_t *sp = (intptr_t *)os::Solaris::ucontext_get_sp(uc);
780   st-&gt;print_cr(&quot;Top of Stack: (sp=&quot; PTR_FORMAT &quot;)&quot;, sp);
781   print_hex_dump(st, (address)sp, (address)(sp + 8*sizeof(intptr_t)), sizeof(intptr_t));
782   st-&gt;cr();
783 
784   // Note: it may be unsafe to inspect memory near pc. For example, pc may
785   // point to garbage if entry point in an nmethod is corrupted. Leave
786   // this at the end, and hope for the best.
787   ExtendedPC epc = os::Solaris::ucontext_get_ExtendedPC(uc);
788   address pc = epc.pc();
789   print_instructions(st, pc, sizeof(char));
790   st-&gt;cr();
791 }
792 
793 void os::print_register_info(outputStream *st, const void *context) {
794   if (context == NULL) return;
795 
796   const ucontext_t *uc = (const ucontext_t*)context;
797 
798   st-&gt;print_cr(&quot;Register to memory mapping:&quot;);
799   st-&gt;cr();
800 
801   // this is horrendously verbose but the layout of the registers in the
802   // context does not match how we defined our abstract Register set, so
803   // we can&#39;t just iterate through the gregs area
804 
805   // this is only for the &quot;general purpose&quot; registers
806 
807 #ifdef AMD64
808   st-&gt;print(&quot;RAX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RAX]);
809   st-&gt;print(&quot;RBX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RBX]);
810   st-&gt;print(&quot;RCX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RCX]);
811   st-&gt;print(&quot;RDX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RDX]);
812   st-&gt;print(&quot;RSP=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RSP]);
813   st-&gt;print(&quot;RBP=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RBP]);
814   st-&gt;print(&quot;RSI=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RSI]);
815   st-&gt;print(&quot;RDI=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_RDI]);
816   st-&gt;print(&quot;R8 =&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R8]);
817   st-&gt;print(&quot;R9 =&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R9]);
818   st-&gt;print(&quot;R10=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R10]);
819   st-&gt;print(&quot;R11=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R11]);
820   st-&gt;print(&quot;R12=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R12]);
821   st-&gt;print(&quot;R13=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R13]);
822   st-&gt;print(&quot;R14=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R14]);
823   st-&gt;print(&quot;R15=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[REG_R15]);
824 #else
825   st-&gt;print(&quot;EAX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[EAX]);
826   st-&gt;print(&quot;EBX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[EBX]);
827   st-&gt;print(&quot;ECX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[ECX]);
828   st-&gt;print(&quot;EDX=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[EDX]);
829   st-&gt;print(&quot;ESP=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[UESP]);
830   st-&gt;print(&quot;EBP=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[EBP]);
831   st-&gt;print(&quot;ESI=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[ESI]);
832   st-&gt;print(&quot;EDI=&quot;); print_location(st, uc-&gt;uc_mcontext.gregs[EDI]);
833 #endif
834 
835   st-&gt;cr();
836 }
837 
838 
839 #ifdef AMD64
840 void os::Solaris::init_thread_fpu_state(void) {
841   // Nothing to do
842 }
843 #else
844 // From solaris_i486.s
845 extern &quot;C&quot; void fixcw();
846 
847 void os::Solaris::init_thread_fpu_state(void) {
848   // Set fpu to 53 bit precision. This happens too early to use a stub.
849   fixcw();
850 }
851 
852 // These routines are the initial value of atomic_xchg_entry(),
853 // atomic_cmpxchg_entry(), atomic_inc_entry() and fence_entry()
854 // until initialization is complete.
855 // TODO - replace with .il implementation when compiler supports it.
856 
857 typedef int32_t  xchg_func_t        (int32_t,  volatile int32_t*);
858 typedef int32_t  cmpxchg_func_t     (int32_t,  volatile int32_t*,  int32_t);
859 typedef int64_t  cmpxchg_long_func_t(int64_t,  volatile int64_t*,  int64_t);
860 typedef int32_t  add_func_t         (int32_t,  volatile int32_t*);
861 
862 int32_t os::atomic_xchg_bootstrap(int32_t exchange_value, volatile int32_t* dest) {
863   // try to use the stub:
864   xchg_func_t* func = CAST_TO_FN_PTR(xchg_func_t*, StubRoutines::atomic_xchg_entry());
865 
866   if (func != NULL) {
867     os::atomic_xchg_func = func;
868     return (*func)(exchange_value, dest);
869   }
870   assert(Threads::number_of_threads() == 0, &quot;for bootstrap only&quot;);
871 
872   int32_t old_value = *dest;
873   *dest = exchange_value;
874   return old_value;
875 }
876 
877 int32_t os::atomic_cmpxchg_bootstrap(int32_t exchange_value, volatile int32_t* dest, int32_t compare_value) {
878   // try to use the stub:
879   cmpxchg_func_t* func = CAST_TO_FN_PTR(cmpxchg_func_t*, StubRoutines::atomic_cmpxchg_entry());
880 
881   if (func != NULL) {
882     os::atomic_cmpxchg_func = func;
883     return (*func)(exchange_value, dest, compare_value);
884   }
885   assert(Threads::number_of_threads() == 0, &quot;for bootstrap only&quot;);
886 
887   int32_t old_value = *dest;
888   if (old_value == compare_value)
889     *dest = exchange_value;
890   return old_value;
891 }
892 
893 int64_t os::atomic_cmpxchg_long_bootstrap(int64_t exchange_value, volatile int64_t* dest, int64_t compare_value) {
894   // try to use the stub:
895   cmpxchg_long_func_t* func = CAST_TO_FN_PTR(cmpxchg_long_func_t*, StubRoutines::atomic_cmpxchg_long_entry());
896 
897   if (func != NULL) {
898     os::atomic_cmpxchg_long_func = func;
899     return (*func)(exchange_value, dest, compare_value);
900   }
901   assert(Threads::number_of_threads() == 0, &quot;for bootstrap only&quot;);
902 
903   int64_t old_value = *dest;
904   if (old_value == compare_value)
905     *dest = exchange_value;
906   return old_value;
907 }
908 
909 int32_t os::atomic_add_bootstrap(int32_t add_value, volatile int32_t* dest) {
910   // try to use the stub:
911   add_func_t* func = CAST_TO_FN_PTR(add_func_t*, StubRoutines::atomic_add_entry());
912 
913   if (func != NULL) {
914     os::atomic_add_func = func;
915     return (*func)(add_value, dest);
916   }
917   assert(Threads::number_of_threads() == 0, &quot;for bootstrap only&quot;);
918 
919   return (*dest) += add_value;
920 }
921 
922 xchg_func_t*         os::atomic_xchg_func         = os::atomic_xchg_bootstrap;
923 cmpxchg_func_t*      os::atomic_cmpxchg_func      = os::atomic_cmpxchg_bootstrap;
924 cmpxchg_long_func_t* os::atomic_cmpxchg_long_func = os::atomic_cmpxchg_long_bootstrap;
925 add_func_t*          os::atomic_add_func          = os::atomic_add_bootstrap;
926 
927 extern &quot;C&quot; void _solaris_raw_setup_fpu(address ptr);
928 void os::setup_fpu() {
929   address fpu_cntrl = StubRoutines::addr_fpu_cntrl_wrd_std();
930   _solaris_raw_setup_fpu(fpu_cntrl);
931 }
932 #endif // AMD64
933 
934 #ifndef PRODUCT
935 void os::verify_stack_alignment() {
936 #ifdef AMD64
937   assert(((intptr_t)os::current_stack_pointer() &amp; (StackAlignmentInBytes-1)) == 0, &quot;incorrect stack alignment&quot;);
938 #endif
939 }
940 #endif
941 
942 int os::extra_bang_size_in_bytes() {
943   // JDK-8050147 requires the full cache line bang for x86.
944   return VM_Version::L1_line_size();
945 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
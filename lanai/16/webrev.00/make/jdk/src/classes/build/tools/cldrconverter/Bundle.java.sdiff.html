<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff make/jdk/src/classes/build/tools/cldrconverter/Bundle.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../netbeans/jmx/build.xml.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CLDRConverter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>make/jdk/src/classes/build/tools/cldrconverter/Bundle.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
269         if (&quot;root&quot;.equals(id)) {
270             parentsMap = null;
271         }
272 
273         for (CalendarType calendarType : CalendarType.values()) {
274             String calendarPrefix = calendarType.keyElementName();
275             // handle multiple inheritance for month and day names
276             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;MonthNames&quot;);
277             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;MonthAbbreviations&quot;);
278             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;MonthNarrows&quot;);
279             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;DayNames&quot;);
280             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;DayAbbreviations&quot;);
281             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;DayNarrows&quot;);
282             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;AmPmMarkers&quot;);
283             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;narrow.AmPmMarkers&quot;);
284             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;abbreviated.AmPmMarkers&quot;);
285             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;QuarterNames&quot;);
286             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;QuarterAbbreviations&quot;);
287             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;QuarterNarrows&quot;);
288 
<span class="line-modified">289             adjustEraNames(myMap, calendarType);</span>
290 
291             handleDateTimeFormatPatterns(TIME_PATTERN_KEYS, myMap, parentsMap, calendarType, &quot;TimePatterns&quot;);
292             handleDateTimeFormatPatterns(DATE_PATTERN_KEYS, myMap, parentsMap, calendarType, &quot;DatePatterns&quot;);
293             handleDateTimeFormatPatterns(DATETIME_PATTERN_KEYS, myMap, parentsMap, calendarType, &quot;DateTimePatterns&quot;);
294         }
295 
296         // First, weed out any empty timezone or metazone names from myMap.
<span class="line-removed">297         // Fill in any missing abbreviations if locale is &quot;en&quot;.</span>
298         for (Iterator&lt;String&gt; it = myMap.keySet().iterator(); it.hasNext();) {
299             String key = it.next();
300             if (key.startsWith(CLDRConverter.TIMEZONE_ID_PREFIX)
301                     || key.startsWith(CLDRConverter.METAZONE_ID_PREFIX)) {
302                 @SuppressWarnings(&quot;unchecked&quot;)
303                 Map&lt;String, String&gt; nameMap = (Map&lt;String, String&gt;) myMap.get(key);
304                 if (nameMap.isEmpty()) {
305                     // Some zones have only exemplarCity, which become empty.
306                     // Remove those from the map.
307                     it.remove();
308                     continue;
309                 }
<span class="line-removed">310 </span>
<span class="line-removed">311                 if (id.equals(&quot;en&quot;)) {</span>
<span class="line-removed">312                     fillInJREs(key, nameMap);</span>
<span class="line-removed">313                 }</span>
314             }
315         }
316         for (Iterator&lt;String&gt; it = myMap.keySet().iterator(); it.hasNext();) {
317             String key = it.next();
318                 if (key.startsWith(CLDRConverter.TIMEZONE_ID_PREFIX)
319                     || key.startsWith(CLDRConverter.METAZONE_ID_PREFIX)) {
320                 @SuppressWarnings(&quot;unchecked&quot;)
321                 Map&lt;String, String&gt; nameMap = (Map&lt;String, String&gt;) myMap.get(key);
322 
323                 // Convert key/value pairs to an array.
324                 String[] names = new String[ZONE_NAME_KEYS.length];
325                 int ix = 0;
326                 for (String nameKey : ZONE_NAME_KEYS) {
327                     String name = nameMap.get(nameKey);
328                     if (name == null &amp;&amp; parentsMap != null) {
329                         @SuppressWarnings(&quot;unchecked&quot;)
330                         Map&lt;String, String&gt; parentNames = (Map&lt;String, String&gt;) parentsMap.get(key);
331                         if (parentNames != null) {
332                             name = parentNames.get(nameKey);
333                         }
</pre>
<hr />
<pre>
398         if (format != null) {
399             map.remove(formatMapKey);
400             map.put(key, format);
401             if (fillInElements(parents, formatMapKey, format)) {
402                 map.remove(key);
403             }
404         }
405         String standaloneMapKey = key + &quot;/stand-alone&quot;;
406         Object standalone = map.get(standaloneMapKey);
407         if (standalone != null) {
408             map.remove(standaloneMapKey);
409             String standaloneResourceKey = &quot;standalone.&quot; + key;
410             map.put(standaloneResourceKey, standalone);
411             if (fillInElements(parents, standaloneMapKey, standalone)) {
412                 map.remove(standaloneResourceKey);
413             }
414         }
415     }
416 
417     /**
<span class="line-modified">418      * Fills in any empty elements with its parent element. Returns true if the resulting array is</span>
<span class="line-modified">419      * identical to its parent array.</span>

420      *
421      * @param parents
422      * @param key
423      * @param value
424      * @return true if the resulting array is identical to its parent array.
425      */
426     private boolean fillInElements(Map&lt;String, Object&gt; parents, String key, Object value) {
427         if (parents == null) {
428             return false;
429         }
430         if (value instanceof String[]) {
<span class="line-modified">431             Object pvalue = parents.get(key);</span>
432             if (pvalue != null &amp;&amp; pvalue instanceof String[]) {
433                 String[] strings = (String[]) value;
434                 String[] pstrings = (String[]) pvalue;
435                 for (int i = 0; i &lt; strings.length; i++) {
436                     if (strings[i] == null || strings[i].length() == 0) {
437                         strings[i] = pstrings[i];
438                     }
439                 }
440                 return Arrays.equals(strings, pstrings);
441             }
442         }
443         return false;
444     }
445 
446     /*
447      * Adjusts String[] for era names because JRE&#39;s Calendars use different
448      * ERA value indexes in the Buddhist, Japanese Imperial, and Islamic calendars.
449      */
<span class="line-modified">450     private void adjustEraNames(Map&lt;String, Object&gt; map, CalendarType type) {</span>
451         String[][] eraNames = new String[ERA_KEYS.length][];
452         String[] realKeys = new String[ERA_KEYS.length];
453         int index = 0;
454         for (String key : ERA_KEYS) {
455             String realKey = type.keyElementName() + key;
456             String[] value = (String[]) map.get(realKey);
457             if (value != null) {



458                 switch (type) {
459                 case GREGORIAN:
460                     break;
461 
462                 case JAPANESE:
463                     {
464                         String[] newValue = new String[value.length + 1];
465                         String[] julianEras = (String[]) map.get(key);
466                         if (julianEras != null &amp;&amp; julianEras.length &gt;= 2) {
467                             newValue[0] = julianEras[1];
468                         } else {
469                             newValue[0] = &quot;&quot;;
470                         }
471                         System.arraycopy(value, 0, newValue, 1, value.length);
472                         value = newValue;
473 
474                         // fix up &#39;Reiwa&#39; era, which can be missing in some locales
475                         if (value[value.length - 1] == null) {
476                             value[value.length - 1] = (key.startsWith(&quot;narrow.&quot;) ? &quot;R&quot; : &quot;Reiwa&quot;);
477                         }
</pre>
<hr />
<pre>
619         if (count != 0) {
620             converter.convert(calendarType, lastLetter, count, jrePattern);
621         }
622         if (cldrFormat.contentEquals(jrePattern)) {
623             return cldrFormat;
624         }
625         return jrePattern.toString();
626     }
627 
628     private String toMetaZoneKey(String tzKey) {
629         if (tzKey.startsWith(CLDRConverter.TIMEZONE_ID_PREFIX)) {
630             String tz = tzKey.substring(CLDRConverter.TIMEZONE_ID_PREFIX.length());
631             String meta = CLDRConverter.handlerMetaZones.get(tz);
632             if (meta != null) {
633                 return CLDRConverter.METAZONE_ID_PREFIX + meta;
634             }
635         }
636         return null;
637     }
638 
<span class="line-removed">639     static List&lt;Object[]&gt; jreTimeZoneNames = Arrays.asList(TimeZoneNames.getContents());</span>
<span class="line-removed">640     private void fillInJREs(String key, Map&lt;String, String&gt; map) {</span>
<span class="line-removed">641         String tzid = null;</span>
<span class="line-removed">642 </span>
<span class="line-removed">643         if (key.startsWith(CLDRConverter.METAZONE_ID_PREFIX)) {</span>
<span class="line-removed">644             // Look for tzid</span>
<span class="line-removed">645             String meta = key.substring(CLDRConverter.METAZONE_ID_PREFIX.length());</span>
<span class="line-removed">646             if (meta.equals(&quot;GMT&quot;)) {</span>
<span class="line-removed">647                 tzid = meta;</span>
<span class="line-removed">648             } else {</span>
<span class="line-removed">649                 for (String tz : CLDRConverter.handlerMetaZones.keySet()) {</span>
<span class="line-removed">650                     if (CLDRConverter.handlerMetaZones.get(tz).equals(meta)) {</span>
<span class="line-removed">651                         tzid = tz;</span>
<span class="line-removed">652                         break;</span>
<span class="line-removed">653                     }</span>
<span class="line-removed">654                 }</span>
<span class="line-removed">655             }</span>
<span class="line-removed">656         } else {</span>
<span class="line-removed">657             tzid = key.substring(CLDRConverter.TIMEZONE_ID_PREFIX.length());</span>
<span class="line-removed">658         }</span>
<span class="line-removed">659 </span>
<span class="line-removed">660         if (tzid != null) {</span>
<span class="line-removed">661             for (Object[] jreZone : jreTimeZoneNames) {</span>
<span class="line-removed">662                 if (jreZone[0].equals(tzid)) {</span>
<span class="line-removed">663                     for (int i = 0; i &lt; ZONE_NAME_KEYS.length; i++) {</span>
<span class="line-removed">664                         if (map.get(ZONE_NAME_KEYS[i]) == null) {</span>
<span class="line-removed">665                             String[] jreNames = (String[])jreZone[1];</span>
<span class="line-removed">666                             map.put(ZONE_NAME_KEYS[i], jreNames[i]);</span>
<span class="line-removed">667                         }</span>
<span class="line-removed">668                     }</span>
<span class="line-removed">669                     break;</span>
<span class="line-removed">670                 }</span>
<span class="line-removed">671             }</span>
<span class="line-removed">672         }</span>
<span class="line-removed">673     }</span>
<span class="line-removed">674 </span>
675     /**
676      * Perform a generic conversion of CLDR date-time format pattern letter based
677      * on the support given by the SimpleDateFormat and the j.t.f.DateTimeFormatter
678      * for date-time formatting.
679      */
680     private void convertDateTimePatternLetter(CalendarType calendarType, char cldrLetter, int count, StringBuilder sb) {
681         switch (cldrLetter) {
682             case &#39;u&#39;:
683                 // Change cldr letter &#39;u&#39; to &#39;y&#39;, as &#39;u&#39; is interpreted as
684                 // &quot;Extended year (numeric)&quot; in CLDR/LDML,
685                 // which is not supported in SimpleDateFormat and
686                 // j.t.f.DateTimeFormatter, so it is replaced with &#39;y&#39;
687                 // as the best approximation
688                 appendN(&#39;y&#39;, count, sb);
689                 break;
690             case &#39;B&#39;:
691                 // &#39;B&#39; character (day period) is not supported by
692                 // SimpleDateFormat and j.t.f.DateTimeFormatter,
693                 // this is a workaround in which &#39;B&#39; character
694                 // appearing in CLDR date-time pattern is replaced
</pre>
</td>
<td>
<hr />
<pre>
269         if (&quot;root&quot;.equals(id)) {
270             parentsMap = null;
271         }
272 
273         for (CalendarType calendarType : CalendarType.values()) {
274             String calendarPrefix = calendarType.keyElementName();
275             // handle multiple inheritance for month and day names
276             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;MonthNames&quot;);
277             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;MonthAbbreviations&quot;);
278             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;MonthNarrows&quot;);
279             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;DayNames&quot;);
280             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;DayAbbreviations&quot;);
281             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;DayNarrows&quot;);
282             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;AmPmMarkers&quot;);
283             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;narrow.AmPmMarkers&quot;);
284             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;abbreviated.AmPmMarkers&quot;);
285             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;QuarterNames&quot;);
286             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;QuarterAbbreviations&quot;);
287             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;QuarterNarrows&quot;);
288 
<span class="line-modified">289             adjustEraNames(myMap, parentsMap, calendarType);</span>
290 
291             handleDateTimeFormatPatterns(TIME_PATTERN_KEYS, myMap, parentsMap, calendarType, &quot;TimePatterns&quot;);
292             handleDateTimeFormatPatterns(DATE_PATTERN_KEYS, myMap, parentsMap, calendarType, &quot;DatePatterns&quot;);
293             handleDateTimeFormatPatterns(DATETIME_PATTERN_KEYS, myMap, parentsMap, calendarType, &quot;DateTimePatterns&quot;);
294         }
295 
296         // First, weed out any empty timezone or metazone names from myMap.

297         for (Iterator&lt;String&gt; it = myMap.keySet().iterator(); it.hasNext();) {
298             String key = it.next();
299             if (key.startsWith(CLDRConverter.TIMEZONE_ID_PREFIX)
300                     || key.startsWith(CLDRConverter.METAZONE_ID_PREFIX)) {
301                 @SuppressWarnings(&quot;unchecked&quot;)
302                 Map&lt;String, String&gt; nameMap = (Map&lt;String, String&gt;) myMap.get(key);
303                 if (nameMap.isEmpty()) {
304                     // Some zones have only exemplarCity, which become empty.
305                     // Remove those from the map.
306                     it.remove();
307                     continue;
308                 }




309             }
310         }
311         for (Iterator&lt;String&gt; it = myMap.keySet().iterator(); it.hasNext();) {
312             String key = it.next();
313                 if (key.startsWith(CLDRConverter.TIMEZONE_ID_PREFIX)
314                     || key.startsWith(CLDRConverter.METAZONE_ID_PREFIX)) {
315                 @SuppressWarnings(&quot;unchecked&quot;)
316                 Map&lt;String, String&gt; nameMap = (Map&lt;String, String&gt;) myMap.get(key);
317 
318                 // Convert key/value pairs to an array.
319                 String[] names = new String[ZONE_NAME_KEYS.length];
320                 int ix = 0;
321                 for (String nameKey : ZONE_NAME_KEYS) {
322                     String name = nameMap.get(nameKey);
323                     if (name == null &amp;&amp; parentsMap != null) {
324                         @SuppressWarnings(&quot;unchecked&quot;)
325                         Map&lt;String, String&gt; parentNames = (Map&lt;String, String&gt;) parentsMap.get(key);
326                         if (parentNames != null) {
327                             name = parentNames.get(nameKey);
328                         }
</pre>
<hr />
<pre>
393         if (format != null) {
394             map.remove(formatMapKey);
395             map.put(key, format);
396             if (fillInElements(parents, formatMapKey, format)) {
397                 map.remove(key);
398             }
399         }
400         String standaloneMapKey = key + &quot;/stand-alone&quot;;
401         Object standalone = map.get(standaloneMapKey);
402         if (standalone != null) {
403             map.remove(standaloneMapKey);
404             String standaloneResourceKey = &quot;standalone.&quot; + key;
405             map.put(standaloneResourceKey, standalone);
406             if (fillInElements(parents, standaloneMapKey, standalone)) {
407                 map.remove(standaloneResourceKey);
408             }
409         }
410     }
411 
412     /**
<span class="line-modified">413      * Fills in any empty elements with its parent element, falling back to</span>
<span class="line-modified">414      * aliased one if parent element is not found. Returns true if the resulting</span>
<span class="line-added">415      * array is identical to its parent array.</span>
416      *
417      * @param parents
418      * @param key
419      * @param value
420      * @return true if the resulting array is identical to its parent array.
421      */
422     private boolean fillInElements(Map&lt;String, Object&gt; parents, String key, Object value) {
423         if (parents == null) {
424             return false;
425         }
426         if (value instanceof String[]) {
<span class="line-modified">427             Object pvalue = parents.getOrDefault(key, parents.get(CLDRConverter.aliases.get(key)));</span>
428             if (pvalue != null &amp;&amp; pvalue instanceof String[]) {
429                 String[] strings = (String[]) value;
430                 String[] pstrings = (String[]) pvalue;
431                 for (int i = 0; i &lt; strings.length; i++) {
432                     if (strings[i] == null || strings[i].length() == 0) {
433                         strings[i] = pstrings[i];
434                     }
435                 }
436                 return Arrays.equals(strings, pstrings);
437             }
438         }
439         return false;
440     }
441 
442     /*
443      * Adjusts String[] for era names because JRE&#39;s Calendars use different
444      * ERA value indexes in the Buddhist, Japanese Imperial, and Islamic calendars.
445      */
<span class="line-modified">446     private void adjustEraNames(Map&lt;String, Object&gt; map, Map&lt;String, Object&gt; pMap, CalendarType type) {</span>
447         String[][] eraNames = new String[ERA_KEYS.length][];
448         String[] realKeys = new String[ERA_KEYS.length];
449         int index = 0;
450         for (String key : ERA_KEYS) {
451             String realKey = type.keyElementName() + key;
452             String[] value = (String[]) map.get(realKey);
453             if (value != null) {
<span class="line-added">454                 // first fill in missing elements from parents map.</span>
<span class="line-added">455                 fillInElements(pMap, realKey, value);</span>
<span class="line-added">456 </span>
457                 switch (type) {
458                 case GREGORIAN:
459                     break;
460 
461                 case JAPANESE:
462                     {
463                         String[] newValue = new String[value.length + 1];
464                         String[] julianEras = (String[]) map.get(key);
465                         if (julianEras != null &amp;&amp; julianEras.length &gt;= 2) {
466                             newValue[0] = julianEras[1];
467                         } else {
468                             newValue[0] = &quot;&quot;;
469                         }
470                         System.arraycopy(value, 0, newValue, 1, value.length);
471                         value = newValue;
472 
473                         // fix up &#39;Reiwa&#39; era, which can be missing in some locales
474                         if (value[value.length - 1] == null) {
475                             value[value.length - 1] = (key.startsWith(&quot;narrow.&quot;) ? &quot;R&quot; : &quot;Reiwa&quot;);
476                         }
</pre>
<hr />
<pre>
618         if (count != 0) {
619             converter.convert(calendarType, lastLetter, count, jrePattern);
620         }
621         if (cldrFormat.contentEquals(jrePattern)) {
622             return cldrFormat;
623         }
624         return jrePattern.toString();
625     }
626 
627     private String toMetaZoneKey(String tzKey) {
628         if (tzKey.startsWith(CLDRConverter.TIMEZONE_ID_PREFIX)) {
629             String tz = tzKey.substring(CLDRConverter.TIMEZONE_ID_PREFIX.length());
630             String meta = CLDRConverter.handlerMetaZones.get(tz);
631             if (meta != null) {
632                 return CLDRConverter.METAZONE_ID_PREFIX + meta;
633             }
634         }
635         return null;
636     }
637 




































638     /**
639      * Perform a generic conversion of CLDR date-time format pattern letter based
640      * on the support given by the SimpleDateFormat and the j.t.f.DateTimeFormatter
641      * for date-time formatting.
642      */
643     private void convertDateTimePatternLetter(CalendarType calendarType, char cldrLetter, int count, StringBuilder sb) {
644         switch (cldrLetter) {
645             case &#39;u&#39;:
646                 // Change cldr letter &#39;u&#39; to &#39;y&#39;, as &#39;u&#39; is interpreted as
647                 // &quot;Extended year (numeric)&quot; in CLDR/LDML,
648                 // which is not supported in SimpleDateFormat and
649                 // j.t.f.DateTimeFormatter, so it is replaced with &#39;y&#39;
650                 // as the best approximation
651                 appendN(&#39;y&#39;, count, sb);
652                 break;
653             case &#39;B&#39;:
654                 // &#39;B&#39; character (day period) is not supported by
655                 // SimpleDateFormat and j.t.f.DateTimeFormatter,
656                 // this is a workaround in which &#39;B&#39; character
657                 // appearing in CLDR date-time pattern is replaced
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../netbeans/jmx/build.xml.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CLDRConverter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
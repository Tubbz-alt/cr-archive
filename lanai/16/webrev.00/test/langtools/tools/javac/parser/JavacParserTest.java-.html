<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/langtools/tools/javac/parser/JavacParserTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /*
  25  * @test
  26  * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913
  27  * @summary tests error and diagnostics positions
  28  * @author  Jan Lahoda
  29  * @modules jdk.compiler/com.sun.tools.javac.api
  30  *          jdk.compiler/com.sun.tools.javac.main
  31  *          jdk.compiler/com.sun.tools.javac.tree
  32  */
  33 
  34 import com.sun.source.tree.BinaryTree;
  35 import com.sun.source.tree.BlockTree;
  36 import com.sun.source.tree.ClassTree;
  37 import com.sun.source.tree.CompilationUnitTree;
  38 import com.sun.source.tree.ErroneousTree;
  39 import com.sun.source.tree.ExpressionStatementTree;
  40 import com.sun.source.tree.ExpressionTree;
  41 import com.sun.source.tree.IfTree;
  42 import com.sun.source.tree.LambdaExpressionTree;
  43 import com.sun.source.tree.MethodInvocationTree;
  44 import com.sun.source.tree.MethodTree;
  45 import com.sun.source.tree.ModifiersTree;
  46 import com.sun.source.tree.PrimitiveTypeTree;
  47 import com.sun.source.tree.StatementTree;
  48 import com.sun.source.tree.Tree;
  49 import com.sun.source.tree.Tree.Kind;
  50 import com.sun.source.tree.VariableTree;
  51 import com.sun.source.tree.WhileLoopTree;
  52 import com.sun.source.util.JavacTask;
  53 import com.sun.source.util.SourcePositions;
  54 import com.sun.source.util.TreePath;
  55 import com.sun.source.util.TreePathScanner;
  56 import com.sun.source.util.TreeScanner;
  57 import com.sun.source.util.Trees;
  58 import com.sun.tools.javac.api.JavacTaskImpl;
  59 import com.sun.tools.javac.main.Main;
  60 import com.sun.tools.javac.main.Main.Result;
  61 import com.sun.tools.javac.tree.JCTree;
  62 import java.io.IOException;
  63 import java.io.StringWriter;
  64 import java.lang.annotation.ElementType;
  65 import java.lang.annotation.Retention;
  66 import java.lang.annotation.RetentionPolicy;
  67 import java.lang.annotation.Target;
  68 import java.lang.reflect.Method;
  69 import java.net.URI;
  70 import java.util.ArrayList;
  71 import java.util.Arrays;
  72 import java.util.LinkedList;
  73 import java.util.List;
  74 import java.util.regex.Pattern;
  75 import javax.lang.model.type.TypeKind;
  76 import javax.tools.Diagnostic;
  77 import javax.tools.DiagnosticCollector;
  78 import javax.tools.DiagnosticListener;
  79 import javax.tools.JavaCompiler;
  80 import javax.tools.JavaFileManager;
  81 import javax.tools.JavaFileObject;
  82 import javax.tools.SimpleJavaFileObject;
  83 import javax.tools.ToolProvider;
  84 
  85 import com.sun.source.tree.CaseTree;
  86 import com.sun.source.util.TreePathScanner;
  87 
  88 public class JavacParserTest extends TestCase {
  89     static final JavaCompiler tool = ToolProvider.getSystemJavaCompiler();
  90     static final JavaFileManager fm = tool.getStandardFileManager(null, null, null);
  91     public static final String SOURCE_VERSION =
  92         Integer.toString(Runtime.version().feature());
  93 
  94     private JavacParserTest(){}
  95 
  96     public static void main(String... args) throws Exception {
  97         try (fm) {
  98             new JavacParserTest().run(args);
  99         }
 100     }
 101 
 102     class MyFileObject extends SimpleJavaFileObject {
 103 
 104         private String text;
 105 
 106         public MyFileObject(String text) {
 107             super(URI.create(&quot;myfo:/Test.java&quot;), JavaFileObject.Kind.SOURCE);
 108             this.text = text;
 109         }
 110 
 111         @Override
 112         public CharSequence getCharContent(boolean ignoreEncodingErrors) {
 113             return text;
 114         }
 115     }
 116     /*
 117      * converts Windows to Unix style LFs for comparing strings
 118      */
 119     String normalize(String in) {
 120         return in.replace(System.getProperty(&quot;line.separator&quot;), &quot;\n&quot;);
 121     }
 122 
 123     CompilationUnitTree getCompilationUnitTree(String code) throws IOException {
 124 
 125         JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, null, null,
 126                 null, Arrays.asList(new MyFileObject(code)));
 127         CompilationUnitTree cut = ct.parse().iterator().next();
 128         return cut;
 129     }
 130 
 131     List&lt;String&gt; getErroneousTreeValues(ErroneousTree node) {
 132 
 133         List&lt;String&gt; values = new ArrayList&lt;&gt;();
 134         if (node.getErrorTrees() != null) {
 135             for (Tree t : node.getErrorTrees()) {
 136                 values.add(t.toString());
 137             }
 138         } else {
 139             throw new RuntimeException(&quot;ERROR: No Erroneous tree &quot;
 140                     + &quot;has been created.&quot;);
 141         }
 142         return values;
 143     }
 144 
 145     @Test
 146     void testPositionForSuperConstructorCalls() throws IOException {
 147         assert tool != null;
 148 
 149         String code = &quot;package test; public class Test {public Test() {super();}}&quot;;
 150 
 151         JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, null, null,
 152                 null, Arrays.asList(new MyFileObject(code)));
 153         CompilationUnitTree cut = ct.parse().iterator().next();
 154         SourcePositions pos = Trees.instance(ct).getSourcePositions();
 155 
 156         MethodTree method =
 157                 (MethodTree) ((ClassTree) cut.getTypeDecls().get(0)).getMembers().get(0);
 158         ExpressionStatementTree es =
 159                 (ExpressionStatementTree) method.getBody().getStatements().get(0);
 160 
 161         final int esStartPos = code.indexOf(es.toString());
 162         final int esEndPos = esStartPos + es.toString().length();
 163         assertEquals(&quot;testPositionForSuperConstructorCalls&quot;,
 164                 esStartPos, pos.getStartPosition(cut, es));
 165         assertEquals(&quot;testPositionForSuperConstructorCalls&quot;,
 166                 esEndPos, pos.getEndPosition(cut, es));
 167 
 168         MethodInvocationTree mit = (MethodInvocationTree) es.getExpression();
 169 
 170         final int mitStartPos = code.indexOf(mit.toString());
 171         final int mitEndPos = mitStartPos + mit.toString().length();
 172         assertEquals(&quot;testPositionForSuperConstructorCalls&quot;,
 173                 mitStartPos, pos.getStartPosition(cut, mit));
 174         assertEquals(&quot;testPositionForSuperConstructorCalls&quot;,
 175                 mitEndPos, pos.getEndPosition(cut, mit));
 176 
 177         final int methodStartPos = mitStartPos;
 178         final int methodEndPos = methodStartPos + mit.getMethodSelect().toString().length();
 179         assertEquals(&quot;testPositionForSuperConstructorCalls&quot;,
 180                 methodStartPos, pos.getStartPosition(cut, mit.getMethodSelect()));
 181         assertEquals(&quot;testPositionForSuperConstructorCalls&quot;,
 182                 methodEndPos, pos.getEndPosition(cut, mit.getMethodSelect()));
 183     }
 184 
 185     @Test
 186     void testPositionForEnumModifiers() throws IOException {
 187         final String theString = &quot;public&quot;;
 188         String code = &quot;package test; &quot; + theString + &quot; enum Test {A;}&quot;;
 189 
 190         JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, null, null,
 191                 null, Arrays.asList(new MyFileObject(code)));
 192         CompilationUnitTree cut = ct.parse().iterator().next();
 193         SourcePositions pos = Trees.instance(ct).getSourcePositions();
 194 
 195         ClassTree clazz = (ClassTree) cut.getTypeDecls().get(0);
 196         ModifiersTree mt = clazz.getModifiers();
 197         int spos = code.indexOf(theString);
 198         int epos = spos + theString.length();
 199         assertEquals(&quot;testPositionForEnumModifiers&quot;,
 200                 spos, pos.getStartPosition(cut, mt));
 201         assertEquals(&quot;testPositionForEnumModifiers&quot;,
 202                 epos, pos.getEndPosition(cut, mt));
 203     }
 204 
 205     @Test
 206     void testNewClassWithEnclosing() throws IOException {
 207 
 208         final String theString = &quot;Test.this.new d()&quot;;
 209         String code = &quot;package test; class Test { &quot; +
 210                 &quot;class d {} private void method() { &quot; +
 211                 &quot;Object o = &quot; + theString + &quot;; } }&quot;;
 212 
 213         JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, null, null,
 214                 null, Arrays.asList(new MyFileObject(code)));
 215         CompilationUnitTree cut = ct.parse().iterator().next();
 216         SourcePositions pos = Trees.instance(ct).getSourcePositions();
 217 
 218         ClassTree clazz = (ClassTree) cut.getTypeDecls().get(0);
 219         ExpressionTree est =
 220                 ((VariableTree) ((MethodTree) clazz.getMembers().get(1)).getBody().getStatements().get(0)).getInitializer();
 221 
 222         final int spos = code.indexOf(theString);
 223         final int epos = spos + theString.length();
 224         assertEquals(&quot;testNewClassWithEnclosing&quot;,
 225                 spos, pos.getStartPosition(cut, est));
 226         assertEquals(&quot;testNewClassWithEnclosing&quot;,
 227                 epos, pos.getEndPosition(cut, est));
 228     }
 229 
 230     @Test
 231     void testPreferredPositionForBinaryOp() throws IOException {
 232 
 233         String code = &quot;package test; public class Test {&quot;
 234                 + &quot;private void test() {&quot;
 235                 + &quot;Object o = null; boolean b = o != null &amp;&amp; o instanceof String;&quot;
 236                 + &quot;} private Test() {}}&quot;;
 237 
 238         CompilationUnitTree cut = getCompilationUnitTree(code);
 239         ClassTree clazz = (ClassTree) cut.getTypeDecls().get(0);
 240         MethodTree method = (MethodTree) clazz.getMembers().get(0);
 241         VariableTree condSt = (VariableTree) method.getBody().getStatements().get(1);
 242         BinaryTree cond = (BinaryTree) condSt.getInitializer();
 243 
 244         JCTree condJC = (JCTree) cond;
 245         int condStartPos = code.indexOf(&quot;&amp;&amp;&quot;);
 246         assertEquals(&quot;testPreferredPositionForBinaryOp&quot;,
 247                 condStartPos, condJC.pos);
 248     }
 249 
 250     @Test
 251     void testErrorRecoveryForEnhancedForLoop142381() throws IOException {
 252 
 253         String code = &quot;package test; class Test { &quot; +
 254                 &quot;private void method() { &quot; +
 255                 &quot;java.util.Set&lt;String&gt; s = null; for (a : s) {} } }&quot;;
 256 
 257         final List&lt;Diagnostic&lt;? extends JavaFileObject&gt;&gt; errors =
 258                 new LinkedList&lt;Diagnostic&lt;? extends JavaFileObject&gt;&gt;();
 259 
 260         JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm,
 261                 new DiagnosticListener&lt;JavaFileObject&gt;() {
 262             public void report(Diagnostic&lt;? extends JavaFileObject&gt; diagnostic) {
 263                 errors.add(diagnostic);
 264             }
 265         }, null, null, Arrays.asList(new MyFileObject(code)));
 266 
 267         CompilationUnitTree cut = ct.parse().iterator().next();
 268 
 269         ClassTree clazz = (ClassTree) cut.getTypeDecls().get(0);
 270         StatementTree forStatement =
 271                 ((MethodTree) clazz.getMembers().get(0)).getBody().getStatements().get(1);
 272 
 273         assertEquals(&quot;testErrorRecoveryForEnhancedForLoop142381&quot;,
 274                 Kind.ENHANCED_FOR_LOOP, forStatement.getKind());
 275         assertFalse(&quot;testErrorRecoveryForEnhancedForLoop142381&quot;, errors.isEmpty());
 276     }
 277 
 278     @Test
 279     void testPositionAnnotationNoPackage187551() throws IOException {
 280 
 281         String code = &quot;\n@interface Test {}&quot;;
 282 
 283         JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, null, null,
 284                 null, Arrays.asList(new MyFileObject(code)));
 285 
 286         CompilationUnitTree cut = ct.parse().iterator().next();
 287         ClassTree clazz = (ClassTree) cut.getTypeDecls().get(0);
 288         Trees t = Trees.instance(ct);
 289 
 290         assertEquals(&quot;testPositionAnnotationNoPackage187551&quot;,
 291                 1, t.getSourcePositions().getStartPosition(cut, clazz));
 292     }
 293 
 294     @Test
 295     void testPositionMissingStatement() throws IOException {
 296         String code = &quot;class C { void t() { if (true) } }&quot;;
 297         DiagnosticCollector&lt;JavaFileObject&gt; dc = new DiagnosticCollector&lt;&gt;();
 298 
 299         JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, dc, null,
 300                 null, Arrays.asList(new MyFileObject(code)));
 301 
 302         CompilationUnitTree cut = ct.parse().iterator().next();
 303         Trees trees = Trees.instance(ct);
 304         SourcePositions positions = trees.getSourcePositions();
 305 
 306         new TreeScanner&lt;Void, Void&gt;() {
 307             @Override
 308             public Void visitIf(IfTree it, Void v) {
 309                 StatementTree st = it.getThenStatement();
 310                 int startpos = (int) positions.getStartPosition(cut, st);
 311                 int endpos = (int) positions.getEndPosition(cut, st);
 312                 assertEquals(&quot;testPositionMissingStatement.execpos&quot;, startpos, endpos);
 313                 assertEquals(&quot;testPositionMissingStatement.execkind&quot;,
 314                              Kind.EXPRESSION_STATEMENT,
 315                              st.getKind());
 316                 Tree err = ((ExpressionStatementTree) st).getExpression();
 317                 startpos = (int) positions.getStartPosition(cut, err);
 318                 endpos = (int) positions.getEndPosition(cut, err);
 319                 assertEquals(&quot;testPositionMissingStatement.errpos&quot;, startpos, endpos);
 320                 assertEquals(&quot;testPositionMissingStatement.errkind&quot;,
 321                              Kind.ERRONEOUS,
 322                              err.getKind());
 323                 return super.visitIf(it, v);
 324             }
 325         }.scan(cut, null);
 326 
 327         assertEquals(&quot;testPositionMissingStatement.diags&quot;, 1, dc.getDiagnostics().size());
 328         Diagnostic&lt;? extends JavaFileObject&gt; d = dc.getDiagnostics().get(0);
 329         int startpos = (int) d.getStartPosition();
 330         int pos = (int) d.getPosition();
 331         int endpos = (int) d.getEndPosition();
 332         assertEquals(&quot;testPositionMissingStatement.diagspan&quot;, startpos, endpos);
 333         assertEquals(&quot;testPositionMissingStatement.diagpref&quot;, startpos, pos);
 334     }
 335 
 336     @Test
 337     void testPositionsSane1() throws IOException {
 338         performPositionsSanityTest(&quot;package test; class Test { &quot; +
 339                 &quot;private void method() { &quot; +
 340                 &quot;java.util.List&lt;? extends java.util.List&lt;? extends String&gt;&gt; l; &quot; +
 341                 &quot;} }&quot;);
 342     }
 343 
 344     @Test
 345     void testPositionsSane2() throws IOException {
 346         performPositionsSanityTest(&quot;package test; class Test { &quot; +
 347                 &quot;private void method() { &quot; +
 348                 &quot;java.util.List&lt;? super java.util.List&lt;? super String&gt;&gt; l; &quot; +
 349                 &quot;} }&quot;);
 350     }
 351 
 352     @Test
 353     void testPositionsSane3() throws IOException {
 354         performPositionsSanityTest(&quot;package test; class Test { &quot; +
 355                 &quot;private void method() { &quot; +
 356                 &quot;java.util.List&lt;? super java.util.List&lt;?&gt;&gt; l; } }&quot;);
 357     }
 358 
 359     private void performPositionsSanityTest(String code) throws IOException {
 360 
 361         final List&lt;Diagnostic&lt;? extends JavaFileObject&gt;&gt; errors =
 362                 new LinkedList&lt;Diagnostic&lt;? extends JavaFileObject&gt;&gt;();
 363 
 364         JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm,
 365                 new DiagnosticListener&lt;JavaFileObject&gt;() {
 366 
 367             public void report(Diagnostic&lt;? extends JavaFileObject&gt; diagnostic) {
 368                 errors.add(diagnostic);
 369             }
 370         }, null, null, Arrays.asList(new MyFileObject(code)));
 371 
 372         final CompilationUnitTree cut = ct.parse().iterator().next();
 373         final Trees trees = Trees.instance(ct);
 374 
 375         new TreeScanner&lt;Void, Void&gt;() {
 376 
 377             private long parentStart = 0;
 378             private long parentEnd = Integer.MAX_VALUE;
 379 
 380             @Override
 381             public Void scan(Tree node, Void p) {
 382                 if (node == null) {
 383                     return null;
 384                 }
 385 
 386                 long start = trees.getSourcePositions().getStartPosition(cut, node);
 387 
 388                 if (start == (-1)) {
 389                     return null; // synthetic tree
 390                 }
 391                 assertTrue(node.toString() + &quot;:&quot; + start + &quot;/&quot; + parentStart,
 392                         parentStart &lt;= start);
 393 
 394                 long prevParentStart = parentStart;
 395 
 396                 parentStart = start;
 397 
 398                 long end = trees.getSourcePositions().getEndPosition(cut, node);
 399 
 400                 assertTrue(node.toString() + &quot;:&quot; + end + &quot;/&quot; + parentEnd,
 401                         end &lt;= parentEnd);
 402 
 403                 long prevParentEnd = parentEnd;
 404 
 405                 parentEnd = end;
 406 
 407                 super.scan(node, p);
 408 
 409                 parentStart = prevParentStart;
 410                 parentEnd = prevParentEnd;
 411 
 412                 return null;
 413             }
 414 
 415             private void assertTrue(String message, boolean b) {
 416                 if (!b) fail(message);
 417             }
 418         }.scan(cut, null);
 419     }
 420 
 421     @Test
 422     void testCorrectWildcardPositions1() throws IOException {
 423         performWildcardPositionsTest(&quot;package test; import java.util.List; &quot; +
 424                 &quot;class Test { private void method() { List&lt;? extends List&lt;? extends String&gt;&gt; l; } }&quot;,
 425 
 426                 Arrays.asList(&quot;List&lt;? extends List&lt;? extends String&gt;&gt; l;&quot;,
 427                 &quot;List&lt;? extends List&lt;? extends String&gt;&gt;&quot;,
 428                 &quot;List&quot;,
 429                 &quot;? extends List&lt;? extends String&gt;&quot;,
 430                 &quot;List&lt;? extends String&gt;&quot;,
 431                 &quot;List&quot;,
 432                 &quot;? extends String&quot;,
 433                 &quot;String&quot;));
 434     }
 435 
 436     @Test
 437     void testCorrectWildcardPositions2() throws IOException {
 438         performWildcardPositionsTest(&quot;package test; import java.util.List; &quot;
 439                 + &quot;class Test { private void method() { List&lt;? super List&lt;? super String&gt;&gt; l; } }&quot;,
 440                 Arrays.asList(&quot;List&lt;? super List&lt;? super String&gt;&gt; l;&quot;,
 441                 &quot;List&lt;? super List&lt;? super String&gt;&gt;&quot;,
 442                 &quot;List&quot;,
 443                 &quot;? super List&lt;? super String&gt;&quot;,
 444                 &quot;List&lt;? super String&gt;&quot;,
 445                 &quot;List&quot;,
 446                 &quot;? super String&quot;,
 447                 &quot;String&quot;));
 448     }
 449 
 450     @Test
 451     void testCorrectWildcardPositions3() throws IOException {
 452         performWildcardPositionsTest(&quot;package test; import java.util.List; &quot; +
 453                 &quot;class Test { private void method() { List&lt;? super List&lt;?&gt;&gt; l; } }&quot;,
 454 
 455                 Arrays.asList(&quot;List&lt;? super List&lt;?&gt;&gt; l;&quot;,
 456                 &quot;List&lt;? super List&lt;?&gt;&gt;&quot;,
 457                 &quot;List&quot;,
 458                 &quot;? super List&lt;?&gt;&quot;,
 459                 &quot;List&lt;?&gt;&quot;,
 460                 &quot;List&quot;,
 461                 &quot;?&quot;));
 462     }
 463 
 464     @Test
 465     void testCorrectWildcardPositions4() throws IOException {
 466         performWildcardPositionsTest(&quot;package test; import java.util.List; &quot; +
 467                 &quot;class Test { private void method() { &quot; +
 468                 &quot;List&lt;? extends List&lt;? extends List&lt;? extends String&gt;&gt;&gt; l; } }&quot;,
 469 
 470                 Arrays.asList(&quot;List&lt;? extends List&lt;? extends List&lt;? extends String&gt;&gt;&gt; l;&quot;,
 471                 &quot;List&lt;? extends List&lt;? extends List&lt;? extends String&gt;&gt;&gt;&quot;,
 472                 &quot;List&quot;,
 473                 &quot;? extends List&lt;? extends List&lt;? extends String&gt;&gt;&quot;,
 474                 &quot;List&lt;? extends List&lt;? extends String&gt;&gt;&quot;,
 475                 &quot;List&quot;,
 476                 &quot;? extends List&lt;? extends String&gt;&quot;,
 477                 &quot;List&lt;? extends String&gt;&quot;,
 478                 &quot;List&quot;,
 479                 &quot;? extends String&quot;,
 480                 &quot;String&quot;));
 481     }
 482 
 483     @Test
 484     void testCorrectWildcardPositions5() throws IOException {
 485         performWildcardPositionsTest(&quot;package test; import java.util.List; &quot; +
 486                 &quot;class Test { private void method() { &quot; +
 487                 &quot;List&lt;? extends List&lt;? extends List&lt;? extends String   &gt;&gt;&gt; l; } }&quot;,
 488                 Arrays.asList(&quot;List&lt;? extends List&lt;? extends List&lt;? extends String   &gt;&gt;&gt; l;&quot;,
 489                 &quot;List&lt;? extends List&lt;? extends List&lt;? extends String   &gt;&gt;&gt;&quot;,
 490                 &quot;List&quot;,
 491                 &quot;? extends List&lt;? extends List&lt;? extends String   &gt;&gt;&quot;,
 492                 &quot;List&lt;? extends List&lt;? extends String   &gt;&gt;&quot;,
 493                 &quot;List&quot;,
 494                 &quot;? extends List&lt;? extends String   &gt;&quot;,
 495                 &quot;List&lt;? extends String   &gt;&quot;,
 496                 &quot;List&quot;,
 497                 &quot;? extends String&quot;,
 498                 &quot;String&quot;));
 499     }
 500 
 501     void performWildcardPositionsTest(final String code,
 502             List&lt;String&gt; golden) throws IOException {
 503 
 504         final List&lt;Diagnostic&lt;? extends JavaFileObject&gt;&gt; errors =
 505                 new LinkedList&lt;Diagnostic&lt;? extends JavaFileObject&gt;&gt;();
 506 
 507         JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm,
 508                 new DiagnosticListener&lt;JavaFileObject&gt;() {
 509                     public void report(Diagnostic&lt;? extends JavaFileObject&gt; diagnostic) {
 510                         errors.add(diagnostic);
 511                     }
 512                 }, null, null, Arrays.asList(new MyFileObject(code)));
 513 
 514         final CompilationUnitTree cut = ct.parse().iterator().next();
 515         final List&lt;String&gt; content = new LinkedList&lt;String&gt;();
 516         final Trees trees = Trees.instance(ct);
 517 
 518         new TreeScanner&lt;Void, Void&gt;() {
 519             @Override
 520             public Void scan(Tree node, Void p) {
 521                 if (node == null) {
 522                     return null;
 523                 }
 524                 long start = trees.getSourcePositions().getStartPosition(cut, node);
 525 
 526                 if (start == (-1)) {
 527                     return null; // synthetic tree
 528                 }
 529                 long end = trees.getSourcePositions().getEndPosition(cut, node);
 530                 String s = code.substring((int) start, (int) end);
 531                 content.add(s);
 532 
 533                 return super.scan(node, p);
 534             }
 535         }.scan(((MethodTree) ((ClassTree) cut.getTypeDecls().get(0)).getMembers().get(0)).getBody().getStatements().get(0), null);
 536 
 537         assertEquals(&quot;performWildcardPositionsTest&quot;,golden.toString(),
 538                 content.toString());
 539     }
 540 
 541     @Test
 542     void testStartPositionForMethodWithoutModifiers() throws IOException {
 543 
 544         String code = &quot;package t; class Test { &lt;T&gt; void t() {} }&quot;;
 545 
 546         JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, null, null,
 547                 null, Arrays.asList(new MyFileObject(code)));
 548         CompilationUnitTree cut = ct.parse().iterator().next();
 549         ClassTree clazz = (ClassTree) cut.getTypeDecls().get(0);
 550         MethodTree mt = (MethodTree) clazz.getMembers().get(0);
 551         Trees t = Trees.instance(ct);
 552         int start = (int) t.getSourcePositions().getStartPosition(cut, mt);
 553         int end = (int) t.getSourcePositions().getEndPosition(cut, mt);
 554 
 555         assertEquals(&quot;testStartPositionForMethodWithoutModifiers&quot;,
 556                 &quot;&lt;T&gt; void t() {}&quot;, code.substring(start, end));
 557     }
 558 
 559     @Test
 560     void testVariableInIfThen1() throws IOException {
 561 
 562         String code = &quot;package t; class Test { &quot; +
 563                 &quot;private static void t(String name) { &quot; +
 564                 &quot;if (name != null) String nn = name.trim(); } }&quot;;
 565 
 566         DiagnosticCollector&lt;JavaFileObject&gt; coll =
 567                 new DiagnosticCollector&lt;JavaFileObject&gt;();
 568 
 569         JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll, null,
 570                 null, Arrays.asList(new MyFileObject(code)));
 571 
 572         ct.parse();
 573 
 574         List&lt;String&gt; codes = new LinkedList&lt;String&gt;();
 575 
 576         for (Diagnostic&lt;? extends JavaFileObject&gt; d : coll.getDiagnostics()) {
 577             codes.add(d.getCode());
 578         }
 579 
 580         assertEquals(&quot;testVariableInIfThen1&quot;,
 581                 Arrays.&lt;String&gt;asList(&quot;compiler.err.variable.not.allowed&quot;),
 582                 codes);
 583     }
 584 
 585     @Test
 586    void testVariableInIfThen2() throws IOException {
 587 
 588         String code = &quot;package t; class Test { &quot; +
 589                 &quot;private static void t(String name) { &quot; +
 590                 &quot;if (name != null) class X {} } }&quot;;
 591         DiagnosticCollector&lt;JavaFileObject&gt; coll =
 592                 new DiagnosticCollector&lt;JavaFileObject&gt;();
 593         JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll, null,
 594                 null, Arrays.asList(new MyFileObject(code)));
 595 
 596         ct.parse();
 597 
 598         List&lt;String&gt; codes = new LinkedList&lt;String&gt;();
 599 
 600         for (Diagnostic&lt;? extends JavaFileObject&gt; d : coll.getDiagnostics()) {
 601             codes.add(d.getCode());
 602         }
 603 
 604         assertEquals(&quot;testVariableInIfThen2&quot;,
 605                 Arrays.&lt;String&gt;asList(&quot;compiler.err.class.not.allowed&quot;), codes);
 606     }
 607 
 608     @Test
 609     void testVariableInIfThen3() throws IOException {
 610 
 611         String code = &quot;package t; class Test { &quot;+
 612                 &quot;private static void t() { &quot; +
 613                 &quot;if (true) abstract class F {} }}&quot;;
 614         DiagnosticCollector&lt;JavaFileObject&gt; coll =
 615                 new DiagnosticCollector&lt;JavaFileObject&gt;();
 616         JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll, null,
 617                 null, Arrays.asList(new MyFileObject(code)));
 618 
 619         ct.parse();
 620 
 621         List&lt;String&gt; codes = new LinkedList&lt;String&gt;();
 622 
 623         for (Diagnostic&lt;? extends JavaFileObject&gt; d : coll.getDiagnostics()) {
 624             codes.add(d.getCode());
 625         }
 626 
 627         assertEquals(&quot;testVariableInIfThen3&quot;,
 628                 Arrays.&lt;String&gt;asList(&quot;compiler.err.class.not.allowed&quot;), codes);
 629     }
 630 
 631     @Test
 632     void testVariableInIfThen4() throws IOException {
 633 
 634         String code = &quot;package t; class Test { &quot;+
 635                 &quot;private static void t(String name) { &quot; +
 636                 &quot;if (name != null) interface X {} } }&quot;;
 637         DiagnosticCollector&lt;JavaFileObject&gt; coll =
 638                 new DiagnosticCollector&lt;JavaFileObject&gt;();
 639         JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll, null,
 640                 null, Arrays.asList(new MyFileObject(code)));
 641 
 642         ct.parse();
 643 
 644         List&lt;String&gt; codes = new LinkedList&lt;String&gt;();
 645 
 646         for (Diagnostic&lt;? extends JavaFileObject&gt; d : coll.getDiagnostics()) {
 647             codes.add(d.getCode());
 648         }
 649 
 650         assertEquals(&quot;testVariableInIfThen4&quot;,
 651                 Arrays.&lt;String&gt;asList(&quot;compiler.err.class.not.allowed&quot;), codes);
 652     }
 653 
 654     @Test
 655     void testVariableInIfThen5() throws IOException {
 656 
 657         String code = &quot;package t; class Test { &quot;+
 658                 &quot;private static void t() { &quot; +
 659                 &quot;if (true) } }&quot;;
 660         DiagnosticCollector&lt;JavaFileObject&gt; coll =
 661                 new DiagnosticCollector&lt;JavaFileObject&gt;();
 662         JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll, null,
 663                 null, Arrays.asList(new MyFileObject(code)));
 664 
 665         ct.parse();
 666 
 667         List&lt;String&gt; codes = new LinkedList&lt;String&gt;();
 668 
 669         for (Diagnostic&lt;? extends JavaFileObject&gt; d : coll.getDiagnostics()) {
 670             codes.add(d.getCode());
 671         }
 672 
 673         assertEquals(&quot;testVariableInIfThen5&quot;,
 674                 Arrays.&lt;String&gt;asList(&quot;compiler.err.illegal.start.of.stmt&quot;),
 675                 codes);
 676     }
 677 
 678     // see javac bug #6882235, NB bug #98234:
 679     @Test
 680     void testMissingExponent() throws IOException {
 681 
 682         String code = &quot;\nclass Test { { System.err.println(0e); } }&quot;;
 683 
 684         JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, null, null,
 685                 null, Arrays.asList(new MyFileObject(code)));
 686 
 687         assertNotNull(ct.parse().iterator().next());
 688     }
 689 
 690     @Test
 691     void testTryResourcePos() throws IOException {
 692 
 693         final String code = &quot;package t; class Test { &quot; +
 694                 &quot;{ try (java.io.InputStream in = null) { } } }&quot;;
 695 
 696         CompilationUnitTree cut = getCompilationUnitTree(code);
 697 
 698         new TreeScanner&lt;Void, Void&gt;() {
 699             @Override
 700             public Void visitVariable(VariableTree node, Void p) {
 701                 if (&quot;in&quot;.contentEquals(node.getName())) {
 702                     JCTree.JCVariableDecl var = (JCTree.JCVariableDecl) node;
 703                     assertEquals(&quot;testTryResourcePos&quot;, &quot;in = null) { } } }&quot;,
 704                             code.substring(var.pos));
 705                 }
 706                 return super.visitVariable(node, p);
 707             }
 708         }.scan(cut, null);
 709     }
 710 
 711     @Test
 712     void testVarPos() throws IOException {
 713 
 714         final String code = &quot;package t; class Test { &quot; +
 715                 &quot;{ java.io.InputStream in = null; } }&quot;;
 716 
 717         CompilationUnitTree cut = getCompilationUnitTree(code);
 718 
 719         new TreeScanner&lt;Void, Void&gt;() {
 720 
 721             @Override
 722             public Void visitVariable(VariableTree node, Void p) {
 723                 if (&quot;in&quot;.contentEquals(node.getName())) {
 724                     JCTree.JCVariableDecl var = (JCTree.JCVariableDecl) node;
 725                     assertEquals(&quot;testVarPos&quot;,&quot;in = null; } }&quot;,
 726                             code.substring(var.pos));
 727                 }
 728                 return super.visitVariable(node, p);
 729             }
 730         }.scan(cut, null);
 731     }
 732 
 733     // expected erroneous tree: int x = y;(ERROR);
 734     @Test
 735     void testOperatorMissingError() throws IOException {
 736 
 737         String code = &quot;package test; public class ErrorTest { &quot;
 738                 + &quot;void method() { int x = y  z } }&quot;;
 739         CompilationUnitTree cut = getCompilationUnitTree(code);
 740         final List&lt;String&gt; values = new ArrayList&lt;&gt;();
 741         final List&lt;String&gt; expectedValues =
 742                 new ArrayList&lt;&gt;(Arrays.asList(&quot;[z]&quot;));
 743 
 744         new TreeScanner&lt;Void, Void&gt;() {
 745             @Override
 746             public Void visitErroneous(ErroneousTree node, Void p) {
 747                 values.add(getErroneousTreeValues(node).toString());
 748                 return null;
 749 
 750             }
 751         }.scan(cut, null);
 752 
 753         assertEquals(&quot;testOperatorMissingError: The Erroneous tree &quot;
 754                 + &quot;error values: &quot; + values
 755                 + &quot; do not match expected error values: &quot;
 756                 + expectedValues, values, expectedValues);
 757     }
 758 
 759     // expected erroneous tree:  String s = (ERROR);
 760     @Test
 761     void testMissingParenthesisError() throws IOException {
 762 
 763         String code = &quot;package test; public class ErrorTest { &quot;
 764                 + &quot;void f() {String s = new String; } }&quot;;
 765         CompilationUnitTree cut = getCompilationUnitTree(code);
 766         final List&lt;String&gt; values = new ArrayList&lt;&gt;();
 767         final List&lt;String&gt; expectedValues =
 768                 new ArrayList&lt;&gt;(Arrays.asList(&quot;[new String()]&quot;));
 769 
 770         new TreeScanner&lt;Void, Void&gt;() {
 771             @Override
 772             public Void visitErroneous(ErroneousTree node, Void p) {
 773                 values.add(getErroneousTreeValues(node).toString());
 774                 return null;
 775             }
 776         }.scan(cut, null);
 777 
 778         assertEquals(&quot;testMissingParenthesisError: The Erroneous tree &quot;
 779                 + &quot;error values: &quot; + values
 780                 + &quot; do not match expected error values: &quot;
 781                 + expectedValues, values, expectedValues);
 782     }
 783 
 784     // expected erroneous tree: package test; (ERROR)(ERROR)
 785     @Test
 786     void testMissingClassError() throws IOException {
 787 
 788         String code = &quot;package Test; clas ErrorTest {  &quot;
 789                 + &quot;void f() {String s = new String(); } }&quot;;
 790         CompilationUnitTree cut = getCompilationUnitTree(code);
 791         final List&lt;String&gt; values = new ArrayList&lt;&gt;();
 792         final List&lt;String&gt; expectedValues =
 793                 new ArrayList&lt;&gt;(Arrays.asList(&quot;[, clas]&quot;, &quot;[]&quot;));
 794 
 795         new TreeScanner&lt;Void, Void&gt;() {
 796             @Override
 797             public Void visitErroneous(ErroneousTree node, Void p) {
 798                 values.add(getErroneousTreeValues(node).toString());
 799                 return null;
 800             }
 801         }.scan(cut, null);
 802 
 803         assertEquals(&quot;testMissingClassError: The Erroneous tree &quot;
 804                 + &quot;error values: &quot; + values
 805                 + &quot; do not match expected error values: &quot;
 806                 + expectedValues, values, expectedValues);
 807     }
 808 
 809     // expected erroneous tree: void m1(int i) {(ERROR);{(ERROR);}
 810     @Test
 811     void testSwitchError() throws IOException {
 812 
 813         String code = &quot;package test; public class ErrorTest { &quot;
 814                 + &quot;int numDays; void m1(int i) { switchh {i} { case 1: &quot;
 815                 + &quot;numDays = 31; break; } } }&quot;;
 816         CompilationUnitTree cut = getCompilationUnitTree(code);
 817         final List&lt;String&gt; values = new ArrayList&lt;&gt;();
 818         final List&lt;String&gt; expectedValues =
 819                 new ArrayList&lt;&gt;(Arrays.asList(&quot;[switchh]&quot;, &quot;[i]&quot;));
 820 
 821         new TreeScanner&lt;Void, Void&gt;() {
 822             @Override
 823             public Void visitErroneous(ErroneousTree node, Void p) {
 824                 values.add(getErroneousTreeValues(node).toString());
 825                 return null;
 826             }
 827         }.scan(cut, null);
 828 
 829         assertEquals(&quot;testSwitchError: The Erroneous tree &quot;
 830                 + &quot;error values: &quot; + values
 831                 + &quot; do not match expected error values: &quot;
 832                 + expectedValues, values, expectedValues);
 833     }
 834 
 835     // expected erroneous tree: class ErrorTest {(ERROR)
 836     @Test
 837     void testMethodError() throws IOException {
 838 
 839         String code = &quot;package Test; class ErrorTest {  &quot;
 840                 + &quot;static final void f) {String s = new String(); } }&quot;;
 841         CompilationUnitTree cut = cut = getCompilationUnitTree(code);
 842 
 843         final List&lt;String&gt; values = new ArrayList&lt;&gt;();
 844         final List&lt;String&gt; expectedValues =
 845                 new ArrayList&lt;&gt;(Arrays.asList(&quot;[\nstatic final void f();]&quot;));
 846 
 847         new TreeScanner&lt;Void, Void&gt;() {
 848             @Override
 849             public Void visitErroneous(ErroneousTree node, Void p) {
 850                 values.add(normalize(getErroneousTreeValues(node).toString()));
 851                 return null;
 852             }
 853         }.scan(cut, null);
 854 
 855         assertEquals(&quot;testMethodError: The Erroneous tree &quot;
 856                 + &quot;error value: &quot; + values
 857                 + &quot; does not match expected error values: &quot;
 858                 + expectedValues, values, expectedValues);
 859     }
 860 
 861     /*
 862      * The following tests do not work just yet with nb-javac nor javac,
 863      * they need further investigation, see CR: 7167356
 864      */
 865 
 866     void testPositionBrokenSource126732a() throws IOException {
 867         String[] commands = new String[]{
 868             &quot;return Runnable()&quot;,
 869             &quot;do { } while (true)&quot;,
 870             &quot;throw UnsupportedOperationException()&quot;,
 871             &quot;assert true&quot;,
 872             &quot;1 + 1&quot;,};
 873 
 874         for (String command : commands) {
 875 
 876             String code = &quot;package test;\n&quot;
 877                     + &quot;public class Test {\n&quot;
 878                     + &quot;    public static void test() {\n&quot;
 879                     + &quot;        &quot; + command + &quot; {\n&quot;
 880                     + &quot;                new Runnable() {\n&quot;
 881                     + &quot;        };\n&quot;
 882                     + &quot;    }\n&quot;
 883                     + &quot;}&quot;;
 884             JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, null,
 885                     null, null, Arrays.asList(new MyFileObject(code)));
 886             CompilationUnitTree cut = ct.parse().iterator().next();
 887 
 888             ClassTree clazz = (ClassTree) cut.getTypeDecls().get(0);
 889             MethodTree method = (MethodTree) clazz.getMembers().get(0);
 890             List&lt;? extends StatementTree&gt; statements =
 891                     method.getBody().getStatements();
 892 
 893             StatementTree ret = statements.get(0);
 894             StatementTree block = statements.get(1);
 895 
 896             Trees t = Trees.instance(ct);
 897             int len = code.indexOf(command + &quot; {&quot;) + (command + &quot; &quot;).length();
 898             assertEquals(command, len,
 899                     t.getSourcePositions().getEndPosition(cut, ret));
 900             assertEquals(command, len,
 901                     t.getSourcePositions().getStartPosition(cut, block));
 902         }
 903     }
 904 
 905     void testPositionBrokenSource126732b() throws IOException {
 906         String[] commands = new String[]{
 907             &quot;break&quot;,
 908             &quot;break A&quot;,
 909             &quot;continue &quot;,
 910             &quot;continue A&quot;,};
 911 
 912         for (String command : commands) {
 913 
 914             String code = &quot;package test;\n&quot;
 915                     + &quot;public class Test {\n&quot;
 916                     + &quot;    public static void test() {\n&quot;
 917                     + &quot;        while (true) {\n&quot;
 918                     + &quot;            &quot; + command + &quot; {\n&quot;
 919                     + &quot;                new Runnable() {\n&quot;
 920                     + &quot;        };\n&quot;
 921                     + &quot;        }\n&quot;
 922                     + &quot;    }\n&quot;
 923                     + &quot;}&quot;;
 924 
 925             JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, null,
 926                     null, null, Arrays.asList(new MyFileObject(code)));
 927             CompilationUnitTree cut = ct.parse().iterator().next();
 928 
 929             ClassTree clazz = (ClassTree) cut.getTypeDecls().get(0);
 930             MethodTree method = (MethodTree) clazz.getMembers().get(0);
 931             List&lt;? extends StatementTree&gt; statements =
 932                     ((BlockTree) ((WhileLoopTree) method.getBody().getStatements().get(0)).getStatement()).getStatements();
 933 
 934             StatementTree ret = statements.get(0);
 935             StatementTree block = statements.get(1);
 936 
 937             Trees t = Trees.instance(ct);
 938             int len = code.indexOf(command + &quot; {&quot;) + (command + &quot; &quot;).length();
 939             assertEquals(command, len,
 940                     t.getSourcePositions().getEndPosition(cut, ret));
 941             assertEquals(command, len,
 942                     t.getSourcePositions().getStartPosition(cut, block));
 943         }
 944     }
 945 
 946     void testStartPositionEnumConstantInit() throws IOException {
 947 
 948         String code = &quot;package t; enum Test { AAA; }&quot;;
 949 
 950         JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, null, null,
 951                 null, Arrays.asList(new MyFileObject(code)));
 952         CompilationUnitTree cut = ct.parse().iterator().next();
 953         ClassTree clazz = (ClassTree) cut.getTypeDecls().get(0);
 954         VariableTree enumAAA = (VariableTree) clazz.getMembers().get(0);
 955         Trees t = Trees.instance(ct);
 956         int start = (int) t.getSourcePositions().getStartPosition(cut,
 957                 enumAAA.getInitializer());
 958 
 959         assertEquals(&quot;testStartPositionEnumConstantInit&quot;, -1, start);
 960     }
 961 
 962     @Test
 963     void testVoidLambdaParameter() throws IOException {
 964         String code = &quot;package t; class Test { &quot; +
 965                 &quot;Runnable r = (void v) -&gt; { };&quot; +
 966                 &quot;}&quot;;
 967         DiagnosticCollector&lt;JavaFileObject&gt; coll =
 968                 new DiagnosticCollector&lt;&gt;();
 969         JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll, null,
 970                 null, Arrays.asList(new MyFileObject(code)));
 971 
 972         CompilationUnitTree cut = ct.parse().iterator().next();
 973         ClassTree clazz = (ClassTree) cut.getTypeDecls().get(0);
 974         VariableTree field = (VariableTree) clazz.getMembers().get(0);
 975 
 976         assertEquals(&quot;actual kind: &quot; + field.getInitializer().getKind(),
 977                      field.getInitializer().getKind(),
 978                      Kind.LAMBDA_EXPRESSION);
 979 
 980         LambdaExpressionTree lambda = (LambdaExpressionTree) field.getInitializer();
 981 
 982         assertEquals(&quot;actual parameters: &quot; + lambda.getParameters().size(),
 983                      lambda.getParameters().size(),
 984                      1);
 985 
 986         Tree paramType = lambda.getParameters().get(0).getType();
 987 
 988         assertEquals(&quot;actual parameter type: &quot; + paramType.getKind(),
 989                      paramType.getKind(),
 990                      Kind.PRIMITIVE_TYPE);
 991 
 992         TypeKind primitiveTypeKind = ((PrimitiveTypeTree) paramType).getPrimitiveTypeKind();
 993 
 994         assertEquals(&quot;actual parameter type: &quot; + primitiveTypeKind,
 995                      primitiveTypeKind,
 996                      TypeKind.VOID);
 997     }
 998 
 999     @Test //JDK-8065753
1000     void testWrongFirstToken() throws IOException {
1001         String code = &quot;&lt;&quot;;
1002         String expectedErrors = &quot;Test.java:1:1: compiler.err.expected3: class, interface, enum\n&quot; +
1003                                 &quot;1 error\n&quot;;
1004         StringWriter out = new StringWriter();
1005         JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(out, fm, null,
1006                 Arrays.asList(&quot;-XDrawDiagnostics&quot;), null, Arrays.asList(new MyFileObject(code)));
1007 
1008         Result errorCode = ct.doCall();
1009         assertEquals(&quot;the error code is not correct; actual:&quot; + errorCode, Main.Result.ERROR, errorCode);
1010         String actualErrors = normalize(out.toString());
1011         assertEquals(&quot;the error message is not correct, actual: &quot; + actualErrors, expectedErrors, actualErrors);
1012     }
1013 
1014     @Test //JDK-8205913
1015     void testForInit() throws IOException {
1016         String code = &quot;class T { void t() { for (n : ns) { } } }&quot;;
1017         String expectedErrors = &quot;Test.java:1:27: compiler.err.bad.initializer: for-loop\n&quot;;
1018         StringWriter out = new StringWriter();
1019         JavacTask ct = (JavacTask) tool.getTask(out, fm, null,
1020                 Arrays.asList(&quot;-XDrawDiagnostics&quot;), null, Arrays.asList(new MyFileObject(code)));
1021 
1022         Iterable&lt;? extends CompilationUnitTree&gt; cuts = ct.parse();
1023         boolean[] foundVar = new boolean[1];
1024 
1025         new TreePathScanner&lt;Void, Void&gt;() {
1026             @Override public Void visitVariable(VariableTree vt, Void p) {
1027                 assertNotNull(vt.getModifiers());
1028                 assertNotNull(vt.getType());
1029                 assertNotNull(vt.getName());
1030                 assertEquals(&quot;name should be &lt;error&gt;&quot;, &quot;&lt;error&gt;&quot;, vt.getName().toString());
1031                 foundVar[0] = true;
1032                 return super.visitVariable(vt, p);
1033             }
1034         }.scan(cuts, null);
1035 
1036         if (!foundVar[0]) {
1037             fail(&quot;haven&#39;t found a variable&quot;);
1038         }
1039 
1040         String actualErrors = normalize(out.toString());
1041         assertEquals(&quot;the error message is not correct, actual: &quot; + actualErrors, expectedErrors, actualErrors);
1042     }
1043 
1044     @Test //JDK-821742
1045     void testCompDeclVarType() throws IOException {
1046         String code = &quot;package test; public class Test {&quot;
1047                 + &quot;private void test() {&quot;
1048                 + &quot;var v1 = 10,v2 = 12;&quot;
1049                 + &quot;} private Test() {}}&quot;;
1050 
1051         JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, null,
1052                 null, null, Arrays.asList(new MyFileObject(code)));
1053         CompilationUnitTree cut = ct.parse().iterator().next();
1054         ct.enter();
1055         ct.analyze();
1056         ClassTree clazz = (ClassTree) cut.getTypeDecls().get(0);
1057         MethodTree method = (MethodTree) clazz.getMembers().get(0);
1058         VariableTree stmt1 = (VariableTree) method.getBody().getStatements().get(0);
1059         VariableTree stmt2 = (VariableTree) method.getBody().getStatements().get(1);
1060         Tree v1Type = stmt1.getType();
1061         Tree v2Type = stmt2.getType();
1062         assertEquals(&quot;Implicit type for v1 is not correct: &quot;, Kind.PRIMITIVE_TYPE, v1Type.getKind());
1063         assertEquals(&quot;Implicit type for v2 is not correct: &quot;, Kind.PRIMITIVE_TYPE, v2Type.getKind());
1064     }
1065 
1066     @Test
1067     void testCaseBodyStatements() throws IOException {
1068         String code = &quot;class C {&quot; +
1069                       &quot;    void t(int i) {&quot; +
1070                       &quot;        switch (i) {&quot; +
1071                       &quot;            case 0 -&gt; i++;&quot; +
1072                       &quot;            case 1 -&gt; { i++; }&quot; +
1073                       &quot;            case 2 -&gt; throw new RuntimeException();&quot; +
1074                       &quot;            case 3 -&gt; if (true) ;&quot; +
1075                       &quot;            default -&gt; i++;&quot; +
1076                       &quot;        }&quot; +
1077                       &quot;        switch (i) {&quot; +
1078                       &quot;            case 0: i++; break;&quot; +
1079                       &quot;            case 1: { i++; break;}&quot; +
1080                       &quot;            case 2: throw new RuntimeException();&quot; +
1081                       &quot;            case 3: if (true) ; break;&quot; +
1082                       &quot;            default: i++; break;&quot; +
1083                       &quot;        }&quot; +
1084                       &quot;        int j = switch (i) {&quot; +
1085                       &quot;            case 0 -&gt; i + 1;&quot; +
1086                       &quot;            case 1 -&gt; { yield i + 1; }&quot; +
1087                       &quot;            default -&gt; throw new RuntimeException();&quot; +
1088                       &quot;        };&quot; +
1089                       &quot;        int k = switch (i) {&quot; +
1090                       &quot;            case 0: yield i + 1;&quot; +
1091                       &quot;            case 1: { yield i + 1; }&quot; +
1092                       &quot;            default: throw new RuntimeException();&quot; +
1093                       &quot;        };&quot; +
1094                       &quot;    }&quot; +
1095                       &quot;}&quot;;
1096         String expectedErrors = &quot;Test.java:1:178: compiler.err.switch.case.unexpected.statement\n&quot;;
1097         StringWriter out = new StringWriter();
1098         JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(out, fm, null,
1099                 Arrays.asList(&quot;-XDrawDiagnostics&quot;),
1100                 null, Arrays.asList(new MyFileObject(code)));
1101 
1102         CompilationUnitTree cut = ct.parse().iterator().next();
1103         Trees trees = Trees.instance(ct);
1104         List&lt;String&gt; spans = new ArrayList&lt;&gt;();
1105 
1106         new TreePathScanner&lt;Void, Void&gt;() {
1107             @Override
1108             public Void visitCase(CaseTree tree, Void v) {
1109                 if (tree.getBody() != null) {
1110                     int start = (int) trees.getSourcePositions().getStartPosition(cut, tree.getBody());
1111                     int end = (int) trees.getSourcePositions().getEndPosition(cut, tree.getBody());
1112                     spans.add(code.substring(start, end));
1113                 } else {
1114                     spans.add(&quot;&lt;null&gt;&quot;);
1115                 }
1116                 return super.visitCase(tree, v);
1117             }
1118         }.scan(cut, null);
1119 
1120         List&lt;String&gt; expectedSpans = List.of(
1121                 &quot;i++;&quot;, &quot;{ i++; }&quot;, &quot;throw new RuntimeException();&quot;, &quot;if (true) ;&quot;, &quot;i++;&quot;,
1122                 &quot;&lt;null&gt;&quot;, &quot;&lt;null&gt;&quot;, &quot;&lt;null&gt;&quot;, &quot;&lt;null&gt;&quot;, &quot;&lt;null&gt;&quot;,
1123                 &quot;i + 1&quot;/*TODO semicolon?*/, &quot;{ yield i + 1; }&quot;, &quot;throw new RuntimeException();&quot;,
1124                 &quot;&lt;null&gt;&quot;, &quot;&lt;null&gt;&quot;, &quot;&lt;null&gt;&quot;);
1125         assertEquals(&quot;the error spans are not correct; actual:&quot; + spans, expectedSpans, spans);
1126         String toString = normalize(cut.toString());
1127         String expectedToString =
1128                 &quot;\n&quot; +
1129                 &quot;class C {\n&quot; +
1130                 &quot;    \n&quot; +
1131                 &quot;    void t(int i) {\n&quot; +
1132                 &quot;        switch (i) {\n&quot; +
1133                 &quot;        case 0 -&gt; i++;\n&quot; +
1134                 &quot;        case 1 -&gt; {\n&quot; +
1135                 &quot;            i++;\n&quot; +
1136                 &quot;        }\n&quot; +
1137                 &quot;        case 2 -&gt; throw new RuntimeException();\n&quot; +
1138                 &quot;        case 3 -&gt; if (true) ;\n&quot; +
1139                 &quot;        default -&gt; i++;\n&quot; +
1140                 &quot;        }\n&quot; +
1141                 &quot;        switch (i) {\n&quot; +
1142                 &quot;        case 0:\n&quot; +
1143                 &quot;            i++;\n&quot; +
1144                 &quot;            break;\n&quot; +
1145                 &quot;        \n&quot; +
1146                 &quot;        case 1:\n&quot; +
1147                 &quot;            {\n&quot; +
1148                 &quot;                i++;\n&quot; +
1149                 &quot;                break;\n&quot; +
1150                 &quot;            }\n&quot; +
1151                 &quot;        \n&quot; +
1152                 &quot;        case 2:\n&quot; +
1153                 &quot;            throw new RuntimeException();\n&quot; +
1154                 &quot;        \n&quot; +
1155                 &quot;        case 3:\n&quot; +
1156                 &quot;            if (true) ;\n&quot; +
1157                 &quot;            break;\n&quot; +
1158                 &quot;        \n&quot; +
1159                 &quot;        default:\n&quot; +
1160                 &quot;            i++;\n&quot; +
1161                 &quot;            break;\n&quot; +
1162                 &quot;        \n&quot; +
1163                 &quot;        }\n&quot; +
1164                 &quot;        int j = switch (i) {\n&quot; +
1165                 &quot;        case 0 -&gt; yield i + 1;\n&quot; +
1166                 &quot;        case 1 -&gt; {\n&quot; +
1167                 &quot;            yield i + 1;\n&quot; +
1168                 &quot;        }\n&quot; +
1169                 &quot;        default -&gt; throw new RuntimeException();\n&quot; +
1170                 &quot;        };\n&quot; +
1171                 &quot;        int k = switch (i) {\n&quot; +
1172                 &quot;        case 0:\n&quot; +
1173                 &quot;            yield i + 1;\n&quot; +
1174                 &quot;        \n&quot; +
1175                 &quot;        case 1:\n&quot; +
1176                 &quot;            {\n&quot; +
1177                 &quot;                yield i + 1;\n&quot; +
1178                 &quot;            }\n&quot; +
1179                 &quot;        \n&quot; +
1180                 &quot;        default:\n&quot; +
1181                 &quot;            throw new RuntimeException();\n&quot; +
1182                 &quot;        \n&quot; +
1183                 &quot;        };\n&quot; +
1184                 &quot;    }\n&quot; +
1185                 &quot;}&quot;;
1186         System.err.println(&quot;toString:&quot;);
1187         System.err.println(toString);
1188         System.err.println(&quot;expectedToString:&quot;);
1189         System.err.println(expectedToString);
1190         assertEquals(&quot;the error spans are not correct; actual:&quot; + toString, expectedToString, toString);
1191         String actualErrors = normalize(out.toString());
1192         assertEquals(&quot;the error message is not correct, actual: &quot; + actualErrors, expectedErrors, actualErrors);
1193     }
1194 
1195     @Test
1196     void testTypeParamsWithoutMethod() throws IOException {
1197         assert tool != null;
1198 
1199         String code = &quot;package test; class Test { /**javadoc*/ |public &lt;T&gt; |}&quot;;
1200         String[] parts = code.split(&quot;\\|&quot;);
1201 
1202         code = parts[0] + parts[1] + parts[2];
1203 
1204         JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, null, null,
1205                 null, Arrays.asList(new MyFileObject(code)));
1206         Trees trees = Trees.instance(ct);
1207         SourcePositions pos = trees.getSourcePositions();
1208         CompilationUnitTree cut = ct.parse().iterator().next();
1209         ClassTree clazz = (ClassTree) cut.getTypeDecls().get(0);
1210         ErroneousTree err = (ErroneousTree) clazz.getMembers().get(0);
1211         MethodTree method = (MethodTree) err.getErrorTrees().get(0);
1212 
1213         final int methodStart = parts[0].length();
1214         final int methodEnd = parts[0].length() + parts[1].length();
1215         assertEquals(&quot;testTypeParamsWithoutMethod&quot;,
1216                 methodStart, pos.getStartPosition(cut, method));
1217         assertEquals(&quot;testTypeParamsWithoutMethod&quot;,
1218                 methodEnd, pos.getEndPosition(cut, method));
1219 
1220         TreePath path2Method = new TreePath(new TreePath(new TreePath(cut), clazz), method);
1221         String javadoc = trees.getDocComment(path2Method);
1222 
1223         if (!&quot;javadoc&quot;.equals(javadoc)) {
1224             throw new AssertionError(&quot;Expected javadoc not found, actual javadoc: &quot; + javadoc);
1225         }
1226     }
1227 
1228     @Test
1229     void testAnalyzeParensWithComma1() throws IOException {
1230         assert tool != null;
1231 
1232         String code = &quot;package test; class Test { FI fi = |(s, |&quot;;
1233         String[] parts = code.split(&quot;\\|&quot;, 3);
1234 
1235         code = parts[0] + parts[1] + parts[2];
1236 
1237         JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, null, null,
1238                 null, Arrays.asList(new MyFileObject(code)));
1239         Trees trees = Trees.instance(ct);
1240         SourcePositions pos = trees.getSourcePositions();
1241         CompilationUnitTree cut = ct.parse().iterator().next();
1242         boolean[] found = new boolean[1];
1243 
1244         new TreeScanner&lt;Void, Void&gt;() {
1245             @Override
1246             public Void visitLambdaExpression(LambdaExpressionTree tree, Void v) {
1247                 found[0] = true;
1248                 int lambdaStart = parts[0].length();
1249                 int lambdaEnd = parts[0].length() + parts[1].length();
1250                 assertEquals(&quot;testAnalyzeParensWithComma1&quot;,
1251                         lambdaStart, pos.getStartPosition(cut, tree));
1252                 assertEquals(&quot;testAnalyzeParensWithComma1&quot;,
1253                         lambdaEnd, pos.getEndPosition(cut, tree));
1254                 return null;
1255             }
1256         }.scan(cut, null);
1257 
1258         assertTrue(&quot;testAnalyzeParensWithComma1&quot;, found[0]);
1259     }
1260 
1261     @Test
1262     void testAnalyzeParensWithComma2() throws IOException {
1263         assert tool != null;
1264 
1265         String code = &quot;package test; class Test { FI fi = |(s, o)|&quot;;
1266         String[] parts = code.split(&quot;\\|&quot;, 3);
1267 
1268         code = parts[0] + parts[1] + parts[2];
1269 
1270         JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, null, null,
1271                 null, Arrays.asList(new MyFileObject(code)));
1272         Trees trees = Trees.instance(ct);
1273         SourcePositions pos = trees.getSourcePositions();
1274         CompilationUnitTree cut = ct.parse().iterator().next();
1275         boolean[] found = new boolean[1];
1276 
1277         new TreeScanner&lt;Void, Void&gt;() {
1278             @Override
1279             public Void visitLambdaExpression(LambdaExpressionTree tree, Void v) {
1280                 found[0] = true;
1281                 int lambdaStart = parts[0].length();
1282                 int lambdaEnd = parts[0].length() + parts[1].length();
1283                 assertEquals(&quot;testAnalyzeParensWithComma2&quot;,
1284                         lambdaStart, pos.getStartPosition(cut, tree));
1285                 assertEquals(&quot;testAnalyzeParensWithComma2&quot;,
1286                         lambdaEnd, pos.getEndPosition(cut, tree));
1287                 return null;
1288             }
1289         }.scan(cut, null);
1290 
1291         assertTrue(&quot;testAnalyzeParensWithComma2&quot;, found[0]);
1292     }
1293 
1294     @Test
1295     void testBrokenEnum1() throws IOException {
1296         assert tool != null;
1297 
1298         String code = &quot;package test; class Test { enum E { A, B, C. D, E, F; } }&quot;;
1299         StringWriter output = new StringWriter();
1300         JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(output, fm, null, List.of(&quot;-XDrawDiagnostics&quot;),
1301                 null, Arrays.asList(new MyFileObject(code)));
1302         CompilationUnitTree cut = ct.parse().iterator().next();
1303         List&lt;String&gt; actual = List.of(output.toString().split(&quot;\r?\n&quot;));
1304         List&lt;String&gt; expected = List.of(&quot;Test.java:1:44: compiler.err.expected3: &#39;,&#39;, &#39;}&#39;, &#39;;&#39;&quot;);
1305 
1306         assertEquals(&quot;The expected and actual errors do not match, actual errors: &quot; + actual,
1307                      actual,
1308                      expected);
1309 
1310         String actualAST = cut.toString().replaceAll(&quot;\r*\n&quot;, &quot;\n&quot;);
1311         String expectedAST = &quot;package test;\n&quot; +
1312                              &quot;\n&quot; +
1313                              &quot;class Test {\n&quot; +
1314                              &quot;    \n&quot; +
1315                              &quot;    enum E {\n&quot; +
1316                              &quot;        /*public static final*/ A /* = new E() */ /*enum*/ ,\n&quot; +
1317                              &quot;        /*public static final*/ B /* = new E() */ /*enum*/ ,\n&quot; +
1318                              &quot;        /*public static final*/ C /* = new E() */ /*enum*/ ,\n&quot; +
1319                              &quot;        /*public static final*/ D /* = new E() */ /*enum*/ ,\n&quot; +
1320                              &quot;        /*public static final*/ E /* = new E() */ /*enum*/ ,\n&quot; +
1321                              &quot;        /*public static final*/ F /* = new E() */ /*enum*/ ;\n&quot; +
1322                              &quot;        (ERROR) &lt;error&gt;;\n&quot; +
1323                              &quot;    }\n&quot; +
1324                              &quot;}&quot;;
1325         assertEquals(&quot;The expected and actual AST do not match, actual AST: &quot; + actualAST,
1326                      actualAST,
1327                      expectedAST);
1328     }
1329 
1330     @Test
1331     void testBrokenEnum2() throws IOException {
1332         assert tool != null;
1333 
1334         String code = &quot;package test; class Test { enum E { A, B, C void t() {} } }&quot;;
1335         StringWriter output = new StringWriter();
1336         JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(output, fm, null, List.of(&quot;-XDrawDiagnostics&quot;),
1337                 null, Arrays.asList(new MyFileObject(code)));
1338         CompilationUnitTree cut = ct.parse().iterator().next();
1339         List&lt;String&gt; actual = List.of(output.toString().split(&quot;\r?\n&quot;));
1340         List&lt;String&gt; expected = List.of(&quot;Test.java:1:44: compiler.err.expected3: &#39;,&#39;, &#39;}&#39;, &#39;;&#39;&quot;);
1341 
1342         assertEquals(&quot;The expected and actual errors do not match, actual errors: &quot; + actual,
1343                      actual,
1344                      expected);
1345 
1346         String actualAST = cut.toString().replaceAll(&quot;\r*\n&quot;, &quot;\n&quot;);
1347         String expectedAST = &quot;package test;\n&quot; +
1348                              &quot;\n&quot; +
1349                              &quot;class Test {\n&quot; +
1350                              &quot;    \n&quot; +
1351                              &quot;    enum E {\n&quot; +
1352                              &quot;        /*public static final*/ A /* = new E() */ /*enum*/ ,\n&quot; +
1353                              &quot;        /*public static final*/ B /* = new E() */ /*enum*/ ,\n&quot; +
1354                              &quot;        /*public static final*/ C /* = new E() */ /*enum*/ ;\n&quot; +
1355                              &quot;        \n&quot; +
1356                              &quot;        void t() {\n&quot; +
1357                              &quot;        }\n&quot; +
1358                              &quot;    }\n&quot; +
1359                              &quot;}&quot;;
1360         assertEquals(&quot;The expected and actual AST do not match, actual AST: &quot; + actualAST,
1361                      actualAST,
1362                      expectedAST);
1363     }
1364 
1365     @Test
1366     void testBrokenEnum3() throws IOException {
1367         assert tool != null;
1368 
1369         String code = &quot;package test; class Test { enum E { , void t() {} } }&quot;;
1370         StringWriter output = new StringWriter();
1371         JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(output, fm, null, List.of(&quot;-XDrawDiagnostics&quot;),
1372                 null, Arrays.asList(new MyFileObject(code)));
1373         CompilationUnitTree cut = ct.parse().iterator().next();
1374         List&lt;String&gt; actual = List.of(output.toString().split(&quot;\r?\n&quot;));
1375         List&lt;String&gt; expected = List.of(&quot;Test.java:1:38: compiler.err.expected2: &#39;}&#39;, &#39;;&#39;&quot;);
1376 
1377         assertEquals(&quot;The expected and actual errors do not match, actual errors: &quot; + actual,
1378                      actual,
1379                      expected);
1380 
1381         String actualAST = cut.toString().replaceAll(&quot;\r*\n&quot;, &quot;\n&quot;);
1382         String expectedAST = &quot;package test;\n&quot; +
1383                              &quot;\n&quot; +
1384                              &quot;class Test {\n&quot; +
1385                              &quot;    \n&quot; +
1386                              &quot;    enum E {\n&quot; +
1387                              &quot;;\n&quot; +
1388                              &quot;        \n&quot; +
1389                              &quot;        void t() {\n&quot; +
1390                              &quot;        }\n&quot; +
1391                              &quot;    }\n&quot; +
1392                              &quot;}&quot;;
1393         assertEquals(&quot;The expected and actual AST do not match, actual AST: &quot; + actualAST,
1394                      actualAST,
1395                      expectedAST);
1396     }
1397 
1398     @Test
1399     void testBrokenEnum4() throws IOException {
1400         assert tool != null;
1401 
1402         String code = &quot;package test; class Test { enum E { A, B, C, void t() {} } }&quot;;
1403         StringWriter output = new StringWriter();
1404         JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(output, fm, null, List.of(&quot;-XDrawDiagnostics&quot;),
1405                 null, Arrays.asList(new MyFileObject(code)));
1406         CompilationUnitTree cut = ct.parse().iterator().next();
1407         List&lt;String&gt; actual = List.of(output.toString().split(&quot;\r?\n&quot;));
1408         List&lt;String&gt; expected = List.of(&quot;Test.java:1:46: compiler.err.enum.constant.expected&quot;);
1409 
1410         assertEquals(&quot;The expected and actual errors do not match, actual errors: &quot; + actual,
1411                      actual,
1412                      expected);
1413 
1414         String actualAST = cut.toString().replaceAll(&quot;\r*\n&quot;, &quot;\n&quot;);
1415         String expectedAST = &quot;package test;\n&quot; +
1416                              &quot;\n&quot; +
1417                              &quot;class Test {\n&quot; +
1418                              &quot;    \n&quot; +
1419                              &quot;    enum E {\n&quot; +
1420                              &quot;        /*public static final*/ A /* = new E() */ /*enum*/ ,\n&quot; +
1421                              &quot;        /*public static final*/ B /* = new E() */ /*enum*/ ,\n&quot; +
1422                              &quot;        /*public static final*/ C /* = new E() */ /*enum*/ ;\n&quot; +
1423                              &quot;        \n&quot; +
1424                              &quot;        void t() {\n&quot; +
1425                              &quot;        }\n&quot; +
1426                              &quot;    }\n&quot; +
1427                              &quot;}&quot;;
1428         assertEquals(&quot;The expected and actual AST do not match, actual AST: &quot; + actualAST,
1429                      actualAST,
1430                      expectedAST);
1431     }
1432 
1433     @Test
1434     void testBrokenEnum5() throws IOException {
1435         assert tool != null;
1436 
1437         String code = &quot;package test; class Test { enum E { A; void t() {} B; } }&quot;;
1438         StringWriter output = new StringWriter();
1439         JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(output, fm, null, List.of(&quot;-XDrawDiagnostics&quot;),
1440                 null, Arrays.asList(new MyFileObject(code)));
1441         CompilationUnitTree cut = ct.parse().iterator().next();
1442         List&lt;String&gt; actual = List.of(output.toString().split(&quot;\r?\n&quot;));
1443         List&lt;String&gt; expected = List.of(&quot;Test.java:1:52: compiler.err.enum.constant.not.expected&quot;);
1444 
1445         assertEquals(&quot;The expected and actual errors do not match, actual errors: &quot; + actual,
1446                      actual,
1447                      expected);
1448 
1449         String actualAST = cut.toString().replaceAll(&quot;\r*\n&quot;, &quot;\n&quot;);
1450         String expectedAST = &quot;package test;\n&quot; +
1451                              &quot;\n&quot; +
1452                              &quot;class Test {\n&quot; +
1453                              &quot;    \n&quot; +
1454                              &quot;    enum E {\n&quot; +
1455                              &quot;        /*public static final*/ A /* = new E() */ /*enum*/ ,\n&quot; +
1456                              &quot;        /*public static final*/ B /* = new E() */ /*enum*/ ;\n&quot; +
1457                              &quot;        \n&quot; +
1458                              &quot;        void t() {\n&quot; +
1459                              &quot;        }\n&quot; +
1460                              &quot;    }\n&quot; +
1461                              &quot;}&quot;;
1462         assertEquals(&quot;The expected and actual AST do not match, actual AST: &quot; + actualAST,
1463                      actualAST,
1464                      expectedAST);
1465     }
1466 
1467     void run(String[] args) throws Exception {
1468         int passed = 0, failed = 0;
1469         final Pattern p = (args != null &amp;&amp; args.length &gt; 0)
1470                 ? Pattern.compile(args[0])
1471                 : null;
1472         for (Method m : this.getClass().getDeclaredMethods()) {
1473             boolean selected = (p == null)
1474                     ? m.isAnnotationPresent(Test.class)
1475                     : p.matcher(m.getName()).matches();
1476             if (selected) {
1477                 try {
1478                     m.invoke(this, (Object[]) null);
1479                     System.out.println(m.getName() + &quot;: OK&quot;);
1480                     passed++;
1481                 } catch (Throwable ex) {
1482                     System.out.printf(&quot;Test %s failed: %s %n&quot;, m, ex.getCause());
1483                     failed++;
1484                 }
1485             }
1486         }
1487         System.out.printf(&quot;Passed: %d, Failed %d%n&quot;, passed, failed);
1488         if (failed &gt; 0) {
1489             throw new RuntimeException(&quot;Tests failed: &quot; + failed);
1490         }
1491         if (passed == 0 &amp;&amp; failed == 0) {
1492             throw new AssertionError(&quot;No test(s) selected: passed = &quot; +
1493                     passed + &quot;, failed = &quot; + failed + &quot; ??????????&quot;);
1494         }
1495     }
1496 }
1497 
1498 abstract class TestCase {
1499 
1500     void assertEquals(String message, int i, int pos) {
1501         if (i != pos) {
1502             fail(message);
1503         }
1504     }
1505 
1506     void assertFalse(String message, boolean bvalue) {
1507         if (bvalue == true) {
1508             fail(message);
1509         }
1510     }
1511 
1512     void assertTrue(String message, boolean bvalue) {
1513         if (bvalue == false) {
1514             fail(message);
1515         }
1516     }
1517 
1518     void assertEquals(String message, int i, long l) {
1519         if (i != l) {
1520             fail(message + &quot;:&quot; + i + &quot;:&quot; + l);
1521         }
1522     }
1523 
1524     void assertEquals(String message, Object o1, Object o2) {
1525         if (o1 != null &amp;&amp; o2 != null &amp;&amp; !o1.equals(o2)) {
1526             fail(message);
1527         }
1528         if (o1 == null &amp;&amp; o2 != null) {
1529             fail(message);
1530         }
1531     }
1532 
1533     void assertNotNull(Object o) {
1534         if (o == null) {
1535             fail();
1536         }
1537     }
1538 
1539     void fail() {
1540         fail(&quot;test failed&quot;);
1541     }
1542 
1543     void fail(String message) {
1544         throw new RuntimeException(message);
1545     }
1546 
1547     /**
1548      * Indicates that the annotated method is a test method.
1549      */
1550     @Retention(RetentionPolicy.RUNTIME)
1551     @Target(ElementType.METHOD)
1552     public @interface Test {}
1553 }
    </pre>
  </body>
</html>
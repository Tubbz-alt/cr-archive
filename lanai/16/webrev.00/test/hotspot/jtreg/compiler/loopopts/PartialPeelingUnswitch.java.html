<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/compiler/loopopts/PartialPeelingUnswitch.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /*
  25  * @test
  26  * @bug 8233033 8235984 8240227
  27  * @summary Tests if partially peeled statements are not executed before the loop predicates by bailing out of loop unswitching.
  28  *
  29  * @run main/othervm -Xbatch -XX:LoopStripMiningIter=0
  30  *      -XX:CompileCommand=compileonly,compiler.loopopts.PartialPeelingUnswitch::test*
  31  *      -XX:CompileCommand=dontinline,compiler.loopopts.PartialPeelingUnswitch::dontInline*
  32  *      compiler.loopopts.PartialPeelingUnswitch
  33  * @run main/othervm -Xbatch -Xcomp -XX:LoopStripMiningIter=0
  34  *      -XX:CompileCommand=compileonly,compiler.loopopts.PartialPeelingUnswitch::test*
  35  *      -XX:CompileCommand=dontinline,compiler.loopopts.PartialPeelingUnswitch::dontInline*
  36  *      compiler.loopopts.PartialPeelingUnswitch
  37  * @run main/othervm -Xbatch
  38  *      -XX:CompileCommand=compileonly,compiler.loopopts.PartialPeelingUnswitch::test*
  39  *      -XX:CompileCommand=dontinline,compiler.loopopts.PartialPeelingUnswitch::dontInline*
  40  *      compiler.loopopts.PartialPeelingUnswitch
  41  * @run main/othervm -Xbatch -Xcomp
  42  *      -XX:CompileCommand=compileonly,compiler.loopopts.PartialPeelingUnswitch::test*
  43  *      -XX:CompileCommand=dontinline,compiler.loopopts.PartialPeelingUnswitch::dontInline*
  44  *      compiler.loopopts.PartialPeelingUnswitch
  45  * @run main/othervm -Xbatch
  46  *      -XX:CompileCommand=compileonly,compiler.loopopts.PartialPeelingUnswitch::*
  47  *      -XX:CompileCommand=dontinline,compiler.loopopts.PartialPeelingUnswitch::dontInline*
  48  *      compiler.loopopts.PartialPeelingUnswitch
  49  * @run main/othervm -Xbatch -Xcomp
  50  *      -XX:CompileCommand=compileonly,compiler.loopopts.PartialPeelingUnswitch::*
  51  *      -XX:CompileCommand=dontinline,compiler.loopopts.PartialPeelingUnswitch::dontInline*
  52  *      compiler.loopopts.PartialPeelingUnswitch
  53  */
  54 
  55 package compiler.loopopts;
  56 
  57 public class PartialPeelingUnswitch {
  58 
  59     public static int iFld;
  60     public static int w = 88;
  61     public static int x = 42;
  62     public static int y = 31;
  63     public static int z = 22;
  64     public static int val = 34;
  65     public static final int iCon = 20;
  66 
  67     public static int[] iArr = new int[10];
  68 
  69     public int test() {
  70         /*
  71          * The inner loop of this test is first partially peeled and then unswitched. An uncommon trap is hit in one
  72          * of the cloned loop predicates for the fast loop (set up at unswitching stage). The only partially peeled
  73          * statement &quot;iFld += 7&quot; was wrongly executed before the predicates (and before the loop itself).
  74          * When hitting the uncommon trap, &quot;iFld &gt;&gt;= 1&quot; was not yet executed. As a result, the interpreter directly
  75          * reexecuted &quot;iFld += 7&quot; again. This resulted in a wrong result for &quot;iFld&quot;. The fix in 8233033 makes peeled
  76          * statements control dependant on the cloned loop predicates such that they are executed after them. However,
  77          * some cases are not handled properly. For now, the new fix in 8235984 just bails out of loop unswitching.
  78          */
  79         iFld = 13;
  80         for (int i = 0; i &lt; 8; i++) {
  81             int j = 10;
  82             while (--j &gt; 0) {
  83                 iFld += -7;
  84                 switch ((i * 5) + 102) {
  85                 case 120:
  86                     break;
  87                 case 103:
  88                     break;
  89                 case 116:
  90                     break;
  91                 default:
  92                     iFld &gt;&gt;= 1;
  93                 }
  94             }
  95         }
  96         return iFld;
  97     }
  98 
  99     public int test2() {
 100         /*
 101          * Same nested loop structure as in test() but with more statements that are partially peeled from the inner loop.
 102          * Afterwards the inner loop is unswitched.
 103          */
 104         iFld = 13;
 105         int k = 0;
 106         for (int i = 0; i &lt; 8; i++) {
 107             int j = 10;
 108             while (--j &gt; 0) {
 109                 // All statements before the switch expression are partially peeled
 110                 iFld += -7;
 111                 x = y + iFld;
 112                 y = iArr[5];
 113                 k = 6;
 114                 iArr[5] = 5;
 115                 iArr[6] += 23;
 116                 iArr[7] = iArr[8] + iArr[6];
 117                 iArr[j] = 34;
 118                 switch ((i * 5) + 102) {
 119                 case 120:
 120                     break;
 121                 case 103:
 122                     break;
 123                 case 116:
 124                     break;
 125                 default:
 126                     iFld &gt;&gt;= 1;
 127                 }
 128             }
 129         }
 130         return iFld + k;
 131     }
 132 
 133     public int test3() {
 134         iFld = 13;
 135         if (z &lt; 34) {
 136             z = 34;
 137         }
 138 
 139         for (int i = 0; i &lt; 8; i++) {
 140             int j = 10;
 141             while (--j &gt; 0) {
 142                 iFld += -7;
 143                 iArr[5] = 8;
 144                 x = iArr[6];
 145                 y = x;
 146                 for (int k = 50; k &lt; 51; k++) {
 147                     x = iArr[7];
 148                 }
 149                 switch ((i * 5) + 102) {
 150                 case 120:
 151                     return iFld;
 152                 case 103:
 153                     break;
 154                 case 116:
 155                     break;
 156                 default:
 157                     if (iFld == -7) {
 158                         return iFld;
 159                     }
 160                     z = iArr[5];
 161                     iFld &gt;&gt;= 1;
 162                 }
 163             }
 164             iArr[5] = 34;
 165             dontInline(iArr[5]);
 166         }
 167         return iFld;
 168     }
 169 
 170     public int test4() {
 171         iFld = 13;
 172         if (z &lt; 34) {
 173             z = 34;
 174         }
 175 
 176         for (int i = 0; i &lt; 8; i++) {
 177             int j = 10;
 178             while (--j &gt; 0) {
 179                 iFld += -7;
 180                 iArr[5] = 8;
 181                 x = iArr[6];
 182                 y = x;
 183                 for (int k = 50; k &lt; 51; k++) {
 184                     x = iArr[7];
 185                 }
 186                 switch ((i * 5) + 102) {
 187                 case 120:
 188                     return iFld;
 189                 case 103:
 190                     break;
 191                 case 116:
 192                     break;
 193                 default:
 194                     if (iFld == -7) {
 195                         return iFld;
 196                     }
 197                     z = iArr[5];
 198                     iFld &gt;&gt;= 1;
 199                 }
 200             }
 201             iArr[5] = 34;
 202         }
 203         return iFld;
 204     }
 205 
 206     public int test5() {
 207         iFld = 13;
 208         for (int i = 0; i &lt; 8; i++) {
 209             int j = 10;
 210             while (--j &gt; 0) {
 211                 iFld += -7;
 212                 iArr[5] = 8;
 213                 x = iArr[6];
 214                 y = x;
 215                 for (int k = 50; k &lt; 51; k++) {
 216                     x = iArr[7];
 217                 }
 218                 switch ((i * 5) + 102) {
 219                 case 120:
 220                     return iFld;
 221                 case 103:
 222                     break;
 223                 case 116:
 224                     break;
 225                 default:
 226                     iFld &gt;&gt;= 1;
 227                 }
 228             }
 229         }
 230         return iFld;
 231     }
 232 
 233     public int test6() {
 234         iFld = 13;
 235         for (int i = 0; i &lt; 8; i++) {
 236             int j = 10;
 237             while (--j &gt; 0) {
 238                 iFld += -7;
 239                 iArr[5] = 8;
 240                 x = iArr[6];
 241                 y = x;
 242                 switch ((i * 5) + 102) {
 243                 case 120:
 244                     return iFld;
 245                 case 103:
 246                     break;
 247                 case 116:
 248                     break;
 249                 default:
 250                     iFld &gt;&gt;= 1;
 251                 }
 252             }
 253         }
 254         return iFld;
 255     }
 256 
 257     public int test7() {
 258         iFld = 13;
 259         for (int i = 0; i &lt; 8; i++) {
 260             int j = 10;
 261             while (--j &gt; 0) {
 262                 iFld += -7;
 263                 iArr[5] = 8;
 264                 switch ((i * 5) + 102) {
 265                 case 120:
 266                     return iFld;
 267                 case 103:
 268                     break;
 269                 case 116:
 270                     break;
 271                 default:
 272                     iFld &gt;&gt;= 1;
 273                 }
 274             }
 275         }
 276         return iFld;
 277     }
 278 
 279     public int test8() {
 280 
 281         iFld = 13;
 282         for (int i = 0; i &lt; 8; i++) {
 283             int j = 50;
 284             while (--j &gt; 0) {
 285                 // All statements before the switch expression are partially peeled
 286                 iFld += -7;
 287                 x = y + iFld;
 288                 y = iArr[5];
 289                 iArr[5] = 5;
 290                 iArr[6] += 23;
 291                 iArr[7] = iArr[8] + iArr[6];
 292                 switch ((val * 5) + 102) {
 293                 case 120:
 294                     break;
 295                 case 103:
 296                     break;
 297                 case 116:
 298                     break;
 299                 default:
 300                     iFld &gt;&gt;= 1;
 301                 }
 302             }
 303         }
 304         return iFld;
 305     }
 306 
 307 
 308     public int test9() {
 309         iFld = 13;
 310         for (int i = 0; i &lt; 8; i++) {
 311             int j = 10;
 312             while (--j &gt; 0) {
 313                 iFld += -7;
 314                 iArr[4] = 8;
 315                 x = iArr[5];
 316                 switch ((i * 5) + 102) {
 317                 case 120:
 318                     return iFld + 1;
 319                 case 103:
 320                     break;
 321                 case 116:
 322                     break;
 323                 default:
 324                     iFld &gt;&gt;= 1;
 325                 }
 326             }
 327         }
 328 
 329         return iFld;
 330     }
 331 
 332    public int test10() {
 333         if (z &lt; 34) {
 334             z = 34;
 335         }
 336 
 337         iFld = 13;
 338         for (int i = 0; i &lt; 80; i++) {
 339             int j = 50;
 340             while (--j &gt; 0) {
 341                 iFld += -7;
 342                 iArr[4] = 8;
 343                 x = iArr[5];
 344                 switch ((i * 5) + 102) {
 345                 case 120:
 346                     break;
 347                 case 103:
 348                     break;
 349                 case 116:
 350                     break;
 351                 default:
 352                     iFld &gt;&gt;= 1;
 353                 }
 354             }
 355         }
 356         if (z == 34) {
 357             x = iArr[6];
 358         }
 359         return iFld;
 360     }
 361 
 362 
 363     public int test11Xcomp() {
 364         if (z &lt; 34) {
 365             z = 34;
 366         }
 367 
 368         iFld = 13;
 369         for (int i = 0; i &lt; 80; i++) {
 370             int j = 50;
 371             while (--j &gt; 0) {
 372                 iFld += -7;
 373                 iArr[4] = 8;
 374                 x = iArr[5];
 375                 switch ((i * 5) + 102) {
 376                 case 120:
 377                     break;
 378                 case 103:
 379                     break;
 380                 case 116:
 381                     break;
 382                 default:
 383                     iFld &gt;&gt;= 1;
 384                 }
 385                 if (z == 34) {
 386                     break;
 387                 }
 388             }
 389         }
 390         if (z == 34) {
 391             x = iArr[6];
 392         }
 393         return iFld;
 394     }
 395 
 396     // Phi with multiple inputs from same peeled node
 397     public int test12Xcomp() {
 398         if (z &lt; 34) {
 399             z = 34;
 400         }
 401 
 402         iFld = 13;
 403         for (int i = 0; i &lt; 80; i++) {
 404             int j = 50;
 405             while (--j &gt; 0) {
 406                 iFld += -7;
 407                 iArr[4] = 8;
 408                 x = iArr[5];
 409                 switch ((i * 5) + 102) {
 410                 case 120:
 411                     break;
 412                 case 103:
 413                     break;
 414                 case 116:
 415                     return z;
 416                 case 106:
 417                     return y;
 418                 case 111:
 419                     return x;
 420                 default:
 421                     iFld &gt;&gt;= 1;
 422                 }
 423                 w = 45;
 424             }
 425 
 426         }
 427         if (z == 34) {
 428             x = iArr[6];
 429         }
 430         return iFld;
 431     }
 432 
 433     public int test13Xcomp() {
 434         if (z &lt; 34) {
 435             z = 34;
 436         }
 437 
 438         iFld = 13;
 439         for (int i = 0; i &lt; 80; i++) {
 440             int j = 50;
 441             while (--j &gt; 0) {
 442                 iFld += -7;
 443                 iArr[4] = 8;
 444                 x = iArr[5];
 445                 switch ((i * 5) + 102) {
 446                 case 120:
 447                     break;
 448                 case 103:
 449                     break;
 450                 case 116:
 451                     break;
 452                 default:
 453                     iFld &gt;&gt;= 1;
 454                 }
 455                 w = 45;
 456             }
 457 
 458         }
 459         if (z == 34) {
 460             x = iArr[6];
 461         }
 462         return iFld;
 463     }
 464 
 465     // Triggers after peeling with Xcomp
 466     public int test14Peel() {
 467         iFld = 13;
 468         for (int i = 0; i &lt; 8; i++) {
 469             int j = 10;
 470             while (--j &gt; 0) {
 471                 iFld += -7;
 472                 iArr[4] = 8;
 473                 x = iArr[5];
 474                 switch ((i * 5) + 102) {
 475                 case 120:
 476                     return iFld;
 477                 case 103:
 478                     break;
 479                 case 116:
 480                     break;
 481                 default:
 482                     iFld &gt;&gt;= 1;
 483                 }
 484                 iFld = 3;
 485             }
 486         }
 487         y = iArr[4];
 488         x = iArr[6];
 489 
 490         return iFld;
 491     }
 492 
 493 
 494     public int test15earlyCtrl() {
 495         iFld = 13;
 496         if (z &lt; 34) {
 497             z = 34;
 498         }
 499 
 500         for (int i = 0; i &lt; 8; i++) {
 501             int j = 10;
 502             while (--j &gt; 0) {
 503                 iFld += -7;
 504                 iArr[5] = 8;
 505                 x = iArr[6];
 506                 y = x;
 507                 x = iArr[7];
 508                 switch ((i * 5) + 102) {
 509                 case 120:
 510                     return iFld;
 511                 case 103:
 512                     break;
 513                 case 116:
 514                     break;
 515                 default:
 516                     if (iFld == -7) {
 517                         return iFld;
 518                     }
 519                     z = iArr[5];
 520                     iFld &gt;&gt;= 1;
 521                 }
 522             }
 523             if (iFld == 7) {
 524                 iArr[3] = 3;
 525             }
 526             dontInline(7);
 527             iArr[5] = 34;
 528         }
 529         return iFld;
 530     }
 531 
 532     // Load after loop -&gt; LoadI after loop from peeled StoreI
 533     public int test16() {
 534         iFld = 13;
 535         if (z &lt; 34) {
 536             z = 34;
 537         }
 538 
 539         for (int i = 0; i &lt; 8; i++) {
 540             int j = 60;
 541             while (--j &gt; 0) {
 542                 iFld += -7;
 543                 y += iFld + 1;
 544 
 545                 iArr[5] = 8;
 546                 x = iArr[6];
 547                 x = iArr[7];
 548                 switch ((i * 5) + 102) {
 549                 case 120:
 550                     return iFld;
 551                 case 103:
 552                     break;
 553                 case 116:
 554                     break;
 555                 default:
 556                     if (iFld == -7) {
 557                         return iFld;
 558                     }
 559                     z = iArr[5];
 560                     iFld &gt;&gt;= 1;
 561                 }
 562             }
 563             w = iArr[9];
 564             if (iFld == 7) {
 565                 iArr[3] = 3;
 566             }
 567             dontInline(7);
 568             iArr[5] = 34;
 569         }
 570         return iFld;
 571     }
 572 
 573     // Region 13 before return, which region to choose for MergeMem?
 574     public int test17Xcomp() {
 575         A p = dontInlineGetA();
 576         if (z &lt; 34) {
 577             z = 34;
 578         }
 579 
 580         iFld = 13;
 581         for (int i = 0; i &lt; 80; i++) {
 582             int j = 50;
 583             while (--j &gt; 0) {
 584                 iFld += -7;
 585                 iArr[4] = 8;
 586                 x = iArr[5];
 587                 y = p.i;
 588                 switch ((i * 5) + 102) {
 589                 case 120:
 590                     break;
 591                 case 103:
 592                     break;
 593                 case 116:
 594                     return z;
 595                 case 106:
 596                     return y;
 597                 case 111:
 598                     return x;
 599                 default:
 600                     iFld &gt;&gt;= 1;
 601                 }
 602                 w = 45;
 603             }
 604 
 605         }
 606         if (z == 34) {
 607             x = iArr[6];
 608         }
 609         return iFld;
 610     }
 611 
 612     // Region 13 before return, which region to choose for MergeMem?
 613     public int test18Xcomp() {
 614         if (z &lt; 34) {
 615             z = 34;
 616         }
 617 
 618         iFld = 13;
 619         for (int i = 0; i &lt; 80; i++) {
 620             int j = 50;
 621             while (--j &gt; 0) {
 622                 iFld += -7;
 623                 iArr[4] = 8;
 624                 x = iArr[5];
 625                 y = 85;
 626                 switch ((i * 5) + 102) {
 627                 case 120:
 628                     break;
 629                 case 103:
 630                     break;
 631                 case 116:
 632                     return z;
 633                 case 106:
 634                     if (z == 34) {
 635                         x = iArr[7];
 636                     }
 637                     return y;
 638                 case 111:
 639                     return x;
 640                 default:
 641                     iFld &gt;&gt;= 1;
 642                 }
 643                 w = 45;
 644             }
 645 
 646         }
 647 
 648         if (z == 34) {
 649             x = iArr[6];
 650         }
 651         return iFld;
 652     }
 653 
 654     public int test19Xcomp() {
 655         if (z &lt; 34) {
 656             z = 34;
 657         }
 658 
 659         iFld = 13;
 660         for (int i = 0; i &lt; 80; i++) {
 661             int j = 50;
 662             while (--j &gt; 0) {
 663                 iFld += -7;
 664                 iArr[4] = 8;
 665                 x = iArr[5]+ iArr[6];
 666                 y = 85;
 667                 switch ((i * 5) + 102) {
 668                 case 120:
 669                     break;
 670                 case 103:
 671                     break;
 672                 case 116:
 673                     break;
 674                 case 106:
 675                     if (z == 34) {
 676                         x = iArr[7];
 677                     }
 678                     return y;
 679                 case 111:
 680                     return x;
 681                 default:
 682                     iFld &gt;&gt;= 1;
 683                 }
 684                 w = 45;
 685             }
 686         }
 687 
 688         if (z == 34) {
 689             iArr[7] = 34;
 690         }
 691         return iFld;
 692     }
 693 
 694     public int test20() {
 695         if (z &lt; 34) {
 696             z = 34;
 697         }
 698 
 699         iFld = 13;
 700         for (int i = 0; i &lt; 80; i++) {
 701             int j = 50;
 702             while (--j &gt; 0) {
 703                 iFld += -7;
 704                 iArr[4] = 8;
 705                 x = iArr[5];
 706                 switch ((i * 5) + 102) {
 707                 case 120:
 708                     break;
 709                 case 103:
 710                     break;
 711                 case 116:
 712                     break;
 713                 default:
 714                     iFld &gt;&gt;= 1;
 715                 }
 716             }
 717             x = iArr[6];
 718         }
 719         if (z == 34) {
 720             x = iArr[7];
 721         }
 722         return iFld;
 723     }
 724 
 725 
 726     public int test21() {
 727         if (z &lt; 34) {
 728             z = 34;
 729         }
 730 
 731         iFld = 13;
 732         for (int i = 0; i &lt; 80; i++) {
 733             int j = 50;
 734             while (--j &gt; 0) {
 735                 iFld += -7;
 736                 iArr[4] = 8;
 737                 x = iArr[5];
 738                 switch ((i * 5) + 102) {
 739                 case 120:
 740                     break;
 741                 case 103:
 742                     break;
 743                 case 116:
 744                     break;
 745                 default:
 746                     iFld &gt;&gt;= 1;
 747                 }
 748             }
 749             x = iArr[6];
 750         }
 751         if (z == 34) {
 752             y = iArr[7];
 753         }
 754         return iFld;
 755     }
 756 
 757     public int testNoOuter() {
 758         iFld = 13;
 759         int j = 10;
 760         while (--j &gt; 0) {
 761             iFld += -7;
 762             switch ((iCon * 5) + 102) {
 763             case 120:
 764                 break;
 765             case 103:
 766                 break;
 767             case 116:
 768                 break;
 769             default:
 770                 iFld &gt;&gt;= 1;
 771             }
 772         }
 773         return iFld;
 774     }
 775 
 776     public int test2NoOuter() {
 777         /*
 778          * Same nested loop structure as in test() but with more statements that are partially peeled from the inner loop.
 779          * Afterwards the inner loop is unswitched.
 780          */
 781         iFld = 13;
 782         int k = 0;
 783         int j = 10;
 784         while (--j &gt; 0) {
 785             // All statements before the switch expression are partially peeled
 786             iFld += -7;
 787             x = y + iFld;
 788             y = iArr[5];
 789             k = 6;
 790             iArr[5] = 5;
 791             iArr[6] += 23;
 792             iArr[7] = iArr[8] + iArr[6];
 793             iArr[j] = 34;
 794             switch ((iCon * 5) + 102) {
 795             case 120:
 796                 break;
 797             case 103:
 798                 break;
 799             case 116:
 800                 break;
 801             default:
 802                 iFld &gt;&gt;= 1;
 803             }
 804         }
 805         return iFld + k;
 806     }
 807 
 808     public int test3NoOuter() {
 809         iFld = 13;
 810         if (z &lt; 34) {
 811             z = 34;
 812         }
 813 
 814         int j = 10;
 815         while (--j &gt; 0) {
 816             iFld += -7;
 817             iArr[5] = 8;
 818             x = iArr[6];
 819             y = x;
 820             for (int k = 50; k &lt; 51; k++) {
 821                 x = iArr[7];
 822             }
 823             switch ((iCon * 5) + 102) {
 824             case 120:
 825                 return iFld;
 826             case 103:
 827                 break;
 828             case 116:
 829                 break;
 830             default:
 831                 if (iFld == -7) {
 832                     return iFld;
 833                 }
 834                 z = iArr[5];
 835                 iFld &gt;&gt;= 1;
 836             }
 837         }
 838         iArr[5] = 34;
 839         dontInline(iArr[5]);
 840         return iFld;
 841     }
 842 
 843     public int test4NoOuter() {
 844         iFld = 13;
 845         if (z &lt; 34) {
 846             z = 34;
 847         }
 848 
 849         int j = 10;
 850         while (--j &gt; 0) {
 851             iFld += -7;
 852             iArr[5] = 8;
 853             x = iArr[6];
 854             y = x;
 855             for (int k = 50; k &lt; 51; k++) {
 856                 x = iArr[7];
 857             }
 858             switch ((iCon * 5) + 102) {
 859             case 120:
 860                 return iFld;
 861             case 103:
 862                 break;
 863             case 116:
 864                 break;
 865             default:
 866                 if (iFld == -7) {
 867                     return iFld;
 868                 }
 869                 z = iArr[5];
 870                 iFld &gt;&gt;= 1;
 871             }
 872         }
 873         iArr[5] = 34;
 874         return iFld;
 875     }
 876 
 877     public int test5NoOuter() {
 878         iFld = 13;
 879         int j = 10;
 880         while (--j &gt; 0) {
 881             iFld += -7;
 882             iArr[5] = 8;
 883             x = iArr[6];
 884             y = x;
 885             for (int k = 50; k &lt; 51; k++) {
 886                 x = iArr[7];
 887             }
 888             switch ((iCon * 5) + 102) {
 889             case 120:
 890                 return iFld;
 891             case 103:
 892                 break;
 893             case 116:
 894                 break;
 895             default:
 896                 iFld &gt;&gt;= 1;
 897             }
 898         }
 899         return iFld;
 900     }
 901 
 902     public int test6NoOuter() {
 903         iFld = 13;
 904         int j = 10;
 905         while (--j &gt; 0) {
 906             iFld += -7;
 907             iArr[5] = 8;
 908             x = iArr[6];
 909             y = x;
 910             switch ((iCon * 5) + 102) {
 911             case 120:
 912                 return iFld;
 913             case 103:
 914                 break;
 915             case 116:
 916                 break;
 917             default:
 918                 iFld &gt;&gt;= 1;
 919             }
 920         }
 921         return iFld;
 922     }
 923 
 924     public int test7NoOuter() {
 925         iFld = 13;
 926         int j = 10;
 927         while (--j &gt; 0) {
 928             iFld += -7;
 929             iArr[5] = 8;
 930             switch ((iCon * 5) + 102) {
 931             case 120:
 932                 return iFld;
 933             case 103:
 934                 break;
 935             case 116:
 936                 break;
 937             default:
 938                 iFld &gt;&gt;= 1;
 939             }
 940         }
 941         return iFld;
 942     }
 943 
 944     public int test8NoOuter() {
 945 
 946         iFld = 13;
 947         int j = 50;
 948         while (--j &gt; 0) {
 949             // All statements before the switch expression are partially peeled
 950             iFld += -7;
 951             x = y + iFld;
 952             y = iArr[5];
 953             iArr[5] = 5;
 954             iArr[6] += 23;
 955             iArr[7] = iArr[8] + iArr[6];
 956             switch ((val * 5) + 102) {
 957             case 120:
 958                 break;
 959             case 103:
 960                 break;
 961             case 116:
 962                 break;
 963             default:
 964                 iFld &gt;&gt;= 1;
 965             }
 966         }
 967         return iFld;
 968     }
 969 
 970 
 971     public int test9NoOuter() {
 972         iFld = 13;
 973         int j = 10;
 974         while (--j &gt; 0) {
 975             iFld += -7;
 976             iArr[4] = 8;
 977             x = iArr[5];
 978             switch ((iCon * 5) + 102) {
 979             case 120:
 980                 return iFld + 1;
 981             case 103:
 982                 break;
 983             case 116:
 984                 break;
 985             default:
 986                 iFld &gt;&gt;= 1;
 987             }
 988         }
 989         return iFld;
 990     }
 991 
 992    public int test10NoOuter() {
 993         if (z &lt; 34) {
 994             z = 34;
 995         }
 996 
 997         iFld = 13;
 998         int j = 50;
 999         while (--j &gt; 0) {
1000             iFld += -7;
1001             iArr[4] = 8;
1002             x = iArr[5];
1003             switch ((iCon * 5) + 102) {
1004             case 120:
1005                 break;
1006             case 103:
1007                 break;
1008             case 116:
1009                 break;
1010             default:
1011                 iFld &gt;&gt;= 1;
1012             }
1013         }
1014         if (z == 34) {
1015             x = iArr[6];
1016         }
1017         return iFld;
1018     }
1019 
1020 
1021     public int test11XcompNoOuter() {
1022         if (z &lt; 34) {
1023             z = 34;
1024         }
1025 
1026         iFld = 13;
1027         int j = 50;
1028         while (--j &gt; 0) {
1029             iFld += -7;
1030             iArr[4] = 8;
1031             x = iArr[5];
1032             switch ((iCon * 5) + 102) {
1033             case 120:
1034                 break;
1035             case 103:
1036                 break;
1037             case 116:
1038                 break;
1039             default:
1040                 iFld &gt;&gt;= 1;
1041             }
1042             if (z == 34) {
1043                 break;
1044             }
1045         }
1046         if (z == 34) {
1047             x = iArr[6];
1048         }
1049         return iFld;
1050     }
1051 
1052     // Phi with multiple inputs from same peeled node
1053     public int test12XcompNoOuter() {
1054         if (z &lt; 34) {
1055             z = 34;
1056         }
1057 
1058         iFld = 13;
1059         int j = 50;
1060         while (--j &gt; 0) {
1061             iFld += -7;
1062             iArr[4] = 8;
1063             x = iArr[5];
1064             switch ((iCon * 5) + 102) {
1065             case 120:
1066                 break;
1067             case 103:
1068                 break;
1069             case 116:
1070                 return z;
1071             case 106:
1072                 return y;
1073             case 111:
1074                 return x;
1075             default:
1076                 iFld &gt;&gt;= 1;
1077             }
1078             w = 45;
1079         }
1080 
1081         if (z == 34) {
1082             x = iArr[6];
1083         }
1084         return iFld;
1085     }
1086 
1087     public int test13XcompNoOuter() {
1088         if (z &lt; 34) {
1089             z = 34;
1090         }
1091 
1092         iFld = 13;
1093         int j = 50;
1094         while (--j &gt; 0) {
1095             iFld += -7;
1096             iArr[4] = 8;
1097             x = iArr[5];
1098             switch ((iCon * 5) + 102) {
1099             case 120:
1100                 break;
1101             case 103:
1102                 break;
1103             case 116:
1104                 break;
1105             default:
1106                 iFld &gt;&gt;= 1;
1107             }
1108             w = 45;
1109         }
1110 
1111         if (z == 34) {
1112             x = iArr[6];
1113         }
1114         return iFld;
1115     }
1116 
1117     // Triggers after peeling with Xcomp
1118     public int test14PeelNoOuter() {
1119         iFld = 13;
1120         int j = 10;
1121         while (--j &gt; 0) {
1122             iFld += -7;
1123             iArr[4] = 8;
1124             x = iArr[5];
1125             switch ((iCon * 5) + 102) {
1126             case 120:
1127                 return iFld;
1128             case 103:
1129                 break;
1130             case 116:
1131                 break;
1132             default:
1133                 iFld &gt;&gt;= 1;
1134             }
1135             iFld = 3;
1136         }
1137         y = iArr[4];
1138         x = iArr[6];
1139 
1140         return iFld;
1141     }
1142 
1143 
1144     public int test15earlyCtrlNoOuter() {
1145         iFld = 13;
1146         if (z &lt; 34) {
1147             z = 34;
1148         }
1149 
1150         int j = 10;
1151         while (--j &gt; 0) {
1152             iFld += -7;
1153             iArr[5] = 8;
1154             x = iArr[6];
1155             y = x;
1156             x = iArr[7];
1157             switch ((iCon * 5) + 102) {
1158             case 120:
1159                 return iFld;
1160             case 103:
1161                 break;
1162             case 116:
1163                 break;
1164             default:
1165                 if (iFld == -7) {
1166                     return iFld;
1167                 }
1168                 z = iArr[5];
1169                 iFld &gt;&gt;= 1;
1170             }
1171         }
1172         if (iFld == 7) {
1173             iArr[3] = 3;
1174         }
1175         dontInline(7);
1176         iArr[5] = 34;
1177         return iFld;
1178     }
1179 
1180     // Load after loop -&gt; LoadI after loop from peeled StoreI
1181     public int test16NoOuter() {
1182         iFld = 13;
1183         if (z &lt; 34) {
1184             z = 34;
1185         }
1186 
1187         int j = 60;
1188         while (--j &gt; 0) {
1189             iFld += -7;
1190             y += iFld + 1;
1191 
1192             iArr[5] = 8;
1193             x = iArr[6];
1194             x = iArr[7];
1195             switch ((iCon * 5) + 102) {
1196             case 120:
1197                 return iFld;
1198             case 103:
1199                 break;
1200             case 116:
1201                 break;
1202             default:
1203                 if (iFld == -7) {
1204                     return iFld;
1205                 }
1206                 z = iArr[5];
1207                 iFld &gt;&gt;= 1;
1208             }
1209         }
1210         w = iArr[9];
1211         if (iFld == 7) {
1212             iArr[3] = 3;
1213         }
1214         dontInline(7);
1215         iArr[5] = 34;
1216         return iFld;
1217     }
1218 
1219     // Region 13 before return, which region to choose for MergeMem?
1220     public int test17XcompNoOuter() {
1221         A p = dontInlineGetA();
1222         if (z &lt; 34) {
1223             z = 34;
1224         }
1225 
1226         iFld = 13;
1227         int j = 50;
1228         while (--j &gt; 0) {
1229             iFld += -7;
1230             iArr[4] = 8;
1231             x = iArr[5];
1232             y = p.i;
1233             switch ((iCon * 5) + 102) {
1234             case 120:
1235                 break;
1236             case 103:
1237                 break;
1238             case 116:
1239                 return z;
1240             case 106:
1241                 return y;
1242             case 111:
1243                 return x;
1244             default:
1245                 iFld &gt;&gt;= 1;
1246             }
1247             w = 45;
1248         }
1249         if (z == 34) {
1250             x = iArr[6];
1251         }
1252         return iFld;
1253     }
1254 
1255     // Region 13 before return, which region to choose for MergeMem?
1256     public int test18XcompNoOuter() {
1257         if (z &lt; 34) {
1258             z = 34;
1259         }
1260 
1261         iFld = 13;
1262         int j = 50;
1263         while (--j &gt; 0) {
1264             iFld += -7;
1265             iArr[4] = 8;
1266             x = iArr[5];
1267             y = 85;
1268             switch ((iCon * 5) + 102) {
1269             case 120:
1270                 break;
1271             case 103:
1272                 break;
1273             case 116:
1274                 return z;
1275             case 106:
1276                 if (z == 34) {
1277                     x = iArr[7];
1278                 }
1279                 return y;
1280             case 111:
1281                 return x;
1282             default:
1283                 iFld &gt;&gt;= 1;
1284             }
1285             w = 45;
1286         }
1287 
1288         if (z == 34) {
1289             x = iArr[6];
1290         }
1291         return iFld;
1292     }
1293 
1294     public int test19XcompNoOuter() {
1295         if (z &lt; 34) {
1296             z = 34;
1297         }
1298 
1299         iFld = 13;
1300         int j = 50;
1301         while (--j &gt; 0) {
1302             iFld += -7;
1303             iArr[4] = 8;
1304             x = iArr[5]+ iArr[6];
1305             y = 85;
1306             switch ((iCon * 5) + 102) {
1307             case 120:
1308                 break;
1309             case 103:
1310                 break;
1311             case 116:
1312                 break;
1313             case 106:
1314                 if (z == 34) {
1315                     x = iArr[7];
1316                 }
1317                 return y;
1318             case 111:
1319                 return x;
1320             default:
1321                 iFld &gt;&gt;= 1;
1322             }
1323             w = 45;
1324         }
1325 
1326         if (z == 34) {
1327             iArr[7] = 34;
1328         }
1329         return iFld;
1330     }
1331 
1332 
1333     public int test20NoOuter() {
1334         if (z &lt; 34) {
1335             z = 34;
1336         }
1337 
1338         iFld = 13;
1339         int j = 50;
1340         while (--j &gt; 0) {
1341             iFld += -7;
1342             iArr[4] = 8;
1343             x = iArr[5];
1344             switch ((iCon * 5) + 102) {
1345             case 120:
1346                 break;
1347             case 103:
1348                 break;
1349             case 116:
1350                 break;
1351             default:
1352                 iFld &gt;&gt;= 1;
1353             }
1354         }
1355         x = iArr[6];
1356         if (z == 34) {
1357             x = iArr[7];
1358         }
1359         return iFld;
1360     }
1361 
1362     public int test21NoOuter() {
1363         if (z &lt; 34) {
1364             z = 34;
1365         }
1366 
1367         iFld = 13;
1368         int j = 50;
1369         while (--j &gt; 0) {
1370             iFld += -7;
1371             iArr[4] = 8;
1372             x = iArr[5];
1373             switch ((iCon * 5) + 102) {
1374             case 120:
1375                 break;
1376             case 103:
1377                 break;
1378             case 116:
1379                 break;
1380             default:
1381                 iFld &gt;&gt;= 1;
1382             }
1383         }
1384         x = iArr[6];
1385         if (z == 34) {
1386             y = iArr[7];
1387         }
1388         return iFld;
1389     }
1390     public static void main(String[] strArr) {
1391         BookKeeper[] bookKeeper = new BookKeeper[22];
1392         for (int i = 0; i &lt; 22; i++) {
1393             bookKeeper[i] = new BookKeeper();
1394         }
1395 
1396         PartialPeelingUnswitch _instance = new PartialPeelingUnswitch();
1397         for (int i = 0; i &lt; 2000; i++) {
1398             int result = _instance.test();
1399             if (result != -7) {
1400                 throw new RuntimeException(&quot;Result should always be -7 but was &quot; + result);
1401             }
1402         }
1403 
1404         for (int i = 0; i &lt; 2000; i++) {
1405             int result = _instance.test2();
1406             check(-1, result);
1407             check(-7, iFld);
1408             check(-9, x);
1409             check(5, y);
1410             check(5, iArr[5]);
1411             check(149, iArr[6]);
1412             check(183, iArr[7]);
1413 
1414             // Reset fields
1415             for (int j = 0; j &lt; 10; j++) {
1416                 iArr[j] = 0;
1417             }
1418             x = 42;
1419             y = 31;
1420         }
1421 
1422         for (int i = 0; i &lt; 2000; i++) {
1423             BookKeeper.setup();
1424             _instance.test3();
1425             bookKeeper[3].compare();
1426             BookKeeper.setup();
1427             _instance.test4();
1428             bookKeeper[4].compare();
1429             BookKeeper.setup();
1430             _instance.test5();
1431             bookKeeper[5].compare();
1432             BookKeeper.setup();
1433             _instance.test6();
1434             bookKeeper[6].compare();
1435             BookKeeper.setup();
1436             _instance.test7();
1437             bookKeeper[7].compare();
1438             BookKeeper.setup();
1439             _instance.test8();
1440             bookKeeper[8].compare();
1441             BookKeeper.setup();
1442             _instance.test9();
1443             bookKeeper[9].compare();
1444             BookKeeper.setup();
1445             _instance.test10();
1446             bookKeeper[10].compare();
1447             BookKeeper.setup();
1448             _instance.test11Xcomp();
1449             bookKeeper[11].compare();
1450             BookKeeper.setup();
1451             _instance.test12Xcomp();
1452             bookKeeper[12].compare();
1453             BookKeeper.setup();
1454             _instance.test13Xcomp();
1455             bookKeeper[13].compare();
1456             BookKeeper.setup();
1457             _instance.test14Peel();
1458             bookKeeper[14].compare();
1459             BookKeeper.setup();
1460             _instance.test15earlyCtrl();
1461             bookKeeper[15].compare();
1462             BookKeeper.setup();
1463             _instance.test16();
1464             bookKeeper[16].compare();
1465             BookKeeper.setup();
1466             _instance.test17Xcomp();
1467             bookKeeper[17].compare();
1468             BookKeeper.setup();
1469             _instance.test18Xcomp();
1470             bookKeeper[18].compare();
1471             BookKeeper.setup();
1472             _instance.test19Xcomp();
1473             bookKeeper[19].compare();
1474             BookKeeper.setup();
1475             _instance.test20();
1476             bookKeeper[20].compare();
1477             BookKeeper.setup();
1478             _instance.test21();
1479             bookKeeper[21].compare();
1480         }
1481 
1482         for (int i = 0; i &lt; 22; i++) {
1483             bookKeeper[i] = new BookKeeper();
1484         }
1485 
1486         for (int i = 0; i &lt; 2000; i++) {
1487             BookKeeper.setup();
1488             _instance.testNoOuter();
1489             bookKeeper[1].compare();
1490             BookKeeper.setup();
1491             _instance.test2NoOuter();
1492             bookKeeper[2].compare();
1493             BookKeeper.setup();
1494             _instance.test3NoOuter();
1495             bookKeeper[3].compare();
1496             BookKeeper.setup();
1497             _instance.test4NoOuter();
1498             bookKeeper[4].compare();
1499             BookKeeper.setup();
1500             _instance.test5NoOuter();
1501             bookKeeper[5].compare();
1502             BookKeeper.setup();
1503             _instance.test6NoOuter();
1504             bookKeeper[6].compare();
1505             BookKeeper.setup();
1506             _instance.test7NoOuter();
1507             bookKeeper[7].compare();
1508             BookKeeper.setup();
1509             _instance.test8NoOuter();
1510             bookKeeper[8].compare();
1511             BookKeeper.setup();
1512             _instance.test9NoOuter();
1513             bookKeeper[9].compare();
1514             BookKeeper.setup();
1515             _instance.test10NoOuter();
1516             bookKeeper[10].compare();
1517             BookKeeper.setup();
1518             _instance.test11XcompNoOuter();
1519             bookKeeper[11].compare();
1520             BookKeeper.setup();
1521             _instance.test12XcompNoOuter();
1522             bookKeeper[12].compare();
1523             BookKeeper.setup();
1524             _instance.test13XcompNoOuter();
1525             bookKeeper[13].compare();
1526             BookKeeper.setup();
1527             _instance.test14PeelNoOuter();
1528             bookKeeper[14].compare();
1529             BookKeeper.setup();
1530             _instance.test15earlyCtrlNoOuter();
1531             bookKeeper[15].compare();
1532             BookKeeper.setup();
1533             _instance.test16NoOuter();
1534             bookKeeper[16].compare();
1535             BookKeeper.setup();
1536             _instance.test17XcompNoOuter();
1537             bookKeeper[17].compare();
1538             BookKeeper.setup();
1539             _instance.test18XcompNoOuter();
1540             bookKeeper[18].compare();
1541             BookKeeper.setup();
1542             _instance.test19XcompNoOuter();
1543             bookKeeper[19].compare();
1544             BookKeeper.setup();
1545             _instance.test20NoOuter();
1546             bookKeeper[20].compare();
1547             BookKeeper.setup();
1548             _instance.test21NoOuter();
1549             bookKeeper[21].compare();
1550         }
1551 
1552         for (int i = 0; i &lt; 22; i++) {
1553             bookKeeper[i] = new BookKeeper();
1554         }
1555 
1556         for (int i = 0; i &lt; 2000; i++) {
1557             BookKeeper.setup();
1558             setZ(i);
1559             _instance.test3();
1560             bookKeeper[3].compare(i);
1561             BookKeeper.setup();
1562             setZ(i);
1563             _instance.test4();
1564             bookKeeper[4].compare(i);
1565             BookKeeper.setup();
1566             setZ(i);
1567             _instance.test5();
1568             bookKeeper[5].compare(i);
1569             BookKeeper.setup();
1570             setZ(i);
1571             _instance.test6();
1572             bookKeeper[6].compare(i);
1573             BookKeeper.setup();
1574             setZ(i);
1575             _instance.test7();
1576             bookKeeper[7].compare(i);
1577             BookKeeper.setup();
1578             setZ(i);
1579             _instance.test8();
1580             bookKeeper[8].compare(i);
1581             BookKeeper.setup();
1582             setZ(i);
1583             _instance.test9();
1584             bookKeeper[9].compare(i);
1585             BookKeeper.setup();
1586             setZ(i);
1587             _instance.test10();
1588             bookKeeper[10].compare(i);
1589             setZ(i);
1590             BookKeeper.setup();
1591             _instance.test11Xcomp();
1592             bookKeeper[11].compare(i);
1593             setZ(i);
1594             BookKeeper.setup();
1595             _instance.test12Xcomp();
1596             bookKeeper[12].compare(i);
1597             setZ(i);
1598             BookKeeper.setup();
1599             _instance.test13Xcomp();
1600             bookKeeper[13].compare(i);
1601             setZ(i);
1602             BookKeeper.setup();
1603             _instance.test14Peel();
1604             bookKeeper[14].compare(i);
1605             setZ(i);
1606             BookKeeper.setup();
1607             _instance.test15earlyCtrl();
1608             bookKeeper[15].compare(i);
1609             setZ(i);
1610             BookKeeper.setup();
1611             _instance.test16();
1612             bookKeeper[16].compare(i);
1613             setZ(i);
1614             BookKeeper.setup();
1615             _instance.test17Xcomp();
1616             bookKeeper[17].compare(i);
1617             setZ(i);
1618             BookKeeper.setup();
1619             _instance.test18Xcomp();
1620             bookKeeper[18].compare(i);
1621             setZ(i);
1622             BookKeeper.setup();
1623             _instance.test19Xcomp();
1624             bookKeeper[19].compare(i);
1625             setZ(i);
1626             BookKeeper.setup();
1627             _instance.test20();
1628             bookKeeper[20].compare(i);
1629             setZ(i);
1630             BookKeeper.setup();
1631             _instance.test21();
1632             bookKeeper[21].compare(i);
1633         }
1634 
1635         for (int i = 0; i &lt; 22; i++) {
1636             bookKeeper[i] = new BookKeeper();
1637         }
1638 
1639         for (int i = 0; i &lt; 2000; i++) {
1640             BookKeeper.setup();
1641             setZ(i);
1642             _instance.testNoOuter();
1643             bookKeeper[1].compare(i);
1644             BookKeeper.setup();
1645             setZ(i);
1646             _instance.test2NoOuter();
1647             bookKeeper[2].compare(i);
1648             BookKeeper.setup();
1649             setZ(i);
1650             _instance.test3NoOuter();
1651             bookKeeper[3].compare(i);
1652             BookKeeper.setup();
1653             setZ(i);
1654             _instance.test4NoOuter();
1655             bookKeeper[4].compare(i);
1656             BookKeeper.setup();
1657             setZ(i);
1658             _instance.test5NoOuter();
1659             bookKeeper[5].compare(i);
1660             BookKeeper.setup();
1661             setZ(i);
1662             _instance.test6NoOuter();
1663             bookKeeper[6].compare(i);
1664             BookKeeper.setup();
1665             setZ(i);
1666             _instance.test7NoOuter();
1667             bookKeeper[7].compare(i);
1668             BookKeeper.setup();
1669             setZ(i);
1670             _instance.test8NoOuter();
1671             bookKeeper[8].compare(i);
1672             BookKeeper.setup();
1673             setZ(i);
1674             _instance.test9NoOuter();
1675             bookKeeper[9].compare(i);
1676             BookKeeper.setup();
1677             setZ(i);
1678             _instance.test10NoOuter();
1679             bookKeeper[10].compare(i);
1680             BookKeeper.setup();
1681             setZ(i);
1682             _instance.test11XcompNoOuter();
1683             bookKeeper[11].compare(i);
1684             BookKeeper.setup();
1685             setZ(i);
1686             _instance.test12XcompNoOuter();
1687             bookKeeper[12].compare(i);
1688             BookKeeper.setup();
1689             setZ(i);
1690             _instance.test13XcompNoOuter();
1691             bookKeeper[13].compare(i);
1692             BookKeeper.setup();
1693             setZ(i);
1694             _instance.test14PeelNoOuter();
1695             bookKeeper[14].compare(i);
1696             BookKeeper.setup();
1697             setZ(i);
1698             _instance.test15earlyCtrlNoOuter();
1699             bookKeeper[15].compare(i);
1700             BookKeeper.setup();
1701             setZ(i);
1702             _instance.test16NoOuter();
1703             bookKeeper[16].compare(i);
1704             BookKeeper.setup();
1705             setZ(i);
1706             _instance.test17XcompNoOuter();
1707             bookKeeper[17].compare(i);
1708             BookKeeper.setup();
1709             setZ(i);
1710             _instance.test18XcompNoOuter();
1711             bookKeeper[18].compare(i);
1712             BookKeeper.setup();
1713             setZ(i);
1714             _instance.test19XcompNoOuter();
1715             bookKeeper[19].compare(i);
1716             BookKeeper.setup();
1717             setZ(i);
1718             _instance.test20NoOuter();
1719             bookKeeper[20].compare(i);
1720             BookKeeper.setup();
1721             setZ(i);
1722             _instance.test21NoOuter();
1723             bookKeeper[21].compare(i);
1724         }
1725     }
1726 
1727     public static void setZ(int i) {
1728         if (i % 2 == 0) {
1729             z = 23;
1730         } else {
1731             z = 35;
1732         }
1733     }
1734 
1735     public static void check(int expected, int actual) {
1736         if (expected != actual) {
1737             throw new RuntimeException(&quot;Wrong result, expected: &quot; + expected + &quot;, actual: &quot; + actual);
1738         }
1739     }
1740 
1741     public void dontInline(int i) { }
1742 
1743     class A {
1744         int i = 3;
1745     }
1746 
1747     A dontInlineGetA() {
1748         return new A();
1749     }
1750 
1751     static class BookKeeper {
1752         public int iFld;
1753         public int w;
1754         public int x;
1755         public int y;
1756         public int z;
1757         public int val;
1758         public int[] iArr;
1759 
1760         public int iFld2;
1761         public int w2;
1762         public int x2;
1763         public int y2;
1764         public int z2;
1765         public int val2;
1766         public int[] iArr2;
1767 
1768         public void compare() {
1769             if (iArr == null) {
1770                 // First compare, initialize values
1771                 this.iFld = PartialPeelingUnswitch.iFld;
1772                 this.w = PartialPeelingUnswitch.w;
1773                 this.x = PartialPeelingUnswitch.x;
1774                 this.y = PartialPeelingUnswitch.y;
1775                 this.z = PartialPeelingUnswitch.z;
1776                 this.val = PartialPeelingUnswitch.val;
1777                 this.iArr = new int[10];
1778                 System.arraycopy(PartialPeelingUnswitch.iArr, 0, this.iArr, 0, 10);
1779             } else {
1780 
1781                 // Do comparison
1782                 boolean check = PartialPeelingUnswitch.iFld == this.iFld
1783                                 &amp;&amp; this.w == PartialPeelingUnswitch.w
1784                                 &amp;&amp; this.x == PartialPeelingUnswitch.x
1785                                 &amp;&amp; this.y == PartialPeelingUnswitch.y
1786                                 &amp;&amp; this.z == PartialPeelingUnswitch.z
1787                                 &amp;&amp; this.val == PartialPeelingUnswitch.val;
1788                 for (int i = 0; i &lt; 10; i++) {
1789                     check = check &amp;&amp; this.iArr[i] == PartialPeelingUnswitch.iArr[i];
1790                 }
1791 
1792                 if (!check) {
1793                     throw new RuntimeException(&quot;Failed comparison&quot;);
1794                 }
1795             }
1796         }
1797 
1798         public void compare(int i) {
1799             if (i % 2 == 0 &amp;&amp; iArr == null) {
1800                 // First compare, initialize values
1801                 this.iFld = PartialPeelingUnswitch.iFld;
1802                 this.w = PartialPeelingUnswitch.w;
1803                 this.x = PartialPeelingUnswitch.x;
1804                 this.y = PartialPeelingUnswitch.y;
1805                 this.z = PartialPeelingUnswitch.z;
1806                 this.val = PartialPeelingUnswitch.val;
1807                 this.iArr = new int[10];
1808                 System.arraycopy(PartialPeelingUnswitch.iArr, 0, this.iArr, 0, 10);
1809             } else if (i % 2 != 0 &amp;&amp; iArr2 == null) {
1810                 // First compare, initialize values
1811                 this.iFld2 = PartialPeelingUnswitch.iFld;
1812                 this.w2 = PartialPeelingUnswitch.w;
1813                 this.x2 = PartialPeelingUnswitch.x;
1814                 this.y2 = PartialPeelingUnswitch.y;
1815                 this.z2 = PartialPeelingUnswitch.z;
1816                 this.val2 = PartialPeelingUnswitch.val;
1817                 this.iArr2 = new int[10];
1818                 System.arraycopy(PartialPeelingUnswitch.iArr, 0, this.iArr2, 0, 10);
1819             } else if (i % 2 == 0) {
1820                 // Do comparison
1821                 boolean check = PartialPeelingUnswitch.iFld == this.iFld
1822                                 &amp;&amp; this.w == PartialPeelingUnswitch.w
1823                                 &amp;&amp; this.x == PartialPeelingUnswitch.x
1824                                 &amp;&amp; this.y == PartialPeelingUnswitch.y
1825                                 &amp;&amp; this.z == PartialPeelingUnswitch.z
1826                                 &amp;&amp; this.val == PartialPeelingUnswitch.val;
1827                 for (int j = 0; j &lt; 10; j++) {
1828                     check = check &amp;&amp; this.iArr[j] == PartialPeelingUnswitch.iArr[j];
1829                 }
1830 
1831                 if (!check) {
1832                     throw new RuntimeException(&quot;Failed comparison&quot;);
1833                 }
1834             } else {
1835                 // Do comparison
1836                 boolean check = PartialPeelingUnswitch.iFld == this.iFld2
1837                                 &amp;&amp; this.w2 == PartialPeelingUnswitch.w
1838                                 &amp;&amp; this.x2 == PartialPeelingUnswitch.x
1839                                 &amp;&amp; this.y2 == PartialPeelingUnswitch.y
1840                                 &amp;&amp; this.z2 == PartialPeelingUnswitch.z
1841                                 &amp;&amp; this.val2 == PartialPeelingUnswitch.val;
1842                 for (int j = 0; j &lt; 10; j++) {
1843                     check = check &amp;&amp; this.iArr2[j] == PartialPeelingUnswitch.iArr[j];
1844                 }
1845 
1846                 if (!check) {
1847                     throw new RuntimeException(&quot;Failed comparison&quot;);
1848                 }
1849             }
1850         }
1851 
1852         public static void setup() {
1853             PartialPeelingUnswitch.iFld = 0;
1854             PartialPeelingUnswitch.w = 88;
1855             PartialPeelingUnswitch.x = 42;
1856             PartialPeelingUnswitch.y = 31;
1857             PartialPeelingUnswitch.z = 22;
1858             PartialPeelingUnswitch.val = 34;
1859             PartialPeelingUnswitch.iArr = new int[10];
1860         }
1861     }
1862 }
    </pre>
  </body>
</html>
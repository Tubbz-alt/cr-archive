<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/sun/management/jmxremote/bootstrap/CustomLauncherTest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.File;
 25 import java.io.IOException;
 26 import java.nio.file.FileSystem;
 27 import java.nio.file.FileSystems;
 28 import java.nio.file.Files;
 29 import java.nio.file.LinkOption;
 30 import java.nio.file.Path;
 31 import java.nio.file.StandardCopyOption;
 32 import java.nio.file.attribute.PosixFilePermission;
 33 import java.util.HashSet;
 34 import java.util.Set;
 35 import java.util.concurrent.TimeUnit;
 36 import java.util.concurrent.atomic.AtomicReference;
 37 
 38 import jdk.test.lib.process.ProcessTools;
 39 
 40 /**
 41  * @test
 42  * @bug 6434402 8004926
 43  * @author Jaroslav Bachorik
 44  *
 45  * @library /test/lib
 46  * @modules java.management
 47  *          jdk.attach
 48  *          jdk.management.agent/jdk.internal.agent
 49  *
 50  * @build TestManager TestApplication CustomLauncherTest
 51  * @run main/othervm CustomLauncherTest
 52  */
 53 public class CustomLauncherTest {
 54     private static final  String TEST_CLASSPATH = System.getProperty(&quot;test.class.path&quot;);
 55     private static final  String TEST_JDK = System.getProperty(&quot;test.jdk&quot;);
 56     private static final  String WORK_DIR = System.getProperty(&quot;user.dir&quot;);
 57 
 58     private static final  String TEST_SRC = System.getProperty(&quot;test.src&quot;);
 59     private static final  String OSNAME = System.getProperty(&quot;os.name&quot;);
 60     private static final  String ARCH;
 61     static {
 62         // magic with os.arch
 63         String osarch = System.getProperty(&quot;os.arch&quot;);
 64         switch (osarch) {
 65             case &quot;i386&quot;:
 66             case &quot;i486&quot;:
 67             case &quot;i586&quot;:
 68             case &quot;i686&quot;:
 69             case &quot;i786&quot;:
 70             case &quot;i886&quot;:
 71             case &quot;i986&quot;: {
 72                 ARCH = &quot;i586&quot;;
 73                 break;
 74             }
 75             case &quot;x86_64&quot;:
 76             case &quot;amd64&quot;: {
 77                 ARCH = &quot;amd64&quot;;
 78                 break;
 79             }
 80             case &quot;sparc&quot;:
 81                 ARCH = &quot;sparcv9&quot;;
 82                 break;
 83             default: {
 84                 ARCH = osarch;
 85             }
 86         }
 87     }
 88 
 89     public static void main(String[] args) throws Exception {
 90         if (TEST_CLASSPATH == null || TEST_CLASSPATH.isEmpty()) {
 91             System.out.println(&quot;Test is designed to be run from jtreg only&quot;);
 92             return;
 93         }
 94 
 95         if (getPlatform() == null) {
 96             System.out.println(&quot;Test not designed to run on this operating &quot; +
 97                                 &quot;system (&quot; + OSNAME + &quot;), skipping...&quot;);
 98             return;
 99         }
100 
101         final FileSystem FS = FileSystems.getDefault();
102 
103         Path libjvmPath = findLibjvm(FS);
104         if (libjvmPath == null) {
105             throw new Error(&quot;Unable to locate &#39;libjvm.so&#39; in &quot; + TEST_JDK);
106         }
107 
108         Process serverPrc = null, clientPrc = null;
109 
110         try {
111             String[] launcher = getLauncher();
112 
113             if (launcher == null) return; // launcher not available for the tested platform; skip
114 
115             System.out.println(&quot;Starting custom launcher:&quot;);
116             System.out.println(&quot;=========================&quot;);
117             System.out.println(&quot;  launcher  : &quot; + launcher[0]);
118             System.out.println(&quot;  libjvm    : &quot; + libjvmPath.toString());
119             System.out.println(&quot;  classpath : &quot; + TEST_CLASSPATH);
120             ProcessBuilder server = new ProcessBuilder(
121                 launcher[1],
122                 libjvmPath.toString(),
123                 TEST_CLASSPATH,
124                 &quot;TestApplication&quot;
125             );
126 
127             final AtomicReference&lt;String&gt; port = new AtomicReference&lt;&gt;();
128 
129             serverPrc = ProcessTools.startProcess(
130                 &quot;Launcher&quot;,
131                 server,
132                 (String line) -&gt; {
133                     if (line.startsWith(&quot;port:&quot;)) {
134                          port.set(line.split(&quot;\\:&quot;)[1]);
135                     } else if (line.startsWith(&quot;waiting&quot;)) {
136                          return true;
137                     }
138                     return false;
139                 },
140                 5,
141                 TimeUnit.SECONDS
142             );
143 
144             System.out.println(&quot;Attaching test manager:&quot;);
145             System.out.println(&quot;=========================&quot;);
146             System.out.println(&quot;  PID           : &quot; + serverPrc.pid());
147             System.out.println(&quot;  shutdown port : &quot; + port.get());
148 
149             ProcessBuilder client = ProcessTools.createJavaProcessBuilder(
150                 &quot;-cp&quot;,
151                 TEST_CLASSPATH,
152                 &quot;--add-exports&quot;, &quot;jdk.management.agent/jdk.internal.agent=ALL-UNNAMED&quot;,
153                 &quot;TestManager&quot;,
154                 String.valueOf(serverPrc.pid()),
155                 port.get(),
156                 &quot;true&quot;
157             );
158 
159             clientPrc = ProcessTools.startProcess(
160                 &quot;TestManager&quot;,
161                 client,
162                 (String line) -&gt; line.startsWith(&quot;Starting TestManager for PID&quot;),
163                 10,
164                 TimeUnit.SECONDS
165             );
166 
167             int clientExitCode = clientPrc.waitFor();
168             int serverExitCode = serverPrc.waitFor();
169 
170             if (clientExitCode != 0 || serverExitCode != 0) {
171                 throw new Error(&quot;Test failed&quot;);
172             }
173         } finally {
174             if (clientPrc != null) {
175                 clientPrc.destroy();
176                 clientPrc.waitFor();
177             }
178             if (serverPrc != null) {
179                 serverPrc.destroy();
180                 serverPrc.waitFor();
181             }
182         }
183     }
184 
185     private static Path findLibjvm(FileSystem FS) {
186         Path libjvmPath = findLibjvm(FS.getPath(TEST_JDK, &quot;lib&quot;));
187         return libjvmPath;
188     }
189 
190     private static Path findLibjvm(Path libPath) {
191         // libjvm.so -&gt; server/libjvm.so -&gt; client/libjvm.so
192         Path libjvmPath = libPath.resolve(&quot;libjvm.so&quot;);
193         if (isFileOk(libjvmPath)) {
194             return libjvmPath;
195         }
196         libjvmPath = libPath.resolve(&quot;server/libjvm.so&quot;);
197         if (isFileOk(libjvmPath)) {
198             return libjvmPath;
199         }
200         libjvmPath = libPath.resolve(&quot;client/libjvm.so&quot;);
201         if (isFileOk(libPath)) {
202             return libjvmPath;
203         }
204 
205         return null;
206     }
207 
208     private static boolean isFileOk(Path path) {
209         return Files.isRegularFile(path) &amp;&amp; Files.isReadable(path);
210     }
211 
212     private static String getPlatform() {
213         String platform = null;
214         switch (OSNAME.toLowerCase()) {
215             case &quot;linux&quot;: {
216                 platform = &quot;linux&quot;;
217                 break;
218             }
219             case &quot;sunos&quot;: {
220                 platform = &quot;solaris&quot;;
221                 break;
222             }
223             default: {
224                 platform = null;
225             }
226         }
227 
228         return platform;
229     }
230 
231     private static String[] getLauncher() throws IOException {
232         String platform = getPlatform();
233         if (platform == null) {
234             return null;
235         }
236 
237         String launcher = TEST_SRC + File.separator + platform + &quot;-&quot; + ARCH +
238                           File.separator + &quot;launcher&quot;;
239 
240         final FileSystem FS = FileSystems.getDefault();
241         Path launcherPath = FS.getPath(launcher);
242 
243         final boolean hasLauncher = Files.isRegularFile(launcherPath, LinkOption.NOFOLLOW_LINKS)&amp;&amp;
244                                     Files.isReadable(launcherPath);
245         if (!hasLauncher) {
246             System.out.println(&quot;Launcher [&quot; + launcher + &quot;] does not exist. Skipping the test.&quot;);
247             return null;
248         }
249 
250         // It is impossible to store an executable file in the source control
251         // We need to copy the launcher to the working directory
252         // and set the executable flag
253         Path localLauncherPath = FS.getPath(WORK_DIR, &quot;launcher&quot;);
254         Files.copy(launcherPath, localLauncherPath,
255                    StandardCopyOption.REPLACE_EXISTING);
256         if (!Files.isExecutable(localLauncherPath)) {
257             Set&lt;PosixFilePermission&gt; perms = new HashSet&lt;&gt;(
258                 Files.getPosixFilePermissions(
259                     localLauncherPath,
260                     LinkOption.NOFOLLOW_LINKS
261                 )
262             );
263             perms.add(PosixFilePermission.OWNER_EXECUTE);
264             Files.setPosixFilePermissions(localLauncherPath, perms);
265         }
266         return new String[] {launcher, localLauncherPath.toAbsolutePath().toString()};
267     }
268 }
    </pre>
  </body>
</html>
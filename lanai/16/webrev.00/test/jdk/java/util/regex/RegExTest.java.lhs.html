<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/util/regex/RegExTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /**
  25  * @test
  26  * @summary tests RegExp framework (use -Dseed=X to set PRNG seed)
  27  * @author Mike McCloskey
  28  * @bug 4481568 4482696 4495089 4504687 4527731 4599621 4631553 4619345
  29  * 4630911 4672616 4711773 4727935 4750573 4792284 4803197 4757029 4808962
  30  * 4872664 4803179 4892980 4900747 4945394 4938995 4979006 4994840 4997476
  31  * 5013885 5003322 4988891 5098443 5110268 6173522 4829857 5027748 6376940
  32  * 6358731 6178785 6284152 6231989 6497148 6486934 6233084 6504326 6635133
  33  * 6350801 6676425 6878475 6919132 6931676 6948903 6990617 7014645 7039066
  34  * 7067045 7014640 7189363 8007395 8013252 8013254 8012646 8023647 6559590
  35  * 8027645 8035076 8039124 8035975 8074678 6854417 8143854 8147531 7071819
  36  * 8151481 4867170 7080302 6728861 6995635 6736245 4916384 6328855 6192895
  37  * 6345469 6988218 6693451 7006761 8140212 8143282 8158482 8176029 8184706
  38  * 8194667 8197462 8184692 8221431 8224789 8228352 8230829 8236034 8235812
<a name="1" id="anc1"></a>
  39  *
  40  * @library /test/lib
  41  * @library /lib/testlibrary/java/lang
  42  * @build jdk.test.lib.RandomFactory
  43  * @run main RegExTest
  44  * @key randomness
  45  */
  46 
  47 import java.io.BufferedReader;
  48 import java.io.ByteArrayInputStream;
  49 import java.io.ByteArrayOutputStream;
  50 import java.io.File;
  51 import java.io.FileInputStream;
  52 import java.io.InputStreamReader;
  53 import java.io.ObjectInputStream;
  54 import java.io.ObjectOutputStream;
  55 import java.math.BigInteger;
  56 import java.nio.CharBuffer;
  57 import java.nio.file.Files;
<a name="2" id="anc2"></a>

  58 import java.util.ArrayList;
  59 import java.util.Arrays;
  60 import java.util.HashMap;
  61 import java.util.List;
  62 import java.util.Map;
  63 import java.util.Random;
  64 import java.util.Scanner;
  65 import java.util.function.Function;
  66 import java.util.function.Predicate;
  67 import java.util.regex.Matcher;
  68 import java.util.regex.MatchResult;
  69 import java.util.regex.Pattern;
  70 import java.util.regex.PatternSyntaxException;
<a name="3" id="anc3"></a>

  71 import jdk.test.lib.RandomFactory;
  72 
  73 /**
  74  * This is a test class created to check the operation of
  75  * the Pattern and Matcher classes.
  76  */
  77 public class RegExTest {
  78 
  79     private static Random generator = RandomFactory.getRandom();
  80     private static boolean failure = false;
  81     private static int failCount = 0;
  82     private static String firstFailure = null;
  83 
  84     /**
  85      * Main to interpret arguments and run several tests.
  86      *
  87      */
  88     public static void main(String[] args) throws Exception {
  89         // Most of the tests are in a file
  90         processFile(&quot;TestCases.txt&quot;);
  91         //processFile(&quot;PerlCases.txt&quot;);
  92         processFile(&quot;BMPTestCases.txt&quot;);
  93         processFile(&quot;SupplementaryTestCases.txt&quot;);
  94 
  95         // These test many randomly generated char patterns
  96         bm();
  97         slice();
  98 
  99         // These are hard to put into the file
 100         escapes();
 101         blankInput();
 102 
 103         // Substitition tests on randomly generated sequences
 104         globalSubstitute();
 105         stringbufferSubstitute();
 106         stringbuilderSubstitute();
 107 
 108         substitutionBasher();
 109         substitutionBasher2();
 110 
 111         // Canonical Equivalence
 112         ceTest();
 113 
 114         // Anchors
 115         anchorTest();
 116 
 117         // boolean match calls
 118         matchesTest();
 119         lookingAtTest();
 120 
 121         // Pattern API
 122         patternMatchesTest();
 123 
 124         // Misc
 125         lookbehindTest();
 126         nullArgumentTest();
 127         backRefTest();
 128         groupCaptureTest();
 129         caretTest();
 130         charClassTest();
 131         emptyPatternTest();
 132         findIntTest();
 133         group0Test();
 134         longPatternTest();
 135         octalTest();
 136         ampersandTest();
 137         negationTest();
 138         splitTest();
 139         appendTest();
 140         caseFoldingTest();
 141         commentsTest();
 142         unixLinesTest();
 143         replaceFirstTest();
 144         gTest();
 145         zTest();
 146         serializeTest();
 147         reluctantRepetitionTest();
 148         multilineDollarTest();
 149         dollarAtEndTest();
 150         caretBetweenTerminatorsTest();
 151         // This RFE rejected in Tiger numOccurrencesTest();
 152         javaCharClassTest();
 153         nonCaptureRepetitionTest();
 154         notCapturedGroupCurlyMatchTest();
 155         escapedSegmentTest();
 156         literalPatternTest();
 157         literalReplacementTest();
 158         regionTest();
 159         toStringTest();
 160         negatedCharClassTest();
 161         findFromTest();
 162         boundsTest();
 163         unicodeWordBoundsTest();
 164         caretAtEndTest();
 165         wordSearchTest();
 166         hitEndTest();
 167         toMatchResultTest();
 168         toMatchResultTest2();
 169         surrogatesInClassTest();
 170         removeQEQuotingTest();
 171         namedGroupCaptureTest();
 172         nonBmpClassComplementTest();
 173         unicodePropertiesTest();
 174         unicodeHexNotationTest();
 175         unicodeClassesTest();
 176         unicodeCharacterNameTest();
 177         horizontalAndVerticalWSTest();
 178         linebreakTest();
 179         branchTest();
 180         groupCurlyNotFoundSuppTest();
 181         groupCurlyBackoffTest();
 182         patternAsPredicate();
 183         patternAsMatchPredicate();
 184         invalidFlags();
 185         embeddedFlags();
 186         grapheme();
 187         expoBacktracking();
 188         invalidGroupName();
 189         illegalRepetitionRange();
 190         surrogatePairWithCanonEq();
 191         lineBreakWithQuantifier();
<a name="4" id="anc4"></a>
 192 
 193         if (failure) {
 194             throw new
 195                 RuntimeException(&quot;RegExTest failed, 1st failure: &quot; +
 196                                  firstFailure);
 197         } else {
 198             System.err.println(&quot;OKAY: All tests passed.&quot;);
 199         }
 200     }
 201 
 202     // Utility functions
 203 
 204     private static String getRandomAlphaString(int length) {
 205         StringBuffer buf = new StringBuffer(length);
 206         for (int i=0; i&lt;length; i++) {
 207             char randChar = (char)(97 + generator.nextInt(26));
 208             buf.append(randChar);
 209         }
 210         return buf.toString();
 211     }
 212 
 213     private static void check(Matcher m, String expected) {
 214         m.find();
 215         if (!m.group().equals(expected))
 216             failCount++;
 217     }
 218 
 219     private static void check(Matcher m, String result, boolean expected) {
 220         m.find();
 221         if (m.group().equals(result) != expected)
 222             failCount++;
 223     }
 224 
 225     private static void check(Pattern p, String s, boolean expected) {
 226         if (p.matcher(s).find() != expected)
 227             failCount++;
 228     }
 229 
 230     private static void check(String p, String s, boolean expected) {
 231         Matcher matcher = Pattern.compile(p).matcher(s);
 232         if (matcher.find() != expected)
 233             failCount++;
 234     }
 235 
 236     private static void check(String p, char c, boolean expected) {
 237         String propertyPattern = expected ? &quot;\\p&quot; + p : &quot;\\P&quot; + p;
 238         Pattern pattern = Pattern.compile(propertyPattern);
 239         char[] ca = new char[1]; ca[0] = c;
 240         Matcher matcher = pattern.matcher(new String(ca));
 241         if (!matcher.find())
 242             failCount++;
 243     }
 244 
 245     private static void check(String p, int codePoint, boolean expected) {
 246         String propertyPattern = expected ? &quot;\\p&quot; + p : &quot;\\P&quot; + p;
 247         Pattern pattern = Pattern.compile(propertyPattern);
 248         char[] ca = Character.toChars(codePoint);
 249         Matcher matcher = pattern.matcher(new String(ca));
 250         if (!matcher.find())
 251             failCount++;
 252     }
 253 
 254     private static void check(String p, int flag, String input, String s,
 255                               boolean expected)
 256     {
 257         Pattern pattern = Pattern.compile(p, flag);
 258         Matcher matcher = pattern.matcher(input);
 259         if (expected)
 260             check(matcher, s, expected);
 261         else
 262             check(pattern, input, false);
 263     }
 264 
 265     private static void report(String testName) {
 266         int spacesToAdd = 30 - testName.length();
 267         StringBuffer paddedNameBuffer = new StringBuffer(testName);
 268         for (int i=0; i&lt;spacesToAdd; i++)
 269             paddedNameBuffer.append(&quot; &quot;);
 270         String paddedName = paddedNameBuffer.toString();
 271         System.err.println(paddedName + &quot;: &quot; +
 272                            (failCount==0 ? &quot;Passed&quot;:&quot;Failed(&quot;+failCount+&quot;)&quot;));
 273         if (failCount &gt; 0) {
 274             failure = true;
 275 
 276             if (firstFailure == null) {
 277                 firstFailure = testName;
 278             }
 279         }
 280 
 281         failCount = 0;
 282     }
 283 
 284     /**
 285      * Converts ASCII alphabet characters [A-Za-z] in the given &#39;s&#39; to
 286      * supplementary characters. This method does NOT fully take care
 287      * of the regex syntax.
 288      */
 289     private static String toSupplementaries(String s) {
 290         int length = s.length();
 291         StringBuffer sb = new StringBuffer(length * 2);
 292 
 293         for (int i = 0; i &lt; length; ) {
 294             char c = s.charAt(i++);
 295             if (c == &#39;\\&#39;) {
 296                 sb.append(c);
 297                 if (i &lt; length) {
 298                     c = s.charAt(i++);
 299                     sb.append(c);
 300                     if (c == &#39;u&#39;) {
 301                         // assume no syntax error
 302                         sb.append(s.charAt(i++));
 303                         sb.append(s.charAt(i++));
 304                         sb.append(s.charAt(i++));
 305                         sb.append(s.charAt(i++));
 306                     }
 307                 }
 308             } else if ((c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;) || (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;)) {
 309                 sb.append(&#39;\ud800&#39;).append((char)(&#39;\udc00&#39;+c));
 310             } else {
 311                 sb.append(c);
 312             }
 313         }
 314         return sb.toString();
 315     }
 316 
 317     // Regular expression tests
 318 
 319     // This is for bug 6178785
 320     // Test if an expected NPE gets thrown when passing in a null argument
 321     private static boolean check(Runnable test) {
 322         try {
 323             test.run();
 324             failCount++;
 325             return false;
 326         } catch (NullPointerException npe) {
 327             return true;
 328         }
 329     }
 330 
 331     private static void nullArgumentTest() {
 332         check(() -&gt; Pattern.compile(null));
 333         check(() -&gt; Pattern.matches(null, null));
 334         check(() -&gt; Pattern.matches(&quot;xyz&quot;, null));
 335         check(() -&gt; Pattern.quote(null));
 336         check(() -&gt; Pattern.compile(&quot;xyz&quot;).split(null));
 337         check(() -&gt; Pattern.compile(&quot;xyz&quot;).matcher(null));
 338 
 339         final Matcher m = Pattern.compile(&quot;xyz&quot;).matcher(&quot;xyz&quot;);
 340         m.matches();
 341         check(() -&gt; m.appendTail((StringBuffer) null));
 342         check(() -&gt; m.appendTail((StringBuilder)null));
 343         check(() -&gt; m.replaceAll((String) null));
 344         check(() -&gt; m.replaceAll((Function&lt;MatchResult, String&gt;)null));
 345         check(() -&gt; m.replaceFirst((String)null));
 346         check(() -&gt; m.replaceFirst((Function&lt;MatchResult, String&gt;) null));
 347         check(() -&gt; m.appendReplacement((StringBuffer)null, null));
 348         check(() -&gt; m.appendReplacement((StringBuilder)null, null));
 349         check(() -&gt; m.reset(null));
 350         check(() -&gt; Matcher.quoteReplacement(null));
 351         //check(() -&gt; m.usePattern(null));
 352 
 353         report(&quot;Null Argument&quot;);
 354     }
 355 
 356     // This is for bug6635133
 357     // Test if surrogate pair in Unicode escapes can be handled correctly.
 358     private static void surrogatesInClassTest() throws Exception {
 359         Pattern pattern = Pattern.compile(&quot;[\\ud834\\udd21-\\ud834\\udd24]&quot;);
 360         Matcher matcher = pattern.matcher(&quot;\ud834\udd22&quot;);
 361         if (!matcher.find())
 362             failCount++;
 363 
 364         report(&quot;Surrogate pair in Unicode escape&quot;);
 365     }
 366 
 367     // This is for bug6990617
 368     // Test if Pattern.RemoveQEQuoting works correctly if the octal unicode
 369     // char encoding is only 2 or 3 digits instead of 4 and the first quoted
 370     // char is an octal digit.
 371     private static void removeQEQuotingTest() throws Exception {
 372         Pattern pattern =
 373             Pattern.compile(&quot;\\011\\Q1sometext\\E\\011\\Q2sometext\\E&quot;);
 374         Matcher matcher = pattern.matcher(&quot;\t1sometext\t2sometext&quot;);
 375         if (!matcher.find())
 376             failCount++;
 377 
 378         report(&quot;Remove Q/E Quoting&quot;);
 379     }
 380 
 381     // This is for bug 4988891
 382     // Test toMatchResult to see that it is a copy of the Matcher
 383     // that is not affected by subsequent operations on the original
 384     private static void toMatchResultTest() throws Exception {
 385         Pattern pattern = Pattern.compile(&quot;squid&quot;);
 386         Matcher matcher = pattern.matcher(
 387             &quot;agiantsquidofdestinyasmallsquidoffate&quot;);
 388         matcher.find();
 389         int matcherStart1 = matcher.start();
 390         MatchResult mr = matcher.toMatchResult();
 391         if (mr == matcher)
 392             failCount++;
 393         int resultStart1 = mr.start();
 394         if (matcherStart1 != resultStart1)
 395             failCount++;
 396         matcher.find();
 397         int matcherStart2 = matcher.start();
 398         int resultStart2 = mr.start();
 399         if (matcherStart2 == resultStart2)
 400             failCount++;
 401         if (resultStart1 != resultStart2)
 402             failCount++;
 403         MatchResult mr2 = matcher.toMatchResult();
 404         if (mr == mr2)
 405             failCount++;
 406         if (mr2.start() != matcherStart2)
 407             failCount++;
 408         report(&quot;toMatchResult is a copy&quot;);
 409     }
 410 
 411     private static void checkExpectedISE(Runnable test) {
 412         try {
 413             test.run();
 414             failCount++;
 415         } catch (IllegalStateException x) {
 416         } catch (IndexOutOfBoundsException xx) {
 417             failCount++;
 418         }
 419     }
 420 
 421     private static void checkExpectedIOOE(Runnable test) {
 422         try {
 423             test.run();
 424             failCount++;
 425         } catch (IndexOutOfBoundsException x) {}
 426     }
 427 
 428     // This is for bug 8074678
 429     // Test the result of toMatchResult throws ISE if no match is availble
 430     private static void toMatchResultTest2() throws Exception {
 431         Matcher matcher = Pattern.compile(&quot;nomatch&quot;).matcher(&quot;hello world&quot;);
 432         matcher.find();
 433         MatchResult mr = matcher.toMatchResult();
 434 
 435         checkExpectedISE(() -&gt; mr.start());
 436         checkExpectedISE(() -&gt; mr.start(2));
 437         checkExpectedISE(() -&gt; mr.end());
 438         checkExpectedISE(() -&gt; mr.end(2));
 439         checkExpectedISE(() -&gt; mr.group());
 440         checkExpectedISE(() -&gt; mr.group(2));
 441 
 442         matcher = Pattern.compile(&quot;(match)&quot;).matcher(&quot;there is a match&quot;);
 443         matcher.find();
 444         MatchResult mr2 = matcher.toMatchResult();
 445         checkExpectedIOOE(() -&gt; mr2.start(2));
 446         checkExpectedIOOE(() -&gt; mr2.end(2));
 447         checkExpectedIOOE(() -&gt; mr2.group(2));
 448 
 449         report(&quot;toMatchResult2 appropriate exceptions&quot;);
 450     }
 451 
 452     // This is for bug 5013885
 453     // Must test a slice to see if it reports hitEnd correctly
 454     private static void hitEndTest() throws Exception {
 455         // Basic test of Slice node
 456         Pattern p = Pattern.compile(&quot;^squidattack&quot;);
 457         Matcher m = p.matcher(&quot;squack&quot;);
 458         m.find();
 459         if (m.hitEnd())
 460             failCount++;
 461         m.reset(&quot;squid&quot;);
 462         m.find();
 463         if (!m.hitEnd())
 464             failCount++;
 465 
 466         // Test Slice, SliceA and SliceU nodes
 467         for (int i=0; i&lt;3; i++) {
 468             int flags = 0;
 469             if (i==1) flags = Pattern.CASE_INSENSITIVE;
 470             if (i==2) flags = Pattern.UNICODE_CASE;
 471             p = Pattern.compile(&quot;^abc&quot;, flags);
 472             m = p.matcher(&quot;ad&quot;);
 473             m.find();
 474             if (m.hitEnd())
 475                 failCount++;
 476             m.reset(&quot;ab&quot;);
 477             m.find();
 478             if (!m.hitEnd())
 479                 failCount++;
 480         }
 481 
 482         // Test Boyer-Moore node
 483         p = Pattern.compile(&quot;catattack&quot;);
 484         m = p.matcher(&quot;attack&quot;);
 485         m.find();
 486         if (!m.hitEnd())
 487             failCount++;
 488 
 489         p = Pattern.compile(&quot;catattack&quot;);
 490         m = p.matcher(&quot;attackattackattackcatatta&quot;);
 491         m.find();
 492         if (!m.hitEnd())
 493             failCount++;
 494 
 495         // 8184706: Matching u+0d at EOL against \R should hit-end
 496         p = Pattern.compile(&quot;...\\R&quot;);
 497         m = p.matcher(&quot;cat&quot; + (char)0x0a);
 498         m.find();
 499         if (m.hitEnd())
 500             failCount++;
 501 
 502         m = p.matcher(&quot;cat&quot; + (char)0x0d);
 503         m.find();
 504         if (!m.hitEnd())
 505             failCount++;
 506 
 507         m = p.matcher(&quot;cat&quot; + (char)0x0d + (char)0x0a);
 508         m.find();
 509         if (m.hitEnd())
 510             failCount++;
 511 
 512         report(&quot;hitEnd&quot;);
 513     }
 514 
 515     // This is for bug 4997476
 516     // It is weird code submitted by customer demonstrating a regression
 517     private static void wordSearchTest() throws Exception {
 518         String testString = new String(&quot;word1 word2 word3&quot;);
 519         Pattern p = Pattern.compile(&quot;\\b&quot;);
 520         Matcher m = p.matcher(testString);
 521         int position = 0;
 522         int start = 0;
 523         while (m.find(position)) {
 524             start = m.start();
 525             if (start == testString.length())
 526                 break;
 527             if (m.find(start+1)) {
 528                 position = m.start();
 529             } else {
 530                 position = testString.length();
 531             }
 532             if (testString.substring(start, position).equals(&quot; &quot;))
 533                 continue;
 534             if (!testString.substring(start, position-1).startsWith(&quot;word&quot;))
 535                 failCount++;
 536         }
 537         report(&quot;Customer word search&quot;);
 538     }
 539 
 540     // This is for bug 4994840
 541     private static void caretAtEndTest() throws Exception {
 542         // Problem only occurs with multiline patterns
 543         // containing a beginning-of-line caret &quot;^&quot; followed
 544         // by an expression that also matches the empty string.
 545         Pattern pattern = Pattern.compile(&quot;^x?&quot;, Pattern.MULTILINE);
 546         Matcher matcher = pattern.matcher(&quot;\r&quot;);
 547         matcher.find();
 548         matcher.find();
 549         report(&quot;Caret at end&quot;);
 550     }
 551 
 552     // This test is for 4979006
 553     // Check to see if word boundary construct properly handles unicode
 554     // non spacing marks
 555     private static void unicodeWordBoundsTest() throws Exception {
 556         String spaces = &quot;  &quot;;
 557         String wordChar = &quot;a&quot;;
 558         String nsm = &quot;\u030a&quot;;
 559 
 560         assert (Character.getType(&#39;\u030a&#39;) == Character.NON_SPACING_MARK);
 561 
 562         Pattern pattern = Pattern.compile(&quot;\\b&quot;);
 563         Matcher matcher = pattern.matcher(&quot;&quot;);
 564         // S=other B=word character N=non spacing mark .=word boundary
 565         // SS.BB.SS
 566         String input = spaces + wordChar + wordChar + spaces;
 567         twoFindIndexes(input, matcher, 2, 4);
 568         // SS.BBN.SS
 569         input = spaces + wordChar +wordChar + nsm + spaces;
 570         twoFindIndexes(input, matcher, 2, 5);
 571         // SS.BN.SS
 572         input = spaces + wordChar + nsm + spaces;
 573         twoFindIndexes(input, matcher, 2, 4);
 574         // SS.BNN.SS
 575         input = spaces + wordChar + nsm + nsm + spaces;
 576         twoFindIndexes(input, matcher, 2, 5);
 577         // SSN.BB.SS
 578         input = spaces + nsm + wordChar + wordChar + spaces;
 579         twoFindIndexes(input, matcher, 3, 5);
 580         // SS.BNB.SS
 581         input = spaces + wordChar + nsm + wordChar + spaces;
 582         twoFindIndexes(input, matcher, 2, 5);
 583         // SSNNSS
 584         input = spaces + nsm + nsm + spaces;
 585         matcher.reset(input);
 586         if (matcher.find())
 587             failCount++;
 588         // SSN.BBN.SS
 589         input = spaces + nsm + wordChar + wordChar + nsm + spaces;
 590         twoFindIndexes(input, matcher, 3, 6);
 591 
 592         report(&quot;Unicode word boundary&quot;);
 593     }
 594 
 595     private static void twoFindIndexes(String input, Matcher matcher, int a,
 596                                        int b) throws Exception
 597     {
 598         matcher.reset(input);
 599         matcher.find();
 600         if (matcher.start() != a)
 601             failCount++;
 602         matcher.find();
 603         if (matcher.start() != b)
 604             failCount++;
 605     }
 606 
 607     // This test is for 6284152
 608     static void check(String regex, String input, String[] expected) {
 609         List&lt;String&gt; result = new ArrayList&lt;String&gt;();
 610         Pattern p = Pattern.compile(regex);
 611         Matcher m = p.matcher(input);
 612         while (m.find()) {
 613             result.add(m.group());
 614         }
 615         if (!Arrays.asList(expected).equals(result))
 616             failCount++;
 617     }
 618 
 619     private static void lookbehindTest() throws Exception {
 620         //Positive
 621         check(&quot;(?&lt;=%.{0,5})foo\\d&quot;,
 622               &quot;%foo1\n%bar foo2\n%bar  foo3\n%blahblah foo4\nfoo5&quot;,
 623               new String[]{&quot;foo1&quot;, &quot;foo2&quot;, &quot;foo3&quot;});
 624 
 625         //boundary at end of the lookbehind sub-regex should work consistently
 626         //with the boundary just after the lookbehind sub-regex
 627         check(&quot;(?&lt;=.*\\b)foo&quot;, &quot;abcd foo&quot;, new String[]{&quot;foo&quot;});
 628         check(&quot;(?&lt;=.*)\\bfoo&quot;, &quot;abcd foo&quot;, new String[]{&quot;foo&quot;});
 629         check(&quot;(?&lt;!abc )\\bfoo&quot;, &quot;abc foo&quot;, new String[0]);
 630         check(&quot;(?&lt;!abc \\b)foo&quot;, &quot;abc foo&quot;, new String[0]);
 631 
 632         //Negative
 633         check(&quot;(?&lt;!%.{0,5})foo\\d&quot;,
 634               &quot;%foo1\n%bar foo2\n%bar  foo3\n%blahblah foo4\nfoo5&quot;,
 635               new String[] {&quot;foo4&quot;, &quot;foo5&quot;});
 636 
 637         //Positive greedy
 638         check(&quot;(?&lt;=%b{1,4})foo&quot;, &quot;%bbbbfoo&quot;, new String[] {&quot;foo&quot;});
 639 
 640         //Positive reluctant
 641         check(&quot;(?&lt;=%b{1,4}?)foo&quot;, &quot;%bbbbfoo&quot;, new String[] {&quot;foo&quot;});
 642 
 643         //supplementary
 644         check(&quot;(?&lt;=%b{1,4})fo\ud800\udc00o&quot;, &quot;%bbbbfo\ud800\udc00o&quot;,
 645               new String[] {&quot;fo\ud800\udc00o&quot;});
 646         check(&quot;(?&lt;=%b{1,4}?)fo\ud800\udc00o&quot;, &quot;%bbbbfo\ud800\udc00o&quot;,
 647               new String[] {&quot;fo\ud800\udc00o&quot;});
 648         check(&quot;(?&lt;!%b{1,4})fo\ud800\udc00o&quot;, &quot;%afo\ud800\udc00o&quot;,
 649               new String[] {&quot;fo\ud800\udc00o&quot;});
 650         check(&quot;(?&lt;!%b{1,4}?)fo\ud800\udc00o&quot;, &quot;%afo\ud800\udc00o&quot;,
 651               new String[] {&quot;fo\ud800\udc00o&quot;});
 652         report(&quot;Lookbehind&quot;);
 653     }
 654 
 655     // This test is for 4938995
 656     // Check to see if weak region boundaries are transparent to
 657     // lookahead and lookbehind constructs
 658     private static void boundsTest() throws Exception {
 659         String fullMessage = &quot;catdogcat&quot;;
 660         Pattern pattern = Pattern.compile(&quot;(?&lt;=cat)dog(?=cat)&quot;);
 661         Matcher matcher = pattern.matcher(&quot;catdogca&quot;);
 662         matcher.useTransparentBounds(true);
 663         if (matcher.find())
 664             failCount++;
 665         matcher.reset(&quot;atdogcat&quot;);
 666         if (matcher.find())
 667             failCount++;
 668         matcher.reset(fullMessage);
 669         if (!matcher.find())
 670             failCount++;
 671         matcher.reset(fullMessage);
 672         matcher.region(0,9);
 673         if (!matcher.find())
 674             failCount++;
 675         matcher.reset(fullMessage);
 676         matcher.region(0,6);
 677         if (!matcher.find())
 678             failCount++;
 679         matcher.reset(fullMessage);
 680         matcher.region(3,6);
 681         if (!matcher.find())
 682             failCount++;
 683         matcher.useTransparentBounds(false);
 684         if (matcher.find())
 685             failCount++;
 686 
 687         // Negative lookahead/lookbehind
 688         pattern = Pattern.compile(&quot;(?&lt;!cat)dog(?!cat)&quot;);
 689         matcher = pattern.matcher(&quot;dogcat&quot;);
 690         matcher.useTransparentBounds(true);
 691         matcher.region(0,3);
 692         if (matcher.find())
 693             failCount++;
 694         matcher.reset(&quot;catdog&quot;);
 695         matcher.region(3,6);
 696         if (matcher.find())
 697             failCount++;
 698         matcher.useTransparentBounds(false);
 699         matcher.reset(&quot;dogcat&quot;);
 700         matcher.region(0,3);
 701         if (!matcher.find())
 702             failCount++;
 703         matcher.reset(&quot;catdog&quot;);
 704         matcher.region(3,6);
 705         if (!matcher.find())
 706             failCount++;
 707 
 708         report(&quot;Region bounds transparency&quot;);
 709     }
 710 
 711     // This test is for 4945394
 712     private static void findFromTest() throws Exception {
 713         String message = &quot;This is 40 $0 message.&quot;;
 714         Pattern pat = Pattern.compile(&quot;\\$0&quot;);
 715         Matcher match = pat.matcher(message);
 716         if (!match.find())
 717             failCount++;
 718         if (match.find())
 719             failCount++;
 720         if (match.find())
 721             failCount++;
 722         report(&quot;Check for alternating find&quot;);
 723     }
 724 
 725     // This test is for 4872664 and 4892980
 726     private static void negatedCharClassTest() throws Exception {
 727         Pattern pattern = Pattern.compile(&quot;[^&gt;]&quot;);
 728         Matcher matcher = pattern.matcher(&quot;\u203A&quot;);
 729         if (!matcher.matches())
 730             failCount++;
 731         pattern = Pattern.compile(&quot;[^fr]&quot;);
 732         matcher = pattern.matcher(&quot;a&quot;);
 733         if (!matcher.find())
 734             failCount++;
 735         matcher.reset(&quot;\u203A&quot;);
 736         if (!matcher.find())
 737             failCount++;
 738         String s = &quot;for&quot;;
 739         String result[] = s.split(&quot;[^fr]&quot;);
 740         if (!result[0].equals(&quot;f&quot;))
 741             failCount++;
 742         if (!result[1].equals(&quot;r&quot;))
 743             failCount++;
 744         s = &quot;f\u203Ar&quot;;
 745         result = s.split(&quot;[^fr]&quot;);
 746         if (!result[0].equals(&quot;f&quot;))
 747             failCount++;
 748         if (!result[1].equals(&quot;r&quot;))
 749             failCount++;
 750 
 751         // Test adding to bits, subtracting a node, then adding to bits again
 752         pattern = Pattern.compile(&quot;[^f\u203Ar]&quot;);
 753         matcher = pattern.matcher(&quot;a&quot;);
 754         if (!matcher.find())
 755             failCount++;
 756         matcher.reset(&quot;f&quot;);
 757         if (matcher.find())
 758             failCount++;
 759         matcher.reset(&quot;\u203A&quot;);
 760         if (matcher.find())
 761             failCount++;
 762         matcher.reset(&quot;r&quot;);
 763         if (matcher.find())
 764             failCount++;
 765         matcher.reset(&quot;\u203B&quot;);
 766         if (!matcher.find())
 767             failCount++;
 768 
 769         // Test subtracting a node, adding to bits, subtracting again
 770         pattern = Pattern.compile(&quot;[^\u203Ar\u203B]&quot;);
 771         matcher = pattern.matcher(&quot;a&quot;);
 772         if (!matcher.find())
 773             failCount++;
 774         matcher.reset(&quot;\u203A&quot;);
 775         if (matcher.find())
 776             failCount++;
 777         matcher.reset(&quot;r&quot;);
 778         if (matcher.find())
 779             failCount++;
 780         matcher.reset(&quot;\u203B&quot;);
 781         if (matcher.find())
 782             failCount++;
 783         matcher.reset(&quot;\u203C&quot;);
 784         if (!matcher.find())
 785             failCount++;
 786 
 787         report(&quot;Negated Character Class&quot;);
 788     }
 789 
 790     // This test is for 4628291
 791     private static void toStringTest() throws Exception {
 792         Pattern pattern = Pattern.compile(&quot;b+&quot;);
 793         if (pattern.toString() != &quot;b+&quot;)
 794             failCount++;
 795         Matcher matcher = pattern.matcher(&quot;aaabbbccc&quot;);
 796         String matcherString = matcher.toString(); // unspecified
 797         matcher.find();
 798         matcherString = matcher.toString(); // unspecified
 799         matcher.region(0,3);
 800         matcherString = matcher.toString(); // unspecified
 801         matcher.reset();
 802         matcherString = matcher.toString(); // unspecified
 803         report(&quot;toString&quot;);
 804     }
 805 
 806     // This test is for 4808962
 807     private static void literalPatternTest() throws Exception {
 808         int flags = Pattern.LITERAL;
 809 
 810         Pattern pattern = Pattern.compile(&quot;abc\\t$^&quot;, flags);
 811         check(pattern, &quot;abc\\t$^&quot;, true);
 812 
 813         pattern = Pattern.compile(Pattern.quote(&quot;abc\\t$^&quot;));
 814         check(pattern, &quot;abc\\t$^&quot;, true);
 815 
 816         pattern = Pattern.compile(&quot;\\Qa^$bcabc\\E&quot;, flags);
 817         check(pattern, &quot;\\Qa^$bcabc\\E&quot;, true);
 818         check(pattern, &quot;a^$bcabc&quot;, false);
 819 
 820         pattern = Pattern.compile(&quot;\\\\Q\\\\E&quot;);
 821         check(pattern, &quot;\\Q\\E&quot;, true);
 822 
 823         pattern = Pattern.compile(&quot;\\Qabc\\Eefg\\\\Q\\\\Ehij&quot;);
 824         check(pattern, &quot;abcefg\\Q\\Ehij&quot;, true);
 825 
 826         pattern = Pattern.compile(&quot;\\\\\\Q\\\\E&quot;);
 827         check(pattern, &quot;\\\\\\\\&quot;, true);
 828 
 829         pattern = Pattern.compile(Pattern.quote(&quot;\\Qa^$bcabc\\E&quot;));
 830         check(pattern, &quot;\\Qa^$bcabc\\E&quot;, true);
 831         check(pattern, &quot;a^$bcabc&quot;, false);
 832 
 833         pattern = Pattern.compile(Pattern.quote(&quot;\\Qabc\\Edef&quot;));
 834         check(pattern, &quot;\\Qabc\\Edef&quot;, true);
 835         check(pattern, &quot;abcdef&quot;, false);
 836 
 837         pattern = Pattern.compile(Pattern.quote(&quot;abc\\Edef&quot;));
 838         check(pattern, &quot;abc\\Edef&quot;, true);
 839         check(pattern, &quot;abcdef&quot;, false);
 840 
 841         pattern = Pattern.compile(Pattern.quote(&quot;\\E&quot;));
 842         check(pattern, &quot;\\E&quot;, true);
 843 
 844         pattern = Pattern.compile(&quot;((((abc.+?:)&quot;, flags);
 845         check(pattern, &quot;((((abc.+?:)&quot;, true);
 846 
 847         flags |= Pattern.MULTILINE;
 848 
 849         pattern = Pattern.compile(&quot;^cat$&quot;, flags);
 850         check(pattern, &quot;abc^cat$def&quot;, true);
 851         check(pattern, &quot;cat&quot;, false);
 852 
 853         flags |= Pattern.CASE_INSENSITIVE;
 854 
 855         pattern = Pattern.compile(&quot;abcdef&quot;, flags);
 856         check(pattern, &quot;ABCDEF&quot;, true);
 857         check(pattern, &quot;AbCdEf&quot;, true);
 858 
 859         flags |= Pattern.DOTALL;
 860 
 861         pattern = Pattern.compile(&quot;a...b&quot;, flags);
 862         check(pattern, &quot;A...b&quot;, true);
 863         check(pattern, &quot;Axxxb&quot;, false);
 864 
 865         flags |= Pattern.CANON_EQ;
 866 
 867         Pattern p = Pattern.compile(&quot;testa\u030a&quot;, flags);
 868         check(pattern, &quot;testa\u030a&quot;, false);
 869         check(pattern, &quot;test\u00e5&quot;, false);
 870 
 871         // Supplementary character test
 872         flags = Pattern.LITERAL;
 873 
 874         pattern = Pattern.compile(toSupplementaries(&quot;abc\\t$^&quot;), flags);
 875         check(pattern, toSupplementaries(&quot;abc\\t$^&quot;), true);
 876 
 877         pattern = Pattern.compile(Pattern.quote(toSupplementaries(&quot;abc\\t$^&quot;)));
 878         check(pattern, toSupplementaries(&quot;abc\\t$^&quot;), true);
 879 
 880         pattern = Pattern.compile(toSupplementaries(&quot;\\Qa^$bcabc\\E&quot;), flags);
 881         check(pattern, toSupplementaries(&quot;\\Qa^$bcabc\\E&quot;), true);
 882         check(pattern, toSupplementaries(&quot;a^$bcabc&quot;), false);
 883 
 884         pattern = Pattern.compile(Pattern.quote(toSupplementaries(&quot;\\Qa^$bcabc\\E&quot;)));
 885         check(pattern, toSupplementaries(&quot;\\Qa^$bcabc\\E&quot;), true);
 886         check(pattern, toSupplementaries(&quot;a^$bcabc&quot;), false);
 887 
 888         pattern = Pattern.compile(Pattern.quote(toSupplementaries(&quot;\\Qabc\\Edef&quot;)));
 889         check(pattern, toSupplementaries(&quot;\\Qabc\\Edef&quot;), true);
 890         check(pattern, toSupplementaries(&quot;abcdef&quot;), false);
 891 
 892         pattern = Pattern.compile(Pattern.quote(toSupplementaries(&quot;abc\\Edef&quot;)));
 893         check(pattern, toSupplementaries(&quot;abc\\Edef&quot;), true);
 894         check(pattern, toSupplementaries(&quot;abcdef&quot;), false);
 895 
 896         pattern = Pattern.compile(toSupplementaries(&quot;((((abc.+?:)&quot;), flags);
 897         check(pattern, toSupplementaries(&quot;((((abc.+?:)&quot;), true);
 898 
 899         flags |= Pattern.MULTILINE;
 900 
 901         pattern = Pattern.compile(toSupplementaries(&quot;^cat$&quot;), flags);
 902         check(pattern, toSupplementaries(&quot;abc^cat$def&quot;), true);
 903         check(pattern, toSupplementaries(&quot;cat&quot;), false);
 904 
 905         flags |= Pattern.DOTALL;
 906 
 907         // note: this is case-sensitive.
 908         pattern = Pattern.compile(toSupplementaries(&quot;a...b&quot;), flags);
 909         check(pattern, toSupplementaries(&quot;a...b&quot;), true);
 910         check(pattern, toSupplementaries(&quot;axxxb&quot;), false);
 911 
 912         flags |= Pattern.CANON_EQ;
 913 
 914         String t = toSupplementaries(&quot;test&quot;);
 915         p = Pattern.compile(t + &quot;a\u030a&quot;, flags);
 916         check(pattern, t + &quot;a\u030a&quot;, false);
 917         check(pattern, t + &quot;\u00e5&quot;, false);
 918 
 919         report(&quot;Literal pattern&quot;);
 920     }
 921 
 922     // This test is for 4803179
 923     // This test is also for 4808962, replacement parts
 924     private static void literalReplacementTest() throws Exception {
 925         int flags = Pattern.LITERAL;
 926 
 927         Pattern pattern = Pattern.compile(&quot;abc&quot;, flags);
 928         Matcher matcher = pattern.matcher(&quot;zzzabczzz&quot;);
 929         String replaceTest = &quot;$0&quot;;
 930         String result = matcher.replaceAll(replaceTest);
 931         if (!result.equals(&quot;zzzabczzz&quot;))
 932             failCount++;
 933 
 934         matcher.reset();
 935         String literalReplacement = matcher.quoteReplacement(replaceTest);
 936         result = matcher.replaceAll(literalReplacement);
 937         if (!result.equals(&quot;zzz$0zzz&quot;))
 938             failCount++;
 939 
 940         matcher.reset();
 941         replaceTest = &quot;\\t$\\$&quot;;
 942         literalReplacement = matcher.quoteReplacement(replaceTest);
 943         result = matcher.replaceAll(literalReplacement);
 944         if (!result.equals(&quot;zzz\\t$\\$zzz&quot;))
 945             failCount++;
 946 
 947         // Supplementary character test
 948         pattern = Pattern.compile(toSupplementaries(&quot;abc&quot;), flags);
 949         matcher = pattern.matcher(toSupplementaries(&quot;zzzabczzz&quot;));
 950         replaceTest = &quot;$0&quot;;
 951         result = matcher.replaceAll(replaceTest);
 952         if (!result.equals(toSupplementaries(&quot;zzzabczzz&quot;)))
 953             failCount++;
 954 
 955         matcher.reset();
 956         literalReplacement = matcher.quoteReplacement(replaceTest);
 957         result = matcher.replaceAll(literalReplacement);
 958         if (!result.equals(toSupplementaries(&quot;zzz$0zzz&quot;)))
 959             failCount++;
 960 
 961         matcher.reset();
 962         replaceTest = &quot;\\t$\\$&quot;;
 963         literalReplacement = matcher.quoteReplacement(replaceTest);
 964         result = matcher.replaceAll(literalReplacement);
 965         if (!result.equals(toSupplementaries(&quot;zzz\\t$\\$zzz&quot;)))
 966             failCount++;
 967 
 968         // IAE should be thrown if backslash or &#39;$&#39; is the last character
 969         // in replacement string
 970         try {
 971             &quot;\uac00&quot;.replaceAll(&quot;\uac00&quot;, &quot;$&quot;);
 972             failCount++;
 973         } catch (IllegalArgumentException iie) {
 974         } catch (Exception e) {
 975             failCount++;
 976         }
 977         try {
 978             &quot;\uac00&quot;.replaceAll(&quot;\uac00&quot;, &quot;\\&quot;);
 979             failCount++;
 980         } catch (IllegalArgumentException iie) {
 981         } catch (Exception e) {
 982             failCount++;
 983         }
 984         report(&quot;Literal replacement&quot;);
 985     }
 986 
 987     // This test is for 4757029
 988     private static void regionTest() throws Exception {
 989         Pattern pattern = Pattern.compile(&quot;abc&quot;);
 990         Matcher matcher = pattern.matcher(&quot;abcdefabc&quot;);
 991 
 992         matcher.region(0,9);
 993         if (!matcher.find())
 994             failCount++;
 995         if (!matcher.find())
 996             failCount++;
 997         matcher.region(0,3);
 998         if (!matcher.find())
 999            failCount++;
1000         matcher.region(3,6);
1001         if (matcher.find())
1002            failCount++;
1003         matcher.region(0,2);
1004         if (matcher.find())
1005            failCount++;
1006 
1007         expectRegionFail(matcher, 1, -1);
1008         expectRegionFail(matcher, -1, -1);
1009         expectRegionFail(matcher, -1, 1);
1010         expectRegionFail(matcher, 5, 3);
1011         expectRegionFail(matcher, 5, 12);
1012         expectRegionFail(matcher, 12, 12);
1013 
1014         pattern = Pattern.compile(&quot;^abc$&quot;);
1015         matcher = pattern.matcher(&quot;zzzabczzz&quot;);
1016         matcher.region(0,9);
1017         if (matcher.find())
1018             failCount++;
1019         matcher.region(3,6);
1020         if (!matcher.find())
1021            failCount++;
1022         matcher.region(3,6);
1023         matcher.useAnchoringBounds(false);
1024         if (matcher.find())
1025            failCount++;
1026 
1027         // Supplementary character test
1028         pattern = Pattern.compile(toSupplementaries(&quot;abc&quot;));
1029         matcher = pattern.matcher(toSupplementaries(&quot;abcdefabc&quot;));
1030         matcher.region(0,9*2);
1031         if (!matcher.find())
1032             failCount++;
1033         if (!matcher.find())
1034             failCount++;
1035         matcher.region(0,3*2);
1036         if (!matcher.find())
1037            failCount++;
1038         matcher.region(1,3*2);
1039         if (matcher.find())
1040            failCount++;
1041         matcher.region(3*2,6*2);
1042         if (matcher.find())
1043            failCount++;
1044         matcher.region(0,2*2);
1045         if (matcher.find())
1046            failCount++;
1047         matcher.region(0,2*2+1);
1048         if (matcher.find())
1049            failCount++;
1050 
1051         expectRegionFail(matcher, 1*2, -1);
1052         expectRegionFail(matcher, -1, -1);
1053         expectRegionFail(matcher, -1, 1*2);
1054         expectRegionFail(matcher, 5*2, 3*2);
1055         expectRegionFail(matcher, 5*2, 12*2);
1056         expectRegionFail(matcher, 12*2, 12*2);
1057 
1058         pattern = Pattern.compile(toSupplementaries(&quot;^abc$&quot;));
1059         matcher = pattern.matcher(toSupplementaries(&quot;zzzabczzz&quot;));
1060         matcher.region(0,9*2);
1061         if (matcher.find())
1062             failCount++;
1063         matcher.region(3*2,6*2);
1064         if (!matcher.find())
1065            failCount++;
1066         matcher.region(3*2+1,6*2);
1067         if (matcher.find())
1068            failCount++;
1069         matcher.region(3*2,6*2-1);
1070         if (matcher.find())
1071            failCount++;
1072         matcher.region(3*2,6*2);
1073         matcher.useAnchoringBounds(false);
1074         if (matcher.find())
1075            failCount++;
1076 
1077         // JDK-8230829
1078         pattern = Pattern.compile(&quot;\\ud800\\udc61&quot;);
1079         matcher = pattern.matcher(&quot;\ud800\udc61&quot;);
1080         matcher.region(0, 1);
1081         if (matcher.find()) {
1082             failCount++;
1083             System.out.println(&quot;Matched a surrogate pair&quot; +
1084                     &quot; that crosses border of region&quot;);
1085         }
1086         if (!matcher.hitEnd()) {
1087             failCount++;
1088             System.out.println(&quot;Expected to hit the end when&quot; +
1089                     &quot; matching a surrogate pair crossing region&quot;);
1090         }
1091 
1092         report(&quot;Regions&quot;);
1093     }
1094 
1095     private static void expectRegionFail(Matcher matcher, int index1,
1096                                          int index2)
1097     {
1098         try {
1099             matcher.region(index1, index2);
1100             failCount++;
1101         } catch (IndexOutOfBoundsException ioobe) {
1102             // Correct result
1103         } catch (IllegalStateException ise) {
1104             // Correct result
1105         }
1106     }
1107 
1108     // This test is for 4803197
1109     private static void escapedSegmentTest() throws Exception {
1110 
1111         Pattern pattern = Pattern.compile(&quot;\\Qdir1\\dir2\\E&quot;);
1112         check(pattern, &quot;dir1\\dir2&quot;, true);
1113 
1114         pattern = Pattern.compile(&quot;\\Qdir1\\dir2\\\\E&quot;);
1115         check(pattern, &quot;dir1\\dir2\\&quot;, true);
1116 
1117         pattern = Pattern.compile(&quot;(\\Qdir1\\dir2\\\\E)&quot;);
1118         check(pattern, &quot;dir1\\dir2\\&quot;, true);
1119 
1120         // Supplementary character test
1121         pattern = Pattern.compile(toSupplementaries(&quot;\\Qdir1\\dir2\\E&quot;));
1122         check(pattern, toSupplementaries(&quot;dir1\\dir2&quot;), true);
1123 
1124         pattern = Pattern.compile(toSupplementaries(&quot;\\Qdir1\\dir2&quot;)+&quot;\\\\E&quot;);
1125         check(pattern, toSupplementaries(&quot;dir1\\dir2\\&quot;), true);
1126 
1127         pattern = Pattern.compile(toSupplementaries(&quot;(\\Qdir1\\dir2&quot;)+&quot;\\\\E)&quot;);
1128         check(pattern, toSupplementaries(&quot;dir1\\dir2\\&quot;), true);
1129 
1130         report(&quot;Escaped segment&quot;);
1131     }
1132 
1133     // This test is for 4792284
1134     private static void nonCaptureRepetitionTest() throws Exception {
1135         String input = &quot;abcdefgh;&quot;;
1136 
1137         String[] patterns = new String[] {
1138             &quot;(?:\\w{4})+;&quot;,
1139             &quot;(?:\\w{8})*;&quot;,
1140             &quot;(?:\\w{2}){2,4};&quot;,
1141             &quot;(?:\\w{4}){2,};&quot;,   // only matches the
1142             &quot;.*?(?:\\w{5})+;&quot;,   //     specified minimum
1143             &quot;.*?(?:\\w{9})*;&quot;,   //     number of reps - OK
1144             &quot;(?:\\w{4})+?;&quot;,     // lazy repetition - OK
1145             &quot;(?:\\w{4})++;&quot;,     // possessive repetition - OK
1146             &quot;(?:\\w{2,}?)+;&quot;,    // non-deterministic - OK
1147             &quot;(\\w{4})+;&quot;,        // capturing group - OK
1148         };
1149 
1150         for (int i = 0; i &lt; patterns.length; i++) {
1151             // Check find()
1152             check(patterns[i], 0, input, input, true);
1153             // Check matches()
1154             Pattern p = Pattern.compile(patterns[i]);
1155             Matcher m = p.matcher(input);
1156 
1157             if (m.matches()) {
1158                 if (!m.group(0).equals(input))
1159                     failCount++;
1160             } else {
1161                 failCount++;
1162             }
1163         }
1164 
1165         report(&quot;Non capturing repetition&quot;);
1166     }
1167 
1168     // This test is for 6358731
1169     private static void notCapturedGroupCurlyMatchTest() throws Exception {
1170         Pattern pattern = Pattern.compile(&quot;(abc)+|(abcd)+&quot;);
1171         Matcher matcher = pattern.matcher(&quot;abcd&quot;);
1172         if (!matcher.matches() ||
1173              matcher.group(1) != null ||
1174              !matcher.group(2).equals(&quot;abcd&quot;)) {
1175             failCount++;
1176         }
1177         report(&quot;Not captured GroupCurly&quot;);
1178     }
1179 
1180     // This test is for 4706545
1181     private static void javaCharClassTest() throws Exception {
1182         for (int i=0; i&lt;1000; i++) {
1183             char c = (char)generator.nextInt();
1184             check(&quot;{javaLowerCase}&quot;, c, Character.isLowerCase(c));
1185             check(&quot;{javaUpperCase}&quot;, c, Character.isUpperCase(c));
1186             check(&quot;{javaUpperCase}+&quot;, c, Character.isUpperCase(c));
1187             check(&quot;{javaTitleCase}&quot;, c, Character.isTitleCase(c));
1188             check(&quot;{javaDigit}&quot;, c, Character.isDigit(c));
1189             check(&quot;{javaDefined}&quot;, c, Character.isDefined(c));
1190             check(&quot;{javaLetter}&quot;, c, Character.isLetter(c));
1191             check(&quot;{javaLetterOrDigit}&quot;, c, Character.isLetterOrDigit(c));
1192             check(&quot;{javaJavaIdentifierStart}&quot;, c,
1193                   Character.isJavaIdentifierStart(c));
1194             check(&quot;{javaJavaIdentifierPart}&quot;, c,
1195                   Character.isJavaIdentifierPart(c));
1196             check(&quot;{javaUnicodeIdentifierStart}&quot;, c,
1197                   Character.isUnicodeIdentifierStart(c));
1198             check(&quot;{javaUnicodeIdentifierPart}&quot;, c,
1199                   Character.isUnicodeIdentifierPart(c));
1200             check(&quot;{javaIdentifierIgnorable}&quot;, c,
1201                   Character.isIdentifierIgnorable(c));
1202             check(&quot;{javaSpaceChar}&quot;, c, Character.isSpaceChar(c));
1203             check(&quot;{javaWhitespace}&quot;, c, Character.isWhitespace(c));
1204             check(&quot;{javaISOControl}&quot;, c, Character.isISOControl(c));
1205             check(&quot;{javaMirrored}&quot;, c, Character.isMirrored(c));
1206 
1207         }
1208 
1209         // Supplementary character test
1210         for (int i=0; i&lt;1000; i++) {
1211             int c = generator.nextInt(Character.MAX_CODE_POINT
1212                                       - Character.MIN_SUPPLEMENTARY_CODE_POINT)
1213                         + Character.MIN_SUPPLEMENTARY_CODE_POINT;
1214             check(&quot;{javaLowerCase}&quot;, c, Character.isLowerCase(c));
1215             check(&quot;{javaUpperCase}&quot;, c, Character.isUpperCase(c));
1216             check(&quot;{javaUpperCase}+&quot;, c, Character.isUpperCase(c));
1217             check(&quot;{javaTitleCase}&quot;, c, Character.isTitleCase(c));
1218             check(&quot;{javaDigit}&quot;, c, Character.isDigit(c));
1219             check(&quot;{javaDefined}&quot;, c, Character.isDefined(c));
1220             check(&quot;{javaLetter}&quot;, c, Character.isLetter(c));
1221             check(&quot;{javaLetterOrDigit}&quot;, c, Character.isLetterOrDigit(c));
1222             check(&quot;{javaJavaIdentifierStart}&quot;, c,
1223                   Character.isJavaIdentifierStart(c));
1224             check(&quot;{javaJavaIdentifierPart}&quot;, c,
1225                   Character.isJavaIdentifierPart(c));
1226             check(&quot;{javaUnicodeIdentifierStart}&quot;, c,
1227                   Character.isUnicodeIdentifierStart(c));
1228             check(&quot;{javaUnicodeIdentifierPart}&quot;, c,
1229                   Character.isUnicodeIdentifierPart(c));
1230             check(&quot;{javaIdentifierIgnorable}&quot;, c,
1231                   Character.isIdentifierIgnorable(c));
1232             check(&quot;{javaSpaceChar}&quot;, c, Character.isSpaceChar(c));
1233             check(&quot;{javaWhitespace}&quot;, c, Character.isWhitespace(c));
1234             check(&quot;{javaISOControl}&quot;, c, Character.isISOControl(c));
1235             check(&quot;{javaMirrored}&quot;, c, Character.isMirrored(c));
1236         }
1237 
1238         report(&quot;Java character classes&quot;);
1239     }
1240 
1241     // This test is for 4523620
1242     /*
1243     private static void numOccurrencesTest() throws Exception {
1244         Pattern pattern = Pattern.compile(&quot;aaa&quot;);
1245 
1246         if (pattern.numOccurrences(&quot;aaaaaa&quot;, false) != 2)
1247             failCount++;
1248         if (pattern.numOccurrences(&quot;aaaaaa&quot;, true) != 4)
1249             failCount++;
1250 
1251         pattern = Pattern.compile(&quot;^&quot;);
1252         if (pattern.numOccurrences(&quot;aaaaaa&quot;, false) != 1)
1253             failCount++;
1254         if (pattern.numOccurrences(&quot;aaaaaa&quot;, true) != 1)
1255             failCount++;
1256 
1257         report(&quot;Number of Occurrences&quot;);
1258     }
1259     */
1260 
1261     // This test is for 4776374
1262     private static void caretBetweenTerminatorsTest() throws Exception {
1263         int flags1 = Pattern.DOTALL;
1264         int flags2 = Pattern.DOTALL | Pattern.UNIX_LINES;
1265         int flags3 = Pattern.DOTALL | Pattern.UNIX_LINES | Pattern.MULTILINE;
1266         int flags4 = Pattern.DOTALL | Pattern.MULTILINE;
1267 
1268         check(&quot;^....&quot;, flags1, &quot;test\ntest&quot;, &quot;test&quot;, true);
1269         check(&quot;.....^&quot;, flags1, &quot;test\ntest&quot;, &quot;test&quot;, false);
1270         check(&quot;.....^&quot;, flags1, &quot;test\n&quot;, &quot;test&quot;, false);
1271         check(&quot;....^&quot;, flags1, &quot;test\r\n&quot;, &quot;test&quot;, false);
1272 
1273         check(&quot;^....&quot;, flags2, &quot;test\ntest&quot;, &quot;test&quot;, true);
1274         check(&quot;....^&quot;, flags2, &quot;test\ntest&quot;, &quot;test&quot;, false);
1275         check(&quot;.....^&quot;, flags2, &quot;test\n&quot;, &quot;test&quot;, false);
1276         check(&quot;....^&quot;, flags2, &quot;test\r\n&quot;, &quot;test&quot;, false);
1277 
1278         check(&quot;^....&quot;, flags3, &quot;test\ntest&quot;, &quot;test&quot;, true);
1279         check(&quot;.....^&quot;, flags3, &quot;test\ntest&quot;, &quot;test\n&quot;, true);
1280         check(&quot;.....^&quot;, flags3, &quot;test\u0085test&quot;, &quot;test\u0085&quot;, false);
1281         check(&quot;.....^&quot;, flags3, &quot;test\n&quot;, &quot;test&quot;, false);
1282         check(&quot;.....^&quot;, flags3, &quot;test\r\n&quot;, &quot;test&quot;, false);
1283         check(&quot;......^&quot;, flags3, &quot;test\r\ntest&quot;, &quot;test\r\n&quot;, true);
1284 
1285         check(&quot;^....&quot;, flags4, &quot;test\ntest&quot;, &quot;test&quot;, true);
1286         check(&quot;.....^&quot;, flags3, &quot;test\ntest&quot;, &quot;test\n&quot;, true);
1287         check(&quot;.....^&quot;, flags4, &quot;test\u0085test&quot;, &quot;test\u0085&quot;, true);
1288         check(&quot;.....^&quot;, flags4, &quot;test\n&quot;, &quot;test\n&quot;, false);
1289         check(&quot;.....^&quot;, flags4, &quot;test\r\n&quot;, &quot;test\r&quot;, false);
1290 
1291         // Supplementary character test
1292         String t = toSupplementaries(&quot;test&quot;);
1293         check(&quot;^....&quot;, flags1, t+&quot;\n&quot;+t, t, true);
1294         check(&quot;.....^&quot;, flags1, t+&quot;\n&quot;+t, t, false);
1295         check(&quot;.....^&quot;, flags1, t+&quot;\n&quot;, t, false);
1296         check(&quot;....^&quot;, flags1, t+&quot;\r\n&quot;, t, false);
1297 
1298         check(&quot;^....&quot;, flags2, t+&quot;\n&quot;+t, t, true);
1299         check(&quot;....^&quot;, flags2, t+&quot;\n&quot;+t, t, false);
1300         check(&quot;.....^&quot;, flags2, t+&quot;\n&quot;, t, false);
1301         check(&quot;....^&quot;, flags2, t+&quot;\r\n&quot;, t, false);
1302 
1303         check(&quot;^....&quot;, flags3, t+&quot;\n&quot;+t, t, true);
1304         check(&quot;.....^&quot;, flags3, t+&quot;\n&quot;+t, t+&quot;\n&quot;, true);
1305         check(&quot;.....^&quot;, flags3, t+&quot;\u0085&quot;+t, t+&quot;\u0085&quot;, false);
1306         check(&quot;.....^&quot;, flags3, t+&quot;\n&quot;, t, false);
1307         check(&quot;.....^&quot;, flags3, t+&quot;\r\n&quot;, t, false);
1308         check(&quot;......^&quot;, flags3, t+&quot;\r\n&quot;+t, t+&quot;\r\n&quot;, true);
1309 
1310         check(&quot;^....&quot;, flags4, t+&quot;\n&quot;+t, t, true);
1311         check(&quot;.....^&quot;, flags3, t+&quot;\n&quot;+t, t+&quot;\n&quot;, true);
1312         check(&quot;.....^&quot;, flags4, t+&quot;\u0085&quot;+t, t+&quot;\u0085&quot;, true);
1313         check(&quot;.....^&quot;, flags4, t+&quot;\n&quot;, t+&quot;\n&quot;, false);
1314         check(&quot;.....^&quot;, flags4, t+&quot;\r\n&quot;, t+&quot;\r&quot;, false);
1315 
1316         report(&quot;Caret between terminators&quot;);
1317     }
1318 
1319     // This test is for 4727935
1320     private static void dollarAtEndTest() throws Exception {
1321         int flags1 = Pattern.DOTALL;
1322         int flags2 = Pattern.DOTALL | Pattern.UNIX_LINES;
1323         int flags3 = Pattern.DOTALL | Pattern.MULTILINE;
1324 
1325         check(&quot;....$&quot;, flags1, &quot;test\n&quot;, &quot;test&quot;, true);
1326         check(&quot;....$&quot;, flags1, &quot;test\r\n&quot;, &quot;test&quot;, true);
1327         check(&quot;.....$&quot;, flags1, &quot;test\n&quot;, &quot;test\n&quot;, true);
1328         check(&quot;.....$&quot;, flags1, &quot;test\u0085&quot;, &quot;test\u0085&quot;, true);
1329         check(&quot;....$&quot;, flags1, &quot;test\u0085&quot;, &quot;test&quot;, true);
1330 
1331         check(&quot;....$&quot;, flags2, &quot;test\n&quot;, &quot;test&quot;, true);
1332         check(&quot;.....$&quot;, flags2, &quot;test\n&quot;, &quot;test\n&quot;, true);
1333         check(&quot;.....$&quot;, flags2, &quot;test\u0085&quot;, &quot;test\u0085&quot;, true);
1334         check(&quot;....$&quot;, flags2, &quot;test\u0085&quot;, &quot;est\u0085&quot;, true);
1335 
1336         check(&quot;....$.blah&quot;, flags3, &quot;test\nblah&quot;, &quot;test\nblah&quot;, true);
1337         check(&quot;.....$.blah&quot;, flags3, &quot;test\n\nblah&quot;, &quot;test\n\nblah&quot;, true);
1338         check(&quot;....$blah&quot;, flags3, &quot;test\nblah&quot;, &quot;!!!!&quot;, false);
1339         check(&quot;.....$blah&quot;, flags3, &quot;test\nblah&quot;, &quot;!!!!&quot;, false);
1340 
1341         // Supplementary character test
1342         String t = toSupplementaries(&quot;test&quot;);
1343         String b = toSupplementaries(&quot;blah&quot;);
1344         check(&quot;....$&quot;, flags1, t+&quot;\n&quot;, t, true);
1345         check(&quot;....$&quot;, flags1, t+&quot;\r\n&quot;, t, true);
1346         check(&quot;.....$&quot;, flags1, t+&quot;\n&quot;, t+&quot;\n&quot;, true);
1347         check(&quot;.....$&quot;, flags1, t+&quot;\u0085&quot;, t+&quot;\u0085&quot;, true);
1348         check(&quot;....$&quot;, flags1, t+&quot;\u0085&quot;, t, true);
1349 
1350         check(&quot;....$&quot;, flags2, t+&quot;\n&quot;, t, true);
1351         check(&quot;.....$&quot;, flags2, t+&quot;\n&quot;, t+&quot;\n&quot;, true);
1352         check(&quot;.....$&quot;, flags2, t+&quot;\u0085&quot;, t+&quot;\u0085&quot;, true);
1353         check(&quot;....$&quot;, flags2, t+&quot;\u0085&quot;, toSupplementaries(&quot;est\u0085&quot;), true);
1354 
1355         check(&quot;....$.&quot;+b, flags3, t+&quot;\n&quot;+b, t+&quot;\n&quot;+b, true);
1356         check(&quot;.....$.&quot;+b, flags3, t+&quot;\n\n&quot;+b, t+&quot;\n\n&quot;+b, true);
1357         check(&quot;....$&quot;+b, flags3, t+&quot;\n&quot;+b, &quot;!!!!&quot;, false);
1358         check(&quot;.....$&quot;+b, flags3, t+&quot;\n&quot;+b, &quot;!!!!&quot;, false);
1359 
1360         report(&quot;Dollar at End&quot;);
1361     }
1362 
1363     // This test is for 4711773
1364     private static void multilineDollarTest() throws Exception {
1365         Pattern findCR = Pattern.compile(&quot;$&quot;, Pattern.MULTILINE);
1366         Matcher matcher = findCR.matcher(&quot;first bit\nsecond bit&quot;);
1367         matcher.find();
1368         if (matcher.start(0) != 9)
1369             failCount++;
1370         matcher.find();
1371         if (matcher.start(0) != 20)
1372             failCount++;
1373 
1374         // Supplementary character test
1375         matcher = findCR.matcher(toSupplementaries(&quot;first  bit\n second  bit&quot;)); // double BMP chars
1376         matcher.find();
1377         if (matcher.start(0) != 9*2)
1378             failCount++;
1379         matcher.find();
1380         if (matcher.start(0) != 20*2)
1381             failCount++;
1382 
1383         report(&quot;Multiline Dollar&quot;);
1384     }
1385 
1386     private static void reluctantRepetitionTest() throws Exception {
1387         Pattern p = Pattern.compile(&quot;1(\\s\\S+?){1,3}?[\\s,]2&quot;);
1388         check(p, &quot;1 word word word 2&quot;, true);
1389         check(p, &quot;1 wor wo w 2&quot;, true);
1390         check(p, &quot;1 word word 2&quot;, true);
1391         check(p, &quot;1 word 2&quot;, true);
1392         check(p, &quot;1 wo w w 2&quot;, true);
1393         check(p, &quot;1 wo w 2&quot;, true);
1394         check(p, &quot;1 wor w 2&quot;, true);
1395 
1396         p = Pattern.compile(&quot;([a-z])+?c&quot;);
1397         Matcher m = p.matcher(&quot;ababcdefdec&quot;);
1398         check(m, &quot;ababc&quot;);
1399 
1400         // Supplementary character test
1401         p = Pattern.compile(toSupplementaries(&quot;([a-z])+?c&quot;));
1402         m = p.matcher(toSupplementaries(&quot;ababcdefdec&quot;));
1403         check(m, toSupplementaries(&quot;ababc&quot;));
1404 
1405         report(&quot;Reluctant Repetition&quot;);
1406     }
1407 
1408     private static Pattern serializedPattern(Pattern p) throws Exception {
1409         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1410         ObjectOutputStream oos = new ObjectOutputStream(baos);
1411         oos.writeObject(p);
1412         oos.close();
1413         try (ObjectInputStream ois = new ObjectInputStream(
1414                 new ByteArrayInputStream(baos.toByteArray()))) {
1415             return (Pattern)ois.readObject();
1416         }
1417     }
1418 
1419     private static void serializeTest() throws Exception {
1420         String patternStr = &quot;(b)&quot;;
1421         String matchStr = &quot;b&quot;;
1422         Pattern pattern = Pattern.compile(patternStr);
1423         Pattern serializedPattern = serializedPattern(pattern);
1424         Matcher matcher = serializedPattern.matcher(matchStr);
1425         if (!matcher.matches())
1426             failCount++;
1427         if (matcher.groupCount() != 1)
1428             failCount++;
1429 
1430         pattern = Pattern.compile(&quot;a(?-i)b&quot;, Pattern.CASE_INSENSITIVE);
1431         serializedPattern = serializedPattern(pattern);
1432         if (!serializedPattern.matcher(&quot;Ab&quot;).matches())
1433             failCount++;
1434         if (serializedPattern.matcher(&quot;AB&quot;).matches())
1435             failCount++;
1436 
1437         report(&quot;Serialization&quot;);
1438     }
1439 
1440     private static void gTest() {
1441         Pattern pattern = Pattern.compile(&quot;\\G\\w&quot;);
1442         Matcher matcher = pattern.matcher(&quot;abc#x#x&quot;);
1443         matcher.find();
1444         matcher.find();
1445         matcher.find();
1446         if (matcher.find())
1447             failCount++;
1448 
1449         pattern = Pattern.compile(&quot;\\GA*&quot;);
1450         matcher = pattern.matcher(&quot;1A2AA3&quot;);
1451         matcher.find();
1452         if (matcher.find())
1453             failCount++;
1454 
1455         pattern = Pattern.compile(&quot;\\GA*&quot;);
1456         matcher = pattern.matcher(&quot;1A2AA3&quot;);
1457         if (!matcher.find(1))
1458             failCount++;
1459         matcher.find();
1460         if (matcher.find())
1461             failCount++;
1462 
1463         report(&quot;\\G&quot;);
1464     }
1465 
1466     private static void zTest() {
1467         Pattern pattern = Pattern.compile(&quot;foo\\Z&quot;);
1468         // Positives
1469         check(pattern, &quot;foo\u0085&quot;, true);
1470         check(pattern, &quot;foo\u2028&quot;, true);
1471         check(pattern, &quot;foo\u2029&quot;, true);
1472         check(pattern, &quot;foo\n&quot;, true);
1473         check(pattern, &quot;foo\r&quot;, true);
1474         check(pattern, &quot;foo\r\n&quot;, true);
1475         // Negatives
1476         check(pattern, &quot;fooo&quot;, false);
1477         check(pattern, &quot;foo\n\r&quot;, false);
1478 
1479         pattern = Pattern.compile(&quot;foo\\Z&quot;, Pattern.UNIX_LINES);
1480         // Positives
1481         check(pattern, &quot;foo&quot;, true);
1482         check(pattern, &quot;foo\n&quot;, true);
1483         // Negatives
1484         check(pattern, &quot;foo\r&quot;, false);
1485         check(pattern, &quot;foo\u0085&quot;, false);
1486         check(pattern, &quot;foo\u2028&quot;, false);
1487         check(pattern, &quot;foo\u2029&quot;, false);
1488 
1489         report(&quot;\\Z&quot;);
1490     }
1491 
1492     private static void replaceFirstTest() {
1493         Pattern pattern = Pattern.compile(&quot;(ab)(c*)&quot;);
1494         Matcher matcher = pattern.matcher(&quot;abccczzzabcczzzabccc&quot;);
1495         if (!matcher.replaceFirst(&quot;test&quot;).equals(&quot;testzzzabcczzzabccc&quot;))
1496             failCount++;
1497 
1498         matcher.reset(&quot;zzzabccczzzabcczzzabccczzz&quot;);
1499         if (!matcher.replaceFirst(&quot;test&quot;).equals(&quot;zzztestzzzabcczzzabccczzz&quot;))
1500             failCount++;
1501 
1502         matcher.reset(&quot;zzzabccczzzabcczzzabccczzz&quot;);
1503         String result = matcher.replaceFirst(&quot;$1&quot;);
1504         if (!result.equals(&quot;zzzabzzzabcczzzabccczzz&quot;))
1505             failCount++;
1506 
1507         matcher.reset(&quot;zzzabccczzzabcczzzabccczzz&quot;);
1508         result = matcher.replaceFirst(&quot;$2&quot;);
1509         if (!result.equals(&quot;zzzccczzzabcczzzabccczzz&quot;))
1510             failCount++;
1511 
1512         pattern = Pattern.compile(&quot;a*&quot;);
1513         matcher = pattern.matcher(&quot;aaaaaaaaaa&quot;);
1514         if (!matcher.replaceFirst(&quot;test&quot;).equals(&quot;test&quot;))
1515             failCount++;
1516 
1517         pattern = Pattern.compile(&quot;a+&quot;);
1518         matcher = pattern.matcher(&quot;zzzaaaaaaaaaa&quot;);
1519         if (!matcher.replaceFirst(&quot;test&quot;).equals(&quot;zzztest&quot;))
1520             failCount++;
1521 
1522         // Supplementary character test
1523         pattern = Pattern.compile(toSupplementaries(&quot;(ab)(c*)&quot;));
1524         matcher = pattern.matcher(toSupplementaries(&quot;abccczzzabcczzzabccc&quot;));
1525         if (!matcher.replaceFirst(toSupplementaries(&quot;test&quot;))
1526                 .equals(toSupplementaries(&quot;testzzzabcczzzabccc&quot;)))
1527             failCount++;
1528 
1529         matcher.reset(toSupplementaries(&quot;zzzabccczzzabcczzzabccczzz&quot;));
1530         if (!matcher.replaceFirst(toSupplementaries(&quot;test&quot;)).
1531             equals(toSupplementaries(&quot;zzztestzzzabcczzzabccczzz&quot;)))
1532             failCount++;
1533 
1534         matcher.reset(toSupplementaries(&quot;zzzabccczzzabcczzzabccczzz&quot;));
1535         result = matcher.replaceFirst(&quot;$1&quot;);
1536         if (!result.equals(toSupplementaries(&quot;zzzabzzzabcczzzabccczzz&quot;)))
1537             failCount++;
1538 
1539         matcher.reset(toSupplementaries(&quot;zzzabccczzzabcczzzabccczzz&quot;));
1540         result = matcher.replaceFirst(&quot;$2&quot;);
1541         if (!result.equals(toSupplementaries(&quot;zzzccczzzabcczzzabccczzz&quot;)))
1542             failCount++;
1543 
1544         pattern = Pattern.compile(toSupplementaries(&quot;a*&quot;));
1545         matcher = pattern.matcher(toSupplementaries(&quot;aaaaaaaaaa&quot;));
1546         if (!matcher.replaceFirst(toSupplementaries(&quot;test&quot;)).equals(toSupplementaries(&quot;test&quot;)))
1547             failCount++;
1548 
1549         pattern = Pattern.compile(toSupplementaries(&quot;a+&quot;));
1550         matcher = pattern.matcher(toSupplementaries(&quot;zzzaaaaaaaaaa&quot;));
1551         if (!matcher.replaceFirst(toSupplementaries(&quot;test&quot;)).equals(toSupplementaries(&quot;zzztest&quot;)))
1552             failCount++;
1553 
1554         report(&quot;Replace First&quot;);
1555     }
1556 
1557     private static void unixLinesTest() {
1558         Pattern pattern = Pattern.compile(&quot;.*&quot;);
1559         Matcher matcher = pattern.matcher(&quot;aa\u2028blah&quot;);
1560         matcher.find();
1561         if (!matcher.group(0).equals(&quot;aa&quot;))
1562             failCount++;
1563 
1564         pattern = Pattern.compile(&quot;.*&quot;, Pattern.UNIX_LINES);
1565         matcher = pattern.matcher(&quot;aa\u2028blah&quot;);
1566         matcher.find();
1567         if (!matcher.group(0).equals(&quot;aa\u2028blah&quot;))
1568             failCount++;
1569 
1570         pattern = Pattern.compile(&quot;[az]$&quot;,
1571                                   Pattern.MULTILINE | Pattern.UNIX_LINES);
1572         matcher = pattern.matcher(&quot;aa\u2028zz&quot;);
1573         check(matcher, &quot;a\u2028&quot;, false);
1574 
1575         // Supplementary character test
1576         pattern = Pattern.compile(&quot;.*&quot;);
1577         matcher = pattern.matcher(toSupplementaries(&quot;aa\u2028blah&quot;));
1578         matcher.find();
1579         if (!matcher.group(0).equals(toSupplementaries(&quot;aa&quot;)))
1580             failCount++;
1581 
1582         pattern = Pattern.compile(&quot;.*&quot;, Pattern.UNIX_LINES);
1583         matcher = pattern.matcher(toSupplementaries(&quot;aa\u2028blah&quot;));
1584         matcher.find();
1585         if (!matcher.group(0).equals(toSupplementaries(&quot;aa\u2028blah&quot;)))
1586             failCount++;
1587 
1588         pattern = Pattern.compile(toSupplementaries(&quot;[az]$&quot;),
1589                                   Pattern.MULTILINE | Pattern.UNIX_LINES);
1590         matcher = pattern.matcher(toSupplementaries(&quot;aa\u2028zz&quot;));
1591         check(matcher, toSupplementaries(&quot;a\u2028&quot;), false);
1592 
1593         report(&quot;Unix Lines&quot;);
1594     }
1595 
1596     private static void commentsTest() {
1597         int flags = Pattern.COMMENTS;
1598 
1599         Pattern pattern = Pattern.compile(&quot;aa \\# aa&quot;, flags);
1600         Matcher matcher = pattern.matcher(&quot;aa#aa&quot;);
1601         if (!matcher.matches())
1602             failCount++;
1603 
1604         pattern = Pattern.compile(&quot;aa  # blah&quot;, flags);
1605         matcher = pattern.matcher(&quot;aa&quot;);
1606         if (!matcher.matches())
1607             failCount++;
1608 
1609         pattern = Pattern.compile(&quot;aa blah&quot;, flags);
1610         matcher = pattern.matcher(&quot;aablah&quot;);
1611         if (!matcher.matches())
1612              failCount++;
1613 
1614         pattern = Pattern.compile(&quot;aa  # blah blech  &quot;, flags);
1615         matcher = pattern.matcher(&quot;aa&quot;);
1616         if (!matcher.matches())
1617             failCount++;
1618 
1619         pattern = Pattern.compile(&quot;aa  # blah\n  &quot;, flags);
1620         matcher = pattern.matcher(&quot;aa&quot;);
1621         if (!matcher.matches())
1622             failCount++;
1623 
1624         pattern = Pattern.compile(&quot;aa  # blah\nbc # blech&quot;, flags);
1625         matcher = pattern.matcher(&quot;aabc&quot;);
1626         if (!matcher.matches())
1627              failCount++;
1628 
1629         pattern = Pattern.compile(&quot;aa  # blah\nbc# blech&quot;, flags);
1630         matcher = pattern.matcher(&quot;aabc&quot;);
1631         if (!matcher.matches())
1632              failCount++;
1633 
1634         pattern = Pattern.compile(&quot;aa  # blah\nbc\\# blech&quot;, flags);
1635         matcher = pattern.matcher(&quot;aabc#blech&quot;);
1636         if (!matcher.matches())
1637              failCount++;
1638 
1639         // Supplementary character test
1640         pattern = Pattern.compile(toSupplementaries(&quot;aa \\# aa&quot;), flags);
1641         matcher = pattern.matcher(toSupplementaries(&quot;aa#aa&quot;));
1642         if (!matcher.matches())
1643             failCount++;
1644 
1645         pattern = Pattern.compile(toSupplementaries(&quot;aa  # blah&quot;), flags);
1646         matcher = pattern.matcher(toSupplementaries(&quot;aa&quot;));
1647         if (!matcher.matches())
1648             failCount++;
1649 
1650         pattern = Pattern.compile(toSupplementaries(&quot;aa blah&quot;), flags);
1651         matcher = pattern.matcher(toSupplementaries(&quot;aablah&quot;));
1652         if (!matcher.matches())
1653              failCount++;
1654 
1655         pattern = Pattern.compile(toSupplementaries(&quot;aa  # blah blech  &quot;), flags);
1656         matcher = pattern.matcher(toSupplementaries(&quot;aa&quot;));
1657         if (!matcher.matches())
1658             failCount++;
1659 
1660         pattern = Pattern.compile(toSupplementaries(&quot;aa  # blah\n  &quot;), flags);
1661         matcher = pattern.matcher(toSupplementaries(&quot;aa&quot;));
1662         if (!matcher.matches())
1663             failCount++;
1664 
1665         pattern = Pattern.compile(toSupplementaries(&quot;aa  # blah\nbc # blech&quot;), flags);
1666         matcher = pattern.matcher(toSupplementaries(&quot;aabc&quot;));
1667         if (!matcher.matches())
1668              failCount++;
1669 
1670         pattern = Pattern.compile(toSupplementaries(&quot;aa  # blah\nbc# blech&quot;), flags);
1671         matcher = pattern.matcher(toSupplementaries(&quot;aabc&quot;));
1672         if (!matcher.matches())
1673              failCount++;
1674 
1675         pattern = Pattern.compile(toSupplementaries(&quot;aa  # blah\nbc\\# blech&quot;), flags);
1676         matcher = pattern.matcher(toSupplementaries(&quot;aabc#blech&quot;));
1677         if (!matcher.matches())
1678              failCount++;
1679 
1680         report(&quot;Comments&quot;);
1681     }
1682 
1683     private static void caseFoldingTest() { // bug 4504687
1684         int flags = Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE;
1685         Pattern pattern = Pattern.compile(&quot;aa&quot;, flags);
1686         Matcher matcher = pattern.matcher(&quot;ab&quot;);
1687         if (matcher.matches())
1688             failCount++;
1689 
1690         pattern = Pattern.compile(&quot;aA&quot;, flags);
1691         matcher = pattern.matcher(&quot;ab&quot;);
1692         if (matcher.matches())
1693             failCount++;
1694 
1695         pattern = Pattern.compile(&quot;aa&quot;, flags);
1696         matcher = pattern.matcher(&quot;aB&quot;);
1697         if (matcher.matches())
1698             failCount++;
1699         matcher = pattern.matcher(&quot;Ab&quot;);
1700         if (matcher.matches())
1701             failCount++;
1702 
1703         // ASCII               &quot;a&quot;
1704         // Latin-1 Supplement  &quot;a&quot; + grave
1705         // Cyrillic            &quot;a&quot;
1706         String[] patterns = new String[] {
1707             //single
1708             &quot;a&quot;, &quot;\u00e0&quot;, &quot;\u0430&quot;,
1709             //slice
1710             &quot;ab&quot;, &quot;\u00e0\u00e1&quot;, &quot;\u0430\u0431&quot;,
1711             //class single
1712             &quot;[a]&quot;, &quot;[\u00e0]&quot;, &quot;[\u0430]&quot;,
1713             //class range
1714             &quot;[a-b]&quot;, &quot;[\u00e0-\u00e5]&quot;, &quot;[\u0430-\u0431]&quot;,
1715             //back reference
1716             &quot;(a)\\1&quot;, &quot;(\u00e0)\\1&quot;, &quot;(\u0430)\\1&quot;
1717         };
1718 
1719         String[] texts = new String[] {
1720             &quot;A&quot;, &quot;\u00c0&quot;, &quot;\u0410&quot;,
1721             &quot;AB&quot;, &quot;\u00c0\u00c1&quot;, &quot;\u0410\u0411&quot;,
1722             &quot;A&quot;, &quot;\u00c0&quot;, &quot;\u0410&quot;,
1723             &quot;B&quot;, &quot;\u00c2&quot;, &quot;\u0411&quot;,
1724             &quot;aA&quot;, &quot;\u00e0\u00c0&quot;, &quot;\u0430\u0410&quot;
1725         };
1726 
1727         boolean[] expected = new boolean[] {
1728             true, false, false,
1729             true, false, false,
1730             true, false, false,
1731             true, false, false,
1732             true, false, false
1733         };
1734 
1735         flags = Pattern.CASE_INSENSITIVE;
1736         for (int i = 0; i &lt; patterns.length; i++) {
1737             pattern = Pattern.compile(patterns[i], flags);
1738             matcher = pattern.matcher(texts[i]);
1739             if (matcher.matches() != expected[i]) {
1740                 System.out.println(&quot;&lt;1&gt; Failed at &quot; + i);
1741                 failCount++;
1742             }
1743         }
1744 
1745         flags = Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE;
1746         for (int i = 0; i &lt; patterns.length; i++) {
1747             pattern = Pattern.compile(patterns[i], flags);
1748             matcher = pattern.matcher(texts[i]);
1749             if (!matcher.matches()) {
1750                 System.out.println(&quot;&lt;2&gt; Failed at &quot; + i);
1751                 failCount++;
1752             }
1753         }
1754         // flag unicode_case alone should do nothing
1755         flags = Pattern.UNICODE_CASE;
1756         for (int i = 0; i &lt; patterns.length; i++) {
1757             pattern = Pattern.compile(patterns[i], flags);
1758             matcher = pattern.matcher(texts[i]);
1759             if (matcher.matches()) {
1760                 System.out.println(&quot;&lt;3&gt; Failed at &quot; + i);
1761                 failCount++;
1762             }
1763         }
1764 
1765         // Special cases: i, I, u+0131 and u+0130
1766         flags = Pattern.UNICODE_CASE | Pattern.CASE_INSENSITIVE;
1767         pattern = Pattern.compile(&quot;[h-j]+&quot;, flags);
1768         if (!pattern.matcher(&quot;\u0131\u0130&quot;).matches())
1769             failCount++;
1770         report(&quot;Case Folding&quot;);
1771     }
1772 
1773     private static void appendTest() {
1774         Pattern pattern = Pattern.compile(&quot;(ab)(cd)&quot;);
1775         Matcher matcher = pattern.matcher(&quot;abcd&quot;);
1776         String result = matcher.replaceAll(&quot;$2$1&quot;);
1777         if (!result.equals(&quot;cdab&quot;))
1778             failCount++;
1779 
1780         String  s1 = &quot;Swap all: first = 123, second = 456&quot;;
1781         String  s2 = &quot;Swap one: first = 123, second = 456&quot;;
1782         String  r  = &quot;$3$2$1&quot;;
1783         pattern = Pattern.compile(&quot;([a-z]+)( *= *)([0-9]+)&quot;);
1784         matcher = pattern.matcher(s1);
1785 
1786         result = matcher.replaceAll(r);
1787         if (!result.equals(&quot;Swap all: 123 = first, 456 = second&quot;))
1788             failCount++;
1789 
1790         matcher = pattern.matcher(s2);
1791 
1792         if (matcher.find()) {
1793             StringBuffer sb = new StringBuffer();
1794             matcher.appendReplacement(sb, r);
1795             matcher.appendTail(sb);
1796             result = sb.toString();
1797             if (!result.equals(&quot;Swap one: 123 = first, second = 456&quot;))
1798                 failCount++;
1799         }
1800 
1801         // Supplementary character test
1802         pattern = Pattern.compile(toSupplementaries(&quot;(ab)(cd)&quot;));
1803         matcher = pattern.matcher(toSupplementaries(&quot;abcd&quot;));
1804         result = matcher.replaceAll(&quot;$2$1&quot;);
1805         if (!result.equals(toSupplementaries(&quot;cdab&quot;)))
1806             failCount++;
1807 
1808         s1 = toSupplementaries(&quot;Swap all: first = 123, second = 456&quot;);
1809         s2 = toSupplementaries(&quot;Swap one: first = 123, second = 456&quot;);
1810         r  = toSupplementaries(&quot;$3$2$1&quot;);
1811         pattern = Pattern.compile(toSupplementaries(&quot;([a-z]+)( *= *)([0-9]+)&quot;));
1812         matcher = pattern.matcher(s1);
1813 
1814         result = matcher.replaceAll(r);
1815         if (!result.equals(toSupplementaries(&quot;Swap all: 123 = first, 456 = second&quot;)))
1816             failCount++;
1817 
1818         matcher = pattern.matcher(s2);
1819 
1820         if (matcher.find()) {
1821             StringBuffer sb = new StringBuffer();
1822             matcher.appendReplacement(sb, r);
1823             matcher.appendTail(sb);
1824             result = sb.toString();
1825             if (!result.equals(toSupplementaries(&quot;Swap one: 123 = first, second = 456&quot;)))
1826                 failCount++;
1827         }
1828         report(&quot;Append&quot;);
1829     }
1830 
1831     private static void splitTest() {
1832         Pattern pattern = Pattern.compile(&quot;:&quot;);
1833         String[] result = pattern.split(&quot;foo:and:boo&quot;, 2);
1834         if (!result[0].equals(&quot;foo&quot;))
1835             failCount++;
1836         if (!result[1].equals(&quot;and:boo&quot;))
1837             failCount++;
1838         // Supplementary character test
1839         Pattern patternX = Pattern.compile(toSupplementaries(&quot;X&quot;));
1840         result = patternX.split(toSupplementaries(&quot;fooXandXboo&quot;), 2);
1841         if (!result[0].equals(toSupplementaries(&quot;foo&quot;)))
1842             failCount++;
1843         if (!result[1].equals(toSupplementaries(&quot;andXboo&quot;)))
1844             failCount++;
1845 
1846         CharBuffer cb = CharBuffer.allocate(100);
1847         cb.put(&quot;foo:and:boo&quot;);
1848         cb.flip();
1849         result = pattern.split(cb);
1850         if (!result[0].equals(&quot;foo&quot;))
1851             failCount++;
1852         if (!result[1].equals(&quot;and&quot;))
1853             failCount++;
1854         if (!result[2].equals(&quot;boo&quot;))
1855             failCount++;
1856 
1857         // Supplementary character test
1858         CharBuffer cbs = CharBuffer.allocate(100);
1859         cbs.put(toSupplementaries(&quot;fooXandXboo&quot;));
1860         cbs.flip();
1861         result = patternX.split(cbs);
1862         if (!result[0].equals(toSupplementaries(&quot;foo&quot;)))
1863             failCount++;
1864         if (!result[1].equals(toSupplementaries(&quot;and&quot;)))
1865             failCount++;
1866         if (!result[2].equals(toSupplementaries(&quot;boo&quot;)))
1867             failCount++;
1868 
1869         String source = &quot;0123456789&quot;;
1870         for (int limit=-2; limit&lt;3; limit++) {
1871             for (int x=0; x&lt;10; x++) {
1872                 result = source.split(Integer.toString(x), limit);
1873                 int expectedLength = limit &lt; 1 ? 2 : limit;
1874 
1875                 if ((limit == 0) &amp;&amp; (x == 9)) {
1876                     // expected dropping of &quot;&quot;
1877                     if (result.length != 1)
1878                         failCount++;
1879                     if (!result[0].equals(&quot;012345678&quot;)) {
1880                         failCount++;
1881                     }
1882                 } else {
1883                     if (result.length != expectedLength) {
1884                         failCount++;
1885                     }
1886                     if (!result[0].equals(source.substring(0,x))) {
1887                         if (limit != 1) {
1888                             failCount++;
1889                         } else {
1890                             if (!result[0].equals(source.substring(0,10))) {
1891                                 failCount++;
1892                             }
1893                         }
1894                     }
1895                     if (expectedLength &gt; 1) { // Check segment 2
1896                         if (!result[1].equals(source.substring(x+1,10)))
1897                             failCount++;
1898                     }
1899                 }
1900             }
1901         }
1902         // Check the case for no match found
1903         for (int limit=-2; limit&lt;3; limit++) {
1904             result = source.split(&quot;e&quot;, limit);
1905             if (result.length != 1)
1906                 failCount++;
1907             if (!result[0].equals(source))
1908                 failCount++;
1909         }
1910         // Check the case for limit == 0, source = &quot;&quot;;
1911         // split() now returns 0-length for empty source &quot;&quot; see #6559590
1912         source = &quot;&quot;;
1913         result = source.split(&quot;e&quot;, 0);
1914         if (result.length != 1)
1915             failCount++;
1916         if (!result[0].equals(source))
1917             failCount++;
1918 
1919         // Check both split() and splitAsStraem(), especially for zero-lenth
1920         // input and zero-lenth match cases
1921         String[][] input = new String[][] {
1922             { &quot; &quot;,           &quot;Abc Efg Hij&quot; },   // normal non-zero-match
1923             { &quot; &quot;,           &quot; Abc Efg Hij&quot; },  // leading empty str for non-zero-match
1924             { &quot; &quot;,           &quot;Abc  Efg Hij&quot; },  // non-zero-match in the middle
1925             { &quot;(?=\\p{Lu})&quot;, &quot;AbcEfgHij&quot; },     // no leading empty str for zero-match
1926             { &quot;(?=\\p{Lu})&quot;, &quot;AbcEfg&quot; },
1927             { &quot;(?=\\p{Lu})&quot;, &quot;Abc&quot; },
1928             { &quot; &quot;,           &quot;&quot; },              // zero-length input
1929             { &quot;.*&quot;,          &quot;&quot; },
1930 
1931             // some tests from PatternStreamTest.java
1932             { &quot;4&quot;,       &quot;awgqwefg1fefw4vssv1vvv1&quot; },
1933             { &quot;\u00a3a&quot;, &quot;afbfq\u00a3abgwgb\u00a3awngnwggw\u00a3a\u00a3ahjrnhneerh&quot; },
1934             { &quot;1&quot;,       &quot;awgqwefg1fefw4vssv1vvv1&quot; },
1935             { &quot;1&quot;,       &quot;a\u4ebafg1fefw\u4eba4\u9f9cvssv\u9f9c1v\u672c\u672cvv&quot; },
1936             { &quot;\u56da&quot;,  &quot;1\u56da23\u56da456\u56da7890&quot; },
1937             { &quot;\u56da&quot;,  &quot;1\u56da23\u9f9c\u672c\u672c\u56da456\u56da\u9f9c\u672c7890&quot; },
1938             { &quot;\u56da&quot;,  &quot;&quot; },
1939             { &quot;[ \t,:.]&quot;,&quot;This is,testing: with\tdifferent separators.&quot; }, //multiple septs
1940             { &quot;o&quot;,       &quot;boo:and:foo&quot; },
1941             { &quot;o&quot;,       &quot;booooo:and:fooooo&quot; },
1942             { &quot;o&quot;,       &quot;fooooo:&quot; },
1943         };
1944 
1945         String[][] expected = new String[][] {
1946             { &quot;Abc&quot;, &quot;Efg&quot;, &quot;Hij&quot; },
1947             { &quot;&quot;, &quot;Abc&quot;, &quot;Efg&quot;, &quot;Hij&quot; },
1948             { &quot;Abc&quot;, &quot;&quot;, &quot;Efg&quot;, &quot;Hij&quot; },
1949             { &quot;Abc&quot;, &quot;Efg&quot;, &quot;Hij&quot; },
1950             { &quot;Abc&quot;, &quot;Efg&quot; },
1951             { &quot;Abc&quot; },
1952             { &quot;&quot; },
1953             { &quot;&quot; },
1954 
1955             { &quot;awgqwefg1fefw&quot;, &quot;vssv1vvv1&quot; },
1956             { &quot;afbfq&quot;, &quot;bgwgb&quot;, &quot;wngnwggw&quot;, &quot;&quot;, &quot;hjrnhneerh&quot; },
1957             { &quot;awgqwefg&quot;, &quot;fefw4vssv&quot;, &quot;vvv&quot; },
1958             { &quot;a\u4ebafg&quot;, &quot;fefw\u4eba4\u9f9cvssv\u9f9c&quot;, &quot;v\u672c\u672cvv&quot; },
1959             { &quot;1&quot;, &quot;23&quot;, &quot;456&quot;, &quot;7890&quot; },
1960             { &quot;1&quot;, &quot;23\u9f9c\u672c\u672c&quot;, &quot;456&quot;, &quot;\u9f9c\u672c7890&quot; },
1961             { &quot;&quot; },
1962             { &quot;This&quot;, &quot;is&quot;, &quot;testing&quot;, &quot;&quot;, &quot;with&quot;, &quot;different&quot;, &quot;separators&quot; },
1963             { &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot; },
1964             { &quot;b&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;:and:f&quot; },
1965             { &quot;f&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;:&quot; },
1966         };
1967         for (int i = 0; i &lt; input.length; i++) {
1968             pattern = Pattern.compile(input[i][0]);
1969             if (!Arrays.equals(pattern.split(input[i][1]), expected[i])) {
1970                 failCount++;
1971             }
1972             if (input[i][1].length() &gt; 0 &amp;&amp;  // splitAsStream() return empty resulting
1973                                              // array for zero-length input for now
1974                 !Arrays.equals(pattern.splitAsStream(input[i][1]).toArray(),
1975                                expected[i])) {
1976                 failCount++;
1977             }
1978         }
1979         report(&quot;Split&quot;);
1980     }
1981 
1982     private static void negationTest() {
1983         Pattern pattern = Pattern.compile(&quot;[\\[@^]+&quot;);
1984         Matcher matcher = pattern.matcher(&quot;@@@@[[[[^^^^&quot;);
1985         if (!matcher.find())
1986             failCount++;
1987         if (!matcher.group(0).equals(&quot;@@@@[[[[^^^^&quot;))
1988             failCount++;
1989         pattern = Pattern.compile(&quot;[@\\[^]+&quot;);
1990         matcher = pattern.matcher(&quot;@@@@[[[[^^^^&quot;);
1991         if (!matcher.find())
1992             failCount++;
1993         if (!matcher.group(0).equals(&quot;@@@@[[[[^^^^&quot;))
1994             failCount++;
1995         pattern = Pattern.compile(&quot;[@\\[^@]+&quot;);
1996         matcher = pattern.matcher(&quot;@@@@[[[[^^^^&quot;);
1997         if (!matcher.find())
1998             failCount++;
1999         if (!matcher.group(0).equals(&quot;@@@@[[[[^^^^&quot;))
2000             failCount++;
2001 
2002         pattern = Pattern.compile(&quot;\\)&quot;);
2003         matcher = pattern.matcher(&quot;xxx)xxx&quot;);
2004         if (!matcher.find())
2005             failCount++;
2006 
2007         report(&quot;Negation&quot;);
2008     }
2009 
2010     private static void ampersandTest() {
2011         Pattern pattern = Pattern.compile(&quot;[&amp;@]+&quot;);
2012         check(pattern, &quot;@@@@&amp;&amp;&amp;&amp;&quot;, true);
2013 
2014         pattern = Pattern.compile(&quot;[@&amp;]+&quot;);
2015         check(pattern, &quot;@@@@&amp;&amp;&amp;&amp;&quot;, true);
2016 
2017         pattern = Pattern.compile(&quot;[@\\&amp;]+&quot;);
2018         check(pattern, &quot;@@@@&amp;&amp;&amp;&amp;&quot;, true);
2019 
2020         report(&quot;Ampersand&quot;);
2021     }
2022 
2023     private static void octalTest() throws Exception {
2024         Pattern pattern = Pattern.compile(&quot;\\u0007&quot;);
2025         Matcher matcher = pattern.matcher(&quot;\u0007&quot;);
2026         if (!matcher.matches())
2027             failCount++;
2028         pattern = Pattern.compile(&quot;\\07&quot;);
2029         matcher = pattern.matcher(&quot;\u0007&quot;);
2030         if (!matcher.matches())
2031             failCount++;
2032         pattern = Pattern.compile(&quot;\\007&quot;);
2033         matcher = pattern.matcher(&quot;\u0007&quot;);
2034         if (!matcher.matches())
2035             failCount++;
2036         pattern = Pattern.compile(&quot;\\0007&quot;);
2037         matcher = pattern.matcher(&quot;\u0007&quot;);
2038         if (!matcher.matches())
2039             failCount++;
2040         pattern = Pattern.compile(&quot;\\040&quot;);
2041         matcher = pattern.matcher(&quot;\u0020&quot;);
2042         if (!matcher.matches())
2043             failCount++;
2044         pattern = Pattern.compile(&quot;\\0403&quot;);
2045         matcher = pattern.matcher(&quot;\u00203&quot;);
2046         if (!matcher.matches())
2047             failCount++;
2048         pattern = Pattern.compile(&quot;\\0103&quot;);
2049         matcher = pattern.matcher(&quot;\u0043&quot;);
2050         if (!matcher.matches())
2051             failCount++;
2052 
2053         report(&quot;Octal&quot;);
2054     }
2055 
2056     private static void longPatternTest() throws Exception {
2057         try {
2058             Pattern pattern = Pattern.compile(
2059                 &quot;a 32-character-long pattern xxxx&quot;);
2060             pattern = Pattern.compile(&quot;a 33-character-long pattern xxxxx&quot;);
2061             pattern = Pattern.compile(&quot;a thirty four character long regex&quot;);
2062             StringBuffer patternToBe = new StringBuffer(101);
2063             for (int i=0; i&lt;100; i++)
2064                 patternToBe.append((char)(97 + i%26));
2065             pattern = Pattern.compile(patternToBe.toString());
2066         } catch (PatternSyntaxException e) {
2067             failCount++;
2068         }
2069 
2070         // Supplementary character test
2071         try {
2072             Pattern pattern = Pattern.compile(
2073                 toSupplementaries(&quot;a 32-character-long pattern xxxx&quot;));
2074             pattern = Pattern.compile(toSupplementaries(&quot;a 33-character-long pattern xxxxx&quot;));
2075             pattern = Pattern.compile(toSupplementaries(&quot;a thirty four character long regex&quot;));
2076             StringBuffer patternToBe = new StringBuffer(101*2);
2077             for (int i=0; i&lt;100; i++)
2078                 patternToBe.append(Character.toChars(Character.MIN_SUPPLEMENTARY_CODE_POINT
2079                                                      + 97 + i%26));
2080             pattern = Pattern.compile(patternToBe.toString());
2081         } catch (PatternSyntaxException e) {
2082             failCount++;
2083         }
2084         report(&quot;LongPattern&quot;);
2085     }
2086 
2087     private static void group0Test() throws Exception {
2088         Pattern pattern = Pattern.compile(&quot;(tes)ting&quot;);
2089         Matcher matcher = pattern.matcher(&quot;testing&quot;);
2090         check(matcher, &quot;testing&quot;);
2091 
2092         matcher.reset(&quot;testing&quot;);
2093         if (matcher.lookingAt()) {
2094             if (!matcher.group(0).equals(&quot;testing&quot;))
2095                 failCount++;
2096         } else {
2097             failCount++;
2098         }
2099 
2100         matcher.reset(&quot;testing&quot;);
2101         if (matcher.matches()) {
2102             if (!matcher.group(0).equals(&quot;testing&quot;))
2103                 failCount++;
2104         } else {
2105             failCount++;
2106         }
2107 
2108         pattern = Pattern.compile(&quot;(tes)ting&quot;);
2109         matcher = pattern.matcher(&quot;testing&quot;);
2110         if (matcher.lookingAt()) {
2111             if (!matcher.group(0).equals(&quot;testing&quot;))
2112                 failCount++;
2113         } else {
2114             failCount++;
2115         }
2116 
2117         pattern = Pattern.compile(&quot;^(tes)ting&quot;);
2118         matcher = pattern.matcher(&quot;testing&quot;);
2119         if (matcher.matches()) {
2120             if (!matcher.group(0).equals(&quot;testing&quot;))
2121                 failCount++;
2122         } else {
2123             failCount++;
2124         }
2125 
2126         // Supplementary character test
2127         pattern = Pattern.compile(toSupplementaries(&quot;(tes)ting&quot;));
2128         matcher = pattern.matcher(toSupplementaries(&quot;testing&quot;));
2129         check(matcher, toSupplementaries(&quot;testing&quot;));
2130 
2131         matcher.reset(toSupplementaries(&quot;testing&quot;));
2132         if (matcher.lookingAt()) {
2133             if (!matcher.group(0).equals(toSupplementaries(&quot;testing&quot;)))
2134                 failCount++;
2135         } else {
2136             failCount++;
2137         }
2138 
2139         matcher.reset(toSupplementaries(&quot;testing&quot;));
2140         if (matcher.matches()) {
2141             if (!matcher.group(0).equals(toSupplementaries(&quot;testing&quot;)))
2142                 failCount++;
2143         } else {
2144             failCount++;
2145         }
2146 
2147         pattern = Pattern.compile(toSupplementaries(&quot;(tes)ting&quot;));
2148         matcher = pattern.matcher(toSupplementaries(&quot;testing&quot;));
2149         if (matcher.lookingAt()) {
2150             if (!matcher.group(0).equals(toSupplementaries(&quot;testing&quot;)))
2151                 failCount++;
2152         } else {
2153             failCount++;
2154         }
2155 
2156         pattern = Pattern.compile(toSupplementaries(&quot;^(tes)ting&quot;));
2157         matcher = pattern.matcher(toSupplementaries(&quot;testing&quot;));
2158         if (matcher.matches()) {
2159             if (!matcher.group(0).equals(toSupplementaries(&quot;testing&quot;)))
2160                 failCount++;
2161         } else {
2162             failCount++;
2163         }
2164 
2165         report(&quot;Group0&quot;);
2166     }
2167 
2168     private static void findIntTest() throws Exception {
2169         Pattern p = Pattern.compile(&quot;blah&quot;);
2170         Matcher m = p.matcher(&quot;zzzzblahzzzzzblah&quot;);
2171         boolean result = m.find(2);
2172         if (!result)
2173             failCount++;
2174 
2175         p = Pattern.compile(&quot;$&quot;);
2176         m = p.matcher(&quot;1234567890&quot;);
2177         result = m.find(10);
2178         if (!result)
2179             failCount++;
2180         try {
2181             result = m.find(11);
2182             failCount++;
2183         } catch (IndexOutOfBoundsException e) {
2184             // correct result
2185         }
2186 
2187         // Supplementary character test
2188         p = Pattern.compile(toSupplementaries(&quot;blah&quot;));
2189         m = p.matcher(toSupplementaries(&quot;zzzzblahzzzzzblah&quot;));
2190         result = m.find(2);
2191         if (!result)
2192             failCount++;
2193 
2194         report(&quot;FindInt&quot;);
2195     }
2196 
2197     private static void emptyPatternTest() throws Exception {
2198         Pattern p = Pattern.compile(&quot;&quot;);
2199         Matcher m = p.matcher(&quot;foo&quot;);
2200 
2201         // Should find empty pattern at beginning of input
2202         boolean result = m.find();
2203         if (result != true)
2204             failCount++;
2205         if (m.start() != 0)
2206             failCount++;
2207 
2208         // Should not match entire input if input is not empty
2209         m.reset();
2210         result = m.matches();
2211         if (result == true)
2212             failCount++;
2213 
2214         try {
2215             m.start(0);
2216             failCount++;
2217         } catch (IllegalStateException e) {
2218             // Correct result
2219         }
2220 
2221         // Should match entire input if input is empty
2222         m.reset(&quot;&quot;);
2223         result = m.matches();
2224         if (result != true)
2225             failCount++;
2226 
2227         result = Pattern.matches(&quot;&quot;, &quot;&quot;);
2228         if (result != true)
2229             failCount++;
2230 
2231         result = Pattern.matches(&quot;&quot;, &quot;foo&quot;);
2232         if (result == true)
2233             failCount++;
2234         report(&quot;EmptyPattern&quot;);
2235     }
2236 
2237     private static void charClassTest() throws Exception {
2238         Pattern pattern = Pattern.compile(&quot;blah[ab]]blech&quot;);
2239         check(pattern, &quot;blahb]blech&quot;, true);
2240 
2241         pattern = Pattern.compile(&quot;[abc[def]]&quot;);
2242         check(pattern, &quot;b&quot;, true);
2243 
2244         // Supplementary character tests
2245         pattern = Pattern.compile(toSupplementaries(&quot;blah[ab]]blech&quot;));
2246         check(pattern, toSupplementaries(&quot;blahb]blech&quot;), true);
2247 
2248         pattern = Pattern.compile(toSupplementaries(&quot;[abc[def]]&quot;));
2249         check(pattern, toSupplementaries(&quot;b&quot;), true);
2250 
2251         try {
2252             // u00ff when UNICODE_CASE
2253             pattern = Pattern.compile(&quot;[ab\u00ffcd]&quot;,
2254                                       Pattern.CASE_INSENSITIVE|
2255                                       Pattern.UNICODE_CASE);
2256             check(pattern, &quot;ab\u00ffcd&quot;, true);
2257             check(pattern, &quot;Ab\u0178Cd&quot;, true);
2258 
2259             // u00b5 when UNICODE_CASE
2260             pattern = Pattern.compile(&quot;[ab\u00b5cd]&quot;,
2261                                       Pattern.CASE_INSENSITIVE|
2262                                       Pattern.UNICODE_CASE);
2263             check(pattern, &quot;ab\u00b5cd&quot;, true);
2264             check(pattern, &quot;Ab\u039cCd&quot;, true);
2265         } catch (Exception e) { failCount++; }
2266 
2267         /* Special cases
2268            (1)LatinSmallLetterLongS u+017f
2269            (2)LatinSmallLetterDotlessI u+0131
2270            (3)LatineCapitalLetterIWithDotAbove u+0130
2271            (4)KelvinSign u+212a
2272            (5)AngstromSign u+212b
2273         */
2274         int flags = Pattern.UNICODE_CASE | Pattern.CASE_INSENSITIVE;
2275         pattern = Pattern.compile(&quot;[sik\u00c5]+&quot;, flags);
2276         if (!pattern.matcher(&quot;\u017f\u0130\u0131\u212a\u212b&quot;).matches())
2277             failCount++;
2278 
2279         report(&quot;CharClass&quot;);
2280     }
2281 
2282     private static void caretTest() throws Exception {
2283         Pattern pattern = Pattern.compile(&quot;\\w*&quot;);
2284         Matcher matcher = pattern.matcher(&quot;a#bc#def##g&quot;);
2285         check(matcher, &quot;a&quot;);
2286         check(matcher, &quot;&quot;);
2287         check(matcher, &quot;bc&quot;);
2288         check(matcher, &quot;&quot;);
2289         check(matcher, &quot;def&quot;);
2290         check(matcher, &quot;&quot;);
2291         check(matcher, &quot;&quot;);
2292         check(matcher, &quot;g&quot;);
2293         check(matcher, &quot;&quot;);
2294         if (matcher.find())
2295             failCount++;
2296 
2297         pattern = Pattern.compile(&quot;^\\w*&quot;);
2298         matcher = pattern.matcher(&quot;a#bc#def##g&quot;);
2299         check(matcher, &quot;a&quot;);
2300         if (matcher.find())
2301             failCount++;
2302 
2303         pattern = Pattern.compile(&quot;\\w&quot;);
2304         matcher = pattern.matcher(&quot;abc##x&quot;);
2305         check(matcher, &quot;a&quot;);
2306         check(matcher, &quot;b&quot;);
2307         check(matcher, &quot;c&quot;);
2308         check(matcher, &quot;x&quot;);
2309         if (matcher.find())
2310             failCount++;
2311 
2312         pattern = Pattern.compile(&quot;^\\w&quot;);
2313         matcher = pattern.matcher(&quot;abc##x&quot;);
2314         check(matcher, &quot;a&quot;);
2315         if (matcher.find())
2316             failCount++;
2317 
2318         pattern = Pattern.compile(&quot;\\A\\p{Alpha}{3}&quot;);
2319         matcher = pattern.matcher(&quot;abcdef-ghi\njklmno&quot;);
2320         check(matcher, &quot;abc&quot;);
2321         if (matcher.find())
2322             failCount++;
2323 
2324         pattern = Pattern.compile(&quot;^\\p{Alpha}{3}&quot;, Pattern.MULTILINE);
2325         matcher = pattern.matcher(&quot;abcdef-ghi\njklmno&quot;);
2326         check(matcher, &quot;abc&quot;);
2327         check(matcher, &quot;jkl&quot;);
2328         if (matcher.find())
2329             failCount++;
2330 
2331         pattern = Pattern.compile(&quot;^&quot;, Pattern.MULTILINE);
2332         matcher = pattern.matcher(&quot;this is some text&quot;);
2333         String result = matcher.replaceAll(&quot;X&quot;);
2334         if (!result.equals(&quot;Xthis is some text&quot;))
2335             failCount++;
2336 
2337         pattern = Pattern.compile(&quot;^&quot;);
2338         matcher = pattern.matcher(&quot;this is some text&quot;);
2339         result = matcher.replaceAll(&quot;X&quot;);
2340         if (!result.equals(&quot;Xthis is some text&quot;))
2341             failCount++;
2342 
2343         pattern = Pattern.compile(&quot;^&quot;, Pattern.MULTILINE | Pattern.UNIX_LINES);
2344         matcher = pattern.matcher(&quot;this is some text\n&quot;);
2345         result = matcher.replaceAll(&quot;X&quot;);
2346         if (!result.equals(&quot;Xthis is some text\n&quot;))
2347             failCount++;
2348 
2349         report(&quot;Caret&quot;);
2350     }
2351 
2352     private static void groupCaptureTest() throws Exception {
2353         // Independent group
2354         Pattern pattern = Pattern.compile(&quot;x+(?&gt;y+)z+&quot;);
2355         Matcher matcher = pattern.matcher(&quot;xxxyyyzzz&quot;);
2356         matcher.find();
2357         try {
2358             String blah = matcher.group(1);
2359             failCount++;
2360         } catch (IndexOutOfBoundsException ioobe) {
2361             // Good result
2362         }
2363         // Pure group
2364         pattern = Pattern.compile(&quot;x+(?:y+)z+&quot;);
2365         matcher = pattern.matcher(&quot;xxxyyyzzz&quot;);
2366         matcher.find();
2367         try {
2368             String blah = matcher.group(1);
2369             failCount++;
2370         } catch (IndexOutOfBoundsException ioobe) {
2371             // Good result
2372         }
2373 
2374         // Supplementary character tests
2375         // Independent group
2376         pattern = Pattern.compile(toSupplementaries(&quot;x+(?&gt;y+)z+&quot;));
2377         matcher = pattern.matcher(toSupplementaries(&quot;xxxyyyzzz&quot;));
2378         matcher.find();
2379         try {
2380             String blah = matcher.group(1);
2381             failCount++;
2382         } catch (IndexOutOfBoundsException ioobe) {
2383             // Good result
2384         }
2385         // Pure group
2386         pattern = Pattern.compile(toSupplementaries(&quot;x+(?:y+)z+&quot;));
2387         matcher = pattern.matcher(toSupplementaries(&quot;xxxyyyzzz&quot;));
2388         matcher.find();
2389         try {
2390             String blah = matcher.group(1);
2391             failCount++;
2392         } catch (IndexOutOfBoundsException ioobe) {
2393             // Good result
2394         }
2395 
2396         report(&quot;GroupCapture&quot;);
2397     }
2398 
2399     private static void backRefTest() throws Exception {
2400         Pattern pattern = Pattern.compile(&quot;(a*)bc\\1&quot;);
2401         check(pattern, &quot;zzzaabcazzz&quot;, true);
2402 
2403         pattern = Pattern.compile(&quot;(a*)bc\\1&quot;);
2404         check(pattern, &quot;zzzaabcaazzz&quot;, true);
2405 
2406         pattern = Pattern.compile(&quot;(abc)(def)\\1&quot;);
2407         check(pattern, &quot;abcdefabc&quot;, true);
2408 
2409         pattern = Pattern.compile(&quot;(abc)(def)\\3&quot;);
2410         check(pattern, &quot;abcdefabc&quot;, false);
2411 
2412         try {
2413             for (int i = 1; i &lt; 10; i++) {
2414                 // Make sure backref 1-9 are always accepted
2415                 pattern = Pattern.compile(&quot;abcdef\\&quot; + i);
2416                 // and fail to match if the target group does not exit
2417                 check(pattern, &quot;abcdef&quot;, false);
2418             }
2419         } catch(PatternSyntaxException e) {
2420             failCount++;
2421         }
2422 
2423         pattern = Pattern.compile(&quot;(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)\\11&quot;);
2424         check(pattern, &quot;abcdefghija&quot;, false);
2425         check(pattern, &quot;abcdefghija1&quot;, true);
2426 
2427         pattern = Pattern.compile(&quot;(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)\\11&quot;);
2428         check(pattern, &quot;abcdefghijkk&quot;, true);
2429 
2430         pattern = Pattern.compile(&quot;(a)bcdefghij\\11&quot;);
2431         check(pattern, &quot;abcdefghija1&quot;, true);
2432 
2433         // Supplementary character tests
2434         pattern = Pattern.compile(toSupplementaries(&quot;(a*)bc\\1&quot;));
2435         check(pattern, toSupplementaries(&quot;zzzaabcazzz&quot;), true);
2436 
2437         pattern = Pattern.compile(toSupplementaries(&quot;(a*)bc\\1&quot;));
2438         check(pattern, toSupplementaries(&quot;zzzaabcaazzz&quot;), true);
2439 
2440         pattern = Pattern.compile(toSupplementaries(&quot;(abc)(def)\\1&quot;));
2441         check(pattern, toSupplementaries(&quot;abcdefabc&quot;), true);
2442 
2443         pattern = Pattern.compile(toSupplementaries(&quot;(abc)(def)\\3&quot;));
2444         check(pattern, toSupplementaries(&quot;abcdefabc&quot;), false);
2445 
2446         pattern = Pattern.compile(toSupplementaries(&quot;(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)\\11&quot;));
2447         check(pattern, toSupplementaries(&quot;abcdefghija&quot;), false);
2448         check(pattern, toSupplementaries(&quot;abcdefghija1&quot;), true);
2449 
2450         pattern = Pattern.compile(toSupplementaries(&quot;(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)\\11&quot;));
2451         check(pattern, toSupplementaries(&quot;abcdefghijkk&quot;), true);
2452 
2453         report(&quot;BackRef&quot;);
2454     }
2455 
2456     /**
2457      * Unicode Technical Report #18, section 2.6 End of Line
2458      * There is no empty line to be matched in the sequence \u000D\u000A
2459      * but there is an empty line in the sequence \u000A\u000D.
2460      */
2461     private static void anchorTest() throws Exception {
2462         Pattern p = Pattern.compile(&quot;^.*$&quot;, Pattern.MULTILINE);
2463         Matcher m = p.matcher(&quot;blah1\r\nblah2&quot;);
2464         m.find();
2465         m.find();
2466         if (!m.group().equals(&quot;blah2&quot;))
2467             failCount++;
2468 
2469         m.reset(&quot;blah1\n\rblah2&quot;);
2470         m.find();
2471         m.find();
2472         m.find();
2473         if (!m.group().equals(&quot;blah2&quot;))
2474             failCount++;
2475 
2476         // Test behavior of $ with \r\n at end of input
2477         p = Pattern.compile(&quot;.+$&quot;);
2478         m = p.matcher(&quot;blah1\r\n&quot;);
2479         if (!m.find())
2480             failCount++;
2481        if (!m.group().equals(&quot;blah1&quot;))
2482             failCount++;
2483         if (m.find())
2484             failCount++;
2485 
2486         // Test behavior of $ with \r\n at end of input in multiline
2487         p = Pattern.compile(&quot;.+$&quot;, Pattern.MULTILINE);
2488         m = p.matcher(&quot;blah1\r\n&quot;);
2489         if (!m.find())
2490             failCount++;
2491         if (m.find())
2492             failCount++;
2493 
2494         // Test for $ recognition of \u0085 for bug 4527731
2495         p = Pattern.compile(&quot;.+$&quot;, Pattern.MULTILINE);
2496         m = p.matcher(&quot;blah1\u0085&quot;);
2497         if (!m.find())
2498             failCount++;
2499 
2500         // Supplementary character test
2501         p = Pattern.compile(&quot;^.*$&quot;, Pattern.MULTILINE);
2502         m = p.matcher(toSupplementaries(&quot;blah1\r\nblah2&quot;));
2503         m.find();
2504         m.find();
2505         if (!m.group().equals(toSupplementaries(&quot;blah2&quot;)))
2506             failCount++;
2507 
2508         m.reset(toSupplementaries(&quot;blah1\n\rblah2&quot;));
2509         m.find();
2510         m.find();
2511         m.find();
2512         if (!m.group().equals(toSupplementaries(&quot;blah2&quot;)))
2513             failCount++;
2514 
2515         // Test behavior of $ with \r\n at end of input
2516         p = Pattern.compile(&quot;.+$&quot;);
2517         m = p.matcher(toSupplementaries(&quot;blah1\r\n&quot;));
2518         if (!m.find())
2519             failCount++;
2520         if (!m.group().equals(toSupplementaries(&quot;blah1&quot;)))
2521             failCount++;
2522         if (m.find())
2523             failCount++;
2524 
2525         // Test behavior of $ with \r\n at end of input in multiline
2526         p = Pattern.compile(&quot;.+$&quot;, Pattern.MULTILINE);
2527         m = p.matcher(toSupplementaries(&quot;blah1\r\n&quot;));
2528         if (!m.find())
2529             failCount++;
2530         if (m.find())
2531             failCount++;
2532 
2533         // Test for $ recognition of \u0085 for bug 4527731
2534         p = Pattern.compile(&quot;.+$&quot;, Pattern.MULTILINE);
2535         m = p.matcher(toSupplementaries(&quot;blah1\u0085&quot;));
2536         if (!m.find())
2537             failCount++;
2538 
2539         report(&quot;Anchors&quot;);
2540     }
2541 
2542     /**
2543      * A basic sanity test of Matcher.lookingAt().
2544      */
2545     private static void lookingAtTest() throws Exception {
2546         Pattern p = Pattern.compile(&quot;(ab)(c*)&quot;);
2547         Matcher m = p.matcher(&quot;abccczzzabcczzzabccc&quot;);
2548 
2549         if (!m.lookingAt())
2550             failCount++;
2551 
2552         if (!m.group().equals(m.group(0)))
2553             failCount++;
2554 
2555         m = p.matcher(&quot;zzzabccczzzabcczzzabccczzz&quot;);
2556         if (m.lookingAt())
2557             failCount++;
2558 
2559         // Supplementary character test
2560         p = Pattern.compile(toSupplementaries(&quot;(ab)(c*)&quot;));
2561         m = p.matcher(toSupplementaries(&quot;abccczzzabcczzzabccc&quot;));
2562 
2563         if (!m.lookingAt())
2564             failCount++;
2565 
2566         if (!m.group().equals(m.group(0)))
2567             failCount++;
2568 
2569         m = p.matcher(toSupplementaries(&quot;zzzabccczzzabcczzzabccczzz&quot;));
2570         if (m.lookingAt())
2571             failCount++;
2572 
2573         report(&quot;Looking At&quot;);
2574     }
2575 
2576     /**
2577      * A basic sanity test of Matcher.matches().
2578      */
2579     private static void matchesTest() throws Exception {
2580         // matches()
2581         Pattern p = Pattern.compile(&quot;ulb(c*)&quot;);
2582         Matcher m = p.matcher(&quot;ulbcccccc&quot;);
2583         if (!m.matches())
2584             failCount++;
2585 
2586         // find() but not matches()
2587         m.reset(&quot;zzzulbcccccc&quot;);
2588         if (m.matches())
2589             failCount++;
2590 
2591         // lookingAt() but not matches()
2592         m.reset(&quot;ulbccccccdef&quot;);
2593         if (m.matches())
2594             failCount++;
2595 
2596         // matches()
2597         p = Pattern.compile(&quot;a|ad&quot;);
2598         m = p.matcher(&quot;ad&quot;);
2599         if (!m.matches())
2600             failCount++;
2601 
2602         // Supplementary character test
2603         // matches()
2604         p = Pattern.compile(toSupplementaries(&quot;ulb(c*)&quot;));
2605         m = p.matcher(toSupplementaries(&quot;ulbcccccc&quot;));
2606         if (!m.matches())
2607             failCount++;
2608 
2609         // find() but not matches()
2610         m.reset(toSupplementaries(&quot;zzzulbcccccc&quot;));
2611         if (m.matches())
2612             failCount++;
2613 
2614         // lookingAt() but not matches()
2615         m.reset(toSupplementaries(&quot;ulbccccccdef&quot;));
2616         if (m.matches())
2617             failCount++;
2618 
2619         // matches()
2620         p = Pattern.compile(toSupplementaries(&quot;a|ad&quot;));
2621         m = p.matcher(toSupplementaries(&quot;ad&quot;));
2622         if (!m.matches())
2623             failCount++;
2624 
2625         report(&quot;Matches&quot;);
2626     }
2627 
2628     /**
2629      * A basic sanity test of Pattern.matches().
2630      */
2631     private static void patternMatchesTest() throws Exception {
2632         // matches()
2633         if (!Pattern.matches(toSupplementaries(&quot;ulb(c*)&quot;),
2634                              toSupplementaries(&quot;ulbcccccc&quot;)))
2635             failCount++;
2636 
2637         // find() but not matches()
2638         if (Pattern.matches(toSupplementaries(&quot;ulb(c*)&quot;),
2639                             toSupplementaries(&quot;zzzulbcccccc&quot;)))
2640             failCount++;
2641 
2642         // lookingAt() but not matches()
2643         if (Pattern.matches(toSupplementaries(&quot;ulb(c*)&quot;),
2644                             toSupplementaries(&quot;ulbccccccdef&quot;)))
2645             failCount++;
2646 
2647         // Supplementary character test
2648         // matches()
2649         if (!Pattern.matches(toSupplementaries(&quot;ulb(c*)&quot;),
2650                              toSupplementaries(&quot;ulbcccccc&quot;)))
2651             failCount++;
2652 
2653         // find() but not matches()
2654         if (Pattern.matches(toSupplementaries(&quot;ulb(c*)&quot;),
2655                             toSupplementaries(&quot;zzzulbcccccc&quot;)))
2656             failCount++;
2657 
2658         // lookingAt() but not matches()
2659         if (Pattern.matches(toSupplementaries(&quot;ulb(c*)&quot;),
2660                             toSupplementaries(&quot;ulbccccccdef&quot;)))
2661             failCount++;
2662 
2663         report(&quot;Pattern Matches&quot;);
2664     }
2665 
2666     /**
2667      * Canonical equivalence testing. Tests the ability of the engine
2668      * to match sequences that are not explicitly specified in the
2669      * pattern when they are considered equivalent by the Unicode Standard.
2670      */
2671     private static void ceTest() throws Exception {
2672         // Decomposed char outside char classes
2673         Pattern p = Pattern.compile(&quot;testa\u030a&quot;, Pattern.CANON_EQ);
2674         Matcher m = p.matcher(&quot;test\u00e5&quot;);
2675         if (!m.matches())
2676             failCount++;
2677 
2678         m.reset(&quot;testa\u030a&quot;);
2679         if (!m.matches())
2680             failCount++;
2681 
2682         // Composed char outside char classes
2683         p = Pattern.compile(&quot;test\u00e5&quot;, Pattern.CANON_EQ);
2684         m = p.matcher(&quot;test\u00e5&quot;);
2685         if (!m.matches())
2686             failCount++;
2687 
2688         m.reset(&quot;testa\u030a&quot;);
2689         if (!m.find())
2690             failCount++;
2691 
2692         // Decomposed char inside a char class
2693         p = Pattern.compile(&quot;test[abca\u030a]&quot;, Pattern.CANON_EQ);
2694         m = p.matcher(&quot;test\u00e5&quot;);
2695         if (!m.find())
2696             failCount++;
2697 
2698         m.reset(&quot;testa\u030a&quot;);
2699         if (!m.find())
2700             failCount++;
2701 
2702         // Composed char inside a char class
2703         p = Pattern.compile(&quot;test[abc\u00e5def\u00e0]&quot;, Pattern.CANON_EQ);
2704         m = p.matcher(&quot;test\u00e5&quot;);
2705         if (!m.find())
2706             failCount++;
2707 
2708         m.reset(&quot;testa\u0300&quot;);
2709         if (!m.find())
2710             failCount++;
2711 
2712         m.reset(&quot;testa\u030a&quot;);
2713         if (!m.find())
2714             failCount++;
2715 
2716         // Marks that cannot legally change order and be equivalent
2717         p = Pattern.compile(&quot;testa\u0308\u0300&quot;, Pattern.CANON_EQ);
2718         check(p, &quot;testa\u0308\u0300&quot;, true);
2719         check(p, &quot;testa\u0300\u0308&quot;, false);
2720 
2721         // Marks that can legally change order and be equivalent
2722         p = Pattern.compile(&quot;testa\u0308\u0323&quot;, Pattern.CANON_EQ);
2723         check(p, &quot;testa\u0308\u0323&quot;, true);
2724         check(p, &quot;testa\u0323\u0308&quot;, true);
2725 
2726         // Test all equivalences of the sequence a\u0308\u0323\u0300
2727         p = Pattern.compile(&quot;testa\u0308\u0323\u0300&quot;, Pattern.CANON_EQ);
2728         check(p, &quot;testa\u0308\u0323\u0300&quot;, true);
2729         check(p, &quot;testa\u0323\u0308\u0300&quot;, true);
2730         check(p, &quot;testa\u0308\u0300\u0323&quot;, true);
2731         check(p, &quot;test\u00e4\u0323\u0300&quot;, true);
2732         check(p, &quot;test\u00e4\u0300\u0323&quot;, true);
2733 
2734         Object[][] data = new Object[][] {
2735 
2736         // JDK-4867170
2737         { &quot;[\u1f80-\u1f82]&quot;, &quot;ab\u1f80cd&quot;,             &quot;f&quot;, true },
2738         { &quot;[\u1f80-\u1f82]&quot;, &quot;ab\u1f81cd&quot;,             &quot;f&quot;, true },
2739         { &quot;[\u1f80-\u1f82]&quot;, &quot;ab\u1f82cd&quot;,             &quot;f&quot;, true },
2740         { &quot;[\u1f80-\u1f82]&quot;, &quot;ab\u03b1\u0314\u0345cd&quot;, &quot;f&quot;, true },
2741         { &quot;[\u1f80-\u1f82]&quot;, &quot;ab\u03b1\u0345\u0314cd&quot;, &quot;f&quot;, true },
2742         { &quot;[\u1f80-\u1f82]&quot;, &quot;ab\u1f01\u0345cd&quot;,       &quot;f&quot;, true },
2743         { &quot;[\u1f80-\u1f82]&quot;, &quot;ab\u1f00\u0345cd&quot;,       &quot;f&quot;, true },
2744 
2745         { &quot;\\p{IsGreek}&quot;,    &quot;ab\u1f80cd&quot;,             &quot;f&quot;, true },
2746         { &quot;\\p{IsGreek}&quot;,    &quot;ab\u1f81cd&quot;,             &quot;f&quot;, true },
2747         { &quot;\\p{IsGreek}&quot;,    &quot;ab\u1f82cd&quot;,             &quot;f&quot;, true },
2748         { &quot;\\p{IsGreek}&quot;,    &quot;ab\u03b1\u0314\u0345cd&quot;, &quot;f&quot;, true },
2749         { &quot;\\p{IsGreek}&quot;,    &quot;ab\u1f01\u0345cd&quot;,       &quot;f&quot;, true },
2750 
2751         // backtracking, force to match &quot;\u1f80&quot;, instead of \u1f82&quot;
2752         { &quot;ab\\p{IsGreek}\u0300cd&quot;, &quot;ab\u03b1\u0313\u0345\u0300cd&quot;, &quot;m&quot;, true },
2753 
2754         { &quot;[\\p{IsGreek}]&quot;,  &quot;\u03b1\u0314\u0345&quot;,     &quot;m&quot;, true },
2755         { &quot;\\p{IsGreek}&quot;,    &quot;\u03b1\u0314\u0345&quot;,     &quot;m&quot;, true },
2756 
2757         { &quot;[^\u1f80-\u1f82]&quot;,&quot;\u1f81&quot;,                 &quot;m&quot;, false },
2758         { &quot;[^\u1f80-\u1f82]&quot;,&quot;\u03b1\u0314\u0345&quot;,     &quot;m&quot;, false },
2759         { &quot;[^\u1f01\u0345]&quot;, &quot;\u1f81&quot;,                 &quot;f&quot;, false },
2760 
2761         { &quot;[^\u1f81]+&quot;,      &quot;\u1f80\u1f82&quot;,           &quot;f&quot;, true },
2762         { &quot;[\u1f80]&quot;,        &quot;ab\u1f80cd&quot;,             &quot;f&quot;, true },
2763         { &quot;\u1f80&quot;,          &quot;ab\u1f80cd&quot;,             &quot;f&quot;, true },
2764         { &quot;\u1f00\u0345\u0300&quot;,  &quot;\u1f82&quot;, &quot;m&quot;, true },
2765         { &quot;\u1f80&quot;,          &quot;-\u1f00\u0345\u0300-&quot;,   &quot;f&quot;, true },
2766         { &quot;\u1f82&quot;,          &quot;\u1f00\u0345\u0300&quot;,     &quot;m&quot;, true },
2767         { &quot;\u1f82&quot;,          &quot;\u1f80\u0300&quot;,           &quot;m&quot;, true },
2768 
2769         // JDK-7080302       # compile failed
2770         { &quot;a(\u0041\u0301\u0328)&quot;, &quot;a\u0041\u0301\u0328&quot;, &quot;m&quot;, true},
2771 
2772         // JDK-6728861, same cause as above one
2773         { &quot;\u00e9\u00e9n&quot;, &quot;e\u0301e\u0301n&quot;, &quot;m&quot;, true},
2774 
2775         // JDK-6995635
2776         { &quot;(\u00e9)&quot;, &quot;e\u0301&quot;, &quot;m&quot;, true },
2777 
2778         // JDK-6736245
2779         // intereting special case, nfc(u2add+u0338) -&gt; u2add+u0338) NOT u2adc
2780         { &quot;\u2ADC&quot;, &quot;\u2ADC&quot;, &quot;m&quot;, true},          // NFC
2781         { &quot;\u2ADC&quot;, &quot;\u2ADD\u0338&quot;, &quot;m&quot;, true},    // NFD
2782 
2783         //  4916384.
2784         // Decomposed hangul (jamos) works inside clazz
2785         { &quot;[\u1100\u1161]&quot;, &quot;\u1100\u1161&quot;, &quot;m&quot;, true},
2786         { &quot;[\u1100\u1161]&quot;, &quot;\uac00&quot;, &quot;m&quot;, true},
2787 
2788         { &quot;[\uac00]&quot;, &quot;\u1100\u1161&quot;, &quot;m&quot;, true},
2789         { &quot;[\uac00]&quot;, &quot;\uac00&quot;, &quot;m&quot;, true},
2790 
2791         // Decomposed hangul (jamos)
2792         { &quot;\u1100\u1161&quot;, &quot;\u1100\u1161&quot;, &quot;m&quot;, true},
2793         { &quot;\u1100\u1161&quot;, &quot;\uac00&quot;, &quot;m&quot;, true},
2794 
2795         // Composed hangul
2796         { &quot;\uac00&quot;,  &quot;\u1100\u1161&quot;, &quot;m&quot;, true },
2797         { &quot;\uac00&quot;,  &quot;\uac00&quot;, &quot;m&quot;, true },
2798 
2799         /* Need a NFDSlice to nfd the source to solve this issue
2800            u+1d1c0 -&gt; nfd: &lt;u+1d1ba&gt;&lt;u+1d165&gt;&lt;u+1d16f&gt;  -&gt; nfc: &lt;u+1d1ba&gt;&lt;u+1d165&gt;&lt;u+1d16f&gt;
2801            u+1d1bc -&gt; nfd: &lt;u+1d1ba&gt;&lt;u+1d165&gt;           -&gt; nfc: &lt;u+1d1ba&gt;&lt;u+1d165&gt;
2802            &lt;u+1d1bc&gt;&lt;u+1d16f&gt; -&gt; nfd: &lt;u+1d1ba&gt;&lt;u+1d165&gt;&lt;u+1d16f&gt; -&gt; nfc: &lt;u+1d1ba&gt;&lt;u+1d165&gt;&lt;u+1d16f&gt;
2803 
2804         // Decomposed supplementary outside char classes
2805         // { &quot;test\ud834\uddbc\ud834\udd6f&quot;, &quot;test\ud834\uddc0&quot;, &quot;m&quot;, true },
2806         // Composed supplementary outside char classes
2807         // { &quot;test\ud834\uddc0&quot;, &quot;test\ud834\uddbc\ud834\udd6f&quot;, &quot;m&quot;, true },
2808         */
2809         { &quot;test\ud834\uddbc\ud834\udd6f&quot;, &quot;test\ud834\uddbc\ud834\udd6f&quot;, &quot;m&quot;, true },
2810         { &quot;test\ud834\uddc0&quot;,             &quot;test\ud834\uddbc\ud834\udd6f&quot;, &quot;m&quot;, true },
2811 
2812         { &quot;test\ud834\uddc0&quot;,             &quot;test\ud834\uddc0&quot;,             &quot;m&quot;, true },
2813         { &quot;test\ud834\uddbc\ud834\udd6f&quot;, &quot;test\ud834\uddc0&quot;,             &quot;m&quot;, true },
2814         };
2815 
2816         int failCount = 0;
2817         for (Object[] d : data) {
2818             String pn = (String)d[0];
2819             String tt = (String)d[1];
2820             boolean isFind = &quot;f&quot;.equals(((String)d[2]));
2821             boolean expected = (boolean)d[3];
2822             boolean ret = isFind ? Pattern.compile(pn, Pattern.CANON_EQ).matcher(tt).find()
2823                                  : Pattern.compile(pn, Pattern.CANON_EQ).matcher(tt).matches();
2824             if (ret != expected) {
2825                 failCount++;
2826                 continue;
2827             }
2828         }
2829         report(&quot;Canonical Equivalence&quot;);
2830     }
2831 
2832     /**
2833      * A basic sanity test of Matcher.replaceAll().
2834      */
2835     private static void globalSubstitute() throws Exception {
2836         // Global substitution with a literal
2837         Pattern p = Pattern.compile(&quot;(ab)(c*)&quot;);
2838         Matcher m = p.matcher(&quot;abccczzzabcczzzabccc&quot;);
2839         if (!m.replaceAll(&quot;test&quot;).equals(&quot;testzzztestzzztest&quot;))
2840             failCount++;
2841 
2842         m.reset(&quot;zzzabccczzzabcczzzabccczzz&quot;);
2843         if (!m.replaceAll(&quot;test&quot;).equals(&quot;zzztestzzztestzzztestzzz&quot;))
2844             failCount++;
2845 
2846         // Global substitution with groups
2847         m.reset(&quot;zzzabccczzzabcczzzabccczzz&quot;);
2848         String result = m.replaceAll(&quot;$1&quot;);
2849         if (!result.equals(&quot;zzzabzzzabzzzabzzz&quot;))
2850             failCount++;
2851 
2852         // Supplementary character test
2853         // Global substitution with a literal
2854         p = Pattern.compile(toSupplementaries(&quot;(ab)(c*)&quot;));
2855         m = p.matcher(toSupplementaries(&quot;abccczzzabcczzzabccc&quot;));
2856         if (!m.replaceAll(toSupplementaries(&quot;test&quot;)).
2857             equals(toSupplementaries(&quot;testzzztestzzztest&quot;)))
2858             failCount++;
2859 
2860         m.reset(toSupplementaries(&quot;zzzabccczzzabcczzzabccczzz&quot;));
2861         if (!m.replaceAll(toSupplementaries(&quot;test&quot;)).
2862             equals(toSupplementaries(&quot;zzztestzzztestzzztestzzz&quot;)))
2863             failCount++;
2864 
2865         // Global substitution with groups
2866         m.reset(toSupplementaries(&quot;zzzabccczzzabcczzzabccczzz&quot;));
2867         result = m.replaceAll(&quot;$1&quot;);
2868         if (!result.equals(toSupplementaries(&quot;zzzabzzzabzzzabzzz&quot;)))
2869             failCount++;
2870 
2871         report(&quot;Global Substitution&quot;);
2872     }
2873 
2874     /**
2875      * Tests the usage of Matcher.appendReplacement() with literal
2876      * and group substitutions.
2877      */
2878     private static void stringbufferSubstitute() throws Exception {
2879         // SB substitution with literal
2880         String blah = &quot;zzzblahzzz&quot;;
2881         Pattern p = Pattern.compile(&quot;blah&quot;);
2882         Matcher m = p.matcher(blah);
2883         StringBuffer result = new StringBuffer();
2884         try {
2885             m.appendReplacement(result, &quot;blech&quot;);
2886             failCount++;
2887         } catch (IllegalStateException e) {
2888         }
2889         m.find();
2890         m.appendReplacement(result, &quot;blech&quot;);
2891         if (!result.toString().equals(&quot;zzzblech&quot;))
2892             failCount++;
2893 
2894         m.appendTail(result);
2895         if (!result.toString().equals(&quot;zzzblechzzz&quot;))
2896             failCount++;
2897 
2898         // SB substitution with groups
2899         blah = &quot;zzzabcdzzz&quot;;
2900         p = Pattern.compile(&quot;(ab)(cd)*&quot;);
2901         m = p.matcher(blah);
2902         result = new StringBuffer();
2903         try {
2904             m.appendReplacement(result, &quot;$1&quot;);
2905             failCount++;
2906         } catch (IllegalStateException e) {
2907         }
2908         m.find();
2909         m.appendReplacement(result, &quot;$1&quot;);
2910         if (!result.toString().equals(&quot;zzzab&quot;))
2911             failCount++;
2912 
2913         m.appendTail(result);
2914         if (!result.toString().equals(&quot;zzzabzzz&quot;))
2915             failCount++;
2916 
2917         // SB substitution with 3 groups
2918         blah = &quot;zzzabcdcdefzzz&quot;;
2919         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
2920         m = p.matcher(blah);
2921         result = new StringBuffer();
2922         try {
2923             m.appendReplacement(result, &quot;$1w$2w$3&quot;);
2924             failCount++;
2925         } catch (IllegalStateException e) {
2926         }
2927         m.find();
2928         m.appendReplacement(result, &quot;$1w$2w$3&quot;);
2929         if (!result.toString().equals(&quot;zzzabwcdwef&quot;))
2930             failCount++;
2931 
2932         m.appendTail(result);
2933         if (!result.toString().equals(&quot;zzzabwcdwefzzz&quot;))
2934             failCount++;
2935 
2936         // SB substitution with groups and three matches
2937         // skipping middle match
2938         blah = &quot;zzzabcdzzzabcddzzzabcdzzz&quot;;
2939         p = Pattern.compile(&quot;(ab)(cd*)&quot;);
2940         m = p.matcher(blah);
2941         result = new StringBuffer();
2942         try {
2943             m.appendReplacement(result, &quot;$1&quot;);
2944             failCount++;
2945         } catch (IllegalStateException e) {
2946         }
2947         m.find();
2948         m.appendReplacement(result, &quot;$1&quot;);
2949         if (!result.toString().equals(&quot;zzzab&quot;))
2950             failCount++;
2951 
2952         m.find();
2953         m.find();
2954         m.appendReplacement(result, &quot;$2&quot;);
2955         if (!result.toString().equals(&quot;zzzabzzzabcddzzzcd&quot;))
2956             failCount++;
2957 
2958         m.appendTail(result);
2959         if (!result.toString().equals(&quot;zzzabzzzabcddzzzcdzzz&quot;))
2960             failCount++;
2961 
2962         // Check to make sure escaped $ is ignored
2963         blah = &quot;zzzabcdcdefzzz&quot;;
2964         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
2965         m = p.matcher(blah);
2966         result = new StringBuffer();
2967         m.find();
2968         m.appendReplacement(result, &quot;$1w\\$2w$3&quot;);
2969         if (!result.toString().equals(&quot;zzzabw$2wef&quot;))
2970             failCount++;
2971 
2972         m.appendTail(result);
2973         if (!result.toString().equals(&quot;zzzabw$2wefzzz&quot;))
2974             failCount++;
2975 
2976         // Check to make sure a reference to nonexistent group causes error
2977         blah = &quot;zzzabcdcdefzzz&quot;;
2978         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
2979         m = p.matcher(blah);
2980         result = new StringBuffer();
2981         m.find();
2982         try {
2983             m.appendReplacement(result, &quot;$1w$5w$3&quot;);
2984             failCount++;
2985         } catch (IndexOutOfBoundsException ioobe) {
2986             // Correct result
2987         }
2988 
2989         // Check double digit group references
2990         blah = &quot;zzz123456789101112zzz&quot;;
2991         p = Pattern.compile(&quot;(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)&quot;);
2992         m = p.matcher(blah);
2993         result = new StringBuffer();
2994         m.find();
2995         m.appendReplacement(result, &quot;$1w$11w$3&quot;);
2996         if (!result.toString().equals(&quot;zzz1w11w3&quot;))
2997             failCount++;
2998 
2999         // Check to make sure it backs off $15 to $1 if only three groups
3000         blah = &quot;zzzabcdcdefzzz&quot;;
3001         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
3002         m = p.matcher(blah);
3003         result = new StringBuffer();
3004         m.find();
3005         m.appendReplacement(result, &quot;$1w$15w$3&quot;);
3006         if (!result.toString().equals(&quot;zzzabwab5wef&quot;))
3007             failCount++;
3008 
3009 
3010         // Supplementary character test
3011         // SB substitution with literal
3012         blah = toSupplementaries(&quot;zzzblahzzz&quot;);
3013         p = Pattern.compile(toSupplementaries(&quot;blah&quot;));
3014         m = p.matcher(blah);
3015         result = new StringBuffer();
3016         try {
3017             m.appendReplacement(result, toSupplementaries(&quot;blech&quot;));
3018             failCount++;
3019         } catch (IllegalStateException e) {
3020         }
3021         m.find();
3022         m.appendReplacement(result, toSupplementaries(&quot;blech&quot;));
3023         if (!result.toString().equals(toSupplementaries(&quot;zzzblech&quot;)))
3024             failCount++;
3025 
3026         m.appendTail(result);
3027         if (!result.toString().equals(toSupplementaries(&quot;zzzblechzzz&quot;)))
3028             failCount++;
3029 
3030         // SB substitution with groups
3031         blah = toSupplementaries(&quot;zzzabcdzzz&quot;);
3032         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*&quot;));
3033         m = p.matcher(blah);
3034         result = new StringBuffer();
3035         try {
3036             m.appendReplacement(result, &quot;$1&quot;);
3037             failCount++;
3038         } catch (IllegalStateException e) {
3039         }
3040         m.find();
3041         m.appendReplacement(result, &quot;$1&quot;);
3042         if (!result.toString().equals(toSupplementaries(&quot;zzzab&quot;)))
3043             failCount++;
3044 
3045         m.appendTail(result);
3046         if (!result.toString().equals(toSupplementaries(&quot;zzzabzzz&quot;)))
3047             failCount++;
3048 
3049         // SB substitution with 3 groups
3050         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3051         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3052         m = p.matcher(blah);
3053         result = new StringBuffer();
3054         try {
3055             m.appendReplacement(result, toSupplementaries(&quot;$1w$2w$3&quot;));
3056             failCount++;
3057         } catch (IllegalStateException e) {
3058         }
3059         m.find();
3060         m.appendReplacement(result, toSupplementaries(&quot;$1w$2w$3&quot;));
3061         if (!result.toString().equals(toSupplementaries(&quot;zzzabwcdwef&quot;)))
3062             failCount++;
3063 
3064         m.appendTail(result);
3065         if (!result.toString().equals(toSupplementaries(&quot;zzzabwcdwefzzz&quot;)))
3066             failCount++;
3067 
3068         // SB substitution with groups and three matches
3069         // skipping middle match
3070         blah = toSupplementaries(&quot;zzzabcdzzzabcddzzzabcdzzz&quot;);
3071         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd*)&quot;));
3072         m = p.matcher(blah);
3073         result = new StringBuffer();
3074         try {
3075             m.appendReplacement(result, &quot;$1&quot;);
3076             failCount++;
3077         } catch (IllegalStateException e) {
3078         }
3079         m.find();
3080         m.appendReplacement(result, &quot;$1&quot;);
3081         if (!result.toString().equals(toSupplementaries(&quot;zzzab&quot;)))
3082             failCount++;
3083 
3084         m.find();
3085         m.find();
3086         m.appendReplacement(result, &quot;$2&quot;);
3087         if (!result.toString().equals(toSupplementaries(&quot;zzzabzzzabcddzzzcd&quot;)))
3088             failCount++;
3089 
3090         m.appendTail(result);
3091         if (!result.toString().equals(toSupplementaries(&quot;zzzabzzzabcddzzzcdzzz&quot;)))
3092             failCount++;
3093 
3094         // Check to make sure escaped $ is ignored
3095         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3096         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3097         m = p.matcher(blah);
3098         result = new StringBuffer();
3099         m.find();
3100         m.appendReplacement(result, toSupplementaries(&quot;$1w\\$2w$3&quot;));
3101         if (!result.toString().equals(toSupplementaries(&quot;zzzabw$2wef&quot;)))
3102             failCount++;
3103 
3104         m.appendTail(result);
3105         if (!result.toString().equals(toSupplementaries(&quot;zzzabw$2wefzzz&quot;)))
3106             failCount++;
3107 
3108         // Check to make sure a reference to nonexistent group causes error
3109         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3110         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3111         m = p.matcher(blah);
3112         result = new StringBuffer();
3113         m.find();
3114         try {
3115             m.appendReplacement(result, toSupplementaries(&quot;$1w$5w$3&quot;));
3116             failCount++;
3117         } catch (IndexOutOfBoundsException ioobe) {
3118             // Correct result
3119         }
3120 
3121         // Check double digit group references
3122         blah = toSupplementaries(&quot;zzz123456789101112zzz&quot;);
3123         p = Pattern.compile(&quot;(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)&quot;);
3124         m = p.matcher(blah);
3125         result = new StringBuffer();
3126         m.find();
3127         m.appendReplacement(result, toSupplementaries(&quot;$1w$11w$3&quot;));
3128         if (!result.toString().equals(toSupplementaries(&quot;zzz1w11w3&quot;)))
3129             failCount++;
3130 
3131         // Check to make sure it backs off $15 to $1 if only three groups
3132         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3133         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3134         m = p.matcher(blah);
3135         result = new StringBuffer();
3136         m.find();
3137         m.appendReplacement(result, toSupplementaries(&quot;$1w$15w$3&quot;));
3138         if (!result.toString().equals(toSupplementaries(&quot;zzzabwab5wef&quot;)))
3139             failCount++;
3140 
3141         // Check nothing has been appended into the output buffer if
3142         // the replacement string triggers IllegalArgumentException.
3143         p = Pattern.compile(&quot;(abc)&quot;);
3144         m = p.matcher(&quot;abcd&quot;);
3145         result = new StringBuffer();
3146         m.find();
3147         try {
3148             m.appendReplacement(result, (&quot;xyz$g&quot;));
3149             failCount++;
3150         } catch (IllegalArgumentException iae) {
3151             if (result.length() != 0)
3152                 failCount++;
3153         }
3154 
3155         report(&quot;SB Substitution&quot;);
3156     }
3157 
3158     /**
3159      * Tests the usage of Matcher.appendReplacement() with literal
3160      * and group substitutions.
3161      */
3162     private static void stringbuilderSubstitute() throws Exception {
3163         // SB substitution with literal
3164         String blah = &quot;zzzblahzzz&quot;;
3165         Pattern p = Pattern.compile(&quot;blah&quot;);
3166         Matcher m = p.matcher(blah);
3167         StringBuilder result = new StringBuilder();
3168         try {
3169             m.appendReplacement(result, &quot;blech&quot;);
3170             failCount++;
3171         } catch (IllegalStateException e) {
3172         }
3173         m.find();
3174         m.appendReplacement(result, &quot;blech&quot;);
3175         if (!result.toString().equals(&quot;zzzblech&quot;))
3176             failCount++;
3177 
3178         m.appendTail(result);
3179         if (!result.toString().equals(&quot;zzzblechzzz&quot;))
3180             failCount++;
3181 
3182         // SB substitution with groups
3183         blah = &quot;zzzabcdzzz&quot;;
3184         p = Pattern.compile(&quot;(ab)(cd)*&quot;);
3185         m = p.matcher(blah);
3186         result = new StringBuilder();
3187         try {
3188             m.appendReplacement(result, &quot;$1&quot;);
3189             failCount++;
3190         } catch (IllegalStateException e) {
3191         }
3192         m.find();
3193         m.appendReplacement(result, &quot;$1&quot;);
3194         if (!result.toString().equals(&quot;zzzab&quot;))
3195             failCount++;
3196 
3197         m.appendTail(result);
3198         if (!result.toString().equals(&quot;zzzabzzz&quot;))
3199             failCount++;
3200 
3201         // SB substitution with 3 groups
3202         blah = &quot;zzzabcdcdefzzz&quot;;
3203         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
3204         m = p.matcher(blah);
3205         result = new StringBuilder();
3206         try {
3207             m.appendReplacement(result, &quot;$1w$2w$3&quot;);
3208             failCount++;
3209         } catch (IllegalStateException e) {
3210         }
3211         m.find();
3212         m.appendReplacement(result, &quot;$1w$2w$3&quot;);
3213         if (!result.toString().equals(&quot;zzzabwcdwef&quot;))
3214             failCount++;
3215 
3216         m.appendTail(result);
3217         if (!result.toString().equals(&quot;zzzabwcdwefzzz&quot;))
3218             failCount++;
3219 
3220         // SB substitution with groups and three matches
3221         // skipping middle match
3222         blah = &quot;zzzabcdzzzabcddzzzabcdzzz&quot;;
3223         p = Pattern.compile(&quot;(ab)(cd*)&quot;);
3224         m = p.matcher(blah);
3225         result = new StringBuilder();
3226         try {
3227             m.appendReplacement(result, &quot;$1&quot;);
3228             failCount++;
3229         } catch (IllegalStateException e) {
3230         }
3231         m.find();
3232         m.appendReplacement(result, &quot;$1&quot;);
3233         if (!result.toString().equals(&quot;zzzab&quot;))
3234             failCount++;
3235 
3236         m.find();
3237         m.find();
3238         m.appendReplacement(result, &quot;$2&quot;);
3239         if (!result.toString().equals(&quot;zzzabzzzabcddzzzcd&quot;))
3240             failCount++;
3241 
3242         m.appendTail(result);
3243         if (!result.toString().equals(&quot;zzzabzzzabcddzzzcdzzz&quot;))
3244             failCount++;
3245 
3246         // Check to make sure escaped $ is ignored
3247         blah = &quot;zzzabcdcdefzzz&quot;;
3248         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
3249         m = p.matcher(blah);
3250         result = new StringBuilder();
3251         m.find();
3252         m.appendReplacement(result, &quot;$1w\\$2w$3&quot;);
3253         if (!result.toString().equals(&quot;zzzabw$2wef&quot;))
3254             failCount++;
3255 
3256         m.appendTail(result);
3257         if (!result.toString().equals(&quot;zzzabw$2wefzzz&quot;))
3258             failCount++;
3259 
3260         // Check to make sure a reference to nonexistent group causes error
3261         blah = &quot;zzzabcdcdefzzz&quot;;
3262         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
3263         m = p.matcher(blah);
3264         result = new StringBuilder();
3265         m.find();
3266         try {
3267             m.appendReplacement(result, &quot;$1w$5w$3&quot;);
3268             failCount++;
3269         } catch (IndexOutOfBoundsException ioobe) {
3270             // Correct result
3271         }
3272 
3273         // Check double digit group references
3274         blah = &quot;zzz123456789101112zzz&quot;;
3275         p = Pattern.compile(&quot;(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)&quot;);
3276         m = p.matcher(blah);
3277         result = new StringBuilder();
3278         m.find();
3279         m.appendReplacement(result, &quot;$1w$11w$3&quot;);
3280         if (!result.toString().equals(&quot;zzz1w11w3&quot;))
3281             failCount++;
3282 
3283         // Check to make sure it backs off $15 to $1 if only three groups
3284         blah = &quot;zzzabcdcdefzzz&quot;;
3285         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
3286         m = p.matcher(blah);
3287         result = new StringBuilder();
3288         m.find();
3289         m.appendReplacement(result, &quot;$1w$15w$3&quot;);
3290         if (!result.toString().equals(&quot;zzzabwab5wef&quot;))
3291             failCount++;
3292 
3293 
3294         // Supplementary character test
3295         // SB substitution with literal
3296         blah = toSupplementaries(&quot;zzzblahzzz&quot;);
3297         p = Pattern.compile(toSupplementaries(&quot;blah&quot;));
3298         m = p.matcher(blah);
3299         result = new StringBuilder();
3300         try {
3301             m.appendReplacement(result, toSupplementaries(&quot;blech&quot;));
3302             failCount++;
3303         } catch (IllegalStateException e) {
3304         }
3305         m.find();
3306         m.appendReplacement(result, toSupplementaries(&quot;blech&quot;));
3307         if (!result.toString().equals(toSupplementaries(&quot;zzzblech&quot;)))
3308             failCount++;
3309         m.appendTail(result);
3310         if (!result.toString().equals(toSupplementaries(&quot;zzzblechzzz&quot;)))
3311             failCount++;
3312 
3313         // SB substitution with groups
3314         blah = toSupplementaries(&quot;zzzabcdzzz&quot;);
3315         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*&quot;));
3316         m = p.matcher(blah);
3317         result = new StringBuilder();
3318         try {
3319             m.appendReplacement(result, &quot;$1&quot;);
3320             failCount++;
3321         } catch (IllegalStateException e) {
3322         }
3323         m.find();
3324         m.appendReplacement(result, &quot;$1&quot;);
3325         if (!result.toString().equals(toSupplementaries(&quot;zzzab&quot;)))
3326             failCount++;
3327 
3328         m.appendTail(result);
3329         if (!result.toString().equals(toSupplementaries(&quot;zzzabzzz&quot;)))
3330             failCount++;
3331 
3332         // SB substitution with 3 groups
3333         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3334         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3335         m = p.matcher(blah);
3336         result = new StringBuilder();
3337         try {
3338             m.appendReplacement(result, toSupplementaries(&quot;$1w$2w$3&quot;));
3339             failCount++;
3340         } catch (IllegalStateException e) {
3341         }
3342         m.find();
3343         m.appendReplacement(result, toSupplementaries(&quot;$1w$2w$3&quot;));
3344         if (!result.toString().equals(toSupplementaries(&quot;zzzabwcdwef&quot;)))
3345             failCount++;
3346 
3347         m.appendTail(result);
3348         if (!result.toString().equals(toSupplementaries(&quot;zzzabwcdwefzzz&quot;)))
3349             failCount++;
3350 
3351         // SB substitution with groups and three matches
3352         // skipping middle match
3353         blah = toSupplementaries(&quot;zzzabcdzzzabcddzzzabcdzzz&quot;);
3354         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd*)&quot;));
3355         m = p.matcher(blah);
3356         result = new StringBuilder();
3357         try {
3358             m.appendReplacement(result, &quot;$1&quot;);
3359             failCount++;
3360         } catch (IllegalStateException e) {
3361         }
3362         m.find();
3363         m.appendReplacement(result, &quot;$1&quot;);
3364         if (!result.toString().equals(toSupplementaries(&quot;zzzab&quot;)))
3365             failCount++;
3366 
3367         m.find();
3368         m.find();
3369         m.appendReplacement(result, &quot;$2&quot;);
3370         if (!result.toString().equals(toSupplementaries(&quot;zzzabzzzabcddzzzcd&quot;)))
3371             failCount++;
3372 
3373         m.appendTail(result);
3374         if (!result.toString().equals(toSupplementaries(&quot;zzzabzzzabcddzzzcdzzz&quot;)))
3375             failCount++;
3376 
3377         // Check to make sure escaped $ is ignored
3378         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3379         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3380         m = p.matcher(blah);
3381         result = new StringBuilder();
3382         m.find();
3383         m.appendReplacement(result, toSupplementaries(&quot;$1w\\$2w$3&quot;));
3384         if (!result.toString().equals(toSupplementaries(&quot;zzzabw$2wef&quot;)))
3385             failCount++;
3386 
3387         m.appendTail(result);
3388         if (!result.toString().equals(toSupplementaries(&quot;zzzabw$2wefzzz&quot;)))
3389             failCount++;
3390 
3391         // Check to make sure a reference to nonexistent group causes error
3392         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3393         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3394         m = p.matcher(blah);
3395         result = new StringBuilder();
3396         m.find();
3397         try {
3398             m.appendReplacement(result, toSupplementaries(&quot;$1w$5w$3&quot;));
3399             failCount++;
3400         } catch (IndexOutOfBoundsException ioobe) {
3401             // Correct result
3402         }
3403         // Check double digit group references
3404         blah = toSupplementaries(&quot;zzz123456789101112zzz&quot;);
3405         p = Pattern.compile(&quot;(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)&quot;);
3406         m = p.matcher(blah);
3407         result = new StringBuilder();
3408         m.find();
3409         m.appendReplacement(result, toSupplementaries(&quot;$1w$11w$3&quot;));
3410         if (!result.toString().equals(toSupplementaries(&quot;zzz1w11w3&quot;)))
3411             failCount++;
3412 
3413         // Check to make sure it backs off $15 to $1 if only three groups
3414         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3415         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3416         m = p.matcher(blah);
3417         result = new StringBuilder();
3418         m.find();
3419         m.appendReplacement(result, toSupplementaries(&quot;$1w$15w$3&quot;));
3420         if (!result.toString().equals(toSupplementaries(&quot;zzzabwab5wef&quot;)))
3421             failCount++;
3422         // Check nothing has been appended into the output buffer if
3423         // the replacement string triggers IllegalArgumentException.
3424         p = Pattern.compile(&quot;(abc)&quot;);
3425         m = p.matcher(&quot;abcd&quot;);
3426         result = new StringBuilder();
3427         m.find();
3428         try {
3429             m.appendReplacement(result, (&quot;xyz$g&quot;));
3430             failCount++;
3431         } catch (IllegalArgumentException iae) {
3432             if (result.length() != 0)
3433                 failCount++;
3434         }
3435         report(&quot;SB Substitution 2&quot;);
3436     }
3437 
3438     /*
3439      * 5 groups of characters are created to make a substitution string.
3440      * A base string will be created including random lead chars, the
3441      * substitution string, and random trailing chars.
3442      * A pattern containing the 5 groups is searched for and replaced with:
3443      * random group + random string + random group.
3444      * The results are checked for correctness.
3445      */
3446     private static void substitutionBasher() {
3447         for (int runs = 0; runs&lt;1000; runs++) {
3448             // Create a base string to work in
3449             int leadingChars = generator.nextInt(10);
3450             StringBuffer baseBuffer = new StringBuffer(100);
3451             String leadingString = getRandomAlphaString(leadingChars);
3452             baseBuffer.append(leadingString);
3453 
3454             // Create 5 groups of random number of random chars
3455             // Create the string to substitute
3456             // Create the pattern string to search for
3457             StringBuffer bufferToSub = new StringBuffer(25);
3458             StringBuffer bufferToPat = new StringBuffer(50);
3459             String[] groups = new String[5];
3460             for(int i=0; i&lt;5; i++) {
3461                 int aGroupSize = generator.nextInt(5)+1;
3462                 groups[i] = getRandomAlphaString(aGroupSize);
3463                 bufferToSub.append(groups[i]);
3464                 bufferToPat.append(&#39;(&#39;);
3465                 bufferToPat.append(groups[i]);
3466                 bufferToPat.append(&#39;)&#39;);
3467             }
3468             String stringToSub = bufferToSub.toString();
3469             String pattern = bufferToPat.toString();
3470 
3471             // Place sub string into working string at random index
3472             baseBuffer.append(stringToSub);
3473 
3474             // Append random chars to end
3475             int trailingChars = generator.nextInt(10);
3476             String trailingString = getRandomAlphaString(trailingChars);
3477             baseBuffer.append(trailingString);
3478             String baseString = baseBuffer.toString();
3479 
3480             // Create test pattern and matcher
3481             Pattern p = Pattern.compile(pattern);
3482             Matcher m = p.matcher(baseString);
3483 
3484             // Reject candidate if pattern happens to start early
3485             m.find();
3486             if (m.start() &lt; leadingChars)
3487                 continue;
3488 
3489             // Reject candidate if more than one match
3490             if (m.find())
3491                 continue;
3492 
3493             // Construct a replacement string with :
3494             // random group + random string + random group
3495             StringBuffer bufferToRep = new StringBuffer();
3496             int groupIndex1 = generator.nextInt(5);
3497             bufferToRep.append(&quot;$&quot; + (groupIndex1 + 1));
3498             String randomMidString = getRandomAlphaString(5);
3499             bufferToRep.append(randomMidString);
3500             int groupIndex2 = generator.nextInt(5);
3501             bufferToRep.append(&quot;$&quot; + (groupIndex2 + 1));
3502             String replacement = bufferToRep.toString();
3503 
3504             // Do the replacement
3505             String result = m.replaceAll(replacement);
3506 
3507             // Construct expected result
3508             StringBuffer bufferToRes = new StringBuffer();
3509             bufferToRes.append(leadingString);
3510             bufferToRes.append(groups[groupIndex1]);
3511             bufferToRes.append(randomMidString);
3512             bufferToRes.append(groups[groupIndex2]);
3513             bufferToRes.append(trailingString);
3514             String expectedResult = bufferToRes.toString();
3515 
3516             // Check results
3517             if (!result.equals(expectedResult))
3518                 failCount++;
3519         }
3520 
3521         report(&quot;Substitution Basher&quot;);
3522     }
3523 
3524     /*
3525      * 5 groups of characters are created to make a substitution string.
3526      * A base string will be created including random lead chars, the
3527      * substitution string, and random trailing chars.
3528      * A pattern containing the 5 groups is searched for and replaced with:
3529      * random group + random string + random group.
3530      * The results are checked for correctness.
3531      */
3532     private static void substitutionBasher2() {
3533         for (int runs = 0; runs&lt;1000; runs++) {
3534             // Create a base string to work in
3535             int leadingChars = generator.nextInt(10);
3536             StringBuilder baseBuffer = new StringBuilder(100);
3537             String leadingString = getRandomAlphaString(leadingChars);
3538             baseBuffer.append(leadingString);
3539 
3540             // Create 5 groups of random number of random chars
3541             // Create the string to substitute
3542             // Create the pattern string to search for
3543             StringBuilder bufferToSub = new StringBuilder(25);
3544             StringBuilder bufferToPat = new StringBuilder(50);
3545             String[] groups = new String[5];
3546             for(int i=0; i&lt;5; i++) {
3547                 int aGroupSize = generator.nextInt(5)+1;
3548                 groups[i] = getRandomAlphaString(aGroupSize);
3549                 bufferToSub.append(groups[i]);
3550                 bufferToPat.append(&#39;(&#39;);
3551                 bufferToPat.append(groups[i]);
3552                 bufferToPat.append(&#39;)&#39;);
3553             }
3554             String stringToSub = bufferToSub.toString();
3555             String pattern = bufferToPat.toString();
3556 
3557             // Place sub string into working string at random index
3558             baseBuffer.append(stringToSub);
3559 
3560             // Append random chars to end
3561             int trailingChars = generator.nextInt(10);
3562             String trailingString = getRandomAlphaString(trailingChars);
3563             baseBuffer.append(trailingString);
3564             String baseString = baseBuffer.toString();
3565 
3566             // Create test pattern and matcher
3567             Pattern p = Pattern.compile(pattern);
3568             Matcher m = p.matcher(baseString);
3569 
3570             // Reject candidate if pattern happens to start early
3571             m.find();
3572             if (m.start() &lt; leadingChars)
3573                 continue;
3574 
3575             // Reject candidate if more than one match
3576             if (m.find())
3577                 continue;
3578 
3579             // Construct a replacement string with :
3580             // random group + random string + random group
3581             StringBuilder bufferToRep = new StringBuilder();
3582             int groupIndex1 = generator.nextInt(5);
3583             bufferToRep.append(&quot;$&quot; + (groupIndex1 + 1));
3584             String randomMidString = getRandomAlphaString(5);
3585             bufferToRep.append(randomMidString);
3586             int groupIndex2 = generator.nextInt(5);
3587             bufferToRep.append(&quot;$&quot; + (groupIndex2 + 1));
3588             String replacement = bufferToRep.toString();
3589 
3590             // Do the replacement
3591             String result = m.replaceAll(replacement);
3592 
3593             // Construct expected result
3594             StringBuilder bufferToRes = new StringBuilder();
3595             bufferToRes.append(leadingString);
3596             bufferToRes.append(groups[groupIndex1]);
3597             bufferToRes.append(randomMidString);
3598             bufferToRes.append(groups[groupIndex2]);
3599             bufferToRes.append(trailingString);
3600             String expectedResult = bufferToRes.toString();
3601 
3602             // Check results
3603             if (!result.equals(expectedResult)) {
3604                 failCount++;
3605             }
3606         }
3607 
3608         report(&quot;Substitution Basher 2&quot;);
3609     }
3610 
3611     /**
3612      * Checks the handling of some escape sequences that the Pattern
3613      * class should process instead of the java compiler. These are
3614      * not in the file because the escapes should be be processed
3615      * by the Pattern class when the regex is compiled.
3616      */
3617     private static void escapes() throws Exception {
3618         Pattern p = Pattern.compile(&quot;\\043&quot;);
3619         Matcher m = p.matcher(&quot;#&quot;);
3620         if (!m.find())
3621             failCount++;
3622 
3623         p = Pattern.compile(&quot;\\x23&quot;);
3624         m = p.matcher(&quot;#&quot;);
3625         if (!m.find())
3626             failCount++;
3627 
3628         p = Pattern.compile(&quot;\\u0023&quot;);
3629         m = p.matcher(&quot;#&quot;);
3630         if (!m.find())
3631             failCount++;
3632 
3633         report(&quot;Escape sequences&quot;);
3634     }
3635 
3636     /**
3637      * Checks the handling of blank input situations. These
3638      * tests are incompatible with my test file format.
3639      */
3640     private static void blankInput() throws Exception {
3641         Pattern p = Pattern.compile(&quot;abc&quot;, Pattern.CASE_INSENSITIVE);
3642         Matcher m = p.matcher(&quot;&quot;);
3643         if (m.find())
3644             failCount++;
3645 
3646         p = Pattern.compile(&quot;a*&quot;, Pattern.CASE_INSENSITIVE);
3647         m = p.matcher(&quot;&quot;);
3648         if (!m.find())
3649             failCount++;
3650 
3651         p = Pattern.compile(&quot;abc&quot;);
3652         m = p.matcher(&quot;&quot;);
3653         if (m.find())
3654             failCount++;
3655 
3656         p = Pattern.compile(&quot;a*&quot;);
3657         m = p.matcher(&quot;&quot;);
3658         if (!m.find())
3659             failCount++;
3660 
3661         report(&quot;Blank input&quot;);
3662     }
3663 
3664     /**
3665      * Tests the Boyer-Moore pattern matching of a character sequence
3666      * on randomly generated patterns.
3667      */
3668     private static void bm() throws Exception {
3669         doBnM(&#39;a&#39;);
3670         report(&quot;Boyer Moore (ASCII)&quot;);
3671 
3672         doBnM(Character.MIN_SUPPLEMENTARY_CODE_POINT - 10);
3673         report(&quot;Boyer Moore (Supplementary)&quot;);
3674     }
3675 
3676     private static void doBnM(int baseCharacter) throws Exception {
3677         int achar=0;
3678 
3679         for (int i=0; i&lt;100; i++) {
3680             // Create a short pattern to search for
3681             int patternLength = generator.nextInt(7) + 4;
3682             StringBuffer patternBuffer = new StringBuffer(patternLength);
3683             String pattern;
3684             retry: for (;;) {
3685                 for (int x=0; x&lt;patternLength; x++) {
3686                     int ch = baseCharacter + generator.nextInt(26);
3687                     if (Character.isSupplementaryCodePoint(ch)) {
3688                         patternBuffer.append(Character.toChars(ch));
3689                     } else {
3690                         patternBuffer.append((char)ch);
3691                     }
3692                 }
3693                 pattern = patternBuffer.toString();
3694 
3695                 // Avoid patterns that start and end with the same substring
3696                 // See JDK-6854417
3697                 for (int x=1; x &lt; pattern.length(); x++) {
3698                     if (pattern.startsWith(pattern.substring(x)))
3699                         continue retry;
3700                 }
3701                 break;
3702             }
3703             Pattern p = Pattern.compile(pattern);
3704 
3705             // Create a buffer with random ASCII chars that does
3706             // not match the sample
3707             String toSearch = null;
3708             StringBuffer s = null;
3709             Matcher m = p.matcher(&quot;&quot;);
3710             do {
3711                 s = new StringBuffer(100);
3712                 for (int x=0; x&lt;100; x++) {
3713                     int ch = baseCharacter + generator.nextInt(26);
3714                     if (Character.isSupplementaryCodePoint(ch)) {
3715                         s.append(Character.toChars(ch));
3716                     } else {
3717                         s.append((char)ch);
3718                     }
3719                 }
3720                 toSearch = s.toString();
3721                 m.reset(toSearch);
3722             } while (m.find());
3723 
3724             // Insert the pattern at a random spot
3725             int insertIndex = generator.nextInt(99);
3726             if (Character.isLowSurrogate(s.charAt(insertIndex)))
3727                 insertIndex++;
3728             s = s.insert(insertIndex, pattern);
3729             toSearch = s.toString();
3730 
3731             // Make sure that the pattern is found
3732             m.reset(toSearch);
3733             if (!m.find())
3734                 failCount++;
3735 
3736             // Make sure that the match text is the pattern
3737             if (!m.group().equals(pattern))
3738                 failCount++;
3739 
3740             // Make sure match occured at insertion point
3741             if (m.start() != insertIndex)
3742                 failCount++;
3743         }
3744     }
3745 
3746     /**
3747      * Tests the matching of slices on randomly generated patterns.
3748      * The Boyer-Moore optimization is not done on these patterns
3749      * because it uses unicode case folding.
3750      */
3751     private static void slice() throws Exception {
3752         doSlice(Character.MAX_VALUE);
3753         report(&quot;Slice&quot;);
3754 
3755         doSlice(Character.MAX_CODE_POINT);
3756         report(&quot;Slice (Supplementary)&quot;);
3757     }
3758 
3759     private static void doSlice(int maxCharacter) throws Exception {
3760         Random generator = new Random();
3761         int achar=0;
3762 
3763         for (int i=0; i&lt;100; i++) {
3764             // Create a short pattern to search for
3765             int patternLength = generator.nextInt(7) + 4;
3766             StringBuffer patternBuffer = new StringBuffer(patternLength);
3767             for (int x=0; x&lt;patternLength; x++) {
3768                 int randomChar = 0;
3769                 while (!Character.isLetterOrDigit(randomChar))
3770                     randomChar = generator.nextInt(maxCharacter);
3771                 if (Character.isSupplementaryCodePoint(randomChar)) {
3772                     patternBuffer.append(Character.toChars(randomChar));
3773                 } else {
3774                     patternBuffer.append((char) randomChar);
3775                 }
3776             }
3777             String pattern =  patternBuffer.toString();
3778             Pattern p = Pattern.compile(pattern, Pattern.UNICODE_CASE);
3779 
3780             // Create a buffer with random chars that does not match the sample
3781             String toSearch = null;
3782             StringBuffer s = null;
3783             Matcher m = p.matcher(&quot;&quot;);
3784             do {
3785                 s = new StringBuffer(100);
3786                 for (int x=0; x&lt;100; x++) {
3787                     int randomChar = 0;
3788                     while (!Character.isLetterOrDigit(randomChar))
3789                         randomChar = generator.nextInt(maxCharacter);
3790                     if (Character.isSupplementaryCodePoint(randomChar)) {
3791                         s.append(Character.toChars(randomChar));
3792                     } else {
3793                         s.append((char) randomChar);
3794                     }
3795                 }
3796                 toSearch = s.toString();
3797                 m.reset(toSearch);
3798             } while (m.find());
3799 
3800             // Insert the pattern at a random spot
3801             int insertIndex = generator.nextInt(99);
3802             if (Character.isLowSurrogate(s.charAt(insertIndex)))
3803                 insertIndex++;
3804             s = s.insert(insertIndex, pattern);
3805             toSearch = s.toString();
3806 
3807             // Make sure that the pattern is found
3808             m.reset(toSearch);
3809             if (!m.find())
3810                 failCount++;
3811 
3812             // Make sure that the match text is the pattern
3813             if (!m.group().equals(pattern))
3814                 failCount++;
3815 
3816             // Make sure match occured at insertion point
3817             if (m.start() != insertIndex)
3818                 failCount++;
3819         }
3820     }
3821 
3822     private static void explainFailure(String pattern, String data,
3823                                        String expected, String actual) {
3824         System.err.println(&quot;----------------------------------------&quot;);
3825         System.err.println(&quot;Pattern = &quot;+pattern);
3826         System.err.println(&quot;Data = &quot;+data);
3827         System.err.println(&quot;Expected = &quot; + expected);
3828         System.err.println(&quot;Actual   = &quot; + actual);
3829     }
3830 
3831     private static void explainFailure(String pattern, String data,
3832                                        Throwable t) {
3833         System.err.println(&quot;----------------------------------------&quot;);
3834         System.err.println(&quot;Pattern = &quot;+pattern);
3835         System.err.println(&quot;Data = &quot;+data);
3836         t.printStackTrace(System.err);
3837     }
3838 
3839     // Testing examples from a file
3840 
3841     /**
3842      * Goes through the file &quot;TestCases.txt&quot; and creates many patterns
3843      * described in the file, matching the patterns against input lines in
3844      * the file, and comparing the results against the correct results
3845      * also found in the file. The file format is described in comments
3846      * at the head of the file.
3847      */
3848     private static void processFile(String fileName) throws Exception {
3849         File testCases = new File(System.getProperty(&quot;test.src&quot;, &quot;.&quot;),
3850                                   fileName);
3851         FileInputStream in = new FileInputStream(testCases);
3852         BufferedReader r = new BufferedReader(new InputStreamReader(in));
3853 
3854         // Process next test case.
3855         String aLine;
3856         while((aLine = r.readLine()) != null) {
3857             // Read a line for pattern
3858             String patternString = grabLine(r);
3859             Pattern p = null;
3860             try {
3861                 p = compileTestPattern(patternString);
3862             } catch (PatternSyntaxException e) {
3863                 String dataString = grabLine(r);
3864                 String expectedResult = grabLine(r);
3865                 if (expectedResult.startsWith(&quot;error&quot;))
3866                     continue;
3867                 explainFailure(patternString, dataString, e);
3868                 failCount++;
3869                 continue;
3870             }
3871 
3872             // Read a line for input string
3873             String dataString = grabLine(r);
3874             Matcher m = p.matcher(dataString);
3875             StringBuffer result = new StringBuffer();
3876 
3877             // Check for IllegalStateExceptions before a match
3878             failCount += preMatchInvariants(m);
3879 
3880             boolean found = m.find();
3881 
3882             if (found)
3883                 failCount += postTrueMatchInvariants(m);
3884             else
3885                 failCount += postFalseMatchInvariants(m);
3886 
3887             if (found) {
3888                 result.append(&quot;true &quot;);
3889                 result.append(m.group(0) + &quot; &quot;);
3890             } else {
3891                 result.append(&quot;false &quot;);
3892             }
3893 
3894             result.append(m.groupCount());
3895 
3896             if (found) {
3897                 for (int i=1; i&lt;m.groupCount()+1; i++)
3898                     if (m.group(i) != null)
3899                         result.append(&quot; &quot; +m.group(i));
3900             }
3901 
3902             // Read a line for the expected result
3903             String expectedResult = grabLine(r);
3904 
3905             if (!result.toString().equals(expectedResult)) {
3906                 explainFailure(patternString, dataString, expectedResult, result.toString());
3907                 failCount++;
3908             }
3909         }
3910 
3911         report(fileName);
3912     }
3913 
3914     private static int preMatchInvariants(Matcher m) {
3915         int failCount = 0;
3916         try {
3917             m.start();
3918             failCount++;
3919         } catch (IllegalStateException ise) {}
3920         try {
3921             m.end();
3922             failCount++;
3923         } catch (IllegalStateException ise) {}
3924         try {
3925             m.group();
3926             failCount++;
3927         } catch (IllegalStateException ise) {}
3928         return failCount;
3929     }
3930 
3931     private static int postFalseMatchInvariants(Matcher m) {
3932         int failCount = 0;
3933         try {
3934             m.group();
3935             failCount++;
3936         } catch (IllegalStateException ise) {}
3937         try {
3938             m.start();
3939             failCount++;
3940         } catch (IllegalStateException ise) {}
3941         try {
3942             m.end();
3943             failCount++;
3944         } catch (IllegalStateException ise) {}
3945         return failCount;
3946     }
3947 
3948     private static int postTrueMatchInvariants(Matcher m) {
3949         int failCount = 0;
3950         //assert(m.start() = m.start(0);
3951         if (m.start() != m.start(0))
3952             failCount++;
3953         //assert(m.end() = m.end(0);
3954         if (m.start() != m.start(0))
3955             failCount++;
3956         //assert(m.group() = m.group(0);
3957         if (!m.group().equals(m.group(0)))
3958             failCount++;
3959         try {
3960             m.group(50);
3961             failCount++;
3962         } catch (IndexOutOfBoundsException ise) {}
3963 
3964         return failCount;
3965     }
3966 
3967     private static Pattern compileTestPattern(String patternString) {
3968         if (!patternString.startsWith(&quot;&#39;&quot;)) {
3969             return Pattern.compile(patternString);
3970         }
3971         int break1 = patternString.lastIndexOf(&quot;&#39;&quot;);
3972         String flagString = patternString.substring(
3973                                           break1+1, patternString.length());
3974         patternString = patternString.substring(1, break1);
3975 
3976         if (flagString.equals(&quot;i&quot;))
3977             return Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);
3978 
3979         if (flagString.equals(&quot;m&quot;))
3980             return Pattern.compile(patternString, Pattern.MULTILINE);
3981 
3982         return Pattern.compile(patternString);
3983     }
3984 
3985     /**
3986      * Reads a line from the input file. Keeps reading lines until a non
3987      * empty non comment line is read. If the line contains a \n then
3988      * these two characters are replaced by a newline char. If a \\uxxxx
3989      * sequence is read then the sequence is replaced by the unicode char.
3990      */
3991     private static String grabLine(BufferedReader r) throws Exception {
3992         int index = 0;
3993         String line = r.readLine();
3994         while (line.startsWith(&quot;//&quot;) || line.length() &lt; 1)
3995             line = r.readLine();
3996         while ((index = line.indexOf(&quot;\\n&quot;)) != -1) {
3997             StringBuffer temp = new StringBuffer(line);
3998             temp.replace(index, index+2, &quot;\n&quot;);
3999             line = temp.toString();
4000         }
4001         while ((index = line.indexOf(&quot;\\u&quot;)) != -1) {
4002             StringBuffer temp = new StringBuffer(line);
4003             String value = temp.substring(index+2, index+6);
4004             char aChar = (char)Integer.parseInt(value, 16);
4005             String unicodeChar = &quot;&quot; + aChar;
4006             temp.replace(index, index+6, unicodeChar);
4007             line = temp.toString();
4008         }
4009 
4010         return line;
4011     }
4012 
4013     private static void check(Pattern p, String s, String g, String expected) {
4014         Matcher m = p.matcher(s);
4015         m.find();
4016         if (!m.group(g).equals(expected) ||
4017             s.charAt(m.start(g)) != expected.charAt(0) ||
4018             s.charAt(m.end(g) - 1) != expected.charAt(expected.length() - 1))
4019             failCount++;
4020     }
4021 
4022     private static void checkReplaceFirst(String p, String s, String r, String expected)
4023     {
4024         if (!expected.equals(Pattern.compile(p)
4025                                     .matcher(s)
4026                                     .replaceFirst(r)))
4027             failCount++;
4028     }
4029 
4030     private static void checkReplaceAll(String p, String s, String r, String expected)
4031     {
4032         if (!expected.equals(Pattern.compile(p)
4033                                     .matcher(s)
4034                                     .replaceAll(r)))
4035             failCount++;
4036     }
4037 
4038     private static void checkExpectedFail(String p) {
4039         try {
4040             Pattern.compile(p);
4041         } catch (PatternSyntaxException pse) {
4042             //pse.printStackTrace();
4043             return;
4044         }
4045         failCount++;
4046     }
4047 
4048     private static void checkExpectedIAE(Matcher m, String g) {
4049         m.find();
4050         try {
4051             m.group(g);
4052         } catch (IllegalArgumentException x) {
4053             //iae.printStackTrace();
4054             try {
4055                 m.start(g);
4056             } catch (IllegalArgumentException xx) {
4057                 try {
4058                     m.start(g);
4059                 } catch (IllegalArgumentException xxx) {
4060                     return;
4061                 }
4062             }
4063         }
4064         failCount++;
4065     }
4066 
4067     private static void checkExpectedNPE(Matcher m) {
4068         m.find();
4069         try {
4070             m.group(null);
4071         } catch (NullPointerException x) {
4072             try {
4073                 m.start(null);
4074             } catch (NullPointerException xx) {
4075                 try {
4076                     m.end(null);
4077                 } catch (NullPointerException xxx) {
4078                     return;
4079                 }
4080             }
4081         }
4082         failCount++;
4083     }
4084 
4085     private static void namedGroupCaptureTest() throws Exception {
4086         check(Pattern.compile(&quot;x+(?&lt;gname&gt;y+)z+&quot;),
4087               &quot;xxxyyyzzz&quot;,
4088               &quot;gname&quot;,
4089               &quot;yyy&quot;);
4090 
4091         check(Pattern.compile(&quot;x+(?&lt;gname8&gt;y+)z+&quot;),
4092               &quot;xxxyyyzzz&quot;,
4093               &quot;gname8&quot;,
4094               &quot;yyy&quot;);
4095 
4096         //backref
4097         Pattern pattern = Pattern.compile(&quot;(a*)bc\\1&quot;);
4098         check(pattern, &quot;zzzaabcazzz&quot;, true);  // found &quot;abca&quot;
4099 
4100         check(Pattern.compile(&quot;(?&lt;gname&gt;a*)bc\\k&lt;gname&gt;&quot;),
4101               &quot;zzzaabcaazzz&quot;, true);
4102 
4103         check(Pattern.compile(&quot;(?&lt;gname&gt;abc)(def)\\k&lt;gname&gt;&quot;),
4104               &quot;abcdefabc&quot;, true);
4105 
4106         check(Pattern.compile(&quot;(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(?&lt;gname&gt;k)\\k&lt;gname&gt;&quot;),
4107               &quot;abcdefghijkk&quot;, true);
4108 
4109         // Supplementary character tests
4110         check(Pattern.compile(&quot;(?&lt;gname&gt;&quot; + toSupplementaries(&quot;a*)bc&quot;) + &quot;\\k&lt;gname&gt;&quot;),
4111               toSupplementaries(&quot;zzzaabcazzz&quot;), true);
4112 
4113         check(Pattern.compile(&quot;(?&lt;gname&gt;&quot; + toSupplementaries(&quot;a*)bc&quot;) + &quot;\\k&lt;gname&gt;&quot;),
4114               toSupplementaries(&quot;zzzaabcaazzz&quot;), true);
4115 
4116         check(Pattern.compile(&quot;(?&lt;gname&gt;&quot; + toSupplementaries(&quot;abc)(def)&quot;) + &quot;\\k&lt;gname&gt;&quot;),
4117               toSupplementaries(&quot;abcdefabc&quot;), true);
4118 
4119         check(Pattern.compile(toSupplementaries(&quot;(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)&quot;) +
4120                               &quot;(?&lt;gname&gt;&quot; +
4121                               toSupplementaries(&quot;k)&quot;) + &quot;\\k&lt;gname&gt;&quot;),
4122               toSupplementaries(&quot;abcdefghijkk&quot;), true);
4123 
4124         check(Pattern.compile(&quot;x+(?&lt;gname&gt;y+)z+\\k&lt;gname&gt;&quot;),
4125               &quot;xxxyyyzzzyyy&quot;,
4126               &quot;gname&quot;,
4127               &quot;yyy&quot;);
4128 
4129         //replaceFirst/All
4130         checkReplaceFirst(&quot;(?&lt;gn&gt;ab)(c*)&quot;,
4131                           &quot;abccczzzabcczzzabccc&quot;,
4132                           &quot;${gn}&quot;,
4133                           &quot;abzzzabcczzzabccc&quot;);
4134 
4135         checkReplaceAll(&quot;(?&lt;gn&gt;ab)(c*)&quot;,
4136                         &quot;abccczzzabcczzzabccc&quot;,
4137                         &quot;${gn}&quot;,
4138                         &quot;abzzzabzzzab&quot;);
4139 
4140 
4141         checkReplaceFirst(&quot;(?&lt;gn&gt;ab)(c*)&quot;,
4142                           &quot;zzzabccczzzabcczzzabccczzz&quot;,
4143                           &quot;${gn}&quot;,
4144                           &quot;zzzabzzzabcczzzabccczzz&quot;);
4145 
4146         checkReplaceAll(&quot;(?&lt;gn&gt;ab)(c*)&quot;,
4147                         &quot;zzzabccczzzabcczzzabccczzz&quot;,
4148                         &quot;${gn}&quot;,
4149                         &quot;zzzabzzzabzzzabzzz&quot;);
4150 
4151         checkReplaceFirst(&quot;(?&lt;gn1&gt;ab)(?&lt;gn2&gt;c*)&quot;,
4152                           &quot;zzzabccczzzabcczzzabccczzz&quot;,
4153                           &quot;${gn2}&quot;,
4154                           &quot;zzzccczzzabcczzzabccczzz&quot;);
4155 
4156         checkReplaceAll(&quot;(?&lt;gn1&gt;ab)(?&lt;gn2&gt;c*)&quot;,
4157                         &quot;zzzabccczzzabcczzzabccczzz&quot;,
4158                         &quot;${gn2}&quot;,
4159                         &quot;zzzccczzzcczzzccczzz&quot;);
4160 
4161         //toSupplementaries(&quot;(ab)(c*)&quot;));
4162         checkReplaceFirst(&quot;(?&lt;gn1&gt;&quot; + toSupplementaries(&quot;ab&quot;) +
4163                            &quot;)(?&lt;gn2&gt;&quot; + toSupplementaries(&quot;c&quot;) + &quot;*)&quot;,
4164                           toSupplementaries(&quot;abccczzzabcczzzabccc&quot;),
4165                           &quot;${gn1}&quot;,
4166                           toSupplementaries(&quot;abzzzabcczzzabccc&quot;));
4167 
4168 
4169         checkReplaceAll(&quot;(?&lt;gn1&gt;&quot; + toSupplementaries(&quot;ab&quot;) +
4170                         &quot;)(?&lt;gn2&gt;&quot; + toSupplementaries(&quot;c&quot;) + &quot;*)&quot;,
4171                         toSupplementaries(&quot;abccczzzabcczzzabccc&quot;),
4172                         &quot;${gn1}&quot;,
4173                         toSupplementaries(&quot;abzzzabzzzab&quot;));
4174 
4175         checkReplaceFirst(&quot;(?&lt;gn1&gt;&quot; + toSupplementaries(&quot;ab&quot;) +
4176                            &quot;)(?&lt;gn2&gt;&quot; + toSupplementaries(&quot;c&quot;) + &quot;*)&quot;,
4177                           toSupplementaries(&quot;abccczzzabcczzzabccc&quot;),
4178                           &quot;${gn2}&quot;,
4179                           toSupplementaries(&quot;ccczzzabcczzzabccc&quot;));
4180 
4181 
4182         checkReplaceAll(&quot;(?&lt;gn1&gt;&quot; + toSupplementaries(&quot;ab&quot;) +
4183                         &quot;)(?&lt;gn2&gt;&quot; + toSupplementaries(&quot;c&quot;) + &quot;*)&quot;,
4184                         toSupplementaries(&quot;abccczzzabcczzzabccc&quot;),
4185                         &quot;${gn2}&quot;,
4186                         toSupplementaries(&quot;ccczzzcczzzccc&quot;));
4187 
4188         checkReplaceFirst(&quot;(?&lt;dog&gt;Dog)AndCat&quot;,
4189                           &quot;zzzDogAndCatzzzDogAndCatzzz&quot;,
4190                           &quot;${dog}&quot;,
4191                           &quot;zzzDogzzzDogAndCatzzz&quot;);
4192 
4193 
4194         checkReplaceAll(&quot;(?&lt;dog&gt;Dog)AndCat&quot;,
4195                           &quot;zzzDogAndCatzzzDogAndCatzzz&quot;,
4196                           &quot;${dog}&quot;,
4197                           &quot;zzzDogzzzDogzzz&quot;);
4198 
4199         // backref in Matcher &amp; String
4200         if (!&quot;abcdefghij&quot;.replaceFirst(&quot;cd(?&lt;gn&gt;ef)gh&quot;, &quot;${gn}&quot;).equals(&quot;abefij&quot;) ||
4201             !&quot;abbbcbdbefgh&quot;.replaceAll(&quot;(?&lt;gn&gt;[a-e])b&quot;, &quot;${gn}&quot;).equals(&quot;abcdefgh&quot;))
4202             failCount++;
4203 
4204         // negative
4205         checkExpectedFail(&quot;(?&lt;groupnamehasnoascii.in&gt;abc)(def)&quot;);
4206         checkExpectedFail(&quot;(?&lt;groupnamehasnoascii_in&gt;abc)(def)&quot;);
4207         checkExpectedFail(&quot;(?&lt;6groupnamestartswithdigit&gt;abc)(def)&quot;);
4208         checkExpectedFail(&quot;(?&lt;gname&gt;abc)(def)\\k&lt;gnameX&gt;&quot;);
4209         checkExpectedFail(&quot;(?&lt;gname&gt;abc)(?&lt;gname&gt;def)\\k&lt;gnameX&gt;&quot;);
4210         checkExpectedIAE(Pattern.compile(&quot;(?&lt;gname&gt;abc)(def)&quot;).matcher(&quot;abcdef&quot;),
4211                          &quot;gnameX&quot;);
4212         checkExpectedNPE(Pattern.compile(&quot;(?&lt;gname&gt;abc)(def)&quot;).matcher(&quot;abcdef&quot;));
4213         report(&quot;NamedGroupCapture&quot;);
4214     }
4215 
4216     // This is for bug 6919132
4217     private static void nonBmpClassComplementTest() throws Exception {
4218         Pattern p = Pattern.compile(&quot;\\P{Lu}&quot;);
4219         Matcher m = p.matcher(new String(new int[] {0x1d400}, 0, 1));
4220 
4221         if (m.find() &amp;&amp; m.start() == 1)
4222             failCount++;
4223 
4224         // from a unicode category
4225         p = Pattern.compile(&quot;\\P{Lu}&quot;);
4226         m = p.matcher(new String(new int[] {0x1d400}, 0, 1));
4227         if (m.find())
4228             failCount++;
4229         if (!m.hitEnd())
4230             failCount++;
4231 
4232         // block
4233         p = Pattern.compile(&quot;\\P{InMathematicalAlphanumericSymbols}&quot;);
4234         m = p.matcher(new String(new int[] {0x1d400}, 0, 1));
4235         if (m.find() &amp;&amp; m.start() == 1)
4236             failCount++;
4237 
4238         p = Pattern.compile(&quot;\\P{sc=GRANTHA}&quot;);
4239         m = p.matcher(new String(new int[] {0x11350}, 0, 1));
4240         if (m.find() &amp;&amp; m.start() == 1)
4241             failCount++;
4242 
4243         report(&quot;NonBmpClassComplement&quot;);
4244     }
4245 
4246     private static void unicodePropertiesTest() throws Exception {
4247         // different forms
4248         if (!Pattern.compile(&quot;\\p{IsLu}&quot;).matcher(&quot;A&quot;).matches() ||
4249             !Pattern.compile(&quot;\\p{Lu}&quot;).matcher(&quot;A&quot;).matches() ||
4250             !Pattern.compile(&quot;\\p{gc=Lu}&quot;).matcher(&quot;A&quot;).matches() ||
4251             !Pattern.compile(&quot;\\p{general_category=Lu}&quot;).matcher(&quot;A&quot;).matches() ||
4252             !Pattern.compile(&quot;\\p{IsLatin}&quot;).matcher(&quot;B&quot;).matches() ||
4253             !Pattern.compile(&quot;\\p{sc=Latin}&quot;).matcher(&quot;B&quot;).matches() ||
4254             !Pattern.compile(&quot;\\p{script=Latin}&quot;).matcher(&quot;B&quot;).matches() ||
4255             !Pattern.compile(&quot;\\p{InBasicLatin}&quot;).matcher(&quot;c&quot;).matches() ||
4256             !Pattern.compile(&quot;\\p{blk=BasicLatin}&quot;).matcher(&quot;c&quot;).matches() ||
4257             !Pattern.compile(&quot;\\p{block=BasicLatin}&quot;).matcher(&quot;c&quot;).matches())
4258             failCount++;
4259 
4260         Matcher common  = Pattern.compile(&quot;\\p{script=Common}&quot;).matcher(&quot;&quot;);
4261         Matcher unknown = Pattern.compile(&quot;\\p{IsUnknown}&quot;).matcher(&quot;&quot;);
4262         Matcher lastSM  = common;
4263         Character.UnicodeScript lastScript = Character.UnicodeScript.of(0);
4264 
4265         Matcher latin  = Pattern.compile(&quot;\\p{block=basic_latin}&quot;).matcher(&quot;&quot;);
4266         Matcher greek  = Pattern.compile(&quot;\\p{InGreek}&quot;).matcher(&quot;&quot;);
4267         Matcher lastBM = latin;
4268         Character.UnicodeBlock lastBlock = Character.UnicodeBlock.of(0);
4269 
4270         for (int cp = 1; cp &lt; Character.MAX_CODE_POINT; cp++) {
4271             if (cp &gt;= 0x30000 &amp;&amp; (cp &amp; 0x70) == 0){
4272                 continue;  // only pick couple code points, they are the same
4273             }
4274 
4275             // Unicode Script
4276             Character.UnicodeScript script = Character.UnicodeScript.of(cp);
4277             Matcher m;
4278             String str = new String(Character.toChars(cp));
4279             if (script == lastScript) {
4280                  m = lastSM;
4281                  m.reset(str);
4282             } else {
4283                  m  = Pattern.compile(&quot;\\p{Is&quot; + script.name() + &quot;}&quot;).matcher(str);
4284             }
4285             if (!m.matches()) {
4286                 failCount++;
4287             }
4288             Matcher other = (script == Character.UnicodeScript.COMMON)? unknown : common;
4289             other.reset(str);
4290             if (other.matches()) {
4291                 failCount++;
4292             }
4293             lastSM = m;
4294             lastScript = script;
4295 
4296             // Unicode Block
4297             Character.UnicodeBlock block = Character.UnicodeBlock.of(cp);
4298             if (block == null) {
4299                 //System.out.printf(&quot;Not a Block: cp=%x%n&quot;, cp);
4300                 continue;
4301             }
4302             if (block == lastBlock) {
4303                  m = lastBM;
4304                  m.reset(str);
4305             } else {
4306                  m  = Pattern.compile(&quot;\\p{block=&quot; + block.toString() + &quot;}&quot;).matcher(str);
4307             }
4308             if (!m.matches()) {
4309                 failCount++;
4310             }
4311             other = (block == Character.UnicodeBlock.BASIC_LATIN)? greek : latin;
4312             other.reset(str);
4313             if (other.matches()) {
4314                 failCount++;
4315             }
4316             lastBM = m;
4317             lastBlock = block;
4318         }
4319         report(&quot;unicodeProperties&quot;);
4320     }
4321 
4322     private static void unicodeHexNotationTest() throws Exception {
4323 
4324         // negative
4325         checkExpectedFail(&quot;\\x{-23}&quot;);
4326         checkExpectedFail(&quot;\\x{110000}&quot;);
4327         checkExpectedFail(&quot;\\x{}&quot;);
4328         checkExpectedFail(&quot;\\x{AB[ef]&quot;);
4329 
4330         // codepoint
4331         check(&quot;^\\x{1033c}$&quot;,              &quot;\uD800\uDF3C&quot;, true);
4332         check(&quot;^\\xF0\\x90\\x8C\\xBC$&quot;,    &quot;\uD800\uDF3C&quot;, false);
4333         check(&quot;^\\x{D800}\\x{DF3c}+$&quot;,     &quot;\uD800\uDF3C&quot;, false);
4334         check(&quot;^\\xF0\\x90\\x8C\\xBC$&quot;,    &quot;\uD800\uDF3C&quot;, false);
4335 
4336         // in class
4337         check(&quot;^[\\x{D800}\\x{DF3c}]+$&quot;,   &quot;\uD800\uDF3C&quot;, false);
4338         check(&quot;^[\\xF0\\x90\\x8C\\xBC]+$&quot;, &quot;\uD800\uDF3C&quot;, false);
4339         check(&quot;^[\\x{D800}\\x{DF3C}]+$&quot;,   &quot;\uD800\uDF3C&quot;, false);
4340         check(&quot;^[\\x{DF3C}\\x{D800}]+$&quot;,   &quot;\uD800\uDF3C&quot;, false);
4341         check(&quot;^[\\x{D800}\\x{DF3C}]+$&quot;,   &quot;\uDF3C\uD800&quot;, true);
4342         check(&quot;^[\\x{DF3C}\\x{D800}]+$&quot;,   &quot;\uDF3C\uD800&quot;, true);
4343 
4344         for (int cp = 0; cp &lt;= 0x10FFFF; cp++) {
4345              String s = &quot;A&quot; + new String(Character.toChars(cp)) + &quot;B&quot;;
4346              String hexUTF16 = (cp &lt;= 0xFFFF)? String.format(&quot;\\u%04x&quot;, cp)
4347                                              : String.format(&quot;\\u%04x\\u%04x&quot;,
4348                                                (int) Character.toChars(cp)[0],
4349                                                (int) Character.toChars(cp)[1]);
4350              String hexCodePoint = &quot;\\x{&quot; + Integer.toHexString(cp) + &quot;}&quot;;
4351              if (!Pattern.matches(&quot;A&quot; + hexUTF16 + &quot;B&quot;, s))
4352                  failCount++;
4353              if (!Pattern.matches(&quot;A[&quot; + hexUTF16 + &quot;]B&quot;, s))
4354                  failCount++;
4355              if (!Pattern.matches(&quot;A&quot; + hexCodePoint + &quot;B&quot;, s))
4356                  failCount++;
4357              if (!Pattern.matches(&quot;A[&quot; + hexCodePoint + &quot;]B&quot;, s))
4358                  failCount++;
4359          }
4360          report(&quot;unicodeHexNotation&quot;);
4361     }
4362 
4363     private static void unicodeClassesTest() throws Exception {
4364 
4365         Matcher lower  = Pattern.compile(&quot;\\p{Lower}&quot;).matcher(&quot;&quot;);
4366         Matcher upper  = Pattern.compile(&quot;\\p{Upper}&quot;).matcher(&quot;&quot;);
4367         Matcher ASCII  = Pattern.compile(&quot;\\p{ASCII}&quot;).matcher(&quot;&quot;);
4368         Matcher alpha  = Pattern.compile(&quot;\\p{Alpha}&quot;).matcher(&quot;&quot;);
4369         Matcher digit  = Pattern.compile(&quot;\\p{Digit}&quot;).matcher(&quot;&quot;);
4370         Matcher alnum  = Pattern.compile(&quot;\\p{Alnum}&quot;).matcher(&quot;&quot;);
4371         Matcher punct  = Pattern.compile(&quot;\\p{Punct}&quot;).matcher(&quot;&quot;);
4372         Matcher graph  = Pattern.compile(&quot;\\p{Graph}&quot;).matcher(&quot;&quot;);
4373         Matcher print  = Pattern.compile(&quot;\\p{Print}&quot;).matcher(&quot;&quot;);
4374         Matcher blank  = Pattern.compile(&quot;\\p{Blank}&quot;).matcher(&quot;&quot;);
4375         Matcher cntrl  = Pattern.compile(&quot;\\p{Cntrl}&quot;).matcher(&quot;&quot;);
4376         Matcher xdigit = Pattern.compile(&quot;\\p{XDigit}&quot;).matcher(&quot;&quot;);
4377         Matcher space  = Pattern.compile(&quot;\\p{Space}&quot;).matcher(&quot;&quot;);
4378         Matcher bound  = Pattern.compile(&quot;\\b&quot;).matcher(&quot;&quot;);
4379         Matcher word   = Pattern.compile(&quot;\\w++&quot;).matcher(&quot;&quot;);
4380         // UNICODE_CHARACTER_CLASS
4381         Matcher lowerU  = Pattern.compile(&quot;\\p{Lower}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4382         Matcher upperU  = Pattern.compile(&quot;\\p{Upper}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4383         Matcher ASCIIU  = Pattern.compile(&quot;\\p{ASCII}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4384         Matcher alphaU  = Pattern.compile(&quot;\\p{Alpha}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4385         Matcher digitU  = Pattern.compile(&quot;\\p{Digit}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4386         Matcher alnumU  = Pattern.compile(&quot;\\p{Alnum}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4387         Matcher punctU  = Pattern.compile(&quot;\\p{Punct}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4388         Matcher graphU  = Pattern.compile(&quot;\\p{Graph}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4389         Matcher printU  = Pattern.compile(&quot;\\p{Print}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4390         Matcher blankU  = Pattern.compile(&quot;\\p{Blank}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4391         Matcher cntrlU  = Pattern.compile(&quot;\\p{Cntrl}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4392         Matcher xdigitU = Pattern.compile(&quot;\\p{XDigit}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4393         Matcher spaceU  = Pattern.compile(&quot;\\p{Space}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4394         Matcher boundU  = Pattern.compile(&quot;\\b&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4395         Matcher wordU   = Pattern.compile(&quot;\\w&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4396         // embedded flag (?U)
4397         Matcher lowerEU  = Pattern.compile(&quot;(?U)\\p{Lower}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4398         Matcher graphEU  = Pattern.compile(&quot;(?U)\\p{Graph}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4399         Matcher wordEU   = Pattern.compile(&quot;(?U)\\w&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4400 
4401         Matcher bwb    = Pattern.compile(&quot;\\b\\w\\b&quot;).matcher(&quot;&quot;);
4402         Matcher bwbU   = Pattern.compile(&quot;\\b\\w++\\b&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4403         Matcher bwbEU  = Pattern.compile(&quot;(?U)\\b\\w++\\b&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4404         // properties
4405         Matcher lowerP  = Pattern.compile(&quot;\\p{IsLowerCase}&quot;).matcher(&quot;&quot;);
4406         Matcher upperP  = Pattern.compile(&quot;\\p{IsUpperCase}&quot;).matcher(&quot;&quot;);
4407         Matcher titleP  = Pattern.compile(&quot;\\p{IsTitleCase}&quot;).matcher(&quot;&quot;);
4408         Matcher letterP = Pattern.compile(&quot;\\p{IsLetter}&quot;).matcher(&quot;&quot;);
4409         Matcher alphaP  = Pattern.compile(&quot;\\p{IsAlphabetic}&quot;).matcher(&quot;&quot;);
4410         Matcher ideogP  = Pattern.compile(&quot;\\p{IsIdeographic}&quot;).matcher(&quot;&quot;);
4411         Matcher cntrlP  = Pattern.compile(&quot;\\p{IsControl}&quot;).matcher(&quot;&quot;);
4412         Matcher spaceP  = Pattern.compile(&quot;\\p{IsWhiteSpace}&quot;).matcher(&quot;&quot;);
4413         Matcher definedP = Pattern.compile(&quot;\\p{IsAssigned}&quot;).matcher(&quot;&quot;);
4414         Matcher nonCCPP = Pattern.compile(&quot;\\p{IsNoncharacterCodePoint}&quot;).matcher(&quot;&quot;);
4415         Matcher joinCrtl = Pattern.compile(&quot;\\p{IsJoinControl}&quot;).matcher(&quot;&quot;);
4416         // javaMethod
4417         Matcher lowerJ  = Pattern.compile(&quot;\\p{javaLowerCase}&quot;).matcher(&quot;&quot;);
4418         Matcher upperJ  = Pattern.compile(&quot;\\p{javaUpperCase}&quot;).matcher(&quot;&quot;);
4419         Matcher alphaJ  = Pattern.compile(&quot;\\p{javaAlphabetic}&quot;).matcher(&quot;&quot;);
4420         Matcher ideogJ  = Pattern.compile(&quot;\\p{javaIdeographic}&quot;).matcher(&quot;&quot;);
4421         // GC/C
4422         Matcher gcC  = Pattern.compile(&quot;\\p{C}&quot;).matcher(&quot;&quot;);
4423 
4424         for (int cp = 1; cp &lt; 0x30000; cp++) {
4425             String str = new String(Character.toChars(cp));
4426             int type = Character.getType(cp);
4427             if (// lower
4428                 POSIX_ASCII.isLower(cp)   != lower.reset(str).matches()  ||
4429                 Character.isLowerCase(cp) != lowerU.reset(str).matches() ||
4430                 Character.isLowerCase(cp) != lowerP.reset(str).matches() ||
4431                 Character.isLowerCase(cp) != lowerEU.reset(str).matches()||
4432                 Character.isLowerCase(cp) != lowerJ.reset(str).matches()||
4433                 // upper
4434                 POSIX_ASCII.isUpper(cp)   != upper.reset(str).matches()  ||
4435                 POSIX_Unicode.isUpper(cp) != upperU.reset(str).matches() ||
4436                 Character.isUpperCase(cp) != upperP.reset(str).matches() ||
4437                 Character.isUpperCase(cp) != upperJ.reset(str).matches() ||
4438                 // alpha
4439                 POSIX_ASCII.isAlpha(cp)   != alpha.reset(str).matches()  ||
4440                 POSIX_Unicode.isAlpha(cp) != alphaU.reset(str).matches() ||
4441                 Character.isAlphabetic(cp)!= alphaP.reset(str).matches() ||
4442                 Character.isAlphabetic(cp)!= alphaJ.reset(str).matches() ||
4443                 // digit
4444                 POSIX_ASCII.isDigit(cp)   != digit.reset(str).matches()  ||
4445                 Character.isDigit(cp)     != digitU.reset(str).matches() ||
4446                 // alnum
4447                 POSIX_ASCII.isAlnum(cp)   != alnum.reset(str).matches()  ||
4448                 POSIX_Unicode.isAlnum(cp) != alnumU.reset(str).matches() ||
4449                 // punct
4450                 POSIX_ASCII.isPunct(cp)   != punct.reset(str).matches()  ||
4451                 POSIX_Unicode.isPunct(cp) != punctU.reset(str).matches() ||
4452                 // graph
4453                 POSIX_ASCII.isGraph(cp)   != graph.reset(str).matches()  ||
4454                 POSIX_Unicode.isGraph(cp) != graphU.reset(str).matches() ||
4455                 POSIX_Unicode.isGraph(cp) != graphEU.reset(str).matches()||
4456                 // blank
4457                 POSIX_ASCII.isType(cp, POSIX_ASCII.BLANK)
4458                                           != blank.reset(str).matches()  ||
4459                 POSIX_Unicode.isBlank(cp) != blankU.reset(str).matches() ||
4460                 // print
4461                 POSIX_ASCII.isPrint(cp)   != print.reset(str).matches()  ||
4462                 POSIX_Unicode.isPrint(cp) != printU.reset(str).matches() ||
4463                 // cntrl
4464                 POSIX_ASCII.isCntrl(cp)   != cntrl.reset(str).matches()  ||
4465                 POSIX_Unicode.isCntrl(cp) != cntrlU.reset(str).matches() ||
4466                 (Character.CONTROL == type) != cntrlP.reset(str).matches() ||
4467                 // hexdigit
4468                 POSIX_ASCII.isHexDigit(cp)   != xdigit.reset(str).matches()  ||
4469                 POSIX_Unicode.isHexDigit(cp) != xdigitU.reset(str).matches() ||
4470                 // space
4471                 POSIX_ASCII.isSpace(cp)   != space.reset(str).matches()  ||
4472                 POSIX_Unicode.isSpace(cp) != spaceU.reset(str).matches() ||
4473                 POSIX_Unicode.isSpace(cp) != spaceP.reset(str).matches() ||
4474                 // word
4475                 POSIX_ASCII.isWord(cp)   != word.reset(str).matches()  ||
4476                 POSIX_Unicode.isWord(cp) != wordU.reset(str).matches() ||
4477                 POSIX_Unicode.isWord(cp) != wordEU.reset(str).matches()||
4478                 // bwordb
4479                 POSIX_ASCII.isWord(cp) != bwb.reset(str).matches() ||
4480                 POSIX_Unicode.isWord(cp) != bwbU.reset(str).matches() ||
4481                 // properties
4482                 Character.isTitleCase(cp) != titleP.reset(str).matches() ||
4483                 Character.isLetter(cp)    != letterP.reset(str).matches()||
4484                 Character.isIdeographic(cp) != ideogP.reset(str).matches() ||
4485                 Character.isIdeographic(cp) != ideogJ.reset(str).matches() ||
4486                 (Character.UNASSIGNED == type) == definedP.reset(str).matches() ||
4487                 POSIX_Unicode.isNoncharacterCodePoint(cp) != nonCCPP.reset(str).matches() ||
4488                 POSIX_Unicode.isJoinControl(cp) != joinCrtl.reset(str).matches() ||
4489                 // gc_C
4490                 (Character.CONTROL == type || Character.FORMAT == type ||
4491                  Character.PRIVATE_USE == type || Character.SURROGATE == type ||
4492                  Character.UNASSIGNED == type)
4493                 != gcC.reset(str).matches()) {
4494                 failCount++;
4495             }
4496         }
4497 
4498         // bounds/word align
4499         twoFindIndexes(&quot; \u0180sherman\u0400 &quot;, bound, 1, 10);
4500         if (!bwbU.reset(&quot;\u0180sherman\u0400&quot;).matches())
4501             failCount++;
4502         twoFindIndexes(&quot; \u0180sh\u0345erman\u0400 &quot;, bound, 1, 11);
4503         if (!bwbU.reset(&quot;\u0180sh\u0345erman\u0400&quot;).matches())
4504             failCount++;
4505         twoFindIndexes(&quot; \u0724\u0739\u0724 &quot;, bound, 1, 4);
4506         if (!bwbU.reset(&quot;\u0724\u0739\u0724&quot;).matches())
4507             failCount++;
4508         if (!bwbEU.reset(&quot;\u0724\u0739\u0724&quot;).matches())
4509             failCount++;
4510         report(&quot;unicodePredefinedClasses&quot;);
4511     }
4512 
4513     private static void unicodeCharacterNameTest() throws Exception {
4514 
4515         for (int cp = 0; cp &lt; Character.MAX_CODE_POINT; cp++) {
4516             if (!Character.isValidCodePoint(cp) ||
4517                 Character.getType(cp) == Character.UNASSIGNED)
4518                 continue;
4519             String str = new String(Character.toChars(cp));
4520             // single
4521             String p = &quot;\\N{&quot; + Character.getName(cp) + &quot;}&quot;;
4522             if (!Pattern.compile(p).matcher(str).matches()) {
4523                 failCount++;
4524             }
4525             // class[c]
4526             p = &quot;[\\N{&quot; + Character.getName(cp) + &quot;}]&quot;;
4527             if (!Pattern.compile(p).matcher(str).matches()) {
4528                 failCount++;
4529             }
4530         }
4531 
4532         // range
4533         for (int i = 0; i &lt; 10; i++) {
4534             int start = generator.nextInt(20);
4535             int end = start + generator.nextInt(200);
4536             String p = &quot;[\\N{&quot; + Character.getName(start) + &quot;}-\\N{&quot; + Character.getName(end) + &quot;}]&quot;;
4537             String str;
4538             for (int cp = start; cp &lt; end; cp++) {
4539                 str = new String(Character.toChars(cp));
4540                 if (!Pattern.compile(p).matcher(str).matches()) {
4541                     failCount++;
4542                 }
4543             }
4544             str = new String(Character.toChars(end + 10));
4545             if (Pattern.compile(p).matcher(str).matches()) {
4546                 failCount++;
4547             }
4548         }
4549 
4550         // slice
4551         for (int i = 0; i &lt; 10; i++) {
4552             int n = generator.nextInt(256);
4553             int[] buf = new int[n];
4554             StringBuffer sb = new StringBuffer(1024);
4555             for (int j = 0; j &lt; n; j++) {
4556                 int cp = generator.nextInt(1000);
4557                 if (!Character.isValidCodePoint(cp) ||
4558                     Character.getType(cp) == Character.UNASSIGNED)
4559                     cp = 0x4e00;    // just use 4e00
4560                 sb.append(&quot;\\N{&quot; + Character.getName(cp) + &quot;}&quot;);
4561                 buf[j] = cp;
4562             }
4563             String p = sb.toString();
4564             String str = new String(buf, 0, buf.length);
4565             if (!Pattern.compile(p).matcher(str).matches()) {
4566                 failCount++;
4567             }
4568         }
4569         report(&quot;unicodeCharacterName&quot;);
4570     }
4571 
4572     private static void horizontalAndVerticalWSTest() throws Exception {
4573         String hws = new String (new char[] {
4574                                      0x09, 0x20, 0xa0, 0x1680, 0x180e,
4575                                      0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005,
4576                                      0x2006, 0x2007, 0x2008, 0x2009, 0x200a,
4577                                      0x202f, 0x205f, 0x3000 });
4578         String vws = new String (new char[] {
4579                                      0x0a, 0x0b, 0x0c, 0x0d, 0x85, 0x2028, 0x2029 });
4580         if (!Pattern.compile(&quot;\\h+&quot;).matcher(hws).matches() ||
4581             !Pattern.compile(&quot;[\\h]+&quot;).matcher(hws).matches())
4582             failCount++;
4583         if (Pattern.compile(&quot;\\H&quot;).matcher(hws).find() ||
4584             Pattern.compile(&quot;[\\H]&quot;).matcher(hws).find())
4585             failCount++;
4586         if (!Pattern.compile(&quot;\\v+&quot;).matcher(vws).matches() ||
4587             !Pattern.compile(&quot;[\\v]+&quot;).matcher(vws).matches())
4588             failCount++;
4589         if (Pattern.compile(&quot;\\V&quot;).matcher(vws).find() ||
4590             Pattern.compile(&quot;[\\V]&quot;).matcher(vws).find())
4591             failCount++;
4592         String prefix = &quot;abcd&quot;;
4593         String suffix = &quot;efgh&quot;;
4594         String ng = &quot;A&quot;;
4595         for (int i = 0; i &lt; hws.length(); i++) {
4596             String c = String.valueOf(hws.charAt(i));
4597             Matcher m = Pattern.compile(&quot;\\h&quot;).matcher(prefix + c + suffix);
4598             if (!m.find() || !c.equals(m.group()))
4599                 failCount++;
4600             m = Pattern.compile(&quot;[\\h]&quot;).matcher(prefix + c + suffix);
4601             if (!m.find() || !c.equals(m.group()))
4602                 failCount++;
4603 
4604             m = Pattern.compile(&quot;\\H&quot;).matcher(hws.substring(0, i) + ng + hws.substring(i));
4605             if (!m.find() || !ng.equals(m.group()))
4606                 failCount++;
4607             m = Pattern.compile(&quot;[\\H]&quot;).matcher(hws.substring(0, i) + ng + hws.substring(i));
4608             if (!m.find() || !ng.equals(m.group()))
4609                 failCount++;
4610         }
4611         for (int i = 0; i &lt; vws.length(); i++) {
4612             String c = String.valueOf(vws.charAt(i));
4613             Matcher m = Pattern.compile(&quot;\\v&quot;).matcher(prefix + c + suffix);
4614             if (!m.find() || !c.equals(m.group()))
4615                 failCount++;
4616             m = Pattern.compile(&quot;[\\v]&quot;).matcher(prefix + c + suffix);
4617             if (!m.find() || !c.equals(m.group()))
4618                 failCount++;
4619 
4620             m = Pattern.compile(&quot;\\V&quot;).matcher(vws.substring(0, i) + ng + vws.substring(i));
4621             if (!m.find() || !ng.equals(m.group()))
4622                 failCount++;
4623             m = Pattern.compile(&quot;[\\V]&quot;).matcher(vws.substring(0, i) + ng + vws.substring(i));
4624             if (!m.find() || !ng.equals(m.group()))
4625                 failCount++;
4626         }
4627         // \v in range is interpreted as 0x0B. This is the undocumented behavior
4628         if (!Pattern.compile(&quot;[\\v-\\v]&quot;).matcher(String.valueOf((char)0x0B)).matches())
4629             failCount++;
4630         report(&quot;horizontalAndVerticalWSTest&quot;);
4631     }
4632 
4633     private static void linebreakTest() throws Exception {
4634         String linebreaks = new String (new char[] {
4635             0x0A, 0x0B, 0x0C, 0x0D, 0x85, 0x2028, 0x2029 });
4636         String crnl = &quot;\r\n&quot;;
4637         if (!(Pattern.compile(&quot;\\R+&quot;).matcher(linebreaks).matches() &amp;&amp;
4638               Pattern.compile(&quot;\\R&quot;).matcher(crnl).matches() &amp;&amp;
4639               Pattern.compile(&quot;\\Rabc&quot;).matcher(crnl + &quot;abc&quot;).matches() &amp;&amp;
4640               Pattern.compile(&quot;\\Rabc&quot;).matcher(&quot;\rabc&quot;).matches() &amp;&amp;
4641               Pattern.compile(&quot;\\R\\R&quot;).matcher(crnl).matches() &amp;&amp;  // backtracking
4642               Pattern.compile(&quot;\\R\\n&quot;).matcher(crnl).matches()) &amp;&amp; // backtracking
4643               !Pattern.compile(&quot;((?&lt;!\\R)\\s)*&quot;).matcher(crnl).matches()) { // #8176029
4644             failCount++;
4645         }
4646         report(&quot;linebreakTest&quot;);
4647     }
4648 
4649     // #7189363
4650     private static void branchTest() throws Exception {
4651         if (!Pattern.compile(&quot;(a)?bc|d&quot;).matcher(&quot;d&quot;).find() ||     // greedy
4652             !Pattern.compile(&quot;(a)+bc|d&quot;).matcher(&quot;d&quot;).find() ||
4653             !Pattern.compile(&quot;(a)*bc|d&quot;).matcher(&quot;d&quot;).find() ||
4654             !Pattern.compile(&quot;(a)??bc|d&quot;).matcher(&quot;d&quot;).find() ||    // reluctant
4655             !Pattern.compile(&quot;(a)+?bc|d&quot;).matcher(&quot;d&quot;).find() ||
4656             !Pattern.compile(&quot;(a)*?bc|d&quot;).matcher(&quot;d&quot;).find() ||
4657             !Pattern.compile(&quot;(a)?+bc|d&quot;).matcher(&quot;d&quot;).find() ||    // possessive
4658             !Pattern.compile(&quot;(a)++bc|d&quot;).matcher(&quot;d&quot;).find() ||
4659             !Pattern.compile(&quot;(a)*+bc|d&quot;).matcher(&quot;d&quot;).find() ||
4660             !Pattern.compile(&quot;(a)?bc|d&quot;).matcher(&quot;d&quot;).matches() ||  // greedy
4661             !Pattern.compile(&quot;(a)+bc|d&quot;).matcher(&quot;d&quot;).matches() ||
4662             !Pattern.compile(&quot;(a)*bc|d&quot;).matcher(&quot;d&quot;).matches() ||
4663             !Pattern.compile(&quot;(a)??bc|d&quot;).matcher(&quot;d&quot;).matches() || // reluctant
4664             !Pattern.compile(&quot;(a)+?bc|d&quot;).matcher(&quot;d&quot;).matches() ||
4665             !Pattern.compile(&quot;(a)*?bc|d&quot;).matcher(&quot;d&quot;).matches() ||
4666             !Pattern.compile(&quot;(a)?+bc|d&quot;).matcher(&quot;d&quot;).matches() || // possessive
4667             !Pattern.compile(&quot;(a)++bc|d&quot;).matcher(&quot;d&quot;).matches() ||
4668             !Pattern.compile(&quot;(a)*+bc|d&quot;).matcher(&quot;d&quot;).matches() ||
4669             !Pattern.compile(&quot;(a)?bc|de&quot;).matcher(&quot;de&quot;).find() ||   // others
4670             !Pattern.compile(&quot;(a)??bc|de&quot;).matcher(&quot;de&quot;).find() ||
4671             !Pattern.compile(&quot;(a)?bc|de&quot;).matcher(&quot;de&quot;).matches() ||
4672             !Pattern.compile(&quot;(a)??bc|de&quot;).matcher(&quot;de&quot;).matches())
4673             failCount++;
4674         report(&quot;branchTest&quot;);
4675     }
4676 
4677     // This test is for 8007395
4678     private static void groupCurlyNotFoundSuppTest() throws Exception {
4679         String input = &quot;test this as \ud83d\ude0d&quot;;
4680         for (String pStr : new String[] { &quot;test(.)+(@[a-zA-Z.]+)&quot;,
4681                                           &quot;test(.)*(@[a-zA-Z.]+)&quot;,
4682                                           &quot;test([^B])+(@[a-zA-Z.]+)&quot;,
4683                                           &quot;test([^B])*(@[a-zA-Z.]+)&quot;,
4684                                           &quot;test(\\P{IsControl})+(@[a-zA-Z.]+)&quot;,
4685                                           &quot;test(\\P{IsControl})*(@[a-zA-Z.]+)&quot;,
4686                                         }) {
4687             Matcher m = Pattern.compile(pStr, Pattern.CASE_INSENSITIVE)
4688                                .matcher(input);
4689             try {
4690                 if (m.find()) {
4691                     failCount++;
4692                 }
4693             } catch (Exception x) {
4694                 failCount++;
4695             }
4696         }
4697         report(&quot;GroupCurly NotFoundSupp&quot;);
4698     }
4699 
4700     // This test is for 8023647
4701     private static void groupCurlyBackoffTest() throws Exception {
4702         if (!&quot;abc1c&quot;.matches(&quot;(\\w)+1\\1&quot;) ||
4703             &quot;abc11&quot;.matches(&quot;(\\w)+1\\1&quot;)) {
4704             failCount++;
4705         }
4706         report(&quot;GroupCurly backoff&quot;);
4707     }
4708 
4709     // This test is for 8012646
4710     private static void patternAsPredicate() throws Exception {
4711         Predicate&lt;String&gt; p = Pattern.compile(&quot;[a-z]+&quot;).asPredicate();
4712 
4713         if (p.test(&quot;&quot;)) {
4714             failCount++;
4715         }
4716         if (!p.test(&quot;word&quot;)) {
4717             failCount++;
4718         }
4719         if (p.test(&quot;1234&quot;)) {
4720             failCount++;
4721         }
4722         if (!p.test(&quot;word1234&quot;)) {
4723             failCount++;
4724         }
4725         report(&quot;Pattern.asPredicate&quot;);
4726     }
4727 
4728     // This test is for 8184692
4729     private static void patternAsMatchPredicate() throws Exception {
4730         Predicate&lt;String&gt; p = Pattern.compile(&quot;[a-z]+&quot;).asMatchPredicate();
4731 
4732         if (p.test(&quot;&quot;)) {
4733             failCount++;
4734         }
4735         if (!p.test(&quot;word&quot;)) {
4736             failCount++;
4737         }
4738         if (p.test(&quot;1234word&quot;)) {
4739             failCount++;
4740         }
4741         if (p.test(&quot;1234&quot;)) {
4742             failCount++;
4743         }
4744         report(&quot;Pattern.asMatchPredicate&quot;);
4745     }
4746 
4747 
4748     // This test is for 8035975
4749     private static void invalidFlags() throws Exception {
4750         for (int flag = 1; flag != 0; flag &lt;&lt;= 1) {
4751             switch (flag) {
4752             case Pattern.CASE_INSENSITIVE:
4753             case Pattern.MULTILINE:
4754             case Pattern.DOTALL:
4755             case Pattern.UNICODE_CASE:
4756             case Pattern.CANON_EQ:
4757             case Pattern.UNIX_LINES:
4758             case Pattern.LITERAL:
4759             case Pattern.UNICODE_CHARACTER_CLASS:
4760             case Pattern.COMMENTS:
4761                 // valid flag, continue
4762                 break;
4763             default:
4764                 try {
4765                     Pattern.compile(&quot;.&quot;, flag);
4766                     failCount++;
4767                 } catch (IllegalArgumentException expected) {
4768                 }
4769             }
4770         }
4771         report(&quot;Invalid compile flags&quot;);
4772     }
4773 
4774     // This test is for 8158482
4775     private static void embeddedFlags() throws Exception {
4776         try {
4777             Pattern.compile(&quot;(?i).(?-i).&quot;);
4778             Pattern.compile(&quot;(?m).(?-m).&quot;);
4779             Pattern.compile(&quot;(?s).(?-s).&quot;);
4780             Pattern.compile(&quot;(?d).(?-d).&quot;);
4781             Pattern.compile(&quot;(?u).(?-u).&quot;);
4782             Pattern.compile(&quot;(?c).(?-c).&quot;);
4783             Pattern.compile(&quot;(?x).(?-x).&quot;);
4784             Pattern.compile(&quot;(?U).(?-U).&quot;);
4785             Pattern.compile(&quot;(?imsducxU).(?-imsducxU).&quot;);
4786         } catch (PatternSyntaxException x) {
4787             failCount++;
4788         }
4789         report(&quot;Embedded flags&quot;);
4790     }
4791 
4792     private static void grapheme() throws Exception {
<a name="5" id="anc5"></a><span class="line-modified">4793         Files.lines(UCDFiles.GRAPHEME_BREAK_TEST)</span>

4794             .filter( ln -&gt; ln.length() != 0 &amp;&amp; !ln.startsWith(&quot;#&quot;) )
4795             .forEach( ln -&gt; {
<a name="6" id="anc6"></a><span class="line-modified">4796                     ln = ln.replaceAll(&quot;\\s+|\\([a-zA-Z]+\\)|\\[[a-zA-Z]]+\\]|#.*&quot;, &quot;&quot;);</span>
<span class="line-modified">4797                     // System.out.println(str);</span>
<span class="line-modified">4798                     String[] strs = ln.split(&quot;\u00f7|\u00d7&quot;);</span>
<span class="line-modified">4799                     StringBuilder src = new StringBuilder();</span>
<span class="line-modified">4800                     ArrayList&lt;String&gt; graphemes = new ArrayList&lt;&gt;();</span>
<span class="line-modified">4801                     StringBuilder buf = new StringBuilder();</span>
<span class="line-modified">4802                     int offBk = 0;</span>
<span class="line-modified">4803                     for (String str : strs) {</span>
<span class="line-modified">4804                         if (str.length() == 0)  // first empty str</span>
<span class="line-modified">4805                             continue;</span>
<span class="line-modified">4806                         int cp = Integer.parseInt(str, 16);</span>
<span class="line-modified">4807                         src.appendCodePoint(cp);</span>
<span class="line-modified">4808                         buf.appendCodePoint(cp);</span>
<span class="line-modified">4809                         offBk += (str.length() + 1);</span>
<span class="line-modified">4810                         if (ln.charAt(offBk) == &#39;\u00f7&#39;) {    // DIV</span>
<span class="line-modified">4811                             graphemes.add(buf.toString());</span>
<span class="line-modified">4812                             buf = new StringBuilder();</span>
<span class="line-removed">4813                         }</span>
4814                     }
<a name="7" id="anc7"></a><span class="line-modified">4815                     Pattern p = Pattern.compile(&quot;\\X&quot;);</span>
<span class="line-modified">4816                     Matcher m = p.matcher(src.toString());</span>
<span class="line-modified">4817                     Scanner s = new Scanner(src.toString()).useDelimiter(&quot;\\b{g}&quot;);</span>
<span class="line-modified">4818                     for (String g : graphemes) {</span>
<span class="line-modified">4819                         // System.out.printf(&quot;     grapheme:=[%s]%n&quot;, g);</span>
<span class="line-modified">4820                         // (1) test \\X directly</span>
<span class="line-modified">4821                         if (!m.find() || !m.group().equals(g)) {</span>
<span class="line-modified">4822                             System.out.println(&quot;Failed \\X [&quot; + ln + &quot;] : &quot; + g);</span>
<span class="line-modified">4823                             failCount++;</span>
<span class="line-modified">4824                         }</span>
<span class="line-removed">4825                         // (2) test \\b{g} + \\X  via Scanner</span>
<span class="line-removed">4826                         boolean hasNext = s.hasNext(p);</span>
<span class="line-removed">4827                         // if (!s.hasNext() || !s.next().equals(next)) {</span>
<span class="line-removed">4828                         if (!s.hasNext(p) || !s.next(p).equals(g)) {</span>
<span class="line-removed">4829                             System.out.println(&quot;Failed b{g} [&quot; + ln + &quot;] : &quot; + g);</span>
<span class="line-removed">4830                             failCount++;</span>
<span class="line-removed">4831                         }</span>
4832                     }
<a name="8" id="anc8"></a><span class="line-modified">4833                 });</span>








4834         // some sanity checks
4835         if (!Pattern.compile(&quot;\\X{10}&quot;).matcher(&quot;abcdefghij&quot;).matches() ||
4836             !Pattern.compile(&quot;\\b{g}(?:\\X\\b{g}){5}\\b{g}&quot;).matcher(&quot;abcde&quot;).matches() ||
4837             !Pattern.compile(&quot;(?:\\X\\b{g}){2}&quot;).matcher(&quot;\ud800\udc00\ud801\udc02&quot;).matches())
4838             failCount++;
4839         // make sure &quot;\b{n}&quot; still works
4840         if (!Pattern.compile(&quot;\\b{1}hello\\b{1} \\b{1}world\\b{1}&quot;).matcher(&quot;hello world&quot;).matches())
4841             failCount++;
4842         report(&quot;Unicode extended grapheme cluster&quot;);
4843     }
4844 
4845     // hangup/timeout if go into exponential backtracking
4846     private static void expoBacktracking() throws Exception {
4847 
4848         Object[][] patternMatchers = {
4849             // 6328855
4850             { &quot;(.*\n*)*&quot;,
4851               &quot;this little fine string lets\r\njava.lang.String.matches\r\ncrash\r\n(We don&#39;t know why but adding \r* to the regex makes it work again)&quot;,
4852               false },
4853             // 6192895
4854             { &quot; *([a-zA-Z0-9/\\-\\?:\\(\\)\\.,&#39;\\+\\{\\}]+ *)+&quot;,
4855               &quot;Hello World this is a test this is a test this is a test A&quot;,
4856               true },
4857             { &quot; *([a-zA-Z0-9/\\-\\?:\\(\\)\\.,&#39;\\+\\{\\}]+ *)+&quot;,
4858               &quot;Hello World this is a test this is a test this is a test \u4e00 &quot;,
4859               false },
4860             { &quot; *([a-z0-9]+ *)+&quot;,
4861               &quot;hello world this is a test this is a test this is a test A&quot;,
4862               false },
4863             // 4771934 [FIXED] #5013651?
4864             { &quot;^(\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,4})+[,;]?)+$&quot;,
4865               &quot;abc@efg.abc,efg@abc.abc,abc@xyz.mno;abc@sdfsd.com&quot;,
4866               true },
4867             // 4866249 [FIXED]
4868             { &quot;&lt;\\s*&quot; + &quot;(meta|META)&quot; + &quot;(\\s|[^&gt;])+&quot; + &quot;(CHARSET|charset)=&quot; + &quot;(\\s|[^&gt;])+&gt;&quot;,
4869               &quot;&lt;META http-equiv=\&quot;Content-Type\&quot; content=\&quot;text/html; charset=ISO-8859-5\&quot;&gt;&quot;,
4870               true },
4871             { &quot;^(\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,4})+[,;]?)+$&quot;,
4872               &quot;abc@efg.abc,efg@abc.abc,abc@xyz.mno;sdfsd.com&quot;,
4873               false },
4874             // 6345469
4875             { &quot;((&lt;[^&gt;]+&gt;)?(((\\s)?)*(\\&amp;nbsp;)?)*((\\s)?)*)+&quot;,
4876               &quot;&amp;nbsp;&amp;nbsp; &lt; br/&gt; &amp;nbsp; &lt; / p&gt; &lt;p&gt; &lt;html&gt; &lt;adfasfdasdf&gt;&amp;nbsp; &lt;/p&gt;&quot;,
4877               true }, // --&gt; matched
4878             { &quot;((&lt;[^&gt;]+&gt;)?(((\\s)?)*(\\&amp;nbsp;)?)*((\\s)?)*)+&quot;,
4879               &quot;&amp;nbsp;&amp;nbsp; &lt; br/&gt; &amp;nbsp; &lt; / p&gt; &lt;p&gt; &lt;html&gt; &lt;adfasfdasdf&gt;&amp;nbsp; p &lt;/p&gt;&quot;,
4880               false },
4881             // 5026912
4882             { &quot;^\\s*&quot; + &quot;(\\w|\\d|[\\xC0-\\xFF]|/)+&quot; + &quot;\\s+|$&quot;,
4883               &quot;156580451111112225588087755221111111566969655555555&quot;,
4884               false},
4885             // 6988218
4886             { &quot;^([+-]?((0[xX](\\p{XDigit}+))|(((\\p{Digit}+)(\\.)?((\\p{Digit}+)?)([eE][+-]?(\\p{Digit}+))?)|(\\.((\\p{Digit}+))([eE][+-]?(\\p{Digit}+))?)))|[n|N]?&#39;([^&#39;]*(?:&#39;&#39;)*[^&#39;]*)*&#39;)&quot;,
4887               &quot;&#39;%)) order by ANGEBOT.ID&quot;,
4888               false},    // find
4889             // 6693451
4890             { &quot;^(\\s*foo\\s*)*$&quot;,
4891               &quot;foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo&quot;,
4892               true },
4893             { &quot;^(\\s*foo\\s*)*$&quot;,
4894               &quot;foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo fo&quot;,
4895               false
4896             },
4897             // 7006761
4898             { &quot;(([0-9A-Z]+)([_]?+)*)*&quot;, &quot;FOOOOO_BAAAR_FOOOOOOOOO_BA_&quot;, true},
4899             { &quot;(([0-9A-Z]+)([_]?+)*)*&quot;, &quot;FOOOOO_BAAAR_FOOOOOOOOO_BA_ &quot;, false},
4900             // 8140212
4901             { &quot;(?&lt;before&gt;.*)\\{(?&lt;reflection&gt;\\w+):(?&lt;innerMethod&gt;\\w+(\\.?\\w+(\\(((?&lt;args&gt;((&#39;[^&#39;]*&#39;)|((/|\\w)+))(,((&#39;[^&#39;]*&#39;)|((/|\\w)+)))*))?\\))?)*)\\}(?&lt;after&gt;.*)&quot;,
4902               &quot;{CeGlobal:getSodCutoff.getGui.getAmqp.getSimpleModeEnabled()&quot;,
4903               false
4904             },
4905             { &quot;^(a+)+$&quot;, &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;, true},
4906             { &quot;^(a+)+$&quot;, &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa!&quot;, false},
4907 
4908             { &quot;(x+)*y&quot;,  &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxy&quot;, true },
4909             { &quot;(x+)*y&quot;,  &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz&quot;, false},
4910 
4911             { &quot;(x+x+)+y&quot;, &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxy&quot;, true},
4912             { &quot;(x+x+)+y&quot;, &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz&quot;, false},
4913 
4914             { &quot;(([0-9A-Z]+)([_]?+)*)*&quot;, &quot;--------------------------------------&quot;, false},
4915 
4916             /* not fixed
4917             //8132141   ---&gt;    second level exponential backtracking
4918             { &quot;(h|h|ih(((i|a|c|c|a|i|i|j|b|a|i|b|a|a|j))+h)ahbfhba|c|i)*&quot;,
4919               &quot;hchcchicihcchciiicichhcichcihcchiihichiciiiihhcchicchhcihchcihiihciichhccciccichcichiihcchcihhicchcciicchcccihiiihhihihihichicihhcciccchihhhcchichchciihiicihciihcccciciccicciiiiiiiiicihhhiiiihchccchchhhhiiihchihcccchhhiiiiiiiicicichicihcciciihichhhhchihciiihhiccccccciciihhichiccchhicchicihihccichicciihcichccihhiciccccccccichhhhihihhcchchihihiihhihihihicichihiiiihhhhihhhchhichiicihhiiiiihchccccchichci&quot; },
4920             */
4921         };
4922 
4923         for (Object[] pm : patternMatchers) {
4924             String p = (String)pm[0];
4925             String s = (String)pm[1];
4926             boolean r = (Boolean)pm[2];
4927             if (r != Pattern.compile(p).matcher(s).matches()) {
4928                 failCount++;
4929             }
4930         }
4931     }
4932 
4933     private static void invalidGroupName() {
4934         // Invalid start of a group name
4935         for (String groupName : List.of(&quot;&quot;, &quot;.&quot;, &quot;0&quot;, &quot;\u0040&quot;, &quot;\u005b&quot;,
4936                 &quot;\u0060&quot;, &quot;\u007b&quot;, &quot;\u0416&quot;)) {
4937             for (String pat : List.of(&quot;(?&lt;&quot; + groupName + &quot;&gt;)&quot;,
4938                     &quot;\\k&lt;&quot; + groupName + &quot;&gt;&quot;)) {
4939                 try {
4940                     Pattern.compile(pat);
4941                     failCount++;
4942                 } catch (PatternSyntaxException e) {
4943                     if (!e.getMessage().startsWith(
4944                             &quot;capturing group name does not start with a&quot;
4945                             + &quot; Latin letter&quot;)) {
4946                         failCount++;
4947                     }
4948                 }
4949             }
4950         }
4951         // Invalid char in a group name
4952         for (String groupName : List.of(&quot;a.&quot;, &quot;b\u0040&quot;, &quot;c\u005b&quot;,
4953                 &quot;d\u0060&quot;, &quot;e\u007b&quot;, &quot;f\u0416&quot;)) {
4954             for (String pat : List.of(&quot;(?&lt;&quot; + groupName + &quot;&gt;)&quot;,
4955                     &quot;\\k&lt;&quot; + groupName + &quot;&gt;&quot;)) {
4956                 try {
4957                     Pattern.compile(pat);
4958                     failCount++;
4959                 } catch (PatternSyntaxException e) {
4960                     if (!e.getMessage().startsWith(
4961                             &quot;named capturing group is missing trailing &#39;&gt;&#39;&quot;)) {
4962                         failCount++;
4963                     }
4964                 }
4965             }
4966         }
4967         report(&quot;Invalid capturing group names&quot;);
4968     }
4969 
4970     private static void illegalRepetitionRange() {
4971         // huge integers &gt; (2^31 - 1)
4972         String n = BigInteger.valueOf(1L &lt;&lt; 32)
4973             .toString();
4974         String m = BigInteger.valueOf(1L &lt;&lt; 31)
4975             .add(new BigInteger(80, generator))
4976             .toString();
4977         for (String rep : List.of(&quot;&quot;, &quot;x&quot;, &quot;.&quot;, &quot;,&quot;, &quot;-1&quot;, &quot;2,1&quot;,
4978                 n, n + &quot;,&quot;, &quot;0,&quot; + n, n + &quot;,&quot; + m, m, m + &quot;,&quot;, &quot;0,&quot; + m)) {
4979             String pat = &quot;.{&quot; + rep + &quot;}&quot;;
4980             try {
4981                 Pattern.compile(pat);
4982                 failCount++;
4983                 System.out.println(&quot;Expected to fail. Pattern: &quot; + pat);
4984             } catch (PatternSyntaxException e) {
4985                 if (!e.getMessage().startsWith(&quot;Illegal repetition&quot;)) {
4986                     failCount++;
4987                     System.out.println(&quot;Unexpected error message: &quot; + e.getMessage());
4988                 }
4989             } catch (Throwable t) {
4990                 failCount++;
4991                 System.out.println(&quot;Unexpected exception: &quot; + t);
4992             }
4993         }
4994         report(&quot;illegalRepetitionRange&quot;);
4995     }
4996 
4997     private static void surrogatePairWithCanonEq() {
4998         try {
4999             Pattern.compile(&quot;\ud834\udd21&quot;, Pattern.CANON_EQ);
5000         } catch (Throwable t) {
5001             failCount++;
5002             System.out.println(&quot;Unexpected exception: &quot; + t);
5003         }
5004         report(&quot;surrogatePairWithCanonEq&quot;);
5005     }
5006 
5007     // This test is for 8235812
5008     private static void lineBreakWithQuantifier() {
5009         // key:    pattern
5010         // value:  lengths of input that must match the pattern
5011         Map&lt;String, List&lt;Integer&gt;&gt; cases = Map.ofEntries(
5012             Map.entry(&quot;\\R?&quot;,      List.of(0, 1)),
5013             Map.entry(&quot;\\R*&quot;,      List.of(0, 1, 2, 3)),
5014             Map.entry(&quot;\\R+&quot;,      List.of(1, 2, 3)),
5015             Map.entry(&quot;\\R{0}&quot;,    List.of(0)),
5016             Map.entry(&quot;\\R{1}&quot;,    List.of(1)),
5017             Map.entry(&quot;\\R{2}&quot;,    List.of(2)),
5018             Map.entry(&quot;\\R{3}&quot;,    List.of(3)),
5019             Map.entry(&quot;\\R{0,}&quot;,   List.of(0, 1, 2, 3)),
5020             Map.entry(&quot;\\R{1,}&quot;,   List.of(1, 2, 3)),
5021             Map.entry(&quot;\\R{2,}&quot;,   List.of(2, 3)),
5022             Map.entry(&quot;\\R{3,}&quot;,   List.of(3)),
5023             Map.entry(&quot;\\R{0,0}&quot;,  List.of(0)),
5024             Map.entry(&quot;\\R{0,1}&quot;,  List.of(0, 1)),
5025             Map.entry(&quot;\\R{0,2}&quot;,  List.of(0, 1, 2)),
5026             Map.entry(&quot;\\R{0,3}&quot;,  List.of(0, 1, 2, 3)),
5027             Map.entry(&quot;\\R{1,1}&quot;,  List.of(1)),
5028             Map.entry(&quot;\\R{1,2}&quot;,  List.of(1, 2)),
5029             Map.entry(&quot;\\R{1,3}&quot;,  List.of(1, 2, 3)),
5030             Map.entry(&quot;\\R{2,2}&quot;,  List.of(2)),
5031             Map.entry(&quot;\\R{2,3}&quot;,  List.of(2, 3)),
5032             Map.entry(&quot;\\R{3,3}&quot;,  List.of(3)),
5033             Map.entry(&quot;\\R&quot;,       List.of(1)),
5034             Map.entry(&quot;\\R\\R&quot;,    List.of(2)),
5035             Map.entry(&quot;\\R\\R\\R&quot;, List.of(3))
5036         );
5037 
5038         // key:    length of input
5039         // value:  all possible inputs of given length
5040         Map&lt;Integer, List&lt;String&gt;&gt; inputs = new HashMap&lt;&gt;();
5041         String[] Rs = { &quot;\r\n&quot;, &quot;\r&quot;, &quot;\n&quot;,
5042                         &quot;\u000B&quot;, &quot;\u000C&quot;, &quot;\u0085&quot;, &quot;\u2028&quot;, &quot;\u2029&quot; };
5043         StringBuilder sb = new StringBuilder();
5044         for (int len = 0; len &lt;= 3; ++len) {
5045             int[] idx = new int[len + 1];
5046             do {
5047                 sb.setLength(0);
5048                 for (int j = 0; j &lt; len; ++j)
5049                     sb.append(Rs[idx[j]]);
5050                 inputs.computeIfAbsent(len, ArrayList::new).add(sb.toString());
5051                 idx[0]++;
5052                 for (int j = 0; j &lt; len; ++j) {
5053                     if (idx[j] &lt; Rs.length)
5054                         break;
5055                     idx[j] = 0;
5056                     idx[j+1]++;
5057                 }
5058             } while (idx[len] == 0);
5059         }
5060 
5061         // exhaustive testing
5062         for (String patStr : cases.keySet()) {
5063             Pattern[] pats = patStr.endsWith(&quot;R&quot;)
5064                 ? new Pattern[] { Pattern.compile(patStr) }  // no quantifiers
5065                 : new Pattern[] { Pattern.compile(patStr),          // greedy
5066                                   Pattern.compile(patStr + &quot;?&quot;) };  // reluctant
5067             Matcher m = pats[0].matcher(&quot;&quot;);
5068             for (Pattern p : pats) {
5069                 m.usePattern(p);
5070                 for (int len : cases.get(patStr)) {
5071                     for (String in : inputs.get(len)) {
5072                         if (!m.reset(in).matches()) {
5073                             failCount++;
5074                             System.err.println(&quot;Expected to match &#39;&quot; +
5075                                     in + &quot;&#39; =~ /&quot; + p + &quot;/&quot;);
5076                         }
5077                     }
5078                 }
5079             }
5080         }
5081         report(&quot;lineBreakWithQuantifier&quot;);
5082     }
<a name="9" id="anc9"></a>



































































5083 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBlitLoops.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="MTLUtils.m.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBlitLoops.m</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
158     id&lt;MTLRenderCommandEncoder&gt; encoder = [mtlc.encoderManager getTextureEncoder:dst
159                                                                      isSrcOpaque:isSrcOpaque
160                                                                      isDstOpaque:isDstOpaque
161                                                                    interpolation:hint
162     ];
163 
164     struct TxtVertex quadTxVerticesBuffer[6];
165     fillTxQuad(quadTxVerticesBuffer, sx1, sy1, sx2, sy2, src.width, src.height, dx1, dy1, dx2, dy2, dst.width, dst.height);
166 
167     [encoder setVertexBytes:quadTxVerticesBuffer length:sizeof(quadTxVerticesBuffer) atIndex:MeshVertexBuffer];
168     [encoder setFragmentTexture:src atIndex: 0];
169     [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];
170 }
171 
172 static
173 id&lt;MTLTexture&gt; replaceTextureRegion(id&lt;MTLTexture&gt; dest, const SurfaceDataRasInfo * srcInfo, const MTLRasterFormatInfo * rfi, int dx1, int dy1, int dx2, int dy2) {
174     const int dw = dx2 - dx1;
175     const int dh = dy2 - dy1;
176 
177     const void * raster = srcInfo-&gt;rasBase;


178     id&lt;MTLTexture&gt; result = nil;
179     if (rfi-&gt;permuteMap != NULL) {
180 #if defined(__MAC_10_15) &amp;&amp; __MAC_OS_X_VERSION_MAX_ALLOWED &gt;= __MAC_10_15
181         if (@available(macOS 10.15, *)) {
182             @autoreleasepool {
183                 const uint8_t swzRed = revertPerm(rfi-&gt;permuteMap, 1);
184                 const uint8_t swzGreen = revertPerm(rfi-&gt;permuteMap, 2);
185                 const uint8_t swzBlue = revertPerm(rfi-&gt;permuteMap, 3);
186                 const uint8_t swzAlpha = revertPerm(rfi-&gt;permuteMap, 0);
187                 MTLTextureSwizzleChannels swizzle = MTLTextureSwizzleChannelsMake(
188                         uint2swizzle(swzRed),
189                         uint2swizzle(swzGreen),
190                         uint2swizzle(swzBlue),
191                         rfi-&gt;hasAlpha ? uint2swizzle(swzAlpha) : MTLTextureSwizzleOne
192                 );
193                 result = [dest
194                         newTextureViewWithPixelFormat:MTLPixelFormatBGRA8Unorm
195                         textureType:MTLTextureType2D
196                         levels:NSMakeRange(0, 1) slices:NSMakeRange(0, 1)
197                         swizzle:swizzle];
</pre>
<hr />
<pre>
204             // perform raster conversion
205             // invoked only from rq-thread, so use static buffers
206             // but it&#39;s better to use thread-local buffers (or special buffer manager)
207             const int destRasterSize = dw*dh*4;
208 
209             static int bufferSize = 0;
210             static void * buffer = NULL;
211             if (buffer == NULL || bufferSize &lt; destRasterSize) {
212                 bufferSize = destRasterSize;
213                 buffer = realloc(buffer, bufferSize);
214             }
215             if (buffer == NULL) {
216                 J2dTraceLn1(J2D_TRACE_ERROR, &quot;replaceTextureRegion: can&#39;t alloc buffer for raster conversion, size=%d&quot;, bufferSize);
217                 bufferSize = 0;
218                 return nil;
219             }
220             vImage_Buffer srcBuf;
221             srcBuf.height = dh;
222             srcBuf.width = dw;
223             srcBuf.rowBytes = srcInfo-&gt;scanStride;
<span class="line-modified">224             srcBuf.data = srcInfo-&gt;rasBase;</span>
225 
226             vImage_Buffer destBuf;
227             destBuf.height = dh;
228             destBuf.width = dw;
229             destBuf.rowBytes = dw*4;
230             destBuf.data = buffer;
231 
232             vImagePermuteChannels_ARGB8888(&amp;srcBuf, &amp;destBuf, rfi-&gt;permuteMap, kvImageNoFlags);
233             raster = buffer;
234 
235             J2dTraceLn5(J2D_TRACE_VERBOSE, &quot;replaceTextureRegion [use conversion]: %d, %d, %d, %d, hasA=%d&quot;,
236                         rfi-&gt;permuteMap[0], rfi-&gt;permuteMap[1], rfi-&gt;permuteMap[2], rfi-&gt;permuteMap[3], rfi-&gt;hasAlpha);
237         }
238     }
239 
240     MTLRegion region = MTLRegionMake2D(dx1, dy1, dw, dh);
241     if (result != nil)
242         dest = result;
243     [dest replaceRegion:region mipmapLevel:0 withBytes:raster bytesPerRow:srcInfo-&gt;scanStride];
244     return result;
</pre>
<hr />
<pre>
337         const int maxY = clipRect-&gt;y + clipRect-&gt;height;
338         if (dcy2 &gt; maxY)
339             dcy2 = maxY;
340 
341         if (dcx1 &gt;= dcx2) {
342             J2dTraceLn2(J2D_TRACE_ERROR, &quot;\tclipDestCoords: dcx1=%1.2f, dcx2=%1.2f&quot;, dcx1, dcx2);
343             dcx1 = dcx2;
344         }
345         if (dcy1 &gt;= dcy2) {
346             J2dTraceLn2(J2D_TRACE_ERROR, &quot;\tclipDestCoords: dcy1=%1.2f, dcy2=%1.2f&quot;, dcy1, dcy2);
347             dcy1 = dcy2;
348         }
349     }
350     if (*dx2 &lt;= dcx1 || *dx1 &gt;= dcx2 || *dy2 &lt;= dcy1 || *dy1 &gt;= dcy2) {
351         J2dTraceLn(J2D_TRACE_INFO, &quot;\tclipDestCoords: dest rect doesn&#39;t intersect clip area&quot;);
352         J2dTraceLn4(J2D_TRACE_INFO, &quot;\tdx2=%1.4f &lt;= dcx1=%1.4f || *dx1=%1.4f &gt;= dcx2=%1.4f&quot;, *dx2, dcx1, *dx1, dcx2);
353         J2dTraceLn4(J2D_TRACE_INFO, &quot;\t*dy2=%1.4f &lt;= dcy1=%1.4f || *dy1=%1.4f &gt;= dcy2=%1.4f&quot;, *dy2, dcy1, *dy1, dcy2);
354         return JNI_FALSE;
355     }
356     if (*dx1 &lt; dcx1) {
<span class="line-modified">357         J2dTraceLn2(J2D_TRACE_VERBOSE, &quot;\t\tdx1=%1.2f, will be clipped to %1.2f&quot;, *dx1, dcx1);</span>
358         *sx1 += (jint)((dcx1 - *dx1) * (sw/dw));
359         *dx1 = dcx1;
360     }
361     if (*dx2 &gt; dcx2) {
<span class="line-modified">362         J2dTraceLn2(J2D_TRACE_VERBOSE, &quot;\t\tdx2=%1.2f, will be clipped to %1.2f&quot;, *dx2, dcx2);</span>
363         *sx2 -= (jint)((*dx2 - dcx2) * (sw/dw));
364         *dx2 = dcx2;
365     }
366     if (*dy1 &lt; dcy1) {
<span class="line-modified">367         J2dTraceLn2(J2D_TRACE_VERBOSE, &quot;\t\tdy1=%1.2f, will be clipped to %1.2f&quot;, *dy1, dcy1);</span>
368         *sy1 += (jint)((dcy1 - *dy1) * (sh/dh));
369         *dy1 = dcy1;
370     }
371     if (*dy2 &gt; dcy2) {
<span class="line-modified">372         J2dTraceLn2(J2D_TRACE_VERBOSE, &quot;\t\tdy2=%1.2f, will be clipped to %1.2f&quot;, *dy2, dcy2);</span>
373         *sy2 -= (jint)((*dy2 - dcy2) * (sh/dh));
374         *dy2 = dcy2;
375     }
376     return JNI_TRUE;
377 }
378 
379 /**
380  * General blit method for copying a native MTL surface to another MTL &quot;Surface&quot;.
381  * Parameter texture == true forces to use &#39;texture&#39; codepath (dest coordinates will always be integers).
382  * Parameter xform == true only when AffineTransform is used (invoked only from TransformBlit, dest coordinates will always be integers).
383  */
384 void
385 MTLBlitLoops_IsoBlit(JNIEnv *env,
386                      MTLContext *mtlc, jlong pSrcOps, jlong pDstOps,
387                      jboolean xform, jint hint, jboolean texture,
388                      jint sx1, jint sy1, jint sx2, jint sy2,
389                      jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)
390 {
391     BMTLSDOps *srcOps = (BMTLSDOps *)jlong_to_ptr(pSrcOps);
392     BMTLSDOps *dstOps = (BMTLSDOps *)jlong_to_ptr(pDstOps);
</pre>
</td>
<td>
<hr />
<pre>
158     id&lt;MTLRenderCommandEncoder&gt; encoder = [mtlc.encoderManager getTextureEncoder:dst
159                                                                      isSrcOpaque:isSrcOpaque
160                                                                      isDstOpaque:isDstOpaque
161                                                                    interpolation:hint
162     ];
163 
164     struct TxtVertex quadTxVerticesBuffer[6];
165     fillTxQuad(quadTxVerticesBuffer, sx1, sy1, sx2, sy2, src.width, src.height, dx1, dy1, dx2, dy2, dst.width, dst.height);
166 
167     [encoder setVertexBytes:quadTxVerticesBuffer length:sizeof(quadTxVerticesBuffer) atIndex:MeshVertexBuffer];
168     [encoder setFragmentTexture:src atIndex: 0];
169     [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];
170 }
171 
172 static
173 id&lt;MTLTexture&gt; replaceTextureRegion(id&lt;MTLTexture&gt; dest, const SurfaceDataRasInfo * srcInfo, const MTLRasterFormatInfo * rfi, int dx1, int dy1, int dx2, int dy2) {
174     const int dw = dx2 - dx1;
175     const int dh = dy2 - dy1;
176 
177     const void * raster = srcInfo-&gt;rasBase;
<span class="line-added">178     raster += srcInfo-&gt;bounds.y1*srcInfo-&gt;scanStride + srcInfo-&gt;bounds.x1*srcInfo-&gt;pixelStride;</span>
<span class="line-added">179 </span>
180     id&lt;MTLTexture&gt; result = nil;
181     if (rfi-&gt;permuteMap != NULL) {
182 #if defined(__MAC_10_15) &amp;&amp; __MAC_OS_X_VERSION_MAX_ALLOWED &gt;= __MAC_10_15
183         if (@available(macOS 10.15, *)) {
184             @autoreleasepool {
185                 const uint8_t swzRed = revertPerm(rfi-&gt;permuteMap, 1);
186                 const uint8_t swzGreen = revertPerm(rfi-&gt;permuteMap, 2);
187                 const uint8_t swzBlue = revertPerm(rfi-&gt;permuteMap, 3);
188                 const uint8_t swzAlpha = revertPerm(rfi-&gt;permuteMap, 0);
189                 MTLTextureSwizzleChannels swizzle = MTLTextureSwizzleChannelsMake(
190                         uint2swizzle(swzRed),
191                         uint2swizzle(swzGreen),
192                         uint2swizzle(swzBlue),
193                         rfi-&gt;hasAlpha ? uint2swizzle(swzAlpha) : MTLTextureSwizzleOne
194                 );
195                 result = [dest
196                         newTextureViewWithPixelFormat:MTLPixelFormatBGRA8Unorm
197                         textureType:MTLTextureType2D
198                         levels:NSMakeRange(0, 1) slices:NSMakeRange(0, 1)
199                         swizzle:swizzle];
</pre>
<hr />
<pre>
206             // perform raster conversion
207             // invoked only from rq-thread, so use static buffers
208             // but it&#39;s better to use thread-local buffers (or special buffer manager)
209             const int destRasterSize = dw*dh*4;
210 
211             static int bufferSize = 0;
212             static void * buffer = NULL;
213             if (buffer == NULL || bufferSize &lt; destRasterSize) {
214                 bufferSize = destRasterSize;
215                 buffer = realloc(buffer, bufferSize);
216             }
217             if (buffer == NULL) {
218                 J2dTraceLn1(J2D_TRACE_ERROR, &quot;replaceTextureRegion: can&#39;t alloc buffer for raster conversion, size=%d&quot;, bufferSize);
219                 bufferSize = 0;
220                 return nil;
221             }
222             vImage_Buffer srcBuf;
223             srcBuf.height = dh;
224             srcBuf.width = dw;
225             srcBuf.rowBytes = srcInfo-&gt;scanStride;
<span class="line-modified">226             srcBuf.data = raster;</span>
227 
228             vImage_Buffer destBuf;
229             destBuf.height = dh;
230             destBuf.width = dw;
231             destBuf.rowBytes = dw*4;
232             destBuf.data = buffer;
233 
234             vImagePermuteChannels_ARGB8888(&amp;srcBuf, &amp;destBuf, rfi-&gt;permuteMap, kvImageNoFlags);
235             raster = buffer;
236 
237             J2dTraceLn5(J2D_TRACE_VERBOSE, &quot;replaceTextureRegion [use conversion]: %d, %d, %d, %d, hasA=%d&quot;,
238                         rfi-&gt;permuteMap[0], rfi-&gt;permuteMap[1], rfi-&gt;permuteMap[2], rfi-&gt;permuteMap[3], rfi-&gt;hasAlpha);
239         }
240     }
241 
242     MTLRegion region = MTLRegionMake2D(dx1, dy1, dw, dh);
243     if (result != nil)
244         dest = result;
245     [dest replaceRegion:region mipmapLevel:0 withBytes:raster bytesPerRow:srcInfo-&gt;scanStride];
246     return result;
</pre>
<hr />
<pre>
339         const int maxY = clipRect-&gt;y + clipRect-&gt;height;
340         if (dcy2 &gt; maxY)
341             dcy2 = maxY;
342 
343         if (dcx1 &gt;= dcx2) {
344             J2dTraceLn2(J2D_TRACE_ERROR, &quot;\tclipDestCoords: dcx1=%1.2f, dcx2=%1.2f&quot;, dcx1, dcx2);
345             dcx1 = dcx2;
346         }
347         if (dcy1 &gt;= dcy2) {
348             J2dTraceLn2(J2D_TRACE_ERROR, &quot;\tclipDestCoords: dcy1=%1.2f, dcy2=%1.2f&quot;, dcy1, dcy2);
349             dcy1 = dcy2;
350         }
351     }
352     if (*dx2 &lt;= dcx1 || *dx1 &gt;= dcx2 || *dy2 &lt;= dcy1 || *dy1 &gt;= dcy2) {
353         J2dTraceLn(J2D_TRACE_INFO, &quot;\tclipDestCoords: dest rect doesn&#39;t intersect clip area&quot;);
354         J2dTraceLn4(J2D_TRACE_INFO, &quot;\tdx2=%1.4f &lt;= dcx1=%1.4f || *dx1=%1.4f &gt;= dcx2=%1.4f&quot;, *dx2, dcx1, *dx1, dcx2);
355         J2dTraceLn4(J2D_TRACE_INFO, &quot;\t*dy2=%1.4f &lt;= dcy1=%1.4f || *dy1=%1.4f &gt;= dcy2=%1.4f&quot;, *dy2, dcy1, *dy1, dcy2);
356         return JNI_FALSE;
357     }
358     if (*dx1 &lt; dcx1) {
<span class="line-modified">359         J2dTraceLn3(J2D_TRACE_VERBOSE, &quot;\t\tdx1=%1.2f, will be clipped to %1.2f | sx1+=%d&quot;, *dx1, dcx1, (jint)((dcx1 - *dx1) * (sw/dw)));</span>
360         *sx1 += (jint)((dcx1 - *dx1) * (sw/dw));
361         *dx1 = dcx1;
362     }
363     if (*dx2 &gt; dcx2) {
<span class="line-modified">364         J2dTraceLn3(J2D_TRACE_VERBOSE, &quot;\t\tdx2=%1.2f, will be clipped to %1.2f | sx2-=%d&quot;, *dx2, dcx2, (jint)((*dx2 - dcx2) * (sw/dw)));</span>
365         *sx2 -= (jint)((*dx2 - dcx2) * (sw/dw));
366         *dx2 = dcx2;
367     }
368     if (*dy1 &lt; dcy1) {
<span class="line-modified">369         J2dTraceLn3(J2D_TRACE_VERBOSE, &quot;\t\tdy1=%1.2f, will be clipped to %1.2f | sy1+=%d&quot;, *dy1, dcy1, (jint)((dcy1 - *dy1) * (sh/dh)));</span>
370         *sy1 += (jint)((dcy1 - *dy1) * (sh/dh));
371         *dy1 = dcy1;
372     }
373     if (*dy2 &gt; dcy2) {
<span class="line-modified">374         J2dTraceLn3(J2D_TRACE_VERBOSE, &quot;\t\tdy2=%1.2f, will be clipped to %1.2f | sy2-=%d&quot;, *dy2, dcy2, (jint)((*dy2 - dcy2) * (sh/dh)));</span>
375         *sy2 -= (jint)((*dy2 - dcy2) * (sh/dh));
376         *dy2 = dcy2;
377     }
378     return JNI_TRUE;
379 }
380 
381 /**
382  * General blit method for copying a native MTL surface to another MTL &quot;Surface&quot;.
383  * Parameter texture == true forces to use &#39;texture&#39; codepath (dest coordinates will always be integers).
384  * Parameter xform == true only when AffineTransform is used (invoked only from TransformBlit, dest coordinates will always be integers).
385  */
386 void
387 MTLBlitLoops_IsoBlit(JNIEnv *env,
388                      MTLContext *mtlc, jlong pSrcOps, jlong pDstOps,
389                      jboolean xform, jint hint, jboolean texture,
390                      jint sx1, jint sy1, jint sx2, jint sy2,
391                      jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)
392 {
393     BMTLSDOps *srcOps = (BMTLSDOps *)jlong_to_ptr(pSrcOps);
394     BMTLSDOps *dstOps = (BMTLSDOps *)jlong_to_ptr(pDstOps);
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="MTLUtils.m.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
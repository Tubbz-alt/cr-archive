<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLRenderQueue.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #ifndef HEADLESS
  27 
  28 #include &lt;stdlib.h&gt;
  29 
  30 #include &quot;sun_java2d_pipe_BufferedOpCodes.h&quot;
  31 
  32 #include &quot;jlong.h&quot;
  33 #include &quot;MTLBlitLoops.h&quot;
  34 #include &quot;MTLBufImgOps.h&quot;
  35 #include &quot;MTLMaskBlit.h&quot;
  36 #include &quot;MTLMaskFill.h&quot;
  37 #include &quot;MTLPaints.h&quot;
  38 #include &quot;MTLRenderQueue.h&quot;
  39 #include &quot;MTLRenderer.h&quot;
  40 #include &quot;MTLTextRenderer.h&quot;
  41 #import &quot;ThreadUtilities.h&quot;
  42 
  43 /**
  44  * References to the &quot;current&quot; context and destination surface.
  45  */
  46 static MTLContext *mtlc = NULL;
  47 static BMTLSDOps *dstOps = NULL;
  48 jint mtlPreviousOp = MTL_OP_INIT;
  49 
  50 /**
  51  * The following methods are implemented in the windowing system (i.e. GLX
  52  * and WGL) source files.
  53  */
  54 extern void MTLGC_DestroyMTLGraphicsConfig(jlong pConfigInfo);
  55 extern void MTLSD_SwapBuffers(JNIEnv *env, jlong window);
  56 
  57 // TODO : Debug logic added for opcode verification,
  58 // should be removed later.
  59 static char *getOpcodeString(jint opcode) {
  60     static char opName[30];
  61     switch (opcode) {
  62         case sun_java2d_pipe_BufferedOpCodes_DRAW_LINE:
  63             {
  64                 strcpy(opName, &quot;DRAW_LINE&quot;);
  65             }
  66             break;
  67         case sun_java2d_pipe_BufferedOpCodes_DRAW_RECT:
  68             {
  69                 strcpy(opName, &quot;DRAW_RECT&quot;);
  70             }
  71             break;
  72         case sun_java2d_pipe_BufferedOpCodes_DRAW_POLY:
  73             {
  74                 strcpy(opName, &quot;DRAW_POLY&quot;);
  75             }
  76             break;
  77         case sun_java2d_pipe_BufferedOpCodes_DRAW_PIXEL:
  78             {
  79                 strcpy(opName, &quot;DRAW_PIXEL&quot;);
  80             }
  81             break;
  82         case sun_java2d_pipe_BufferedOpCodes_DRAW_SCANLINES:
  83             {
  84                 strcpy(opName, &quot;DRAW_SCANLINES&quot;);
  85             }
  86             break;
  87         case sun_java2d_pipe_BufferedOpCodes_DRAW_PARALLELOGRAM:
  88             {
  89                 strcpy(opName, &quot;DRAW_PARALLELOGRAM&quot;);
  90             }
  91             break;
  92         case sun_java2d_pipe_BufferedOpCodes_DRAW_AAPARALLELOGRAM:
  93             {
  94                 strcpy(opName, &quot;DRAW_AAPARALLELOGRAM&quot;);
  95             }
  96             break;
  97         case sun_java2d_pipe_BufferedOpCodes_FILL_RECT:
  98             {
  99                 strcpy(opName, &quot;FILL_RECT&quot;);
 100             }
 101             break;
 102         case sun_java2d_pipe_BufferedOpCodes_FILL_SPANS:
 103             {
 104                 strcpy(opName, &quot;FILL_SPANS&quot;);
 105             }
 106             break;
 107         case sun_java2d_pipe_BufferedOpCodes_FILL_PARALLELOGRAM:
 108             {
 109                 strcpy(opName, &quot;FILL_PARALLELOGRAM&quot;);
 110             }
 111             break;
 112         case sun_java2d_pipe_BufferedOpCodes_FILL_AAPARALLELOGRAM:
 113             {
 114                 strcpy(opName, &quot;FILL_AAPARALLELOGRAM&quot;);
 115             }
 116             break;
 117         case sun_java2d_pipe_BufferedOpCodes_DRAW_GLYPH_LIST:
 118             {
 119                 strcpy(opName, &quot;DRAW_GLYPH_LIST&quot;);
 120             }
 121             break;
 122         case sun_java2d_pipe_BufferedOpCodes_COPY_AREA:
 123             {
 124                 strcpy(opName, &quot;COPY_AREA&quot;);
 125             }
 126             break;
 127         case sun_java2d_pipe_BufferedOpCodes_BLIT:
 128             {
 129                 strcpy(opName, &quot;BLIT&quot;);
 130             }
 131             break;
 132         case sun_java2d_pipe_BufferedOpCodes_SURFACE_TO_SW_BLIT:
 133             {
 134                 strcpy(opName, &quot;SURFACE_TO_SW_BLIT&quot;);
 135             }
 136             break;
 137         case sun_java2d_pipe_BufferedOpCodes_MASK_FILL:
 138             {
 139                 strcpy(opName, &quot;MASK_FILL&quot;);
 140             }
 141             break;
 142         case sun_java2d_pipe_BufferedOpCodes_MASK_BLIT:
 143             {
 144 
 145                 strcpy(opName, &quot;MASK_BLIT&quot;);
 146             }
 147             break;
 148         case sun_java2d_pipe_BufferedOpCodes_SET_RECT_CLIP:
 149             {
 150                 strcpy(opName, &quot;SET_RECT_CLIP&quot;);
 151             }
 152             break;
 153         case sun_java2d_pipe_BufferedOpCodes_BEGIN_SHAPE_CLIP:
 154             {
 155                 strcpy(opName, &quot;BEGIN_SHAPE_CLIP&quot;);
 156             }
 157             break;
 158         case sun_java2d_pipe_BufferedOpCodes_SET_SHAPE_CLIP_SPANS:
 159             {
 160                 strcpy(opName, &quot;SET_SHAPE_CLIP_SPANS&quot;);
 161             }
 162             break;
 163         case sun_java2d_pipe_BufferedOpCodes_END_SHAPE_CLIP:
 164             {
 165                 strcpy(opName, &quot;END_SHAPE_CLIP&quot;);
 166             }
 167             break;
 168         case sun_java2d_pipe_BufferedOpCodes_RESET_CLIP:
 169             {
 170                 strcpy(opName, &quot;RESET_CLIP&quot;);
 171             }
 172             break;
 173         case sun_java2d_pipe_BufferedOpCodes_SET_ALPHA_COMPOSITE:
 174             {
 175                 strcpy(opName, &quot;SET_ALPHA_COMPOSITE&quot;);
 176             }
 177             break;
 178         case sun_java2d_pipe_BufferedOpCodes_SET_XOR_COMPOSITE:
 179             {
 180                 strcpy(opName, &quot;SET_XOR_COMPOSITE&quot;);
 181             }
 182             break;
 183         case sun_java2d_pipe_BufferedOpCodes_RESET_COMPOSITE:
 184             {
 185                 strcpy(opName, &quot;RESET_COMPOSITE&quot;);
 186             }
 187             break;
 188         case sun_java2d_pipe_BufferedOpCodes_SET_TRANSFORM:
 189             {
 190                 strcpy(opName, &quot;SET_TRANSFORM&quot;);
 191             }
 192             break;
 193         case sun_java2d_pipe_BufferedOpCodes_RESET_TRANSFORM:
 194             {
 195                 strcpy(opName, &quot;RESET_TRANSFORM&quot;);
 196             }
 197             break;
 198         case sun_java2d_pipe_BufferedOpCodes_SET_SURFACES:
 199             {
 200 
 201                 strcpy(opName, &quot;SET_SURFACES&quot;);
 202             }
 203             break;
 204         case sun_java2d_pipe_BufferedOpCodes_SET_SCRATCH_SURFACE:
 205             {
 206                 strcpy(opName, &quot;SET_SCRATCH_SURFACE&quot;);
 207             }
 208             break;
 209         case sun_java2d_pipe_BufferedOpCodes_FLUSH_SURFACE:
 210             {
 211                 strcpy(opName, &quot;FLUSH_SURFACE&quot;);
 212             }
 213             break;
 214         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_SURFACE:
 215             {
 216                 strcpy(opName, &quot;DISPOSE_SURFACE&quot;);
 217             }
 218             break;
 219         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_CONFIG:
 220             {
 221                 strcpy(opName, &quot;DISPOSE_CONFIG&quot;);
 222             }
 223             break;
 224         case sun_java2d_pipe_BufferedOpCodes_INVALIDATE_CONTEXT:
 225             {
 226                 strcpy(opName, &quot;INVALIDATE_CONTEXT&quot;);
 227             }
 228             break;
 229         case sun_java2d_pipe_BufferedOpCodes_SYNC:
 230             {
 231                 strcpy(opName, &quot;SYNC&quot;);
 232 
 233             }
 234             break;
 235         case sun_java2d_pipe_BufferedOpCodes_SWAP_BUFFERS:
 236             {
 237                 strcpy(opName, &quot;SWAP_BUFFERS&quot;);
 238             }
 239             break;
 240         case sun_java2d_pipe_BufferedOpCodes_NOOP:
 241             strcpy(opName, &quot;NOOP&quot;);
 242             break;
 243         case sun_java2d_pipe_BufferedOpCodes_RESET_PAINT:
 244             {
 245                 strcpy(opName, &quot;RESET_PAINT&quot;);
 246             }
 247             break;
 248         case sun_java2d_pipe_BufferedOpCodes_SET_COLOR:
 249             {
 250                 strcpy(opName, &quot;SET_COLOR&quot;);
 251             }
 252             break;
 253         case sun_java2d_pipe_BufferedOpCodes_SET_GRADIENT_PAINT:
 254             {
 255                 strcpy(opName, &quot;SET_GRADIENT_PAINT&quot;);
 256             }
 257             break;
 258         case sun_java2d_pipe_BufferedOpCodes_SET_LINEAR_GRADIENT_PAINT:
 259             {
 260                 strcpy(opName, &quot;SET_LINEAR_GRADIENT_PAINT&quot;);
 261             }
 262             break;
 263         case sun_java2d_pipe_BufferedOpCodes_SET_RADIAL_GRADIENT_PAINT:
 264             {
 265                 strcpy(opName, &quot;SET_RADIAL_GRADIENT_PAINT&quot;);
 266             }
 267             break;
 268         case sun_java2d_pipe_BufferedOpCodes_SET_TEXTURE_PAINT:
 269             {
 270                 strcpy(opName, &quot;SET_TEXTURE_PAINT&quot;);
 271             }
 272             break;
 273         case sun_java2d_pipe_BufferedOpCodes_ENABLE_CONVOLVE_OP:
 274             {
 275                 strcpy(opName, &quot;ENABLE_CONVOLVE_OP&quot;);
 276             }
 277             break;
 278         case sun_java2d_pipe_BufferedOpCodes_DISABLE_CONVOLVE_OP:
 279             {
 280                 strcpy(opName, &quot;DISABLE_CONVOLVE_OP&quot;);
 281             }
 282             break;
 283         case sun_java2d_pipe_BufferedOpCodes_ENABLE_RESCALE_OP:
 284             {
 285                 strcpy(opName, &quot;ENABLE_RESCALE_OP&quot;);
 286             }
 287             break;
 288         case sun_java2d_pipe_BufferedOpCodes_DISABLE_RESCALE_OP:
 289             {
 290                  strcpy(opName, &quot;DISABLE_RESCALE_OP&quot;);
 291             }
 292             break;
 293         case sun_java2d_pipe_BufferedOpCodes_ENABLE_LOOKUP_OP:
 294             {
 295                 strcpy(opName, &quot;ENABLE_LOOKUP_OP&quot;);
 296             }
 297             break;
 298         case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:
 299             {
 300                 strcpy(opName, &quot;DISABLE_LOOKUP_OP&quot;);
 301             }
 302             break;
 303         default:
 304             strcpy(opName, &quot;UNKNOWN&quot;);
 305             break;
 306         }
 307     return opName;
 308 }
 309 
 310 void MTLRenderQueue_CheckPreviousOp(jint op) {
 311 
 312     if (mtlPreviousOp == op) {
 313         // The op is the same as last time, so we can return immediately.
 314         return;
 315     }
 316 
 317     J2dTraceLn1(J2D_TRACE_VERBOSE,
 318                 &quot;MTLRenderQueue_CheckPreviousOp: new op=%d&quot;, op);
 319 
 320     if (op == MTL_OP_SET_COLOR) {
 321         return; // SET_COLOR should not cause endEncoder
 322     }
 323 
 324     if (mtlPreviousOp == MTL_OP_INIT) {
 325         mtlPreviousOp = op;
 326         return;
 327     }
 328 
 329     if (mtlc != NULL) {
 330         [mtlc.encoderManager endEncoder];
 331 
 332         if (op == MTL_OP_RESET_PAINT || op == MTL_OP_SYNC) {
 333             MTLCommandBufferWrapper *cbwrapper = [mtlc pullCommandBufferWrapper];
 334             id &lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
 335             [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
 336                 [cbwrapper release];
 337             }];
 338             [commandbuf commit];
 339             if (op == MTL_OP_SYNC) {
 340                 [commandbuf waitUntilCompleted];
 341             }
 342         }
 343     }
 344     mtlPreviousOp = op;
 345 }
 346 
 347 JNIEXPORT void JNICALL
 348 Java_sun_java2d_metal_MTLRenderQueue_flushBuffer
 349     (JNIEnv *env, jobject mtlrq,
 350      jlong buf, jint limit)
 351 {
 352     unsigned char *b, *end;
 353 
 354     J2dTraceLn1(J2D_TRACE_INFO,
 355                 &quot;MTLRenderQueue_flushBuffer: limit=%d&quot;, limit);
 356 
 357     b = (unsigned char *)jlong_to_ptr(buf);
 358     if (b == NULL) {
 359         J2dRlsTraceLn(J2D_TRACE_ERROR,
 360             &quot;MTLRenderQueue_flushBuffer: cannot get direct buffer address&quot;);
 361         return;
 362     }
 363 
 364     end = b + limit;
 365 
 366     jboolean DEBUG_LOG = JNI_FALSE;
 367     while (b &lt; end) {
 368         jint opcode = NEXT_INT(b);
 369 
 370         if (DEBUG_LOG) {
 371             J2dTraceLn2(J2D_TRACE_ERROR,
 372                     &quot;MTLRenderQueue_flushBuffer: opcode_name = %s, rem=%d&quot;,
 373                     getOpcodeString(opcode), (end-b));
 374         } else {
 375             J2dTraceLn2(J2D_TRACE_VERBOSE,
 376                     &quot;MTLRenderQueue_flushBuffer: opcode=%d, rem=%d&quot;,
 377                     opcode, (end-b));
 378         }
 379 
 380         switch (opcode) {
 381 
 382         // draw ops
 383         case sun_java2d_pipe_BufferedOpCodes_DRAW_LINE:
 384             {
 385                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 386                 J2dTraceLn(J2D_TRACE_VERBOSE, &quot;sun_java2d_pipe_BufferedOpCodes_DRAW_LINE&quot;);
 387                 jint x1 = NEXT_INT(b);
 388                 jint y1 = NEXT_INT(b);
 389                 jint x2 = NEXT_INT(b);
 390                 jint y2 = NEXT_INT(b);
 391                 MTLRenderer_DrawLine(mtlc, dstOps, x1, y1, x2, y2);
 392             }
 393             break;
 394         case sun_java2d_pipe_BufferedOpCodes_DRAW_RECT:
 395             {
 396                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 397                 jint x = NEXT_INT(b);
 398                 jint y = NEXT_INT(b);
 399                 jint w = NEXT_INT(b);
 400                 jint h = NEXT_INT(b);
 401                 MTLRenderer_DrawRect(mtlc, dstOps, x, y, w, h);
 402             }
 403             break;
 404         case sun_java2d_pipe_BufferedOpCodes_DRAW_POLY:
 405             {
 406                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 407                 jint nPoints      = NEXT_INT(b);
 408                 jboolean isClosed = NEXT_BOOLEAN(b);
 409                 jint transX       = NEXT_INT(b);
 410                 jint transY       = NEXT_INT(b);
 411                 jint *xPoints = (jint *)b;
 412                 jint *yPoints = ((jint *)b) + nPoints;
 413                 MTLRenderer_DrawPoly(mtlc, dstOps, nPoints, isClosed, transX, transY, xPoints, yPoints);
 414                 SKIP_BYTES(b, nPoints * BYTES_PER_POLY_POINT);
 415             }
 416             break;
 417         case sun_java2d_pipe_BufferedOpCodes_DRAW_PIXEL:
 418             {
 419                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 420                 jint x = NEXT_INT(b);
 421                 jint y = NEXT_INT(b);
 422                 CONTINUE_IF_NULL(mtlc);
<a name="1" id="anc1"></a><span class="line-modified"> 423                 MTLRenderer_DrawPixel(mtlc, dstOps, x, y);</span>

 424             }
 425             break;
 426         case sun_java2d_pipe_BufferedOpCodes_DRAW_SCANLINES:
 427             {
 428                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 429                 jint count = NEXT_INT(b);
 430                 MTLRenderer_DrawScanlines(mtlc, dstOps, count, (jint *)b);
 431 
 432                 SKIP_BYTES(b, count * BYTES_PER_SCANLINE);
 433             }
 434             break;
 435         case sun_java2d_pipe_BufferedOpCodes_DRAW_PARALLELOGRAM:
 436             {
 437                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 438                 jfloat x11 = NEXT_FLOAT(b);
 439                 jfloat y11 = NEXT_FLOAT(b);
 440                 jfloat dx21 = NEXT_FLOAT(b);
 441                 jfloat dy21 = NEXT_FLOAT(b);
 442                 jfloat dx12 = NEXT_FLOAT(b);
 443                 jfloat dy12 = NEXT_FLOAT(b);
 444                 jfloat lwr21 = NEXT_FLOAT(b);
 445                 jfloat lwr12 = NEXT_FLOAT(b);
 446 
 447                 MTLRenderer_DrawParallelogram(mtlc, dstOps,
 448                                               x11, y11,
 449                                               dx21, dy21,
 450                                               dx12, dy12,
 451                                               lwr21, lwr12);
 452             }
 453             break;
 454         case sun_java2d_pipe_BufferedOpCodes_DRAW_AAPARALLELOGRAM:
 455             {
 456                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 457                 jfloat x11 = NEXT_FLOAT(b);
 458                 jfloat y11 = NEXT_FLOAT(b);
 459                 jfloat dx21 = NEXT_FLOAT(b);
 460                 jfloat dy21 = NEXT_FLOAT(b);
 461                 jfloat dx12 = NEXT_FLOAT(b);
 462                 jfloat dy12 = NEXT_FLOAT(b);
 463                 jfloat lwr21 = NEXT_FLOAT(b);
 464                 jfloat lwr12 = NEXT_FLOAT(b);
 465 
 466                 MTLRenderer_DrawAAParallelogram(mtlc, dstOps,
 467                                                 x11, y11,
 468                                                 dx21, dy21,
 469                                                 dx12, dy12,
 470                                                 lwr21, lwr12);
 471             }
 472             break;
 473 
 474         // fill ops
 475         case sun_java2d_pipe_BufferedOpCodes_FILL_RECT:
 476             {
 477                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 478                 jint x = NEXT_INT(b);
 479                 jint y = NEXT_INT(b);
 480                 jint w = NEXT_INT(b);
 481                 jint h = NEXT_INT(b);
 482                 MTLRenderer_FillRect(mtlc, dstOps, x, y, w, h);
 483             }
 484             break;
 485         case sun_java2d_pipe_BufferedOpCodes_FILL_SPANS:
 486             {
 487                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 488                 jint count = NEXT_INT(b);
 489                 MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);
 490                 SKIP_BYTES(b, count * BYTES_PER_SPAN);
 491             }
 492             break;
 493         case sun_java2d_pipe_BufferedOpCodes_FILL_PARALLELOGRAM:
 494             {
 495                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 496                 jfloat x11 = NEXT_FLOAT(b);
 497                 jfloat y11 = NEXT_FLOAT(b);
 498                 jfloat dx21 = NEXT_FLOAT(b);
 499                 jfloat dy21 = NEXT_FLOAT(b);
 500                 jfloat dx12 = NEXT_FLOAT(b);
 501                 jfloat dy12 = NEXT_FLOAT(b);
 502                 MTLRenderer_FillParallelogram(mtlc, dstOps,
 503                                               x11, y11,
 504                                               dx21, dy21,
 505                                               dx12, dy12);
 506             }
 507             break;
 508         case sun_java2d_pipe_BufferedOpCodes_FILL_AAPARALLELOGRAM:
 509             {
 510                 CHECK_PREVIOUS_OP(MTL_OP_AA);
 511                 jfloat x11 = NEXT_FLOAT(b);
 512                 jfloat y11 = NEXT_FLOAT(b);
 513                 jfloat dx21 = NEXT_FLOAT(b);
 514                 jfloat dy21 = NEXT_FLOAT(b);
 515                 jfloat dx12 = NEXT_FLOAT(b);
 516                 jfloat dy12 = NEXT_FLOAT(b);
 517                 MTLRenderer_FillAAParallelogram(mtlc, dstOps,
 518                                                 x11, y11,
 519                                                 dx21, dy21,
 520                                                 dx12, dy12);
 521             }
 522             break;
 523 
 524         // text-related ops
 525         case sun_java2d_pipe_BufferedOpCodes_DRAW_GLYPH_LIST:
 526             {
 527                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 528                 jint numGlyphs        = NEXT_INT(b);
 529                 jint packedParams     = NEXT_INT(b);
 530                 jfloat glyphListOrigX = NEXT_FLOAT(b);
 531                 jfloat glyphListOrigY = NEXT_FLOAT(b);
 532                 jboolean usePositions = EXTRACT_BOOLEAN(packedParams,
 533                                                         OFFSET_POSITIONS);
 534                 jboolean subPixPos    = EXTRACT_BOOLEAN(packedParams,
 535                                                         OFFSET_SUBPIXPOS);
 536                 jboolean rgbOrder     = EXTRACT_BOOLEAN(packedParams,
 537                                                         OFFSET_RGBORDER);
 538                 jint lcdContrast      = EXTRACT_BYTE(packedParams,
 539                                                      OFFSET_CONTRAST);
 540                 unsigned char *images = b;
 541                 unsigned char *positions;
 542                 jint bytesPerGlyph;
 543                 if (usePositions) {
 544                     positions = (b + numGlyphs * BYTES_PER_GLYPH_IMAGE);
 545                     bytesPerGlyph = BYTES_PER_POSITIONED_GLYPH;
 546                 } else {
 547                     positions = NULL;
 548                     bytesPerGlyph = BYTES_PER_GLYPH_IMAGE;
 549                 }
 550                 MTLTR_DrawGlyphList(env, mtlc, dstOps,
 551                                     numGlyphs, usePositions,
 552                                     subPixPos, rgbOrder, lcdContrast,
 553                                     glyphListOrigX, glyphListOrigY,
 554                                     images, positions);
 555                 SKIP_BYTES(b, numGlyphs * bytesPerGlyph);
 556             }
 557             break;
 558 
 559         // copy-related ops
 560         case sun_java2d_pipe_BufferedOpCodes_COPY_AREA:
 561             {
 562                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 563                 jint x  = NEXT_INT(b);
 564                 jint y  = NEXT_INT(b);
 565                 jint w  = NEXT_INT(b);
 566                 jint h  = NEXT_INT(b);
 567                 jint dx = NEXT_INT(b);
 568                 jint dy = NEXT_INT(b);
 569                 MTLBlitLoops_CopyArea(env, mtlc, dstOps,
 570                                       x, y, w, h, dx, dy);
 571             }
 572             break;
 573         case sun_java2d_pipe_BufferedOpCodes_BLIT:
 574             {
 575                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 576                 jint packedParams = NEXT_INT(b);
 577                 jint sx1          = NEXT_INT(b);
 578                 jint sy1          = NEXT_INT(b);
 579                 jint sx2          = NEXT_INT(b);
 580                 jint sy2          = NEXT_INT(b);
 581                 jdouble dx1       = NEXT_DOUBLE(b);
 582                 jdouble dy1       = NEXT_DOUBLE(b);
 583                 jdouble dx2       = NEXT_DOUBLE(b);
 584                 jdouble dy2       = NEXT_DOUBLE(b);
 585                 jlong pSrc        = NEXT_LONG(b);
 586                 jlong pDst        = NEXT_LONG(b);
 587                 jint hint         = EXTRACT_BYTE(packedParams, OFFSET_HINT);
 588                 jboolean texture  = EXTRACT_BOOLEAN(packedParams,
 589                                                     OFFSET_TEXTURE);
 590                 jboolean xform    = EXTRACT_BOOLEAN(packedParams,
 591                                                     OFFSET_XFORM);
 592                 jboolean isoblit  = EXTRACT_BOOLEAN(packedParams,
 593                                                     OFFSET_ISOBLIT);
 594                 if (isoblit) {
 595                     MTLBlitLoops_IsoBlit(env, mtlc, pSrc, pDst,
 596                                          xform, hint, texture,
 597                                          sx1, sy1, sx2, sy2,
 598                                          dx1, dy1, dx2, dy2);
 599                 } else {
 600                     jint srctype = EXTRACT_BYTE(packedParams, OFFSET_SRCTYPE);
 601                     MTLBlitLoops_Blit(env, mtlc, pSrc, pDst,
 602                                       xform, hint, srctype, texture,
 603                                       sx1, sy1, sx2, sy2,
 604                                       dx1, dy1, dx2, dy2);
 605                 }
 606             }
 607             break;
 608         case sun_java2d_pipe_BufferedOpCodes_SURFACE_TO_SW_BLIT:
 609             {
 610                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 611                 jint sx      = NEXT_INT(b);
 612                 jint sy      = NEXT_INT(b);
 613                 jint dx      = NEXT_INT(b);
 614                 jint dy      = NEXT_INT(b);
 615                 jint w       = NEXT_INT(b);
 616                 jint h       = NEXT_INT(b);
 617                 jint dsttype = NEXT_INT(b);
 618                 jlong pSrc   = NEXT_LONG(b);
 619                 jlong pDst   = NEXT_LONG(b);
 620                 MTLBlitLoops_SurfaceToSwBlit(env, mtlc,
 621                                              pSrc, pDst, dsttype,
 622                                              sx, sy, dx, dy, w, h);
 623             }
 624             break;
 625         case sun_java2d_pipe_BufferedOpCodes_MASK_FILL:
 626             {
 627                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 628                 jint x        = NEXT_INT(b);
 629                 jint y        = NEXT_INT(b);
 630                 jint w        = NEXT_INT(b);
 631                 jint h        = NEXT_INT(b);
 632                 jint maskoff  = NEXT_INT(b);
 633                 jint maskscan = NEXT_INT(b);
 634                 jint masklen  = NEXT_INT(b);
 635                 unsigned char *pMask = (masklen &gt; 0) ? b : NULL;
 636                 MTLMaskFill_MaskFill(mtlc, dstOps, x, y, w, h,
 637                                      maskoff, maskscan, masklen, pMask);
 638                 SKIP_BYTES(b, masklen);
 639             }
 640             break;
 641         case sun_java2d_pipe_BufferedOpCodes_MASK_BLIT:
 642             {
 643                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 644                 jint dstx     = NEXT_INT(b);
 645                 jint dsty     = NEXT_INT(b);
 646                 jint width    = NEXT_INT(b);
 647                 jint height   = NEXT_INT(b);
 648                 jint masklen  = width * height * sizeof(jint);
 649                 MTLMaskBlit_MaskBlit(env, mtlc, dstOps,
 650                                      dstx, dsty, width, height, b);
 651                 SKIP_BYTES(b, masklen);
 652             }
 653             break;
 654 
 655         // state-related ops
 656         case sun_java2d_pipe_BufferedOpCodes_SET_RECT_CLIP:
 657             {
 658                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 659                 jint x1 = NEXT_INT(b);
 660                 jint y1 = NEXT_INT(b);
 661                 jint x2 = NEXT_INT(b);
 662                 jint y2 = NEXT_INT(b);
 663                 [mtlc setClipRectX1:x1 Y1:y1 X2:x2 Y2:y2];
 664             }
 665             break;
 666         case sun_java2d_pipe_BufferedOpCodes_BEGIN_SHAPE_CLIP:
 667             {
 668                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 669                 [mtlc beginShapeClip:dstOps];
 670             }
 671             break;
 672         case sun_java2d_pipe_BufferedOpCodes_SET_SHAPE_CLIP_SPANS:
 673             {
 674                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 675                 // This results in creation of new render encoder with
 676                 // stencil buffer set as render target
 677                 jint count = NEXT_INT(b);
 678                 MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);
 679                 SKIP_BYTES(b, count * BYTES_PER_SPAN);
 680             }
 681             break;
 682         case sun_java2d_pipe_BufferedOpCodes_END_SHAPE_CLIP:
 683             {
 684                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 685                 [mtlc endShapeClip:dstOps];
 686             }
 687             break;
 688         case sun_java2d_pipe_BufferedOpCodes_RESET_CLIP:
 689             {
 690                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 691                 [mtlc resetClip];
 692             }
 693             break;
 694         case sun_java2d_pipe_BufferedOpCodes_SET_ALPHA_COMPOSITE:
 695             {
 696                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 697                 jint rule         = NEXT_INT(b);
 698                 jfloat extraAlpha = NEXT_FLOAT(b);
 699                 jint flags        = NEXT_INT(b);
 700                 [mtlc setAlphaCompositeRule:rule extraAlpha:extraAlpha flags:flags];
 701             }
 702             break;
 703         case sun_java2d_pipe_BufferedOpCodes_SET_XOR_COMPOSITE:
 704             {
 705                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 706                 jint xorPixel = NEXT_INT(b);
 707                 [mtlc setXorComposite:xorPixel];
 708             }
 709             break;
 710         case sun_java2d_pipe_BufferedOpCodes_RESET_COMPOSITE:
 711             {
 712                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 713                 [mtlc resetComposite];
 714             }
 715             break;
 716         case sun_java2d_pipe_BufferedOpCodes_SET_TRANSFORM:
 717             {
 718                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 719                 jdouble m00 = NEXT_DOUBLE(b);
 720                 jdouble m10 = NEXT_DOUBLE(b);
 721                 jdouble m01 = NEXT_DOUBLE(b);
 722                 jdouble m11 = NEXT_DOUBLE(b);
 723                 jdouble m02 = NEXT_DOUBLE(b);
 724                 jdouble m12 = NEXT_DOUBLE(b);
 725                 [mtlc setTransformM00:m00 M10:m10 M01:m01 M11:m11 M02:m02 M12:m12];
 726             }
 727             break;
 728         case sun_java2d_pipe_BufferedOpCodes_RESET_TRANSFORM:
 729             {
 730                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 731                 [mtlc resetTransform];
 732             }
 733             break;
 734 
 735         // context-related ops
 736         case sun_java2d_pipe_BufferedOpCodes_SET_SURFACES:
 737             {
 738                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 739                 jlong pSrc = NEXT_LONG(b);
 740                 jlong pDst = NEXT_LONG(b);
 741 
 742                 dstOps = (BMTLSDOps *)jlong_to_ptr(pDst);
 743                 mtlc = [MTLContext setSurfacesEnv:env src:pSrc dst:pDst];
 744             }
 745             break;
 746         case sun_java2d_pipe_BufferedOpCodes_SET_SCRATCH_SURFACE:
 747             {
 748                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 749                 jlong pConfigInfo = NEXT_LONG(b);
 750                 MTLGraphicsConfigInfo *mtlInfo =
 751                         (MTLGraphicsConfigInfo *)jlong_to_ptr(pConfigInfo);
 752 
 753                 if (mtlInfo == NULL) {
 754 
 755                 } else {
 756                     MTLContext *newMtlc = mtlInfo-&gt;context;
 757                     if (newMtlc == NULL) {
 758 
 759                     } else {
 760                         mtlc = newMtlc;
 761                         dstOps = NULL;
 762                     }
 763                 }
 764             }
 765             break;
 766         case sun_java2d_pipe_BufferedOpCodes_FLUSH_SURFACE:
 767             {
 768                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 769                 jlong pData = NEXT_LONG(b);
 770                 BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);
 771                 if (mtlsdo != NULL) {
 772                     CONTINUE_IF_NULL(mtlc);
 773                     MTLSD_Delete(env, mtlsdo);
 774                 }
 775             }
 776             break;
 777         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_SURFACE:
 778             {
 779                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 780                 jlong pData = NEXT_LONG(b);
 781                 BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);
 782                 if (mtlsdo != NULL) {
 783                     CONTINUE_IF_NULL(mtlc);
 784                     MTLSD_Delete(env, mtlsdo);
 785                     if (mtlsdo-&gt;privOps != NULL) {
 786                         free(mtlsdo-&gt;privOps);
 787                     }
 788                 }
 789             }
 790             break;
 791         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_CONFIG:
 792             {
 793                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 794                 jlong pConfigInfo = NEXT_LONG(b);
 795                 CONTINUE_IF_NULL(mtlc);
 796                 MTLGC_DestroyMTLGraphicsConfig(pConfigInfo);
 797 
 798                 // the previous method will call glX/wglMakeCurrent(None),
 799                 // so we should nullify the current mtlc and dstOps to avoid
 800                 // calling glFlush() (or similar) while no context is current
 801                 mtlc = NULL;
 802              //   dstOps = NULL;
 803             }
 804             break;
 805         case sun_java2d_pipe_BufferedOpCodes_INVALIDATE_CONTEXT:
 806             {
 807                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 808                 // invalidate the references to the current context and
 809                 // destination surface that are maintained at the native level
 810                 mtlc = NULL;
 811             //    dstOps = NULL;
 812             }
 813             break;
 814         case sun_java2d_pipe_BufferedOpCodes_SYNC:
 815             {
 816                 CHECK_PREVIOUS_OP(MTL_OP_SYNC);
 817             }
 818             break;
 819 
 820         // multibuffering ops
 821         case sun_java2d_pipe_BufferedOpCodes_SWAP_BUFFERS:
 822             {
 823                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 824                 jlong window = NEXT_LONG(b);
 825                 MTLSD_SwapBuffers(env, window);
 826             }
 827             break;
 828 
 829         // special no-op (mainly used for achieving 8-byte alignment)
 830         case sun_java2d_pipe_BufferedOpCodes_NOOP:
 831             break;
 832 
 833         // paint-related ops
 834         case sun_java2d_pipe_BufferedOpCodes_RESET_PAINT:
 835             {
 836               CHECK_PREVIOUS_OP(MTL_OP_RESET_PAINT);
 837               [mtlc resetPaint];
 838             }
 839             break;
 840         case sun_java2d_pipe_BufferedOpCodes_SET_COLOR:
 841             {
 842                 CHECK_PREVIOUS_OP(MTL_OP_SET_COLOR);
 843                 jint pixel = NEXT_INT(b);
 844                 [mtlc setColorPaint:pixel];
 845             }
 846             break;
 847         case sun_java2d_pipe_BufferedOpCodes_SET_GRADIENT_PAINT:
 848             {
 849                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 850                 jboolean useMask= NEXT_BOOLEAN(b);
 851                 jboolean cyclic = NEXT_BOOLEAN(b);
 852                 jdouble p0      = NEXT_DOUBLE(b);
 853                 jdouble p1      = NEXT_DOUBLE(b);
 854                 jdouble p3      = NEXT_DOUBLE(b);
 855                 jint pixel1     = NEXT_INT(b);
 856                 jint pixel2     = NEXT_INT(b);
 857                 [mtlc setGradientPaintUseMask:useMask
 858                                     cyclic:cyclic
 859                                         p0:p0
 860                                         p1:p1
 861                                         p3:p3
 862                                     pixel1:pixel1
 863                                     pixel2:pixel2];
 864             }
 865             break;
 866         case sun_java2d_pipe_BufferedOpCodes_SET_LINEAR_GRADIENT_PAINT:
 867             {
 868                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 869                 jboolean useMask = NEXT_BOOLEAN(b);
 870                 jboolean linear  = NEXT_BOOLEAN(b);
 871                 jint cycleMethod = NEXT_INT(b);
 872                 jint numStops    = NEXT_INT(b);
 873                 jfloat p0        = NEXT_FLOAT(b);
 874                 jfloat p1        = NEXT_FLOAT(b);
 875                 jfloat p3        = NEXT_FLOAT(b);
 876                 void *fractions, *pixels;
 877                 fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));
 878                 pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));
 879                 [mtlc setLinearGradientPaint:useMask
 880                                       linear:linear
 881                                  cycleMethod:cycleMethod
 882                                     numStops:numStops
 883                                           p0:p0
 884                                           p1:p1
 885                                           p3:p3
 886                                    fractions:fractions
 887                                       pixels:pixels];
 888             }
 889             break;
 890         case sun_java2d_pipe_BufferedOpCodes_SET_RADIAL_GRADIENT_PAINT:
 891             {
 892                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 893                 jboolean useMask = NEXT_BOOLEAN(b);
 894                 jboolean linear  = NEXT_BOOLEAN(b);
 895                 jint numStops    = NEXT_INT(b);
 896                 jint cycleMethod = NEXT_INT(b);
 897                 jfloat m00       = NEXT_FLOAT(b);
 898                 jfloat m01       = NEXT_FLOAT(b);
 899                 jfloat m02       = NEXT_FLOAT(b);
 900                 jfloat m10       = NEXT_FLOAT(b);
 901                 jfloat m11       = NEXT_FLOAT(b);
 902                 jfloat m12       = NEXT_FLOAT(b);
 903                 jfloat focusX    = NEXT_FLOAT(b);
 904                 void *fractions, *pixels;
 905                 fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));
 906                 pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));
 907                 [mtlc setRadialGradientPaint:useMask
 908                                       linear:linear
 909                                  cycleMethod:cycleMethod
 910                                     numStops:numStops
 911                                          m00:m00
 912                                          m01:m01
 913                                          m02:m02
 914                                          m10:m10
 915                                          m11:m11
 916                                          m12:m12
 917                                       focusX:focusX
 918                                    fractions:fractions
 919                                       pixels:pixels];
 920             }
 921             break;
 922         case sun_java2d_pipe_BufferedOpCodes_SET_TEXTURE_PAINT:
 923             {
 924                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 925                 jboolean useMask= NEXT_BOOLEAN(b);
 926                 jboolean filter = NEXT_BOOLEAN(b);
 927                 jlong pSrc      = NEXT_LONG(b);
 928                 jdouble xp0     = NEXT_DOUBLE(b);
 929                 jdouble xp1     = NEXT_DOUBLE(b);
 930                 jdouble xp3     = NEXT_DOUBLE(b);
 931                 jdouble yp0     = NEXT_DOUBLE(b);
 932                 jdouble yp1     = NEXT_DOUBLE(b);
 933                 jdouble yp3     = NEXT_DOUBLE(b);
 934                 [mtlc setTexturePaint:useMask
 935                               pSrcOps:pSrc
 936                                filter:filter
 937                                   xp0:xp0
 938                                   xp1:xp1
 939                                   xp3:xp3
 940                                   yp0:yp0
 941                                   yp1:yp1
 942                                   yp3:yp3];
 943             }
 944             break;
 945 
 946         // BufferedImageOp-related ops
 947         case sun_java2d_pipe_BufferedOpCodes_ENABLE_CONVOLVE_OP:
 948             {
 949                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 950                 jlong pSrc        = NEXT_LONG(b);
 951                 jboolean edgeZero = NEXT_BOOLEAN(b);
 952                 jint kernelWidth  = NEXT_INT(b);
 953                 jint kernelHeight = NEXT_INT(b);
 954 
 955                 BMTLSDOps * bmtlsdOps = (BMTLSDOps *)pSrc;
 956                 MTLConvolveOp * convolveOp = [[MTLConvolveOp alloc] init:edgeZero
 957                         kernelWidth:kernelWidth
 958                        kernelHeight:kernelHeight
 959                            srcWidth:bmtlsdOps-&gt;width
 960                           srcHeight:bmtlsdOps-&gt;height
 961                              kernel:b
 962                              device:mtlc.device
 963                                               ];
 964                 [mtlc setBufImgOp:convolveOp];
 965                 SKIP_BYTES(b, kernelWidth * kernelHeight * sizeof(jfloat));
 966             }
 967             break;
 968         case sun_java2d_pipe_BufferedOpCodes_DISABLE_CONVOLVE_OP:
 969             {
 970                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 971                 [mtlc setBufImgOp:NULL];
 972             }
 973             break;
 974         case sun_java2d_pipe_BufferedOpCodes_ENABLE_RESCALE_OP:
 975             {
 976                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 977                 jlong pSrc          = NEXT_LONG(b);
 978                 jboolean nonPremult = NEXT_BOOLEAN(b);
 979                 jint numFactors     = 4;
 980                 unsigned char *scaleFactors = b;
 981                 unsigned char *offsets = (b + numFactors * sizeof(jfloat));
 982                 MTLRescaleOp * rescaleOp = [[MTLRescaleOp alloc] init:nonPremult factors:scaleFactors offsets:offsets];
 983                 [mtlc setBufImgOp:rescaleOp];
 984                 SKIP_BYTES(b, numFactors * sizeof(jfloat) * 2);
 985             }
 986             break;
 987         case sun_java2d_pipe_BufferedOpCodes_DISABLE_RESCALE_OP:
 988             {
 989                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 990                 [mtlc setBufImgOp:NULL];
 991             }
 992             break;
 993         case sun_java2d_pipe_BufferedOpCodes_ENABLE_LOOKUP_OP:
 994             {
 995                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 996                 jlong pSrc          = NEXT_LONG(b);
 997                 jboolean nonPremult = NEXT_BOOLEAN(b);
 998                 jboolean shortData  = NEXT_BOOLEAN(b);
 999                 jint numBands       = NEXT_INT(b);
1000                 jint bandLength     = NEXT_INT(b);
1001                 jint offset         = NEXT_INT(b);
1002                 jint bytesPerElem = shortData ? sizeof(jshort):sizeof(jbyte);
1003                 void *tableValues = b;
1004 
1005                 MTLLookupOp * lookupOp = [[MTLLookupOp alloc] init:nonPremult
1006                                                          shortData:shortData
1007                                                           numBands:numBands
1008                                                         bandLength:bandLength
1009                                                             offset:offset
1010                                                        tableValues:tableValues
1011                                                             device:mtlc.device];
1012                 [mtlc setBufImgOp:lookupOp];
1013                 SKIP_BYTES(b, numBands * bandLength * bytesPerElem);
1014             }
1015             break;
1016         case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:
1017             {
1018                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
1019                 [mtlc setBufImgOp:NULL];
1020             }
1021             break;
1022 
1023         default:
1024             J2dRlsTraceLn1(J2D_TRACE_ERROR,
1025                 &quot;MTLRenderQueue_flushBuffer: invalid opcode=%d&quot;, opcode);
1026             return;
1027         }
1028     }
1029 
1030     if (mtlc != NULL) {
1031         [mtlc.encoderManager endEncoder];
1032         MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];
1033         id&lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
1034         [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
1035             [cbwrapper release];
1036         }];
1037         [commandbuf commit];
1038         BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
1039         if (dstOps != NULL) {
1040             MTLSDOps *dstMTLOps = (MTLSDOps *)dstOps-&gt;privOps;
1041             MTLLayer *layer = (MTLLayer*)dstMTLOps-&gt;layer;
1042             if (layer != NULL) {
1043                 [JNFRunLoop performOnMainThreadWaiting:NO withBlock:^(){
1044                     AWT_ASSERT_APPKIT_THREAD;
1045                     [layer setNeedsDisplay];
1046                 }];
1047             }
1048         }
1049     }
1050     RESET_PREVIOUS_OP();
1051 }
1052 
1053 /**
1054  * Returns a pointer to the &quot;current&quot; context, as set by the last SET_SURFACES
1055  * or SET_SCRATCH_SURFACE operation.
1056  */
1057 MTLContext *
1058 MTLRenderQueue_GetCurrentContext()
1059 {
1060     return mtlc;
1061 }
1062 
1063 /**
1064  * Returns a pointer to the &quot;current&quot; destination surface, as set by the last
1065  * SET_SURFACES operation.
1066  */
1067 BMTLSDOps *
1068 MTLRenderQueue_GetCurrentDestination()
1069 {
1070     return dstOps;
1071 }
1072 
1073 #endif /* !HEADLESS */
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
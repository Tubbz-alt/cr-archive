<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLRenderQueue.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef HEADLESS
 27 
 28 #include &lt;stdlib.h&gt;
 29 
 30 #include &quot;sun_java2d_pipe_BufferedOpCodes.h&quot;
 31 
 32 #include &quot;jlong.h&quot;
 33 #include &quot;MTLBlitLoops.h&quot;
 34 #include &quot;MTLBufImgOps.h&quot;
 35 #include &quot;MTLMaskBlit.h&quot;
 36 #include &quot;MTLMaskFill.h&quot;
 37 #include &quot;MTLPaints.h&quot;
 38 #include &quot;MTLRenderQueue.h&quot;
 39 #include &quot;MTLRenderer.h&quot;
 40 #include &quot;MTLTextRenderer.h&quot;
 41 #import &quot;ThreadUtilities.h&quot;
 42 
 43 /**
 44  * References to the &quot;current&quot; context and destination surface.
 45  */
 46 static MTLContext *mtlc = NULL;
 47 static BMTLSDOps *dstOps = NULL;
<a name="1" id="anc1"></a>
 48 
 49 /**
 50  * The following methods are implemented in the windowing system (i.e. GLX
 51  * and WGL) source files.
 52  */
 53 extern void MTLGC_DestroyMTLGraphicsConfig(jlong pConfigInfo);
 54 extern void MTLSD_SwapBuffers(JNIEnv *env, jlong window);
 55 
 56 // TODO : Debug logic added for opcode verification,
 57 // should be removed later.
 58 static char *getOpcodeString(jint opcode) {
 59     static char opName[30];
 60     switch (opcode) {
 61         case sun_java2d_pipe_BufferedOpCodes_DRAW_LINE:
 62             {
 63                 strcpy(opName, &quot;DRAW_LINE&quot;);
 64             }
 65             break;
 66         case sun_java2d_pipe_BufferedOpCodes_DRAW_RECT:
 67             {
 68                 strcpy(opName, &quot;DRAW_RECT&quot;);
 69             }
 70             break;
 71         case sun_java2d_pipe_BufferedOpCodes_DRAW_POLY:
 72             {
 73                 strcpy(opName, &quot;DRAW_POLY&quot;);
 74             }
 75             break;
 76         case sun_java2d_pipe_BufferedOpCodes_DRAW_PIXEL:
 77             {
 78                 strcpy(opName, &quot;DRAW_PIXEL&quot;);
 79             }
 80             break;
 81         case sun_java2d_pipe_BufferedOpCodes_DRAW_SCANLINES:
 82             {
 83                 strcpy(opName, &quot;DRAW_SCANLINES&quot;);
 84             }
 85             break;
 86         case sun_java2d_pipe_BufferedOpCodes_DRAW_PARALLELOGRAM:
 87             {
 88                 strcpy(opName, &quot;DRAW_PARALLELOGRAM&quot;);
 89             }
 90             break;
 91         case sun_java2d_pipe_BufferedOpCodes_DRAW_AAPARALLELOGRAM:
 92             {
 93                 strcpy(opName, &quot;DRAW_AAPARALLELOGRAM&quot;);
 94             }
 95             break;
 96         case sun_java2d_pipe_BufferedOpCodes_FILL_RECT:
 97             {
 98                 strcpy(opName, &quot;FILL_RECT&quot;);
 99             }
100             break;
101         case sun_java2d_pipe_BufferedOpCodes_FILL_SPANS:
102             {
103                 strcpy(opName, &quot;FILL_SPANS&quot;);
104             }
105             break;
106         case sun_java2d_pipe_BufferedOpCodes_FILL_PARALLELOGRAM:
107             {
108                 strcpy(opName, &quot;FILL_PARALLELOGRAM&quot;);
109             }
110             break;
111         case sun_java2d_pipe_BufferedOpCodes_FILL_AAPARALLELOGRAM:
112             {
113                 strcpy(opName, &quot;FILL_AAPARALLELOGRAM&quot;);
114             }
115             break;
116         case sun_java2d_pipe_BufferedOpCodes_DRAW_GLYPH_LIST:
117             {
118                 strcpy(opName, &quot;DRAW_GLYPH_LIST&quot;);
119             }
120             break;
121         case sun_java2d_pipe_BufferedOpCodes_COPY_AREA:
122             {
123                 strcpy(opName, &quot;COPY_AREA&quot;);
124             }
125             break;
126         case sun_java2d_pipe_BufferedOpCodes_BLIT:
127             {
128                 strcpy(opName, &quot;BLIT&quot;);
129             }
130             break;
131         case sun_java2d_pipe_BufferedOpCodes_SURFACE_TO_SW_BLIT:
132             {
133                 strcpy(opName, &quot;SURFACE_TO_SW_BLIT&quot;);
134             }
135             break;
136         case sun_java2d_pipe_BufferedOpCodes_MASK_FILL:
137             {
138                 strcpy(opName, &quot;MASK_FILL&quot;);
139             }
140             break;
141         case sun_java2d_pipe_BufferedOpCodes_MASK_BLIT:
142             {
143 
144                 strcpy(opName, &quot;MASK_BLIT&quot;);
145             }
146             break;
147         case sun_java2d_pipe_BufferedOpCodes_SET_RECT_CLIP:
148             {
149                 strcpy(opName, &quot;SET_RECT_CLIP&quot;);
150             }
151             break;
152         case sun_java2d_pipe_BufferedOpCodes_BEGIN_SHAPE_CLIP:
153             {
154                 strcpy(opName, &quot;BEGIN_SHAPE_CLIP&quot;);
155             }
156             break;
157         case sun_java2d_pipe_BufferedOpCodes_SET_SHAPE_CLIP_SPANS:
158             {
159                 strcpy(opName, &quot;SET_SHAPE_CLIP_SPANS&quot;);
160             }
161             break;
162         case sun_java2d_pipe_BufferedOpCodes_END_SHAPE_CLIP:
163             {
164                 strcpy(opName, &quot;END_SHAPE_CLIP&quot;);
165             }
166             break;
167         case sun_java2d_pipe_BufferedOpCodes_RESET_CLIP:
168             {
169                 strcpy(opName, &quot;RESET_CLIP&quot;);
170             }
171             break;
172         case sun_java2d_pipe_BufferedOpCodes_SET_ALPHA_COMPOSITE:
173             {
174                 strcpy(opName, &quot;SET_ALPHA_COMPOSITE&quot;);
175             }
176             break;
177         case sun_java2d_pipe_BufferedOpCodes_SET_XOR_COMPOSITE:
178             {
179                 strcpy(opName, &quot;SET_XOR_COMPOSITE&quot;);
180             }
181             break;
182         case sun_java2d_pipe_BufferedOpCodes_RESET_COMPOSITE:
183             {
184                 strcpy(opName, &quot;RESET_COMPOSITE&quot;);
185             }
186             break;
187         case sun_java2d_pipe_BufferedOpCodes_SET_TRANSFORM:
188             {
189                 strcpy(opName, &quot;SET_TRANSFORM&quot;);
190             }
191             break;
192         case sun_java2d_pipe_BufferedOpCodes_RESET_TRANSFORM:
193             {
194                 strcpy(opName, &quot;RESET_TRANSFORM&quot;);
195             }
196             break;
197         case sun_java2d_pipe_BufferedOpCodes_SET_SURFACES:
198             {
199 
200                 strcpy(opName, &quot;SET_SURFACES&quot;);
201             }
202             break;
203         case sun_java2d_pipe_BufferedOpCodes_SET_SCRATCH_SURFACE:
204             {
205                 strcpy(opName, &quot;SET_SCRATCH_SURFACE&quot;);
206             }
207             break;
208         case sun_java2d_pipe_BufferedOpCodes_FLUSH_SURFACE:
209             {
210                 strcpy(opName, &quot;FLUSH_SURFACE&quot;);
211             }
212             break;
213         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_SURFACE:
214             {
215                 strcpy(opName, &quot;DISPOSE_SURFACE&quot;);
216             }
217             break;
218         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_CONFIG:
219             {
220                 strcpy(opName, &quot;DISPOSE_CONFIG&quot;);
221             }
222             break;
223         case sun_java2d_pipe_BufferedOpCodes_INVALIDATE_CONTEXT:
224             {
225                 strcpy(opName, &quot;INVALIDATE_CONTEXT&quot;);
226             }
227             break;
228         case sun_java2d_pipe_BufferedOpCodes_SYNC:
229             {
230                 strcpy(opName, &quot;SYNC&quot;);
231 
232             }
233             break;
234         case sun_java2d_pipe_BufferedOpCodes_SWAP_BUFFERS:
235             {
236                 strcpy(opName, &quot;SWAP_BUFFERS&quot;);
237             }
238             break;
239         case sun_java2d_pipe_BufferedOpCodes_NOOP:
240             strcpy(opName, &quot;NOOP&quot;);
241             break;
242         case sun_java2d_pipe_BufferedOpCodes_RESET_PAINT:
243             {
244                 strcpy(opName, &quot;RESET_PAINT&quot;);
245             }
246             break;
247         case sun_java2d_pipe_BufferedOpCodes_SET_COLOR:
248             {
249                 strcpy(opName, &quot;SET_COLOR&quot;);
250             }
251             break;
252         case sun_java2d_pipe_BufferedOpCodes_SET_GRADIENT_PAINT:
253             {
254                 strcpy(opName, &quot;SET_GRADIENT_PAINT&quot;);
255             }
256             break;
257         case sun_java2d_pipe_BufferedOpCodes_SET_LINEAR_GRADIENT_PAINT:
258             {
259                 strcpy(opName, &quot;SET_LINEAR_GRADIENT_PAINT&quot;);
260             }
261             break;
262         case sun_java2d_pipe_BufferedOpCodes_SET_RADIAL_GRADIENT_PAINT:
263             {
264                 strcpy(opName, &quot;SET_RADIAL_GRADIENT_PAINT&quot;);
265             }
266             break;
267         case sun_java2d_pipe_BufferedOpCodes_SET_TEXTURE_PAINT:
268             {
269                 strcpy(opName, &quot;SET_TEXTURE_PAINT&quot;);
270             }
271             break;
272         case sun_java2d_pipe_BufferedOpCodes_ENABLE_CONVOLVE_OP:
273             {
274                 strcpy(opName, &quot;ENABLE_CONVOLVE_OP&quot;);
275             }
276             break;
277         case sun_java2d_pipe_BufferedOpCodes_DISABLE_CONVOLVE_OP:
278             {
279                 strcpy(opName, &quot;DISABLE_CONVOLVE_OP&quot;);
280             }
281             break;
282         case sun_java2d_pipe_BufferedOpCodes_ENABLE_RESCALE_OP:
283             {
284                 strcpy(opName, &quot;ENABLE_RESCALE_OP&quot;);
285             }
286             break;
287         case sun_java2d_pipe_BufferedOpCodes_DISABLE_RESCALE_OP:
288             {
289                  strcpy(opName, &quot;DISABLE_RESCALE_OP&quot;);
290             }
291             break;
292         case sun_java2d_pipe_BufferedOpCodes_ENABLE_LOOKUP_OP:
293             {
294                 strcpy(opName, &quot;ENABLE_LOOKUP_OP&quot;);
295             }
296             break;
297         case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:
298             {
299                 strcpy(opName, &quot;DISABLE_LOOKUP_OP&quot;);
300             }
301             break;
302         default:
303             strcpy(opName, &quot;UNKNOWN&quot;);
304             break;
305         }
306     return opName;
307 }
308 
<a name="2" id="anc2"></a>




















309 JNIEXPORT void JNICALL
310 Java_sun_java2d_metal_MTLRenderQueue_flushBuffer
311     (JNIEnv *env, jobject mtlrq,
312      jlong buf, jint limit)
313 {
314     jboolean sync = JNI_FALSE;
315     unsigned char *b, *end;
316 
317     J2dTraceLn1(J2D_TRACE_INFO,
318                 &quot;MTLRenderQueue_flushBuffer: limit=%d&quot;, limit);
319 
320     b = (unsigned char *)jlong_to_ptr(buf);
321     if (b == NULL) {
322         J2dRlsTraceLn(J2D_TRACE_ERROR,
323             &quot;MTLRenderQueue_flushBuffer: cannot get direct buffer address&quot;);
324         return;
325     }
326 
327     end = b + limit;
328 
329     jboolean DEBUG_LOG = JNI_FALSE;
330     while (b &lt; end) {
331         jint opcode = NEXT_INT(b);
332 
333         if (DEBUG_LOG) {
334             J2dTraceLn2(J2D_TRACE_ERROR,
335                     &quot;MTLRenderQueue_flushBuffer: opcode_name = %s, rem=%d&quot;,
336                     getOpcodeString(opcode), (end-b));
337         } else {
338             J2dTraceLn2(J2D_TRACE_VERBOSE,
339                     &quot;MTLRenderQueue_flushBuffer: opcode=%d, rem=%d&quot;,
340                     opcode, (end-b));
341         }
342 
343         switch (opcode) {
344 
345         // draw ops
346         case sun_java2d_pipe_BufferedOpCodes_DRAW_LINE:
347             {
<a name="3" id="anc3"></a>
348                 J2dTraceLn(J2D_TRACE_VERBOSE, &quot;sun_java2d_pipe_BufferedOpCodes_DRAW_LINE&quot;);
349                 jint x1 = NEXT_INT(b);
350                 jint y1 = NEXT_INT(b);
351                 jint x2 = NEXT_INT(b);
352                 jint y2 = NEXT_INT(b);
353                 MTLRenderer_DrawLine(mtlc, dstOps, x1, y1, x2, y2);
354             }
355             break;
356         case sun_java2d_pipe_BufferedOpCodes_DRAW_RECT:
357             {
<a name="4" id="anc4"></a>
358                 jint x = NEXT_INT(b);
359                 jint y = NEXT_INT(b);
360                 jint w = NEXT_INT(b);
361                 jint h = NEXT_INT(b);
362                 MTLRenderer_DrawRect(mtlc, dstOps, x, y, w, h);
363             }
364             break;
365         case sun_java2d_pipe_BufferedOpCodes_DRAW_POLY:
366             {
<a name="5" id="anc5"></a>
367                 jint nPoints      = NEXT_INT(b);
368                 jboolean isClosed = NEXT_BOOLEAN(b);
369                 jint transX       = NEXT_INT(b);
370                 jint transY       = NEXT_INT(b);
371                 jint *xPoints = (jint *)b;
372                 jint *yPoints = ((jint *)b) + nPoints;
373                 MTLRenderer_DrawPoly(mtlc, dstOps, nPoints, isClosed, transX, transY, xPoints, yPoints);
374                 SKIP_BYTES(b, nPoints * BYTES_PER_POLY_POINT);
375             }
376             break;
377         case sun_java2d_pipe_BufferedOpCodes_DRAW_PIXEL:
378             {
<a name="6" id="anc6"></a>
379                 jint x = NEXT_INT(b);
380                 jint y = NEXT_INT(b);
381                 CONTINUE_IF_NULL(mtlc);
382                 //TODO
383                 J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLRenderQueue_DRAW_PIXEL -- :TODO&quot;);
384             }
385             break;
386         case sun_java2d_pipe_BufferedOpCodes_DRAW_SCANLINES:
387             {
<a name="7" id="anc7"></a>
388                 jint count = NEXT_INT(b);
389                 MTLRenderer_DrawScanlines(mtlc, dstOps, count, (jint *)b);
390 
391                 SKIP_BYTES(b, count * BYTES_PER_SCANLINE);
392             }
393             break;
394         case sun_java2d_pipe_BufferedOpCodes_DRAW_PARALLELOGRAM:
395             {
<a name="8" id="anc8"></a>
396                 jfloat x11 = NEXT_FLOAT(b);
397                 jfloat y11 = NEXT_FLOAT(b);
398                 jfloat dx21 = NEXT_FLOAT(b);
399                 jfloat dy21 = NEXT_FLOAT(b);
400                 jfloat dx12 = NEXT_FLOAT(b);
401                 jfloat dy12 = NEXT_FLOAT(b);
402                 jfloat lwr21 = NEXT_FLOAT(b);
403                 jfloat lwr12 = NEXT_FLOAT(b);
404 
405                 MTLRenderer_DrawParallelogram(mtlc, dstOps,
406                                               x11, y11,
407                                               dx21, dy21,
408                                               dx12, dy12,
409                                               lwr21, lwr12);
410             }
411             break;
412         case sun_java2d_pipe_BufferedOpCodes_DRAW_AAPARALLELOGRAM:
413             {
<a name="9" id="anc9"></a>
414                 jfloat x11 = NEXT_FLOAT(b);
415                 jfloat y11 = NEXT_FLOAT(b);
416                 jfloat dx21 = NEXT_FLOAT(b);
417                 jfloat dy21 = NEXT_FLOAT(b);
418                 jfloat dx12 = NEXT_FLOAT(b);
419                 jfloat dy12 = NEXT_FLOAT(b);
420                 jfloat lwr21 = NEXT_FLOAT(b);
421                 jfloat lwr12 = NEXT_FLOAT(b);
422 
423                 MTLRenderer_DrawAAParallelogram(mtlc, dstOps,
424                                                 x11, y11,
425                                                 dx21, dy21,
426                                                 dx12, dy12,
427                                                 lwr21, lwr12);
428             }
429             break;
430 
431         // fill ops
432         case sun_java2d_pipe_BufferedOpCodes_FILL_RECT:
433             {
<a name="10" id="anc10"></a>
434                 jint x = NEXT_INT(b);
435                 jint y = NEXT_INT(b);
436                 jint w = NEXT_INT(b);
437                 jint h = NEXT_INT(b);
438                 MTLRenderer_FillRect(mtlc, dstOps, x, y, w, h);
439             }
440             break;
441         case sun_java2d_pipe_BufferedOpCodes_FILL_SPANS:
442             {
<a name="11" id="anc11"></a>
443                 jint count = NEXT_INT(b);
444                 MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);
445                 SKIP_BYTES(b, count * BYTES_PER_SPAN);
446             }
447             break;
448         case sun_java2d_pipe_BufferedOpCodes_FILL_PARALLELOGRAM:
449             {
<a name="12" id="anc12"></a>
450                 jfloat x11 = NEXT_FLOAT(b);
451                 jfloat y11 = NEXT_FLOAT(b);
452                 jfloat dx21 = NEXT_FLOAT(b);
453                 jfloat dy21 = NEXT_FLOAT(b);
454                 jfloat dx12 = NEXT_FLOAT(b);
455                 jfloat dy12 = NEXT_FLOAT(b);
456                 MTLRenderer_FillParallelogram(mtlc, dstOps,
457                                               x11, y11,
458                                               dx21, dy21,
459                                               dx12, dy12);
460             }
461             break;
462         case sun_java2d_pipe_BufferedOpCodes_FILL_AAPARALLELOGRAM:
463             {
<a name="13" id="anc13"></a>
464                 jfloat x11 = NEXT_FLOAT(b);
465                 jfloat y11 = NEXT_FLOAT(b);
466                 jfloat dx21 = NEXT_FLOAT(b);
467                 jfloat dy21 = NEXT_FLOAT(b);
468                 jfloat dx12 = NEXT_FLOAT(b);
469                 jfloat dy12 = NEXT_FLOAT(b);
470                 MTLRenderer_FillAAParallelogram(mtlc, dstOps,
471                                                 x11, y11,
472                                                 dx21, dy21,
473                                                 dx12, dy12);
474             }
475             break;
476 
477         // text-related ops
478         case sun_java2d_pipe_BufferedOpCodes_DRAW_GLYPH_LIST:
479             {
<a name="14" id="anc14"></a>
480                 jint numGlyphs        = NEXT_INT(b);
481                 jint packedParams     = NEXT_INT(b);
482                 jfloat glyphListOrigX = NEXT_FLOAT(b);
483                 jfloat glyphListOrigY = NEXT_FLOAT(b);
484                 jboolean usePositions = EXTRACT_BOOLEAN(packedParams,
485                                                         OFFSET_POSITIONS);
486                 jboolean subPixPos    = EXTRACT_BOOLEAN(packedParams,
487                                                         OFFSET_SUBPIXPOS);
488                 jboolean rgbOrder     = EXTRACT_BOOLEAN(packedParams,
489                                                         OFFSET_RGBORDER);
490                 jint lcdContrast      = EXTRACT_BYTE(packedParams,
491                                                      OFFSET_CONTRAST);
492                 unsigned char *images = b;
493                 unsigned char *positions;
494                 jint bytesPerGlyph;
495                 if (usePositions) {
496                     positions = (b + numGlyphs * BYTES_PER_GLYPH_IMAGE);
497                     bytesPerGlyph = BYTES_PER_POSITIONED_GLYPH;
498                 } else {
499                     positions = NULL;
500                     bytesPerGlyph = BYTES_PER_GLYPH_IMAGE;
501                 }
502                 MTLTR_DrawGlyphList(env, mtlc, dstOps,
503                                     numGlyphs, usePositions,
504                                     subPixPos, rgbOrder, lcdContrast,
505                                     glyphListOrigX, glyphListOrigY,
506                                     images, positions);
507                 SKIP_BYTES(b, numGlyphs * bytesPerGlyph);
508             }
509             break;
510 
511         // copy-related ops
512         case sun_java2d_pipe_BufferedOpCodes_COPY_AREA:
513             {
<a name="15" id="anc15"></a>
514                 jint x  = NEXT_INT(b);
515                 jint y  = NEXT_INT(b);
516                 jint w  = NEXT_INT(b);
517                 jint h  = NEXT_INT(b);
518                 jint dx = NEXT_INT(b);
519                 jint dy = NEXT_INT(b);
520                 MTLBlitLoops_CopyArea(env, mtlc, dstOps,
521                                       x, y, w, h, dx, dy);
522             }
523             break;
524         case sun_java2d_pipe_BufferedOpCodes_BLIT:
525             {
<a name="16" id="anc16"></a>
526                 jint packedParams = NEXT_INT(b);
527                 jint sx1          = NEXT_INT(b);
528                 jint sy1          = NEXT_INT(b);
529                 jint sx2          = NEXT_INT(b);
530                 jint sy2          = NEXT_INT(b);
531                 jdouble dx1       = NEXT_DOUBLE(b);
532                 jdouble dy1       = NEXT_DOUBLE(b);
533                 jdouble dx2       = NEXT_DOUBLE(b);
534                 jdouble dy2       = NEXT_DOUBLE(b);
535                 jlong pSrc        = NEXT_LONG(b);
536                 jlong pDst        = NEXT_LONG(b);
537                 jint hint         = EXTRACT_BYTE(packedParams, OFFSET_HINT);
538                 jboolean texture  = EXTRACT_BOOLEAN(packedParams,
539                                                     OFFSET_TEXTURE);
540                 jboolean xform    = EXTRACT_BOOLEAN(packedParams,
541                                                     OFFSET_XFORM);
542                 jboolean isoblit  = EXTRACT_BOOLEAN(packedParams,
543                                                     OFFSET_ISOBLIT);
544                 if (isoblit) {
545                     MTLBlitLoops_IsoBlit(env, mtlc, pSrc, pDst,
546                                          xform, hint, texture,
547                                          sx1, sy1, sx2, sy2,
548                                          dx1, dy1, dx2, dy2);
549                 } else {
550                     jint srctype = EXTRACT_BYTE(packedParams, OFFSET_SRCTYPE);
551                     MTLBlitLoops_Blit(env, mtlc, pSrc, pDst,
552                                       xform, hint, srctype, texture,
553                                       sx1, sy1, sx2, sy2,
554                                       dx1, dy1, dx2, dy2);
555                 }
556             }
557             break;
558         case sun_java2d_pipe_BufferedOpCodes_SURFACE_TO_SW_BLIT:
559             {
<a name="17" id="anc17"></a><span class="line-modified">560 </span>
561                 jint sx      = NEXT_INT(b);
562                 jint sy      = NEXT_INT(b);
563                 jint dx      = NEXT_INT(b);
564                 jint dy      = NEXT_INT(b);
565                 jint w       = NEXT_INT(b);
566                 jint h       = NEXT_INT(b);
567                 jint dsttype = NEXT_INT(b);
568                 jlong pSrc   = NEXT_LONG(b);
569                 jlong pDst   = NEXT_LONG(b);
570                 MTLBlitLoops_SurfaceToSwBlit(env, mtlc,
571                                              pSrc, pDst, dsttype,
572                                              sx, sy, dx, dy, w, h);
573             }
574             break;
575         case sun_java2d_pipe_BufferedOpCodes_MASK_FILL:
576             {
<a name="18" id="anc18"></a><span class="line-modified">577 </span>
578                 jint x        = NEXT_INT(b);
579                 jint y        = NEXT_INT(b);
580                 jint w        = NEXT_INT(b);
581                 jint h        = NEXT_INT(b);
582                 jint maskoff  = NEXT_INT(b);
583                 jint maskscan = NEXT_INT(b);
584                 jint masklen  = NEXT_INT(b);
585                 unsigned char *pMask = (masklen &gt; 0) ? b : NULL;
586                 MTLMaskFill_MaskFill(mtlc, dstOps, x, y, w, h,
587                                      maskoff, maskscan, masklen, pMask);
588                 SKIP_BYTES(b, masklen);
589             }
590             break;
591         case sun_java2d_pipe_BufferedOpCodes_MASK_BLIT:
592             {
<a name="19" id="anc19"></a><span class="line-modified">593 </span>
594                 jint dstx     = NEXT_INT(b);
595                 jint dsty     = NEXT_INT(b);
596                 jint width    = NEXT_INT(b);
597                 jint height   = NEXT_INT(b);
598                 jint masklen  = width * height * sizeof(jint);
599                 MTLMaskBlit_MaskBlit(env, mtlc, dstOps,
600                                      dstx, dsty, width, height, b);
601                 SKIP_BYTES(b, masklen);
602             }
603             break;
604 
605         // state-related ops
606         case sun_java2d_pipe_BufferedOpCodes_SET_RECT_CLIP:
607             {
<a name="20" id="anc20"></a>
608                 jint x1 = NEXT_INT(b);
609                 jint y1 = NEXT_INT(b);
610                 jint x2 = NEXT_INT(b);
611                 jint y2 = NEXT_INT(b);
612                 [mtlc setClipRectX1:x1 Y1:y1 X2:x2 Y2:y2];
613             }
614             break;
615         case sun_java2d_pipe_BufferedOpCodes_BEGIN_SHAPE_CLIP:
616             {
<a name="21" id="anc21"></a>
617                 [mtlc beginShapeClip:dstOps];
618             }
619             break;
620         case sun_java2d_pipe_BufferedOpCodes_SET_SHAPE_CLIP_SPANS:
621             {
<a name="22" id="anc22"></a>
622                 // This results in creation of new render encoder with
623                 // stencil buffer set as render target
624                 jint count = NEXT_INT(b);
625                 MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);
626                 SKIP_BYTES(b, count * BYTES_PER_SPAN);
627             }
628             break;
629         case sun_java2d_pipe_BufferedOpCodes_END_SHAPE_CLIP:
630             {
<a name="23" id="anc23"></a>
631                 [mtlc endShapeClip:dstOps];
632             }
633             break;
634         case sun_java2d_pipe_BufferedOpCodes_RESET_CLIP:
635             {
<a name="24" id="anc24"></a>
636                 [mtlc resetClip];
637             }
638             break;
639         case sun_java2d_pipe_BufferedOpCodes_SET_ALPHA_COMPOSITE:
640             {
<a name="25" id="anc25"></a>
641                 jint rule         = NEXT_INT(b);
642                 jfloat extraAlpha = NEXT_FLOAT(b);
643                 jint flags        = NEXT_INT(b);
644                 [mtlc setAlphaCompositeRule:rule extraAlpha:extraAlpha flags:flags];
645             }
646             break;
647         case sun_java2d_pipe_BufferedOpCodes_SET_XOR_COMPOSITE:
648             {
<a name="26" id="anc26"></a>
649                 jint xorPixel = NEXT_INT(b);
650                 [mtlc setXorComposite:xorPixel];
651             }
652             break;
653         case sun_java2d_pipe_BufferedOpCodes_RESET_COMPOSITE:
654             {
<a name="27" id="anc27"></a>
655                 [mtlc resetComposite];
656             }
657             break;
658         case sun_java2d_pipe_BufferedOpCodes_SET_TRANSFORM:
659             {
<a name="28" id="anc28"></a>
660                 jdouble m00 = NEXT_DOUBLE(b);
661                 jdouble m10 = NEXT_DOUBLE(b);
662                 jdouble m01 = NEXT_DOUBLE(b);
663                 jdouble m11 = NEXT_DOUBLE(b);
664                 jdouble m02 = NEXT_DOUBLE(b);
665                 jdouble m12 = NEXT_DOUBLE(b);
666                 [mtlc setTransformM00:m00 M10:m10 M01:m01 M11:m11 M02:m02 M12:m12];
667             }
668             break;
669         case sun_java2d_pipe_BufferedOpCodes_RESET_TRANSFORM:
670             {
<a name="29" id="anc29"></a>
671                 [mtlc resetTransform];
672             }
673             break;
674 
675         // context-related ops
676         case sun_java2d_pipe_BufferedOpCodes_SET_SURFACES:
677             {
<a name="30" id="anc30"></a><span class="line-modified">678 </span>
679                 jlong pSrc = NEXT_LONG(b);
680                 jlong pDst = NEXT_LONG(b);
681 
682                 dstOps = (BMTLSDOps *)jlong_to_ptr(pDst);
683                 mtlc = [MTLContext setSurfacesEnv:env src:pSrc dst:pDst];
684             }
685             break;
686         case sun_java2d_pipe_BufferedOpCodes_SET_SCRATCH_SURFACE:
687             {
<a name="31" id="anc31"></a>
688                 jlong pConfigInfo = NEXT_LONG(b);
689                 MTLGraphicsConfigInfo *mtlInfo =
690                         (MTLGraphicsConfigInfo *)jlong_to_ptr(pConfigInfo);
691 
692                 if (mtlInfo == NULL) {
693 
694                 } else {
695                     MTLContext *newMtlc = mtlInfo-&gt;context;
696                     if (newMtlc == NULL) {
697 
698                     } else {
699                         mtlc = newMtlc;
700                         dstOps = NULL;
701                     }
702                 }
703             }
704             break;
705         case sun_java2d_pipe_BufferedOpCodes_FLUSH_SURFACE:
706             {
<a name="32" id="anc32"></a>
707                 jlong pData = NEXT_LONG(b);
708                 BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);
709                 if (mtlsdo != NULL) {
710                     CONTINUE_IF_NULL(mtlc);
711                     MTLSD_Delete(env, mtlsdo);
712                 }
713             }
714             break;
715         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_SURFACE:
716             {
<a name="33" id="anc33"></a>
717                 jlong pData = NEXT_LONG(b);
718                 BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);
719                 if (mtlsdo != NULL) {
720                     CONTINUE_IF_NULL(mtlc);
721                     MTLSD_Delete(env, mtlsdo);
722                     if (mtlsdo-&gt;privOps != NULL) {
723                         free(mtlsdo-&gt;privOps);
724                     }
725                 }
726             }
727             break;
728         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_CONFIG:
729             {
<a name="34" id="anc34"></a>
730                 jlong pConfigInfo = NEXT_LONG(b);
731                 CONTINUE_IF_NULL(mtlc);
732                 MTLGC_DestroyMTLGraphicsConfig(pConfigInfo);
733 
734                 // the previous method will call glX/wglMakeCurrent(None),
735                 // so we should nullify the current mtlc and dstOps to avoid
736                 // calling glFlush() (or similar) while no context is current
737                 mtlc = NULL;
738              //   dstOps = NULL;
739             }
740             break;
741         case sun_java2d_pipe_BufferedOpCodes_INVALIDATE_CONTEXT:
742             {
<a name="35" id="anc35"></a>
743                 // invalidate the references to the current context and
744                 // destination surface that are maintained at the native level
745                 mtlc = NULL;
746             //    dstOps = NULL;
747             }
748             break;
749         case sun_java2d_pipe_BufferedOpCodes_SYNC:
750             {
<a name="36" id="anc36"></a>
751                 sync = JNI_TRUE;
752 
753                 // TODO
754                 J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLRenderQueue_SYNC -- :TODO&quot;);
755 
756             }
757             break;
758 
759         // multibuffering ops
760         case sun_java2d_pipe_BufferedOpCodes_SWAP_BUFFERS:
761             {
<a name="37" id="anc37"></a>
762                 jlong window = NEXT_LONG(b);
763                 MTLSD_SwapBuffers(env, window);
764             }
765             break;
766 
767         // special no-op (mainly used for achieving 8-byte alignment)
768         case sun_java2d_pipe_BufferedOpCodes_NOOP:
769             break;
770 
771         // paint-related ops
772         case sun_java2d_pipe_BufferedOpCodes_RESET_PAINT:
773             {
<a name="38" id="anc38"></a><span class="line-modified">774                 [mtlc resetPaint];</span>

775             }
776             break;
777         case sun_java2d_pipe_BufferedOpCodes_SET_COLOR:
778             {
<a name="39" id="anc39"></a>
779                 jint pixel = NEXT_INT(b);
780                 [mtlc setColorPaint:pixel];
781             }
782             break;
783         case sun_java2d_pipe_BufferedOpCodes_SET_GRADIENT_PAINT:
784             {
<a name="40" id="anc40"></a>
785                 jboolean useMask= NEXT_BOOLEAN(b);
786                 jboolean cyclic = NEXT_BOOLEAN(b);
787                 jdouble p0      = NEXT_DOUBLE(b);
788                 jdouble p1      = NEXT_DOUBLE(b);
789                 jdouble p3      = NEXT_DOUBLE(b);
790                 jint pixel1     = NEXT_INT(b);
791                 jint pixel2     = NEXT_INT(b);
792                 [mtlc setGradientPaintUseMask:useMask
793                                     cyclic:cyclic
794                                         p0:p0
795                                         p1:p1
796                                         p3:p3
797                                     pixel1:pixel1
798                                     pixel2:pixel2];
799             }
800             break;
801         case sun_java2d_pipe_BufferedOpCodes_SET_LINEAR_GRADIENT_PAINT:
802             {
<a name="41" id="anc41"></a>
803                 jboolean useMask = NEXT_BOOLEAN(b);
804                 jboolean linear  = NEXT_BOOLEAN(b);
805                 jint cycleMethod = NEXT_INT(b);
806                 jint numStops    = NEXT_INT(b);
807                 jfloat p0        = NEXT_FLOAT(b);
808                 jfloat p1        = NEXT_FLOAT(b);
809                 jfloat p3        = NEXT_FLOAT(b);
810                 void *fractions, *pixels;
811                 fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));
812                 pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));
813                 [mtlc setLinearGradientPaint:useMask
814                                       linear:linear
815                                  cycleMethod:cycleMethod
816                                     numStops:numStops
817                                           p0:p0
818                                           p1:p1
819                                           p3:p3
820                                    fractions:fractions
821                                       pixels:pixels];
822             }
823             break;
824         case sun_java2d_pipe_BufferedOpCodes_SET_RADIAL_GRADIENT_PAINT:
825             {
<a name="42" id="anc42"></a>
826                 jboolean useMask = NEXT_BOOLEAN(b);
827                 jboolean linear  = NEXT_BOOLEAN(b);
828                 jint numStops    = NEXT_INT(b);
829                 jint cycleMethod = NEXT_INT(b);
830                 jfloat m00       = NEXT_FLOAT(b);
831                 jfloat m01       = NEXT_FLOAT(b);
832                 jfloat m02       = NEXT_FLOAT(b);
833                 jfloat m10       = NEXT_FLOAT(b);
834                 jfloat m11       = NEXT_FLOAT(b);
835                 jfloat m12       = NEXT_FLOAT(b);
836                 jfloat focusX    = NEXT_FLOAT(b);
837                 void *fractions, *pixels;
838                 fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));
839                 pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));
840                 [mtlc setRadialGradientPaint:useMask
841                                       linear:linear
842                                  cycleMethod:cycleMethod
843                                     numStops:numStops
844                                          m00:m00
845                                          m01:m01
846                                          m02:m02
847                                          m10:m10
848                                          m11:m11
849                                          m12:m12
850                                       focusX:focusX
851                                    fractions:fractions
852                                       pixels:pixels];
853             }
854             break;
855         case sun_java2d_pipe_BufferedOpCodes_SET_TEXTURE_PAINT:
856             {
<a name="43" id="anc43"></a>
857                 jboolean useMask= NEXT_BOOLEAN(b);
858                 jboolean filter = NEXT_BOOLEAN(b);
859                 jlong pSrc      = NEXT_LONG(b);
860                 jdouble xp0     = NEXT_DOUBLE(b);
861                 jdouble xp1     = NEXT_DOUBLE(b);
862                 jdouble xp3     = NEXT_DOUBLE(b);
863                 jdouble yp0     = NEXT_DOUBLE(b);
864                 jdouble yp1     = NEXT_DOUBLE(b);
865                 jdouble yp3     = NEXT_DOUBLE(b);
866                 [mtlc setTexturePaint:useMask
867                               pSrcOps:pSrc
868                                filter:filter
869                                   xp0:xp0
870                                   xp1:xp1
871                                   xp3:xp3
872                                   yp0:yp0
873                                   yp1:yp1
874                                   yp3:yp3];
875             }
876             break;
877 
878         // BufferedImageOp-related ops
879         case sun_java2d_pipe_BufferedOpCodes_ENABLE_CONVOLVE_OP:
880             {
<a name="44" id="anc44"></a>
881                 jlong pSrc        = NEXT_LONG(b);
882                 jboolean edgeZero = NEXT_BOOLEAN(b);
883                 jint kernelWidth  = NEXT_INT(b);
884                 jint kernelHeight = NEXT_INT(b);
885                 MTLBufImgOps_EnableConvolveOp(mtlc, pSrc, edgeZero,
886                                               kernelWidth, kernelHeight, b);
887                 SKIP_BYTES(b, kernelWidth * kernelHeight * sizeof(jfloat));
888             }
889             break;
890         case sun_java2d_pipe_BufferedOpCodes_DISABLE_CONVOLVE_OP:
891             {
<a name="45" id="anc45"></a>
892                 MTLBufImgOps_DisableConvolveOp(mtlc);
893             }
894             break;
895         case sun_java2d_pipe_BufferedOpCodes_ENABLE_RESCALE_OP:
896             {
<a name="46" id="anc46"></a>
897                 jlong pSrc          = NEXT_LONG(b);
898                 jboolean nonPremult = NEXT_BOOLEAN(b);
899                 jint numFactors     = 4;
900                 unsigned char *scaleFactors = b;
901                 unsigned char *offsets = (b + numFactors * sizeof(jfloat));
902                 MTLBufImgOps_EnableRescaleOp(mtlc, pSrc, nonPremult,
903                                              scaleFactors, offsets);
904                 SKIP_BYTES(b, numFactors * sizeof(jfloat) * 2);
905             }
906             break;
907         case sun_java2d_pipe_BufferedOpCodes_DISABLE_RESCALE_OP:
908             {
<a name="47" id="anc47"></a>
909                 MTLBufImgOps_DisableRescaleOp(mtlc);
910             }
911             break;
912         case sun_java2d_pipe_BufferedOpCodes_ENABLE_LOOKUP_OP:
913             {
<a name="48" id="anc48"></a>
914                 jlong pSrc          = NEXT_LONG(b);
915                 jboolean nonPremult = NEXT_BOOLEAN(b);
916                 jboolean shortData  = NEXT_BOOLEAN(b);
917                 jint numBands       = NEXT_INT(b);
918                 jint bandLength     = NEXT_INT(b);
919                 jint offset         = NEXT_INT(b);
920                 jint bytesPerElem = shortData ? sizeof(jshort):sizeof(jbyte);
921                 void *tableValues = b;
922                 MTLBufImgOps_EnableLookupOp(mtlc, pSrc, nonPremult, shortData,
923                                             numBands, bandLength, offset,
924                                             tableValues);
925                 SKIP_BYTES(b, numBands * bandLength * bytesPerElem);
926             }
927             break;
928         case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:
929             {
<a name="49" id="anc49"></a>
930                 MTLBufImgOps_DisableLookupOp(mtlc);
931             }
932             break;
933 
934         default:
935             J2dRlsTraceLn1(J2D_TRACE_ERROR,
936                 &quot;MTLRenderQueue_flushBuffer: invalid opcode=%d&quot;, opcode);
937             return;
938         }
939     }
940 
<a name="50" id="anc50"></a>
941     if (mtlc != NULL) {
942         [mtlc.encoderManager endEncoder];
943         MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];
944         id&lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
945         [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
946             [cbwrapper release];
947         }];
948         [commandbuf commit];
949         if (sync) {
950             [commandbuf waitUntilCompleted];
951         }
952         BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
953         if (dstOps != NULL) {
954             MTLSDOps *dstMTLOps = (MTLSDOps *)dstOps-&gt;privOps;
955             MTLLayer *layer = (MTLLayer*)dstMTLOps-&gt;layer;
956             if (layer != NULL) {
957                 [JNFRunLoop performOnMainThreadWaiting:NO withBlock:^(){
958                     AWT_ASSERT_APPKIT_THREAD;
959                     [layer setNeedsDisplay];
960                 }];
961             }
962         }
963     }
964 }
965 
966 /**
967  * Returns a pointer to the &quot;current&quot; context, as set by the last SET_SURFACES
968  * or SET_SCRATCH_SURFACE operation.
969  */
970 MTLContext *
971 MTLRenderQueue_GetCurrentContext()
972 {
973     return mtlc;
974 }
975 
976 /**
977  * Returns a pointer to the &quot;current&quot; destination surface, as set by the last
978  * SET_SURFACES operation.
979  */
980 BMTLSDOps *
981 MTLRenderQueue_GetCurrentDestination()
982 {
983     return dstOps;
984 }
985 
986 #endif /* !HEADLESS */
<a name="51" id="anc51"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="51" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLRenderQueue.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MTLRenderQueue.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MTLTransform.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLRenderQueue.m</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  28 #include &lt;stdlib.h&gt;
  29 
  30 #include &quot;sun_java2d_pipe_BufferedOpCodes.h&quot;
  31 
  32 #include &quot;jlong.h&quot;
  33 #include &quot;MTLBlitLoops.h&quot;
  34 #include &quot;MTLBufImgOps.h&quot;
  35 #include &quot;MTLMaskBlit.h&quot;
  36 #include &quot;MTLMaskFill.h&quot;
  37 #include &quot;MTLPaints.h&quot;
  38 #include &quot;MTLRenderQueue.h&quot;
  39 #include &quot;MTLRenderer.h&quot;
  40 #include &quot;MTLTextRenderer.h&quot;
  41 #import &quot;ThreadUtilities.h&quot;
  42 
  43 /**
  44  * References to the &quot;current&quot; context and destination surface.
  45  */
  46 static MTLContext *mtlc = NULL;
  47 static BMTLSDOps *dstOps = NULL;

  48 
  49 /**
  50  * The following methods are implemented in the windowing system (i.e. GLX
  51  * and WGL) source files.
  52  */
  53 extern void MTLGC_DestroyMTLGraphicsConfig(jlong pConfigInfo);
  54 extern void MTLSD_SwapBuffers(JNIEnv *env, jlong window);
  55 
  56 // TODO : Debug logic added for opcode verification,
  57 // should be removed later.
  58 static char *getOpcodeString(jint opcode) {
  59     static char opName[30];
  60     switch (opcode) {
  61         case sun_java2d_pipe_BufferedOpCodes_DRAW_LINE:
  62             {
  63                 strcpy(opName, &quot;DRAW_LINE&quot;);
  64             }
  65             break;
  66         case sun_java2d_pipe_BufferedOpCodes_DRAW_RECT:
  67             {
</pre>
<hr />
<pre>
 289                  strcpy(opName, &quot;DISABLE_RESCALE_OP&quot;);
 290             }
 291             break;
 292         case sun_java2d_pipe_BufferedOpCodes_ENABLE_LOOKUP_OP:
 293             {
 294                 strcpy(opName, &quot;ENABLE_LOOKUP_OP&quot;);
 295             }
 296             break;
 297         case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:
 298             {
 299                 strcpy(opName, &quot;DISABLE_LOOKUP_OP&quot;);
 300             }
 301             break;
 302         default:
 303             strcpy(opName, &quot;UNKNOWN&quot;);
 304             break;
 305         }
 306     return opName;
 307 }
 308 





















 309 JNIEXPORT void JNICALL
 310 Java_sun_java2d_metal_MTLRenderQueue_flushBuffer
 311     (JNIEnv *env, jobject mtlrq,
 312      jlong buf, jint limit)
 313 {
 314     jboolean sync = JNI_FALSE;
 315     unsigned char *b, *end;
 316 
 317     J2dTraceLn1(J2D_TRACE_INFO,
 318                 &quot;MTLRenderQueue_flushBuffer: limit=%d&quot;, limit);
 319 
 320     b = (unsigned char *)jlong_to_ptr(buf);
 321     if (b == NULL) {
 322         J2dRlsTraceLn(J2D_TRACE_ERROR,
 323             &quot;MTLRenderQueue_flushBuffer: cannot get direct buffer address&quot;);
 324         return;
 325     }
 326 
 327     end = b + limit;
 328 
 329     jboolean DEBUG_LOG = JNI_FALSE;
 330     while (b &lt; end) {
 331         jint opcode = NEXT_INT(b);
 332 
 333         if (DEBUG_LOG) {
 334             J2dTraceLn2(J2D_TRACE_ERROR,
 335                     &quot;MTLRenderQueue_flushBuffer: opcode_name = %s, rem=%d&quot;,
 336                     getOpcodeString(opcode), (end-b));
 337         } else {
 338             J2dTraceLn2(J2D_TRACE_VERBOSE,
 339                     &quot;MTLRenderQueue_flushBuffer: opcode=%d, rem=%d&quot;,
 340                     opcode, (end-b));
 341         }
 342 
 343         switch (opcode) {
 344 
 345         // draw ops
 346         case sun_java2d_pipe_BufferedOpCodes_DRAW_LINE:
 347             {

 348                 J2dTraceLn(J2D_TRACE_VERBOSE, &quot;sun_java2d_pipe_BufferedOpCodes_DRAW_LINE&quot;);
 349                 jint x1 = NEXT_INT(b);
 350                 jint y1 = NEXT_INT(b);
 351                 jint x2 = NEXT_INT(b);
 352                 jint y2 = NEXT_INT(b);
 353                 MTLRenderer_DrawLine(mtlc, dstOps, x1, y1, x2, y2);
 354             }
 355             break;
 356         case sun_java2d_pipe_BufferedOpCodes_DRAW_RECT:
 357             {

 358                 jint x = NEXT_INT(b);
 359                 jint y = NEXT_INT(b);
 360                 jint w = NEXT_INT(b);
 361                 jint h = NEXT_INT(b);
 362                 MTLRenderer_DrawRect(mtlc, dstOps, x, y, w, h);
 363             }
 364             break;
 365         case sun_java2d_pipe_BufferedOpCodes_DRAW_POLY:
 366             {

 367                 jint nPoints      = NEXT_INT(b);
 368                 jboolean isClosed = NEXT_BOOLEAN(b);
 369                 jint transX       = NEXT_INT(b);
 370                 jint transY       = NEXT_INT(b);
 371                 jint *xPoints = (jint *)b;
 372                 jint *yPoints = ((jint *)b) + nPoints;
 373                 MTLRenderer_DrawPoly(mtlc, dstOps, nPoints, isClosed, transX, transY, xPoints, yPoints);
 374                 SKIP_BYTES(b, nPoints * BYTES_PER_POLY_POINT);
 375             }
 376             break;
 377         case sun_java2d_pipe_BufferedOpCodes_DRAW_PIXEL:
 378             {

 379                 jint x = NEXT_INT(b);
 380                 jint y = NEXT_INT(b);
 381                 CONTINUE_IF_NULL(mtlc);
 382                 //TODO
 383                 J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLRenderQueue_DRAW_PIXEL -- :TODO&quot;);
 384             }
 385             break;
 386         case sun_java2d_pipe_BufferedOpCodes_DRAW_SCANLINES:
 387             {

 388                 jint count = NEXT_INT(b);
 389                 MTLRenderer_DrawScanlines(mtlc, dstOps, count, (jint *)b);
 390 
 391                 SKIP_BYTES(b, count * BYTES_PER_SCANLINE);
 392             }
 393             break;
 394         case sun_java2d_pipe_BufferedOpCodes_DRAW_PARALLELOGRAM:
 395             {

 396                 jfloat x11 = NEXT_FLOAT(b);
 397                 jfloat y11 = NEXT_FLOAT(b);
 398                 jfloat dx21 = NEXT_FLOAT(b);
 399                 jfloat dy21 = NEXT_FLOAT(b);
 400                 jfloat dx12 = NEXT_FLOAT(b);
 401                 jfloat dy12 = NEXT_FLOAT(b);
 402                 jfloat lwr21 = NEXT_FLOAT(b);
 403                 jfloat lwr12 = NEXT_FLOAT(b);
 404 
 405                 MTLRenderer_DrawParallelogram(mtlc, dstOps,
 406                                               x11, y11,
 407                                               dx21, dy21,
 408                                               dx12, dy12,
 409                                               lwr21, lwr12);
 410             }
 411             break;
 412         case sun_java2d_pipe_BufferedOpCodes_DRAW_AAPARALLELOGRAM:
 413             {

 414                 jfloat x11 = NEXT_FLOAT(b);
 415                 jfloat y11 = NEXT_FLOAT(b);
 416                 jfloat dx21 = NEXT_FLOAT(b);
 417                 jfloat dy21 = NEXT_FLOAT(b);
 418                 jfloat dx12 = NEXT_FLOAT(b);
 419                 jfloat dy12 = NEXT_FLOAT(b);
 420                 jfloat lwr21 = NEXT_FLOAT(b);
 421                 jfloat lwr12 = NEXT_FLOAT(b);
 422 
 423                 MTLRenderer_DrawAAParallelogram(mtlc, dstOps,
 424                                                 x11, y11,
 425                                                 dx21, dy21,
 426                                                 dx12, dy12,
 427                                                 lwr21, lwr12);
 428             }
 429             break;
 430 
 431         // fill ops
 432         case sun_java2d_pipe_BufferedOpCodes_FILL_RECT:
 433             {

 434                 jint x = NEXT_INT(b);
 435                 jint y = NEXT_INT(b);
 436                 jint w = NEXT_INT(b);
 437                 jint h = NEXT_INT(b);
 438                 MTLRenderer_FillRect(mtlc, dstOps, x, y, w, h);
 439             }
 440             break;
 441         case sun_java2d_pipe_BufferedOpCodes_FILL_SPANS:
 442             {

 443                 jint count = NEXT_INT(b);
 444                 MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);
 445                 SKIP_BYTES(b, count * BYTES_PER_SPAN);
 446             }
 447             break;
 448         case sun_java2d_pipe_BufferedOpCodes_FILL_PARALLELOGRAM:
 449             {

 450                 jfloat x11 = NEXT_FLOAT(b);
 451                 jfloat y11 = NEXT_FLOAT(b);
 452                 jfloat dx21 = NEXT_FLOAT(b);
 453                 jfloat dy21 = NEXT_FLOAT(b);
 454                 jfloat dx12 = NEXT_FLOAT(b);
 455                 jfloat dy12 = NEXT_FLOAT(b);
 456                 MTLRenderer_FillParallelogram(mtlc, dstOps,
 457                                               x11, y11,
 458                                               dx21, dy21,
 459                                               dx12, dy12);
 460             }
 461             break;
 462         case sun_java2d_pipe_BufferedOpCodes_FILL_AAPARALLELOGRAM:
 463             {

 464                 jfloat x11 = NEXT_FLOAT(b);
 465                 jfloat y11 = NEXT_FLOAT(b);
 466                 jfloat dx21 = NEXT_FLOAT(b);
 467                 jfloat dy21 = NEXT_FLOAT(b);
 468                 jfloat dx12 = NEXT_FLOAT(b);
 469                 jfloat dy12 = NEXT_FLOAT(b);
 470                 MTLRenderer_FillAAParallelogram(mtlc, dstOps,
 471                                                 x11, y11,
 472                                                 dx21, dy21,
 473                                                 dx12, dy12);
 474             }
 475             break;
 476 
 477         // text-related ops
 478         case sun_java2d_pipe_BufferedOpCodes_DRAW_GLYPH_LIST:
 479             {

 480                 jint numGlyphs        = NEXT_INT(b);
 481                 jint packedParams     = NEXT_INT(b);
 482                 jfloat glyphListOrigX = NEXT_FLOAT(b);
 483                 jfloat glyphListOrigY = NEXT_FLOAT(b);
 484                 jboolean usePositions = EXTRACT_BOOLEAN(packedParams,
 485                                                         OFFSET_POSITIONS);
 486                 jboolean subPixPos    = EXTRACT_BOOLEAN(packedParams,
 487                                                         OFFSET_SUBPIXPOS);
 488                 jboolean rgbOrder     = EXTRACT_BOOLEAN(packedParams,
 489                                                         OFFSET_RGBORDER);
 490                 jint lcdContrast      = EXTRACT_BYTE(packedParams,
 491                                                      OFFSET_CONTRAST);
 492                 unsigned char *images = b;
 493                 unsigned char *positions;
 494                 jint bytesPerGlyph;
 495                 if (usePositions) {
 496                     positions = (b + numGlyphs * BYTES_PER_GLYPH_IMAGE);
 497                     bytesPerGlyph = BYTES_PER_POSITIONED_GLYPH;
 498                 } else {
 499                     positions = NULL;
 500                     bytesPerGlyph = BYTES_PER_GLYPH_IMAGE;
 501                 }
 502                 MTLTR_DrawGlyphList(env, mtlc, dstOps,
 503                                     numGlyphs, usePositions,
 504                                     subPixPos, rgbOrder, lcdContrast,
 505                                     glyphListOrigX, glyphListOrigY,
 506                                     images, positions);
 507                 SKIP_BYTES(b, numGlyphs * bytesPerGlyph);
 508             }
 509             break;
 510 
 511         // copy-related ops
 512         case sun_java2d_pipe_BufferedOpCodes_COPY_AREA:
 513             {

 514                 jint x  = NEXT_INT(b);
 515                 jint y  = NEXT_INT(b);
 516                 jint w  = NEXT_INT(b);
 517                 jint h  = NEXT_INT(b);
 518                 jint dx = NEXT_INT(b);
 519                 jint dy = NEXT_INT(b);
 520                 MTLBlitLoops_CopyArea(env, mtlc, dstOps,
 521                                       x, y, w, h, dx, dy);
 522             }
 523             break;
 524         case sun_java2d_pipe_BufferedOpCodes_BLIT:
 525             {

 526                 jint packedParams = NEXT_INT(b);
 527                 jint sx1          = NEXT_INT(b);
 528                 jint sy1          = NEXT_INT(b);
 529                 jint sx2          = NEXT_INT(b);
 530                 jint sy2          = NEXT_INT(b);
 531                 jdouble dx1       = NEXT_DOUBLE(b);
 532                 jdouble dy1       = NEXT_DOUBLE(b);
 533                 jdouble dx2       = NEXT_DOUBLE(b);
 534                 jdouble dy2       = NEXT_DOUBLE(b);
 535                 jlong pSrc        = NEXT_LONG(b);
 536                 jlong pDst        = NEXT_LONG(b);
 537                 jint hint         = EXTRACT_BYTE(packedParams, OFFSET_HINT);
 538                 jboolean texture  = EXTRACT_BOOLEAN(packedParams,
 539                                                     OFFSET_TEXTURE);
 540                 jboolean xform    = EXTRACT_BOOLEAN(packedParams,
 541                                                     OFFSET_XFORM);
 542                 jboolean isoblit  = EXTRACT_BOOLEAN(packedParams,
 543                                                     OFFSET_ISOBLIT);
 544                 if (isoblit) {
 545                     MTLBlitLoops_IsoBlit(env, mtlc, pSrc, pDst,
 546                                          xform, hint, texture,
 547                                          sx1, sy1, sx2, sy2,
 548                                          dx1, dy1, dx2, dy2);
 549                 } else {
 550                     jint srctype = EXTRACT_BYTE(packedParams, OFFSET_SRCTYPE);
 551                     MTLBlitLoops_Blit(env, mtlc, pSrc, pDst,
 552                                       xform, hint, srctype, texture,
 553                                       sx1, sy1, sx2, sy2,
 554                                       dx1, dy1, dx2, dy2);
 555                 }
 556             }
 557             break;
 558         case sun_java2d_pipe_BufferedOpCodes_SURFACE_TO_SW_BLIT:
 559             {
<span class="line-modified"> 560 </span>
 561                 jint sx      = NEXT_INT(b);
 562                 jint sy      = NEXT_INT(b);
 563                 jint dx      = NEXT_INT(b);
 564                 jint dy      = NEXT_INT(b);
 565                 jint w       = NEXT_INT(b);
 566                 jint h       = NEXT_INT(b);
 567                 jint dsttype = NEXT_INT(b);
 568                 jlong pSrc   = NEXT_LONG(b);
 569                 jlong pDst   = NEXT_LONG(b);
 570                 MTLBlitLoops_SurfaceToSwBlit(env, mtlc,
 571                                              pSrc, pDst, dsttype,
 572                                              sx, sy, dx, dy, w, h);
 573             }
 574             break;
 575         case sun_java2d_pipe_BufferedOpCodes_MASK_FILL:
 576             {
<span class="line-modified"> 577 </span>
 578                 jint x        = NEXT_INT(b);
 579                 jint y        = NEXT_INT(b);
 580                 jint w        = NEXT_INT(b);
 581                 jint h        = NEXT_INT(b);
 582                 jint maskoff  = NEXT_INT(b);
 583                 jint maskscan = NEXT_INT(b);
 584                 jint masklen  = NEXT_INT(b);
 585                 unsigned char *pMask = (masklen &gt; 0) ? b : NULL;
 586                 MTLMaskFill_MaskFill(mtlc, dstOps, x, y, w, h,
 587                                      maskoff, maskscan, masklen, pMask);
 588                 SKIP_BYTES(b, masklen);
 589             }
 590             break;
 591         case sun_java2d_pipe_BufferedOpCodes_MASK_BLIT:
 592             {
<span class="line-modified"> 593 </span>
 594                 jint dstx     = NEXT_INT(b);
 595                 jint dsty     = NEXT_INT(b);
 596                 jint width    = NEXT_INT(b);
 597                 jint height   = NEXT_INT(b);
 598                 jint masklen  = width * height * sizeof(jint);
 599                 MTLMaskBlit_MaskBlit(env, mtlc, dstOps,
 600                                      dstx, dsty, width, height, b);
 601                 SKIP_BYTES(b, masklen);
 602             }
 603             break;
 604 
 605         // state-related ops
 606         case sun_java2d_pipe_BufferedOpCodes_SET_RECT_CLIP:
 607             {

 608                 jint x1 = NEXT_INT(b);
 609                 jint y1 = NEXT_INT(b);
 610                 jint x2 = NEXT_INT(b);
 611                 jint y2 = NEXT_INT(b);
 612                 [mtlc setClipRectX1:x1 Y1:y1 X2:x2 Y2:y2];
 613             }
 614             break;
 615         case sun_java2d_pipe_BufferedOpCodes_BEGIN_SHAPE_CLIP:
 616             {

 617                 [mtlc beginShapeClip:dstOps];
 618             }
 619             break;
 620         case sun_java2d_pipe_BufferedOpCodes_SET_SHAPE_CLIP_SPANS:
 621             {

 622                 // This results in creation of new render encoder with
 623                 // stencil buffer set as render target
 624                 jint count = NEXT_INT(b);
 625                 MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);
 626                 SKIP_BYTES(b, count * BYTES_PER_SPAN);
 627             }
 628             break;
 629         case sun_java2d_pipe_BufferedOpCodes_END_SHAPE_CLIP:
 630             {

 631                 [mtlc endShapeClip:dstOps];
 632             }
 633             break;
 634         case sun_java2d_pipe_BufferedOpCodes_RESET_CLIP:
 635             {

 636                 [mtlc resetClip];
 637             }
 638             break;
 639         case sun_java2d_pipe_BufferedOpCodes_SET_ALPHA_COMPOSITE:
 640             {

 641                 jint rule         = NEXT_INT(b);
 642                 jfloat extraAlpha = NEXT_FLOAT(b);
 643                 jint flags        = NEXT_INT(b);
 644                 [mtlc setAlphaCompositeRule:rule extraAlpha:extraAlpha flags:flags];
 645             }
 646             break;
 647         case sun_java2d_pipe_BufferedOpCodes_SET_XOR_COMPOSITE:
 648             {

 649                 jint xorPixel = NEXT_INT(b);
 650                 [mtlc setXorComposite:xorPixel];
 651             }
 652             break;
 653         case sun_java2d_pipe_BufferedOpCodes_RESET_COMPOSITE:
 654             {

 655                 [mtlc resetComposite];
 656             }
 657             break;
 658         case sun_java2d_pipe_BufferedOpCodes_SET_TRANSFORM:
 659             {

 660                 jdouble m00 = NEXT_DOUBLE(b);
 661                 jdouble m10 = NEXT_DOUBLE(b);
 662                 jdouble m01 = NEXT_DOUBLE(b);
 663                 jdouble m11 = NEXT_DOUBLE(b);
 664                 jdouble m02 = NEXT_DOUBLE(b);
 665                 jdouble m12 = NEXT_DOUBLE(b);
 666                 [mtlc setTransformM00:m00 M10:m10 M01:m01 M11:m11 M02:m02 M12:m12];
 667             }
 668             break;
 669         case sun_java2d_pipe_BufferedOpCodes_RESET_TRANSFORM:
 670             {

 671                 [mtlc resetTransform];
 672             }
 673             break;
 674 
 675         // context-related ops
 676         case sun_java2d_pipe_BufferedOpCodes_SET_SURFACES:
 677             {
<span class="line-modified"> 678 </span>
 679                 jlong pSrc = NEXT_LONG(b);
 680                 jlong pDst = NEXT_LONG(b);
 681 
 682                 dstOps = (BMTLSDOps *)jlong_to_ptr(pDst);
 683                 mtlc = [MTLContext setSurfacesEnv:env src:pSrc dst:pDst];
 684             }
 685             break;
 686         case sun_java2d_pipe_BufferedOpCodes_SET_SCRATCH_SURFACE:
 687             {

 688                 jlong pConfigInfo = NEXT_LONG(b);
 689                 MTLGraphicsConfigInfo *mtlInfo =
 690                         (MTLGraphicsConfigInfo *)jlong_to_ptr(pConfigInfo);
 691 
 692                 if (mtlInfo == NULL) {
 693 
 694                 } else {
 695                     MTLContext *newMtlc = mtlInfo-&gt;context;
 696                     if (newMtlc == NULL) {
 697 
 698                     } else {
 699                         mtlc = newMtlc;
 700                         dstOps = NULL;
 701                     }
 702                 }
 703             }
 704             break;
 705         case sun_java2d_pipe_BufferedOpCodes_FLUSH_SURFACE:
 706             {

 707                 jlong pData = NEXT_LONG(b);
 708                 BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);
 709                 if (mtlsdo != NULL) {
 710                     CONTINUE_IF_NULL(mtlc);
 711                     MTLSD_Delete(env, mtlsdo);
 712                 }
 713             }
 714             break;
 715         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_SURFACE:
 716             {

 717                 jlong pData = NEXT_LONG(b);
 718                 BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);
 719                 if (mtlsdo != NULL) {
 720                     CONTINUE_IF_NULL(mtlc);
 721                     MTLSD_Delete(env, mtlsdo);
 722                     if (mtlsdo-&gt;privOps != NULL) {
 723                         free(mtlsdo-&gt;privOps);
 724                     }
 725                 }
 726             }
 727             break;
 728         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_CONFIG:
 729             {

 730                 jlong pConfigInfo = NEXT_LONG(b);
 731                 CONTINUE_IF_NULL(mtlc);
 732                 MTLGC_DestroyMTLGraphicsConfig(pConfigInfo);
 733 
 734                 // the previous method will call glX/wglMakeCurrent(None),
 735                 // so we should nullify the current mtlc and dstOps to avoid
 736                 // calling glFlush() (or similar) while no context is current
 737                 mtlc = NULL;
 738              //   dstOps = NULL;
 739             }
 740             break;
 741         case sun_java2d_pipe_BufferedOpCodes_INVALIDATE_CONTEXT:
 742             {

 743                 // invalidate the references to the current context and
 744                 // destination surface that are maintained at the native level
 745                 mtlc = NULL;
 746             //    dstOps = NULL;
 747             }
 748             break;
 749         case sun_java2d_pipe_BufferedOpCodes_SYNC:
 750             {

 751                 sync = JNI_TRUE;
 752 
 753                 // TODO
 754                 J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLRenderQueue_SYNC -- :TODO&quot;);
 755 
 756             }
 757             break;
 758 
 759         // multibuffering ops
 760         case sun_java2d_pipe_BufferedOpCodes_SWAP_BUFFERS:
 761             {

 762                 jlong window = NEXT_LONG(b);
 763                 MTLSD_SwapBuffers(env, window);
 764             }
 765             break;
 766 
 767         // special no-op (mainly used for achieving 8-byte alignment)
 768         case sun_java2d_pipe_BufferedOpCodes_NOOP:
 769             break;
 770 
 771         // paint-related ops
 772         case sun_java2d_pipe_BufferedOpCodes_RESET_PAINT:
 773             {
<span class="line-modified"> 774                 [mtlc resetPaint];</span>

 775             }
 776             break;
 777         case sun_java2d_pipe_BufferedOpCodes_SET_COLOR:
 778             {

 779                 jint pixel = NEXT_INT(b);
 780                 [mtlc setColorPaint:pixel];
 781             }
 782             break;
 783         case sun_java2d_pipe_BufferedOpCodes_SET_GRADIENT_PAINT:
 784             {

 785                 jboolean useMask= NEXT_BOOLEAN(b);
 786                 jboolean cyclic = NEXT_BOOLEAN(b);
 787                 jdouble p0      = NEXT_DOUBLE(b);
 788                 jdouble p1      = NEXT_DOUBLE(b);
 789                 jdouble p3      = NEXT_DOUBLE(b);
 790                 jint pixel1     = NEXT_INT(b);
 791                 jint pixel2     = NEXT_INT(b);
 792                 [mtlc setGradientPaintUseMask:useMask
 793                                     cyclic:cyclic
 794                                         p0:p0
 795                                         p1:p1
 796                                         p3:p3
 797                                     pixel1:pixel1
 798                                     pixel2:pixel2];
 799             }
 800             break;
 801         case sun_java2d_pipe_BufferedOpCodes_SET_LINEAR_GRADIENT_PAINT:
 802             {

 803                 jboolean useMask = NEXT_BOOLEAN(b);
 804                 jboolean linear  = NEXT_BOOLEAN(b);
 805                 jint cycleMethod = NEXT_INT(b);
 806                 jint numStops    = NEXT_INT(b);
 807                 jfloat p0        = NEXT_FLOAT(b);
 808                 jfloat p1        = NEXT_FLOAT(b);
 809                 jfloat p3        = NEXT_FLOAT(b);
 810                 void *fractions, *pixels;
 811                 fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));
 812                 pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));
 813                 [mtlc setLinearGradientPaint:useMask
 814                                       linear:linear
 815                                  cycleMethod:cycleMethod
 816                                     numStops:numStops
 817                                           p0:p0
 818                                           p1:p1
 819                                           p3:p3
 820                                    fractions:fractions
 821                                       pixels:pixels];
 822             }
 823             break;
 824         case sun_java2d_pipe_BufferedOpCodes_SET_RADIAL_GRADIENT_PAINT:
 825             {

 826                 jboolean useMask = NEXT_BOOLEAN(b);
 827                 jboolean linear  = NEXT_BOOLEAN(b);
 828                 jint numStops    = NEXT_INT(b);
 829                 jint cycleMethod = NEXT_INT(b);
 830                 jfloat m00       = NEXT_FLOAT(b);
 831                 jfloat m01       = NEXT_FLOAT(b);
 832                 jfloat m02       = NEXT_FLOAT(b);
 833                 jfloat m10       = NEXT_FLOAT(b);
 834                 jfloat m11       = NEXT_FLOAT(b);
 835                 jfloat m12       = NEXT_FLOAT(b);
 836                 jfloat focusX    = NEXT_FLOAT(b);
 837                 void *fractions, *pixels;
 838                 fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));
 839                 pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));
 840                 [mtlc setRadialGradientPaint:useMask
 841                                       linear:linear
 842                                  cycleMethod:cycleMethod
 843                                     numStops:numStops
 844                                          m00:m00
 845                                          m01:m01
 846                                          m02:m02
 847                                          m10:m10
 848                                          m11:m11
 849                                          m12:m12
 850                                       focusX:focusX
 851                                    fractions:fractions
 852                                       pixels:pixels];
 853             }
 854             break;
 855         case sun_java2d_pipe_BufferedOpCodes_SET_TEXTURE_PAINT:
 856             {

 857                 jboolean useMask= NEXT_BOOLEAN(b);
 858                 jboolean filter = NEXT_BOOLEAN(b);
 859                 jlong pSrc      = NEXT_LONG(b);
 860                 jdouble xp0     = NEXT_DOUBLE(b);
 861                 jdouble xp1     = NEXT_DOUBLE(b);
 862                 jdouble xp3     = NEXT_DOUBLE(b);
 863                 jdouble yp0     = NEXT_DOUBLE(b);
 864                 jdouble yp1     = NEXT_DOUBLE(b);
 865                 jdouble yp3     = NEXT_DOUBLE(b);
 866                 [mtlc setTexturePaint:useMask
 867                               pSrcOps:pSrc
 868                                filter:filter
 869                                   xp0:xp0
 870                                   xp1:xp1
 871                                   xp3:xp3
 872                                   yp0:yp0
 873                                   yp1:yp1
 874                                   yp3:yp3];
 875             }
 876             break;
 877 
 878         // BufferedImageOp-related ops
 879         case sun_java2d_pipe_BufferedOpCodes_ENABLE_CONVOLVE_OP:
 880             {

 881                 jlong pSrc        = NEXT_LONG(b);
 882                 jboolean edgeZero = NEXT_BOOLEAN(b);
 883                 jint kernelWidth  = NEXT_INT(b);
 884                 jint kernelHeight = NEXT_INT(b);
 885                 MTLBufImgOps_EnableConvolveOp(mtlc, pSrc, edgeZero,
 886                                               kernelWidth, kernelHeight, b);
 887                 SKIP_BYTES(b, kernelWidth * kernelHeight * sizeof(jfloat));
 888             }
 889             break;
 890         case sun_java2d_pipe_BufferedOpCodes_DISABLE_CONVOLVE_OP:
 891             {

 892                 MTLBufImgOps_DisableConvolveOp(mtlc);
 893             }
 894             break;
 895         case sun_java2d_pipe_BufferedOpCodes_ENABLE_RESCALE_OP:
 896             {

 897                 jlong pSrc          = NEXT_LONG(b);
 898                 jboolean nonPremult = NEXT_BOOLEAN(b);
 899                 jint numFactors     = 4;
 900                 unsigned char *scaleFactors = b;
 901                 unsigned char *offsets = (b + numFactors * sizeof(jfloat));
 902                 MTLBufImgOps_EnableRescaleOp(mtlc, pSrc, nonPremult,
 903                                              scaleFactors, offsets);
 904                 SKIP_BYTES(b, numFactors * sizeof(jfloat) * 2);
 905             }
 906             break;
 907         case sun_java2d_pipe_BufferedOpCodes_DISABLE_RESCALE_OP:
 908             {

 909                 MTLBufImgOps_DisableRescaleOp(mtlc);
 910             }
 911             break;
 912         case sun_java2d_pipe_BufferedOpCodes_ENABLE_LOOKUP_OP:
 913             {

 914                 jlong pSrc          = NEXT_LONG(b);
 915                 jboolean nonPremult = NEXT_BOOLEAN(b);
 916                 jboolean shortData  = NEXT_BOOLEAN(b);
 917                 jint numBands       = NEXT_INT(b);
 918                 jint bandLength     = NEXT_INT(b);
 919                 jint offset         = NEXT_INT(b);
 920                 jint bytesPerElem = shortData ? sizeof(jshort):sizeof(jbyte);
 921                 void *tableValues = b;
 922                 MTLBufImgOps_EnableLookupOp(mtlc, pSrc, nonPremult, shortData,
 923                                             numBands, bandLength, offset,
 924                                             tableValues);
 925                 SKIP_BYTES(b, numBands * bandLength * bytesPerElem);
 926             }
 927             break;
 928         case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:
 929             {

 930                 MTLBufImgOps_DisableLookupOp(mtlc);
 931             }
 932             break;
 933 
 934         default:
 935             J2dRlsTraceLn1(J2D_TRACE_ERROR,
 936                 &quot;MTLRenderQueue_flushBuffer: invalid opcode=%d&quot;, opcode);
 937             return;
 938         }
 939     }
 940 

 941     if (mtlc != NULL) {
 942         [mtlc.encoderManager endEncoder];
 943         MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];
 944         id&lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
 945         [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
 946             [cbwrapper release];
 947         }];
 948         [commandbuf commit];
 949         if (sync) {
 950             [commandbuf waitUntilCompleted];
 951         }
 952         BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
 953         if (dstOps != NULL) {
 954             MTLSDOps *dstMTLOps = (MTLSDOps *)dstOps-&gt;privOps;
 955             MTLLayer *layer = (MTLLayer*)dstMTLOps-&gt;layer;
 956             if (layer != NULL) {
 957                 [JNFRunLoop performOnMainThreadWaiting:NO withBlock:^(){
 958                     AWT_ASSERT_APPKIT_THREAD;
 959                     [layer setNeedsDisplay];
 960                 }];
</pre>
</td>
<td>
<hr />
<pre>
  28 #include &lt;stdlib.h&gt;
  29 
  30 #include &quot;sun_java2d_pipe_BufferedOpCodes.h&quot;
  31 
  32 #include &quot;jlong.h&quot;
  33 #include &quot;MTLBlitLoops.h&quot;
  34 #include &quot;MTLBufImgOps.h&quot;
  35 #include &quot;MTLMaskBlit.h&quot;
  36 #include &quot;MTLMaskFill.h&quot;
  37 #include &quot;MTLPaints.h&quot;
  38 #include &quot;MTLRenderQueue.h&quot;
  39 #include &quot;MTLRenderer.h&quot;
  40 #include &quot;MTLTextRenderer.h&quot;
  41 #import &quot;ThreadUtilities.h&quot;
  42 
  43 /**
  44  * References to the &quot;current&quot; context and destination surface.
  45  */
  46 static MTLContext *mtlc = NULL;
  47 static BMTLSDOps *dstOps = NULL;
<span class="line-added">  48 jint mtlPreviousOp = MTL_OP_INIT;</span>
  49 
  50 /**
  51  * The following methods are implemented in the windowing system (i.e. GLX
  52  * and WGL) source files.
  53  */
  54 extern void MTLGC_DestroyMTLGraphicsConfig(jlong pConfigInfo);
  55 extern void MTLSD_SwapBuffers(JNIEnv *env, jlong window);
  56 
  57 // TODO : Debug logic added for opcode verification,
  58 // should be removed later.
  59 static char *getOpcodeString(jint opcode) {
  60     static char opName[30];
  61     switch (opcode) {
  62         case sun_java2d_pipe_BufferedOpCodes_DRAW_LINE:
  63             {
  64                 strcpy(opName, &quot;DRAW_LINE&quot;);
  65             }
  66             break;
  67         case sun_java2d_pipe_BufferedOpCodes_DRAW_RECT:
  68             {
</pre>
<hr />
<pre>
 290                  strcpy(opName, &quot;DISABLE_RESCALE_OP&quot;);
 291             }
 292             break;
 293         case sun_java2d_pipe_BufferedOpCodes_ENABLE_LOOKUP_OP:
 294             {
 295                 strcpy(opName, &quot;ENABLE_LOOKUP_OP&quot;);
 296             }
 297             break;
 298         case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:
 299             {
 300                 strcpy(opName, &quot;DISABLE_LOOKUP_OP&quot;);
 301             }
 302             break;
 303         default:
 304             strcpy(opName, &quot;UNKNOWN&quot;);
 305             break;
 306         }
 307     return opName;
 308 }
 309 
<span class="line-added"> 310 void MTLRenderQueue_CheckPreviousOp(jint op) {</span>
<span class="line-added"> 311 </span>
<span class="line-added"> 312     if (mtlPreviousOp == op) {</span>
<span class="line-added"> 313         // The op is the same as last time, so we can return immediately.</span>
<span class="line-added"> 314         return;</span>
<span class="line-added"> 315     }</span>
<span class="line-added"> 316 </span>
<span class="line-added"> 317     J2dTraceLn1(J2D_TRACE_VERBOSE,</span>
<span class="line-added"> 318                 &quot;MTLRenderQueue_CheckPreviousOp: new op=%d&quot;, op);</span>
<span class="line-added"> 319 </span>
<span class="line-added"> 320     if (mtlPreviousOp == MTL_OP_INIT) {</span>
<span class="line-added"> 321         mtlPreviousOp = op;</span>
<span class="line-added"> 322         return;</span>
<span class="line-added"> 323     }</span>
<span class="line-added"> 324 </span>
<span class="line-added"> 325     if (mtlc != NULL) {</span>
<span class="line-added"> 326         [mtlc.encoderManager endEncoder];</span>
<span class="line-added"> 327     }</span>
<span class="line-added"> 328     mtlPreviousOp = op;</span>
<span class="line-added"> 329 }</span>
<span class="line-added"> 330 </span>
 331 JNIEXPORT void JNICALL
 332 Java_sun_java2d_metal_MTLRenderQueue_flushBuffer
 333     (JNIEnv *env, jobject mtlrq,
 334      jlong buf, jint limit)
 335 {
 336     jboolean sync = JNI_FALSE;
 337     unsigned char *b, *end;
 338 
 339     J2dTraceLn1(J2D_TRACE_INFO,
 340                 &quot;MTLRenderQueue_flushBuffer: limit=%d&quot;, limit);
 341 
 342     b = (unsigned char *)jlong_to_ptr(buf);
 343     if (b == NULL) {
 344         J2dRlsTraceLn(J2D_TRACE_ERROR,
 345             &quot;MTLRenderQueue_flushBuffer: cannot get direct buffer address&quot;);
 346         return;
 347     }
 348 
 349     end = b + limit;
 350 
 351     jboolean DEBUG_LOG = JNI_FALSE;
 352     while (b &lt; end) {
 353         jint opcode = NEXT_INT(b);
 354 
 355         if (DEBUG_LOG) {
 356             J2dTraceLn2(J2D_TRACE_ERROR,
 357                     &quot;MTLRenderQueue_flushBuffer: opcode_name = %s, rem=%d&quot;,
 358                     getOpcodeString(opcode), (end-b));
 359         } else {
 360             J2dTraceLn2(J2D_TRACE_VERBOSE,
 361                     &quot;MTLRenderQueue_flushBuffer: opcode=%d, rem=%d&quot;,
 362                     opcode, (end-b));
 363         }
 364 
 365         switch (opcode) {
 366 
 367         // draw ops
 368         case sun_java2d_pipe_BufferedOpCodes_DRAW_LINE:
 369             {
<span class="line-added"> 370                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 371                 J2dTraceLn(J2D_TRACE_VERBOSE, &quot;sun_java2d_pipe_BufferedOpCodes_DRAW_LINE&quot;);
 372                 jint x1 = NEXT_INT(b);
 373                 jint y1 = NEXT_INT(b);
 374                 jint x2 = NEXT_INT(b);
 375                 jint y2 = NEXT_INT(b);
 376                 MTLRenderer_DrawLine(mtlc, dstOps, x1, y1, x2, y2);
 377             }
 378             break;
 379         case sun_java2d_pipe_BufferedOpCodes_DRAW_RECT:
 380             {
<span class="line-added"> 381                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 382                 jint x = NEXT_INT(b);
 383                 jint y = NEXT_INT(b);
 384                 jint w = NEXT_INT(b);
 385                 jint h = NEXT_INT(b);
 386                 MTLRenderer_DrawRect(mtlc, dstOps, x, y, w, h);
 387             }
 388             break;
 389         case sun_java2d_pipe_BufferedOpCodes_DRAW_POLY:
 390             {
<span class="line-added"> 391                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 392                 jint nPoints      = NEXT_INT(b);
 393                 jboolean isClosed = NEXT_BOOLEAN(b);
 394                 jint transX       = NEXT_INT(b);
 395                 jint transY       = NEXT_INT(b);
 396                 jint *xPoints = (jint *)b;
 397                 jint *yPoints = ((jint *)b) + nPoints;
 398                 MTLRenderer_DrawPoly(mtlc, dstOps, nPoints, isClosed, transX, transY, xPoints, yPoints);
 399                 SKIP_BYTES(b, nPoints * BYTES_PER_POLY_POINT);
 400             }
 401             break;
 402         case sun_java2d_pipe_BufferedOpCodes_DRAW_PIXEL:
 403             {
<span class="line-added"> 404                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 405                 jint x = NEXT_INT(b);
 406                 jint y = NEXT_INT(b);
 407                 CONTINUE_IF_NULL(mtlc);
 408                 //TODO
 409                 J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLRenderQueue_DRAW_PIXEL -- :TODO&quot;);
 410             }
 411             break;
 412         case sun_java2d_pipe_BufferedOpCodes_DRAW_SCANLINES:
 413             {
<span class="line-added"> 414                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 415                 jint count = NEXT_INT(b);
 416                 MTLRenderer_DrawScanlines(mtlc, dstOps, count, (jint *)b);
 417 
 418                 SKIP_BYTES(b, count * BYTES_PER_SCANLINE);
 419             }
 420             break;
 421         case sun_java2d_pipe_BufferedOpCodes_DRAW_PARALLELOGRAM:
 422             {
<span class="line-added"> 423                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 424                 jfloat x11 = NEXT_FLOAT(b);
 425                 jfloat y11 = NEXT_FLOAT(b);
 426                 jfloat dx21 = NEXT_FLOAT(b);
 427                 jfloat dy21 = NEXT_FLOAT(b);
 428                 jfloat dx12 = NEXT_FLOAT(b);
 429                 jfloat dy12 = NEXT_FLOAT(b);
 430                 jfloat lwr21 = NEXT_FLOAT(b);
 431                 jfloat lwr12 = NEXT_FLOAT(b);
 432 
 433                 MTLRenderer_DrawParallelogram(mtlc, dstOps,
 434                                               x11, y11,
 435                                               dx21, dy21,
 436                                               dx12, dy12,
 437                                               lwr21, lwr12);
 438             }
 439             break;
 440         case sun_java2d_pipe_BufferedOpCodes_DRAW_AAPARALLELOGRAM:
 441             {
<span class="line-added"> 442                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 443                 jfloat x11 = NEXT_FLOAT(b);
 444                 jfloat y11 = NEXT_FLOAT(b);
 445                 jfloat dx21 = NEXT_FLOAT(b);
 446                 jfloat dy21 = NEXT_FLOAT(b);
 447                 jfloat dx12 = NEXT_FLOAT(b);
 448                 jfloat dy12 = NEXT_FLOAT(b);
 449                 jfloat lwr21 = NEXT_FLOAT(b);
 450                 jfloat lwr12 = NEXT_FLOAT(b);
 451 
 452                 MTLRenderer_DrawAAParallelogram(mtlc, dstOps,
 453                                                 x11, y11,
 454                                                 dx21, dy21,
 455                                                 dx12, dy12,
 456                                                 lwr21, lwr12);
 457             }
 458             break;
 459 
 460         // fill ops
 461         case sun_java2d_pipe_BufferedOpCodes_FILL_RECT:
 462             {
<span class="line-added"> 463                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 464                 jint x = NEXT_INT(b);
 465                 jint y = NEXT_INT(b);
 466                 jint w = NEXT_INT(b);
 467                 jint h = NEXT_INT(b);
 468                 MTLRenderer_FillRect(mtlc, dstOps, x, y, w, h);
 469             }
 470             break;
 471         case sun_java2d_pipe_BufferedOpCodes_FILL_SPANS:
 472             {
<span class="line-added"> 473                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 474                 jint count = NEXT_INT(b);
 475                 MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);
 476                 SKIP_BYTES(b, count * BYTES_PER_SPAN);
 477             }
 478             break;
 479         case sun_java2d_pipe_BufferedOpCodes_FILL_PARALLELOGRAM:
 480             {
<span class="line-added"> 481                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 482                 jfloat x11 = NEXT_FLOAT(b);
 483                 jfloat y11 = NEXT_FLOAT(b);
 484                 jfloat dx21 = NEXT_FLOAT(b);
 485                 jfloat dy21 = NEXT_FLOAT(b);
 486                 jfloat dx12 = NEXT_FLOAT(b);
 487                 jfloat dy12 = NEXT_FLOAT(b);
 488                 MTLRenderer_FillParallelogram(mtlc, dstOps,
 489                                               x11, y11,
 490                                               dx21, dy21,
 491                                               dx12, dy12);
 492             }
 493             break;
 494         case sun_java2d_pipe_BufferedOpCodes_FILL_AAPARALLELOGRAM:
 495             {
<span class="line-added"> 496                 CHECK_PREVIOUS_OP(MTL_OP_AA);</span>
 497                 jfloat x11 = NEXT_FLOAT(b);
 498                 jfloat y11 = NEXT_FLOAT(b);
 499                 jfloat dx21 = NEXT_FLOAT(b);
 500                 jfloat dy21 = NEXT_FLOAT(b);
 501                 jfloat dx12 = NEXT_FLOAT(b);
 502                 jfloat dy12 = NEXT_FLOAT(b);
 503                 MTLRenderer_FillAAParallelogram(mtlc, dstOps,
 504                                                 x11, y11,
 505                                                 dx21, dy21,
 506                                                 dx12, dy12);
 507             }
 508             break;
 509 
 510         // text-related ops
 511         case sun_java2d_pipe_BufferedOpCodes_DRAW_GLYPH_LIST:
 512             {
<span class="line-added"> 513                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 514                 jint numGlyphs        = NEXT_INT(b);
 515                 jint packedParams     = NEXT_INT(b);
 516                 jfloat glyphListOrigX = NEXT_FLOAT(b);
 517                 jfloat glyphListOrigY = NEXT_FLOAT(b);
 518                 jboolean usePositions = EXTRACT_BOOLEAN(packedParams,
 519                                                         OFFSET_POSITIONS);
 520                 jboolean subPixPos    = EXTRACT_BOOLEAN(packedParams,
 521                                                         OFFSET_SUBPIXPOS);
 522                 jboolean rgbOrder     = EXTRACT_BOOLEAN(packedParams,
 523                                                         OFFSET_RGBORDER);
 524                 jint lcdContrast      = EXTRACT_BYTE(packedParams,
 525                                                      OFFSET_CONTRAST);
 526                 unsigned char *images = b;
 527                 unsigned char *positions;
 528                 jint bytesPerGlyph;
 529                 if (usePositions) {
 530                     positions = (b + numGlyphs * BYTES_PER_GLYPH_IMAGE);
 531                     bytesPerGlyph = BYTES_PER_POSITIONED_GLYPH;
 532                 } else {
 533                     positions = NULL;
 534                     bytesPerGlyph = BYTES_PER_GLYPH_IMAGE;
 535                 }
 536                 MTLTR_DrawGlyphList(env, mtlc, dstOps,
 537                                     numGlyphs, usePositions,
 538                                     subPixPos, rgbOrder, lcdContrast,
 539                                     glyphListOrigX, glyphListOrigY,
 540                                     images, positions);
 541                 SKIP_BYTES(b, numGlyphs * bytesPerGlyph);
 542             }
 543             break;
 544 
 545         // copy-related ops
 546         case sun_java2d_pipe_BufferedOpCodes_COPY_AREA:
 547             {
<span class="line-added"> 548                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 549                 jint x  = NEXT_INT(b);
 550                 jint y  = NEXT_INT(b);
 551                 jint w  = NEXT_INT(b);
 552                 jint h  = NEXT_INT(b);
 553                 jint dx = NEXT_INT(b);
 554                 jint dy = NEXT_INT(b);
 555                 MTLBlitLoops_CopyArea(env, mtlc, dstOps,
 556                                       x, y, w, h, dx, dy);
 557             }
 558             break;
 559         case sun_java2d_pipe_BufferedOpCodes_BLIT:
 560             {
<span class="line-added"> 561                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 562                 jint packedParams = NEXT_INT(b);
 563                 jint sx1          = NEXT_INT(b);
 564                 jint sy1          = NEXT_INT(b);
 565                 jint sx2          = NEXT_INT(b);
 566                 jint sy2          = NEXT_INT(b);
 567                 jdouble dx1       = NEXT_DOUBLE(b);
 568                 jdouble dy1       = NEXT_DOUBLE(b);
 569                 jdouble dx2       = NEXT_DOUBLE(b);
 570                 jdouble dy2       = NEXT_DOUBLE(b);
 571                 jlong pSrc        = NEXT_LONG(b);
 572                 jlong pDst        = NEXT_LONG(b);
 573                 jint hint         = EXTRACT_BYTE(packedParams, OFFSET_HINT);
 574                 jboolean texture  = EXTRACT_BOOLEAN(packedParams,
 575                                                     OFFSET_TEXTURE);
 576                 jboolean xform    = EXTRACT_BOOLEAN(packedParams,
 577                                                     OFFSET_XFORM);
 578                 jboolean isoblit  = EXTRACT_BOOLEAN(packedParams,
 579                                                     OFFSET_ISOBLIT);
 580                 if (isoblit) {
 581                     MTLBlitLoops_IsoBlit(env, mtlc, pSrc, pDst,
 582                                          xform, hint, texture,
 583                                          sx1, sy1, sx2, sy2,
 584                                          dx1, dy1, dx2, dy2);
 585                 } else {
 586                     jint srctype = EXTRACT_BYTE(packedParams, OFFSET_SRCTYPE);
 587                     MTLBlitLoops_Blit(env, mtlc, pSrc, pDst,
 588                                       xform, hint, srctype, texture,
 589                                       sx1, sy1, sx2, sy2,
 590                                       dx1, dy1, dx2, dy2);
 591                 }
 592             }
 593             break;
 594         case sun_java2d_pipe_BufferedOpCodes_SURFACE_TO_SW_BLIT:
 595             {
<span class="line-modified"> 596                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 597                 jint sx      = NEXT_INT(b);
 598                 jint sy      = NEXT_INT(b);
 599                 jint dx      = NEXT_INT(b);
 600                 jint dy      = NEXT_INT(b);
 601                 jint w       = NEXT_INT(b);
 602                 jint h       = NEXT_INT(b);
 603                 jint dsttype = NEXT_INT(b);
 604                 jlong pSrc   = NEXT_LONG(b);
 605                 jlong pDst   = NEXT_LONG(b);
 606                 MTLBlitLoops_SurfaceToSwBlit(env, mtlc,
 607                                              pSrc, pDst, dsttype,
 608                                              sx, sy, dx, dy, w, h);
 609             }
 610             break;
 611         case sun_java2d_pipe_BufferedOpCodes_MASK_FILL:
 612             {
<span class="line-modified"> 613                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 614                 jint x        = NEXT_INT(b);
 615                 jint y        = NEXT_INT(b);
 616                 jint w        = NEXT_INT(b);
 617                 jint h        = NEXT_INT(b);
 618                 jint maskoff  = NEXT_INT(b);
 619                 jint maskscan = NEXT_INT(b);
 620                 jint masklen  = NEXT_INT(b);
 621                 unsigned char *pMask = (masklen &gt; 0) ? b : NULL;
 622                 MTLMaskFill_MaskFill(mtlc, dstOps, x, y, w, h,
 623                                      maskoff, maskscan, masklen, pMask);
 624                 SKIP_BYTES(b, masklen);
 625             }
 626             break;
 627         case sun_java2d_pipe_BufferedOpCodes_MASK_BLIT:
 628             {
<span class="line-modified"> 629                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 630                 jint dstx     = NEXT_INT(b);
 631                 jint dsty     = NEXT_INT(b);
 632                 jint width    = NEXT_INT(b);
 633                 jint height   = NEXT_INT(b);
 634                 jint masklen  = width * height * sizeof(jint);
 635                 MTLMaskBlit_MaskBlit(env, mtlc, dstOps,
 636                                      dstx, dsty, width, height, b);
 637                 SKIP_BYTES(b, masklen);
 638             }
 639             break;
 640 
 641         // state-related ops
 642         case sun_java2d_pipe_BufferedOpCodes_SET_RECT_CLIP:
 643             {
<span class="line-added"> 644                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 645                 jint x1 = NEXT_INT(b);
 646                 jint y1 = NEXT_INT(b);
 647                 jint x2 = NEXT_INT(b);
 648                 jint y2 = NEXT_INT(b);
 649                 [mtlc setClipRectX1:x1 Y1:y1 X2:x2 Y2:y2];
 650             }
 651             break;
 652         case sun_java2d_pipe_BufferedOpCodes_BEGIN_SHAPE_CLIP:
 653             {
<span class="line-added"> 654                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 655                 [mtlc beginShapeClip:dstOps];
 656             }
 657             break;
 658         case sun_java2d_pipe_BufferedOpCodes_SET_SHAPE_CLIP_SPANS:
 659             {
<span class="line-added"> 660                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 661                 // This results in creation of new render encoder with
 662                 // stencil buffer set as render target
 663                 jint count = NEXT_INT(b);
 664                 MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);
 665                 SKIP_BYTES(b, count * BYTES_PER_SPAN);
 666             }
 667             break;
 668         case sun_java2d_pipe_BufferedOpCodes_END_SHAPE_CLIP:
 669             {
<span class="line-added"> 670                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 671                 [mtlc endShapeClip:dstOps];
 672             }
 673             break;
 674         case sun_java2d_pipe_BufferedOpCodes_RESET_CLIP:
 675             {
<span class="line-added"> 676                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 677                 [mtlc resetClip];
 678             }
 679             break;
 680         case sun_java2d_pipe_BufferedOpCodes_SET_ALPHA_COMPOSITE:
 681             {
<span class="line-added"> 682                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 683                 jint rule         = NEXT_INT(b);
 684                 jfloat extraAlpha = NEXT_FLOAT(b);
 685                 jint flags        = NEXT_INT(b);
 686                 [mtlc setAlphaCompositeRule:rule extraAlpha:extraAlpha flags:flags];
 687             }
 688             break;
 689         case sun_java2d_pipe_BufferedOpCodes_SET_XOR_COMPOSITE:
 690             {
<span class="line-added"> 691                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 692                 jint xorPixel = NEXT_INT(b);
 693                 [mtlc setXorComposite:xorPixel];
 694             }
 695             break;
 696         case sun_java2d_pipe_BufferedOpCodes_RESET_COMPOSITE:
 697             {
<span class="line-added"> 698                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 699                 [mtlc resetComposite];
 700             }
 701             break;
 702         case sun_java2d_pipe_BufferedOpCodes_SET_TRANSFORM:
 703             {
<span class="line-added"> 704                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 705                 jdouble m00 = NEXT_DOUBLE(b);
 706                 jdouble m10 = NEXT_DOUBLE(b);
 707                 jdouble m01 = NEXT_DOUBLE(b);
 708                 jdouble m11 = NEXT_DOUBLE(b);
 709                 jdouble m02 = NEXT_DOUBLE(b);
 710                 jdouble m12 = NEXT_DOUBLE(b);
 711                 [mtlc setTransformM00:m00 M10:m10 M01:m01 M11:m11 M02:m02 M12:m12];
 712             }
 713             break;
 714         case sun_java2d_pipe_BufferedOpCodes_RESET_TRANSFORM:
 715             {
<span class="line-added"> 716                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 717                 [mtlc resetTransform];
 718             }
 719             break;
 720 
 721         // context-related ops
 722         case sun_java2d_pipe_BufferedOpCodes_SET_SURFACES:
 723             {
<span class="line-modified"> 724                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 725                 jlong pSrc = NEXT_LONG(b);
 726                 jlong pDst = NEXT_LONG(b);
 727 
 728                 dstOps = (BMTLSDOps *)jlong_to_ptr(pDst);
 729                 mtlc = [MTLContext setSurfacesEnv:env src:pSrc dst:pDst];
 730             }
 731             break;
 732         case sun_java2d_pipe_BufferedOpCodes_SET_SCRATCH_SURFACE:
 733             {
<span class="line-added"> 734                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 735                 jlong pConfigInfo = NEXT_LONG(b);
 736                 MTLGraphicsConfigInfo *mtlInfo =
 737                         (MTLGraphicsConfigInfo *)jlong_to_ptr(pConfigInfo);
 738 
 739                 if (mtlInfo == NULL) {
 740 
 741                 } else {
 742                     MTLContext *newMtlc = mtlInfo-&gt;context;
 743                     if (newMtlc == NULL) {
 744 
 745                     } else {
 746                         mtlc = newMtlc;
 747                         dstOps = NULL;
 748                     }
 749                 }
 750             }
 751             break;
 752         case sun_java2d_pipe_BufferedOpCodes_FLUSH_SURFACE:
 753             {
<span class="line-added"> 754                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 755                 jlong pData = NEXT_LONG(b);
 756                 BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);
 757                 if (mtlsdo != NULL) {
 758                     CONTINUE_IF_NULL(mtlc);
 759                     MTLSD_Delete(env, mtlsdo);
 760                 }
 761             }
 762             break;
 763         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_SURFACE:
 764             {
<span class="line-added"> 765                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 766                 jlong pData = NEXT_LONG(b);
 767                 BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);
 768                 if (mtlsdo != NULL) {
 769                     CONTINUE_IF_NULL(mtlc);
 770                     MTLSD_Delete(env, mtlsdo);
 771                     if (mtlsdo-&gt;privOps != NULL) {
 772                         free(mtlsdo-&gt;privOps);
 773                     }
 774                 }
 775             }
 776             break;
 777         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_CONFIG:
 778             {
<span class="line-added"> 779                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 780                 jlong pConfigInfo = NEXT_LONG(b);
 781                 CONTINUE_IF_NULL(mtlc);
 782                 MTLGC_DestroyMTLGraphicsConfig(pConfigInfo);
 783 
 784                 // the previous method will call glX/wglMakeCurrent(None),
 785                 // so we should nullify the current mtlc and dstOps to avoid
 786                 // calling glFlush() (or similar) while no context is current
 787                 mtlc = NULL;
 788              //   dstOps = NULL;
 789             }
 790             break;
 791         case sun_java2d_pipe_BufferedOpCodes_INVALIDATE_CONTEXT:
 792             {
<span class="line-added"> 793                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 794                 // invalidate the references to the current context and
 795                 // destination surface that are maintained at the native level
 796                 mtlc = NULL;
 797             //    dstOps = NULL;
 798             }
 799             break;
 800         case sun_java2d_pipe_BufferedOpCodes_SYNC:
 801             {
<span class="line-added"> 802                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 803                 sync = JNI_TRUE;
 804 
 805                 // TODO
 806                 J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLRenderQueue_SYNC -- :TODO&quot;);
 807 
 808             }
 809             break;
 810 
 811         // multibuffering ops
 812         case sun_java2d_pipe_BufferedOpCodes_SWAP_BUFFERS:
 813             {
<span class="line-added"> 814                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 815                 jlong window = NEXT_LONG(b);
 816                 MTLSD_SwapBuffers(env, window);
 817             }
 818             break;
 819 
 820         // special no-op (mainly used for achieving 8-byte alignment)
 821         case sun_java2d_pipe_BufferedOpCodes_NOOP:
 822             break;
 823 
 824         // paint-related ops
 825         case sun_java2d_pipe_BufferedOpCodes_RESET_PAINT:
 826             {
<span class="line-modified"> 827               CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
<span class="line-added"> 828               [mtlc resetPaint];</span>
 829             }
 830             break;
 831         case sun_java2d_pipe_BufferedOpCodes_SET_COLOR:
 832             {
<span class="line-added"> 833                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 834                 jint pixel = NEXT_INT(b);
 835                 [mtlc setColorPaint:pixel];
 836             }
 837             break;
 838         case sun_java2d_pipe_BufferedOpCodes_SET_GRADIENT_PAINT:
 839             {
<span class="line-added"> 840                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 841                 jboolean useMask= NEXT_BOOLEAN(b);
 842                 jboolean cyclic = NEXT_BOOLEAN(b);
 843                 jdouble p0      = NEXT_DOUBLE(b);
 844                 jdouble p1      = NEXT_DOUBLE(b);
 845                 jdouble p3      = NEXT_DOUBLE(b);
 846                 jint pixel1     = NEXT_INT(b);
 847                 jint pixel2     = NEXT_INT(b);
 848                 [mtlc setGradientPaintUseMask:useMask
 849                                     cyclic:cyclic
 850                                         p0:p0
 851                                         p1:p1
 852                                         p3:p3
 853                                     pixel1:pixel1
 854                                     pixel2:pixel2];
 855             }
 856             break;
 857         case sun_java2d_pipe_BufferedOpCodes_SET_LINEAR_GRADIENT_PAINT:
 858             {
<span class="line-added"> 859                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 860                 jboolean useMask = NEXT_BOOLEAN(b);
 861                 jboolean linear  = NEXT_BOOLEAN(b);
 862                 jint cycleMethod = NEXT_INT(b);
 863                 jint numStops    = NEXT_INT(b);
 864                 jfloat p0        = NEXT_FLOAT(b);
 865                 jfloat p1        = NEXT_FLOAT(b);
 866                 jfloat p3        = NEXT_FLOAT(b);
 867                 void *fractions, *pixels;
 868                 fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));
 869                 pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));
 870                 [mtlc setLinearGradientPaint:useMask
 871                                       linear:linear
 872                                  cycleMethod:cycleMethod
 873                                     numStops:numStops
 874                                           p0:p0
 875                                           p1:p1
 876                                           p3:p3
 877                                    fractions:fractions
 878                                       pixels:pixels];
 879             }
 880             break;
 881         case sun_java2d_pipe_BufferedOpCodes_SET_RADIAL_GRADIENT_PAINT:
 882             {
<span class="line-added"> 883                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 884                 jboolean useMask = NEXT_BOOLEAN(b);
 885                 jboolean linear  = NEXT_BOOLEAN(b);
 886                 jint numStops    = NEXT_INT(b);
 887                 jint cycleMethod = NEXT_INT(b);
 888                 jfloat m00       = NEXT_FLOAT(b);
 889                 jfloat m01       = NEXT_FLOAT(b);
 890                 jfloat m02       = NEXT_FLOAT(b);
 891                 jfloat m10       = NEXT_FLOAT(b);
 892                 jfloat m11       = NEXT_FLOAT(b);
 893                 jfloat m12       = NEXT_FLOAT(b);
 894                 jfloat focusX    = NEXT_FLOAT(b);
 895                 void *fractions, *pixels;
 896                 fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));
 897                 pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));
 898                 [mtlc setRadialGradientPaint:useMask
 899                                       linear:linear
 900                                  cycleMethod:cycleMethod
 901                                     numStops:numStops
 902                                          m00:m00
 903                                          m01:m01
 904                                          m02:m02
 905                                          m10:m10
 906                                          m11:m11
 907                                          m12:m12
 908                                       focusX:focusX
 909                                    fractions:fractions
 910                                       pixels:pixels];
 911             }
 912             break;
 913         case sun_java2d_pipe_BufferedOpCodes_SET_TEXTURE_PAINT:
 914             {
<span class="line-added"> 915                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 916                 jboolean useMask= NEXT_BOOLEAN(b);
 917                 jboolean filter = NEXT_BOOLEAN(b);
 918                 jlong pSrc      = NEXT_LONG(b);
 919                 jdouble xp0     = NEXT_DOUBLE(b);
 920                 jdouble xp1     = NEXT_DOUBLE(b);
 921                 jdouble xp3     = NEXT_DOUBLE(b);
 922                 jdouble yp0     = NEXT_DOUBLE(b);
 923                 jdouble yp1     = NEXT_DOUBLE(b);
 924                 jdouble yp3     = NEXT_DOUBLE(b);
 925                 [mtlc setTexturePaint:useMask
 926                               pSrcOps:pSrc
 927                                filter:filter
 928                                   xp0:xp0
 929                                   xp1:xp1
 930                                   xp3:xp3
 931                                   yp0:yp0
 932                                   yp1:yp1
 933                                   yp3:yp3];
 934             }
 935             break;
 936 
 937         // BufferedImageOp-related ops
 938         case sun_java2d_pipe_BufferedOpCodes_ENABLE_CONVOLVE_OP:
 939             {
<span class="line-added"> 940                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 941                 jlong pSrc        = NEXT_LONG(b);
 942                 jboolean edgeZero = NEXT_BOOLEAN(b);
 943                 jint kernelWidth  = NEXT_INT(b);
 944                 jint kernelHeight = NEXT_INT(b);
 945                 MTLBufImgOps_EnableConvolveOp(mtlc, pSrc, edgeZero,
 946                                               kernelWidth, kernelHeight, b);
 947                 SKIP_BYTES(b, kernelWidth * kernelHeight * sizeof(jfloat));
 948             }
 949             break;
 950         case sun_java2d_pipe_BufferedOpCodes_DISABLE_CONVOLVE_OP:
 951             {
<span class="line-added"> 952                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 953                 MTLBufImgOps_DisableConvolveOp(mtlc);
 954             }
 955             break;
 956         case sun_java2d_pipe_BufferedOpCodes_ENABLE_RESCALE_OP:
 957             {
<span class="line-added"> 958                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 959                 jlong pSrc          = NEXT_LONG(b);
 960                 jboolean nonPremult = NEXT_BOOLEAN(b);
 961                 jint numFactors     = 4;
 962                 unsigned char *scaleFactors = b;
 963                 unsigned char *offsets = (b + numFactors * sizeof(jfloat));
 964                 MTLBufImgOps_EnableRescaleOp(mtlc, pSrc, nonPremult,
 965                                              scaleFactors, offsets);
 966                 SKIP_BYTES(b, numFactors * sizeof(jfloat) * 2);
 967             }
 968             break;
 969         case sun_java2d_pipe_BufferedOpCodes_DISABLE_RESCALE_OP:
 970             {
<span class="line-added"> 971                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 972                 MTLBufImgOps_DisableRescaleOp(mtlc);
 973             }
 974             break;
 975         case sun_java2d_pipe_BufferedOpCodes_ENABLE_LOOKUP_OP:
 976             {
<span class="line-added"> 977                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 978                 jlong pSrc          = NEXT_LONG(b);
 979                 jboolean nonPremult = NEXT_BOOLEAN(b);
 980                 jboolean shortData  = NEXT_BOOLEAN(b);
 981                 jint numBands       = NEXT_INT(b);
 982                 jint bandLength     = NEXT_INT(b);
 983                 jint offset         = NEXT_INT(b);
 984                 jint bytesPerElem = shortData ? sizeof(jshort):sizeof(jbyte);
 985                 void *tableValues = b;
 986                 MTLBufImgOps_EnableLookupOp(mtlc, pSrc, nonPremult, shortData,
 987                                             numBands, bandLength, offset,
 988                                             tableValues);
 989                 SKIP_BYTES(b, numBands * bandLength * bytesPerElem);
 990             }
 991             break;
 992         case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:
 993             {
<span class="line-added"> 994                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 995                 MTLBufImgOps_DisableLookupOp(mtlc);
 996             }
 997             break;
 998 
 999         default:
1000             J2dRlsTraceLn1(J2D_TRACE_ERROR,
1001                 &quot;MTLRenderQueue_flushBuffer: invalid opcode=%d&quot;, opcode);
1002             return;
1003         }
1004     }
1005 
<span class="line-added">1006     CHECK_PREVIOUS_OP(MTL_OP_INIT);</span>
1007     if (mtlc != NULL) {
1008         [mtlc.encoderManager endEncoder];
1009         MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];
1010         id&lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
1011         [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
1012             [cbwrapper release];
1013         }];
1014         [commandbuf commit];
1015         if (sync) {
1016             [commandbuf waitUntilCompleted];
1017         }
1018         BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
1019         if (dstOps != NULL) {
1020             MTLSDOps *dstMTLOps = (MTLSDOps *)dstOps-&gt;privOps;
1021             MTLLayer *layer = (MTLLayer*)dstMTLOps-&gt;layer;
1022             if (layer != NULL) {
1023                 [JNFRunLoop performOnMainThreadWaiting:NO withBlock:^(){
1024                     AWT_ASSERT_APPKIT_THREAD;
1025                     [layer setNeedsDisplay];
1026                 }];
</pre>
</td>
</tr>
</table>
<center><a href="MTLRenderQueue.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MTLTransform.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBlitLoops.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="MTLContext.m.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBlitLoops.m</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 24  */
 25 
 26 #ifndef HEADLESS
 27 
 28 #include &lt;jni.h&gt;
 29 #include &lt;jlong.h&gt;
 30 
 31 #include &quot;SurfaceData.h&quot;
 32 #include &quot;MTLBlitLoops.h&quot;
 33 #include &quot;MTLRenderQueue.h&quot;
 34 #include &quot;MTLSurfaceData.h&quot;
 35 #include &quot;MTLUtils.h&quot;
 36 #include &quot;GraphicsPrimitiveMgr.h&quot;
 37 
 38 #include &lt;stdlib.h&gt; // malloc
 39 #include &lt;string.h&gt; // memcpy
 40 #include &quot;IntArgbPre.h&quot;
 41 
 42 #import &lt;Accelerate/Accelerate.h&gt;
 43 
<span class="line-modified"> 44 //#define TRACE_ISOBLIT</span>
<span class="line-modified"> 45 //#define TRACE_BLIT</span>


 46 //#define DEBUG_ISOBLIT
 47 //#define DEBUG_BLIT
 48 
 49 typedef struct {
 50     MTLPixelFormat   format;
 51     jboolean hasAlpha;
 52     jboolean isPremult;
 53     const uint8_t * permuteMap;
 54 } MTLRasterFormatInfo;
 55 
 56 // 0 denotes the alpha channel, 1 the red channel, 2 the green channel, and 3 the blue channel.
 57 const uint8_t permuteMap_rgbx[4] = { 1, 2, 3, 0 };
 58 const uint8_t permuteMap_bgrx[4] = { 3, 2, 1, 0 };
 59 
 60 static uint8_t revertPerm(const uint8_t * perm, uint8_t pos) {
 61     for (int c = 0; c &lt; 4; ++c) {
 62         if (perm[c] == pos)
 63             return c;
 64     }
 65     return -1;
</pre>
<hr />
<pre>
330         const int maxX = clipRect-&gt;x + clipRect-&gt;width;
331         if (dcx2 &gt; maxX)
332             dcx2 = maxX;
333         if (clipRect-&gt;y &gt; dcy1)
334             dcy1 = clipRect-&gt;y;
335         const int maxY = clipRect-&gt;y + clipRect-&gt;height;
336         if (dcy2 &gt; maxY)
337             dcy2 = maxY;
338 
339         if (dcx1 &gt;= dcx2) {
340             J2dTraceLn2(J2D_TRACE_ERROR, &quot;\tclipDestCoords: dcx1=%1.2f, dcx2=%1.2f&quot;, dcx1, dcx2);
341             dcx1 = dcx2;
342         }
343         if (dcy1 &gt;= dcy2) {
344             J2dTraceLn2(J2D_TRACE_ERROR, &quot;\tclipDestCoords: dcy1=%1.2f, dcy2=%1.2f&quot;, dcy1, dcy2);
345             dcy1 = dcy2;
346         }
347     }
348     if (*dx2 &lt;= dcx1 || *dx1 &gt;= dcx2 || *dy2 &lt;= dcy1 || *dy1 &gt;= dcy2) {
349         J2dTraceLn(J2D_TRACE_INFO, &quot;\tclipDestCoords: dest rect doesn&#39;t intersect clip area&quot;);


350         return JNI_FALSE;
351     }
352     if (*dx1 &lt; dcx1) {
353         J2dTraceLn2(J2D_TRACE_VERBOSE, &quot;\t\tdx1=%1.2f, will be clipped to %1.2f&quot;, *dx1, dcx1);
354         *sx1 += (jint)((dcx1 - *dx1) * (sw/dw));
355         *dx1 = dcx1;
356     }
357     if (*dx2 &gt; dcx2) {
358         J2dTraceLn2(J2D_TRACE_VERBOSE, &quot;\t\tdx2=%1.2f, will be clipped to %1.2f&quot;, *dx2, dcx2);
359         *sx2 -= (jint)((*dx2 - dcx2) * (sw/dw));
360         *dx2 = dcx2;
361     }
362     if (*dy1 &lt; dcy1) {
363         J2dTraceLn2(J2D_TRACE_VERBOSE, &quot;\t\tdy1=%1.2f, will be clipped to %1.2f&quot;, *dy1, dcy1);
364         *sy1 += (jint)((dcy1 - *dy1) * (sh/dh));
365         *dy1 = dcy1;
366     }
367     if (*dy2 &gt; dcy2) {
368         J2dTraceLn2(J2D_TRACE_VERBOSE, &quot;\t\tdy2=%1.2f, will be clipped to %1.2f&quot;, *dy2, dcy2);
369         *sy2 -= (jint)((*dy2 - dcy2) * (sh/dh));
</pre>
<hr />
<pre>
402     const jint sh    = sy2 - sy1;
403     const jdouble dw = dx2 - dx1;
404     const jdouble dh = dy2 - dy1;
405 
406     if (sw &lt;= 0 || sh &lt;= 0 || dw &lt;= 0 || dh &lt;= 0) {
407         J2dTraceLn4(J2D_TRACE_WARNING, &quot;MTLBlitLoops_IsoBlit: invalid dimensions: sw=%d, sh%d, dw=%d, dh=%d&quot;, sw, sh, dw, dh);
408         return;
409     }
410 
411 #ifdef DEBUG_ISOBLIT
412     if ((xform == JNI_TRUE) != (mtlc.useTransform == JNI_TRUE)) {
413         J2dTraceImpl(J2D_TRACE_ERROR, JNI_TRUE,
414                 &quot;MTLBlitLoops_IsoBlit state error: xform=%d, mtlc.useTransform=%d, texture=%d&quot;,
415                 xform, mtlc.useTransform, texture);
416     }
417 #endif // DEBUG_ISOBLIT
418 
419     clipDestCoords(
420             &amp;dx1, &amp;dy1, &amp;dx2, &amp;dy2,
421             &amp;sx1, &amp;sy1, &amp;sx2, &amp;sy2,
<span class="line-modified">422             dstTex.width, dstTex.height, [mtlc.clip getRect]</span>
423     );
424 
425     SurfaceDataBounds bounds;
426     bounds.x1 = sx1;
427     bounds.y1 = sy1;
428     bounds.x2 = sx2;
429     bounds.y2 = sy2;
430     SurfaceData_IntersectBoundsXYXY(&amp;bounds, 0, 0, srcOps-&gt;width, srcOps-&gt;height);
431 
432     if (bounds.x2 &lt;= bounds.x1 || bounds.y2 &lt;= bounds.y1) {
433         J2dTraceLn(J2D_TRACE_VERBOSE, &quot;MTLBlitLoops_IsoBlit: source rectangle doesn&#39;t intersect with source surface bounds&quot;);
434         J2dTraceLn6(J2D_TRACE_VERBOSE, &quot;  sx1=%d sy1=%d sx2=%d sy2=%d sw=%d sh=%d&quot;, sx1, sy1, sx2, sy2, srcOps-&gt;width, srcOps-&gt;height);
435         J2dTraceLn4(J2D_TRACE_VERBOSE, &quot;  dx1=%f dy1=%f dx2=%f dy2=%f&quot;, dx1, dy1, dx2, dy2);
436         return;
437     }
438 
439     if (bounds.x1 != sx1) {
440         dx1 += (bounds.x1 - sx1) * (dw / sw);
441         sx1 = bounds.x1;
442     }
</pre>
</td>
<td>
<hr />
<pre>
 24  */
 25 
 26 #ifndef HEADLESS
 27 
 28 #include &lt;jni.h&gt;
 29 #include &lt;jlong.h&gt;
 30 
 31 #include &quot;SurfaceData.h&quot;
 32 #include &quot;MTLBlitLoops.h&quot;
 33 #include &quot;MTLRenderQueue.h&quot;
 34 #include &quot;MTLSurfaceData.h&quot;
 35 #include &quot;MTLUtils.h&quot;
 36 #include &quot;GraphicsPrimitiveMgr.h&quot;
 37 
 38 #include &lt;stdlib.h&gt; // malloc
 39 #include &lt;string.h&gt; // memcpy
 40 #include &quot;IntArgbPre.h&quot;
 41 
 42 #import &lt;Accelerate/Accelerate.h&gt;
 43 
<span class="line-modified"> 44 #ifdef DEBUG</span>
<span class="line-modified"> 45 #define TRACE_ISOBLIT</span>
<span class="line-added"> 46 #define TRACE_BLIT</span>
<span class="line-added"> 47 #endif //DEBUG</span>
 48 //#define DEBUG_ISOBLIT
 49 //#define DEBUG_BLIT
 50 
 51 typedef struct {
 52     MTLPixelFormat   format;
 53     jboolean hasAlpha;
 54     jboolean isPremult;
 55     const uint8_t * permuteMap;
 56 } MTLRasterFormatInfo;
 57 
 58 // 0 denotes the alpha channel, 1 the red channel, 2 the green channel, and 3 the blue channel.
 59 const uint8_t permuteMap_rgbx[4] = { 1, 2, 3, 0 };
 60 const uint8_t permuteMap_bgrx[4] = { 3, 2, 1, 0 };
 61 
 62 static uint8_t revertPerm(const uint8_t * perm, uint8_t pos) {
 63     for (int c = 0; c &lt; 4; ++c) {
 64         if (perm[c] == pos)
 65             return c;
 66     }
 67     return -1;
</pre>
<hr />
<pre>
332         const int maxX = clipRect-&gt;x + clipRect-&gt;width;
333         if (dcx2 &gt; maxX)
334             dcx2 = maxX;
335         if (clipRect-&gt;y &gt; dcy1)
336             dcy1 = clipRect-&gt;y;
337         const int maxY = clipRect-&gt;y + clipRect-&gt;height;
338         if (dcy2 &gt; maxY)
339             dcy2 = maxY;
340 
341         if (dcx1 &gt;= dcx2) {
342             J2dTraceLn2(J2D_TRACE_ERROR, &quot;\tclipDestCoords: dcx1=%1.2f, dcx2=%1.2f&quot;, dcx1, dcx2);
343             dcx1 = dcx2;
344         }
345         if (dcy1 &gt;= dcy2) {
346             J2dTraceLn2(J2D_TRACE_ERROR, &quot;\tclipDestCoords: dcy1=%1.2f, dcy2=%1.2f&quot;, dcy1, dcy2);
347             dcy1 = dcy2;
348         }
349     }
350     if (*dx2 &lt;= dcx1 || *dx1 &gt;= dcx2 || *dy2 &lt;= dcy1 || *dy1 &gt;= dcy2) {
351         J2dTraceLn(J2D_TRACE_INFO, &quot;\tclipDestCoords: dest rect doesn&#39;t intersect clip area&quot;);
<span class="line-added">352         J2dTraceLn4(J2D_TRACE_INFO, &quot;\tdx2=%1.4f &lt;= dcx1=%1.4f || *dx1=%1.4f &gt;= dcx2=%1.4f&quot;, *dx2, dcx1, *dx1, dcx2);</span>
<span class="line-added">353         J2dTraceLn4(J2D_TRACE_INFO, &quot;\t*dy2=%1.4f &lt;= dcy1=%1.4f || *dy1=%1.4f &gt;= dcy2=%1.4f&quot;, *dy2, dcy1, *dy1, dcy2);</span>
354         return JNI_FALSE;
355     }
356     if (*dx1 &lt; dcx1) {
357         J2dTraceLn2(J2D_TRACE_VERBOSE, &quot;\t\tdx1=%1.2f, will be clipped to %1.2f&quot;, *dx1, dcx1);
358         *sx1 += (jint)((dcx1 - *dx1) * (sw/dw));
359         *dx1 = dcx1;
360     }
361     if (*dx2 &gt; dcx2) {
362         J2dTraceLn2(J2D_TRACE_VERBOSE, &quot;\t\tdx2=%1.2f, will be clipped to %1.2f&quot;, *dx2, dcx2);
363         *sx2 -= (jint)((*dx2 - dcx2) * (sw/dw));
364         *dx2 = dcx2;
365     }
366     if (*dy1 &lt; dcy1) {
367         J2dTraceLn2(J2D_TRACE_VERBOSE, &quot;\t\tdy1=%1.2f, will be clipped to %1.2f&quot;, *dy1, dcy1);
368         *sy1 += (jint)((dcy1 - *dy1) * (sh/dh));
369         *dy1 = dcy1;
370     }
371     if (*dy2 &gt; dcy2) {
372         J2dTraceLn2(J2D_TRACE_VERBOSE, &quot;\t\tdy2=%1.2f, will be clipped to %1.2f&quot;, *dy2, dcy2);
373         *sy2 -= (jint)((*dy2 - dcy2) * (sh/dh));
</pre>
<hr />
<pre>
406     const jint sh    = sy2 - sy1;
407     const jdouble dw = dx2 - dx1;
408     const jdouble dh = dy2 - dy1;
409 
410     if (sw &lt;= 0 || sh &lt;= 0 || dw &lt;= 0 || dh &lt;= 0) {
411         J2dTraceLn4(J2D_TRACE_WARNING, &quot;MTLBlitLoops_IsoBlit: invalid dimensions: sw=%d, sh%d, dw=%d, dh=%d&quot;, sw, sh, dw, dh);
412         return;
413     }
414 
415 #ifdef DEBUG_ISOBLIT
416     if ((xform == JNI_TRUE) != (mtlc.useTransform == JNI_TRUE)) {
417         J2dTraceImpl(J2D_TRACE_ERROR, JNI_TRUE,
418                 &quot;MTLBlitLoops_IsoBlit state error: xform=%d, mtlc.useTransform=%d, texture=%d&quot;,
419                 xform, mtlc.useTransform, texture);
420     }
421 #endif // DEBUG_ISOBLIT
422 
423     clipDestCoords(
424             &amp;dx1, &amp;dy1, &amp;dx2, &amp;dy2,
425             &amp;sx1, &amp;sy1, &amp;sx2, &amp;sy2,
<span class="line-modified">426             dstTex.width, dstTex.height, texture ? NULL : [mtlc.clip getRect]</span>
427     );
428 
429     SurfaceDataBounds bounds;
430     bounds.x1 = sx1;
431     bounds.y1 = sy1;
432     bounds.x2 = sx2;
433     bounds.y2 = sy2;
434     SurfaceData_IntersectBoundsXYXY(&amp;bounds, 0, 0, srcOps-&gt;width, srcOps-&gt;height);
435 
436     if (bounds.x2 &lt;= bounds.x1 || bounds.y2 &lt;= bounds.y1) {
437         J2dTraceLn(J2D_TRACE_VERBOSE, &quot;MTLBlitLoops_IsoBlit: source rectangle doesn&#39;t intersect with source surface bounds&quot;);
438         J2dTraceLn6(J2D_TRACE_VERBOSE, &quot;  sx1=%d sy1=%d sx2=%d sy2=%d sw=%d sh=%d&quot;, sx1, sy1, sx2, sy2, srcOps-&gt;width, srcOps-&gt;height);
439         J2dTraceLn4(J2D_TRACE_VERBOSE, &quot;  dx1=%f dy1=%f dx2=%f dy2=%f&quot;, dx1, dy1, dx2, dy2);
440         return;
441     }
442 
443     if (bounds.x1 != sx1) {
444         dx1 += (bounds.x1 - sx1) * (dw / sw);
445         sx1 = bounds.x1;
446     }
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="MTLContext.m.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBlitLoops.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef HEADLESS
 27 
 28 #include &lt;jni.h&gt;
 29 #include &lt;jlong.h&gt;
 30 
 31 #include &quot;SurfaceData.h&quot;
 32 #include &quot;MTLBlitLoops.h&quot;
 33 #include &quot;MTLRenderQueue.h&quot;
 34 #include &quot;MTLSurfaceData.h&quot;
 35 #include &quot;MTLUtils.h&quot;
 36 #include &quot;GraphicsPrimitiveMgr.h&quot;
 37 
 38 #include &lt;stdlib.h&gt; // malloc
 39 #include &lt;string.h&gt; // memcpy
 40 #include &quot;IntArgbPre.h&quot;
 41 
 42 #import &lt;Accelerate/Accelerate.h&gt;
 43 
 44 //#define TRACE_ISOBLIT
 45 //#define TRACE_BLIT
 46 //#define DEBUG_ISOBLIT
 47 //#define DEBUG_BLIT
 48 
 49 typedef struct {
 50     MTLPixelFormat   format;
 51     jboolean hasAlpha;
 52     jboolean isPremult;
 53     const uint8_t * permuteMap;
 54 } MTLRasterFormatInfo;
 55 
 56 // 0 denotes the alpha channel, 1 the red channel, 2 the green channel, and 3 the blue channel.
 57 const uint8_t permuteMap_rgbx[4] = { 1, 2, 3, 0 };
 58 const uint8_t permuteMap_bgrx[4] = { 3, 2, 1, 0 };
 59 
 60 static uint8_t revertPerm(const uint8_t * perm, uint8_t pos) {
 61     for (int c = 0; c &lt; 4; ++c) {
 62         if (perm[c] == pos)
 63             return c;
 64     }
 65     return -1;
 66 }
 67 
 68 #define uint2swizzle(channel) (channel == 0 ? MTLTextureSwizzleAlpha : (channel == 1 ? MTLTextureSwizzleRed : (channel == 2 ? MTLTextureSwizzleGreen : (channel == 3 ? MTLTextureSwizzleBlue : MTLTextureSwizzleZero))))
 69 
 70 /**
 71  * This table contains the &quot;pixel formats&quot; for all system memory surfaces
 72  * that Metal is capable of handling, indexed by the &quot;PF_&quot; constants defined
 73  * in MTLLSurfaceData.java.  These pixel formats contain information that is
 74  * passed to Metal when copying from a system memory (&quot;Sw&quot;) surface to
 75  * an Metal surface
 76  */
 77 MTLRasterFormatInfo RasterFormatInfos[] = {
 78         { MTLPixelFormatBGRA8Unorm, 1, 0, NULL }, /* 0 - IntArgb      */ // Argb (in java notation)
 79         { MTLPixelFormatBGRA8Unorm, 1, 1, NULL }, /* 1 - IntArgbPre   */
 80         { MTLPixelFormatBGRA8Unorm, 0, 1, NULL }, /* 2 - IntRgb       */ // xrgb
 81         { MTLPixelFormatBGRA8Unorm, 0, 1, permuteMap_rgbx }, /* 3 - IntRgbx      */
 82         { MTLPixelFormatRGBA8Unorm, 0, 1, NULL }, /* 4 - IntBgr       */ // xbgr
 83         { MTLPixelFormatBGRA8Unorm, 0, 1, permuteMap_bgrx }, /* 5 - IntBgrx      */
 84 
 85 //        TODO: support 2-byte formats
 86 //        { GL_BGRA, GL_UNSIGNED_SHORT_1_5_5_5_REV,
 87 //                2, 0, 1,                                     }, /* 7 - Ushort555Rgb */
 88 //        { GL_RGBA, GL_UNSIGNED_SHORT_5_5_5_1,
 89 //                2, 0, 1,                                     }, /* 8 - Ushort555Rgbx*/
 90 //        { GL_LUMINANCE, GL_UNSIGNED_BYTE,
 91 //                1, 0, 1,                                     }, /* 9 - ByteGray     */
 92 //        { GL_LUMINANCE, GL_UNSIGNED_SHORT,
 93 //                2, 0, 1,                                     }, /*10 - UshortGray   */
 94 //        { GL_BGR,  GL_UNSIGNED_BYTE,
 95 //                1, 0, 1,                                     }, /*11 - ThreeByteBgr */
 96 };
 97 
 98 extern void J2dTraceImpl(int level, jboolean cr, const char *string, ...);
 99 
100 void fillTxQuad(
101         struct TxtVertex * txQuadVerts,
102         jint sx1, jint sy1, jint sx2, jint sy2, jint sw, jint sh,
103         jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2, jdouble dw, jdouble dh
104 ) {
105     const float nsx1 = sx1/(float)sw;
106     const float nsy1 = sy1/(float)sh;
107     const float nsx2 = sx2/(float)sw;
108     const float nsy2 = sy2/(float)sh;
109 
110     txQuadVerts[0].position[0] = dx1;
111     txQuadVerts[0].position[1] = dy1;
112     txQuadVerts[0].txtpos[0]   = nsx1;
113     txQuadVerts[0].txtpos[1]   = nsy1;
114 
115     txQuadVerts[1].position[0] = dx2;
116     txQuadVerts[1].position[1] = dy1;
117     txQuadVerts[1].txtpos[0]   = nsx2;
118     txQuadVerts[1].txtpos[1]   = nsy1;
119 
120     txQuadVerts[2].position[0] = dx2;
121     txQuadVerts[2].position[1] = dy2;
122     txQuadVerts[2].txtpos[0]   = nsx2;
123     txQuadVerts[2].txtpos[1]   = nsy2;
124 
125     txQuadVerts[3].position[0] = dx2;
126     txQuadVerts[3].position[1] = dy2;
127     txQuadVerts[3].txtpos[0]   = nsx2;
128     txQuadVerts[3].txtpos[1]   = nsy2;
129 
130     txQuadVerts[4].position[0] = dx1;
131     txQuadVerts[4].position[1] = dy2;
132     txQuadVerts[4].txtpos[0]   = nsx1;
133     txQuadVerts[4].txtpos[1]   = nsy2;
134 
135     txQuadVerts[5].position[0] = dx1;
136     txQuadVerts[5].position[1] = dy1;
137     txQuadVerts[5].txtpos[0]   = nsx1;
138     txQuadVerts[5].txtpos[1]   = nsy1;
139 }
140 
141 //#define TRACE_drawTex2Tex
142 
143 void drawTex2Tex(MTLContext *mtlc,
144                         id&lt;MTLTexture&gt; src, id&lt;MTLTexture&gt; dst,
145                         jboolean isSrcOpaque, jboolean isDstOpaque, jint hint,
146                         jint sx1, jint sy1, jint sx2, jint sy2,
147                         jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)
148 {
149 #ifdef TRACE_drawTex2Tex
150     J2dRlsTraceLn2(J2D_TRACE_VERBOSE, &quot;drawTex2Tex: src tex=%p, dst tex=%p&quot;, src, dst);
151     J2dRlsTraceLn4(J2D_TRACE_VERBOSE, &quot;  sw=%d sh=%d dw=%d dh=%d&quot;, src.width, src.height, dst.width, dst.height);
152     J2dRlsTraceLn4(J2D_TRACE_VERBOSE, &quot;  sx1=%d sy1=%d sx2=%d sy2=%d&quot;, sx1, sy1, sx2, sy2);
153     J2dRlsTraceLn4(J2D_TRACE_VERBOSE, &quot;  dx1=%f dy1=%f dx2=%f dy2=%f&quot;, dx1, dy1, dx2, dy2);
154 #endif //TRACE_drawTex2Tex
155 
156     id&lt;MTLRenderCommandEncoder&gt; encoder = [mtlc.encoderManager getTextureEncoder:dst
157                                                                      isSrcOpaque:isSrcOpaque
158                                                                      isDstOpaque:isDstOpaque
159                                                                    interpolation:hint
160     ];
161 
162     struct TxtVertex quadTxVerticesBuffer[6];
163     fillTxQuad(quadTxVerticesBuffer, sx1, sy1, sx2, sy2, src.width, src.height, dx1, dy1, dx2, dy2, dst.width, dst.height);
164 
165     [encoder setVertexBytes:quadTxVerticesBuffer length:sizeof(quadTxVerticesBuffer) atIndex:MeshVertexBuffer];
166     [encoder setFragmentTexture:src atIndex: 0];
167     [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];
168 }
169 
170 static
171 id&lt;MTLTexture&gt; replaceTextureRegion(id&lt;MTLTexture&gt; dest, const SurfaceDataRasInfo * srcInfo, const MTLRasterFormatInfo * rfi, int dx1, int dy1, int dx2, int dy2) {
172     const int dw = dx2 - dx1;
173     const int dh = dy2 - dy1;
174 
175     const void * raster = srcInfo-&gt;rasBase;
176     id&lt;MTLTexture&gt; result = nil;
177     if (rfi-&gt;permuteMap != NULL) {
178 #if defined(__MAC_10_15) &amp;&amp; __MAC_OS_X_VERSION_MAX_ALLOWED &gt;= __MAC_10_15
179         if (@available(macOS 10.15, *)) {
180             @autoreleasepool {
181                 const uint8_t swzRed = revertPerm(rfi-&gt;permuteMap, 1);
182                 const uint8_t swzGreen = revertPerm(rfi-&gt;permuteMap, 2);
183                 const uint8_t swzBlue = revertPerm(rfi-&gt;permuteMap, 3);
184                 const uint8_t swzAlpha = revertPerm(rfi-&gt;permuteMap, 0);
185                 MTLTextureSwizzleChannels swizzle = MTLTextureSwizzleChannelsMake(
186                         uint2swizzle(swzRed),
187                         uint2swizzle(swzGreen),
188                         uint2swizzle(swzBlue),
189                         rfi-&gt;hasAlpha ? uint2swizzle(swzAlpha) : MTLTextureSwizzleOne
190                 );
191                 result = [dest
192                         newTextureViewWithPixelFormat:MTLPixelFormatBGRA8Unorm
193                         textureType:MTLTextureType2D
194                         levels:NSMakeRange(0, 1) slices:NSMakeRange(0, 1)
195                         swizzle:swizzle];
196                 J2dTraceLn5(J2D_TRACE_VERBOSE, &quot;replaceTextureRegion [use swizzle for pooled]: %d, %d, %d, %d, hasA=%d&quot;,
197                             swizzle.red, swizzle.green, swizzle.blue, swizzle.alpha, rfi-&gt;hasAlpha);
198             }
199         } else
200 #endif // __MAC_10_15 &amp;&amp; __MAC_OS_X_VERSION_MAX_ALLOWED &gt;= __MAC_10_15
201         {
202             // perform raster conversion
203             // invoked only from rq-thread, so use static buffers
204             // but it&#39;s better to use thread-local buffers (or special buffer manager)
205             const int destRasterSize = dw*dh*4;
206 
207             static int bufferSize = 0;
208             static void * buffer = NULL;
209             if (buffer == NULL || bufferSize &lt; destRasterSize) {
210                 bufferSize = destRasterSize;
211                 buffer = realloc(buffer, bufferSize);
212             }
213             if (buffer == NULL) {
214                 J2dTraceLn1(J2D_TRACE_ERROR, &quot;replaceTextureRegion: can&#39;t alloc buffer for raster conversion, size=%d&quot;, bufferSize);
215                 bufferSize = 0;
216                 return nil;
217             }
218             vImage_Buffer srcBuf;
219             srcBuf.height = dh;
220             srcBuf.width = dw;
221             srcBuf.rowBytes = srcInfo-&gt;scanStride;
222             srcBuf.data = srcInfo-&gt;rasBase;
223 
224             vImage_Buffer destBuf;
225             destBuf.height = dh;
226             destBuf.width = dw;
227             destBuf.rowBytes = dw*4;
228             destBuf.data = buffer;
229 
230             vImagePermuteChannels_ARGB8888(&amp;srcBuf, &amp;destBuf, rfi-&gt;permuteMap, kvImageNoFlags);
231             raster = buffer;
232 
233             J2dTraceLn5(J2D_TRACE_VERBOSE, &quot;replaceTextureRegion [use conversion]: %d, %d, %d, %d, hasA=%d&quot;,
234                         rfi-&gt;permuteMap[0], rfi-&gt;permuteMap[1], rfi-&gt;permuteMap[2], rfi-&gt;permuteMap[3], rfi-&gt;hasAlpha);
235         }
236     }
237 
238     MTLRegion region = MTLRegionMake2D(dx1, dy1, dw, dh);
239     if (result != nil)
240         dest = result;
241     [dest replaceRegion:region mipmapLevel:0 withBytes:raster bytesPerRow:srcInfo-&gt;scanStride];
242     return result;
243 }
244 
245 /**
246  * Inner loop used for copying a source system memory (&quot;Sw&quot;) surface to a
247  * destination MTL &quot;Surface&quot;.  This method is invoked from
248  * MTLBlitLoops_Blit().
249  */
250 
251 static void
252 MTLBlitSwToTextureViaPooledTexture(
253         MTLContext *mtlc, SurfaceDataRasInfo *srcInfo, BMTLSDOps * bmtlsdOps,
254         MTLRasterFormatInfo * rfi, jboolean useBlitEncoder, jint hint,
255         jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)
256 {
257     const int sw = srcInfo-&gt;bounds.x2 - srcInfo-&gt;bounds.x1;
258     const int sh = srcInfo-&gt;bounds.y2 - srcInfo-&gt;bounds.y1;
259     id&lt;MTLTexture&gt; dest = bmtlsdOps-&gt;pTexture;
260 
261     MTLPooledTextureHandle * texHandle = [mtlc.texturePool getTexture:sw height:sh format:rfi-&gt;format];
262     if (texHandle == nil) {
263         J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBlitSwToTextureViaPooledTexture: can&#39;t obtain temporary texture object from pool&quot;);
264         return;
265     }
266     [[mtlc getCommandBufferWrapper] registerPooledTexture:texHandle];
267     [texHandle release];
268 
269     id&lt;MTLTexture&gt; texBuff = texHandle.texture;
270     id&lt;MTLTexture&gt; swizzledTexture = replaceTextureRegion(texBuff, srcInfo, rfi, 0, 0, sw, sh);
271     if (useBlitEncoder) {
272         id &lt;MTLBlitCommandEncoder&gt; blitEncoder = [mtlc.encoderManager createBlitEncoder];
273         [blitEncoder copyFromTexture:swizzledTexture != nil ? swizzledTexture : texBuff
274                          sourceSlice:0
275                          sourceLevel:0
276                         sourceOrigin:MTLOriginMake(0, 0, 0)
277                           sourceSize:MTLSizeMake(sw, sh, 1)
278                            toTexture:dest
279                     destinationSlice:0
280                     destinationLevel:0
281                    destinationOrigin:MTLOriginMake(dx1, dy1, 0)];
282         [blitEncoder endEncoding];
283     } else {
284         drawTex2Tex(mtlc, swizzledTexture != nil ? swizzledTexture : texBuff, dest, !rfi-&gt;hasAlpha, bmtlsdOps-&gt;isOpaque, hint,
285                     0, 0, sw, sh, dx1, dy1, dx2, dy2);
286     }
287 
288     if (swizzledTexture != nil) {
289         [swizzledTexture release];
290     }
291 }
292 
293 static
294 jboolean isIntegerAndUnscaled(
295         jint sx1, jint sy1, jint sx2, jint sy2,
296         jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2
297 ) {
298     const jdouble epsilon = 0.0001f;
299 
300     // check that dx1,dy1 is integer
301     if (fabs(dx1 - (int)dx1) &gt; epsilon || fabs(dy1 - (int)dy1) &gt; epsilon) {
302         return JNI_FALSE;
303     }
304     // check that destSize equals srcSize
305     if (fabs(dx2 - dx1 - sx2 + sx1) &gt; epsilon || fabs(dy2 - dy1 - sy2 + sy1) &gt; epsilon) {
306         return JNI_FALSE;
307     }
308     return JNI_TRUE;
309 }
310 
311 static
312 jboolean clipDestCoords(
313         jdouble *dx1, jdouble *dy1, jdouble *dx2, jdouble *dy2,
314         jint *sx1, jint *sy1, jint *sx2, jint *sy2,
315         jint destW, jint destH, const MTLScissorRect * clipRect
316 ) {
317     // Trim destination rect by clip-rect (or dest.bounds)
318     const jint sw    = *sx2 - *sx1;
319     const jint sh    = *sy2 - *sy1;
320     const jdouble dw = *dx2 - *dx1;
321     const jdouble dh = *dy2 - *dy1;
322 
323     jdouble dcx1 = 0;
324     jdouble dcx2 = destW;
325     jdouble dcy1 = 0;
326     jdouble dcy2 = destH;
327     if (clipRect != NULL) {
328         if (clipRect-&gt;x &gt; dcx1)
329             dcx1 = clipRect-&gt;x;
330         const int maxX = clipRect-&gt;x + clipRect-&gt;width;
331         if (dcx2 &gt; maxX)
332             dcx2 = maxX;
333         if (clipRect-&gt;y &gt; dcy1)
334             dcy1 = clipRect-&gt;y;
335         const int maxY = clipRect-&gt;y + clipRect-&gt;height;
336         if (dcy2 &gt; maxY)
337             dcy2 = maxY;
338 
339         if (dcx1 &gt;= dcx2) {
340             J2dTraceLn2(J2D_TRACE_ERROR, &quot;\tclipDestCoords: dcx1=%1.2f, dcx2=%1.2f&quot;, dcx1, dcx2);
341             dcx1 = dcx2;
342         }
343         if (dcy1 &gt;= dcy2) {
344             J2dTraceLn2(J2D_TRACE_ERROR, &quot;\tclipDestCoords: dcy1=%1.2f, dcy2=%1.2f&quot;, dcy1, dcy2);
345             dcy1 = dcy2;
346         }
347     }
348     if (*dx2 &lt;= dcx1 || *dx1 &gt;= dcx2 || *dy2 &lt;= dcy1 || *dy1 &gt;= dcy2) {
349         J2dTraceLn(J2D_TRACE_INFO, &quot;\tclipDestCoords: dest rect doesn&#39;t intersect clip area&quot;);
350         return JNI_FALSE;
351     }
352     if (*dx1 &lt; dcx1) {
353         J2dTraceLn2(J2D_TRACE_VERBOSE, &quot;\t\tdx1=%1.2f, will be clipped to %1.2f&quot;, *dx1, dcx1);
354         *sx1 += (jint)((dcx1 - *dx1) * (sw/dw));
355         *dx1 = dcx1;
356     }
357     if (*dx2 &gt; dcx2) {
358         J2dTraceLn2(J2D_TRACE_VERBOSE, &quot;\t\tdx2=%1.2f, will be clipped to %1.2f&quot;, *dx2, dcx2);
359         *sx2 -= (jint)((*dx2 - dcx2) * (sw/dw));
360         *dx2 = dcx2;
361     }
362     if (*dy1 &lt; dcy1) {
363         J2dTraceLn2(J2D_TRACE_VERBOSE, &quot;\t\tdy1=%1.2f, will be clipped to %1.2f&quot;, *dy1, dcy1);
364         *sy1 += (jint)((dcy1 - *dy1) * (sh/dh));
365         *dy1 = dcy1;
366     }
367     if (*dy2 &gt; dcy2) {
368         J2dTraceLn2(J2D_TRACE_VERBOSE, &quot;\t\tdy2=%1.2f, will be clipped to %1.2f&quot;, *dy2, dcy2);
369         *sy2 -= (jint)((*dy2 - dcy2) * (sh/dh));
370         *dy2 = dcy2;
371     }
372     return JNI_TRUE;
373 }
374 
375 /**
376  * General blit method for copying a native MTL surface to another MTL &quot;Surface&quot;.
377  * Parameter texture == true forces to use &#39;texture&#39; codepath (dest coordinates will always be integers).
378  * Parameter xform == true only when AffineTransform is used (invoked only from TransformBlit, dest coordinates will always be integers).
379  */
380 void
381 MTLBlitLoops_IsoBlit(JNIEnv *env,
382                      MTLContext *mtlc, jlong pSrcOps, jlong pDstOps,
383                      jboolean xform, jint hint, jboolean texture,
384                      jint sx1, jint sy1, jint sx2, jint sy2,
385                      jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)
386 {
387     BMTLSDOps *srcOps = (BMTLSDOps *)jlong_to_ptr(pSrcOps);
388     BMTLSDOps *dstOps = (BMTLSDOps *)jlong_to_ptr(pDstOps);
389 
390     RETURN_IF_NULL(mtlc);
391     RETURN_IF_NULL(srcOps);
392     RETURN_IF_NULL(dstOps);
393 
394     id&lt;MTLTexture&gt; srcTex = srcOps-&gt;pTexture;
395     id&lt;MTLTexture&gt; dstTex = dstOps-&gt;pTexture;
396     if (srcTex == nil || srcTex == nil) {
397         J2dTraceLn2(J2D_TRACE_ERROR, &quot;MTLBlitLoops_IsoBlit: surface is null (stex=%p, dtex=%p)&quot;, srcTex, dstTex);
398         return;
399     }
400 
401     const jint sw    = sx2 - sx1;
402     const jint sh    = sy2 - sy1;
403     const jdouble dw = dx2 - dx1;
404     const jdouble dh = dy2 - dy1;
405 
406     if (sw &lt;= 0 || sh &lt;= 0 || dw &lt;= 0 || dh &lt;= 0) {
407         J2dTraceLn4(J2D_TRACE_WARNING, &quot;MTLBlitLoops_IsoBlit: invalid dimensions: sw=%d, sh%d, dw=%d, dh=%d&quot;, sw, sh, dw, dh);
408         return;
409     }
410 
411 #ifdef DEBUG_ISOBLIT
412     if ((xform == JNI_TRUE) != (mtlc.useTransform == JNI_TRUE)) {
413         J2dTraceImpl(J2D_TRACE_ERROR, JNI_TRUE,
414                 &quot;MTLBlitLoops_IsoBlit state error: xform=%d, mtlc.useTransform=%d, texture=%d&quot;,
415                 xform, mtlc.useTransform, texture);
416     }
417 #endif // DEBUG_ISOBLIT
418 
419     clipDestCoords(
420             &amp;dx1, &amp;dy1, &amp;dx2, &amp;dy2,
421             &amp;sx1, &amp;sy1, &amp;sx2, &amp;sy2,
422             dstTex.width, dstTex.height, [mtlc.clip getRect]
423     );
424 
425     SurfaceDataBounds bounds;
426     bounds.x1 = sx1;
427     bounds.y1 = sy1;
428     bounds.x2 = sx2;
429     bounds.y2 = sy2;
430     SurfaceData_IntersectBoundsXYXY(&amp;bounds, 0, 0, srcOps-&gt;width, srcOps-&gt;height);
431 
432     if (bounds.x2 &lt;= bounds.x1 || bounds.y2 &lt;= bounds.y1) {
433         J2dTraceLn(J2D_TRACE_VERBOSE, &quot;MTLBlitLoops_IsoBlit: source rectangle doesn&#39;t intersect with source surface bounds&quot;);
434         J2dTraceLn6(J2D_TRACE_VERBOSE, &quot;  sx1=%d sy1=%d sx2=%d sy2=%d sw=%d sh=%d&quot;, sx1, sy1, sx2, sy2, srcOps-&gt;width, srcOps-&gt;height);
435         J2dTraceLn4(J2D_TRACE_VERBOSE, &quot;  dx1=%f dy1=%f dx2=%f dy2=%f&quot;, dx1, dy1, dx2, dy2);
436         return;
437     }
438 
439     if (bounds.x1 != sx1) {
440         dx1 += (bounds.x1 - sx1) * (dw / sw);
441         sx1 = bounds.x1;
442     }
443     if (bounds.y1 != sy1) {
444         dy1 += (bounds.y1 - sy1) * (dh / sh);
445         sy1 = bounds.y1;
446     }
447     if (bounds.x2 != sx2) {
448         dx2 += (bounds.x2 - sx2) * (dw / sw);
449         sx2 = bounds.x2;
450     }
451     if (bounds.y2 != sy2) {
452         dy2 += (bounds.y2 - sy2) * (dh / sh);
453         sy2 = bounds.y2;
454     }
455 
456 #ifdef TRACE_ISOBLIT
457     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_FALSE,
458          &quot;MTLBlitLoops_IsoBlit [tx=%d, xf=%d, AC=%s]: src=%s, dst=%s | (%d, %d, %d, %d)-&gt;(%1.2f, %1.2f, %1.2f, %1.2f)&quot;,
459          texture, xform, [mtlc getCompositeDescription].cString,
460          getSurfaceDescription(srcOps).cString, getSurfaceDescription(dstOps).cString,
461          sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2);
462 #endif //TRACE_ISOBLIT
463 
464     if (!texture &amp;&amp; !xform
465         &amp;&amp; [mtlc isBlendingDisabled:srcOps-&gt;isOpaque]
466         &amp;&amp; isIntegerAndUnscaled(sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2)
467         &amp;&amp; (dstOps-&gt;isOpaque || !srcOps-&gt;isOpaque)
468     ) {
469 #ifdef TRACE_ISOBLIT
470         J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [via blitEncoder]&quot;);
471 #endif //TRACE_ISOBLIT
472 
473         id &lt;MTLBlitCommandEncoder&gt; blitEncoder = [mtlc.encoderManager createBlitEncoder];
474         [blitEncoder copyFromTexture:srcTex
475                          sourceSlice:0
476                          sourceLevel:0
477                         sourceOrigin:MTLOriginMake(sx1, sy1, 0)
478                           sourceSize:MTLSizeMake(sx2 - sx1, sy2 - sy1, 1)
479                            toTexture:dstTex
480                     destinationSlice:0
481                     destinationLevel:0
482                    destinationOrigin:MTLOriginMake(dx1, dy1, 0)];
483         [blitEncoder endEncoding];
484         return;
485     }
486 
487 #ifdef TRACE_ISOBLIT
488     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [via sampling]&quot;);
489 #endif //TRACE_ISOBLIT
490     drawTex2Tex(mtlc, srcTex, dstTex,
491             [mtlc isBlendingDisabled:srcOps-&gt;isOpaque],
492             dstOps-&gt;isOpaque, hint, sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2);
493 }
494 
495 /**
496  * General blit method for copying a system memory (&quot;Sw&quot;) surface to a native MTL surface.
497  * Parameter texture == true only in SwToTextureBlit (straight copy from sw to texture), dest coordinates will always be integers.
498  * Parameter xform == true only when AffineTransform is used (invoked only from TransformBlit, dest coordinates will always be integers).
499  */
500 void
501 MTLBlitLoops_Blit(JNIEnv *env,
502                   MTLContext *mtlc, jlong pSrcOps, jlong pDstOps,
503                   jboolean xform, jint hint,
504                   jint srctype, jboolean texture,
505                   jint sx1, jint sy1, jint sx2, jint sy2,
506                   jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)
507 {
508     SurfaceDataOps *srcOps = (SurfaceDataOps *)jlong_to_ptr(pSrcOps);
509     BMTLSDOps *dstOps = (BMTLSDOps *)jlong_to_ptr(pDstOps);
510 
511     RETURN_IF_NULL(mtlc);
512     RETURN_IF_NULL(srcOps);
513     RETURN_IF_NULL(dstOps);
514 
515     id&lt;MTLTexture&gt; dest = dstOps-&gt;pTexture;
516     if (dest == NULL) {
517         J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBlitLoops_Blit: dest is null&quot;);
518         return;
519     }
520     if (srctype &lt; 0 || srctype &gt;= sizeof(RasterFormatInfos)/ sizeof(MTLRasterFormatInfo)) {
521         J2dTraceLn1(J2D_TRACE_ERROR, &quot;MTLBlitLoops_Blit: source pixel format %d isn&#39;t supported&quot;, srctype);
522         return;
523     }
524     const jint sw    = sx2 - sx1;
525     const jint sh    = sy2 - sy1;
526     const jdouble dw = dx2 - dx1;
527     const jdouble dh = dy2 - dy1;
528 
529     if (sw &lt;= 0 || sh &lt;= 0 || dw &lt;= 0 || dh &lt;= 0) {
530         J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBlitLoops_Blit: invalid dimensions&quot;);
531         return;
532     }
533 
534 #ifdef DEBUG_BLIT
535     if (
536         (xform == JNI_TRUE) != (mtlc.useTransform == JNI_TRUE)
537         || (xform &amp;&amp; texture)
538     ) {
539         J2dTraceImpl(J2D_TRACE_ERROR, JNI_TRUE,
540                 &quot;MTLBlitLoops_Blit state error: xform=%d, mtlc.useTransform=%d, texture=%d&quot;,
541                 xform, mtlc.useTransform, texture);
542     }
543     if (texture) {
544         if (!isIntegerAndUnscaled(sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2)) {
545             J2dTraceImpl(J2D_TRACE_ERROR, JNI_TRUE,
546                     &quot;MTLBlitLoops_Blit state error: texture=true, but src and dst dimensions aren&#39;t equal or dest coords aren&#39;t integers&quot;);
547         }
548         if (!dstOps-&gt;isOpaque &amp;&amp; !RasterFormatInfos[srctype].hasAlpha) {
549             J2dTraceImpl(J2D_TRACE_ERROR, JNI_TRUE,
550                     &quot;MTLBlitLoops_Blit state error: texture=true, but dest has alpha and source hasn&#39;t alpha, can&#39;t use texture-codepath&quot;);
551         }
552     }
553 #endif // DEBUG_BLIT
554 
555     clipDestCoords(
556             &amp;dx1, &amp;dy1, &amp;dx2, &amp;dy2,
557             &amp;sx1, &amp;sy1, &amp;sx2, &amp;sy2,
558             dest.width, dest.height, texture ? NULL : [mtlc.clip getRect]
559     );
560 
561     SurfaceDataRasInfo srcInfo;
562     srcInfo.bounds.x1 = sx1;
563     srcInfo.bounds.y1 = sy1;
564     srcInfo.bounds.x2 = sx2;
565     srcInfo.bounds.y2 = sy2;
566 
567     // NOTE: This function will modify the contents of the bounds field to represent the maximum available raster data.
568     if (srcOps-&gt;Lock(env, srcOps, &amp;srcInfo, SD_LOCK_READ) != SD_SUCCESS) {
569         J2dTraceLn(J2D_TRACE_WARNING, &quot;MTLBlitLoops_Blit: could not acquire lock&quot;);
570         return;
571     }
572 
573     if (srcInfo.bounds.x2 &gt; srcInfo.bounds.x1 &amp;&amp; srcInfo.bounds.y2 &gt; srcInfo.bounds.y1) {
574         srcOps-&gt;GetRasInfo(env, srcOps, &amp;srcInfo);
575         if (srcInfo.rasBase) {
576             if (srcInfo.bounds.x1 != sx1) {
577                 const int dx = srcInfo.bounds.x1 - sx1;
578                 dx1 += dx * (dw / sw);
579             }
580             if (srcInfo.bounds.y1 != sy1) {
581                 const int dy = srcInfo.bounds.y1 - sy1;
582                 dy1 += dy * (dh / sh);
583             }
584             if (srcInfo.bounds.x2 != sx2) {
585                 const int dx = srcInfo.bounds.x2 - sx2;
586                 dx2 += dx * (dw / sw);
587             }
588             if (srcInfo.bounds.y2 != sy2) {
589                 const int dy = srcInfo.bounds.y2 - sy2;
590                 dy2 += dy * (dh / sh);
591             }
592 
593 #ifdef TRACE_BLIT
594             J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_FALSE,
595                     &quot;MTLBlitLoops_Blit [tx=%d, xf=%d, AC=%s]: bdst=%s, src=%p (%dx%d) O=%d premul=%d | (%d, %d, %d, %d)-&gt;(%1.2f, %1.2f, %1.2f, %1.2f)&quot;,
596                     texture, xform, [mtlc getCompositeDescription].cString,
597                     getSurfaceDescription(dstOps).cString, srcOps,
598                     sx2 - sx1, sy2 - sy1,
599                     RasterFormatInfos[srctype].hasAlpha ? 0 : 1, RasterFormatInfos[srctype].isPremult ? 1 : 0,
600                     sx1, sy1, sx2, sy2,
601                     dx1, dy1, dx2, dy2);
602 #endif //TRACE_BLIT
603 
604             MTLRasterFormatInfo rfi = RasterFormatInfos[srctype];
605             const jboolean useReplaceRegion = texture ||
606                     ([mtlc isBlendingDisabled:!rfi.hasAlpha]
607                     &amp;&amp; !xform
608                     &amp;&amp; isIntegerAndUnscaled(sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2));
609 
610             if (useReplaceRegion) {
611                 if (dstOps-&gt;isOpaque || rfi.hasAlpha) {
612 #ifdef TRACE_BLIT
613                     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [replaceTextureRegion]&quot;);
614 #endif //TRACE_BLIT
615                     replaceTextureRegion(dest, &amp;srcInfo, &amp;rfi, (int) dx1, (int) dy1, (int) dx2, (int) dy2);
616                 } else {
617 #ifdef TRACE_BLIT
618                     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [via pooled + blit]&quot;);
619 #endif //TRACE_BLIT
620                     MTLBlitSwToTextureViaPooledTexture(mtlc, &amp;srcInfo, dstOps, &amp;rfi, true, hint, dx1, dy1, dx2, dy2);
621                 }
622             } else { // !useReplaceRegion
623 #ifdef TRACE_BLIT
624                 J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [via pooled texture]&quot;);
625 #endif //TRACE_BLIT
626                 MTLBlitSwToTextureViaPooledTexture(mtlc, &amp;srcInfo, dstOps, &amp;rfi, false, hint, dx1, dy1, dx2, dy2);
627             }
628         }
629         SurfaceData_InvokeRelease(env, srcOps, &amp;srcInfo);
630     }
631     SurfaceData_InvokeUnlock(env, srcOps, &amp;srcInfo);
632 }
633 
634 /**
635  * Specialized blit method for copying a native MTL &quot;Surface&quot; (pbuffer,
636  * window, etc.) to a system memory (&quot;Sw&quot;) surface.
637  */
638 void
639 MTLBlitLoops_SurfaceToSwBlit(JNIEnv *env, MTLContext *mtlc,
640                              jlong pSrcOps, jlong pDstOps, jint dsttype,
641                              jint srcx, jint srcy, jint dstx, jint dsty,
642                              jint width, jint height)
643 {
644     J2dTraceLn6(J2D_TRACE_VERBOSE, &quot;MTLBlitLoops_SurfaceToSwBlit: sx=%d sy=%d w=%d h=%d dx=%d dy=%d&quot;, srcx, srcy, width, height, dstx, dsty);
645 
646     BMTLSDOps *srcOps = (BMTLSDOps *)jlong_to_ptr(pSrcOps);
647     SurfaceDataOps *dstOps = (SurfaceDataOps *)jlong_to_ptr(pDstOps);
648     SurfaceDataRasInfo srcInfo, dstInfo;
649 
650     if (dsttype &lt; 0 || dsttype &gt;= sizeof(RasterFormatInfos)/ sizeof(MTLRasterFormatInfo)) {
651         J2dTraceLn1(J2D_TRACE_ERROR, &quot;MTLBlitLoops_SurfaceToSwBlit: destination pixel format %d isn&#39;t supported&quot;, dsttype);
652         return;
653     }
654 
655     if (width &lt;= 0 || height &lt;= 0) {
656         J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBlitLoops_SurfaceToSwBlit: dimensions are non-positive&quot;);
657         return;
658     }
659 
660     RETURN_IF_NULL(srcOps);
661     RETURN_IF_NULL(dstOps);
662     RETURN_IF_NULL(mtlc);
663 
664     srcInfo.bounds.x1 = srcx;
665     srcInfo.bounds.y1 = srcy;
666     srcInfo.bounds.x2 = srcx + width;
667     srcInfo.bounds.y2 = srcy + height;
668     dstInfo.bounds.x1 = dstx;
669     dstInfo.bounds.y1 = dsty;
670     dstInfo.bounds.x2 = dstx + width;
671     dstInfo.bounds.y2 = dsty + height;
672 
673     if (dstOps-&gt;Lock(env, dstOps, &amp;dstInfo, SD_LOCK_WRITE) != SD_SUCCESS) {
674         J2dTraceLn(J2D_TRACE_WARNING,&quot;MTLBlitLoops_SurfaceToSwBlit: could not acquire dst lock&quot;);
675         return;
676     }
677 
678     SurfaceData_IntersectBoundsXYXY(&amp;srcInfo.bounds,
679                                     0, 0, srcOps-&gt;width, srcOps-&gt;height);
680     SurfaceData_IntersectBlitBounds(&amp;dstInfo.bounds, &amp;srcInfo.bounds,
681                                     srcx - dstx, srcy - dsty);
682 
683     if (srcInfo.bounds.x2 &gt; srcInfo.bounds.x1 &amp;&amp;
684         srcInfo.bounds.y2 &gt; srcInfo.bounds.y1)
685     {
686         dstOps-&gt;GetRasInfo(env, dstOps, &amp;dstInfo);
687         if (dstInfo.rasBase) {
688             void *pDst = dstInfo.rasBase;
689 
690             srcx = srcInfo.bounds.x1;
691             srcy = srcInfo.bounds.y1;
692             dstx = dstInfo.bounds.x1;
693             dsty = dstInfo.bounds.y1;
694             width = srcInfo.bounds.x2 - srcInfo.bounds.x1;
695             height = srcInfo.bounds.y2 - srcInfo.bounds.y1;
696 
697             pDst = PtrAddBytes(pDst, dstx * dstInfo.pixelStride);
698             pDst = PtrPixelsRow(pDst, dsty, dstInfo.scanStride);
699 
700             // this accounts for lower-left origin of the source region
701             srcx = srcOps-&gt;xOffset + srcx;
702             srcy = srcOps-&gt;yOffset + srcOps-&gt;height - srcy - height;
703             const int srcLength = width * height * 4; // NOTE: assume that src format is MTLPixelFormatBGRA8Unorm
704 
705 #ifdef DEBUG
706             void *pDstEnd = dstInfo.rasBase + (height - 1)*dstInfo.scanStride + width*dstInfo.pixelStride;
707             if (pDst + srcLength &gt; pDstEnd) {
708                 J2dTraceLn6(J2D_TRACE_ERROR, &quot;MTLBlitLoops_SurfaceToSwBlit: length mismatch: dstx=%d, dsty=%d, w=%d, h=%d, pixStride=%d, scanStride=%d&quot;,
709                         dstx, dsty, width, height, dstInfo.pixelStride, dstInfo.scanStride);
710                 return;
711             }
712 #endif //DEBUG
713 
714             // Create MTLBuffer (or use static)
715             MTLRasterFormatInfo rfi = RasterFormatInfos[dsttype];
716             const jboolean directCopy = rfi.permuteMap == NULL;
717 
718             id&lt;MTLBuffer&gt; mtlbuf;
719 #ifdef USE_STATIC_BUFFER
720             if (directCopy) {
721                 // NOTE: theoretically we can use newBufferWithBytesNoCopy, but pDst must be allocated with special API
722                 // mtlbuf = [mtlc.device
723                 //          newBufferWithBytesNoCopy:pDst
724                 //                            length:(NSUInteger) srcLength
725                 //                           options:MTLResourceCPUCacheModeDefaultCache
726                 //                       deallocator:nil];
727                 //
728                 // see https://developer.apple.com/documentation/metal/mtldevice/1433382-newbufferwithbytesnocopy?language=objc
729                 //
730                 // The storage allocation of the returned new MTLBuffer object is the same as the pointer input value.
731                 // The existing memory allocation must be covered by a single VM region, typically allocated with vm_allocate or mmap.
732                 // Memory allocated by malloc is specifically disallowed.
733             }
734 
735             static id&lt;MTLBuffer&gt; mtlIntermediateBuffer = nil; // need to reimplement with MTLBufferManager
736             if (mtlIntermediateBuffer == nil || mtlIntermediateBuffer.length &lt; srcLength) {
737                 if (mtlIntermediateBuffer != nil) {
738                     [mtlIntermediateBuffer release];
739                 }
740                 mtlIntermediateBuffer = [mtlc.device newBufferWithLength:srcLength options:MTLResourceCPUCacheModeDefaultCache];
741             }
742             mtlbuf = mtlIntermediateBuffer;
743 #else // USE_STATIC_BUFFER
744             mtlbuf = [mtlc.device newBufferWithLength:width*height*4 options:MTLResourceStorageModeShared];
745 #endif // USE_STATIC_BUFFER
746 
747             // Read from surface into MTLBuffer
748             // NOTE: using of separate blitCommandBuffer can produce errors (draw into surface (with general cmd-buf)
749             // can be unfinished when reading raster from blit cmd-buf).
750             // Consider to use [mtlc.encoderManager createBlitEncoder] and [mtlc commitCommandBuffer:JNI_TRUE];
751             J2dTraceLn1(J2D_TRACE_VERBOSE, &quot;MTLBlitLoops_SurfaceToSwBlit: source texture %p&quot;, srcOps-&gt;pTexture);
752 
753             id&lt;MTLCommandBuffer&gt; cb = [mtlc createBlitCommandBuffer];
754             id&lt;MTLBlitCommandEncoder&gt; blitEncoder = [cb blitCommandEncoder];
755             [blitEncoder synchronizeTexture:srcOps-&gt;pTexture slice:0 level:0];
756             [blitEncoder copyFromTexture:srcOps-&gt;pTexture
757                             sourceSlice:0
758                             sourceLevel:0
759                            sourceOrigin:MTLOriginMake(srcx, srcy, 0)
760                              sourceSize:MTLSizeMake(width, height, 1)
761                                toBuffer:mtlbuf
762                       destinationOffset:0 /*offset already taken in: pDst = PtrAddBytes(pDst, dstx * dstInfo.pixelStride)*/
763                  destinationBytesPerRow:width*4
764                destinationBytesPerImage:width * height*4];
765             [blitEncoder endEncoding];
766 
767             // Commit and wait for reading complete
768             [cb commit];
769             [cb waitUntilCompleted];
770 
771             // Perform conversion if necessary
772             if (directCopy) {
773                 memcpy(pDst, mtlbuf.contents, srcLength);
774             } else {
775                 J2dTraceLn6(J2D_TRACE_VERBOSE,&quot;MTLBlitLoops_SurfaceToSwBlit: dsttype=%d, raster conversion will be performed, dest rfi: %d, %d, %d, %d, hasA=%d&quot;,
776                             dsttype, rfi.permuteMap[0], rfi.permuteMap[1], rfi.permuteMap[2], rfi.permuteMap[3], rfi.hasAlpha);
777 
778                 // perform raster conversion: mtlIntermediateBuffer(8888) -&gt; pDst(rfi)
779                 // invoked only from rq-thread, so use static buffers
780                 // but it&#39;s better to use thread-local buffers (or special buffer manager)
781                 vImage_Buffer srcBuf;
782                 srcBuf.height = height;
783                 srcBuf.width = width;
784                 srcBuf.rowBytes = 4*width;
785                 srcBuf.data = mtlbuf.contents;
786 
787                 vImage_Buffer destBuf;
788                 destBuf.height = height;
789                 destBuf.width = width;
790                 destBuf.rowBytes = dstInfo.scanStride;
791                 destBuf.data = pDst;
792 
793                 vImagePermuteChannels_ARGB8888(&amp;srcBuf, &amp;destBuf, rfi.permuteMap, kvImageNoFlags);
794             }
795 #ifndef USE_STATIC_BUFFER
796             [mtlbuf release];
797 #endif // USE_STATIC_BUFFER
798         }
799         SurfaceData_InvokeRelease(env, dstOps, &amp;dstInfo);
800     }
801     SurfaceData_InvokeUnlock(env, dstOps, &amp;dstInfo);
802 }
803 
804 void
805 MTLBlitLoops_CopyArea(JNIEnv *env,
806                       MTLContext *mtlc, BMTLSDOps *dstOps,
807                       jint x, jint y, jint width, jint height,
808                       jint dx, jint dy)
809 {
810 #ifdef DEBUG
811     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE, &quot;MTLBlitLoops_CopyArea: bdst=%p [tex=%p] %dx%d | src (%d, %d), %dx%d -&gt; dst (%d, %d)&quot;,
812             dstOps, dstOps-&gt;pTexture, ((id&lt;MTLTexture&gt;)dstOps-&gt;pTexture).width, ((id&lt;MTLTexture&gt;)dstOps-&gt;pTexture).height, x, y, width, height, dx, dy);
813 #endif //DEBUG
814     id &lt;MTLBlitCommandEncoder&gt; blitEncoder = [mtlc.encoderManager createBlitEncoder];
815     [blitEncoder
816             copyFromTexture:dstOps-&gt;pTexture
817             sourceSlice:0 sourceLevel:0 sourceOrigin:MTLOriginMake(x, y, 0) sourceSize:MTLSizeMake(width, height, 1)
818             toTexture:dstOps-&gt;pTexture destinationSlice:0 destinationLevel:0 destinationOrigin:MTLOriginMake(x + dx, y + dy, 0)];
819     [blitEncoder endEncoding];
820 
821     // TODO:
822     //  1. check rect bounds
823     //  2. support CopyArea with extra-alpha (and with custom Composite if necessary)
824 }
825 
826 #endif /* !HEADLESS */
    </pre>
  </body>
</html>
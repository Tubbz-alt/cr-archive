<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLGraphicsConfig.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #import &quot;sun_java2d_metal_MTLGraphicsConfig.h&quot;
 27 
 28 #import &quot;MTLGraphicsConfig.h&quot;
 29 #import &quot;MTLSurfaceData.h&quot;
 30 #import &quot;ThreadUtilities.h&quot;
 31 #import &quot;awt.h&quot;
 32 
 33 #import &lt;stdlib.h&gt;
 34 #import &lt;string.h&gt;
 35 #import &lt;ApplicationServices/ApplicationServices.h&gt;
 36 #import &lt;JavaNativeFoundation/JavaNativeFoundation.h&gt;
 37 
 38 #pragma mark -
 39 #pragma mark &quot;--- Mac OS X specific methods for GL pipeline ---&quot;
 40 
 41 /**
 42  * Disposes all memory and resources associated with the given
 43  * CGLGraphicsConfigInfo (including its native MTLContext data).
 44  */
 45 void
 46 MTLGC_DestroyMTLGraphicsConfig(jlong pConfigInfo)
 47 {
 48     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLGC_DestroyMTLGraphicsConfig&quot;);
 49 
 50     MTLGraphicsConfigInfo *mtlinfo =
 51         (MTLGraphicsConfigInfo *)jlong_to_ptr(pConfigInfo);
 52     if (mtlinfo == NULL) {
 53         J2dRlsTraceLn(J2D_TRACE_ERROR,
 54                       &quot;MTLGC_DestroyMTLGraphicsConfig: info is null&quot;);
 55         return;
 56     }
 57 
 58     MTLContext *mtlc = (MTLContext*)mtlinfo-&gt;context;
 59     if (mtlc != NULL) {
 60         [mtlinfo-&gt;context release];
 61         mtlinfo-&gt;context = nil;
 62     }
 63     free(mtlinfo);
 64 }
 65 
 66 #pragma mark -
 67 #pragma mark &quot;--- MTLGraphicsConfig methods ---&quot;
 68 
 69 
 70 /**
 71  * Attempts to initialize CGL and the core OpenGL library.
 72  */
 73 JNIEXPORT jboolean JNICALL
 74 Java_sun_java2d_metal_MTLGraphicsConfig_initMTL
 75     (JNIEnv *env, jclass cglgc)
 76 {
 77     J2dRlsTraceLn(J2D_TRACE_INFO, &quot;MTLGraphicsConfig_initMTL&quot;);
 78 
 79     FILE *f = popen(&quot;system_profiler SPDisplaysDataType&quot;, &quot;r&quot;);
 80     bool metalSupport = FALSE;
 81     while (getc(f) != EOF)
 82     {
 83         char str[60];
 84 
 85         if (fgets(str, 60, f) != NULL) {
 86             // Check for string
 87             // &quot;Metal:	Supported, feature set macOS GPUFamily1 v4&quot;
 88             if (strstr(str, &quot;Metal&quot;) != NULL) {
 89                 puts(str);
 90                 metalSupport = JNI_TRUE;
 91                 break;
 92             }
 93         }
 94     }
 95     pclose(f);
 96     if (!metalSupport) {
 97         fprintf(stderr, &quot;Metal support not present\n&quot;);
 98         return JNI_FALSE;
 99     } else {
100         fprintf(stderr, &quot;Metal support is present\n&quot;);
101     }
102 
103     if (!MTLFuncs_OpenLibrary()) {
104         return JNI_FALSE;
105     }
106 
107     if (!MTLFuncs_InitPlatformFuncs() ||
108         !MTLFuncs_InitBaseFuncs() ||
109         !MTLFuncs_InitExtFuncs())
110     {
111         MTLFuncs_CloseLibrary();
112         return JNI_FALSE;
113     }
114 
115     return JNI_TRUE;
116 }
117 
118 
119 /**
120  * Determines whether the CGL pipeline can be used for a given GraphicsConfig
121  * provided its screen number and visual ID.  If the minimum requirements are
122  * met, the native CGLGraphicsConfigInfo structure is initialized for this
123  * GraphicsConfig with the necessary information (pixel format, etc.)
124  * and a pointer to this structure is returned as a jlong.  If
125  * initialization fails at any point, zero is returned, indicating that CGL
126  * cannot be used for this GraphicsConfig (we should fallback on an existing
127  * 2D pipeline).
128  */
129 JNIEXPORT jlong JNICALL
130 Java_sun_java2d_metal_MTLGraphicsConfig_getMTLConfigInfo
131     (JNIEnv *env, jclass cglgc, jint displayID, jstring mtlShadersLib)
132 {
133   jlong ret = 0L;
134   JNF_COCOA_ENTER(env);
135   NSMutableArray * retArray = [NSMutableArray arrayWithCapacity:3];
136   [retArray addObject: [NSNumber numberWithInt: (int)displayID]];
137   [retArray addObject: [NSString stringWithUTF8String: JNU_GetStringPlatformChars(env, mtlShadersLib, 0)]];
138   if ([NSThread isMainThread]) {
139       [MTLGraphicsConfigUtil _getMTLConfigInfo: retArray];
140   } else {
141       [MTLGraphicsConfigUtil performSelectorOnMainThread: @selector(_getMTLConfigInfo:) withObject: retArray waitUntilDone: YES];
142   }
143   NSNumber * num = (NSNumber *)[retArray objectAtIndex: 0];
144   ret = (jlong)[num longValue];
145   JNF_COCOA_EXIT(env);
146   return ret;
147 }
148 
149 
150 
151 
152 @implementation MTLGraphicsConfigUtil
153 + (void) _getMTLConfigInfo: (NSMutableArray *)argValue {
154     AWT_ASSERT_APPKIT_THREAD;
155 
156     jint displayID = (jint)[(NSNumber *)[argValue objectAtIndex: 0] intValue];
157     NSString *mtlShadersLib = (NSString *)[argValue objectAtIndex: 1];
158     JNIEnv *env = [ThreadUtilities getJNIEnvUncached];
159     [argValue removeAllObjects];
160 
161     J2dRlsTraceLn(J2D_TRACE_INFO, &quot;MTLGraphicsConfig_getMTLConfigInfo&quot;);
162 
163     NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];
164 
165 
166     NSRect contentRect = NSMakeRect(0, 0, 64, 64);
167     NSWindow *window =
168         [[NSWindow alloc]
169             initWithContentRect: contentRect
170             styleMask: NSBorderlessWindowMask
171             backing: NSBackingStoreBuffered
172             defer: false];
173     if (window == nil) {
174         J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;MTLGraphicsConfig_getMTLConfigInfo: NSWindow is NULL&quot;);
175         [argValue addObject: [NSNumber numberWithLong: 0L]];
176         return;
177     }
178 
179     NSView *scratchSurface =
180         [[NSView alloc]
181             initWithFrame: contentRect];
182     if (scratchSurface == nil) {
183         J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;MTLGraphicsConfig_getMTLConfigInfo: NSView is NULL&quot;);
184         [argValue addObject: [NSNumber numberWithLong: 0L]];
185         return;
186     }
187     [window setContentView: scratchSurface];
188 
189     MTLContext *mtlc = [[MTLContext alloc] initWithDevice:CGDirectDisplayCopyCurrentMetalDevice(displayID)
190                         shadersLib:mtlShadersLib];
191     if (mtlc == 0L) {
192         J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;MTLGC_InitMTLContext: could not allocate memory for mtlc&quot;);
193         [argValue addObject: [NSNumber numberWithLong: 0L]];
194         return;
195     }
196 
197 
198     // create the MTLGraphicsConfigInfo record for this config
199     MTLGraphicsConfigInfo *mtlinfo = (MTLGraphicsConfigInfo *)malloc(sizeof(MTLGraphicsConfigInfo));
200     if (mtlinfo == NULL) {
201         J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;MTLGraphicsConfig_getMTLConfigInfo: could not allocate memory for mtlinfo&quot;);
202         free(mtlc);
203         [argValue addObject: [NSNumber numberWithLong: 0L]];
204         return;
205     }
206     memset(mtlinfo, 0, sizeof(MTLGraphicsConfigInfo));
207     mtlinfo-&gt;screen = displayID;
208     mtlinfo-&gt;context = mtlc;
209 
210     [argValue addObject: [NSNumber numberWithLong:ptr_to_jlong(mtlinfo)]];
211     [pool drain];
212 }
213 @end //GraphicsConfigUtil
214 
215 
216 JNIEXPORT jint JNICALL
217 Java_sun_java2d_metal_MTLGraphicsConfig_nativeGetMaxTextureSize
218     (JNIEnv *env, jclass mtlgc)
219 {
220     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLGraphicsConfig_nativeGetMaxTextureSize&quot;);
221 
222     __block int max = 0;
223 
224 //    [ThreadUtilities performOnMainThreadWaiting:YES block:^(){
225 //    }];
226 
227     return (jint)max;
228 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/macosx/classes/sun/java2d/metal/MTLBlitLoops.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.java2d.metal;
 27 
 28 import sun.java2d.SurfaceData;
 29 import sun.java2d.loops.*;
 30 import sun.java2d.pipe.Region;
 31 import sun.java2d.pipe.RenderBuffer;
 32 import sun.java2d.pipe.RenderQueue;
 33 import sun.java2d.pipe.hw.AccelSurface;
 34 
 35 import java.awt.*;
 36 import java.awt.geom.AffineTransform;
 37 import java.awt.image.AffineTransformOp;
 38 import java.awt.image.BufferedImage;
 39 import java.awt.image.BufferedImageOp;
 40 import java.lang.annotation.Native;
 41 import java.lang.ref.WeakReference;
 42 
 43 import static sun.java2d.pipe.BufferedOpCodes.BLIT;
 44 import static sun.java2d.pipe.BufferedOpCodes.SURFACE_TO_SW_BLIT;
 45 
 46 final class MTLBlitLoops {
 47 
 48     static void register() {
 49         Blit blitIntArgbPreToSurface =
 50                 new MTLSwToSurfaceBlit(SurfaceType.IntArgbPre,
 51                         MTLSurfaceData.PF_INT_ARGB_PRE);
 52         Blit blitIntArgbPreToTexture =
 53                 new MTLSwToTextureBlit(SurfaceType.IntArgbPre,
 54                         MTLSurfaceData.PF_INT_ARGB_PRE);
 55         TransformBlit transformBlitIntArgbPreToSurface =
 56                 new MTLSwToSurfaceTransform(SurfaceType.IntArgbPre,
 57                         MTLSurfaceData.PF_INT_ARGB_PRE);
 58         MTLSurfaceToSwBlit blitSurfaceToIntArgbPre =
 59                 new MTLSurfaceToSwBlit(SurfaceType.IntArgbPre,
 60                         MTLSurfaceData.PF_INT_ARGB_PRE);
 61 
 62         GraphicsPrimitive[] primitives = {
 63                 // surface-&gt;surface ops
 64                 new MTLSurfaceToSurfaceBlit(),
 65                 new MTLSurfaceToSurfaceScale(),
 66                 new MTLSurfaceToSurfaceTransform(),
 67 
 68                 // render-to-texture surface-&gt;surface ops
 69                 new MTLRTTSurfaceToSurfaceBlit(),
 70                 new MTLRTTSurfaceToSurfaceScale(),
 71                 new MTLRTTSurfaceToSurfaceTransform(),
 72 
 73                 // surface-&gt;sw ops
 74                 new MTLSurfaceToSwBlit(SurfaceType.IntArgb,
 75                         MTLSurfaceData.PF_INT_ARGB),
 76                 blitSurfaceToIntArgbPre,
 77 
 78                 // sw-&gt;surface ops
 79                 blitIntArgbPreToSurface,
 80                 new MTLSwToSurfaceBlit(SurfaceType.IntRgb,
 81                         MTLSurfaceData.PF_INT_RGB),
 82                 new MTLSwToSurfaceBlit(SurfaceType.IntRgbx,
 83                         MTLSurfaceData.PF_INT_RGBX),
 84                 new MTLSwToSurfaceBlit(SurfaceType.IntBgr,
 85                         MTLSurfaceData.PF_INT_BGR),
 86                 new MTLSwToSurfaceBlit(SurfaceType.IntBgrx,
 87                         MTLSurfaceData.PF_INT_BGRX),
<a name="1" id="anc1"></a><span class="line-modified"> 88 // TODO: Provide native implementation</span>
<span class="line-modified"> 89 // It may not be effective/possible. For example, there is no direct</span>
<span class="line-modified"> 90 // support in Metal for SurfaceType.ThreeByteBgr</span>
<span class="line-modified"> 91 //                new MTLSwToSurfaceBlit(SurfaceType.ThreeByteBgr,</span>
<span class="line-modified"> 92 //                        MTLSurfaceData.PF_3BYTE_BGR),</span>
<span class="line-modified"> 93 //                new MTLSwToSurfaceBlit(SurfaceType.Ushort565Rgb,</span>
<span class="line-modified"> 94 //                        MTLSurfaceData.PF_USHORT_565_RGB),</span>
<span class="line-modified"> 95 //                new MTLSwToSurfaceBlit(SurfaceType.Ushort555Rgb,</span>
<span class="line-modified"> 96 //                        MTLSurfaceData.PF_USHORT_555_RGB),</span>
<span class="line-modified"> 97 //                new MTLSwToSurfaceBlit(SurfaceType.Ushort555Rgbx,</span>
<span class="line-modified"> 98 //                        MTLSurfaceData.PF_USHORT_555_RGBX),</span>
<span class="line-modified"> 99 //                 new MTLSwToSurfaceBlit(SurfaceType.ByteGray,</span>
<span class="line-added">100 //                         MTLSurfaceData.PF_BYTE_GRAY),</span>
<span class="line-added">101 //                 new MTLSwToSurfaceBlit(SurfaceType.UshortGray,</span>
<span class="line-added">102 //                         MTLSurfaceData.PF_USHORT_GRAY),</span>
103                 new MTLGeneralBlit(MTLSurfaceData.MTLSurface,
104                         CompositeType.AnyAlpha,
105                         blitIntArgbPreToSurface),
106 
107                 new MTLAnyCompositeBlit(MTLSurfaceData.MTLSurface,
108                         blitSurfaceToIntArgbPre,
109                         blitSurfaceToIntArgbPre,
110                         blitIntArgbPreToSurface),
111                 new MTLAnyCompositeBlit(SurfaceType.Any,
112                         null,
113                         blitSurfaceToIntArgbPre,
114                         blitIntArgbPreToSurface),
115 
116                 new MTLSwToSurfaceScale(SurfaceType.IntRgb,
117                         MTLSurfaceData.PF_INT_RGB),
118                 new MTLSwToSurfaceScale(SurfaceType.IntRgbx,
119                         MTLSurfaceData.PF_INT_RGBX),
120                 new MTLSwToSurfaceScale(SurfaceType.IntBgr,
121                         MTLSurfaceData.PF_INT_BGR),
122                 new MTLSwToSurfaceScale(SurfaceType.IntBgrx,
123                         MTLSurfaceData.PF_INT_BGRX),
<a name="2" id="anc2"></a><span class="line-modified">124 // TODO: Provide native implementation</span>
<span class="line-modified">125 //                new MTLSwToSurfaceScale(SurfaceType.ThreeByteBgr,</span>
<span class="line-modified">126 //                        MTLSurfaceData.PF_3BYTE_BGR),</span>
<span class="line-modified">127 //                new MTLSwToSurfaceScale(SurfaceType.Ushort565Rgb,</span>
<span class="line-modified">128 //                        MTLSurfaceData.PF_USHORT_565_RGB),</span>
<span class="line-modified">129 //                new MTLSwToSurfaceScale(SurfaceType.Ushort555Rgb,</span>
<span class="line-modified">130 //                        MTLSurfaceData.PF_USHORT_555_RGB),</span>
<span class="line-modified">131 //                new MTLSwToSurfaceScale(SurfaceType.Ushort555Rgbx,</span>
<span class="line-modified">132 //                        MTLSurfaceData.PF_USHORT_555_RGBX),</span>
<span class="line-modified">133 //                 new MTLSwToSurfaceScale(SurfaceType.ByteGray,</span>
<span class="line-modified">134 //                         MTLSurfaceData.PF_BYTE_GRAY),</span>
<span class="line-modified">135 //                 new MTLSwToSurfaceScale(SurfaceType.UshortGray,</span>
<span class="line-added">136 //                         MTLSurfaceData.PF_USHORT_GRAY),</span>
137                 new MTLSwToSurfaceScale(SurfaceType.IntArgbPre,
138                         MTLSurfaceData.PF_INT_ARGB_PRE),
139 
140                 new MTLSwToSurfaceTransform(SurfaceType.IntRgb,
141                         MTLSurfaceData.PF_INT_RGB),
142                 new MTLSwToSurfaceTransform(SurfaceType.IntRgbx,
143                         MTLSurfaceData.PF_INT_RGBX),
144                 new MTLSwToSurfaceTransform(SurfaceType.IntBgr,
145                         MTLSurfaceData.PF_INT_BGR),
146                 new MTLSwToSurfaceTransform(SurfaceType.IntBgrx,
147                         MTLSurfaceData.PF_INT_BGRX),
<a name="3" id="anc3"></a><span class="line-modified">148 // TODO: Provide native implementation</span>
<span class="line-modified">149 //                new MTLSwToSurfaceTransform(SurfaceType.ThreeByteBgr,</span>
<span class="line-modified">150 //                        MTLSurfaceData.PF_3BYTE_BGR),</span>
<span class="line-modified">151 //                new MTLSwToSurfaceTransform(SurfaceType.Ushort565Rgb,</span>
<span class="line-modified">152 //                        MTLSurfaceData.PF_USHORT_565_RGB),</span>
<span class="line-modified">153 //                new MTLSwToSurfaceTransform(SurfaceType.Ushort555Rgb,</span>
<span class="line-modified">154 //                        MTLSurfaceData.PF_USHORT_555_RGB),</span>
<span class="line-modified">155 //                new MTLSwToSurfaceTransform(SurfaceType.Ushort555Rgbx,</span>
<span class="line-modified">156 //                        MTLSurfaceData.PF_USHORT_555_RGBX),</span>
<span class="line-modified">157 //                 new MTLSwToSurfaceTransform(SurfaceType.ByteGray,</span>
<span class="line-modified">158 //                         MTLSurfaceData.PF_BYTE_GRAY),</span>
<span class="line-modified">159 //                 new MTLSwToSurfaceTransform(SurfaceType.UshortGray,</span>
<span class="line-added">160 //                         MTLSurfaceData.PF_USHORT_GRAY),</span>
161                 transformBlitIntArgbPreToSurface,
162 
163                 new MTLGeneralTransformedBlit(transformBlitIntArgbPreToSurface),
164 
165                 // texture-&gt;surface ops
166                 new MTLTextureToSurfaceBlit(),
167                 new MTLTextureToSurfaceScale(),
168                 new MTLTextureToSurfaceTransform(),
169 
170                 // sw-&gt;texture ops
171                 blitIntArgbPreToTexture,
172                 new MTLSwToTextureBlit(SurfaceType.IntRgb,
173                         MTLSurfaceData.PF_INT_RGB),
174                 new MTLSwToTextureBlit(SurfaceType.IntRgbx,
175                         MTLSurfaceData.PF_INT_RGBX),
176                 new MTLSwToTextureBlit(SurfaceType.IntBgr,
177                         MTLSurfaceData.PF_INT_BGR),
178                 new MTLSwToTextureBlit(SurfaceType.IntBgrx,
179                         MTLSurfaceData.PF_INT_BGRX),
<a name="4" id="anc4"></a><span class="line-modified">180 // TODO: Provide native implementation</span>
<span class="line-modified">181 //                new MTLSwToTextureBlit(SurfaceType.ThreeByteBgr,</span>
<span class="line-modified">182 //                        MTLSurfaceData.PF_3BYTE_BGR),</span>
<span class="line-modified">183 //                new MTLSwToTextureBlit(SurfaceType.Ushort565Rgb,</span>
<span class="line-modified">184 //                        MTLSurfaceData.PF_USHORT_565_RGB),</span>
<span class="line-modified">185 //                new MTLSwToTextureBlit(SurfaceType.Ushort555Rgb,</span>
<span class="line-modified">186 //                        MTLSurfaceData.PF_USHORT_555_RGB),</span>
<span class="line-modified">187 //                new MTLSwToTextureBlit(SurfaceType.Ushort555Rgbx,</span>
<span class="line-modified">188 //                        MTLSurfaceData.PF_USHORT_555_RGBX),</span>
<span class="line-modified">189 //                 new MTLSwToTextureBlit(SurfaceType.ByteGray,</span>
<span class="line-modified">190 //                         MTLSurfaceData.PF_BYTE_GRAY),</span>
<span class="line-modified">191 //                 new MTLSwToTextureBlit(SurfaceType.UshortGray,</span>
<span class="line-added">192 //                         MTLSurfaceData.PF_USHORT_GRAY),</span>
193                 new MTLGeneralBlit(MTLSurfaceData.MTLTexture,
194                         CompositeType.SrcNoEa,
195                         blitIntArgbPreToTexture),
196         };
197         GraphicsPrimitiveMgr.register(primitives);
198     }
199 
200     /**
201      * The following offsets are used to pack the parameters in
202      * createPackedParams().  (They are also used at the native level when
203      * unpacking the params.)
204      */
205     @Native private static final int OFFSET_SRCTYPE = 16;
206     @Native private static final int OFFSET_HINT    =  8;
207     @Native private static final int OFFSET_TEXTURE =  3;
208     @Native private static final int OFFSET_RTT     =  2;
209     @Native private static final int OFFSET_XFORM   =  1;
210     @Native private static final int OFFSET_ISOBLIT =  0;
211 
212     /**
213      * Packs the given parameters into a single int value in order to save
214      * space on the rendering queue.
215      */
216     private static int createPackedParams(boolean isoblit, boolean texture,
217                                           boolean rtt, boolean xform,
218                                           int hint, int srctype)
219     {
220         return
221                 ((srctype           &lt;&lt; OFFSET_SRCTYPE) |
222                         (hint              &lt;&lt; OFFSET_HINT   ) |
223                         ((texture ? 1 : 0) &lt;&lt; OFFSET_TEXTURE) |
224                         ((rtt     ? 1 : 0) &lt;&lt; OFFSET_RTT    ) |
225                         ((xform   ? 1 : 0) &lt;&lt; OFFSET_XFORM  ) |
226                         ((isoblit ? 1 : 0) &lt;&lt; OFFSET_ISOBLIT));
227     }
228 
229     /**
230      * Enqueues a BLIT operation with the given parameters.  Note that the
231      * RenderQueue lock must be held before calling this method.
232      */
233     private static void enqueueBlit(RenderQueue rq,
234                                     SurfaceData src, SurfaceData dst,
235                                     int packedParams,
236                                     int sx1, int sy1,
237                                     int sx2, int sy2,
238                                     double dx1, double dy1,
239                                     double dx2, double dy2)
240     {
241         // assert rq.lock.isHeldByCurrentThread();
242         RenderBuffer buf = rq.getBuffer();
243         rq.ensureCapacityAndAlignment(72, 24);
244         buf.putInt(BLIT);
245         buf.putInt(packedParams);
246         buf.putInt(sx1).putInt(sy1);
247         buf.putInt(sx2).putInt(sy2);
248         buf.putDouble(dx1).putDouble(dy1);
249         buf.putDouble(dx2).putDouble(dy2);
250         buf.putLong(src.getNativeOps());
251         buf.putLong(dst.getNativeOps());
252     }
253 
254     static void Blit(SurfaceData srcData, SurfaceData dstData,
255                      Composite comp, Region clip,
256                      AffineTransform xform, int hint,
257                      int sx1, int sy1,
258                      int sx2, int sy2,
259                      double dx1, double dy1,
260                      double dx2, double dy2,
261                      int srctype, boolean texture)
262     {
263         int ctxflags = 0;
264         if (srcData.getTransparency() == Transparency.OPAQUE) {
265             ctxflags |= MTLContext.SRC_IS_OPAQUE;
266         }
267 
268         MTLRenderQueue rq = MTLRenderQueue.getInstance();
269         rq.lock();
270         try {
271             // make sure the RenderQueue keeps a hard reference to the
272             // source (sysmem) SurfaceData to prevent it from being
273             // disposed while the operation is processed on the QFT
274             rq.addReference(srcData);
275 
276             MTLSurfaceData oglDst = (MTLSurfaceData)dstData;
277             if (texture) {
278                 // make sure we have a current context before uploading
279                 // the sysmem data to the texture object
280                 MTLGraphicsConfig gc = oglDst.getMTLGraphicsConfig();
281                 MTLContext.setScratchSurface(gc);
282             } else {
283                 MTLContext.validateContext(oglDst, oglDst,
284                         clip, comp, xform, null, null,
285                         ctxflags);
286             }
287 
288             int packedParams = createPackedParams(false, texture,
289                     false /*unused*/, xform != null,
290                     hint, srctype);
291             enqueueBlit(rq, srcData, dstData,
292                     packedParams,
293                     sx1, sy1, sx2, sy2,
294                     dx1, dy1, dx2, dy2);
295 
296             // always flush immediately, since we (currently) have no means
297             // of tracking changes to the system memory surface
298             rq.flushNow();
299         } finally {
300             rq.unlock();
301         }
302     }
303 
304     /**
305      * Note: The srcImg and biop parameters are only used when invoked
306      * from the MTLBufImgOps.renderImageWithOp() method; in all other cases,
307      * this method can be called with null values for those two parameters,
308      * and they will be effectively ignored.
309      */
310     static void IsoBlit(SurfaceData srcData, SurfaceData dstData,
311                         BufferedImage srcImg, BufferedImageOp biop,
312                         Composite comp, Region clip,
313                         AffineTransform xform, int hint,
314                         int sx1, int sy1,
315                         int sx2, int sy2,
316                         double dx1, double dy1,
317                         double dx2, double dy2,
318                         boolean texture)
319     {
320         int ctxflags = 0;
321         if (srcData.getTransparency() == Transparency.OPAQUE) {
322             ctxflags |= MTLContext.SRC_IS_OPAQUE;
323         }
324 
325         MTLRenderQueue rq = MTLRenderQueue.getInstance();
326         rq.lock();
327         try {
328             MTLSurfaceData oglSrc = (MTLSurfaceData)srcData;
329             MTLSurfaceData oglDst = (MTLSurfaceData)dstData;
330             int srctype = oglSrc.getType();
331             boolean rtt;
332             MTLSurfaceData srcCtxData;
333             if (srctype == MTLSurfaceData.TEXTURE) {
334                 // the source is a regular texture object; we substitute
335                 // the destination surface for the purposes of making a
336                 // context current
337                 rtt = false;
338                 srcCtxData = oglDst;
339             } else {
340                 // the source is a pbuffer, backbuffer, or render-to-texture
341                 // surface; we set rtt to true to differentiate this kind
342                 // of surface from a regular texture object
343                 rtt = true;
344                 if (srctype == AccelSurface.RT_TEXTURE) {
345                     srcCtxData = oglDst;
346                 } else {
347                     srcCtxData = oglSrc;
348                 }
349             }
350 
351             MTLContext.validateContext(srcCtxData, oglDst,
352                     clip, comp, xform, null, null,
353                     ctxflags);
354 
355             if (biop != null) {
356                 MTLBufImgOps.enableBufImgOp(rq, oglSrc, srcImg, biop);
357             }
358 
359             int packedParams = createPackedParams(true, texture,
360                     false /*unused*/, xform != null,
361                     hint, 0 /*unused*/);
362             enqueueBlit(rq, srcData, dstData,
363                     packedParams,
364                     sx1, sy1, sx2, sy2,
365                     dx1, dy1, dx2, dy2);
366 
367             if (biop != null) {
368                 MTLBufImgOps.disableBufImgOp(rq, biop);
369             }
370 
371             if (rtt &amp;&amp; oglDst.isOnScreen()) {
372                 // we only have to flush immediately when copying from a
373                 // (non-texture) surface to the screen; otherwise Swing apps
374                 // might appear unresponsive until the auto-flush completes
375                 rq.flushNow();
376             }
377         } finally {
378             rq.unlock();
379         }
380     }
381 }
382 
383 class MTLSurfaceToSurfaceBlit extends Blit {
384 
385     MTLSurfaceToSurfaceBlit() {
386         super(MTLSurfaceData.MTLSurface,
387                 CompositeType.AnyAlpha,
388                 MTLSurfaceData.MTLSurface);
389     }
390 
391     public void Blit(SurfaceData src, SurfaceData dst,
392                      Composite comp, Region clip,
393                      int sx, int sy, int dx, int dy, int w, int h)
394     {
395         MTLBlitLoops.IsoBlit(src, dst,
396                 null, null,
397                 comp, clip, null,
398                 AffineTransformOp.TYPE_NEAREST_NEIGHBOR,
399                 sx, sy, sx+w, sy+h,
400                 dx, dy, dx+w, dy+h,
401                 false);
402     }
403 }
404 
405 class MTLSurfaceToSurfaceScale extends ScaledBlit {
406 
407     MTLSurfaceToSurfaceScale() {
408         super(MTLSurfaceData.MTLSurface,
409                 CompositeType.AnyAlpha,
410                 MTLSurfaceData.MTLSurface);
411     }
412 
413     public void Scale(SurfaceData src, SurfaceData dst,
414                       Composite comp, Region clip,
415                       int sx1, int sy1,
416                       int sx2, int sy2,
417                       double dx1, double dy1,
418                       double dx2, double dy2)
419     {
420         MTLBlitLoops.IsoBlit(src, dst,
421                 null, null,
422                 comp, clip, null,
423                 AffineTransformOp.TYPE_NEAREST_NEIGHBOR,
424                 sx1, sy1, sx2, sy2,
425                 dx1, dy1, dx2, dy2,
426                 false);
427     }
428 }
429 
430 class MTLSurfaceToSurfaceTransform extends TransformBlit {
431 
432     MTLSurfaceToSurfaceTransform() {
433         super(MTLSurfaceData.MTLSurface,
434                 CompositeType.AnyAlpha,
435                 MTLSurfaceData.MTLSurface);
436     }
437 
438     public void Transform(SurfaceData src, SurfaceData dst,
439                           Composite comp, Region clip,
440                           AffineTransform at, int hint,
441                           int sx, int sy, int dx, int dy,
442                           int w, int h)
443     {
444         MTLBlitLoops.IsoBlit(src, dst,
445                 null, null,
446                 comp, clip, at, hint,
447                 sx, sy, sx+w, sy+h,
448                 dx, dy, dx+w, dy+h,
449                 false);
450     }
451 }
452 
453 class MTLRTTSurfaceToSurfaceBlit extends Blit {
454 
455     MTLRTTSurfaceToSurfaceBlit() {
456         super(MTLSurfaceData.MTLSurfaceRTT,
457                 CompositeType.AnyAlpha,
458                 MTLSurfaceData.MTLSurface);
459     }
460 
461     public void Blit(SurfaceData src, SurfaceData dst,
462                      Composite comp, Region clip,
463                      int sx, int sy, int dx, int dy, int w, int h)
464     {
465         MTLBlitLoops.IsoBlit(src, dst,
466                 null, null,
467                 comp, clip, null,
468                 AffineTransformOp.TYPE_NEAREST_NEIGHBOR,
469                 sx, sy, sx+w, sy+h,
470                 dx, dy, dx+w, dy+h,
471                 true);
472     }
473 }
474 
475 class MTLRTTSurfaceToSurfaceScale extends ScaledBlit {
476 
477     MTLRTTSurfaceToSurfaceScale() {
478         super(MTLSurfaceData.MTLSurfaceRTT,
479                 CompositeType.AnyAlpha,
480                 MTLSurfaceData.MTLSurface);
481     }
482 
483     public void Scale(SurfaceData src, SurfaceData dst,
484                       Composite comp, Region clip,
485                       int sx1, int sy1,
486                       int sx2, int sy2,
487                       double dx1, double dy1,
488                       double dx2, double dy2)
489     {
490         MTLBlitLoops.IsoBlit(src, dst,
491                 null, null,
492                 comp, clip, null,
493                 AffineTransformOp.TYPE_NEAREST_NEIGHBOR,
494                 sx1, sy1, sx2, sy2,
495                 dx1, dy1, dx2, dy2,
496                 true);
497     }
498 }
499 
500 class MTLRTTSurfaceToSurfaceTransform extends TransformBlit {
501 
502     MTLRTTSurfaceToSurfaceTransform() {
503         super(MTLSurfaceData.MTLSurfaceRTT,
504                 CompositeType.AnyAlpha,
505                 MTLSurfaceData.MTLSurface);
506     }
507 
508     public void Transform(SurfaceData src, SurfaceData dst,
509                           Composite comp, Region clip,
510                           AffineTransform at, int hint,
511                           int sx, int sy, int dx, int dy, int w, int h)
512     {
513         MTLBlitLoops.IsoBlit(src, dst,
514                 null, null,
515                 comp, clip, at, hint,
516                 sx, sy, sx+w, sy+h,
517                 dx, dy, dx+w, dy+h,
518                 true);
519     }
520 }
521 
522 final class MTLSurfaceToSwBlit extends Blit {
523 
524     private final int typeval;
525     private WeakReference&lt;SurfaceData&gt; srcTmp;
526 
527     // destination will actually be ArgbPre or Argb
528     MTLSurfaceToSwBlit(final SurfaceType dstType, final int typeval) {
529         super(MTLSurfaceData.MTLSurface,
530                 CompositeType.SrcNoEa,
531                 dstType);
532         this.typeval = typeval;
533     }
534 
535     private synchronized void complexClipBlit(SurfaceData src, SurfaceData dst,
536                                               Composite comp, Region clip,
537                                               int sx, int sy, int dx, int dy,
538                                               int w, int h) {
539         SurfaceData cachedSrc = null;
540         if (srcTmp != null) {
541             // use cached intermediate surface, if available
542             cachedSrc = srcTmp.get();
543         }
544 
545         // We can convert argb_pre data from MTL surface in two places:
546         // - During MTL surface -&gt; SW blit
547         // - During SW -&gt; SW blit
548         // The first one is faster when we use opaque MTL surface, because in
549         // this case we simply skip conversion and use color components as is.
550         // Because of this we align intermediate buffer type with type of
551         // destination not source.
552         final int type = typeval == MTLSurfaceData.PF_INT_ARGB_PRE ?
553                 BufferedImage.TYPE_INT_ARGB_PRE :
554                 BufferedImage.TYPE_INT_ARGB;
555 
556         src = convertFrom(this, src, sx, sy, w, h, cachedSrc, type);
557 
558         // copy intermediate SW to destination SW using complex clip
559         final Blit performop = Blit.getFromCache(src.getSurfaceType(),
560                 CompositeType.SrcNoEa,
561                 dst.getSurfaceType());
562         performop.Blit(src, dst, comp, clip, 0, 0, dx, dy, w, h);
563 
564         if (src != cachedSrc) {
565             // cache the intermediate surface
566             srcTmp = new WeakReference&lt;&gt;(src);
567         }
568     }
569 
570     public void Blit(SurfaceData src, SurfaceData dst,
571                      Composite comp, Region clip,
572                      int sx, int sy, int dx, int dy,
573                      int w, int h)
574     {
575         if (clip != null) {
576             clip = clip.getIntersectionXYWH(dx, dy, w, h);
577             // At the end this method will flush the RenderQueue, we should exit
578             // from it as soon as possible.
579             if (clip.isEmpty()) {
580                 return;
581             }
582             sx += clip.getLoX() - dx;
583             sy += clip.getLoY() - dy;
584             dx = clip.getLoX();
585             dy = clip.getLoY();
586             w = clip.getWidth();
587             h = clip.getHeight();
588 
589             if (!clip.isRectangular()) {
590                 complexClipBlit(src, dst, comp, clip, sx, sy, dx, dy, w, h);
591                 return;
592             }
593         }
594 
595         MTLRenderQueue rq = MTLRenderQueue.getInstance();
596         rq.lock();
597         try {
598             // make sure the RenderQueue keeps a hard reference to the
599             // destination (sysmem) SurfaceData to prevent it from being
600             // disposed while the operation is processed on the QFT
601             rq.addReference(dst);
602 
603             RenderBuffer buf = rq.getBuffer();
604             MTLContext.validateContext((MTLSurfaceData)src);
605 
606             rq.ensureCapacityAndAlignment(48, 32);
607             buf.putInt(SURFACE_TO_SW_BLIT);
608             buf.putInt(sx).putInt(sy);
609             buf.putInt(dx).putInt(dy);
610             buf.putInt(w).putInt(h);
611             buf.putInt(typeval);
612             buf.putLong(src.getNativeOps());
613             buf.putLong(dst.getNativeOps());
614 
615             // always flush immediately
616             rq.flushNow();
617         } finally {
618             rq.unlock();
619         }
620     }
621 }
622 
623 class MTLSwToSurfaceBlit extends Blit {
624 
625     private int typeval;
626 
627     MTLSwToSurfaceBlit(SurfaceType srcType, int typeval) {
628         super(srcType,
629                 CompositeType.AnyAlpha,
630                 MTLSurfaceData.MTLSurface);
631         this.typeval = typeval;
632     }
633 
634     public void Blit(SurfaceData src, SurfaceData dst,
635                      Composite comp, Region clip,
636                      int sx, int sy, int dx, int dy, int w, int h)
637     {
638         MTLBlitLoops.Blit(src, dst,
639                 comp, clip, null,
640                 AffineTransformOp.TYPE_NEAREST_NEIGHBOR,
641                 sx, sy, sx+w, sy+h,
642                 dx, dy, dx+w, dy+h,
643                 typeval, false);
644     }
645 }
646 
647 class MTLSwToSurfaceScale extends ScaledBlit {
648 
649     private int typeval;
650 
651     MTLSwToSurfaceScale(SurfaceType srcType, int typeval) {
652         super(srcType,
653                 CompositeType.AnyAlpha,
654                 MTLSurfaceData.MTLSurface);
655         this.typeval = typeval;
656     }
657 
658     public void Scale(SurfaceData src, SurfaceData dst,
659                       Composite comp, Region clip,
660                       int sx1, int sy1,
661                       int sx2, int sy2,
662                       double dx1, double dy1,
663                       double dx2, double dy2)
664     {
665         MTLBlitLoops.Blit(src, dst,
666                 comp, clip, null,
667                 AffineTransformOp.TYPE_NEAREST_NEIGHBOR,
668                 sx1, sy1, sx2, sy2,
669                 dx1, dy1, dx2, dy2,
670                 typeval, false);
671     }
672 }
673 
674 class MTLSwToSurfaceTransform extends TransformBlit {
675 
676     private int typeval;
677 
678     MTLSwToSurfaceTransform(SurfaceType srcType, int typeval) {
679         super(srcType,
680                 CompositeType.AnyAlpha,
681                 MTLSurfaceData.MTLSurface);
682         this.typeval = typeval;
683     }
684 
685     public void Transform(SurfaceData src, SurfaceData dst,
686                           Composite comp, Region clip,
687                           AffineTransform at, int hint,
688                           int sx, int sy, int dx, int dy, int w, int h)
689     {
690         MTLBlitLoops.Blit(src, dst,
691                 comp, clip, at, hint,
692                 sx, sy, sx+w, sy+h,
693                 dx, dy, dx+w, dy+h,
694                 typeval, false);
695     }
696 }
697 
698 class MTLSwToTextureBlit extends Blit {
699 
700     private int typeval;
701 
702     MTLSwToTextureBlit(SurfaceType srcType, int typeval) {
703         super(srcType,
704                 CompositeType.SrcNoEa,
705                 MTLSurfaceData.MTLTexture);
706         this.typeval = typeval;
707     }
708 
709     public void Blit(SurfaceData src, SurfaceData dst,
710                      Composite comp, Region clip,
711                      int sx, int sy, int dx, int dy, int w, int h)
712     {
713         MTLBlitLoops.Blit(src, dst,
714                 comp, clip, null,
715                 AffineTransformOp.TYPE_NEAREST_NEIGHBOR,
716                 sx, sy, sx+w, sy+h,
717                 dx, dy, dx+w, dy+h,
718                 typeval, true);
719     }
720 }
721 
722 class MTLTextureToSurfaceBlit extends Blit {
723 
724     MTLTextureToSurfaceBlit() {
725         super(MTLSurfaceData.MTLTexture,
726                 CompositeType.AnyAlpha,
727                 MTLSurfaceData.MTLSurface);
728     }
729 
730     public void Blit(SurfaceData src, SurfaceData dst,
731                      Composite comp, Region clip,
732                      int sx, int sy, int dx, int dy, int w, int h)
733     {
734         MTLBlitLoops.IsoBlit(src, dst,
735                 null, null,
736                 comp, clip, null,
737                 AffineTransformOp.TYPE_NEAREST_NEIGHBOR,
738                 sx, sy, sx+w, sy+h,
739                 dx, dy, dx+w, dy+h,
740                 true);
741     }
742 }
743 
744 class MTLTextureToSurfaceScale extends ScaledBlit {
745 
746     MTLTextureToSurfaceScale() {
747         super(MTLSurfaceData.MTLTexture,
748                 CompositeType.AnyAlpha,
749                 MTLSurfaceData.MTLSurface);
750     }
751 
752     public void Scale(SurfaceData src, SurfaceData dst,
753                       Composite comp, Region clip,
754                       int sx1, int sy1,
755                       int sx2, int sy2,
756                       double dx1, double dy1,
757                       double dx2, double dy2)
758     {
759         MTLBlitLoops.IsoBlit(src, dst,
760                 null, null,
761                 comp, clip, null,
762                 AffineTransformOp.TYPE_NEAREST_NEIGHBOR,
763                 sx1, sy1, sx2, sy2,
764                 dx1, dy1, dx2, dy2,
765                 true);
766     }
767 }
768 
769 class MTLTextureToSurfaceTransform extends TransformBlit {
770 
771     MTLTextureToSurfaceTransform() {
772         super(MTLSurfaceData.MTLTexture,
773                 CompositeType.AnyAlpha,
774                 MTLSurfaceData.MTLSurface);
775     }
776 
777     public void Transform(SurfaceData src, SurfaceData dst,
778                           Composite comp, Region clip,
779                           AffineTransform at, int hint,
780                           int sx, int sy, int dx, int dy,
781                           int w, int h)
782     {
783         MTLBlitLoops.IsoBlit(src, dst,
784                 null, null,
785                 comp, clip, at, hint,
786                 sx, sy, sx+w, sy+h,
787                 dx, dy, dx+w, dy+h,
788                 true);
789     }
790 }
791 
792 /**
793  * This general Blit implementation converts any source surface to an
794  * intermediate IntArgbPre surface, and then uses the more specific
795  * IntArgbPre-&gt;MTLSurface/Texture loop to get the intermediate
796  * (premultiplied) surface down to OpenGL using simple blit.
797  */
798 class MTLGeneralBlit extends Blit {
799 
800     private final Blit performop;
801     private WeakReference&lt;SurfaceData&gt; srcTmp;
802 
803     MTLGeneralBlit(SurfaceType dstType,
804                    CompositeType compType,
805                    Blit performop)
806     {
807         super(SurfaceType.Any, compType, dstType);
808         this.performop = performop;
809     }
810 
811     public synchronized void Blit(SurfaceData src, SurfaceData dst,
812                                   Composite comp, Region clip,
813                                   int sx, int sy, int dx, int dy,
814                                   int w, int h)
815     {
816         Blit convertsrc = Blit.getFromCache(src.getSurfaceType(),
817                 CompositeType.SrcNoEa,
818                 SurfaceType.IntArgbPre);
819 
820         SurfaceData cachedSrc = null;
821         if (srcTmp != null) {
822             // use cached intermediate surface, if available
823             cachedSrc = srcTmp.get();
824         }
825 
826         // convert source to IntArgbPre
827         src = convertFrom(convertsrc, src, sx, sy, w, h,
828                 cachedSrc, BufferedImage.TYPE_INT_ARGB_PRE);
829 
830         // copy IntArgbPre intermediate surface to OpenGL surface
831         performop.Blit(src, dst, comp, clip,
832                 0, 0, dx, dy, w, h);
833 
834         if (src != cachedSrc) {
835             // cache the intermediate surface
836             srcTmp = new WeakReference&lt;&gt;(src);
837         }
838     }
839 }
840 
841 /**
842  * This general TransformedBlit implementation converts any source surface to an
843  * intermediate IntArgbPre surface, and then uses the more specific
844  * IntArgbPre-&gt;MTLSurface/Texture loop to get the intermediate
845  * (premultiplied) surface down to OpenGL using simple transformBlit.
846  */
847 final class MTLGeneralTransformedBlit extends TransformBlit {
848 
849     private final TransformBlit performop;
850     private WeakReference&lt;SurfaceData&gt; srcTmp;
851 
852     MTLGeneralTransformedBlit(final TransformBlit performop) {
853         super(SurfaceType.Any, CompositeType.AnyAlpha,
854                 MTLSurfaceData.MTLSurface);
855         this.performop = performop;
856     }
857 
858     @Override
859     public synchronized void Transform(SurfaceData src, SurfaceData dst,
860                                        Composite comp, Region clip,
861                                        AffineTransform at, int hint, int srcx,
862                                        int srcy, int dstx, int dsty, int width,
863                                        int height){
864         Blit convertsrc = Blit.getFromCache(src.getSurfaceType(),
865                 CompositeType.SrcNoEa,
866                 SurfaceType.IntArgbPre);
867         // use cached intermediate surface, if available
868         final SurfaceData cachedSrc = srcTmp != null ? srcTmp.get() : null;
869         // convert source to IntArgbPre
870         src = convertFrom(convertsrc, src, srcx, srcy, width, height, cachedSrc,
871                 BufferedImage.TYPE_INT_ARGB_PRE);
872 
873         // transform IntArgbPre intermediate surface to OpenGL surface
874         performop.Transform(src, dst, comp, clip, at, hint, 0, 0, dstx, dsty,
875                 width, height);
876 
877         if (src != cachedSrc) {
878             // cache the intermediate surface
879             srcTmp = new WeakReference&lt;&gt;(src);
880         }
881     }
882 }
883 
884 /**
885  * This general MTLAnyCompositeBlit implementation can convert any source/target
886  * surface to an intermediate surface using convertsrc/convertdst loops, applies
887  * necessary composite operation, and then uses convertresult loop to get the
888  * intermediate surface down to OpenGL.
889  */
890 final class MTLAnyCompositeBlit extends Blit {
891 
892     private WeakReference&lt;SurfaceData&gt; dstTmp;
893     private WeakReference&lt;SurfaceData&gt; srcTmp;
894     private final Blit convertsrc;
895     private final Blit convertdst;
896     private final Blit convertresult;
897 
898     MTLAnyCompositeBlit(SurfaceType srctype, Blit convertsrc, Blit convertdst,
899                         Blit convertresult) {
900         super(srctype, CompositeType.Any, MTLSurfaceData.MTLSurface);
901         this.convertsrc = convertsrc;
902         this.convertdst = convertdst;
903         this.convertresult = convertresult;
904     }
905 
906     public synchronized void Blit(SurfaceData src, SurfaceData dst,
907                                   Composite comp, Region clip,
908                                   int sx, int sy, int dx, int dy,
909                                   int w, int h)
910     {
911         if (convertsrc != null) {
912             SurfaceData cachedSrc = null;
913             if (srcTmp != null) {
914                 // use cached intermediate surface, if available
915                 cachedSrc = srcTmp.get();
916             }
917             // convert source to IntArgbPre
918             src = convertFrom(convertsrc, src, sx, sy, w, h, cachedSrc,
919                     BufferedImage.TYPE_INT_ARGB_PRE);
920             if (src != cachedSrc) {
921                 // cache the intermediate surface
922                 srcTmp = new WeakReference&lt;&gt;(src);
923             }
924         }
925 
926         SurfaceData cachedDst = null;
927 
928         if (dstTmp != null) {
929             // use cached intermediate surface, if available
930             cachedDst = dstTmp.get();
931         }
932 
933         // convert destination to IntArgbPre
934         SurfaceData dstBuffer = convertFrom(convertdst, dst, dx, dy, w, h,
935                 cachedDst, BufferedImage.TYPE_INT_ARGB_PRE);
936         Region bufferClip =
937                 clip == null ? null : clip.getTranslatedRegion(-dx, -dy);
938 
939         Blit performop = Blit.getFromCache(src.getSurfaceType(),
940                 CompositeType.Any, dstBuffer.getSurfaceType());
941         performop.Blit(src, dstBuffer, comp, bufferClip, sx, sy, 0, 0, w, h);
942 
943         if (dstBuffer != cachedDst) {
944             // cache the intermediate surface
945             dstTmp = new WeakReference&lt;&gt;(dstBuffer);
946         }
947         // now blit the buffer back to the destination
948         convertresult.Blit(dstBuffer, dst, AlphaComposite.Src, clip, 0, 0, dx,
949                 dy, w, h);
950     }
951 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLTextRenderer.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLTextRenderer.m</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
508     id&lt;MTLTexture&gt; blitTexture = nil;
509 
510     id&lt;MTLRenderCommandEncoder&gt; encoder = nil;
511 
512     MTLTextureDescriptor *textureDescriptor =
513         [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatBGRA8Unorm
514                                                             width:w
515                                                             height:h
516                                                             mipmapped:NO];
517 
518     blitTexture = [mtlc.device newTextureWithDescriptor:textureDescriptor];
519     [textureDescriptor release];
520 
521     if (glyphMode != MODE_USE_CACHE_LCD) {
522         if (glyphMode == MODE_NO_CACHE_GRAY) {
523             MTLVertexCache_DisableMaskCache(mtlc);
524         } else if (glyphMode == MODE_USE_CACHE_GRAY) {
525             MTLTR_DisableGlyphVertexCache(mtlc);
526         }
527 
<span class="line-modified">528         if (glyphCacheLCD == NULL) {</span>
529             if (!MTLTR_InitGlyphCache(mtlc, JNI_TRUE)) {
530                 return JNI_FALSE;
531             }
532         }
533 
534         if (rgbOrder != lastRGBOrder) {
535             // need to invalidate the cache in this case; see comments
536             // for lastRGBOrder above
537             MTLGlyphCache_Invalidate(glyphCacheLCD);
538             lastRGBOrder = rgbOrder;
<span class="line-modified">539         }</span>
540 
541         glyphMode = MODE_USE_CACHE_LCD;
542     }
543 
<span class="line-modified">544     if (ginfo-&gt;cellInfo == NULL) {</span>
545         // attempt to add glyph to accelerated glyph cache
546         // TODO : Handle RGB order
547         MTLTR_AddToGlyphCache(ginfo, mtlc, MTLPixelFormatRGBA8Unorm);
548 
549         if (ginfo-&gt;cellInfo == NULL) {
550             // we&#39;ll just no-op in the rare case that the cell is NULL
551             return JNI_TRUE;
552         }
<span class="line-modified">553     }</span>
554     encoder = [mtlc.encoderManager getTextureEncoder:dstOps-&gt;pTexture isSrcOpaque:YES isDstOpaque:YES];
555     if (!MTLTR_EnableLCDGlyphModeState(encoder, mtlc, dstOps,contrast))
556     {
557         return JNI_FALSE;
558     }
559 
560 
561     unsigned int imageBytes = w * h *4;
562     unsigned char imageData[imageBytes];
563     memset(&amp;imageData, 0, sizeof(imageData));
564 
565     for (int i = 0; i &lt; h; i++) {
566         for (int j = 0; j &lt; w; j++) {
567             imageData[(i * w * 4) + j * 4] = ginfo-&gt;image[(i * w * 3) + j * 3];
568             imageData[(i * w * 4) + j * 4 + 1] = ginfo-&gt;image[(i * w * 3) + j * 3 + 1];
569             imageData[(i * w * 4) + j * 4 + 2] = ginfo-&gt;image[(i * w * 3) + j * 3 + 2];
570             imageData[(i * w * 4) + j * 4 + 3] = 0xFF;
571         }
572     }
573 
</pre>
<hr />
<pre>
911                 ok = MTLTR_DrawLCDGlyphViaCache(mtlc, dstOps,
912                                                 ginfo, x, y,
913                                                 glyphCounter, totalGlyphs,
914                                                 rgbOrder, lcdContrast,
915                                                 dstTexture);
916             } else {
917                 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList LCD no cache&quot;);
918                 ok = MTLTR_DrawLCDGlyphNoCache(mtlc, dstOps,
919                                                ginfo, x, y,
920                                                rowBytesOffset,
921                                                rgbOrder, lcdContrast,
922                                                dstTexture);
923             }
924         }
925 
926         if (!ok) {
927             break;
928         }
929     }
930     /*
<span class="line-modified">931      * This state management needs to be extended for other glyphmodes</span>
<span class="line-modified">932      * when they are implemented.</span>

933      */
<span class="line-modified">934     if (glyphMode != MODE_NO_CACHE_LCD) {</span>
<span class="line-modified">935         if (glyphMode == MODE_NO_CACHE_GRAY) {</span>
<span class="line-modified">936             MTLVertexCache_DisableMaskCache(mtlc);</span>
<span class="line-modified">937         } else {</span>
<span class="line-removed">938             MTLTR_DisableGlyphVertexCache(mtlc);</span>
<span class="line-removed">939         }</span>
940     }
941 }
942 
943 JNIEXPORT void JNICALL
944 Java_sun_java2d_metal_MTLTextRenderer_drawGlyphList
945     (JNIEnv *env, jobject self,
946      jint numGlyphs, jboolean usePositions,
947      jboolean subPixPos, jboolean rgbOrder, jint lcdContrast,
948      jfloat glyphListOrigX, jfloat glyphListOrigY,
949      jlongArray imgArray, jfloatArray posArray)
950 {
951     unsigned char *images;
952 
953     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTextRenderer_drawGlyphList&quot;);
954 
955     images = (unsigned char *)
956         (*env)-&gt;GetPrimitiveArrayCritical(env, imgArray, NULL);
957     if (images != NULL) {
958         MTLContext *mtlc = MTLRenderQueue_GetCurrentContext();
959         BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
</pre>
</td>
<td>
<hr />
<pre>
508     id&lt;MTLTexture&gt; blitTexture = nil;
509 
510     id&lt;MTLRenderCommandEncoder&gt; encoder = nil;
511 
512     MTLTextureDescriptor *textureDescriptor =
513         [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatBGRA8Unorm
514                                                             width:w
515                                                             height:h
516                                                             mipmapped:NO];
517 
518     blitTexture = [mtlc.device newTextureWithDescriptor:textureDescriptor];
519     [textureDescriptor release];
520 
521     if (glyphMode != MODE_USE_CACHE_LCD) {
522         if (glyphMode == MODE_NO_CACHE_GRAY) {
523             MTLVertexCache_DisableMaskCache(mtlc);
524         } else if (glyphMode == MODE_USE_CACHE_GRAY) {
525             MTLTR_DisableGlyphVertexCache(mtlc);
526         }
527 
<span class="line-modified">528         /*if (glyphCacheLCD == NULL) {</span>
529             if (!MTLTR_InitGlyphCache(mtlc, JNI_TRUE)) {
530                 return JNI_FALSE;
531             }
532         }
533 
534         if (rgbOrder != lastRGBOrder) {
535             // need to invalidate the cache in this case; see comments
536             // for lastRGBOrder above
537             MTLGlyphCache_Invalidate(glyphCacheLCD);
538             lastRGBOrder = rgbOrder;
<span class="line-modified">539         }*/</span>
540 
541         glyphMode = MODE_USE_CACHE_LCD;
542     }
543 
<span class="line-modified">544     /*if (ginfo-&gt;cellInfo == NULL) {</span>
545         // attempt to add glyph to accelerated glyph cache
546         // TODO : Handle RGB order
547         MTLTR_AddToGlyphCache(ginfo, mtlc, MTLPixelFormatRGBA8Unorm);
548 
549         if (ginfo-&gt;cellInfo == NULL) {
550             // we&#39;ll just no-op in the rare case that the cell is NULL
551             return JNI_TRUE;
552         }
<span class="line-modified">553     }*/</span>
554     encoder = [mtlc.encoderManager getTextureEncoder:dstOps-&gt;pTexture isSrcOpaque:YES isDstOpaque:YES];
555     if (!MTLTR_EnableLCDGlyphModeState(encoder, mtlc, dstOps,contrast))
556     {
557         return JNI_FALSE;
558     }
559 
560 
561     unsigned int imageBytes = w * h *4;
562     unsigned char imageData[imageBytes];
563     memset(&amp;imageData, 0, sizeof(imageData));
564 
565     for (int i = 0; i &lt; h; i++) {
566         for (int j = 0; j &lt; w; j++) {
567             imageData[(i * w * 4) + j * 4] = ginfo-&gt;image[(i * w * 3) + j * 3];
568             imageData[(i * w * 4) + j * 4 + 1] = ginfo-&gt;image[(i * w * 3) + j * 3 + 1];
569             imageData[(i * w * 4) + j * 4 + 2] = ginfo-&gt;image[(i * w * 3) + j * 3 + 2];
570             imageData[(i * w * 4) + j * 4 + 3] = 0xFF;
571         }
572     }
573 
</pre>
<hr />
<pre>
911                 ok = MTLTR_DrawLCDGlyphViaCache(mtlc, dstOps,
912                                                 ginfo, x, y,
913                                                 glyphCounter, totalGlyphs,
914                                                 rgbOrder, lcdContrast,
915                                                 dstTexture);
916             } else {
917                 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList LCD no cache&quot;);
918                 ok = MTLTR_DrawLCDGlyphNoCache(mtlc, dstOps,
919                                                ginfo, x, y,
920                                                rowBytesOffset,
921                                                rgbOrder, lcdContrast,
922                                                dstTexture);
923             }
924         }
925 
926         if (!ok) {
927             break;
928         }
929     }
930     /*
<span class="line-modified">931      * Only in case of grayscale text drawing we need to flush</span>
<span class="line-modified">932      * cache. Still in case of LCD we are not using any intermediate</span>
<span class="line-added">933      * cache.</span>
934      */
<span class="line-modified">935     if (glyphMode == MODE_NO_CACHE_GRAY) {</span>
<span class="line-modified">936         MTLVertexCache_DisableMaskCache(mtlc);</span>
<span class="line-modified">937     } else if (glyphMode == MODE_USE_CACHE_GRAY) {</span>
<span class="line-modified">938         MTLTR_DisableGlyphVertexCache(mtlc);</span>


939     }
940 }
941 
942 JNIEXPORT void JNICALL
943 Java_sun_java2d_metal_MTLTextRenderer_drawGlyphList
944     (JNIEnv *env, jobject self,
945      jint numGlyphs, jboolean usePositions,
946      jboolean subPixPos, jboolean rgbOrder, jint lcdContrast,
947      jfloat glyphListOrigX, jfloat glyphListOrigY,
948      jlongArray imgArray, jfloatArray posArray)
949 {
950     unsigned char *images;
951 
952     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTextRenderer_drawGlyphList&quot;);
953 
954     images = (unsigned char *)
955         (*env)-&gt;GetPrimitiveArrayCritical(env, imgArray, NULL);
956     if (images != NULL) {
957         MTLContext *mtlc = MTLRenderQueue_GetCurrentContext();
958         BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
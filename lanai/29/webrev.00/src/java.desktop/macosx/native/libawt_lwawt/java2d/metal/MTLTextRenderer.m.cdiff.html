<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLTextRenderer.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLTextRenderer.m</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 523,36 ***</span>
              MTLVertexCache_DisableMaskCache(mtlc);
          } else if (glyphMode == MODE_USE_CACHE_GRAY) {
              MTLTR_DisableGlyphVertexCache(mtlc);
          }
  
<span class="line-modified">!         if (glyphCacheLCD == NULL) {</span>
              if (!MTLTR_InitGlyphCache(mtlc, JNI_TRUE)) {
                  return JNI_FALSE;
              }
          }
  
          if (rgbOrder != lastRGBOrder) {
              // need to invalidate the cache in this case; see comments
              // for lastRGBOrder above
              MTLGlyphCache_Invalidate(glyphCacheLCD);
              lastRGBOrder = rgbOrder;
<span class="line-modified">!         }</span>
  
          glyphMode = MODE_USE_CACHE_LCD;
      }
  
<span class="line-modified">!     if (ginfo-&gt;cellInfo == NULL) {</span>
          // attempt to add glyph to accelerated glyph cache
          // TODO : Handle RGB order
          MTLTR_AddToGlyphCache(ginfo, mtlc, MTLPixelFormatRGBA8Unorm);
  
          if (ginfo-&gt;cellInfo == NULL) {
              // we&#39;ll just no-op in the rare case that the cell is NULL
              return JNI_TRUE;
          }
<span class="line-modified">!     }</span>
      encoder = [mtlc.encoderManager getTextureEncoder:dstOps-&gt;pTexture isSrcOpaque:YES isDstOpaque:YES];
      if (!MTLTR_EnableLCDGlyphModeState(encoder, mtlc, dstOps,contrast))
      {
          return JNI_FALSE;
      }
<span class="line-new-header">--- 523,36 ---</span>
              MTLVertexCache_DisableMaskCache(mtlc);
          } else if (glyphMode == MODE_USE_CACHE_GRAY) {
              MTLTR_DisableGlyphVertexCache(mtlc);
          }
  
<span class="line-modified">!         /*if (glyphCacheLCD == NULL) {</span>
              if (!MTLTR_InitGlyphCache(mtlc, JNI_TRUE)) {
                  return JNI_FALSE;
              }
          }
  
          if (rgbOrder != lastRGBOrder) {
              // need to invalidate the cache in this case; see comments
              // for lastRGBOrder above
              MTLGlyphCache_Invalidate(glyphCacheLCD);
              lastRGBOrder = rgbOrder;
<span class="line-modified">!         }*/</span>
  
          glyphMode = MODE_USE_CACHE_LCD;
      }
  
<span class="line-modified">!     /*if (ginfo-&gt;cellInfo == NULL) {</span>
          // attempt to add glyph to accelerated glyph cache
          // TODO : Handle RGB order
          MTLTR_AddToGlyphCache(ginfo, mtlc, MTLPixelFormatRGBA8Unorm);
  
          if (ginfo-&gt;cellInfo == NULL) {
              // we&#39;ll just no-op in the rare case that the cell is NULL
              return JNI_TRUE;
          }
<span class="line-modified">!     }*/</span>
      encoder = [mtlc.encoderManager getTextureEncoder:dstOps-&gt;pTexture isSrcOpaque:YES isDstOpaque:YES];
      if (!MTLTR_EnableLCDGlyphModeState(encoder, mtlc, dstOps,contrast))
      {
          return JNI_FALSE;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 926,19 ***</span>
          if (!ok) {
              break;
          }
      }
      /*
<span class="line-modified">!      * This state management needs to be extended for other glyphmodes</span>
<span class="line-modified">!      * when they are implemented.</span>
       */
<span class="line-modified">!     if (glyphMode != MODE_NO_CACHE_LCD) {</span>
<span class="line-modified">!         if (glyphMode == MODE_NO_CACHE_GRAY) {</span>
<span class="line-modified">!             MTLVertexCache_DisableMaskCache(mtlc);</span>
<span class="line-modified">!         } else {</span>
<span class="line-removed">-             MTLTR_DisableGlyphVertexCache(mtlc);</span>
<span class="line-removed">-         }</span>
      }
  }
  
  JNIEXPORT void JNICALL
  Java_sun_java2d_metal_MTLTextRenderer_drawGlyphList
<span class="line-new-header">--- 926,18 ---</span>
          if (!ok) {
              break;
          }
      }
      /*
<span class="line-modified">!      * Only in case of grayscale text drawing we need to flush</span>
<span class="line-modified">!      * cache. Still in case of LCD we are not using any intermediate</span>
<span class="line-added">+      * cache.</span>
       */
<span class="line-modified">!     if (glyphMode == MODE_NO_CACHE_GRAY) {</span>
<span class="line-modified">!         MTLVertexCache_DisableMaskCache(mtlc);</span>
<span class="line-modified">!     } else if (glyphMode == MODE_USE_CACHE_GRAY) {</span>
<span class="line-modified">!         MTLTR_DisableGlyphVertexCache(mtlc);</span>
      }
  }
  
  JNIEXPORT void JNICALL
  Java_sun_java2d_metal_MTLTextRenderer_drawGlyphList
</pre>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
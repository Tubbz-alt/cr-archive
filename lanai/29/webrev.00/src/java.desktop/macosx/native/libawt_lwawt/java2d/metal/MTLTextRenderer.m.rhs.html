<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLTextRenderer.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef HEADLESS
 27 
 28 #include &lt;stdlib.h&gt;
 29 #include &lt;limits.h&gt;
 30 #include &lt;math.h&gt;
 31 #include &lt;jlong.h&gt;
 32 
 33 #include &quot;sun_java2d_metal_MTLTextRenderer.h&quot;
 34 
 35 #include &quot;SurfaceData.h&quot;
 36 #include &quot;MTLContext.h&quot;
 37 #include &quot;MTLRenderQueue.h&quot;
 38 #include &quot;MTLTextRenderer.h&quot;
 39 #include &quot;MTLVertexCache.h&quot;
 40 #include &quot;MTLGlyphCache.h&quot;
 41 #include &quot;MTLBlitLoops.h&quot;
 42 
 43 /**
 44  * The following constants define the inner and outer bounds of the
 45  * accelerated glyph cache.
 46  */
 47 #define MTLTR_CACHE_WIDTH       512
 48 #define MTLTR_CACHE_HEIGHT      512
 49 #define MTLTR_CACHE_CELL_WIDTH  32
 50 #define MTLTR_CACHE_CELL_HEIGHT 32
 51 
 52 /**
 53  * The current &quot;glyph mode&quot; state.  This variable is used to track the
 54  * codepath used to render a particular glyph.  This variable is reset to
 55  * MODE_NOT_INITED at the beginning of every call to MTLTR_DrawGlyphList().
 56  * As each glyph is rendered, the glyphMode variable is updated to reflect
 57  * the current mode, so if the current mode is the same as the mode used
 58  * to render the previous glyph, we can avoid doing costly setup operations
 59  * each time.
 60  */
 61 typedef enum {
 62     MODE_NOT_INITED,
 63     MODE_USE_CACHE_GRAY,
 64     MODE_USE_CACHE_LCD,
 65     MODE_NO_CACHE_GRAY,
 66     MODE_NO_CACHE_LCD,
 67     MODE_NO_CACHE_COLOR
 68 } GlyphMode;
 69 static GlyphMode glyphMode = MODE_NOT_INITED;
 70 
 71 /**
 72  * There are two separate glyph caches: for AA and for LCD.
 73  * Once one of them is initialized as either GRAY or LCD, it
 74  * stays in that mode for the duration of the application.  It should
 75  * be safe to use this one glyph cache for all screens in a multimon
 76  * environment, since the glyph cache texture is shared between all contexts,
 77  * and (in theory) OpenGL drivers should be smart enough to manage that
 78  * texture across all screens.
 79  */
 80 
 81 static MTLGlyphCacheInfo *glyphCacheLCD = NULL;
 82 static MTLGlyphCacheInfo *glyphCacheAA = NULL;
 83 
 84 /**
 85  * The handle to the LCD text fragment program object.
 86  */
 87 static GLhandleARB lcdTextProgram = 0;
 88 
 89 /**
 90  * This value tracks the previous LCD contrast setting, so if the contrast
 91  * value hasn&#39;t changed since the last time the gamma uniforms were
 92  * updated (not very common), then we can skip updating the unforms.
 93  */
 94 static jint lastLCDContrast = -1;
 95 
 96 /**
 97  * This value tracks the previous LCD rgbOrder setting, so if the rgbOrder
 98  * value has changed since the last time, it indicates that we need to
 99  * invalidate the cache, which may already store glyph images in the reverse
100  * order.  Note that in most real world applications this value will not
101  * change over the course of the application, but tests like Font2DTest
102  * allow for changing the ordering at runtime, so we need to handle that case.
103  */
104 static jboolean lastRGBOrder = JNI_TRUE;
105 
106 /**
107  * This constant defines the size of the tile to use in the
108  * MTLTR_DrawLCDGlyphNoCache() method.  See below for more on why we
109  * restrict this value to a particular size.
110  */
111 #define MTLTR_NOCACHE_TILE_SIZE 32
112 
113 /**
114  * These constants define the size of the &quot;cached destination&quot; texture.
115  * This texture is only used when rendering LCD-optimized text, as that
116  * codepath needs direct access to the destination.  There is no way to
117  * access the framebuffer directly from an OpenGL shader, so we need to first
118  * copy the destination region corresponding to a particular glyph into
119  * this cached texture, and then that texture will be accessed inside the
120  * shader.  Copying the destination into this cached texture can be a very
121  * expensive operation (accounting for about half the rendering time for
122  * LCD text), so to mitigate this cost we try to bulk read a horizontal
123  * region of the destination at a time.  (These values are empirically
124  * derived for the common case where text runs horizontally.)
125  *
126  * Note: It is assumed in various calculations below that:
127  *     (MTLTR_CACHED_DEST_WIDTH  &gt;= MTLTR_CACHE_CELL_WIDTH)  &amp;&amp;
128  *     (MTLTR_CACHED_DEST_WIDTH  &gt;= MTLTR_NOCACHE_TILE_SIZE) &amp;&amp;
129  *     (MTLTR_CACHED_DEST_HEIGHT &gt;= MTLTR_CACHE_CELL_HEIGHT) &amp;&amp;
130  *     (MTLTR_CACHED_DEST_HEIGHT &gt;= MTLTR_NOCACHE_TILE_SIZE)
131  */
132 #define MTLTR_CACHED_DEST_WIDTH  512
133 #define MTLTR_CACHED_DEST_HEIGHT (MTLTR_CACHE_CELL_HEIGHT * 2)
134 
135 /**
136  * The handle to the &quot;cached destination&quot; texture object.
137  */
138 static GLuint cachedDestTextureID = 0;
139 
140 /**
141  * The current bounds of the &quot;cached destination&quot; texture, in destination
142  * coordinate space.  The width/height of these bounds will not exceed the
143  * MTLTR_CACHED_DEST_WIDTH/HEIGHT values defined above.  These bounds are
144  * only considered valid when the isCachedDestValid flag is JNI_TRUE.
145  */
146 static SurfaceDataBounds cachedDestBounds;
147 
148 /**
149  * This flag indicates whether the &quot;cached destination&quot; texture contains
150  * valid data.  This flag is reset to JNI_FALSE at the beginning of every
151  * call to MTLTR_DrawGlyphList().  Once we copy valid destination data
152  * into the cached texture, this flag is set to JNI_TRUE.  This way, we can
153  * limit the number of times we need to copy destination data, which is a
154  * very costly operation.
155  */
156 static jboolean isCachedDestValid = JNI_FALSE;
157 
158 /**
159  * The bounds of the previously rendered LCD glyph, in destination
160  * coordinate space.  We use these bounds to determine whether the glyph
161  * currently being rendered overlaps the previously rendered glyph (i.e.
162  * its bounding box intersects that of the previously rendered glyph).  If
163  * so, we need to re-read the destination area associated with that previous
164  * glyph so that we can correctly blend with the actual destination data.
165  */
166 static SurfaceDataBounds previousGlyphBounds;
167 
168 static struct TxtVertex txtVertices[6];
169 static jint vertexCacheIndex = 0;
170 
171 #define LCD_ADD_VERTEX(TX, TY, DX, DY, DZ) \
172     do { \
173         struct TxtVertex *v = &amp;txtVertices[vertexCacheIndex++]; \
174         v-&gt;txtpos[0] = TX; \
175         v-&gt;txtpos[1] = TY; \
176         v-&gt;position[0]= DX; \
177         v-&gt;position[1] = DY; \
178     } while (0)
179 
180 #define LCD_ADD_TRIANGLES(TX1, TY1, TX2, TY2, DX1, DY1, DX2, DY2) \
181     do { \
182         LCD_ADD_VERTEX(TX1, TY1, DX1, DY1, 0); \
183         LCD_ADD_VERTEX(TX2, TY1, DX2, DY1, 0); \
184         LCD_ADD_VERTEX(TX2, TY2, DX2, DY2, 0); \
185         LCD_ADD_VERTEX(TX2, TY2, DX2, DY2, 0); \
186         LCD_ADD_VERTEX(TX1, TY2, DX1, DY2, 0); \
187         LCD_ADD_VERTEX(TX1, TY1, DX1, DY1, 0); \
188     } while (0)
189 
190 /**
191  * Initializes the one glyph cache (texture and data structure).
192  * If lcdCache is JNI_TRUE, the texture will contain RGB data,
193  * otherwise we will simply store the grayscale/monochrome glyph images
194  * as intensity values (which work well with the GL_MODULATE function).
195  */
196 static jboolean
197 MTLTR_InitGlyphCache(MTLContext *mtlc, jboolean lcdCache)
198 {
199     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_InitGlyphCache&quot;);
200     MTLPixelFormat pixelFormat =
201         lcdCache ? MTLPixelFormatRGBA8Unorm : MTLPixelFormatA8Unorm;
202 
203     MTLGlyphCacheInfo *gcinfo;
204     // init glyph cache data structure
205     gcinfo = MTLGlyphCache_Init(MTLTR_CACHE_WIDTH,
206                                 MTLTR_CACHE_HEIGHT,
207                                 MTLTR_CACHE_CELL_WIDTH,
208                                 MTLTR_CACHE_CELL_HEIGHT,
209                                 MTLVertexCache_FlushGlyphVertexCache);
210 
211     if (gcinfo == NULL) {
212         J2dRlsTraceLn(J2D_TRACE_ERROR,
213                       &quot;MTLTR_InitGlyphCache: could not init MTL glyph cache&quot;);
214         return JNI_FALSE;
215     }
216 
217     MTLTextureDescriptor *textureDescriptor =
218         [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:pixelFormat
219                                                             width:MTLTR_CACHE_WIDTH
220                                                             height:MTLTR_CACHE_HEIGHT
221                                                             mipmapped:NO];
222 
223     gcinfo-&gt;texture = [mtlc.device newTextureWithDescriptor:textureDescriptor];
224     [textureDescriptor release];
225 
226     if (lcdCache) {
227         glyphCacheLCD = gcinfo;
228     } else {
229         glyphCacheAA = gcinfo;
230     }
231 
232     return JNI_TRUE;
233 }
234 
235 id&lt;MTLTexture&gt;
236 MTLTR_GetGlyphCacheTexture()
237 {
238     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_GetGlyphCacheTexture&quot;);
239     if (glyphCacheAA != NULL) {
240         return glyphCacheAA-&gt;texture;
241     }
242     return NULL;
243 }
244 
245 /**
246  * Adds the given glyph to the glyph cache (texture and data structure)
247  * associated with the given MTLContext.
248  */
249 static void
250 MTLTR_AddToGlyphCache(GlyphInfo *glyph, MTLContext *mtlc,
251                       MTLPixelFormat pixelFormat)
252 {
253     MTLCacheCellInfo *ccinfo;
254     MTLGlyphCacheInfo *gcinfo;
255 
256     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_AddToGlyphCache&quot;);
257     if (pixelFormat == MTLPixelFormatA8Unorm) {
258         gcinfo = glyphCacheAA;
259     } else {
260         gcinfo = glyphCacheLCD;
261     }
262 
263     if ((gcinfo == NULL) || (glyph-&gt;image == NULL)) {
264         return;
265     }
266 
267     bool isCacheFull = MTLGlyphCache_IsCacheFull(gcinfo, glyph);
268     if (isCacheFull) {
269         MTLGlyphCache_Free(gcinfo);
270         if (pixelFormat == MTLPixelFormatA8Unorm) {
271             MTLTR_InitGlyphCache(mtlc, JNI_FALSE);
272         } else {
273             MTLTR_InitGlyphCache(mtlc, JNI_TRUE);
274         }
275         gcinfo = glyphCacheAA;
276     }
277     MTLGlyphCache_AddGlyph(gcinfo, glyph);
278     ccinfo = (MTLCacheCellInfo *) glyph-&gt;cellInfo;
279 
280     if (ccinfo != NULL) {
281         // store glyph image in texture cell
282         MTLRegion region = {
283                 {ccinfo-&gt;x,  ccinfo-&gt;y,   0},
284                 {glyph-&gt;width, glyph-&gt;height, 1}
285         };
286         NSUInteger bytesPerRow = 1 * glyph-&gt;width;
287         [gcinfo-&gt;texture replaceRegion:region
288                          mipmapLevel:0
289                          withBytes:glyph-&gt;image
290                          bytesPerRow:bytesPerRow];
291     }
292 }
293 
294 static MTLRenderPipelineDescriptor * templateRenderPipelineDesc = nil;
295 static MTLRenderPipelineDescriptor * templateLCDPipelineDesc = nil;
296 
297 /**
298  * Enables the LCD text shader and updates any related state, such as the
299  * gamma lookup table textures.
300  */
301 static jboolean
302 MTLTR_EnableLCDGlyphModeState(id&lt;MTLRenderCommandEncoder&gt; encoder,
303                               MTLContext *mtlc, 
304                               MTLSDOps *dstOps,
305                               jint contrast)
306 {
307     // create the LCD text shader, if necessary
308     if (templateLCDPipelineDesc == nil) {
309 
310         MTLVertexDescriptor *vertDesc = [[MTLVertexDescriptor new] autorelease];
311         vertDesc.attributes[VertexAttributePosition].format = MTLVertexFormatFloat2;
312         vertDesc.attributes[VertexAttributePosition].offset = 0;
313         vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;
314         vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct Vertex);
315         vertDesc.layouts[MeshVertexBuffer].stepRate = 1;
316         vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
317 
318         templateLCDPipelineDesc = [[MTLRenderPipelineDescriptor new] autorelease];
319         templateLCDPipelineDesc.sampleCount = 1;
320         templateLCDPipelineDesc.vertexDescriptor = vertDesc;
321         templateLCDPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;
322         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].format = MTLVertexFormatFloat2;
323         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].offset = 2*sizeof(float);
324         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].bufferIndex = MeshVertexBuffer;
325         templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stride = sizeof(struct TxtVertex);
326         templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepRate = 1;
327         templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
328         templateLCDPipelineDesc.label = @&quot;template_lcd&quot;;
329     }
330 
331     id&lt;MTLRenderPipelineState&gt; pipelineState =
332                 [mtlc.pipelineStateStorage
333                     getPipelineState:templateLCDPipelineDesc
334                     vertexShaderId:@&quot;vert_txt&quot;
335                     fragmentShaderId:@&quot;lcd_color&quot;
336                    ];
337 
338     [encoder setRenderPipelineState:pipelineState];
339 
340     // update the current color settings
341     double gamma = ((double)contrast) / 100.0;
342     double invgamma = 1.0/gamma;
343     jfloat radj, gadj, badj;
344     jfloat clr[4];
345     jint col = [mtlc.paint getColor];
346 
347     J2dTraceLn2(J2D_TRACE_INFO, &quot;primary color %x, contrast %d&quot;, col, contrast);
348     J2dTraceLn2(J2D_TRACE_INFO, &quot;gamma %f, invgamma %f&quot;, gamma, invgamma);
349 
350     clr[0] = ((col &gt;&gt; 16) &amp; 0xFF)/255.0f;
351     clr[1] = ((col &gt;&gt; 8) &amp; 0xFF)/255.0f;
352     clr[2] = ((col) &amp; 0xFF)/255.0f;
353 
354     // gamma adjust the primary color
355     radj = (float)pow(clr[0], gamma);
356     gadj = (float)pow(clr[1], gamma);
357     badj = (float)pow(clr[2], gamma);
358 
359     struct LCDFrameUniforms uf = {
360             {radj, gadj, badj},
361             {gamma, gamma, gamma},
362             {invgamma, invgamma, invgamma}};
363     [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
364 
365     return JNI_TRUE;
366 }
367 
368 void
369 MTLTR_EnableGlyphVertexCache(MTLContext *mtlc, BMTLSDOps *dstOps)
370 {
371 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_EnableGlyphVertexCache&quot;);
372 
373     if (!MTLVertexCache_InitVertexCache()) {
374         return;
375     }
376 
377     if (glyphCacheAA == NULL) {
378         if (!MTLTR_InitGlyphCache(mtlc, JNI_FALSE)) {
379             return;
380         }
381     }
382     MTLVertexCache_CreateSamplingEncoder(mtlc, dstOps);
383 }
384 
385 void
386 MTLTR_DisableGlyphVertexCache(MTLContext *mtlc)
387 {
388     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DisableGlyphVertexCache&quot;);
389     MTLVertexCache_FlushGlyphVertexCache();
390     MTLVertexCache_RestoreColorState(mtlc);
391     MTLVertexCache_FreeVertexCache();
392 }
393 
394 /**
395  * Disables any pending state associated with the current &quot;glyph mode&quot;.
396  */
397 void
398 MTLTR_DisableGlyphModeState()
399 {
400     // TODO : This is similar to OpenGL implementation
401     // When LCD implementation is done weshould make
402     // more changes.
403     J2dTraceLn1(J2D_TRACE_VERBOSE,
404                 &quot;MTLTR_DisableGlyphModeState: mode=%d&quot;, glyphMode);
405     switch (glyphMode) {
406     case MODE_NO_CACHE_LCD:
407         // TODO : Along with LCD implementation
408         // changes needs to be made
409     case MODE_USE_CACHE_LCD:
410         // TODO : Along with LCD implementation
411         // changes needs to be made
412         break;
413     case MODE_NO_CACHE_GRAY:
414     case MODE_USE_CACHE_GRAY:
415     case MODE_NOT_INITED:
416     default:
417         break;
418     }
419 }
420 
421 static jboolean
422 MTLTR_DrawGrayscaleGlyphViaCache(MTLContext *mtlc,
423                                  GlyphInfo *ginfo, jint x, jint y, BMTLSDOps *dstOps)
424 {
425     MTLCacheCellInfo *cell;
426     jfloat x1, y1, x2, y2;
427 
428     if (glyphMode != MODE_USE_CACHE_GRAY) {
429         if (glyphMode == MODE_NO_CACHE_GRAY) {
430             MTLVertexCache_DisableMaskCache(mtlc);
431         }
432         MTLTR_EnableGlyphVertexCache(mtlc, dstOps);
433         glyphMode = MODE_USE_CACHE_GRAY;
434     }
435 
436     if (ginfo-&gt;cellInfo == NULL) {
437         // attempt to add glyph to accelerated glyph cache
438         MTLTR_AddToGlyphCache(ginfo, mtlc, MTLPixelFormatA8Unorm);
439 
440         if (ginfo-&gt;cellInfo == NULL) {
441             // we&#39;ll just no-op in the rare case that the cell is NULL
442             return JNI_TRUE;
443         }
444     }
445 
446     cell = (MTLCacheCellInfo *) (ginfo-&gt;cellInfo);
447     cell-&gt;timesRendered++;
448 
449     x1 = (jfloat)x;
450     y1 = (jfloat)y;
451     x2 = x1 + ginfo-&gt;width;
452     y2 = y1 + ginfo-&gt;height;
453 
454     MTLVertexCache_AddGlyphQuad(mtlc,
455                                 cell-&gt;tx1, cell-&gt;ty1,
456                                 cell-&gt;tx2, cell-&gt;ty2,
457                                 x1, y1, x2, y2);
458 
459     return JNI_TRUE;
460 }
461 
462 /**
463  * Evaluates to true if the rectangle defined by gx1/gy1/gx2/gy2 is
464  * inside outerBounds.
465  */
466 #define INSIDE(gx1, gy1, gx2, gy2, outerBounds) \
467     (((gx1) &gt;= outerBounds.x1) &amp;&amp; ((gy1) &gt;= outerBounds.y1) &amp;&amp; \
468      ((gx2) &lt;= outerBounds.x2) &amp;&amp; ((gy2) &lt;= outerBounds.y2))
469 
470 /**
471  * Evaluates to true if the rectangle defined by gx1/gy1/gx2/gy2 intersects
472  * the rectangle defined by bounds.
473  */
474 #define INTERSECTS(gx1, gy1, gx2, gy2, bounds) \
475     ((bounds.x2 &gt; (gx1)) &amp;&amp; (bounds.y2 &gt; (gy1)) &amp;&amp; \
476      (bounds.x1 &lt; (gx2)) &amp;&amp; (bounds.y1 &lt; (gy2)))
477 
478 /**
479  * This method checks to see if the given LCD glyph bounds fall within the
480  * cached destination texture bounds.  If so, this method can return
481  * immediately.  If not, this method will copy a chunk of framebuffer data
482  * into the cached destination texture and then update the current cached
483  * destination bounds before returning.
484  */
485 static void
486 MTLTR_UpdateCachedDestination(MTLSDOps *dstOps, GlyphInfo *ginfo,
487                               jint gx1, jint gy1, jint gx2, jint gy2,
488                               jint glyphIndex, jint totalGlyphs)
489 {
490     //TODO
491 }
492 
493 static jboolean
494 MTLTR_DrawLCDGlyphViaCache(MTLContext *mtlc, BMTLSDOps *dstOps,
495                            GlyphInfo *ginfo, jint x, jint y,
496                            jint glyphIndex, jint totalGlyphs,
497                            jboolean rgbOrder, jint contrast,
498                            id&lt;MTLTexture&gt; dstTexture)
499 {
500     CacheCellInfo *cell;
501     jfloat tx1, ty1, tx2, ty2;
502     jfloat dtx1=0, dty1=0, dtx2=0, dty2=0;
503     jint tw, th;
504     jint sx=0, sy=0, sw=0, sh=0, dxadj=0, dyadj=0;
505     jint x0;
506     jint w = ginfo-&gt;width;
507     jint h = ginfo-&gt;height;
508     id&lt;MTLTexture&gt; blitTexture = nil;
509 
510     id&lt;MTLRenderCommandEncoder&gt; encoder = nil;
511 
512     MTLTextureDescriptor *textureDescriptor =
513         [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatBGRA8Unorm
514                                                             width:w
515                                                             height:h
516                                                             mipmapped:NO];
517 
518     blitTexture = [mtlc.device newTextureWithDescriptor:textureDescriptor];
519     [textureDescriptor release];
520 
521     if (glyphMode != MODE_USE_CACHE_LCD) {
522         if (glyphMode == MODE_NO_CACHE_GRAY) {
523             MTLVertexCache_DisableMaskCache(mtlc);
524         } else if (glyphMode == MODE_USE_CACHE_GRAY) {
525             MTLTR_DisableGlyphVertexCache(mtlc);
526         }
527 
<a name="1" id="anc1"></a><span class="line-modified">528         /*if (glyphCacheLCD == NULL) {</span>
529             if (!MTLTR_InitGlyphCache(mtlc, JNI_TRUE)) {
530                 return JNI_FALSE;
531             }
532         }
533 
534         if (rgbOrder != lastRGBOrder) {
535             // need to invalidate the cache in this case; see comments
536             // for lastRGBOrder above
537             MTLGlyphCache_Invalidate(glyphCacheLCD);
538             lastRGBOrder = rgbOrder;
<a name="2" id="anc2"></a><span class="line-modified">539         }*/</span>
540 
541         glyphMode = MODE_USE_CACHE_LCD;
542     }
543 
<a name="3" id="anc3"></a><span class="line-modified">544     /*if (ginfo-&gt;cellInfo == NULL) {</span>
545         // attempt to add glyph to accelerated glyph cache
546         // TODO : Handle RGB order
547         MTLTR_AddToGlyphCache(ginfo, mtlc, MTLPixelFormatRGBA8Unorm);
548 
549         if (ginfo-&gt;cellInfo == NULL) {
550             // we&#39;ll just no-op in the rare case that the cell is NULL
551             return JNI_TRUE;
552         }
<a name="4" id="anc4"></a><span class="line-modified">553     }*/</span>
554     encoder = [mtlc.encoderManager getTextureEncoder:dstOps-&gt;pTexture isSrcOpaque:YES isDstOpaque:YES];
555     if (!MTLTR_EnableLCDGlyphModeState(encoder, mtlc, dstOps,contrast))
556     {
557         return JNI_FALSE;
558     }
559 
560 
561     unsigned int imageBytes = w * h *4;
562     unsigned char imageData[imageBytes];
563     memset(&amp;imageData, 0, sizeof(imageData));
564 
565     for (int i = 0; i &lt; h; i++) {
566         for (int j = 0; j &lt; w; j++) {
567             imageData[(i * w * 4) + j * 4] = ginfo-&gt;image[(i * w * 3) + j * 3];
568             imageData[(i * w * 4) + j * 4 + 1] = ginfo-&gt;image[(i * w * 3) + j * 3 + 1];
569             imageData[(i * w * 4) + j * 4 + 2] = ginfo-&gt;image[(i * w * 3) + j * 3 + 2];
570             imageData[(i * w * 4) + j * 4 + 3] = 0xFF;
571         }
572     }
573 
574     // copy LCD mask into glyph texture tile
575     MTLRegion region = MTLRegionMake2D(0, 0, w, h);
576 
577     NSUInteger bytesPerRow = 4 * ginfo-&gt;width;
578     [blitTexture replaceRegion:region
579                  mipmapLevel:0
580                  withBytes:imageData
581                  bytesPerRow:bytesPerRow];
582 
583     J2dTraceLn7(J2D_TRACE_INFO, &quot;sx = %d sy = %d x = %d y = %d sw = %d sh = %d w = %d&quot;, sx, sy, x, y, sw, sh, w);
584 
585     x0 = x;
586     tx1 = 0.0f;
587     ty1 = 0.0f;
588     dtx1 = 0.0f;
589     dty2 = 0.0f;
590     tw = MTLTR_NOCACHE_TILE_SIZE;
591     th = MTLTR_NOCACHE_TILE_SIZE;
592 
593     // update the lower-right glyph texture coordinates
594     tx2 = 1.0f;
595     ty2 = 1.0f;
596 
597     J2dTraceLn5(J2D_TRACE_INFO, &quot;xOffset %d yOffset %d, dxadj %d, dyadj %d dstOps-&gt;height %d&quot;, dstOps-&gt;xOffset, dstOps-&gt;yOffset, dxadj, dyadj, dstOps-&gt;height);
598 
599     dtx1 = ((jfloat)dxadj) / dstOps-&gt;textureWidth;
600     dtx2 = ((float)dxadj + sw) / dstOps-&gt;textureWidth;
601   
602     dty1 = ((jfloat)dyadj + sh) / dstOps-&gt;textureHeight;
603     dty2 = ((jfloat)dyadj) / dstOps-&gt;textureHeight;
604 
605     J2dTraceLn4(J2D_TRACE_INFO, &quot;tx1 %f, ty1 %f, tx2 %f, ty2 %f&quot;, tx1, ty1, tx2, ty2);
606     J2dTraceLn2(J2D_TRACE_INFO, &quot;textureWidth %d textureHeight %d&quot;, dstOps-&gt;textureWidth, dstOps-&gt;textureHeight);
607     J2dTraceLn4(J2D_TRACE_INFO, &quot;dtx1 %f, dty1 %f, dtx2 %f, dty2 %f&quot;, dtx1, dty1, dtx2, dty2);
608 
609     LCD_ADD_TRIANGLES(tx1, ty1, tx2, ty2, x, y, x+w, y+h);
610 
611     [encoder setVertexBytes:txtVertices length:sizeof(txtVertices) atIndex:MeshVertexBuffer];
612     [encoder setFragmentTexture:blitTexture atIndex:0];
613     [encoder setFragmentTexture:dstOps-&gt;pTexture atIndex:1];
614 
615     [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];
616 
617     vertexCacheIndex = 0;
618     [mtlc.encoderManager endEncoder];
619 
620     [blitTexture release];
621 
622     MTLCommandBufferWrapper* cbwrapper = [mtlc pullCommandBufferWrapper];
623 
624     id&lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
625     [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
626         [cbwrapper release];
627     }];
628 
629     [commandbuf commit];
630     [commandbuf waitUntilCompleted];
631 
632     // TODO : Updating cache bounds and texture mapping.
633     return JNI_TRUE;
634 }
635 
636 static jboolean
637 MTLTR_DrawGrayscaleGlyphNoCache(MTLContext *mtlc,
638                                 GlyphInfo *ginfo, jint x, jint y, BMTLSDOps *dstOps)
639 {
640     jint tw, th;
641     jint sx, sy, sw, sh;
642     jint x0;
643     jint w = ginfo-&gt;width;
644     jint h = ginfo-&gt;height;
645 
646     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGrayscaleGlyphNoCache&quot;);
647     if (glyphMode != MODE_NO_CACHE_GRAY) {
648         if (glyphMode == MODE_USE_CACHE_GRAY) {
649             MTLTR_DisableGlyphVertexCache(mtlc);
650         }
651         MTLVertexCache_EnableMaskCache(mtlc, dstOps);
652         glyphMode = MODE_NO_CACHE_GRAY;
653     }
654 
655     x0 = x;
656     tw = MTLVC_MASK_CACHE_TILE_WIDTH;
657     th = MTLVC_MASK_CACHE_TILE_HEIGHT;
658 
659     for (sy = 0; sy &lt; h; sy += th, y += th) {
660         x = x0;
661         sh = ((sy + th) &gt; h) ? (h - sy) : th;
662 
663         for (sx = 0; sx &lt; w; sx += tw, x += tw) {
664             sw = ((sx + tw) &gt; w) ? (w - sx) : tw;
665 
666             J2dTraceLn7(J2D_TRACE_INFO, &quot;sx = %d sy = %d x = %d y = %d sw = %d sh = %d w = %d&quot;, sx, sy, x, y, sw, sh, w);
667             MTLVertexCache_AddMaskQuad(mtlc,
668                                        sx, sy, x, y, sw, sh,
669                                        w, ginfo-&gt;image,
670                                        dstOps,
671                                        ginfo-&gt;width);
672         }
673     }
674 
675     return JNI_TRUE;
676 }
677 
678 
679 static jboolean
680 MTLTR_DrawLCDGlyphNoCache(MTLContext *mtlc, BMTLSDOps *dstOps,
681                           GlyphInfo *ginfo, jint x, jint y,
682                           jint rowBytesOffset,
683                           jboolean rgbOrder, jint contrast,
684                           id&lt;MTLTexture&gt; dstTexture)
685 {
686     jfloat tx1, ty1, tx2, ty2;
687     jfloat dtx1=0, dty1=0, dtx2=0, dty2=0;
688     jint tw, th;
689     jint sx=0, sy=0, sw=0, sh=0, dxadj=0, dyadj=0;
690     jint x0;
691     jint w = ginfo-&gt;width;
692     jint h = ginfo-&gt;height;
693     id&lt;MTLTexture&gt; blitTexture = nil;
694 
695     J2dTraceLn2(J2D_TRACE_INFO, &quot;MTLTR_DrawLCDGlyphNoCache x %d, y%d&quot;, x, y);
696     J2dTraceLn3(J2D_TRACE_INFO, &quot;MTLTR_DrawLCDGlyphNoCache rowBytesOffset=%d, rgbOrder=%d, contrast=%d&quot;, rowBytesOffset, rgbOrder, contrast);
697 
698 
699     id&lt;MTLRenderCommandEncoder&gt; encoder = nil;
700 
701     MTLTextureDescriptor *textureDescriptor =
702         [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatBGRA8Unorm
703                                                             width:w
704                                                             height:h
705                                                             mipmapped:NO];
706 
707     blitTexture = [mtlc.device newTextureWithDescriptor:textureDescriptor];
708     [textureDescriptor release];
709 
710     if (glyphMode != MODE_NO_CACHE_LCD) {
711         if (glyphMode == MODE_NO_CACHE_GRAY) {
712             MTLVertexCache_DisableMaskCache(mtlc);
713         } else if (glyphMode == MODE_USE_CACHE_GRAY) {
714             MTLTR_DisableGlyphVertexCache(mtlc);
715         }
716 
717         if (blitTexture == nil) {
718             J2dTraceLn(J2D_TRACE_ERROR, &quot;can&#39;t obtain temporary texture object from pool&quot;);
719             return JNI_FALSE;
720         }
721 
722 
723         glyphMode = MODE_NO_CACHE_LCD;
724     }
725     encoder = [mtlc.encoderManager getTextureEncoder:dstOps-&gt;pTexture isSrcOpaque:YES isDstOpaque:YES];
726     if (!MTLTR_EnableLCDGlyphModeState(encoder, mtlc, dstOps,contrast))
727     {
728         return JNI_FALSE;
729     }
730 
731     x0 = x;
732     tx1 = 0.0f;
733     ty1 = 0.0f;
734     dtx1 = 0.0f;
735     dty2 = 0.0f;
736     tw = MTLTR_NOCACHE_TILE_SIZE;
737     th = MTLTR_NOCACHE_TILE_SIZE;
738 
739     unsigned int imageBytes = w * h *4;
740     unsigned char imageData[imageBytes];
741     memset(&amp;imageData, 0, sizeof(imageData));
742 
743     for (int i = 0; i &lt; h; i++) {
744         for (int j = 0; j &lt; w; j++) {
745             imageData[(i * w * 4) + j * 4] = ginfo-&gt;image[(i * w * 3) + j * 3];
746             imageData[(i * w * 4) + j * 4 + 1] = ginfo-&gt;image[(i * w * 3) + j * 3 + 1];
747             imageData[(i * w * 4) + j * 4 + 2] = ginfo-&gt;image[(i * w * 3) + j * 3 + 2];
748             imageData[(i * w * 4) + j * 4 + 3] = 0xFF;
749         }
750     }
751 
752     // copy LCD mask into glyph texture tile
753     MTLRegion region = MTLRegionMake2D(0, 0, w, h);
754 
755     NSUInteger bytesPerRow = 4 * ginfo-&gt;width;
756     [blitTexture replaceRegion:region
757                  mipmapLevel:0
758                  withBytes:imageData
759                  bytesPerRow:bytesPerRow];
760 
761     J2dTraceLn7(J2D_TRACE_INFO, &quot;sx = %d sy = %d x = %d y = %d sw = %d sh = %d w = %d&quot;, sx, sy, x, y, sw, sh, w);
762 
763 
764     // update the lower-right glyph texture coordinates
765     tx2 = 1.0f;
766     ty2 = 1.0f;
767 
768     J2dTraceLn5(J2D_TRACE_INFO, &quot;xOffset %d yOffset %d, dxadj %d, dyadj %d dstOps-&gt;height %d&quot;, dstOps-&gt;xOffset, dstOps-&gt;yOffset, dxadj, dyadj, dstOps-&gt;height);
769 
770     dtx1 = ((jfloat)dxadj) / dstOps-&gt;textureWidth;
771     dtx2 = ((float)dxadj + sw) / dstOps-&gt;textureWidth;
772   
773     dty1 = ((jfloat)dyadj + sh) / dstOps-&gt;textureHeight;
774     dty2 = ((jfloat)dyadj) / dstOps-&gt;textureHeight;
775 
776     J2dTraceLn4(J2D_TRACE_INFO, &quot;tx1 %f, ty1 %f, tx2 %f, ty2 %f&quot;, tx1, ty1, tx2, ty2);
777     J2dTraceLn2(J2D_TRACE_INFO, &quot;textureWidth %d textureHeight %d&quot;, dstOps-&gt;textureWidth, dstOps-&gt;textureHeight);
778     J2dTraceLn4(J2D_TRACE_INFO, &quot;dtx1 %f, dty1 %f, dtx2 %f, dty2 %f&quot;, dtx1, dty1, dtx2, dty2);
779 
780     LCD_ADD_TRIANGLES(tx1, ty1, tx2, ty2, x, y, x+w, y+h);
781 
782     [encoder setVertexBytes:txtVertices length:sizeof(txtVertices) atIndex:MeshVertexBuffer];
783     [encoder setFragmentTexture:blitTexture atIndex:0];
784     [encoder setFragmentTexture:dstOps-&gt;pTexture atIndex:1];
785 
786     [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];
787 
788     vertexCacheIndex = 0;
789     [mtlc.encoderManager endEncoder];
790     [blitTexture release];
791 
792     MTLCommandBufferWrapper* cbwrapper = [mtlc pullCommandBufferWrapper];
793 
794     id&lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
795     [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
796         [cbwrapper release];
797     }];
798 
799     [commandbuf commit];
800     [commandbuf waitUntilCompleted];
801 
802     return JNI_TRUE;
803 }
804 
805 static jboolean
806 MTLTR_DrawColorGlyphNoCache(MTLContext *mtlc, GlyphInfo *ginfo, jint x, jint y)
807 {
808     //TODO
809     return JNI_TRUE;
810 }
811 
812 
813 // see DrawGlyphList.c for more on this macro...
814 #define FLOOR_ASSIGN(l, r) \
815     if ((r)&lt;0) (l) = ((int)floor(r)); else (l) = ((int)(r))
816 
817 void
818 MTLTR_DrawGlyphList(JNIEnv *env, MTLContext *mtlc, BMTLSDOps *dstOps,
819                     jint totalGlyphs, jboolean usePositions,
820                     jboolean subPixPos, jboolean rgbOrder, jint lcdContrast,
821                     jfloat glyphListOrigX, jfloat glyphListOrigY,
822                     unsigned char *images, unsigned char *positions)
823 {
824     int glyphCounter;
825 
826     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList&quot;);
827 
828     RETURN_IF_NULL(mtlc);
829     RETURN_IF_NULL(dstOps);
830     RETURN_IF_NULL(images);
831     if (usePositions) {
832         RETURN_IF_NULL(positions);
833     }
834 
835     glyphMode = MODE_NOT_INITED;
836     isCachedDestValid = JNI_FALSE;
837     J2dTraceLn1(J2D_TRACE_INFO, &quot;totalGlyphs = %d&quot;, totalGlyphs);
838 
839     for (glyphCounter = 0; glyphCounter &lt; totalGlyphs; glyphCounter++) {
840         J2dTraceLn(J2D_TRACE_INFO, &quot;Entered for loop for glyph list&quot;);
841         jint x, y;
842         jfloat glyphx, glyphy;
843         jboolean grayscale, ok;
844         GlyphInfo *ginfo = (GlyphInfo *)jlong_to_ptr(NEXT_LONG(images));
845 
846         if (ginfo == NULL) {
847             // this shouldn&#39;t happen, but if it does we&#39;ll just break out...
848             J2dRlsTraceLn(J2D_TRACE_ERROR,
849                           &quot;MTLTR_DrawGlyphList: glyph info is null&quot;);
850             break;
851         }
852 
853         grayscale = (ginfo-&gt;rowBytes == ginfo-&gt;width);
854 
855         if (usePositions) {
856             jfloat posx = NEXT_FLOAT(positions);
857             jfloat posy = NEXT_FLOAT(positions);
858             glyphx = glyphListOrigX + posx + ginfo-&gt;topLeftX;
859             glyphy = glyphListOrigY + posy + ginfo-&gt;topLeftY;
860             FLOOR_ASSIGN(x, glyphx);
861             FLOOR_ASSIGN(y, glyphy);
862         } else {
863             glyphx = glyphListOrigX + ginfo-&gt;topLeftX;
864             glyphy = glyphListOrigY + ginfo-&gt;topLeftY;
865             FLOOR_ASSIGN(x, glyphx);
866             FLOOR_ASSIGN(y, glyphy);
867             glyphListOrigX += ginfo-&gt;advanceX;
868             glyphListOrigY += ginfo-&gt;advanceY;
869         }
870 
871         if (ginfo-&gt;image == NULL) {
872             J2dTraceLn(J2D_TRACE_INFO, &quot;Glyph image is null&quot;);
873             continue;
874         }
875 
876         J2dTraceLn2(J2D_TRACE_INFO, &quot;Glyph width = %d height = %d&quot;, ginfo-&gt;width, ginfo-&gt;height);
877         J2dTraceLn1(J2D_TRACE_INFO, &quot;rowBytes = %d&quot;, ginfo-&gt;rowBytes);
878         //TODO : Right now we have initial texture mapping logic
879         // as we implement LCD, cache usage add new selection condition.
880         if (grayscale) {
881             // grayscale or monochrome glyph data
882             if (ginfo-&gt;width &lt;= MTLTR_CACHE_CELL_WIDTH &amp;&amp;
883                 ginfo-&gt;height &lt;= MTLTR_CACHE_CELL_HEIGHT)
884             {
885                 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList Grayscale cache&quot;);
886                 ok = MTLTR_DrawGrayscaleGlyphViaCache(mtlc, ginfo, x, y, dstOps);
887             } else {
888                 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList Grayscale no cache&quot;);
889                 ok = MTLTR_DrawGrayscaleGlyphNoCache(mtlc, ginfo, x, y, dstOps);
890             }
891         } else {
892             void* dstTexture = dstOps-&gt;textureLCD;
893 
894             // LCD-optimized glyph data
895             jint rowBytesOffset = 0;
896 
897             if (subPixPos) {
898                 jint frac = (jint)((glyphx - x) * 3);
899                 if (frac != 0) {
900                     rowBytesOffset = 3 - frac;
901                     x += 1;
902                 }
903             }
904 
905             // TODO: Implement LCD text rendering
906             if (rowBytesOffset == 0 &amp;&amp;
907                 ginfo-&gt;width &lt;= MTLTR_CACHE_CELL_WIDTH &amp;&amp;
908                 ginfo-&gt;height &lt;= MTLTR_CACHE_CELL_HEIGHT)
909             {
910                 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList LCD cache -- :TODO&quot;);
911                 ok = MTLTR_DrawLCDGlyphViaCache(mtlc, dstOps,
912                                                 ginfo, x, y,
913                                                 glyphCounter, totalGlyphs,
914                                                 rgbOrder, lcdContrast,
915                                                 dstTexture);
916             } else {
917                 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList LCD no cache&quot;);
918                 ok = MTLTR_DrawLCDGlyphNoCache(mtlc, dstOps,
919                                                ginfo, x, y,
920                                                rowBytesOffset,
921                                                rgbOrder, lcdContrast,
922                                                dstTexture);
923             }
924         }
925 
926         if (!ok) {
927             break;
928         }
929     }
930     /*
<a name="5" id="anc5"></a><span class="line-modified">931      * Only in case of grayscale text drawing we need to flush</span>
<span class="line-modified">932      * cache. Still in case of LCD we are not using any intermediate</span>
<span class="line-added">933      * cache.</span>
934      */
<a name="6" id="anc6"></a><span class="line-modified">935     if (glyphMode == MODE_NO_CACHE_GRAY) {</span>
<span class="line-modified">936         MTLVertexCache_DisableMaskCache(mtlc);</span>
<span class="line-modified">937     } else if (glyphMode == MODE_USE_CACHE_GRAY) {</span>
<span class="line-modified">938         MTLTR_DisableGlyphVertexCache(mtlc);</span>


939     }
940 }
941 
942 JNIEXPORT void JNICALL
943 Java_sun_java2d_metal_MTLTextRenderer_drawGlyphList
944     (JNIEnv *env, jobject self,
945      jint numGlyphs, jboolean usePositions,
946      jboolean subPixPos, jboolean rgbOrder, jint lcdContrast,
947      jfloat glyphListOrigX, jfloat glyphListOrigY,
948      jlongArray imgArray, jfloatArray posArray)
949 {
950     unsigned char *images;
951 
952     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTextRenderer_drawGlyphList&quot;);
953 
954     images = (unsigned char *)
955         (*env)-&gt;GetPrimitiveArrayCritical(env, imgArray, NULL);
956     if (images != NULL) {
957         MTLContext *mtlc = MTLRenderQueue_GetCurrentContext();
958         BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
959 
960         if (usePositions) {
961             unsigned char *positions = (unsigned char *)
962                 (*env)-&gt;GetPrimitiveArrayCritical(env, posArray, NULL);
963             if (positions != NULL) {
964                 MTLTR_DrawGlyphList(env, mtlc, dstOps,
965                                     numGlyphs, usePositions,
966                                     subPixPos, rgbOrder, lcdContrast,
967                                     glyphListOrigX, glyphListOrigY,
968                                     images, positions);
969                 (*env)-&gt;ReleasePrimitiveArrayCritical(env, posArray,
970                                                       positions, JNI_ABORT);
971             }
972         } else {
973             MTLTR_DrawGlyphList(env, mtlc, dstOps,
974                                 numGlyphs, usePositions,
975                                 subPixPos, rgbOrder, lcdContrast,
976                                 glyphListOrigX, glyphListOrigY,
977                                 images, NULL);
978         }
979 
980         (*env)-&gt;ReleasePrimitiveArrayCritical(env, imgArray,
981                                               images, JNI_ABORT);
982     }
983 }
984 
985 #endif /* !HEADLESS */
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
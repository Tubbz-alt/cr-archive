diff a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBlitLoops.m b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBlitLoops.m
--- a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBlitLoops.m
+++ b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBlitLoops.m
@@ -485,11 +485,13 @@
     }
 
 #ifdef TRACE_ISOBLIT
     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE," [via sampling]");
 #endif //TRACE_ISOBLIT
-    drawTex2Tex(mtlc, srcTex, dstTex, srcOps->isOpaque, dstOps->isOpaque, hint, sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2);
+    drawTex2Tex(mtlc, srcTex, dstTex,
+            [mtlc isBlendingDisabled:srcOps->isOpaque],
+            dstOps->isOpaque, hint, sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2);
 }
 
 /**
  * General blit method for copying a system memory ("Sw") surface to a native MTL surface.
  * Parameter texture == true only in SwToTextureBlit (straight copy from sw to texture), dest coordinates will always be integers.
diff a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLComposite.m b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLComposite.m
--- a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLComposite.m
+++ b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLComposite.m
@@ -139,17 +139,14 @@
     }
     return [NSString stringWithFormat:@"%s", result];
 }
 
 - (jboolean)isBlendingDisabled:(jboolean)isSrcOpaque {
-    if (_compositeRule == java_awt_AlphaComposite_SRC) {
-        const jfloat epsilon = 0.001f;
-        return fabs(_extraAlpha - 1.0f) < epsilon;
-    }
-    if (_compositeRule != java_awt_AlphaComposite_SRC_OVER) {
-        // J2dRlsTraceLn1(J2D_TRACE_VERBOSE, "\tuse blending for rule %d", alphaCompositeRule);
-        return JNI_FALSE;
+    if (_compositeRule == java_awt_AlphaComposite_SRC ||
+        _compositeRule == java_awt_AlphaComposite_SRC_OVER)
+    {
+        return FLT_LT(_extraAlpha, 1.0f);
     }
     return isSrcOpaque;
 }
 
 - (void)setAlphaComposite:(jint)rule {
diff a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPaints.m b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPaints.m
--- a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPaints.m
+++ b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPaints.m
@@ -323,11 +323,11 @@
 
 static void setTxtUniforms(
         id<MTLRenderCommandEncoder> encoder, int color, int mode, int interpolation, bool repeat, jfloat extraAlpha,
         const SurfaceRasterFlags * srcFlags, const SurfaceRasterFlags * dstFlags
 ) {
-    struct TxtFrameUniforms uf = {RGBA_TO_V4(color), mode, srcFlags->isOpaque, dstFlags->isOpaque, interpolation};
+    struct TxtFrameUniforms uf = {RGBA_TO_V4(color), mode, srcFlags->isOpaque, dstFlags->isOpaque, extraAlpha};
     [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];
 
     id<MTLSamplerState> sampler;
     if (repeat) {
         sampler = interpolation == INTERPOLATION_BILINEAR ? samplerLinearRepeat : samplerNearestRepeat;
diff a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPipelineStatesStorage.m b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPipelineStatesStorage.m
--- a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPipelineStatesStorage.m
+++ b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPipelineStatesStorage.m
@@ -263,12 +263,13 @@
         int compositeRule,
         MTLComposite* composite,
         const SurfaceRasterFlags * srcFlags,
         const SurfaceRasterFlags * dstFlags
 ) {
-    if (compositeRule == RULE_Src) {
-        J2dTraceLn(J2D_TRACE_VERBOSE, "set RULE_Src");
+    if (compositeRule == RULE_Src &&
+        (composite == nil || FLT_GE([composite getExtraAlpha], 1.0f))) {
+        J2dTraceLn(J2D_TRACE_VERBOSE, "set RULE_Src but blending is disabled because src is opaque");
         return;
     }
 
     cad.blendingEnabled = YES;
 
@@ -291,11 +292,11 @@
             // Cr = Cs + Cd*(1-As)
             if (srcFlags->isOpaque &&
                 (composite == nil ||
                  FLT_GE([composite getExtraAlpha], 1.0f)))
             {
-                J2dTraceLn(J2D_TRACE_VERBOSE, "rule=RULE_Src, but blending is disabled because src is opaque");
+                J2dTraceLn(J2D_TRACE_VERBOSE, "rule=RULE_SrcOver, but blending is disabled because src is opaque");
                 cad.blendingEnabled = NO;
                 return;
             }
             if (dstFlags->isOpaque) {
                 // Ar = 1, can be ignored, so

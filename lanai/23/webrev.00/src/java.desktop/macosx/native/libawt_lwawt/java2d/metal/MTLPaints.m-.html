<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPaints.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef HEADLESS
 27 
 28 #include &quot;MTLPaints.h&quot;
 29 
 30 #include &quot;MTLClip.h&quot;
 31 
 32 #include &quot;common.h&quot;
 33 
 34 #include &quot;sun_java2d_SunGraphics2D.h&quot;
 35 #include &quot;sun_java2d_pipe_BufferedPaints.h&quot;
 36 
 37 #define RGBA_TO_V4(c)              \
 38 {                                  \
 39     (((c) &gt;&gt; 16) &amp; (0xFF))/255.0f, \
 40     (((c) &gt;&gt; 8) &amp; 0xFF)/255.0f,    \
 41     ((c) &amp; 0xFF)/255.0f,           \
 42     (((c) &gt;&gt; 24) &amp; 0xFF)/255.0f    \
 43 }
 44 
 45 static MTLRenderPipelineDescriptor * templateRenderPipelineDesc = nil;
 46 static MTLRenderPipelineDescriptor * templateTexturePipelineDesc = nil;
 47 static MTLRenderPipelineDescriptor * templateAATexturePipelineDesc = nil;
 48 
 49 static void initTemplatePipelineDescriptors() {
 50     if (templateRenderPipelineDesc != nil &amp;&amp; templateTexturePipelineDesc != nil)
 51         return;
 52 
 53     MTLVertexDescriptor *vertDesc = [[MTLVertexDescriptor new] autorelease];
 54     vertDesc.attributes[VertexAttributePosition].format = MTLVertexFormatFloat2;
 55     vertDesc.attributes[VertexAttributePosition].offset = 0;
 56     vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;
 57     vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct Vertex);
 58     vertDesc.layouts[MeshVertexBuffer].stepRate = 1;
 59     vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
 60 
 61     templateRenderPipelineDesc = [[MTLRenderPipelineDescriptor new] autorelease];
 62     templateRenderPipelineDesc.sampleCount = 1;
 63     templateRenderPipelineDesc.vertexDescriptor = vertDesc;
 64     templateRenderPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;
 65     templateRenderPipelineDesc.label = @&quot;template_render&quot;;
 66 
 67     templateTexturePipelineDesc = [[templateRenderPipelineDesc copy] autorelease];
 68     templateTexturePipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].format = MTLVertexFormatFloat2;
 69     templateTexturePipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].offset = 2*sizeof(float);
 70     templateTexturePipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].bufferIndex = MeshVertexBuffer;
 71     templateTexturePipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stride = sizeof(struct TxtVertex);
 72     templateTexturePipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepRate = 1;
 73     templateTexturePipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
 74     templateTexturePipelineDesc.label = @&quot;template_texture&quot;;
 75 
 76     templateAATexturePipelineDesc = [[templateTexturePipelineDesc copy] autorelease];
 77     templateAATexturePipelineDesc.colorAttachments[0].sourceRGBBlendFactor = MTLBlendFactorOne;
 78     templateAATexturePipelineDesc.colorAttachments[0].sourceAlphaBlendFactor = MTLBlendFactorOne;
 79     templateAATexturePipelineDesc.colorAttachments[0].destinationRGBBlendFactor = MTLBlendFactorOneMinusSourceAlpha;
 80     templateAATexturePipelineDesc.colorAttachments[0].destinationAlphaBlendFactor = MTLBlendFactorOneMinusSourceAlpha;
 81     templateAATexturePipelineDesc.label = @&quot;template_aa_texture&quot;;
 82 
 83 }
 84 
 85 @implementation MTLPaint {
 86     // TODO: remove paintState, split into heirarchy of Paint-objects (i.e. PaintColor, PaintGrad, e.t.c)
 87     jint          _paintState;
 88 
 89     // color-mode
 90     jint          _color;
 91 
 92     // lin-grad-mode
 93     jdouble       _p0;
 94     jdouble       _p1;
 95     jdouble       _p3;
 96     jboolean      _cyclic;
 97     jint          _pixel1;
 98     jint          _pixel2;
 99     jboolean      _useMask;
100 
101     // texture paint
102     id&lt;MTLTexture&gt; _paintTexture;
103     struct AnchorData _anchor;
104 }
105 
106 - (id)init {
107     self = [super init];
108     if (self) {
109         _paintState = sun_java2d_SunGraphics2D_PAINT_UNDEFINED;
110     }
111     return self;
112 }
113 
114 - (BOOL)isEqual:(MTLPaint *)other {
115     if (self == other)
116         return YES;
117     if (_paintState == sun_java2d_SunGraphics2D_PAINT_UNDEFINED)
118         return _paintState == other-&gt;_paintState;
119     if (_paintState != other-&gt;_paintState)
120         return NO;
121     if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
122         return _p0 == other-&gt;_p0
123                &amp;&amp; _p1 == other-&gt;_p1
124                &amp;&amp; _p3 == other-&gt;_p3
125                &amp;&amp; _pixel1 == other-&gt;_pixel1
126                &amp;&amp; _pixel2 == other-&gt;_pixel2;
127     }
128     if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
129         return _color == other-&gt;_color;
130     }
131     if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
132         return _paintTexture == other-&gt;_paintTexture
133                &amp;&amp; _anchor.xParams[0] == other-&gt;_anchor.xParams[0]
134                &amp;&amp; _anchor.xParams[1] == other-&gt;_anchor.xParams[1]
135                &amp;&amp; _anchor.xParams[2] == other-&gt;_anchor.xParams[2]
136                &amp;&amp; _anchor.yParams[0] == other-&gt;_anchor.yParams[0]
137                &amp;&amp; _anchor.yParams[1] == other-&gt;_anchor.yParams[1]
138                &amp;&amp; _anchor.yParams[2] == other-&gt;_anchor.yParams[2];
139     }
140 
141     J2dTraceLn1(J2D_TRACE_ERROR, &quot;Unimplemented paint mode %d&quot;, _paintState);
142     return NO;
143 }
144 
145 - (void)copyFrom:(MTLPaint *)other {
146     _paintState = other-&gt;_paintState;
147     if (other-&gt;_paintState == sun_java2d_SunGraphics2D_PAINT_UNDEFINED)
148         return;
149 
150     if (other-&gt;_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
151         _p0 = other-&gt;_p0;
152         _p1 = other-&gt;_p1;
153         _p3 = other-&gt;_p3;
154         _pixel1 = other-&gt;_pixel1;
155         _pixel2 = other-&gt;_pixel2;
156         return;
157     }
158     if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
159         _color = other-&gt;_color;
160         return;
161     }
162 
163     if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
164         _color = other-&gt;_color;
165         _paintTexture = other-&gt;_paintTexture;
166         _anchor = other-&gt;_anchor;
167         return;
168     }
169 
170     J2dTraceLn1(J2D_TRACE_ERROR, &quot;Unsupported paint mode %d&quot;, _paintState);
171 }
172 
173 - (NSString *)getDescription {
174     if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
175         return [NSString stringWithFormat:@&quot;[r=%d g=%d b=%d a=%d]&quot;, (_color &gt;&gt; 16) &amp; (0xFF), (_color &gt;&gt; 8) &amp; 0xFF, (_color) &amp; 0xFF, (_color &gt;&gt; 24) &amp; 0xFF];
176     }
177     
178     if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
179         return [NSString stringWithFormat:@&quot;gradient&quot;];
180     }
181 
182     if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
183         return [NSString stringWithFormat:@&quot;texture_paint&quot;];
184     }
185 
186     return @&quot;unknown-paint&quot;;
187 }
188 
189 - (jint)getColor {
190     return _color;
191 }
192 
193 - (void)reset {
194     _paintState = sun_java2d_SunGraphics2D_PAINT_UNDEFINED;
195     _paintTexture = nil;
196     _anchor.xParams[0] = _anchor.xParams[1] = _anchor.xParams[2] = 0.0f;
197     _anchor.yParams[0] = _anchor.yParams[1] = _anchor.yParams[2] = 0.0f; 
198 }
199 
200 - (void)setColor:(jint)pixelColor {
201     _paintState = sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR;
202     _color = pixelColor;
203 }
204 
205 - (void)setGradientUseMask:(jboolean)useMask
206                     cyclic:(jboolean)cyclic
207                         p0:(jdouble)p0
208                         p1:(jdouble)p1
209                         p3:(jdouble)p3
210                     pixel1:(jint)pixel1
211                     pixel2:(jint)pixel2
212 {
213     //TODO Resolve gradient distribution problem
214     //TODO Implement useMask
215     //TODO Implement cyclic
216     //fprintf(stderr,
217     //        &quot;MTLPaints_SetGradientPaint useMask=%d cyclic=%d &quot;
218     //        &quot;p0=%f p1=%f p3=%f pix1=%d pix2=%d\n&quot;, useMask, cyclic,
219     //        p0, p1, p3, pixel1, pixel2);
220 
221     _paintState = sun_java2d_SunGraphics2D_PAINT_GRADIENT;
222     _useMask = useMask;
223     _pixel1 = pixel1;
224     _pixel2 = pixel2;
225     _p0 = p0;
226     _p1 = p1;
227     _p3 = p3;
228     _cyclic = cyclic;
229 }
230 
231 - (void)setLinearGradient:(jboolean)useMask
232                    linear:(jboolean)linear
233               cycleMethod:(jboolean)cycleMethod
234                  numStops:(jint)numStops
235                        p0:(jfloat)p0
236                        p1:(jfloat)p1
237                        p3:(jfloat)p3
238                 fractions:(void *)fractions
239                    pixels:(void *)pixels
240 {
241     J2dTraceLn(J2D_TRACE_ERROR, &quot;setLinearGradient: UNIMPLEMENTED&quot;);
242     [self setColor:0];
243 }
244 
245 - (void)setRadialGradient:(jboolean)useMask
246                    linear:(jboolean)linear
247               cycleMethod:(jboolean)cycleMethod
248                  numStops:(jint)numStops
249                       m00:(jfloat)m00
250                       m01:(jfloat)m01
251                       m02:(jfloat)m02
252                       m10:(jfloat)m10
253                       m11:(jfloat)m11
254                       m12:(jfloat)m12
255                    focusX:(jfloat)focusX
256                 fractions:(void *)fractions
257                    pixels:(void *)pixels
258 {
259     J2dTraceLn(J2D_TRACE_ERROR, &quot;setRadialGradient: UNIMPLEMENTED&quot;);
260     [self setColor:0];
261 }
262 
263 - (void)setTexture:(jboolean)useMask
264            textureID:(id&lt;MTLTexture&gt;)textureID
265             filter:(jboolean)filter
266                xp0:(jdouble)xp0
267                xp1:(jdouble)xp1
268                xp3:(jdouble)xp3
269                yp0:(jdouble)yp0
270                yp1:(jdouble)yp1
271                yp3:(jdouble)yp3
272 {
273     _paintState = sun_java2d_SunGraphics2D_PAINT_TEXTURE;
274     _paintTexture = textureID;
275     
276     _anchor.xParams[0] = xp0;
277     _anchor.xParams[1] = xp1;
278     _anchor.xParams[2] = xp3;
279 
280     _anchor.yParams[0] = yp0;
281     _anchor.yParams[1] = yp1;
282     _anchor.yParams[2] = yp3;
283 }
284 
285 // For the current paint mode:
286 // 1. Selects vertex+fragment shaders (and corresponding pipelineDesc) and set pipelineState
287 // 2. Set vertex and fragment buffers
288 - (void)setPipelineState:(id&lt;MTLRenderCommandEncoder&gt;)encoder
289                composite:(MTLComposite *)composite
290            isStencilUsed:(jboolean)isStencilUsed
291                isTexture:(jboolean)isTexture
292                     isAA:(jboolean)isAA
293                 srcFlags:(const SurfaceRasterFlags *)srcFlags
294                 dstFlags:(const SurfaceRasterFlags *)dstFlags
295     pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage
296 {
297     initTemplatePipelineDescriptors();
298 
299     const bool stencil = isStencilUsed == JNI_TRUE;
300 
301     id&lt;MTLRenderPipelineState&gt; pipelineState = nil;
302     if (isTexture) {
303 
304       if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
305         pipelineState = [pipelineStateStorage getPipelineState:templateTexturePipelineDesc
306                                                 vertexShaderId:@&quot;vert_txt_tp&quot;
307                                               fragmentShaderId:@&quot;frag_txt_tp&quot;
308                                                  compositeRule:[composite getRule]
309                                                           isAA:JNI_FALSE
310                                                       srcFlags:srcFlags
311                                                       dstFlags:dstFlags
312                                                  stencilNeeded:stencil];
313         [encoder setVertexBytes:&amp;_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];
314         [encoder setFragmentTexture:_paintTexture atIndex: 1];
315 
316         struct TxtFrameUniforms uf = {RGBA_TO_V4(0), 0, srcFlags-&gt;isOpaque,
317                                       dstFlags-&gt;isOpaque};
318         [encoder setFragmentBytes:&amp;uf length:sizeof(uf)
319                           atIndex:FrameUniformBuffer];
320 
321       } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
322         pipelineState = [pipelineStateStorage getPipelineState:templateTexturePipelineDesc
323                                                 vertexShaderId:@&quot;vert_txt_grad&quot;
324                                               fragmentShaderId:@&quot;frag_txt_grad&quot;
325                                                  compositeRule:[composite getRule]
326                                                           isAA:JNI_FALSE
327                                                       srcFlags:srcFlags
328                                                       dstFlags:dstFlags
329                                                  stencilNeeded:stencil];
330         struct GradFrameUniforms uf = {
331             {_p0, _p1, _p3},
332             RGBA_TO_V4(_pixel1),
333             RGBA_TO_V4(_pixel2)};
334         [encoder setFragmentBytes: &amp;uf length:sizeof(uf) atIndex:0];
335 
336       } else {
337         if (isAA) {
338           pipelineState = [pipelineStateStorage
339               getPipelineState:templateAATexturePipelineDesc
340                 vertexShaderId:@&quot;vert_txt&quot;
341               fragmentShaderId:@&quot;aa_frag_txt&quot;
342                  compositeRule:[composite getRule]
343                           isAA:JNI_FALSE
344                       srcFlags:srcFlags
345                       dstFlags:dstFlags
346                  stencilNeeded:stencil];
347 
348         } else {
349           pipelineState =
350               [pipelineStateStorage getPipelineState:templateTexturePipelineDesc
351                                       vertexShaderId:@&quot;vert_txt&quot;
352                                     fragmentShaderId:@&quot;frag_txt&quot;
353                                        compositeRule:[composite getRule]
354                                                 isAA:JNI_FALSE
355                                             srcFlags:srcFlags
356                                             dstFlags:dstFlags
357                                        stencilNeeded:stencil];
358         }
359 
360         if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
361           struct TxtFrameUniforms uf = {RGBA_TO_V4(_color), 1, srcFlags-&gt;isOpaque, dstFlags-&gt;isOpaque };
362           [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
363         } else {
364           struct TxtFrameUniforms uf = {RGBA_TO_V4(0), 0, srcFlags-&gt;isOpaque, dstFlags-&gt;isOpaque };
365           [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
366         }
367       }
368     } else {
369         if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
370             pipelineState = [pipelineStateStorage getPipelineState:templateRenderPipelineDesc
371                                                     vertexShaderId:@&quot;vert_col&quot;
372                                                   fragmentShaderId:@&quot;frag_col&quot;
373                                                      compositeRule:[composite getRule]
374                                                               isAA:isAA
375                                                           srcFlags:srcFlags
376                                                           dstFlags:dstFlags
377                                                      stencilNeeded:stencil];
378 
379             struct FrameUniforms uf = {RGBA_TO_V4(_color)};
380             [encoder setVertexBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
381         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
382             pipelineState = [pipelineStateStorage getPipelineState:templateRenderPipelineDesc
383                                                     vertexShaderId:@&quot;vert_grad&quot;
384                                                   fragmentShaderId:@&quot;frag_grad&quot;
385                                                      compositeRule:[composite getRule]
386                                                               isAA:isAA
387                                                           srcFlags:srcFlags
388                                                           dstFlags:dstFlags
389                                                      stencilNeeded:stencil];
390 
391             struct GradFrameUniforms uf = {
392                     {_p0, _p1, _p3},
393                     RGBA_TO_V4(_pixel1),
394                     RGBA_TO_V4(_pixel2)};
395             [encoder setFragmentBytes: &amp;uf length:sizeof(uf) atIndex:0];
396         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
397             pipelineState = [pipelineStateStorage getPipelineState:templateRenderPipelineDesc
398                                         vertexShaderId:@&quot;vert_tp&quot;
399                                       fragmentShaderId:@&quot;frag_tp&quot;
400                                          compositeRule:[composite getRule]
401                                                   isAA:isAA
402                                               srcFlags:srcFlags
403                                               dstFlags:dstFlags
404                                          stencilNeeded:stencil];
405 
406             [encoder setVertexBytes:&amp;_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];
407             [encoder setFragmentTexture:_paintTexture atIndex: 0];
408         }
409     }
410 
411     [encoder setRenderPipelineState:pipelineState];
412 }
413 
414 
415 // For the current paint mode: and for XOR composite - a separate method is added as fragment shader differ in some cases
416 // 1. Selects vertex+fragment shaders (and corresponding pipelineDesc) and set pipelineState
417 // 2. Set vertex and fragment buffers
418 - (void)setXorModePipelineState:(id&lt;MTLRenderCommandEncoder&gt;)encoder
419                composite:(MTLComposite *)composite
420            isStencilUsed:(jboolean)isStencilUsed
421                isTexture:(jboolean)isTexture
422                 srcFlags:(const SurfaceRasterFlags *)srcFlags
423                 dstFlags:(const SurfaceRasterFlags *)dstFlags
424     pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage {
425     initTemplatePipelineDescriptors();
426 
427     const bool stencil = isStencilUsed == JNI_TRUE;
428     jint xorColor = (jint) [composite getXorColor];
429 
430     id&lt;MTLRenderPipelineState&gt; pipelineState = nil;
431     if (isTexture) {
432           pipelineState = [pipelineStateStorage getXorModePipelineState:templateTexturePipelineDesc
433                                           vertexShaderId:@&quot;vert_txt&quot;
434                                         fragmentShaderId:@&quot;frag_txt&quot;
435                                                 srcFlags:srcFlags
436                                                 dstFlags:dstFlags
437                                            stencilNeeded:stencil];
438 
439         if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
440             struct TxtFrameUniforms uf = {RGBA_TO_V4(_color ^ xorColor), 1, srcFlags-&gt;isOpaque, dstFlags-&gt;isOpaque };
441             [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
442         } else {
443             struct TxtFrameUniforms uf = {RGBA_TO_V4(0 ^ xorColor), 0, srcFlags-&gt;isOpaque, dstFlags-&gt;isOpaque };
444             [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
445         }
446         [encoder setFragmentBytes:&amp;xorColor length:sizeof(xorColor) atIndex: 0];
447     } else {
448         if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
449 
450             pipelineState = [pipelineStateStorage getXorModePipelineState:templateRenderPipelineDesc
451                                         vertexShaderId:@&quot;vert_col&quot;
452                                       fragmentShaderId:@&quot;frag_col&quot;
453                                               srcFlags:srcFlags
454                                               dstFlags:dstFlags
455                                          stencilNeeded:stencil];
456 
457             // Calculate _color ^ xorColor for RGB components
458             // This color gets XORed with destination framebuffer pixel color
459             struct FrameUniforms uf = {RGBA_TO_V4(_color ^ xorColor)};
460             [encoder setVertexBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
461 
462         } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {
463 
464             pipelineState = [pipelineStateStorage getXorModePipelineState:templateRenderPipelineDesc
465                                         vertexShaderId:@&quot;vert_grad&quot;
466                                       fragmentShaderId:@&quot;frag_grad&quot;
467                                               srcFlags:srcFlags
468                                               dstFlags:dstFlags
469                                          stencilNeeded:stencil];
470 
471                 struct GradFrameUniforms uf = {
472                         {_p0, _p1, _p3},
473                         RGBA_TO_V4(_pixel1 ^ xorColor),
474                         RGBA_TO_V4(_pixel2 ^ xorColor)};
475                 [encoder setFragmentBytes: &amp;uf length:sizeof(uf) atIndex:0];
476             } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {
477 
478                 pipelineState = [pipelineStateStorage getXorModePipelineState:templateRenderPipelineDesc
479                                             vertexShaderId:@&quot;vert_tp&quot;
480                                           fragmentShaderId:@&quot;frag_tp_xorMode&quot;
481                                                   srcFlags:srcFlags
482                                                   dstFlags:dstFlags
483                                              stencilNeeded:stencil];
484 
485                 [encoder setVertexBytes:&amp;_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];
486                 [encoder setFragmentTexture:_paintTexture atIndex: 0];
487                 [encoder setFragmentBytes:&amp;xorColor length:sizeof(xorColor) atIndex: 0];
488             }
489         }
490     [encoder setRenderPipelineState:pipelineState];
491 }
492 
493 @end
494 
495 /************************* GradientPaint support ****************************/
496 
497 static void
498 MTLPaints_InitGradientTexture()
499 {
500     //TODO
501     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints_InitGradientTexture -- :TODO&quot;);
502 }
503 
504 /****************** Shared MultipleGradientPaint support ********************/
505 
506 /**
507  * These constants are identical to those defined in the
508  * MultipleGradientPaint.CycleMethod enum; they are copied here for
509  * convenience (ideally we would pull them directly from the Java level,
510  * but that entails more hassle than it is worth).
511  */
512 #define CYCLE_NONE    0
513 #define CYCLE_REFLECT 1
514 #define CYCLE_REPEAT  2
515 
516 /**
517  * The following constants are flags that can be bitwise-or&#39;ed together
518  * to control how the MultipleGradientPaint shader source code is generated:
519  *
520  *   MULTI_CYCLE_METHOD
521  *     Placeholder for the CycleMethod enum constant.
522  *
523  *   MULTI_LARGE
524  *     If set, use the (slower) shader that supports a larger number of
525  *     gradient colors; otherwise, use the optimized codepath.  See
526  *     the MAX_FRACTIONS_SMALL/LARGE constants below for more details.
527  *
528  *   MULTI_USE_MASK
529  *     If set, apply the alpha mask value from texture unit 0 to the
530  *     final color result (only used in the MaskFill case).
531  *
532  *   MULTI_LINEAR_RGB
533  *     If set, convert the linear RGB result back into the sRGB color space.
534  */
535 #define MULTI_CYCLE_METHOD (3 &lt;&lt; 0)
536 #define MULTI_LARGE        (1 &lt;&lt; 2)
537 #define MULTI_USE_MASK     (1 &lt;&lt; 3)
538 #define MULTI_LINEAR_RGB   (1 &lt;&lt; 4)
539 
540 /**
541  * This value determines the size of the array of programs for each
542  * MultipleGradientPaint type.  This value reflects the maximum value that
543  * can be represented by performing a bitwise-or of all the MULTI_*
544  * constants defined above.
545  */
546 #define MAX_PROGRAMS 32
547 
548 /** Evaluates to true if the given bit is set on the local flags variable. */
549 #define IS_SET(flagbit) \
550     (((flags) &amp; (flagbit)) != 0)
551 
552 /** Composes the given parameters as flags into the given flags variable.*/
553 #define COMPOSE_FLAGS(flags, cycleMethod, large, useMask, linear) \
554     do {                                                   \
555         flags |= ((cycleMethod) &amp; MULTI_CYCLE_METHOD);     \
556         if (large)   flags |= MULTI_LARGE;                 \
557         if (useMask) flags |= MULTI_USE_MASK;              \
558         if (linear)  flags |= MULTI_LINEAR_RGB;            \
559     } while (0)
560 
561 /** Extracts the CycleMethod enum value from the given flags variable. */
562 #define EXTRACT_CYCLE_METHOD(flags) \
563     ((flags) &amp; MULTI_CYCLE_METHOD)
564 
565 /**
566  * The maximum number of gradient &quot;stops&quot; supported by the fragment shader
567  * and related code.  When the MULTI_LARGE flag is set, we will use
568  * MAX_FRACTIONS_LARGE; otherwise, we use MAX_FRACTIONS_SMALL.  By having
569  * two separate values, we can have one highly optimized shader (SMALL) that
570  * supports only a few fractions/colors, and then another, less optimal
571  * shader that supports more stops.
572  */
573 #define MAX_FRACTIONS sun_java2d_pipe_BufferedPaints_MULTI_MAX_FRACTIONS
574 #define MAX_FRACTIONS_LARGE MAX_FRACTIONS
575 #define MAX_FRACTIONS_SMALL 4
576 
577 /**
578  * The maximum number of gradient colors supported by all of the gradient
579  * fragment shaders.  Note that this value must be a power of two, as it
580  * determines the size of the 1D texture created below.  It also must be
581  * greater than or equal to MAX_FRACTIONS (there is no strict requirement
582  * that the two values be equal).
583  */
584 #define MAX_COLORS 16
585 
586 /**
587  * The handle to the gradient color table texture object used by the shaders.
588  */
589 static jint multiGradientTexID = 0;
590 
591 /**
592  * This is essentially a template of the shader source code that can be used
593  * for either LinearGradientPaint or RadialGradientPaint.  It includes the
594  * structure and some variables that are common to each; the remaining
595  * code snippets (for CycleMethod, ColorSpaceType, and mask modulation)
596  * are filled in prior to compiling the shader at runtime depending on the
597  * paint parameters.  See MTLPaints_CreateMultiGradProgram() for more details.
598  */
599 static const char *multiGradientShaderSource =
600     // gradient texture size (in texels)
601     &quot;const int TEXTURE_SIZE = %d;&quot;
602     // maximum number of fractions/colors supported by this shader
603     &quot;const int MAX_FRACTIONS = %d;&quot;
604     // size of a single texel
605     &quot;const float FULL_TEXEL = (1.0 / float(TEXTURE_SIZE));&quot;
606     // size of half of a single texel
607     &quot;const float HALF_TEXEL = (FULL_TEXEL / 2.0);&quot;
608     // texture containing the gradient colors
609     &quot;uniform sampler1D colors;&quot;
610     // array of gradient stops/fractions
611     &quot;uniform float fractions[MAX_FRACTIONS];&quot;
612     // array of scale factors (one for each interval)
613     &quot;uniform float scaleFactors[MAX_FRACTIONS-1];&quot;
614     // (placeholder for mask variable)
615     &quot;%s&quot;
616     // (placeholder for Linear/RadialGP-specific variables)
617     &quot;%s&quot;
618     &quot;&quot;
619     &quot;void main(void)&quot;
620     &quot;{&quot;
621     &quot;    float dist;&quot;
622          // (placeholder for Linear/RadialGradientPaint-specific code)
623     &quot;    %s&quot;
624     &quot;&quot;
625     &quot;    float tc;&quot;
626          // (placeholder for CycleMethod-specific code)
627     &quot;    %s&quot;
628     &quot;&quot;
629          // calculate interpolated color
630     &quot;    vec4 result = texture1D(colors, tc);&quot;
631     &quot;&quot;
632          // (placeholder for ColorSpace conversion code)
633     &quot;    %s&quot;
634     &quot;&quot;
635          // (placeholder for mask modulation code)
636     &quot;    %s&quot;
637     &quot;&quot;
638          // modulate with gl_Color in order to apply extra alpha
639     &quot;    gl_FragColor = result * gl_Color;&quot;
640     &quot;}&quot;;
641 
642 /**
643  * This code takes a &quot;dist&quot; value as input (as calculated earlier by the
644  * LGP/RGP-specific code) in the range [0,1] and produces a texture
645  * coordinate value &quot;tc&quot; that represents the position of the chosen color
646  * in the one-dimensional gradient texture (also in the range [0,1]).
647  *
648  * One naive way to implement this would be to iterate through the fractions
649  * to figure out in which interval &quot;dist&quot; falls, and then compute the
650  * relative distance between the two nearest stops.  This approach would
651  * require an &quot;if&quot; check on every iteration, and it is best to avoid
652  * conditionals in fragment shaders for performance reasons.  Also, one might
653  * be tempted to use a break statement to jump out of the loop once the
654  * interval was found, but break statements (and non-constant loop bounds)
655  * are not natively available on most graphics hardware today, so that is
656  * a non-starter.
657  *
658  * The more optimal approach used here avoids these issues entirely by using
659  * an accumulation function that is equivalent to the process described above.
660  * The scaleFactors array is pre-initialized at enable time as follows:
661  *     scaleFactors[i] = 1.0 / (fractions[i+1] - fractions[i]);
662  *
663  * For each iteration, we subtract fractions[i] from dist and then multiply
664  * that value by scaleFactors[i].  If we are within the target interval,
665  * this value will be a fraction in the range [0,1] indicating the relative
666  * distance between fraction[i] and fraction[i+1].  If we are below the
667  * target interval, this value will be negative, so we clamp it to zero
668  * to avoid accumulating any value.  If we are above the target interval,
669  * the value will be greater than one, so we clamp it to one.  Upon exiting
670  * the loop, we will have accumulated zero or more 1.0&#39;s and a single
671  * fractional value.  This accumulated value tells us the position of the
672  * fragment color in the one-dimensional gradient texture, i.e., the
673  * texcoord called &quot;tc&quot;.
674  */
675 static const char *texCoordCalcCode =
676     &quot;int i;&quot;
677     &quot;float relFraction = 0.0;&quot;
678     &quot;for (i = 0; i &lt; MAX_FRACTIONS-1; i++) {&quot;
679     &quot;    relFraction +=&quot;
680     &quot;        clamp((dist - fractions[i]) * scaleFactors[i], 0.0, 1.0);&quot;
681     &quot;}&quot;
682     // we offset by half a texel so that we find the linearly interpolated
683     // color between the two texel centers of interest
684     &quot;tc = HALF_TEXEL + (FULL_TEXEL * relFraction);&quot;;
685 
686 /** Code for NO_CYCLE that gets plugged into the CycleMethod placeholder. */
687 static const char *noCycleCode =
688     &quot;if (dist &lt;= 0.0) {&quot;
689     &quot;    tc = 0.0;&quot;
690     &quot;} else if (dist &gt;= 1.0) {&quot;
691     &quot;    tc = 1.0;&quot;
692     &quot;} else {&quot;
693          // (placeholder for texcoord calculation)
694     &quot;    %s&quot;
695     &quot;}&quot;;
696 
697 /** Code for REFLECT that gets plugged into the CycleMethod placeholder. */
698 static const char *reflectCode =
699     &quot;dist = 1.0 - (abs(fract(dist * 0.5) - 0.5) * 2.0);&quot;
700     // (placeholder for texcoord calculation)
701     &quot;%s&quot;;
702 
703 /** Code for REPEAT that gets plugged into the CycleMethod placeholder. */
704 static const char *repeatCode =
705     &quot;dist = fract(dist);&quot;
706     // (placeholder for texcoord calculation)
707     &quot;%s&quot;;
708 
709 static void
710 MTLPaints_InitMultiGradientTexture()
711 {
712     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints_InitMultiGradientTexture -- :TODO&quot;);
713 }
714 
715 /**
716  * Compiles and links the MultipleGradientPaint shader program.  If
717  * successful, this function returns a handle to the newly created
718  * shader program; otherwise returns 0.
719  */
720 static void*
721 MTLPaints_CreateMultiGradProgram(jint flags,
722                                  char *paintVars, char *distCode)
723 {
724 
725     //TODO
726     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints_CreateMultiGradProgram -- :TODO&quot;);
727 
728     return NULL;
729 }
730 
731 /**
732  * Called from the MTLPaints_SetLinear/RadialGradientPaint() methods
733  * in order to setup the fraction/color values that are common to both.
734  */
735 static void
736 MTLPaints_SetMultiGradientPaint(void* multiGradProgram,
737                                 jint numStops,
738                                 void *pFractions, void *pPixels)
739 {
740     //TODO
741     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLPaints_SetMultiGradientPaint -- :TODO&quot;);
742 
743 }
744 
745 /********************** LinearGradientPaint support *************************/
746 
747 /**
748  * The handles to the LinearGradientPaint fragment program objects.  The
749  * index to the array should be a bitwise-or&#39;ing of the MULTI_* flags defined
750  * above.  Note that most applications will likely need to initialize one
751  * or two of these elements, so the array is usually sparsely populated.
752  */
753 static void* linearGradPrograms[MAX_PROGRAMS];
754 
755 /**
756  * Compiles and links the LinearGradientPaint shader program.  If successful,
757  * this function returns a handle to the newly created shader program;
758  * otherwise returns 0.
759  */
760 static void*
761 MTLPaints_CreateLinearGradProgram(jint flags)
762 {
763     char *paintVars;
764     char *distCode;
765 
766     J2dTraceLn1(J2D_TRACE_INFO,
767                 &quot;MTLPaints_CreateLinearGradProgram&quot;,
768                 flags);
769 
770     /*
771      * To simplify the code and to make it easier to upload a number of
772      * uniform values at once, we pack a bunch of scalar (float) values
773      * into vec3 values below.  Here&#39;s how the values are related:
774      *
775      *   params.x = p0
776      *   params.y = p1
777      *   params.z = p3
778      *
779      *   yoff = dstOps-&gt;yOffset + dstOps-&gt;height
780      */
781     paintVars =
782         &quot;uniform vec3 params;&quot;
783         &quot;uniform float yoff;&quot;;
784     distCode =
785         // note that gl_FragCoord is in window space relative to the
786         // lower-left corner, so we have to flip the y-coordinate here
787         &quot;vec3 fragCoord = vec3(gl_FragCoord.x, yoff-gl_FragCoord.y, 1.0);&quot;
788         &quot;dist = dot(params, fragCoord);&quot;;
789 
790     return MTLPaints_CreateMultiGradProgram(flags, paintVars, distCode);
791 }
792 
793 /********************** RadialGradientPaint support *************************/
794 
795 /**
796  * The handles to the RadialGradientPaint fragment program objects.  The
797  * index to the array should be a bitwise-or&#39;ing of the MULTI_* flags defined
798  * above.  Note that most applications will likely need to initialize one
799  * or two of these elements, so the array is usually sparsely populated.
800  */
801 static void* radialGradPrograms[MAX_PROGRAMS];
802 
803 /**
804  * Compiles and links the RadialGradientPaint shader program.  If successful,
805  * this function returns a handle to the newly created shader program;
806  * otherwise returns 0.
807  */
808 static void*
809 MTLPaints_CreateRadialGradProgram(jint flags)
810 {
811     char *paintVars;
812     char *distCode;
813 
814     J2dTraceLn1(J2D_TRACE_INFO,
815                 &quot;MTLPaints_CreateRadialGradProgram&quot;,
816                 flags);
817 
818     /*
819      * To simplify the code and to make it easier to upload a number of
820      * uniform values at once, we pack a bunch of scalar (float) values
821      * into vec3 and vec4 values below.  Here&#39;s how the values are related:
822      *
823      *   m0.x = m00
824      *   m0.y = m01
825      *   m0.z = m02
826      *
827      *   m1.x = m10
828      *   m1.y = m11
829      *   m1.z = m12
830      *
831      *   precalc.x = focusX
832      *   precalc.y = yoff = dstOps-&gt;yOffset + dstOps-&gt;height
833      *   precalc.z = 1.0 - (focusX * focusX)
834      *   precalc.w = 1.0 / precalc.z
835      */
836     paintVars =
837         &quot;uniform vec3 m0;&quot;
838         &quot;uniform vec3 m1;&quot;
839         &quot;uniform vec4 precalc;&quot;;
840 
841     /*
842      * The following code is derived from Daniel Rice&#39;s whitepaper on
843      * radial gradient performance (attached to the bug report for 6521533).
844      * Refer to that document as well as the setup code in the Java-level
845      * BufferedPaints.setRadialGradientPaint() method for more details.
846      */
847     distCode =
848         // note that gl_FragCoord is in window space relative to the
849         // lower-left corner, so we have to flip the y-coordinate here
850         &quot;vec3 fragCoord =&quot;
851         &quot;    vec3(gl_FragCoord.x, precalc.y - gl_FragCoord.y, 1.0);&quot;
852         &quot;float x = dot(fragCoord, m0);&quot;
853         &quot;float y = dot(fragCoord, m1);&quot;
854         &quot;float xfx = x - precalc.x;&quot;
855         &quot;dist = (precalc.x*xfx + sqrt(xfx*xfx + y*y*precalc.z))*precalc.w;&quot;;
856 
857     return MTLPaints_CreateMultiGradProgram(flags, paintVars, distCode);
858 }
859 
860 #endif /* !HEADLESS */
    </pre>
  </body>
</html>
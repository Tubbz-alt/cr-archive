<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLRenderQueue.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #ifndef HEADLESS
  27 
  28 #include &lt;stdlib.h&gt;
  29 
  30 #include &quot;sun_java2d_pipe_BufferedOpCodes.h&quot;
  31 
  32 #include &quot;jlong.h&quot;
  33 #include &quot;MTLBlitLoops.h&quot;
  34 #include &quot;MTLBufImgOps.h&quot;
  35 #include &quot;MTLMaskBlit.h&quot;
  36 #include &quot;MTLMaskFill.h&quot;
  37 #include &quot;MTLPaints.h&quot;
  38 #include &quot;MTLRenderQueue.h&quot;
  39 #include &quot;MTLRenderer.h&quot;
  40 #include &quot;MTLTextRenderer.h&quot;
  41 #import &quot;ThreadUtilities.h&quot;
  42 
  43 /**
  44  * References to the &quot;current&quot; context and destination surface.
  45  */
  46 static MTLContext *mtlc = NULL;
  47 static BMTLSDOps *dstOps = NULL;
  48 jint mtlPreviousOp = MTL_OP_INIT;
  49 
  50 /**
  51  * The following methods are implemented in the windowing system (i.e. GLX
  52  * and WGL) source files.
  53  */
  54 extern void MTLGC_DestroyMTLGraphicsConfig(jlong pConfigInfo);
  55 extern void MTLSD_SwapBuffers(JNIEnv *env, jlong window);
  56 
  57 // TODO : Debug logic added for opcode verification,
  58 // should be removed later.
  59 static char *getOpcodeString(jint opcode) {
  60     static char opName[30];
  61     switch (opcode) {
  62         case sun_java2d_pipe_BufferedOpCodes_DRAW_LINE:
  63             {
  64                 strcpy(opName, &quot;DRAW_LINE&quot;);
  65             }
  66             break;
  67         case sun_java2d_pipe_BufferedOpCodes_DRAW_RECT:
  68             {
  69                 strcpy(opName, &quot;DRAW_RECT&quot;);
  70             }
  71             break;
  72         case sun_java2d_pipe_BufferedOpCodes_DRAW_POLY:
  73             {
  74                 strcpy(opName, &quot;DRAW_POLY&quot;);
  75             }
  76             break;
  77         case sun_java2d_pipe_BufferedOpCodes_DRAW_PIXEL:
  78             {
  79                 strcpy(opName, &quot;DRAW_PIXEL&quot;);
  80             }
  81             break;
  82         case sun_java2d_pipe_BufferedOpCodes_DRAW_SCANLINES:
  83             {
  84                 strcpy(opName, &quot;DRAW_SCANLINES&quot;);
  85             }
  86             break;
  87         case sun_java2d_pipe_BufferedOpCodes_DRAW_PARALLELOGRAM:
  88             {
  89                 strcpy(opName, &quot;DRAW_PARALLELOGRAM&quot;);
  90             }
  91             break;
  92         case sun_java2d_pipe_BufferedOpCodes_DRAW_AAPARALLELOGRAM:
  93             {
  94                 strcpy(opName, &quot;DRAW_AAPARALLELOGRAM&quot;);
  95             }
  96             break;
  97         case sun_java2d_pipe_BufferedOpCodes_FILL_RECT:
  98             {
  99                 strcpy(opName, &quot;FILL_RECT&quot;);
 100             }
 101             break;
 102         case sun_java2d_pipe_BufferedOpCodes_FILL_SPANS:
 103             {
 104                 strcpy(opName, &quot;FILL_SPANS&quot;);
 105             }
 106             break;
 107         case sun_java2d_pipe_BufferedOpCodes_FILL_PARALLELOGRAM:
 108             {
 109                 strcpy(opName, &quot;FILL_PARALLELOGRAM&quot;);
 110             }
 111             break;
 112         case sun_java2d_pipe_BufferedOpCodes_FILL_AAPARALLELOGRAM:
 113             {
 114                 strcpy(opName, &quot;FILL_AAPARALLELOGRAM&quot;);
 115             }
 116             break;
 117         case sun_java2d_pipe_BufferedOpCodes_DRAW_GLYPH_LIST:
 118             {
 119                 strcpy(opName, &quot;DRAW_GLYPH_LIST&quot;);
 120             }
 121             break;
 122         case sun_java2d_pipe_BufferedOpCodes_COPY_AREA:
 123             {
 124                 strcpy(opName, &quot;COPY_AREA&quot;);
 125             }
 126             break;
 127         case sun_java2d_pipe_BufferedOpCodes_BLIT:
 128             {
 129                 strcpy(opName, &quot;BLIT&quot;);
 130             }
 131             break;
 132         case sun_java2d_pipe_BufferedOpCodes_SURFACE_TO_SW_BLIT:
 133             {
 134                 strcpy(opName, &quot;SURFACE_TO_SW_BLIT&quot;);
 135             }
 136             break;
 137         case sun_java2d_pipe_BufferedOpCodes_MASK_FILL:
 138             {
 139                 strcpy(opName, &quot;MASK_FILL&quot;);
 140             }
 141             break;
 142         case sun_java2d_pipe_BufferedOpCodes_MASK_BLIT:
 143             {
 144 
 145                 strcpy(opName, &quot;MASK_BLIT&quot;);
 146             }
 147             break;
 148         case sun_java2d_pipe_BufferedOpCodes_SET_RECT_CLIP:
 149             {
 150                 strcpy(opName, &quot;SET_RECT_CLIP&quot;);
 151             }
 152             break;
 153         case sun_java2d_pipe_BufferedOpCodes_BEGIN_SHAPE_CLIP:
 154             {
 155                 strcpy(opName, &quot;BEGIN_SHAPE_CLIP&quot;);
 156             }
 157             break;
 158         case sun_java2d_pipe_BufferedOpCodes_SET_SHAPE_CLIP_SPANS:
 159             {
 160                 strcpy(opName, &quot;SET_SHAPE_CLIP_SPANS&quot;);
 161             }
 162             break;
 163         case sun_java2d_pipe_BufferedOpCodes_END_SHAPE_CLIP:
 164             {
 165                 strcpy(opName, &quot;END_SHAPE_CLIP&quot;);
 166             }
 167             break;
 168         case sun_java2d_pipe_BufferedOpCodes_RESET_CLIP:
 169             {
 170                 strcpy(opName, &quot;RESET_CLIP&quot;);
 171             }
 172             break;
 173         case sun_java2d_pipe_BufferedOpCodes_SET_ALPHA_COMPOSITE:
 174             {
 175                 strcpy(opName, &quot;SET_ALPHA_COMPOSITE&quot;);
 176             }
 177             break;
 178         case sun_java2d_pipe_BufferedOpCodes_SET_XOR_COMPOSITE:
 179             {
 180                 strcpy(opName, &quot;SET_XOR_COMPOSITE&quot;);
 181             }
 182             break;
 183         case sun_java2d_pipe_BufferedOpCodes_RESET_COMPOSITE:
 184             {
 185                 strcpy(opName, &quot;RESET_COMPOSITE&quot;);
 186             }
 187             break;
 188         case sun_java2d_pipe_BufferedOpCodes_SET_TRANSFORM:
 189             {
 190                 strcpy(opName, &quot;SET_TRANSFORM&quot;);
 191             }
 192             break;
 193         case sun_java2d_pipe_BufferedOpCodes_RESET_TRANSFORM:
 194             {
 195                 strcpy(opName, &quot;RESET_TRANSFORM&quot;);
 196             }
 197             break;
 198         case sun_java2d_pipe_BufferedOpCodes_SET_SURFACES:
 199             {
 200 
 201                 strcpy(opName, &quot;SET_SURFACES&quot;);
 202             }
 203             break;
 204         case sun_java2d_pipe_BufferedOpCodes_SET_SCRATCH_SURFACE:
 205             {
 206                 strcpy(opName, &quot;SET_SCRATCH_SURFACE&quot;);
 207             }
 208             break;
 209         case sun_java2d_pipe_BufferedOpCodes_FLUSH_SURFACE:
 210             {
 211                 strcpy(opName, &quot;FLUSH_SURFACE&quot;);
 212             }
 213             break;
 214         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_SURFACE:
 215             {
 216                 strcpy(opName, &quot;DISPOSE_SURFACE&quot;);
 217             }
 218             break;
 219         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_CONFIG:
 220             {
 221                 strcpy(opName, &quot;DISPOSE_CONFIG&quot;);
 222             }
 223             break;
 224         case sun_java2d_pipe_BufferedOpCodes_INVALIDATE_CONTEXT:
 225             {
 226                 strcpy(opName, &quot;INVALIDATE_CONTEXT&quot;);
 227             }
 228             break;
 229         case sun_java2d_pipe_BufferedOpCodes_SYNC:
 230             {
 231                 strcpy(opName, &quot;SYNC&quot;);
 232 
 233             }
 234             break;
 235         case sun_java2d_pipe_BufferedOpCodes_SWAP_BUFFERS:
 236             {
 237                 strcpy(opName, &quot;SWAP_BUFFERS&quot;);
 238             }
 239             break;
 240         case sun_java2d_pipe_BufferedOpCodes_NOOP:
 241             strcpy(opName, &quot;NOOP&quot;);
 242             break;
 243         case sun_java2d_pipe_BufferedOpCodes_RESET_PAINT:
 244             {
 245                 strcpy(opName, &quot;RESET_PAINT&quot;);
 246             }
 247             break;
 248         case sun_java2d_pipe_BufferedOpCodes_SET_COLOR:
 249             {
 250                 strcpy(opName, &quot;SET_COLOR&quot;);
 251             }
 252             break;
 253         case sun_java2d_pipe_BufferedOpCodes_SET_GRADIENT_PAINT:
 254             {
 255                 strcpy(opName, &quot;SET_GRADIENT_PAINT&quot;);
 256             }
 257             break;
 258         case sun_java2d_pipe_BufferedOpCodes_SET_LINEAR_GRADIENT_PAINT:
 259             {
 260                 strcpy(opName, &quot;SET_LINEAR_GRADIENT_PAINT&quot;);
 261             }
 262             break;
 263         case sun_java2d_pipe_BufferedOpCodes_SET_RADIAL_GRADIENT_PAINT:
 264             {
 265                 strcpy(opName, &quot;SET_RADIAL_GRADIENT_PAINT&quot;);
 266             }
 267             break;
 268         case sun_java2d_pipe_BufferedOpCodes_SET_TEXTURE_PAINT:
 269             {
 270                 strcpy(opName, &quot;SET_TEXTURE_PAINT&quot;);
 271             }
 272             break;
 273         case sun_java2d_pipe_BufferedOpCodes_ENABLE_CONVOLVE_OP:
 274             {
 275                 strcpy(opName, &quot;ENABLE_CONVOLVE_OP&quot;);
 276             }
 277             break;
 278         case sun_java2d_pipe_BufferedOpCodes_DISABLE_CONVOLVE_OP:
 279             {
 280                 strcpy(opName, &quot;DISABLE_CONVOLVE_OP&quot;);
 281             }
 282             break;
 283         case sun_java2d_pipe_BufferedOpCodes_ENABLE_RESCALE_OP:
 284             {
 285                 strcpy(opName, &quot;ENABLE_RESCALE_OP&quot;);
 286             }
 287             break;
 288         case sun_java2d_pipe_BufferedOpCodes_DISABLE_RESCALE_OP:
 289             {
 290                  strcpy(opName, &quot;DISABLE_RESCALE_OP&quot;);
 291             }
 292             break;
 293         case sun_java2d_pipe_BufferedOpCodes_ENABLE_LOOKUP_OP:
 294             {
 295                 strcpy(opName, &quot;ENABLE_LOOKUP_OP&quot;);
 296             }
 297             break;
 298         case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:
 299             {
 300                 strcpy(opName, &quot;DISABLE_LOOKUP_OP&quot;);
 301             }
 302             break;
 303         default:
 304             strcpy(opName, &quot;UNKNOWN&quot;);
 305             break;
 306         }
 307     return opName;
 308 }
 309 
 310 void MTLRenderQueue_CheckPreviousOp(jint op) {
 311 
 312     if (mtlPreviousOp == op) {
 313         // The op is the same as last time, so we can return immediately.
 314         return;
 315     }
 316 
 317     J2dTraceLn1(J2D_TRACE_VERBOSE,
 318                 &quot;MTLRenderQueue_CheckPreviousOp: new op=%d&quot;, op);
 319 
 320     if (op == MTL_OP_SET_COLOR) {
 321         return; // SET_COLOR should not cause endEncoder
 322     }
 323 
 324     if (mtlPreviousOp == MTL_OP_INIT) {
 325         mtlPreviousOp = op;
 326         return;
 327     }
 328 
 329     if (mtlc != NULL) {
 330         [mtlc.encoderManager endEncoder];
<a name="1" id="anc1"></a><span class="line-added"> 331 </span>
<span class="line-added"> 332         if (op == MTL_OP_RESET_PAINT || op == MTL_OP_SYNC) {</span>
<span class="line-added"> 333             MTLCommandBufferWrapper *cbwrapper = [mtlc pullCommandBufferWrapper];</span>
<span class="line-added"> 334             id &lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];</span>
<span class="line-added"> 335             [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {</span>
<span class="line-added"> 336                 [cbwrapper release];</span>
<span class="line-added"> 337             }];</span>
<span class="line-added"> 338             [commandbuf commit];</span>
<span class="line-added"> 339             if (op == MTL_OP_SYNC) {</span>
<span class="line-added"> 340                 [commandbuf waitUntilCompleted];</span>
<span class="line-added"> 341             }</span>
<span class="line-added"> 342         }</span>
 343     }
 344     mtlPreviousOp = op;
 345 }
 346 
 347 JNIEXPORT void JNICALL
 348 Java_sun_java2d_metal_MTLRenderQueue_flushBuffer
 349     (JNIEnv *env, jobject mtlrq,
 350      jlong buf, jint limit)
 351 {
<a name="2" id="anc2"></a>
 352     unsigned char *b, *end;
 353 
 354     J2dTraceLn1(J2D_TRACE_INFO,
 355                 &quot;MTLRenderQueue_flushBuffer: limit=%d&quot;, limit);
 356 
 357     b = (unsigned char *)jlong_to_ptr(buf);
 358     if (b == NULL) {
 359         J2dRlsTraceLn(J2D_TRACE_ERROR,
 360             &quot;MTLRenderQueue_flushBuffer: cannot get direct buffer address&quot;);
 361         return;
 362     }
 363 
 364     end = b + limit;
 365 
 366     jboolean DEBUG_LOG = JNI_FALSE;
 367     while (b &lt; end) {
 368         jint opcode = NEXT_INT(b);
 369 
 370         if (DEBUG_LOG) {
 371             J2dTraceLn2(J2D_TRACE_ERROR,
 372                     &quot;MTLRenderQueue_flushBuffer: opcode_name = %s, rem=%d&quot;,
 373                     getOpcodeString(opcode), (end-b));
 374         } else {
 375             J2dTraceLn2(J2D_TRACE_VERBOSE,
 376                     &quot;MTLRenderQueue_flushBuffer: opcode=%d, rem=%d&quot;,
 377                     opcode, (end-b));
 378         }
 379 
 380         switch (opcode) {
 381 
 382         // draw ops
 383         case sun_java2d_pipe_BufferedOpCodes_DRAW_LINE:
 384             {
 385                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 386                 J2dTraceLn(J2D_TRACE_VERBOSE, &quot;sun_java2d_pipe_BufferedOpCodes_DRAW_LINE&quot;);
 387                 jint x1 = NEXT_INT(b);
 388                 jint y1 = NEXT_INT(b);
 389                 jint x2 = NEXT_INT(b);
 390                 jint y2 = NEXT_INT(b);
 391                 MTLRenderer_DrawLine(mtlc, dstOps, x1, y1, x2, y2);
 392             }
 393             break;
 394         case sun_java2d_pipe_BufferedOpCodes_DRAW_RECT:
 395             {
 396                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 397                 jint x = NEXT_INT(b);
 398                 jint y = NEXT_INT(b);
 399                 jint w = NEXT_INT(b);
 400                 jint h = NEXT_INT(b);
 401                 MTLRenderer_DrawRect(mtlc, dstOps, x, y, w, h);
 402             }
 403             break;
 404         case sun_java2d_pipe_BufferedOpCodes_DRAW_POLY:
 405             {
 406                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 407                 jint nPoints      = NEXT_INT(b);
 408                 jboolean isClosed = NEXT_BOOLEAN(b);
 409                 jint transX       = NEXT_INT(b);
 410                 jint transY       = NEXT_INT(b);
 411                 jint *xPoints = (jint *)b;
 412                 jint *yPoints = ((jint *)b) + nPoints;
 413                 MTLRenderer_DrawPoly(mtlc, dstOps, nPoints, isClosed, transX, transY, xPoints, yPoints);
 414                 SKIP_BYTES(b, nPoints * BYTES_PER_POLY_POINT);
 415             }
 416             break;
 417         case sun_java2d_pipe_BufferedOpCodes_DRAW_PIXEL:
 418             {
 419                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 420                 jint x = NEXT_INT(b);
 421                 jint y = NEXT_INT(b);
 422                 CONTINUE_IF_NULL(mtlc);
 423                 //TODO
 424                 J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLRenderQueue_DRAW_PIXEL -- :TODO&quot;);
 425             }
 426             break;
 427         case sun_java2d_pipe_BufferedOpCodes_DRAW_SCANLINES:
 428             {
 429                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 430                 jint count = NEXT_INT(b);
 431                 MTLRenderer_DrawScanlines(mtlc, dstOps, count, (jint *)b);
 432 
 433                 SKIP_BYTES(b, count * BYTES_PER_SCANLINE);
 434             }
 435             break;
 436         case sun_java2d_pipe_BufferedOpCodes_DRAW_PARALLELOGRAM:
 437             {
 438                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 439                 jfloat x11 = NEXT_FLOAT(b);
 440                 jfloat y11 = NEXT_FLOAT(b);
 441                 jfloat dx21 = NEXT_FLOAT(b);
 442                 jfloat dy21 = NEXT_FLOAT(b);
 443                 jfloat dx12 = NEXT_FLOAT(b);
 444                 jfloat dy12 = NEXT_FLOAT(b);
 445                 jfloat lwr21 = NEXT_FLOAT(b);
 446                 jfloat lwr12 = NEXT_FLOAT(b);
 447 
 448                 MTLRenderer_DrawParallelogram(mtlc, dstOps,
 449                                               x11, y11,
 450                                               dx21, dy21,
 451                                               dx12, dy12,
 452                                               lwr21, lwr12);
 453             }
 454             break;
 455         case sun_java2d_pipe_BufferedOpCodes_DRAW_AAPARALLELOGRAM:
 456             {
 457                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 458                 jfloat x11 = NEXT_FLOAT(b);
 459                 jfloat y11 = NEXT_FLOAT(b);
 460                 jfloat dx21 = NEXT_FLOAT(b);
 461                 jfloat dy21 = NEXT_FLOAT(b);
 462                 jfloat dx12 = NEXT_FLOAT(b);
 463                 jfloat dy12 = NEXT_FLOAT(b);
 464                 jfloat lwr21 = NEXT_FLOAT(b);
 465                 jfloat lwr12 = NEXT_FLOAT(b);
 466 
 467                 MTLRenderer_DrawAAParallelogram(mtlc, dstOps,
 468                                                 x11, y11,
 469                                                 dx21, dy21,
 470                                                 dx12, dy12,
 471                                                 lwr21, lwr12);
 472             }
 473             break;
 474 
 475         // fill ops
 476         case sun_java2d_pipe_BufferedOpCodes_FILL_RECT:
 477             {
 478                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 479                 jint x = NEXT_INT(b);
 480                 jint y = NEXT_INT(b);
 481                 jint w = NEXT_INT(b);
 482                 jint h = NEXT_INT(b);
 483                 MTLRenderer_FillRect(mtlc, dstOps, x, y, w, h);
 484             }
 485             break;
 486         case sun_java2d_pipe_BufferedOpCodes_FILL_SPANS:
 487             {
 488                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 489                 jint count = NEXT_INT(b);
 490                 MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);
 491                 SKIP_BYTES(b, count * BYTES_PER_SPAN);
 492             }
 493             break;
 494         case sun_java2d_pipe_BufferedOpCodes_FILL_PARALLELOGRAM:
 495             {
 496                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 497                 jfloat x11 = NEXT_FLOAT(b);
 498                 jfloat y11 = NEXT_FLOAT(b);
 499                 jfloat dx21 = NEXT_FLOAT(b);
 500                 jfloat dy21 = NEXT_FLOAT(b);
 501                 jfloat dx12 = NEXT_FLOAT(b);
 502                 jfloat dy12 = NEXT_FLOAT(b);
 503                 MTLRenderer_FillParallelogram(mtlc, dstOps,
 504                                               x11, y11,
 505                                               dx21, dy21,
 506                                               dx12, dy12);
 507             }
 508             break;
 509         case sun_java2d_pipe_BufferedOpCodes_FILL_AAPARALLELOGRAM:
 510             {
 511                 CHECK_PREVIOUS_OP(MTL_OP_AA);
 512                 jfloat x11 = NEXT_FLOAT(b);
 513                 jfloat y11 = NEXT_FLOAT(b);
 514                 jfloat dx21 = NEXT_FLOAT(b);
 515                 jfloat dy21 = NEXT_FLOAT(b);
 516                 jfloat dx12 = NEXT_FLOAT(b);
 517                 jfloat dy12 = NEXT_FLOAT(b);
 518                 MTLRenderer_FillAAParallelogram(mtlc, dstOps,
 519                                                 x11, y11,
 520                                                 dx21, dy21,
 521                                                 dx12, dy12);
 522             }
 523             break;
 524 
 525         // text-related ops
 526         case sun_java2d_pipe_BufferedOpCodes_DRAW_GLYPH_LIST:
 527             {
 528                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 529                 jint numGlyphs        = NEXT_INT(b);
 530                 jint packedParams     = NEXT_INT(b);
 531                 jfloat glyphListOrigX = NEXT_FLOAT(b);
 532                 jfloat glyphListOrigY = NEXT_FLOAT(b);
 533                 jboolean usePositions = EXTRACT_BOOLEAN(packedParams,
 534                                                         OFFSET_POSITIONS);
 535                 jboolean subPixPos    = EXTRACT_BOOLEAN(packedParams,
 536                                                         OFFSET_SUBPIXPOS);
 537                 jboolean rgbOrder     = EXTRACT_BOOLEAN(packedParams,
 538                                                         OFFSET_RGBORDER);
 539                 jint lcdContrast      = EXTRACT_BYTE(packedParams,
 540                                                      OFFSET_CONTRAST);
 541                 unsigned char *images = b;
 542                 unsigned char *positions;
 543                 jint bytesPerGlyph;
 544                 if (usePositions) {
 545                     positions = (b + numGlyphs * BYTES_PER_GLYPH_IMAGE);
 546                     bytesPerGlyph = BYTES_PER_POSITIONED_GLYPH;
 547                 } else {
 548                     positions = NULL;
 549                     bytesPerGlyph = BYTES_PER_GLYPH_IMAGE;
 550                 }
 551                 MTLTR_DrawGlyphList(env, mtlc, dstOps,
 552                                     numGlyphs, usePositions,
 553                                     subPixPos, rgbOrder, lcdContrast,
 554                                     glyphListOrigX, glyphListOrigY,
 555                                     images, positions);
 556                 SKIP_BYTES(b, numGlyphs * bytesPerGlyph);
 557             }
 558             break;
 559 
 560         // copy-related ops
 561         case sun_java2d_pipe_BufferedOpCodes_COPY_AREA:
 562             {
 563                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 564                 jint x  = NEXT_INT(b);
 565                 jint y  = NEXT_INT(b);
 566                 jint w  = NEXT_INT(b);
 567                 jint h  = NEXT_INT(b);
 568                 jint dx = NEXT_INT(b);
 569                 jint dy = NEXT_INT(b);
 570                 MTLBlitLoops_CopyArea(env, mtlc, dstOps,
 571                                       x, y, w, h, dx, dy);
 572             }
 573             break;
 574         case sun_java2d_pipe_BufferedOpCodes_BLIT:
 575             {
 576                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 577                 jint packedParams = NEXT_INT(b);
 578                 jint sx1          = NEXT_INT(b);
 579                 jint sy1          = NEXT_INT(b);
 580                 jint sx2          = NEXT_INT(b);
 581                 jint sy2          = NEXT_INT(b);
 582                 jdouble dx1       = NEXT_DOUBLE(b);
 583                 jdouble dy1       = NEXT_DOUBLE(b);
 584                 jdouble dx2       = NEXT_DOUBLE(b);
 585                 jdouble dy2       = NEXT_DOUBLE(b);
 586                 jlong pSrc        = NEXT_LONG(b);
 587                 jlong pDst        = NEXT_LONG(b);
 588                 jint hint         = EXTRACT_BYTE(packedParams, OFFSET_HINT);
 589                 jboolean texture  = EXTRACT_BOOLEAN(packedParams,
 590                                                     OFFSET_TEXTURE);
 591                 jboolean xform    = EXTRACT_BOOLEAN(packedParams,
 592                                                     OFFSET_XFORM);
 593                 jboolean isoblit  = EXTRACT_BOOLEAN(packedParams,
 594                                                     OFFSET_ISOBLIT);
 595                 if (isoblit) {
 596                     MTLBlitLoops_IsoBlit(env, mtlc, pSrc, pDst,
 597                                          xform, hint, texture,
 598                                          sx1, sy1, sx2, sy2,
 599                                          dx1, dy1, dx2, dy2);
 600                 } else {
 601                     jint srctype = EXTRACT_BYTE(packedParams, OFFSET_SRCTYPE);
 602                     MTLBlitLoops_Blit(env, mtlc, pSrc, pDst,
 603                                       xform, hint, srctype, texture,
 604                                       sx1, sy1, sx2, sy2,
 605                                       dx1, dy1, dx2, dy2);
 606                 }
 607             }
 608             break;
 609         case sun_java2d_pipe_BufferedOpCodes_SURFACE_TO_SW_BLIT:
 610             {
 611                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 612                 jint sx      = NEXT_INT(b);
 613                 jint sy      = NEXT_INT(b);
 614                 jint dx      = NEXT_INT(b);
 615                 jint dy      = NEXT_INT(b);
 616                 jint w       = NEXT_INT(b);
 617                 jint h       = NEXT_INT(b);
 618                 jint dsttype = NEXT_INT(b);
 619                 jlong pSrc   = NEXT_LONG(b);
 620                 jlong pDst   = NEXT_LONG(b);
 621                 MTLBlitLoops_SurfaceToSwBlit(env, mtlc,
 622                                              pSrc, pDst, dsttype,
 623                                              sx, sy, dx, dy, w, h);
 624             }
 625             break;
 626         case sun_java2d_pipe_BufferedOpCodes_MASK_FILL:
 627             {
 628                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 629                 jint x        = NEXT_INT(b);
 630                 jint y        = NEXT_INT(b);
 631                 jint w        = NEXT_INT(b);
 632                 jint h        = NEXT_INT(b);
 633                 jint maskoff  = NEXT_INT(b);
 634                 jint maskscan = NEXT_INT(b);
 635                 jint masklen  = NEXT_INT(b);
 636                 unsigned char *pMask = (masklen &gt; 0) ? b : NULL;
 637                 MTLMaskFill_MaskFill(mtlc, dstOps, x, y, w, h,
 638                                      maskoff, maskscan, masklen, pMask);
 639                 SKIP_BYTES(b, masklen);
 640             }
 641             break;
 642         case sun_java2d_pipe_BufferedOpCodes_MASK_BLIT:
 643             {
 644                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 645                 jint dstx     = NEXT_INT(b);
 646                 jint dsty     = NEXT_INT(b);
 647                 jint width    = NEXT_INT(b);
 648                 jint height   = NEXT_INT(b);
 649                 jint masklen  = width * height * sizeof(jint);
 650                 MTLMaskBlit_MaskBlit(env, mtlc, dstOps,
 651                                      dstx, dsty, width, height, b);
 652                 SKIP_BYTES(b, masklen);
 653             }
 654             break;
 655 
 656         // state-related ops
 657         case sun_java2d_pipe_BufferedOpCodes_SET_RECT_CLIP:
 658             {
 659                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 660                 jint x1 = NEXT_INT(b);
 661                 jint y1 = NEXT_INT(b);
 662                 jint x2 = NEXT_INT(b);
 663                 jint y2 = NEXT_INT(b);
 664                 [mtlc setClipRectX1:x1 Y1:y1 X2:x2 Y2:y2];
 665             }
 666             break;
 667         case sun_java2d_pipe_BufferedOpCodes_BEGIN_SHAPE_CLIP:
 668             {
 669                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 670                 [mtlc beginShapeClip:dstOps];
 671             }
 672             break;
 673         case sun_java2d_pipe_BufferedOpCodes_SET_SHAPE_CLIP_SPANS:
 674             {
 675                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 676                 // This results in creation of new render encoder with
 677                 // stencil buffer set as render target
 678                 jint count = NEXT_INT(b);
 679                 MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);
 680                 SKIP_BYTES(b, count * BYTES_PER_SPAN);
 681             }
 682             break;
 683         case sun_java2d_pipe_BufferedOpCodes_END_SHAPE_CLIP:
 684             {
 685                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 686                 [mtlc endShapeClip:dstOps];
 687             }
 688             break;
 689         case sun_java2d_pipe_BufferedOpCodes_RESET_CLIP:
 690             {
 691                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 692                 [mtlc resetClip];
 693             }
 694             break;
 695         case sun_java2d_pipe_BufferedOpCodes_SET_ALPHA_COMPOSITE:
 696             {
 697                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 698                 jint rule         = NEXT_INT(b);
 699                 jfloat extraAlpha = NEXT_FLOAT(b);
 700                 jint flags        = NEXT_INT(b);
 701                 [mtlc setAlphaCompositeRule:rule extraAlpha:extraAlpha flags:flags];
 702             }
 703             break;
 704         case sun_java2d_pipe_BufferedOpCodes_SET_XOR_COMPOSITE:
 705             {
 706                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 707                 jint xorPixel = NEXT_INT(b);
 708                 [mtlc setXorComposite:xorPixel];
 709             }
 710             break;
 711         case sun_java2d_pipe_BufferedOpCodes_RESET_COMPOSITE:
 712             {
 713                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 714                 [mtlc resetComposite];
 715             }
 716             break;
 717         case sun_java2d_pipe_BufferedOpCodes_SET_TRANSFORM:
 718             {
 719                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 720                 jdouble m00 = NEXT_DOUBLE(b);
 721                 jdouble m10 = NEXT_DOUBLE(b);
 722                 jdouble m01 = NEXT_DOUBLE(b);
 723                 jdouble m11 = NEXT_DOUBLE(b);
 724                 jdouble m02 = NEXT_DOUBLE(b);
 725                 jdouble m12 = NEXT_DOUBLE(b);
 726                 [mtlc setTransformM00:m00 M10:m10 M01:m01 M11:m11 M02:m02 M12:m12];
 727             }
 728             break;
 729         case sun_java2d_pipe_BufferedOpCodes_RESET_TRANSFORM:
 730             {
 731                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 732                 [mtlc resetTransform];
 733             }
 734             break;
 735 
 736         // context-related ops
 737         case sun_java2d_pipe_BufferedOpCodes_SET_SURFACES:
 738             {
 739                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 740                 jlong pSrc = NEXT_LONG(b);
 741                 jlong pDst = NEXT_LONG(b);
 742 
 743                 dstOps = (BMTLSDOps *)jlong_to_ptr(pDst);
 744                 mtlc = [MTLContext setSurfacesEnv:env src:pSrc dst:pDst];
 745             }
 746             break;
 747         case sun_java2d_pipe_BufferedOpCodes_SET_SCRATCH_SURFACE:
 748             {
 749                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 750                 jlong pConfigInfo = NEXT_LONG(b);
 751                 MTLGraphicsConfigInfo *mtlInfo =
 752                         (MTLGraphicsConfigInfo *)jlong_to_ptr(pConfigInfo);
 753 
 754                 if (mtlInfo == NULL) {
 755 
 756                 } else {
 757                     MTLContext *newMtlc = mtlInfo-&gt;context;
 758                     if (newMtlc == NULL) {
 759 
 760                     } else {
 761                         mtlc = newMtlc;
 762                         dstOps = NULL;
 763                     }
 764                 }
 765             }
 766             break;
 767         case sun_java2d_pipe_BufferedOpCodes_FLUSH_SURFACE:
 768             {
 769                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 770                 jlong pData = NEXT_LONG(b);
 771                 BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);
 772                 if (mtlsdo != NULL) {
 773                     CONTINUE_IF_NULL(mtlc);
 774                     MTLSD_Delete(env, mtlsdo);
 775                 }
 776             }
 777             break;
 778         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_SURFACE:
 779             {
 780                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 781                 jlong pData = NEXT_LONG(b);
 782                 BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);
 783                 if (mtlsdo != NULL) {
 784                     CONTINUE_IF_NULL(mtlc);
 785                     MTLSD_Delete(env, mtlsdo);
 786                     if (mtlsdo-&gt;privOps != NULL) {
 787                         free(mtlsdo-&gt;privOps);
 788                     }
 789                 }
 790             }
 791             break;
 792         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_CONFIG:
 793             {
 794                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 795                 jlong pConfigInfo = NEXT_LONG(b);
 796                 CONTINUE_IF_NULL(mtlc);
 797                 MTLGC_DestroyMTLGraphicsConfig(pConfigInfo);
 798 
 799                 // the previous method will call glX/wglMakeCurrent(None),
 800                 // so we should nullify the current mtlc and dstOps to avoid
 801                 // calling glFlush() (or similar) while no context is current
 802                 mtlc = NULL;
 803              //   dstOps = NULL;
 804             }
 805             break;
 806         case sun_java2d_pipe_BufferedOpCodes_INVALIDATE_CONTEXT:
 807             {
 808                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 809                 // invalidate the references to the current context and
 810                 // destination surface that are maintained at the native level
 811                 mtlc = NULL;
 812             //    dstOps = NULL;
 813             }
 814             break;
 815         case sun_java2d_pipe_BufferedOpCodes_SYNC:
 816             {
<a name="3" id="anc3"></a><span class="line-modified"> 817                 CHECK_PREVIOUS_OP(MTL_OP_SYNC);</span>





 818             }
 819             break;
 820 
 821         // multibuffering ops
 822         case sun_java2d_pipe_BufferedOpCodes_SWAP_BUFFERS:
 823             {
 824                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 825                 jlong window = NEXT_LONG(b);
 826                 MTLSD_SwapBuffers(env, window);
 827             }
 828             break;
 829 
 830         // special no-op (mainly used for achieving 8-byte alignment)
 831         case sun_java2d_pipe_BufferedOpCodes_NOOP:
 832             break;
 833 
 834         // paint-related ops
 835         case sun_java2d_pipe_BufferedOpCodes_RESET_PAINT:
 836             {
<a name="4" id="anc4"></a><span class="line-modified"> 837               CHECK_PREVIOUS_OP(MTL_OP_RESET_PAINT);</span>
 838               [mtlc resetPaint];
 839             }
 840             break;
 841         case sun_java2d_pipe_BufferedOpCodes_SET_COLOR:
 842             {
 843                 CHECK_PREVIOUS_OP(MTL_OP_SET_COLOR);
 844                 jint pixel = NEXT_INT(b);
 845                 [mtlc setColorPaint:pixel];
 846             }
 847             break;
 848         case sun_java2d_pipe_BufferedOpCodes_SET_GRADIENT_PAINT:
 849             {
 850                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 851                 jboolean useMask= NEXT_BOOLEAN(b);
 852                 jboolean cyclic = NEXT_BOOLEAN(b);
 853                 jdouble p0      = NEXT_DOUBLE(b);
 854                 jdouble p1      = NEXT_DOUBLE(b);
 855                 jdouble p3      = NEXT_DOUBLE(b);
 856                 jint pixel1     = NEXT_INT(b);
 857                 jint pixel2     = NEXT_INT(b);
 858                 [mtlc setGradientPaintUseMask:useMask
 859                                     cyclic:cyclic
 860                                         p0:p0
 861                                         p1:p1
 862                                         p3:p3
 863                                     pixel1:pixel1
 864                                     pixel2:pixel2];
 865             }
 866             break;
 867         case sun_java2d_pipe_BufferedOpCodes_SET_LINEAR_GRADIENT_PAINT:
 868             {
 869                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 870                 jboolean useMask = NEXT_BOOLEAN(b);
 871                 jboolean linear  = NEXT_BOOLEAN(b);
 872                 jint cycleMethod = NEXT_INT(b);
 873                 jint numStops    = NEXT_INT(b);
 874                 jfloat p0        = NEXT_FLOAT(b);
 875                 jfloat p1        = NEXT_FLOAT(b);
 876                 jfloat p3        = NEXT_FLOAT(b);
 877                 void *fractions, *pixels;
 878                 fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));
 879                 pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));
 880                 [mtlc setLinearGradientPaint:useMask
 881                                       linear:linear
 882                                  cycleMethod:cycleMethod
 883                                     numStops:numStops
 884                                           p0:p0
 885                                           p1:p1
 886                                           p3:p3
 887                                    fractions:fractions
 888                                       pixels:pixels];
 889             }
 890             break;
 891         case sun_java2d_pipe_BufferedOpCodes_SET_RADIAL_GRADIENT_PAINT:
 892             {
 893                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 894                 jboolean useMask = NEXT_BOOLEAN(b);
 895                 jboolean linear  = NEXT_BOOLEAN(b);
 896                 jint numStops    = NEXT_INT(b);
 897                 jint cycleMethod = NEXT_INT(b);
 898                 jfloat m00       = NEXT_FLOAT(b);
 899                 jfloat m01       = NEXT_FLOAT(b);
 900                 jfloat m02       = NEXT_FLOAT(b);
 901                 jfloat m10       = NEXT_FLOAT(b);
 902                 jfloat m11       = NEXT_FLOAT(b);
 903                 jfloat m12       = NEXT_FLOAT(b);
 904                 jfloat focusX    = NEXT_FLOAT(b);
 905                 void *fractions, *pixels;
 906                 fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));
 907                 pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));
 908                 [mtlc setRadialGradientPaint:useMask
 909                                       linear:linear
 910                                  cycleMethod:cycleMethod
 911                                     numStops:numStops
 912                                          m00:m00
 913                                          m01:m01
 914                                          m02:m02
 915                                          m10:m10
 916                                          m11:m11
 917                                          m12:m12
 918                                       focusX:focusX
 919                                    fractions:fractions
 920                                       pixels:pixels];
 921             }
 922             break;
 923         case sun_java2d_pipe_BufferedOpCodes_SET_TEXTURE_PAINT:
 924             {
 925                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 926                 jboolean useMask= NEXT_BOOLEAN(b);
 927                 jboolean filter = NEXT_BOOLEAN(b);
 928                 jlong pSrc      = NEXT_LONG(b);
 929                 jdouble xp0     = NEXT_DOUBLE(b);
 930                 jdouble xp1     = NEXT_DOUBLE(b);
 931                 jdouble xp3     = NEXT_DOUBLE(b);
 932                 jdouble yp0     = NEXT_DOUBLE(b);
 933                 jdouble yp1     = NEXT_DOUBLE(b);
 934                 jdouble yp3     = NEXT_DOUBLE(b);
 935                 [mtlc setTexturePaint:useMask
 936                               pSrcOps:pSrc
 937                                filter:filter
 938                                   xp0:xp0
 939                                   xp1:xp1
 940                                   xp3:xp3
 941                                   yp0:yp0
 942                                   yp1:yp1
 943                                   yp3:yp3];
 944             }
 945             break;
 946 
 947         // BufferedImageOp-related ops
 948         case sun_java2d_pipe_BufferedOpCodes_ENABLE_CONVOLVE_OP:
 949             {
 950                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 951                 jlong pSrc        = NEXT_LONG(b);
 952                 jboolean edgeZero = NEXT_BOOLEAN(b);
 953                 jint kernelWidth  = NEXT_INT(b);
 954                 jint kernelHeight = NEXT_INT(b);
 955                 MTLBufImgOps_EnableConvolveOp(mtlc, pSrc, edgeZero,
 956                                               kernelWidth, kernelHeight, b);
 957                 SKIP_BYTES(b, kernelWidth * kernelHeight * sizeof(jfloat));
 958             }
 959             break;
 960         case sun_java2d_pipe_BufferedOpCodes_DISABLE_CONVOLVE_OP:
 961             {
 962                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 963                 MTLBufImgOps_DisableConvolveOp(mtlc);
 964             }
 965             break;
 966         case sun_java2d_pipe_BufferedOpCodes_ENABLE_RESCALE_OP:
 967             {
 968                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 969                 jlong pSrc          = NEXT_LONG(b);
 970                 jboolean nonPremult = NEXT_BOOLEAN(b);
 971                 jint numFactors     = 4;
 972                 unsigned char *scaleFactors = b;
 973                 unsigned char *offsets = (b + numFactors * sizeof(jfloat));
 974                 MTLBufImgOps_EnableRescaleOp(mtlc, pSrc, nonPremult,
 975                                              scaleFactors, offsets);
 976                 SKIP_BYTES(b, numFactors * sizeof(jfloat) * 2);
 977             }
 978             break;
 979         case sun_java2d_pipe_BufferedOpCodes_DISABLE_RESCALE_OP:
 980             {
 981                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 982                 MTLBufImgOps_DisableRescaleOp(mtlc);
 983             }
 984             break;
 985         case sun_java2d_pipe_BufferedOpCodes_ENABLE_LOOKUP_OP:
 986             {
 987                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 988                 jlong pSrc          = NEXT_LONG(b);
 989                 jboolean nonPremult = NEXT_BOOLEAN(b);
 990                 jboolean shortData  = NEXT_BOOLEAN(b);
 991                 jint numBands       = NEXT_INT(b);
 992                 jint bandLength     = NEXT_INT(b);
 993                 jint offset         = NEXT_INT(b);
 994                 jint bytesPerElem = shortData ? sizeof(jshort):sizeof(jbyte);
 995                 void *tableValues = b;
 996                 MTLBufImgOps_EnableLookupOp(mtlc, pSrc, nonPremult, shortData,
 997                                             numBands, bandLength, offset,
 998                                             tableValues);
 999                 SKIP_BYTES(b, numBands * bandLength * bytesPerElem);
1000             }
1001             break;
1002         case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:
1003             {
1004                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
1005                 MTLBufImgOps_DisableLookupOp(mtlc);
1006             }
1007             break;
1008 
1009         default:
1010             J2dRlsTraceLn1(J2D_TRACE_ERROR,
1011                 &quot;MTLRenderQueue_flushBuffer: invalid opcode=%d&quot;, opcode);
1012             return;
1013         }
1014     }
1015 
1016     if (mtlc != NULL) {
1017         [mtlc.encoderManager endEncoder];
1018         MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];
1019         id&lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
1020         [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
1021             [cbwrapper release];
1022         }];
1023         [commandbuf commit];
<a name="5" id="anc5"></a>


1024         BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
1025         if (dstOps != NULL) {
1026             MTLSDOps *dstMTLOps = (MTLSDOps *)dstOps-&gt;privOps;
1027             MTLLayer *layer = (MTLLayer*)dstMTLOps-&gt;layer;
1028             if (layer != NULL) {
1029                 [JNFRunLoop performOnMainThreadWaiting:NO withBlock:^(){
1030                     AWT_ASSERT_APPKIT_THREAD;
1031                     [layer setNeedsDisplay];
1032                 }];
1033             }
1034         }
1035     }
1036     RESET_PREVIOUS_OP();
1037 }
1038 
1039 /**
1040  * Returns a pointer to the &quot;current&quot; context, as set by the last SET_SURFACES
1041  * or SET_SCRATCH_SURFACE operation.
1042  */
1043 MTLContext *
1044 MTLRenderQueue_GetCurrentContext()
1045 {
1046     return mtlc;
1047 }
1048 
1049 /**
1050  * Returns a pointer to the &quot;current&quot; destination surface, as set by the last
1051  * SET_SURFACES operation.
1052  */
1053 BMTLSDOps *
1054 MTLRenderQueue_GetCurrentDestination()
1055 {
1056     return dstOps;
1057 }
1058 
1059 #endif /* !HEADLESS */
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
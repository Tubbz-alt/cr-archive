<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBlitLoops.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../awt/shaders.metal.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MTLComposite.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBlitLoops.m</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
197         } else
198 #endif // __MAC_10_15 &amp;&amp; __MAC_OS_X_VERSION_MAX_ALLOWED &gt;= __MAC_10_15
199         {
200             // perform raster conversion
201             // invoked only from rq-thread, so use static buffers
202             // but it&#39;s better to use thread-local buffers (or special buffer manager)
203             const int destRasterSize = dw*dh*4;
204 
205             static int bufferSize = 0;
206             static void * buffer = NULL;
207             if (buffer == NULL || bufferSize &lt; destRasterSize) {
208                 bufferSize = destRasterSize;
209                 buffer = realloc(buffer, bufferSize);
210             }
211             if (buffer == NULL) {
212                 J2dTraceLn1(J2D_TRACE_ERROR, &quot;replaceTextureRegion: can&#39;t alloc buffer for raster conversion, size=%d&quot;, bufferSize);
213                 bufferSize = 0;
214                 return nil;
215             }
216             vImage_Buffer srcBuf;
<span class="line-modified">217             srcBuf.height = dw;</span>
<span class="line-modified">218             srcBuf.width = dh;</span>
219             srcBuf.rowBytes = srcInfo-&gt;scanStride;
220             srcBuf.data = srcInfo-&gt;rasBase;
221 
222             vImage_Buffer destBuf;
<span class="line-modified">223             destBuf.height = dw;</span>
<span class="line-modified">224             destBuf.width = dh;</span>
225             destBuf.rowBytes = dw*4;
226             destBuf.data = buffer;
227 
228             vImagePermuteChannels_ARGB8888(&amp;srcBuf, &amp;destBuf, rfi-&gt;permuteMap, kvImageNoFlags);
229             raster = buffer;
230 
231             J2dTraceLn5(J2D_TRACE_VERBOSE, &quot;replaceTextureRegion [use conversion]: %d, %d, %d, %d, hasA=%d&quot;,
232                         rfi-&gt;permuteMap[0], rfi-&gt;permuteMap[1], rfi-&gt;permuteMap[2], rfi-&gt;permuteMap[3], rfi-&gt;hasAlpha);
233         }
234     }
235 
236     MTLRegion region = MTLRegionMake2D(dx1, dy1, dw, dh);
237     if (result != nil)
238         dest = result;
239     [dest replaceRegion:region mipmapLevel:0 withBytes:raster bytesPerRow:srcInfo-&gt;scanStride];
240     return result;
241 }
242 
243 /**
244  * Inner loop used for copying a source system memory (&quot;Sw&quot;) surface to a
</pre>
<hr />
<pre>
620                 J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [via pooled texture]&quot;);
621 #endif //TRACE_BLIT
622                 MTLBlitSwToTextureViaPooledTexture(mtlc, &amp;srcInfo, dstOps, &amp;rfi, false, dx1, dy1, dx2, dy2);
623             }
624         }
625         SurfaceData_InvokeRelease(env, srcOps, &amp;srcInfo);
626     }
627     SurfaceData_InvokeUnlock(env, srcOps, &amp;srcInfo);
628 }
629 
630 /**
631  * Specialized blit method for copying a native MTL &quot;Surface&quot; (pbuffer,
632  * window, etc.) to a system memory (&quot;Sw&quot;) surface.
633  */
634 void
635 MTLBlitLoops_SurfaceToSwBlit(JNIEnv *env, MTLContext *mtlc,
636                              jlong pSrcOps, jlong pDstOps, jint dsttype,
637                              jint srcx, jint srcy, jint dstx, jint dsty,
638                              jint width, jint height)
639 {
<span class="line-modified">640     //TODO</span>
<span class="line-modified">641     J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBlitLoops_SurfaceToSwBlit -- :TODO&quot;);</span>




























































































































































642 }
643 
644 void
645 MTLBlitLoops_CopyArea(JNIEnv *env,
646                       MTLContext *mtlc, BMTLSDOps *dstOps,
647                       jint x, jint y, jint width, jint height,
648                       jint dx, jint dy)
649 {
650 #ifdef DEBUG
651     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE, &quot;MTLBlitLoops_CopyArea: bdst=%p [tex=%p] %dx%d | src (%d, %d), %dx%d -&gt; dst (%d, %d)&quot;,
652             dstOps, dstOps-&gt;pTexture, ((id&lt;MTLTexture&gt;)dstOps-&gt;pTexture).width, ((id&lt;MTLTexture&gt;)dstOps-&gt;pTexture).height, x, y, width, height, dx, dy);
653 #endif //DEBUG
654     id &lt;MTLBlitCommandEncoder&gt; blitEncoder = [mtlc.encoderManager createBlitEncoder];
655     [blitEncoder
656             copyFromTexture:dstOps-&gt;pTexture
657             sourceSlice:0 sourceLevel:0 sourceOrigin:MTLOriginMake(x, y, 0) sourceSize:MTLSizeMake(width, height, 1)
658             toTexture:dstOps-&gt;pTexture destinationSlice:0 destinationLevel:0 destinationOrigin:MTLOriginMake(x + dx, y + dy, 0)];
659     [blitEncoder endEncoding];




660 }
661 
662 #endif /* !HEADLESS */
</pre>
</td>
<td>
<hr />
<pre>
197         } else
198 #endif // __MAC_10_15 &amp;&amp; __MAC_OS_X_VERSION_MAX_ALLOWED &gt;= __MAC_10_15
199         {
200             // perform raster conversion
201             // invoked only from rq-thread, so use static buffers
202             // but it&#39;s better to use thread-local buffers (or special buffer manager)
203             const int destRasterSize = dw*dh*4;
204 
205             static int bufferSize = 0;
206             static void * buffer = NULL;
207             if (buffer == NULL || bufferSize &lt; destRasterSize) {
208                 bufferSize = destRasterSize;
209                 buffer = realloc(buffer, bufferSize);
210             }
211             if (buffer == NULL) {
212                 J2dTraceLn1(J2D_TRACE_ERROR, &quot;replaceTextureRegion: can&#39;t alloc buffer for raster conversion, size=%d&quot;, bufferSize);
213                 bufferSize = 0;
214                 return nil;
215             }
216             vImage_Buffer srcBuf;
<span class="line-modified">217             srcBuf.height = dh;</span>
<span class="line-modified">218             srcBuf.width = dw;</span>
219             srcBuf.rowBytes = srcInfo-&gt;scanStride;
220             srcBuf.data = srcInfo-&gt;rasBase;
221 
222             vImage_Buffer destBuf;
<span class="line-modified">223             destBuf.height = dh;</span>
<span class="line-modified">224             destBuf.width = dw;</span>
225             destBuf.rowBytes = dw*4;
226             destBuf.data = buffer;
227 
228             vImagePermuteChannels_ARGB8888(&amp;srcBuf, &amp;destBuf, rfi-&gt;permuteMap, kvImageNoFlags);
229             raster = buffer;
230 
231             J2dTraceLn5(J2D_TRACE_VERBOSE, &quot;replaceTextureRegion [use conversion]: %d, %d, %d, %d, hasA=%d&quot;,
232                         rfi-&gt;permuteMap[0], rfi-&gt;permuteMap[1], rfi-&gt;permuteMap[2], rfi-&gt;permuteMap[3], rfi-&gt;hasAlpha);
233         }
234     }
235 
236     MTLRegion region = MTLRegionMake2D(dx1, dy1, dw, dh);
237     if (result != nil)
238         dest = result;
239     [dest replaceRegion:region mipmapLevel:0 withBytes:raster bytesPerRow:srcInfo-&gt;scanStride];
240     return result;
241 }
242 
243 /**
244  * Inner loop used for copying a source system memory (&quot;Sw&quot;) surface to a
</pre>
<hr />
<pre>
620                 J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [via pooled texture]&quot;);
621 #endif //TRACE_BLIT
622                 MTLBlitSwToTextureViaPooledTexture(mtlc, &amp;srcInfo, dstOps, &amp;rfi, false, dx1, dy1, dx2, dy2);
623             }
624         }
625         SurfaceData_InvokeRelease(env, srcOps, &amp;srcInfo);
626     }
627     SurfaceData_InvokeUnlock(env, srcOps, &amp;srcInfo);
628 }
629 
630 /**
631  * Specialized blit method for copying a native MTL &quot;Surface&quot; (pbuffer,
632  * window, etc.) to a system memory (&quot;Sw&quot;) surface.
633  */
634 void
635 MTLBlitLoops_SurfaceToSwBlit(JNIEnv *env, MTLContext *mtlc,
636                              jlong pSrcOps, jlong pDstOps, jint dsttype,
637                              jint srcx, jint srcy, jint dstx, jint dsty,
638                              jint width, jint height)
639 {
<span class="line-modified">640     J2dTraceLn6(J2D_TRACE_VERBOSE, &quot;MTLBlitLoops_SurfaceToSwBlit: sx=%d sy=%d w=%d h=%d dx=%d dy=%d&quot;, srcx, srcy, width, height, dstx, dsty);</span>
<span class="line-modified">641 </span>
<span class="line-added">642     BMTLSDOps *srcOps = (BMTLSDOps *)jlong_to_ptr(pSrcOps);</span>
<span class="line-added">643     SurfaceDataOps *dstOps = (SurfaceDataOps *)jlong_to_ptr(pDstOps);</span>
<span class="line-added">644     SurfaceDataRasInfo srcInfo, dstInfo;</span>
<span class="line-added">645 </span>
<span class="line-added">646     if (dsttype &lt; 0 || dsttype &gt;= sizeof(RasterFormatInfos)/ sizeof(MTLRasterFormatInfo)) {</span>
<span class="line-added">647         J2dTraceLn1(J2D_TRACE_ERROR, &quot;MTLBlitLoops_SurfaceToSwBlit: destination pixel format %d isn&#39;t supported&quot;, dsttype);</span>
<span class="line-added">648         return;</span>
<span class="line-added">649     }</span>
<span class="line-added">650 </span>
<span class="line-added">651     if (width &lt;= 0 || height &lt;= 0) {</span>
<span class="line-added">652         J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBlitLoops_SurfaceToSwBlit: dimensions are non-positive&quot;);</span>
<span class="line-added">653         return;</span>
<span class="line-added">654     }</span>
<span class="line-added">655 </span>
<span class="line-added">656     RETURN_IF_NULL(srcOps);</span>
<span class="line-added">657     RETURN_IF_NULL(dstOps);</span>
<span class="line-added">658     RETURN_IF_NULL(mtlc);</span>
<span class="line-added">659 </span>
<span class="line-added">660     srcInfo.bounds.x1 = srcx;</span>
<span class="line-added">661     srcInfo.bounds.y1 = srcy;</span>
<span class="line-added">662     srcInfo.bounds.x2 = srcx + width;</span>
<span class="line-added">663     srcInfo.bounds.y2 = srcy + height;</span>
<span class="line-added">664     dstInfo.bounds.x1 = dstx;</span>
<span class="line-added">665     dstInfo.bounds.y1 = dsty;</span>
<span class="line-added">666     dstInfo.bounds.x2 = dstx + width;</span>
<span class="line-added">667     dstInfo.bounds.y2 = dsty + height;</span>
<span class="line-added">668 </span>
<span class="line-added">669     if (dstOps-&gt;Lock(env, dstOps, &amp;dstInfo, SD_LOCK_WRITE) != SD_SUCCESS) {</span>
<span class="line-added">670         J2dTraceLn(J2D_TRACE_WARNING,&quot;MTLBlitLoops_SurfaceToSwBlit: could not acquire dst lock&quot;);</span>
<span class="line-added">671         return;</span>
<span class="line-added">672     }</span>
<span class="line-added">673 </span>
<span class="line-added">674     SurfaceData_IntersectBoundsXYXY(&amp;srcInfo.bounds,</span>
<span class="line-added">675                                     0, 0, srcOps-&gt;width, srcOps-&gt;height);</span>
<span class="line-added">676     SurfaceData_IntersectBlitBounds(&amp;dstInfo.bounds, &amp;srcInfo.bounds,</span>
<span class="line-added">677                                     srcx - dstx, srcy - dsty);</span>
<span class="line-added">678 </span>
<span class="line-added">679     if (srcInfo.bounds.x2 &gt; srcInfo.bounds.x1 &amp;&amp;</span>
<span class="line-added">680         srcInfo.bounds.y2 &gt; srcInfo.bounds.y1)</span>
<span class="line-added">681     {</span>
<span class="line-added">682         dstOps-&gt;GetRasInfo(env, dstOps, &amp;dstInfo);</span>
<span class="line-added">683         if (dstInfo.rasBase) {</span>
<span class="line-added">684             void *pDst = dstInfo.rasBase;</span>
<span class="line-added">685 </span>
<span class="line-added">686             srcx = srcInfo.bounds.x1;</span>
<span class="line-added">687             srcy = srcInfo.bounds.y1;</span>
<span class="line-added">688             dstx = dstInfo.bounds.x1;</span>
<span class="line-added">689             dsty = dstInfo.bounds.y1;</span>
<span class="line-added">690             width = srcInfo.bounds.x2 - srcInfo.bounds.x1;</span>
<span class="line-added">691             height = srcInfo.bounds.y2 - srcInfo.bounds.y1;</span>
<span class="line-added">692 </span>
<span class="line-added">693             pDst = PtrAddBytes(pDst, dstx * dstInfo.pixelStride);</span>
<span class="line-added">694             pDst = PtrPixelsRow(pDst, dsty, dstInfo.scanStride);</span>
<span class="line-added">695 </span>
<span class="line-added">696             // this accounts for lower-left origin of the source region</span>
<span class="line-added">697             srcx = srcOps-&gt;xOffset + srcx;</span>
<span class="line-added">698             srcy = srcOps-&gt;yOffset + srcOps-&gt;height - srcy - height;</span>
<span class="line-added">699             const int srcLength = width * height * 4; // NOTE: assume that src format is MTLPixelFormatBGRA8Unorm</span>
<span class="line-added">700 </span>
<span class="line-added">701 #ifdef DEBUG</span>
<span class="line-added">702             void *pDstEnd = dstInfo.rasBase + (height - 1)*dstInfo.scanStride + width*dstInfo.pixelStride;</span>
<span class="line-added">703             if (pDst + srcLength &gt; pDstEnd) {</span>
<span class="line-added">704                 J2dTraceLn6(J2D_TRACE_ERROR, &quot;MTLBlitLoops_SurfaceToSwBlit: length mismatch: dstx=%d, dsty=%d, w=%d, h=%d, pixStride=%d, scanStride=%d&quot;,</span>
<span class="line-added">705                         dstx, dsty, width, height, dstInfo.pixelStride, dstInfo.scanStride);</span>
<span class="line-added">706                 return;</span>
<span class="line-added">707             }</span>
<span class="line-added">708 #endif //DEBUG</span>
<span class="line-added">709 </span>
<span class="line-added">710             // Create MTLBuffer (or use static)</span>
<span class="line-added">711             MTLRasterFormatInfo rfi = RasterFormatInfos[dsttype];</span>
<span class="line-added">712             const jboolean directCopy = dsttype == 0;</span>
<span class="line-added">713 </span>
<span class="line-added">714             id&lt;MTLBuffer&gt; mtlbuf;</span>
<span class="line-added">715 #ifdef USE_STATIC_BUFFER</span>
<span class="line-added">716             if (directCopy) {</span>
<span class="line-added">717                 // NOTE: theoretically we can use newBufferWithBytesNoCopy, but pDst must be allocated with special API</span>
<span class="line-added">718                 // mtlbuf = [mtlc.device</span>
<span class="line-added">719                 //          newBufferWithBytesNoCopy:pDst</span>
<span class="line-added">720                 //                            length:(NSUInteger) srcLength</span>
<span class="line-added">721                 //                           options:MTLResourceCPUCacheModeDefaultCache</span>
<span class="line-added">722                 //                       deallocator:nil];</span>
<span class="line-added">723                 //</span>
<span class="line-added">724                 // see https://developer.apple.com/documentation/metal/mtldevice/1433382-newbufferwithbytesnocopy?language=objc</span>
<span class="line-added">725                 //</span>
<span class="line-added">726                 // The storage allocation of the returned new MTLBuffer object is the same as the pointer input value.</span>
<span class="line-added">727                 // The existing memory allocation must be covered by a single VM region, typically allocated with vm_allocate or mmap.</span>
<span class="line-added">728                 // Memory allocated by malloc is specifically disallowed.</span>
<span class="line-added">729             }</span>
<span class="line-added">730 </span>
<span class="line-added">731             static id&lt;MTLBuffer&gt; mtlIntermediateBuffer = nil; // need to reimplement with MTLBufferManager</span>
<span class="line-added">732             if (mtlIntermediateBuffer == nil || mtlIntermediateBuffer.length &lt; srcLength) {</span>
<span class="line-added">733                 if (mtlIntermediateBuffer != nil) {</span>
<span class="line-added">734                     [mtlIntermediateBuffer release];</span>
<span class="line-added">735                 }</span>
<span class="line-added">736                 mtlIntermediateBuffer = [mtlc.device newBufferWithLength:srcLength options:MTLResourceCPUCacheModeDefaultCache];</span>
<span class="line-added">737             }</span>
<span class="line-added">738             mtlbuf = mtlIntermediateBuffer;</span>
<span class="line-added">739 #else // USE_STATIC_BUFFER</span>
<span class="line-added">740             mtlbuf = [mtlc.device newBufferWithLength:width*height*4 options:MTLResourceStorageModeShared];</span>
<span class="line-added">741 #endif // USE_STATIC_BUFFER</span>
<span class="line-added">742 </span>
<span class="line-added">743             // Read from surface into MTLBuffer</span>
<span class="line-added">744             // NOTE: using of separate blitCommandBuffer can produce errors (draw into surface (with general cmd-buf)</span>
<span class="line-added">745             // can be unfinished when reading raster from blit cmd-buf).</span>
<span class="line-added">746             // Consider to use [mtlc.encoderManager createBlitEncoder] and [mtlc commitCommandBuffer:JNI_TRUE];</span>
<span class="line-added">747             J2dTraceLn1(J2D_TRACE_VERBOSE, &quot;MTLBlitLoops_SurfaceToSwBlit: source texture %p&quot;, srcOps-&gt;pTexture);</span>
<span class="line-added">748 </span>
<span class="line-added">749             id&lt;MTLCommandBuffer&gt; cb = [mtlc createBlitCommandBuffer];</span>
<span class="line-added">750             id&lt;MTLBlitCommandEncoder&gt; blitEncoder = [cb blitCommandEncoder];</span>
<span class="line-added">751             [blitEncoder synchronizeTexture:srcOps-&gt;pTexture slice:0 level:0];</span>
<span class="line-added">752             [blitEncoder copyFromTexture:srcOps-&gt;pTexture</span>
<span class="line-added">753                             sourceSlice:0</span>
<span class="line-added">754                             sourceLevel:0</span>
<span class="line-added">755                            sourceOrigin:MTLOriginMake(srcx, srcy, 0)</span>
<span class="line-added">756                              sourceSize:MTLSizeMake(width, height, 1)</span>
<span class="line-added">757                                toBuffer:mtlbuf</span>
<span class="line-added">758                       destinationOffset:0 /*offset already taken in: pDst = PtrAddBytes(pDst, dstx * dstInfo.pixelStride)*/</span>
<span class="line-added">759                  destinationBytesPerRow:width*4</span>
<span class="line-added">760                destinationBytesPerImage:width * height*4];</span>
<span class="line-added">761             [blitEncoder endEncoding];</span>
<span class="line-added">762 </span>
<span class="line-added">763             // Commit and wait for reading complete</span>
<span class="line-added">764             [cb commit];</span>
<span class="line-added">765             [cb waitUntilCompleted];</span>
<span class="line-added">766 </span>
<span class="line-added">767             // Perform conversion if necessary</span>
<span class="line-added">768             if (directCopy) {</span>
<span class="line-added">769                 memcpy(pDst, mtlbuf.contents, srcLength);</span>
<span class="line-added">770             } else {</span>
<span class="line-added">771                 J2dTraceLn6(J2D_TRACE_VERBOSE,&quot;MTLBlitLoops_SurfaceToSwBlit: dsttype=%d, raster conversion will be performed, dest rfi: %d, %d, %d, %d, hasA=%d&quot;,</span>
<span class="line-added">772                             dsttype, rfi.permuteMap[0], rfi.permuteMap[1], rfi.permuteMap[2], rfi.permuteMap[3], rfi.hasAlpha);</span>
<span class="line-added">773 </span>
<span class="line-added">774                 // perform raster conversion: mtlIntermediateBuffer(8888) -&gt; pDst(rfi)</span>
<span class="line-added">775                 // invoked only from rq-thread, so use static buffers</span>
<span class="line-added">776                 // but it&#39;s better to use thread-local buffers (or special buffer manager)</span>
<span class="line-added">777                 vImage_Buffer srcBuf;</span>
<span class="line-added">778                 srcBuf.height = height;</span>
<span class="line-added">779                 srcBuf.width = width;</span>
<span class="line-added">780                 srcBuf.rowBytes = 4*width;</span>
<span class="line-added">781                 srcBuf.data = mtlbuf.contents;</span>
<span class="line-added">782 </span>
<span class="line-added">783                 vImage_Buffer destBuf;</span>
<span class="line-added">784                 destBuf.height = height;</span>
<span class="line-added">785                 destBuf.width = width;</span>
<span class="line-added">786                 destBuf.rowBytes = dstInfo.scanStride;</span>
<span class="line-added">787                 destBuf.data = pDst;</span>
<span class="line-added">788 </span>
<span class="line-added">789                 vImagePermuteChannels_ARGB8888(&amp;srcBuf, &amp;destBuf, rfi.permuteMap, kvImageNoFlags);</span>
<span class="line-added">790             }</span>
<span class="line-added">791 #ifndef USE_STATIC_BUFFER</span>
<span class="line-added">792             [mtlbuf release];</span>
<span class="line-added">793 #endif // USE_STATIC_BUFFER</span>
<span class="line-added">794         }</span>
<span class="line-added">795         SurfaceData_InvokeRelease(env, dstOps, &amp;dstInfo);</span>
<span class="line-added">796     }</span>
<span class="line-added">797     SurfaceData_InvokeUnlock(env, dstOps, &amp;dstInfo);</span>
798 }
799 
800 void
801 MTLBlitLoops_CopyArea(JNIEnv *env,
802                       MTLContext *mtlc, BMTLSDOps *dstOps,
803                       jint x, jint y, jint width, jint height,
804                       jint dx, jint dy)
805 {
806 #ifdef DEBUG
807     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE, &quot;MTLBlitLoops_CopyArea: bdst=%p [tex=%p] %dx%d | src (%d, %d), %dx%d -&gt; dst (%d, %d)&quot;,
808             dstOps, dstOps-&gt;pTexture, ((id&lt;MTLTexture&gt;)dstOps-&gt;pTexture).width, ((id&lt;MTLTexture&gt;)dstOps-&gt;pTexture).height, x, y, width, height, dx, dy);
809 #endif //DEBUG
810     id &lt;MTLBlitCommandEncoder&gt; blitEncoder = [mtlc.encoderManager createBlitEncoder];
811     [blitEncoder
812             copyFromTexture:dstOps-&gt;pTexture
813             sourceSlice:0 sourceLevel:0 sourceOrigin:MTLOriginMake(x, y, 0) sourceSize:MTLSizeMake(width, height, 1)
814             toTexture:dstOps-&gt;pTexture destinationSlice:0 destinationLevel:0 destinationOrigin:MTLOriginMake(x + dx, y + dy, 0)];
815     [blitEncoder endEncoding];
<span class="line-added">816 </span>
<span class="line-added">817     // TODO:</span>
<span class="line-added">818     //  1. check rect bounds</span>
<span class="line-added">819     //  2. support CopyArea with extra-alpha (and with custom Composite if necessary)</span>
820 }
821 
822 #endif /* !HEADLESS */
</pre>
</td>
</tr>
</table>
<center><a href="../../awt/shaders.metal.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MTLComposite.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPipelineStatesStorage.m b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPipelineStatesStorage.m
--- a/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPipelineStatesStorage.m
+++ b/src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPipelineStatesStorage.m
@@ -1,17 +1,19 @@
 #import "MTLPipelineStatesStorage.h"
 
 #include "GraphicsPrimitiveMgr.h"
+#import "MTLComposite.h"
 
 // A special value for xor composite
 const int XOR_COMPOSITE_RULE = 20;
 
 extern const SurfaceRasterFlags defaultRasterFlags;
 
 static void setBlendingFactors(
         MTLRenderPipelineColorAttachmentDescriptor * cad,
         int compositeRule,
+        MTLComposite* composite,
         const SurfaceRasterFlags * srcFlags, const SurfaceRasterFlags * dstFlags);
 
 @implementation MTLPipelineStatesStorage
 
 @synthesize device;
@@ -98,17 +100,37 @@
                          srcFlags:srcFlags
                          dstFlags:dstFlags
             stencilNeeded:stencilNeeded];
 }
 
+- (id<MTLRenderPipelineState>) getPipelineState:(MTLRenderPipelineDescriptor *) pipelineDescriptor
+                                 vertexShaderId:(NSString *)vertexShaderId
+                               fragmentShaderId:(NSString *)fragmentShaderId
+                                  compositeRule:(jint)compositeRule
+                                           isAA:(jboolean)isAA
+                                       srcFlags:(const SurfaceRasterFlags *)srcFlags
+                                       dstFlags:(const SurfaceRasterFlags *)dstFlags
+                                  stencilNeeded:(bool)stencilNeeded;
+{
+    return [self getPipelineState:pipelineDescriptor
+                   vertexShaderId:vertexShaderId
+                 fragmentShaderId:fragmentShaderId
+                    compositeRule:compositeRule
+                        composite:nil
+                             isAA:isAA
+                         srcFlags:srcFlags
+                         dstFlags:dstFlags
+                    stencilNeeded:stencilNeeded];
+}
 
 // Base method to obtain MTLRenderPipelineState.
 // NOTE: parameters compositeRule, srcFlags, dstFlags are used to set MTLRenderPipelineColorAttachmentDescriptor multipliers
 - (id<MTLRenderPipelineState>) getPipelineState:(MTLRenderPipelineDescriptor *) pipelineDescriptor
                                  vertexShaderId:(NSString *)vertexShaderId
                                fragmentShaderId:(NSString *)fragmentShaderId
                                   compositeRule:(jint)compositeRule
+                                      composite:(MTLComposite*) composite
                                            isAA:(jboolean)isAA
                                        srcFlags:(const SurfaceRasterFlags *)srcFlags
                                        dstFlags:(const SurfaceRasterFlags *)dstFlags
                                   stencilNeeded:(bool)stencilNeeded;
 {
@@ -142,10 +164,14 @@
     }
 
     if (isAA) {
         subIndex |= 1 << 5;
     }
+
+    if ((composite != nil && FLT_LT([composite getExtraAlpha], 1.0f))) {
+        subIndex |= 1 << 6;
+    }
     int index = compositeRule*64 + subIndex;
 
     NSPointerArray * subStates = [self getSubStates:vertexShaderId fragmentShader:fragmentShaderId];
     while (index >= [subStates count]) {
         [subStates addPointer:NULL]; // obj-c collections haven't resize methods, so do that
@@ -165,14 +191,18 @@
  
                 pipelineDesc.colorAttachments[0].rgbBlendOperation = MTLBlendOperationAdd;
                 pipelineDesc.colorAttachments[0].sourceRGBBlendFactor = MTLBlendFactorOneMinusDestinationColor;
                 pipelineDesc.colorAttachments[0].destinationRGBBlendFactor =  MTLBlendFactorOneMinusSourceColor;
 
-            } else if (useComposite) {
+            } else if (useComposite ||
+                       (composite != nil  &&
+                        FLT_GE([composite getExtraAlpha], 1.0f)))
+            {
                 setBlendingFactors(
                         pipelineDesc.colorAttachments[0],
                         compositeRule,
+                        composite,
                         srcFlags, dstFlags
                 );
             }
             if (stencilNeeded) {
                 pipelineDesc.stencilAttachmentPixelFormat = MTLPixelFormatStencil8;
@@ -229,10 +259,11 @@
 @end
 
 static void setBlendingFactors(
         MTLRenderPipelineColorAttachmentDescriptor * cad,
         int compositeRule,
+        MTLComposite* composite,
         const SurfaceRasterFlags * srcFlags,
         const SurfaceRasterFlags * dstFlags
 ) {
     if (compositeRule == RULE_Src) {
         J2dTraceLn(J2D_TRACE_VERBOSE, "set RULE_Src");
@@ -256,11 +287,14 @@
 
     switch (compositeRule) {
         case RULE_SrcOver: {
             // Ar = As + Ad*(1-As)
             // Cr = Cs + Cd*(1-As)
-            if (srcFlags->isOpaque) {
+            if (srcFlags->isOpaque &&
+                (composite == nil ||
+                 FLT_GE([composite getExtraAlpha], 1.0f)))
+            {
                 J2dTraceLn(J2D_TRACE_VERBOSE, "rule=RULE_Src, but blending is disabled because src is opaque");
                 cad.blendingEnabled = NO;
                 return;
             }
             if (dstFlags->isOpaque) {
@@ -272,11 +306,15 @@
                 cad.destinationAlphaBlendFactor = MTLBlendFactorOneMinusSourceAlpha;
             }
             if (!srcFlags->isPremultiplied) {
                 cad.sourceRGBBlendFactor = MTLBlendFactorSourceAlpha;
             }
+            if (composite != nil && FLT_LT([composite getExtraAlpha], 1.0f)) {
+                cad.sourceRGBBlendFactor = MTLBlendFactorSourceAlpha;
+            }
             cad.destinationRGBBlendFactor = MTLBlendFactorOneMinusSourceAlpha;
+
             J2dTraceLn(J2D_TRACE_VERBOSE, "set RULE_SrcOver");
             break;
         }
         case RULE_DstOver: {
             // Ar = As*(1-Ad) + Ad

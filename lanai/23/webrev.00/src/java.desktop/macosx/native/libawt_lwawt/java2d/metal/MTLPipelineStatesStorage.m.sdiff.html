<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPipelineStatesStorage.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MTLPipelineStatesStorage.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MTLRenderQueue.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLPipelineStatesStorage.m</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 #import &quot;MTLPipelineStatesStorage.h&quot;
  2 
  3 #include &quot;GraphicsPrimitiveMgr.h&quot;

  4 
  5 // A special value for xor composite
  6 const int XOR_COMPOSITE_RULE = 20;
  7 
  8 extern const SurfaceRasterFlags defaultRasterFlags;
  9 
 10 static void setBlendingFactors(
 11         MTLRenderPipelineColorAttachmentDescriptor * cad,
 12         int compositeRule,

 13         const SurfaceRasterFlags * srcFlags, const SurfaceRasterFlags * dstFlags);
 14 
 15 @implementation MTLPipelineStatesStorage
 16 
 17 @synthesize device;
 18 @synthesize library;
 19 @synthesize shaders;
 20 @synthesize states;
 21 
 22 - (id) initWithDevice:(id&lt;MTLDevice&gt;)dev shaderLibPath:(NSString *)shadersLib {
 23     self = [super init];
 24     if (self == nil) return self;
 25 
 26     self.device = dev;
 27 
 28     NSError *error = nil;
 29     self.library = [dev newLibraryWithFile:shadersLib error:&amp;error];
 30     if (!self.library) {
 31         NSLog(@&quot;Failed to load library. error %@&quot;, error);
 32         exit(0);
</pre>
<hr />
<pre>
 83 }
 84 
 85 - (id&lt;MTLRenderPipelineState&gt;) getPipelineState:(MTLRenderPipelineDescriptor *) pipelineDescriptor
 86                                  vertexShaderId:(NSString *)vertexShaderId
 87                                fragmentShaderId:(NSString *)fragmentShaderId
 88                                   compositeRule:(jint)compositeRule
 89                                        srcFlags:(const SurfaceRasterFlags *)srcFlags
 90                                        dstFlags:(const SurfaceRasterFlags *)dstFlags
 91                                   stencilNeeded:(bool)stencilNeeded;
 92 {
 93     return [self getPipelineState:pipelineDescriptor
 94                    vertexShaderId:vertexShaderId
 95                  fragmentShaderId:fragmentShaderId
 96                     compositeRule:compositeRule
 97                              isAA:JNI_FALSE
 98                          srcFlags:srcFlags
 99                          dstFlags:dstFlags
100             stencilNeeded:stencilNeeded];
101 }
102 



















103 
104 // Base method to obtain MTLRenderPipelineState.
105 // NOTE: parameters compositeRule, srcFlags, dstFlags are used to set MTLRenderPipelineColorAttachmentDescriptor multipliers
106 - (id&lt;MTLRenderPipelineState&gt;) getPipelineState:(MTLRenderPipelineDescriptor *) pipelineDescriptor
107                                  vertexShaderId:(NSString *)vertexShaderId
108                                fragmentShaderId:(NSString *)fragmentShaderId
109                                   compositeRule:(jint)compositeRule

110                                            isAA:(jboolean)isAA
111                                        srcFlags:(const SurfaceRasterFlags *)srcFlags
112                                        dstFlags:(const SurfaceRasterFlags *)dstFlags
113                                   stencilNeeded:(bool)stencilNeeded;
114 {
115     const jboolean useXorComposite = (compositeRule == XOR_COMPOSITE_RULE);
116     const jboolean useComposite = compositeRule &gt;= 0
117         &amp;&amp; compositeRule &lt; java_awt_AlphaComposite_MAX_RULE
118         &amp;&amp; srcFlags != NULL &amp;&amp; dstFlags != NULL;
119 
120     // Calculate index by flags and compositeRule
121     // TODO: reimplement, use map with convenient key (calculated by all arguments)
122     int subIndex = 0;
123     if (useXorComposite) {
124         // compositeRule value is already XOR_COMPOSITE_RULE
125     }
126     else {
127         if (useComposite) {
128             if (!srcFlags-&gt;isPremultiplied)
129                 subIndex |= 1;
130             if (srcFlags-&gt;isOpaque)
131                 subIndex |= 1 &lt;&lt; 1;
132             if (!dstFlags-&gt;isPremultiplied)
133                 subIndex |= 1 &lt;&lt; 2;
134             if (dstFlags-&gt;isOpaque)
135                 subIndex |= 1 &lt;&lt; 3;
136         } else
137             compositeRule = RULE_Src;
138     }
139 
140     if (stencilNeeded) {
141         subIndex |= 1 &lt;&lt; 4;
142     }
143 
144     if (isAA) {
145         subIndex |= 1 &lt;&lt; 5;
146     }




147     int index = compositeRule*64 + subIndex;
148 
149     NSPointerArray * subStates = [self getSubStates:vertexShaderId fragmentShader:fragmentShaderId];
150     while (index &gt;= [subStates count]) {
151         [subStates addPointer:NULL]; // obj-c collections haven&#39;t resize methods, so do that
152     }
153 
154     id&lt;MTLRenderPipelineState&gt; result = [subStates pointerAtIndex:index];
155     if (result == nil) {
156         @autoreleasepool {
157             id &lt;MTLFunction&gt; vertexShader = [self getShader:vertexShaderId];
158             id &lt;MTLFunction&gt; fragmentShader = [self getShader:fragmentShaderId];
159             MTLRenderPipelineDescriptor *pipelineDesc = [[pipelineDescriptor copy] autorelease];
160             pipelineDesc.vertexFunction = vertexShader;
161             pipelineDesc.fragmentFunction = fragmentShader;
162 
163             if (useXorComposite) {
164                 pipelineDesc.colorAttachments[0].blendingEnabled = YES;
165  
166                 pipelineDesc.colorAttachments[0].rgbBlendOperation = MTLBlendOperationAdd;
167                 pipelineDesc.colorAttachments[0].sourceRGBBlendFactor = MTLBlendFactorOneMinusDestinationColor;
168                 pipelineDesc.colorAttachments[0].destinationRGBBlendFactor =  MTLBlendFactorOneMinusSourceColor;
169 
<span class="line-modified">170             } else if (useComposite) {</span>



171                 setBlendingFactors(
172                         pipelineDesc.colorAttachments[0],
173                         compositeRule,

174                         srcFlags, dstFlags
175                 );
176             }
177             if (stencilNeeded) {
178                 pipelineDesc.stencilAttachmentPixelFormat = MTLPixelFormatStencil8;
179             }
180 
181             if (isAA) {
182                 pipelineDesc.sampleCount = MTLAASampleCount;
183                 pipelineDesc.colorAttachments[0].rgbBlendOperation =   MTLBlendOperationAdd;
184                 pipelineDesc.colorAttachments[0].alphaBlendOperation = MTLBlendOperationAdd;
185                 pipelineDesc.colorAttachments[0].sourceRGBBlendFactor = MTLBlendFactorSourceAlpha;
186                 pipelineDesc.colorAttachments[0].sourceAlphaBlendFactor = MTLBlendFactorSourceAlpha;
187                 pipelineDesc.colorAttachments[0].destinationRGBBlendFactor = MTLBlendFactorOneMinusSourceAlpha;
188                 pipelineDesc.colorAttachments[0].destinationAlphaBlendFactor = MTLBlendFactorOneMinusSourceAlpha;
189                 pipelineDesc.colorAttachments[0].blendingEnabled = YES;
190             }
191 
192             NSError *error = nil;
193             result = [[self.device newRenderPipelineStateWithDescriptor:pipelineDesc error:&amp;error] autorelease];
</pre>
<hr />
<pre>
214 
215 - (id&lt;MTLRenderPipelineState&gt;) getXorModePipelineState:(MTLRenderPipelineDescriptor *) pipelineDescriptor
216                                  vertexShaderId:(NSString *)vertexShaderId
217                                fragmentShaderId:(NSString *)fragmentShaderId
218                                                   srcFlags:(const SurfaceRasterFlags * )srcFlags
219                                                   dstFlags:(const SurfaceRasterFlags * )dstFlags
220                                              stencilNeeded:(bool)stencilNeeded {
221             return [self getPipelineState:pipelineDescriptor
222                    vertexShaderId:vertexShaderId
223                  fragmentShaderId:fragmentShaderId
224                     compositeRule:XOR_COMPOSITE_RULE
225                          srcFlags:NULL
226                          dstFlags:NULL
227                     stencilNeeded:stencilNeeded];
228 } 
229 @end
230 
231 static void setBlendingFactors(
232         MTLRenderPipelineColorAttachmentDescriptor * cad,
233         int compositeRule,

234         const SurfaceRasterFlags * srcFlags,
235         const SurfaceRasterFlags * dstFlags
236 ) {
237     if (compositeRule == RULE_Src) {
238         J2dTraceLn(J2D_TRACE_VERBOSE, &quot;set RULE_Src&quot;);
239         return;
240     }
241 
242     cad.blendingEnabled = YES;
243 
244     // RGB = Source.rgb * SBFc + Dest.rgb * DBFc
245     // A = Source.a * SBFa + Dest.a * DBFa
246     //
247     // default mode == RULE_Src with constants:
248     // DBFa=0
249     // DBFc=0
250     // SBFa=1
251     // SBFc=1
252     //
253     // NOTE: constants MTLBlendFactorBlendAlpha, MTLBlendFactorOneMinusBlendAlpha refers to [encoder setBlendColorRed:green:blue:alpha:] (default value is zero)
254     //
255     // TODO: implement alpha-composite via shaders (will be much more simpler and can support all rules and modes)
256 
257     switch (compositeRule) {
258         case RULE_SrcOver: {
259             // Ar = As + Ad*(1-As)
260             // Cr = Cs + Cd*(1-As)
<span class="line-modified">261             if (srcFlags-&gt;isOpaque) {</span>



262                 J2dTraceLn(J2D_TRACE_VERBOSE, &quot;rule=RULE_Src, but blending is disabled because src is opaque&quot;);
263                 cad.blendingEnabled = NO;
264                 return;
265             }
266             if (dstFlags-&gt;isOpaque) {
267                 // Ar = 1, can be ignored, so
268                 // Cr = Cs + Cd*(1-As)
269                 // TODO: select any multiplier with best performance
270                 // for example: cad.destinationAlphaBlendFactor = MTLBlendFactorZero;
271             } else {
272                 cad.destinationAlphaBlendFactor = MTLBlendFactorOneMinusSourceAlpha;
273             }
274             if (!srcFlags-&gt;isPremultiplied) {
275                 cad.sourceRGBBlendFactor = MTLBlendFactorSourceAlpha;
276             }



277             cad.destinationRGBBlendFactor = MTLBlendFactorOneMinusSourceAlpha;

278             J2dTraceLn(J2D_TRACE_VERBOSE, &quot;set RULE_SrcOver&quot;);
279             break;
280         }
281         case RULE_DstOver: {
282             // Ar = As*(1-Ad) + Ad
283             // Cr = Cs*(1-Ad) + Cd
284             if (srcFlags-&gt;isOpaque) {
285                 J2dTraceLn(J2D_TRACE_ERROR, &quot;Composite rule RULE_DstOver with opaque src isn&#39;t implemented (src alpha won&#39;t be ignored)&quot;);
286             }
287             if (dstFlags-&gt;isOpaque) {
288                 J2dTraceLn(J2D_TRACE_ERROR, &quot;Composite rule RULE_DstOver with opaque dest hasn&#39;t any sense&quot;);
289             }
290             if (!srcFlags-&gt;isPremultiplied) {
291                 J2dTrace(J2D_TRACE_ERROR, &quot;Composite rule RULE_DstOver with non-premultiplied source isn&#39;t implemented (scr alpha will be ignored for rgb-component)&quot;);
292             }
293             cad.sourceAlphaBlendFactor = MTLBlendFactorOneMinusDestinationAlpha;
294             cad.sourceRGBBlendFactor = MTLBlendFactorOneMinusDestinationAlpha;
295             cad.destinationAlphaBlendFactor = MTLBlendFactorOne;
296             cad.destinationRGBBlendFactor = MTLBlendFactorOne;
297             J2dTraceLn(J2D_TRACE_VERBOSE, &quot;set RULE_DstOver&quot;);
</pre>
</td>
<td>
<hr />
<pre>
  1 #import &quot;MTLPipelineStatesStorage.h&quot;
  2 
  3 #include &quot;GraphicsPrimitiveMgr.h&quot;
<span class="line-added">  4 #import &quot;MTLComposite.h&quot;</span>
  5 
  6 // A special value for xor composite
  7 const int XOR_COMPOSITE_RULE = 20;
  8 
  9 extern const SurfaceRasterFlags defaultRasterFlags;
 10 
 11 static void setBlendingFactors(
 12         MTLRenderPipelineColorAttachmentDescriptor * cad,
 13         int compositeRule,
<span class="line-added"> 14         MTLComposite* composite,</span>
 15         const SurfaceRasterFlags * srcFlags, const SurfaceRasterFlags * dstFlags);
 16 
 17 @implementation MTLPipelineStatesStorage
 18 
 19 @synthesize device;
 20 @synthesize library;
 21 @synthesize shaders;
 22 @synthesize states;
 23 
 24 - (id) initWithDevice:(id&lt;MTLDevice&gt;)dev shaderLibPath:(NSString *)shadersLib {
 25     self = [super init];
 26     if (self == nil) return self;
 27 
 28     self.device = dev;
 29 
 30     NSError *error = nil;
 31     self.library = [dev newLibraryWithFile:shadersLib error:&amp;error];
 32     if (!self.library) {
 33         NSLog(@&quot;Failed to load library. error %@&quot;, error);
 34         exit(0);
</pre>
<hr />
<pre>
 85 }
 86 
 87 - (id&lt;MTLRenderPipelineState&gt;) getPipelineState:(MTLRenderPipelineDescriptor *) pipelineDescriptor
 88                                  vertexShaderId:(NSString *)vertexShaderId
 89                                fragmentShaderId:(NSString *)fragmentShaderId
 90                                   compositeRule:(jint)compositeRule
 91                                        srcFlags:(const SurfaceRasterFlags *)srcFlags
 92                                        dstFlags:(const SurfaceRasterFlags *)dstFlags
 93                                   stencilNeeded:(bool)stencilNeeded;
 94 {
 95     return [self getPipelineState:pipelineDescriptor
 96                    vertexShaderId:vertexShaderId
 97                  fragmentShaderId:fragmentShaderId
 98                     compositeRule:compositeRule
 99                              isAA:JNI_FALSE
100                          srcFlags:srcFlags
101                          dstFlags:dstFlags
102             stencilNeeded:stencilNeeded];
103 }
104 
<span class="line-added">105 - (id&lt;MTLRenderPipelineState&gt;) getPipelineState:(MTLRenderPipelineDescriptor *) pipelineDescriptor</span>
<span class="line-added">106                                  vertexShaderId:(NSString *)vertexShaderId</span>
<span class="line-added">107                                fragmentShaderId:(NSString *)fragmentShaderId</span>
<span class="line-added">108                                   compositeRule:(jint)compositeRule</span>
<span class="line-added">109                                            isAA:(jboolean)isAA</span>
<span class="line-added">110                                        srcFlags:(const SurfaceRasterFlags *)srcFlags</span>
<span class="line-added">111                                        dstFlags:(const SurfaceRasterFlags *)dstFlags</span>
<span class="line-added">112                                   stencilNeeded:(bool)stencilNeeded;</span>
<span class="line-added">113 {</span>
<span class="line-added">114     return [self getPipelineState:pipelineDescriptor</span>
<span class="line-added">115                    vertexShaderId:vertexShaderId</span>
<span class="line-added">116                  fragmentShaderId:fragmentShaderId</span>
<span class="line-added">117                     compositeRule:compositeRule</span>
<span class="line-added">118                         composite:nil</span>
<span class="line-added">119                              isAA:isAA</span>
<span class="line-added">120                          srcFlags:srcFlags</span>
<span class="line-added">121                          dstFlags:dstFlags</span>
<span class="line-added">122                     stencilNeeded:stencilNeeded];</span>
<span class="line-added">123 }</span>
124 
125 // Base method to obtain MTLRenderPipelineState.
126 // NOTE: parameters compositeRule, srcFlags, dstFlags are used to set MTLRenderPipelineColorAttachmentDescriptor multipliers
127 - (id&lt;MTLRenderPipelineState&gt;) getPipelineState:(MTLRenderPipelineDescriptor *) pipelineDescriptor
128                                  vertexShaderId:(NSString *)vertexShaderId
129                                fragmentShaderId:(NSString *)fragmentShaderId
130                                   compositeRule:(jint)compositeRule
<span class="line-added">131                                       composite:(MTLComposite*) composite</span>
132                                            isAA:(jboolean)isAA
133                                        srcFlags:(const SurfaceRasterFlags *)srcFlags
134                                        dstFlags:(const SurfaceRasterFlags *)dstFlags
135                                   stencilNeeded:(bool)stencilNeeded;
136 {
137     const jboolean useXorComposite = (compositeRule == XOR_COMPOSITE_RULE);
138     const jboolean useComposite = compositeRule &gt;= 0
139         &amp;&amp; compositeRule &lt; java_awt_AlphaComposite_MAX_RULE
140         &amp;&amp; srcFlags != NULL &amp;&amp; dstFlags != NULL;
141 
142     // Calculate index by flags and compositeRule
143     // TODO: reimplement, use map with convenient key (calculated by all arguments)
144     int subIndex = 0;
145     if (useXorComposite) {
146         // compositeRule value is already XOR_COMPOSITE_RULE
147     }
148     else {
149         if (useComposite) {
150             if (!srcFlags-&gt;isPremultiplied)
151                 subIndex |= 1;
152             if (srcFlags-&gt;isOpaque)
153                 subIndex |= 1 &lt;&lt; 1;
154             if (!dstFlags-&gt;isPremultiplied)
155                 subIndex |= 1 &lt;&lt; 2;
156             if (dstFlags-&gt;isOpaque)
157                 subIndex |= 1 &lt;&lt; 3;
158         } else
159             compositeRule = RULE_Src;
160     }
161 
162     if (stencilNeeded) {
163         subIndex |= 1 &lt;&lt; 4;
164     }
165 
166     if (isAA) {
167         subIndex |= 1 &lt;&lt; 5;
168     }
<span class="line-added">169 </span>
<span class="line-added">170     if ((composite != nil &amp;&amp; FLT_LT([composite getExtraAlpha], 1.0f))) {</span>
<span class="line-added">171         subIndex |= 1 &lt;&lt; 6;</span>
<span class="line-added">172     }</span>
173     int index = compositeRule*64 + subIndex;
174 
175     NSPointerArray * subStates = [self getSubStates:vertexShaderId fragmentShader:fragmentShaderId];
176     while (index &gt;= [subStates count]) {
177         [subStates addPointer:NULL]; // obj-c collections haven&#39;t resize methods, so do that
178     }
179 
180     id&lt;MTLRenderPipelineState&gt; result = [subStates pointerAtIndex:index];
181     if (result == nil) {
182         @autoreleasepool {
183             id &lt;MTLFunction&gt; vertexShader = [self getShader:vertexShaderId];
184             id &lt;MTLFunction&gt; fragmentShader = [self getShader:fragmentShaderId];
185             MTLRenderPipelineDescriptor *pipelineDesc = [[pipelineDescriptor copy] autorelease];
186             pipelineDesc.vertexFunction = vertexShader;
187             pipelineDesc.fragmentFunction = fragmentShader;
188 
189             if (useXorComposite) {
190                 pipelineDesc.colorAttachments[0].blendingEnabled = YES;
191  
192                 pipelineDesc.colorAttachments[0].rgbBlendOperation = MTLBlendOperationAdd;
193                 pipelineDesc.colorAttachments[0].sourceRGBBlendFactor = MTLBlendFactorOneMinusDestinationColor;
194                 pipelineDesc.colorAttachments[0].destinationRGBBlendFactor =  MTLBlendFactorOneMinusSourceColor;
195 
<span class="line-modified">196             } else if (useComposite ||</span>
<span class="line-added">197                        (composite != nil  &amp;&amp;</span>
<span class="line-added">198                         FLT_GE([composite getExtraAlpha], 1.0f)))</span>
<span class="line-added">199             {</span>
200                 setBlendingFactors(
201                         pipelineDesc.colorAttachments[0],
202                         compositeRule,
<span class="line-added">203                         composite,</span>
204                         srcFlags, dstFlags
205                 );
206             }
207             if (stencilNeeded) {
208                 pipelineDesc.stencilAttachmentPixelFormat = MTLPixelFormatStencil8;
209             }
210 
211             if (isAA) {
212                 pipelineDesc.sampleCount = MTLAASampleCount;
213                 pipelineDesc.colorAttachments[0].rgbBlendOperation =   MTLBlendOperationAdd;
214                 pipelineDesc.colorAttachments[0].alphaBlendOperation = MTLBlendOperationAdd;
215                 pipelineDesc.colorAttachments[0].sourceRGBBlendFactor = MTLBlendFactorSourceAlpha;
216                 pipelineDesc.colorAttachments[0].sourceAlphaBlendFactor = MTLBlendFactorSourceAlpha;
217                 pipelineDesc.colorAttachments[0].destinationRGBBlendFactor = MTLBlendFactorOneMinusSourceAlpha;
218                 pipelineDesc.colorAttachments[0].destinationAlphaBlendFactor = MTLBlendFactorOneMinusSourceAlpha;
219                 pipelineDesc.colorAttachments[0].blendingEnabled = YES;
220             }
221 
222             NSError *error = nil;
223             result = [[self.device newRenderPipelineStateWithDescriptor:pipelineDesc error:&amp;error] autorelease];
</pre>
<hr />
<pre>
244 
245 - (id&lt;MTLRenderPipelineState&gt;) getXorModePipelineState:(MTLRenderPipelineDescriptor *) pipelineDescriptor
246                                  vertexShaderId:(NSString *)vertexShaderId
247                                fragmentShaderId:(NSString *)fragmentShaderId
248                                                   srcFlags:(const SurfaceRasterFlags * )srcFlags
249                                                   dstFlags:(const SurfaceRasterFlags * )dstFlags
250                                              stencilNeeded:(bool)stencilNeeded {
251             return [self getPipelineState:pipelineDescriptor
252                    vertexShaderId:vertexShaderId
253                  fragmentShaderId:fragmentShaderId
254                     compositeRule:XOR_COMPOSITE_RULE
255                          srcFlags:NULL
256                          dstFlags:NULL
257                     stencilNeeded:stencilNeeded];
258 } 
259 @end
260 
261 static void setBlendingFactors(
262         MTLRenderPipelineColorAttachmentDescriptor * cad,
263         int compositeRule,
<span class="line-added">264         MTLComposite* composite,</span>
265         const SurfaceRasterFlags * srcFlags,
266         const SurfaceRasterFlags * dstFlags
267 ) {
268     if (compositeRule == RULE_Src) {
269         J2dTraceLn(J2D_TRACE_VERBOSE, &quot;set RULE_Src&quot;);
270         return;
271     }
272 
273     cad.blendingEnabled = YES;
274 
275     // RGB = Source.rgb * SBFc + Dest.rgb * DBFc
276     // A = Source.a * SBFa + Dest.a * DBFa
277     //
278     // default mode == RULE_Src with constants:
279     // DBFa=0
280     // DBFc=0
281     // SBFa=1
282     // SBFc=1
283     //
284     // NOTE: constants MTLBlendFactorBlendAlpha, MTLBlendFactorOneMinusBlendAlpha refers to [encoder setBlendColorRed:green:blue:alpha:] (default value is zero)
285     //
286     // TODO: implement alpha-composite via shaders (will be much more simpler and can support all rules and modes)
287 
288     switch (compositeRule) {
289         case RULE_SrcOver: {
290             // Ar = As + Ad*(1-As)
291             // Cr = Cs + Cd*(1-As)
<span class="line-modified">292             if (srcFlags-&gt;isOpaque &amp;&amp;</span>
<span class="line-added">293                 (composite == nil ||</span>
<span class="line-added">294                  FLT_GE([composite getExtraAlpha], 1.0f)))</span>
<span class="line-added">295             {</span>
296                 J2dTraceLn(J2D_TRACE_VERBOSE, &quot;rule=RULE_Src, but blending is disabled because src is opaque&quot;);
297                 cad.blendingEnabled = NO;
298                 return;
299             }
300             if (dstFlags-&gt;isOpaque) {
301                 // Ar = 1, can be ignored, so
302                 // Cr = Cs + Cd*(1-As)
303                 // TODO: select any multiplier with best performance
304                 // for example: cad.destinationAlphaBlendFactor = MTLBlendFactorZero;
305             } else {
306                 cad.destinationAlphaBlendFactor = MTLBlendFactorOneMinusSourceAlpha;
307             }
308             if (!srcFlags-&gt;isPremultiplied) {
309                 cad.sourceRGBBlendFactor = MTLBlendFactorSourceAlpha;
310             }
<span class="line-added">311             if (composite != nil &amp;&amp; FLT_LT([composite getExtraAlpha], 1.0f)) {</span>
<span class="line-added">312                 cad.sourceRGBBlendFactor = MTLBlendFactorSourceAlpha;</span>
<span class="line-added">313             }</span>
314             cad.destinationRGBBlendFactor = MTLBlendFactorOneMinusSourceAlpha;
<span class="line-added">315 </span>
316             J2dTraceLn(J2D_TRACE_VERBOSE, &quot;set RULE_SrcOver&quot;);
317             break;
318         }
319         case RULE_DstOver: {
320             // Ar = As*(1-Ad) + Ad
321             // Cr = Cs*(1-Ad) + Cd
322             if (srcFlags-&gt;isOpaque) {
323                 J2dTraceLn(J2D_TRACE_ERROR, &quot;Composite rule RULE_DstOver with opaque src isn&#39;t implemented (src alpha won&#39;t be ignored)&quot;);
324             }
325             if (dstFlags-&gt;isOpaque) {
326                 J2dTraceLn(J2D_TRACE_ERROR, &quot;Composite rule RULE_DstOver with opaque dest hasn&#39;t any sense&quot;);
327             }
328             if (!srcFlags-&gt;isPremultiplied) {
329                 J2dTrace(J2D_TRACE_ERROR, &quot;Composite rule RULE_DstOver with non-premultiplied source isn&#39;t implemented (scr alpha will be ignored for rgb-component)&quot;);
330             }
331             cad.sourceAlphaBlendFactor = MTLBlendFactorOneMinusDestinationAlpha;
332             cad.sourceRGBBlendFactor = MTLBlendFactorOneMinusDestinationAlpha;
333             cad.destinationAlphaBlendFactor = MTLBlendFactorOne;
334             cad.destinationRGBBlendFactor = MTLBlendFactorOne;
335             J2dTraceLn(J2D_TRACE_VERBOSE, &quot;set RULE_DstOver&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="MTLPipelineStatesStorage.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MTLRenderQueue.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLRenderQueue.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #ifndef HEADLESS
  27 
  28 #include &lt;stdlib.h&gt;
  29 
  30 #include &quot;sun_java2d_pipe_BufferedOpCodes.h&quot;
  31 
  32 #include &quot;jlong.h&quot;
  33 #include &quot;MTLBlitLoops.h&quot;
  34 #include &quot;MTLBufImgOps.h&quot;
  35 #include &quot;MTLMaskBlit.h&quot;
  36 #include &quot;MTLMaskFill.h&quot;
  37 #include &quot;MTLPaints.h&quot;
  38 #include &quot;MTLRenderQueue.h&quot;
  39 #include &quot;MTLRenderer.h&quot;
  40 #include &quot;MTLTextRenderer.h&quot;
  41 #import &quot;ThreadUtilities.h&quot;
  42 
  43 /**
  44  * References to the &quot;current&quot; context and destination surface.
  45  */
  46 static MTLContext *mtlc = NULL;
  47 static BMTLSDOps *dstOps = NULL;
  48 jint mtlPreviousOp = MTL_OP_INIT;
  49 
  50 /**
  51  * The following methods are implemented in the windowing system (i.e. GLX
  52  * and WGL) source files.
  53  */
  54 extern void MTLGC_DestroyMTLGraphicsConfig(jlong pConfigInfo);
  55 extern void MTLSD_SwapBuffers(JNIEnv *env, jlong window);
  56 
  57 // TODO : Debug logic added for opcode verification,
  58 // should be removed later.
  59 static char *getOpcodeString(jint opcode) {
  60     static char opName[30];
  61     switch (opcode) {
  62         case sun_java2d_pipe_BufferedOpCodes_DRAW_LINE:
  63             {
  64                 strcpy(opName, &quot;DRAW_LINE&quot;);
  65             }
  66             break;
  67         case sun_java2d_pipe_BufferedOpCodes_DRAW_RECT:
  68             {
  69                 strcpy(opName, &quot;DRAW_RECT&quot;);
  70             }
  71             break;
  72         case sun_java2d_pipe_BufferedOpCodes_DRAW_POLY:
  73             {
  74                 strcpy(opName, &quot;DRAW_POLY&quot;);
  75             }
  76             break;
  77         case sun_java2d_pipe_BufferedOpCodes_DRAW_PIXEL:
  78             {
  79                 strcpy(opName, &quot;DRAW_PIXEL&quot;);
  80             }
  81             break;
  82         case sun_java2d_pipe_BufferedOpCodes_DRAW_SCANLINES:
  83             {
  84                 strcpy(opName, &quot;DRAW_SCANLINES&quot;);
  85             }
  86             break;
  87         case sun_java2d_pipe_BufferedOpCodes_DRAW_PARALLELOGRAM:
  88             {
  89                 strcpy(opName, &quot;DRAW_PARALLELOGRAM&quot;);
  90             }
  91             break;
  92         case sun_java2d_pipe_BufferedOpCodes_DRAW_AAPARALLELOGRAM:
  93             {
  94                 strcpy(opName, &quot;DRAW_AAPARALLELOGRAM&quot;);
  95             }
  96             break;
  97         case sun_java2d_pipe_BufferedOpCodes_FILL_RECT:
  98             {
  99                 strcpy(opName, &quot;FILL_RECT&quot;);
 100             }
 101             break;
 102         case sun_java2d_pipe_BufferedOpCodes_FILL_SPANS:
 103             {
 104                 strcpy(opName, &quot;FILL_SPANS&quot;);
 105             }
 106             break;
 107         case sun_java2d_pipe_BufferedOpCodes_FILL_PARALLELOGRAM:
 108             {
 109                 strcpy(opName, &quot;FILL_PARALLELOGRAM&quot;);
 110             }
 111             break;
 112         case sun_java2d_pipe_BufferedOpCodes_FILL_AAPARALLELOGRAM:
 113             {
 114                 strcpy(opName, &quot;FILL_AAPARALLELOGRAM&quot;);
 115             }
 116             break;
 117         case sun_java2d_pipe_BufferedOpCodes_DRAW_GLYPH_LIST:
 118             {
 119                 strcpy(opName, &quot;DRAW_GLYPH_LIST&quot;);
 120             }
 121             break;
 122         case sun_java2d_pipe_BufferedOpCodes_COPY_AREA:
 123             {
 124                 strcpy(opName, &quot;COPY_AREA&quot;);
 125             }
 126             break;
 127         case sun_java2d_pipe_BufferedOpCodes_BLIT:
 128             {
 129                 strcpy(opName, &quot;BLIT&quot;);
 130             }
 131             break;
 132         case sun_java2d_pipe_BufferedOpCodes_SURFACE_TO_SW_BLIT:
 133             {
 134                 strcpy(opName, &quot;SURFACE_TO_SW_BLIT&quot;);
 135             }
 136             break;
 137         case sun_java2d_pipe_BufferedOpCodes_MASK_FILL:
 138             {
 139                 strcpy(opName, &quot;MASK_FILL&quot;);
 140             }
 141             break;
 142         case sun_java2d_pipe_BufferedOpCodes_MASK_BLIT:
 143             {
 144 
 145                 strcpy(opName, &quot;MASK_BLIT&quot;);
 146             }
 147             break;
 148         case sun_java2d_pipe_BufferedOpCodes_SET_RECT_CLIP:
 149             {
 150                 strcpy(opName, &quot;SET_RECT_CLIP&quot;);
 151             }
 152             break;
 153         case sun_java2d_pipe_BufferedOpCodes_BEGIN_SHAPE_CLIP:
 154             {
 155                 strcpy(opName, &quot;BEGIN_SHAPE_CLIP&quot;);
 156             }
 157             break;
 158         case sun_java2d_pipe_BufferedOpCodes_SET_SHAPE_CLIP_SPANS:
 159             {
 160                 strcpy(opName, &quot;SET_SHAPE_CLIP_SPANS&quot;);
 161             }
 162             break;
 163         case sun_java2d_pipe_BufferedOpCodes_END_SHAPE_CLIP:
 164             {
 165                 strcpy(opName, &quot;END_SHAPE_CLIP&quot;);
 166             }
 167             break;
 168         case sun_java2d_pipe_BufferedOpCodes_RESET_CLIP:
 169             {
 170                 strcpy(opName, &quot;RESET_CLIP&quot;);
 171             }
 172             break;
 173         case sun_java2d_pipe_BufferedOpCodes_SET_ALPHA_COMPOSITE:
 174             {
 175                 strcpy(opName, &quot;SET_ALPHA_COMPOSITE&quot;);
 176             }
 177             break;
 178         case sun_java2d_pipe_BufferedOpCodes_SET_XOR_COMPOSITE:
 179             {
 180                 strcpy(opName, &quot;SET_XOR_COMPOSITE&quot;);
 181             }
 182             break;
 183         case sun_java2d_pipe_BufferedOpCodes_RESET_COMPOSITE:
 184             {
 185                 strcpy(opName, &quot;RESET_COMPOSITE&quot;);
 186             }
 187             break;
 188         case sun_java2d_pipe_BufferedOpCodes_SET_TRANSFORM:
 189             {
 190                 strcpy(opName, &quot;SET_TRANSFORM&quot;);
 191             }
 192             break;
 193         case sun_java2d_pipe_BufferedOpCodes_RESET_TRANSFORM:
 194             {
 195                 strcpy(opName, &quot;RESET_TRANSFORM&quot;);
 196             }
 197             break;
 198         case sun_java2d_pipe_BufferedOpCodes_SET_SURFACES:
 199             {
 200 
 201                 strcpy(opName, &quot;SET_SURFACES&quot;);
 202             }
 203             break;
 204         case sun_java2d_pipe_BufferedOpCodes_SET_SCRATCH_SURFACE:
 205             {
 206                 strcpy(opName, &quot;SET_SCRATCH_SURFACE&quot;);
 207             }
 208             break;
 209         case sun_java2d_pipe_BufferedOpCodes_FLUSH_SURFACE:
 210             {
 211                 strcpy(opName, &quot;FLUSH_SURFACE&quot;);
 212             }
 213             break;
 214         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_SURFACE:
 215             {
 216                 strcpy(opName, &quot;DISPOSE_SURFACE&quot;);
 217             }
 218             break;
 219         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_CONFIG:
 220             {
 221                 strcpy(opName, &quot;DISPOSE_CONFIG&quot;);
 222             }
 223             break;
 224         case sun_java2d_pipe_BufferedOpCodes_INVALIDATE_CONTEXT:
 225             {
 226                 strcpy(opName, &quot;INVALIDATE_CONTEXT&quot;);
 227             }
 228             break;
 229         case sun_java2d_pipe_BufferedOpCodes_SYNC:
 230             {
 231                 strcpy(opName, &quot;SYNC&quot;);
 232 
 233             }
 234             break;
 235         case sun_java2d_pipe_BufferedOpCodes_SWAP_BUFFERS:
 236             {
 237                 strcpy(opName, &quot;SWAP_BUFFERS&quot;);
 238             }
 239             break;
 240         case sun_java2d_pipe_BufferedOpCodes_NOOP:
 241             strcpy(opName, &quot;NOOP&quot;);
 242             break;
 243         case sun_java2d_pipe_BufferedOpCodes_RESET_PAINT:
 244             {
 245                 strcpy(opName, &quot;RESET_PAINT&quot;);
 246             }
 247             break;
 248         case sun_java2d_pipe_BufferedOpCodes_SET_COLOR:
 249             {
 250                 strcpy(opName, &quot;SET_COLOR&quot;);
 251             }
 252             break;
 253         case sun_java2d_pipe_BufferedOpCodes_SET_GRADIENT_PAINT:
 254             {
 255                 strcpy(opName, &quot;SET_GRADIENT_PAINT&quot;);
 256             }
 257             break;
 258         case sun_java2d_pipe_BufferedOpCodes_SET_LINEAR_GRADIENT_PAINT:
 259             {
 260                 strcpy(opName, &quot;SET_LINEAR_GRADIENT_PAINT&quot;);
 261             }
 262             break;
 263         case sun_java2d_pipe_BufferedOpCodes_SET_RADIAL_GRADIENT_PAINT:
 264             {
 265                 strcpy(opName, &quot;SET_RADIAL_GRADIENT_PAINT&quot;);
 266             }
 267             break;
 268         case sun_java2d_pipe_BufferedOpCodes_SET_TEXTURE_PAINT:
 269             {
 270                 strcpy(opName, &quot;SET_TEXTURE_PAINT&quot;);
 271             }
 272             break;
 273         case sun_java2d_pipe_BufferedOpCodes_ENABLE_CONVOLVE_OP:
 274             {
 275                 strcpy(opName, &quot;ENABLE_CONVOLVE_OP&quot;);
 276             }
 277             break;
 278         case sun_java2d_pipe_BufferedOpCodes_DISABLE_CONVOLVE_OP:
 279             {
 280                 strcpy(opName, &quot;DISABLE_CONVOLVE_OP&quot;);
 281             }
 282             break;
 283         case sun_java2d_pipe_BufferedOpCodes_ENABLE_RESCALE_OP:
 284             {
 285                 strcpy(opName, &quot;ENABLE_RESCALE_OP&quot;);
 286             }
 287             break;
 288         case sun_java2d_pipe_BufferedOpCodes_DISABLE_RESCALE_OP:
 289             {
 290                  strcpy(opName, &quot;DISABLE_RESCALE_OP&quot;);
 291             }
 292             break;
 293         case sun_java2d_pipe_BufferedOpCodes_ENABLE_LOOKUP_OP:
 294             {
 295                 strcpy(opName, &quot;ENABLE_LOOKUP_OP&quot;);
 296             }
 297             break;
 298         case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:
 299             {
 300                 strcpy(opName, &quot;DISABLE_LOOKUP_OP&quot;);
 301             }
 302             break;
 303         default:
 304             strcpy(opName, &quot;UNKNOWN&quot;);
 305             break;
 306         }
 307     return opName;
 308 }
 309 
 310 void MTLRenderQueue_CheckPreviousOp(jint op) {
 311 
 312     if (mtlPreviousOp == op) {
 313         // The op is the same as last time, so we can return immediately.
 314         return;
 315     }
 316 
 317     J2dTraceLn1(J2D_TRACE_VERBOSE,
 318                 &quot;MTLRenderQueue_CheckPreviousOp: new op=%d&quot;, op);
 319 
 320     if (op == MTL_OP_SET_COLOR) {
 321         return; // SET_COLOR should not cause endEncoder
 322     }
 323 
 324     if (mtlPreviousOp == MTL_OP_INIT) {
 325         mtlPreviousOp = op;
 326         return;
 327     }
 328 
 329     if (mtlc != NULL) {
 330         [mtlc.encoderManager endEncoder];
 331     }
 332     mtlPreviousOp = op;
 333 }
 334 
 335 JNIEXPORT void JNICALL
 336 Java_sun_java2d_metal_MTLRenderQueue_flushBuffer
 337     (JNIEnv *env, jobject mtlrq,
 338      jlong buf, jint limit)
 339 {
 340     jboolean sync = JNI_FALSE;
 341     unsigned char *b, *end;
 342 
 343     J2dTraceLn1(J2D_TRACE_INFO,
 344                 &quot;MTLRenderQueue_flushBuffer: limit=%d&quot;, limit);
 345 
 346     b = (unsigned char *)jlong_to_ptr(buf);
 347     if (b == NULL) {
 348         J2dRlsTraceLn(J2D_TRACE_ERROR,
 349             &quot;MTLRenderQueue_flushBuffer: cannot get direct buffer address&quot;);
 350         return;
 351     }
 352 
 353     end = b + limit;
 354 
 355     jboolean DEBUG_LOG = JNI_FALSE;
 356     while (b &lt; end) {
 357         jint opcode = NEXT_INT(b);
 358 
 359         if (DEBUG_LOG) {
 360             J2dTraceLn2(J2D_TRACE_ERROR,
 361                     &quot;MTLRenderQueue_flushBuffer: opcode_name = %s, rem=%d&quot;,
 362                     getOpcodeString(opcode), (end-b));
 363         } else {
 364             J2dTraceLn2(J2D_TRACE_VERBOSE,
 365                     &quot;MTLRenderQueue_flushBuffer: opcode=%d, rem=%d&quot;,
 366                     opcode, (end-b));
 367         }
 368 
 369         switch (opcode) {
 370 
 371         // draw ops
 372         case sun_java2d_pipe_BufferedOpCodes_DRAW_LINE:
 373             {
 374                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 375                 J2dTraceLn(J2D_TRACE_VERBOSE, &quot;sun_java2d_pipe_BufferedOpCodes_DRAW_LINE&quot;);
 376                 jint x1 = NEXT_INT(b);
 377                 jint y1 = NEXT_INT(b);
 378                 jint x2 = NEXT_INT(b);
 379                 jint y2 = NEXT_INT(b);
 380                 MTLRenderer_DrawLine(mtlc, dstOps, x1, y1, x2, y2);
 381             }
 382             break;
 383         case sun_java2d_pipe_BufferedOpCodes_DRAW_RECT:
 384             {
 385                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 386                 jint x = NEXT_INT(b);
 387                 jint y = NEXT_INT(b);
 388                 jint w = NEXT_INT(b);
 389                 jint h = NEXT_INT(b);
 390                 MTLRenderer_DrawRect(mtlc, dstOps, x, y, w, h);
 391             }
 392             break;
 393         case sun_java2d_pipe_BufferedOpCodes_DRAW_POLY:
 394             {
 395                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 396                 jint nPoints      = NEXT_INT(b);
 397                 jboolean isClosed = NEXT_BOOLEAN(b);
 398                 jint transX       = NEXT_INT(b);
 399                 jint transY       = NEXT_INT(b);
 400                 jint *xPoints = (jint *)b;
 401                 jint *yPoints = ((jint *)b) + nPoints;
 402                 MTLRenderer_DrawPoly(mtlc, dstOps, nPoints, isClosed, transX, transY, xPoints, yPoints);
 403                 SKIP_BYTES(b, nPoints * BYTES_PER_POLY_POINT);
 404             }
 405             break;
 406         case sun_java2d_pipe_BufferedOpCodes_DRAW_PIXEL:
 407             {
 408                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 409                 jint x = NEXT_INT(b);
 410                 jint y = NEXT_INT(b);
 411                 CONTINUE_IF_NULL(mtlc);
 412                 //TODO
 413                 J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLRenderQueue_DRAW_PIXEL -- :TODO&quot;);
 414             }
 415             break;
 416         case sun_java2d_pipe_BufferedOpCodes_DRAW_SCANLINES:
 417             {
 418                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 419                 jint count = NEXT_INT(b);
 420                 MTLRenderer_DrawScanlines(mtlc, dstOps, count, (jint *)b);
 421 
 422                 SKIP_BYTES(b, count * BYTES_PER_SCANLINE);
 423             }
 424             break;
 425         case sun_java2d_pipe_BufferedOpCodes_DRAW_PARALLELOGRAM:
 426             {
 427                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 428                 jfloat x11 = NEXT_FLOAT(b);
 429                 jfloat y11 = NEXT_FLOAT(b);
 430                 jfloat dx21 = NEXT_FLOAT(b);
 431                 jfloat dy21 = NEXT_FLOAT(b);
 432                 jfloat dx12 = NEXT_FLOAT(b);
 433                 jfloat dy12 = NEXT_FLOAT(b);
 434                 jfloat lwr21 = NEXT_FLOAT(b);
 435                 jfloat lwr12 = NEXT_FLOAT(b);
 436 
 437                 MTLRenderer_DrawParallelogram(mtlc, dstOps,
 438                                               x11, y11,
 439                                               dx21, dy21,
 440                                               dx12, dy12,
 441                                               lwr21, lwr12);
 442             }
 443             break;
 444         case sun_java2d_pipe_BufferedOpCodes_DRAW_AAPARALLELOGRAM:
 445             {
 446                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 447                 jfloat x11 = NEXT_FLOAT(b);
 448                 jfloat y11 = NEXT_FLOAT(b);
 449                 jfloat dx21 = NEXT_FLOAT(b);
 450                 jfloat dy21 = NEXT_FLOAT(b);
 451                 jfloat dx12 = NEXT_FLOAT(b);
 452                 jfloat dy12 = NEXT_FLOAT(b);
 453                 jfloat lwr21 = NEXT_FLOAT(b);
 454                 jfloat lwr12 = NEXT_FLOAT(b);
 455 
 456                 MTLRenderer_DrawAAParallelogram(mtlc, dstOps,
 457                                                 x11, y11,
 458                                                 dx21, dy21,
 459                                                 dx12, dy12,
 460                                                 lwr21, lwr12);
 461             }
 462             break;
 463 
 464         // fill ops
 465         case sun_java2d_pipe_BufferedOpCodes_FILL_RECT:
 466             {
 467                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 468                 jint x = NEXT_INT(b);
 469                 jint y = NEXT_INT(b);
 470                 jint w = NEXT_INT(b);
 471                 jint h = NEXT_INT(b);
 472                 MTLRenderer_FillRect(mtlc, dstOps, x, y, w, h);
 473             }
 474             break;
 475         case sun_java2d_pipe_BufferedOpCodes_FILL_SPANS:
 476             {
 477                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 478                 jint count = NEXT_INT(b);
 479                 MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);
 480                 SKIP_BYTES(b, count * BYTES_PER_SPAN);
 481             }
 482             break;
 483         case sun_java2d_pipe_BufferedOpCodes_FILL_PARALLELOGRAM:
 484             {
 485                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 486                 jfloat x11 = NEXT_FLOAT(b);
 487                 jfloat y11 = NEXT_FLOAT(b);
 488                 jfloat dx21 = NEXT_FLOAT(b);
 489                 jfloat dy21 = NEXT_FLOAT(b);
 490                 jfloat dx12 = NEXT_FLOAT(b);
 491                 jfloat dy12 = NEXT_FLOAT(b);
 492                 MTLRenderer_FillParallelogram(mtlc, dstOps,
 493                                               x11, y11,
 494                                               dx21, dy21,
 495                                               dx12, dy12);
 496             }
 497             break;
 498         case sun_java2d_pipe_BufferedOpCodes_FILL_AAPARALLELOGRAM:
 499             {
 500                 CHECK_PREVIOUS_OP(MTL_OP_AA);
 501                 jfloat x11 = NEXT_FLOAT(b);
 502                 jfloat y11 = NEXT_FLOAT(b);
 503                 jfloat dx21 = NEXT_FLOAT(b);
 504                 jfloat dy21 = NEXT_FLOAT(b);
 505                 jfloat dx12 = NEXT_FLOAT(b);
 506                 jfloat dy12 = NEXT_FLOAT(b);
 507                 MTLRenderer_FillAAParallelogram(mtlc, dstOps,
 508                                                 x11, y11,
 509                                                 dx21, dy21,
 510                                                 dx12, dy12);
 511             }
 512             break;
 513 
 514         // text-related ops
 515         case sun_java2d_pipe_BufferedOpCodes_DRAW_GLYPH_LIST:
 516             {
 517                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 518                 jint numGlyphs        = NEXT_INT(b);
 519                 jint packedParams     = NEXT_INT(b);
 520                 jfloat glyphListOrigX = NEXT_FLOAT(b);
 521                 jfloat glyphListOrigY = NEXT_FLOAT(b);
 522                 jboolean usePositions = EXTRACT_BOOLEAN(packedParams,
 523                                                         OFFSET_POSITIONS);
 524                 jboolean subPixPos    = EXTRACT_BOOLEAN(packedParams,
 525                                                         OFFSET_SUBPIXPOS);
 526                 jboolean rgbOrder     = EXTRACT_BOOLEAN(packedParams,
 527                                                         OFFSET_RGBORDER);
 528                 jint lcdContrast      = EXTRACT_BYTE(packedParams,
 529                                                      OFFSET_CONTRAST);
 530                 unsigned char *images = b;
 531                 unsigned char *positions;
 532                 jint bytesPerGlyph;
 533                 if (usePositions) {
 534                     positions = (b + numGlyphs * BYTES_PER_GLYPH_IMAGE);
 535                     bytesPerGlyph = BYTES_PER_POSITIONED_GLYPH;
 536                 } else {
 537                     positions = NULL;
 538                     bytesPerGlyph = BYTES_PER_GLYPH_IMAGE;
 539                 }
 540                 MTLTR_DrawGlyphList(env, mtlc, dstOps,
 541                                     numGlyphs, usePositions,
 542                                     subPixPos, rgbOrder, lcdContrast,
 543                                     glyphListOrigX, glyphListOrigY,
 544                                     images, positions);
 545                 SKIP_BYTES(b, numGlyphs * bytesPerGlyph);
 546             }
 547             break;
 548 
 549         // copy-related ops
 550         case sun_java2d_pipe_BufferedOpCodes_COPY_AREA:
 551             {
 552                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 553                 jint x  = NEXT_INT(b);
 554                 jint y  = NEXT_INT(b);
 555                 jint w  = NEXT_INT(b);
 556                 jint h  = NEXT_INT(b);
 557                 jint dx = NEXT_INT(b);
 558                 jint dy = NEXT_INT(b);
 559                 MTLBlitLoops_CopyArea(env, mtlc, dstOps,
 560                                       x, y, w, h, dx, dy);
 561             }
 562             break;
 563         case sun_java2d_pipe_BufferedOpCodes_BLIT:
 564             {
 565                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 566                 jint packedParams = NEXT_INT(b);
 567                 jint sx1          = NEXT_INT(b);
 568                 jint sy1          = NEXT_INT(b);
 569                 jint sx2          = NEXT_INT(b);
 570                 jint sy2          = NEXT_INT(b);
 571                 jdouble dx1       = NEXT_DOUBLE(b);
 572                 jdouble dy1       = NEXT_DOUBLE(b);
 573                 jdouble dx2       = NEXT_DOUBLE(b);
 574                 jdouble dy2       = NEXT_DOUBLE(b);
 575                 jlong pSrc        = NEXT_LONG(b);
 576                 jlong pDst        = NEXT_LONG(b);
 577                 jint hint         = EXTRACT_BYTE(packedParams, OFFSET_HINT);
 578                 jboolean texture  = EXTRACT_BOOLEAN(packedParams,
 579                                                     OFFSET_TEXTURE);
 580                 jboolean xform    = EXTRACT_BOOLEAN(packedParams,
 581                                                     OFFSET_XFORM);
 582                 jboolean isoblit  = EXTRACT_BOOLEAN(packedParams,
 583                                                     OFFSET_ISOBLIT);
 584                 if (isoblit) {
 585                     MTLBlitLoops_IsoBlit(env, mtlc, pSrc, pDst,
 586                                          xform, hint, texture,
 587                                          sx1, sy1, sx2, sy2,
 588                                          dx1, dy1, dx2, dy2);
 589                 } else {
 590                     jint srctype = EXTRACT_BYTE(packedParams, OFFSET_SRCTYPE);
 591                     MTLBlitLoops_Blit(env, mtlc, pSrc, pDst,
 592                                       xform, hint, srctype, texture,
 593                                       sx1, sy1, sx2, sy2,
 594                                       dx1, dy1, dx2, dy2);
 595                 }
 596             }
 597             break;
 598         case sun_java2d_pipe_BufferedOpCodes_SURFACE_TO_SW_BLIT:
 599             {
 600                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 601                 jint sx      = NEXT_INT(b);
 602                 jint sy      = NEXT_INT(b);
 603                 jint dx      = NEXT_INT(b);
 604                 jint dy      = NEXT_INT(b);
 605                 jint w       = NEXT_INT(b);
 606                 jint h       = NEXT_INT(b);
 607                 jint dsttype = NEXT_INT(b);
 608                 jlong pSrc   = NEXT_LONG(b);
 609                 jlong pDst   = NEXT_LONG(b);
 610                 MTLBlitLoops_SurfaceToSwBlit(env, mtlc,
 611                                              pSrc, pDst, dsttype,
 612                                              sx, sy, dx, dy, w, h);
 613             }
 614             break;
 615         case sun_java2d_pipe_BufferedOpCodes_MASK_FILL:
 616             {
 617                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 618                 jint x        = NEXT_INT(b);
 619                 jint y        = NEXT_INT(b);
 620                 jint w        = NEXT_INT(b);
 621                 jint h        = NEXT_INT(b);
 622                 jint maskoff  = NEXT_INT(b);
 623                 jint maskscan = NEXT_INT(b);
 624                 jint masklen  = NEXT_INT(b);
 625                 unsigned char *pMask = (masklen &gt; 0) ? b : NULL;
 626                 MTLMaskFill_MaskFill(mtlc, dstOps, x, y, w, h,
 627                                      maskoff, maskscan, masklen, pMask);
 628                 SKIP_BYTES(b, masklen);
 629             }
 630             break;
 631         case sun_java2d_pipe_BufferedOpCodes_MASK_BLIT:
 632             {
 633                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 634                 jint dstx     = NEXT_INT(b);
 635                 jint dsty     = NEXT_INT(b);
 636                 jint width    = NEXT_INT(b);
 637                 jint height   = NEXT_INT(b);
 638                 jint masklen  = width * height * sizeof(jint);
 639                 MTLMaskBlit_MaskBlit(env, mtlc, dstOps,
 640                                      dstx, dsty, width, height, b);
 641                 SKIP_BYTES(b, masklen);
 642             }
 643             break;
 644 
 645         // state-related ops
 646         case sun_java2d_pipe_BufferedOpCodes_SET_RECT_CLIP:
 647             {
 648                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 649                 jint x1 = NEXT_INT(b);
 650                 jint y1 = NEXT_INT(b);
 651                 jint x2 = NEXT_INT(b);
 652                 jint y2 = NEXT_INT(b);
 653                 [mtlc setClipRectX1:x1 Y1:y1 X2:x2 Y2:y2];
 654             }
 655             break;
 656         case sun_java2d_pipe_BufferedOpCodes_BEGIN_SHAPE_CLIP:
 657             {
 658                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 659                 [mtlc beginShapeClip:dstOps];
 660             }
 661             break;
 662         case sun_java2d_pipe_BufferedOpCodes_SET_SHAPE_CLIP_SPANS:
 663             {
 664                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 665                 // This results in creation of new render encoder with
 666                 // stencil buffer set as render target
 667                 jint count = NEXT_INT(b);
 668                 MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);
 669                 SKIP_BYTES(b, count * BYTES_PER_SPAN);
 670             }
 671             break;
 672         case sun_java2d_pipe_BufferedOpCodes_END_SHAPE_CLIP:
 673             {
 674                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 675                 [mtlc endShapeClip:dstOps];
 676             }
 677             break;
 678         case sun_java2d_pipe_BufferedOpCodes_RESET_CLIP:
 679             {
 680                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 681                 [mtlc resetClip];
 682             }
 683             break;
 684         case sun_java2d_pipe_BufferedOpCodes_SET_ALPHA_COMPOSITE:
 685             {
 686                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 687                 jint rule         = NEXT_INT(b);
 688                 jfloat extraAlpha = NEXT_FLOAT(b);
 689                 jint flags        = NEXT_INT(b);
 690                 [mtlc setAlphaCompositeRule:rule extraAlpha:extraAlpha flags:flags];
 691             }
 692             break;
 693         case sun_java2d_pipe_BufferedOpCodes_SET_XOR_COMPOSITE:
 694             {
 695                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 696                 jint xorPixel = NEXT_INT(b);
 697                 [mtlc setXorComposite:xorPixel];
 698             }
 699             break;
 700         case sun_java2d_pipe_BufferedOpCodes_RESET_COMPOSITE:
 701             {
 702                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 703                 [mtlc resetComposite];
 704             }
 705             break;
 706         case sun_java2d_pipe_BufferedOpCodes_SET_TRANSFORM:
 707             {
 708                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 709                 jdouble m00 = NEXT_DOUBLE(b);
 710                 jdouble m10 = NEXT_DOUBLE(b);
 711                 jdouble m01 = NEXT_DOUBLE(b);
 712                 jdouble m11 = NEXT_DOUBLE(b);
 713                 jdouble m02 = NEXT_DOUBLE(b);
 714                 jdouble m12 = NEXT_DOUBLE(b);
 715                 [mtlc setTransformM00:m00 M10:m10 M01:m01 M11:m11 M02:m02 M12:m12];
 716             }
 717             break;
 718         case sun_java2d_pipe_BufferedOpCodes_RESET_TRANSFORM:
 719             {
 720                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 721                 [mtlc resetTransform];
 722             }
 723             break;
 724 
 725         // context-related ops
 726         case sun_java2d_pipe_BufferedOpCodes_SET_SURFACES:
 727             {
 728                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 729                 jlong pSrc = NEXT_LONG(b);
 730                 jlong pDst = NEXT_LONG(b);
 731 
 732                 dstOps = (BMTLSDOps *)jlong_to_ptr(pDst);
 733                 mtlc = [MTLContext setSurfacesEnv:env src:pSrc dst:pDst];
 734             }
 735             break;
 736         case sun_java2d_pipe_BufferedOpCodes_SET_SCRATCH_SURFACE:
 737             {
 738                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 739                 jlong pConfigInfo = NEXT_LONG(b);
 740                 MTLGraphicsConfigInfo *mtlInfo =
 741                         (MTLGraphicsConfigInfo *)jlong_to_ptr(pConfigInfo);
 742 
 743                 if (mtlInfo == NULL) {
 744 
 745                 } else {
 746                     MTLContext *newMtlc = mtlInfo-&gt;context;
 747                     if (newMtlc == NULL) {
 748 
 749                     } else {
 750                         mtlc = newMtlc;
 751                         dstOps = NULL;
 752                     }
 753                 }
 754             }
 755             break;
 756         case sun_java2d_pipe_BufferedOpCodes_FLUSH_SURFACE:
 757             {
 758                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 759                 jlong pData = NEXT_LONG(b);
 760                 BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);
 761                 if (mtlsdo != NULL) {
 762                     CONTINUE_IF_NULL(mtlc);
 763                     MTLSD_Delete(env, mtlsdo);
 764                 }
 765             }
 766             break;
 767         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_SURFACE:
 768             {
 769                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 770                 jlong pData = NEXT_LONG(b);
 771                 BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);
 772                 if (mtlsdo != NULL) {
 773                     CONTINUE_IF_NULL(mtlc);
 774                     MTLSD_Delete(env, mtlsdo);
 775                     if (mtlsdo-&gt;privOps != NULL) {
 776                         free(mtlsdo-&gt;privOps);
 777                     }
 778                 }
 779             }
 780             break;
 781         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_CONFIG:
 782             {
 783                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 784                 jlong pConfigInfo = NEXT_LONG(b);
 785                 CONTINUE_IF_NULL(mtlc);
 786                 MTLGC_DestroyMTLGraphicsConfig(pConfigInfo);
 787 
 788                 // the previous method will call glX/wglMakeCurrent(None),
 789                 // so we should nullify the current mtlc and dstOps to avoid
 790                 // calling glFlush() (or similar) while no context is current
 791                 mtlc = NULL;
 792              //   dstOps = NULL;
 793             }
 794             break;
 795         case sun_java2d_pipe_BufferedOpCodes_INVALIDATE_CONTEXT:
 796             {
 797                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 798                 // invalidate the references to the current context and
 799                 // destination surface that are maintained at the native level
 800                 mtlc = NULL;
 801             //    dstOps = NULL;
 802             }
 803             break;
 804         case sun_java2d_pipe_BufferedOpCodes_SYNC:
 805             {
 806                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 807                 sync = JNI_TRUE;
 808 
 809                 // TODO
 810                 J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLRenderQueue_SYNC -- :TODO&quot;);
 811 
 812             }
 813             break;
 814 
 815         // multibuffering ops
 816         case sun_java2d_pipe_BufferedOpCodes_SWAP_BUFFERS:
 817             {
 818                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 819                 jlong window = NEXT_LONG(b);
 820                 MTLSD_SwapBuffers(env, window);
 821             }
 822             break;
 823 
 824         // special no-op (mainly used for achieving 8-byte alignment)
 825         case sun_java2d_pipe_BufferedOpCodes_NOOP:
 826             break;
 827 
 828         // paint-related ops
 829         case sun_java2d_pipe_BufferedOpCodes_RESET_PAINT:
 830             {
 831               CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 832               [mtlc resetPaint];
 833             }
 834             break;
 835         case sun_java2d_pipe_BufferedOpCodes_SET_COLOR:
 836             {
 837                 CHECK_PREVIOUS_OP(MTL_OP_SET_COLOR);
 838                 jint pixel = NEXT_INT(b);
 839                 [mtlc setColorPaint:pixel];
 840             }
 841             break;
 842         case sun_java2d_pipe_BufferedOpCodes_SET_GRADIENT_PAINT:
 843             {
 844                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 845                 jboolean useMask= NEXT_BOOLEAN(b);
 846                 jboolean cyclic = NEXT_BOOLEAN(b);
 847                 jdouble p0      = NEXT_DOUBLE(b);
 848                 jdouble p1      = NEXT_DOUBLE(b);
 849                 jdouble p3      = NEXT_DOUBLE(b);
 850                 jint pixel1     = NEXT_INT(b);
 851                 jint pixel2     = NEXT_INT(b);
 852                 [mtlc setGradientPaintUseMask:useMask
 853                                     cyclic:cyclic
 854                                         p0:p0
 855                                         p1:p1
 856                                         p3:p3
 857                                     pixel1:pixel1
 858                                     pixel2:pixel2];
 859             }
 860             break;
 861         case sun_java2d_pipe_BufferedOpCodes_SET_LINEAR_GRADIENT_PAINT:
 862             {
 863                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 864                 jboolean useMask = NEXT_BOOLEAN(b);
 865                 jboolean linear  = NEXT_BOOLEAN(b);
 866                 jint cycleMethod = NEXT_INT(b);
 867                 jint numStops    = NEXT_INT(b);
 868                 jfloat p0        = NEXT_FLOAT(b);
 869                 jfloat p1        = NEXT_FLOAT(b);
 870                 jfloat p3        = NEXT_FLOAT(b);
 871                 void *fractions, *pixels;
 872                 fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));
 873                 pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));
 874                 [mtlc setLinearGradientPaint:useMask
 875                                       linear:linear
 876                                  cycleMethod:cycleMethod
 877                                     numStops:numStops
 878                                           p0:p0
 879                                           p1:p1
 880                                           p3:p3
 881                                    fractions:fractions
 882                                       pixels:pixels];
 883             }
 884             break;
 885         case sun_java2d_pipe_BufferedOpCodes_SET_RADIAL_GRADIENT_PAINT:
 886             {
 887                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 888                 jboolean useMask = NEXT_BOOLEAN(b);
 889                 jboolean linear  = NEXT_BOOLEAN(b);
 890                 jint numStops    = NEXT_INT(b);
 891                 jint cycleMethod = NEXT_INT(b);
 892                 jfloat m00       = NEXT_FLOAT(b);
 893                 jfloat m01       = NEXT_FLOAT(b);
 894                 jfloat m02       = NEXT_FLOAT(b);
 895                 jfloat m10       = NEXT_FLOAT(b);
 896                 jfloat m11       = NEXT_FLOAT(b);
 897                 jfloat m12       = NEXT_FLOAT(b);
 898                 jfloat focusX    = NEXT_FLOAT(b);
 899                 void *fractions, *pixels;
 900                 fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));
 901                 pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));
 902                 [mtlc setRadialGradientPaint:useMask
 903                                       linear:linear
 904                                  cycleMethod:cycleMethod
 905                                     numStops:numStops
 906                                          m00:m00
 907                                          m01:m01
 908                                          m02:m02
 909                                          m10:m10
 910                                          m11:m11
 911                                          m12:m12
 912                                       focusX:focusX
 913                                    fractions:fractions
 914                                       pixels:pixels];
 915             }
 916             break;
 917         case sun_java2d_pipe_BufferedOpCodes_SET_TEXTURE_PAINT:
 918             {
 919                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 920                 jboolean useMask= NEXT_BOOLEAN(b);
 921                 jboolean filter = NEXT_BOOLEAN(b);
 922                 jlong pSrc      = NEXT_LONG(b);
 923                 jdouble xp0     = NEXT_DOUBLE(b);
 924                 jdouble xp1     = NEXT_DOUBLE(b);
 925                 jdouble xp3     = NEXT_DOUBLE(b);
 926                 jdouble yp0     = NEXT_DOUBLE(b);
 927                 jdouble yp1     = NEXT_DOUBLE(b);
 928                 jdouble yp3     = NEXT_DOUBLE(b);
 929                 [mtlc setTexturePaint:useMask
 930                               pSrcOps:pSrc
 931                                filter:filter
 932                                   xp0:xp0
 933                                   xp1:xp1
 934                                   xp3:xp3
 935                                   yp0:yp0
 936                                   yp1:yp1
 937                                   yp3:yp3];
 938             }
 939             break;
 940 
 941         // BufferedImageOp-related ops
 942         case sun_java2d_pipe_BufferedOpCodes_ENABLE_CONVOLVE_OP:
 943             {
 944                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 945                 jlong pSrc        = NEXT_LONG(b);
 946                 jboolean edgeZero = NEXT_BOOLEAN(b);
 947                 jint kernelWidth  = NEXT_INT(b);
 948                 jint kernelHeight = NEXT_INT(b);
 949                 MTLBufImgOps_EnableConvolveOp(mtlc, pSrc, edgeZero,
 950                                               kernelWidth, kernelHeight, b);
 951                 SKIP_BYTES(b, kernelWidth * kernelHeight * sizeof(jfloat));
 952             }
 953             break;
 954         case sun_java2d_pipe_BufferedOpCodes_DISABLE_CONVOLVE_OP:
 955             {
 956                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 957                 MTLBufImgOps_DisableConvolveOp(mtlc);
 958             }
 959             break;
 960         case sun_java2d_pipe_BufferedOpCodes_ENABLE_RESCALE_OP:
 961             {
 962                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 963                 jlong pSrc          = NEXT_LONG(b);
 964                 jboolean nonPremult = NEXT_BOOLEAN(b);
 965                 jint numFactors     = 4;
 966                 unsigned char *scaleFactors = b;
 967                 unsigned char *offsets = (b + numFactors * sizeof(jfloat));
 968                 MTLBufImgOps_EnableRescaleOp(mtlc, pSrc, nonPremult,
 969                                              scaleFactors, offsets);
 970                 SKIP_BYTES(b, numFactors * sizeof(jfloat) * 2);
 971             }
 972             break;
 973         case sun_java2d_pipe_BufferedOpCodes_DISABLE_RESCALE_OP:
 974             {
 975                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 976                 MTLBufImgOps_DisableRescaleOp(mtlc);
 977             }
 978             break;
 979         case sun_java2d_pipe_BufferedOpCodes_ENABLE_LOOKUP_OP:
 980             {
 981                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 982                 jlong pSrc          = NEXT_LONG(b);
 983                 jboolean nonPremult = NEXT_BOOLEAN(b);
 984                 jboolean shortData  = NEXT_BOOLEAN(b);
 985                 jint numBands       = NEXT_INT(b);
 986                 jint bandLength     = NEXT_INT(b);
 987                 jint offset         = NEXT_INT(b);
 988                 jint bytesPerElem = shortData ? sizeof(jshort):sizeof(jbyte);
 989                 void *tableValues = b;
 990                 MTLBufImgOps_EnableLookupOp(mtlc, pSrc, nonPremult, shortData,
 991                                             numBands, bandLength, offset,
 992                                             tableValues);
 993                 SKIP_BYTES(b, numBands * bandLength * bytesPerElem);
 994             }
 995             break;
 996         case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:
 997             {
 998                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 999                 MTLBufImgOps_DisableLookupOp(mtlc);
1000             }
1001             break;
1002 
1003         default:
1004             J2dRlsTraceLn1(J2D_TRACE_ERROR,
1005                 &quot;MTLRenderQueue_flushBuffer: invalid opcode=%d&quot;, opcode);
1006             return;
1007         }
1008     }
1009 
1010     if (mtlc != NULL) {
1011         [mtlc.encoderManager endEncoder];
1012         MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];
1013         id&lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
1014         [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
1015             [cbwrapper release];
1016         }];
1017         [commandbuf commit];
1018         if (sync) {
1019             [commandbuf waitUntilCompleted];
1020         }
1021         BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
1022         if (dstOps != NULL) {
1023             MTLSDOps *dstMTLOps = (MTLSDOps *)dstOps-&gt;privOps;
1024             MTLLayer *layer = (MTLLayer*)dstMTLOps-&gt;layer;
1025             if (layer != NULL) {
1026                 [JNFRunLoop performOnMainThreadWaiting:NO withBlock:^(){
1027                     AWT_ASSERT_APPKIT_THREAD;
1028                     [layer setNeedsDisplay];
1029                 }];
1030             }
1031         }
1032     }
1033     RESET_PREVIOUS_OP();
1034 }
1035 
1036 /**
1037  * Returns a pointer to the &quot;current&quot; context, as set by the last SET_SURFACES
1038  * or SET_SCRATCH_SURFACE operation.
1039  */
1040 MTLContext *
1041 MTLRenderQueue_GetCurrentContext()
1042 {
1043     return mtlc;
1044 }
1045 
1046 /**
1047  * Returns a pointer to the &quot;current&quot; destination surface, as set by the last
1048  * SET_SURFACES operation.
1049  */
1050 BMTLSDOps *
1051 MTLRenderQueue_GetCurrentDestination()
1052 {
1053     return dstOps;
1054 }
1055 
1056 #endif /* !HEADLESS */
    </pre>
  </body>
</html>
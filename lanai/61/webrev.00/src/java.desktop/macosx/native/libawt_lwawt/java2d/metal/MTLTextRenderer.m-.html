<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLTextRenderer.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef HEADLESS
 27 
 28 #include &lt;stdlib.h&gt;
 29 #include &lt;limits.h&gt;
 30 #include &lt;math.h&gt;
 31 #include &lt;jlong.h&gt;
 32 
 33 #include &quot;sun_java2d_metal_MTLTextRenderer.h&quot;
 34 
 35 #include &quot;SurfaceData.h&quot;
 36 #include &quot;MTLContext.h&quot;
 37 #include &quot;MTLRenderQueue.h&quot;
 38 #include &quot;MTLTextRenderer.h&quot;
 39 #include &quot;MTLVertexCache.h&quot;
 40 #include &quot;MTLGlyphCache.h&quot;
 41 #include &quot;MTLBlitLoops.h&quot;
 42 
 43 /**
 44  * The following constants define the inner and outer bounds of the
 45  * accelerated glyph cache.
 46  */
 47 #define MTLTR_CACHE_WIDTH       512
 48 #define MTLTR_CACHE_HEIGHT      512
 49 #define MTLTR_CACHE_CELL_WIDTH  32
 50 #define MTLTR_CACHE_CELL_HEIGHT 32
 51 
 52 /**
 53  * The current &quot;glyph mode&quot; state.  This variable is used to track the
 54  * codepath used to render a particular glyph.  This variable is reset to
 55  * MODE_NOT_INITED at the beginning of every call to MTLTR_DrawGlyphList().
 56  * As each glyph is rendered, the glyphMode variable is updated to reflect
 57  * the current mode, so if the current mode is the same as the mode used
 58  * to render the previous glyph, we can avoid doing costly setup operations
 59  * each time.
 60  */
 61 typedef enum {
 62     MODE_NOT_INITED,
 63     MODE_USE_CACHE_GRAY,
 64     MODE_USE_CACHE_LCD,
 65     MODE_NO_CACHE_GRAY,
 66     MODE_NO_CACHE_LCD,
 67     MODE_NO_CACHE_COLOR
 68 } GlyphMode;
 69 static GlyphMode glyphMode = MODE_NOT_INITED;
 70 
 71 /**
 72  * There are two separate glyph caches: for AA and for LCD.
 73  * Once one of them is initialized as either GRAY or LCD, it
 74  * stays in that mode for the duration of the application.  It should
 75  * be safe to use this one glyph cache for all screens in a multimon
 76  * environment, since the glyph cache texture is shared between all contexts,
 77  * and (in theory) OpenGL drivers should be smart enough to manage that
 78  * texture across all screens.
 79  */
 80 
 81 static MTLGlyphCacheInfo *glyphCacheLCD = NULL;
 82 static MTLGlyphCacheInfo *glyphCacheAA = NULL;
 83 
 84 /**
 85  * The handle to the LCD text fragment program object.
 86  */
 87 static GLhandleARB lcdTextProgram = 0;
 88 
 89 /**
 90  * This value tracks the previous LCD contrast setting, so if the contrast
 91  * value hasn&#39;t changed since the last time the gamma uniforms were
 92  * updated (not very common), then we can skip updating the unforms.
 93  */
 94 static jint lastLCDContrast = -1;
 95 
 96 /**
 97  * This value tracks the previous LCD rgbOrder setting, so if the rgbOrder
 98  * value has changed since the last time, it indicates that we need to
 99  * invalidate the cache, which may already store glyph images in the reverse
100  * order.  Note that in most real world applications this value will not
101  * change over the course of the application, but tests like Font2DTest
102  * allow for changing the ordering at runtime, so we need to handle that case.
103  */
104 static jboolean lastRGBOrder = JNI_TRUE;
105 
106 /**
107  * This constant defines the size of the tile to use in the
108  * MTLTR_DrawLCDGlyphNoCache() method.  See below for more on why we
109  * restrict this value to a particular size.
110  */
111 #define MTLTR_NOCACHE_TILE_SIZE 32
112 
113 /**
114  * These constants define the size of the &quot;cached destination&quot; texture.
115  * This texture is only used when rendering LCD-optimized text, as that
116  * codepath needs direct access to the destination.  There is no way to
117  * access the framebuffer directly from an OpenGL shader, so we need to first
118  * copy the destination region corresponding to a particular glyph into
119  * this cached texture, and then that texture will be accessed inside the
120  * shader.  Copying the destination into this cached texture can be a very
121  * expensive operation (accounting for about half the rendering time for
122  * LCD text), so to mitigate this cost we try to bulk read a horizontal
123  * region of the destination at a time.  (These values are empirically
124  * derived for the common case where text runs horizontally.)
125  *
126  * Note: It is assumed in various calculations below that:
127  *     (MTLTR_CACHED_DEST_WIDTH  &gt;= MTLTR_CACHE_CELL_WIDTH)  &amp;&amp;
128  *     (MTLTR_CACHED_DEST_WIDTH  &gt;= MTLTR_NOCACHE_TILE_SIZE) &amp;&amp;
129  *     (MTLTR_CACHED_DEST_HEIGHT &gt;= MTLTR_CACHE_CELL_HEIGHT) &amp;&amp;
130  *     (MTLTR_CACHED_DEST_HEIGHT &gt;= MTLTR_NOCACHE_TILE_SIZE)
131  */
132 #define MTLTR_CACHED_DEST_WIDTH  512
133 #define MTLTR_CACHED_DEST_HEIGHT (MTLTR_CACHE_CELL_HEIGHT * 2)
134 
135 /**
136  * The handle to the &quot;cached destination&quot; texture object.
137  */
138 static GLuint cachedDestTextureID = 0;
139 
140 /**
141  * The current bounds of the &quot;cached destination&quot; texture, in destination
142  * coordinate space.  The width/height of these bounds will not exceed the
143  * MTLTR_CACHED_DEST_WIDTH/HEIGHT values defined above.  These bounds are
144  * only considered valid when the isCachedDestValid flag is JNI_TRUE.
145  */
146 static SurfaceDataBounds cachedDestBounds;
147 
148 /**
149  * This flag indicates whether the &quot;cached destination&quot; texture contains
150  * valid data.  This flag is reset to JNI_FALSE at the beginning of every
151  * call to MTLTR_DrawGlyphList().  Once we copy valid destination data
152  * into the cached texture, this flag is set to JNI_TRUE.  This way, we can
153  * limit the number of times we need to copy destination data, which is a
154  * very costly operation.
155  */
156 static jboolean isCachedDestValid = JNI_FALSE;
157 
158 /**
159  * The bounds of the previously rendered LCD glyph, in destination
160  * coordinate space.  We use these bounds to determine whether the glyph
161  * currently being rendered overlaps the previously rendered glyph (i.e.
162  * its bounding box intersects that of the previously rendered glyph).  If
163  * so, we need to re-read the destination area associated with that previous
164  * glyph so that we can correctly blend with the actual destination data.
165  */
166 static SurfaceDataBounds previousGlyphBounds;
167 
168 static struct TxtVertex txtVertices[6];
169 static jint vertexCacheIndex = 0;
170 
171 #define LCD_ADD_VERTEX(TX, TY, DX, DY, DZ) \
172     do { \
173         struct TxtVertex *v = &amp;txtVertices[vertexCacheIndex++]; \
174         v-&gt;txtpos[0] = TX; \
175         v-&gt;txtpos[1] = TY; \
176         v-&gt;position[0]= DX; \
177         v-&gt;position[1] = DY; \
178     } while (0)
179 
180 #define LCD_ADD_TRIANGLES(TX1, TY1, TX2, TY2, DX1, DY1, DX2, DY2) \
181     do { \
182         LCD_ADD_VERTEX(TX1, TY1, DX1, DY1, 0); \
183         LCD_ADD_VERTEX(TX2, TY1, DX2, DY1, 0); \
184         LCD_ADD_VERTEX(TX2, TY2, DX2, DY2, 0); \
185         LCD_ADD_VERTEX(TX2, TY2, DX2, DY2, 0); \
186         LCD_ADD_VERTEX(TX1, TY2, DX1, DY2, 0); \
187         LCD_ADD_VERTEX(TX1, TY1, DX1, DY1, 0); \
188     } while (0)
189 
190 /**
191  * Initializes the one glyph cache (texture and data structure).
192  * If lcdCache is JNI_TRUE, the texture will contain RGB data,
193  * otherwise we will simply store the grayscale/monochrome glyph images
194  * as intensity values (which work well with the GL_MODULATE function).
195  */
196 static jboolean
197 MTLTR_InitGlyphCache(MTLContext *mtlc, jboolean lcdCache)
198 {
199     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_InitGlyphCache&quot;);
200     // TODO : Need to fix RGB order in case of LCD
201     MTLPixelFormat pixelFormat = MTLPixelFormatBGRA8Unorm;
202 
203     MTLGlyphCacheInfo *gcinfo;
204     // init glyph cache data structure
205     gcinfo = MTLGlyphCache_Init(MTLTR_CACHE_WIDTH,
206                                 MTLTR_CACHE_HEIGHT,
207                                 MTLTR_CACHE_CELL_WIDTH,
208                                 MTLTR_CACHE_CELL_HEIGHT,
209                                 MTLVertexCache_FlushGlyphVertexCache);
210 
211     if (gcinfo == NULL) {
212         J2dRlsTraceLn(J2D_TRACE_ERROR,
213                       &quot;MTLTR_InitGlyphCache: could not init MTL glyph cache&quot;);
214         return JNI_FALSE;
215     }
216 
217     MTLTextureDescriptor *textureDescriptor =
218         [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:pixelFormat
219                                                             width:MTLTR_CACHE_WIDTH
220                                                             height:MTLTR_CACHE_HEIGHT
221                                                             mipmapped:NO];
222 
223     gcinfo-&gt;texture = [mtlc.device newTextureWithDescriptor:textureDescriptor];
224     [textureDescriptor release];
225 
226     if (lcdCache) {
227         glyphCacheLCD = gcinfo;
228     } else {
229         glyphCacheAA = gcinfo;
230     }
231 
232     return JNI_TRUE;
233 }
234 
235 id&lt;MTLTexture&gt;
236 MTLTR_GetGlyphCacheTexture()
237 {
238     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_GetGlyphCacheTexture&quot;);
239     if (glyphCacheAA != NULL) {
240         return glyphCacheAA-&gt;texture;
241     }
242     return NULL;
243 }
244 
245 /**
246  * Adds the given glyph to the glyph cache (texture and data structure)
247  * associated with the given MTLContext.
248  */
249 static void
250 MTLTR_AddToGlyphCache(GlyphInfo *glyph, MTLContext *mtlc,
251                       MTLPixelFormat pixelFormat)
252 {
253     MTLCacheCellInfo *ccinfo;
254     MTLGlyphCacheInfo *gcinfo;
255     jboolean isLCD = JNI_FALSE;
256     jint w = glyph-&gt;width;
257     jint h = glyph-&gt;height;
258 
259     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_AddToGlyphCache&quot;);
260     if (pixelFormat == MTLPixelFormatA8Unorm) {
261         gcinfo = glyphCacheAA;
262     } else {
263         gcinfo = glyphCacheLCD;
264         isLCD = JNI_TRUE;
265     }
266 
267     if ((gcinfo == NULL) || (glyph-&gt;image == NULL)) {
268         return;
269     }
270 
271     bool isCacheFull = MTLGlyphCache_IsCacheFull(gcinfo, glyph);
272     if (isCacheFull) {
273         MTLGlyphCache_Free(gcinfo);
274         if (!isLCD) {
275             MTLTR_InitGlyphCache(mtlc, JNI_FALSE);
276             gcinfo = glyphCacheAA;
277         } else {
278             MTLTR_InitGlyphCache(mtlc, JNI_TRUE);
279             gcinfo = glyphCacheLCD;
280         }
281     }
282     MTLGlyphCache_AddGlyph(gcinfo, glyph);
283     ccinfo = (MTLCacheCellInfo *) glyph-&gt;cellInfo;
284 
285     if (ccinfo != NULL) {
286         // store glyph image in texture cell
287         MTLRegion region = {
288                 {ccinfo-&gt;x,  ccinfo-&gt;y,   0},
289                 {w, h, 1}
290         };
291         if (!isLCD) {
292             // Opengl uses GL_INTENSITY as internal pixel format to set number of
293             // color components in the texture for grayscale texture.
294             // It is mentioned that for GL_INTENSITY format,
295             // the GL assembles it into an RGBA element by replicating the
296             // intensity value three times for red, green, blue, and alpha.
297             // To let metal behave the same for grayscale text,
298             // we need to make sure we create BGRA component by replicating
299             // graycale pixel value as in R=G=B=A=grayscale pixel value
300 
301             unsigned int imageBytes = w * h * 4;
302             unsigned char imageData[imageBytes];
303             memset(&amp;imageData, 0, sizeof(imageData));
304 
305             unsigned int dstindex = 0;
306             for (int i = 0; i &lt; (w * h); i++) {
307                 imageData[dstindex++] = glyph-&gt;image[i];
308                 imageData[dstindex++] = glyph-&gt;image[i];
309                 imageData[dstindex++] = glyph-&gt;image[i];
310                 imageData[dstindex++] = glyph-&gt;image[i];
311             }
312             NSUInteger bytesPerRow = 4 * w;
313             [gcinfo-&gt;texture replaceRegion:region
314                              mipmapLevel:0
315                              withBytes:imageData
316                              bytesPerRow:bytesPerRow];
317         } else {
318             unsigned int imageBytes = w * h * 4;
319             unsigned char imageData[imageBytes];
320             memset(&amp;imageData, 0, sizeof(imageData));
321 
322             for (int i = 0; i &lt; h; i++) {
323                 for (int j = 0; j &lt; w; j++) {
324                     imageData[(i * w * 4) + j * 4] = glyph-&gt;image[(i * w * 3) + j * 3];
325                     imageData[(i * w * 4) + j * 4 + 1] = glyph-&gt;image[(i * w * 3) + j * 3 + 1];
326                     imageData[(i * w * 4) + j * 4 + 2] = glyph-&gt;image[(i * w * 3) + j * 3 + 2];
327                     imageData[(i * w * 4) + j * 4 + 3] = 0xFF;
328                 }
329             }
330 
331             NSUInteger bytesPerRow = 4 * w;
332             [gcinfo-&gt;texture replaceRegion:region
333                              mipmapLevel:0
334                              withBytes:imageData
335                              bytesPerRow:bytesPerRow];
336         }
337     }
338 }
339 
340 static MTLRenderPipelineDescriptor * templateRenderPipelineDesc = nil;
341 static MTLRenderPipelineDescriptor * templateLCDPipelineDesc = nil;
342 
343 /**
344  * Enables the LCD text shader and updates any related state, such as the
345  * gamma lookup table textures.
346  */
347 static jboolean
348 MTLTR_EnableLCDGlyphModeState(id&lt;MTLRenderCommandEncoder&gt; encoder,
349                               MTLContext *mtlc, 
350                               MTLSDOps *dstOps,
351                               jint contrast)
352 {
353     // create the LCD text shader, if necessary
354     if (templateLCDPipelineDesc == nil) {
355 
356         MTLVertexDescriptor *vertDesc = [[MTLVertexDescriptor new] autorelease];
357         vertDesc.attributes[VertexAttributePosition].format = MTLVertexFormatFloat2;
358         vertDesc.attributes[VertexAttributePosition].offset = 0;
359         vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;
360         vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct Vertex);
361         vertDesc.layouts[MeshVertexBuffer].stepRate = 1;
362         vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
363 
364         templateLCDPipelineDesc = [[MTLRenderPipelineDescriptor new] autorelease];
365         templateLCDPipelineDesc.sampleCount = 1;
366         templateLCDPipelineDesc.vertexDescriptor = vertDesc;
367         templateLCDPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;
368         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].format = MTLVertexFormatFloat2;
369         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].offset = 2*sizeof(float);
370         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].bufferIndex = MeshVertexBuffer;
371         templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stride = sizeof(struct TxtVertex);
372         templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepRate = 1;
373         templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
374         templateLCDPipelineDesc.label = @&quot;template_lcd&quot;;
375     }
376 
377     id&lt;MTLRenderPipelineState&gt; pipelineState =
378                 [mtlc.pipelineStateStorage
379                     getPipelineState:templateLCDPipelineDesc
380                     vertexShaderId:@&quot;vert_txt&quot;
381                     fragmentShaderId:@&quot;lcd_color&quot;
382                    ];
383 
384     [encoder setRenderPipelineState:pipelineState];
385 
386     // update the current color settings
387     double gamma = ((double)contrast) / 100.0;
388     double invgamma = 1.0/gamma;
389     jfloat radj, gadj, badj;
390     jfloat clr[4];
391     jint col = [mtlc.paint getColor];
392 
393     J2dTraceLn2(J2D_TRACE_INFO, &quot;primary color %x, contrast %d&quot;, col, contrast);
394     J2dTraceLn2(J2D_TRACE_INFO, &quot;gamma %f, invgamma %f&quot;, gamma, invgamma);
395 
396     clr[0] = ((col &gt;&gt; 16) &amp; 0xFF)/255.0f;
397     clr[1] = ((col &gt;&gt; 8) &amp; 0xFF)/255.0f;
398     clr[2] = ((col) &amp; 0xFF)/255.0f;
399 
400     // gamma adjust the primary color
401     radj = (float)pow(clr[0], gamma);
402     gadj = (float)pow(clr[1], gamma);
403     badj = (float)pow(clr[2], gamma);
404 
405     struct LCDFrameUniforms uf = {
406             {radj, gadj, badj},
407             {gamma, gamma, gamma},
408             {invgamma, invgamma, invgamma}};
409     [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
410 
411     return JNI_TRUE;
412 }
413 
414 void
415 MTLTR_EnableGlyphVertexCache(MTLContext *mtlc, BMTLSDOps *dstOps)
416 {
417 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_EnableGlyphVertexCache&quot;);
418 
419     if (!MTLVertexCache_InitVertexCache()) {
420         return;
421     }
422 
423     if (glyphCacheAA == NULL) {
424         if (!MTLTR_InitGlyphCache(mtlc, JNI_FALSE)) {
425             return;
426         }
427     }
428     MTLVertexCache_CreateSamplingEncoder(mtlc, dstOps);
429 }
430 
431 void
432 MTLTR_DisableGlyphVertexCache(MTLContext *mtlc)
433 {
434     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DisableGlyphVertexCache&quot;);
435     MTLVertexCache_FlushGlyphVertexCache();
436     MTLVertexCache_RestoreColorState(mtlc);
437     MTLVertexCache_FreeVertexCache();
438 }
439 
440 /**
441  * Disables any pending state associated with the current &quot;glyph mode&quot;.
442  */
443 void
444 MTLTR_DisableGlyphModeState()
445 {
446     // TODO : This is similar to OpenGL implementation
447     // When LCD implementation is done weshould make
448     // more changes.
449     J2dTraceLn1(J2D_TRACE_VERBOSE,
450                 &quot;MTLTR_DisableGlyphModeState: mode=%d&quot;, glyphMode);
451     switch (glyphMode) {
452     case MODE_NO_CACHE_LCD:
453         // TODO : Along with LCD implementation
454         // changes needs to be made
455     case MODE_USE_CACHE_LCD:
456         // TODO : Along with LCD implementation
457         // changes needs to be made
458         break;
459     case MODE_NO_CACHE_GRAY:
460     case MODE_USE_CACHE_GRAY:
461     case MODE_NOT_INITED:
462     default:
463         break;
464     }
465 }
466 
467 static jboolean
468 MTLTR_DrawGrayscaleGlyphViaCache(MTLContext *mtlc,
469                                  GlyphInfo *ginfo, jint x, jint y, BMTLSDOps *dstOps)
470 {
471     MTLCacheCellInfo *cell;
472     jfloat x1, y1, x2, y2;
473 
474     if (glyphMode != MODE_USE_CACHE_GRAY) {
475         if (glyphMode == MODE_NO_CACHE_GRAY) {
476             MTLVertexCache_DisableMaskCache(mtlc);
477         }
478         MTLTR_EnableGlyphVertexCache(mtlc, dstOps);
479         glyphMode = MODE_USE_CACHE_GRAY;
480     }
481 
482     if (ginfo-&gt;cellInfo == NULL) {
483         // attempt to add glyph to accelerated glyph cache
484         MTLTR_AddToGlyphCache(ginfo, mtlc, MTLPixelFormatA8Unorm);
485 
486         if (ginfo-&gt;cellInfo == NULL) {
487             // we&#39;ll just no-op in the rare case that the cell is NULL
488             return JNI_TRUE;
489         }
490     }
491 
492     cell = (MTLCacheCellInfo *) (ginfo-&gt;cellInfo);
493     cell-&gt;timesRendered++;
494 
495     x1 = (jfloat)x;
496     y1 = (jfloat)y;
497     x2 = x1 + ginfo-&gt;width;
498     y2 = y1 + ginfo-&gt;height;
499 
500     MTLVertexCache_AddGlyphQuad(mtlc,
501                                 cell-&gt;tx1, cell-&gt;ty1,
502                                 cell-&gt;tx2, cell-&gt;ty2,
503                                 x1, y1, x2, y2);
504 
505     return JNI_TRUE;
506 }
507 
508 /**
509  * Evaluates to true if the rectangle defined by gx1/gy1/gx2/gy2 is
510  * inside outerBounds.
511  */
512 #define INSIDE(gx1, gy1, gx2, gy2, outerBounds) \
513     (((gx1) &gt;= outerBounds.x1) &amp;&amp; ((gy1) &gt;= outerBounds.y1) &amp;&amp; \
514      ((gx2) &lt;= outerBounds.x2) &amp;&amp; ((gy2) &lt;= outerBounds.y2))
515 
516 /**
517  * Evaluates to true if the rectangle defined by gx1/gy1/gx2/gy2 intersects
518  * the rectangle defined by bounds.
519  */
520 #define INTERSECTS(gx1, gy1, gx2, gy2, bounds) \
521     ((bounds.x2 &gt; (gx1)) &amp;&amp; (bounds.y2 &gt; (gy1)) &amp;&amp; \
522      (bounds.x1 &lt; (gx2)) &amp;&amp; (bounds.y1 &lt; (gy2)))
523 
524 /**
525  * This method checks to see if the given LCD glyph bounds fall within the
526  * cached destination texture bounds.  If so, this method can return
527  * immediately.  If not, this method will copy a chunk of framebuffer data
528  * into the cached destination texture and then update the current cached
529  * destination bounds before returning.
530  */
531 static void
532 MTLTR_UpdateCachedDestination(MTLSDOps *dstOps, GlyphInfo *ginfo,
533                               jint gx1, jint gy1, jint gx2, jint gy2,
534                               jint glyphIndex, jint totalGlyphs)
535 {
536     //TODO
537 }
538 
539 static jboolean
540 MTLTR_DrawLCDGlyphViaCache(MTLContext *mtlc, BMTLSDOps *dstOps,
541                            GlyphInfo *ginfo, jint x, jint y,
542                            jint rowBytesOffset,
543                            jboolean rgbOrder, jint contrast,
544                            id&lt;MTLTexture&gt; dstTexture)
545 {
546     CacheCellInfo *cell;
547     jfloat tx1, ty1, tx2, ty2;
548     jint w = ginfo-&gt;width;
549     jint h = ginfo-&gt;height;
550 
551     id&lt;MTLRenderCommandEncoder&gt; encoder = nil;
552 
553     if (glyphMode != MODE_USE_CACHE_LCD) {
554         if (glyphMode == MODE_NO_CACHE_GRAY) {
555             MTLVertexCache_DisableMaskCache(mtlc);
556         } else if (glyphMode == MODE_USE_CACHE_GRAY) {
557             MTLTR_DisableGlyphVertexCache(mtlc);
558         }
559 
560         if (glyphCacheLCD == NULL) {
561             if (!MTLTR_InitGlyphCache(mtlc, JNI_TRUE)) {
562                 return JNI_FALSE;
563             }
564         }
565 
566         if (rgbOrder != lastRGBOrder) {
567             // need to invalidate the cache in this case; see comments
568             // for lastRGBOrder above
569             MTLGlyphCache_Invalidate(glyphCacheLCD);
570             lastRGBOrder = rgbOrder;
571         }
572 
573         glyphMode = MODE_USE_CACHE_LCD;
574     }
575 
576     if (ginfo-&gt;cellInfo == NULL) {
577         // attempt to add glyph to accelerated glyph cache
578         // TODO : Handle RGB order
579         MTLTR_AddToGlyphCache(ginfo, mtlc, MTLPixelFormatRGBA8Unorm);
580 
581         if (ginfo-&gt;cellInfo == NULL) {
582             // we&#39;ll just no-op in the rare case that the cell is NULL
583             return JNI_TRUE;
584         }
585     }
586     cell = (CacheCellInfo *) (ginfo-&gt;cellInfo);
587     cell-&gt;timesRendered++;
588     encoder = [mtlc.encoderManager getTextureEncoder:dstOps-&gt;pTexture isSrcOpaque:YES isDstOpaque:YES];
589     if (!MTLTR_EnableLCDGlyphModeState(encoder, mtlc, dstOps,contrast))
590     {
591         return JNI_FALSE;
592     }
593 
594     tx1 = cell-&gt;tx1;
595     ty1 = cell-&gt;ty1;
596     tx2 = cell-&gt;tx2;
597     ty2 = cell-&gt;ty2;
598 
599     J2dTraceLn4(J2D_TRACE_INFO, &quot;tx1 %f, ty1 %f, tx2 %f, ty2 %f&quot;, tx1, ty1, tx2, ty2);
600     J2dTraceLn2(J2D_TRACE_INFO, &quot;textureWidth %d textureHeight %d&quot;, dstOps-&gt;textureWidth, dstOps-&gt;textureHeight);
601 
602     LCD_ADD_TRIANGLES(tx1, ty1, tx2, ty2, x, y, x+w, y+h);
603 
604     [encoder setVertexBytes:txtVertices length:sizeof(txtVertices) atIndex:MeshVertexBuffer];
605     [encoder setFragmentTexture:glyphCacheLCD-&gt;texture atIndex:0];
606     [encoder setFragmentTexture:dstOps-&gt;pTexture atIndex:1];
607 
608     [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];
609 
610     vertexCacheIndex = 0;
611     [mtlc.encoderManager endEncoder];
612 
613     return JNI_TRUE;
614 }
615 
616 static jboolean
617 MTLTR_DrawGrayscaleGlyphNoCache(MTLContext *mtlc,
618                                 GlyphInfo *ginfo, jint x, jint y, BMTLSDOps *dstOps)
619 {
620     jint tw, th;
621     jint sx, sy, sw, sh;
622     jint x0;
623     jint w = ginfo-&gt;width;
624     jint h = ginfo-&gt;height;
625 
626     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGrayscaleGlyphNoCache&quot;);
627     if (glyphMode != MODE_NO_CACHE_GRAY) {
628         if (glyphMode == MODE_USE_CACHE_GRAY) {
629             MTLTR_DisableGlyphVertexCache(mtlc);
630         }
631         MTLVertexCache_EnableMaskCache(mtlc, dstOps);
632         glyphMode = MODE_NO_CACHE_GRAY;
633     }
634 
635     x0 = x;
636     tw = MTLVC_MASK_CACHE_TILE_WIDTH;
637     th = MTLVC_MASK_CACHE_TILE_HEIGHT;
638 
639     for (sy = 0; sy &lt; h; sy += th, y += th) {
640         x = x0;
641         sh = ((sy + th) &gt; h) ? (h - sy) : th;
642 
643         for (sx = 0; sx &lt; w; sx += tw, x += tw) {
644             sw = ((sx + tw) &gt; w) ? (w - sx) : tw;
645 
646             J2dTraceLn7(J2D_TRACE_INFO, &quot;sx = %d sy = %d x = %d y = %d sw = %d sh = %d w = %d&quot;, sx, sy, x, y, sw, sh, w);
647             MTLVertexCache_AddMaskQuad(mtlc,
648                                        sx, sy, x, y, sw, sh,
649                                        w, ginfo-&gt;image,
650                                        dstOps,
651                                        ginfo-&gt;width);
652         }
653     }
654 
655     return JNI_TRUE;
656 }
657 
658 
659 static jboolean
660 MTLTR_DrawLCDGlyphNoCache(MTLContext *mtlc, BMTLSDOps *dstOps,
661                           GlyphInfo *ginfo, jint x, jint y,
662                           jint rowBytesOffset,
663                           jboolean rgbOrder, jint contrast,
664                           id&lt;MTLTexture&gt; dstTexture)
665 {
666     jfloat tx1, ty1, tx2, ty2;
667     jfloat dtx1=0, dty1=0, dtx2=0, dty2=0;
668     jint tw, th;
669     jint sx=0, sy=0, sw=0, sh=0, dxadj=0, dyadj=0;
670     jint x0;
671     jint w = ginfo-&gt;width;
672     jint h = ginfo-&gt;height;
673     id&lt;MTLTexture&gt; blitTexture = nil;
674 
675     J2dTraceLn2(J2D_TRACE_INFO, &quot;MTLTR_DrawLCDGlyphNoCache x %d, y%d&quot;, x, y);
676     J2dTraceLn3(J2D_TRACE_INFO, &quot;MTLTR_DrawLCDGlyphNoCache rowBytesOffset=%d, rgbOrder=%d, contrast=%d&quot;, rowBytesOffset, rgbOrder, contrast);
677 
678 
679     id&lt;MTLRenderCommandEncoder&gt; encoder = nil;
680 
681     MTLTextureDescriptor *textureDescriptor =
682         [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatBGRA8Unorm
683                                                             width:w
684                                                             height:h
685                                                             mipmapped:NO];
686 
687     blitTexture = [mtlc.device newTextureWithDescriptor:textureDescriptor];
688     [textureDescriptor release];
689 
690     if (glyphMode != MODE_NO_CACHE_LCD) {
691         if (glyphMode == MODE_NO_CACHE_GRAY) {
692             MTLVertexCache_DisableMaskCache(mtlc);
693         } else if (glyphMode == MODE_USE_CACHE_GRAY) {
694             MTLTR_DisableGlyphVertexCache(mtlc);
695         }
696 
697         if (blitTexture == nil) {
698             J2dTraceLn(J2D_TRACE_ERROR, &quot;can&#39;t obtain temporary texture object from pool&quot;);
699             return JNI_FALSE;
700         }
701 
702 
703         glyphMode = MODE_NO_CACHE_LCD;
704     }
705     encoder = [mtlc.encoderManager getTextureEncoder:dstOps-&gt;pTexture isSrcOpaque:YES isDstOpaque:YES];
706     if (!MTLTR_EnableLCDGlyphModeState(encoder, mtlc, dstOps,contrast))
707     {
708         return JNI_FALSE;
709     }
710 
711     x0 = x;
712     tx1 = 0.0f;
713     ty1 = 0.0f;
714     dtx1 = 0.0f;
715     dty2 = 0.0f;
716     tw = MTLTR_NOCACHE_TILE_SIZE;
717     th = MTLTR_NOCACHE_TILE_SIZE;
718 
719     unsigned int imageBytes = w * h *4;
720     unsigned char imageData[imageBytes];
721     memset(&amp;imageData, 0, sizeof(imageData));
722 
723     for (int i = 0; i &lt; h; i++) {
724         for (int j = 0; j &lt; w; j++) {
725             imageData[(i * w * 4) + j * 4] = ginfo-&gt;image[(i * w * 3) + j * 3];
726             imageData[(i * w * 4) + j * 4 + 1] = ginfo-&gt;image[(i * w * 3) + j * 3 + 1];
727             imageData[(i * w * 4) + j * 4 + 2] = ginfo-&gt;image[(i * w * 3) + j * 3 + 2];
728             imageData[(i * w * 4) + j * 4 + 3] = 0xFF;
729         }
730     }
731 
732     // copy LCD mask into glyph texture tile
733     MTLRegion region = MTLRegionMake2D(0, 0, w, h);
734 
735     NSUInteger bytesPerRow = 4 * ginfo-&gt;width;
736     [blitTexture replaceRegion:region
737                  mipmapLevel:0
738                  withBytes:imageData
739                  bytesPerRow:bytesPerRow];
740 
741     J2dTraceLn7(J2D_TRACE_INFO, &quot;sx = %d sy = %d x = %d y = %d sw = %d sh = %d w = %d&quot;, sx, sy, x, y, sw, sh, w);
742 
743 
744     // update the lower-right glyph texture coordinates
745     tx2 = 1.0f;
746     ty2 = 1.0f;
747 
748     J2dTraceLn5(J2D_TRACE_INFO, &quot;xOffset %d yOffset %d, dxadj %d, dyadj %d dstOps-&gt;height %d&quot;, dstOps-&gt;xOffset, dstOps-&gt;yOffset, dxadj, dyadj, dstOps-&gt;height);
749 
750     dtx1 = ((jfloat)dxadj) / dstOps-&gt;textureWidth;
751     dtx2 = ((float)dxadj + sw) / dstOps-&gt;textureWidth;
752   
753     dty1 = ((jfloat)dyadj + sh) / dstOps-&gt;textureHeight;
754     dty2 = ((jfloat)dyadj) / dstOps-&gt;textureHeight;
755 
756     J2dTraceLn4(J2D_TRACE_INFO, &quot;tx1 %f, ty1 %f, tx2 %f, ty2 %f&quot;, tx1, ty1, tx2, ty2);
757     J2dTraceLn2(J2D_TRACE_INFO, &quot;textureWidth %d textureHeight %d&quot;, dstOps-&gt;textureWidth, dstOps-&gt;textureHeight);
758     J2dTraceLn4(J2D_TRACE_INFO, &quot;dtx1 %f, dty1 %f, dtx2 %f, dty2 %f&quot;, dtx1, dty1, dtx2, dty2);
759 
760     LCD_ADD_TRIANGLES(tx1, ty1, tx2, ty2, x, y, x+w, y+h);
761 
762     [encoder setVertexBytes:txtVertices length:sizeof(txtVertices) atIndex:MeshVertexBuffer];
763     [encoder setFragmentTexture:blitTexture atIndex:0];
764     [encoder setFragmentTexture:dstOps-&gt;pTexture atIndex:1];
765 
766     [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];
767 
768     vertexCacheIndex = 0;
769     [mtlc.encoderManager endEncoder];
770     [blitTexture release];
771 
772     MTLCommandBufferWrapper* cbwrapper = [mtlc pullCommandBufferWrapper];
773 
774     id&lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
775     [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
776         [cbwrapper release];
777     }];
778 
779     [commandbuf commit];
780     [commandbuf waitUntilCompleted];
781 
782     return JNI_TRUE;
783 }
784 
785 // see DrawGlyphList.c for more on this macro...
786 #define FLOOR_ASSIGN(l, r) \
787     if ((r)&lt;0) (l) = ((int)floor(r)); else (l) = ((int)(r))
788 
789 void
790 MTLTR_DrawGlyphList(JNIEnv *env, MTLContext *mtlc, BMTLSDOps *dstOps,
791                     jint totalGlyphs, jboolean usePositions,
792                     jboolean subPixPos, jboolean rgbOrder, jint lcdContrast,
793                     jfloat glyphListOrigX, jfloat glyphListOrigY,
794                     unsigned char *images, unsigned char *positions)
795 {
796     int glyphCounter;
797 
798     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList&quot;);
799 
800     RETURN_IF_NULL(mtlc);
801     RETURN_IF_NULL(dstOps);
802     RETURN_IF_NULL(images);
803     if (usePositions) {
804         RETURN_IF_NULL(positions);
805     }
806 
807     glyphMode = MODE_NOT_INITED;
808     isCachedDestValid = JNI_FALSE;
809     J2dTraceLn1(J2D_TRACE_INFO, &quot;totalGlyphs = %d&quot;, totalGlyphs);
810 
811     for (glyphCounter = 0; glyphCounter &lt; totalGlyphs; glyphCounter++) {
812         J2dTraceLn(J2D_TRACE_INFO, &quot;Entered for loop for glyph list&quot;);
813         jint x, y;
814         jfloat glyphx, glyphy;
815         jboolean grayscale, ok;
816         GlyphInfo *ginfo = (GlyphInfo *)jlong_to_ptr(NEXT_LONG(images));
817 
818         if (ginfo == NULL) {
819             // this shouldn&#39;t happen, but if it does we&#39;ll just break out...
820             J2dRlsTraceLn(J2D_TRACE_ERROR,
821                           &quot;MTLTR_DrawGlyphList: glyph info is null&quot;);
822             break;
823         }
824 
825         grayscale = (ginfo-&gt;rowBytes == ginfo-&gt;width);
826 
827         if (usePositions) {
828             jfloat posx = NEXT_FLOAT(positions);
829             jfloat posy = NEXT_FLOAT(positions);
830             glyphx = glyphListOrigX + posx + ginfo-&gt;topLeftX;
831             glyphy = glyphListOrigY + posy + ginfo-&gt;topLeftY;
832             FLOOR_ASSIGN(x, glyphx);
833             FLOOR_ASSIGN(y, glyphy);
834         } else {
835             glyphx = glyphListOrigX + ginfo-&gt;topLeftX;
836             glyphy = glyphListOrigY + ginfo-&gt;topLeftY;
837             FLOOR_ASSIGN(x, glyphx);
838             FLOOR_ASSIGN(y, glyphy);
839             glyphListOrigX += ginfo-&gt;advanceX;
840             glyphListOrigY += ginfo-&gt;advanceY;
841         }
842 
843         if (ginfo-&gt;image == NULL) {
844             J2dTraceLn(J2D_TRACE_INFO, &quot;Glyph image is null&quot;);
845             continue;
846         }
847 
848         J2dTraceLn2(J2D_TRACE_INFO, &quot;Glyph width = %d height = %d&quot;, ginfo-&gt;width, ginfo-&gt;height);
849         J2dTraceLn1(J2D_TRACE_INFO, &quot;rowBytes = %d&quot;, ginfo-&gt;rowBytes);
850         if (grayscale) {
851             // grayscale or monochrome glyph data
852             if (ginfo-&gt;width &lt;= MTLTR_CACHE_CELL_WIDTH &amp;&amp;
853                 ginfo-&gt;height &lt;= MTLTR_CACHE_CELL_HEIGHT)
854             {
855                 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList Grayscale cache&quot;);
856                 ok = MTLTR_DrawGrayscaleGlyphViaCache(mtlc, ginfo, x, y, dstOps);
857             } else {
858                 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList Grayscale no cache&quot;);
859                 ok = MTLTR_DrawGrayscaleGlyphNoCache(mtlc, ginfo, x, y, dstOps);
860             }
861         } else {
862             void* dstTexture = dstOps-&gt;textureLCD;
863 
864             // LCD-optimized glyph data
865             jint rowBytesOffset = 0;
866 
867             if (subPixPos) {
868                 jint frac = (jint)((glyphx - x) * 3);
869                 if (frac != 0) {
870                     rowBytesOffset = 3 - frac;
871                     x += 1;
872                 }
873             }
874 
875             if (rowBytesOffset == 0 &amp;&amp;
876                 ginfo-&gt;width &lt;= MTLTR_CACHE_CELL_WIDTH &amp;&amp;
877                 ginfo-&gt;height &lt;= MTLTR_CACHE_CELL_HEIGHT)
878             {
879                 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList LCD cache&quot;);
880                 ok = MTLTR_DrawLCDGlyphViaCache(mtlc, dstOps,
881                                                 ginfo, x, y,
882                                                 rowBytesOffset,
883                                                 rgbOrder, lcdContrast,
884                                                 dstTexture);
885             } else {
886                 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList LCD no cache&quot;);
887                 ok = MTLTR_DrawLCDGlyphNoCache(mtlc, dstOps,
888                                                ginfo, x, y,
889                                                rowBytesOffset,
890                                                rgbOrder, lcdContrast,
891                                                dstTexture);
892             }
893         }
894 
895         if (!ok) {
896             break;
897         }
898     }
899     /*
900      * Only in case of grayscale text drawing we need to flush
901      * cache. Still in case of LCD we are not using any intermediate
902      * cache.
903      */
904     if (glyphMode == MODE_NO_CACHE_GRAY) {
905         MTLVertexCache_DisableMaskCache(mtlc);
906     } else if (glyphMode == MODE_USE_CACHE_GRAY) {
907         MTLTR_DisableGlyphVertexCache(mtlc);
908     }
909 }
910 
911 JNIEXPORT void JNICALL
912 Java_sun_java2d_metal_MTLTextRenderer_drawGlyphList
913     (JNIEnv *env, jobject self,
914      jint numGlyphs, jboolean usePositions,
915      jboolean subPixPos, jboolean rgbOrder, jint lcdContrast,
916      jfloat glyphListOrigX, jfloat glyphListOrigY,
917      jlongArray imgArray, jfloatArray posArray)
918 {
919     unsigned char *images;
920 
921     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTextRenderer_drawGlyphList&quot;);
922 
923     images = (unsigned char *)
924         (*env)-&gt;GetPrimitiveArrayCritical(env, imgArray, NULL);
925     if (images != NULL) {
926         MTLContext *mtlc = MTLRenderQueue_GetCurrentContext();
927         BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
928 
929         if (usePositions) {
930             unsigned char *positions = (unsigned char *)
931                 (*env)-&gt;GetPrimitiveArrayCritical(env, posArray, NULL);
932             if (positions != NULL) {
933                 MTLTR_DrawGlyphList(env, mtlc, dstOps,
934                                     numGlyphs, usePositions,
935                                     subPixPos, rgbOrder, lcdContrast,
936                                     glyphListOrigX, glyphListOrigY,
937                                     images, positions);
938                 (*env)-&gt;ReleasePrimitiveArrayCritical(env, posArray,
939                                                       positions, JNI_ABORT);
940             }
941         } else {
942             MTLTR_DrawGlyphList(env, mtlc, dstOps,
943                                 numGlyphs, usePositions,
944                                 subPixPos, rgbOrder, lcdContrast,
945                                 glyphListOrigX, glyphListOrigY,
946                                 images, NULL);
947         }
948 
949         (*env)-&gt;ReleasePrimitiveArrayCritical(env, imgArray,
950                                               images, JNI_ABORT);
951     }
952 }
953 
954 #endif /* !HEADLESS */
    </pre>
  </body>
</html>
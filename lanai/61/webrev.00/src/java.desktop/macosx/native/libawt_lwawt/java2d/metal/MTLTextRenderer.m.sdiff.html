<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLTextRenderer.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLTextRenderer.m</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 150  * valid data.  This flag is reset to JNI_FALSE at the beginning of every
 151  * call to MTLTR_DrawGlyphList().  Once we copy valid destination data
 152  * into the cached texture, this flag is set to JNI_TRUE.  This way, we can
 153  * limit the number of times we need to copy destination data, which is a
 154  * very costly operation.
 155  */
 156 static jboolean isCachedDestValid = JNI_FALSE;
 157 
 158 /**
 159  * The bounds of the previously rendered LCD glyph, in destination
 160  * coordinate space.  We use these bounds to determine whether the glyph
 161  * currently being rendered overlaps the previously rendered glyph (i.e.
 162  * its bounding box intersects that of the previously rendered glyph).  If
 163  * so, we need to re-read the destination area associated with that previous
 164  * glyph so that we can correctly blend with the actual destination data.
 165  */
 166 static SurfaceDataBounds previousGlyphBounds;
 167 
 168 static struct TxtVertex txtVertices[6];
 169 static jint vertexCacheIndex = 0;

 170 
 171 #define LCD_ADD_VERTEX(TX, TY, DX, DY, DZ) \
 172     do { \
 173         struct TxtVertex *v = &amp;txtVertices[vertexCacheIndex++]; \
 174         v-&gt;txtpos[0] = TX; \
 175         v-&gt;txtpos[1] = TY; \
 176         v-&gt;position[0]= DX; \
 177         v-&gt;position[1] = DY; \
 178     } while (0)
 179 
 180 #define LCD_ADD_TRIANGLES(TX1, TY1, TX2, TY2, DX1, DY1, DX2, DY2) \
 181     do { \
 182         LCD_ADD_VERTEX(TX1, TY1, DX1, DY1, 0); \
 183         LCD_ADD_VERTEX(TX2, TY1, DX2, DY1, 0); \
 184         LCD_ADD_VERTEX(TX2, TY2, DX2, DY2, 0); \
 185         LCD_ADD_VERTEX(TX2, TY2, DX2, DY2, 0); \
 186         LCD_ADD_VERTEX(TX1, TY2, DX1, DY2, 0); \
 187         LCD_ADD_VERTEX(TX1, TY1, DX1, DY1, 0); \
 188     } while (0)
 189 
</pre>
<hr />
<pre>
 394     J2dTraceLn2(J2D_TRACE_INFO, &quot;gamma %f, invgamma %f&quot;, gamma, invgamma);
 395 
 396     clr[0] = ((col &gt;&gt; 16) &amp; 0xFF)/255.0f;
 397     clr[1] = ((col &gt;&gt; 8) &amp; 0xFF)/255.0f;
 398     clr[2] = ((col) &amp; 0xFF)/255.0f;
 399 
 400     // gamma adjust the primary color
 401     radj = (float)pow(clr[0], gamma);
 402     gadj = (float)pow(clr[1], gamma);
 403     badj = (float)pow(clr[2], gamma);
 404 
 405     struct LCDFrameUniforms uf = {
 406             {radj, gadj, badj},
 407             {gamma, gamma, gamma},
 408             {invgamma, invgamma, invgamma}};
 409     [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
 410 
 411     return JNI_TRUE;
 412 }
 413 




































































 414 void
 415 MTLTR_EnableGlyphVertexCache(MTLContext *mtlc, BMTLSDOps *dstOps)
 416 {
 417 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_EnableGlyphVertexCache&quot;);
 418 
 419     if (!MTLVertexCache_InitVertexCache()) {
 420         return;
 421     }
 422 
 423     if (glyphCacheAA == NULL) {
 424         if (!MTLTR_InitGlyphCache(mtlc, JNI_FALSE)) {
 425             return;
 426         }
 427     }
 428     MTLVertexCache_CreateSamplingEncoder(mtlc, dstOps);
 429 }
 430 
 431 void
 432 MTLTR_DisableGlyphVertexCache(MTLContext *mtlc)
 433 {
</pre>
<hr />
<pre>
 457         // changes needs to be made
 458         break;
 459     case MODE_NO_CACHE_GRAY:
 460     case MODE_USE_CACHE_GRAY:
 461     case MODE_NOT_INITED:
 462     default:
 463         break;
 464     }
 465 }
 466 
 467 static jboolean
 468 MTLTR_DrawGrayscaleGlyphViaCache(MTLContext *mtlc,
 469                                  GlyphInfo *ginfo, jint x, jint y, BMTLSDOps *dstOps)
 470 {
 471     MTLCacheCellInfo *cell;
 472     jfloat x1, y1, x2, y2;
 473 
 474     if (glyphMode != MODE_USE_CACHE_GRAY) {
 475         if (glyphMode == MODE_NO_CACHE_GRAY) {
 476             MTLVertexCache_DisableMaskCache(mtlc);



 477         }
 478         MTLTR_EnableGlyphVertexCache(mtlc, dstOps);
 479         glyphMode = MODE_USE_CACHE_GRAY;
 480     }
 481 
 482     if (ginfo-&gt;cellInfo == NULL) {
 483         // attempt to add glyph to accelerated glyph cache
 484         MTLTR_AddToGlyphCache(ginfo, mtlc, MTLPixelFormatA8Unorm);
 485 
 486         if (ginfo-&gt;cellInfo == NULL) {
 487             // we&#39;ll just no-op in the rare case that the cell is NULL
 488             return JNI_TRUE;
 489         }
 490     }
 491 
 492     cell = (MTLCacheCellInfo *) (ginfo-&gt;cellInfo);
 493     cell-&gt;timesRendered++;
 494 
 495     x1 = (jfloat)x;
 496     y1 = (jfloat)y;
</pre>
<hr />
<pre>
 531 static void
 532 MTLTR_UpdateCachedDestination(MTLSDOps *dstOps, GlyphInfo *ginfo,
 533                               jint gx1, jint gy1, jint gx2, jint gy2,
 534                               jint glyphIndex, jint totalGlyphs)
 535 {
 536     //TODO
 537 }
 538 
 539 static jboolean
 540 MTLTR_DrawLCDGlyphViaCache(MTLContext *mtlc, BMTLSDOps *dstOps,
 541                            GlyphInfo *ginfo, jint x, jint y,
 542                            jint rowBytesOffset,
 543                            jboolean rgbOrder, jint contrast,
 544                            id&lt;MTLTexture&gt; dstTexture)
 545 {
 546     CacheCellInfo *cell;
 547     jfloat tx1, ty1, tx2, ty2;
 548     jint w = ginfo-&gt;width;
 549     jint h = ginfo-&gt;height;
 550 
<span class="line-removed"> 551     id&lt;MTLRenderCommandEncoder&gt; encoder = nil;</span>
<span class="line-removed"> 552 </span>
 553     if (glyphMode != MODE_USE_CACHE_LCD) {
 554         if (glyphMode == MODE_NO_CACHE_GRAY) {
 555             MTLVertexCache_DisableMaskCache(mtlc);
 556         } else if (glyphMode == MODE_USE_CACHE_GRAY) {
 557             MTLTR_DisableGlyphVertexCache(mtlc);
 558         }
 559 
 560         if (glyphCacheLCD == NULL) {
 561             if (!MTLTR_InitGlyphCache(mtlc, JNI_TRUE)) {
 562                 return JNI_FALSE;
 563             }
 564         }
<span class="line-modified"> 565 </span>



 566         if (rgbOrder != lastRGBOrder) {
 567             // need to invalidate the cache in this case; see comments
 568             // for lastRGBOrder above
 569             MTLGlyphCache_Invalidate(glyphCacheLCD);
 570             lastRGBOrder = rgbOrder;
 571         }
 572 
 573         glyphMode = MODE_USE_CACHE_LCD;
 574     }
 575 
 576     if (ginfo-&gt;cellInfo == NULL) {
 577         // attempt to add glyph to accelerated glyph cache
 578         // TODO : Handle RGB order
 579         MTLTR_AddToGlyphCache(ginfo, mtlc, MTLPixelFormatRGBA8Unorm);
 580 
 581         if (ginfo-&gt;cellInfo == NULL) {
 582             // we&#39;ll just no-op in the rare case that the cell is NULL
 583             return JNI_TRUE;
 584         }
 585     }
 586     cell = (CacheCellInfo *) (ginfo-&gt;cellInfo);
 587     cell-&gt;timesRendered++;
<span class="line-removed"> 588     encoder = [mtlc.encoderManager getTextureEncoder:dstOps-&gt;pTexture isSrcOpaque:YES isDstOpaque:YES];</span>
<span class="line-removed"> 589     if (!MTLTR_EnableLCDGlyphModeState(encoder, mtlc, dstOps,contrast))</span>
<span class="line-removed"> 590     {</span>
<span class="line-removed"> 591         return JNI_FALSE;</span>
<span class="line-removed"> 592     }</span>
 593 

 594     tx1 = cell-&gt;tx1;
 595     ty1 = cell-&gt;ty1;
 596     tx2 = cell-&gt;tx2;
 597     ty2 = cell-&gt;ty2;
 598 
 599     J2dTraceLn4(J2D_TRACE_INFO, &quot;tx1 %f, ty1 %f, tx2 %f, ty2 %f&quot;, tx1, ty1, tx2, ty2);
 600     J2dTraceLn2(J2D_TRACE_INFO, &quot;textureWidth %d textureHeight %d&quot;, dstOps-&gt;textureWidth, dstOps-&gt;textureHeight);
 601 
 602     LCD_ADD_TRIANGLES(tx1, ty1, tx2, ty2, x, y, x+w, y+h);
 603 
<span class="line-modified"> 604     [encoder setVertexBytes:txtVertices length:sizeof(txtVertices) atIndex:MeshVertexBuffer];</span>
<span class="line-modified"> 605     [encoder setFragmentTexture:glyphCacheLCD-&gt;texture atIndex:0];</span>
<span class="line-modified"> 606     [encoder setFragmentTexture:dstOps-&gt;pTexture atIndex:1];</span>
 607 
<span class="line-modified"> 608     [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];</span>
 609 
 610     vertexCacheIndex = 0;
<span class="line-removed"> 611     [mtlc.encoderManager endEncoder];</span>
 612 
 613     return JNI_TRUE;
 614 }
 615 
 616 static jboolean
 617 MTLTR_DrawGrayscaleGlyphNoCache(MTLContext *mtlc,
 618                                 GlyphInfo *ginfo, jint x, jint y, BMTLSDOps *dstOps)
 619 {
 620     jint tw, th;
 621     jint sx, sy, sw, sh;
 622     jint x0;
 623     jint w = ginfo-&gt;width;
 624     jint h = ginfo-&gt;height;
 625 
 626     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGrayscaleGlyphNoCache&quot;);
 627     if (glyphMode != MODE_NO_CACHE_GRAY) {
 628         if (glyphMode == MODE_USE_CACHE_GRAY) {
 629             MTLTR_DisableGlyphVertexCache(mtlc);



 630         }
 631         MTLVertexCache_EnableMaskCache(mtlc, dstOps);
 632         glyphMode = MODE_NO_CACHE_GRAY;
 633     }
 634 
 635     x0 = x;
 636     tw = MTLVC_MASK_CACHE_TILE_WIDTH;
 637     th = MTLVC_MASK_CACHE_TILE_HEIGHT;
 638 
 639     for (sy = 0; sy &lt; h; sy += th, y += th) {
 640         x = x0;
 641         sh = ((sy + th) &gt; h) ? (h - sy) : th;
 642 
 643         for (sx = 0; sx &lt; w; sx += tw, x += tw) {
 644             sw = ((sx + tw) &gt; w) ? (w - sx) : tw;
 645 
 646             J2dTraceLn7(J2D_TRACE_INFO, &quot;sx = %d sy = %d x = %d y = %d sw = %d sh = %d w = %d&quot;, sx, sy, x, y, sw, sh, w);
 647             MTLVertexCache_AddMaskQuad(mtlc,
 648                                        sx, sy, x, y, sw, sh,
 649                                        w, ginfo-&gt;image,
</pre>
<hr />
<pre>
 675     J2dTraceLn2(J2D_TRACE_INFO, &quot;MTLTR_DrawLCDGlyphNoCache x %d, y%d&quot;, x, y);
 676     J2dTraceLn3(J2D_TRACE_INFO, &quot;MTLTR_DrawLCDGlyphNoCache rowBytesOffset=%d, rgbOrder=%d, contrast=%d&quot;, rowBytesOffset, rgbOrder, contrast);
 677 
 678 
 679     id&lt;MTLRenderCommandEncoder&gt; encoder = nil;
 680 
 681     MTLTextureDescriptor *textureDescriptor =
 682         [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatBGRA8Unorm
 683                                                             width:w
 684                                                             height:h
 685                                                             mipmapped:NO];
 686 
 687     blitTexture = [mtlc.device newTextureWithDescriptor:textureDescriptor];
 688     [textureDescriptor release];
 689 
 690     if (glyphMode != MODE_NO_CACHE_LCD) {
 691         if (glyphMode == MODE_NO_CACHE_GRAY) {
 692             MTLVertexCache_DisableMaskCache(mtlc);
 693         } else if (glyphMode == MODE_USE_CACHE_GRAY) {
 694             MTLTR_DisableGlyphVertexCache(mtlc);



 695         }
 696 
 697         if (blitTexture == nil) {
 698             J2dTraceLn(J2D_TRACE_ERROR, &quot;can&#39;t obtain temporary texture object from pool&quot;);
 699             return JNI_FALSE;
 700         }
 701 
 702 
 703         glyphMode = MODE_NO_CACHE_LCD;
 704     }
 705     encoder = [mtlc.encoderManager getTextureEncoder:dstOps-&gt;pTexture isSrcOpaque:YES isDstOpaque:YES];
 706     if (!MTLTR_EnableLCDGlyphModeState(encoder, mtlc, dstOps,contrast))
 707     {
 708         return JNI_FALSE;
 709     }
 710 
 711     x0 = x;
 712     tx1 = 0.0f;
 713     ty1 = 0.0f;
 714     dtx1 = 0.0f;
</pre>
<hr />
<pre>
 888                                                ginfo, x, y,
 889                                                rowBytesOffset,
 890                                                rgbOrder, lcdContrast,
 891                                                dstTexture);
 892             }
 893         }
 894 
 895         if (!ok) {
 896             break;
 897         }
 898     }
 899     /*
 900      * Only in case of grayscale text drawing we need to flush
 901      * cache. Still in case of LCD we are not using any intermediate
 902      * cache.
 903      */
 904     if (glyphMode == MODE_NO_CACHE_GRAY) {
 905         MTLVertexCache_DisableMaskCache(mtlc);
 906     } else if (glyphMode == MODE_USE_CACHE_GRAY) {
 907         MTLTR_DisableGlyphVertexCache(mtlc);



 908     }
 909 }
 910 
 911 JNIEXPORT void JNICALL
 912 Java_sun_java2d_metal_MTLTextRenderer_drawGlyphList
 913     (JNIEnv *env, jobject self,
 914      jint numGlyphs, jboolean usePositions,
 915      jboolean subPixPos, jboolean rgbOrder, jint lcdContrast,
 916      jfloat glyphListOrigX, jfloat glyphListOrigY,
 917      jlongArray imgArray, jfloatArray posArray)
 918 {
 919     unsigned char *images;
 920 
 921     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTextRenderer_drawGlyphList&quot;);
 922 
 923     images = (unsigned char *)
 924         (*env)-&gt;GetPrimitiveArrayCritical(env, imgArray, NULL);
 925     if (images != NULL) {
 926         MTLContext *mtlc = MTLRenderQueue_GetCurrentContext();
 927         BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
</pre>
</td>
<td>
<hr />
<pre>
 150  * valid data.  This flag is reset to JNI_FALSE at the beginning of every
 151  * call to MTLTR_DrawGlyphList().  Once we copy valid destination data
 152  * into the cached texture, this flag is set to JNI_TRUE.  This way, we can
 153  * limit the number of times we need to copy destination data, which is a
 154  * very costly operation.
 155  */
 156 static jboolean isCachedDestValid = JNI_FALSE;
 157 
 158 /**
 159  * The bounds of the previously rendered LCD glyph, in destination
 160  * coordinate space.  We use these bounds to determine whether the glyph
 161  * currently being rendered overlaps the previously rendered glyph (i.e.
 162  * its bounding box intersects that of the previously rendered glyph).  If
 163  * so, we need to re-read the destination area associated with that previous
 164  * glyph so that we can correctly blend with the actual destination data.
 165  */
 166 static SurfaceDataBounds previousGlyphBounds;
 167 
 168 static struct TxtVertex txtVertices[6];
 169 static jint vertexCacheIndex = 0;
<span class="line-added"> 170 static id&lt;MTLRenderCommandEncoder&gt; lcdCacheEncoder = nil;</span>
 171 
 172 #define LCD_ADD_VERTEX(TX, TY, DX, DY, DZ) \
 173     do { \
 174         struct TxtVertex *v = &amp;txtVertices[vertexCacheIndex++]; \
 175         v-&gt;txtpos[0] = TX; \
 176         v-&gt;txtpos[1] = TY; \
 177         v-&gt;position[0]= DX; \
 178         v-&gt;position[1] = DY; \
 179     } while (0)
 180 
 181 #define LCD_ADD_TRIANGLES(TX1, TY1, TX2, TY2, DX1, DY1, DX2, DY2) \
 182     do { \
 183         LCD_ADD_VERTEX(TX1, TY1, DX1, DY1, 0); \
 184         LCD_ADD_VERTEX(TX2, TY1, DX2, DY1, 0); \
 185         LCD_ADD_VERTEX(TX2, TY2, DX2, DY2, 0); \
 186         LCD_ADD_VERTEX(TX2, TY2, DX2, DY2, 0); \
 187         LCD_ADD_VERTEX(TX1, TY2, DX1, DY2, 0); \
 188         LCD_ADD_VERTEX(TX1, TY1, DX1, DY1, 0); \
 189     } while (0)
 190 
</pre>
<hr />
<pre>
 395     J2dTraceLn2(J2D_TRACE_INFO, &quot;gamma %f, invgamma %f&quot;, gamma, invgamma);
 396 
 397     clr[0] = ((col &gt;&gt; 16) &amp; 0xFF)/255.0f;
 398     clr[1] = ((col &gt;&gt; 8) &amp; 0xFF)/255.0f;
 399     clr[2] = ((col) &amp; 0xFF)/255.0f;
 400 
 401     // gamma adjust the primary color
 402     radj = (float)pow(clr[0], gamma);
 403     gadj = (float)pow(clr[1], gamma);
 404     badj = (float)pow(clr[2], gamma);
 405 
 406     struct LCDFrameUniforms uf = {
 407             {radj, gadj, badj},
 408             {gamma, gamma, gamma},
 409             {invgamma, invgamma, invgamma}};
 410     [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
 411 
 412     return JNI_TRUE;
 413 }
 414 
<span class="line-added"> 415 static jboolean</span>
<span class="line-added"> 416 MTLTR_SetLCDCachePipelineState(MTLContext *mtlc)</span>
<span class="line-added"> 417 {</span>
<span class="line-added"> 418     if (templateLCDPipelineDesc == nil) {</span>
<span class="line-added"> 419 </span>
<span class="line-added"> 420         MTLVertexDescriptor *vertDesc = [[MTLVertexDescriptor new] autorelease];</span>
<span class="line-added"> 421         vertDesc.attributes[VertexAttributePosition].format = MTLVertexFormatFloat2;</span>
<span class="line-added"> 422         vertDesc.attributes[VertexAttributePosition].offset = 0;</span>
<span class="line-added"> 423         vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;</span>
<span class="line-added"> 424         vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct Vertex);</span>
<span class="line-added"> 425         vertDesc.layouts[MeshVertexBuffer].stepRate = 1;</span>
<span class="line-added"> 426         vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;</span>
<span class="line-added"> 427 </span>
<span class="line-added"> 428         templateLCDPipelineDesc = [[MTLRenderPipelineDescriptor new] autorelease];</span>
<span class="line-added"> 429         templateLCDPipelineDesc.sampleCount = 1;</span>
<span class="line-added"> 430         templateLCDPipelineDesc.vertexDescriptor = vertDesc;</span>
<span class="line-added"> 431         templateLCDPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;</span>
<span class="line-added"> 432         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].format = MTLVertexFormatFloat2;</span>
<span class="line-added"> 433         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].offset = 2*sizeof(float);</span>
<span class="line-added"> 434         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].bufferIndex = MeshVertexBuffer;</span>
<span class="line-added"> 435         templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stride = sizeof(struct TxtVertex);</span>
<span class="line-added"> 436         templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepRate = 1;</span>
<span class="line-added"> 437         templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;</span>
<span class="line-added"> 438         templateLCDPipelineDesc.label = @&quot;template_lcd&quot;;</span>
<span class="line-added"> 439     }</span>
<span class="line-added"> 440 </span>
<span class="line-added"> 441     id&lt;MTLRenderPipelineState&gt; pipelineState =</span>
<span class="line-added"> 442                 [mtlc.pipelineStateStorage</span>
<span class="line-added"> 443                     getPipelineState:templateLCDPipelineDesc</span>
<span class="line-added"> 444                     vertexShaderId:@&quot;vert_txt&quot;</span>
<span class="line-added"> 445                     fragmentShaderId:@&quot;lcd_color&quot;</span>
<span class="line-added"> 446                    ];</span>
<span class="line-added"> 447 </span>
<span class="line-added"> 448     [lcdCacheEncoder setRenderPipelineState:pipelineState];</span>
<span class="line-added"> 449     return JNI_TRUE;</span>
<span class="line-added"> 450 }</span>
<span class="line-added"> 451 </span>
<span class="line-added"> 452 static jboolean</span>
<span class="line-added"> 453 MTLTR_SetLCDContrast(MTLContext *mtlc,</span>
<span class="line-added"> 454                      jint contrast)</span>
<span class="line-added"> 455 {</span>
<span class="line-added"> 456     // update the current color settings</span>
<span class="line-added"> 457     double gamma = ((double)contrast) / 100.0;</span>
<span class="line-added"> 458     double invgamma = 1.0/gamma;</span>
<span class="line-added"> 459     jfloat radj, gadj, badj;</span>
<span class="line-added"> 460     jfloat clr[4];</span>
<span class="line-added"> 461     jint col = [mtlc.paint getColor];</span>
<span class="line-added"> 462 </span>
<span class="line-added"> 463     J2dTraceLn2(J2D_TRACE_INFO, &quot;primary color %x, contrast %d&quot;, col, contrast);</span>
<span class="line-added"> 464     J2dTraceLn2(J2D_TRACE_INFO, &quot;gamma %f, invgamma %f&quot;, gamma, invgamma);</span>
<span class="line-added"> 465 </span>
<span class="line-added"> 466     clr[0] = ((col &gt;&gt; 16) &amp; 0xFF)/255.0f;</span>
<span class="line-added"> 467     clr[1] = ((col &gt;&gt; 8) &amp; 0xFF)/255.0f;</span>
<span class="line-added"> 468     clr[2] = ((col) &amp; 0xFF)/255.0f;</span>
<span class="line-added"> 469 </span>
<span class="line-added"> 470     // gamma adjust the primary color</span>
<span class="line-added"> 471     radj = (float)pow(clr[0], gamma);</span>
<span class="line-added"> 472     gadj = (float)pow(clr[1], gamma);</span>
<span class="line-added"> 473     badj = (float)pow(clr[2], gamma);</span>
<span class="line-added"> 474 </span>
<span class="line-added"> 475     struct LCDFrameUniforms uf = {</span>
<span class="line-added"> 476             {radj, gadj, badj},</span>
<span class="line-added"> 477             {gamma, gamma, gamma},</span>
<span class="line-added"> 478             {invgamma, invgamma, invgamma}};</span>
<span class="line-added"> 479     [lcdCacheEncoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];</span>
<span class="line-added"> 480     return JNI_TRUE;</span>
<span class="line-added"> 481 }</span>
<span class="line-added"> 482 </span>
 483 void
 484 MTLTR_EnableGlyphVertexCache(MTLContext *mtlc, BMTLSDOps *dstOps)
 485 {
 486 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_EnableGlyphVertexCache&quot;);
 487 
 488     if (!MTLVertexCache_InitVertexCache()) {
 489         return;
 490     }
 491 
 492     if (glyphCacheAA == NULL) {
 493         if (!MTLTR_InitGlyphCache(mtlc, JNI_FALSE)) {
 494             return;
 495         }
 496     }
 497     MTLVertexCache_CreateSamplingEncoder(mtlc, dstOps);
 498 }
 499 
 500 void
 501 MTLTR_DisableGlyphVertexCache(MTLContext *mtlc)
 502 {
</pre>
<hr />
<pre>
 526         // changes needs to be made
 527         break;
 528     case MODE_NO_CACHE_GRAY:
 529     case MODE_USE_CACHE_GRAY:
 530     case MODE_NOT_INITED:
 531     default:
 532         break;
 533     }
 534 }
 535 
 536 static jboolean
 537 MTLTR_DrawGrayscaleGlyphViaCache(MTLContext *mtlc,
 538                                  GlyphInfo *ginfo, jint x, jint y, BMTLSDOps *dstOps)
 539 {
 540     MTLCacheCellInfo *cell;
 541     jfloat x1, y1, x2, y2;
 542 
 543     if (glyphMode != MODE_USE_CACHE_GRAY) {
 544         if (glyphMode == MODE_NO_CACHE_GRAY) {
 545             MTLVertexCache_DisableMaskCache(mtlc);
<span class="line-added"> 546         } else if (glyphMode == MODE_USE_CACHE_LCD) {</span>
<span class="line-added"> 547             [mtlc.encoderManager endEncoder];</span>
<span class="line-added"> 548             lcdCacheEncoder = nil;</span>
 549         }
 550         MTLTR_EnableGlyphVertexCache(mtlc, dstOps);
 551         glyphMode = MODE_USE_CACHE_GRAY;
 552     }
 553 
 554     if (ginfo-&gt;cellInfo == NULL) {
 555         // attempt to add glyph to accelerated glyph cache
 556         MTLTR_AddToGlyphCache(ginfo, mtlc, MTLPixelFormatA8Unorm);
 557 
 558         if (ginfo-&gt;cellInfo == NULL) {
 559             // we&#39;ll just no-op in the rare case that the cell is NULL
 560             return JNI_TRUE;
 561         }
 562     }
 563 
 564     cell = (MTLCacheCellInfo *) (ginfo-&gt;cellInfo);
 565     cell-&gt;timesRendered++;
 566 
 567     x1 = (jfloat)x;
 568     y1 = (jfloat)y;
</pre>
<hr />
<pre>
 603 static void
 604 MTLTR_UpdateCachedDestination(MTLSDOps *dstOps, GlyphInfo *ginfo,
 605                               jint gx1, jint gy1, jint gx2, jint gy2,
 606                               jint glyphIndex, jint totalGlyphs)
 607 {
 608     //TODO
 609 }
 610 
 611 static jboolean
 612 MTLTR_DrawLCDGlyphViaCache(MTLContext *mtlc, BMTLSDOps *dstOps,
 613                            GlyphInfo *ginfo, jint x, jint y,
 614                            jint rowBytesOffset,
 615                            jboolean rgbOrder, jint contrast,
 616                            id&lt;MTLTexture&gt; dstTexture)
 617 {
 618     CacheCellInfo *cell;
 619     jfloat tx1, ty1, tx2, ty2;
 620     jint w = ginfo-&gt;width;
 621     jint h = ginfo-&gt;height;
 622 


 623     if (glyphMode != MODE_USE_CACHE_LCD) {
 624         if (glyphMode == MODE_NO_CACHE_GRAY) {
 625             MTLVertexCache_DisableMaskCache(mtlc);
 626         } else if (glyphMode == MODE_USE_CACHE_GRAY) {
 627             MTLTR_DisableGlyphVertexCache(mtlc);
 628         }
 629 
 630         if (glyphCacheLCD == NULL) {
 631             if (!MTLTR_InitGlyphCache(mtlc, JNI_TRUE)) {
 632                 return JNI_FALSE;
 633             }
 634         }
<span class="line-modified"> 635         if (lcdCacheEncoder == nil) {</span>
<span class="line-added"> 636             lcdCacheEncoder = [mtlc.encoderManager getTextureEncoder:dstOps-&gt;pTexture isSrcOpaque:YES isDstOpaque:YES];</span>
<span class="line-added"> 637             MTLTR_SetLCDCachePipelineState(mtlc);</span>
<span class="line-added"> 638         }</span>
 639         if (rgbOrder != lastRGBOrder) {
 640             // need to invalidate the cache in this case; see comments
 641             // for lastRGBOrder above
 642             MTLGlyphCache_Invalidate(glyphCacheLCD);
 643             lastRGBOrder = rgbOrder;
 644         }
 645 
 646         glyphMode = MODE_USE_CACHE_LCD;
 647     }
 648 
 649     if (ginfo-&gt;cellInfo == NULL) {
 650         // attempt to add glyph to accelerated glyph cache
 651         // TODO : Handle RGB order
 652         MTLTR_AddToGlyphCache(ginfo, mtlc, MTLPixelFormatRGBA8Unorm);
 653 
 654         if (ginfo-&gt;cellInfo == NULL) {
 655             // we&#39;ll just no-op in the rare case that the cell is NULL
 656             return JNI_TRUE;
 657         }
 658     }
 659     cell = (CacheCellInfo *) (ginfo-&gt;cellInfo);
 660     cell-&gt;timesRendered++;





 661 
<span class="line-added"> 662     MTLTR_SetLCDContrast(mtlc, contrast);</span>
 663     tx1 = cell-&gt;tx1;
 664     ty1 = cell-&gt;ty1;
 665     tx2 = cell-&gt;tx2;
 666     ty2 = cell-&gt;ty2;
 667 
 668     J2dTraceLn4(J2D_TRACE_INFO, &quot;tx1 %f, ty1 %f, tx2 %f, ty2 %f&quot;, tx1, ty1, tx2, ty2);
 669     J2dTraceLn2(J2D_TRACE_INFO, &quot;textureWidth %d textureHeight %d&quot;, dstOps-&gt;textureWidth, dstOps-&gt;textureHeight);
 670 
 671     LCD_ADD_TRIANGLES(tx1, ty1, tx2, ty2, x, y, x+w, y+h);
 672 
<span class="line-modified"> 673     [lcdCacheEncoder setVertexBytes:txtVertices length:sizeof(txtVertices) atIndex:MeshVertexBuffer];</span>
<span class="line-modified"> 674     [lcdCacheEncoder setFragmentTexture:glyphCacheLCD-&gt;texture atIndex:0];</span>
<span class="line-modified"> 675     [lcdCacheEncoder setFragmentTexture:dstOps-&gt;pTexture atIndex:1];</span>
 676 
<span class="line-modified"> 677     [lcdCacheEncoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];</span>
 678 
 679     vertexCacheIndex = 0;

 680 
 681     return JNI_TRUE;
 682 }
 683 
 684 static jboolean
 685 MTLTR_DrawGrayscaleGlyphNoCache(MTLContext *mtlc,
 686                                 GlyphInfo *ginfo, jint x, jint y, BMTLSDOps *dstOps)
 687 {
 688     jint tw, th;
 689     jint sx, sy, sw, sh;
 690     jint x0;
 691     jint w = ginfo-&gt;width;
 692     jint h = ginfo-&gt;height;
 693 
 694     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGrayscaleGlyphNoCache&quot;);
 695     if (glyphMode != MODE_NO_CACHE_GRAY) {
 696         if (glyphMode == MODE_USE_CACHE_GRAY) {
 697             MTLTR_DisableGlyphVertexCache(mtlc);
<span class="line-added"> 698         } else if (glyphMode == MODE_USE_CACHE_LCD) {</span>
<span class="line-added"> 699             [mtlc.encoderManager endEncoder];</span>
<span class="line-added"> 700             lcdCacheEncoder = nil;</span>
 701         }
 702         MTLVertexCache_EnableMaskCache(mtlc, dstOps);
 703         glyphMode = MODE_NO_CACHE_GRAY;
 704     }
 705 
 706     x0 = x;
 707     tw = MTLVC_MASK_CACHE_TILE_WIDTH;
 708     th = MTLVC_MASK_CACHE_TILE_HEIGHT;
 709 
 710     for (sy = 0; sy &lt; h; sy += th, y += th) {
 711         x = x0;
 712         sh = ((sy + th) &gt; h) ? (h - sy) : th;
 713 
 714         for (sx = 0; sx &lt; w; sx += tw, x += tw) {
 715             sw = ((sx + tw) &gt; w) ? (w - sx) : tw;
 716 
 717             J2dTraceLn7(J2D_TRACE_INFO, &quot;sx = %d sy = %d x = %d y = %d sw = %d sh = %d w = %d&quot;, sx, sy, x, y, sw, sh, w);
 718             MTLVertexCache_AddMaskQuad(mtlc,
 719                                        sx, sy, x, y, sw, sh,
 720                                        w, ginfo-&gt;image,
</pre>
<hr />
<pre>
 746     J2dTraceLn2(J2D_TRACE_INFO, &quot;MTLTR_DrawLCDGlyphNoCache x %d, y%d&quot;, x, y);
 747     J2dTraceLn3(J2D_TRACE_INFO, &quot;MTLTR_DrawLCDGlyphNoCache rowBytesOffset=%d, rgbOrder=%d, contrast=%d&quot;, rowBytesOffset, rgbOrder, contrast);
 748 
 749 
 750     id&lt;MTLRenderCommandEncoder&gt; encoder = nil;
 751 
 752     MTLTextureDescriptor *textureDescriptor =
 753         [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatBGRA8Unorm
 754                                                             width:w
 755                                                             height:h
 756                                                             mipmapped:NO];
 757 
 758     blitTexture = [mtlc.device newTextureWithDescriptor:textureDescriptor];
 759     [textureDescriptor release];
 760 
 761     if (glyphMode != MODE_NO_CACHE_LCD) {
 762         if (glyphMode == MODE_NO_CACHE_GRAY) {
 763             MTLVertexCache_DisableMaskCache(mtlc);
 764         } else if (glyphMode == MODE_USE_CACHE_GRAY) {
 765             MTLTR_DisableGlyphVertexCache(mtlc);
<span class="line-added"> 766         } else if (glyphMode == MODE_USE_CACHE_LCD) {</span>
<span class="line-added"> 767             [mtlc.encoderManager endEncoder];</span>
<span class="line-added"> 768             lcdCacheEncoder = nil;</span>
 769         }
 770 
 771         if (blitTexture == nil) {
 772             J2dTraceLn(J2D_TRACE_ERROR, &quot;can&#39;t obtain temporary texture object from pool&quot;);
 773             return JNI_FALSE;
 774         }
 775 
 776 
 777         glyphMode = MODE_NO_CACHE_LCD;
 778     }
 779     encoder = [mtlc.encoderManager getTextureEncoder:dstOps-&gt;pTexture isSrcOpaque:YES isDstOpaque:YES];
 780     if (!MTLTR_EnableLCDGlyphModeState(encoder, mtlc, dstOps,contrast))
 781     {
 782         return JNI_FALSE;
 783     }
 784 
 785     x0 = x;
 786     tx1 = 0.0f;
 787     ty1 = 0.0f;
 788     dtx1 = 0.0f;
</pre>
<hr />
<pre>
 962                                                ginfo, x, y,
 963                                                rowBytesOffset,
 964                                                rgbOrder, lcdContrast,
 965                                                dstTexture);
 966             }
 967         }
 968 
 969         if (!ok) {
 970             break;
 971         }
 972     }
 973     /*
 974      * Only in case of grayscale text drawing we need to flush
 975      * cache. Still in case of LCD we are not using any intermediate
 976      * cache.
 977      */
 978     if (glyphMode == MODE_NO_CACHE_GRAY) {
 979         MTLVertexCache_DisableMaskCache(mtlc);
 980     } else if (glyphMode == MODE_USE_CACHE_GRAY) {
 981         MTLTR_DisableGlyphVertexCache(mtlc);
<span class="line-added"> 982     } else if (glyphMode == MODE_USE_CACHE_LCD) {</span>
<span class="line-added"> 983         [mtlc.encoderManager endEncoder];</span>
<span class="line-added"> 984         lcdCacheEncoder = nil;</span>
 985     }
 986 }
 987 
 988 JNIEXPORT void JNICALL
 989 Java_sun_java2d_metal_MTLTextRenderer_drawGlyphList
 990     (JNIEnv *env, jobject self,
 991      jint numGlyphs, jboolean usePositions,
 992      jboolean subPixPos, jboolean rgbOrder, jint lcdContrast,
 993      jfloat glyphListOrigX, jfloat glyphListOrigY,
 994      jlongArray imgArray, jfloatArray posArray)
 995 {
 996     unsigned char *images;
 997 
 998     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTextRenderer_drawGlyphList&quot;);
 999 
1000     images = (unsigned char *)
1001         (*env)-&gt;GetPrimitiveArrayCritical(env, imgArray, NULL);
1002     if (images != NULL) {
1003         MTLContext *mtlc = MTLRenderQueue_GetCurrentContext();
1004         BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLTextRenderer.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #ifndef HEADLESS
  27 
  28 #include &lt;stdlib.h&gt;
  29 #include &lt;limits.h&gt;
  30 #include &lt;math.h&gt;
  31 #include &lt;jlong.h&gt;
  32 
  33 #include &quot;sun_java2d_metal_MTLTextRenderer.h&quot;
  34 
  35 #include &quot;SurfaceData.h&quot;
  36 #include &quot;MTLContext.h&quot;
  37 #include &quot;MTLRenderQueue.h&quot;
  38 #include &quot;MTLTextRenderer.h&quot;
  39 #include &quot;MTLVertexCache.h&quot;
  40 #include &quot;MTLGlyphCache.h&quot;
  41 #include &quot;MTLBlitLoops.h&quot;
  42 
  43 /**
  44  * The following constants define the inner and outer bounds of the
  45  * accelerated glyph cache.
  46  */
  47 #define MTLTR_CACHE_WIDTH       512
  48 #define MTLTR_CACHE_HEIGHT      512
  49 #define MTLTR_CACHE_CELL_WIDTH  32
  50 #define MTLTR_CACHE_CELL_HEIGHT 32
  51 
  52 /**
  53  * The current &quot;glyph mode&quot; state.  This variable is used to track the
  54  * codepath used to render a particular glyph.  This variable is reset to
  55  * MODE_NOT_INITED at the beginning of every call to MTLTR_DrawGlyphList().
  56  * As each glyph is rendered, the glyphMode variable is updated to reflect
  57  * the current mode, so if the current mode is the same as the mode used
  58  * to render the previous glyph, we can avoid doing costly setup operations
  59  * each time.
  60  */
  61 typedef enum {
  62     MODE_NOT_INITED,
  63     MODE_USE_CACHE_GRAY,
  64     MODE_USE_CACHE_LCD,
  65     MODE_NO_CACHE_GRAY,
  66     MODE_NO_CACHE_LCD,
  67     MODE_NO_CACHE_COLOR
  68 } GlyphMode;
  69 static GlyphMode glyphMode = MODE_NOT_INITED;
  70 
  71 /**
  72  * There are two separate glyph caches: for AA and for LCD.
  73  * Once one of them is initialized as either GRAY or LCD, it
  74  * stays in that mode for the duration of the application.  It should
  75  * be safe to use this one glyph cache for all screens in a multimon
  76  * environment, since the glyph cache texture is shared between all contexts,
  77  * and (in theory) OpenGL drivers should be smart enough to manage that
  78  * texture across all screens.
  79  */
  80 
  81 static MTLGlyphCacheInfo *glyphCacheLCD = NULL;
  82 static MTLGlyphCacheInfo *glyphCacheAA = NULL;
  83 
  84 /**
  85  * The handle to the LCD text fragment program object.
  86  */
  87 static GLhandleARB lcdTextProgram = 0;
  88 
  89 /**
  90  * This value tracks the previous LCD contrast setting, so if the contrast
  91  * value hasn&#39;t changed since the last time the gamma uniforms were
  92  * updated (not very common), then we can skip updating the unforms.
  93  */
  94 static jint lastLCDContrast = -1;
  95 
  96 /**
  97  * This value tracks the previous LCD rgbOrder setting, so if the rgbOrder
  98  * value has changed since the last time, it indicates that we need to
  99  * invalidate the cache, which may already store glyph images in the reverse
 100  * order.  Note that in most real world applications this value will not
 101  * change over the course of the application, but tests like Font2DTest
 102  * allow for changing the ordering at runtime, so we need to handle that case.
 103  */
 104 static jboolean lastRGBOrder = JNI_TRUE;
 105 
 106 /**
 107  * This constant defines the size of the tile to use in the
 108  * MTLTR_DrawLCDGlyphNoCache() method.  See below for more on why we
 109  * restrict this value to a particular size.
 110  */
 111 #define MTLTR_NOCACHE_TILE_SIZE 32
 112 
 113 /**
 114  * These constants define the size of the &quot;cached destination&quot; texture.
 115  * This texture is only used when rendering LCD-optimized text, as that
 116  * codepath needs direct access to the destination.  There is no way to
 117  * access the framebuffer directly from an OpenGL shader, so we need to first
 118  * copy the destination region corresponding to a particular glyph into
 119  * this cached texture, and then that texture will be accessed inside the
 120  * shader.  Copying the destination into this cached texture can be a very
 121  * expensive operation (accounting for about half the rendering time for
 122  * LCD text), so to mitigate this cost we try to bulk read a horizontal
 123  * region of the destination at a time.  (These values are empirically
 124  * derived for the common case where text runs horizontally.)
 125  *
 126  * Note: It is assumed in various calculations below that:
 127  *     (MTLTR_CACHED_DEST_WIDTH  &gt;= MTLTR_CACHE_CELL_WIDTH)  &amp;&amp;
 128  *     (MTLTR_CACHED_DEST_WIDTH  &gt;= MTLTR_NOCACHE_TILE_SIZE) &amp;&amp;
 129  *     (MTLTR_CACHED_DEST_HEIGHT &gt;= MTLTR_CACHE_CELL_HEIGHT) &amp;&amp;
 130  *     (MTLTR_CACHED_DEST_HEIGHT &gt;= MTLTR_NOCACHE_TILE_SIZE)
 131  */
 132 #define MTLTR_CACHED_DEST_WIDTH  512
 133 #define MTLTR_CACHED_DEST_HEIGHT (MTLTR_CACHE_CELL_HEIGHT * 2)
 134 
 135 /**
 136  * The handle to the &quot;cached destination&quot; texture object.
 137  */
 138 static GLuint cachedDestTextureID = 0;
 139 
 140 /**
 141  * The current bounds of the &quot;cached destination&quot; texture, in destination
 142  * coordinate space.  The width/height of these bounds will not exceed the
 143  * MTLTR_CACHED_DEST_WIDTH/HEIGHT values defined above.  These bounds are
 144  * only considered valid when the isCachedDestValid flag is JNI_TRUE.
 145  */
 146 static SurfaceDataBounds cachedDestBounds;
 147 
 148 /**
 149  * This flag indicates whether the &quot;cached destination&quot; texture contains
 150  * valid data.  This flag is reset to JNI_FALSE at the beginning of every
 151  * call to MTLTR_DrawGlyphList().  Once we copy valid destination data
 152  * into the cached texture, this flag is set to JNI_TRUE.  This way, we can
 153  * limit the number of times we need to copy destination data, which is a
 154  * very costly operation.
 155  */
 156 static jboolean isCachedDestValid = JNI_FALSE;
 157 
 158 /**
 159  * The bounds of the previously rendered LCD glyph, in destination
 160  * coordinate space.  We use these bounds to determine whether the glyph
 161  * currently being rendered overlaps the previously rendered glyph (i.e.
 162  * its bounding box intersects that of the previously rendered glyph).  If
 163  * so, we need to re-read the destination area associated with that previous
 164  * glyph so that we can correctly blend with the actual destination data.
 165  */
 166 static SurfaceDataBounds previousGlyphBounds;
 167 
 168 static struct TxtVertex txtVertices[6];
 169 static jint vertexCacheIndex = 0;
<a name="1" id="anc1"></a><span class="line-added"> 170 static id&lt;MTLRenderCommandEncoder&gt; lcdCacheEncoder = nil;</span>
 171 
 172 #define LCD_ADD_VERTEX(TX, TY, DX, DY, DZ) \
 173     do { \
 174         struct TxtVertex *v = &amp;txtVertices[vertexCacheIndex++]; \
 175         v-&gt;txtpos[0] = TX; \
 176         v-&gt;txtpos[1] = TY; \
 177         v-&gt;position[0]= DX; \
 178         v-&gt;position[1] = DY; \
 179     } while (0)
 180 
 181 #define LCD_ADD_TRIANGLES(TX1, TY1, TX2, TY2, DX1, DY1, DX2, DY2) \
 182     do { \
 183         LCD_ADD_VERTEX(TX1, TY1, DX1, DY1, 0); \
 184         LCD_ADD_VERTEX(TX2, TY1, DX2, DY1, 0); \
 185         LCD_ADD_VERTEX(TX2, TY2, DX2, DY2, 0); \
 186         LCD_ADD_VERTEX(TX2, TY2, DX2, DY2, 0); \
 187         LCD_ADD_VERTEX(TX1, TY2, DX1, DY2, 0); \
 188         LCD_ADD_VERTEX(TX1, TY1, DX1, DY1, 0); \
 189     } while (0)
 190 
 191 /**
 192  * Initializes the one glyph cache (texture and data structure).
 193  * If lcdCache is JNI_TRUE, the texture will contain RGB data,
 194  * otherwise we will simply store the grayscale/monochrome glyph images
 195  * as intensity values (which work well with the GL_MODULATE function).
 196  */
 197 static jboolean
 198 MTLTR_InitGlyphCache(MTLContext *mtlc, jboolean lcdCache)
 199 {
 200     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_InitGlyphCache&quot;);
 201     // TODO : Need to fix RGB order in case of LCD
 202     MTLPixelFormat pixelFormat = MTLPixelFormatBGRA8Unorm;
 203 
 204     MTLGlyphCacheInfo *gcinfo;
 205     // init glyph cache data structure
 206     gcinfo = MTLGlyphCache_Init(MTLTR_CACHE_WIDTH,
 207                                 MTLTR_CACHE_HEIGHT,
 208                                 MTLTR_CACHE_CELL_WIDTH,
 209                                 MTLTR_CACHE_CELL_HEIGHT,
 210                                 MTLVertexCache_FlushGlyphVertexCache);
 211 
 212     if (gcinfo == NULL) {
 213         J2dRlsTraceLn(J2D_TRACE_ERROR,
 214                       &quot;MTLTR_InitGlyphCache: could not init MTL glyph cache&quot;);
 215         return JNI_FALSE;
 216     }
 217 
 218     MTLTextureDescriptor *textureDescriptor =
 219         [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:pixelFormat
 220                                                             width:MTLTR_CACHE_WIDTH
 221                                                             height:MTLTR_CACHE_HEIGHT
 222                                                             mipmapped:NO];
 223 
 224     gcinfo-&gt;texture = [mtlc.device newTextureWithDescriptor:textureDescriptor];
 225     [textureDescriptor release];
 226 
 227     if (lcdCache) {
 228         glyphCacheLCD = gcinfo;
 229     } else {
 230         glyphCacheAA = gcinfo;
 231     }
 232 
 233     return JNI_TRUE;
 234 }
 235 
 236 id&lt;MTLTexture&gt;
 237 MTLTR_GetGlyphCacheTexture()
 238 {
 239     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_GetGlyphCacheTexture&quot;);
 240     if (glyphCacheAA != NULL) {
 241         return glyphCacheAA-&gt;texture;
 242     }
 243     return NULL;
 244 }
 245 
 246 /**
 247  * Adds the given glyph to the glyph cache (texture and data structure)
 248  * associated with the given MTLContext.
 249  */
 250 static void
 251 MTLTR_AddToGlyphCache(GlyphInfo *glyph, MTLContext *mtlc,
 252                       MTLPixelFormat pixelFormat)
 253 {
 254     MTLCacheCellInfo *ccinfo;
 255     MTLGlyphCacheInfo *gcinfo;
 256     jboolean isLCD = JNI_FALSE;
 257     jint w = glyph-&gt;width;
 258     jint h = glyph-&gt;height;
 259 
 260     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_AddToGlyphCache&quot;);
 261     if (pixelFormat == MTLPixelFormatA8Unorm) {
 262         gcinfo = glyphCacheAA;
 263     } else {
 264         gcinfo = glyphCacheLCD;
 265         isLCD = JNI_TRUE;
 266     }
 267 
 268     if ((gcinfo == NULL) || (glyph-&gt;image == NULL)) {
 269         return;
 270     }
 271 
 272     bool isCacheFull = MTLGlyphCache_IsCacheFull(gcinfo, glyph);
 273     if (isCacheFull) {
 274         MTLGlyphCache_Free(gcinfo);
 275         if (!isLCD) {
 276             MTLTR_InitGlyphCache(mtlc, JNI_FALSE);
 277             gcinfo = glyphCacheAA;
 278         } else {
 279             MTLTR_InitGlyphCache(mtlc, JNI_TRUE);
 280             gcinfo = glyphCacheLCD;
 281         }
 282     }
 283     MTLGlyphCache_AddGlyph(gcinfo, glyph);
 284     ccinfo = (MTLCacheCellInfo *) glyph-&gt;cellInfo;
 285 
 286     if (ccinfo != NULL) {
 287         // store glyph image in texture cell
 288         MTLRegion region = {
 289                 {ccinfo-&gt;x,  ccinfo-&gt;y,   0},
 290                 {w, h, 1}
 291         };
 292         if (!isLCD) {
 293             // Opengl uses GL_INTENSITY as internal pixel format to set number of
 294             // color components in the texture for grayscale texture.
 295             // It is mentioned that for GL_INTENSITY format,
 296             // the GL assembles it into an RGBA element by replicating the
 297             // intensity value three times for red, green, blue, and alpha.
 298             // To let metal behave the same for grayscale text,
 299             // we need to make sure we create BGRA component by replicating
 300             // graycale pixel value as in R=G=B=A=grayscale pixel value
 301 
 302             unsigned int imageBytes = w * h * 4;
 303             unsigned char imageData[imageBytes];
 304             memset(&amp;imageData, 0, sizeof(imageData));
 305 
 306             unsigned int dstindex = 0;
 307             for (int i = 0; i &lt; (w * h); i++) {
 308                 imageData[dstindex++] = glyph-&gt;image[i];
 309                 imageData[dstindex++] = glyph-&gt;image[i];
 310                 imageData[dstindex++] = glyph-&gt;image[i];
 311                 imageData[dstindex++] = glyph-&gt;image[i];
 312             }
 313             NSUInteger bytesPerRow = 4 * w;
 314             [gcinfo-&gt;texture replaceRegion:region
 315                              mipmapLevel:0
 316                              withBytes:imageData
 317                              bytesPerRow:bytesPerRow];
 318         } else {
 319             unsigned int imageBytes = w * h * 4;
 320             unsigned char imageData[imageBytes];
 321             memset(&amp;imageData, 0, sizeof(imageData));
 322 
 323             for (int i = 0; i &lt; h; i++) {
 324                 for (int j = 0; j &lt; w; j++) {
 325                     imageData[(i * w * 4) + j * 4] = glyph-&gt;image[(i * w * 3) + j * 3];
 326                     imageData[(i * w * 4) + j * 4 + 1] = glyph-&gt;image[(i * w * 3) + j * 3 + 1];
 327                     imageData[(i * w * 4) + j * 4 + 2] = glyph-&gt;image[(i * w * 3) + j * 3 + 2];
 328                     imageData[(i * w * 4) + j * 4 + 3] = 0xFF;
 329                 }
 330             }
 331 
 332             NSUInteger bytesPerRow = 4 * w;
 333             [gcinfo-&gt;texture replaceRegion:region
 334                              mipmapLevel:0
 335                              withBytes:imageData
 336                              bytesPerRow:bytesPerRow];
 337         }
 338     }
 339 }
 340 
 341 static MTLRenderPipelineDescriptor * templateRenderPipelineDesc = nil;
 342 static MTLRenderPipelineDescriptor * templateLCDPipelineDesc = nil;
 343 
 344 /**
 345  * Enables the LCD text shader and updates any related state, such as the
 346  * gamma lookup table textures.
 347  */
 348 static jboolean
 349 MTLTR_EnableLCDGlyphModeState(id&lt;MTLRenderCommandEncoder&gt; encoder,
 350                               MTLContext *mtlc, 
 351                               MTLSDOps *dstOps,
 352                               jint contrast)
 353 {
 354     // create the LCD text shader, if necessary
 355     if (templateLCDPipelineDesc == nil) {
 356 
 357         MTLVertexDescriptor *vertDesc = [[MTLVertexDescriptor new] autorelease];
 358         vertDesc.attributes[VertexAttributePosition].format = MTLVertexFormatFloat2;
 359         vertDesc.attributes[VertexAttributePosition].offset = 0;
 360         vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;
 361         vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct Vertex);
 362         vertDesc.layouts[MeshVertexBuffer].stepRate = 1;
 363         vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
 364 
 365         templateLCDPipelineDesc = [[MTLRenderPipelineDescriptor new] autorelease];
 366         templateLCDPipelineDesc.sampleCount = 1;
 367         templateLCDPipelineDesc.vertexDescriptor = vertDesc;
 368         templateLCDPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;
 369         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].format = MTLVertexFormatFloat2;
 370         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].offset = 2*sizeof(float);
 371         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].bufferIndex = MeshVertexBuffer;
 372         templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stride = sizeof(struct TxtVertex);
 373         templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepRate = 1;
 374         templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;
 375         templateLCDPipelineDesc.label = @&quot;template_lcd&quot;;
 376     }
 377 
 378     id&lt;MTLRenderPipelineState&gt; pipelineState =
 379                 [mtlc.pipelineStateStorage
 380                     getPipelineState:templateLCDPipelineDesc
 381                     vertexShaderId:@&quot;vert_txt&quot;
 382                     fragmentShaderId:@&quot;lcd_color&quot;
 383                    ];
 384 
 385     [encoder setRenderPipelineState:pipelineState];
 386 
 387     // update the current color settings
 388     double gamma = ((double)contrast) / 100.0;
 389     double invgamma = 1.0/gamma;
 390     jfloat radj, gadj, badj;
 391     jfloat clr[4];
 392     jint col = [mtlc.paint getColor];
 393 
 394     J2dTraceLn2(J2D_TRACE_INFO, &quot;primary color %x, contrast %d&quot;, col, contrast);
 395     J2dTraceLn2(J2D_TRACE_INFO, &quot;gamma %f, invgamma %f&quot;, gamma, invgamma);
 396 
 397     clr[0] = ((col &gt;&gt; 16) &amp; 0xFF)/255.0f;
 398     clr[1] = ((col &gt;&gt; 8) &amp; 0xFF)/255.0f;
 399     clr[2] = ((col) &amp; 0xFF)/255.0f;
 400 
 401     // gamma adjust the primary color
 402     radj = (float)pow(clr[0], gamma);
 403     gadj = (float)pow(clr[1], gamma);
 404     badj = (float)pow(clr[2], gamma);
 405 
 406     struct LCDFrameUniforms uf = {
 407             {radj, gadj, badj},
 408             {gamma, gamma, gamma},
 409             {invgamma, invgamma, invgamma}};
 410     [encoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
 411 
 412     return JNI_TRUE;
 413 }
 414 
<a name="2" id="anc2"></a><span class="line-added"> 415 static jboolean</span>
<span class="line-added"> 416 MTLTR_SetLCDCachePipelineState(MTLContext *mtlc)</span>
<span class="line-added"> 417 {</span>
<span class="line-added"> 418     if (templateLCDPipelineDesc == nil) {</span>
<span class="line-added"> 419 </span>
<span class="line-added"> 420         MTLVertexDescriptor *vertDesc = [[MTLVertexDescriptor new] autorelease];</span>
<span class="line-added"> 421         vertDesc.attributes[VertexAttributePosition].format = MTLVertexFormatFloat2;</span>
<span class="line-added"> 422         vertDesc.attributes[VertexAttributePosition].offset = 0;</span>
<span class="line-added"> 423         vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;</span>
<span class="line-added"> 424         vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct Vertex);</span>
<span class="line-added"> 425         vertDesc.layouts[MeshVertexBuffer].stepRate = 1;</span>
<span class="line-added"> 426         vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;</span>
<span class="line-added"> 427 </span>
<span class="line-added"> 428         templateLCDPipelineDesc = [[MTLRenderPipelineDescriptor new] autorelease];</span>
<span class="line-added"> 429         templateLCDPipelineDesc.sampleCount = 1;</span>
<span class="line-added"> 430         templateLCDPipelineDesc.vertexDescriptor = vertDesc;</span>
<span class="line-added"> 431         templateLCDPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;</span>
<span class="line-added"> 432         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].format = MTLVertexFormatFloat2;</span>
<span class="line-added"> 433         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].offset = 2*sizeof(float);</span>
<span class="line-added"> 434         templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].bufferIndex = MeshVertexBuffer;</span>
<span class="line-added"> 435         templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stride = sizeof(struct TxtVertex);</span>
<span class="line-added"> 436         templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepRate = 1;</span>
<span class="line-added"> 437         templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;</span>
<span class="line-added"> 438         templateLCDPipelineDesc.label = @&quot;template_lcd&quot;;</span>
<span class="line-added"> 439     }</span>
<span class="line-added"> 440 </span>
<span class="line-added"> 441     id&lt;MTLRenderPipelineState&gt; pipelineState =</span>
<span class="line-added"> 442                 [mtlc.pipelineStateStorage</span>
<span class="line-added"> 443                     getPipelineState:templateLCDPipelineDesc</span>
<span class="line-added"> 444                     vertexShaderId:@&quot;vert_txt&quot;</span>
<span class="line-added"> 445                     fragmentShaderId:@&quot;lcd_color&quot;</span>
<span class="line-added"> 446                    ];</span>
<span class="line-added"> 447 </span>
<span class="line-added"> 448     [lcdCacheEncoder setRenderPipelineState:pipelineState];</span>
<span class="line-added"> 449     return JNI_TRUE;</span>
<span class="line-added"> 450 }</span>
<span class="line-added"> 451 </span>
<span class="line-added"> 452 static jboolean</span>
<span class="line-added"> 453 MTLTR_SetLCDContrast(MTLContext *mtlc,</span>
<span class="line-added"> 454                      jint contrast)</span>
<span class="line-added"> 455 {</span>
<span class="line-added"> 456     // update the current color settings</span>
<span class="line-added"> 457     double gamma = ((double)contrast) / 100.0;</span>
<span class="line-added"> 458     double invgamma = 1.0/gamma;</span>
<span class="line-added"> 459     jfloat radj, gadj, badj;</span>
<span class="line-added"> 460     jfloat clr[4];</span>
<span class="line-added"> 461     jint col = [mtlc.paint getColor];</span>
<span class="line-added"> 462 </span>
<span class="line-added"> 463     J2dTraceLn2(J2D_TRACE_INFO, &quot;primary color %x, contrast %d&quot;, col, contrast);</span>
<span class="line-added"> 464     J2dTraceLn2(J2D_TRACE_INFO, &quot;gamma %f, invgamma %f&quot;, gamma, invgamma);</span>
<span class="line-added"> 465 </span>
<span class="line-added"> 466     clr[0] = ((col &gt;&gt; 16) &amp; 0xFF)/255.0f;</span>
<span class="line-added"> 467     clr[1] = ((col &gt;&gt; 8) &amp; 0xFF)/255.0f;</span>
<span class="line-added"> 468     clr[2] = ((col) &amp; 0xFF)/255.0f;</span>
<span class="line-added"> 469 </span>
<span class="line-added"> 470     // gamma adjust the primary color</span>
<span class="line-added"> 471     radj = (float)pow(clr[0], gamma);</span>
<span class="line-added"> 472     gadj = (float)pow(clr[1], gamma);</span>
<span class="line-added"> 473     badj = (float)pow(clr[2], gamma);</span>
<span class="line-added"> 474 </span>
<span class="line-added"> 475     struct LCDFrameUniforms uf = {</span>
<span class="line-added"> 476             {radj, gadj, badj},</span>
<span class="line-added"> 477             {gamma, gamma, gamma},</span>
<span class="line-added"> 478             {invgamma, invgamma, invgamma}};</span>
<span class="line-added"> 479     [lcdCacheEncoder setFragmentBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];</span>
<span class="line-added"> 480     return JNI_TRUE;</span>
<span class="line-added"> 481 }</span>
<span class="line-added"> 482 </span>
 483 void
 484 MTLTR_EnableGlyphVertexCache(MTLContext *mtlc, BMTLSDOps *dstOps)
 485 {
 486 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_EnableGlyphVertexCache&quot;);
 487 
 488     if (!MTLVertexCache_InitVertexCache()) {
 489         return;
 490     }
 491 
 492     if (glyphCacheAA == NULL) {
 493         if (!MTLTR_InitGlyphCache(mtlc, JNI_FALSE)) {
 494             return;
 495         }
 496     }
 497     MTLVertexCache_CreateSamplingEncoder(mtlc, dstOps);
 498 }
 499 
 500 void
 501 MTLTR_DisableGlyphVertexCache(MTLContext *mtlc)
 502 {
 503     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DisableGlyphVertexCache&quot;);
 504     MTLVertexCache_FlushGlyphVertexCache();
 505     MTLVertexCache_RestoreColorState(mtlc);
 506     MTLVertexCache_FreeVertexCache();
 507 }
 508 
 509 /**
 510  * Disables any pending state associated with the current &quot;glyph mode&quot;.
 511  */
 512 void
 513 MTLTR_DisableGlyphModeState()
 514 {
 515     // TODO : This is similar to OpenGL implementation
 516     // When LCD implementation is done weshould make
 517     // more changes.
 518     J2dTraceLn1(J2D_TRACE_VERBOSE,
 519                 &quot;MTLTR_DisableGlyphModeState: mode=%d&quot;, glyphMode);
 520     switch (glyphMode) {
 521     case MODE_NO_CACHE_LCD:
 522         // TODO : Along with LCD implementation
 523         // changes needs to be made
 524     case MODE_USE_CACHE_LCD:
 525         // TODO : Along with LCD implementation
 526         // changes needs to be made
 527         break;
 528     case MODE_NO_CACHE_GRAY:
 529     case MODE_USE_CACHE_GRAY:
 530     case MODE_NOT_INITED:
 531     default:
 532         break;
 533     }
 534 }
 535 
 536 static jboolean
 537 MTLTR_DrawGrayscaleGlyphViaCache(MTLContext *mtlc,
 538                                  GlyphInfo *ginfo, jint x, jint y, BMTLSDOps *dstOps)
 539 {
 540     MTLCacheCellInfo *cell;
 541     jfloat x1, y1, x2, y2;
 542 
 543     if (glyphMode != MODE_USE_CACHE_GRAY) {
 544         if (glyphMode == MODE_NO_CACHE_GRAY) {
 545             MTLVertexCache_DisableMaskCache(mtlc);
<a name="3" id="anc3"></a><span class="line-added"> 546         } else if (glyphMode == MODE_USE_CACHE_LCD) {</span>
<span class="line-added"> 547             [mtlc.encoderManager endEncoder];</span>
<span class="line-added"> 548             lcdCacheEncoder = nil;</span>
 549         }
 550         MTLTR_EnableGlyphVertexCache(mtlc, dstOps);
 551         glyphMode = MODE_USE_CACHE_GRAY;
 552     }
 553 
 554     if (ginfo-&gt;cellInfo == NULL) {
 555         // attempt to add glyph to accelerated glyph cache
 556         MTLTR_AddToGlyphCache(ginfo, mtlc, MTLPixelFormatA8Unorm);
 557 
 558         if (ginfo-&gt;cellInfo == NULL) {
 559             // we&#39;ll just no-op in the rare case that the cell is NULL
 560             return JNI_TRUE;
 561         }
 562     }
 563 
 564     cell = (MTLCacheCellInfo *) (ginfo-&gt;cellInfo);
 565     cell-&gt;timesRendered++;
 566 
 567     x1 = (jfloat)x;
 568     y1 = (jfloat)y;
 569     x2 = x1 + ginfo-&gt;width;
 570     y2 = y1 + ginfo-&gt;height;
 571 
 572     MTLVertexCache_AddGlyphQuad(mtlc,
 573                                 cell-&gt;tx1, cell-&gt;ty1,
 574                                 cell-&gt;tx2, cell-&gt;ty2,
 575                                 x1, y1, x2, y2);
 576 
 577     return JNI_TRUE;
 578 }
 579 
 580 /**
 581  * Evaluates to true if the rectangle defined by gx1/gy1/gx2/gy2 is
 582  * inside outerBounds.
 583  */
 584 #define INSIDE(gx1, gy1, gx2, gy2, outerBounds) \
 585     (((gx1) &gt;= outerBounds.x1) &amp;&amp; ((gy1) &gt;= outerBounds.y1) &amp;&amp; \
 586      ((gx2) &lt;= outerBounds.x2) &amp;&amp; ((gy2) &lt;= outerBounds.y2))
 587 
 588 /**
 589  * Evaluates to true if the rectangle defined by gx1/gy1/gx2/gy2 intersects
 590  * the rectangle defined by bounds.
 591  */
 592 #define INTERSECTS(gx1, gy1, gx2, gy2, bounds) \
 593     ((bounds.x2 &gt; (gx1)) &amp;&amp; (bounds.y2 &gt; (gy1)) &amp;&amp; \
 594      (bounds.x1 &lt; (gx2)) &amp;&amp; (bounds.y1 &lt; (gy2)))
 595 
 596 /**
 597  * This method checks to see if the given LCD glyph bounds fall within the
 598  * cached destination texture bounds.  If so, this method can return
 599  * immediately.  If not, this method will copy a chunk of framebuffer data
 600  * into the cached destination texture and then update the current cached
 601  * destination bounds before returning.
 602  */
 603 static void
 604 MTLTR_UpdateCachedDestination(MTLSDOps *dstOps, GlyphInfo *ginfo,
 605                               jint gx1, jint gy1, jint gx2, jint gy2,
 606                               jint glyphIndex, jint totalGlyphs)
 607 {
 608     //TODO
 609 }
 610 
 611 static jboolean
 612 MTLTR_DrawLCDGlyphViaCache(MTLContext *mtlc, BMTLSDOps *dstOps,
 613                            GlyphInfo *ginfo, jint x, jint y,
 614                            jint rowBytesOffset,
 615                            jboolean rgbOrder, jint contrast,
 616                            id&lt;MTLTexture&gt; dstTexture)
 617 {
 618     CacheCellInfo *cell;
 619     jfloat tx1, ty1, tx2, ty2;
 620     jint w = ginfo-&gt;width;
 621     jint h = ginfo-&gt;height;
 622 
<a name="4" id="anc4"></a>

 623     if (glyphMode != MODE_USE_CACHE_LCD) {
 624         if (glyphMode == MODE_NO_CACHE_GRAY) {
 625             MTLVertexCache_DisableMaskCache(mtlc);
 626         } else if (glyphMode == MODE_USE_CACHE_GRAY) {
 627             MTLTR_DisableGlyphVertexCache(mtlc);
 628         }
 629 
 630         if (glyphCacheLCD == NULL) {
 631             if (!MTLTR_InitGlyphCache(mtlc, JNI_TRUE)) {
 632                 return JNI_FALSE;
 633             }
 634         }
<a name="5" id="anc5"></a><span class="line-modified"> 635         if (lcdCacheEncoder == nil) {</span>
<span class="line-added"> 636             lcdCacheEncoder = [mtlc.encoderManager getTextureEncoder:dstOps-&gt;pTexture isSrcOpaque:YES isDstOpaque:YES];</span>
<span class="line-added"> 637             MTLTR_SetLCDCachePipelineState(mtlc);</span>
<span class="line-added"> 638         }</span>
 639         if (rgbOrder != lastRGBOrder) {
 640             // need to invalidate the cache in this case; see comments
 641             // for lastRGBOrder above
 642             MTLGlyphCache_Invalidate(glyphCacheLCD);
 643             lastRGBOrder = rgbOrder;
 644         }
 645 
 646         glyphMode = MODE_USE_CACHE_LCD;
 647     }
 648 
 649     if (ginfo-&gt;cellInfo == NULL) {
 650         // attempt to add glyph to accelerated glyph cache
 651         // TODO : Handle RGB order
 652         MTLTR_AddToGlyphCache(ginfo, mtlc, MTLPixelFormatRGBA8Unorm);
 653 
 654         if (ginfo-&gt;cellInfo == NULL) {
 655             // we&#39;ll just no-op in the rare case that the cell is NULL
 656             return JNI_TRUE;
 657         }
 658     }
 659     cell = (CacheCellInfo *) (ginfo-&gt;cellInfo);
 660     cell-&gt;timesRendered++;
<a name="6" id="anc6"></a>




 661 
<a name="7" id="anc7"></a><span class="line-added"> 662     MTLTR_SetLCDContrast(mtlc, contrast);</span>
 663     tx1 = cell-&gt;tx1;
 664     ty1 = cell-&gt;ty1;
 665     tx2 = cell-&gt;tx2;
 666     ty2 = cell-&gt;ty2;
 667 
 668     J2dTraceLn4(J2D_TRACE_INFO, &quot;tx1 %f, ty1 %f, tx2 %f, ty2 %f&quot;, tx1, ty1, tx2, ty2);
 669     J2dTraceLn2(J2D_TRACE_INFO, &quot;textureWidth %d textureHeight %d&quot;, dstOps-&gt;textureWidth, dstOps-&gt;textureHeight);
 670 
 671     LCD_ADD_TRIANGLES(tx1, ty1, tx2, ty2, x, y, x+w, y+h);
 672 
<a name="8" id="anc8"></a><span class="line-modified"> 673     [lcdCacheEncoder setVertexBytes:txtVertices length:sizeof(txtVertices) atIndex:MeshVertexBuffer];</span>
<span class="line-modified"> 674     [lcdCacheEncoder setFragmentTexture:glyphCacheLCD-&gt;texture atIndex:0];</span>
<span class="line-modified"> 675     [lcdCacheEncoder setFragmentTexture:dstOps-&gt;pTexture atIndex:1];</span>
 676 
<a name="9" id="anc9"></a><span class="line-modified"> 677     [lcdCacheEncoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];</span>
 678 
 679     vertexCacheIndex = 0;
<a name="10" id="anc10"></a>
 680 
 681     return JNI_TRUE;
 682 }
 683 
 684 static jboolean
 685 MTLTR_DrawGrayscaleGlyphNoCache(MTLContext *mtlc,
 686                                 GlyphInfo *ginfo, jint x, jint y, BMTLSDOps *dstOps)
 687 {
 688     jint tw, th;
 689     jint sx, sy, sw, sh;
 690     jint x0;
 691     jint w = ginfo-&gt;width;
 692     jint h = ginfo-&gt;height;
 693 
 694     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGrayscaleGlyphNoCache&quot;);
 695     if (glyphMode != MODE_NO_CACHE_GRAY) {
 696         if (glyphMode == MODE_USE_CACHE_GRAY) {
 697             MTLTR_DisableGlyphVertexCache(mtlc);
<a name="11" id="anc11"></a><span class="line-added"> 698         } else if (glyphMode == MODE_USE_CACHE_LCD) {</span>
<span class="line-added"> 699             [mtlc.encoderManager endEncoder];</span>
<span class="line-added"> 700             lcdCacheEncoder = nil;</span>
 701         }
 702         MTLVertexCache_EnableMaskCache(mtlc, dstOps);
 703         glyphMode = MODE_NO_CACHE_GRAY;
 704     }
 705 
 706     x0 = x;
 707     tw = MTLVC_MASK_CACHE_TILE_WIDTH;
 708     th = MTLVC_MASK_CACHE_TILE_HEIGHT;
 709 
 710     for (sy = 0; sy &lt; h; sy += th, y += th) {
 711         x = x0;
 712         sh = ((sy + th) &gt; h) ? (h - sy) : th;
 713 
 714         for (sx = 0; sx &lt; w; sx += tw, x += tw) {
 715             sw = ((sx + tw) &gt; w) ? (w - sx) : tw;
 716 
 717             J2dTraceLn7(J2D_TRACE_INFO, &quot;sx = %d sy = %d x = %d y = %d sw = %d sh = %d w = %d&quot;, sx, sy, x, y, sw, sh, w);
 718             MTLVertexCache_AddMaskQuad(mtlc,
 719                                        sx, sy, x, y, sw, sh,
 720                                        w, ginfo-&gt;image,
 721                                        dstOps,
 722                                        ginfo-&gt;width);
 723         }
 724     }
 725 
 726     return JNI_TRUE;
 727 }
 728 
 729 
 730 static jboolean
 731 MTLTR_DrawLCDGlyphNoCache(MTLContext *mtlc, BMTLSDOps *dstOps,
 732                           GlyphInfo *ginfo, jint x, jint y,
 733                           jint rowBytesOffset,
 734                           jboolean rgbOrder, jint contrast,
 735                           id&lt;MTLTexture&gt; dstTexture)
 736 {
 737     jfloat tx1, ty1, tx2, ty2;
 738     jfloat dtx1=0, dty1=0, dtx2=0, dty2=0;
 739     jint tw, th;
 740     jint sx=0, sy=0, sw=0, sh=0, dxadj=0, dyadj=0;
 741     jint x0;
 742     jint w = ginfo-&gt;width;
 743     jint h = ginfo-&gt;height;
 744     id&lt;MTLTexture&gt; blitTexture = nil;
 745 
 746     J2dTraceLn2(J2D_TRACE_INFO, &quot;MTLTR_DrawLCDGlyphNoCache x %d, y%d&quot;, x, y);
 747     J2dTraceLn3(J2D_TRACE_INFO, &quot;MTLTR_DrawLCDGlyphNoCache rowBytesOffset=%d, rgbOrder=%d, contrast=%d&quot;, rowBytesOffset, rgbOrder, contrast);
 748 
 749 
 750     id&lt;MTLRenderCommandEncoder&gt; encoder = nil;
 751 
 752     MTLTextureDescriptor *textureDescriptor =
 753         [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatBGRA8Unorm
 754                                                             width:w
 755                                                             height:h
 756                                                             mipmapped:NO];
 757 
 758     blitTexture = [mtlc.device newTextureWithDescriptor:textureDescriptor];
 759     [textureDescriptor release];
 760 
 761     if (glyphMode != MODE_NO_CACHE_LCD) {
 762         if (glyphMode == MODE_NO_CACHE_GRAY) {
 763             MTLVertexCache_DisableMaskCache(mtlc);
 764         } else if (glyphMode == MODE_USE_CACHE_GRAY) {
 765             MTLTR_DisableGlyphVertexCache(mtlc);
<a name="12" id="anc12"></a><span class="line-added"> 766         } else if (glyphMode == MODE_USE_CACHE_LCD) {</span>
<span class="line-added"> 767             [mtlc.encoderManager endEncoder];</span>
<span class="line-added"> 768             lcdCacheEncoder = nil;</span>
 769         }
 770 
 771         if (blitTexture == nil) {
 772             J2dTraceLn(J2D_TRACE_ERROR, &quot;can&#39;t obtain temporary texture object from pool&quot;);
 773             return JNI_FALSE;
 774         }
 775 
 776 
 777         glyphMode = MODE_NO_CACHE_LCD;
 778     }
 779     encoder = [mtlc.encoderManager getTextureEncoder:dstOps-&gt;pTexture isSrcOpaque:YES isDstOpaque:YES];
 780     if (!MTLTR_EnableLCDGlyphModeState(encoder, mtlc, dstOps,contrast))
 781     {
 782         return JNI_FALSE;
 783     }
 784 
 785     x0 = x;
 786     tx1 = 0.0f;
 787     ty1 = 0.0f;
 788     dtx1 = 0.0f;
 789     dty2 = 0.0f;
 790     tw = MTLTR_NOCACHE_TILE_SIZE;
 791     th = MTLTR_NOCACHE_TILE_SIZE;
 792 
 793     unsigned int imageBytes = w * h *4;
 794     unsigned char imageData[imageBytes];
 795     memset(&amp;imageData, 0, sizeof(imageData));
 796 
 797     for (int i = 0; i &lt; h; i++) {
 798         for (int j = 0; j &lt; w; j++) {
 799             imageData[(i * w * 4) + j * 4] = ginfo-&gt;image[(i * w * 3) + j * 3];
 800             imageData[(i * w * 4) + j * 4 + 1] = ginfo-&gt;image[(i * w * 3) + j * 3 + 1];
 801             imageData[(i * w * 4) + j * 4 + 2] = ginfo-&gt;image[(i * w * 3) + j * 3 + 2];
 802             imageData[(i * w * 4) + j * 4 + 3] = 0xFF;
 803         }
 804     }
 805 
 806     // copy LCD mask into glyph texture tile
 807     MTLRegion region = MTLRegionMake2D(0, 0, w, h);
 808 
 809     NSUInteger bytesPerRow = 4 * ginfo-&gt;width;
 810     [blitTexture replaceRegion:region
 811                  mipmapLevel:0
 812                  withBytes:imageData
 813                  bytesPerRow:bytesPerRow];
 814 
 815     J2dTraceLn7(J2D_TRACE_INFO, &quot;sx = %d sy = %d x = %d y = %d sw = %d sh = %d w = %d&quot;, sx, sy, x, y, sw, sh, w);
 816 
 817 
 818     // update the lower-right glyph texture coordinates
 819     tx2 = 1.0f;
 820     ty2 = 1.0f;
 821 
 822     J2dTraceLn5(J2D_TRACE_INFO, &quot;xOffset %d yOffset %d, dxadj %d, dyadj %d dstOps-&gt;height %d&quot;, dstOps-&gt;xOffset, dstOps-&gt;yOffset, dxadj, dyadj, dstOps-&gt;height);
 823 
 824     dtx1 = ((jfloat)dxadj) / dstOps-&gt;textureWidth;
 825     dtx2 = ((float)dxadj + sw) / dstOps-&gt;textureWidth;
 826   
 827     dty1 = ((jfloat)dyadj + sh) / dstOps-&gt;textureHeight;
 828     dty2 = ((jfloat)dyadj) / dstOps-&gt;textureHeight;
 829 
 830     J2dTraceLn4(J2D_TRACE_INFO, &quot;tx1 %f, ty1 %f, tx2 %f, ty2 %f&quot;, tx1, ty1, tx2, ty2);
 831     J2dTraceLn2(J2D_TRACE_INFO, &quot;textureWidth %d textureHeight %d&quot;, dstOps-&gt;textureWidth, dstOps-&gt;textureHeight);
 832     J2dTraceLn4(J2D_TRACE_INFO, &quot;dtx1 %f, dty1 %f, dtx2 %f, dty2 %f&quot;, dtx1, dty1, dtx2, dty2);
 833 
 834     LCD_ADD_TRIANGLES(tx1, ty1, tx2, ty2, x, y, x+w, y+h);
 835 
 836     [encoder setVertexBytes:txtVertices length:sizeof(txtVertices) atIndex:MeshVertexBuffer];
 837     [encoder setFragmentTexture:blitTexture atIndex:0];
 838     [encoder setFragmentTexture:dstOps-&gt;pTexture atIndex:1];
 839 
 840     [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];
 841 
 842     vertexCacheIndex = 0;
 843     [mtlc.encoderManager endEncoder];
 844     [blitTexture release];
 845 
 846     MTLCommandBufferWrapper* cbwrapper = [mtlc pullCommandBufferWrapper];
 847 
 848     id&lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
 849     [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
 850         [cbwrapper release];
 851     }];
 852 
 853     [commandbuf commit];
 854     [commandbuf waitUntilCompleted];
 855 
 856     return JNI_TRUE;
 857 }
 858 
 859 // see DrawGlyphList.c for more on this macro...
 860 #define FLOOR_ASSIGN(l, r) \
 861     if ((r)&lt;0) (l) = ((int)floor(r)); else (l) = ((int)(r))
 862 
 863 void
 864 MTLTR_DrawGlyphList(JNIEnv *env, MTLContext *mtlc, BMTLSDOps *dstOps,
 865                     jint totalGlyphs, jboolean usePositions,
 866                     jboolean subPixPos, jboolean rgbOrder, jint lcdContrast,
 867                     jfloat glyphListOrigX, jfloat glyphListOrigY,
 868                     unsigned char *images, unsigned char *positions)
 869 {
 870     int glyphCounter;
 871 
 872     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList&quot;);
 873 
 874     RETURN_IF_NULL(mtlc);
 875     RETURN_IF_NULL(dstOps);
 876     RETURN_IF_NULL(images);
 877     if (usePositions) {
 878         RETURN_IF_NULL(positions);
 879     }
 880 
 881     glyphMode = MODE_NOT_INITED;
 882     isCachedDestValid = JNI_FALSE;
 883     J2dTraceLn1(J2D_TRACE_INFO, &quot;totalGlyphs = %d&quot;, totalGlyphs);
 884 
 885     for (glyphCounter = 0; glyphCounter &lt; totalGlyphs; glyphCounter++) {
 886         J2dTraceLn(J2D_TRACE_INFO, &quot;Entered for loop for glyph list&quot;);
 887         jint x, y;
 888         jfloat glyphx, glyphy;
 889         jboolean grayscale, ok;
 890         GlyphInfo *ginfo = (GlyphInfo *)jlong_to_ptr(NEXT_LONG(images));
 891 
 892         if (ginfo == NULL) {
 893             // this shouldn&#39;t happen, but if it does we&#39;ll just break out...
 894             J2dRlsTraceLn(J2D_TRACE_ERROR,
 895                           &quot;MTLTR_DrawGlyphList: glyph info is null&quot;);
 896             break;
 897         }
 898 
 899         grayscale = (ginfo-&gt;rowBytes == ginfo-&gt;width);
 900 
 901         if (usePositions) {
 902             jfloat posx = NEXT_FLOAT(positions);
 903             jfloat posy = NEXT_FLOAT(positions);
 904             glyphx = glyphListOrigX + posx + ginfo-&gt;topLeftX;
 905             glyphy = glyphListOrigY + posy + ginfo-&gt;topLeftY;
 906             FLOOR_ASSIGN(x, glyphx);
 907             FLOOR_ASSIGN(y, glyphy);
 908         } else {
 909             glyphx = glyphListOrigX + ginfo-&gt;topLeftX;
 910             glyphy = glyphListOrigY + ginfo-&gt;topLeftY;
 911             FLOOR_ASSIGN(x, glyphx);
 912             FLOOR_ASSIGN(y, glyphy);
 913             glyphListOrigX += ginfo-&gt;advanceX;
 914             glyphListOrigY += ginfo-&gt;advanceY;
 915         }
 916 
 917         if (ginfo-&gt;image == NULL) {
 918             J2dTraceLn(J2D_TRACE_INFO, &quot;Glyph image is null&quot;);
 919             continue;
 920         }
 921 
 922         J2dTraceLn2(J2D_TRACE_INFO, &quot;Glyph width = %d height = %d&quot;, ginfo-&gt;width, ginfo-&gt;height);
 923         J2dTraceLn1(J2D_TRACE_INFO, &quot;rowBytes = %d&quot;, ginfo-&gt;rowBytes);
 924         if (grayscale) {
 925             // grayscale or monochrome glyph data
 926             if (ginfo-&gt;width &lt;= MTLTR_CACHE_CELL_WIDTH &amp;&amp;
 927                 ginfo-&gt;height &lt;= MTLTR_CACHE_CELL_HEIGHT)
 928             {
 929                 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList Grayscale cache&quot;);
 930                 ok = MTLTR_DrawGrayscaleGlyphViaCache(mtlc, ginfo, x, y, dstOps);
 931             } else {
 932                 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList Grayscale no cache&quot;);
 933                 ok = MTLTR_DrawGrayscaleGlyphNoCache(mtlc, ginfo, x, y, dstOps);
 934             }
 935         } else {
 936             void* dstTexture = dstOps-&gt;textureLCD;
 937 
 938             // LCD-optimized glyph data
 939             jint rowBytesOffset = 0;
 940 
 941             if (subPixPos) {
 942                 jint frac = (jint)((glyphx - x) * 3);
 943                 if (frac != 0) {
 944                     rowBytesOffset = 3 - frac;
 945                     x += 1;
 946                 }
 947             }
 948 
 949             if (rowBytesOffset == 0 &amp;&amp;
 950                 ginfo-&gt;width &lt;= MTLTR_CACHE_CELL_WIDTH &amp;&amp;
 951                 ginfo-&gt;height &lt;= MTLTR_CACHE_CELL_HEIGHT)
 952             {
 953                 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList LCD cache&quot;);
 954                 ok = MTLTR_DrawLCDGlyphViaCache(mtlc, dstOps,
 955                                                 ginfo, x, y,
 956                                                 rowBytesOffset,
 957                                                 rgbOrder, lcdContrast,
 958                                                 dstTexture);
 959             } else {
 960                 J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList LCD no cache&quot;);
 961                 ok = MTLTR_DrawLCDGlyphNoCache(mtlc, dstOps,
 962                                                ginfo, x, y,
 963                                                rowBytesOffset,
 964                                                rgbOrder, lcdContrast,
 965                                                dstTexture);
 966             }
 967         }
 968 
 969         if (!ok) {
 970             break;
 971         }
 972     }
 973     /*
 974      * Only in case of grayscale text drawing we need to flush
 975      * cache. Still in case of LCD we are not using any intermediate
 976      * cache.
 977      */
 978     if (glyphMode == MODE_NO_CACHE_GRAY) {
 979         MTLVertexCache_DisableMaskCache(mtlc);
 980     } else if (glyphMode == MODE_USE_CACHE_GRAY) {
 981         MTLTR_DisableGlyphVertexCache(mtlc);
<a name="13" id="anc13"></a><span class="line-added"> 982     } else if (glyphMode == MODE_USE_CACHE_LCD) {</span>
<span class="line-added"> 983         [mtlc.encoderManager endEncoder];</span>
<span class="line-added"> 984         lcdCacheEncoder = nil;</span>
 985     }
 986 }
 987 
 988 JNIEXPORT void JNICALL
 989 Java_sun_java2d_metal_MTLTextRenderer_drawGlyphList
 990     (JNIEnv *env, jobject self,
 991      jint numGlyphs, jboolean usePositions,
 992      jboolean subPixPos, jboolean rgbOrder, jint lcdContrast,
 993      jfloat glyphListOrigX, jfloat glyphListOrigY,
 994      jlongArray imgArray, jfloatArray posArray)
 995 {
 996     unsigned char *images;
 997 
 998     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTextRenderer_drawGlyphList&quot;);
 999 
1000     images = (unsigned char *)
1001         (*env)-&gt;GetPrimitiveArrayCritical(env, imgArray, NULL);
1002     if (images != NULL) {
1003         MTLContext *mtlc = MTLRenderQueue_GetCurrentContext();
1004         BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
1005 
1006         if (usePositions) {
1007             unsigned char *positions = (unsigned char *)
1008                 (*env)-&gt;GetPrimitiveArrayCritical(env, posArray, NULL);
1009             if (positions != NULL) {
1010                 MTLTR_DrawGlyphList(env, mtlc, dstOps,
1011                                     numGlyphs, usePositions,
1012                                     subPixPos, rgbOrder, lcdContrast,
1013                                     glyphListOrigX, glyphListOrigY,
1014                                     images, positions);
1015                 (*env)-&gt;ReleasePrimitiveArrayCritical(env, posArray,
1016                                                       positions, JNI_ABORT);
1017             }
1018         } else {
1019             MTLTR_DrawGlyphList(env, mtlc, dstOps,
1020                                 numGlyphs, usePositions,
1021                                 subPixPos, rgbOrder, lcdContrast,
1022                                 glyphListOrigX, glyphListOrigY,
1023                                 images, NULL);
1024         }
1025 
1026         (*env)-&gt;ReleasePrimitiveArrayCritical(env, imgArray,
1027                                               images, JNI_ABORT);
1028     }
1029 }
1030 
1031 #endif /* !HEADLESS */
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
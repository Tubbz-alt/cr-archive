<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/macosx/native/libawt_lwawt/awt/shaders.metal</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/java.desktop/macosx/native/libawt_lwawt/awt/shaders.metal</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
213     // TODO: check uniforms.isNonPremult and pre-multiply if necessary
214     return half4(srcColor.r*uniforms.normScaleFactors.r + uniforms.normOffsets.r,
215                  srcColor.g*uniforms.normScaleFactors.g + uniforms.normOffsets.g,
216                  srcColor.b*uniforms.normScaleFactors.b + uniforms.normOffsets.b, srcA*uniforms.extraAlpha);
217 
218     // NOTE: GL-shader multiplies result with glColor (in order to apply extra alpha), probably it&#39;s better to do the
219     // same here.
220     //
221     // GL-shader impl:
222     //&quot;    vec4 srcColor = texture%s(baseImage, gl_TexCoord[0].st);&quot;
223     //&quot;    %s&quot;                                                      // (placeholder for un-premult code: srcColor.rgb /= srcColor.a;)
224     //&quot;    vec4 result = (srcColor * scaleFactors) + offsets;&quot;      // rescale source value
225     //&quot;    %s&quot;                                                      // (placeholder for re-premult code: result.rgb *= result.a;)
226     //&quot;    gl_FragColor = result * gl_Color;&quot;                       // modulate with gl_Color in order to apply extra alpha
227 }
228 
229 fragment half4 frag_txt_op_convolve(
230         TxtShaderInOut vert [[stage_in]],
231         texture2d&lt;float, access::sample&gt; srcTex [[texture(0)]],
232         constant TxtFrameOpConvolveUniforms&amp; uniforms [[buffer(1)]],
<span class="line-modified">233         const device float3 * kernelVals [[buffer(2)]],</span>
234         sampler textureSampler [[sampler(0)]]
235 ) {
236     float4 sum = float4(0, 0, 0, 0);
237     if (vert.texCoords[0] &lt; uniforms.imgEdge[0]
238         || vert.texCoords[1] &lt; uniforms.imgEdge[1]
239         || vert.texCoords[0] &gt; uniforms.imgEdge[2]
240         || vert.texCoords[1] &gt; uniforms.imgEdge[3]
241     ) {
242         if (!uniforms.isEdgeZeroFill) {
243             sum = srcTex.sample(textureSampler, vert.texCoords);
244         }
245     }
246 
247     for (int i = 0; i &lt; uniforms.kernelSize; i++) {
<span class="line-modified">248         float3 kern = kernelVals[i];</span>
249         float2 pos = float2(vert.texCoords.x + kern.x, vert.texCoords.y + kern.y);
250         float4 pixCol = srcTex.sample(textureSampler, pos);
251         sum.r += kern.z * pixCol.r;
252         sum.g += kern.z * pixCol.g;
253         sum.b += kern.z * pixCol.b;
254         sum.a += kern.z * pixCol.a;
255     }
256 
257     return half4(sum.r, sum.g, sum.b, sum.a*uniforms.extraAlpha);
258 
259     // NOTE: GL-shader multiplies result with glColor (in order to apply extra alpha), probably it&#39;s better to do the
260     // same here.
261     //
262     // GL-shader impl:
263     //&quot;    if (any(lessThan(gl_TexCoord[0].st, imgEdge.xy)) ||&quot;
264     //&quot;        any(greaterThan(gl_TexCoord[0].st, imgEdge.zw)))&quot;
265     //&quot;    {&quot;
266     //&quot;        %s&quot;      // (placeholder for edge condition code)
267     //&quot;    } else {&quot;
268     //&quot;        sum = vec4(0.0);&quot;
</pre>
</td>
<td>
<hr />
<pre>
213     // TODO: check uniforms.isNonPremult and pre-multiply if necessary
214     return half4(srcColor.r*uniforms.normScaleFactors.r + uniforms.normOffsets.r,
215                  srcColor.g*uniforms.normScaleFactors.g + uniforms.normOffsets.g,
216                  srcColor.b*uniforms.normScaleFactors.b + uniforms.normOffsets.b, srcA*uniforms.extraAlpha);
217 
218     // NOTE: GL-shader multiplies result with glColor (in order to apply extra alpha), probably it&#39;s better to do the
219     // same here.
220     //
221     // GL-shader impl:
222     //&quot;    vec4 srcColor = texture%s(baseImage, gl_TexCoord[0].st);&quot;
223     //&quot;    %s&quot;                                                      // (placeholder for un-premult code: srcColor.rgb /= srcColor.a;)
224     //&quot;    vec4 result = (srcColor * scaleFactors) + offsets;&quot;      // rescale source value
225     //&quot;    %s&quot;                                                      // (placeholder for re-premult code: result.rgb *= result.a;)
226     //&quot;    gl_FragColor = result * gl_Color;&quot;                       // modulate with gl_Color in order to apply extra alpha
227 }
228 
229 fragment half4 frag_txt_op_convolve(
230         TxtShaderInOut vert [[stage_in]],
231         texture2d&lt;float, access::sample&gt; srcTex [[texture(0)]],
232         constant TxtFrameOpConvolveUniforms&amp; uniforms [[buffer(1)]],
<span class="line-modified">233         const device float * kernelVals [[buffer(2)]],</span>
234         sampler textureSampler [[sampler(0)]]
235 ) {
236     float4 sum = float4(0, 0, 0, 0);
237     if (vert.texCoords[0] &lt; uniforms.imgEdge[0]
238         || vert.texCoords[1] &lt; uniforms.imgEdge[1]
239         || vert.texCoords[0] &gt; uniforms.imgEdge[2]
240         || vert.texCoords[1] &gt; uniforms.imgEdge[3]
241     ) {
242         if (!uniforms.isEdgeZeroFill) {
243             sum = srcTex.sample(textureSampler, vert.texCoords);
244         }
245     }
246 
247     for (int i = 0; i &lt; uniforms.kernelSize; i++) {
<span class="line-modified">248         float3 kern = float3(kernelVals[i*3], kernelVals[i*3 + 1], kernelVals[i*3 + 2]);</span>
249         float2 pos = float2(vert.texCoords.x + kern.x, vert.texCoords.y + kern.y);
250         float4 pixCol = srcTex.sample(textureSampler, pos);
251         sum.r += kern.z * pixCol.r;
252         sum.g += kern.z * pixCol.g;
253         sum.b += kern.z * pixCol.b;
254         sum.a += kern.z * pixCol.a;
255     }
256 
257     return half4(sum.r, sum.g, sum.b, sum.a*uniforms.extraAlpha);
258 
259     // NOTE: GL-shader multiplies result with glColor (in order to apply extra alpha), probably it&#39;s better to do the
260     // same here.
261     //
262     // GL-shader impl:
263     //&quot;    if (any(lessThan(gl_TexCoord[0].st, imgEdge.xy)) ||&quot;
264     //&quot;        any(greaterThan(gl_TexCoord[0].st, imgEdge.zw)))&quot;
265     //&quot;    {&quot;
266     //&quot;        %s&quot;      // (placeholder for edge condition code)
267     //&quot;    } else {&quot;
268     //&quot;        sum = vec4(0.0);&quot;
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLClip.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MTLClip.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MTLSurfaceData.m.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLClip.m</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 32         stencilDescriptor.frontFaceStencil.stencilCompareFunction = MTLCompareFunctionEqual;
 33         stencilDescriptor.frontFaceStencil.stencilFailureOperation = MTLStencilOperationKeep;
 34 
 35         // TODO : backFaceStencil can be set to nil if all primitives are drawn as front-facing primitives
 36         // currently, fill parallelogram uses back-facing primitive drawing - that needs to be changed.
 37         // Once that part is changed, set backFaceStencil to nil
 38         //stencilDescriptor.backFaceStencil = nil;
 39 
 40         stencilDescriptor.backFaceStencil.stencilCompareFunction = MTLCompareFunctionEqual;
 41         stencilDescriptor.backFaceStencil.stencilFailureOperation = MTLStencilOperationKeep;
 42 
 43         stencilState = [device newDepthStencilStateWithDescriptor:stencilDescriptor];
 44     }
 45 
 46     return stencilState;
 47 }
 48 
 49 @implementation MTLClip {
 50     jint _clipType;
 51     MTLScissorRect  _clipRect;
<span class="line-modified"> 52 </span>
<span class="line-modified"> 53     jboolean _stencilMaskGenerationInProgress;</span>
<span class="line-modified"> 54     id&lt;MTLTexture&gt; _stencilTextureRef;</span>
<span class="line-modified"> 55     id&lt;MTLTexture&gt; _stencilAADataRef;</span>

 56 }
 57 
 58 - (id)init {
 59     self = [super init];
 60     if (self) {
 61         _clipType = NO_CLIP;
<span class="line-modified"> 62         _stencilMaskGenerationInProgress = JNI_FALSE;</span>
<span class="line-modified"> 63         _stencilTextureRef = nil;</span>



 64     }
 65     return self;
 66 }
 67 
 68 - (BOOL)isEqual:(MTLClip *)other {
 69     if (self == other)
 70         return YES;
 71     if (_stencilMaskGenerationInProgress == JNI_TRUE)
 72         return other-&gt;_stencilMaskGenerationInProgress == JNI_TRUE;
 73     if (_clipType != other-&gt;_clipType)
 74         return NO;
 75     if (_clipType == NO_CLIP)
 76         return YES;
 77     if (_clipType == RECT_CLIP) {
 78         return _clipRect.x == other-&gt;_clipRect.x &amp;&amp; _clipRect.y == other-&gt;_clipRect.y
 79                &amp;&amp; _clipRect.width == other-&gt;_clipRect.width &amp;&amp; _clipRect.height == other-&gt;_clipRect.height;
 80     }
 81 
 82     // NOTE: can compare stencil-data pointers here
 83     return YES;
 84 }
 85 
 86 - (BOOL)isShape {
 87     return _clipType == SHAPE_CLIP;
 88 }
 89 
 90 - (BOOL)isRect __unused {
 91     return _clipType == RECT_CLIP;
 92 }
 93 
 94 - (const MTLScissorRect * _Nullable) getRect {
 95     return _clipType == RECT_CLIP ? &amp;_clipRect : NULL;
 96 }
 97 
 98 - (void)copyFrom:(MTLClip *)other {
 99     _clipType = other-&gt;_clipType;
100     _stencilMaskGenerationInProgress = other-&gt;_stencilMaskGenerationInProgress;
<span class="line-modified">101     _stencilTextureRef = other-&gt;_stencilTextureRef;</span>
<span class="line-removed">102     _stencilAADataRef = other-&gt;_stencilAADataRef;</span>
103     if (other-&gt;_clipType == RECT_CLIP) {
104         _clipRect = other-&gt;_clipRect;
105     }
106 }
107 
108 - (void)reset {
109     _clipType = NO_CLIP;
<span class="line-removed">110     _stencilTextureRef = nil;</span>
<span class="line-removed">111     _stencilAADataRef = nil;</span>
112     _stencilMaskGenerationInProgress = JNI_FALSE;
113 }
114 
115 - (void)setClipRectX1:(jint)x1 Y1:(jint)y1 X2:(jint)x2 Y2:(jint)y2 {
116     if (_clipType == SHAPE_CLIP) {
<span class="line-modified">117         _stencilTextureRef = nil;</span>
<span class="line-removed">118         _stencilAADataRef = nil;</span>
119     }
120 
121     if (x1 &gt;= x2 || y1 &gt;= y2) {
122         J2dTraceLn4(J2D_TRACE_ERROR, &quot;MTLClip.setClipRect: invalid rect: x1=%d y1=%d x2=%d y2=%d&quot;, x1, y1, x2, y2);
123         _clipType = NO_CLIP;
124     }
125 
126     const jint width = x2 - x1;
127     const jint height = y2 - y1;
128 
129     J2dTraceLn4(J2D_TRACE_INFO, &quot;MTLClip.setClipRect: x=%d y=%d w=%d h=%d&quot;, x1, y1, width, height);
130 
131     _clipRect.x = (NSUInteger)((x1 &gt;= 0) ? x1 : 0);
132     _clipRect.y = (NSUInteger)((y1 &gt;= 0) ? y1 : 0);
133     _clipRect.width = (NSUInteger)((width &gt;= 0) ? width : 0);
134     _clipRect.height = (NSUInteger)((height &gt;= 0) ? height : 0);
135     _clipType = RECT_CLIP;
136 }
137 
138 - (void)beginShapeClip:(BMTLSDOps *)dstOps context:(MTLContext *)mtlc {
<span class="line-modified">139     _stencilMaskGenerationInProgress = JNI_TRUE;</span>
140 
141     if ((dstOps == NULL) || (dstOps-&gt;pStencilData == NULL) || (dstOps-&gt;pStencilTexture == NULL)) {
142         J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;MTLContext_beginShapeClip: stencil render target or stencil texture is NULL&quot;);
143         return;
144     }
145 
146     // Clear the stencil render buffer &amp; stencil texture
147     @autoreleasepool {
148         if (dstOps-&gt;width &lt;= 0 || dstOps-&gt;height &lt;= 0) {
149           return;
150         }
151 
152         NSUInteger width = (NSUInteger)dstOps-&gt;width;
153         NSUInteger height = (NSUInteger)dstOps-&gt;height;
154         NSUInteger size = width*height;
155         id &lt;MTLBuffer&gt; buff = [mtlc.device newBufferWithLength:size*4 options:MTLResourceStorageModePrivate];
156         id&lt;MTLCommandBuffer&gt; commandBuf = [mtlc createBlitCommandBuffer];
157         id&lt;MTLBlitCommandEncoder&gt; blitEncoder = [commandBuf blitCommandEncoder];
158         [blitEncoder fillBuffer:buff range:NSMakeRange(0, size*4) value:0];
159 
160         MTLOrigin origin = MTLOriginMake(0, 0, 0);
161         MTLSize sourceSize = MTLSizeMake(width, height, 1);
162         [blitEncoder copyFromBuffer:buff
163                        sourceOffset:0
164                   sourceBytesPerRow:width
165                 sourceBytesPerImage:size
166                          sourceSize:sourceSize
167                           toTexture:dstOps-&gt;pStencilData
168                    destinationSlice:0
169                    destinationLevel:0
170                   destinationOrigin:origin];
<span class="line-removed">171 </span>
<span class="line-removed">172         [blitEncoder copyFromBuffer:buff</span>
<span class="line-removed">173                        sourceOffset:0</span>
<span class="line-removed">174                   sourceBytesPerRow:width*4</span>
<span class="line-removed">175                 sourceBytesPerImage:size*4</span>
<span class="line-removed">176                          sourceSize:sourceSize</span>
<span class="line-removed">177                           toTexture:dstOps-&gt;pAAStencilData</span>
<span class="line-removed">178                    destinationSlice:0</span>
<span class="line-removed">179                    destinationLevel:0</span>
<span class="line-removed">180                   destinationOrigin:origin];</span>
<span class="line-removed">181 </span>
<span class="line-removed">182         [blitEncoder copyFromBuffer:buff</span>
<span class="line-removed">183                        sourceOffset:0</span>
<span class="line-removed">184                   sourceBytesPerRow:width</span>
<span class="line-removed">185                 sourceBytesPerImage:size</span>
<span class="line-removed">186                          sourceSize:sourceSize</span>
<span class="line-removed">187                           toTexture:dstOps-&gt;pStencilTexture</span>
<span class="line-removed">188                    destinationSlice:0</span>
<span class="line-removed">189                    destinationLevel:0</span>
<span class="line-removed">190                   destinationOrigin:origin];</span>
<span class="line-removed">191 </span>
192         [blitEncoder endEncoding];
<span class="line-removed">193 </span>
194         [commandBuf commit];
195         [commandBuf waitUntilCompleted];
196 
197         [buff release];
198     }
199 }
200 
201 - (void)endShapeClip:(BMTLSDOps *)dstOps context:(MTLContext *)mtlc {
202 
203     if ((dstOps == NULL) || (dstOps-&gt;pStencilData == NULL) || (dstOps-&gt;pStencilTexture == NULL)) {
204         J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;MTLContext_endShapeClip: stencil render target or stencil texture is NULL&quot;);
205         return;
206     }
207 
208     // Complete the rendering to the stencil buffer ------------
209     [mtlc.encoderManager endEncoder];
210 
211     MTLCommandBufferWrapper* cbWrapper = [mtlc pullCommandBufferWrapper];
212 
213     id&lt;MTLCommandBuffer&gt; commandBuffer = [cbWrapper getCommandBuffer];
214     [commandBuffer addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; c) {
215         [cbWrapper release];
216     }];
217 
218     [commandBuffer commit];
219     [commandBuffer waitUntilCompleted];
220 
221     // Now the stencil data is ready, this needs to be used while rendering further
222     @autoreleasepool {
223         if (dstOps-&gt;width &gt; 0 &amp;&amp; dstOps-&gt;height &gt; 0) {
224             NSUInteger width = (NSUInteger)dstOps-&gt;width;
225             NSUInteger height = (NSUInteger)dstOps-&gt;height;
226             NSUInteger size = width*height;
227             NSUInteger sizeX4 = size*4;
228 
<span class="line-removed">229             id&lt;MTLBuffer&gt; buff = </span>
<span class="line-removed">230                 [mtlc.device newBufferWithLength:size </span>
<span class="line-removed">231                                          options:MTLResourceStorageModeShared];</span>
<span class="line-removed">232             id&lt;MTLBuffer&gt; aaBuff = </span>
<span class="line-removed">233                 [mtlc.device newBufferWithLength:sizeX4</span>
<span class="line-removed">234                                          options:MTLResourceStorageModeShared];</span>
<span class="line-removed">235 </span>
236             id&lt;MTLCommandBuffer&gt; cb = [mtlc createBlitCommandBuffer];
237             id&lt;MTLBlitCommandEncoder&gt; blitEncoder = [cb blitCommandEncoder];
238             MTLSize sourceSize = MTLSizeMake(width, height, 1);
239             MTLOrigin origin = MTLOriginMake(0, 0, 0);
240             [blitEncoder copyFromTexture:dstOps-&gt;pStencilData
241                              sourceSlice:0
242                              sourceLevel:0
243                             sourceOrigin:origin
244                               sourceSize:sourceSize
<span class="line-modified">245                                 toBuffer:buff</span>
246                        destinationOffset:0
247                   destinationBytesPerRow:width
248                 destinationBytesPerImage:size];
<span class="line-removed">249 </span>
<span class="line-removed">250             [blitEncoder copyFromBuffer:buff</span>
<span class="line-removed">251                            sourceOffset:0</span>
<span class="line-removed">252                       sourceBytesPerRow:width</span>
<span class="line-removed">253                     sourceBytesPerImage:size</span>
<span class="line-removed">254                              sourceSize:sourceSize</span>
<span class="line-removed">255                               toTexture:dstOps-&gt;pStencilTexture</span>
<span class="line-removed">256                        destinationSlice:0</span>
<span class="line-removed">257                        destinationLevel:0</span>
<span class="line-removed">258                       destinationOrigin:origin];</span>
<span class="line-removed">259 </span>
<span class="line-removed">260             [blitEncoder endEncoding];</span>
<span class="line-removed">261             [cb commit];</span>
<span class="line-removed">262             [cb waitUntilCompleted];</span>
<span class="line-removed">263 // TODO: Implement via compute shader</span>
<span class="line-removed">264             for (int i = 0; i &lt; width*height; i++) {</span>
<span class="line-removed">265                 unsigned char c =  ((unsigned char*)(buff.contents))[i];</span>
<span class="line-removed">266                 ((jint*)(aaBuff.contents))[i] = c + (c &lt;&lt; 8) + (c &lt;&lt; 16) + (c &lt;&lt; 24);</span>
<span class="line-removed">267             }</span>
<span class="line-removed">268 </span>
<span class="line-removed">269             cb = [mtlc createBlitCommandBuffer];</span>
<span class="line-removed">270             blitEncoder = [cb blitCommandEncoder];</span>
<span class="line-removed">271 </span>
<span class="line-removed">272             [blitEncoder copyFromBuffer:aaBuff</span>
<span class="line-removed">273                            sourceOffset:0</span>
<span class="line-removed">274                       sourceBytesPerRow:width*4</span>
<span class="line-removed">275                     sourceBytesPerImage:sizeX4</span>
<span class="line-removed">276                              sourceSize:sourceSize</span>
<span class="line-removed">277                               toTexture:dstOps-&gt;pAAStencilData</span>
<span class="line-removed">278                        destinationSlice:0</span>
<span class="line-removed">279                        destinationLevel:0</span>
<span class="line-removed">280                       destinationOrigin:origin];</span>
281             [blitEncoder endEncoding];
<span class="line-removed">282 </span>
283             [cb commit];
284             [cb waitUntilCompleted];
<span class="line-removed">285 </span>
<span class="line-removed">286             [buff release];</span>
<span class="line-removed">287             [aaBuff release];</span>
288         }
289     }
290 
291     _stencilMaskGenerationInProgress = JNI_FALSE;
<span class="line-modified">292     _stencilTextureRef = dstOps-&gt;pStencilTexture;</span>
<span class="line-modified">293     _stencilAADataRef = dstOps-&gt;pAAStencilData;</span>
294     _clipType = SHAPE_CLIP;


295 }
296 
297 - (void)setMaskGenerationPipelineState:(id&lt;MTLRenderCommandEncoder&gt;)encoder
298                   destWidth:(NSUInteger)dw
299                  destHeight:(NSUInteger)dh
300        pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage
301 {
302     initTemplatePipelineDescriptors();
303 
304     // A  PipelineState for rendering to a byte-buffered texture that will be used as a stencil
305     id &lt;MTLRenderPipelineState&gt; pipelineState = [pipelineStateStorage getPipelineState:templateStencilPipelineDesc
306                                                                          vertexShaderId:@&quot;vert_stencil&quot;
307                                                                        fragmentShaderId:@&quot;frag_stencil&quot;];
308     [encoder setRenderPipelineState:pipelineState];
309 
310     struct FrameUniforms uf; // color is ignored while writing to stencil buffer
311     memset(&amp;uf, 0, sizeof(uf));
312     [encoder setVertexBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
313 
314     _clipRect.x = 0;
</pre>
<hr />
<pre>
339         return;
340     }
341 
342     if (_clipType == SHAPE_CLIP) {
343         // Enable stencil test
344         [encoder setDepthStencilState:getStencilState(device)];
345         [encoder setStencilReferenceValue:0xFF];
346     }
347 }
348 
349 - (NSString *)getDescription __unused {
350     if (_clipType == NO_CLIP) {
351         return @&quot;NO_CLIP&quot;;
352     }
353     if (_clipType == RECT_CLIP) {
354         return [NSString stringWithFormat:@&quot;RECT_CLIP [%lu,%lu - %lux%lu]&quot;, _clipRect.x, _clipRect.y, _clipRect.width, _clipRect.height];
355     }
356     return [NSString stringWithFormat:@&quot;SHAPE_CLIP&quot;];
357 }
358 










































































359 @end
</pre>
</td>
<td>
<hr />
<pre>
 32         stencilDescriptor.frontFaceStencil.stencilCompareFunction = MTLCompareFunctionEqual;
 33         stencilDescriptor.frontFaceStencil.stencilFailureOperation = MTLStencilOperationKeep;
 34 
 35         // TODO : backFaceStencil can be set to nil if all primitives are drawn as front-facing primitives
 36         // currently, fill parallelogram uses back-facing primitive drawing - that needs to be changed.
 37         // Once that part is changed, set backFaceStencil to nil
 38         //stencilDescriptor.backFaceStencil = nil;
 39 
 40         stencilDescriptor.backFaceStencil.stencilCompareFunction = MTLCompareFunctionEqual;
 41         stencilDescriptor.backFaceStencil.stencilFailureOperation = MTLStencilOperationKeep;
 42 
 43         stencilState = [device newDepthStencilStateWithDescriptor:stencilDescriptor];
 44     }
 45 
 46     return stencilState;
 47 }
 48 
 49 @implementation MTLClip {
 50     jint _clipType;
 51     MTLScissorRect  _clipRect;
<span class="line-modified"> 52     MTLContext* _mtlc;</span>
<span class="line-modified"> 53     BMTLSDOps*  _dstOps;</span>
<span class="line-modified"> 54     BOOL _stencilMaskGenerationInProgress;</span>
<span class="line-modified"> 55     BOOL _clipReady;</span>
<span class="line-added"> 56     BOOL _aaClipReady;</span>
 57 }
 58 
 59 - (id)init {
 60     self = [super init];
 61     if (self) {
 62         _clipType = NO_CLIP;
<span class="line-modified"> 63         _mtlc = nil;</span>
<span class="line-modified"> 64         _dstOps = NULL;</span>
<span class="line-added"> 65         _stencilMaskGenerationInProgress = NO;</span>
<span class="line-added"> 66         _clipReady = NO;</span>
<span class="line-added"> 67         _aaClipReady = NO;</span>
 68     }
 69     return self;
 70 }
 71 
 72 - (BOOL)isEqual:(MTLClip *)other {
 73     if (self == other)
 74         return YES;
 75     if (_stencilMaskGenerationInProgress == JNI_TRUE)
 76         return other-&gt;_stencilMaskGenerationInProgress == JNI_TRUE;
 77     if (_clipType != other-&gt;_clipType)
 78         return NO;
 79     if (_clipType == NO_CLIP)
 80         return YES;
 81     if (_clipType == RECT_CLIP) {
 82         return _clipRect.x == other-&gt;_clipRect.x &amp;&amp; _clipRect.y == other-&gt;_clipRect.y
 83                &amp;&amp; _clipRect.width == other-&gt;_clipRect.width &amp;&amp; _clipRect.height == other-&gt;_clipRect.height;
 84     }
 85 
 86     // NOTE: can compare stencil-data pointers here
 87     return YES;
 88 }
 89 
 90 - (BOOL)isShape {
 91     return _clipType == SHAPE_CLIP;
 92 }
 93 
 94 - (BOOL)isRect __unused {
 95     return _clipType == RECT_CLIP;
 96 }
 97 
 98 - (const MTLScissorRect * _Nullable) getRect {
 99     return _clipType == RECT_CLIP ? &amp;_clipRect : NULL;
100 }
101 
102 - (void)copyFrom:(MTLClip *)other {
103     _clipType = other-&gt;_clipType;
104     _stencilMaskGenerationInProgress = other-&gt;_stencilMaskGenerationInProgress;
<span class="line-modified">105     _dstOps = other-&gt;_dstOps;</span>

106     if (other-&gt;_clipType == RECT_CLIP) {
107         _clipRect = other-&gt;_clipRect;
108     }
109 }
110 
111 - (void)reset {
112     _clipType = NO_CLIP;


113     _stencilMaskGenerationInProgress = JNI_FALSE;
114 }
115 
116 - (void)setClipRectX1:(jint)x1 Y1:(jint)y1 X2:(jint)x2 Y2:(jint)y2 {
117     if (_clipType == SHAPE_CLIP) {
<span class="line-modified">118         _dstOps = NULL;</span>

119     }
120 
121     if (x1 &gt;= x2 || y1 &gt;= y2) {
122         J2dTraceLn4(J2D_TRACE_ERROR, &quot;MTLClip.setClipRect: invalid rect: x1=%d y1=%d x2=%d y2=%d&quot;, x1, y1, x2, y2);
123         _clipType = NO_CLIP;
124     }
125 
126     const jint width = x2 - x1;
127     const jint height = y2 - y1;
128 
129     J2dTraceLn4(J2D_TRACE_INFO, &quot;MTLClip.setClipRect: x=%d y=%d w=%d h=%d&quot;, x1, y1, width, height);
130 
131     _clipRect.x = (NSUInteger)((x1 &gt;= 0) ? x1 : 0);
132     _clipRect.y = (NSUInteger)((y1 &gt;= 0) ? y1 : 0);
133     _clipRect.width = (NSUInteger)((width &gt;= 0) ? width : 0);
134     _clipRect.height = (NSUInteger)((height &gt;= 0) ? height : 0);
135     _clipType = RECT_CLIP;
136 }
137 
138 - (void)beginShapeClip:(BMTLSDOps *)dstOps context:(MTLContext *)mtlc {
<span class="line-modified">139     _stencilMaskGenerationInProgress = YES;</span>
140 
141     if ((dstOps == NULL) || (dstOps-&gt;pStencilData == NULL) || (dstOps-&gt;pStencilTexture == NULL)) {
142         J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;MTLContext_beginShapeClip: stencil render target or stencil texture is NULL&quot;);
143         return;
144     }
145 
146     // Clear the stencil render buffer &amp; stencil texture
147     @autoreleasepool {
148         if (dstOps-&gt;width &lt;= 0 || dstOps-&gt;height &lt;= 0) {
149           return;
150         }
151 
152         NSUInteger width = (NSUInteger)dstOps-&gt;width;
153         NSUInteger height = (NSUInteger)dstOps-&gt;height;
154         NSUInteger size = width*height;
155         id &lt;MTLBuffer&gt; buff = [mtlc.device newBufferWithLength:size*4 options:MTLResourceStorageModePrivate];
156         id&lt;MTLCommandBuffer&gt; commandBuf = [mtlc createBlitCommandBuffer];
157         id&lt;MTLBlitCommandEncoder&gt; blitEncoder = [commandBuf blitCommandEncoder];
158         [blitEncoder fillBuffer:buff range:NSMakeRange(0, size*4) value:0];
159 
160         MTLOrigin origin = MTLOriginMake(0, 0, 0);
161         MTLSize sourceSize = MTLSizeMake(width, height, 1);
162         [blitEncoder copyFromBuffer:buff
163                        sourceOffset:0
164                   sourceBytesPerRow:width
165                 sourceBytesPerImage:size
166                          sourceSize:sourceSize
167                           toTexture:dstOps-&gt;pStencilData
168                    destinationSlice:0
169                    destinationLevel:0
170                   destinationOrigin:origin];





















171         [blitEncoder endEncoding];

172         [commandBuf commit];
173         [commandBuf waitUntilCompleted];
174 
175         [buff release];
176     }
177 }
178 
179 - (void)endShapeClip:(BMTLSDOps *)dstOps context:(MTLContext *)mtlc {
180 
181     if ((dstOps == NULL) || (dstOps-&gt;pStencilData == NULL) || (dstOps-&gt;pStencilTexture == NULL)) {
182         J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;MTLContext_endShapeClip: stencil render target or stencil texture is NULL&quot;);
183         return;
184     }
185 
186     // Complete the rendering to the stencil buffer ------------
187     [mtlc.encoderManager endEncoder];
188 
189     MTLCommandBufferWrapper* cbWrapper = [mtlc pullCommandBufferWrapper];
190 
191     id&lt;MTLCommandBuffer&gt; commandBuffer = [cbWrapper getCommandBuffer];
192     [commandBuffer addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; c) {
193         [cbWrapper release];
194     }];
195 
196     [commandBuffer commit];
197     [commandBuffer waitUntilCompleted];
198 
199     // Now the stencil data is ready, this needs to be used while rendering further
200     @autoreleasepool {
201         if (dstOps-&gt;width &gt; 0 &amp;&amp; dstOps-&gt;height &gt; 0) {
202             NSUInteger width = (NSUInteger)dstOps-&gt;width;
203             NSUInteger height = (NSUInteger)dstOps-&gt;height;
204             NSUInteger size = width*height;
205             NSUInteger sizeX4 = size*4;
206 







207             id&lt;MTLCommandBuffer&gt; cb = [mtlc createBlitCommandBuffer];
208             id&lt;MTLBlitCommandEncoder&gt; blitEncoder = [cb blitCommandEncoder];
209             MTLSize sourceSize = MTLSizeMake(width, height, 1);
210             MTLOrigin origin = MTLOriginMake(0, 0, 0);
211             [blitEncoder copyFromTexture:dstOps-&gt;pStencilData
212                              sourceSlice:0
213                              sourceLevel:0
214                             sourceOrigin:origin
215                               sourceSize:sourceSize
<span class="line-modified">216                                 toBuffer:dstOps-&gt;pStencilDataBuf</span>
217                        destinationOffset:0
218                   destinationBytesPerRow:width
219                 destinationBytesPerImage:size];
































220             [blitEncoder endEncoding];

221             [cb commit];
222             [cb waitUntilCompleted];



223         }
224     }
225 
226     _stencilMaskGenerationInProgress = JNI_FALSE;
<span class="line-modified">227     _mtlc = mtlc;</span>
<span class="line-modified">228     _dstOps = dstOps;</span>
229     _clipType = SHAPE_CLIP;
<span class="line-added">230     _clipReady = NO;</span>
<span class="line-added">231     _aaClipReady = NO;</span>
232 }
233 
234 - (void)setMaskGenerationPipelineState:(id&lt;MTLRenderCommandEncoder&gt;)encoder
235                   destWidth:(NSUInteger)dw
236                  destHeight:(NSUInteger)dh
237        pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage
238 {
239     initTemplatePipelineDescriptors();
240 
241     // A  PipelineState for rendering to a byte-buffered texture that will be used as a stencil
242     id &lt;MTLRenderPipelineState&gt; pipelineState = [pipelineStateStorage getPipelineState:templateStencilPipelineDesc
243                                                                          vertexShaderId:@&quot;vert_stencil&quot;
244                                                                        fragmentShaderId:@&quot;frag_stencil&quot;];
245     [encoder setRenderPipelineState:pipelineState];
246 
247     struct FrameUniforms uf; // color is ignored while writing to stencil buffer
248     memset(&amp;uf, 0, sizeof(uf));
249     [encoder setVertexBytes:&amp;uf length:sizeof(uf) atIndex:FrameUniformBuffer];
250 
251     _clipRect.x = 0;
</pre>
<hr />
<pre>
276         return;
277     }
278 
279     if (_clipType == SHAPE_CLIP) {
280         // Enable stencil test
281         [encoder setDepthStencilState:getStencilState(device)];
282         [encoder setStencilReferenceValue:0xFF];
283     }
284 }
285 
286 - (NSString *)getDescription __unused {
287     if (_clipType == NO_CLIP) {
288         return @&quot;NO_CLIP&quot;;
289     }
290     if (_clipType == RECT_CLIP) {
291         return [NSString stringWithFormat:@&quot;RECT_CLIP [%lu,%lu - %lux%lu]&quot;, _clipRect.x, _clipRect.y, _clipRect.width, _clipRect.height];
292     }
293     return [NSString stringWithFormat:@&quot;SHAPE_CLIP&quot;];
294 }
295 
<span class="line-added">296 - (id&lt;MTLTexture&gt;) stencilTextureRef {</span>
<span class="line-added">297     if (_dstOps == NULL) return nil;</span>
<span class="line-added">298 </span>
<span class="line-added">299     id &lt;MTLTexture&gt; _stencilTextureRef = _dstOps-&gt;pStencilTexture;</span>
<span class="line-added">300 </span>
<span class="line-added">301     if (!_clipReady) {</span>
<span class="line-added">302         @autoreleasepool {</span>
<span class="line-added">303             id &lt;MTLCommandBuffer&gt; cb = [_mtlc createBlitCommandBuffer];</span>
<span class="line-added">304             id &lt;MTLBlitCommandEncoder&gt; blitEncoder = [cb blitCommandEncoder];</span>
<span class="line-added">305             id &lt;MTLBuffer&gt; _stencilDataBufRef = _dstOps-&gt;pStencilDataBuf;</span>
<span class="line-added">306 </span>
<span class="line-added">307             NSUInteger width = _stencilTextureRef.width;</span>
<span class="line-added">308             NSUInteger height = _stencilTextureRef.height;</span>
<span class="line-added">309 </span>
<span class="line-added">310             [blitEncoder copyFromBuffer:_stencilDataBufRef</span>
<span class="line-added">311                            sourceOffset:0</span>
<span class="line-added">312                       sourceBytesPerRow:width</span>
<span class="line-added">313                     sourceBytesPerImage:width * height</span>
<span class="line-added">314                              sourceSize:MTLSizeMake(width, height, 1)</span>
<span class="line-added">315                               toTexture:_stencilTextureRef</span>
<span class="line-added">316                        destinationSlice:0</span>
<span class="line-added">317                        destinationLevel:0</span>
<span class="line-added">318                       destinationOrigin:MTLOriginMake(0, 0, 0)];</span>
<span class="line-added">319             [blitEncoder endEncoding];</span>
<span class="line-added">320             [cb commit];</span>
<span class="line-added">321             [cb waitUntilCompleted];</span>
<span class="line-added">322             _clipReady = YES;</span>
<span class="line-added">323         }</span>
<span class="line-added">324     }</span>
<span class="line-added">325     return _stencilTextureRef;</span>
<span class="line-added">326 }</span>
<span class="line-added">327 </span>
<span class="line-added">328 - (id&lt;MTLTexture&gt;) stencilAADataRef {</span>
<span class="line-added">329     if (_dstOps == NULL) return nil;</span>
<span class="line-added">330 </span>
<span class="line-added">331     id &lt;MTLTexture&gt; _stencilAADataRef = _dstOps-&gt;pAAStencilData;</span>
<span class="line-added">332 </span>
<span class="line-added">333     if (!_aaClipReady) {</span>
<span class="line-added">334 </span>
<span class="line-added">335         @autoreleasepool {</span>
<span class="line-added">336 </span>
<span class="line-added">337             id &lt;MTLCommandBuffer&gt; cb = [_mtlc createBlitCommandBuffer];</span>
<span class="line-added">338             id &lt;MTLBlitCommandEncoder&gt; blitEncoder = [cb blitCommandEncoder];</span>
<span class="line-added">339             id &lt;MTLBuffer&gt; _stencilDataBufRef = _dstOps-&gt;pStencilDataBuf;</span>
<span class="line-added">340             id &lt;MTLBuffer&gt; _stencilAADataBufRef = _dstOps-&gt;pAAStencilDataBuf;</span>
<span class="line-added">341             NSUInteger width = _stencilAADataRef.width;</span>
<span class="line-added">342             NSUInteger height = _stencilAADataRef.height;</span>
<span class="line-added">343             NSUInteger size = width * height;</span>
<span class="line-added">344 </span>
<span class="line-added">345             for (int i = 0; i &lt; size; i++) {</span>
<span class="line-added">346                 unsigned char c = ((unsigned char *) (((id &lt;MTLBuffer&gt;) (_stencilDataBufRef)).contents))[i];</span>
<span class="line-added">347                 ((jint *) (_stencilAADataBufRef.contents))[i] = c + (c &lt;&lt; 8) + (c &lt;&lt; 16) + (c &lt;&lt; 24);</span>
<span class="line-added">348             }</span>
<span class="line-added">349 </span>
<span class="line-added">350             [blitEncoder copyFromBuffer:_stencilAADataBufRef</span>
<span class="line-added">351                            sourceOffset:0</span>
<span class="line-added">352                       sourceBytesPerRow:width * 4</span>
<span class="line-added">353                     sourceBytesPerImage:size * 4</span>
<span class="line-added">354                              sourceSize:MTLSizeMake(width, height, 1)</span>
<span class="line-added">355                               toTexture:_stencilAADataRef</span>
<span class="line-added">356                        destinationSlice:0</span>
<span class="line-added">357                        destinationLevel:0</span>
<span class="line-added">358                       destinationOrigin:MTLOriginMake(0, 0, 0)];</span>
<span class="line-added">359             [blitEncoder endEncoding];</span>
<span class="line-added">360 </span>
<span class="line-added">361             [cb commit];</span>
<span class="line-added">362             [cb waitUntilCompleted];</span>
<span class="line-added">363             _aaClipReady = YES;</span>
<span class="line-added">364         }</span>
<span class="line-added">365     }</span>
<span class="line-added">366     return _stencilAADataRef;</span>
<span class="line-added">367 }</span>
<span class="line-added">368 </span>
<span class="line-added">369 </span>
370 @end
</pre>
</td>
</tr>
</table>
<center><a href="MTLClip.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MTLSurfaceData.m.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
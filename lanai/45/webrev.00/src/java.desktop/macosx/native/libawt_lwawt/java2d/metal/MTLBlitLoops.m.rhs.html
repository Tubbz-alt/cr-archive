<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLBlitLoops.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef HEADLESS
 27 
 28 #include &lt;jni.h&gt;
 29 #include &lt;jlong.h&gt;
 30 
 31 #include &quot;SurfaceData.h&quot;
 32 #include &quot;MTLBlitLoops.h&quot;
 33 #include &quot;MTLRenderQueue.h&quot;
 34 #include &quot;MTLSurfaceData.h&quot;
 35 #include &quot;MTLUtils.h&quot;
 36 #include &quot;GraphicsPrimitiveMgr.h&quot;
 37 
 38 #include &lt;stdlib.h&gt; // malloc
 39 #include &lt;string.h&gt; // memcpy
 40 #include &quot;IntArgbPre.h&quot;
 41 
 42 #import &lt;Accelerate/Accelerate.h&gt;
 43 
 44 #ifdef DEBUG
 45 #define TRACE_ISOBLIT
 46 #define TRACE_BLIT
 47 #endif //DEBUG
 48 //#define DEBUG_ISOBLIT
 49 //#define DEBUG_BLIT
 50 
 51 typedef struct {
 52     MTLPixelFormat   format;
 53     jboolean hasAlpha;
 54     jboolean isPremult;
 55     const uint8_t * permuteMap;
 56 } MTLRasterFormatInfo;
 57 
 58 // 0 denotes the alpha channel, 1 the red channel, 2 the green channel, and 3 the blue channel.
 59 const uint8_t permuteMap_rgbx[4] = { 1, 2, 3, 0 };
 60 const uint8_t permuteMap_bgrx[4] = { 3, 2, 1, 0 };
 61 
 62 static uint8_t revertPerm(const uint8_t * perm, uint8_t pos) {
 63     for (int c = 0; c &lt; 4; ++c) {
 64         if (perm[c] == pos)
 65             return c;
 66     }
 67     return -1;
 68 }
 69 
 70 #define uint2swizzle(channel) (channel == 0 ? MTLTextureSwizzleAlpha : (channel == 1 ? MTLTextureSwizzleRed : (channel == 2 ? MTLTextureSwizzleGreen : (channel == 3 ? MTLTextureSwizzleBlue : MTLTextureSwizzleZero))))
 71 
 72 /**
 73  * This table contains the &quot;pixel formats&quot; for all system memory surfaces
 74  * that Metal is capable of handling, indexed by the &quot;PF_&quot; constants defined
 75  * in MTLLSurfaceData.java.  These pixel formats contain information that is
 76  * passed to Metal when copying from a system memory (&quot;Sw&quot;) surface to
 77  * an Metal surface
 78  */
 79 MTLRasterFormatInfo RasterFormatInfos[] = {
 80         { MTLPixelFormatBGRA8Unorm, 1, 0, NULL }, /* 0 - IntArgb      */ // Argb (in java notation)
 81         { MTLPixelFormatBGRA8Unorm, 1, 1, NULL }, /* 1 - IntArgbPre   */
 82         { MTLPixelFormatBGRA8Unorm, 0, 1, NULL }, /* 2 - IntRgb       */ // xrgb
 83         { MTLPixelFormatBGRA8Unorm, 0, 1, permuteMap_rgbx }, /* 3 - IntRgbx      */
 84         { MTLPixelFormatRGBA8Unorm, 0, 1, NULL }, /* 4 - IntBgr       */ // xbgr
 85         { MTLPixelFormatBGRA8Unorm, 0, 1, permuteMap_bgrx }, /* 5 - IntBgrx      */
 86 
 87 //        TODO: support 2-byte formats
 88 //        { GL_BGRA, GL_UNSIGNED_SHORT_1_5_5_5_REV,
 89 //                2, 0, 1,                                     }, /* 7 - Ushort555Rgb */
 90 //        { GL_RGBA, GL_UNSIGNED_SHORT_5_5_5_1,
 91 //                2, 0, 1,                                     }, /* 8 - Ushort555Rgbx*/
 92 //        { GL_LUMINANCE, GL_UNSIGNED_BYTE,
 93 //                1, 0, 1,                                     }, /* 9 - ByteGray     */
 94 //        { GL_LUMINANCE, GL_UNSIGNED_SHORT,
 95 //                2, 0, 1,                                     }, /*10 - UshortGray   */
 96 //        { GL_BGR,  GL_UNSIGNED_BYTE,
 97 //                1, 0, 1,                                     }, /*11 - ThreeByteBgr */
 98 };
 99 
100 extern void J2dTraceImpl(int level, jboolean cr, const char *string, ...);
101 
102 void fillTxQuad(
103         struct TxtVertex * txQuadVerts,
104         jint sx1, jint sy1, jint sx2, jint sy2, jint sw, jint sh,
105         jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2, jdouble dw, jdouble dh
106 ) {
107     const float nsx1 = sx1/(float)sw;
108     const float nsy1 = sy1/(float)sh;
109     const float nsx2 = sx2/(float)sw;
110     const float nsy2 = sy2/(float)sh;
111 
112     txQuadVerts[0].position[0] = dx1;
113     txQuadVerts[0].position[1] = dy1;
114     txQuadVerts[0].txtpos[0]   = nsx1;
115     txQuadVerts[0].txtpos[1]   = nsy1;
116 
117     txQuadVerts[1].position[0] = dx2;
118     txQuadVerts[1].position[1] = dy1;
119     txQuadVerts[1].txtpos[0]   = nsx2;
120     txQuadVerts[1].txtpos[1]   = nsy1;
121 
122     txQuadVerts[2].position[0] = dx2;
123     txQuadVerts[2].position[1] = dy2;
124     txQuadVerts[2].txtpos[0]   = nsx2;
125     txQuadVerts[2].txtpos[1]   = nsy2;
126 
127     txQuadVerts[3].position[0] = dx2;
128     txQuadVerts[3].position[1] = dy2;
129     txQuadVerts[3].txtpos[0]   = nsx2;
130     txQuadVerts[3].txtpos[1]   = nsy2;
131 
132     txQuadVerts[4].position[0] = dx1;
133     txQuadVerts[4].position[1] = dy2;
134     txQuadVerts[4].txtpos[0]   = nsx1;
135     txQuadVerts[4].txtpos[1]   = nsy2;
136 
137     txQuadVerts[5].position[0] = dx1;
138     txQuadVerts[5].position[1] = dy1;
139     txQuadVerts[5].txtpos[0]   = nsx1;
140     txQuadVerts[5].txtpos[1]   = nsy1;
141 }
142 
143 //#define TRACE_drawTex2Tex
144 
145 void drawTex2Tex(MTLContext *mtlc,
146                         id&lt;MTLTexture&gt; src, id&lt;MTLTexture&gt; dst,
147                         jboolean isSrcOpaque, jboolean isDstOpaque, jint hint,
148                         jint sx1, jint sy1, jint sx2, jint sy2,
149                         jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)
150 {
151 #ifdef TRACE_drawTex2Tex
152     J2dRlsTraceLn2(J2D_TRACE_VERBOSE, &quot;drawTex2Tex: src tex=%p, dst tex=%p&quot;, src, dst);
153     J2dRlsTraceLn4(J2D_TRACE_VERBOSE, &quot;  sw=%d sh=%d dw=%d dh=%d&quot;, src.width, src.height, dst.width, dst.height);
154     J2dRlsTraceLn4(J2D_TRACE_VERBOSE, &quot;  sx1=%d sy1=%d sx2=%d sy2=%d&quot;, sx1, sy1, sx2, sy2);
155     J2dRlsTraceLn4(J2D_TRACE_VERBOSE, &quot;  dx1=%f dy1=%f dx2=%f dy2=%f&quot;, dx1, dy1, dx2, dy2);
156 #endif //TRACE_drawTex2Tex
157 
158     id&lt;MTLRenderCommandEncoder&gt; encoder = [mtlc.encoderManager getTextureEncoder:dst
159                                                                      isSrcOpaque:isSrcOpaque
160                                                                      isDstOpaque:isDstOpaque
161                                                                    interpolation:hint
162     ];
163 
164     struct TxtVertex quadTxVerticesBuffer[6];
165     fillTxQuad(quadTxVerticesBuffer, sx1, sy1, sx2, sy2, src.width, src.height, dx1, dy1, dx2, dy2, dst.width, dst.height);
166 
167     [encoder setVertexBytes:quadTxVerticesBuffer length:sizeof(quadTxVerticesBuffer) atIndex:MeshVertexBuffer];
168     [encoder setFragmentTexture:src atIndex: 0];
169     [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];
170 }
171 
172 static
173 id&lt;MTLTexture&gt; replaceTextureRegion(id&lt;MTLTexture&gt; dest, const SurfaceDataRasInfo * srcInfo, const MTLRasterFormatInfo * rfi, int dx1, int dy1, int dx2, int dy2) {
174     const int dw = dx2 - dx1;
175     const int dh = dy2 - dy1;
176 
177     const void * raster = srcInfo-&gt;rasBase;
178     id&lt;MTLTexture&gt; result = nil;
179     if (rfi-&gt;permuteMap != NULL) {
180 #if defined(__MAC_10_15) &amp;&amp; __MAC_OS_X_VERSION_MAX_ALLOWED &gt;= __MAC_10_15
181         if (@available(macOS 10.15, *)) {
182             @autoreleasepool {
183                 const uint8_t swzRed = revertPerm(rfi-&gt;permuteMap, 1);
184                 const uint8_t swzGreen = revertPerm(rfi-&gt;permuteMap, 2);
185                 const uint8_t swzBlue = revertPerm(rfi-&gt;permuteMap, 3);
186                 const uint8_t swzAlpha = revertPerm(rfi-&gt;permuteMap, 0);
187                 MTLTextureSwizzleChannels swizzle = MTLTextureSwizzleChannelsMake(
188                         uint2swizzle(swzRed),
189                         uint2swizzle(swzGreen),
190                         uint2swizzle(swzBlue),
191                         rfi-&gt;hasAlpha ? uint2swizzle(swzAlpha) : MTLTextureSwizzleOne
192                 );
193                 result = [dest
194                         newTextureViewWithPixelFormat:MTLPixelFormatBGRA8Unorm
195                         textureType:MTLTextureType2D
196                         levels:NSMakeRange(0, 1) slices:NSMakeRange(0, 1)
197                         swizzle:swizzle];
198                 J2dTraceLn5(J2D_TRACE_VERBOSE, &quot;replaceTextureRegion [use swizzle for pooled]: %d, %d, %d, %d, hasA=%d&quot;,
199                             swizzle.red, swizzle.green, swizzle.blue, swizzle.alpha, rfi-&gt;hasAlpha);
200             }
201         } else
202 #endif // __MAC_10_15 &amp;&amp; __MAC_OS_X_VERSION_MAX_ALLOWED &gt;= __MAC_10_15
203         {
204             // perform raster conversion
205             // invoked only from rq-thread, so use static buffers
206             // but it&#39;s better to use thread-local buffers (or special buffer manager)
207             const int destRasterSize = dw*dh*4;
208 
209             static int bufferSize = 0;
210             static void * buffer = NULL;
211             if (buffer == NULL || bufferSize &lt; destRasterSize) {
212                 bufferSize = destRasterSize;
213                 buffer = realloc(buffer, bufferSize);
214             }
215             if (buffer == NULL) {
216                 J2dTraceLn1(J2D_TRACE_ERROR, &quot;replaceTextureRegion: can&#39;t alloc buffer for raster conversion, size=%d&quot;, bufferSize);
217                 bufferSize = 0;
218                 return nil;
219             }
220             vImage_Buffer srcBuf;
221             srcBuf.height = dh;
222             srcBuf.width = dw;
223             srcBuf.rowBytes = srcInfo-&gt;scanStride;
224             srcBuf.data = srcInfo-&gt;rasBase;
225 
226             vImage_Buffer destBuf;
227             destBuf.height = dh;
228             destBuf.width = dw;
229             destBuf.rowBytes = dw*4;
230             destBuf.data = buffer;
231 
232             vImagePermuteChannels_ARGB8888(&amp;srcBuf, &amp;destBuf, rfi-&gt;permuteMap, kvImageNoFlags);
233             raster = buffer;
234 
235             J2dTraceLn5(J2D_TRACE_VERBOSE, &quot;replaceTextureRegion [use conversion]: %d, %d, %d, %d, hasA=%d&quot;,
236                         rfi-&gt;permuteMap[0], rfi-&gt;permuteMap[1], rfi-&gt;permuteMap[2], rfi-&gt;permuteMap[3], rfi-&gt;hasAlpha);
237         }
238     }
239 
240     MTLRegion region = MTLRegionMake2D(dx1, dy1, dw, dh);
241     if (result != nil)
242         dest = result;
243     [dest replaceRegion:region mipmapLevel:0 withBytes:raster bytesPerRow:srcInfo-&gt;scanStride];
244     return result;
245 }
246 
247 /**
248  * Inner loop used for copying a source system memory (&quot;Sw&quot;) surface to a
249  * destination MTL &quot;Surface&quot;.  This method is invoked from
250  * MTLBlitLoops_Blit().
251  */
252 
253 static void
254 MTLBlitSwToTextureViaPooledTexture(
255         MTLContext *mtlc, SurfaceDataRasInfo *srcInfo, BMTLSDOps * bmtlsdOps,
256         MTLRasterFormatInfo * rfi, jboolean useBlitEncoder, jint hint,
257         jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)
258 {
259     const int sw = srcInfo-&gt;bounds.x2 - srcInfo-&gt;bounds.x1;
260     const int sh = srcInfo-&gt;bounds.y2 - srcInfo-&gt;bounds.y1;
261     id&lt;MTLTexture&gt; dest = bmtlsdOps-&gt;pTexture;
262 
263     MTLPooledTextureHandle * texHandle = [mtlc.texturePool getTexture:sw height:sh format:rfi-&gt;format];
264     if (texHandle == nil) {
265         J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBlitSwToTextureViaPooledTexture: can&#39;t obtain temporary texture object from pool&quot;);
266         return;
267     }
268     [[mtlc getCommandBufferWrapper] registerPooledTexture:texHandle];
269     [texHandle release];
270 
271     id&lt;MTLTexture&gt; texBuff = texHandle.texture;
272     id&lt;MTLTexture&gt; swizzledTexture = replaceTextureRegion(texBuff, srcInfo, rfi, 0, 0, sw, sh);
273     if (useBlitEncoder) {
274         id &lt;MTLBlitCommandEncoder&gt; blitEncoder = [mtlc.encoderManager createBlitEncoder];
275         [blitEncoder copyFromTexture:swizzledTexture != nil ? swizzledTexture : texBuff
276                          sourceSlice:0
277                          sourceLevel:0
278                         sourceOrigin:MTLOriginMake(0, 0, 0)
279                           sourceSize:MTLSizeMake(sw, sh, 1)
280                            toTexture:dest
281                     destinationSlice:0
282                     destinationLevel:0
283                    destinationOrigin:MTLOriginMake(dx1, dy1, 0)];
284         [blitEncoder endEncoding];
285     } else {
286         drawTex2Tex(mtlc, swizzledTexture != nil ? swizzledTexture : texBuff, dest, !rfi-&gt;hasAlpha, bmtlsdOps-&gt;isOpaque, hint,
287                     0, 0, sw, sh, dx1, dy1, dx2, dy2);
288     }
289 
290     if (swizzledTexture != nil) {
291         [swizzledTexture release];
292     }
293 }
294 
295 static
296 jboolean isIntegerAndUnscaled(
297         jint sx1, jint sy1, jint sx2, jint sy2,
298         jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2
299 ) {
300     const jdouble epsilon = 0.0001f;
301 
302     // check that dx1,dy1 is integer
303     if (fabs(dx1 - (int)dx1) &gt; epsilon || fabs(dy1 - (int)dy1) &gt; epsilon) {
304         return JNI_FALSE;
305     }
306     // check that destSize equals srcSize
307     if (fabs(dx2 - dx1 - sx2 + sx1) &gt; epsilon || fabs(dy2 - dy1 - sy2 + sy1) &gt; epsilon) {
308         return JNI_FALSE;
309     }
310     return JNI_TRUE;
311 }
312 
313 static
314 jboolean clipDestCoords(
315         jdouble *dx1, jdouble *dy1, jdouble *dx2, jdouble *dy2,
316         jint *sx1, jint *sy1, jint *sx2, jint *sy2,
317         jint destW, jint destH, const MTLScissorRect * clipRect
318 ) {
319     // Trim destination rect by clip-rect (or dest.bounds)
320     const jint sw    = *sx2 - *sx1;
321     const jint sh    = *sy2 - *sy1;
322     const jdouble dw = *dx2 - *dx1;
323     const jdouble dh = *dy2 - *dy1;
324 
325     jdouble dcx1 = 0;
326     jdouble dcx2 = destW;
327     jdouble dcy1 = 0;
328     jdouble dcy2 = destH;
329     if (clipRect != NULL) {
330         if (clipRect-&gt;x &gt; dcx1)
331             dcx1 = clipRect-&gt;x;
332         const int maxX = clipRect-&gt;x + clipRect-&gt;width;
333         if (dcx2 &gt; maxX)
334             dcx2 = maxX;
335         if (clipRect-&gt;y &gt; dcy1)
336             dcy1 = clipRect-&gt;y;
337         const int maxY = clipRect-&gt;y + clipRect-&gt;height;
338         if (dcy2 &gt; maxY)
339             dcy2 = maxY;
340 
341         if (dcx1 &gt;= dcx2) {
342             J2dTraceLn2(J2D_TRACE_ERROR, &quot;\tclipDestCoords: dcx1=%1.2f, dcx2=%1.2f&quot;, dcx1, dcx2);
343             dcx1 = dcx2;
344         }
345         if (dcy1 &gt;= dcy2) {
346             J2dTraceLn2(J2D_TRACE_ERROR, &quot;\tclipDestCoords: dcy1=%1.2f, dcy2=%1.2f&quot;, dcy1, dcy2);
347             dcy1 = dcy2;
348         }
349     }
350     if (*dx2 &lt;= dcx1 || *dx1 &gt;= dcx2 || *dy2 &lt;= dcy1 || *dy1 &gt;= dcy2) {
351         J2dTraceLn(J2D_TRACE_INFO, &quot;\tclipDestCoords: dest rect doesn&#39;t intersect clip area&quot;);
352         J2dTraceLn4(J2D_TRACE_INFO, &quot;\tdx2=%1.4f &lt;= dcx1=%1.4f || *dx1=%1.4f &gt;= dcx2=%1.4f&quot;, *dx2, dcx1, *dx1, dcx2);
353         J2dTraceLn4(J2D_TRACE_INFO, &quot;\t*dy2=%1.4f &lt;= dcy1=%1.4f || *dy1=%1.4f &gt;= dcy2=%1.4f&quot;, *dy2, dcy1, *dy1, dcy2);
354         return JNI_FALSE;
355     }
356     if (*dx1 &lt; dcx1) {
357         J2dTraceLn2(J2D_TRACE_VERBOSE, &quot;\t\tdx1=%1.2f, will be clipped to %1.2f&quot;, *dx1, dcx1);
358         *sx1 += (jint)((dcx1 - *dx1) * (sw/dw));
359         *dx1 = dcx1;
360     }
361     if (*dx2 &gt; dcx2) {
362         J2dTraceLn2(J2D_TRACE_VERBOSE, &quot;\t\tdx2=%1.2f, will be clipped to %1.2f&quot;, *dx2, dcx2);
363         *sx2 -= (jint)((*dx2 - dcx2) * (sw/dw));
364         *dx2 = dcx2;
365     }
366     if (*dy1 &lt; dcy1) {
367         J2dTraceLn2(J2D_TRACE_VERBOSE, &quot;\t\tdy1=%1.2f, will be clipped to %1.2f&quot;, *dy1, dcy1);
368         *sy1 += (jint)((dcy1 - *dy1) * (sh/dh));
369         *dy1 = dcy1;
370     }
371     if (*dy2 &gt; dcy2) {
372         J2dTraceLn2(J2D_TRACE_VERBOSE, &quot;\t\tdy2=%1.2f, will be clipped to %1.2f&quot;, *dy2, dcy2);
373         *sy2 -= (jint)((*dy2 - dcy2) * (sh/dh));
374         *dy2 = dcy2;
375     }
376     return JNI_TRUE;
377 }
378 
379 /**
380  * General blit method for copying a native MTL surface to another MTL &quot;Surface&quot;.
381  * Parameter texture == true forces to use &#39;texture&#39; codepath (dest coordinates will always be integers).
382  * Parameter xform == true only when AffineTransform is used (invoked only from TransformBlit, dest coordinates will always be integers).
383  */
384 void
385 MTLBlitLoops_IsoBlit(JNIEnv *env,
386                      MTLContext *mtlc, jlong pSrcOps, jlong pDstOps,
387                      jboolean xform, jint hint, jboolean texture,
388                      jint sx1, jint sy1, jint sx2, jint sy2,
389                      jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)
390 {
391     BMTLSDOps *srcOps = (BMTLSDOps *)jlong_to_ptr(pSrcOps);
392     BMTLSDOps *dstOps = (BMTLSDOps *)jlong_to_ptr(pDstOps);
393 
394     RETURN_IF_NULL(mtlc);
395     RETURN_IF_NULL(srcOps);
396     RETURN_IF_NULL(dstOps);
397 
398     id&lt;MTLTexture&gt; srcTex = srcOps-&gt;pTexture;
399     id&lt;MTLTexture&gt; dstTex = dstOps-&gt;pTexture;
400     if (srcTex == nil || srcTex == nil) {
401         J2dTraceLn2(J2D_TRACE_ERROR, &quot;MTLBlitLoops_IsoBlit: surface is null (stex=%p, dtex=%p)&quot;, srcTex, dstTex);
402         return;
403     }
404 
405     const jint sw    = sx2 - sx1;
406     const jint sh    = sy2 - sy1;
407     const jdouble dw = dx2 - dx1;
408     const jdouble dh = dy2 - dy1;
409 
410     if (sw &lt;= 0 || sh &lt;= 0 || dw &lt;= 0 || dh &lt;= 0) {
411         J2dTraceLn4(J2D_TRACE_WARNING, &quot;MTLBlitLoops_IsoBlit: invalid dimensions: sw=%d, sh%d, dw=%d, dh=%d&quot;, sw, sh, dw, dh);
412         return;
413     }
414 
415 #ifdef DEBUG_ISOBLIT
416     if ((xform == JNI_TRUE) != (mtlc.useTransform == JNI_TRUE)) {
417         J2dTraceImpl(J2D_TRACE_ERROR, JNI_TRUE,
418                 &quot;MTLBlitLoops_IsoBlit state error: xform=%d, mtlc.useTransform=%d, texture=%d&quot;,
419                 xform, mtlc.useTransform, texture);
420     }
421 #endif // DEBUG_ISOBLIT
422 
423     clipDestCoords(
424             &amp;dx1, &amp;dy1, &amp;dx2, &amp;dy2,
425             &amp;sx1, &amp;sy1, &amp;sx2, &amp;sy2,
426             dstTex.width, dstTex.height, texture ? NULL : [mtlc.clip getRect]
427     );
428 
429     SurfaceDataBounds bounds;
430     bounds.x1 = sx1;
431     bounds.y1 = sy1;
432     bounds.x2 = sx2;
433     bounds.y2 = sy2;
434     SurfaceData_IntersectBoundsXYXY(&amp;bounds, 0, 0, srcOps-&gt;width, srcOps-&gt;height);
435 
436     if (bounds.x2 &lt;= bounds.x1 || bounds.y2 &lt;= bounds.y1) {
437         J2dTraceLn(J2D_TRACE_VERBOSE, &quot;MTLBlitLoops_IsoBlit: source rectangle doesn&#39;t intersect with source surface bounds&quot;);
438         J2dTraceLn6(J2D_TRACE_VERBOSE, &quot;  sx1=%d sy1=%d sx2=%d sy2=%d sw=%d sh=%d&quot;, sx1, sy1, sx2, sy2, srcOps-&gt;width, srcOps-&gt;height);
439         J2dTraceLn4(J2D_TRACE_VERBOSE, &quot;  dx1=%f dy1=%f dx2=%f dy2=%f&quot;, dx1, dy1, dx2, dy2);
440         return;
441     }
442 
443     if (bounds.x1 != sx1) {
444         dx1 += (bounds.x1 - sx1) * (dw / sw);
445         sx1 = bounds.x1;
446     }
447     if (bounds.y1 != sy1) {
448         dy1 += (bounds.y1 - sy1) * (dh / sh);
449         sy1 = bounds.y1;
450     }
451     if (bounds.x2 != sx2) {
452         dx2 += (bounds.x2 - sx2) * (dw / sw);
453         sx2 = bounds.x2;
454     }
455     if (bounds.y2 != sy2) {
456         dy2 += (bounds.y2 - sy2) * (dh / sh);
457         sy2 = bounds.y2;
458     }
459 
460 #ifdef TRACE_ISOBLIT
461     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_FALSE,
462          &quot;MTLBlitLoops_IsoBlit [tx=%d, xf=%d, AC=%s]: src=%s, dst=%s | (%d, %d, %d, %d)-&gt;(%1.2f, %1.2f, %1.2f, %1.2f)&quot;,
463          texture, xform, [mtlc getCompositeDescription].cString,
464          getSurfaceDescription(srcOps).cString, getSurfaceDescription(dstOps).cString,
465          sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2);
466 #endif //TRACE_ISOBLIT
467 
468     if (!texture &amp;&amp; !xform
469         &amp;&amp; [mtlc isBlendingDisabled:srcOps-&gt;isOpaque]
470         &amp;&amp; isIntegerAndUnscaled(sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2)
471         &amp;&amp; (dstOps-&gt;isOpaque || !srcOps-&gt;isOpaque)
472     ) {
473 #ifdef TRACE_ISOBLIT
474         J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [via blitEncoder]&quot;);
475 #endif //TRACE_ISOBLIT
476 
477         id &lt;MTLBlitCommandEncoder&gt; blitEncoder = [mtlc.encoderManager createBlitEncoder];
478         [blitEncoder copyFromTexture:srcTex
479                          sourceSlice:0
480                          sourceLevel:0
481                         sourceOrigin:MTLOriginMake(sx1, sy1, 0)
482                           sourceSize:MTLSizeMake(sx2 - sx1, sy2 - sy1, 1)
483                            toTexture:dstTex
484                     destinationSlice:0
485                     destinationLevel:0
486                    destinationOrigin:MTLOriginMake(dx1, dy1, 0)];
487         [blitEncoder endEncoding];
488         return;
489     }
490 
491 #ifdef TRACE_ISOBLIT
492     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [via sampling]&quot;);
493 #endif //TRACE_ISOBLIT
494     drawTex2Tex(mtlc, srcTex, dstTex,
495             [mtlc isBlendingDisabled:srcOps-&gt;isOpaque],
496             dstOps-&gt;isOpaque, hint, sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2);
497 }
498 
499 /**
500  * General blit method for copying a system memory (&quot;Sw&quot;) surface to a native MTL surface.
501  * Parameter texture == true only in SwToTextureBlit (straight copy from sw to texture), dest coordinates will always be integers.
502  * Parameter xform == true only when AffineTransform is used (invoked only from TransformBlit, dest coordinates will always be integers).
503  */
504 void
505 MTLBlitLoops_Blit(JNIEnv *env,
506                   MTLContext *mtlc, jlong pSrcOps, jlong pDstOps,
507                   jboolean xform, jint hint,
508                   jint srctype, jboolean texture,
509                   jint sx1, jint sy1, jint sx2, jint sy2,
510                   jdouble dx1, jdouble dy1, jdouble dx2, jdouble dy2)
511 {
512     SurfaceDataOps *srcOps = (SurfaceDataOps *)jlong_to_ptr(pSrcOps);
513     BMTLSDOps *dstOps = (BMTLSDOps *)jlong_to_ptr(pDstOps);
514 
515     RETURN_IF_NULL(mtlc);
516     RETURN_IF_NULL(srcOps);
517     RETURN_IF_NULL(dstOps);
518 
519     id&lt;MTLTexture&gt; dest = dstOps-&gt;pTexture;
520     if (dest == NULL) {
521         J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBlitLoops_Blit: dest is null&quot;);
522         return;
523     }
524     if (srctype &lt; 0 || srctype &gt;= sizeof(RasterFormatInfos)/ sizeof(MTLRasterFormatInfo)) {
525         J2dTraceLn1(J2D_TRACE_ERROR, &quot;MTLBlitLoops_Blit: source pixel format %d isn&#39;t supported&quot;, srctype);
526         return;
527     }
528     const jint sw    = sx2 - sx1;
529     const jint sh    = sy2 - sy1;
530     const jdouble dw = dx2 - dx1;
531     const jdouble dh = dy2 - dy1;
532 
533     if (sw &lt;= 0 || sh &lt;= 0 || dw &lt;= 0 || dh &lt;= 0) {
534         J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBlitLoops_Blit: invalid dimensions&quot;);
535         return;
536     }
537 
538 #ifdef DEBUG_BLIT
539     if (
540         (xform == JNI_TRUE) != (mtlc.useTransform == JNI_TRUE)
541         || (xform &amp;&amp; texture)
542     ) {
543         J2dTraceImpl(J2D_TRACE_ERROR, JNI_TRUE,
544                 &quot;MTLBlitLoops_Blit state error: xform=%d, mtlc.useTransform=%d, texture=%d&quot;,
545                 xform, mtlc.useTransform, texture);
546     }
547     if (texture) {
548         if (!isIntegerAndUnscaled(sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2)) {
549             J2dTraceImpl(J2D_TRACE_ERROR, JNI_TRUE,
550                     &quot;MTLBlitLoops_Blit state error: texture=true, but src and dst dimensions aren&#39;t equal or dest coords aren&#39;t integers&quot;);
551         }
552         if (!dstOps-&gt;isOpaque &amp;&amp; !RasterFormatInfos[srctype].hasAlpha) {
553             J2dTraceImpl(J2D_TRACE_ERROR, JNI_TRUE,
554                     &quot;MTLBlitLoops_Blit state error: texture=true, but dest has alpha and source hasn&#39;t alpha, can&#39;t use texture-codepath&quot;);
555         }
556     }
557 #endif // DEBUG_BLIT
558 
559     clipDestCoords(
560             &amp;dx1, &amp;dy1, &amp;dx2, &amp;dy2,
561             &amp;sx1, &amp;sy1, &amp;sx2, &amp;sy2,
562             dest.width, dest.height, texture ? NULL : [mtlc.clip getRect]
563     );
564 
565     SurfaceDataRasInfo srcInfo;
566     srcInfo.bounds.x1 = sx1;
567     srcInfo.bounds.y1 = sy1;
568     srcInfo.bounds.x2 = sx2;
569     srcInfo.bounds.y2 = sy2;
570 
571     // NOTE: This function will modify the contents of the bounds field to represent the maximum available raster data.
572     if (srcOps-&gt;Lock(env, srcOps, &amp;srcInfo, SD_LOCK_READ) != SD_SUCCESS) {
573         J2dTraceLn(J2D_TRACE_WARNING, &quot;MTLBlitLoops_Blit: could not acquire lock&quot;);
574         return;
575     }
576 
577     if (srcInfo.bounds.x2 &gt; srcInfo.bounds.x1 &amp;&amp; srcInfo.bounds.y2 &gt; srcInfo.bounds.y1) {
578         srcOps-&gt;GetRasInfo(env, srcOps, &amp;srcInfo);
579         if (srcInfo.rasBase) {
580             if (srcInfo.bounds.x1 != sx1) {
581                 const int dx = srcInfo.bounds.x1 - sx1;
582                 dx1 += dx * (dw / sw);
583             }
584             if (srcInfo.bounds.y1 != sy1) {
585                 const int dy = srcInfo.bounds.y1 - sy1;
586                 dy1 += dy * (dh / sh);
587             }
588             if (srcInfo.bounds.x2 != sx2) {
589                 const int dx = srcInfo.bounds.x2 - sx2;
590                 dx2 += dx * (dw / sw);
591             }
592             if (srcInfo.bounds.y2 != sy2) {
593                 const int dy = srcInfo.bounds.y2 - sy2;
594                 dy2 += dy * (dh / sh);
595             }
596 
597 #ifdef TRACE_BLIT
598             J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_FALSE,
599                     &quot;MTLBlitLoops_Blit [tx=%d, xf=%d, AC=%s]: bdst=%s, src=%p (%dx%d) O=%d premul=%d | (%d, %d, %d, %d)-&gt;(%1.2f, %1.2f, %1.2f, %1.2f)&quot;,
600                     texture, xform, [mtlc getCompositeDescription].cString,
601                     getSurfaceDescription(dstOps).cString, srcOps,
602                     sx2 - sx1, sy2 - sy1,
603                     RasterFormatInfos[srctype].hasAlpha ? 0 : 1, RasterFormatInfos[srctype].isPremult ? 1 : 0,
604                     sx1, sy1, sx2, sy2,
605                     dx1, dy1, dx2, dy2);
606 #endif //TRACE_BLIT
607 
608             MTLRasterFormatInfo rfi = RasterFormatInfos[srctype];
609             const jboolean useReplaceRegion = texture ||
610                     ([mtlc isBlendingDisabled:!rfi.hasAlpha]
611                     &amp;&amp; !xform
612                     &amp;&amp; isIntegerAndUnscaled(sx1, sy1, sx2, sy2, dx1, dy1, dx2, dy2));
613 
614             if (useReplaceRegion) {
615                 if (dstOps-&gt;isOpaque || rfi.hasAlpha) {
616 #ifdef TRACE_BLIT
617                     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [replaceTextureRegion]&quot;);
618 #endif //TRACE_BLIT
619                     replaceTextureRegion(dest, &amp;srcInfo, &amp;rfi, (int) dx1, (int) dy1, (int) dx2, (int) dy2);
620                 } else {
621 #ifdef TRACE_BLIT
622                     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [via pooled + blit]&quot;);
623 #endif //TRACE_BLIT
624                     MTLBlitSwToTextureViaPooledTexture(mtlc, &amp;srcInfo, dstOps, &amp;rfi, true, hint, dx1, dy1, dx2, dy2);
625                 }
626             } else { // !useReplaceRegion
627 #ifdef TRACE_BLIT
628                 J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,&quot; [via pooled texture]&quot;);
629 #endif //TRACE_BLIT
630                 MTLBlitSwToTextureViaPooledTexture(mtlc, &amp;srcInfo, dstOps, &amp;rfi, false, hint, dx1, dy1, dx2, dy2);
631             }
632         }
633         SurfaceData_InvokeRelease(env, srcOps, &amp;srcInfo);
634     }
635     SurfaceData_InvokeUnlock(env, srcOps, &amp;srcInfo);
636 }
637 
638 /**
639  * Specialized blit method for copying a native MTL &quot;Surface&quot; (pbuffer,
640  * window, etc.) to a system memory (&quot;Sw&quot;) surface.
641  */
642 void
643 MTLBlitLoops_SurfaceToSwBlit(JNIEnv *env, MTLContext *mtlc,
644                              jlong pSrcOps, jlong pDstOps, jint dsttype,
645                              jint srcx, jint srcy, jint dstx, jint dsty,
646                              jint width, jint height)
647 {
648     J2dTraceLn6(J2D_TRACE_VERBOSE, &quot;MTLBlitLoops_SurfaceToSwBlit: sx=%d sy=%d w=%d h=%d dx=%d dy=%d&quot;, srcx, srcy, width, height, dstx, dsty);
649 
650     BMTLSDOps *srcOps = (BMTLSDOps *)jlong_to_ptr(pSrcOps);
651     SurfaceDataOps *dstOps = (SurfaceDataOps *)jlong_to_ptr(pDstOps);
652     SurfaceDataRasInfo srcInfo, dstInfo;
653 
654     if (dsttype &lt; 0 || dsttype &gt;= sizeof(RasterFormatInfos)/ sizeof(MTLRasterFormatInfo)) {
655         J2dTraceLn1(J2D_TRACE_ERROR, &quot;MTLBlitLoops_SurfaceToSwBlit: destination pixel format %d isn&#39;t supported&quot;, dsttype);
656         return;
657     }
658 
659     if (width &lt;= 0 || height &lt;= 0) {
660         J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLBlitLoops_SurfaceToSwBlit: dimensions are non-positive&quot;);
661         return;
662     }
663 
664     RETURN_IF_NULL(srcOps);
665     RETURN_IF_NULL(dstOps);
666     RETURN_IF_NULL(mtlc);
667 
668     srcInfo.bounds.x1 = srcx;
669     srcInfo.bounds.y1 = srcy;
670     srcInfo.bounds.x2 = srcx + width;
671     srcInfo.bounds.y2 = srcy + height;
672     dstInfo.bounds.x1 = dstx;
673     dstInfo.bounds.y1 = dsty;
674     dstInfo.bounds.x2 = dstx + width;
675     dstInfo.bounds.y2 = dsty + height;
676 
677     if (dstOps-&gt;Lock(env, dstOps, &amp;dstInfo, SD_LOCK_WRITE) != SD_SUCCESS) {
678         J2dTraceLn(J2D_TRACE_WARNING,&quot;MTLBlitLoops_SurfaceToSwBlit: could not acquire dst lock&quot;);
679         return;
680     }
681 
682     SurfaceData_IntersectBoundsXYXY(&amp;srcInfo.bounds,
683                                     0, 0, srcOps-&gt;width, srcOps-&gt;height);
684     SurfaceData_IntersectBlitBounds(&amp;dstInfo.bounds, &amp;srcInfo.bounds,
685                                     srcx - dstx, srcy - dsty);
686 
687     if (srcInfo.bounds.x2 &gt; srcInfo.bounds.x1 &amp;&amp;
688         srcInfo.bounds.y2 &gt; srcInfo.bounds.y1)
689     {
690         dstOps-&gt;GetRasInfo(env, dstOps, &amp;dstInfo);
691         if (dstInfo.rasBase) {
692             void *pDst = dstInfo.rasBase;
693 
694             srcx = srcInfo.bounds.x1;
695             srcy = srcInfo.bounds.y1;
696             dstx = dstInfo.bounds.x1;
697             dsty = dstInfo.bounds.y1;
698             width = srcInfo.bounds.x2 - srcInfo.bounds.x1;
699             height = srcInfo.bounds.y2 - srcInfo.bounds.y1;
700 
701             pDst = PtrAddBytes(pDst, dstx * dstInfo.pixelStride);
702             pDst = PtrPixelsRow(pDst, dsty, dstInfo.scanStride);
703 
704             // this accounts for lower-left origin of the source region
705             srcx = srcOps-&gt;xOffset + srcx;
706             srcy = srcOps-&gt;yOffset + srcOps-&gt;height - srcy - height;
707             const int srcLength = width * height * 4; // NOTE: assume that src format is MTLPixelFormatBGRA8Unorm
708 
709 #ifdef DEBUG
710             void *pDstEnd = dstInfo.rasBase + (height - 1)*dstInfo.scanStride + width*dstInfo.pixelStride;
711             if (pDst + srcLength &gt; pDstEnd) {
712                 J2dTraceLn6(J2D_TRACE_ERROR, &quot;MTLBlitLoops_SurfaceToSwBlit: length mismatch: dstx=%d, dsty=%d, w=%d, h=%d, pixStride=%d, scanStride=%d&quot;,
713                         dstx, dsty, width, height, dstInfo.pixelStride, dstInfo.scanStride);
714                 return;
715             }
716 #endif //DEBUG
717 
718             // Create MTLBuffer (or use static)
719             MTLRasterFormatInfo rfi = RasterFormatInfos[dsttype];
720             const jboolean directCopy = rfi.permuteMap == NULL;
721 
722             id&lt;MTLBuffer&gt; mtlbuf;
723 #ifdef USE_STATIC_BUFFER
724             if (directCopy) {
725                 // NOTE: theoretically we can use newBufferWithBytesNoCopy, but pDst must be allocated with special API
726                 // mtlbuf = [mtlc.device
727                 //          newBufferWithBytesNoCopy:pDst
728                 //                            length:(NSUInteger) srcLength
729                 //                           options:MTLResourceCPUCacheModeDefaultCache
730                 //                       deallocator:nil];
731                 //
732                 // see https://developer.apple.com/documentation/metal/mtldevice/1433382-newbufferwithbytesnocopy?language=objc
733                 //
734                 // The storage allocation of the returned new MTLBuffer object is the same as the pointer input value.
735                 // The existing memory allocation must be covered by a single VM region, typically allocated with vm_allocate or mmap.
736                 // Memory allocated by malloc is specifically disallowed.
737             }
738 
739             static id&lt;MTLBuffer&gt; mtlIntermediateBuffer = nil; // need to reimplement with MTLBufferManager
740             if (mtlIntermediateBuffer == nil || mtlIntermediateBuffer.length &lt; srcLength) {
741                 if (mtlIntermediateBuffer != nil) {
742                     [mtlIntermediateBuffer release];
743                 }
744                 mtlIntermediateBuffer = [mtlc.device newBufferWithLength:srcLength options:MTLResourceCPUCacheModeDefaultCache];
745             }
746             mtlbuf = mtlIntermediateBuffer;
747 #else // USE_STATIC_BUFFER
748             mtlbuf = [mtlc.device newBufferWithLength:width*height*4 options:MTLResourceStorageModeShared];
749 #endif // USE_STATIC_BUFFER
750 
751             // Read from surface into MTLBuffer
752             // NOTE: using of separate blitCommandBuffer can produce errors (draw into surface (with general cmd-buf)
753             // can be unfinished when reading raster from blit cmd-buf).
754             // Consider to use [mtlc.encoderManager createBlitEncoder] and [mtlc commitCommandBuffer:JNI_TRUE];
755             J2dTraceLn1(J2D_TRACE_VERBOSE, &quot;MTLBlitLoops_SurfaceToSwBlit: source texture %p&quot;, srcOps-&gt;pTexture);
756 
757             id&lt;MTLCommandBuffer&gt; cb = [mtlc createBlitCommandBuffer];
758             id&lt;MTLBlitCommandEncoder&gt; blitEncoder = [cb blitCommandEncoder];
759             [blitEncoder synchronizeTexture:srcOps-&gt;pTexture slice:0 level:0];
760             [blitEncoder copyFromTexture:srcOps-&gt;pTexture
761                             sourceSlice:0
762                             sourceLevel:0
763                            sourceOrigin:MTLOriginMake(srcx, srcy, 0)
764                              sourceSize:MTLSizeMake(width, height, 1)
765                                toBuffer:mtlbuf
766                       destinationOffset:0 /*offset already taken in: pDst = PtrAddBytes(pDst, dstx * dstInfo.pixelStride)*/
767                  destinationBytesPerRow:width*4
768                destinationBytesPerImage:width * height*4];
769             [blitEncoder endEncoding];
770 
771             // Commit and wait for reading complete
772             [cb commit];
773             [cb waitUntilCompleted];
774 
775             // Perform conversion if necessary
776             if (directCopy) {
777                 memcpy(pDst, mtlbuf.contents, srcLength);
778             } else {
779                 J2dTraceLn6(J2D_TRACE_VERBOSE,&quot;MTLBlitLoops_SurfaceToSwBlit: dsttype=%d, raster conversion will be performed, dest rfi: %d, %d, %d, %d, hasA=%d&quot;,
780                             dsttype, rfi.permuteMap[0], rfi.permuteMap[1], rfi.permuteMap[2], rfi.permuteMap[3], rfi.hasAlpha);
781 
782                 // perform raster conversion: mtlIntermediateBuffer(8888) -&gt; pDst(rfi)
783                 // invoked only from rq-thread, so use static buffers
784                 // but it&#39;s better to use thread-local buffers (or special buffer manager)
785                 vImage_Buffer srcBuf;
786                 srcBuf.height = height;
787                 srcBuf.width = width;
788                 srcBuf.rowBytes = 4*width;
789                 srcBuf.data = mtlbuf.contents;
790 
791                 vImage_Buffer destBuf;
792                 destBuf.height = height;
793                 destBuf.width = width;
794                 destBuf.rowBytes = dstInfo.scanStride;
795                 destBuf.data = pDst;
796 
797                 vImagePermuteChannels_ARGB8888(&amp;srcBuf, &amp;destBuf, rfi.permuteMap, kvImageNoFlags);
798             }
799 #ifndef USE_STATIC_BUFFER
800             [mtlbuf release];
801 #endif // USE_STATIC_BUFFER
802         }
803         SurfaceData_InvokeRelease(env, dstOps, &amp;dstInfo);
804     }
805     SurfaceData_InvokeUnlock(env, dstOps, &amp;dstInfo);
806 }
807 
808 void
809 MTLBlitLoops_CopyArea(JNIEnv *env,
810                       MTLContext *mtlc, BMTLSDOps *dstOps,
811                       jint x, jint y, jint width, jint height,
812                       jint dx, jint dy)
813 {
814 #ifdef DEBUG
815     J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE, &quot;MTLBlitLoops_CopyArea: bdst=%p [tex=%p] %dx%d | src (%d, %d), %dx%d -&gt; dst (%d, %d)&quot;,
816             dstOps, dstOps-&gt;pTexture, ((id&lt;MTLTexture&gt;)dstOps-&gt;pTexture).width, ((id&lt;MTLTexture&gt;)dstOps-&gt;pTexture).height, x, y, width, height, dx, dy);
817 #endif //DEBUG
<a name="1" id="anc1"></a><span class="line-modified">818 </span>
<span class="line-modified">819     @autoreleasepool {</span>
<span class="line-modified">820     id&lt;MTLCommandBuffer&gt; cb = [mtlc createBlitCommandBuffer];</span>
<span class="line-added">821     id&lt;MTLBlitCommandEncoder&gt; blitEncoder = [cb blitCommandEncoder];</span>
<span class="line-added">822 </span>
<span class="line-added">823     // Create an intrermediate buffer</span>
<span class="line-added">824     int totalBuffsize = width * height * 4;</span>
<span class="line-added">825     id &lt;MTLBuffer&gt; buff = [mtlc.device newBufferWithLength:totalBuffsize options:MTLResourceStorageModePrivate];</span>
<span class="line-added">826 </span>
<span class="line-added">827     [blitEncoder copyFromTexture:dstOps-&gt;pTexture</span>
828             sourceSlice:0 sourceLevel:0 sourceOrigin:MTLOriginMake(x, y, 0) sourceSize:MTLSizeMake(width, height, 1)
<a name="2" id="anc2"></a><span class="line-added">829              toBuffer:buff destinationOffset:0 destinationBytesPerRow:(width * 4) destinationBytesPerImage:totalBuffsize];</span>
<span class="line-added">830 </span>
<span class="line-added">831     [blitEncoder copyFromBuffer:buff</span>
<span class="line-added">832             sourceOffset:0 sourceBytesPerRow:width*4 sourceBytesPerImage:totalBuffsize sourceSize:MTLSizeMake(width, height, 1)</span>
833             toTexture:dstOps-&gt;pTexture destinationSlice:0 destinationLevel:0 destinationOrigin:MTLOriginMake(x + dx, y + dy, 0)];
834     [blitEncoder endEncoding];
835 
<a name="3" id="anc3"></a><span class="line-added">836     [cb commit];</span>
<span class="line-added">837     //[cb waitUntilCompleted];</span>
<span class="line-added">838 </span>
<span class="line-added">839     /*[blitEncoder</span>
<span class="line-added">840             copyFromTexture:dstOps-&gt;pTexture</span>
<span class="line-added">841             sourceSlice:0 sourceLevel:0 sourceOrigin:MTLOriginMake(x, y, 0) sourceSize:MTLSizeMake(width, height, 1)</span>
<span class="line-added">842             toTexture:dstOps-&gt;pTexture destinationSlice:0 destinationLevel:0 destinationOrigin:MTLOriginMake(x + dx, y + dy, 0)];</span>
<span class="line-added">843     [blitEncoder endEncoding];*/</span>
<span class="line-added">844 </span>
<span class="line-added">845     }</span>
846     // TODO:
847     //  1. check rect bounds
848     //  2. support CopyArea with extra-alpha (and with custom Composite if necessary)
849 }
850 
851 #endif /* !HEADLESS */
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
diff a/src/jdk.aot/share/classes/jdk.tools.jaotc/src/jdk/tools/jaotc/CodeSectionProcessor.java b/src/jdk.aot/share/classes/jdk.tools.jaotc/src/jdk/tools/jaotc/CodeSectionProcessor.java
--- a/src/jdk.aot/share/classes/jdk.tools.jaotc/src/jdk/tools/jaotc/CodeSectionProcessor.java
+++ b/src/jdk.aot/share/classes/jdk.tools.jaotc/src/jdk/tools/jaotc/CodeSectionProcessor.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -27,10 +27,11 @@
 
 import java.util.ArrayList;
 
 import org.graalvm.compiler.code.CompilationResult;
 import org.graalvm.compiler.hotspot.HotSpotForeignCallLinkage;
+import org.graalvm.compiler.options.OptionValues;
 
 import jdk.tools.jaotc.binformat.BinaryContainer;
 import jdk.tools.jaotc.binformat.CodeContainer;
 import jdk.tools.jaotc.binformat.Symbol;
 import jdk.vm.ci.amd64.AMD64;
@@ -40,17 +41,20 @@
 import jdk.vm.ci.code.site.InfopointReason;
 import jdk.vm.ci.meta.ResolvedJavaMethod;
 
 final class CodeSectionProcessor {
 
+    private final OptionValues optionValues;
+
     private final TargetDescription target;
 
     private final BinaryContainer binaryContainer;
 
     CodeSectionProcessor(DataBuilder dataBuilder) {
         this.target = dataBuilder.getBackend().getTarget();
         this.binaryContainer = dataBuilder.getBinaryContainer();
+        this.optionValues = dataBuilder.getBackend().getRuntime().getOptions();
     }
 
     /**
      * Method that looks at code section of a compiled result {@code compClass} and records function
      * entry point symbols along with the text section contents. Note that the text section contents
@@ -129,11 +133,11 @@
     }
 
     private StubInformation addCallStub(boolean isVirtualCall) {
         final int startOffset = binaryContainer.getCodeContainer().getByteStreamSize();
         StubInformation stub = new StubInformation(startOffset, isVirtualCall);
-        ELFMacroAssembler masm = ELFMacroAssembler.getELFMacroAssembler(target);
+        ELFMacroAssembler masm = ELFMacroAssembler.getELFMacroAssembler(target, optionValues);
         byte[] code;
         if (isVirtualCall) {
             code = masm.getPLTVirtualEntryCode(stub);
         } else {
             code = masm.getPLTStaticEntryCode(stub);

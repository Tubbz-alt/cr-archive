<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/ModuleWriterImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ModuleIndexWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="PackageIndexWriter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/ModuleWriterImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 29 import java.util.Collections;
 30 import java.util.List;
 31 import java.util.Map;
 32 import java.util.Set;
 33 import java.util.SortedSet;
 34 import java.util.TreeMap;
 35 import java.util.TreeSet;
 36 
 37 import javax.lang.model.element.Element;
 38 import javax.lang.model.element.ModuleElement;
 39 import javax.lang.model.element.PackageElement;
 40 import javax.lang.model.element.TypeElement;
 41 import javax.lang.model.util.ElementFilter;
 42 
 43 import com.sun.source.doctree.DocTree;
 44 import jdk.javadoc.doclet.DocletEnvironment.ModuleMode;
 45 import jdk.javadoc.internal.doclets.formats.html.markup.BodyContents;
 46 import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;
 47 import jdk.javadoc.internal.doclets.formats.html.markup.Entity;
 48 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
<span class="line-modified"> 49 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTag;</span>
 50 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
<span class="line-modified"> 51 import jdk.javadoc.internal.doclets.formats.html.markup.Navigation;</span>
<span class="line-removed"> 52 import jdk.javadoc.internal.doclets.formats.html.markup.Navigation.PageMode;</span>
 53 import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;
 54 import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;
 55 import jdk.javadoc.internal.doclets.formats.html.markup.Table;
 56 import jdk.javadoc.internal.doclets.formats.html.markup.TableHeader;
 57 import jdk.javadoc.internal.doclets.toolkit.Content;
 58 import jdk.javadoc.internal.doclets.toolkit.ModuleSummaryWriter;
 59 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
 60 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
 61 
 62 /**
 63  * Class to generate file for each module contents in the right-hand frame. This will list all the
 64  * required modules, packages and service types for the module. A click on any of the links will update
 65  * the frame with the clicked element page.
 66  *
 67  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 68  *  If you write code that depends on this, you do so at your own risk.
 69  *  This code and its internal interfaces are subject to change or
 70  *  deletion without notice.&lt;/b&gt;
 71  */
 72 public class ModuleWriterImpl extends HtmlDocletWriter implements ModuleSummaryWriter {
</pre>
<hr />
<pre>
177         this.navBar = new Navigation(mdle, configuration, PageMode.MODULE, path);
178         computeModulesData();
179     }
180 
181     /**
182      * Get the module header.
183      *
184      * @param heading the heading for the section
185      */
186     @Override
187     public Content getModuleHeader(String heading) {
188         HtmlTree bodyTree = getBody(getWindowTitle(mdle.getQualifiedName().toString()));
189         Content headerContent = new ContentBuilder();
190         addTop(headerContent);
191         navBar.setDisplaySummaryModuleDescLink(!utils.getFullBody(mdle).isEmpty() &amp;&amp; !options.noComment());
192         navBar.setDisplaySummaryModulesLink(display(requires) || display(indirectModules));
193         navBar.setDisplaySummaryPackagesLink(display(packages) || display(indirectPackages)
194                 || display(indirectOpenPackages));
195         navBar.setDisplaySummaryServicesLink(displayServices(uses, usesTrees) || displayServices(provides.keySet(), providesTrees));
196         navBar.setUserHeader(getUserHeaderFooter(true));
<span class="line-modified">197         headerContent.add(navBar.getContent(true));</span>
<span class="line-modified">198         HtmlTree div = new HtmlTree(HtmlTag.DIV);</span>
199         div.setStyle(HtmlStyle.header);
<span class="line-modified">200         Content annotationContent = new HtmlTree(HtmlTag.P);</span>
201         addAnnotationInfo(mdle, annotationContent);
202         div.add(annotationContent);
203         Content label = mdle.isOpen() &amp;&amp; (configuration.docEnv.getModuleMode() == ModuleMode.ALL)
204                 ? contents.openModuleLabel : contents.moduleLabel;
<span class="line-modified">205         Content tHeading = HtmlTree.HEADING(Headings.PAGE_TITLE_HEADING, true,</span>
206                 HtmlStyle.title, label);
207         tHeading.add(Entity.NO_BREAK_SPACE);
208         Content moduleHead = new RawHtml(heading);
209         tHeading.add(moduleHead);
210         div.add(tHeading);
211         bodyContents.setHeader(headerContent)
212                 .addMainContent(div);
213         return bodyTree;
214     }
215 
216     /**
217      * Get the content header.
218      */
219     @Override
220     public Content getContentHeader() {
<span class="line-modified">221         HtmlTree div = new HtmlTree(HtmlTag.DIV);</span>
<span class="line-removed">222         div.setStyle(HtmlStyle.contentContainer);</span>
<span class="line-removed">223         return div;</span>
224     }
225 
226     /**
227      * Get the summary section header.
228      */
229     @Override
230     public Content getSummaryHeader() {
<span class="line-modified">231         HtmlTree ul = new HtmlTree(HtmlTag.UL);</span>
232         ul.setStyle(HtmlStyle.blockList);
233         return ul;
234     }
235 
236     /**
237      * Get the summary tree.
238      *
239      * @param summaryContentTree the content tree to be added to the summary tree.
240      */
241     @Override
242     public Content getSummaryTree(Content summaryContentTree) {
243         return HtmlTree.SECTION(HtmlStyle.summary, summaryContentTree);
244     }
245 
246     /**
247      * Compute the modules data that will be displayed in various tables on the module summary page.
248      */
249     public void computeModulesData() {
250         CommentHelper ch = utils.getCommentHelper(mdle);
251         // Get module dependencies using the module&#39;s transitive closure.
252         Map&lt;ModuleElement, String&gt; dependentModules = utils.getDependentModules(mdle);
253         // Add all dependent modules to indirect modules set. We will remove the modules,
254         // listed using the requires directive, from this set to come up with the table of indirect
255         // required modules.
256         dependentModules.forEach((module, mod) -&gt; {
257             if (shouldDocument(module)) {
258                 indirectModules.put(module, new StringContent(mod));
259             }
260         });
<span class="line-modified">261         (ElementFilter.requiresIn(mdle.getDirectives())).forEach((directive) -&gt; {</span>
262             ModuleElement m = directive.getDependency();
263             if (shouldDocument(m)) {
264                 if (moduleMode == ModuleMode.ALL || directive.isTransitive()) {
265                     requires.put(m, new StringContent(utils.getModifiers(directive)));
<span class="line-modified">266             } else {</span>
267                     // For api mode, just keep the public requires in dependentModules for display of
268                     // indirect packages in the &quot;Packages&quot; section.
269                     dependentModules.remove(m);
270                 }
271                 indirectModules.remove(m);
<span class="line-modified">272         }</span>
273         });
274 
275         // Get all packages if module is open or if displaying concealed modules
276         for (PackageElement pkg : utils.getModulePackageMap().getOrDefault(mdle, Collections.emptySet())) {
277             if (shouldDocument(pkg) &amp;&amp; (mdle.isOpen() || moduleMode == ModuleMode.ALL)) {
278                 PackageEntry e = new PackageEntry();
279                 if (mdle.isOpen()) {
280                     e.openedTo = Collections.emptySet();
281                 }
282                 packages.put(pkg, e);
283             }
284         }
285 
286         // Get all exported packages for the module, using the exports directive for the module.
287         for (ModuleElement.ExportsDirective directive : ElementFilter.exportsIn(mdle.getDirectives())) {
288             PackageElement p = directive.getPackage();
289             if (shouldDocument(p)) {
290                 List&lt;? extends ModuleElement&gt; targetMdles = directive.getTargetModules();
291                 // Include package if in details mode, or exported to all (i.e. targetModules == null)
292                 if (moduleMode == ModuleMode.ALL || targetMdles == null) {
</pre>
<hr />
<pre>
304         // If it is an open module, there will be no separate opens directives.
305         for (ModuleElement.OpensDirective directive : ElementFilter.opensIn(mdle.getDirectives())) {
306             PackageElement p = directive.getPackage();
307             if (shouldDocument(p)) {
308                 List&lt;? extends ModuleElement&gt; targetMdles = directive.getTargetModules();
309                 // Include package if in details mode, or opened to all (i.e. targetModules == null)
310                 if (moduleMode == ModuleMode.ALL || targetMdles == null) {
311                     PackageEntry packageEntry = packages.computeIfAbsent(p, pkg -&gt; new PackageEntry());
312                     SortedSet&lt;ModuleElement&gt; mdleList = new TreeSet&lt;&gt;(utils.makeModuleComparator());
313                     if (targetMdles != null) {
314                         mdleList.addAll(targetMdles);
315                     }
316                     packageEntry.openedTo = mdleList;
317                 }
318             }
319         }
320 
321         // Get all the exported and opened packages, for the transitive closure of the module, to be displayed in
322         // the indirect packages tables.
323         dependentModules.forEach((module, mod) -&gt; {
<span class="line-modified">324             SortedSet&lt;PackageElement&gt; exportPkgList = new TreeSet&lt;&gt;(utils.makePackageComparator());</span>
<span class="line-modified">325             (ElementFilter.exportsIn(module.getDirectives())).forEach((directive) -&gt; {</span>
326                 PackageElement pkg = directive.getPackage();
327                 if (shouldDocument(pkg)) {
328                     // Qualified exports are not displayed in API mode
329                     if (moduleMode == ModuleMode.ALL || directive.getTargetModules() == null) {
<span class="line-modified">330                         exportPkgList.add(pkg);</span>
331                     }
332                 }
333             });
334             // If none of the indirect modules have exported packages to be displayed, we should not be
335             // displaying the table and so it should not be added to the map.
<span class="line-modified">336             if (!exportPkgList.isEmpty()) {</span>
<span class="line-modified">337                 indirectPackages.put(module, exportPkgList);</span>
338             }
<span class="line-modified">339             SortedSet&lt;PackageElement&gt; openPkgList = new TreeSet&lt;&gt;(utils.makePackageComparator());</span>
340             if (module.isOpen()) {
<span class="line-modified">341                 openPkgList.addAll(utils.getModulePackageMap().getOrDefault(module, Collections.emptySet()));</span>
342             } else {
<span class="line-modified">343                 (ElementFilter.opensIn(module.getDirectives())).forEach((directive) -&gt; {</span>
344                     PackageElement pkg = directive.getPackage();
345                     if (shouldDocument(pkg)) {
346                         // Qualified opens are not displayed in API mode
347                         if (moduleMode == ModuleMode.ALL || directive.getTargetModules() == null) {
<span class="line-modified">348                             openPkgList.add(pkg);</span>
349                         }
350                     }
351                 });
352             }
353             // If none of the indirect modules have opened packages to be displayed, we should not be
354             // displaying the table and so it should not be added to the map.
<span class="line-modified">355             if (!openPkgList.isEmpty()) {</span>
<span class="line-modified">356                 indirectOpenPackages.put(module, openPkgList);</span>
357             }
358         });
359         // Get all the services listed as uses directive.
<span class="line-modified">360         (ElementFilter.usesIn(mdle.getDirectives())).forEach((directive) -&gt; {</span>
361             TypeElement u = directive.getService();
362             if (shouldDocument(u)) {
363                 uses.add(u);
364             }
365         });
366         // Get all the services and implementations listed as provides directive.
<span class="line-modified">367         (ElementFilter.providesIn(mdle.getDirectives())).forEach((directive) -&gt; {</span>
368             TypeElement u = directive.getService();
369             if (shouldDocument(u)) {
370                 List&lt;? extends TypeElement&gt; implList = directive.getImplementations();
371                 SortedSet&lt;TypeElement&gt; implSet = new TreeSet&lt;&gt;(utils.makeAllClassesComparator());
372                 implSet.addAll(implList);
373                 provides.put(u, implSet);
374             }
375         });
376         // Generate the map of all services listed using @provides, and the description.
<span class="line-modified">377         (utils.getBlockTags(mdle, DocTree.Kind.PROVIDES)).forEach((tree) -&gt; {</span>
378             TypeElement t = ch.getServiceType(tree);
379             if (t != null) {
380                 providesTrees.put(t, commentTagsToContent(tree, mdle, ch.getDescription(tree), false, true));
381             }
382         });
383         // Generate the map of all services listed using @uses, and the description.
<span class="line-modified">384         (utils.getBlockTags(mdle, DocTree.Kind.USES)).forEach((tree) -&gt; {</span>
385             TypeElement t = ch.getServiceType(tree);
386             if (t != null) {
387                 usesTrees.put(t, commentTagsToContent(tree, mdle, ch.getDescription(tree), false, true));
388             }
389         });
390     }
391 
392     /**
393      * Returns true if the element should be documented on the module summary page.
394      *
395      * @param element the element to be checked
396      * @return true if the element should be documented
397      */
398     public boolean shouldDocument(Element element) {
399         return (moduleMode == ModuleMode.ALL || utils.isIncluded(element));
400     }
401 
402     /**
403      * Returns true if there are elements to be displayed.
404      *
</pre>
<hr />
<pre>
409         return section != null &amp;&amp; !section.isEmpty();
410     }
411 
412     /**
413      * Returns true if there are elements to be displayed.
414      *
415      * @param section map of elements.
416      * @return true if there are elements to be displayed
417      */
418     public boolean display(Map&lt;? extends Element, ?&gt; section) {
419         return section != null &amp;&amp; !section.isEmpty();
420     }
421 
422     /*
423      * Returns true, in API mode, if at least one type element in
424      * the typeElements set is referenced by a javadoc tag in tagsMap.
425      */
426     private boolean displayServices(Set&lt;TypeElement&gt; typeElements,
427                                     Map&lt;TypeElement, Content&gt; tagsMap) {
428         return typeElements != null &amp;&amp;
<span class="line-modified">429                 typeElements.stream().anyMatch((v) -&gt; displayServiceDirective(v, tagsMap));</span>
430     }
431 
432     /*
433      * Returns true, in API mode, if the type element is referenced
434      * from a javadoc tag in tagsMap.
435      */
436     private boolean displayServiceDirective(TypeElement typeElement,
437                                             Map&lt;TypeElement, Content&gt; tagsMap) {
438         return moduleMode == ModuleMode.ALL || tagsMap.containsKey(typeElement);
439     }
440 
441     /**
442      * Add the summary header.
443      *
444      * @param startMarker the marker comment
445      * @param heading the heading for the section
446      * @param htmltree the content tree to which the information is added
447      */
448     public void addSummaryHeader(Content startMarker, Content heading,
449             Content htmltree) {
</pre>
<hr />
<pre>
486     }
487 
488     @Override
489     public void addModulesSummary(Content summaryContentTree) {
490         if (display(requires) || display(indirectModules)) {
491             TableHeader requiresTableHeader =
492                     new TableHeader(contents.modifierLabel, contents.moduleLabel,
493                             contents.descriptionLabel);
494             HtmlTree section = HtmlTree.SECTION(HtmlStyle.modulesSummary)
495                     .setId(SectionName.MODULES.getName());
496             addSummaryHeader(MarkerComments.START_OF_MODULES_SUMMARY, contents.navModules, section);
497             if (display(requires)) {
498                 String text = resources.getText(&quot;doclet.Requires_Summary&quot;);
499                 String tableSummary = resources.getText(&quot;doclet.Member_Table_Summary&quot;,
500                         text,
501                         resources.getText(&quot;doclet.modules&quot;));
502                 Content caption = getTableCaption(new StringContent(text));
503                 Table table = getTable3(caption, tableSummary, HtmlStyle.requiresSummary,
504                             requiresTableHeader);
505                 addModulesList(requires, table);
<span class="line-modified">506                 section.add(table.toContent());</span>
507             }
508             // Display indirect modules table in both &quot;api&quot; and &quot;all&quot; mode.
509             if (display(indirectModules)) {
510                 String amrText = resources.getText(&quot;doclet.Indirect_Requires_Summary&quot;);
511                 String amrTableSummary = resources.getText(&quot;doclet.Member_Table_Summary&quot;,
512                         amrText,
513                         resources.getText(&quot;doclet.modules&quot;));
514                 Content amrCaption = getTableCaption(new StringContent(amrText));
515                 Table amrTable = getTable3(amrCaption, amrTableSummary, HtmlStyle.requiresSummary,
516                             requiresTableHeader);
517                 addModulesList(indirectModules, amrTable);
<span class="line-modified">518                 section.add(amrTable.toContent());</span>
519             }
520             summaryContentTree.add(HtmlTree.LI(HtmlStyle.blockList, section));
521         }
522     }
523 
524     /**
525      * Add the list of modules.
526      *
527      * @param mdleMap map of modules and modifiers
528      * @param table the table to which the list will be added
529      */
530     private void addModulesList(Map&lt;ModuleElement, Content&gt; mdleMap, Table table) {
531         for (ModuleElement m : mdleMap.keySet()) {
532             Content modifiers = mdleMap.get(m);
533             Content moduleLink = getModuleLink(m, new StringContent(m.getQualifiedName()));
534             Content moduleSummary = new ContentBuilder();
535             addSummaryComment(m, moduleSummary);
536             table.addRow(modifiers, moduleLink, moduleSummary);
537         }
538     }
539 
540     @Override
541     public void addPackagesSummary(Content summaryContentTree) {
542         if (display(packages)
543                 || display(indirectPackages) || display(indirectOpenPackages)) {
544             HtmlTree section = HtmlTree.SECTION(HtmlStyle.packagesSummary)
545                     .setId(SectionName.PACKAGES.getName());;
546             addSummaryHeader(MarkerComments.START_OF_PACKAGES_SUMMARY, contents.navPackages, section);
547             if (display(packages)) {
548                 addPackageSummary(section);
549             }
550             TableHeader indirectPackagesHeader =
551                     new TableHeader(contents.fromLabel, contents.packagesLabel);
552             if (display(indirectPackages)) {
553                 String aepText = resources.getText(&quot;doclet.Indirect_Exports_Summary&quot;);
554                 Table aepTable = getTable2(new StringContent(aepText),
555                         HtmlStyle.packagesSummary, indirectPackagesHeader);
556                 addIndirectPackages(aepTable, indirectPackages);
<span class="line-modified">557                 section.add(aepTable.toContent());</span>
558             }
559             if (display(indirectOpenPackages)) {
560                 String aopText = resources.getText(&quot;doclet.Indirect_Opens_Summary&quot;);
561                 Table aopTable = getTable2(new StringContent(aopText), HtmlStyle.packagesSummary,
562                         indirectPackagesHeader);
563                 addIndirectPackages(aopTable, indirectOpenPackages);
<span class="line-modified">564                 section.add(aopTable.toContent());</span>
565             }
566             summaryContentTree.add(HtmlTree.LI(HtmlStyle.blockList, section));
567         }
568     }
569 
570     /**
571      * Add the package summary for the module.
572      *
573      * @param li
574      */
575     public void addPackageSummary(HtmlTree li) {
576         Table table = new Table(HtmlStyle.packagesSummary)
577                 .setDefaultTab(resources.getText(&quot;doclet.All_Packages&quot;))
578                 .addTab(resources.getText(&quot;doclet.Exported_Packages_Summary&quot;), this::isExported)
579                 .addTab(resources.getText(&quot;doclet.Opened_Packages_Summary&quot;), this::isOpened)
580                 .addTab(resources.getText(&quot;doclet.Concealed_Packages_Summary&quot;), this::isConcealed)
581                 .setTabScript(i -&gt; String.format(&quot;show(%d);&quot;, i));
582 
583         // Determine whether to show the &quot;Exported To&quot; and &quot;Opened To&quot; columns,
584         // based on whether such columns would provide &quot;useful&quot; info.
</pre>
<hr />
<pre>
631         for (Map.Entry&lt;PackageElement, PackageEntry&gt; e : packages.entrySet()) {
632             PackageElement pkg = e.getKey();
633             PackageEntry entry = e.getValue();
634             List&lt;Content&gt; row = new ArrayList&lt;&gt;();
635             Content pkgLinkContent = getPackageLink(pkg, new StringContent(utils.getPackageName(pkg)));
636             row.add(pkgLinkContent);
637 
638             if (showExportedTo) {
639                 row.add(getPackageExportOpensTo(entry.exportedTo));
640             }
641             if (showOpenedTo) {
642                 row.add(getPackageExportOpensTo(entry.openedTo));
643             }
644             Content summary = new ContentBuilder();
645             addSummaryComment(pkg, summary);
646             row.add(summary);
647 
648             table.addRow(pkg, row);
649         }
650 
<span class="line-modified">651         li.add(table.toContent());</span>
652         if (table.needsScript()) {
653             mainBodyScript.append(table.getScript());
654         }
655     }
656 
657     private boolean isExported(Element e) {
658         PackageEntry entry = packages.get((PackageElement) e);
659         return (entry != null) &amp;&amp; (entry.exportedTo != null);
660     }
661 
662     private boolean isOpened(Element e) {
663         PackageEntry entry = packages.get((PackageElement) e);
664         return (entry != null) &amp;&amp; (entry.openedTo != null);
665     }
666 
667     private boolean isConcealed(Element e) {
668         PackageEntry entry = packages.get((PackageElement) e);
669         return (entry != null) &amp;&amp; (entry.exportedTo == null) &amp;&amp; (entry.openedTo == null);
670     }
671 
</pre>
<hr />
<pre>
709     }
710 
711     @Override
712     public void addServicesSummary(Content summaryContentTree) {
713 
714         boolean haveUses = displayServices(uses, usesTrees);
715         boolean haveProvides = displayServices(provides.keySet(), providesTrees);
716 
717         if (haveProvides || haveUses) {
718             HtmlTree section = HtmlTree.SECTION(HtmlStyle.servicesSummary)
719                     .setId(SectionName.SERVICES.getName());
720             addSummaryHeader(MarkerComments.START_OF_SERVICES_SUMMARY, contents.navServices, section);
721             TableHeader usesProvidesTableHeader =
722                     new TableHeader(contents.typeLabel, contents.descriptionLabel);
723             if (haveProvides) {
724                 String label = resources.getText(&quot;doclet.Provides_Summary&quot;);
725                 Table table = getTable2(new StringContent(label), HtmlStyle.providesSummary,
726                         usesProvidesTableHeader);
727                 addProvidesList(table);
728                 if (!table.isEmpty()) {
<span class="line-modified">729                     section.add(table.toContent());</span>
730                 }
731             }
732             if (haveUses){
733                 String label = resources.getText(&quot;doclet.Uses_Summary&quot;);
734                 Table table = getTable2(new StringContent(label), HtmlStyle.usesSummary,
735                         usesProvidesTableHeader);
736                 addUsesList(table);
737                 if (!table.isEmpty()) {
<span class="line-modified">738                     section.add(table.toContent());</span>
739                 }
740             }
741             summaryContentTree.add(HtmlTree.LI(HtmlStyle.blockList, section));
742         }
743     }
744 
745     /**
746      * Add the uses list for the module.
747      *
748      * @param table the table to which the services used will be added
749      */
750     public void addUsesList(Table table) {
751         Content typeLinkContent;
752         Content description;
753         for (TypeElement t : uses) {
754             if (!displayServiceDirective(t, usesTrees)) {
755                 continue;
756             }
757             typeLinkContent = getLink(new LinkInfoImpl(configuration, LinkInfoImpl.Kind.PACKAGE, t));
758             Content summary = new ContentBuilder();
</pre>
<hr />
<pre>
779         SortedSet&lt;TypeElement&gt; implSet;
780         Content description;
781         for (Map.Entry&lt;TypeElement, SortedSet&lt;TypeElement&gt;&gt; entry : provides.entrySet()) {
782             TypeElement srv = entry.getKey();
783             if (!displayServiceDirective(srv, providesTrees)) {
784                 continue;
785             }
786             implSet = entry.getValue();
787             Content srvLinkContent = getLink(new LinkInfoImpl(configuration, LinkInfoImpl.Kind.PACKAGE, srv));
788             Content desc = new ContentBuilder();
789             if (display(providesTrees)) {
790                 description = providesTrees.get(srv);
791                 desc.add((description != null &amp;&amp; !description.isEmpty())
792                         ? HtmlTree.DIV(HtmlStyle.block, description)
793                         : Entity.NO_BREAK_SPACE);
794             } else {
795                 desc.add(Entity.NO_BREAK_SPACE);
796                 }
797             // Only display the implementation details in the &quot;all&quot; mode.
798             if (moduleMode == ModuleMode.ALL &amp;&amp; !implSet.isEmpty()) {
<span class="line-modified">799                 desc.add(new HtmlTree(HtmlTag.BR));</span>
800                 desc.add(&quot;(&quot;);
801                 HtmlTree implSpan = HtmlTree.SPAN(HtmlStyle.implementationLabel, contents.implementation);
802                 desc.add(implSpan);
803                 desc.add(Entity.NO_BREAK_SPACE);
804                 String sep = &quot;&quot;;
805                 for (TypeElement impl : implSet) {
806                     desc.add(sep);
807                     desc.add(getLink(new LinkInfoImpl(configuration, LinkInfoImpl.Kind.PACKAGE, impl)));
808                     sep = &quot;, &quot;;
809                 }
810                 desc.add(&quot;)&quot;);
811             }
812             table.addRow(srvLinkContent, desc);
813         }
814     }
815 
816     /**
817      * Add the module deprecation information to the documentation tree.
818      *
819      * @param div the content tree to which the deprecation information will be added
820      */
821     public void addDeprecationInfo(Content div) {
822         List&lt;? extends DocTree&gt; deprs = utils.getBlockTags(mdle, DocTree.Kind.DEPRECATED);
823         if (utils.isDeprecated(mdle)) {
824             CommentHelper ch = utils.getCommentHelper(mdle);
<span class="line-modified">825             HtmlTree deprDiv = new HtmlTree(HtmlTag.DIV);</span>
826             deprDiv.setStyle(HtmlStyle.deprecationBlock);
827             Content deprPhrase = HtmlTree.SPAN(HtmlStyle.deprecatedLabel, getDeprecatedPhrase(mdle));
828             deprDiv.add(deprPhrase);
829             if (!deprs.isEmpty()) {
830                 List&lt;? extends DocTree&gt; commentTags = ch.getDescription(deprs.get(0));
831                 if (!commentTags.isEmpty()) {
832                     addInlineDeprecatedComment(mdle, deprs.get(0), deprDiv);
833                 }
834             }
835             div.add(deprDiv);
836         }
837     }
838 
839     @Override
840     public void addModuleDescription(Content moduleContentTree) {
841         if (!utils.getFullBody(mdle).isEmpty()) {
842             HtmlTree tree = HtmlTree.SECTION(HtmlStyle.moduleDescription);
843             tree.setId(SectionName.MODULE_DESCRIPTION.getName());
844             addDeprecationInfo(tree);
845             tree.add(MarkerComments.START_OF_MODULE_DESCRIPTION);
</pre>
<hr />
<pre>
847             moduleContentTree.add(tree);
848         }
849     }
850 
851     @Override
852     public void addModuleTags(Content moduleContentTree) {
853         Content tree = HtmlTree.SECTION(HtmlStyle.moduleTags);
854         addTagsInfo(mdle, tree);
855         moduleContentTree.add(tree);
856     }
857 
858     @Override
859     public void addModuleContent(Content moduleContentTree) {
860         bodyContents.addMainContent(moduleContentTree);
861     }
862 
863     @Override
864     public void addModuleFooter() {
865         Content htmlTree = HtmlTree.FOOTER();
866         navBar.setUserFooter(getUserHeaderFooter(false));
<span class="line-modified">867         htmlTree.add(navBar.getContent(false));</span>
868         addBottom(htmlTree);
869         bodyContents.setFooter(htmlTree);
870     }
871 
872     @Override
873     public void printDocument(Content contentTree) throws DocFileIOException {
<span class="line-modified">874         contentTree.add(bodyContents.toContent());</span>
875         printHtmlDocument(configuration.metakeywords.getMetaKeywordsForModule(mdle),
876                 getDescription(&quot;declaration&quot;, mdle), getLocalStylesheets(mdle), contentTree);
877     }
878 
879     /**
880      * Add the module package deprecation information to the documentation tree.
881      *
882      * @param li the content tree to which the deprecation information will be added
883      * @param pkg the PackageDoc that is added
884      */
885     public void addPackageDeprecationInfo(Content li, PackageElement pkg) {
886         List&lt;? extends DocTree&gt; deprs;
887         if (utils.isDeprecated(pkg)) {
888             deprs = utils.getDeprecatedTrees(pkg);
<span class="line-modified">889             HtmlTree deprDiv = new HtmlTree(HtmlTag.DIV);</span>
890             deprDiv.setStyle(HtmlStyle.deprecationBlock);
891             Content deprPhrase = HtmlTree.SPAN(HtmlStyle.deprecatedLabel, getDeprecatedPhrase(pkg));
892             deprDiv.add(deprPhrase);
893             if (!deprs.isEmpty()) {
894                 CommentHelper ch = utils.getCommentHelper(pkg);
895                 List&lt;? extends DocTree&gt; commentTags = ch.getDescription(deprs.get(0));
896                 if (!commentTags.isEmpty()) {
897                     addInlineDeprecatedComment(pkg, deprs.get(0), deprDiv);
898                 }
899             }
900             li.add(deprDiv);
901         }
902     }
903 }
</pre>
</td>
<td>
<hr />
<pre>
 29 import java.util.Collections;
 30 import java.util.List;
 31 import java.util.Map;
 32 import java.util.Set;
 33 import java.util.SortedSet;
 34 import java.util.TreeMap;
 35 import java.util.TreeSet;
 36 
 37 import javax.lang.model.element.Element;
 38 import javax.lang.model.element.ModuleElement;
 39 import javax.lang.model.element.PackageElement;
 40 import javax.lang.model.element.TypeElement;
 41 import javax.lang.model.util.ElementFilter;
 42 
 43 import com.sun.source.doctree.DocTree;
 44 import jdk.javadoc.doclet.DocletEnvironment.ModuleMode;
 45 import jdk.javadoc.internal.doclets.formats.html.markup.BodyContents;
 46 import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;
 47 import jdk.javadoc.internal.doclets.formats.html.markup.Entity;
 48 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
<span class="line-modified"> 49 import jdk.javadoc.internal.doclets.formats.html.markup.TagName;</span>
 50 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
<span class="line-modified"> 51 import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;</span>

 52 import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;
 53 import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;
 54 import jdk.javadoc.internal.doclets.formats.html.markup.Table;
 55 import jdk.javadoc.internal.doclets.formats.html.markup.TableHeader;
 56 import jdk.javadoc.internal.doclets.toolkit.Content;
 57 import jdk.javadoc.internal.doclets.toolkit.ModuleSummaryWriter;
 58 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
 59 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
 60 
 61 /**
 62  * Class to generate file for each module contents in the right-hand frame. This will list all the
 63  * required modules, packages and service types for the module. A click on any of the links will update
 64  * the frame with the clicked element page.
 65  *
 66  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 67  *  If you write code that depends on this, you do so at your own risk.
 68  *  This code and its internal interfaces are subject to change or
 69  *  deletion without notice.&lt;/b&gt;
 70  */
 71 public class ModuleWriterImpl extends HtmlDocletWriter implements ModuleSummaryWriter {
</pre>
<hr />
<pre>
176         this.navBar = new Navigation(mdle, configuration, PageMode.MODULE, path);
177         computeModulesData();
178     }
179 
180     /**
181      * Get the module header.
182      *
183      * @param heading the heading for the section
184      */
185     @Override
186     public Content getModuleHeader(String heading) {
187         HtmlTree bodyTree = getBody(getWindowTitle(mdle.getQualifiedName().toString()));
188         Content headerContent = new ContentBuilder();
189         addTop(headerContent);
190         navBar.setDisplaySummaryModuleDescLink(!utils.getFullBody(mdle).isEmpty() &amp;&amp; !options.noComment());
191         navBar.setDisplaySummaryModulesLink(display(requires) || display(indirectModules));
192         navBar.setDisplaySummaryPackagesLink(display(packages) || display(indirectPackages)
193                 || display(indirectOpenPackages));
194         navBar.setDisplaySummaryServicesLink(displayServices(uses, usesTrees) || displayServices(provides.keySet(), providesTrees));
195         navBar.setUserHeader(getUserHeaderFooter(true));
<span class="line-modified">196         headerContent.add(navBar.getContent(Navigation.Position.TOP));</span>
<span class="line-modified">197         HtmlTree div = new HtmlTree(TagName.DIV);</span>
198         div.setStyle(HtmlStyle.header);
<span class="line-modified">199         Content annotationContent = new HtmlTree(TagName.P);</span>
200         addAnnotationInfo(mdle, annotationContent);
201         div.add(annotationContent);
202         Content label = mdle.isOpen() &amp;&amp; (configuration.docEnv.getModuleMode() == ModuleMode.ALL)
203                 ? contents.openModuleLabel : contents.moduleLabel;
<span class="line-modified">204         Content tHeading = HtmlTree.HEADING_TITLE(Headings.PAGE_TITLE_HEADING,</span>
205                 HtmlStyle.title, label);
206         tHeading.add(Entity.NO_BREAK_SPACE);
207         Content moduleHead = new RawHtml(heading);
208         tHeading.add(moduleHead);
209         div.add(tHeading);
210         bodyContents.setHeader(headerContent)
211                 .addMainContent(div);
212         return bodyTree;
213     }
214 
215     /**
216      * Get the content header.
217      */
218     @Override
219     public Content getContentHeader() {
<span class="line-modified">220         return new ContentBuilder();</span>


221     }
222 
223     /**
224      * Get the summary section header.
225      */
226     @Override
227     public Content getSummaryHeader() {
<span class="line-modified">228         HtmlTree ul = new HtmlTree(TagName.UL);</span>
229         ul.setStyle(HtmlStyle.blockList);
230         return ul;
231     }
232 
233     /**
234      * Get the summary tree.
235      *
236      * @param summaryContentTree the content tree to be added to the summary tree.
237      */
238     @Override
239     public Content getSummaryTree(Content summaryContentTree) {
240         return HtmlTree.SECTION(HtmlStyle.summary, summaryContentTree);
241     }
242 
243     /**
244      * Compute the modules data that will be displayed in various tables on the module summary page.
245      */
246     public void computeModulesData() {
247         CommentHelper ch = utils.getCommentHelper(mdle);
248         // Get module dependencies using the module&#39;s transitive closure.
249         Map&lt;ModuleElement, String&gt; dependentModules = utils.getDependentModules(mdle);
250         // Add all dependent modules to indirect modules set. We will remove the modules,
251         // listed using the requires directive, from this set to come up with the table of indirect
252         // required modules.
253         dependentModules.forEach((module, mod) -&gt; {
254             if (shouldDocument(module)) {
255                 indirectModules.put(module, new StringContent(mod));
256             }
257         });
<span class="line-modified">258         ElementFilter.requiresIn(mdle.getDirectives()).forEach(directive -&gt; {</span>
259             ModuleElement m = directive.getDependency();
260             if (shouldDocument(m)) {
261                 if (moduleMode == ModuleMode.ALL || directive.isTransitive()) {
262                     requires.put(m, new StringContent(utils.getModifiers(directive)));
<span class="line-modified">263                 } else {</span>
264                     // For api mode, just keep the public requires in dependentModules for display of
265                     // indirect packages in the &quot;Packages&quot; section.
266                     dependentModules.remove(m);
267                 }
268                 indirectModules.remove(m);
<span class="line-modified">269             }</span>
270         });
271 
272         // Get all packages if module is open or if displaying concealed modules
273         for (PackageElement pkg : utils.getModulePackageMap().getOrDefault(mdle, Collections.emptySet())) {
274             if (shouldDocument(pkg) &amp;&amp; (mdle.isOpen() || moduleMode == ModuleMode.ALL)) {
275                 PackageEntry e = new PackageEntry();
276                 if (mdle.isOpen()) {
277                     e.openedTo = Collections.emptySet();
278                 }
279                 packages.put(pkg, e);
280             }
281         }
282 
283         // Get all exported packages for the module, using the exports directive for the module.
284         for (ModuleElement.ExportsDirective directive : ElementFilter.exportsIn(mdle.getDirectives())) {
285             PackageElement p = directive.getPackage();
286             if (shouldDocument(p)) {
287                 List&lt;? extends ModuleElement&gt; targetMdles = directive.getTargetModules();
288                 // Include package if in details mode, or exported to all (i.e. targetModules == null)
289                 if (moduleMode == ModuleMode.ALL || targetMdles == null) {
</pre>
<hr />
<pre>
301         // If it is an open module, there will be no separate opens directives.
302         for (ModuleElement.OpensDirective directive : ElementFilter.opensIn(mdle.getDirectives())) {
303             PackageElement p = directive.getPackage();
304             if (shouldDocument(p)) {
305                 List&lt;? extends ModuleElement&gt; targetMdles = directive.getTargetModules();
306                 // Include package if in details mode, or opened to all (i.e. targetModules == null)
307                 if (moduleMode == ModuleMode.ALL || targetMdles == null) {
308                     PackageEntry packageEntry = packages.computeIfAbsent(p, pkg -&gt; new PackageEntry());
309                     SortedSet&lt;ModuleElement&gt; mdleList = new TreeSet&lt;&gt;(utils.makeModuleComparator());
310                     if (targetMdles != null) {
311                         mdleList.addAll(targetMdles);
312                     }
313                     packageEntry.openedTo = mdleList;
314                 }
315             }
316         }
317 
318         // Get all the exported and opened packages, for the transitive closure of the module, to be displayed in
319         // the indirect packages tables.
320         dependentModules.forEach((module, mod) -&gt; {
<span class="line-modified">321             SortedSet&lt;PackageElement&gt; exportedPackages = new TreeSet&lt;&gt;(utils.makePackageComparator());</span>
<span class="line-modified">322             ElementFilter.exportsIn(module.getDirectives()).forEach(directive -&gt; {</span>
323                 PackageElement pkg = directive.getPackage();
324                 if (shouldDocument(pkg)) {
325                     // Qualified exports are not displayed in API mode
326                     if (moduleMode == ModuleMode.ALL || directive.getTargetModules() == null) {
<span class="line-modified">327                         exportedPackages.add(pkg);</span>
328                     }
329                 }
330             });
331             // If none of the indirect modules have exported packages to be displayed, we should not be
332             // displaying the table and so it should not be added to the map.
<span class="line-modified">333             if (!exportedPackages.isEmpty()) {</span>
<span class="line-modified">334                 indirectPackages.put(module, exportedPackages);</span>
335             }
<span class="line-modified">336             SortedSet&lt;PackageElement&gt; openPackages = new TreeSet&lt;&gt;(utils.makePackageComparator());</span>
337             if (module.isOpen()) {
<span class="line-modified">338                 openPackages.addAll(utils.getModulePackageMap().getOrDefault(module, Collections.emptySet()));</span>
339             } else {
<span class="line-modified">340                 ElementFilter.opensIn(module.getDirectives()).forEach(directive -&gt; {</span>
341                     PackageElement pkg = directive.getPackage();
342                     if (shouldDocument(pkg)) {
343                         // Qualified opens are not displayed in API mode
344                         if (moduleMode == ModuleMode.ALL || directive.getTargetModules() == null) {
<span class="line-modified">345                             openPackages.add(pkg);</span>
346                         }
347                     }
348                 });
349             }
350             // If none of the indirect modules have opened packages to be displayed, we should not be
351             // displaying the table and so it should not be added to the map.
<span class="line-modified">352             if (!openPackages.isEmpty()) {</span>
<span class="line-modified">353                 indirectOpenPackages.put(module, openPackages);</span>
354             }
355         });
356         // Get all the services listed as uses directive.
<span class="line-modified">357         ElementFilter.usesIn(mdle.getDirectives()).forEach(directive -&gt; {</span>
358             TypeElement u = directive.getService();
359             if (shouldDocument(u)) {
360                 uses.add(u);
361             }
362         });
363         // Get all the services and implementations listed as provides directive.
<span class="line-modified">364         ElementFilter.providesIn(mdle.getDirectives()).forEach(directive -&gt; {</span>
365             TypeElement u = directive.getService();
366             if (shouldDocument(u)) {
367                 List&lt;? extends TypeElement&gt; implList = directive.getImplementations();
368                 SortedSet&lt;TypeElement&gt; implSet = new TreeSet&lt;&gt;(utils.makeAllClassesComparator());
369                 implSet.addAll(implList);
370                 provides.put(u, implSet);
371             }
372         });
373         // Generate the map of all services listed using @provides, and the description.
<span class="line-modified">374         utils.getBlockTags(mdle, DocTree.Kind.PROVIDES).forEach(tree -&gt; {</span>
375             TypeElement t = ch.getServiceType(tree);
376             if (t != null) {
377                 providesTrees.put(t, commentTagsToContent(tree, mdle, ch.getDescription(tree), false, true));
378             }
379         });
380         // Generate the map of all services listed using @uses, and the description.
<span class="line-modified">381         utils.getBlockTags(mdle, DocTree.Kind.USES).forEach(tree -&gt; {</span>
382             TypeElement t = ch.getServiceType(tree);
383             if (t != null) {
384                 usesTrees.put(t, commentTagsToContent(tree, mdle, ch.getDescription(tree), false, true));
385             }
386         });
387     }
388 
389     /**
390      * Returns true if the element should be documented on the module summary page.
391      *
392      * @param element the element to be checked
393      * @return true if the element should be documented
394      */
395     public boolean shouldDocument(Element element) {
396         return (moduleMode == ModuleMode.ALL || utils.isIncluded(element));
397     }
398 
399     /**
400      * Returns true if there are elements to be displayed.
401      *
</pre>
<hr />
<pre>
406         return section != null &amp;&amp; !section.isEmpty();
407     }
408 
409     /**
410      * Returns true if there are elements to be displayed.
411      *
412      * @param section map of elements.
413      * @return true if there are elements to be displayed
414      */
415     public boolean display(Map&lt;? extends Element, ?&gt; section) {
416         return section != null &amp;&amp; !section.isEmpty();
417     }
418 
419     /*
420      * Returns true, in API mode, if at least one type element in
421      * the typeElements set is referenced by a javadoc tag in tagsMap.
422      */
423     private boolean displayServices(Set&lt;TypeElement&gt; typeElements,
424                                     Map&lt;TypeElement, Content&gt; tagsMap) {
425         return typeElements != null &amp;&amp;
<span class="line-modified">426                 typeElements.stream().anyMatch(v -&gt; displayServiceDirective(v, tagsMap));</span>
427     }
428 
429     /*
430      * Returns true, in API mode, if the type element is referenced
431      * from a javadoc tag in tagsMap.
432      */
433     private boolean displayServiceDirective(TypeElement typeElement,
434                                             Map&lt;TypeElement, Content&gt; tagsMap) {
435         return moduleMode == ModuleMode.ALL || tagsMap.containsKey(typeElement);
436     }
437 
438     /**
439      * Add the summary header.
440      *
441      * @param startMarker the marker comment
442      * @param heading the heading for the section
443      * @param htmltree the content tree to which the information is added
444      */
445     public void addSummaryHeader(Content startMarker, Content heading,
446             Content htmltree) {
</pre>
<hr />
<pre>
483     }
484 
485     @Override
486     public void addModulesSummary(Content summaryContentTree) {
487         if (display(requires) || display(indirectModules)) {
488             TableHeader requiresTableHeader =
489                     new TableHeader(contents.modifierLabel, contents.moduleLabel,
490                             contents.descriptionLabel);
491             HtmlTree section = HtmlTree.SECTION(HtmlStyle.modulesSummary)
492                     .setId(SectionName.MODULES.getName());
493             addSummaryHeader(MarkerComments.START_OF_MODULES_SUMMARY, contents.navModules, section);
494             if (display(requires)) {
495                 String text = resources.getText(&quot;doclet.Requires_Summary&quot;);
496                 String tableSummary = resources.getText(&quot;doclet.Member_Table_Summary&quot;,
497                         text,
498                         resources.getText(&quot;doclet.modules&quot;));
499                 Content caption = getTableCaption(new StringContent(text));
500                 Table table = getTable3(caption, tableSummary, HtmlStyle.requiresSummary,
501                             requiresTableHeader);
502                 addModulesList(requires, table);
<span class="line-modified">503                 section.add(table);</span>
504             }
505             // Display indirect modules table in both &quot;api&quot; and &quot;all&quot; mode.
506             if (display(indirectModules)) {
507                 String amrText = resources.getText(&quot;doclet.Indirect_Requires_Summary&quot;);
508                 String amrTableSummary = resources.getText(&quot;doclet.Member_Table_Summary&quot;,
509                         amrText,
510                         resources.getText(&quot;doclet.modules&quot;));
511                 Content amrCaption = getTableCaption(new StringContent(amrText));
512                 Table amrTable = getTable3(amrCaption, amrTableSummary, HtmlStyle.requiresSummary,
513                             requiresTableHeader);
514                 addModulesList(indirectModules, amrTable);
<span class="line-modified">515                 section.add(amrTable);</span>
516             }
517             summaryContentTree.add(HtmlTree.LI(HtmlStyle.blockList, section));
518         }
519     }
520 
521     /**
522      * Add the list of modules.
523      *
524      * @param mdleMap map of modules and modifiers
525      * @param table the table to which the list will be added
526      */
527     private void addModulesList(Map&lt;ModuleElement, Content&gt; mdleMap, Table table) {
528         for (ModuleElement m : mdleMap.keySet()) {
529             Content modifiers = mdleMap.get(m);
530             Content moduleLink = getModuleLink(m, new StringContent(m.getQualifiedName()));
531             Content moduleSummary = new ContentBuilder();
532             addSummaryComment(m, moduleSummary);
533             table.addRow(modifiers, moduleLink, moduleSummary);
534         }
535     }
536 
537     @Override
538     public void addPackagesSummary(Content summaryContentTree) {
539         if (display(packages)
540                 || display(indirectPackages) || display(indirectOpenPackages)) {
541             HtmlTree section = HtmlTree.SECTION(HtmlStyle.packagesSummary)
542                     .setId(SectionName.PACKAGES.getName());;
543             addSummaryHeader(MarkerComments.START_OF_PACKAGES_SUMMARY, contents.navPackages, section);
544             if (display(packages)) {
545                 addPackageSummary(section);
546             }
547             TableHeader indirectPackagesHeader =
548                     new TableHeader(contents.fromLabel, contents.packagesLabel);
549             if (display(indirectPackages)) {
550                 String aepText = resources.getText(&quot;doclet.Indirect_Exports_Summary&quot;);
551                 Table aepTable = getTable2(new StringContent(aepText),
552                         HtmlStyle.packagesSummary, indirectPackagesHeader);
553                 addIndirectPackages(aepTable, indirectPackages);
<span class="line-modified">554                 section.add(aepTable);</span>
555             }
556             if (display(indirectOpenPackages)) {
557                 String aopText = resources.getText(&quot;doclet.Indirect_Opens_Summary&quot;);
558                 Table aopTable = getTable2(new StringContent(aopText), HtmlStyle.packagesSummary,
559                         indirectPackagesHeader);
560                 addIndirectPackages(aopTable, indirectOpenPackages);
<span class="line-modified">561                 section.add(aopTable);</span>
562             }
563             summaryContentTree.add(HtmlTree.LI(HtmlStyle.blockList, section));
564         }
565     }
566 
567     /**
568      * Add the package summary for the module.
569      *
570      * @param li
571      */
572     public void addPackageSummary(HtmlTree li) {
573         Table table = new Table(HtmlStyle.packagesSummary)
574                 .setDefaultTab(resources.getText(&quot;doclet.All_Packages&quot;))
575                 .addTab(resources.getText(&quot;doclet.Exported_Packages_Summary&quot;), this::isExported)
576                 .addTab(resources.getText(&quot;doclet.Opened_Packages_Summary&quot;), this::isOpened)
577                 .addTab(resources.getText(&quot;doclet.Concealed_Packages_Summary&quot;), this::isConcealed)
578                 .setTabScript(i -&gt; String.format(&quot;show(%d);&quot;, i));
579 
580         // Determine whether to show the &quot;Exported To&quot; and &quot;Opened To&quot; columns,
581         // based on whether such columns would provide &quot;useful&quot; info.
</pre>
<hr />
<pre>
628         for (Map.Entry&lt;PackageElement, PackageEntry&gt; e : packages.entrySet()) {
629             PackageElement pkg = e.getKey();
630             PackageEntry entry = e.getValue();
631             List&lt;Content&gt; row = new ArrayList&lt;&gt;();
632             Content pkgLinkContent = getPackageLink(pkg, new StringContent(utils.getPackageName(pkg)));
633             row.add(pkgLinkContent);
634 
635             if (showExportedTo) {
636                 row.add(getPackageExportOpensTo(entry.exportedTo));
637             }
638             if (showOpenedTo) {
639                 row.add(getPackageExportOpensTo(entry.openedTo));
640             }
641             Content summary = new ContentBuilder();
642             addSummaryComment(pkg, summary);
643             row.add(summary);
644 
645             table.addRow(pkg, row);
646         }
647 
<span class="line-modified">648         li.add(table);</span>
649         if (table.needsScript()) {
650             mainBodyScript.append(table.getScript());
651         }
652     }
653 
654     private boolean isExported(Element e) {
655         PackageEntry entry = packages.get((PackageElement) e);
656         return (entry != null) &amp;&amp; (entry.exportedTo != null);
657     }
658 
659     private boolean isOpened(Element e) {
660         PackageEntry entry = packages.get((PackageElement) e);
661         return (entry != null) &amp;&amp; (entry.openedTo != null);
662     }
663 
664     private boolean isConcealed(Element e) {
665         PackageEntry entry = packages.get((PackageElement) e);
666         return (entry != null) &amp;&amp; (entry.exportedTo == null) &amp;&amp; (entry.openedTo == null);
667     }
668 
</pre>
<hr />
<pre>
706     }
707 
708     @Override
709     public void addServicesSummary(Content summaryContentTree) {
710 
711         boolean haveUses = displayServices(uses, usesTrees);
712         boolean haveProvides = displayServices(provides.keySet(), providesTrees);
713 
714         if (haveProvides || haveUses) {
715             HtmlTree section = HtmlTree.SECTION(HtmlStyle.servicesSummary)
716                     .setId(SectionName.SERVICES.getName());
717             addSummaryHeader(MarkerComments.START_OF_SERVICES_SUMMARY, contents.navServices, section);
718             TableHeader usesProvidesTableHeader =
719                     new TableHeader(contents.typeLabel, contents.descriptionLabel);
720             if (haveProvides) {
721                 String label = resources.getText(&quot;doclet.Provides_Summary&quot;);
722                 Table table = getTable2(new StringContent(label), HtmlStyle.providesSummary,
723                         usesProvidesTableHeader);
724                 addProvidesList(table);
725                 if (!table.isEmpty()) {
<span class="line-modified">726                     section.add(table);</span>
727                 }
728             }
729             if (haveUses){
730                 String label = resources.getText(&quot;doclet.Uses_Summary&quot;);
731                 Table table = getTable2(new StringContent(label), HtmlStyle.usesSummary,
732                         usesProvidesTableHeader);
733                 addUsesList(table);
734                 if (!table.isEmpty()) {
<span class="line-modified">735                     section.add(table);</span>
736                 }
737             }
738             summaryContentTree.add(HtmlTree.LI(HtmlStyle.blockList, section));
739         }
740     }
741 
742     /**
743      * Add the uses list for the module.
744      *
745      * @param table the table to which the services used will be added
746      */
747     public void addUsesList(Table table) {
748         Content typeLinkContent;
749         Content description;
750         for (TypeElement t : uses) {
751             if (!displayServiceDirective(t, usesTrees)) {
752                 continue;
753             }
754             typeLinkContent = getLink(new LinkInfoImpl(configuration, LinkInfoImpl.Kind.PACKAGE, t));
755             Content summary = new ContentBuilder();
</pre>
<hr />
<pre>
776         SortedSet&lt;TypeElement&gt; implSet;
777         Content description;
778         for (Map.Entry&lt;TypeElement, SortedSet&lt;TypeElement&gt;&gt; entry : provides.entrySet()) {
779             TypeElement srv = entry.getKey();
780             if (!displayServiceDirective(srv, providesTrees)) {
781                 continue;
782             }
783             implSet = entry.getValue();
784             Content srvLinkContent = getLink(new LinkInfoImpl(configuration, LinkInfoImpl.Kind.PACKAGE, srv));
785             Content desc = new ContentBuilder();
786             if (display(providesTrees)) {
787                 description = providesTrees.get(srv);
788                 desc.add((description != null &amp;&amp; !description.isEmpty())
789                         ? HtmlTree.DIV(HtmlStyle.block, description)
790                         : Entity.NO_BREAK_SPACE);
791             } else {
792                 desc.add(Entity.NO_BREAK_SPACE);
793                 }
794             // Only display the implementation details in the &quot;all&quot; mode.
795             if (moduleMode == ModuleMode.ALL &amp;&amp; !implSet.isEmpty()) {
<span class="line-modified">796                 desc.add(new HtmlTree(TagName.BR));</span>
797                 desc.add(&quot;(&quot;);
798                 HtmlTree implSpan = HtmlTree.SPAN(HtmlStyle.implementationLabel, contents.implementation);
799                 desc.add(implSpan);
800                 desc.add(Entity.NO_BREAK_SPACE);
801                 String sep = &quot;&quot;;
802                 for (TypeElement impl : implSet) {
803                     desc.add(sep);
804                     desc.add(getLink(new LinkInfoImpl(configuration, LinkInfoImpl.Kind.PACKAGE, impl)));
805                     sep = &quot;, &quot;;
806                 }
807                 desc.add(&quot;)&quot;);
808             }
809             table.addRow(srvLinkContent, desc);
810         }
811     }
812 
813     /**
814      * Add the module deprecation information to the documentation tree.
815      *
816      * @param div the content tree to which the deprecation information will be added
817      */
818     public void addDeprecationInfo(Content div) {
819         List&lt;? extends DocTree&gt; deprs = utils.getBlockTags(mdle, DocTree.Kind.DEPRECATED);
820         if (utils.isDeprecated(mdle)) {
821             CommentHelper ch = utils.getCommentHelper(mdle);
<span class="line-modified">822             HtmlTree deprDiv = new HtmlTree(TagName.DIV);</span>
823             deprDiv.setStyle(HtmlStyle.deprecationBlock);
824             Content deprPhrase = HtmlTree.SPAN(HtmlStyle.deprecatedLabel, getDeprecatedPhrase(mdle));
825             deprDiv.add(deprPhrase);
826             if (!deprs.isEmpty()) {
827                 List&lt;? extends DocTree&gt; commentTags = ch.getDescription(deprs.get(0));
828                 if (!commentTags.isEmpty()) {
829                     addInlineDeprecatedComment(mdle, deprs.get(0), deprDiv);
830                 }
831             }
832             div.add(deprDiv);
833         }
834     }
835 
836     @Override
837     public void addModuleDescription(Content moduleContentTree) {
838         if (!utils.getFullBody(mdle).isEmpty()) {
839             HtmlTree tree = HtmlTree.SECTION(HtmlStyle.moduleDescription);
840             tree.setId(SectionName.MODULE_DESCRIPTION.getName());
841             addDeprecationInfo(tree);
842             tree.add(MarkerComments.START_OF_MODULE_DESCRIPTION);
</pre>
<hr />
<pre>
844             moduleContentTree.add(tree);
845         }
846     }
847 
848     @Override
849     public void addModuleTags(Content moduleContentTree) {
850         Content tree = HtmlTree.SECTION(HtmlStyle.moduleTags);
851         addTagsInfo(mdle, tree);
852         moduleContentTree.add(tree);
853     }
854 
855     @Override
856     public void addModuleContent(Content moduleContentTree) {
857         bodyContents.addMainContent(moduleContentTree);
858     }
859 
860     @Override
861     public void addModuleFooter() {
862         Content htmlTree = HtmlTree.FOOTER();
863         navBar.setUserFooter(getUserHeaderFooter(false));
<span class="line-modified">864         htmlTree.add(navBar.getContent(Navigation.Position.BOTTOM));</span>
865         addBottom(htmlTree);
866         bodyContents.setFooter(htmlTree);
867     }
868 
869     @Override
870     public void printDocument(Content contentTree) throws DocFileIOException {
<span class="line-modified">871         contentTree.add(bodyContents);</span>
872         printHtmlDocument(configuration.metakeywords.getMetaKeywordsForModule(mdle),
873                 getDescription(&quot;declaration&quot;, mdle), getLocalStylesheets(mdle), contentTree);
874     }
875 
876     /**
877      * Add the module package deprecation information to the documentation tree.
878      *
879      * @param li the content tree to which the deprecation information will be added
880      * @param pkg the PackageDoc that is added
881      */
882     public void addPackageDeprecationInfo(Content li, PackageElement pkg) {
883         List&lt;? extends DocTree&gt; deprs;
884         if (utils.isDeprecated(pkg)) {
885             deprs = utils.getDeprecatedTrees(pkg);
<span class="line-modified">886             HtmlTree deprDiv = new HtmlTree(TagName.DIV);</span>
887             deprDiv.setStyle(HtmlStyle.deprecationBlock);
888             Content deprPhrase = HtmlTree.SPAN(HtmlStyle.deprecatedLabel, getDeprecatedPhrase(pkg));
889             deprDiv.add(deprPhrase);
890             if (!deprs.isEmpty()) {
891                 CommentHelper ch = utils.getCommentHelper(pkg);
892                 List&lt;? extends DocTree&gt; commentTags = ch.getDescription(deprs.get(0));
893                 if (!commentTags.isEmpty()) {
894                     addInlineDeprecatedComment(pkg, deprs.get(0), deprDiv);
895                 }
896             }
897             li.add(deprDiv);
898         }
899     }
900 }
</pre>
</td>
</tr>
</table>
<center><a href="ModuleIndexWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="PackageIndexWriter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
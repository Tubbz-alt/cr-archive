<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/Utils.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IndexBuilder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="VisibleMemberTable.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/Utils.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  78 import javax.lang.model.type.NoType;
  79 import javax.lang.model.type.PrimitiveType;
  80 import javax.lang.model.type.TypeMirror;
  81 import javax.lang.model.type.TypeVariable;
  82 import javax.lang.model.type.WildcardType;
  83 import javax.lang.model.util.ElementFilter;
  84 import javax.lang.model.util.ElementKindVisitor14;
  85 import javax.lang.model.util.Elements;
  86 import javax.lang.model.util.SimpleElementVisitor14;
  87 import javax.lang.model.util.SimpleTypeVisitor9;
  88 import javax.lang.model.util.TypeKindVisitor9;
  89 import javax.lang.model.util.Types;
  90 import javax.tools.FileObject;
  91 import javax.tools.JavaFileManager;
  92 import javax.tools.JavaFileManager.Location;
  93 import javax.tools.StandardLocation;
  94 
  95 import com.sun.source.doctree.DocCommentTree;
  96 import com.sun.source.doctree.DocTree;
  97 import com.sun.source.doctree.DocTree.Kind;

  98 import com.sun.source.doctree.ParamTree;
  99 import com.sun.source.doctree.SerialFieldTree;


 100 import com.sun.source.doctree.UnknownBlockTagTree;
 101 import com.sun.source.tree.CompilationUnitTree;
 102 import com.sun.source.tree.LineMap;
 103 import com.sun.source.util.DocSourcePositions;
 104 import com.sun.source.util.DocTrees;
 105 import com.sun.source.util.TreePath;
 106 import com.sun.tools.javac.model.JavacTypes;
 107 import jdk.javadoc.internal.doclets.formats.html.SearchIndexItem;
 108 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
 109 import jdk.javadoc.internal.doclets.toolkit.BaseOptions;
 110 import jdk.javadoc.internal.doclets.toolkit.CommentUtils.DocCommentDuo;
 111 import jdk.javadoc.internal.doclets.toolkit.Messages;
 112 import jdk.javadoc.internal.doclets.toolkit.Resources;
 113 import jdk.javadoc.internal.doclets.toolkit.WorkArounds;
 114 import jdk.javadoc.internal.doclets.toolkit.taglets.BaseTaglet;
 115 import jdk.javadoc.internal.doclets.toolkit.taglets.Taglet;
 116 import jdk.javadoc.internal.tool.DocEnvImpl;
 117 
 118 import static javax.lang.model.element.ElementKind.*;
 119 import static javax.lang.model.element.Modifier.*;
</pre>
<hr />
<pre>
 197     }
 198 
 199     public TypeMirror getDeprecatedType() {
 200         return getSymbol(&quot;java.lang.Deprecated&quot;);
 201     }
 202 
 203     public TypeMirror getFunctionalInterface() {
 204         return getSymbol(&quot;java.lang.FunctionalInterface&quot;);
 205     }
 206 
 207     /**
 208      * Return array of class members whose documentation is to be generated.
 209      * If the member is deprecated do not include such a member in the
 210      * returned array.
 211      *
 212      * @param  members    Array of members to choose from.
 213      * @return List       List of eligible members for whom
 214      *                    documentation is getting generated.
 215      */
 216     public List&lt;Element&gt; excludeDeprecatedMembers(List&lt;? extends Element&gt; members) {
<span class="line-modified"> 217         List&lt;Element&gt; excludeList = members.stream()</span>
<span class="line-modified"> 218                 .filter((member) -&gt; (!isDeprecated(member)))</span>
<span class="line-modified"> 219                 .sorted(makeGeneralPurposeComparator())</span>
<span class="line-modified"> 220                 .collect(Collectors.&lt;Element, List&lt;Element&gt;&gt;toCollection(ArrayList::new));</span>
<span class="line-removed"> 221         return excludeList;</span>
 222     }
 223 
 224     /**
 225      * Search for the given method in the given class.
 226      *
 227      * @param  te        Class to search into.
 228      * @param  method    Method to be searched.
 229      * @return ExecutableElement Method found, null otherwise.
 230      */
 231     public ExecutableElement findMethod(TypeElement te, ExecutableElement method) {
 232         for (Element m : getMethods(te)) {
<span class="line-modified"> 233             if (executableMembersEqual(method, (ExecutableElement)m)) {</span>
<span class="line-modified"> 234                 return (ExecutableElement)m;</span>
 235             }
 236         }
 237         return null;
 238     }
 239 
 240     /**
 241      * Test whether a class is a subclass of another class.
 242      *
 243      * @param t1 the candidate superclass.
 244      * @param t2 the target
 245      * @return true if t1 is a superclass of t2.
 246      */
 247     public boolean isSubclassOf(TypeElement t1, TypeElement t2) {
 248         return typeUtils.isSubtype(typeUtils.erasure(t1.asType()), typeUtils.erasure(t2.asType()));
 249     }
 250 
 251     /**
 252      * @param e1 the first method to compare.
 253      * @param e2 the second method to compare.
 254      * @return true if member1 overrides/hides or is overridden/hidden by member2.
 255      */
<span class="line-removed"> 256 </span>
 257     public boolean executableMembersEqual(ExecutableElement e1, ExecutableElement e2) {
 258         // TODO: investigate if Elements.hides(..) will work here.
 259         if (isStatic(e1) &amp;&amp; isStatic(e2)) {
 260             List&lt;? extends VariableElement&gt; parameters1 = e1.getParameters();
 261             List&lt;? extends VariableElement&gt; parameters2 = e2.getParameters();
 262             if (e1.getSimpleName().equals(e2.getSimpleName()) &amp;&amp;
 263                     parameters1.size() == parameters2.size()) {
 264                 int j;
 265                 for (j = 0 ; j &lt; parameters1.size(); j++) {
 266                     VariableElement v1 = parameters1.get(j);
 267                     VariableElement v2 = parameters2.get(j);
 268                     String t1 = getTypeName(v1.asType(), true);
 269                     String t2 = getTypeName(v2.asType(), true);
 270                     if (!(t1.equals(t2) ||
 271                             isTypeVariable(v1.asType()) || isTypeVariable(v2.asType()))) {
 272                         break;
 273                     }
 274                 }
 275                 if (j == parameters1.size()) {
<span class="line-modified"> 276                 return true;</span>
 277                 }
 278             }
 279             return false;
 280         } else {
 281             return elementUtils.overrides(e1, e2, getEnclosingTypeElement(e1)) ||
 282                     elementUtils.overrides(e2, e1, getEnclosingTypeElement(e2)) ||
 283                     e1.equals(e2);
 284         }
 285     }
 286 
 287     /**
 288      * According to
 289      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
 290      * all the outer classes and static inner classes are core classes.
 291      */
 292     public boolean isCoreClass(TypeElement e) {
 293         return getEnclosingTypeElement(e) == null || isStatic(e);
 294     }
 295 
 296     public Location getLocationForPackage(PackageElement pd) {
</pre>
<hr />
<pre>
 491         return new ElementKindVisitor14&lt;String, SortedSet&lt;Modifier&gt;&gt;() {
 492             final StringBuilder sb = new StringBuilder();
 493 
 494             void addVisibilityModifier(Set&lt;Modifier&gt; modifiers) {
 495                 if (modifiers.contains(PUBLIC)) {
 496                     append(&quot;public&quot;);
 497                 } else if (modifiers.contains(PROTECTED)) {
 498                     append(&quot;protected&quot;);
 499                 } else if (modifiers.contains(PRIVATE)) {
 500                     append(&quot;private&quot;);
 501                 }
 502             }
 503 
 504             void addStatic(Set&lt;Modifier&gt; modifiers) {
 505                 if (modifiers.contains(STATIC)) {
 506                     append(&quot;static&quot;);
 507                 }
 508             }
 509 
 510             void addModifiers(Set&lt;Modifier&gt; modifiers) {
<span class="line-modified"> 511                 modifiers.stream().map(Modifier::toString).forEach(this::append);</span>
 512             }
 513 
 514             void append(String s) {
 515                 if (sb.length() &gt; 0) {
 516                     sb.append(&quot; &quot;);
 517                 }
 518                 sb.append(s);
 519             }
 520 
 521             String finalString(String s) {
 522                 append(s);
 523                 if (trailingSpace) {
 524                     sb.append(&quot; &quot;);
<span class="line-modified"> 525                     }</span>
 526                 return sb.toString();
 527             }
 528 
 529             @Override
 530             public String visitTypeAsInterface(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 531                 addVisibilityModifier(mods);
 532                 addStatic(mods);
 533                 return finalString(&quot;interface&quot;);
 534             }
 535 
 536             @Override
 537             public String visitTypeAsEnum(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 538                 addVisibilityModifier(mods);
 539                 addStatic(mods);
 540                 return finalString(&quot;enum&quot;);
 541             }
 542 
 543             @Override
 544             public String visitTypeAsAnnotationType(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 545                 addVisibilityModifier(mods);
</pre>
<hr />
<pre>
 648               case LOCAL_VARIABLE: case PARAMETER:
 649               case RESOURCE_VARIABLE:
 650                   return true;
 651               default:
 652                   return false;
 653         }
 654     }
 655 
 656     public boolean isTypeElement(Element e) {
 657         switch (e.getKind()) {
 658             case CLASS: case ENUM: case INTERFACE: case ANNOTATION_TYPE: case RECORD:
 659                 return true;
 660             default:
 661                 return false;
 662         }
 663     }
 664 
 665     /**
 666      * Get the signature. It is the parameter list, type is qualified.
 667      * For instance, for a method {@code mymethod(String x, int y)},
<span class="line-modified"> 668      * it will return {@code(java.lang.String,int)}.</span>
 669      *
 670      * @param e
 671      * @return String
 672      */
 673     public String signature(ExecutableElement e) {
 674         return makeSignature(e, true);
 675     }
 676 
 677     /**
 678      * Get flat signature.  All types are not qualified.
 679      * Return a String, which is the flat signature of this member.
 680      * It is the parameter list, type is not qualified.
 681      * For instance, for a method {@code mymethod(String x, int y)},
 682      * it will return {@code (String, int)}.
 683      */
 684     public String flatSignature(ExecutableElement e) {
 685         return makeSignature(e, false);
 686     }
 687 
 688     public String makeSignature(ExecutableElement e, boolean full) {
</pre>
<hr />
<pre>
 912             TypeElement te = asTypeElement(t);
 913             if (te == null) {
 914                 return null;
 915             }
 916             VisibleMemberTable vmt = configuration.getVisibleMemberTable(te);
 917             for (Element e : vmt.getMembers(VisibleMemberTable.Kind.METHODS)) {
 918                 ExecutableElement ee = (ExecutableElement)e;
 919                 if (configuration.workArounds.overrides(method, ee, origin) &amp;&amp;
 920                         !isSimpleOverride(ee)) {
 921                     return ee;
 922                 }
 923             }
 924             if (t.equals(getObjectType()))
 925                 return null;
 926         }
 927         return null;
 928     }
 929 
 930     public SortedSet&lt;TypeElement&gt; getTypeElementsAsSortedSet(Iterable&lt;TypeElement&gt; typeElements) {
 931         SortedSet&lt;TypeElement&gt; set = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());
<span class="line-modified"> 932         for (TypeElement te : typeElements) {</span>
<span class="line-removed"> 933             set.add(te);</span>
<span class="line-removed"> 934         }</span>
 935         return set;
 936     }
 937 
 938     public List&lt;? extends DocTree&gt; getSerialDataTrees(ExecutableElement member) {
 939         return getBlockTags(member, SERIAL_DATA);
 940     }
 941 
 942     public FileObject getFileObject(TypeElement te) {
 943         return docTrees.getPath(te).getCompilationUnit().getSourceFile();
 944     }
 945 
 946     public TypeMirror getDeclaredType(TypeElement enclosing, TypeMirror target) {
 947         return getDeclaredType(Collections.emptyList(), enclosing, target);
 948     }
 949 
 950     /**
 951      * Finds the declaration of the enclosing&#39;s type parameter.
 952      *
 953      * @param values
 954      * @param enclosing a TypeElement whose type arguments  we desire
</pre>
<hr />
<pre>
1230             }
1231         }.visit(t);
1232     }
1233 
1234     public TypeMirror getComponentType(TypeMirror t) {
1235         while (isArrayType(t)) {
1236             t = ((ArrayType) t).getComponentType();
1237         }
1238         return t;
1239     }
1240 
1241     /**
1242      * Return the type&#39;s dimension information, as a string.
1243      * &lt;p&gt;
1244      * For example, a two dimensional array of String returns &quot;{@code [][]}&quot;.
1245      *
1246      * @return the type&#39;s dimension information as a string.
1247      */
1248     public String getDimension(TypeMirror t) {
1249         return new SimpleTypeVisitor9&lt;String, Void&gt;() {
<span class="line-modified">1250             StringBuilder dimension = new StringBuilder(&quot;&quot;);</span>
1251             @Override
1252             public String visitArray(ArrayType t, Void p) {
1253                 dimension.append(&quot;[]&quot;);
1254                 return visit(t.getComponentType());
1255             }
1256 
1257             @Override
1258             protected String defaultAction(TypeMirror e, Void p) {
1259                 return dimension.toString();
1260             }
1261 
1262         }.visit(t);
1263     }
1264 
1265     public TypeElement getSuperClass(TypeElement te) {
1266         if (isInterface(te) || isAnnotationType(te) ||
1267                 te.asType().equals(getObjectType())) {
1268             return null;
1269         }
1270         TypeMirror superclass = te.getSuperclass();
</pre>
<hr />
<pre>
1317                     || supersuperClass.getQualifiedName().equals(superClass.getQualifiedName())) {
1318                 break;
1319             }
1320             superType = supersuperType;
1321             superClass = supersuperClass;
1322         }
1323         if (te.asType().equals(superType)) {
1324             return null;
1325         }
1326         return superType;
1327     }
1328 
1329     /**
1330      * Given a TypeElement, return the name of its type (Class, Interface, etc.).
1331      *
1332      * @param te the TypeElement to check.
1333      * @param lowerCaseOnly true if you want the name returned in lower case.
1334      *                      If false, the first letter of the name is capitalized.
1335      * @return
1336      */
<span class="line-removed">1337 </span>
1338     public String getTypeElementName(TypeElement te, boolean lowerCaseOnly) {
1339         String typeName = &quot;&quot;;
1340         if (isInterface(te)) {
1341             typeName = &quot;doclet.Interface&quot;;
1342         } else if (isException(te)) {
1343             typeName = &quot;doclet.Exception&quot;;
1344         } else if (isError(te)) {
1345             typeName = &quot;doclet.Error&quot;;
1346         } else if (isAnnotationType(te)) {
1347             typeName = &quot;doclet.AnnotationType&quot;;
1348         } else if (isEnum(te)) {
1349             typeName = &quot;doclet.Enum&quot;;
1350         } else if (isOrdinaryClass(te)) {
1351             typeName = &quot;doclet.Class&quot;;
1352         }
1353         typeName = lowerCaseOnly ? toLowerCase(typeName) : typeName;
1354         return typeNameMap.computeIfAbsent(typeName, resources::getText);
1355     }
1356 
1357     private final Map&lt;String, String&gt; typeNameMap = new HashMap&lt;&gt;();
</pre>
<hr />
<pre>
1642     public int compareCaseCompare(String s1, String s2) {
1643         return compareStrings(false, s1, s2);
1644     }
1645 
1646     private DocCollator tertiaryCollator = null;
1647     private DocCollator secondaryCollator = null;
1648 
1649     private int compareStrings(boolean caseSensitive, String s1, String s2) {
1650         if (caseSensitive) {
1651             if (tertiaryCollator == null) {
1652                 tertiaryCollator = new DocCollator(configuration.locale, Collator.TERTIARY);
1653             }
1654             return tertiaryCollator.compare(s1, s2);
1655         }
1656         if (secondaryCollator == null) {
1657             secondaryCollator = new DocCollator(configuration.locale, Collator.SECONDARY);
1658         }
1659         return secondaryCollator.compare(s1, s2);
1660     }
1661 


































1662     private static class DocCollator {
1663         private final Map&lt;String, CollationKey&gt; keys;
1664         private final Collator instance;
1665         private final int MAX_SIZE = 1000;
1666         private DocCollator(Locale locale, int strength) {
1667             instance = createCollator(locale);
1668             instance.setStrength(strength);
1669 
1670             keys = new LinkedHashMap&lt;String, CollationKey&gt;(MAX_SIZE + 1, 0.75f, true) {
1671                 private static final long serialVersionUID = 1L;
1672                 @Override
1673                 protected boolean removeEldestEntry(Entry&lt;String, CollationKey&gt; eldest) {
1674                     return size() &gt; MAX_SIZE;
1675                 }
1676             };
1677         }
1678 
1679         CollationKey getKey(String s) {
1680             return keys.computeIfAbsent(s, instance :: getCollationKey);
1681         }
</pre>
<hr />
<pre>
1785     public Comparator&lt;SerialFieldTree&gt; makeSerialFieldTreeComparator() {
1786         if (serialFieldTreeComparator == null) {
1787             serialFieldTreeComparator = (SerialFieldTree o1, SerialFieldTree o2) -&gt; {
1788                 String s1 = o1.getName().toString();
1789                 String s2 = o2.getName().toString();
1790                 return s1.compareTo(s2);
1791             };
1792         }
1793         return serialFieldTreeComparator;
1794     }
1795 
1796     /**
1797      * Returns a general purpose comparator.
1798      * @return a Comparator
1799      */
1800     public Comparator&lt;Element&gt; makeGeneralPurposeComparator() {
1801         return makeClassUseComparator();
1802     }
1803 
1804     private Comparator&lt;Element&gt; overrideUseComparator = null;

1805     /**
1806      * Returns a Comparator for overrides and implements,
1807      * used primarily on methods, compares the name first,
1808      * then compares the simple names of the enclosing
1809      * TypeElement and the fully qualified name of the enclosing TypeElement.
1810      * @return a Comparator
1811      */
1812     public Comparator&lt;Element&gt; makeOverrideUseComparator() {
1813         if (overrideUseComparator == null) {
1814             overrideUseComparator = new Utils.ElementComparator() {
1815                 @Override
1816                 public int compare(Element o1, Element o2) {
1817                     int result = compareStrings(getSimpleName(o1), getSimpleName(o2));
1818                     if (result != 0) {
1819                         return result;
1820                     }
1821                     if (!isTypeElement(o1) &amp;&amp; !isTypeElement(o2) &amp;&amp; !isPackage(o1) &amp;&amp; !isPackage(o2)) {
1822                         TypeElement t1 = getEnclosingTypeElement(o1);
1823                         TypeElement t2 = getEnclosingTypeElement(o2);
1824                         result = compareStrings(getSimpleName(t1), getSimpleName(t2));
</pre>
<hr />
<pre>
1994             }
1995 
1996             @Override
1997             public String visitPackage(PackageElement e, Void p) {
1998                 return e.getQualifiedName().toString();
1999             }
2000 
2001             @Override
2002             public String visitType(TypeElement e, Void p) {
2003                 return e.getQualifiedName().toString();
2004             }
2005 
2006             @Override
2007             protected String defaultAction(Element e, Void p) {
2008                 return outer ? visit(e.getEnclosingElement()) : e.getSimpleName().toString();
2009             }
2010         }.visit(e);
2011     }
2012 
2013     private Comparator&lt;Element&gt; classUseComparator = null;

2014     /**
2015      * Comparator for ClassUse presentations, and sorts as follows:
2016      * 1. member names
2017      * 2. then fully qualified member names
2018      * 3. then parameter types if applicable
2019      * 4. finally the element kinds ie. package, class, interface etc.
2020      * @return a comparator to sort classes and members for class use
2021      */
2022     public Comparator&lt;Element&gt; makeClassUseComparator() {
2023         if (classUseComparator == null) {
2024             classUseComparator = new Utils.ElementComparator() {
2025                 /**
2026                  * Compares two Elements.
2027                  *
2028                  * @param e1 - an element.
2029                  * @param e2 - an element.
2030                  * @return a negative integer, zero, or a positive integer as the first
2031                  * argument is less than, equal to, or greater than the second.
2032                  */
2033                 @Override
</pre>
<hr />
<pre>
2325     public List&lt;ExecutableElement&gt; getMethods(Element e) {
2326         return convertToExecutableElement(getItems(e, true, METHOD));
2327     }
2328 
2329     List&lt;ExecutableElement&gt; getMethodsUnfiltered(Element e) {
2330         return convertToExecutableElement(getItems(e, false, METHOD));
2331     }
2332 
2333     public int getOrdinalValue(VariableElement member) {
2334         if (member == null || member.getKind() != ENUM_CONSTANT) {
2335             throw new IllegalArgumentException(&quot;must be an enum constant: &quot; + member);
2336         }
2337         return member.getEnclosingElement().getEnclosedElements().indexOf(member);
2338     }
2339 
2340     private Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; modulePackageMap = null;
2341     public Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; getModulePackageMap() {
2342         if (modulePackageMap == null) {
2343             modulePackageMap = new HashMap&lt;&gt;();
2344             Set&lt;PackageElement&gt; pkgs = configuration.getIncludedPackageElements();
<span class="line-modified">2345             pkgs.forEach((pkg) -&gt; {</span>
2346                 ModuleElement mod = elementUtils.getModuleOf(pkg);
2347                 modulePackageMap.computeIfAbsent(mod, m -&gt; new HashSet&lt;&gt;()).add(pkg);
2348             });
2349         }
2350         return modulePackageMap;
2351     }
2352 
2353     public Map&lt;ModuleElement, String&gt; getDependentModules(ModuleElement mdle) {
2354         Map&lt;ModuleElement, String&gt; result = new TreeMap&lt;&gt;(makeModuleComparator());
2355         Deque&lt;ModuleElement&gt; queue = new ArrayDeque&lt;&gt;();
2356         // get all the requires for the element in question
2357         for (RequiresDirective rd : ElementFilter.requiresIn(mdle.getDirectives())) {
2358             ModuleElement dep = rd.getDependency();
2359             // add the dependency to work queue
2360             if (!result.containsKey(dep)) {
2361                 if (rd.isTransitive()) {
2362                     queue.addLast(dep);
2363                 }
2364             }
2365             // add all exports for the primary module
2366             result.put(rd.getDependency(), getModifiers(rd));
2367         }
2368 
2369         // add only requires public for subsequent module dependencies
2370         for (ModuleElement m = queue.poll(); m != null; m = queue.poll()) {
2371             for (RequiresDirective rd : ElementFilter.requiresIn(m.getDirectives())) {
2372                 ModuleElement dep = rd.getDependency();
2373                 if (!result.containsKey(dep)) {
2374                     if (rd.isTransitive()) {
2375                         result.put(dep, getModifiers(rd));
2376                         queue.addLast(dep);
2377                     }
2378                 }
2379             }
2380         }
2381         return result;
2382     }
2383 
2384     public String getModifiers(RequiresDirective rd) {
2385         StringBuilder modifiers = new StringBuilder();
<span class="line-modified">2386         String sep=&quot;&quot;;</span>
2387         if (rd.isTransitive()) {
2388             modifiers.append(&quot;transitive&quot;);
2389             sep = &quot; &quot;;
2390         }
2391         if (rd.isStatic()) {
2392             modifiers.append(sep);
2393             modifiers.append(&quot;static&quot;);
2394         }
2395         return (modifiers.length() == 0) ? &quot; &quot; : modifiers.toString();
2396     }
2397 
2398     public long getLineNumber(Element e) {
2399         TreePath path = getTreePath(e);
2400         if (path == null) { // maybe null if synthesized
2401             TypeElement encl = getEnclosingTypeElement(e);
2402             path = getTreePath(encl);
2403         }
2404         CompilationUnitTree cu = path.getCompilationUnit();
2405         LineMap lineMap = cu.getLineMap();
2406         DocSourcePositions spos = docTrees.getSourcePositions();
</pre>
<hr />
<pre>
3255     public List&lt;? extends ParamTree&gt; getTypeParamTrees(Element element) {
3256         return getParamTrees(element, true);
3257     }
3258 
3259     public List&lt;? extends ParamTree&gt; getParamTrees(Element element) {
3260         return getParamTrees(element, false);
3261     }
3262 
3263     private  List&lt;? extends ParamTree&gt; getParamTrees(Element element, boolean isTypeParameters) {
3264         List&lt;ParamTree&gt; out = new ArrayList&lt;&gt;();
3265         for (DocTree dt : getBlockTags(element, PARAM)) {
3266             ParamTree pt = (ParamTree) dt;
3267             if (pt.isTypeParameter() == isTypeParameters) {
3268                 out.add(pt);
3269             }
3270         }
3271         return out;
3272     }
3273 
3274     public  List&lt;? extends DocTree&gt; getReturnTrees(Element element) {
<span class="line-modified">3275         List&lt;DocTree&gt; out = new ArrayList&lt;&gt;();</span>
<span class="line-removed">3276         for (DocTree dt : getBlockTags(element, RETURN)) {</span>
<span class="line-removed">3277             out.add(dt);</span>
<span class="line-removed">3278         }</span>
<span class="line-removed">3279         return out;</span>
3280     }
3281 
3282     public List&lt;? extends DocTree&gt; getUsesTrees(Element element) {
3283         return getBlockTags(element, USES);
3284     }
3285 
3286     public List&lt;? extends DocTree&gt; getFirstSentenceTrees(Element element) {
3287         DocCommentTree dcTree = getDocCommentTree(element);
3288         if (dcTree == null) {
3289             return Collections.emptyList();
3290         }
<span class="line-modified">3291         List&lt;DocTree&gt; out = new ArrayList&lt;&gt;();</span>
<span class="line-removed">3292         for (DocTree dt : dcTree.getFirstSentence()) {</span>
<span class="line-removed">3293             out.add(dt);</span>
<span class="line-removed">3294         }</span>
<span class="line-removed">3295         return out;</span>
3296     }
3297 
3298     public ModuleElement containingModule(Element e) {
3299         return elementUtils.getModuleOf(e);
3300     }
3301 
3302     public PackageElement containingPackage(Element e) {
3303         return elementUtils.getPackageOf(e);
3304     }
3305 
3306     public TypeElement getTopMostContainingTypeElement(Element e) {
3307         if (isPackage(e)) {
3308             return null;
3309         }
3310         TypeElement outer = getEnclosingTypeElement(e);
3311         if (outer == null)
3312             return (TypeElement)e;
3313         while (outer != null &amp;&amp; outer.getNestingKind().isNested()) {
3314             outer = getEnclosingTypeElement(outer);
3315         }
</pre>
<hr />
<pre>
3344             SoftReference&lt;CommentHelper&gt; value = map.get(key);
3345             return value == null ? null : value.get();
3346         }
3347 
3348         public CommentHelper computeIfAbsent(Element key) {
3349             SoftReference&lt;CommentHelper&gt; refValue = map.get(key);
3350             if (refValue != null) {
3351                 CommentHelper value = refValue.get();
3352                 if (value != null) {
3353                     return value;
3354                 }
3355             }
3356             CommentHelper newValue = new CommentHelper(utils.configuration, key, utils.getTreePath(key),
3357                     utils.getDocCommentTree(key));
3358             map.put(key, new SoftReference&lt;&gt;(newValue));
3359             return newValue;
3360         }
3361     }
3362 
3363     /**
<span class="line-modified">3364      * A simple pair container.</span>
<span class="line-modified">3365      * @param &lt;K&gt; first a value</span>
<span class="line-modified">3366      * @param &lt;L&gt; second another value</span>

3367      */
3368     public static class Pair&lt;K, L&gt; {
3369         public final K first;
3370         public final L second;
3371 
3372         public Pair(K first, L second) {
3373             this.first = first;
3374             this.second = second;
3375         }
3376 
3377         @Override
3378         public String toString() {
<span class="line-modified">3379             StringBuffer out = new StringBuffer();</span>
<span class="line-removed">3380             out.append(first + &quot;:&quot; + second);</span>
<span class="line-removed">3381             return out.toString();</span>
3382         }
3383     }
3384 }
</pre>
</td>
<td>
<hr />
<pre>
  78 import javax.lang.model.type.NoType;
  79 import javax.lang.model.type.PrimitiveType;
  80 import javax.lang.model.type.TypeMirror;
  81 import javax.lang.model.type.TypeVariable;
  82 import javax.lang.model.type.WildcardType;
  83 import javax.lang.model.util.ElementFilter;
  84 import javax.lang.model.util.ElementKindVisitor14;
  85 import javax.lang.model.util.Elements;
  86 import javax.lang.model.util.SimpleElementVisitor14;
  87 import javax.lang.model.util.SimpleTypeVisitor9;
  88 import javax.lang.model.util.TypeKindVisitor9;
  89 import javax.lang.model.util.Types;
  90 import javax.tools.FileObject;
  91 import javax.tools.JavaFileManager;
  92 import javax.tools.JavaFileManager.Location;
  93 import javax.tools.StandardLocation;
  94 
  95 import com.sun.source.doctree.DocCommentTree;
  96 import com.sun.source.doctree.DocTree;
  97 import com.sun.source.doctree.DocTree.Kind;
<span class="line-added">  98 import com.sun.source.doctree.EndElementTree;</span>
  99 import com.sun.source.doctree.ParamTree;
 100 import com.sun.source.doctree.SerialFieldTree;
<span class="line-added"> 101 import com.sun.source.doctree.StartElementTree;</span>
<span class="line-added"> 102 import com.sun.source.doctree.TextTree;</span>
 103 import com.sun.source.doctree.UnknownBlockTagTree;
 104 import com.sun.source.tree.CompilationUnitTree;
 105 import com.sun.source.tree.LineMap;
 106 import com.sun.source.util.DocSourcePositions;
 107 import com.sun.source.util.DocTrees;
 108 import com.sun.source.util.TreePath;
 109 import com.sun.tools.javac.model.JavacTypes;
 110 import jdk.javadoc.internal.doclets.formats.html.SearchIndexItem;
 111 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
 112 import jdk.javadoc.internal.doclets.toolkit.BaseOptions;
 113 import jdk.javadoc.internal.doclets.toolkit.CommentUtils.DocCommentDuo;
 114 import jdk.javadoc.internal.doclets.toolkit.Messages;
 115 import jdk.javadoc.internal.doclets.toolkit.Resources;
 116 import jdk.javadoc.internal.doclets.toolkit.WorkArounds;
 117 import jdk.javadoc.internal.doclets.toolkit.taglets.BaseTaglet;
 118 import jdk.javadoc.internal.doclets.toolkit.taglets.Taglet;
 119 import jdk.javadoc.internal.tool.DocEnvImpl;
 120 
 121 import static javax.lang.model.element.ElementKind.*;
 122 import static javax.lang.model.element.Modifier.*;
</pre>
<hr />
<pre>
 200     }
 201 
 202     public TypeMirror getDeprecatedType() {
 203         return getSymbol(&quot;java.lang.Deprecated&quot;);
 204     }
 205 
 206     public TypeMirror getFunctionalInterface() {
 207         return getSymbol(&quot;java.lang.FunctionalInterface&quot;);
 208     }
 209 
 210     /**
 211      * Return array of class members whose documentation is to be generated.
 212      * If the member is deprecated do not include such a member in the
 213      * returned array.
 214      *
 215      * @param  members    Array of members to choose from.
 216      * @return List       List of eligible members for whom
 217      *                    documentation is getting generated.
 218      */
 219     public List&lt;Element&gt; excludeDeprecatedMembers(List&lt;? extends Element&gt; members) {
<span class="line-modified"> 220         return members.stream()</span>
<span class="line-modified"> 221                       .filter(member -&gt; !isDeprecated(member))</span>
<span class="line-modified"> 222                       .sorted(makeGeneralPurposeComparator())</span>
<span class="line-modified"> 223                       .collect(Collectors.toCollection(ArrayList::new));</span>

 224     }
 225 
 226     /**
 227      * Search for the given method in the given class.
 228      *
 229      * @param  te        Class to search into.
 230      * @param  method    Method to be searched.
 231      * @return ExecutableElement Method found, null otherwise.
 232      */
 233     public ExecutableElement findMethod(TypeElement te, ExecutableElement method) {
 234         for (Element m : getMethods(te)) {
<span class="line-modified"> 235             if (executableMembersEqual(method, (ExecutableElement) m)) {</span>
<span class="line-modified"> 236                 return (ExecutableElement) m;</span>
 237             }
 238         }
 239         return null;
 240     }
 241 
 242     /**
 243      * Test whether a class is a subclass of another class.
 244      *
 245      * @param t1 the candidate superclass.
 246      * @param t2 the target
 247      * @return true if t1 is a superclass of t2.
 248      */
 249     public boolean isSubclassOf(TypeElement t1, TypeElement t2) {
 250         return typeUtils.isSubtype(typeUtils.erasure(t1.asType()), typeUtils.erasure(t2.asType()));
 251     }
 252 
 253     /**
 254      * @param e1 the first method to compare.
 255      * @param e2 the second method to compare.
 256      * @return true if member1 overrides/hides or is overridden/hidden by member2.
 257      */

 258     public boolean executableMembersEqual(ExecutableElement e1, ExecutableElement e2) {
 259         // TODO: investigate if Elements.hides(..) will work here.
 260         if (isStatic(e1) &amp;&amp; isStatic(e2)) {
 261             List&lt;? extends VariableElement&gt; parameters1 = e1.getParameters();
 262             List&lt;? extends VariableElement&gt; parameters2 = e2.getParameters();
 263             if (e1.getSimpleName().equals(e2.getSimpleName()) &amp;&amp;
 264                     parameters1.size() == parameters2.size()) {
 265                 int j;
 266                 for (j = 0 ; j &lt; parameters1.size(); j++) {
 267                     VariableElement v1 = parameters1.get(j);
 268                     VariableElement v2 = parameters2.get(j);
 269                     String t1 = getTypeName(v1.asType(), true);
 270                     String t2 = getTypeName(v2.asType(), true);
 271                     if (!(t1.equals(t2) ||
 272                             isTypeVariable(v1.asType()) || isTypeVariable(v2.asType()))) {
 273                         break;
 274                     }
 275                 }
 276                 if (j == parameters1.size()) {
<span class="line-modified"> 277                     return true;</span>
 278                 }
 279             }
 280             return false;
 281         } else {
 282             return elementUtils.overrides(e1, e2, getEnclosingTypeElement(e1)) ||
 283                     elementUtils.overrides(e2, e1, getEnclosingTypeElement(e2)) ||
 284                     e1.equals(e2);
 285         }
 286     }
 287 
 288     /**
 289      * According to
 290      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
 291      * all the outer classes and static inner classes are core classes.
 292      */
 293     public boolean isCoreClass(TypeElement e) {
 294         return getEnclosingTypeElement(e) == null || isStatic(e);
 295     }
 296 
 297     public Location getLocationForPackage(PackageElement pd) {
</pre>
<hr />
<pre>
 492         return new ElementKindVisitor14&lt;String, SortedSet&lt;Modifier&gt;&gt;() {
 493             final StringBuilder sb = new StringBuilder();
 494 
 495             void addVisibilityModifier(Set&lt;Modifier&gt; modifiers) {
 496                 if (modifiers.contains(PUBLIC)) {
 497                     append(&quot;public&quot;);
 498                 } else if (modifiers.contains(PROTECTED)) {
 499                     append(&quot;protected&quot;);
 500                 } else if (modifiers.contains(PRIVATE)) {
 501                     append(&quot;private&quot;);
 502                 }
 503             }
 504 
 505             void addStatic(Set&lt;Modifier&gt; modifiers) {
 506                 if (modifiers.contains(STATIC)) {
 507                     append(&quot;static&quot;);
 508                 }
 509             }
 510 
 511             void addModifiers(Set&lt;Modifier&gt; modifiers) {
<span class="line-modified"> 512                 modifiers.stream().map(Modifier::toString).forEachOrdered(this::append);</span>
 513             }
 514 
 515             void append(String s) {
 516                 if (sb.length() &gt; 0) {
 517                     sb.append(&quot; &quot;);
 518                 }
 519                 sb.append(s);
 520             }
 521 
 522             String finalString(String s) {
 523                 append(s);
 524                 if (trailingSpace) {
 525                     sb.append(&quot; &quot;);
<span class="line-modified"> 526                 }</span>
 527                 return sb.toString();
 528             }
 529 
 530             @Override
 531             public String visitTypeAsInterface(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 532                 addVisibilityModifier(mods);
 533                 addStatic(mods);
 534                 return finalString(&quot;interface&quot;);
 535             }
 536 
 537             @Override
 538             public String visitTypeAsEnum(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 539                 addVisibilityModifier(mods);
 540                 addStatic(mods);
 541                 return finalString(&quot;enum&quot;);
 542             }
 543 
 544             @Override
 545             public String visitTypeAsAnnotationType(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 546                 addVisibilityModifier(mods);
</pre>
<hr />
<pre>
 649               case LOCAL_VARIABLE: case PARAMETER:
 650               case RESOURCE_VARIABLE:
 651                   return true;
 652               default:
 653                   return false;
 654         }
 655     }
 656 
 657     public boolean isTypeElement(Element e) {
 658         switch (e.getKind()) {
 659             case CLASS: case ENUM: case INTERFACE: case ANNOTATION_TYPE: case RECORD:
 660                 return true;
 661             default:
 662                 return false;
 663         }
 664     }
 665 
 666     /**
 667      * Get the signature. It is the parameter list, type is qualified.
 668      * For instance, for a method {@code mymethod(String x, int y)},
<span class="line-modified"> 669      * it will return {@code (java.lang.String,int)}.</span>
 670      *
 671      * @param e
 672      * @return String
 673      */
 674     public String signature(ExecutableElement e) {
 675         return makeSignature(e, true);
 676     }
 677 
 678     /**
 679      * Get flat signature.  All types are not qualified.
 680      * Return a String, which is the flat signature of this member.
 681      * It is the parameter list, type is not qualified.
 682      * For instance, for a method {@code mymethod(String x, int y)},
 683      * it will return {@code (String, int)}.
 684      */
 685     public String flatSignature(ExecutableElement e) {
 686         return makeSignature(e, false);
 687     }
 688 
 689     public String makeSignature(ExecutableElement e, boolean full) {
</pre>
<hr />
<pre>
 913             TypeElement te = asTypeElement(t);
 914             if (te == null) {
 915                 return null;
 916             }
 917             VisibleMemberTable vmt = configuration.getVisibleMemberTable(te);
 918             for (Element e : vmt.getMembers(VisibleMemberTable.Kind.METHODS)) {
 919                 ExecutableElement ee = (ExecutableElement)e;
 920                 if (configuration.workArounds.overrides(method, ee, origin) &amp;&amp;
 921                         !isSimpleOverride(ee)) {
 922                     return ee;
 923                 }
 924             }
 925             if (t.equals(getObjectType()))
 926                 return null;
 927         }
 928         return null;
 929     }
 930 
 931     public SortedSet&lt;TypeElement&gt; getTypeElementsAsSortedSet(Iterable&lt;TypeElement&gt; typeElements) {
 932         SortedSet&lt;TypeElement&gt; set = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());
<span class="line-modified"> 933         typeElements.forEach(set::add);</span>


 934         return set;
 935     }
 936 
 937     public List&lt;? extends DocTree&gt; getSerialDataTrees(ExecutableElement member) {
 938         return getBlockTags(member, SERIAL_DATA);
 939     }
 940 
 941     public FileObject getFileObject(TypeElement te) {
 942         return docTrees.getPath(te).getCompilationUnit().getSourceFile();
 943     }
 944 
 945     public TypeMirror getDeclaredType(TypeElement enclosing, TypeMirror target) {
 946         return getDeclaredType(Collections.emptyList(), enclosing, target);
 947     }
 948 
 949     /**
 950      * Finds the declaration of the enclosing&#39;s type parameter.
 951      *
 952      * @param values
 953      * @param enclosing a TypeElement whose type arguments  we desire
</pre>
<hr />
<pre>
1229             }
1230         }.visit(t);
1231     }
1232 
1233     public TypeMirror getComponentType(TypeMirror t) {
1234         while (isArrayType(t)) {
1235             t = ((ArrayType) t).getComponentType();
1236         }
1237         return t;
1238     }
1239 
1240     /**
1241      * Return the type&#39;s dimension information, as a string.
1242      * &lt;p&gt;
1243      * For example, a two dimensional array of String returns &quot;{@code [][]}&quot;.
1244      *
1245      * @return the type&#39;s dimension information as a string.
1246      */
1247     public String getDimension(TypeMirror t) {
1248         return new SimpleTypeVisitor9&lt;String, Void&gt;() {
<span class="line-modified">1249             StringBuilder dimension = new StringBuilder();</span>
1250             @Override
1251             public String visitArray(ArrayType t, Void p) {
1252                 dimension.append(&quot;[]&quot;);
1253                 return visit(t.getComponentType());
1254             }
1255 
1256             @Override
1257             protected String defaultAction(TypeMirror e, Void p) {
1258                 return dimension.toString();
1259             }
1260 
1261         }.visit(t);
1262     }
1263 
1264     public TypeElement getSuperClass(TypeElement te) {
1265         if (isInterface(te) || isAnnotationType(te) ||
1266                 te.asType().equals(getObjectType())) {
1267             return null;
1268         }
1269         TypeMirror superclass = te.getSuperclass();
</pre>
<hr />
<pre>
1316                     || supersuperClass.getQualifiedName().equals(superClass.getQualifiedName())) {
1317                 break;
1318             }
1319             superType = supersuperType;
1320             superClass = supersuperClass;
1321         }
1322         if (te.asType().equals(superType)) {
1323             return null;
1324         }
1325         return superType;
1326     }
1327 
1328     /**
1329      * Given a TypeElement, return the name of its type (Class, Interface, etc.).
1330      *
1331      * @param te the TypeElement to check.
1332      * @param lowerCaseOnly true if you want the name returned in lower case.
1333      *                      If false, the first letter of the name is capitalized.
1334      * @return
1335      */

1336     public String getTypeElementName(TypeElement te, boolean lowerCaseOnly) {
1337         String typeName = &quot;&quot;;
1338         if (isInterface(te)) {
1339             typeName = &quot;doclet.Interface&quot;;
1340         } else if (isException(te)) {
1341             typeName = &quot;doclet.Exception&quot;;
1342         } else if (isError(te)) {
1343             typeName = &quot;doclet.Error&quot;;
1344         } else if (isAnnotationType(te)) {
1345             typeName = &quot;doclet.AnnotationType&quot;;
1346         } else if (isEnum(te)) {
1347             typeName = &quot;doclet.Enum&quot;;
1348         } else if (isOrdinaryClass(te)) {
1349             typeName = &quot;doclet.Class&quot;;
1350         }
1351         typeName = lowerCaseOnly ? toLowerCase(typeName) : typeName;
1352         return typeNameMap.computeIfAbsent(typeName, resources::getText);
1353     }
1354 
1355     private final Map&lt;String, String&gt; typeNameMap = new HashMap&lt;&gt;();
</pre>
<hr />
<pre>
1640     public int compareCaseCompare(String s1, String s2) {
1641         return compareStrings(false, s1, s2);
1642     }
1643 
1644     private DocCollator tertiaryCollator = null;
1645     private DocCollator secondaryCollator = null;
1646 
1647     private int compareStrings(boolean caseSensitive, String s1, String s2) {
1648         if (caseSensitive) {
1649             if (tertiaryCollator == null) {
1650                 tertiaryCollator = new DocCollator(configuration.locale, Collator.TERTIARY);
1651             }
1652             return tertiaryCollator.compare(s1, s2);
1653         }
1654         if (secondaryCollator == null) {
1655             secondaryCollator = new DocCollator(configuration.locale, Collator.SECONDARY);
1656         }
1657         return secondaryCollator.compare(s1, s2);
1658     }
1659 
<span class="line-added">1660     public String getHTMLTitle(Element element) {</span>
<span class="line-added">1661         List&lt;? extends DocTree&gt; preamble = getPreamble(element);</span>
<span class="line-added">1662         StringBuilder sb = new StringBuilder();</span>
<span class="line-added">1663         boolean titleFound = false;</span>
<span class="line-added">1664         loop:</span>
<span class="line-added">1665         for (DocTree dt : preamble) {</span>
<span class="line-added">1666             switch (dt.getKind()) {</span>
<span class="line-added">1667                 case START_ELEMENT:</span>
<span class="line-added">1668                     StartElementTree nodeStart = (StartElementTree)dt;</span>
<span class="line-added">1669                     if (Utils.toLowerCase(nodeStart.getName().toString()).equals(&quot;title&quot;)) {</span>
<span class="line-added">1670                         titleFound = true;</span>
<span class="line-added">1671                     }</span>
<span class="line-added">1672                     break;</span>
<span class="line-added">1673 </span>
<span class="line-added">1674                 case END_ELEMENT:</span>
<span class="line-added">1675                     EndElementTree nodeEnd = (EndElementTree)dt;</span>
<span class="line-added">1676                     if (Utils.toLowerCase(nodeEnd.getName().toString()).equals(&quot;title&quot;)) {</span>
<span class="line-added">1677                         break loop;</span>
<span class="line-added">1678                     }</span>
<span class="line-added">1679                     break;</span>
<span class="line-added">1680 </span>
<span class="line-added">1681                 case TEXT:</span>
<span class="line-added">1682                     TextTree nodeText = (TextTree)dt;</span>
<span class="line-added">1683                     if (titleFound)</span>
<span class="line-added">1684                         sb.append(nodeText.getBody());</span>
<span class="line-added">1685                     break;</span>
<span class="line-added">1686 </span>
<span class="line-added">1687                 default:</span>
<span class="line-added">1688                     // do nothing</span>
<span class="line-added">1689             }</span>
<span class="line-added">1690         }</span>
<span class="line-added">1691         return sb.toString().trim();</span>
<span class="line-added">1692     }</span>
<span class="line-added">1693 </span>
1694     private static class DocCollator {
1695         private final Map&lt;String, CollationKey&gt; keys;
1696         private final Collator instance;
1697         private final int MAX_SIZE = 1000;
1698         private DocCollator(Locale locale, int strength) {
1699             instance = createCollator(locale);
1700             instance.setStrength(strength);
1701 
1702             keys = new LinkedHashMap&lt;String, CollationKey&gt;(MAX_SIZE + 1, 0.75f, true) {
1703                 private static final long serialVersionUID = 1L;
1704                 @Override
1705                 protected boolean removeEldestEntry(Entry&lt;String, CollationKey&gt; eldest) {
1706                     return size() &gt; MAX_SIZE;
1707                 }
1708             };
1709         }
1710 
1711         CollationKey getKey(String s) {
1712             return keys.computeIfAbsent(s, instance :: getCollationKey);
1713         }
</pre>
<hr />
<pre>
1817     public Comparator&lt;SerialFieldTree&gt; makeSerialFieldTreeComparator() {
1818         if (serialFieldTreeComparator == null) {
1819             serialFieldTreeComparator = (SerialFieldTree o1, SerialFieldTree o2) -&gt; {
1820                 String s1 = o1.getName().toString();
1821                 String s2 = o2.getName().toString();
1822                 return s1.compareTo(s2);
1823             };
1824         }
1825         return serialFieldTreeComparator;
1826     }
1827 
1828     /**
1829      * Returns a general purpose comparator.
1830      * @return a Comparator
1831      */
1832     public Comparator&lt;Element&gt; makeGeneralPurposeComparator() {
1833         return makeClassUseComparator();
1834     }
1835 
1836     private Comparator&lt;Element&gt; overrideUseComparator = null;
<span class="line-added">1837 </span>
1838     /**
1839      * Returns a Comparator for overrides and implements,
1840      * used primarily on methods, compares the name first,
1841      * then compares the simple names of the enclosing
1842      * TypeElement and the fully qualified name of the enclosing TypeElement.
1843      * @return a Comparator
1844      */
1845     public Comparator&lt;Element&gt; makeOverrideUseComparator() {
1846         if (overrideUseComparator == null) {
1847             overrideUseComparator = new Utils.ElementComparator() {
1848                 @Override
1849                 public int compare(Element o1, Element o2) {
1850                     int result = compareStrings(getSimpleName(o1), getSimpleName(o2));
1851                     if (result != 0) {
1852                         return result;
1853                     }
1854                     if (!isTypeElement(o1) &amp;&amp; !isTypeElement(o2) &amp;&amp; !isPackage(o1) &amp;&amp; !isPackage(o2)) {
1855                         TypeElement t1 = getEnclosingTypeElement(o1);
1856                         TypeElement t2 = getEnclosingTypeElement(o2);
1857                         result = compareStrings(getSimpleName(t1), getSimpleName(t2));
</pre>
<hr />
<pre>
2027             }
2028 
2029             @Override
2030             public String visitPackage(PackageElement e, Void p) {
2031                 return e.getQualifiedName().toString();
2032             }
2033 
2034             @Override
2035             public String visitType(TypeElement e, Void p) {
2036                 return e.getQualifiedName().toString();
2037             }
2038 
2039             @Override
2040             protected String defaultAction(Element e, Void p) {
2041                 return outer ? visit(e.getEnclosingElement()) : e.getSimpleName().toString();
2042             }
2043         }.visit(e);
2044     }
2045 
2046     private Comparator&lt;Element&gt; classUseComparator = null;
<span class="line-added">2047 </span>
2048     /**
2049      * Comparator for ClassUse presentations, and sorts as follows:
2050      * 1. member names
2051      * 2. then fully qualified member names
2052      * 3. then parameter types if applicable
2053      * 4. finally the element kinds ie. package, class, interface etc.
2054      * @return a comparator to sort classes and members for class use
2055      */
2056     public Comparator&lt;Element&gt; makeClassUseComparator() {
2057         if (classUseComparator == null) {
2058             classUseComparator = new Utils.ElementComparator() {
2059                 /**
2060                  * Compares two Elements.
2061                  *
2062                  * @param e1 - an element.
2063                  * @param e2 - an element.
2064                  * @return a negative integer, zero, or a positive integer as the first
2065                  * argument is less than, equal to, or greater than the second.
2066                  */
2067                 @Override
</pre>
<hr />
<pre>
2359     public List&lt;ExecutableElement&gt; getMethods(Element e) {
2360         return convertToExecutableElement(getItems(e, true, METHOD));
2361     }
2362 
2363     List&lt;ExecutableElement&gt; getMethodsUnfiltered(Element e) {
2364         return convertToExecutableElement(getItems(e, false, METHOD));
2365     }
2366 
2367     public int getOrdinalValue(VariableElement member) {
2368         if (member == null || member.getKind() != ENUM_CONSTANT) {
2369             throw new IllegalArgumentException(&quot;must be an enum constant: &quot; + member);
2370         }
2371         return member.getEnclosingElement().getEnclosedElements().indexOf(member);
2372     }
2373 
2374     private Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; modulePackageMap = null;
2375     public Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; getModulePackageMap() {
2376         if (modulePackageMap == null) {
2377             modulePackageMap = new HashMap&lt;&gt;();
2378             Set&lt;PackageElement&gt; pkgs = configuration.getIncludedPackageElements();
<span class="line-modified">2379             pkgs.forEach(pkg -&gt; {</span>
2380                 ModuleElement mod = elementUtils.getModuleOf(pkg);
2381                 modulePackageMap.computeIfAbsent(mod, m -&gt; new HashSet&lt;&gt;()).add(pkg);
2382             });
2383         }
2384         return modulePackageMap;
2385     }
2386 
2387     public Map&lt;ModuleElement, String&gt; getDependentModules(ModuleElement mdle) {
2388         Map&lt;ModuleElement, String&gt; result = new TreeMap&lt;&gt;(makeModuleComparator());
2389         Deque&lt;ModuleElement&gt; queue = new ArrayDeque&lt;&gt;();
2390         // get all the requires for the element in question
2391         for (RequiresDirective rd : ElementFilter.requiresIn(mdle.getDirectives())) {
2392             ModuleElement dep = rd.getDependency();
2393             // add the dependency to work queue
2394             if (!result.containsKey(dep)) {
2395                 if (rd.isTransitive()) {
2396                     queue.addLast(dep);
2397                 }
2398             }
2399             // add all exports for the primary module
2400             result.put(rd.getDependency(), getModifiers(rd));
2401         }
2402 
2403         // add only requires public for subsequent module dependencies
2404         for (ModuleElement m = queue.poll(); m != null; m = queue.poll()) {
2405             for (RequiresDirective rd : ElementFilter.requiresIn(m.getDirectives())) {
2406                 ModuleElement dep = rd.getDependency();
2407                 if (!result.containsKey(dep)) {
2408                     if (rd.isTransitive()) {
2409                         result.put(dep, getModifiers(rd));
2410                         queue.addLast(dep);
2411                     }
2412                 }
2413             }
2414         }
2415         return result;
2416     }
2417 
2418     public String getModifiers(RequiresDirective rd) {
2419         StringBuilder modifiers = new StringBuilder();
<span class="line-modified">2420         String sep = &quot;&quot;;</span>
2421         if (rd.isTransitive()) {
2422             modifiers.append(&quot;transitive&quot;);
2423             sep = &quot; &quot;;
2424         }
2425         if (rd.isStatic()) {
2426             modifiers.append(sep);
2427             modifiers.append(&quot;static&quot;);
2428         }
2429         return (modifiers.length() == 0) ? &quot; &quot; : modifiers.toString();
2430     }
2431 
2432     public long getLineNumber(Element e) {
2433         TreePath path = getTreePath(e);
2434         if (path == null) { // maybe null if synthesized
2435             TypeElement encl = getEnclosingTypeElement(e);
2436             path = getTreePath(encl);
2437         }
2438         CompilationUnitTree cu = path.getCompilationUnit();
2439         LineMap lineMap = cu.getLineMap();
2440         DocSourcePositions spos = docTrees.getSourcePositions();
</pre>
<hr />
<pre>
3289     public List&lt;? extends ParamTree&gt; getTypeParamTrees(Element element) {
3290         return getParamTrees(element, true);
3291     }
3292 
3293     public List&lt;? extends ParamTree&gt; getParamTrees(Element element) {
3294         return getParamTrees(element, false);
3295     }
3296 
3297     private  List&lt;? extends ParamTree&gt; getParamTrees(Element element, boolean isTypeParameters) {
3298         List&lt;ParamTree&gt; out = new ArrayList&lt;&gt;();
3299         for (DocTree dt : getBlockTags(element, PARAM)) {
3300             ParamTree pt = (ParamTree) dt;
3301             if (pt.isTypeParameter() == isTypeParameters) {
3302                 out.add(pt);
3303             }
3304         }
3305         return out;
3306     }
3307 
3308     public  List&lt;? extends DocTree&gt; getReturnTrees(Element element) {
<span class="line-modified">3309         return new ArrayList&lt;&gt;(getBlockTags(element, RETURN));</span>




3310     }
3311 
3312     public List&lt;? extends DocTree&gt; getUsesTrees(Element element) {
3313         return getBlockTags(element, USES);
3314     }
3315 
3316     public List&lt;? extends DocTree&gt; getFirstSentenceTrees(Element element) {
3317         DocCommentTree dcTree = getDocCommentTree(element);
3318         if (dcTree == null) {
3319             return Collections.emptyList();
3320         }
<span class="line-modified">3321         return new ArrayList&lt;&gt;(dcTree.getFirstSentence());</span>




3322     }
3323 
3324     public ModuleElement containingModule(Element e) {
3325         return elementUtils.getModuleOf(e);
3326     }
3327 
3328     public PackageElement containingPackage(Element e) {
3329         return elementUtils.getPackageOf(e);
3330     }
3331 
3332     public TypeElement getTopMostContainingTypeElement(Element e) {
3333         if (isPackage(e)) {
3334             return null;
3335         }
3336         TypeElement outer = getEnclosingTypeElement(e);
3337         if (outer == null)
3338             return (TypeElement)e;
3339         while (outer != null &amp;&amp; outer.getNestingKind().isNested()) {
3340             outer = getEnclosingTypeElement(outer);
3341         }
</pre>
<hr />
<pre>
3370             SoftReference&lt;CommentHelper&gt; value = map.get(key);
3371             return value == null ? null : value.get();
3372         }
3373 
3374         public CommentHelper computeIfAbsent(Element key) {
3375             SoftReference&lt;CommentHelper&gt; refValue = map.get(key);
3376             if (refValue != null) {
3377                 CommentHelper value = refValue.get();
3378                 if (value != null) {
3379                     return value;
3380                 }
3381             }
3382             CommentHelper newValue = new CommentHelper(utils.configuration, key, utils.getTreePath(key),
3383                     utils.getDocCommentTree(key));
3384             map.put(key, new SoftReference&lt;&gt;(newValue));
3385             return newValue;
3386         }
3387     }
3388 
3389     /**
<span class="line-modified">3390      * A container holding a pair of values (tuple).</span>
<span class="line-modified">3391      *</span>
<span class="line-modified">3392      * @param &lt;K&gt; the type of the first value</span>
<span class="line-added">3393      * @param &lt;L&gt; the type of the second value</span>
3394      */
3395     public static class Pair&lt;K, L&gt; {
3396         public final K first;
3397         public final L second;
3398 
3399         public Pair(K first, L second) {
3400             this.first = first;
3401             this.second = second;
3402         }
3403 
3404         @Override
3405         public String toString() {
<span class="line-modified">3406             return first + &quot;:&quot; + second;</span>


3407         }
3408     }
3409 }
</pre>
</td>
</tr>
</table>
<center><a href="IndexBuilder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="VisibleMemberTable.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
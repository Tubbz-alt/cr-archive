diff a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/taglets/TagletManager.java b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/taglets/TagletManager.java
--- a/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/taglets/TagletManager.java
+++ b/src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/taglets/TagletManager.java
@@ -28,14 +28,14 @@
 import java.io.File;
 import java.io.IOException;
 import java.io.PrintStream;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.Comparator;
 import java.util.EnumMap;
 import java.util.EnumSet;
 import java.util.HashSet;
-import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.ServiceLoader;
@@ -96,16 +96,16 @@
      * The default separator for the simple tag option.
      */
     public static final char SIMPLE_TAGLET_OPT_SEPARATOR = ':';
 
     /**
-     * The map of all taglets.
+     * All taglets, keyed by their {@link Taglet#getName() name}.
      */
-    private final LinkedHashMap<String,Taglet> allTaglets;
+    private final LinkedHashMap<String, Taglet> allTaglets;
 
     /**
-     * Block (non-inline) taglets, grouped by Location
+     * Block (non-inline) taglets, grouped by {@link Location location}.
      */
     private Map<Location, List<Taglet>> blockTagletsByLocation;
 
     /**
      * The taglets that can appear inline in descriptive text.
@@ -179,11 +179,12 @@
     private final boolean showTaglets;
 
     private final String tagletPath;
 
     /**
-     * Construct a new {@code TagletManager}.
+     * Constructs a new {@code TagletManager}.
+     *
      * @param configuration the configuration for this taglet manager
      */
     public TagletManager(BaseConfiguration configuration) {
         overriddenStandardTags = new HashSet<>();
         potentiallyConflictingTags = new HashSet<>();
@@ -272,17 +273,15 @@
      * Loads taglets from a taglet path using service loader.
      * @param fileManager the file manager to load the taglets.
      * @throws IOException if an error occurs while getting the service loader.
      */
     public void loadTaglets(JavaFileManager fileManager) throws IOException {
-        Iterable<? extends File> location = ((StandardJavaFileManager)fileManager).getLocation(TAGLET_PATH);
+        Iterable<? extends File> location = ((StandardJavaFileManager) fileManager).getLocation(TAGLET_PATH);
         if (location != null && location.iterator().hasNext()) {
             ServiceLoader<jdk.javadoc.doclet.Taglet> serviceLoader =
                     fileManager.getServiceLoader(TAGLET_PATH, jdk.javadoc.doclet.Taglet.class);
-            Iterator<jdk.javadoc.doclet.Taglet> iterator = serviceLoader.iterator();
-            while (iterator.hasNext()) {
-                jdk.javadoc.doclet.Taglet taglet = iterator.next();
+            for (jdk.javadoc.doclet.Taglet taglet : serviceLoader) {
                 registerTaglet(taglet);
             }
         }
     }
 
@@ -364,12 +363,12 @@
         for (DocTree tag : trees) {
             String name = tag.getKind().tagName;
             if (name == null) {
                 continue;
             }
-            if (name.length() > 0 && name.charAt(0) == '@') {
-                name = name.substring(1, name.length());
+            if (!name.isEmpty() && name.charAt(0) == '@') {
+                name = name.substring(1);
             }
             if (! (standardTags.contains(name) || allTaglets.containsKey(name))) {
                 if (standardTagsLowercase.contains(Utils.toLowerCase(name))) {
                     messages.warning(ch.getDocTreePath(tag), "doclet.UnknownTagLowercase", ch.getTagName(tag));
                     continue;
@@ -553,11 +552,11 @@
                 return blockTagletsByLocation.get(Location.MODULE);
             case PACKAGE:
                 return blockTagletsByLocation.get(Location.PACKAGE);
             case OTHER:
                 if (e instanceof DocletElement) {
-                    DocletElement de = (DocletElement)e;
+                    DocletElement de = (DocletElement) e;
                     switch (de.getSubKind()) {
                         case DOCFILE:
                             return blockTagletsByLocation.get(Location.PACKAGE);
                         case OVERVIEW:
                             return blockTagletsByLocation.get(Location.OVERVIEW);
@@ -705,11 +704,11 @@
         printReportHelper("doclet.Notice_taglet_overridden", overriddenStandardTags);
         printReportHelper("doclet.Notice_taglet_unseen", unseenCustomTags);
     }
 
     private void printReportHelper(String noticeKey, Set<String> names) {
-        if (names.size() > 0) {
+        if (!names.isEmpty()) {
             StringBuilder result = new StringBuilder();
             for (String name : names) {
                 result.append(result.length() == 0 ? " " : ", ");
                 result.append("@").append(name);
             }
@@ -729,20 +728,19 @@
         if (name.indexOf("@") == 0) {
             return allTaglets.get(name.substring(1));
         } else {
             return allTaglets.get(name);
         }
-
     }
 
     /*
      * The output of this method is the basis for a table at the end of the
      * doc comment specification, so any changes in the output may indicate
      * a need for a corresponding update to the spec.
      */
     private void showTaglets(PrintStream out) {
-        Set<Taglet> taglets = new TreeSet<>((o1, o2) -> o1.getName().compareTo(o2.getName()));
+        Set<Taglet> taglets = new TreeSet<>(Comparator.comparing(Taglet::getName));
         taglets.addAll(allTaglets.values());
 
         for (Taglet t : taglets) {
             String name = t.isInlineTag() ? "{@" + t.getName() + "}" : "@" + t.getName();
             out.println(String.format("%20s", name) + ": "
@@ -753,11 +751,11 @@
                     + format(t.inType(), "type") + " "
                     + format(t.inConstructor(),"constructor") + " "
                     + format(t.inMethod(), "method") + " "
                     + format(t.inField(), "field") + " "
                     + format(t.isInlineTag(), "inline")+ " "
-                    + format((t instanceof SimpleTaglet) && !((SimpleTaglet)t).enabled, "disabled"));
+                    + format((t instanceof SimpleTaglet) && !((SimpleTaglet) t).enabled, "disabled"));
         }
     }
 
     private String format(boolean b, String s) {
         return b ? s : s.replaceAll(".", "."); // replace all with "."

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.*;
  29 import java.util.function.Supplier;
  30 
  31 import javax.lang.model.element.ElementKind;
  32 import javax.tools.JavaFileManager;
  33 
  34 import com.sun.tools.javac.code.*;
  35 import com.sun.tools.javac.code.Attribute.Compound;
  36 import com.sun.tools.javac.code.Directive.ExportsDirective;
  37 import com.sun.tools.javac.code.Directive.RequiresDirective;
  38 import com.sun.tools.javac.code.Source.Feature;
  39 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  40 import com.sun.tools.javac.jvm.*;
  41 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  42 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  43 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  44 import com.sun.tools.javac.tree.*;
  45 import com.sun.tools.javac.util.*;
  46 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  47 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  48 import com.sun.tools.javac.util.JCDiagnostic.Error;
  49 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  50 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  51 import com.sun.tools.javac.util.List;
  52 
  53 import com.sun.tools.javac.code.Lint;
  54 import com.sun.tools.javac.code.Lint.LintCategory;
  55 import com.sun.tools.javac.code.Scope.WriteableScope;
  56 import com.sun.tools.javac.code.Type.*;
  57 import com.sun.tools.javac.code.Symbol.*;
  58 import com.sun.tools.javac.comp.DeferredAttr.DeferredAttrContext;
  59 import com.sun.tools.javac.tree.JCTree.*;
  60 
  61 import static com.sun.tools.javac.code.Flags.*;
  62 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  63 import static com.sun.tools.javac.code.Flags.SYNCHRONIZED;
  64 import static com.sun.tools.javac.code.Kinds.*;
  65 import static com.sun.tools.javac.code.Kinds.Kind.*;
  66 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  67 import static com.sun.tools.javac.code.TypeTag.*;
  68 import static com.sun.tools.javac.code.TypeTag.WILDCARD;
  69 
  70 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  71 
  72 /** Type checking helper class for the attribution phase.
  73  *
  74  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  75  *  If you write code that depends on this, you do so at your own risk.
  76  *  This code and its internal interfaces are subject to change or
  77  *  deletion without notice.&lt;/b&gt;
  78  */
  79 public class Check {
  80     protected static final Context.Key&lt;Check&gt; checkKey = new Context.Key&lt;&gt;();
  81 
  82     private final Names names;
  83     private final Log log;
  84     private final Resolve rs;
  85     private final Symtab syms;
  86     private final Enter enter;
  87     private final DeferredAttr deferredAttr;
  88     private final Infer infer;
  89     private final Types types;
  90     private final TypeAnnotations typeAnnotations;
  91     private final JCDiagnostic.Factory diags;
  92     private final JavaFileManager fileManager;
  93     private final Source source;
  94     private final Target target;
  95     private final Profile profile;
  96     private final Preview preview;
  97     private final boolean warnOnAnyAccessToMembers;
  98 
  99     // The set of lint options currently in effect. It is initialized
 100     // from the context, and then is set/reset as needed by Attr as it
 101     // visits all the various parts of the trees during attribution.
 102     private Lint lint;
 103 
 104     // The method being analyzed in Attr - it is set/reset as needed by
 105     // Attr as it visits new method declarations.
 106     private MethodSymbol method;
 107 
 108     public static Check instance(Context context) {
 109         Check instance = context.get(checkKey);
 110         if (instance == null)
 111             instance = new Check(context);
 112         return instance;
 113     }
 114 
 115     protected Check(Context context) {
 116         context.put(checkKey, this);
 117 
 118         names = Names.instance(context);
 119         dfltTargetMeta = new Name[] { names.PACKAGE, names.TYPE,
 120             names.FIELD, names.RECORD_COMPONENT, names.METHOD, names.CONSTRUCTOR,
 121             names.ANNOTATION_TYPE, names.LOCAL_VARIABLE, names.PARAMETER};
 122         log = Log.instance(context);
 123         rs = Resolve.instance(context);
 124         syms = Symtab.instance(context);
 125         enter = Enter.instance(context);
 126         deferredAttr = DeferredAttr.instance(context);
 127         infer = Infer.instance(context);
 128         types = Types.instance(context);
 129         typeAnnotations = TypeAnnotations.instance(context);
 130         diags = JCDiagnostic.Factory.instance(context);
 131         Options options = Options.instance(context);
 132         lint = Lint.instance(context);
 133         fileManager = context.get(JavaFileManager.class);
 134 
 135         source = Source.instance(context);
 136         target = Target.instance(context);
 137         warnOnAnyAccessToMembers = options.isSet(&quot;warnOnAccessToMembers&quot;);
 138 
 139         Target target = Target.instance(context);
 140         syntheticNameChar = target.syntheticNameChar();
 141 
 142         profile = Profile.instance(context);
 143         preview = Preview.instance(context);
 144 
 145         boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);
 146         boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);
 147         boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);
 148         boolean enforceMandatoryWarnings = true;
 149 
 150         deprecationHandler = new MandatoryWarningHandler(log, verboseDeprecated,
 151                 enforceMandatoryWarnings, &quot;deprecated&quot;, LintCategory.DEPRECATION);
 152         removalHandler = new MandatoryWarningHandler(log, verboseRemoval,
 153                 enforceMandatoryWarnings, &quot;removal&quot;, LintCategory.REMOVAL);
 154         uncheckedHandler = new MandatoryWarningHandler(log, verboseUnchecked,
 155                 enforceMandatoryWarnings, &quot;unchecked&quot;, LintCategory.UNCHECKED);
 156         sunApiHandler = new MandatoryWarningHandler(log, false,
 157                 enforceMandatoryWarnings, &quot;sunapi&quot;, null);
 158 
 159         deferredLintHandler = DeferredLintHandler.instance(context);
<a name="1" id="anc1"></a><span class="line-added"> 160 </span>
<span class="line-added"> 161         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;</span>
<span class="line-added"> 162                 Feature.RECORDS.allowedInSource(source);</span>
 163     }
 164 
 165     /** Character for synthetic names
 166      */
 167     char syntheticNameChar;
 168 
 169     /** A table mapping flat names of all compiled classes for each module in this run
 170      *  to their symbols; maintained from outside.
 171      */
 172     private Map&lt;Pair&lt;ModuleSymbol, Name&gt;,ClassSymbol&gt; compiled = new HashMap&lt;&gt;();
 173 
 174     /** A handler for messages about deprecated usage.
 175      */
 176     private MandatoryWarningHandler deprecationHandler;
 177 
 178     /** A handler for messages about deprecated-for-removal usage.
 179      */
 180     private MandatoryWarningHandler removalHandler;
 181 
 182     /** A handler for messages about unchecked or unsafe usage.
 183      */
 184     private MandatoryWarningHandler uncheckedHandler;
 185 
 186     /** A handler for messages about using proprietary API.
 187      */
 188     private MandatoryWarningHandler sunApiHandler;
 189 
 190     /** A handler for deferred lint warnings.
 191      */
 192     private DeferredLintHandler deferredLintHandler;
 193 
<a name="2" id="anc2"></a><span class="line-added"> 194     /** Are records allowed</span>
<span class="line-added"> 195      */</span>
<span class="line-added"> 196     private final boolean allowRecords;</span>
<span class="line-added"> 197 </span>
 198 /* *************************************************************************
 199  * Errors and Warnings
 200  **************************************************************************/
 201 
 202     Lint setLint(Lint newLint) {
 203         Lint prev = lint;
 204         lint = newLint;
 205         return prev;
 206     }
 207 
 208     MethodSymbol setMethod(MethodSymbol newMethod) {
 209         MethodSymbol prev = method;
 210         method = newMethod;
 211         return prev;
 212     }
 213 
 214     /** Warn about deprecated symbol.
 215      *  @param pos        Position to be used for error reporting.
 216      *  @param sym        The deprecated symbol.
 217      */
 218     void warnDeprecated(DiagnosticPosition pos, Symbol sym) {
 219         if (sym.isDeprecatedForRemoval()) {
 220             if (!lint.isSuppressed(LintCategory.REMOVAL)) {
 221                 if (sym.kind == MDL) {
 222                     removalHandler.report(pos, Warnings.HasBeenDeprecatedForRemovalModule(sym));
 223                 } else {
 224                     removalHandler.report(pos, Warnings.HasBeenDeprecatedForRemoval(sym, sym.location()));
 225                 }
 226             }
 227         } else if (!lint.isSuppressed(LintCategory.DEPRECATION)) {
 228             if (sym.kind == MDL) {
 229                 deprecationHandler.report(pos, Warnings.HasBeenDeprecatedModule(sym));
 230             } else {
 231                 deprecationHandler.report(pos, Warnings.HasBeenDeprecated(sym, sym.location()));
 232             }
 233         }
 234     }
 235 
 236     /** Warn about deprecated symbol.
 237      *  @param pos        Position to be used for error reporting.
 238      *  @param sym        The deprecated symbol.
 239      */
 240     void warnPreview(DiagnosticPosition pos, Symbol sym) {
 241         warnPreview(pos, Warnings.IsPreview(sym));
 242     }
 243 
 244     /** Log a preview warning.
 245      *  @param pos        Position to be used for error reporting.
 246      *  @param msg        A Warning describing the problem.
 247      */
 248     public void warnPreview(DiagnosticPosition pos, Warning warnKey) {
 249         if (!lint.isSuppressed(LintCategory.PREVIEW))
 250             preview.reportPreviewWarning(pos, warnKey);
 251     }
 252 
 253     /** Warn about unchecked operation.
 254      *  @param pos        Position to be used for error reporting.
 255      *  @param msg        A string describing the problem.
 256      */
 257     public void warnUnchecked(DiagnosticPosition pos, Warning warnKey) {
 258         if (!lint.isSuppressed(LintCategory.UNCHECKED))
 259             uncheckedHandler.report(pos, warnKey);
 260     }
 261 
 262     /** Warn about unsafe vararg method decl.
 263      *  @param pos        Position to be used for error reporting.
 264      */
 265     void warnUnsafeVararg(DiagnosticPosition pos, Warning warnKey) {
 266         if (lint.isEnabled(LintCategory.VARARGS))
 267             log.warning(LintCategory.VARARGS, pos, warnKey);
 268     }
 269 
 270     public void warnStatic(DiagnosticPosition pos, Warning warnKey) {
 271         if (lint.isEnabled(LintCategory.STATIC))
 272             log.warning(LintCategory.STATIC, pos, warnKey);
 273     }
 274 
 275     /** Warn about division by integer constant zero.
 276      *  @param pos        Position to be used for error reporting.
 277      */
 278     void warnDivZero(DiagnosticPosition pos) {
 279         if (lint.isEnabled(LintCategory.DIVZERO))
 280             log.warning(LintCategory.DIVZERO, pos, Warnings.DivZero);
 281     }
 282 
 283     /**
 284      * Report any deferred diagnostics.
 285      */
 286     public void reportDeferredDiagnostics() {
 287         deprecationHandler.reportDeferredDiagnostic();
 288         removalHandler.reportDeferredDiagnostic();
 289         uncheckedHandler.reportDeferredDiagnostic();
 290         sunApiHandler.reportDeferredDiagnostic();
 291     }
 292 
 293 
 294     /** Report a failure to complete a class.
 295      *  @param pos        Position to be used for error reporting.
 296      *  @param ex         The failure to report.
 297      */
 298     public Type completionError(DiagnosticPosition pos, CompletionFailure ex) {
 299         log.error(JCDiagnostic.DiagnosticFlag.NON_DEFERRABLE, pos, Errors.CantAccess(ex.sym, ex.getDetailValue()));
 300         return syms.errType;
 301     }
 302 
 303     /** Report an error that wrong type tag was found.
 304      *  @param pos        Position to be used for error reporting.
 305      *  @param required   An internationalized string describing the type tag
 306      *                    required.
 307      *  @param found      The type that was found.
 308      */
 309     Type typeTagError(DiagnosticPosition pos, JCDiagnostic required, Object found) {
 310         // this error used to be raised by the parser,
 311         // but has been delayed to this point:
 312         if (found instanceof Type &amp;&amp; ((Type)found).hasTag(VOID)) {
 313             log.error(pos, Errors.IllegalStartOfType);
 314             return syms.errType;
 315         }
 316         log.error(pos, Errors.TypeFoundReq(found, required));
 317         return types.createErrorType(found instanceof Type ? (Type)found : syms.errType);
 318     }
 319 
 320     /** Report an error that symbol cannot be referenced before super
 321      *  has been called.
 322      *  @param pos        Position to be used for error reporting.
 323      *  @param sym        The referenced symbol.
 324      */
 325     void earlyRefError(DiagnosticPosition pos, Symbol sym) {
 326         log.error(pos, Errors.CantRefBeforeCtorCalled(sym));
 327     }
 328 
 329     /** Report duplicate declaration error.
 330      */
 331     void duplicateError(DiagnosticPosition pos, Symbol sym) {
 332         if (!sym.type.isErroneous()) {
 333             Symbol location = sym.location();
 334             if (location.kind == MTH &amp;&amp;
 335                     ((MethodSymbol)location).isStaticOrInstanceInit()) {
 336                 log.error(pos,
 337                           Errors.AlreadyDefinedInClinit(kindName(sym),
 338                                                         sym,
 339                                                         kindName(sym.location()),
 340                                                         kindName(sym.location().enclClass()),
 341                                                         sym.location().enclClass()));
 342             } else {
 343                 /* dont error if this is a duplicated parameter of a generated canonical constructor
 344                  * as we should have issued an error for the duplicated fields
 345                  */
 346                 if (location.kind != MTH ||
 347                         ((sym.owner.flags_field &amp; GENERATEDCONSTR) == 0) ||
 348                         ((sym.owner.flags_field &amp; RECORD) == 0)) {
 349                     log.error(pos,
 350                             Errors.AlreadyDefined(kindName(sym),
 351                                     sym,
 352                                     kindName(sym.location()),
 353                                     sym.location()));
 354                 }
 355             }
 356         }
 357     }
 358 
 359     /** Report array/varargs duplicate declaration
 360      */
 361     void varargsDuplicateError(DiagnosticPosition pos, Symbol sym1, Symbol sym2) {
 362         if (!sym1.type.isErroneous() &amp;&amp; !sym2.type.isErroneous()) {
 363             log.error(pos, Errors.ArrayAndVarargs(sym1, sym2, sym2.location()));
 364         }
 365     }
 366 
 367 /* ************************************************************************
 368  * duplicate declaration checking
 369  *************************************************************************/
 370 
 371     /** Check that variable does not hide variable with same name in
 372      *  immediately enclosing local scope.
 373      *  @param pos           Position for error reporting.
 374      *  @param v             The symbol.
 375      *  @param s             The scope.
 376      */
 377     void checkTransparentVar(DiagnosticPosition pos, VarSymbol v, Scope s) {
 378         for (Symbol sym : s.getSymbolsByName(v.name)) {
 379             if (sym.owner != v.owner) break;
 380             if (sym.kind == VAR &amp;&amp;
 381                 sym.owner.kind.matches(KindSelector.VAL_MTH) &amp;&amp;
 382                 v.name != names.error) {
 383                 duplicateError(pos, sym);
 384                 return;
 385             }
 386         }
 387     }
 388 
 389     /** Check that a class or interface does not hide a class or
 390      *  interface with same name in immediately enclosing local scope.
 391      *  @param pos           Position for error reporting.
 392      *  @param c             The symbol.
 393      *  @param s             The scope.
 394      */
 395     void checkTransparentClass(DiagnosticPosition pos, ClassSymbol c, Scope s) {
 396         for (Symbol sym : s.getSymbolsByName(c.name)) {
 397             if (sym.owner != c.owner) break;
 398             if (sym.kind == TYP &amp;&amp; !sym.type.hasTag(TYPEVAR) &amp;&amp;
 399                 sym.owner.kind.matches(KindSelector.VAL_MTH) &amp;&amp;
 400                 c.name != names.error) {
 401                 duplicateError(pos, sym);
 402                 return;
 403             }
 404         }
 405     }
 406 
 407     /** Check that class does not have the same name as one of
 408      *  its enclosing classes, or as a class defined in its enclosing scope.
 409      *  return true if class is unique in its enclosing scope.
 410      *  @param pos           Position for error reporting.
 411      *  @param name          The class name.
 412      *  @param s             The enclosing scope.
 413      */
 414     boolean checkUniqueClassName(DiagnosticPosition pos, Name name, Scope s) {
 415         for (Symbol sym : s.getSymbolsByName(name, NON_RECURSIVE)) {
 416             if (sym.kind == TYP &amp;&amp; sym.name != names.error) {
 417                 duplicateError(pos, sym);
 418                 return false;
 419             }
 420         }
 421         for (Symbol sym = s.owner; sym != null; sym = sym.owner) {
 422             if (sym.kind == TYP &amp;&amp; sym.name == name &amp;&amp; sym.name != names.error) {
 423                 duplicateError(pos, sym);
 424                 return true;
 425             }
 426         }
 427         return true;
 428     }
 429 
 430 /* *************************************************************************
 431  * Class name generation
 432  **************************************************************************/
 433 
 434 
 435     private Map&lt;Pair&lt;Name, Name&gt;, Integer&gt; localClassNameIndexes = new HashMap&lt;&gt;();
 436 
 437     /** Return name of local class.
 438      *  This is of the form   {@code &lt;enclClass&gt; $ n &lt;classname&gt; }
 439      *  where
 440      *    enclClass is the flat name of the enclosing class,
 441      *    classname is the simple name of the local class
 442      */
 443     public Name localClassName(ClassSymbol c) {
 444         Name enclFlatname = c.owner.enclClass().flatname;
 445         String enclFlatnameStr = enclFlatname.toString();
 446         Pair&lt;Name, Name&gt; key = new Pair&lt;&gt;(enclFlatname, c.name);
 447         Integer index = localClassNameIndexes.get(key);
 448         for (int i = (index == null) ? 1 : index; ; i++) {
 449             Name flatname = names.fromString(enclFlatnameStr
 450                     + syntheticNameChar + i + c.name);
 451             if (getCompiled(c.packge().modle, flatname) == null) {
 452                 localClassNameIndexes.put(key, i + 1);
 453                 return flatname;
 454             }
 455         }
 456     }
 457 
 458     public void clearLocalClassNameIndexes(ClassSymbol c) {
 459         if (c.owner != null &amp;&amp; c.owner.kind != NIL) {
 460             localClassNameIndexes.remove(new Pair&lt;&gt;(
 461                     c.owner.enclClass().flatname, c.name));
 462         }
 463     }
 464 
 465     public void newRound() {
 466         compiled.clear();
 467         localClassNameIndexes.clear();
 468     }
 469 
 470     public void clear() {
 471         deprecationHandler.clear();
 472         removalHandler.clear();
 473         uncheckedHandler.clear();
 474         sunApiHandler.clear();
 475     }
 476 
 477     public void putCompiled(ClassSymbol csym) {
 478         compiled.put(Pair.of(csym.packge().modle, csym.flatname), csym);
 479     }
 480 
 481     public ClassSymbol getCompiled(ClassSymbol csym) {
 482         return compiled.get(Pair.of(csym.packge().modle, csym.flatname));
 483     }
 484 
 485     public ClassSymbol getCompiled(ModuleSymbol msym, Name flatname) {
 486         return compiled.get(Pair.of(msym, flatname));
 487     }
 488 
 489     public void removeCompiled(ClassSymbol csym) {
 490         compiled.remove(Pair.of(csym.packge().modle, csym.flatname));
 491     }
 492 
 493 /* *************************************************************************
 494  * Type Checking
 495  **************************************************************************/
 496 
 497     /**
 498      * A check context is an object that can be used to perform compatibility
 499      * checks - depending on the check context, meaning of &#39;compatibility&#39; might
 500      * vary significantly.
 501      */
 502     public interface CheckContext {
 503         /**
 504          * Is type &#39;found&#39; compatible with type &#39;req&#39; in given context
 505          */
 506         boolean compatible(Type found, Type req, Warner warn);
 507         /**
 508          * Report a check error
 509          */
 510         void report(DiagnosticPosition pos, JCDiagnostic details);
 511         /**
 512          * Obtain a warner for this check context
 513          */
 514         public Warner checkWarner(DiagnosticPosition pos, Type found, Type req);
 515 
 516         public InferenceContext inferenceContext();
 517 
 518         public DeferredAttr.DeferredAttrContext deferredAttrContext();
 519     }
 520 
 521     /**
 522      * This class represent a check context that is nested within another check
 523      * context - useful to check sub-expressions. The default behavior simply
 524      * redirects all method calls to the enclosing check context leveraging
 525      * the forwarding pattern.
 526      */
 527     static class NestedCheckContext implements CheckContext {
 528         CheckContext enclosingContext;
 529 
 530         NestedCheckContext(CheckContext enclosingContext) {
 531             this.enclosingContext = enclosingContext;
 532         }
 533 
 534         public boolean compatible(Type found, Type req, Warner warn) {
 535             return enclosingContext.compatible(found, req, warn);
 536         }
 537 
 538         public void report(DiagnosticPosition pos, JCDiagnostic details) {
 539             enclosingContext.report(pos, details);
 540         }
 541 
 542         public Warner checkWarner(DiagnosticPosition pos, Type found, Type req) {
 543             return enclosingContext.checkWarner(pos, found, req);
 544         }
 545 
 546         public InferenceContext inferenceContext() {
 547             return enclosingContext.inferenceContext();
 548         }
 549 
 550         public DeferredAttrContext deferredAttrContext() {
 551             return enclosingContext.deferredAttrContext();
 552         }
 553     }
 554 
 555     /**
 556      * Check context to be used when evaluating assignment/return statements
 557      */
 558     CheckContext basicHandler = new CheckContext() {
 559         public void report(DiagnosticPosition pos, JCDiagnostic details) {
 560             log.error(pos, Errors.ProbFoundReq(details));
 561         }
 562         public boolean compatible(Type found, Type req, Warner warn) {
 563             return types.isAssignable(found, req, warn);
 564         }
 565 
 566         public Warner checkWarner(DiagnosticPosition pos, Type found, Type req) {
 567             return convertWarner(pos, found, req);
 568         }
 569 
 570         public InferenceContext inferenceContext() {
 571             return infer.emptyContext;
 572         }
 573 
 574         public DeferredAttrContext deferredAttrContext() {
 575             return deferredAttr.emptyDeferredAttrContext;
 576         }
 577 
 578         @Override
 579         public String toString() {
 580             return &quot;CheckContext: basicHandler&quot;;
 581         }
 582     };
 583 
 584     /** Check that a given type is assignable to a given proto-type.
 585      *  If it is, return the type, otherwise return errType.
 586      *  @param pos        Position to be used for error reporting.
 587      *  @param found      The type that was found.
 588      *  @param req        The type that was required.
 589      */
 590     public Type checkType(DiagnosticPosition pos, Type found, Type req) {
 591         return checkType(pos, found, req, basicHandler);
 592     }
 593 
 594     Type checkType(final DiagnosticPosition pos, final Type found, final Type req, final CheckContext checkContext) {
 595         final InferenceContext inferenceContext = checkContext.inferenceContext();
 596         if (inferenceContext.free(req) || inferenceContext.free(found)) {
 597             inferenceContext.addFreeTypeListener(List.of(req, found),
 598                     solvedContext -&gt; checkType(pos, solvedContext.asInstType(found), solvedContext.asInstType(req), checkContext));
 599         }
 600         if (req.hasTag(ERROR))
 601             return req;
 602         if (req.hasTag(NONE))
 603             return found;
 604         if (checkContext.compatible(found, req, checkContext.checkWarner(pos, found, req))) {
 605             return found;
 606         } else {
 607             if (found.isNumeric() &amp;&amp; req.isNumeric()) {
 608                 checkContext.report(pos, diags.fragment(Fragments.PossibleLossOfPrecision(found, req)));
 609                 return types.createErrorType(found);
 610             }
 611             checkContext.report(pos, diags.fragment(Fragments.InconvertibleTypes(found, req)));
 612             return types.createErrorType(found);
 613         }
 614     }
 615 
 616     /** Check that a given type can be cast to a given target type.
 617      *  Return the result of the cast.
 618      *  @param pos        Position to be used for error reporting.
 619      *  @param found      The type that is being cast.
 620      *  @param req        The target type of the cast.
 621      */
 622     Type checkCastable(DiagnosticPosition pos, Type found, Type req) {
 623         return checkCastable(pos, found, req, basicHandler);
 624     }
 625     Type checkCastable(DiagnosticPosition pos, Type found, Type req, CheckContext checkContext) {
 626         if (types.isCastable(found, req, castWarner(pos, found, req))) {
 627             return req;
 628         } else {
 629             checkContext.report(pos, diags.fragment(Fragments.InconvertibleTypes(found, req)));
 630             return types.createErrorType(found);
 631         }
 632     }
 633 
 634     /** Check for redundant casts (i.e. where source type is a subtype of target type)
 635      * The problem should only be reported for non-292 cast
 636      */
 637     public void checkRedundantCast(Env&lt;AttrContext&gt; env, final JCTypeCast tree) {
 638         if (!tree.type.isErroneous()
 639                 &amp;&amp; types.isSameType(tree.expr.type, tree.clazz.type)
 640                 &amp;&amp; !(ignoreAnnotatedCasts &amp;&amp; TreeInfo.containsTypeAnnotation(tree.clazz))
 641                 &amp;&amp; !is292targetTypeCast(tree)) {
 642             deferredLintHandler.report(() -&gt; {
 643                 if (lint.isEnabled(LintCategory.CAST))
 644                     log.warning(LintCategory.CAST,
 645                             tree.pos(), Warnings.RedundantCast(tree.clazz.type));
 646             });
 647         }
 648     }
 649     //where
 650         private boolean is292targetTypeCast(JCTypeCast tree) {
 651             boolean is292targetTypeCast = false;
 652             JCExpression expr = TreeInfo.skipParens(tree.expr);
 653             if (expr.hasTag(APPLY)) {
 654                 JCMethodInvocation apply = (JCMethodInvocation)expr;
 655                 Symbol sym = TreeInfo.symbol(apply.meth);
 656                 is292targetTypeCast = sym != null &amp;&amp;
 657                     sym.kind == MTH &amp;&amp;
 658                     (sym.flags() &amp; HYPOTHETICAL) != 0;
 659             }
 660             return is292targetTypeCast;
 661         }
 662 
 663         private static final boolean ignoreAnnotatedCasts = true;
 664 
 665     /** Check that a type is within some bounds.
 666      *
 667      *  Used in TypeApply to verify that, e.g., X in {@code V&lt;X&gt;} is a valid
 668      *  type argument.
 669      *  @param a             The type that should be bounded by bs.
 670      *  @param bound         The bound.
 671      */
 672     private boolean checkExtends(Type a, Type bound) {
 673          if (a.isUnbound()) {
 674              return true;
 675          } else if (!a.hasTag(WILDCARD)) {
 676              a = types.cvarUpperBound(a);
 677              return types.isSubtype(a, bound);
 678          } else if (a.isExtendsBound()) {
 679              return types.isCastable(bound, types.wildUpperBound(a), types.noWarnings);
 680          } else if (a.isSuperBound()) {
 681              return !types.notSoftSubtype(types.wildLowerBound(a), bound);
 682          }
 683          return true;
 684      }
 685 
 686     /** Check that type is different from &#39;void&#39;.
 687      *  @param pos           Position to be used for error reporting.
 688      *  @param t             The type to be checked.
 689      */
 690     Type checkNonVoid(DiagnosticPosition pos, Type t) {
 691         if (t.hasTag(VOID)) {
 692             log.error(pos, Errors.VoidNotAllowedHere);
 693             return types.createErrorType(t);
 694         } else {
 695             return t;
 696         }
 697     }
 698 
 699     Type checkClassOrArrayType(DiagnosticPosition pos, Type t) {
 700         if (!t.hasTag(CLASS) &amp;&amp; !t.hasTag(ARRAY) &amp;&amp; !t.hasTag(ERROR)) {
 701             return typeTagError(pos,
 702                                 diags.fragment(Fragments.TypeReqClassArray),
 703                                 asTypeParam(t));
 704         } else {
 705             return t;
 706         }
 707     }
 708 
 709     /** Check that type is a class or interface type.
 710      *  @param pos           Position to be used for error reporting.
 711      *  @param t             The type to be checked.
 712      */
 713     Type checkClassType(DiagnosticPosition pos, Type t) {
 714         if (!t.hasTag(CLASS) &amp;&amp; !t.hasTag(ERROR)) {
 715             return typeTagError(pos,
 716                                 diags.fragment(Fragments.TypeReqClass),
 717                                 asTypeParam(t));
 718         } else {
 719             return t;
 720         }
 721     }
 722     //where
 723         private Object asTypeParam(Type t) {
 724             return (t.hasTag(TYPEVAR))
 725                                     ? diags.fragment(Fragments.TypeParameter(t))
 726                                     : t;
 727         }
 728 
 729     /** Check that type is a valid qualifier for a constructor reference expression
 730      */
 731     Type checkConstructorRefType(DiagnosticPosition pos, Type t) {
 732         t = checkClassOrArrayType(pos, t);
 733         if (t.hasTag(CLASS)) {
 734             if ((t.tsym.flags() &amp; (ABSTRACT | INTERFACE)) != 0) {
 735                 log.error(pos, Errors.AbstractCantBeInstantiated(t.tsym));
 736                 t = types.createErrorType(t);
 737             } else if ((t.tsym.flags() &amp; ENUM) != 0) {
 738                 log.error(pos, Errors.EnumCantBeInstantiated);
 739                 t = types.createErrorType(t);
 740             } else {
 741                 t = checkClassType(pos, t, true);
 742             }
 743         } else if (t.hasTag(ARRAY)) {
 744             if (!types.isReifiable(((ArrayType)t).elemtype)) {
 745                 log.error(pos, Errors.GenericArrayCreation);
 746                 t = types.createErrorType(t);
 747             }
 748         }
 749         return t;
 750     }
 751 
 752     /** Check that type is a class or interface type.
 753      *  @param pos           Position to be used for error reporting.
 754      *  @param t             The type to be checked.
 755      *  @param noBounds    True if type bounds are illegal here.
 756      */
 757     Type checkClassType(DiagnosticPosition pos, Type t, boolean noBounds) {
 758         t = checkClassType(pos, t);
 759         if (noBounds &amp;&amp; t.isParameterized()) {
 760             List&lt;Type&gt; args = t.getTypeArguments();
 761             while (args.nonEmpty()) {
 762                 if (args.head.hasTag(WILDCARD))
 763                     return typeTagError(pos,
 764                                         diags.fragment(Fragments.TypeReqExact),
 765                                         args.head);
 766                 args = args.tail;
 767             }
 768         }
 769         return t;
 770     }
 771 
 772     /** Check that type is a reference type, i.e. a class, interface or array type
 773      *  or a type variable.
 774      *  @param pos           Position to be used for error reporting.
 775      *  @param t             The type to be checked.
 776      */
 777     Type checkRefType(DiagnosticPosition pos, Type t) {
 778         if (t.isReference())
 779             return t;
 780         else
 781             return typeTagError(pos,
 782                                 diags.fragment(Fragments.TypeReqRef),
 783                                 t);
 784     }
 785 
 786     /** Check that each type is a reference type, i.e. a class, interface or array type
 787      *  or a type variable.
 788      *  @param trees         Original trees, used for error reporting.
 789      *  @param types         The types to be checked.
 790      */
 791     List&lt;Type&gt; checkRefTypes(List&lt;JCExpression&gt; trees, List&lt;Type&gt; types) {
 792         List&lt;JCExpression&gt; tl = trees;
 793         for (List&lt;Type&gt; l = types; l.nonEmpty(); l = l.tail) {
 794             l.head = checkRefType(tl.head.pos(), l.head);
 795             tl = tl.tail;
 796         }
 797         return types;
 798     }
 799 
 800     /** Check that type is a null or reference type.
 801      *  @param pos           Position to be used for error reporting.
 802      *  @param t             The type to be checked.
 803      */
 804     Type checkNullOrRefType(DiagnosticPosition pos, Type t) {
 805         if (t.isReference() || t.hasTag(BOT))
 806             return t;
 807         else
 808             return typeTagError(pos,
 809                                 diags.fragment(Fragments.TypeReqRef),
 810                                 t);
 811     }
 812 
 813     /** Check that flag set does not contain elements of two conflicting sets. s
 814      *  Return true if it doesn&#39;t.
 815      *  @param pos           Position to be used for error reporting.
 816      *  @param flags         The set of flags to be checked.
 817      *  @param set1          Conflicting flags set #1.
 818      *  @param set2          Conflicting flags set #2.
 819      */
 820     boolean checkDisjoint(DiagnosticPosition pos, long flags, long set1, long set2) {
 821         if ((flags &amp; set1) != 0 &amp;&amp; (flags &amp; set2) != 0) {
 822             log.error(pos,
 823                       Errors.IllegalCombinationOfModifiers(asFlagSet(TreeInfo.firstFlag(flags &amp; set1)),
 824                                                            asFlagSet(TreeInfo.firstFlag(flags &amp; set2))));
 825             return false;
 826         } else
 827             return true;
 828     }
 829 
 830     /** Check that usage of diamond operator is correct (i.e. diamond should not
 831      * be used with non-generic classes or in anonymous class creation expressions)
 832      */
 833     Type checkDiamond(JCNewClass tree, Type t) {
 834         if (!TreeInfo.isDiamond(tree) ||
 835                 t.isErroneous()) {
 836             return checkClassType(tree.clazz.pos(), t, true);
 837         } else {
 838             if (tree.def != null &amp;&amp; !Feature.DIAMOND_WITH_ANONYMOUS_CLASS_CREATION.allowedInSource(source)) {
 839                 log.error(DiagnosticFlag.SOURCE_LEVEL, tree.clazz.pos(),
 840                         Errors.CantApplyDiamond1(t, Feature.DIAMOND_WITH_ANONYMOUS_CLASS_CREATION.fragment(source.name)));
 841             }
 842             if (t.tsym.type.getTypeArguments().isEmpty()) {
 843                 log.error(tree.clazz.pos(),
 844                           Errors.CantApplyDiamond1(t,
 845                                                    Fragments.DiamondNonGeneric(t)));
 846                 return types.createErrorType(t);
 847             } else if (tree.typeargs != null &amp;&amp;
 848                     tree.typeargs.nonEmpty()) {
 849                 log.error(tree.clazz.pos(),
 850                           Errors.CantApplyDiamond1(t,
 851                                                    Fragments.DiamondAndExplicitParams(t)));
 852                 return types.createErrorType(t);
 853             } else {
 854                 return t;
 855             }
 856         }
 857     }
 858 
 859     /** Check that the type inferred using the diamond operator does not contain
 860      *  non-denotable types such as captured types or intersection types.
 861      *  @param t the type inferred using the diamond operator
 862      *  @return  the (possibly empty) list of non-denotable types.
 863      */
 864     List&lt;Type&gt; checkDiamondDenotable(ClassType t) {
 865         ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
 866         for (Type arg : t.allparams()) {
 867             if (!checkDenotable(arg)) {
 868                 buf.append(arg);
 869             }
 870         }
 871         return buf.toList();
 872     }
 873 
 874     public boolean checkDenotable(Type t) {
 875         return denotableChecker.visit(t, null);
 876     }
 877         // where
 878 
 879         /** diamondTypeChecker: A type visitor that descends down the given type looking for non-denotable
 880          *  types. The visit methods return false as soon as a non-denotable type is encountered and true
 881          *  otherwise.
 882          */
 883         private static final Types.SimpleVisitor&lt;Boolean, Void&gt; denotableChecker = new Types.SimpleVisitor&lt;Boolean, Void&gt;() {
 884             @Override
 885             public Boolean visitType(Type t, Void s) {
 886                 return true;
 887             }
 888             @Override
 889             public Boolean visitClassType(ClassType t, Void s) {
 890                 if (t.isUnion() || t.isIntersection()) {
 891                     return false;
 892                 }
 893                 for (Type targ : t.allparams()) {
 894                     if (!visit(targ, s)) {
 895                         return false;
 896                     }
 897                 }
 898                 return true;
 899             }
 900 
 901             @Override
 902             public Boolean visitTypeVar(TypeVar t, Void s) {
 903                 /* Any type variable mentioned in the inferred type must have been declared as a type parameter
 904                   (i.e cannot have been produced by inference (18.4))
 905                 */
 906                 return (t.tsym.flags() &amp; SYNTHETIC) == 0;
 907             }
 908 
 909             @Override
 910             public Boolean visitCapturedType(CapturedType t, Void s) {
 911                 /* Any type variable mentioned in the inferred type must have been declared as a type parameter
 912                   (i.e cannot have been produced by capture conversion (5.1.10))
 913                 */
 914                 return false;
 915             }
 916 
 917             @Override
 918             public Boolean visitArrayType(ArrayType t, Void s) {
 919                 return visit(t.elemtype, s);
 920             }
 921 
 922             @Override
 923             public Boolean visitWildcardType(WildcardType t, Void s) {
 924                 return visit(t.type, s);
 925             }
 926         };
 927 
 928     void checkVarargsMethodDecl(Env&lt;AttrContext&gt; env, JCMethodDecl tree) {
 929         MethodSymbol m = tree.sym;
 930         boolean hasTrustMeAnno = m.attribute(syms.trustMeType.tsym) != null;
 931         Type varargElemType = null;
 932         if (m.isVarArgs()) {
 933             varargElemType = types.elemtype(tree.params.last().type);
 934         }
 935         if (hasTrustMeAnno &amp;&amp; !isTrustMeAllowedOnMethod(m)) {
 936             if (varargElemType != null) {
 937                 JCDiagnostic msg = Feature.PRIVATE_SAFE_VARARGS.allowedInSource(source) ?
 938                         diags.fragment(Fragments.VarargsTrustmeOnVirtualVarargs(m)) :
 939                         diags.fragment(Fragments.VarargsTrustmeOnVirtualVarargsFinalOnly(m));
 940                 log.error(tree,
 941                           Errors.VarargsInvalidTrustmeAnno(syms.trustMeType.tsym,
 942                                                            msg));
 943             } else {
 944                 log.error(tree,
 945                           Errors.VarargsInvalidTrustmeAnno(syms.trustMeType.tsym,
 946                                                            Fragments.VarargsTrustmeOnNonVarargsMeth(m)));
 947             }
 948         } else if (hasTrustMeAnno &amp;&amp; varargElemType != null &amp;&amp;
 949                             types.isReifiable(varargElemType)) {
 950             warnUnsafeVararg(tree, Warnings.VarargsRedundantTrustmeAnno(
 951                                 syms.trustMeType.tsym,
 952                                 diags.fragment(Fragments.VarargsTrustmeOnReifiableVarargs(varargElemType))));
 953         }
 954         else if (!hasTrustMeAnno &amp;&amp; varargElemType != null &amp;&amp;
 955                 !types.isReifiable(varargElemType)) {
 956             warnUnchecked(tree.params.head.pos(), Warnings.UncheckedVarargsNonReifiableType(varargElemType));
 957         }
 958     }
 959     //where
 960         private boolean isTrustMeAllowedOnMethod(Symbol s) {
 961             return (s.flags() &amp; VARARGS) != 0 &amp;&amp;
 962                 (s.isConstructor() ||
 963                     (s.flags() &amp; (STATIC | FINAL |
 964                                   (Feature.PRIVATE_SAFE_VARARGS.allowedInSource(source) ? PRIVATE : 0) )) != 0);
 965         }
 966 
 967     Type checkLocalVarType(DiagnosticPosition pos, Type t, Name name) {
 968         //check that resulting type is not the null type
 969         if (t.hasTag(BOT)) {
 970             log.error(pos, Errors.CantInferLocalVarType(name, Fragments.LocalCantInferNull));
 971             return types.createErrorType(t);
 972         } else if (t.hasTag(VOID)) {
 973             log.error(pos, Errors.CantInferLocalVarType(name, Fragments.LocalCantInferVoid));
 974             return types.createErrorType(t);
 975         }
 976 
 977         //upward project the initializer type
 978         return types.upward(t, types.captures(t));
 979     }
 980 
 981     Type checkMethod(final Type mtype,
 982             final Symbol sym,
 983             final Env&lt;AttrContext&gt; env,
 984             final List&lt;JCExpression&gt; argtrees,
 985             final List&lt;Type&gt; argtypes,
 986             final boolean useVarargs,
 987             InferenceContext inferenceContext) {
 988         // System.out.println(&quot;call   : &quot; + env.tree);
 989         // System.out.println(&quot;method : &quot; + owntype);
 990         // System.out.println(&quot;actuals: &quot; + argtypes);
 991         if (inferenceContext.free(mtype)) {
 992             inferenceContext.addFreeTypeListener(List.of(mtype),
 993                     solvedContext -&gt; checkMethod(solvedContext.asInstType(mtype), sym, env, argtrees, argtypes, useVarargs, solvedContext));
 994             return mtype;
 995         }
 996         Type owntype = mtype;
 997         List&lt;Type&gt; formals = owntype.getParameterTypes();
 998         List&lt;Type&gt; nonInferred = sym.type.getParameterTypes();
 999         if (nonInferred.length() != formals.length()) nonInferred = formals;
1000         Type last = useVarargs ? formals.last() : null;
1001         if (sym.name == names.init &amp;&amp; sym.owner == syms.enumSym) {
1002             formals = formals.tail.tail;
1003             nonInferred = nonInferred.tail.tail;
1004         }
1005         if ((sym.flags() &amp; ANONCONSTR_BASED) != 0) {
1006             formals = formals.tail;
1007             nonInferred = nonInferred.tail;
1008         }
1009         List&lt;JCExpression&gt; args = argtrees;
1010         if (args != null) {
1011             //this is null when type-checking a method reference
1012             while (formals.head != last) {
1013                 JCTree arg = args.head;
1014                 Warner warn = convertWarner(arg.pos(), arg.type, nonInferred.head);
1015                 assertConvertible(arg, arg.type, formals.head, warn);
1016                 args = args.tail;
1017                 formals = formals.tail;
1018                 nonInferred = nonInferred.tail;
1019             }
1020             if (useVarargs) {
1021                 Type varArg = types.elemtype(last);
1022                 while (args.tail != null) {
1023                     JCTree arg = args.head;
1024                     Warner warn = convertWarner(arg.pos(), arg.type, varArg);
1025                     assertConvertible(arg, arg.type, varArg, warn);
1026                     args = args.tail;
1027                 }
1028             } else if ((sym.flags() &amp; (VARARGS | SIGNATURE_POLYMORPHIC)) == VARARGS) {
1029                 // non-varargs call to varargs method
1030                 Type varParam = owntype.getParameterTypes().last();
1031                 Type lastArg = argtypes.last();
1032                 if (types.isSubtypeUnchecked(lastArg, types.elemtype(varParam)) &amp;&amp;
1033                     !types.isSameType(types.erasure(varParam), types.erasure(lastArg)))
1034                     log.warning(argtrees.last().pos(),
1035                                 Warnings.InexactNonVarargsCall(types.elemtype(varParam),varParam));
1036             }
1037         }
1038         if (useVarargs) {
1039             Type argtype = owntype.getParameterTypes().last();
1040             if (!types.isReifiable(argtype) &amp;&amp;
1041                 (sym.baseSymbol().attribute(syms.trustMeType.tsym) == null ||
1042                  !isTrustMeAllowedOnMethod(sym))) {
1043                 warnUnchecked(env.tree.pos(), Warnings.UncheckedGenericArrayCreation(argtype));
1044             }
1045             TreeInfo.setVarargsElement(env.tree, types.elemtype(argtype));
1046          }
1047          return owntype;
1048     }
1049     //where
1050     private void assertConvertible(JCTree tree, Type actual, Type formal, Warner warn) {
1051         if (types.isConvertible(actual, formal, warn))
1052             return;
1053 
1054         if (formal.isCompound()
1055             &amp;&amp; types.isSubtype(actual, types.supertype(formal))
1056             &amp;&amp; types.isSubtypeUnchecked(actual, types.interfaces(formal), warn))
1057             return;
1058     }
1059 
1060     /**
1061      * Check that type &#39;t&#39; is a valid instantiation of a generic class
1062      * (see JLS 4.5)
1063      *
1064      * @param t class type to be checked
1065      * @return true if &#39;t&#39; is well-formed
1066      */
1067     public boolean checkValidGenericType(Type t) {
1068         return firstIncompatibleTypeArg(t) == null;
1069     }
1070     //WHERE
1071         private Type firstIncompatibleTypeArg(Type type) {
1072             List&lt;Type&gt; formals = type.tsym.type.allparams();
1073             List&lt;Type&gt; actuals = type.allparams();
1074             List&lt;Type&gt; args = type.getTypeArguments();
1075             List&lt;Type&gt; forms = type.tsym.type.getTypeArguments();
1076             ListBuffer&lt;Type&gt; bounds_buf = new ListBuffer&lt;&gt;();
1077 
1078             // For matching pairs of actual argument types `a&#39; and
1079             // formal type parameters with declared bound `b&#39; ...
1080             while (args.nonEmpty() &amp;&amp; forms.nonEmpty()) {
1081                 // exact type arguments needs to know their
1082                 // bounds (for upper and lower bound
1083                 // calculations).  So we create new bounds where
1084                 // type-parameters are replaced with actuals argument types.
1085                 bounds_buf.append(types.subst(forms.head.getUpperBound(), formals, actuals));
1086                 args = args.tail;
1087                 forms = forms.tail;
1088             }
1089 
1090             args = type.getTypeArguments();
1091             List&lt;Type&gt; tvars_cap = types.substBounds(formals,
1092                                       formals,
1093                                       types.capture(type).allparams());
1094             while (args.nonEmpty() &amp;&amp; tvars_cap.nonEmpty()) {
1095                 // Let the actual arguments know their bound
1096                 args.head.withTypeVar((TypeVar)tvars_cap.head);
1097                 args = args.tail;
1098                 tvars_cap = tvars_cap.tail;
1099             }
1100 
1101             args = type.getTypeArguments();
1102             List&lt;Type&gt; bounds = bounds_buf.toList();
1103 
1104             while (args.nonEmpty() &amp;&amp; bounds.nonEmpty()) {
1105                 Type actual = args.head;
1106                 if (!isTypeArgErroneous(actual) &amp;&amp;
1107                         !bounds.head.isErroneous() &amp;&amp;
1108                         !checkExtends(actual, bounds.head)) {
1109                     return args.head;
1110                 }
1111                 args = args.tail;
1112                 bounds = bounds.tail;
1113             }
1114 
1115             args = type.getTypeArguments();
1116             bounds = bounds_buf.toList();
1117 
1118             for (Type arg : types.capture(type).getTypeArguments()) {
1119                 if (arg.hasTag(TYPEVAR) &amp;&amp;
1120                         arg.getUpperBound().isErroneous() &amp;&amp;
1121                         !bounds.head.isErroneous() &amp;&amp;
1122                         !isTypeArgErroneous(args.head)) {
1123                     return args.head;
1124                 }
1125                 bounds = bounds.tail;
1126                 args = args.tail;
1127             }
1128 
1129             return null;
1130         }
1131         //where
1132         boolean isTypeArgErroneous(Type t) {
1133             return isTypeArgErroneous.visit(t);
1134         }
1135 
1136         Types.UnaryVisitor&lt;Boolean&gt; isTypeArgErroneous = new Types.UnaryVisitor&lt;Boolean&gt;() {
1137             public Boolean visitType(Type t, Void s) {
1138                 return t.isErroneous();
1139             }
1140             @Override
1141             public Boolean visitTypeVar(TypeVar t, Void s) {
1142                 return visit(t.getUpperBound());
1143             }
1144             @Override
1145             public Boolean visitCapturedType(CapturedType t, Void s) {
1146                 return visit(t.getUpperBound()) ||
1147                         visit(t.getLowerBound());
1148             }
1149             @Override
1150             public Boolean visitWildcardType(WildcardType t, Void s) {
1151                 return visit(t.type);
1152             }
1153         };
1154 
1155     /** Check that given modifiers are legal for given symbol and
1156      *  return modifiers together with any implicit modifiers for that symbol.
1157      *  Warning: we can&#39;t use flags() here since this method
1158      *  is called during class enter, when flags() would cause a premature
1159      *  completion.
1160      *  @param pos           Position to be used for error reporting.
1161      *  @param flags         The set of modifiers given in a definition.
1162      *  @param sym           The defined symbol.
1163      */
1164     long checkFlags(DiagnosticPosition pos, long flags, Symbol sym, JCTree tree) {
1165         long mask;
1166         long implicit = 0;
1167 
1168         switch (sym.kind) {
1169         case VAR:
1170             if (TreeInfo.isReceiverParam(tree))
1171                 mask = ReceiverParamFlags;
1172             else if (sym.owner.kind != TYP)
1173                 mask = LocalVarFlags;
1174             else if ((sym.owner.flags_field &amp; INTERFACE) != 0)
1175                 mask = implicit = InterfaceVarFlags;
1176             else
1177                 mask = VarFlags;
1178             break;
1179         case MTH:
1180             if (sym.name == names.init) {
1181                 if ((sym.owner.flags_field &amp; ENUM) != 0) {
1182                     // enum constructors cannot be declared public or
1183                     // protected and must be implicitly or explicitly
1184                     // private
1185                     implicit = PRIVATE;
1186                     mask = PRIVATE;
1187                 } else
1188                     mask = ConstructorFlags;
1189             }  else if ((sym.owner.flags_field &amp; INTERFACE) != 0) {
1190                 if ((sym.owner.flags_field &amp; ANNOTATION) != 0) {
1191                     mask = AnnotationTypeElementMask;
1192                     implicit = PUBLIC | ABSTRACT;
1193                 } else if ((flags &amp; (DEFAULT | STATIC | PRIVATE)) != 0) {
1194                     mask = InterfaceMethodMask;
1195                     implicit = (flags &amp; PRIVATE) != 0 ? 0 : PUBLIC;
1196                     if ((flags &amp; DEFAULT) != 0) {
1197                         implicit |= ABSTRACT;
1198                     }
1199                 } else {
1200                     mask = implicit = InterfaceMethodFlags;
1201                 }
1202             } else if ((sym.owner.flags_field &amp; RECORD) != 0) {
1203                 mask = RecordMethodFlags;
1204             } else {
1205                 mask = MethodFlags;
1206             }
1207             // Imply STRICTFP if owner has STRICTFP set.
1208             if (((flags|implicit) &amp; Flags.ABSTRACT) == 0 ||
1209                 ((flags) &amp; Flags.DEFAULT) != 0)
1210                 implicit |= sym.owner.flags_field &amp; STRICTFP;
1211             break;
1212         case TYP:
1213             if (sym.isLocal()) {
1214                 mask = (flags &amp; RECORD) != 0 ? LocalRecordFlags : LocalClassFlags;
1215                 if ((flags &amp; RECORD) != 0) {
1216                     implicit = STATIC;
1217                     if (sym.owner.kind == TYP) {
1218                         log.error(pos, Errors.RecordDeclarationNotAllowedInInnerClasses);
1219                     }
1220                 }
1221                 if ((sym.owner.flags_field &amp; STATIC) == 0 &amp;&amp;
1222                     (flags &amp; ENUM) != 0) {
1223                     log.error(pos, Errors.EnumsMustBeStatic);
1224                 }
1225             } else if (sym.owner.kind == TYP) {
1226                 mask = (flags &amp; RECORD) != 0 ? MemberRecordFlags : MemberClassFlags;
1227                 if (sym.owner.owner.kind == PCK ||
1228                     (sym.owner.flags_field &amp; STATIC) != 0)
1229                     mask |= STATIC;
1230                 else if ((flags &amp; ENUM) != 0) {
1231                     log.error(pos, Errors.EnumsMustBeStatic);
1232                 } else if ((flags &amp; RECORD) != 0) {
1233                     log.error(pos, Errors.RecordDeclarationNotAllowedInInnerClasses);
1234                 }
1235                 // Nested interfaces and enums are always STATIC (Spec ???)
1236                 if ((flags &amp; (INTERFACE | ENUM | RECORD)) != 0 ) implicit = STATIC;
1237             } else {
1238                 mask = ClassFlags;
1239             }
1240             // Interfaces are always ABSTRACT
1241             if ((flags &amp; INTERFACE) != 0) implicit |= ABSTRACT;
1242 
1243             if ((flags &amp; ENUM) != 0) {
1244                 // enums can&#39;t be declared abstract or final
1245                 mask &amp;= ~(ABSTRACT | FINAL);
1246                 implicit |= implicitEnumFinalFlag(tree);
1247             }
1248             if ((flags &amp; RECORD) != 0) {
1249                 // records can&#39;t be declared abstract
1250                 mask &amp;= ~ABSTRACT;
1251                 implicit |= FINAL;
1252             }
1253             // Imply STRICTFP if owner has STRICTFP set.
1254             implicit |= sym.owner.flags_field &amp; STRICTFP;
1255             break;
1256         default:
1257             throw new AssertionError();
1258         }
1259         long illegal = flags &amp; ExtendedStandardFlags &amp; ~mask;
1260         if (illegal != 0) {
1261             if ((illegal &amp; INTERFACE) != 0) {
1262                 log.error(pos, ((flags &amp; ANNOTATION) != 0) ? Errors.AnnotationDeclNotAllowedHere : Errors.IntfNotAllowedHere);
1263                 mask |= INTERFACE;
1264             }
1265             else {
1266                 log.error(pos,
1267                           Errors.ModNotAllowedHere(asFlagSet(illegal)));
1268             }
1269         }
1270         else if ((sym.kind == TYP ||
1271                   // ISSUE: Disallowing abstract&amp;private is no longer appropriate
1272                   // in the presence of inner classes. Should it be deleted here?
1273                   checkDisjoint(pos, flags,
1274                                 ABSTRACT,
1275                                 PRIVATE | STATIC | DEFAULT))
1276                  &amp;&amp;
1277                  checkDisjoint(pos, flags,
1278                                 STATIC | PRIVATE,
1279                                 DEFAULT)
1280                  &amp;&amp;
1281                  checkDisjoint(pos, flags,
1282                                ABSTRACT | INTERFACE,
1283                                FINAL | NATIVE | SYNCHRONIZED)
1284                  &amp;&amp;
1285                  checkDisjoint(pos, flags,
1286                                PUBLIC,
1287                                PRIVATE | PROTECTED)
1288                  &amp;&amp;
1289                  checkDisjoint(pos, flags,
1290                                PRIVATE,
1291                                PUBLIC | PROTECTED)
1292                  &amp;&amp;
1293                  checkDisjoint(pos, flags,
1294                                FINAL,
1295                                VOLATILE)
1296                  &amp;&amp;
1297                  (sym.kind == TYP ||
1298                   checkDisjoint(pos, flags,
1299                                 ABSTRACT | NATIVE,
1300                                 STRICTFP))) {
1301             // skip
1302         }
1303         return flags &amp; (mask | ~ExtendedStandardFlags) | implicit;
1304     }
1305 
1306 
1307     /** Determine if this enum should be implicitly final.
1308      *
1309      *  If the enum has no specialized enum constants, it is final.
1310      *
1311      *  If the enum does have specialized enum constants, it is
1312      *  &lt;i&gt;not&lt;/i&gt; final.
1313      */
1314     private long implicitEnumFinalFlag(JCTree tree) {
1315         if (!tree.hasTag(CLASSDEF)) return 0;
1316         class SpecialTreeVisitor extends JCTree.Visitor {
1317             boolean specialized;
1318             SpecialTreeVisitor() {
1319                 this.specialized = false;
1320             }
1321 
1322             @Override
1323             public void visitTree(JCTree tree) { /* no-op */ }
1324 
1325             @Override
1326             public void visitVarDef(JCVariableDecl tree) {
1327                 if ((tree.mods.flags &amp; ENUM) != 0) {
1328                     if (tree.init instanceof JCNewClass &amp;&amp;
1329                         ((JCNewClass) tree.init).def != null) {
1330                         specialized = true;
1331                     }
1332                 }
1333             }
1334         }
1335 
1336         SpecialTreeVisitor sts = new SpecialTreeVisitor();
1337         JCClassDecl cdef = (JCClassDecl) tree;
1338         for (JCTree defs: cdef.defs) {
1339             defs.accept(sts);
1340             if (sts.specialized) return 0;
1341         }
1342         return FINAL;
1343     }
1344 
1345 /* *************************************************************************
1346  * Type Validation
1347  **************************************************************************/
1348 
1349     /** Validate a type expression. That is,
1350      *  check that all type arguments of a parametric type are within
1351      *  their bounds. This must be done in a second phase after type attribution
1352      *  since a class might have a subclass as type parameter bound. E.g:
1353      *
1354      *  &lt;pre&gt;{@code
1355      *  class B&lt;A extends C&gt; { ... }
1356      *  class C extends B&lt;C&gt; { ... }
1357      *  }&lt;/pre&gt;
1358      *
1359      *  and we can&#39;t make sure that the bound is already attributed because
1360      *  of possible cycles.
1361      *
1362      * Visitor method: Validate a type expression, if it is not null, catching
1363      *  and reporting any completion failures.
1364      */
1365     void validate(JCTree tree, Env&lt;AttrContext&gt; env) {
1366         validate(tree, env, true);
1367     }
1368     void validate(JCTree tree, Env&lt;AttrContext&gt; env, boolean checkRaw) {
1369         new Validator(env).validateTree(tree, checkRaw, true);
1370     }
1371 
1372     /** Visitor method: Validate a list of type expressions.
1373      */
1374     void validate(List&lt;? extends JCTree&gt; trees, Env&lt;AttrContext&gt; env) {
1375         for (List&lt;? extends JCTree&gt; l = trees; l.nonEmpty(); l = l.tail)
1376             validate(l.head, env);
1377     }
1378 
1379     /** A visitor class for type validation.
1380      */
1381     class Validator extends JCTree.Visitor {
1382 
1383         boolean checkRaw;
1384         boolean isOuter;
1385         Env&lt;AttrContext&gt; env;
1386 
1387         Validator(Env&lt;AttrContext&gt; env) {
1388             this.env = env;
1389         }
1390 
1391         @Override
1392         public void visitTypeArray(JCArrayTypeTree tree) {
1393             validateTree(tree.elemtype, checkRaw, isOuter);
1394         }
1395 
1396         @Override
1397         public void visitTypeApply(JCTypeApply tree) {
1398             if (tree.type.hasTag(CLASS)) {
1399                 List&lt;JCExpression&gt; args = tree.arguments;
1400                 List&lt;Type&gt; forms = tree.type.tsym.type.getTypeArguments();
1401 
1402                 Type incompatibleArg = firstIncompatibleTypeArg(tree.type);
1403                 if (incompatibleArg != null) {
1404                     for (JCTree arg : tree.arguments) {
1405                         if (arg.type == incompatibleArg) {
1406                             log.error(arg, Errors.NotWithinBounds(incompatibleArg, forms.head));
1407                         }
1408                         forms = forms.tail;
1409                      }
1410                  }
1411 
1412                 forms = tree.type.tsym.type.getTypeArguments();
1413 
1414                 boolean is_java_lang_Class = tree.type.tsym.flatName() == names.java_lang_Class;
1415 
1416                 // For matching pairs of actual argument types `a&#39; and
1417                 // formal type parameters with declared bound `b&#39; ...
1418                 while (args.nonEmpty() &amp;&amp; forms.nonEmpty()) {
1419                     validateTree(args.head,
1420                             !(isOuter &amp;&amp; is_java_lang_Class),
1421                             false);
1422                     args = args.tail;
1423                     forms = forms.tail;
1424                 }
1425 
1426                 // Check that this type is either fully parameterized, or
1427                 // not parameterized at all.
1428                 if (tree.type.getEnclosingType().isRaw())
1429                     log.error(tree.pos(), Errors.ImproperlyFormedTypeInnerRawParam);
1430                 if (tree.clazz.hasTag(SELECT))
1431                     visitSelectInternal((JCFieldAccess)tree.clazz);
1432             }
1433         }
1434 
1435         @Override
1436         public void visitTypeParameter(JCTypeParameter tree) {
1437             validateTrees(tree.bounds, true, isOuter);
1438             checkClassBounds(tree.pos(), tree.type);
1439         }
1440 
1441         @Override
1442         public void visitWildcard(JCWildcard tree) {
1443             if (tree.inner != null)
1444                 validateTree(tree.inner, true, isOuter);
1445         }
1446 
1447         @Override
1448         public void visitSelect(JCFieldAccess tree) {
1449             if (tree.type.hasTag(CLASS)) {
1450                 visitSelectInternal(tree);
1451 
1452                 // Check that this type is either fully parameterized, or
1453                 // not parameterized at all.
1454                 if (tree.selected.type.isParameterized() &amp;&amp; tree.type.tsym.type.getTypeArguments().nonEmpty())
1455                     log.error(tree.pos(), Errors.ImproperlyFormedTypeParamMissing);
1456             }
1457         }
1458 
1459         public void visitSelectInternal(JCFieldAccess tree) {
1460             if (tree.type.tsym.isStatic() &amp;&amp;
1461                 tree.selected.type.isParameterized()) {
1462                 // The enclosing type is not a class, so we are
1463                 // looking at a static member type.  However, the
1464                 // qualifying expression is parameterized.
1465                 log.error(tree.pos(), Errors.CantSelectStaticClassFromParamType);
1466             } else {
1467                 // otherwise validate the rest of the expression
1468                 tree.selected.accept(this);
1469             }
1470         }
1471 
1472         @Override
1473         public void visitAnnotatedType(JCAnnotatedType tree) {
1474             tree.underlyingType.accept(this);
1475         }
1476 
1477         @Override
1478         public void visitTypeIdent(JCPrimitiveTypeTree that) {
1479             if (that.type.hasTag(TypeTag.VOID)) {
1480                 log.error(that.pos(), Errors.VoidNotAllowedHere);
1481             }
1482             super.visitTypeIdent(that);
1483         }
1484 
1485         /** Default visitor method: do nothing.
1486          */
1487         @Override
1488         public void visitTree(JCTree tree) {
1489         }
1490 
1491         public void validateTree(JCTree tree, boolean checkRaw, boolean isOuter) {
1492             if (tree != null) {
1493                 boolean prevCheckRaw = this.checkRaw;
1494                 this.checkRaw = checkRaw;
1495                 this.isOuter = isOuter;
1496 
1497                 try {
1498                     tree.accept(this);
1499                     if (checkRaw)
1500                         checkRaw(tree, env);
1501                 } catch (CompletionFailure ex) {
1502                     completionError(tree.pos(), ex);
1503                 } finally {
1504                     this.checkRaw = prevCheckRaw;
1505                 }
1506             }
1507         }
1508 
1509         public void validateTrees(List&lt;? extends JCTree&gt; trees, boolean checkRaw, boolean isOuter) {
1510             for (List&lt;? extends JCTree&gt; l = trees; l.nonEmpty(); l = l.tail)
1511                 validateTree(l.head, checkRaw, isOuter);
1512         }
1513     }
1514 
1515     void checkRaw(JCTree tree, Env&lt;AttrContext&gt; env) {
1516         if (lint.isEnabled(LintCategory.RAW) &amp;&amp;
1517             tree.type.hasTag(CLASS) &amp;&amp;
1518             !TreeInfo.isDiamond(tree) &amp;&amp;
1519             !withinAnonConstr(env) &amp;&amp;
1520             tree.type.isRaw()) {
1521             log.warning(LintCategory.RAW,
1522                     tree.pos(), Warnings.RawClassUse(tree.type, tree.type.tsym.type));
1523         }
1524     }
1525     //where
1526         private boolean withinAnonConstr(Env&lt;AttrContext&gt; env) {
1527             return env.enclClass.name.isEmpty() &amp;&amp;
1528                     env.enclMethod != null &amp;&amp; env.enclMethod.name == names.init;
1529         }
1530 
1531 /* *************************************************************************
1532  * Exception checking
1533  **************************************************************************/
1534 
1535     /* The following methods treat classes as sets that contain
1536      * the class itself and all their subclasses
1537      */
1538 
1539     /** Is given type a subtype of some of the types in given list?
1540      */
1541     boolean subset(Type t, List&lt;Type&gt; ts) {
1542         for (List&lt;Type&gt; l = ts; l.nonEmpty(); l = l.tail)
1543             if (types.isSubtype(t, l.head)) return true;
1544         return false;
1545     }
1546 
1547     /** Is given type a subtype or supertype of
1548      *  some of the types in given list?
1549      */
1550     boolean intersects(Type t, List&lt;Type&gt; ts) {
1551         for (List&lt;Type&gt; l = ts; l.nonEmpty(); l = l.tail)
1552             if (types.isSubtype(t, l.head) || types.isSubtype(l.head, t)) return true;
1553         return false;
1554     }
1555 
1556     /** Add type set to given type list, unless it is a subclass of some class
1557      *  in the list.
1558      */
1559     List&lt;Type&gt; incl(Type t, List&lt;Type&gt; ts) {
1560         return subset(t, ts) ? ts : excl(t, ts).prepend(t);
1561     }
1562 
1563     /** Remove type set from type set list.
1564      */
1565     List&lt;Type&gt; excl(Type t, List&lt;Type&gt; ts) {
1566         if (ts.isEmpty()) {
1567             return ts;
1568         } else {
1569             List&lt;Type&gt; ts1 = excl(t, ts.tail);
1570             if (types.isSubtype(ts.head, t)) return ts1;
1571             else if (ts1 == ts.tail) return ts;
1572             else return ts1.prepend(ts.head);
1573         }
1574     }
1575 
1576     /** Form the union of two type set lists.
1577      */
1578     List&lt;Type&gt; union(List&lt;Type&gt; ts1, List&lt;Type&gt; ts2) {
1579         List&lt;Type&gt; ts = ts1;
1580         for (List&lt;Type&gt; l = ts2; l.nonEmpty(); l = l.tail)
1581             ts = incl(l.head, ts);
1582         return ts;
1583     }
1584 
1585     /** Form the difference of two type lists.
1586      */
1587     List&lt;Type&gt; diff(List&lt;Type&gt; ts1, List&lt;Type&gt; ts2) {
1588         List&lt;Type&gt; ts = ts1;
1589         for (List&lt;Type&gt; l = ts2; l.nonEmpty(); l = l.tail)
1590             ts = excl(l.head, ts);
1591         return ts;
1592     }
1593 
1594     /** Form the intersection of two type lists.
1595      */
1596     public List&lt;Type&gt; intersect(List&lt;Type&gt; ts1, List&lt;Type&gt; ts2) {
1597         List&lt;Type&gt; ts = List.nil();
1598         for (List&lt;Type&gt; l = ts1; l.nonEmpty(); l = l.tail)
1599             if (subset(l.head, ts2)) ts = incl(l.head, ts);
1600         for (List&lt;Type&gt; l = ts2; l.nonEmpty(); l = l.tail)
1601             if (subset(l.head, ts1)) ts = incl(l.head, ts);
1602         return ts;
1603     }
1604 
1605     /** Is exc an exception symbol that need not be declared?
1606      */
1607     boolean isUnchecked(ClassSymbol exc) {
1608         return
1609             exc.kind == ERR ||
1610             exc.isSubClass(syms.errorType.tsym, types) ||
1611             exc.isSubClass(syms.runtimeExceptionType.tsym, types);
1612     }
1613 
1614     /** Is exc an exception type that need not be declared?
1615      */
1616     boolean isUnchecked(Type exc) {
1617         return
1618             (exc.hasTag(TYPEVAR)) ? isUnchecked(types.supertype(exc)) :
1619             (exc.hasTag(CLASS)) ? isUnchecked((ClassSymbol)exc.tsym) :
1620             exc.hasTag(BOT);
1621     }
1622 
1623     boolean isChecked(Type exc) {
1624         return !isUnchecked(exc);
1625     }
1626 
1627     /** Same, but handling completion failures.
1628      */
1629     boolean isUnchecked(DiagnosticPosition pos, Type exc) {
1630         try {
1631             return isUnchecked(exc);
1632         } catch (CompletionFailure ex) {
1633             completionError(pos, ex);
1634             return true;
1635         }
1636     }
1637 
1638     /** Is exc handled by given exception list?
1639      */
1640     boolean isHandled(Type exc, List&lt;Type&gt; handled) {
1641         return isUnchecked(exc) || subset(exc, handled);
1642     }
1643 
1644     /** Return all exceptions in thrown list that are not in handled list.
1645      *  @param thrown     The list of thrown exceptions.
1646      *  @param handled    The list of handled exceptions.
1647      */
1648     List&lt;Type&gt; unhandled(List&lt;Type&gt; thrown, List&lt;Type&gt; handled) {
1649         List&lt;Type&gt; unhandled = List.nil();
1650         for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail)
1651             if (!isHandled(l.head, handled)) unhandled = unhandled.prepend(l.head);
1652         return unhandled;
1653     }
1654 
1655 /* *************************************************************************
1656  * Overriding/Implementation checking
1657  **************************************************************************/
1658 
1659     /** The level of access protection given by a flag set,
1660      *  where PRIVATE is highest and PUBLIC is lowest.
1661      */
1662     static int protection(long flags) {
1663         switch ((short)(flags &amp; AccessFlags)) {
1664         case PRIVATE: return 3;
1665         case PROTECTED: return 1;
1666         default:
1667         case PUBLIC: return 0;
1668         case 0: return 2;
1669         }
1670     }
1671 
1672     /** A customized &quot;cannot override&quot; error message.
1673      *  @param m      The overriding method.
1674      *  @param other  The overridden method.
1675      *  @return       An internationalized string.
1676      */
1677     Fragment cannotOverride(MethodSymbol m, MethodSymbol other) {
1678         Symbol mloc = m.location();
1679         Symbol oloc = other.location();
1680 
1681         if ((other.owner.flags() &amp; INTERFACE) == 0)
1682             return Fragments.CantOverride(m, mloc, other, oloc);
1683         else if ((m.owner.flags() &amp; INTERFACE) == 0)
1684             return Fragments.CantImplement(m, mloc, other, oloc);
1685         else
1686             return Fragments.ClashesWith(m, mloc, other, oloc);
1687     }
1688 
1689     /** A customized &quot;override&quot; warning message.
1690      *  @param m      The overriding method.
1691      *  @param other  The overridden method.
1692      *  @return       An internationalized string.
1693      */
1694     Fragment uncheckedOverrides(MethodSymbol m, MethodSymbol other) {
1695         Symbol mloc = m.location();
1696         Symbol oloc = other.location();
1697 
1698         if ((other.owner.flags() &amp; INTERFACE) == 0)
1699             return Fragments.UncheckedOverride(m, mloc, other, oloc);
1700         else if ((m.owner.flags() &amp; INTERFACE) == 0)
1701             return Fragments.UncheckedImplement(m, mloc, other, oloc);
1702         else
1703             return Fragments.UncheckedClashWith(m, mloc, other, oloc);
1704     }
1705 
1706     /** A customized &quot;override&quot; warning message.
1707      *  @param m      The overriding method.
1708      *  @param other  The overridden method.
1709      *  @return       An internationalized string.
1710      */
1711     Fragment varargsOverrides(MethodSymbol m, MethodSymbol other) {
1712         Symbol mloc = m.location();
1713         Symbol oloc = other.location();
1714 
1715         if ((other.owner.flags() &amp; INTERFACE) == 0)
1716             return Fragments.VarargsOverride(m, mloc, other, oloc);
1717         else  if ((m.owner.flags() &amp; INTERFACE) == 0)
1718             return Fragments.VarargsImplement(m, mloc, other, oloc);
1719         else
1720             return Fragments.VarargsClashWith(m, mloc, other, oloc);
1721     }
1722 
1723     /** Check that this method conforms with overridden method &#39;other&#39;.
1724      *  where `origin&#39; is the class where checking started.
1725      *  Complications:
1726      *  (1) Do not check overriding of synthetic methods
1727      *      (reason: they might be final).
1728      *      todo: check whether this is still necessary.
1729      *  (2) Admit the case where an interface proxy throws fewer exceptions
1730      *      than the method it implements. Augment the proxy methods with the
1731      *      undeclared exceptions in this case.
1732      *  (3) When generics are enabled, admit the case where an interface proxy
1733      *      has a result type
1734      *      extended by the result type of the method it implements.
1735      *      Change the proxies result type to the smaller type in this case.
1736      *
1737      *  @param tree         The tree from which positions
1738      *                      are extracted for errors.
1739      *  @param m            The overriding method.
1740      *  @param other        The overridden method.
1741      *  @param origin       The class of which the overriding method
1742      *                      is a member.
1743      */
1744     void checkOverride(JCTree tree,
1745                        MethodSymbol m,
1746                        MethodSymbol other,
1747                        ClassSymbol origin) {
1748         // Don&#39;t check overriding of synthetic methods or by bridge methods.
1749         if ((m.flags() &amp; (SYNTHETIC|BRIDGE)) != 0 || (other.flags() &amp; SYNTHETIC) != 0) {
1750             return;
1751         }
1752 
1753         // Error if static method overrides instance method (JLS 8.4.6.2).
1754         if ((m.flags() &amp; STATIC) != 0 &amp;&amp;
1755                    (other.flags() &amp; STATIC) == 0) {
1756             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1757                       Errors.OverrideStatic(cannotOverride(m, other)));
1758             m.flags_field |= BAD_OVERRIDE;
1759             return;
1760         }
1761 
1762         // Error if instance method overrides static or final
1763         // method (JLS 8.4.6.1).
1764         if ((other.flags() &amp; FINAL) != 0 ||
1765                  (m.flags() &amp; STATIC) == 0 &amp;&amp;
1766                  (other.flags() &amp; STATIC) != 0) {
1767             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1768                       Errors.OverrideMeth(cannotOverride(m, other),
1769                                           asFlagSet(other.flags() &amp; (FINAL | STATIC))));
1770             m.flags_field |= BAD_OVERRIDE;
1771             return;
1772         }
1773 
1774         if ((m.owner.flags() &amp; ANNOTATION) != 0) {
1775             // handled in validateAnnotationMethod
1776             return;
1777         }
1778 
1779         // Error if overriding method has weaker access (JLS 8.4.6.3).
1780         if (protection(m.flags()) &gt; protection(other.flags())) {
1781             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1782                       (other.flags() &amp; AccessFlags) == 0 ?
1783                               Errors.OverrideWeakerAccess(cannotOverride(m, other),
1784                                                           &quot;package&quot;) :
1785                               Errors.OverrideWeakerAccess(cannotOverride(m, other),
1786                                                           asFlagSet(other.flags() &amp; AccessFlags)));
1787             m.flags_field |= BAD_OVERRIDE;
1788             return;
1789         }
1790 
1791         Type mt = types.memberType(origin.type, m);
1792         Type ot = types.memberType(origin.type, other);
1793         // Error if overriding result type is different
1794         // (or, in the case of generics mode, not a subtype) of
1795         // overridden result type. We have to rename any type parameters
1796         // before comparing types.
1797         List&lt;Type&gt; mtvars = mt.getTypeArguments();
1798         List&lt;Type&gt; otvars = ot.getTypeArguments();
1799         Type mtres = mt.getReturnType();
1800         Type otres = types.subst(ot.getReturnType(), otvars, mtvars);
1801 
1802         overrideWarner.clear();
1803         boolean resultTypesOK =
1804             types.returnTypeSubstitutable(mt, ot, otres, overrideWarner);
1805         if (!resultTypesOK) {
1806             if ((m.flags() &amp; STATIC) != 0 &amp;&amp; (other.flags() &amp; STATIC) != 0) {
1807                 log.error(TreeInfo.diagnosticPositionFor(m, tree),
1808                           Errors.OverrideIncompatibleRet(Fragments.CantHide(m, m.location(), other,
1809                                         other.location()), mtres, otres));
1810                 m.flags_field |= BAD_OVERRIDE;
1811             } else {
1812                 log.error(TreeInfo.diagnosticPositionFor(m, tree),
1813                           Errors.OverrideIncompatibleRet(cannotOverride(m, other), mtres, otres));
1814                 m.flags_field |= BAD_OVERRIDE;
1815             }
1816             return;
1817         } else if (overrideWarner.hasNonSilentLint(LintCategory.UNCHECKED)) {
1818             warnUnchecked(TreeInfo.diagnosticPositionFor(m, tree),
1819                     Warnings.OverrideUncheckedRet(uncheckedOverrides(m, other), mtres, otres));
1820         }
1821 
1822         // Error if overriding method throws an exception not reported
1823         // by overridden method.
1824         List&lt;Type&gt; otthrown = types.subst(ot.getThrownTypes(), otvars, mtvars);
1825         List&lt;Type&gt; unhandledErased = unhandled(mt.getThrownTypes(), types.erasure(otthrown));
1826         List&lt;Type&gt; unhandledUnerased = unhandled(mt.getThrownTypes(), otthrown);
1827         if (unhandledErased.nonEmpty()) {
1828             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1829                       Errors.OverrideMethDoesntThrow(cannotOverride(m, other), unhandledUnerased.head));
1830             m.flags_field |= BAD_OVERRIDE;
1831             return;
1832         }
1833         else if (unhandledUnerased.nonEmpty()) {
1834             warnUnchecked(TreeInfo.diagnosticPositionFor(m, tree),
1835                           Warnings.OverrideUncheckedThrown(cannotOverride(m, other), unhandledUnerased.head));
1836             return;
1837         }
1838 
1839         // Optional warning if varargs don&#39;t agree
1840         if ((((m.flags() ^ other.flags()) &amp; Flags.VARARGS) != 0)
1841             &amp;&amp; lint.isEnabled(LintCategory.OVERRIDES)) {
1842             log.warning(TreeInfo.diagnosticPositionFor(m, tree),
1843                         ((m.flags() &amp; Flags.VARARGS) != 0)
1844                         ? Warnings.OverrideVarargsMissing(varargsOverrides(m, other))
1845                         : Warnings.OverrideVarargsExtra(varargsOverrides(m, other)));
1846         }
1847 
1848         // Warn if instance method overrides bridge method (compiler spec ??)
1849         if ((other.flags() &amp; BRIDGE) != 0) {
1850             log.warning(TreeInfo.diagnosticPositionFor(m, tree),
1851                         Warnings.OverrideBridge(uncheckedOverrides(m, other)));
1852         }
1853 
1854         // Warn if a deprecated method overridden by a non-deprecated one.
1855         if (!isDeprecatedOverrideIgnorable(other, origin)) {
1856             Lint prevLint = setLint(lint.augment(m));
1857             try {
1858                 checkDeprecated(() -&gt; TreeInfo.diagnosticPositionFor(m, tree), m, other);
1859             } finally {
1860                 setLint(prevLint);
1861             }
1862         }
1863     }
1864     // where
1865         private boolean isDeprecatedOverrideIgnorable(MethodSymbol m, ClassSymbol origin) {
1866             // If the method, m, is defined in an interface, then ignore the issue if the method
1867             // is only inherited via a supertype and also implemented in the supertype,
1868             // because in that case, we will rediscover the issue when examining the method
1869             // in the supertype.
1870             // If the method, m, is not defined in an interface, then the only time we need to
1871             // address the issue is when the method is the supertype implementation: any other
1872             // case, we will have dealt with when examining the supertype classes
1873             ClassSymbol mc = m.enclClass();
1874             Type st = types.supertype(origin.type);
1875             if (!st.hasTag(CLASS))
1876                 return true;
1877             MethodSymbol stimpl = m.implementation((ClassSymbol)st.tsym, types, false);
1878 
1879             if (mc != null &amp;&amp; ((mc.flags() &amp; INTERFACE) != 0)) {
1880                 List&lt;Type&gt; intfs = types.interfaces(origin.type);
1881                 return (intfs.contains(mc.type) ? false : (stimpl != null));
1882             }
1883             else
1884                 return (stimpl != m);
1885         }
1886 
1887 
1888     // used to check if there were any unchecked conversions
1889     Warner overrideWarner = new Warner();
1890 
1891     /** Check that a class does not inherit two concrete methods
1892      *  with the same signature.
1893      *  @param pos          Position to be used for error reporting.
1894      *  @param site         The class type to be checked.
1895      */
1896     public void checkCompatibleConcretes(DiagnosticPosition pos, Type site) {
1897         Type sup = types.supertype(site);
1898         if (!sup.hasTag(CLASS)) return;
1899 
1900         for (Type t1 = sup;
1901              t1.hasTag(CLASS) &amp;&amp; t1.tsym.type.isParameterized();
1902              t1 = types.supertype(t1)) {
1903             for (Symbol s1 : t1.tsym.members().getSymbols(NON_RECURSIVE)) {
1904                 if (s1.kind != MTH ||
1905                     (s1.flags() &amp; (STATIC|SYNTHETIC|BRIDGE)) != 0 ||
1906                     !s1.isInheritedIn(site.tsym, types) ||
1907                     ((MethodSymbol)s1).implementation(site.tsym,
1908                                                       types,
1909                                                       true) != s1)
1910                     continue;
1911                 Type st1 = types.memberType(t1, s1);
1912                 int s1ArgsLength = st1.getParameterTypes().length();
1913                 if (st1 == s1.type) continue;
1914 
1915                 for (Type t2 = sup;
1916                      t2.hasTag(CLASS);
1917                      t2 = types.supertype(t2)) {
1918                     for (Symbol s2 : t2.tsym.members().getSymbolsByName(s1.name)) {
1919                         if (s2 == s1 ||
1920                             s2.kind != MTH ||
1921                             (s2.flags() &amp; (STATIC|SYNTHETIC|BRIDGE)) != 0 ||
1922                             s2.type.getParameterTypes().length() != s1ArgsLength ||
1923                             !s2.isInheritedIn(site.tsym, types) ||
1924                             ((MethodSymbol)s2).implementation(site.tsym,
1925                                                               types,
1926                                                               true) != s2)
1927                             continue;
1928                         Type st2 = types.memberType(t2, s2);
1929                         if (types.overrideEquivalent(st1, st2))
1930                             log.error(pos,
1931                                       Errors.ConcreteInheritanceConflict(s1, t1, s2, t2, sup));
1932                     }
1933                 }
1934             }
1935         }
1936     }
1937 
1938     /** Check that classes (or interfaces) do not each define an abstract
1939      *  method with same name and arguments but incompatible return types.
1940      *  @param pos          Position to be used for error reporting.
1941      *  @param t1           The first argument type.
1942      *  @param t2           The second argument type.
1943      */
1944     public boolean checkCompatibleAbstracts(DiagnosticPosition pos,
1945                                             Type t1,
1946                                             Type t2,
1947                                             Type site) {
1948         if ((site.tsym.flags() &amp; COMPOUND) != 0) {
1949             // special case for intersections: need to eliminate wildcards in supertypes
1950             t1 = types.capture(t1);
1951             t2 = types.capture(t2);
1952         }
1953         return firstIncompatibility(pos, t1, t2, site) == null;
1954     }
1955 
1956     /** Return the first method which is defined with same args
1957      *  but different return types in two given interfaces, or null if none
1958      *  exists.
1959      *  @param t1     The first type.
1960      *  @param t2     The second type.
1961      *  @param site   The most derived type.
1962      *  @return symbol from t2 that conflicts with one in t1.
1963      */
1964     private Symbol firstIncompatibility(DiagnosticPosition pos, Type t1, Type t2, Type site) {
1965         Map&lt;TypeSymbol,Type&gt; interfaces1 = new HashMap&lt;&gt;();
1966         closure(t1, interfaces1);
1967         Map&lt;TypeSymbol,Type&gt; interfaces2;
1968         if (t1 == t2)
1969             interfaces2 = interfaces1;
1970         else
1971             closure(t2, interfaces1, interfaces2 = new HashMap&lt;&gt;());
1972 
1973         for (Type t3 : interfaces1.values()) {
1974             for (Type t4 : interfaces2.values()) {
1975                 Symbol s = firstDirectIncompatibility(pos, t3, t4, site);
1976                 if (s != null) return s;
1977             }
1978         }
1979         return null;
1980     }
1981 
1982     /** Compute all the supertypes of t, indexed by type symbol. */
1983     private void closure(Type t, Map&lt;TypeSymbol,Type&gt; typeMap) {
1984         if (!t.hasTag(CLASS)) return;
1985         if (typeMap.put(t.tsym, t) == null) {
1986             closure(types.supertype(t), typeMap);
1987             for (Type i : types.interfaces(t))
1988                 closure(i, typeMap);
1989         }
1990     }
1991 
1992     /** Compute all the supertypes of t, indexed by type symbol (except those in typesSkip). */
1993     private void closure(Type t, Map&lt;TypeSymbol,Type&gt; typesSkip, Map&lt;TypeSymbol,Type&gt; typeMap) {
1994         if (!t.hasTag(CLASS)) return;
1995         if (typesSkip.get(t.tsym) != null) return;
1996         if (typeMap.put(t.tsym, t) == null) {
1997             closure(types.supertype(t), typesSkip, typeMap);
1998             for (Type i : types.interfaces(t))
1999                 closure(i, typesSkip, typeMap);
2000         }
2001     }
2002 
2003     /** Return the first method in t2 that conflicts with a method from t1. */
2004     private Symbol firstDirectIncompatibility(DiagnosticPosition pos, Type t1, Type t2, Type site) {
2005         for (Symbol s1 : t1.tsym.members().getSymbols(NON_RECURSIVE)) {
2006             Type st1 = null;
2007             if (s1.kind != MTH || !s1.isInheritedIn(site.tsym, types) ||
2008                     (s1.flags() &amp; SYNTHETIC) != 0) continue;
2009             Symbol impl = ((MethodSymbol)s1).implementation(site.tsym, types, false);
2010             if (impl != null &amp;&amp; (impl.flags() &amp; ABSTRACT) == 0) continue;
2011             for (Symbol s2 : t2.tsym.members().getSymbolsByName(s1.name)) {
2012                 if (s1 == s2) continue;
2013                 if (s2.kind != MTH || !s2.isInheritedIn(site.tsym, types) ||
2014                         (s2.flags() &amp; SYNTHETIC) != 0) continue;
2015                 if (st1 == null) st1 = types.memberType(t1, s1);
2016                 Type st2 = types.memberType(t2, s2);
2017                 if (types.overrideEquivalent(st1, st2)) {
2018                     List&lt;Type&gt; tvars1 = st1.getTypeArguments();
2019                     List&lt;Type&gt; tvars2 = st2.getTypeArguments();
2020                     Type rt1 = st1.getReturnType();
2021                     Type rt2 = types.subst(st2.getReturnType(), tvars2, tvars1);
2022                     boolean compat =
2023                         types.isSameType(rt1, rt2) ||
2024                         !rt1.isPrimitiveOrVoid() &amp;&amp;
2025                         !rt2.isPrimitiveOrVoid() &amp;&amp;
2026                         (types.covariantReturnType(rt1, rt2, types.noWarnings) ||
2027                          types.covariantReturnType(rt2, rt1, types.noWarnings)) ||
2028                          checkCommonOverriderIn(s1,s2,site);
2029                     if (!compat) {
2030                         log.error(pos, Errors.TypesIncompatible(t1, t2,
2031                                 Fragments.IncompatibleDiffRet(s2.name, types.memberType(t2, s2).getParameterTypes())));
2032                         return s2;
2033                     }
2034                 } else if (checkNameClash((ClassSymbol)site.tsym, s1, s2) &amp;&amp;
2035                         !checkCommonOverriderIn(s1, s2, site)) {
2036                     log.error(pos, Errors.NameClashSameErasureNoOverride(
2037                             s1.name, types.memberType(site, s1).asMethodType().getParameterTypes(), s1.location(),
2038                             s2.name, types.memberType(site, s2).asMethodType().getParameterTypes(), s2.location()));
2039                     return s2;
2040                 }
2041             }
2042         }
2043         return null;
2044     }
2045     //WHERE
2046     boolean checkCommonOverriderIn(Symbol s1, Symbol s2, Type site) {
2047         Map&lt;TypeSymbol,Type&gt; supertypes = new HashMap&lt;&gt;();
2048         Type st1 = types.memberType(site, s1);
2049         Type st2 = types.memberType(site, s2);
2050         closure(site, supertypes);
2051         for (Type t : supertypes.values()) {
2052             for (Symbol s3 : t.tsym.members().getSymbolsByName(s1.name)) {
2053                 if (s3 == s1 || s3 == s2 || s3.kind != MTH || (s3.flags() &amp; (BRIDGE|SYNTHETIC)) != 0) continue;
2054                 Type st3 = types.memberType(site,s3);
2055                 if (types.overrideEquivalent(st3, st1) &amp;&amp;
2056                         types.overrideEquivalent(st3, st2) &amp;&amp;
2057                         types.returnTypeSubstitutable(st3, st1) &amp;&amp;
2058                         types.returnTypeSubstitutable(st3, st2)) {
2059                     return true;
2060                 }
2061             }
2062         }
2063         return false;
2064     }
2065 
2066     /** Check that a given method conforms with any method it overrides.
2067      *  @param tree         The tree from which positions are extracted
2068      *                      for errors.
2069      *  @param m            The overriding method.
2070      */
2071     void checkOverride(Env&lt;AttrContext&gt; env, JCMethodDecl tree, MethodSymbol m) {
2072         ClassSymbol origin = (ClassSymbol)m.owner;
2073         if ((origin.flags() &amp; ENUM) != 0 &amp;&amp; names.finalize.equals(m.name))
2074             if (m.overrides(syms.enumFinalFinalize, origin, types, false)) {
2075                 log.error(tree.pos(), Errors.EnumNoFinalize);
2076                 return;
2077             }
2078         for (Type t = origin.type; t.hasTag(CLASS);
2079              t = types.supertype(t)) {
2080             if (t != origin.type) {
2081                 checkOverride(tree, t, origin, m);
2082             }
2083             for (Type t2 : types.interfaces(t)) {
2084                 checkOverride(tree, t2, origin, m);
2085             }
2086         }
2087 
2088         final boolean explicitOverride = m.attribute(syms.overrideType.tsym) != null;
2089         // Check if this method must override a super method due to being annotated with @Override
2090         // or by virtue of being a member of a diamond inferred anonymous class. Latter case is to
2091         // be treated &quot;as if as they were annotated&quot; with @Override.
2092         boolean mustOverride = explicitOverride ||
2093                 (env.info.isAnonymousDiamond &amp;&amp; !m.isConstructor() &amp;&amp; !m.isPrivate());
2094         if (mustOverride &amp;&amp; !isOverrider(m)) {
2095             DiagnosticPosition pos = tree.pos();
2096             for (JCAnnotation a : tree.getModifiers().annotations) {
2097                 if (a.annotationType.type.tsym == syms.overrideType.tsym) {
2098                     pos = a.pos();
2099                     break;
2100                 }
2101             }
2102             log.error(pos,
2103                       explicitOverride ? (m.isStatic() ? Errors.StaticMethodsCannotBeAnnotatedWithOverride : Errors.MethodDoesNotOverrideSuperclass) :
2104                                 Errors.AnonymousDiamondMethodDoesNotOverrideSuperclass(Fragments.DiamondAnonymousMethodsImplicitlyOverride));
2105         }
2106     }
2107 
2108     void checkOverride(JCTree tree, Type site, ClassSymbol origin, MethodSymbol m) {
2109         TypeSymbol c = site.tsym;
2110         for (Symbol sym : c.members().getSymbolsByName(m.name)) {
2111             if (m.overrides(sym, origin, types, false)) {
2112                 if ((sym.flags() &amp; ABSTRACT) == 0) {
2113                     checkOverride(tree, m, (MethodSymbol)sym, origin);
2114                 }
2115             }
2116         }
2117     }
2118 
2119     private Filter&lt;Symbol&gt; equalsHasCodeFilter = s -&gt; MethodSymbol.implementation_filter.accepts(s) &amp;&amp;
2120             (s.flags() &amp; BAD_OVERRIDE) == 0;
2121 
2122     public void checkClassOverrideEqualsAndHashIfNeeded(DiagnosticPosition pos,
2123             ClassSymbol someClass) {
2124         /* At present, annotations cannot possibly have a method that is override
2125          * equivalent with Object.equals(Object) but in any case the condition is
2126          * fine for completeness.
2127          */
2128         if (someClass == (ClassSymbol)syms.objectType.tsym ||
2129             someClass.isInterface() || someClass.isEnum() ||
2130             (someClass.flags() &amp; ANNOTATION) != 0 ||
2131             (someClass.flags() &amp; ABSTRACT) != 0) return;
2132         //anonymous inner classes implementing interfaces need especial treatment
2133         if (someClass.isAnonymous()) {
2134             List&lt;Type&gt; interfaces =  types.interfaces(someClass.type);
2135             if (interfaces != null &amp;&amp; !interfaces.isEmpty() &amp;&amp;
2136                 interfaces.head.tsym == syms.comparatorType.tsym) return;
2137         }
2138         checkClassOverrideEqualsAndHash(pos, someClass);
2139     }
2140 
2141     private void checkClassOverrideEqualsAndHash(DiagnosticPosition pos,
2142             ClassSymbol someClass) {
2143         if (lint.isEnabled(LintCategory.OVERRIDES)) {
2144             MethodSymbol equalsAtObject = (MethodSymbol)syms.objectType
2145                     .tsym.members().findFirst(names.equals);
2146             MethodSymbol hashCodeAtObject = (MethodSymbol)syms.objectType
2147                     .tsym.members().findFirst(names.hashCode);
2148             boolean overridesEquals = types.implementation(equalsAtObject,
2149                 someClass, false, equalsHasCodeFilter).owner == someClass;
2150             boolean overridesHashCode = types.implementation(hashCodeAtObject,
2151                 someClass, false, equalsHasCodeFilter) != hashCodeAtObject;
2152 
2153             if (overridesEquals &amp;&amp; !overridesHashCode) {
2154                 log.warning(LintCategory.OVERRIDES, pos,
2155                             Warnings.OverrideEqualsButNotHashcode(someClass));
2156             }
2157         }
2158     }
2159 
2160     public void checkModuleName (JCModuleDecl tree) {
2161         Name moduleName = tree.sym.name;
2162         Assert.checkNonNull(moduleName);
2163         if (lint.isEnabled(LintCategory.MODULE)) {
2164             JCExpression qualId = tree.qualId;
2165             while (qualId != null) {
2166                 Name componentName;
2167                 DiagnosticPosition pos;
2168                 switch (qualId.getTag()) {
2169                     case SELECT:
2170                         JCFieldAccess selectNode = ((JCFieldAccess) qualId);
2171                         componentName = selectNode.name;
2172                         pos = selectNode.pos();
2173                         qualId = selectNode.selected;
2174                         break;
2175                     case IDENT:
2176                         componentName = ((JCIdent) qualId).name;
2177                         pos = qualId.pos();
2178                         qualId = null;
2179                         break;
2180                     default:
2181                         throw new AssertionError(&quot;Unexpected qualified identifier: &quot; + qualId.toString());
2182                 }
2183                 if (componentName != null) {
2184                     String moduleNameComponentString = componentName.toString();
2185                     int nameLength = moduleNameComponentString.length();
2186                     if (nameLength &gt; 0 &amp;&amp; Character.isDigit(moduleNameComponentString.charAt(nameLength - 1))) {
2187                         log.warning(Lint.LintCategory.MODULE, pos, Warnings.PoorChoiceForModuleName(componentName));
2188                     }
2189                 }
2190             }
2191         }
2192     }
2193 
2194     private boolean checkNameClash(ClassSymbol origin, Symbol s1, Symbol s2) {
2195         ClashFilter cf = new ClashFilter(origin.type);
2196         return (cf.accepts(s1) &amp;&amp;
2197                 cf.accepts(s2) &amp;&amp;
2198                 types.hasSameArgs(s1.erasure(types), s2.erasure(types)));
2199     }
2200 
2201 
2202     /** Check that all abstract members of given class have definitions.
2203      *  @param pos          Position to be used for error reporting.
2204      *  @param c            The class.
2205      */
2206     void checkAllDefined(DiagnosticPosition pos, ClassSymbol c) {
2207         MethodSymbol undef = types.firstUnimplementedAbstract(c);
2208         if (undef != null) {
2209             MethodSymbol undef1 =
2210                 new MethodSymbol(undef.flags(), undef.name,
2211                                  types.memberType(c.type, undef), undef.owner);
2212             log.error(pos,
2213                       Errors.DoesNotOverrideAbstract(c, undef1, undef1.location()));
2214         }
2215     }
2216 
2217     void checkNonCyclicDecl(JCClassDecl tree) {
2218         CycleChecker cc = new CycleChecker();
2219         cc.scan(tree);
2220         if (!cc.errorFound &amp;&amp; !cc.partialCheck) {
2221             tree.sym.flags_field |= ACYCLIC;
2222         }
2223     }
2224 
2225     class CycleChecker extends TreeScanner {
2226 
2227         List&lt;Symbol&gt; seenClasses = List.nil();
2228         boolean errorFound = false;
2229         boolean partialCheck = false;
2230 
2231         private void checkSymbol(DiagnosticPosition pos, Symbol sym) {
2232             if (sym != null &amp;&amp; sym.kind == TYP) {
2233                 Env&lt;AttrContext&gt; classEnv = enter.getEnv((TypeSymbol)sym);
2234                 if (classEnv != null) {
2235                     DiagnosticSource prevSource = log.currentSource();
2236                     try {
2237                         log.useSource(classEnv.toplevel.sourcefile);
2238                         scan(classEnv.tree);
2239                     }
2240                     finally {
2241                         log.useSource(prevSource.getFile());
2242                     }
2243                 } else if (sym.kind == TYP) {
2244                     checkClass(pos, sym, List.nil());
2245                 }
2246             } else {
2247                 //not completed yet
2248                 partialCheck = true;
2249             }
2250         }
2251 
2252         @Override
2253         public void visitSelect(JCFieldAccess tree) {
2254             super.visitSelect(tree);
2255             checkSymbol(tree.pos(), tree.sym);
2256         }
2257 
2258         @Override
2259         public void visitIdent(JCIdent tree) {
2260             checkSymbol(tree.pos(), tree.sym);
2261         }
2262 
2263         @Override
2264         public void visitTypeApply(JCTypeApply tree) {
2265             scan(tree.clazz);
2266         }
2267 
2268         @Override
2269         public void visitTypeArray(JCArrayTypeTree tree) {
2270             scan(tree.elemtype);
2271         }
2272 
2273         @Override
2274         public void visitClassDef(JCClassDecl tree) {
2275             List&lt;JCTree&gt; supertypes = List.nil();
2276             if (tree.getExtendsClause() != null) {
2277                 supertypes = supertypes.prepend(tree.getExtendsClause());
2278             }
2279             if (tree.getImplementsClause() != null) {
2280                 for (JCTree intf : tree.getImplementsClause()) {
2281                     supertypes = supertypes.prepend(intf);
2282                 }
2283             }
2284             checkClass(tree.pos(), tree.sym, supertypes);
2285         }
2286 
2287         void checkClass(DiagnosticPosition pos, Symbol c, List&lt;JCTree&gt; supertypes) {
2288             if ((c.flags_field &amp; ACYCLIC) != 0)
2289                 return;
2290             if (seenClasses.contains(c)) {
2291                 errorFound = true;
2292                 noteCyclic(pos, (ClassSymbol)c);
2293             } else if (!c.type.isErroneous()) {
2294                 try {
2295                     seenClasses = seenClasses.prepend(c);
2296                     if (c.type.hasTag(CLASS)) {
2297                         if (supertypes.nonEmpty()) {
2298                             scan(supertypes);
2299                         }
2300                         else {
2301                             ClassType ct = (ClassType)c.type;
2302                             if (ct.supertype_field == null ||
2303                                     ct.interfaces_field == null) {
2304                                 //not completed yet
2305                                 partialCheck = true;
2306                                 return;
2307                             }
2308                             checkSymbol(pos, ct.supertype_field.tsym);
2309                             for (Type intf : ct.interfaces_field) {
2310                                 checkSymbol(pos, intf.tsym);
2311                             }
2312                         }
2313                         if (c.owner.kind == TYP) {
2314                             checkSymbol(pos, c.owner);
2315                         }
2316                     }
2317                 } finally {
2318                     seenClasses = seenClasses.tail;
2319                 }
2320             }
2321         }
2322     }
2323 
2324     /** Check for cyclic references. Issue an error if the
2325      *  symbol of the type referred to has a LOCKED flag set.
2326      *
2327      *  @param pos      Position to be used for error reporting.
2328      *  @param t        The type referred to.
2329      */
2330     void checkNonCyclic(DiagnosticPosition pos, Type t) {
2331         checkNonCyclicInternal(pos, t);
2332     }
2333 
2334 
2335     void checkNonCyclic(DiagnosticPosition pos, TypeVar t) {
2336         checkNonCyclic1(pos, t, List.nil());
2337     }
2338 
2339     private void checkNonCyclic1(DiagnosticPosition pos, Type t, List&lt;TypeVar&gt; seen) {
2340         final TypeVar tv;
2341         if  (t.hasTag(TYPEVAR) &amp;&amp; (t.tsym.flags() &amp; UNATTRIBUTED) != 0)
2342             return;
2343         if (seen.contains(t)) {
2344             tv = (TypeVar)t;
2345             tv.setUpperBound(types.createErrorType(t));
2346             log.error(pos, Errors.CyclicInheritance(t));
2347         } else if (t.hasTag(TYPEVAR)) {
2348             tv = (TypeVar)t;
2349             seen = seen.prepend(tv);
2350             for (Type b : types.getBounds(tv))
2351                 checkNonCyclic1(pos, b, seen);
2352         }
2353     }
2354 
2355     /** Check for cyclic references. Issue an error if the
2356      *  symbol of the type referred to has a LOCKED flag set.
2357      *
2358      *  @param pos      Position to be used for error reporting.
2359      *  @param t        The type referred to.
2360      *  @returns        True if the check completed on all attributed classes
2361      */
2362     private boolean checkNonCyclicInternal(DiagnosticPosition pos, Type t) {
2363         boolean complete = true; // was the check complete?
2364         //- System.err.println(&quot;checkNonCyclicInternal(&quot;+t+&quot;);&quot;);//DEBUG
2365         Symbol c = t.tsym;
2366         if ((c.flags_field &amp; ACYCLIC) != 0) return true;
2367 
2368         if ((c.flags_field &amp; LOCKED) != 0) {
2369             noteCyclic(pos, (ClassSymbol)c);
2370         } else if (!c.type.isErroneous()) {
2371             try {
2372                 c.flags_field |= LOCKED;
2373                 if (c.type.hasTag(CLASS)) {
2374                     ClassType clazz = (ClassType)c.type;
2375                     if (clazz.interfaces_field != null)
2376                         for (List&lt;Type&gt; l=clazz.interfaces_field; l.nonEmpty(); l=l.tail)
2377                             complete &amp;= checkNonCyclicInternal(pos, l.head);
2378                     if (clazz.supertype_field != null) {
2379                         Type st = clazz.supertype_field;
2380                         if (st != null &amp;&amp; st.hasTag(CLASS))
2381                             complete &amp;= checkNonCyclicInternal(pos, st);
2382                     }
2383                     if (c.owner.kind == TYP)
2384                         complete &amp;= checkNonCyclicInternal(pos, c.owner.type);
2385                 }
2386             } finally {
2387                 c.flags_field &amp;= ~LOCKED;
2388             }
2389         }
2390         if (complete)
2391             complete = ((c.flags_field &amp; UNATTRIBUTED) == 0) &amp;&amp; c.isCompleted();
2392         if (complete) c.flags_field |= ACYCLIC;
2393         return complete;
2394     }
2395 
2396     /** Note that we found an inheritance cycle. */
2397     private void noteCyclic(DiagnosticPosition pos, ClassSymbol c) {
2398         log.error(pos, Errors.CyclicInheritance(c));
2399         for (List&lt;Type&gt; l=types.interfaces(c.type); l.nonEmpty(); l=l.tail)
2400             l.head = types.createErrorType((ClassSymbol)l.head.tsym, Type.noType);
2401         Type st = types.supertype(c.type);
2402         if (st.hasTag(CLASS))
2403             ((ClassType)c.type).supertype_field = types.createErrorType((ClassSymbol)st.tsym, Type.noType);
2404         c.type = types.createErrorType(c, c.type);
2405         c.flags_field |= ACYCLIC;
2406     }
2407 
2408     /** Check that all methods which implement some
2409      *  method conform to the method they implement.
2410      *  @param tree         The class definition whose members are checked.
2411      */
2412     void checkImplementations(JCClassDecl tree) {
2413         checkImplementations(tree, tree.sym, tree.sym);
2414     }
2415     //where
2416         /** Check that all methods which implement some
2417          *  method in `ic&#39; conform to the method they implement.
2418          */
2419         void checkImplementations(JCTree tree, ClassSymbol origin, ClassSymbol ic) {
2420             for (List&lt;Type&gt; l = types.closure(ic.type); l.nonEmpty(); l = l.tail) {
2421                 ClassSymbol lc = (ClassSymbol)l.head.tsym;
2422                 if ((lc.flags() &amp; ABSTRACT) != 0) {
2423                     for (Symbol sym : lc.members().getSymbols(NON_RECURSIVE)) {
2424                         if (sym.kind == MTH &amp;&amp;
2425                             (sym.flags() &amp; (STATIC|ABSTRACT)) == ABSTRACT) {
2426                             MethodSymbol absmeth = (MethodSymbol)sym;
2427                             MethodSymbol implmeth = absmeth.implementation(origin, types, false);
2428                             if (implmeth != null &amp;&amp; implmeth != absmeth &amp;&amp;
2429                                 (implmeth.owner.flags() &amp; INTERFACE) ==
2430                                 (origin.flags() &amp; INTERFACE)) {
2431                                 // don&#39;t check if implmeth is in a class, yet
2432                                 // origin is an interface. This case arises only
2433                                 // if implmeth is declared in Object. The reason is
2434                                 // that interfaces really don&#39;t inherit from
2435                                 // Object it&#39;s just that the compiler represents
2436                                 // things that way.
2437                                 checkOverride(tree, implmeth, absmeth, origin);
2438                             }
2439                         }
2440                     }
2441                 }
2442             }
2443         }
2444 
2445     /** Check that all abstract methods implemented by a class are
2446      *  mutually compatible.
2447      *  @param pos          Position to be used for error reporting.
2448      *  @param c            The class whose interfaces are checked.
2449      */
2450     void checkCompatibleSupertypes(DiagnosticPosition pos, Type c) {
2451         List&lt;Type&gt; supertypes = types.interfaces(c);
2452         Type supertype = types.supertype(c);
2453         if (supertype.hasTag(CLASS) &amp;&amp;
2454             (supertype.tsym.flags() &amp; ABSTRACT) != 0)
2455             supertypes = supertypes.prepend(supertype);
2456         for (List&lt;Type&gt; l = supertypes; l.nonEmpty(); l = l.tail) {
2457             if (!l.head.getTypeArguments().isEmpty() &amp;&amp;
2458                 !checkCompatibleAbstracts(pos, l.head, l.head, c))
2459                 return;
2460             for (List&lt;Type&gt; m = supertypes; m != l; m = m.tail)
2461                 if (!checkCompatibleAbstracts(pos, l.head, m.head, c))
2462                     return;
2463         }
2464         checkCompatibleConcretes(pos, c);
2465     }
2466 
2467     /** Check that all non-override equivalent methods accessible from &#39;site&#39;
2468      *  are mutually compatible (JLS 8.4.8/9.4.1).
2469      *
2470      *  @param pos  Position to be used for error reporting.
2471      *  @param site The class whose methods are checked.
2472      *  @param sym  The method symbol to be checked.
2473      */
2474     void checkOverrideClashes(DiagnosticPosition pos, Type site, MethodSymbol sym) {
2475          ClashFilter cf = new ClashFilter(site);
2476         //for each method m1 that is overridden (directly or indirectly)
2477         //by method &#39;sym&#39; in &#39;site&#39;...
2478 
2479         List&lt;MethodSymbol&gt; potentiallyAmbiguousList = List.nil();
2480         boolean overridesAny = false;
2481         ArrayList&lt;Symbol&gt; symbolsByName = new ArrayList&lt;&gt;();
2482         types.membersClosure(site, false).getSymbolsByName(sym.name, cf).forEach(symbolsByName::add);
2483         for (Symbol m1 : symbolsByName) {
2484             if (!sym.overrides(m1, site.tsym, types, false)) {
2485                 if (m1 == sym) {
2486                     continue;
2487                 }
2488 
2489                 if (!overridesAny) {
2490                     potentiallyAmbiguousList = potentiallyAmbiguousList.prepend((MethodSymbol)m1);
2491                 }
2492                 continue;
2493             }
2494 
2495             if (m1 != sym) {
2496                 overridesAny = true;
2497                 potentiallyAmbiguousList = List.nil();
2498             }
2499 
2500             //...check each method m2 that is a member of &#39;site&#39;
2501             for (Symbol m2 : symbolsByName) {
2502                 if (m2 == m1) continue;
2503                 //if (i) the signature of &#39;sym&#39; is not a subsignature of m1 (seen as
2504                 //a member of &#39;site&#39;) and (ii) m1 has the same erasure as m2, issue an error
2505                 if (!types.isSubSignature(sym.type, types.memberType(site, m2), Feature.STRICT_METHOD_CLASH_CHECK.allowedInSource(source)) &amp;&amp;
2506                         types.hasSameArgs(m2.erasure(types), m1.erasure(types))) {
2507                     sym.flags_field |= CLASH;
2508                     if (m1 == sym) {
2509                         log.error(pos, Errors.NameClashSameErasureNoOverride(
2510                             m1.name, types.memberType(site, m1).asMethodType().getParameterTypes(), m1.location(),
2511                             m2.name, types.memberType(site, m2).asMethodType().getParameterTypes(), m2.location()));
2512                     } else {
2513                         ClassType ct = (ClassType)site;
2514                         String kind = ct.isInterface() ? &quot;interface&quot; : &quot;class&quot;;
2515                         log.error(pos, Errors.NameClashSameErasureNoOverride1(
2516                             kind,
2517                             ct.tsym.name,
2518                             m1.name,
2519                             types.memberType(site, m1).asMethodType().getParameterTypes(),
2520                             m1.location(),
2521                             m2.name,
2522                             types.memberType(site, m2).asMethodType().getParameterTypes(),
2523                             m2.location()));
2524                     }
2525                     return;
2526                 }
2527             }
2528         }
2529 
2530         if (!overridesAny) {
2531             for (MethodSymbol m: potentiallyAmbiguousList) {
2532                 checkPotentiallyAmbiguousOverloads(pos, site, sym, m);
2533             }
2534         }
2535     }
2536 
2537     /** Check that all static methods accessible from &#39;site&#39; are
2538      *  mutually compatible (JLS 8.4.8).
2539      *
2540      *  @param pos  Position to be used for error reporting.
2541      *  @param site The class whose methods are checked.
2542      *  @param sym  The method symbol to be checked.
2543      */
2544     void checkHideClashes(DiagnosticPosition pos, Type site, MethodSymbol sym) {
2545         ClashFilter cf = new ClashFilter(site);
2546         //for each method m1 that is a member of &#39;site&#39;...
2547         for (Symbol s : types.membersClosure(site, true).getSymbolsByName(sym.name, cf)) {
2548             //if (i) the signature of &#39;sym&#39; is not a subsignature of m1 (seen as
2549             //a member of &#39;site&#39;) and (ii) &#39;sym&#39; has the same erasure as m1, issue an error
2550             if (!types.isSubSignature(sym.type, types.memberType(site, s), Feature.STRICT_METHOD_CLASH_CHECK.allowedInSource(source))) {
2551                 if (types.hasSameArgs(s.erasure(types), sym.erasure(types))) {
2552                     log.error(pos,
2553                               Errors.NameClashSameErasureNoHide(sym, sym.location(), s, s.location()));
2554                     return;
2555                 } else {
2556                     checkPotentiallyAmbiguousOverloads(pos, site, sym, (MethodSymbol)s);
2557                 }
2558             }
2559          }
2560      }
2561 
2562      //where
2563      private class ClashFilter implements Filter&lt;Symbol&gt; {
2564 
2565          Type site;
2566 
2567          ClashFilter(Type site) {
2568              this.site = site;
2569          }
2570 
2571          boolean shouldSkip(Symbol s) {
2572              return (s.flags() &amp; CLASH) != 0 &amp;&amp;
2573                 s.owner == site.tsym;
2574          }
2575 
2576          public boolean accepts(Symbol s) {
2577              return s.kind == MTH &amp;&amp;
2578                      (s.flags() &amp; SYNTHETIC) == 0 &amp;&amp;
2579                      !shouldSkip(s) &amp;&amp;
2580                      s.isInheritedIn(site.tsym, types) &amp;&amp;
2581                      !s.isConstructor();
2582          }
2583      }
2584 
2585     void checkDefaultMethodClashes(DiagnosticPosition pos, Type site) {
2586         DefaultMethodClashFilter dcf = new DefaultMethodClashFilter(site);
2587         for (Symbol m : types.membersClosure(site, false).getSymbols(dcf)) {
2588             Assert.check(m.kind == MTH);
2589             List&lt;MethodSymbol&gt; prov = types.interfaceCandidates(site, (MethodSymbol)m);
2590             if (prov.size() &gt; 1) {
2591                 ListBuffer&lt;Symbol&gt; abstracts = new ListBuffer&lt;&gt;();
2592                 ListBuffer&lt;Symbol&gt; defaults = new ListBuffer&lt;&gt;();
2593                 for (MethodSymbol provSym : prov) {
2594                     if ((provSym.flags() &amp; DEFAULT) != 0) {
2595                         defaults = defaults.append(provSym);
2596                     } else if ((provSym.flags() &amp; ABSTRACT) != 0) {
2597                         abstracts = abstracts.append(provSym);
2598                     }
2599                     if (defaults.nonEmpty() &amp;&amp; defaults.size() + abstracts.size() &gt;= 2) {
2600                         //strong semantics - issue an error if two sibling interfaces
2601                         //have two override-equivalent defaults - or if one is abstract
2602                         //and the other is default
2603                         Fragment diagKey;
2604                         Symbol s1 = defaults.first();
2605                         Symbol s2;
2606                         if (defaults.size() &gt; 1) {
2607                             s2 = defaults.toList().tail.head;
2608                             diagKey = Fragments.IncompatibleUnrelatedDefaults(Kinds.kindName(site.tsym), site,
2609                                     m.name, types.memberType(site, m).getParameterTypes(),
2610                                     s1.location(), s2.location());
2611 
2612                         } else {
2613                             s2 = abstracts.first();
2614                             diagKey = Fragments.IncompatibleAbstractDefault(Kinds.kindName(site.tsym), site,
2615                                     m.name, types.memberType(site, m).getParameterTypes(),
2616                                     s1.location(), s2.location());
2617                         }
2618                         log.error(pos, Errors.TypesIncompatible(s1.location().type, s2.location().type, diagKey));
2619                         break;
2620                     }
2621                 }
2622             }
2623         }
2624     }
2625 
2626     //where
2627      private class DefaultMethodClashFilter implements Filter&lt;Symbol&gt; {
2628 
2629          Type site;
2630 
2631          DefaultMethodClashFilter(Type site) {
2632              this.site = site;
2633          }
2634 
2635          public boolean accepts(Symbol s) {
2636              return s.kind == MTH &amp;&amp;
2637                      (s.flags() &amp; DEFAULT) != 0 &amp;&amp;
2638                      s.isInheritedIn(site.tsym, types) &amp;&amp;
2639                      !s.isConstructor();
2640          }
2641      }
2642 
2643     /**
2644       * Report warnings for potentially ambiguous method declarations. Two declarations
2645       * are potentially ambiguous if they feature two unrelated functional interface
2646       * in same argument position (in which case, a call site passing an implicit
2647       * lambda would be ambiguous).
2648       */
2649     void checkPotentiallyAmbiguousOverloads(DiagnosticPosition pos, Type site,
2650             MethodSymbol msym1, MethodSymbol msym2) {
2651         if (msym1 != msym2 &amp;&amp;
2652                 Feature.DEFAULT_METHODS.allowedInSource(source) &amp;&amp;
2653                 lint.isEnabled(LintCategory.OVERLOADS) &amp;&amp;
2654                 (msym1.flags() &amp; POTENTIALLY_AMBIGUOUS) == 0 &amp;&amp;
2655                 (msym2.flags() &amp; POTENTIALLY_AMBIGUOUS) == 0) {
2656             Type mt1 = types.memberType(site, msym1);
2657             Type mt2 = types.memberType(site, msym2);
2658             //if both generic methods, adjust type variables
2659             if (mt1.hasTag(FORALL) &amp;&amp; mt2.hasTag(FORALL) &amp;&amp;
2660                     types.hasSameBounds((ForAll)mt1, (ForAll)mt2)) {
2661                 mt2 = types.subst(mt2, ((ForAll)mt2).tvars, ((ForAll)mt1).tvars);
2662             }
2663             //expand varargs methods if needed
2664             int maxLength = Math.max(mt1.getParameterTypes().length(), mt2.getParameterTypes().length());
2665             List&lt;Type&gt; args1 = rs.adjustArgs(mt1.getParameterTypes(), msym1, maxLength, true);
2666             List&lt;Type&gt; args2 = rs.adjustArgs(mt2.getParameterTypes(), msym2, maxLength, true);
2667             //if arities don&#39;t match, exit
2668             if (args1.length() != args2.length()) return;
2669             boolean potentiallyAmbiguous = false;
2670             while (args1.nonEmpty() &amp;&amp; args2.nonEmpty()) {
2671                 Type s = args1.head;
2672                 Type t = args2.head;
2673                 if (!types.isSubtype(t, s) &amp;&amp; !types.isSubtype(s, t)) {
2674                     if (types.isFunctionalInterface(s) &amp;&amp; types.isFunctionalInterface(t) &amp;&amp;
2675                             types.findDescriptorType(s).getParameterTypes().length() &gt; 0 &amp;&amp;
2676                             types.findDescriptorType(s).getParameterTypes().length() ==
2677                             types.findDescriptorType(t).getParameterTypes().length()) {
2678                         potentiallyAmbiguous = true;
2679                     } else {
2680                         break;
2681                     }
2682                 }
2683                 args1 = args1.tail;
2684                 args2 = args2.tail;
2685             }
2686             if (potentiallyAmbiguous) {
2687                 //we found two incompatible functional interfaces with same arity
2688                 //this means a call site passing an implicit lambda would be ambiguous
2689                 msym1.flags_field |= POTENTIALLY_AMBIGUOUS;
2690                 msym2.flags_field |= POTENTIALLY_AMBIGUOUS;
2691                 log.warning(LintCategory.OVERLOADS, pos,
2692                             Warnings.PotentiallyAmbiguousOverload(msym1, msym1.location(),
2693                                                                   msym2, msym2.location()));
2694                 return;
2695             }
2696         }
2697     }
2698 
2699     void checkAccessFromSerializableElement(final JCTree tree, boolean isLambda) {
2700         if (warnOnAnyAccessToMembers ||
2701             (lint.isEnabled(LintCategory.SERIAL) &amp;&amp;
2702             !lint.isSuppressed(LintCategory.SERIAL) &amp;&amp;
2703             isLambda)) {
2704             Symbol sym = TreeInfo.symbol(tree);
2705             if (!sym.kind.matches(KindSelector.VAL_MTH)) {
2706                 return;
2707             }
2708 
2709             if (sym.kind == VAR) {
2710                 if ((sym.flags() &amp; PARAMETER) != 0 ||
2711                     sym.isLocal() ||
2712                     sym.name == names._this ||
2713                     sym.name == names._super) {
2714                     return;
2715                 }
2716             }
2717 
2718             if (!types.isSubtype(sym.owner.type, syms.serializableType) &amp;&amp;
2719                 isEffectivelyNonPublic(sym)) {
2720                 if (isLambda) {
2721                     if (belongsToRestrictedPackage(sym)) {
2722                         log.warning(LintCategory.SERIAL, tree.pos(),
2723                                     Warnings.AccessToMemberFromSerializableLambda(sym));
2724                     }
2725                 } else {
2726                     log.warning(tree.pos(),
2727                                 Warnings.AccessToMemberFromSerializableElement(sym));
2728                 }
2729             }
2730         }
2731     }
2732 
2733     private boolean isEffectivelyNonPublic(Symbol sym) {
2734         if (sym.packge() == syms.rootPackage) {
2735             return false;
2736         }
2737 
2738         while (sym.kind != PCK) {
2739             if ((sym.flags() &amp; PUBLIC) == 0) {
2740                 return true;
2741             }
2742             sym = sym.owner;
2743         }
2744         return false;
2745     }
2746 
2747     private boolean belongsToRestrictedPackage(Symbol sym) {
2748         String fullName = sym.packge().fullname.toString();
2749         return fullName.startsWith(&quot;java.&quot;) ||
2750                 fullName.startsWith(&quot;javax.&quot;) ||
2751                 fullName.startsWith(&quot;sun.&quot;) ||
2752                 fullName.contains(&quot;.internal.&quot;);
2753     }
2754 
2755     /** Check that class c does not implement directly or indirectly
2756      *  the same parameterized interface with two different argument lists.
2757      *  @param pos          Position to be used for error reporting.
2758      *  @param type         The type whose interfaces are checked.
2759      */
2760     void checkClassBounds(DiagnosticPosition pos, Type type) {
2761         checkClassBounds(pos, new HashMap&lt;TypeSymbol,Type&gt;(), type);
2762     }
2763 //where
2764         /** Enter all interfaces of type `type&#39; into the hash table `seensofar&#39;
2765          *  with their class symbol as key and their type as value. Make
2766          *  sure no class is entered with two different types.
2767          */
2768         void checkClassBounds(DiagnosticPosition pos,
2769                               Map&lt;TypeSymbol,Type&gt; seensofar,
2770                               Type type) {
2771             if (type.isErroneous()) return;
2772             for (List&lt;Type&gt; l = types.interfaces(type); l.nonEmpty(); l = l.tail) {
2773                 Type it = l.head;
2774                 if (type.hasTag(CLASS) &amp;&amp; !it.hasTag(CLASS)) continue; // JLS 8.1.5
2775 
2776                 Type oldit = seensofar.put(it.tsym, it);
2777                 if (oldit != null) {
2778                     List&lt;Type&gt; oldparams = oldit.allparams();
2779                     List&lt;Type&gt; newparams = it.allparams();
2780                     if (!types.containsTypeEquivalent(oldparams, newparams))
2781                         log.error(pos,
2782                                   Errors.CantInheritDiffArg(it.tsym,
2783                                                             Type.toString(oldparams),
2784                                                             Type.toString(newparams)));
2785                 }
2786                 checkClassBounds(pos, seensofar, it);
2787             }
2788             Type st = types.supertype(type);
2789             if (type.hasTag(CLASS) &amp;&amp; !st.hasTag(CLASS)) return; // JLS 8.1.4
2790             if (st != Type.noType) checkClassBounds(pos, seensofar, st);
2791         }
2792 
2793     /** Enter interface into into set.
2794      *  If it existed already, issue a &quot;repeated interface&quot; error.
2795      */
2796     void checkNotRepeated(DiagnosticPosition pos, Type it, Set&lt;Type&gt; its) {
2797         if (its.contains(it))
2798             log.error(pos, Errors.RepeatedInterface);
2799         else {
2800             its.add(it);
2801         }
2802     }
2803 
2804 /* *************************************************************************
2805  * Check annotations
2806  **************************************************************************/
2807 
2808     /**
2809      * Recursively validate annotations values
2810      */
2811     void validateAnnotationTree(JCTree tree) {
2812         class AnnotationValidator extends TreeScanner {
2813             @Override
2814             public void visitAnnotation(JCAnnotation tree) {
2815                 if (!tree.type.isErroneous() &amp;&amp; tree.type.tsym.isAnnotationType()) {
2816                     super.visitAnnotation(tree);
2817                     validateAnnotation(tree);
2818                 }
2819             }
2820         }
2821         tree.accept(new AnnotationValidator());
2822     }
2823 
2824     /**
2825      *  {@literal
2826      *  Annotation types are restricted to primitives, String, an
2827      *  enum, an annotation, Class, Class&lt;?&gt;, Class&lt;? extends
2828      *  Anything&gt;, arrays of the preceding.
2829      *  }
2830      */
2831     void validateAnnotationType(JCTree restype) {
2832         // restype may be null if an error occurred, so don&#39;t bother validating it
2833         if (restype != null) {
2834             validateAnnotationType(restype.pos(), restype.type);
2835         }
2836     }
2837 
2838     void validateAnnotationType(DiagnosticPosition pos, Type type) {
2839         if (type.isPrimitive()) return;
2840         if (types.isSameType(type, syms.stringType)) return;
2841         if ((type.tsym.flags() &amp; Flags.ENUM) != 0) return;
2842         if ((type.tsym.flags() &amp; Flags.ANNOTATION) != 0) return;
2843         if (types.cvarLowerBound(type).tsym == syms.classType.tsym) return;
2844         if (types.isArray(type) &amp;&amp; !types.isArray(types.elemtype(type))) {
2845             validateAnnotationType(pos, types.elemtype(type));
2846             return;
2847         }
2848         log.error(pos, Errors.InvalidAnnotationMemberType);
2849     }
2850 
2851     /**
2852      * &quot;It is also a compile-time error if any method declared in an
2853      * annotation type has a signature that is override-equivalent to
2854      * that of any public or protected method declared in class Object
2855      * or in the interface annotation.Annotation.&quot;
2856      *
2857      * @jls 9.6 Annotation Types
2858      */
2859     void validateAnnotationMethod(DiagnosticPosition pos, MethodSymbol m) {
2860         for (Type sup = syms.annotationType; sup.hasTag(CLASS); sup = types.supertype(sup)) {
2861             Scope s = sup.tsym.members();
2862             for (Symbol sym : s.getSymbolsByName(m.name)) {
2863                 if (sym.kind == MTH &amp;&amp;
2864                     (sym.flags() &amp; (PUBLIC | PROTECTED)) != 0 &amp;&amp;
2865                     types.overrideEquivalent(m.type, sym.type))
2866                     log.error(pos, Errors.IntfAnnotationMemberClash(sym, sup));
2867             }
2868         }
2869     }
2870 
2871     /** Check the annotations of a symbol.
2872      */
2873     public void validateAnnotations(List&lt;JCAnnotation&gt; annotations, JCTree declarationTree, Symbol s) {
2874         for (JCAnnotation a : annotations)
2875             validateAnnotation(a, declarationTree, s);
2876     }
2877 
2878     /** Check the type annotations.
2879      */
2880     public void validateTypeAnnotations(List&lt;JCAnnotation&gt; annotations, boolean isTypeParameter) {
2881         for (JCAnnotation a : annotations)
2882             validateTypeAnnotation(a, isTypeParameter);
2883     }
2884 
2885     /** Check an annotation of a symbol.
2886      */
2887     private void validateAnnotation(JCAnnotation a, JCTree declarationTree, Symbol s) {
2888         validateAnnotationTree(a);
2889         boolean isRecordMember = (s.flags_field &amp; RECORD) != 0 || s.enclClass() != null &amp;&amp; s.enclClass().isRecord();
2890 
2891         boolean isRecordField = isRecordMember &amp;&amp;
2892                 (s.flags_field &amp; (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &amp;&amp;
2893                 declarationTree.hasTag(VARDEF) &amp;&amp;
2894                 s.owner.kind == TYP;
2895 
2896         if (isRecordField) {
2897             // first we need to check if the annotation is applicable to records
2898             Name[] targets = getTargetNames(a);
2899             boolean appliesToRecords = false;
2900             for (Name target : targets) {
2901                 appliesToRecords =
2902                                 target == names.FIELD ||
2903                                 target == names.PARAMETER ||
2904                                 target == names.METHOD ||
2905                                 target == names.TYPE_USE ||
2906                                 target == names.RECORD_COMPONENT;
2907                 if (appliesToRecords) {
2908                     break;
2909                 }
2910             }
2911             if (!appliesToRecords) {
2912                 log.error(a.pos(), Errors.AnnotationTypeNotApplicable);
2913             } else {
2914                 /* lets now find the annotations in the field that are targeted to record components and append them to
2915                  * the corresponding record component
2916                  */
2917                 ClassSymbol recordClass = (ClassSymbol) s.owner;
2918                 RecordComponent rc = recordClass.getRecordComponent((VarSymbol)s);
2919                 SymbolMetadata metadata = rc.getMetadata();
2920                 if (metadata == null || metadata.isEmpty()) {
2921                     /* if not is empty then we have already been here, which is the case if multiple annotations are applied
2922                      * to the record component declaration
2923                      */
2924                     rc.appendAttributes(s.getRawAttributes().stream().filter(anno -&gt;
2925                             Arrays.stream(getTargetNames(anno.type.tsym)).anyMatch(name -&gt; name == names.RECORD_COMPONENT)
2926                     ).collect(List.collector()));
2927                     rc.setTypeAttributes(s.getRawTypeAttributes());
2928                     // to get all the type annotations applied to the type
2929                     rc.type = s.type;
2930                 }
2931             }
2932         }
2933 
2934         /* the section below is tricky. Annotations applied to record components are propagated to the corresponding
2935          * record member so if an annotation has target: FIELD, it is propagated to the corresponding FIELD, if it has
2936          * target METHOD, it is propagated to the accessor and so on. But at the moment when method members are generated
2937          * there is no enough information to propagate only the right annotations. So all the annotations are propagated
2938          * to all the possible locations.
2939          *
2940          * At this point we need to remove all the annotations that are not in place before going on with the annotation
2941          * party. On top of the above there is the issue that there is no AST representing record components, just symbols
2942          * so the corresponding field has been holding all the annotations and it&#39;s metadata has been modified as if it
2943          * was both a field and a record component.
2944          *
2945          * So there are two places where we need to trim annotations from: the metadata of the symbol and / or the modifiers
2946          * in the AST. Whatever is in the metadata will be written to the class file, whatever is in the modifiers could
2947          * be see by annotation processors.
2948          *
2949          * The metadata contains both type annotations and declaration annotations. At this point of the game we don&#39;t
2950          * need to care about type annotations, they are all in the right place. But we could need to remove declaration
2951          * annotations. So for declaration annotations if they are not applicable to the record member, excluding type
2952          * annotations which are already correct, then we will remove it. For the AST modifiers if the annotation is not
2953          * applicable either as type annotation and or declaration annotation, only in that case it will be removed.
2954          *
2955          * So it could be that annotation is removed as a declaration annotation but it is kept in the AST modifier for
2956          * further inspection by annotation processors.
2957          *
2958          * For example:
2959          *
2960          *     import java.lang.annotation.*;
2961          *
2962          *     @Target({ElementType.TYPE_USE, ElementType.RECORD_COMPONENT})
2963          *     @Retention(RetentionPolicy.RUNTIME)
2964          *     @interface Anno { }
2965          *
2966          *     record R(@Anno String s) {}
2967          *
2968          * at this point we will have for the case of the generated field:
2969          *   - @Anno in the modifier
2970          *   - @Anno as a type annotation
2971          *   - @Anno as a declaration annotation
2972          *
2973          * the last one should be removed because the annotation has not FIELD as target but it was applied as a
2974          * declaration annotation because the field was being treated both as a field and as a record component
2975          * as we have already copied the annotations to the record component, now the field doesn&#39;t need to hold
2976          * annotations that are not intended for it anymore. Still @Anno has to be kept in the AST&#39;s modifiers as it
2977          * is applicable as a type annotation to the type of the field.
2978          */
2979 
2980         if (a.type.tsym.isAnnotationType()) {
2981             Optional&lt;Set&lt;Name&gt;&gt; applicableTargetsOp = getApplicableTargets(a, s);
2982             if (!applicableTargetsOp.isEmpty()) {
2983                 Set&lt;Name&gt; applicableTargets = applicableTargetsOp.get();
2984                 boolean notApplicableOrIsTypeUseOnly = applicableTargets.isEmpty() ||
2985                         applicableTargets.size() == 1 &amp;&amp; applicableTargets.contains(names.TYPE_USE);
2986                 boolean isRecordMemberWithNonApplicableDeclAnno =
2987                         isRecordMember &amp;&amp; (s.flags_field &amp; Flags.GENERATED_MEMBER) != 0 &amp;&amp; notApplicableOrIsTypeUseOnly;
2988 
2989                 if (applicableTargets.isEmpty() || isRecordMemberWithNonApplicableDeclAnno) {
2990                     if (isRecordMemberWithNonApplicableDeclAnno) {
2991                             /* so we have found an annotation that is not applicable to a record member that was generated by the
2992                              * compiler. This was intentionally done at TypeEnter, now is the moment strip away the annotations
2993                              * that are not applicable to the given record member
2994                              */
2995                         JCModifiers modifiers = TreeInfo.getModifiers(declarationTree);
2996                             /* lets first remove the annotation from the modifier if it is not applicable, we have to check again as
2997                              * it could be a type annotation
2998                              */
2999                         if (modifiers != null &amp;&amp; applicableTargets.isEmpty()) {
3000                             ListBuffer&lt;JCAnnotation&gt; newAnnotations = new ListBuffer&lt;&gt;();
3001                             for (JCAnnotation anno : modifiers.annotations) {
3002                                 if (anno != a) {
3003                                     newAnnotations.add(anno);
3004                                 }
3005                             }
3006                             modifiers.annotations = newAnnotations.toList();
3007                         }
3008                         // now lets remove it from the symbol
3009                         s.getMetadata().removeDeclarationMetadata(a.attribute);
3010                     } else {
3011                         log.error(a.pos(), Errors.AnnotationTypeNotApplicable);
3012                     }
3013                 }
3014             }
3015         }
3016 
3017         if (a.annotationType.type.tsym == syms.functionalInterfaceType.tsym) {
3018             if (s.kind != TYP) {
3019                 log.error(a.pos(), Errors.BadFunctionalIntfAnno);
3020             } else if (!s.isInterface() || (s.flags() &amp; ANNOTATION) != 0) {
3021                 log.error(a.pos(), Errors.BadFunctionalIntfAnno1(Fragments.NotAFunctionalIntf(s)));
3022             }
3023         }
3024     }
3025 
3026     public void validateTypeAnnotation(JCAnnotation a, boolean isTypeParameter) {
3027         Assert.checkNonNull(a.type);
3028         validateAnnotationTree(a);
3029 
3030         if (a.hasTag(TYPE_ANNOTATION) &amp;&amp;
3031                 !a.annotationType.type.isErroneous() &amp;&amp;
3032                 !isTypeAnnotation(a, isTypeParameter)) {
3033             log.error(a.pos(), Errors.AnnotationTypeNotApplicableToType(a.type));
3034         }
3035     }
3036 
3037     /**
3038      * Validate the proposed container &#39;repeatable&#39; on the
3039      * annotation type symbol &#39;s&#39;. Report errors at position
3040      * &#39;pos&#39;.
3041      *
3042      * @param s The (annotation)type declaration annotated with a @Repeatable
3043      * @param repeatable the @Repeatable on &#39;s&#39;
3044      * @param pos where to report errors
3045      */
3046     public void validateRepeatable(TypeSymbol s, Attribute.Compound repeatable, DiagnosticPosition pos) {
3047         Assert.check(types.isSameType(repeatable.type, syms.repeatableType));
3048 
3049         Type t = null;
3050         List&lt;Pair&lt;MethodSymbol,Attribute&gt;&gt; l = repeatable.values;
3051         if (!l.isEmpty()) {
3052             Assert.check(l.head.fst.name == names.value);
3053             t = ((Attribute.Class)l.head.snd).getValue();
3054         }
3055 
3056         if (t == null) {
3057             // errors should already have been reported during Annotate
3058             return;
3059         }
3060 
3061         validateValue(t.tsym, s, pos);
3062         validateRetention(t.tsym, s, pos);
3063         validateDocumented(t.tsym, s, pos);
3064         validateInherited(t.tsym, s, pos);
3065         validateTarget(t.tsym, s, pos);
3066         validateDefault(t.tsym, pos);
3067     }
3068 
3069     private void validateValue(TypeSymbol container, TypeSymbol contained, DiagnosticPosition pos) {
3070         Symbol sym = container.members().findFirst(names.value);
3071         if (sym != null &amp;&amp; sym.kind == MTH) {
3072             MethodSymbol m = (MethodSymbol) sym;
3073             Type ret = m.getReturnType();
3074             if (!(ret.hasTag(ARRAY) &amp;&amp; types.isSameType(((ArrayType)ret).elemtype, contained.type))) {
3075                 log.error(pos,
3076                           Errors.InvalidRepeatableAnnotationValueReturn(container,
3077                                                                         ret,
3078                                                                         types.makeArrayType(contained.type)));
3079             }
3080         } else {
3081             log.error(pos, Errors.InvalidRepeatableAnnotationNoValue(container));
3082         }
3083     }
3084 
3085     private void validateRetention(TypeSymbol container, TypeSymbol contained, DiagnosticPosition pos) {
3086         Attribute.RetentionPolicy containerRetention = types.getRetention(container);
3087         Attribute.RetentionPolicy containedRetention = types.getRetention(contained);
3088 
3089         boolean error = false;
3090         switch (containedRetention) {
3091         case RUNTIME:
3092             if (containerRetention != Attribute.RetentionPolicy.RUNTIME) {
3093                 error = true;
3094             }
3095             break;
3096         case CLASS:
3097             if (containerRetention == Attribute.RetentionPolicy.SOURCE)  {
3098                 error = true;
3099             }
3100         }
3101         if (error ) {
3102             log.error(pos,
3103                       Errors.InvalidRepeatableAnnotationRetention(container,
3104                                                                   containerRetention.name(),
3105                                                                   contained,
3106                                                                   containedRetention.name()));
3107         }
3108     }
3109 
3110     private void validateDocumented(Symbol container, Symbol contained, DiagnosticPosition pos) {
3111         if (contained.attribute(syms.documentedType.tsym) != null) {
3112             if (container.attribute(syms.documentedType.tsym) == null) {
3113                 log.error(pos, Errors.InvalidRepeatableAnnotationNotDocumented(container, contained));
3114             }
3115         }
3116     }
3117 
3118     private void validateInherited(Symbol container, Symbol contained, DiagnosticPosition pos) {
3119         if (contained.attribute(syms.inheritedType.tsym) != null) {
3120             if (container.attribute(syms.inheritedType.tsym) == null) {
3121                 log.error(pos, Errors.InvalidRepeatableAnnotationNotInherited(container, contained));
3122             }
3123         }
3124     }
3125 
3126     private void validateTarget(TypeSymbol container, TypeSymbol contained, DiagnosticPosition pos) {
3127         // The set of targets the container is applicable to must be a subset
3128         // (with respect to annotation target semantics) of the set of targets
3129         // the contained is applicable to. The target sets may be implicit or
3130         // explicit.
3131 
3132         Set&lt;Name&gt; containerTargets;
3133         Attribute.Array containerTarget = getAttributeTargetAttribute(container);
3134         if (containerTarget == null) {
3135             containerTargets = getDefaultTargetSet();
3136         } else {
3137             containerTargets = new HashSet&lt;&gt;();
3138             for (Attribute app : containerTarget.values) {
3139                 if (!(app instanceof Attribute.Enum)) {
3140                     continue; // recovery
3141                 }
3142                 Attribute.Enum e = (Attribute.Enum)app;
3143                 containerTargets.add(e.value.name);
3144             }
3145         }
3146 
3147         Set&lt;Name&gt; containedTargets;
3148         Attribute.Array containedTarget = getAttributeTargetAttribute(contained);
3149         if (containedTarget == null) {
3150             containedTargets = getDefaultTargetSet();
3151         } else {
3152             containedTargets = new HashSet&lt;&gt;();
3153             for (Attribute app : containedTarget.values) {
3154                 if (!(app instanceof Attribute.Enum)) {
3155                     continue; // recovery
3156                 }
3157                 Attribute.Enum e = (Attribute.Enum)app;
3158                 containedTargets.add(e.value.name);
3159             }
3160         }
3161 
3162         if (!isTargetSubsetOf(containerTargets, containedTargets)) {
3163             log.error(pos, Errors.InvalidRepeatableAnnotationIncompatibleTarget(container, contained));
3164         }
3165     }
3166 
3167     /* get a set of names for the default target */
3168     private Set&lt;Name&gt; getDefaultTargetSet() {
3169         if (defaultTargets == null) {
3170             Set&lt;Name&gt; targets = new HashSet&lt;&gt;();
3171             targets.add(names.ANNOTATION_TYPE);
3172             targets.add(names.CONSTRUCTOR);
3173             targets.add(names.FIELD);
<a name="3" id="anc3"></a><span class="line-modified">3174             if (allowRecords) {</span>
<span class="line-added">3175                 targets.add(names.RECORD_COMPONENT);</span>
<span class="line-added">3176             }</span>
3177             targets.add(names.LOCAL_VARIABLE);
3178             targets.add(names.METHOD);
3179             targets.add(names.PACKAGE);
3180             targets.add(names.PARAMETER);
3181             targets.add(names.TYPE);
3182 
3183             defaultTargets = java.util.Collections.unmodifiableSet(targets);
3184         }
3185 
3186         return defaultTargets;
3187     }
3188     private Set&lt;Name&gt; defaultTargets;
3189 
3190 
3191     /** Checks that s is a subset of t, with respect to ElementType
3192      * semantics, specifically {ANNOTATION_TYPE} is a subset of {TYPE},
3193      * and {TYPE_USE} covers the set {ANNOTATION_TYPE, TYPE, TYPE_USE,
3194      * TYPE_PARAMETER}.
3195      */
3196     private boolean isTargetSubsetOf(Set&lt;Name&gt; s, Set&lt;Name&gt; t) {
3197         // Check that all elements in s are present in t
3198         for (Name n2 : s) {
3199             boolean currentElementOk = false;
3200             for (Name n1 : t) {
3201                 if (n1 == n2) {
3202                     currentElementOk = true;
3203                     break;
3204                 } else if (n1 == names.TYPE &amp;&amp; n2 == names.ANNOTATION_TYPE) {
3205                     currentElementOk = true;
3206                     break;
3207                 } else if (n1 == names.TYPE_USE &amp;&amp;
3208                         (n2 == names.TYPE ||
3209                          n2 == names.ANNOTATION_TYPE ||
3210                          n2 == names.TYPE_PARAMETER)) {
3211                     currentElementOk = true;
3212                     break;
3213                 }
3214             }
3215             if (!currentElementOk)
3216                 return false;
3217         }
3218         return true;
3219     }
3220 
3221     private void validateDefault(Symbol container, DiagnosticPosition pos) {
3222         // validate that all other elements of containing type has defaults
3223         Scope scope = container.members();
3224         for(Symbol elm : scope.getSymbols()) {
3225             if (elm.name != names.value &amp;&amp;
3226                 elm.kind == MTH &amp;&amp;
3227                 ((MethodSymbol)elm).defaultValue == null) {
3228                 log.error(pos,
3229                           Errors.InvalidRepeatableAnnotationElemNondefault(container, elm));
3230             }
3231         }
3232     }
3233 
3234     /** Is s a method symbol that overrides a method in a superclass? */
3235     boolean isOverrider(Symbol s) {
3236         if (s.kind != MTH || s.isStatic())
3237             return false;
3238         MethodSymbol m = (MethodSymbol)s;
3239         TypeSymbol owner = (TypeSymbol)m.owner;
3240         for (Type sup : types.closure(owner.type)) {
3241             if (sup == owner.type)
3242                 continue; // skip &quot;this&quot;
3243             Scope scope = sup.tsym.members();
3244             for (Symbol sym : scope.getSymbolsByName(m.name)) {
3245                 if (!sym.isStatic() &amp;&amp; m.overrides(sym, owner, types, true))
3246                     return true;
3247             }
3248         }
3249         return false;
3250     }
3251 
3252     /** Is the annotation applicable to types? */
3253     protected boolean isTypeAnnotation(JCAnnotation a, boolean isTypeParameter) {
3254         List&lt;Attribute&gt; targets = typeAnnotations.annotationTargets(a.annotationType.type.tsym);
3255         return (targets == null) ?
3256                 false :
3257                 targets.stream()
3258                         .anyMatch(attr -&gt; isTypeAnnotation(attr, isTypeParameter));
3259     }
3260     //where
3261         boolean isTypeAnnotation(Attribute a, boolean isTypeParameter) {
3262             Attribute.Enum e = (Attribute.Enum)a;
3263             return (e.value.name == names.TYPE_USE ||
3264                     (isTypeParameter &amp;&amp; e.value.name == names.TYPE_PARAMETER));
3265         }
3266 
3267     /** Is the annotation applicable to the symbol? */
3268     Name[] getTargetNames(JCAnnotation a) {
3269         return getTargetNames(a.annotationType.type.tsym);
3270     }
3271 
3272     public Name[] getTargetNames(TypeSymbol annoSym) {
3273         Attribute.Array arr = getAttributeTargetAttribute(annoSym);
3274         Name[] targets;
3275         if (arr == null) {
3276             targets = defaultTargetMetaInfo();
3277         } else {
3278             // TODO: can we optimize this?
3279             targets = new Name[arr.values.length];
3280             for (int i=0; i&lt;arr.values.length; ++i) {
3281                 Attribute app = arr.values[i];
3282                 if (!(app instanceof Attribute.Enum)) {
3283                     return new Name[0];
3284                 }
3285                 Attribute.Enum e = (Attribute.Enum) app;
3286                 targets[i] = e.value.name;
3287             }
3288         }
3289         return targets;
3290     }
3291 
3292     boolean annotationApplicable(JCAnnotation a, Symbol s) {
3293         Optional&lt;Set&lt;Name&gt;&gt; targets = getApplicableTargets(a, s);
3294         /* the optional could be emtpy if the annotation is unknown in that case
3295          * we return that it is applicable and if it is erroneous that should imply
3296          * an error at the declaration site
3297          */
3298         return targets.isEmpty() || targets.isPresent() &amp;&amp; !targets.get().isEmpty();
3299     }
3300 
3301     @SuppressWarnings(&quot;preview&quot;)
3302     Optional&lt;Set&lt;Name&gt;&gt; getApplicableTargets(JCAnnotation a, Symbol s) {
3303         Attribute.Array arr = getAttributeTargetAttribute(a.annotationType.type.tsym);
3304         Name[] targets;
3305         Set&lt;Name&gt; applicableTargets = new HashSet&lt;&gt;();
3306 
3307         if (arr == null) {
3308             targets = defaultTargetMetaInfo();
3309         } else {
3310             // TODO: can we optimize this?
3311             targets = new Name[arr.values.length];
3312             for (int i=0; i&lt;arr.values.length; ++i) {
3313                 Attribute app = arr.values[i];
3314                 if (!(app instanceof Attribute.Enum)) {
3315                     // recovery
3316                     return Optional.empty();
3317                 }
3318                 Attribute.Enum e = (Attribute.Enum) app;
3319                 targets[i] = e.value.name;
3320             }
3321         }
3322         for (Name target : targets) {
3323             if (target == names.TYPE) {
3324                 if (s.kind == TYP)
3325                     applicableTargets.add(names.TYPE);
3326             } else if (target == names.FIELD) {
3327                 if (s.kind == VAR &amp;&amp; s.owner.kind != MTH)
3328                     applicableTargets.add(names.FIELD);
3329             } else if (target == names.RECORD_COMPONENT) {
3330                 if (s.getKind() == ElementKind.RECORD_COMPONENT) {
3331                     applicableTargets.add(names.RECORD_COMPONENT);
3332                 }
3333             } else if (target == names.METHOD) {
3334                 if (s.kind == MTH &amp;&amp; !s.isConstructor())
3335                     applicableTargets.add(names.METHOD);
3336             } else if (target == names.PARAMETER) {
3337                 if (s.kind == VAR &amp;&amp;
3338                     (s.owner.kind == MTH &amp;&amp; (s.flags() &amp; PARAMETER) != 0)) {
3339                     applicableTargets.add(names.PARAMETER);
3340                 }
3341             } else if (target == names.CONSTRUCTOR) {
3342                 if (s.kind == MTH &amp;&amp; s.isConstructor())
3343                     applicableTargets.add(names.CONSTRUCTOR);
3344             } else if (target == names.LOCAL_VARIABLE) {
3345                 if (s.kind == VAR &amp;&amp; s.owner.kind == MTH &amp;&amp;
3346                       (s.flags() &amp; PARAMETER) == 0) {
3347                     applicableTargets.add(names.LOCAL_VARIABLE);
3348                 }
3349             } else if (target == names.ANNOTATION_TYPE) {
3350                 if (s.kind == TYP &amp;&amp; (s.flags() &amp; ANNOTATION) != 0) {
3351                     applicableTargets.add(names.ANNOTATION_TYPE);
3352                 }
3353             } else if (target == names.PACKAGE) {
3354                 if (s.kind == PCK)
3355                     applicableTargets.add(names.PACKAGE);
3356             } else if (target == names.TYPE_USE) {
3357                 if (s.kind == VAR &amp;&amp; s.owner.kind == MTH &amp;&amp; s.type.hasTag(NONE)) {
3358                     //cannot type annotate implicitly typed locals
3359                     continue;
3360                 } else if (s.kind == TYP || s.kind == VAR ||
3361                         (s.kind == MTH &amp;&amp; !s.isConstructor() &amp;&amp;
3362                                 !s.type.getReturnType().hasTag(VOID)) ||
3363                         (s.kind == MTH &amp;&amp; s.isConstructor())) {
3364                     applicableTargets.add(names.TYPE_USE);
3365                 }
3366             } else if (target == names.TYPE_PARAMETER) {
3367                 if (s.kind == TYP &amp;&amp; s.type.hasTag(TYPEVAR))
3368                     applicableTargets.add(names.TYPE_PARAMETER);
3369             } else
3370                 return Optional.empty(); // Unknown ElementType. This should be an error at declaration site,
3371                                          // assume applicable.
3372         }
3373         return Optional.of(applicableTargets);
3374     }
3375 
3376     Attribute.Array getAttributeTargetAttribute(TypeSymbol s) {
3377         Attribute.Compound atTarget = s.getAnnotationTypeMetadata().getTarget();
3378         if (atTarget == null) return null; // ok, is applicable
3379         Attribute atValue = atTarget.member(names.value);
3380         if (!(atValue instanceof Attribute.Array)) return null; // error recovery
3381         return (Attribute.Array) atValue;
3382     }
3383 
3384     public final Name[] dfltTargetMeta;
3385     private Name[] defaultTargetMetaInfo() {
3386         return dfltTargetMeta;
3387     }
3388 
3389     /** Check an annotation value.
3390      *
3391      * @param a The annotation tree to check
3392      * @return true if this annotation tree is valid, otherwise false
3393      */
3394     public boolean validateAnnotationDeferErrors(JCAnnotation a) {
3395         boolean res = false;
3396         final Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);
3397         try {
3398             res = validateAnnotation(a);
3399         } finally {
3400             log.popDiagnosticHandler(diagHandler);
3401         }
3402         return res;
3403     }
3404 
3405     private boolean validateAnnotation(JCAnnotation a) {
3406         boolean isValid = true;
3407         AnnotationTypeMetadata metadata = a.annotationType.type.tsym.getAnnotationTypeMetadata();
3408 
3409         // collect an inventory of the annotation elements
3410         Set&lt;MethodSymbol&gt; elements = metadata.getAnnotationElements();
3411 
3412         // remove the ones that are assigned values
3413         for (JCTree arg : a.args) {
3414             if (!arg.hasTag(ASSIGN)) continue; // recovery
3415             JCAssign assign = (JCAssign)arg;
3416             Symbol m = TreeInfo.symbol(assign.lhs);
3417             if (m == null || m.type.isErroneous()) continue;
3418             if (!elements.remove(m)) {
3419                 isValid = false;
3420                 log.error(assign.lhs.pos(),
3421                           Errors.DuplicateAnnotationMemberValue(m.name, a.type));
3422             }
3423         }
3424 
3425         // all the remaining ones better have default values
3426         List&lt;Name&gt; missingDefaults = List.nil();
3427         Set&lt;MethodSymbol&gt; membersWithDefault = metadata.getAnnotationElementsWithDefault();
3428         for (MethodSymbol m : elements) {
3429             if (m.type.isErroneous())
3430                 continue;
3431 
3432             if (!membersWithDefault.contains(m))
3433                 missingDefaults = missingDefaults.append(m.name);
3434         }
3435         missingDefaults = missingDefaults.reverse();
3436         if (missingDefaults.nonEmpty()) {
3437             isValid = false;
3438             Error errorKey = (missingDefaults.size() &gt; 1)
3439                     ? Errors.AnnotationMissingDefaultValue1(a.type, missingDefaults)
3440                     : Errors.AnnotationMissingDefaultValue(a.type, missingDefaults);
3441             log.error(a.pos(), errorKey);
3442         }
3443 
3444         return isValid &amp;&amp; validateTargetAnnotationValue(a);
3445     }
3446 
3447     /* Validate the special java.lang.annotation.Target annotation */
3448     boolean validateTargetAnnotationValue(JCAnnotation a) {
3449         // special case: java.lang.annotation.Target must not have
3450         // repeated values in its value member
3451         if (a.annotationType.type.tsym != syms.annotationTargetType.tsym ||
3452                 a.args.tail == null)
3453             return true;
3454 
3455         boolean isValid = true;
3456         if (!a.args.head.hasTag(ASSIGN)) return false; // error recovery
3457         JCAssign assign = (JCAssign) a.args.head;
3458         Symbol m = TreeInfo.symbol(assign.lhs);
3459         if (m.name != names.value) return false;
3460         JCTree rhs = assign.rhs;
3461         if (!rhs.hasTag(NEWARRAY)) return false;
3462         JCNewArray na = (JCNewArray) rhs;
3463         Set&lt;Symbol&gt; targets = new HashSet&lt;&gt;();
3464         for (JCTree elem : na.elems) {
3465             if (!targets.add(TreeInfo.symbol(elem))) {
3466                 isValid = false;
3467                 log.error(elem.pos(), Errors.RepeatedAnnotationTarget);
3468             }
3469         }
3470         return isValid;
3471     }
3472 
3473     void checkDeprecatedAnnotation(DiagnosticPosition pos, Symbol s) {
3474         if (lint.isEnabled(LintCategory.DEP_ANN) &amp;&amp; s.isDeprecatableViaAnnotation() &amp;&amp;
3475             (s.flags() &amp; DEPRECATED) != 0 &amp;&amp;
3476             !syms.deprecatedType.isErroneous() &amp;&amp;
3477             s.attribute(syms.deprecatedType.tsym) == null) {
3478             log.warning(LintCategory.DEP_ANN,
3479                     pos, Warnings.MissingDeprecatedAnnotation);
3480         }
3481         // Note: @Deprecated has no effect on local variables, parameters and package decls.
3482         if (lint.isEnabled(LintCategory.DEPRECATION) &amp;&amp; !s.isDeprecatableViaAnnotation()) {
3483             if (!syms.deprecatedType.isErroneous() &amp;&amp; s.attribute(syms.deprecatedType.tsym) != null) {
3484                 log.warning(LintCategory.DEPRECATION, pos,
3485                             Warnings.DeprecatedAnnotationHasNoEffect(Kinds.kindName(s)));
3486             }
3487         }
3488     }
3489 
3490     void checkDeprecated(final DiagnosticPosition pos, final Symbol other, final Symbol s) {
3491         checkDeprecated(() -&gt; pos, other, s);
3492     }
3493 
3494     void checkDeprecated(Supplier&lt;DiagnosticPosition&gt; pos, final Symbol other, final Symbol s) {
3495         if ( (s.isDeprecatedForRemoval()
3496                 || s.isDeprecated() &amp;&amp; !other.isDeprecated())
3497                 &amp;&amp; (s.outermostClass() != other.outermostClass() || s.outermostClass() == null)) {
3498             deferredLintHandler.report(() -&gt; warnDeprecated(pos.get(), s));
3499         }
3500     }
3501 
3502     void checkSunAPI(final DiagnosticPosition pos, final Symbol s) {
3503         if ((s.flags() &amp; PROPRIETARY) != 0) {
3504             deferredLintHandler.report(() -&gt; {
3505                 log.mandatoryWarning(pos, Warnings.SunProprietary(s));
3506             });
3507         }
3508     }
3509 
3510     void checkProfile(final DiagnosticPosition pos, final Symbol s) {
3511         if (profile != Profile.DEFAULT &amp;&amp; (s.flags() &amp; NOT_IN_PROFILE) != 0) {
3512             log.error(pos, Errors.NotInProfile(s, profile));
3513         }
3514     }
3515 
3516     void checkPreview(DiagnosticPosition pos, Symbol s) {
3517         if ((s.flags() &amp; PREVIEW_API) != 0) {
3518             if ((s.flags() &amp; PREVIEW_ESSENTIAL_API) != 0 &amp;&amp; !preview.isEnabled()) {
3519                 log.error(pos, Errors.IsPreview(s));
3520             } else {
3521                 deferredLintHandler.report(() -&gt; warnPreview(pos, s));
3522             }
3523         }
3524     }
3525 
3526 /* *************************************************************************
3527  * Check for recursive annotation elements.
3528  **************************************************************************/
3529 
3530     /** Check for cycles in the graph of annotation elements.
3531      */
3532     void checkNonCyclicElements(JCClassDecl tree) {
3533         if ((tree.sym.flags_field &amp; ANNOTATION) == 0) return;
3534         Assert.check((tree.sym.flags_field &amp; LOCKED) == 0);
3535         try {
3536             tree.sym.flags_field |= LOCKED;
3537             for (JCTree def : tree.defs) {
3538                 if (!def.hasTag(METHODDEF)) continue;
3539                 JCMethodDecl meth = (JCMethodDecl)def;
3540                 checkAnnotationResType(meth.pos(), meth.restype.type);
3541             }
3542         } finally {
3543             tree.sym.flags_field &amp;= ~LOCKED;
3544             tree.sym.flags_field |= ACYCLIC_ANN;
3545         }
3546     }
3547 
3548     void checkNonCyclicElementsInternal(DiagnosticPosition pos, TypeSymbol tsym) {
3549         if ((tsym.flags_field &amp; ACYCLIC_ANN) != 0)
3550             return;
3551         if ((tsym.flags_field &amp; LOCKED) != 0) {
3552             log.error(pos, Errors.CyclicAnnotationElement(tsym));
3553             return;
3554         }
3555         try {
3556             tsym.flags_field |= LOCKED;
3557             for (Symbol s : tsym.members().getSymbols(NON_RECURSIVE)) {
3558                 if (s.kind != MTH)
3559                     continue;
3560                 checkAnnotationResType(pos, ((MethodSymbol)s).type.getReturnType());
3561             }
3562         } finally {
3563             tsym.flags_field &amp;= ~LOCKED;
3564             tsym.flags_field |= ACYCLIC_ANN;
3565         }
3566     }
3567 
3568     void checkAnnotationResType(DiagnosticPosition pos, Type type) {
3569         switch (type.getTag()) {
3570         case CLASS:
3571             if ((type.tsym.flags() &amp; ANNOTATION) != 0)
3572                 checkNonCyclicElementsInternal(pos, type.tsym);
3573             break;
3574         case ARRAY:
3575             checkAnnotationResType(pos, types.elemtype(type));
3576             break;
3577         default:
3578             break; // int etc
3579         }
3580     }
3581 
3582 /* *************************************************************************
3583  * Check for cycles in the constructor call graph.
3584  **************************************************************************/
3585 
3586     /** Check for cycles in the graph of constructors calling other
3587      *  constructors.
3588      */
3589     void checkCyclicConstructors(JCClassDecl tree) {
3590         Map&lt;Symbol,Symbol&gt; callMap = new HashMap&lt;&gt;();
3591 
3592         // enter each constructor this-call into the map
3593         for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
3594             JCMethodInvocation app = TreeInfo.firstConstructorCall(l.head);
3595             if (app == null) continue;
3596             JCMethodDecl meth = (JCMethodDecl) l.head;
3597             if (TreeInfo.name(app.meth) == names._this) {
3598                 callMap.put(meth.sym, TreeInfo.symbol(app.meth));
3599             } else {
3600                 meth.sym.flags_field |= ACYCLIC;
3601             }
3602         }
3603 
3604         // Check for cycles in the map
3605         Symbol[] ctors = new Symbol[0];
3606         ctors = callMap.keySet().toArray(ctors);
3607         for (Symbol caller : ctors) {
3608             checkCyclicConstructor(tree, caller, callMap);
3609         }
3610     }
3611 
3612     /** Look in the map to see if the given constructor is part of a
3613      *  call cycle.
3614      */
3615     private void checkCyclicConstructor(JCClassDecl tree, Symbol ctor,
3616                                         Map&lt;Symbol,Symbol&gt; callMap) {
3617         if (ctor != null &amp;&amp; (ctor.flags_field &amp; ACYCLIC) == 0) {
3618             if ((ctor.flags_field &amp; LOCKED) != 0) {
3619                 log.error(TreeInfo.diagnosticPositionFor(ctor, tree),
3620                           Errors.RecursiveCtorInvocation);
3621             } else {
3622                 ctor.flags_field |= LOCKED;
3623                 checkCyclicConstructor(tree, callMap.remove(ctor), callMap);
3624                 ctor.flags_field &amp;= ~LOCKED;
3625             }
3626             ctor.flags_field |= ACYCLIC;
3627         }
3628     }
3629 
3630 /* *************************************************************************
3631  * Miscellaneous
3632  **************************************************************************/
3633 
3634     /**
3635      *  Check for division by integer constant zero
3636      *  @param pos           Position for error reporting.
3637      *  @param operator      The operator for the expression
3638      *  @param operand       The right hand operand for the expression
3639      */
3640     void checkDivZero(final DiagnosticPosition pos, Symbol operator, Type operand) {
3641         if (operand.constValue() != null
3642             &amp;&amp; operand.getTag().isSubRangeOf(LONG)
3643             &amp;&amp; ((Number) (operand.constValue())).longValue() == 0) {
3644             int opc = ((OperatorSymbol)operator).opcode;
3645             if (opc == ByteCodes.idiv || opc == ByteCodes.imod
3646                 || opc == ByteCodes.ldiv || opc == ByteCodes.lmod) {
3647                 deferredLintHandler.report(() -&gt; warnDivZero(pos));
3648             }
3649         }
3650     }
3651 
3652     /**
3653      * Check for empty statements after if
3654      */
3655     void checkEmptyIf(JCIf tree) {
3656         if (tree.thenpart.hasTag(SKIP) &amp;&amp; tree.elsepart == null &amp;&amp;
3657                 lint.isEnabled(LintCategory.EMPTY))
3658             log.warning(LintCategory.EMPTY, tree.thenpart.pos(), Warnings.EmptyIf);
3659     }
3660 
3661     /** Check that symbol is unique in given scope.
3662      *  @param pos           Position for error reporting.
3663      *  @param sym           The symbol.
3664      *  @param s             The scope.
3665      */
3666     boolean checkUnique(DiagnosticPosition pos, Symbol sym, Scope s) {
3667         if (sym.type.isErroneous())
3668             return true;
3669         if (sym.owner.name == names.any) return false;
3670         for (Symbol byName : s.getSymbolsByName(sym.name, NON_RECURSIVE)) {
3671             if (sym != byName &amp;&amp;
3672                     (byName.flags() &amp; CLASH) == 0 &amp;&amp;
3673                     sym.kind == byName.kind &amp;&amp;
3674                     sym.name != names.error &amp;&amp;
3675                     (sym.kind != MTH ||
3676                      types.hasSameArgs(sym.type, byName.type) ||
3677                      types.hasSameArgs(types.erasure(sym.type), types.erasure(byName.type)))) {
3678                 if ((sym.flags() &amp; VARARGS) != (byName.flags() &amp; VARARGS)) {
3679                     sym.flags_field |= CLASH;
3680                     varargsDuplicateError(pos, sym, byName);
3681                     return true;
3682                 } else if (sym.kind == MTH &amp;&amp; !types.hasSameArgs(sym.type, byName.type, false)) {
3683                     duplicateErasureError(pos, sym, byName);
3684                     sym.flags_field |= CLASH;
3685                     return true;
3686                 } else if ((sym.flags() &amp; MATCH_BINDING) != 0 &amp;&amp;
3687                            (byName.flags() &amp; MATCH_BINDING) != 0 &amp;&amp;
3688                            (byName.flags() &amp; MATCH_BINDING_TO_OUTER) == 0) {
3689                     if (!sym.type.isErroneous()) {
3690                         log.error(pos, Errors.MatchBindingExists);
3691                         sym.flags_field |= CLASH;
3692                     }
3693                     return false;
3694                 } else {
3695                     duplicateError(pos, byName);
3696                     return false;
3697                 }
3698             }
3699         }
3700         return true;
3701     }
3702 
3703     /** Report duplicate declaration error.
3704      */
3705     void duplicateErasureError(DiagnosticPosition pos, Symbol sym1, Symbol sym2) {
3706         if (!sym1.type.isErroneous() &amp;&amp; !sym2.type.isErroneous()) {
3707             log.error(pos, Errors.NameClashSameErasure(sym1, sym2));
3708         }
3709     }
3710 
3711     /**Check that types imported through the ordinary imports don&#39;t clash with types imported
3712      * by other (static or ordinary) imports. Note that two static imports may import two clashing
3713      * types without an error on the imports.
3714      * @param toplevel       The toplevel tree for which the test should be performed.
3715      */
3716     void checkImportsUnique(JCCompilationUnit toplevel) {
3717         WriteableScope ordinallyImportedSoFar = WriteableScope.create(toplevel.packge);
3718         WriteableScope staticallyImportedSoFar = WriteableScope.create(toplevel.packge);
3719         WriteableScope topLevelScope = toplevel.toplevelScope;
3720 
3721         for (JCTree def : toplevel.defs) {
3722             if (!def.hasTag(IMPORT))
3723                 continue;
3724 
3725             JCImport imp = (JCImport) def;
3726 
3727             if (imp.importScope == null)
3728                 continue;
3729 
3730             for (Symbol sym : imp.importScope.getSymbols(sym -&gt; sym.kind == TYP)) {
3731                 if (imp.isStatic()) {
3732                     checkUniqueImport(imp.pos(), ordinallyImportedSoFar, staticallyImportedSoFar, topLevelScope, sym, true);
3733                     staticallyImportedSoFar.enter(sym);
3734                 } else {
3735                     checkUniqueImport(imp.pos(), ordinallyImportedSoFar, staticallyImportedSoFar, topLevelScope, sym, false);
3736                     ordinallyImportedSoFar.enter(sym);
3737                 }
3738             }
3739 
3740             imp.importScope = null;
3741         }
3742     }
3743 
3744     /** Check that single-type import is not already imported or top-level defined,
3745      *  but make an exception for two single-type imports which denote the same type.
3746      *  @param pos                     Position for error reporting.
3747      *  @param ordinallyImportedSoFar  A Scope containing types imported so far through
3748      *                                 ordinary imports.
3749      *  @param staticallyImportedSoFar A Scope containing types imported so far through
3750      *                                 static imports.
3751      *  @param topLevelScope           The current file&#39;s top-level Scope
3752      *  @param sym                     The symbol.
3753      *  @param staticImport            Whether or not this was a static import
3754      */
3755     private boolean checkUniqueImport(DiagnosticPosition pos, Scope ordinallyImportedSoFar,
3756                                       Scope staticallyImportedSoFar, Scope topLevelScope,
3757                                       Symbol sym, boolean staticImport) {
3758         Filter&lt;Symbol&gt; duplicates = candidate -&gt; candidate != sym &amp;&amp; !candidate.type.isErroneous();
3759         Symbol ordinaryClashing = ordinallyImportedSoFar.findFirst(sym.name, duplicates);
3760         Symbol staticClashing = null;
3761         if (ordinaryClashing == null &amp;&amp; !staticImport) {
3762             staticClashing = staticallyImportedSoFar.findFirst(sym.name, duplicates);
3763         }
3764         if (ordinaryClashing != null || staticClashing != null) {
3765             if (ordinaryClashing != null)
3766                 log.error(pos, Errors.AlreadyDefinedSingleImport(ordinaryClashing));
3767             else
3768                 log.error(pos, Errors.AlreadyDefinedStaticSingleImport(staticClashing));
3769             return false;
3770         }
3771         Symbol clashing = topLevelScope.findFirst(sym.name, duplicates);
3772         if (clashing != null) {
3773             log.error(pos, Errors.AlreadyDefinedThisUnit(clashing));
3774             return false;
3775         }
3776         return true;
3777     }
3778 
3779     /** Check that a qualified name is in canonical form (for import decls).
3780      */
3781     public void checkCanonical(JCTree tree) {
3782         if (!isCanonical(tree))
3783             log.error(tree.pos(),
3784                       Errors.ImportRequiresCanonical(TreeInfo.symbol(tree)));
3785     }
3786         // where
3787         private boolean isCanonical(JCTree tree) {
3788             while (tree.hasTag(SELECT)) {
3789                 JCFieldAccess s = (JCFieldAccess) tree;
3790                 if (s.sym.owner.getQualifiedName() != TreeInfo.symbol(s.selected).getQualifiedName())
3791                     return false;
3792                 tree = s.selected;
3793             }
3794             return true;
3795         }
3796 
3797     /** Check that an auxiliary class is not accessed from any other file than its own.
3798      */
3799     void checkForBadAuxiliaryClassAccess(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, ClassSymbol c) {
3800         if (lint.isEnabled(Lint.LintCategory.AUXILIARYCLASS) &amp;&amp;
3801             (c.flags() &amp; AUXILIARY) != 0 &amp;&amp;
3802             rs.isAccessible(env, c) &amp;&amp;
3803             !fileManager.isSameFile(c.sourcefile, env.toplevel.sourcefile))
3804         {
3805             log.warning(pos,
3806                         Warnings.AuxiliaryClassAccessedFromOutsideOfItsSourceFile(c, c.sourcefile));
3807         }
3808     }
3809 
3810     private class ConversionWarner extends Warner {
3811         final String uncheckedKey;
3812         final Type found;
3813         final Type expected;
3814         public ConversionWarner(DiagnosticPosition pos, String uncheckedKey, Type found, Type expected) {
3815             super(pos);
3816             this.uncheckedKey = uncheckedKey;
3817             this.found = found;
3818             this.expected = expected;
3819         }
3820 
3821         @Override
3822         public void warn(LintCategory lint) {
3823             boolean warned = this.warned;
3824             super.warn(lint);
3825             if (warned) return; // suppress redundant diagnostics
3826             switch (lint) {
3827                 case UNCHECKED:
3828                     Check.this.warnUnchecked(pos(), Warnings.ProbFoundReq(diags.fragment(uncheckedKey), found, expected));
3829                     break;
3830                 case VARARGS:
3831                     if (method != null &amp;&amp;
3832                             method.attribute(syms.trustMeType.tsym) != null &amp;&amp;
3833                             isTrustMeAllowedOnMethod(method) &amp;&amp;
3834                             !types.isReifiable(method.type.getParameterTypes().last())) {
3835                         Check.this.warnUnsafeVararg(pos(), Warnings.VarargsUnsafeUseVarargsParam(method.params.last()));
3836                     }
3837                     break;
3838                 default:
3839                     throw new AssertionError(&quot;Unexpected lint: &quot; + lint);
3840             }
3841         }
3842     }
3843 
3844     public Warner castWarner(DiagnosticPosition pos, Type found, Type expected) {
3845         return new ConversionWarner(pos, &quot;unchecked.cast.to.type&quot;, found, expected);
3846     }
3847 
3848     public Warner convertWarner(DiagnosticPosition pos, Type found, Type expected) {
3849         return new ConversionWarner(pos, &quot;unchecked.assign&quot;, found, expected);
3850     }
3851 
3852     public void checkFunctionalInterface(JCClassDecl tree, ClassSymbol cs) {
3853         Compound functionalType = cs.attribute(syms.functionalInterfaceType.tsym);
3854 
3855         if (functionalType != null) {
3856             try {
3857                 types.findDescriptorSymbol((TypeSymbol)cs);
3858             } catch (Types.FunctionDescriptorLookupError ex) {
3859                 DiagnosticPosition pos = tree.pos();
3860                 for (JCAnnotation a : tree.getModifiers().annotations) {
3861                     if (a.annotationType.type.tsym == syms.functionalInterfaceType.tsym) {
3862                         pos = a.pos();
3863                         break;
3864                     }
3865                 }
3866                 log.error(pos, Errors.BadFunctionalIntfAnno1(ex.getDiagnostic()));
3867             }
3868         }
3869     }
3870 
3871     public void checkImportsResolvable(final JCCompilationUnit toplevel) {
3872         for (final JCImport imp : toplevel.getImports()) {
3873             if (!imp.staticImport || !imp.qualid.hasTag(SELECT))
3874                 continue;
3875             final JCFieldAccess select = (JCFieldAccess) imp.qualid;
3876             final Symbol origin;
3877             if (select.name == names.asterisk || (origin = TreeInfo.symbol(select.selected)) == null || origin.kind != TYP)
3878                 continue;
3879 
3880             TypeSymbol site = (TypeSymbol) TreeInfo.symbol(select.selected);
3881             if (!checkTypeContainsImportableElement(site, site, toplevel.packge, select.name, new HashSet&lt;Symbol&gt;())) {
3882                 log.error(imp.pos(),
3883                           Errors.CantResolveLocation(KindName.STATIC,
3884                                                      select.name,
3885                                                      null,
3886                                                      null,
3887                                                      Fragments.Location(kindName(site),
3888                                                                         site,
3889                                                                         null)));
3890             }
3891         }
3892     }
3893 
3894     // Check that packages imported are in scope (JLS 7.4.3, 6.3, 6.5.3.1, 6.5.3.2)
3895     public void checkImportedPackagesObservable(final JCCompilationUnit toplevel) {
3896         OUTER: for (JCImport imp : toplevel.getImports()) {
3897             if (!imp.staticImport &amp;&amp; TreeInfo.name(imp.qualid) == names.asterisk) {
3898                 TypeSymbol tsym = ((JCFieldAccess)imp.qualid).selected.type.tsym;
3899                 if (tsym.kind == PCK &amp;&amp; tsym.members().isEmpty() &amp;&amp;
3900                     !(Feature.IMPORT_ON_DEMAND_OBSERVABLE_PACKAGES.allowedInSource(source) &amp;&amp; tsym.exists())) {
3901                     log.error(DiagnosticFlag.RESOLVE_ERROR, imp.pos, Errors.DoesntExist(tsym));
3902                 }
3903             }
3904         }
3905     }
3906 
3907     private boolean checkTypeContainsImportableElement(TypeSymbol tsym, TypeSymbol origin, PackageSymbol packge, Name name, Set&lt;Symbol&gt; processed) {
3908         if (tsym == null || !processed.add(tsym))
3909             return false;
3910 
3911             // also search through inherited names
3912         if (checkTypeContainsImportableElement(types.supertype(tsym.type).tsym, origin, packge, name, processed))
3913             return true;
3914 
3915         for (Type t : types.interfaces(tsym.type))
3916             if (checkTypeContainsImportableElement(t.tsym, origin, packge, name, processed))
3917                 return true;
3918 
3919         for (Symbol sym : tsym.members().getSymbolsByName(name)) {
3920             if (sym.isStatic() &amp;&amp;
3921                 importAccessible(sym, packge) &amp;&amp;
3922                 sym.isMemberOf(origin, types)) {
3923                 return true;
3924             }
3925         }
3926 
3927         return false;
3928     }
3929 
3930     // is the sym accessible everywhere in packge?
3931     public boolean importAccessible(Symbol sym, PackageSymbol packge) {
3932         try {
3933             int flags = (int)(sym.flags() &amp; AccessFlags);
3934             switch (flags) {
3935             default:
3936             case PUBLIC:
3937                 return true;
3938             case PRIVATE:
3939                 return false;
3940             case 0:
3941             case PROTECTED:
3942                 return sym.packge() == packge;
3943             }
3944         } catch (ClassFinder.BadClassFile err) {
3945             throw err;
3946         } catch (CompletionFailure ex) {
3947             return false;
3948         }
3949     }
3950 
3951     public void checkLeaksNotAccessible(Env&lt;AttrContext&gt; env, JCClassDecl check) {
3952         JCCompilationUnit toplevel = env.toplevel;
3953 
3954         if (   toplevel.modle == syms.unnamedModule
3955             || toplevel.modle == syms.noModule
3956             || (check.sym.flags() &amp; COMPOUND) != 0) {
3957             return ;
3958         }
3959 
3960         ExportsDirective currentExport = findExport(toplevel.packge);
3961 
3962         if (   currentExport == null //not exported
3963             || currentExport.modules != null) //don&#39;t check classes in qualified export
3964             return ;
3965 
3966         new TreeScanner() {
3967             Lint lint = env.info.lint;
3968             boolean inSuperType;
3969 
3970             @Override
3971             public void visitBlock(JCBlock tree) {
3972             }
3973             @Override
3974             public void visitMethodDef(JCMethodDecl tree) {
3975                 if (!isAPISymbol(tree.sym))
3976                     return;
3977                 Lint prevLint = lint;
3978                 try {
3979                     lint = lint.augment(tree.sym);
3980                     if (lint.isEnabled(LintCategory.EXPORTS)) {
3981                         super.visitMethodDef(tree);
3982                     }
3983                 } finally {
3984                     lint = prevLint;
3985                 }
3986             }
3987             @Override
3988             public void visitVarDef(JCVariableDecl tree) {
3989                 if (!isAPISymbol(tree.sym) &amp;&amp; tree.sym.owner.kind != MTH)
3990                     return;
3991                 Lint prevLint = lint;
3992                 try {
3993                     lint = lint.augment(tree.sym);
3994                     if (lint.isEnabled(LintCategory.EXPORTS)) {
3995                         scan(tree.mods);
3996                         scan(tree.vartype);
3997                     }
3998                 } finally {
3999                     lint = prevLint;
4000                 }
4001             }
4002             @Override
4003             public void visitClassDef(JCClassDecl tree) {
4004                 if (tree != check)
4005                     return ;
4006 
4007                 if (!isAPISymbol(tree.sym))
4008                     return ;
4009 
4010                 Lint prevLint = lint;
4011                 try {
4012                     lint = lint.augment(tree.sym);
4013                     if (lint.isEnabled(LintCategory.EXPORTS)) {
4014                         scan(tree.mods);
4015                         scan(tree.typarams);
4016                         try {
4017                             inSuperType = true;
4018                             scan(tree.extending);
4019                             scan(tree.implementing);
4020                         } finally {
4021                             inSuperType = false;
4022                         }
4023                         scan(tree.defs);
4024                     }
4025                 } finally {
4026                     lint = prevLint;
4027                 }
4028             }
4029             @Override
4030             public void visitTypeApply(JCTypeApply tree) {
4031                 scan(tree.clazz);
4032                 boolean oldInSuperType = inSuperType;
4033                 try {
4034                     inSuperType = false;
4035                     scan(tree.arguments);
4036                 } finally {
4037                     inSuperType = oldInSuperType;
4038                 }
4039             }
4040             @Override
4041             public void visitIdent(JCIdent tree) {
4042                 Symbol sym = TreeInfo.symbol(tree);
4043                 if (sym.kind == TYP &amp;&amp; !sym.type.hasTag(TYPEVAR)) {
4044                     checkVisible(tree.pos(), sym, toplevel.packge, inSuperType);
4045                 }
4046             }
4047 
4048             @Override
4049             public void visitSelect(JCFieldAccess tree) {
4050                 Symbol sym = TreeInfo.symbol(tree);
4051                 Symbol sitesym = TreeInfo.symbol(tree.selected);
4052                 if (sym.kind == TYP &amp;&amp; sitesym.kind == PCK) {
4053                     checkVisible(tree.pos(), sym, toplevel.packge, inSuperType);
4054                 } else {
4055                     super.visitSelect(tree);
4056                 }
4057             }
4058 
4059             @Override
4060             public void visitAnnotation(JCAnnotation tree) {
4061                 if (tree.attribute.type.tsym.getAnnotation(java.lang.annotation.Documented.class) != null)
4062                     super.visitAnnotation(tree);
4063             }
4064 
4065         }.scan(check);
4066     }
4067         //where:
4068         private ExportsDirective findExport(PackageSymbol pack) {
4069             for (ExportsDirective d : pack.modle.exports) {
4070                 if (d.packge == pack)
4071                     return d;
4072             }
4073 
4074             return null;
4075         }
4076         private boolean isAPISymbol(Symbol sym) {
4077             while (sym.kind != PCK) {
4078                 if ((sym.flags() &amp; Flags.PUBLIC) == 0 &amp;&amp; (sym.flags() &amp; Flags.PROTECTED) == 0) {
4079                     return false;
4080                 }
4081                 sym = sym.owner;
4082             }
4083             return true;
4084         }
4085         private void checkVisible(DiagnosticPosition pos, Symbol what, PackageSymbol inPackage, boolean inSuperType) {
4086             if (!isAPISymbol(what) &amp;&amp; !inSuperType) { //package private/private element
4087                 log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessible(kindName(what), what, what.packge().modle));
4088                 return ;
4089             }
4090 
4091             PackageSymbol whatPackage = what.packge();
4092             ExportsDirective whatExport = findExport(whatPackage);
4093             ExportsDirective inExport = findExport(inPackage);
4094 
4095             if (whatExport == null) { //package not exported:
4096                 log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessibleUnexported(kindName(what), what, what.packge().modle));
4097                 return ;
4098             }
4099 
4100             if (whatExport.modules != null) {
4101                 if (inExport.modules == null || !whatExport.modules.containsAll(inExport.modules)) {
4102                     log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessibleUnexportedQualified(kindName(what), what, what.packge().modle));
4103                 }
4104             }
4105 
4106             if (whatPackage.modle != inPackage.modle &amp;&amp; whatPackage.modle != syms.java_base) {
4107                 //check that relativeTo.modle requires transitive what.modle, somehow:
4108                 List&lt;ModuleSymbol&gt; todo = List.of(inPackage.modle);
4109 
4110                 while (todo.nonEmpty()) {
4111                     ModuleSymbol current = todo.head;
4112                     todo = todo.tail;
4113                     if (current == whatPackage.modle)
4114                         return ; //OK
4115                     if ((current.flags() &amp; Flags.AUTOMATIC_MODULE) != 0)
4116                         continue; //for automatic modules, don&#39;t look into their dependencies
4117                     for (RequiresDirective req : current.requires) {
4118                         if (req.isTransitive()) {
4119                             todo = todo.prepend(req.module);
4120                         }
4121                     }
4122                 }
4123 
4124                 log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessibleNotRequiredTransitive(kindName(what), what, what.packge().modle));
4125             }
4126         }
4127 
4128     void checkModuleExists(final DiagnosticPosition pos, ModuleSymbol msym) {
4129         if (msym.kind != MDL) {
4130             deferredLintHandler.report(() -&gt; {
4131                 if (lint.isEnabled(LintCategory.MODULE))
4132                     log.warning(LintCategory.MODULE, pos, Warnings.ModuleNotFound(msym));
4133             });
4134         }
4135     }
4136 
4137     void checkPackageExistsForOpens(final DiagnosticPosition pos, PackageSymbol packge) {
4138         if (packge.members().isEmpty() &amp;&amp;
4139             ((packge.flags() &amp; Flags.HAS_RESOURCE) == 0)) {
4140             deferredLintHandler.report(() -&gt; {
4141                 if (lint.isEnabled(LintCategory.OPENS))
4142                     log.warning(pos, Warnings.PackageEmptyOrNotFound(packge));
4143             });
4144         }
4145     }
4146 
4147     void checkModuleRequires(final DiagnosticPosition pos, final RequiresDirective rd) {
4148         if ((rd.module.flags() &amp; Flags.AUTOMATIC_MODULE) != 0) {
4149             deferredLintHandler.report(() -&gt; {
4150                 if (rd.isTransitive() &amp;&amp; lint.isEnabled(LintCategory.REQUIRES_TRANSITIVE_AUTOMATIC)) {
4151                     log.warning(pos, Warnings.RequiresTransitiveAutomatic);
4152                 } else if (lint.isEnabled(LintCategory.REQUIRES_AUTOMATIC)) {
4153                     log.warning(pos, Warnings.RequiresAutomatic);
4154                 }
4155             });
4156         }
4157     }
4158 
4159 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
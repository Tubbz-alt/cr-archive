<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/x509/AlgorithmId.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.x509;
  27 
  28 import java.io.*;
  29 import java.security.spec.AlgorithmParameterSpec;
  30 import java.security.spec.InvalidParameterSpecException;
  31 import java.security.spec.MGF1ParameterSpec;
  32 import java.security.spec.PSSParameterSpec;
  33 import java.util.*;
  34 import java.security.*;
  35 
  36 import sun.security.rsa.PSSParameters;
  37 import sun.security.util.*;
  38 
  39 
  40 /**
  41  * This class identifies algorithms, such as cryptographic transforms, each
  42  * of which may be associated with parameters.  Instances of this base class
  43  * are used when this runtime environment has no special knowledge of the
  44  * algorithm type, and may also be used in other cases.  Equivalence is
  45  * defined according to OID and (where relevant) parameters.
  46  *
  47  * &lt;P&gt;Subclasses may be used, for example when the algorithm ID has
  48  * associated parameters which some code (e.g. code using public keys) needs
  49  * to have parsed.  Two examples of such algorithms are Diffie-Hellman key
  50  * exchange, and the Digital Signature Standard Algorithm (DSS/DSA).
  51  *
  52  * &lt;P&gt;The OID constants defined in this class correspond to some widely
  53  * used algorithms, for which conventional string names have been defined.
  54  * This class is not a general repository for OIDs, or for such string names.
  55  * Note that the mappings between algorithm IDs and algorithm names is
  56  * not one-to-one.
  57  *
  58  *
  59  * @author David Brownell
  60  * @author Amit Kapoor
  61  * @author Hemma Prafullchandra
  62  */
  63 public class AlgorithmId implements Serializable, DerEncoder {
  64 
  65     /** use serialVersionUID from JDK 1.1. for interoperability */
  66     @java.io.Serial
  67     private static final long serialVersionUID = 7205873507486557157L;
  68 
  69     /**
  70      * The object identitifer being used for this algorithm.
  71      */
  72     private ObjectIdentifier algid;
  73 
  74     // The (parsed) parameters
  75     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable
  76     private AlgorithmParameters algParams;
  77     private boolean constructedFromDer = true;
  78 
  79     /**
  80      * Parameters for this algorithm.  These are stored in unparsed
  81      * DER-encoded form; subclasses can be made to automaticaly parse
  82      * them so there is fast access to these parameters.
  83      */
  84     @SuppressWarnings(&quot;serial&quot;) // Not statically typed as Serializable
  85     protected DerValue          params;
  86 
  87 
  88     /**
  89      * Constructs an algorithm ID which will be initialized
  90      * separately, for example by deserialization.
  91      * @deprecated use one of the other constructors.
  92      */
  93     @Deprecated
  94     public AlgorithmId() { }
  95 
  96     /**
  97      * Constructs a parameterless algorithm ID.
  98      *
  99      * @param oid the identifier for the algorithm
 100      */
 101     public AlgorithmId(ObjectIdentifier oid) {
 102         algid = oid;
 103     }
 104 
 105     /**
 106      * Constructs an algorithm ID with algorithm parameters.
 107      *
 108      * @param oid the identifier for the algorithm.
 109      * @param algparams the associated algorithm parameters.
 110      */
 111     public AlgorithmId(ObjectIdentifier oid, AlgorithmParameters algparams) {
 112         algid = oid;
 113         algParams = algparams;
 114         constructedFromDer = false;
 115     }
 116 
 117     private AlgorithmId(ObjectIdentifier oid, DerValue params)
 118             throws IOException {
 119         this.algid = oid;
 120         this.params = params;
 121         if (this.params != null) {
 122             decodeParams();
 123         }
 124     }
 125 
 126     protected void decodeParams() throws IOException {
 127         String algidString = algid.toString();
 128         try {
 129             algParams = AlgorithmParameters.getInstance(algidString);
 130         } catch (NoSuchAlgorithmException e) {
 131             /*
 132              * This algorithm parameter type is not supported, so we cannot
 133              * parse the parameters.
 134              */
 135             algParams = null;
 136             return;
 137         }
 138 
 139         // Decode (parse) the parameters
 140         algParams.init(params.toByteArray());
 141     }
 142 
 143     /**
 144      * Marshal a DER-encoded &quot;AlgorithmID&quot; sequence on the DER stream.
 145      */
 146     public final void encode(DerOutputStream out) throws IOException {
 147         derEncode(out);
 148     }
 149 
 150     /**
 151      * DER encode this object onto an output stream.
 152      * Implements the &lt;code&gt;DerEncoder&lt;/code&gt; interface.
 153      *
 154      * @param out
 155      * the output stream on which to write the DER encoding.
 156      *
 157      * @exception IOException on encoding error.
 158      */
 159     public void derEncode (OutputStream out) throws IOException {
 160         DerOutputStream bytes = new DerOutputStream();
 161         DerOutputStream tmp = new DerOutputStream();
 162 
 163         bytes.putOID(algid);
 164         // Setup params from algParams since no DER encoding is given
 165         if (constructedFromDer == false) {
 166             if (algParams != null) {
 167                 params = new DerValue(algParams.getEncoded());
 168             } else {
 169                 params = null;
 170             }
 171         }
 172         if (params == null) {
 173             // Changes backed out for compatibility with Solaris
 174 
 175             // Several AlgorithmId should omit the whole parameter part when
 176             // it&#39;s NULL. They are ---
 177             // RFC 3370 2.1: Implementations SHOULD generate SHA-1
 178             // AlgorithmIdentifiers with absent parameters.
 179             // RFC 3447 C1: When id-sha1, id-sha224, id-sha256, id-sha384 and
 180             // id-sha512 are used in an AlgorithmIdentifier the parameters
 181             // (which are optional) SHOULD be omitted.
 182             // RFC 3279 2.3.2: The id-dsa algorithm syntax includes optional
 183             // domain parameters... When omitted, the parameters component
 184             // MUST be omitted entirely
 185             // RFC 3370 3.1: When the id-dsa-with-sha1 algorithm identifier
 186             // is used, the AlgorithmIdentifier parameters field MUST be absent.
 187             /*if (
 188                 algid.equals((Object)SHA_oid) ||
 189                 algid.equals((Object)SHA224_oid) ||
 190                 algid.equals((Object)SHA256_oid) ||
 191                 algid.equals((Object)SHA384_oid) ||
 192                 algid.equals((Object)SHA512_oid) ||
 193                 algid.equals((Object)SHA512_224_oid) ||
 194                 algid.equals((Object)SHA512_256_oid) ||
 195                 algid.equals((Object)DSA_oid) ||
 196                 algid.equals((Object)sha1WithDSA_oid)) {
 197                 ; // no parameter part encoded
 198             } else {
 199                 bytes.putNull();
 200             }*/
 201             if (algid.equals(RSASSA_PSS_oid)) {
 202                 // RFC 4055 3.3: when an RSASSA-PSS key does not require
 203                 // parameter validation, field is absent.
 204             } else {
 205                 bytes.putNull();
 206             }
 207         } else {
 208             bytes.putDerValue(params);
 209         }
 210         tmp.write(DerValue.tag_Sequence, bytes);
 211         out.write(tmp.toByteArray());
 212     }
 213 
 214 
 215     /**
 216      * Returns the DER-encoded X.509 AlgorithmId as a byte array.
 217      */
 218     public final byte[] encode() throws IOException {
 219         DerOutputStream out = new DerOutputStream();
 220         derEncode(out);
 221         return out.toByteArray();
 222     }
 223 
 224     /**
 225      * Returns the ISO OID for this algorithm.  This is usually converted
 226      * to a string and used as part of an algorithm name, for example
 227      * &quot;OID.1.3.14.3.2.13&quot; style notation.  Use the &lt;code&gt;getName&lt;/code&gt;
 228      * call when you do not need to ensure cross-system portability
 229      * of algorithm names, or need a user friendly name.
 230      */
 231     public final ObjectIdentifier getOID () {
 232         return algid;
 233     }
 234 
 235     /**
 236      * Returns a name for the algorithm which may be more intelligible
 237      * to humans than the algorithm&#39;s OID, but which won&#39;t necessarily
 238      * be comprehensible on other systems.  For example, this might
 239      * return a name such as &quot;MD5withRSA&quot; for a signature algorithm on
 240      * some systems.  It also returns names like &quot;OID.1.2.3.4&quot;, when
 241      * no particular name for the algorithm is known.
 242      *
 243      * Note: for ecdsa-with-SHA2 plus hash algorithm (Ex: SHA-256), this method
 244      * returns the &quot;full&quot; signature algorithm (Ex: SHA256withECDSA) directly.
 245      */
 246     public String getName() {
 247         String algName = nameTable.get(algid);
 248         if (algName != null) {
 249             return algName;
 250         }
 251         if ((params != null) &amp;&amp; algid.equals((Object)specifiedWithECDSA_oid)) {
 252             try {
 253                 AlgorithmId paramsId =
 254                         AlgorithmId.parse(new DerValue(params.toByteArray()));
 255                 String paramsName = paramsId.getName();
 256                 algName = makeSigAlg(paramsName, &quot;EC&quot;);
 257             } catch (IOException e) {
 258                 // ignore
 259             }
 260         }
 261         return (algName == null) ? algid.toString() : algName;
 262     }
 263 
 264     public AlgorithmParameters getParameters() {
 265         return algParams;
 266     }
 267 
 268     /**
 269      * Returns the DER encoded parameter, which can then be
 270      * used to initialize java.security.AlgorithmParameters.
 271      *
 272      * Note: for ecdsa-with-SHA2 plus hash algorithm (Ex: SHA-256), this method
 273      * returns null because {@link #getName()} has already returned the &quot;full&quot;
 274      * signature algorithm (Ex: SHA256withECDSA).
 275      *
 276      * @return DER encoded parameters, or null not present.
 277      */
 278     public byte[] getEncodedParams() throws IOException {
 279         return (params == null || algid.equals(specifiedWithECDSA_oid))
 280                 ? null
 281                 : params.toByteArray();
 282     }
 283 
 284     /**
 285      * Returns true iff the argument indicates the same algorithm
 286      * with the same parameters.
 287      */
 288     public boolean equals(AlgorithmId other) {
 289         boolean paramsEqual = Objects.equals(other.params, params);
 290         return (algid.equals((Object)other.algid) &amp;&amp; paramsEqual);
 291     }
 292 
 293     /**
 294      * Compares this AlgorithmID to another.  If algorithm parameters are
 295      * available, they are compared.  Otherwise, just the object IDs
 296      * for the algorithm are compared.
 297      *
 298      * @param other preferably an AlgorithmId, else an ObjectIdentifier
 299      */
 300     public boolean equals(Object other) {
 301         if (this == other) {
 302             return true;
 303         }
 304         if (other instanceof AlgorithmId) {
 305             return equals((AlgorithmId) other);
 306         } else if (other instanceof ObjectIdentifier) {
 307             return equals((ObjectIdentifier) other);
 308         } else {
 309             return false;
 310         }
 311     }
 312 
 313     /**
 314      * Compares two algorithm IDs for equality.  Returns true iff
 315      * they are the same algorithm, ignoring algorithm parameters.
 316      */
 317     public final boolean equals(ObjectIdentifier id) {
 318         return algid.equals((Object)id);
 319     }
 320 
 321     /**
 322      * Returns a hashcode for this AlgorithmId.
 323      *
 324      * @return a hashcode for this AlgorithmId.
 325      */
 326     public int hashCode() {
 327         StringBuilder sbuf = new StringBuilder();
 328         sbuf.append(algid.toString());
 329         sbuf.append(paramsToString());
 330         return sbuf.toString().hashCode();
 331     }
 332 
 333     /**
 334      * Provides a human-readable description of the algorithm parameters.
 335      * This may be redefined by subclasses which parse those parameters.
 336      */
 337     protected String paramsToString() {
 338         if (params == null) {
 339             return &quot;&quot;;
 340         } else if (algParams != null) {
 341             return algParams.toString();
 342         } else {
 343             return &quot;, params unparsed&quot;;
 344         }
 345     }
 346 
 347     /**
 348      * Returns a string describing the algorithm and its parameters.
 349      */
 350     public String toString() {
 351         return getName() + paramsToString();
 352     }
 353 
 354     /**
 355      * Parse (unmarshal) an ID from a DER sequence input value.  This form
 356      * parsing might be used when expanding a value which has already been
 357      * partially unmarshaled as a set or sequence member.
 358      *
 359      * @exception IOException on error.
 360      * @param val the input value, which contains the algid and, if
 361      *          there are any parameters, those parameters.
 362      * @return an ID for the algorithm.  If the system is configured
 363      *          appropriately, this may be an instance of a class
 364      *          with some kind of special support for this algorithm.
 365      *          In that case, you may &quot;narrow&quot; the type of the ID.
 366      */
 367     public static AlgorithmId parse(DerValue val) throws IOException {
 368         if (val.tag != DerValue.tag_Sequence) {
 369             throw new IOException(&quot;algid parse error, not a sequence&quot;);
 370         }
 371 
 372         /*
 373          * Get the algorithm ID and any parameters.
 374          */
 375         ObjectIdentifier        algid;
 376         DerValue                params;
 377         DerInputStream          in = val.toDerInputStream();
 378 
 379         algid = in.getOID();
 380         if (in.available() == 0) {
 381             params = null;
 382         } else {
 383             params = in.getDerValue();
 384             if (params.tag == DerValue.tag_Null) {
 385                 if (params.length() != 0) {
 386                     throw new IOException(&quot;invalid NULL&quot;);
 387                 }
 388                 params = null;
 389             }
 390             if (in.available() != 0) {
 391                 throw new IOException(&quot;Invalid AlgorithmIdentifier: extra data&quot;);
 392             }
 393         }
 394 
 395         return new AlgorithmId(algid, params);
 396     }
 397 
 398     /**
 399      * Returns one of the algorithm IDs most commonly associated
 400      * with this algorithm name.
 401      *
 402      * @param algname the name being used
 403      * @deprecated use the short get form of this method.
 404      * @exception NoSuchAlgorithmException on error.
 405      */
 406     @Deprecated
 407     public static AlgorithmId getAlgorithmId(String algname)
 408             throws NoSuchAlgorithmException {
 409         return get(algname);
 410     }
 411 
 412     /**
 413      * Returns one of the algorithm IDs most commonly associated
 414      * with this algorithm name.
 415      *
 416      * @param algname the name being used
 417      * @exception NoSuchAlgorithmException on error.
 418      */
 419     public static AlgorithmId get(String algname)
 420             throws NoSuchAlgorithmException {
 421         ObjectIdentifier oid;
 422         try {
 423             oid = algOID(algname);
 424         } catch (IOException ioe) {
 425             throw new NoSuchAlgorithmException
 426                 (&quot;Invalid ObjectIdentifier &quot; + algname);
 427         }
 428 
 429         if (oid == null) {
 430             throw new NoSuchAlgorithmException
 431                 (&quot;unrecognized algorithm name: &quot; + algname);
 432         }
 433         return new AlgorithmId(oid);
 434     }
 435 
 436     /**
 437      * Returns one of the algorithm IDs most commonly associated
 438      * with this algorithm parameters.
 439      *
 440      * @param algparams the associated algorithm parameters.
 441      * @exception NoSuchAlgorithmException on error.
 442      */
 443     public static AlgorithmId get(AlgorithmParameters algparams)
 444             throws NoSuchAlgorithmException {
 445         ObjectIdentifier oid;
 446         String algname = algparams.getAlgorithm();
 447         try {
 448             oid = algOID(algname);
 449         } catch (IOException ioe) {
 450             throw new NoSuchAlgorithmException
 451                 (&quot;Invalid ObjectIdentifier &quot; + algname);
 452         }
 453         if (oid == null) {
 454             throw new NoSuchAlgorithmException
 455                 (&quot;unrecognized algorithm name: &quot; + algname);
 456         }
 457         return new AlgorithmId(oid, algparams);
 458     }
 459 
 460     /*
 461      * Translates from some common algorithm names to the
 462      * OID with which they&#39;re usually associated ... this mapping
 463      * is the reverse of the one below, except in those cases
 464      * where synonyms are supported or where a given algorithm
 465      * is commonly associated with multiple OIDs.
 466      *
 467      * XXX This method needs to be enhanced so that we can also pass the
 468      * scope of the algorithm name to it, e.g., the algorithm name &quot;DSA&quot;
 469      * may have a different OID when used as a &quot;Signature&quot; algorithm than when
 470      * used as a &quot;KeyPairGenerator&quot; algorithm.
 471      */
 472     private static ObjectIdentifier algOID(String name) throws IOException {
 473         // See if algname is in printable OID (&quot;dot-dot&quot;) notation
 474         if (name.indexOf(&#39;.&#39;) != -1) {
 475             if (name.startsWith(&quot;OID.&quot;)) {
 476                 return new ObjectIdentifier(name.substring(&quot;OID.&quot;.length()));
 477             } else {
 478                 return new ObjectIdentifier(name);
 479             }
 480         }
 481 
 482         // Digesting algorithms
 483         if (name.equalsIgnoreCase(&quot;MD5&quot;)) {
 484             return AlgorithmId.MD5_oid;
 485         }
 486         if (name.equalsIgnoreCase(&quot;MD2&quot;)) {
 487             return AlgorithmId.MD2_oid;
 488         }
 489         if (name.equalsIgnoreCase(&quot;SHA&quot;) || name.equalsIgnoreCase(&quot;SHA1&quot;)
 490             || name.equalsIgnoreCase(&quot;SHA-1&quot;)) {
 491             return AlgorithmId.SHA_oid;
 492         }
 493         if (name.equalsIgnoreCase(&quot;SHA-256&quot;) ||
 494             name.equalsIgnoreCase(&quot;SHA256&quot;)) {
 495             return AlgorithmId.SHA256_oid;
 496         }
 497         if (name.equalsIgnoreCase(&quot;SHA-384&quot;) ||
 498             name.equalsIgnoreCase(&quot;SHA384&quot;)) {
 499             return AlgorithmId.SHA384_oid;
 500         }
 501         if (name.equalsIgnoreCase(&quot;SHA-512&quot;) ||
 502             name.equalsIgnoreCase(&quot;SHA512&quot;)) {
 503             return AlgorithmId.SHA512_oid;
 504         }
 505         if (name.equalsIgnoreCase(&quot;SHA-224&quot;) ||
 506             name.equalsIgnoreCase(&quot;SHA224&quot;)) {
 507             return AlgorithmId.SHA224_oid;
 508         }
 509         if (name.equalsIgnoreCase(&quot;SHA-512/224&quot;) ||
 510             name.equalsIgnoreCase(&quot;SHA512/224&quot;)) {
 511             return AlgorithmId.SHA512_224_oid;
 512         }
 513         if (name.equalsIgnoreCase(&quot;SHA-512/256&quot;) ||
 514             name.equalsIgnoreCase(&quot;SHA512/256&quot;)) {
 515             return AlgorithmId.SHA512_256_oid;
 516         }
 517         // Various public key algorithms
 518         if (name.equalsIgnoreCase(&quot;RSA&quot;)) {
 519             return AlgorithmId.RSAEncryption_oid;
 520         }
 521         if (name.equalsIgnoreCase(&quot;RSASSA-PSS&quot;)) {
 522             return AlgorithmId.RSASSA_PSS_oid;
 523         }
 524         if (name.equalsIgnoreCase(&quot;RSAES-OAEP&quot;)) {
 525             return AlgorithmId.RSAES_OAEP_oid;
 526         }
 527         if (name.equalsIgnoreCase(&quot;Diffie-Hellman&quot;)
 528             || name.equalsIgnoreCase(&quot;DH&quot;)) {
 529             return AlgorithmId.DH_oid;
 530         }
 531         if (name.equalsIgnoreCase(&quot;DSA&quot;)) {
 532             return AlgorithmId.DSA_oid;
 533         }
 534         if (name.equalsIgnoreCase(&quot;EC&quot;)) {
 535             return EC_oid;
 536         }
 537         if (name.equalsIgnoreCase(&quot;ECDH&quot;)) {
 538             return AlgorithmId.ECDH_oid;
 539         }
 540 
 541         // Secret key algorithms
 542         if (name.equalsIgnoreCase(&quot;AES&quot;)) {
 543             return AlgorithmId.AES_oid;
 544         }
 545 
 546         // Common signature types
 547         if (name.equalsIgnoreCase(&quot;MD5withRSA&quot;)
 548             || name.equalsIgnoreCase(&quot;MD5/RSA&quot;)) {
 549             return AlgorithmId.md5WithRSAEncryption_oid;
 550         }
 551         if (name.equalsIgnoreCase(&quot;MD2withRSA&quot;)
 552             || name.equalsIgnoreCase(&quot;MD2/RSA&quot;)) {
 553             return AlgorithmId.md2WithRSAEncryption_oid;
 554         }
 555         if (name.equalsIgnoreCase(&quot;SHAwithDSA&quot;)
 556             || name.equalsIgnoreCase(&quot;SHA1withDSA&quot;)
 557             || name.equalsIgnoreCase(&quot;SHA/DSA&quot;)
 558             || name.equalsIgnoreCase(&quot;SHA1/DSA&quot;)
 559             || name.equalsIgnoreCase(&quot;DSAWithSHA1&quot;)
 560             || name.equalsIgnoreCase(&quot;DSS&quot;)
 561             || name.equalsIgnoreCase(&quot;SHA-1/DSA&quot;)) {
 562             return AlgorithmId.sha1WithDSA_oid;
 563         }
 564         if (name.equalsIgnoreCase(&quot;SHA224WithDSA&quot;)) {
 565             return AlgorithmId.sha224WithDSA_oid;
 566         }
 567         if (name.equalsIgnoreCase(&quot;SHA256WithDSA&quot;)) {
 568             return AlgorithmId.sha256WithDSA_oid;
 569         }
 570         if (name.equalsIgnoreCase(&quot;SHA1WithRSA&quot;)
 571             || name.equalsIgnoreCase(&quot;SHA1/RSA&quot;)) {
 572             return AlgorithmId.sha1WithRSAEncryption_oid;
 573         }
 574         if (name.equalsIgnoreCase(&quot;SHA1withECDSA&quot;)
 575                 || name.equalsIgnoreCase(&quot;ECDSA&quot;)) {
 576             return AlgorithmId.sha1WithECDSA_oid;
 577         }
 578         if (name.equalsIgnoreCase(&quot;SHA224withECDSA&quot;)) {
 579             return AlgorithmId.sha224WithECDSA_oid;
 580         }
 581         if (name.equalsIgnoreCase(&quot;SHA256withECDSA&quot;)) {
 582             return AlgorithmId.sha256WithECDSA_oid;
 583         }
 584         if (name.equalsIgnoreCase(&quot;SHA384withECDSA&quot;)) {
 585             return AlgorithmId.sha384WithECDSA_oid;
 586         }
 587         if (name.equalsIgnoreCase(&quot;SHA512withECDSA&quot;)) {
 588             return AlgorithmId.sha512WithECDSA_oid;
 589         }
 590 
 591         return oidTable().get(name.toUpperCase(Locale.ENGLISH));
 592     }
 593 
<a name="2" id="anc2"></a><span class="line-removed"> 594     private static ObjectIdentifier oid(int ... values) {</span>
<span class="line-removed"> 595         return ObjectIdentifier.newInternal(values);</span>
<span class="line-removed"> 596     }</span>
<span class="line-removed"> 597 </span>
 598     private static volatile Map&lt;String,ObjectIdentifier&gt; oidTable;
 599     private static final Map&lt;ObjectIdentifier,String&gt; nameTable;
 600 
 601     /** Returns the oidTable, lazily initializing it on first access. */
 602     private static Map&lt;String,ObjectIdentifier&gt; oidTable()
 603         throws IOException {
 604         // Double checked locking; safe because oidTable is volatile
 605         Map&lt;String,ObjectIdentifier&gt; tab;
 606         if ((tab = oidTable) == null) {
 607             synchronized (AlgorithmId.class) {
 608                 if ((tab = oidTable) == null)
 609                     oidTable = tab = computeOidTable();
 610             }
 611         }
 612         return tab;
 613     }
 614 
 615     /** Collects the algorithm names from the installed providers. */
 616     private static HashMap&lt;String,ObjectIdentifier&gt; computeOidTable()
 617         throws IOException {
 618         HashMap&lt;String,ObjectIdentifier&gt; tab = new HashMap&lt;&gt;();
 619         for (Provider provider : Security.getProviders()) {
 620             for (Object key : provider.keySet()) {
 621                 String alias = (String)key;
 622                 String upperCaseAlias = alias.toUpperCase(Locale.ENGLISH);
 623                 int index;
 624                 if (upperCaseAlias.startsWith(&quot;ALG.ALIAS&quot;) &amp;&amp;
 625                     (index=upperCaseAlias.indexOf(&quot;OID.&quot;, 0)) != -1) {
 626                     index += &quot;OID.&quot;.length();
 627                     if (index == alias.length()) {
 628                         // invalid alias entry
 629                         break;
 630                     }
 631                     String oidString = alias.substring(index);
 632                     String stdAlgName = provider.getProperty(alias);
 633                     if (stdAlgName != null) {
 634                         stdAlgName = stdAlgName.toUpperCase(Locale.ENGLISH);
 635                     }
 636                     if (stdAlgName != null &amp;&amp;
 637                         tab.get(stdAlgName) == null) {
 638                         tab.put(stdAlgName, new ObjectIdentifier(oidString));
 639                     }
 640                 }
 641             }
 642         }
 643         return tab;
 644     }
 645 
 646     /*****************************************************************/
 647 
 648     /*
 649      * HASHING ALGORITHMS
 650      */
 651 
 652     /**
 653      * Algorithm ID for the MD2 Message Digest Algorthm, from RFC 1319.
 654      * OID = 1.2.840.113549.2.2
 655      */
 656     public static final ObjectIdentifier MD2_oid =
<a name="3" id="anc3"></a><span class="line-modified"> 657     ObjectIdentifier.newInternal(new int[] {1, 2, 840, 113549, 2, 2});</span>
 658 
 659     /**
 660      * Algorithm ID for the MD5 Message Digest Algorthm, from RFC 1321.
 661      * OID = 1.2.840.113549.2.5
 662      */
 663     public static final ObjectIdentifier MD5_oid =
<a name="4" id="anc4"></a><span class="line-modified"> 664     ObjectIdentifier.newInternal(new int[] {1, 2, 840, 113549, 2, 5});</span>
 665 
 666     /**
 667      * Algorithm ID for the SHA1 Message Digest Algorithm, from FIPS 180-1.
 668      * This is sometimes called &quot;SHA&quot;, though that is often confusing since
 669      * many people refer to FIPS 180 (which has an error) as defining SHA.
 670      * OID = 1.3.14.3.2.26. Old SHA-0 OID: 1.3.14.3.2.18.
 671      */
 672     public static final ObjectIdentifier SHA_oid =
<a name="5" id="anc5"></a><span class="line-modified"> 673     ObjectIdentifier.newInternal(new int[] {1, 3, 14, 3, 2, 26});</span>
 674 
 675     public static final ObjectIdentifier SHA224_oid =
<a name="6" id="anc6"></a><span class="line-modified"> 676     ObjectIdentifier.newInternal(new int[] {2, 16, 840, 1, 101, 3, 4, 2, 4});</span>
 677 
 678     public static final ObjectIdentifier SHA256_oid =
<a name="7" id="anc7"></a><span class="line-modified"> 679     ObjectIdentifier.newInternal(new int[] {2, 16, 840, 1, 101, 3, 4, 2, 1});</span>
 680 
 681     public static final ObjectIdentifier SHA384_oid =
<a name="8" id="anc8"></a><span class="line-modified"> 682     ObjectIdentifier.newInternal(new int[] {2, 16, 840, 1, 101, 3, 4, 2, 2});</span>
 683 
 684     public static final ObjectIdentifier SHA512_oid =
<a name="9" id="anc9"></a><span class="line-modified"> 685     ObjectIdentifier.newInternal(new int[] {2, 16, 840, 1, 101, 3, 4, 2, 3});</span>
 686 
 687     public static final ObjectIdentifier SHA512_224_oid =
<a name="10" id="anc10"></a><span class="line-modified"> 688     ObjectIdentifier.newInternal(new int[] {2, 16, 840, 1, 101, 3, 4, 2, 5});</span>
 689 
 690     public static final ObjectIdentifier SHA512_256_oid =
<a name="11" id="anc11"></a><span class="line-modified"> 691     ObjectIdentifier.newInternal(new int[] {2, 16, 840, 1, 101, 3, 4, 2, 6});</span>
 692 
 693     /*
 694      * COMMON PUBLIC KEY TYPES
 695      */
<a name="12" id="anc12"></a><span class="line-removed"> 696     private static final int[] DH_data = { 1, 2, 840, 113549, 1, 3, 1 };</span>
<span class="line-removed"> 697     private static final int[] DH_PKIX_data = { 1, 2, 840, 10046, 2, 1 };</span>
<span class="line-removed"> 698     private static final int[] DSA_OIW_data = { 1, 3, 14, 3, 2, 12 };</span>
<span class="line-removed"> 699     private static final int[] DSA_PKIX_data = { 1, 2, 840, 10040, 4, 1 };</span>
<span class="line-removed"> 700     private static final int[] RSA_data = { 2, 5, 8, 1, 1 };</span>
<span class="line-removed"> 701 </span>
<span class="line-removed"> 702     public static final ObjectIdentifier DH_oid;</span>
<span class="line-removed"> 703     public static final ObjectIdentifier DH_PKIX_oid;</span>
<span class="line-removed"> 704     public static final ObjectIdentifier DSA_oid;</span>
<span class="line-removed"> 705     public static final ObjectIdentifier DSA_OIW_oid;</span>
<span class="line-removed"> 706     public static final ObjectIdentifier EC_oid = oid(1, 2, 840, 10045, 2, 1);</span>
<span class="line-removed"> 707     public static final ObjectIdentifier ECDH_oid = oid(1, 3, 132, 1, 12);</span>
<span class="line-removed"> 708     public static final ObjectIdentifier RSA_oid;</span>
<span class="line-removed"> 709     public static final ObjectIdentifier RSAEncryption_oid =</span>
<span class="line-removed"> 710                                             oid(1, 2, 840, 113549, 1, 1, 1);</span>
<span class="line-removed"> 711     public static final ObjectIdentifier RSAES_OAEP_oid =</span>
<span class="line-removed"> 712                                             oid(1, 2, 840, 113549, 1, 1, 7);</span>
<span class="line-removed"> 713     public static final ObjectIdentifier mgf1_oid =</span>
<span class="line-removed"> 714                                             oid(1, 2, 840, 113549, 1, 1, 8);</span>
<span class="line-removed"> 715     public static final ObjectIdentifier RSASSA_PSS_oid =</span>
<span class="line-removed"> 716                                             oid(1, 2, 840, 113549, 1, 1, 10);</span>
<span class="line-removed"> 717 </span>
<span class="line-removed"> 718     /*</span>
<span class="line-removed"> 719      * COMMON SECRET KEY TYPES</span>
<span class="line-removed"> 720      */</span>
<span class="line-removed"> 721     public static final ObjectIdentifier AES_oid =</span>
<span class="line-removed"> 722                                             oid(2, 16, 840, 1, 101, 3, 4, 1);</span>
<span class="line-removed"> 723 </span>
<span class="line-removed"> 724     /*</span>
<span class="line-removed"> 725      * COMMON SIGNATURE ALGORITHMS</span>
<span class="line-removed"> 726      */</span>
<span class="line-removed"> 727     private static final int[] md2WithRSAEncryption_data =</span>
<span class="line-removed"> 728                                        { 1, 2, 840, 113549, 1, 1, 2 };</span>
<span class="line-removed"> 729     private static final int[] md5WithRSAEncryption_data =</span>
<span class="line-removed"> 730                                        { 1, 2, 840, 113549, 1, 1, 4 };</span>
<span class="line-removed"> 731     private static final int[] sha1WithRSAEncryption_data =</span>
<span class="line-removed"> 732                                        { 1, 2, 840, 113549, 1, 1, 5 };</span>
<span class="line-removed"> 733     private static final int[] sha1WithRSAEncryption_OIW_data =</span>
<span class="line-removed"> 734                                        { 1, 3, 14, 3, 2, 29 };</span>
<span class="line-removed"> 735     private static final int[] sha224WithRSAEncryption_data =</span>
<span class="line-removed"> 736                                        { 1, 2, 840, 113549, 1, 1, 14 };</span>
<span class="line-removed"> 737     private static final int[] sha256WithRSAEncryption_data =</span>
<span class="line-removed"> 738                                        { 1, 2, 840, 113549, 1, 1, 11 };</span>
<span class="line-removed"> 739     private static final int[] sha384WithRSAEncryption_data =</span>
<span class="line-removed"> 740                                        { 1, 2, 840, 113549, 1, 1, 12 };</span>
<span class="line-removed"> 741     private static final int[] sha512WithRSAEncryption_data =</span>
<span class="line-removed"> 742                                        { 1, 2, 840, 113549, 1, 1, 13 };</span>
<span class="line-removed"> 743 </span>
<span class="line-removed"> 744     private static final int[] shaWithDSA_OIW_data =</span>
<span class="line-removed"> 745                                        { 1, 3, 14, 3, 2, 13 };</span>
<span class="line-removed"> 746     private static final int[] sha1WithDSA_OIW_data =</span>
<span class="line-removed"> 747                                        { 1, 3, 14, 3, 2, 27 };</span>
<span class="line-removed"> 748     private static final int[] dsaWithSHA1_PKIX_data =</span>
<span class="line-removed"> 749                                        { 1, 2, 840, 10040, 4, 3 };</span>
<span class="line-removed"> 750 </span>
<span class="line-removed"> 751     public static final ObjectIdentifier md2WithRSAEncryption_oid;</span>
<span class="line-removed"> 752     public static final ObjectIdentifier md5WithRSAEncryption_oid;</span>
<span class="line-removed"> 753     public static final ObjectIdentifier sha1WithRSAEncryption_oid;</span>
<span class="line-removed"> 754     public static final ObjectIdentifier sha1WithRSAEncryption_OIW_oid;</span>
<span class="line-removed"> 755     public static final ObjectIdentifier sha224WithRSAEncryption_oid;</span>
<span class="line-removed"> 756     public static final ObjectIdentifier sha256WithRSAEncryption_oid;</span>
<span class="line-removed"> 757     public static final ObjectIdentifier sha384WithRSAEncryption_oid;</span>
<span class="line-removed"> 758     public static final ObjectIdentifier sha512WithRSAEncryption_oid;</span>
<span class="line-removed"> 759     public static final ObjectIdentifier sha512_224WithRSAEncryption_oid =</span>
<span class="line-removed"> 760                                             oid(1, 2, 840, 113549, 1, 1, 15);</span>
<span class="line-removed"> 761     public static final ObjectIdentifier sha512_256WithRSAEncryption_oid =</span>
<span class="line-removed"> 762                                             oid(1, 2, 840, 113549, 1, 1, 16);;</span>
<span class="line-removed"> 763 </span>
<span class="line-removed"> 764     public static final ObjectIdentifier shaWithDSA_OIW_oid;</span>
<span class="line-removed"> 765     public static final ObjectIdentifier sha1WithDSA_OIW_oid;</span>
<span class="line-removed"> 766     public static final ObjectIdentifier sha1WithDSA_oid;</span>
<span class="line-removed"> 767     public static final ObjectIdentifier sha224WithDSA_oid =</span>
<span class="line-removed"> 768                                             oid(2, 16, 840, 1, 101, 3, 4, 3, 1);</span>
<span class="line-removed"> 769     public static final ObjectIdentifier sha256WithDSA_oid =</span>
<span class="line-removed"> 770                                             oid(2, 16, 840, 1, 101, 3, 4, 3, 2);</span>
<span class="line-removed"> 771 </span>
<span class="line-removed"> 772     public static final ObjectIdentifier sha1WithECDSA_oid =</span>
<span class="line-removed"> 773                                             oid(1, 2, 840, 10045, 4, 1);</span>
<span class="line-removed"> 774     public static final ObjectIdentifier sha224WithECDSA_oid =</span>
<span class="line-removed"> 775                                             oid(1, 2, 840, 10045, 4, 3, 1);</span>
<span class="line-removed"> 776     public static final ObjectIdentifier sha256WithECDSA_oid =</span>
<span class="line-removed"> 777                                             oid(1, 2, 840, 10045, 4, 3, 2);</span>
<span class="line-removed"> 778     public static final ObjectIdentifier sha384WithECDSA_oid =</span>
<span class="line-removed"> 779                                             oid(1, 2, 840, 10045, 4, 3, 3);</span>
<span class="line-removed"> 780     public static final ObjectIdentifier sha512WithECDSA_oid =</span>
<span class="line-removed"> 781                                             oid(1, 2, 840, 10045, 4, 3, 4);</span>
<span class="line-removed"> 782     public static final ObjectIdentifier specifiedWithECDSA_oid =</span>
<span class="line-removed"> 783                                             oid(1, 2, 840, 10045, 4, 3);</span>
<span class="line-removed"> 784 </span>
<span class="line-removed"> 785     /**</span>
<span class="line-removed"> 786      * Algorithm ID for the PBE encryption algorithms from PKCS#5 and</span>
<span class="line-removed"> 787      * PKCS#12.</span>
<span class="line-removed"> 788      */</span>
<span class="line-removed"> 789     public static final ObjectIdentifier pbeWithMD5AndDES_oid =</span>
<span class="line-removed"> 790         ObjectIdentifier.newInternal(new int[]{1, 2, 840, 113549, 1, 5, 3});</span>
<span class="line-removed"> 791     public static final ObjectIdentifier pbeWithMD5AndRC2_oid =</span>
<span class="line-removed"> 792         ObjectIdentifier.newInternal(new int[] {1, 2, 840, 113549, 1, 5, 6});</span>
<span class="line-removed"> 793     public static final ObjectIdentifier pbeWithSHA1AndDES_oid =</span>
<span class="line-removed"> 794         ObjectIdentifier.newInternal(new int[] {1, 2, 840, 113549, 1, 5, 10});</span>
<span class="line-removed"> 795     public static final ObjectIdentifier pbeWithSHA1AndRC2_oid =</span>
<span class="line-removed"> 796         ObjectIdentifier.newInternal(new int[] {1, 2, 840, 113549, 1, 5, 11});</span>
<span class="line-removed"> 797     public static ObjectIdentifier pbeWithSHA1AndRC4_128_oid =</span>
<span class="line-removed"> 798         ObjectIdentifier.newInternal(new int[] {1, 2, 840, 113549, 1, 12, 1, 1});</span>
<span class="line-removed"> 799     public static ObjectIdentifier pbeWithSHA1AndRC4_40_oid =</span>
<span class="line-removed"> 800         ObjectIdentifier.newInternal(new int[] {1, 2, 840, 113549, 1, 12, 1, 2});</span>
<span class="line-removed"> 801     public static ObjectIdentifier pbeWithSHA1AndDESede_oid =</span>
<span class="line-removed"> 802         ObjectIdentifier.newInternal(new int[] {1, 2, 840, 113549, 1, 12, 1, 3});</span>
<span class="line-removed"> 803     public static ObjectIdentifier pbeWithSHA1AndRC2_128_oid =</span>
<span class="line-removed"> 804         ObjectIdentifier.newInternal(new int[] {1, 2, 840, 113549, 1, 12, 1, 5});</span>
<span class="line-removed"> 805     public static ObjectIdentifier pbeWithSHA1AndRC2_40_oid =</span>
<span class="line-removed"> 806         ObjectIdentifier.newInternal(new int[] {1, 2, 840, 113549, 1, 12, 1, 6});</span>
<span class="line-removed"> 807 </span>
<span class="line-removed"> 808     static {</span>
 809     /*
 810      * Note the preferred OIDs are named simply with no &quot;OIW&quot; or
 811      * &quot;PKIX&quot; in them, even though they may point to data from these
 812      * specs; e.g. SHA_oid, DH_oid, DSA_oid, SHA1WithDSA_oid...
 813      */
 814     /**
 815      * Algorithm ID for Diffie Hellman Key agreement, from PKCS #3.
 816      * Parameters include public values P and G, and may optionally specify
 817      * the length of the private key X.  Alternatively, algorithm parameters
 818      * may be derived from another source such as a Certificate Authority&#39;s
 819      * certificate.
 820      * OID = 1.2.840.113549.1.3.1
 821      */
<a name="13" id="anc13"></a><span class="line-modified"> 822         DH_oid = ObjectIdentifier.newInternal(DH_data);</span>

 823 
 824     /**
 825      * Algorithm ID for the Diffie Hellman Key Agreement (DH), from RFC 3279.
 826      * Parameters may include public values P and G.
 827      * OID = 1.2.840.10046.2.1
 828      */
<a name="14" id="anc14"></a><span class="line-modified"> 829         DH_PKIX_oid = ObjectIdentifier.newInternal(DH_PKIX_data);</span>

 830 
 831     /**
 832      * Algorithm ID for the Digital Signing Algorithm (DSA), from the
 833      * NIST OIW Stable Agreements part 12.
 834      * Parameters may include public values P, Q, and G; or these may be
 835      * derived from
 836      * another source such as a Certificate Authority&#39;s certificate.
 837      * OID = 1.3.14.3.2.12
 838      */
<a name="15" id="anc15"></a><span class="line-modified"> 839         DSA_OIW_oid = ObjectIdentifier.newInternal(DSA_OIW_data);</span>

 840 
 841     /**
 842      * Algorithm ID for the Digital Signing Algorithm (DSA), from RFC 3279.
 843      * Parameters may include public values P, Q, and G; or these may be
 844      * derived from another source such as a Certificate Authority&#39;s
 845      * certificate.
 846      * OID = 1.2.840.10040.4.1
 847      */
<a name="16" id="anc16"></a><span class="line-modified"> 848         DSA_oid = ObjectIdentifier.newInternal(DSA_PKIX_data);</span>

 849 
 850     /**
 851      * Algorithm ID for RSA keys used for any purpose, as defined in X.509.
 852      * The algorithm parameter is a single value, the number of bits in the
 853      * public modulus.
 854      * OID = 2.5.8.1.1
 855      */
<a name="17" id="anc17"></a><span class="line-modified"> 856         RSA_oid = ObjectIdentifier.newInternal(RSA_data);</span>














 857 
<a name="18" id="anc18"></a>








 858     /**
 859      * Identifies a signing algorithm where an MD2 digest is encrypted
 860      * using an RSA private key; defined in PKCS #1.  Use of this
 861      * signing algorithm is discouraged due to MD2 vulnerabilities.
 862      * OID = 1.2.840.113549.1.1.2
 863      */
<a name="19" id="anc19"></a><span class="line-modified"> 864         md2WithRSAEncryption_oid =</span>
<span class="line-modified"> 865             ObjectIdentifier.newInternal(md2WithRSAEncryption_data);</span>
 866 
 867     /**
 868      * Identifies a signing algorithm where an MD5 digest is
 869      * encrypted using an RSA private key; defined in PKCS #1.
 870      * OID = 1.2.840.113549.1.1.4
 871      */
<a name="20" id="anc20"></a><span class="line-modified"> 872         md5WithRSAEncryption_oid =</span>
<span class="line-modified"> 873             ObjectIdentifier.newInternal(md5WithRSAEncryption_data);</span>
 874 
 875     /**
 876      * Identifies a signing algorithm where a SHA1 digest is
 877      * encrypted using an RSA private key; defined by RSA DSI.
 878      * OID = 1.2.840.113549.1.1.5
 879      */
<a name="21" id="anc21"></a><span class="line-modified"> 880         sha1WithRSAEncryption_oid =</span>
<span class="line-modified"> 881             ObjectIdentifier.newInternal(sha1WithRSAEncryption_data);</span>
 882 
 883     /**
 884      * Identifies a signing algorithm where a SHA1 digest is
 885      * encrypted using an RSA private key; defined in NIST OIW.
 886      * OID = 1.3.14.3.2.29
 887      */
<a name="22" id="anc22"></a><span class="line-modified"> 888         sha1WithRSAEncryption_OIW_oid =</span>
<span class="line-modified"> 889             ObjectIdentifier.newInternal(sha1WithRSAEncryption_OIW_data);</span>
 890 
 891     /**
 892      * Identifies a signing algorithm where a SHA224 digest is
 893      * encrypted using an RSA private key; defined by PKCS #1.
 894      * OID = 1.2.840.113549.1.1.14
 895      */
<a name="23" id="anc23"></a><span class="line-modified"> 896         sha224WithRSAEncryption_oid =</span>
<span class="line-modified"> 897             ObjectIdentifier.newInternal(sha224WithRSAEncryption_data);</span>
 898 
 899     /**
 900      * Identifies a signing algorithm where a SHA256 digest is
 901      * encrypted using an RSA private key; defined by PKCS #1.
 902      * OID = 1.2.840.113549.1.1.11
 903      */
<a name="24" id="anc24"></a><span class="line-modified"> 904         sha256WithRSAEncryption_oid =</span>
<span class="line-modified"> 905             ObjectIdentifier.newInternal(sha256WithRSAEncryption_data);</span>
 906 
 907     /**
 908      * Identifies a signing algorithm where a SHA384 digest is
 909      * encrypted using an RSA private key; defined by PKCS #1.
 910      * OID = 1.2.840.113549.1.1.12
 911      */
<a name="25" id="anc25"></a><span class="line-modified"> 912         sha384WithRSAEncryption_oid =</span>
<span class="line-modified"> 913             ObjectIdentifier.newInternal(sha384WithRSAEncryption_data);</span>
 914 
 915     /**
 916      * Identifies a signing algorithm where a SHA512 digest is
 917      * encrypted using an RSA private key; defined by PKCS #1.
 918      * OID = 1.2.840.113549.1.1.13
 919      */
<a name="26" id="anc26"></a><span class="line-modified"> 920         sha512WithRSAEncryption_oid =</span>
<span class="line-modified"> 921             ObjectIdentifier.newInternal(sha512WithRSAEncryption_data);</span>
 922 
 923     /**
 924      * Identifies the FIPS 186 &quot;Digital Signature Standard&quot; (DSS), where a
 925      * SHA digest is signed using the Digital Signing Algorithm (DSA).
 926      * This should not be used.
 927      * OID = 1.3.14.3.2.13
 928      */
<a name="27" id="anc27"></a><span class="line-modified"> 929         shaWithDSA_OIW_oid = ObjectIdentifier.newInternal(shaWithDSA_OIW_data);</span>

 930 
 931     /**
 932      * Identifies the FIPS 186 &quot;Digital Signature Standard&quot; (DSS), where a
 933      * SHA1 digest is signed using the Digital Signing Algorithm (DSA).
 934      * OID = 1.3.14.3.2.27
 935      */
<a name="28" id="anc28"></a><span class="line-modified"> 936         sha1WithDSA_OIW_oid = ObjectIdentifier.newInternal(sha1WithDSA_OIW_data);</span>

 937 
 938     /**
 939      * Identifies the FIPS 186 &quot;Digital Signature Standard&quot; (DSS), where a
 940      * SHA1 digest is signed using the Digital Signing Algorithm (DSA).
 941      * OID = 1.2.840.10040.4.3
 942      */
<a name="29" id="anc29"></a><span class="line-modified"> 943         sha1WithDSA_oid = ObjectIdentifier.newInternal(dsaWithSHA1_PKIX_data);</span>

 944 
<a name="30" id="anc30"></a>














































 945         nameTable = new HashMap&lt;&gt;();
 946         nameTable.put(MD5_oid, &quot;MD5&quot;);
 947         nameTable.put(MD2_oid, &quot;MD2&quot;);
 948         nameTable.put(SHA_oid, &quot;SHA-1&quot;);
 949         nameTable.put(SHA224_oid, &quot;SHA-224&quot;);
 950         nameTable.put(SHA256_oid, &quot;SHA-256&quot;);
 951         nameTable.put(SHA384_oid, &quot;SHA-384&quot;);
 952         nameTable.put(SHA512_oid, &quot;SHA-512&quot;);
 953         nameTable.put(SHA512_224_oid, &quot;SHA-512/224&quot;);
 954         nameTable.put(SHA512_256_oid, &quot;SHA-512/256&quot;);
 955         nameTable.put(RSAEncryption_oid, &quot;RSA&quot;);
 956         nameTable.put(RSA_oid, &quot;RSA&quot;);
 957         nameTable.put(DH_oid, &quot;Diffie-Hellman&quot;);
 958         nameTable.put(DH_PKIX_oid, &quot;Diffie-Hellman&quot;);
 959         nameTable.put(DSA_oid, &quot;DSA&quot;);
 960         nameTable.put(DSA_OIW_oid, &quot;DSA&quot;);
 961         nameTable.put(EC_oid, &quot;EC&quot;);
 962         nameTable.put(ECDH_oid, &quot;ECDH&quot;);
 963 
 964         nameTable.put(AES_oid, &quot;AES&quot;);
 965 
 966         nameTable.put(sha1WithECDSA_oid, &quot;SHA1withECDSA&quot;);
 967         nameTable.put(sha224WithECDSA_oid, &quot;SHA224withECDSA&quot;);
 968         nameTable.put(sha256WithECDSA_oid, &quot;SHA256withECDSA&quot;);
 969         nameTable.put(sha384WithECDSA_oid, &quot;SHA384withECDSA&quot;);
 970         nameTable.put(sha512WithECDSA_oid, &quot;SHA512withECDSA&quot;);
 971         nameTable.put(md5WithRSAEncryption_oid, &quot;MD5withRSA&quot;);
 972         nameTable.put(md2WithRSAEncryption_oid, &quot;MD2withRSA&quot;);
 973         nameTable.put(sha1WithDSA_oid, &quot;SHA1withDSA&quot;);
 974         nameTable.put(sha1WithDSA_OIW_oid, &quot;SHA1withDSA&quot;);
 975         nameTable.put(shaWithDSA_OIW_oid, &quot;SHA1withDSA&quot;);
 976         nameTable.put(sha224WithDSA_oid, &quot;SHA224withDSA&quot;);
 977         nameTable.put(sha256WithDSA_oid, &quot;SHA256withDSA&quot;);
 978         nameTable.put(sha1WithRSAEncryption_oid, &quot;SHA1withRSA&quot;);
 979         nameTable.put(sha1WithRSAEncryption_OIW_oid, &quot;SHA1withRSA&quot;);
 980         nameTable.put(sha224WithRSAEncryption_oid, &quot;SHA224withRSA&quot;);
 981         nameTable.put(sha256WithRSAEncryption_oid, &quot;SHA256withRSA&quot;);
 982         nameTable.put(sha384WithRSAEncryption_oid, &quot;SHA384withRSA&quot;);
 983         nameTable.put(sha512WithRSAEncryption_oid, &quot;SHA512withRSA&quot;);
 984         nameTable.put(sha512_224WithRSAEncryption_oid, &quot;SHA512/224withRSA&quot;);
 985         nameTable.put(sha512_256WithRSAEncryption_oid, &quot;SHA512/256withRSA&quot;);
 986         nameTable.put(RSASSA_PSS_oid, &quot;RSASSA-PSS&quot;);
 987         nameTable.put(RSAES_OAEP_oid, &quot;RSAES-OAEP&quot;);
 988 
 989         nameTable.put(pbeWithMD5AndDES_oid, &quot;PBEWithMD5AndDES&quot;);
 990         nameTable.put(pbeWithMD5AndRC2_oid, &quot;PBEWithMD5AndRC2&quot;);
 991         nameTable.put(pbeWithSHA1AndDES_oid, &quot;PBEWithSHA1AndDES&quot;);
 992         nameTable.put(pbeWithSHA1AndRC2_oid, &quot;PBEWithSHA1AndRC2&quot;);
 993         nameTable.put(pbeWithSHA1AndRC4_128_oid, &quot;PBEWithSHA1AndRC4_128&quot;);
 994         nameTable.put(pbeWithSHA1AndRC4_40_oid, &quot;PBEWithSHA1AndRC4_40&quot;);
 995         nameTable.put(pbeWithSHA1AndDESede_oid, &quot;PBEWithSHA1AndDESede&quot;);
 996         nameTable.put(pbeWithSHA1AndRC2_128_oid, &quot;PBEWithSHA1AndRC2_128&quot;);
 997         nameTable.put(pbeWithSHA1AndRC2_40_oid, &quot;PBEWithSHA1AndRC2_40&quot;);
 998     }
 999 
1000     /**
1001      * Creates a signature algorithm name from a digest algorithm
1002      * name and a encryption algorithm name.
1003      */
1004     public static String makeSigAlg(String digAlg, String encAlg) {
1005         digAlg = digAlg.replace(&quot;-&quot;, &quot;&quot;);
1006         if (encAlg.equalsIgnoreCase(&quot;EC&quot;)) encAlg = &quot;ECDSA&quot;;
1007 
1008         return digAlg + &quot;with&quot; + encAlg;
1009     }
1010 
1011     /**
1012      * Extracts the encryption algorithm name from a signature
1013      * algorithm name.
1014       */
1015     public static String getEncAlgFromSigAlg(String signatureAlgorithm) {
1016         signatureAlgorithm = signatureAlgorithm.toUpperCase(Locale.ENGLISH);
1017         int with = signatureAlgorithm.indexOf(&quot;WITH&quot;);
1018         String keyAlgorithm = null;
1019         if (with &gt; 0) {
1020             int and = signatureAlgorithm.indexOf(&quot;AND&quot;, with + 4);
1021             if (and &gt; 0) {
1022                 keyAlgorithm = signatureAlgorithm.substring(with + 4, and);
1023             } else {
1024                 keyAlgorithm = signatureAlgorithm.substring(with + 4);
1025             }
1026             if (keyAlgorithm.equalsIgnoreCase(&quot;ECDSA&quot;)) {
1027                 keyAlgorithm = &quot;EC&quot;;
1028             }
1029         }
1030         return keyAlgorithm;
1031     }
1032 
1033     /**
1034      * Extracts the digest algorithm name from a signature
1035      * algorithm name.
1036       */
1037     public static String getDigAlgFromSigAlg(String signatureAlgorithm) {
1038         signatureAlgorithm = signatureAlgorithm.toUpperCase(Locale.ENGLISH);
1039         int with = signatureAlgorithm.indexOf(&quot;WITH&quot;);
1040         if (with &gt; 0) {
1041             return signatureAlgorithm.substring(0, with);
1042         }
1043         return null;
1044     }
1045 
1046     /**
1047      * Checks if a signature algorithm matches a key algorithm, i.e. a
1048      * signature can be initialized with a key.
1049      *
1050      * @param kAlg must not be null
1051      * @param sAlg must not be null
1052      * @throws IllegalArgumentException if they do not match
1053      */
1054     public static void checkKeyAndSigAlgMatch(String kAlg, String sAlg) {
1055         String sAlgUp = sAlg.toUpperCase(Locale.US);
1056         if ((sAlgUp.endsWith(&quot;WITHRSA&quot;) &amp;&amp; !kAlg.equalsIgnoreCase(&quot;RSA&quot;)) ||
1057                 (sAlgUp.endsWith(&quot;WITHECDSA&quot;) &amp;&amp; !kAlg.equalsIgnoreCase(&quot;EC&quot;)) ||
1058                 (sAlgUp.endsWith(&quot;WITHDSA&quot;) &amp;&amp; !kAlg.equalsIgnoreCase(&quot;DSA&quot;))) {
1059             throw new IllegalArgumentException(
1060                     &quot;key algorithm not compatible with signature algorithm&quot;);
1061         }
1062     }
1063 
1064     /**
1065      * Returns the default signature algorithm for a private key. The digest
1066      * part might evolve with time. Remember to update the spec of
1067      * {@link jdk.security.jarsigner.JarSigner.Builder#getDefaultSignatureAlgorithm(PrivateKey)}
1068      * if updated.
1069      *
1070      * @param k cannot be null
1071      * @return the default alg, might be null if unsupported
1072      */
1073     public static String getDefaultSigAlgForKey(PrivateKey k) {
1074         switch (k.getAlgorithm().toUpperCase(Locale.ENGLISH)) {
1075             case &quot;EC&quot;:
1076                 return ecStrength(KeyUtil.getKeySize(k))
1077                     + &quot;withECDSA&quot;;
1078             case &quot;DSA&quot;:
1079                 return ifcFfcStrength(KeyUtil.getKeySize(k))
1080                     + &quot;withDSA&quot;;
1081             case &quot;RSA&quot;:
1082                 return ifcFfcStrength(KeyUtil.getKeySize(k))
1083                     + &quot;withRSA&quot;;
1084             default:
1085                 return null;
1086         }
1087     }
1088 
1089     // Most commonly used PSSParameterSpec and AlgorithmId
1090     private static class PSSParamsHolder {
1091 
1092         final static PSSParameterSpec PSS_256_SPEC = new PSSParameterSpec(
1093                 &quot;SHA-256&quot;, &quot;MGF1&quot;,
1094                 new MGF1ParameterSpec(&quot;SHA-256&quot;),
1095                 32, PSSParameterSpec.TRAILER_FIELD_BC);
1096         final static PSSParameterSpec PSS_384_SPEC = new PSSParameterSpec(
1097                 &quot;SHA-384&quot;, &quot;MGF1&quot;,
1098                 new MGF1ParameterSpec(&quot;SHA-384&quot;),
1099                 48, PSSParameterSpec.TRAILER_FIELD_BC);
1100         final static PSSParameterSpec PSS_512_SPEC = new PSSParameterSpec(
1101                 &quot;SHA-512&quot;, &quot;MGF1&quot;,
1102                 new MGF1ParameterSpec(&quot;SHA-512&quot;),
1103                 64, PSSParameterSpec.TRAILER_FIELD_BC);
1104 
1105         final static AlgorithmId PSS_256_ID;
1106         final static AlgorithmId PSS_384_ID;
1107         final static AlgorithmId PSS_512_ID;
1108 
1109         static {
1110             try {
1111                 PSS_256_ID = new AlgorithmId(RSASSA_PSS_oid,
1112                         new DerValue(PSSParameters.getEncoded(PSS_256_SPEC)));
1113                 PSS_384_ID = new AlgorithmId(RSASSA_PSS_oid,
1114                         new DerValue(PSSParameters.getEncoded(PSS_384_SPEC)));
1115                 PSS_512_ID = new AlgorithmId(RSASSA_PSS_oid,
1116                         new DerValue(PSSParameters.getEncoded(PSS_512_SPEC)));
1117             } catch (IOException e) {
1118                 throw new AssertionError(&quot;Should not happen&quot;, e);
1119             }
1120         }
1121     }
1122 
1123     public static AlgorithmId getWithParameterSpec(String algName,
1124             AlgorithmParameterSpec spec) throws NoSuchAlgorithmException {
1125 
1126         if (spec == null) {
1127             return AlgorithmId.get(algName);
1128         } else if (spec == PSSParamsHolder.PSS_256_SPEC) {
1129             return PSSParamsHolder.PSS_256_ID;
1130         } else if (spec == PSSParamsHolder.PSS_384_SPEC) {
1131             return PSSParamsHolder.PSS_384_ID;
1132         } else if (spec == PSSParamsHolder.PSS_512_SPEC) {
1133             return PSSParamsHolder.PSS_512_ID;
1134         } else {
1135             try {
1136                 AlgorithmParameters result =
1137                         AlgorithmParameters.getInstance(algName);
1138                 result.init(spec);
1139                 return get(result);
1140             } catch (InvalidParameterSpecException | NoSuchAlgorithmException e) {
1141                 throw new ProviderException(e);
1142             }
1143         }
1144     }
1145 
1146     public static PSSParameterSpec getDefaultAlgorithmParameterSpec(
1147             String sigAlg, PrivateKey k) {
1148         if (sigAlg.equalsIgnoreCase(&quot;RSASSA-PSS&quot;)) {
1149             switch (ifcFfcStrength(KeyUtil.getKeySize(k))) {
1150                 case &quot;SHA256&quot;:
1151                     return PSSParamsHolder.PSS_256_SPEC;
1152                 case &quot;SHA384&quot;:
1153                     return PSSParamsHolder.PSS_384_SPEC;
1154                 case &quot;SHA512&quot;:
1155                     return PSSParamsHolder.PSS_512_SPEC;
1156                 default:
1157                     throw new AssertionError(&quot;Should not happen&quot;);
1158             }
1159         } else {
1160             return null;
1161         }
1162     }
1163 
1164     // Values from SP800-57 part 1 rev 4 tables 2 and 3
1165     private static String ecStrength (int bitLength) {
1166         if (bitLength &gt;= 512) { // 256 bits of strength
1167             return &quot;SHA512&quot;;
1168         } else if (bitLength &gt;= 384) {  // 192 bits of strength
1169             return &quot;SHA384&quot;;
1170         } else { // 128 bits of strength and less
1171             return &quot;SHA256&quot;;
1172         }
1173     }
1174 
1175     // Same values for RSA and DSA
1176     private static String ifcFfcStrength (int bitLength) {
1177         if (bitLength &gt; 7680) { // 256 bits
1178             return &quot;SHA512&quot;;
1179         } else if (bitLength &gt; 3072) {  // 192 bits
1180             return &quot;SHA384&quot;;
1181         } else  { // 128 bits and less
1182             return &quot;SHA256&quot;;
1183         }
1184     }
1185 }
<a name="31" id="anc31"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="31" type="hidden" />
</body>
</html>
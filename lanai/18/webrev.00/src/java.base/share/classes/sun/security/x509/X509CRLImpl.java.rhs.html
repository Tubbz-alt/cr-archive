<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/x509/X509CRLImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.x509;
  27 
  28 import java.io.InputStream;
  29 import java.io.OutputStream;
  30 import java.io.IOException;
  31 import java.math.BigInteger;
  32 import java.security.cert.Certificate;
  33 import java.security.cert.X509CRL;
  34 import java.security.cert.X509Certificate;
  35 import java.security.cert.X509CRLEntry;
  36 import java.security.cert.CRLException;
  37 import java.security.*;
  38 import java.util.*;
  39 
  40 import javax.security.auth.x500.X500Principal;
  41 
  42 import sun.security.provider.X509Factory;
  43 import sun.security.util.*;
  44 
  45 /**
  46  * &lt;p&gt;
  47  * An implementation for X509 CRL (Certificate Revocation List).
  48  * &lt;p&gt;
  49  * The X.509 v2 CRL format is described below in ASN.1:
  50  * &lt;pre&gt;
  51  * CertificateList  ::=  SEQUENCE  {
  52  *     tbsCertList          TBSCertList,
  53  *     signatureAlgorithm   AlgorithmIdentifier,
  54  *     signature            BIT STRING  }
  55  * &lt;/pre&gt;
  56  * More information can be found in
  57  * &lt;a href=&quot;http://tools.ietf.org/html/rfc5280&quot;&gt;RFC 5280: Internet X.509
  58  * Public Key Infrastructure Certificate and CRL Profile&lt;/a&gt;.
  59  * &lt;p&gt;
  60  * The ASN.1 definition of &lt;code&gt;tbsCertList&lt;/code&gt; is:
  61  * &lt;pre&gt;
  62  * TBSCertList  ::=  SEQUENCE  {
  63  *     version                 Version OPTIONAL,
  64  *                             -- if present, must be v2
  65  *     signature               AlgorithmIdentifier,
  66  *     issuer                  Name,
  67  *     thisUpdate              ChoiceOfTime,
  68  *     nextUpdate              ChoiceOfTime OPTIONAL,
  69  *     revokedCertificates     SEQUENCE OF SEQUENCE  {
  70  *         userCertificate         CertificateSerialNumber,
  71  *         revocationDate          ChoiceOfTime,
  72  *         crlEntryExtensions      Extensions OPTIONAL
  73  *                                 -- if present, must be v2
  74  *         }  OPTIONAL,
  75  *     crlExtensions           [0]  EXPLICIT Extensions OPTIONAL
  76  *                                  -- if present, must be v2
  77  *     }
  78  * &lt;/pre&gt;
  79  *
  80  * @author Hemma Prafullchandra
  81  * @see X509CRL
  82  */
  83 public class X509CRLImpl extends X509CRL implements DerEncoder {
  84 
  85     // CRL data, and its envelope
  86     private byte[]      signedCRL = null; // DER encoded crl
  87     private byte[]      signature = null; // raw signature bits
  88     private byte[]      tbsCertList = null; // DER encoded &quot;to-be-signed&quot; CRL
  89     private AlgorithmId sigAlgId = null; // sig alg in CRL
  90 
  91     // crl information
  92     private int              version;
  93     private AlgorithmId      infoSigAlgId; // sig alg in &quot;to-be-signed&quot; crl
  94     private X500Name         issuer = null;
  95     private X500Principal    issuerPrincipal = null;
  96     private Date             thisUpdate = null;
  97     private Date             nextUpdate = null;
  98     private Map&lt;X509IssuerSerial,X509CRLEntry&gt; revokedMap = new TreeMap&lt;&gt;();
  99     private List&lt;X509CRLEntry&gt; revokedList = new LinkedList&lt;&gt;();
 100     private CRLExtensions    extensions = null;
 101     private static final boolean isExplicit = true;
<a name="2" id="anc2"></a>
 102 
 103     private boolean readOnly = false;
 104 
 105     /**
 106      * PublicKey that has previously been used to successfully verify
 107      * the signature of this CRL. Null if the CRL has not
 108      * yet been verified (successfully).
 109      */
 110     private PublicKey verifiedPublicKey;
 111     /**
 112      * If verifiedPublicKey is not null, name of the provider used to
 113      * successfully verify the signature of this CRL, or the
 114      * empty String if no provider was explicitly specified.
 115      */
 116     private String verifiedProvider;
 117 
 118     /**
 119      * Not to be used. As it would lead to cases of uninitialized
 120      * CRL objects.
 121      */
 122     private X509CRLImpl() { }
 123 
 124     /**
 125      * Unmarshals an X.509 CRL from its encoded form, parsing the encoded
 126      * bytes.  This form of constructor is used by agents which
 127      * need to examine and use CRL contents. Note that the buffer
 128      * must include only one CRL, and no &quot;garbage&quot; may be left at
 129      * the end.
 130      *
 131      * @param crlData the encoded bytes, with no trailing padding.
 132      * @exception CRLException on parsing errors.
 133      */
 134     public X509CRLImpl(byte[] crlData) throws CRLException {
 135         try {
 136             parse(new DerValue(crlData));
 137         } catch (IOException e) {
 138             signedCRL = null;
 139             throw new CRLException(&quot;Parsing error: &quot; + e.getMessage());
 140         }
 141     }
 142 
 143     /**
 144      * Unmarshals an X.509 CRL from an DER value.
 145      *
 146      * @param val a DER value holding at least one CRL
 147      * @exception CRLException on parsing errors.
 148      */
 149     public X509CRLImpl(DerValue val) throws CRLException {
 150         try {
 151             parse(val);
 152         } catch (IOException e) {
 153             signedCRL = null;
 154             throw new CRLException(&quot;Parsing error: &quot; + e.getMessage());
 155         }
 156     }
 157 
 158     /**
 159      * Unmarshals an X.509 CRL from an input stream. Only one CRL
 160      * is expected at the end of the input stream.
 161      *
 162      * @param inStrm an input stream holding at least one CRL
 163      * @exception CRLException on parsing errors.
 164      */
 165     public X509CRLImpl(InputStream inStrm) throws CRLException {
 166         try {
 167             parse(new DerValue(inStrm));
 168         } catch (IOException e) {
 169             signedCRL = null;
 170             throw new CRLException(&quot;Parsing error: &quot; + e.getMessage());
 171         }
 172     }
 173 
 174     /**
 175      * Initial CRL constructor, no revoked certs, and no extensions.
 176      *
 177      * @param issuer the name of the CA issuing this CRL.
 178      * @param thisDate the Date of this issue.
 179      * @param nextDate the Date of the next CRL.
 180      */
 181     public X509CRLImpl(X500Name issuer, Date thisDate, Date nextDate) {
 182         this.issuer = issuer;
 183         this.thisUpdate = thisDate;
 184         this.nextUpdate = nextDate;
 185     }
 186 
 187     /**
 188      * CRL constructor, revoked certs, no extensions.
 189      *
 190      * @param issuer the name of the CA issuing this CRL.
 191      * @param thisDate the Date of this issue.
 192      * @param nextDate the Date of the next CRL.
 193      * @param badCerts the array of CRL entries.
 194      *
 195      * @exception CRLException on parsing/construction errors.
 196      */
 197     public X509CRLImpl(X500Name issuer, Date thisDate, Date nextDate,
 198                        X509CRLEntry[] badCerts)
 199         throws CRLException
 200     {
 201         this.issuer = issuer;
 202         this.thisUpdate = thisDate;
 203         this.nextUpdate = nextDate;
 204         if (badCerts != null) {
 205             X500Principal crlIssuer = getIssuerX500Principal();
 206             X500Principal badCertIssuer = crlIssuer;
 207             for (int i = 0; i &lt; badCerts.length; i++) {
 208                 X509CRLEntryImpl badCert = (X509CRLEntryImpl)badCerts[i];
 209                 try {
 210                     badCertIssuer = getCertIssuer(badCert, badCertIssuer);
 211                 } catch (IOException ioe) {
 212                     throw new CRLException(ioe);
 213                 }
 214                 badCert.setCertificateIssuer(crlIssuer, badCertIssuer);
 215                 X509IssuerSerial issuerSerial = new X509IssuerSerial
 216                     (badCertIssuer, badCert.getSerialNumber());
 217                 this.revokedMap.put(issuerSerial, badCert);
 218                 this.revokedList.add(badCert);
 219                 if (badCert.hasExtensions()) {
 220                     this.version = 1;
 221                 }
 222             }
 223         }
 224     }
 225 
 226     /**
 227      * CRL constructor, revoked certs and extensions.
 228      *
 229      * @param issuer the name of the CA issuing this CRL.
 230      * @param thisDate the Date of this issue.
 231      * @param nextDate the Date of the next CRL.
 232      * @param badCerts the array of CRL entries.
 233      * @param crlExts the CRL extensions.
 234      *
 235      * @exception CRLException on parsing/construction errors.
 236      */
 237     public X509CRLImpl(X500Name issuer, Date thisDate, Date nextDate,
 238                X509CRLEntry[] badCerts, CRLExtensions crlExts)
 239         throws CRLException
 240     {
 241         this(issuer, thisDate, nextDate, badCerts);
 242         if (crlExts != null) {
 243             this.extensions = crlExts;
 244             this.version = 1;
 245         }
 246     }
 247 
 248     /**
 249      * Returned the encoding as an uncloned byte array. Callers must
 250      * guarantee that they neither modify it nor expose it to untrusted
 251      * code.
 252      */
 253     public byte[] getEncodedInternal() throws CRLException {
 254         if (signedCRL == null) {
 255             throw new CRLException(&quot;Null CRL to encode&quot;);
 256         }
 257         return signedCRL;
 258     }
 259 
 260     /**
 261      * Returns the ASN.1 DER encoded form of this CRL.
 262      *
 263      * @exception CRLException if an encoding error occurs.
 264      */
 265     public byte[] getEncoded() throws CRLException {
 266         return getEncodedInternal().clone();
 267     }
 268 
 269     /**
 270      * Encodes the &quot;to-be-signed&quot; CRL to the OutputStream.
 271      *
 272      * @param out the OutputStream to write to.
 273      * @exception CRLException on encoding errors.
 274      */
 275     public void encodeInfo(OutputStream out) throws CRLException {
 276         try {
 277             DerOutputStream tmp = new DerOutputStream();
 278             DerOutputStream rCerts = new DerOutputStream();
 279             DerOutputStream seq = new DerOutputStream();
 280 
 281             if (version != 0) // v2 crl encode version
 282                 tmp.putInteger(version);
 283             infoSigAlgId.encode(tmp);
 284             if ((version == 0) &amp;&amp; (issuer.toString() == null))
 285                 throw new CRLException(&quot;Null Issuer DN not allowed in v1 CRL&quot;);
 286             issuer.encode(tmp);
 287 
<a name="3" id="anc3"></a><span class="line-modified"> 288             if (thisUpdate.getTime() &lt; CertificateValidity.YR_2050)</span>
 289                 tmp.putUTCTime(thisUpdate);
 290             else
 291                 tmp.putGeneralizedTime(thisUpdate);
 292 
 293             if (nextUpdate != null) {
<a name="4" id="anc4"></a><span class="line-modified"> 294                 if (nextUpdate.getTime() &lt; CertificateValidity.YR_2050)</span>
 295                     tmp.putUTCTime(nextUpdate);
 296                 else
 297                     tmp.putGeneralizedTime(nextUpdate);
 298             }
 299 
 300             if (!revokedList.isEmpty()) {
 301                 for (X509CRLEntry entry : revokedList) {
 302                     ((X509CRLEntryImpl)entry).encode(rCerts);
 303                 }
 304                 tmp.write(DerValue.tag_Sequence, rCerts);
 305             }
 306 
 307             if (extensions != null)
 308                 extensions.encode(tmp, isExplicit);
 309 
 310             seq.write(DerValue.tag_Sequence, tmp);
 311 
 312             tbsCertList = seq.toByteArray();
 313             out.write(tbsCertList);
 314         } catch (IOException e) {
 315              throw new CRLException(&quot;Encoding error: &quot; + e.getMessage());
 316         }
 317     }
 318 
 319     /**
 320      * Verifies that this CRL was signed using the
 321      * private key that corresponds to the given public key.
 322      *
 323      * @param key the PublicKey used to carry out the verification.
 324      *
 325      * @exception NoSuchAlgorithmException on unsupported signature
 326      * algorithms.
 327      * @exception InvalidKeyException on incorrect key.
 328      * @exception NoSuchProviderException if there&#39;s no default provider.
 329      * @exception SignatureException on signature errors.
 330      * @exception CRLException on encoding errors.
 331      */
 332     public void verify(PublicKey key)
 333     throws CRLException, NoSuchAlgorithmException, InvalidKeyException,
 334            NoSuchProviderException, SignatureException {
 335         verify(key, &quot;&quot;);
 336     }
 337 
 338     /**
 339      * Verifies that this CRL was signed using the
 340      * private key that corresponds to the given public key,
 341      * and that the signature verification was computed by
 342      * the given provider.
 343      *
 344      * @param key the PublicKey used to carry out the verification.
 345      * @param sigProvider the name of the signature provider.
 346      *
 347      * @exception NoSuchAlgorithmException on unsupported signature
 348      * algorithms.
 349      * @exception InvalidKeyException on incorrect key.
 350      * @exception NoSuchProviderException on incorrect provider.
 351      * @exception SignatureException on signature errors.
 352      * @exception CRLException on encoding errors.
 353      */
 354     public synchronized void verify(PublicKey key, String sigProvider)
 355             throws CRLException, NoSuchAlgorithmException, InvalidKeyException,
 356             NoSuchProviderException, SignatureException {
 357 
 358         if (sigProvider == null) {
 359             sigProvider = &quot;&quot;;
 360         }
 361         if ((verifiedPublicKey != null) &amp;&amp; verifiedPublicKey.equals(key)) {
 362             // this CRL has already been successfully verified using
 363             // this public key. Make sure providers match, too.
 364             if (sigProvider.equals(verifiedProvider)) {
 365                 return;
 366             }
 367         }
 368         if (signedCRL == null) {
 369             throw new CRLException(&quot;Uninitialized CRL&quot;);
 370         }
 371         Signature   sigVerf = null;
 372         String sigName = sigAlgId.getName();
 373         if (sigProvider.isEmpty()) {
 374             sigVerf = Signature.getInstance(sigName);
 375         } else {
 376             sigVerf = Signature.getInstance(sigName, sigProvider);
 377         }
 378 
 379         try {
 380             SignatureUtil.initVerifyWithParam(sigVerf, key,
 381                 SignatureUtil.getParamSpec(sigName, getSigAlgParams()));
 382         } catch (ProviderException e) {
 383             throw new CRLException(e.getMessage(), e.getCause());
 384         } catch (InvalidAlgorithmParameterException e) {
 385             throw new CRLException(e);
 386         }
 387 
 388         if (tbsCertList == null) {
 389             throw new CRLException(&quot;Uninitialized CRL&quot;);
 390         }
 391 
 392         sigVerf.update(tbsCertList, 0, tbsCertList.length);
 393 
 394         if (!sigVerf.verify(signature)) {
 395             throw new SignatureException(&quot;Signature does not match.&quot;);
 396         }
 397         verifiedPublicKey = key;
 398         verifiedProvider = sigProvider;
 399     }
 400 
 401     /**
 402      * Verifies that this CRL was signed using the
 403      * private key that corresponds to the given public key,
 404      * and that the signature verification was computed by
 405      * the given provider. Note that the specified Provider object
 406      * does not have to be registered in the provider list.
 407      *
 408      * @param key the PublicKey used to carry out the verification.
 409      * @param sigProvider the signature provider.
 410      *
 411      * @exception NoSuchAlgorithmException on unsupported signature
 412      * algorithms.
 413      * @exception InvalidKeyException on incorrect key.
 414      * @exception SignatureException on signature errors.
 415      * @exception CRLException on encoding errors.
 416      */
 417     public synchronized void verify(PublicKey key, Provider sigProvider)
 418             throws CRLException, NoSuchAlgorithmException, InvalidKeyException,
 419             SignatureException {
 420 
 421         if (signedCRL == null) {
 422             throw new CRLException(&quot;Uninitialized CRL&quot;);
 423         }
 424         Signature sigVerf = null;
 425         String sigName = sigAlgId.getName();
 426         if (sigProvider == null) {
 427             sigVerf = Signature.getInstance(sigName);
 428         } else {
 429             sigVerf = Signature.getInstance(sigName, sigProvider);
 430         }
 431 
 432         try {
 433             SignatureUtil.initVerifyWithParam(sigVerf, key,
 434                 SignatureUtil.getParamSpec(sigName, getSigAlgParams()));
 435         } catch (ProviderException e) {
 436             throw new CRLException(e.getMessage(), e.getCause());
 437         } catch (InvalidAlgorithmParameterException e) {
 438             throw new CRLException(e);
 439         }
 440 
 441         if (tbsCertList == null) {
 442             throw new CRLException(&quot;Uninitialized CRL&quot;);
 443         }
 444 
 445         sigVerf.update(tbsCertList, 0, tbsCertList.length);
 446 
 447         if (!sigVerf.verify(signature)) {
 448             throw new SignatureException(&quot;Signature does not match.&quot;);
 449         }
 450         verifiedPublicKey = key;
 451     }
 452 
 453     /**
 454      * Encodes an X.509 CRL, and signs it using the given key.
 455      *
 456      * @param key the private key used for signing.
 457      * @param algorithm the name of the signature algorithm used.
 458      *
 459      * @exception NoSuchAlgorithmException on unsupported signature
 460      * algorithms.
 461      * @exception InvalidKeyException on incorrect key.
 462      * @exception NoSuchProviderException on incorrect provider.
 463      * @exception SignatureException on signature errors.
 464      * @exception CRLException if any mandatory data was omitted.
 465      */
 466     public void sign(PrivateKey key, String algorithm)
 467     throws CRLException, NoSuchAlgorithmException, InvalidKeyException,
 468         NoSuchProviderException, SignatureException {
 469         sign(key, algorithm, null);
 470     }
 471 
 472     /**
 473      * Encodes an X.509 CRL, and signs it using the given key.
 474      *
 475      * @param key the private key used for signing.
 476      * @param algorithm the name of the signature algorithm used.
 477      * @param provider the name of the provider.
 478      *
 479      * @exception NoSuchAlgorithmException on unsupported signature
 480      * algorithms.
 481      * @exception InvalidKeyException on incorrect key.
 482      * @exception NoSuchProviderException on incorrect provider.
 483      * @exception SignatureException on signature errors.
 484      * @exception CRLException if any mandatory data was omitted.
 485      */
 486     public void sign(PrivateKey key, String algorithm, String provider)
 487     throws CRLException, NoSuchAlgorithmException, InvalidKeyException,
 488         NoSuchProviderException, SignatureException {
 489         try {
 490             if (readOnly)
 491                 throw new CRLException(&quot;cannot over-write existing CRL&quot;);
 492             Signature sigEngine = null;
 493             if (provider == null || provider.isEmpty())
 494                 sigEngine = Signature.getInstance(algorithm);
 495             else
 496                 sigEngine = Signature.getInstance(algorithm, provider);
 497 
 498             sigEngine.initSign(key);
 499 
 500             // in case the name is reset
 501             sigAlgId = AlgorithmId.get(sigEngine.getAlgorithm());
 502             infoSigAlgId = sigAlgId;
 503 
 504             DerOutputStream out = new DerOutputStream();
 505             DerOutputStream tmp = new DerOutputStream();
 506 
 507             // encode crl info
 508             encodeInfo(tmp);
 509 
 510             // encode algorithm identifier
 511             sigAlgId.encode(tmp);
 512 
 513             // Create and encode the signature itself.
 514             sigEngine.update(tbsCertList, 0, tbsCertList.length);
 515             signature = sigEngine.sign();
 516             tmp.putBitString(signature);
 517 
 518             // Wrap the signed data in a SEQUENCE { data, algorithm, sig }
 519             out.write(DerValue.tag_Sequence, tmp);
 520             signedCRL = out.toByteArray();
 521             readOnly = true;
 522 
 523         } catch (IOException e) {
 524             throw new CRLException(&quot;Error while encoding data: &quot; +
 525                                    e.getMessage());
 526         }
 527     }
 528 
 529     /**
 530      * Returns a printable string of this CRL.
 531      *
 532      * @return value of this CRL in a printable form.
 533      */
 534     public String toString() {
 535         return toStringWithAlgName(&quot;&quot; + sigAlgId);
 536     }
 537 
 538     // Specifically created for keytool to append a (weak) label to sigAlg
 539     public String toStringWithAlgName(String name) {
 540         StringBuilder sb = new StringBuilder();
 541         sb.append(&quot;X.509 CRL v&quot;)
 542             .append(version+1)
 543             .append(&#39;\n&#39;);
 544         if (sigAlgId != null)
 545             sb.append(&quot;Signature Algorithm: &quot;)
 546                 .append(name)
 547                 .append(&quot;, OID=&quot;)
 548                 .append(sigAlgId.getOID())
 549                 .append(&#39;\n&#39;);
 550         if (issuer != null)
 551             sb.append(&quot;Issuer: &quot;)
 552                 .append(issuer)
 553                 .append(&#39;\n&#39;);
 554         if (thisUpdate != null)
 555             sb.append(&quot;\nThis Update: &quot;)
 556                 .append(thisUpdate)
 557                 .append(&#39;\n&#39;);
 558         if (nextUpdate != null)
 559             sb.append(&quot;Next Update: &quot;)
 560                 .append(nextUpdate)
 561                 .append(&#39;\n&#39;);
 562         if (revokedList.isEmpty())
 563             sb.append(&quot;\nNO certificates have been revoked\n&quot;);
 564         else {
 565             sb.append(&quot;\nRevoked Certificates: &quot;)
 566                 .append(revokedList.size());
 567             int i = 1;
 568             for (X509CRLEntry entry: revokedList) {
 569                 sb.append(&quot;\n[&quot;)
 570                     .append(i++)
 571                     .append(&quot;] &quot;)
 572                     .append(entry);
 573             }
 574         }
 575         if (extensions != null) {
 576             Collection&lt;Extension&gt; allExts = extensions.getAllExtensions();
 577             Object[] objs = allExts.toArray();
 578             sb.append(&quot;\nCRL Extensions: &quot;)
 579                 .append(objs.length);
 580             for (int i = 0; i &lt; objs.length; i++) {
 581                 sb.append(&quot;\n[&quot;).append(i+1).append(&quot;]: &quot;);
 582                 Extension ext = (Extension)objs[i];
 583                 try {
 584                     if (OIDMap.getClass(ext.getExtensionId()) == null) {
 585                         sb.append(ext);
 586                         byte[] extValue = ext.getExtensionValue();
 587                         if (extValue != null) {
 588                             DerOutputStream out = new DerOutputStream();
 589                             out.putOctetString(extValue);
 590                             extValue = out.toByteArray();
 591                             HexDumpEncoder enc = new HexDumpEncoder();
 592                             sb.append(&quot;Extension unknown: &quot;)
 593                                 .append(&quot;DER encoded OCTET string =\n&quot;)
 594                                 .append(enc.encodeBuffer(extValue))
 595                                 .append(&#39;\n&#39;);
 596                         }
 597                     } else {
 598                         sb.append(ext); // sub-class exists
 599                     }
 600                 } catch (Exception e) {
 601                     sb.append(&quot;, Error parsing this extension&quot;);
 602                 }
 603             }
 604         }
 605         if (signature != null) {
 606             HexDumpEncoder encoder = new HexDumpEncoder();
 607             sb.append(&quot;\nSignature:\n&quot;)
 608                 .append(encoder.encodeBuffer(signature))
 609                 .append(&#39;\n&#39;);
 610         } else {
 611             sb.append(&quot;NOT signed yet\n&quot;);
 612         }
 613         return sb.toString();
 614     }
 615 
 616     /**
 617      * Checks whether the given certificate is on this CRL.
 618      *
 619      * @param cert the certificate to check for.
 620      * @return true if the given certificate is on this CRL,
 621      * false otherwise.
 622      */
 623     public boolean isRevoked(Certificate cert) {
 624         if (revokedMap.isEmpty() || (!(cert instanceof X509Certificate))) {
 625             return false;
 626         }
 627         X509Certificate xcert = (X509Certificate) cert;
 628         X509IssuerSerial issuerSerial = new X509IssuerSerial(xcert);
 629         return revokedMap.containsKey(issuerSerial);
 630     }
 631 
 632     /**
 633      * Gets the version number from this CRL.
 634      * The ASN.1 definition for this is:
 635      * &lt;pre&gt;
 636      * Version  ::=  INTEGER  {  v1(0), v2(1), v3(2)  }
 637      *             -- v3 does not apply to CRLs but appears for consistency
 638      *             -- with definition of Version for certs
 639      * &lt;/pre&gt;
 640      * @return the version number, i.e. 1 or 2.
 641      */
 642     public int getVersion() {
 643         return version+1;
 644     }
 645 
 646     /**
 647      * Gets the issuer distinguished name from this CRL.
 648      * The issuer name identifies the entity who has signed (and
 649      * issued the CRL). The issuer name field contains an
 650      * X.500 distinguished name (DN).
 651      * The ASN.1 definition for this is:
 652      * &lt;pre&gt;
 653      * issuer    Name
 654      *
 655      * Name ::= CHOICE { RDNSequence }
 656      * RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
 657      * RelativeDistinguishedName ::=
 658      *     SET OF AttributeValueAssertion
 659      *
 660      * AttributeValueAssertion ::= SEQUENCE {
 661      *                               AttributeType,
 662      *                               AttributeValue }
 663      * AttributeType ::= OBJECT IDENTIFIER
 664      * AttributeValue ::= ANY
 665      * &lt;/pre&gt;
 666      * The Name describes a hierarchical name composed of attributes,
 667      * such as country name, and corresponding values, such as US.
 668      * The type of the component AttributeValue is determined by the
 669      * AttributeType; in general it will be a directoryString.
 670      * A directoryString is usually one of PrintableString,
 671      * TeletexString or UniversalString.
 672      * @return the issuer name.
 673      */
 674     public Principal getIssuerDN() {
 675         return (Principal)issuer;
 676     }
 677 
 678     /**
 679      * Return the issuer as X500Principal. Overrides method in X509CRL
 680      * to provide a slightly more efficient version.
 681      */
 682     public X500Principal getIssuerX500Principal() {
 683         if (issuerPrincipal == null) {
 684             issuerPrincipal = issuer.asX500Principal();
 685         }
 686         return issuerPrincipal;
 687     }
 688 
 689     /**
 690      * Gets the thisUpdate date from the CRL.
 691      * The ASN.1 definition for this is:
 692      *
 693      * @return the thisUpdate date from the CRL.
 694      */
 695     public Date getThisUpdate() {
 696         return (new Date(thisUpdate.getTime()));
 697     }
 698 
 699     /**
 700      * Gets the nextUpdate date from the CRL.
 701      *
 702      * @return the nextUpdate date from the CRL, or null if
 703      * not present.
 704      */
 705     public Date getNextUpdate() {
 706         if (nextUpdate == null)
 707             return null;
 708         return (new Date(nextUpdate.getTime()));
 709     }
 710 
 711     /**
 712      * Gets the CRL entry with the given serial number from this CRL.
 713      *
 714      * @return the entry with the given serial number, or &lt;code&gt;null&lt;/code&gt; if
 715      * no such entry exists in the CRL.
 716      * @see X509CRLEntry
 717      */
 718     public X509CRLEntry getRevokedCertificate(BigInteger serialNumber) {
 719         if (revokedMap.isEmpty()) {
 720             return null;
 721         }
 722         // assume this is a direct CRL entry (cert and CRL issuer are the same)
 723         X509IssuerSerial issuerSerial = new X509IssuerSerial
 724             (getIssuerX500Principal(), serialNumber);
 725         return revokedMap.get(issuerSerial);
 726     }
 727 
 728     /**
 729      * Gets the CRL entry for the given certificate.
 730      */
 731     public X509CRLEntry getRevokedCertificate(X509Certificate cert) {
 732         if (revokedMap.isEmpty()) {
 733             return null;
 734         }
 735         X509IssuerSerial issuerSerial = new X509IssuerSerial(cert);
 736         return revokedMap.get(issuerSerial);
 737     }
 738 
 739     /**
 740      * Gets all the revoked certificates from the CRL.
 741      * A Set of X509CRLEntry.
 742      *
 743      * @return all the revoked certificates or &lt;code&gt;null&lt;/code&gt; if there are
 744      * none.
 745      * @see X509CRLEntry
 746      */
 747     public Set&lt;X509CRLEntry&gt; getRevokedCertificates() {
 748         if (revokedList.isEmpty()) {
 749             return null;
 750         } else {
 751             return new TreeSet&lt;X509CRLEntry&gt;(revokedList);
 752         }
 753     }
 754 
 755     /**
 756      * Gets the DER encoded CRL information, the
 757      * &lt;code&gt;tbsCertList&lt;/code&gt; from this CRL.
 758      * This can be used to verify the signature independently.
 759      *
 760      * @return the DER encoded CRL information.
 761      * @exception CRLException on encoding errors.
 762      */
 763     public byte[] getTBSCertList() throws CRLException {
 764         if (tbsCertList == null)
 765             throw new CRLException(&quot;Uninitialized CRL&quot;);
 766         return tbsCertList.clone();
 767     }
 768 
 769     /**
 770      * Gets the raw Signature bits from the CRL.
 771      *
 772      * @return the signature.
 773      */
 774     public byte[] getSignature() {
 775         if (signature == null)
 776             return null;
 777         return signature.clone();
 778     }
 779 
 780     /**
 781      * Gets the signature algorithm name for the CRL
 782      * signature algorithm. For example, the string &quot;SHA1withDSA&quot;.
 783      * The ASN.1 definition for this is:
 784      * &lt;pre&gt;
 785      * AlgorithmIdentifier  ::=  SEQUENCE  {
 786      *     algorithm               OBJECT IDENTIFIER,
 787      *     parameters              ANY DEFINED BY algorithm OPTIONAL  }
 788      *                             -- contains a value of the type
 789      *                             -- registered for use with the
 790      *                             -- algorithm object identifier value
 791      * &lt;/pre&gt;
 792      *
 793      * @return the signature algorithm name.
 794      */
 795     public String getSigAlgName() {
 796         if (sigAlgId == null)
 797             return null;
 798         return sigAlgId.getName();
 799     }
 800 
 801     /**
 802      * Gets the signature algorithm OID string from the CRL.
 803      * An OID is represented by a set of positive whole number separated
 804      * by &quot;.&quot;, that means,&lt;br&gt;
 805      * &amp;lt;positive whole number&amp;gt;.&amp;lt;positive whole number&amp;gt;.&amp;lt;...&amp;gt;
 806      * For example, the string &quot;1.2.840.10040.4.3&quot; identifies the SHA-1
 807      * with DSA signature algorithm defined in
 808      * &lt;a href=&quot;http://www.ietf.org/rfc/rfc3279.txt&quot;&gt;RFC 3279: Algorithms and
 809      * Identifiers for the Internet X.509 Public Key Infrastructure Certificate
 810      * and CRL Profile&lt;/a&gt;.
 811      *
 812      * @return the signature algorithm oid string.
 813      */
 814     public String getSigAlgOID() {
 815         if (sigAlgId == null)
 816             return null;
 817         ObjectIdentifier oid = sigAlgId.getOID();
 818         return oid.toString();
 819     }
 820 
 821     /**
 822      * Gets the DER encoded signature algorithm parameters from this
 823      * CRL&#39;s signature algorithm. In most cases, the signature
 824      * algorithm parameters are null, the parameters are usually
 825      * supplied with the Public Key.
 826      *
 827      * @return the DER encoded signature algorithm parameters, or
 828      *         null if no parameters are present.
 829      */
 830     public byte[] getSigAlgParams() {
 831         if (sigAlgId == null)
 832             return null;
 833         try {
 834             return sigAlgId.getEncodedParams();
 835         } catch (IOException e) {
 836             return null;
 837         }
 838     }
 839 
 840     /**
 841      * Gets the signature AlgorithmId from the CRL.
 842      *
 843      * @return the signature AlgorithmId
 844      */
 845     public AlgorithmId getSigAlgId() {
 846         return sigAlgId;
 847     }
 848 
 849     /**
 850      * return the AuthorityKeyIdentifier, if any.
 851      *
 852      * @return AuthorityKeyIdentifier or null
 853      *         (if no AuthorityKeyIdentifierExtension)
 854      * @throws IOException on error
 855      */
 856     public KeyIdentifier getAuthKeyId() throws IOException {
 857         AuthorityKeyIdentifierExtension aki = getAuthKeyIdExtension();
 858         if (aki != null) {
 859             KeyIdentifier keyId = (KeyIdentifier)aki.get(
 860                     AuthorityKeyIdentifierExtension.KEY_ID);
 861             return keyId;
 862         } else {
 863             return null;
 864         }
 865     }
 866 
 867     /**
 868      * return the AuthorityKeyIdentifierExtension, if any.
 869      *
 870      * @return AuthorityKeyIdentifierExtension or null (if no such extension)
 871      * @throws IOException on error
 872      */
 873     public AuthorityKeyIdentifierExtension getAuthKeyIdExtension()
 874         throws IOException {
 875         Object obj = getExtension(PKIXExtensions.AuthorityKey_Id);
 876         return (AuthorityKeyIdentifierExtension)obj;
 877     }
 878 
 879     /**
 880      * return the CRLNumberExtension, if any.
 881      *
 882      * @return CRLNumberExtension or null (if no such extension)
 883      * @throws IOException on error
 884      */
 885     public CRLNumberExtension getCRLNumberExtension() throws IOException {
 886         Object obj = getExtension(PKIXExtensions.CRLNumber_Id);
 887         return (CRLNumberExtension)obj;
 888     }
 889 
 890     /**
 891      * return the CRL number from the CRLNumberExtension, if any.
 892      *
 893      * @return number or null (if no such extension)
 894      * @throws IOException on error
 895      */
 896     public BigInteger getCRLNumber() throws IOException {
 897         CRLNumberExtension numExt = getCRLNumberExtension();
 898         if (numExt != null) {
 899             BigInteger num = numExt.get(CRLNumberExtension.NUMBER);
 900             return num;
 901         } else {
 902             return null;
 903         }
 904     }
 905 
 906     /**
 907      * return the DeltaCRLIndicatorExtension, if any.
 908      *
 909      * @return DeltaCRLIndicatorExtension or null (if no such extension)
 910      * @throws IOException on error
 911      */
 912     public DeltaCRLIndicatorExtension getDeltaCRLIndicatorExtension()
 913         throws IOException {
 914 
 915         Object obj = getExtension(PKIXExtensions.DeltaCRLIndicator_Id);
 916         return (DeltaCRLIndicatorExtension)obj;
 917     }
 918 
 919     /**
 920      * return the base CRL number from the DeltaCRLIndicatorExtension, if any.
 921      *
 922      * @return number or null (if no such extension)
 923      * @throws IOException on error
 924      */
 925     public BigInteger getBaseCRLNumber() throws IOException {
 926         DeltaCRLIndicatorExtension dciExt = getDeltaCRLIndicatorExtension();
 927         if (dciExt != null) {
 928             BigInteger num = dciExt.get(DeltaCRLIndicatorExtension.NUMBER);
 929             return num;
 930         } else {
 931             return null;
 932         }
 933     }
 934 
 935     /**
 936      * return the IssuerAlternativeNameExtension, if any.
 937      *
 938      * @return IssuerAlternativeNameExtension or null (if no such extension)
 939      * @throws IOException on error
 940      */
 941     public IssuerAlternativeNameExtension getIssuerAltNameExtension()
 942         throws IOException {
 943         Object obj = getExtension(PKIXExtensions.IssuerAlternativeName_Id);
 944         return (IssuerAlternativeNameExtension)obj;
 945     }
 946 
 947     /**
 948      * return the IssuingDistributionPointExtension, if any.
 949      *
 950      * @return IssuingDistributionPointExtension or null
 951      *         (if no such extension)
 952      * @throws IOException on error
 953      */
 954     public IssuingDistributionPointExtension
 955         getIssuingDistributionPointExtension() throws IOException {
 956 
 957         Object obj = getExtension(PKIXExtensions.IssuingDistributionPoint_Id);
 958         return (IssuingDistributionPointExtension) obj;
 959     }
 960 
 961     /**
 962      * Return true if a critical extension is found that is
 963      * not supported, otherwise return false.
 964      */
 965     public boolean hasUnsupportedCriticalExtension() {
 966         if (extensions == null)
 967             return false;
 968         return extensions.hasUnsupportedCriticalExtension();
 969     }
 970 
 971     /**
 972      * Gets a Set of the extension(s) marked CRITICAL in the
 973      * CRL. In the returned set, each extension is represented by
 974      * its OID string.
 975      *
 976      * @return a set of the extension oid strings in the
 977      * CRL that are marked critical.
 978      */
 979     public Set&lt;String&gt; getCriticalExtensionOIDs() {
 980         if (extensions == null) {
 981             return null;
 982         }
 983         Set&lt;String&gt; extSet = new TreeSet&lt;&gt;();
 984         for (Extension ex : extensions.getAllExtensions()) {
 985             if (ex.isCritical()) {
 986                 extSet.add(ex.getExtensionId().toString());
 987             }
 988         }
 989         return extSet;
 990     }
 991 
 992     /**
 993      * Gets a Set of the extension(s) marked NON-CRITICAL in the
 994      * CRL. In the returned set, each extension is represented by
 995      * its OID string.
 996      *
 997      * @return a set of the extension oid strings in the
 998      * CRL that are NOT marked critical.
 999      */
1000     public Set&lt;String&gt; getNonCriticalExtensionOIDs() {
1001         if (extensions == null) {
1002             return null;
1003         }
1004         Set&lt;String&gt; extSet = new TreeSet&lt;&gt;();
1005         for (Extension ex : extensions.getAllExtensions()) {
1006             if (!ex.isCritical()) {
1007                 extSet.add(ex.getExtensionId().toString());
1008             }
1009         }
1010         return extSet;
1011     }
1012 
1013     /**
1014      * Gets the DER encoded OCTET string for the extension value
1015      * (&lt;code&gt;extnValue&lt;/code&gt;) identified by the passed in oid String.
1016      * The &lt;code&gt;oid&lt;/code&gt; string is
1017      * represented by a set of positive whole number separated
1018      * by &quot;.&quot;, that means,&lt;br&gt;
1019      * &amp;lt;positive whole number&amp;gt;.&amp;lt;positive whole number&amp;gt;.&amp;lt;...&amp;gt;
1020      *
1021      * @param oid the Object Identifier value for the extension.
1022      * @return the der encoded octet string of the extension value.
1023      */
1024     public byte[] getExtensionValue(String oid) {
1025         if (extensions == null)
1026             return null;
1027         try {
1028             String extAlias = OIDMap.getName(new ObjectIdentifier(oid));
1029             Extension crlExt = null;
1030 
1031             if (extAlias == null) { // may be unknown
1032                 ObjectIdentifier findOID = new ObjectIdentifier(oid);
1033                 Extension ex = null;
1034                 ObjectIdentifier inCertOID;
1035                 for (Enumeration&lt;Extension&gt; e = extensions.getElements();
1036                                                  e.hasMoreElements();) {
1037                     ex = e.nextElement();
1038                     inCertOID = ex.getExtensionId();
1039                     if (inCertOID.equals(findOID)) {
1040                         crlExt = ex;
1041                         break;
1042                     }
1043                 }
1044             } else
1045                 crlExt = extensions.get(extAlias);
1046             if (crlExt == null)
1047                 return null;
1048             byte[] extData = crlExt.getExtensionValue();
1049             if (extData == null)
1050                 return null;
1051             DerOutputStream out = new DerOutputStream();
1052             out.putOctetString(extData);
1053             return out.toByteArray();
1054         } catch (Exception e) {
1055             return null;
1056         }
1057     }
1058 
1059     /**
1060      * get an extension
1061      *
1062      * @param oid ObjectIdentifier of extension desired
1063      * @return Object of type {@code &lt;extension&gt;} or null, if not found
1064      * @throws IOException on error
1065      */
1066     public Object getExtension(ObjectIdentifier oid) {
1067         if (extensions == null)
1068             return null;
1069 
1070         // XXX Consider cloning this
1071         return extensions.get(OIDMap.getName(oid));
1072     }
1073 
1074     /*
1075      * Parses an X.509 CRL, should be used only by constructors.
1076      */
1077     private void parse(DerValue val) throws CRLException, IOException {
1078         // check if can over write the certificate
1079         if (readOnly)
1080             throw new CRLException(&quot;cannot over-write existing CRL&quot;);
1081 
1082         if ( val.getData() == null || val.tag != DerValue.tag_Sequence)
1083             throw new CRLException(&quot;Invalid DER-encoded CRL data&quot;);
1084 
1085         signedCRL = val.toByteArray();
1086         DerValue[] seq = new DerValue[3];
1087 
1088         seq[0] = val.data.getDerValue();
1089         seq[1] = val.data.getDerValue();
1090         seq[2] = val.data.getDerValue();
1091 
1092         if (val.data.available() != 0)
1093             throw new CRLException(&quot;signed overrun, bytes = &quot;
1094                                      + val.data.available());
1095 
1096         if (seq[0].tag != DerValue.tag_Sequence)
1097             throw new CRLException(&quot;signed CRL fields invalid&quot;);
1098 
1099         sigAlgId = AlgorithmId.parse(seq[1]);
1100         signature = seq[2].getBitString();
1101 
1102         if (seq[1].data.available() != 0)
1103             throw new CRLException(&quot;AlgorithmId field overrun&quot;);
1104 
1105         if (seq[2].data.available() != 0)
1106             throw new CRLException(&quot;Signature field overrun&quot;);
1107 
1108         // the tbsCertsList
1109         tbsCertList = seq[0].toByteArray();
1110 
1111         // parse the information
1112         DerInputStream derStrm = seq[0].data;
1113         DerValue       tmp;
1114         byte           nextByte;
1115 
1116         // version (optional if v1)
1117         version = 0;   // by default, version = v1 == 0
1118         nextByte = (byte)derStrm.peekByte();
1119         if (nextByte == DerValue.tag_Integer) {
1120             version = derStrm.getInteger();
1121             if (version != 1)  // i.e. v2
1122                 throw new CRLException(&quot;Invalid version&quot;);
1123         }
1124         tmp = derStrm.getDerValue();
1125 
1126         // signature
1127         AlgorithmId tmpId = AlgorithmId.parse(tmp);
1128 
1129         // the &quot;inner&quot; and &quot;outer&quot; signature algorithms must match
1130         if (! tmpId.equals(sigAlgId))
1131             throw new CRLException(&quot;Signature algorithm mismatch&quot;);
1132         infoSigAlgId = tmpId;
1133 
1134         // issuer
1135         issuer = new X500Name(derStrm);
1136         if (issuer.isEmpty()) {
1137             throw new CRLException(&quot;Empty issuer DN not allowed in X509CRLs&quot;);
1138         }
1139 
1140         // thisUpdate
1141         // check if UTCTime encoded or GeneralizedTime
1142 
1143         nextByte = (byte)derStrm.peekByte();
1144         if (nextByte == DerValue.tag_UtcTime) {
1145             thisUpdate = derStrm.getUTCTime();
1146         } else if (nextByte == DerValue.tag_GeneralizedTime) {
1147             thisUpdate = derStrm.getGeneralizedTime();
1148         } else {
1149             throw new CRLException(&quot;Invalid encoding for thisUpdate&quot;
1150                                    + &quot; (tag=&quot; + nextByte + &quot;)&quot;);
1151         }
1152 
1153         if (derStrm.available() == 0)
1154            return;     // done parsing no more optional fields present
1155 
1156         // nextUpdate (optional)
1157         nextByte = (byte)derStrm.peekByte();
1158         if (nextByte == DerValue.tag_UtcTime) {
1159             nextUpdate = derStrm.getUTCTime();
1160         } else if (nextByte == DerValue.tag_GeneralizedTime) {
1161             nextUpdate = derStrm.getGeneralizedTime();
1162         } // else it is not present
1163 
1164         if (derStrm.available() == 0)
1165             return;     // done parsing no more optional fields present
1166 
1167         // revokedCertificates (optional)
1168         nextByte = (byte)derStrm.peekByte();
1169         if ((nextByte == DerValue.tag_SequenceOf)
1170             &amp;&amp; (! ((nextByte &amp; 0x0c0) == 0x080))) {
1171             DerValue[] badCerts = derStrm.getSequence(4);
1172 
1173             X500Principal crlIssuer = getIssuerX500Principal();
1174             X500Principal badCertIssuer = crlIssuer;
1175             for (int i = 0; i &lt; badCerts.length; i++) {
1176                 X509CRLEntryImpl entry = new X509CRLEntryImpl(badCerts[i]);
1177                 badCertIssuer = getCertIssuer(entry, badCertIssuer);
1178                 entry.setCertificateIssuer(crlIssuer, badCertIssuer);
1179                 X509IssuerSerial issuerSerial = new X509IssuerSerial
1180                     (badCertIssuer, entry.getSerialNumber());
1181                 revokedMap.put(issuerSerial, entry);
1182                 revokedList.add(entry);
1183             }
1184         }
1185 
1186         if (derStrm.available() == 0)
1187             return;     // done parsing no extensions
1188 
1189         // crlExtensions (optional)
1190         tmp = derStrm.getDerValue();
1191         if (tmp.isConstructed() &amp;&amp; tmp.isContextSpecific((byte)0)) {
1192             extensions = new CRLExtensions(tmp.data);
1193         }
1194         readOnly = true;
1195     }
1196 
1197     /**
1198      * Extract the issuer X500Principal from an X509CRL. Parses the encoded
1199      * form of the CRL to preserve the principal&#39;s ASN.1 encoding.
1200      *
1201      * Called by java.security.cert.X509CRL.getIssuerX500Principal().
1202      */
1203     public static X500Principal getIssuerX500Principal(X509CRL crl) {
1204         try {
1205             byte[] encoded = crl.getEncoded();
1206             DerInputStream derIn = new DerInputStream(encoded);
1207             DerValue tbsCert = derIn.getSequence(3)[0];
1208             DerInputStream tbsIn = tbsCert.data;
1209 
1210             DerValue tmp;
1211             // skip version number if present
1212             byte nextByte = (byte)tbsIn.peekByte();
1213             if (nextByte == DerValue.tag_Integer) {
1214                 tmp = tbsIn.getDerValue();
1215             }
1216 
1217             tmp = tbsIn.getDerValue();  // skip signature
1218             tmp = tbsIn.getDerValue();  // issuer
1219             byte[] principalBytes = tmp.toByteArray();
1220             return new X500Principal(principalBytes);
1221         } catch (Exception e) {
1222             throw new RuntimeException(&quot;Could not parse issuer&quot;, e);
1223         }
1224     }
1225 
1226     /**
1227      * Returned the encoding of the given certificate for internal use.
1228      * Callers must guarantee that they neither modify it nor expose it
1229      * to untrusted code. Uses getEncodedInternal() if the certificate
1230      * is instance of X509CertImpl, getEncoded() otherwise.
1231      */
1232     public static byte[] getEncodedInternal(X509CRL crl) throws CRLException {
1233         if (crl instanceof X509CRLImpl) {
1234             return ((X509CRLImpl)crl).getEncodedInternal();
1235         } else {
1236             return crl.getEncoded();
1237         }
1238     }
1239 
1240     /**
1241      * Utility method to convert an arbitrary instance of X509CRL
1242      * to a X509CRLImpl. Does a cast if possible, otherwise reparses
1243      * the encoding.
1244      */
1245     public static X509CRLImpl toImpl(X509CRL crl)
1246             throws CRLException {
1247         if (crl instanceof X509CRLImpl) {
1248             return (X509CRLImpl)crl;
1249         } else {
1250             return X509Factory.intern(crl);
1251         }
1252     }
1253 
1254     /**
1255      * Returns the X500 certificate issuer DN of a CRL entry.
1256      *
1257      * @param entry the entry to check
1258      * @param prevCertIssuer the previous entry&#39;s certificate issuer
1259      * @return the X500Principal in a CertificateIssuerExtension, or
1260      *   prevCertIssuer if it does not exist
1261      */
1262     private X500Principal getCertIssuer(X509CRLEntryImpl entry,
1263         X500Principal prevCertIssuer) throws IOException {
1264 
1265         CertificateIssuerExtension ciExt =
1266             entry.getCertificateIssuerExtension();
1267         if (ciExt != null) {
1268             GeneralNames names = ciExt.get(CertificateIssuerExtension.ISSUER);
1269             X500Name issuerDN = (X500Name) names.get(0).getName();
1270             return issuerDN.asX500Principal();
1271         } else {
1272             return prevCertIssuer;
1273         }
1274     }
1275 
1276     @Override
1277     public void derEncode(OutputStream out) throws IOException {
1278         if (signedCRL == null)
1279             throw new IOException(&quot;Null CRL to encode&quot;);
1280         out.write(signedCRL.clone());
1281     }
1282 
1283     /**
1284      * Immutable X.509 Certificate Issuer DN and serial number pair
1285      */
1286     private static final class X509IssuerSerial
1287             implements Comparable&lt;X509IssuerSerial&gt; {
1288         final X500Principal issuer;
1289         final BigInteger serial;
1290         volatile int hashcode;
1291 
1292         /**
1293          * Create an X509IssuerSerial.
1294          *
1295          * @param issuer the issuer DN
1296          * @param serial the serial number
1297          */
1298         X509IssuerSerial(X500Principal issuer, BigInteger serial) {
1299             this.issuer = issuer;
1300             this.serial = serial;
1301         }
1302 
1303         /**
1304          * Construct an X509IssuerSerial from an X509Certificate.
1305          */
1306         X509IssuerSerial(X509Certificate cert) {
1307             this(cert.getIssuerX500Principal(), cert.getSerialNumber());
1308         }
1309 
1310         /**
1311          * Returns the issuer.
1312          *
1313          * @return the issuer
1314          */
1315         X500Principal getIssuer() {
1316             return issuer;
1317         }
1318 
1319         /**
1320          * Returns the serial number.
1321          *
1322          * @return the serial number
1323          */
1324         BigInteger getSerial() {
1325             return serial;
1326         }
1327 
1328         /**
1329          * Compares this X509Serial with another and returns true if they
1330          * are equivalent.
1331          *
1332          * @param o the other object to compare with
1333          * @return true if equal, false otherwise
1334          */
1335         public boolean equals(Object o) {
1336             if (o == this) {
1337                 return true;
1338             }
1339 
1340             if (!(o instanceof X509IssuerSerial)) {
1341                 return false;
1342             }
1343 
1344             X509IssuerSerial other = (X509IssuerSerial) o;
1345             if (serial.equals(other.getSerial()) &amp;&amp;
1346                 issuer.equals(other.getIssuer())) {
1347                 return true;
1348             }
1349             return false;
1350         }
1351 
1352         /**
1353          * Returns a hash code value for this X509IssuerSerial.
1354          *
1355          * @return the hash code value
1356          */
1357         public int hashCode() {
1358             int h = hashcode;
1359             if (h == 0) {
1360                 h = 17;
1361                 h = 37*h + issuer.hashCode();
1362                 h = 37*h + serial.hashCode();
1363                 if (h != 0) {
1364                     hashcode = h;
1365                 }
1366             }
1367             return h;
1368         }
1369 
1370         @Override
1371         public int compareTo(X509IssuerSerial another) {
1372             int cissuer = issuer.toString()
1373                     .compareTo(another.issuer.toString());
1374             if (cissuer != 0) return cissuer;
1375             return this.serial.compareTo(another.serial);
1376         }
1377     }
1378 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/util/IdentityHashMap.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util;
  27 
  28 import java.lang.reflect.Array;
  29 import java.util.function.BiConsumer;
  30 import java.util.function.BiFunction;
  31 import java.util.function.Consumer;
  32 import jdk.internal.access.SharedSecrets;
  33 
  34 /**
  35  * This class implements the {@code Map} interface with a hash table, using
  36  * reference-equality in place of object-equality when comparing keys (and
  37  * values).  In other words, in an {@code IdentityHashMap}, two keys
  38  * {@code k1} and {@code k2} are considered equal if and only if
  39  * {@code (k1==k2)}.  (In normal {@code Map} implementations (like
  40  * {@code HashMap}) two keys {@code k1} and {@code k2} are considered equal
  41  * if and only if {@code (k1==null ? k2==null : k1.equals(k2))}.)
  42  *
  43  * &lt;p&gt;&lt;b&gt;This class is &lt;i&gt;not&lt;/i&gt; a general-purpose {@code Map}
  44  * implementation!  While this class implements the {@code Map} interface, it
  45  * intentionally violates {@code Map&#39;s} general contract, which mandates the
  46  * use of the {@code equals} method when comparing objects.  This class is
  47  * designed for use only in the rare cases wherein reference-equality
  48  * semantics are required.&lt;/b&gt;
  49  *
  50  * &lt;p&gt;A typical use of this class is &lt;i&gt;topology-preserving object graph
  51  * transformations&lt;/i&gt;, such as serialization or deep-copying.  To perform such
  52  * a transformation, a program must maintain a &quot;node table&quot; that keeps track
  53  * of all the object references that have already been processed.  The node
  54  * table must not equate distinct objects even if they happen to be equal.
  55  * Another typical use of this class is to maintain &lt;i&gt;proxy objects&lt;/i&gt;.  For
  56  * example, a debugging facility might wish to maintain a proxy object for
  57  * each object in the program being debugged.
  58  *
  59  * &lt;p&gt;This class provides all of the optional map operations, and permits
  60  * {@code null} values and the {@code null} key.  This class makes no
  61  * guarantees as to the order of the map; in particular, it does not guarantee
  62  * that the order will remain constant over time.
  63  *
  64  * &lt;p&gt;This class provides constant-time performance for the basic
  65  * operations ({@code get} and {@code put}), assuming the system
  66  * identity hash function ({@link System#identityHashCode(Object)})
  67  * disperses elements properly among the buckets.
  68  *
  69  * &lt;p&gt;This class has one tuning parameter (which affects performance but not
  70  * semantics): &lt;i&gt;expected maximum size&lt;/i&gt;.  This parameter is the maximum
  71  * number of key-value mappings that the map is expected to hold.  Internally,
  72  * this parameter is used to determine the number of buckets initially
  73  * comprising the hash table.  The precise relationship between the expected
  74  * maximum size and the number of buckets is unspecified.
  75  *
  76  * &lt;p&gt;If the size of the map (the number of key-value mappings) sufficiently
  77  * exceeds the expected maximum size, the number of buckets is increased.
  78  * Increasing the number of buckets (&quot;rehashing&quot;) may be fairly expensive, so
  79  * it pays to create identity hash maps with a sufficiently large expected
  80  * maximum size.  On the other hand, iteration over collection views requires
  81  * time proportional to the number of buckets in the hash table, so it
  82  * pays not to set the expected maximum size too high if you are especially
  83  * concerned with iteration performance or memory usage.
  84  *
  85  * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;
  86  * If multiple threads access an identity hash map concurrently, and at
  87  * least one of the threads modifies the map structurally, it &lt;i&gt;must&lt;/i&gt;
  88  * be synchronized externally.  (A structural modification is any operation
  89  * that adds or deletes one or more mappings; merely changing the value
  90  * associated with a key that an instance already contains is not a
  91  * structural modification.)  This is typically accomplished by
  92  * synchronizing on some object that naturally encapsulates the map.
  93  *
  94  * If no such object exists, the map should be &quot;wrapped&quot; using the
  95  * {@link Collections#synchronizedMap Collections.synchronizedMap}
  96  * method.  This is best done at creation time, to prevent accidental
  97  * unsynchronized access to the map:&lt;pre&gt;
  98  *   Map m = Collections.synchronizedMap(new IdentityHashMap(...));&lt;/pre&gt;
  99  *
 100  * &lt;p&gt;The iterators returned by the {@code iterator} method of the
 101  * collections returned by all of this class&#39;s &quot;collection view
 102  * methods&quot; are &lt;i&gt;fail-fast&lt;/i&gt;: if the map is structurally modified
 103  * at any time after the iterator is created, in any way except
 104  * through the iterator&#39;s own {@code remove} method, the iterator
 105  * will throw a {@link ConcurrentModificationException}.  Thus, in the
 106  * face of concurrent modification, the iterator fails quickly and
 107  * cleanly, rather than risking arbitrary, non-deterministic behavior
 108  * at an undetermined time in the future.
 109  *
 110  * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
 111  * as it is, generally speaking, impossible to make any hard guarantees in the
 112  * presence of unsynchronized concurrent modification.  Fail-fast iterators
 113  * throw {@code ConcurrentModificationException} on a best-effort basis.
 114  * Therefore, it would be wrong to write a program that depended on this
 115  * exception for its correctness: &lt;i&gt;fail-fast iterators should be used only
 116  * to detect bugs.&lt;/i&gt;
 117  *
<a name="2" id="anc2"></a><span class="line-removed"> 118  * &lt;p&gt;Implementation note: This is a simple &lt;i&gt;linear-probe&lt;/i&gt; hash table,</span>
<span class="line-removed"> 119  * as described for example in texts by Sedgewick and Knuth.  The array</span>
<span class="line-removed"> 120  * alternates holding keys and values.  (This has better locality for large</span>
<span class="line-removed"> 121  * tables than does using separate arrays.)  For many JRE implementations</span>
<span class="line-removed"> 122  * and operation mixes, this class will yield better performance than</span>
<span class="line-removed"> 123  * {@link HashMap} (which uses &lt;i&gt;chaining&lt;/i&gt; rather than linear-probing).</span>
<span class="line-removed"> 124  *</span>
 125  * &lt;p&gt;This class is a member of the
 126  * &lt;a href=&quot;{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework&quot;&gt;
 127  * Java Collections Framework&lt;/a&gt;.
 128  *
<a name="3" id="anc3"></a>








 129  * @see     System#identityHashCode(Object)
 130  * @see     Object#hashCode()
 131  * @see     Collection
 132  * @see     Map
 133  * @see     HashMap
 134  * @see     TreeMap
 135  * @author  Doug Lea and Josh Bloch
 136  * @since   1.4
 137  */
 138 
 139 public class IdentityHashMap&lt;K,V&gt;
 140     extends AbstractMap&lt;K,V&gt;
 141     implements Map&lt;K,V&gt;, java.io.Serializable, Cloneable
 142 {
 143     /**
 144      * The initial capacity used by the no-args constructor.
 145      * MUST be a power of two.  The value 32 corresponds to the
 146      * (specified) expected maximum size of 21, given a load factor
 147      * of 2/3.
 148      */
 149     private static final int DEFAULT_CAPACITY = 32;
 150 
 151     /**
 152      * The minimum capacity, used if a lower value is implicitly specified
 153      * by either of the constructors with arguments.  The value 4 corresponds
 154      * to an expected maximum size of 2, given a load factor of 2/3.
 155      * MUST be a power of two.
 156      */
 157     private static final int MINIMUM_CAPACITY = 4;
 158 
 159     /**
 160      * The maximum capacity, used if a higher value is implicitly specified
 161      * by either of the constructors with arguments.
 162      * MUST be a power of two &lt;= 1&lt;&lt;29.
 163      *
 164      * In fact, the map can hold no more than MAXIMUM_CAPACITY-1 items
 165      * because it has to have at least one slot with the key == null
 166      * in order to avoid infinite loops in get(), put(), remove()
 167      */
 168     private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 29;
 169 
 170     /**
 171      * The table, resized as necessary. Length MUST always be a power of two.
 172      */
 173     transient Object[] table; // non-private to simplify nested class access
 174 
 175     /**
 176      * The number of key-value mappings contained in this identity hash map.
 177      *
 178      * @serial
 179      */
 180     int size;
 181 
 182     /**
 183      * The number of modifications, to support fast-fail iterators
 184      */
 185     transient int modCount;
 186 
 187     /**
 188      * Value representing null keys inside tables.
 189      */
 190     static final Object NULL_KEY = new Object();
 191 
 192     /**
 193      * Use NULL_KEY for key if it is null.
 194      */
 195     private static Object maskNull(Object key) {
 196         return (key == null ? NULL_KEY : key);
 197     }
 198 
 199     /**
 200      * Returns internal representation of null key back to caller as null.
 201      */
 202     static final Object unmaskNull(Object key) {
 203         return (key == NULL_KEY ? null : key);
 204     }
 205 
 206     /**
 207      * Constructs a new, empty identity hash map with a default expected
 208      * maximum size (21).
 209      */
 210     public IdentityHashMap() {
 211         init(DEFAULT_CAPACITY);
 212     }
 213 
 214     /**
 215      * Constructs a new, empty map with the specified expected maximum size.
 216      * Putting more than the expected number of key-value mappings into
 217      * the map may cause the internal data structure to grow, which may be
 218      * somewhat time-consuming.
 219      *
 220      * @param expectedMaxSize the expected maximum size of the map
 221      * @throws IllegalArgumentException if {@code expectedMaxSize} is negative
 222      */
 223     public IdentityHashMap(int expectedMaxSize) {
 224         if (expectedMaxSize &lt; 0)
 225             throw new IllegalArgumentException(&quot;expectedMaxSize is negative: &quot;
 226                                                + expectedMaxSize);
 227         init(capacity(expectedMaxSize));
 228     }
 229 
 230     /**
 231      * Returns the appropriate capacity for the given expected maximum size.
 232      * Returns the smallest power of two between MINIMUM_CAPACITY and
 233      * MAXIMUM_CAPACITY, inclusive, that is greater than (3 *
 234      * expectedMaxSize)/2, if such a number exists.  Otherwise returns
 235      * MAXIMUM_CAPACITY.
 236      */
 237     private static int capacity(int expectedMaxSize) {
 238         // assert expectedMaxSize &gt;= 0;
 239         return
 240             (expectedMaxSize &gt; MAXIMUM_CAPACITY / 3) ? MAXIMUM_CAPACITY :
 241             (expectedMaxSize &lt;= 2 * MINIMUM_CAPACITY / 3) ? MINIMUM_CAPACITY :
 242             Integer.highestOneBit(expectedMaxSize + (expectedMaxSize &lt;&lt; 1));
 243     }
 244 
 245     /**
 246      * Initializes object to be an empty map with the specified initial
 247      * capacity, which is assumed to be a power of two between
 248      * MINIMUM_CAPACITY and MAXIMUM_CAPACITY inclusive.
 249      */
 250     private void init(int initCapacity) {
 251         // assert (initCapacity &amp; -initCapacity) == initCapacity; // power of 2
 252         // assert initCapacity &gt;= MINIMUM_CAPACITY;
 253         // assert initCapacity &lt;= MAXIMUM_CAPACITY;
 254 
 255         table = new Object[2 * initCapacity];
 256     }
 257 
 258     /**
 259      * Constructs a new identity hash map containing the keys-value mappings
 260      * in the specified map.
 261      *
 262      * @param m the map whose mappings are to be placed into this map
 263      * @throws NullPointerException if the specified map is null
 264      */
 265     public IdentityHashMap(Map&lt;? extends K, ? extends V&gt; m) {
 266         // Allow for a bit of growth
 267         this((int) ((1 + m.size()) * 1.1));
 268         putAll(m);
 269     }
 270 
 271     /**
 272      * Returns the number of key-value mappings in this identity hash map.
 273      *
 274      * @return the number of key-value mappings in this map
 275      */
 276     public int size() {
 277         return size;
 278     }
 279 
 280     /**
 281      * Returns {@code true} if this identity hash map contains no key-value
 282      * mappings.
 283      *
 284      * @return {@code true} if this identity hash map contains no key-value
 285      *         mappings
 286      */
 287     public boolean isEmpty() {
 288         return size == 0;
 289     }
 290 
 291     /**
 292      * Returns index for Object x.
 293      */
 294     private static int hash(Object x, int length) {
 295         int h = System.identityHashCode(x);
<a name="4" id="anc4"></a><span class="line-modified"> 296         // Multiply by -127, and left-shift to use least bit as part of hash</span>
 297         return ((h &lt;&lt; 1) - (h &lt;&lt; 8)) &amp; (length - 1);
 298     }
 299 
 300     /**
 301      * Circularly traverses table of size len.
 302      */
 303     private static int nextKeyIndex(int i, int len) {
 304         return (i + 2 &lt; len ? i + 2 : 0);
 305     }
 306 
 307     /**
 308      * Returns the value to which the specified key is mapped,
 309      * or {@code null} if this map contains no mapping for the key.
 310      *
 311      * &lt;p&gt;More formally, if this map contains a mapping from a key
 312      * {@code k} to a value {@code v} such that {@code (key == k)},
 313      * then this method returns {@code v}; otherwise it returns
 314      * {@code null}.  (There can be at most one such mapping.)
 315      *
 316      * &lt;p&gt;A return value of {@code null} does not &lt;i&gt;necessarily&lt;/i&gt;
 317      * indicate that the map contains no mapping for the key; it&#39;s also
 318      * possible that the map explicitly maps the key to {@code null}.
 319      * The {@link #containsKey containsKey} operation may be used to
 320      * distinguish these two cases.
 321      *
 322      * @see #put(Object, Object)
 323      */
 324     @SuppressWarnings(&quot;unchecked&quot;)
 325     public V get(Object key) {
 326         Object k = maskNull(key);
 327         Object[] tab = table;
 328         int len = tab.length;
 329         int i = hash(k, len);
 330         while (true) {
 331             Object item = tab[i];
 332             if (item == k)
 333                 return (V) tab[i + 1];
 334             if (item == null)
 335                 return null;
 336             i = nextKeyIndex(i, len);
 337         }
 338     }
 339 
 340     /**
 341      * Tests whether the specified object reference is a key in this identity
 342      * hash map.
 343      *
 344      * @param   key   possible key
 345      * @return  {@code true} if the specified object reference is a key
 346      *          in this map
 347      * @see     #containsValue(Object)
 348      */
 349     public boolean containsKey(Object key) {
 350         Object k = maskNull(key);
 351         Object[] tab = table;
 352         int len = tab.length;
 353         int i = hash(k, len);
 354         while (true) {
 355             Object item = tab[i];
 356             if (item == k)
 357                 return true;
 358             if (item == null)
 359                 return false;
 360             i = nextKeyIndex(i, len);
 361         }
 362     }
 363 
 364     /**
 365      * Tests whether the specified object reference is a value in this identity
 366      * hash map.
 367      *
 368      * @param value value whose presence in this map is to be tested
 369      * @return {@code true} if this map maps one or more keys to the
 370      *         specified object reference
 371      * @see     #containsKey(Object)
 372      */
 373     public boolean containsValue(Object value) {
 374         Object[] tab = table;
 375         for (int i = 1; i &lt; tab.length; i += 2)
 376             if (tab[i] == value &amp;&amp; tab[i - 1] != null)
 377                 return true;
 378 
 379         return false;
 380     }
 381 
 382     /**
 383      * Tests if the specified key-value mapping is in the map.
 384      *
 385      * @param   key   possible key
 386      * @param   value possible value
 387      * @return  {@code true} if and only if the specified key-value
 388      *          mapping is in the map
 389      */
 390     private boolean containsMapping(Object key, Object value) {
 391         Object k = maskNull(key);
 392         Object[] tab = table;
 393         int len = tab.length;
 394         int i = hash(k, len);
 395         while (true) {
 396             Object item = tab[i];
 397             if (item == k)
 398                 return tab[i + 1] == value;
 399             if (item == null)
 400                 return false;
 401             i = nextKeyIndex(i, len);
 402         }
 403     }
 404 
 405     /**
 406      * Associates the specified value with the specified key in this identity
 407      * hash map.  If the map previously contained a mapping for the key, the
 408      * old value is replaced.
 409      *
 410      * @param key the key with which the specified value is to be associated
 411      * @param value the value to be associated with the specified key
 412      * @return the previous value associated with {@code key}, or
 413      *         {@code null} if there was no mapping for {@code key}.
 414      *         (A {@code null} return can also indicate that the map
 415      *         previously associated {@code null} with {@code key}.)
 416      * @see     Object#equals(Object)
 417      * @see     #get(Object)
 418      * @see     #containsKey(Object)
 419      */
 420     public V put(K key, V value) {
 421         final Object k = maskNull(key);
 422 
 423         retryAfterResize: for (;;) {
 424             final Object[] tab = table;
 425             final int len = tab.length;
 426             int i = hash(k, len);
 427 
 428             for (Object item; (item = tab[i]) != null;
 429                  i = nextKeyIndex(i, len)) {
 430                 if (item == k) {
 431                     @SuppressWarnings(&quot;unchecked&quot;)
 432                         V oldValue = (V) tab[i + 1];
 433                     tab[i + 1] = value;
 434                     return oldValue;
 435                 }
 436             }
 437 
 438             final int s = size + 1;
 439             // Use optimized form of 3 * s.
 440             // Next capacity is len, 2 * current capacity.
 441             if (s + (s &lt;&lt; 1) &gt; len &amp;&amp; resize(len))
 442                 continue retryAfterResize;
 443 
 444             modCount++;
 445             tab[i] = k;
 446             tab[i + 1] = value;
 447             size = s;
 448             return null;
 449         }
 450     }
 451 
 452     /**
 453      * Resizes the table if necessary to hold given capacity.
 454      *
 455      * @param newCapacity the new capacity, must be a power of two.
 456      * @return whether a resize did in fact take place
 457      */
 458     private boolean resize(int newCapacity) {
 459         // assert (newCapacity &amp; -newCapacity) == newCapacity; // power of 2
 460         int newLength = newCapacity * 2;
 461 
 462         Object[] oldTable = table;
 463         int oldLength = oldTable.length;
 464         if (oldLength == 2 * MAXIMUM_CAPACITY) { // can&#39;t expand any further
 465             if (size == MAXIMUM_CAPACITY - 1)
 466                 throw new IllegalStateException(&quot;Capacity exhausted.&quot;);
 467             return false;
 468         }
 469         if (oldLength &gt;= newLength)
 470             return false;
 471 
 472         Object[] newTable = new Object[newLength];
 473 
 474         for (int j = 0; j &lt; oldLength; j += 2) {
 475             Object key = oldTable[j];
 476             if (key != null) {
 477                 Object value = oldTable[j+1];
 478                 oldTable[j] = null;
 479                 oldTable[j+1] = null;
 480                 int i = hash(key, newLength);
 481                 while (newTable[i] != null)
 482                     i = nextKeyIndex(i, newLength);
 483                 newTable[i] = key;
 484                 newTable[i + 1] = value;
 485             }
 486         }
 487         table = newTable;
 488         return true;
 489     }
 490 
 491     /**
 492      * Copies all of the mappings from the specified map to this map.
 493      * These mappings will replace any mappings that this map had for
 494      * any of the keys currently in the specified map.
 495      *
 496      * @param m mappings to be stored in this map
 497      * @throws NullPointerException if the specified map is null
 498      */
 499     public void putAll(Map&lt;? extends K, ? extends V&gt; m) {
 500         int n = m.size();
 501         if (n == 0)
 502             return;
 503         if (n &gt; size)
 504             resize(capacity(n)); // conservatively pre-expand
 505 
 506         for (Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())
 507             put(e.getKey(), e.getValue());
 508     }
 509 
 510     /**
 511      * Removes the mapping for this key from this map if present.
 512      *
 513      * @param key key whose mapping is to be removed from the map
 514      * @return the previous value associated with {@code key}, or
 515      *         {@code null} if there was no mapping for {@code key}.
 516      *         (A {@code null} return can also indicate that the map
 517      *         previously associated {@code null} with {@code key}.)
 518      */
 519     public V remove(Object key) {
 520         Object k = maskNull(key);
 521         Object[] tab = table;
 522         int len = tab.length;
 523         int i = hash(k, len);
 524 
 525         while (true) {
 526             Object item = tab[i];
 527             if (item == k) {
 528                 modCount++;
 529                 size--;
 530                 @SuppressWarnings(&quot;unchecked&quot;)
 531                     V oldValue = (V) tab[i + 1];
 532                 tab[i + 1] = null;
 533                 tab[i] = null;
 534                 closeDeletion(i);
 535                 return oldValue;
 536             }
 537             if (item == null)
 538                 return null;
 539             i = nextKeyIndex(i, len);
 540         }
 541     }
 542 
 543     /**
 544      * Removes the specified key-value mapping from the map if it is present.
 545      *
 546      * @param   key   possible key
 547      * @param   value possible value
 548      * @return  {@code true} if and only if the specified key-value
 549      *          mapping was in the map
 550      */
 551     private boolean removeMapping(Object key, Object value) {
 552         Object k = maskNull(key);
 553         Object[] tab = table;
 554         int len = tab.length;
 555         int i = hash(k, len);
 556 
 557         while (true) {
 558             Object item = tab[i];
 559             if (item == k) {
 560                 if (tab[i + 1] != value)
 561                     return false;
 562                 modCount++;
 563                 size--;
 564                 tab[i] = null;
 565                 tab[i + 1] = null;
 566                 closeDeletion(i);
 567                 return true;
 568             }
 569             if (item == null)
 570                 return false;
 571             i = nextKeyIndex(i, len);
 572         }
 573     }
 574 
 575     /**
 576      * Rehash all possibly-colliding entries following a
 577      * deletion. This preserves the linear-probe
 578      * collision properties required by get, put, etc.
 579      *
 580      * @param d the index of a newly empty deleted slot
 581      */
 582     private void closeDeletion(int d) {
 583         // Adapted from Knuth Section 6.4 Algorithm R
 584         Object[] tab = table;
 585         int len = tab.length;
 586 
 587         // Look for items to swap into newly vacated slot
 588         // starting at index immediately following deletion,
 589         // and continuing until a null slot is seen, indicating
 590         // the end of a run of possibly-colliding keys.
 591         Object item;
 592         for (int i = nextKeyIndex(d, len); (item = tab[i]) != null;
 593              i = nextKeyIndex(i, len) ) {
 594             // The following test triggers if the item at slot i (which
 595             // hashes to be at slot r) should take the spot vacated by d.
 596             // If so, we swap it in, and then continue with d now at the
 597             // newly vacated i.  This process will terminate when we hit
 598             // the null slot at the end of this run.
 599             // The test is messy because we are using a circular table.
 600             int r = hash(item, len);
 601             if ((i &lt; r &amp;&amp; (r &lt;= d || d &lt;= i)) || (r &lt;= d &amp;&amp; d &lt;= i)) {
 602                 tab[d] = item;
 603                 tab[d + 1] = tab[i + 1];
 604                 tab[i] = null;
 605                 tab[i + 1] = null;
 606                 d = i;
 607             }
 608         }
 609     }
 610 
 611     /**
 612      * Removes all of the mappings from this map.
 613      * The map will be empty after this call returns.
 614      */
 615     public void clear() {
 616         modCount++;
 617         Object[] tab = table;
 618         for (int i = 0; i &lt; tab.length; i++)
 619             tab[i] = null;
 620         size = 0;
 621     }
 622 
 623     /**
 624      * Compares the specified object with this map for equality.  Returns
 625      * {@code true} if the given object is also a map and the two maps
 626      * represent identical object-reference mappings.  More formally, this
 627      * map is equal to another map {@code m} if and only if
 628      * {@code this.entrySet().equals(m.entrySet())}.
 629      *
 630      * &lt;p&gt;&lt;b&gt;Owing to the reference-equality-based semantics of this map it is
 631      * possible that the symmetry and transitivity requirements of the
 632      * {@code Object.equals} contract may be violated if this map is compared
 633      * to a normal map.  However, the {@code Object.equals} contract is
 634      * guaranteed to hold among {@code IdentityHashMap} instances.&lt;/b&gt;
 635      *
 636      * @param  o object to be compared for equality with this map
 637      * @return {@code true} if the specified object is equal to this map
 638      * @see Object#equals(Object)
 639      */
 640     public boolean equals(Object o) {
 641         if (o == this) {
 642             return true;
 643         } else if (o instanceof IdentityHashMap) {
 644             IdentityHashMap&lt;?,?&gt; m = (IdentityHashMap&lt;?,?&gt;) o;
 645             if (m.size() != size)
 646                 return false;
 647 
 648             Object[] tab = m.table;
 649             for (int i = 0; i &lt; tab.length; i+=2) {
 650                 Object k = tab[i];
 651                 if (k != null &amp;&amp; !containsMapping(k, tab[i + 1]))
 652                     return false;
 653             }
 654             return true;
 655         } else if (o instanceof Map) {
 656             Map&lt;?,?&gt; m = (Map&lt;?,?&gt;)o;
 657             return entrySet().equals(m.entrySet());
 658         } else {
 659             return false;  // o is not a Map
 660         }
 661     }
 662 
 663     /**
 664      * Returns the hash code value for this map.  The hash code of a map is
 665      * defined to be the sum of the hash codes of each entry in the map&#39;s
 666      * {@code entrySet()} view.  This ensures that {@code m1.equals(m2)}
 667      * implies that {@code m1.hashCode()==m2.hashCode()} for any two
 668      * {@code IdentityHashMap} instances {@code m1} and {@code m2}, as
 669      * required by the general contract of {@link Object#hashCode}.
 670      *
 671      * &lt;p&gt;&lt;b&gt;Owing to the reference-equality-based semantics of the
 672      * {@code Map.Entry} instances in the set returned by this map&#39;s
 673      * {@code entrySet} method, it is possible that the contractual
 674      * requirement of {@code Object.hashCode} mentioned in the previous
 675      * paragraph will be violated if one of the two objects being compared is
 676      * an {@code IdentityHashMap} instance and the other is a normal map.&lt;/b&gt;
 677      *
 678      * @return the hash code value for this map
 679      * @see Object#equals(Object)
 680      * @see #equals(Object)
 681      */
 682     public int hashCode() {
 683         int result = 0;
 684         Object[] tab = table;
 685         for (int i = 0; i &lt; tab.length; i +=2) {
 686             Object key = tab[i];
 687             if (key != null) {
 688                 Object k = unmaskNull(key);
 689                 result += System.identityHashCode(k) ^
 690                           System.identityHashCode(tab[i + 1]);
 691             }
 692         }
 693         return result;
 694     }
 695 
 696     /**
 697      * Returns a shallow copy of this identity hash map: the keys and values
 698      * themselves are not cloned.
 699      *
 700      * @return a shallow copy of this map
 701      */
 702     public Object clone() {
 703         try {
 704             IdentityHashMap&lt;?,?&gt; m = (IdentityHashMap&lt;?,?&gt;) super.clone();
 705             m.entrySet = null;
 706             m.table = table.clone();
 707             return m;
 708         } catch (CloneNotSupportedException e) {
 709             throw new InternalError(e);
 710         }
 711     }
 712 
 713     private abstract class IdentityHashMapIterator&lt;T&gt; implements Iterator&lt;T&gt; {
 714         int index = (size != 0 ? 0 : table.length); // current slot.
 715         int expectedModCount = modCount; // to support fast-fail
 716         int lastReturnedIndex = -1;      // to allow remove()
 717         boolean indexValid; // To avoid unnecessary next computation
 718         Object[] traversalTable = table; // reference to main table or copy
 719 
 720         public boolean hasNext() {
 721             Object[] tab = traversalTable;
 722             for (int i = index; i &lt; tab.length; i+=2) {
 723                 Object key = tab[i];
 724                 if (key != null) {
 725                     index = i;
 726                     return indexValid = true;
 727                 }
 728             }
 729             index = tab.length;
 730             return false;
 731         }
 732 
 733         protected int nextIndex() {
 734             if (modCount != expectedModCount)
 735                 throw new ConcurrentModificationException();
 736             if (!indexValid &amp;&amp; !hasNext())
 737                 throw new NoSuchElementException();
 738 
 739             indexValid = false;
 740             lastReturnedIndex = index;
 741             index += 2;
 742             return lastReturnedIndex;
 743         }
 744 
 745         public void remove() {
 746             if (lastReturnedIndex == -1)
 747                 throw new IllegalStateException();
 748             if (modCount != expectedModCount)
 749                 throw new ConcurrentModificationException();
 750 
 751             expectedModCount = ++modCount;
 752             int deletedSlot = lastReturnedIndex;
 753             lastReturnedIndex = -1;
 754             // back up index to revisit new contents after deletion
 755             index = deletedSlot;
 756             indexValid = false;
 757 
 758             // Removal code proceeds as in closeDeletion except that
 759             // it must catch the rare case where an element already
 760             // seen is swapped into a vacant slot that will be later
 761             // traversed by this iterator. We cannot allow future
 762             // next() calls to return it again.  The likelihood of
 763             // this occurring under 2/3 load factor is very slim, but
 764             // when it does happen, we must make a copy of the rest of
 765             // the table to use for the rest of the traversal. Since
 766             // this can only happen when we are near the end of the table,
 767             // even in these rare cases, this is not very expensive in
 768             // time or space.
 769 
 770             Object[] tab = traversalTable;
 771             int len = tab.length;
 772 
 773             int d = deletedSlot;
 774             Object key = tab[d];
 775             tab[d] = null;        // vacate the slot
 776             tab[d + 1] = null;
 777 
 778             // If traversing a copy, remove in real table.
 779             // We can skip gap-closure on copy.
 780             if (tab != IdentityHashMap.this.table) {
 781                 IdentityHashMap.this.remove(key);
 782                 expectedModCount = modCount;
 783                 return;
 784             }
 785 
 786             size--;
 787 
 788             Object item;
 789             for (int i = nextKeyIndex(d, len); (item = tab[i]) != null;
 790                  i = nextKeyIndex(i, len)) {
 791                 int r = hash(item, len);
 792                 // See closeDeletion for explanation of this conditional
 793                 if ((i &lt; r &amp;&amp; (r &lt;= d || d &lt;= i)) ||
 794                     (r &lt;= d &amp;&amp; d &lt;= i)) {
 795 
 796                     // If we are about to swap an already-seen element
 797                     // into a slot that may later be returned by next(),
 798                     // then clone the rest of table for use in future
 799                     // next() calls. It is OK that our copy will have
 800                     // a gap in the &quot;wrong&quot; place, since it will never
 801                     // be used for searching anyway.
 802 
 803                     if (i &lt; deletedSlot &amp;&amp; d &gt;= deletedSlot &amp;&amp;
 804                         traversalTable == IdentityHashMap.this.table) {
 805                         int remaining = len - deletedSlot;
 806                         Object[] newTable = new Object[remaining];
 807                         System.arraycopy(tab, deletedSlot,
 808                                          newTable, 0, remaining);
 809                         traversalTable = newTable;
 810                         index = 0;
 811                     }
 812 
 813                     tab[d] = item;
 814                     tab[d + 1] = tab[i + 1];
 815                     tab[i] = null;
 816                     tab[i + 1] = null;
 817                     d = i;
 818                 }
 819             }
 820         }
 821     }
 822 
 823     private class KeyIterator extends IdentityHashMapIterator&lt;K&gt; {
 824         @SuppressWarnings(&quot;unchecked&quot;)
 825         public K next() {
 826             return (K) unmaskNull(traversalTable[nextIndex()]);
 827         }
 828     }
 829 
 830     private class ValueIterator extends IdentityHashMapIterator&lt;V&gt; {
 831         @SuppressWarnings(&quot;unchecked&quot;)
 832         public V next() {
 833             return (V) traversalTable[nextIndex() + 1];
 834         }
 835     }
 836 
 837     private class EntryIterator
 838         extends IdentityHashMapIterator&lt;Map.Entry&lt;K,V&gt;&gt;
 839     {
 840         private Entry lastReturnedEntry;
 841 
 842         public Map.Entry&lt;K,V&gt; next() {
 843             lastReturnedEntry = new Entry(nextIndex());
 844             return lastReturnedEntry;
 845         }
 846 
 847         public void remove() {
 848             lastReturnedIndex =
 849                 ((null == lastReturnedEntry) ? -1 : lastReturnedEntry.index);
 850             super.remove();
 851             lastReturnedEntry.index = lastReturnedIndex;
 852             lastReturnedEntry = null;
 853         }
 854 
 855         private class Entry implements Map.Entry&lt;K,V&gt; {
 856             private int index;
 857 
 858             private Entry(int index) {
 859                 this.index = index;
 860             }
 861 
 862             @SuppressWarnings(&quot;unchecked&quot;)
 863             public K getKey() {
 864                 checkIndexForEntryUse();
 865                 return (K) unmaskNull(traversalTable[index]);
 866             }
 867 
 868             @SuppressWarnings(&quot;unchecked&quot;)
 869             public V getValue() {
 870                 checkIndexForEntryUse();
 871                 return (V) traversalTable[index+1];
 872             }
 873 
 874             @SuppressWarnings(&quot;unchecked&quot;)
 875             public V setValue(V value) {
 876                 checkIndexForEntryUse();
 877                 V oldValue = (V) traversalTable[index+1];
 878                 traversalTable[index+1] = value;
 879                 // if shadowing, force into main table
 880                 if (traversalTable != IdentityHashMap.this.table)
 881                     put((K) traversalTable[index], value);
 882                 return oldValue;
 883             }
 884 
 885             public boolean equals(Object o) {
 886                 if (index &lt; 0)
 887                     return super.equals(o);
 888 
 889                 if (!(o instanceof Map.Entry))
 890                     return false;
 891                 Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;
 892                 return (e.getKey() == unmaskNull(traversalTable[index]) &amp;&amp;
 893                        e.getValue() == traversalTable[index+1]);
 894             }
 895 
 896             public int hashCode() {
 897                 if (lastReturnedIndex &lt; 0)
 898                     return super.hashCode();
 899 
 900                 return (System.identityHashCode(unmaskNull(traversalTable[index])) ^
 901                        System.identityHashCode(traversalTable[index+1]));
 902             }
 903 
 904             public String toString() {
 905                 if (index &lt; 0)
 906                     return super.toString();
 907 
 908                 return (unmaskNull(traversalTable[index]) + &quot;=&quot;
 909                         + traversalTable[index+1]);
 910             }
 911 
 912             private void checkIndexForEntryUse() {
 913                 if (index &lt; 0)
 914                     throw new IllegalStateException(&quot;Entry was removed&quot;);
 915             }
 916         }
 917     }
 918 
 919     // Views
 920 
 921     /**
 922      * This field is initialized to contain an instance of the entry set
 923      * view the first time this view is requested.  The view is stateless,
 924      * so there&#39;s no reason to create more than one.
 925      */
 926     private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;
 927 
 928     /**
 929      * Returns an identity-based set view of the keys contained in this map.
 930      * The set is backed by the map, so changes to the map are reflected in
 931      * the set, and vice-versa.  If the map is modified while an iteration
 932      * over the set is in progress, the results of the iteration are
 933      * undefined.  The set supports element removal, which removes the
 934      * corresponding mapping from the map, via the {@code Iterator.remove},
 935      * {@code Set.remove}, {@code removeAll}, {@code retainAll}, and
 936      * {@code clear} methods.  It does not support the {@code add} or
 937      * {@code addAll} methods.
 938      *
 939      * &lt;p&gt;&lt;b&gt;While the object returned by this method implements the
 940      * {@code Set} interface, it does &lt;i&gt;not&lt;/i&gt; obey {@code Set&#39;s} general
 941      * contract.  Like its backing map, the set returned by this method
 942      * defines element equality as reference-equality rather than
 943      * object-equality.  This affects the behavior of its {@code contains},
 944      * {@code remove}, {@code containsAll}, {@code equals}, and
 945      * {@code hashCode} methods.&lt;/b&gt;
 946      *
 947      * &lt;p&gt;&lt;b&gt;The {@code equals} method of the returned set returns {@code true}
 948      * only if the specified object is a set containing exactly the same
 949      * object references as the returned set.  The symmetry and transitivity
 950      * requirements of the {@code Object.equals} contract may be violated if
 951      * the set returned by this method is compared to a normal set.  However,
 952      * the {@code Object.equals} contract is guaranteed to hold among sets
 953      * returned by this method.&lt;/b&gt;
 954      *
 955      * &lt;p&gt;The {@code hashCode} method of the returned set returns the sum of
 956      * the &lt;i&gt;identity hashcodes&lt;/i&gt; of the elements in the set, rather than
 957      * the sum of their hashcodes.  This is mandated by the change in the
 958      * semantics of the {@code equals} method, in order to enforce the
 959      * general contract of the {@code Object.hashCode} method among sets
 960      * returned by this method.
 961      *
 962      * @return an identity-based set view of the keys contained in this map
 963      * @see Object#equals(Object)
 964      * @see System#identityHashCode(Object)
 965      */
 966     public Set&lt;K&gt; keySet() {
 967         Set&lt;K&gt; ks = keySet;
 968         if (ks == null) {
 969             ks = new KeySet();
 970             keySet = ks;
 971         }
 972         return ks;
 973     }
 974 
 975     private class KeySet extends AbstractSet&lt;K&gt; {
 976         public Iterator&lt;K&gt; iterator() {
 977             return new KeyIterator();
 978         }
 979         public int size() {
 980             return size;
 981         }
 982         public boolean contains(Object o) {
 983             return containsKey(o);
 984         }
 985         public boolean remove(Object o) {
 986             int oldSize = size;
 987             IdentityHashMap.this.remove(o);
 988             return size != oldSize;
 989         }
 990         /*
 991          * Must revert from AbstractSet&#39;s impl to AbstractCollection&#39;s, as
 992          * the former contains an optimization that results in incorrect
 993          * behavior when c is a smaller &quot;normal&quot; (non-identity-based) Set.
 994          */
 995         public boolean removeAll(Collection&lt;?&gt; c) {
 996             Objects.requireNonNull(c);
 997             boolean modified = false;
 998             for (Iterator&lt;K&gt; i = iterator(); i.hasNext(); ) {
 999                 if (c.contains(i.next())) {
1000                     i.remove();
1001                     modified = true;
1002                 }
1003             }
1004             return modified;
1005         }
1006         public void clear() {
1007             IdentityHashMap.this.clear();
1008         }
1009         public int hashCode() {
1010             int result = 0;
1011             for (K key : this)
1012                 result += System.identityHashCode(key);
1013             return result;
1014         }
1015         public Object[] toArray() {
1016             return toArray(new Object[0]);
1017         }
1018         @SuppressWarnings(&quot;unchecked&quot;)
1019         public &lt;T&gt; T[] toArray(T[] a) {
1020             int expectedModCount = modCount;
1021             int size = size();
1022             if (a.length &lt; size)
1023                 a = (T[]) Array.newInstance(a.getClass().getComponentType(), size);
1024             Object[] tab = table;
1025             int ti = 0;
1026             for (int si = 0; si &lt; tab.length; si += 2) {
1027                 Object key;
1028                 if ((key = tab[si]) != null) { // key present ?
1029                     // more elements than expected -&gt; concurrent modification from other thread
1030                     if (ti &gt;= size) {
1031                         throw new ConcurrentModificationException();
1032                     }
1033                     a[ti++] = (T) unmaskNull(key); // unmask key
1034                 }
1035             }
1036             // fewer elements than expected or concurrent modification from other thread detected
1037             if (ti &lt; size || expectedModCount != modCount) {
1038                 throw new ConcurrentModificationException();
1039             }
1040             // final null marker as per spec
1041             if (ti &lt; a.length) {
1042                 a[ti] = null;
1043             }
1044             return a;
1045         }
1046 
1047         public Spliterator&lt;K&gt; spliterator() {
1048             return new KeySpliterator&lt;&gt;(IdentityHashMap.this, 0, -1, 0, 0);
1049         }
1050     }
1051 
1052     /**
1053      * Returns a {@link Collection} view of the values contained in this map.
1054      * The collection is backed by the map, so changes to the map are
1055      * reflected in the collection, and vice-versa.  If the map is
1056      * modified while an iteration over the collection is in progress,
1057      * the results of the iteration are undefined.  The collection
1058      * supports element removal, which removes the corresponding
1059      * mapping from the map, via the {@code Iterator.remove},
1060      * {@code Collection.remove}, {@code removeAll},
1061      * {@code retainAll} and {@code clear} methods.  It does not
1062      * support the {@code add} or {@code addAll} methods.
1063      *
1064      * &lt;p&gt;&lt;b&gt;While the object returned by this method implements the
1065      * {@code Collection} interface, it does &lt;i&gt;not&lt;/i&gt; obey
1066      * {@code Collection&#39;s} general contract.  Like its backing map,
1067      * the collection returned by this method defines element equality as
1068      * reference-equality rather than object-equality.  This affects the
1069      * behavior of its {@code contains}, {@code remove} and
1070      * {@code containsAll} methods.&lt;/b&gt;
1071      */
1072     public Collection&lt;V&gt; values() {
1073         Collection&lt;V&gt; vs = values;
1074         if (vs == null) {
1075             vs = new Values();
1076             values = vs;
1077         }
1078         return vs;
1079     }
1080 
1081     private class Values extends AbstractCollection&lt;V&gt; {
1082         public Iterator&lt;V&gt; iterator() {
1083             return new ValueIterator();
1084         }
1085         public int size() {
1086             return size;
1087         }
1088         public boolean contains(Object o) {
1089             return containsValue(o);
1090         }
1091         public boolean remove(Object o) {
1092             for (Iterator&lt;V&gt; i = iterator(); i.hasNext(); ) {
1093                 if (i.next() == o) {
1094                     i.remove();
1095                     return true;
1096                 }
1097             }
1098             return false;
1099         }
1100         public void clear() {
1101             IdentityHashMap.this.clear();
1102         }
1103         public Object[] toArray() {
1104             return toArray(new Object[0]);
1105         }
1106         @SuppressWarnings(&quot;unchecked&quot;)
1107         public &lt;T&gt; T[] toArray(T[] a) {
1108             int expectedModCount = modCount;
1109             int size = size();
1110             if (a.length &lt; size)
1111                 a = (T[]) Array.newInstance(a.getClass().getComponentType(), size);
1112             Object[] tab = table;
1113             int ti = 0;
1114             for (int si = 0; si &lt; tab.length; si += 2) {
1115                 if (tab[si] != null) { // key present ?
1116                     // more elements than expected -&gt; concurrent modification from other thread
1117                     if (ti &gt;= size) {
1118                         throw new ConcurrentModificationException();
1119                     }
1120                     a[ti++] = (T) tab[si+1]; // copy value
1121                 }
1122             }
1123             // fewer elements than expected or concurrent modification from other thread detected
1124             if (ti &lt; size || expectedModCount != modCount) {
1125                 throw new ConcurrentModificationException();
1126             }
1127             // final null marker as per spec
1128             if (ti &lt; a.length) {
1129                 a[ti] = null;
1130             }
1131             return a;
1132         }
1133 
1134         public Spliterator&lt;V&gt; spliterator() {
1135             return new ValueSpliterator&lt;&gt;(IdentityHashMap.this, 0, -1, 0, 0);
1136         }
1137     }
1138 
1139     /**
1140      * Returns a {@link Set} view of the mappings contained in this map.
1141      * Each element in the returned set is a reference-equality-based
1142      * {@code Map.Entry}.  The set is backed by the map, so changes
1143      * to the map are reflected in the set, and vice-versa.  If the
1144      * map is modified while an iteration over the set is in progress,
1145      * the results of the iteration are undefined.  The set supports
1146      * element removal, which removes the corresponding mapping from
1147      * the map, via the {@code Iterator.remove}, {@code Set.remove},
1148      * {@code removeAll}, {@code retainAll} and {@code clear}
1149      * methods.  It does not support the {@code add} or
1150      * {@code addAll} methods.
1151      *
1152      * &lt;p&gt;Like the backing map, the {@code Map.Entry} objects in the set
1153      * returned by this method define key and value equality as
1154      * reference-equality rather than object-equality.  This affects the
1155      * behavior of the {@code equals} and {@code hashCode} methods of these
1156      * {@code Map.Entry} objects.  A reference-equality based {@code Map.Entry
1157      * e} is equal to an object {@code o} if and only if {@code o} is a
1158      * {@code Map.Entry} and {@code e.getKey()==o.getKey() &amp;&amp;
1159      * e.getValue()==o.getValue()}.  To accommodate these equals
1160      * semantics, the {@code hashCode} method returns
1161      * {@code System.identityHashCode(e.getKey()) ^
1162      * System.identityHashCode(e.getValue())}.
1163      *
1164      * &lt;p&gt;&lt;b&gt;Owing to the reference-equality-based semantics of the
1165      * {@code Map.Entry} instances in the set returned by this method,
1166      * it is possible that the symmetry and transitivity requirements of
1167      * the {@link Object#equals(Object)} contract may be violated if any of
1168      * the entries in the set is compared to a normal map entry, or if
1169      * the set returned by this method is compared to a set of normal map
1170      * entries (such as would be returned by a call to this method on a normal
1171      * map).  However, the {@code Object.equals} contract is guaranteed to
1172      * hold among identity-based map entries, and among sets of such entries.
1173      * &lt;/b&gt;
1174      *
1175      * @return a set view of the identity-mappings contained in this map
1176      */
1177     public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
1178         Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;
1179         if (es != null)
1180             return es;
1181         else
1182             return entrySet = new EntrySet();
1183     }
1184 
1185     private class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {
1186         public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
1187             return new EntryIterator();
1188         }
1189         public boolean contains(Object o) {
1190             if (!(o instanceof Map.Entry))
1191                 return false;
1192             Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;)o;
1193             return containsMapping(entry.getKey(), entry.getValue());
1194         }
1195         public boolean remove(Object o) {
1196             if (!(o instanceof Map.Entry))
1197                 return false;
1198             Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;)o;
1199             return removeMapping(entry.getKey(), entry.getValue());
1200         }
1201         public int size() {
1202             return size;
1203         }
1204         public void clear() {
1205             IdentityHashMap.this.clear();
1206         }
1207         /*
1208          * Must revert from AbstractSet&#39;s impl to AbstractCollection&#39;s, as
1209          * the former contains an optimization that results in incorrect
1210          * behavior when c is a smaller &quot;normal&quot; (non-identity-based) Set.
1211          */
1212         public boolean removeAll(Collection&lt;?&gt; c) {
1213             Objects.requireNonNull(c);
1214             boolean modified = false;
1215             for (Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = iterator(); i.hasNext(); ) {
1216                 if (c.contains(i.next())) {
1217                     i.remove();
1218                     modified = true;
1219                 }
1220             }
1221             return modified;
1222         }
1223 
1224         public Object[] toArray() {
1225             return toArray(new Object[0]);
1226         }
1227 
1228         @SuppressWarnings(&quot;unchecked&quot;)
1229         public &lt;T&gt; T[] toArray(T[] a) {
1230             int expectedModCount = modCount;
1231             int size = size();
1232             if (a.length &lt; size)
1233                 a = (T[]) Array.newInstance(a.getClass().getComponentType(), size);
1234             Object[] tab = table;
1235             int ti = 0;
1236             for (int si = 0; si &lt; tab.length; si += 2) {
1237                 Object key;
1238                 if ((key = tab[si]) != null) { // key present ?
1239                     // more elements than expected -&gt; concurrent modification from other thread
1240                     if (ti &gt;= size) {
1241                         throw new ConcurrentModificationException();
1242                     }
1243                     a[ti++] = (T) new AbstractMap.SimpleEntry&lt;&gt;(unmaskNull(key), tab[si + 1]);
1244                 }
1245             }
1246             // fewer elements than expected or concurrent modification from other thread detected
1247             if (ti &lt; size || expectedModCount != modCount) {
1248                 throw new ConcurrentModificationException();
1249             }
1250             // final null marker as per spec
1251             if (ti &lt; a.length) {
1252                 a[ti] = null;
1253             }
1254             return a;
1255         }
1256 
1257         public Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() {
1258             return new EntrySpliterator&lt;&gt;(IdentityHashMap.this, 0, -1, 0, 0);
1259         }
1260     }
1261 
1262     @java.io.Serial
1263     private static final long serialVersionUID = 8188218128353913216L;
1264 
1265     /**
1266      * Saves the state of the {@code IdentityHashMap} instance to a stream
1267      * (i.e., serializes it).
1268      *
1269      * @serialData The &lt;i&gt;size&lt;/i&gt; of the HashMap (the number of key-value
1270      *          mappings) ({@code int}), followed by the key (Object) and
1271      *          value (Object) for each key-value mapping represented by the
1272      *          IdentityHashMap.  The key-value mappings are emitted in no
1273      *          particular order.
1274      */
1275     @java.io.Serial
1276     private void writeObject(java.io.ObjectOutputStream s)
1277         throws java.io.IOException  {
1278         // Write out and any hidden stuff
1279         s.defaultWriteObject();
1280 
1281         // Write out size (number of Mappings)
1282         s.writeInt(size);
1283 
1284         // Write out keys and values (alternating)
1285         Object[] tab = table;
1286         for (int i = 0; i &lt; tab.length; i += 2) {
1287             Object key = tab[i];
1288             if (key != null) {
1289                 s.writeObject(unmaskNull(key));
1290                 s.writeObject(tab[i + 1]);
1291             }
1292         }
1293     }
1294 
1295     /**
1296      * Reconstitutes the {@code IdentityHashMap} instance from a stream (i.e.,
1297      * deserializes it).
1298      */
1299     @java.io.Serial
1300     private void readObject(java.io.ObjectInputStream s)
1301         throws java.io.IOException, ClassNotFoundException  {
1302         // Read in any hidden stuff
1303         s.defaultReadObject();
1304 
1305         // Read in size (number of Mappings)
1306         int size = s.readInt();
1307         if (size &lt; 0)
1308             throw new java.io.StreamCorruptedException
1309                 (&quot;Illegal mappings count: &quot; + size);
1310         int cap = capacity(size);
1311         SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, cap);
1312         init(cap);
1313 
1314         // Read the keys and values, and put the mappings in the table
1315         for (int i=0; i&lt;size; i++) {
1316             @SuppressWarnings(&quot;unchecked&quot;)
1317                 K key = (K) s.readObject();
1318             @SuppressWarnings(&quot;unchecked&quot;)
1319                 V value = (V) s.readObject();
1320             putForCreate(key, value);
1321         }
1322     }
1323 
1324     /**
1325      * The put method for readObject.  It does not resize the table,
1326      * update modCount, etc.
1327      */
1328     private void putForCreate(K key, V value)
1329         throws java.io.StreamCorruptedException
1330     {
1331         Object k = maskNull(key);
1332         Object[] tab = table;
1333         int len = tab.length;
1334         int i = hash(k, len);
1335 
1336         Object item;
1337         while ( (item = tab[i]) != null) {
1338             if (item == k)
1339                 throw new java.io.StreamCorruptedException();
1340             i = nextKeyIndex(i, len);
1341         }
1342         tab[i] = k;
1343         tab[i + 1] = value;
1344     }
1345 
1346     @SuppressWarnings(&quot;unchecked&quot;)
1347     @Override
1348     public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {
1349         Objects.requireNonNull(action);
1350         int expectedModCount = modCount;
1351 
1352         Object[] t = table;
1353         for (int index = 0; index &lt; t.length; index += 2) {
1354             Object k = t[index];
1355             if (k != null) {
1356                 action.accept((K) unmaskNull(k), (V) t[index + 1]);
1357             }
1358 
1359             if (modCount != expectedModCount) {
1360                 throw new ConcurrentModificationException();
1361             }
1362         }
1363     }
1364 
1365     @SuppressWarnings(&quot;unchecked&quot;)
1366     @Override
1367     public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) {
1368         Objects.requireNonNull(function);
1369         int expectedModCount = modCount;
1370 
1371         Object[] t = table;
1372         for (int index = 0; index &lt; t.length; index += 2) {
1373             Object k = t[index];
1374             if (k != null) {
1375                 t[index + 1] = function.apply((K) unmaskNull(k), (V) t[index + 1]);
1376             }
1377 
1378             if (modCount != expectedModCount) {
1379                 throw new ConcurrentModificationException();
1380             }
1381         }
1382     }
1383 
1384     /**
1385      * Similar form as array-based Spliterators, but skips blank elements,
1386      * and guestimates size as decreasing by half per split.
1387      */
1388     static class IdentityHashMapSpliterator&lt;K,V&gt; {
1389         final IdentityHashMap&lt;K,V&gt; map;
1390         int index;             // current index, modified on advance/split
1391         int fence;             // -1 until first use; then one past last index
1392         int est;               // size estimate
1393         int expectedModCount;  // initialized when fence set
1394 
1395         IdentityHashMapSpliterator(IdentityHashMap&lt;K,V&gt; map, int origin,
1396                                    int fence, int est, int expectedModCount) {
1397             this.map = map;
1398             this.index = origin;
1399             this.fence = fence;
1400             this.est = est;
1401             this.expectedModCount = expectedModCount;
1402         }
1403 
1404         final int getFence() { // initialize fence and size on first use
1405             int hi;
1406             if ((hi = fence) &lt; 0) {
1407                 est = map.size;
1408                 expectedModCount = map.modCount;
1409                 hi = fence = map.table.length;
1410             }
1411             return hi;
1412         }
1413 
1414         public final long estimateSize() {
1415             getFence(); // force init
1416             return (long) est;
1417         }
1418     }
1419 
1420     static final class KeySpliterator&lt;K,V&gt;
1421         extends IdentityHashMapSpliterator&lt;K,V&gt;
1422         implements Spliterator&lt;K&gt; {
1423         KeySpliterator(IdentityHashMap&lt;K,V&gt; map, int origin, int fence, int est,
1424                        int expectedModCount) {
1425             super(map, origin, fence, est, expectedModCount);
1426         }
1427 
1428         public KeySpliterator&lt;K,V&gt; trySplit() {
1429             int hi = getFence(), lo = index, mid = ((lo + hi) &gt;&gt;&gt; 1) &amp; ~1;
1430             return (lo &gt;= mid) ? null :
1431                 new KeySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1,
1432                                      expectedModCount);
1433         }
1434 
1435         @SuppressWarnings(&quot;unchecked&quot;)
1436         public void forEachRemaining(Consumer&lt;? super K&gt; action) {
1437             if (action == null)
1438                 throw new NullPointerException();
1439             int i, hi, mc; Object key;
1440             IdentityHashMap&lt;K,V&gt; m; Object[] a;
1441             if ((m = map) != null &amp;&amp; (a = m.table) != null &amp;&amp;
1442                 (i = index) &gt;= 0 &amp;&amp; (index = hi = getFence()) &lt;= a.length) {
1443                 for (; i &lt; hi; i += 2) {
1444                     if ((key = a[i]) != null)
1445                         action.accept((K)unmaskNull(key));
1446                 }
1447                 if (m.modCount == expectedModCount)
1448                     return;
1449             }
1450             throw new ConcurrentModificationException();
1451         }
1452 
1453         @SuppressWarnings(&quot;unchecked&quot;)
1454         public boolean tryAdvance(Consumer&lt;? super K&gt; action) {
1455             if (action == null)
1456                 throw new NullPointerException();
1457             Object[] a = map.table;
1458             int hi = getFence();
1459             while (index &lt; hi) {
1460                 Object key = a[index];
1461                 index += 2;
1462                 if (key != null) {
1463                     action.accept((K)unmaskNull(key));
1464                     if (map.modCount != expectedModCount)
1465                         throw new ConcurrentModificationException();
1466                     return true;
1467                 }
1468             }
1469             return false;
1470         }
1471 
1472         public int characteristics() {
1473             return (fence &lt; 0 || est == map.size ? SIZED : 0) | Spliterator.DISTINCT;
1474         }
1475     }
1476 
1477     static final class ValueSpliterator&lt;K,V&gt;
1478         extends IdentityHashMapSpliterator&lt;K,V&gt;
1479         implements Spliterator&lt;V&gt; {
1480         ValueSpliterator(IdentityHashMap&lt;K,V&gt; m, int origin, int fence, int est,
1481                          int expectedModCount) {
1482             super(m, origin, fence, est, expectedModCount);
1483         }
1484 
1485         public ValueSpliterator&lt;K,V&gt; trySplit() {
1486             int hi = getFence(), lo = index, mid = ((lo + hi) &gt;&gt;&gt; 1) &amp; ~1;
1487             return (lo &gt;= mid) ? null :
1488                 new ValueSpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1,
1489                                        expectedModCount);
1490         }
1491 
1492         public void forEachRemaining(Consumer&lt;? super V&gt; action) {
1493             if (action == null)
1494                 throw new NullPointerException();
1495             int i, hi, mc;
1496             IdentityHashMap&lt;K,V&gt; m; Object[] a;
1497             if ((m = map) != null &amp;&amp; (a = m.table) != null &amp;&amp;
1498                 (i = index) &gt;= 0 &amp;&amp; (index = hi = getFence()) &lt;= a.length) {
1499                 for (; i &lt; hi; i += 2) {
1500                     if (a[i] != null) {
1501                         @SuppressWarnings(&quot;unchecked&quot;) V v = (V)a[i+1];
1502                         action.accept(v);
1503                     }
1504                 }
1505                 if (m.modCount == expectedModCount)
1506                     return;
1507             }
1508             throw new ConcurrentModificationException();
1509         }
1510 
1511         public boolean tryAdvance(Consumer&lt;? super V&gt; action) {
1512             if (action == null)
1513                 throw new NullPointerException();
1514             Object[] a = map.table;
1515             int hi = getFence();
1516             while (index &lt; hi) {
1517                 Object key = a[index];
1518                 @SuppressWarnings(&quot;unchecked&quot;) V v = (V)a[index+1];
1519                 index += 2;
1520                 if (key != null) {
1521                     action.accept(v);
1522                     if (map.modCount != expectedModCount)
1523                         throw new ConcurrentModificationException();
1524                     return true;
1525                 }
1526             }
1527             return false;
1528         }
1529 
1530         public int characteristics() {
1531             return (fence &lt; 0 || est == map.size ? SIZED : 0);
1532         }
1533 
1534     }
1535 
1536     static final class EntrySpliterator&lt;K,V&gt;
1537         extends IdentityHashMapSpliterator&lt;K,V&gt;
1538         implements Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; {
1539         EntrySpliterator(IdentityHashMap&lt;K,V&gt; m, int origin, int fence, int est,
1540                          int expectedModCount) {
1541             super(m, origin, fence, est, expectedModCount);
1542         }
1543 
1544         public EntrySpliterator&lt;K,V&gt; trySplit() {
1545             int hi = getFence(), lo = index, mid = ((lo + hi) &gt;&gt;&gt; 1) &amp; ~1;
1546             return (lo &gt;= mid) ? null :
1547                 new EntrySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1,
1548                                        expectedModCount);
1549         }
1550 
1551         public void forEachRemaining(Consumer&lt;? super Map.Entry&lt;K, V&gt;&gt; action) {
1552             if (action == null)
1553                 throw new NullPointerException();
1554             int i, hi, mc;
1555             IdentityHashMap&lt;K,V&gt; m; Object[] a;
1556             if ((m = map) != null &amp;&amp; (a = m.table) != null &amp;&amp;
1557                 (i = index) &gt;= 0 &amp;&amp; (index = hi = getFence()) &lt;= a.length) {
1558                 for (; i &lt; hi; i += 2) {
1559                     Object key = a[i];
1560                     if (key != null) {
1561                         @SuppressWarnings(&quot;unchecked&quot;) K k =
1562                             (K)unmaskNull(key);
1563                         @SuppressWarnings(&quot;unchecked&quot;) V v = (V)a[i+1];
1564                         action.accept
1565                             (new AbstractMap.SimpleImmutableEntry&lt;&gt;(k, v));
1566 
1567                     }
1568                 }
1569                 if (m.modCount == expectedModCount)
1570                     return;
1571             }
1572             throw new ConcurrentModificationException();
1573         }
1574 
1575         public boolean tryAdvance(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) {
1576             if (action == null)
1577                 throw new NullPointerException();
1578             Object[] a = map.table;
1579             int hi = getFence();
1580             while (index &lt; hi) {
1581                 Object key = a[index];
1582                 @SuppressWarnings(&quot;unchecked&quot;) V v = (V)a[index+1];
1583                 index += 2;
1584                 if (key != null) {
1585                     @SuppressWarnings(&quot;unchecked&quot;) K k =
1586                         (K)unmaskNull(key);
1587                     action.accept
1588                         (new AbstractMap.SimpleImmutableEntry&lt;&gt;(k, v));
1589                     if (map.modCount != expectedModCount)
1590                         throw new ConcurrentModificationException();
1591                     return true;
1592                 }
1593             }
1594             return false;
1595         }
1596 
1597         public int characteristics() {
1598             return (fence &lt; 0 || est == map.size ? SIZED : 0) | Spliterator.DISTINCT;
1599         }
1600     }
1601 
1602 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
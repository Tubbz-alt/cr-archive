<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/ClassLoader.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Class.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Enum.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/ClassLoader.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  22  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  23  * or visit www.oracle.com if you need additional information or have any
  24  * questions.
  25  */
  26 
  27 package java.lang;
  28 
  29 import java.io.InputStream;
  30 import java.io.IOException;
  31 import java.io.UncheckedIOException;
  32 import java.io.File;
  33 import java.lang.reflect.Constructor;
  34 import java.lang.reflect.InvocationTargetException;
  35 import java.net.URL;
  36 import java.security.AccessController;
  37 import java.security.AccessControlContext;
  38 import java.security.CodeSource;
  39 import java.security.PrivilegedAction;
  40 import java.security.ProtectionDomain;
  41 import java.security.cert.Certificate;
<span class="line-removed">  42 import java.util.ArrayDeque;</span>
  43 import java.util.ArrayList;
<span class="line-removed">  44 import java.util.Arrays;</span>
  45 import java.util.Collections;
<span class="line-removed">  46 import java.util.Deque;</span>
  47 import java.util.Enumeration;
  48 import java.util.HashMap;
<span class="line-removed">  49 import java.util.HashSet;</span>
  50 import java.util.Map;
  51 import java.util.NoSuchElementException;
  52 import java.util.Objects;
  53 import java.util.Set;
  54 import java.util.Spliterator;
  55 import java.util.Spliterators;
  56 import java.util.WeakHashMap;
  57 import java.util.concurrent.ConcurrentHashMap;
  58 import java.util.function.Supplier;
  59 import java.util.stream.Stream;
  60 import java.util.stream.StreamSupport;
  61 
<span class="line-removed">  62 import jdk.internal.loader.BuiltinClassLoader;</span>
<span class="line-removed">  63 import jdk.internal.perf.PerfCounter;</span>
  64 import jdk.internal.loader.BootLoader;

  65 import jdk.internal.loader.ClassLoaders;



  66 import jdk.internal.misc.Unsafe;
  67 import jdk.internal.misc.VM;
<span class="line-removed">  68 import jdk.internal.ref.CleanerFactory;</span>
  69 import jdk.internal.reflect.CallerSensitive;
  70 import jdk.internal.reflect.Reflection;
  71 import jdk.internal.util.StaticProperty;
  72 import sun.reflect.misc.ReflectUtil;
  73 import sun.security.util.SecurityConstants;
  74 
  75 /**
  76  * A class loader is an object that is responsible for loading classes. The
  77  * class {@code ClassLoader} is an abstract class.  Given the &lt;a
  78  * href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of a class, a class loader should attempt to
  79  * locate or generate data that constitutes a definition for the class.  A
  80  * typical strategy is to transform the name into a file name and then read a
  81  * &quot;class file&quot; of that name from a file system.
  82  *
  83  * &lt;p&gt; Every {@link java.lang.Class Class} object contains a {@link
  84  * Class#getClassLoader() reference} to the {@code ClassLoader} that defined
  85  * it.
  86  *
  87  * &lt;p&gt; {@code Class} objects for array classes are not created by class
  88  * loaders, but are created automatically as required by the Java runtime.
</pre>
<hr />
<pre>
2360      * Returns the absolute path name of a native library.  The VM invokes this
2361      * method to locate the native libraries that belong to classes loaded with
2362      * this class loader. If this method returns {@code null}, the VM
2363      * searches the library along the path specified as the
2364      * &quot;{@code java.library.path}&quot; property.
2365      *
2366      * @param  libname
2367      *         The library name
2368      *
2369      * @return  The absolute path of the native library
2370      *
2371      * @see  System#loadLibrary(String)
2372      * @see  System#mapLibraryName(String)
2373      *
2374      * @since  1.2
2375      */
2376     protected String findLibrary(String libname) {
2377         return null;
2378     }
2379 
<span class="line-modified">2380     /**</span>
<span class="line-removed">2381      * The inner class NativeLibrary denotes a loaded native library instance.</span>
<span class="line-removed">2382      * Every classloader contains a vector of loaded native libraries in the</span>
<span class="line-removed">2383      * private field {@code nativeLibraries}.  The native libraries loaded</span>
<span class="line-removed">2384      * into the system are entered into the {@code systemNativeLibraries}</span>
<span class="line-removed">2385      * vector.</span>
<span class="line-removed">2386      *</span>
<span class="line-removed">2387      * &lt;p&gt; Every native library requires a particular version of JNI. This is</span>
<span class="line-removed">2388      * denoted by the private {@code jniVersion} field.  This field is set by</span>
<span class="line-removed">2389      * the VM when it loads the library, and used by the VM to pass the correct</span>
<span class="line-removed">2390      * version of JNI to the native methods.  &lt;/p&gt;</span>
<span class="line-removed">2391      *</span>
<span class="line-removed">2392      * @see      ClassLoader</span>
<span class="line-removed">2393      * @since    1.2</span>
<span class="line-removed">2394      */</span>
<span class="line-removed">2395     static class NativeLibrary {</span>
<span class="line-removed">2396         // the class from which the library is loaded, also indicates</span>
<span class="line-removed">2397         // the loader this native library belongs.</span>
<span class="line-removed">2398         final Class&lt;?&gt; fromClass;</span>
<span class="line-removed">2399         // the canonicalized name of the native library.</span>
<span class="line-removed">2400         // or static library name</span>
<span class="line-removed">2401         final String name;</span>
<span class="line-removed">2402         // Indicates if the native library is linked into the VM</span>
<span class="line-removed">2403         final boolean isBuiltin;</span>
<span class="line-removed">2404 </span>
<span class="line-removed">2405         // opaque handle to native library, used in native code.</span>
<span class="line-removed">2406         long handle;</span>
<span class="line-removed">2407         // the version of JNI environment the native library requires.</span>
<span class="line-removed">2408         int jniVersion;</span>
<span class="line-removed">2409 </span>
<span class="line-removed">2410         native boolean load0(String name, boolean isBuiltin);</span>
<span class="line-removed">2411 </span>
<span class="line-removed">2412         native long findEntry(String name);</span>
<span class="line-removed">2413 </span>
<span class="line-removed">2414         NativeLibrary(Class&lt;?&gt; fromClass, String name, boolean isBuiltin) {</span>
<span class="line-removed">2415             this.name = name;</span>
<span class="line-removed">2416             this.fromClass = fromClass;</span>
<span class="line-removed">2417             this.isBuiltin = isBuiltin;</span>
<span class="line-removed">2418         }</span>
<span class="line-removed">2419 </span>
<span class="line-removed">2420         /*</span>
<span class="line-removed">2421          * Loads the native library and registers for cleanup when its</span>
<span class="line-removed">2422          * associated class loader is unloaded</span>
<span class="line-removed">2423          */</span>
<span class="line-removed">2424         boolean load() {</span>
<span class="line-removed">2425             if (handle != 0) {</span>
<span class="line-removed">2426                 throw new InternalError(&quot;Native library &quot; + name + &quot; has been loaded&quot;);</span>
<span class="line-removed">2427             }</span>
<span class="line-removed">2428 </span>
<span class="line-removed">2429             if (!load0(name, isBuiltin)) return false;</span>
<span class="line-removed">2430 </span>
<span class="line-removed">2431             // register the class loader for cleanup when unloaded</span>
<span class="line-removed">2432             // builtin class loaders are never unloaded</span>
<span class="line-removed">2433             ClassLoader loader = fromClass.getClassLoader();</span>
<span class="line-removed">2434             if (loader != null &amp;&amp;</span>
<span class="line-removed">2435                 loader != getBuiltinPlatformClassLoader() &amp;&amp;</span>
<span class="line-removed">2436                 loader != getBuiltinAppClassLoader()) {</span>
<span class="line-removed">2437                 CleanerFactory.cleaner().register(loader,</span>
<span class="line-removed">2438                         new Unloader(name, handle, isBuiltin));</span>
<span class="line-removed">2439             }</span>
<span class="line-removed">2440             return true;</span>
<span class="line-removed">2441         }</span>
<span class="line-removed">2442 </span>
<span class="line-removed">2443         static boolean loadLibrary(Class&lt;?&gt; fromClass, String name, boolean isBuiltin) {</span>
<span class="line-removed">2444             ClassLoader loader =</span>
<span class="line-removed">2445                 fromClass == null ? null : fromClass.getClassLoader();</span>
<span class="line-removed">2446 </span>
<span class="line-removed">2447             synchronized (loadedLibraryNames) {</span>
<span class="line-removed">2448                 Map&lt;String, NativeLibrary&gt; libs =</span>
<span class="line-removed">2449                     loader != null ? loader.nativeLibraries() : systemNativeLibraries();</span>
<span class="line-removed">2450                 if (libs.containsKey(name)) {</span>
<span class="line-removed">2451                     return true;</span>
<span class="line-removed">2452                 }</span>
<span class="line-removed">2453 </span>
<span class="line-removed">2454                 if (loadedLibraryNames.contains(name)) {</span>
<span class="line-removed">2455                     throw new UnsatisfiedLinkError(&quot;Native Library &quot; + name +</span>
<span class="line-removed">2456                         &quot; already loaded in another classloader&quot;);</span>
<span class="line-removed">2457                 }</span>
2458 
<span class="line-modified">2459                 /*</span>
<span class="line-modified">2460                  * When a library is being loaded, JNI_OnLoad function can cause</span>
<span class="line-modified">2461                  * another loadLibrary invocation that should succeed.</span>
<span class="line-modified">2462                  *</span>
<span class="line-modified">2463                  * We use a static stack to hold the list of libraries we are</span>
<span class="line-modified">2464                  * loading because this can happen only when called by the</span>
<span class="line-modified">2465                  * same thread because this block is synchronous.</span>
<span class="line-removed">2466                  *</span>
<span class="line-removed">2467                  * If there is a pending load operation for the library, we</span>
<span class="line-removed">2468                  * immediately return success; otherwise, we raise</span>
<span class="line-removed">2469                  * UnsatisfiedLinkError.</span>
<span class="line-removed">2470                  */</span>
<span class="line-removed">2471                 for (NativeLibrary lib : nativeLibraryContext) {</span>
<span class="line-removed">2472                     if (name.equals(lib.name)) {</span>
<span class="line-removed">2473                         if (loader == lib.fromClass.getClassLoader()) {</span>
<span class="line-removed">2474                             return true;</span>
<span class="line-removed">2475                         } else {</span>
<span class="line-removed">2476                             throw new UnsatisfiedLinkError(&quot;Native Library &quot; +</span>
<span class="line-removed">2477                                 name + &quot; is being loaded in another classloader&quot;);</span>
<span class="line-removed">2478                         }</span>
<span class="line-removed">2479                     }</span>
<span class="line-removed">2480                 }</span>
<span class="line-removed">2481                 NativeLibrary lib = new NativeLibrary(fromClass, name, isBuiltin);</span>
<span class="line-removed">2482                 // load the native library</span>
<span class="line-removed">2483                 nativeLibraryContext.push(lib);</span>
<span class="line-removed">2484                 try {</span>
<span class="line-removed">2485                     if (!lib.load()) return false;</span>
<span class="line-removed">2486                 } finally {</span>
<span class="line-removed">2487                     nativeLibraryContext.pop();</span>
<span class="line-removed">2488                 }</span>
<span class="line-removed">2489                 // register the loaded native library</span>
<span class="line-removed">2490                 loadedLibraryNames.add(name);</span>
<span class="line-removed">2491                 libs.put(name, lib);</span>
<span class="line-removed">2492             }</span>
<span class="line-removed">2493             return true;</span>
<span class="line-removed">2494         }</span>
<span class="line-removed">2495 </span>
<span class="line-removed">2496         // Invoked in the VM to determine the context class in JNI_OnLoad</span>
<span class="line-removed">2497         // and JNI_OnUnload</span>
<span class="line-removed">2498         static Class&lt;?&gt; getFromClass() {</span>
<span class="line-removed">2499             return nativeLibraryContext.peek().fromClass;</span>
2500         }
<span class="line-modified">2501 </span>
<span class="line-modified">2502         // native libraries being loaded</span>
<span class="line-modified">2503         static Deque&lt;NativeLibrary&gt; nativeLibraryContext = new ArrayDeque&lt;&gt;(8);</span>
<span class="line-modified">2504 </span>
<span class="line-modified">2505         /*</span>
<span class="line-modified">2506          * The run() method will be invoked when this class loader becomes</span>
<span class="line-modified">2507          * phantom reachable to unload the native library.</span>
<span class="line-modified">2508          */</span>
<span class="line-removed">2509         static class Unloader implements Runnable {</span>
<span class="line-removed">2510             // This represents the context when a native library is unloaded</span>
<span class="line-removed">2511             // and getFromClass() will return null,</span>
<span class="line-removed">2512             static final NativeLibrary UNLOADER =</span>
<span class="line-removed">2513                 new NativeLibrary(null, &quot;dummy&quot;, false);</span>
<span class="line-removed">2514             final String name;</span>
<span class="line-removed">2515             final long handle;</span>
<span class="line-removed">2516             final boolean isBuiltin;</span>
<span class="line-removed">2517 </span>
<span class="line-removed">2518             Unloader(String name, long handle, boolean isBuiltin) {</span>
<span class="line-removed">2519                 if (handle == 0) {</span>
<span class="line-removed">2520                     throw new IllegalArgumentException(</span>
<span class="line-removed">2521                         &quot;Invalid handle for native library &quot; + name);</span>
<span class="line-removed">2522                 }</span>
<span class="line-removed">2523 </span>
<span class="line-removed">2524                 this.name = name;</span>
<span class="line-removed">2525                 this.handle = handle;</span>
<span class="line-removed">2526                 this.isBuiltin = isBuiltin;</span>
<span class="line-removed">2527             }</span>
<span class="line-removed">2528 </span>
<span class="line-removed">2529             @Override</span>
<span class="line-removed">2530             public void run() {</span>
<span class="line-removed">2531                 synchronized (loadedLibraryNames) {</span>
<span class="line-removed">2532                     /* remove the native library name */</span>
<span class="line-removed">2533                     loadedLibraryNames.remove(name);</span>
<span class="line-removed">2534                     nativeLibraryContext.push(UNLOADER);</span>
<span class="line-removed">2535                     try {</span>
<span class="line-removed">2536                         unload(name, isBuiltin, handle);</span>
<span class="line-removed">2537                     } finally {</span>
<span class="line-removed">2538                         nativeLibraryContext.pop();</span>
<span class="line-removed">2539                     }</span>
<span class="line-removed">2540 </span>
<span class="line-removed">2541                 }</span>
2542             }


2543         }
2544 
<span class="line-modified">2545         // JNI FindClass expects the caller class if invoked from JNI_OnLoad</span>
<span class="line-modified">2546         // and JNI_OnUnload is NativeLibrary class</span>
<span class="line-modified">2547         static native void unload(String name, boolean isBuiltin, long handle);</span>
<span class="line-modified">2548     }</span>
<span class="line-modified">2549 </span>
<span class="line-modified">2550     /**</span>
<span class="line-modified">2551      * Holds system and user library paths derived from the</span>
<span class="line-removed">2552      * {@code java.library.path} and {@code sun.boot.library.path} system</span>
<span class="line-removed">2553      * properties. The system properties are eagerly read at bootstrap, then</span>
<span class="line-removed">2554      * lazily parsed on first use to avoid initialization ordering issues.</span>
<span class="line-removed">2555      */</span>
<span class="line-removed">2556     private static class LibraryPaths {</span>
<span class="line-removed">2557         static final String[] USER =</span>
<span class="line-removed">2558                 ClassLoaderHelper.parsePath(StaticProperty.javaLibraryPath());</span>
<span class="line-removed">2559         static final String[] SYS =</span>
<span class="line-removed">2560                 ClassLoaderHelper.parsePath(StaticProperty.sunBootLibraryPath());</span>
<span class="line-removed">2561     }</span>
<span class="line-removed">2562 </span>
<span class="line-removed">2563     // Invoked in the java.lang.Runtime class to implement load and loadLibrary.</span>
<span class="line-removed">2564     static void loadLibrary(Class&lt;?&gt; fromClass, String name,</span>
<span class="line-removed">2565                             boolean isAbsolute) {</span>
<span class="line-removed">2566         ClassLoader loader =</span>
<span class="line-removed">2567             (fromClass == null) ? null : fromClass.getClassLoader();</span>
<span class="line-removed">2568 </span>
<span class="line-removed">2569         if (isAbsolute) {</span>
<span class="line-removed">2570             if (loadLibrary0(fromClass, new File(name))) {</span>
<span class="line-removed">2571                 return;</span>
<span class="line-removed">2572             }</span>
<span class="line-removed">2573             throw new UnsatisfiedLinkError(&quot;Can&#39;t load library: &quot; + name);</span>
<span class="line-removed">2574         }</span>
<span class="line-removed">2575         if (loader != null) {</span>
<span class="line-removed">2576             String libfilename = loader.findLibrary(name);</span>
<span class="line-removed">2577             if (libfilename != null) {</span>
<span class="line-removed">2578                 File libfile = new File(libfilename);</span>
<span class="line-removed">2579                 if (!libfile.isAbsolute()) {</span>
<span class="line-removed">2580                     throw new UnsatisfiedLinkError(</span>
2581                         &quot;ClassLoader.findLibrary failed to return an absolute path: &quot; + libfilename);
<span class="line-removed">2582                 }</span>
<span class="line-removed">2583                 if (loadLibrary0(fromClass, libfile)) {</span>
<span class="line-removed">2584                     return;</span>
<span class="line-removed">2585                 }</span>
<span class="line-removed">2586                 throw new UnsatisfiedLinkError(&quot;Can&#39;t load &quot; + libfilename);</span>
2587             }
<span class="line-modified">2588         }</span>
<span class="line-modified">2589         for (String sysPath : LibraryPaths.SYS) {</span>
<span class="line-modified">2590             File libfile = new File(sysPath, System.mapLibraryName(name));</span>
<span class="line-removed">2591             if (loadLibrary0(fromClass, libfile)) {</span>
<span class="line-removed">2592                 return;</span>
<span class="line-removed">2593             }</span>
<span class="line-removed">2594             libfile = ClassLoaderHelper.mapAlternativeName(libfile);</span>
<span class="line-removed">2595             if (libfile != null &amp;&amp; loadLibrary0(fromClass, libfile)) {</span>
<span class="line-removed">2596                 return;</span>
2597             }

2598         }
<span class="line-modified">2599         if (loader != null) {</span>
<span class="line-modified">2600             for (String userPath : LibraryPaths.USER) {</span>
<span class="line-modified">2601                 File libfile = new File(userPath, System.mapLibraryName(name));</span>
<span class="line-modified">2602                 if (loadLibrary0(fromClass, libfile)) {</span>
<span class="line-removed">2603                     return;</span>
<span class="line-removed">2604                 }</span>
<span class="line-removed">2605                 libfile = ClassLoaderHelper.mapAlternativeName(libfile);</span>
<span class="line-removed">2606                 if (libfile != null &amp;&amp; loadLibrary0(fromClass, libfile)) {</span>
<span class="line-removed">2607                     return;</span>
<span class="line-removed">2608                 }</span>
<span class="line-removed">2609             }</span>
2610         }

2611         // Oops, it failed
2612         throw new UnsatisfiedLinkError(&quot;no &quot; + name +
<span class="line-modified">2613             &quot; in java.library.path: &quot; + Arrays.toString(LibraryPaths.USER));</span>
<span class="line-removed">2614     }</span>
<span class="line-removed">2615 </span>
<span class="line-removed">2616     private static native String findBuiltinLib(String name);</span>
<span class="line-removed">2617 </span>
<span class="line-removed">2618     private static boolean loadLibrary0(Class&lt;?&gt; fromClass, final File file) {</span>
<span class="line-removed">2619         // Check to see if we&#39;re attempting to access a static library</span>
<span class="line-removed">2620         String name = findBuiltinLib(file.getName());</span>
<span class="line-removed">2621         boolean isBuiltin = (name != null);</span>
<span class="line-removed">2622         if (!isBuiltin) {</span>
<span class="line-removed">2623             name = AccessController.doPrivileged(</span>
<span class="line-removed">2624                 new PrivilegedAction&lt;&gt;() {</span>
<span class="line-removed">2625                     public String run() {</span>
<span class="line-removed">2626                         try {</span>
<span class="line-removed">2627                             return file.exists() ? file.getCanonicalPath() : null;</span>
<span class="line-removed">2628                         } catch (IOException e) {</span>
<span class="line-removed">2629                             return null;</span>
<span class="line-removed">2630                         }</span>
<span class="line-removed">2631                     }</span>
<span class="line-removed">2632                 });</span>
<span class="line-removed">2633             if (name == null) {</span>
<span class="line-removed">2634                 return false;</span>
<span class="line-removed">2635             }</span>
<span class="line-removed">2636         }</span>
<span class="line-removed">2637         return NativeLibrary.loadLibrary(fromClass, name, isBuiltin);</span>
2638     }
2639 
2640     /*
2641      * Invoked in the VM class linking code.
2642      */
2643     private static long findNative(ClassLoader loader, String entryName) {
<span class="line-modified">2644         Map&lt;String, NativeLibrary&gt; libs =</span>
<span class="line-modified">2645             loader != null ? loader.nativeLibraries() : systemNativeLibraries();</span>
<span class="line-modified">2646         if (libs.isEmpty())</span>
<span class="line-modified">2647             return 0;</span>
<span class="line-removed">2648 </span>
<span class="line-removed">2649         // the native libraries map may be updated in another thread</span>
<span class="line-removed">2650         // when a native library is being loaded.  No symbol will be</span>
<span class="line-removed">2651         // searched from it yet.</span>
<span class="line-removed">2652         for (NativeLibrary lib : libs.values()) {</span>
<span class="line-removed">2653             long entry = lib.findEntry(entryName);</span>
<span class="line-removed">2654             if (entry != 0) return entry;</span>
<span class="line-removed">2655         }</span>
<span class="line-removed">2656         return 0;</span>
<span class="line-removed">2657     }</span>
<span class="line-removed">2658 </span>
<span class="line-removed">2659     // All native library names we&#39;ve loaded.</span>
<span class="line-removed">2660     // This also serves as the lock to obtain nativeLibraries</span>
<span class="line-removed">2661     // and write to nativeLibraryContext.</span>
<span class="line-removed">2662     private static final Set&lt;String&gt; loadedLibraryNames = new HashSet&lt;&gt;();</span>
<span class="line-removed">2663 </span>
<span class="line-removed">2664     // Native libraries belonging to system classes.</span>
<span class="line-removed">2665     private static volatile Map&lt;String, NativeLibrary&gt; systemNativeLibraries;</span>
<span class="line-removed">2666 </span>
<span class="line-removed">2667     // Native libraries associated with the class loader.</span>
<span class="line-removed">2668     private volatile Map&lt;String, NativeLibrary&gt; nativeLibraries;</span>
<span class="line-removed">2669 </span>
<span class="line-removed">2670     /*</span>
<span class="line-removed">2671      * Returns the native libraries map associated with bootstrap class loader</span>
<span class="line-removed">2672      * This method will create the map at the first time when called.</span>
<span class="line-removed">2673      */</span>
<span class="line-removed">2674     private static Map&lt;String, NativeLibrary&gt; systemNativeLibraries() {</span>
<span class="line-removed">2675         Map&lt;String, NativeLibrary&gt; libs = systemNativeLibraries;</span>
<span class="line-removed">2676         if (libs == null) {</span>
<span class="line-removed">2677             synchronized (loadedLibraryNames) {</span>
<span class="line-removed">2678                 libs = systemNativeLibraries;</span>
<span class="line-removed">2679                 if (libs == null) {</span>
<span class="line-removed">2680                     libs = systemNativeLibraries = new ConcurrentHashMap&lt;&gt;();</span>
<span class="line-removed">2681                 }</span>
<span class="line-removed">2682             }</span>
<span class="line-removed">2683         }</span>
<span class="line-removed">2684         return libs;</span>
<span class="line-removed">2685     }</span>
<span class="line-removed">2686 </span>
<span class="line-removed">2687     /*</span>
<span class="line-removed">2688      * Returns the native libraries map associated with this class loader</span>
<span class="line-removed">2689      * This method will create the map at the first time when called.</span>
<span class="line-removed">2690      */</span>
<span class="line-removed">2691     private Map&lt;String, NativeLibrary&gt; nativeLibraries() {</span>
<span class="line-removed">2692         Map&lt;String, NativeLibrary&gt; libs = nativeLibraries;</span>
<span class="line-removed">2693         if (libs == null) {</span>
<span class="line-removed">2694             synchronized (loadedLibraryNames) {</span>
<span class="line-removed">2695                 libs = nativeLibraries;</span>
<span class="line-removed">2696                 if (libs == null) {</span>
<span class="line-removed">2697                     libs = nativeLibraries = new ConcurrentHashMap&lt;&gt;();</span>
<span class="line-removed">2698                 }</span>
<span class="line-removed">2699             }</span>
2700         }
<span class="line-removed">2701         return libs;</span>
2702     }
2703 
2704     // -- Assertion management --
2705 
2706     final Object assertionLock;
2707 
2708     // The default toggle for assertion checking.
2709     // @GuardedBy(&quot;assertionLock&quot;)
2710     private boolean defaultAssertionStatus = false;
2711 
2712     // Maps String packageName to Boolean package default assertion status Note
2713     // that the default package is placed under a null map key.  If this field
2714     // is null then we are delegating assertion status queries to the VM, i.e.,
2715     // none of this ClassLoader&#39;s assertion status modification methods have
2716     // been invoked.
2717     // @GuardedBy(&quot;assertionLock&quot;)
2718     private Map&lt;String, Boolean&gt; packageAssertionStatus = null;
2719 
2720     // Maps String fullyQualifiedClassName to Boolean assertionStatus If this
2721     // field is null then we are delegating assertion status queries to the VM,
</pre>
</td>
<td>
<hr />
<pre>
  22  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  23  * or visit www.oracle.com if you need additional information or have any
  24  * questions.
  25  */
  26 
  27 package java.lang;
  28 
  29 import java.io.InputStream;
  30 import java.io.IOException;
  31 import java.io.UncheckedIOException;
  32 import java.io.File;
  33 import java.lang.reflect.Constructor;
  34 import java.lang.reflect.InvocationTargetException;
  35 import java.net.URL;
  36 import java.security.AccessController;
  37 import java.security.AccessControlContext;
  38 import java.security.CodeSource;
  39 import java.security.PrivilegedAction;
  40 import java.security.ProtectionDomain;
  41 import java.security.cert.Certificate;

  42 import java.util.ArrayList;

  43 import java.util.Collections;

  44 import java.util.Enumeration;
  45 import java.util.HashMap;

  46 import java.util.Map;
  47 import java.util.NoSuchElementException;
  48 import java.util.Objects;
  49 import java.util.Set;
  50 import java.util.Spliterator;
  51 import java.util.Spliterators;
  52 import java.util.WeakHashMap;
  53 import java.util.concurrent.ConcurrentHashMap;
  54 import java.util.function.Supplier;
  55 import java.util.stream.Stream;
  56 import java.util.stream.StreamSupport;
  57 


  58 import jdk.internal.loader.BootLoader;
<span class="line-added">  59 import jdk.internal.loader.BuiltinClassLoader;</span>
  60 import jdk.internal.loader.ClassLoaders;
<span class="line-added">  61 import jdk.internal.loader.NativeLibrary;</span>
<span class="line-added">  62 import jdk.internal.loader.NativeLibraries;</span>
<span class="line-added">  63 import jdk.internal.perf.PerfCounter;</span>
  64 import jdk.internal.misc.Unsafe;
  65 import jdk.internal.misc.VM;

  66 import jdk.internal.reflect.CallerSensitive;
  67 import jdk.internal.reflect.Reflection;
  68 import jdk.internal.util.StaticProperty;
  69 import sun.reflect.misc.ReflectUtil;
  70 import sun.security.util.SecurityConstants;
  71 
  72 /**
  73  * A class loader is an object that is responsible for loading classes. The
  74  * class {@code ClassLoader} is an abstract class.  Given the &lt;a
  75  * href=&quot;#binary-name&quot;&gt;binary name&lt;/a&gt; of a class, a class loader should attempt to
  76  * locate or generate data that constitutes a definition for the class.  A
  77  * typical strategy is to transform the name into a file name and then read a
  78  * &quot;class file&quot; of that name from a file system.
  79  *
  80  * &lt;p&gt; Every {@link java.lang.Class Class} object contains a {@link
  81  * Class#getClassLoader() reference} to the {@code ClassLoader} that defined
  82  * it.
  83  *
  84  * &lt;p&gt; {@code Class} objects for array classes are not created by class
  85  * loaders, but are created automatically as required by the Java runtime.
</pre>
<hr />
<pre>
2357      * Returns the absolute path name of a native library.  The VM invokes this
2358      * method to locate the native libraries that belong to classes loaded with
2359      * this class loader. If this method returns {@code null}, the VM
2360      * searches the library along the path specified as the
2361      * &quot;{@code java.library.path}&quot; property.
2362      *
2363      * @param  libname
2364      *         The library name
2365      *
2366      * @return  The absolute path of the native library
2367      *
2368      * @see  System#loadLibrary(String)
2369      * @see  System#mapLibraryName(String)
2370      *
2371      * @since  1.2
2372      */
2373     protected String findLibrary(String libname) {
2374         return null;
2375     }
2376 
<span class="line-modified">2377     private final NativeLibraries libraries = new NativeLibraries(this);</span>













































































2378 
<span class="line-modified">2379     // Invoked in the java.lang.Runtime class to implement load and loadLibrary.</span>
<span class="line-modified">2380     static NativeLibrary loadLibrary(Class&lt;?&gt; fromClass, File file) {</span>
<span class="line-modified">2381         ClassLoader loader = (fromClass == null) ? null : fromClass.getClassLoader();</span>
<span class="line-modified">2382         NativeLibraries libs = loader != null ? loader.libraries : BootLoader.getNativeLibraries();</span>
<span class="line-modified">2383         NativeLibrary nl = libs.loadLibrary(fromClass, file);</span>
<span class="line-modified">2384         if (nl != null) {</span>
<span class="line-modified">2385             return nl;</span>


































2386         }
<span class="line-modified">2387         throw new UnsatisfiedLinkError(&quot;Can&#39;t load library: &quot; + file);</span>
<span class="line-modified">2388     }</span>
<span class="line-modified">2389     static NativeLibrary loadLibrary(Class&lt;?&gt; fromClass, String name) {</span>
<span class="line-modified">2390         ClassLoader loader = (fromClass == null) ? null : fromClass.getClassLoader();</span>
<span class="line-modified">2391         if (loader == null) {</span>
<span class="line-modified">2392             NativeLibrary nl = BootLoader.getNativeLibraries().loadLibrary(fromClass, name);</span>
<span class="line-modified">2393             if (nl != null) {</span>
<span class="line-modified">2394                 return nl;</span>

































2395             }
<span class="line-added">2396             throw new UnsatisfiedLinkError(&quot;no &quot; + name +</span>
<span class="line-added">2397                     &quot; in system library path: &quot; + StaticProperty.sunBootLibraryPath());</span>
2398         }
2399 
<span class="line-modified">2400         NativeLibraries libs = loader.libraries;</span>
<span class="line-modified">2401         // First load from the file returned from ClassLoader::findLibrary, if found.</span>
<span class="line-modified">2402         String libfilename = loader.findLibrary(name);</span>
<span class="line-modified">2403         if (libfilename != null) {</span>
<span class="line-modified">2404             File libfile = new File(libfilename);</span>
<span class="line-modified">2405             if (!libfile.isAbsolute()) {</span>
<span class="line-modified">2406                 throw new UnsatisfiedLinkError(</span>





























2407                         &quot;ClassLoader.findLibrary failed to return an absolute path: &quot; + libfilename);





2408             }
<span class="line-modified">2409             NativeLibrary nl = libs.loadLibrary(fromClass, libfile);</span>
<span class="line-modified">2410             if (nl != null) {</span>
<span class="line-modified">2411                 return nl;</span>






2412             }
<span class="line-added">2413             throw new UnsatisfiedLinkError(&quot;Can&#39;t load &quot; + libfilename);</span>
2414         }
<span class="line-modified">2415         // Then load from system library path and java library path</span>
<span class="line-modified">2416         NativeLibrary nl = libs.loadLibrary(fromClass, name);</span>
<span class="line-modified">2417         if (nl != null) {</span>
<span class="line-modified">2418             return nl;</span>







2419         }
<span class="line-added">2420 </span>
2421         // Oops, it failed
2422         throw new UnsatisfiedLinkError(&quot;no &quot; + name +
<span class="line-modified">2423                 &quot; in java.library.path: &quot; + StaticProperty.javaLibraryPath());</span>
























2424     }
2425 
2426     /*
2427      * Invoked in the VM class linking code.
2428      */
2429     private static long findNative(ClassLoader loader, String entryName) {
<span class="line-modified">2430         if (loader == null) {</span>
<span class="line-modified">2431             return BootLoader.getNativeLibraries().find(entryName);</span>
<span class="line-modified">2432         } else {</span>
<span class="line-modified">2433             return loader.libraries.find(entryName);</span>




















































2434         }

2435     }
2436 
2437     // -- Assertion management --
2438 
2439     final Object assertionLock;
2440 
2441     // The default toggle for assertion checking.
2442     // @GuardedBy(&quot;assertionLock&quot;)
2443     private boolean defaultAssertionStatus = false;
2444 
2445     // Maps String packageName to Boolean package default assertion status Note
2446     // that the default package is placed under a null map key.  If this field
2447     // is null then we are delegating assertion status queries to the VM, i.e.,
2448     // none of this ClassLoader&#39;s assertion status modification methods have
2449     // been invoked.
2450     // @GuardedBy(&quot;assertionLock&quot;)
2451     private Map&lt;String, Boolean&gt; packageAssertionStatus = null;
2452 
2453     // Maps String fullyQualifiedClassName to Boolean assertionStatus If this
2454     // field is null then we are delegating assertion status queries to the VM,
</pre>
</td>
</tr>
</table>
<center><a href="Class.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Enum.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
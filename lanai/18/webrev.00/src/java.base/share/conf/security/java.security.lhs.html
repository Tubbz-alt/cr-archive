<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/conf/security/java.security</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 #
   2 # This is the &quot;master security properties file&quot;.
   3 #
   4 # An alternate java.security properties file may be specified
   5 # from the command line via the system property
   6 #
   7 #    -Djava.security.properties=&lt;URL&gt;
   8 #
   9 # This properties file appends to the master security properties file.
  10 # If both properties files specify values for the same key, the value
  11 # from the command-line properties file is selected, as it is the last
  12 # one loaded.
  13 #
  14 # Also, if you specify
  15 #
  16 #    -Djava.security.properties==&lt;URL&gt; (2 equals),
  17 #
  18 # then that properties file completely overrides the master security
  19 # properties file.
  20 #
  21 # To disable the ability to specify an additional properties file from
  22 # the command line, set the key security.overridePropertiesFile
  23 # to false in the master security properties file. It is set to true
  24 # by default.
  25 
  26 # In this file, various security properties are set for use by
  27 # java.security classes. This is where users can statically register
  28 # Cryptography Package Providers (&quot;providers&quot; for short). The term
  29 # &quot;provider&quot; refers to a package or set of packages that supply a
  30 # concrete implementation of a subset of the cryptography aspects of
  31 # the Java Security API. A provider may, for example, implement one or
  32 # more digital signature algorithms or message digest algorithms.
  33 #
  34 # Each provider must implement a subclass of the Provider class.
  35 # To register a provider in this master security properties file,
  36 # specify the provider and priority in the format
  37 #
  38 #    security.provider.&lt;n&gt;=&lt;provName | className&gt;
  39 #
  40 # This declares a provider, and specifies its preference
  41 # order n. The preference order is the order in which providers are
  42 # searched for requested algorithms (when no specific provider is
  43 # requested). The order is 1-based; 1 is the most preferred, followed
  44 # by 2, and so on.
  45 #
  46 # &lt;provName&gt; must specify the name of the Provider as passed to its super
  47 # class java.security.Provider constructor. This is for providers loaded
  48 # through the ServiceLoader mechanism.
  49 #
  50 # &lt;className&gt; must specify the subclass of the Provider class whose
  51 # constructor sets the values of various properties that are required
  52 # for the Java Security API to look up the algorithms or other
  53 # facilities implemented by the provider. This is for providers loaded
  54 # through classpath.
  55 #
  56 # Note: Providers can be dynamically registered instead by calls to
  57 # either the addProvider or insertProviderAt method in the Security
  58 # class.
  59 
  60 #
  61 # List of providers and their preference orders (see above):
  62 #
  63 #ifdef solaris
  64 # Note: The OracleUcrypto provider is deprecated and subject to removal in
  65 # a future version of the JDK.
  66 security.provider.tbd=OracleUcrypto
  67 security.provider.tbd=SunPKCS11 ${java.home}/conf/security/sunpkcs11-solaris.cfg
  68 #endif
  69 security.provider.tbd=SUN
  70 security.provider.tbd=SunRsaSign
  71 security.provider.tbd=SunEC
  72 security.provider.tbd=SunJSSE
  73 security.provider.tbd=SunJCE
  74 security.provider.tbd=SunJGSS
  75 security.provider.tbd=SunSASL
  76 security.provider.tbd=XMLDSig
  77 security.provider.tbd=SunPCSC
  78 security.provider.tbd=JdkLDAP
  79 security.provider.tbd=JdkSASL
  80 #ifdef windows
  81 security.provider.tbd=SunMSCAPI
  82 #endif
  83 #ifdef macosx
  84 security.provider.tbd=Apple
  85 #endif
  86 #ifndef solaris
  87 security.provider.tbd=SunPKCS11
  88 #endif
  89 
  90 #
  91 # A list of preferred providers for specific algorithms. These providers will
  92 # be searched for matching algorithms before the list of registered providers.
  93 # Entries containing errors (parsing, etc) will be ignored. Use the
  94 # -Djava.security.debug=jca property to debug these errors.
  95 #
  96 # The property is a comma-separated list of serviceType.algorithm:provider
  97 # entries. The serviceType (example: &quot;MessageDigest&quot;) is optional, and if
  98 # not specified, the algorithm applies to all service types that support it.
  99 # The algorithm is the standard algorithm name or transformation.
 100 # Transformations can be specified in their full standard name
 101 # (ex: AES/CBC/PKCS5Padding), or as partial matches (ex: AES, AES/CBC).
 102 # The provider is the name of the provider. Any provider that does not
 103 # also appear in the registered list will be ignored.
 104 #
 105 # There is a special serviceType for this property only to group a set of
 106 # algorithms together. The type is &quot;Group&quot; and is followed by an algorithm
 107 # keyword. Groups are to simplify and lessen the entries on the property
 108 # line. Current groups are:
 109 #   Group.SHA2 = SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, SHA-512/256
 110 #   Group.HmacSHA2 = HmacSHA224, HmacSHA256, HmacSHA384, HmacSHA512
 111 #   Group.SHA2RSA = SHA224withRSA, SHA256withRSA, SHA384withRSA, SHA512withRSA
 112 #   Group.SHA2DSA = SHA224withDSA, SHA256withDSA, SHA384withDSA, SHA512withDSA
 113 #   Group.SHA2ECDSA = SHA224withECDSA, SHA256withECDSA, SHA384withECDSA, \
 114 #                     SHA512withECDSA
 115 #   Group.SHA3 = SHA3-224, SHA3-256, SHA3-384, SHA3-512
 116 #   Group.HmacSHA3 = HmacSHA3-224, HmacSHA3-256, HmacSHA3-384, HmacSHA3-512
 117 #
 118 # Example:
 119 #   jdk.security.provider.preferred=AES/GCM/NoPadding:SunJCE, \
 120 #         MessageDigest.SHA-256:SUN, Group.HmacSHA2:SunJCE
 121 #
 122 #ifdef solaris-sparc
 123 # Optional Solaris-SPARC configuration for non-FIPS 140 configurations.
 124 #   jdk.security.provider.preferred=AES:SunJCE, SHA1:SUN, Group.SHA2:SUN, \
 125 #   HmacSHA1:SunJCE, Group.HmacSHA2:SunJCE
 126 #
 127 #endif
 128 #jdk.security.provider.preferred=
 129 
 130 
 131 #
 132 # Sun Provider SecureRandom seed source.
 133 #
 134 # Select the primary source of seed data for the &quot;NativePRNG&quot;, &quot;SHA1PRNG&quot;
 135 # and &quot;DRBG&quot; SecureRandom implementations in the &quot;Sun&quot; provider.
 136 # (Other SecureRandom implementations might also use this property.)
 137 #
 138 # On Unix-like systems (for example, Solaris/Linux/MacOS), the
 139 # &quot;NativePRNG&quot;, &quot;SHA1PRNG&quot; and &quot;DRBG&quot; implementations obtains seed data from
 140 # special device files such as file:/dev/random.
 141 #
 142 # On Windows systems, specifying the URLs &quot;file:/dev/random&quot; or
 143 # &quot;file:/dev/urandom&quot; will enable the native Microsoft CryptoAPI seeding
 144 # mechanism for SHA1PRNG and DRBG.
 145 #
 146 # By default, an attempt is made to use the entropy gathering device
 147 # specified by the &quot;securerandom.source&quot; Security property.  If an
 148 # exception occurs while accessing the specified URL:
 149 #
 150 #     NativePRNG:
 151 #         a default value of /dev/random will be used.  If neither
 152 #         are available, the implementation will be disabled.
 153 #         &quot;file&quot; is the only currently supported protocol type.
 154 #
 155 #     SHA1PRNG and DRBG:
 156 #         the traditional system/thread activity algorithm will be used.
 157 #
 158 # The entropy gathering device can also be specified with the System
 159 # property &quot;java.security.egd&quot;. For example:
 160 #
 161 #   % java -Djava.security.egd=file:/dev/random MainClass
 162 #
 163 # Specifying this System property will override the
 164 # &quot;securerandom.source&quot; Security property.
 165 #
 166 # In addition, if &quot;file:/dev/random&quot; or &quot;file:/dev/urandom&quot; is
 167 # specified, the &quot;NativePRNG&quot; implementation will be more preferred than
 168 # DRBG and SHA1PRNG in the Sun provider.
 169 #
 170 securerandom.source=file:/dev/random
 171 
 172 #
 173 # A list of known strong SecureRandom implementations.
 174 #
 175 # To help guide applications in selecting a suitable strong
 176 # java.security.SecureRandom implementation, Java distributions should
 177 # indicate a list of known strong implementations using the property.
 178 #
 179 # This is a comma-separated list of algorithm and/or algorithm:provider
 180 # entries.
 181 #
 182 #ifdef windows
 183 securerandom.strongAlgorithms=Windows-PRNG:SunMSCAPI,DRBG:SUN
 184 #endif
 185 #ifndef windows
 186 securerandom.strongAlgorithms=NativePRNGBlocking:SUN,DRBG:SUN
 187 #endif
 188 
 189 #
 190 # Sun provider DRBG configuration and default instantiation request.
 191 #
 192 # NIST SP 800-90Ar1 lists several DRBG mechanisms. Each can be configured
 193 # with a DRBG algorithm name, and can be instantiated with a security strength,
 194 # prediction resistance support, etc. This property defines the configuration
 195 # and the default instantiation request of &quot;DRBG&quot; SecureRandom implementations
 196 # in the SUN provider. (Other DRBG implementations can also use this property.)
 197 # Applications can request different instantiation parameters like security
 198 # strength, capability, personalization string using one of the
 199 # getInstance(...,SecureRandomParameters,...) methods with a
 200 # DrbgParameters.Instantiation argument, but other settings such as the
 201 # mechanism and DRBG algorithm names are not currently configurable by any API.
 202 #
 203 # Please note that the SUN implementation of DRBG always supports reseeding.
 204 #
 205 # The value of this property is a comma-separated list of all configurable
 206 # aspects. The aspects can appear in any order but the same aspect can only
 207 # appear at most once. Its BNF-style definition is:
 208 #
 209 #   Value:
 210 #     aspect { &quot;,&quot; aspect }
 211 #
 212 #   aspect:
 213 #     mech_name | algorithm_name | strength | capability | df
 214 #
 215 #   // The DRBG mechanism to use. Default &quot;Hash_DRBG&quot;
 216 #   mech_name:
 217 #     &quot;Hash_DRBG&quot; | &quot;HMAC_DRBG&quot; | &quot;CTR_DRBG&quot;
 218 #
 219 #   // The DRBG algorithm name. The &quot;SHA-***&quot; names are for Hash_DRBG and
 220 #   // HMAC_DRBG, default &quot;SHA-256&quot;. The &quot;AES-***&quot; names are for CTR_DRBG,
 221 #   // default &quot;AES-128&quot; when using the limited cryptographic or &quot;AES-256&quot;
 222 #   // when using the unlimited.
 223 #   algorithm_name:
 224 #     &quot;SHA-224&quot; | &quot;SHA-512/224&quot; | &quot;SHA-256&quot; |
 225 #     &quot;SHA-512/256&quot; | &quot;SHA-384&quot; | &quot;SHA-512&quot; |
 226 #     &quot;AES-128&quot; | &quot;AES-192&quot; | &quot;AES-256&quot;
 227 #
 228 #   // Security strength requested. Default &quot;128&quot;
 229 #   strength:
 230 #     &quot;112&quot; | &quot;128&quot; | &quot;192&quot; | &quot;256&quot;
 231 #
 232 #   // Prediction resistance and reseeding request. Default &quot;none&quot;
 233 #   //  &quot;pr_and_reseed&quot; - Both prediction resistance and reseeding
 234 #   //                    support requested
 235 #   //  &quot;reseed_only&quot;   - Only reseeding support requested
 236 #   //  &quot;none&quot;          - Neither prediction resistance not reseeding
 237 #   //                    support requested
 238 #   pr:
 239 #     &quot;pr_and_reseed&quot; | &quot;reseed_only&quot; | &quot;none&quot;
 240 #
 241 #   // Whether a derivation function should be used. only applicable
 242 #   // to CTR_DRBG. Default &quot;use_df&quot;
 243 #   df:
 244 #     &quot;use_df&quot; | &quot;no_df&quot;
 245 #
 246 # Examples,
 247 #   securerandom.drbg.config=Hash_DRBG,SHA-224,112,none
 248 #   securerandom.drbg.config=CTR_DRBG,AES-256,192,pr_and_reseed,use_df
 249 #
 250 # The default value is an empty string, which is equivalent to
 251 #   securerandom.drbg.config=Hash_DRBG,SHA-256,128,none
 252 #
 253 securerandom.drbg.config=
 254 
 255 #
 256 # Class to instantiate as the javax.security.auth.login.Configuration
 257 # provider.
 258 #
 259 login.configuration.provider=sun.security.provider.ConfigFile
 260 
 261 #
 262 # Default login configuration file
 263 #
 264 #login.config.url.1=file:${user.home}/.java.login.config
 265 
 266 #
 267 # Class to instantiate as the system Policy. This is the name of the class
 268 # that will be used as the Policy object. The system class loader is used to
 269 # locate this class.
 270 #
 271 policy.provider=sun.security.provider.PolicyFile
 272 
 273 # The default is to have a single system-wide policy file,
 274 # and a policy file in the user&#39;s home directory.
 275 #
 276 policy.url.1=file:${java.home}/conf/security/java.policy
 277 policy.url.2=file:${user.home}/.java.policy
 278 
<a name="1" id="anc1"></a><span class="line-modified"> 279 # whether or not we expand properties in the policy file</span>
<span class="line-modified"> 280 # if this is set to false, properties (${...}) will not be expanded in policy</span>
<span class="line-modified"> 281 # files.</span>


 282 #
 283 policy.expandProperties=true
 284 
<a name="2" id="anc2"></a><span class="line-modified"> 285 # whether or not we allow an extra policy to be passed on the command line</span>
<span class="line-modified"> 286 # with -Djava.security.policy=somefile. Comment out this line to disable</span>
<span class="line-modified"> 287 # this feature.</span>

 288 #
 289 policy.allowSystemProperty=true
 290 
 291 # whether or not we look into the IdentityScope for trusted Identities
 292 # when encountering a 1.1 signed JAR file. If the identity is found
 293 # and is trusted, we grant it AllPermission. Note: the default policy
 294 # provider (sun.security.provider.PolicyFile) does not support this property.
 295 #
 296 policy.ignoreIdentityScope=false
 297 
 298 #
 299 # Default keystore type.
 300 #
 301 keystore.type=pkcs12
 302 
 303 #
 304 # Controls compatibility mode for JKS and PKCS12 keystore types.
 305 #
 306 # When set to &#39;true&#39;, both JKS and PKCS12 keystore types support loading
 307 # keystore files in either JKS or PKCS12 format. When set to &#39;false&#39; the
 308 # JKS keystore type supports loading only JKS keystore files and the PKCS12
 309 # keystore type supports loading only PKCS12 keystore files.
 310 #
 311 keystore.type.compat=true
 312 
 313 #
 314 # List of comma-separated packages that start with or equal this string
 315 # will cause a security exception to be thrown when passed to the
 316 # SecurityManager::checkPackageAccess method unless the corresponding
 317 # RuntimePermission(&quot;accessClassInPackage.&quot;+package) has been granted.
 318 #
 319 package.access=sun.misc.,\
 320                sun.reflect.,\
 321 
 322 #
 323 # List of comma-separated packages that start with or equal this string
 324 # will cause a security exception to be thrown when passed to the
 325 # SecurityManager::checkPackageDefinition method unless the corresponding
 326 # RuntimePermission(&quot;defineClassInPackage.&quot;+package) has been granted.
 327 #
 328 # By default, none of the class loaders supplied with the JDK call
 329 # checkPackageDefinition.
 330 #
 331 package.definition=sun.misc.,\
 332                    sun.reflect.,\
 333 
 334 #
 335 # Determines whether this properties file can be appended to
 336 # or overridden on the command line via -Djava.security.properties
 337 #
 338 security.overridePropertiesFile=true
 339 
 340 #
 341 # Determines the default key and trust manager factory algorithms for
 342 # the javax.net.ssl package.
 343 #
 344 ssl.KeyManagerFactory.algorithm=SunX509
 345 ssl.TrustManagerFactory.algorithm=PKIX
 346 
 347 #
 348 # The Java-level namelookup cache policy for successful lookups:
 349 #
 350 # any negative value: caching forever
 351 # any positive value: the number of seconds to cache an address for
 352 # zero: do not cache
 353 #
 354 # default value is forever (FOREVER). For security reasons, this
 355 # caching is made forever when a security manager is set. When a security
 356 # manager is not set, the default behavior in this implementation
 357 # is to cache for 30 seconds.
 358 #
 359 # NOTE: setting this to anything other than the default value can have
 360 #       serious security implications. Do not set it unless
 361 #       you are sure you are not exposed to DNS spoofing attack.
 362 #
 363 #networkaddress.cache.ttl=-1
 364 
 365 # The Java-level namelookup cache policy for failed lookups:
 366 #
 367 # any negative value: cache forever
 368 # any positive value: the number of seconds to cache negative lookup results
 369 # zero: do not cache
 370 #
 371 # In some Microsoft Windows networking environments that employ
 372 # the WINS name service in addition to DNS, name service lookups
 373 # that fail may take a noticeably long time to return (approx. 5 seconds).
 374 # For this reason the default caching policy is to maintain these
 375 # results for 10 seconds.
 376 #
 377 networkaddress.cache.negative.ttl=10
 378 
 379 #
 380 # Properties to configure OCSP for certificate revocation checking
 381 #
 382 
 383 # Enable OCSP
 384 #
 385 # By default, OCSP is not used for certificate revocation checking.
 386 # This property enables the use of OCSP when set to the value &quot;true&quot;.
 387 #
 388 # NOTE: SocketPermission is required to connect to an OCSP responder.
 389 #
 390 # Example,
 391 #   ocsp.enable=true
 392 
 393 #
 394 # Location of the OCSP responder
 395 #
 396 # By default, the location of the OCSP responder is determined implicitly
 397 # from the certificate being validated. This property explicitly specifies
 398 # the location of the OCSP responder. The property is used when the
 399 # Authority Information Access extension (defined in RFC 5280) is absent
 400 # from the certificate or when it requires overriding.
 401 #
 402 # Example,
 403 #   ocsp.responderURL=http://ocsp.example.net:80
 404 
 405 #
 406 # Subject name of the OCSP responder&#39;s certificate
 407 #
 408 # By default, the certificate of the OCSP responder is that of the issuer
 409 # of the certificate being validated. This property identifies the certificate
 410 # of the OCSP responder when the default does not apply. Its value is a string
 411 # distinguished name (defined in RFC 2253) which identifies a certificate in
 412 # the set of certificates supplied during cert path validation. In cases where
 413 # the subject name alone is not sufficient to uniquely identify the certificate
 414 # then both the &quot;ocsp.responderCertIssuerName&quot; and
 415 # &quot;ocsp.responderCertSerialNumber&quot; properties must be used instead. When this
 416 # property is set then those two properties are ignored.
 417 #
 418 # Example,
 419 #   ocsp.responderCertSubjectName=CN=OCSP Responder, O=XYZ Corp
 420 
 421 #
 422 # Issuer name of the OCSP responder&#39;s certificate
 423 #
 424 # By default, the certificate of the OCSP responder is that of the issuer
 425 # of the certificate being validated. This property identifies the certificate
 426 # of the OCSP responder when the default does not apply. Its value is a string
 427 # distinguished name (defined in RFC 2253) which identifies a certificate in
 428 # the set of certificates supplied during cert path validation. When this
 429 # property is set then the &quot;ocsp.responderCertSerialNumber&quot; property must also
 430 # be set. When the &quot;ocsp.responderCertSubjectName&quot; property is set then this
 431 # property is ignored.
 432 #
 433 # Example,
 434 #   ocsp.responderCertIssuerName=CN=Enterprise CA, O=XYZ Corp
 435 
 436 #
 437 # Serial number of the OCSP responder&#39;s certificate
 438 #
 439 # By default, the certificate of the OCSP responder is that of the issuer
 440 # of the certificate being validated. This property identifies the certificate
 441 # of the OCSP responder when the default does not apply. Its value is a string
 442 # of hexadecimal digits (colon or space separators may be present) which
 443 # identifies a certificate in the set of certificates supplied during cert path
 444 # validation. When this property is set then the &quot;ocsp.responderCertIssuerName&quot;
 445 # property must also be set. When the &quot;ocsp.responderCertSubjectName&quot; property
 446 # is set then this property is ignored.
 447 #
 448 # Example,
 449 #   ocsp.responderCertSerialNumber=2A:FF:00
 450 
 451 #
 452 # Policy for failed Kerberos KDC lookups:
 453 #
 454 # When a KDC is unavailable (network error, service failure, etc), it is
 455 # put inside a blacklist and accessed less often for future requests. The
 456 # value (case-insensitive) for this policy can be:
 457 #
 458 # tryLast
 459 #    KDCs in the blacklist are always tried after those not on the list.
 460 #
 461 # tryLess[:max_retries,timeout]
 462 #    KDCs in the blacklist are still tried by their order in the configuration,
 463 #    but with smaller max_retries and timeout values. max_retries and timeout
 464 #    are optional numerical parameters (default 1 and 5000, which means once
 465 #    and 5 seconds). Please notes that if any of the values defined here is
 466 #    more than what is defined in krb5.conf, it will be ignored.
 467 #
 468 # Whenever a KDC is detected as available, it is removed from the blacklist.
 469 # The blacklist is reset when krb5.conf is reloaded. You can add
 470 # refreshKrb5Config=true to a JAAS configuration file so that krb5.conf is
 471 # reloaded whenever a JAAS authentication is attempted.
 472 #
 473 # Example,
 474 #   krb5.kdc.bad.policy = tryLast
 475 #   krb5.kdc.bad.policy = tryLess:2,2000
 476 #
 477 krb5.kdc.bad.policy = tryLast
 478 
 479 #
 480 # Kerberos cross-realm referrals (RFC 6806)
 481 #
 482 # OpenJDK&#39;s Kerberos client supports cross-realm referrals as defined in
 483 # RFC 6806. This allows to setup more dynamic environments in which clients
 484 # do not need to know in advance how to reach the realm of a target principal
 485 # (either a user or service).
 486 #
 487 # When a client issues an AS or a TGS request, the &quot;canonicalize&quot; option
 488 # is set to announce support of this feature. A KDC server may fulfill the
 489 # request or reply referring the client to a different one. If referred,
 490 # the client will issue a new request and the cycle repeats.
 491 #
 492 # In addition to referrals, the &quot;canonicalize&quot; option allows the KDC server
 493 # to change the client name in response to an AS request. For security reasons,
 494 # RFC 6806 (section 11) FAST scheme is enforced.
 495 #
 496 # Disable Kerberos cross-realm referrals. Value may be overwritten with a
 497 # System property (-Dsun.security.krb5.disableReferrals).
 498 sun.security.krb5.disableReferrals=false
 499 
 500 # Maximum number of AS or TGS referrals to avoid infinite loops. Value may
 501 # be overwritten with a System property (-Dsun.security.krb5.maxReferrals).
 502 sun.security.krb5.maxReferrals=5
 503 
 504 #
 505 # This property contains a list of disabled EC Named Curves that can be included
 506 # in the jdk.[tls|certpath|jar].disabledAlgorithms properties.  To include this
 507 # list in any of the disabledAlgorithms properties, add the property name as
 508 # an entry.
 509 jdk.disabled.namedCurves = secp112r1, secp112r2, secp128r1, secp128r2, \
 510     secp160k1, secp160r1, secp160r2, secp192k1, secp192r1, secp224k1, \
 511     secp224r1, secp256k1, sect113r1, sect113r2, sect131r1, sect131r2, \
 512     sect163k1, sect163r1, sect163r2, sect193r1, sect193r2, sect233k1, \
 513     sect233r1, sect239k1, sect283k1, sect283r1, sect409k1, sect409r1, \
 514     sect571k1, sect571r1, X9.62 c2tnb191v1, X9.62 c2tnb191v2, \
 515     X9.62 c2tnb191v3, X9.62 c2tnb239v1, X9.62 c2tnb239v2, X9.62 c2tnb239v3, \
 516     X9.62 c2tnb359v1, X9.62 c2tnb431r1, X9.62 prime192v2, X9.62 prime192v3, \
 517     X9.62 prime239v1, X9.62 prime239v2, X9.62 prime239v3, brainpoolP256r1, \
 518     brainpoolP320r1, brainpoolP384r1, brainpoolP512r1
 519 
 520 #
 521 # Algorithm restrictions for certification path (CertPath) processing
 522 #
 523 # In some environments, certain algorithms or key lengths may be undesirable
 524 # for certification path building and validation.  For example, &quot;MD2&quot; is
 525 # generally no longer considered to be a secure hash algorithm.  This section
 526 # describes the mechanism for disabling algorithms based on algorithm name
 527 # and/or key length.  This includes algorithms used in certificates, as well
 528 # as revocation information such as CRLs and signed OCSP Responses.
 529 # The syntax of the disabled algorithm string is described as follows:
 530 #   DisabledAlgorithms:
 531 #       &quot; DisabledAlgorithm { , DisabledAlgorithm } &quot;
 532 #
 533 #   DisabledAlgorithm:
 534 #       AlgorithmName [Constraint] { &#39;&amp;&#39; Constraint } | IncludeProperty
 535 #
 536 #   AlgorithmName:
 537 #       (see below)
 538 #
 539 #   Constraint:
 540 #       KeySizeConstraint | CAConstraint | DenyAfterConstraint |
 541 #       UsageConstraint
 542 #
 543 #   KeySizeConstraint:
 544 #       keySize Operator KeyLength
 545 #
 546 #   Operator:
 547 #       &lt;= | &lt; | == | != | &gt;= | &gt;
 548 #
 549 #   KeyLength:
 550 #       Integer value of the algorithm&#39;s key length in bits
 551 #
 552 #   CAConstraint:
 553 #       jdkCA
 554 #
 555 #   DenyAfterConstraint:
 556 #       denyAfter YYYY-MM-DD
 557 #
 558 #   UsageConstraint:
 559 #       usage [TLSServer] [TLSClient] [SignedJAR]
 560 #
 561 #   IncludeProperty:
 562 #       include &lt;security property&gt;
 563 #
 564 # The &quot;AlgorithmName&quot; is the standard algorithm name of the disabled
 565 # algorithm. See the Java Security Standard Algorithm Names Specification
 566 # for information about Standard Algorithm Names.  Matching is
 567 # performed using a case-insensitive sub-element matching rule.  (For
 568 # example, in &quot;SHA1withECDSA&quot; the sub-elements are &quot;SHA1&quot; for hashing and
 569 # &quot;ECDSA&quot; for signatures.)  If the assertion &quot;AlgorithmName&quot; is a
 570 # sub-element of the certificate algorithm name, the algorithm will be
 571 # rejected during certification path building and validation.  For example,
 572 # the assertion algorithm name &quot;DSA&quot; will disable all certificate algorithms
 573 # that rely on DSA, such as NONEwithDSA, SHA1withDSA.  However, the assertion
 574 # will not disable algorithms related to &quot;ECDSA&quot;.
 575 #
 576 # The &quot;IncludeProperty&quot; allows a implementation-defined security property that
 577 # can be included in the disabledAlgorithms properties.  These properties are
 578 # to help manage common actions easier across multiple disabledAlgorithm
 579 # properties.
 580 # There is one defined security property:  jdk.disabled.NamedCurves
 581 # See the property for more specific details.
 582 #
 583 #
 584 # A &quot;Constraint&quot; defines restrictions on the keys and/or certificates for
 585 # a specified AlgorithmName:
 586 #
 587 #   KeySizeConstraint:
 588 #     keySize Operator KeyLength
 589 #       The constraint requires a key of a valid size range if the
 590 #       &quot;AlgorithmName&quot; is of a key algorithm.  The &quot;KeyLength&quot; indicates
 591 #       the key size specified in number of bits.  For example,
 592 #       &quot;RSA keySize &lt;= 1024&quot; indicates that any RSA key with key size less
 593 #       than or equal to 1024 bits should be disabled, and
 594 #       &quot;RSA keySize &lt; 1024, RSA keySize &gt; 2048&quot; indicates that any RSA key
 595 #       with key size less than 1024 or greater than 2048 should be disabled.
 596 #       This constraint is only used on algorithms that have a key size.
 597 #
 598 #   CAConstraint:
 599 #     jdkCA
 600 #       This constraint prohibits the specified algorithm only if the
 601 #       algorithm is used in a certificate chain that terminates at a marked
 602 #       trust anchor in the lib/security/cacerts keystore.  If the jdkCA
 603 #       constraint is not set, then all chains using the specified algorithm
 604 #       are restricted.  jdkCA may only be used once in a DisabledAlgorithm
 605 #       expression.
 606 #       Example:  To apply this constraint to SHA-1 certificates, include
 607 #       the following:  &quot;SHA1 jdkCA&quot;
 608 #
 609 #   DenyAfterConstraint:
 610 #     denyAfter YYYY-MM-DD
 611 #       This constraint prohibits a certificate with the specified algorithm
 612 #       from being used after the date regardless of the certificate&#39;s
 613 #       validity.  JAR files that are signed and timestamped before the
 614 #       constraint date with certificates containing the disabled algorithm
 615 #       will not be restricted.  The date is processed in the UTC timezone.
 616 #       This constraint can only be used once in a DisabledAlgorithm
 617 #       expression.
 618 #       Example:  To deny usage of RSA 2048 bit certificates after Feb 3 2020,
 619 #       use the following:  &quot;RSA keySize == 2048 &amp; denyAfter 2020-02-03&quot;
 620 #
 621 #   UsageConstraint:
 622 #     usage [TLSServer] [TLSClient] [SignedJAR]
 623 #       This constraint prohibits the specified algorithm for
 624 #       a specified usage.  This should be used when disabling an algorithm
 625 #       for all usages is not practical. &#39;TLSServer&#39; restricts the algorithm
 626 #       in TLS server certificate chains when server authentication is
 627 #       performed. &#39;TLSClient&#39; restricts the algorithm in TLS client
 628 #       certificate chains when client authentication is performed.
 629 #       &#39;SignedJAR&#39; constrains use of certificates in signed jar files.
 630 #       The usage type follows the keyword and more than one usage type can
 631 #       be specified with a whitespace delimiter.
 632 #       Example:  &quot;SHA1 usage TLSServer TLSClient&quot;
 633 #
 634 # When an algorithm must satisfy more than one constraint, it must be
 635 # delimited by an ampersand &#39;&amp;&#39;.  For example, to restrict certificates in a
 636 # chain that terminate at a distribution provided trust anchor and contain
 637 # RSA keys that are less than or equal to 1024 bits, add the following
 638 # constraint:  &quot;RSA keySize &lt;= 1024 &amp; jdkCA&quot;.
 639 #
 640 # All DisabledAlgorithms expressions are processed in the order defined in the
 641 # property.  This requires lower keysize constraints to be specified
 642 # before larger keysize constraints of the same algorithm.  For example:
 643 # &quot;RSA keySize &lt; 1024 &amp; jdkCA, RSA keySize &lt; 2048&quot;.
 644 #
 645 # Note: The algorithm restrictions do not apply to trust anchors or
 646 # self-signed certificates.
 647 #
 648 # Note: This property is currently used by Oracle&#39;s PKIX implementation. It
 649 # is not guaranteed to be examined and used by other implementations.
 650 #
 651 # Example:
 652 #   jdk.certpath.disabledAlgorithms=MD2, DSA, RSA keySize &lt; 2048
 653 #
 654 #
 655 jdk.certpath.disabledAlgorithms=MD2, MD5, SHA1 jdkCA &amp; usage TLSServer, \
 656     RSA keySize &lt; 1024, DSA keySize &lt; 1024, EC keySize &lt; 224, \
 657     include jdk.disabled.namedCurves
 658 
 659 #
 660 # Algorithm restrictions for signed JAR files
 661 #
 662 # In some environments, certain algorithms or key lengths may be undesirable
 663 # for signed JAR validation.  For example, &quot;MD2&quot; is generally no longer
 664 # considered to be a secure hash algorithm.  This section describes the
 665 # mechanism for disabling algorithms based on algorithm name and/or key length.
 666 # JARs signed with any of the disabled algorithms or key sizes will be treated
 667 # as unsigned.
 668 #
 669 # The syntax of the disabled algorithm string is described as follows:
 670 #   DisabledAlgorithms:
 671 #       &quot; DisabledAlgorithm { , DisabledAlgorithm } &quot;
 672 #
 673 #   DisabledAlgorithm:
 674 #       AlgorithmName [Constraint] { &#39;&amp;&#39; Constraint }
 675 #
 676 #   AlgorithmName:
 677 #       (see below)
 678 #
 679 #   Constraint:
 680 #       KeySizeConstraint | DenyAfterConstraint
 681 #
 682 #   KeySizeConstraint:
 683 #       keySize Operator KeyLength
 684 #
 685 #   DenyAfterConstraint:
 686 #       denyAfter YYYY-MM-DD
 687 #
 688 #   Operator:
 689 #       &lt;= | &lt; | == | != | &gt;= | &gt;
 690 #
 691 #   KeyLength:
 692 #       Integer value of the algorithm&#39;s key length in bits
 693 #
 694 # Note: This property is currently used by the JDK Reference
 695 # implementation. It is not guaranteed to be examined and used by other
 696 # implementations.
 697 #
 698 # See &quot;jdk.certpath.disabledAlgorithms&quot; for syntax descriptions.
 699 #
 700 jdk.jar.disabledAlgorithms=MD2, MD5, RSA keySize &lt; 1024, \
 701       DSA keySize &lt; 1024, include jdk.disabled.namedCurves
 702 
 703 #
 704 # Algorithm restrictions for Secure Socket Layer/Transport Layer Security
 705 # (SSL/TLS/DTLS) processing
 706 #
 707 # In some environments, certain algorithms or key lengths may be undesirable
 708 # when using SSL/TLS/DTLS.  This section describes the mechanism for disabling
 709 # algorithms during SSL/TLS/DTLS security parameters negotiation, including
 710 # protocol version negotiation, cipher suites selection, named groups
 711 # selection, signature schemes selection, peer authentication and key
 712 # exchange mechanisms.
 713 #
 714 # Disabled algorithms will not be negotiated for SSL/TLS connections, even
 715 # if they are enabled explicitly in an application.
 716 #
 717 # For PKI-based peer authentication and key exchange mechanisms, this list
 718 # of disabled algorithms will also be checked during certification path
 719 # building and validation, including algorithms used in certificates, as
 720 # well as revocation information such as CRLs and signed OCSP Responses.
 721 # This is in addition to the jdk.certpath.disabledAlgorithms property above.
 722 #
 723 # See the specification of &quot;jdk.certpath.disabledAlgorithms&quot; for the
 724 # syntax of the disabled algorithm string.
 725 #
 726 # Note: The algorithm restrictions do not apply to trust anchors or
 727 # self-signed certificates.
 728 #
 729 # Note: This property is currently used by the JDK Reference implementation.
 730 # It is not guaranteed to be examined and used by other implementations.
 731 #
 732 # Example:
 733 #   jdk.tls.disabledAlgorithms=MD5, SSLv3, DSA, RSA keySize &lt; 2048, \
 734 #       rsa_pkcs1_sha1, secp224r1
 735 jdk.tls.disabledAlgorithms=SSLv3, RC4, DES, MD5withRSA, DH keySize &lt; 1024, \
 736     EC keySize &lt; 224, 3DES_EDE_CBC, anon, NULL, \
 737     include jdk.disabled.namedCurves
 738 
 739 #
 740 # Legacy algorithms for Secure Socket Layer/Transport Layer Security (SSL/TLS)
 741 # processing in JSSE implementation.
 742 #
 743 # In some environments, a certain algorithm may be undesirable but it
 744 # cannot be disabled because of its use in legacy applications.  Legacy
 745 # algorithms may still be supported, but applications should not use them
 746 # as the security strength of legacy algorithms are usually not strong enough
 747 # in practice.
 748 #
 749 # During SSL/TLS security parameters negotiation, legacy algorithms will
 750 # not be negotiated unless there are no other candidates.
 751 #
 752 # The syntax of the legacy algorithms string is described as this Java
 753 # BNF-style:
 754 #   LegacyAlgorithms:
 755 #       &quot; LegacyAlgorithm { , LegacyAlgorithm } &quot;
 756 #
 757 #   LegacyAlgorithm:
 758 #       AlgorithmName (standard JSSE algorithm name)
 759 #
 760 # See the specification of security property &quot;jdk.certpath.disabledAlgorithms&quot;
 761 # for the syntax and description of the &quot;AlgorithmName&quot; notation.
 762 #
 763 # Per SSL/TLS specifications, cipher suites have the form:
 764 #       SSL_KeyExchangeAlg_WITH_CipherAlg_MacAlg
 765 # or
 766 #       TLS_KeyExchangeAlg_WITH_CipherAlg_MacAlg
 767 #
 768 # For example, the cipher suite TLS_RSA_WITH_AES_128_CBC_SHA uses RSA as the
 769 # key exchange algorithm, AES_128_CBC (128 bits AES cipher algorithm in CBC
 770 # mode) as the cipher (encryption) algorithm, and SHA-1 as the message digest
 771 # algorithm for HMAC.
 772 #
 773 # The LegacyAlgorithm can be one of the following standard algorithm names:
 774 #     1. JSSE cipher suite name, e.g., TLS_RSA_WITH_AES_128_CBC_SHA
 775 #     2. JSSE key exchange algorithm name, e.g., RSA
 776 #     3. JSSE cipher (encryption) algorithm name, e.g., AES_128_CBC
 777 #     4. JSSE message digest algorithm name, e.g., SHA
 778 #
 779 # See SSL/TLS specifications and the Java Security Standard Algorithm Names
 780 # Specification for information about the algorithm names.
 781 #
 782 # Note: If a legacy algorithm is also restricted through the
 783 # jdk.tls.disabledAlgorithms property or the
 784 # java.security.AlgorithmConstraints API (See
 785 # javax.net.ssl.SSLParameters.setAlgorithmConstraints()),
 786 # then the algorithm is completely disabled and will not be negotiated.
 787 #
 788 # Note: This property is currently used by the JDK Reference implementation.
 789 # It is not guaranteed to be examined and used by other implementations.
 790 # There is no guarantee the property will continue to exist or be of the
 791 # same syntax in future releases.
 792 #
 793 # Example:
 794 #   jdk.tls.legacyAlgorithms=DH_anon, DES_CBC, SSL_RSA_WITH_RC4_128_MD5
 795 #
<a name="3" id="anc3"></a><span class="line-modified"> 796 jdk.tls.legacyAlgorithms= \</span>
<span class="line-removed"> 797         K_NULL, C_NULL, M_NULL, \</span>
<span class="line-removed"> 798         DH_anon, ECDH_anon, \</span>
<span class="line-removed"> 799         RC4_128, RC4_40, DES_CBC, DES40_CBC, \</span>
<span class="line-removed"> 800         3DES_EDE_CBC</span>
 801 
 802 #
 803 # The pre-defined default finite field Diffie-Hellman ephemeral (DHE)
 804 # parameters for Transport Layer Security (SSL/TLS/DTLS) processing.
 805 #
 806 # In traditional SSL/TLS/DTLS connections where finite field DHE parameters
 807 # negotiation mechanism is not used, the server offers the client group
 808 # parameters, base generator g and prime modulus p, for DHE key exchange.
 809 # It is recommended to use dynamic group parameters.  This property defines
 810 # a mechanism that allows you to specify custom group parameters.
 811 #
 812 # The syntax of this property string is described as this Java BNF-style:
 813 #   DefaultDHEParameters:
 814 #       DefinedDHEParameters { , DefinedDHEParameters }
 815 #
 816 #   DefinedDHEParameters:
 817 #       &quot;{&quot; DHEPrimeModulus , DHEBaseGenerator &quot;}&quot;
 818 #
 819 #   DHEPrimeModulus:
 820 #       HexadecimalDigits
 821 #
 822 #   DHEBaseGenerator:
 823 #       HexadecimalDigits
 824 #
 825 #   HexadecimalDigits:
 826 #       HexadecimalDigit { HexadecimalDigit }
 827 #
 828 #   HexadecimalDigit: one of
 829 #       0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f
 830 #
 831 # Whitespace characters are ignored.
 832 #
 833 # The &quot;DefinedDHEParameters&quot; defines the custom group parameters, prime
 834 # modulus p and base generator g, for a particular size of prime modulus p.
 835 # The &quot;DHEPrimeModulus&quot; defines the hexadecimal prime modulus p, and the
 836 # &quot;DHEBaseGenerator&quot; defines the hexadecimal base generator g of a group
 837 # parameter.  It is recommended to use safe primes for the custom group
 838 # parameters.
 839 #
 840 # If this property is not defined or the value is empty, the underlying JSSE
 841 # provider&#39;s default group parameter is used for each connection.
 842 #
 843 # If the property value does not follow the grammar, or a particular group
 844 # parameter is not valid, the connection will fall back and use the
 845 # underlying JSSE provider&#39;s default group parameter.
 846 #
 847 # Note: This property is currently used by OpenJDK&#39;s JSSE implementation. It
 848 # is not guaranteed to be examined and used by other implementations.
 849 #
 850 # Example:
 851 #   jdk.tls.server.defaultDHEParameters=
 852 #       { \
 853 #       FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1 \
 854 #       29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD \
 855 #       EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245 \
 856 #       E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED \
 857 #       EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE65381 \
 858 #       FFFFFFFF FFFFFFFF, 2}
 859 
 860 #
 861 # TLS key limits on symmetric cryptographic algorithms
 862 #
 863 # This security property sets limits on algorithms key usage in TLS 1.3.
 864 # When the amount of data encrypted exceeds the algorithm value listed below,
 865 # a KeyUpdate message will trigger a key change.  This is for symmetric ciphers
 866 # with TLS 1.3 only.
 867 #
 868 # The syntax for the property is described below:
 869 #   KeyLimits:
 870 #       &quot; KeyLimit { , KeyLimit } &quot;
 871 #
 872 #   WeakKeyLimit:
 873 #       AlgorithmName Action Length
 874 #
 875 #   AlgorithmName:
 876 #       A full algorithm transformation.
 877 #
 878 #   Action:
 879 #       KeyUpdate
 880 #
 881 #   Length:
 882 #       The amount of encrypted data in a session before the Action occurs
 883 #       This value may be an integer value in bytes, or as a power of two, 2^29.
 884 #
 885 #   KeyUpdate:
 886 #       The TLS 1.3 KeyUpdate handshake process begins when the Length amount
 887 #       is fulfilled.
 888 #
 889 # Note: This property is currently used by OpenJDK&#39;s JSSE implementation. It
 890 # is not guaranteed to be examined and used by other implementations.
 891 #
 892 jdk.tls.keyLimits=AES/GCM/NoPadding KeyUpdate 2^37
 893 
 894 #
 895 # Cryptographic Jurisdiction Policy defaults
 896 #
 897 # Import and export control rules on cryptographic software vary from
 898 # country to country.  By default, Java provides two different sets of
 899 # cryptographic policy files[1]:
 900 #
 901 #     unlimited:  These policy files contain no restrictions on cryptographic
 902 #                 strengths or algorithms
 903 #
 904 #     limited:    These policy files contain more restricted cryptographic
 905 #                 strengths
 906 #
 907 # The default setting is determined by the value of the &quot;crypto.policy&quot;
 908 # Security property below. If your country or usage requires the
 909 # traditional restrictive policy, the &quot;limited&quot; Java cryptographic
 910 # policy is still available and may be appropriate for your environment.
 911 #
 912 # If you have restrictions that do not fit either use case mentioned
 913 # above, Java provides the capability to customize these policy files.
 914 # The &quot;crypto.policy&quot; security property points to a subdirectory
 915 # within &lt;java-home&gt;/conf/security/policy/ which can be customized.
 916 # Please see the &lt;java-home&gt;/conf/security/policy/README.txt file or consult
 917 # the Java Security Guide/JCA documentation for more information.
 918 #
 919 # YOU ARE ADVISED TO CONSULT YOUR EXPORT/IMPORT CONTROL COUNSEL OR ATTORNEY
 920 # TO DETERMINE THE EXACT REQUIREMENTS.
 921 #
 922 # [1] Please note that the JCE for Java SE, including the JCE framework,
 923 # cryptographic policy files, and standard JCE providers provided with
 924 # the Java SE, have been reviewed and approved for export as mass market
 925 # encryption item by the US Bureau of Industry and Security.
 926 #
 927 # Note: This property is currently used by the JDK Reference implementation.
 928 # It is not guaranteed to be examined and used by other implementations.
 929 #
 930 crypto.policy=crypto.policydir-tbd
 931 
 932 #
 933 # The policy for the XML Signature secure validation mode. The mode is
 934 # enabled by setting the property &quot;org.jcp.xml.dsig.secureValidation&quot; to
 935 # true with the javax.xml.crypto.XMLCryptoContext.setProperty() method,
 936 # or by running the code with a SecurityManager.
 937 #
 938 #   Policy:
 939 #       Constraint {&quot;,&quot; Constraint }
 940 #   Constraint:
 941 #       AlgConstraint | MaxTransformsConstraint | MaxReferencesConstraint |
 942 #       ReferenceUriSchemeConstraint | KeySizeConstraint | OtherConstraint
 943 #   AlgConstraint
 944 #       &quot;disallowAlg&quot; Uri
 945 #   MaxTransformsConstraint:
 946 #       &quot;maxTransforms&quot; Integer
 947 #   MaxReferencesConstraint:
 948 #       &quot;maxReferences&quot; Integer
 949 #   ReferenceUriSchemeConstraint:
 950 #       &quot;disallowReferenceUriSchemes&quot; String { String }
 951 #   KeySizeConstraint:
 952 #       &quot;minKeySize&quot; KeyAlg Integer
 953 #   OtherConstraint:
 954 #       &quot;noDuplicateIds&quot; | &quot;noRetrievalMethodLoops&quot;
 955 #
 956 # For AlgConstraint, Uri is the algorithm URI String that is not allowed.
 957 # See the XML Signature Recommendation for more information on algorithm
 958 # URI Identifiers. For KeySizeConstraint, KeyAlg is the standard algorithm
 959 # name of the key type (ex: &quot;RSA&quot;). If the MaxTransformsConstraint,
 960 # MaxReferencesConstraint or KeySizeConstraint (for the same key type) is
 961 # specified more than once, only the last entry is enforced.
 962 #
 963 # Note: This property is currently used by the JDK Reference implementation. It
 964 # is not guaranteed to be examined and used by other implementations.
 965 #
 966 jdk.xml.dsig.secureValidationPolicy=\
 967     disallowAlg http://www.w3.org/TR/1999/REC-xslt-19991116,\
 968     disallowAlg http://www.w3.org/2001/04/xmldsig-more#rsa-md5,\
 969     disallowAlg http://www.w3.org/2001/04/xmldsig-more#hmac-md5,\
 970     disallowAlg http://www.w3.org/2001/04/xmldsig-more#md5,\
 971     maxTransforms 5,\
 972     maxReferences 30,\
 973     disallowReferenceUriSchemes file http https,\
 974     minKeySize RSA 1024,\
 975     minKeySize DSA 1024,\
 976     minKeySize EC 224,\
 977     noDuplicateIds,\
 978     noRetrievalMethodLoops
 979 
 980 #
 981 # Serialization system-wide filter
 982 #
 983 # A filter, if configured, is used by java.io.ObjectInputStream during
 984 # deserialization to check the contents of the stream.
 985 # A filter is configured as a sequence of patterns, each pattern is either
 986 # matched against the name of a class in the stream or defines a limit.
 987 # Patterns are separated by &quot;;&quot; (semicolon).
 988 # Whitespace is significant and is considered part of the pattern.
 989 #
 990 # If the system property jdk.serialFilter is also specified, it supersedes
 991 # the security property value defined here.
 992 #
 993 # If a pattern includes a &quot;=&quot;, it sets a limit.
 994 # If a limit appears more than once the last value is used.
 995 # Limits are checked before classes regardless of the order in the
 996 # sequence of patterns.
 997 # If any of the limits are exceeded, the filter status is REJECTED.
 998 #
 999 #   maxdepth=value - the maximum depth of a graph
1000 #   maxrefs=value  - the maximum number of internal references
1001 #   maxbytes=value - the maximum number of bytes in the input stream
1002 #   maxarray=value - the maximum array length allowed
1003 #
1004 # Other patterns, from left to right, match the class or package name as
1005 # returned from Class.getName.
1006 # If the class is an array type, the class or package to be matched is the
1007 # element type.
1008 # Arrays of any number of dimensions are treated the same as the element type.
1009 # For example, a pattern of &quot;!example.Foo&quot;, rejects creation of any instance or
1010 # array of example.Foo.
1011 #
1012 # If the pattern starts with &quot;!&quot;, the status is REJECTED if the remaining
1013 # pattern is matched; otherwise the status is ALLOWED if the pattern matches.
1014 # If the pattern contains &quot;/&quot;, the non-empty prefix up to the &quot;/&quot; is the
1015 # module name;
1016 #   if the module name matches the module name of the class then
1017 #   the remaining pattern is matched with the class name.
1018 #   If there is no &quot;/&quot;, the module name is not compared.
1019 # If the pattern ends with &quot;.**&quot; it matches any class in the package and all
1020 # subpackages.
1021 # If the pattern ends with &quot;.*&quot; it matches any class in the package.
1022 # If the pattern ends with &quot;*&quot;, it matches any class with the pattern as a
1023 # prefix.
1024 # If the pattern is equal to the class name, it matches.
1025 # Otherwise, the status is UNDECIDED.
1026 #
1027 #jdk.serialFilter=pattern;pattern
1028 
1029 #
1030 # RMI Registry Serial Filter
1031 #
1032 # The filter pattern uses the same format as jdk.serialFilter.
1033 # This filter can override the builtin filter if additional types need to be
1034 # allowed or rejected from the RMI Registry or to decrease limits but not
1035 # to increase limits.
1036 # If the limits (maxdepth, maxrefs, or maxbytes) are exceeded, the object is rejected.
1037 #
1038 # Each non-array type is allowed or rejected if it matches one of the patterns,
1039 # evaluated from left to right, and is otherwise allowed. Arrays of any
1040 # component type, including subarrays and arrays of primitives, are allowed.
1041 #
1042 # Array construction of any component type, including subarrays and arrays of
1043 # primitives, are allowed unless the length is greater than the maxarray limit.
1044 # The filter is applied to each array element.
1045 #
1046 # Note: This property is currently used by the JDK Reference implementation.
1047 # It is not guaranteed to be examined and used by other implementations.
1048 #
1049 # The built-in filter allows subclasses of allowed classes and
1050 # can approximately be represented as the pattern:
1051 #
1052 #sun.rmi.registry.registryFilter=\
1053 #    maxarray=1000000;\
1054 #    maxdepth=20;\
1055 #    java.lang.String;\
1056 #    java.lang.Number;\
1057 #    java.lang.reflect.Proxy;\
1058 #    java.rmi.Remote;\
1059 #    sun.rmi.server.UnicastRef;\
1060 #    sun.rmi.server.RMIClientSocketFactory;\
1061 #    sun.rmi.server.RMIServerSocketFactory;\
1062 #    java.rmi.activation.ActivationID;\
1063 #    java.rmi.server.UID
1064 #
1065 # RMI Distributed Garbage Collector (DGC) Serial Filter
1066 #
1067 # The filter pattern uses the same format as jdk.serialFilter.
1068 # This filter can override the builtin filter if additional types need to be
1069 # allowed or rejected from the RMI DGC.
1070 #
1071 # Note: This property is currently used by the JDK Reference implementation.
1072 # It is not guaranteed to be examined and used by other implementations.
1073 #
1074 # The builtin DGC filter can approximately be represented as the filter pattern:
1075 #
1076 #sun.rmi.transport.dgcFilter=\
1077 #    java.rmi.server.ObjID;\
1078 #    java.rmi.server.UID;\
1079 #    java.rmi.dgc.VMID;\
1080 #    java.rmi.dgc.Lease;\
1081 #    maxdepth=5;maxarray=10000
1082 
1083 #
1084 # JCEKS Encrypted Key Serial Filter
1085 #
1086 # This filter, if configured, is used by the JCEKS KeyStore during the
1087 # deserialization of the encrypted Key object stored inside a key entry.
1088 # If not configured or the filter result is UNDECIDED (i.e. none of the patterns
1089 # matches), the filter configured by jdk.serialFilter will be consulted.
1090 #
1091 # If the system property jceks.key.serialFilter is also specified, it supersedes
1092 # the security property value defined here.
1093 #
1094 # The filter pattern uses the same format as jdk.serialFilter. The default
1095 # pattern allows java.lang.Enum, java.security.KeyRep, java.security.KeyRep$Type,
1096 # and javax.crypto.spec.SecretKeySpec and rejects all the others.
1097 jceks.key.serialFilter = java.base/java.lang.Enum;java.base/java.security.KeyRep;\
1098   java.base/java.security.KeyRep$Type;java.base/javax.crypto.spec.SecretKeySpec;!*
1099 
1100 # The iteration count used for password-based encryption (PBE) in JCEKS
1101 # keystores. Values in the range 10000 to 5000000 are considered valid.
1102 # If the value is out of this range, or is not a number, or is unspecified;
1103 # a default of 200000 is used.
1104 #
1105 # If the system property jdk.jceks.iterationCount is also specified, it
1106 # supersedes the security property value defined here.
1107 #
1108 #jdk.jceks.iterationCount = 200000
1109 
1110 #
1111 # PKCS12 KeyStore properties
1112 #
1113 # The following properties, if configured, are used by the PKCS12 KeyStore
1114 # implementation during the creation of a new keystore. Several of the
1115 # properties may also be used when modifying an existing keystore. The
1116 # properties can be overridden by a KeyStore API that specifies its own
1117 # algorithms and parameters.
1118 #
1119 # If an existing PKCS12 keystore is loaded and then stored, the algorithm and
1120 # parameter used to generate the existing Mac will be reused. If the existing
1121 # keystore does not have a Mac, no Mac will be created while storing. If there
1122 # is at least one certificate in the existing keystore, the algorithm and
1123 # parameters used to encrypt the last certificate in the existing keystore will
1124 # be reused to encrypt all certificates while storing. If the last certificate
1125 # in the existing keystore is not encrypted, all certificates will be stored
1126 # unencrypted. If there is no certificate in the existing keystore, any newly
1127 # added certificate will be encrypted (or stored unencrypted if algorithm
1128 # value is &quot;NONE&quot;) using the &quot;keystore.pkcs12.certProtectionAlgorithm&quot; and
1129 # &quot;keystore.pkcs12.certPbeIterationCount&quot; values defined here. Existing private
1130 # and secret key(s) are not changed. Newly set private and secret key(s) will
1131 # be encrypted using the &quot;keystore.pkcs12.keyProtectionAlgorithm&quot; and
1132 # &quot;keystore.pkcs12.keyPbeIterationCount&quot; values defined here.
1133 #
1134 # In order to apply new algorithms and parameters to all entries in an
1135 # existing keystore, one can create a new keystore and add entries in the
1136 # existing keystore into the new keystore. This can be achieved by calling the
1137 # &quot;keytool -importkeystore&quot; command.
1138 #
1139 # If a system property of the same name is also specified, it supersedes the
1140 # security property value defined here.
1141 #
1142 # If the property is set to an illegal value,
1143 # an iteration count that is not a positive integer, or an unknown algorithm
1144 # name, an exception will be thrown when the property is used.
1145 # If the property is not set or empty, a default value will be used.
1146 #
1147 # Note: These properties are currently used by the JDK Reference implementation.
1148 # They are not guaranteed to be examined and used by other implementations.
1149 
1150 # The algorithm used to encrypt a certificate. This can be any non-Hmac PBE
1151 # algorithm defined in the Cipher section of the Java Security Standard
1152 # Algorithm Names Specification. When set to &quot;NONE&quot;, the certificate
1153 # is not encrypted. The default value is &quot;PBEWithSHA1AndRC2_40&quot;.
1154 #keystore.pkcs12.certProtectionAlgorithm = PBEWithSHA1AndRC2_40
1155 
1156 # The iteration count used by the PBE algorithm when encrypting a certificate.
1157 # This value must be a positive integer. The default value is 50000.
1158 #keystore.pkcs12.certPbeIterationCount = 50000
1159 
1160 # The algorithm used to encrypt a private key or secret key. This can be
1161 # any non-Hmac PBE algorithm defined in the Cipher section of the Java
1162 # Security Standard Algorithm Names Specification. The value must not be &quot;NONE&quot;.
1163 # The default value is &quot;PBEWithSHA1AndDESede&quot;.
1164 #keystore.pkcs12.keyProtectionAlgorithm = PBEWithSHA1AndDESede
1165 
1166 # The iteration count used by the PBE algorithm when encrypting a private key
1167 # or a secret key. This value must be a positive integer. The default value
1168 # is 50000.
1169 #keystore.pkcs12.keyPbeIterationCount = 50000
1170 
1171 # The algorithm used to calculate the optional MacData at the end of a PKCS12
1172 # file. This can be any HmacPBE algorithm defined in the Mac section of the
1173 # Java Security Standard Algorithm Names Specification. When set to &quot;NONE&quot;,
1174 # no Mac is generated. The default value is &quot;HmacPBESHA1&quot;.
1175 #keystore.pkcs12.macAlgorithm = HmacPBESHA1
1176 
1177 # The iteration count used by the MacData algorithm. This value must be a
1178 # positive integer. The default value is 100000.
1179 #keystore.pkcs12.macIterationCount = 100000
1180 
1181 #
1182 # Enhanced exception message information
1183 #
1184 # By default, exception messages should not include potentially sensitive
1185 # information such as file names, host names, or port numbers. This property
1186 # accepts one or more comma separated values, each of which represents a
1187 # category of enhanced exception message information to enable. Values are
1188 # case-insensitive. Leading and trailing whitespaces, surrounding each value,
1189 # are ignored. Unknown values are ignored.
1190 #
1191 # NOTE: Use caution before setting this property. Setting this property
1192 # exposes sensitive information in Exceptions, which could, for example,
1193 # propagate to untrusted code or be emitted in stack traces that are
1194 # inadvertently disclosed and made accessible over a public network.
1195 #
1196 # The categories are:
1197 #
1198 #  hostInfo - IOExceptions thrown by java.net.Socket and the socket types in the
1199 #             java.nio.channels package will contain enhanced exception
1200 #             message information
1201 #
1202 #  jar      - enables more detailed information in the IOExceptions thrown
1203 #             by classes in the java.util.jar package
1204 #
1205 # The property setting in this file can be overridden by a system property of
1206 # the same name, with the same syntax and possible values.
1207 #
1208 #jdk.includeInExceptions=hostInfo,jar
1209 
1210 #
1211 # Disabled mechanisms for the Simple Authentication and Security Layer (SASL)
1212 #
1213 # Disabled mechanisms will not be negotiated by both SASL clients and servers.
1214 # These mechanisms will be ignored if they are specified in the &quot;mechanisms&quot;
1215 # argument of &quot;Sasl.createSaslClient&quot; or the &quot;mechanism&quot; argument of
1216 # &quot;Sasl.createSaslServer&quot;.
1217 #
1218 # The value of this property is a comma-separated list of SASL mechanisms.
1219 # The mechanisms are case-sensitive. Whitespaces around the commas are ignored.
1220 #
1221 # Note: This property is currently used by the JDK Reference implementation.
1222 # It is not guaranteed to be examined and used by other implementations.
1223 #
1224 # Example:
1225 #   jdk.sasl.disabledMechanisms=PLAIN, CRAM-MD5, DIGEST-MD5
1226 jdk.sasl.disabledMechanisms=
1227 
1228 #
1229 # Policies for distrusting Certificate Authorities (CAs).
1230 #
1231 # This is a comma separated value of one or more case-sensitive strings, each
1232 # of which represents a policy for determining if a CA should be distrusted.
1233 # The supported values are:
1234 #
1235 #   SYMANTEC_TLS : Distrust TLS Server certificates anchored by a Symantec
1236 #   root CA and issued after April 16, 2019 unless issued by one of the
1237 #   following subordinate CAs which have a later distrust date:
1238 #     1. Apple IST CA 2 - G1, SHA-256 fingerprint:
1239 #        AC2B922ECFD5E01711772FEA8ED372DE9D1E2245FCE3F57A9CDBEC77296A424B
1240 #        Distrust after December 31, 2019.
1241 #     2. Apple IST CA 8 - G1, SHA-256 fingerprint:
1242 #        A4FE7C7F15155F3F0AEF7AAA83CF6E06DEB97CA3F909DF920AC1490882D488ED
1243 #        Distrust after December 31, 2019.
1244 #
1245 # Leading and trailing whitespace surrounding each value are ignored.
1246 # Unknown values are ignored. If the property is commented out or set to the
1247 # empty String, no policies are enforced.
1248 #
1249 # Note: This property is currently used by the JDK Reference implementation.
1250 # It is not guaranteed to be supported by other SE implementations. Also, this
1251 # property does not override other security properties which can restrict
1252 # certificates such as jdk.tls.disabledAlgorithms or
1253 # jdk.certpath.disabledAlgorithms; those restrictions are still enforced even
1254 # if this property is not enabled.
1255 #
1256 jdk.security.caDistrustPolicies=SYMANTEC_TLS
1257 
1258 #
1259 # FilePermission path canonicalization
1260 #
1261 # This security property dictates how the path argument is processed and stored
1262 # while constructing a FilePermission object. If the value is set to true, the
1263 # path argument is canonicalized and FilePermission methods (such as implies,
1264 # equals, and hashCode) are implemented based on this canonicalized result.
1265 # Otherwise, the path argument is not canonicalized and FilePermission methods are
1266 # implemented based on the original input. See the implementation note of the
1267 # FilePermission class for more details.
1268 #
1269 # If a system property of the same name is also specified, it supersedes the
1270 # security property value defined here.
1271 #
1272 # The default value for this property is false.
1273 #
1274 jdk.io.permissionsUseCanonicalPath=false
1275 
1276 
1277 #
1278 # Policies for the proxy_impersonator Kerberos ccache configuration entry
1279 #
1280 # The proxy_impersonator ccache configuration entry indicates that the ccache
1281 # is a synthetic delegated credential for use with S4U2Proxy by an intermediate
1282 # server. The ccache file should also contain the TGT of this server and
1283 # an evidence ticket from the default principal of the ccache to this server.
1284 #
1285 # This security property determines how Java uses this configuration entry.
1286 # There are 3 possible values:
1287 #
1288 #  no-impersonate     - Ignore this configuration entry, and always act as
1289 #                       the owner of the TGT (if it exists).
1290 #
1291 #  try-impersonate    - Try impersonation when this configuration entry exists.
1292 #                       If no matching TGT or evidence ticket is found,
1293 #                       fallback to no-impersonate.
1294 #
1295 #  always-impersonate - Always impersonate when this configuration entry exists.
1296 #                       If no matching TGT or evidence ticket is found,
1297 #                       no initial credential is read from the ccache.
1298 #
1299 # The default value is &quot;always-impersonate&quot;.
1300 #
1301 # If a system property of the same name is also specified, it supersedes the
1302 # security property value defined here.
1303 #
1304 #jdk.security.krb5.default.initiate.credential=always-impersonate
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
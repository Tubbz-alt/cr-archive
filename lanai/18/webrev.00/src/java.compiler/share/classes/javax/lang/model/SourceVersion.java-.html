<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.compiler/share/classes/javax/lang/model/SourceVersion.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package javax.lang.model;
 27 
 28 import java.util.Collections;
 29 import java.util.Set;
 30 import java.util.HashSet;
 31 
 32 /**
 33  * Source versions of the Java&amp;trade; programming language.
 34  *
 35  * See the appropriate edition of
 36  * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;
 37  * for information about a particular source version.
 38  *
 39  * &lt;p&gt;Note that additional source version constants will be added to
 40  * model future releases of the language.
 41  *
 42  * @author Joseph D. Darcy
 43  * @author Scott Seligman
 44  * @author Peter von der Ah&amp;eacute;
 45  * @since 1.6
 46  */
 47 public enum SourceVersion {
 48     /*
 49      * Summary of language evolution
 50      * 1.1: nested classes
 51      * 1.2: strictfp
 52      * 1.3: no changes
 53      * 1.4: assert
 54      * 1.5: annotations, generics, autoboxing, var-args...
 55      * 1.6: no changes
 56      * 1.7: diamond syntax, try-with-resources, etc.
 57      * 1.8: lambda expressions and default methods
 58      *   9: modules, small cleanups to 1.7 and 1.8 changes
 59      *  10: local-variable type inference (var)
 60      *  11: local-variable syntax for lambda parameters
 61      *  12: no changes (switch expressions in preview)
 62      *  13: no changes (switch expressions and text blocks in preview)
 63      *  14: switch expressions (pattern matching and records in
 64      *      preview, text blocks in preview again)
 65      *  15: TBD
 66      */
 67 
 68     /**
 69      * The original version.
 70      *
 71      * The language described in
 72      * &lt;cite&gt;The Java&amp;trade; Language Specification, First Edition&lt;/cite&gt;.
 73      */
 74     RELEASE_0,
 75 
 76     /**
 77      * The version recognized by the Java Platform 1.1.
 78      *
 79      * The language is {@code RELEASE_0} augmented with nested classes as described in the 1.1 update to
 80      * &lt;cite&gt;The Java&amp;trade; Language Specification, First Edition&lt;/cite&gt;.
 81      */
 82     RELEASE_1,
 83 
 84     /**
 85      * The version recognized by the Java 2 Platform, Standard Edition,
 86      * v 1.2.
 87      *
 88      * The language described in
 89      * &lt;cite&gt;The Java&amp;trade; Language Specification,
 90      * Second Edition&lt;/cite&gt;, which includes the {@code
 91      * strictfp} modifier.
 92      */
 93     RELEASE_2,
 94 
 95     /**
 96      * The version recognized by the Java 2 Platform, Standard Edition,
 97      * v 1.3.
 98      *
 99      * No major changes from {@code RELEASE_2}.
100      */
101     RELEASE_3,
102 
103     /**
104      * The version recognized by the Java 2 Platform, Standard Edition,
105      * v 1.4.
106      *
107      * Added a simple assertion facility.
108      */
109     RELEASE_4,
110 
111     /**
112      * The version recognized by the Java 2 Platform, Standard
113      * Edition 5.0.
114      *
115      * The language described in
116      * &lt;cite&gt;The Java&amp;trade; Language Specification,
117      * Third Edition&lt;/cite&gt;.  First release to support
118      * generics, annotations, autoboxing, var-args, enhanced {@code
119      * for} loop, and hexadecimal floating-point literals.
120      */
121     RELEASE_5,
122 
123     /**
124      * The version recognized by the Java Platform, Standard Edition
125      * 6.
126      *
127      * No major changes from {@code RELEASE_5}.
128      */
129     RELEASE_6,
130 
131     /**
132      * The version recognized by the Java Platform, Standard Edition
133      * 7.
134      *
135      * Additions in this release include, diamond syntax for
136      * constructors, {@code try}-with-resources, strings in switch,
137      * binary literals, and multi-catch.
138      * @since 1.7
139      */
140     RELEASE_7,
141 
142     /**
143      * The version recognized by the Java Platform, Standard Edition
144      * 8.
145      *
146      * Additions in this release include lambda expressions and default methods.
147      * @since 1.8
148      */
149     RELEASE_8,
150 
151     /**
152      * The version recognized by the Java Platform, Standard Edition
153      * 9.
154      *
155      * Additions in this release include modules and removal of a
156      * single underscore from the set of legal identifier names.
157      *
158      * @since 9
159      */
160      RELEASE_9,
161 
162     /**
163      * The version recognized by the Java Platform, Standard Edition
164      * 10.
165      *
166      * Additions in this release include local-variable type inference
167      * ({@code var}).
168      *
169      * @since 10
170      */
171      RELEASE_10,
172 
173     /**
174      * The version recognized by the Java Platform, Standard Edition
175      * 11.
176      *
177      * Additions in this release include local-variable syntax for
178      * lambda parameters.
179      *
180      * @since 11
181      */
182      RELEASE_11,
183 
184     /**
185      * The version recognized by the Java Platform, Standard Edition
186      * 12.
187      *
188      * @since 12
189      */
190      RELEASE_12,
191 
192     /**
193      * The version recognized by the Java Platform, Standard Edition
194      * 13.
195      *
196      * @since 13
197      */
198      RELEASE_13,
199 
200     /**
201      * The version recognized by the Java Platform, Standard Edition
202      * 14.
203      *
204      * Additions in this release include switch expressions.
205      *
206      * @since 14
207      */
208     RELEASE_14,
209 
210     /**
211      * The version recognized by the Java Platform, Standard Edition
212      * 15.
213      *
214      * @since 15
215      */
216      RELEASE_15;
217 
218     // Note that when adding constants for newer releases, the
219     // behavior of latest() and latestSupported() must be updated too.
220 
221     /**
222      * Returns the latest source version that can be modeled.
223      *
224      * @return the latest source version that can be modeled
225      */
226     public static SourceVersion latest() {
227         return RELEASE_15;
228     }
229 
230     private static final SourceVersion latestSupported = getLatestSupported();
231 
232     /*
233      * The integer version to enum constant mapping implemented by
234      * this method assumes the JEP 322: &quot;Time-Based Release
235      * Versioning&quot; scheme is in effect. This scheme began in JDK
236      * 10. If the JDK versioning scheme is revised, this method may
237      * need to be updated accordingly.
238      */
239     private static SourceVersion getLatestSupported() {
240         int intVersion = Runtime.version().feature();
241         return (intVersion &gt;= 11) ?
242             valueOf(&quot;RELEASE_&quot; + Math.min(15, intVersion)):
243             RELEASE_10;
244     }
245 
246     /**
247      * Returns the latest source version fully supported by the
248      * current execution environment.  {@code RELEASE_9} or later must
249      * be returned.
250      *
251      * @apiNote This method is included alongside {@link latest} to
252      * allow identification of situations where the language model API
253      * is running on a platform version different than the latest
254      * version modeled by the API. One way that sort of situation can
255      * occur is if an IDE or similar tool is using the API to model
256      * source version &lt;i&gt;N&lt;/i&gt; while running on platform version
257      * (&lt;i&gt;N&lt;/i&gt;&amp;nbsp;-&amp;nbsp;1). Running in this configuration is
258      * supported by the API. Running an API on platform versions
259      * earlier than (&lt;i&gt;N&lt;/i&gt;&amp;nbsp;-&amp;nbsp;1) or later than &lt;i&gt;N&lt;/i&gt;
260      * may or may not work as an implementation detail. If an
261      * annotation processor was generating code to run under the
262      * current execution environment, the processor should only use
263      * platform features up to the {@code latestSupported} release,
264      * which may be earlier than the {@code latest} release.
265      *
266      * @return the latest source version that is fully supported
267      */
268     public static SourceVersion latestSupported() {
269         return latestSupported;
270     }
271 
272     /**
273      * Returns whether or not {@code name} is a syntactically valid
274      * identifier (simple name) or keyword in the latest source
275      * version.  The method returns {@code true} if the name consists
276      * of an initial character for which {@link
277      * Character#isJavaIdentifierStart(int)} returns {@code true},
278      * followed only by characters for which {@link
279      * Character#isJavaIdentifierPart(int)} returns {@code true}.
280      * This pattern matches regular identifiers, keywords, restricted
281      * keywords, restricted identifiers and the literals {@code &quot;true&quot;},
282      * {@code &quot;false&quot;}, {@code &quot;null&quot;}.
283      *
284      * The method returns {@code false} for all other strings.
285      *
286      * @param name the string to check
287      * @return {@code true} if this string is a
288      * syntactically valid identifier or keyword, {@code false}
289      * otherwise.
290      */
291     public static boolean isIdentifier(CharSequence name) {
292         String id = name.toString();
293 
294         if (id.length() == 0) {
295             return false;
296         }
297         int cp = id.codePointAt(0);
298         if (!Character.isJavaIdentifierStart(cp)) {
299             return false;
300         }
301         for (int i = Character.charCount(cp);
302                 i &lt; id.length();
303                 i += Character.charCount(cp)) {
304             cp = id.codePointAt(i);
305             if (!Character.isJavaIdentifierPart(cp)) {
306                 return false;
307             }
308         }
309         return true;
310     }
311 
312     /**
313      * Returns whether or not {@code name} is a syntactically valid
314      * qualified name in the latest source version.  Unlike {@link
315      * #isIdentifier isIdentifier}, this method returns {@code false}
316      * for keywords, boolean literals, and the null literal.
317      *
318      * This method returns {@code true} for &lt;i&gt;restricted
319      * keywords&lt;/i&gt; and &lt;i&gt;restricted identifiers&lt;/i&gt;
320      *
321      * @param name the string to check
322      * @return {@code true} if this string is a
323      * syntactically valid name, {@code false} otherwise.
324      * @jls 3.9 Keywords
325      * @jls 6.2 Names and Identifiers
326      */
327     public static boolean isName(CharSequence name) {
328         return isName(name, latest());
329     }
330 
331     /**
332      * Returns whether or not {@code name} is a syntactically valid
333      * qualified name in the given source version.  Unlike {@link
334      * #isIdentifier isIdentifier}, this method returns {@code false}
335      * for keywords, boolean literals, and the null literal.
336      *
337      * This method returns {@code true} for &lt;i&gt;restricted
338      * keywords&lt;/i&gt; and &lt;i&gt;restricted identifiers&lt;/i&gt;
339      *
340      * @param name the string to check
341      * @param version the version to use
342      * @return {@code true} if this string is a
343      * syntactically valid name, {@code false} otherwise.
344      * @jls 3.9 Keywords
345      * @jls 6.2 Names and Identifiers
346      * @since 9
347      */
348     public static boolean isName(CharSequence name, SourceVersion version) {
349         String id = name.toString();
350 
351         for(String s : id.split(&quot;\\.&quot;, -1)) {
352             if (!isIdentifier(s) || isKeyword(s, version))
353                 return false;
354         }
355         return true;
356     }
357 
358     /**
359      * Returns whether or not {@code s} is a keyword, boolean literal,
360      * or null literal in the latest source version.
361      * This method returns {@code false} for &lt;i&gt;restricted
362      * keywords&lt;/i&gt; and &lt;i&gt;restricted identifiers&lt;/i&gt;.
363      *
364      * @param s the string to check
365      * @return {@code true} if {@code s} is a keyword, or boolean
366      * literal, or null literal, {@code false} otherwise.
367      * @jls 3.9 Keywords
368      * @jls 3.10.3 Boolean Literals
369      * @jls 3.10.7 The Null Literal
370      */
371     public static boolean isKeyword(CharSequence s) {
372         return isKeyword(s, latest());
373     }
374 
375     /**
376      * Returns whether or not {@code s} is a keyword, boolean literal,
377      * or null literal in the given source version.
378      * This method returns {@code false} for &lt;i&gt;restricted
379      * keywords&lt;/i&gt; and &lt;i&gt;restricted identifiers&lt;/i&gt;.
380      *
381      * @param s the string to check
382      * @param version the version to use
383      * @return {@code true} if {@code s} is a keyword, or boolean
384      * literal, or null literal, {@code false} otherwise.
385      * @jls 3.9 Keywords
386      * @jls 3.10.3 Boolean Literals
387      * @jls 3.10.7 The Null Literal
388      * @since 9
389      */
390     public static boolean isKeyword(CharSequence s, SourceVersion version) {
391         String id = s.toString();
392         switch(id) {
393             // A trip through history
394         case &quot;strictfp&quot;:
395             return version.compareTo(RELEASE_2) &gt;= 0;
396 
397         case &quot;assert&quot;:
398             return version.compareTo(RELEASE_4) &gt;= 0;
399 
400         case &quot;enum&quot;:
401             return version.compareTo(RELEASE_5) &gt;= 0;
402 
403         case &quot;_&quot;:
404             return version.compareTo(RELEASE_9) &gt;= 0;
405 
406             // Keywords common across versions
407 
408             // Modifiers
409         case &quot;public&quot;:    case &quot;protected&quot;: case &quot;private&quot;:
410         case &quot;abstract&quot;:  case &quot;static&quot;:    case &quot;final&quot;:
411         case &quot;transient&quot;: case &quot;volatile&quot;:  case &quot;synchronized&quot;:
412         case &quot;native&quot;:
413 
414             // Declarations
415         case &quot;class&quot;:     case &quot;interface&quot;: case &quot;extends&quot;:
416         case &quot;package&quot;:   case &quot;throws&quot;:    case &quot;implements&quot;:
417 
418             // Primitive types and void
419         case &quot;boolean&quot;:   case &quot;byte&quot;:      case &quot;char&quot;:
420         case &quot;short&quot;:     case &quot;int&quot;:       case &quot;long&quot;:
421         case &quot;float&quot;:     case &quot;double&quot;:
422         case &quot;void&quot;:
423 
424             // Control flow
425         case &quot;if&quot;:      case &quot;else&quot;:
426         case &quot;try&quot;:     case &quot;catch&quot;:    case &quot;finally&quot;:
427         case &quot;do&quot;:      case &quot;while&quot;:
428         case &quot;for&quot;:     case &quot;continue&quot;:
429         case &quot;switch&quot;:  case &quot;case&quot;:     case &quot;default&quot;:
430         case &quot;break&quot;:   case &quot;throw&quot;:    case &quot;return&quot;:
431 
432             // Other keywords
433         case  &quot;this&quot;:   case &quot;new&quot;:      case &quot;super&quot;:
434         case &quot;import&quot;:  case &quot;instanceof&quot;:
435 
436             // Forbidden!
437         case &quot;goto&quot;:        case &quot;const&quot;:
438 
439             // literals
440         case &quot;null&quot;:         case &quot;true&quot;:       case &quot;false&quot;:
441             return true;
442 
443         default:
444             return false;
445         }
446     }
447 }
    </pre>
  </body>
</html>
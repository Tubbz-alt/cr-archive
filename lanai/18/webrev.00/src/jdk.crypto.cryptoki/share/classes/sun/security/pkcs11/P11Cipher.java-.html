<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.crypto.cryptoki/share/classes/sun/security/pkcs11/P11Cipher.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package sun.security.pkcs11;
 26 
 27 import java.nio.ByteBuffer;
 28 import java.util.Arrays;
 29 import java.util.Locale;
 30 
 31 import java.security.*;
 32 import java.security.spec.*;
 33 
 34 import javax.crypto.*;
 35 import javax.crypto.spec.*;
 36 
 37 import sun.nio.ch.DirectBuffer;
 38 import sun.security.jca.JCAUtil;
 39 import sun.security.pkcs11.wrapper.*;
 40 import static sun.security.pkcs11.wrapper.PKCS11Constants.*;
 41 
 42 /**
 43  * Cipher implementation class. This class currently supports
 44  * DES, DESede, AES, ARCFOUR, and Blowfish.
 45  *
 46  * This class is designed to support ECB, CBC, CTR with NoPadding
 47  * and ECB, CBC with PKCS5Padding. It will use its own padding impl
 48  * if the native mechanism does not support padding.
 49  *
 50  * Note that PKCS#11 currently only supports ECB, CBC, and CTR.
 51  * There are no provisions for other modes such as CFB, OFB, and PCBC.
 52  *
 53  * @author  Andreas Sterbenz
 54  * @since   1.5
 55  */
 56 final class P11Cipher extends CipherSpi {
 57 
 58     // mode constant for ECB mode
 59     private final static int MODE_ECB = 3;
 60     // mode constant for CBC mode
 61     private final static int MODE_CBC = 4;
 62     // mode constant for CTR mode
 63     private final static int MODE_CTR = 5;
 64 
 65     // padding constant for NoPadding
 66     private final static int PAD_NONE = 5;
 67     // padding constant for PKCS5Padding
 68     private final static int PAD_PKCS5 = 6;
 69 
 70     private static interface Padding {
 71         // ENC: format the specified buffer with padding bytes and return the
 72         // actual padding length
 73         int setPaddingBytes(byte[] paddingBuffer, int padLen);
 74 
 75         // DEC: return the length of trailing padding bytes given the specified
 76         // padded data
 77         int unpad(byte[] paddedData, int len)
 78                 throws BadPaddingException, IllegalBlockSizeException;
 79     }
 80 
 81     private static class PKCS5Padding implements Padding {
 82 
 83         private final int blockSize;
 84 
 85         PKCS5Padding(int blockSize)
 86                 throws NoSuchPaddingException {
 87             if (blockSize == 0) {
 88                 throw new NoSuchPaddingException
 89                         (&quot;PKCS#5 padding not supported with stream ciphers&quot;);
 90             }
 91             this.blockSize = blockSize;
 92         }
 93 
 94         public int setPaddingBytes(byte[] paddingBuffer, int padLen) {
 95             Arrays.fill(paddingBuffer, 0, padLen, (byte) (padLen &amp; 0x007f));
 96             return padLen;
 97         }
 98 
 99         public int unpad(byte[] paddedData, int len)
100                 throws BadPaddingException, IllegalBlockSizeException {
101             if ((len &lt; 1) || (len % blockSize != 0)) {
102                 throw new IllegalBlockSizeException
103                     (&quot;Input length must be multiples of &quot; + blockSize);
104             }
105             byte padValue = paddedData[len - 1];
106             if (padValue &lt; 1 || padValue &gt; blockSize) {
107                 throw new BadPaddingException(&quot;Invalid pad value!&quot;);
108             }
109             // sanity check padding bytes
110             int padStartIndex = len - padValue;
111             for (int i = padStartIndex; i &lt; len; i++) {
112                 if (paddedData[i] != padValue) {
113                     throw new BadPaddingException(&quot;Invalid pad bytes!&quot;);
114                 }
115             }
116             return padValue;
117         }
118     }
119 
120     // token instance
121     private final Token token;
122 
123     // algorithm name
124     private final String algorithm;
125 
126     // name of the key algorithm, e.g. DES instead of algorithm DES/CBC/...
127     private final String keyAlgorithm;
128 
129     // mechanism id
130     private final long mechanism;
131 
132     // associated session, if any
133     private Session session;
134 
135     // key, if init() was called
136     private P11Key p11Key;
137 
138     // flag indicating whether an operation is initialized
139     private boolean initialized;
140 
141     // falg indicating encrypt or decrypt mode
142     private boolean encrypt;
143 
144     // mode, one of MODE_* above (MODE_ECB for stream ciphers)
145     private int blockMode;
146 
147     // block size, 0 for stream ciphers
148     private final int blockSize;
149 
150     // padding type, on of PAD_* above (PAD_NONE for stream ciphers)
151     private int paddingType;
152 
153     // when the padding is requested but unsupported by the native mechanism,
154     // we use the following to do padding and necessary data buffering.
155     // padding object which generate padding and unpad the decrypted data
156     private Padding paddingObj;
157     // buffer for holding back the block which contains padding bytes
158     private byte[] padBuffer;
159     private int padBufferLen;
160 
161     // original IV, if in MODE_CBC or MODE_CTR
162     private byte[] iv;
163 
164     // number of bytes buffered internally by the native mechanism and padBuffer
165     // if we do the padding
166     private int bytesBuffered;
167 
168     // length of key size in bytes; currently only used by AES given its oid
169     // specification mandates a fixed size of the key
170     private int fixedKeySize = -1;
171 
172     P11Cipher(Token token, String algorithm, long mechanism)
173             throws PKCS11Exception, NoSuchAlgorithmException {
174         super();
175         this.token = token;
176         this.algorithm = algorithm;
177         this.mechanism = mechanism;
178 
179         String[] algoParts = algorithm.split(&quot;/&quot;);
180 
181         if (algoParts[0].startsWith(&quot;AES&quot;)) {
182             blockSize = 16;
183             int index = algoParts[0].indexOf(&#39;_&#39;);
184             if (index != -1) {
185                 // should be well-formed since we specify what we support
186                 fixedKeySize = Integer.parseInt(algoParts[0].substring(index+1))/8;
187             }
188             keyAlgorithm = &quot;AES&quot;;
189         } else {
190             keyAlgorithm = algoParts[0];
191             if (keyAlgorithm.equals(&quot;RC4&quot;) ||
192                     keyAlgorithm.equals(&quot;ARCFOUR&quot;)) {
193                 blockSize = 0;
194             } else { // DES, DESede, Blowfish
195                 blockSize = 8;
196             }
197         }
198         this.blockMode =
199             (algoParts.length &gt; 1 ? parseMode(algoParts[1]) : MODE_ECB);
200         String defPadding = (blockSize == 0 ? &quot;NoPadding&quot; : &quot;PKCS5Padding&quot;);
201         String paddingStr =
202                 (algoParts.length &gt; 2 ? algoParts[2] : defPadding);
203         try {
204             engineSetPadding(paddingStr);
205         } catch (NoSuchPaddingException nspe) {
206             // should not happen
207             throw new ProviderException(nspe);
208         }
209     }
210 
211     protected void engineSetMode(String mode) throws NoSuchAlgorithmException {
212         // Disallow change of mode for now since currently it&#39;s explicitly
213         // defined in transformation strings
214         throw new NoSuchAlgorithmException(&quot;Unsupported mode &quot; + mode);
215     }
216 
217     private int parseMode(String mode) throws NoSuchAlgorithmException {
218         mode = mode.toUpperCase(Locale.ENGLISH);
219         int result;
220         if (mode.equals(&quot;ECB&quot;)) {
221             result = MODE_ECB;
222         } else if (mode.equals(&quot;CBC&quot;)) {
223             if (blockSize == 0) {
224                 throw new NoSuchAlgorithmException
225                         (&quot;CBC mode not supported with stream ciphers&quot;);
226             }
227             result = MODE_CBC;
228         } else if (mode.equals(&quot;CTR&quot;)) {
229             result = MODE_CTR;
230         } else {
231             throw new NoSuchAlgorithmException(&quot;Unsupported mode &quot; + mode);
232         }
233         return result;
234     }
235 
236     // see JCE spec
237     protected void engineSetPadding(String padding)
238             throws NoSuchPaddingException {
239         paddingObj = null;
240         padBuffer = null;
241         padding = padding.toUpperCase(Locale.ENGLISH);
242         if (padding.equals(&quot;NOPADDING&quot;)) {
243             paddingType = PAD_NONE;
244         } else if (padding.equals(&quot;PKCS5PADDING&quot;)) {
245             if (this.blockMode == MODE_CTR) {
246                 throw new NoSuchPaddingException
247                     (&quot;PKCS#5 padding not supported with CTR mode&quot;);
248             }
249             paddingType = PAD_PKCS5;
250             if (mechanism != CKM_DES_CBC_PAD &amp;&amp; mechanism != CKM_DES3_CBC_PAD &amp;&amp;
251                     mechanism != CKM_AES_CBC_PAD) {
252                 // no native padding support; use our own padding impl
253                 paddingObj = new PKCS5Padding(blockSize);
254                 padBuffer = new byte[blockSize];
255             }
256         } else {
257             throw new NoSuchPaddingException(&quot;Unsupported padding &quot; + padding);
258         }
259     }
260 
261     // see JCE spec
262     protected int engineGetBlockSize() {
263         return blockSize;
264     }
265 
266     // see JCE spec
267     protected int engineGetOutputSize(int inputLen) {
268         return doFinalLength(inputLen);
269     }
270 
271     // see JCE spec
272     protected byte[] engineGetIV() {
273         return (iv == null) ? null : iv.clone();
274     }
275 
276     // see JCE spec
277     protected AlgorithmParameters engineGetParameters() {
278         if (iv == null) {
279             return null;
280         }
281         IvParameterSpec ivSpec = new IvParameterSpec(iv);
282         try {
283             AlgorithmParameters params =
284                     AlgorithmParameters.getInstance(keyAlgorithm,
285                     P11Util.getSunJceProvider());
286             params.init(ivSpec);
287             return params;
288         } catch (GeneralSecurityException e) {
289             // NoSuchAlgorithmException, NoSuchProviderException
290             // InvalidParameterSpecException
291             throw new ProviderException(&quot;Could not encode parameters&quot;, e);
292         }
293     }
294 
295     // see JCE spec
296     protected void engineInit(int opmode, Key key, SecureRandom random)
297             throws InvalidKeyException {
298         try {
299             implInit(opmode, key, null, random);
300         } catch (InvalidAlgorithmParameterException e) {
301             throw new InvalidKeyException(&quot;init() failed&quot;, e);
302         }
303     }
304 
305     // see JCE spec
306     protected void engineInit(int opmode, Key key,
307             AlgorithmParameterSpec params, SecureRandom random)
308             throws InvalidKeyException, InvalidAlgorithmParameterException {
309         byte[] ivValue;
310         if (params != null) {
311             if (params instanceof IvParameterSpec == false) {
312                 throw new InvalidAlgorithmParameterException
313                         (&quot;Only IvParameterSpec supported&quot;);
314             }
315             IvParameterSpec ivSpec = (IvParameterSpec) params;
316             ivValue = ivSpec.getIV();
317         } else {
318             ivValue = null;
319         }
320         implInit(opmode, key, ivValue, random);
321     }
322 
323     // see JCE spec
324     protected void engineInit(int opmode, Key key, AlgorithmParameters params,
325             SecureRandom random)
326             throws InvalidKeyException, InvalidAlgorithmParameterException {
327         byte[] ivValue;
328         if (params != null) {
329             try {
330                 IvParameterSpec ivSpec =
331                         params.getParameterSpec(IvParameterSpec.class);
332                 ivValue = ivSpec.getIV();
333             } catch (InvalidParameterSpecException e) {
334                 throw new InvalidAlgorithmParameterException
335                         (&quot;Could not decode IV&quot;, e);
336             }
337         } else {
338             ivValue = null;
339         }
340         implInit(opmode, key, ivValue, random);
341     }
342 
343     // actual init() implementation
344     private void implInit(int opmode, Key key, byte[] iv,
345             SecureRandom random)
346             throws InvalidKeyException, InvalidAlgorithmParameterException {
347         reset(true);
348         if (fixedKeySize != -1 &amp;&amp; key.getEncoded().length != fixedKeySize) {
349             throw new InvalidKeyException(&quot;Key size is invalid&quot;);
350         }
351         switch (opmode) {
352             case Cipher.ENCRYPT_MODE:
353                 encrypt = true;
354                 break;
355             case Cipher.DECRYPT_MODE:
356                 encrypt = false;
357                 break;
358             default:
359                 throw new InvalidAlgorithmParameterException
360                         (&quot;Unsupported mode: &quot; + opmode);
361         }
362         if (blockMode == MODE_ECB) { // ECB or stream cipher
363             if (iv != null) {
364                 if (blockSize == 0) {
365                     throw new InvalidAlgorithmParameterException
366                             (&quot;IV not used with stream ciphers&quot;);
367                 } else {
368                     throw new InvalidAlgorithmParameterException
369                             (&quot;IV not used in ECB mode&quot;);
370                 }
371             }
372         } else { // MODE_CBC or MODE_CTR
373             if (iv == null) {
374                 if (encrypt == false) {
375                     String exMsg =
376                         (blockMode == MODE_CBC ?
377                          &quot;IV must be specified for decryption in CBC mode&quot; :
378                          &quot;IV must be specified for decryption in CTR mode&quot;);
379                     throw new InvalidAlgorithmParameterException(exMsg);
380                 }
381                 // generate random IV
382                 if (random == null) {
383                     random = JCAUtil.getSecureRandom();
384                 }
385                 iv = new byte[blockSize];
386                 random.nextBytes(iv);
387             } else {
388                 if (iv.length != blockSize) {
389                     throw new InvalidAlgorithmParameterException
390                             (&quot;IV length must match block size&quot;);
391                 }
392             }
393         }
394         this.iv = iv;
395         p11Key = P11SecretKeyFactory.convertKey(token, key, keyAlgorithm);
396         try {
397             initialize();
398         } catch (PKCS11Exception e) {
399             throw new InvalidKeyException(&quot;Could not initialize cipher&quot;, e);
400         }
401     }
402 
403     // reset the states to the pre-initialized values
404     // need to be called after doFinal or prior to re-init
405     private void reset(boolean doCancel) {
406         if (!initialized) {
407             return;
408         }
409         initialized = false;
410         try {
411             if (session == null) {
412                 return;
413             }
414             if (doCancel &amp;&amp; token.explicitCancel) {
415                 cancelOperation();
416             }
417         } finally {
418             p11Key.releaseKeyID();
419             session = token.releaseSession(session);
420             bytesBuffered = 0;
421             padBufferLen = 0;
422         }
423     }
424 
425     private void cancelOperation() {
426         token.ensureValid();
427         if (session.hasObjects() == false) {
428             session = token.killSession(session);
429             return;
430         } else {
431             try {
432                 // cancel operation by finishing it
433                 int bufLen = doFinalLength(0);
434                 byte[] buffer = new byte[bufLen];
435                 if (encrypt) {
436                     token.p11.C_EncryptFinal(session.id(), 0, buffer, 0, bufLen);
437                 } else {
438                     token.p11.C_DecryptFinal(session.id(), 0, buffer, 0, bufLen);
439                 }
440             } catch (PKCS11Exception e) {
441                 throw new ProviderException(&quot;Cancel failed&quot;, e);
442             }
443         }
444     }
445 
446     private void ensureInitialized() throws PKCS11Exception {
447         if (!initialized) {
448             initialize();
449         }
450     }
451 
452     private void initialize() throws PKCS11Exception {
453         if (p11Key == null) {
454             throw new ProviderException(
455                     &quot;Operation cannot be performed without&quot;
456                     + &quot; calling engineInit first&quot;);
457         }
458         token.ensureValid();
459         long p11KeyID = p11Key.getKeyID();
460         try {
461             if (session == null) {
462                 session = token.getOpSession();
463             }
464             CK_MECHANISM mechParams = (blockMode == MODE_CTR?
465                     new CK_MECHANISM(mechanism, new CK_AES_CTR_PARAMS(iv)) :
466                     new CK_MECHANISM(mechanism, iv));
467             if (encrypt) {
468                 token.p11.C_EncryptInit(session.id(), mechParams, p11KeyID);
469             } else {
470                 token.p11.C_DecryptInit(session.id(), mechParams, p11KeyID);
471             }
472         } catch (PKCS11Exception e) {
473             p11Key.releaseKeyID();
474             session = token.releaseSession(session);
475             throw e;
476         }
477         initialized = true;
478         bytesBuffered = 0;
479         padBufferLen = 0;
480     }
481 
482     // if update(inLen) is called, how big does the output buffer have to be?
483     private int updateLength(int inLen) {
484         if (inLen &lt;= 0) {
485             return 0;
486         }
487 
488         int result = inLen + bytesBuffered;
489         if (blockSize != 0 &amp;&amp; blockMode != MODE_CTR) {
490             // minus the number of bytes in the last incomplete block.
491             result -= (result &amp; (blockSize - 1));
492         }
493         return result;
494     }
495 
496     // if doFinal(inLen) is called, how big does the output buffer have to be?
497     private int doFinalLength(int inLen) {
498         if (inLen &lt; 0) {
499             return 0;
500         }
501 
502         int result = inLen + bytesBuffered;
503         if (blockSize != 0 &amp;&amp; encrypt &amp;&amp; paddingType != PAD_NONE) {
504             // add the number of bytes to make the last block complete.
505             result += (blockSize - (result &amp; (blockSize - 1)));
506         }
507         return result;
508     }
509 
510     // see JCE spec
511     protected byte[] engineUpdate(byte[] in, int inOfs, int inLen) {
512         try {
513             byte[] out = new byte[updateLength(inLen)];
514             int n = engineUpdate(in, inOfs, inLen, out, 0);
515             return P11Util.convert(out, 0, n);
516         } catch (ShortBufferException e) {
517             // convert since the output length is calculated by updateLength()
518             throw new ProviderException(e);
519         }
520     }
521 
522     // see JCE spec
523     protected int engineUpdate(byte[] in, int inOfs, int inLen, byte[] out,
524             int outOfs) throws ShortBufferException {
525         int outLen = out.length - outOfs;
526         return implUpdate(in, inOfs, inLen, out, outOfs, outLen);
527     }
528 
529     // see JCE spec
530     @Override
531     protected int engineUpdate(ByteBuffer inBuffer, ByteBuffer outBuffer)
532             throws ShortBufferException {
533         return implUpdate(inBuffer, outBuffer);
534     }
535 
536     // see JCE spec
537     protected byte[] engineDoFinal(byte[] in, int inOfs, int inLen)
538             throws IllegalBlockSizeException, BadPaddingException {
539         try {
540             byte[] out = new byte[doFinalLength(inLen)];
541             int n = engineDoFinal(in, inOfs, inLen, out, 0);
542             return P11Util.convert(out, 0, n);
543         } catch (ShortBufferException e) {
544             // convert since the output length is calculated by doFinalLength()
545             throw new ProviderException(e);
546         }
547     }
548 
549     // see JCE spec
550     protected int engineDoFinal(byte[] in, int inOfs, int inLen, byte[] out,
551             int outOfs) throws ShortBufferException, IllegalBlockSizeException,
552             BadPaddingException {
553         int n = 0;
554         if ((inLen != 0) &amp;&amp; (in != null)) {
555             n = engineUpdate(in, inOfs, inLen, out, outOfs);
556             outOfs += n;
557         }
558         n += implDoFinal(out, outOfs, out.length - outOfs);
559         return n;
560     }
561 
562     // see JCE spec
563     @Override
564     protected int engineDoFinal(ByteBuffer inBuffer, ByteBuffer outBuffer)
565             throws ShortBufferException, IllegalBlockSizeException,
566             BadPaddingException {
567         int n = engineUpdate(inBuffer, outBuffer);
568         n += implDoFinal(outBuffer);
569         return n;
570     }
571 
572     private int implUpdate(byte[] in, int inOfs, int inLen,
573             byte[] out, int outOfs, int outLen) throws ShortBufferException {
574         if (outLen &lt; updateLength(inLen)) {
575             throw new ShortBufferException();
576         }
577         try {
578             ensureInitialized();
579             int k = 0;
580             if (encrypt) {
581                 k = token.p11.C_EncryptUpdate(session.id(), 0, in, inOfs, inLen,
582                         0, out, outOfs, outLen);
583             } else {
584                 int newPadBufferLen = 0;
585                 if (paddingObj != null) {
586                     if (padBufferLen != 0) {
587                         // NSS throws up when called with data not in multiple
588                         // of blocks. Try to work around this by holding the
589                         // extra data in padBuffer.
590                         if (padBufferLen != padBuffer.length) {
591                             int bufCapacity = padBuffer.length - padBufferLen;
592                             if (inLen &gt; bufCapacity) {
593                                 bufferInputBytes(in, inOfs, bufCapacity);
594                                 inOfs += bufCapacity;
595                                 inLen -= bufCapacity;
596                             } else {
597                                 bufferInputBytes(in, inOfs, inLen);
598                                 return 0;
599                             }
600                         }
601                         k = token.p11.C_DecryptUpdate(session.id(),
602                                 0, padBuffer, 0, padBufferLen,
603                                 0, out, outOfs, outLen);
604                         padBufferLen = 0;
605                     }
606                     newPadBufferLen = inLen &amp; (blockSize - 1);
607                     if (newPadBufferLen == 0) {
608                         newPadBufferLen = padBuffer.length;
609                     }
610                     inLen -= newPadBufferLen;
611                 }
612                 if (inLen &gt; 0) {
613                     k += token.p11.C_DecryptUpdate(session.id(), 0, in, inOfs,
614                             inLen, 0, out, (outOfs + k), (outLen - k));
615                 }
616                 // update &#39;padBuffer&#39; if using our own padding impl.
617                 if (paddingObj != null) {
618                     bufferInputBytes(in, inOfs + inLen, newPadBufferLen);
619                 }
620             }
621             bytesBuffered += (inLen - k);
622             return k;
623         } catch (PKCS11Exception e) {
624             if (e.getErrorCode() == CKR_BUFFER_TOO_SMALL) {
625                 throw (ShortBufferException)
626                         (new ShortBufferException().initCause(e));
627             }
628             reset(false);
629             throw new ProviderException(&quot;update() failed&quot;, e);
630         }
631     }
632 
633     private int implUpdate(ByteBuffer inBuffer, ByteBuffer outBuffer)
634             throws ShortBufferException {
635         int inLen = inBuffer.remaining();
636         if (inLen &lt;= 0) {
637             return 0;
638         }
639 
640         int outLen = outBuffer.remaining();
641         if (outLen &lt; updateLength(inLen)) {
642             throw new ShortBufferException();
643         }
644         int origPos = inBuffer.position();
645         try {
646             ensureInitialized();
647 
648             long inAddr = 0;
649             int inOfs = 0;
650             byte[] inArray = null;
651 
652             if (inBuffer instanceof DirectBuffer) {
653                 inAddr = ((DirectBuffer) inBuffer).address();
654                 inOfs = origPos;
655             } else if (inBuffer.hasArray()) {
656                 inArray = inBuffer.array();
657                 inOfs = (origPos + inBuffer.arrayOffset());
658             }
659 
660             long outAddr = 0;
661             int outOfs = 0;
662             byte[] outArray = null;
663             if (outBuffer instanceof DirectBuffer) {
664                 outAddr = ((DirectBuffer) outBuffer).address();
665                 outOfs = outBuffer.position();
666             } else {
667                 if (outBuffer.hasArray()) {
668                     outArray = outBuffer.array();
669                     outOfs = (outBuffer.position() + outBuffer.arrayOffset());
670                 } else {
671                     outArray = new byte[outLen];
672                 }
673             }
674 
675             int k = 0;
676             if (encrypt) {
677                 if (inAddr == 0 &amp;&amp; inArray == null) {
678                     inArray = new byte[inLen];
679                     inBuffer.get(inArray);
680                 } else {
681                     inBuffer.position(origPos + inLen);
682                 }
683                 k = token.p11.C_EncryptUpdate(session.id(),
684                         inAddr, inArray, inOfs, inLen,
685                         outAddr, outArray, outOfs, outLen);
686             } else {
687                 int newPadBufferLen = 0;
688                 if (paddingObj != null) {
689                     if (padBufferLen != 0) {
690                         // NSS throws up when called with data not in multiple
691                         // of blocks. Try to work around this by holding the
692                         // extra data in padBuffer.
693                         if (padBufferLen != padBuffer.length) {
694                             int bufCapacity = padBuffer.length - padBufferLen;
695                             if (inLen &gt; bufCapacity) {
696                                 bufferInputBytes(inBuffer, bufCapacity);
697                                 inOfs += bufCapacity;
698                                 inLen -= bufCapacity;
699                             } else {
700                                 bufferInputBytes(inBuffer, inLen);
701                                 return 0;
702                             }
703                         }
704                         k = token.p11.C_DecryptUpdate(session.id(), 0,
705                                 padBuffer, 0, padBufferLen, outAddr, outArray,
706                                 outOfs, outLen);
707                         padBufferLen = 0;
708                     }
709                     newPadBufferLen = inLen &amp; (blockSize - 1);
710                     if (newPadBufferLen == 0) {
711                         newPadBufferLen = padBuffer.length;
712                     }
713                     inLen -= newPadBufferLen;
714                 }
715                 if (inLen &gt; 0) {
716                     if (inAddr == 0 &amp;&amp; inArray == null) {
717                         inArray = new byte[inLen];
718                         inBuffer.get(inArray);
719                     } else {
720                         inBuffer.position(inBuffer.position() + inLen);
721                     }
722                     k += token.p11.C_DecryptUpdate(session.id(), inAddr,
723                             inArray, inOfs, inLen, outAddr, outArray,
724                             (outOfs + k), (outLen - k));
725                 }
726                 // update &#39;padBuffer&#39; if using our own padding impl.
727                 if (paddingObj != null &amp;&amp; newPadBufferLen != 0) {
728                     bufferInputBytes(inBuffer, newPadBufferLen);
729                 }
730             }
731             bytesBuffered += (inLen - k);
732             if (!(outBuffer instanceof DirectBuffer) &amp;&amp;
733                     !outBuffer.hasArray()) {
734                 outBuffer.put(outArray, outOfs, k);
735             } else {
736                 outBuffer.position(outBuffer.position() + k);
737             }
738             return k;
739         } catch (PKCS11Exception e) {
740             // Reset input buffer to its original position for
741             inBuffer.position(origPos);
742             if (e.getErrorCode() == CKR_BUFFER_TOO_SMALL) {
743                 throw (ShortBufferException)
744                         (new ShortBufferException().initCause(e));
745             }
746             reset(false);
747             throw new ProviderException(&quot;update() failed&quot;, e);
748         }
749     }
750 
751     private int implDoFinal(byte[] out, int outOfs, int outLen)
752             throws ShortBufferException, IllegalBlockSizeException,
753             BadPaddingException {
754         int requiredOutLen = doFinalLength(0);
755         if (outLen &lt; requiredOutLen) {
756             throw new ShortBufferException();
757         }
758         boolean doCancel = true;
759         try {
760             ensureInitialized();
761             int k = 0;
762             if (encrypt) {
763                 if (paddingObj != null) {
764                     int actualPadLen = paddingObj.setPaddingBytes(padBuffer,
765                             requiredOutLen - bytesBuffered);
766                     k = token.p11.C_EncryptUpdate(session.id(),
767                             0, padBuffer, 0, actualPadLen,
768                             0, out, outOfs, outLen);
769                 }
770                 k += token.p11.C_EncryptFinal(session.id(),
771                         0, out, (outOfs + k), (outLen - k));
772                 doCancel = false;
773             } else {
774                 // Special handling to match SunJCE provider behavior
775                 if (bytesBuffered == 0 &amp;&amp; padBufferLen == 0) {
776                     return 0;
777                 }
778                 if (paddingObj != null) {
779                     if (padBufferLen != 0) {
780                         k = token.p11.C_DecryptUpdate(session.id(), 0,
781                                 padBuffer, 0, padBufferLen, 0, padBuffer, 0,
782                                 padBuffer.length);
783                     }
784                     k += token.p11.C_DecryptFinal(session.id(), 0, padBuffer, k,
785                             padBuffer.length - k);
786                     doCancel = false;
787 
788                     int actualPadLen = paddingObj.unpad(padBuffer, k);
789                     k -= actualPadLen;
790                     System.arraycopy(padBuffer, 0, out, outOfs, k);
791                 } else {
792                     k = token.p11.C_DecryptFinal(session.id(), 0, out, outOfs,
793                             outLen);
794                     doCancel = false;
795                 }
796             }
797             return k;
798         } catch (PKCS11Exception e) {
799             doCancel = false;
800             handleException(e);
801             throw new ProviderException(&quot;doFinal() failed&quot;, e);
802         } finally {
803             reset(doCancel);
804         }
805     }
806 
807     private int implDoFinal(ByteBuffer outBuffer)
808             throws ShortBufferException, IllegalBlockSizeException,
809             BadPaddingException {
810         int outLen = outBuffer.remaining();
811         int requiredOutLen = doFinalLength(0);
812         if (outLen &lt; requiredOutLen) {
813             throw new ShortBufferException();
814         }
815 
816         boolean doCancel = true;
817         try {
818             ensureInitialized();
819 
820             long outAddr = 0;
821             byte[] outArray = null;
822             int outOfs = 0;
823             if (outBuffer instanceof DirectBuffer) {
824                 outAddr = ((DirectBuffer) outBuffer).address();
825                 outOfs = outBuffer.position();
826             } else {
827                 if (outBuffer.hasArray()) {
828                     outArray = outBuffer.array();
829                     outOfs = outBuffer.position() + outBuffer.arrayOffset();
830                 } else {
831                     outArray = new byte[outLen];
832                 }
833             }
834 
835             int k = 0;
836 
837             if (encrypt) {
838                 if (paddingObj != null) {
839                     int actualPadLen = paddingObj.setPaddingBytes(padBuffer,
840                             requiredOutLen - bytesBuffered);
841                     k = token.p11.C_EncryptUpdate(session.id(),
842                             0, padBuffer, 0, actualPadLen,
843                             outAddr, outArray, outOfs, outLen);
844                 }
845                 k += token.p11.C_EncryptFinal(session.id(),
846                         outAddr, outArray, (outOfs + k), (outLen - k));
847                 doCancel = false;
848             } else {
849                 // Special handling to match SunJCE provider behavior
850                 if (bytesBuffered == 0 &amp;&amp; padBufferLen == 0) {
851                     return 0;
852                 }
853 
854                 if (paddingObj != null) {
855                     if (padBufferLen != 0) {
856                         k = token.p11.C_DecryptUpdate(session.id(),
857                                 0, padBuffer, 0, padBufferLen,
858                                 0, padBuffer, 0, padBuffer.length);
859                         padBufferLen = 0;
860                     }
861                     k += token.p11.C_DecryptFinal(session.id(),
862                             0, padBuffer, k, padBuffer.length - k);
863                     doCancel = false;
864 
865                     int actualPadLen = paddingObj.unpad(padBuffer, k);
866                     k -= actualPadLen;
867                     outArray = padBuffer;
868                     outOfs = 0;
869                 } else {
870                     k = token.p11.C_DecryptFinal(session.id(),
871                             outAddr, outArray, outOfs, outLen);
872                     doCancel = false;
873                 }
874             }
875             if ((!encrypt &amp;&amp; paddingObj != null) ||
876                     (!(outBuffer instanceof DirectBuffer) &amp;&amp;
877                     !outBuffer.hasArray())) {
878                 outBuffer.put(outArray, outOfs, k);
879             } else {
880                 outBuffer.position(outBuffer.position() + k);
881             }
882             return k;
883         } catch (PKCS11Exception e) {
884             doCancel = false;
885             handleException(e);
886             throw new ProviderException(&quot;doFinal() failed&quot;, e);
887         } finally {
888             reset(doCancel);
889         }
890     }
891 
892     private void handleException(PKCS11Exception e)
893             throws ShortBufferException, IllegalBlockSizeException {
894         long errorCode = e.getErrorCode();
895         if (errorCode == CKR_BUFFER_TOO_SMALL) {
896             throw (ShortBufferException)
897                     (new ShortBufferException().initCause(e));
898         } else if (errorCode == CKR_DATA_LEN_RANGE ||
899                    errorCode == CKR_ENCRYPTED_DATA_LEN_RANGE) {
900             throw (IllegalBlockSizeException)
901                     (new IllegalBlockSizeException(e.toString()).initCause(e));
902         }
903     }
904 
905     // see JCE spec
906     protected byte[] engineWrap(Key key) throws IllegalBlockSizeException,
907             InvalidKeyException {
908         // XXX key wrapping
909         throw new UnsupportedOperationException(&quot;engineWrap()&quot;);
910     }
911 
912     // see JCE spec
913     protected Key engineUnwrap(byte[] wrappedKey, String wrappedKeyAlgorithm,
914             int wrappedKeyType)
915             throws InvalidKeyException, NoSuchAlgorithmException {
916         // XXX key unwrapping
917         throw new UnsupportedOperationException(&quot;engineUnwrap()&quot;);
918     }
919 
920     // see JCE spec
921     @Override
922     protected int engineGetKeySize(Key key) throws InvalidKeyException {
923         int n = P11SecretKeyFactory.convertKey
924                 (token, key, keyAlgorithm).length();
925         return n;
926     }
927 
928     private final void bufferInputBytes(byte[] in, int inOfs, int len) {
929         System.arraycopy(in, inOfs, padBuffer, padBufferLen, len);
930         padBufferLen += len;
931         bytesBuffered += len;
932     }
933 
934     private final void bufferInputBytes(ByteBuffer inBuffer, int len) {
935         inBuffer.get(padBuffer, padBufferLen, len);
936         padBufferLen += len;
937         bytesBuffered += len;
938     }
939 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.crypto.cryptoki/share/classes/sun/security/pkcs11/Secmod.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2005, 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.pkcs11;
 27 
 28 import java.io.*;
 29 import java.util.*;
 30 
 31 import java.security.*;
 32 import java.security.KeyStore.*;
 33 import java.security.cert.X509Certificate;
 34 
 35 import sun.security.pkcs11.wrapper.*;
 36 import static sun.security.pkcs11.wrapper.PKCS11Constants.*;
 37 
 38 
 39 /**
 40  * The Secmod class defines the interface to the native NSS
 41  * library and the configuration information it stores in its
 42  * secmod.db file.
 43  *
 44  * &lt;p&gt;Example code:
 45  * &lt;pre&gt;
 46  *   Secmod secmod = Secmod.getInstance();
 47  *   if (secmod.isInitialized() == false) {
 48  *       secmod.initialize(&quot;/home/myself/.mozilla&quot;);
 49  *   }
 50  *
 51  *   Provider p = secmod.getModule(ModuleType.KEYSTORE).getProvider();
 52  *   KeyStore ks = KeyStore.getInstance(&quot;PKCS11&quot;, p);
 53  *   ks.load(null, password);
 54  * &lt;/pre&gt;
 55  *
 56  * @since   1.6
 57  * @author  Andreas Sterbenz
 58  */
 59 public final class Secmod {
 60 
 61     private final static boolean DEBUG = false;
 62 
 63     private final static Secmod INSTANCE;
 64 
 65     static {
 66         sun.security.pkcs11.wrapper.PKCS11.loadNative();
 67         INSTANCE = new Secmod();
 68     }
 69 
 70     private final static String NSS_LIB_NAME = &quot;nss3&quot;;
 71 
 72     private final static String SOFTTOKEN_LIB_NAME = &quot;softokn3&quot;;
 73 
 74     private final static String TRUST_LIB_NAME = &quot;nssckbi&quot;;
 75 
 76     // handle to be passed to the native code, 0 means not initialized
 77     private long nssHandle;
 78 
 79     // whether this is a supported version of NSS
 80     private boolean supported;
 81 
 82     // list of the modules
 83     private List&lt;Module&gt; modules;
 84 
 85     private String configDir;
 86 
 87     private String nssLibDir;
 88 
 89     private Secmod() {
 90         // empty
 91     }
 92 
 93     /**
 94      * Return the singleton Secmod instance.
 95      */
 96     public static Secmod getInstance() {
 97         return INSTANCE;
 98     }
 99 
100     private boolean isLoaded() {
101         if (nssHandle == 0) {
102             nssHandle = nssGetLibraryHandle(System.mapLibraryName(NSS_LIB_NAME));
103             if (nssHandle != 0) {
104                 fetchVersions();
105             }
106         }
107         return (nssHandle != 0);
108     }
109 
110     private void fetchVersions() {
111         supported = nssVersionCheck(nssHandle, &quot;3.7&quot;);
112     }
113 
114     /**
115      * Test whether this Secmod has been initialized. Returns true
116      * if NSS has been initialized using either the initialize() method
117      * or by directly calling the native NSS APIs. The latter may be
118      * the case if the current process contains components that use
119      * NSS directly.
120      *
121      * @throws IOException if an incompatible version of NSS
122      *   has been loaded
123      */
124     public synchronized boolean isInitialized() throws IOException {
125         // NSS does not allow us to check if it is initialized already
126         // assume that if it is loaded it is also initialized
127         if (isLoaded() == false) {
128             return false;
129         }
130         if (supported == false) {
131             throw new IOException
132                 (&quot;An incompatible version of NSS is already loaded, &quot;
133                 + &quot;3.7 or later required&quot;);
134         }
135         return true;
136     }
137 
138     String getConfigDir() {
139         return configDir;
140     }
141 
142     String getLibDir() {
143         return nssLibDir;
144     }
145 
146     /**
147      * Initialize this Secmod.
148      *
149      * @param configDir the directory containing the NSS configuration
150      *   files such as secmod.db
151      * @param nssLibDir the directory containing the NSS libraries
152      *   (libnss3.so or nss3.dll) or null if the library is on
153      *   the system default shared library path
154      *
155      * @throws IOException if NSS has already been initialized,
156      *   the specified directories are invalid, or initialization
157      *   fails for any other reason
158      */
159     public void initialize(String configDir, String nssLibDir)
160             throws IOException {
161         initialize(DbMode.READ_WRITE, configDir, nssLibDir, false);
162     }
163 
164     public void initialize(DbMode dbMode, String configDir, String nssLibDir)
165             throws IOException {
166         initialize(dbMode, configDir, nssLibDir, false);
167     }
168 
169     public synchronized void initialize(DbMode dbMode, String configDir,
170         String nssLibDir, boolean nssOptimizeSpace) throws IOException {
171 
172         if (isInitialized()) {
173             throw new IOException(&quot;NSS is already initialized&quot;);
174         }
175 
176         if (dbMode == null) {
177             throw new NullPointerException();
178         }
179         if ((dbMode != DbMode.NO_DB) &amp;&amp; (configDir == null)) {
180             throw new NullPointerException();
181         }
182         String platformLibName = System.mapLibraryName(&quot;nss3&quot;);
183         String platformPath;
184         if (nssLibDir == null) {
185             platformPath = platformLibName;
186         } else {
187             File base = new File(nssLibDir);
188             if (base.isDirectory() == false) {
189                 throw new IOException(&quot;nssLibDir must be a directory:&quot; + nssLibDir);
190             }
191             File platformFile = new File(base, platformLibName);
192             if (platformFile.isFile() == false) {
193                 throw new FileNotFoundException(platformFile.getPath());
194             }
195             platformPath = platformFile.getPath();
196         }
197 
198         if (configDir != null) {
199             String configDirPath = null;
200             String sqlPrefix = &quot;sql:&quot;;
201             if (!configDir.startsWith(sqlPrefix)) {
202                 configDirPath = configDir;
203             } else {
204                 StringBuilder configDirPathSB = new StringBuilder(configDir);
205                 configDirPath = configDirPathSB.substring(sqlPrefix.length());
206             }
207             File configBase = new File(configDirPath);
208             if (configBase.isDirectory() == false ) {
209                 throw new IOException(&quot;configDir must be a directory: &quot; + configDirPath);
210             }
211             if (!configDir.startsWith(sqlPrefix)) {
212                 File secmodFile = new File(configBase, &quot;secmod.db&quot;);
213                 if (secmodFile.isFile() == false) {
214                     throw new FileNotFoundException(secmodFile.getPath());
215                 }
216             }
217         }
218 
219         if (DEBUG) System.out.println(&quot;lib: &quot; + platformPath);
220         nssHandle = nssLoadLibrary(platformPath);
221         if (DEBUG) System.out.println(&quot;handle: &quot; + nssHandle);
222         fetchVersions();
223         if (supported == false) {
224             throw new IOException
225                 (&quot;The specified version of NSS is incompatible, &quot;
226                 + &quot;3.7 or later required&quot;);
227         }
228 
229         if (DEBUG) System.out.println(&quot;dir: &quot; + configDir);
230         boolean initok = nssInitialize(dbMode.functionName, nssHandle,
231             configDir, nssOptimizeSpace);
232         if (DEBUG) System.out.println(&quot;init: &quot; + initok);
233         if (initok == false) {
234             throw new IOException(&quot;NSS initialization failed&quot;);
235         }
236 
237         this.configDir = configDir;
238         this.nssLibDir = nssLibDir;
239     }
240 
241     /**
242      * Return an immutable list of all available modules.
243      *
244      * @throws IllegalStateException if this Secmod is misconfigured
245      *   or not initialized
246      */
247     public synchronized List&lt;Module&gt; getModules() {
248         try {
249             if (isInitialized() == false) {
250                 throw new IllegalStateException(&quot;NSS not initialized&quot;);
251             }
252         } catch (IOException e) {
253             // IOException if misconfigured
254             throw new IllegalStateException(e);
255         }
256         if (modules == null) {
257             @SuppressWarnings(&quot;unchecked&quot;)
258             List&lt;Module&gt; modules = (List&lt;Module&gt;)nssGetModuleList(nssHandle,
259                 nssLibDir);
260             this.modules = Collections.unmodifiableList(modules);
261         }
262         return modules;
263     }
264 
265     private static byte[] getDigest(X509Certificate cert, String algorithm) {
266         try {
267             MessageDigest md = MessageDigest.getInstance(algorithm);
268             return md.digest(cert.getEncoded());
269         } catch (GeneralSecurityException e) {
270             throw new ProviderException(e);
271         }
272     }
273 
274     boolean isTrusted(X509Certificate cert, TrustType trustType) {
275         Bytes bytes = new Bytes(getDigest(cert, &quot;SHA-1&quot;));
276         TrustAttributes attr = getModuleTrust(ModuleType.KEYSTORE, bytes);
277         if (attr == null) {
278             attr = getModuleTrust(ModuleType.FIPS, bytes);
279             if (attr == null) {
280                 attr = getModuleTrust(ModuleType.TRUSTANCHOR, bytes);
281             }
282         }
283         return (attr == null) ? false : attr.isTrusted(trustType);
284     }
285 
286     private TrustAttributes getModuleTrust(ModuleType type, Bytes bytes) {
287         Module module = getModule(type);
288         TrustAttributes t = (module == null) ? null : module.getTrust(bytes);
289         return t;
290     }
291 
292     /**
293      * Constants describing the different types of NSS modules.
294      * For this API, NSS modules are classified as either one
295      * of the internal modules delivered as part of NSS or
296      * as an external module provided by a 3rd party.
297      */
298     public static enum ModuleType {
299         /**
300          * The NSS Softtoken crypto module. This is the first
301          * slot of the softtoken object.
302          * This module provides
303          * implementations for cryptographic algorithms but no KeyStore.
304          */
305         CRYPTO,
306         /**
307          * The NSS Softtoken KeyStore module. This is the second
308          * slot of the softtoken object.
309          * This module provides
310          * implementations for cryptographic algorithms (after login)
311          * and the KeyStore.
312          */
313         KEYSTORE,
314         /**
315          * The NSS Softtoken module in FIPS mode. Note that in FIPS mode the
316          * softtoken presents only one slot, not separate CRYPTO and KEYSTORE
317          * slots as in non-FIPS mode.
318          */
319         FIPS,
320         /**
321          * The NSS builtin trust anchor module. This is the
322          * NSSCKBI object. It provides no crypto functions.
323          */
324         TRUSTANCHOR,
325         /**
326          * An external module.
327          */
328         EXTERNAL,
329     }
330 
331     /**
332      * Returns the first module of the specified type. If no such
333      * module exists, this method returns null.
334      *
335      * @throws IllegalStateException if this Secmod is misconfigured
336      *   or not initialized
337      */
338     public Module getModule(ModuleType type) {
339         for (Module module : getModules()) {
340             if (module.getType() == type) {
341                 return module;
342             }
343         }
344         return null;
345     }
346 
347     static final String TEMPLATE_EXTERNAL =
348         &quot;library = %s\n&quot;
349         + &quot;name = \&quot;%s\&quot;\n&quot;
350         + &quot;slotListIndex = %d\n&quot;;
351 
352     static final String TEMPLATE_TRUSTANCHOR =
353         &quot;library = %s\n&quot;
354         + &quot;name = \&quot;NSS Trust Anchors\&quot;\n&quot;
355         + &quot;slotListIndex = 0\n&quot;
356         + &quot;enabledMechanisms = { KeyStore }\n&quot;
357         + &quot;nssUseSecmodTrust = true\n&quot;;
358 
359     static final String TEMPLATE_CRYPTO =
360         &quot;library = %s\n&quot;
361         + &quot;name = \&quot;NSS SoftToken Crypto\&quot;\n&quot;
362         + &quot;slotListIndex = 0\n&quot;
363         + &quot;disabledMechanisms = { KeyStore }\n&quot;;
364 
365     static final String TEMPLATE_KEYSTORE =
366         &quot;library = %s\n&quot;
367         + &quot;name = \&quot;NSS SoftToken KeyStore\&quot;\n&quot;
368         + &quot;slotListIndex = 1\n&quot;
369         + &quot;nssUseSecmodTrust = true\n&quot;;
370 
371     static final String TEMPLATE_FIPS =
372         &quot;library = %s\n&quot;
373         + &quot;name = \&quot;NSS FIPS SoftToken\&quot;\n&quot;
374         + &quot;slotListIndex = 0\n&quot;
375         + &quot;nssUseSecmodTrust = true\n&quot;;
376 
377     /**
378      * A representation of one PKCS#11 slot in a PKCS#11 module.
379      */
380     public static final class Module {
381         // path of the native library
382         final String libraryName;
383         // descriptive name used by NSS
384         final String commonName;
385         final int slot;
386         final ModuleType type;
387 
388         private String config;
389         private SunPKCS11 provider;
390 
391         // trust attributes. Used for the KEYSTORE and TRUSTANCHOR modules only
392         private Map&lt;Bytes,TrustAttributes&gt; trust;
393 
394         Module(String libraryDir, String libraryName, String commonName,
395                 boolean fips, int slot) {
396             ModuleType type;
397 
398             if ((libraryName == null) || (libraryName.length() == 0)) {
399                 // must be softtoken
400                 libraryName = System.mapLibraryName(SOFTTOKEN_LIB_NAME);
401                 if (fips == false) {
402                     type = (slot == 0) ? ModuleType.CRYPTO : ModuleType.KEYSTORE;
403                 } else {
404                     type = ModuleType.FIPS;
405                     if (slot != 0) {
406                         throw new RuntimeException
407                             (&quot;Slot index should be 0 for FIPS slot&quot;);
408                     }
409                 }
410             } else {
411                 if (libraryName.endsWith(System.mapLibraryName(TRUST_LIB_NAME))
412                         || commonName.equals(&quot;Builtin Roots Module&quot;)) {
413                     type = ModuleType.TRUSTANCHOR;
414                 } else {
415                     type = ModuleType.EXTERNAL;
416                 }
417                 if (fips) {
418                     throw new RuntimeException(&quot;FIPS flag set for non-internal &quot;
419                         + &quot;module: &quot; + libraryName + &quot;, &quot; + commonName);
420                 }
421             }
422             // On Ubuntu the libsoftokn3 library is located in a subdirectory
423             // of the system libraries directory. (Since Ubuntu 11.04.)
424             File libraryFile = new File(libraryDir, libraryName);
425             if (!libraryFile.isFile()) {
426                File failover = new File(libraryDir, &quot;nss/&quot; + libraryName);
427                if (failover.isFile()) {
428                    libraryFile = failover;
429                }
430             }
431             this.libraryName = libraryFile.getPath();
432             this.commonName = commonName;
433             this.slot = slot;
434             this.type = type;
435             initConfiguration();
436         }
437 
438         private void initConfiguration() {
439             switch (type) {
440             case EXTERNAL:
441                 config = String.format(TEMPLATE_EXTERNAL, libraryName,
442                                             commonName + &quot; &quot; + slot, slot);
443                 break;
444             case CRYPTO:
445                 config = String.format(TEMPLATE_CRYPTO, libraryName);
446                 break;
447             case KEYSTORE:
448                 config = String.format(TEMPLATE_KEYSTORE, libraryName);
449                 break;
450             case FIPS:
451                 config = String.format(TEMPLATE_FIPS, libraryName);
452                 break;
453             case TRUSTANCHOR:
454                 config = String.format(TEMPLATE_TRUSTANCHOR, libraryName);
455                 break;
456             default:
457                 throw new RuntimeException(&quot;Unknown module type: &quot; + type);
458             }
459         }
460 
461         /**
462          * Get the configuration for this module. This is a string
463          * in the SunPKCS11 configuration format. It can be
464          * customized with additional options and then made
465          * current using the setConfiguration() method.
466          */
467         @Deprecated
468         public synchronized String getConfiguration() {
469             return config;
470         }
471 
472         /**
473          * Set the configuration for this module.
474          *
475          * @throws IllegalStateException if the associated provider
476          *   instance has already been created.
477          */
478         @Deprecated
479         public synchronized void setConfiguration(String config) {
480             if (provider != null) {
481                 throw new IllegalStateException(&quot;Provider instance already created&quot;);
482             }
483             this.config = config;
484         }
485 
486         /**
487          * Return the pathname of the native library that implements
488          * this module. For example, /usr/lib/libpkcs11.so.
489          */
490         public String getLibraryName() {
491             return libraryName;
492         }
493 
494         /**
495          * Returns the type of this module.
496          */
497         public ModuleType getType() {
498             return type;
499         }
500 
501         /**
502          * Returns the provider instance that is associated with this
503          * module. The first call to this method creates the provider
504          * instance.
505          */
506         @Deprecated
507         public synchronized Provider getProvider() {
508             if (provider == null) {
509                 provider = newProvider();
510             }
511             return provider;
512         }
513 
514         synchronized boolean hasInitializedProvider() {
515             return provider != null;
516         }
517 
518         void setProvider(SunPKCS11 p) {
519             if (provider != null) {
520                 throw new ProviderException(&quot;Secmod provider already initialized&quot;);
521             }
522             provider = p;
523         }
524 
525         private SunPKCS11 newProvider() {
526             try {
527                 return new SunPKCS11(new Config(&quot;--&quot; + config));
528             } catch (Exception e) {
529                 // XXX
530                 throw new ProviderException(e);
531             }
532         }
533 
534         synchronized void setTrust(Token token, X509Certificate cert) {
535             Bytes bytes = new Bytes(getDigest(cert, &quot;SHA-1&quot;));
536             TrustAttributes attr = getTrust(bytes);
537             if (attr == null) {
538                 attr = new TrustAttributes(token, cert, bytes, CKT_NETSCAPE_TRUSTED_DELEGATOR);
539                 trust.put(bytes, attr);
540             } else {
541                 // does it already have the correct trust settings?
542                 if (attr.isTrusted(TrustType.ALL) == false) {
543                     // XXX not yet implemented
544                     throw new ProviderException(&quot;Cannot change existing trust attributes&quot;);
545                 }
546             }
547         }
548 
549         TrustAttributes getTrust(Bytes hash) {
550             if (trust == null) {
551                 // If provider is not set, create a temporary provider to
552                 // retrieve the trust information. This can happen if we need
553                 // to get the trust information for the trustanchor module
554                 // because we need to look for user customized settings in the
555                 // keystore module (which may not have a provider created yet).
556                 // Creating a temporary provider and then dropping it on the
557                 // floor immediately is flawed, but it&#39;s the best we can do
558                 // for now.
559                 synchronized (this) {
560                     SunPKCS11 p = provider;
561                     if (p == null) {
562                         p = newProvider();
563                     }
564                     try {
565                         trust = Secmod.getTrust(p);
566                     } catch (PKCS11Exception e) {
567                         throw new RuntimeException(e);
568                     }
569                 }
570             }
571             return trust.get(hash);
572         }
573 
574         public String toString() {
575             return
576             commonName + &quot; (&quot; + type + &quot;, &quot; + libraryName + &quot;, slot &quot; + slot + &quot;)&quot;;
577         }
578 
579     }
580 
581     /**
582      * Constants representing NSS trust categories.
583      */
584     public static enum TrustType {
585         /** Trusted for all purposes */
586         ALL,
587         /** Trusted for SSL client authentication */
588         CLIENT_AUTH,
589         /** Trusted for SSL server authentication */
590         SERVER_AUTH,
591         /** Trusted for code signing */
592         CODE_SIGNING,
593         /** Trusted for email protection */
594         EMAIL_PROTECTION,
595     }
596 
597     public static enum DbMode {
598         READ_WRITE(&quot;NSS_InitReadWrite&quot;),
599         READ_ONLY (&quot;NSS_Init&quot;),
600         NO_DB     (&quot;NSS_NoDB_Init&quot;);
601 
602         final String functionName;
603         DbMode(String functionName) {
604             this.functionName = functionName;
605         }
606     }
607 
608     /**
609      * A LoadStoreParameter for use with the NSS Softtoken or
610      * NSS TrustAnchor KeyStores.
611      * &lt;p&gt;
612      * It allows the set of trusted certificates that are returned by
613      * the KeyStore to be specified.
614      */
615     public static final class KeyStoreLoadParameter implements LoadStoreParameter {
616         final TrustType trustType;
617         final ProtectionParameter protection;
618         public KeyStoreLoadParameter(TrustType trustType, char[] password) {
619             this(trustType, new PasswordProtection(password));
620 
621         }
622         public KeyStoreLoadParameter(TrustType trustType, ProtectionParameter prot) {
623             if (trustType == null) {
624                 throw new NullPointerException(&quot;trustType must not be null&quot;);
625             }
626             this.trustType = trustType;
627             this.protection = prot;
628         }
629         public ProtectionParameter getProtectionParameter() {
630             return protection;
631         }
632         public TrustType getTrustType() {
633             return trustType;
634         }
635     }
636 
637     static class TrustAttributes {
638         final long handle;
639         final long clientAuth, serverAuth, codeSigning, emailProtection;
640         final byte[] shaHash;
641         TrustAttributes(Token token, X509Certificate cert, Bytes bytes, long trustValue) {
642             Session session = null;
643             try {
644                 session = token.getOpSession();
645                 // XXX use KeyStore TrustType settings to determine which
646                 // attributes to set
647                 CK_ATTRIBUTE[] attrs = new CK_ATTRIBUTE[] {
648                     new CK_ATTRIBUTE(CKA_TOKEN, true),
649                     new CK_ATTRIBUTE(CKA_CLASS, CKO_NETSCAPE_TRUST),
650                     new CK_ATTRIBUTE(CKA_NETSCAPE_TRUST_SERVER_AUTH, trustValue),
651                     new CK_ATTRIBUTE(CKA_NETSCAPE_TRUST_CODE_SIGNING, trustValue),
652                     new CK_ATTRIBUTE(CKA_NETSCAPE_TRUST_EMAIL_PROTECTION, trustValue),
653                     new CK_ATTRIBUTE(CKA_NETSCAPE_TRUST_CLIENT_AUTH, trustValue),
654                     new CK_ATTRIBUTE(CKA_NETSCAPE_CERT_SHA1_HASH, bytes.b),
655                     new CK_ATTRIBUTE(CKA_NETSCAPE_CERT_MD5_HASH, getDigest(cert, &quot;MD5&quot;)),
656                     new CK_ATTRIBUTE(CKA_ISSUER, cert.getIssuerX500Principal().getEncoded()),
657                     new CK_ATTRIBUTE(CKA_SERIAL_NUMBER, cert.getSerialNumber().toByteArray()),
658                     // XXX per PKCS#11 spec, the serial number should be in ASN.1
659                 };
660                 handle = token.p11.C_CreateObject(session.id(), attrs);
661                 shaHash = bytes.b;
662                 clientAuth = trustValue;
663                 serverAuth = trustValue;
664                 codeSigning = trustValue;
665                 emailProtection = trustValue;
666             } catch (PKCS11Exception e) {
667                 throw new ProviderException(&quot;Could not create trust object&quot;, e);
668             } finally {
669                 token.releaseSession(session);
670             }
671         }
672         TrustAttributes(Token token, Session session, long handle)
673                         throws PKCS11Exception {
674             this.handle = handle;
675             CK_ATTRIBUTE[] attrs = new CK_ATTRIBUTE[] {
676                 new CK_ATTRIBUTE(CKA_NETSCAPE_TRUST_SERVER_AUTH),
677                 new CK_ATTRIBUTE(CKA_NETSCAPE_TRUST_CODE_SIGNING),
678                 new CK_ATTRIBUTE(CKA_NETSCAPE_TRUST_EMAIL_PROTECTION),
679                 new CK_ATTRIBUTE(CKA_NETSCAPE_CERT_SHA1_HASH),
680             };
681 
682             token.p11.C_GetAttributeValue(session.id(), handle, attrs);
683             serverAuth = attrs[0].getLong();
684             codeSigning = attrs[1].getLong();
685             emailProtection = attrs[2].getLong();
686             shaHash = attrs[3].getByteArray();
687 
688             attrs = new CK_ATTRIBUTE[] {
689                 new CK_ATTRIBUTE(CKA_NETSCAPE_TRUST_CLIENT_AUTH),
690             };
691             long c;
692             try {
693                 token.p11.C_GetAttributeValue(session.id(), handle, attrs);
694                 c = attrs[0].getLong();
695             } catch (PKCS11Exception e) {
696                 // trust anchor module does not support this attribute
697                 c = serverAuth;
698             }
699             clientAuth = c;
700         }
701         Bytes getHash() {
702             return new Bytes(shaHash);
703         }
704         boolean isTrusted(TrustType type) {
705             switch (type) {
706             case CLIENT_AUTH:
707                 return isTrusted(clientAuth);
708             case SERVER_AUTH:
709                 return isTrusted(serverAuth);
710             case CODE_SIGNING:
711                 return isTrusted(codeSigning);
712             case EMAIL_PROTECTION:
713                 return isTrusted(emailProtection);
714             case ALL:
715                 return isTrusted(TrustType.CLIENT_AUTH)
716                     &amp;&amp; isTrusted(TrustType.SERVER_AUTH)
717                     &amp;&amp; isTrusted(TrustType.CODE_SIGNING)
718                     &amp;&amp; isTrusted(TrustType.EMAIL_PROTECTION);
719             default:
720                 return false;
721             }
722         }
723 
724         private boolean isTrusted(long l) {
725             // XXX CKT_TRUSTED?
726             return (l == CKT_NETSCAPE_TRUSTED_DELEGATOR);
727         }
728 
729     }
730 
731     private static class Bytes {
732         final byte[] b;
733         Bytes(byte[] b) {
734             this.b = b;
735         }
736         public int hashCode() {
737             return Arrays.hashCode(b);
738         }
739         public boolean equals(Object o) {
740             if (this == o) {
741                 return true;
742             }
743             if (o instanceof Bytes == false) {
744                 return false;
745             }
746             Bytes other = (Bytes)o;
747             return Arrays.equals(this.b, other.b);
748         }
749     }
750 
751     private static Map&lt;Bytes,TrustAttributes&gt; getTrust(SunPKCS11 provider)
752             throws PKCS11Exception {
753         Map&lt;Bytes,TrustAttributes&gt; trustMap = new HashMap&lt;Bytes,TrustAttributes&gt;();
754         Token token = provider.getToken();
755         Session session = null;
756         boolean exceptionOccurred = true;
757         try {
758             session = token.getOpSession();
759             int MAX_NUM = 8192;
760             CK_ATTRIBUTE[] attrs = new CK_ATTRIBUTE[] {
761                 new CK_ATTRIBUTE(CKA_CLASS, CKO_NETSCAPE_TRUST),
762             };
763             token.p11.C_FindObjectsInit(session.id(), attrs);
764             long[] handles = token.p11.C_FindObjects(session.id(), MAX_NUM);
765             token.p11.C_FindObjectsFinal(session.id());
766             if (DEBUG) System.out.println(&quot;handles: &quot; + handles.length);
767 
768             for (long handle : handles) {
769                 try {
770                     TrustAttributes trust = new TrustAttributes(token, session, handle);
771                     trustMap.put(trust.getHash(), trust);
772                 } catch (PKCS11Exception e) {
773                     // skip put on pkcs11 error
774                 }
775             }
776             exceptionOccurred = false;
777         } finally {
778             if (exceptionOccurred) {
779                 token.killSession(session);
780             } else {
781                 token.releaseSession(session);
782             }
783         }
784         return trustMap;
785     }
786 
787     private static native long nssGetLibraryHandle(String libraryName);
788 
789     private static native long nssLoadLibrary(String name) throws IOException;
790 
791     private static native boolean nssVersionCheck(long handle, String minVersion);
792 
793     private static native boolean nssInitialize(String functionName, long handle, String configDir, boolean nssOptimizeSpace);
794 
795     private static native Object nssGetModuleList(long handle, String libDir);
796 
797 }
    </pre>
  </body>
</html>
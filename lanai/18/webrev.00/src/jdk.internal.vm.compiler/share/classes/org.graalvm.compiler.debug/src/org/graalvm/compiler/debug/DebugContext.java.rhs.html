<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.debug/src/org/graalvm/compiler/debug/DebugContext.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.debug;
  26 
  27 import static java.util.FormattableFlags.LEFT_JUSTIFY;
  28 import static java.util.FormattableFlags.UPPERCASE;
  29 import static org.graalvm.compiler.debug.DebugOptions.Count;
  30 import static org.graalvm.compiler.debug.DebugOptions.Counters;
<a name="2" id="anc2"></a><span class="line-added">  31 import static org.graalvm.compiler.debug.DebugOptions.DisableIntercept;</span>
  32 import static org.graalvm.compiler.debug.DebugOptions.Dump;
  33 import static org.graalvm.compiler.debug.DebugOptions.DumpOnError;
  34 import static org.graalvm.compiler.debug.DebugOptions.DumpOnPhaseChange;
  35 import static org.graalvm.compiler.debug.DebugOptions.DumpPath;
  36 import static org.graalvm.compiler.debug.DebugOptions.ListMetrics;
  37 import static org.graalvm.compiler.debug.DebugOptions.Log;
  38 import static org.graalvm.compiler.debug.DebugOptions.MemUseTrackers;
  39 import static org.graalvm.compiler.debug.DebugOptions.ShowDumpFiles;
  40 import static org.graalvm.compiler.debug.DebugOptions.Time;
  41 import static org.graalvm.compiler.debug.DebugOptions.Timers;
  42 import static org.graalvm.compiler.debug.DebugOptions.TrackMemUse;
  43 
  44 import java.io.ByteArrayOutputStream;
  45 import java.io.File;
  46 import java.io.IOException;
  47 import java.io.PrintStream;
  48 import java.nio.file.Files;
  49 import java.nio.file.Path;
  50 import java.nio.file.Paths;
  51 import java.nio.file.StandardOpenOption;
  52 import java.util.ArrayList;
  53 import java.util.Arrays;
  54 import java.util.Collection;
  55 import java.util.Collections;
  56 import java.util.Formatter;
  57 import java.util.HashMap;
  58 import java.util.List;
  59 import java.util.Map;
  60 import java.util.SortedMap;
  61 import java.util.TreeMap;
  62 
  63 import jdk.internal.vm.compiler.collections.EconomicMap;
  64 import jdk.internal.vm.compiler.collections.EconomicSet;
  65 import jdk.internal.vm.compiler.collections.Pair;
  66 import org.graalvm.compiler.options.OptionKey;
  67 import org.graalvm.compiler.options.OptionValues;
  68 import org.graalvm.compiler.serviceprovider.GraalServices;
  69 import org.graalvm.graphio.GraphOutput;
  70 
  71 import jdk.vm.ci.meta.JavaMethod;
  72 
  73 /**
  74  * A facility for logging and dumping as well as a container for values associated with
  75  * {@link MetricKey}s.
  76  *
  77  * A {@code DebugContext} object must only be used on the thread that created it. This means it
  78  * needs to be passed around as a parameter. For convenience, it can be encapsulated in a widely
  79  * used object that is in scope wherever a {@code DebugContext} is needed. However, care must be
  80  * taken when such objects can be exposed to multiple threads (e.g., they are in a non-thread-local
  81  * cache).
  82  */
  83 public final class DebugContext implements AutoCloseable {
  84 
  85     public static final Description NO_DESCRIPTION = new Description(null, &quot;NO_DESCRIPTION&quot;);
  86     public static final GlobalMetrics NO_GLOBAL_METRIC_VALUES = null;
  87     public static final Iterable&lt;DebugHandlersFactory&gt; NO_CONFIG_CUSTOMIZERS = Collections.emptyList();
  88 
  89     public static final PrintStream DEFAULT_LOG_STREAM = TTY.out;
  90 
  91     /**
  92      * Contains the immutable parts of a debug context. This separation allows the immutable parts
  93      * to be shared and reduces the overhead of initialization since most immutable fields are
  94      * configured by parsing options.
  95      */
  96     final Immutable immutable;
  97 
  98     /**
  99      * Determines whether metrics are enabled.
 100      */
 101     boolean metricsEnabled;
 102 
 103     DebugConfigImpl currentConfig;
 104     ScopeImpl currentScope;
 105     CloseableCounter currentTimer;
 106     CloseableCounter currentMemUseTracker;
 107     Scope lastClosedScope;
 108     Throwable lastExceptionThrown;
 109     private IgvDumpChannel sharedChannel;
 110     private GraphOutput&lt;?, ?&gt; parentOutput;
 111 
 112     /**
 113      * Stores the {@link MetricKey} values.
 114      */
 115     private long[] metricValues;
 116 
 117     /**
 118      * Determines if dynamic scopes are enabled.
 119      */
 120     public boolean areScopesEnabled() {
 121         return immutable.scopesEnabled;
 122     }
 123 
 124     public &lt;G, N, M&gt; GraphOutput&lt;G, M&gt; buildOutput(GraphOutput.Builder&lt;G, N, M&gt; builder) throws IOException {
 125         if (parentOutput != null) {
 126             return builder.build(parentOutput);
 127         } else {
 128             if (sharedChannel == null) {
 129                 sharedChannel = new IgvDumpChannel(() -&gt; getDumpPath(&quot;.bgv&quot;, false), immutable.options);
 130             }
 131             final GraphOutput&lt;G, M&gt; output = builder.build(sharedChannel);
 132             parentOutput = output;
 133             return output;
 134         }
 135     }
 136 
 137     /**
 138      * Adds version properties to the provided map. The version properties are read at a start of
 139      * the JVM from a JVM specific location. Each property identifiers a commit of a certain
 140      * component in the system. The properties added to the {@code properties} map are prefixed with
 141      * {@code &quot;version.&quot;} prefix.
 142      *
 143      * @param properties map to add the version properties to or {@code null}
 144      * @return {@code properties} with version properties added or an unmodifiable map containing
 145      *         the version properties if {@code properties == null}
 146      */
 147     public static Map&lt;Object, Object&gt; addVersionProperties(Map&lt;Object, Object&gt; properties) {
 148         return Versions.VERSIONS.withVersions(properties);
 149     }
 150 
 151     /**
 152      * The immutable configuration that can be shared between {@link DebugContext} objects.
 153      */
 154     static final class Immutable {
 155 
 156         private static final Immutable[] CACHE = new Immutable[5];
 157 
 158         /**
 159          * The options from which this object was configured.
 160          */
 161         final OptionValues options;
 162 
 163         /**
 164          * Specifies if dynamic scopes are enabled.
 165          */
 166         final boolean scopesEnabled;
 167 
 168         final boolean listMetrics;
 169 
 170         /**
 171          * Names of unscoped counters. A counter is unscoped if this set is empty or contains the
 172          * counter&#39;s name.
 173          */
 174         final EconomicSet&lt;String&gt; unscopedCounters;
 175 
 176         /**
 177          * Names of unscoped timers. A timer is unscoped if this set is empty or contains the
 178          * timer&#39;s name.
 179          */
 180         final EconomicSet&lt;String&gt; unscopedTimers;
 181 
 182         /**
 183          * Names of unscoped memory usage trackers. A memory usage tracker is unscoped if this set
 184          * is empty or contains the memory usage tracker&#39;s name.
 185          */
 186         final EconomicSet&lt;String&gt; unscopedMemUseTrackers;
 187 
 188         private static EconomicSet&lt;String&gt; parseUnscopedMetricSpec(String spec, boolean unconditional, boolean accumulatedKey) {
 189             EconomicSet&lt;String&gt; res;
 190             if (spec == null) {
 191                 if (!unconditional) {
 192                     res = null;
 193                 } else {
 194                     res = EconomicSet.create();
 195                 }
 196             } else {
 197                 res = EconomicSet.create();
 198                 if (!spec.isEmpty()) {
 199                     if (!accumulatedKey) {
 200                         res.addAll(Arrays.asList(spec.split(&quot;,&quot;)));
 201                     } else {
 202                         for (String n : spec.split(&quot;,&quot;)) {
 203                             res.add(n + AccumulatedKey.ACCUMULATED_KEY_SUFFIX);
 204                             res.add(n + AccumulatedKey.FLAT_KEY_SUFFIX);
 205                         }
 206                     }
 207 
 208                 }
 209             }
 210             return res;
 211         }
 212 
 213         static Immutable create(OptionValues options) {
 214             int i = 0;
 215             while (i &lt; CACHE.length) {
 216                 Immutable immutable = CACHE[i];
 217                 if (immutable == null) {
 218                     break;
 219                 }
 220                 if (immutable.options == options) {
 221                     return immutable;
 222                 }
 223                 i++;
 224             }
 225             Immutable immutable = new Immutable(options);
 226             if (i &lt; CACHE.length) {
 227                 CACHE[i] = immutable;
 228             }
 229             return immutable;
 230         }
 231 
 232         private static boolean isNotEmpty(OptionKey&lt;String&gt; option, OptionValues options) {
 233             return option.getValue(options) != null &amp;&amp; !option.getValue(options).isEmpty();
 234         }
 235 
 236         private Immutable(OptionValues options) {
 237             this.options = options;
 238             String timeValue = Time.getValue(options);
 239             String trackMemUseValue = TrackMemUse.getValue(options);
 240             this.unscopedCounters = parseUnscopedMetricSpec(Counters.getValue(options), &quot;&quot;.equals(Count.getValue(options)), false);
 241             this.unscopedTimers = parseUnscopedMetricSpec(Timers.getValue(options), &quot;&quot;.equals(timeValue), true);
 242             this.unscopedMemUseTrackers = parseUnscopedMetricSpec(MemUseTrackers.getValue(options), &quot;&quot;.equals(trackMemUseValue), true);
 243 
 244             if (unscopedMemUseTrackers != null || trackMemUseValue != null) {
 245                 if (!GraalServices.isThreadAllocatedMemorySupported()) {
 246                     TTY.println(&quot;WARNING: Missing VM support for MemUseTrackers and TrackMemUse options so all reported memory usage will be 0&quot;);
 247                 }
 248             }
 249 
 250             this.scopesEnabled = DumpOnError.getValue(options) ||
 251                             Dump.getValue(options) != null ||
 252                             Log.getValue(options) != null ||
 253                             isNotEmpty(DebugOptions.Count, options) ||
 254                             isNotEmpty(DebugOptions.Time, options) ||
 255                             isNotEmpty(DebugOptions.TrackMemUse, options) ||
 256                             DumpOnPhaseChange.getValue(options) != null;
 257             this.listMetrics = ListMetrics.getValue(options);
 258         }
 259 
 260         private Immutable() {
 261             this.options = new OptionValues(EconomicMap.create());
 262             this.unscopedCounters = null;
 263             this.unscopedTimers = null;
 264             this.unscopedMemUseTrackers = null;
 265             this.scopesEnabled = false;
 266             this.listMetrics = false;
 267         }
 268 
 269         public boolean hasUnscopedMetrics() {
 270             return unscopedCounters != null || unscopedTimers != null || unscopedMemUseTrackers != null;
 271         }
 272     }
 273 
 274     /**
 275      * Gets the options this debug context was constructed with.
 276      */
 277     public OptionValues getOptions() {
 278         return immutable.options;
 279     }
 280 
 281     static class Activated extends ThreadLocal&lt;DebugContext&gt; {
 282     }
 283 
 284     private static final Activated activated = new Activated();
 285 
 286     /**
 287      * An object used to undo the changes made by DebugContext#activate().
 288      */
 289     public static class Activation implements AutoCloseable {
 290         private final DebugContext parent;
 291 
 292         Activation(DebugContext parent) {
 293             this.parent = parent;
 294         }
 295 
 296         @Override
 297         public void close() {
 298             activated.set(parent);
 299         }
 300     }
 301 
 302     /**
 303      * Activates this object as the debug context {@linkplain DebugContext#forCurrentThread for the
 304      * current thread}. This method should be used in a try-with-resources statement.
 305      *
 306      * @return an object that will deactivate the debug context for the current thread when
 307      *         {@link Activation#close()} is called on it
 308      */
 309     public Activation activate() {
 310         Activation res = new Activation(activated.get());
 311         activated.set(this);
 312         return res;
 313     }
 314 
 315     /**
 316      * Singleton used to represent a disabled debug context.
 317      */
 318     private static final DebugContext DISABLED = new DebugContext(NO_DESCRIPTION, NO_GLOBAL_METRIC_VALUES, DEFAULT_LOG_STREAM, new Immutable(), NO_CONFIG_CUSTOMIZERS);
 319 
 320     /**
 321      * Create a DebugContext with debugging disabled.
 322      */
 323     public static DebugContext disabled(OptionValues options) {
 324         if (options == null || options.getMap().isEmpty()) {
 325             return DISABLED;
 326         }
 327         return new DebugContext(NO_DESCRIPTION, NO_GLOBAL_METRIC_VALUES, DEFAULT_LOG_STREAM, Immutable.create(options), NO_CONFIG_CUSTOMIZERS);
 328     }
 329 
 330     /**
 331      * Gets the debug context for the current thread. This should only be used when there is no
 332      * other reasonable means to get a hold of a debug context.
 333      */
 334     public static DebugContext forCurrentThread() {
 335         DebugContext current = activated.get();
 336         if (current == null) {
 337             return DISABLED;
 338         }
 339         return current;
 340     }
 341 
 342     private final GlobalMetrics globalMetrics;
 343 
 344     /**
 345      * Describes the computation associated with a {@link DebugContext}.
 346      */
 347     public static class Description {
 348         /**
 349          * The primary input to the computation.
 350          */
 351         final Object compilable;
 352 
 353         /**
 354          * A runtime based identifier that is most likely to be unique.
 355          */
 356         final String identifier;
 357 
 358         public Description(Object compilable, String identifier) {
 359             this.compilable = compilable;
 360             this.identifier = identifier;
 361         }
 362 
 363         @Override
 364         public String toString() {
 365             String compilableName = compilable instanceof JavaMethod ? ((JavaMethod) compilable).format(&quot;%H.%n(%p)%R&quot;) : String.valueOf(compilable);
 366             return identifier + &quot;:&quot; + compilableName;
 367         }
 368 
 369         final String getLabel() {
 370             if (compilable instanceof JavaMethod) {
 371                 JavaMethod method = (JavaMethod) compilable;
 372                 return method.format(&quot;%h.%n(%p)%r&quot;);
 373             }
 374             return String.valueOf(compilable);
 375         }
 376     }
 377 
 378     private final Description description;
 379 
 380     /**
 381      * Gets a description of the computation associated with this debug context.
 382      *
 383      * @return {@code null} if no description is available
 384      */
 385     public Description getDescription() {
 386         return description;
 387     }
 388 
 389     /**
 390      * Gets the global metrics associated with this debug context.
 391      *
 392      * @return {@code null} if no global metrics are available
 393      */
 394     public GlobalMetrics getGlobalMetrics() {
 395         return globalMetrics;
 396     }
 397 
 398     /**
 399      * Creates a {@link DebugContext} based on a given set of option values and {@code factory}.
 400      */
 401     public static DebugContext create(OptionValues options, DebugHandlersFactory factory) {
 402         return new DebugContext(NO_DESCRIPTION, NO_GLOBAL_METRIC_VALUES, DEFAULT_LOG_STREAM, Immutable.create(options), Collections.singletonList(factory));
 403     }
 404 
 405     /**
 406      * Creates a {@link DebugContext} based on a given set of option values and {@code factories}.
 407      * The {@link DebugHandlersFactory#LOADER} can be used for the latter.
 408      */
 409     public static DebugContext create(OptionValues options, Iterable&lt;DebugHandlersFactory&gt; factories) {
 410         return new DebugContext(NO_DESCRIPTION, NO_GLOBAL_METRIC_VALUES, DEFAULT_LOG_STREAM, Immutable.create(options), factories);
 411     }
 412 
 413     public static DebugContext create(OptionValues options, PrintStream logStream, DebugHandlersFactory factory) {
 414         return new DebugContext(NO_DESCRIPTION, NO_GLOBAL_METRIC_VALUES, logStream, Immutable.create(options), Collections.singletonList(factory));
 415     }
 416 
 417     /**
 418      * Creates a {@link DebugContext} based on a given set of option values and {@code factories}.
 419      * The {@link DebugHandlersFactory#LOADER} can be used for the latter.
 420      */
 421     public static DebugContext create(OptionValues options, Description description, Iterable&lt;DebugHandlersFactory&gt; factories) {
 422         return new DebugContext(description, NO_GLOBAL_METRIC_VALUES, DEFAULT_LOG_STREAM, Immutable.create(options), factories);
 423     }
 424 
 425     /**
 426      * Creates a {@link DebugContext}.
 427      */
 428     public static DebugContext create(OptionValues options, Description description, GlobalMetrics globalMetrics, PrintStream logStream, Iterable&lt;DebugHandlersFactory&gt; factories) {
 429         return new DebugContext(description, globalMetrics, logStream, Immutable.create(options), factories);
 430     }
 431 
 432     private DebugContext(Description description, GlobalMetrics globalMetrics, PrintStream logStream, Immutable immutable, Iterable&lt;DebugHandlersFactory&gt; factories) {
 433         this.immutable = immutable;
 434         this.description = description;
 435         this.globalMetrics = globalMetrics;
 436         if (immutable.scopesEnabled) {
 437             OptionValues options = immutable.options;
 438             List&lt;DebugDumpHandler&gt; dumpHandlers = new ArrayList&lt;&gt;();
 439             List&lt;DebugVerifyHandler&gt; verifyHandlers = new ArrayList&lt;&gt;();
 440             for (DebugHandlersFactory factory : factories) {
 441                 for (DebugHandler handler : factory.createHandlers(options)) {
 442                     if (handler instanceof DebugDumpHandler) {
 443                         dumpHandlers.add((DebugDumpHandler) handler);
 444                     } else {
 445                         assert handler instanceof DebugVerifyHandler;
 446                         verifyHandlers.add((DebugVerifyHandler) handler);
 447                     }
 448                 }
 449             }
 450             currentConfig = new DebugConfigImpl(options, logStream, dumpHandlers, verifyHandlers);
<a name="3" id="anc3"></a><span class="line-modified"> 451             currentScope = new ScopeImpl(this, Thread.currentThread(), DisableIntercept.getValue(options));</span>
 452             currentScope.updateFlags(currentConfig);
 453             metricsEnabled = true;
 454         } else {
 455             metricsEnabled = immutable.hasUnscopedMetrics() || immutable.listMetrics;
 456         }
 457     }
 458 
 459     public Path getDumpPath(String extension, boolean createMissingDirectory) {
 460         try {
 461             String id = description == null ? null : description.identifier;
 462             String label = description == null ? null : description.getLabel();
 463             Path result = PathUtilities.createUnique(immutable.options, DumpPath, id, label, extension, createMissingDirectory);
 464             if (ShowDumpFiles.getValue(immutable.options)) {
 465                 TTY.println(&quot;Dumping debug output to %s&quot;, result.toAbsolutePath().toString());
 466             }
 467             return result;
 468         } catch (IOException ex) {
 469             throw rethrowSilently(RuntimeException.class, ex);
 470         }
 471     }
 472 
 473     /**
 474      * A special dump level that indicates the dumping machinery is enabled but no dumps will be
 475      * produced except through other options.
 476      */
 477     public static final int ENABLED_LEVEL = 0;
 478 
 479     /**
 480      * Basic debug level.
 481      *
 482      * For HIR dumping, only ~5 graphs per method: after parsing, after inlining, after high tier,
 483      * after mid tier, after low tier.
 484      *
 485      * LIR dumping: After LIR generation, after each pre-allocation, allocation and post allocation
 486      * stage, and after code installation.
 487      */
 488     public static final int BASIC_LEVEL = 1;
 489 
 490     /**
 491      * Informational debug level.
 492      *
 493      * HIR dumping: One graph after each applied top-level phase.
 494      *
 495      * LIR dumping: After each applied phase.
 496      */
 497     public static final int INFO_LEVEL = 2;
 498 
 499     /**
 500      * Verbose debug level.
 501      *
 502      * HIR dumping: One graph after each phase (including sub phases).
 503      *
 504      * LIR dumping: After each phase including sub phases.
 505      */
 506     public static final int VERBOSE_LEVEL = 3;
 507 
 508     /**
 509      * Detailed debug level.
 510      *
 511      * HIR dumping: Graphs within phases where interesting for a phase, max ~5 per phase.
 512      *
 513      * LIR dumping: Dump CFG within phases where interesting.
 514      */
 515     public static final int DETAILED_LEVEL = 4;
 516 
 517     /**
 518      * Very detailed debug level.
 519      *
 520      * HIR dumping: Graphs per node granularity graph change (before/after change).
 521      *
 522      * LIR dumping: Intermediate CFGs of phases where interesting.
 523      */
 524     public static final int VERY_DETAILED_LEVEL = 5;
 525 
 526     public boolean isDumpEnabled(int dumpLevel) {
 527         return currentScope != null &amp;&amp; currentScope.isDumpEnabled(dumpLevel);
 528     }
 529 
 530     /**
 531      * Determines if verification is enabled for any {@link JavaMethod} in the current scope.
 532      *
 533      * @see DebugContext#verify(Object, String)
 534      */
 535     public boolean isVerifyEnabledForMethod() {
 536         if (currentScope == null) {
 537             return false;
 538         }
 539         if (currentConfig == null) {
 540             return false;
 541         }
 542         return currentConfig.isVerifyEnabledForMethod(currentScope);
 543     }
 544 
 545     /**
 546      * Determines if verification is enabled in the current scope.
 547      *
 548      * @see DebugContext#verify(Object, String)
 549      */
 550     public boolean isVerifyEnabled() {
 551         return currentScope != null &amp;&amp; currentScope.isVerifyEnabled();
 552     }
 553 
 554     public boolean isCountEnabled() {
 555         return currentScope != null &amp;&amp; currentScope.isCountEnabled();
 556     }
 557 
 558     public boolean isTimeEnabled() {
 559         return currentScope != null &amp;&amp; currentScope.isTimeEnabled();
 560     }
 561 
 562     public boolean isMemUseTrackingEnabled() {
 563         return currentScope != null &amp;&amp; currentScope.isMemUseTrackingEnabled();
 564     }
 565 
 566     public boolean isDumpEnabledForMethod() {
 567         if (currentConfig == null) {
 568             return false;
 569         }
 570         return currentConfig.isDumpEnabledForMethod(currentScope);
 571     }
 572 
 573     public boolean isLogEnabledForMethod() {
 574         if (currentScope == null) {
 575             return false;
 576         }
 577         if (currentConfig == null) {
 578             return false;
 579         }
 580         return currentConfig.isLogEnabledForMethod(currentScope);
 581     }
 582 
 583     public boolean isLogEnabled() {
 584         return currentScope != null &amp;&amp; isLogEnabled(BASIC_LEVEL);
 585     }
 586 
 587     public boolean isLogEnabled(int logLevel) {
 588         return currentScope != null &amp;&amp; currentScope.isLogEnabled(logLevel);
 589     }
 590 
 591     /**
 592      * Gets a string composed of the names in the current nesting of debug
 593      * {@linkplain #scope(Object) scopes} separated by {@code &#39;.&#39;}.
 594      */
 595     public String getCurrentScopeName() {
 596         if (currentScope != null) {
 597             return currentScope.getQualifiedName();
 598         } else {
 599             return &quot;&quot;;
 600         }
 601     }
 602 
 603     /**
 604      * Creates and enters a new debug scope which will be a child of the current debug scope.
 605      * &lt;p&gt;
 606      * It is recommended to use the try-with-resource statement for managing entering and leaving
 607      * debug scopes. For example:
 608      *
 609      * &lt;pre&gt;
 610      * try (Scope s = Debug.scope(&amp;quot;InliningGraph&amp;quot;, inlineeGraph)) {
 611      *     ...
 612      * } catch (Throwable e) {
 613      *     throw Debug.handle(e);
 614      * }
 615      * &lt;/pre&gt;
 616      *
 617      * The {@code name} argument is subject to the following type based conversion before having
 618      * {@link Object#toString()} called on it:
 619      *
 620      * &lt;pre&gt;
 621      *     Type          | Conversion
 622      * ------------------+-----------------
 623      *  java.lang.Class  | arg.getSimpleName()
 624      *                   |
 625      * &lt;/pre&gt;
 626      *
 627      * @param name the name of the new scope
 628      * @param contextObjects an array of object to be appended to the {@linkplain #context()
 629      *            current} debug context
 630      * @throws Throwable used to enforce a catch block.
 631      * @return the scope entered by this method which will be exited when its {@link Scope#close()}
 632      *         method is called
 633      */
 634     public DebugContext.Scope scope(Object name, Object[] contextObjects) throws Throwable {
 635         if (currentScope != null) {
 636             return enterScope(convertFormatArg(name).toString(), null, contextObjects);
 637         } else {
 638             return null;
 639         }
 640     }
 641 
 642     /**
 643      * Similar to {@link #scope(Object, Object[])} but without context objects. Therefore the catch
 644      * block can be omitted.
 645      *
 646      * @see #scope(Object, Object[])
 647      */
 648     public DebugContext.Scope scope(Object name) {
 649         if (currentScope != null) {
 650             return enterScope(convertFormatArg(name).toString(), null);
 651         } else {
 652             return null;
 653         }
 654     }
 655 
 656     private final Invariants invariants = Assertions.assertionsEnabled() ? new Invariants() : null;
 657 
 658     static StackTraceElement[] getStackTrace(Thread thread) {
 659         return thread.getStackTrace();
 660     }
 661 
 662     /**
 663      * Utility for enforcing {@link DebugContext} invariants via assertions.
 664      */
 665     static class Invariants {
 666         private final Thread thread;
 667         private final StackTraceElement[] origin;
 668 
 669         Invariants() {
 670             thread = Thread.currentThread();
 671             origin = getStackTrace(thread);
 672         }
 673 
 674         boolean checkNoConcurrentAccess() {
 675             Thread currentThread = Thread.currentThread();
 676             if (currentThread != thread) {
 677                 Formatter buf = new Formatter();
 678                 buf.format(&quot;Thread local %s object was created on thread %s but is being accessed by thread %s. The most likely cause is &quot; +
 679                                 &quot;that the object is being retrieved from a non-thread-local cache.&quot;,
 680                                 DebugContext.class.getName(), thread, currentThread);
 681                 int debugContextConstructors = 0;
 682                 boolean addedHeader = false;
 683                 for (StackTraceElement e : origin) {
 684                     if (e.getMethodName().equals(&quot;&lt;init&gt;&quot;) &amp;&amp; e.getClassName().equals(DebugContext.class.getName())) {
 685                         debugContextConstructors++;
 686                     } else if (debugContextConstructors != 0) {
 687                         if (!addedHeader) {
 688                             addedHeader = true;
 689                             buf.format(&quot; The object was instantiated here:&quot;);
 690                         }
 691                         // Distinguish from assertion stack trace by using double indent and
 692                         // &quot;in&quot; instead of &quot;at&quot; prefix.
 693                         buf.format(&quot;%n\t\tin %s&quot;, e);
 694                     }
 695                 }
 696                 if (addedHeader) {
 697                     buf.format(&quot;%n&quot;);
 698                 }
 699 
 700                 throw new AssertionError(buf.toString());
 701             }
 702             return true;
 703         }
 704     }
 705 
 706     boolean checkNoConcurrentAccess() {
 707         assert invariants == null || invariants.checkNoConcurrentAccess();
 708         return true;
 709     }
 710 
 711     private DebugContext.Scope enterScope(CharSequence name, DebugConfig sandboxConfig, Object... newContextObjects) {
 712         assert checkNoConcurrentAccess();
 713         currentScope = currentScope.scope(name, sandboxConfig, newContextObjects);
 714         return currentScope;
 715     }
 716 
 717     /**
 718      * @see #scope(Object, Object[])
 719      * @param context an object to be appended to the {@linkplain #context() current} debug context
 720      */
 721     public DebugContext.Scope scope(Object name, Object context) throws Throwable {
 722         if (currentScope != null) {
 723             return enterScope(convertFormatArg(name).toString(), null, context);
 724         } else {
 725             return null;
 726         }
 727     }
 728 
 729     /**
 730      * @see #scope(Object, Object[])
 731      * @param context1 first object to be appended to the {@linkplain #context() current} debug
 732      *            context
 733      * @param context2 second object to be appended to the {@linkplain #context() current} debug
 734      *            context
 735      */
 736     public DebugContext.Scope scope(Object name, Object context1, Object context2) throws Throwable {
 737         if (currentScope != null) {
 738             return enterScope(convertFormatArg(name).toString(), null, context1, context2);
 739         } else {
 740             return null;
 741         }
 742     }
 743 
 744     /**
 745      * @see #scope(Object, Object[])
 746      * @param context1 first object to be appended to the {@linkplain #context() current} debug
 747      *            context
 748      * @param context2 second object to be appended to the {@linkplain #context() current} debug
 749      *            context
 750      * @param context3 third object to be appended to the {@linkplain #context() current} debug
 751      *            context
 752      */
 753     public DebugContext.Scope scope(Object name, Object context1, Object context2, Object context3) throws Throwable {
 754         if (currentScope != null) {
 755             return enterScope(convertFormatArg(name).toString(), null, context1, context2, context3);
 756         } else {
 757             return null;
 758         }
 759     }
 760 
 761     /**
 762      * Create an unnamed scope that appends some context to the current scope.
 763      *
 764      * @param context an object to be appended to the {@linkplain #context() current} debug context
 765      */
 766     public DebugContext.Scope withContext(Object context) throws Throwable {
 767         if (currentScope != null) {
 768             return enterScope(&quot;&quot;, null, context);
 769         } else {
 770             return null;
 771         }
 772     }
 773 
 774     /**
 775      * Creates and enters a new debug scope which will be disjoint from the current debug scope.
 776      * &lt;p&gt;
 777      * It is recommended to use the try-with-resource statement for managing entering and leaving
 778      * debug scopes. For example:
 779      *
 780      * &lt;pre&gt;
 781      * try (Scope s = Debug.sandbox(&amp;quot;CompilingStub&amp;quot;, null, stubGraph)) {
 782      *     ...
 783      * } catch (Throwable e) {
 784      *     throw Debug.handle(e);
 785      * }
 786      * &lt;/pre&gt;
 787      *
 788      * @param name the name of the new scope
 789      * @param config the debug configuration to use for the new scope or {@code null} to disable the
 790      *            scoping mechanism within the sandbox scope
 791      * @param context objects to be appended to the {@linkplain #context() current} debug context
 792      * @return the scope entered by this method which will be exited when its {@link Scope#close()}
 793      *         method is called
 794      */
 795     public DebugContext.Scope sandbox(CharSequence name, DebugConfig config, Object... context) throws Throwable {
 796         if (config == null) {
 797             return disable();
 798         }
 799         if (currentScope != null) {
 800             return enterScope(name, config, context);
 801         } else {
 802             return null;
 803         }
 804     }
 805 
 806     /**
 807      * Determines if scopes are enabled and this context is in a non-top-level scope.
 808      */
 809     public boolean inNestedScope() {
 810         if (immutable.scopesEnabled) {
 811             if (currentScope == null) {
 812                 // In an active DisabledScope
 813                 return true;
 814             }
 815             return !currentScope.isTopLevel();
 816         } else {
 817             return false;
 818         }
 819     }
 820 
 821     class DisabledScope implements DebugContext.Scope {
 822         final boolean savedMetricsEnabled;
 823         final ScopeImpl savedScope;
 824         final DebugConfigImpl savedConfig;
 825 
 826         DisabledScope() {
 827             this.savedMetricsEnabled = metricsEnabled;
 828             this.savedScope = currentScope;
 829             this.savedConfig = currentConfig;
 830             metricsEnabled = false;
 831             currentScope = null;
 832             currentConfig = null;
 833         }
 834 
 835         @Override
 836         public String getQualifiedName() {
 837             return &quot;&quot;;
 838         }
 839 
 840         @Override
 841         public Iterable&lt;Object&gt; getCurrentContext() {
 842             return Collections.emptyList();
 843         }
 844 
 845         @Override
 846         public void close() {
 847             metricsEnabled = savedMetricsEnabled;
 848             currentScope = savedScope;
 849             currentConfig = savedConfig;
 850             lastClosedScope = this;
 851         }
 852     }
 853 
 854     /**
 855      * Disables all metrics and scope related functionality until {@code close()} is called on the
 856      * returned object.
 857      */
 858     public DebugContext.Scope disable() {
 859         if (currentScope != null) {
 860             return new DisabledScope();
 861         } else {
 862             return null;
 863         }
 864     }
 865 
 866     public DebugContext.Scope forceLog() throws Throwable {
 867         if (currentConfig != null) {
 868             ArrayList&lt;Object&gt; context = new ArrayList&lt;&gt;();
 869             for (Object obj : context()) {
 870                 context.add(obj);
 871             }
 872             DebugConfigImpl config = new DebugConfigImpl(new OptionValues(currentConfig.getOptions(), DebugOptions.Log, &quot;:1000&quot;));
 873             return sandbox(&quot;forceLog&quot;, config, context.toArray());
 874         }
 875         return null;
 876     }
 877 
 878     /**
 879      * Opens a scope in which exception
 880      * {@linkplain DebugConfig#interceptException(DebugContext, Throwable) interception} is
 881      * disabled. The current state of interception is restored when {@link DebugCloseable#close()}
 882      * is called on the returned object.
 883      *
 884      * This is particularly useful to suppress extraneous output in JUnit tests that are expected to
 885      * throw an exception.
 886      */
 887     public DebugCloseable disableIntercept() {
 888         if (currentScope != null) {
 889             return currentScope.disableIntercept();
 890         }
 891         return null;
 892     }
 893 
 894     /**
 895      * Handles an exception in the context of the debug scope just exited. The just exited scope
 896      * must have the current scope as its parent which will be the case if the try-with-resource
 897      * pattern recommended by {@link #scope(Object)} and
 898      * {@link #sandbox(CharSequence, DebugConfig, Object...)} is used
 899      *
 900      * @see #scope(Object, Object[])
 901      * @see #sandbox(CharSequence, DebugConfig, Object...)
 902      */
 903     public RuntimeException handle(Throwable exception) {
 904         if (currentScope != null) {
 905             return currentScope.handle(exception);
 906         } else {
 907             if (exception instanceof Error) {
 908                 throw (Error) exception;
 909             }
 910             if (exception instanceof RuntimeException) {
 911                 throw (RuntimeException) exception;
 912             }
 913             throw new RuntimeException(exception);
 914         }
 915     }
 916 
 917     public void log(String msg) {
 918         log(BASIC_LEVEL, msg);
 919     }
 920 
 921     /**
 922      * Prints a message to the current debug scope&#39;s logging stream if logging is enabled.
 923      *
 924      * @param msg the message to log
 925      */
 926     public void log(int logLevel, String msg) {
 927         if (currentScope != null) {
 928             currentScope.log(logLevel, msg);
 929         }
 930     }
 931 
 932     public void log(String format, Object arg) {
 933         log(BASIC_LEVEL, format, arg);
 934     }
 935 
 936     /**
 937      * Prints a message to the current debug scope&#39;s logging stream if logging is enabled.
 938      *
 939      * @param format a format string
 940      * @param arg the argument referenced by the format specifiers in {@code format}
 941      */
 942     public void log(int logLevel, String format, Object arg) {
 943         if (currentScope != null) {
 944             currentScope.log(logLevel, format, arg);
 945         }
 946     }
 947 
 948     public void log(String format, int arg) {
 949         log(BASIC_LEVEL, format, arg);
 950     }
 951 
 952     /**
 953      * Prints a message to the current debug scope&#39;s logging stream if logging is enabled.
 954      *
 955      * @param format a format string
 956      * @param arg the argument referenced by the format specifiers in {@code format}
 957      */
 958     public void log(int logLevel, String format, int arg) {
 959         if (currentScope != null) {
 960             currentScope.log(logLevel, format, arg);
 961         }
 962     }
 963 
 964     public void log(String format, Object arg1, Object arg2) {
 965         log(BASIC_LEVEL, format, arg1, arg2);
 966     }
 967 
 968     /**
 969      * @see #log(int, String, Object)
 970      */
 971     public void log(int logLevel, String format, Object arg1, Object arg2) {
 972         if (currentScope != null) {
 973             currentScope.log(logLevel, format, arg1, arg2);
 974         }
 975     }
 976 
 977     public void log(String format, int arg1, Object arg2) {
 978         log(BASIC_LEVEL, format, arg1, arg2);
 979     }
 980 
 981     /**
 982      * @see #log(int, String, Object)
 983      */
 984     public void log(int logLevel, String format, int arg1, Object arg2) {
 985         if (currentScope != null) {
 986             currentScope.log(logLevel, format, arg1, arg2);
 987         }
 988     }
 989 
 990     public void log(String format, Object arg1, int arg2) {
 991         log(BASIC_LEVEL, format, arg1, arg2);
 992     }
 993 
 994     /**
 995      * @see #log(int, String, Object)
 996      */
 997     public void log(int logLevel, String format, Object arg1, int arg2) {
 998         if (currentScope != null) {
 999             currentScope.log(logLevel, format, arg1, arg2);
1000         }
1001     }
1002 
1003     public void log(String format, int arg1, int arg2) {
1004         log(BASIC_LEVEL, format, arg1, arg2);
1005     }
1006 
1007     /**
1008      * @see #log(int, String, Object)
1009      */
1010     public void log(int logLevel, String format, int arg1, int arg2) {
1011         if (currentScope != null) {
1012             currentScope.log(logLevel, format, arg1, arg2);
1013         }
1014     }
1015 
1016     public void log(String format, Object arg1, Object arg2, Object arg3) {
1017         log(BASIC_LEVEL, format, arg1, arg2, arg3);
1018     }
1019 
1020     /**
1021      * @see #log(int, String, Object)
1022      */
1023     public void log(int logLevel, String format, Object arg1, Object arg2, Object arg3) {
1024         if (currentScope != null) {
1025             currentScope.log(logLevel, format, arg1, arg2, arg3);
1026         }
1027     }
1028 
1029     public void log(String format, int arg1, int arg2, int arg3) {
1030         log(BASIC_LEVEL, format, arg1, arg2, arg3);
1031     }
1032 
1033     /**
1034      * @see #log(int, String, Object)
1035      */
1036     public void log(int logLevel, String format, int arg1, int arg2, int arg3) {
1037         if (currentScope != null) {
1038             currentScope.log(logLevel, format, arg1, arg2, arg3);
1039         }
1040     }
1041 
1042     public void log(String format, Object arg1, Object arg2, Object arg3, Object arg4) {
1043         log(BASIC_LEVEL, format, arg1, arg2, arg3, arg4);
1044     }
1045 
1046     /**
1047      * @see #log(int, String, Object)
1048      */
1049     public void log(int logLevel, String format, Object arg1, Object arg2, Object arg3, Object arg4) {
1050         if (currentScope != null) {
1051             currentScope.log(logLevel, format, arg1, arg2, arg3, arg4);
1052         }
1053     }
1054 
1055     public void log(String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5) {
1056         log(BASIC_LEVEL, format, arg1, arg2, arg3, arg4, arg5);
1057     }
1058 
1059     /**
1060      * @see #log(int, String, Object)
1061      */
1062     public void log(int logLevel, String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5) {
1063         if (currentScope != null) {
1064             currentScope.log(logLevel, format, arg1, arg2, arg3, arg4, arg5);
1065         }
1066     }
1067 
1068     public void log(String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6) {
1069         log(BASIC_LEVEL, format, arg1, arg2, arg3, arg4, arg5, arg6);
1070     }
1071 
1072     /**
1073      * @see #log(int, String, Object)
1074      */
1075     public void log(int logLevel, String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6) {
1076         if (currentScope != null) {
1077             currentScope.log(logLevel, format, arg1, arg2, arg3, arg4, arg5, arg6);
1078         }
1079     }
1080 
1081     public void log(String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7) {
1082         log(BASIC_LEVEL, format, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
1083     }
1084 
1085     public void log(String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7, Object arg8) {
1086         log(BASIC_LEVEL, format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
1087     }
1088 
1089     /**
1090      * @see #log(int, String, Object)
1091      */
1092     public void log(int logLevel, String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7) {
1093         if (currentScope != null) {
1094             currentScope.log(logLevel, format, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
1095         }
1096     }
1097 
1098     public void log(int logLevel, String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7, Object arg8) {
1099         if (currentScope != null) {
1100             currentScope.log(logLevel, format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
1101         }
1102     }
1103 
1104     public void log(String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7, Object arg8, Object arg9) {
1105         log(BASIC_LEVEL, format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
1106     }
1107 
1108     public void log(int logLevel, String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7, Object arg8, Object arg9) {
1109         if (currentScope != null) {
1110             currentScope.log(logLevel, format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
1111         }
1112     }
1113 
1114     public void log(String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7, Object arg8, Object arg9, Object arg10) {
1115         log(BASIC_LEVEL, format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
1116     }
1117 
1118     public void log(int logLevel, String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6, Object arg7, Object arg8, Object arg9, Object arg10) {
1119         if (currentScope != null) {
1120             currentScope.log(logLevel, format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
1121         }
1122     }
1123 
1124     public void logv(String format, Object... args) {
1125         logv(BASIC_LEVEL, format, args);
1126     }
1127 
1128     /**
1129      * Prints a message to the current debug scope&#39;s logging stream. This method must only be called
1130      * if debugging scopes are {@linkplain DebugContext#areScopesEnabled() enabled} as it incurs
1131      * allocation at the call site. If possible, call one of the other {@code log()} methods in this
1132      * class that take a fixed number of parameters.
1133      *
1134      * @param format a format string
1135      * @param args the arguments referenced by the format specifiers in {@code format}
1136      */
1137     public void logv(int logLevel, String format, Object... args) {
1138         if (currentScope == null) {
1139             throw new InternalError(&quot;Use of Debug.logv() must be guarded by a test of Debug.isEnabled()&quot;);
1140         }
1141         currentScope.log(logLevel, format, args);
1142     }
1143 
1144     /**
1145      * This override exists to catch cases when {@link #log(String, Object)} is called with one
1146      * argument bound to a varargs method parameter. It will bind to this method instead of the
1147      * single arg variant and produce a deprecation warning instead of silently wrapping the
1148      * Object[] inside of another Object[].
1149      */
1150     @Deprecated
1151     public void log(String format, Object[] args) {
1152         assert false : &quot;shouldn&#39;t use this&quot;;
1153         log(BASIC_LEVEL, format, args);
1154     }
1155 
1156     /**
1157      * This override exists to catch cases when {@link #log(int, String, Object)} is called with one
1158      * argument bound to a varargs method parameter. It will bind to this method instead of the
1159      * single arg variant and produce a deprecation warning instead of silently wrapping the
1160      * Object[] inside of another Object[].
1161      */
1162     @Deprecated
1163     public void log(int logLevel, String format, Object[] args) {
1164         assert false : &quot;shouldn&#39;t use this&quot;;
1165         logv(logLevel, format, args);
1166     }
1167 
1168     /**
1169      * Forces an unconditional dump. This method exists mainly for debugging. It can also be used to
1170      * force a graph dump from IDEs that support invoking a Java method while at a breakpoint.
1171      */
1172     public void forceDump(Object object, String format, Object... args) {
1173         DebugConfig config = currentConfig;
1174         Collection&lt;DebugDumpHandler&gt; dumpHandlers;
1175         boolean closeAfterDump;
1176         if (config != null) {
1177             dumpHandlers = config.dumpHandlers();
1178             closeAfterDump = false;
1179         } else {
1180             OptionValues options = getOptions();
1181             dumpHandlers = new ArrayList&lt;&gt;();
1182             for (DebugHandlersFactory factory : DebugHandlersFactory.LOADER) {
1183                 for (DebugHandler handler : factory.createHandlers(options)) {
1184                     if (handler instanceof DebugDumpHandler) {
1185                         dumpHandlers.add((DebugDumpHandler) handler);
1186                     }
1187                 }
1188             }
1189             closeAfterDump = true;
1190         }
1191         for (DebugDumpHandler dumpHandler : dumpHandlers) {
1192             dumpHandler.dump(this, object, format, args);
1193             if (closeAfterDump) {
1194                 dumpHandler.close();
1195             }
1196         }
1197     }
1198 
1199     public void dump(int dumpLevel, Object object, String msg) {
1200         if (currentScope != null &amp;&amp; currentScope.isDumpEnabled(dumpLevel)) {
1201             currentScope.dump(dumpLevel, object, msg);
1202         }
1203     }
1204 
1205     public void dump(int dumpLevel, Object object, String format, Object arg) {
1206         if (currentScope != null &amp;&amp; currentScope.isDumpEnabled(dumpLevel)) {
1207             currentScope.dump(dumpLevel, object, format, arg);
1208         }
1209     }
1210 
1211     public void dump(int dumpLevel, Object object, String format, Object arg1, Object arg2) {
1212         if (currentScope != null &amp;&amp; currentScope.isDumpEnabled(dumpLevel)) {
1213             currentScope.dump(dumpLevel, object, format, arg1, arg2);
1214         }
1215     }
1216 
1217     public void dump(int dumpLevel, Object object, String format, Object arg1, Object arg2, Object arg3) {
1218         if (currentScope != null &amp;&amp; currentScope.isDumpEnabled(dumpLevel)) {
1219             currentScope.dump(dumpLevel, object, format, arg1, arg2, arg3);
1220         }
1221     }
1222 
1223     /**
1224      * This override exists to catch cases when {@link #dump(int, Object, String, Object)} is called
1225      * with one argument bound to a varargs method parameter. It will bind to this method instead of
1226      * the single arg variant and produce a deprecation warning instead of silently wrapping the
1227      * Object[] inside of another Object[].
1228      */
1229     @Deprecated
1230     public void dump(int dumpLevel, Object object, String format, Object[] args) {
1231         assert false : &quot;shouldn&#39;t use this&quot;;
1232         if (currentScope != null &amp;&amp; currentScope.isDumpEnabled(dumpLevel)) {
1233             currentScope.dump(dumpLevel, object, format, args);
1234         }
1235     }
1236 
1237     /**
1238      * Calls all {@link DebugVerifyHandler}s in the current {@linkplain #getConfig() config} to
1239      * perform verification on a given object.
1240      *
1241      * @param object object to verify
1242      * @param message description of verification context
1243      *
1244      * @see DebugVerifyHandler#verify
1245      */
1246     public void verify(Object object, String message) {
1247         if (currentScope != null &amp;&amp; currentScope.isVerifyEnabled()) {
1248             currentScope.verify(object, message);
1249         }
1250     }
1251 
1252     /**
1253      * Calls all {@link DebugVerifyHandler}s in the current {@linkplain #getConfig() config} to
1254      * perform verification on a given object.
1255      *
1256      * @param object object to verify
1257      * @param format a format string for the description of the verification context
1258      * @param arg the argument referenced by the format specifiers in {@code format}
1259      *
1260      * @see DebugVerifyHandler#verify
1261      */
1262     public void verify(Object object, String format, Object arg) {
1263         if (currentScope != null &amp;&amp; currentScope.isVerifyEnabled()) {
1264             currentScope.verify(object, format, arg);
1265         }
1266     }
1267 
1268     /**
1269      * This override exists to catch cases when {@link #verify(Object, String, Object)} is called
1270      * with one argument bound to a varargs method parameter. It will bind to this method instead of
1271      * the single arg variant and produce a deprecation warning instead of silently wrapping the
1272      * Object[] inside of another Object[].
1273      */
1274     @Deprecated
1275     public void verify(Object object, String format, Object[] args) {
1276         assert false : &quot;shouldn&#39;t use this&quot;;
1277         if (currentScope != null &amp;&amp; currentScope.isVerifyEnabled()) {
1278             currentScope.verify(object, format, args);
1279         }
1280     }
1281 
1282     /**
1283      * Opens a new indentation level (by adding some spaces) based on the current indentation level.
1284      * This should be used in a {@linkplain Indent try-with-resources} pattern.
1285      *
1286      * @return an object that reverts to the current indentation level when
1287      *         {@linkplain Indent#close() closed} or null if debugging is disabled
1288      * @see #logAndIndent(int, String)
1289      * @see #logAndIndent(int, String, Object)
1290      */
1291     public Indent indent() {
1292         if (currentScope != null) {
1293             return currentScope.pushIndentLogger();
1294         }
1295         return null;
1296     }
1297 
1298     public Indent logAndIndent(String msg) {
1299         return logAndIndent(BASIC_LEVEL, msg);
1300     }
1301 
1302     /**
1303      * A convenience function which combines {@link #log(String)} and {@link #indent()}.
1304      *
1305      * @param msg the message to log
1306      * @return an object that reverts to the current indentation level when
1307      *         {@linkplain Indent#close() closed} or null if debugging is disabled
1308      */
1309     public Indent logAndIndent(int logLevel, String msg) {
1310         if (currentScope != null &amp;&amp; isLogEnabled(logLevel)) {
1311             return logvAndIndentInternal(logLevel, msg);
1312         }
1313         return null;
1314     }
1315 
1316     public Indent logAndIndent(String format, Object arg) {
1317         return logAndIndent(BASIC_LEVEL, format, arg);
1318     }
1319 
1320     /**
1321      * A convenience function which combines {@link #log(String, Object)} and {@link #indent()}.
1322      *
1323      * @param format a format string
1324      * @param arg the argument referenced by the format specifiers in {@code format}
1325      * @return an object that reverts to the current indentation level when
1326      *         {@linkplain Indent#close() closed} or null if debugging is disabled
1327      */
1328     public Indent logAndIndent(int logLevel, String format, Object arg) {
1329         if (currentScope != null &amp;&amp; isLogEnabled(logLevel)) {
1330             return logvAndIndentInternal(logLevel, format, arg);
1331         }
1332         return null;
1333     }
1334 
1335     public Indent logAndIndent(String format, int arg) {
1336         return logAndIndent(BASIC_LEVEL, format, arg);
1337     }
1338 
1339     /**
1340      * A convenience function which combines {@link #log(String, Object)} and {@link #indent()}.
1341      *
1342      * @param format a format string
1343      * @param arg the argument referenced by the format specifiers in {@code format}
1344      * @return an object that reverts to the current indentation level when
1345      *         {@linkplain Indent#close() closed} or null if debugging is disabled
1346      */
1347     public Indent logAndIndent(int logLevel, String format, int arg) {
1348         if (currentScope != null &amp;&amp; isLogEnabled(logLevel)) {
1349             return logvAndIndentInternal(logLevel, format, arg);
1350         }
1351         return null;
1352     }
1353 
1354     public Indent logAndIndent(String format, int arg1, Object arg2) {
1355         return logAndIndent(BASIC_LEVEL, format, arg1, arg2);
1356     }
1357 
1358     /**
1359      * @see #logAndIndent(int, String, Object)
1360      */
1361     public Indent logAndIndent(int logLevel, String format, int arg1, Object arg2) {
1362         if (currentScope != null &amp;&amp; isLogEnabled(logLevel)) {
1363             return logvAndIndentInternal(logLevel, format, arg1, arg2);
1364         }
1365         return null;
1366     }
1367 
1368     public Indent logAndIndent(String format, Object arg1, int arg2) {
1369         return logAndIndent(BASIC_LEVEL, format, arg1, arg2);
1370     }
1371 
1372     /**
1373      * @see #logAndIndent(int, String, Object)
1374      */
1375     public Indent logAndIndent(int logLevel, String format, Object arg1, int arg2) {
1376         if (currentScope != null &amp;&amp; isLogEnabled(logLevel)) {
1377             return logvAndIndentInternal(logLevel, format, arg1, arg2);
1378         }
1379         return null;
1380     }
1381 
1382     public Indent logAndIndent(String format, int arg1, int arg2) {
1383         return logAndIndent(BASIC_LEVEL, format, arg1, arg2);
1384     }
1385 
1386     /**
1387      * @see #logAndIndent(int, String, Object)
1388      */
1389     public Indent logAndIndent(int logLevel, String format, int arg1, int arg2) {
1390         if (currentScope != null &amp;&amp; isLogEnabled(logLevel)) {
1391             return logvAndIndentInternal(logLevel, format, arg1, arg2);
1392         }
1393         return null;
1394     }
1395 
1396     public Indent logAndIndent(String format, Object arg1, Object arg2) {
1397         return logAndIndent(BASIC_LEVEL, format, arg1, arg2);
1398     }
1399 
1400     /**
1401      * @see #logAndIndent(int, String, Object)
1402      */
1403     public Indent logAndIndent(int logLevel, String format, Object arg1, Object arg2) {
1404         if (currentScope != null &amp;&amp; isLogEnabled(logLevel)) {
1405             return logvAndIndentInternal(logLevel, format, arg1, arg2);
1406         }
1407         return null;
1408     }
1409 
1410     public Indent logAndIndent(String format, Object arg1, Object arg2, Object arg3) {
1411         return logAndIndent(BASIC_LEVEL, format, arg1, arg2, arg3);
1412     }
1413 
1414     /**
1415      * @see #logAndIndent(int, String, Object)
1416      */
1417     public Indent logAndIndent(int logLevel, String format, Object arg1, Object arg2, Object arg3) {
1418         if (currentScope != null &amp;&amp; isLogEnabled(logLevel)) {
1419             return logvAndIndentInternal(logLevel, format, arg1, arg2, arg3);
1420         }
1421         return null;
1422     }
1423 
1424     public Indent logAndIndent(String format, int arg1, int arg2, int arg3) {
1425         return logAndIndent(BASIC_LEVEL, format, arg1, arg2, arg3);
1426     }
1427 
1428     /**
1429      * @see #logAndIndent(int, String, Object)
1430      */
1431     public Indent logAndIndent(int logLevel, String format, int arg1, int arg2, int arg3) {
1432         if (currentScope != null &amp;&amp; isLogEnabled(logLevel)) {
1433             return logvAndIndentInternal(logLevel, format, arg1, arg2, arg3);
1434         }
1435         return null;
1436     }
1437 
1438     public Indent logAndIndent(String format, Object arg1, int arg2, int arg3) {
1439         return logAndIndent(BASIC_LEVEL, format, arg1, arg2, arg3);
1440     }
1441 
1442     /**
1443      * @see #logAndIndent(int, String, Object)
1444      */
1445     public Indent logAndIndent(int logLevel, String format, Object arg1, int arg2, int arg3) {
1446         if (currentScope != null &amp;&amp; isLogEnabled(logLevel)) {
1447             return logvAndIndentInternal(logLevel, format, arg1, arg2, arg3);
1448         }
1449         return null;
1450     }
1451 
1452     public Indent logAndIndent(String format, Object arg1, Object arg2, Object arg3, Object arg4) {
1453         return logAndIndent(BASIC_LEVEL, format, arg1, arg2, arg3, arg4);
1454     }
1455 
1456     /**
1457      * @see #logAndIndent(int, String, Object)
1458      */
1459     public Indent logAndIndent(int logLevel, String format, Object arg1, Object arg2, Object arg3, Object arg4) {
1460         if (currentScope != null &amp;&amp; isLogEnabled(logLevel)) {
1461             return logvAndIndentInternal(logLevel, format, arg1, arg2, arg3, arg4);
1462         }
1463         return null;
1464     }
1465 
1466     public Indent logAndIndent(String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5) {
1467         return logAndIndent(BASIC_LEVEL, format, arg1, arg2, arg3, arg4, arg5);
1468     }
1469 
1470     /**
1471      * @see #logAndIndent(int, String, Object)
1472      */
1473     public Indent logAndIndent(int logLevel, String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5) {
1474         if (currentScope != null &amp;&amp; isLogEnabled(logLevel)) {
1475             return logvAndIndentInternal(logLevel, format, arg1, arg2, arg3, arg4, arg5);
1476         }
1477         return null;
1478     }
1479 
1480     public Indent logAndIndent(String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6) {
1481         return logAndIndent(BASIC_LEVEL, format, arg1, arg2, arg3, arg4, arg5, arg6);
1482     }
1483 
1484     /**
1485      * @see #logAndIndent(int, String, Object)
1486      */
1487     public Indent logAndIndent(int logLevel, String format, Object arg1, Object arg2, Object arg3, Object arg4, Object arg5, Object arg6) {
1488         if (currentScope != null &amp;&amp; isLogEnabled(logLevel)) {
1489             return logvAndIndentInternal(logLevel, format, arg1, arg2, arg3, arg4, arg5, arg6);
1490         }
1491         return null;
1492     }
1493 
1494     /**
1495      * A convenience function which combines {@link #logv(int, String, Object...)} and
1496      * {@link #indent()}.
1497      *
1498      * @param format a format string
1499      * @param args the arguments referenced by the format specifiers in {@code format}
1500      * @return an object that reverts to the current indentation level when
1501      *         {@linkplain Indent#close() closed} or null if debugging is disabled
1502      */
1503     public Indent logvAndIndent(int logLevel, String format, Object... args) {
1504         if (currentScope != null) {
1505             if (isLogEnabled(logLevel)) {
1506                 return logvAndIndentInternal(logLevel, format, args);
1507             }
1508             return null;
1509         }
1510         throw new InternalError(&quot;Use of Debug.logvAndIndent() must be guarded by a test of Debug.isEnabled()&quot;);
1511     }
1512 
1513     private Indent logvAndIndentInternal(int logLevel, String format, Object... args) {
1514         assert currentScope != null &amp;&amp; isLogEnabled(logLevel) : &quot;must have checked Debug.isLogEnabled()&quot;;
1515         currentScope.log(logLevel, format, args);
1516         return currentScope.pushIndentLogger();
1517     }
1518 
1519     /**
1520      * This override exists to catch cases when {@link #logAndIndent(String, Object)} is called with
1521      * one argument bound to a varargs method parameter. It will bind to this method instead of the
1522      * single arg variant and produce a deprecation warning instead of silently wrapping the
1523      * Object[] inside of another Object[].
1524      */
1525     @Deprecated
1526     public void logAndIndent(String format, Object[] args) {
1527         assert false : &quot;shouldn&#39;t use this&quot;;
1528         logAndIndent(BASIC_LEVEL, format, args);
1529     }
1530 
1531     /**
1532      * This override exists to catch cases when {@link #logAndIndent(int, String, Object)} is called
1533      * with one argument bound to a varargs method parameter. It will bind to this method instead of
1534      * the single arg variant and produce a deprecation warning instead of silently wrapping the
1535      * Object[] inside of another Object[].
1536      */
1537     @Deprecated
1538     public void logAndIndent(int logLevel, String format, Object[] args) {
1539         assert false : &quot;shouldn&#39;t use this&quot;;
1540         logvAndIndent(logLevel, format, args);
1541     }
1542 
1543     public Iterable&lt;Object&gt; context() {
1544         if (currentScope != null) {
1545             return currentScope.getCurrentContext();
1546         } else {
1547             return Collections.emptyList();
1548         }
1549     }
1550 
1551     @SuppressWarnings(&quot;unchecked&quot;)
1552     public &lt;T&gt; List&lt;T&gt; contextSnapshot(Class&lt;T&gt; clazz) {
1553         if (currentScope != null) {
1554             List&lt;T&gt; result = new ArrayList&lt;&gt;();
1555             for (Object o : context()) {
1556                 if (clazz.isInstance(o)) {
1557                     result.add((T) o);
1558                 }
1559             }
1560             return result;
1561         } else {
1562             return Collections.emptyList();
1563         }
1564     }
1565 
1566     /**
1567      * Searches the current debug scope, bottom up, for a context object that is an instance of a
1568      * given type. The first such object found is returned.
1569      */
1570     @SuppressWarnings(&quot;unchecked&quot;)
1571     public &lt;T&gt; T contextLookup(Class&lt;T&gt; clazz) {
1572         if (currentScope != null) {
1573             for (Object o : context()) {
1574                 if (clazz.isInstance(o)) {
1575                     return ((T) o);
1576                 }
1577             }
1578         }
1579         return null;
1580     }
1581 
1582     /**
1583      * Searches the current debug scope, top down, for a context object that is an instance of a
1584      * given type. The first such object found is returned.
1585      */
1586     @SuppressWarnings(&quot;unchecked&quot;)
1587     public &lt;T&gt; T contextLookupTopdown(Class&lt;T&gt; clazz) {
1588         if (currentScope != null) {
1589             T found = null;
1590             for (Object o : context()) {
1591                 if (clazz.isInstance(o)) {
1592                     found = (T) o;
1593                 }
1594             }
1595             return found;
1596         }
1597         return null;
1598     }
1599 
1600     /**
1601      * Creates a {@linkplain MemUseTrackerKey memory use tracker}.
1602      */
1603     public static MemUseTrackerKey memUseTracker(CharSequence name) {
1604         return createMemUseTracker(&quot;%s&quot;, name, null);
1605     }
1606 
1607     /**
1608      * Creates a debug memory use tracker. Invoking this method is equivalent to:
1609      *
1610      * &lt;pre&gt;
1611      * Debug.memUseTracker(format, arg, null)
1612      * &lt;/pre&gt;
1613      *
1614      * except that the string formatting only happens if mem tracking is enabled.
1615      *
1616      * @see #counter(String, Object, Object)
1617      */
1618     public static MemUseTrackerKey memUseTracker(String format, Object arg) {
1619         return createMemUseTracker(format, arg, null);
1620     }
1621 
1622     /**
1623      * Creates a debug memory use tracker. Invoking this method is equivalent to:
1624      *
1625      * &lt;pre&gt;
1626      * Debug.memUseTracker(String.format(format, arg1, arg2))
1627      * &lt;/pre&gt;
1628      *
1629      * except that the string formatting only happens if memory use tracking is enabled. In
1630      * addition, each argument is subject to the following type based conversion before being passed
1631      * as an argument to {@link String#format(String, Object...)}:
1632      *
1633      * &lt;pre&gt;
1634      *     Type          | Conversion
1635      * ------------------+-----------------
1636      *  java.lang.Class  | arg.getSimpleName()
1637      *                   |
1638      * &lt;/pre&gt;
1639      *
1640      * @see #memUseTracker(CharSequence)
1641      */
1642     public static MemUseTrackerKey memUseTracker(String format, Object arg1, Object arg2) {
1643         return createMemUseTracker(format, arg1, arg2);
1644     }
1645 
1646     private static MemUseTrackerKey createMemUseTracker(String format, Object arg1, Object arg2) {
1647         return new MemUseTrackerKeyImpl(format, arg1, arg2);
1648     }
1649 
1650     /**
1651      * Creates a {@linkplain CounterKey counter}.
1652      */
1653     public static CounterKey counter(CharSequence name) {
1654         return createCounter(&quot;%s&quot;, name, null);
1655     }
1656 
1657     /**
1658      * Gets a tally of the metric values in this context and a given tally.
1659      *
1660      * @param tally the tally to which the metrics should be added
1661      * @return a tally of the metric values in this context and {@code tally}. This will be
1662      *         {@code tally} if this context has no metric values or {@code tally} is wide enough to
1663      *         hold all the metric values in this context otherwise it will be a new array.
1664      */
1665     public long[] addValuesTo(long[] tally) {
1666         if (metricValues == null) {
1667             return tally;
1668         }
1669         if (tally == null) {
1670             return metricValues.clone();
1671         } else if (metricValues.length &gt;= tally.length) {
1672             long[] newTally = metricValues.clone();
1673             for (int i = 0; i &lt; tally.length; i++) {
1674                 newTally[i] += tally[i];
1675             }
1676             return newTally;
1677         } else {
1678             for (int i = 0; i &lt; metricValues.length; i++) {
1679                 tally[i] += metricValues[i];
1680             }
1681             return tally;
1682         }
1683     }
1684 
1685     /**
1686      * Creates and returns a sorted map from metric names to their values in {@code values}.
1687      *
1688      * @param values values for metrics in the {@link KeyRegistry}.
1689      */
1690     public static EconomicMap&lt;MetricKey, Long&gt; convertValuesToKeyValueMap(long[] values) {
1691         List&lt;MetricKey&gt; keys = KeyRegistry.getKeys();
1692         Collections.sort(keys, MetricKey.NAME_COMPARATOR);
1693         EconomicMap&lt;MetricKey, Long&gt; res = EconomicMap.create(keys.size());
1694         for (MetricKey key : keys) {
1695             int index = ((AbstractKey) key).getIndex();
1696             if (index &gt;= values.length) {
1697                 res.put(key, 0L);
1698             } else {
1699                 res.put(key, values[index]);
1700             }
1701         }
1702         return res;
1703     }
1704 
1705     void setMetricValue(int keyIndex, long l) {
1706         ensureMetricValuesSize(keyIndex);
1707         metricValues[keyIndex] = l;
1708     }
1709 
1710     long getMetricValue(int keyIndex) {
1711         if (metricValues == null || metricValues.length &lt;= keyIndex) {
1712             return 0L;
1713         }
1714         return metricValues[keyIndex];
1715     }
1716 
1717     private void ensureMetricValuesSize(int index) {
1718         if (metricValues == null) {
1719             metricValues = new long[index + 1];
1720         }
1721         if (metricValues.length &lt;= index) {
1722             metricValues = Arrays.copyOf(metricValues, index + 1);
1723         }
1724     }
1725 
1726     public static String applyFormattingFlagsAndWidth(String s, int flags, int width) {
1727         if (flags == 0 &amp;&amp; width &lt; 0) {
1728             return s;
1729         }
1730         StringBuilder sb = new StringBuilder(s);
1731 
1732         // apply width and justification
1733         int len = sb.length();
1734         if (len &lt; width) {
1735             for (int i = 0; i &lt; width - len; i++) {
1736                 if ((flags &amp; LEFT_JUSTIFY) == LEFT_JUSTIFY) {
1737                     sb.append(&#39; &#39;);
1738                 } else {
1739                     sb.insert(0, &#39; &#39;);
1740                 }
1741             }
1742         }
1743 
1744         String res = sb.toString();
1745         if ((flags &amp; UPPERCASE) == UPPERCASE) {
1746             res = res.toUpperCase();
1747         }
1748         return res;
1749     }
1750 
1751     /**
1752      * Creates a debug counter. Invoking this method is equivalent to:
1753      *
1754      * &lt;pre&gt;
1755      * Debug.counter(format, arg, null)
1756      * &lt;/pre&gt;
1757      *
1758      * except that the string formatting only happens if count is enabled.
1759      *
1760      * @see #counter(String, Object, Object)
1761      */
1762     public static CounterKey counter(String format, Object arg) {
1763         return createCounter(format, arg, null);
1764     }
1765 
1766     /**
1767      * Creates a debug counter. Invoking this method is equivalent to:
1768      *
1769      * &lt;pre&gt;
1770      * Debug.counter(String.format(format, arg1, arg2))
1771      * &lt;/pre&gt;
1772      *
1773      * except that the string formatting only happens if count is enabled. In addition, each
1774      * argument is subject to the following type based conversion before being passed as an argument
1775      * to {@link String#format(String, Object...)}:
1776      *
1777      * &lt;pre&gt;
1778      *     Type          | Conversion
1779      * ------------------+-----------------
1780      *  java.lang.Class  | arg.getSimpleName()
1781      *                   |
1782      * &lt;/pre&gt;
1783      *
1784      * @see #counter(CharSequence)
1785      */
1786     public static CounterKey counter(String format, Object arg1, Object arg2) {
1787         return createCounter(format, arg1, arg2);
1788     }
1789 
1790     private static CounterKey createCounter(String format, Object arg1, Object arg2) {
1791         return new CounterKeyImpl(format, arg1, arg2);
1792     }
1793 
1794     public DebugConfig getConfig() {
1795         return currentConfig;
1796     }
1797 
1798     /**
1799      * Creates a {@linkplain TimerKey timer}.
1800      * &lt;p&gt;
1801      * A disabled timer has virtually no overhead.
1802      */
1803     public static TimerKey timer(CharSequence name) {
1804         return createTimer(&quot;%s&quot;, name, null);
1805     }
1806 
1807     /**
1808      * Creates a debug timer. Invoking this method is equivalent to:
1809      *
1810      * &lt;pre&gt;
1811      * Debug.timer(format, arg, null)
1812      * &lt;/pre&gt;
1813      *
1814      * except that the string formatting only happens if timing is enabled.
1815      *
1816      * @see #timer(String, Object, Object)
1817      */
1818     public static TimerKey timer(String format, Object arg) {
1819         return createTimer(format, arg, null);
1820     }
1821 
1822     /**
1823      * Creates a debug timer. Invoking this method is equivalent to:
1824      *
1825      * &lt;pre&gt;
1826      * Debug.timer(String.format(format, arg1, arg2))
1827      * &lt;/pre&gt;
1828      *
1829      * except that the string formatting only happens if timing is enabled. In addition, each
1830      * argument is subject to the following type based conversion before being passed as an argument
1831      * to {@link String#format(String, Object...)}:
1832      *
1833      * &lt;pre&gt;
1834      *     Type          | Conversion
1835      * ------------------+-----------------
1836      *  java.lang.Class  | arg.getSimpleName()
1837      *                   |
1838      * &lt;/pre&gt;
1839      *
1840      * @see #timer(CharSequence)
1841      */
1842     public static TimerKey timer(String format, Object arg1, Object arg2) {
1843         return createTimer(format, arg1, arg2);
1844     }
1845 
1846     /**
1847      * Gets the name to use for a class based on whether it appears to be an obfuscated name. The
1848      * heuristic for an obfuscated name is that it is less than 6 characters in length and consists
1849      * only of lower case letters.
1850      */
1851     private static String getBaseName(Class&lt;?&gt; c) {
1852         String simpleName = c.getSimpleName();
1853         if (simpleName.length() &lt; 6) {
1854             for (int i = 0; i &lt; simpleName.length(); i++) {
1855                 if (!Character.isLowerCase(simpleName.charAt(0))) {
1856                     return simpleName;
1857                 }
1858             }
1859             // Looks like an obfuscated simple class name so use qualified class name
1860             return c.getName();
1861         }
1862         return simpleName;
1863     }
1864 
1865     /**
1866      * There are paths where construction of formatted class names are common and the code below is
1867      * surprisingly expensive, so compute it once and cache it.
1868      */
1869     private static final ClassValue&lt;String&gt; formattedClassName = new ClassValue&lt;String&gt;() {
1870         @Override
1871         protected String computeValue(Class&lt;?&gt; c) {
1872             String baseName = getBaseName(c);
1873             if (Character.isLowerCase(baseName.charAt(0))) {
1874                 // Looks like an obfuscated simple class name so use qualified class name
1875                 baseName = c.getName();
1876             }
1877             Class&lt;?&gt; enclosingClass = c.getEnclosingClass();
1878             if (enclosingClass != null) {
1879                 String prefix = &quot;&quot;;
1880                 while (enclosingClass != null) {
1881                     prefix = getBaseName(enclosingClass) + &quot;_&quot; + prefix;
1882                     enclosingClass = enclosingClass.getEnclosingClass();
1883                 }
1884                 return prefix + baseName;
1885             } else {
1886                 return baseName;
1887             }
1888         }
1889     };
1890 
1891     public static Object convertFormatArg(Object arg) {
1892         if (arg instanceof Class) {
1893             return formattedClassName.get((Class&lt;?&gt;) arg);
1894         }
1895         return arg;
1896     }
1897 
1898     static String formatDebugName(String format, Object arg1, Object arg2) {
1899         return String.format(format, convertFormatArg(arg1), convertFormatArg(arg2));
1900     }
1901 
1902     private static TimerKey createTimer(String format, Object arg1, Object arg2) {
1903         return new TimerKeyImpl(format, arg1, arg2);
1904     }
1905 
1906     /**
1907      * Represents a debug scope entered by {@link DebugContext#scope(Object)} or
1908      * {@link DebugContext#sandbox(CharSequence, DebugConfig, Object...)}. Leaving the scope is
1909      * achieved via {@link #close()}.
1910      */
1911     public interface Scope extends AutoCloseable {
1912         /**
1913          * Gets the names of this scope and its ancestors separated by {@code &#39;.&#39;}.
1914          */
1915         String getQualifiedName();
1916 
1917         Iterable&lt;Object&gt; getCurrentContext();
1918 
1919         @Override
1920         void close();
1921     }
1922 
1923     boolean isTimerEnabled(TimerKeyImpl key) {
1924         if (!metricsEnabled) {
1925             // Pulling this common case out of `isTimerEnabledSlow`
1926             // gives C1 a better chance to inline this method.
1927             return false;
1928         }
1929         return isTimerEnabledSlow(key);
1930     }
1931 
1932     private boolean isTimerEnabledSlow(AbstractKey key) {
1933         if (currentScope != null &amp;&amp; currentScope.isTimeEnabled()) {
1934             return true;
1935         }
1936         if (immutable.listMetrics) {
1937             key.ensureInitialized();
1938         }
1939         assert checkNoConcurrentAccess();
1940         EconomicSet&lt;String&gt; unscoped = immutable.unscopedTimers;
1941         return unscoped != null &amp;&amp; (unscoped.isEmpty() || unscoped.contains(key.getName()));
1942     }
1943 
1944     /**
1945      * Determines if a given timer is enabled in the current scope.
1946      */
1947     boolean isCounterEnabled(CounterKeyImpl key) {
1948         if (!metricsEnabled) {
1949             // Pulling this common case out of `isCounterEnabledSlow`
1950             // gives C1 a better chance to inline this method.
1951             return false;
1952         }
1953         return isCounterEnabledSlow(key);
1954     }
1955 
1956     private boolean isCounterEnabledSlow(AbstractKey key) {
1957         if (currentScope != null &amp;&amp; currentScope.isCountEnabled()) {
1958             return true;
1959         }
1960         if (immutable.listMetrics) {
1961             key.ensureInitialized();
1962         }
1963         assert checkNoConcurrentAccess();
1964         EconomicSet&lt;String&gt; unscoped = immutable.unscopedCounters;
1965         return unscoped != null &amp;&amp; (unscoped.isEmpty() || unscoped.contains(key.getName()));
1966     }
1967 
1968     boolean isMemUseTrackerEnabled(MemUseTrackerKeyImpl key) {
1969         if (!metricsEnabled) {
1970             // Pulling this common case out of `isMemUseTrackerEnabledSlow`
1971             // gives C1 a better chance to inline this method.
1972             return false;
1973         }
1974         return isMemUseTrackerEnabledSlow(key);
1975     }
1976 
1977     private boolean isMemUseTrackerEnabledSlow(AbstractKey key) {
1978         if (currentScope != null &amp;&amp; currentScope.isMemUseTrackingEnabled()) {
1979             return true;
1980         }
1981         if (immutable.listMetrics) {
1982             key.ensureInitialized();
1983         }
1984         assert checkNoConcurrentAccess();
1985         EconomicSet&lt;String&gt; unscoped = immutable.unscopedMemUseTrackers;
1986         return unscoped != null &amp;&amp; (unscoped.isEmpty() || unscoped.contains(key.getName()));
1987     }
1988 
1989     public boolean areMetricsEnabled() {
1990         return metricsEnabled;
1991     }
1992 
1993     @Override
1994     public void close() {
1995         closeDumpHandlers(false);
1996         if (description != null) {
1997             printMetrics(description);
1998         }
1999         if (metricsEnabled &amp;&amp; metricValues != null &amp;&amp; globalMetrics != null) {
2000             globalMetrics.add(this);
2001         }
2002         metricValues = null;
2003         if (sharedChannel != null) {
2004             try {
2005                 sharedChannel.realClose();
2006             } catch (IOException ex) {
2007                 // ignore.
2008             }
2009         }
2010     }
2011 
2012     public void closeDumpHandlers(boolean ignoreErrors) {
2013         if (currentConfig != null) {
2014             currentConfig.closeDumpHandlers(ignoreErrors);
2015         }
2016     }
2017 
2018     /**
2019      * Records how many times a given method has been compiled.
2020      */
2021     private static EconomicMap&lt;Integer, Integer&gt; compilations;
2022 
2023     /**
2024      * Maintains maximum buffer size used by {@link #printMetrics(Description)} to minimize buffer
2025      * resizing during subsequent calls to this method.
2026      */
2027     private static int metricsBufSize = 50_000;
2028 
2029     /**
2030      * Flag that allows the first call to {@link #printMetrics(Description)} to delete the file that
2031      * will be appended to.
2032      */
2033     private static boolean metricsFileDeleteCheckPerformed;
2034 
2035     /**
2036      * Prints metric values in this object to the file (if any) specified by
2037      * {@link DebugOptions#MetricsFile}.
2038      */
2039     public void printMetrics(Description desc) {
2040         if (metricValues == null) {
2041             return;
2042         }
2043         String metricsFile = DebugOptions.MetricsFile.getValue(getOptions());
2044         if (metricsFile != null) {
2045             // Use identity to distinguish methods that have been redefined
2046             // or loaded by different class loaders.
2047             Object compilable = desc.compilable;
2048             Integer identity = System.identityHashCode(compilable);
2049             int compilationNr;
2050             synchronized (PRINT_METRICS_LOCK) {
2051                 if (!metricsFileDeleteCheckPerformed) {
2052                     metricsFileDeleteCheckPerformed = true;
2053                     File file = new File(metricsFile);
2054                     if (file.exists()) {
2055                         // This can return false in case something like /dev/stdout
2056                         // is specified. If the file is unwriteable, the file open
2057                         // below will fail.
2058                         file.delete();
2059                     }
2060                 }
2061                 if (compilations == null) {
2062                     compilationNr = 0;
2063                     compilations = EconomicMap.create();
2064                 } else {
2065                     Integer value = compilations.get(identity);
2066                     compilationNr = value == null ? 0 : value + 1;
2067                 }
2068                 compilations.put(identity, compilationNr);
2069             }
2070 
2071             // Release the lock while generating the content to reduce contention.
2072             // This means `compilationNr` fields may show up out of order in the file.
2073             ByteArrayOutputStream baos = new ByteArrayOutputStream(metricsBufSize);
2074             PrintStream out = new PrintStream(baos);
2075             if (metricsFile.endsWith(&quot;.csv&quot;) || metricsFile.endsWith(&quot;.CSV&quot;)) {
2076                 printMetricsCSV(out, compilable, identity, compilationNr, desc.identifier);
2077             } else {
2078                 printMetrics(out, compilable, identity, compilationNr, desc.identifier);
2079             }
2080 
2081             byte[] content = baos.toByteArray();
2082             Path path = Paths.get(metricsFile);
2083             synchronized (PRINT_METRICS_LOCK) {
2084                 metricsBufSize = Math.max(metricsBufSize, content.length);
2085                 try {
2086                     Files.write(path, content, StandardOpenOption.CREATE, StandardOpenOption.APPEND);
2087                 } catch (IOException e) {
2088                 }
2089             }
2090         }
2091     }
2092 
2093     /**
2094      * Lock to serialize writes to {@link DebugOptions#MetricsFile}.
2095      */
2096     private static final Object PRINT_METRICS_LOCK = new Object();
2097 
2098     /**
2099      * Appends metrics in CSV format to {@code out} for a single method compilation.
2100      *
2101      * @param identity the identity hash code of {@code compilable}
2102      * @param compilationNr where this compilation lies in the ordered sequence of all compilations
2103      *            identified by {@code identity}
2104      * @param compilationId the runtime issued identifier for the compilation
2105      */
2106     private void printMetricsCSV(PrintStream out, Object compilable, Integer identity, int compilationNr, String compilationId) {
2107         String compilableName = compilable instanceof JavaMethod ? ((JavaMethod) compilable).format(&quot;%H.%n(%p)%R&quot;) : String.valueOf(compilable);
2108         String csvFormat = CSVUtil.buildFormatString(&quot;%s&quot;, &quot;%s&quot;, &quot;%d&quot;, &quot;%s&quot;);
2109         String format = String.format(csvFormat, CSVUtil.Escape.escapeArgs(compilableName, identity, compilationNr, compilationId));
2110         char sep = CSVUtil.SEPARATOR;
2111         format += sep + &quot;%s&quot; + sep + &quot;%s&quot; + sep + &quot;%s&quot;;
2112         for (MetricKey key : KeyRegistry.getKeys()) {
2113             int index = ((AbstractKey) key).getIndex();
2114             if (index &lt; metricValues.length) {
2115                 Pair&lt;String, String&gt; valueAndUnit = key.toCSVFormat(metricValues[index]);
2116                 CSVUtil.Escape.println(out, format, CSVUtil.Escape.escape(key.getName()), valueAndUnit.getLeft(), valueAndUnit.getRight());
2117             }
2118         }
2119     }
2120 
2121     /**
2122      * Appends metrics in a human readable format to {@code out} for a single method compilation.
2123      *
2124      * @param identity the identity hash code of {@code compilable}
2125      * @param compilationNr where this compilation lies in the ordered sequence of all compilations
2126      *            identified by {@code identity}
2127      * @param compilationId the runtime issued identifier for the compilation
2128      */
2129     private void printMetrics(PrintStream out, Object compilable, Integer identity, int compilationNr, String compilationId) {
2130         String compilableName = compilable instanceof JavaMethod ? ((JavaMethod) compilable).format(&quot;%H.%n(%p)%R&quot;) : String.valueOf(compilable);
2131         int maxKeyWidth = compilableName.length();
2132         SortedMap&lt;String, String&gt; res = new TreeMap&lt;&gt;();
2133         for (MetricKey key : KeyRegistry.getKeys()) {
2134             int index = ((AbstractKey) key).getIndex();
2135             if (index &lt; metricValues.length &amp;&amp; metricValues[index] != 0) {
2136                 String name = key.getName();
2137                 long value = metricValues[index];
2138                 String valueString;
2139                 if (key instanceof TimerKey) {
2140                     // Report timers in ms
2141                     TimerKey timer = (TimerKey) key;
2142                     long ms = timer.getTimeUnit().toMillis(value);
2143                     if (ms == 0) {
2144                         continue;
2145                     }
2146                     valueString = ms + &quot;ms&quot;;
2147                 } else {
2148                     valueString = String.valueOf(value);
2149                 }
2150                 res.put(name, valueString);
2151                 maxKeyWidth = Math.max(maxKeyWidth, name.length());
2152             }
2153         }
2154 
2155         String title = String.format(&quot;%s [id:%s compilation:%d compilation_id:%s]&quot;, compilableName, identity, compilationNr, compilationId);
2156         out.println(new String(new char[title.length()]).replace(&#39;\0&#39;, &#39;#&#39;));
2157         out.printf(&quot;%s%n&quot;, title);
2158         out.println(new String(new char[title.length()]).replace(&#39;\0&#39;, &#39;~&#39;));
2159 
2160         for (Map.Entry&lt;String, String&gt; e : res.entrySet()) {
2161             out.printf(&quot;%-&quot; + String.valueOf(maxKeyWidth) + &quot;s = %20s%n&quot;, e.getKey(), e.getValue());
2162         }
2163         out.println();
2164     }
2165 
2166     public Map&lt;MetricKey, Long&gt; getMetricsSnapshot() {
2167         Map&lt;MetricKey, Long&gt; res = new HashMap&lt;&gt;();
2168         for (MetricKey key : KeyRegistry.getKeys()) {
2169             int index = ((AbstractKey) key).getIndex();
2170             if (index &lt; metricValues.length &amp;&amp; metricValues[index] != 0) {
2171                 long value = metricValues[index];
2172                 res.put(key, value);
2173             }
2174         }
2175         return res;
2176     }
2177 
2178     @SuppressWarnings({&quot;unused&quot;, &quot;unchecked&quot;})
2179     private static &lt;E extends Exception&gt; E rethrowSilently(Class&lt;E&gt; type, Throwable ex) throws E {
2180         throw (E) ex;
2181     }
2182 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
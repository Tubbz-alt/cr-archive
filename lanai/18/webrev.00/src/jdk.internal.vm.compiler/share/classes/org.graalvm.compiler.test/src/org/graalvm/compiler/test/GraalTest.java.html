<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.test/src/org/graalvm/compiler/test/GraalTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.test;
 26 
 27 import static org.graalvm.compiler.debug.DebugContext.DEFAULT_LOG_STREAM;
 28 import static org.graalvm.compiler.debug.DebugContext.NO_DESCRIPTION;
 29 
 30 import java.io.IOException;
 31 import java.io.PrintStream;
 32 import java.io.PrintWriter;
 33 import java.lang.reflect.Method;
 34 import java.nio.file.FileVisitResult;
 35 import java.nio.file.Files;
 36 import java.nio.file.Path;
 37 import java.nio.file.Paths;
 38 import java.nio.file.SimpleFileVisitor;
 39 import java.nio.file.attribute.BasicFileAttributes;
 40 import java.nio.file.attribute.FileAttribute;
 41 import java.util.ArrayList;
 42 import java.util.Arrays;
 43 import java.util.Collection;
 44 import java.util.Collections;
 45 import java.util.List;
 46 import java.util.concurrent.TimeUnit;
 47 
 48 import org.graalvm.compiler.debug.DebugContext;
 49 import org.graalvm.compiler.debug.DebugDumpHandler;
 50 import org.graalvm.compiler.debug.DebugHandlersFactory;
 51 import org.graalvm.compiler.debug.GlobalMetrics;
 52 import org.graalvm.compiler.options.OptionValues;
 53 import org.graalvm.compiler.serviceprovider.GraalServices;
 54 import org.graalvm.compiler.serviceprovider.GraalUnsafeAccess;
 55 import org.junit.After;
 56 import org.junit.Assert;
 57 import org.junit.AssumptionViolatedException;
 58 import org.junit.internal.ComparisonCriteria;
 59 import org.junit.internal.ExactComparisonCriteria;
 60 import org.junit.rules.DisableOnDebug;
 61 import org.junit.rules.TestRule;
 62 import org.junit.rules.Timeout;
 63 
 64 import jdk.vm.ci.meta.ResolvedJavaMethod;
 65 import sun.misc.Unsafe;
 66 
 67 /**
 68  * Base class that contains common utility methods and classes useful in unit tests.
 69  */
 70 public class GraalTest {
 71 
 72     public static final Unsafe UNSAFE = GraalUnsafeAccess.getUnsafe();
 73 
 74     protected Method getMethod(String methodName) {
 75         return getMethod(getClass(), methodName);
 76     }
 77 
 78     protected Method getMethod(Class&lt;?&gt; clazz, String methodName) {
 79         Method found = null;
 80         for (Method m : clazz.getMethods()) {
 81             if (m.getName().equals(methodName)) {
 82                 Assert.assertNull(found);
 83                 found = m;
 84             }
 85         }
 86         if (found == null) {
 87             /* Now look for non-public methods (but this does not look in superclasses). */
 88             for (Method m : clazz.getDeclaredMethods()) {
 89                 if (m.getName().equals(methodName)) {
 90                     Assert.assertNull(found);
 91                     found = m;
 92                 }
 93             }
 94         }
 95         if (found != null) {
 96             return found;
 97         } else {
 98             throw new RuntimeException(&quot;method not found: &quot; + methodName);
 99         }
100     }
101 
102     protected Method getMethod(Class&lt;?&gt; clazz, String methodName, Class&lt;?&gt;... parameterTypes) {
103         try {
104             return clazz.getMethod(methodName, parameterTypes);
105         } catch (NoSuchMethodException | SecurityException e) {
106             throw new RuntimeException(&quot;method not found: &quot; + methodName + &quot;&quot; + Arrays.toString(parameterTypes));
107         }
108     }
109 
110     /**
111      * Compares two given objects for {@linkplain Assert#assertEquals(Object, Object) equality}.
112      * Does a deep copy equality comparison if {@code expected} is an array.
113      */
114     protected void assertDeepEquals(Object expected, Object actual) {
115         assertDeepEquals(null, expected, actual);
116     }
117 
118     /**
119      * Compares two given objects for {@linkplain Assert#assertEquals(Object, Object) equality}.
120      * Does a deep copy equality comparison if {@code expected} is an array.
121      *
122      * @param message the identifying message for the {@link AssertionError}
123      */
124     protected void assertDeepEquals(String message, Object expected, Object actual) {
125         if (ulpsDelta() &gt; 0) {
126             assertDeepEquals(message, expected, actual, ulpsDelta());
127         } else {
128             assertDeepEquals(message, expected, actual, equalFloatsOrDoublesDelta());
129         }
130     }
131 
132     /**
133      * Compares two given values for equality, doing a recursive test if both values are arrays of
134      * the same type.
135      *
136      * @param message the identifying message for the {@link AssertionError}
137      * @param delta the maximum delta between two doubles or floats for which both numbers are still
138      *            considered equal.
139      */
140     protected void assertDeepEquals(String message, Object expected, Object actual, double delta) {
141         if (expected != null &amp;&amp; actual != null) {
142             Class&lt;?&gt; expectedClass = expected.getClass();
143             Class&lt;?&gt; actualClass = actual.getClass();
144             if (expectedClass.isArray()) {
145                 Assert.assertEquals(message, expectedClass, actual.getClass());
146                 if (expected instanceof int[]) {
147                     Assert.assertArrayEquals(message, (int[]) expected, (int[]) actual);
148                 } else if (expected instanceof byte[]) {
149                     Assert.assertArrayEquals(message, (byte[]) expected, (byte[]) actual);
150                 } else if (expected instanceof char[]) {
151                     Assert.assertArrayEquals(message, (char[]) expected, (char[]) actual);
152                 } else if (expected instanceof short[]) {
153                     Assert.assertArrayEquals(message, (short[]) expected, (short[]) actual);
154                 } else if (expected instanceof float[]) {
155                     Assert.assertArrayEquals(message, (float[]) expected, (float[]) actual, (float) delta);
156                 } else if (expected instanceof long[]) {
157                     Assert.assertArrayEquals(message, (long[]) expected, (long[]) actual);
158                 } else if (expected instanceof double[]) {
159                     Assert.assertArrayEquals(message, (double[]) expected, (double[]) actual, delta);
160                 } else if (expected instanceof boolean[]) {
161                     new ExactComparisonCriteria().arrayEquals(message, expected, actual);
162                 } else if (expected instanceof Object[]) {
163                     new ComparisonCriteria() {
164                         @Override
165                         protected void assertElementsEqual(Object e, Object a) {
166                             assertDeepEquals(message, e, a, delta);
167                         }
168                     }.arrayEquals(message, expected, actual);
169                 } else {
170                     Assert.fail((message == null ? &quot;&quot; : message) + &quot;non-array value encountered: &quot; + expected);
171                 }
172             } else if (expectedClass.equals(double.class) &amp;&amp; actualClass.equals(double.class)) {
173                 Assert.assertEquals((double) expected, (double) actual, delta);
174             } else if (expectedClass.equals(float.class) &amp;&amp; actualClass.equals(float.class)) {
175                 Assert.assertEquals((float) expected, (float) actual, delta);
176             } else {
177                 Assert.assertEquals(message, expected, actual);
178             }
179         } else {
180             Assert.assertEquals(message, expected, actual);
181         }
182     }
183 
184     /**
185      * Compares two given values for equality, doing a recursive test if both values are arrays of
186      * the same type. Uses {@linkplain StrictMath#ulp(float) ULP}s for comparison of floats.
187      *
188      * @param message the identifying message for the {@link AssertionError}
189      * @param ulpsDelta the maximum allowed ulps difference between two doubles or floats for which
190      *            both numbers are still considered equal.
191      */
192     protected void assertDeepEquals(String message, Object expected, Object actual, int ulpsDelta) {
193         ComparisonCriteria doubleUlpsDeltaCriteria = new ComparisonCriteria() {
194             @Override
195             protected void assertElementsEqual(Object e, Object a) {
196                 assertTrue(message, e instanceof Double &amp;&amp; a instanceof Double);
197                 // determine acceptable error based on whether it is a normal number or a NaN/Inf
198                 double de = (Double) e;
199                 double epsilon = (!Double.isNaN(de) &amp;&amp; Double.isFinite(de) ? ulpsDelta * Math.ulp(de) : 0);
200                 Assert.assertEquals(message, (Double) e, (Double) a, epsilon);
201             }
202         };
203 
204         ComparisonCriteria floatUlpsDeltaCriteria = new ComparisonCriteria() {
205             @Override
206             protected void assertElementsEqual(Object e, Object a) {
207                 assertTrue(message, e instanceof Float &amp;&amp; a instanceof Float);
208                 // determine acceptable error based on whether it is a normal number or a NaN/Inf
209                 float fe = (Float) e;
210                 float epsilon = (!Float.isNaN(fe) &amp;&amp; Float.isFinite(fe) ? ulpsDelta * Math.ulp(fe) : 0);
211                 Assert.assertEquals(message, (Float) e, (Float) a, epsilon);
212             }
213         };
214 
215         if (expected != null &amp;&amp; actual != null) {
216             Class&lt;?&gt; expectedClass = expected.getClass();
217             Class&lt;?&gt; actualClass = actual.getClass();
218             if (expectedClass.isArray()) {
219                 Assert.assertEquals(message, expectedClass, actualClass);
220                 if (expected instanceof double[] || expected instanceof Object[]) {
221                     doubleUlpsDeltaCriteria.arrayEquals(message, expected, actual);
222                     return;
223                 } else if (expected instanceof float[] || expected instanceof Object[]) {
224                     floatUlpsDeltaCriteria.arrayEquals(message, expected, actual);
225                     return;
226                 }
227             } else if (expectedClass.equals(double.class) &amp;&amp; actualClass.equals(double.class)) {
228                 doubleUlpsDeltaCriteria.arrayEquals(message, expected, actual);
229                 return;
230             } else if (expectedClass.equals(float.class) &amp;&amp; actualClass.equals(float.class)) {
231                 floatUlpsDeltaCriteria.arrayEquals(message, expected, actual);
232                 return;
233             }
234         }
235         // anything else just use the non-ulps version
236         assertDeepEquals(message, expected, actual, equalFloatsOrDoublesDelta());
237     }
238 
239     /**
240      * @see &quot;https://bugs.openjdk.java.net/browse/JDK-8076557&quot;
241      */
242     public static void assumeManagementLibraryIsLoadable() {
243         try {
244             /* Trigger loading of the management library using the bootstrap class loader. */
245             GraalServices.getCurrentThreadAllocatedBytes();
246         } catch (UnsatisfiedLinkError | NoClassDefFoundError | UnsupportedOperationException e) {
247             throw new AssumptionViolatedException(&quot;Management interface is unavailable: &quot; + e);
248         }
249     }
250 
251     /**
252      * Gets the value used by {@link #assertDeepEquals(Object, Object)} and
253      * {@link #assertDeepEquals(String, Object, Object)} for the maximum delta between two doubles
254      * or floats for which both numbers are still considered equal.
255      */
256     protected double equalFloatsOrDoublesDelta() {
257         return 0.0D;
258     }
259 
260     // unless overridden ulpsDelta is not used
261     protected int ulpsDelta() {
262         return 0;
263     }
264 
265     @SuppressWarnings(&quot;serial&quot;)
266     public static class MultiCauseAssertionError extends AssertionError {
267 
268         private Throwable[] causes;
269 
270         public MultiCauseAssertionError(String message, Throwable... causes) {
271             super(message);
272             this.causes = causes;
273         }
274 
275         @Override
276         public void printStackTrace(PrintStream out) {
277             super.printStackTrace(out);
278             int num = 0;
279             for (Throwable cause : causes) {
280                 if (cause != null) {
281                     out.print(&quot;cause &quot; + (num++));
282                     cause.printStackTrace(out);
283                 }
284             }
285         }
286 
287         @Override
288         public void printStackTrace(PrintWriter out) {
289             super.printStackTrace(out);
290             int num = 0;
291             for (Throwable cause : causes) {
292                 if (cause != null) {
293                     out.print(&quot;cause &quot; + (num++) + &quot;: &quot;);
294                     cause.printStackTrace(out);
295                 }
296             }
297         }
298     }
299 
300     /*
301      * Overrides to the normal JUnit {@link Assert} routines that provide varargs style formatting
302      * and produce an exception stack trace with the assertion frames trimmed out.
303      */
304 
305     /**
306      * Fails a test with the given message.
307      *
308      * @param message the identifying message for the {@link AssertionError} (&lt;code&gt;null&lt;/code&gt;
309      *            okay)
310      * @see AssertionError
311      */
312     public static void fail(String message, Object... objects) {
313         AssertionError e;
314         if (message == null) {
315             e = new AssertionError();
316         } else {
317             e = new AssertionError(String.format(message, objects));
318         }
319         // Trim the assert frames from the stack trace
320         StackTraceElement[] trace = e.getStackTrace();
321         int start = 1; // Skip this frame
322         String thisClassName = GraalTest.class.getName();
323         while (start &lt; trace.length &amp;&amp; trace[start].getClassName().equals(thisClassName) &amp;&amp; (trace[start].getMethodName().equals(&quot;assertTrue&quot;) || trace[start].getMethodName().equals(&quot;assertFalse&quot;))) {
324             start++;
325         }
326         e.setStackTrace(Arrays.copyOfRange(trace, start, trace.length));
327         throw e;
328     }
329 
330     /**
331      * Asserts that a condition is true. If it isn&#39;t it throws an {@link AssertionError} with the
332      * given message.
333      *
334      * @param message the identifying message for the {@link AssertionError} (&lt;code&gt;null&lt;/code&gt;
335      *            okay)
336      * @param condition condition to be checked
337      */
338     public static void assertTrue(String message, boolean condition) {
339         assertTrue(condition, message);
340     }
341 
342     /**
343      * Asserts that a condition is true. If it isn&#39;t it throws an {@link AssertionError} without a
344      * message.
345      *
346      * @param condition condition to be checked
347      */
348     public static void assertTrue(boolean condition) {
349         assertTrue(condition, null);
350     }
351 
352     /**
353      * Asserts that a condition is false. If it isn&#39;t it throws an {@link AssertionError} with the
354      * given message.
355      *
356      * @param message the identifying message for the {@link AssertionError} (&lt;code&gt;null&lt;/code&gt;
357      *            okay)
358      * @param condition condition to be checked
359      */
360     public static void assertFalse(String message, boolean condition) {
361         assertTrue(!condition, message);
362     }
363 
364     /**
365      * Asserts that a condition is false. If it isn&#39;t it throws an {@link AssertionError} without a
366      * message.
367      *
368      * @param condition condition to be checked
369      */
370     public static void assertFalse(boolean condition) {
371         assertTrue(!condition, null);
372     }
373 
374     /**
375      * Asserts that a condition is true. If it isn&#39;t it throws an {@link AssertionError} with the
376      * given message.
377      *
378      * @param condition condition to be checked
379      * @param message the identifying message for the {@link AssertionError}
380      * @param objects arguments to the format string
381      */
382     public static void assertTrue(boolean condition, String message, Object... objects) {
383         if (!condition) {
384             fail(message, objects);
385         }
386     }
387 
388     /**
389      * Asserts that a condition is false. If it isn&#39;t it throws an {@link AssertionError} with the
390      * given message produced by {@link String#format}.
391      *
392      * @param condition condition to be checked
393      * @param message the identifying message for the {@link AssertionError}
394      * @param objects arguments to the format string
395      */
396     public static void assertFalse(boolean condition, String message, Object... objects) {
397         assertTrue(!condition, message, objects);
398     }
399 
400     /**
401      * Gets the {@link DebugHandlersFactory}s available for a {@link DebugContext}.
402      */
403     protected Collection&lt;DebugHandlersFactory&gt; getDebugHandlersFactories() {
404         return Collections.emptyList();
405     }
406 
407     /**
408      * Gets a {@link DebugContext} object corresponding to {@code options}, creating a new one if
409      * none currently exists. Debug contexts created by this method will have their
410      * {@link DebugDumpHandler}s closed in {@link #afterTest()}.
411      */
412     protected DebugContext getDebugContext(OptionValues options) {
413         return getDebugContext(options, null, null);
414     }
415 
416     /**
417      * Gets a {@link DebugContext} object corresponding to {@code options}, creating a new one if
418      * none currently exists. Debug contexts created by this method will have their
419      * {@link DebugDumpHandler}s closed in {@link #afterTest()}.
420      *
421      * @param options currently active options
422      * @param id identification of the compilation or {@code null}
423      * @param method method to use for a proper description of the context or {@code null}
424      * @return configured context for compilation
425      */
426     protected DebugContext getDebugContext(OptionValues options, String id, ResolvedJavaMethod method) {
427         List&lt;DebugContext&gt; cached = cachedDebugs.get();
428         if (cached == null) {
429             cached = new ArrayList&lt;&gt;();
430             cachedDebugs.set(cached);
431         }
432         for (DebugContext debug : cached) {
433             if (debug.getOptions() == options) {
434                 return debug;
435             }
436         }
437         final DebugContext.Description descr;
438         if (method == null) {
439             descr = NO_DESCRIPTION;
440         } else {
441             descr = new DebugContext.Description(method, id == null ? method.getName() : id);
442         }
443         DebugContext debug = DebugContext.create(options, descr, globalMetrics, DEFAULT_LOG_STREAM, getDebugHandlersFactories());
444         cached.add(debug);
445         return debug;
446     }
447 
448     private static final GlobalMetrics globalMetrics = new GlobalMetrics();
449 
450     static {
451         Runtime.getRuntime().addShutdownHook(new Thread(&quot;GlobalMetricsPrinter&quot;) {
452             @Override
453             public void run() {
454                 // globalMetrics.print(new OptionValues(OptionValues.newOptionMap()));
455             }
456         });
457     }
458     private final ThreadLocal&lt;List&lt;DebugContext&gt;&gt; cachedDebugs = new ThreadLocal&lt;&gt;();
459 
460     @After
461     public void afterTest() {
462         List&lt;DebugContext&gt; cached = cachedDebugs.get();
463         if (cached != null) {
464             for (DebugContext debug : cached) {
465                 debug.close();
466                 debug.closeDumpHandlers(true);
467             }
468         }
469     }
470 
471     private static final double TIMEOUT_SCALING_FACTOR = Double.parseDouble(System.getProperty(&quot;graaltest.timeout.factor&quot;, &quot;1.0&quot;));
472 
473     /**
474      * Creates a {@link TestRule} that applies a given timeout.
475      *
476      * A test harness can scale {@code length} with a factor specified by the
477      * {@code graaltest.timeout.factor} system property.
478      */
479     public static TestRule createTimeout(long length, TimeUnit timeUnit) {
480         Timeout timeout = new Timeout((long) (length * TIMEOUT_SCALING_FACTOR), timeUnit);
481         try {
482             return new DisableOnDebug(timeout);
483         } catch (LinkageError ex) {
484             return timeout;
485         }
486     }
487 
488     /**
489      * @see #createTimeout
490      */
491     public static TestRule createTimeoutSeconds(int seconds) {
492         return createTimeout(seconds, TimeUnit.SECONDS);
493     }
494 
495     /**
496      * @see #createTimeout
497      */
498     public static TestRule createTimeoutMillis(long milliseconds) {
499         return createTimeout(milliseconds, TimeUnit.MILLISECONDS);
500     }
501 
502     public static class TemporaryDirectory implements AutoCloseable {
503 
504         public final Path path;
505         private IOException closeException;
506 
507         public TemporaryDirectory(Path dir, String prefix, FileAttribute&lt;?&gt;... attrs) throws IOException {
508             path = Files.createTempDirectory(dir == null ? Paths.get(&quot;.&quot;) : dir, prefix, attrs);
509         }
510 
511         @Override
512         public void close() {
513             closeException = removeDirectory(path);
514         }
515 
516         public IOException getCloseException() {
517             return closeException;
518         }
519 
520         @Override
521         public String toString() {
522             return path.toString();
523         }
524     }
525 
526     /**
527      * Tries to recursively remove {@code directory}. If it fails with an {@link IOException}, the
528      * exception&#39;s {@code toString()} is printed to {@link System#err} and the exception is
529      * returned.
530      */
531     public static IOException removeDirectory(Path directory) {
532         try {
533             Files.walkFileTree(directory, new SimpleFileVisitor&lt;Path&gt;() {
534                 @Override
535                 public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
536                     Files.delete(file);
537                     return FileVisitResult.CONTINUE;
538                 }
539 
540                 @Override
541                 public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
542                     Files.delete(dir);
543                     return FileVisitResult.CONTINUE;
544                 }
545             });
546         } catch (IOException e) {
547             System.err.println(e);
548             return e;
549         }
550         return null;
551     }
552 }
    </pre>
  </body>
</html>
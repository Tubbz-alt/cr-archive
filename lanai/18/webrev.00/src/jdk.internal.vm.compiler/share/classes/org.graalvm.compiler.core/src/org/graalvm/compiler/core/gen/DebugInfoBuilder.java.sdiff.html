<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core/src/org/graalvm/compiler/core/gen/DebugInfoBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../LIRGenerationPhase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="NodeLIRBuilder.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core/src/org/graalvm/compiler/core/gen/DebugInfoBuilder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
123                     slotKinds = new JavaKind[entryCount];
124                 }
125                 if (values.length &gt; 0) {
126                     VirtualObjectState currentField = (VirtualObjectState) objectStates.get(vobjNode);
127                     assert currentField != null;
128                     int pos = 0;
129                     for (int i = 0; i &lt; entryCount; i++) {
130                         ValueNode value = currentField.values().get(i);
131                         if (value == null) {
132                             JavaKind entryKind = vobjNode.entryKind(i);
133                             values[pos] = JavaConstant.defaultForKind(entryKind.getStackKind());
134                             slotKinds[pos] = entryKind.getStackKind();
135                             pos++;
136                         } else if (!value.isConstant() || value.asJavaConstant().getJavaKind() != JavaKind.Illegal) {
137                             values[pos] = toJavaValue(value);
138                             slotKinds[pos] = toSlotKind(value);
139                             pos++;
140                         } else {
141                             assert value.getStackKind() == JavaKind.Illegal;
142                             ValueNode previousValue = currentField.values().get(i - 1);
<span class="line-modified">143                             assert (previousValue != null &amp;&amp; previousValue.getStackKind().needsTwoSlots()) : vobjNode + &quot; &quot; + i +</span>
144                                             &quot; &quot; + previousValue + &quot; &quot; + currentField.values().snapshot();
<span class="line-modified">145                             if (previousValue == null || !previousValue.getStackKind().needsTwoSlots()) {</span>














146                                 // Don&#39;t allow the IllegalConstant to leak into the debug info
147                                 JavaKind entryKind = vobjNode.entryKind(i);
148                                 values[pos] = JavaConstant.defaultForKind(entryKind.getStackKind());
149                                 slotKinds[pos] = entryKind.getStackKind();
150                                 pos++;
151                             }
152                         }
153                     }
154                     if (pos != entryCount) {
155                         values = Arrays.copyOf(values, pos);
156                         slotKinds = Arrays.copyOf(slotKinds, pos);
157                     }
158                 }
159                 assert checkValues(vobjValue.getType(), values, slotKinds);
160                 vobjValue.setValues(values, slotKinds);
161             }
162 
163             virtualObjectsArray = new VirtualObject[virtualObjects.size()];
164             int index = 0;
165             for (VirtualObject value : virtualObjects.getValues()) {
</pre>
<hr />
<pre>
186                     if ((valKind == JavaKind.Double || valKind == JavaKind.Long) &amp;&amp; fieldKind == JavaKind.Int) {
187                         assert fieldIndex + 1 &lt; fields.length : String.format(&quot;Not enough fields for fieldIndex = %d valueIndex = %d %s %s&quot;, fieldIndex, valueIndex, Arrays.toString(fields),
188                                         Arrays.toString(values));
189                         assert storageKind(fields[fieldIndex + 1].getType()) == JavaKind.Int : String.format(&quot;fieldIndex = %d valueIndex = %d %s %s %s&quot;, fieldIndex, valueIndex,
190                                         storageKind(fields[fieldIndex + 1].getType()), Arrays.toString(fields),
191                                         Arrays.toString(values));
192                         fieldIndex++;
193                     } else {
194                         assert valKind == fieldKind.getStackKind() : field + &quot;: &quot; + valKind + &quot; != &quot; + fieldKind;
195                     }
196                 }
197                 assert fields.length == fieldIndex : type + &quot;: fields=&quot; + Arrays.toString(fields) + &quot;, field values=&quot; + Arrays.toString(values);
198             } else {
199                 JavaKind componentKind = storageKind(type.getComponentType()).getStackKind();
200                 if (componentKind == JavaKind.Object) {
201                     for (int i = 0; i &lt; values.length; i++) {
202                         assert slotKinds[i].isObject() : slotKinds[i] + &quot; != &quot; + componentKind;
203                     }
204                 } else {
205                     for (int i = 0; i &lt; values.length; i++) {
<span class="line-modified">206                         assert slotKinds[i] == componentKind || componentKind.getBitCount() &gt;= slotKinds[i].getBitCount() ||</span>


207                                         (componentKind == JavaKind.Int &amp;&amp; slotKinds[i].getBitCount() &gt;= JavaKind.Int.getBitCount()) : slotKinds[i] + &quot; != &quot; + componentKind;
208                     }
209                 }
210             }
211         }
212         return true;
213     }
214 
215     /*
216      * Customization point for subclasses. For example, Word types have a kind Object, but are
217      * internally stored as a primitive value. We do not know about Word types here, but subclasses
218      * do know.
219      */
220     protected JavaKind storageKind(JavaType type) {
221         return type.getJavaKind();
222     }
223 
224     protected LIRFrameState newLIRFrameState(LabelRef exceptionEdge, BytecodeFrame frame, VirtualObject[] virtualObjectsArray) {
225         return new LIRFrameState(frame, virtualObjectsArray, exceptionEdge);
226     }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
123                     slotKinds = new JavaKind[entryCount];
124                 }
125                 if (values.length &gt; 0) {
126                     VirtualObjectState currentField = (VirtualObjectState) objectStates.get(vobjNode);
127                     assert currentField != null;
128                     int pos = 0;
129                     for (int i = 0; i &lt; entryCount; i++) {
130                         ValueNode value = currentField.values().get(i);
131                         if (value == null) {
132                             JavaKind entryKind = vobjNode.entryKind(i);
133                             values[pos] = JavaConstant.defaultForKind(entryKind.getStackKind());
134                             slotKinds[pos] = entryKind.getStackKind();
135                             pos++;
136                         } else if (!value.isConstant() || value.asJavaConstant().getJavaKind() != JavaKind.Illegal) {
137                             values[pos] = toJavaValue(value);
138                             slotKinds[pos] = toSlotKind(value);
139                             pos++;
140                         } else {
141                             assert value.getStackKind() == JavaKind.Illegal;
142                             ValueNode previousValue = currentField.values().get(i - 1);
<span class="line-modified">143                             assert (previousValue != null &amp;&amp; (previousValue.getStackKind().needsTwoSlots()) || vobjNode.isVirtualByteArray()) : vobjNode + &quot; &quot; + i +</span>
144                                             &quot; &quot; + previousValue + &quot; &quot; + currentField.values().snapshot();
<span class="line-modified">145                             if (vobjNode.isVirtualByteArray()) {</span>
<span class="line-added">146                                 /*</span>
<span class="line-added">147                                  * Let Illegals pass through to help knowing the number of bytes to</span>
<span class="line-added">148                                  * write. For example, writing a short to index 2 of a byte array of</span>
<span class="line-added">149                                  * size 6 would look like, in debug info:</span>
<span class="line-added">150                                  *</span>
<span class="line-added">151                                  * {b0, b1, INT(...), ILLEGAL, b4, b5}</span>
<span class="line-added">152                                  *</span>
<span class="line-added">153                                  * Thus, from the VM, we can simply count the number of illegals to</span>
<span class="line-added">154                                  * restore the byte count.</span>
<span class="line-added">155                                  */</span>
<span class="line-added">156                                 values[pos] = Value.ILLEGAL;</span>
<span class="line-added">157                                 slotKinds[pos] = JavaKind.Illegal;</span>
<span class="line-added">158                                 pos++;</span>
<span class="line-added">159                             } else if (previousValue == null || !previousValue.getStackKind().needsTwoSlots()) {</span>
160                                 // Don&#39;t allow the IllegalConstant to leak into the debug info
161                                 JavaKind entryKind = vobjNode.entryKind(i);
162                                 values[pos] = JavaConstant.defaultForKind(entryKind.getStackKind());
163                                 slotKinds[pos] = entryKind.getStackKind();
164                                 pos++;
165                             }
166                         }
167                     }
168                     if (pos != entryCount) {
169                         values = Arrays.copyOf(values, pos);
170                         slotKinds = Arrays.copyOf(slotKinds, pos);
171                     }
172                 }
173                 assert checkValues(vobjValue.getType(), values, slotKinds);
174                 vobjValue.setValues(values, slotKinds);
175             }
176 
177             virtualObjectsArray = new VirtualObject[virtualObjects.size()];
178             int index = 0;
179             for (VirtualObject value : virtualObjects.getValues()) {
</pre>
<hr />
<pre>
200                     if ((valKind == JavaKind.Double || valKind == JavaKind.Long) &amp;&amp; fieldKind == JavaKind.Int) {
201                         assert fieldIndex + 1 &lt; fields.length : String.format(&quot;Not enough fields for fieldIndex = %d valueIndex = %d %s %s&quot;, fieldIndex, valueIndex, Arrays.toString(fields),
202                                         Arrays.toString(values));
203                         assert storageKind(fields[fieldIndex + 1].getType()) == JavaKind.Int : String.format(&quot;fieldIndex = %d valueIndex = %d %s %s %s&quot;, fieldIndex, valueIndex,
204                                         storageKind(fields[fieldIndex + 1].getType()), Arrays.toString(fields),
205                                         Arrays.toString(values));
206                         fieldIndex++;
207                     } else {
208                         assert valKind == fieldKind.getStackKind() : field + &quot;: &quot; + valKind + &quot; != &quot; + fieldKind;
209                     }
210                 }
211                 assert fields.length == fieldIndex : type + &quot;: fields=&quot; + Arrays.toString(fields) + &quot;, field values=&quot; + Arrays.toString(values);
212             } else {
213                 JavaKind componentKind = storageKind(type.getComponentType()).getStackKind();
214                 if (componentKind == JavaKind.Object) {
215                     for (int i = 0; i &lt; values.length; i++) {
216                         assert slotKinds[i].isObject() : slotKinds[i] + &quot; != &quot; + componentKind;
217                     }
218                 } else {
219                     for (int i = 0; i &lt; values.length; i++) {
<span class="line-modified">220                         assert slotKinds[i] == componentKind ||</span>
<span class="line-added">221                                         (slotKinds[i] == JavaKind.Illegal &amp;&amp; storageKind(type.getComponentType()) == JavaKind.Byte) ||</span>
<span class="line-added">222                                         componentKind.getBitCount() &gt;= slotKinds[i].getBitCount() ||</span>
223                                         (componentKind == JavaKind.Int &amp;&amp; slotKinds[i].getBitCount() &gt;= JavaKind.Int.getBitCount()) : slotKinds[i] + &quot; != &quot; + componentKind;
224                     }
225                 }
226             }
227         }
228         return true;
229     }
230 
231     /*
232      * Customization point for subclasses. For example, Word types have a kind Object, but are
233      * internally stored as a primitive value. We do not know about Word types here, but subclasses
234      * do know.
235      */
236     protected JavaKind storageKind(JavaType type) {
237         return type.getJavaKind();
238     }
239 
240     protected LIRFrameState newLIRFrameState(LabelRef exceptionEdge, BytecodeFrame frame, VirtualObject[] virtualObjectsArray) {
241         return new LIRFrameState(frame, virtualObjectsArray, exceptionEdge);
242     }
</pre>
</td>
</tr>
</table>
<center><a href="../LIRGenerationPhase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="NodeLIRBuilder.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
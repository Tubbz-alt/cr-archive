<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases/src/org/graalvm/compiler/phases/schedule/SchedulePhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.phases.schedule;
  26 
  27 import static jdk.internal.vm.compiler.collections.Equivalence.IDENTITY;
  28 import static org.graalvm.compiler.core.common.GraalOptions.GuardPriorities;
  29 import static org.graalvm.compiler.core.common.GraalOptions.OptScheduleOutOfLoops;
  30 import static org.graalvm.compiler.core.common.cfg.AbstractControlFlowGraph.strictlyDominates;
  31 
  32 import java.util.ArrayList;
  33 import java.util.Arrays;
  34 import java.util.Comparator;
  35 import java.util.EnumMap;
  36 import java.util.Formatter;
  37 import java.util.Iterator;
  38 import java.util.List;
  39 import java.util.SortedSet;
  40 import java.util.TreeSet;
  41 import java.util.function.Function;
  42 
  43 import jdk.internal.vm.compiler.collections.EconomicSet;
  44 import org.graalvm.compiler.core.common.SuppressFBWarnings;
  45 import org.graalvm.compiler.core.common.cfg.AbstractControlFlowGraph;
  46 import org.graalvm.compiler.core.common.cfg.BlockMap;
  47 import org.graalvm.compiler.debug.Assertions;
  48 import org.graalvm.compiler.graph.Graph.NodeEvent;
  49 import org.graalvm.compiler.graph.Graph.NodeEventListener;
  50 import org.graalvm.compiler.graph.Graph.NodeEventScope;
  51 import org.graalvm.compiler.graph.Node;
  52 import org.graalvm.compiler.graph.NodeBitMap;
  53 import org.graalvm.compiler.graph.NodeMap;
  54 import org.graalvm.compiler.graph.NodeStack;
  55 import org.graalvm.compiler.nodes.AbstractBeginNode;
  56 import org.graalvm.compiler.nodes.AbstractEndNode;
  57 import org.graalvm.compiler.nodes.AbstractMergeNode;
  58 import org.graalvm.compiler.nodes.ControlSinkNode;
  59 import org.graalvm.compiler.nodes.ControlSplitNode;
  60 import org.graalvm.compiler.nodes.DeoptimizeNode;
  61 import org.graalvm.compiler.nodes.FixedNode;
  62 import org.graalvm.compiler.nodes.GuardNode;
  63 import org.graalvm.compiler.nodes.IfNode;
  64 import org.graalvm.compiler.nodes.KillingBeginNode;
  65 import org.graalvm.compiler.nodes.LoopBeginNode;
  66 import org.graalvm.compiler.nodes.LoopExitNode;
  67 import org.graalvm.compiler.nodes.PhiNode;
  68 import org.graalvm.compiler.nodes.ProxyNode;
  69 import org.graalvm.compiler.nodes.StartNode;
  70 import org.graalvm.compiler.nodes.StaticDeoptimizingNode;
  71 import org.graalvm.compiler.nodes.StaticDeoptimizingNode.GuardPriority;
  72 import org.graalvm.compiler.nodes.StructuredGraph;
  73 import org.graalvm.compiler.nodes.StructuredGraph.GuardsStage;
  74 import org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult;
  75 import org.graalvm.compiler.nodes.ValueNode;
  76 import org.graalvm.compiler.nodes.VirtualState;
  77 import org.graalvm.compiler.nodes.calc.ConvertNode;
  78 import org.graalvm.compiler.nodes.calc.IsNullNode;
  79 import org.graalvm.compiler.nodes.cfg.Block;
  80 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
  81 import org.graalvm.compiler.nodes.cfg.HIRLoop;
  82 import org.graalvm.compiler.nodes.cfg.LocationSet;
  83 import org.graalvm.compiler.nodes.memory.FloatingReadNode;
  84 import org.graalvm.compiler.nodes.memory.MultiMemoryKill;
  85 import org.graalvm.compiler.nodes.memory.SingleMemoryKill;
  86 import org.graalvm.compiler.nodes.spi.ValueProxy;
  87 import org.graalvm.compiler.options.OptionValues;
  88 import org.graalvm.compiler.phases.Phase;
  89 import jdk.internal.vm.compiler.word.LocationIdentity;
  90 
  91 public final class SchedulePhase extends Phase {
  92 
  93     public enum SchedulingStrategy {
  94         EARLIEST_WITH_GUARD_ORDER,
  95         EARLIEST,
  96         LATEST,
  97         LATEST_OUT_OF_LOOPS,
  98         LATEST_OUT_OF_LOOPS_IMPLICIT_NULL_CHECKS;
  99 
 100         public boolean isEarliest() {
 101             return this == EARLIEST || this == EARLIEST_WITH_GUARD_ORDER;
 102         }
 103 
 104         public boolean isLatest() {
 105             return !isEarliest();
 106         }
 107 
 108         public boolean scheduleOutOfLoops() {
 109             return this == LATEST_OUT_OF_LOOPS || this == LATEST_OUT_OF_LOOPS_IMPLICIT_NULL_CHECKS;
 110         }
 111 
 112         public boolean considerImplicitNullChecks() {
 113             return this == LATEST_OUT_OF_LOOPS_IMPLICIT_NULL_CHECKS;
 114         }
 115     }
 116 
 117     private final SchedulingStrategy selectedStrategy;
 118 
 119     private final boolean immutableGraph;
 120 
 121     public SchedulePhase(OptionValues options) {
 122         this(false, options);
 123     }
 124 
 125     public SchedulePhase(boolean immutableGraph, OptionValues options) {
 126         this(OptScheduleOutOfLoops.getValue(options) ? SchedulingStrategy.LATEST_OUT_OF_LOOPS : SchedulingStrategy.LATEST, immutableGraph);
 127     }
 128 
 129     public SchedulePhase(SchedulingStrategy strategy) {
 130         this(strategy, false);
 131     }
 132 
 133     public SchedulePhase(SchedulingStrategy strategy, boolean immutableGraph) {
 134         this.selectedStrategy = strategy;
 135         this.immutableGraph = immutableGraph;
 136     }
 137 
 138     private NodeEventScope verifyImmutableGraph(StructuredGraph graph) {
 139         if (immutableGraph &amp;&amp; Assertions.assertionsEnabled()) {
 140             return graph.trackNodeEvents(new NodeEventListener() {
 141                 @Override
 142                 public void changed(NodeEvent e, Node node) {
 143                     assert false : &quot;graph changed: &quot; + e + &quot; on node &quot; + node;
 144                 }
 145             });
 146         } else {
 147             return null;
 148         }
 149     }
 150 
 151     @Override
 152     @SuppressWarnings(&quot;try&quot;)
 153     protected void run(StructuredGraph graph) {
 154         try (NodeEventScope scope = verifyImmutableGraph(graph)) {
 155             Instance inst = new Instance();
 156             inst.run(graph, selectedStrategy, immutableGraph);
 157         }
 158     }
 159 
 160     public static void run(StructuredGraph graph, SchedulingStrategy strategy, ControlFlowGraph cfg) {
 161         Instance inst = new Instance(cfg);
 162         inst.run(graph, strategy, false);
 163     }
 164 
 165     public static class Instance {
 166 
 167         private static final double IMPLICIT_NULL_CHECK_OPPORTUNITY_PROBABILITY_FACTOR = 2;
 168         /**
 169          * Map from blocks to the nodes in each block.
 170          */
 171         protected ControlFlowGraph cfg;
 172         protected BlockMap&lt;List&lt;Node&gt;&gt; blockToNodesMap;
 173         protected NodeMap&lt;Block&gt; nodeToBlockMap;
 174 
 175         public Instance() {
 176             this(null);
 177         }
 178 
 179         public Instance(ControlFlowGraph cfg) {
 180             this.cfg = cfg;
 181         }
 182 
 183         @SuppressWarnings(&quot;try&quot;)
 184         public void run(StructuredGraph graph, SchedulingStrategy selectedStrategy, boolean immutableGraph) {
 185             // assert GraphOrder.assertNonCyclicGraph(graph);
 186 
 187             if (this.cfg == null) {
 188                 this.cfg = ControlFlowGraph.compute(graph, true, true, true, false);
 189             }
 190 
 191             NodeMap&lt;Block&gt; currentNodeMap = graph.createNodeMap();
 192             NodeBitMap visited = graph.createNodeBitMap();
 193             BlockMap&lt;List&lt;Node&gt;&gt; earliestBlockToNodesMap = new BlockMap&lt;&gt;(cfg);
 194             this.nodeToBlockMap = currentNodeMap;
 195             this.blockToNodesMap = earliestBlockToNodesMap;
 196 
 197             scheduleEarliestIterative(earliestBlockToNodesMap, currentNodeMap, visited, graph, immutableGraph, selectedStrategy == SchedulingStrategy.EARLIEST_WITH_GUARD_ORDER);
 198 
 199             if (!selectedStrategy.isEarliest()) {
 200                 // For non-earliest schedules, we need to do a second pass.
 201                 BlockMap&lt;List&lt;Node&gt;&gt; latestBlockToNodesMap = new BlockMap&lt;&gt;(cfg);
 202                 for (Block b : cfg.getBlocks()) {
 203                     latestBlockToNodesMap.put(b, new ArrayList&lt;&gt;());
 204                 }
 205 
 206                 BlockMap&lt;ArrayList&lt;FloatingReadNode&gt;&gt; watchListMap = calcLatestBlocks(selectedStrategy, currentNodeMap, earliestBlockToNodesMap, visited, latestBlockToNodesMap, immutableGraph);
 207                 sortNodesLatestWithinBlock(cfg, earliestBlockToNodesMap, latestBlockToNodesMap, currentNodeMap, watchListMap, visited);
 208 
 209                 assert verifySchedule(cfg, latestBlockToNodesMap, currentNodeMap);
 210                 assert (!Assertions.detailedAssertionsEnabled(graph.getOptions())) ||
 211                                 ScheduleVerification.check(cfg.getStartBlock(), latestBlockToNodesMap, currentNodeMap);
 212 
 213                 this.blockToNodesMap = latestBlockToNodesMap;
 214 
 215             }
 216             cfg.setNodeToBlock(currentNodeMap);
 217 
 218             graph.setLastSchedule(new ScheduleResult(this.cfg, this.nodeToBlockMap, this.blockToNodesMap));
 219         }
 220 
 221         @SuppressFBWarnings(value = &quot;RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE&quot;, justification = &quot;false positive found by findbugs&quot;)
 222         private BlockMap&lt;ArrayList&lt;FloatingReadNode&gt;&gt; calcLatestBlocks(SchedulingStrategy strategy, NodeMap&lt;Block&gt; currentNodeMap, BlockMap&lt;List&lt;Node&gt;&gt; earliestBlockToNodesMap, NodeBitMap visited,
 223                         BlockMap&lt;List&lt;Node&gt;&gt; latestBlockToNodesMap, boolean immutableGraph) {
 224             BlockMap&lt;ArrayList&lt;FloatingReadNode&gt;&gt; watchListMap = new BlockMap&lt;&gt;(cfg);
 225             Block[] reversePostOrder = cfg.reversePostOrder();
 226             for (int j = reversePostOrder.length - 1; j &gt;= 0; --j) {
 227                 Block currentBlock = reversePostOrder[j];
 228                 List&lt;Node&gt; blockToNodes = earliestBlockToNodesMap.get(currentBlock);
 229                 LocationSet killed = null;
 230                 int previousIndex = blockToNodes.size();
 231                 for (int i = blockToNodes.size() - 1; i &gt;= 0; --i) {
 232                     Node currentNode = blockToNodes.get(i);
 233                     assert currentNodeMap.get(currentNode) == currentBlock;
 234                     assert !(currentNode instanceof PhiNode) &amp;&amp; !(currentNode instanceof ProxyNode);
 235                     assert visited.isMarked(currentNode);
 236                     if (currentNode instanceof FixedNode) {
 237                         // For these nodes, the earliest is at the same time the latest block.
 238                     } else {
 239                         Block latestBlock = null;
 240 
 241                         if (currentBlock.getFirstDominated() == null &amp;&amp; !(currentNode instanceof VirtualState)) {
 242                             // This block doesn&#39;t dominate any other blocks =&gt;
 243                             // node must be scheduled in earliest block.
 244                             latestBlock = currentBlock;
 245                         }
 246 
 247                         LocationIdentity constrainingLocation = null;
 248                         if (latestBlock == null &amp;&amp; currentNode instanceof FloatingReadNode) {
 249                             // We are scheduling a floating read node =&gt; check memory
 250                             // anti-dependencies.
 251                             FloatingReadNode floatingReadNode = (FloatingReadNode) currentNode;
 252                             LocationIdentity location = floatingReadNode.getLocationIdentity();
 253                             if (location.isMutable()) {
 254                                 // Location can be killed.
 255                                 constrainingLocation = location;
 256                                 if (currentBlock.canKill(location)) {
 257                                     if (killed == null) {
 258                                         killed = new LocationSet();
 259                                     }
 260                                     fillKillSet(killed, blockToNodes.subList(i + 1, previousIndex));
 261                                     previousIndex = i;
 262                                     if (killed.contains(location)) {
 263                                         // Earliest block kills location =&gt; we need to stay within
 264                                         // earliest block.
 265                                         latestBlock = currentBlock;
 266                                     }
 267                                 }
 268                             }
 269                         }
 270 
 271                         if (latestBlock == null) {
 272                             // We are not constraint within earliest block =&gt; calculate optimized
 273                             // schedule.
 274                             calcLatestBlock(currentBlock, strategy, currentNode, currentNodeMap, constrainingLocation, watchListMap, latestBlockToNodesMap, visited, immutableGraph);
 275                         } else {
 276                             selectLatestBlock(currentNode, currentBlock, latestBlock, currentNodeMap, watchListMap, constrainingLocation, latestBlockToNodesMap);
 277                         }
 278                     }
 279                 }
 280             }
 281             return watchListMap;
 282         }
 283 
 284         protected static void selectLatestBlock(Node currentNode, Block currentBlock, Block latestBlock, NodeMap&lt;Block&gt; currentNodeMap, BlockMap&lt;ArrayList&lt;FloatingReadNode&gt;&gt; watchListMap,
 285                         LocationIdentity constrainingLocation, BlockMap&lt;List&lt;Node&gt;&gt; latestBlockToNodesMap) {
 286 
 287             assert checkLatestEarliestRelation(currentNode, currentBlock, latestBlock);
 288             if (currentBlock != latestBlock) {
 289 
 290                 currentNodeMap.setAndGrow(currentNode, latestBlock);
 291 
 292                 if (constrainingLocation != null &amp;&amp; latestBlock.canKill(constrainingLocation)) {
 293                     if (watchListMap.get(latestBlock) == null) {
 294                         watchListMap.put(latestBlock, new ArrayList&lt;&gt;());
 295                     }
 296                     watchListMap.get(latestBlock).add((FloatingReadNode) currentNode);
 297                 }
 298             }
 299 
 300             latestBlockToNodesMap.get(latestBlock).add(currentNode);
 301         }
 302 
 303         private static boolean checkLatestEarliestRelation(Node currentNode, Block earliestBlock, Block latestBlock) {
 304             assert AbstractControlFlowGraph.dominates(earliestBlock, latestBlock) || (currentNode instanceof VirtualState &amp;&amp; latestBlock == earliestBlock.getDominator()) : String.format(
 305                             &quot;%s %s (%s) %s (%s)&quot;, currentNode, earliestBlock, earliestBlock.getBeginNode(), latestBlock, latestBlock.getBeginNode());
 306             return true;
 307         }
 308 
 309         private static boolean verifySchedule(ControlFlowGraph cfg, BlockMap&lt;List&lt;Node&gt;&gt; blockToNodesMap, NodeMap&lt;Block&gt; nodeMap) {
 310             for (Block b : cfg.getBlocks()) {
 311                 List&lt;Node&gt; nodes = blockToNodesMap.get(b);
 312                 for (Node n : nodes) {
 313                     assert n.isAlive();
 314                     assert nodeMap.get(n) == b;
 315                     StructuredGraph g = (StructuredGraph) n.graph();
 316                     if (g.hasLoops() &amp;&amp; g.getGuardsStage() == GuardsStage.AFTER_FSA &amp;&amp; n instanceof DeoptimizeNode) {
 317                         assert b.getLoopDepth() == 0 : n;
 318                     }
 319                 }
 320             }
 321             return true;
 322         }
 323 
 324         public static Block checkKillsBetween(Block earliestBlock, Block latestBlock, LocationIdentity location) {
 325             assert strictlyDominates(earliestBlock, latestBlock);
 326             Block current = latestBlock.getDominator();
 327 
 328             // Collect dominator chain that needs checking.
 329             List&lt;Block&gt; dominatorChain = new ArrayList&lt;&gt;();
 330             dominatorChain.add(latestBlock);
 331             while (current != earliestBlock) {
 332                 // Current is an intermediate dominator between earliestBlock and latestBlock.
 333                 assert strictlyDominates(earliestBlock, current) &amp;&amp; strictlyDominates(current, latestBlock);
 334                 if (current.canKill(location)) {
 335                     dominatorChain.clear();
 336                 }
 337                 dominatorChain.add(current);
 338                 current = current.getDominator();
 339             }
 340 
 341             // The first element of dominatorChain now contains the latest possible block.
 342             assert dominatorChain.size() &gt;= 1;
 343             assert dominatorChain.get(dominatorChain.size() - 1).getDominator() == earliestBlock;
 344 
 345             Block lastBlock = earliestBlock;
 346             for (int i = dominatorChain.size() - 1; i &gt;= 0; --i) {
 347                 Block currentBlock = dominatorChain.get(i);
 348                 if (currentBlock.getLoopDepth() &gt; lastBlock.getLoopDepth()) {
 349                     // We are entering a loop boundary. The new loops must not kill the location for
 350                     // the crossing to be safe.
 351                     if (currentBlock.getLoop() != null &amp;&amp; ((HIRLoop) currentBlock.getLoop()).canKill(location)) {
 352                         break;
 353                     }
 354                 }
 355 
 356                 if (currentBlock.canKillBetweenThisAndDominator(location)) {
 357                     break;
 358                 }
 359                 lastBlock = currentBlock;
 360             }
 361 
 362             if (lastBlock.getBeginNode() instanceof KillingBeginNode) {
 363                 LocationIdentity locationIdentity = ((KillingBeginNode) lastBlock.getBeginNode()).getKilledLocationIdentity();
 364                 if ((locationIdentity.isAny() || locationIdentity.equals(location)) &amp;&amp; lastBlock != earliestBlock) {
 365                     // The begin of this block kills the location, so we *have* to schedule the node
 366                     // in the dominating block.
 367                     lastBlock = lastBlock.getDominator();
 368                 }
 369             }
 370 
 371             return lastBlock;
 372         }
 373 
 374         private static void fillKillSet(LocationSet killed, List&lt;Node&gt; subList) {
 375             if (!killed.isAny()) {
 376                 for (Node n : subList) {
 377                     // Check if this node kills a node in the watch list.
 378                     if (n instanceof SingleMemoryKill) {
 379                         LocationIdentity identity = ((SingleMemoryKill) n).getKilledLocationIdentity();
 380                         killed.add(identity);
 381                         if (killed.isAny()) {
 382                             return;
 383                         }
 384                     } else if (n instanceof MultiMemoryKill) {
 385                         for (LocationIdentity identity : ((MultiMemoryKill) n).getKilledLocationIdentities()) {
 386                             killed.add(identity);
 387                             if (killed.isAny()) {
 388                                 return;
 389                             }
 390                         }
 391                     }
 392                 }
 393             }
 394         }
 395 
 396         private static void sortNodesLatestWithinBlock(ControlFlowGraph cfg, BlockMap&lt;List&lt;Node&gt;&gt; earliestBlockToNodesMap, BlockMap&lt;List&lt;Node&gt;&gt; latestBlockToNodesMap, NodeMap&lt;Block&gt; currentNodeMap,
 397                         BlockMap&lt;ArrayList&lt;FloatingReadNode&gt;&gt; watchListMap, NodeBitMap visited) {
 398             for (Block b : cfg.getBlocks()) {
 399                 sortNodesLatestWithinBlock(b, earliestBlockToNodesMap, latestBlockToNodesMap, currentNodeMap, watchListMap, visited);
 400             }
 401         }
 402 
 403         private static void sortNodesLatestWithinBlock(Block b, BlockMap&lt;List&lt;Node&gt;&gt; earliestBlockToNodesMap, BlockMap&lt;List&lt;Node&gt;&gt; latestBlockToNodesMap, NodeMap&lt;Block&gt; nodeMap,
 404                         BlockMap&lt;ArrayList&lt;FloatingReadNode&gt;&gt; watchListMap, NodeBitMap unprocessed) {
 405             List&lt;Node&gt; earliestSorting = earliestBlockToNodesMap.get(b);
 406             ArrayList&lt;Node&gt; result = new ArrayList&lt;&gt;(earliestSorting.size());
 407             ArrayList&lt;FloatingReadNode&gt; watchList = null;
 408             if (watchListMap != null) {
 409                 watchList = watchListMap.get(b);
 410                 assert watchList == null || !b.getKillLocations().isEmpty();
 411             }
 412             AbstractBeginNode beginNode = b.getBeginNode();
 413             if (beginNode instanceof LoopExitNode) {
 414                 LoopExitNode loopExitNode = (LoopExitNode) beginNode;
 415                 for (ProxyNode proxy : loopExitNode.proxies()) {
 416                     unprocessed.clear(proxy);
 417                     ValueNode value = proxy.value();
 418                     // if multiple proxies reference the same value, schedule the value of a
 419                     // proxy once
 420                     if (value != null &amp;&amp; nodeMap.get(value) == b &amp;&amp; unprocessed.isMarked(value)) {
 421                         sortIntoList(value, b, result, nodeMap, unprocessed, null);
 422                     }
 423                 }
 424             }
 425             FixedNode endNode = b.getEndNode();
 426             FixedNode fixedEndNode = null;
 427             if (isFixedEnd(endNode)) {
 428                 // Only if the end node is either a control split or an end node, we need to force
 429                 // it to be the last node in the schedule.
 430                 fixedEndNode = endNode;
 431             }
 432             for (Node n : earliestSorting) {
 433                 if (n != fixedEndNode) {
 434                     if (n instanceof FixedNode) {
 435                         assert nodeMap.get(n) == b;
 436                         checkWatchList(b, nodeMap, unprocessed, result, watchList, n);
 437                         sortIntoList(n, b, result, nodeMap, unprocessed, null);
 438                     } else if (nodeMap.get(n) == b &amp;&amp; n instanceof FloatingReadNode) {
 439                         FloatingReadNode floatingReadNode = (FloatingReadNode) n;
 440                         if (isImplicitNullOpportunity(floatingReadNode, b)) {
 441                             // Schedule at the beginning of the block.
 442                             sortIntoList(floatingReadNode, b, result, nodeMap, unprocessed, null);
 443                         } else {
 444                             LocationIdentity location = floatingReadNode.getLocationIdentity();
 445                             if (b.canKill(location)) {
 446                                 // This read can be killed in this block, add to watch list.
 447                                 if (watchList == null) {
 448                                     watchList = new ArrayList&lt;&gt;();
 449                                 }
 450                                 watchList.add(floatingReadNode);
 451                             }
 452                         }
 453                     }
 454                 }
 455             }
 456 
 457             for (Node n : latestBlockToNodesMap.get(b)) {
 458                 assert nodeMap.get(n) == b : n;
 459                 assert !(n instanceof FixedNode);
 460                 if (unprocessed.isMarked(n)) {
 461                     sortIntoList(n, b, result, nodeMap, unprocessed, fixedEndNode);
 462                 }
 463             }
 464 
 465             if (endNode != null &amp;&amp; unprocessed.isMarked(endNode)) {
 466                 sortIntoList(endNode, b, result, nodeMap, unprocessed, null);
 467             }
 468 
 469             latestBlockToNodesMap.put(b, result);
 470         }
 471 
 472         private static void checkWatchList(Block b, NodeMap&lt;Block&gt; nodeMap, NodeBitMap unprocessed, ArrayList&lt;Node&gt; result, ArrayList&lt;FloatingReadNode&gt; watchList, Node n) {
 473             if (watchList != null &amp;&amp; !watchList.isEmpty()) {
 474                 // Check if this node kills a node in the watch list.
 475                 if (n instanceof SingleMemoryKill) {
 476                     LocationIdentity identity = ((SingleMemoryKill) n).getKilledLocationIdentity();
 477                     checkWatchList(watchList, identity, b, result, nodeMap, unprocessed);
 478                 } else if (n instanceof MultiMemoryKill) {
 479                     for (LocationIdentity identity : ((MultiMemoryKill) n).getKilledLocationIdentities()) {
 480                         checkWatchList(watchList, identity, b, result, nodeMap, unprocessed);
 481                     }
 482                 }
 483             }
 484         }
 485 
 486         private static void checkWatchList(ArrayList&lt;FloatingReadNode&gt; watchList, LocationIdentity identity, Block b, ArrayList&lt;Node&gt; result, NodeMap&lt;Block&gt; nodeMap, NodeBitMap unprocessed) {
 487             if (identity.isImmutable()) {
 488                 // Nothing to do. This can happen for an initialization write.
 489             } else if (identity.isAny()) {
 490                 for (FloatingReadNode r : watchList) {
 491                     if (unprocessed.isMarked(r)) {
 492                         sortIntoList(r, b, result, nodeMap, unprocessed, null);
 493                     }
 494                 }
 495                 watchList.clear();
 496             } else {
 497                 int index = 0;
 498                 while (index &lt; watchList.size()) {
 499                     FloatingReadNode r = watchList.get(index);
 500                     LocationIdentity locationIdentity = r.getLocationIdentity();
 501                     assert locationIdentity.isMutable();
 502                     if (unprocessed.isMarked(r)) {
 503                         if (identity.overlaps(locationIdentity)) {
 504                             sortIntoList(r, b, result, nodeMap, unprocessed, null);
 505                         } else {
 506                             ++index;
 507                             continue;
 508                         }
 509                     }
 510                     int lastIndex = watchList.size() - 1;
 511                     watchList.set(index, watchList.get(lastIndex));
 512                     watchList.remove(lastIndex);
 513                 }
 514             }
 515         }
 516 
 517         private static void sortIntoList(Node n, Block b, ArrayList&lt;Node&gt; result, NodeMap&lt;Block&gt; nodeMap, NodeBitMap unprocessed, Node excludeNode) {
 518             assert unprocessed.isMarked(n) : n;
 519             assert nodeMap.get(n) == b;
 520 
 521             if (n instanceof PhiNode) {
 522                 return;
 523             }
 524 
 525             unprocessed.clear(n);
 526 
 527             for (Node input : n.inputs()) {
 528                 if (nodeMap.get(input) == b &amp;&amp; unprocessed.isMarked(input) &amp;&amp; input != excludeNode) {
 529                     sortIntoList(input, b, result, nodeMap, unprocessed, excludeNode);
 530                 }
 531             }
 532 
 533             if (n instanceof ProxyNode) {
 534                 // Skip proxy nodes.
 535             } else {
 536                 result.add(n);
 537             }
 538 
 539         }
 540 
 541         protected void calcLatestBlock(Block earliestBlock, SchedulingStrategy strategy, Node currentNode, NodeMap&lt;Block&gt; currentNodeMap, LocationIdentity constrainingLocation,
 542                         BlockMap&lt;ArrayList&lt;FloatingReadNode&gt;&gt; watchListMap, BlockMap&lt;List&lt;Node&gt;&gt; latestBlockToNodesMap, NodeBitMap visited, boolean immutableGraph) {
 543             Block latestBlock = null;
 544             if (!currentNode.hasUsages()) {
 545                 assert currentNode instanceof GuardNode;
 546                 latestBlock = earliestBlock;
 547             } else {
 548                 assert currentNode.hasUsages();
 549                 for (Node usage : currentNode.usages()) {
 550                     if (immutableGraph &amp;&amp; !visited.contains(usage)) {
 551                         /*
 552                          * Normally, dead nodes are deleted by the scheduler before we reach this
 553                          * point. Only when the scheduler is asked to not modify a graph, we can see
 554                          * dead nodes here.
 555                          */
 556                         continue;
 557                     }
 558                     latestBlock = calcBlockForUsage(currentNode, usage, latestBlock, currentNodeMap);
 559                 }
 560 
 561                 assert latestBlock != null : currentNode;
 562 
 563                 if (strategy.scheduleOutOfLoops()) {
 564                     Block currentBlock = latestBlock;
 565                     while (currentBlock.getLoopDepth() &gt; earliestBlock.getLoopDepth() &amp;&amp; currentBlock != earliestBlock.getDominator()) {
 566                         Block previousCurrentBlock = currentBlock;
 567                         currentBlock = currentBlock.getDominator();
 568                         if (previousCurrentBlock.isLoopHeader()) {
 569                             if (currentBlock.getRelativeFrequency() &lt; latestBlock.getRelativeFrequency() || ((StructuredGraph) currentNode.graph()).hasValueProxies()) {
 570                                 // Only assign new latest block if frequency is actually lower or if
 571                                 // loop proxies would be required otherwise.
 572                                 latestBlock = currentBlock;
 573                             }
 574                         }
 575                     }
 576                 }
 577 
 578                 if (latestBlock != earliestBlock &amp;&amp; latestBlock != earliestBlock.getDominator() &amp;&amp; constrainingLocation != null) {
 579                     latestBlock = checkKillsBetween(earliestBlock, latestBlock, constrainingLocation);
 580                 }
 581             }
 582 
 583             if (latestBlock != earliestBlock &amp;&amp; strategy.considerImplicitNullChecks() &amp;&amp; isImplicitNullOpportunity(currentNode, earliestBlock) &amp;&amp;
 584                             earliestBlock.getRelativeFrequency() &lt; latestBlock.getRelativeFrequency() * IMPLICIT_NULL_CHECK_OPPORTUNITY_PROBABILITY_FACTOR) {
 585                 latestBlock = earliestBlock;
 586             }
 587 
 588             selectLatestBlock(currentNode, earliestBlock, latestBlock, currentNodeMap, watchListMap, constrainingLocation, latestBlockToNodesMap);
 589         }
 590 
 591         protected static boolean isImplicitNullOpportunity(Node currentNode, Block block) {
 592             if (currentNode instanceof FloatingReadNode) {
 593                 FloatingReadNode floatingReadNode = (FloatingReadNode) currentNode;
 594                 Node pred = block.getBeginNode().predecessor();
 595                 if (pred instanceof IfNode) {
 596                     IfNode ifNode = (IfNode) pred;
 597                     if (ifNode.condition() instanceof IsNullNode &amp;&amp; ifNode.getTrueSuccessorProbability() == 0.0) {
 598                         IsNullNode isNullNode = (IsNullNode) ifNode.condition();
 599                         if (getUnproxifiedUncompressed(floatingReadNode.getAddress().getBase()) == getUnproxifiedUncompressed(isNullNode.getValue())) {
 600                             return true;
 601                         }
 602                     }
 603                 }
 604             }
 605             return false;
 606         }
 607 
 608         private static Node getUnproxifiedUncompressed(Node node) {
 609             Node result = node;
 610             while (true) {
 611                 if (result instanceof ValueProxy) {
 612                     ValueProxy valueProxy = (ValueProxy) result;
 613                     result = valueProxy.getOriginalNode();
 614                 } else if (result instanceof ConvertNode) {
 615                     ConvertNode convertNode = (ConvertNode) result;
 616                     if (convertNode.mayNullCheckSkipConversion()) {
 617                         result = convertNode.getValue();
 618                     } else {
 619                         break;
 620                     }
 621                 } else {
 622                     break;
 623                 }
 624             }
 625             return result;
 626         }
 627 
 628         private static Block calcBlockForUsage(Node node, Node usage, Block startBlock, NodeMap&lt;Block&gt; currentNodeMap) {
 629             assert !(node instanceof PhiNode);
 630             Block currentBlock = startBlock;
 631             if (usage instanceof PhiNode) {
 632                 // An input to a PhiNode is used at the end of the predecessor block that
 633                 // corresponds to the PhiNode input. One PhiNode can use an input multiple times.
 634                 PhiNode phi = (PhiNode) usage;
 635                 AbstractMergeNode merge = phi.merge();
 636                 Block mergeBlock = currentNodeMap.get(merge);
 637                 for (int i = 0; i &lt; phi.valueCount(); ++i) {
 638                     if (phi.valueAt(i) == node) {
 639                         Block otherBlock = mergeBlock.getPredecessors()[i];
 640                         currentBlock = AbstractControlFlowGraph.commonDominatorTyped(currentBlock, otherBlock);
 641                     }
 642                 }
 643             } else if (usage instanceof AbstractBeginNode) {
 644                 AbstractBeginNode abstractBeginNode = (AbstractBeginNode) usage;
 645                 if (abstractBeginNode instanceof StartNode) {
 646                     currentBlock = AbstractControlFlowGraph.commonDominatorTyped(currentBlock, currentNodeMap.get(abstractBeginNode));
 647                 } else {
 648                     Block otherBlock = currentNodeMap.get(abstractBeginNode).getDominator();
 649                     currentBlock = AbstractControlFlowGraph.commonDominatorTyped(currentBlock, otherBlock);
 650                 }
 651             } else {
 652                 // All other types of usages: Put the input into the same block as the usage.
 653                 Block otherBlock = currentNodeMap.get(usage);
 654                 if (usage instanceof ProxyNode) {
 655                     ProxyNode proxyNode = (ProxyNode) usage;
 656                     otherBlock = currentNodeMap.get(proxyNode.proxyPoint());
 657 
 658                 }
 659                 currentBlock = AbstractControlFlowGraph.commonDominatorTyped(currentBlock, otherBlock);
 660             }
 661             return currentBlock;
 662         }
 663 
 664         /**
 665          * Micro block that is allocated for each fixed node and captures all floating nodes that
 666          * need to be scheduled immediately after the corresponding fixed node.
 667          */
 668         private static class MicroBlock {
 669             private final int id;
 670             private int nodeCount;
 671             private NodeEntry head;
 672             private NodeEntry tail;
 673 
 674             MicroBlock(int id) {
 675                 this.id = id;
 676             }
 677 
 678             /**
 679              * Adds a new floating node into the micro block.
 680              */
 681             public void add(Node node) {
 682                 assert !(node instanceof FixedNode) : node;
 683                 NodeEntry newTail = new NodeEntry(node);
 684                 if (tail == null) {
 685                     tail = head = newTail;
 686                 } else {
 687                     tail.next = newTail;
 688                     tail = newTail;
 689                 }
 690                 nodeCount++;
 691             }
 692 
 693             /**
 694              * Number of nodes in this micro block.
 695              */
 696             public int getNodeCount() {
 697                 assert getActualNodeCount() == nodeCount : getActualNodeCount() + &quot; != &quot; + nodeCount;
 698                 return nodeCount;
 699             }
 700 
 701             private int getActualNodeCount() {
 702                 int count = 0;
 703                 for (NodeEntry e = head; e != null; e = e.next) {
 704                     count++;
 705                 }
 706                 return count;
 707             }
 708 
 709             /**
 710              * The id of the micro block, with a block always associated with a lower id than its
 711              * successors.
 712              */
 713             public int getId() {
 714                 return id;
 715             }
 716 
 717             /**
 718              * First node of the linked list of nodes of this micro block.
 719              */
 720             public NodeEntry getFirstNode() {
 721                 return head;
 722             }
 723 
 724             /**
 725              * Takes all nodes in this micro blocks and prepends them to the nodes of the given
 726              * parameter.
 727              *
 728              * @param newBlock the new block for the nodes
 729              */
 730             public void prependChildrenTo(MicroBlock newBlock) {
 731                 if (tail != null) {
 732                     assert head != null;
 733                     tail.next = newBlock.head;
 734                     newBlock.head = head;
 735                     head = tail = null;
 736                     newBlock.nodeCount += nodeCount;
 737                     nodeCount = 0;
 738                 }
 739             }
 740 
 741             @Override
 742             public String toString() {
 743                 return String.format(&quot;MicroBlock[id=%d]&quot;, id);
 744             }
 745 
 746             @Override
 747             public int hashCode() {
 748                 return id;
 749             }
 750         }
 751 
 752         /**
 753          * Entry in the linked list of nodes.
 754          */
 755         private static class NodeEntry {
 756             private final Node node;
 757             private NodeEntry next;
 758 
 759             NodeEntry(Node node) {
 760                 this.node = node;
 761                 this.next = null;
 762             }
 763 
 764             public NodeEntry getNext() {
 765                 return next;
 766             }
 767 
 768             public Node getNode() {
 769                 return node;
 770             }
 771         }
 772 
 773         private void scheduleEarliestIterative(BlockMap&lt;List&lt;Node&gt;&gt; blockToNodes, NodeMap&lt;Block&gt; nodeToBlock, NodeBitMap visited, StructuredGraph graph, boolean immutableGraph,
 774                         boolean withGuardOrder) {
 775 
 776             NodeMap&lt;MicroBlock&gt; entries = graph.createNodeMap();
 777             NodeStack stack = new NodeStack();
 778 
 779             // Initialize with fixed nodes.
 780             MicroBlock startBlock = null;
 781             int nextId = 1;
 782             for (Block b : cfg.reversePostOrder()) {
 783                 for (FixedNode current : b.getBeginNode().getBlockNodes()) {
 784                     MicroBlock microBlock = new MicroBlock(nextId++);
 785                     entries.set(current, microBlock);
 786                     boolean isNew = visited.checkAndMarkInc(current);
 787                     assert isNew;
 788                     if (startBlock == null) {
 789                         startBlock = microBlock;
 790                     }
 791                 }
 792             }
 793 
 794             if (graph.getGuardsStage().allowsFloatingGuards() &amp;&amp; graph.getNodes(GuardNode.TYPE).isNotEmpty()) {
 795                 // Now process guards.
 796                 if (GuardPriorities.getValue(graph.getOptions()) &amp;&amp; withGuardOrder) {
 797                     EnumMap&lt;GuardPriority, List&lt;GuardNode&gt;&gt; guardsByPriority = new EnumMap&lt;&gt;(GuardPriority.class);
 798                     for (GuardNode guard : graph.getNodes(GuardNode.TYPE)) {
 799                         guardsByPriority.computeIfAbsent(guard.computePriority(), p -&gt; new ArrayList&lt;&gt;()).add(guard);
 800                     }
 801                     // `EnumMap.values` returns values in &quot;natural&quot; key order
 802                     for (List&lt;GuardNode&gt; guards : guardsByPriority.values()) {
 803                         processNodes(visited, entries, stack, startBlock, guards);
 804                     }
 805                     GuardOrder.resortGuards(graph, entries, stack);
 806                 } else {
 807                     processNodes(visited, entries, stack, startBlock, graph.getNodes(GuardNode.TYPE));
 808                 }
 809             } else {
 810                 assert graph.getNodes(GuardNode.TYPE).isEmpty();
 811             }
 812 
 813             // Now process inputs of fixed nodes.
 814             for (Block b : cfg.reversePostOrder()) {
 815                 for (FixedNode current : b.getBeginNode().getBlockNodes()) {
 816                     processNodes(visited, entries, stack, startBlock, current.inputs());
 817                 }
 818             }
 819 
 820             if (visited.getCounter() &lt; graph.getNodeCount()) {
 821                 // Visit back input edges of loop phis.
 822                 boolean changed;
 823                 boolean unmarkedPhi;
 824                 do {
 825                     changed = false;
 826                     unmarkedPhi = false;
 827                     for (LoopBeginNode loopBegin : graph.getNodes(LoopBeginNode.TYPE)) {
 828                         for (PhiNode phi : loopBegin.phis()) {
 829                             if (visited.isMarked(phi)) {
 830                                 for (int i = 0; i &lt; loopBegin.getLoopEndCount(); ++i) {
 831                                     Node node = phi.valueAt(i + loopBegin.forwardEndCount());
 832                                     if (node != null &amp;&amp; entries.get(node) == null) {
 833                                         changed = true;
 834                                         processStack(node, startBlock, entries, visited, stack);
 835                                     }
 836                                 }
 837                             } else {
 838                                 unmarkedPhi = true;
 839                             }
 840                         }
 841                     }
 842 
 843                     /*
 844                      * the processing of one loop phi could have marked a previously checked loop
 845                      * phi, therefore this needs to be iterative.
 846                      */
 847                 } while (unmarkedPhi &amp;&amp; changed);
 848             }
 849 
 850             // Check for dead nodes.
 851             if (!immutableGraph &amp;&amp; visited.getCounter() &lt; graph.getNodeCount()) {
 852                 for (Node n : graph.getNodes()) {
 853                     if (!visited.isMarked(n)) {
 854                         n.clearInputs();
 855                         n.markDeleted();
 856                     }
 857                 }
 858             }
 859 
 860             for (Block b : cfg.reversePostOrder()) {
 861                 FixedNode fixedNode = b.getEndNode();
 862                 if (fixedNode instanceof ControlSplitNode) {
 863                     ControlSplitNode controlSplitNode = (ControlSplitNode) fixedNode;
 864                     MicroBlock endBlock = entries.get(fixedNode);
 865                     AbstractBeginNode primarySuccessor = controlSplitNode.getPrimarySuccessor();
 866                     if (primarySuccessor != null) {
 867                         endBlock.prependChildrenTo(entries.get(primarySuccessor));
 868                     } else {
 869                         assert endBlock.tail == null;
 870                     }
 871                 }
 872             }
 873 
 874             // Create lists for each block
 875             for (Block b : cfg.reversePostOrder()) {
 876                 // Count nodes in block
 877                 int totalCount = 0;
 878                 for (FixedNode current : b.getBeginNode().getBlockNodes()) {
 879                     MicroBlock microBlock = entries.get(current);
 880                     totalCount += microBlock.getNodeCount() + 1;
 881                 }
 882 
 883                 // Initialize with begin node, it is always the first node.
 884                 ArrayList&lt;Node&gt; nodes = new ArrayList&lt;&gt;(totalCount);
 885                 blockToNodes.put(b, nodes);
 886 
 887                 for (FixedNode current : b.getBeginNode().getBlockNodes()) {
 888                     MicroBlock microBlock = entries.get(current);
 889                     nodeToBlock.set(current, b);
 890                     nodes.add(current);
 891                     NodeEntry next = microBlock.getFirstNode();
 892                     while (next != null) {
 893                         Node nextNode = next.getNode();
 894                         nodeToBlock.set(nextNode, b);
 895                         nodes.add(nextNode);
 896                         next = next.getNext();
 897                     }
 898                 }
 899             }
 900 
 901             assert (!Assertions.detailedAssertionsEnabled(cfg.graph.getOptions())) || ScheduleVerification.check(cfg.getStartBlock(), blockToNodes, nodeToBlock);
 902         }
 903 
 904         private static void processNodes(NodeBitMap visited, NodeMap&lt;MicroBlock&gt; entries, NodeStack stack, MicroBlock startBlock, Iterable&lt;? extends Node&gt; nodes) {
 905             for (Node node : nodes) {
 906                 if (entries.get(node) == null) {
 907                     processStack(node, startBlock, entries, visited, stack);
 908                 }
 909             }
 910         }
 911 
 912         private static void processStackPhi(NodeStack stack, PhiNode phiNode, NodeMap&lt;MicroBlock&gt; nodeToBlock, NodeBitMap visited) {
 913             stack.pop();
 914             if (visited.checkAndMarkInc(phiNode)) {
 915                 MicroBlock mergeBlock = nodeToBlock.get(phiNode.merge());
 916                 assert mergeBlock != null : phiNode;
 917                 nodeToBlock.set(phiNode, mergeBlock);
 918                 AbstractMergeNode merge = phiNode.merge();
 919                 for (int i = 0; i &lt; merge.forwardEndCount(); ++i) {
 920                     Node input = phiNode.valueAt(i);
 921                     if (input != null &amp;&amp; nodeToBlock.get(input) == null) {
 922                         stack.push(input);
 923                     }
 924                 }
 925             }
 926         }
 927 
 928         private static void processStackProxy(NodeStack stack, ProxyNode proxyNode, NodeMap&lt;MicroBlock&gt; nodeToBlock, NodeBitMap visited) {
 929             stack.pop();
 930             if (visited.checkAndMarkInc(proxyNode)) {
 931                 nodeToBlock.set(proxyNode, nodeToBlock.get(proxyNode.proxyPoint()));
 932                 Node input = proxyNode.value();
 933                 if (input != null &amp;&amp; nodeToBlock.get(input) == null) {
 934                     stack.push(input);
 935                 }
 936             }
 937         }
 938 
 939         private static void processStack(Node first, MicroBlock startBlock, NodeMap&lt;MicroBlock&gt; nodeToMicroBlock, NodeBitMap visited, NodeStack stack) {
 940             assert stack.isEmpty();
 941             assert !visited.isMarked(first);
 942             stack.push(first);
 943             Node current = first;
 944             while (true) {
 945                 if (current instanceof PhiNode) {
 946                     processStackPhi(stack, (PhiNode) current, nodeToMicroBlock, visited);
 947                 } else if (current instanceof ProxyNode) {
 948                     processStackProxy(stack, (ProxyNode) current, nodeToMicroBlock, visited);
 949                 } else {
 950                     MicroBlock currentBlock = nodeToMicroBlock.get(current);
 951                     if (currentBlock == null) {
 952                         MicroBlock earliestBlock = processInputs(nodeToMicroBlock, stack, startBlock, current);
 953                         if (earliestBlock == null) {
 954                             // We need to delay until inputs are processed.
 955                         } else {
 956                             // Can immediately process and pop.
 957                             stack.pop();
 958                             visited.checkAndMarkInc(current);
 959                             nodeToMicroBlock.set(current, earliestBlock);
 960                             earliestBlock.add(current);
 961                         }
 962                     } else {
 963                         stack.pop();
 964                     }
 965                 }
 966 
 967                 if (stack.isEmpty()) {
 968                     break;
 969                 }
 970                 current = stack.peek();
 971             }
 972         }
 973 
 974         private static class GuardOrder {
 975             /**
 976              * After an earliest schedule, this will re-sort guards to honor their
 977              * {@linkplain StaticDeoptimizingNode#computePriority() priority}.
 978              *
 979              * Note that this only changes the order of nodes within {@linkplain MicroBlock
 980              * micro-blocks}, nodes will not be moved from one micro-block to another.
 981              */
 982             private static void resortGuards(StructuredGraph graph, NodeMap&lt;MicroBlock&gt; entries, NodeStack stack) {
 983                 assert stack.isEmpty();
 984                 EconomicSet&lt;MicroBlock&gt; blocksWithGuards = EconomicSet.create(IDENTITY);
 985                 for (GuardNode guard : graph.getNodes(GuardNode.TYPE)) {
 986                     MicroBlock block = entries.get(guard);
 987                     assert block != null : guard + &quot;should already be scheduled to a micro-block&quot;;
 988                     blocksWithGuards.add(block);
 989                 }
 990                 assert !blocksWithGuards.isEmpty();
 991                 NodeMap&lt;GuardPriority&gt; priorities = graph.createNodeMap();
 992                 NodeBitMap blockNodes = graph.createNodeBitMap();
 993                 for (MicroBlock block : blocksWithGuards) {
 994                     MicroBlock newBlock = resortGuards(block, stack, blockNodes, priorities);
 995                     assert stack.isEmpty();
 996                     assert blockNodes.isEmpty();
 997                     if (newBlock != null) {
 998                         assert block.getNodeCount() == newBlock.getNodeCount();
 999                         block.head = newBlock.head;
1000                         block.tail = newBlock.tail;
1001                     }
1002                 }
1003             }
1004 
1005             /**
1006              * This resorts guards within one micro-block.
1007              *
1008              * {@code stack}, {@code blockNodes} and {@code priorities} are just temporary
1009              * data-structures which are allocated once by the callers of this method. They should
1010              * be in their &quot;initial&quot;/&quot;empty&quot; state when calling this method and when it returns.
1011              */
1012             private static MicroBlock resortGuards(MicroBlock block, NodeStack stack, NodeBitMap blockNodes, NodeMap&lt;GuardPriority&gt; priorities) {
1013                 if (!propagatePriority(block, stack, priorities, blockNodes)) {
1014                     return null;
1015                 }
1016 
1017                 Function&lt;GuardNode, GuardPriority&gt; transitiveGuardPriorityGetter = priorities::get;
1018                 Comparator&lt;GuardNode&gt; globalGuardPriorityComparator = Comparator.comparing(transitiveGuardPriorityGetter).thenComparing(GuardNode::computePriority).thenComparingInt(Node::hashCode);
1019 
1020                 SortedSet&lt;GuardNode&gt; availableGuards = new TreeSet&lt;&gt;(globalGuardPriorityComparator);
1021                 MicroBlock newBlock = new MicroBlock(block.getId());
1022 
1023                 NodeBitMap sorted = blockNodes;
1024                 sorted.invert();
1025 
1026                 for (NodeEntry e = block.head; e != null; e = e.next) {
1027                     checkIfAvailable(e.node, stack, sorted, newBlock, availableGuards, false);
1028                 }
1029                 do {
1030                     while (!stack.isEmpty()) {
1031                         checkIfAvailable(stack.pop(), stack, sorted, newBlock, availableGuards, true);
1032                     }
1033                     Iterator&lt;GuardNode&gt; iterator = availableGuards.iterator();
1034                     if (iterator.hasNext()) {
1035                         addNodeToResort(iterator.next(), stack, sorted, newBlock, true);
1036                         iterator.remove();
1037                     }
1038                 } while (!stack.isEmpty() || !availableGuards.isEmpty());
1039 
1040                 blockNodes.clearAll();
1041                 return newBlock;
1042             }
1043 
1044             /**
1045              * This checks if {@code n} can be scheduled, if it is the case, it schedules it now by
1046              * calling {@link #addNodeToResort(Node, NodeStack, NodeBitMap, MicroBlock, boolean)}.
1047              */
1048             private static void checkIfAvailable(Node n, NodeStack stack, NodeBitMap sorted, Instance.MicroBlock newBlock, SortedSet&lt;GuardNode&gt; availableGuardNodes, boolean pushUsages) {
1049                 if (sorted.isMarked(n)) {
1050                     return;
1051                 }
1052                 for (Node in : n.inputs()) {
1053                     if (!sorted.isMarked(in)) {
1054                         return;
1055                     }
1056                 }
1057                 if (n instanceof GuardNode) {
1058                     availableGuardNodes.add((GuardNode) n);
1059                 } else {
1060                     addNodeToResort(n, stack, sorted, newBlock, pushUsages);
1061                 }
1062             }
1063 
1064             /**
1065              * Add a node to the re-sorted micro-block. This also pushes nodes that need to be
1066              * (re-)examined on the stack.
1067              */
1068             private static void addNodeToResort(Node n, NodeStack stack, NodeBitMap sorted, MicroBlock newBlock, boolean pushUsages) {
1069                 sorted.mark(n);
1070                 newBlock.add(n);
1071                 if (pushUsages) {
1072                     for (Node u : n.usages()) {
1073                         if (!sorted.isMarked(u)) {
1074                             stack.push(u);
1075                         }
1076                     }
1077                 }
1078             }
1079 
1080             /**
1081              * This fills in a map of transitive priorities ({@code priorities}). It also marks the
1082              * nodes from this micro-block in {@code blockNodes}.
1083              *
1084              * The transitive priority of a guard is the highest of its priority and the priority of
1085              * the guards that depend on it (transitively).
1086              *
1087              * This method returns {@code false} if no re-ordering is necessary in this micro-block.
1088              */
1089             private static boolean propagatePriority(MicroBlock block, NodeStack stack, NodeMap&lt;GuardPriority&gt; priorities, NodeBitMap blockNodes) {
1090                 assert stack.isEmpty();
1091                 assert blockNodes.isEmpty();
1092                 GuardPriority lowestPriority = GuardPriority.highest();
1093                 for (NodeEntry e = block.head; e != null; e = e.next) {
1094                     blockNodes.mark(e.node);
1095                     if (e.node instanceof GuardNode) {
1096                         GuardNode guard = (GuardNode) e.node;
1097                         GuardPriority priority = guard.computePriority();
1098                         if (lowestPriority != null) {
1099                             if (priority.isLowerPriorityThan(lowestPriority)) {
1100                                 lowestPriority = priority;
1101                             } else if (priority.isHigherPriorityThan(lowestPriority)) {
1102                                 lowestPriority = null;
1103                             }
1104                         }
1105                         stack.push(guard);
1106                         priorities.set(guard, priority);
1107                     }
1108                 }
1109                 if (lowestPriority != null) {
1110                     stack.clear();
1111                     blockNodes.clearAll();
1112                     return false;
1113                 }
1114 
1115                 do {
1116                     Node current = stack.pop();
1117                     assert blockNodes.isMarked(current);
1118                     GuardPriority priority = priorities.get(current);
1119                     for (Node input : current.inputs()) {
1120                         if (!blockNodes.isMarked(input)) {
1121                             continue;
1122                         }
1123                         GuardPriority inputPriority = priorities.get(input);
1124                         if (inputPriority == null || inputPriority.isLowerPriorityThan(priority)) {
1125                             priorities.set(input, priority);
1126                             stack.push(input);
1127                         }
1128                     }
1129                 } while (!stack.isEmpty());
1130                 return true;
1131             }
1132         }
1133 
1134         /**
1135          * Processes the inputs of given block. Pushes unprocessed inputs onto the stack. Returns
1136          * null if there were still unprocessed inputs, otherwise returns the earliest block given
1137          * node can be scheduled in.
1138          */
1139         private static MicroBlock processInputs(NodeMap&lt;MicroBlock&gt; nodeToBlock, NodeStack stack, MicroBlock startBlock, Node current) {
1140             if (current.getNodeClass().isLeafNode()) {
1141                 return startBlock;
1142             }
1143 
1144             MicroBlock earliestBlock = startBlock;
1145             for (Node input : current.inputs()) {
1146                 MicroBlock inputBlock = nodeToBlock.get(input);
1147                 if (inputBlock == null) {
1148                     earliestBlock = null;
1149                     stack.push(input);
1150                 } else if (earliestBlock != null &amp;&amp; inputBlock.getId() &gt; earliestBlock.getId()) {
1151                     earliestBlock = inputBlock;
1152                 }
1153             }
1154             return earliestBlock;
1155         }
1156 
1157         private static boolean isFixedEnd(FixedNode endNode) {
1158             return endNode instanceof ControlSplitNode || endNode instanceof ControlSinkNode || endNode instanceof AbstractEndNode;
1159         }
1160 
1161         public String printScheduleHelper(String desc) {
1162             Formatter buf = new Formatter();
1163             buf.format(&quot;=== %s / %s ===%n&quot;, getCFG().getStartBlock().getBeginNode().graph(), desc);
1164             for (Block b : getCFG().getBlocks()) {
1165                 buf.format(&quot;==== b: %s (loopDepth: %s). &quot;, b, b.getLoopDepth());
1166                 buf.format(&quot;dom: %s. &quot;, b.getDominator());
1167                 buf.format(&quot;preds: %s. &quot;, Arrays.toString(b.getPredecessors()));
1168                 buf.format(&quot;succs: %s ====%n&quot;, Arrays.toString(b.getSuccessors()));
1169 
1170                 if (blockToNodesMap.get(b) != null) {
1171                     for (Node n : nodesFor(b)) {
1172                         printNode(n);
1173                     }
1174                 } else {
1175                     for (Node n : b.getNodes()) {
1176                         printNode(n);
1177                     }
1178                 }
1179             }
1180             buf.format(&quot;%n&quot;);
1181             return buf.toString();
1182         }
1183 
1184         private static void printNode(Node n) {
1185             Formatter buf = new Formatter();
1186             buf.format(&quot;%s&quot;, n);
1187             if (n instanceof SingleMemoryKill) {
1188                 buf.format(&quot; // kills %s&quot;, ((SingleMemoryKill) n).getKilledLocationIdentity());
1189             } else if (n instanceof MultiMemoryKill) {
1190                 buf.format(&quot; // kills &quot;);
1191                 for (LocationIdentity locid : ((MultiMemoryKill) n).getKilledLocationIdentities()) {
1192                     buf.format(&quot;%s, &quot;, locid);
1193                 }
1194             } else if (n instanceof FloatingReadNode) {
1195                 FloatingReadNode frn = (FloatingReadNode) n;
1196                 buf.format(&quot; // from %s&quot;, frn.getLocationIdentity());
1197                 buf.format(&quot;, lastAccess: %s&quot;, frn.getLastLocationAccess());
1198                 buf.format(&quot;, address: %s&quot;, frn.getAddress());
1199             } else if (n instanceof GuardNode) {
1200                 buf.format(&quot;, anchor: %s&quot;, ((GuardNode) n).getAnchor());
1201             }
1202             n.getDebug().log(&quot;%s&quot;, buf);
1203         }
1204 
1205         public ControlFlowGraph getCFG() {
1206             return cfg;
1207         }
1208 
1209         /**
1210          * Gets the nodes in a given block.
1211          */
1212         public List&lt;Node&gt; nodesFor(Block block) {
1213             return blockToNodesMap.get(block);
1214         }
1215     }
1216 
1217 }
    </pre>
  </body>
</html>
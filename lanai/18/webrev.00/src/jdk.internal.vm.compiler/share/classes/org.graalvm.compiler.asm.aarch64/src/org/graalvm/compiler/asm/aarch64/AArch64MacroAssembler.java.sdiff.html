<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.aarch64/src/org/graalvm/compiler/asm/aarch64/AArch64MacroAssembler.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AArch64Assembler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../org.graalvm.compiler.asm.amd64/src/org/graalvm/compiler/asm/amd64/AMD64Address.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.aarch64/src/org/graalvm/compiler/asm/aarch64/AArch64MacroAssembler.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  26 package org.graalvm.compiler.asm.aarch64;
  27 
  28 import static jdk.vm.ci.aarch64.AArch64.CPU;
  29 import static jdk.vm.ci.aarch64.AArch64.rscratch1;
  30 import static jdk.vm.ci.aarch64.AArch64.rscratch2;
  31 import static jdk.vm.ci.aarch64.AArch64.sp;
  32 import static jdk.vm.ci.aarch64.AArch64.zr;
  33 import static org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode.BASE_REGISTER_ONLY;
  34 import static org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode.EXTENDED_REGISTER_OFFSET;
  35 import static org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode.IMMEDIATE_SCALED;
  36 import static org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode.IMMEDIATE_UNSCALED;
  37 import static org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode.REGISTER_OFFSET;
  38 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDP;
  39 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.STP;
  40 import static org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.AddressGenerationPlan.WorkPlan.ADD_TO_BASE;
  41 import static org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.AddressGenerationPlan.WorkPlan.ADD_TO_INDEX;
  42 import static org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.AddressGenerationPlan.WorkPlan.NO_WORK;
  43 
  44 import org.graalvm.compiler.asm.BranchTargetOutOfBoundsException;
  45 import org.graalvm.compiler.asm.Label;

  46 import org.graalvm.compiler.core.common.NumUtil;
  47 import org.graalvm.compiler.debug.GraalError;
  48 
  49 import jdk.vm.ci.aarch64.AArch64;
  50 import jdk.vm.ci.code.Register;
  51 import jdk.vm.ci.code.TargetDescription;
  52 
  53 public class AArch64MacroAssembler extends AArch64Assembler {
  54 
  55     private final ScratchRegister[] scratchRegister = new ScratchRegister[]{new ScratchRegister(rscratch1), new ScratchRegister(rscratch2)};
  56 
  57     // Points to the next free scratch register
  58     private int nextFreeScratchRegister = 0;
  59 
  60     // Last immediate ldr/str instruction, which is a candidate to be merged.
  61     private AArch64MemoryEncoding lastImmLoadStoreEncoding;
  62     private boolean isImmLoadStoreMerged = false;
  63 
  64     public AArch64MacroAssembler(TargetDescription target) {
  65         super(target);
</pre>
<hr />
<pre>
 485         }
 486         return false;
 487     }
 488 
 489     public boolean isImmLoadStoreMerged() {
 490         return isImmLoadStoreMerged;
 491     }
 492 
 493     public void movx(Register dst, Register src) {
 494         mov(64, dst, src);
 495     }
 496 
 497     public void mov(int size, Register dst, Register src) {
 498         if (dst.equals(sp) || src.equals(sp)) {
 499             add(size, dst, src, 0);
 500         } else {
 501             or(size, dst, zr, src);
 502         }
 503     }
 504 








































 505     /**
 506      * Generates a 64-bit immediate move code sequence.
 507      *
 508      * @param dst general purpose register. May not be null, stackpointer or zero-register.
 509      * @param imm the value to move into the register
<span class="line-modified"> 510      * @param annotateImm Flag denoting if annotation should be added.</span>
 511      */
<span class="line-modified"> 512     private void mov64(Register dst, long imm, boolean annotateImm) {</span>
<span class="line-modified"> 513         // We have to move all non zero parts of the immediate in 16-bit chunks</span>
<span class="line-removed"> 514         int numMovs = 0;</span>
 515         int pos = position();
<span class="line-modified"> 516         boolean firstMove = true;</span>
<span class="line-modified"> 517         for (int offset = 0; offset &lt; 64; offset += 16) {</span>
<span class="line-modified"> 518             int chunk = (int) (imm &gt;&gt; offset) &amp; NumUtil.getNbitNumberInt(16);</span>




 519             if (chunk == 0) {
<span class="line-modified"> 520                 continue;</span>


 521             }
<span class="line-modified"> 522             if (firstMove) {</span>
<span class="line-modified"> 523                 movz(64, dst, chunk, offset);</span>
<span class="line-modified"> 524                 firstMove = false;</span>
<span class="line-modified"> 525             } else {</span>
<span class="line-modified"> 526                 movk(64, dst, chunk, offset);</span>




































































 527             }
<span class="line-modified"> 528             ++numMovs;</span>





































 529         }
<span class="line-modified"> 530         assert !firstMove;</span>
<span class="line-modified"> 531         if (annotateImm) {</span>
<span class="line-removed"> 532             annotateImmediateMovSequence(pos, numMovs);</span>
 533         }
 534     }
 535 










 536     /**
 537      * Loads immediate into register.
 538      *
 539      * @param dst general purpose register. May not be null, zero-register or stackpointer.
 540      * @param imm immediate loaded into register.
 541      */
 542     public void mov(Register dst, long imm) {
 543         mov(dst, imm, false);
 544     }
 545 
 546     /**
 547      * Loads immediate into register.
 548      *
 549      * @param dst general purpose register. May not be null, zero-register or stackpointer.
 550      * @param imm immediate loaded into register.
<span class="line-modified"> 551      * @param annotateImm Flag to signal of the immediate value should be annotated.</span>
 552      */
<span class="line-modified"> 553     public void mov(Register dst, long imm, boolean annotateImm) {</span>

















 554         assert dst.getRegisterCategory().equals(CPU);
 555         if (imm == 0L) {
 556             movx(dst, zr);
<span class="line-modified"> 557         } else if (LogicalImmediateTable.isRepresentable(true, imm) != LogicalImmediateTable.Representable.NO) {</span>
 558             or(64, dst, zr, imm);
 559         } else if (imm &gt;&gt; 32 == -1L &amp;&amp; (int) imm &lt; 0 &amp;&amp; LogicalImmediateTable.isRepresentable((int) imm) != LogicalImmediateTable.Representable.NO) {
 560             // If the higher 32-bit are 1s and the sign bit of the lower 32-bits is set *and* we can
 561             // represent the lower 32 bits as a logical immediate we can create the lower 32-bit and
 562             // then sign extend
 563             // them. This allows us to cover immediates like ~1L with 2 instructions.
 564             mov(dst, (int) imm);
 565             sxt(64, 32, dst, dst);
 566         } else {
<span class="line-modified"> 567             mov64(dst, imm, annotateImm);</span>
 568         }
 569     }
 570 
<span class="line-removed"> 571     /**</span>
<span class="line-removed"> 572      * Loads immediate into register.</span>
<span class="line-removed"> 573      *</span>
<span class="line-removed"> 574      * @param dst general purpose register. May not be null, zero-register or stackpointer.</span>
<span class="line-removed"> 575      * @param imm immediate loaded into register.</span>
<span class="line-removed"> 576      */</span>
<span class="line-removed"> 577     public void mov(Register dst, int imm) {</span>
<span class="line-removed"> 578         mov(dst, imm &amp; 0xFFFF_FFFFL);</span>
<span class="line-removed"> 579     }</span>
<span class="line-removed"> 580 </span>
 581     /**
 582      * Generates a 48-bit immediate move code sequence. The immediate may later be updated by
 583      * HotSpot.
 584      *
 585      * In AArch64 mode the virtual address space is 48-bits in size, so we only need three
 586      * instructions to create a patchable instruction sequence that can reach anywhere.
 587      *
 588      * @param dst general purpose register. May not be null, stackpointer or zero-register.
 589      * @param imm
 590      */
 591     public void movNativeAddress(Register dst, long imm) {
 592         movNativeAddress(dst, imm, false);
 593     }
 594 
 595     /**
 596      * Generates a 48-bit immediate move code sequence. The immediate may later be updated by
 597      * HotSpot.
 598      *
 599      * In AArch64 mode the virtual address space is 48-bits in size, so we only need three
 600      * instructions to create a patchable instruction sequence that can reach anywhere.
 601      *
 602      * @param dst general purpose register. May not be null, stackpointer or zero-register.
 603      * @param imm The immediate address
<span class="line-modified"> 604      * @param annotateImm Flag to signal of the immediate value should be annotated.</span>
 605      */
<span class="line-modified"> 606     public void movNativeAddress(Register dst, long imm, boolean annotateImm) {</span>
 607         assert (imm &amp; 0xFFFF_0000_0000_0000L) == 0;
 608         // We have to move all non zero parts of the immediate in 16-bit chunks
 609         boolean firstMove = true;
 610         int pos = position();
 611         for (int offset = 0; offset &lt; 48; offset += 16) {
 612             int chunk = (int) (imm &gt;&gt; offset) &amp; NumUtil.getNbitNumberInt(16);
 613             if (firstMove) {
 614                 movz(64, dst, chunk, offset);
 615                 firstMove = false;
 616             } else {
 617                 movk(64, dst, chunk, offset);
 618             }
 619         }
<span class="line-modified"> 620         if (annotateImm) {</span>
<span class="line-modified"> 621             annotateImmediateMovSequence(pos, 3);</span>

 622         }
 623         assert !firstMove;
 624     }
 625 
 626     /**
 627      * Generates a 32-bit immediate move code sequence. The immediate may later be updated by
 628      * HotSpot.
 629      *
 630      * @param dst general purpose register. May not be null, stackpointer or zero-register.
 631      * @param imm
 632      */
 633     public void movNarrowAddress(Register dst, long imm) {
 634         assert (imm &amp; 0xFFFF_FFFF_0000_0000L) == 0;
 635         movz(64, dst, (int) (imm &gt;&gt;&gt; 16), 16);
 636         movk(64, dst, (int) (imm &amp; 0xffff), 0);
 637     }
 638 
 639     /**
 640      * @return Number of instructions necessary to load immediate into register.
 641      */
</pre>
<hr />
<pre>
1242      * @param src general purpose register. May not be null, stackpointer or zero-register.
1243      * @param shiftAmt amount by which src is shifted.
1244      */
1245     public void ashr(int size, Register dst, Register src, long shiftAmt) {
1246         int shift = clampShiftAmt(size, shiftAmt);
1247         super.sbfm(size, dst, src, shift, size - 1);
1248     }
1249 
1250     /**
1251      * dst = src1 &gt;&gt; (src2 &amp; log2(size)).
1252      *
1253      * @param size register size. Has to be 32 or 64.
1254      * @param dst general purpose register. May not be null or stackpointer.
1255      * @param src general purpose register. May not be null or stackpointer.
1256      * @param shift general purpose register. May not be null or stackpointer.
1257      */
1258     public void ashr(int size, Register dst, Register src, Register shift) {
1259         super.asr(size, dst, src, shift);
1260     }
1261 




























1262     /**
1263      * Clamps shiftAmt into range 0 &lt;= shiftamt &lt; size according to JLS.
1264      *
1265      * @param size size of operation.
1266      * @param shiftAmt arbitrary shift amount.
1267      * @return value between 0 and size - 1 inclusive that is equivalent to shiftAmt according to
1268      *         JLS.
1269      */
1270     private static int clampShiftAmt(int size, long shiftAmt) {
1271         return (int) (shiftAmt &amp; (size - 1));
1272     }
1273 
1274     /**
1275      * dst = src1 &amp; src2.
1276      *
1277      * @param size register size. Has to be 32 or 64.
1278      * @param dst general purpose register. May not be null or stackpointer.
1279      * @param src1 general purpose register. May not be null or stackpointer.
1280      * @param src2 general purpose register. May not be null or stackpointer.
1281      */
</pre>
<hr />
<pre>
1303      * @param src1 general purpose register. May not be null or stackpointer.
1304      * @param src2 general purpose register. May not be null or stackpointer.
1305      */
1306     public void or(int size, Register dst, Register src1, Register src2) {
1307         super.orr(size, dst, src1, src2, ShiftType.LSL, 0);
1308     }
1309 
1310     /**
1311      * dst = src | bimm.
1312      *
1313      * @param size register size. Has to be 32 or 64.
1314      * @param dst general purpose register. May not be null or zero-register.
1315      * @param src general purpose register. May not be null or stack-pointer.
1316      * @param bimm logical immediate. See {@link AArch64Assembler.LogicalImmediateTable} for exact
1317      *            definition.
1318      */
1319     public void or(int size, Register dst, Register src, long bimm) {
1320         super.orr(size, dst, src, bimm);
1321     }
1322 




































1323     /**
1324      * dst = ~src.
1325      *
1326      * @param size register size. Has to be 32 or 64.
1327      * @param dst general purpose register. May not be null or stackpointer.
1328      * @param src general purpose register. May not be null or stackpointer.
1329      */
1330     public void not(int size, Register dst, Register src) {
1331         super.orn(size, dst, zr, src, ShiftType.LSL, 0);
1332     }
1333 
1334     /**
1335      * dst = src1 &amp; shiftType(src2, imm).
1336      *
1337      * @param size register size. Has to be 32 or 64.
1338      * @param dst general purpose register. May not be null or stackpointer.
1339      * @param src1 general purpose register. May not be null or stackpointer.
1340      * @param src2 general purpose register. May not be null or stackpointer.
1341      * @param shiftType all types allowed, may not be null.
1342      * @param shiftAmt must be in range 0 to size - 1.
</pre>
<hr />
<pre>
2042         a.lea(this, d);
2043     }
2044 
2045     /**
2046      * Count the set bits of src register.
2047      *
2048      * @param size src register size. Has to be 32 or 64.
2049      * @param dst general purpose register. Should not be null or zero-register.
2050      * @param src general purpose register. Should not be null.
2051      * @param vreg SIMD register. Should not be null.
2052      */
2053     public void popcnt(int size, Register dst, Register src, Register vreg) {
2054         assert 32 == size || 64 == size : &quot;Invalid data size&quot;;
2055         fmov(size, vreg, src);
2056         final int fixedSize = 64;
2057         cnt(fixedSize, vreg, vreg);
2058         addv(fixedSize, SIMDElementSize.Byte, vreg, vreg);
2059         umov(fixedSize, dst, 0, vreg);
2060     }
2061 
<span class="line-removed">2062     public interface MacroInstruction {</span>
<span class="line-removed">2063         void patch(int codePos, int relative, byte[] code);</span>
<span class="line-removed">2064     }</span>
<span class="line-removed">2065 </span>
2066     /**
2067      * Emits elf patchable adrp ldr sequence.
2068      */
2069     public void adrpLdr(int srcSize, Register result, AArch64Address a) {
2070         if (codePatchingAnnotationConsumer != null) {
<span class="line-modified">2071             codePatchingAnnotationConsumer.accept(new AdrpLdrMacroInstruction(position()));</span>
2072         }
2073         super.adrp(a.getBase());
2074         this.ldr(srcSize, result, a);
2075     }
2076 
<span class="line-modified">2077     public static class AdrpLdrMacroInstruction extends CodeAnnotation implements MacroInstruction {</span>
<span class="line-modified">2078         public AdrpLdrMacroInstruction(int position) {</span>


2079             super(position);

2080         }
2081 
2082         @Override
2083         public String toString() {
2084             return &quot;ADRP_LDR&quot;;
2085         }
2086 
2087         @Override
2088         public void patch(int codePos, int relative, byte[] code) {
<span class="line-modified">2089             throw GraalError.unimplemented();</span>







































2090         }
2091     }
2092 
<span class="line-modified">2093     public static class AdrpAddMacroInstruction extends CodeAnnotation implements MacroInstruction {</span>
2094         public AdrpAddMacroInstruction(int position) {
2095             super(position);
2096         }
2097 
2098         @Override
2099         public String toString() {
2100             return &quot;ADRP_ADD&quot;;
2101         }
2102 
2103         @Override
2104         public void patch(int codePos, int relative, byte[] code) {
<span class="line-modified">2105             throw GraalError.unimplemented();</span>























































































2106         }
2107     }
2108 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  26 package org.graalvm.compiler.asm.aarch64;
  27 
  28 import static jdk.vm.ci.aarch64.AArch64.CPU;
  29 import static jdk.vm.ci.aarch64.AArch64.rscratch1;
  30 import static jdk.vm.ci.aarch64.AArch64.rscratch2;
  31 import static jdk.vm.ci.aarch64.AArch64.sp;
  32 import static jdk.vm.ci.aarch64.AArch64.zr;
  33 import static org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode.BASE_REGISTER_ONLY;
  34 import static org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode.EXTENDED_REGISTER_OFFSET;
  35 import static org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode.IMMEDIATE_SCALED;
  36 import static org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode.IMMEDIATE_UNSCALED;
  37 import static org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode.REGISTER_OFFSET;
  38 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDP;
  39 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.STP;
  40 import static org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.AddressGenerationPlan.WorkPlan.ADD_TO_BASE;
  41 import static org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.AddressGenerationPlan.WorkPlan.ADD_TO_INDEX;
  42 import static org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.AddressGenerationPlan.WorkPlan.NO_WORK;
  43 
  44 import org.graalvm.compiler.asm.BranchTargetOutOfBoundsException;
  45 import org.graalvm.compiler.asm.Label;
<span class="line-added">  46 import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.MovSequenceAnnotation.MovAction;</span>
  47 import org.graalvm.compiler.core.common.NumUtil;
  48 import org.graalvm.compiler.debug.GraalError;
  49 
  50 import jdk.vm.ci.aarch64.AArch64;
  51 import jdk.vm.ci.code.Register;
  52 import jdk.vm.ci.code.TargetDescription;
  53 
  54 public class AArch64MacroAssembler extends AArch64Assembler {
  55 
  56     private final ScratchRegister[] scratchRegister = new ScratchRegister[]{new ScratchRegister(rscratch1), new ScratchRegister(rscratch2)};
  57 
  58     // Points to the next free scratch register
  59     private int nextFreeScratchRegister = 0;
  60 
  61     // Last immediate ldr/str instruction, which is a candidate to be merged.
  62     private AArch64MemoryEncoding lastImmLoadStoreEncoding;
  63     private boolean isImmLoadStoreMerged = false;
  64 
  65     public AArch64MacroAssembler(TargetDescription target) {
  66         super(target);
</pre>
<hr />
<pre>
 486         }
 487         return false;
 488     }
 489 
 490     public boolean isImmLoadStoreMerged() {
 491         return isImmLoadStoreMerged;
 492     }
 493 
 494     public void movx(Register dst, Register src) {
 495         mov(64, dst, src);
 496     }
 497 
 498     public void mov(int size, Register dst, Register src) {
 499         if (dst.equals(sp) || src.equals(sp)) {
 500             add(size, dst, src, 0);
 501         } else {
 502             or(size, dst, zr, src);
 503         }
 504     }
 505 
<span class="line-added"> 506     /**</span>
<span class="line-added"> 507      * Generates a 32-bit immediate move code sequence.</span>
<span class="line-added"> 508      *</span>
<span class="line-added"> 509      * @param dst general purpose register. May not be null, stackpointer or zero-register.</span>
<span class="line-added"> 510      * @param imm the value to move into the register.</span>
<span class="line-added"> 511      * @param needsImmAnnotation Flag denoting if annotation should be added.</span>
<span class="line-added"> 512      */</span>
<span class="line-added"> 513     private void mov32(Register dst, int imm, boolean needsImmAnnotation) {</span>
<span class="line-added"> 514         MovAction[] includeSet = {MovAction.SKIPPED, MovAction.SKIPPED};</span>
<span class="line-added"> 515         int pos = position();</span>
<span class="line-added"> 516 </span>
<span class="line-added"> 517         // Split 32-bit imm into low16 and high16 parts.</span>
<span class="line-added"> 518         int low16 = imm &amp; 0xFFFF;</span>
<span class="line-added"> 519         int high16 = (imm &gt;&gt;&gt; 16) &amp; 0xFFFF;</span>
<span class="line-added"> 520 </span>
<span class="line-added"> 521         // Generate code sequence with a combination of MOVZ or MOVN with MOVK.</span>
<span class="line-added"> 522         if (high16 == 0) {</span>
<span class="line-added"> 523             movz(32, dst, low16, 0);</span>
<span class="line-added"> 524             includeSet[0] = MovAction.USED;</span>
<span class="line-added"> 525         } else if (high16 == 0xFFFF) {</span>
<span class="line-added"> 526             movn(32, dst, low16 ^ 0xFFFF, 0);</span>
<span class="line-added"> 527             includeSet[0] = MovAction.NEGATED;</span>
<span class="line-added"> 528         } else if (low16 == 0) {</span>
<span class="line-added"> 529             movz(32, dst, high16, 16);</span>
<span class="line-added"> 530             includeSet[1] = MovAction.USED;</span>
<span class="line-added"> 531         } else if (low16 == 0xFFFF) {</span>
<span class="line-added"> 532             movn(32, dst, high16 ^ 0xFFFF, 16);</span>
<span class="line-added"> 533             includeSet[1] = MovAction.NEGATED;</span>
<span class="line-added"> 534         } else {</span>
<span class="line-added"> 535             // Neither of the 2 parts is all-0s or all-1s. Generate 2 instructions.</span>
<span class="line-added"> 536             movz(32, dst, low16, 0);</span>
<span class="line-added"> 537             movk(32, dst, high16, 16);</span>
<span class="line-added"> 538             includeSet[0] = MovAction.USED;</span>
<span class="line-added"> 539             includeSet[1] = MovAction.USED;</span>
<span class="line-added"> 540         }</span>
<span class="line-added"> 541         if (needsImmAnnotation) {</span>
<span class="line-added"> 542             annotateImmediateMovSequence(pos, includeSet);</span>
<span class="line-added"> 543         }</span>
<span class="line-added"> 544     }</span>
<span class="line-added"> 545 </span>
 546     /**
 547      * Generates a 64-bit immediate move code sequence.
 548      *
 549      * @param dst general purpose register. May not be null, stackpointer or zero-register.
 550      * @param imm the value to move into the register
<span class="line-modified"> 551      * @param needsImmAnnotation Flag denoting if annotation should be added.</span>
 552      */
<span class="line-modified"> 553     private void mov64(Register dst, long imm, boolean needsImmAnnotation) {</span>
<span class="line-modified"> 554         MovAction[] includeSet = {MovAction.SKIPPED, MovAction.SKIPPED, MovAction.SKIPPED, MovAction.SKIPPED};</span>

 555         int pos = position();
<span class="line-modified"> 556         int[] chunks = new int[4];</span>
<span class="line-modified"> 557         int zeroCount = 0;</span>
<span class="line-modified"> 558         int negCount = 0;</span>
<span class="line-added"> 559 </span>
<span class="line-added"> 560         // Split 64-bit imm into 4 chunks and count the numbers of all-0 and all-1 chunks.</span>
<span class="line-added"> 561         for (int i = 0; i &lt; 4; i++) {</span>
<span class="line-added"> 562             int chunk = (int) ((imm &gt;&gt;&gt; (i * 16)) &amp; 0xFFFFL);</span>
 563             if (chunk == 0) {
<span class="line-modified"> 564                 zeroCount++;</span>
<span class="line-added"> 565             } else if (chunk == 0xFFFF) {</span>
<span class="line-added"> 566                 negCount++;</span>
 567             }
<span class="line-modified"> 568             chunks[i] = chunk;</span>
<span class="line-modified"> 569         }</span>
<span class="line-modified"> 570 </span>
<span class="line-modified"> 571         // Generate code sequence with a combination of MOVZ or MOVN with MOVK.</span>
<span class="line-modified"> 572         if (zeroCount == 4) {</span>
<span class="line-added"> 573             // Generate only one MOVZ.</span>
<span class="line-added"> 574             movz(64, dst, 0, 0);</span>
<span class="line-added"> 575             includeSet[0] = MovAction.USED;</span>
<span class="line-added"> 576         } else if (negCount == 4) {</span>
<span class="line-added"> 577             // Generate only one MOVN.</span>
<span class="line-added"> 578             movn(64, dst, 0, 0);</span>
<span class="line-added"> 579             includeSet[0] = MovAction.NEGATED;</span>
<span class="line-added"> 580         } else if (zeroCount == 3) {</span>
<span class="line-added"> 581             // Generate only one MOVZ.</span>
<span class="line-added"> 582             for (int i = 0; i &lt; 4; i++) {</span>
<span class="line-added"> 583                 if (chunks[i] != 0) {</span>
<span class="line-added"> 584                     movz(64, dst, chunks[i], i * 16);</span>
<span class="line-added"> 585                     includeSet[i] = MovAction.USED;</span>
<span class="line-added"> 586                     break;</span>
<span class="line-added"> 587                 }</span>
<span class="line-added"> 588             }</span>
<span class="line-added"> 589         } else if (negCount == 3) {</span>
<span class="line-added"> 590             // Generate only one MOVN.</span>
<span class="line-added"> 591             for (int i = 0; i &lt; 4; i++) {</span>
<span class="line-added"> 592                 if (chunks[i] != 0xFFFF) {</span>
<span class="line-added"> 593                     movn(64, dst, chunks[i] ^ 0xFFFF, i * 16);</span>
<span class="line-added"> 594                     includeSet[i] = MovAction.NEGATED;</span>
<span class="line-added"> 595                     break;</span>
<span class="line-added"> 596                 }</span>
<span class="line-added"> 597             }</span>
<span class="line-added"> 598         } else if (zeroCount == 2) {</span>
<span class="line-added"> 599             // Generate one MOVZ and one MOVK.</span>
<span class="line-added"> 600             int i;</span>
<span class="line-added"> 601             for (i = 0; i &lt; 4; i++) {</span>
<span class="line-added"> 602                 if (chunks[i] != 0) {</span>
<span class="line-added"> 603                     movz(64, dst, chunks[i], i * 16);</span>
<span class="line-added"> 604                     includeSet[i] = MovAction.USED;</span>
<span class="line-added"> 605                     break;</span>
<span class="line-added"> 606                 }</span>
<span class="line-added"> 607             }</span>
<span class="line-added"> 608             for (int k = i + 1; k &lt; 4; k++) {</span>
<span class="line-added"> 609                 if (chunks[k] != 0) {</span>
<span class="line-added"> 610                     movk(64, dst, chunks[k], k * 16);</span>
<span class="line-added"> 611                     includeSet[k] = MovAction.USED;</span>
<span class="line-added"> 612                     break;</span>
<span class="line-added"> 613                 }</span>
<span class="line-added"> 614             }</span>
<span class="line-added"> 615         } else if (negCount == 2) {</span>
<span class="line-added"> 616             // Generate one MOVN and one MOVK.</span>
<span class="line-added"> 617             int i;</span>
<span class="line-added"> 618             for (i = 0; i &lt; 4; i++) {</span>
<span class="line-added"> 619                 if (chunks[i] != 0xFFFF) {</span>
<span class="line-added"> 620                     movn(64, dst, chunks[i] ^ 0xFFFF, i * 16);</span>
<span class="line-added"> 621                     includeSet[i] = MovAction.NEGATED;</span>
<span class="line-added"> 622                     break;</span>
<span class="line-added"> 623                 }</span>
<span class="line-added"> 624             }</span>
<span class="line-added"> 625             for (int k = i + 1; k &lt; 4; k++) {</span>
<span class="line-added"> 626                 if (chunks[k] != 0xFFFF) {</span>
<span class="line-added"> 627                     movk(64, dst, chunks[k], k * 16);</span>
<span class="line-added"> 628                     includeSet[k] = MovAction.USED;</span>
<span class="line-added"> 629                     break;</span>
<span class="line-added"> 630                 }</span>
<span class="line-added"> 631             }</span>
<span class="line-added"> 632         } else if (zeroCount == 1) {</span>
<span class="line-added"> 633             // Generate one MOVZ and two MOVKs.</span>
<span class="line-added"> 634             int i;</span>
<span class="line-added"> 635             for (i = 0; i &lt; 4; i++) {</span>
<span class="line-added"> 636                 if (chunks[i] != 0) {</span>
<span class="line-added"> 637                     movz(64, dst, chunks[i], i * 16);</span>
<span class="line-added"> 638                     includeSet[i] = MovAction.USED;</span>
<span class="line-added"> 639                     break;</span>
<span class="line-added"> 640                 }</span>
 641             }
<span class="line-modified"> 642             int numMovks = 0;</span>
<span class="line-added"> 643             for (int k = i + 1; k &lt; 4; k++) {</span>
<span class="line-added"> 644                 if (chunks[k] != 0) {</span>
<span class="line-added"> 645                     movk(64, dst, chunks[k], k * 16);</span>
<span class="line-added"> 646                     includeSet[k] = MovAction.USED;</span>
<span class="line-added"> 647                     numMovks++;</span>
<span class="line-added"> 648                 }</span>
<span class="line-added"> 649             }</span>
<span class="line-added"> 650             assert numMovks == 2;</span>
<span class="line-added"> 651         } else if (negCount == 1) {</span>
<span class="line-added"> 652             // Generate one MOVN and two MOVKs.</span>
<span class="line-added"> 653             int i;</span>
<span class="line-added"> 654             for (i = 0; i &lt; 4; i++) {</span>
<span class="line-added"> 655                 if (chunks[i] != 0xFFFF) {</span>
<span class="line-added"> 656                     movn(64, dst, chunks[i] ^ 0xFFFF, i * 16);</span>
<span class="line-added"> 657                     includeSet[i] = MovAction.NEGATED;</span>
<span class="line-added"> 658                     break;</span>
<span class="line-added"> 659                 }</span>
<span class="line-added"> 660             }</span>
<span class="line-added"> 661             int numMovks = 0;</span>
<span class="line-added"> 662             for (int k = i + 1; k &lt; 4; k++) {</span>
<span class="line-added"> 663                 if (chunks[k] != 0xFFFF) {</span>
<span class="line-added"> 664                     movk(64, dst, chunks[k], k * 16);</span>
<span class="line-added"> 665                     includeSet[k] = MovAction.USED;</span>
<span class="line-added"> 666                     numMovks++;</span>
<span class="line-added"> 667                 }</span>
<span class="line-added"> 668             }</span>
<span class="line-added"> 669             assert numMovks == 2;</span>
<span class="line-added"> 670         } else {</span>
<span class="line-added"> 671             // Generate one MOVZ and three MOVKs</span>
<span class="line-added"> 672             movz(64, dst, chunks[0], 0);</span>
<span class="line-added"> 673             movk(64, dst, chunks[1], 16);</span>
<span class="line-added"> 674             movk(64, dst, chunks[2], 32);</span>
<span class="line-added"> 675             movk(64, dst, chunks[3], 48);</span>
<span class="line-added"> 676             includeSet[0] = MovAction.USED;</span>
<span class="line-added"> 677             includeSet[1] = MovAction.USED;</span>
<span class="line-added"> 678             includeSet[2] = MovAction.USED;</span>
<span class="line-added"> 679             includeSet[3] = MovAction.USED;</span>
 680         }
<span class="line-modified"> 681         if (needsImmAnnotation) {</span>
<span class="line-modified"> 682             annotateImmediateMovSequence(pos, includeSet);</span>

 683         }
 684     }
 685 
<span class="line-added"> 686     /**</span>
<span class="line-added"> 687      * Loads immediate into register.</span>
<span class="line-added"> 688      *</span>
<span class="line-added"> 689      * @param dst general purpose register. May not be null, zero-register or stackpointer.</span>
<span class="line-added"> 690      * @param imm immediate loaded into register.</span>
<span class="line-added"> 691      */</span>
<span class="line-added"> 692     public void mov(Register dst, int imm) {</span>
<span class="line-added"> 693         mov(dst, imm, false);</span>
<span class="line-added"> 694     }</span>
<span class="line-added"> 695 </span>
 696     /**
 697      * Loads immediate into register.
 698      *
 699      * @param dst general purpose register. May not be null, zero-register or stackpointer.
 700      * @param imm immediate loaded into register.
 701      */
 702     public void mov(Register dst, long imm) {
 703         mov(dst, imm, false);
 704     }
 705 
 706     /**
 707      * Loads immediate into register.
 708      *
 709      * @param dst general purpose register. May not be null, zero-register or stackpointer.
 710      * @param imm immediate loaded into register.
<span class="line-modified"> 711      * @param needsImmAnnotation Flag to signal of the immediate value should be annotated.</span>
 712      */
<span class="line-modified"> 713     public void mov(Register dst, int imm, boolean needsImmAnnotation) {</span>
<span class="line-added"> 714         if (imm == 0) {</span>
<span class="line-added"> 715             mov(32, dst, zr);</span>
<span class="line-added"> 716         } else if (isLogicalImmediate(imm)) {</span>
<span class="line-added"> 717             or(32, dst, zr, imm);</span>
<span class="line-added"> 718         } else {</span>
<span class="line-added"> 719             mov32(dst, imm, needsImmAnnotation);</span>
<span class="line-added"> 720         }</span>
<span class="line-added"> 721     }</span>
<span class="line-added"> 722 </span>
<span class="line-added"> 723     /**</span>
<span class="line-added"> 724      * Loads immediate into register.</span>
<span class="line-added"> 725      *</span>
<span class="line-added"> 726      * @param dst general purpose register. May not be null, zero-register or stackpointer.</span>
<span class="line-added"> 727      * @param imm immediate loaded into register.</span>
<span class="line-added"> 728      * @param needsImmAnnotation Flag to signal of the immediate value should be annotated.</span>
<span class="line-added"> 729      */</span>
<span class="line-added"> 730     public void mov(Register dst, long imm, boolean needsImmAnnotation) {</span>
 731         assert dst.getRegisterCategory().equals(CPU);
 732         if (imm == 0L) {
 733             movx(dst, zr);
<span class="line-modified"> 734         } else if (isLogicalImmediate(imm)) {</span>
 735             or(64, dst, zr, imm);
 736         } else if (imm &gt;&gt; 32 == -1L &amp;&amp; (int) imm &lt; 0 &amp;&amp; LogicalImmediateTable.isRepresentable((int) imm) != LogicalImmediateTable.Representable.NO) {
 737             // If the higher 32-bit are 1s and the sign bit of the lower 32-bits is set *and* we can
 738             // represent the lower 32 bits as a logical immediate we can create the lower 32-bit and
 739             // then sign extend
 740             // them. This allows us to cover immediates like ~1L with 2 instructions.
 741             mov(dst, (int) imm);
 742             sxt(64, 32, dst, dst);
 743         } else {
<span class="line-modified"> 744             mov64(dst, imm, needsImmAnnotation);</span>
 745         }
 746     }
 747 










 748     /**
 749      * Generates a 48-bit immediate move code sequence. The immediate may later be updated by
 750      * HotSpot.
 751      *
 752      * In AArch64 mode the virtual address space is 48-bits in size, so we only need three
 753      * instructions to create a patchable instruction sequence that can reach anywhere.
 754      *
 755      * @param dst general purpose register. May not be null, stackpointer or zero-register.
 756      * @param imm
 757      */
 758     public void movNativeAddress(Register dst, long imm) {
 759         movNativeAddress(dst, imm, false);
 760     }
 761 
 762     /**
 763      * Generates a 48-bit immediate move code sequence. The immediate may later be updated by
 764      * HotSpot.
 765      *
 766      * In AArch64 mode the virtual address space is 48-bits in size, so we only need three
 767      * instructions to create a patchable instruction sequence that can reach anywhere.
 768      *
 769      * @param dst general purpose register. May not be null, stackpointer or zero-register.
 770      * @param imm The immediate address
<span class="line-modified"> 771      * @param needsImmAnnotation Flag to signal of the immediate value should be annotated.</span>
 772      */
<span class="line-modified"> 773     public void movNativeAddress(Register dst, long imm, boolean needsImmAnnotation) {</span>
 774         assert (imm &amp; 0xFFFF_0000_0000_0000L) == 0;
 775         // We have to move all non zero parts of the immediate in 16-bit chunks
 776         boolean firstMove = true;
 777         int pos = position();
 778         for (int offset = 0; offset &lt; 48; offset += 16) {
 779             int chunk = (int) (imm &gt;&gt; offset) &amp; NumUtil.getNbitNumberInt(16);
 780             if (firstMove) {
 781                 movz(64, dst, chunk, offset);
 782                 firstMove = false;
 783             } else {
 784                 movk(64, dst, chunk, offset);
 785             }
 786         }
<span class="line-modified"> 787         if (needsImmAnnotation) {</span>
<span class="line-modified"> 788             MovAction[] includeSet = {MovAction.USED, MovAction.USED, MovAction.USED};</span>
<span class="line-added"> 789             annotateImmediateMovSequence(pos, includeSet);</span>
 790         }
 791         assert !firstMove;
 792     }
 793 
 794     /**
 795      * Generates a 32-bit immediate move code sequence. The immediate may later be updated by
 796      * HotSpot.
 797      *
 798      * @param dst general purpose register. May not be null, stackpointer or zero-register.
 799      * @param imm
 800      */
 801     public void movNarrowAddress(Register dst, long imm) {
 802         assert (imm &amp; 0xFFFF_FFFF_0000_0000L) == 0;
 803         movz(64, dst, (int) (imm &gt;&gt;&gt; 16), 16);
 804         movk(64, dst, (int) (imm &amp; 0xffff), 0);
 805     }
 806 
 807     /**
 808      * @return Number of instructions necessary to load immediate into register.
 809      */
</pre>
<hr />
<pre>
1410      * @param src general purpose register. May not be null, stackpointer or zero-register.
1411      * @param shiftAmt amount by which src is shifted.
1412      */
1413     public void ashr(int size, Register dst, Register src, long shiftAmt) {
1414         int shift = clampShiftAmt(size, shiftAmt);
1415         super.sbfm(size, dst, src, shift, size - 1);
1416     }
1417 
1418     /**
1419      * dst = src1 &gt;&gt; (src2 &amp; log2(size)).
1420      *
1421      * @param size register size. Has to be 32 or 64.
1422      * @param dst general purpose register. May not be null or stackpointer.
1423      * @param src general purpose register. May not be null or stackpointer.
1424      * @param shift general purpose register. May not be null or stackpointer.
1425      */
1426     public void ashr(int size, Register dst, Register src, Register shift) {
1427         super.asr(size, dst, src, shift);
1428     }
1429 
<span class="line-added">1430     /**</span>
<span class="line-added">1431      * Rotate right (register). dst = rotateRight(src1, (src2 &amp; (size - 1))).</span>
<span class="line-added">1432      *</span>
<span class="line-added">1433      * @param size register size. Has to be 32 or 64.</span>
<span class="line-added">1434      * @param dst general purpose register. May not be null or stackpointer.</span>
<span class="line-added">1435      * @param src1 general purpose register. May not be null or stackpointer.</span>
<span class="line-added">1436      * @param src2 general purpose register. It holds a shift amount from 0 to (size - 1) in its</span>
<span class="line-added">1437      *            bottom 5 bits. May not be null or stackpointer.</span>
<span class="line-added">1438      */</span>
<span class="line-added">1439     @Override</span>
<span class="line-added">1440     public void rorv(int size, Register dst, Register src1, Register src2) {</span>
<span class="line-added">1441         super.rorv(size, dst, src1, src2);</span>
<span class="line-added">1442     }</span>
<span class="line-added">1443 </span>
<span class="line-added">1444     /**</span>
<span class="line-added">1445      * Rotate right (immediate). dst = rotateRight(src1, shift).</span>
<span class="line-added">1446      *</span>
<span class="line-added">1447      * @param size register size. Has to be 32 or 64.</span>
<span class="line-added">1448      * @param dst general purpose register. May not be null or stackpointer.</span>
<span class="line-added">1449      * @param src general purpose register. May not be null or stackpointer.</span>
<span class="line-added">1450      * @param shift amount by which src is rotated. The value depends on the instruction variant, it</span>
<span class="line-added">1451      *            can be 0 to (size - 1).</span>
<span class="line-added">1452      */</span>
<span class="line-added">1453     public void ror(int size, Register dst, Register src, int shift) {</span>
<span class="line-added">1454         assert (0 &lt;= shift &amp;&amp; shift &lt;= (size - 1));</span>
<span class="line-added">1455         super.extr(size, dst, src, src, shift);</span>
<span class="line-added">1456     }</span>
<span class="line-added">1457 </span>
1458     /**
1459      * Clamps shiftAmt into range 0 &lt;= shiftamt &lt; size according to JLS.
1460      *
1461      * @param size size of operation.
1462      * @param shiftAmt arbitrary shift amount.
1463      * @return value between 0 and size - 1 inclusive that is equivalent to shiftAmt according to
1464      *         JLS.
1465      */
1466     private static int clampShiftAmt(int size, long shiftAmt) {
1467         return (int) (shiftAmt &amp; (size - 1));
1468     }
1469 
1470     /**
1471      * dst = src1 &amp; src2.
1472      *
1473      * @param size register size. Has to be 32 or 64.
1474      * @param dst general purpose register. May not be null or stackpointer.
1475      * @param src1 general purpose register. May not be null or stackpointer.
1476      * @param src2 general purpose register. May not be null or stackpointer.
1477      */
</pre>
<hr />
<pre>
1499      * @param src1 general purpose register. May not be null or stackpointer.
1500      * @param src2 general purpose register. May not be null or stackpointer.
1501      */
1502     public void or(int size, Register dst, Register src1, Register src2) {
1503         super.orr(size, dst, src1, src2, ShiftType.LSL, 0);
1504     }
1505 
1506     /**
1507      * dst = src | bimm.
1508      *
1509      * @param size register size. Has to be 32 or 64.
1510      * @param dst general purpose register. May not be null or zero-register.
1511      * @param src general purpose register. May not be null or stack-pointer.
1512      * @param bimm logical immediate. See {@link AArch64Assembler.LogicalImmediateTable} for exact
1513      *            definition.
1514      */
1515     public void or(int size, Register dst, Register src, long bimm) {
1516         super.orr(size, dst, src, bimm);
1517     }
1518 
<span class="line-added">1519     /**</span>
<span class="line-added">1520      * dst = src1 &amp; (~src2).</span>
<span class="line-added">1521      *</span>
<span class="line-added">1522      * @param size register size. Has to be 32 or 64.</span>
<span class="line-added">1523      * @param dst general purpose register. May not be null or stackpointer.</span>
<span class="line-added">1524      * @param src1 general purpose register. May not be null or stackpointer.</span>
<span class="line-added">1525      * @param src2 general purpose register. May not be null or stackpointer.</span>
<span class="line-added">1526      */</span>
<span class="line-added">1527     public void bic(int size, Register dst, Register src1, Register src2) {</span>
<span class="line-added">1528         super.bic(size, dst, src1, src2, ShiftType.LSL, 0);</span>
<span class="line-added">1529     }</span>
<span class="line-added">1530 </span>
<span class="line-added">1531     /**</span>
<span class="line-added">1532      * dst = src1 ^ (~src2).</span>
<span class="line-added">1533      *</span>
<span class="line-added">1534      * @param size register size. Has to be 32 or 64.</span>
<span class="line-added">1535      * @param dst general purpose register. May not be null or stackpointer.</span>
<span class="line-added">1536      * @param src1 general purpose register. May not be null or stackpointer.</span>
<span class="line-added">1537      * @param src2 general purpose register. May not be null or stackpointer.</span>
<span class="line-added">1538      */</span>
<span class="line-added">1539     public void eon(int size, Register dst, Register src1, Register src2) {</span>
<span class="line-added">1540         super.eon(size, dst, src1, src2, ShiftType.LSL, 0);</span>
<span class="line-added">1541     }</span>
<span class="line-added">1542 </span>
<span class="line-added">1543     /**</span>
<span class="line-added">1544      * dst = src1 | (~src2).</span>
<span class="line-added">1545      *</span>
<span class="line-added">1546      * @param size register size. Has to be 32 or 64.</span>
<span class="line-added">1547      * @param dst general purpose register. May not be null or stackpointer.</span>
<span class="line-added">1548      * @param src1 general purpose register. May not be null or stackpointer.</span>
<span class="line-added">1549      * @param src2 general purpose register. May not be null or stackpointer.</span>
<span class="line-added">1550      */</span>
<span class="line-added">1551     public void orn(int size, Register dst, Register src1, Register src2) {</span>
<span class="line-added">1552         super.orn(size, dst, src1, src2, ShiftType.LSL, 0);</span>
<span class="line-added">1553     }</span>
<span class="line-added">1554 </span>
1555     /**
1556      * dst = ~src.
1557      *
1558      * @param size register size. Has to be 32 or 64.
1559      * @param dst general purpose register. May not be null or stackpointer.
1560      * @param src general purpose register. May not be null or stackpointer.
1561      */
1562     public void not(int size, Register dst, Register src) {
1563         super.orn(size, dst, zr, src, ShiftType.LSL, 0);
1564     }
1565 
1566     /**
1567      * dst = src1 &amp; shiftType(src2, imm).
1568      *
1569      * @param size register size. Has to be 32 or 64.
1570      * @param dst general purpose register. May not be null or stackpointer.
1571      * @param src1 general purpose register. May not be null or stackpointer.
1572      * @param src2 general purpose register. May not be null or stackpointer.
1573      * @param shiftType all types allowed, may not be null.
1574      * @param shiftAmt must be in range 0 to size - 1.
</pre>
<hr />
<pre>
2274         a.lea(this, d);
2275     }
2276 
2277     /**
2278      * Count the set bits of src register.
2279      *
2280      * @param size src register size. Has to be 32 or 64.
2281      * @param dst general purpose register. Should not be null or zero-register.
2282      * @param src general purpose register. Should not be null.
2283      * @param vreg SIMD register. Should not be null.
2284      */
2285     public void popcnt(int size, Register dst, Register src, Register vreg) {
2286         assert 32 == size || 64 == size : &quot;Invalid data size&quot;;
2287         fmov(size, vreg, src);
2288         final int fixedSize = 64;
2289         cnt(fixedSize, vreg, vreg);
2290         addv(fixedSize, SIMDElementSize.Byte, vreg, vreg);
2291         umov(fixedSize, dst, 0, vreg);
2292     }
2293 




2294     /**
2295      * Emits elf patchable adrp ldr sequence.
2296      */
2297     public void adrpLdr(int srcSize, Register result, AArch64Address a) {
2298         if (codePatchingAnnotationConsumer != null) {
<span class="line-modified">2299             codePatchingAnnotationConsumer.accept(new AdrpLdrMacroInstruction(position(), srcSize));</span>
2300         }
2301         super.adrp(a.getBase());
2302         this.ldr(srcSize, result, a);
2303     }
2304 
<span class="line-modified">2305     public static class AdrpLdrMacroInstruction extends AArch64Assembler.PatchableCodeAnnotation {</span>
<span class="line-modified">2306         public final int srcSize;</span>
<span class="line-added">2307 </span>
<span class="line-added">2308         public AdrpLdrMacroInstruction(int position, int srcSize) {</span>
2309             super(position);
<span class="line-added">2310             this.srcSize = srcSize;</span>
2311         }
2312 
2313         @Override
2314         public String toString() {
2315             return &quot;ADRP_LDR&quot;;
2316         }
2317 
2318         @Override
2319         public void patch(int codePos, int relative, byte[] code) {
<span class="line-modified">2320             int shiftSize = 0;</span>
<span class="line-added">2321             switch (srcSize) {</span>
<span class="line-added">2322                 case 64:</span>
<span class="line-added">2323                     shiftSize = 3;</span>
<span class="line-added">2324                     break;</span>
<span class="line-added">2325                 case 32:</span>
<span class="line-added">2326                     shiftSize = 2;</span>
<span class="line-added">2327                     break;</span>
<span class="line-added">2328                 case 16:</span>
<span class="line-added">2329                     shiftSize = 1;</span>
<span class="line-added">2330                     break;</span>
<span class="line-added">2331                 case 8:</span>
<span class="line-added">2332                     shiftSize = 0;</span>
<span class="line-added">2333                     break;</span>
<span class="line-added">2334                 default:</span>
<span class="line-added">2335                     assert false : &quot;srcSize must be either 8, 16, 32, or 64&quot;;</span>
<span class="line-added">2336             }</span>
<span class="line-added">2337 </span>
<span class="line-added">2338             int pos = instructionPosition;</span>
<span class="line-added">2339 </span>
<span class="line-added">2340             int targetAddress = pos + relative;</span>
<span class="line-added">2341             assert shiftSize == 0 || (targetAddress &amp; ((1 &lt;&lt; shiftSize) - 1)) == 0 : &quot;shift bits must be zero&quot;;</span>
<span class="line-added">2342 </span>
<span class="line-added">2343             int relativePageDifference = PatcherUtil.computeRelativePageDifference(targetAddress, pos, 1 &lt;&lt; 12);</span>
<span class="line-added">2344 </span>
<span class="line-added">2345             // adrp imm_hi bits</span>
<span class="line-added">2346             int curValue = (relativePageDifference &gt;&gt; 2) &amp; 0x7FFFF;</span>
<span class="line-added">2347             int[] adrHiBits = {3, 8, 8};</span>
<span class="line-added">2348             int[] adrHiOffsets = {5, 0, 0};</span>
<span class="line-added">2349             PatcherUtil.writeBitSequence(code, pos, curValue, adrHiBits, adrHiOffsets);</span>
<span class="line-added">2350             // adrp imm_lo bits</span>
<span class="line-added">2351             curValue = relativePageDifference &amp; 0x3;</span>
<span class="line-added">2352             int[] adrLoBits = {2};</span>
<span class="line-added">2353             int[] adrLoOffsets = {5};</span>
<span class="line-added">2354             PatcherUtil.writeBitSequence(code, pos + 3, curValue, adrLoBits, adrLoOffsets);</span>
<span class="line-added">2355             // ldr bits</span>
<span class="line-added">2356             curValue = (targetAddress &gt;&gt; shiftSize) &amp; 0x1FF;</span>
<span class="line-added">2357             int[] ldrBits = {6, 6};</span>
<span class="line-added">2358             int[] ldrOffsets = {2, 0};</span>
<span class="line-added">2359             PatcherUtil.writeBitSequence(code, pos + 5, curValue, ldrBits, ldrOffsets);</span>
2360         }
2361     }
2362 
<span class="line-modified">2363     public static class AdrpAddMacroInstruction extends AArch64Assembler.PatchableCodeAnnotation {</span>
2364         public AdrpAddMacroInstruction(int position) {
2365             super(position);
2366         }
2367 
2368         @Override
2369         public String toString() {
2370             return &quot;ADRP_ADD&quot;;
2371         }
2372 
2373         @Override
2374         public void patch(int codePos, int relative, byte[] code) {
<span class="line-modified">2375             int pos = instructionPosition;</span>
<span class="line-added">2376             int targetAddress = pos + relative;</span>
<span class="line-added">2377             int relativePageDifference = PatcherUtil.computeRelativePageDifference(targetAddress, pos, 1 &lt;&lt; 12);</span>
<span class="line-added">2378             // adrp imm_hi bits</span>
<span class="line-added">2379             int curValue = (relativePageDifference &gt;&gt; 2) &amp; 0x7FFFF;</span>
<span class="line-added">2380             int[] adrHiBits = {3, 8, 8};</span>
<span class="line-added">2381             int[] adrHiOffsets = {5, 0, 0};</span>
<span class="line-added">2382             PatcherUtil.writeBitSequence(code, pos, curValue, adrHiBits, adrHiOffsets);</span>
<span class="line-added">2383             // adrp imm_lo bits</span>
<span class="line-added">2384             curValue = relativePageDifference &amp; 0x3;</span>
<span class="line-added">2385             int[] adrLoBits = {2};</span>
<span class="line-added">2386             int[] adrLoOffsets = {5};</span>
<span class="line-added">2387             PatcherUtil.writeBitSequence(code, pos + 3, curValue, adrLoBits, adrLoOffsets);</span>
<span class="line-added">2388             // add bits</span>
<span class="line-added">2389             curValue = targetAddress &amp; 0xFFF;</span>
<span class="line-added">2390             int[] addBits = {6, 6};</span>
<span class="line-added">2391             int[] addOffsets = {2, 0};</span>
<span class="line-added">2392             PatcherUtil.writeBitSequence(code, pos + 5, curValue, addBits, addOffsets);</span>
<span class="line-added">2393         }</span>
<span class="line-added">2394     }</span>
<span class="line-added">2395 </span>
<span class="line-added">2396     private void annotateImmediateMovSequence(int pos, MovSequenceAnnotation.MovAction[] includeSet) {</span>
<span class="line-added">2397         if (codePatchingAnnotationConsumer != null) {</span>
<span class="line-added">2398             codePatchingAnnotationConsumer.accept(new MovSequenceAnnotation(pos, includeSet));</span>
<span class="line-added">2399         }</span>
<span class="line-added">2400     }</span>
<span class="line-added">2401 </span>
<span class="line-added">2402     public static class MovSequenceAnnotation extends AArch64Assembler.PatchableCodeAnnotation {</span>
<span class="line-added">2403 </span>
<span class="line-added">2404         /**</span>
<span class="line-added">2405          * An enum to indicate how each 16-bit immediate chunk is represented within a sequence of</span>
<span class="line-added">2406          * mov instructions.</span>
<span class="line-added">2407          */</span>
<span class="line-added">2408         public enum MovAction {</span>
<span class="line-added">2409             USED, // mov instruction is in place for this chunk.</span>
<span class="line-added">2410             SKIPPED, // no mov instruction is in place for this chunk.</span>
<span class="line-added">2411             NEGATED; // movn instruction is in place for this chunk.</span>
<span class="line-added">2412         }</span>
<span class="line-added">2413 </span>
<span class="line-added">2414         /**</span>
<span class="line-added">2415          * The size of the operand, in bytes.</span>
<span class="line-added">2416          */</span>
<span class="line-added">2417         public final MovAction[] includeSet;</span>
<span class="line-added">2418 </span>
<span class="line-added">2419         MovSequenceAnnotation(int instructionPosition, MovAction[] includeSet) {</span>
<span class="line-added">2420             super(instructionPosition);</span>
<span class="line-added">2421             this.includeSet = includeSet;</span>
<span class="line-added">2422         }</span>
<span class="line-added">2423 </span>
<span class="line-added">2424         @Override</span>
<span class="line-added">2425         public String toString() {</span>
<span class="line-added">2426             return &quot;MOV_SEQ&quot;;</span>
<span class="line-added">2427         }</span>
<span class="line-added">2428 </span>
<span class="line-added">2429         @Override</span>
<span class="line-added">2430         public void patch(int codePos, int relative, byte[] code) {</span>
<span class="line-added">2431             /*</span>
<span class="line-added">2432              * Each move has a 16 bit immediate operand. We use a series of shifted moves to</span>
<span class="line-added">2433              * represent immediate values larger than 16 bits.</span>
<span class="line-added">2434              */</span>
<span class="line-added">2435             int curValue = relative;</span>
<span class="line-added">2436             int[] bitsUsed = {3, 8, 5};</span>
<span class="line-added">2437             int[] offsets = {5, 0, 0};</span>
<span class="line-added">2438             int siteOffset = 0;</span>
<span class="line-added">2439             boolean containsNegatedMov = false;</span>
<span class="line-added">2440             for (MovAction include : includeSet) {</span>
<span class="line-added">2441                 if (include == MovAction.NEGATED) {</span>
<span class="line-added">2442                     containsNegatedMov = true;</span>
<span class="line-added">2443                     break;</span>
<span class="line-added">2444                 }</span>
<span class="line-added">2445             }</span>
<span class="line-added">2446             for (int i = 0; i &lt; includeSet.length; i++) {</span>
<span class="line-added">2447                 int value = curValue &amp; 0xFFFF;</span>
<span class="line-added">2448                 curValue = curValue &gt;&gt; 16;</span>
<span class="line-added">2449                 switch (includeSet[i]) {</span>
<span class="line-added">2450                     case USED:</span>
<span class="line-added">2451                         break;</span>
<span class="line-added">2452                     case SKIPPED:</span>
<span class="line-added">2453                         assert value == (containsNegatedMov ? 0xFFFF : 0) : &quot;Unable to patch this value.&quot;;</span>
<span class="line-added">2454                         continue;</span>
<span class="line-added">2455                     case NEGATED:</span>
<span class="line-added">2456                         value = value ^ 0xFFFF;</span>
<span class="line-added">2457                         break;</span>
<span class="line-added">2458                 }</span>
<span class="line-added">2459                 int bytePosition = instructionPosition + siteOffset;</span>
<span class="line-added">2460                 PatcherUtil.writeBitSequence(code, bytePosition, value, bitsUsed, offsets);</span>
<span class="line-added">2461                 siteOffset += 4;</span>
<span class="line-added">2462             }</span>
2463         }
2464     }
2465 }
</pre>
</td>
</tr>
</table>
<center><a href="AArch64Assembler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../org.graalvm.compiler.asm.amd64/src/org/graalvm/compiler/asm/amd64/AMD64Address.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.aarch64/src/org/graalvm/compiler/asm/aarch64/AArch64MacroAssembler.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AArch64Assembler.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../org.graalvm.compiler.asm.amd64/src/org/graalvm/compiler/asm/amd64/AMD64Address.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.aarch64/src/org/graalvm/compiler/asm/aarch64/AArch64MacroAssembler.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -41,10 +41,11 @@</span>
  import static org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.AddressGenerationPlan.WorkPlan.ADD_TO_INDEX;
  import static org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.AddressGenerationPlan.WorkPlan.NO_WORK;
  
  import org.graalvm.compiler.asm.BranchTargetOutOfBoundsException;
  import org.graalvm.compiler.asm.Label;
<span class="udiff-line-added">+ import org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.MovSequenceAnnotation.MovAction;</span>
  import org.graalvm.compiler.core.common.NumUtil;
  import org.graalvm.compiler.debug.GraalError;
  
  import jdk.vm.ci.aarch64.AArch64;
  import jdk.vm.ci.code.Register;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -500,41 +501,200 @@</span>
          } else {
              or(size, dst, zr, src);
          }
      }
  
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Generates a 32-bit immediate move code sequence.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param dst general purpose register. May not be null, stackpointer or zero-register.</span>
<span class="udiff-line-added">+      * @param imm the value to move into the register.</span>
<span class="udiff-line-added">+      * @param needsImmAnnotation Flag denoting if annotation should be added.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private void mov32(Register dst, int imm, boolean needsImmAnnotation) {</span>
<span class="udiff-line-added">+         MovAction[] includeSet = {MovAction.SKIPPED, MovAction.SKIPPED};</span>
<span class="udiff-line-added">+         int pos = position();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Split 32-bit imm into low16 and high16 parts.</span>
<span class="udiff-line-added">+         int low16 = imm &amp; 0xFFFF;</span>
<span class="udiff-line-added">+         int high16 = (imm &gt;&gt;&gt; 16) &amp; 0xFFFF;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Generate code sequence with a combination of MOVZ or MOVN with MOVK.</span>
<span class="udiff-line-added">+         if (high16 == 0) {</span>
<span class="udiff-line-added">+             movz(32, dst, low16, 0);</span>
<span class="udiff-line-added">+             includeSet[0] = MovAction.USED;</span>
<span class="udiff-line-added">+         } else if (high16 == 0xFFFF) {</span>
<span class="udiff-line-added">+             movn(32, dst, low16 ^ 0xFFFF, 0);</span>
<span class="udiff-line-added">+             includeSet[0] = MovAction.NEGATED;</span>
<span class="udiff-line-added">+         } else if (low16 == 0) {</span>
<span class="udiff-line-added">+             movz(32, dst, high16, 16);</span>
<span class="udiff-line-added">+             includeSet[1] = MovAction.USED;</span>
<span class="udiff-line-added">+         } else if (low16 == 0xFFFF) {</span>
<span class="udiff-line-added">+             movn(32, dst, high16 ^ 0xFFFF, 16);</span>
<span class="udiff-line-added">+             includeSet[1] = MovAction.NEGATED;</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             // Neither of the 2 parts is all-0s or all-1s. Generate 2 instructions.</span>
<span class="udiff-line-added">+             movz(32, dst, low16, 0);</span>
<span class="udiff-line-added">+             movk(32, dst, high16, 16);</span>
<span class="udiff-line-added">+             includeSet[0] = MovAction.USED;</span>
<span class="udiff-line-added">+             includeSet[1] = MovAction.USED;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (needsImmAnnotation) {</span>
<span class="udiff-line-added">+             annotateImmediateMovSequence(pos, includeSet);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /**
       * Generates a 64-bit immediate move code sequence.
       *
       * @param dst general purpose register. May not be null, stackpointer or zero-register.
       * @param imm the value to move into the register
<span class="udiff-line-modified-removed">-      * @param annotateImm Flag denoting if annotation should be added.</span>
<span class="udiff-line-modified-added">+      * @param needsImmAnnotation Flag denoting if annotation should be added.</span>
       */
<span class="udiff-line-modified-removed">-     private void mov64(Register dst, long imm, boolean annotateImm) {</span>
<span class="udiff-line-modified-removed">-         // We have to move all non zero parts of the immediate in 16-bit chunks</span>
<span class="udiff-line-removed">-         int numMovs = 0;</span>
<span class="udiff-line-modified-added">+     private void mov64(Register dst, long imm, boolean needsImmAnnotation) {</span>
<span class="udiff-line-modified-added">+         MovAction[] includeSet = {MovAction.SKIPPED, MovAction.SKIPPED, MovAction.SKIPPED, MovAction.SKIPPED};</span>
          int pos = position();
<span class="udiff-line-modified-removed">-         boolean firstMove = true;</span>
<span class="udiff-line-modified-removed">-         for (int offset = 0; offset &lt; 64; offset += 16) {</span>
<span class="udiff-line-modified-removed">-             int chunk = (int) (imm &gt;&gt; offset) &amp; NumUtil.getNbitNumberInt(16);</span>
<span class="udiff-line-modified-added">+         int[] chunks = new int[4];</span>
<span class="udiff-line-modified-added">+         int zeroCount = 0;</span>
<span class="udiff-line-modified-added">+         int negCount = 0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Split 64-bit imm into 4 chunks and count the numbers of all-0 and all-1 chunks.</span>
<span class="udiff-line-added">+         for (int i = 0; i &lt; 4; i++) {</span>
<span class="udiff-line-added">+             int chunk = (int) ((imm &gt;&gt;&gt; (i * 16)) &amp; 0xFFFFL);</span>
              if (chunk == 0) {
<span class="udiff-line-modified-removed">-                 continue;</span>
<span class="udiff-line-modified-added">+                 zeroCount++;</span>
<span class="udiff-line-added">+             } else if (chunk == 0xFFFF) {</span>
<span class="udiff-line-added">+                 negCount++;</span>
              }
<span class="udiff-line-modified-removed">-             if (firstMove) {</span>
<span class="udiff-line-modified-removed">-                 movz(64, dst, chunk, offset);</span>
<span class="udiff-line-modified-removed">-                 firstMove = false;</span>
<span class="udiff-line-modified-removed">-             } else {</span>
<span class="udiff-line-modified-removed">-                 movk(64, dst, chunk, offset);</span>
<span class="udiff-line-modified-added">+             chunks[i] = chunk;</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         // Generate code sequence with a combination of MOVZ or MOVN with MOVK.</span>
<span class="udiff-line-modified-added">+         if (zeroCount == 4) {</span>
<span class="udiff-line-added">+             // Generate only one MOVZ.</span>
<span class="udiff-line-added">+             movz(64, dst, 0, 0);</span>
<span class="udiff-line-added">+             includeSet[0] = MovAction.USED;</span>
<span class="udiff-line-added">+         } else if (negCount == 4) {</span>
<span class="udiff-line-added">+             // Generate only one MOVN.</span>
<span class="udiff-line-added">+             movn(64, dst, 0, 0);</span>
<span class="udiff-line-added">+             includeSet[0] = MovAction.NEGATED;</span>
<span class="udiff-line-added">+         } else if (zeroCount == 3) {</span>
<span class="udiff-line-added">+             // Generate only one MOVZ.</span>
<span class="udiff-line-added">+             for (int i = 0; i &lt; 4; i++) {</span>
<span class="udiff-line-added">+                 if (chunks[i] != 0) {</span>
<span class="udiff-line-added">+                     movz(64, dst, chunks[i], i * 16);</span>
<span class="udiff-line-added">+                     includeSet[i] = MovAction.USED;</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         } else if (negCount == 3) {</span>
<span class="udiff-line-added">+             // Generate only one MOVN.</span>
<span class="udiff-line-added">+             for (int i = 0; i &lt; 4; i++) {</span>
<span class="udiff-line-added">+                 if (chunks[i] != 0xFFFF) {</span>
<span class="udiff-line-added">+                     movn(64, dst, chunks[i] ^ 0xFFFF, i * 16);</span>
<span class="udiff-line-added">+                     includeSet[i] = MovAction.NEGATED;</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         } else if (zeroCount == 2) {</span>
<span class="udiff-line-added">+             // Generate one MOVZ and one MOVK.</span>
<span class="udiff-line-added">+             int i;</span>
<span class="udiff-line-added">+             for (i = 0; i &lt; 4; i++) {</span>
<span class="udiff-line-added">+                 if (chunks[i] != 0) {</span>
<span class="udiff-line-added">+                     movz(64, dst, chunks[i], i * 16);</span>
<span class="udiff-line-added">+                     includeSet[i] = MovAction.USED;</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             for (int k = i + 1; k &lt; 4; k++) {</span>
<span class="udiff-line-added">+                 if (chunks[k] != 0) {</span>
<span class="udiff-line-added">+                     movk(64, dst, chunks[k], k * 16);</span>
<span class="udiff-line-added">+                     includeSet[k] = MovAction.USED;</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         } else if (negCount == 2) {</span>
<span class="udiff-line-added">+             // Generate one MOVN and one MOVK.</span>
<span class="udiff-line-added">+             int i;</span>
<span class="udiff-line-added">+             for (i = 0; i &lt; 4; i++) {</span>
<span class="udiff-line-added">+                 if (chunks[i] != 0xFFFF) {</span>
<span class="udiff-line-added">+                     movn(64, dst, chunks[i] ^ 0xFFFF, i * 16);</span>
<span class="udiff-line-added">+                     includeSet[i] = MovAction.NEGATED;</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             for (int k = i + 1; k &lt; 4; k++) {</span>
<span class="udiff-line-added">+                 if (chunks[k] != 0xFFFF) {</span>
<span class="udiff-line-added">+                     movk(64, dst, chunks[k], k * 16);</span>
<span class="udiff-line-added">+                     includeSet[k] = MovAction.USED;</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         } else if (zeroCount == 1) {</span>
<span class="udiff-line-added">+             // Generate one MOVZ and two MOVKs.</span>
<span class="udiff-line-added">+             int i;</span>
<span class="udiff-line-added">+             for (i = 0; i &lt; 4; i++) {</span>
<span class="udiff-line-added">+                 if (chunks[i] != 0) {</span>
<span class="udiff-line-added">+                     movz(64, dst, chunks[i], i * 16);</span>
<span class="udiff-line-added">+                     includeSet[i] = MovAction.USED;</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 }</span>
              }
<span class="udiff-line-modified-removed">-             ++numMovs;</span>
<span class="udiff-line-modified-added">+             int numMovks = 0;</span>
<span class="udiff-line-added">+             for (int k = i + 1; k &lt; 4; k++) {</span>
<span class="udiff-line-added">+                 if (chunks[k] != 0) {</span>
<span class="udiff-line-added">+                     movk(64, dst, chunks[k], k * 16);</span>
<span class="udiff-line-added">+                     includeSet[k] = MovAction.USED;</span>
<span class="udiff-line-added">+                     numMovks++;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             assert numMovks == 2;</span>
<span class="udiff-line-added">+         } else if (negCount == 1) {</span>
<span class="udiff-line-added">+             // Generate one MOVN and two MOVKs.</span>
<span class="udiff-line-added">+             int i;</span>
<span class="udiff-line-added">+             for (i = 0; i &lt; 4; i++) {</span>
<span class="udiff-line-added">+                 if (chunks[i] != 0xFFFF) {</span>
<span class="udiff-line-added">+                     movn(64, dst, chunks[i] ^ 0xFFFF, i * 16);</span>
<span class="udiff-line-added">+                     includeSet[i] = MovAction.NEGATED;</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             int numMovks = 0;</span>
<span class="udiff-line-added">+             for (int k = i + 1; k &lt; 4; k++) {</span>
<span class="udiff-line-added">+                 if (chunks[k] != 0xFFFF) {</span>
<span class="udiff-line-added">+                     movk(64, dst, chunks[k], k * 16);</span>
<span class="udiff-line-added">+                     includeSet[k] = MovAction.USED;</span>
<span class="udiff-line-added">+                     numMovks++;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             assert numMovks == 2;</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             // Generate one MOVZ and three MOVKs</span>
<span class="udiff-line-added">+             movz(64, dst, chunks[0], 0);</span>
<span class="udiff-line-added">+             movk(64, dst, chunks[1], 16);</span>
<span class="udiff-line-added">+             movk(64, dst, chunks[2], 32);</span>
<span class="udiff-line-added">+             movk(64, dst, chunks[3], 48);</span>
<span class="udiff-line-added">+             includeSet[0] = MovAction.USED;</span>
<span class="udiff-line-added">+             includeSet[1] = MovAction.USED;</span>
<span class="udiff-line-added">+             includeSet[2] = MovAction.USED;</span>
<span class="udiff-line-added">+             includeSet[3] = MovAction.USED;</span>
          }
<span class="udiff-line-modified-removed">-         assert !firstMove;</span>
<span class="udiff-line-modified-removed">-         if (annotateImm) {</span>
<span class="udiff-line-removed">-             annotateImmediateMovSequence(pos, numMovs);</span>
<span class="udiff-line-modified-added">+         if (needsImmAnnotation) {</span>
<span class="udiff-line-modified-added">+             annotateImmediateMovSequence(pos, includeSet);</span>
          }
      }
  
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Loads immediate into register.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param dst general purpose register. May not be null, zero-register or stackpointer.</span>
<span class="udiff-line-added">+      * @param imm immediate loaded into register.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public void mov(Register dst, int imm) {</span>
<span class="udiff-line-added">+         mov(dst, imm, false);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /**
       * Loads immediate into register.
       *
       * @param dst general purpose register. May not be null, zero-register or stackpointer.
       * @param imm immediate loaded into register.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -546,40 +706,47 @@</span>
      /**
       * Loads immediate into register.
       *
       * @param dst general purpose register. May not be null, zero-register or stackpointer.
       * @param imm immediate loaded into register.
<span class="udiff-line-modified-removed">-      * @param annotateImm Flag to signal of the immediate value should be annotated.</span>
<span class="udiff-line-modified-added">+      * @param needsImmAnnotation Flag to signal of the immediate value should be annotated.</span>
       */
<span class="udiff-line-modified-removed">-     public void mov(Register dst, long imm, boolean annotateImm) {</span>
<span class="udiff-line-modified-added">+     public void mov(Register dst, int imm, boolean needsImmAnnotation) {</span>
<span class="udiff-line-added">+         if (imm == 0) {</span>
<span class="udiff-line-added">+             mov(32, dst, zr);</span>
<span class="udiff-line-added">+         } else if (isLogicalImmediate(imm)) {</span>
<span class="udiff-line-added">+             or(32, dst, zr, imm);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             mov32(dst, imm, needsImmAnnotation);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Loads immediate into register.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param dst general purpose register. May not be null, zero-register or stackpointer.</span>
<span class="udiff-line-added">+      * @param imm immediate loaded into register.</span>
<span class="udiff-line-added">+      * @param needsImmAnnotation Flag to signal of the immediate value should be annotated.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public void mov(Register dst, long imm, boolean needsImmAnnotation) {</span>
          assert dst.getRegisterCategory().equals(CPU);
          if (imm == 0L) {
              movx(dst, zr);
<span class="udiff-line-modified-removed">-         } else if (LogicalImmediateTable.isRepresentable(true, imm) != LogicalImmediateTable.Representable.NO) {</span>
<span class="udiff-line-modified-added">+         } else if (isLogicalImmediate(imm)) {</span>
              or(64, dst, zr, imm);
          } else if (imm &gt;&gt; 32 == -1L &amp;&amp; (int) imm &lt; 0 &amp;&amp; LogicalImmediateTable.isRepresentable((int) imm) != LogicalImmediateTable.Representable.NO) {
              // If the higher 32-bit are 1s and the sign bit of the lower 32-bits is set *and* we can
              // represent the lower 32 bits as a logical immediate we can create the lower 32-bit and
              // then sign extend
              // them. This allows us to cover immediates like ~1L with 2 instructions.
              mov(dst, (int) imm);
              sxt(64, 32, dst, dst);
          } else {
<span class="udiff-line-modified-removed">-             mov64(dst, imm, annotateImm);</span>
<span class="udiff-line-modified-added">+             mov64(dst, imm, needsImmAnnotation);</span>
          }
      }
  
<span class="udiff-line-removed">-     /**</span>
<span class="udiff-line-removed">-      * Loads immediate into register.</span>
<span class="udiff-line-removed">-      *</span>
<span class="udiff-line-removed">-      * @param dst general purpose register. May not be null, zero-register or stackpointer.</span>
<span class="udiff-line-removed">-      * @param imm immediate loaded into register.</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     public void mov(Register dst, int imm) {</span>
<span class="udiff-line-removed">-         mov(dst, imm &amp; 0xFFFF_FFFFL);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      /**
       * Generates a 48-bit immediate move code sequence. The immediate may later be updated by
       * HotSpot.
       *
       * In AArch64 mode the virtual address space is 48-bits in size, so we only need three
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -599,13 +766,13 @@</span>
       * In AArch64 mode the virtual address space is 48-bits in size, so we only need three
       * instructions to create a patchable instruction sequence that can reach anywhere.
       *
       * @param dst general purpose register. May not be null, stackpointer or zero-register.
       * @param imm The immediate address
<span class="udiff-line-modified-removed">-      * @param annotateImm Flag to signal of the immediate value should be annotated.</span>
<span class="udiff-line-modified-added">+      * @param needsImmAnnotation Flag to signal of the immediate value should be annotated.</span>
       */
<span class="udiff-line-modified-removed">-     public void movNativeAddress(Register dst, long imm, boolean annotateImm) {</span>
<span class="udiff-line-modified-added">+     public void movNativeAddress(Register dst, long imm, boolean needsImmAnnotation) {</span>
          assert (imm &amp; 0xFFFF_0000_0000_0000L) == 0;
          // We have to move all non zero parts of the immediate in 16-bit chunks
          boolean firstMove = true;
          int pos = position();
          for (int offset = 0; offset &lt; 48; offset += 16) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -615,12 +782,13 @@</span>
                  firstMove = false;
              } else {
                  movk(64, dst, chunk, offset);
              }
          }
<span class="udiff-line-modified-removed">-         if (annotateImm) {</span>
<span class="udiff-line-modified-removed">-             annotateImmediateMovSequence(pos, 3);</span>
<span class="udiff-line-modified-added">+         if (needsImmAnnotation) {</span>
<span class="udiff-line-modified-added">+             MovAction[] includeSet = {MovAction.USED, MovAction.USED, MovAction.USED};</span>
<span class="udiff-line-added">+             annotateImmediateMovSequence(pos, includeSet);</span>
          }
          assert !firstMove;
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1257,10 +1425,38 @@</span>
       */
      public void ashr(int size, Register dst, Register src, Register shift) {
          super.asr(size, dst, src, shift);
      }
  
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Rotate right (register). dst = rotateRight(src1, (src2 &amp; (size - 1))).</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param size register size. Has to be 32 or 64.</span>
<span class="udiff-line-added">+      * @param dst general purpose register. May not be null or stackpointer.</span>
<span class="udiff-line-added">+      * @param src1 general purpose register. May not be null or stackpointer.</span>
<span class="udiff-line-added">+      * @param src2 general purpose register. It holds a shift amount from 0 to (size - 1) in its</span>
<span class="udiff-line-added">+      *            bottom 5 bits. May not be null or stackpointer.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     @Override</span>
<span class="udiff-line-added">+     public void rorv(int size, Register dst, Register src1, Register src2) {</span>
<span class="udiff-line-added">+         super.rorv(size, dst, src1, src2);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Rotate right (immediate). dst = rotateRight(src1, shift).</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param size register size. Has to be 32 or 64.</span>
<span class="udiff-line-added">+      * @param dst general purpose register. May not be null or stackpointer.</span>
<span class="udiff-line-added">+      * @param src general purpose register. May not be null or stackpointer.</span>
<span class="udiff-line-added">+      * @param shift amount by which src is rotated. The value depends on the instruction variant, it</span>
<span class="udiff-line-added">+      *            can be 0 to (size - 1).</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public void ror(int size, Register dst, Register src, int shift) {</span>
<span class="udiff-line-added">+         assert (0 &lt;= shift &amp;&amp; shift &lt;= (size - 1));</span>
<span class="udiff-line-added">+         super.extr(size, dst, src, src, shift);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /**
       * Clamps shiftAmt into range 0 &lt;= shiftamt &lt; size according to JLS.
       *
       * @param size size of operation.
       * @param shiftAmt arbitrary shift amount.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1318,10 +1514,46 @@</span>
       */
      public void or(int size, Register dst, Register src, long bimm) {
          super.orr(size, dst, src, bimm);
      }
  
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * dst = src1 &amp; (~src2).</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param size register size. Has to be 32 or 64.</span>
<span class="udiff-line-added">+      * @param dst general purpose register. May not be null or stackpointer.</span>
<span class="udiff-line-added">+      * @param src1 general purpose register. May not be null or stackpointer.</span>
<span class="udiff-line-added">+      * @param src2 general purpose register. May not be null or stackpointer.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public void bic(int size, Register dst, Register src1, Register src2) {</span>
<span class="udiff-line-added">+         super.bic(size, dst, src1, src2, ShiftType.LSL, 0);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * dst = src1 ^ (~src2).</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param size register size. Has to be 32 or 64.</span>
<span class="udiff-line-added">+      * @param dst general purpose register. May not be null or stackpointer.</span>
<span class="udiff-line-added">+      * @param src1 general purpose register. May not be null or stackpointer.</span>
<span class="udiff-line-added">+      * @param src2 general purpose register. May not be null or stackpointer.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public void eon(int size, Register dst, Register src1, Register src2) {</span>
<span class="udiff-line-added">+         super.eon(size, dst, src1, src2, ShiftType.LSL, 0);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * dst = src1 | (~src2).</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param size register size. Has to be 32 or 64.</span>
<span class="udiff-line-added">+      * @param dst general purpose register. May not be null or stackpointer.</span>
<span class="udiff-line-added">+      * @param src1 general purpose register. May not be null or stackpointer.</span>
<span class="udiff-line-added">+      * @param src2 general purpose register. May not be null or stackpointer.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public void orn(int size, Register dst, Register src1, Register src2) {</span>
<span class="udiff-line-added">+         super.orn(size, dst, src1, src2, ShiftType.LSL, 0);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /**
       * dst = ~src.
       *
       * @param size register size. Has to be 32 or 64.
       * @param dst general purpose register. May not be null or stackpointer.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2057,42 +2289,80 @@</span>
          cnt(fixedSize, vreg, vreg);
          addv(fixedSize, SIMDElementSize.Byte, vreg, vreg);
          umov(fixedSize, dst, 0, vreg);
      }
  
<span class="udiff-line-removed">-     public interface MacroInstruction {</span>
<span class="udiff-line-removed">-         void patch(int codePos, int relative, byte[] code);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      /**
       * Emits elf patchable adrp ldr sequence.
       */
      public void adrpLdr(int srcSize, Register result, AArch64Address a) {
          if (codePatchingAnnotationConsumer != null) {
<span class="udiff-line-modified-removed">-             codePatchingAnnotationConsumer.accept(new AdrpLdrMacroInstruction(position()));</span>
<span class="udiff-line-modified-added">+             codePatchingAnnotationConsumer.accept(new AdrpLdrMacroInstruction(position(), srcSize));</span>
          }
          super.adrp(a.getBase());
          this.ldr(srcSize, result, a);
      }
  
<span class="udiff-line-modified-removed">-     public static class AdrpLdrMacroInstruction extends CodeAnnotation implements MacroInstruction {</span>
<span class="udiff-line-modified-removed">-         public AdrpLdrMacroInstruction(int position) {</span>
<span class="udiff-line-modified-added">+     public static class AdrpLdrMacroInstruction extends AArch64Assembler.PatchableCodeAnnotation {</span>
<span class="udiff-line-modified-added">+         public final int srcSize;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public AdrpLdrMacroInstruction(int position, int srcSize) {</span>
              super(position);
<span class="udiff-line-added">+             this.srcSize = srcSize;</span>
          }
  
          @Override
          public String toString() {
              return &quot;ADRP_LDR&quot;;
          }
  
          @Override
          public void patch(int codePos, int relative, byte[] code) {
<span class="udiff-line-modified-removed">-             throw GraalError.unimplemented();</span>
<span class="udiff-line-modified-added">+             int shiftSize = 0;</span>
<span class="udiff-line-added">+             switch (srcSize) {</span>
<span class="udiff-line-added">+                 case 64:</span>
<span class="udiff-line-added">+                     shiftSize = 3;</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 case 32:</span>
<span class="udiff-line-added">+                     shiftSize = 2;</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 case 16:</span>
<span class="udiff-line-added">+                     shiftSize = 1;</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 case 8:</span>
<span class="udiff-line-added">+                     shiftSize = 0;</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 default:</span>
<span class="udiff-line-added">+                     assert false : &quot;srcSize must be either 8, 16, 32, or 64&quot;;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             int pos = instructionPosition;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             int targetAddress = pos + relative;</span>
<span class="udiff-line-added">+             assert shiftSize == 0 || (targetAddress &amp; ((1 &lt;&lt; shiftSize) - 1)) == 0 : &quot;shift bits must be zero&quot;;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             int relativePageDifference = PatcherUtil.computeRelativePageDifference(targetAddress, pos, 1 &lt;&lt; 12);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             // adrp imm_hi bits</span>
<span class="udiff-line-added">+             int curValue = (relativePageDifference &gt;&gt; 2) &amp; 0x7FFFF;</span>
<span class="udiff-line-added">+             int[] adrHiBits = {3, 8, 8};</span>
<span class="udiff-line-added">+             int[] adrHiOffsets = {5, 0, 0};</span>
<span class="udiff-line-added">+             PatcherUtil.writeBitSequence(code, pos, curValue, adrHiBits, adrHiOffsets);</span>
<span class="udiff-line-added">+             // adrp imm_lo bits</span>
<span class="udiff-line-added">+             curValue = relativePageDifference &amp; 0x3;</span>
<span class="udiff-line-added">+             int[] adrLoBits = {2};</span>
<span class="udiff-line-added">+             int[] adrLoOffsets = {5};</span>
<span class="udiff-line-added">+             PatcherUtil.writeBitSequence(code, pos + 3, curValue, adrLoBits, adrLoOffsets);</span>
<span class="udiff-line-added">+             // ldr bits</span>
<span class="udiff-line-added">+             curValue = (targetAddress &gt;&gt; shiftSize) &amp; 0x1FF;</span>
<span class="udiff-line-added">+             int[] ldrBits = {6, 6};</span>
<span class="udiff-line-added">+             int[] ldrOffsets = {2, 0};</span>
<span class="udiff-line-added">+             PatcherUtil.writeBitSequence(code, pos + 5, curValue, ldrBits, ldrOffsets);</span>
          }
      }
  
<span class="udiff-line-modified-removed">-     public static class AdrpAddMacroInstruction extends CodeAnnotation implements MacroInstruction {</span>
<span class="udiff-line-modified-added">+     public static class AdrpAddMacroInstruction extends AArch64Assembler.PatchableCodeAnnotation {</span>
          public AdrpAddMacroInstruction(int position) {
              super(position);
          }
  
          @Override
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2100,9 +2370,96 @@</span>
              return &quot;ADRP_ADD&quot;;
          }
  
          @Override
          public void patch(int codePos, int relative, byte[] code) {
<span class="udiff-line-modified-removed">-             throw GraalError.unimplemented();</span>
<span class="udiff-line-modified-added">+             int pos = instructionPosition;</span>
<span class="udiff-line-added">+             int targetAddress = pos + relative;</span>
<span class="udiff-line-added">+             int relativePageDifference = PatcherUtil.computeRelativePageDifference(targetAddress, pos, 1 &lt;&lt; 12);</span>
<span class="udiff-line-added">+             // adrp imm_hi bits</span>
<span class="udiff-line-added">+             int curValue = (relativePageDifference &gt;&gt; 2) &amp; 0x7FFFF;</span>
<span class="udiff-line-added">+             int[] adrHiBits = {3, 8, 8};</span>
<span class="udiff-line-added">+             int[] adrHiOffsets = {5, 0, 0};</span>
<span class="udiff-line-added">+             PatcherUtil.writeBitSequence(code, pos, curValue, adrHiBits, adrHiOffsets);</span>
<span class="udiff-line-added">+             // adrp imm_lo bits</span>
<span class="udiff-line-added">+             curValue = relativePageDifference &amp; 0x3;</span>
<span class="udiff-line-added">+             int[] adrLoBits = {2};</span>
<span class="udiff-line-added">+             int[] adrLoOffsets = {5};</span>
<span class="udiff-line-added">+             PatcherUtil.writeBitSequence(code, pos + 3, curValue, adrLoBits, adrLoOffsets);</span>
<span class="udiff-line-added">+             // add bits</span>
<span class="udiff-line-added">+             curValue = targetAddress &amp; 0xFFF;</span>
<span class="udiff-line-added">+             int[] addBits = {6, 6};</span>
<span class="udiff-line-added">+             int[] addOffsets = {2, 0};</span>
<span class="udiff-line-added">+             PatcherUtil.writeBitSequence(code, pos + 5, curValue, addBits, addOffsets);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private void annotateImmediateMovSequence(int pos, MovSequenceAnnotation.MovAction[] includeSet) {</span>
<span class="udiff-line-added">+         if (codePatchingAnnotationConsumer != null) {</span>
<span class="udiff-line-added">+             codePatchingAnnotationConsumer.accept(new MovSequenceAnnotation(pos, includeSet));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public static class MovSequenceAnnotation extends AArch64Assembler.PatchableCodeAnnotation {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /**</span>
<span class="udiff-line-added">+          * An enum to indicate how each 16-bit immediate chunk is represented within a sequence of</span>
<span class="udiff-line-added">+          * mov instructions.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         public enum MovAction {</span>
<span class="udiff-line-added">+             USED, // mov instruction is in place for this chunk.</span>
<span class="udiff-line-added">+             SKIPPED, // no mov instruction is in place for this chunk.</span>
<span class="udiff-line-added">+             NEGATED; // movn instruction is in place for this chunk.</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /**</span>
<span class="udiff-line-added">+          * The size of the operand, in bytes.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         public final MovAction[] includeSet;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         MovSequenceAnnotation(int instructionPosition, MovAction[] includeSet) {</span>
<span class="udiff-line-added">+             super(instructionPosition);</span>
<span class="udiff-line-added">+             this.includeSet = includeSet;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public String toString() {</span>
<span class="udiff-line-added">+             return &quot;MOV_SEQ&quot;;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public void patch(int codePos, int relative, byte[] code) {</span>
<span class="udiff-line-added">+             /*</span>
<span class="udiff-line-added">+              * Each move has a 16 bit immediate operand. We use a series of shifted moves to</span>
<span class="udiff-line-added">+              * represent immediate values larger than 16 bits.</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             int curValue = relative;</span>
<span class="udiff-line-added">+             int[] bitsUsed = {3, 8, 5};</span>
<span class="udiff-line-added">+             int[] offsets = {5, 0, 0};</span>
<span class="udiff-line-added">+             int siteOffset = 0;</span>
<span class="udiff-line-added">+             boolean containsNegatedMov = false;</span>
<span class="udiff-line-added">+             for (MovAction include : includeSet) {</span>
<span class="udiff-line-added">+                 if (include == MovAction.NEGATED) {</span>
<span class="udiff-line-added">+                     containsNegatedMov = true;</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             for (int i = 0; i &lt; includeSet.length; i++) {</span>
<span class="udiff-line-added">+                 int value = curValue &amp; 0xFFFF;</span>
<span class="udiff-line-added">+                 curValue = curValue &gt;&gt; 16;</span>
<span class="udiff-line-added">+                 switch (includeSet[i]) {</span>
<span class="udiff-line-added">+                     case USED:</span>
<span class="udiff-line-added">+                         break;</span>
<span class="udiff-line-added">+                     case SKIPPED:</span>
<span class="udiff-line-added">+                         assert value == (containsNegatedMov ? 0xFFFF : 0) : &quot;Unable to patch this value.&quot;;</span>
<span class="udiff-line-added">+                         continue;</span>
<span class="udiff-line-added">+                     case NEGATED:</span>
<span class="udiff-line-added">+                         value = value ^ 0xFFFF;</span>
<span class="udiff-line-added">+                         break;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 int bytePosition = instructionPosition + siteOffset;</span>
<span class="udiff-line-added">+                 PatcherUtil.writeBitSequence(code, bytePosition, value, bitsUsed, offsets);</span>
<span class="udiff-line-added">+                 siteOffset += 4;</span>
<span class="udiff-line-added">+             }</span>
          }
      }
  }
</pre>
<center><a href="AArch64Assembler.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../org.graalvm.compiler.asm.amd64/src/org/graalvm/compiler/asm/amd64/AMD64Address.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
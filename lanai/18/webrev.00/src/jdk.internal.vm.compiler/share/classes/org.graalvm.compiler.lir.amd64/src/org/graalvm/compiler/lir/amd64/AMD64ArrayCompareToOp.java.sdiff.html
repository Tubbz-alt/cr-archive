<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64ArrayCompareToOp.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AMD64Arithmetic.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64ArrayEqualsOp.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64ArrayCompareToOp.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 31 import static jdk.vm.ci.code.ValueUtil.asRegister;
 32 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.ILLEGAL;
 33 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;
 34 
 35 import java.util.EnumSet;
 36 
 37 import org.graalvm.compiler.asm.Label;
 38 import org.graalvm.compiler.asm.amd64.AMD64Address;
 39 import org.graalvm.compiler.asm.amd64.AMD64Address.Scale;
 40 import org.graalvm.compiler.asm.amd64.AMD64Assembler.ConditionFlag;
 41 import org.graalvm.compiler.asm.amd64.AMD64MacroAssembler;
 42 import org.graalvm.compiler.core.common.LIRKind;
 43 import org.graalvm.compiler.lir.LIRInstructionClass;
 44 import org.graalvm.compiler.lir.Opcode;
 45 import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
 46 import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
 47 
 48 import jdk.vm.ci.amd64.AMD64;
 49 import jdk.vm.ci.amd64.AMD64.CPUFeature;
 50 import jdk.vm.ci.amd64.AMD64Kind;

 51 import jdk.vm.ci.code.Register;
 52 import jdk.vm.ci.code.TargetDescription;
 53 import jdk.vm.ci.meta.JavaKind;
 54 import jdk.vm.ci.meta.Value;
 55 
 56 /**
 57  * Emits code which compares two arrays lexicographically. If the CPU supports any vector
 58  * instructions specialized code is emitted to leverage these instructions.
 59  */
 60 @Opcode(&quot;ARRAY_COMPARE_TO&quot;)
 61 public final class AMD64ArrayCompareToOp extends AMD64LIRInstruction {
 62     public static final LIRInstructionClass&lt;AMD64ArrayCompareToOp&gt; TYPE = LIRInstructionClass.create(AMD64ArrayCompareToOp.class);
 63 
 64     private final JavaKind kind1;
 65     private final JavaKind kind2;
 66     private final int array1BaseOffset;
 67     private final int array2BaseOffset;
 68 


 69     @Def({REG}) protected Value resultValue;
 70     @Alive({REG}) protected Value array1Value;
 71     @Alive({REG}) protected Value array2Value;
 72     @Use({REG}) protected Value length1Value;
 73     @Use({REG}) protected Value length2Value;
 74     @Temp({REG}) protected Value length1ValueTemp;
 75     @Temp({REG}) protected Value length2ValueTemp;
 76     @Temp({REG}) protected Value temp1;
 77     @Temp({REG}) protected Value temp2;
 78 
 79     @Temp({REG, ILLEGAL}) protected Value vectorTemp1;
 80 
<span class="line-modified"> 81     public AMD64ArrayCompareToOp(LIRGeneratorTool tool, JavaKind kind1, JavaKind kind2, Value result, Value array1, Value array2, Value length1, Value length2) {</span>
 82         super(TYPE);



 83         this.kind1 = kind1;
 84         this.kind2 = kind2;
 85 
 86         // Both offsets should be the same but better be safe than sorry.
 87         this.array1BaseOffset = tool.getProviders().getMetaAccess().getArrayBaseOffset(kind1);
 88         this.array2BaseOffset = tool.getProviders().getMetaAccess().getArrayBaseOffset(kind2);
 89 
 90         this.resultValue = result;
 91         this.array1Value = array1;
 92         this.array2Value = array2;
 93         /*
 94          * The length values are inputs but are also killed like temporaries so need both Use and
 95          * Temp annotations, which will only work with fixed registers.
 96          */
 97         this.length1Value = length1;
 98         this.length2Value = length2;
 99         this.length1ValueTemp = length1;
100         this.length2ValueTemp = length2;
101 
102         // Allocate some temporaries.
</pre>
<hr />
<pre>
155         AMD64Address.Scale scale2 = null;
156 
157         // if (ae != StrIntrinsicNode::LL) {
158         if (!(kind1 == JavaKind.Byte &amp;&amp; kind2 == JavaKind.Byte)) {
159             stride2x2 = 0x20;
160         }
161 
162         // if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {
163         if (kind1 != kind2) {
164             masm.shrl(cnt2, 1);
165         }
166         // Compute the minimum of the string lengths and the
167         // difference of the string lengths (stack).
168         // Do the conditional move stuff
169         masm.movl(result, cnt1);
170         masm.subl(cnt1, cnt2);
171         masm.push(cnt1);
172         masm.cmovl(ConditionFlag.LessEqual, cnt2, result);    // cnt2 = min(cnt1, cnt2)
173 
174         // Is the minimum length zero?
<span class="line-modified">175         masm.testl(cnt2, cnt2);</span>
<span class="line-modified">176         masm.jcc(ConditionFlag.Zero, LENGTH_DIFF_LABEL);</span>
177         // if (ae == StrIntrinsicNode::LL) {
178         if (kind1 == JavaKind.Byte &amp;&amp; kind2 == JavaKind.Byte) {
179             // Load first bytes
180             masm.movzbl(result, new AMD64Address(str1, 0));  // result = str1[0]
181             masm.movzbl(cnt1, new AMD64Address(str2, 0));    // cnt1 = str2[0]
182             // } else if (ae == StrIntrinsicNode::UU) {
183         } else if (kind1 == JavaKind.Char &amp;&amp; kind2 == JavaKind.Char) {
184             // Load first characters
185             masm.movzwl(result, new AMD64Address(str1, 0));
186             masm.movzwl(cnt1, new AMD64Address(str2, 0));
187         } else {
188             masm.movzbl(result, new AMD64Address(str1, 0));
189             masm.movzwl(cnt1, new AMD64Address(str2, 0));
190         }
<span class="line-modified">191         masm.subl(result, cnt1);</span>
<span class="line-removed">192         masm.jcc(ConditionFlag.NotZero, POP_LABEL);</span>
193 
194         // if (ae == StrIntrinsicNode::UU) {
195         if (kind1 == JavaKind.Char &amp;&amp; kind2 == JavaKind.Char) {
196             // Divide length by 2 to get number of chars
197             masm.shrl(cnt2, 1);
198         }
<span class="line-modified">199         masm.cmpl(cnt2, 1);</span>
<span class="line-removed">200         masm.jcc(ConditionFlag.Equal, LENGTH_DIFF_LABEL);</span>
201 
202         // Check if the strings start at the same location and setup scale and stride
203         // if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
204         if (kind1 == kind2) {
<span class="line-modified">205             masm.cmpptr(str1, str2);</span>
<span class="line-modified">206             masm.jcc(ConditionFlag.Equal, LENGTH_DIFF_LABEL);</span>
207             // if (ae == StrIntrinsicNode::LL) {
208             if (kind1 == JavaKind.Byte &amp;&amp; kind2 == JavaKind.Byte) {
209                 scale = AMD64Address.Scale.Times1;
210                 stride = 16;
211             } else {
212                 scale = AMD64Address.Scale.Times2;
213                 stride = 8;
214             }
215         } else {
216             scale1 = AMD64Address.Scale.Times1;
217             scale2 = AMD64Address.Scale.Times2;
218             // scale not used
219             stride = 8;
220         }
221 
222         // if (UseAVX &gt;= 2 &amp;&amp; UseSSE42Intrinsics) {
223         if (supportsAVX2(crb.target) &amp;&amp; supportsSSE42(crb.target)) {
224             Register vec1 = asRegister(vectorTemp1, AMD64Kind.DOUBLE);
225 
226             // Checkstyle: stop
</pre>
<hr />
<pre>
233             Label COMPARE_INDEX_CHAR = new Label();
234             Label COMPARE_WIDE_VECTORS_LOOP_AVX2 = new Label();
235             Label COMPARE_TAIL_LONG = new Label();
236             Label COMPARE_WIDE_VECTORS_LOOP_AVX3 = new Label();  // used only _LP64 &amp;&amp; AVX3
237             // Checkstyle: resume
238 
239             int pcmpmask = 0x19;
240             // if (ae == StrIntrinsicNode::LL) {
241             if (kind1 == JavaKind.Byte &amp;&amp; kind2 == JavaKind.Byte) {
242                 pcmpmask &amp;= ~0x01;
243             }
244 
245             // Setup to compare 16-chars (32-bytes) vectors,
246             // start from first character again because it has aligned address.
247             // if (ae == StrIntrinsicNode::LL) {
248             if (kind1 == JavaKind.Byte &amp;&amp; kind2 == JavaKind.Byte) {
249                 stride2 = 32;
250             } else {
251                 stride2 = 16;
252             }

253             // if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
254             if (kind1 == kind2) {
255                 adr_stride = stride &lt;&lt; scale.log2;
256             } else {
257                 adr_stride1 = 8;  // stride &lt;&lt; scale1;
258                 adr_stride2 = 16; // stride &lt;&lt; scale2;
259             }
260 
261             assert result.equals(rax) &amp;&amp; cnt2.equals(rdx) &amp;&amp; cnt1.equals(rcx) : &quot;pcmpestri&quot;;
262             // rax and rdx are used by pcmpestri as elements counters
263             masm.movl(result, cnt2);
<span class="line-modified">264             masm.andl(cnt2, ~(stride2 - 1));   // cnt2 holds the vector count</span>
<span class="line-removed">265             masm.jcc(ConditionFlag.Zero, COMPARE_TAIL_LONG);</span>
266 
267             // fast path : compare first 2 8-char vectors.
268             masm.bind(COMPARE_16_CHARS);
269             // if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
270             if (kind1 == kind2) {
271                 masm.movdqu(vec1, new AMD64Address(str1, 0));
272             } else {
273                 masm.pmovzxbw(vec1, new AMD64Address(str1, 0));
274             }
275             masm.pcmpestri(vec1, new AMD64Address(str2, 0), pcmpmask);
276             masm.jccb(ConditionFlag.Below, COMPARE_INDEX_CHAR);
277 
278             // if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
279             if (kind1 == kind2) {
280                 masm.movdqu(vec1, new AMD64Address(str1, adr_stride));
281                 masm.pcmpestri(vec1, new AMD64Address(str2, adr_stride), pcmpmask);
282             } else {
283                 masm.pmovzxbw(vec1, new AMD64Address(str1, adr_stride1));
284                 masm.pcmpestri(vec1, new AMD64Address(str2, adr_stride2), pcmpmask);
285             }
286             masm.jccb(ConditionFlag.AboveEqual, COMPARE_WIDE_VECTORS);
287             masm.addl(cnt1, stride);
288 
289             // Compare the characters at index in cnt1
290             masm.bind(COMPARE_INDEX_CHAR); // cnt1 has the offset of the mismatching character
291             loadNextElements(masm, result, cnt2, str1, str2, scale, scale1, scale2, cnt1);
292             masm.subl(result, cnt2);
293             masm.jmp(POP_LABEL);
294 
295             // Setup the registers to start vector comparison loop
296             masm.bind(COMPARE_WIDE_VECTORS);
297             // if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
298             if (kind1 == kind2) {
299                 masm.leaq(str1, new AMD64Address(str1, result, scale));
300                 masm.leaq(str2, new AMD64Address(str2, result, scale));
301             } else {
302                 masm.leaq(str1, new AMD64Address(str1, result, scale1));
303                 masm.leaq(str2, new AMD64Address(str2, result, scale2));
304             }
305             masm.subl(result, stride2);
<span class="line-modified">306             masm.subl(cnt2, stride2);</span>
<span class="line-removed">307             masm.jcc(ConditionFlag.Zero, COMPARE_WIDE_TAIL);</span>
308             masm.negq(result);
309 
310             // In a loop, compare 16-chars (32-bytes) at once using (vpxor+vptest)
311             masm.bind(COMPARE_WIDE_VECTORS_LOOP);
312 
313             // if (VM_Version::supports_avx512vlbw()) { // trying 64 bytes fast loop
<span class="line-modified">314             if (supportsAVX512VLBW(crb.target)) {</span>
<span class="line-modified">315                 masm.cmpl(cnt2, stride2x2);</span>
<span class="line-modified">316                 masm.jccb(ConditionFlag.Below, COMPARE_WIDE_VECTORS_LOOP_AVX2);</span>
<span class="line-modified">317                 masm.testl(cnt2, stride2x2 - 1);   // cnt2 holds the vector count</span>
<span class="line-removed">318                 // means we cannot subtract by 0x40</span>
<span class="line-removed">319                 masm.jccb(ConditionFlag.NotZero, COMPARE_WIDE_VECTORS_LOOP_AVX2);</span>
320 
321                 masm.bind(COMPARE_WIDE_VECTORS_LOOP_AVX3); // the hottest loop
322                 // if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
323                 if (kind1 == kind2) {
324                     masm.evmovdqu64(vec1, new AMD64Address(str1, result, scale));
325                     // k7 == 11..11, if operands equal, otherwise k7 has some 0
326                     masm.evpcmpeqb(k7, vec1, new AMD64Address(str2, result, scale));
327                 } else {
328                     masm.evpmovzxbw(vec1, new AMD64Address(str1, result, scale1));
329                     // k7 == 11..11, if operands equal, otherwise k7 has some 0
330                     masm.evpcmpeqb(k7, vec1, new AMD64Address(str2, result, scale2));
331                 }
332                 masm.kortestq(k7, k7);
<span class="line-modified">333                 masm.jcc(ConditionFlag.AboveEqual, COMPARE_WIDE_VECTORS_LOOP_FAILED);     // miscompare</span>
<span class="line-modified">334                 masm.addq(result, stride2x2);  // update since we already compared at this addr</span>
<span class="line-modified">335                 masm.subl(cnt2, stride2x2);      // and sub the size too</span>
<span class="line-modified">336                 masm.jccb(ConditionFlag.NotZero, COMPARE_WIDE_VECTORS_LOOP_AVX3);</span>
337 
338                 masm.vpxor(vec1, vec1, vec1);
339                 masm.jmpb(COMPARE_WIDE_TAIL);
340             }
341 
342             masm.bind(COMPARE_WIDE_VECTORS_LOOP_AVX2);
343             // if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
344             if (kind1 == kind2) {
345                 masm.vmovdqu(vec1, new AMD64Address(str1, result, scale));
346                 masm.vpxor(vec1, vec1, new AMD64Address(str2, result, scale));
347             } else {
348                 masm.vpmovzxbw(vec1, new AMD64Address(str1, result, scale1));
349                 masm.vpxor(vec1, vec1, new AMD64Address(str2, result, scale2));
350             }
351             masm.vptest(vec1, vec1);
352             masm.jcc(ConditionFlag.NotZero, VECTOR_NOT_EQUAL);
353             masm.addq(result, stride2);
<span class="line-modified">354             masm.subl(cnt2, stride2);</span>
<span class="line-removed">355             masm.jcc(ConditionFlag.NotZero, COMPARE_WIDE_VECTORS_LOOP);</span>
356             // clean upper bits of YMM registers
357             masm.vpxor(vec1, vec1, vec1);
358 
359             // compare wide vectors tail
360             masm.bind(COMPARE_WIDE_TAIL);
<span class="line-modified">361             masm.testq(result, result);</span>
<span class="line-removed">362             masm.jcc(ConditionFlag.Zero, LENGTH_DIFF_LABEL);</span>
363 
364             masm.movl(result, stride2);
365             masm.movl(cnt2, result);
366             masm.negq(result);
367             masm.jmp(COMPARE_WIDE_VECTORS_LOOP_AVX2);
368 
369             // Identifies the mismatching (higher or lower)16-bytes in the 32-byte vectors.
370             masm.bind(VECTOR_NOT_EQUAL);
371             // clean upper bits of YMM registers
372             masm.vpxor(vec1, vec1, vec1);
373             // if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
374             if (kind1 == kind2) {
375                 masm.leaq(str1, new AMD64Address(str1, result, scale));
376                 masm.leaq(str2, new AMD64Address(str2, result, scale));
377             } else {
378                 masm.leaq(str1, new AMD64Address(str1, result, scale1));
379                 masm.leaq(str2, new AMD64Address(str2, result, scale2));
380             }
381             masm.jmp(COMPARE_16_CHARS);
382 
383             // Compare tail chars, length between 1 to 15 chars
384             masm.bind(COMPARE_TAIL_LONG);
385             masm.movl(cnt2, result);
<span class="line-modified">386             masm.cmpl(cnt2, stride);</span>
<span class="line-removed">387             masm.jcc(ConditionFlag.Less, COMPARE_SMALL_STR);</span>
388 
389             // if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
390             if (kind1 == kind2) {
391                 masm.movdqu(vec1, new AMD64Address(str1, 0));
392             } else {
393                 masm.pmovzxbw(vec1, new AMD64Address(str1, 0));
394             }
395             masm.pcmpestri(vec1, new AMD64Address(str2, 0), pcmpmask);
396             masm.jcc(ConditionFlag.Below, COMPARE_INDEX_CHAR);
<span class="line-modified">397             masm.subq(cnt2, stride);</span>
<span class="line-removed">398             masm.jcc(ConditionFlag.Zero, LENGTH_DIFF_LABEL);</span>
399             // if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
400             if (kind1 == kind2) {
401                 masm.leaq(str1, new AMD64Address(str1, result, scale));
402                 masm.leaq(str2, new AMD64Address(str2, result, scale));
403             } else {
404                 masm.leaq(str1, new AMD64Address(str1, result, scale1));
405                 masm.leaq(str2, new AMD64Address(str2, result, scale2));
406             }
407             masm.negq(cnt2);
408             masm.jmpb(WHILE_HEAD_LABEL);
409 
410             masm.bind(COMPARE_SMALL_STR);
411         } else if (supportsSSE42(crb.target)) {
412             Register vec1 = asRegister(vectorTemp1, AMD64Kind.DOUBLE);
413 
414             // Checkstyle: stop
415             Label COMPARE_WIDE_VECTORS = new Label();
416             Label VECTOR_NOT_EQUAL = new Label();
417             Label COMPARE_TAIL = new Label();
418             // Checkstyle: resume
419             int pcmpmask = 0x19;
420             // Setup to compare 8-char (16-byte) vectors,
421             // start from first character again because it has aligned address.
422             masm.movl(result, cnt2);
<span class="line-removed">423             masm.andl(cnt2, ~(stride - 1));   // cnt2 holds the vector count</span>
424             // if (ae == StrIntrinsicNode::LL) {
425             if (kind1 == JavaKind.Byte &amp;&amp; kind2 == JavaKind.Byte) {
426                 pcmpmask &amp;= ~0x01;
427             }
<span class="line-modified">428             masm.jcc(ConditionFlag.Zero, COMPARE_TAIL);</span>
429             // if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
430             if (kind1 == kind2) {
431                 masm.leaq(str1, new AMD64Address(str1, result, scale));
432                 masm.leaq(str2, new AMD64Address(str2, result, scale));
433             } else {
434                 masm.leaq(str1, new AMD64Address(str1, result, scale1));
435                 masm.leaq(str2, new AMD64Address(str2, result, scale2));
436             }
437             masm.negq(result);
438 
439             // pcmpestri
440             // inputs:
441             // vec1- substring
442             // rax - negative string length (elements count)
443             // mem - scanned string
444             // rdx - string length (elements count)
445             // pcmpmask - cmp mode: 11000 (string compare with negated result)
446             // + 00 (unsigned bytes) or + 01 (unsigned shorts)
447             // outputs:
448             // rcx - first mismatched element index
449             assert result.equals(rax) &amp;&amp; cnt2.equals(rdx) &amp;&amp; cnt1.equals(rcx) : &quot;pcmpestri&quot;;
450 
451             masm.bind(COMPARE_WIDE_VECTORS);
452             // if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
453             if (kind1 == kind2) {
454                 masm.movdqu(vec1, new AMD64Address(str1, result, scale));
455                 masm.pcmpestri(vec1, new AMD64Address(str2, result, scale), pcmpmask);
456             } else {
457                 masm.pmovzxbw(vec1, new AMD64Address(str1, result, scale1));
458                 masm.pcmpestri(vec1, new AMD64Address(str2, result, scale2), pcmpmask);
459             }
460             // After pcmpestri cnt1(rcx) contains mismatched element index
461 
462             masm.jccb(ConditionFlag.Below, VECTOR_NOT_EQUAL);  // CF==1
463             masm.addq(result, stride);
<span class="line-modified">464             masm.subq(cnt2, stride);</span>
<span class="line-removed">465             masm.jccb(ConditionFlag.NotZero, COMPARE_WIDE_VECTORS);</span>
466 
467             // compare wide vectors tail
<span class="line-modified">468             masm.testq(result, result);</span>
<span class="line-removed">469             masm.jcc(ConditionFlag.Zero, LENGTH_DIFF_LABEL);</span>
470 
471             masm.movl(cnt2, stride);
472             masm.movl(result, stride);
473             masm.negq(result);
474             // if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
475             if (kind1 == kind2) {
476                 masm.movdqu(vec1, new AMD64Address(str1, result, scale));
477                 masm.pcmpestri(vec1, new AMD64Address(str2, result, scale), pcmpmask);
478             } else {
479                 masm.pmovzxbw(vec1, new AMD64Address(str1, result, scale1));
480                 masm.pcmpestri(vec1, new AMD64Address(str2, result, scale2), pcmpmask);
481             }
482             masm.jccb(ConditionFlag.AboveEqual, LENGTH_DIFF_LABEL);
483 
484             // Mismatched characters in the vectors
485             masm.bind(VECTOR_NOT_EQUAL);
486             masm.addq(cnt1, result);
487             loadNextElements(masm, result, cnt2, str1, str2, scale, scale1, scale2, cnt1);
488             masm.subl(result, cnt2);
489             masm.jmpb(POP_LABEL);
</pre>
<hr />
<pre>
491             masm.bind(COMPARE_TAIL); // limit is zero
492             masm.movl(cnt2, result);
493             // Fallthru to tail compare
494         }
495 
496         // Shift str2 and str1 to the end of the arrays, negate min
497         // if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
498         if (kind1 == kind2) {
499             masm.leaq(str1, new AMD64Address(str1, cnt2, scale));
500             masm.leaq(str2, new AMD64Address(str2, cnt2, scale));
501         } else {
502             masm.leaq(str1, new AMD64Address(str1, cnt2, scale1));
503             masm.leaq(str2, new AMD64Address(str2, cnt2, scale2));
504         }
505         masm.decrementl(cnt2);  // first character was compared already
506         masm.negq(cnt2);
507 
508         // Compare the rest of the elements
509         masm.bind(WHILE_HEAD_LABEL);
510         loadNextElements(masm, result, cnt1, str1, str2, scale, scale1, scale2, cnt2);
<span class="line-modified">511         masm.subl(result, cnt1);</span>
<span class="line-modified">512         masm.jccb(ConditionFlag.NotZero, POP_LABEL);</span>
<span class="line-removed">513         masm.incrementq(cnt2, 1);</span>
<span class="line-removed">514         masm.jccb(ConditionFlag.NotZero, WHILE_HEAD_LABEL);</span>
515 
516         // Strings are equal up to min length. Return the length difference.
517         masm.bind(LENGTH_DIFF_LABEL);
518         masm.pop(result);
519         // if (ae == StrIntrinsicNode::UU) {
520         if (kind1 == JavaKind.Char &amp;&amp; kind2 == JavaKind.Char) {
521             // Divide diff by 2 to get number of chars
522             masm.sarl(result, 1);
523         }
524         masm.jmpb(DONE_LABEL);
525 
526         // if (VM_Version::supports_avx512vlbw()) {
527         if (supportsAVX512VLBW(crb.target)) {
528             masm.bind(COMPARE_WIDE_VECTORS_LOOP_FAILED);
529 
530             masm.kmovq(cnt1, k7);
531             masm.notq(cnt1);
532             masm.bsfq(cnt2, cnt1);
533             // if (ae != StrIntrinsicNode::LL) {
534             if (!(kind1 == JavaKind.Byte &amp;&amp; kind2 == JavaKind.Byte)) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 31 import static jdk.vm.ci.code.ValueUtil.asRegister;
 32 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.ILLEGAL;
 33 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;
 34 
 35 import java.util.EnumSet;
 36 
 37 import org.graalvm.compiler.asm.Label;
 38 import org.graalvm.compiler.asm.amd64.AMD64Address;
 39 import org.graalvm.compiler.asm.amd64.AMD64Address.Scale;
 40 import org.graalvm.compiler.asm.amd64.AMD64Assembler.ConditionFlag;
 41 import org.graalvm.compiler.asm.amd64.AMD64MacroAssembler;
 42 import org.graalvm.compiler.core.common.LIRKind;
 43 import org.graalvm.compiler.lir.LIRInstructionClass;
 44 import org.graalvm.compiler.lir.Opcode;
 45 import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
 46 import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
 47 
 48 import jdk.vm.ci.amd64.AMD64;
 49 import jdk.vm.ci.amd64.AMD64.CPUFeature;
 50 import jdk.vm.ci.amd64.AMD64Kind;
<span class="line-added"> 51 import jdk.vm.ci.code.CodeUtil;</span>
 52 import jdk.vm.ci.code.Register;
 53 import jdk.vm.ci.code.TargetDescription;
 54 import jdk.vm.ci.meta.JavaKind;
 55 import jdk.vm.ci.meta.Value;
 56 
 57 /**
 58  * Emits code which compares two arrays lexicographically. If the CPU supports any vector
 59  * instructions specialized code is emitted to leverage these instructions.
 60  */
 61 @Opcode(&quot;ARRAY_COMPARE_TO&quot;)
 62 public final class AMD64ArrayCompareToOp extends AMD64LIRInstruction {
 63     public static final LIRInstructionClass&lt;AMD64ArrayCompareToOp&gt; TYPE = LIRInstructionClass.create(AMD64ArrayCompareToOp.class);
 64 
 65     private final JavaKind kind1;
 66     private final JavaKind kind2;
 67     private final int array1BaseOffset;
 68     private final int array2BaseOffset;
 69 
<span class="line-added"> 70     private final int useAVX3Threshold;</span>
<span class="line-added"> 71 </span>
 72     @Def({REG}) protected Value resultValue;
 73     @Alive({REG}) protected Value array1Value;
 74     @Alive({REG}) protected Value array2Value;
 75     @Use({REG}) protected Value length1Value;
 76     @Use({REG}) protected Value length2Value;
 77     @Temp({REG}) protected Value length1ValueTemp;
 78     @Temp({REG}) protected Value length2ValueTemp;
 79     @Temp({REG}) protected Value temp1;
 80     @Temp({REG}) protected Value temp2;
 81 
 82     @Temp({REG, ILLEGAL}) protected Value vectorTemp1;
 83 
<span class="line-modified"> 84     public AMD64ArrayCompareToOp(LIRGeneratorTool tool, int useAVX3Threshold, JavaKind kind1, JavaKind kind2, Value result, Value array1, Value array2, Value length1, Value length2) {</span>
 85         super(TYPE);
<span class="line-added"> 86 </span>
<span class="line-added"> 87         assert CodeUtil.isPowerOf2(useAVX3Threshold) : &quot;AVX3Threshold must be power of 2&quot;;</span>
<span class="line-added"> 88         this.useAVX3Threshold = useAVX3Threshold;</span>
 89         this.kind1 = kind1;
 90         this.kind2 = kind2;
 91 
 92         // Both offsets should be the same but better be safe than sorry.
 93         this.array1BaseOffset = tool.getProviders().getMetaAccess().getArrayBaseOffset(kind1);
 94         this.array2BaseOffset = tool.getProviders().getMetaAccess().getArrayBaseOffset(kind2);
 95 
 96         this.resultValue = result;
 97         this.array1Value = array1;
 98         this.array2Value = array2;
 99         /*
100          * The length values are inputs but are also killed like temporaries so need both Use and
101          * Temp annotations, which will only work with fixed registers.
102          */
103         this.length1Value = length1;
104         this.length2Value = length2;
105         this.length1ValueTemp = length1;
106         this.length2ValueTemp = length2;
107 
108         // Allocate some temporaries.
</pre>
<hr />
<pre>
161         AMD64Address.Scale scale2 = null;
162 
163         // if (ae != StrIntrinsicNode::LL) {
164         if (!(kind1 == JavaKind.Byte &amp;&amp; kind2 == JavaKind.Byte)) {
165             stride2x2 = 0x20;
166         }
167 
168         // if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {
169         if (kind1 != kind2) {
170             masm.shrl(cnt2, 1);
171         }
172         // Compute the minimum of the string lengths and the
173         // difference of the string lengths (stack).
174         // Do the conditional move stuff
175         masm.movl(result, cnt1);
176         masm.subl(cnt1, cnt2);
177         masm.push(cnt1);
178         masm.cmovl(ConditionFlag.LessEqual, cnt2, result);    // cnt2 = min(cnt1, cnt2)
179 
180         // Is the minimum length zero?
<span class="line-modified">181         masm.testlAndJcc(cnt2, cnt2, ConditionFlag.Zero, LENGTH_DIFF_LABEL, false);</span>
<span class="line-modified">182 </span>
183         // if (ae == StrIntrinsicNode::LL) {
184         if (kind1 == JavaKind.Byte &amp;&amp; kind2 == JavaKind.Byte) {
185             // Load first bytes
186             masm.movzbl(result, new AMD64Address(str1, 0));  // result = str1[0]
187             masm.movzbl(cnt1, new AMD64Address(str2, 0));    // cnt1 = str2[0]
188             // } else if (ae == StrIntrinsicNode::UU) {
189         } else if (kind1 == JavaKind.Char &amp;&amp; kind2 == JavaKind.Char) {
190             // Load first characters
191             masm.movzwl(result, new AMD64Address(str1, 0));
192             masm.movzwl(cnt1, new AMD64Address(str2, 0));
193         } else {
194             masm.movzbl(result, new AMD64Address(str1, 0));
195             masm.movzwl(cnt1, new AMD64Address(str2, 0));
196         }
<span class="line-modified">197         masm.sublAndJcc(result, cnt1, ConditionFlag.NotZero, POP_LABEL, false);</span>

198 
199         // if (ae == StrIntrinsicNode::UU) {
200         if (kind1 == JavaKind.Char &amp;&amp; kind2 == JavaKind.Char) {
201             // Divide length by 2 to get number of chars
202             masm.shrl(cnt2, 1);
203         }
<span class="line-modified">204         masm.cmplAndJcc(cnt2, 1, ConditionFlag.Equal, LENGTH_DIFF_LABEL, false);</span>

205 
206         // Check if the strings start at the same location and setup scale and stride
207         // if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
208         if (kind1 == kind2) {
<span class="line-modified">209             masm.cmpqAndJcc(str1, str2, ConditionFlag.Equal, LENGTH_DIFF_LABEL, false);</span>
<span class="line-modified">210 </span>
211             // if (ae == StrIntrinsicNode::LL) {
212             if (kind1 == JavaKind.Byte &amp;&amp; kind2 == JavaKind.Byte) {
213                 scale = AMD64Address.Scale.Times1;
214                 stride = 16;
215             } else {
216                 scale = AMD64Address.Scale.Times2;
217                 stride = 8;
218             }
219         } else {
220             scale1 = AMD64Address.Scale.Times1;
221             scale2 = AMD64Address.Scale.Times2;
222             // scale not used
223             stride = 8;
224         }
225 
226         // if (UseAVX &gt;= 2 &amp;&amp; UseSSE42Intrinsics) {
227         if (supportsAVX2(crb.target) &amp;&amp; supportsSSE42(crb.target)) {
228             Register vec1 = asRegister(vectorTemp1, AMD64Kind.DOUBLE);
229 
230             // Checkstyle: stop
</pre>
<hr />
<pre>
237             Label COMPARE_INDEX_CHAR = new Label();
238             Label COMPARE_WIDE_VECTORS_LOOP_AVX2 = new Label();
239             Label COMPARE_TAIL_LONG = new Label();
240             Label COMPARE_WIDE_VECTORS_LOOP_AVX3 = new Label();  // used only _LP64 &amp;&amp; AVX3
241             // Checkstyle: resume
242 
243             int pcmpmask = 0x19;
244             // if (ae == StrIntrinsicNode::LL) {
245             if (kind1 == JavaKind.Byte &amp;&amp; kind2 == JavaKind.Byte) {
246                 pcmpmask &amp;= ~0x01;
247             }
248 
249             // Setup to compare 16-chars (32-bytes) vectors,
250             // start from first character again because it has aligned address.
251             // if (ae == StrIntrinsicNode::LL) {
252             if (kind1 == JavaKind.Byte &amp;&amp; kind2 == JavaKind.Byte) {
253                 stride2 = 32;
254             } else {
255                 stride2 = 16;
256             }
<span class="line-added">257 </span>
258             // if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
259             if (kind1 == kind2) {
260                 adr_stride = stride &lt;&lt; scale.log2;
261             } else {
262                 adr_stride1 = 8;  // stride &lt;&lt; scale1;
263                 adr_stride2 = 16; // stride &lt;&lt; scale2;
264             }
265 
266             assert result.equals(rax) &amp;&amp; cnt2.equals(rdx) &amp;&amp; cnt1.equals(rcx) : &quot;pcmpestri&quot;;
267             // rax and rdx are used by pcmpestri as elements counters
268             masm.movl(result, cnt2);
<span class="line-modified">269             masm.andlAndJcc(cnt2, ~(stride2 - 1), ConditionFlag.Zero, COMPARE_TAIL_LONG, false);</span>

270 
271             // fast path : compare first 2 8-char vectors.
272             masm.bind(COMPARE_16_CHARS);
273             // if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
274             if (kind1 == kind2) {
275                 masm.movdqu(vec1, new AMD64Address(str1, 0));
276             } else {
277                 masm.pmovzxbw(vec1, new AMD64Address(str1, 0));
278             }
279             masm.pcmpestri(vec1, new AMD64Address(str2, 0), pcmpmask);
280             masm.jccb(ConditionFlag.Below, COMPARE_INDEX_CHAR);
281 
282             // if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
283             if (kind1 == kind2) {
284                 masm.movdqu(vec1, new AMD64Address(str1, adr_stride));
285                 masm.pcmpestri(vec1, new AMD64Address(str2, adr_stride), pcmpmask);
286             } else {
287                 masm.pmovzxbw(vec1, new AMD64Address(str1, adr_stride1));
288                 masm.pcmpestri(vec1, new AMD64Address(str2, adr_stride2), pcmpmask);
289             }
290             masm.jccb(ConditionFlag.AboveEqual, COMPARE_WIDE_VECTORS);
291             masm.addl(cnt1, stride);
292 
293             // Compare the characters at index in cnt1
294             masm.bind(COMPARE_INDEX_CHAR); // cnt1 has the offset of the mismatching character
295             loadNextElements(masm, result, cnt2, str1, str2, scale, scale1, scale2, cnt1);
296             masm.subl(result, cnt2);
297             masm.jmp(POP_LABEL);
298 
299             // Setup the registers to start vector comparison loop
300             masm.bind(COMPARE_WIDE_VECTORS);
301             // if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
302             if (kind1 == kind2) {
303                 masm.leaq(str1, new AMD64Address(str1, result, scale));
304                 masm.leaq(str2, new AMD64Address(str2, result, scale));
305             } else {
306                 masm.leaq(str1, new AMD64Address(str1, result, scale1));
307                 masm.leaq(str2, new AMD64Address(str2, result, scale2));
308             }
309             masm.subl(result, stride2);
<span class="line-modified">310             masm.sublAndJcc(cnt2, stride2, ConditionFlag.Zero, COMPARE_WIDE_TAIL, false);</span>

311             masm.negq(result);
312 
313             // In a loop, compare 16-chars (32-bytes) at once using (vpxor+vptest)
314             masm.bind(COMPARE_WIDE_VECTORS_LOOP);
315 
316             // if (VM_Version::supports_avx512vlbw()) { // trying 64 bytes fast loop
<span class="line-modified">317             if (useAVX3Threshold == 0 &amp;&amp; supportsAVX512VLBW(crb.target)) {</span>
<span class="line-modified">318                 masm.cmplAndJcc(cnt2, stride2x2, ConditionFlag.Below, COMPARE_WIDE_VECTORS_LOOP_AVX2, true);</span>
<span class="line-modified">319                 // cnt2 holds the vector, not-zero means we cannot subtract by 0x40</span>
<span class="line-modified">320                 masm.testlAndJcc(cnt2, stride2x2 - 1, ConditionFlag.NotZero, COMPARE_WIDE_VECTORS_LOOP_AVX2, true);</span>


321 
322                 masm.bind(COMPARE_WIDE_VECTORS_LOOP_AVX3); // the hottest loop
323                 // if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
324                 if (kind1 == kind2) {
325                     masm.evmovdqu64(vec1, new AMD64Address(str1, result, scale));
326                     // k7 == 11..11, if operands equal, otherwise k7 has some 0
327                     masm.evpcmpeqb(k7, vec1, new AMD64Address(str2, result, scale));
328                 } else {
329                     masm.evpmovzxbw(vec1, new AMD64Address(str1, result, scale1));
330                     // k7 == 11..11, if operands equal, otherwise k7 has some 0
331                     masm.evpcmpeqb(k7, vec1, new AMD64Address(str2, result, scale2));
332                 }
333                 masm.kortestq(k7, k7);
<span class="line-modified">334                 masm.jcc(ConditionFlag.AboveEqual, COMPARE_WIDE_VECTORS_LOOP_FAILED); // miscompare</span>
<span class="line-modified">335                 masm.addq(result, stride2x2); // update since we already compared at this addr</span>
<span class="line-modified">336                 // and sub the size too</span>
<span class="line-modified">337                 masm.sublAndJcc(cnt2, stride2x2, ConditionFlag.NotZero, COMPARE_WIDE_VECTORS_LOOP_AVX3, true);</span>
338 
339                 masm.vpxor(vec1, vec1, vec1);
340                 masm.jmpb(COMPARE_WIDE_TAIL);
341             }
342 
343             masm.bind(COMPARE_WIDE_VECTORS_LOOP_AVX2);
344             // if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
345             if (kind1 == kind2) {
346                 masm.vmovdqu(vec1, new AMD64Address(str1, result, scale));
347                 masm.vpxor(vec1, vec1, new AMD64Address(str2, result, scale));
348             } else {
349                 masm.vpmovzxbw(vec1, new AMD64Address(str1, result, scale1));
350                 masm.vpxor(vec1, vec1, new AMD64Address(str2, result, scale2));
351             }
352             masm.vptest(vec1, vec1);
353             masm.jcc(ConditionFlag.NotZero, VECTOR_NOT_EQUAL);
354             masm.addq(result, stride2);
<span class="line-modified">355             masm.sublAndJcc(cnt2, stride2, ConditionFlag.NotZero, COMPARE_WIDE_VECTORS_LOOP, false);</span>

356             // clean upper bits of YMM registers
357             masm.vpxor(vec1, vec1, vec1);
358 
359             // compare wide vectors tail
360             masm.bind(COMPARE_WIDE_TAIL);
<span class="line-modified">361             masm.testqAndJcc(result, result, ConditionFlag.Zero, LENGTH_DIFF_LABEL, false);</span>

362 
363             masm.movl(result, stride2);
364             masm.movl(cnt2, result);
365             masm.negq(result);
366             masm.jmp(COMPARE_WIDE_VECTORS_LOOP_AVX2);
367 
368             // Identifies the mismatching (higher or lower)16-bytes in the 32-byte vectors.
369             masm.bind(VECTOR_NOT_EQUAL);
370             // clean upper bits of YMM registers
371             masm.vpxor(vec1, vec1, vec1);
372             // if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
373             if (kind1 == kind2) {
374                 masm.leaq(str1, new AMD64Address(str1, result, scale));
375                 masm.leaq(str2, new AMD64Address(str2, result, scale));
376             } else {
377                 masm.leaq(str1, new AMD64Address(str1, result, scale1));
378                 masm.leaq(str2, new AMD64Address(str2, result, scale2));
379             }
380             masm.jmp(COMPARE_16_CHARS);
381 
382             // Compare tail chars, length between 1 to 15 chars
383             masm.bind(COMPARE_TAIL_LONG);
384             masm.movl(cnt2, result);
<span class="line-modified">385             masm.cmplAndJcc(cnt2, stride, ConditionFlag.Less, COMPARE_SMALL_STR, false);</span>

386 
387             // if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
388             if (kind1 == kind2) {
389                 masm.movdqu(vec1, new AMD64Address(str1, 0));
390             } else {
391                 masm.pmovzxbw(vec1, new AMD64Address(str1, 0));
392             }
393             masm.pcmpestri(vec1, new AMD64Address(str2, 0), pcmpmask);
394             masm.jcc(ConditionFlag.Below, COMPARE_INDEX_CHAR);
<span class="line-modified">395             masm.subqAndJcc(cnt2, stride, ConditionFlag.Zero, LENGTH_DIFF_LABEL, false);</span>

396             // if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
397             if (kind1 == kind2) {
398                 masm.leaq(str1, new AMD64Address(str1, result, scale));
399                 masm.leaq(str2, new AMD64Address(str2, result, scale));
400             } else {
401                 masm.leaq(str1, new AMD64Address(str1, result, scale1));
402                 masm.leaq(str2, new AMD64Address(str2, result, scale2));
403             }
404             masm.negq(cnt2);
405             masm.jmpb(WHILE_HEAD_LABEL);
406 
407             masm.bind(COMPARE_SMALL_STR);
408         } else if (supportsSSE42(crb.target)) {
409             Register vec1 = asRegister(vectorTemp1, AMD64Kind.DOUBLE);
410 
411             // Checkstyle: stop
412             Label COMPARE_WIDE_VECTORS = new Label();
413             Label VECTOR_NOT_EQUAL = new Label();
414             Label COMPARE_TAIL = new Label();
415             // Checkstyle: resume
416             int pcmpmask = 0x19;
417             // Setup to compare 8-char (16-byte) vectors,
418             // start from first character again because it has aligned address.
419             masm.movl(result, cnt2);

420             // if (ae == StrIntrinsicNode::LL) {
421             if (kind1 == JavaKind.Byte &amp;&amp; kind2 == JavaKind.Byte) {
422                 pcmpmask &amp;= ~0x01;
423             }
<span class="line-modified">424             masm.andlAndJcc(cnt2, ~(stride - 1), ConditionFlag.Zero, COMPARE_TAIL, false);</span>
425             // if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
426             if (kind1 == kind2) {
427                 masm.leaq(str1, new AMD64Address(str1, result, scale));
428                 masm.leaq(str2, new AMD64Address(str2, result, scale));
429             } else {
430                 masm.leaq(str1, new AMD64Address(str1, result, scale1));
431                 masm.leaq(str2, new AMD64Address(str2, result, scale2));
432             }
433             masm.negq(result);
434 
435             // pcmpestri
436             // inputs:
437             // vec1- substring
438             // rax - negative string length (elements count)
439             // mem - scanned string
440             // rdx - string length (elements count)
441             // pcmpmask - cmp mode: 11000 (string compare with negated result)
442             // + 00 (unsigned bytes) or + 01 (unsigned shorts)
443             // outputs:
444             // rcx - first mismatched element index
445             assert result.equals(rax) &amp;&amp; cnt2.equals(rdx) &amp;&amp; cnt1.equals(rcx) : &quot;pcmpestri&quot;;
446 
447             masm.bind(COMPARE_WIDE_VECTORS);
448             // if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
449             if (kind1 == kind2) {
450                 masm.movdqu(vec1, new AMD64Address(str1, result, scale));
451                 masm.pcmpestri(vec1, new AMD64Address(str2, result, scale), pcmpmask);
452             } else {
453                 masm.pmovzxbw(vec1, new AMD64Address(str1, result, scale1));
454                 masm.pcmpestri(vec1, new AMD64Address(str2, result, scale2), pcmpmask);
455             }
456             // After pcmpestri cnt1(rcx) contains mismatched element index
457 
458             masm.jccb(ConditionFlag.Below, VECTOR_NOT_EQUAL);  // CF==1
459             masm.addq(result, stride);
<span class="line-modified">460             masm.subqAndJcc(cnt2, stride, ConditionFlag.NotZero, COMPARE_WIDE_VECTORS, true);</span>

461 
462             // compare wide vectors tail
<span class="line-modified">463             masm.testqAndJcc(result, result, ConditionFlag.Zero, LENGTH_DIFF_LABEL, false);</span>

464 
465             masm.movl(cnt2, stride);
466             masm.movl(result, stride);
467             masm.negq(result);
468             // if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
469             if (kind1 == kind2) {
470                 masm.movdqu(vec1, new AMD64Address(str1, result, scale));
471                 masm.pcmpestri(vec1, new AMD64Address(str2, result, scale), pcmpmask);
472             } else {
473                 masm.pmovzxbw(vec1, new AMD64Address(str1, result, scale1));
474                 masm.pcmpestri(vec1, new AMD64Address(str2, result, scale2), pcmpmask);
475             }
476             masm.jccb(ConditionFlag.AboveEqual, LENGTH_DIFF_LABEL);
477 
478             // Mismatched characters in the vectors
479             masm.bind(VECTOR_NOT_EQUAL);
480             masm.addq(cnt1, result);
481             loadNextElements(masm, result, cnt2, str1, str2, scale, scale1, scale2, cnt1);
482             masm.subl(result, cnt2);
483             masm.jmpb(POP_LABEL);
</pre>
<hr />
<pre>
485             masm.bind(COMPARE_TAIL); // limit is zero
486             masm.movl(cnt2, result);
487             // Fallthru to tail compare
488         }
489 
490         // Shift str2 and str1 to the end of the arrays, negate min
491         // if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
492         if (kind1 == kind2) {
493             masm.leaq(str1, new AMD64Address(str1, cnt2, scale));
494             masm.leaq(str2, new AMD64Address(str2, cnt2, scale));
495         } else {
496             masm.leaq(str1, new AMD64Address(str1, cnt2, scale1));
497             masm.leaq(str2, new AMD64Address(str2, cnt2, scale2));
498         }
499         masm.decrementl(cnt2);  // first character was compared already
500         masm.negq(cnt2);
501 
502         // Compare the rest of the elements
503         masm.bind(WHILE_HEAD_LABEL);
504         loadNextElements(masm, result, cnt1, str1, str2, scale, scale1, scale2, cnt2);
<span class="line-modified">505         masm.sublAndJcc(result, cnt1, ConditionFlag.NotZero, POP_LABEL, true);</span>
<span class="line-modified">506         masm.incqAndJcc(cnt2, ConditionFlag.NotZero, WHILE_HEAD_LABEL, true);</span>


507 
508         // Strings are equal up to min length. Return the length difference.
509         masm.bind(LENGTH_DIFF_LABEL);
510         masm.pop(result);
511         // if (ae == StrIntrinsicNode::UU) {
512         if (kind1 == JavaKind.Char &amp;&amp; kind2 == JavaKind.Char) {
513             // Divide diff by 2 to get number of chars
514             masm.sarl(result, 1);
515         }
516         masm.jmpb(DONE_LABEL);
517 
518         // if (VM_Version::supports_avx512vlbw()) {
519         if (supportsAVX512VLBW(crb.target)) {
520             masm.bind(COMPARE_WIDE_VECTORS_LOOP_FAILED);
521 
522             masm.kmovq(cnt1, k7);
523             masm.notq(cnt1);
524             masm.bsfq(cnt2, cnt1);
525             // if (ae != StrIntrinsicNode::LL) {
526             if (!(kind1 == JavaKind.Byte &amp;&amp; kind2 == JavaKind.Byte)) {
</pre>
</td>
</tr>
</table>
<center><a href="AMD64Arithmetic.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64ArrayEqualsOp.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
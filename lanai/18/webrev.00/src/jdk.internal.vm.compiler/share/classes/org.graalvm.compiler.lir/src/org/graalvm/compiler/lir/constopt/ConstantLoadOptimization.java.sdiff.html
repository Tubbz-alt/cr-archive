<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/constopt/ConstantLoadOptimization.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../asm/CompilationResultBuilder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../dfa/MarkBasePointersPhase.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/constopt/ConstantLoadOptimization.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.lir.constopt;
 26 
 27 import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;
 28 import static org.graalvm.compiler.lir.phases.LIRPhase.Options.LIROptimization;
 29 
 30 import java.util.ArrayDeque;
 31 import java.util.ArrayList;
 32 import java.util.BitSet;
 33 import java.util.Collections;
 34 import java.util.Deque;
 35 import java.util.EnumSet;
 36 import java.util.List;
 37 

 38 import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
 39 import org.graalvm.compiler.core.common.cfg.BlockMap;
 40 import org.graalvm.compiler.debug.CounterKey;
 41 import org.graalvm.compiler.debug.DebugContext;
 42 import org.graalvm.compiler.debug.Indent;
 43 import org.graalvm.compiler.lir.InstructionValueConsumer;
 44 import org.graalvm.compiler.lir.LIR;
 45 import org.graalvm.compiler.lir.LIRInsertionBuffer;
 46 import org.graalvm.compiler.lir.LIRInstruction;
 47 import org.graalvm.compiler.lir.LIRInstruction.OperandFlag;
 48 import org.graalvm.compiler.lir.LIRInstruction.OperandMode;
 49 import org.graalvm.compiler.lir.StandardOp.LoadConstantOp;
 50 import org.graalvm.compiler.lir.ValueConsumer;
 51 import org.graalvm.compiler.lir.Variable;
 52 import org.graalvm.compiler.lir.constopt.ConstantTree.Flags;
 53 import org.graalvm.compiler.lir.constopt.ConstantTree.NodeCost;
 54 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
 55 import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
 56 import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase;
 57 import org.graalvm.compiler.options.NestedBooleanOptionKey;
 58 import org.graalvm.compiler.options.Option;
 59 import org.graalvm.compiler.options.OptionType;
 60 
 61 import jdk.vm.ci.code.TargetDescription;

 62 import jdk.vm.ci.meta.Constant;
 63 import jdk.vm.ci.meta.Value;
 64 import jdk.vm.ci.meta.ValueKind;
 65 
 66 /**
 67  * This optimization tries to improve the handling of constants by replacing a single definition of
 68  * a constant, which is potentially scheduled into a block with high frequency, with one or more
 69  * definitions in blocks with a lower frequency.
 70  */
 71 public final class ConstantLoadOptimization extends PreAllocationOptimizationPhase {
 72 
 73     public static class Options {
 74         // @formatter:off
 75         @Option(help = &quot;Enable constant load optimization.&quot;, type = OptionType.Debug)
 76         public static final NestedBooleanOptionKey LIROptConstantLoadOptimization = new NestedBooleanOptionKey(LIROptimization, true);
 77         // @formatter:on
 78     }
 79 
 80     @Override
 81     protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PreAllocationOptimizationContext context) {
 82         LIRGeneratorTool lirGen = context.lirGen;
 83         new Optimization(lirGenRes.getLIR(), lirGen).apply();
 84     }
 85 
 86     private static final CounterKey constantsTotal = DebugContext.counter(&quot;ConstantLoadOptimization[total]&quot;);
 87     private static final CounterKey phiConstantsSkipped = DebugContext.counter(&quot;ConstantLoadOptimization[PhisSkipped]&quot;);
 88     private static final CounterKey singleUsageConstantsSkipped = DebugContext.counter(&quot;ConstantLoadOptimization[SingleUsageSkipped]&quot;);
 89     private static final CounterKey usageAtDefinitionSkipped = DebugContext.counter(&quot;ConstantLoadOptimization[UsageAtDefinitionSkipped]&quot;);

 90     private static final CounterKey materializeAtDefinitionSkipped = DebugContext.counter(&quot;ConstantLoadOptimization[MaterializeAtDefinitionSkipped]&quot;);
 91     private static final CounterKey constantsOptimized = DebugContext.counter(&quot;ConstantLoadOptimization[optimized]&quot;);
 92 
 93     private static final class Optimization {
 94         private final LIR lir;
 95         private final LIRGeneratorTool lirGen;
 96         private final VariableMap&lt;DefUseTree&gt; map;
 97         private final BitSet phiConstants;
 98         private final BitSet defined;
 99         private final BlockMap&lt;List&lt;UseEntry&gt;&gt; blockMap;
100         private final BlockMap&lt;LIRInsertionBuffer&gt; insertionBuffers;
101         private final DebugContext debug;
102 
103         private Optimization(LIR lir, LIRGeneratorTool lirGen) {
104             this.lir = lir;
105             this.debug = lir.getDebug();
106             this.lirGen = lirGen;
107             this.map = new VariableMap&lt;&gt;();
108             this.phiConstants = new BitSet();
109             this.defined = new BitSet();
</pre>
<hr />
<pre>
182         private void addUsageToBlockMap(UseEntry entry) {
183             AbstractBlockBase&lt;?&gt; block = entry.getBlock();
184             List&lt;UseEntry&gt; list = blockMap.get(block);
185             if (list == null) {
186                 list = new ArrayList&lt;&gt;();
187                 blockMap.put(block, list);
188             }
189             list.add(entry);
190         }
191 
192         /**
193          * Collects def-use information for a {@code block}.
194          */
195         @SuppressWarnings(&quot;try&quot;)
196         private void analyzeBlock(AbstractBlockBase&lt;?&gt; block) {
197             try (Indent indent = debug.logAndIndent(&quot;Block: %s&quot;, block)) {
198 
199                 InstructionValueConsumer loadConsumer = (instruction, value, mode, flags) -&gt; {
200                     if (isVariable(value)) {
201                         Variable var = (Variable) value;
<span class="line-modified">202 </span>










203                         if (!phiConstants.get(var.index)) {
204                             if (!defined.get(var.index)) {
205                                 defined.set(var.index);
206                                 if (isConstantLoad(instruction)) {
207                                     debug.log(&quot;constant load: %s&quot;, instruction);
208                                     map.put(var, new DefUseTree(instruction, block));
209                                     constantsTotal.increment(debug);
210                                 }
211                             } else {
212                                 // Variable is redefined, this only happens for constant loads
213                                 // introduced by phi resolution -&gt; ignore.
214                                 DefUseTree removed = map.remove(var);
215                                 if (removed != null) {
216                                     phiConstantsSkipped.increment(debug);
217                                 }
218                                 phiConstants.set(var.index);
219                                 debug.log(DebugContext.VERBOSE_LEVEL, &quot;Removing phi variable: %s&quot;, var);
220                             }
221                         } else {
222                             assert defined.get(var.index) : &quot;phi but not defined? &quot; + var;
</pre>
<hr />
<pre>
232                             if (tree != null) {
233                                 tree.addUsage(block, instruction, value);
234                                 debug.log(&quot;usage of %s : %s&quot;, var, instruction);
235                             }
236                         }
237                     }
238                 };
239 
240                 int opId = 0;
241                 for (LIRInstruction inst : lir.getLIRforBlock(block)) {
242                     // set instruction id to the index in the lir instruction list
243                     inst.setId(opId++);
244                     inst.visitEachOutput(loadConsumer);
245                     inst.visitEachInput(useConsumer);
246                     inst.visitEachAlive(useConsumer);
247 
248                 }
249             }
250         }
251 









252         /**
253          * Creates the dominator tree and searches for an solution.
254          */
255         @SuppressWarnings(&quot;try&quot;)
256         private void createConstantTree(DefUseTree tree) {
257             ConstantTree constTree = new ConstantTree(lir.getControlFlowGraph(), tree);
258             constTree.set(Flags.SUBTREE, tree.getBlock());
259             tree.forEach(u -&gt; constTree.set(Flags.USAGE, u.getBlock()));
260 
261             if (constTree.get(Flags.USAGE, tree.getBlock())) {
262                 // usage in the definition block -&gt; no optimization
263                 usageAtDefinitionSkipped.increment(debug);
264                 return;
265             }
266 
267             constTree.markBlocks();
268 
269             NodeCost cost = ConstantTreeAnalyzer.analyze(debug, constTree, tree.getBlock());
270             int usageCount = cost.getUsages().size();
271             assert usageCount == tree.usageCount() : &quot;Usage count differs: &quot; + usageCount + &quot; vs. &quot; + tree.usageCount();
</pre>
</td>
<td>
<hr />
<pre>
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.lir.constopt;
 26 
 27 import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;
 28 import static org.graalvm.compiler.lir.phases.LIRPhase.Options.LIROptimization;
 29 
 30 import java.util.ArrayDeque;
 31 import java.util.ArrayList;
 32 import java.util.BitSet;
 33 import java.util.Collections;
 34 import java.util.Deque;
 35 import java.util.EnumSet;
 36 import java.util.List;
 37 
<span class="line-added"> 38 import org.graalvm.compiler.core.common.LIRKind;</span>
 39 import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
 40 import org.graalvm.compiler.core.common.cfg.BlockMap;
 41 import org.graalvm.compiler.debug.CounterKey;
 42 import org.graalvm.compiler.debug.DebugContext;
 43 import org.graalvm.compiler.debug.Indent;
 44 import org.graalvm.compiler.lir.InstructionValueConsumer;
 45 import org.graalvm.compiler.lir.LIR;
 46 import org.graalvm.compiler.lir.LIRInsertionBuffer;
 47 import org.graalvm.compiler.lir.LIRInstruction;
 48 import org.graalvm.compiler.lir.LIRInstruction.OperandFlag;
 49 import org.graalvm.compiler.lir.LIRInstruction.OperandMode;
 50 import org.graalvm.compiler.lir.StandardOp.LoadConstantOp;
 51 import org.graalvm.compiler.lir.ValueConsumer;
 52 import org.graalvm.compiler.lir.Variable;
 53 import org.graalvm.compiler.lir.constopt.ConstantTree.Flags;
 54 import org.graalvm.compiler.lir.constopt.ConstantTree.NodeCost;
 55 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
 56 import org.graalvm.compiler.lir.gen.LIRGeneratorTool;
 57 import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase;
 58 import org.graalvm.compiler.options.NestedBooleanOptionKey;
 59 import org.graalvm.compiler.options.Option;
 60 import org.graalvm.compiler.options.OptionType;
 61 
 62 import jdk.vm.ci.code.TargetDescription;
<span class="line-added"> 63 import jdk.vm.ci.meta.AllocatableValue;</span>
 64 import jdk.vm.ci.meta.Constant;
 65 import jdk.vm.ci.meta.Value;
 66 import jdk.vm.ci.meta.ValueKind;
 67 
 68 /**
 69  * This optimization tries to improve the handling of constants by replacing a single definition of
 70  * a constant, which is potentially scheduled into a block with high frequency, with one or more
 71  * definitions in blocks with a lower frequency.
 72  */
 73 public final class ConstantLoadOptimization extends PreAllocationOptimizationPhase {
 74 
 75     public static class Options {
 76         // @formatter:off
 77         @Option(help = &quot;Enable constant load optimization.&quot;, type = OptionType.Debug)
 78         public static final NestedBooleanOptionKey LIROptConstantLoadOptimization = new NestedBooleanOptionKey(LIROptimization, true);
 79         // @formatter:on
 80     }
 81 
 82     @Override
 83     protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PreAllocationOptimizationContext context) {
 84         LIRGeneratorTool lirGen = context.lirGen;
 85         new Optimization(lirGenRes.getLIR(), lirGen).apply();
 86     }
 87 
 88     private static final CounterKey constantsTotal = DebugContext.counter(&quot;ConstantLoadOptimization[total]&quot;);
 89     private static final CounterKey phiConstantsSkipped = DebugContext.counter(&quot;ConstantLoadOptimization[PhisSkipped]&quot;);
 90     private static final CounterKey singleUsageConstantsSkipped = DebugContext.counter(&quot;ConstantLoadOptimization[SingleUsageSkipped]&quot;);
 91     private static final CounterKey usageAtDefinitionSkipped = DebugContext.counter(&quot;ConstantLoadOptimization[UsageAtDefinitionSkipped]&quot;);
<span class="line-added"> 92     private static final CounterKey basePointerUsagesSkipped = DebugContext.counter(&quot;ConstantLoadOptimization[BasePointerUsagesSkipped]&quot;);</span>
 93     private static final CounterKey materializeAtDefinitionSkipped = DebugContext.counter(&quot;ConstantLoadOptimization[MaterializeAtDefinitionSkipped]&quot;);
 94     private static final CounterKey constantsOptimized = DebugContext.counter(&quot;ConstantLoadOptimization[optimized]&quot;);
 95 
 96     private static final class Optimization {
 97         private final LIR lir;
 98         private final LIRGeneratorTool lirGen;
 99         private final VariableMap&lt;DefUseTree&gt; map;
100         private final BitSet phiConstants;
101         private final BitSet defined;
102         private final BlockMap&lt;List&lt;UseEntry&gt;&gt; blockMap;
103         private final BlockMap&lt;LIRInsertionBuffer&gt; insertionBuffers;
104         private final DebugContext debug;
105 
106         private Optimization(LIR lir, LIRGeneratorTool lirGen) {
107             this.lir = lir;
108             this.debug = lir.getDebug();
109             this.lirGen = lirGen;
110             this.map = new VariableMap&lt;&gt;();
111             this.phiConstants = new BitSet();
112             this.defined = new BitSet();
</pre>
<hr />
<pre>
185         private void addUsageToBlockMap(UseEntry entry) {
186             AbstractBlockBase&lt;?&gt; block = entry.getBlock();
187             List&lt;UseEntry&gt; list = blockMap.get(block);
188             if (list == null) {
189                 list = new ArrayList&lt;&gt;();
190                 blockMap.put(block, list);
191             }
192             list.add(entry);
193         }
194 
195         /**
196          * Collects def-use information for a {@code block}.
197          */
198         @SuppressWarnings(&quot;try&quot;)
199         private void analyzeBlock(AbstractBlockBase&lt;?&gt; block) {
200             try (Indent indent = debug.logAndIndent(&quot;Block: %s&quot;, block)) {
201 
202                 InstructionValueConsumer loadConsumer = (instruction, value, mode, flags) -&gt; {
203                     if (isVariable(value)) {
204                         Variable var = (Variable) value;
<span class="line-modified">205                         AllocatableValue base = getBasePointer(var);</span>
<span class="line-added">206                         if (base != null &amp;&amp; base instanceof Variable) {</span>
<span class="line-added">207                             if (map.remove((Variable) base) != null) {</span>
<span class="line-added">208                                 // We do not want optimize constants which are used as base</span>
<span class="line-added">209                                 // pointer. The reason is that it would require to update all</span>
<span class="line-added">210                                 // the derived Variables (LIRKind and so on)</span>
<span class="line-added">211                                 map.remove(var);</span>
<span class="line-added">212                                 basePointerUsagesSkipped.increment(debug);</span>
<span class="line-added">213                                 debug.log(&quot;skip optimizing %s because it is used as base pointer&quot;, base);</span>
<span class="line-added">214                             }</span>
<span class="line-added">215                         }</span>
216                         if (!phiConstants.get(var.index)) {
217                             if (!defined.get(var.index)) {
218                                 defined.set(var.index);
219                                 if (isConstantLoad(instruction)) {
220                                     debug.log(&quot;constant load: %s&quot;, instruction);
221                                     map.put(var, new DefUseTree(instruction, block));
222                                     constantsTotal.increment(debug);
223                                 }
224                             } else {
225                                 // Variable is redefined, this only happens for constant loads
226                                 // introduced by phi resolution -&gt; ignore.
227                                 DefUseTree removed = map.remove(var);
228                                 if (removed != null) {
229                                     phiConstantsSkipped.increment(debug);
230                                 }
231                                 phiConstants.set(var.index);
232                                 debug.log(DebugContext.VERBOSE_LEVEL, &quot;Removing phi variable: %s&quot;, var);
233                             }
234                         } else {
235                             assert defined.get(var.index) : &quot;phi but not defined? &quot; + var;
</pre>
<hr />
<pre>
245                             if (tree != null) {
246                                 tree.addUsage(block, instruction, value);
247                                 debug.log(&quot;usage of %s : %s&quot;, var, instruction);
248                             }
249                         }
250                     }
251                 };
252 
253                 int opId = 0;
254                 for (LIRInstruction inst : lir.getLIRforBlock(block)) {
255                     // set instruction id to the index in the lir instruction list
256                     inst.setId(opId++);
257                     inst.visitEachOutput(loadConsumer);
258                     inst.visitEachInput(useConsumer);
259                     inst.visitEachAlive(useConsumer);
260 
261                 }
262             }
263         }
264 
<span class="line-added">265         private static AllocatableValue getBasePointer(Value value) {</span>
<span class="line-added">266             ValueKind&lt;?&gt; kind = value.getValueKind();</span>
<span class="line-added">267             if (kind instanceof LIRKind) {</span>
<span class="line-added">268                 return ((LIRKind) kind).getDerivedReferenceBase();</span>
<span class="line-added">269             } else {</span>
<span class="line-added">270                 return null;</span>
<span class="line-added">271             }</span>
<span class="line-added">272         }</span>
<span class="line-added">273 </span>
274         /**
275          * Creates the dominator tree and searches for an solution.
276          */
277         @SuppressWarnings(&quot;try&quot;)
278         private void createConstantTree(DefUseTree tree) {
279             ConstantTree constTree = new ConstantTree(lir.getControlFlowGraph(), tree);
280             constTree.set(Flags.SUBTREE, tree.getBlock());
281             tree.forEach(u -&gt; constTree.set(Flags.USAGE, u.getBlock()));
282 
283             if (constTree.get(Flags.USAGE, tree.getBlock())) {
284                 // usage in the definition block -&gt; no optimization
285                 usageAtDefinitionSkipped.increment(debug);
286                 return;
287             }
288 
289             constTree.markBlocks();
290 
291             NodeCost cost = ConstantTreeAnalyzer.analyze(debug, constTree, tree.getBlock());
292             int usageCount = cost.getUsages().size();
293             assert usageCount == tree.usageCount() : &quot;Usage count differs: &quot; + usageCount + &quot; vs. &quot; + tree.usageCount();
</pre>
</td>
</tr>
</table>
<center><a href="../asm/CompilationResultBuilder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../dfa/MarkBasePointersPhase.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/alloc/lsra/LinearScanLifetimeAnalysisPhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.lir.alloc.lsra;
 26 
 27 import static jdk.vm.ci.code.ValueUtil.asRegister;
 28 import static jdk.vm.ci.code.ValueUtil.asStackSlot;
 29 import static jdk.vm.ci.code.ValueUtil.isRegister;
 30 import static jdk.vm.ci.code.ValueUtil.isStackSlot;
 31 import static org.graalvm.compiler.lir.LIRValueUtil.asVariable;
 32 import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;
 33 import static org.graalvm.compiler.lir.debug.LIRGenerationDebugContext.getSourceForOperandFromDebugContext;
 34 
 35 import java.util.ArrayDeque;
 36 import java.util.ArrayList;
 37 import java.util.BitSet;
 38 import java.util.EnumSet;
 39 
 40 import jdk.internal.vm.compiler.collections.EconomicSet;
 41 import jdk.internal.vm.compiler.collections.Equivalence;
 42 import org.graalvm.compiler.core.common.LIRKind;
 43 import org.graalvm.compiler.core.common.PermanentBailoutException;
 44 import org.graalvm.compiler.core.common.alloc.ComputeBlockOrder;
 45 import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;
 46 import org.graalvm.compiler.core.common.util.BitMap2D;
 47 import org.graalvm.compiler.debug.Assertions;
 48 import org.graalvm.compiler.debug.DebugContext;
 49 import org.graalvm.compiler.debug.GraalError;
 50 import org.graalvm.compiler.debug.Indent;
 51 import org.graalvm.compiler.lir.InstructionStateProcedure;
 52 import org.graalvm.compiler.lir.InstructionValueConsumer;
 53 import org.graalvm.compiler.lir.LIRInstruction;
 54 import org.graalvm.compiler.lir.LIRInstruction.OperandFlag;
 55 import org.graalvm.compiler.lir.LIRInstruction.OperandMode;
 56 import org.graalvm.compiler.lir.StandardOp.LoadConstantOp;
 57 import org.graalvm.compiler.lir.StandardOp.ValueMoveOp;
 58 import org.graalvm.compiler.lir.ValueConsumer;
 59 import org.graalvm.compiler.lir.alloc.lsra.Interval.RegisterPriority;
 60 import org.graalvm.compiler.lir.alloc.lsra.Interval.SpillState;
 61 import org.graalvm.compiler.lir.alloc.lsra.LinearScan.BlockData;
 62 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
 63 import org.graalvm.compiler.lir.phases.AllocationPhase.AllocationContext;
 64 
 65 import jdk.vm.ci.code.Register;
 66 import jdk.vm.ci.code.RegisterArray;
 67 import jdk.vm.ci.code.StackSlot;
 68 import jdk.vm.ci.code.TargetDescription;
 69 import jdk.vm.ci.meta.AllocatableValue;
 70 import jdk.vm.ci.meta.Constant;
 71 import jdk.vm.ci.meta.JavaConstant;
 72 import jdk.vm.ci.meta.Value;
 73 import jdk.vm.ci.meta.ValueKind;
 74 import org.graalvm.compiler.lir.util.IndexedValueMap;
 75 
 76 public class LinearScanLifetimeAnalysisPhase extends LinearScanAllocationPhase {
 77 
 78     protected final LinearScan allocator;
 79     protected final DebugContext debug;
 80 
 81     /**
 82      * @param linearScan
 83      */
 84     protected LinearScanLifetimeAnalysisPhase(LinearScan linearScan) {
 85         allocator = linearScan;
 86         debug = allocator.getDebug();
 87     }
 88 
 89     @Override
 90     protected void run(TargetDescription target, LIRGenerationResult lirGenRes, AllocationContext context) {
 91         numberInstructions();
 92         debug.dump(DebugContext.VERBOSE_LEVEL, lirGenRes.getLIR(), &quot;Before register allocation&quot;);
 93         computeLocalLiveSets();
 94         computeGlobalLiveSets();
 95         buildIntervals(Assertions.detailedAssertionsEnabled(allocator.getOptions()));
 96     }
 97 
 98     /**
 99      * Bit set for each variable that is contained in each loop.
100      */
101     private BitMap2D intervalInLoop;
102 
103     boolean isIntervalInLoop(int interval, int loop) {
104         return intervalInLoop.at(interval, loop);
105     }
106 
107     /**
108      * Numbers all instructions in all blocks. The numbering follows the
109      * {@linkplain ComputeBlockOrder linear scan order}.
110      */
111     protected void numberInstructions() {
112 
113         allocator.initIntervals();
114 
115         ValueConsumer setVariableConsumer = (value, mode, flags) -&gt; {
116             if (isVariable(value)) {
117                 allocator.getOrCreateInterval(asVariable(value));
118             }
119         };
120 
121         // Assign IDs to LIR nodes and build a mapping, lirOps, from ID to LIRInstruction node.
122         int numInstructions = 0;
123         for (AbstractBlockBase&lt;?&gt; block : allocator.sortedBlocks()) {
124             numInstructions += allocator.getLIR().getLIRforBlock(block).size();
125         }
126 
127         // initialize with correct length
128         allocator.initOpIdMaps(numInstructions);
129 
130         int opId = 0;
131         int index = 0;
132         for (AbstractBlockBase&lt;?&gt; block : allocator.sortedBlocks()) {
133             allocator.initBlockData(block);
134 
135             ArrayList&lt;LIRInstruction&gt; instructions = allocator.getLIR().getLIRforBlock(block);
136 
137             int numInst = instructions.size();
138             for (int j = 0; j &lt; numInst; j++) {
139                 LIRInstruction op = instructions.get(j);
140                 op.setId(opId);
141 
142                 allocator.putOpIdMaps(index, op, block);
143                 assert allocator.instructionForId(opId) == op : &quot;must match&quot;;
144 
145                 op.visitEachTemp(setVariableConsumer);
146                 op.visitEachOutput(setVariableConsumer);
147 
148                 index++;
149                 opId += 2; // numbering of lirOps by two
150             }
151         }
152         assert index == numInstructions : &quot;must match&quot;;
153         assert (index &lt;&lt; 1) == opId : &quot;must match: &quot; + (index &lt;&lt; 1);
154     }
155 
156     /**
157      * Computes local live sets (i.e. {@link BlockData#liveGen} and {@link BlockData#liveKill})
158      * separately for each block.
159      */
160     @SuppressWarnings(&quot;try&quot;)
161     void computeLocalLiveSets() {
162         int liveSize = allocator.liveSetSize();
163 
164         intervalInLoop = new BitMap2D(allocator.operandSize(), allocator.numLoops());
165 
166         try {
167             final BitSet liveGenScratch = new BitSet(liveSize);
168             final BitSet liveKillScratch = new BitSet(liveSize);
169             // iterate all blocks
170             for (final AbstractBlockBase&lt;?&gt; block : allocator.sortedBlocks()) {
171                 try (Indent indent = debug.logAndIndent(&quot;compute local live sets for block %s&quot;, block)) {
172 
173                     liveGenScratch.clear();
174                     liveKillScratch.clear();
175 
176                     ArrayList&lt;LIRInstruction&gt; instructions = allocator.getLIR().getLIRforBlock(block);
177                     int numInst = instructions.size();
178 
179                     ValueConsumer useConsumer = (operand, mode, flags) -&gt; {
180                         if (isVariable(operand)) {
181                             int operandNum = getOperandNumber(operand);
182                             if (!liveKillScratch.get(operandNum)) {
183                                 liveGenScratch.set(operandNum);
184                                 if (debug.isLogEnabled()) {
185                                     debug.log(&quot;liveGen for operand %d(%s)&quot;, operandNum, operand);
186                                 }
187                             }
188                             if (block.getLoop() != null) {
189                                 intervalInLoop.setBit(operandNum, block.getLoop().getIndex());
190                             }
191                         }
192 
193                         if (allocator.detailedAsserts) {
194                             verifyInput(block, liveKillScratch, operand);
195                         }
196                     };
197                     ValueConsumer stateConsumer = (operand, mode, flags) -&gt; {
198                         if (LinearScan.isVariableOrRegister(operand)) {
199                             int operandNum = getOperandNumber(operand);
200                             if (!liveKillScratch.get(operandNum)) {
201                                 liveGenScratch.set(operandNum);
202                                 if (debug.isLogEnabled()) {
203                                     debug.log(&quot;liveGen in state for operand %d(%s)&quot;, operandNum, operand);
204                                 }
205                             }
206                         }
207                     };
208                     ValueConsumer defConsumer = (operand, mode, flags) -&gt; {
209                         if (isVariable(operand)) {
210                             int varNum = getOperandNumber(operand);
211                             liveKillScratch.set(varNum);
212                             if (debug.isLogEnabled()) {
213                                 debug.log(&quot;liveKill for operand %d(%s)&quot;, varNum, operand);
214                             }
215                             if (block.getLoop() != null) {
216                                 intervalInLoop.setBit(varNum, block.getLoop().getIndex());
217                             }
218                         }
219 
220                         if (allocator.detailedAsserts) {
221                             /*
222                              * Fixed intervals are never live at block boundaries, so they need not
223                              * be processed in live sets. Process them only in debug mode so that
224                              * this can be checked
225                              */
226                             verifyTemp(liveKillScratch, operand);
227                         }
228                     };
229 
230                     // iterate all instructions of the block
231                     for (int j = 0; j &lt; numInst; j++) {
232                         final LIRInstruction op = instructions.get(j);
233 
234                         try (Indent indent2 = debug.logAndIndent(&quot;handle op %d: %s&quot;, op.id(), op)) {
235                             op.visitEachInput(useConsumer);
236                             op.visitEachAlive(useConsumer);
237                             /*
238                              * Add uses of live locals from interpreter&#39;s point of view for proper
239                              * debug information generation.
240                              */
241                             op.visitEachState(stateConsumer);
242                             op.visitEachTemp(defConsumer);
243                             op.visitEachOutput(defConsumer);
244                         }
245                     } // end of instruction iteration
246 
247                     BlockData blockSets = allocator.getBlockData(block);
248                     blockSets.liveGen = trimClone(liveGenScratch);
249                     blockSets.liveKill = trimClone(liveKillScratch);
250                     // sticky size, will get non-sticky in computeGlobalLiveSets
251                     blockSets.liveIn = new BitSet(0);
252                     blockSets.liveOut = new BitSet(0);
253 
254                     if (debug.isLogEnabled()) {
255                         debug.log(&quot;liveGen  B%d %s&quot;, block.getId(), blockSets.liveGen);
256                         debug.log(&quot;liveKill B%d %s&quot;, block.getId(), blockSets.liveKill);
257                     }
258 
259                 }
260             } // end of block iteration
261         } catch (OutOfMemoryError oom) {
262             throw new PermanentBailoutException(oom, &quot;Out-of-memory during live set allocation of size %d&quot;, liveSize);
263         }
264     }
265 
266     private void verifyTemp(BitSet liveKill, Value operand) {
267         /*
268          * Fixed intervals are never live at block boundaries, so they need not be processed in live
269          * sets. Process them only in debug mode so that this can be checked
270          */
271         if (isRegister(operand)) {
272             if (allocator.isProcessed(operand)) {
273                 liveKill.set(getOperandNumber(operand));
274             }
275         }
276     }
277 
278     private void verifyInput(AbstractBlockBase&lt;?&gt; block, BitSet liveKill, Value operand) {
279         /*
280          * Fixed intervals are never live at block boundaries, so they need not be processed in live
281          * sets. This is checked by these assertions to be sure about it. The entry block may have
282          * incoming values in registers, which is ok.
283          */
284         if (isRegister(operand) &amp;&amp; block != allocator.getLIR().getControlFlowGraph().getStartBlock()) {
285             if (allocator.isProcessed(operand)) {
286                 assert liveKill.get(getOperandNumber(operand)) : &quot;using fixed register &quot; + asRegister(operand) + &quot; that is not defined in this block &quot; + block;
287             }
288         }
289     }
290 
291     protected int getOperandNumber(Value operand) {
292         return allocator.operandNumber(operand);
293     }
294 
295     /**
296      * Performs a backward dataflow analysis to compute global live sets (i.e.
297      * {@link BlockData#liveIn} and {@link BlockData#liveOut}) for each block.
298      */
299     @SuppressWarnings(&quot;try&quot;)
300     protected void computeGlobalLiveSets() {
301         try (Indent indent = debug.logAndIndent(&quot;compute global live sets&quot;)) {
302             int numBlocks = allocator.blockCount();
303             boolean changeOccurred;
304             boolean changeOccurredInBlock;
305             int iterationCount = 0;
306             BitSet scratch = new BitSet(allocator.liveSetSize()); // scratch set for calculations
307 
308             /*
309              * Perform a backward dataflow analysis to compute liveOut and liveIn for each block.
310              * The loop is executed until a fixpoint is reached (no changes in an iteration).
311              */
312             do {
313                 changeOccurred = false;
314 
315                 try (Indent indent2 = debug.logAndIndent(&quot;new iteration %d&quot;, iterationCount)) {
316 
317                     // iterate all blocks in reverse order
318                     for (int i = numBlocks - 1; i &gt;= 0; i--) {
319                         AbstractBlockBase&lt;?&gt; block = allocator.blockAt(i);
320                         BlockData blockSets = allocator.getBlockData(block);
321 
322                         changeOccurredInBlock = false;
323 
324                         /*
325                          * liveOut(block) is the union of liveIn(sux), for successors sux of block.
326                          */
327                         int n = block.getSuccessorCount();
328                         if (n &gt; 0) {
329                             scratch.clear();
330                             // block has successors
331                             if (n &gt; 0) {
332                                 for (AbstractBlockBase&lt;?&gt; successor : block.getSuccessors()) {
333                                     scratch.or(allocator.getBlockData(successor).liveIn);
334                                 }
335                             }
336 
337                             if (!blockSets.liveOut.equals(scratch)) {
338                                 blockSets.liveOut = trimClone(scratch);
339 
340                                 changeOccurred = true;
341                                 changeOccurredInBlock = true;
342                             }
343                         }
344 
345                         if (iterationCount == 0 || changeOccurredInBlock) {
346                             /*
347                              * liveIn(block) is the union of liveGen(block) with (liveOut(block) &amp;
348                              * !liveKill(block)).
349                              *
350                              * Note: liveIn has to be computed only in first iteration or if liveOut
351                              * has changed!
352                              *
353                              * Note: liveIn set can only grow, never shrink. No need to clear it.
354                              */
355                             BitSet liveIn = blockSets.liveIn;
356                             /*
357                              * BitSet#or will call BitSet#ensureSize (since the bit set is of length
358                              * 0 initially) and set sticky to false
359                              */
360                             liveIn.or(blockSets.liveOut);
361                             liveIn.andNot(blockSets.liveKill);
362                             liveIn.or(blockSets.liveGen);
363 
364                             liveIn.clone(); // trimToSize()
365 
366                             if (debug.isLogEnabled()) {
367                                 debug.log(&quot;block %d: livein = %s,  liveout = %s&quot;, block.getId(), liveIn, blockSets.liveOut);
368                             }
369                         }
370                     }
371                     iterationCount++;
372 
373                     if (changeOccurred &amp;&amp; iterationCount &gt; 50) {
374                         /*
375                          * Very unlikely, should never happen: If it happens we cannot guarantee it
376                          * won&#39;t happen again.
377                          */
378                         throw new PermanentBailoutException(&quot;too many iterations in computeGlobalLiveSets&quot;);
379                     }
380                 }
381             } while (changeOccurred);
382 
383             if (Assertions.detailedAssertionsEnabled(allocator.getOptions())) {
384                 verifyLiveness();
385             }
386 
387             // check that the liveIn set of the first block is empty
388             AbstractBlockBase&lt;?&gt; startBlock = allocator.getLIR().getControlFlowGraph().getStartBlock();
389             if (allocator.getBlockData(startBlock).liveIn.cardinality() != 0) {
390                 if (Assertions.detailedAssertionsEnabled(allocator.getOptions())) {
391                     reportFailure(numBlocks);
392                 }
393                 // bailout if this occurs in product mode.
394                 throw new GraalError(&quot;liveIn set of first block must be empty: &quot; + allocator.getBlockData(startBlock).liveIn);
395             }
396         }
397     }
398 
399     /**
400      * Creates a trimmed copy a bit set.
401      *
402      * {@link BitSet#clone()} cannot be used since it will not {@linkplain BitSet#trimToSize trim}
403      * the array if the bit set is {@linkplain BitSet#sizeIsSticky sticky}.
404      */
405     @SuppressWarnings(&quot;javadoc&quot;)
406     private static BitSet trimClone(BitSet set) {
407         BitSet trimmedSet = new BitSet(0); // zero-length words array, sticky
408         trimmedSet.or(set); // words size ensured to be words-in-use of set,
409                             // also makes it non-sticky
410         return trimmedSet;
411     }
412 
413     @SuppressWarnings(&quot;try&quot;)
414     protected void reportFailure(int numBlocks) {
415         try (DebugContext.Scope s = debug.forceLog()) {
416             try (Indent indent = debug.logAndIndent(&quot;report failure&quot;)) {
417 
418                 BitSet startBlockLiveIn = allocator.getBlockData(allocator.getLIR().getControlFlowGraph().getStartBlock()).liveIn;
419                 try (Indent indent2 = debug.logAndIndent(&quot;Error: liveIn set of first block must be empty (when this fails, variables are used before they are defined):&quot;)) {
420                     for (int operandNum = startBlockLiveIn.nextSetBit(0); operandNum &gt;= 0; operandNum = startBlockLiveIn.nextSetBit(operandNum + 1)) {
421                         Interval interval = allocator.intervalFor(operandNum);
422                         if (interval != null) {
423                             Value operand = interval.operand;
424                             debug.log(&quot;var %d; operand=%s; node=%s&quot;, operandNum, operand, getSourceForOperandFromDebugContext(debug, operand));
425                         } else {
426                             debug.log(&quot;var %d; missing operand&quot;, operandNum);
427                         }
428                     }
429                 }
430 
431                 // print some additional information to simplify debugging
432                 for (int operandNum = startBlockLiveIn.nextSetBit(0); operandNum &gt;= 0; operandNum = startBlockLiveIn.nextSetBit(operandNum + 1)) {
433                     Interval interval = allocator.intervalFor(operandNum);
434                     Value operand = null;
435                     Object valueForOperandFromDebugContext = null;
436                     if (interval != null) {
437                         operand = interval.operand;
438                         valueForOperandFromDebugContext = getSourceForOperandFromDebugContext(debug, operand);
439                     }
440                     try (Indent indent2 = debug.logAndIndent(&quot;---- Detailed information for var %d; operand=%s; node=%s ----&quot;, operandNum, operand, valueForOperandFromDebugContext)) {
441 
442                         ArrayDeque&lt;AbstractBlockBase&lt;?&gt;&gt; definedIn = new ArrayDeque&lt;&gt;();
443                         EconomicSet&lt;AbstractBlockBase&lt;?&gt;&gt; usedIn = EconomicSet.create(Equivalence.IDENTITY);
444                         for (AbstractBlockBase&lt;?&gt; block : allocator.sortedBlocks()) {
445                             if (allocator.getBlockData(block).liveGen.get(operandNum)) {
446                                 usedIn.add(block);
447                                 try (Indent indent3 = debug.logAndIndent(&quot;used in block B%d&quot;, block.getId())) {
448                                     for (LIRInstruction ins : allocator.getLIR().getLIRforBlock(block)) {
449                                         try (Indent indent4 = debug.logAndIndent(&quot;%d: %s&quot;, ins.id(), ins)) {
450                                             ins.forEachState((liveStateOperand, mode, flags) -&gt; {
451                                                 debug.log(&quot;operand=%s&quot;, liveStateOperand);
452                                                 return liveStateOperand;
453                                             });
454                                         }
455                                     }
456                                 }
457                             }
458                             if (allocator.getBlockData(block).liveKill.get(operandNum)) {
459                                 definedIn.add(block);
460                                 try (Indent indent3 = debug.logAndIndent(&quot;defined in block B%d&quot;, block.getId())) {
461                                     for (LIRInstruction ins : allocator.getLIR().getLIRforBlock(block)) {
462                                         debug.log(&quot;%d: %s&quot;, ins.id(), ins);
463                                     }
464                                 }
465                             }
466                         }
467 
468                         int[] hitCount = new int[numBlocks];
469 
470                         while (!definedIn.isEmpty()) {
471                             AbstractBlockBase&lt;?&gt; block = definedIn.removeFirst();
472                             usedIn.remove(block);
473                             for (AbstractBlockBase&lt;?&gt; successor : block.getSuccessors()) {
474                                 if (successor.isLoopHeader()) {
475                                     if (!block.isLoopEnd()) {
476                                         definedIn.add(successor);
477                                     }
478                                 } else {
479                                     if (++hitCount[successor.getId()] == successor.getPredecessorCount()) {
480                                         definedIn.add(successor);
481                                     }
482                                 }
483                             }
484                         }
485                         try (Indent indent3 = debug.logAndIndent(&quot;**** offending usages are in: &quot;)) {
486                             for (AbstractBlockBase&lt;?&gt; block : usedIn) {
487                                 debug.log(&quot;B%d&quot;, block.getId());
488                             }
489                         }
490                     }
491                 }
492             }
493         } catch (Throwable e) {
494             throw debug.handle(e);
495         }
496     }
497 
498     protected void verifyLiveness() {
499         /*
500          * Check that fixed intervals are not live at block boundaries (live set must be empty at
501          * fixed intervals).
502          */
503         for (AbstractBlockBase&lt;?&gt; block : allocator.sortedBlocks()) {
504             for (int j = 0; j &lt;= allocator.maxRegisterNumber(); j++) {
505                 assert !allocator.getBlockData(block).liveIn.get(j) : &quot;liveIn  set of fixed register must be empty&quot;;
506                 assert !allocator.getBlockData(block).liveOut.get(j) : &quot;liveOut set of fixed register must be empty&quot;;
507                 assert !allocator.getBlockData(block).liveGen.get(j) : &quot;liveGen set of fixed register must be empty&quot;;
508             }
509         }
510     }
511 
512     protected void addUse(AllocatableValue operand, int from, int to, RegisterPriority registerPriority, ValueKind&lt;?&gt; kind, boolean detailedAsserts) {
513         if (!allocator.isProcessed(operand)) {
514             return;
515         }
516 
517         Interval interval = allocator.getOrCreateInterval(operand);
518         if (!kind.equals(LIRKind.Illegal)) {
519             interval.setKind(kind);
520         }
521 
522         interval.addRange(from, to);
523 
524         // Register use position at even instruction id.
525         interval.addUsePos(to &amp; ~1, registerPriority, detailedAsserts);
526 
527         if (debug.isLogEnabled()) {
528             debug.log(&quot;add use: %s, from %d to %d (%s)&quot;, interval, from, to, registerPriority.name());
529         }
530     }
531 
532     protected void addTemp(AllocatableValue operand, int tempPos, RegisterPriority registerPriority, ValueKind&lt;?&gt; kind, boolean detailedAsserts) {
533         if (!allocator.isProcessed(operand)) {
534             return;
535         }
536 
537         Interval interval = allocator.getOrCreateInterval(operand);
538         if (!kind.equals(LIRKind.Illegal)) {
539             interval.setKind(kind);
540         }
541 
542         interval.addRange(tempPos, tempPos + 1);
543         interval.addUsePos(tempPos, registerPriority, detailedAsserts);
544         interval.addMaterializationValue(null);
545 
546         if (debug.isLogEnabled()) {
547             debug.log(&quot;add temp: %s tempPos %d (%s)&quot;, interval, tempPos, RegisterPriority.MustHaveRegister.name());
548         }
549     }
550 
551     protected void addDef(AllocatableValue operand, LIRInstruction op, RegisterPriority registerPriority, ValueKind&lt;?&gt; kind, boolean detailedAsserts) {
552         if (!allocator.isProcessed(operand)) {
553             return;
554         }
555         int defPos = op.id();
556 
557         Interval interval = allocator.getOrCreateInterval(operand);
558         if (!kind.equals(LIRKind.Illegal)) {
559             interval.setKind(kind);
560         }
561 
562         Range r = interval.first();
563         if (r.from &lt;= defPos) {
564             /*
565              * Update the starting point (when a range is first created for a use, its start is the
566              * beginning of the current block until a def is encountered).
567              */
568             r.from = defPos;
569             interval.addUsePos(defPos, registerPriority, detailedAsserts);
570 
571         } else {
572             /*
573              * Dead value - make vacuous interval also add register priority for dead intervals
574              */
575             interval.addRange(defPos, defPos + 1);
576             interval.addUsePos(defPos, registerPriority, detailedAsserts);
577             if (debug.isLogEnabled()) {
578                 debug.log(&quot;Warning: def of operand %s at %d occurs without use&quot;, operand, defPos);
579             }
580         }
581 
582         changeSpillDefinitionPos(op, operand, interval, defPos);
583         if (registerPriority == RegisterPriority.None &amp;&amp; interval.spillState().ordinal() &lt;= SpillState.StartInMemory.ordinal() &amp;&amp; isStackSlot(operand)) {
584             // detection of method-parameters and roundfp-results
585             interval.setSpillState(SpillState.StartInMemory);
586         }
587         interval.addMaterializationValue(getMaterializedValue(op, operand, interval));
588 
589         if (debug.isLogEnabled()) {
590             debug.log(&quot;add def: %s defPos %d (%s)&quot;, interval, defPos, registerPriority.name());
591         }
592     }
593 
594     /**
595      * Optimizes moves related to incoming stack based arguments. The interval for the destination
596      * of such moves is assigned the stack slot (which is in the caller&#39;s frame) as its spill slot.
597      */
598     protected void handleMethodArguments(LIRInstruction op) {
599         if (ValueMoveOp.isValueMoveOp(op)) {
600             ValueMoveOp move = ValueMoveOp.asValueMoveOp(op);
601             if (optimizeMethodArgument(move.getInput())) {
602                 StackSlot slot = asStackSlot(move.getInput());
603                 if (Assertions.detailedAssertionsEnabled(allocator.getOptions())) {
604                     assert op.id() &gt; 0 : &quot;invalid id&quot;;
605                     assert allocator.blockForId(op.id()).getPredecessorCount() == 0 : &quot;move from stack must be in first block&quot;;
606                     assert isVariable(move.getResult()) : &quot;result of move must be a variable&quot;;
607 
608                     if (debug.isLogEnabled()) {
609                         debug.log(&quot;found move from stack slot %s to %s&quot;, slot, move.getResult());
610                     }
611                 }
612 
613                 Interval interval = allocator.intervalFor(move.getResult());
614                 interval.setSpillSlot(slot);
615                 interval.assignLocation(slot);
616             }
617         }
618     }
619 
620     protected void addRegisterHint(final LIRInstruction op, final Value targetValue, OperandMode mode, EnumSet&lt;OperandFlag&gt; flags, final boolean hintAtDef) {
621         if (flags.contains(OperandFlag.HINT) &amp;&amp; LinearScan.isVariableOrRegister(targetValue)) {
622 
623             op.forEachRegisterHint(targetValue, mode, (registerHint, valueMode, valueFlags) -&gt; {
624                 if (LinearScan.isVariableOrRegister(registerHint)) {
625                     Interval from = allocator.getOrCreateInterval((AllocatableValue) registerHint);
626                     Interval to = allocator.getOrCreateInterval((AllocatableValue) targetValue);
627 
628                     /* hints always point from def to use */
629                     if (hintAtDef) {
630                         to.setLocationHint(from);
631                     } else {
632                         from.setLocationHint(to);
633                     }
634                     if (debug.isLogEnabled()) {
635                         debug.log(&quot;operation at opId %d: added hint from interval %d to %d&quot;, op.id(), from.operandNumber, to.operandNumber);
636                     }
637 
638                     return registerHint;
639                 }
640                 return null;
641             });
642         }
643     }
644 
645     /**
646      * Eliminates moves from register to stack if the stack slot is known to be correct.
647      *
648      * @param op
649      * @param operand
650      */
651     protected void changeSpillDefinitionPos(LIRInstruction op, AllocatableValue operand, Interval interval, int defPos) {
652         assert interval.isSplitParent() : &quot;can only be called for split parents&quot;;
653 
654         switch (interval.spillState()) {
655             case NoDefinitionFound:
656                 assert interval.spillDefinitionPos() == -1 : &quot;must no be set before&quot;;
657                 interval.setSpillDefinitionPos(defPos);
658                 interval.setSpillState(SpillState.NoSpillStore);
659                 break;
660 
661             case NoSpillStore:
662                 assert defPos &lt;= interval.spillDefinitionPos() : &quot;positions are processed in reverse order when intervals are created&quot;;
663                 if (defPos &lt; interval.spillDefinitionPos() - 2) {
664                     // second definition found, so no spill optimization possible for this interval
665                     interval.setSpillState(SpillState.NoOptimization);
666                 } else {
667                     // two consecutive definitions (because of two-operand LIR form)
668                     assert allocator.blockForId(defPos) == allocator.blockForId(interval.spillDefinitionPos()) : &quot;block must be equal&quot;;
669                 }
670                 break;
671 
672             case NoOptimization:
673                 // nothing to do
674                 break;
675 
676             default:
677                 throw GraalError.shouldNotReachHere(&quot;other states not allowed at this time&quot;);
678         }
679     }
680 
681     private static boolean optimizeMethodArgument(Value value) {
682         /*
683          * Object method arguments that are passed on the stack are currently not optimized because
684          * this requires that the runtime visits method arguments during stack walking.
685          */
686         return isStackSlot(value) &amp;&amp; asStackSlot(value).isInCallerFrame() &amp;&amp; LIRKind.isValue(value);
687     }
688 
689     /**
690      * Determines the register priority for an instruction&#39;s output/result operand.
691      */
692     protected RegisterPriority registerPriorityOfOutputOperand(LIRInstruction op) {
693         if (ValueMoveOp.isValueMoveOp(op)) {
694             ValueMoveOp move = ValueMoveOp.asValueMoveOp(op);
695             if (optimizeMethodArgument(move.getInput())) {
696                 return RegisterPriority.None;
697             }
698         }
699 
700         // all other operands require a register
701         return RegisterPriority.MustHaveRegister;
702     }
703 
704     /**
705      * Determines the priority which with an instruction&#39;s input operand will be allocated a
706      * register.
707      */
708     protected static RegisterPriority registerPriorityOfInputOperand(EnumSet&lt;OperandFlag&gt; flags) {
709         if (flags.contains(OperandFlag.STACK)) {
710             return RegisterPriority.ShouldHaveRegister;
711         }
712         // all other operands require a register
713         return RegisterPriority.MustHaveRegister;
714     }
715 
716     @SuppressWarnings(&quot;try&quot;)
717     protected void buildIntervals(boolean detailedAsserts) {
718 
719         try (Indent indent = debug.logAndIndent(&quot;build intervals&quot;)) {
720             InstructionValueConsumer outputConsumer = (op, operand, mode, flags) -&gt; {
721                 if (LinearScan.isVariableOrRegister(operand)) {
722                     addDef((AllocatableValue) operand, op, registerPriorityOfOutputOperand(op), operand.getValueKind(), detailedAsserts);
723                     addRegisterHint(op, operand, mode, flags, true);
724                 }
725             };
726 
727             InstructionValueConsumer tempConsumer = (op, operand, mode, flags) -&gt; {
728                 if (LinearScan.isVariableOrRegister(operand)) {
729                     addTemp((AllocatableValue) operand, op.id(), RegisterPriority.MustHaveRegister, operand.getValueKind(), detailedAsserts);
730                     addRegisterHint(op, operand, mode, flags, false);
731                 }
732             };
733 
734             InstructionValueConsumer aliveConsumer = (op, operand, mode, flags) -&gt; {
735                 if (LinearScan.isVariableOrRegister(operand)) {
736                     RegisterPriority p = registerPriorityOfInputOperand(flags);
737                     int opId = op.id();
738                     int blockFrom = allocator.getFirstLirInstructionId((allocator.blockForId(opId)));
739                     addUse((AllocatableValue) operand, blockFrom, opId + 1, p, operand.getValueKind(), detailedAsserts);
740                     addRegisterHint(op, operand, mode, flags, false);
741                 }
742             };
743 
744             InstructionValueConsumer inputConsumer = (op, operand, mode, flags) -&gt; {
745                 if (LinearScan.isVariableOrRegister(operand)) {
746                     int opId = op.id();
747                     int blockFrom = allocator.getFirstLirInstructionId((allocator.blockForId(opId)));
748                     RegisterPriority p = registerPriorityOfInputOperand(flags);
749                     addUse((AllocatableValue) operand, blockFrom, opId, p, operand.getValueKind(), detailedAsserts);
750                     addRegisterHint(op, operand, mode, flags, false);
751                 }
752             };
753 
754             InstructionValueConsumer nonBasePointersStateProc = (op, operand, mode, flags) -&gt; {
755                 if (LinearScan.isVariableOrRegister(operand)) {
756                     int opId = op.id();
757                     int blockFrom = allocator.getFirstLirInstructionId((allocator.blockForId(opId)));
758                     addUse((AllocatableValue) operand, blockFrom, opId + 1, RegisterPriority.None, operand.getValueKind(), detailedAsserts);
759                 }
760             };
761             InstructionValueConsumer basePointerStateProc = (op, operand, mode, flags) -&gt; {
762                 if (LinearScan.isVariableOrRegister(operand)) {
763                     int opId = op.id();
764                     int blockFrom = allocator.getFirstLirInstructionId((allocator.blockForId(opId)));
765                     /*
766                      * Setting priority of base pointers to ShouldHaveRegister to avoid
767                      * rematerialization (see #getMaterializedValue).
768                      */
769                     addUse((AllocatableValue) operand, blockFrom, opId + 1, RegisterPriority.ShouldHaveRegister, operand.getValueKind(), detailedAsserts);
770                 }
771             };
772 
773             InstructionStateProcedure stateProc = (op, state) -&gt; {
774                 IndexedValueMap liveBasePointers = state.getLiveBasePointers();
775                 // temporarily unset the base pointers to that the procedure will not visit them
776                 state.setLiveBasePointers(null);
777                 state.visitEachState(op, nonBasePointersStateProc);
778                 // visit the base pointers explicitly
779                 liveBasePointers.visitEach(op, OperandMode.ALIVE, null, basePointerStateProc);
780                 // reset the base pointers
781                 state.setLiveBasePointers(liveBasePointers);
782             };
783 
784             // create a list with all caller-save registers (cpu, fpu, xmm)
785             RegisterArray callerSaveRegs = allocator.getRegisterAllocationConfig().getRegisterConfig().getCallerSaveRegisters();
786 
787             // iterate all blocks in reverse order
788             for (int i = allocator.blockCount() - 1; i &gt;= 0; i--) {
789 
790                 AbstractBlockBase&lt;?&gt; block = allocator.blockAt(i);
791                 try (Indent indent2 = debug.logAndIndent(&quot;handle block %d&quot;, block.getId())) {
792 
793                     ArrayList&lt;LIRInstruction&gt; instructions = allocator.getLIR().getLIRforBlock(block);
794                     final int blockFrom = allocator.getFirstLirInstructionId(block);
795                     int blockTo = allocator.getLastLirInstructionId(block);
796 
797                     assert blockFrom == instructions.get(0).id();
798                     assert blockTo == instructions.get(instructions.size() - 1).id();
799 
800                     // Update intervals for operands live at the end of this block;
801                     BitSet live = allocator.getBlockData(block).liveOut;
802                     for (int operandNum = live.nextSetBit(0); operandNum &gt;= 0; operandNum = live.nextSetBit(operandNum + 1)) {
803                         assert live.get(operandNum) : &quot;should not stop here otherwise&quot;;
804                         AllocatableValue operand = allocator.intervalFor(operandNum).operand;
805                         if (debug.isLogEnabled()) {
806                             debug.log(&quot;live in %d: %s&quot;, operandNum, operand);
807                         }
808 
809                         addUse(operand, blockFrom, blockTo + 2, RegisterPriority.None, LIRKind.Illegal, detailedAsserts);
810 
811                         /*
812                          * Add special use positions for loop-end blocks when the interval is used
813                          * anywhere inside this loop. It&#39;s possible that the block was part of a
814                          * non-natural loop, so it might have an invalid loop index.
815                          */
816                         if (block.isLoopEnd() &amp;&amp; block.getLoop() != null &amp;&amp; isIntervalInLoop(operandNum, block.getLoop().getIndex())) {
817                             allocator.intervalFor(operandNum).addUsePos(blockTo + 1, RegisterPriority.LiveAtLoopEnd, detailedAsserts);
818                         }
819                     }
820 
821                     /*
822                      * Iterate all instructions of the block in reverse order. definitions of
823                      * intervals are processed before uses.
824                      */
825                     for (int j = instructions.size() - 1; j &gt;= 0; j--) {
826                         final LIRInstruction op = instructions.get(j);
827                         final int opId = op.id();
828 
829                         try (Indent indent3 = debug.logAndIndent(&quot;handle inst %d: %s&quot;, opId, op)) {
830 
831                             // add a temp range for each register if operation destroys
832                             // caller-save registers
833                             if (op.destroysCallerSavedRegisters()) {
834                                 for (Register r : callerSaveRegs) {
835                                     if (allocator.attributes(r).isAllocatable()) {
836                                         addTemp(r.asValue(), opId, RegisterPriority.None, LIRKind.Illegal, detailedAsserts);
837                                     }
838                                 }
839                                 if (debug.isLogEnabled()) {
840                                     debug.log(&quot;operation destroys all caller-save registers&quot;);
841                                 }
842                             }
843 
844                             op.visitEachOutput(outputConsumer);
845                             op.visitEachTemp(tempConsumer);
846                             op.visitEachAlive(aliveConsumer);
847                             op.visitEachInput(inputConsumer);
848 
849                             /*
850                              * Add uses of live locals from interpreter&#39;s point of view for proper
851                              * debug information generation. Treat these operands as temp values (if
852                              * the live range is extended to a call site, the value would be in a
853                              * register at the call otherwise).
854                              */
855                             op.forEachState(stateProc);
856 
857                             // special steps for some instructions (especially moves)
858                             handleMethodArguments(op);
859 
860                         }
861 
862                     } // end of instruction iteration
863                 }
864             } // end of block iteration
865 
866             /*
867              * Add the range [0, 1] to all fixed intervals. the register allocator need not handle
868              * unhandled fixed intervals.
869              */
870             for (Interval interval : allocator.intervals()) {
871                 if (interval != null &amp;&amp; isRegister(interval.operand)) {
872                     interval.addRange(0, 1);
873                 }
874             }
875         }
876     }
877 
878     /**
879      * Returns a value for a interval definition, which can be used for re-materialization.
880      *
881      * @param op An instruction which defines a value
882      * @param operand The destination operand of the instruction
883      * @param interval The interval for this defined value.
884      * @return Returns the value which is moved to the instruction and which can be reused at all
885      *         reload-locations in case the interval of this instruction is spilled. Currently this
886      *         can only be a {@link JavaConstant}.
887      */
888     protected Constant getMaterializedValue(LIRInstruction op, Value operand, Interval interval) {
889         if (LoadConstantOp.isLoadConstantOp(op)) {
890             LoadConstantOp move = LoadConstantOp.asLoadConstantOp(op);
891 
892             if (!allocator.neverSpillConstants()) {
893                 /*
894                  * Check if the interval has any uses which would accept an stack location (priority
895                  * == ShouldHaveRegister). Rematerialization of such intervals can result in a
896                  * degradation, because rematerialization always inserts a constant load, even if
897                  * the value is not needed in a register.
898                  */
899                 Interval.UsePosList usePosList = interval.usePosList();
900                 int numUsePos = usePosList.size();
901                 for (int useIdx = 0; useIdx &lt; numUsePos; useIdx++) {
902                     Interval.RegisterPriority priority = usePosList.registerPriority(useIdx);
903                     if (priority == Interval.RegisterPriority.ShouldHaveRegister) {
904                         return null;
905                     }
906                 }
907             }
908             Constant constant = move.getConstant();
909             if (!(constant instanceof JavaConstant)) {
910                 // Other kinds of constants might not be supported by the generic move operation.
911                 return null;
912             }
913             return constant;
914         }
915         return null;
916     }
917 }
    </pre>
  </body>
</html>
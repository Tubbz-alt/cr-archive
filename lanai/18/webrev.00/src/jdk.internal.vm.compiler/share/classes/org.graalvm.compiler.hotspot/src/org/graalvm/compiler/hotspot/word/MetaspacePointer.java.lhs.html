<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/word/MetaspacePointer.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.word;
 26 
 27 import static org.graalvm.compiler.hotspot.word.HotSpotOperation.HotspotOpcode.FROM_POINTER;
 28 import static org.graalvm.compiler.hotspot.word.HotSpotOperation.HotspotOpcode.IS_NULL;
 29 
<a name="2" id="anc2"></a><span class="line-modified"> 30 import org.graalvm.compiler.nodes.memory.HeapAccess.BarrierType;</span>
 31 import org.graalvm.compiler.word.Word;
 32 import org.graalvm.compiler.word.Word.Opcode;
 33 import org.graalvm.compiler.word.Word.Operation;
 34 import jdk.internal.vm.compiler.word.LocationIdentity;
<a name="3" id="anc3"></a><span class="line-removed"> 35 import jdk.internal.vm.compiler.word.Pointer;</span>
 36 import jdk.internal.vm.compiler.word.SignedWord;
 37 import jdk.internal.vm.compiler.word.UnsignedWord;
 38 import jdk.internal.vm.compiler.word.WordBase;
 39 
 40 /**
 41  * Marker type for a metaspace pointer.
 42  */
 43 public abstract class MetaspacePointer {
 44 
 45     @HotSpotOperation(opcode = IS_NULL)
 46     public abstract boolean isNull();
 47 
 48     @HotSpotOperation(opcode = FROM_POINTER)
<a name="4" id="anc4"></a><span class="line-modified"> 49     public abstract Pointer asWord();</span>
 50 
 51     /**
 52      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 53      * bytes.
 54      * &lt;p&gt;
 55      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 56      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 57      * knows that the highest-order bit of the unsigned value is never used).
 58      *
 59      * @param offset the signed offset for the memory access
 60      * @param locationIdentity the identity of the read
 61      * @return the result of the memory access
 62      */
 63     @Operation(opcode = Opcode.READ_POINTER)
 64     public abstract byte readByte(WordBase offset, LocationIdentity locationIdentity);
 65 
 66     /**
 67      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 68      * bytes.
 69      * &lt;p&gt;
 70      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 71      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 72      * knows that the highest-order bit of the unsigned value is never used).
 73      *
 74      * @param offset the signed offset for the memory access
 75      * @param locationIdentity the identity of the read
 76      * @return the result of the memory access
 77      */
 78     @Operation(opcode = Opcode.READ_POINTER)
 79     public abstract char readChar(WordBase offset, LocationIdentity locationIdentity);
 80 
 81     /**
 82      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 83      * bytes.
 84      * &lt;p&gt;
 85      * The offset is always treated as a {@link SignedWord} value. However, the static type is
 86      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
 87      * knows that the highest-order bit of the unsigned value is never used).
 88      *
 89      * @param offset the signed offset for the memory access
 90      * @param locationIdentity the identity of the read
 91      * @return the result of the memory access
 92      */
 93     @Operation(opcode = Opcode.READ_POINTER)
 94     public abstract short readShort(WordBase offset, LocationIdentity locationIdentity);
 95 
 96     /**
 97      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
 98      * bytes.
 99      * &lt;p&gt;
100      * The offset is always treated as a {@link SignedWord} value. However, the static type is
101      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
102      * knows that the highest-order bit of the unsigned value is never used).
103      *
104      * @param offset the signed offset for the memory access
105      * @param locationIdentity the identity of the read
106      * @return the result of the memory access
107      */
108     @Operation(opcode = Opcode.READ_POINTER)
109     public abstract int readInt(WordBase offset, LocationIdentity locationIdentity);
110 
111     /**
112      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
113      * bytes.
114      * &lt;p&gt;
115      * The offset is always treated as a {@link SignedWord} value. However, the static type is
116      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
117      * knows that the highest-order bit of the unsigned value is never used).
118      *
119      * @param offset the signed offset for the memory access
120      * @param locationIdentity the identity of the read
121      * @return the result of the memory access
122      */
123     @Operation(opcode = Opcode.READ_POINTER)
124     public abstract long readLong(WordBase offset, LocationIdentity locationIdentity);
125 
126     /**
127      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
128      * bytes.
129      * &lt;p&gt;
130      * The offset is always treated as a {@link SignedWord} value. However, the static type is
131      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
132      * knows that the highest-order bit of the unsigned value is never used).
133      *
134      * @param offset the signed offset for the memory access
135      * @param locationIdentity the identity of the read
136      * @return the result of the memory access
137      */
138     @Operation(opcode = Opcode.READ_POINTER)
139     public abstract float readFloat(WordBase offset, LocationIdentity locationIdentity);
140 
141     /**
142      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
143      * bytes.
144      * &lt;p&gt;
145      * The offset is always treated as a {@link SignedWord} value. However, the static type is
146      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
147      * knows that the highest-order bit of the unsigned value is never used).
148      *
149      * @param offset the signed offset for the memory access
150      * @param locationIdentity the identity of the read
151      * @return the result of the memory access
152      */
153     @Operation(opcode = Opcode.READ_POINTER)
154     public abstract double readDouble(WordBase offset, LocationIdentity locationIdentity);
155 
156     /**
157      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
158      * bytes.
159      * &lt;p&gt;
160      * The offset is always treated as a {@link SignedWord} value. However, the static type is
161      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
162      * knows that the highest-order bit of the unsigned value is never used).
163      *
164      * @param offset the signed offset for the memory access
165      * @param locationIdentity the identity of the read
166      * @return the result of the memory access
167      */
168     @Operation(opcode = Opcode.READ_POINTER)
169     public abstract Word readWord(WordBase offset, LocationIdentity locationIdentity);
170 
171     /**
172      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
173      * bytes.
174      * &lt;p&gt;
175      * The offset is always treated as a {@link SignedWord} value. However, the static type is
176      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
177      * knows that the highest-order bit of the unsigned value is never used).
178      *
179      * @param offset the signed offset for the memory access
180      * @param locationIdentity the identity of the read
181      * @return the result of the memory access
182      */
183     @Operation(opcode = Opcode.READ_POINTER)
184     public abstract Object readObject(WordBase offset, LocationIdentity locationIdentity);
185 
186     /**
187      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
188      * bytes.
189      *
190      * @param offset the signed offset for the memory access
191      * @param locationIdentity the identity of the read
192      * @return the result of the memory access
193      */
194     @Operation(opcode = Opcode.READ_POINTER)
195     public abstract byte readByte(int offset, LocationIdentity locationIdentity);
196 
197     /**
198      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
199      * bytes.
200      *
201      * @param offset the signed offset for the memory access
202      * @param locationIdentity the identity of the read
203      * @return the result of the memory access
204      */
205     @Operation(opcode = Opcode.READ_POINTER)
206     public abstract char readChar(int offset, LocationIdentity locationIdentity);
207 
208     /**
209      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
210      * bytes.
211      *
212      * @param offset the signed offset for the memory access
213      * @param locationIdentity the identity of the read
214      * @return the result of the memory access
215      */
216     @Operation(opcode = Opcode.READ_POINTER)
217     public abstract short readShort(int offset, LocationIdentity locationIdentity);
218 
219     /**
220      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
221      * bytes.
222      *
223      * @param offset the signed offset for the memory access
224      * @param locationIdentity the identity of the read
225      * @return the result of the memory access
226      */
227     @Operation(opcode = Opcode.READ_POINTER)
228     public abstract int readInt(int offset, LocationIdentity locationIdentity);
229 
230     /**
231      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
232      * bytes.
233      *
234      * @param offset the signed offset for the memory access
235      * @param locationIdentity the identity of the read
236      * @return the result of the memory access
237      */
238     @Operation(opcode = Opcode.READ_POINTER)
239     public abstract long readLong(int offset, LocationIdentity locationIdentity);
240 
241     /**
242      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
243      * bytes.
244      *
245      * @param offset the signed offset for the memory access
246      * @param locationIdentity the identity of the read
247      * @return the result of the memory access
248      */
249     @Operation(opcode = Opcode.READ_POINTER)
250     public abstract float readFloat(int offset, LocationIdentity locationIdentity);
251 
252     /**
253      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
254      * bytes.
255      *
256      * @param offset the signed offset for the memory access
257      * @param locationIdentity the identity of the read
258      * @return the result of the memory access
259      */
260     @Operation(opcode = Opcode.READ_POINTER)
261     public abstract double readDouble(int offset, LocationIdentity locationIdentity);
262 
263     /**
264      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
265      * bytes.
266      *
267      * @param offset the signed offset for the memory access
268      * @param locationIdentity the identity of the read
269      * @return the result of the memory access
270      */
271     @Operation(opcode = Opcode.READ_POINTER)
272     public abstract Word readWord(int offset, LocationIdentity locationIdentity);
273 
274     /**
275      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
276      * bytes.
277      *
278      * @param offset the signed offset for the memory access
279      * @param locationIdentity the identity of the read
280      * @return the result of the memory access
281      */
282     @Operation(opcode = Opcode.READ_POINTER)
283     public abstract Object readObject(int offset, LocationIdentity locationIdentity);
284 
285     /**
286      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
287      * bytes.
288      * &lt;p&gt;
289      * The offset is always treated as a {@link SignedWord} value. However, the static type is
290      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
291      * knows that the highest-order bit of the unsigned value is never used).
292      *
293      * @param offset the signed offset for the memory access
294      * @param locationIdentity the identity of the write
295      * @param val the value to be written to memory
296      */
297     @Operation(opcode = Opcode.WRITE_POINTER)
298     public abstract void writeByte(WordBase offset, byte val, LocationIdentity locationIdentity);
299 
300     /**
301      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
302      * bytes.
303      * &lt;p&gt;
304      * The offset is always treated as a {@link SignedWord} value. However, the static type is
305      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
306      * knows that the highest-order bit of the unsigned value is never used).
307      *
308      * @param offset the signed offset for the memory access
309      * @param locationIdentity the identity of the write
310      * @param val the value to be written to memory
311      */
312     @Operation(opcode = Opcode.WRITE_POINTER)
313     public abstract void writeChar(WordBase offset, char val, LocationIdentity locationIdentity);
314 
315     /**
316      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
317      * bytes.
318      * &lt;p&gt;
319      * The offset is always treated as a {@link SignedWord} value. However, the static type is
320      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
321      * knows that the highest-order bit of the unsigned value is never used).
322      *
323      * @param offset the signed offset for the memory access
324      * @param locationIdentity the identity of the write
325      * @param val the value to be written to memory
326      */
327     @Operation(opcode = Opcode.WRITE_POINTER)
328     public abstract void writeShort(WordBase offset, short val, LocationIdentity locationIdentity);
329 
330     /**
331      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
332      * bytes.
333      * &lt;p&gt;
334      * The offset is always treated as a {@link SignedWord} value. However, the static type is
335      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
336      * knows that the highest-order bit of the unsigned value is never used).
337      *
338      * @param offset the signed offset for the memory access
339      * @param locationIdentity the identity of the write
340      * @param val the value to be written to memory
341      */
342     @Operation(opcode = Opcode.WRITE_POINTER)
343     public abstract void writeInt(WordBase offset, int val, LocationIdentity locationIdentity);
344 
345     /**
346      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
347      * bytes.
348      * &lt;p&gt;
349      * The offset is always treated as a {@link SignedWord} value. However, the static type is
350      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
351      * knows that the highest-order bit of the unsigned value is never used).
352      *
353      * @param offset the signed offset for the memory access
354      * @param locationIdentity the identity of the write
355      * @param val the value to be written to memory
356      */
357     @Operation(opcode = Opcode.WRITE_POINTER)
358     public abstract void writeLong(WordBase offset, long val, LocationIdentity locationIdentity);
359 
360     /**
361      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
362      * bytes.
363      * &lt;p&gt;
364      * The offset is always treated as a {@link SignedWord} value. However, the static type is
365      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
366      * knows that the highest-order bit of the unsigned value is never used).
367      *
368      * @param offset the signed offset for the memory access
369      * @param locationIdentity the identity of the write
370      * @param val the value to be written to memory
371      */
372     @Operation(opcode = Opcode.WRITE_POINTER)
373     public abstract void writeFloat(WordBase offset, float val, LocationIdentity locationIdentity);
374 
375     /**
376      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
377      * bytes.
378      * &lt;p&gt;
379      * The offset is always treated as a {@link SignedWord} value. However, the static type is
380      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
381      * knows that the highest-order bit of the unsigned value is never used).
382      *
383      * @param offset the signed offset for the memory access
384      * @param locationIdentity the identity of the write
385      * @param val the value to be written to memory
386      */
387     @Operation(opcode = Opcode.WRITE_POINTER)
388     public abstract void writeDouble(WordBase offset, double val, LocationIdentity locationIdentity);
389 
390     /**
391      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
392      * bytes.
393      * &lt;p&gt;
394      * The offset is always treated as a {@link SignedWord} value. However, the static type is
395      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
396      * knows that the highest-order bit of the unsigned value is never used).
397      *
398      * @param offset the signed offset for the memory access
399      * @param locationIdentity the identity of the write
400      * @param val the value to be written to memory
401      */
402     @Operation(opcode = Opcode.WRITE_POINTER)
403     public abstract void writeWord(WordBase offset, WordBase val, LocationIdentity locationIdentity);
404 
405     /**
406      * Initializes the memory at address {@code (this + offset)}. Both the base address and offset
407      * are in bytes. The memory must be uninitialized or zero prior to this operation.
408      * &lt;p&gt;
409      * The offset is always treated as a {@link SignedWord} value. However, the static type is
410      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
411      * knows that the highest-order bit of the unsigned value is never used).
412      *
413      * @param offset the signed offset for the memory access
414      * @param locationIdentity the identity of the write
415      * @param val the value to be written to memory
416      */
417     @Operation(opcode = Opcode.INITIALIZE)
418     public abstract void initializeLong(WordBase offset, long val, LocationIdentity locationIdentity);
419 
420     /**
421      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
422      * bytes.
423      * &lt;p&gt;
424      * The offset is always treated as a {@link SignedWord} value. However, the static type is
425      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
426      * knows that the highest-order bit of the unsigned value is never used).
427      *
428      * @param offset the signed offset for the memory access
429      * @param locationIdentity the identity of the write
430      * @param val the value to be written to memory
431      */
432     @Operation(opcode = Opcode.WRITE_POINTER)
433     public abstract void writeObject(WordBase offset, Object val, LocationIdentity locationIdentity);
434 
435     /**
436      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
437      * bytes.
438      *
439      * @param offset the signed offset for the memory access
440      * @param locationIdentity the identity of the write
441      * @param val the value to be written to memory
442      */
443     @Operation(opcode = Opcode.WRITE_POINTER)
444     public abstract void writeByte(int offset, byte val, LocationIdentity locationIdentity);
445 
446     /**
447      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
448      * bytes.
449      *
450      * @param offset the signed offset for the memory access
451      * @param locationIdentity the identity of the write
452      * @param val the value to be written to memory
453      */
454     @Operation(opcode = Opcode.WRITE_POINTER)
455     public abstract void writeChar(int offset, char val, LocationIdentity locationIdentity);
456 
457     /**
458      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
459      * bytes.
460      *
461      * @param offset the signed offset for the memory access
462      * @param locationIdentity the identity of the write
463      * @param val the value to be written to memory
464      */
465     @Operation(opcode = Opcode.WRITE_POINTER)
466     public abstract void writeShort(int offset, short val, LocationIdentity locationIdentity);
467 
468     /**
469      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
470      * bytes.
471      *
472      * @param offset the signed offset for the memory access
473      * @param locationIdentity the identity of the write
474      * @param val the value to be written to memory
475      */
476     @Operation(opcode = Opcode.WRITE_POINTER)
477     public abstract void writeInt(int offset, int val, LocationIdentity locationIdentity);
478 
479     /**
480      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
481      * bytes.
482      *
483      * @param offset the signed offset for the memory access
484      * @param locationIdentity the identity of the write
485      * @param val the value to be written to memory
486      */
487     @Operation(opcode = Opcode.WRITE_POINTER)
488     public abstract void writeLong(int offset, long val, LocationIdentity locationIdentity);
489 
490     /**
491      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
492      * bytes.
493      *
494      * @param offset the signed offset for the memory access
495      * @param locationIdentity the identity of the write
496      * @param val the value to be written to memory
497      */
498     @Operation(opcode = Opcode.WRITE_POINTER)
499     public abstract void writeFloat(int offset, float val, LocationIdentity locationIdentity);
500 
501     /**
502      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
503      * bytes.
504      *
505      * @param offset the signed offset for the memory access
506      * @param locationIdentity the identity of the write
507      * @param val the value to be written to memory
508      */
509     @Operation(opcode = Opcode.WRITE_POINTER)
510     public abstract void writeDouble(int offset, double val, LocationIdentity locationIdentity);
511 
512     /**
513      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
514      * bytes.
515      *
516      * @param offset the signed offset for the memory access
517      * @param locationIdentity the identity of the write
518      * @param val the value to be written to memory
519      */
520     @Operation(opcode = Opcode.WRITE_POINTER)
521     public abstract void writeWord(int offset, WordBase val, LocationIdentity locationIdentity);
522 
523     /**
524      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
525      * bytes.
526      *
527      * @param offset the signed offset for the memory access
528      * @param locationIdentity the identity of the write
529      * @param val the value to be written to memory
530      */
531     @Operation(opcode = Opcode.WRITE_POINTER)
532     public abstract void writeObject(int offset, Object val, LocationIdentity locationIdentity);
533 
534     /**
535      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
536      * bytes.
537      * &lt;p&gt;
538      * The offset is always treated as a {@link SignedWord} value. However, the static type is
539      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
540      * knows that the highest-order bit of the unsigned value is never used).
541      *
542      * @param offset the signed offset for the memory access
543      * @return the result of the memory access
544      */
545     @Operation(opcode = Opcode.READ_POINTER)
546     public abstract byte readByte(WordBase offset);
547 
548     /**
549      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
550      * bytes.
551      * &lt;p&gt;
552      * The offset is always treated as a {@link SignedWord} value. However, the static type is
553      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
554      * knows that the highest-order bit of the unsigned value is never used).
555      *
556      * @param offset the signed offset for the memory access
557      * @return the result of the memory access
558      */
559     @Operation(opcode = Opcode.READ_POINTER)
560     public abstract char readChar(WordBase offset);
561 
562     /**
563      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
564      * bytes.
565      * &lt;p&gt;
566      * The offset is always treated as a {@link SignedWord} value. However, the static type is
567      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
568      * knows that the highest-order bit of the unsigned value is never used).
569      *
570      * @param offset the signed offset for the memory access
571      * @return the result of the memory access
572      */
573     @Operation(opcode = Opcode.READ_POINTER)
574     public abstract short readShort(WordBase offset);
575 
576     /**
577      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
578      * bytes.
579      * &lt;p&gt;
580      * The offset is always treated as a {@link SignedWord} value. However, the static type is
581      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
582      * knows that the highest-order bit of the unsigned value is never used).
583      *
584      * @param offset the signed offset for the memory access
585      * @return the result of the memory access
586      */
587     @Operation(opcode = Opcode.READ_POINTER)
588     public abstract int readInt(WordBase offset);
589 
590     /**
591      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
592      * bytes.
593      * &lt;p&gt;
594      * The offset is always treated as a {@link SignedWord} value. However, the static type is
595      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
596      * knows that the highest-order bit of the unsigned value is never used).
597      *
598      * @param offset the signed offset for the memory access
599      * @return the result of the memory access
600      */
601     @Operation(opcode = Opcode.READ_POINTER)
602     public abstract long readLong(WordBase offset);
603 
604     /**
605      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
606      * bytes.
607      * &lt;p&gt;
608      * The offset is always treated as a {@link SignedWord} value. However, the static type is
609      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
610      * knows that the highest-order bit of the unsigned value is never used).
611      *
612      * @param offset the signed offset for the memory access
613      * @return the result of the memory access
614      */
615     @Operation(opcode = Opcode.READ_POINTER)
616     public abstract float readFloat(WordBase offset);
617 
618     /**
619      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
620      * bytes.
621      * &lt;p&gt;
622      * The offset is always treated as a {@link SignedWord} value. However, the static type is
623      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
624      * knows that the highest-order bit of the unsigned value is never used).
625      *
626      * @param offset the signed offset for the memory access
627      * @return the result of the memory access
628      */
629     @Operation(opcode = Opcode.READ_POINTER)
630     public abstract double readDouble(WordBase offset);
631 
632     /**
633      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
634      * bytes.
635      * &lt;p&gt;
636      * The offset is always treated as a {@link SignedWord} value. However, the static type is
637      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
638      * knows that the highest-order bit of the unsigned value is never used).
639      *
640      * @param offset the signed offset for the memory access
641      * @return the result of the memory access
642      */
643     @Operation(opcode = Opcode.READ_POINTER)
644     public abstract Word readWord(WordBase offset);
645 
646     /**
647      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
648      * bytes.
649      * &lt;p&gt;
650      * The offset is always treated as a {@link SignedWord} value. However, the static type is
651      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
652      * knows that the highest-order bit of the unsigned value is never used).
653      *
654      * @param offset the signed offset for the memory access
655      * @return the result of the memory access
656      */
657     @Operation(opcode = Opcode.READ_POINTER)
658     public abstract Object readObject(WordBase offset);
659 
660     /**
661      * Reads the memory at address {@code (this + offset)}. This access will decompress the oop if
662      * the VM uses compressed oops, and it can be parameterized to allow read barriers (G1 referent
663      * field).
664      * &lt;p&gt;
665      * The offset is always treated as a {@link SignedWord} value. However, the static type is
666      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
667      * knows that the highest-order bit of the unsigned value is never used).
668      *
669      * @param offset the signed offset for the memory access
670      * @param barrierType the type of the read barrier to be added
671      * @return the result of the memory access
672      */
673     @Operation(opcode = Opcode.READ_POINTER)
674     public abstract Object readObject(WordBase offset, BarrierType barrierType);
675 
676     /**
677      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
678      * bytes.
679      *
680      * @param offset the signed offset for the memory access
681      * @return the result of the memory access
682      */
683     @Operation(opcode = Opcode.READ_POINTER)
684     public abstract byte readByte(int offset);
685 
686     /**
687      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
688      * bytes.
689      *
690      * @param offset the signed offset for the memory access
691      * @return the result of the memory access
692      */
693     @Operation(opcode = Opcode.READ_POINTER)
694     public abstract char readChar(int offset);
695 
696     /**
697      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
698      * bytes.
699      *
700      * @param offset the signed offset for the memory access
701      * @return the result of the memory access
702      */
703     @Operation(opcode = Opcode.READ_POINTER)
704     public abstract short readShort(int offset);
705 
706     /**
707      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
708      * bytes.
709      *
710      * @param offset the signed offset for the memory access
711      * @return the result of the memory access
712      */
713     @Operation(opcode = Opcode.READ_POINTER)
714     public abstract int readInt(int offset);
715 
716     /**
717      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
718      * bytes.
719      *
720      * @param offset the signed offset for the memory access
721      * @return the result of the memory access
722      */
723     @Operation(opcode = Opcode.READ_POINTER)
724     public abstract long readLong(int offset);
725 
726     /**
727      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
728      * bytes.
729      *
730      * @param offset the signed offset for the memory access
731      * @return the result of the memory access
732      */
733     @Operation(opcode = Opcode.READ_POINTER)
734     public abstract float readFloat(int offset);
735 
736     /**
737      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
738      * bytes.
739      *
740      * @param offset the signed offset for the memory access
741      * @return the result of the memory access
742      */
743     @Operation(opcode = Opcode.READ_POINTER)
744     public abstract double readDouble(int offset);
745 
746     /**
747      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
748      * bytes.
749      *
750      * @param offset the signed offset for the memory access
751      * @return the result of the memory access
752      */
753     @Operation(opcode = Opcode.READ_POINTER)
754     public abstract Word readWord(int offset);
755 
756     /**
757      * Reads the memory at address {@code (this + offset)}. Both the base address and offset are in
758      * bytes.
759      *
760      * @param offset the signed offset for the memory access
761      * @return the result of the memory access
762      */
763     @Operation(opcode = Opcode.READ_POINTER)
764     public abstract Object readObject(int offset);
765 
766     /**
767      * Reads the memory at address {@code (this + offset)}. This access will decompress the oop if
768      * the VM uses compressed oops, and it can be parameterized to allow read barriers (G1 referent
769      * field).
770      *
771      * @param offset the signed offset for the memory access
772      * @param barrierType the type of the read barrier to be added
773      * @return the result of the memory access
774      */
775     @Operation(opcode = Opcode.READ_POINTER)
776     public abstract Object readObject(int offset, BarrierType barrierType);
777 
778     /**
779      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
780      * bytes.
781      * &lt;p&gt;
782      * The offset is always treated as a {@link SignedWord} value. However, the static type is
783      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
784      * knows that the highest-order bit of the unsigned value is never used).
785      *
786      * @param offset the signed offset for the memory access
787      * @param val the value to be written to memory
788      */
789     @Operation(opcode = Opcode.WRITE_POINTER)
790     public abstract void writeByte(WordBase offset, byte val);
791 
792     /**
793      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
794      * bytes.
795      * &lt;p&gt;
796      * The offset is always treated as a {@link SignedWord} value. However, the static type is
797      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
798      * knows that the highest-order bit of the unsigned value is never used).
799      *
800      * @param offset the signed offset for the memory access
801      * @param val the value to be written to memory
802      */
803     @Operation(opcode = Opcode.WRITE_POINTER)
804     public abstract void writeChar(WordBase offset, char val);
805 
806     /**
807      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
808      * bytes.
809      * &lt;p&gt;
810      * The offset is always treated as a {@link SignedWord} value. However, the static type is
811      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
812      * knows that the highest-order bit of the unsigned value is never used).
813      *
814      * @param offset the signed offset for the memory access
815      * @param val the value to be written to memory
816      */
817     @Operation(opcode = Opcode.WRITE_POINTER)
818     public abstract void writeShort(WordBase offset, short val);
819 
820     /**
821      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
822      * bytes.
823      * &lt;p&gt;
824      * The offset is always treated as a {@link SignedWord} value. However, the static type is
825      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
826      * knows that the highest-order bit of the unsigned value is never used).
827      *
828      * @param offset the signed offset for the memory access
829      * @param val the value to be written to memory
830      */
831     @Operation(opcode = Opcode.WRITE_POINTER)
832     public abstract void writeInt(WordBase offset, int val);
833 
834     /**
835      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
836      * bytes.
837      * &lt;p&gt;
838      * The offset is always treated as a {@link SignedWord} value. However, the static type is
839      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
840      * knows that the highest-order bit of the unsigned value is never used).
841      *
842      * @param offset the signed offset for the memory access
843      * @param val the value to be written to memory
844      */
845     @Operation(opcode = Opcode.WRITE_POINTER)
846     public abstract void writeLong(WordBase offset, long val);
847 
848     /**
849      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
850      * bytes.
851      * &lt;p&gt;
852      * The offset is always treated as a {@link SignedWord} value. However, the static type is
853      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
854      * knows that the highest-order bit of the unsigned value is never used).
855      *
856      * @param offset the signed offset for the memory access
857      * @param val the value to be written to memory
858      */
859     @Operation(opcode = Opcode.WRITE_POINTER)
860     public abstract void writeFloat(WordBase offset, float val);
861 
862     /**
863      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
864      * bytes.
865      * &lt;p&gt;
866      * The offset is always treated as a {@link SignedWord} value. However, the static type is
867      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
868      * knows that the highest-order bit of the unsigned value is never used).
869      *
870      * @param offset the signed offset for the memory access
871      * @param val the value to be written to memory
872      */
873     @Operation(opcode = Opcode.WRITE_POINTER)
874     public abstract void writeDouble(WordBase offset, double val);
875 
876     /**
877      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
878      * bytes.
879      * &lt;p&gt;
880      * The offset is always treated as a {@link SignedWord} value. However, the static type is
881      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
882      * knows that the highest-order bit of the unsigned value is never used).
883      *
884      * @param offset the signed offset for the memory access
885      * @param val the value to be written to memory
886      */
887     @Operation(opcode = Opcode.WRITE_POINTER)
888     public abstract void writeWord(WordBase offset, WordBase val);
889 
890     /**
891      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
892      * bytes.
893      * &lt;p&gt;
894      * The offset is always treated as a {@link SignedWord} value. However, the static type is
895      * {@link WordBase} to avoid the frequent casts of {@link UnsignedWord} values (where the caller
896      * knows that the highest-order bit of the unsigned value is never used).
897      *
898      * @param offset the signed offset for the memory access
899      * @param val the value to be written to memory
900      */
901     @Operation(opcode = Opcode.WRITE_POINTER)
902     public abstract void writeObject(WordBase offset, Object val);
903 
904     /**
905      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
906      * bytes.
907      *
908      * @param offset the signed offset for the memory access
909      * @param val the value to be written to memory
910      */
911     @Operation(opcode = Opcode.WRITE_POINTER)
912     public abstract void writeByte(int offset, byte val);
913 
914     /**
915      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
916      * bytes.
917      *
918      * @param offset the signed offset for the memory access
919      * @param val the value to be written to memory
920      */
921     @Operation(opcode = Opcode.WRITE_POINTER)
922     public abstract void writeChar(int offset, char val);
923 
924     /**
925      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
926      * bytes.
927      *
928      * @param offset the signed offset for the memory access
929      * @param val the value to be written to memory
930      */
931     @Operation(opcode = Opcode.WRITE_POINTER)
932     public abstract void writeShort(int offset, short val);
933 
934     /**
935      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
936      * bytes.
937      *
938      * @param offset the signed offset for the memory access
939      * @param val the value to be written to memory
940      */
941     @Operation(opcode = Opcode.WRITE_POINTER)
942     public abstract void writeInt(int offset, int val);
943 
944     /**
945      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
946      * bytes.
947      *
948      * @param offset the signed offset for the memory access
949      * @param val the value to be written to memory
950      */
951     @Operation(opcode = Opcode.WRITE_POINTER)
952     public abstract void writeLong(int offset, long val);
953 
954     /**
955      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
956      * bytes.
957      *
958      * @param offset the signed offset for the memory access
959      * @param val the value to be written to memory
960      */
961     @Operation(opcode = Opcode.WRITE_POINTER)
962     public abstract void writeFloat(int offset, float val);
963 
964     /**
965      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
966      * bytes.
967      *
968      * @param offset the signed offset for the memory access
969      * @param val the value to be written to memory
970      */
971     @Operation(opcode = Opcode.WRITE_POINTER)
972     public abstract void writeDouble(int offset, double val);
973 
974     /**
975      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
976      * bytes.
977      *
978      * @param offset the signed offset for the memory access
979      * @param val the value to be written to memory
980      */
981     @Operation(opcode = Opcode.WRITE_POINTER)
982     public abstract void writeWord(int offset, WordBase val);
983 
984     /**
985      * Writes the memory at address {@code (this + offset)}. Both the base address and offset are in
986      * bytes.
987      *
988      * @param offset the signed offset for the memory access
989      * @param val the value to be written to memory
990      */
991     @Operation(opcode = Opcode.WRITE_POINTER)
992     public abstract void writeObject(int offset, Object val);
993 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
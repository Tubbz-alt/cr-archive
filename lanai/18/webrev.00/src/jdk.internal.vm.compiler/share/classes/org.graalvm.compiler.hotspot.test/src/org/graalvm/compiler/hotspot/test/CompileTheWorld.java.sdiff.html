<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.test/src/org/graalvm/compiler/hotspot/test/CompileTheWorld.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CompilationWrapperTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="CompileTheWorldTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.test/src/org/graalvm/compiler/hotspot/test/CompileTheWorld.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  57 import java.util.ArrayList;
  58 import java.util.Arrays;
  59 import java.util.Collections;
  60 import java.util.Enumeration;
  61 import java.util.HashMap;
  62 import java.util.HashSet;
  63 import java.util.List;
  64 import java.util.Map;
  65 import java.util.ServiceLoader;
  66 import java.util.Set;
  67 import java.util.concurrent.ExecutionException;
  68 import java.util.concurrent.Future;
  69 import java.util.concurrent.LinkedBlockingQueue;
  70 import java.util.concurrent.ThreadPoolExecutor;
  71 import java.util.concurrent.TimeUnit;
  72 import java.util.concurrent.atomic.AtomicLong;
  73 import java.util.jar.JarEntry;
  74 import java.util.jar.JarFile;
  75 import java.util.regex.Matcher;
  76 import java.util.regex.Pattern;
<span class="line-removed">  77 import java.util.stream.Collectors;</span>
  78 
  79 import jdk.internal.vm.compiler.collections.EconomicMap;
  80 import jdk.internal.vm.compiler.collections.UnmodifiableMapCursor;
  81 import org.graalvm.compiler.api.replacements.Snippet;
  82 import org.graalvm.compiler.bytecode.Bytecodes;
  83 import org.graalvm.compiler.core.CompilerThreadFactory;
  84 import org.graalvm.compiler.core.phases.HighTier;
  85 import org.graalvm.compiler.core.test.ReflectionOptionDescriptors;
<span class="line-removed">  86 import org.graalvm.compiler.debug.DebugOptions;</span>
  87 import org.graalvm.compiler.debug.GlobalMetrics;
  88 import org.graalvm.compiler.debug.GraalError;
  89 import org.graalvm.compiler.debug.MethodFilter;
  90 import org.graalvm.compiler.debug.MetricKey;
  91 import org.graalvm.compiler.debug.TTY;
  92 import org.graalvm.compiler.hotspot.CompilationTask;
  93 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
  94 import org.graalvm.compiler.hotspot.HotSpotGraalCompiler;
  95 import org.graalvm.compiler.hotspot.HotSpotGraalRuntime;
  96 import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;
  97 import org.graalvm.compiler.hotspot.test.CompileTheWorld.LibGraalParams.StackTraceBuffer;
  98 import org.graalvm.compiler.options.OptionDescriptors;
  99 import org.graalvm.compiler.options.OptionKey;
 100 import org.graalvm.compiler.options.OptionValues;
 101 import org.graalvm.compiler.options.OptionsParser;
 102 import org.graalvm.compiler.serviceprovider.GraalUnsafeAccess;
 103 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
 104 import org.graalvm.compiler.api.test.ModuleSupport;
 105 import jdk.internal.vm.compiler.libgraal.LibGraal;
 106 import jdk.internal.vm.compiler.libgraal.LibGraalScope;
</pre>
<hr />
<pre>
 175      * Class index to start compilation at.
 176      *
 177      * @see Options#StartAt
 178      */
 179     private final int startAt;
 180 
 181     /**
 182      * Class index to stop compilation at.
 183      *
 184      * @see Options#StopAt
 185      */
 186     private final int stopAt;
 187 
 188     /**
 189      * Max classes to compile.
 190      *
 191      * @see Options#MaxClasses
 192      */
 193     private final int maxClasses;
 194 
<span class="line-modified"> 195     /** Only compile methods matching one of the filters in this array if the array is non-null. */</span>
<span class="line-modified"> 196     private final MethodFilter[] methodFilters;</span>
 197 
<span class="line-modified"> 198     /** Exclude methods matching one of the filters in this array if the array is non-null. */</span>
<span class="line-modified"> 199     private final MethodFilter[] excludeMethodFilters;</span>




 200 
 201     // Counters
 202     private int classFileCounter = 0;
 203     private AtomicLong compiledMethodsCounter = new AtomicLong();
 204     private AtomicLong compileTime = new AtomicLong();
 205     private AtomicLong memoryUsed = new AtomicLong();
 206 
 207     private boolean verbose;
 208 
 209     /**
 210      * Signal that the threads should start compiling in multithreaded mode.
 211      */
 212     private boolean running;
 213 
 214     private ThreadPoolExecutor threadPool;
 215 
 216     /**
 217      * Values for {@link CompileTheWorld.Options}.
 218      */
 219     private final OptionValues harnessOptions;
</pre>
<hr />
<pre>
 328 
 329         @Override
 330         public void close() {
 331             options.free();
 332             synchronized (stackTraceBuffers) {
 333                 for (StackTraceBuffer buffer : stackTraceBuffers) {
 334                     buffer.free();
 335                 }
 336                 stackTraceBuffers.clear();
 337             }
 338         }
 339     }
 340 
 341     /**
 342      * Creates a compile-the-world instance.
 343      *
 344      * @param files {@link File#pathSeparator} separated list of Zip/Jar files to compile
 345      * @param startAt index of the class file to start compilation at
 346      * @param stopAt index of the class file to stop compilation at
 347      * @param maxClasses maximum number of classes to process
<span class="line-modified"> 348      * @param methodFilters</span>
<span class="line-modified"> 349      * @param excludeMethodFilters</span>
 350      * @param harnessOptions values for {@link CompileTheWorld.Options}
 351      * @param compilerOptions option values used by the compiler
 352      */
 353     public CompileTheWorld(HotSpotJVMCIRuntime jvmciRuntime,
 354                     HotSpotGraalCompiler compiler,
 355                     String files,
 356                     int startAt,
 357                     int stopAt,
 358                     int maxClasses,
 359                     String methodFilters,
 360                     String excludeMethodFilters,
 361                     boolean verbose,
 362                     OptionValues harnessOptions,
 363                     OptionValues compilerOptions) {
 364         this.jvmciRuntime = jvmciRuntime;
 365         this.compiler = compiler;
 366         this.inputClassPath = files;
 367         this.startAt = Math.max(startAt, 1);
 368         this.stopAt = Math.max(stopAt, 1);
 369         this.maxClasses = Math.max(maxClasses, 1);
<span class="line-modified"> 370         this.methodFilters = methodFilters == null || methodFilters.isEmpty() ? null : MethodFilter.parse(methodFilters);</span>
<span class="line-modified"> 371         this.excludeMethodFilters = excludeMethodFilters == null || excludeMethodFilters.isEmpty() ? null : MethodFilter.parse(excludeMethodFilters);</span>
 372         this.verbose = verbose;
 373         this.harnessOptions = harnessOptions;
 374 
 375         // Copy the initial options and add in any extra options
 376         EconomicMap&lt;OptionKey&lt;?&gt;, Object&gt; compilerOptionsMap = EconomicMap.create(compilerOptions.getMap());
 377 
 378         // We want to see stack traces when a method fails to compile
 379         CompilationBailoutAsFailure.putIfAbsent(compilerOptionsMap, true);
 380         CompilationFailureAction.putIfAbsent(compilerOptionsMap, Print);
 381 
<span class="line-removed"> 382         // By default only report statistics for the CTW threads themselves</span>
<span class="line-removed"> 383         DebugOptions.MetricsThreadFilter.putIfAbsent(compilerOptionsMap, &quot;^CompileTheWorld&quot;);</span>
 384         this.compilerOptions = new OptionValues(compilerOptionsMap);
 385     }
 386 
 387     public CompileTheWorld(HotSpotJVMCIRuntime jvmciRuntime,
 388                     HotSpotGraalCompiler compiler,
 389                     OptionValues harnessOptions,
 390                     OptionValues compilerOptions) {
 391         this(jvmciRuntime, compiler, Options.Classpath.getValue(harnessOptions),
 392                         Options.StartAt.getValue(harnessOptions),
 393                         Options.StopAt.getValue(harnessOptions),
 394                         Options.MaxClasses.getValue(harnessOptions),
 395                         Options.MethodFilter.getValue(harnessOptions),
 396                         Options.ExcludeMethodFilter.getValue(harnessOptions),
 397                         Options.Verbose.hasBeenSet(harnessOptions) ? Options.Verbose.getValue(harnessOptions) : !Options.MultiThreaded.getValue(harnessOptions),
 398                         harnessOptions,
 399                         new OptionValues(compilerOptions, parseOptions(Options.Config.getValue(harnessOptions))));
 400     }
 401 
 402     /**
 403      * Compiles all methods in all classes in {@link #inputClassPath}. If {@link #inputClassPath}
</pre>
<hr />
<pre>
 628                                     String base = p.getName(nameCount - 1).toString();
 629                                     if (base.endsWith(&quot;.class&quot;) &amp;&amp; !base.equals(&quot;module-info.class&quot;)) {
 630                                         String module = p.getName(1).toString();
 631                                         if (positive.isEmpty() || positive.contains(module)) {
 632                                             if (negative.isEmpty() || !negative.contains(module)) {
 633                                                 // Strip module prefix and convert to dotted form
 634                                                 String className = p.subpath(2, nameCount).toString().replace(&#39;/&#39;, &#39;.&#39;);
 635                                                 // Strip &quot;.class&quot; suffix
 636                                                 className = className.replace(&#39;/&#39;, &#39;.&#39;).substring(0, className.length() - &quot;.class&quot;.length());
 637                                                 classNames.add(className);
 638                                             }
 639                                         }
 640                                     }
 641                                 }
 642                             });
 643             return classNames;
 644         }
 645     }
 646 
 647     private boolean isClassIncluded(String className) {
<span class="line-modified"> 648         if (methodFilters != null &amp;&amp; !MethodFilter.matchesClassName(methodFilters, className)) {</span>
 649             return false;
 650         }
<span class="line-modified"> 651         if (excludeMethodFilters != null &amp;&amp; MethodFilter.matchesClassName(excludeMethodFilters, className)) {</span>
 652             return false;
 653         }
 654         return true;
 655     }
 656 
 657     private ClassPathEntry openClassPathEntry(String entry) throws IOException {
 658         if (entry.endsWith(&quot;.zip&quot;) || entry.endsWith(&quot;.jar&quot;)) {
 659             return new JarClassPathEntry(entry);
 660         } else if (entry.equals(JRT_CLASS_PATH_ENTRY)) {
 661             return new JRTClassPathEntry(entry, Options.LimitModules.getValue(harnessOptions));
 662         } else {
 663             if (!new File(entry).isDirectory()) {
 664                 return null;
 665             }
 666             return new DirClassPathEntry(entry);
 667         }
 668     }
 669 
 670     /**
 671      * Compiles all methods in all classes in a given class path.
</pre>
<hr />
<pre>
 725             }
 726 
 727             int lastClassFile = totalClassFileCount - 1;
 728             compileStartAt = Math.min(startAt, lastClassFile);
 729             compileStopAt = Math.min(stopAt, lastClassFile);
 730             int range = compileStopAt - compileStartAt + 1;
 731             if (maxClasses &lt; range) {
 732                 compileStep = range / maxClasses;
 733             }
 734         }
 735 
 736         for (int i = 0; i &lt; entries.length; i++) {
 737             final String entry = entries[i];
 738             try (ClassPathEntry cpe = openClassPathEntry(entry)) {
 739                 if (cpe == null) {
 740                     println(&quot;CompileTheWorld : Skipped classes in &quot; + entry);
 741                     println();
 742                     continue;
 743                 }
 744 
<span class="line-modified"> 745                 if (methodFilters == null || methodFilters.length == 0) {</span>
 746                     println(&quot;CompileTheWorld : Compiling all classes in &quot; + entry);
 747                 } else {
<span class="line-modified"> 748                     String include = Arrays.asList(methodFilters).stream().map(MethodFilter::toString).collect(Collectors.joining(&quot;, &quot;));</span>
 749                     println(&quot;CompileTheWorld : Compiling all methods in &quot; + entry + &quot; matching one of the following filters: &quot; + include);
 750                 }
<span class="line-modified"> 751                 if (excludeMethodFilters != null &amp;&amp; excludeMethodFilters.length &gt; 0) {</span>
<span class="line-modified"> 752                     String exclude = Arrays.asList(excludeMethodFilters).stream().map(MethodFilter::toString).collect(Collectors.joining(&quot;, &quot;));</span>
 753                     println(&quot;CompileTheWorld : Excluding all methods matching one of the following filters: &quot; + exclude);
 754                 }
 755                 println();
 756 
 757                 ClassLoader loader = cpe.createClassLoader();
 758 
 759                 for (String className : cpe.getClassNames()) {
 760 
 761                     // Are we done?
 762                     if (classFileCounter &gt;= compileStopAt) {
 763                         break;
 764                     }
 765 
 766                     classFileCounter++;
 767 
 768                     if (compileStep &gt; 1 &amp;&amp; ((classFileCounter - compileStartAt) % compileStep) != 0) {
 769                         continue;
 770                     }
 771 
 772                     if (className.startsWith(&quot;jdk.management.&quot;) ||
</pre>
<hr />
<pre>
 908         }
 909     }
 910 
 911     private synchronized void startThreads() {
 912         running = true;
 913         // Wake up any waiting threads
 914         notifyAll();
 915     }
 916 
 917     private synchronized void waitToRun() {
 918         while (!running) {
 919             try {
 920                 wait();
 921             } catch (InterruptedException e) {
 922             }
 923         }
 924     }
 925 
 926     @SuppressWarnings(&quot;try&quot;)
 927     private void compileMethod(HotSpotResolvedJavaMethod method, LibGraalParams libgraal) throws InterruptedException, ExecutionException {
<span class="line-modified"> 928         if (methodFilters != null &amp;&amp; !MethodFilter.matches(methodFilters, method)) {</span>
 929             return;
 930         }
<span class="line-modified"> 931         if (excludeMethodFilters != null &amp;&amp; MethodFilter.matches(excludeMethodFilters, method)) {</span>
 932             return;
 933         }
 934         Future&lt;?&gt; task = threadPool.submit(new Runnable() {
 935             @Override
 936             public void run() {
 937                 waitToRun();
 938                 compileMethod(method, classFileCounter, libgraal);
 939             }
 940         });
 941         if (threadPool.getCorePoolSize() == 1) {
 942             task.get();
 943         }
 944     }
 945 
 946     private static final Unsafe UNSAFE = GraalUnsafeAccess.getUnsafe();
 947 
 948     /**
 949      * Implemented by
 950      * {@code com.oracle.svm.graal.hotspot.libgraal.LibGraalEntryPoints.compileMethod}.
 951      */
</pre>
<hr />
<pre>
1017             compileTime.getAndAdd(System.nanoTime() - start);
1018             compiledMethodsCounter.incrementAndGet();
1019         } catch (Throwable t) {
1020             // Catch everything and print a message
1021             println(&quot;CompileTheWorld (%d) : Error compiling method: %s&quot;, counter, method.format(&quot;%H.%n(%p):%r&quot;));
1022             printStackTrace(t);
1023         }
1024     }
1025 
1026     /**
1027      * Determines if a method should be compiled (Cf. CompilationPolicy::can_be_compiled).
1028      *
1029      * @return true if it can be compiled, false otherwise
1030      */
1031     private boolean canBeCompiled(HotSpotResolvedJavaMethod javaMethod, int modifiers) {
1032         if (Modifier.isAbstract(modifiers) || Modifier.isNative(modifiers)) {
1033             return false;
1034         }
1035         GraalHotSpotVMConfig c = compiler.getGraalRuntime().getVMConfig();
1036         if (c.dontCompileHugeMethods &amp;&amp; javaMethod.getCodeSize() &gt; c.hugeMethodLimit) {
<span class="line-modified">1037             println(verbose || methodFilters != null,</span>
1038                             String.format(&quot;CompileTheWorld (%d) : Skipping huge method %s (use -XX:-DontCompileHugeMethods or -XX:HugeMethodLimit=%d to include it)&quot;, classFileCounter,
1039                                             javaMethod.format(&quot;%H.%n(%p):%r&quot;),
1040                                             javaMethod.getCodeSize()));
1041             return false;
1042         }
1043         // Allow use of -XX:CompileCommand=dontinline to exclude problematic methods
1044         if (!javaMethod.canBeInlined()) {
1045             return false;
1046         }
1047         // Skip @Snippets for now
1048         for (Annotation annotation : javaMethod.getAnnotations()) {
1049             if (annotation.annotationType().equals(Snippet.class)) {
1050                 return false;
1051             }
1052         }
1053         return true;
1054     }
1055 
1056     static class Options {
1057         public static final OptionKey&lt;Boolean&gt; Help = new OptionKey&lt;&gt;(false);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  57 import java.util.ArrayList;
  58 import java.util.Arrays;
  59 import java.util.Collections;
  60 import java.util.Enumeration;
  61 import java.util.HashMap;
  62 import java.util.HashSet;
  63 import java.util.List;
  64 import java.util.Map;
  65 import java.util.ServiceLoader;
  66 import java.util.Set;
  67 import java.util.concurrent.ExecutionException;
  68 import java.util.concurrent.Future;
  69 import java.util.concurrent.LinkedBlockingQueue;
  70 import java.util.concurrent.ThreadPoolExecutor;
  71 import java.util.concurrent.TimeUnit;
  72 import java.util.concurrent.atomic.AtomicLong;
  73 import java.util.jar.JarEntry;
  74 import java.util.jar.JarFile;
  75 import java.util.regex.Matcher;
  76 import java.util.regex.Pattern;

  77 
  78 import jdk.internal.vm.compiler.collections.EconomicMap;
  79 import jdk.internal.vm.compiler.collections.UnmodifiableMapCursor;
  80 import org.graalvm.compiler.api.replacements.Snippet;
  81 import org.graalvm.compiler.bytecode.Bytecodes;
  82 import org.graalvm.compiler.core.CompilerThreadFactory;
  83 import org.graalvm.compiler.core.phases.HighTier;
  84 import org.graalvm.compiler.core.test.ReflectionOptionDescriptors;

  85 import org.graalvm.compiler.debug.GlobalMetrics;
  86 import org.graalvm.compiler.debug.GraalError;
  87 import org.graalvm.compiler.debug.MethodFilter;
  88 import org.graalvm.compiler.debug.MetricKey;
  89 import org.graalvm.compiler.debug.TTY;
  90 import org.graalvm.compiler.hotspot.CompilationTask;
  91 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
  92 import org.graalvm.compiler.hotspot.HotSpotGraalCompiler;
  93 import org.graalvm.compiler.hotspot.HotSpotGraalRuntime;
  94 import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;
  95 import org.graalvm.compiler.hotspot.test.CompileTheWorld.LibGraalParams.StackTraceBuffer;
  96 import org.graalvm.compiler.options.OptionDescriptors;
  97 import org.graalvm.compiler.options.OptionKey;
  98 import org.graalvm.compiler.options.OptionValues;
  99 import org.graalvm.compiler.options.OptionsParser;
 100 import org.graalvm.compiler.serviceprovider.GraalUnsafeAccess;
 101 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
 102 import org.graalvm.compiler.api.test.ModuleSupport;
 103 import jdk.internal.vm.compiler.libgraal.LibGraal;
 104 import jdk.internal.vm.compiler.libgraal.LibGraalScope;
</pre>
<hr />
<pre>
 173      * Class index to start compilation at.
 174      *
 175      * @see Options#StartAt
 176      */
 177     private final int startAt;
 178 
 179     /**
 180      * Class index to stop compilation at.
 181      *
 182      * @see Options#StopAt
 183      */
 184     private final int stopAt;
 185 
 186     /**
 187      * Max classes to compile.
 188      *
 189      * @see Options#MaxClasses
 190      */
 191     private final int maxClasses;
 192 
<span class="line-modified"> 193     /** Only compile methods matching this filter if the filter is non-null. */</span>
<span class="line-modified"> 194     private final MethodFilter methodFilter;</span>
 195 
<span class="line-modified"> 196     /**</span>
<span class="line-modified"> 197      * Exclude methods matching this filter if the filter is non-null. This is used by mx to exclude</span>
<span class="line-added"> 198      * some methods, while users are expected to use positive or negative filters in</span>
<span class="line-added"> 199      * {@link #methodFilter} instead.</span>
<span class="line-added"> 200      */</span>
<span class="line-added"> 201     private final MethodFilter excludeMethodFilter;</span>
 202 
 203     // Counters
 204     private int classFileCounter = 0;
 205     private AtomicLong compiledMethodsCounter = new AtomicLong();
 206     private AtomicLong compileTime = new AtomicLong();
 207     private AtomicLong memoryUsed = new AtomicLong();
 208 
 209     private boolean verbose;
 210 
 211     /**
 212      * Signal that the threads should start compiling in multithreaded mode.
 213      */
 214     private boolean running;
 215 
 216     private ThreadPoolExecutor threadPool;
 217 
 218     /**
 219      * Values for {@link CompileTheWorld.Options}.
 220      */
 221     private final OptionValues harnessOptions;
</pre>
<hr />
<pre>
 330 
 331         @Override
 332         public void close() {
 333             options.free();
 334             synchronized (stackTraceBuffers) {
 335                 for (StackTraceBuffer buffer : stackTraceBuffers) {
 336                     buffer.free();
 337                 }
 338                 stackTraceBuffers.clear();
 339             }
 340         }
 341     }
 342 
 343     /**
 344      * Creates a compile-the-world instance.
 345      *
 346      * @param files {@link File#pathSeparator} separated list of Zip/Jar files to compile
 347      * @param startAt index of the class file to start compilation at
 348      * @param stopAt index of the class file to stop compilation at
 349      * @param maxClasses maximum number of classes to process
<span class="line-modified"> 350      * @param methodFilters filters describing the methods to compile</span>
<span class="line-modified"> 351      * @param excludeMethodFilters filters describing the methods not to compile</span>
 352      * @param harnessOptions values for {@link CompileTheWorld.Options}
 353      * @param compilerOptions option values used by the compiler
 354      */
 355     public CompileTheWorld(HotSpotJVMCIRuntime jvmciRuntime,
 356                     HotSpotGraalCompiler compiler,
 357                     String files,
 358                     int startAt,
 359                     int stopAt,
 360                     int maxClasses,
 361                     String methodFilters,
 362                     String excludeMethodFilters,
 363                     boolean verbose,
 364                     OptionValues harnessOptions,
 365                     OptionValues compilerOptions) {
 366         this.jvmciRuntime = jvmciRuntime;
 367         this.compiler = compiler;
 368         this.inputClassPath = files;
 369         this.startAt = Math.max(startAt, 1);
 370         this.stopAt = Math.max(stopAt, 1);
 371         this.maxClasses = Math.max(maxClasses, 1);
<span class="line-modified"> 372         this.methodFilter = methodFilters == null ? null : MethodFilter.parse(methodFilters);</span>
<span class="line-modified"> 373         this.excludeMethodFilter = excludeMethodFilters == null ? null : MethodFilter.parse(excludeMethodFilters);</span>
 374         this.verbose = verbose;
 375         this.harnessOptions = harnessOptions;
 376 
 377         // Copy the initial options and add in any extra options
 378         EconomicMap&lt;OptionKey&lt;?&gt;, Object&gt; compilerOptionsMap = EconomicMap.create(compilerOptions.getMap());
 379 
 380         // We want to see stack traces when a method fails to compile
 381         CompilationBailoutAsFailure.putIfAbsent(compilerOptionsMap, true);
 382         CompilationFailureAction.putIfAbsent(compilerOptionsMap, Print);
 383 


 384         this.compilerOptions = new OptionValues(compilerOptionsMap);
 385     }
 386 
 387     public CompileTheWorld(HotSpotJVMCIRuntime jvmciRuntime,
 388                     HotSpotGraalCompiler compiler,
 389                     OptionValues harnessOptions,
 390                     OptionValues compilerOptions) {
 391         this(jvmciRuntime, compiler, Options.Classpath.getValue(harnessOptions),
 392                         Options.StartAt.getValue(harnessOptions),
 393                         Options.StopAt.getValue(harnessOptions),
 394                         Options.MaxClasses.getValue(harnessOptions),
 395                         Options.MethodFilter.getValue(harnessOptions),
 396                         Options.ExcludeMethodFilter.getValue(harnessOptions),
 397                         Options.Verbose.hasBeenSet(harnessOptions) ? Options.Verbose.getValue(harnessOptions) : !Options.MultiThreaded.getValue(harnessOptions),
 398                         harnessOptions,
 399                         new OptionValues(compilerOptions, parseOptions(Options.Config.getValue(harnessOptions))));
 400     }
 401 
 402     /**
 403      * Compiles all methods in all classes in {@link #inputClassPath}. If {@link #inputClassPath}
</pre>
<hr />
<pre>
 628                                     String base = p.getName(nameCount - 1).toString();
 629                                     if (base.endsWith(&quot;.class&quot;) &amp;&amp; !base.equals(&quot;module-info.class&quot;)) {
 630                                         String module = p.getName(1).toString();
 631                                         if (positive.isEmpty() || positive.contains(module)) {
 632                                             if (negative.isEmpty() || !negative.contains(module)) {
 633                                                 // Strip module prefix and convert to dotted form
 634                                                 String className = p.subpath(2, nameCount).toString().replace(&#39;/&#39;, &#39;.&#39;);
 635                                                 // Strip &quot;.class&quot; suffix
 636                                                 className = className.replace(&#39;/&#39;, &#39;.&#39;).substring(0, className.length() - &quot;.class&quot;.length());
 637                                                 classNames.add(className);
 638                                             }
 639                                         }
 640                                     }
 641                                 }
 642                             });
 643             return classNames;
 644         }
 645     }
 646 
 647     private boolean isClassIncluded(String className) {
<span class="line-modified"> 648         if (methodFilter != null &amp;&amp; !methodFilter.matchesClassName(className)) {</span>
 649             return false;
 650         }
<span class="line-modified"> 651         if (excludeMethodFilter != null &amp;&amp; excludeMethodFilter.matchesClassName(className)) {</span>
 652             return false;
 653         }
 654         return true;
 655     }
 656 
 657     private ClassPathEntry openClassPathEntry(String entry) throws IOException {
 658         if (entry.endsWith(&quot;.zip&quot;) || entry.endsWith(&quot;.jar&quot;)) {
 659             return new JarClassPathEntry(entry);
 660         } else if (entry.equals(JRT_CLASS_PATH_ENTRY)) {
 661             return new JRTClassPathEntry(entry, Options.LimitModules.getValue(harnessOptions));
 662         } else {
 663             if (!new File(entry).isDirectory()) {
 664                 return null;
 665             }
 666             return new DirClassPathEntry(entry);
 667         }
 668     }
 669 
 670     /**
 671      * Compiles all methods in all classes in a given class path.
</pre>
<hr />
<pre>
 725             }
 726 
 727             int lastClassFile = totalClassFileCount - 1;
 728             compileStartAt = Math.min(startAt, lastClassFile);
 729             compileStopAt = Math.min(stopAt, lastClassFile);
 730             int range = compileStopAt - compileStartAt + 1;
 731             if (maxClasses &lt; range) {
 732                 compileStep = range / maxClasses;
 733             }
 734         }
 735 
 736         for (int i = 0; i &lt; entries.length; i++) {
 737             final String entry = entries[i];
 738             try (ClassPathEntry cpe = openClassPathEntry(entry)) {
 739                 if (cpe == null) {
 740                     println(&quot;CompileTheWorld : Skipped classes in &quot; + entry);
 741                     println();
 742                     continue;
 743                 }
 744 
<span class="line-modified"> 745                 if (methodFilter == null || methodFilter.matchesNothing()) {</span>
 746                     println(&quot;CompileTheWorld : Compiling all classes in &quot; + entry);
 747                 } else {
<span class="line-modified"> 748                     String include = methodFilter.toString();</span>
 749                     println(&quot;CompileTheWorld : Compiling all methods in &quot; + entry + &quot; matching one of the following filters: &quot; + include);
 750                 }
<span class="line-modified"> 751                 if (excludeMethodFilter != null &amp;&amp; !excludeMethodFilter.matchesNothing()) {</span>
<span class="line-modified"> 752                     String exclude = excludeMethodFilter.toString();</span>
 753                     println(&quot;CompileTheWorld : Excluding all methods matching one of the following filters: &quot; + exclude);
 754                 }
 755                 println();
 756 
 757                 ClassLoader loader = cpe.createClassLoader();
 758 
 759                 for (String className : cpe.getClassNames()) {
 760 
 761                     // Are we done?
 762                     if (classFileCounter &gt;= compileStopAt) {
 763                         break;
 764                     }
 765 
 766                     classFileCounter++;
 767 
 768                     if (compileStep &gt; 1 &amp;&amp; ((classFileCounter - compileStartAt) % compileStep) != 0) {
 769                         continue;
 770                     }
 771 
 772                     if (className.startsWith(&quot;jdk.management.&quot;) ||
</pre>
<hr />
<pre>
 908         }
 909     }
 910 
 911     private synchronized void startThreads() {
 912         running = true;
 913         // Wake up any waiting threads
 914         notifyAll();
 915     }
 916 
 917     private synchronized void waitToRun() {
 918         while (!running) {
 919             try {
 920                 wait();
 921             } catch (InterruptedException e) {
 922             }
 923         }
 924     }
 925 
 926     @SuppressWarnings(&quot;try&quot;)
 927     private void compileMethod(HotSpotResolvedJavaMethod method, LibGraalParams libgraal) throws InterruptedException, ExecutionException {
<span class="line-modified"> 928         if (methodFilter != null &amp;&amp; !methodFilter.matches(method)) {</span>
 929             return;
 930         }
<span class="line-modified"> 931         if (excludeMethodFilter != null &amp;&amp; excludeMethodFilter.matches(method)) {</span>
 932             return;
 933         }
 934         Future&lt;?&gt; task = threadPool.submit(new Runnable() {
 935             @Override
 936             public void run() {
 937                 waitToRun();
 938                 compileMethod(method, classFileCounter, libgraal);
 939             }
 940         });
 941         if (threadPool.getCorePoolSize() == 1) {
 942             task.get();
 943         }
 944     }
 945 
 946     private static final Unsafe UNSAFE = GraalUnsafeAccess.getUnsafe();
 947 
 948     /**
 949      * Implemented by
 950      * {@code com.oracle.svm.graal.hotspot.libgraal.LibGraalEntryPoints.compileMethod}.
 951      */
</pre>
<hr />
<pre>
1017             compileTime.getAndAdd(System.nanoTime() - start);
1018             compiledMethodsCounter.incrementAndGet();
1019         } catch (Throwable t) {
1020             // Catch everything and print a message
1021             println(&quot;CompileTheWorld (%d) : Error compiling method: %s&quot;, counter, method.format(&quot;%H.%n(%p):%r&quot;));
1022             printStackTrace(t);
1023         }
1024     }
1025 
1026     /**
1027      * Determines if a method should be compiled (Cf. CompilationPolicy::can_be_compiled).
1028      *
1029      * @return true if it can be compiled, false otherwise
1030      */
1031     private boolean canBeCompiled(HotSpotResolvedJavaMethod javaMethod, int modifiers) {
1032         if (Modifier.isAbstract(modifiers) || Modifier.isNative(modifiers)) {
1033             return false;
1034         }
1035         GraalHotSpotVMConfig c = compiler.getGraalRuntime().getVMConfig();
1036         if (c.dontCompileHugeMethods &amp;&amp; javaMethod.getCodeSize() &gt; c.hugeMethodLimit) {
<span class="line-modified">1037             println(verbose || methodFilter != null,</span>
1038                             String.format(&quot;CompileTheWorld (%d) : Skipping huge method %s (use -XX:-DontCompileHugeMethods or -XX:HugeMethodLimit=%d to include it)&quot;, classFileCounter,
1039                                             javaMethod.format(&quot;%H.%n(%p):%r&quot;),
1040                                             javaMethod.getCodeSize()));
1041             return false;
1042         }
1043         // Allow use of -XX:CompileCommand=dontinline to exclude problematic methods
1044         if (!javaMethod.canBeInlined()) {
1045             return false;
1046         }
1047         // Skip @Snippets for now
1048         for (Annotation annotation : javaMethod.getAnnotations()) {
1049             if (annotation.annotationType().equals(Snippet.class)) {
1050                 return false;
1051             }
1052         }
1053         return true;
1054     }
1055 
1056     static class Options {
1057         public static final OptionKey&lt;Boolean&gt; Help = new OptionKey&lt;&gt;(false);
</pre>
</td>
</tr>
</table>
<center><a href="CompilationWrapperTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="CompileTheWorldTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
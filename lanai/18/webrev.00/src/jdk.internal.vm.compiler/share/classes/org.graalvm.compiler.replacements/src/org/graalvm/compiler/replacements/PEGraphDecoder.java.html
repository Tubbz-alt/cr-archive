<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/PEGraphDecoder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.replacements;
  26 
  27 import static org.graalvm.compiler.debug.GraalError.unimplemented;
  28 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_IGNORED;
  29 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_IGNORED;
  30 
  31 import java.net.URI;
  32 import java.util.ArrayList;
  33 import java.util.Arrays;
  34 import java.util.Formatter;
  35 import java.util.HashMap;
  36 import java.util.List;
  37 import java.util.Map;
  38 
  39 import jdk.internal.vm.compiler.collections.EconomicMap;
  40 import jdk.internal.vm.compiler.collections.Equivalence;
  41 import org.graalvm.compiler.api.replacements.Fold;
  42 import org.graalvm.compiler.bytecode.Bytecode;
  43 import org.graalvm.compiler.bytecode.BytecodeProvider;
  44 import org.graalvm.compiler.core.common.PermanentBailoutException;
  45 import org.graalvm.compiler.core.common.cfg.CFGVerifier;
  46 import org.graalvm.compiler.core.common.spi.ConstantFieldProvider;
  47 import org.graalvm.compiler.core.common.type.Stamp;
  48 import org.graalvm.compiler.core.common.type.StampFactory;
  49 import org.graalvm.compiler.core.common.type.StampPair;
  50 import org.graalvm.compiler.debug.DebugCloseable;
  51 import org.graalvm.compiler.debug.DebugContext;
  52 import org.graalvm.compiler.debug.GraalError;
  53 import org.graalvm.compiler.graph.Node;
  54 import org.graalvm.compiler.graph.Node.NodeIntrinsic;
  55 import org.graalvm.compiler.graph.NodeClass;
  56 import org.graalvm.compiler.graph.NodeSourcePosition;
  57 import org.graalvm.compiler.graph.SourceLanguagePosition;
  58 import org.graalvm.compiler.graph.SourceLanguagePositionProvider;
  59 import org.graalvm.compiler.graph.spi.Canonicalizable;
  60 import org.graalvm.compiler.java.GraphBuilderPhase;
  61 import org.graalvm.compiler.nodeinfo.NodeInfo;
  62 import org.graalvm.compiler.nodes.AbstractBeginNode;
  63 import org.graalvm.compiler.nodes.AbstractMergeNode;
  64 import org.graalvm.compiler.nodes.CallTargetNode;
  65 import org.graalvm.compiler.nodes.CallTargetNode.InvokeKind;
  66 import org.graalvm.compiler.nodes.ControlSinkNode;
  67 import org.graalvm.compiler.nodes.DeoptimizeNode;
  68 import org.graalvm.compiler.nodes.EncodedGraph;
  69 import org.graalvm.compiler.nodes.FixedNode;
  70 import org.graalvm.compiler.nodes.FixedWithNextNode;
  71 import org.graalvm.compiler.nodes.FrameState;
  72 import org.graalvm.compiler.nodes.IfNode;
  73 import org.graalvm.compiler.nodes.Invoke;
  74 import org.graalvm.compiler.nodes.InvokeWithExceptionNode;
  75 import org.graalvm.compiler.nodes.MergeNode;
  76 import org.graalvm.compiler.nodes.NodeView;
  77 import org.graalvm.compiler.nodes.ParameterNode;
  78 import org.graalvm.compiler.nodes.ReturnNode;
  79 import org.graalvm.compiler.nodes.SimplifyingGraphDecoder;
  80 import org.graalvm.compiler.nodes.StateSplit;
  81 import org.graalvm.compiler.nodes.StructuredGraph;
  82 import org.graalvm.compiler.nodes.UnwindNode;
  83 import org.graalvm.compiler.nodes.ValueNode;
  84 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
  85 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
  86 import org.graalvm.compiler.nodes.extended.IntegerSwitchNode;
  87 import org.graalvm.compiler.nodes.graphbuilderconf.GeneratedInvocationPlugin;
  88 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
  89 import org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin;
  90 import org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin.InlineInfo;
  91 import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext;
  92 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
  93 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
  94 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.InvocationPluginReceiver;
  95 import org.graalvm.compiler.nodes.graphbuilderconf.LoopExplosionPlugin;
  96 import org.graalvm.compiler.nodes.graphbuilderconf.LoopExplosionPlugin.LoopExplosionKind;
  97 import org.graalvm.compiler.nodes.graphbuilderconf.MethodSubstitutionPlugin;
  98 import org.graalvm.compiler.nodes.graphbuilderconf.NodePlugin;
  99 import org.graalvm.compiler.nodes.graphbuilderconf.ParameterPlugin;
 100 import org.graalvm.compiler.nodes.java.LoadFieldNode;
 101 import org.graalvm.compiler.nodes.java.LoadIndexedNode;
 102 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
 103 import org.graalvm.compiler.nodes.java.MonitorIdNode;
 104 import org.graalvm.compiler.nodes.java.NewArrayNode;
 105 import org.graalvm.compiler.nodes.java.NewInstanceNode;
 106 import org.graalvm.compiler.nodes.java.NewMultiArrayNode;
 107 import org.graalvm.compiler.nodes.java.StoreFieldNode;
 108 import org.graalvm.compiler.nodes.java.StoreIndexedNode;
 109 import org.graalvm.compiler.nodes.spi.CoreProviders;
 110 import org.graalvm.compiler.nodes.spi.Replacements;
 111 import org.graalvm.compiler.nodes.spi.StampProvider;
 112 import org.graalvm.compiler.nodes.type.StampTool;
 113 import org.graalvm.compiler.nodes.util.GraphUtil;
 114 import org.graalvm.compiler.options.Option;
 115 import org.graalvm.compiler.options.OptionKey;
 116 import org.graalvm.compiler.options.OptionType;
 117 import org.graalvm.compiler.options.OptionValues;
 118 import org.graalvm.compiler.phases.common.inlining.InliningUtil;
 119 
 120 import jdk.vm.ci.code.Architecture;
 121 import jdk.vm.ci.code.BailoutException;
 122 import jdk.vm.ci.code.BytecodeFrame;
 123 import jdk.vm.ci.meta.Assumptions;
 124 import jdk.vm.ci.meta.ConstantReflectionProvider;
 125 import jdk.vm.ci.meta.DeoptimizationAction;
 126 import jdk.vm.ci.meta.DeoptimizationReason;
 127 import jdk.vm.ci.meta.JavaConstant;
 128 import jdk.vm.ci.meta.JavaKind;
 129 import jdk.vm.ci.meta.JavaType;
 130 import jdk.vm.ci.meta.MetaAccessProvider;
 131 import jdk.vm.ci.meta.ResolvedJavaField;
 132 import jdk.vm.ci.meta.ResolvedJavaMethod;
 133 import jdk.vm.ci.meta.ResolvedJavaType;
 134 
 135 /**
 136  * A graph decoder that performs partial evaluation, i.e., that performs method inlining and
 137  * canonicalization/simplification of nodes during decoding.
 138  *
 139  * Inlining and loop explosion are configured via the plugin mechanism also used by the
 140  * {@link GraphBuilderPhase}. However, not all callback methods defined in
 141  * {@link GraphBuilderContext} are available since decoding is more limited than graph building.
 142  *
 143  * The standard {@link Canonicalizable#canonical node canonicalization} interface is used to
 144  * canonicalize nodes during decoding. Additionally, {@link IfNode branches} and
 145  * {@link IntegerSwitchNode switches} with constant conditions are simplified.
 146  */
 147 public abstract class PEGraphDecoder extends SimplifyingGraphDecoder {
 148 
 149     private static final Object CACHED_NULL_VALUE = new Object();
 150 
 151     public static class Options {
 152         @Option(help = &quot;Maximum inlining depth during partial evaluation before reporting an infinite recursion&quot;)//
 153         public static final OptionKey&lt;Integer&gt; InliningDepthError = new OptionKey&lt;&gt;(1000);
 154 
 155         @Option(help = &quot;Max number of loop explosions per method.&quot;, type = OptionType.Debug)//
 156         public static final OptionKey&lt;Integer&gt; MaximumLoopExplosionCount = new OptionKey&lt;&gt;(10000);
 157 
 158         @Option(help = &quot;Do not bail out but throw an exception on failed loop explosion.&quot;, type = OptionType.Debug)//
 159         public static final OptionKey&lt;Boolean&gt; FailedLoopExplosionIsFatal = new OptionKey&lt;&gt;(false);
 160     }
 161 
 162     protected class PEMethodScope extends MethodScope {
 163         /** The state of the caller method. Only non-null during method inlining. */
 164         protected final PEMethodScope caller;
 165         protected final ResolvedJavaMethod method;
 166         protected final InvokeData invokeData;
 167         protected final int inliningDepth;
 168 
 169         protected final ValueNode[] arguments;
 170         private SourceLanguagePosition sourceLanguagePosition = UnresolvedSourceLanguagePosition.INSTANCE;
 171 
 172         protected FrameState outerState;
 173         protected FrameState exceptionState;
 174         protected ExceptionPlaceholderNode exceptionPlaceholderNode;
 175         protected NodeSourcePosition callerBytecodePosition;
 176 
 177         protected PEMethodScope(StructuredGraph targetGraph, PEMethodScope caller, LoopScope callerLoopScope, EncodedGraph encodedGraph, ResolvedJavaMethod method, InvokeData invokeData,
 178                         int inliningDepth, LoopExplosionPlugin loopExplosionPlugin, ValueNode[] arguments) {
 179             super(callerLoopScope, targetGraph, encodedGraph, loopExplosionKind(method, loopExplosionPlugin));
 180 
 181             this.caller = caller;
 182             this.method = method;
 183             this.invokeData = invokeData;
 184             this.inliningDepth = inliningDepth;
 185             this.arguments = arguments;
 186         }
 187 
 188         @Override
 189         public boolean isInlinedMethod() {
 190             return caller != null;
 191         }
 192 
 193         /**
 194          * Gets the call stack representing this method scope and its callers.
 195          */
 196         public StackTraceElement[] getCallStack() {
 197             StackTraceElement[] stack = new StackTraceElement[inliningDepth + 1];
 198             PEMethodScope frame = this;
 199             int index = 0;
 200             int bci = -1;
 201             while (frame != null) {
 202                 stack[index++] = frame.method.asStackTraceElement(bci);
 203                 bci = frame.invokeData == null ? 0 : frame.invokeData.invoke.bci();
 204                 frame = frame.caller;
 205             }
 206             assert index == stack.length : index + &quot; != &quot; + stack.length;
 207             return stack;
 208         }
 209 
 210         @Override
 211         public NodeSourcePosition getCallerBytecodePosition(NodeSourcePosition position) {
 212             if (caller == null) {
 213                 return position;
 214             }
 215             if (callerBytecodePosition == null) {
 216                 NodeSourcePosition invokePosition = invokeData.invoke.asNode().getNodeSourcePosition();
 217                 if (invokePosition == null) {
 218                     assert position == null : &quot;should only happen when tracking is disabled&quot;;
 219                     return null;
 220                 }
 221                 callerBytecodePosition = invokePosition;
 222             }
 223             if (position != null) {
 224                 return position.addCaller(caller.resolveSourceLanguagePosition(), callerBytecodePosition);
 225             }
 226             final SourceLanguagePosition pos = caller.resolveSourceLanguagePosition();
 227             if (pos != null &amp;&amp; callerBytecodePosition != null) {
 228                 return new NodeSourcePosition(pos, callerBytecodePosition.getCaller(), callerBytecodePosition.getMethod(), callerBytecodePosition.getBCI());
 229             }
 230             return callerBytecodePosition;
 231         }
 232 
 233         private SourceLanguagePosition resolveSourceLanguagePosition() {
 234             SourceLanguagePosition res = sourceLanguagePosition;
 235             if (res == UnresolvedSourceLanguagePosition.INSTANCE) {
 236                 res = null;
 237                 if (arguments != null &amp;&amp; method.hasReceiver() &amp;&amp; arguments.length &gt; 0 &amp;&amp; arguments[0].isJavaConstant()) {
 238                     JavaConstant constantArgument = arguments[0].asJavaConstant();
 239                     res = sourceLanguagePositionProvider.getPosition(constantArgument);
 240                 }
 241                 sourceLanguagePosition = res;
 242             }
 243             return res;
 244         }
 245 
 246         @Override
 247         public String toString() {
 248             return getClass().getSimpleName() + &#39;[&#39; + method.format(&quot;%H.%n(%p)&quot;) + &#39;]&#39;;
 249         }
 250     }
 251 
 252     private static final class UnresolvedSourceLanguagePosition implements SourceLanguagePosition {
 253         static final SourceLanguagePosition INSTANCE = new UnresolvedSourceLanguagePosition();
 254 
 255         @Override
 256         public String toShortString() {
 257             throw new IllegalStateException(getClass().getSimpleName() + &quot; should not be reachable.&quot;);
 258         }
 259 
 260         @Override
 261         public int getOffsetEnd() {
 262             throw new IllegalStateException(getClass().getSimpleName() + &quot; should not be reachable.&quot;);
 263         }
 264 
 265         @Override
 266         public int getOffsetStart() {
 267             throw new IllegalStateException(getClass().getSimpleName() + &quot; should not be reachable.&quot;);
 268         }
 269 
 270         @Override
 271         public int getLineNumber() {
 272             throw new IllegalStateException(getClass().getSimpleName() + &quot; should not be reachable.&quot;);
 273         }
 274 
 275         @Override
 276         public URI getURI() {
 277             throw new IllegalStateException(getClass().getSimpleName() + &quot; should not be reachable.&quot;);
 278         }
 279 
 280         @Override
 281         public String getLanguage() {
 282             throw new IllegalStateException(getClass().getSimpleName() + &quot; should not be reachable.&quot;);
 283         }
 284     }
 285 
 286     protected class PENonAppendGraphBuilderContext implements GraphBuilderContext {
 287         protected final PEMethodScope methodScope;
 288         protected final Invoke invoke;
 289 
 290         @Override
 291         public ExternalInliningContext getExternalInliningContext() {
 292             return new ExternalInliningContext() {
 293                 @Override
 294                 public int getInlinedDepth() {
 295                     int count = 0;
 296                     PEGraphDecoder.PEMethodScope scope = methodScope;
 297                     while (scope != null) {
 298                         if (scope.method.equals(callInlinedMethod) || scope.method.equals(callInlinedAgnosticMethod)) {
 299                             count++;
 300                         }
 301                         scope = scope.caller;
 302                     }
 303                     return count;
 304                 }
 305             };
 306         }
 307 
 308         public PENonAppendGraphBuilderContext(PEMethodScope methodScope, Invoke invoke) {
 309             this.methodScope = methodScope;
 310             this.invoke = invoke;
 311         }
 312 
 313         /**
 314          * {@link Fold} and {@link NodeIntrinsic} can be deferred during parsing/decoding. Only by
 315          * the end of {@linkplain SnippetTemplate#instantiate Snippet instantiation} do they need to
 316          * have been processed.
 317          *
 318          * This is how SVM handles snippets. They are parsed with plugins disabled and then encoded
 319          * and stored in the image. When the snippet is needed at runtime the graph is decoded and
 320          * the plugins are run during the decoding process. If they aren&#39;t handled at this point
 321          * then they will never be handled.
 322          */
 323         @Override
 324         public boolean canDeferPlugin(GeneratedInvocationPlugin plugin) {
 325             return plugin.isGeneratedFromFoldOrNodeIntrinsic();
 326         }
 327 
 328         @Override
 329         public BailoutException bailout(String string) {
 330             BailoutException bailout = new PermanentBailoutException(string);
 331             throw GraphUtil.createBailoutException(string, bailout, methodScope.getCallStack());
 332         }
 333 
 334         @Override
 335         public StampProvider getStampProvider() {
 336             return providers.getStampProvider();
 337         }
 338 
 339         @Override
 340         public MetaAccessProvider getMetaAccess() {
 341             return providers.getMetaAccess();
 342         }
 343 
 344         @Override
 345         public ConstantReflectionProvider getConstantReflection() {
 346             return providers.getConstantReflection();
 347         }
 348 
 349         @Override
 350         public ConstantFieldProvider getConstantFieldProvider() {
 351             return providers.getConstantFieldProvider();
 352         }
 353 
 354         @Override
 355         public Replacements getReplacements() {
 356             return providers.getReplacements();
 357         }
 358 
 359         @Override
 360         public StructuredGraph getGraph() {
 361             return graph;
 362         }
 363 
 364         @Override
 365         public int getDepth() {
 366             return methodScope.inliningDepth;
 367         }
 368 
 369         @Override
 370         public IntrinsicContext getIntrinsic() {
 371             return PEGraphDecoder.this.getIntrinsic();
 372         }
 373 
 374         @Override
 375         public &lt;T extends ValueNode&gt; T append(T value) {
 376             throw unimplemented();
 377         }
 378 
 379         @Override
 380         public void push(JavaKind kind, ValueNode value) {
 381             throw unimplemented();
 382         }
 383 
 384         @Override
 385         public Invoke handleReplacedInvoke(InvokeKind invokeKind, ResolvedJavaMethod targetMethod, ValueNode[] args, boolean inlineEverything) {
 386             throw unimplemented();
 387         }
 388 
 389         @Override
 390         public void handleReplacedInvoke(CallTargetNode callTarget, JavaKind resultType) {
 391             throw unimplemented();
 392         }
 393 
 394         @Override
 395         public boolean intrinsify(BytecodeProvider bytecodeProvider, ResolvedJavaMethod targetMethod, ResolvedJavaMethod substitute, InvocationPlugin.Receiver receiver, ValueNode[] args) {
 396             return false;
 397         }
 398 
 399         @Override
 400         public boolean intrinsify(ResolvedJavaMethod targetMethod, StructuredGraph substituteGraph, InvocationPlugin.Receiver receiver, ValueNode[] argsIncludingReceiver) {
 401             return false;
 402         }
 403 
 404         @Override
 405         public void setStateAfter(StateSplit stateSplit) {
 406             throw unimplemented();
 407         }
 408 
 409         @Override
 410         public GraphBuilderContext getParent() {
 411             throw unimplemented();
 412         }
 413 
 414         @Override
 415         public Bytecode getCode() {
 416             throw unimplemented();
 417         }
 418 
 419         @Override
 420         public ResolvedJavaMethod getMethod() {
 421             return methodScope.method;
 422         }
 423 
 424         @Override
 425         public int bci() {
 426             // There is no BCI available when decoding an encoded method
 427             return -1;
 428         }
 429 
 430         @Override
 431         public InvokeKind getInvokeKind() {
 432             throw unimplemented();
 433         }
 434 
 435         @Override
 436         public JavaType getInvokeReturnType() {
 437             throw unimplemented();
 438         }
 439 
 440         @Override
 441         public String toString() {
 442             Formatter fmt = new Formatter();
 443             fmt.format(&quot;Decoding %s&quot;, methodScope.method.format(&quot;%H.%n(%p)&quot;));
 444             for (StackTraceElement e : methodScope.getCallStack()) {
 445                 fmt.format(&quot;%n\tat %s&quot;, e);
 446             }
 447             return fmt.toString();
 448         }
 449     }
 450 
 451     protected IntrinsicContext getIntrinsic() {
 452         return null;
 453     }
 454 
 455     protected class PEAppendGraphBuilderContext extends PENonAppendGraphBuilderContext {
 456         protected FixedWithNextNode lastInstr;
 457         protected ValueNode pushedNode;
 458         protected boolean invokeConsumed;
 459         protected final InvokeKind invokeKind;
 460         protected final JavaType invokeReturnType;
 461 
 462         public PEAppendGraphBuilderContext(PEMethodScope inlineScope, FixedWithNextNode lastInstr) {
 463             this(inlineScope, lastInstr, null, null);
 464         }
 465 
 466         public PEAppendGraphBuilderContext(PEMethodScope inlineScope, FixedWithNextNode lastInstr, InvokeKind invokeKind, JavaType invokeReturnType) {
 467             super(inlineScope, inlineScope.invokeData != null ? inlineScope.invokeData.invoke : null);
 468             this.lastInstr = lastInstr;
 469             this.invokeKind = invokeKind;
 470             this.invokeReturnType = invokeReturnType;
 471         }
 472 
 473         @Override
 474         public void push(JavaKind kind, ValueNode value) {
 475             if (pushedNode != null) {
 476                 throw unimplemented(&quot;Only one push is supported&quot;);
 477             }
 478             pushedNode = value;
 479         }
 480 
 481         @Override
 482         public void setStateAfter(StateSplit stateSplit) {
 483             Node stateAfter = decodeFloatingNode(methodScope.caller, methodScope.callerLoopScope, methodScope.invokeData.stateAfterOrderId);
 484             getGraph().add(stateAfter);
 485             FrameState fs = (FrameState) handleFloatingNodeAfterAdd(methodScope.caller, methodScope.callerLoopScope, stateAfter);
 486             stateSplit.setStateAfter(fs);
 487         }
 488 
 489         @SuppressWarnings(&quot;try&quot;)
 490         @Override
 491         public &lt;T extends ValueNode&gt; T append(T v) {
 492             if (v.graph() != null) {
 493                 return v;
 494             }
 495             try (DebugCloseable position = withNodeSoucePosition()) {
 496                 T added = getGraph().addOrUniqueWithInputs(v);
 497                 if (added == v) {
 498                     updateLastInstruction(v);
 499                 }
 500                 return added;
 501             }
 502         }
 503 
 504         private DebugCloseable withNodeSoucePosition() {
 505             if (getGraph().trackNodeSourcePosition()) {
 506                 NodeSourcePosition callerBytecodePosition = methodScope.getCallerBytecodePosition();
 507                 if (callerBytecodePosition != null) {
 508                     return getGraph().withNodeSourcePosition(callerBytecodePosition);
 509                 }
 510             }
 511             return null;
 512         }
 513 
 514         private &lt;T extends ValueNode&gt; void updateLastInstruction(T v) {
 515             if (v instanceof FixedNode) {
 516                 FixedNode fixedNode = (FixedNode) v;
 517                 if (lastInstr != null) {
 518                     lastInstr.setNext(fixedNode);
 519                 }
 520                 if (fixedNode instanceof FixedWithNextNode) {
 521                     FixedWithNextNode fixedWithNextNode = (FixedWithNextNode) fixedNode;
 522                     assert fixedWithNextNode.next() == null : &quot;cannot append instruction to instruction which isn&#39;t end&quot;;
 523                     lastInstr = fixedWithNextNode;
 524                 } else {
 525                     lastInstr = null;
 526                 }
 527             }
 528         }
 529 
 530         @Override
 531         public InvokeKind getInvokeKind() {
 532             if (invokeKind != null) {
 533                 return invokeKind;
 534             }
 535             return super.getInvokeKind();
 536         }
 537 
 538         @Override
 539         public JavaType getInvokeReturnType() {
 540             if (invokeReturnType != null) {
 541                 return invokeReturnType;
 542             }
 543             return super.getInvokeReturnType();
 544         }
 545 
 546         @Override
 547         public void handleReplacedInvoke(CallTargetNode callTarget, JavaKind resultType) {
 548             if (invokeConsumed) {
 549                 throw unimplemented(&quot;handleReplacedInvoke can be called only once&quot;);
 550             }
 551             invokeConsumed = true;
 552 
 553             appendInvoke(methodScope.caller, methodScope.callerLoopScope, methodScope.invokeData, callTarget);
 554             updateLastInstruction(invoke.asNode());
 555         }
 556 
 557         @Override
 558         public GraphBuilderContext getNonIntrinsicAncestor() {
 559             return null;
 560         }
 561     }
 562 
 563     @NodeInfo(cycles = CYCLES_IGNORED, size = SIZE_IGNORED)
 564     static class ExceptionPlaceholderNode extends ValueNode {
 565         public static final NodeClass&lt;ExceptionPlaceholderNode&gt; TYPE = NodeClass.create(ExceptionPlaceholderNode.class);
 566 
 567         protected ExceptionPlaceholderNode() {
 568             super(TYPE, StampFactory.object());
 569         }
 570     }
 571 
 572     protected static class SpecialCallTargetCacheKey {
 573         private final InvokeKind invokeKind;
 574         private final ResolvedJavaMethod targetMethod;
 575         private final ResolvedJavaType contextType;
 576         private final Stamp receiverStamp;
 577 
 578         public SpecialCallTargetCacheKey(InvokeKind invokeKind, ResolvedJavaMethod targetMethod, ResolvedJavaType contextType, Stamp receiverStamp) {
 579             this.invokeKind = invokeKind;
 580             this.targetMethod = targetMethod;
 581             this.contextType = contextType;
 582             this.receiverStamp = receiverStamp;
 583         }
 584 
 585         @Override
 586         public int hashCode() {
 587             return invokeKind.hashCode() ^ targetMethod.hashCode() ^ contextType.hashCode() ^ receiverStamp.hashCode();
 588         }
 589 
 590         @Override
 591         public boolean equals(Object obj) {
 592             if (obj instanceof SpecialCallTargetCacheKey) {
 593                 SpecialCallTargetCacheKey key = (SpecialCallTargetCacheKey) obj;
 594                 return key.invokeKind.equals(this.invokeKind) &amp;&amp; key.targetMethod.equals(this.targetMethod) &amp;&amp; key.contextType.equals(this.contextType) &amp;&amp; key.receiverStamp.equals(this.receiverStamp);
 595             }
 596             return false;
 597         }
 598     }
 599 
 600     private final LoopExplosionPlugin loopExplosionPlugin;
 601     private final InvocationPlugins invocationPlugins;
 602     private final InlineInvokePlugin[] inlineInvokePlugins;
 603     private final ParameterPlugin parameterPlugin;
 604     private final NodePlugin[] nodePlugins;
 605     private final EconomicMap&lt;SpecialCallTargetCacheKey, Object&gt; specialCallTargetCache;
 606     private final EconomicMap&lt;ResolvedJavaMethod, Object&gt; invocationPluginCache;
 607     private final ResolvedJavaMethod callInlinedMethod;
 608     private final ResolvedJavaMethod callInlinedAgnosticMethod;
 609     protected final SourceLanguagePositionProvider sourceLanguagePositionProvider;
 610 
 611     public PEGraphDecoder(Architecture architecture, StructuredGraph graph, CoreProviders providers, LoopExplosionPlugin loopExplosionPlugin, InvocationPlugins invocationPlugins,
 612                     InlineInvokePlugin[] inlineInvokePlugins,
 613                     ParameterPlugin parameterPlugin,
 614                     NodePlugin[] nodePlugins, ResolvedJavaMethod callInlinedMethod, ResolvedJavaMethod callInlinedAgnosticMethod, SourceLanguagePositionProvider sourceLanguagePositionProvider) {
 615         super(architecture, graph, providers, true);
 616         this.loopExplosionPlugin = loopExplosionPlugin;
 617         this.invocationPlugins = invocationPlugins;
 618         this.inlineInvokePlugins = inlineInvokePlugins;
 619         this.parameterPlugin = parameterPlugin;
 620         this.nodePlugins = nodePlugins;
 621         this.callInlinedAgnosticMethod = callInlinedAgnosticMethod;
 622         this.specialCallTargetCache = EconomicMap.create(Equivalence.DEFAULT);
 623         this.invocationPluginCache = EconomicMap.create(Equivalence.DEFAULT);
 624         this.callInlinedMethod = callInlinedMethod;
 625         this.sourceLanguagePositionProvider = sourceLanguagePositionProvider;
 626     }
 627 
 628     protected static LoopExplosionKind loopExplosionKind(ResolvedJavaMethod method, LoopExplosionPlugin loopExplosionPlugin) {
 629         if (loopExplosionPlugin == null) {
 630             return LoopExplosionKind.NONE;
 631         } else {
 632             return loopExplosionPlugin.loopExplosionKind(method);
 633         }
 634     }
 635 
 636     @SuppressWarnings(&quot;try&quot;)
 637     public void decode(ResolvedJavaMethod method, boolean isSubstitution, boolean trackNodeSourcePosition) {
 638         try (DebugContext.Scope scope = debug.scope(&quot;PEGraphDecode&quot;, graph)) {
 639             EncodedGraph encodedGraph = lookupEncodedGraph(method, null, null, isSubstitution, trackNodeSourcePosition);
 640             PEMethodScope methodScope = new PEMethodScope(graph, null, null, encodedGraph, method, null, 0, loopExplosionPlugin, null);
 641             decode(createInitialLoopScope(methodScope, null));
 642             cleanupGraph(methodScope);
 643 
 644             debug.dump(DebugContext.VERBOSE_LEVEL, graph, &quot;After graph cleanup&quot;);
 645             assert graph.verify();
 646         } catch (Throwable t) {
 647             throw debug.handle(t);
 648         }
 649 
 650         try {
 651             /* Check that the control flow graph can be computed, to catch problems early. */
 652             assert CFGVerifier.verify(ControlFlowGraph.compute(graph, true, true, true, true));
 653         } catch (Throwable ex) {
 654             throw GraalError.shouldNotReachHere(&quot;Control flow graph not valid after partial evaluation&quot;);
 655         }
 656     }
 657 
 658     @Override
 659     protected void cleanupGraph(MethodScope methodScope) {
 660         super.cleanupGraph(methodScope);
 661 
 662         for (FrameState frameState : graph.getNodes(FrameState.TYPE)) {
 663             if (frameState.bci == BytecodeFrame.UNWIND_BCI) {
 664                 /*
 665                  * handleMissingAfterExceptionFrameState is called during graph decoding from
 666                  * InliningUtil.processFrameState - but during graph decoding it does not do
 667                  * anything because the usages of the frameState are not available yet. So we need
 668                  * to call it again.
 669                  */
 670                 PEMethodScope peMethodScope = (PEMethodScope) methodScope;
 671                 Invoke invoke = peMethodScope.invokeData != null ? peMethodScope.invokeData.invoke : null;
 672                 InliningUtil.handleMissingAfterExceptionFrameState(frameState, invoke, null, true);
 673 
 674                 /*
 675                  * The frameState must be gone now, because it is not a valid deoptimization point.
 676                  */
 677                 assert frameState.isDeleted();
 678             }
 679         }
 680     }
 681 
 682     @Override
 683     protected void checkLoopExplosionIteration(MethodScope s, LoopScope loopScope) {
 684         PEMethodScope methodScope = (PEMethodScope) s;
 685 
 686         if (loopScope.loopIteration &gt; Options.MaximumLoopExplosionCount.getValue(options)) {
 687             throw tooManyLoopExplosionIterations(methodScope, options);
 688         }
 689     }
 690 
 691     private static RuntimeException tooManyLoopExplosionIterations(PEMethodScope methodScope, OptionValues options) {
 692         String message = &quot;too many loop explosion iterations - does the explosion not terminate for method &quot; + methodScope.method + &quot;?&quot;;
 693         RuntimeException bailout = Options.FailedLoopExplosionIsFatal.getValue(options) ? new RuntimeException(message) : new PermanentBailoutException(message);
 694         throw GraphUtil.createBailoutException(message, bailout, methodScope.getCallStack());
 695     }
 696 
 697     @Override
 698     protected LoopScope handleInvoke(MethodScope s, LoopScope loopScope, InvokeData invokeData) {
 699         PEMethodScope methodScope = (PEMethodScope) s;
 700 
 701         /*
 702          * Decode the call target, but do not add it to the graph yet. This avoids adding usages for
 703          * all the arguments, which are expensive to remove again when we can inline the method.
 704          */
 705         assert invokeData.invoke.callTarget() == null : &quot;callTarget edge is ignored during decoding of Invoke&quot;;
 706         CallTargetNode callTarget = (CallTargetNode) decodeFloatingNode(methodScope, loopScope, invokeData.callTargetOrderId);
 707         if (callTarget instanceof MethodCallTargetNode) {
 708             MethodCallTargetNode methodCall = (MethodCallTargetNode) callTarget;
 709             if (methodCall.invokeKind().hasReceiver()) {
 710                 invokeData.constantReceiver = methodCall.arguments().get(0).asJavaConstant();
 711                 NodeSourcePosition invokePosition = invokeData.invoke.asNode().getNodeSourcePosition();
 712                 if (invokeData.constantReceiver != null &amp;&amp; invokePosition != null) {
 713                     // new NodeSourcePosition(invokeData.constantReceiver,
 714                     // invokePosition.getCaller(), invokePosition.getMethod(),
 715                     // invokePosition.getBCI());
 716                 }
 717             }
 718             LoopScope inlineLoopScope = trySimplifyInvoke(methodScope, loopScope, invokeData, (MethodCallTargetNode) callTarget);
 719             if (inlineLoopScope != null) {
 720                 return inlineLoopScope;
 721             }
 722         }
 723 
 724         /* We know that we need an invoke, so now we can add the call target to the graph. */
 725         graph.add(callTarget);
 726         registerNode(loopScope, invokeData.callTargetOrderId, callTarget, false, false);
 727         return super.handleInvoke(methodScope, loopScope, invokeData);
 728     }
 729 
 730     protected LoopScope trySimplifyInvoke(PEMethodScope methodScope, LoopScope loopScope, InvokeData invokeData, MethodCallTargetNode callTarget) {
 731         // attempt to devirtualize the call
 732         ResolvedJavaMethod specialCallTarget = getSpecialCallTarget(invokeData, callTarget);
 733         if (specialCallTarget != null) {
 734             callTarget.setTargetMethod(specialCallTarget);
 735             callTarget.setInvokeKind(InvokeKind.Special);
 736         }
 737 
 738         if (tryInvocationPlugin(methodScope, loopScope, invokeData, callTarget)) {
 739             /*
 740              * The invocation plugin handled the call, so decoding continues in the calling method.
 741              */
 742             return loopScope;
 743         }
 744         LoopScope inlineLoopScope = tryInline(methodScope, loopScope, invokeData, callTarget);
 745         if (inlineLoopScope != null) {
 746             /*
 747              * We can inline the call, so decoding continues in the inlined method.
 748              */
 749             return inlineLoopScope;
 750         }
 751 
 752         for (InlineInvokePlugin plugin : inlineInvokePlugins) {
 753             plugin.notifyNotInlined(new PENonAppendGraphBuilderContext(methodScope, invokeData.invoke), callTarget.targetMethod(), invokeData.invoke);
 754         }
 755         return null;
 756     }
 757 
 758     private ResolvedJavaMethod getSpecialCallTarget(InvokeData invokeData, MethodCallTargetNode callTarget) {
 759         if (callTarget.invokeKind().isDirect()) {
 760             return null;
 761         }
 762 
 763         // check for trivial cases (e.g. final methods, nonvirtual methods)
 764         if (callTarget.targetMethod().canBeStaticallyBound()) {
 765             return callTarget.targetMethod();
 766         }
 767 
 768         SpecialCallTargetCacheKey key = new SpecialCallTargetCacheKey(callTarget.invokeKind(), callTarget.targetMethod(), invokeData.contextType, callTarget.receiver().stamp(NodeView.DEFAULT));
 769         Object specialCallTarget = specialCallTargetCache.get(key);
 770         if (specialCallTarget == null) {
 771             specialCallTarget = MethodCallTargetNode.devirtualizeCall(key.invokeKind, key.targetMethod, key.contextType, graph.getAssumptions(),
 772                             key.receiverStamp);
 773             if (specialCallTarget == null) {
 774                 specialCallTarget = CACHED_NULL_VALUE;
 775             }
 776             specialCallTargetCache.put(key, specialCallTarget);
 777         }
 778 
 779         return specialCallTarget == CACHED_NULL_VALUE ? null : (ResolvedJavaMethod) specialCallTarget;
 780     }
 781 
 782     protected boolean tryInvocationPlugin(PEMethodScope methodScope, LoopScope loopScope, InvokeData invokeData, MethodCallTargetNode callTarget) {
 783         if (invocationPlugins == null || invocationPlugins.isEmpty()) {
 784             return false;
 785         }
 786 
 787         Invoke invoke = invokeData.invoke;
 788 
 789         ResolvedJavaMethod targetMethod = callTarget.targetMethod();
 790         if (loopScope.methodScope.encodedGraph.isCallToOriginal(targetMethod)) {
 791             return false;
 792         }
 793 
 794         InvocationPlugin invocationPlugin = getInvocationPlugin(targetMethod);
 795         if (invocationPlugin == null) {
 796             return false;
 797         }
 798 
 799         if (loopScope.methodScope.encodedGraph.isCallToOriginal(targetMethod)) {
 800             return false;
 801         }
 802 
 803         ValueNode[] arguments = callTarget.arguments().toArray(new ValueNode[0]);
 804         FixedWithNextNode invokePredecessor = (FixedWithNextNode) invoke.asNode().predecessor();
 805 
 806         /*
 807          * Remove invoke from graph so that invocation plugin can append nodes to the predecessor.
 808          */
 809         invoke.asNode().replaceAtPredecessor(null);
 810 
 811         PEMethodScope inlineScope = new PEMethodScope(graph, methodScope, loopScope, null, targetMethod, invokeData, methodScope.inliningDepth + 1, loopExplosionPlugin, arguments);
 812 
 813         JavaType returnType = targetMethod.getSignature().getReturnType(methodScope.method.getDeclaringClass());
 814         PEAppendGraphBuilderContext graphBuilderContext = new PEAppendGraphBuilderContext(inlineScope, invokePredecessor, callTarget.invokeKind(), returnType);
 815         InvocationPluginReceiver invocationPluginReceiver = new InvocationPluginReceiver(graphBuilderContext);
 816 
 817         if (invocationPlugin.execute(graphBuilderContext, targetMethod, invocationPluginReceiver.init(targetMethod, arguments), arguments)) {
 818 
 819             if (graphBuilderContext.invokeConsumed) {
 820                 /* Nothing to do. */
 821             } else if (graphBuilderContext.lastInstr != null) {
 822                 registerNode(loopScope, invokeData.invokeOrderId, graphBuilderContext.pushedNode, true, true);
 823                 invoke.asNode().replaceAtUsages(graphBuilderContext.pushedNode);
 824                 graphBuilderContext.lastInstr.setNext(nodeAfterInvoke(methodScope, loopScope, invokeData, AbstractBeginNode.prevBegin(graphBuilderContext.lastInstr)));
 825                 deleteInvoke(invoke);
 826             } else {
 827                 assert graphBuilderContext.pushedNode == null : &quot;Why push a node when the invoke does not return anyway?&quot;;
 828                 invoke.asNode().replaceAtUsages(null);
 829                 deleteInvoke(invoke);
 830             }
 831             return true;
 832 
 833         } else {
 834             /* Intrinsification failed, restore original state: invoke is in Graph. */
 835             invokePredecessor.setNext(invoke.asNode());
 836             return false;
 837         }
 838     }
 839 
 840     private InvocationPlugin getInvocationPlugin(ResolvedJavaMethod targetMethod) {
 841         Object invocationPlugin = invocationPluginCache.get(targetMethod);
 842         if (invocationPlugin == null) {
 843             invocationPlugin = invocationPlugins.lookupInvocation(targetMethod);
 844             if (invocationPlugin == null) {
 845                 invocationPlugin = CACHED_NULL_VALUE;
 846             }
 847             invocationPluginCache.put(targetMethod, invocationPlugin);
 848         }
 849 
 850         return invocationPlugin == CACHED_NULL_VALUE ? null : (InvocationPlugin) invocationPlugin;
 851     }
 852 
 853     protected LoopScope tryInline(PEMethodScope methodScope, LoopScope loopScope, InvokeData invokeData, MethodCallTargetNode callTarget) {
 854         if (!callTarget.invokeKind().isDirect()) {
 855             return null;
 856         }
 857 
 858         ResolvedJavaMethod targetMethod = callTarget.targetMethod();
 859         if (targetMethod.hasNeverInlineDirective()) {
 860             return null;
 861         }
 862 
 863         ValueNode[] arguments = callTarget.arguments().toArray(new ValueNode[0]);
 864         GraphBuilderContext graphBuilderContext = new PENonAppendGraphBuilderContext(methodScope, invokeData.invoke);
 865 
 866         for (InlineInvokePlugin plugin : inlineInvokePlugins) {
 867             InlineInfo inlineInfo = plugin.shouldInlineInvoke(graphBuilderContext, targetMethod, arguments);
 868             if (inlineInfo != null) {
 869                 if (inlineInfo.allowsInlining()) {
 870                     return doInline(methodScope, loopScope, invokeData, inlineInfo, arguments);
 871                 } else {
 872                     return null;
 873                 }
 874             }
 875         }
 876         return null;
 877     }
 878 
 879     protected LoopScope doInline(PEMethodScope methodScope, LoopScope loopScope, InvokeData invokeData, InlineInfo inlineInfo, ValueNode[] arguments) {
 880         if (!invokeData.invoke.useForInlining()) {
 881             return null;
 882         }
 883         ResolvedJavaMethod inlineMethod = inlineInfo.getMethodToInline();
 884         EncodedGraph graphToInline = lookupEncodedGraph(inlineMethod, inlineInfo.getPlugin(), inlineInfo.getIntrinsicBytecodeProvider(), inlineInfo.isSubstitution(), graph.trackNodeSourcePosition());
 885         if (graphToInline == null) {
 886             return null;
 887         }
 888 
 889         assert !graph.trackNodeSourcePosition() || graphToInline.trackNodeSourcePosition() : graph + &quot; &quot; + graphToInline;
 890         if (methodScope.inliningDepth &gt; Options.InliningDepthError.getValue(options)) {
 891             throw tooDeepInlining(methodScope);
 892         }
 893 
 894         for (InlineInvokePlugin plugin : inlineInvokePlugins) {
 895             plugin.notifyBeforeInline(inlineMethod);
 896         }
 897 
 898         Invoke invoke = invokeData.invoke;
 899         FixedNode invokeNode = invoke.asNode();
 900         FixedWithNextNode predecessor = (FixedWithNextNode) invokeNode.predecessor();
 901         invokeNode.replaceAtPredecessor(null);
 902 
 903         PEMethodScope inlineScope = new PEMethodScope(graph, methodScope, loopScope, graphToInline, inlineMethod, invokeData, methodScope.inliningDepth + 1,
 904                         loopExplosionPlugin, arguments);
 905 
 906         if (!inlineMethod.isStatic()) {
 907             if (StampTool.isPointerAlwaysNull(arguments[0])) {
 908                 /*
 909                  * The receiver is null, so we can unconditionally throw a NullPointerException
 910                  * instead of performing any inlining.
 911                  */
 912                 DeoptimizeNode deoptimizeNode = graph.add(new DeoptimizeNode(DeoptimizationAction.InvalidateReprofile, DeoptimizationReason.NullCheckException));
 913                 predecessor.setNext(deoptimizeNode);
 914                 finishInlining(inlineScope);
 915                 /* Continue decoding in the caller. */
 916                 return loopScope;
 917 
 918             } else if (!StampTool.isPointerNonNull(arguments[0])) {
 919                 /* The receiver might be null, so we need to insert a null check. */
 920                 PEAppendGraphBuilderContext graphBuilderContext = new PEAppendGraphBuilderContext(inlineScope, predecessor);
 921                 arguments[0] = graphBuilderContext.nullCheckedValue(arguments[0]);
 922                 predecessor = graphBuilderContext.lastInstr;
 923             }
 924         }
 925 
 926         LoopScope inlineLoopScope = createInitialLoopScope(inlineScope, predecessor);
 927 
 928         /*
 929          * The GraphEncoder assigns parameters a nodeId immediately after the fixed nodes.
 930          * Initializing createdNodes here avoid decoding and immediately replacing the
 931          * ParameterNodes.
 932          */
 933         int firstArgumentNodeId = inlineScope.maxFixedNodeOrderId + 1;
 934         for (int i = 0; i &lt; arguments.length; i++) {
 935             inlineLoopScope.createdNodes[firstArgumentNodeId + i] = arguments[i];
 936         }
 937 
 938         // Copy assumptions from inlinee to caller
 939         Assumptions assumptions = graph.getAssumptions();
 940         Assumptions inlinedAssumptions = graphToInline.getAssumptions();
 941         if (assumptions != null) {
 942             if (inlinedAssumptions != null) {
 943                 assumptions.record(inlinedAssumptions);
 944             }
 945         } else {
 946             assert inlinedAssumptions == null : String.format(&quot;cannot inline graph (%s) which makes assumptions into a graph (%s) that doesn&#39;t&quot;, inlineMethod, graph);
 947         }
 948 
 949         // Copy inlined methods from inlinee to caller
 950         List&lt;ResolvedJavaMethod&gt; inlinedMethods = graphToInline.getInlinedMethods();
 951         if (inlinedMethods != null) {
 952             for (ResolvedJavaMethod other : inlinedMethods) {
 953                 graph.recordMethod(other);
 954             }
 955         }
 956 
 957         if (graphToInline.getFields() != null) {
 958             for (ResolvedJavaField field : graphToInline.getFields()) {
 959                 graph.recordField(field);
 960             }
 961         }
 962         if (graphToInline.hasUnsafeAccess()) {
 963             graph.markUnsafeAccess();
 964         }
 965 
 966         /*
 967          * Do the actual inlining by returning the initial loop scope for the inlined method scope.
 968          */
 969         return inlineLoopScope;
 970     }
 971 
 972     @Override
 973     protected void finishInlining(MethodScope is) {
 974         PEMethodScope inlineScope = (PEMethodScope) is;
 975         ResolvedJavaMethod inlineMethod = inlineScope.method;
 976         PEMethodScope methodScope = inlineScope.caller;
 977         LoopScope loopScope = inlineScope.callerLoopScope;
 978         InvokeData invokeData = inlineScope.invokeData;
 979         Invoke invoke = invokeData.invoke;
 980         FixedNode invokeNode = invoke.asNode();
 981 
 982         ValueNode exceptionValue = null;
 983         int returnNodeCount = 0;
 984         int unwindNodeCount = 0;
 985         List&lt;ControlSinkNode&gt; returnAndUnwindNodes = inlineScope.returnAndUnwindNodes;
 986         for (int i = 0; i &lt; returnAndUnwindNodes.size(); i++) {
 987             FixedNode fixedNode = returnAndUnwindNodes.get(i);
 988             if (fixedNode instanceof ReturnNode) {
 989                 returnNodeCount++;
 990             } else if (fixedNode.isAlive()) {
 991                 assert fixedNode instanceof UnwindNode;
 992                 unwindNodeCount++;
 993             }
 994         }
 995 
 996         if (unwindNodeCount &gt; 0) {
 997             FixedNode unwindReplacement;
 998             if (invoke instanceof InvokeWithExceptionNode) {
 999                 /* Decoding continues for the exception handler. */
1000                 unwindReplacement = makeStubNode(methodScope, loopScope, invokeData.exceptionNextOrderId);
1001             } else {
1002                 /* No exception handler available, so the only thing we can do is deoptimize. */
1003                 unwindReplacement = graph.add(new DeoptimizeNode(DeoptimizationAction.InvalidateRecompile, DeoptimizationReason.NotCompiledExceptionHandler));
1004             }
1005 
1006             if (unwindNodeCount == 1) {
1007                 /* Only one UnwindNode, we can use the exception directly. */
1008                 UnwindNode unwindNode = getSingleMatchingNode(returnAndUnwindNodes, returnNodeCount &gt; 0, UnwindNode.class);
1009                 exceptionValue = unwindNode.exception();
1010                 unwindNode.replaceAndDelete(unwindReplacement);
1011 
1012             } else {
1013                 /*
1014                  * More than one UnwindNode. This can happen with the loop explosion strategy
1015                  * FULL_EXPLODE_UNTIL_RETURN, where we keep exploding after the loop and therefore
1016                  * also explode exception paths. Merge the exception in a similar way as multiple
1017                  * return values.
1018                  */
1019                 MergeNode unwindMergeNode = graph.add(new MergeNode());
1020                 exceptionValue = InliningUtil.mergeValueProducers(unwindMergeNode, getMatchingNodes(returnAndUnwindNodes, returnNodeCount &gt; 0, UnwindNode.class, unwindNodeCount),
1021                                 null, unwindNode -&gt; unwindNode.exception());
1022                 unwindMergeNode.setNext(unwindReplacement);
1023 
1024                 ensureExceptionStateDecoded(inlineScope);
1025                 unwindMergeNode.setStateAfter(inlineScope.exceptionState.duplicateModified(JavaKind.Object, JavaKind.Object, exceptionValue));
1026             }
1027         }
1028 
1029         assert invoke.next() == null;
1030         assert !(invoke instanceof InvokeWithExceptionNode) || ((InvokeWithExceptionNode) invoke).exceptionEdge() == null;
1031 
1032         ValueNode returnValue;
1033         if (returnNodeCount == 0) {
1034             returnValue = null;
1035         } else if (returnNodeCount == 1) {
1036             ReturnNode returnNode = getSingleMatchingNode(returnAndUnwindNodes, unwindNodeCount &gt; 0, ReturnNode.class);
1037             returnValue = returnNode.result();
1038             FixedNode n = nodeAfterInvoke(methodScope, loopScope, invokeData, AbstractBeginNode.prevBegin(returnNode));
1039             returnNode.replaceAndDelete(n);
1040         } else {
1041             AbstractMergeNode merge = graph.add(new MergeNode());
1042             merge.setStateAfter((FrameState) ensureNodeCreated(methodScope, loopScope, invokeData.stateAfterOrderId));
1043             returnValue = InliningUtil.mergeReturns(merge, getMatchingNodes(returnAndUnwindNodes, unwindNodeCount &gt; 0, ReturnNode.class, returnNodeCount));
1044             FixedNode n = nodeAfterInvoke(methodScope, loopScope, invokeData, merge);
1045             merge.setNext(n);
1046         }
1047         invokeNode.replaceAtUsages(returnValue);
1048 
1049         /*
1050          * Usage the handles that we have on the return value and the exception to update the
1051          * orderId-&gt;Node table.
1052          */
1053         registerNode(loopScope, invokeData.invokeOrderId, returnValue, true, true);
1054         if (invoke instanceof InvokeWithExceptionNode) {
1055             registerNode(loopScope, invokeData.exceptionOrderId, exceptionValue, true, true);
1056         }
1057         if (inlineScope.exceptionPlaceholderNode != null) {
1058             inlineScope.exceptionPlaceholderNode.replaceAtUsagesAndDelete(exceptionValue);
1059         }
1060         deleteInvoke(invoke);
1061 
1062         for (InlineInvokePlugin plugin : inlineInvokePlugins) {
1063             plugin.notifyAfterInline(inlineMethod);
1064         }
1065     }
1066 
1067     @SuppressWarnings(&quot;unchecked&quot;)
1068     private static &lt;T&gt; T getSingleMatchingNode(List&lt;ControlSinkNode&gt; returnAndUnwindNodes, boolean hasNonMatchingEntries, Class&lt;T&gt; clazz) {
1069         if (!hasNonMatchingEntries) {
1070             assert returnAndUnwindNodes.size() == 1;
1071             return (T) returnAndUnwindNodes.get(0);
1072         }
1073 
1074         for (int i = 0; i &lt; returnAndUnwindNodes.size(); i++) {
1075             ControlSinkNode node = returnAndUnwindNodes.get(i);
1076             if (clazz.isInstance(node)) {
1077                 return (T) node;
1078             }
1079         }
1080         throw GraalError.shouldNotReachHere();
1081     }
1082 
1083     @SuppressWarnings(&quot;unchecked&quot;)
1084     private static &lt;T&gt; List&lt;T&gt; getMatchingNodes(List&lt;ControlSinkNode&gt; returnAndUnwindNodes, boolean hasNonMatchingEntries, Class&lt;T&gt; clazz, int resultCount) {
1085         if (!hasNonMatchingEntries) {
1086             return (List&lt;T&gt;) returnAndUnwindNodes;
1087         }
1088 
1089         List&lt;T&gt; result = new ArrayList&lt;&gt;(resultCount);
1090         for (int i = 0; i &lt; returnAndUnwindNodes.size(); i++) {
1091             ControlSinkNode node = returnAndUnwindNodes.get(i);
1092             if (clazz.isInstance(node)) {
1093                 result.add((T) node);
1094             }
1095         }
1096         assert result.size() == resultCount;
1097         return result;
1098     }
1099 
1100     private static RuntimeException tooDeepInlining(PEMethodScope methodScope) {
1101         HashMap&lt;ResolvedJavaMethod, Integer&gt; methodCounts = new HashMap&lt;&gt;();
1102         for (PEMethodScope cur = methodScope; cur != null; cur = cur.caller) {
1103             Integer oldCount = methodCounts.get(cur.method);
1104             methodCounts.put(cur.method, oldCount == null ? 1 : oldCount + 1);
1105         }
1106 
1107         List&lt;Map.Entry&lt;ResolvedJavaMethod, Integer&gt;&gt; methods = new ArrayList&lt;&gt;(methodCounts.entrySet());
1108         methods.sort((e1, e2) -&gt; -Integer.compare(e1.getValue(), e2.getValue()));
1109 
1110         StringBuilder msg = new StringBuilder(&quot;Too deep inlining, probably caused by recursive inlining.&quot;).append(System.lineSeparator()).append(&quot;== Inlined methods ordered by inlining frequency:&quot;);
1111         for (Map.Entry&lt;ResolvedJavaMethod, Integer&gt; entry : methods) {
1112             msg.append(System.lineSeparator()).append(entry.getKey().format(&quot;%H.%n(%p) [&quot;)).append(entry.getValue()).append(&quot;]&quot;);
1113         }
1114         msg.append(System.lineSeparator()).append(&quot;== Complete stack trace of inlined methods:&quot;);
1115         int lastBci = 0;
1116         for (PEMethodScope cur = methodScope; cur != null; cur = cur.caller) {
1117             msg.append(System.lineSeparator()).append(cur.method.asStackTraceElement(lastBci));
1118             if (cur.invokeData != null) {
1119                 lastBci = cur.invokeData.invoke.bci();
1120             } else {
1121                 lastBci = 0;
1122             }
1123         }
1124 
1125         throw new PermanentBailoutException(msg.toString());
1126     }
1127 
1128     public FixedNode nodeAfterInvoke(PEMethodScope methodScope, LoopScope loopScope, InvokeData invokeData, AbstractBeginNode lastBlock) {
1129         assert lastBlock.isAlive();
1130         FixedNode n;
1131         if (invokeData.invoke instanceof InvokeWithExceptionNode) {
1132             registerNode(loopScope, invokeData.nextOrderId, lastBlock, false, false);
1133             n = makeStubNode(methodScope, loopScope, invokeData.nextNextOrderId);
1134         } else {
1135             n = makeStubNode(methodScope, loopScope, invokeData.nextOrderId);
1136         }
1137         return n;
1138     }
1139 
1140     private static void deleteInvoke(Invoke invoke) {
1141         /*
1142          * Clean up unused nodes. We cannot just call killCFG on the invoke node because that can
1143          * kill too much: nodes that are decoded later can use values that appear unused by now.
1144          */
1145         FrameState frameState = invoke.stateAfter();
1146         invoke.asNode().safeDelete();
1147         assert invoke.callTarget() == null : &quot;must not have been added to the graph yet&quot;;
1148         if (frameState != null &amp;&amp; frameState.hasNoUsages()) {
1149             frameState.safeDelete();
1150         }
1151     }
1152 
1153     protected abstract EncodedGraph lookupEncodedGraph(ResolvedJavaMethod method, MethodSubstitutionPlugin plugin, BytecodeProvider intrinsicBytecodeProvider, boolean isSubstitution,
1154                     boolean trackNodeSourcePosition);
1155 
1156     @Override
1157     protected void handleFixedNode(MethodScope s, LoopScope loopScope, int nodeOrderId, FixedNode node) {
1158         PEMethodScope methodScope = (PEMethodScope) s;
1159 
1160         if (node instanceof ForeignCallNode) {
1161             ForeignCallNode foreignCall = (ForeignCallNode) node;
1162             if (foreignCall.getBci() == BytecodeFrame.UNKNOWN_BCI &amp;&amp; methodScope.invokeData != null) {
1163                 foreignCall.setBci(methodScope.invokeData.invoke.bci());
1164             }
1165         }
1166 
1167         super.handleFixedNode(methodScope, loopScope, nodeOrderId, node);
1168     }
1169 
1170     @SuppressWarnings(&quot;try&quot;)
1171     @Override
1172     protected Node canonicalizeFixedNode(MethodScope s, Node node) {
1173         PEMethodScope methodScope = (PEMethodScope) s;
1174 
1175         Node replacedNode = node;
1176         if (nodePlugins != null &amp;&amp; nodePlugins.length &gt; 0) {
1177             if (node instanceof LoadFieldNode) {
1178                 LoadFieldNode loadFieldNode = (LoadFieldNode) node;
1179                 PEAppendGraphBuilderContext graphBuilderContext = new PEAppendGraphBuilderContext(methodScope, loadFieldNode);
1180                 ResolvedJavaField field = loadFieldNode.field();
1181                 if (loadFieldNode.isStatic()) {
1182                     for (NodePlugin nodePlugin : nodePlugins) {
1183                         if (nodePlugin.handleLoadStaticField(graphBuilderContext, field)) {
1184                             replacedNode = graphBuilderContext.pushedNode;
1185                             break;
1186                         }
1187                     }
1188                 } else {
1189                     ValueNode object = loadFieldNode.object();
1190                     for (NodePlugin nodePlugin : nodePlugins) {
1191                         if (nodePlugin.handleLoadField(graphBuilderContext, object, field)) {
1192                             replacedNode = graphBuilderContext.pushedNode;
1193                             break;
1194                         }
1195                     }
1196                 }
1197             } else if (node instanceof StoreFieldNode) {
1198                 StoreFieldNode storeFieldNode = (StoreFieldNode) node;
1199                 PEAppendGraphBuilderContext graphBuilderContext = new PEAppendGraphBuilderContext(methodScope, storeFieldNode);
1200                 ResolvedJavaField field = storeFieldNode.field();
1201                 if (storeFieldNode.isStatic()) {
1202                     ValueNode value = storeFieldNode.value();
1203                     for (NodePlugin nodePlugin : nodePlugins) {
1204                         if (nodePlugin.handleStoreStaticField(graphBuilderContext, field, value)) {
1205                             replacedNode = graphBuilderContext.pushedNode;
1206                             break;
1207                         }
1208                     }
1209                 } else {
1210                     ValueNode object = storeFieldNode.object();
1211                     ValueNode value = storeFieldNode.value();
1212                     for (NodePlugin nodePlugin : nodePlugins) {
1213                         if (nodePlugin.handleStoreField(graphBuilderContext, object, field, value)) {
1214                             replacedNode = graphBuilderContext.pushedNode;
1215                             break;
1216                         }
1217                     }
1218                 }
1219             } else if (node instanceof LoadIndexedNode) {
1220                 LoadIndexedNode loadIndexedNode = (LoadIndexedNode) node;
1221                 PEAppendGraphBuilderContext graphBuilderContext = new PEAppendGraphBuilderContext(methodScope, loadIndexedNode);
1222                 ValueNode array = loadIndexedNode.array();
1223                 ValueNode index = loadIndexedNode.index();
1224                 for (NodePlugin nodePlugin : nodePlugins) {
1225                     if (nodePlugin.handleLoadIndexed(graphBuilderContext, array, index, loadIndexedNode.getBoundsCheck(), loadIndexedNode.elementKind())) {
1226                         replacedNode = graphBuilderContext.pushedNode;
1227                         break;
1228                     }
1229                 }
1230             } else if (node instanceof StoreIndexedNode) {
1231                 StoreIndexedNode storeIndexedNode = (StoreIndexedNode) node;
1232                 PEAppendGraphBuilderContext graphBuilderContext = new PEAppendGraphBuilderContext(methodScope, storeIndexedNode);
1233                 ValueNode array = storeIndexedNode.array();
1234                 ValueNode index = storeIndexedNode.index();
1235                 ValueNode value = storeIndexedNode.value();
1236                 for (NodePlugin nodePlugin : nodePlugins) {
1237                     if (nodePlugin.handleStoreIndexed(graphBuilderContext, array, index, storeIndexedNode.getBoundsCheck(), storeIndexedNode.getStoreCheck(), storeIndexedNode.elementKind(), value)) {
1238                         replacedNode = graphBuilderContext.pushedNode;
1239                         break;
1240                     }
1241                 }
1242             } else if (node instanceof NewInstanceNode) {
1243                 NewInstanceNode newInstanceNode = (NewInstanceNode) node;
1244                 PEAppendGraphBuilderContext graphBuilderContext = new PEAppendGraphBuilderContext(methodScope, newInstanceNode);
1245                 ResolvedJavaType type = newInstanceNode.instanceClass();
1246                 for (NodePlugin nodePlugin : nodePlugins) {
1247                     if (nodePlugin.handleNewInstance(graphBuilderContext, type)) {
1248                         replacedNode = graphBuilderContext.pushedNode;
1249                         break;
1250                     }
1251                 }
1252             } else if (node instanceof NewArrayNode) {
1253                 NewArrayNode newArrayNode = (NewArrayNode) node;
1254                 PEAppendGraphBuilderContext graphBuilderContext = new PEAppendGraphBuilderContext(methodScope, newArrayNode);
1255                 ResolvedJavaType elementType = newArrayNode.elementType();
1256                 ValueNode length = newArrayNode.length();
1257                 for (NodePlugin nodePlugin : nodePlugins) {
1258                     if (nodePlugin.handleNewArray(graphBuilderContext, elementType, length)) {
1259                         replacedNode = graphBuilderContext.pushedNode;
1260                         break;
1261                     }
1262                 }
1263             } else if (node instanceof NewMultiArrayNode) {
1264                 NewMultiArrayNode newArrayNode = (NewMultiArrayNode) node;
1265                 PEAppendGraphBuilderContext graphBuilderContext = new PEAppendGraphBuilderContext(methodScope, newArrayNode);
1266                 ResolvedJavaType elementType = newArrayNode.type();
1267                 ValueNode[] dimensions = newArrayNode.dimensions().toArray(new ValueNode[0]);
1268                 for (NodePlugin nodePlugin : nodePlugins) {
1269                     if (nodePlugin.handleNewMultiArray(graphBuilderContext, elementType, dimensions)) {
1270                         replacedNode = graphBuilderContext.pushedNode;
1271                         break;
1272                     }
1273                 }
1274             }
1275         }
1276 
1277         return super.canonicalizeFixedNode(methodScope, replacedNode);
1278     }
1279 
1280     @Override
1281     protected Node handleFloatingNodeBeforeAdd(MethodScope s, LoopScope loopScope, Node n) {
1282         PEMethodScope methodScope = (PEMethodScope) s;
1283 
1284         Node node = n;
1285         if (node instanceof ParameterNode) {
1286             ParameterNode param = (ParameterNode) node;
1287             if (methodScope.isInlinedMethod()) {
1288                 throw GraalError.shouldNotReachHere(&quot;Parameter nodes are already registered when the inlined scope is created&quot;);
1289 
1290             } else if (parameterPlugin != null) {
1291                 assert !methodScope.isInlinedMethod();
1292                 GraphBuilderContext graphBuilderContext = new PENonAppendGraphBuilderContext(methodScope, null);
1293                 Node result = parameterPlugin.interceptParameter(graphBuilderContext, param.index(),
1294                                 StampPair.create(param.stamp(NodeView.DEFAULT), param.uncheckedStamp()));
1295                 if (result != null) {
1296                     return result;
1297                 }
1298             }
1299             node = param.copyWithInputs();
1300         }
1301 
1302         return super.handleFloatingNodeBeforeAdd(methodScope, loopScope, node);
1303     }
1304 
1305     protected void ensureOuterStateDecoded(PEMethodScope methodScope) {
1306         if (methodScope.outerState == null &amp;&amp; methodScope.caller != null) {
1307             FrameState stateAtReturn = methodScope.invokeData.invoke.stateAfter();
1308             if (stateAtReturn == null) {
1309                 stateAtReturn = (FrameState) decodeFloatingNode(methodScope.caller, methodScope.callerLoopScope, methodScope.invokeData.stateAfterOrderId);
1310             }
1311 
1312             JavaKind invokeReturnKind = methodScope.invokeData.invoke.asNode().getStackKind();
1313             FrameState outerState = stateAtReturn.duplicateModified(graph, methodScope.invokeData.invoke.bci(), stateAtReturn.rethrowException(), true, invokeReturnKind, null, null);
1314 
1315             /*
1316              * When the encoded graph has methods inlining, we can already have a proper caller
1317              * state. If not, we set the caller state here.
1318              */
1319             if (outerState.outerFrameState() == null &amp;&amp; methodScope.caller != null) {
1320                 ensureOuterStateDecoded(methodScope.caller);
1321                 outerState.setOuterFrameState(methodScope.caller.outerState);
1322             }
1323             methodScope.outerState = outerState;
1324         }
1325     }
1326 
1327     protected void ensureStateAfterDecoded(PEMethodScope methodScope) {
1328         if (methodScope.invokeData.invoke.stateAfter() == null) {
1329             methodScope.invokeData.invoke.setStateAfter((FrameState) ensureNodeCreated(methodScope.caller, methodScope.callerLoopScope, methodScope.invokeData.stateAfterOrderId));
1330         }
1331     }
1332 
1333     protected void ensureExceptionStateDecoded(PEMethodScope methodScope) {
1334         if (methodScope.exceptionState == null &amp;&amp; methodScope.caller != null &amp;&amp; methodScope.invokeData.invoke instanceof InvokeWithExceptionNode) {
1335             ensureStateAfterDecoded(methodScope);
1336 
1337             assert methodScope.exceptionPlaceholderNode == null;
1338             methodScope.exceptionPlaceholderNode = graph.add(new ExceptionPlaceholderNode());
1339             registerNode(methodScope.callerLoopScope, methodScope.invokeData.exceptionOrderId, methodScope.exceptionPlaceholderNode, false, false);
1340             FrameState exceptionState = (FrameState) ensureNodeCreated(methodScope.caller, methodScope.callerLoopScope, methodScope.invokeData.exceptionStateOrderId);
1341 
1342             if (exceptionState.outerFrameState() == null &amp;&amp; methodScope.caller != null) {
1343                 ensureOuterStateDecoded(methodScope.caller);
1344                 exceptionState.setOuterFrameState(methodScope.caller.outerState);
1345             }
1346             methodScope.exceptionState = exceptionState;
1347         }
1348     }
1349 
1350     @Override
1351     protected Node handleFloatingNodeAfterAdd(MethodScope s, LoopScope loopScope, Node node) {
1352         PEMethodScope methodScope = (PEMethodScope) s;
1353 
1354         if (methodScope.isInlinedMethod()) {
1355             if (node instanceof FrameState) {
1356                 FrameState frameState = (FrameState) node;
1357 
1358                 ensureOuterStateDecoded(methodScope);
1359                 if (frameState.bci &lt; 0) {
1360                     ensureExceptionStateDecoded(methodScope);
1361                 }
1362                 List&lt;ValueNode&gt; invokeArgsList = null;
1363                 if (frameState.bci == BytecodeFrame.BEFORE_BCI) {
1364                     /*
1365                      * We know that the argument list is only used in this case, so avoid the List
1366                      * allocation for &quot;normal&quot; bcis.
1367                      */
1368                     invokeArgsList = Arrays.asList(methodScope.arguments);
1369                 }
1370                 return InliningUtil.processFrameState(frameState, methodScope.invokeData.invoke, null, methodScope.method, methodScope.exceptionState, methodScope.outerState, true,
1371                                 methodScope.method, invokeArgsList);
1372 
1373             } else if (node instanceof MonitorIdNode) {
1374                 ensureOuterStateDecoded(methodScope);
1375                 InliningUtil.processMonitorId(methodScope.outerState, (MonitorIdNode) node);
1376                 return node;
1377             }
1378         }
1379 
1380         return node;
1381     }
1382 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/StandardGraphBuilderPlugins.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.replacements;
  26 
  27 import static jdk.vm.ci.code.MemoryBarriers.JMM_POST_VOLATILE_READ;
  28 import static jdk.vm.ci.code.MemoryBarriers.JMM_POST_VOLATILE_WRITE;
  29 import static jdk.vm.ci.code.MemoryBarriers.JMM_PRE_VOLATILE_READ;
  30 import static jdk.vm.ci.code.MemoryBarriers.JMM_PRE_VOLATILE_WRITE;
  31 import static jdk.vm.ci.code.MemoryBarriers.LOAD_LOAD;
  32 import static jdk.vm.ci.code.MemoryBarriers.LOAD_STORE;
  33 import static jdk.vm.ci.code.MemoryBarriers.STORE_LOAD;
  34 import static jdk.vm.ci.code.MemoryBarriers.STORE_STORE;
  35 import static org.graalvm.compiler.nodes.NamedLocationIdentity.OFF_HEAP_LOCATION;
  36 
  37 import java.lang.reflect.Array;
  38 import java.lang.reflect.Field;
  39 import java.util.Arrays;
  40 
  41 import org.graalvm.compiler.api.directives.GraalDirectives;
  42 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
  43 import org.graalvm.compiler.core.common.calc.Condition;
  44 import org.graalvm.compiler.core.common.calc.Condition.CanonicalizedCondition;
  45 import org.graalvm.compiler.core.common.calc.UnsignedMath;
  46 import org.graalvm.compiler.core.common.type.IntegerStamp;
  47 import org.graalvm.compiler.core.common.type.ObjectStamp;
  48 import org.graalvm.compiler.core.common.type.Stamp;
  49 import org.graalvm.compiler.core.common.type.StampFactory;
  50 import org.graalvm.compiler.core.common.type.TypeReference;
  51 import org.graalvm.compiler.debug.GraalError;
  52 import org.graalvm.compiler.graph.Edges;
  53 import org.graalvm.compiler.graph.Node;
  54 import org.graalvm.compiler.graph.NodeList;
  55 import org.graalvm.compiler.nodes.AbstractBeginNode;
  56 import org.graalvm.compiler.nodes.BeginNode;
  57 import org.graalvm.compiler.nodes.ConstantNode;
  58 import org.graalvm.compiler.nodes.DeoptimizeNode;
  59 import org.graalvm.compiler.nodes.EndNode;
  60 import org.graalvm.compiler.nodes.FixedGuardNode;
  61 import org.graalvm.compiler.nodes.FixedWithNextNode;
  62 import org.graalvm.compiler.nodes.IfNode;
  63 import org.graalvm.compiler.nodes.LogicNode;
  64 import org.graalvm.compiler.nodes.MergeNode;
  65 import org.graalvm.compiler.nodes.NamedLocationIdentity;
  66 import org.graalvm.compiler.nodes.NodeView;
  67 import org.graalvm.compiler.nodes.StateSplit;
  68 import org.graalvm.compiler.nodes.StructuredGraph;
  69 import org.graalvm.compiler.nodes.ValueNode;
  70 import org.graalvm.compiler.nodes.ValuePhiNode;
  71 import org.graalvm.compiler.nodes.calc.AbsNode;
  72 import org.graalvm.compiler.nodes.calc.CompareNode;
  73 import org.graalvm.compiler.nodes.calc.ConditionalNode;
  74 import org.graalvm.compiler.nodes.calc.FloatEqualsNode;
  75 import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;
  76 import org.graalvm.compiler.nodes.calc.IsNullNode;
  77 import org.graalvm.compiler.nodes.calc.NarrowNode;
  78 import org.graalvm.compiler.nodes.calc.ReinterpretNode;
  79 import org.graalvm.compiler.nodes.calc.RightShiftNode;
  80 import org.graalvm.compiler.nodes.calc.SignExtendNode;
  81 import org.graalvm.compiler.nodes.calc.SqrtNode;
  82 import org.graalvm.compiler.nodes.calc.UnsignedDivNode;
  83 import org.graalvm.compiler.nodes.calc.UnsignedRemNode;
  84 import org.graalvm.compiler.nodes.calc.ZeroExtendNode;
  85 import org.graalvm.compiler.nodes.debug.BindToRegisterNode;
  86 import org.graalvm.compiler.nodes.debug.BlackholeNode;
  87 import org.graalvm.compiler.nodes.debug.ControlFlowAnchorNode;
  88 import org.graalvm.compiler.nodes.debug.SideEffectNode;
  89 import org.graalvm.compiler.nodes.debug.SpillRegistersNode;
  90 import org.graalvm.compiler.nodes.extended.BoxNode;
  91 import org.graalvm.compiler.nodes.extended.BranchProbabilityNode;
  92 import org.graalvm.compiler.nodes.extended.BytecodeExceptionNode.BytecodeExceptionKind;
  93 import org.graalvm.compiler.nodes.extended.GetClassNode;
  94 import org.graalvm.compiler.nodes.extended.GuardingNode;
  95 import org.graalvm.compiler.nodes.extended.JavaReadNode;
  96 import org.graalvm.compiler.nodes.extended.JavaWriteNode;
  97 import org.graalvm.compiler.nodes.extended.MembarNode;
  98 import org.graalvm.compiler.nodes.extended.OpaqueNode;
  99 import org.graalvm.compiler.nodes.extended.RawLoadNode;
 100 import org.graalvm.compiler.nodes.extended.RawStoreNode;
 101 import org.graalvm.compiler.nodes.extended.UnboxNode;
 102 import org.graalvm.compiler.nodes.extended.UnsafeMemoryLoadNode;
 103 import org.graalvm.compiler.nodes.extended.UnsafeMemoryStoreNode;
 104 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 105 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 106 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin.Receiver;
 107 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 108 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.Registration;
 109 import org.graalvm.compiler.nodes.java.ClassIsAssignableFromNode;
 110 import org.graalvm.compiler.nodes.java.DynamicNewArrayNode;
 111 import org.graalvm.compiler.nodes.java.DynamicNewInstanceNode;
 112 import org.graalvm.compiler.nodes.java.InstanceOfDynamicNode;
 113 import org.graalvm.compiler.nodes.java.LoadFieldNode;
 114 import org.graalvm.compiler.nodes.java.RegisterFinalizerNode;
 115 import org.graalvm.compiler.nodes.java.UnsafeCompareAndExchangeNode;
 116 import org.graalvm.compiler.nodes.java.UnsafeCompareAndSwapNode;
 117 import org.graalvm.compiler.nodes.memory.OnHeapMemoryAccess.BarrierType;
 118 import org.graalvm.compiler.nodes.memory.address.IndexAddressNode;
 119 import org.graalvm.compiler.nodes.spi.Replacements;
 120 import org.graalvm.compiler.nodes.type.StampTool;
 121 import org.graalvm.compiler.nodes.util.GraphUtil;
 122 import org.graalvm.compiler.nodes.virtual.EnsureVirtualizedNode;
 123 import org.graalvm.compiler.replacements.nodes.ProfileBooleanNode;
 124 import org.graalvm.compiler.replacements.nodes.ReverseBytesNode;
 125 import org.graalvm.compiler.replacements.nodes.VirtualizableInvokeMacroNode;
 126 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerAddExactNode;
 127 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerAddExactOverflowNode;
 128 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerAddExactSplitNode;
 129 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerExactArithmeticSplitNode;
 130 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerMulExactNode;
 131 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerMulExactOverflowNode;
 132 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerMulExactSplitNode;
 133 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerSubExactNode;
 134 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerSubExactOverflowNode;
 135 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerSubExactSplitNode;
 136 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
 137 import org.graalvm.compiler.serviceprovider.SpeculationReasonGroup;
 138 import jdk.internal.vm.compiler.word.LocationIdentity;
 139 
 140 import jdk.vm.ci.code.BytecodePosition;
 141 import jdk.vm.ci.meta.DeoptimizationAction;
 142 import jdk.vm.ci.meta.DeoptimizationReason;
 143 import jdk.vm.ci.meta.JavaConstant;
 144 import jdk.vm.ci.meta.JavaKind;
 145 import jdk.vm.ci.meta.MetaAccessProvider;
 146 import jdk.vm.ci.meta.ResolvedJavaField;
 147 import jdk.vm.ci.meta.ResolvedJavaMethod;
 148 import jdk.vm.ci.meta.ResolvedJavaType;
 149 import jdk.vm.ci.meta.SpeculationLog;
 150 import jdk.vm.ci.meta.SpeculationLog.Speculation;
 151 import jdk.vm.ci.meta.SpeculationLog.SpeculationReason;
 152 import sun.misc.Unsafe;
 153 
 154 /**
 155  * Provides non-runtime specific {@link InvocationPlugin}s.
 156  */
 157 public class StandardGraphBuilderPlugins {
 158 
 159     public static void registerInvocationPlugins(MetaAccessProvider metaAccess, SnippetReflectionProvider snippetReflection, InvocationPlugins plugins, Replacements replacements,
 160                     boolean allowDeoptimization, boolean explicitUnsafeNullChecks, boolean arrayEqualsSubstitution) {
 161         registerObjectPlugins(plugins);
 162         registerClassPlugins(plugins);
 163         registerMathPlugins(plugins, allowDeoptimization);
 164         registerStrictMathPlugins(plugins);
 165         registerUnsignedMathPlugins(plugins);
 166         registerStringPlugins(plugins, replacements, snippetReflection, arrayEqualsSubstitution);
 167         registerCharacterPlugins(plugins);
 168         registerShortPlugins(plugins);
 169         registerIntegerLongPlugins(plugins, JavaKind.Int);
 170         registerIntegerLongPlugins(plugins, JavaKind.Long);
 171         registerFloatPlugins(plugins);
 172         registerDoublePlugins(plugins);
 173         if (arrayEqualsSubstitution) {
 174             registerArraysPlugins(plugins, replacements);
 175         }
 176         registerArrayPlugins(plugins, replacements);
 177         registerUnsafePlugins(plugins, replacements, explicitUnsafeNullChecks);
 178         registerEdgesPlugins(metaAccess, plugins);
 179         registerGraalDirectivesPlugins(plugins);
 180         registerBoxingPlugins(plugins);
 181         registerJMHBlackholePlugins(plugins, replacements);
 182         registerJFRThrowablePlugins(plugins, replacements);
 183         registerMethodHandleImplPlugins(plugins, snippetReflection, replacements);
 184         registerJcovCollectPlugins(plugins, replacements);
 185     }
 186 
 187     private static final Field STRING_VALUE_FIELD;
 188     private static final Field STRING_CODER_FIELD;
 189 
 190     static {
 191         Field coder = null;
 192         try {
 193             STRING_VALUE_FIELD = String.class.getDeclaredField(&quot;value&quot;);
 194             if (JavaVersionUtil.JAVA_SPEC &gt; 8) {
 195                 coder = String.class.getDeclaredField(&quot;coder&quot;);
 196             }
 197         } catch (NoSuchFieldException e) {
 198             throw new GraalError(e);
 199         }
 200         STRING_CODER_FIELD = coder;
 201     }
 202 
 203     private static void registerStringPlugins(InvocationPlugins plugins, Replacements replacements, SnippetReflectionProvider snippetReflection, boolean arrayEqualsSubstitution) {
 204         final Registration r = new Registration(plugins, String.class, replacements);
 205         r.register1(&quot;hashCode&quot;, Receiver.class, new InvocationPlugin() {
 206             @Override
 207             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
 208                 if (receiver.isConstant()) {
 209                     String s = snippetReflection.asObject(String.class, (JavaConstant) receiver.get().asConstant());
 210                     if (s != null) {
 211                         b.addPush(JavaKind.Int, b.add(ConstantNode.forInt(s.hashCode())));
 212                         return true;
 213                     }
 214                 }
 215                 return false;
 216             }
 217         });
 218         r.register1(&quot;intern&quot;, Receiver.class, new InvocationPlugin() {
 219             @Override
 220             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
 221                 if (receiver.isConstant()) {
 222                     String s = snippetReflection.asObject(String.class, (JavaConstant) receiver.get().asConstant());
 223                     if (s != null) {
 224                         JavaConstant interned = snippetReflection.forObject(s.intern());
 225                         b.addPush(JavaKind.Object, b.add(ConstantNode.forConstant(interned, b.getMetaAccess(), b.getGraph())));
 226                         return true;
 227                     }
 228                 }
 229                 return false;
 230             }
 231         });
 232 
 233         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {
 234             if (arrayEqualsSubstitution) {
 235                 r.registerMethodSubstitution(StringSubstitutions.class, &quot;equals&quot;, Receiver.class, Object.class);
 236             }
 237 
 238             r.register7(&quot;indexOf&quot;, char[].class, int.class, int.class, char[].class, int.class, int.class, int.class, new StringIndexOfConstantPlugin());
 239 
 240             Registration sr = new Registration(plugins, StringSubstitutions.class);
 241             sr.register1(&quot;getValue&quot;, String.class, new InvocationPlugin() {
 242                 @Override
 243                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 244                     ResolvedJavaField field = b.getMetaAccess().lookupJavaField(STRING_VALUE_FIELD);
 245                     b.addPush(JavaKind.Object, LoadFieldNode.create(b.getConstantFieldProvider(), b.getConstantReflection(), b.getMetaAccess(),
 246                                     b.getOptions(), b.getAssumptions(), value, field, false, false));
 247                     return true;
 248                 }
 249             });
 250         } else {
 251             if (arrayEqualsSubstitution) {
 252                 r.registerMethodSubstitution(JDK9StringSubstitutions.class, &quot;equals&quot;, Receiver.class, Object.class);
 253             }
 254             Registration utf16sub = new Registration(plugins, StringUTF16Substitutions.class, replacements);
 255             utf16sub.register2(&quot;getCharDirect&quot;, byte[].class, int.class, new InvocationPlugin() {
 256                 @Override
 257                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode arg1, ValueNode arg2) {
 258                     b.addPush(JavaKind.Char, new JavaReadNode(JavaKind.Char, new IndexAddressNode(arg1, arg2, JavaKind.Byte), NamedLocationIdentity.getArrayLocation(JavaKind.Byte),
 259                                     BarrierType.NONE, false));
 260                     return true;
 261                 }
 262             });
 263             utf16sub.register3(&quot;putCharDirect&quot;, byte[].class, int.class, int.class, new InvocationPlugin() {
 264                 @Override
 265                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode arg1, ValueNode arg2, ValueNode arg3) {
 266                     b.add(new JavaWriteNode(JavaKind.Char, new IndexAddressNode(arg1, arg2, JavaKind.Byte), NamedLocationIdentity.getArrayLocation(JavaKind.Byte), arg3,
 267                                     BarrierType.NONE, false));
 268                     return true;
 269                 }
 270             });
 271 
 272             final Registration latin1r = new Registration(plugins, &quot;java.lang.StringLatin1&quot;, replacements);
 273             latin1r.register5(&quot;indexOf&quot;, byte[].class, int.class, byte[].class, int.class, int.class, new StringLatin1IndexOfConstantPlugin());
 274 
 275             final Registration utf16r = new Registration(plugins, &quot;java.lang.StringUTF16&quot;, replacements);
 276             utf16r.register5(&quot;indexOfUnsafe&quot;, byte[].class, int.class, byte[].class, int.class, int.class, new StringUTF16IndexOfConstantPlugin());
 277             utf16r.setAllowOverwrite(true);
 278             utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;getChar&quot;, byte[].class, int.class);
 279             utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;putChar&quot;, byte[].class, int.class, int.class);
 280 
 281             Registration sr = new Registration(plugins, JDK9StringSubstitutions.class);
 282             sr.register1(&quot;getValue&quot;, String.class, new InvocationPlugin() {
 283                 @Override
 284                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 285                     ResolvedJavaField field = b.getMetaAccess().lookupJavaField(STRING_VALUE_FIELD);
 286                     b.addPush(JavaKind.Object, LoadFieldNode.create(b.getConstantFieldProvider(), b.getConstantReflection(), b.getMetaAccess(),
 287                                     b.getOptions(), b.getAssumptions(), value, field, false, false));
 288                     return true;
 289                 }
 290             });
 291             sr.register1(&quot;getCoder&quot;, String.class, new InvocationPlugin() {
 292                 @Override
 293                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 294                     ResolvedJavaField field = b.getMetaAccess().lookupJavaField(STRING_CODER_FIELD);
 295                     b.addPush(JavaKind.Int, LoadFieldNode.create(b.getConstantFieldProvider(), b.getConstantReflection(), b.getMetaAccess(),
 296                                     b.getOptions(), b.getAssumptions(), value, field, false, false));
 297                     return true;
 298                 }
 299             });
 300         }
 301     }
 302 
 303     private static void registerArraysPlugins(InvocationPlugins plugins, Replacements replacements) {
 304         Registration r = new Registration(plugins, Arrays.class, replacements);
 305         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, boolean[].class, boolean[].class);
 306         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, byte[].class, byte[].class);
 307         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, short[].class, short[].class);
 308         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, char[].class, char[].class);
 309         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, int[].class, int[].class);
 310         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, long[].class, long[].class);
 311     }
 312 
 313     private static void registerArrayPlugins(InvocationPlugins plugins, Replacements replacements) {
 314         Registration r = new Registration(plugins, Array.class, replacements);
 315         r.register2(&quot;newInstance&quot;, Class.class, int.class, new InvocationPlugin() {
 316             @Override
 317             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unused, ValueNode componentType, ValueNode length) {
 318                 b.addPush(JavaKind.Object, new DynamicNewArrayNode(componentType, length, true));
 319                 return true;
 320             }
 321         });
 322         r.registerMethodSubstitution(ArraySubstitutions.class, &quot;getLength&quot;, Object.class);
 323     }
 324 
 325     /**
 326      * The intrinsic for {@link Math#sqrt(double)} is shared with {@link StrictMath#sqrt(double)}.
 327      *
 328      * @see &quot;http://hg.openjdk.java.net/jdk/jdk/file/621efe32eb0b/src/hotspot/share/oops/method.cpp#l1504&quot;
 329      */
 330     static final class MathSqrtPlugin implements InvocationPlugin {
 331         @Override
 332         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 333             b.push(JavaKind.Double, b.append(SqrtNode.create(value, NodeView.DEFAULT)));
 334             return true;
 335         }
 336     }
 337 
 338     private abstract static class UnsafeCompareAndUpdatePluginsRegistrar {
 339         public void register(Registration r, String casPrefix, boolean explicitUnsafeNullChecks, JavaKind[] compareAndSwapTypes, boolean java11OrEarlier) {
 340             for (JavaKind kind : compareAndSwapTypes) {
 341                 Class&lt;?&gt; javaClass = kind == JavaKind.Object ? Object.class : kind.toJavaClass();
 342                 String kindName = (kind == JavaKind.Object &amp;&amp; !java11OrEarlier) ? &quot;Reference&quot; : kind.name();
 343                 r.register5(casPrefix + kindName, Receiver.class, Object.class, long.class, javaClass, javaClass, new UnsafeAccessPlugin(returnKind(kind), explicitUnsafeNullChecks) {
 344                     @Override
 345                     public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode object, ValueNode offset, ValueNode expected, ValueNode x) {
 346                         // Emits a null-check for the otherwise unused receiver
 347                         unsafe.get();
 348                         createUnsafeAccess(object, b, (obj, loc) -&gt; UnsafeCompareAndUpdatePluginsRegistrar.this.createNode(obj, offset, expected, x, kind, loc));
 349                         return true;
 350                     }
 351                 });
 352             }
 353         }
 354 
 355         public abstract FixedWithNextNode createNode(ValueNode object, ValueNode offset, ValueNode expected, ValueNode newValue, JavaKind kind, LocationIdentity identity);
 356 
 357         public abstract JavaKind returnKind(JavaKind accessKind);
 358     }
 359 
 360     private static class UnsafeCompareAndSwapPluginsRegistrar extends UnsafeCompareAndUpdatePluginsRegistrar {
 361         @Override
 362         public FixedWithNextNode createNode(ValueNode object, ValueNode offset, ValueNode expected, ValueNode newValue, JavaKind kind, LocationIdentity identity) {
 363             return new UnsafeCompareAndSwapNode(object, offset, expected, newValue, kind, identity);
 364         }
 365 
 366         @Override
 367         public JavaKind returnKind(JavaKind accessKind) {
 368             return JavaKind.Boolean.getStackKind();
 369         }
 370     }
 371 
 372     private static UnsafeCompareAndSwapPluginsRegistrar unsafeCompareAndSwapPluginsRegistrar = new UnsafeCompareAndSwapPluginsRegistrar();
 373 
 374     private static class UnsafeCompareAndExchangePluginsRegistrar extends UnsafeCompareAndUpdatePluginsRegistrar {
 375         @Override
 376         public FixedWithNextNode createNode(ValueNode object, ValueNode offset, ValueNode expected, ValueNode newValue, JavaKind kind, LocationIdentity identity) {
 377             return new UnsafeCompareAndExchangeNode(object, offset, expected, newValue, kind, identity);
 378         }
 379 
 380         @Override
 381         public JavaKind returnKind(JavaKind accessKind) {
 382             if (accessKind.isNumericInteger()) {
 383                 return accessKind.getStackKind();
 384             } else {
 385                 return accessKind;
 386             }
 387         }
 388     }
 389 
 390     private static UnsafeCompareAndExchangePluginsRegistrar unsafeCompareAndExchangePluginsRegistrar = new UnsafeCompareAndExchangePluginsRegistrar();
 391 
 392     public static void registerPlatformSpecificUnsafePlugins(InvocationPlugins plugins, Replacements replacements, boolean explicitUnsafeNullChecks, JavaKind[] supportedCasKinds) {
 393         registerPlatformSpecificUnsafePlugins(supportedCasKinds, new Registration(plugins, Unsafe.class), true, explicitUnsafeNullChecks);
 394         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {
 395             registerPlatformSpecificUnsafePlugins(supportedCasKinds, new Registration(plugins, &quot;jdk.internal.misc.Unsafe&quot;, replacements), false, explicitUnsafeNullChecks);
 396         }
 397 
 398     }
 399 
 400     private static void registerPlatformSpecificUnsafePlugins(JavaKind[] supportedCasKinds, Registration r, boolean java8OrEarlier, boolean explicitUnsafeNullChecks) {
 401         if (java8OrEarlier) {
 402             unsafeCompareAndSwapPluginsRegistrar.register(r, &quot;compareAndSwap&quot;, explicitUnsafeNullChecks, new JavaKind[]{JavaKind.Int, JavaKind.Long, JavaKind.Object}, true);
 403         } else {
 404             unsafeCompareAndSwapPluginsRegistrar.register(r, &quot;compareAndSet&quot;, explicitUnsafeNullChecks, supportedCasKinds, JavaVersionUtil.JAVA_SPEC &lt;= 11);
 405             unsafeCompareAndExchangePluginsRegistrar.register(r, &quot;compareAndExchange&quot;, explicitUnsafeNullChecks, supportedCasKinds, JavaVersionUtil.JAVA_SPEC &lt;= 11);
 406         }
 407     }
 408 
 409     private static void registerUnsafePlugins(InvocationPlugins plugins, Replacements replacements, boolean explicitUnsafeNullChecks) {
 410         registerUnsafePlugins(new Registration(plugins, Unsafe.class), true, explicitUnsafeNullChecks);
 411         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {
 412             registerUnsafePlugins(new Registration(plugins, &quot;jdk.internal.misc.Unsafe&quot;, replacements), false, explicitUnsafeNullChecks);
 413         }
 414     }
 415 
 416     private static void registerUnsafePlugins(Registration r, boolean sunMiscUnsafe, boolean explicitUnsafeNullChecks) {
 417         for (JavaKind kind : JavaKind.values()) {
 418             if ((kind.isPrimitive() &amp;&amp; kind != JavaKind.Void) || kind == JavaKind.Object) {
 419                 Class&lt;?&gt; javaClass = kind == JavaKind.Object ? Object.class : kind.toJavaClass();
 420                 String kindName = (kind == JavaKind.Object &amp;&amp; !sunMiscUnsafe &amp;&amp; !(JavaVersionUtil.JAVA_SPEC &lt;= 11)) ? &quot;Reference&quot; : kind.name();
 421                 String getName = &quot;get&quot; + kindName;
 422                 String putName = &quot;put&quot; + kindName;
 423                 // Object-based accesses
 424                 r.register3(getName, Receiver.class, Object.class, long.class, new UnsafeGetPlugin(kind, explicitUnsafeNullChecks));
 425                 r.register4(putName, Receiver.class, Object.class, long.class, javaClass, new UnsafePutPlugin(kind, explicitUnsafeNullChecks));
 426                 // Volatile object-based accesses
 427                 r.register3(getName + &quot;Volatile&quot;, Receiver.class, Object.class, long.class, new UnsafeGetPlugin(kind, AccessKind.VOLATILE, explicitUnsafeNullChecks));
 428                 r.register4(putName + &quot;Volatile&quot;, Receiver.class, Object.class, long.class, javaClass, new UnsafePutPlugin(kind, AccessKind.VOLATILE, explicitUnsafeNullChecks));
 429                 // Ordered object-based accesses
 430                 if (sunMiscUnsafe) {
 431                     if (kind == JavaKind.Int || kind == JavaKind.Long || kind == JavaKind.Object) {
 432                         r.register4(&quot;putOrdered&quot; + kindName, Receiver.class, Object.class, long.class, javaClass, new UnsafePutPlugin(kind, AccessKind.RELEASE_ACQUIRE, explicitUnsafeNullChecks));
 433                     }
 434                 } else {
 435                     r.register4(&quot;put&quot; + kindName + &quot;Release&quot;, Receiver.class, Object.class, long.class, javaClass, new UnsafePutPlugin(kind, AccessKind.RELEASE_ACQUIRE, explicitUnsafeNullChecks));
 436                     r.register3(&quot;get&quot; + kindName + &quot;Acquire&quot;, Receiver.class, Object.class, long.class, new UnsafeGetPlugin(kind, AccessKind.RELEASE_ACQUIRE, explicitUnsafeNullChecks));
 437                     r.register4(&quot;put&quot; + kindName + &quot;Opaque&quot;, Receiver.class, Object.class, long.class, javaClass, new UnsafePutPlugin(kind, AccessKind.OPAQUE, explicitUnsafeNullChecks));
 438                     r.register3(&quot;get&quot; + kindName + &quot;Opaque&quot;, Receiver.class, Object.class, long.class, new UnsafeGetPlugin(kind, AccessKind.OPAQUE, explicitUnsafeNullChecks));
 439                 }
 440                 if (kind != JavaKind.Boolean &amp;&amp; kind != JavaKind.Object) {
 441                     // Raw accesses to memory addresses
 442                     r.register2(getName, Receiver.class, long.class, new UnsafeGetPlugin(kind, explicitUnsafeNullChecks));
 443                     r.register3(putName, Receiver.class, long.class, kind.toJavaClass(), new UnsafePutPlugin(kind, explicitUnsafeNullChecks));
 444                 }
 445             }
 446         }
 447 
 448         // Accesses to native memory addresses.
 449         r.register2(&quot;getAddress&quot;, Receiver.class, long.class, new UnsafeGetPlugin(JavaKind.Long, explicitUnsafeNullChecks));
 450         r.register3(&quot;putAddress&quot;, Receiver.class, long.class, long.class, new UnsafePutPlugin(JavaKind.Long, explicitUnsafeNullChecks));
 451 
 452         r.register2(&quot;allocateInstance&quot;, Receiver.class, Class.class, new InvocationPlugin() {
 453 
 454             @Override
 455             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode clazz) {
 456                 // Emits a null-check for the otherwise unused receiver
 457                 unsafe.get();
 458                 b.addPush(JavaKind.Object, new DynamicNewInstanceNode(b.nullCheckedValue(clazz, DeoptimizationAction.None), true));
 459                 return true;
 460             }
 461 
 462         });
 463 
 464         r.register1(&quot;loadFence&quot;, Receiver.class, new UnsafeFencePlugin(LOAD_LOAD | LOAD_STORE));
 465         r.register1(&quot;storeFence&quot;, Receiver.class, new UnsafeFencePlugin(STORE_STORE | LOAD_STORE));
 466         r.register1(&quot;fullFence&quot;, Receiver.class, new UnsafeFencePlugin(LOAD_LOAD | STORE_STORE | LOAD_STORE | STORE_LOAD));
 467     }
 468 
 469     private static void registerIntegerLongPlugins(InvocationPlugins plugins, JavaKind kind) {
 470         Class&lt;?&gt; declaringClass = kind.toBoxedJavaClass();
 471         Class&lt;?&gt; type = kind.toJavaClass();
 472         Registration r = new Registration(plugins, declaringClass);
 473         r.register1(&quot;reverseBytes&quot;, type, new InvocationPlugin() {
 474             @Override
 475             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 476                 b.push(kind, b.append(new ReverseBytesNode(value).canonical(null)));
 477                 return true;
 478             }
 479         });
 480         r.register2(&quot;divideUnsigned&quot;, type, type, new InvocationPlugin() {
 481             @Override
 482             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode dividend, ValueNode divisor) {
 483                 b.push(kind, b.append(UnsignedDivNode.create(dividend, divisor, null, NodeView.DEFAULT)));
 484                 return true;
 485             }
 486         });
 487         r.register2(&quot;remainderUnsigned&quot;, type, type, new InvocationPlugin() {
 488             @Override
 489             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode dividend, ValueNode divisor) {
 490                 b.push(kind, b.append(UnsignedRemNode.create(dividend, divisor, null, NodeView.DEFAULT)));
 491                 return true;
 492             }
 493         });
 494     }
 495 
 496     private static void registerCharacterPlugins(InvocationPlugins plugins) {
 497         Registration r = new Registration(plugins, Character.class);
 498         r.register1(&quot;reverseBytes&quot;, char.class, new InvocationPlugin() {
 499             @Override
 500             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 501                 // return (char) (Integer.reverse(i) &gt;&gt; 16);
 502                 ReverseBytesNode reverse = b.add(new ReverseBytesNode(value));
 503                 RightShiftNode rightShift = b.add(new RightShiftNode(reverse, b.add(ConstantNode.forInt(16))));
 504                 ZeroExtendNode charCast = b.add(new ZeroExtendNode(b.add(new NarrowNode(rightShift, 16)), 32));
 505                 b.push(JavaKind.Char, b.append(charCast.canonical(null)));
 506                 return true;
 507             }
 508         });
 509     }
 510 
 511     private static void registerShortPlugins(InvocationPlugins plugins) {
 512         Registration r = new Registration(plugins, Short.class);
 513         r.register1(&quot;reverseBytes&quot;, short.class, new InvocationPlugin() {
 514             @Override
 515             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 516                 // return (short) (Integer.reverse(i) &gt;&gt; 16);
 517                 ReverseBytesNode reverse = b.add(new ReverseBytesNode(value));
 518                 RightShiftNode rightShift = b.add(new RightShiftNode(reverse, b.add(ConstantNode.forInt(16))));
 519                 SignExtendNode charCast = b.add(new SignExtendNode(b.add(new NarrowNode(rightShift, 16)), 32));
 520                 b.push(JavaKind.Short, b.append(charCast.canonical(null)));
 521                 return true;
 522             }
 523         });
 524     }
 525 
 526     private static void registerFloatPlugins(InvocationPlugins plugins) {
 527         Registration r = new Registration(plugins, Float.class);
 528         r.register1(&quot;floatToRawIntBits&quot;, float.class, new InvocationPlugin() {
 529             @Override
 530             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 531                 b.push(JavaKind.Int, b.append(ReinterpretNode.create(JavaKind.Int, value, NodeView.DEFAULT)));
 532                 return true;
 533             }
 534         });
 535         r.register1(&quot;floatToIntBits&quot;, float.class, new InvocationPlugin() {
 536             @Override
 537             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 538                 LogicNode notNan = b.append(FloatEqualsNode.create(value, value, NodeView.DEFAULT));
 539                 ValueNode raw = b.append(ReinterpretNode.create(JavaKind.Int, value, NodeView.DEFAULT));
 540                 ValueNode result = b.append(ConditionalNode.create(notNan, raw, ConstantNode.forInt(0x7fc00000), NodeView.DEFAULT));
 541                 b.push(JavaKind.Int, result);
 542                 return true;
 543             }
 544         });
 545         r.register1(&quot;intBitsToFloat&quot;, int.class, new InvocationPlugin() {
 546             @Override
 547             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 548                 b.push(JavaKind.Float, b.append(ReinterpretNode.create(JavaKind.Float, value, NodeView.DEFAULT)));
 549                 return true;
 550             }
 551         });
 552     }
 553 
 554     private static void registerDoublePlugins(InvocationPlugins plugins) {
 555         Registration r = new Registration(plugins, Double.class);
 556         r.register1(&quot;doubleToRawLongBits&quot;, double.class, new InvocationPlugin() {
 557             @Override
 558             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 559                 b.push(JavaKind.Long, b.append(ReinterpretNode.create(JavaKind.Long, value, NodeView.DEFAULT)));
 560                 return true;
 561             }
 562         });
 563         r.register1(&quot;doubleToLongBits&quot;, double.class, new InvocationPlugin() {
 564             @Override
 565             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 566                 LogicNode notNan = b.append(FloatEqualsNode.create(value, value, NodeView.DEFAULT));
 567                 ValueNode raw = b.append(ReinterpretNode.create(JavaKind.Long, value, NodeView.DEFAULT));
 568                 ValueNode result = b.append(ConditionalNode.create(notNan, raw, ConstantNode.forLong(0x7ff8000000000000L), NodeView.DEFAULT));
 569                 b.push(JavaKind.Long, result);
 570                 return true;
 571             }
 572         });
 573         r.register1(&quot;longBitsToDouble&quot;, long.class, new InvocationPlugin() {
 574             @Override
 575             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 576                 b.push(JavaKind.Double, b.append(ReinterpretNode.create(JavaKind.Double, value, NodeView.DEFAULT)));
 577                 return true;
 578             }
 579         });
 580     }
 581 
 582     public enum IntegerExactOp {
 583         INTEGER_ADD_EXACT,
 584         INTEGER_INCREMENT_EXACT,
 585         INTEGER_SUBTRACT_EXACT,
 586         INTEGER_DECREMENT_EXACT,
 587         INTEGER_MULTIPLY_EXACT
 588     }
 589 
 590     private static GuardingNode createIntegerExactArithmeticGuardNode(GraphBuilderContext b, ValueNode x, ValueNode y, IntegerExactOp op) {
 591         LogicNode overflowCheck;
 592         switch (op) {
 593             case INTEGER_ADD_EXACT:
 594             case INTEGER_INCREMENT_EXACT: {
 595                 overflowCheck = new IntegerAddExactOverflowNode(x, y);
 596                 break;
 597             }
 598             case INTEGER_SUBTRACT_EXACT:
 599             case INTEGER_DECREMENT_EXACT: {
 600                 overflowCheck = new IntegerSubExactOverflowNode(x, y);
 601                 break;
 602             }
 603             case INTEGER_MULTIPLY_EXACT: {
 604                 overflowCheck = new IntegerMulExactOverflowNode(x, y);
 605                 break;
 606             }
 607             default:
 608                 throw GraalError.shouldNotReachHere(&quot;Unknown integer exact operation.&quot;);
 609         }
 610         return b.add(new FixedGuardNode(overflowCheck, DeoptimizationReason.ArithmeticException, DeoptimizationAction.InvalidateRecompile, true));
 611     }
 612 
 613     private static ValueNode createIntegerExactArithmeticNode(GraphBuilderContext b, ValueNode x, ValueNode y, IntegerExactOp op) {
 614         switch (op) {
 615             case INTEGER_ADD_EXACT:
 616             case INTEGER_INCREMENT_EXACT:
 617                 return new IntegerAddExactNode(x, y, createIntegerExactArithmeticGuardNode(b, x, y, op));
 618             case INTEGER_SUBTRACT_EXACT:
 619             case INTEGER_DECREMENT_EXACT:
 620                 return new IntegerSubExactNode(x, y, createIntegerExactArithmeticGuardNode(b, x, y, op));
 621             case INTEGER_MULTIPLY_EXACT:
 622                 return new IntegerMulExactNode(x, y, createIntegerExactArithmeticGuardNode(b, x, y, op));
 623             default:
 624                 throw GraalError.shouldNotReachHere(&quot;Unknown integer exact operation.&quot;);
 625         }
 626     }
 627 
 628     private static IntegerExactArithmeticSplitNode createIntegerExactSplit(ValueNode x, ValueNode y, AbstractBeginNode exceptionEdge, IntegerExactOp op) {
 629         switch (op) {
 630             case INTEGER_ADD_EXACT:
 631             case INTEGER_INCREMENT_EXACT:
 632                 return new IntegerAddExactSplitNode(x.stamp(NodeView.DEFAULT).unrestricted(), x, y, null, exceptionEdge);
 633             case INTEGER_SUBTRACT_EXACT:
 634             case INTEGER_DECREMENT_EXACT:
 635                 return new IntegerSubExactSplitNode(x.stamp(NodeView.DEFAULT).unrestricted(), x, y, null, exceptionEdge);
 636             case INTEGER_MULTIPLY_EXACT:
 637                 return new IntegerMulExactSplitNode(x.stamp(NodeView.DEFAULT).unrestricted(), x, y, null, exceptionEdge);
 638             default:
 639                 throw GraalError.shouldNotReachHere(&quot;Unknown integer exact operation.&quot;);
 640         }
 641     }
 642 
 643     private static void createIntegerExactOperation(GraphBuilderContext b, JavaKind kind, ValueNode x, ValueNode y, IntegerExactOp op) {
 644         if (b.needsExplicitException()) {
 645             BytecodeExceptionKind exceptionKind = kind == JavaKind.Int ? BytecodeExceptionKind.INTEGER_EXACT_OVERFLOW : BytecodeExceptionKind.LONG_EXACT_OVERFLOW;
 646             AbstractBeginNode exceptionEdge = b.genExplicitExceptionEdge(exceptionKind);
 647             IntegerExactArithmeticSplitNode split = b.addPush(kind, createIntegerExactSplit(x, y, exceptionEdge, op));
 648             split.setNext(b.add(new BeginNode()));
 649         } else {
 650             b.addPush(kind, createIntegerExactArithmeticNode(b, x, y, op));
 651         }
 652     }
 653 
 654     private static void registerMathPlugins(InvocationPlugins plugins, boolean allowDeoptimization) {
 655         Registration r = new Registration(plugins, Math.class);
 656         if (allowDeoptimization) {
 657             for (JavaKind kind : new JavaKind[]{JavaKind.Int, JavaKind.Long}) {
 658                 Class&lt;?&gt; type = kind.toJavaClass();
 659                 r.register1(&quot;decrementExact&quot;, type, new InvocationPlugin() {
 660                     @Override
 661                     public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode x) {
 662                         ConstantNode y = b.add(ConstantNode.forIntegerKind(kind, 1));
 663                         createIntegerExactOperation(b, kind, x, y, IntegerExactOp.INTEGER_DECREMENT_EXACT);
 664                         return true;
 665                     }
 666                 });
 667 
 668                 r.register1(&quot;incrementExact&quot;, type, new InvocationPlugin() {
 669                     @Override
 670                     public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode x) {
 671                         ConstantNode y = b.add(ConstantNode.forIntegerKind(kind, 1));
 672                         createIntegerExactOperation(b, kind, x, y, IntegerExactOp.INTEGER_INCREMENT_EXACT);
 673                         return true;
 674                     }
 675                 });
 676                 r.register2(&quot;addExact&quot;, type, type, new InvocationPlugin() {
 677                     @Override
 678                     public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode x, ValueNode y) {
 679                         createIntegerExactOperation(b, kind, x, y, IntegerExactOp.INTEGER_ADD_EXACT);
 680                         return true;
 681                     }
 682                 });
 683                 r.register2(&quot;subtractExact&quot;, type, type, new InvocationPlugin() {
 684                     @Override
 685                     public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode x, ValueNode y) {
 686                         createIntegerExactOperation(b, kind, x, y, IntegerExactOp.INTEGER_SUBTRACT_EXACT);
 687                         return true;
 688                     }
 689                 });
 690 
 691                 r.register2(&quot;multiplyExact&quot;, type, type, new InvocationPlugin() {
 692                     @Override
 693                     public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode x, ValueNode y) {
 694                         createIntegerExactOperation(b, kind, x, y, IntegerExactOp.INTEGER_MULTIPLY_EXACT);
 695                         return true;
 696                     }
 697                 });
 698             }
 699         }
 700         r.register1(&quot;abs&quot;, Float.TYPE, new InvocationPlugin() {
 701 
 702             @Override
 703             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 704                 b.push(JavaKind.Float, b.append(new AbsNode(value).canonical(null)));
 705                 return true;
 706             }
 707         });
 708         r.register1(&quot;abs&quot;, Double.TYPE, new InvocationPlugin() {
 709             @Override
 710             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 711                 b.push(JavaKind.Double, b.append(new AbsNode(value).canonical(null)));
 712                 return true;
 713             }
 714         });
 715         r.register1(&quot;sqrt&quot;, Double.TYPE, new MathSqrtPlugin());
 716     }
 717 
 718     private static void registerStrictMathPlugins(InvocationPlugins plugins) {
 719         Registration r = new Registration(plugins, StrictMath.class);
 720         r.register1(&quot;sqrt&quot;, Double.TYPE, new MathSqrtPlugin());
 721     }
 722 
 723     public static final class StringIndexOfConstantPlugin implements InvocationPlugin {
 724         @Override
 725         public boolean inlineOnly() {
 726             return true;
 727         }
 728 
 729         @Override
 730         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, InvocationPlugin.Receiver receiver, ValueNode source, ValueNode sourceOffset, ValueNode sourceCount,
 731                         ValueNode target, ValueNode targetOffset, ValueNode targetCount, ValueNode origFromIndex) {
 732             if (target.isConstant()) {
 733                 b.addPush(JavaKind.Int, new StringIndexOfNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()), source, sourceOffset, sourceCount,
 734                                 target, targetOffset, targetCount, origFromIndex));
 735                 return true;
 736             }
 737             return false;
 738         }
 739     }
 740 
 741     public static final class StringLatin1IndexOfConstantPlugin implements InvocationPlugin {
 742         @Override
 743         public boolean inlineOnly() {
 744             return true;
 745         }
 746 
 747         @Override
 748         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, InvocationPlugin.Receiver receiver,
 749                         ValueNode source, ValueNode sourceCount, ValueNode target, ValueNode targetCount, ValueNode origFromIndex) {
 750             if (target.isConstant()) {
 751                 b.addPush(JavaKind.Int, new StringLatin1IndexOfNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()),
 752                                 source, sourceCount, target, targetCount, origFromIndex));
 753                 return true;
 754             }
 755             return false;
 756         }
 757     }
 758 
 759     public static final class StringUTF16IndexOfConstantPlugin implements InvocationPlugin {
 760         @Override
 761         public boolean inlineOnly() {
 762             return true;
 763         }
 764 
 765         @Override
 766         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, InvocationPlugin.Receiver receiver,
 767                         ValueNode source, ValueNode sourceCount, ValueNode target, ValueNode targetCount, ValueNode origFromIndex) {
 768             if (target.isConstant()) {
 769                 b.addPush(JavaKind.Int, new StringUTF16IndexOfNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()),
 770                                 source, sourceCount, target, targetCount, origFromIndex));
 771                 return true;
 772             }
 773             return false;
 774         }
 775     }
 776 
 777     public static class UnsignedMathPlugin implements InvocationPlugin {
 778         private final Condition condition;
 779 
 780         public UnsignedMathPlugin(Condition condition) {
 781             this.condition = condition;
 782         }
 783 
 784         @Override
 785         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode x, ValueNode y) {
 786             CanonicalizedCondition canonical = condition.canonicalize();
 787             StructuredGraph graph = b.getGraph();
 788 
 789             ValueNode lhs = canonical.mustMirror() ? y : x;
 790             ValueNode rhs = canonical.mustMirror() ? x : y;
 791 
 792             ValueNode trueValue = ConstantNode.forBoolean(!canonical.mustNegate(), graph);
 793             ValueNode falseValue = ConstantNode.forBoolean(canonical.mustNegate(), graph);
 794 
 795             LogicNode compare = CompareNode.createCompareNode(graph, b.getConstantReflection(), b.getMetaAccess(), b.getOptions(), null, canonical.getCanonicalCondition(), lhs, rhs, NodeView.DEFAULT);
 796             b.addPush(JavaKind.Boolean, new ConditionalNode(compare, trueValue, falseValue));
 797             return true;
 798         }
 799     }
 800 
 801     private static void registerUnsignedMathPlugins(InvocationPlugins plugins) {
 802         Registration r = new Registration(plugins, UnsignedMath.class);
 803         r.register2(&quot;aboveThan&quot;, int.class, int.class, new UnsignedMathPlugin(Condition.AT));
 804         r.register2(&quot;aboveThan&quot;, long.class, long.class, new UnsignedMathPlugin(Condition.AT));
 805         r.register2(&quot;belowThan&quot;, int.class, int.class, new UnsignedMathPlugin(Condition.BT));
 806         r.register2(&quot;belowThan&quot;, long.class, long.class, new UnsignedMathPlugin(Condition.BT));
 807         r.register2(&quot;aboveOrEqual&quot;, int.class, int.class, new UnsignedMathPlugin(Condition.AE));
 808         r.register2(&quot;aboveOrEqual&quot;, long.class, long.class, new UnsignedMathPlugin(Condition.AE));
 809         r.register2(&quot;belowOrEqual&quot;, int.class, int.class, new UnsignedMathPlugin(Condition.BE));
 810         r.register2(&quot;belowOrEqual&quot;, long.class, long.class, new UnsignedMathPlugin(Condition.BE));
 811     }
 812 
 813     protected static void registerBoxingPlugins(InvocationPlugins plugins) {
 814         for (JavaKind kind : JavaKind.values()) {
 815             if (kind.isPrimitive() &amp;&amp; kind != JavaKind.Void) {
 816                 new BoxPlugin(kind).register(plugins);
 817                 new UnboxPlugin(kind).register(plugins);
 818             }
 819         }
 820     }
 821 
 822     private static void registerObjectPlugins(InvocationPlugins plugins) {
 823         Registration r = new Registration(plugins, Object.class);
 824         r.register1(&quot;&lt;init&gt;&quot;, Receiver.class, new InvocationPlugin() {
 825             @Override
 826             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
 827                 /*
 828                  * Object.&lt;init&gt; is a common instrumentation point so only perform this rewrite if
 829                  * the current definition is the normal empty method with a single return bytecode.
 830                  * The finalizer registration will instead be performed by the BytecodeParser.
 831                  */
 832                 if (targetMethod.getCodeSize() == 1) {
 833                     ValueNode object = receiver.get();
 834                     if (RegisterFinalizerNode.mayHaveFinalizer(object, b.getAssumptions())) {
 835                         b.add(new RegisterFinalizerNode(object));
 836                     }
 837                     return true;
 838                 }
 839                 return false;
 840             }
 841         });
 842         r.register1(&quot;getClass&quot;, Receiver.class, new InvocationPlugin() {
 843             @Override
 844             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
 845                 ValueNode object = receiver.get();
 846                 ValueNode folded = GetClassNode.tryFold(b.getMetaAccess(), b.getConstantReflection(), NodeView.DEFAULT, GraphUtil.originalValue(object, true));
 847                 if (folded != null) {
 848                     b.addPush(JavaKind.Object, folded);
 849                 } else {
 850                     Stamp stamp = StampFactory.objectNonNull(TypeReference.createTrusted(b.getAssumptions(), b.getMetaAccess().lookupJavaType(Class.class)));
 851                     b.addPush(JavaKind.Object, new GetClassNode(stamp, object));
 852                 }
 853                 return true;
 854             }
 855         });
 856     }
 857 
 858     private static void registerClassPlugins(InvocationPlugins plugins) {
 859         Registration r = new Registration(plugins, Class.class);
 860         r.register2(&quot;isInstance&quot;, Receiver.class, Object.class, new InvocationPlugin() {
 861             @Override
 862             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver type, ValueNode object) {
 863                 LogicNode condition = b.append(InstanceOfDynamicNode.create(b.getAssumptions(), b.getConstantReflection(), type.get(), object, false));
 864                 b.push(JavaKind.Boolean, b.append(new ConditionalNode(condition).canonical(null)));
 865                 return true;
 866             }
 867         });
 868         r.register2(&quot;isAssignableFrom&quot;, Receiver.class, Class.class, new InvocationPlugin() {
 869             @Override
 870             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver type, ValueNode otherType) {
 871                 ClassIsAssignableFromNode condition = b.append(new ClassIsAssignableFromNode(type.get(), otherType));
 872                 b.push(JavaKind.Boolean, b.append(new ConditionalNode(condition).canonical(null)));
 873                 return true;
 874             }
 875         });
 876 
 877         r.register2(&quot;cast&quot;, Receiver.class, Object.class, new InvocationPlugin() {
 878             @Override
 879             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode object) {
 880                 b.genCheckcastDynamic(object, receiver.get());
 881                 return true;
 882             }
 883 
 884             @Override
 885             public boolean inlineOnly() {
 886                 return true;
 887             }
 888         });
 889     }
 890 
 891     /**
 892      * Substitutions for improving the performance of some critical methods in {@link Edges}. These
 893      * substitutions improve the performance by forcing the relevant methods to be inlined
 894      * (intrinsification being a special form of inlining) and removing a checked cast.
 895      */
 896     private static void registerEdgesPlugins(MetaAccessProvider metaAccess, InvocationPlugins plugins) {
 897         Registration r = new Registration(plugins, Edges.class);
 898         for (Class&lt;?&gt; c : new Class&lt;?&gt;[]{Node.class, NodeList.class}) {
 899             r.register2(&quot;get&quot; + c.getSimpleName() + &quot;Unsafe&quot;, Node.class, long.class, new InvocationPlugin() {
 900                 @Override
 901                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode node, ValueNode offset) {
 902                     ObjectStamp stamp = StampFactory.object(TypeReference.createTrusted(b.getAssumptions(), metaAccess.lookupJavaType(c)));
 903                     RawLoadNode value = b.add(new RawLoadNode(stamp, node, offset, LocationIdentity.any(), JavaKind.Object));
 904                     b.addPush(JavaKind.Object, value);
 905                     return true;
 906                 }
 907             });
 908             r.register3(&quot;put&quot; + c.getSimpleName() + &quot;Unsafe&quot;, Node.class, long.class, c, new InvocationPlugin() {
 909                 @Override
 910                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode node, ValueNode offset, ValueNode value) {
 911                     b.add(new RawStoreNode(node, offset, value, JavaKind.Object, LocationIdentity.any()));
 912                     return true;
 913                 }
 914             });
 915         }
 916     }
 917 
 918     public static class BoxPlugin implements InvocationPlugin {
 919 
 920         private final JavaKind kind;
 921 
 922         BoxPlugin(JavaKind kind) {
 923             this.kind = kind;
 924         }
 925 
 926         @Override
 927         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 928             if (b.parsingIntrinsic()) {
 929                 ResolvedJavaMethod rootMethod = b.getGraph().method();
 930                 if (b.getMetaAccess().lookupJavaType(BoxingSnippets.class).isAssignableFrom(rootMethod.getDeclaringClass())) {
 931                     // Disable invocation plugins for boxing snippets so that the
 932                     // original JDK methods are inlined
 933                     return false;
 934                 }
 935             }
 936             ResolvedJavaType resultType = b.getMetaAccess().lookupJavaType(kind.toBoxedJavaClass());
 937             b.addPush(JavaKind.Object, new BoxNode(value, resultType, kind));
 938             return true;
 939         }
 940 
 941         void register(InvocationPlugins plugins) {
 942             plugins.register(this, kind.toBoxedJavaClass(), &quot;valueOf&quot;, kind.toJavaClass());
 943         }
 944     }
 945 
 946     public static class UnboxPlugin implements InvocationPlugin {
 947 
 948         private final JavaKind kind;
 949 
 950         UnboxPlugin(JavaKind kind) {
 951             this.kind = kind;
 952         }
 953 
 954         @Override
 955         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
 956             if (b.parsingIntrinsic()) {
 957                 ResolvedJavaMethod rootMethod = b.getGraph().method();
 958                 if (b.getMetaAccess().lookupJavaType(BoxingSnippets.class).isAssignableFrom(rootMethod.getDeclaringClass())) {
 959                     // Disable invocation plugins for unboxing snippets so that the
 960                     // original JDK methods are inlined
 961                     return false;
 962                 }
 963             }
 964             ValueNode valueNode = UnboxNode.create(b.getMetaAccess(), b.getConstantReflection(), receiver.get(), kind);
 965             b.addPush(kind, valueNode);
 966             return true;
 967         }
 968 
 969         void register(InvocationPlugins plugins) {
 970             String name = kind.toJavaClass().getSimpleName() + &quot;Value&quot;;
 971             plugins.register(this, kind.toBoxedJavaClass(), name, Receiver.class);
 972         }
 973     }
 974 
 975     /**
 976      * The new memory order modes (JDK9+) are defined with cumulative effect, from weakest to
 977      * strongest: Plain, Opaque, Release/Acquire, and Volatile. The existing Plain and Volatile
 978      * modes are defined compatibly with their pre-JDK 9 forms. Any guaranteed property of a weaker
 979      * mode, plus more, holds for a stronger mode. (Conversely, implementations are allowed to use a
 980      * stronger mode than requested for any access.) In JDK 9, these are provided without a full
 981      * formal specification.
 982      */
 983     enum AccessKind {
 984         PLAIN(0, 0, 0, 0, false),
 985         /**
 986          * Opaque accesses are wrapped by dummy membars to avoid floating/hoisting, this is stronger
 987          * than required since Opaque mode does not directly impose any ordering constraints with
 988          * respect to other variables beyond Plain mode.
 989          */
 990         OPAQUE(0, 0, 0, 0, true),
 991         RELEASE_ACQUIRE(0, LOAD_LOAD | LOAD_STORE, LOAD_STORE | STORE_STORE, 0, true),
 992         VOLATILE(JMM_PRE_VOLATILE_READ, JMM_POST_VOLATILE_READ, JMM_PRE_VOLATILE_WRITE, JMM_POST_VOLATILE_WRITE, true);
 993 
 994         public final boolean emitBarriers;
 995         public final int preReadBarriers;
 996         public final int postReadBarriers;
 997         public final int preWriteBarriers;
 998         public final int postWriteBarriers;
 999 
1000         AccessKind(int preReadBarriers, int postReadBarriers, int preWriteBarriers, int postWriteBarriers, boolean emitBarriers) {
1001             this.emitBarriers = emitBarriers;
1002             this.preReadBarriers = preReadBarriers;
1003             this.postReadBarriers = postReadBarriers;
1004             this.preWriteBarriers = preWriteBarriers;
1005             this.postWriteBarriers = postWriteBarriers;
1006         }
1007     }
1008 
1009     /**
1010      * Unsafe access relative to null object is an access to off-heap memory. As linear pointer
1011      * compression uses non-zero null, here null object must be replaced with zero constant.
1012      */
1013     public abstract static class UnsafeAccessPlugin implements InvocationPlugin {
1014         @FunctionalInterface
1015         public interface UnsafeNodeConstructor {
1016             FixedWithNextNode create(ValueNode value, LocationIdentity location);
1017         }
1018 
1019         protected final JavaKind unsafeAccessKind;
1020         private final boolean explicitUnsafeNullChecks;
1021 
1022         public UnsafeAccessPlugin(JavaKind kind, boolean explicitUnsafeNullChecks) {
1023             unsafeAccessKind = kind;
1024             this.explicitUnsafeNullChecks = explicitUnsafeNullChecks;
1025         }
1026 
1027         private static FixedWithNextNode createObjectAccessNode(ValueNode value, UnsafeNodeConstructor nodeConstructor) {
1028             return nodeConstructor.create(value, LocationIdentity.ANY_LOCATION);
1029         }
1030 
1031         private static FixedWithNextNode createMemoryAccessNode(StructuredGraph graph, UnsafeNodeConstructor nodeConstructor) {
1032             return nodeConstructor.create(ConstantNode.forLong(0L, graph), OFF_HEAP_LOCATION);
1033         }
1034 
1035         private static boolean isLoad(ValueNode node) {
1036             return node.getStackKind() != JavaKind.Void;
1037         }
1038 
1039         private void setResult(ValueNode node, GraphBuilderContext b) {
1040             if (isLoad(node)) {
1041                 b.addPush(unsafeAccessKind, node);
1042             } else {
1043                 b.add(node);
1044             }
1045         }
1046 
1047         protected final void createUnsafeAccess(ValueNode value, GraphBuilderContext b, UnsafeNodeConstructor nodeConstructor) {
1048             StructuredGraph graph = b.getGraph();
1049             graph.markUnsafeAccess();
1050             /* For unsafe access object pointers can only be stored in the heap */
1051             if (unsafeAccessKind == JavaKind.Object) {
1052                 setResult(createObjectAccessNode(value, nodeConstructor), b);
1053             } else if (StampTool.isPointerAlwaysNull(value)) {
1054                 setResult(createMemoryAccessNode(graph, nodeConstructor), b);
1055             } else if (!explicitUnsafeNullChecks || StampTool.isPointerNonNull(value)) {
1056                 setResult(createObjectAccessNode(value, nodeConstructor), b);
1057             } else {
1058                 FixedWithNextNode objectAccess = graph.add(createObjectAccessNode(value, nodeConstructor));
1059                 FixedWithNextNode memoryAccess = graph.add(createMemoryAccessNode(graph, nodeConstructor));
1060                 FixedWithNextNode[] accessNodes = new FixedWithNextNode[]{objectAccess, memoryAccess};
1061 
1062                 LogicNode condition = graph.addOrUniqueWithInputs(IsNullNode.create(value));
1063                 b.add(new IfNode(condition, memoryAccess, objectAccess, 0.5));
1064 
1065                 MergeNode merge = b.append(new MergeNode());
1066                 for (FixedWithNextNode node : accessNodes) {
1067                     EndNode endNode = graph.add(new EndNode());
1068                     node.setNext(endNode);
1069                     if (node instanceof StateSplit) {
1070                         if (isLoad(node)) {
1071                             /*
1072                              * Temporarily push the access node so that the frame state has the node
1073                              * on the expression stack.
1074                              */
1075                             b.push(unsafeAccessKind, node);
1076                         }
1077                         b.setStateAfter((StateSplit) node);
1078                         if (isLoad(node)) {
1079                             ValueNode popped = b.pop(unsafeAccessKind);
1080                             assert popped == node;
1081                         }
1082                     }
1083                     merge.addForwardEnd(endNode);
1084                 }
1085 
1086                 if (isLoad(objectAccess)) {
1087                     ValuePhiNode phi = new ValuePhiNode(objectAccess.stamp(NodeView.DEFAULT), merge, accessNodes);
1088                     b.push(unsafeAccessKind, graph.addOrUnique(phi));
1089                 }
1090                 b.setStateAfter(merge);
1091             }
1092         }
1093     }
1094 
1095     public static class UnsafeGetPlugin extends UnsafeAccessPlugin {
1096         private final AccessKind accessKind;
1097 
1098         public UnsafeGetPlugin(JavaKind returnKind, boolean explicitUnsafeNullChecks) {
1099             this(returnKind, AccessKind.PLAIN, explicitUnsafeNullChecks);
1100         }
1101 
1102         public UnsafeGetPlugin(JavaKind kind, AccessKind accessKind, boolean explicitUnsafeNullChecks) {
1103             super(kind, explicitUnsafeNullChecks);
1104             this.accessKind = accessKind;
1105         }
1106 
1107         @Override
1108         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode address) {
1109             // Emits a null-check for the otherwise unused receiver
1110             unsafe.get();
1111             b.addPush(unsafeAccessKind, new UnsafeMemoryLoadNode(address, unsafeAccessKind, OFF_HEAP_LOCATION));
1112             b.getGraph().markUnsafeAccess();
1113             return true;
1114         }
1115 
1116         @Override
1117         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode object, ValueNode offset) {
1118             // Opaque mode does not directly impose any ordering constraints with respect to other
1119             // variables beyond Plain mode.
1120             if (accessKind == AccessKind.OPAQUE &amp;&amp; StampTool.isPointerAlwaysNull(object)) {
1121                 // OFF_HEAP_LOCATION accesses are not floatable =&gt; no membars needed for opaque.
1122                 return apply(b, targetMethod, unsafe, offset);
1123             }
1124             // Emits a null-check for the otherwise unused receiver
1125             unsafe.get();
1126             if (accessKind.emitBarriers) {
1127                 b.add(new MembarNode(accessKind.preReadBarriers));
1128             }
1129             // Raw accesses can be turned into floatable field accesses, the membars preserve the
1130             // access mode. In the case of opaque access, and only for opaque, the location of the
1131             // wrapping membars can be refined to the field location.
1132             createUnsafeAccess(object, b, (obj, loc) -&gt; new RawLoadNode(obj, offset, unsafeAccessKind, loc));
1133             if (accessKind.emitBarriers) {
1134                 b.add(new MembarNode(accessKind.postReadBarriers));
1135             }
1136             return true;
1137         }
1138     }
1139 
1140     public static class UnsafePutPlugin extends UnsafeAccessPlugin {
1141         private final AccessKind accessKind;
1142 
1143         public UnsafePutPlugin(JavaKind kind, boolean explicitUnsafeNullChecks) {
1144             this(kind, AccessKind.PLAIN, explicitUnsafeNullChecks);
1145         }
1146 
1147         private UnsafePutPlugin(JavaKind kind, AccessKind accessKind, boolean explicitUnsafeNullChecks) {
1148             super(kind, explicitUnsafeNullChecks);
1149             this.accessKind = accessKind;
1150         }
1151 
1152         @Override
1153         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode address, ValueNode value) {
1154             assert !accessKind.emitBarriers : &quot;Barriers for address based Unsafe put is not supported.&quot;;
1155             // Emits a null-check for the otherwise unused receiver
1156             unsafe.get();
1157             b.add(new UnsafeMemoryStoreNode(address, value, unsafeAccessKind, OFF_HEAP_LOCATION));
1158             b.getGraph().markUnsafeAccess();
1159             return true;
1160         }
1161 
1162         @Override
1163         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode object, ValueNode offset, ValueNode value) {
1164             // Opaque mode does not directly impose any ordering constraints with respect to other
1165             // variables beyond Plain mode.
1166             if (accessKind == AccessKind.OPAQUE &amp;&amp; StampTool.isPointerAlwaysNull(object)) {
1167                 // OFF_HEAP_LOCATION accesses are not floatable =&gt; no membars needed for opaque.
1168                 return apply(b, targetMethod, unsafe, offset, value);
1169             }
1170             // Emits a null-check for the otherwise unused receiver
1171             unsafe.get();
1172             if (accessKind.emitBarriers) {
1173                 b.add(new MembarNode(accessKind.preWriteBarriers));
1174             }
1175             ValueNode maskedValue = b.maskSubWordValue(value, unsafeAccessKind);
1176             // Raw accesses can be turned into floatable field accesses, the membars preserve the
1177             // access mode. In the case of opaque access, and only for opaque, the location of the
1178             // wrapping membars can be refined to the field location.
1179             createUnsafeAccess(object, b, (obj, loc) -&gt; new RawStoreNode(obj, offset, maskedValue, unsafeAccessKind, loc));
1180             if (accessKind.emitBarriers) {
1181                 b.add(new MembarNode(accessKind.postWriteBarriers));
1182             }
1183             return true;
1184         }
1185     }
1186 
1187     public static class UnsafeFencePlugin implements InvocationPlugin {
1188 
1189         private final int barriers;
1190 
1191         public UnsafeFencePlugin(int barriers) {
1192             this.barriers = barriers;
1193         }
1194 
1195         @Override
1196         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe) {
1197             // Emits a null-check for the otherwise unused receiver
1198             unsafe.get();
1199             b.add(new MembarNode(barriers));
1200             return true;
1201         }
1202     }
1203 
1204     private static final SpeculationReasonGroup DIRECTIVE_SPECULATIONS = new SpeculationReasonGroup(&quot;GraalDirective&quot;, BytecodePosition.class);
1205 
1206     private static void registerGraalDirectivesPlugins(InvocationPlugins plugins) {
1207         Registration r = new Registration(plugins, GraalDirectives.class);
1208         r.register0(&quot;deoptimize&quot;, new InvocationPlugin() {
1209             @Override
1210             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
1211                 b.add(new DeoptimizeNode(DeoptimizationAction.None, DeoptimizationReason.TransferToInterpreter));
1212                 return true;
1213             }
1214         });
1215 
1216         r.register0(&quot;deoptimizeAndInvalidate&quot;, new InvocationPlugin() {
1217             @Override
1218             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
1219                 b.add(new DeoptimizeNode(DeoptimizationAction.InvalidateReprofile, DeoptimizationReason.TransferToInterpreter));
1220                 return true;
1221             }
1222         });
1223 
1224         r.register0(&quot;deoptimizeAndInvalidateWithSpeculation&quot;, new InvocationPlugin() {
1225             @Override
1226             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
1227                 GraalError.guarantee(b.getGraph().getSpeculationLog() != null, &quot;A speculation log is needed to use `deoptimizeAndInvalidateWithSpeculation`&quot;);
1228                 BytecodePosition pos = new BytecodePosition(null, b.getMethod(), b.bci());
1229                 SpeculationReason reason = DIRECTIVE_SPECULATIONS.createSpeculationReason(pos);
1230                 Speculation speculation;
1231                 if (b.getGraph().getSpeculationLog().maySpeculate(reason)) {
1232                     speculation = b.getGraph().getSpeculationLog().speculate(reason);
1233                 } else {
1234                     speculation = SpeculationLog.NO_SPECULATION;
1235                 }
1236                 b.add(new DeoptimizeNode(DeoptimizationAction.InvalidateReprofile, DeoptimizationReason.TransferToInterpreter, speculation));
1237                 return true;
1238             }
1239         });
1240 
1241         r.register0(&quot;inCompiledCode&quot;, new InvocationPlugin() {
1242             @Override
1243             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
1244                 b.addPush(JavaKind.Boolean, ConstantNode.forBoolean(true));
1245                 return true;
1246             }
1247         });
1248 
1249         r.register0(&quot;controlFlowAnchor&quot;, new InvocationPlugin() {
1250             @Override
1251             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
1252                 b.add(new ControlFlowAnchorNode());
1253                 return true;
1254             }
1255         });
1256         r.register0(&quot;sideEffect&quot;, new InvocationPlugin() {
1257             @Override
1258             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
1259                 b.add(new SideEffectNode());
1260                 return true;
1261             }
1262         });
1263         r.register1(&quot;sideEffect&quot;, int.class, new InvocationPlugin() {
1264             @Override
1265             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode a) {
1266                 b.addPush(JavaKind.Int, new SideEffectNode(a));
1267                 return true;
1268             }
1269         });
1270         r.register2(&quot;assumeStableDimension&quot;, Object.class, int.class, new InvocationPlugin() {
1271             @Override
1272             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode array, ValueNode dimension) {
1273                 if (array instanceof ConstantNode &amp;&amp; b.getMetaAccess().lookupJavaType(array.asJavaConstant()).isArray()) {
1274                     if (dimension instanceof ConstantNode &amp;&amp; dimension.stamp(NodeView.DEFAULT) instanceof IntegerStamp) {
1275                         int stableDim = dimension.asJavaConstant().asInt();
1276                         ConstantNode c = ConstantNode.forConstant(array.asJavaConstant(), stableDim, false, b.getMetaAccess());
1277                         b.addPush(JavaKind.Object, c);
1278                         return true;
1279                     }
1280                 }
1281                 throw GraalError.shouldNotReachHere(&quot;Illegal usage of stable array intrinsic assumeStableDimension(array, dimension): &quot; +
1282                                 &quot;This compiler intrinsic can only be used iff array is a constant node (i.e., constant field) and iff &quot; +
1283                                 &quot;dimension is a constant int. It will replace the constant array with a new constant that additionally sets the stable&quot; +
1284                                 &quot;dimensions to the int parameter supplied.&quot;);
1285             }
1286         });
1287         r.register2(&quot;injectBranchProbability&quot;, double.class, boolean.class, new InvocationPlugin() {
1288             @Override
1289             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode probability, ValueNode condition) {
1290                 b.addPush(JavaKind.Boolean, new BranchProbabilityNode(probability, condition));
1291                 return true;
1292             }
1293         });
1294 
1295         InvocationPlugin blackholePlugin = new InvocationPlugin() {
1296             @Override
1297             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
1298                 b.add(new BlackholeNode(value));
1299                 return true;
1300             }
1301         };
1302 
1303         InvocationPlugin bindToRegisterPlugin = new InvocationPlugin() {
1304             @Override
1305             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
1306                 b.add(new BindToRegisterNode(value));
1307                 return true;
1308             }
1309         };
1310         for (JavaKind kind : JavaKind.values()) {
1311             if ((kind.isPrimitive() &amp;&amp; kind != JavaKind.Void) || kind == JavaKind.Object) {
1312                 Class&lt;?&gt; javaClass = kind == JavaKind.Object ? Object.class : kind.toJavaClass();
1313                 r.register1(&quot;blackhole&quot;, javaClass, blackholePlugin);
1314                 r.register1(&quot;bindToRegister&quot;, javaClass, bindToRegisterPlugin);
1315 
1316                 r.register1(&quot;opaque&quot;, javaClass, new InvocationPlugin() {
1317                     @Override
1318                     public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
1319                         b.addPush(kind, new OpaqueNode(value));
1320                         return true;
1321                     }
1322                 });
1323             }
1324         }
1325 
1326         InvocationPlugin spillPlugin = new InvocationPlugin() {
1327             @Override
1328             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
1329                 b.add(new SpillRegistersNode());
1330                 return true;
1331             }
1332         };
1333         r.register0(&quot;spillRegisters&quot;, spillPlugin);
1334 
1335         r.register1(&quot;guardingNonNull&quot;, Object.class, new InvocationPlugin() {
1336             @Override
1337             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
1338                 b.addPush(value.getStackKind(), b.nullCheckedValue(value));
1339                 return true;
1340             }
1341         });
1342 
1343         r.register1(&quot;ensureVirtualized&quot;, Object.class, new InvocationPlugin() {
1344             @Override
1345             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode object) {
1346                 b.add(new EnsureVirtualizedNode(object, false));
1347                 return true;
1348             }
1349         });
1350         r.register1(&quot;ensureVirtualizedHere&quot;, Object.class, new InvocationPlugin() {
1351             @Override
1352             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode object) {
1353                 b.add(new EnsureVirtualizedNode(object, true));
1354                 return true;
1355             }
1356         });
1357     }
1358 
1359     private static void registerJMHBlackholePlugins(InvocationPlugins plugins, Replacements replacements) {
1360         InvocationPlugin blackholePlugin = new InvocationPlugin() {
1361             @Override
1362             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver blackhole, ValueNode value) {
1363                 blackhole.get();
1364                 b.add(new BlackholeNode(value));
1365                 return true;
1366             }
1367 
1368             @Override
1369             public boolean isDecorator() {
1370                 return true;
1371             }
1372         };
1373         String[] names = {&quot;org.openjdk.jmh.infra.Blackhole&quot;, &quot;org.openjdk.jmh.logic.BlackHole&quot;};
1374         for (String name : names) {
1375             Registration r = new Registration(plugins, name, replacements);
1376             for (JavaKind kind : JavaKind.values()) {
1377                 if ((kind.isPrimitive() &amp;&amp; kind != JavaKind.Void) || kind == JavaKind.Object) {
1378                     Class&lt;?&gt; javaClass = kind == JavaKind.Object ? Object.class : kind.toJavaClass();
1379                     r.registerOptional2(&quot;consume&quot;, Receiver.class, javaClass, blackholePlugin);
1380                 }
1381             }
1382             r.registerOptional2(&quot;consume&quot;, Receiver.class, Object[].class, blackholePlugin);
1383         }
1384     }
1385 
1386     private static void registerJFRThrowablePlugins(InvocationPlugins plugins, Replacements replacements) {
1387         Registration r = new Registration(plugins, &quot;oracle.jrockit.jfr.jdkevents.ThrowableTracer&quot;, replacements);
1388         r.register2(&quot;traceThrowable&quot;, Throwable.class, String.class, new InvocationPlugin() {
1389             @Override
1390             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode throwable, ValueNode message) {
1391                 b.add(new VirtualizableInvokeMacroNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()), throwable, message));
1392                 return true;
1393             }
1394 
1395             @Override
1396             public boolean inlineOnly() {
1397                 return true;
1398             }
1399         });
1400     }
1401 
1402     private static void registerMethodHandleImplPlugins(InvocationPlugins plugins, SnippetReflectionProvider snippetReflection, Replacements replacements) {
1403         Registration r = new Registration(plugins, &quot;java.lang.invoke.MethodHandleImpl&quot;, replacements);
1404         // In later JDKs this no longer exists and the usage is replace by Class.cast which is
1405         // already an intrinsic
1406         r.registerOptional2(&quot;castReference&quot;, Class.class, Object.class, new InvocationPlugin() {
1407             @Override
1408             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode javaClass, ValueNode object) {
1409                 b.genCheckcastDynamic(object, javaClass);
1410                 return true;
1411             }
1412 
1413             @Override
1414             public boolean inlineOnly() {
1415                 return true;
1416             }
1417         });
1418         r.register2(&quot;profileBoolean&quot;, boolean.class, int[].class, new InvocationPlugin() {
1419             @Override
1420             public boolean inlineOnly() {
1421                 return true;
1422             }
1423 
1424             @Override
1425             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode result, ValueNode counters) {
1426                 if (result.isConstant()) {
1427                     b.push(JavaKind.Boolean, result);
1428                     return true;
1429                 }
1430                 if (counters.isConstant()) {
1431                     ValueNode newResult = result;
1432                     int[] ctrs = snippetReflection.asObject(int[].class, (JavaConstant) counters.asConstant());
1433                     if (ctrs != null &amp;&amp; ctrs.length == 2) {
1434                         int falseCount = ctrs[0];
1435                         int trueCount = ctrs[1];
1436                         int totalCount = trueCount + falseCount;
1437 
1438                         if (totalCount == 0) {
1439                             b.add(new DeoptimizeNode(DeoptimizationAction.InvalidateReprofile, DeoptimizationReason.TransferToInterpreter));
1440                         } else if (falseCount == 0 || trueCount == 0) {
1441                             boolean expected = falseCount == 0;
1442                             LogicNode condition = b.add(
1443                                             IntegerEqualsNode.create(b.getConstantReflection(), b.getMetaAccess(), b.getOptions(), null, result, b.add(ConstantNode.forBoolean(!expected)),
1444                                                             NodeView.DEFAULT));
1445                             b.append(new FixedGuardNode(condition, DeoptimizationReason.UnreachedCode, DeoptimizationAction.InvalidateReprofile, true));
1446                             newResult = b.add(ConstantNode.forBoolean(expected));
1447                         } else {
1448                             // We cannot use BranchProbabilityNode here since there&#39;s no guarantee
1449                             // the result of MethodHandleImpl.profileBoolean() is used as the
1450                             // test in an `if` statement (as required by BranchProbabilityNode).
1451                         }
1452                     }
1453                     b.addPush(JavaKind.Boolean, newResult);
1454                     return true;
1455                 }
1456                 b.addPush(JavaKind.Boolean,
1457                                 new ProfileBooleanNode(snippetReflection, b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()), result, counters));
1458                 return true;
1459             }
1460         });
1461     }
1462 
1463     /**
1464      * Registers a plugin to ignore {@code com.sun.tdk.jcov.runtime.Collect.hit} within an
1465      * intrinsic.
1466      */
1467     private static void registerJcovCollectPlugins(InvocationPlugins plugins, Replacements replacements) {
1468         Registration r = new Registration(plugins, &quot;com.sun.tdk.jcov.runtime.Collect&quot;, replacements);
1469         r.register1(&quot;hit&quot;, int.class, new InvocationPlugin() {
1470             @Override
1471             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode object) {
1472                 if (b.parsingIntrinsic()) {
1473                     return true;
1474                 }
1475                 return false;
1476             }
1477         });
1478     }
1479 }
    </pre>
  </body>
</html>
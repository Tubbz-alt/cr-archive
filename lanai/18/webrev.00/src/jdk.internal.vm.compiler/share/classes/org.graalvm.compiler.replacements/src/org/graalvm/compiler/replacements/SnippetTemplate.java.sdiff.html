<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/SnippetTemplate.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SnippetLowerableMemoryNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="StandardGraphBuilderPlugins.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/SnippetTemplate.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  96 import org.graalvm.compiler.nodes.LoopBeginNode;
  97 import org.graalvm.compiler.nodes.MergeNode;
  98 import org.graalvm.compiler.nodes.NodeView;
  99 import org.graalvm.compiler.nodes.ParameterNode;
 100 import org.graalvm.compiler.nodes.PhiNode;
 101 import org.graalvm.compiler.nodes.PiNode.Placeholder;
 102 import org.graalvm.compiler.nodes.PiNode.PlaceholderStamp;
 103 import org.graalvm.compiler.nodes.ReturnNode;
 104 import org.graalvm.compiler.nodes.StartNode;
 105 import org.graalvm.compiler.nodes.StateSplit;
 106 import org.graalvm.compiler.nodes.StructuredGraph;
 107 import org.graalvm.compiler.nodes.StructuredGraph.GuardsStage;
 108 import org.graalvm.compiler.nodes.ValueNode;
 109 import org.graalvm.compiler.nodes.ValueNodeUtil;
 110 import org.graalvm.compiler.nodes.calc.FloatingNode;
 111 import org.graalvm.compiler.nodes.java.LoadIndexedNode;
 112 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
 113 import org.graalvm.compiler.nodes.java.StoreIndexedNode;
 114 import org.graalvm.compiler.nodes.memory.MemoryAccess;
 115 import org.graalvm.compiler.nodes.memory.MemoryAnchorNode;
<span class="line-modified"> 116 import org.graalvm.compiler.nodes.memory.MemoryCheckpoint;</span>
 117 import org.graalvm.compiler.nodes.memory.MemoryMap;
 118 import org.graalvm.compiler.nodes.memory.MemoryMapNode;
<span class="line-removed"> 119 import org.graalvm.compiler.nodes.memory.MemoryNode;</span>
 120 import org.graalvm.compiler.nodes.memory.MemoryPhiNode;


 121 import org.graalvm.compiler.nodes.spi.ArrayLengthProvider;
 122 import org.graalvm.compiler.nodes.spi.CoreProviders;
 123 import org.graalvm.compiler.nodes.spi.LoweringTool;
<span class="line-modified"> 124 import org.graalvm.compiler.nodes.spi.MemoryProxy;</span>
 125 import org.graalvm.compiler.nodes.util.GraphUtil;
 126 import org.graalvm.compiler.options.Option;
 127 import org.graalvm.compiler.options.OptionKey;
 128 import org.graalvm.compiler.options.OptionValues;
 129 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
 130 import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase;
 131 import org.graalvm.compiler.phases.common.FloatingReadPhase;
 132 import org.graalvm.compiler.phases.common.FloatingReadPhase.MemoryMapImpl;
 133 import org.graalvm.compiler.phases.common.GuardLoweringPhase;
 134 import org.graalvm.compiler.phases.common.LoweringPhase;
 135 import org.graalvm.compiler.phases.common.RemoveValueProxyPhase;
 136 import org.graalvm.compiler.phases.common.inlining.InliningUtil;
 137 import org.graalvm.compiler.phases.util.Providers;
 138 import org.graalvm.compiler.replacements.nodes.ExplodeLoopNode;
 139 import org.graalvm.compiler.replacements.nodes.LoadSnippetVarargParameterNode;
 140 import org.graalvm.util.CollectionsUtil;
 141 import jdk.internal.vm.compiler.word.LocationIdentity;
 142 import jdk.internal.vm.compiler.word.WordBase;
 143 
 144 import jdk.vm.ci.code.TargetDescription;
</pre>
<hr />
<pre>
 912                     FrameState frameState = stateSplit.stateAfter();
 913                     if (stateSplit.hasSideEffect()) {
 914                         curSideEffectNodes.add((StateSplit) node);
 915                     }
 916                     if (frameState != null) {
 917                         stateSplit.setStateAfter(null);
 918                     }
 919                 }
 920                 if (node instanceof DeoptimizingNode) {
 921                     DeoptimizingNode deoptNode = (DeoptimizingNode) node;
 922                     if (deoptNode.canDeoptimize()) {
 923                         curDeoptNodes.add(deoptNode);
 924                     }
 925                 }
 926             }
 927 
 928             new DeadCodeEliminationPhase(Required).apply(snippetCopy);
 929 
 930             assert checkAllVarargPlaceholdersAreDeleted(parameterCount, placeholders);
 931 
<span class="line-modified"> 932             new FloatingReadPhase(true, true).apply(snippetCopy);</span>


 933 
 934             if (!guardsStage.requiresValueProxies()) {
 935                 new RemoveValueProxyPhase().apply(snippetCopy);
 936             }
 937 
<span class="line-modified"> 938             MemoryAnchorNode anchor = snippetCopy.add(new MemoryAnchorNode());</span>
 939             snippetCopy.start().replaceAtUsages(InputType.Memory, anchor);
 940 
 941             this.snippet = snippetCopy;
 942 
 943             StartNode entryPointNode = snippet.start();
 944             if (anchor.hasNoUsages()) {
 945                 anchor.safeDelete();
 946                 this.memoryAnchor = null;
 947             } else {
 948                 // Find out if all the return memory maps point to the anchor (i.e., there&#39;s no kill
 949                 // anywhere)
 950                 boolean needsMemoryMaps = false;
 951                 for (ReturnNode retNode : snippet.getNodes(ReturnNode.TYPE)) {
 952                     MemoryMapNode memoryMap = retNode.getMemoryMap();
 953                     if (memoryMap.getLocations().size() &gt; 1 || memoryMap.getLastLocationAccess(LocationIdentity.any()) != anchor) {
 954                         needsMemoryMaps = true;
 955                         break;
 956                     }
 957                 }
 958                 boolean needsAnchor;
</pre>
<hr />
<pre>
1268     };
1269 
1270     private boolean assertSnippetKills(ValueNode replacee) {
1271         if (!replacee.graph().isAfterFloatingReadPhase()) {
1272             // no floating reads yet, ignore locations created while lowering
1273             return true;
1274         }
1275         if (returnNode == null) {
1276             // The snippet terminates control flow
1277             return true;
1278         }
1279         MemoryMapNode memoryMap = returnNode.getMemoryMap();
1280         if (memoryMap == null || memoryMap.isEmpty()) {
1281             // there are no kills in the snippet graph
1282             return true;
1283         }
1284 
1285         EconomicSet&lt;LocationIdentity&gt; kills = EconomicSet.create(Equivalence.DEFAULT);
1286         kills.addAll(memoryMap.getLocations());
1287 
<span class="line-modified">1288         if (replacee instanceof MemoryCheckpoint.Single) {</span>
1289             // check if some node in snippet graph also kills the same location
<span class="line-modified">1290             LocationIdentity locationIdentity = ((MemoryCheckpoint.Single) replacee).getKilledLocationIdentity();</span>
1291             if (locationIdentity.isAny()) {
1292                 assert !(memoryMap.getLastLocationAccess(any()) instanceof MemoryAnchorNode) : replacee + &quot; kills ANY_LOCATION, but snippet does not&quot;;
1293                 // if the replacee kills ANY_LOCATION, the snippet can kill arbitrary locations
1294                 return true;
1295             }
1296             assert kills.contains(locationIdentity) : replacee + &quot; kills &quot; + locationIdentity + &quot;, but snippet doesn&#39;t contain a kill to this location&quot;;
1297             kills.remove(locationIdentity);
1298         }
<span class="line-modified">1299         assert !(replacee instanceof MemoryCheckpoint.Multi) : replacee + &quot; multi not supported (yet)&quot;;</span>
1300 
1301         // remove ANY_LOCATION if it&#39;s just a kill by the start node
1302         if (memoryMap.getLastLocationAccess(any()) instanceof MemoryAnchorNode) {
1303             kills.remove(any());
1304         }
1305 
1306         // node can only lower to a ANY_LOCATION kill if the replacee also kills ANY_LOCATION
1307         assert !kills.contains(any()) : &quot;snippet graph contains a kill to ANY_LOCATION, but replacee (&quot; + replacee + &quot;) doesn&#39;t kill ANY_LOCATION.  kills: &quot; + kills;
1308 
1309         /*
1310          * Kills to private locations are safe, since there can be no floating read to these
1311          * locations except reads that are introduced by the snippet itself or related snippets in
1312          * the same lowering round. These reads are anchored to a MemoryAnchor at the beginning of
1313          * their snippet, so they can not float above a kill in another instance of the same
1314          * snippet.
1315          */
1316         for (LocationIdentity p : this.info.privateLocations) {
1317             kills.remove(p);
1318         }
1319 
1320         assert kills.isEmpty() : &quot;snippet graph kills non-private locations &quot; + kills + &quot; that replacee (&quot; + replacee + &quot;) doesn&#39;t kill&quot;;
1321         return true;
1322     }
1323 
1324     private static class MemoryInputMap implements MemoryMap {
1325 
1326         private final LocationIdentity locationIdentity;
<span class="line-modified">1327         private final MemoryNode lastLocationAccess;</span>
1328 
1329         MemoryInputMap(ValueNode replacee) {
1330             if (replacee instanceof MemoryAccess) {
1331                 MemoryAccess access = (MemoryAccess) replacee;
1332                 locationIdentity = access.getLocationIdentity();
1333                 lastLocationAccess = access.getLastLocationAccess();
1334             } else {
1335                 locationIdentity = null;
1336                 lastLocationAccess = null;
1337             }
1338         }
1339 
1340         @Override
<span class="line-modified">1341         public MemoryNode getLastLocationAccess(LocationIdentity location) {</span>
1342             if (locationIdentity != null &amp;&amp; locationIdentity.equals(location)) {
1343                 return lastLocationAccess;
1344             } else {
1345                 return null;
1346             }
1347         }
1348 
1349         @Override
1350         public Collection&lt;LocationIdentity&gt; getLocations() {
1351             if (locationIdentity == null) {
1352                 return Collections.emptySet();
1353             } else {
1354                 return Collections.singleton(locationIdentity);
1355             }
1356         }
1357     }
1358 
1359     private class MemoryOutputMap extends MemoryInputMap {
1360 
1361         private final UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates;
1362 
1363         MemoryOutputMap(ValueNode replacee, UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates) {
1364             super(replacee);
1365             this.duplicates = duplicates;
1366         }
1367 
1368         @Override
<span class="line-modified">1369         public MemoryNode getLastLocationAccess(LocationIdentity locationIdentity) {</span>
1370             MemoryMapNode memoryMap = returnNode.getMemoryMap();
1371             assert memoryMap != null : &quot;no memory map stored for this snippet graph (snippet doesn&#39;t have a ReturnNode?)&quot;;
<span class="line-modified">1372             MemoryNode lastLocationAccess = memoryMap.getLastLocationAccess(locationIdentity);</span>
1373             assert lastLocationAccess != null : locationIdentity;
1374             if (lastLocationAccess == memoryAnchor) {
1375                 return super.getLastLocationAccess(locationIdentity);
1376             } else {
<span class="line-modified">1377                 return (MemoryNode) duplicates.get(ValueNodeUtil.asNode(lastLocationAccess));</span>
1378             }
1379         }
1380 
1381         @Override
1382         public Collection&lt;LocationIdentity&gt; getLocations() {
1383             return returnNode.getMemoryMap().getLocations();
1384         }
1385     }
1386 
1387     private void rewireMemoryGraph(ValueNode replacee, UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates) {
1388         if (replacee.graph().isAfterFloatingReadPhase()) {
1389             // rewire outgoing memory edges
1390             replaceMemoryUsages(replacee, new MemoryOutputMap(replacee, duplicates));
1391 
1392             if (returnNode != null) {
1393                 ReturnNode ret = (ReturnNode) duplicates.get(returnNode);
1394                 if (ret != null) {
1395                     MemoryMapNode memoryMap = ret.getMemoryMap();
1396                     if (memoryMap != null) {
1397                         ret.setMemoryMap(null);
</pre>
<hr />
<pre>
1403                 // rewire incoming memory edges
1404                 MemoryAnchorNode memoryDuplicate = (MemoryAnchorNode) duplicates.get(memoryAnchor);
1405                 replaceMemoryUsages(memoryDuplicate, new MemoryInputMap(replacee));
1406 
1407                 if (memoryDuplicate.hasNoUsages()) {
1408                     if (memoryDuplicate.next() != null) {
1409                         memoryDuplicate.graph().removeFixed(memoryDuplicate);
1410                     } else {
1411                         // this was a dummy memory node used when instantiating pure data-flow
1412                         // snippets: it was not attached to the control flow.
1413                         memoryDuplicate.safeDelete();
1414                     }
1415                 }
1416             }
1417         }
1418     }
1419 
1420     private static LocationIdentity getLocationIdentity(Node node) {
1421         if (node instanceof MemoryAccess) {
1422             return ((MemoryAccess) node).getLocationIdentity();
<span class="line-modified">1423         } else if (node instanceof MemoryProxy) {</span>
<span class="line-modified">1424             return ((MemoryProxy) node).getLocationIdentity();</span>
1425         } else if (node instanceof MemoryPhiNode) {
1426             return ((MemoryPhiNode) node).getLocationIdentity();
1427         } else {
1428             return null;
1429         }
1430     }
1431 
1432     private void replaceMemoryUsages(ValueNode node, MemoryMap map) {
1433         for (Node usage : node.usages().snapshot()) {
1434             if (usage instanceof MemoryMapNode) {
1435                 continue;
1436             }
1437 
1438             LocationIdentity location = getLocationIdentity(usage);
1439             if (location != null) {
1440                 for (Position pos : usage.inputPositions()) {
1441                     if (pos.getInputType() == InputType.Memory &amp;&amp; pos.get(usage) == node) {
<span class="line-modified">1442                         MemoryNode replacement = map.getLastLocationAccess(location);</span>
1443                         if (replacement == null) {
1444                             assert mayRemoveLocation || LocationIdentity.any().equals(location) ||
1445                                             CollectionsUtil.anyMatch(info.privateLocations, Predicate.isEqual(location)) : &quot;Snippet &quot; +
1446                                                             info.method.format(&quot;%h.%n&quot;) + &quot; contains access to the non-private location &quot; +
1447                                                             location + &quot;, but replacee doesn&#39;t access this location.&quot; + map.getLocations();
1448                         } else {
1449                             pos.set(usage, replacement.asNode());
1450                         }
1451                     }
1452                 }
1453             }
1454         }
1455     }
1456 
1457     /**
1458      * Replaces a given fixed node with this specialized snippet.
1459      *
1460      * @param metaAccess
1461      * @param replacee the node that will be replaced
1462      * @param replacer object that replaces the usages of {@code replacee}
</pre>
<hr />
<pre>
1490             StructuredGraph replaceeGraph = replacee.graph();
1491             EconomicMap&lt;Node, Node&gt; replacements = bind(replaceeGraph, metaAccess, args);
1492             replacements.put(entryPointNode, AbstractBeginNode.prevBegin(replacee));
1493             UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = inlineSnippet(replacee, debug, replaceeGraph, replacements);
1494 
1495             // Re-wire the control flow graph around the replacee
1496             FixedNode firstCFGNodeDuplicate = (FixedNode) duplicates.get(firstCFGNode);
1497             replacee.replaceAtPredecessor(firstCFGNodeDuplicate);
1498 
1499             rewireFrameStates(replacee, duplicates);
1500 
1501             updateStamps(replacee, duplicates);
1502 
1503             rewireMemoryGraph(replacee, duplicates);
1504 
1505             // Replace all usages of the replacee with the value returned by the snippet
1506             ValueNode returnValue = null;
1507             if (returnNode != null &amp;&amp; !(replacee instanceof ControlSinkNode)) {
1508                 ReturnNode returnDuplicate = (ReturnNode) duplicates.get(returnNode);
1509                 returnValue = returnDuplicate.result();
<span class="line-modified">1510                 if (returnValue == null &amp;&amp; replacee.usages().isNotEmpty() &amp;&amp; replacee instanceof MemoryCheckpoint) {</span>
1511                     replacer.replace(replacee, null);
1512                 } else {
1513                     assert returnValue != null || replacee.hasNoUsages();
1514                     replacer.replace(replacee, returnValue);
1515                 }
1516                 if (returnDuplicate.isAlive()) {
1517                     FixedNode next = null;
1518                     if (replacee instanceof FixedWithNextNode) {
1519                         FixedWithNextNode fwn = (FixedWithNextNode) replacee;
1520                         next = fwn.next();
1521                         fwn.setNext(null);
1522                     }
1523                     returnDuplicate.replaceAndDelete(next);
1524                 }
1525             }
1526 
1527             if (killReplacee) {
1528                 // Remove the replacee from its graph
1529                 GraphUtil.killCFG(replacee);
1530             }
</pre>
<hr />
<pre>
1648      *
1649      * @param metaAccess
1650      * @param replacee the node that will be replaced
1651      * @param replacer object that replaces the usages of {@code replacee}
1652      * @param args the arguments to be bound to the flattened positional parameters of the snippet
1653      */
1654     @SuppressWarnings(&quot;try&quot;)
1655     public void instantiate(MetaAccessProvider metaAccess, FloatingNode replacee, UsageReplacer replacer, Arguments args) {
1656         DebugContext debug = replacee.getDebug();
1657         assert assertSnippetKills(replacee);
1658         try (DebugCloseable a = args.info.instantiationTimer.start(debug)) {
1659             args.info.instantiationCounter.increment(debug);
1660 
1661             // Inline the snippet nodes, replacing parameters with the given args in the process
1662             StartNode entryPointNode = snippet.start();
1663             assert entryPointNode.next() == (memoryAnchor == null ? returnNode : memoryAnchor) : entryPointNode.next();
1664             StructuredGraph replaceeGraph = replacee.graph();
1665             EconomicMap&lt;Node, Node&gt; replacements = bind(replaceeGraph, metaAccess, args);
1666             MemoryAnchorNode anchorDuplicate = null;
1667             if (memoryAnchor != null) {
<span class="line-modified">1668                 anchorDuplicate = replaceeGraph.add(new MemoryAnchorNode());</span>
1669                 replacements.put(memoryAnchor, anchorDuplicate);
1670             }
1671             List&lt;Node&gt; floatingNodes = new ArrayList&lt;&gt;(nodes.size() - 2);
1672             for (Node n : nodes) {
1673                 if (n != entryPointNode &amp;&amp; n != returnNode) {
1674                     floatingNodes.add(n);
1675                 }
1676             }
1677             UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = inlineSnippet(replacee, debug, replaceeGraph, replacements);
1678 
1679             // floating nodes are not state-splits not need to re-wire frame states
1680             assert !(replacee instanceof StateSplit);
1681             updateStamps(replacee, duplicates);
1682 
1683             rewireMemoryGraph(replacee, duplicates);
1684             assert anchorDuplicate == null || anchorDuplicate.isDeleted();
1685 
1686             // Replace all usages of the replacee with the value returned by the snippet
1687             ValueNode returnValue = (ValueNode) duplicates.get(returnNode.result());
1688             replacer.replace(replacee, returnValue);
</pre>
<hr />
<pre>
1773                 buf.append(param.getStackKind().getJavaName()).append(&#39; &#39;).append(name);
1774             } else {
1775                 ParameterNode[] params = (ParameterNode[]) value;
1776                 String kind = params.length == 0 ? &quot;?&quot; : params[0].getStackKind().getJavaName();
1777                 buf.append(kind).append(&#39;[&#39;).append(params.length).append(&quot;] &quot;).append(name);
1778             }
1779         }
1780         return buf.append(&#39;)&#39;).toString();
1781     }
1782 
1783     private static boolean checkTemplate(MetaAccessProvider metaAccess, Arguments args, ResolvedJavaMethod method, Signature signature) {
1784         int offset = args.info.hasReceiver() ? 1 : 0;
1785         for (int i = offset; i &lt; args.info.getParameterCount(); i++) {
1786             if (args.info.isConstantParameter(i)) {
1787                 JavaKind kind = signature.getParameterKind(i - offset);
1788                 assert checkConstantArgument(metaAccess, method, signature, i - offset, args.info.getParameterName(i), args.values[i], kind);
1789 
1790             } else if (args.info.isVarargsParameter(i)) {
1791                 assert args.values[i] instanceof Varargs;
1792                 Varargs varargs = (Varargs) args.values[i];
<span class="line-modified">1793                 assert checkVarargs(metaAccess, method, signature, i, args.info.getParameterName(i), varargs);</span>
1794             }
1795         }
1796         return true;
1797     }
1798 
1799     public void setMayRemoveLocation(boolean mayRemoveLocation) {
1800         this.mayRemoveLocation = mayRemoveLocation;
1801     }
1802 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  96 import org.graalvm.compiler.nodes.LoopBeginNode;
  97 import org.graalvm.compiler.nodes.MergeNode;
  98 import org.graalvm.compiler.nodes.NodeView;
  99 import org.graalvm.compiler.nodes.ParameterNode;
 100 import org.graalvm.compiler.nodes.PhiNode;
 101 import org.graalvm.compiler.nodes.PiNode.Placeholder;
 102 import org.graalvm.compiler.nodes.PiNode.PlaceholderStamp;
 103 import org.graalvm.compiler.nodes.ReturnNode;
 104 import org.graalvm.compiler.nodes.StartNode;
 105 import org.graalvm.compiler.nodes.StateSplit;
 106 import org.graalvm.compiler.nodes.StructuredGraph;
 107 import org.graalvm.compiler.nodes.StructuredGraph.GuardsStage;
 108 import org.graalvm.compiler.nodes.ValueNode;
 109 import org.graalvm.compiler.nodes.ValueNodeUtil;
 110 import org.graalvm.compiler.nodes.calc.FloatingNode;
 111 import org.graalvm.compiler.nodes.java.LoadIndexedNode;
 112 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
 113 import org.graalvm.compiler.nodes.java.StoreIndexedNode;
 114 import org.graalvm.compiler.nodes.memory.MemoryAccess;
 115 import org.graalvm.compiler.nodes.memory.MemoryAnchorNode;
<span class="line-modified"> 116 import org.graalvm.compiler.nodes.memory.MemoryKill;</span>
 117 import org.graalvm.compiler.nodes.memory.MemoryMap;
 118 import org.graalvm.compiler.nodes.memory.MemoryMapNode;

 119 import org.graalvm.compiler.nodes.memory.MemoryPhiNode;
<span class="line-added"> 120 import org.graalvm.compiler.nodes.memory.MultiMemoryKill;</span>
<span class="line-added"> 121 import org.graalvm.compiler.nodes.memory.SingleMemoryKill;</span>
 122 import org.graalvm.compiler.nodes.spi.ArrayLengthProvider;
 123 import org.graalvm.compiler.nodes.spi.CoreProviders;
 124 import org.graalvm.compiler.nodes.spi.LoweringTool;
<span class="line-modified"> 125 import org.graalvm.compiler.nodes.spi.MemoryEdgeProxy;</span>
 126 import org.graalvm.compiler.nodes.util.GraphUtil;
 127 import org.graalvm.compiler.options.Option;
 128 import org.graalvm.compiler.options.OptionKey;
 129 import org.graalvm.compiler.options.OptionValues;
 130 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
 131 import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase;
 132 import org.graalvm.compiler.phases.common.FloatingReadPhase;
 133 import org.graalvm.compiler.phases.common.FloatingReadPhase.MemoryMapImpl;
 134 import org.graalvm.compiler.phases.common.GuardLoweringPhase;
 135 import org.graalvm.compiler.phases.common.LoweringPhase;
 136 import org.graalvm.compiler.phases.common.RemoveValueProxyPhase;
 137 import org.graalvm.compiler.phases.common.inlining.InliningUtil;
 138 import org.graalvm.compiler.phases.util.Providers;
 139 import org.graalvm.compiler.replacements.nodes.ExplodeLoopNode;
 140 import org.graalvm.compiler.replacements.nodes.LoadSnippetVarargParameterNode;
 141 import org.graalvm.util.CollectionsUtil;
 142 import jdk.internal.vm.compiler.word.LocationIdentity;
 143 import jdk.internal.vm.compiler.word.WordBase;
 144 
 145 import jdk.vm.ci.code.TargetDescription;
</pre>
<hr />
<pre>
 913                     FrameState frameState = stateSplit.stateAfter();
 914                     if (stateSplit.hasSideEffect()) {
 915                         curSideEffectNodes.add((StateSplit) node);
 916                     }
 917                     if (frameState != null) {
 918                         stateSplit.setStateAfter(null);
 919                     }
 920                 }
 921                 if (node instanceof DeoptimizingNode) {
 922                     DeoptimizingNode deoptNode = (DeoptimizingNode) node;
 923                     if (deoptNode.canDeoptimize()) {
 924                         curDeoptNodes.add(deoptNode);
 925                     }
 926                 }
 927             }
 928 
 929             new DeadCodeEliminationPhase(Required).apply(snippetCopy);
 930 
 931             assert checkAllVarargPlaceholdersAreDeleted(parameterCount, placeholders);
 932 
<span class="line-modified"> 933             if (((StructuredGraph) replacee.graph()).isAfterFloatingReadPhase()) {</span>
<span class="line-added"> 934                 new FloatingReadPhase(true, true).apply(snippetCopy);</span>
<span class="line-added"> 935             }</span>
 936 
 937             if (!guardsStage.requiresValueProxies()) {
 938                 new RemoveValueProxyPhase().apply(snippetCopy);
 939             }
 940 
<span class="line-modified"> 941             MemoryAnchorNode anchor = snippetCopy.add(new MemoryAnchorNode(info.privateLocations));</span>
 942             snippetCopy.start().replaceAtUsages(InputType.Memory, anchor);
 943 
 944             this.snippet = snippetCopy;
 945 
 946             StartNode entryPointNode = snippet.start();
 947             if (anchor.hasNoUsages()) {
 948                 anchor.safeDelete();
 949                 this.memoryAnchor = null;
 950             } else {
 951                 // Find out if all the return memory maps point to the anchor (i.e., there&#39;s no kill
 952                 // anywhere)
 953                 boolean needsMemoryMaps = false;
 954                 for (ReturnNode retNode : snippet.getNodes(ReturnNode.TYPE)) {
 955                     MemoryMapNode memoryMap = retNode.getMemoryMap();
 956                     if (memoryMap.getLocations().size() &gt; 1 || memoryMap.getLastLocationAccess(LocationIdentity.any()) != anchor) {
 957                         needsMemoryMaps = true;
 958                         break;
 959                     }
 960                 }
 961                 boolean needsAnchor;
</pre>
<hr />
<pre>
1271     };
1272 
1273     private boolean assertSnippetKills(ValueNode replacee) {
1274         if (!replacee.graph().isAfterFloatingReadPhase()) {
1275             // no floating reads yet, ignore locations created while lowering
1276             return true;
1277         }
1278         if (returnNode == null) {
1279             // The snippet terminates control flow
1280             return true;
1281         }
1282         MemoryMapNode memoryMap = returnNode.getMemoryMap();
1283         if (memoryMap == null || memoryMap.isEmpty()) {
1284             // there are no kills in the snippet graph
1285             return true;
1286         }
1287 
1288         EconomicSet&lt;LocationIdentity&gt; kills = EconomicSet.create(Equivalence.DEFAULT);
1289         kills.addAll(memoryMap.getLocations());
1290 
<span class="line-modified">1291         if (replacee instanceof SingleMemoryKill) {</span>
1292             // check if some node in snippet graph also kills the same location
<span class="line-modified">1293             LocationIdentity locationIdentity = ((SingleMemoryKill) replacee).getKilledLocationIdentity();</span>
1294             if (locationIdentity.isAny()) {
1295                 assert !(memoryMap.getLastLocationAccess(any()) instanceof MemoryAnchorNode) : replacee + &quot; kills ANY_LOCATION, but snippet does not&quot;;
1296                 // if the replacee kills ANY_LOCATION, the snippet can kill arbitrary locations
1297                 return true;
1298             }
1299             assert kills.contains(locationIdentity) : replacee + &quot; kills &quot; + locationIdentity + &quot;, but snippet doesn&#39;t contain a kill to this location&quot;;
1300             kills.remove(locationIdentity);
1301         }
<span class="line-modified">1302         assert !(replacee instanceof MultiMemoryKill) : replacee + &quot; multi not supported (yet)&quot;;</span>
1303 
1304         // remove ANY_LOCATION if it&#39;s just a kill by the start node
1305         if (memoryMap.getLastLocationAccess(any()) instanceof MemoryAnchorNode) {
1306             kills.remove(any());
1307         }
1308 
1309         // node can only lower to a ANY_LOCATION kill if the replacee also kills ANY_LOCATION
1310         assert !kills.contains(any()) : &quot;snippet graph contains a kill to ANY_LOCATION, but replacee (&quot; + replacee + &quot;) doesn&#39;t kill ANY_LOCATION.  kills: &quot; + kills;
1311 
1312         /*
1313          * Kills to private locations are safe, since there can be no floating read to these
1314          * locations except reads that are introduced by the snippet itself or related snippets in
1315          * the same lowering round. These reads are anchored to a MemoryAnchor at the beginning of
1316          * their snippet, so they can not float above a kill in another instance of the same
1317          * snippet.
1318          */
1319         for (LocationIdentity p : this.info.privateLocations) {
1320             kills.remove(p);
1321         }
1322 
1323         assert kills.isEmpty() : &quot;snippet graph kills non-private locations &quot; + kills + &quot; that replacee (&quot; + replacee + &quot;) doesn&#39;t kill&quot;;
1324         return true;
1325     }
1326 
1327     private static class MemoryInputMap implements MemoryMap {
1328 
1329         private final LocationIdentity locationIdentity;
<span class="line-modified">1330         private final MemoryKill lastLocationAccess;</span>
1331 
1332         MemoryInputMap(ValueNode replacee) {
1333             if (replacee instanceof MemoryAccess) {
1334                 MemoryAccess access = (MemoryAccess) replacee;
1335                 locationIdentity = access.getLocationIdentity();
1336                 lastLocationAccess = access.getLastLocationAccess();
1337             } else {
1338                 locationIdentity = null;
1339                 lastLocationAccess = null;
1340             }
1341         }
1342 
1343         @Override
<span class="line-modified">1344         public MemoryKill getLastLocationAccess(LocationIdentity location) {</span>
1345             if (locationIdentity != null &amp;&amp; locationIdentity.equals(location)) {
1346                 return lastLocationAccess;
1347             } else {
1348                 return null;
1349             }
1350         }
1351 
1352         @Override
1353         public Collection&lt;LocationIdentity&gt; getLocations() {
1354             if (locationIdentity == null) {
1355                 return Collections.emptySet();
1356             } else {
1357                 return Collections.singleton(locationIdentity);
1358             }
1359         }
1360     }
1361 
1362     private class MemoryOutputMap extends MemoryInputMap {
1363 
1364         private final UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates;
1365 
1366         MemoryOutputMap(ValueNode replacee, UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates) {
1367             super(replacee);
1368             this.duplicates = duplicates;
1369         }
1370 
1371         @Override
<span class="line-modified">1372         public MemoryKill getLastLocationAccess(LocationIdentity locationIdentity) {</span>
1373             MemoryMapNode memoryMap = returnNode.getMemoryMap();
1374             assert memoryMap != null : &quot;no memory map stored for this snippet graph (snippet doesn&#39;t have a ReturnNode?)&quot;;
<span class="line-modified">1375             MemoryKill lastLocationAccess = memoryMap.getLastLocationAccess(locationIdentity);</span>
1376             assert lastLocationAccess != null : locationIdentity;
1377             if (lastLocationAccess == memoryAnchor) {
1378                 return super.getLastLocationAccess(locationIdentity);
1379             } else {
<span class="line-modified">1380                 return (MemoryKill) duplicates.get(ValueNodeUtil.asNode(lastLocationAccess));</span>
1381             }
1382         }
1383 
1384         @Override
1385         public Collection&lt;LocationIdentity&gt; getLocations() {
1386             return returnNode.getMemoryMap().getLocations();
1387         }
1388     }
1389 
1390     private void rewireMemoryGraph(ValueNode replacee, UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates) {
1391         if (replacee.graph().isAfterFloatingReadPhase()) {
1392             // rewire outgoing memory edges
1393             replaceMemoryUsages(replacee, new MemoryOutputMap(replacee, duplicates));
1394 
1395             if (returnNode != null) {
1396                 ReturnNode ret = (ReturnNode) duplicates.get(returnNode);
1397                 if (ret != null) {
1398                     MemoryMapNode memoryMap = ret.getMemoryMap();
1399                     if (memoryMap != null) {
1400                         ret.setMemoryMap(null);
</pre>
<hr />
<pre>
1406                 // rewire incoming memory edges
1407                 MemoryAnchorNode memoryDuplicate = (MemoryAnchorNode) duplicates.get(memoryAnchor);
1408                 replaceMemoryUsages(memoryDuplicate, new MemoryInputMap(replacee));
1409 
1410                 if (memoryDuplicate.hasNoUsages()) {
1411                     if (memoryDuplicate.next() != null) {
1412                         memoryDuplicate.graph().removeFixed(memoryDuplicate);
1413                     } else {
1414                         // this was a dummy memory node used when instantiating pure data-flow
1415                         // snippets: it was not attached to the control flow.
1416                         memoryDuplicate.safeDelete();
1417                     }
1418                 }
1419             }
1420         }
1421     }
1422 
1423     private static LocationIdentity getLocationIdentity(Node node) {
1424         if (node instanceof MemoryAccess) {
1425             return ((MemoryAccess) node).getLocationIdentity();
<span class="line-modified">1426         } else if (node instanceof MemoryEdgeProxy) {</span>
<span class="line-modified">1427             return ((MemoryEdgeProxy) node).getLocationIdentity();</span>
1428         } else if (node instanceof MemoryPhiNode) {
1429             return ((MemoryPhiNode) node).getLocationIdentity();
1430         } else {
1431             return null;
1432         }
1433     }
1434 
1435     private void replaceMemoryUsages(ValueNode node, MemoryMap map) {
1436         for (Node usage : node.usages().snapshot()) {
1437             if (usage instanceof MemoryMapNode) {
1438                 continue;
1439             }
1440 
1441             LocationIdentity location = getLocationIdentity(usage);
1442             if (location != null) {
1443                 for (Position pos : usage.inputPositions()) {
1444                     if (pos.getInputType() == InputType.Memory &amp;&amp; pos.get(usage) == node) {
<span class="line-modified">1445                         MemoryKill replacement = map.getLastLocationAccess(location);</span>
1446                         if (replacement == null) {
1447                             assert mayRemoveLocation || LocationIdentity.any().equals(location) ||
1448                                             CollectionsUtil.anyMatch(info.privateLocations, Predicate.isEqual(location)) : &quot;Snippet &quot; +
1449                                                             info.method.format(&quot;%h.%n&quot;) + &quot; contains access to the non-private location &quot; +
1450                                                             location + &quot;, but replacee doesn&#39;t access this location.&quot; + map.getLocations();
1451                         } else {
1452                             pos.set(usage, replacement.asNode());
1453                         }
1454                     }
1455                 }
1456             }
1457         }
1458     }
1459 
1460     /**
1461      * Replaces a given fixed node with this specialized snippet.
1462      *
1463      * @param metaAccess
1464      * @param replacee the node that will be replaced
1465      * @param replacer object that replaces the usages of {@code replacee}
</pre>
<hr />
<pre>
1493             StructuredGraph replaceeGraph = replacee.graph();
1494             EconomicMap&lt;Node, Node&gt; replacements = bind(replaceeGraph, metaAccess, args);
1495             replacements.put(entryPointNode, AbstractBeginNode.prevBegin(replacee));
1496             UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = inlineSnippet(replacee, debug, replaceeGraph, replacements);
1497 
1498             // Re-wire the control flow graph around the replacee
1499             FixedNode firstCFGNodeDuplicate = (FixedNode) duplicates.get(firstCFGNode);
1500             replacee.replaceAtPredecessor(firstCFGNodeDuplicate);
1501 
1502             rewireFrameStates(replacee, duplicates);
1503 
1504             updateStamps(replacee, duplicates);
1505 
1506             rewireMemoryGraph(replacee, duplicates);
1507 
1508             // Replace all usages of the replacee with the value returned by the snippet
1509             ValueNode returnValue = null;
1510             if (returnNode != null &amp;&amp; !(replacee instanceof ControlSinkNode)) {
1511                 ReturnNode returnDuplicate = (ReturnNode) duplicates.get(returnNode);
1512                 returnValue = returnDuplicate.result();
<span class="line-modified">1513                 if (returnValue == null &amp;&amp; replacee.usages().isNotEmpty() &amp;&amp; replacee instanceof MemoryKill) {</span>
1514                     replacer.replace(replacee, null);
1515                 } else {
1516                     assert returnValue != null || replacee.hasNoUsages();
1517                     replacer.replace(replacee, returnValue);
1518                 }
1519                 if (returnDuplicate.isAlive()) {
1520                     FixedNode next = null;
1521                     if (replacee instanceof FixedWithNextNode) {
1522                         FixedWithNextNode fwn = (FixedWithNextNode) replacee;
1523                         next = fwn.next();
1524                         fwn.setNext(null);
1525                     }
1526                     returnDuplicate.replaceAndDelete(next);
1527                 }
1528             }
1529 
1530             if (killReplacee) {
1531                 // Remove the replacee from its graph
1532                 GraphUtil.killCFG(replacee);
1533             }
</pre>
<hr />
<pre>
1651      *
1652      * @param metaAccess
1653      * @param replacee the node that will be replaced
1654      * @param replacer object that replaces the usages of {@code replacee}
1655      * @param args the arguments to be bound to the flattened positional parameters of the snippet
1656      */
1657     @SuppressWarnings(&quot;try&quot;)
1658     public void instantiate(MetaAccessProvider metaAccess, FloatingNode replacee, UsageReplacer replacer, Arguments args) {
1659         DebugContext debug = replacee.getDebug();
1660         assert assertSnippetKills(replacee);
1661         try (DebugCloseable a = args.info.instantiationTimer.start(debug)) {
1662             args.info.instantiationCounter.increment(debug);
1663 
1664             // Inline the snippet nodes, replacing parameters with the given args in the process
1665             StartNode entryPointNode = snippet.start();
1666             assert entryPointNode.next() == (memoryAnchor == null ? returnNode : memoryAnchor) : entryPointNode.next();
1667             StructuredGraph replaceeGraph = replacee.graph();
1668             EconomicMap&lt;Node, Node&gt; replacements = bind(replaceeGraph, metaAccess, args);
1669             MemoryAnchorNode anchorDuplicate = null;
1670             if (memoryAnchor != null) {
<span class="line-modified">1671                 anchorDuplicate = replaceeGraph.add(new MemoryAnchorNode(info.privateLocations));</span>
1672                 replacements.put(memoryAnchor, anchorDuplicate);
1673             }
1674             List&lt;Node&gt; floatingNodes = new ArrayList&lt;&gt;(nodes.size() - 2);
1675             for (Node n : nodes) {
1676                 if (n != entryPointNode &amp;&amp; n != returnNode) {
1677                     floatingNodes.add(n);
1678                 }
1679             }
1680             UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = inlineSnippet(replacee, debug, replaceeGraph, replacements);
1681 
1682             // floating nodes are not state-splits not need to re-wire frame states
1683             assert !(replacee instanceof StateSplit);
1684             updateStamps(replacee, duplicates);
1685 
1686             rewireMemoryGraph(replacee, duplicates);
1687             assert anchorDuplicate == null || anchorDuplicate.isDeleted();
1688 
1689             // Replace all usages of the replacee with the value returned by the snippet
1690             ValueNode returnValue = (ValueNode) duplicates.get(returnNode.result());
1691             replacer.replace(replacee, returnValue);
</pre>
<hr />
<pre>
1776                 buf.append(param.getStackKind().getJavaName()).append(&#39; &#39;).append(name);
1777             } else {
1778                 ParameterNode[] params = (ParameterNode[]) value;
1779                 String kind = params.length == 0 ? &quot;?&quot; : params[0].getStackKind().getJavaName();
1780                 buf.append(kind).append(&#39;[&#39;).append(params.length).append(&quot;] &quot;).append(name);
1781             }
1782         }
1783         return buf.append(&#39;)&#39;).toString();
1784     }
1785 
1786     private static boolean checkTemplate(MetaAccessProvider metaAccess, Arguments args, ResolvedJavaMethod method, Signature signature) {
1787         int offset = args.info.hasReceiver() ? 1 : 0;
1788         for (int i = offset; i &lt; args.info.getParameterCount(); i++) {
1789             if (args.info.isConstantParameter(i)) {
1790                 JavaKind kind = signature.getParameterKind(i - offset);
1791                 assert checkConstantArgument(metaAccess, method, signature, i - offset, args.info.getParameterName(i), args.values[i], kind);
1792 
1793             } else if (args.info.isVarargsParameter(i)) {
1794                 assert args.values[i] instanceof Varargs;
1795                 Varargs varargs = (Varargs) args.values[i];
<span class="line-modified">1796                 assert checkVarargs(metaAccess, method, signature, i - offset, args.info.getParameterName(i), varargs);</span>
1797             }
1798         }
1799         return true;
1800     }
1801 
1802     public void setMayRemoveLocation(boolean mayRemoveLocation) {
1803         this.mayRemoveLocation = mayRemoveLocation;
1804     }
1805 }
</pre>
</td>
</tr>
</table>
<center><a href="SnippetLowerableMemoryNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="StandardGraphBuilderPlugins.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
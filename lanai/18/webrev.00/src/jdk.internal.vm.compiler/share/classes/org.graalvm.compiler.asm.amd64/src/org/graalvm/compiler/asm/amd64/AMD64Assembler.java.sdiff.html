<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.amd64/src/org/graalvm/compiler/asm/amd64/AMD64Assembler.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AMD64Address.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64BaseAssembler.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.amd64/src/org/graalvm/compiler/asm/amd64/AMD64Assembler.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.asm.amd64;
  26 
  27 import static jdk.vm.ci.amd64.AMD64.CPU;
  28 import static jdk.vm.ci.amd64.AMD64.MASK;
  29 import static jdk.vm.ci.amd64.AMD64.XMM;




  30 import static jdk.vm.ci.amd64.AMD64.CPUFeature.AVX512BW;
  31 import static jdk.vm.ci.amd64.AMD64.CPUFeature.AVX512CD;
  32 import static jdk.vm.ci.amd64.AMD64.CPUFeature.AVX512DQ;
  33 import static jdk.vm.ci.amd64.AMD64.CPUFeature.AVX512F;
  34 import static jdk.vm.ci.amd64.AMD64.CPUFeature.AVX512VL;
  35 import static jdk.vm.ci.code.MemoryBarriers.STORE_LOAD;
  36 import static org.graalvm.compiler.asm.amd64.AMD64AsmOptions.UseAddressNop;
  37 import static org.graalvm.compiler.asm.amd64.AMD64AsmOptions.UseIntelNops;
  38 import static org.graalvm.compiler.asm.amd64.AMD64AsmOptions.UseNormalNop;
  39 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.ADD;
  40 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.AND;
  41 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.CMP;
  42 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.OR;
  43 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.SBB;
  44 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.SUB;
  45 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.XOR;
  46 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MOp.DEC;
  47 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MOp.INC;
  48 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MOp.NEG;
  49 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MOp.NOT;
</pre>
<hr />
<pre>
  67 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.M_0F3A;
  68 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.P_;
  69 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.P_66;
  70 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.P_F2;
  71 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.P_F3;
  72 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.W0;
  73 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.W1;
  74 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.WIG;
  75 import static org.graalvm.compiler.core.common.NumUtil.isByte;
  76 import static org.graalvm.compiler.core.common.NumUtil.isInt;
  77 import static org.graalvm.compiler.core.common.NumUtil.isShiftCount;
  78 import static org.graalvm.compiler.core.common.NumUtil.isUByte;
  79 
  80 import java.util.EnumSet;
  81 
  82 import org.graalvm.compiler.asm.Label;
  83 import org.graalvm.compiler.asm.amd64.AMD64Address.Scale;
  84 import org.graalvm.compiler.asm.amd64.AVXKind.AVXSize;
  85 import org.graalvm.compiler.core.common.calc.Condition;
  86 import org.graalvm.compiler.debug.GraalError;




  87 
  88 import jdk.vm.ci.amd64.AMD64;
  89 import jdk.vm.ci.amd64.AMD64.CPUFeature;
  90 import jdk.vm.ci.code.Register;
  91 import jdk.vm.ci.code.Register.RegisterCategory;
  92 import jdk.vm.ci.code.TargetDescription;
  93 
  94 /**
  95  * This class implements an assembler that can encode most X86 instructions.
  96  */
  97 public class AMD64Assembler extends AMD64BaseAssembler {
  98 





















  99     /**
 100      * Constructs an assembler for the AMD64 architecture.
 101      */
<span class="line-modified"> 102     public AMD64Assembler(TargetDescription target) {</span>
 103         super(target);






 104     }
 105 
 106     /**
 107      * The x86 condition codes used for conditional jumps/moves.
 108      */
 109     public enum ConditionFlag {
 110         Zero(0x4, &quot;|zero|&quot;),
 111         NotZero(0x5, &quot;|nzero|&quot;),
 112         Equal(0x4, &quot;=&quot;),
 113         NotEqual(0x5, &quot;!=&quot;),
 114         Less(0xc, &quot;&lt;&quot;),
 115         LessEqual(0xe, &quot;&lt;=&quot;),
 116         Greater(0xf, &quot;&gt;&quot;),
 117         GreaterEqual(0xd, &quot;&gt;=&quot;),
 118         Below(0x2, &quot;|&lt;|&quot;),
 119         BelowEqual(0x6, &quot;|&lt;=|&quot;),
 120         Above(0x7, &quot;|&gt;|&quot;),
 121         AboveEqual(0x3, &quot;|&gt;=|&quot;),
 122         Overflow(0x0, &quot;|of|&quot;),
 123         NoOverflow(0x1, &quot;|nof|&quot;),
</pre>
<hr />
<pre>
 234             return false;
 235         }
 236 
 237     }
 238 
 239     protected static final int P_0F = 0x0F;
 240     protected static final int P_0F38 = 0x380F;
 241     protected static final int P_0F3A = 0x3A0F;
 242 
 243     /**
 244      * Base class for AMD64 opcodes.
 245      */
 246     public static class AMD64Op {
 247 
 248         private final String opcode;
 249 
 250         protected final int prefix1;
 251         protected final int prefix2;
 252         protected final int op;
 253 
<span class="line-modified"> 254         private final boolean dstIsByte;</span>
<span class="line-modified"> 255         private final boolean srcIsByte;</span>
 256 
 257         private final OpAssertion assertion;
 258         private final CPUFeature feature;
 259 
 260         protected AMD64Op(String opcode, int prefix1, int prefix2, int op, OpAssertion assertion, CPUFeature feature) {
 261             this(opcode, prefix1, prefix2, op, assertion == OpAssertion.ByteAssertion, assertion == OpAssertion.ByteAssertion, assertion, feature);
 262         }
 263 
 264         protected AMD64Op(String opcode, int prefix1, int prefix2, int op, boolean dstIsByte, boolean srcIsByte, OpAssertion assertion, CPUFeature feature) {
 265             this.opcode = opcode;
 266             this.prefix1 = prefix1;
 267             this.prefix2 = prefix2;
 268             this.op = op;
 269 
 270             this.dstIsByte = dstIsByte;
 271             this.srcIsByte = srcIsByte;
 272 
 273             this.assertion = assertion;
 274             this.feature = feature;
 275         }
</pre>
<hr />
<pre>
 342         private final boolean immIsByte;
 343 
 344         protected AMD64ImmOp(String opcode, boolean immIsByte, int prefix, int op, OpAssertion assertion) {
 345             this(opcode, immIsByte, prefix, op, assertion, null);
 346         }
 347 
 348         protected AMD64ImmOp(String opcode, boolean immIsByte, int prefix, int op, OpAssertion assertion, CPUFeature feature) {
 349             super(opcode, 0, prefix, op, assertion, feature);
 350             this.immIsByte = immIsByte;
 351         }
 352 
 353         protected final void emitImmediate(AMD64Assembler asm, OperandSize size, int imm) {
 354             if (immIsByte) {
 355                 assert imm == (byte) imm;
 356                 asm.emitByte(imm);
 357             } else {
 358                 size.emitImmediate(asm, imm);
 359             }
 360         }
 361 
<span class="line-modified"> 362         protected final int immediateSize(OperandSize size) {</span>
 363             if (immIsByte) {
 364                 return 1;
 365             } else {
<span class="line-modified"> 366                 return size.getBytes();</span>
 367             }
 368         }
 369     }
 370 
 371     /**
 372      * Opcode with operand order of either RM or MR for 2 address forms.
 373      */
 374     public abstract static class AMD64RROp extends AMD64Op {
 375 
 376         protected AMD64RROp(String opcode, int prefix1, int prefix2, int op, OpAssertion assertion, CPUFeature feature) {
 377             super(opcode, prefix1, prefix2, op, assertion, feature);
 378         }
 379 
 380         protected AMD64RROp(String opcode, int prefix1, int prefix2, int op, boolean dstIsByte, boolean srcIsByte, OpAssertion assertion, CPUFeature feature) {
 381             super(opcode, prefix1, prefix2, op, dstIsByte, srcIsByte, assertion, feature);
 382         }
 383 
 384         public abstract void emit(AMD64Assembler asm, OperandSize size, Register dst, Register src);
 385     }
 386 
</pre>
<hr />
<pre>
 588                 emitOpcode(asm, size, getRXB(src, dst), src.encoding, dst.encoding);
 589                 asm.emitModRM(src, dst);
 590             }
 591         }
 592 
 593         public final void emit(AMD64Assembler asm, OperandSize size, AMD64Address dst, Register src) {
 594             assert verify(asm, size, src, null);
 595             if (isSSEInstruction()) {
 596                 asm.simdPrefix(src, Register.None, dst, size, prefix1, prefix2, size == QWORD);
 597                 asm.emitByte(op);
 598             } else {
 599                 emitOpcode(asm, size, getRXB(src, dst), src.encoding, 0);
 600             }
 601             asm.emitOperandHelper(src, dst, 0);
 602         }
 603     }
 604 
 605     /**
 606      * Opcodes with operand order of M.
 607      */
<span class="line-modified"> 608     public static class AMD64MOp extends AMD64Op {</span>
 609         // @formatter:off
 610         public static final AMD64MOp NOT  = new AMD64MOp(&quot;NOT&quot;,  0xF7, 2);
 611         public static final AMD64MOp NEG  = new AMD64MOp(&quot;NEG&quot;,  0xF7, 3);
 612         public static final AMD64MOp MUL  = new AMD64MOp(&quot;MUL&quot;,  0xF7, 4);
 613         public static final AMD64MOp IMUL = new AMD64MOp(&quot;IMUL&quot;, 0xF7, 5);
 614         public static final AMD64MOp DIV  = new AMD64MOp(&quot;DIV&quot;,  0xF7, 6);
 615         public static final AMD64MOp IDIV = new AMD64MOp(&quot;IDIV&quot;, 0xF7, 7);
 616         public static final AMD64MOp INC  = new AMD64MOp(&quot;INC&quot;,  0xFF, 0);
 617         public static final AMD64MOp DEC  = new AMD64MOp(&quot;DEC&quot;,  0xFF, 1);
 618         public static final AMD64MOp PUSH = new AMD64MOp(&quot;PUSH&quot;, 0xFF, 6);
 619         public static final AMD64MOp POP  = new AMD64MOp(&quot;POP&quot;,  0x8F, 0, OpAssertion.WordOrDwordAssertion);
 620         // @formatter:on
 621 
 622         private final int ext;
 623 
 624         protected AMD64MOp(String opcode, int op, int ext) {
<span class="line-modified"> 625             this(opcode, 0, op, ext);</span>
<span class="line-removed"> 626         }</span>
<span class="line-removed"> 627 </span>
<span class="line-removed"> 628         protected AMD64MOp(String opcode, int prefix, int op, int ext) {</span>
<span class="line-removed"> 629             this(opcode, prefix, op, ext, OpAssertion.WordOrLargerAssertion);</span>
 630         }
 631 
 632         protected AMD64MOp(String opcode, int op, int ext, OpAssertion assertion) {
 633             this(opcode, 0, op, ext, assertion);
 634         }
 635 
 636         protected AMD64MOp(String opcode, int prefix, int op, int ext, OpAssertion assertion) {
 637             super(opcode, 0, prefix, op, assertion, null);
 638             this.ext = ext;
 639         }
 640 
<span class="line-modified"> 641         public final void emit(AMD64Assembler asm, OperandSize size, Register dst) {</span>
 642             assert verify(asm, size, dst, null);
 643             emitOpcode(asm, size, getRXB(null, dst), 0, dst.encoding);
 644             asm.emitModRM(ext, dst);
 645         }
 646 
<span class="line-modified"> 647         public final void emit(AMD64Assembler asm, OperandSize size, AMD64Address dst) {</span>
 648             assert verify(asm, size, null, null);
 649             emitOpcode(asm, size, getRXB(null, dst), 0, 0);
 650             asm.emitOperandHelper(ext, dst, 0);
 651         }
 652     }
 653 
 654     /**
 655      * Opcodes with operand order of MI.
 656      */
 657     public static class AMD64MIOp extends AMD64ImmOp {
 658         // @formatter:off
 659         public static final AMD64MIOp MOVB = new AMD64MIOp(&quot;MOVB&quot;, true,  0xC6, 0, OpAssertion.ByteAssertion);
 660         public static final AMD64MIOp MOV  = new AMD64MIOp(&quot;MOV&quot;,  false, 0xC7, 0);
 661         public static final AMD64MIOp TEST = new AMD64MIOp(&quot;TEST&quot;, false, 0xF7, 0);
 662         // @formatter:on
 663 
 664         private final int ext;
 665 
 666         protected AMD64MIOp(String opcode, boolean immIsByte, int op, int ext) {
 667             this(opcode, immIsByte, op, ext, OpAssertion.WordOrLargerAssertion);
</pre>
<hr />
<pre>
1898      * The 32-bit cmpxchg compares the value at adr with the contents of X86.rax, and stores reg
1899      * into adr if so; otherwise, the value at adr is loaded into X86.rax,. The ZF is set if the
1900      * compared values were equal, and cleared otherwise.
1901      */
1902     public final void cmpxchgl(Register reg, AMD64Address adr) { // cmpxchg
1903         prefix(adr, reg);
1904         emitByte(0x0F);
1905         emitByte(0xB1);
1906         emitOperandHelper(reg, adr, 0);
1907     }
1908 
1909     public final void cvtsi2sdl(Register dst, Register src) {
1910         SSEOp.CVTSI2SD.emit(this, DWORD, dst, src);
1911     }
1912 
1913     public final void cvttsd2sil(Register dst, Register src) {
1914         SSEOp.CVTTSD2SI.emit(this, DWORD, dst, src);
1915     }
1916 
1917     public final void decl(AMD64Address dst) {
<span class="line-modified">1918         prefix(dst);</span>
<span class="line-removed">1919         emitByte(0xFF);</span>
<span class="line-removed">1920         emitOperandHelper(1, dst, 0);</span>
1921     }
1922 
1923     public final void divsd(Register dst, Register src) {
1924         SSEOp.DIV.emit(this, SD, dst, src);
1925     }
1926 
1927     public final void hlt() {
1928         emitByte(0xF4);
1929     }
1930 
1931     public final void imull(Register dst, Register src, int value) {
1932         if (isByte(value)) {
1933             AMD64RMIOp.IMUL_SX.emit(this, DWORD, dst, src, value);
1934         } else {
1935             AMD64RMIOp.IMUL.emit(this, DWORD, dst, src, value);
1936         }
1937     }
1938 
1939     public final void incl(AMD64Address dst) {
<span class="line-modified">1940         prefix(dst);</span>
<span class="line-modified">1941         emitByte(0xFF);</span>
<span class="line-modified">1942         emitOperandHelper(0, dst, 0);</span>































































1943     }
1944 
1945     public void jcc(ConditionFlag cc, int jumpTarget, boolean forceDisp32) {
<span class="line-modified">1946         int shortSize = 2;</span>
<span class="line-modified">1947         int longSize = 6;</span>

1948         long disp = jumpTarget - position();
1949         if (!forceDisp32 &amp;&amp; isByte(disp - shortSize)) {
<span class="line-modified">1950             // 0111 tttn #8-bit disp</span>
<span class="line-modified">1951             emitByte(0x70 | cc.getValue());</span>
<span class="line-modified">1952             emitByte((int) ((disp - shortSize) &amp; 0xFF));</span>
<span class="line-modified">1953         } else {</span>
<span class="line-modified">1954             // 0000 1111 1000 tttn #32-bit disp</span>
<span class="line-modified">1955             assert isInt(disp - longSize) : &quot;must be 32bit offset (call4)&quot;;</span>
<span class="line-modified">1956             emitByte(0x0F);</span>
<span class="line-modified">1957             emitByte(0x80 | cc.getValue());</span>
<span class="line-modified">1958             emitInt((int) (disp - longSize));</span>
1959         }








1960     }
1961 
1962     public final void jcc(ConditionFlag cc, Label l) {
1963         assert (0 &lt;= cc.getValue()) &amp;&amp; (cc.getValue() &lt; 16) : &quot;illegal cc&quot;;
1964         if (l.isBound()) {
1965             jcc(cc, l.position(), false);
1966         } else {

1967             // Note: could eliminate cond. jumps to this jump if condition
1968             // is the same however, seems to be rather unlikely case.
1969             // Note: use jccb() if label to be bound is very close to get
1970             // an 8-bit displacement
1971             l.addPatchAt(position(), this);
1972             emitByte(0x0F);
1973             emitByte(0x80 | cc.getValue());
1974             emitInt(0);
1975         }
<span class="line-removed">1976 </span>
1977     }
1978 
1979     public final void jccb(ConditionFlag cc, Label l) {


1980         if (l.isBound()) {
<span class="line-removed">1981             int shortSize = 2;</span>
1982             int entry = l.position();
<span class="line-modified">1983             assert isByte(entry - (position() + shortSize)) : &quot;Dispacement too large for a short jmp&quot;;</span>
1984             long disp = entry - position();
1985             // 0111 tttn #8-bit disp
1986             emitByte(0x70 | cc.getValue());
1987             emitByte((int) ((disp - shortSize) &amp; 0xFF));
1988         } else {
1989             l.addPatchAt(position(), this);
1990             emitByte(0x70 | cc.getValue());
1991             emitByte(0);
1992         }
1993     }
1994 
<span class="line-modified">1995     public final void jmp(int jumpTarget, boolean forceDisp32) {</span>
<span class="line-modified">1996         int shortSize = 2;</span>
<span class="line-modified">1997         int longSize = 5;</span>
<span class="line-modified">1998         long disp = jumpTarget - position();</span>
<span class="line-modified">1999         if (!forceDisp32 &amp;&amp; isByte(disp - shortSize)) {</span>
<span class="line-modified">2000             emitByte(0xEB);</span>
<span class="line-removed">2001             emitByte((int) ((disp - shortSize) &amp; 0xFF));</span>
2002         } else {
<span class="line-modified">2003             emitByte(0xE9);</span>
<span class="line-modified">2004             emitInt((int) (disp - longSize));</span>























2005         }







2006     }
2007 
2008     @Override
2009     public final void jmp(Label l) {
2010         if (l.isBound()) {
2011             jmp(l.position(), false);
2012         } else {
2013             // By default, forward jumps are always 32-bit displacements, since
2014             // we can&#39;t yet know where the label will be bound. If you&#39;re sure that
2015             // the forward jump will not run beyond 256 bytes, use jmpb to
2016             // force an 8-bit displacement.
<span class="line-modified">2017 </span>
2018             l.addPatchAt(position(), this);
2019             emitByte(0xE9);
2020             emitInt(0);
2021         }
2022     }
2023 
<span class="line-modified">2024     public final void jmp(Register entry) {</span>
2025         prefix(entry);
2026         emitByte(0xFF);
2027         emitModRM(4, entry);
2028     }
2029 








2030     public final void jmp(AMD64Address adr) {



2031         prefix(adr);
2032         emitByte(0xFF);
2033         emitOperandHelper(AMD64.rsp, adr, 0);












































2034     }
2035 
2036     public final void jmpb(Label l) {


2037         if (l.isBound()) {
<span class="line-removed">2038             int shortSize = 2;</span>
2039             // Displacement is relative to byte just after jmpb instruction
2040             int displacement = l.position() - position() - shortSize;
2041             GraalError.guarantee(isByte(displacement), &quot;Displacement too large to be encoded as a byte: %d&quot;, displacement);
2042             emitByte(0xEB);
2043             emitByte(displacement &amp; 0xFF);
2044         } else {
2045             l.addPatchAt(position(), this);
2046             emitByte(0xEB);
2047             emitByte(0);
2048         }
2049     }
2050 
2051     public final void lead(Register dst, AMD64Address src) {
2052         prefix(src, dst);
2053         emitByte(0x8D);
2054         emitOperandHelper(dst, src, 0);
2055     }
2056 
2057     public final void leaq(Register dst, AMD64Address src) {
2058         prefixq(src, dst);
</pre>
<hr />
<pre>
2981         emitModRM(dst, src);
2982     }
2983 
2984     public final void punpcklbw(Register dst, Register src) {
2985         assert supports(CPUFeature.SSE2);
2986         assert inRC(XMM, dst) &amp;&amp; inRC(XMM, src);
2987         simdPrefix(dst, dst, src, PD, P_0F, false);
2988         emitByte(0x60);
2989         emitModRM(dst, src);
2990     }
2991 
2992     public final void rcpps(Register dst, Register src) {
2993         assert inRC(XMM, dst) &amp;&amp; inRC(XMM, src);
2994         simdPrefix(dst, Register.None, src, PS, P_0F, false);
2995         emitByte(0x53);
2996         emitModRM(dst, src);
2997     }
2998 
2999     public final void ret(int imm16) {
3000         if (imm16 == 0) {

3001             emitByte(0xC3);
3002         } else {

3003             emitByte(0xC2);
3004             emitShort(imm16);
3005         }
3006     }
3007 
3008     public final void sarl(Register dst, int imm8) {
3009         prefix(dst);
3010         assert isShiftCount(imm8 &gt;&gt; 1) : &quot;illegal shift count&quot;;
3011         if (imm8 == 1) {
3012             emitByte(0xD1);
3013             emitModRM(7, dst);
3014         } else {
3015             emitByte(0xC1);
3016             emitModRM(7, dst);
3017             emitByte(imm8);
3018         }
3019     }
3020 
3021     public final void shll(Register dst, int imm8) {
3022         assert isShiftCount(imm8 &gt;&gt; 1) : &quot;illegal shift count&quot;;
</pre>
<hr />
<pre>
3072     }
3073 
3074     public final void subpd(Register dst, Register src) {
3075         SSEOp.SUB.emit(this, PD, dst, src);
3076     }
3077 
3078     public final void subsd(Register dst, Register src) {
3079         SSEOp.SUB.emit(this, SD, dst, src);
3080     }
3081 
3082     public final void subsd(Register dst, AMD64Address src) {
3083         SSEOp.SUB.emit(this, SD, dst, src);
3084     }
3085 
3086     public final void testl(Register dst, int imm32) {
3087         // not using emitArith because test
3088         // doesn&#39;t support sign-extension of
3089         // 8bit operands
3090         if (dst.encoding == 0) {
3091             emitByte(0xA9);

3092         } else {
<span class="line-modified">3093             prefix(dst);</span>
<span class="line-removed">3094             emitByte(0xF7);</span>
<span class="line-removed">3095             emitModRM(0, dst);</span>
3096         }
<span class="line-removed">3097         emitInt(imm32);</span>
3098     }
3099 
3100     public final void testl(Register dst, Register src) {
<span class="line-modified">3101         prefix(dst, src);</span>
<span class="line-removed">3102         emitByte(0x85);</span>
<span class="line-removed">3103         emitModRM(dst, src);</span>
3104     }
3105 
3106     public final void testl(Register dst, AMD64Address src) {
<span class="line-modified">3107         prefix(src, dst);</span>
<span class="line-removed">3108         emitByte(0x85);</span>
<span class="line-removed">3109         emitOperandHelper(dst, src, 0);</span>
3110     }
3111 
3112     public final void unpckhpd(Register dst, Register src) {
3113         assert inRC(XMM, dst) &amp;&amp; inRC(XMM, src);
3114         simdPrefix(dst, dst, src, PD, P_0F, false);
3115         emitByte(0x15);
3116         emitModRM(dst, src);
3117     }
3118 
3119     public final void unpcklpd(Register dst, Register src) {
3120         assert inRC(XMM, dst) &amp;&amp; inRC(XMM, src);
3121         simdPrefix(dst, dst, src, PD, P_0F, false);
3122         emitByte(0x14);
3123         emitModRM(dst, src);
3124     }
3125 
3126     public final void xorl(Register dst, Register src) {
3127         XOR.rmOp.emit(this, DWORD, dst, src);
3128     }
3129 
3130     public final void xorq(Register dst, Register src) {
3131         XOR.rmOp.emit(this, QWORD, dst, src);
3132     }
3133 
3134     public final void xorpd(Register dst, Register src) {
3135         SSEOp.XOR.emit(this, PD, dst, src);
3136     }
3137 
3138     public final void xorps(Register dst, Register src) {
3139         SSEOp.XOR.emit(this, PS, dst, src);
3140     }
3141 
3142     public final void decl(Register dst) {
3143         // Use two-byte form (one-byte form is a REX prefix in 64-bit mode)
<span class="line-modified">3144         prefix(dst);</span>
<span class="line-removed">3145         emitByte(0xFF);</span>
<span class="line-removed">3146         emitModRM(1, dst);</span>
3147     }
3148 
3149     public final void incl(Register dst) {
3150         // Use two-byte form (one-byte from is a REX prefix in 64-bit mode)
<span class="line-modified">3151         prefix(dst);</span>
<span class="line-removed">3152         emitByte(0xFF);</span>
<span class="line-removed">3153         emitModRM(0, dst);</span>
3154     }
3155 
3156     public final void addq(Register dst, int imm32) {
3157         ADD.getMIOpcode(QWORD, isByte(imm32)).emit(this, QWORD, dst, imm32);
3158     }
3159 
3160     public final void addq(AMD64Address dst, int imm32) {
3161         ADD.getMIOpcode(QWORD, isByte(imm32)).emit(this, QWORD, dst, imm32);
3162     }
3163 
3164     public final void addq(Register dst, Register src) {
3165         ADD.rmOp.emit(this, QWORD, dst, src);
3166     }
3167 
3168     public final void addq(AMD64Address dst, Register src) {
3169         ADD.mrOp.emit(this, QWORD, dst, src);
3170     }
3171 
3172     public final void andq(Register dst, int imm32) {
3173         AND.getMIOpcode(QWORD, isByte(imm32)).emit(this, QWORD, dst, imm32);
</pre>
<hr />
<pre>
3250         emitModRM(dst, src);
3251     }
3252 
3253     public final void cvtsi2sdq(Register dst, Register src) {
3254         SSEOp.CVTSI2SD.emit(this, QWORD, dst, src);
3255     }
3256 
3257     public final void cvttsd2siq(Register dst, Register src) {
3258         SSEOp.CVTTSD2SI.emit(this, QWORD, dst, src);
3259     }
3260 
3261     public final void cvttpd2dq(Register dst, Register src) {
3262         assert inRC(XMM, dst) &amp;&amp; inRC(XMM, src);
3263         simdPrefix(dst, Register.None, src, PD, P_0F, false);
3264         emitByte(0xE6);
3265         emitModRM(dst, src);
3266     }
3267 
3268     public final void decq(Register dst) {
3269         // Use two-byte form (one-byte form is a REX prefix in 64-bit mode)
<span class="line-modified">3270         prefixq(dst);</span>
<span class="line-removed">3271         emitByte(0xFF);</span>
<span class="line-removed">3272         emitModRM(1, dst);</span>
3273     }
3274 
3275     public final void decq(AMD64Address dst) {
3276         DEC.emit(this, QWORD, dst);
3277     }
3278 
3279     public final void imulq(Register dst, Register src) {
3280         prefixq(dst, src);
3281         emitByte(0x0F);
3282         emitByte(0xAF);
3283         emitModRM(dst, src);
3284     }
3285 
3286     public final void incq(Register dst) {
3287         // Don&#39;t use it directly. Use Macroincrementq() instead.
3288         // Use two-byte form (one-byte from is a REX prefix in 64-bit mode)
<span class="line-modified">3289         prefixq(dst);</span>
<span class="line-removed">3290         emitByte(0xFF);</span>
<span class="line-removed">3291         emitModRM(0, dst);</span>
3292     }
3293 
3294     public final void incq(AMD64Address dst) {
3295         INC.emit(this, QWORD, dst);
3296     }
3297 
3298     public final void movq(Register dst, long imm64) {
3299         movq(dst, imm64, false);
3300     }
3301 
3302     public final void movq(Register dst, long imm64, boolean annotateImm) {
3303         int insnPos = position();
3304         prefixq(dst);
3305         emitByte(0xB8 + encode(dst));
3306         int immPos = position();
3307         emitLong(imm64);
3308         int nextInsnPos = position();
3309         if (annotateImm &amp;&amp; codePatchingAnnotationConsumer != null) {
3310             codePatchingAnnotationConsumer.accept(new OperandDataAnnotation(insnPos, immPos, nextInsnPos - immPos, nextInsnPos));
3311         }
</pre>
<hr />
<pre>
3469     }
3470 
3471     public final void subq(Register dst, int imm32) {
3472         SUB.getMIOpcode(QWORD, isByte(imm32)).emit(this, QWORD, dst, imm32);
3473     }
3474 
3475     public final void subq(AMD64Address dst, int imm32) {
3476         SUB.getMIOpcode(QWORD, isByte(imm32)).emit(this, QWORD, dst, imm32);
3477     }
3478 
3479     public final void subqWide(Register dst, int imm32) {
3480         // don&#39;t use the sign-extending version, forcing a 32-bit immediate
3481         SUB.getMIOpcode(QWORD, false).emit(this, QWORD, dst, imm32);
3482     }
3483 
3484     public final void subq(Register dst, Register src) {
3485         SUB.rmOp.emit(this, QWORD, dst, src);
3486     }
3487 
3488     public final void testq(Register dst, Register src) {
<span class="line-modified">3489         prefixq(dst, src);</span>
<span class="line-removed">3490         emitByte(0x85);</span>
<span class="line-removed">3491         emitModRM(dst, src);</span>
3492     }
3493 
3494     public final void btrq(Register src, int imm8) {
3495         prefixq(src);
3496         emitByte(0x0F);
3497         emitByte(0xBA);
3498         emitModRM(6, src);
3499         emitByte(imm8);
3500     }
3501 
3502     public final void xaddb(AMD64Address dst, Register src) {
3503         prefixb(dst, src);
3504         emitByte(0x0F);
3505         emitByte(0xC0);
3506         emitOperandHelper(src, dst, 0);
3507     }
3508 
3509     public final void xaddw(AMD64Address dst, Register src) {
3510         emitByte(0x66); // Switch to 16-bit mode.
3511         prefix(dst, src);
</pre>
<hr />
<pre>
3947 
3948     // Insn: KTESTD k1, k2
3949 
3950     public final void ktestd(Register src1, Register src2) {
3951         assert supports(CPUFeature.AVX512BW);
3952         assert inRC(MASK, src1) &amp;&amp; inRC(MASK, src2);
3953         // Code: VEX.L0.66.0F.W1 99 /r
3954         vexPrefix(src1, Register.None, src2, AVXSize.XMM, P_66, M_0F, W1, W1, true);
3955         emitByte(0x99);
3956         emitModRM(src1, src2);
3957     }
3958 
3959     public final void evmovdqu64(Register dst, AMD64Address src) {
3960         assert supports(CPUFeature.AVX512F);
3961         assert inRC(XMM, dst);
3962         evexPrefix(dst, Register.None, Register.None, src, AVXSize.ZMM, P_F3, M_0F, W1, Z0, B0);
3963         emitByte(0x6F);
3964         emitOperandHelper(dst, src, 0, EVEXTuple.FVM.getDisp8ScalingFactor(AVXSize.ZMM));
3965     }
3966 








3967     // Insn: VPMOVZXBW zmm1, m256
3968 
3969     public final void evpmovzxbw(Register dst, AMD64Address src) {
3970         assert supports(CPUFeature.AVX512BW);
3971         assert inRC(XMM, dst);
3972         // Code: EVEX.512.66.0F38.WIG 30 /r
3973         evexPrefix(dst, Register.None, Register.None, src, AVXSize.ZMM, P_66, M_0F38, WIG, Z0, B0);
3974         emitByte(0x30);
3975         emitOperandHelper(dst, src, 0, EVEXTuple.HVM.getDisp8ScalingFactor(AVXSize.ZMM));
3976     }
3977 
3978     public final void evpcmpeqb(Register kdst, Register nds, AMD64Address src) {
3979         assert supports(CPUFeature.AVX512BW);
3980         assert inRC(MASK, kdst) &amp;&amp; inRC(XMM, nds);
3981         evexPrefix(kdst, Register.None, nds, src, AVXSize.ZMM, P_66, M_0F, WIG, Z0, B0);
3982         emitByte(0x74);
3983         emitOperandHelper(kdst, src, 0, EVEXTuple.FVM.getDisp8ScalingFactor(AVXSize.ZMM));
3984     }
3985 
3986     // Insn: VMOVDQU16 zmm1 {k1}{z}, zmm2/m512
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.asm.amd64;
  26 
  27 import static jdk.vm.ci.amd64.AMD64.CPU;
  28 import static jdk.vm.ci.amd64.AMD64.MASK;
  29 import static jdk.vm.ci.amd64.AMD64.XMM;
<span class="line-added">  30 import static jdk.vm.ci.amd64.AMD64.r12;</span>
<span class="line-added">  31 import static jdk.vm.ci.amd64.AMD64.r13;</span>
<span class="line-added">  32 import static jdk.vm.ci.amd64.AMD64.rbp;</span>
<span class="line-added">  33 import static jdk.vm.ci.amd64.AMD64.rsp;</span>
  34 import static jdk.vm.ci.amd64.AMD64.CPUFeature.AVX512BW;
  35 import static jdk.vm.ci.amd64.AMD64.CPUFeature.AVX512CD;
  36 import static jdk.vm.ci.amd64.AMD64.CPUFeature.AVX512DQ;
  37 import static jdk.vm.ci.amd64.AMD64.CPUFeature.AVX512F;
  38 import static jdk.vm.ci.amd64.AMD64.CPUFeature.AVX512VL;
  39 import static jdk.vm.ci.code.MemoryBarriers.STORE_LOAD;
  40 import static org.graalvm.compiler.asm.amd64.AMD64AsmOptions.UseAddressNop;
  41 import static org.graalvm.compiler.asm.amd64.AMD64AsmOptions.UseIntelNops;
  42 import static org.graalvm.compiler.asm.amd64.AMD64AsmOptions.UseNormalNop;
  43 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.ADD;
  44 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.AND;
  45 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.CMP;
  46 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.OR;
  47 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.SBB;
  48 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.SUB;
  49 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.XOR;
  50 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MOp.DEC;
  51 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MOp.INC;
  52 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MOp.NEG;
  53 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MOp.NOT;
</pre>
<hr />
<pre>
  71 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.M_0F3A;
  72 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.P_;
  73 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.P_66;
  74 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.P_F2;
  75 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.P_F3;
  76 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.W0;
  77 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.W1;
  78 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.VEXPrefixConfig.WIG;
  79 import static org.graalvm.compiler.core.common.NumUtil.isByte;
  80 import static org.graalvm.compiler.core.common.NumUtil.isInt;
  81 import static org.graalvm.compiler.core.common.NumUtil.isShiftCount;
  82 import static org.graalvm.compiler.core.common.NumUtil.isUByte;
  83 
  84 import java.util.EnumSet;
  85 
  86 import org.graalvm.compiler.asm.Label;
  87 import org.graalvm.compiler.asm.amd64.AMD64Address.Scale;
  88 import org.graalvm.compiler.asm.amd64.AVXKind.AVXSize;
  89 import org.graalvm.compiler.core.common.calc.Condition;
  90 import org.graalvm.compiler.debug.GraalError;
<span class="line-added">  91 import org.graalvm.compiler.options.Option;</span>
<span class="line-added">  92 import org.graalvm.compiler.options.OptionKey;</span>
<span class="line-added">  93 import org.graalvm.compiler.options.OptionType;</span>
<span class="line-added">  94 import org.graalvm.compiler.options.OptionValues;</span>
  95 
  96 import jdk.vm.ci.amd64.AMD64;
  97 import jdk.vm.ci.amd64.AMD64.CPUFeature;
  98 import jdk.vm.ci.code.Register;
  99 import jdk.vm.ci.code.Register.RegisterCategory;
 100 import jdk.vm.ci.code.TargetDescription;
 101 
 102 /**
 103  * This class implements an assembler that can encode most X86 instructions.
 104  */
 105 public class AMD64Assembler extends AMD64BaseAssembler {
 106 
<span class="line-added"> 107     public static class Options {</span>
<span class="line-added"> 108         // @formatter:off</span>
<span class="line-added"> 109         @Option(help = &quot;Force branch instructions to align with 32-bytes boundary, to mitigate the jcc erratum. &quot; +</span>
<span class="line-added"> 110                 &quot;See https://www.intel.com/content/dam/support/us/en/documents/processors/mitigations-jump-conditional-code-erratum.pdf for more details.&quot;, type = OptionType.User)</span>
<span class="line-added"> 111         public static final OptionKey&lt;Boolean&gt; UseBranchesWithin32ByteBoundary = new OptionKey&lt;&gt;(false);</span>
<span class="line-added"> 112         // @formatter:on</span>
<span class="line-added"> 113     }</span>
<span class="line-added"> 114 </span>
<span class="line-added"> 115     private final boolean useBranchesWithin32ByteBoundary;</span>
<span class="line-added"> 116 </span>
<span class="line-added"> 117     public interface CodePatchShifter {</span>
<span class="line-added"> 118         void shift(int pos, int bytesToShift);</span>
<span class="line-added"> 119     }</span>
<span class="line-added"> 120 </span>
<span class="line-added"> 121     protected CodePatchShifter codePatchShifter = null;</span>
<span class="line-added"> 122 </span>
<span class="line-added"> 123     public AMD64Assembler(TargetDescription target) {</span>
<span class="line-added"> 124         super(target);</span>
<span class="line-added"> 125         useBranchesWithin32ByteBoundary = false;</span>
<span class="line-added"> 126     }</span>
<span class="line-added"> 127 </span>
 128     /**
 129      * Constructs an assembler for the AMD64 architecture.
 130      */
<span class="line-modified"> 131     public AMD64Assembler(TargetDescription target, OptionValues optionValues) {</span>
 132         super(target);
<span class="line-added"> 133         useBranchesWithin32ByteBoundary = Options.UseBranchesWithin32ByteBoundary.getValue(optionValues);</span>
<span class="line-added"> 134     }</span>
<span class="line-added"> 135 </span>
<span class="line-added"> 136     public void setCodePatchShifter(CodePatchShifter codePatchShifter) {</span>
<span class="line-added"> 137         assert this.codePatchShifter == null : &quot;overwriting existing value&quot;;</span>
<span class="line-added"> 138         this.codePatchShifter = codePatchShifter;</span>
 139     }
 140 
 141     /**
 142      * The x86 condition codes used for conditional jumps/moves.
 143      */
 144     public enum ConditionFlag {
 145         Zero(0x4, &quot;|zero|&quot;),
 146         NotZero(0x5, &quot;|nzero|&quot;),
 147         Equal(0x4, &quot;=&quot;),
 148         NotEqual(0x5, &quot;!=&quot;),
 149         Less(0xc, &quot;&lt;&quot;),
 150         LessEqual(0xe, &quot;&lt;=&quot;),
 151         Greater(0xf, &quot;&gt;&quot;),
 152         GreaterEqual(0xd, &quot;&gt;=&quot;),
 153         Below(0x2, &quot;|&lt;|&quot;),
 154         BelowEqual(0x6, &quot;|&lt;=|&quot;),
 155         Above(0x7, &quot;|&gt;|&quot;),
 156         AboveEqual(0x3, &quot;|&gt;=|&quot;),
 157         Overflow(0x0, &quot;|of|&quot;),
 158         NoOverflow(0x1, &quot;|nof|&quot;),
</pre>
<hr />
<pre>
 269             return false;
 270         }
 271 
 272     }
 273 
 274     protected static final int P_0F = 0x0F;
 275     protected static final int P_0F38 = 0x380F;
 276     protected static final int P_0F3A = 0x3A0F;
 277 
 278     /**
 279      * Base class for AMD64 opcodes.
 280      */
 281     public static class AMD64Op {
 282 
 283         private final String opcode;
 284 
 285         protected final int prefix1;
 286         protected final int prefix2;
 287         protected final int op;
 288 
<span class="line-modified"> 289         final boolean dstIsByte;</span>
<span class="line-modified"> 290         final boolean srcIsByte;</span>
 291 
 292         private final OpAssertion assertion;
 293         private final CPUFeature feature;
 294 
 295         protected AMD64Op(String opcode, int prefix1, int prefix2, int op, OpAssertion assertion, CPUFeature feature) {
 296             this(opcode, prefix1, prefix2, op, assertion == OpAssertion.ByteAssertion, assertion == OpAssertion.ByteAssertion, assertion, feature);
 297         }
 298 
 299         protected AMD64Op(String opcode, int prefix1, int prefix2, int op, boolean dstIsByte, boolean srcIsByte, OpAssertion assertion, CPUFeature feature) {
 300             this.opcode = opcode;
 301             this.prefix1 = prefix1;
 302             this.prefix2 = prefix2;
 303             this.op = op;
 304 
 305             this.dstIsByte = dstIsByte;
 306             this.srcIsByte = srcIsByte;
 307 
 308             this.assertion = assertion;
 309             this.feature = feature;
 310         }
</pre>
<hr />
<pre>
 377         private final boolean immIsByte;
 378 
 379         protected AMD64ImmOp(String opcode, boolean immIsByte, int prefix, int op, OpAssertion assertion) {
 380             this(opcode, immIsByte, prefix, op, assertion, null);
 381         }
 382 
 383         protected AMD64ImmOp(String opcode, boolean immIsByte, int prefix, int op, OpAssertion assertion, CPUFeature feature) {
 384             super(opcode, 0, prefix, op, assertion, feature);
 385             this.immIsByte = immIsByte;
 386         }
 387 
 388         protected final void emitImmediate(AMD64Assembler asm, OperandSize size, int imm) {
 389             if (immIsByte) {
 390                 assert imm == (byte) imm;
 391                 asm.emitByte(imm);
 392             } else {
 393                 size.emitImmediate(asm, imm);
 394             }
 395         }
 396 
<span class="line-modified"> 397         public final int immediateSize(OperandSize size) {</span>
 398             if (immIsByte) {
 399                 return 1;
 400             } else {
<span class="line-modified"> 401                 return size.immediateSize();</span>
 402             }
 403         }
 404     }
 405 
 406     /**
 407      * Opcode with operand order of either RM or MR for 2 address forms.
 408      */
 409     public abstract static class AMD64RROp extends AMD64Op {
 410 
 411         protected AMD64RROp(String opcode, int prefix1, int prefix2, int op, OpAssertion assertion, CPUFeature feature) {
 412             super(opcode, prefix1, prefix2, op, assertion, feature);
 413         }
 414 
 415         protected AMD64RROp(String opcode, int prefix1, int prefix2, int op, boolean dstIsByte, boolean srcIsByte, OpAssertion assertion, CPUFeature feature) {
 416             super(opcode, prefix1, prefix2, op, dstIsByte, srcIsByte, assertion, feature);
 417         }
 418 
 419         public abstract void emit(AMD64Assembler asm, OperandSize size, Register dst, Register src);
 420     }
 421 
</pre>
<hr />
<pre>
 623                 emitOpcode(asm, size, getRXB(src, dst), src.encoding, dst.encoding);
 624                 asm.emitModRM(src, dst);
 625             }
 626         }
 627 
 628         public final void emit(AMD64Assembler asm, OperandSize size, AMD64Address dst, Register src) {
 629             assert verify(asm, size, src, null);
 630             if (isSSEInstruction()) {
 631                 asm.simdPrefix(src, Register.None, dst, size, prefix1, prefix2, size == QWORD);
 632                 asm.emitByte(op);
 633             } else {
 634                 emitOpcode(asm, size, getRXB(src, dst), src.encoding, 0);
 635             }
 636             asm.emitOperandHelper(src, dst, 0);
 637         }
 638     }
 639 
 640     /**
 641      * Opcodes with operand order of M.
 642      */
<span class="line-modified"> 643     public static final class AMD64MOp extends AMD64Op {</span>
 644         // @formatter:off
 645         public static final AMD64MOp NOT  = new AMD64MOp(&quot;NOT&quot;,  0xF7, 2);
 646         public static final AMD64MOp NEG  = new AMD64MOp(&quot;NEG&quot;,  0xF7, 3);
 647         public static final AMD64MOp MUL  = new AMD64MOp(&quot;MUL&quot;,  0xF7, 4);
 648         public static final AMD64MOp IMUL = new AMD64MOp(&quot;IMUL&quot;, 0xF7, 5);
 649         public static final AMD64MOp DIV  = new AMD64MOp(&quot;DIV&quot;,  0xF7, 6);
 650         public static final AMD64MOp IDIV = new AMD64MOp(&quot;IDIV&quot;, 0xF7, 7);
 651         public static final AMD64MOp INC  = new AMD64MOp(&quot;INC&quot;,  0xFF, 0);
 652         public static final AMD64MOp DEC  = new AMD64MOp(&quot;DEC&quot;,  0xFF, 1);
 653         public static final AMD64MOp PUSH = new AMD64MOp(&quot;PUSH&quot;, 0xFF, 6);
 654         public static final AMD64MOp POP  = new AMD64MOp(&quot;POP&quot;,  0x8F, 0, OpAssertion.WordOrDwordAssertion);
 655         // @formatter:on
 656 
 657         private final int ext;
 658 
 659         protected AMD64MOp(String opcode, int op, int ext) {
<span class="line-modified"> 660             this(opcode, 0, op, ext, OpAssertion.WordOrLargerAssertion);</span>




 661         }
 662 
 663         protected AMD64MOp(String opcode, int op, int ext, OpAssertion assertion) {
 664             this(opcode, 0, op, ext, assertion);
 665         }
 666 
 667         protected AMD64MOp(String opcode, int prefix, int op, int ext, OpAssertion assertion) {
 668             super(opcode, 0, prefix, op, assertion, null);
 669             this.ext = ext;
 670         }
 671 
<span class="line-modified"> 672         public void emit(AMD64Assembler asm, OperandSize size, Register dst) {</span>
 673             assert verify(asm, size, dst, null);
 674             emitOpcode(asm, size, getRXB(null, dst), 0, dst.encoding);
 675             asm.emitModRM(ext, dst);
 676         }
 677 
<span class="line-modified"> 678         public void emit(AMD64Assembler asm, OperandSize size, AMD64Address dst) {</span>
 679             assert verify(asm, size, null, null);
 680             emitOpcode(asm, size, getRXB(null, dst), 0, 0);
 681             asm.emitOperandHelper(ext, dst, 0);
 682         }
 683     }
 684 
 685     /**
 686      * Opcodes with operand order of MI.
 687      */
 688     public static class AMD64MIOp extends AMD64ImmOp {
 689         // @formatter:off
 690         public static final AMD64MIOp MOVB = new AMD64MIOp(&quot;MOVB&quot;, true,  0xC6, 0, OpAssertion.ByteAssertion);
 691         public static final AMD64MIOp MOV  = new AMD64MIOp(&quot;MOV&quot;,  false, 0xC7, 0);
 692         public static final AMD64MIOp TEST = new AMD64MIOp(&quot;TEST&quot;, false, 0xF7, 0);
 693         // @formatter:on
 694 
 695         private final int ext;
 696 
 697         protected AMD64MIOp(String opcode, boolean immIsByte, int op, int ext) {
 698             this(opcode, immIsByte, op, ext, OpAssertion.WordOrLargerAssertion);
</pre>
<hr />
<pre>
1929      * The 32-bit cmpxchg compares the value at adr with the contents of X86.rax, and stores reg
1930      * into adr if so; otherwise, the value at adr is loaded into X86.rax,. The ZF is set if the
1931      * compared values were equal, and cleared otherwise.
1932      */
1933     public final void cmpxchgl(Register reg, AMD64Address adr) { // cmpxchg
1934         prefix(adr, reg);
1935         emitByte(0x0F);
1936         emitByte(0xB1);
1937         emitOperandHelper(reg, adr, 0);
1938     }
1939 
1940     public final void cvtsi2sdl(Register dst, Register src) {
1941         SSEOp.CVTSI2SD.emit(this, DWORD, dst, src);
1942     }
1943 
1944     public final void cvttsd2sil(Register dst, Register src) {
1945         SSEOp.CVTTSD2SI.emit(this, DWORD, dst, src);
1946     }
1947 
1948     public final void decl(AMD64Address dst) {
<span class="line-modified">1949         DEC.emit(this, DWORD, dst);</span>


1950     }
1951 
1952     public final void divsd(Register dst, Register src) {
1953         SSEOp.DIV.emit(this, SD, dst, src);
1954     }
1955 
1956     public final void hlt() {
1957         emitByte(0xF4);
1958     }
1959 
1960     public final void imull(Register dst, Register src, int value) {
1961         if (isByte(value)) {
1962             AMD64RMIOp.IMUL_SX.emit(this, DWORD, dst, src, value);
1963         } else {
1964             AMD64RMIOp.IMUL.emit(this, DWORD, dst, src, value);
1965         }
1966     }
1967 
1968     public final void incl(AMD64Address dst) {
<span class="line-modified">1969         INC.emit(this, DWORD, dst);</span>
<span class="line-modified">1970     }</span>
<span class="line-modified">1971 </span>
<span class="line-added">1972     public static final int JCC_ERRATUM_MITIGATION_BOUNDARY = 0x20;</span>
<span class="line-added">1973     public static final int OPCODE_IN_BYTES = 1;</span>
<span class="line-added">1974     public static final int MODRM_IN_BYTES = 1;</span>
<span class="line-added">1975 </span>
<span class="line-added">1976     protected static int getPrefixInBytes(OperandSize size, Register dst, boolean dstIsByte) {</span>
<span class="line-added">1977         boolean needsRex = needsRex(dst, dstIsByte);</span>
<span class="line-added">1978         if (size == WORD) {</span>
<span class="line-added">1979             return needsRex ? 2 : 1;</span>
<span class="line-added">1980         }</span>
<span class="line-added">1981         return size == QWORD || needsRex ? 1 : 0;</span>
<span class="line-added">1982     }</span>
<span class="line-added">1983 </span>
<span class="line-added">1984     protected static int getPrefixInBytes(OperandSize size, AMD64Address src) {</span>
<span class="line-added">1985         boolean needsRex = needsRex(src.getBase()) || needsRex(src.getIndex());</span>
<span class="line-added">1986         if (size == WORD) {</span>
<span class="line-added">1987             return needsRex ? 2 : 1;</span>
<span class="line-added">1988         }</span>
<span class="line-added">1989         return size == QWORD || needsRex ? 1 : 0;</span>
<span class="line-added">1990     }</span>
<span class="line-added">1991 </span>
<span class="line-added">1992     protected static int getPrefixInBytes(OperandSize size, Register dst, boolean dstIsByte, Register src, boolean srcIsByte) {</span>
<span class="line-added">1993         boolean needsRex = needsRex(dst, dstIsByte) || needsRex(src, srcIsByte);</span>
<span class="line-added">1994         if (size == WORD) {</span>
<span class="line-added">1995             return needsRex ? 2 : 1;</span>
<span class="line-added">1996         }</span>
<span class="line-added">1997         return size == QWORD || needsRex ? 1 : 0;</span>
<span class="line-added">1998     }</span>
<span class="line-added">1999 </span>
<span class="line-added">2000     protected static int getPrefixInBytes(OperandSize size, Register dst, boolean dstIsByte, AMD64Address src) {</span>
<span class="line-added">2001         boolean needsRex = needsRex(dst, dstIsByte) || needsRex(src.getBase()) || needsRex(src.getIndex());</span>
<span class="line-added">2002         if (size == WORD) {</span>
<span class="line-added">2003             return needsRex ? 2 : 1;</span>
<span class="line-added">2004         }</span>
<span class="line-added">2005         return size == QWORD || needsRex ? 1 : 0;</span>
<span class="line-added">2006     }</span>
<span class="line-added">2007 </span>
<span class="line-added">2008     protected boolean mayCrossBoundary(int opStart, int opEnd) {</span>
<span class="line-added">2009         return (opStart / JCC_ERRATUM_MITIGATION_BOUNDARY) != ((opEnd - 1) / JCC_ERRATUM_MITIGATION_BOUNDARY) || (opEnd % JCC_ERRATUM_MITIGATION_BOUNDARY) == 0;</span>
<span class="line-added">2010     }</span>
<span class="line-added">2011 </span>
<span class="line-added">2012     private static int bytesUntilBoundary(int pos) {</span>
<span class="line-added">2013         return JCC_ERRATUM_MITIGATION_BOUNDARY - (pos % JCC_ERRATUM_MITIGATION_BOUNDARY);</span>
<span class="line-added">2014     }</span>
<span class="line-added">2015 </span>
<span class="line-added">2016     protected boolean ensureWithinBoundary(int opStart) {</span>
<span class="line-added">2017         if (useBranchesWithin32ByteBoundary) {</span>
<span class="line-added">2018             assert !mayCrossBoundary(opStart, position());</span>
<span class="line-added">2019         }</span>
<span class="line-added">2020         return true;</span>
<span class="line-added">2021     }</span>
<span class="line-added">2022 </span>
<span class="line-added">2023     protected final void testAndAlign(int bytesToEmit) {</span>
<span class="line-added">2024         if (useBranchesWithin32ByteBoundary) {</span>
<span class="line-added">2025             int beforeNextOp = position();</span>
<span class="line-added">2026             int afterNextOp = beforeNextOp + bytesToEmit;</span>
<span class="line-added">2027             if (mayCrossBoundary(beforeNextOp, afterNextOp)) {</span>
<span class="line-added">2028                 int bytesToShift = bytesUntilBoundary(beforeNextOp);</span>
<span class="line-added">2029                 nop(bytesToShift);</span>
<span class="line-added">2030                 if (codePatchShifter != null) {</span>
<span class="line-added">2031                     codePatchShifter.shift(beforeNextOp, bytesToShift);</span>
<span class="line-added">2032                 }</span>
<span class="line-added">2033             }</span>
<span class="line-added">2034         }</span>
2035     }
2036 
2037     public void jcc(ConditionFlag cc, int jumpTarget, boolean forceDisp32) {
<span class="line-modified">2038         final int shortSize = 2;</span>
<span class="line-modified">2039         final int longSize = 6;</span>
<span class="line-added">2040 </span>
2041         long disp = jumpTarget - position();
2042         if (!forceDisp32 &amp;&amp; isByte(disp - shortSize)) {
<span class="line-modified">2043             testAndAlign(shortSize);</span>
<span class="line-modified">2044             // After alignment, isByte(disp - shortSize) might not hold. Need to check again.</span>
<span class="line-modified">2045             disp = jumpTarget - position();</span>
<span class="line-modified">2046             if (isByte(disp - shortSize)) {</span>
<span class="line-modified">2047                 // 0111 tttn #8-bit disp</span>
<span class="line-modified">2048                 emitByte(0x70 | cc.getValue());</span>
<span class="line-modified">2049                 emitByte((int) ((disp - shortSize) &amp; 0xFF));</span>
<span class="line-modified">2050                 return;</span>
<span class="line-modified">2051             }</span>
2052         }
<span class="line-added">2053 </span>
<span class="line-added">2054         // 0000 1111 1000 tttn #32-bit disp</span>
<span class="line-added">2055         assert forceDisp32 || isInt(disp - longSize) : &quot;must be 32bit offset (call4)&quot;;</span>
<span class="line-added">2056         testAndAlign(longSize);</span>
<span class="line-added">2057         disp = jumpTarget - position();</span>
<span class="line-added">2058         emitByte(0x0F);</span>
<span class="line-added">2059         emitByte(0x80 | cc.getValue());</span>
<span class="line-added">2060         emitInt((int) (disp - longSize));</span>
2061     }
2062 
2063     public final void jcc(ConditionFlag cc, Label l) {
2064         assert (0 &lt;= cc.getValue()) &amp;&amp; (cc.getValue() &lt; 16) : &quot;illegal cc&quot;;
2065         if (l.isBound()) {
2066             jcc(cc, l.position(), false);
2067         } else {
<span class="line-added">2068             testAndAlign(6);</span>
2069             // Note: could eliminate cond. jumps to this jump if condition
2070             // is the same however, seems to be rather unlikely case.
2071             // Note: use jccb() if label to be bound is very close to get
2072             // an 8-bit displacement
2073             l.addPatchAt(position(), this);
2074             emitByte(0x0F);
2075             emitByte(0x80 | cc.getValue());
2076             emitInt(0);
2077         }

2078     }
2079 
2080     public final void jccb(ConditionFlag cc, Label l) {
<span class="line-added">2081         final int shortSize = 2;</span>
<span class="line-added">2082         testAndAlign(shortSize);</span>
2083         if (l.isBound()) {

2084             int entry = l.position();
<span class="line-modified">2085             assert isByte(entry - (position() + shortSize)) : &quot;Displacement too large for a short jmp&quot;;</span>
2086             long disp = entry - position();
2087             // 0111 tttn #8-bit disp
2088             emitByte(0x70 | cc.getValue());
2089             emitByte((int) ((disp - shortSize) &amp; 0xFF));
2090         } else {
2091             l.addPatchAt(position(), this);
2092             emitByte(0x70 | cc.getValue());
2093             emitByte(0);
2094         }
2095     }
2096 
<span class="line-modified">2097     public final void jcc(ConditionFlag cc, Label branchTarget, boolean isShortJmp) {</span>
<span class="line-modified">2098         if (branchTarget == null) {</span>
<span class="line-modified">2099             // jump to placeholder</span>
<span class="line-modified">2100             jcc(cc, 0, true);</span>
<span class="line-modified">2101         } else if (isShortJmp) {</span>
<span class="line-modified">2102             jccb(cc, branchTarget);</span>

2103         } else {
<span class="line-modified">2104             jcc(cc, branchTarget);</span>
<span class="line-modified">2105         }</span>
<span class="line-added">2106     }</span>
<span class="line-added">2107 </span>
<span class="line-added">2108     /**</span>
<span class="line-added">2109      * Emit a jmp instruction given a known target address.</span>
<span class="line-added">2110      *</span>
<span class="line-added">2111      * @return the position where the jmp instruction starts.</span>
<span class="line-added">2112      */</span>
<span class="line-added">2113     public final int jmp(int jumpTarget, boolean forceDisp32) {</span>
<span class="line-added">2114         final int shortSize = 2;</span>
<span class="line-added">2115         final int longSize = 5;</span>
<span class="line-added">2116         // For long jmp, the jmp instruction will cross the jcc-erratum-mitigation-boundary when the</span>
<span class="line-added">2117         // current position is between [0x1b, 0x1f]. For short jmp [0x1e, 0x1f], which is covered by</span>
<span class="line-added">2118         // the long jmp triggering range.</span>
<span class="line-added">2119         if (!forceDisp32) {</span>
<span class="line-added">2120             // We first align the next jmp assuming it will be short jmp.</span>
<span class="line-added">2121             testAndAlign(shortSize);</span>
<span class="line-added">2122             int pos = position();</span>
<span class="line-added">2123             long disp = jumpTarget - pos;</span>
<span class="line-added">2124             if (isByte(disp - shortSize)) {</span>
<span class="line-added">2125                 emitByte(0xEB);</span>
<span class="line-added">2126                 emitByte((int) ((disp - shortSize) &amp; 0xFF));</span>
<span class="line-added">2127                 return pos;</span>
<span class="line-added">2128             }</span>
2129         }
<span class="line-added">2130 </span>
<span class="line-added">2131         testAndAlign(longSize);</span>
<span class="line-added">2132         int pos = position();</span>
<span class="line-added">2133         long disp = jumpTarget - pos;</span>
<span class="line-added">2134         emitByte(0xE9);</span>
<span class="line-added">2135         emitInt((int) (disp - longSize));</span>
<span class="line-added">2136         return pos;</span>
2137     }
2138 
2139     @Override
2140     public final void jmp(Label l) {
2141         if (l.isBound()) {
2142             jmp(l.position(), false);
2143         } else {
2144             // By default, forward jumps are always 32-bit displacements, since
2145             // we can&#39;t yet know where the label will be bound. If you&#39;re sure that
2146             // the forward jump will not run beyond 256 bytes, use jmpb to
2147             // force an 8-bit displacement.
<span class="line-modified">2148             testAndAlign(5);</span>
2149             l.addPatchAt(position(), this);
2150             emitByte(0xE9);
2151             emitInt(0);
2152         }
2153     }
2154 
<span class="line-modified">2155     protected final void jmpWithoutAlignment(Register entry) {</span>
2156         prefix(entry);
2157         emitByte(0xFF);
2158         emitModRM(4, entry);
2159     }
2160 
<span class="line-added">2161     public final void jmp(Register entry) {</span>
<span class="line-added">2162         int bytesToEmit = needsRex(entry) ? 3 : 2;</span>
<span class="line-added">2163         testAndAlign(bytesToEmit);</span>
<span class="line-added">2164         int beforeJmp = position();</span>
<span class="line-added">2165         jmpWithoutAlignment(entry);</span>
<span class="line-added">2166         assert beforeJmp + bytesToEmit == position();</span>
<span class="line-added">2167     }</span>
<span class="line-added">2168 </span>
2169     public final void jmp(AMD64Address adr) {
<span class="line-added">2170         int bytesToEmit = getPrefixInBytes(DWORD, adr) + OPCODE_IN_BYTES + addressInBytes(adr);</span>
<span class="line-added">2171         testAndAlign(bytesToEmit);</span>
<span class="line-added">2172         int beforeJmp = position();</span>
2173         prefix(adr);
2174         emitByte(0xFF);
2175         emitOperandHelper(AMD64.rsp, adr, 0);
<span class="line-added">2176         assert beforeJmp + bytesToEmit == position();</span>
<span class="line-added">2177     }</span>
<span class="line-added">2178 </span>
<span class="line-added">2179     /**</span>
<span class="line-added">2180      * This method should be synchronized with</span>
<span class="line-added">2181      * {@link AMD64BaseAssembler#emitOperandHelper(Register, AMD64Address, int)}}.</span>
<span class="line-added">2182      */</span>
<span class="line-added">2183     protected static int addressInBytes(AMD64Address addr) {</span>
<span class="line-added">2184         Register base = addr.getBase();</span>
<span class="line-added">2185         Register index = addr.getIndex();</span>
<span class="line-added">2186         int disp = addr.getDisplacement();</span>
<span class="line-added">2187 </span>
<span class="line-added">2188         if (base.equals(AMD64.rip)) {</span>
<span class="line-added">2189             return 5;</span>
<span class="line-added">2190         } else if (base.isValid()) {</span>
<span class="line-added">2191             final boolean isZeroDisplacement = disp == 0 &amp;&amp; !base.equals(rbp) &amp;&amp; !base.equals(r13);</span>
<span class="line-added">2192             if (index.isValid()) {</span>
<span class="line-added">2193                 if (isZeroDisplacement) {</span>
<span class="line-added">2194                     return 2;</span>
<span class="line-added">2195                 } else if (isByte(disp)) {</span>
<span class="line-added">2196                     return 3;</span>
<span class="line-added">2197                 } else {</span>
<span class="line-added">2198                     return 6;</span>
<span class="line-added">2199                 }</span>
<span class="line-added">2200             } else if (base.equals(rsp) || base.equals(r12)) {</span>
<span class="line-added">2201                 if (disp == 0) {</span>
<span class="line-added">2202                     return 2;</span>
<span class="line-added">2203                 } else if (isByte(disp)) {</span>
<span class="line-added">2204                     return 3;</span>
<span class="line-added">2205                 } else {</span>
<span class="line-added">2206                     return 6;</span>
<span class="line-added">2207                 }</span>
<span class="line-added">2208             } else {</span>
<span class="line-added">2209                 if (isZeroDisplacement) {</span>
<span class="line-added">2210                     return 1;</span>
<span class="line-added">2211                 } else if (isByte(disp)) {</span>
<span class="line-added">2212                     return 2;</span>
<span class="line-added">2213                 } else {</span>
<span class="line-added">2214                     return 5;</span>
<span class="line-added">2215                 }</span>
<span class="line-added">2216             }</span>
<span class="line-added">2217         } else {</span>
<span class="line-added">2218             return 6;</span>
<span class="line-added">2219         }</span>
2220     }
2221 
2222     public final void jmpb(Label l) {
<span class="line-added">2223         final int shortSize = 2;</span>
<span class="line-added">2224         testAndAlign(shortSize);</span>
2225         if (l.isBound()) {

2226             // Displacement is relative to byte just after jmpb instruction
2227             int displacement = l.position() - position() - shortSize;
2228             GraalError.guarantee(isByte(displacement), &quot;Displacement too large to be encoded as a byte: %d&quot;, displacement);
2229             emitByte(0xEB);
2230             emitByte(displacement &amp; 0xFF);
2231         } else {
2232             l.addPatchAt(position(), this);
2233             emitByte(0xEB);
2234             emitByte(0);
2235         }
2236     }
2237 
2238     public final void lead(Register dst, AMD64Address src) {
2239         prefix(src, dst);
2240         emitByte(0x8D);
2241         emitOperandHelper(dst, src, 0);
2242     }
2243 
2244     public final void leaq(Register dst, AMD64Address src) {
2245         prefixq(src, dst);
</pre>
<hr />
<pre>
3168         emitModRM(dst, src);
3169     }
3170 
3171     public final void punpcklbw(Register dst, Register src) {
3172         assert supports(CPUFeature.SSE2);
3173         assert inRC(XMM, dst) &amp;&amp; inRC(XMM, src);
3174         simdPrefix(dst, dst, src, PD, P_0F, false);
3175         emitByte(0x60);
3176         emitModRM(dst, src);
3177     }
3178 
3179     public final void rcpps(Register dst, Register src) {
3180         assert inRC(XMM, dst) &amp;&amp; inRC(XMM, src);
3181         simdPrefix(dst, Register.None, src, PS, P_0F, false);
3182         emitByte(0x53);
3183         emitModRM(dst, src);
3184     }
3185 
3186     public final void ret(int imm16) {
3187         if (imm16 == 0) {
<span class="line-added">3188             testAndAlign(1);</span>
3189             emitByte(0xC3);
3190         } else {
<span class="line-added">3191             testAndAlign(3);</span>
3192             emitByte(0xC2);
3193             emitShort(imm16);
3194         }
3195     }
3196 
3197     public final void sarl(Register dst, int imm8) {
3198         prefix(dst);
3199         assert isShiftCount(imm8 &gt;&gt; 1) : &quot;illegal shift count&quot;;
3200         if (imm8 == 1) {
3201             emitByte(0xD1);
3202             emitModRM(7, dst);
3203         } else {
3204             emitByte(0xC1);
3205             emitModRM(7, dst);
3206             emitByte(imm8);
3207         }
3208     }
3209 
3210     public final void shll(Register dst, int imm8) {
3211         assert isShiftCount(imm8 &gt;&gt; 1) : &quot;illegal shift count&quot;;
</pre>
<hr />
<pre>
3261     }
3262 
3263     public final void subpd(Register dst, Register src) {
3264         SSEOp.SUB.emit(this, PD, dst, src);
3265     }
3266 
3267     public final void subsd(Register dst, Register src) {
3268         SSEOp.SUB.emit(this, SD, dst, src);
3269     }
3270 
3271     public final void subsd(Register dst, AMD64Address src) {
3272         SSEOp.SUB.emit(this, SD, dst, src);
3273     }
3274 
3275     public final void testl(Register dst, int imm32) {
3276         // not using emitArith because test
3277         // doesn&#39;t support sign-extension of
3278         // 8bit operands
3279         if (dst.encoding == 0) {
3280             emitByte(0xA9);
<span class="line-added">3281             emitInt(imm32);</span>
3282         } else {
<span class="line-modified">3283             AMD64MIOp.TEST.emit(this, DWORD, dst, imm32);</span>


3284         }

3285     }
3286 
3287     public final void testl(Register dst, Register src) {
<span class="line-modified">3288         AMD64RMOp.TEST.emit(this, DWORD, dst, src);</span>


3289     }
3290 
3291     public final void testl(Register dst, AMD64Address src) {
<span class="line-modified">3292         AMD64RMOp.TEST.emit(this, DWORD, dst, src);</span>


3293     }
3294 
3295     public final void unpckhpd(Register dst, Register src) {
3296         assert inRC(XMM, dst) &amp;&amp; inRC(XMM, src);
3297         simdPrefix(dst, dst, src, PD, P_0F, false);
3298         emitByte(0x15);
3299         emitModRM(dst, src);
3300     }
3301 
3302     public final void unpcklpd(Register dst, Register src) {
3303         assert inRC(XMM, dst) &amp;&amp; inRC(XMM, src);
3304         simdPrefix(dst, dst, src, PD, P_0F, false);
3305         emitByte(0x14);
3306         emitModRM(dst, src);
3307     }
3308 
3309     public final void xorl(Register dst, Register src) {
3310         XOR.rmOp.emit(this, DWORD, dst, src);
3311     }
3312 
3313     public final void xorq(Register dst, Register src) {
3314         XOR.rmOp.emit(this, QWORD, dst, src);
3315     }
3316 
3317     public final void xorpd(Register dst, Register src) {
3318         SSEOp.XOR.emit(this, PD, dst, src);
3319     }
3320 
3321     public final void xorps(Register dst, Register src) {
3322         SSEOp.XOR.emit(this, PS, dst, src);
3323     }
3324 
3325     public final void decl(Register dst) {
3326         // Use two-byte form (one-byte form is a REX prefix in 64-bit mode)
<span class="line-modified">3327         DEC.emit(this, DWORD, dst);</span>


3328     }
3329 
3330     public final void incl(Register dst) {
3331         // Use two-byte form (one-byte from is a REX prefix in 64-bit mode)
<span class="line-modified">3332         INC.emit(this, DWORD, dst);</span>


3333     }
3334 
3335     public final void addq(Register dst, int imm32) {
3336         ADD.getMIOpcode(QWORD, isByte(imm32)).emit(this, QWORD, dst, imm32);
3337     }
3338 
3339     public final void addq(AMD64Address dst, int imm32) {
3340         ADD.getMIOpcode(QWORD, isByte(imm32)).emit(this, QWORD, dst, imm32);
3341     }
3342 
3343     public final void addq(Register dst, Register src) {
3344         ADD.rmOp.emit(this, QWORD, dst, src);
3345     }
3346 
3347     public final void addq(AMD64Address dst, Register src) {
3348         ADD.mrOp.emit(this, QWORD, dst, src);
3349     }
3350 
3351     public final void andq(Register dst, int imm32) {
3352         AND.getMIOpcode(QWORD, isByte(imm32)).emit(this, QWORD, dst, imm32);
</pre>
<hr />
<pre>
3429         emitModRM(dst, src);
3430     }
3431 
3432     public final void cvtsi2sdq(Register dst, Register src) {
3433         SSEOp.CVTSI2SD.emit(this, QWORD, dst, src);
3434     }
3435 
3436     public final void cvttsd2siq(Register dst, Register src) {
3437         SSEOp.CVTTSD2SI.emit(this, QWORD, dst, src);
3438     }
3439 
3440     public final void cvttpd2dq(Register dst, Register src) {
3441         assert inRC(XMM, dst) &amp;&amp; inRC(XMM, src);
3442         simdPrefix(dst, Register.None, src, PD, P_0F, false);
3443         emitByte(0xE6);
3444         emitModRM(dst, src);
3445     }
3446 
3447     public final void decq(Register dst) {
3448         // Use two-byte form (one-byte form is a REX prefix in 64-bit mode)
<span class="line-modified">3449         DEC.emit(this, QWORD, dst);</span>


3450     }
3451 
3452     public final void decq(AMD64Address dst) {
3453         DEC.emit(this, QWORD, dst);
3454     }
3455 
3456     public final void imulq(Register dst, Register src) {
3457         prefixq(dst, src);
3458         emitByte(0x0F);
3459         emitByte(0xAF);
3460         emitModRM(dst, src);
3461     }
3462 
3463     public final void incq(Register dst) {
3464         // Don&#39;t use it directly. Use Macroincrementq() instead.
3465         // Use two-byte form (one-byte from is a REX prefix in 64-bit mode)
<span class="line-modified">3466         INC.emit(this, QWORD, dst);</span>


3467     }
3468 
3469     public final void incq(AMD64Address dst) {
3470         INC.emit(this, QWORD, dst);
3471     }
3472 
3473     public final void movq(Register dst, long imm64) {
3474         movq(dst, imm64, false);
3475     }
3476 
3477     public final void movq(Register dst, long imm64, boolean annotateImm) {
3478         int insnPos = position();
3479         prefixq(dst);
3480         emitByte(0xB8 + encode(dst));
3481         int immPos = position();
3482         emitLong(imm64);
3483         int nextInsnPos = position();
3484         if (annotateImm &amp;&amp; codePatchingAnnotationConsumer != null) {
3485             codePatchingAnnotationConsumer.accept(new OperandDataAnnotation(insnPos, immPos, nextInsnPos - immPos, nextInsnPos));
3486         }
</pre>
<hr />
<pre>
3644     }
3645 
3646     public final void subq(Register dst, int imm32) {
3647         SUB.getMIOpcode(QWORD, isByte(imm32)).emit(this, QWORD, dst, imm32);
3648     }
3649 
3650     public final void subq(AMD64Address dst, int imm32) {
3651         SUB.getMIOpcode(QWORD, isByte(imm32)).emit(this, QWORD, dst, imm32);
3652     }
3653 
3654     public final void subqWide(Register dst, int imm32) {
3655         // don&#39;t use the sign-extending version, forcing a 32-bit immediate
3656         SUB.getMIOpcode(QWORD, false).emit(this, QWORD, dst, imm32);
3657     }
3658 
3659     public final void subq(Register dst, Register src) {
3660         SUB.rmOp.emit(this, QWORD, dst, src);
3661     }
3662 
3663     public final void testq(Register dst, Register src) {
<span class="line-modified">3664         AMD64RMOp.TEST.emit(this, QWORD, dst, src);</span>


3665     }
3666 
3667     public final void btrq(Register src, int imm8) {
3668         prefixq(src);
3669         emitByte(0x0F);
3670         emitByte(0xBA);
3671         emitModRM(6, src);
3672         emitByte(imm8);
3673     }
3674 
3675     public final void xaddb(AMD64Address dst, Register src) {
3676         prefixb(dst, src);
3677         emitByte(0x0F);
3678         emitByte(0xC0);
3679         emitOperandHelper(src, dst, 0);
3680     }
3681 
3682     public final void xaddw(AMD64Address dst, Register src) {
3683         emitByte(0x66); // Switch to 16-bit mode.
3684         prefix(dst, src);
</pre>
<hr />
<pre>
4120 
4121     // Insn: KTESTD k1, k2
4122 
4123     public final void ktestd(Register src1, Register src2) {
4124         assert supports(CPUFeature.AVX512BW);
4125         assert inRC(MASK, src1) &amp;&amp; inRC(MASK, src2);
4126         // Code: VEX.L0.66.0F.W1 99 /r
4127         vexPrefix(src1, Register.None, src2, AVXSize.XMM, P_66, M_0F, W1, W1, true);
4128         emitByte(0x99);
4129         emitModRM(src1, src2);
4130     }
4131 
4132     public final void evmovdqu64(Register dst, AMD64Address src) {
4133         assert supports(CPUFeature.AVX512F);
4134         assert inRC(XMM, dst);
4135         evexPrefix(dst, Register.None, Register.None, src, AVXSize.ZMM, P_F3, M_0F, W1, Z0, B0);
4136         emitByte(0x6F);
4137         emitOperandHelper(dst, src, 0, EVEXTuple.FVM.getDisp8ScalingFactor(AVXSize.ZMM));
4138     }
4139 
<span class="line-added">4140     public final void evmovdqu64(AMD64Address dst, Register src) {</span>
<span class="line-added">4141         assert supports(CPUFeature.AVX512F);</span>
<span class="line-added">4142         assert inRC(XMM, src);</span>
<span class="line-added">4143         evexPrefix(src, Register.None, Register.None, dst, AVXSize.ZMM, P_F3, M_0F, W1, Z0, B0);</span>
<span class="line-added">4144         emitByte(0x7F);</span>
<span class="line-added">4145         emitOperandHelper(src, dst, 0, EVEXTuple.FVM.getDisp8ScalingFactor(AVXSize.ZMM));</span>
<span class="line-added">4146     }</span>
<span class="line-added">4147 </span>
4148     // Insn: VPMOVZXBW zmm1, m256
4149 
4150     public final void evpmovzxbw(Register dst, AMD64Address src) {
4151         assert supports(CPUFeature.AVX512BW);
4152         assert inRC(XMM, dst);
4153         // Code: EVEX.512.66.0F38.WIG 30 /r
4154         evexPrefix(dst, Register.None, Register.None, src, AVXSize.ZMM, P_66, M_0F38, WIG, Z0, B0);
4155         emitByte(0x30);
4156         emitOperandHelper(dst, src, 0, EVEXTuple.HVM.getDisp8ScalingFactor(AVXSize.ZMM));
4157     }
4158 
4159     public final void evpcmpeqb(Register kdst, Register nds, AMD64Address src) {
4160         assert supports(CPUFeature.AVX512BW);
4161         assert inRC(MASK, kdst) &amp;&amp; inRC(XMM, nds);
4162         evexPrefix(kdst, Register.None, nds, src, AVXSize.ZMM, P_66, M_0F, WIG, Z0, B0);
4163         emitByte(0x74);
4164         emitOperandHelper(kdst, src, 0, EVEXTuple.FVM.getDisp8ScalingFactor(AVXSize.ZMM));
4165     }
4166 
4167     // Insn: VMOVDQU16 zmm1 {k1}{z}, zmm2/m512
</pre>
</td>
</tr>
</table>
<center><a href="AMD64Address.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64BaseAssembler.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
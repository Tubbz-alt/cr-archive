<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacAppImageBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.incubator.jpackage.internal;
 27 
 28 import java.io.File;
 29 import java.io.FileInputStream;
 30 import java.io.IOException;
 31 import java.io.InputStream;
 32 import java.io.Writer;
 33 import java.math.BigInteger;
 34 import java.nio.file.Files;
 35 import java.nio.file.Path;
 36 import java.nio.file.StandardCopyOption;
 37 import java.nio.file.attribute.PosixFilePermission;
 38 import java.text.MessageFormat;
 39 import java.util.ArrayList;
 40 import java.util.Arrays;
 41 import java.util.EnumSet;
 42 import java.util.HashMap;
 43 import java.util.List;
 44 import java.util.Map;
 45 import java.util.Objects;
 46 import java.util.Optional;
 47 import java.util.ResourceBundle;
 48 import java.util.Set;
 49 import java.util.concurrent.atomic.AtomicReference;
 50 import java.util.function.Consumer;
 51 import java.util.stream.Stream;
 52 import javax.xml.parsers.DocumentBuilder;
 53 import javax.xml.parsers.DocumentBuilderFactory;
 54 import javax.xml.xpath.XPath;
 55 import javax.xml.xpath.XPathConstants;
 56 import javax.xml.xpath.XPathFactory;
 57 
 58 import static jdk.incubator.jpackage.internal.StandardBundlerParam.*;
 59 import static jdk.incubator.jpackage.internal.MacBaseInstallerBundler.*;
 60 import static jdk.incubator.jpackage.internal.MacAppBundler.*;
 61 import static jdk.incubator.jpackage.internal.OverridableResource.createResource;
 62 
 63 public class MacAppImageBuilder extends AbstractAppImageBuilder {
 64 
 65     private static final ResourceBundle I18N = ResourceBundle.getBundle(
 66             &quot;jdk.incubator.jpackage.internal.resources.MacResources&quot;);
 67 
 68     private static final String LIBRARY_NAME = &quot;libapplauncher.dylib&quot;;
 69     private static final String TEMPLATE_BUNDLE_ICON = &quot;java.icns&quot;;
 70     private static final String OS_TYPE_CODE = &quot;APPL&quot;;
 71     private static final String TEMPLATE_INFO_PLIST_LITE =
 72             &quot;Info-lite.plist.template&quot;;
 73     private static final String TEMPLATE_RUNTIME_INFO_PLIST =
 74             &quot;Runtime-Info.plist.template&quot;;
 75 
 76     private final Path root;
 77     private final Path contentsDir;
 78     private final Path appDir;
 79     private final Path javaModsDir;
 80     private final Path resourcesDir;
 81     private final Path macOSDir;
 82     private final Path runtimeDir;
 83     private final Path runtimeRoot;
 84     private final Path mdir;
 85 
 86     private static List&lt;String&gt; keyChains;
 87 
 88     public static final BundlerParamInfo&lt;Boolean&gt;
 89             MAC_CONFIGURE_LAUNCHER_IN_PLIST = new StandardBundlerParam&lt;&gt;(
 90                     &quot;mac.configure-launcher-in-plist&quot;,
 91                     Boolean.class,
 92                     params -&gt; Boolean.FALSE,
 93                     (s, p) -&gt; Boolean.valueOf(s));
 94 
 95     public static final BundlerParamInfo&lt;String&gt; MAC_CF_BUNDLE_NAME =
 96             new StandardBundlerParam&lt;&gt;(
 97                     Arguments.CLIOptions.MAC_BUNDLE_NAME.getId(),
 98                     String.class,
 99                     params -&gt; null,
100                     (s, p) -&gt; s);
101 
102     public static final BundlerParamInfo&lt;String&gt; MAC_CF_BUNDLE_IDENTIFIER =
103             new StandardBundlerParam&lt;&gt;(
104                     Arguments.CLIOptions.MAC_BUNDLE_IDENTIFIER.getId(),
105                     String.class,
106                     params -&gt; {
107                         // Get identifier from app image if user provided
108                         // app image and did not provide the identifier via CLI.
109                         String identifier = extractBundleIdentifier(params);
110                         if (identifier != null) {
111                             return identifier;
112                         }
113 
<a name="1" id="anc1"></a><span class="line-modified">114                         return IDENTIFIER.fetchFrom(params);</span>








115                     },
116                     (s, p) -&gt; s);
117 
118     public static final BundlerParamInfo&lt;String&gt; MAC_CF_BUNDLE_VERSION =
119             new StandardBundlerParam&lt;&gt;(
120                     &quot;mac.CFBundleVersion&quot;,
121                     String.class,
122                     p -&gt; {
123                         String s = VERSION.fetchFrom(p);
124                         if (validCFBundleVersion(s)) {
125                             return s;
126                         } else {
127                             return &quot;100&quot;;
128                         }
129                     },
130                     (s, p) -&gt; s);
131 
132     public static final BundlerParamInfo&lt;File&gt; ICON_ICNS =
133             new StandardBundlerParam&lt;&gt;(
134             &quot;icon.icns&quot;,
135             File.class,
136             params -&gt; {
137                 File f = ICON.fetchFrom(params);
138                 if (f != null &amp;&amp; !f.getName().toLowerCase().endsWith(&quot;.icns&quot;)) {
139                     Log.error(MessageFormat.format(
140                             I18N.getString(&quot;message.icon-not-icns&quot;), f));
141                     return null;
142                 }
143                 return f;
144             },
145             (s, p) -&gt; new File(s));
146 
147     public static final StandardBundlerParam&lt;Boolean&gt; SIGN_BUNDLE  =
148             new StandardBundlerParam&lt;&gt;(
149             Arguments.CLIOptions.MAC_SIGN.getId(),
150             Boolean.class,
151             params -&gt; false,
152             // valueOf(null) is false, we actually do want null in some cases
153             (s, p) -&gt; (s == null || &quot;null&quot;.equalsIgnoreCase(s)) ?
154                     null : Boolean.valueOf(s)
155         );
156 
157     public MacAppImageBuilder(Map&lt;String, Object&gt; params, Path imageOutDir)
158             throws IOException {
159         super(params, imageOutDir.resolve(APP_NAME.fetchFrom(params)
160                 + &quot;.app/Contents/runtime/Contents/Home&quot;));
161 
162         Objects.requireNonNull(imageOutDir);
163 
164         this.root = imageOutDir.resolve(APP_NAME.fetchFrom(params) + &quot;.app&quot;);
165         this.contentsDir = root.resolve(&quot;Contents&quot;);
166         this.appDir = contentsDir.resolve(&quot;app&quot;);
167         this.javaModsDir = appDir.resolve(&quot;mods&quot;);
168         this.resourcesDir = contentsDir.resolve(&quot;Resources&quot;);
169         this.macOSDir = contentsDir.resolve(&quot;MacOS&quot;);
170         this.runtimeDir = contentsDir.resolve(&quot;runtime&quot;);
171         this.runtimeRoot = runtimeDir.resolve(&quot;Contents/Home&quot;);
172         this.mdir = runtimeRoot.resolve(&quot;lib&quot;);
173         Files.createDirectories(appDir);
174         Files.createDirectories(resourcesDir);
175         Files.createDirectories(macOSDir);
176         Files.createDirectories(runtimeDir);
177     }
178 
179     private void writeEntry(InputStream in, Path dstFile) throws IOException {
180         Files.createDirectories(dstFile.getParent());
181         Files.copy(in, dstFile);
182     }
183 
184     public static boolean validCFBundleVersion(String v) {
185         // CFBundleVersion (String - iOS, OS X) specifies the build version
186         // number of the bundle, which identifies an iteration (released or
187         // unreleased) of the bundle. The build version number should be a
188         // string comprised of three non-negative, period-separated integers
189         // with the first integer being greater than zero. The string should
190         // only contain numeric (0-9) and period (.) characters. Leading zeros
191         // are truncated from each integer and will be ignored (that is,
192         // 1.02.3 is equivalent to 1.2.3). This key is not localizable.
193 
194         if (v == null) {
195             return false;
196         }
197 
198         String p[] = v.split(&quot;\\.&quot;);
199         if (p.length &gt; 3 || p.length &lt; 1) {
200             Log.verbose(I18N.getString(
201                     &quot;message.version-string-too-many-components&quot;));
202             return false;
203         }
204 
205         try {
206             BigInteger n = new BigInteger(p[0]);
207             if (BigInteger.ONE.compareTo(n) &gt; 0) {
208                 Log.verbose(I18N.getString(
209                         &quot;message.version-string-first-number-not-zero&quot;));
210                 return false;
211             }
212             if (p.length &gt; 1) {
213                 n = new BigInteger(p[1]);
214                 if (BigInteger.ZERO.compareTo(n) &gt; 0) {
215                     Log.verbose(I18N.getString(
216                             &quot;message.version-string-no-negative-numbers&quot;));
217                     return false;
218                 }
219             }
220             if (p.length &gt; 2) {
221                 n = new BigInteger(p[2]);
222                 if (BigInteger.ZERO.compareTo(n) &gt; 0) {
223                     Log.verbose(I18N.getString(
224                             &quot;message.version-string-no-negative-numbers&quot;));
225                     return false;
226                 }
227             }
228         } catch (NumberFormatException ne) {
229             Log.verbose(I18N.getString(&quot;message.version-string-numbers-only&quot;));
230             Log.verbose(ne);
231             return false;
232         }
233 
234         return true;
235     }
236 
237     @Override
238     public Path getAppDir() {
239         return appDir;
240     }
241 
242     @Override
243     public Path getAppModsDir() {
244         return javaModsDir;
245     }
246 
247     @Override
248     public void prepareApplicationFiles(Map&lt;String, ? super Object&gt; params)
249             throws IOException {
250         Map&lt;String, ? super Object&gt; originalParams = new HashMap&lt;&gt;(params);
251         // Generate PkgInfo
252         File pkgInfoFile = new File(contentsDir.toFile(), &quot;PkgInfo&quot;);
253         pkgInfoFile.createNewFile();
254         writePkgInfo(pkgInfoFile);
255 
256         Path executable = macOSDir.resolve(getLauncherName(params));
257 
258         // create the main app launcher
259         try (InputStream is_launcher =
260                 getResourceAsStream(&quot;jpackageapplauncher&quot;);
261             InputStream is_lib = getResourceAsStream(LIBRARY_NAME)) {
262             // Copy executable and library to MacOS folder
263             writeEntry(is_launcher, executable);
264             writeEntry(is_lib, macOSDir.resolve(LIBRARY_NAME));
265         }
266         executable.toFile().setExecutable(true, false);
267         // generate main app launcher config file
268         File cfg = new File(root.toFile(), getLauncherCfgName(params));
269         writeCfgFile(params, cfg);
270 
271         // create additional app launcher(s) and config file(s)
272         List&lt;Map&lt;String, ? super Object&gt;&gt; entryPoints =
273                 StandardBundlerParam.ADD_LAUNCHERS.fetchFrom(params);
274         for (Map&lt;String, ? super Object&gt; entryPoint : entryPoints) {
275             Map&lt;String, ? super Object&gt; tmp =
276                     AddLauncherArguments.merge(originalParams, entryPoint);
277 
278             // add executable for add launcher
279             Path addExecutable = macOSDir.resolve(getLauncherName(tmp));
280             try (InputStream is = getResourceAsStream(&quot;jpackageapplauncher&quot;);) {
281                 writeEntry(is, addExecutable);
282             }
283             addExecutable.toFile().setExecutable(true, false);
284 
285             // add config file for add launcher
286             cfg = new File(root.toFile(), getLauncherCfgName(tmp));
287             writeCfgFile(tmp, cfg);
288         }
289 
290         // Copy class path entries to Java folder
291         copyClassPathEntries(appDir, params);
292 
293         /*********** Take care of &quot;config&quot; files *******/
294 
295         createResource(TEMPLATE_BUNDLE_ICON, params)
296                 .setCategory(&quot;icon&quot;)
297                 .setExternal(ICON_ICNS.fetchFrom(params))
298                 .saveToFile(resourcesDir.resolve(APP_NAME.fetchFrom(params)
299                         + &quot;.icns&quot;));
300 
301         // copy file association icons
302         for (Map&lt;String, ?
303                 super Object&gt; fa : FILE_ASSOCIATIONS.fetchFrom(params)) {
304             File f = FA_ICON.fetchFrom(fa);
305             if (f != null &amp;&amp; f.exists()) {
306                 try (InputStream in2 = new FileInputStream(f)) {
307                     Files.copy(in2, resourcesDir.resolve(f.getName()));
308                 }
309 
310             }
311         }
312 
313         copyRuntimeFiles(params);
314         sign(params);
315     }
316 
317     @Override
318     public void prepareJreFiles(Map&lt;String, ? super Object&gt; params)
319             throws IOException {
320         copyRuntimeFiles(params);
321         sign(params);
322     }
323 
324     @Override
325     File getRuntimeImageDir(File runtimeImageTop) {
326         File home = new File(runtimeImageTop, &quot;Contents/Home&quot;);
327         return (home.exists() ? home : runtimeImageTop);
328     }
329 
330     private void copyRuntimeFiles(Map&lt;String, ? super Object&gt; params)
331             throws IOException {
332         // Generate Info.plist
333         writeInfoPlist(contentsDir.resolve(&quot;Info.plist&quot;).toFile(), params);
334 
335         // generate java runtime info.plist
336         writeRuntimeInfoPlist(
337                 runtimeDir.resolve(&quot;Contents/Info.plist&quot;).toFile(), params);
338 
339         // copy library
340         Path runtimeMacOSDir = Files.createDirectories(
341                 runtimeDir.resolve(&quot;Contents/MacOS&quot;));
342 
343         // JDK 9, 10, and 11 have extra &#39;/jli/&#39; subdir
344         Path jli = runtimeRoot.resolve(&quot;lib/libjli.dylib&quot;);
345         if (!Files.exists(jli)) {
346             jli = runtimeRoot.resolve(&quot;lib/jli/libjli.dylib&quot;);
347         }
348 
349         Files.copy(jli, runtimeMacOSDir.resolve(&quot;libjli.dylib&quot;));
350     }
351 
352     private void sign(Map&lt;String, ? super Object&gt; params) throws IOException {
353         if (Optional.ofNullable(
354                 SIGN_BUNDLE.fetchFrom(params)).orElse(Boolean.TRUE)) {
355             try {
356                 addNewKeychain(params);
357             } catch (InterruptedException e) {
358                 Log.error(e.getMessage());
359             }
360             String signingIdentity =
361                     DEVELOPER_ID_APP_SIGNING_KEY.fetchFrom(params);
362             if (signingIdentity != null) {
363                 signAppBundle(params, root, signingIdentity,
364                         BUNDLE_ID_SIGNING_PREFIX.fetchFrom(params), null, null);
365             }
366             restoreKeychainList(params);
367         }
368     }
369 
370     private String getLauncherName(Map&lt;String, ? super Object&gt; params) {
371         if (APP_NAME.fetchFrom(params) != null) {
372             return APP_NAME.fetchFrom(params);
373         } else {
374             return MAIN_CLASS.fetchFrom(params);
375         }
376     }
377 
378     public static String getLauncherCfgName(
379             Map&lt;String, ? super Object&gt; params) {
380         return &quot;Contents/app/&quot; + APP_NAME.fetchFrom(params) + &quot;.cfg&quot;;
381     }
382 
383     private void copyClassPathEntries(Path javaDirectory,
384             Map&lt;String, ? super Object&gt; params) throws IOException {
385         List&lt;RelativeFileSet&gt; resourcesList =
386                 APP_RESOURCES_LIST.fetchFrom(params);
387         if (resourcesList == null) {
388             throw new RuntimeException(
389                     I18N.getString(&quot;message.null-classpath&quot;));
390         }
391 
392         for (RelativeFileSet classPath : resourcesList) {
393             File srcdir = classPath.getBaseDirectory();
394             for (String fname : classPath.getIncludedFiles()) {
395                 copyEntry(javaDirectory, srcdir, fname);
396             }
397         }
398     }
399 
400     private String getBundleName(Map&lt;String, ? super Object&gt; params) {
401         if (MAC_CF_BUNDLE_NAME.fetchFrom(params) != null) {
402             String bn = MAC_CF_BUNDLE_NAME.fetchFrom(params);
403             if (bn.length() &gt; 16) {
404                 Log.error(MessageFormat.format(I18N.getString(
405                         &quot;message.bundle-name-too-long-warning&quot;),
406                         MAC_CF_BUNDLE_NAME.getID(), bn));
407             }
408             return MAC_CF_BUNDLE_NAME.fetchFrom(params);
409         } else if (APP_NAME.fetchFrom(params) != null) {
410             return APP_NAME.fetchFrom(params);
411         } else {
412             String nm = MAIN_CLASS.fetchFrom(params);
413             if (nm.length() &gt; 16) {
414                 nm = nm.substring(0, 16);
415             }
416             return nm;
417         }
418     }
419 
420     private void writeRuntimeInfoPlist(File file,
421             Map&lt;String, ? super Object&gt; params) throws IOException {
422         Map&lt;String, String&gt; data = new HashMap&lt;&gt;();
423         String identifier = StandardBundlerParam.isRuntimeInstaller(params) ?
424                 MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params) :
425                 &quot;com.oracle.java.&quot; + MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params);
426         data.put(&quot;CF_BUNDLE_IDENTIFIER&quot;, identifier);
427         String name = StandardBundlerParam.isRuntimeInstaller(params) ?
428                 getBundleName(params): &quot;Java Runtime Image&quot;;
429         data.put(&quot;CF_BUNDLE_NAME&quot;, name);
430         data.put(&quot;CF_BUNDLE_VERSION&quot;, VERSION.fetchFrom(params));
431         data.put(&quot;CF_BUNDLE_SHORT_VERSION_STRING&quot;, VERSION.fetchFrom(params));
432 
433         createResource(TEMPLATE_RUNTIME_INFO_PLIST, params)
434                 .setPublicName(&quot;Runtime-Info.plist&quot;)
435                 .setCategory(I18N.getString(&quot;resource.runtime-info-plist&quot;))
436                 .setSubstitutionData(data)
437                 .saveToFile(file);
438     }
439 
440     private void writeInfoPlist(File file, Map&lt;String, ? super Object&gt; params)
441             throws IOException {
442         Log.verbose(MessageFormat.format(I18N.getString(
443                 &quot;message.preparing-info-plist&quot;), file.getAbsolutePath()));
444 
445         //prepare config for exe
446         //Note: do not need CFBundleDisplayName if we don&#39;t support localization
447         Map&lt;String, String&gt; data = new HashMap&lt;&gt;();
448         data.put(&quot;DEPLOY_ICON_FILE&quot;, APP_NAME.fetchFrom(params) + &quot;.icns&quot;);
449         data.put(&quot;DEPLOY_BUNDLE_IDENTIFIER&quot;,
450                 MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params));
451         data.put(&quot;DEPLOY_BUNDLE_NAME&quot;,
452                 getBundleName(params));
453         data.put(&quot;DEPLOY_BUNDLE_COPYRIGHT&quot;,
454                 COPYRIGHT.fetchFrom(params) != null ?
455                 COPYRIGHT.fetchFrom(params) : &quot;Unknown&quot;);
456         data.put(&quot;DEPLOY_LAUNCHER_NAME&quot;, getLauncherName(params));
457         data.put(&quot;DEPLOY_BUNDLE_SHORT_VERSION&quot;,
458                 VERSION.fetchFrom(params) != null ?
459                 VERSION.fetchFrom(params) : &quot;1.0.0&quot;);
460         data.put(&quot;DEPLOY_BUNDLE_CFBUNDLE_VERSION&quot;,
461                 MAC_CF_BUNDLE_VERSION.fetchFrom(params) != null ?
462                 MAC_CF_BUNDLE_VERSION.fetchFrom(params) : &quot;100&quot;);
463 
464         boolean hasMainJar = MAIN_JAR.fetchFrom(params) != null;
465         boolean hasMainModule =
466                 StandardBundlerParam.MODULE.fetchFrom(params) != null;
467 
468         if (hasMainJar) {
469             data.put(&quot;DEPLOY_MAIN_JAR_NAME&quot;, MAIN_JAR.fetchFrom(params).
470                     getIncludedFiles().iterator().next());
471         }
472         else if (hasMainModule) {
473             data.put(&quot;DEPLOY_MODULE_NAME&quot;,
474                     StandardBundlerParam.MODULE.fetchFrom(params));
475         }
476 
477         StringBuilder sb = new StringBuilder();
478         List&lt;String&gt; jvmOptions = JAVA_OPTIONS.fetchFrom(params);
479 
480         String newline = &quot;&quot;; //So we don&#39;t add extra line after last append
481         for (String o : jvmOptions) {
482             sb.append(newline).append(
483                     &quot;    &lt;string&gt;&quot;).append(o).append(&quot;&lt;/string&gt;&quot;);
484             newline = &quot;\n&quot;;
485         }
486 
487         data.put(&quot;DEPLOY_JAVA_OPTIONS&quot;, sb.toString());
488 
489         sb = new StringBuilder();
490         List&lt;String&gt; args = ARGUMENTS.fetchFrom(params);
491         newline = &quot;&quot;;
492         // So we don&#39;t add unneccessary extra line after last append
493 
494         for (String o : args) {
495             sb.append(newline).append(&quot;    &lt;string&gt;&quot;).append(o).append(
496                     &quot;&lt;/string&gt;&quot;);
497             newline = &quot;\n&quot;;
498         }
499         data.put(&quot;DEPLOY_ARGUMENTS&quot;, sb.toString());
500 
501         newline = &quot;&quot;;
502 
503         data.put(&quot;DEPLOY_LAUNCHER_CLASS&quot;, MAIN_CLASS.fetchFrom(params));
504 
505         data.put(&quot;DEPLOY_APP_CLASSPATH&quot;,
506                   getCfgClassPath(CLASSPATH.fetchFrom(params)));
507 
508         StringBuilder bundleDocumentTypes = new StringBuilder();
509         StringBuilder exportedTypes = new StringBuilder();
510         for (Map&lt;String, ? super Object&gt;
511                 fileAssociation : FILE_ASSOCIATIONS.fetchFrom(params)) {
512 
513             List&lt;String&gt; extensions = FA_EXTENSIONS.fetchFrom(fileAssociation);
514 
515             if (extensions == null) {
516                 Log.verbose(I18N.getString(
517                         &quot;message.creating-association-with-null-extension&quot;));
518             }
519 
520             List&lt;String&gt; mimeTypes = FA_CONTENT_TYPE.fetchFrom(fileAssociation);
521             String itemContentType = MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params)
522                     + &quot;.&quot; + ((extensions == null || extensions.isEmpty())
523                     ? &quot;mime&quot; : extensions.get(0));
524             String description = FA_DESCRIPTION.fetchFrom(fileAssociation);
525             File icon = FA_ICON.fetchFrom(fileAssociation);
526 
527             bundleDocumentTypes.append(&quot;    &lt;dict&gt;\n&quot;)
528                     .append(&quot;      &lt;key&gt;LSItemContentTypes&lt;/key&gt;\n&quot;)
529                     .append(&quot;      &lt;array&gt;\n&quot;)
530                     .append(&quot;        &lt;string&gt;&quot;)
531                     .append(itemContentType)
532                     .append(&quot;&lt;/string&gt;\n&quot;)
533                     .append(&quot;      &lt;/array&gt;\n&quot;)
534                     .append(&quot;\n&quot;)
535                     .append(&quot;      &lt;key&gt;CFBundleTypeName&lt;/key&gt;\n&quot;)
536                     .append(&quot;      &lt;string&gt;&quot;)
537                     .append(description)
538                     .append(&quot;&lt;/string&gt;\n&quot;)
539                     .append(&quot;\n&quot;)
540                     .append(&quot;      &lt;key&gt;LSHandlerRank&lt;/key&gt;\n&quot;)
541                     .append(&quot;      &lt;string&gt;Owner&lt;/string&gt;\n&quot;)
542                             // TODO make a bundler arg
543                     .append(&quot;\n&quot;)
544                     .append(&quot;      &lt;key&gt;CFBundleTypeRole&lt;/key&gt;\n&quot;)
545                     .append(&quot;      &lt;string&gt;Editor&lt;/string&gt;\n&quot;)
546                             // TODO make a bundler arg
547                     .append(&quot;\n&quot;)
548                     .append(&quot;      &lt;key&gt;LSIsAppleDefaultForType&lt;/key&gt;\n&quot;)
549                     .append(&quot;      &lt;true/&gt;\n&quot;)
550                             // TODO make a bundler arg
551                     .append(&quot;\n&quot;);
552 
553             if (icon != null &amp;&amp; icon.exists()) {
554                 bundleDocumentTypes
555                         .append(&quot;      &lt;key&gt;CFBundleTypeIconFile&lt;/key&gt;\n&quot;)
556                         .append(&quot;      &lt;string&gt;&quot;)
557                         .append(icon.getName())
558                         .append(&quot;&lt;/string&gt;\n&quot;);
559             }
560             bundleDocumentTypes.append(&quot;    &lt;/dict&gt;\n&quot;);
561 
562             exportedTypes.append(&quot;    &lt;dict&gt;\n&quot;)
563                     .append(&quot;      &lt;key&gt;UTTypeIdentifier&lt;/key&gt;\n&quot;)
564                     .append(&quot;      &lt;string&gt;&quot;)
565                     .append(itemContentType)
566                     .append(&quot;&lt;/string&gt;\n&quot;)
567                     .append(&quot;\n&quot;)
568                     .append(&quot;      &lt;key&gt;UTTypeDescription&lt;/key&gt;\n&quot;)
569                     .append(&quot;      &lt;string&gt;&quot;)
570                     .append(description)
571                     .append(&quot;&lt;/string&gt;\n&quot;)
572                     .append(&quot;      &lt;key&gt;UTTypeConformsTo&lt;/key&gt;\n&quot;)
573                     .append(&quot;      &lt;array&gt;\n&quot;)
574                     .append(&quot;          &lt;string&gt;public.data&lt;/string&gt;\n&quot;)
575                             //TODO expose this?
576                     .append(&quot;      &lt;/array&gt;\n&quot;)
577                     .append(&quot;\n&quot;);
578 
579             if (icon != null &amp;&amp; icon.exists()) {
580                 exportedTypes.append(&quot;      &lt;key&gt;UTTypeIconFile&lt;/key&gt;\n&quot;)
581                         .append(&quot;      &lt;string&gt;&quot;)
582                         .append(icon.getName())
583                         .append(&quot;&lt;/string&gt;\n&quot;)
584                         .append(&quot;\n&quot;);
585             }
586 
587             exportedTypes.append(&quot;\n&quot;)
588                     .append(&quot;      &lt;key&gt;UTTypeTagSpecification&lt;/key&gt;\n&quot;)
589                     .append(&quot;      &lt;dict&gt;\n&quot;)
590                             // TODO expose via param? .append(
591                             // &quot;        &lt;key&gt;com.apple.ostype&lt;/key&gt;\n&quot;);
592                             // TODO expose via param? .append(
593                             // &quot;        &lt;string&gt;ABCD&lt;/string&gt;\n&quot;)
594                     .append(&quot;\n&quot;);
595 
596             if (extensions != null &amp;&amp; !extensions.isEmpty()) {
597                 exportedTypes.append(
598                         &quot;        &lt;key&gt;public.filename-extension&lt;/key&gt;\n&quot;)
599                         .append(&quot;        &lt;array&gt;\n&quot;);
600 
601                 for (String ext : extensions) {
602                     exportedTypes.append(&quot;          &lt;string&gt;&quot;)
603                             .append(ext)
604                             .append(&quot;&lt;/string&gt;\n&quot;);
605                 }
606                 exportedTypes.append(&quot;        &lt;/array&gt;\n&quot;);
607             }
608             if (mimeTypes != null &amp;&amp; !mimeTypes.isEmpty()) {
609                 exportedTypes.append(&quot;        &lt;key&gt;public.mime-type&lt;/key&gt;\n&quot;)
610                         .append(&quot;        &lt;array&gt;\n&quot;);
611 
612                 for (String mime : mimeTypes) {
613                     exportedTypes.append(&quot;          &lt;string&gt;&quot;)
614                             .append(mime)
615                             .append(&quot;&lt;/string&gt;\n&quot;);
616                 }
617                 exportedTypes.append(&quot;        &lt;/array&gt;\n&quot;);
618             }
619             exportedTypes.append(&quot;      &lt;/dict&gt;\n&quot;)
620                     .append(&quot;    &lt;/dict&gt;\n&quot;);
621         }
622         String associationData;
623         if (bundleDocumentTypes.length() &gt; 0) {
624             associationData =
625                     &quot;\n  &lt;key&gt;CFBundleDocumentTypes&lt;/key&gt;\n  &lt;array&gt;\n&quot;
626                     + bundleDocumentTypes.toString()
627                     + &quot;  &lt;/array&gt;\n\n&quot;
628                     + &quot;  &lt;key&gt;UTExportedTypeDeclarations&lt;/key&gt;\n  &lt;array&gt;\n&quot;
629                     + exportedTypes.toString()
630                     + &quot;  &lt;/array&gt;\n&quot;;
631         } else {
632             associationData = &quot;&quot;;
633         }
634         data.put(&quot;DEPLOY_FILE_ASSOCIATIONS&quot;, associationData);
635 
636         createResource(TEMPLATE_INFO_PLIST_LITE, params)
637                 .setCategory(I18N.getString(&quot;resource.app-info-plist&quot;))
638                 .setSubstitutionData(data)
639                 .setPublicName(&quot;Info.plist&quot;)
640                 .saveToFile(file);
641     }
642 
643     private void writePkgInfo(File file) throws IOException {
644         //hardcoded as it does not seem we need to change it ever
645         String signature = &quot;????&quot;;
646 
647         try (Writer out = Files.newBufferedWriter(file.toPath())) {
648             out.write(OS_TYPE_CODE + signature);
649             out.flush();
650         }
651     }
652 
653     public static void addNewKeychain(Map&lt;String, ? super Object&gt; params)
654                                     throws IOException, InterruptedException {
655         if (Platform.getMajorVersion() &lt; 10 ||
656                 (Platform.getMajorVersion() == 10 &amp;&amp;
657                 Platform.getMinorVersion() &lt; 12)) {
658             // we need this for OS X 10.12+
659             return;
660         }
661 
662         String keyChain = SIGNING_KEYCHAIN.fetchFrom(params);
663         if (keyChain == null || keyChain.isEmpty()) {
664             return;
665         }
666 
667         // get current keychain list
668         String keyChainPath = new File (keyChain).getAbsolutePath().toString();
669         List&lt;String&gt; keychainList = new ArrayList&lt;&gt;();
670         int ret = IOUtils.getProcessOutput(
671                 keychainList, &quot;security&quot;, &quot;list-keychains&quot;);
672         if (ret != 0) {
673             Log.error(I18N.getString(&quot;message.keychain.error&quot;));
674             return;
675         }
676 
677         boolean contains = keychainList.stream().anyMatch(
678                     str -&gt; str.trim().equals(&quot;\&quot;&quot;+keyChainPath.trim()+&quot;\&quot;&quot;));
679         if (contains) {
680             // keychain is already added in the search list
681             return;
682         }
683 
684         keyChains = new ArrayList&lt;&gt;();
685         // remove &quot;
686         keychainList.forEach((String s) -&gt; {
687             String path = s.trim();
688             if (path.startsWith(&quot;\&quot;&quot;) &amp;&amp; path.endsWith(&quot;\&quot;&quot;)) {
689                 path = path.substring(1, path.length()-1);
690             }
691             keyChains.add(path);
692         });
693 
694         List&lt;String&gt; args = new ArrayList&lt;&gt;();
695         args.add(&quot;security&quot;);
696         args.add(&quot;list-keychains&quot;);
697         args.add(&quot;-s&quot;);
698 
699         args.addAll(keyChains);
700         args.add(keyChain);
701 
702         ProcessBuilder  pb = new ProcessBuilder(args);
703         IOUtils.exec(pb);
704     }
705 
706     public static void restoreKeychainList(Map&lt;String, ? super Object&gt; params)
707             throws IOException{
708         if (Platform.getMajorVersion() &lt; 10 ||
709                 (Platform.getMajorVersion() == 10 &amp;&amp;
710                 Platform.getMinorVersion() &lt; 12)) {
711             // we need this for OS X 10.12+
712             return;
713         }
714 
715         if (keyChains == null || keyChains.isEmpty()) {
716             return;
717         }
718 
719         List&lt;String&gt; args = new ArrayList&lt;&gt;();
720         args.add(&quot;security&quot;);
721         args.add(&quot;list-keychains&quot;);
722         args.add(&quot;-s&quot;);
723 
724         args.addAll(keyChains);
725 
726         ProcessBuilder  pb = new ProcessBuilder(args);
727         IOUtils.exec(pb);
728     }
729 
730     public static void signAppBundle(
731             Map&lt;String, ? super Object&gt; params, Path appLocation,
732             String signingIdentity, String identifierPrefix,
733             String entitlementsFile, String inheritedEntitlements)
734             throws IOException {
735         AtomicReference&lt;IOException&gt; toThrow = new AtomicReference&lt;&gt;();
736         String appExecutable = &quot;/Contents/MacOS/&quot; + APP_NAME.fetchFrom(params);
737         String keyChain = SIGNING_KEYCHAIN.fetchFrom(params);
738 
739         // sign all dylibs and jars
740         try (Stream&lt;Path&gt; stream = Files.walk(appLocation)) {
741             stream.peek(path -&gt; { // fix permissions
742                 try {
743                     Set&lt;PosixFilePermission&gt; pfp =
744                             Files.getPosixFilePermissions(path);
745                     if (!pfp.contains(PosixFilePermission.OWNER_WRITE)) {
746                         pfp = EnumSet.copyOf(pfp);
747                         pfp.add(PosixFilePermission.OWNER_WRITE);
748                         Files.setPosixFilePermissions(path, pfp);
749                     }
750                 } catch (IOException e) {
751                     Log.verbose(e);
752                 }
753             }).filter(p -&gt; Files.isRegularFile(p)
754                       &amp;&amp; !(p.toString().contains(&quot;/Contents/MacOS/libjli.dylib&quot;)
755                       || p.toString().endsWith(appExecutable)
756                       || p.toString().contains(&quot;/Contents/runtime&quot;)
757                       || p.toString().contains(&quot;/Contents/Frameworks&quot;))).forEach(p -&gt; {
758                 //noinspection ThrowableResultOfMethodCallIgnored
759                 if (toThrow.get() != null) return;
760 
761                 // If p is a symlink then skip the signing process.
762                 if (Files.isSymbolicLink(p)) {
763                     if (VERBOSE.fetchFrom(params)) {
764                         Log.verbose(MessageFormat.format(I18N.getString(
765                                 &quot;message.ignoring.symlink&quot;), p.toString()));
766                     }
767                 } else {
768                     if (p.toString().endsWith(LIBRARY_NAME)) {
769                         if (isFileSigned(p)) {
770                             return;
771                         }
772                     }
773 
774                     List&lt;String&gt; args = new ArrayList&lt;&gt;();
775                     args.addAll(Arrays.asList(&quot;codesign&quot;,
776                             &quot;-s&quot;, signingIdentity, // sign with this key
777                             &quot;--prefix&quot;, identifierPrefix,
778                             // use the identifier as a prefix
779                             &quot;-vvvv&quot;));
780                     if (entitlementsFile != null &amp;&amp;
781                             (p.toString().endsWith(&quot;.jar&quot;)
782                             || p.toString().endsWith(&quot;.dylib&quot;))) {
783                         args.add(&quot;--entitlements&quot;);
784                         args.add(entitlementsFile); // entitlements
785                     } else if (inheritedEntitlements != null &amp;&amp;
786                             Files.isExecutable(p)) {
787                         args.add(&quot;--entitlements&quot;);
788                         args.add(inheritedEntitlements);
789                         // inherited entitlements for executable processes
790                     }
791                     if (keyChain != null &amp;&amp; !keyChain.isEmpty()) {
792                         args.add(&quot;--keychain&quot;);
793                         args.add(keyChain);
794                     }
795                     args.add(p.toString());
796 
797                     try {
798                         Set&lt;PosixFilePermission&gt; oldPermissions =
799                                 Files.getPosixFilePermissions(p);
800                         File f = p.toFile();
801                         f.setWritable(true, true);
802 
803                         ProcessBuilder pb = new ProcessBuilder(args);
804                         IOUtils.exec(pb);
805 
806                         Files.setPosixFilePermissions(p, oldPermissions);
807                     } catch (IOException ioe) {
808                         toThrow.set(ioe);
809                     }
810                 }
811             });
812         }
813         IOException ioe = toThrow.get();
814         if (ioe != null) {
815             throw ioe;
816         }
817 
818         // sign all runtime and frameworks
819         Consumer&lt;? super Path&gt; signIdentifiedByPList = path -&gt; {
820             //noinspection ThrowableResultOfMethodCallIgnored
821             if (toThrow.get() != null) return;
822 
823             try {
824                 List&lt;String&gt; args = new ArrayList&lt;&gt;();
825                 args.addAll(Arrays.asList(&quot;codesign&quot;,
826                         &quot;-f&quot;,
827                         &quot;-s&quot;, signingIdentity, // sign with this key
828                         &quot;--prefix&quot;, identifierPrefix,
829                         // use the identifier as a prefix
830                         &quot;-vvvv&quot;));
831                 if (keyChain != null &amp;&amp; !keyChain.isEmpty()) {
832                     args.add(&quot;--keychain&quot;);
833                     args.add(keyChain);
834                 }
835                 args.add(path.toString());
836                 ProcessBuilder pb = new ProcessBuilder(args);
837                 IOUtils.exec(pb);
838 
839                 args = new ArrayList&lt;&gt;();
840                 args.addAll(Arrays.asList(&quot;codesign&quot;,
841                         &quot;-s&quot;, signingIdentity, // sign with this key
842                         &quot;--prefix&quot;, identifierPrefix,
843                         // use the identifier as a prefix
844                         &quot;-vvvv&quot;));
845                 if (keyChain != null &amp;&amp; !keyChain.isEmpty()) {
846                     args.add(&quot;--keychain&quot;);
847                     args.add(keyChain);
848                 }
849                 args.add(path.toString()
850                         + &quot;/Contents/_CodeSignature/CodeResources&quot;);
851                 pb = new ProcessBuilder(args);
852                 IOUtils.exec(pb);
853             } catch (IOException e) {
854                 toThrow.set(e);
855             }
856         };
857 
858         Path javaPath = appLocation.resolve(&quot;Contents/runtime&quot;);
859         if (Files.isDirectory(javaPath)) {
860             signIdentifiedByPList.accept(javaPath);
861 
862             ioe = toThrow.get();
863             if (ioe != null) {
864                 throw ioe;
865             }
866         }
867         Path frameworkPath = appLocation.resolve(&quot;Contents/Frameworks&quot;);
868         if (Files.isDirectory(frameworkPath)) {
869             Files.list(frameworkPath)
870                     .forEach(signIdentifiedByPList);
871 
872             ioe = toThrow.get();
873             if (ioe != null) {
874                 throw ioe;
875             }
876         }
877 
878         // sign the app itself
879         List&lt;String&gt; args = new ArrayList&lt;&gt;();
880         args.addAll(Arrays.asList(&quot;codesign&quot;,
881                 &quot;-s&quot;, signingIdentity, // sign with this key
882                 &quot;-vvvv&quot;)); // super verbose output
883         if (entitlementsFile != null) {
884             args.add(&quot;--entitlements&quot;);
885             args.add(entitlementsFile); // entitlements
886         }
887         if (keyChain != null &amp;&amp; !keyChain.isEmpty()) {
888             args.add(&quot;--keychain&quot;);
889             args.add(keyChain);
890         }
891         args.add(appLocation.toString());
892 
893         ProcessBuilder pb =
894                 new ProcessBuilder(args.toArray(new String[args.size()]));
895         IOUtils.exec(pb);
896     }
897 
898     private static boolean isFileSigned(Path file) {
899         ProcessBuilder pb =
900                 new ProcessBuilder(&quot;codesign&quot;, &quot;--verify&quot;, file.toString());
901 
902         try {
903             IOUtils.exec(pb);
904         } catch (IOException ex) {
905             return false;
906         }
907 
908         return true;
909     }
910 
911     private static String extractBundleIdentifier(Map&lt;String, Object&gt; params) {
912         if (PREDEFINED_APP_IMAGE.fetchFrom(params) == null) {
913             return null;
914         }
915 
916         try {
917             File infoPList = new File(PREDEFINED_APP_IMAGE.fetchFrom(params) +
918                                       File.separator + &quot;Contents&quot; +
919                                       File.separator + &quot;Info.plist&quot;);
920 
921             DocumentBuilderFactory dbf
922                     = DocumentBuilderFactory.newDefaultInstance();
923             dbf.setFeature(&quot;http://apache.org/xml/features/&quot; +
924                            &quot;nonvalidating/load-external-dtd&quot;, false);
925             DocumentBuilder b = dbf.newDocumentBuilder();
926             org.w3c.dom.Document doc = b.parse(new FileInputStream(
927                     infoPList.getAbsolutePath()));
928 
929             XPath xPath = XPathFactory.newInstance().newXPath();
930             // Query for the value of &lt;string&gt; element preceding &lt;key&gt;
931             // element with value equal to CFBundleIdentifier
932             String v = (String) xPath.evaluate(
933                     &quot;//string[preceding-sibling::key = \&quot;CFBundleIdentifier\&quot;][1]&quot;,
934                     doc, XPathConstants.STRING);
935 
936             if (v != null &amp;&amp; !v.isEmpty()) {
937                 return v;
938             }
939         } catch (Exception ex) {
940             Log.verbose(ex);
941         }
942 
943         return null;
944     }
945 
946 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
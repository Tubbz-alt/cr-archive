<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacPkgBundler.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MacAppImageBuilder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="resources/MacResources.properties.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacPkgBundler.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
345                     if (skip == 0) {
346                         out.println(lines[i]);
347                     }
348                 }
349             }
350         }
351     }
352 
353     // pkgbuild includes all components from &quot;--root&quot; and subfolders,
354     // so if we have app image in folder which contains other images, then they
355     // will be included as well. It does have &quot;--filter&quot; option which use regex
356     // to exclude files/folder, but it will overwrite default one which excludes
357     // based on doc &quot;any .svn or CVS directories, and any .DS_Store files&quot;.
358     // So easy aproach will be to copy user provided app-image into temp folder
359     // if root path contains other files.
360     private String getRoot(Map&lt;String, ? super Object&gt; params,
361             File appLocation) throws IOException {
362         String root = appLocation.getParent() == null ?
363                 &quot;.&quot; : appLocation.getParent();
364         File rootDir = new File(root);

365         File[] list = rootDir.listFiles();
366         if (list != null) { // Should not happend
367             // We should only have app image and/or .DS_Store
368             if (list.length == 1) {
369                 return root;
370             } else if (list.length == 2) {
371                 // Check case with app image and .DS_Store
372                 if (list[0].toString().toLowerCase().endsWith(&quot;.ds_store&quot;) ||
373                     list[1].toString().toLowerCase().endsWith(&quot;.ds_store&quot;)) {
374                     return root; // Only app image and .DS_Store
375                 }
376             }
377         }
378 
379         // Copy to new root
380         Path newRoot = Files.createTempDirectory(
<span class="line-modified">381                 TEMP_ROOT.fetchFrom(params).toPath(),</span>
<span class="line-modified">382                 &quot;root-&quot;);</span>
<span class="line-modified">383 </span>
<span class="line-modified">384         IOUtils.copyRecursive(appLocation.toPath(),</span>
<span class="line-modified">385                 newRoot.resolve(appLocation.getName()));</span>














386 
387         return newRoot.toString();
388     }
389 
390     private File createPKG(Map&lt;String, ? super Object&gt; params,
391             File outdir, File appLocation) {
392         // generic find attempt
393         try {
394             File appPKG = getPackages_AppPackage(params);
395 
396             String root = getRoot(params, appLocation);
397 
398             // Generate default CPL file
399             File cpl = new File(CONFIG_ROOT.fetchFrom(params).getAbsolutePath()
400                     + File.separator + &quot;cpl.plist&quot;);
401             ProcessBuilder pb = new ProcessBuilder(&quot;pkgbuild&quot;,
402                     &quot;--root&quot;,
403                     root,
404                     &quot;--install-location&quot;,
405                     MAC_INSTALL_DIR.fetchFrom(params),
406                     &quot;--analyze&quot;,
407                     cpl.getAbsolutePath());
408 
409             IOUtils.exec(pb);
410 
411             patchCPLFile(cpl);
412 
413             preparePackageScripts(params);
414 
415             // build application package
416             pb = new ProcessBuilder(&quot;pkgbuild&quot;,
417                     &quot;--root&quot;,
418                     root,
419                     &quot;--install-location&quot;,
420                     MAC_INSTALL_DIR.fetchFrom(params),
421                     &quot;--component-plist&quot;,
422                     cpl.getAbsolutePath(),
423                     &quot;--scripts&quot;,
424                     SCRIPTS_DIR.fetchFrom(params).getAbsolutePath(),


425                     appPKG.getAbsolutePath());
426             IOUtils.exec(pb);
427 
428             // build final package
429             File finalPKG = new File(outdir, INSTALLER_NAME.fetchFrom(params)
430                     + INSTALLER_SUFFIX.fetchFrom(params)
431                     + &quot;.pkg&quot;);
432             outdir.mkdirs();
433 
434             List&lt;String&gt; commandLine = new ArrayList&lt;&gt;();
435             commandLine.add(&quot;productbuild&quot;);
436 
437             commandLine.add(&quot;--resources&quot;);
438             commandLine.add(CONFIG_ROOT.fetchFrom(params).getAbsolutePath());
439 
440             // maybe sign
441             if (Optional.ofNullable(MacAppImageBuilder.
442                     SIGN_BUNDLE.fetchFrom(params)).orElse(Boolean.TRUE)) {
443                 if (Platform.getMajorVersion() &gt; 10 ||
444                     (Platform.getMajorVersion() == 10 &amp;&amp;
</pre>
<hr />
<pre>
476         } catch (Exception ignored) {
477             Log.verbose(ignored);
478             return null;
479         }
480     }
481 
482     //////////////////////////////////////////////////////////////////////////
483     // Implement Bundler
484     //////////////////////////////////////////////////////////////////////////
485 
486     @Override
487     public String getName() {
488         return I18N.getString(&quot;pkg.bundler.name&quot;);
489     }
490 
491     @Override
492     public String getID() {
493         return &quot;pkg&quot;;
494     }
495 














496     @Override
497     public boolean validate(Map&lt;String, ? super Object&gt; params)
498             throws ConfigException {
499         try {
500             Objects.requireNonNull(params);
501 
502             // run basic validation to ensure requirements are met
503             // we are not interested in return code, only possible exception
504             validateAppImageAndBundeler(params);
505 
<span class="line-modified">506             if (MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params) == null) {</span>

507                 throw new ConfigException(
508                         I18N.getString(&quot;message.app-image-requires-identifier&quot;),
509                         I18N.getString(
510                             &quot;message.app-image-requires-identifier.advice&quot;));
511             }






512 
513             // reject explicitly set sign to true and no valid signature key
514             if (Optional.ofNullable(MacAppImageBuilder.
515                     SIGN_BUNDLE.fetchFrom(params)).orElse(Boolean.FALSE)) {
516                 String signingIdentity =
517                         DEVELOPER_ID_INSTALLER_SIGNING_KEY.fetchFrom(params);
518                 if (signingIdentity == null) {
519                     throw new ConfigException(
520                             I18N.getString(&quot;error.explicit-sign-no-cert&quot;),
521                             I18N.getString(
522                             &quot;error.explicit-sign-no-cert.advice&quot;));
523                 }
524             }
525 
526             // hdiutil is always available so there&#39;s no need
527             // to test for availability.
528 
529             return true;
530         } catch (RuntimeException re) {
531             if (re.getCause() instanceof ConfigException) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
345                     if (skip == 0) {
346                         out.println(lines[i]);
347                     }
348                 }
349             }
350         }
351     }
352 
353     // pkgbuild includes all components from &quot;--root&quot; and subfolders,
354     // so if we have app image in folder which contains other images, then they
355     // will be included as well. It does have &quot;--filter&quot; option which use regex
356     // to exclude files/folder, but it will overwrite default one which excludes
357     // based on doc &quot;any .svn or CVS directories, and any .DS_Store files&quot;.
358     // So easy aproach will be to copy user provided app-image into temp folder
359     // if root path contains other files.
360     private String getRoot(Map&lt;String, ? super Object&gt; params,
361             File appLocation) throws IOException {
362         String root = appLocation.getParent() == null ?
363                 &quot;.&quot; : appLocation.getParent();
364         File rootDir = new File(root);
<span class="line-added">365 </span>
366         File[] list = rootDir.listFiles();
367         if (list != null) { // Should not happend
368             // We should only have app image and/or .DS_Store
369             if (list.length == 1) {
370                 return root;
371             } else if (list.length == 2) {
372                 // Check case with app image and .DS_Store
373                 if (list[0].toString().toLowerCase().endsWith(&quot;.ds_store&quot;) ||
374                     list[1].toString().toLowerCase().endsWith(&quot;.ds_store&quot;)) {
375                     return root; // Only app image and .DS_Store
376                 }
377             }
378         }
379 
380         // Copy to new root
381         Path newRoot = Files.createTempDirectory(
<span class="line-modified">382                 TEMP_ROOT.fetchFrom(params).toPath(), &quot;root-&quot;);</span>
<span class="line-modified">383 </span>
<span class="line-modified">384         Path source, dest;</span>
<span class="line-modified">385 </span>
<span class="line-modified">386         if (StandardBundlerParam.isRuntimeInstaller(params)) {</span>
<span class="line-added">387             // firs, is this already a runtime with</span>
<span class="line-added">388             // &lt;runtime&gt;/Contents/Home - if so we need the Home dir</span>
<span class="line-added">389             Path original = appLocation.toPath();</span>
<span class="line-added">390             Path home = original.resolve(&quot;Contents/Home&quot;);</span>
<span class="line-added">391             source = (Files.exists(home)) ? home : original;</span>
<span class="line-added">392 </span>
<span class="line-added">393             // Then we need to put back the &lt;NAME&gt;/Content/Home</span>
<span class="line-added">394             dest = newRoot.resolve(</span>
<span class="line-added">395                 MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params) + &quot;/Contents/Home&quot;);</span>
<span class="line-added">396         } else {</span>
<span class="line-added">397             source = appLocation.toPath();</span>
<span class="line-added">398             dest = newRoot.resolve(appLocation.getName());</span>
<span class="line-added">399         }</span>
<span class="line-added">400         IOUtils.copyRecursive(source, dest);</span>
401 
402         return newRoot.toString();
403     }
404 
405     private File createPKG(Map&lt;String, ? super Object&gt; params,
406             File outdir, File appLocation) {
407         // generic find attempt
408         try {
409             File appPKG = getPackages_AppPackage(params);
410 
411             String root = getRoot(params, appLocation);
412 
413             // Generate default CPL file
414             File cpl = new File(CONFIG_ROOT.fetchFrom(params).getAbsolutePath()
415                     + File.separator + &quot;cpl.plist&quot;);
416             ProcessBuilder pb = new ProcessBuilder(&quot;pkgbuild&quot;,
417                     &quot;--root&quot;,
418                     root,
419                     &quot;--install-location&quot;,
420                     MAC_INSTALL_DIR.fetchFrom(params),
421                     &quot;--analyze&quot;,
422                     cpl.getAbsolutePath());
423 
424             IOUtils.exec(pb);
425 
426             patchCPLFile(cpl);
427 
428             preparePackageScripts(params);
429 
430             // build application package
431             pb = new ProcessBuilder(&quot;pkgbuild&quot;,
432                     &quot;--root&quot;,
433                     root,
434                     &quot;--install-location&quot;,
435                     MAC_INSTALL_DIR.fetchFrom(params),
436                     &quot;--component-plist&quot;,
437                     cpl.getAbsolutePath(),
438                     &quot;--scripts&quot;,
439                     SCRIPTS_DIR.fetchFrom(params).getAbsolutePath(),
<span class="line-added">440                     &quot;--identifier&quot;,</span>
<span class="line-added">441                      MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params),</span>
442                     appPKG.getAbsolutePath());
443             IOUtils.exec(pb);
444 
445             // build final package
446             File finalPKG = new File(outdir, INSTALLER_NAME.fetchFrom(params)
447                     + INSTALLER_SUFFIX.fetchFrom(params)
448                     + &quot;.pkg&quot;);
449             outdir.mkdirs();
450 
451             List&lt;String&gt; commandLine = new ArrayList&lt;&gt;();
452             commandLine.add(&quot;productbuild&quot;);
453 
454             commandLine.add(&quot;--resources&quot;);
455             commandLine.add(CONFIG_ROOT.fetchFrom(params).getAbsolutePath());
456 
457             // maybe sign
458             if (Optional.ofNullable(MacAppImageBuilder.
459                     SIGN_BUNDLE.fetchFrom(params)).orElse(Boolean.TRUE)) {
460                 if (Platform.getMajorVersion() &gt; 10 ||
461                     (Platform.getMajorVersion() == 10 &amp;&amp;
</pre>
<hr />
<pre>
493         } catch (Exception ignored) {
494             Log.verbose(ignored);
495             return null;
496         }
497     }
498 
499     //////////////////////////////////////////////////////////////////////////
500     // Implement Bundler
501     //////////////////////////////////////////////////////////////////////////
502 
503     @Override
504     public String getName() {
505         return I18N.getString(&quot;pkg.bundler.name&quot;);
506     }
507 
508     @Override
509     public String getID() {
510         return &quot;pkg&quot;;
511     }
512 
<span class="line-added">513     private static boolean isValidBundleIdentifier(String id) {</span>
<span class="line-added">514         for (int i = 0; i &lt; id.length(); i++) {</span>
<span class="line-added">515             char a = id.charAt(i);</span>
<span class="line-added">516             // We check for ASCII codes first which we accept. If check fails,</span>
<span class="line-added">517             // check if it is acceptable extended ASCII or unicode character.</span>
<span class="line-added">518             if ((a &gt;= &#39;A&#39; &amp;&amp; a &lt;= &#39;Z&#39;) || (a &gt;= &#39;a&#39; &amp;&amp; a &lt;= &#39;z&#39;)</span>
<span class="line-added">519                     || (a &gt;= &#39;0&#39; &amp;&amp; a &lt;= &#39;9&#39;) || (a == &#39;-&#39; || a == &#39;.&#39;)) {</span>
<span class="line-added">520                 continue;</span>
<span class="line-added">521             }</span>
<span class="line-added">522             return false;</span>
<span class="line-added">523         }</span>
<span class="line-added">524         return true;</span>
<span class="line-added">525     }</span>
<span class="line-added">526 </span>
527     @Override
528     public boolean validate(Map&lt;String, ? super Object&gt; params)
529             throws ConfigException {
530         try {
531             Objects.requireNonNull(params);
532 
533             // run basic validation to ensure requirements are met
534             // we are not interested in return code, only possible exception
535             validateAppImageAndBundeler(params);
536 
<span class="line-modified">537             String identifier = MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params);</span>
<span class="line-added">538             if (identifier == null) {</span>
539                 throw new ConfigException(
540                         I18N.getString(&quot;message.app-image-requires-identifier&quot;),
541                         I18N.getString(
542                             &quot;message.app-image-requires-identifier.advice&quot;));
543             }
<span class="line-added">544             if (!isValidBundleIdentifier(identifier)) {</span>
<span class="line-added">545                 throw new ConfigException(</span>
<span class="line-added">546                         MessageFormat.format(I18N.getString(</span>
<span class="line-added">547                         &quot;message.invalid-identifier&quot;), identifier),</span>
<span class="line-added">548                         I18N.getString(&quot;message.invalid-identifier.advice&quot;));</span>
<span class="line-added">549             }</span>
550 
551             // reject explicitly set sign to true and no valid signature key
552             if (Optional.ofNullable(MacAppImageBuilder.
553                     SIGN_BUNDLE.fetchFrom(params)).orElse(Boolean.FALSE)) {
554                 String signingIdentity =
555                         DEVELOPER_ID_INSTALLER_SIGNING_KEY.fetchFrom(params);
556                 if (signingIdentity == null) {
557                     throw new ConfigException(
558                             I18N.getString(&quot;error.explicit-sign-no-cert&quot;),
559                             I18N.getString(
560                             &quot;error.explicit-sign-no-cert.advice&quot;));
561                 }
562             }
563 
564             // hdiutil is always available so there&#39;s no need
565             // to test for availability.
566 
567             return true;
568         } catch (RuntimeException re) {
569             if (re.getCause() instanceof ConfigException) {
</pre>
</td>
</tr>
</table>
<center><a href="MacAppImageBuilder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="resources/MacResources.properties.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
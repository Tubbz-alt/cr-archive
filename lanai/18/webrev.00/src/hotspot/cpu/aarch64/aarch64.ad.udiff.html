<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/aarch64/aarch64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../.mx.jvmci/mx_jvmci.py.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="assembler_aarch64.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/aarch64.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1573,11 +1573,11 @@</span>
    }
  
  //=============================================================================
  const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
  
<span class="udiff-line-modified-removed">- int Compile::ConstantTable::calculate_table_base_offset() const {</span>
<span class="udiff-line-modified-added">+ int ConstantTable::calculate_table_base_offset() const {</span>
    return 0;  // absolute addressing, no offset
  }
  
  bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1600,13 +1600,13 @@</span>
  
  #ifndef PRODUCT
  void MachPrologNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
    Compile* C = ra_-&gt;C;
  
<span class="udiff-line-modified-removed">-   int framesize = C-&gt;frame_slots() &lt;&lt; LogBytesPerInt;</span>
<span class="udiff-line-modified-added">+   int framesize = C-&gt;output()-&gt;frame_slots() &lt;&lt; LogBytesPerInt;</span>
  
<span class="udiff-line-modified-removed">-   if (C-&gt;need_stack_bang(framesize))</span>
<span class="udiff-line-modified-added">+   if (C-&gt;output()-&gt;need_stack_bang(framesize))</span>
      st-&gt;print(&quot;# stack bang size=%d\n\t&quot;, framesize);
  
    if (framesize &lt; ((1 &lt;&lt; 9) + 2 * wordSize)) {
      st-&gt;print(&quot;sub  sp, sp, #%d\n\t&quot;, framesize);
      st-&gt;print(&quot;stp  rfp, lr, [sp, #%d]&quot;, framesize - 2 * wordSize);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1623,11 +1623,11 @@</span>
  void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
    Compile* C = ra_-&gt;C;
    MacroAssembler _masm(&amp;cbuf);
  
    // n.b. frame size includes space for return pc and rfp
<span class="udiff-line-modified-removed">-   const long framesize = C-&gt;frame_size_in_bytes();</span>
<span class="udiff-line-modified-added">+   const long framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
    assert(framesize%(2*wordSize) == 0, &quot;must preserve 2*wordSize alignment&quot;);
  
    // insert a nop at the start of the prolog so we can patch in a
    // branch if we need to invalidate the method later
    __ nop();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1641,26 +1641,26 @@</span>
      __ clinit_barrier(rscratch2, rscratch1, &amp;L_skip_barrier);
      __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));
      __ bind(L_skip_barrier);
    }
  
<span class="udiff-line-modified-removed">-   int bangsize = C-&gt;bang_size_in_bytes();</span>
<span class="udiff-line-modified-removed">-   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging)</span>
<span class="udiff-line-modified-added">+   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
<span class="udiff-line-modified-added">+   if (C-&gt;output()-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging)</span>
      __ generate_stack_overflow_check(bangsize);
  
    __ build_frame(framesize);
  
    if (VerifyStackAtCalls) {
      Unimplemented();
    }
  
<span class="udiff-line-modified-removed">-   C-&gt;set_frame_complete(cbuf.insts_size());</span>
<span class="udiff-line-modified-added">+   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());</span>
  
    if (C-&gt;has_mach_constant_base_node()) {
      // NOTE: We set the table base offset here because users might be
      // emitted before MachConstantBaseNode.
<span class="udiff-line-modified-removed">-     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();</span>
<span class="udiff-line-modified-added">+     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();</span>
      constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
    }
  }
  
  uint MachPrologNode::size(PhaseRegAlloc* ra_) const
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1677,11 +1677,11 @@</span>
  //=============================================================================
  
  #ifndef PRODUCT
  void MachEpilogNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
    Compile* C = ra_-&gt;C;
<span class="udiff-line-modified-removed">-   int framesize = C-&gt;frame_slots() &lt;&lt; LogBytesPerInt;</span>
<span class="udiff-line-modified-added">+   int framesize = C-&gt;output()-&gt;frame_slots() &lt;&lt; LogBytesPerInt;</span>
  
    st-&gt;print(&quot;# pop frame %d\n\t&quot;,framesize);
  
    if (framesize == 0) {
      st-&gt;print(&quot;ldp  lr, rfp, [sp],#%d\n\t&quot;, (2 * wordSize));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1703,11 +1703,11 @@</span>
  #endif
  
  void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
    Compile* C = ra_-&gt;C;
    MacroAssembler _masm(&amp;cbuf);
<span class="udiff-line-modified-removed">-   int framesize = C-&gt;frame_slots() &lt;&lt; LogBytesPerInt;</span>
<span class="udiff-line-modified-added">+   int framesize = C-&gt;output()-&gt;frame_slots() &lt;&lt; LogBytesPerInt;</span>
  
    __ remove_frame(framesize);
  
    if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
      __ reserved_stack_check();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2072,19 +2072,28 @@</span>
    }
  
    return ret_value; // Per default match rules are supported.
  }
  
<span class="udiff-line-added">+ // Identify extra cases that we might want to provide match rules for vector nodes and</span>
<span class="udiff-line-added">+ // other intrinsics guarded with vector length (vlen) and element type (bt).</span>
  const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {
<span class="udiff-line-added">+   if (!match_rule_supported(opcode)) {</span>
<span class="udiff-line-added">+     return false;</span>
<span class="udiff-line-added">+   }</span>
  
<span class="udiff-line-modified-removed">-   // TODO</span>
<span class="udiff-line-modified-removed">-   // identify extra cases that we might want to provide match rules for</span>
<span class="udiff-line-modified-removed">-   // e.g. Op_ vector nodes and other intrinsics while guarding with vlen</span>
<span class="udiff-line-modified-removed">-   bool ret_value = match_rule_supported(opcode);</span>
<span class="udiff-line-modified-removed">-   // Add rules here.</span>
<span class="udiff-line-modified-added">+   // Special cases which require vector length</span>
<span class="udiff-line-modified-added">+   switch (opcode) {</span>
<span class="udiff-line-modified-added">+     case Op_MulAddVS2VI: {</span>
<span class="udiff-line-modified-added">+       if (vlen != 4) {</span>
<span class="udiff-line-modified-added">+         return false;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
  
<span class="udiff-line-modified-removed">-   return ret_value;  // Per default match rules are supported.</span>
<span class="udiff-line-modified-added">+   return true; // Per default match rules are supported.</span>
  }
  
  const bool Matcher::has_predicated_vectors(void) {
    return false;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2255,12 +2264,11 @@</span>
  // No-op on amd64
  void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
    Unimplemented();
  }
  
<span class="udiff-line-modified-removed">- // Advertise here if the CPU requires explicit rounding operations to</span>
<span class="udiff-line-removed">- // implement the UseStrictFP mode.</span>
<span class="udiff-line-modified-added">+ // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.</span>
  const bool Matcher::strict_fp_requires_explicit_rounding = false;
  
  // Are floats converted to double when stored to stack during
  // deoptimization?
  bool Matcher::float_in_double() { return false; }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -10554,10 +10562,26 @@</span>
    %}
  
    ins_pipe(imac_reg_reg);
  %}
  
<span class="udiff-line-added">+ // Combined Multiply-Add Shorts into Integer (dst = src1 * src2 + src3 * src4)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ instruct muladdS2I(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2, iRegIorL2I src3, iRegIorL2I src4) %{</span>
<span class="udiff-line-added">+   match(Set dst (MulAddS2I (Binary src1 src2) (Binary src3 src4)));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ins_cost(INSN_COST * 5);</span>
<span class="udiff-line-added">+   format %{ &quot;mulw  rscratch1, $src1, $src2\n\t&quot;</span>
<span class="udiff-line-added">+             &quot;maddw $dst, $src3, $src4, rscratch1&quot; %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ins_encode %{</span>
<span class="udiff-line-added">+     __ mulw(rscratch1, as_Register($src1$$reg), as_Register($src2$$reg));</span>
<span class="udiff-line-added">+     __ maddw(as_Register($dst$$reg), as_Register($src3$$reg), as_Register($src4$$reg), rscratch1); %}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ins_pipe(imac_reg_reg);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
  // Integer Divide
  
  instruct divI(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2) %{
    match(Set dst (DivI src1 src2));
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -14910,36 +14934,36 @@</span>
    ins_short_branch(1);
  %}
  
  instruct cmpL_branch_bit(cmpOpEqNe cmp, iRegL op1, immL op2, immL0 op3, label labl) %{
    match(If cmp (CmpL (AndL op1 op2) op3));
<span class="udiff-line-modified-removed">-   predicate(is_power_of_2(n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_long()));</span>
<span class="udiff-line-modified-added">+   predicate(is_power_of_2((julong)n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_long()));</span>
    effect(USE labl);
  
    ins_cost(BRANCH_COST);
    format %{ &quot;tb$cmp   $op1, $op2, $labl&quot; %}
    ins_encode %{
      Label* L = $labl$$label;
      Assembler::Condition cond = (Assembler::Condition)$cmp$$cmpcode;
<span class="udiff-line-modified-removed">-     int bit = exact_log2($op2$$constant);</span>
<span class="udiff-line-modified-added">+     int bit = exact_log2_long($op2$$constant);</span>
      __ tbr(cond, $op1$$Register, bit, *L);
    %}
    ins_pipe(pipe_cmp_branch);
    ins_short_branch(1);
  %}
  
  instruct cmpI_branch_bit(cmpOpEqNe cmp, iRegIorL2I op1, immI op2, immI0 op3, label labl) %{
    match(If cmp (CmpI (AndI op1 op2) op3));
<span class="udiff-line-modified-removed">-   predicate(is_power_of_2(n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_int()));</span>
<span class="udiff-line-modified-added">+   predicate(is_power_of_2((juint)n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_int()));</span>
    effect(USE labl);
  
    ins_cost(BRANCH_COST);
    format %{ &quot;tb$cmp   $op1, $op2, $labl&quot; %}
    ins_encode %{
      Label* L = $labl$$label;
      Assembler::Condition cond = (Assembler::Condition)$cmp$$cmpcode;
<span class="udiff-line-modified-removed">-     int bit = exact_log2($op2$$constant);</span>
<span class="udiff-line-modified-added">+     int bit = exact_log2((juint)$op2$$constant);</span>
      __ tbr(cond, $op1$$Register, bit, *L);
    %}
    ins_pipe(pipe_cmp_branch);
    ins_short_branch(1);
  %}
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -14975,35 +14999,35 @@</span>
    ins_pipe(pipe_cmp_branch);
  %}
  
  instruct far_cmpL_branch_bit(cmpOpEqNe cmp, iRegL op1, immL op2, immL0 op3, label labl) %{
    match(If cmp (CmpL (AndL op1 op2) op3));
<span class="udiff-line-modified-removed">-   predicate(is_power_of_2(n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_long()));</span>
<span class="udiff-line-modified-added">+   predicate(is_power_of_2((julong)n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_long()));</span>
    effect(USE labl);
  
    ins_cost(BRANCH_COST);
    format %{ &quot;tb$cmp   $op1, $op2, $labl&quot; %}
    ins_encode %{
      Label* L = $labl$$label;
      Assembler::Condition cond = (Assembler::Condition)$cmp$$cmpcode;
<span class="udiff-line-modified-removed">-     int bit = exact_log2($op2$$constant);</span>
<span class="udiff-line-modified-added">+     int bit = exact_log2_long($op2$$constant);</span>
      __ tbr(cond, $op1$$Register, bit, *L, /*far*/true);
    %}
    ins_pipe(pipe_cmp_branch);
  %}
  
  instruct far_cmpI_branch_bit(cmpOpEqNe cmp, iRegIorL2I op1, immI op2, immI0 op3, label labl) %{
    match(If cmp (CmpI (AndI op1 op2) op3));
<span class="udiff-line-modified-removed">-   predicate(is_power_of_2(n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_int()));</span>
<span class="udiff-line-modified-added">+   predicate(is_power_of_2((juint)n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_int()));</span>
    effect(USE labl);
  
    ins_cost(BRANCH_COST);
    format %{ &quot;tb$cmp   $op1, $op2, $labl&quot; %}
    ins_encode %{
      Label* L = $labl$$label;
      Assembler::Condition cond = (Assembler::Condition)$cmp$$cmpcode;
<span class="udiff-line-modified-removed">-     int bit = exact_log2($op2$$constant);</span>
<span class="udiff-line-modified-added">+     int bit = exact_log2((juint)$op2$$constant);</span>
      __ tbr(cond, $op1$$Register, bit, *L, /*far*/true);
    %}
    ins_pipe(pipe_cmp_branch);
  %}
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -16934,10 +16958,34 @@</span>
              as_FloatRegister($src2$$reg));
    %}
    ins_pipe(vmuldiv_fp128);
  %}
  
<span class="udiff-line-added">+ // --------------- Vector Multiply-Add Shorts into Integer --------------------</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ instruct vmuladdS2I(vecX dst, vecX src1, vecX src2, vecX tmp) %{</span>
<span class="udiff-line-added">+   predicate(n-&gt;in(1)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_SHORT);</span>
<span class="udiff-line-added">+   match(Set dst (MulAddVS2VI src1 src2));</span>
<span class="udiff-line-added">+   ins_cost(INSN_COST);</span>
<span class="udiff-line-added">+   effect(TEMP tmp);</span>
<span class="udiff-line-added">+   format %{ &quot;smullv  $tmp, $src1, $src2\t# vector (4H)\n\t&quot;</span>
<span class="udiff-line-added">+             &quot;smullv  $dst, $src1, $src2\t# vector (8H)\n\t&quot;</span>
<span class="udiff-line-added">+             &quot;addpv   $dst, $tmp, $dst\t# vector (4S)\n\t&quot; %}</span>
<span class="udiff-line-added">+   ins_encode %{</span>
<span class="udiff-line-added">+     __ smullv(as_FloatRegister($tmp$$reg), __ T4H,</span>
<span class="udiff-line-added">+               as_FloatRegister($src1$$reg),</span>
<span class="udiff-line-added">+               as_FloatRegister($src2$$reg));</span>
<span class="udiff-line-added">+     __ smullv(as_FloatRegister($dst$$reg), __ T8H,</span>
<span class="udiff-line-added">+               as_FloatRegister($src1$$reg),</span>
<span class="udiff-line-added">+               as_FloatRegister($src2$$reg));</span>
<span class="udiff-line-added">+     __ addpv(as_FloatRegister($dst$$reg), __ T4S,</span>
<span class="udiff-line-added">+              as_FloatRegister($tmp$$reg),</span>
<span class="udiff-line-added">+              as_FloatRegister($dst$$reg));</span>
<span class="udiff-line-added">+   %}</span>
<span class="udiff-line-added">+   ins_pipe(vmuldiv_fp128);</span>
<span class="udiff-line-added">+ %}</span>
<span class="udiff-line-added">+ </span>
  // --------------------------------- DIV --------------------------------------
  
  instruct vdiv2F(vecD dst, vecD src1, vecD src2)
  %{
    predicate(n-&gt;as_Vector()-&gt;length() == 2);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17311,11 +17359,11 @@</span>
  %}
  
  instruct vsll8B_imm(vecD dst, vecD src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 4 ||
              n-&gt;as_Vector()-&gt;length() == 8);
<span class="udiff-line-modified-removed">-   match(Set dst (LShiftVB src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (LShiftVB src (LShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;shl    $dst, $src, $shift\t# vector (8B)&quot; %}
    ins_encode %{
      int sh = (int)$shift$$constant;
      if (sh &gt;= 8) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17330,11 +17378,11 @@</span>
    ins_pipe(vshift64_imm);
  %}
  
  instruct vsll16B_imm(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 16);
<span class="udiff-line-modified-removed">-   match(Set dst (LShiftVB src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (LShiftVB src (LShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;shl    $dst, $src, $shift\t# vector (16B)&quot; %}
    ins_encode %{
      int sh = (int)$shift$$constant;
      if (sh &gt;= 8) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17350,11 +17398,11 @@</span>
  %}
  
  instruct vsra8B_imm(vecD dst, vecD src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 4 ||
              n-&gt;as_Vector()-&gt;length() == 8);
<span class="udiff-line-modified-removed">-   match(Set dst (RShiftVB src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (RShiftVB src (RShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;sshr    $dst, $src, $shift\t# vector (8B)&quot; %}
    ins_encode %{
      int sh = (int)$shift$$constant;
      if (sh &gt;= 8) sh = 7;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17364,11 +17412,11 @@</span>
    ins_pipe(vshift64_imm);
  %}
  
  instruct vsra16B_imm(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 16);
<span class="udiff-line-modified-removed">-   match(Set dst (RShiftVB src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (RShiftVB src (RShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;sshr    $dst, $src, $shift\t# vector (16B)&quot; %}
    ins_encode %{
      int sh = (int)$shift$$constant;
      if (sh &gt;= 8) sh = 7;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17379,11 +17427,11 @@</span>
  %}
  
  instruct vsrl8B_imm(vecD dst, vecD src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 4 ||
              n-&gt;as_Vector()-&gt;length() == 8);
<span class="udiff-line-modified-removed">-   match(Set dst (URShiftVB src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (URShiftVB src (RShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;ushr    $dst, $src, $shift\t# vector (8B)&quot; %}
    ins_encode %{
      int sh = (int)$shift$$constant;
      if (sh &gt;= 8) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17398,11 +17446,11 @@</span>
    ins_pipe(vshift64_imm);
  %}
  
  instruct vsrl16B_imm(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 16);
<span class="udiff-line-modified-removed">-   match(Set dst (URShiftVB src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (URShiftVB src (RShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;ushr    $dst, $src, $shift\t# vector (16B)&quot; %}
    ins_encode %{
      int sh = (int)$shift$$constant;
      if (sh &gt;= 8) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17515,11 +17563,11 @@</span>
  %}
  
  instruct vsll4S_imm(vecD dst, vecD src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 2 ||
              n-&gt;as_Vector()-&gt;length() == 4);
<span class="udiff-line-modified-removed">-   match(Set dst (LShiftVS src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (LShiftVS src (LShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;shl    $dst, $src, $shift\t# vector (4H)&quot; %}
    ins_encode %{
      int sh = (int)$shift$$constant;
      if (sh &gt;= 16) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17534,11 +17582,11 @@</span>
    ins_pipe(vshift64_imm);
  %}
  
  instruct vsll8S_imm(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 8);
<span class="udiff-line-modified-removed">-   match(Set dst (LShiftVS src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (LShiftVS src (LShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;shl    $dst, $src, $shift\t# vector (8H)&quot; %}
    ins_encode %{
      int sh = (int)$shift$$constant;
      if (sh &gt;= 16) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17554,11 +17602,11 @@</span>
  %}
  
  instruct vsra4S_imm(vecD dst, vecD src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 2 ||
              n-&gt;as_Vector()-&gt;length() == 4);
<span class="udiff-line-modified-removed">-   match(Set dst (RShiftVS src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (RShiftVS src (LShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;sshr    $dst, $src, $shift\t# vector (4H)&quot; %}
    ins_encode %{
      int sh = (int)$shift$$constant;
      if (sh &gt;= 16) sh = 15;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17568,11 +17616,11 @@</span>
    ins_pipe(vshift64_imm);
  %}
  
  instruct vsra8S_imm(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 8);
<span class="udiff-line-modified-removed">-   match(Set dst (RShiftVS src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (RShiftVS src (LShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;sshr    $dst, $src, $shift\t# vector (8H)&quot; %}
    ins_encode %{
      int sh = (int)$shift$$constant;
      if (sh &gt;= 16) sh = 15;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17583,11 +17631,11 @@</span>
  %}
  
  instruct vsrl4S_imm(vecD dst, vecD src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 2 ||
              n-&gt;as_Vector()-&gt;length() == 4);
<span class="udiff-line-modified-removed">-   match(Set dst (URShiftVS src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (URShiftVS src (RShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;ushr    $dst, $src, $shift\t# vector (4H)&quot; %}
    ins_encode %{
      int sh = (int)$shift$$constant;
      if (sh &gt;= 16) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17602,11 +17650,11 @@</span>
    ins_pipe(vshift64_imm);
  %}
  
  instruct vsrl8S_imm(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 8);
<span class="udiff-line-modified-removed">-   match(Set dst (URShiftVS src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (URShiftVS src (RShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;ushr    $dst, $src, $shift\t# vector (8H)&quot; %}
    ins_encode %{
      int sh = (int)$shift$$constant;
      if (sh &gt;= 16) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17715,11 +17763,11 @@</span>
    ins_pipe(vshift128);
  %}
  
  instruct vsll2I_imm(vecD dst, vecD src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="udiff-line-modified-removed">-   match(Set dst (LShiftVI src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (LShiftVI src (LShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;shl    $dst, $src, $shift\t# vector (2S)&quot; %}
    ins_encode %{
      __ shl(as_FloatRegister($dst$$reg), __ T2S,
             as_FloatRegister($src$$reg),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17728,11 +17776,11 @@</span>
    ins_pipe(vshift64_imm);
  %}
  
  instruct vsll4I_imm(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 4);
<span class="udiff-line-modified-removed">-   match(Set dst (LShiftVI src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (LShiftVI src (LShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;shl    $dst, $src, $shift\t# vector (4S)&quot; %}
    ins_encode %{
      __ shl(as_FloatRegister($dst$$reg), __ T4S,
             as_FloatRegister($src$$reg),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17741,11 +17789,11 @@</span>
    ins_pipe(vshift128_imm);
  %}
  
  instruct vsra2I_imm(vecD dst, vecD src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="udiff-line-modified-removed">-   match(Set dst (RShiftVI src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (RShiftVI src (RShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;sshr    $dst, $src, $shift\t# vector (2S)&quot; %}
    ins_encode %{
      __ sshr(as_FloatRegister($dst$$reg), __ T2S,
              as_FloatRegister($src$$reg),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17754,11 +17802,11 @@</span>
    ins_pipe(vshift64_imm);
  %}
  
  instruct vsra4I_imm(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 4);
<span class="udiff-line-modified-removed">-   match(Set dst (RShiftVI src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (RShiftVI src (RShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;sshr    $dst, $src, $shift\t# vector (4S)&quot; %}
    ins_encode %{
      __ sshr(as_FloatRegister($dst$$reg), __ T4S,
              as_FloatRegister($src$$reg),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17767,11 +17815,11 @@</span>
    ins_pipe(vshift128_imm);
  %}
  
  instruct vsrl2I_imm(vecD dst, vecD src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="udiff-line-modified-removed">-   match(Set dst (URShiftVI src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (URShiftVI src (RShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;ushr    $dst, $src, $shift\t# vector (2S)&quot; %}
    ins_encode %{
      __ ushr(as_FloatRegister($dst$$reg), __ T2S,
              as_FloatRegister($src$$reg),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17780,11 +17828,11 @@</span>
    ins_pipe(vshift64_imm);
  %}
  
  instruct vsrl4I_imm(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 4);
<span class="udiff-line-modified-removed">-   match(Set dst (URShiftVI src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (URShiftVI src (RShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;ushr    $dst, $src, $shift\t# vector (4S)&quot; %}
    ins_encode %{
      __ ushr(as_FloatRegister($dst$$reg), __ T4S,
              as_FloatRegister($src$$reg),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17840,11 +17888,11 @@</span>
    ins_pipe(vshift128);
  %}
  
  instruct vsll2L_imm(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="udiff-line-modified-removed">-   match(Set dst (LShiftVL src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (LShiftVL src (LShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;shl    $dst, $src, $shift\t# vector (2D)&quot; %}
    ins_encode %{
      __ shl(as_FloatRegister($dst$$reg), __ T2D,
             as_FloatRegister($src$$reg),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17853,11 +17901,11 @@</span>
    ins_pipe(vshift128_imm);
  %}
  
  instruct vsra2L_imm(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="udiff-line-modified-removed">-   match(Set dst (RShiftVL src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (RShiftVL src (RShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;sshr    $dst, $src, $shift\t# vector (2D)&quot; %}
    ins_encode %{
      __ sshr(as_FloatRegister($dst$$reg), __ T2D,
              as_FloatRegister($src$$reg),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17866,11 +17914,11 @@</span>
    ins_pipe(vshift128_imm);
  %}
  
  instruct vsrl2L_imm(vecX dst, vecX src, immI shift) %{
    predicate(n-&gt;as_Vector()-&gt;length() == 2);
<span class="udiff-line-modified-removed">-   match(Set dst (URShiftVL src shift));</span>
<span class="udiff-line-modified-added">+   match(Set dst (URShiftVL src (RShiftCntV shift)));</span>
    ins_cost(INSN_COST);
    format %{ &quot;ushr    $dst, $src, $shift\t# vector (2D)&quot; %}
    ins_encode %{
      __ ushr(as_FloatRegister($dst$$reg), __ T2D,
              as_FloatRegister($src$$reg),
</pre>
<center><a href="../../.mx.jvmci/mx_jvmci.py.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="assembler_aarch64.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
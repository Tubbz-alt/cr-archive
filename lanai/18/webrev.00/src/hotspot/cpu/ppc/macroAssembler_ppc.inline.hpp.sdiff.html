<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/ppc/macroAssembler_ppc.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_ppc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ppc.ad.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/ppc/macroAssembler_ppc.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #ifndef CPU_PPC_MACROASSEMBLER_PPC_INLINE_HPP
 27 #define CPU_PPC_MACROASSEMBLER_PPC_INLINE_HPP
 28 
 29 #include &quot;asm/assembler.inline.hpp&quot;
 30 #include &quot;asm/macroAssembler.hpp&quot;
 31 #include &quot;asm/codeBuffer.hpp&quot;
 32 #include &quot;code/codeCache.hpp&quot;
 33 #include &quot;gc/shared/barrierSet.hpp&quot;
 34 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
 35 #include &quot;oops/accessDecorators.hpp&quot;
 36 #include &quot;oops/compressedOops.hpp&quot;
 37 #include &quot;runtime/safepointMechanism.hpp&quot;

 38 
 39 inline bool MacroAssembler::is_ld_largeoffset(address a) {
 40   const int inst1 = *(int *)a;
 41   const int inst2 = *(int *)(a+4);
 42   return (is_ld(inst1)) ||
 43          (is_addis(inst1) &amp;&amp; is_ld(inst2) &amp;&amp; inv_ra_field(inst2) == inv_rt_field(inst1));
 44 }
 45 
 46 inline int MacroAssembler::get_ld_largeoffset_offset(address a) {
 47   assert(MacroAssembler::is_ld_largeoffset(a), &quot;must be ld with large offset&quot;);
 48 
 49   const int inst1 = *(int *)a;
 50   if (is_ld(inst1)) {
 51     return inv_d1_field(inst1);
 52   } else {
 53     const int inst2 = *(int *)(a+4);
 54     return (inv_d1_field(inst1) &lt;&lt; 16) + inv_d1_field(inst2);
 55   }
 56 }
 57 
 58 inline void MacroAssembler::round_to(Register r, int modulus) {
<span class="line-modified"> 59   assert(is_power_of_2_long((jlong)modulus), &quot;must be power of 2&quot;);</span>
 60   addi(r, r, modulus-1);
 61   clrrdi(r, r, log2_long((jlong)modulus));
 62 }
 63 
 64 // Move register if destination register and target register are different.
 65 inline void MacroAssembler::mr_if_needed(Register rd, Register rs) {
 66   if (rs != rd) mr(rd, rs);
 67 }
 68 inline void MacroAssembler::fmr_if_needed(FloatRegister rd, FloatRegister rs) {
 69   if (rs != rd) fmr(rd, rs);
 70 }
 71 inline void MacroAssembler::endgroup_if_needed(bool needed) {
 72   if (needed) {
 73     endgroup();
 74   }
 75 }
 76 
 77 inline void MacroAssembler::membar(int bits) {
 78   // Comment: Usage of elemental_membar(bits) is not recommended for Power 8.
 79   // If elemental_membar(bits) is used, disable optimization of acquire-release
</pre>
</td>
<td>
<hr />
<pre>
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  *
 24  */
 25 
 26 #ifndef CPU_PPC_MACROASSEMBLER_PPC_INLINE_HPP
 27 #define CPU_PPC_MACROASSEMBLER_PPC_INLINE_HPP
 28 
 29 #include &quot;asm/assembler.inline.hpp&quot;
 30 #include &quot;asm/macroAssembler.hpp&quot;
 31 #include &quot;asm/codeBuffer.hpp&quot;
 32 #include &quot;code/codeCache.hpp&quot;
 33 #include &quot;gc/shared/barrierSet.hpp&quot;
 34 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
 35 #include &quot;oops/accessDecorators.hpp&quot;
 36 #include &quot;oops/compressedOops.hpp&quot;
 37 #include &quot;runtime/safepointMechanism.hpp&quot;
<span class="line-added"> 38 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
 39 
 40 inline bool MacroAssembler::is_ld_largeoffset(address a) {
 41   const int inst1 = *(int *)a;
 42   const int inst2 = *(int *)(a+4);
 43   return (is_ld(inst1)) ||
 44          (is_addis(inst1) &amp;&amp; is_ld(inst2) &amp;&amp; inv_ra_field(inst2) == inv_rt_field(inst1));
 45 }
 46 
 47 inline int MacroAssembler::get_ld_largeoffset_offset(address a) {
 48   assert(MacroAssembler::is_ld_largeoffset(a), &quot;must be ld with large offset&quot;);
 49 
 50   const int inst1 = *(int *)a;
 51   if (is_ld(inst1)) {
 52     return inv_d1_field(inst1);
 53   } else {
 54     const int inst2 = *(int *)(a+4);
 55     return (inv_d1_field(inst1) &lt;&lt; 16) + inv_d1_field(inst2);
 56   }
 57 }
 58 
 59 inline void MacroAssembler::round_to(Register r, int modulus) {
<span class="line-modified"> 60   assert(is_power_of_2((jlong)modulus), &quot;must be power of 2&quot;);</span>
 61   addi(r, r, modulus-1);
 62   clrrdi(r, r, log2_long((jlong)modulus));
 63 }
 64 
 65 // Move register if destination register and target register are different.
 66 inline void MacroAssembler::mr_if_needed(Register rd, Register rs) {
 67   if (rs != rd) mr(rd, rs);
 68 }
 69 inline void MacroAssembler::fmr_if_needed(FloatRegister rd, FloatRegister rs) {
 70   if (rs != rd) fmr(rd, rs);
 71 }
 72 inline void MacroAssembler::endgroup_if_needed(bool needed) {
 73   if (needed) {
 74     endgroup();
 75   }
 76 }
 77 
 78 inline void MacroAssembler::membar(int bits) {
 79   // Comment: Usage of elemental_membar(bits) is not recommended for Power 8.
 80   // If elemental_membar(bits) is used, disable optimization of acquire-release
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_ppc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ppc.ad.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/ppc/ppc.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
    1 //
    2 // Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
    3 // Copyright (c) 2012, 2019 SAP SE. All rights reserved.
    4 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    5 //
    6 // This code is free software; you can redistribute it and/or modify it
    7 // under the terms of the GNU General Public License version 2 only, as
    8 // published by the Free Software Foundation.
    9 //
   10 // This code is distributed in the hope that it will be useful, but WITHOUT
   11 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   12 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   13 // version 2 for more details (a copy is included in the LICENSE file that
   14 // accompanied this code).
   15 //
   16 // You should have received a copy of the GNU General Public License version
   17 // 2 along with this work; if not, write to the Free Software Foundation,
   18 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   19 //
   20 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   21 // or visit www.oracle.com if you need additional information or have any
   22 // questions.
   23 //
   24 //
   25 
   26 //
   27 // PPC64 Architecture Description File
   28 //
   29 
   30 //----------REGISTER DEFINITION BLOCK------------------------------------------
   31 // This information is used by the matcher and the register allocator to
   32 // describe individual registers and classes of registers within the target
   33 // architecture.
   34 register %{
   35 //----------Architecture Description Register Definitions----------------------
   36 // General Registers
   37 // &quot;reg_def&quot;  name (register save type, C convention save type,
   38 //                  ideal register type, encoding);
   39 //
   40 // Register Save Types:
   41 //
   42 //   NS  = No-Save:     The register allocator assumes that these registers
   43 //                      can be used without saving upon entry to the method, &amp;
   44 //                      that they do not need to be saved at call sites.
   45 //
   46 //   SOC = Save-On-Call: The register allocator assumes that these registers
   47 //                      can be used without saving upon entry to the method,
   48 //                      but that they must be saved at call sites.
   49 //                      These are called &quot;volatiles&quot; on ppc.
   50 //
   51 //   SOE = Save-On-Entry: The register allocator assumes that these registers
   52 //                      must be saved before using them upon entry to the
   53 //                      method, but they do not need to be saved at call
   54 //                      sites.
   55 //                      These are called &quot;nonvolatiles&quot; on ppc.
   56 //
   57 //   AS  = Always-Save:   The register allocator assumes that these registers
   58 //                      must be saved before using them upon entry to the
   59 //                      method, &amp; that they must be saved at call sites.
   60 //
   61 // Ideal Register Type is used to determine how to save &amp; restore a
   62 // register. Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   63 // spilled with LoadP/StoreP. If the register supports both, use Op_RegI.
   64 //
   65 // The encoding number is the actual bit-pattern placed into the opcodes.
   66 //
   67 // PPC64 register definitions, based on the 64-bit PowerPC ELF ABI
   68 // Supplement Version 1.7 as of 2003-10-29.
   69 //
   70 // For each 64-bit register we must define two registers: the register
   71 // itself, e.g. R3, and a corresponding virtual other (32-bit-)&#39;half&#39;,
   72 // e.g. R3_H, which is needed by the allocator, but is not used
   73 // for stores, loads, etc.
   74 
   75 // ----------------------------
   76 // Integer/Long Registers
   77 // ----------------------------
   78 
   79   // PPC64 has 32 64-bit integer registers.
   80 
   81   // types: v = volatile, nv = non-volatile, s = system
   82   reg_def R0   ( SOC, SOC, Op_RegI,  0, R0-&gt;as_VMReg()         );  // v   used in prologs
   83   reg_def R0_H ( SOC, SOC, Op_RegI, 99, R0-&gt;as_VMReg()-&gt;next() );
   84   reg_def R1   ( NS,  NS,  Op_RegI,  1, R1-&gt;as_VMReg()         );  // s   SP
   85   reg_def R1_H ( NS,  NS,  Op_RegI, 99, R1-&gt;as_VMReg()-&gt;next() );
   86   reg_def R2   ( SOC, SOC, Op_RegI,  2, R2-&gt;as_VMReg()         );  // v   TOC
   87   reg_def R2_H ( SOC, SOC, Op_RegI, 99, R2-&gt;as_VMReg()-&gt;next() );
   88   reg_def R3   ( SOC, SOC, Op_RegI,  3, R3-&gt;as_VMReg()         );  // v   iarg1 &amp; iret
   89   reg_def R3_H ( SOC, SOC, Op_RegI, 99, R3-&gt;as_VMReg()-&gt;next() );
   90   reg_def R4   ( SOC, SOC, Op_RegI,  4, R4-&gt;as_VMReg()         );  //     iarg2
   91   reg_def R4_H ( SOC, SOC, Op_RegI, 99, R4-&gt;as_VMReg()-&gt;next() );
   92   reg_def R5   ( SOC, SOC, Op_RegI,  5, R5-&gt;as_VMReg()         );  // v   iarg3
   93   reg_def R5_H ( SOC, SOC, Op_RegI, 99, R5-&gt;as_VMReg()-&gt;next() );
   94   reg_def R6   ( SOC, SOC, Op_RegI,  6, R6-&gt;as_VMReg()         );  // v   iarg4
   95   reg_def R6_H ( SOC, SOC, Op_RegI, 99, R6-&gt;as_VMReg()-&gt;next() );
   96   reg_def R7   ( SOC, SOC, Op_RegI,  7, R7-&gt;as_VMReg()         );  // v   iarg5
   97   reg_def R7_H ( SOC, SOC, Op_RegI, 99, R7-&gt;as_VMReg()-&gt;next() );
   98   reg_def R8   ( SOC, SOC, Op_RegI,  8, R8-&gt;as_VMReg()         );  // v   iarg6
   99   reg_def R8_H ( SOC, SOC, Op_RegI, 99, R8-&gt;as_VMReg()-&gt;next() );
  100   reg_def R9   ( SOC, SOC, Op_RegI,  9, R9-&gt;as_VMReg()         );  // v   iarg7
  101   reg_def R9_H ( SOC, SOC, Op_RegI, 99, R9-&gt;as_VMReg()-&gt;next() );
  102   reg_def R10  ( SOC, SOC, Op_RegI, 10, R10-&gt;as_VMReg()        );  // v   iarg8
  103   reg_def R10_H( SOC, SOC, Op_RegI, 99, R10-&gt;as_VMReg()-&gt;next());
  104   reg_def R11  ( SOC, SOC, Op_RegI, 11, R11-&gt;as_VMReg()        );  // v   ENV / scratch
  105   reg_def R11_H( SOC, SOC, Op_RegI, 99, R11-&gt;as_VMReg()-&gt;next());
  106   reg_def R12  ( SOC, SOC, Op_RegI, 12, R12-&gt;as_VMReg()        );  // v   scratch
  107   reg_def R12_H( SOC, SOC, Op_RegI, 99, R12-&gt;as_VMReg()-&gt;next());
  108   reg_def R13  ( NS,  NS,  Op_RegI, 13, R13-&gt;as_VMReg()        );  // s   system thread id
  109   reg_def R13_H( NS,  NS,  Op_RegI, 99, R13-&gt;as_VMReg()-&gt;next());
  110   reg_def R14  ( SOC, SOE, Op_RegI, 14, R14-&gt;as_VMReg()        );  // nv
  111   reg_def R14_H( SOC, SOE, Op_RegI, 99, R14-&gt;as_VMReg()-&gt;next());
  112   reg_def R15  ( SOC, SOE, Op_RegI, 15, R15-&gt;as_VMReg()        );  // nv
  113   reg_def R15_H( SOC, SOE, Op_RegI, 99, R15-&gt;as_VMReg()-&gt;next());
  114   reg_def R16  ( SOC, SOE, Op_RegI, 16, R16-&gt;as_VMReg()        );  // nv
  115   reg_def R16_H( SOC, SOE, Op_RegI, 99, R16-&gt;as_VMReg()-&gt;next());
  116   reg_def R17  ( SOC, SOE, Op_RegI, 17, R17-&gt;as_VMReg()        );  // nv
  117   reg_def R17_H( SOC, SOE, Op_RegI, 99, R17-&gt;as_VMReg()-&gt;next());
  118   reg_def R18  ( SOC, SOE, Op_RegI, 18, R18-&gt;as_VMReg()        );  // nv
  119   reg_def R18_H( SOC, SOE, Op_RegI, 99, R18-&gt;as_VMReg()-&gt;next());
  120   reg_def R19  ( SOC, SOE, Op_RegI, 19, R19-&gt;as_VMReg()        );  // nv
  121   reg_def R19_H( SOC, SOE, Op_RegI, 99, R19-&gt;as_VMReg()-&gt;next());
  122   reg_def R20  ( SOC, SOE, Op_RegI, 20, R20-&gt;as_VMReg()        );  // nv
  123   reg_def R20_H( SOC, SOE, Op_RegI, 99, R20-&gt;as_VMReg()-&gt;next());
  124   reg_def R21  ( SOC, SOE, Op_RegI, 21, R21-&gt;as_VMReg()        );  // nv
  125   reg_def R21_H( SOC, SOE, Op_RegI, 99, R21-&gt;as_VMReg()-&gt;next());
  126   reg_def R22  ( SOC, SOE, Op_RegI, 22, R22-&gt;as_VMReg()        );  // nv
  127   reg_def R22_H( SOC, SOE, Op_RegI, 99, R22-&gt;as_VMReg()-&gt;next());
  128   reg_def R23  ( SOC, SOE, Op_RegI, 23, R23-&gt;as_VMReg()        );  // nv
  129   reg_def R23_H( SOC, SOE, Op_RegI, 99, R23-&gt;as_VMReg()-&gt;next());
  130   reg_def R24  ( SOC, SOE, Op_RegI, 24, R24-&gt;as_VMReg()        );  // nv
  131   reg_def R24_H( SOC, SOE, Op_RegI, 99, R24-&gt;as_VMReg()-&gt;next());
  132   reg_def R25  ( SOC, SOE, Op_RegI, 25, R25-&gt;as_VMReg()        );  // nv
  133   reg_def R25_H( SOC, SOE, Op_RegI, 99, R25-&gt;as_VMReg()-&gt;next());
  134   reg_def R26  ( SOC, SOE, Op_RegI, 26, R26-&gt;as_VMReg()        );  // nv
  135   reg_def R26_H( SOC, SOE, Op_RegI, 99, R26-&gt;as_VMReg()-&gt;next());
  136   reg_def R27  ( SOC, SOE, Op_RegI, 27, R27-&gt;as_VMReg()        );  // nv
  137   reg_def R27_H( SOC, SOE, Op_RegI, 99, R27-&gt;as_VMReg()-&gt;next());
  138   reg_def R28  ( SOC, SOE, Op_RegI, 28, R28-&gt;as_VMReg()        );  // nv
  139   reg_def R28_H( SOC, SOE, Op_RegI, 99, R28-&gt;as_VMReg()-&gt;next());
  140   reg_def R29  ( SOC, SOE, Op_RegI, 29, R29-&gt;as_VMReg()        );  // nv
  141   reg_def R29_H( SOC, SOE, Op_RegI, 99, R29-&gt;as_VMReg()-&gt;next());
  142   reg_def R30  ( SOC, SOE, Op_RegI, 30, R30-&gt;as_VMReg()        );  // nv
  143   reg_def R30_H( SOC, SOE, Op_RegI, 99, R30-&gt;as_VMReg()-&gt;next());
  144   reg_def R31  ( SOC, SOE, Op_RegI, 31, R31-&gt;as_VMReg()        );  // nv
  145   reg_def R31_H( SOC, SOE, Op_RegI, 99, R31-&gt;as_VMReg()-&gt;next());
  146 
  147 
  148 // ----------------------------
  149 // Float/Double Registers
  150 // ----------------------------
  151 
  152   // Double Registers
  153   // The rules of ADL require that double registers be defined in pairs.
  154   // Each pair must be two 32-bit values, but not necessarily a pair of
  155   // single float registers. In each pair, ADLC-assigned register numbers
  156   // must be adjacent, with the lower number even. Finally, when the
  157   // CPU stores such a register pair to memory, the word associated with
  158   // the lower ADLC-assigned number must be stored to the lower address.
  159 
  160   // PPC64 has 32 64-bit floating-point registers. Each can store a single
  161   // or double precision floating-point value.
  162 
  163   // types: v = volatile, nv = non-volatile, s = system
  164   reg_def F0   ( SOC, SOC, Op_RegF,  0, F0-&gt;as_VMReg()         );  // v   scratch
  165   reg_def F0_H ( SOC, SOC, Op_RegF, 99, F0-&gt;as_VMReg()-&gt;next() );
  166   reg_def F1   ( SOC, SOC, Op_RegF,  1, F1-&gt;as_VMReg()         );  // v   farg1 &amp; fret
  167   reg_def F1_H ( SOC, SOC, Op_RegF, 99, F1-&gt;as_VMReg()-&gt;next() );
  168   reg_def F2   ( SOC, SOC, Op_RegF,  2, F2-&gt;as_VMReg()         );  // v   farg2
  169   reg_def F2_H ( SOC, SOC, Op_RegF, 99, F2-&gt;as_VMReg()-&gt;next() );
  170   reg_def F3   ( SOC, SOC, Op_RegF,  3, F3-&gt;as_VMReg()         );  // v   farg3
  171   reg_def F3_H ( SOC, SOC, Op_RegF, 99, F3-&gt;as_VMReg()-&gt;next() );
  172   reg_def F4   ( SOC, SOC, Op_RegF,  4, F4-&gt;as_VMReg()         );  // v   farg4
  173   reg_def F4_H ( SOC, SOC, Op_RegF, 99, F4-&gt;as_VMReg()-&gt;next() );
  174   reg_def F5   ( SOC, SOC, Op_RegF,  5, F5-&gt;as_VMReg()         );  // v   farg5
  175   reg_def F5_H ( SOC, SOC, Op_RegF, 99, F5-&gt;as_VMReg()-&gt;next() );
  176   reg_def F6   ( SOC, SOC, Op_RegF,  6, F6-&gt;as_VMReg()         );  // v   farg6
  177   reg_def F6_H ( SOC, SOC, Op_RegF, 99, F6-&gt;as_VMReg()-&gt;next() );
  178   reg_def F7   ( SOC, SOC, Op_RegF,  7, F7-&gt;as_VMReg()         );  // v   farg7
  179   reg_def F7_H ( SOC, SOC, Op_RegF, 99, F7-&gt;as_VMReg()-&gt;next() );
  180   reg_def F8   ( SOC, SOC, Op_RegF,  8, F8-&gt;as_VMReg()         );  // v   farg8
  181   reg_def F8_H ( SOC, SOC, Op_RegF, 99, F8-&gt;as_VMReg()-&gt;next() );
  182   reg_def F9   ( SOC, SOC, Op_RegF,  9, F9-&gt;as_VMReg()         );  // v   farg9
  183   reg_def F9_H ( SOC, SOC, Op_RegF, 99, F9-&gt;as_VMReg()-&gt;next() );
  184   reg_def F10  ( SOC, SOC, Op_RegF, 10, F10-&gt;as_VMReg()        );  // v   farg10
  185   reg_def F10_H( SOC, SOC, Op_RegF, 99, F10-&gt;as_VMReg()-&gt;next());
  186   reg_def F11  ( SOC, SOC, Op_RegF, 11, F11-&gt;as_VMReg()        );  // v   farg11
  187   reg_def F11_H( SOC, SOC, Op_RegF, 99, F11-&gt;as_VMReg()-&gt;next());
  188   reg_def F12  ( SOC, SOC, Op_RegF, 12, F12-&gt;as_VMReg()        );  // v   farg12
  189   reg_def F12_H( SOC, SOC, Op_RegF, 99, F12-&gt;as_VMReg()-&gt;next());
  190   reg_def F13  ( SOC, SOC, Op_RegF, 13, F13-&gt;as_VMReg()        );  // v   farg13
  191   reg_def F13_H( SOC, SOC, Op_RegF, 99, F13-&gt;as_VMReg()-&gt;next());
  192   reg_def F14  ( SOC, SOE, Op_RegF, 14, F14-&gt;as_VMReg()        );  // nv
  193   reg_def F14_H( SOC, SOE, Op_RegF, 99, F14-&gt;as_VMReg()-&gt;next());
  194   reg_def F15  ( SOC, SOE, Op_RegF, 15, F15-&gt;as_VMReg()        );  // nv
  195   reg_def F15_H( SOC, SOE, Op_RegF, 99, F15-&gt;as_VMReg()-&gt;next());
  196   reg_def F16  ( SOC, SOE, Op_RegF, 16, F16-&gt;as_VMReg()        );  // nv
  197   reg_def F16_H( SOC, SOE, Op_RegF, 99, F16-&gt;as_VMReg()-&gt;next());
  198   reg_def F17  ( SOC, SOE, Op_RegF, 17, F17-&gt;as_VMReg()        );  // nv
  199   reg_def F17_H( SOC, SOE, Op_RegF, 99, F17-&gt;as_VMReg()-&gt;next());
  200   reg_def F18  ( SOC, SOE, Op_RegF, 18, F18-&gt;as_VMReg()        );  // nv
  201   reg_def F18_H( SOC, SOE, Op_RegF, 99, F18-&gt;as_VMReg()-&gt;next());
  202   reg_def F19  ( SOC, SOE, Op_RegF, 19, F19-&gt;as_VMReg()        );  // nv
  203   reg_def F19_H( SOC, SOE, Op_RegF, 99, F19-&gt;as_VMReg()-&gt;next());
  204   reg_def F20  ( SOC, SOE, Op_RegF, 20, F20-&gt;as_VMReg()        );  // nv
  205   reg_def F20_H( SOC, SOE, Op_RegF, 99, F20-&gt;as_VMReg()-&gt;next());
  206   reg_def F21  ( SOC, SOE, Op_RegF, 21, F21-&gt;as_VMReg()        );  // nv
  207   reg_def F21_H( SOC, SOE, Op_RegF, 99, F21-&gt;as_VMReg()-&gt;next());
  208   reg_def F22  ( SOC, SOE, Op_RegF, 22, F22-&gt;as_VMReg()        );  // nv
  209   reg_def F22_H( SOC, SOE, Op_RegF, 99, F22-&gt;as_VMReg()-&gt;next());
  210   reg_def F23  ( SOC, SOE, Op_RegF, 23, F23-&gt;as_VMReg()        );  // nv
  211   reg_def F23_H( SOC, SOE, Op_RegF, 99, F23-&gt;as_VMReg()-&gt;next());
  212   reg_def F24  ( SOC, SOE, Op_RegF, 24, F24-&gt;as_VMReg()        );  // nv
  213   reg_def F24_H( SOC, SOE, Op_RegF, 99, F24-&gt;as_VMReg()-&gt;next());
  214   reg_def F25  ( SOC, SOE, Op_RegF, 25, F25-&gt;as_VMReg()        );  // nv
  215   reg_def F25_H( SOC, SOE, Op_RegF, 99, F25-&gt;as_VMReg()-&gt;next());
  216   reg_def F26  ( SOC, SOE, Op_RegF, 26, F26-&gt;as_VMReg()        );  // nv
  217   reg_def F26_H( SOC, SOE, Op_RegF, 99, F26-&gt;as_VMReg()-&gt;next());
  218   reg_def F27  ( SOC, SOE, Op_RegF, 27, F27-&gt;as_VMReg()        );  // nv
  219   reg_def F27_H( SOC, SOE, Op_RegF, 99, F27-&gt;as_VMReg()-&gt;next());
  220   reg_def F28  ( SOC, SOE, Op_RegF, 28, F28-&gt;as_VMReg()        );  // nv
  221   reg_def F28_H( SOC, SOE, Op_RegF, 99, F28-&gt;as_VMReg()-&gt;next());
  222   reg_def F29  ( SOC, SOE, Op_RegF, 29, F29-&gt;as_VMReg()        );  // nv
  223   reg_def F29_H( SOC, SOE, Op_RegF, 99, F29-&gt;as_VMReg()-&gt;next());
  224   reg_def F30  ( SOC, SOE, Op_RegF, 30, F30-&gt;as_VMReg()        );  // nv
  225   reg_def F30_H( SOC, SOE, Op_RegF, 99, F30-&gt;as_VMReg()-&gt;next());
  226   reg_def F31  ( SOC, SOE, Op_RegF, 31, F31-&gt;as_VMReg()        );  // nv
  227   reg_def F31_H( SOC, SOE, Op_RegF, 99, F31-&gt;as_VMReg()-&gt;next());
  228 
  229 // ----------------------------
  230 // Special Registers
  231 // ----------------------------
  232 
  233 // Condition Codes Flag Registers
  234 
  235   // PPC64 has 8 condition code &quot;registers&quot; which are all contained
  236   // in the CR register.
  237 
  238   // types: v = volatile, nv = non-volatile, s = system
  239   reg_def CCR0(SOC, SOC, Op_RegFlags, 0, CCR0-&gt;as_VMReg());  // v
  240   reg_def CCR1(SOC, SOC, Op_RegFlags, 1, CCR1-&gt;as_VMReg());  // v
  241   reg_def CCR2(SOC, SOC, Op_RegFlags, 2, CCR2-&gt;as_VMReg());  // nv
  242   reg_def CCR3(SOC, SOC, Op_RegFlags, 3, CCR3-&gt;as_VMReg());  // nv
  243   reg_def CCR4(SOC, SOC, Op_RegFlags, 4, CCR4-&gt;as_VMReg());  // nv
  244   reg_def CCR5(SOC, SOC, Op_RegFlags, 5, CCR5-&gt;as_VMReg());  // v
  245   reg_def CCR6(SOC, SOC, Op_RegFlags, 6, CCR6-&gt;as_VMReg());  // v
  246   reg_def CCR7(SOC, SOC, Op_RegFlags, 7, CCR7-&gt;as_VMReg());  // v
  247 
  248   // Special registers of PPC64
  249 
  250   reg_def SR_XER(    SOC, SOC, Op_RegP, 0, SR_XER-&gt;as_VMReg());     // v
  251   reg_def SR_LR(     SOC, SOC, Op_RegP, 1, SR_LR-&gt;as_VMReg());      // v
  252   reg_def SR_CTR(    SOC, SOC, Op_RegP, 2, SR_CTR-&gt;as_VMReg());     // v
  253   reg_def SR_VRSAVE( SOC, SOC, Op_RegP, 3, SR_VRSAVE-&gt;as_VMReg());  // v
  254   reg_def SR_SPEFSCR(SOC, SOC, Op_RegP, 4, SR_SPEFSCR-&gt;as_VMReg()); // v
  255   reg_def SR_PPR(    SOC, SOC, Op_RegP, 5, SR_PPR-&gt;as_VMReg());     // v
  256 
  257 // ----------------------------
  258 // Vector-Scalar Registers
  259 // ----------------------------
  260   reg_def VSR0 ( SOC, SOC, Op_VecX, 0, NULL);
  261   reg_def VSR1 ( SOC, SOC, Op_VecX, 1, NULL);
  262   reg_def VSR2 ( SOC, SOC, Op_VecX, 2, NULL);
  263   reg_def VSR3 ( SOC, SOC, Op_VecX, 3, NULL);
  264   reg_def VSR4 ( SOC, SOC, Op_VecX, 4, NULL);
  265   reg_def VSR5 ( SOC, SOC, Op_VecX, 5, NULL);
  266   reg_def VSR6 ( SOC, SOC, Op_VecX, 6, NULL);
  267   reg_def VSR7 ( SOC, SOC, Op_VecX, 7, NULL);
  268   reg_def VSR8 ( SOC, SOC, Op_VecX, 8, NULL);
  269   reg_def VSR9 ( SOC, SOC, Op_VecX, 9, NULL);
  270   reg_def VSR10 ( SOC, SOC, Op_VecX, 10, NULL);
  271   reg_def VSR11 ( SOC, SOC, Op_VecX, 11, NULL);
  272   reg_def VSR12 ( SOC, SOC, Op_VecX, 12, NULL);
  273   reg_def VSR13 ( SOC, SOC, Op_VecX, 13, NULL);
  274   reg_def VSR14 ( SOC, SOC, Op_VecX, 14, NULL);
  275   reg_def VSR15 ( SOC, SOC, Op_VecX, 15, NULL);
  276   reg_def VSR16 ( SOC, SOC, Op_VecX, 16, NULL);
  277   reg_def VSR17 ( SOC, SOC, Op_VecX, 17, NULL);
  278   reg_def VSR18 ( SOC, SOC, Op_VecX, 18, NULL);
  279   reg_def VSR19 ( SOC, SOC, Op_VecX, 19, NULL);
  280   reg_def VSR20 ( SOC, SOC, Op_VecX, 20, NULL);
  281   reg_def VSR21 ( SOC, SOC, Op_VecX, 21, NULL);
  282   reg_def VSR22 ( SOC, SOC, Op_VecX, 22, NULL);
  283   reg_def VSR23 ( SOC, SOC, Op_VecX, 23, NULL);
  284   reg_def VSR24 ( SOC, SOC, Op_VecX, 24, NULL);
  285   reg_def VSR25 ( SOC, SOC, Op_VecX, 25, NULL);
  286   reg_def VSR26 ( SOC, SOC, Op_VecX, 26, NULL);
  287   reg_def VSR27 ( SOC, SOC, Op_VecX, 27, NULL);
  288   reg_def VSR28 ( SOC, SOC, Op_VecX, 28, NULL);
  289   reg_def VSR29 ( SOC, SOC, Op_VecX, 29, NULL);
  290   reg_def VSR30 ( SOC, SOC, Op_VecX, 30, NULL);
  291   reg_def VSR31 ( SOC, SOC, Op_VecX, 31, NULL);
  292   reg_def VSR32 ( SOC, SOC, Op_VecX, 32, NULL);
  293   reg_def VSR33 ( SOC, SOC, Op_VecX, 33, NULL);
  294   reg_def VSR34 ( SOC, SOC, Op_VecX, 34, NULL);
  295   reg_def VSR35 ( SOC, SOC, Op_VecX, 35, NULL);
  296   reg_def VSR36 ( SOC, SOC, Op_VecX, 36, NULL);
  297   reg_def VSR37 ( SOC, SOC, Op_VecX, 37, NULL);
  298   reg_def VSR38 ( SOC, SOC, Op_VecX, 38, NULL);
  299   reg_def VSR39 ( SOC, SOC, Op_VecX, 39, NULL);
  300   reg_def VSR40 ( SOC, SOC, Op_VecX, 40, NULL);
  301   reg_def VSR41 ( SOC, SOC, Op_VecX, 41, NULL);
  302   reg_def VSR42 ( SOC, SOC, Op_VecX, 42, NULL);
  303   reg_def VSR43 ( SOC, SOC, Op_VecX, 43, NULL);
  304   reg_def VSR44 ( SOC, SOC, Op_VecX, 44, NULL);
  305   reg_def VSR45 ( SOC, SOC, Op_VecX, 45, NULL);
  306   reg_def VSR46 ( SOC, SOC, Op_VecX, 46, NULL);
  307   reg_def VSR47 ( SOC, SOC, Op_VecX, 47, NULL);
  308   reg_def VSR48 ( SOC, SOC, Op_VecX, 48, NULL);
  309   reg_def VSR49 ( SOC, SOC, Op_VecX, 49, NULL);
  310   reg_def VSR50 ( SOC, SOC, Op_VecX, 50, NULL);
  311   reg_def VSR51 ( SOC, SOC, Op_VecX, 51, NULL);
  312   reg_def VSR52 ( SOC, SOC, Op_VecX, 52, NULL);
  313   reg_def VSR53 ( SOC, SOC, Op_VecX, 53, NULL);
  314   reg_def VSR54 ( SOC, SOC, Op_VecX, 54, NULL);
  315   reg_def VSR55 ( SOC, SOC, Op_VecX, 55, NULL);
  316   reg_def VSR56 ( SOC, SOC, Op_VecX, 56, NULL);
  317   reg_def VSR57 ( SOC, SOC, Op_VecX, 57, NULL);
  318   reg_def VSR58 ( SOC, SOC, Op_VecX, 58, NULL);
  319   reg_def VSR59 ( SOC, SOC, Op_VecX, 59, NULL);
  320   reg_def VSR60 ( SOC, SOC, Op_VecX, 60, NULL);
  321   reg_def VSR61 ( SOC, SOC, Op_VecX, 61, NULL);
  322   reg_def VSR62 ( SOC, SOC, Op_VecX, 62, NULL);
  323   reg_def VSR63 ( SOC, SOC, Op_VecX, 63, NULL);
  324 
  325 // ----------------------------
  326 // Specify priority of register selection within phases of register
  327 // allocation. Highest priority is first. A useful heuristic is to
  328 // give registers a low priority when they are required by machine
  329 // instructions, like EAX and EDX on I486, and choose no-save registers
  330 // before save-on-call, &amp; save-on-call before save-on-entry. Registers
  331 // which participate in fixed calling sequences should come last.
  332 // Registers which are used as pairs must fall on an even boundary.
  333 
  334 // It&#39;s worth about 1% on SPEC geomean to get this right.
  335 
  336 // Chunk0, chunk1, and chunk2 form the MachRegisterNumbers enumeration
  337 // in adGlobals_ppc.hpp which defines the &lt;register&gt;_num values, e.g.
  338 // R3_num. Therefore, R3_num may not be (and in reality is not)
  339 // the same as R3-&gt;encoding()! Furthermore, we cannot make any
  340 // assumptions on ordering, e.g. R3_num may be less than R2_num.
  341 // Additionally, the function
  342 //   static enum RC rc_class(OptoReg::Name reg )
  343 // maps a given &lt;register&gt;_num value to its chunk type (except for flags)
  344 // and its current implementation relies on chunk0 and chunk1 having a
  345 // size of 64 each.
  346 
  347 // If you change this allocation class, please have a look at the
  348 // default values for the parameters RoundRobinIntegerRegIntervalStart
  349 // and RoundRobinFloatRegIntervalStart
  350 
  351 alloc_class chunk0 (
  352   // Chunk0 contains *all* 64 integer registers halves.
  353 
  354   // &quot;non-volatile&quot; registers
  355   R14, R14_H,
  356   R15, R15_H,
  357   R17, R17_H,
  358   R18, R18_H,
  359   R19, R19_H,
  360   R20, R20_H,
  361   R21, R21_H,
  362   R22, R22_H,
  363   R23, R23_H,
  364   R24, R24_H,
  365   R25, R25_H,
  366   R26, R26_H,
  367   R27, R27_H,
  368   R28, R28_H,
  369   R29, R29_H,
  370   R30, R30_H,
  371   R31, R31_H,
  372 
  373   // scratch/special registers
  374   R11, R11_H,
  375   R12, R12_H,
  376 
  377   // argument registers
  378   R10, R10_H,
  379   R9,  R9_H,
  380   R8,  R8_H,
  381   R7,  R7_H,
  382   R6,  R6_H,
  383   R5,  R5_H,
  384   R4,  R4_H,
  385   R3,  R3_H,
  386 
  387   // special registers, not available for allocation
  388   R16, R16_H,     // R16_thread
  389   R13, R13_H,     // system thread id
  390   R2,  R2_H,      // may be used for TOC
  391   R1,  R1_H,      // SP
  392   R0,  R0_H       // R0 (scratch)
  393 );
  394 
  395 // If you change this allocation class, please have a look at the
  396 // default values for the parameters RoundRobinIntegerRegIntervalStart
  397 // and RoundRobinFloatRegIntervalStart
  398 
  399 alloc_class chunk1 (
  400   // Chunk1 contains *all* 64 floating-point registers halves.
  401 
  402   // scratch register
  403   F0,  F0_H,
  404 
  405   // argument registers
  406   F13, F13_H,
  407   F12, F12_H,
  408   F11, F11_H,
  409   F10, F10_H,
  410   F9,  F9_H,
  411   F8,  F8_H,
  412   F7,  F7_H,
  413   F6,  F6_H,
  414   F5,  F5_H,
  415   F4,  F4_H,
  416   F3,  F3_H,
  417   F2,  F2_H,
  418   F1,  F1_H,
  419 
  420   // non-volatile registers
  421   F14, F14_H,
  422   F15, F15_H,
  423   F16, F16_H,
  424   F17, F17_H,
  425   F18, F18_H,
  426   F19, F19_H,
  427   F20, F20_H,
  428   F21, F21_H,
  429   F22, F22_H,
  430   F23, F23_H,
  431   F24, F24_H,
  432   F25, F25_H,
  433   F26, F26_H,
  434   F27, F27_H,
  435   F28, F28_H,
  436   F29, F29_H,
  437   F30, F30_H,
  438   F31, F31_H
  439 );
  440 
  441 alloc_class chunk2 (
  442   // Chunk2 contains *all* 8 condition code registers.
  443 
  444   CCR0,
  445   CCR1,
  446   CCR2,
  447   CCR3,
  448   CCR4,
  449   CCR5,
  450   CCR6,
  451   CCR7
  452 );
  453 
  454 alloc_class chunk3 (
  455   VSR0,
  456   VSR1,
  457   VSR2,
  458   VSR3,
  459   VSR4,
  460   VSR5,
  461   VSR6,
  462   VSR7,
  463   VSR8,
  464   VSR9,
  465   VSR10,
  466   VSR11,
  467   VSR12,
  468   VSR13,
  469   VSR14,
  470   VSR15,
  471   VSR16,
  472   VSR17,
  473   VSR18,
  474   VSR19,
  475   VSR20,
  476   VSR21,
  477   VSR22,
  478   VSR23,
  479   VSR24,
  480   VSR25,
  481   VSR26,
  482   VSR27,
  483   VSR28,
  484   VSR29,
  485   VSR30,
  486   VSR31,
  487   VSR32,
  488   VSR33,
  489   VSR34,
  490   VSR35,
  491   VSR36,
  492   VSR37,
  493   VSR38,
  494   VSR39,
  495   VSR40,
  496   VSR41,
  497   VSR42,
  498   VSR43,
  499   VSR44,
  500   VSR45,
  501   VSR46,
  502   VSR47,
  503   VSR48,
  504   VSR49,
  505   VSR50,
  506   VSR51,
  507   VSR52,
  508   VSR53,
  509   VSR54,
  510   VSR55,
  511   VSR56,
  512   VSR57,
  513   VSR58,
  514   VSR59,
  515   VSR60,
  516   VSR61,
  517   VSR62,
  518   VSR63
  519 );
  520 
  521 alloc_class chunk4 (
  522   // special registers
  523   // These registers are not allocated, but used for nodes generated by postalloc expand.
  524   SR_XER,
  525   SR_LR,
  526   SR_CTR,
  527   SR_VRSAVE,
  528   SR_SPEFSCR,
  529   SR_PPR
  530 );
  531 
  532 //-------Architecture Description Register Classes-----------------------
  533 
  534 // Several register classes are automatically defined based upon
  535 // information in this architecture description.
  536 
  537 // 1) reg_class inline_cache_reg           ( as defined in frame section )
  538 // 2) reg_class compiler_method_oop_reg    ( as defined in frame section )
  539 // 2) reg_class interpreter_method_oop_reg ( as defined in frame section )
  540 // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
  541 //
  542 
  543 // ----------------------------
  544 // 32 Bit Register Classes
  545 // ----------------------------
  546 
  547 // We specify registers twice, once as read/write, and once read-only.
  548 // We use the read-only registers for source operands. With this, we
  549 // can include preset read only registers in this class, as a hard-coded
  550 // &#39;0&#39;-register. (We used to simulate this on ppc.)
  551 
  552 // 32 bit registers that can be read and written i.e. these registers
  553 // can be dest (or src) of normal instructions.
  554 reg_class bits32_reg_rw(
  555 /*R0*/              // R0
  556 /*R1*/              // SP
  557   R2,               // TOC
  558   R3,
  559   R4,
  560   R5,
  561   R6,
  562   R7,
  563   R8,
  564   R9,
  565   R10,
  566   R11,
  567   R12,
  568 /*R13*/             // system thread id
  569   R14,
  570   R15,
  571 /*R16*/             // R16_thread
  572   R17,
  573   R18,
  574   R19,
  575   R20,
  576   R21,
  577   R22,
  578   R23,
  579   R24,
  580   R25,
  581   R26,
  582   R27,
  583   R28,
  584 /*R29,*/             // global TOC
  585   R30,
  586   R31
  587 );
  588 
  589 // 32 bit registers that can only be read i.e. these registers can
  590 // only be src of all instructions.
  591 reg_class bits32_reg_ro(
  592 /*R0*/              // R0
  593 /*R1*/              // SP
  594   R2                // TOC
  595   R3,
  596   R4,
  597   R5,
  598   R6,
  599   R7,
  600   R8,
  601   R9,
  602   R10,
  603   R11,
  604   R12,
  605 /*R13*/             // system thread id
  606   R14,
  607   R15,
  608 /*R16*/             // R16_thread
  609   R17,
  610   R18,
  611   R19,
  612   R20,
  613   R21,
  614   R22,
  615   R23,
  616   R24,
  617   R25,
  618   R26,
  619   R27,
  620   R28,
  621 /*R29,*/
  622   R30,
  623   R31
  624 );
  625 
  626 reg_class rscratch1_bits32_reg(R11);
  627 reg_class rscratch2_bits32_reg(R12);
  628 reg_class rarg1_bits32_reg(R3);
  629 reg_class rarg2_bits32_reg(R4);
  630 reg_class rarg3_bits32_reg(R5);
  631 reg_class rarg4_bits32_reg(R6);
  632 
  633 // ----------------------------
  634 // 64 Bit Register Classes
  635 // ----------------------------
  636 // 64-bit build means 64-bit pointers means hi/lo pairs
  637 
  638 reg_class rscratch1_bits64_reg(R11_H, R11);
  639 reg_class rscratch2_bits64_reg(R12_H, R12);
  640 reg_class rarg1_bits64_reg(R3_H, R3);
  641 reg_class rarg2_bits64_reg(R4_H, R4);
  642 reg_class rarg3_bits64_reg(R5_H, R5);
  643 reg_class rarg4_bits64_reg(R6_H, R6);
  644 // Thread register, &#39;written&#39; by tlsLoadP, see there.
  645 reg_class thread_bits64_reg(R16_H, R16);
  646 
  647 reg_class r19_bits64_reg(R19_H, R19);
  648 
  649 // 64 bit registers that can be read and written i.e. these registers
  650 // can be dest (or src) of normal instructions.
  651 reg_class bits64_reg_rw(
  652 /*R0_H,  R0*/     // R0
  653 /*R1_H,  R1*/     // SP
  654   R2_H,  R2,      // TOC
  655   R3_H,  R3,
  656   R4_H,  R4,
  657   R5_H,  R5,
  658   R6_H,  R6,
  659   R7_H,  R7,
  660   R8_H,  R8,
  661   R9_H,  R9,
  662   R10_H, R10,
  663   R11_H, R11,
  664   R12_H, R12,
  665 /*R13_H, R13*/   // system thread id
  666   R14_H, R14,
  667   R15_H, R15,
  668 /*R16_H, R16*/   // R16_thread
  669   R17_H, R17,
  670   R18_H, R18,
  671   R19_H, R19,
  672   R20_H, R20,
  673   R21_H, R21,
  674   R22_H, R22,
  675   R23_H, R23,
  676   R24_H, R24,
  677   R25_H, R25,
  678   R26_H, R26,
  679   R27_H, R27,
  680   R28_H, R28,
  681 /*R29_H, R29,*/
  682   R30_H, R30,
  683   R31_H, R31
  684 );
  685 
  686 // 64 bit registers used excluding r2, r11 and r12
  687 // Used to hold the TOC to avoid collisions with expanded LeafCall which uses
  688 // r2, r11 and r12 internally.
  689 reg_class bits64_reg_leaf_call(
  690 /*R0_H,  R0*/     // R0
  691 /*R1_H,  R1*/     // SP
  692 /*R2_H,  R2*/     // TOC
  693   R3_H,  R3,
  694   R4_H,  R4,
  695   R5_H,  R5,
  696   R6_H,  R6,
  697   R7_H,  R7,
  698   R8_H,  R8,
  699   R9_H,  R9,
  700   R10_H, R10,
  701 /*R11_H, R11*/
  702 /*R12_H, R12*/
  703 /*R13_H, R13*/   // system thread id
  704   R14_H, R14,
  705   R15_H, R15,
  706 /*R16_H, R16*/   // R16_thread
  707   R17_H, R17,
  708   R18_H, R18,
  709   R19_H, R19,
  710   R20_H, R20,
  711   R21_H, R21,
  712   R22_H, R22,
  713   R23_H, R23,
  714   R24_H, R24,
  715   R25_H, R25,
  716   R26_H, R26,
  717   R27_H, R27,
  718   R28_H, R28,
  719 /*R29_H, R29,*/
  720   R30_H, R30,
  721   R31_H, R31
  722 );
  723 
  724 // Used to hold the TOC to avoid collisions with expanded DynamicCall
  725 // which uses r19 as inline cache internally and expanded LeafCall which uses
  726 // r2, r11 and r12 internally.
  727 reg_class bits64_constant_table_base(
  728 /*R0_H,  R0*/     // R0
  729 /*R1_H,  R1*/     // SP
  730 /*R2_H,  R2*/     // TOC
  731   R3_H,  R3,
  732   R4_H,  R4,
  733   R5_H,  R5,
  734   R6_H,  R6,
  735   R7_H,  R7,
  736   R8_H,  R8,
  737   R9_H,  R9,
  738   R10_H, R10,
  739 /*R11_H, R11*/
  740 /*R12_H, R12*/
  741 /*R13_H, R13*/   // system thread id
  742   R14_H, R14,
  743   R15_H, R15,
  744 /*R16_H, R16*/   // R16_thread
  745   R17_H, R17,
  746   R18_H, R18,
  747 /*R19_H, R19*/
  748   R20_H, R20,
  749   R21_H, R21,
  750   R22_H, R22,
  751   R23_H, R23,
  752   R24_H, R24,
  753   R25_H, R25,
  754   R26_H, R26,
  755   R27_H, R27,
  756   R28_H, R28,
  757 /*R29_H, R29,*/
  758   R30_H, R30,
  759   R31_H, R31
  760 );
  761 
  762 // 64 bit registers that can only be read i.e. these registers can
  763 // only be src of all instructions.
  764 reg_class bits64_reg_ro(
  765 /*R0_H,  R0*/     // R0
  766   R1_H,  R1,
  767   R2_H,  R2,       // TOC
  768   R3_H,  R3,
  769   R4_H,  R4,
  770   R5_H,  R5,
  771   R6_H,  R6,
  772   R7_H,  R7,
  773   R8_H,  R8,
  774   R9_H,  R9,
  775   R10_H, R10,
  776   R11_H, R11,
  777   R12_H, R12,
  778 /*R13_H, R13*/   // system thread id
  779   R14_H, R14,
  780   R15_H, R15,
  781   R16_H, R16,    // R16_thread
  782   R17_H, R17,
  783   R18_H, R18,
  784   R19_H, R19,
  785   R20_H, R20,
  786   R21_H, R21,
  787   R22_H, R22,
  788   R23_H, R23,
  789   R24_H, R24,
  790   R25_H, R25,
  791   R26_H, R26,
  792   R27_H, R27,
  793   R28_H, R28,
  794 /*R29_H, R29,*/ // TODO: let allocator handle TOC!!
  795   R30_H, R30,
  796   R31_H, R31
  797 );
  798 
  799 
  800 // ----------------------------
  801 // Special Class for Condition Code Flags Register
  802 
  803 reg_class int_flags(
  804 /*CCR0*/             // scratch
  805 /*CCR1*/             // scratch
  806 /*CCR2*/             // nv!
  807 /*CCR3*/             // nv!
  808 /*CCR4*/             // nv!
  809   CCR5,
  810   CCR6,
  811   CCR7
  812 );
  813 
  814 reg_class int_flags_ro(
  815   CCR0,
  816   CCR1,
  817   CCR2,
  818   CCR3,
  819   CCR4,
  820   CCR5,
  821   CCR6,
  822   CCR7
  823 );
  824 
  825 reg_class int_flags_CR0(CCR0);
  826 reg_class int_flags_CR1(CCR1);
  827 reg_class int_flags_CR6(CCR6);
  828 reg_class ctr_reg(SR_CTR);
  829 
  830 // ----------------------------
  831 // Float Register Classes
  832 // ----------------------------
  833 
  834 reg_class flt_reg(
  835   F0,
  836   F1,
  837   F2,
  838   F3,
  839   F4,
  840   F5,
  841   F6,
  842   F7,
  843   F8,
  844   F9,
  845   F10,
  846   F11,
  847   F12,
  848   F13,
  849   F14,              // nv!
  850   F15,              // nv!
  851   F16,              // nv!
  852   F17,              // nv!
  853   F18,              // nv!
  854   F19,              // nv!
  855   F20,              // nv!
  856   F21,              // nv!
  857   F22,              // nv!
  858   F23,              // nv!
  859   F24,              // nv!
  860   F25,              // nv!
  861   F26,              // nv!
  862   F27,              // nv!
  863   F28,              // nv!
  864   F29,              // nv!
  865   F30,              // nv!
  866   F31               // nv!
  867 );
  868 
  869 // Double precision float registers have virtual `high halves&#39; that
  870 // are needed by the allocator.
  871 reg_class dbl_reg(
  872   F0,  F0_H,
  873   F1,  F1_H,
  874   F2,  F2_H,
  875   F3,  F3_H,
  876   F4,  F4_H,
  877   F5,  F5_H,
  878   F6,  F6_H,
  879   F7,  F7_H,
  880   F8,  F8_H,
  881   F9,  F9_H,
  882   F10, F10_H,
  883   F11, F11_H,
  884   F12, F12_H,
  885   F13, F13_H,
  886   F14, F14_H,    // nv!
  887   F15, F15_H,    // nv!
  888   F16, F16_H,    // nv!
  889   F17, F17_H,    // nv!
  890   F18, F18_H,    // nv!
  891   F19, F19_H,    // nv!
  892   F20, F20_H,    // nv!
  893   F21, F21_H,    // nv!
  894   F22, F22_H,    // nv!
  895   F23, F23_H,    // nv!
  896   F24, F24_H,    // nv!
  897   F25, F25_H,    // nv!
  898   F26, F26_H,    // nv!
  899   F27, F27_H,    // nv!
  900   F28, F28_H,    // nv!
  901   F29, F29_H,    // nv!
  902   F30, F30_H,    // nv!
  903   F31, F31_H     // nv!
  904 );
  905 
  906 // ----------------------------
  907 // Vector-Scalar Register Class
  908 // ----------------------------
  909 
  910 reg_class vs_reg(
  911   // Attention: Only these ones are saved &amp; restored at safepoint by RegisterSaver.
  912   VSR32,
  913   VSR33,
  914   VSR34,
  915   VSR35,
  916   VSR36,
  917   VSR37,
  918   VSR38,
  919   VSR39,
  920   VSR40,
  921   VSR41,
  922   VSR42,
  923   VSR43,
  924   VSR44,
  925   VSR45,
  926   VSR46,
  927   VSR47,
  928   VSR48,
  929   VSR49,
  930   VSR50,
  931   VSR51
  932   // VSR52-VSR63 // nv!
  933 );
  934 
  935  %}
  936 
  937 //----------DEFINITION BLOCK---------------------------------------------------
  938 // Define name --&gt; value mappings to inform the ADLC of an integer valued name
  939 // Current support includes integer values in the range [0, 0x7FFFFFFF]
  940 // Format:
  941 //        int_def  &lt;name&gt;         ( &lt;int_value&gt;, &lt;expression&gt;);
  942 // Generated Code in ad_&lt;arch&gt;.hpp
  943 //        #define  &lt;name&gt;   (&lt;expression&gt;)
  944 //        // value == &lt;int_value&gt;
  945 // Generated code in ad_&lt;arch&gt;.cpp adlc_verification()
  946 //        assert( &lt;name&gt; == &lt;int_value&gt;, &quot;Expect (&lt;expression&gt;) to equal &lt;int_value&gt;&quot;);
  947 //
  948 definitions %{
  949   // The default cost (of an ALU instruction).
  950   int_def DEFAULT_COST_LOW        (     30,      30);
  951   int_def DEFAULT_COST            (    100,     100);
  952   int_def HUGE_COST               (1000000, 1000000);
  953 
  954   // Memory refs
  955   int_def MEMORY_REF_COST_LOW     (    200, DEFAULT_COST * 2);
  956   int_def MEMORY_REF_COST         (    300, DEFAULT_COST * 3);
  957 
  958   // Branches are even more expensive.
  959   int_def BRANCH_COST             (    900, DEFAULT_COST * 9);
  960   int_def CALL_COST               (   1300, DEFAULT_COST * 13);
  961 %}
  962 
  963 
  964 //----------SOURCE BLOCK-------------------------------------------------------
  965 // This is a block of C++ code which provides values, functions, and
  966 // definitions necessary in the rest of the architecture description.
  967 source_hpp %{
  968   // Header information of the source block.
  969   // Method declarations/definitions which are used outside
  970   // the ad-scope can conveniently be defined here.
  971   //
  972   // To keep related declarations/definitions/uses close together,
  973   // we switch between source %{ }% and source_hpp %{ }% freely as needed.
  974 
  975 #include &quot;opto/convertnode.hpp&quot;
  976 
  977   // Returns true if Node n is followed by a MemBar node that
  978   // will do an acquire. If so, this node must not do the acquire
  979   // operation.
  980   bool followed_by_acquire(const Node *n);
  981 %}
  982 
  983 source %{
  984 
  985 // Should the Matcher clone shifts on addressing modes, expecting them
  986 // to be subsumed into complex addressing expressions or compute them
  987 // into registers?
  988 bool Matcher::clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {
  989   return clone_base_plus_offset_address(m, mstack, address_visited);
  990 }
  991 
  992 void Compile::reshape_address(AddPNode* addp) {
  993 }
  994 
  995 // Optimize load-acquire.
  996 //
  997 // Check if acquire is unnecessary due to following operation that does
  998 // acquire anyways.
  999 // Walk the pattern:
 1000 //
 1001 //      n: Load.acq
 1002 //           |
 1003 //      MemBarAcquire
 1004 //       |         |
 1005 //  Proj(ctrl)  Proj(mem)
 1006 //       |         |
 1007 //   MemBarRelease/Volatile
 1008 //
 1009 bool followed_by_acquire(const Node *load) {
 1010   assert(load-&gt;is_Load(), &quot;So far implemented only for loads.&quot;);
 1011 
 1012   // Find MemBarAcquire.
 1013   const Node *mba = NULL;
 1014   for (DUIterator_Fast imax, i = load-&gt;fast_outs(imax); i &lt; imax; i++) {
 1015     const Node *out = load-&gt;fast_out(i);
 1016     if (out-&gt;Opcode() == Op_MemBarAcquire) {
 1017       if (out-&gt;in(0) == load) continue; // Skip control edge, membar should be found via precedence edge.
 1018       mba = out;
 1019       break;
 1020     }
 1021   }
 1022   if (!mba) return false;
 1023 
 1024   // Find following MemBar node.
 1025   //
 1026   // The following node must be reachable by control AND memory
 1027   // edge to assure no other operations are in between the two nodes.
 1028   //
 1029   // So first get the Proj node, mem_proj, to use it to iterate forward.
 1030   Node *mem_proj = NULL;
 1031   for (DUIterator_Fast imax, i = mba-&gt;fast_outs(imax); i &lt; imax; i++) {
 1032     mem_proj = mba-&gt;fast_out(i);      // Runs out of bounds and asserts if Proj not found.
 1033     assert(mem_proj-&gt;is_Proj(), &quot;only projections here&quot;);
 1034     ProjNode *proj = mem_proj-&gt;as_Proj();
 1035     if (proj-&gt;_con == TypeFunc::Memory &amp;&amp;
 1036         !Compile::current()-&gt;node_arena()-&gt;contains(mem_proj)) // Unmatched old-space only
 1037       break;
 1038   }
 1039   assert(mem_proj-&gt;as_Proj()-&gt;_con == TypeFunc::Memory, &quot;Graph broken&quot;);
 1040 
 1041   // Search MemBar behind Proj. If there are other memory operations
 1042   // behind the Proj we lost.
 1043   for (DUIterator_Fast jmax, j = mem_proj-&gt;fast_outs(jmax); j &lt; jmax; j++) {
 1044     Node *x = mem_proj-&gt;fast_out(j);
 1045     // Proj might have an edge to a store or load node which precedes the membar.
 1046     if (x-&gt;is_Mem()) return false;
 1047 
 1048     // On PPC64 release and volatile are implemented by an instruction
 1049     // that also has acquire semantics. I.e. there is no need for an
 1050     // acquire before these.
 1051     int xop = x-&gt;Opcode();
 1052     if (xop == Op_MemBarRelease || xop == Op_MemBarVolatile) {
 1053       // Make sure we&#39;re not missing Call/Phi/MergeMem by checking
 1054       // control edges. The control edge must directly lead back
 1055       // to the MemBarAcquire
 1056       Node *ctrl_proj = x-&gt;in(0);
 1057       if (ctrl_proj-&gt;is_Proj() &amp;&amp; ctrl_proj-&gt;in(0) == mba) {
 1058         return true;
 1059       }
 1060     }
 1061   }
 1062 
 1063   return false;
 1064 }
 1065 
 1066 #define __ _masm.
 1067 
 1068 // Tertiary op of a LoadP or StoreP encoding.
 1069 #define REGP_OP true
 1070 
 1071 // ****************************************************************************
 1072 
 1073 // REQUIRED FUNCTIONALITY
 1074 
 1075 // !!!!! Special hack to get all type of calls to specify the byte offset
 1076 //       from the start of the call to the point where the return address
 1077 //       will point.
 1078 
 1079 // PPC port: Removed use of lazy constant construct.
 1080 
 1081 int MachCallStaticJavaNode::ret_addr_offset() {
 1082   // It&#39;s only a single branch-and-link instruction.
 1083   return 4;
 1084 }
 1085 
 1086 int MachCallDynamicJavaNode::ret_addr_offset() {
 1087   // Offset is 4 with postalloc expanded calls (bl is one instruction). We use
 1088   // postalloc expanded calls if we use inline caches and do not update method data.
 1089   if (UseInlineCaches)
 1090     return 4;
 1091 
 1092   int vtable_index = this-&gt;_vtable_index;
 1093   if (vtable_index &lt; 0) {
 1094     // Must be invalid_vtable_index, not nonvirtual_vtable_index.
 1095     assert(vtable_index == Method::invalid_vtable_index, &quot;correct sentinel value&quot;);
 1096     return 12;
 1097   } else {
 1098     assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
 1099     return 24;
 1100   }
 1101 }
 1102 
 1103 int MachCallRuntimeNode::ret_addr_offset() {
 1104 #if defined(ABI_ELFv2)
 1105   return 28;
 1106 #else
 1107   return 40;
 1108 #endif
 1109 }
 1110 
 1111 //=============================================================================
 1112 
 1113 // condition code conversions
 1114 
 1115 static int cc_to_boint(int cc) {
 1116   return Assembler::bcondCRbiIs0 | (cc &amp; 8);
 1117 }
 1118 
 1119 static int cc_to_inverse_boint(int cc) {
 1120   return Assembler::bcondCRbiIs0 | (8-(cc &amp; 8));
 1121 }
 1122 
 1123 static int cc_to_biint(int cc, int flags_reg) {
 1124   return (flags_reg &lt;&lt; 2) | (cc &amp; 3);
 1125 }
 1126 
 1127 //=============================================================================
 1128 
 1129 // Compute padding required for nodes which need alignment. The padding
 1130 // is the number of bytes (not instructions) which will be inserted before
 1131 // the instruction. The padding must match the size of a NOP instruction.
 1132 
 1133 // Currently not used on this platform.
 1134 
 1135 //=============================================================================
 1136 
 1137 // Indicate if the safepoint node needs the polling page as an input.
 1138 bool SafePointNode::needs_polling_address_input() {
 1139   // The address is loaded from thread by a seperate node.
 1140   return true;
 1141 }
 1142 
 1143 //=============================================================================
 1144 
 1145 // Emit an interrupt that is caught by the debugger (for debugging compiler).
 1146 void emit_break(CodeBuffer &amp;cbuf) {
 1147   MacroAssembler _masm(&amp;cbuf);
 1148   __ illtrap();
 1149 }
 1150 
 1151 #ifndef PRODUCT
 1152 void MachBreakpointNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1153   st-&gt;print(&quot;BREAKPOINT&quot;);
 1154 }
 1155 #endif
 1156 
 1157 void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1158   emit_break(cbuf);
 1159 }
 1160 
 1161 uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
 1162   return MachNode::size(ra_);
 1163 }
 1164 
 1165 //=============================================================================
 1166 
 1167 void emit_nop(CodeBuffer &amp;cbuf) {
 1168   MacroAssembler _masm(&amp;cbuf);
 1169   __ nop();
 1170 }
 1171 
 1172 static inline void emit_long(CodeBuffer &amp;cbuf, int value) {
 1173   *((int*)(cbuf.insts_end())) = value;
 1174   cbuf.set_insts_end(cbuf.insts_end() + BytesPerInstWord);
 1175 }
 1176 
 1177 //=============================================================================
 1178 
 1179 %} // interrupt source
 1180 
 1181 source_hpp %{ // Header information of the source block.
 1182 
 1183 //--------------------------------------------------------------
 1184 //---&lt;  Used for optimization in Compile::Shorten_branches  &gt;---
 1185 //--------------------------------------------------------------
 1186 
 1187 class CallStubImpl {
 1188 
 1189  public:
 1190 
 1191   // Emit call stub, compiled java to interpreter.
 1192   static void emit_trampoline_stub(MacroAssembler &amp;_masm, int destination_toc_offset, int insts_call_instruction_offset);
 1193 
 1194   // Size of call trampoline stub.
 1195   // This doesn&#39;t need to be accurate to the byte, but it
 1196   // must be larger than or equal to the real size of the stub.
 1197   static uint size_call_trampoline() {
 1198     return MacroAssembler::trampoline_stub_size;
 1199   }
 1200 
 1201   // number of relocations needed by a call trampoline stub
 1202   static uint reloc_call_trampoline() {
 1203     return 5;
 1204   }
 1205 
 1206 };
 1207 
 1208 %} // end source_hpp
 1209 
 1210 source %{
 1211 
 1212 // Emit a trampoline stub for a call to a target which is too far away.
 1213 //
 1214 // code sequences:
 1215 //
 1216 // call-site:
 1217 //   branch-and-link to &lt;destination&gt; or &lt;trampoline stub&gt;
 1218 //
 1219 // Related trampoline stub for this call-site in the stub section:
 1220 //   load the call target from the constant pool
 1221 //   branch via CTR (LR/link still points to the call-site above)
 1222 
 1223 void CallStubImpl::emit_trampoline_stub(MacroAssembler &amp;_masm, int destination_toc_offset, int insts_call_instruction_offset) {
 1224   address stub = __ emit_trampoline_stub(destination_toc_offset, insts_call_instruction_offset);
 1225   if (stub == NULL) {
 1226     ciEnv::current()-&gt;record_out_of_memory_failure();
 1227   }
 1228 }
 1229 
 1230 //=============================================================================
 1231 
 1232 // Emit an inline branch-and-link call and a related trampoline stub.
 1233 //
 1234 // code sequences:
 1235 //
 1236 // call-site:
 1237 //   branch-and-link to &lt;destination&gt; or &lt;trampoline stub&gt;
 1238 //
 1239 // Related trampoline stub for this call-site in the stub section:
 1240 //   load the call target from the constant pool
 1241 //   branch via CTR (LR/link still points to the call-site above)
 1242 //
 1243 
 1244 typedef struct {
 1245   int insts_call_instruction_offset;
 1246   int ret_addr_offset;
 1247 } EmitCallOffsets;
 1248 
 1249 // Emit a branch-and-link instruction that branches to a trampoline.
 1250 // - Remember the offset of the branch-and-link instruction.
 1251 // - Add a relocation at the branch-and-link instruction.
 1252 // - Emit a branch-and-link.
 1253 // - Remember the return pc offset.
 1254 EmitCallOffsets emit_call_with_trampoline_stub(MacroAssembler &amp;_masm, address entry_point, relocInfo::relocType rtype) {
 1255   EmitCallOffsets offsets = { -1, -1 };
 1256   const int start_offset = __ offset();
 1257   offsets.insts_call_instruction_offset = __ offset();
 1258 
 1259   // No entry point given, use the current pc.
 1260   if (entry_point == NULL) entry_point = __ pc();
 1261 
 1262   // Put the entry point as a constant into the constant pool.
 1263   const address entry_point_toc_addr   = __ address_constant(entry_point, RelocationHolder::none);
 1264   if (entry_point_toc_addr == NULL) {
 1265     ciEnv::current()-&gt;record_out_of_memory_failure();
 1266     return offsets;
 1267   }
 1268   const int     entry_point_toc_offset = __ offset_to_method_toc(entry_point_toc_addr);
 1269 
 1270   // Emit the trampoline stub which will be related to the branch-and-link below.
 1271   CallStubImpl::emit_trampoline_stub(_masm, entry_point_toc_offset, offsets.insts_call_instruction_offset);
 1272   if (ciEnv::current()-&gt;failing()) { return offsets; } // Code cache may be full.
 1273   __ relocate(rtype);
 1274 
 1275   // Note: At this point we do not have the address of the trampoline
 1276   // stub, and the entry point might be too far away for bl, so __ pc()
 1277   // serves as dummy and the bl will be patched later.
 1278   __ bl((address) __ pc());
 1279 
 1280   offsets.ret_addr_offset = __ offset() - start_offset;
 1281 
 1282   return offsets;
 1283 }
 1284 
 1285 //=============================================================================
 1286 
 1287 // Factory for creating loadConL* nodes for large/small constant pool.
 1288 
 1289 static inline jlong replicate_immF(float con) {
 1290   // Replicate float con 2 times and pack into vector.
 1291   int val = *((int*)&amp;con);
 1292   jlong lval = val;
 1293   lval = (lval &lt;&lt; 32) | (lval &amp; 0xFFFFFFFFl);
 1294   return lval;
 1295 }
 1296 
 1297 //=============================================================================
 1298 
 1299 const RegMask&amp; MachConstantBaseNode::_out_RegMask = BITS64_CONSTANT_TABLE_BASE_mask();
 1300 int Compile::ConstantTable::calculate_table_base_offset() const {
 1301   return 0;  // absolute addressing, no offset
 1302 }
 1303 
 1304 bool MachConstantBaseNode::requires_postalloc_expand() const { return true; }
 1305 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
 1306   iRegPdstOper *op_dst = new iRegPdstOper();
 1307   MachNode *m1 = new loadToc_hiNode();
 1308   MachNode *m2 = new loadToc_loNode();
 1309 
 1310   m1-&gt;add_req(NULL);
 1311   m2-&gt;add_req(NULL, m1);
 1312   m1-&gt;_opnds[0] = op_dst;
 1313   m2-&gt;_opnds[0] = op_dst;
 1314   m2-&gt;_opnds[1] = op_dst;
 1315   ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 1316   ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 1317   nodes-&gt;push(m1);
 1318   nodes-&gt;push(m2);
 1319 }
 1320 
 1321 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
 1322   // Is postalloc expanded.
 1323   ShouldNotReachHere();
 1324 }
 1325 
 1326 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
 1327   return 0;
 1328 }
 1329 
 1330 #ifndef PRODUCT
 1331 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
 1332   st-&gt;print(&quot;-- \t// MachConstantBaseNode (empty encoding)&quot;);
 1333 }
 1334 #endif
 1335 
 1336 //=============================================================================
 1337 
 1338 #ifndef PRODUCT
 1339 void MachPrologNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1340   Compile* C = ra_-&gt;C;
 1341   const long framesize = C-&gt;frame_slots() &lt;&lt; LogBytesPerInt;
 1342 
 1343   st-&gt;print(&quot;PROLOG\n\t&quot;);
 1344   if (C-&gt;need_stack_bang(framesize)) {
 1345     st-&gt;print(&quot;stack_overflow_check\n\t&quot;);
 1346   }
 1347 
 1348   if (!false /* TODO: PPC port C-&gt;is_frameless_method()*/) {
 1349     st-&gt;print(&quot;save return pc\n\t&quot;);
 1350     st-&gt;print(&quot;push frame %ld\n\t&quot;, -framesize);
 1351   }
 1352 }
 1353 #endif
 1354 
 1355 // Macro used instead of the common __ to emulate the pipes of PPC.
 1356 // Instead of e.g. __ ld(...) one hase to write ___(ld) ld(...) This enables the
 1357 // micro scheduler to cope with &quot;hand written&quot; assembler like in the prolog. Though
 1358 // still no scheduling of this code is possible, the micro scheduler is aware of the
 1359 // code and can update its internal data. The following mechanism is used to achieve this:
 1360 // The micro scheduler calls size() of each compound node during scheduling. size() does a
 1361 // dummy emit and only during this dummy emit C-&gt;hb_scheduling() is not NULL.
 1362 #if 0 // TODO: PPC port
 1363 #define ___(op) if (UsePower6SchedulerPPC64 &amp;&amp; C-&gt;hb_scheduling())                    \
 1364                   C-&gt;hb_scheduling()-&gt;_pdScheduling-&gt;PdEmulatePipe(ppc64Opcode_##op); \
 1365                 _masm.
 1366 #define ___stop if (UsePower6SchedulerPPC64 &amp;&amp; C-&gt;hb_scheduling())                    \
 1367                   C-&gt;hb_scheduling()-&gt;_pdScheduling-&gt;PdEmulatePipe(archOpcode_none)
 1368 #define ___advance if (UsePower6SchedulerPPC64 &amp;&amp; C-&gt;hb_scheduling())                 \
 1369                   C-&gt;hb_scheduling()-&gt;_pdScheduling-&gt;advance_offset
 1370 #else
 1371 #define ___(op) if (UsePower6SchedulerPPC64)                                          \
 1372                   Unimplemented();                                                    \
 1373                 _masm.
 1374 #define ___stop if (UsePower6SchedulerPPC64)                                          \
 1375                   Unimplemented()
 1376 #define ___advance if (UsePower6SchedulerPPC64)                                       \
 1377                   Unimplemented()
 1378 #endif
 1379 
 1380 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1381   Compile* C = ra_-&gt;C;
 1382   MacroAssembler _masm(&amp;cbuf);
 1383 
 1384   const long framesize = C-&gt;frame_size_in_bytes();
 1385   assert(framesize % (2 * wordSize) == 0, &quot;must preserve 2*wordSize alignment&quot;);
 1386 
 1387   const bool method_is_frameless      = false /* TODO: PPC port C-&gt;is_frameless_method()*/;
 1388 
 1389   const Register return_pc            = R20; // Must match return_addr() in frame section.
 1390   const Register callers_sp           = R21;
 1391   const Register push_frame_temp      = R22;
 1392   const Register toc_temp             = R23;
 1393   assert_different_registers(R11, return_pc, callers_sp, push_frame_temp, toc_temp);
 1394 
 1395   if (method_is_frameless) {
 1396     // Add nop at beginning of all frameless methods to prevent any
 1397     // oop instructions from getting overwritten by make_not_entrant
 1398     // (patching attempt would fail).
 1399     ___(nop) nop();
 1400   } else {
 1401     // Get return pc.
 1402     ___(mflr) mflr(return_pc);
 1403   }
 1404 
 1405   if (C-&gt;clinit_barrier_on_entry()) {
 1406     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
 1407 
 1408     Label L_skip_barrier;
 1409     Register klass = toc_temp;
 1410 
 1411     // Notify OOP recorder (don&#39;t need the relocation)
 1412     AddressLiteral md = __ constant_metadata_address(C-&gt;method()-&gt;holder()-&gt;constant_encoding());
 1413     __ load_const_optimized(klass, md.value(), R0);
 1414     __ clinit_barrier(klass, R16_thread, &amp;L_skip_barrier /*L_fast_path*/);
 1415 
 1416     __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub(), R0);
 1417     __ mtctr(klass);
 1418     __ bctr();
 1419 
 1420     __ bind(L_skip_barrier);
 1421   }
 1422 
 1423   // Calls to C2R adapters often do not accept exceptional returns.
 1424   // We require that their callers must bang for them. But be
 1425   // careful, because some VM calls (such as call site linkage) can
 1426   // use several kilobytes of stack. But the stack safety zone should
 1427   // account for that. See bugs 4446381, 4468289, 4497237.
 1428 
 1429   int bangsize = C-&gt;bang_size_in_bytes();
 1430   assert(bangsize &gt;= framesize || bangsize &lt;= 0, &quot;stack bang size incorrect&quot;);
 1431   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {
 1432     // Unfortunately we cannot use the function provided in
 1433     // assembler.cpp as we have to emulate the pipes. So I had to
 1434     // insert the code of generate_stack_overflow_check(), see
 1435     // assembler.cpp for some illuminative comments.
 1436     const int page_size = os::vm_page_size();
 1437     int bang_end = JavaThread::stack_shadow_zone_size();
 1438 
 1439     // This is how far the previous frame&#39;s stack banging extended.
 1440     const int bang_end_safe = bang_end;
 1441 
 1442     if (bangsize &gt; page_size) {
 1443       bang_end += bangsize;
 1444     }
 1445 
 1446     int bang_offset = bang_end_safe;
 1447 
 1448     while (bang_offset &lt;= bang_end) {
 1449       // Need at least one stack bang at end of shadow zone.
 1450 
 1451       // Again I had to copy code, this time from assembler_ppc.cpp,
 1452       // bang_stack_with_offset - see there for comments.
 1453 
 1454       // Stack grows down, caller passes positive offset.
 1455       assert(bang_offset &gt; 0, &quot;must bang with positive offset&quot;);
 1456 
 1457       long stdoffset = -bang_offset;
 1458 
 1459       if (Assembler::is_simm(stdoffset, 16)) {
 1460         // Signed 16 bit offset, a simple std is ok.
 1461         if (UseLoadInstructionsForStackBangingPPC64) {
 1462           ___(ld) ld(R0,  (int)(signed short)stdoffset, R1_SP);
 1463         } else {
 1464           ___(std) std(R0, (int)(signed short)stdoffset, R1_SP);
 1465         }
 1466       } else if (Assembler::is_simm(stdoffset, 31)) {
 1467         // Use largeoffset calculations for addis &amp; ld/std.
 1468         const int hi = MacroAssembler::largeoffset_si16_si16_hi(stdoffset);
 1469         const int lo = MacroAssembler::largeoffset_si16_si16_lo(stdoffset);
 1470 
 1471         Register tmp = R11;
 1472         ___(addis) addis(tmp, R1_SP, hi);
 1473         if (UseLoadInstructionsForStackBangingPPC64) {
 1474           ___(ld) ld(R0, lo, tmp);
 1475         } else {
 1476           ___(std) std(R0, lo, tmp);
 1477         }
 1478       } else {
 1479         ShouldNotReachHere();
 1480       }
 1481 
 1482       bang_offset += page_size;
 1483     }
 1484     // R11 trashed
 1485   } // C-&gt;need_stack_bang(framesize) &amp;&amp; UseStackBanging
 1486 
 1487   unsigned int bytes = (unsigned int)framesize;
 1488   long offset = Assembler::align_addr(bytes, frame::alignment_in_bytes);
 1489   ciMethod *currMethod = C-&gt;method();
 1490 
 1491   // Optimized version for most common case.
 1492   if (UsePower6SchedulerPPC64 &amp;&amp;
 1493       !method_is_frameless &amp;&amp; Assembler::is_simm((int)(-offset), 16) &amp;&amp;
 1494       !(false /* ConstantsALot TODO: PPC port*/)) {
 1495     ___(or) mr(callers_sp, R1_SP);
 1496     ___(std) std(return_pc, _abi(lr), R1_SP);
 1497     ___(stdu) stdu(R1_SP, -offset, R1_SP);
 1498     return;
 1499   }
 1500 
 1501   if (!method_is_frameless) {
 1502     // Get callers sp.
 1503     ___(or) mr(callers_sp, R1_SP);
 1504 
 1505     // Push method&#39;s frame, modifies SP.
 1506     assert(Assembler::is_uimm(framesize, 32U), &quot;wrong type&quot;);
 1507     // The ABI is already accounted for in &#39;framesize&#39; via the
 1508     // &#39;out_preserve&#39; area.
 1509     Register tmp = push_frame_temp;
 1510     // Had to insert code of push_frame((unsigned int)framesize, push_frame_temp).
 1511     if (Assembler::is_simm(-offset, 16)) {
 1512       ___(stdu) stdu(R1_SP, -offset, R1_SP);
 1513     } else {
 1514       long x = -offset;
 1515       // Had to insert load_const(tmp, -offset).
 1516       ___(addis)  lis( tmp, (int)((signed short)(((x &gt;&gt; 32) &amp; 0xffff0000) &gt;&gt; 16)));
 1517       ___(ori)    ori( tmp, tmp, ((x &gt;&gt; 32) &amp; 0x0000ffff));
 1518       ___(rldicr) sldi(tmp, tmp, 32);
 1519       ___(oris)   oris(tmp, tmp, (x &amp; 0xffff0000) &gt;&gt; 16);
 1520       ___(ori)    ori( tmp, tmp, (x &amp; 0x0000ffff));
 1521 
 1522       ___(stdux) stdux(R1_SP, R1_SP, tmp);
 1523     }
 1524   }
 1525 #if 0 // TODO: PPC port
 1526   // For testing large constant pools, emit a lot of constants to constant pool.
 1527   // &quot;Randomize&quot; const_size.
 1528   if (ConstantsALot) {
 1529     const int num_consts = const_size();
 1530     for (int i = 0; i &lt; num_consts; i++) {
 1531       __ long_constant(0xB0B5B00BBABE);
 1532     }
 1533   }
 1534 #endif
 1535   if (!method_is_frameless) {
 1536     // Save return pc.
 1537     ___(std) std(return_pc, _abi(lr), callers_sp);
 1538   }
 1539 
 1540   C-&gt;set_frame_complete(cbuf.insts_size());
 1541 }
 1542 #undef ___
 1543 #undef ___stop
 1544 #undef ___advance
 1545 
 1546 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
 1547   // Variable size. determine dynamically.
 1548   return MachNode::size(ra_);
 1549 }
 1550 
 1551 int MachPrologNode::reloc() const {
 1552   // Return number of relocatable values contained in this instruction.
 1553   return 1; // 1 reloc entry for load_const(toc).
 1554 }
 1555 
 1556 //=============================================================================
 1557 
 1558 #ifndef PRODUCT
 1559 void MachEpilogNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1560   Compile* C = ra_-&gt;C;
 1561 
 1562   st-&gt;print(&quot;EPILOG\n\t&quot;);
 1563   st-&gt;print(&quot;restore return pc\n\t&quot;);
 1564   st-&gt;print(&quot;pop frame\n\t&quot;);
 1565 
 1566   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
 1567     st-&gt;print(&quot;touch polling page\n\t&quot;);
 1568   }
 1569 }
 1570 #endif
 1571 
 1572 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1573   Compile* C = ra_-&gt;C;
 1574   MacroAssembler _masm(&amp;cbuf);
 1575 
 1576   const long framesize = ((long)C-&gt;frame_slots()) &lt;&lt; LogBytesPerInt;
 1577   assert(framesize &gt;= 0, &quot;negative frame-size?&quot;);
 1578 
 1579   const bool method_needs_polling = do_polling() &amp;&amp; C-&gt;is_method_compilation();
 1580   const bool method_is_frameless  = false /* TODO: PPC port C-&gt;is_frameless_method()*/;
 1581   const Register return_pc        = R31;  // Must survive C-call to enable_stack_reserved_zone().
 1582   const Register polling_page     = R12;
 1583 
 1584   if (!method_is_frameless) {
 1585     // Restore return pc relative to callers&#39; sp.
 1586     __ ld(return_pc, ((int)framesize) + _abi(lr), R1_SP);
 1587   }
 1588 
 1589   if (method_needs_polling) {
 1590     if (SafepointMechanism::uses_thread_local_poll()) {
 1591       __ ld(polling_page, in_bytes(JavaThread::polling_page_offset()), R16_thread);
 1592     } else {
 1593       __ load_const_optimized(polling_page, (long)(address) os::get_polling_page());
 1594     }
 1595   }
 1596 
 1597   if (!method_is_frameless) {
 1598     // Move return pc to LR.
 1599     __ mtlr(return_pc);
 1600     // Pop frame (fixed frame-size).
 1601     __ addi(R1_SP, R1_SP, (int)framesize);
 1602   }
 1603 
 1604   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
 1605     __ reserved_stack_check(return_pc);
 1606   }
 1607 
 1608   if (method_needs_polling) {
 1609     // We need to mark the code position where the load from the safepoint
 1610     // polling page was emitted as relocInfo::poll_return_type here.
 1611     __ relocate(relocInfo::poll_return_type);
 1612     __ load_from_polling_page(polling_page);
 1613   }
 1614 }
 1615 
 1616 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
 1617   // Variable size. Determine dynamically.
 1618   return MachNode::size(ra_);
 1619 }
 1620 
 1621 int MachEpilogNode::reloc() const {
 1622   // Return number of relocatable values contained in this instruction.
 1623   return 1; // 1 for load_from_polling_page.
 1624 }
 1625 
 1626 const Pipeline * MachEpilogNode::pipeline() const {
 1627   return MachNode::pipeline_class();
 1628 }
 1629 
 1630 // This method seems to be obsolete. It is declared in machnode.hpp
 1631 // and defined in all *.ad files, but it is never called. Should we
 1632 // get rid of it?
 1633 int MachEpilogNode::safepoint_offset() const {
 1634   assert(do_polling(), &quot;no return for this epilog node&quot;);
 1635   return 0;
 1636 }
 1637 
 1638 #if 0 // TODO: PPC port
 1639 void MachLoadPollAddrLateNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
 1640   MacroAssembler _masm(&amp;cbuf);
 1641   if (LoadPollAddressFromThread) {
 1642     _masm.ld(R11, in_bytes(JavaThread::poll_address_offset()), R16_thread);
 1643   } else {
 1644     _masm.nop();
 1645   }
 1646 }
 1647 
 1648 uint MachLoadPollAddrLateNode::size(PhaseRegAlloc* ra_) const {
 1649   if (LoadPollAddressFromThread) {
 1650     return 4;
 1651   } else {
 1652     return 4;
 1653   }
 1654 }
 1655 
 1656 #ifndef PRODUCT
 1657 void MachLoadPollAddrLateNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
 1658   st-&gt;print_cr(&quot; LD R11, PollAddressOffset, R16_thread \t// LoadPollAddressFromThread&quot;);
 1659 }
 1660 #endif
 1661 
 1662 const RegMask &amp;MachLoadPollAddrLateNode::out_RegMask() const {
 1663   return RSCRATCH1_BITS64_REG_mask();
 1664 }
 1665 #endif // PPC port
 1666 
 1667 // =============================================================================
 1668 
 1669 // Figure out which register class each belongs in: rc_int, rc_float, rc_vs or
 1670 // rc_stack.
 1671 enum RC { rc_bad, rc_int, rc_float, rc_vs, rc_stack };
 1672 
 1673 static enum RC rc_class(OptoReg::Name reg) {
 1674   // Return the register class for the given register. The given register
 1675   // reg is a &lt;register&gt;_num value, which is an index into the MachRegisterNumbers
 1676   // enumeration in adGlobals_ppc.hpp.
 1677 
 1678   if (reg == OptoReg::Bad) return rc_bad;
 1679 
 1680   // We have 64 integer register halves, starting at index 0.
 1681   if (reg &lt; 64) return rc_int;
 1682 
 1683   // We have 64 floating-point register halves, starting at index 64.
 1684   if (reg &lt; 64+64) return rc_float;
 1685 
 1686   // We have 64 vector-scalar registers, starting at index 128.
 1687   if (reg &lt; 64+64+64) return rc_vs;
 1688 
 1689   // Between float regs &amp; stack are the flags regs.
 1690   assert(OptoReg::is_stack(reg) || reg &lt; 64+64+64, &quot;blow up if spilling flags&quot;);
 1691 
 1692   return rc_stack;
 1693 }
 1694 
 1695 static int ld_st_helper(CodeBuffer *cbuf, const char *op_str, uint opcode, int reg, int offset,
 1696                         bool do_print, Compile* C, outputStream *st) {
 1697 
 1698   assert(opcode == Assembler::LD_OPCODE   ||
 1699          opcode == Assembler::STD_OPCODE  ||
 1700          opcode == Assembler::LWZ_OPCODE  ||
 1701          opcode == Assembler::STW_OPCODE  ||
 1702          opcode == Assembler::LFD_OPCODE  ||
 1703          opcode == Assembler::STFD_OPCODE ||
 1704          opcode == Assembler::LFS_OPCODE  ||
 1705          opcode == Assembler::STFS_OPCODE,
 1706          &quot;opcode not supported&quot;);
 1707 
 1708   if (cbuf) {
 1709     int d =
 1710       (Assembler::LD_OPCODE == opcode || Assembler::STD_OPCODE == opcode) ?
 1711         Assembler::ds(offset+0 /* TODO: PPC port C-&gt;frame_slots_sp_bias_in_bytes()*/)
 1712       : Assembler::d1(offset+0 /* TODO: PPC port C-&gt;frame_slots_sp_bias_in_bytes()*/); // Makes no difference in opt build.
 1713     emit_long(*cbuf, opcode | Assembler::rt(Matcher::_regEncode[reg]) | d | Assembler::ra(R1_SP));
 1714   }
 1715 #ifndef PRODUCT
 1716   else if (do_print) {
 1717     st-&gt;print(&quot;%-7s %s, [R1_SP + #%d+%d] \t// spill copy&quot;,
 1718               op_str,
 1719               Matcher::regName[reg],
 1720               offset, 0 /* TODO: PPC port C-&gt;frame_slots_sp_bias_in_bytes()*/);
 1721   }
 1722 #endif
 1723   return 4; // size
 1724 }
 1725 
 1726 uint MachSpillCopyNode::implementation(CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream *st) const {
 1727   Compile* C = ra_-&gt;C;
 1728 
 1729   // Get registers to move.
 1730   OptoReg::Name src_hi = ra_-&gt;get_reg_second(in(1));
 1731   OptoReg::Name src_lo = ra_-&gt;get_reg_first(in(1));
 1732   OptoReg::Name dst_hi = ra_-&gt;get_reg_second(this);
 1733   OptoReg::Name dst_lo = ra_-&gt;get_reg_first(this);
 1734 
 1735   enum RC src_hi_rc = rc_class(src_hi);
 1736   enum RC src_lo_rc = rc_class(src_lo);
 1737   enum RC dst_hi_rc = rc_class(dst_hi);
 1738   enum RC dst_lo_rc = rc_class(dst_lo);
 1739 
 1740   assert(src_lo != OptoReg::Bad &amp;&amp; dst_lo != OptoReg::Bad, &quot;must move at least 1 register&quot;);
 1741   if (src_hi != OptoReg::Bad)
 1742     assert((src_lo&amp;1)==0 &amp;&amp; src_lo+1==src_hi &amp;&amp;
 1743            (dst_lo&amp;1)==0 &amp;&amp; dst_lo+1==dst_hi,
 1744            &quot;expected aligned-adjacent pairs&quot;);
 1745   // Generate spill code!
 1746   int size = 0;
 1747 
 1748   if (src_lo == dst_lo &amp;&amp; src_hi == dst_hi)
 1749     return size;            // Self copy, no move.
 1750 
 1751   if (bottom_type()-&gt;isa_vect() != NULL &amp;&amp; ideal_reg() == Op_VecX) {
 1752     // Memory-&gt;Memory Spill.
 1753     if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_stack) {
 1754       int src_offset = ra_-&gt;reg2offset(src_lo);
 1755       int dst_offset = ra_-&gt;reg2offset(dst_lo);
 1756       if (cbuf) {
 1757         MacroAssembler _masm(cbuf);
 1758         __ ld(R0, src_offset, R1_SP);
 1759         __ std(R0, dst_offset, R1_SP);
 1760         __ ld(R0, src_offset+8, R1_SP);
 1761         __ std(R0, dst_offset+8, R1_SP);
 1762       }
 1763       size += 16;
 1764     }
 1765     // VectorSRegister-&gt;Memory Spill.
 1766     else if (src_lo_rc == rc_vs &amp;&amp; dst_lo_rc == rc_stack) {
 1767       VectorSRegister Rsrc = as_VectorSRegister(Matcher::_regEncode[src_lo]);
 1768       int dst_offset = ra_-&gt;reg2offset(dst_lo);
 1769       if (cbuf) {
 1770         MacroAssembler _masm(cbuf);
 1771         __ addi(R0, R1_SP, dst_offset);
 1772         __ stxvd2x(Rsrc, R0);
 1773       }
 1774       size += 8;
 1775     }
 1776     // Memory-&gt;VectorSRegister Spill.
 1777     else if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_vs) {
 1778       VectorSRegister Rdst = as_VectorSRegister(Matcher::_regEncode[dst_lo]);
 1779       int src_offset = ra_-&gt;reg2offset(src_lo);
 1780       if (cbuf) {
 1781         MacroAssembler _masm(cbuf);
 1782         __ addi(R0, R1_SP, src_offset);
 1783         __ lxvd2x(Rdst, R0);
 1784       }
 1785       size += 8;
 1786     }
 1787     // VectorSRegister-&gt;VectorSRegister.
 1788     else if (src_lo_rc == rc_vs &amp;&amp; dst_lo_rc == rc_vs) {
 1789       VectorSRegister Rsrc = as_VectorSRegister(Matcher::_regEncode[src_lo]);
 1790       VectorSRegister Rdst = as_VectorSRegister(Matcher::_regEncode[dst_lo]);
 1791       if (cbuf) {
 1792         MacroAssembler _masm(cbuf);
 1793         __ xxlor(Rdst, Rsrc, Rsrc);
 1794       }
 1795       size += 4;
 1796     }
 1797     else {
 1798       ShouldNotReachHere(); // No VSR spill.
 1799     }
 1800     return size;
 1801   }
 1802 
 1803   // --------------------------------------
 1804   // Memory-&gt;Memory Spill. Use R0 to hold the value.
 1805   if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_stack) {
 1806     int src_offset = ra_-&gt;reg2offset(src_lo);
 1807     int dst_offset = ra_-&gt;reg2offset(dst_lo);
 1808     if (src_hi != OptoReg::Bad) {
 1809       assert(src_hi_rc==rc_stack &amp;&amp; dst_hi_rc==rc_stack,
 1810              &quot;expected same type of move for high parts&quot;);
 1811       size += ld_st_helper(cbuf, &quot;LD  &quot;, Assembler::LD_OPCODE,  R0_num, src_offset, !do_size, C, st);
 1812       if (!cbuf &amp;&amp; !do_size) st-&gt;print(&quot;\n\t&quot;);
 1813       size += ld_st_helper(cbuf, &quot;STD &quot;, Assembler::STD_OPCODE, R0_num, dst_offset, !do_size, C, st);
 1814     } else {
 1815       size += ld_st_helper(cbuf, &quot;LWZ &quot;, Assembler::LWZ_OPCODE, R0_num, src_offset, !do_size, C, st);
 1816       if (!cbuf &amp;&amp; !do_size) st-&gt;print(&quot;\n\t&quot;);
 1817       size += ld_st_helper(cbuf, &quot;STW &quot;, Assembler::STW_OPCODE, R0_num, dst_offset, !do_size, C, st);
 1818     }
 1819     return size;
 1820   }
 1821 
 1822   // --------------------------------------
 1823   // Check for float-&gt;int copy; requires a trip through memory.
 1824   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_int) {
 1825     Unimplemented();
 1826   }
 1827 
 1828   // --------------------------------------
 1829   // Check for integer reg-reg copy.
 1830   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_int) {
 1831       Register Rsrc = as_Register(Matcher::_regEncode[src_lo]);
 1832       Register Rdst = as_Register(Matcher::_regEncode[dst_lo]);
 1833       size = (Rsrc != Rdst) ? 4 : 0;
 1834 
 1835       if (cbuf) {
 1836         MacroAssembler _masm(cbuf);
 1837         if (size) {
 1838           __ mr(Rdst, Rsrc);
 1839         }
 1840       }
 1841 #ifndef PRODUCT
 1842       else if (!do_size) {
 1843         if (size) {
 1844           st-&gt;print(&quot;%-7s %s, %s \t// spill copy&quot;, &quot;MR&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1845         } else {
 1846           st-&gt;print(&quot;%-7s %s, %s \t// spill copy&quot;, &quot;MR-NOP&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1847         }
 1848       }
 1849 #endif
 1850       return size;
 1851   }
 1852 
 1853   // Check for integer store.
 1854   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_stack) {
 1855     int dst_offset = ra_-&gt;reg2offset(dst_lo);
 1856     if (src_hi != OptoReg::Bad) {
 1857       assert(src_hi_rc==rc_int &amp;&amp; dst_hi_rc==rc_stack,
 1858              &quot;expected same type of move for high parts&quot;);
 1859       size += ld_st_helper(cbuf, &quot;STD &quot;, Assembler::STD_OPCODE, src_lo, dst_offset, !do_size, C, st);
 1860     } else {
 1861       size += ld_st_helper(cbuf, &quot;STW &quot;, Assembler::STW_OPCODE, src_lo, dst_offset, !do_size, C, st);
 1862     }
 1863     return size;
 1864   }
 1865 
 1866   // Check for integer load.
 1867   if (dst_lo_rc == rc_int &amp;&amp; src_lo_rc == rc_stack) {
 1868     int src_offset = ra_-&gt;reg2offset(src_lo);
 1869     if (src_hi != OptoReg::Bad) {
 1870       assert(dst_hi_rc==rc_int &amp;&amp; src_hi_rc==rc_stack,
 1871              &quot;expected same type of move for high parts&quot;);
 1872       size += ld_st_helper(cbuf, &quot;LD  &quot;, Assembler::LD_OPCODE, dst_lo, src_offset, !do_size, C, st);
 1873     } else {
 1874       size += ld_st_helper(cbuf, &quot;LWZ &quot;, Assembler::LWZ_OPCODE, dst_lo, src_offset, !do_size, C, st);
 1875     }
 1876     return size;
 1877   }
 1878 
 1879   // Check for float reg-reg copy.
 1880   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_float) {
 1881     if (cbuf) {
 1882       MacroAssembler _masm(cbuf);
 1883       FloatRegister Rsrc = as_FloatRegister(Matcher::_regEncode[src_lo]);
 1884       FloatRegister Rdst = as_FloatRegister(Matcher::_regEncode[dst_lo]);
 1885       __ fmr(Rdst, Rsrc);
 1886     }
 1887 #ifndef PRODUCT
 1888     else if (!do_size) {
 1889       st-&gt;print(&quot;%-7s %s, %s \t// spill copy&quot;, &quot;FMR&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1890     }
 1891 #endif
 1892     return 4;
 1893   }
 1894 
 1895   // Check for float store.
 1896   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_stack) {
 1897     int dst_offset = ra_-&gt;reg2offset(dst_lo);
 1898     if (src_hi != OptoReg::Bad) {
 1899       assert(src_hi_rc==rc_float &amp;&amp; dst_hi_rc==rc_stack,
 1900              &quot;expected same type of move for high parts&quot;);
 1901       size += ld_st_helper(cbuf, &quot;STFD&quot;, Assembler::STFD_OPCODE, src_lo, dst_offset, !do_size, C, st);
 1902     } else {
 1903       size += ld_st_helper(cbuf, &quot;STFS&quot;, Assembler::STFS_OPCODE, src_lo, dst_offset, !do_size, C, st);
 1904     }
 1905     return size;
 1906   }
 1907 
 1908   // Check for float load.
 1909   if (dst_lo_rc == rc_float &amp;&amp; src_lo_rc == rc_stack) {
 1910     int src_offset = ra_-&gt;reg2offset(src_lo);
 1911     if (src_hi != OptoReg::Bad) {
 1912       assert(dst_hi_rc==rc_float &amp;&amp; src_hi_rc==rc_stack,
 1913              &quot;expected same type of move for high parts&quot;);
 1914       size += ld_st_helper(cbuf, &quot;LFD &quot;, Assembler::LFD_OPCODE, dst_lo, src_offset, !do_size, C, st);
 1915     } else {
 1916       size += ld_st_helper(cbuf, &quot;LFS &quot;, Assembler::LFS_OPCODE, dst_lo, src_offset, !do_size, C, st);
 1917     }
 1918     return size;
 1919   }
 1920 
 1921   // --------------------------------------------------------------------
 1922   // Check for hi bits still needing moving. Only happens for misaligned
 1923   // arguments to native calls.
 1924   if (src_hi == dst_hi)
 1925     return size;               // Self copy; no move.
 1926 
 1927   assert(src_hi_rc != rc_bad &amp;&amp; dst_hi_rc != rc_bad, &quot;src_hi &amp; dst_hi cannot be Bad&quot;);
 1928   ShouldNotReachHere(); // Unimplemented
 1929   return 0;
 1930 }
 1931 
 1932 #ifndef PRODUCT
 1933 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1934   if (!ra_)
 1935     st-&gt;print(&quot;N%d = SpillCopy(N%d)&quot;, _idx, in(1)-&gt;_idx);
 1936   else
 1937     implementation(NULL, ra_, false, st);
 1938 }
 1939 #endif
 1940 
 1941 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1942   implementation(&amp;cbuf, ra_, false, NULL);
 1943 }
 1944 
 1945 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1946   return implementation(NULL, ra_, true, NULL);
 1947 }
 1948 
 1949 #if 0 // TODO: PPC port
 1950 ArchOpcode MachSpillCopyNode_archOpcode(MachSpillCopyNode *n, PhaseRegAlloc *ra_) {
 1951 #ifndef PRODUCT
 1952   if (ra_-&gt;node_regs_max_index() == 0) return archOpcode_undefined;
 1953 #endif
 1954   assert(ra_-&gt;node_regs_max_index() != 0, &quot;&quot;);
 1955 
 1956   // Get registers to move.
 1957   OptoReg::Name src_hi = ra_-&gt;get_reg_second(n-&gt;in(1));
 1958   OptoReg::Name src_lo = ra_-&gt;get_reg_first(n-&gt;in(1));
 1959   OptoReg::Name dst_hi = ra_-&gt;get_reg_second(n);
 1960   OptoReg::Name dst_lo = ra_-&gt;get_reg_first(n);
 1961 
 1962   enum RC src_lo_rc = rc_class(src_lo);
 1963   enum RC dst_lo_rc = rc_class(dst_lo);
 1964 
 1965   if (src_lo == dst_lo &amp;&amp; src_hi == dst_hi)
 1966     return ppc64Opcode_none;            // Self copy, no move.
 1967 
 1968   // --------------------------------------
 1969   // Memory-&gt;Memory Spill. Use R0 to hold the value.
 1970   if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_stack) {
 1971     return ppc64Opcode_compound;
 1972   }
 1973 
 1974   // --------------------------------------
 1975   // Check for float-&gt;int copy; requires a trip through memory.
 1976   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_int) {
 1977     Unimplemented();
 1978   }
 1979 
 1980   // --------------------------------------
 1981   // Check for integer reg-reg copy.
 1982   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_int) {
 1983     Register Rsrc = as_Register(Matcher::_regEncode[src_lo]);
 1984     Register Rdst = as_Register(Matcher::_regEncode[dst_lo]);
 1985     if (Rsrc == Rdst) {
 1986       return ppc64Opcode_none;
 1987     } else {
 1988       return ppc64Opcode_or;
 1989     }
 1990   }
 1991 
 1992   // Check for integer store.
 1993   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_stack) {
 1994     if (src_hi != OptoReg::Bad) {
 1995       return ppc64Opcode_std;
 1996     } else {
 1997       return ppc64Opcode_stw;
 1998     }
 1999   }
 2000 
 2001   // Check for integer load.
 2002   if (dst_lo_rc == rc_int &amp;&amp; src_lo_rc == rc_stack) {
 2003     if (src_hi != OptoReg::Bad) {
 2004       return ppc64Opcode_ld;
 2005     } else {
 2006       return ppc64Opcode_lwz;
 2007     }
 2008   }
 2009 
 2010   // Check for float reg-reg copy.
 2011   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_float) {
 2012     return ppc64Opcode_fmr;
 2013   }
 2014 
 2015   // Check for float store.
 2016   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_stack) {
 2017     if (src_hi != OptoReg::Bad) {
 2018       return ppc64Opcode_stfd;
 2019     } else {
 2020       return ppc64Opcode_stfs;
 2021     }
 2022   }
 2023 
 2024   // Check for float load.
 2025   if (dst_lo_rc == rc_float &amp;&amp; src_lo_rc == rc_stack) {
 2026     if (src_hi != OptoReg::Bad) {
 2027       return ppc64Opcode_lfd;
 2028     } else {
 2029       return ppc64Opcode_lfs;
 2030     }
 2031   }
 2032 
 2033   // --------------------------------------------------------------------
 2034   // Check for hi bits still needing moving. Only happens for misaligned
 2035   // arguments to native calls.
 2036   if (src_hi == dst_hi) {
 2037     return ppc64Opcode_none;               // Self copy; no move.
 2038   }
 2039 
 2040   ShouldNotReachHere();
 2041   return ppc64Opcode_undefined;
 2042 }
 2043 #endif // PPC port
 2044 
 2045 #ifndef PRODUCT
 2046 void MachNopNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 2047   st-&gt;print(&quot;NOP \t// %d nops to pad for loops.&quot;, _count);
 2048 }
 2049 #endif
 2050 
 2051 void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *) const {
 2052   MacroAssembler _masm(&amp;cbuf);
 2053   // _count contains the number of nops needed for padding.
 2054   for (int i = 0; i &lt; _count; i++) {
 2055     __ nop();
 2056   }
 2057 }
 2058 
 2059 uint MachNopNode::size(PhaseRegAlloc *ra_) const {
 2060   return _count * 4;
 2061 }
 2062 
 2063 #ifndef PRODUCT
 2064 void BoxLockNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 2065   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 2066   char reg_str[128];
 2067   ra_-&gt;dump_register(this, reg_str);
 2068   st-&gt;print(&quot;ADDI    %s, SP, %d \t// box node&quot;, reg_str, offset);
 2069 }
 2070 #endif
 2071 
 2072 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 2073   MacroAssembler _masm(&amp;cbuf);
 2074 
 2075   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 2076   int reg    = ra_-&gt;get_encode(this);
 2077 
 2078   if (Assembler::is_simm(offset, 16)) {
 2079     __ addi(as_Register(reg), R1, offset);
 2080   } else {
 2081     ShouldNotReachHere();
 2082   }
 2083 }
 2084 
 2085 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 2086   // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_).
 2087   return 4;
 2088 }
 2089 
 2090 #ifndef PRODUCT
 2091 void MachUEPNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 2092   st-&gt;print_cr(&quot;---- MachUEPNode ----&quot;);
 2093   st-&gt;print_cr(&quot;...&quot;);
 2094 }
 2095 #endif
 2096 
 2097 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 2098   // This is the unverified entry point.
 2099   MacroAssembler _masm(&amp;cbuf);
 2100 
 2101   // Inline_cache contains a klass.
 2102   Register ic_klass       = as_Register(Matcher::inline_cache_reg_encode());
 2103   Register receiver_klass = R12_scratch2;  // tmp
 2104 
 2105   assert_different_registers(ic_klass, receiver_klass, R11_scratch1, R3_ARG1);
 2106   assert(R11_scratch1 == R11, &quot;need prologue scratch register&quot;);
 2107 
 2108   // Check for NULL argument if we don&#39;t have implicit null checks.
 2109   if (!ImplicitNullChecks || !os::zero_page_read_protected()) {
 2110     if (TrapBasedNullChecks) {
 2111       __ trap_null_check(R3_ARG1);
 2112     } else {
 2113       Label valid;
 2114       __ cmpdi(CCR0, R3_ARG1, 0);
 2115       __ bne_predict_taken(CCR0, valid);
 2116       // We have a null argument, branch to ic_miss_stub.
 2117       __ b64_patchable((address)SharedRuntime::get_ic_miss_stub(),
 2118                            relocInfo::runtime_call_type);
 2119       __ bind(valid);
 2120     }
 2121   }
 2122   // Assume argument is not NULL, load klass from receiver.
 2123   __ load_klass(receiver_klass, R3_ARG1);
 2124 
 2125   if (TrapBasedICMissChecks) {
 2126     __ trap_ic_miss_check(receiver_klass, ic_klass);
 2127   } else {
 2128     Label valid;
 2129     __ cmpd(CCR0, receiver_klass, ic_klass);
 2130     __ beq_predict_taken(CCR0, valid);
 2131     // We have an unexpected klass, branch to ic_miss_stub.
 2132     __ b64_patchable((address)SharedRuntime::get_ic_miss_stub(),
 2133                          relocInfo::runtime_call_type);
 2134     __ bind(valid);
 2135   }
 2136 
 2137   // Argument is valid and klass is as expected, continue.
 2138 }
 2139 
 2140 #if 0 // TODO: PPC port
 2141 // Optimize UEP code on z (save a load_const() call in main path).
 2142 int MachUEPNode::ep_offset() {
 2143   return 0;
 2144 }
 2145 #endif
 2146 
 2147 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
 2148   // Variable size. Determine dynamically.
 2149   return MachNode::size(ra_);
 2150 }
 2151 
 2152 //=============================================================================
 2153 
 2154 %} // interrupt source
 2155 
 2156 source_hpp %{ // Header information of the source block.
 2157 
 2158 class HandlerImpl {
 2159 
 2160  public:
 2161 
 2162   static int emit_exception_handler(CodeBuffer &amp;cbuf);
 2163   static int emit_deopt_handler(CodeBuffer&amp; cbuf);
 2164 
 2165   static uint size_exception_handler() {
 2166     // The exception_handler is a b64_patchable.
 2167     return MacroAssembler::b64_patchable_size;
 2168   }
 2169 
 2170   static uint size_deopt_handler() {
 2171     // The deopt_handler is a bl64_patchable.
 2172     return MacroAssembler::bl64_patchable_size;
 2173   }
 2174 
 2175 };
 2176 
 2177 %} // end source_hpp
 2178 
 2179 source %{
 2180 
 2181 int HandlerImpl::emit_exception_handler(CodeBuffer &amp;cbuf) {
 2182   MacroAssembler _masm(&amp;cbuf);
 2183 
 2184   address base = __ start_a_stub(size_exception_handler());
 2185   if (base == NULL) return 0; // CodeBuffer::expand failed
 2186 
 2187   int offset = __ offset();
 2188   __ b64_patchable((address)OptoRuntime::exception_blob()-&gt;content_begin(),
 2189                        relocInfo::runtime_call_type);
 2190   assert(__ offset() - offset == (int)size_exception_handler(), &quot;must be fixed size&quot;);
 2191   __ end_a_stub();
 2192 
 2193   return offset;
 2194 }
 2195 
 2196 // The deopt_handler is like the exception handler, but it calls to
 2197 // the deoptimization blob instead of jumping to the exception blob.
 2198 int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
 2199   MacroAssembler _masm(&amp;cbuf);
 2200 
 2201   address base = __ start_a_stub(size_deopt_handler());
 2202   if (base == NULL) return 0; // CodeBuffer::expand failed
 2203 
 2204   int offset = __ offset();
 2205   __ bl64_patchable((address)SharedRuntime::deopt_blob()-&gt;unpack(),
 2206                         relocInfo::runtime_call_type);
 2207   assert(__ offset() - offset == (int) size_deopt_handler(), &quot;must be fixed size&quot;);
 2208   __ end_a_stub();
 2209 
 2210   return offset;
 2211 }
 2212 
 2213 //=============================================================================
 2214 
 2215 // Use a frame slots bias for frameless methods if accessing the stack.
 2216 static int frame_slots_bias(int reg_enc, PhaseRegAlloc* ra_) {
 2217   if (as_Register(reg_enc) == R1_SP) {
 2218     return 0; // TODO: PPC port ra_-&gt;C-&gt;frame_slots_sp_bias_in_bytes();
 2219   }
 2220   return 0;
 2221 }
 2222 
 2223 const bool Matcher::match_rule_supported(int opcode) {
 2224   if (!has_match_rule(opcode))
 2225     return false;
 2226 
 2227   bool ret_value = true;
 2228   switch (opcode) {
 2229   case Op_SqrtD:
 2230     return VM_Version::has_fsqrt();
 2231   case Op_CountLeadingZerosI:
 2232   case Op_CountLeadingZerosL:
 2233     if (!UseCountLeadingZerosInstructionsPPC64)
 2234       return false;
 2235     break;
 2236   case Op_CountTrailingZerosI:
 2237   case Op_CountTrailingZerosL:
 2238     if (!UseCountLeadingZerosInstructionsPPC64 &amp;&amp;
 2239         !UseCountTrailingZerosInstructionsPPC64)
 2240       return false;
 2241     break;
 2242 
 2243   case Op_PopCountI:
 2244   case Op_PopCountL:
 2245     return (UsePopCountInstruction &amp;&amp; VM_Version::has_popcntw());
 2246 
 2247   case Op_StrComp:
 2248     return SpecialStringCompareTo;
 2249   case Op_StrEquals:
 2250     return SpecialStringEquals;
 2251   case Op_StrIndexOf:
 2252   case Op_StrIndexOfChar:
 2253     return SpecialStringIndexOf;
 2254   case Op_AddVB:
 2255   case Op_AddVS:
 2256   case Op_AddVI:
 2257   case Op_AddVF:
 2258   case Op_AddVD:
 2259   case Op_SubVB:
 2260   case Op_SubVS:
 2261   case Op_SubVI:
 2262   case Op_SubVF:
 2263   case Op_SubVD:
 2264   case Op_MulVS:
 2265   case Op_MulVF:
 2266   case Op_MulVD:
 2267   case Op_DivVF:
 2268   case Op_DivVD:
 2269   case Op_AbsVF:
 2270   case Op_AbsVD:
 2271   case Op_NegVF:
 2272   case Op_NegVD:
 2273   case Op_SqrtVF:
 2274   case Op_SqrtVD:
 2275   case Op_AddVL:
 2276   case Op_SubVL:
 2277   case Op_MulVI:
 2278   case Op_RoundDoubleModeV:
 2279     return SuperwordUseVSX;
 2280   case Op_PopCountVI:
 2281     return (SuperwordUseVSX &amp;&amp; UsePopCountInstruction);
 2282   case Op_FmaVF:
 2283   case Op_FmaVD:
 2284     return (SuperwordUseVSX &amp;&amp; UseFMA);
 2285   case Op_Digit:
 2286   case Op_LowerCase:
 2287   case Op_UpperCase:
 2288   case Op_Whitespace:
 2289     return UseCharacterCompareIntrinsics;
 2290 
 2291   case Op_CacheWB:
 2292   case Op_CacheWBPreSync:
 2293   case Op_CacheWBPostSync:
 2294     if (!VM_Version::supports_data_cache_line_flush()) {
 2295       ret_value = false;
 2296     }
 2297     break;
 2298   }
 2299 
 2300   return ret_value;  // Per default match rules are supported.
 2301 }
 2302 
 2303 const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {
 2304 
 2305   // TODO
 2306   // identify extra cases that we might want to provide match rules for
 2307   // e.g. Op_ vector nodes and other intrinsics while guarding with vlen
 2308   bool ret_value = match_rule_supported(opcode);
 2309   // Add rules here.
 2310 
 2311   return ret_value;  // Per default match rules are supported.
 2312 }
 2313 
 2314 const bool Matcher::has_predicated_vectors(void) {
 2315   return false;
 2316 }
 2317 
 2318 const int Matcher::float_pressure(int default_pressure_threshold) {
 2319   return default_pressure_threshold;
 2320 }
 2321 
 2322 int Matcher::regnum_to_fpu_offset(int regnum) {
 2323   // No user for this method?
 2324   Unimplemented();
 2325   return 999;
 2326 }
 2327 
 2328 const bool Matcher::convL2FSupported(void) {
 2329   // fcfids can do the conversion (&gt;= Power7).
 2330   // fcfid + frsp showed rounding problem when result should be 0x3f800001.
 2331   return VM_Version::has_fcfids(); // False means that conversion is done by runtime call.
 2332 }
 2333 
 2334 // Vector width in bytes.
 2335 const int Matcher::vector_width_in_bytes(BasicType bt) {
 2336   if (SuperwordUseVSX) {
 2337     assert(MaxVectorSize == 16, &quot;&quot;);
 2338     return 16;
 2339   } else {
 2340     assert(MaxVectorSize == 8, &quot;&quot;);
 2341     return 8;
 2342   }
 2343 }
 2344 
 2345 // Vector ideal reg.
 2346 const uint Matcher::vector_ideal_reg(int size) {
 2347   if (SuperwordUseVSX) {
 2348     assert(MaxVectorSize == 16 &amp;&amp; size == 16, &quot;&quot;);
 2349     return Op_VecX;
 2350   } else {
 2351     assert(MaxVectorSize == 8 &amp;&amp; size == 8, &quot;&quot;);
 2352     return Op_RegL;
 2353   }
 2354 }
 2355 
 2356 const uint Matcher::vector_shift_count_ideal_reg(int size) {
 2357   fatal(&quot;vector shift is not supported&quot;);
 2358   return Node::NotAMachineReg;
 2359 }
 2360 
 2361 // Limits on vector size (number of elements) loaded into vector.
 2362 const int Matcher::max_vector_size(const BasicType bt) {
 2363   assert(is_java_primitive(bt), &quot;only primitive type vectors&quot;);
 2364   return vector_width_in_bytes(bt)/type2aelembytes(bt);
 2365 }
 2366 
 2367 const int Matcher::min_vector_size(const BasicType bt) {
 2368   return max_vector_size(bt); // Same as max.
 2369 }
 2370 
 2371 // PPC implementation uses VSX load/store instructions (if
 2372 // SuperwordUseVSX) which support 4 byte but not arbitrary alignment
 2373 const bool Matcher::misaligned_vectors_ok() {
 2374   return false;
 2375 }
 2376 
 2377 // PPC AES support not yet implemented
 2378 const bool Matcher::pass_original_key_for_aes() {
 2379   return false;
 2380 }
 2381 
 2382 // RETURNS: whether this branch offset is short enough that a short
 2383 // branch can be used.
 2384 //
 2385 // If the platform does not provide any short branch variants, then
 2386 // this method should return `false&#39; for offset 0.
 2387 //
 2388 // `Compile::Fill_buffer&#39; will decide on basis of this information
 2389 // whether to do the pass `Compile::Shorten_branches&#39; at all.
 2390 //
 2391 // And `Compile::Shorten_branches&#39; will decide on basis of this
 2392 // information whether to replace particular branch sites by short
 2393 // ones.
 2394 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 2395   // Is the offset within the range of a ppc64 pc relative branch?
 2396   bool b;
 2397 
 2398   const int safety_zone = 3 * BytesPerInstWord;
 2399   b = Assembler::is_simm((offset&lt;0 ? offset-safety_zone : offset+safety_zone),
 2400                          29 - 16 + 1 + 2);
 2401   return b;
 2402 }
 2403 
 2404 const bool Matcher::isSimpleConstant64(jlong value) {
 2405   // Probably always true, even if a temp register is required.
 2406   return true;
 2407 }
 2408 /* TODO: PPC port
 2409 // Make a new machine dependent decode node (with its operands).
 2410 MachTypeNode *Matcher::make_decode_node() {
 2411   assert(CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0,
 2412          &quot;This method is only implemented for unscaled cOops mode so far&quot;);
 2413   MachTypeNode *decode = new decodeN_unscaledNode();
 2414   decode-&gt;set_opnd_array(0, new iRegPdstOper());
 2415   decode-&gt;set_opnd_array(1, new iRegNsrcOper());
 2416   return decode;
 2417 }
 2418 */
 2419 
 2420 // false =&gt; size gets scaled to BytesPerLong, ok.
 2421 const bool Matcher::init_array_count_is_in_bytes = false;
 2422 
 2423 // Use conditional move (CMOVL) on Power7.
 2424 const int Matcher::long_cmove_cost() { return 0; } // this only makes long cmoves more expensive than int cmoves
 2425 
 2426 // Suppress CMOVF. Conditional move available (sort of) on PPC64 only from P7 onwards. Not exploited yet.
 2427 // fsel doesn&#39;t accept a condition register as input, so this would be slightly different.
 2428 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
 2429 
 2430 // Power6 requires postalloc expand (see block.cpp for description of postalloc expand).
 2431 const bool Matcher::require_postalloc_expand = true;
 2432 
 2433 // Do we need to mask the count passed to shift instructions or does
 2434 // the cpu only look at the lower 5/6 bits anyway?
 2435 // PowerPC requires masked shift counts.
 2436 const bool Matcher::need_masked_shift_count = true;
 2437 
 2438 // No support for generic vector operands.
 2439 const bool Matcher::supports_generic_vector_operands  = false;
 2440 
 2441 MachOper* Matcher::specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {
 2442   ShouldNotReachHere(); // generic vector operands not supported
 2443   return NULL;
 2444 }
 2445 
 2446 bool Matcher::is_generic_reg2reg_move(MachNode* m) {
 2447   ShouldNotReachHere();  // generic vector operands not supported
 2448   return false;
 2449 }
 2450 
 2451 bool Matcher::is_generic_vector(MachOper* opnd)  {
 2452   ShouldNotReachHere();  // generic vector operands not supported
 2453   return false;
 2454 }
 2455 
 2456 // This affects two different things:
 2457 //  - how Decode nodes are matched
 2458 //  - how ImplicitNullCheck opportunities are recognized
 2459 // If true, the matcher will try to remove all Decodes and match them
 2460 // (as operands) into nodes. NullChecks are not prepared to deal with
 2461 // Decodes by final_graph_reshaping().
 2462 // If false, final_graph_reshaping() forces the decode behind the Cmp
 2463 // for a NullCheck. The matcher matches the Decode node into a register.
 2464 // Implicit_null_check optimization moves the Decode along with the
 2465 // memory operation back up before the NullCheck.
 2466 bool Matcher::narrow_oop_use_complex_address() {
 2467   // TODO: PPC port if (MatchDecodeNodes) return true;
 2468   return false;
 2469 }
 2470 
 2471 bool Matcher::narrow_klass_use_complex_address() {
 2472   NOT_LP64(ShouldNotCallThis());
 2473   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 2474   // TODO: PPC port if (MatchDecodeNodes) return true;
 2475   return false;
 2476 }
 2477 
 2478 bool Matcher::const_oop_prefer_decode() {
 2479   // Prefer ConN+DecodeN over ConP in simple compressed oops mode.
 2480   return CompressedOops::base() == NULL;
 2481 }
 2482 
 2483 bool Matcher::const_klass_prefer_decode() {
 2484   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
 2485   return CompressedKlassPointers::base() == NULL;
 2486 }
 2487 
 2488 // Is it better to copy float constants, or load them directly from memory?
 2489 // Intel can load a float constant from a direct address, requiring no
 2490 // extra registers. Most RISCs will have to materialize an address into a
 2491 // register first, so they would do better to copy the constant from stack.
 2492 const bool Matcher::rematerialize_float_constants = false;
 2493 
 2494 // If CPU can load and store mis-aligned doubles directly then no fixup is
 2495 // needed. Else we split the double into 2 integer pieces and move it
 2496 // piece-by-piece. Only happens when passing doubles into C code as the
 2497 // Java calling convention forces doubles to be aligned.
 2498 const bool Matcher::misaligned_doubles_ok = true;
 2499 
 2500 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
 2501  Unimplemented();
 2502 }
 2503 
 2504 // Advertise here if the CPU requires explicit rounding operations
 2505 // to implement the UseStrictFP mode.
 2506 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 2507 
 2508 // Do floats take an entire double register or just half?
 2509 //
 2510 // A float occupies a ppc64 double register. For the allocator, a
 2511 // ppc64 double register appears as a pair of float registers.
 2512 bool Matcher::float_in_double() { return true; }
 2513 
 2514 // Do ints take an entire long register or just half?
 2515 // The relevant question is how the int is callee-saved:
 2516 // the whole long is written but de-opt&#39;ing will have to extract
 2517 // the relevant 32 bits.
 2518 const bool Matcher::int_in_long = true;
 2519 
 2520 // Constants for c2c and c calling conventions.
 2521 
 2522 const MachRegisterNumbers iarg_reg[8] = {
 2523   R3_num, R4_num, R5_num, R6_num,
 2524   R7_num, R8_num, R9_num, R10_num
 2525 };
 2526 
 2527 const MachRegisterNumbers farg_reg[13] = {
 2528   F1_num, F2_num, F3_num, F4_num,
 2529   F5_num, F6_num, F7_num, F8_num,
 2530   F9_num, F10_num, F11_num, F12_num,
 2531   F13_num
 2532 };
 2533 
 2534 const MachRegisterNumbers vsarg_reg[64] = {
 2535   VSR0_num, VSR1_num, VSR2_num, VSR3_num,
 2536   VSR4_num, VSR5_num, VSR6_num, VSR7_num,
 2537   VSR8_num, VSR9_num, VSR10_num, VSR11_num,
 2538   VSR12_num, VSR13_num, VSR14_num, VSR15_num,
 2539   VSR16_num, VSR17_num, VSR18_num, VSR19_num,
 2540   VSR20_num, VSR21_num, VSR22_num, VSR23_num,
 2541   VSR24_num, VSR23_num, VSR24_num, VSR25_num,
 2542   VSR28_num, VSR29_num, VSR30_num, VSR31_num,
 2543   VSR32_num, VSR33_num, VSR34_num, VSR35_num,
 2544   VSR36_num, VSR37_num, VSR38_num, VSR39_num,
 2545   VSR40_num, VSR41_num, VSR42_num, VSR43_num,
 2546   VSR44_num, VSR45_num, VSR46_num, VSR47_num,
 2547   VSR48_num, VSR49_num, VSR50_num, VSR51_num,
 2548   VSR52_num, VSR53_num, VSR54_num, VSR55_num,
 2549   VSR56_num, VSR57_num, VSR58_num, VSR59_num,
 2550   VSR60_num, VSR61_num, VSR62_num, VSR63_num
 2551 };
 2552 
 2553 const int num_iarg_registers = sizeof(iarg_reg) / sizeof(iarg_reg[0]);
 2554 
 2555 const int num_farg_registers = sizeof(farg_reg) / sizeof(farg_reg[0]);
 2556 
 2557 const int num_vsarg_registers = sizeof(vsarg_reg) / sizeof(vsarg_reg[0]);
 2558 
 2559 // Return whether or not this register is ever used as an argument. This
 2560 // function is used on startup to build the trampoline stubs in generateOptoStub.
 2561 // Registers not mentioned will be killed by the VM call in the trampoline, and
 2562 // arguments in those registers not be available to the callee.
 2563 bool Matcher::can_be_java_arg(int reg) {
 2564   // We return true for all registers contained in iarg_reg[] and
 2565   // farg_reg[] and their virtual halves.
 2566   // We must include the virtual halves in order to get STDs and LDs
 2567   // instead of STWs and LWs in the trampoline stubs.
 2568 
 2569   if (   reg == R3_num  || reg == R3_H_num
 2570       || reg == R4_num  || reg == R4_H_num
 2571       || reg == R5_num  || reg == R5_H_num
 2572       || reg == R6_num  || reg == R6_H_num
 2573       || reg == R7_num  || reg == R7_H_num
 2574       || reg == R8_num  || reg == R8_H_num
 2575       || reg == R9_num  || reg == R9_H_num
 2576       || reg == R10_num || reg == R10_H_num)
 2577     return true;
 2578 
 2579   if (   reg == F1_num  || reg == F1_H_num
 2580       || reg == F2_num  || reg == F2_H_num
 2581       || reg == F3_num  || reg == F3_H_num
 2582       || reg == F4_num  || reg == F4_H_num
 2583       || reg == F5_num  || reg == F5_H_num
 2584       || reg == F6_num  || reg == F6_H_num
 2585       || reg == F7_num  || reg == F7_H_num
 2586       || reg == F8_num  || reg == F8_H_num
 2587       || reg == F9_num  || reg == F9_H_num
 2588       || reg == F10_num || reg == F10_H_num
 2589       || reg == F11_num || reg == F11_H_num
 2590       || reg == F12_num || reg == F12_H_num
 2591       || reg == F13_num || reg == F13_H_num)
 2592     return true;
 2593 
 2594   return false;
 2595 }
 2596 
 2597 bool Matcher::is_spillable_arg(int reg) {
 2598   return can_be_java_arg(reg);
 2599 }
 2600 
 2601 bool Matcher::use_asm_for_ldiv_by_con(jlong divisor) {
 2602   return false;
 2603 }
 2604 
 2605 // Register for DIVI projection of divmodI.
 2606 RegMask Matcher::divI_proj_mask() {
 2607   ShouldNotReachHere();
 2608   return RegMask();
 2609 }
 2610 
 2611 // Register for MODI projection of divmodI.
 2612 RegMask Matcher::modI_proj_mask() {
 2613   ShouldNotReachHere();
 2614   return RegMask();
 2615 }
 2616 
 2617 // Register for DIVL projection of divmodL.
 2618 RegMask Matcher::divL_proj_mask() {
 2619   ShouldNotReachHere();
 2620   return RegMask();
 2621 }
 2622 
 2623 // Register for MODL projection of divmodL.
 2624 RegMask Matcher::modL_proj_mask() {
 2625   ShouldNotReachHere();
 2626   return RegMask();
 2627 }
 2628 
 2629 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 2630   return RegMask();
 2631 }
 2632 
 2633 const bool Matcher::convi2l_type_required = true;
 2634 
 2635 %}
 2636 
 2637 //----------ENCODING BLOCK-----------------------------------------------------
 2638 // This block specifies the encoding classes used by the compiler to output
 2639 // byte streams. Encoding classes are parameterized macros used by
 2640 // Machine Instruction Nodes in order to generate the bit encoding of the
 2641 // instruction. Operands specify their base encoding interface with the
 2642 // interface keyword. There are currently supported four interfaces,
 2643 // REG_INTER, CONST_INTER, MEMORY_INTER, &amp; COND_INTER. REG_INTER causes an
 2644 // operand to generate a function which returns its register number when
 2645 // queried. CONST_INTER causes an operand to generate a function which
 2646 // returns the value of the constant when queried. MEMORY_INTER causes an
 2647 // operand to generate four functions which return the Base Register, the
 2648 // Index Register, the Scale Value, and the Offset Value of the operand when
 2649 // queried. COND_INTER causes an operand to generate six functions which
 2650 // return the encoding code (ie - encoding bits for the instruction)
 2651 // associated with each basic boolean condition for a conditional instruction.
 2652 //
 2653 // Instructions specify two basic values for encoding. Again, a function
 2654 // is available to check if the constant displacement is an oop. They use the
 2655 // ins_encode keyword to specify their encoding classes (which must be
 2656 // a sequence of enc_class names, and their parameters, specified in
 2657 // the encoding block), and they use the
 2658 // opcode keyword to specify, in order, their primary, secondary, and
 2659 // tertiary opcode. Only the opcode sections which a particular instruction
 2660 // needs for encoding need to be specified.
 2661 encode %{
 2662   enc_class enc_unimplemented %{
 2663     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 2664     MacroAssembler _masm(&amp;cbuf);
 2665     __ unimplemented(&quot;Unimplemented mach node encoding in AD file.&quot;, 13);
 2666   %}
 2667 
 2668   enc_class enc_untested %{
 2669 #ifdef ASSERT
 2670     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 2671     MacroAssembler _masm(&amp;cbuf);
 2672     __ untested(&quot;Untested mach node encoding in AD file.&quot;);
 2673 #else
 2674     // TODO: PPC port $archOpcode(ppc64Opcode_none);
 2675 #endif
 2676   %}
 2677 
 2678   enc_class enc_lbz(iRegIdst dst, memory mem) %{
 2679     // TODO: PPC port $archOpcode(ppc64Opcode_lbz);
 2680     MacroAssembler _masm(&amp;cbuf);
 2681     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2682     __ lbz($dst$$Register, Idisp, $mem$$base$$Register);
 2683   %}
 2684 
 2685   // Load acquire.
 2686   enc_class enc_lbz_ac(iRegIdst dst, memory mem) %{
 2687     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 2688     MacroAssembler _masm(&amp;cbuf);
 2689     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2690     __ lbz($dst$$Register, Idisp, $mem$$base$$Register);
 2691     __ twi_0($dst$$Register);
 2692     __ isync();
 2693   %}
 2694 
 2695   enc_class enc_lhz(iRegIdst dst, memory mem) %{
 2696     // TODO: PPC port $archOpcode(ppc64Opcode_lhz);
 2697 
 2698     MacroAssembler _masm(&amp;cbuf);
 2699     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2700     __ lhz($dst$$Register, Idisp, $mem$$base$$Register);
 2701   %}
 2702 
 2703   // Load acquire.
 2704   enc_class enc_lhz_ac(iRegIdst dst, memory mem) %{
 2705     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 2706 
 2707     MacroAssembler _masm(&amp;cbuf);
 2708     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2709     __ lhz($dst$$Register, Idisp, $mem$$base$$Register);
 2710     __ twi_0($dst$$Register);
 2711     __ isync();
 2712   %}
 2713 
 2714   enc_class enc_lwz(iRegIdst dst, memory mem) %{
 2715     // TODO: PPC port $archOpcode(ppc64Opcode_lwz);
 2716 
 2717     MacroAssembler _masm(&amp;cbuf);
 2718     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2719     __ lwz($dst$$Register, Idisp, $mem$$base$$Register);
 2720   %}
 2721 
 2722   // Load acquire.
 2723   enc_class enc_lwz_ac(iRegIdst dst, memory mem) %{
 2724     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 2725 
 2726     MacroAssembler _masm(&amp;cbuf);
 2727     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2728     __ lwz($dst$$Register, Idisp, $mem$$base$$Register);
 2729     __ twi_0($dst$$Register);
 2730     __ isync();
 2731   %}
 2732 
 2733   enc_class enc_ld(iRegLdst dst, memoryAlg4 mem) %{
 2734     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
 2735     MacroAssembler _masm(&amp;cbuf);
 2736     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2737     // Operand &#39;ds&#39; requires 4-alignment.
 2738     assert((Idisp &amp; 0x3) == 0, &quot;unaligned offset&quot;);
 2739     __ ld($dst$$Register, Idisp, $mem$$base$$Register);
 2740   %}
 2741 
 2742   // Load acquire.
 2743   enc_class enc_ld_ac(iRegLdst dst, memoryAlg4 mem) %{
 2744     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 2745     MacroAssembler _masm(&amp;cbuf);
 2746     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2747     // Operand &#39;ds&#39; requires 4-alignment.
 2748     assert((Idisp &amp; 0x3) == 0, &quot;unaligned offset&quot;);
 2749     __ ld($dst$$Register, Idisp, $mem$$base$$Register);
 2750     __ twi_0($dst$$Register);
 2751     __ isync();
 2752   %}
 2753 
 2754   enc_class enc_lfd(RegF dst, memory mem) %{
 2755     // TODO: PPC port $archOpcode(ppc64Opcode_lfd);
 2756     MacroAssembler _masm(&amp;cbuf);
 2757     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2758     __ lfd($dst$$FloatRegister, Idisp, $mem$$base$$Register);
 2759   %}
 2760 
 2761   enc_class enc_load_long_constL(iRegLdst dst, immL src, iRegLdst toc) %{
 2762     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
 2763 
 2764     MacroAssembler _masm(&amp;cbuf);
 2765     int toc_offset = 0;
 2766 
 2767     address const_toc_addr;
 2768     // Create a non-oop constant, no relocation needed.
 2769     // If it is an IC, it has a virtual_call_Relocation.
 2770     const_toc_addr = __ long_constant((jlong)$src$$constant);
 2771     if (const_toc_addr == NULL) {
 2772       ciEnv::current()-&gt;record_out_of_memory_failure();
 2773       return;
 2774     }
 2775 
 2776     // Get the constant&#39;s TOC offset.
 2777     toc_offset = __ offset_to_method_toc(const_toc_addr);
 2778 
 2779     // Keep the current instruction offset in mind.
 2780     ((loadConLNode*)this)-&gt;_cbuf_insts_offset = __ offset();
 2781 
 2782     __ ld($dst$$Register, toc_offset, $toc$$Register);
 2783   %}
 2784 
 2785   enc_class enc_load_long_constL_hi(iRegLdst dst, iRegLdst toc, immL src) %{
 2786     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 2787 
 2788     MacroAssembler _masm(&amp;cbuf);
 2789 
 2790     if (!ra_-&gt;C-&gt;in_scratch_emit_size()) {
 2791       address const_toc_addr;
 2792       // Create a non-oop constant, no relocation needed.
 2793       // If it is an IC, it has a virtual_call_Relocation.
 2794       const_toc_addr = __ long_constant((jlong)$src$$constant);
 2795       if (const_toc_addr == NULL) {
 2796         ciEnv::current()-&gt;record_out_of_memory_failure();
 2797         return;
 2798       }
 2799 
 2800       // Get the constant&#39;s TOC offset.
 2801       const int toc_offset = __ offset_to_method_toc(const_toc_addr);
 2802       // Store the toc offset of the constant.
 2803       ((loadConL_hiNode*)this)-&gt;_const_toc_offset = toc_offset;
 2804 
 2805       // Also keep the current instruction offset in mind.
 2806       ((loadConL_hiNode*)this)-&gt;_cbuf_insts_offset = __ offset();
 2807     }
 2808 
 2809     __ addis($dst$$Register, $toc$$Register, MacroAssembler::largeoffset_si16_si16_hi(_const_toc_offset));
 2810   %}
 2811 
 2812 %} // encode
 2813 
 2814 source %{
 2815 
 2816 typedef struct {
 2817   loadConL_hiNode *_large_hi;
 2818   loadConL_loNode *_large_lo;
 2819   loadConLNode    *_small;
 2820   MachNode        *_last;
 2821 } loadConLNodesTuple;
 2822 
 2823 loadConLNodesTuple loadConLNodesTuple_create(PhaseRegAlloc *ra_, Node *toc, immLOper *immSrc,
 2824                                              OptoReg::Name reg_second, OptoReg::Name reg_first) {
 2825   loadConLNodesTuple nodes;
 2826 
 2827   const bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
 2828   if (large_constant_pool) {
 2829     // Create new nodes.
 2830     loadConL_hiNode *m1 = new loadConL_hiNode();
 2831     loadConL_loNode *m2 = new loadConL_loNode();
 2832 
 2833     // inputs for new nodes
 2834     m1-&gt;add_req(NULL, toc);
 2835     m2-&gt;add_req(NULL, m1);
 2836 
 2837     // operands for new nodes
 2838     m1-&gt;_opnds[0] = new iRegLdstOper(); // dst
 2839     m1-&gt;_opnds[1] = immSrc;             // src
 2840     m1-&gt;_opnds[2] = new iRegPdstOper(); // toc
 2841     m2-&gt;_opnds[0] = new iRegLdstOper(); // dst
 2842     m2-&gt;_opnds[1] = immSrc;             // src
 2843     m2-&gt;_opnds[2] = new iRegLdstOper(); // base
 2844 
 2845     // Initialize ins_attrib TOC fields.
 2846     m1-&gt;_const_toc_offset = -1;
 2847     m2-&gt;_const_toc_offset_hi_node = m1;
 2848 
 2849     // Initialize ins_attrib instruction offset.
 2850     m1-&gt;_cbuf_insts_offset = -1;
 2851 
 2852     // register allocation for new nodes
 2853     ra_-&gt;set_pair(m1-&gt;_idx, reg_second, reg_first);
 2854     ra_-&gt;set_pair(m2-&gt;_idx, reg_second, reg_first);
 2855 
 2856     // Create result.
 2857     nodes._large_hi = m1;
 2858     nodes._large_lo = m2;
 2859     nodes._small = NULL;
 2860     nodes._last = nodes._large_lo;
 2861     assert(m2-&gt;bottom_type()-&gt;isa_long(), &quot;must be long&quot;);
 2862   } else {
 2863     loadConLNode *m2 = new loadConLNode();
 2864 
 2865     // inputs for new nodes
 2866     m2-&gt;add_req(NULL, toc);
 2867 
 2868     // operands for new nodes
 2869     m2-&gt;_opnds[0] = new iRegLdstOper(); // dst
 2870     m2-&gt;_opnds[1] = immSrc;             // src
 2871     m2-&gt;_opnds[2] = new iRegPdstOper(); // toc
 2872 
 2873     // Initialize ins_attrib instruction offset.
 2874     m2-&gt;_cbuf_insts_offset = -1;
 2875 
 2876     // register allocation for new nodes
 2877     ra_-&gt;set_pair(m2-&gt;_idx, reg_second, reg_first);
 2878 
 2879     // Create result.
 2880     nodes._large_hi = NULL;
 2881     nodes._large_lo = NULL;
 2882     nodes._small = m2;
 2883     nodes._last = nodes._small;
 2884     assert(m2-&gt;bottom_type()-&gt;isa_long(), &quot;must be long&quot;);
 2885   }
 2886 
 2887   return nodes;
 2888 }
 2889 
 2890 typedef struct {
 2891   loadConL_hiNode *_large_hi;
 2892   loadConL_loNode *_large_lo;
 2893   mtvsrdNode      *_moved;
 2894   xxspltdNode     *_replicated;
 2895   loadConLNode    *_small;
 2896   MachNode        *_last;
 2897 } loadConLReplicatedNodesTuple;
 2898 
 2899 loadConLReplicatedNodesTuple loadConLReplicatedNodesTuple_create(Compile *C, PhaseRegAlloc *ra_, Node *toc, immLOper *immSrc,
 2900                                                  vecXOper *dst, immI_0Oper *zero,
 2901                                                  OptoReg::Name reg_second, OptoReg::Name reg_first,
 2902                                                  OptoReg::Name reg_vec_second, OptoReg::Name reg_vec_first) {
 2903   loadConLReplicatedNodesTuple nodes;
 2904 
 2905   const bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
 2906   if (large_constant_pool) {
 2907     // Create new nodes.
 2908     loadConL_hiNode *m1 = new  loadConL_hiNode();
 2909     loadConL_loNode *m2 = new  loadConL_loNode();
 2910     mtvsrdNode *m3 = new  mtvsrdNode();
 2911     xxspltdNode *m4 = new  xxspltdNode();
 2912 
 2913     // inputs for new nodes
 2914     m1-&gt;add_req(NULL, toc);
 2915     m2-&gt;add_req(NULL, m1);
 2916     m3-&gt;add_req(NULL, m2);
 2917     m4-&gt;add_req(NULL, m3);
 2918 
 2919     // operands for new nodes
 2920     m1-&gt;_opnds[0] = new  iRegLdstOper(); // dst
 2921     m1-&gt;_opnds[1] = immSrc;              // src
 2922     m1-&gt;_opnds[2] = new  iRegPdstOper(); // toc
 2923 
 2924     m2-&gt;_opnds[0] = new  iRegLdstOper(); // dst
 2925     m2-&gt;_opnds[1] = immSrc;              // src
 2926     m2-&gt;_opnds[2] = new  iRegLdstOper(); // base
 2927 
 2928     m3-&gt;_opnds[0] = new  vecXOper();     // dst
 2929     m3-&gt;_opnds[1] = new  iRegLdstOper(); // src
 2930 
 2931     m4-&gt;_opnds[0] = new  vecXOper();     // dst
 2932     m4-&gt;_opnds[1] = new  vecXOper();     // src
 2933     m4-&gt;_opnds[2] = zero;
 2934 
 2935     // Initialize ins_attrib TOC fields.
 2936     m1-&gt;_const_toc_offset = -1;
 2937     m2-&gt;_const_toc_offset_hi_node = m1;
 2938 
 2939     // Initialize ins_attrib instruction offset.
 2940     m1-&gt;_cbuf_insts_offset = -1;
 2941 
 2942     // register allocation for new nodes
 2943     ra_-&gt;set_pair(m1-&gt;_idx, reg_second, reg_first);
 2944     ra_-&gt;set_pair(m2-&gt;_idx, reg_second, reg_first);
 2945     ra_-&gt;set1(m3-&gt;_idx, reg_second);
 2946     ra_-&gt;set2(m3-&gt;_idx, reg_vec_first);
 2947     ra_-&gt;set_pair(m4-&gt;_idx, reg_vec_second, reg_vec_first);
 2948 
 2949     // Create result.
 2950     nodes._large_hi = m1;
 2951     nodes._large_lo = m2;
 2952     nodes._moved = m3;
 2953     nodes._replicated = m4;
 2954     nodes._small = NULL;
 2955     nodes._last = nodes._replicated;
 2956     assert(m2-&gt;bottom_type()-&gt;isa_long(), &quot;must be long&quot;);
 2957   } else {
 2958     loadConLNode *m2 = new  loadConLNode();
 2959     mtvsrdNode *m3 = new  mtvsrdNode();
 2960     xxspltdNode *m4 = new  xxspltdNode();
 2961 
 2962     // inputs for new nodes
 2963     m2-&gt;add_req(NULL, toc);
 2964 
 2965     // operands for new nodes
 2966     m2-&gt;_opnds[0] = new  iRegLdstOper(); // dst
 2967     m2-&gt;_opnds[1] = immSrc;              // src
 2968     m2-&gt;_opnds[2] = new  iRegPdstOper(); // toc
 2969 
 2970     m3-&gt;_opnds[0] = new  vecXOper();     // dst
 2971     m3-&gt;_opnds[1] = new  iRegLdstOper(); // src
 2972 
 2973     m4-&gt;_opnds[0] = new  vecXOper();     // dst
 2974     m4-&gt;_opnds[1] = new  vecXOper();     // src
 2975     m4-&gt;_opnds[2] = zero;
 2976 
 2977     // Initialize ins_attrib instruction offset.
 2978     m2-&gt;_cbuf_insts_offset = -1;
 2979     ra_-&gt;set1(m3-&gt;_idx, reg_second);
 2980     ra_-&gt;set2(m3-&gt;_idx, reg_vec_first);
 2981     ra_-&gt;set_pair(m4-&gt;_idx, reg_vec_second, reg_vec_first);
 2982 
 2983     // register allocation for new nodes
 2984     ra_-&gt;set_pair(m2-&gt;_idx, reg_second, reg_first);
 2985 
 2986     // Create result.
 2987     nodes._large_hi = NULL;
 2988     nodes._large_lo = NULL;
 2989     nodes._small = m2;
 2990     nodes._moved = m3;
 2991     nodes._replicated = m4;
 2992     nodes._last = nodes._replicated;
 2993     assert(m2-&gt;bottom_type()-&gt;isa_long(), &quot;must be long&quot;);
 2994   }
 2995 
 2996   return nodes;
 2997 }
 2998 
 2999 %} // source
 3000 
 3001 encode %{
 3002   // Postalloc expand emitter for loading a long constant from the method&#39;s TOC.
 3003   // Enc_class needed as consttanttablebase is not supported by postalloc
 3004   // expand.
 3005   enc_class postalloc_expand_load_long_constant(iRegLdst dst, immL src, iRegLdst toc) %{
 3006     // Create new nodes.
 3007     loadConLNodesTuple loadConLNodes =
 3008       loadConLNodesTuple_create(ra_, n_toc, op_src,
 3009                                 ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3010 
 3011     // Push new nodes.
 3012     if (loadConLNodes._large_hi) nodes-&gt;push(loadConLNodes._large_hi);
 3013     if (loadConLNodes._last)     nodes-&gt;push(loadConLNodes._last);
 3014 
 3015     // some asserts
 3016     assert(nodes-&gt;length() &gt;= 1, &quot;must have created at least 1 node&quot;);
 3017     assert(loadConLNodes._last-&gt;bottom_type()-&gt;isa_long(), &quot;must be long&quot;);
 3018   %}
 3019 
 3020   enc_class enc_load_long_constP(iRegLdst dst, immP src, iRegLdst toc) %{
 3021     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
 3022 
 3023     MacroAssembler _masm(&amp;cbuf);
 3024     int toc_offset = 0;
 3025 
 3026     intptr_t val = $src$$constant;
 3027     relocInfo::relocType constant_reloc = $src-&gt;constant_reloc();  // src
 3028     address const_toc_addr;
 3029     if (constant_reloc == relocInfo::oop_type) {
 3030       // Create an oop constant and a corresponding relocation.
 3031       AddressLiteral a = __ allocate_oop_address((jobject)val);
 3032       const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
 3033       __ relocate(a.rspec());
 3034     } else if (constant_reloc == relocInfo::metadata_type) {
 3035       AddressLiteral a = __ constant_metadata_address((Metadata *)val);
 3036       const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
 3037       __ relocate(a.rspec());
 3038     } else {
 3039       // Create a non-oop constant, no relocation needed.
 3040       const_toc_addr = __ long_constant((jlong)$src$$constant);
 3041     }
 3042 
 3043     if (const_toc_addr == NULL) {
 3044       ciEnv::current()-&gt;record_out_of_memory_failure();
 3045       return;
 3046     }
 3047     // Get the constant&#39;s TOC offset.
 3048     toc_offset = __ offset_to_method_toc(const_toc_addr);
 3049 
 3050     __ ld($dst$$Register, toc_offset, $toc$$Register);
 3051   %}
 3052 
 3053   enc_class enc_load_long_constP_hi(iRegLdst dst, immP src, iRegLdst toc) %{
 3054     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 3055 
 3056     MacroAssembler _masm(&amp;cbuf);
 3057     if (!ra_-&gt;C-&gt;in_scratch_emit_size()) {
 3058       intptr_t val = $src$$constant;
 3059       relocInfo::relocType constant_reloc = $src-&gt;constant_reloc();  // src
 3060       address const_toc_addr;
 3061       if (constant_reloc == relocInfo::oop_type) {
 3062         // Create an oop constant and a corresponding relocation.
 3063         AddressLiteral a = __ allocate_oop_address((jobject)val);
 3064         const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
 3065         __ relocate(a.rspec());
 3066       } else if (constant_reloc == relocInfo::metadata_type) {
 3067         AddressLiteral a = __ constant_metadata_address((Metadata *)val);
 3068         const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
 3069         __ relocate(a.rspec());
 3070       } else {  // non-oop pointers, e.g. card mark base, heap top
 3071         // Create a non-oop constant, no relocation needed.
 3072         const_toc_addr = __ long_constant((jlong)$src$$constant);
 3073       }
 3074 
 3075       if (const_toc_addr == NULL) {
 3076         ciEnv::current()-&gt;record_out_of_memory_failure();
 3077         return;
 3078       }
 3079       // Get the constant&#39;s TOC offset.
 3080       const int toc_offset = __ offset_to_method_toc(const_toc_addr);
 3081       // Store the toc offset of the constant.
 3082       ((loadConP_hiNode*)this)-&gt;_const_toc_offset = toc_offset;
 3083     }
 3084 
 3085     __ addis($dst$$Register, $toc$$Register, MacroAssembler::largeoffset_si16_si16_hi(_const_toc_offset));
 3086   %}
 3087 
 3088   // Postalloc expand emitter for loading a ptr constant from the method&#39;s TOC.
 3089   // Enc_class needed as consttanttablebase is not supported by postalloc
 3090   // expand.
 3091   enc_class postalloc_expand_load_ptr_constant(iRegPdst dst, immP src, iRegLdst toc) %{
 3092     const bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
 3093     if (large_constant_pool) {
 3094       // Create new nodes.
 3095       loadConP_hiNode *m1 = new loadConP_hiNode();
 3096       loadConP_loNode *m2 = new loadConP_loNode();
 3097 
 3098       // inputs for new nodes
 3099       m1-&gt;add_req(NULL, n_toc);
 3100       m2-&gt;add_req(NULL, m1);
 3101 
 3102       // operands for new nodes
 3103       m1-&gt;_opnds[0] = new iRegPdstOper(); // dst
 3104       m1-&gt;_opnds[1] = op_src;             // src
 3105       m1-&gt;_opnds[2] = new iRegPdstOper(); // toc
 3106       m2-&gt;_opnds[0] = new iRegPdstOper(); // dst
 3107       m2-&gt;_opnds[1] = op_src;             // src
 3108       m2-&gt;_opnds[2] = new iRegLdstOper(); // base
 3109 
 3110       // Initialize ins_attrib TOC fields.
 3111       m1-&gt;_const_toc_offset = -1;
 3112       m2-&gt;_const_toc_offset_hi_node = m1;
 3113 
 3114       // Register allocation for new nodes.
 3115       ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3116       ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3117 
 3118       nodes-&gt;push(m1);
 3119       nodes-&gt;push(m2);
 3120       assert(m2-&gt;bottom_type()-&gt;isa_ptr(), &quot;must be ptr&quot;);
 3121     } else {
 3122       loadConPNode *m2 = new loadConPNode();
 3123 
 3124       // inputs for new nodes
 3125       m2-&gt;add_req(NULL, n_toc);
 3126 
 3127       // operands for new nodes
 3128       m2-&gt;_opnds[0] = new iRegPdstOper(); // dst
 3129       m2-&gt;_opnds[1] = op_src;             // src
 3130       m2-&gt;_opnds[2] = new iRegPdstOper(); // toc
 3131 
 3132       // Register allocation for new nodes.
 3133       ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3134 
 3135       nodes-&gt;push(m2);
 3136       assert(m2-&gt;bottom_type()-&gt;isa_ptr(), &quot;must be ptr&quot;);
 3137     }
 3138   %}
 3139 
 3140   // Enc_class needed as consttanttablebase is not supported by postalloc
 3141   // expand.
 3142   enc_class postalloc_expand_load_float_constant(regF dst, immF src, iRegLdst toc) %{
 3143     bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
 3144 
 3145     MachNode *m2;
 3146     if (large_constant_pool) {
 3147       m2 = new loadConFCompNode();
 3148     } else {
 3149       m2 = new loadConFNode();
 3150     }
 3151     // inputs for new nodes
 3152     m2-&gt;add_req(NULL, n_toc);
 3153 
 3154     // operands for new nodes
 3155     m2-&gt;_opnds[0] = op_dst;
 3156     m2-&gt;_opnds[1] = op_src;
 3157     m2-&gt;_opnds[2] = new iRegPdstOper(); // constanttablebase
 3158 
 3159     // register allocation for new nodes
 3160     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3161     nodes-&gt;push(m2);
 3162   %}
 3163 
 3164   // Enc_class needed as consttanttablebase is not supported by postalloc
 3165   // expand.
 3166   enc_class postalloc_expand_load_double_constant(regD dst, immD src, iRegLdst toc) %{
 3167     bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
 3168 
 3169     MachNode *m2;
 3170     if (large_constant_pool) {
 3171       m2 = new loadConDCompNode();
 3172     } else {
 3173       m2 = new loadConDNode();
 3174     }
 3175     // inputs for new nodes
 3176     m2-&gt;add_req(NULL, n_toc);
 3177 
 3178     // operands for new nodes
 3179     m2-&gt;_opnds[0] = op_dst;
 3180     m2-&gt;_opnds[1] = op_src;
 3181     m2-&gt;_opnds[2] = new iRegPdstOper(); // constanttablebase
 3182 
 3183     // register allocation for new nodes
 3184     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3185     nodes-&gt;push(m2);
 3186   %}
 3187 
 3188   enc_class enc_stw(iRegIsrc src, memory mem) %{
 3189     // TODO: PPC port $archOpcode(ppc64Opcode_stw);
 3190     MacroAssembler _masm(&amp;cbuf);
 3191     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 3192     __ stw($src$$Register, Idisp, $mem$$base$$Register);
 3193   %}
 3194 
 3195   enc_class enc_std(iRegIsrc src, memoryAlg4 mem) %{
 3196     // TODO: PPC port $archOpcode(ppc64Opcode_std);
 3197     MacroAssembler _masm(&amp;cbuf);
 3198     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 3199     // Operand &#39;ds&#39; requires 4-alignment.
 3200     assert((Idisp &amp; 0x3) == 0, &quot;unaligned offset&quot;);
 3201     __ std($src$$Register, Idisp, $mem$$base$$Register);
 3202   %}
 3203 
 3204   enc_class enc_stfs(RegF src, memory mem) %{
 3205     // TODO: PPC port $archOpcode(ppc64Opcode_stfs);
 3206     MacroAssembler _masm(&amp;cbuf);
 3207     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 3208     __ stfs($src$$FloatRegister, Idisp, $mem$$base$$Register);
 3209   %}
 3210 
 3211   enc_class enc_stfd(RegF src, memory mem) %{
 3212     // TODO: PPC port $archOpcode(ppc64Opcode_stfd);
 3213     MacroAssembler _masm(&amp;cbuf);
 3214     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 3215     __ stfd($src$$FloatRegister, Idisp, $mem$$base$$Register);
 3216   %}
 3217 
 3218   // Use release_store for card-marking to ensure that previous
 3219   // oop-stores are visible before the card-mark change.
 3220   enc_class enc_cms_card_mark(memory mem, iRegLdst releaseFieldAddr, flagsReg crx) %{
 3221     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 3222     // FIXME: Implement this as a cmove and use a fixed condition code
 3223     // register which is written on every transition to compiled code,
 3224     // e.g. in call-stub and when returning from runtime stubs.
 3225     //
 3226     // Proposed code sequence for the cmove implementation:
 3227     //
 3228     // Label skip_release;
 3229     // __ beq(CCRfixed, skip_release);
 3230     // __ release();
 3231     // __ bind(skip_release);
 3232     // __ stb(card mark);
 3233 
 3234     MacroAssembler _masm(&amp;cbuf);
 3235     Label skip_storestore;
 3236 
 3237 #if 0 // TODO: PPC port
 3238     // Check CMSCollectorCardTableBarrierSetBSExt::_requires_release and do the
 3239     // StoreStore barrier conditionally.
 3240     __ lwz(R0, 0, $releaseFieldAddr$$Register);
 3241     __ cmpwi($crx$$CondRegister, R0, 0);
 3242     __ beq_predict_taken($crx$$CondRegister, skip_storestore);
 3243 #endif
 3244     __ li(R0, 0);
 3245     __ membar(Assembler::StoreStore);
 3246 #if 0 // TODO: PPC port
 3247     __ bind(skip_storestore);
 3248 #endif
 3249 
 3250     // Do the store.
 3251     if ($mem$$index == 0) {
 3252       __ stb(R0, $mem$$disp, $mem$$base$$Register);
 3253     } else {
 3254       assert(0 == $mem$$disp, &quot;no displacement possible with indexed load/stores on ppc&quot;);
 3255       __ stbx(R0, $mem$$base$$Register, $mem$$index$$Register);
 3256     }
 3257   %}
 3258 
 3259   enc_class postalloc_expand_encode_oop(iRegNdst dst, iRegPdst src, flagsReg crx) %{
 3260 
 3261     if (VM_Version::has_isel()) {
 3262       // use isel instruction with Power 7
 3263       cmpP_reg_imm16Node *n_compare  = new cmpP_reg_imm16Node();
 3264       encodeP_subNode    *n_sub_base = new encodeP_subNode();
 3265       encodeP_shiftNode  *n_shift    = new encodeP_shiftNode();
 3266       cond_set_0_oopNode *n_cond_set = new cond_set_0_oopNode();
 3267 
 3268       n_compare-&gt;add_req(n_region, n_src);
 3269       n_compare-&gt;_opnds[0] = op_crx;
 3270       n_compare-&gt;_opnds[1] = op_src;
 3271       n_compare-&gt;_opnds[2] = new immL16Oper(0);
 3272 
 3273       n_sub_base-&gt;add_req(n_region, n_src);
 3274       n_sub_base-&gt;_opnds[0] = op_dst;
 3275       n_sub_base-&gt;_opnds[1] = op_src;
 3276       n_sub_base-&gt;_bottom_type = _bottom_type;
 3277 
 3278       n_shift-&gt;add_req(n_region, n_sub_base);
 3279       n_shift-&gt;_opnds[0] = op_dst;
 3280       n_shift-&gt;_opnds[1] = op_dst;
 3281       n_shift-&gt;_bottom_type = _bottom_type;
 3282 
 3283       n_cond_set-&gt;add_req(n_region, n_compare, n_shift);
 3284       n_cond_set-&gt;_opnds[0] = op_dst;
 3285       n_cond_set-&gt;_opnds[1] = op_crx;
 3286       n_cond_set-&gt;_opnds[2] = op_dst;
 3287       n_cond_set-&gt;_bottom_type = _bottom_type;
 3288 
 3289       ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
 3290       ra_-&gt;set_pair(n_sub_base-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3291       ra_-&gt;set_pair(n_shift-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3292       ra_-&gt;set_pair(n_cond_set-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3293 
 3294       nodes-&gt;push(n_compare);
 3295       nodes-&gt;push(n_sub_base);
 3296       nodes-&gt;push(n_shift);
 3297       nodes-&gt;push(n_cond_set);
 3298 
 3299     } else {
 3300       // before Power 7
 3301       moveRegNode        *n_move     = new moveRegNode();
 3302       cmpP_reg_imm16Node *n_compare  = new cmpP_reg_imm16Node();
 3303       encodeP_shiftNode  *n_shift    = new encodeP_shiftNode();
 3304       cond_sub_baseNode  *n_sub_base = new cond_sub_baseNode();
 3305 
 3306       n_move-&gt;add_req(n_region, n_src);
 3307       n_move-&gt;_opnds[0] = op_dst;
 3308       n_move-&gt;_opnds[1] = op_src;
 3309       ra_-&gt;set_oop(n_move, true); // Until here, &#39;n_move&#39; still produces an oop.
 3310 
 3311       n_compare-&gt;add_req(n_region, n_src);
 3312       n_compare-&gt;add_prec(n_move);
 3313 
 3314       n_compare-&gt;_opnds[0] = op_crx;
 3315       n_compare-&gt;_opnds[1] = op_src;
 3316       n_compare-&gt;_opnds[2] = new immL16Oper(0);
 3317 
 3318       n_sub_base-&gt;add_req(n_region, n_compare, n_src);
 3319       n_sub_base-&gt;_opnds[0] = op_dst;
 3320       n_sub_base-&gt;_opnds[1] = op_crx;
 3321       n_sub_base-&gt;_opnds[2] = op_src;
 3322       n_sub_base-&gt;_bottom_type = _bottom_type;
 3323 
 3324       n_shift-&gt;add_req(n_region, n_sub_base);
 3325       n_shift-&gt;_opnds[0] = op_dst;
 3326       n_shift-&gt;_opnds[1] = op_dst;
 3327       n_shift-&gt;_bottom_type = _bottom_type;
 3328 
 3329       ra_-&gt;set_pair(n_shift-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3330       ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
 3331       ra_-&gt;set_pair(n_sub_base-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3332       ra_-&gt;set_pair(n_move-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3333 
 3334       nodes-&gt;push(n_move);
 3335       nodes-&gt;push(n_compare);
 3336       nodes-&gt;push(n_sub_base);
 3337       nodes-&gt;push(n_shift);
 3338     }
 3339 
 3340     assert(!(ra_-&gt;is_oop(this)), &quot;sanity&quot;); // This is not supposed to be GC&#39;ed.
 3341   %}
 3342 
 3343   enc_class postalloc_expand_encode_oop_not_null(iRegNdst dst, iRegPdst src) %{
 3344 
 3345     encodeP_subNode *n1 = new encodeP_subNode();
 3346     n1-&gt;add_req(n_region, n_src);
 3347     n1-&gt;_opnds[0] = op_dst;
 3348     n1-&gt;_opnds[1] = op_src;
 3349     n1-&gt;_bottom_type = _bottom_type;
 3350 
 3351     encodeP_shiftNode *n2 = new encodeP_shiftNode();
 3352     n2-&gt;add_req(n_region, n1);
 3353     n2-&gt;_opnds[0] = op_dst;
 3354     n2-&gt;_opnds[1] = op_dst;
 3355     n2-&gt;_bottom_type = _bottom_type;
 3356     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3357     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3358 
 3359     nodes-&gt;push(n1);
 3360     nodes-&gt;push(n2);
 3361     assert(!(ra_-&gt;is_oop(this)), &quot;sanity&quot;); // This is not supposed to be GC&#39;ed.
 3362   %}
 3363 
 3364   enc_class postalloc_expand_decode_oop(iRegPdst dst, iRegNsrc src, flagsReg crx) %{
 3365     decodeN_shiftNode *n_shift    = new decodeN_shiftNode();
 3366     cmpN_reg_imm0Node *n_compare  = new cmpN_reg_imm0Node();
 3367 
 3368     n_compare-&gt;add_req(n_region, n_src);
 3369     n_compare-&gt;_opnds[0] = op_crx;
 3370     n_compare-&gt;_opnds[1] = op_src;
 3371     n_compare-&gt;_opnds[2] = new immN_0Oper(TypeNarrowOop::NULL_PTR);
 3372 
 3373     n_shift-&gt;add_req(n_region, n_src);
 3374     n_shift-&gt;_opnds[0] = op_dst;
 3375     n_shift-&gt;_opnds[1] = op_src;
 3376     n_shift-&gt;_bottom_type = _bottom_type;
 3377 
 3378     if (VM_Version::has_isel()) {
 3379       // use isel instruction with Power 7
 3380 
 3381       decodeN_addNode *n_add_base = new decodeN_addNode();
 3382       n_add_base-&gt;add_req(n_region, n_shift);
 3383       n_add_base-&gt;_opnds[0] = op_dst;
 3384       n_add_base-&gt;_opnds[1] = op_dst;
 3385       n_add_base-&gt;_bottom_type = _bottom_type;
 3386 
 3387       cond_set_0_ptrNode *n_cond_set = new cond_set_0_ptrNode();
 3388       n_cond_set-&gt;add_req(n_region, n_compare, n_add_base);
 3389       n_cond_set-&gt;_opnds[0] = op_dst;
 3390       n_cond_set-&gt;_opnds[1] = op_crx;
 3391       n_cond_set-&gt;_opnds[2] = op_dst;
 3392       n_cond_set-&gt;_bottom_type = _bottom_type;
 3393 
 3394       assert(ra_-&gt;is_oop(this) == true, &quot;A decodeN node must produce an oop!&quot;);
 3395       ra_-&gt;set_oop(n_cond_set, true);
 3396 
 3397       ra_-&gt;set_pair(n_shift-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3398       ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
 3399       ra_-&gt;set_pair(n_add_base-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3400       ra_-&gt;set_pair(n_cond_set-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3401 
 3402       nodes-&gt;push(n_compare);
 3403       nodes-&gt;push(n_shift);
 3404       nodes-&gt;push(n_add_base);
 3405       nodes-&gt;push(n_cond_set);
 3406 
 3407     } else {
 3408       // before Power 7
 3409       cond_add_baseNode *n_add_base = new cond_add_baseNode();
 3410 
 3411       n_add_base-&gt;add_req(n_region, n_compare, n_shift);
 3412       n_add_base-&gt;_opnds[0] = op_dst;
 3413       n_add_base-&gt;_opnds[1] = op_crx;
 3414       n_add_base-&gt;_opnds[2] = op_dst;
 3415       n_add_base-&gt;_bottom_type = _bottom_type;
 3416 
 3417       assert(ra_-&gt;is_oop(this) == true, &quot;A decodeN node must produce an oop!&quot;);
 3418       ra_-&gt;set_oop(n_add_base, true);
 3419 
 3420       ra_-&gt;set_pair(n_shift-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3421       ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
 3422       ra_-&gt;set_pair(n_add_base-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3423 
 3424       nodes-&gt;push(n_compare);
 3425       nodes-&gt;push(n_shift);
 3426       nodes-&gt;push(n_add_base);
 3427     }
 3428   %}
 3429 
 3430   enc_class postalloc_expand_decode_oop_not_null(iRegPdst dst, iRegNsrc src) %{
 3431     decodeN_shiftNode *n1 = new decodeN_shiftNode();
 3432     n1-&gt;add_req(n_region, n_src);
 3433     n1-&gt;_opnds[0] = op_dst;
 3434     n1-&gt;_opnds[1] = op_src;
 3435     n1-&gt;_bottom_type = _bottom_type;
 3436 
 3437     decodeN_addNode *n2 = new decodeN_addNode();
 3438     n2-&gt;add_req(n_region, n1);
 3439     n2-&gt;_opnds[0] = op_dst;
 3440     n2-&gt;_opnds[1] = op_dst;
 3441     n2-&gt;_bottom_type = _bottom_type;
 3442     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3443     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3444 
 3445     assert(ra_-&gt;is_oop(this) == true, &quot;A decodeN node must produce an oop!&quot;);
 3446     ra_-&gt;set_oop(n2, true);
 3447 
 3448     nodes-&gt;push(n1);
 3449     nodes-&gt;push(n2);
 3450   %}
 3451 
 3452   enc_class enc_cmove_reg(iRegIdst dst, flagsRegSrc crx, iRegIsrc src, cmpOp cmp) %{
 3453     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
 3454 
 3455     MacroAssembler _masm(&amp;cbuf);
 3456     int cc        = $cmp$$cmpcode;
 3457     int flags_reg = $crx$$reg;
 3458     Label done;
 3459     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, &quot;check encoding&quot;);
 3460     // Branch if not (cmp crx).
 3461     __ bc(cc_to_inverse_boint(cc), cc_to_biint(cc, flags_reg), done);
 3462     __ mr($dst$$Register, $src$$Register);
 3463     // TODO PPC port __ endgroup_if_needed(_size == 12);
 3464     __ bind(done);
 3465   %}
 3466 
 3467   enc_class enc_cmove_imm(iRegIdst dst, flagsRegSrc crx, immI16 src, cmpOp cmp) %{
 3468     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
 3469 
 3470     MacroAssembler _masm(&amp;cbuf);
 3471     Label done;
 3472     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, &quot;check encoding&quot;);
 3473     // Branch if not (cmp crx).
 3474     __ bc(cc_to_inverse_boint($cmp$$cmpcode), cc_to_biint($cmp$$cmpcode, $crx$$reg), done);
 3475     __ li($dst$$Register, $src$$constant);
 3476     // TODO PPC port __ endgroup_if_needed(_size == 12);
 3477     __ bind(done);
 3478   %}
 3479 
 3480   // This enc_class is needed so that scheduler gets proper
 3481   // input mapping for latency computation.
 3482   enc_class enc_andc(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 3483     // TODO: PPC port $archOpcode(ppc64Opcode_andc);
 3484     MacroAssembler _masm(&amp;cbuf);
 3485     __ andc($dst$$Register, $src1$$Register, $src2$$Register);
 3486   %}
 3487 
 3488   enc_class enc_convI2B_regI__cmove(iRegIdst dst, iRegIsrc src, flagsReg crx, immI16 zero, immI16 notzero) %{
 3489     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 3490 
 3491     MacroAssembler _masm(&amp;cbuf);
 3492 
 3493     Label done;
 3494     __ cmpwi($crx$$CondRegister, $src$$Register, 0);
 3495     __ li($dst$$Register, $zero$$constant);
 3496     __ beq($crx$$CondRegister, done);
 3497     __ li($dst$$Register, $notzero$$constant);
 3498     __ bind(done);
 3499   %}
 3500 
 3501   enc_class enc_convP2B_regP__cmove(iRegIdst dst, iRegPsrc src, flagsReg crx, immI16 zero, immI16 notzero) %{
 3502     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 3503 
 3504     MacroAssembler _masm(&amp;cbuf);
 3505 
 3506     Label done;
 3507     __ cmpdi($crx$$CondRegister, $src$$Register, 0);
 3508     __ li($dst$$Register, $zero$$constant);
 3509     __ beq($crx$$CondRegister, done);
 3510     __ li($dst$$Register, $notzero$$constant);
 3511     __ bind(done);
 3512   %}
 3513 
 3514   enc_class enc_cmove_bso_stackSlotL(iRegLdst dst, flagsRegSrc crx, stackSlotL mem ) %{
 3515     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
 3516 
 3517     MacroAssembler _masm(&amp;cbuf);
 3518     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 3519     Label done;
 3520     __ bso($crx$$CondRegister, done);
 3521     __ ld($dst$$Register, Idisp, $mem$$base$$Register);
 3522     // TODO PPC port __ endgroup_if_needed(_size == 12);
 3523     __ bind(done);
 3524   %}
 3525 
 3526   enc_class enc_cmove_bso_reg(iRegLdst dst, flagsRegSrc crx, regD src) %{
 3527     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
 3528 
 3529     MacroAssembler _masm(&amp;cbuf);
 3530     Label done;
 3531     __ bso($crx$$CondRegister, done);
 3532     __ mffprd($dst$$Register, $src$$FloatRegister);
 3533     // TODO PPC port __ endgroup_if_needed(_size == 12);
 3534     __ bind(done);
 3535   %}
 3536 
 3537   enc_class enc_bc(flagsRegSrc crx, cmpOp cmp, Label lbl) %{
 3538     // TODO: PPC port $archOpcode(ppc64Opcode_bc);
 3539 
 3540     MacroAssembler _masm(&amp;cbuf);
 3541     Label d;   // dummy
 3542     __ bind(d);
 3543     Label* p = ($lbl$$label);
 3544     // `p&#39; is `NULL&#39; when this encoding class is used only to
 3545     // determine the size of the encoded instruction.
 3546     Label&amp; l = (NULL == p)? d : *(p);
 3547     int cc = $cmp$$cmpcode;
 3548     int flags_reg = $crx$$reg;
 3549     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, &quot;check encoding&quot;);
 3550     int bhint = Assembler::bhintNoHint;
 3551 
 3552     if (UseStaticBranchPredictionForUncommonPathsPPC64) {
 3553       if (_prob &lt;= PROB_NEVER) {
 3554         bhint = Assembler::bhintIsNotTaken;
 3555       } else if (_prob &gt;= PROB_ALWAYS) {
 3556         bhint = Assembler::bhintIsTaken;
 3557       }
 3558     }
 3559 
 3560     __ bc(Assembler::add_bhint_to_boint(bhint, cc_to_boint(cc)),
 3561           cc_to_biint(cc, flags_reg),
 3562           l);
 3563   %}
 3564 
 3565   enc_class enc_bc_far(flagsRegSrc crx, cmpOp cmp, Label lbl) %{
 3566     // The scheduler doesn&#39;t know about branch shortening, so we set the opcode
 3567     // to ppc64Opcode_bc in order to hide this detail from the scheduler.
 3568     // TODO: PPC port $archOpcode(ppc64Opcode_bc);
 3569 
 3570     MacroAssembler _masm(&amp;cbuf);
 3571     Label d;    // dummy
 3572     __ bind(d);
 3573     Label* p = ($lbl$$label);
 3574     // `p&#39; is `NULL&#39; when this encoding class is used only to
 3575     // determine the size of the encoded instruction.
 3576     Label&amp; l = (NULL == p)? d : *(p);
 3577     int cc = $cmp$$cmpcode;
 3578     int flags_reg = $crx$$reg;
 3579     int bhint = Assembler::bhintNoHint;
 3580 
 3581     if (UseStaticBranchPredictionForUncommonPathsPPC64) {
 3582       if (_prob &lt;= PROB_NEVER) {
 3583         bhint = Assembler::bhintIsNotTaken;
 3584       } else if (_prob &gt;= PROB_ALWAYS) {
 3585         bhint = Assembler::bhintIsTaken;
 3586       }
 3587     }
 3588 
 3589     // Tell the conditional far branch to optimize itself when being relocated.
 3590     __ bc_far(Assembler::add_bhint_to_boint(bhint, cc_to_boint(cc)),
 3591                   cc_to_biint(cc, flags_reg),
 3592                   l,
 3593                   MacroAssembler::bc_far_optimize_on_relocate);
 3594   %}
 3595 
 3596   // Branch used with Power6 scheduling (can be shortened without changing the node).
 3597   enc_class enc_bc_short_far(flagsRegSrc crx, cmpOp cmp, Label lbl) %{
 3598     // The scheduler doesn&#39;t know about branch shortening, so we set the opcode
 3599     // to ppc64Opcode_bc in order to hide this detail from the scheduler.
 3600     // TODO: PPC port $archOpcode(ppc64Opcode_bc);
 3601 
 3602     MacroAssembler _masm(&amp;cbuf);
 3603     Label d;   // dummy
 3604     __ bind(d);
 3605     Label* p = ($lbl$$label);
 3606     // `p&#39; is `NULL&#39; when this encoding class is used only to
 3607     // determine the size of the encoded instruction.
 3608     Label&amp; l = (NULL == p)? d : *(p);
 3609     int cc = $cmp$$cmpcode;
 3610     int flags_reg = $crx$$reg;
 3611     int bhint = Assembler::bhintNoHint;
 3612 
 3613     if (UseStaticBranchPredictionForUncommonPathsPPC64) {
 3614       if (_prob &lt;= PROB_NEVER) {
 3615         bhint = Assembler::bhintIsNotTaken;
 3616       } else if (_prob &gt;= PROB_ALWAYS) {
 3617         bhint = Assembler::bhintIsTaken;
 3618       }
 3619     }
 3620 
 3621 #if 0 // TODO: PPC port
 3622     if (_size == 8) {
 3623       // Tell the conditional far branch to optimize itself when being relocated.
 3624       __ bc_far(Assembler::add_bhint_to_boint(bhint, cc_to_boint(cc)),
 3625                     cc_to_biint(cc, flags_reg),
 3626                     l,
 3627                     MacroAssembler::bc_far_optimize_on_relocate);
 3628     } else {
 3629       __ bc    (Assembler::add_bhint_to_boint(bhint, cc_to_boint(cc)),
 3630                     cc_to_biint(cc, flags_reg),
 3631                     l);
 3632     }
 3633 #endif
 3634     Unimplemented();
 3635   %}
 3636 
 3637   // Postalloc expand emitter for loading a replicatef float constant from
 3638   // the method&#39;s TOC.
 3639   // Enc_class needed as consttanttablebase is not supported by postalloc
 3640   // expand.
 3641   enc_class postalloc_expand_load_replF_constant(iRegLdst dst, immF src, iRegLdst toc) %{
 3642     // Create new nodes.
 3643 
 3644     // Make an operand with the bit pattern to load as float.
 3645     immLOper *op_repl = new immLOper((jlong)replicate_immF(op_src-&gt;constantF()));
 3646 
 3647     loadConLNodesTuple loadConLNodes =
 3648       loadConLNodesTuple_create(ra_, n_toc, op_repl,
 3649                                 ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3650 
 3651     // Push new nodes.
 3652     if (loadConLNodes._large_hi) nodes-&gt;push(loadConLNodes._large_hi);
 3653     if (loadConLNodes._last)     nodes-&gt;push(loadConLNodes._last);
 3654 
 3655     assert(nodes-&gt;length() &gt;= 1, &quot;must have created at least 1 node&quot;);
 3656     assert(loadConLNodes._last-&gt;bottom_type()-&gt;isa_long(), &quot;must be long&quot;);
 3657   %}
 3658 
 3659   enc_class postalloc_expand_load_replF_constant_vsx(vecX dst, immF src, iRegLdst toc, iRegLdst tmp) %{
 3660     // Create new nodes.
 3661 
 3662     // Make an operand with the bit pattern to load as float.
 3663     immLOper *op_repl = new  immLOper((jlong)replicate_immF(op_src-&gt;constantF()));
 3664     immI_0Oper *op_zero = new  immI_0Oper(0);
 3665 
 3666     loadConLReplicatedNodesTuple loadConLNodes =
 3667       loadConLReplicatedNodesTuple_create(C, ra_, n_toc, op_repl, op_dst, op_zero,
 3668                                 ra_-&gt;get_reg_second(n_tmp), ra_-&gt;get_reg_first(n_tmp),
 3669                                 ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3670 
 3671     // Push new nodes.
 3672     if (loadConLNodes._large_hi) { nodes-&gt;push(loadConLNodes._large_hi); }
 3673     if (loadConLNodes._large_lo) { nodes-&gt;push(loadConLNodes._large_lo); }
 3674     if (loadConLNodes._moved)    { nodes-&gt;push(loadConLNodes._moved); }
 3675     if (loadConLNodes._last)     { nodes-&gt;push(loadConLNodes._last); }
 3676 
 3677     assert(nodes-&gt;length() &gt;= 1, &quot;must have created at least 1 node&quot;);
 3678   %}
 3679 
 3680   // This enc_class is needed so that scheduler gets proper
 3681   // input mapping for latency computation.
 3682   enc_class enc_poll(immI dst, iRegLdst poll) %{
 3683     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
 3684     // Fake operand dst needed for PPC scheduler.
 3685     assert($dst$$constant == 0x0, &quot;dst must be 0x0&quot;);
 3686 
 3687     MacroAssembler _masm(&amp;cbuf);
 3688     // Mark the code position where the load from the safepoint
 3689     // polling page was emitted as relocInfo::poll_type.
 3690     __ relocate(relocInfo::poll_type);
 3691     __ load_from_polling_page($poll$$Register);
 3692   %}
 3693 
 3694   // A Java static call or a runtime call.
 3695   //
 3696   // Branch-and-link relative to a trampoline.
 3697   // The trampoline loads the target address and does a long branch to there.
 3698   // In case we call java, the trampoline branches to a interpreter_stub
 3699   // which loads the inline cache and the real call target from the constant pool.
 3700   //
 3701   // This basically looks like this:
 3702   //
 3703   // &gt;&gt;&gt;&gt; consts      -+  -+
 3704   //                   |   |- offset1
 3705   // [call target1]    | &lt;-+
 3706   // [IC cache]        |- offset2
 3707   // [call target2] &lt;--+
 3708   //
 3709   // &lt;&lt;&lt;&lt; consts
 3710   // &gt;&gt;&gt;&gt; insts
 3711   //
 3712   // bl offset16               -+  -+             ??? // How many bits available?
 3713   //                            |   |
 3714   // &lt;&lt;&lt;&lt; insts                 |   |
 3715   // &gt;&gt;&gt;&gt; stubs                 |   |
 3716   //                            |   |- trampoline_stub_Reloc
 3717   // trampoline stub:           | &lt;-+
 3718   //   r2 = toc                 |
 3719   //   r2 = [r2 + offset1]      |       // Load call target1 from const section
 3720   //   mtctr r2                 |
 3721   //   bctr                     |- static_stub_Reloc
 3722   // comp_to_interp_stub:   &lt;---+
 3723   //   r1 = toc
 3724   //   ICreg = [r1 + IC_offset]         // Load IC from const section
 3725   //   r1    = [r1 + offset2]           // Load call target2 from const section
 3726   //   mtctr r1
 3727   //   bctr
 3728   //
 3729   // &lt;&lt;&lt;&lt; stubs
 3730   //
 3731   // The call instruction in the code either
 3732   // - Branches directly to a compiled method if the offset is encodable in instruction.
 3733   // - Branches to the trampoline stub if the offset to the compiled method is not encodable.
 3734   // - Branches to the compiled_to_interp stub if the target is interpreted.
 3735   //
 3736   // Further there are three relocations from the loads to the constants in
 3737   // the constant section.
 3738   //
 3739   // Usage of r1 and r2 in the stubs allows to distinguish them.
 3740   enc_class enc_java_static_call(method meth) %{
 3741     // TODO: PPC port $archOpcode(ppc64Opcode_bl);
 3742 
 3743     MacroAssembler _masm(&amp;cbuf);
 3744     address entry_point = (address)$meth$$method;
 3745 
 3746     if (!_method) {
 3747       // A call to a runtime wrapper, e.g. new, new_typeArray_Java, uncommon_trap.
 3748       emit_call_with_trampoline_stub(_masm, entry_point, relocInfo::runtime_call_type);
 3749     } else {
 3750       // Remember the offset not the address.
 3751       const int start_offset = __ offset();
 3752 
 3753       // The trampoline stub.
 3754       // No entry point given, use the current pc.
 3755       // Make sure branch fits into
 3756       if (entry_point == 0) entry_point = __ pc();
 3757 
 3758       // Put the entry point as a constant into the constant pool.
 3759       const address entry_point_toc_addr = __ address_constant(entry_point, RelocationHolder::none);
 3760       if (entry_point_toc_addr == NULL) {
 3761         ciEnv::current()-&gt;record_out_of_memory_failure();
 3762         return;
 3763       }
 3764       const int entry_point_toc_offset = __ offset_to_method_toc(entry_point_toc_addr);
 3765 
 3766       // Emit the trampoline stub which will be related to the branch-and-link below.
 3767       CallStubImpl::emit_trampoline_stub(_masm, entry_point_toc_offset, start_offset);
 3768       if (ciEnv::current()-&gt;failing()) { return; } // Code cache may be full.
 3769       int method_index = resolved_method_index(cbuf);
 3770       __ relocate(_optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 3771                   : static_call_Relocation::spec(method_index));
 3772 
 3773       // The real call.
 3774       // Note: At this point we do not have the address of the trampoline
 3775       // stub, and the entry point might be too far away for bl, so __ pc()
 3776       // serves as dummy and the bl will be patched later.
 3777       cbuf.set_insts_mark();
 3778       __ bl(__ pc());  // Emits a relocation.
 3779 
 3780       // The stub for call to interpreter.
 3781       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 3782       if (stub == NULL) {
 3783         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 3784         return;
 3785       }
 3786     }
 3787   %}
 3788 
 3789   // Second node of expanded dynamic call - the call.
 3790   enc_class enc_java_dynamic_call_sched(method meth) %{
 3791     // TODO: PPC port $archOpcode(ppc64Opcode_bl);
 3792 
 3793     MacroAssembler _masm(&amp;cbuf);
 3794 
 3795     if (!ra_-&gt;C-&gt;in_scratch_emit_size()) {
 3796       // Create a call trampoline stub for the given method.
 3797       const address entry_point = !($meth$$method) ? 0 : (address)$meth$$method;
 3798       const address entry_point_const = __ address_constant(entry_point, RelocationHolder::none);
 3799       if (entry_point_const == NULL) {
 3800         ciEnv::current()-&gt;record_out_of_memory_failure();
 3801         return;
 3802       }
 3803       const int entry_point_const_toc_offset = __ offset_to_method_toc(entry_point_const);
 3804       CallStubImpl::emit_trampoline_stub(_masm, entry_point_const_toc_offset, __ offset());
 3805       if (ra_-&gt;C-&gt;env()-&gt;failing()) { return; } // Code cache may be full.
 3806 
 3807       // Build relocation at call site with ic position as data.
 3808       assert((_load_ic_hi_node != NULL &amp;&amp; _load_ic_node == NULL) ||
 3809              (_load_ic_hi_node == NULL &amp;&amp; _load_ic_node != NULL),
 3810              &quot;must have one, but can&#39;t have both&quot;);
 3811       assert((_load_ic_hi_node != NULL &amp;&amp; _load_ic_hi_node-&gt;_cbuf_insts_offset != -1) ||
 3812              (_load_ic_node != NULL    &amp;&amp; _load_ic_node-&gt;_cbuf_insts_offset != -1),
 3813              &quot;must contain instruction offset&quot;);
 3814       const int virtual_call_oop_addr_offset = _load_ic_hi_node != NULL
 3815         ? _load_ic_hi_node-&gt;_cbuf_insts_offset
 3816         : _load_ic_node-&gt;_cbuf_insts_offset;
 3817       const address virtual_call_oop_addr = __ addr_at(virtual_call_oop_addr_offset);
 3818       assert(MacroAssembler::is_load_const_from_method_toc_at(virtual_call_oop_addr),
 3819              &quot;should be load from TOC&quot;);
 3820       int method_index = resolved_method_index(cbuf);
 3821       __ relocate(virtual_call_Relocation::spec(virtual_call_oop_addr, method_index));
 3822     }
 3823 
 3824     // At this point I do not have the address of the trampoline stub,
 3825     // and the entry point might be too far away for bl. Pc() serves
 3826     // as dummy and bl will be patched later.
 3827     __ bl((address) __ pc());
 3828   %}
 3829 
 3830   // postalloc expand emitter for virtual calls.
 3831   enc_class postalloc_expand_java_dynamic_call_sched(method meth, iRegLdst toc) %{
 3832 
 3833     // Create the nodes for loading the IC from the TOC.
 3834     loadConLNodesTuple loadConLNodes_IC =
 3835       loadConLNodesTuple_create(ra_, n_toc, new immLOper((jlong)Universe::non_oop_word()),
 3836                                 OptoReg::Name(R19_H_num), OptoReg::Name(R19_num));
 3837 
 3838     // Create the call node.
 3839     CallDynamicJavaDirectSchedNode *call = new CallDynamicJavaDirectSchedNode();
 3840     call-&gt;_method_handle_invoke = _method_handle_invoke;
 3841     call-&gt;_vtable_index      = _vtable_index;
 3842     call-&gt;_method            = _method;
 3843     call-&gt;_bci               = _bci;
 3844     call-&gt;_optimized_virtual = _optimized_virtual;
 3845     call-&gt;_tf                = _tf;
 3846     call-&gt;_entry_point       = _entry_point;
 3847     call-&gt;_cnt               = _cnt;
 3848     call-&gt;_argsize           = _argsize;
 3849     call-&gt;_oop_map           = _oop_map;
 3850     call-&gt;_jvms              = _jvms;
 3851     call-&gt;_jvmadj            = _jvmadj;
 3852     call-&gt;_in_rms            = _in_rms;
 3853     call-&gt;_nesting           = _nesting;
 3854     call-&gt;_override_symbolic_info = _override_symbolic_info;
 3855 
 3856     // New call needs all inputs of old call.
 3857     // Req...
 3858     for (uint i = 0; i &lt; req(); ++i) {
 3859       // The expanded node does not need toc any more.
 3860       // Add the inline cache constant here instead. This expresses the
 3861       // register of the inline cache must be live at the call.
 3862       // Else we would have to adapt JVMState by -1.
 3863       if (i == mach_constant_base_node_input()) {
 3864         call-&gt;add_req(loadConLNodes_IC._last);
 3865       } else {
 3866         call-&gt;add_req(in(i));
 3867       }
 3868     }
 3869     // ...as well as prec
 3870     for (uint i = req(); i &lt; len(); ++i) {
 3871       call-&gt;add_prec(in(i));
 3872     }
 3873 
 3874     // Remember nodes loading the inline cache into r19.
 3875     call-&gt;_load_ic_hi_node = loadConLNodes_IC._large_hi;
 3876     call-&gt;_load_ic_node    = loadConLNodes_IC._small;
 3877 
 3878     // Operands for new nodes.
 3879     call-&gt;_opnds[0] = _opnds[0];
 3880     call-&gt;_opnds[1] = _opnds[1];
 3881 
 3882     // Only the inline cache is associated with a register.
 3883     assert(Matcher::inline_cache_reg() == OptoReg::Name(R19_num), &quot;ic reg should be R19&quot;);
 3884 
 3885     // Push new nodes.
 3886     if (loadConLNodes_IC._large_hi) nodes-&gt;push(loadConLNodes_IC._large_hi);
 3887     if (loadConLNodes_IC._last)     nodes-&gt;push(loadConLNodes_IC._last);
 3888     nodes-&gt;push(call);
 3889   %}
 3890 
 3891   // Compound version of call dynamic
 3892   // Toc is only passed so that it can be used in ins_encode statement.
 3893   // In the code we have to use $constanttablebase.
 3894   enc_class enc_java_dynamic_call(method meth, iRegLdst toc) %{
 3895     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 3896     MacroAssembler _masm(&amp;cbuf);
 3897     int start_offset = __ offset();
 3898 
 3899     Register Rtoc = (ra_) ? $constanttablebase : R2_TOC;
 3900 #if 0
 3901     int vtable_index = this-&gt;_vtable_index;
 3902     if (_vtable_index &lt; 0) {
 3903       // Must be invalid_vtable_index, not nonvirtual_vtable_index.
 3904       assert(_vtable_index == Method::invalid_vtable_index, &quot;correct sentinel value&quot;);
 3905       Register ic_reg = as_Register(Matcher::inline_cache_reg_encode());
 3906 
 3907       // Virtual call relocation will point to ic load.
 3908       address virtual_call_meta_addr = __ pc();
 3909       // Load a clear inline cache.
 3910       AddressLiteral empty_ic((address) Universe::non_oop_word());
 3911       bool success = __ load_const_from_method_toc(ic_reg, empty_ic, Rtoc, /*fixed_size*/ true);
 3912       if (!success) {
 3913         ciEnv::current()-&gt;record_out_of_memory_failure();
 3914         return;
 3915       }
 3916       // CALL to fixup routine.  Fixup routine uses ScopeDesc info
 3917       // to determine who we intended to call.
 3918       __ relocate(virtual_call_Relocation::spec(virtual_call_meta_addr));
 3919       emit_call_with_trampoline_stub(_masm, (address)$meth$$method, relocInfo::none);
 3920       assert(((MachCallDynamicJavaNode*)this)-&gt;ret_addr_offset() == __ offset() - start_offset,
 3921              &quot;Fix constant in ret_addr_offset()&quot;);
 3922     } else {
 3923       assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
 3924       // Go thru the vtable. Get receiver klass. Receiver already
 3925       // checked for non-null. If we&#39;ll go thru a C2I adapter, the
 3926       // interpreter expects method in R19_method.
 3927 
 3928       __ load_klass(R11_scratch1, R3);
 3929 
 3930       int entry_offset = in_bytes(Klass::vtable_start_offset()) + _vtable_index * vtableEntry::size_in_bytes();
 3931       int v_off = entry_offset + vtableEntry::method_offset_in_bytes();
 3932       __ li(R19_method, v_off);
 3933       __ ldx(R19_method/*method oop*/, R19_method/*method offset*/, R11_scratch1/*class*/);
 3934       // NOTE: for vtable dispatches, the vtable entry will never be
 3935       // null. However it may very well end up in handle_wrong_method
 3936       // if the method is abstract for the particular class.
 3937       __ ld(R11_scratch1, in_bytes(Method::from_compiled_offset()), R19_method);
 3938       // Call target. Either compiled code or C2I adapter.
 3939       __ mtctr(R11_scratch1);
 3940       __ bctrl();
 3941       if (((MachCallDynamicJavaNode*)this)-&gt;ret_addr_offset() != __ offset() - start_offset) {
 3942         tty-&gt;print(&quot; %d, %d\n&quot;, ((MachCallDynamicJavaNode*)this)-&gt;ret_addr_offset(),__ offset() - start_offset);
 3943       }
 3944       assert(((MachCallDynamicJavaNode*)this)-&gt;ret_addr_offset() == __ offset() - start_offset,
 3945              &quot;Fix constant in ret_addr_offset()&quot;);
 3946     }
 3947 #endif
 3948     Unimplemented();  // ret_addr_offset not yet fixed. Depends on compressed oops (load klass!).
 3949   %}
 3950 
 3951   // a runtime call
 3952   enc_class enc_java_to_runtime_call (method meth) %{
 3953     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 3954 
 3955     MacroAssembler _masm(&amp;cbuf);
 3956     const address start_pc = __ pc();
 3957 
 3958 #if defined(ABI_ELFv2)
 3959     address entry= !($meth$$method) ? NULL : (address)$meth$$method;
 3960     __ call_c(entry, relocInfo::runtime_call_type);
 3961 #else
 3962     // The function we&#39;re going to call.
 3963     FunctionDescriptor fdtemp;
 3964     const FunctionDescriptor* fd = !($meth$$method) ? &amp;fdtemp : (FunctionDescriptor*)$meth$$method;
 3965 
 3966     Register Rtoc = R12_scratch2;
 3967     // Calculate the method&#39;s TOC.
 3968     __ calculate_address_from_global_toc(Rtoc, __ method_toc());
 3969     // Put entry, env, toc into the constant pool, this needs up to 3 constant
 3970     // pool entries; call_c_using_toc will optimize the call.
 3971     bool success = __ call_c_using_toc(fd, relocInfo::runtime_call_type, Rtoc);
 3972     if (!success) {
 3973       ciEnv::current()-&gt;record_out_of_memory_failure();
 3974       return;
 3975     }
 3976 #endif
 3977 
 3978     // Check the ret_addr_offset.
 3979     assert(((MachCallRuntimeNode*)this)-&gt;ret_addr_offset() ==  __ last_calls_return_pc() - start_pc,
 3980            &quot;Fix constant in ret_addr_offset()&quot;);
 3981   %}
 3982 
 3983   // Move to ctr for leaf call.
 3984   // This enc_class is needed so that scheduler gets proper
 3985   // input mapping for latency computation.
 3986   enc_class enc_leaf_call_mtctr(iRegLsrc src) %{
 3987     // TODO: PPC port $archOpcode(ppc64Opcode_mtctr);
 3988     MacroAssembler _masm(&amp;cbuf);
 3989     __ mtctr($src$$Register);
 3990   %}
 3991 
 3992   // Postalloc expand emitter for runtime leaf calls.
 3993   enc_class postalloc_expand_java_to_runtime_call(method meth, iRegLdst toc) %{
 3994     loadConLNodesTuple loadConLNodes_Entry;
 3995 #if defined(ABI_ELFv2)
 3996     jlong entry_address = (jlong) this-&gt;entry_point();
 3997     assert(entry_address, &quot;need address here&quot;);
 3998     loadConLNodes_Entry = loadConLNodesTuple_create(ra_, n_toc, new immLOper(entry_address),
 3999                                                     OptoReg::Name(R12_H_num), OptoReg::Name(R12_num));
 4000 #else
 4001     // Get the struct that describes the function we are about to call.
 4002     FunctionDescriptor* fd = (FunctionDescriptor*) this-&gt;entry_point();
 4003     assert(fd, &quot;need fd here&quot;);
 4004     jlong entry_address = (jlong) fd-&gt;entry();
 4005     // new nodes
 4006     loadConLNodesTuple loadConLNodes_Env;
 4007     loadConLNodesTuple loadConLNodes_Toc;
 4008 
 4009     // Create nodes and operands for loading the entry point.
 4010     loadConLNodes_Entry = loadConLNodesTuple_create(ra_, n_toc, new immLOper(entry_address),
 4011                                                     OptoReg::Name(R12_H_num), OptoReg::Name(R12_num));
 4012 
 4013 
 4014     // Create nodes and operands for loading the env pointer.
 4015     if (fd-&gt;env() != NULL) {
 4016       loadConLNodes_Env = loadConLNodesTuple_create(ra_, n_toc, new immLOper((jlong) fd-&gt;env()),
 4017                                                     OptoReg::Name(R11_H_num), OptoReg::Name(R11_num));
 4018     } else {
 4019       loadConLNodes_Env._large_hi = NULL;
 4020       loadConLNodes_Env._large_lo = NULL;
 4021       loadConLNodes_Env._small    = NULL;
 4022       loadConLNodes_Env._last = new loadConL16Node();
 4023       loadConLNodes_Env._last-&gt;_opnds[0] = new iRegLdstOper();
 4024       loadConLNodes_Env._last-&gt;_opnds[1] = new immL16Oper(0);
 4025       ra_-&gt;set_pair(loadConLNodes_Env._last-&gt;_idx, OptoReg::Name(R11_H_num), OptoReg::Name(R11_num));
 4026     }
 4027 
 4028     // Create nodes and operands for loading the Toc point.
 4029     loadConLNodes_Toc = loadConLNodesTuple_create(ra_, n_toc, new immLOper((jlong) fd-&gt;toc()),
 4030                                                   OptoReg::Name(R2_H_num), OptoReg::Name(R2_num));
 4031 #endif // ABI_ELFv2
 4032     // mtctr node
 4033     MachNode *mtctr = new CallLeafDirect_mtctrNode();
 4034 
 4035     assert(loadConLNodes_Entry._last != NULL, &quot;entry must exist&quot;);
 4036     mtctr-&gt;add_req(0, loadConLNodes_Entry._last);
 4037 
 4038     mtctr-&gt;_opnds[0] = new iRegLdstOper();
 4039     mtctr-&gt;_opnds[1] = new iRegLdstOper();
 4040 
 4041     // call node
 4042     MachCallLeafNode *call = new CallLeafDirectNode();
 4043 
 4044     call-&gt;_opnds[0] = _opnds[0];
 4045     call-&gt;_opnds[1] = new methodOper((intptr_t) entry_address); // May get set later.
 4046 
 4047     // Make the new call node look like the old one.
 4048     call-&gt;_name        = _name;
 4049     call-&gt;_tf          = _tf;
 4050     call-&gt;_entry_point = _entry_point;
 4051     call-&gt;_cnt         = _cnt;
 4052     call-&gt;_argsize     = _argsize;
 4053     call-&gt;_oop_map     = _oop_map;
 4054     guarantee(!_jvms, &quot;You must clone the jvms and adapt the offsets by fix_jvms().&quot;);
 4055     call-&gt;_jvms        = NULL;
 4056     call-&gt;_jvmadj      = _jvmadj;
 4057     call-&gt;_in_rms      = _in_rms;
 4058     call-&gt;_nesting     = _nesting;
 4059 
 4060 
 4061     // New call needs all inputs of old call.
 4062     // Req...
 4063     for (uint i = 0; i &lt; req(); ++i) {
 4064       if (i != mach_constant_base_node_input()) {
 4065         call-&gt;add_req(in(i));
 4066       }
 4067     }
 4068 
 4069     // These must be reqired edges, as the registers are live up to
 4070     // the call. Else the constants are handled as kills.
 4071     call-&gt;add_req(mtctr);
 4072 #if !defined(ABI_ELFv2)
 4073     call-&gt;add_req(loadConLNodes_Env._last);
 4074     call-&gt;add_req(loadConLNodes_Toc._last);
 4075 #endif
 4076 
 4077     // ...as well as prec
 4078     for (uint i = req(); i &lt; len(); ++i) {
 4079       call-&gt;add_prec(in(i));
 4080     }
 4081 
 4082     // registers
 4083     ra_-&gt;set1(mtctr-&gt;_idx, OptoReg::Name(SR_CTR_num));
 4084 
 4085     // Insert the new nodes.
 4086     if (loadConLNodes_Entry._large_hi) nodes-&gt;push(loadConLNodes_Entry._large_hi);
 4087     if (loadConLNodes_Entry._last)     nodes-&gt;push(loadConLNodes_Entry._last);
 4088 #if !defined(ABI_ELFv2)
 4089     if (loadConLNodes_Env._large_hi)   nodes-&gt;push(loadConLNodes_Env._large_hi);
 4090     if (loadConLNodes_Env._last)       nodes-&gt;push(loadConLNodes_Env._last);
 4091     if (loadConLNodes_Toc._large_hi)   nodes-&gt;push(loadConLNodes_Toc._large_hi);
 4092     if (loadConLNodes_Toc._last)       nodes-&gt;push(loadConLNodes_Toc._last);
 4093 #endif
 4094     nodes-&gt;push(mtctr);
 4095     nodes-&gt;push(call);
 4096   %}
 4097 %}
 4098 
 4099 //----------FRAME--------------------------------------------------------------
 4100 // Definition of frame structure and management information.
 4101 
 4102 frame %{
 4103   // What direction does stack grow in (assumed to be same for native &amp; Java).
 4104   stack_direction(TOWARDS_LOW);
 4105 
 4106   // These two registers define part of the calling convention between
 4107   // compiled code and the interpreter.
 4108 
 4109   // Inline Cache Register or method for I2C.
 4110   inline_cache_reg(R19); // R19_method
 4111 
 4112   // Method Oop Register when calling interpreter.
 4113   interpreter_method_oop_reg(R19); // R19_method
 4114 
 4115   // Optional: name the operand used by cisc-spilling to access
 4116   // [stack_pointer + offset].
 4117   cisc_spilling_operand_name(indOffset);
 4118 
 4119   // Number of stack slots consumed by a Monitor enter.
 4120   sync_stack_slots((frame::jit_monitor_size / VMRegImpl::stack_slot_size));
 4121 
 4122   // Compiled code&#39;s Frame Pointer.
 4123   frame_pointer(R1); // R1_SP
 4124 
 4125   // Interpreter stores its frame pointer in a register which is
 4126   // stored to the stack by I2CAdaptors. I2CAdaptors convert from
 4127   // interpreted java to compiled java.
 4128   //
 4129   // R14_state holds pointer to caller&#39;s cInterpreter.
 4130   interpreter_frame_pointer(R14); // R14_state
 4131 
 4132   stack_alignment(frame::alignment_in_bytes);
 4133 
 4134   in_preserve_stack_slots((frame::jit_in_preserve_size / VMRegImpl::stack_slot_size));
 4135 
 4136   // Number of outgoing stack slots killed above the
 4137   // out_preserve_stack_slots for calls to C. Supports the var-args
 4138   // backing area for register parms.
 4139   //
 4140   varargs_C_out_slots_killed(((frame::abi_reg_args_size - frame::jit_out_preserve_size) / VMRegImpl::stack_slot_size));
 4141 
 4142   // The after-PROLOG location of the return address. Location of
 4143   // return address specifies a type (REG or STACK) and a number
 4144   // representing the register number (i.e. - use a register name) or
 4145   // stack slot.
 4146   //
 4147   // A: Link register is stored in stack slot ...
 4148   // M:  ... but it&#39;s in the caller&#39;s frame according to PPC-64 ABI.
 4149   // J: Therefore, we make sure that the link register is also in R11_scratch1
 4150   //    at the end of the prolog.
 4151   // B: We use R20, now.
 4152   //return_addr(REG R20);
 4153 
 4154   // G: After reading the comments made by all the luminaries on their
 4155   //    failure to tell the compiler where the return address really is,
 4156   //    I hardly dare to try myself.  However, I&#39;m convinced it&#39;s in slot
 4157   //    4 what apparently works and saves us some spills.
 4158   return_addr(STACK 4);
 4159 
 4160   // This is the body of the function
 4161   //
 4162   // void Matcher::calling_convention(OptoRegPair* sig, // array of ideal regs
 4163   //                                  uint length,      // length of array
 4164   //                                  bool is_outgoing)
 4165   //
 4166   // The `sig&#39; array is to be updated. sig[j] represents the location
 4167   // of the j-th argument, either a register or a stack slot.
 4168 
 4169   // Comment taken from i486.ad:
 4170   // Body of function which returns an integer array locating
 4171   // arguments either in registers or in stack slots. Passed an array
 4172   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count. Stack-slot
 4173   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 4174   // arguments for a CALLEE. Incoming stack arguments are
 4175   // automatically biased by the preserve_stack_slots field above.
 4176   calling_convention %{
 4177     // No difference between ingoing/outgoing. Just pass false.
 4178     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
 4179   %}
 4180 
 4181   // Comment taken from i486.ad:
 4182   // Body of function which returns an integer array locating
 4183   // arguments either in registers or in stack slots. Passed an array
 4184   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count. Stack-slot
 4185   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 4186   // arguments for a CALLEE. Incoming stack arguments are
 4187   // automatically biased by the preserve_stack_slots field above.
 4188   c_calling_convention %{
 4189     // This is obviously always outgoing.
 4190     // C argument in register AND stack slot.
 4191     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 4192   %}
 4193 
 4194   // Location of native (C/C++) and interpreter return values. This
 4195   // is specified to be the same as Java. In the 32-bit VM, long
 4196   // values are actually returned from native calls in O0:O1 and
 4197   // returned to the interpreter in I0:I1. The copying to and from
 4198   // the register pairs is done by the appropriate call and epilog
 4199   // opcodes. This simplifies the register allocator.
 4200   c_return_value %{
 4201     assert((ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL) ||
 4202             (ideal_reg == Op_RegN &amp;&amp; CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0),
 4203             &quot;only return normal values&quot;);
 4204     // enum names from opcodes.hpp:    Op_Node Op_Set Op_RegN       Op_RegI       Op_RegP       Op_RegF       Op_RegD       Op_RegL
 4205     static int typeToRegLo[Op_RegL+1] = { 0,   0,     R3_num,   R3_num,   R3_num,   F1_num,   F1_num,   R3_num };
 4206     static int typeToRegHi[Op_RegL+1] = { 0,   0,     OptoReg::Bad, R3_H_num, R3_H_num, OptoReg::Bad, F1_H_num, R3_H_num };
 4207     return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
 4208   %}
 4209 
 4210   // Location of compiled Java return values.  Same as C
 4211   return_value %{
 4212     assert((ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL) ||
 4213             (ideal_reg == Op_RegN &amp;&amp; CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0),
 4214             &quot;only return normal values&quot;);
 4215     // enum names from opcodes.hpp:    Op_Node Op_Set Op_RegN       Op_RegI       Op_RegP       Op_RegF       Op_RegD       Op_RegL
 4216     static int typeToRegLo[Op_RegL+1] = { 0,   0,     R3_num,   R3_num,   R3_num,   F1_num,   F1_num,   R3_num };
 4217     static int typeToRegHi[Op_RegL+1] = { 0,   0,     OptoReg::Bad, R3_H_num, R3_H_num, OptoReg::Bad, F1_H_num, R3_H_num };
 4218     return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
 4219   %}
 4220 %}
 4221 
 4222 
 4223 //----------ATTRIBUTES---------------------------------------------------------
 4224 
 4225 //----------Operand Attributes-------------------------------------------------
 4226 op_attrib op_cost(1);          // Required cost attribute.
 4227 
 4228 //----------Instruction Attributes---------------------------------------------
 4229 
 4230 // Cost attribute. required.
 4231 ins_attrib ins_cost(DEFAULT_COST);
 4232 
 4233 // Is this instruction a non-matching short branch variant of some
 4234 // long branch? Not required.
 4235 ins_attrib ins_short_branch(0);
 4236 
 4237 ins_attrib ins_is_TrapBasedCheckNode(true);
 4238 
 4239 // Number of constants.
 4240 // This instruction uses the given number of constants
 4241 // (optional attribute).
 4242 // This is needed to determine in time whether the constant pool will
 4243 // exceed 4000 entries. Before postalloc_expand the overall number of constants
 4244 // is determined. It&#39;s also used to compute the constant pool size
 4245 // in Output().
 4246 ins_attrib ins_num_consts(0);
 4247 
 4248 // Required alignment attribute (must be a power of 2) specifies the
 4249 // alignment that some part of the instruction (not necessarily the
 4250 // start) requires. If &gt; 1, a compute_padding() function must be
 4251 // provided for the instruction.
 4252 ins_attrib ins_alignment(1);
 4253 
 4254 // Enforce/prohibit rematerializations.
 4255 // - If an instruction is attributed with &#39;ins_cannot_rematerialize(true)&#39;
 4256 //   then rematerialization of that instruction is prohibited and the
 4257 //   instruction&#39;s value will be spilled if necessary.
 4258 //   Causes that MachNode::rematerialize() returns false.
 4259 // - If an instruction is attributed with &#39;ins_should_rematerialize(true)&#39;
 4260 //   then rematerialization should be enforced and a copy of the instruction
 4261 //   should be inserted if possible; rematerialization is not guaranteed.
 4262 //   Note: this may result in rematerializations in front of every use.
 4263 //   Causes that MachNode::rematerialize() can return true.
 4264 // (optional attribute)
 4265 ins_attrib ins_cannot_rematerialize(false);
 4266 ins_attrib ins_should_rematerialize(false);
 4267 
 4268 // Instruction has variable size depending on alignment.
 4269 ins_attrib ins_variable_size_depending_on_alignment(false);
 4270 
 4271 // Instruction is a nop.
 4272 ins_attrib ins_is_nop(false);
 4273 
 4274 // Instruction is mapped to a MachIfFastLock node (instead of MachFastLock).
 4275 ins_attrib ins_use_mach_if_fast_lock_node(false);
 4276 
 4277 // Field for the toc offset of a constant.
 4278 //
 4279 // This is needed if the toc offset is not encodable as an immediate in
 4280 // the PPC load instruction. If so, the upper (hi) bits of the offset are
 4281 // added to the toc, and from this a load with immediate is performed.
 4282 // With postalloc expand, we get two nodes that require the same offset
 4283 // but which don&#39;t know about each other. The offset is only known
 4284 // when the constant is added to the constant pool during emitting.
 4285 // It is generated in the &#39;hi&#39;-node adding the upper bits, and saved
 4286 // in this node.  The &#39;lo&#39;-node has a link to the &#39;hi&#39;-node and reads
 4287 // the offset from there when it gets encoded.
 4288 ins_attrib ins_field_const_toc_offset(0);
 4289 ins_attrib ins_field_const_toc_offset_hi_node(0);
 4290 
 4291 // A field that can hold the instructions offset in the code buffer.
 4292 // Set in the nodes emitter.
 4293 ins_attrib ins_field_cbuf_insts_offset(-1);
 4294 
 4295 // Fields for referencing a call&#39;s load-IC-node.
 4296 // If the toc offset can not be encoded as an immediate in a load, we
 4297 // use two nodes.
 4298 ins_attrib ins_field_load_ic_hi_node(0);
 4299 ins_attrib ins_field_load_ic_node(0);
 4300 
 4301 //----------OPERANDS-----------------------------------------------------------
 4302 // Operand definitions must precede instruction definitions for correct
 4303 // parsing in the ADLC because operands constitute user defined types
 4304 // which are used in instruction definitions.
 4305 //
 4306 // Formats are generated automatically for constants and base registers.
 4307 
 4308 operand vecX() %{
 4309   constraint(ALLOC_IN_RC(vs_reg));
 4310   match(VecX);
 4311 
 4312   format %{ %}
 4313   interface(REG_INTER);
 4314 %}
 4315 
 4316 //----------Simple Operands----------------------------------------------------
 4317 // Immediate Operands
 4318 
 4319 // Integer Immediate: 32-bit
 4320 operand immI() %{
 4321   match(ConI);
 4322   op_cost(40);
 4323   format %{ %}
 4324   interface(CONST_INTER);
 4325 %}
 4326 
 4327 operand immI8() %{
 4328   predicate(Assembler::is_simm(n-&gt;get_int(), 8));
 4329   op_cost(0);
 4330   match(ConI);
 4331   format %{ %}
 4332   interface(CONST_INTER);
 4333 %}
 4334 
 4335 // Integer Immediate: 16-bit
 4336 operand immI16() %{
 4337   predicate(Assembler::is_simm(n-&gt;get_int(), 16));
 4338   op_cost(0);
 4339   match(ConI);
 4340   format %{ %}
 4341   interface(CONST_INTER);
 4342 %}
 4343 
 4344 // Integer Immediate: 32-bit, where lowest 16 bits are 0x0000.
 4345 operand immIhi16() %{
 4346   predicate(((n-&gt;get_int() &amp; 0xffff0000) != 0) &amp;&amp; ((n-&gt;get_int() &amp; 0xffff) == 0));
 4347   match(ConI);
 4348   op_cost(0);
 4349   format %{ %}
 4350   interface(CONST_INTER);
 4351 %}
 4352 
 4353 operand immInegpow2() %{
 4354   predicate(is_power_of_2_long((jlong) (julong) (juint) (-(n-&gt;get_int()))));
 4355   match(ConI);
 4356   op_cost(0);
 4357   format %{ %}
 4358   interface(CONST_INTER);
 4359 %}
 4360 
 4361 operand immIpow2minus1() %{
 4362   predicate(is_power_of_2_long((((jlong) (n-&gt;get_int()))+1)));
 4363   match(ConI);
 4364   op_cost(0);
 4365   format %{ %}
 4366   interface(CONST_INTER);
 4367 %}
 4368 
 4369 operand immIpowerOf2() %{
 4370   predicate(is_power_of_2_long((((jlong) (julong) (juint) (n-&gt;get_int())))));
 4371   match(ConI);
 4372   op_cost(0);
 4373   format %{ %}
 4374   interface(CONST_INTER);
 4375 %}
 4376 
 4377 // Unsigned Integer Immediate: the values 0-31
 4378 operand uimmI5() %{
 4379   predicate(Assembler::is_uimm(n-&gt;get_int(), 5));
 4380   match(ConI);
 4381   op_cost(0);
 4382   format %{ %}
 4383   interface(CONST_INTER);
 4384 %}
 4385 
 4386 // Unsigned Integer Immediate: 6-bit
 4387 operand uimmI6() %{
 4388   predicate(Assembler::is_uimm(n-&gt;get_int(), 6));
 4389   match(ConI);
 4390   op_cost(0);
 4391   format %{ %}
 4392   interface(CONST_INTER);
 4393 %}
 4394 
 4395 // Unsigned Integer Immediate:  6-bit int, greater than 32
 4396 operand uimmI6_ge32() %{
 4397   predicate(Assembler::is_uimm(n-&gt;get_int(), 6) &amp;&amp; n-&gt;get_int() &gt;= 32);
 4398   match(ConI);
 4399   op_cost(0);
 4400   format %{ %}
 4401   interface(CONST_INTER);
 4402 %}
 4403 
 4404 // Unsigned Integer Immediate: 15-bit
 4405 operand uimmI15() %{
 4406   predicate(Assembler::is_uimm(n-&gt;get_int(), 15));
 4407   match(ConI);
 4408   op_cost(0);
 4409   format %{ %}
 4410   interface(CONST_INTER);
 4411 %}
 4412 
 4413 // Unsigned Integer Immediate: 16-bit
 4414 operand uimmI16() %{
 4415   predicate(Assembler::is_uimm(n-&gt;get_int(), 16));
 4416   match(ConI);
 4417   op_cost(0);
 4418   format %{ %}
 4419   interface(CONST_INTER);
 4420 %}
 4421 
 4422 // constant &#39;int 0&#39;.
 4423 operand immI_0() %{
 4424   predicate(n-&gt;get_int() == 0);
 4425   match(ConI);
 4426   op_cost(0);
 4427   format %{ %}
 4428   interface(CONST_INTER);
 4429 %}
 4430 
 4431 // constant &#39;int 1&#39;.
 4432 operand immI_1() %{
 4433   predicate(n-&gt;get_int() == 1);
 4434   match(ConI);
 4435   op_cost(0);
 4436   format %{ %}
 4437   interface(CONST_INTER);
 4438 %}
 4439 
 4440 // constant &#39;int -1&#39;.
 4441 operand immI_minus1() %{
 4442   predicate(n-&gt;get_int() == -1);
 4443   match(ConI);
 4444   op_cost(0);
 4445   format %{ %}
 4446   interface(CONST_INTER);
 4447 %}
 4448 
 4449 // int value 16.
 4450 operand immI_16() %{
 4451   predicate(n-&gt;get_int() == 16);
 4452   match(ConI);
 4453   op_cost(0);
 4454   format %{ %}
 4455   interface(CONST_INTER);
 4456 %}
 4457 
 4458 // int value 24.
 4459 operand immI_24() %{
 4460   predicate(n-&gt;get_int() == 24);
 4461   match(ConI);
 4462   op_cost(0);
 4463   format %{ %}
 4464   interface(CONST_INTER);
 4465 %}
 4466 
 4467 // Compressed oops constants
 4468 // Pointer Immediate
 4469 operand immN() %{
 4470   match(ConN);
 4471 
 4472   op_cost(10);
 4473   format %{ %}
 4474   interface(CONST_INTER);
 4475 %}
 4476 
 4477 // NULL Pointer Immediate
 4478 operand immN_0() %{
 4479   predicate(n-&gt;get_narrowcon() == 0);
 4480   match(ConN);
 4481 
 4482   op_cost(0);
 4483   format %{ %}
 4484   interface(CONST_INTER);
 4485 %}
 4486 
 4487 // Compressed klass constants
 4488 operand immNKlass() %{
 4489   match(ConNKlass);
 4490 
 4491   op_cost(0);
 4492   format %{ %}
 4493   interface(CONST_INTER);
 4494 %}
 4495 
 4496 // This operand can be used to avoid matching of an instruct
 4497 // with chain rule.
 4498 operand immNKlass_NM() %{
 4499   match(ConNKlass);
 4500   predicate(false);
 4501   op_cost(0);
 4502   format %{ %}
 4503   interface(CONST_INTER);
 4504 %}
 4505 
 4506 // Pointer Immediate: 64-bit
 4507 operand immP() %{
 4508   match(ConP);
 4509   op_cost(0);
 4510   format %{ %}
 4511   interface(CONST_INTER);
 4512 %}
 4513 
 4514 // Operand to avoid match of loadConP.
 4515 // This operand can be used to avoid matching of an instruct
 4516 // with chain rule.
 4517 operand immP_NM() %{
 4518   match(ConP);
 4519   predicate(false);
 4520   op_cost(0);
 4521   format %{ %}
 4522   interface(CONST_INTER);
 4523 %}
 4524 
 4525 // costant &#39;pointer 0&#39;.
 4526 operand immP_0() %{
 4527   predicate(n-&gt;get_ptr() == 0);
 4528   match(ConP);
 4529   op_cost(0);
 4530   format %{ %}
 4531   interface(CONST_INTER);
 4532 %}
 4533 
 4534 // pointer 0x0 or 0x1
 4535 operand immP_0or1() %{
 4536   predicate((n-&gt;get_ptr() == 0) || (n-&gt;get_ptr() == 1));
 4537   match(ConP);
 4538   op_cost(0);
 4539   format %{ %}
 4540   interface(CONST_INTER);
 4541 %}
 4542 
 4543 operand immL() %{
 4544   match(ConL);
 4545   op_cost(40);
 4546   format %{ %}
 4547   interface(CONST_INTER);
 4548 %}
 4549 
 4550 operand immLmax30() %{
 4551   predicate((n-&gt;get_long() &lt;= 30));
 4552   match(ConL);
 4553   op_cost(0);
 4554   format %{ %}
 4555   interface(CONST_INTER);
 4556 %}
 4557 
 4558 // Long Immediate: 16-bit
 4559 operand immL16() %{
 4560   predicate(Assembler::is_simm(n-&gt;get_long(), 16));
 4561   match(ConL);
 4562   op_cost(0);
 4563   format %{ %}
 4564   interface(CONST_INTER);
 4565 %}
 4566 
 4567 // Long Immediate: 16-bit, 4-aligned
 4568 operand immL16Alg4() %{
 4569   predicate(Assembler::is_simm(n-&gt;get_long(), 16) &amp;&amp; ((n-&gt;get_long() &amp; 0x3) == 0));
 4570   match(ConL);
 4571   op_cost(0);
 4572   format %{ %}
 4573   interface(CONST_INTER);
 4574 %}
 4575 
 4576 // Long Immediate: 32-bit, where lowest 16 bits are 0x0000.
 4577 operand immL32hi16() %{
 4578   predicate(Assembler::is_simm(n-&gt;get_long(), 32) &amp;&amp; ((n-&gt;get_long() &amp; 0xffffL) == 0L));
 4579   match(ConL);
 4580   op_cost(0);
 4581   format %{ %}
 4582   interface(CONST_INTER);
 4583 %}
 4584 
 4585 // Long Immediate: 32-bit
 4586 operand immL32() %{
 4587   predicate(Assembler::is_simm(n-&gt;get_long(), 32));
 4588   match(ConL);
 4589   op_cost(0);
 4590   format %{ %}
 4591   interface(CONST_INTER);
 4592 %}
 4593 
 4594 // Long Immediate: 64-bit, where highest 16 bits are not 0x0000.
 4595 operand immLhighest16() %{
 4596   predicate((n-&gt;get_long() &amp; 0xffff000000000000L) != 0L &amp;&amp; (n-&gt;get_long() &amp; 0x0000ffffffffffffL) == 0L);
 4597   match(ConL);
 4598   op_cost(0);
 4599   format %{ %}
 4600   interface(CONST_INTER);
 4601 %}
 4602 
 4603 operand immLnegpow2() %{
 4604   predicate(is_power_of_2_long((jlong)-(n-&gt;get_long())));
 4605   match(ConL);
 4606   op_cost(0);
 4607   format %{ %}
 4608   interface(CONST_INTER);
 4609 %}
 4610 
 4611 operand immLpow2minus1() %{
 4612   predicate(is_power_of_2_long((((jlong) (n-&gt;get_long()))+1)) &amp;&amp;
 4613             (n-&gt;get_long() != (jlong)0xffffffffffffffffL));
 4614   match(ConL);
 4615   op_cost(0);
 4616   format %{ %}
 4617   interface(CONST_INTER);
 4618 %}
 4619 
 4620 // constant &#39;long 0&#39;.
 4621 operand immL_0() %{
 4622   predicate(n-&gt;get_long() == 0L);
 4623   match(ConL);
 4624   op_cost(0);
 4625   format %{ %}
 4626   interface(CONST_INTER);
 4627 %}
 4628 
 4629 // constat &#39; long -1&#39;.
 4630 operand immL_minus1() %{
 4631   predicate(n-&gt;get_long() == -1L);
 4632   match(ConL);
 4633   op_cost(0);
 4634   format %{ %}
 4635   interface(CONST_INTER);
 4636 %}
 4637 
 4638 // Long Immediate: low 32-bit mask
 4639 operand immL_32bits() %{
 4640   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 4641   match(ConL);
 4642   op_cost(0);
 4643   format %{ %}
 4644   interface(CONST_INTER);
 4645 %}
 4646 
 4647 // Unsigned Long Immediate: 16-bit
 4648 operand uimmL16() %{
 4649   predicate(Assembler::is_uimm(n-&gt;get_long(), 16));
 4650   match(ConL);
 4651   op_cost(0);
 4652   format %{ %}
 4653   interface(CONST_INTER);
 4654 %}
 4655 
 4656 // Float Immediate
 4657 operand immF() %{
 4658   match(ConF);
 4659   op_cost(40);
 4660   format %{ %}
 4661   interface(CONST_INTER);
 4662 %}
 4663 
 4664 // Float Immediate: +0.0f.
 4665 operand immF_0() %{
 4666   predicate(jint_cast(n-&gt;getf()) == 0);
 4667   match(ConF);
 4668 
 4669   op_cost(0);
 4670   format %{ %}
 4671   interface(CONST_INTER);
 4672 %}
 4673 
 4674 // Double Immediate
 4675 operand immD() %{
 4676   match(ConD);
 4677   op_cost(40);
 4678   format %{ %}
 4679   interface(CONST_INTER);
 4680 %}
 4681 
 4682 // Double Immediate: +0.0d.
 4683 operand immD_0() %{
 4684   predicate(jlong_cast(n-&gt;getd()) == 0);
 4685   match(ConD);
 4686 
 4687   op_cost(0);
 4688   format %{ %}
 4689   interface(CONST_INTER);
 4690 %}
 4691 
 4692 // Integer Register Operands
 4693 // Integer Destination Register
 4694 // See definition of reg_class bits32_reg_rw.
 4695 operand iRegIdst() %{
 4696   constraint(ALLOC_IN_RC(bits32_reg_rw));
 4697   match(RegI);
 4698   match(rscratch1RegI);
 4699   match(rscratch2RegI);
 4700   match(rarg1RegI);
 4701   match(rarg2RegI);
 4702   match(rarg3RegI);
 4703   match(rarg4RegI);
 4704   format %{ %}
 4705   interface(REG_INTER);
 4706 %}
 4707 
 4708 // Integer Source Register
 4709 // See definition of reg_class bits32_reg_ro.
 4710 operand iRegIsrc() %{
 4711   constraint(ALLOC_IN_RC(bits32_reg_ro));
 4712   match(RegI);
 4713   match(rscratch1RegI);
 4714   match(rscratch2RegI);
 4715   match(rarg1RegI);
 4716   match(rarg2RegI);
 4717   match(rarg3RegI);
 4718   match(rarg4RegI);
 4719   format %{ %}
 4720   interface(REG_INTER);
 4721 %}
 4722 
 4723 operand rscratch1RegI() %{
 4724   constraint(ALLOC_IN_RC(rscratch1_bits32_reg));
 4725   match(iRegIdst);
 4726   format %{ %}
 4727   interface(REG_INTER);
 4728 %}
 4729 
 4730 operand rscratch2RegI() %{
 4731   constraint(ALLOC_IN_RC(rscratch2_bits32_reg));
 4732   match(iRegIdst);
 4733   format %{ %}
 4734   interface(REG_INTER);
 4735 %}
 4736 
 4737 operand rarg1RegI() %{
 4738   constraint(ALLOC_IN_RC(rarg1_bits32_reg));
 4739   match(iRegIdst);
 4740   format %{ %}
 4741   interface(REG_INTER);
 4742 %}
 4743 
 4744 operand rarg2RegI() %{
 4745   constraint(ALLOC_IN_RC(rarg2_bits32_reg));
 4746   match(iRegIdst);
 4747   format %{ %}
 4748   interface(REG_INTER);
 4749 %}
 4750 
 4751 operand rarg3RegI() %{
 4752   constraint(ALLOC_IN_RC(rarg3_bits32_reg));
 4753   match(iRegIdst);
 4754   format %{ %}
 4755   interface(REG_INTER);
 4756 %}
 4757 
 4758 operand rarg4RegI() %{
 4759   constraint(ALLOC_IN_RC(rarg4_bits32_reg));
 4760   match(iRegIdst);
 4761   format %{ %}
 4762   interface(REG_INTER);
 4763 %}
 4764 
 4765 operand rarg1RegL() %{
 4766   constraint(ALLOC_IN_RC(rarg1_bits64_reg));
 4767   match(iRegLdst);
 4768   format %{ %}
 4769   interface(REG_INTER);
 4770 %}
 4771 
 4772 operand rarg2RegL() %{
 4773   constraint(ALLOC_IN_RC(rarg2_bits64_reg));
 4774   match(iRegLdst);
 4775   format %{ %}
 4776   interface(REG_INTER);
 4777 %}
 4778 
 4779 operand rarg3RegL() %{
 4780   constraint(ALLOC_IN_RC(rarg3_bits64_reg));
 4781   match(iRegLdst);
 4782   format %{ %}
 4783   interface(REG_INTER);
 4784 %}
 4785 
 4786 operand rarg4RegL() %{
 4787   constraint(ALLOC_IN_RC(rarg4_bits64_reg));
 4788   match(iRegLdst);
 4789   format %{ %}
 4790   interface(REG_INTER);
 4791 %}
 4792 
 4793 // Pointer Destination Register
 4794 // See definition of reg_class bits64_reg_rw.
 4795 operand iRegPdst() %{
 4796   constraint(ALLOC_IN_RC(bits64_reg_rw));
 4797   match(RegP);
 4798   match(rscratch1RegP);
 4799   match(rscratch2RegP);
 4800   match(rarg1RegP);
 4801   match(rarg2RegP);
 4802   match(rarg3RegP);
 4803   match(rarg4RegP);
 4804   format %{ %}
 4805   interface(REG_INTER);
 4806 %}
 4807 
 4808 // Pointer Destination Register
 4809 // Operand not using r11 and r12 (killed in epilog).
 4810 operand iRegPdstNoScratch() %{
 4811   constraint(ALLOC_IN_RC(bits64_reg_leaf_call));
 4812   match(RegP);
 4813   match(rarg1RegP);
 4814   match(rarg2RegP);
 4815   match(rarg3RegP);
 4816   match(rarg4RegP);
 4817   format %{ %}
 4818   interface(REG_INTER);
 4819 %}
 4820 
 4821 // Pointer Source Register
 4822 // See definition of reg_class bits64_reg_ro.
 4823 operand iRegPsrc() %{
 4824   constraint(ALLOC_IN_RC(bits64_reg_ro));
 4825   match(RegP);
 4826   match(iRegPdst);
 4827   match(rscratch1RegP);
 4828   match(rscratch2RegP);
 4829   match(rarg1RegP);
 4830   match(rarg2RegP);
 4831   match(rarg3RegP);
 4832   match(rarg4RegP);
 4833   match(threadRegP);
 4834   format %{ %}
 4835   interface(REG_INTER);
 4836 %}
 4837 
 4838 // Thread operand.
 4839 operand threadRegP() %{
 4840   constraint(ALLOC_IN_RC(thread_bits64_reg));
 4841   match(iRegPdst);
 4842   format %{ &quot;R16&quot; %}
 4843   interface(REG_INTER);
 4844 %}
 4845 
 4846 operand rscratch1RegP() %{
 4847   constraint(ALLOC_IN_RC(rscratch1_bits64_reg));
 4848   match(iRegPdst);
 4849   format %{ &quot;R11&quot; %}
 4850   interface(REG_INTER);
 4851 %}
 4852 
 4853 operand rscratch2RegP() %{
 4854   constraint(ALLOC_IN_RC(rscratch2_bits64_reg));
 4855   match(iRegPdst);
 4856   format %{ %}
 4857   interface(REG_INTER);
 4858 %}
 4859 
 4860 operand rarg1RegP() %{
 4861   constraint(ALLOC_IN_RC(rarg1_bits64_reg));
 4862   match(iRegPdst);
 4863   format %{ %}
 4864   interface(REG_INTER);
 4865 %}
 4866 
 4867 operand rarg2RegP() %{
 4868   constraint(ALLOC_IN_RC(rarg2_bits64_reg));
 4869   match(iRegPdst);
 4870   format %{ %}
 4871   interface(REG_INTER);
 4872 %}
 4873 
 4874 operand rarg3RegP() %{
 4875   constraint(ALLOC_IN_RC(rarg3_bits64_reg));
 4876   match(iRegPdst);
 4877   format %{ %}
 4878   interface(REG_INTER);
 4879 %}
 4880 
 4881 operand rarg4RegP() %{
 4882   constraint(ALLOC_IN_RC(rarg4_bits64_reg));
 4883   match(iRegPdst);
 4884   format %{ %}
 4885   interface(REG_INTER);
 4886 %}
 4887 
 4888 operand iRegNsrc() %{
 4889   constraint(ALLOC_IN_RC(bits32_reg_ro));
 4890   match(RegN);
 4891   match(iRegNdst);
 4892 
 4893   format %{ %}
 4894   interface(REG_INTER);
 4895 %}
 4896 
 4897 operand iRegNdst() %{
 4898   constraint(ALLOC_IN_RC(bits32_reg_rw));
 4899   match(RegN);
 4900 
 4901   format %{ %}
 4902   interface(REG_INTER);
 4903 %}
 4904 
 4905 // Long Destination Register
 4906 // See definition of reg_class bits64_reg_rw.
 4907 operand iRegLdst() %{
 4908   constraint(ALLOC_IN_RC(bits64_reg_rw));
 4909   match(RegL);
 4910   match(rscratch1RegL);
 4911   match(rscratch2RegL);
 4912   format %{ %}
 4913   interface(REG_INTER);
 4914 %}
 4915 
 4916 // Long Source Register
 4917 // See definition of reg_class bits64_reg_ro.
 4918 operand iRegLsrc() %{
 4919   constraint(ALLOC_IN_RC(bits64_reg_ro));
 4920   match(RegL);
 4921   match(iRegLdst);
 4922   match(rscratch1RegL);
 4923   match(rscratch2RegL);
 4924   format %{ %}
 4925   interface(REG_INTER);
 4926 %}
 4927 
 4928 // Special operand for ConvL2I.
 4929 operand iRegL2Isrc(iRegLsrc reg) %{
 4930   constraint(ALLOC_IN_RC(bits64_reg_ro));
 4931   match(ConvL2I reg);
 4932   format %{ &quot;ConvL2I($reg)&quot; %}
 4933   interface(REG_INTER)
 4934 %}
 4935 
 4936 operand rscratch1RegL() %{
 4937   constraint(ALLOC_IN_RC(rscratch1_bits64_reg));
 4938   match(RegL);
 4939   format %{ %}
 4940   interface(REG_INTER);
 4941 %}
 4942 
 4943 operand rscratch2RegL() %{
 4944   constraint(ALLOC_IN_RC(rscratch2_bits64_reg));
 4945   match(RegL);
 4946   format %{ %}
 4947   interface(REG_INTER);
 4948 %}
 4949 
 4950 // Condition Code Flag Registers
 4951 operand flagsReg() %{
 4952   constraint(ALLOC_IN_RC(int_flags));
 4953   match(RegFlags);
 4954   format %{ %}
 4955   interface(REG_INTER);
 4956 %}
 4957 
 4958 operand flagsRegSrc() %{
 4959   constraint(ALLOC_IN_RC(int_flags_ro));
 4960   match(RegFlags);
 4961   match(flagsReg);
 4962   match(flagsRegCR0);
 4963   format %{ %}
 4964   interface(REG_INTER);
 4965 %}
 4966 
 4967 // Condition Code Flag Register CR0
 4968 operand flagsRegCR0() %{
 4969   constraint(ALLOC_IN_RC(int_flags_CR0));
 4970   match(RegFlags);
 4971   format %{ &quot;CR0&quot; %}
 4972   interface(REG_INTER);
 4973 %}
 4974 
 4975 operand flagsRegCR1() %{
 4976   constraint(ALLOC_IN_RC(int_flags_CR1));
 4977   match(RegFlags);
 4978   format %{ &quot;CR1&quot; %}
 4979   interface(REG_INTER);
 4980 %}
 4981 
 4982 operand flagsRegCR6() %{
 4983   constraint(ALLOC_IN_RC(int_flags_CR6));
 4984   match(RegFlags);
 4985   format %{ &quot;CR6&quot; %}
 4986   interface(REG_INTER);
 4987 %}
 4988 
 4989 operand regCTR() %{
 4990   constraint(ALLOC_IN_RC(ctr_reg));
 4991   // RegFlags should work. Introducing a RegSpecial type would cause a
 4992   // lot of changes.
 4993   match(RegFlags);
 4994   format %{&quot;SR_CTR&quot; %}
 4995   interface(REG_INTER);
 4996 %}
 4997 
 4998 operand regD() %{
 4999   constraint(ALLOC_IN_RC(dbl_reg));
 5000   match(RegD);
 5001   format %{ %}
 5002   interface(REG_INTER);
 5003 %}
 5004 
 5005 operand regF() %{
 5006   constraint(ALLOC_IN_RC(flt_reg));
 5007   match(RegF);
 5008   format %{ %}
 5009   interface(REG_INTER);
 5010 %}
 5011 
 5012 // Special Registers
 5013 
 5014 // Method Register
 5015 operand inline_cache_regP(iRegPdst reg) %{
 5016   constraint(ALLOC_IN_RC(r19_bits64_reg)); // inline_cache_reg
 5017   match(reg);
 5018   format %{ %}
 5019   interface(REG_INTER);
 5020 %}
 5021 
 5022 operand compiler_method_oop_regP(iRegPdst reg) %{
 5023   constraint(ALLOC_IN_RC(rscratch1_bits64_reg)); // compiler_method_oop_reg
 5024   match(reg);
 5025   format %{ %}
 5026   interface(REG_INTER);
 5027 %}
 5028 
 5029 operand interpreter_method_oop_regP(iRegPdst reg) %{
 5030   constraint(ALLOC_IN_RC(r19_bits64_reg)); // interpreter_method_oop_reg
 5031   match(reg);
 5032   format %{ %}
 5033   interface(REG_INTER);
 5034 %}
 5035 
 5036 // Operands to remove register moves in unscaled mode.
 5037 // Match read/write registers with an EncodeP node if neither shift nor add are required.
 5038 operand iRegP2N(iRegPsrc reg) %{
 5039   predicate(false /* TODO: PPC port MatchDecodeNodes*/&amp;&amp; CompressedOops::shift() == 0);
 5040   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5041   match(EncodeP reg);
 5042   format %{ &quot;$reg&quot; %}
 5043   interface(REG_INTER)
 5044 %}
 5045 
 5046 operand iRegN2P(iRegNsrc reg) %{
 5047   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
 5048   constraint(ALLOC_IN_RC(bits32_reg_ro));
 5049   match(DecodeN reg);
 5050   format %{ &quot;$reg&quot; %}
 5051   interface(REG_INTER)
 5052 %}
 5053 
 5054 operand iRegN2P_klass(iRegNsrc reg) %{
 5055   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0);
 5056   constraint(ALLOC_IN_RC(bits32_reg_ro));
 5057   match(DecodeNKlass reg);
 5058   format %{ &quot;$reg&quot; %}
 5059   interface(REG_INTER)
 5060 %}
 5061 
 5062 //----------Complex Operands---------------------------------------------------
 5063 // Indirect Memory Reference
 5064 operand indirect(iRegPsrc reg) %{
 5065   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5066   match(reg);
 5067   op_cost(100);
 5068   format %{ &quot;[$reg]&quot; %}
 5069   interface(MEMORY_INTER) %{
 5070     base($reg);
 5071     index(0x0);
 5072     scale(0x0);
 5073     disp(0x0);
 5074   %}
 5075 %}
 5076 
 5077 // Indirect with Offset
 5078 operand indOffset16(iRegPsrc reg, immL16 offset) %{
 5079   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5080   match(AddP reg offset);
 5081   op_cost(100);
 5082   format %{ &quot;[$reg + $offset]&quot; %}
 5083   interface(MEMORY_INTER) %{
 5084     base($reg);
 5085     index(0x0);
 5086     scale(0x0);
 5087     disp($offset);
 5088   %}
 5089 %}
 5090 
 5091 // Indirect with 4-aligned Offset
 5092 operand indOffset16Alg4(iRegPsrc reg, immL16Alg4 offset) %{
 5093   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5094   match(AddP reg offset);
 5095   op_cost(100);
 5096   format %{ &quot;[$reg + $offset]&quot; %}
 5097   interface(MEMORY_INTER) %{
 5098     base($reg);
 5099     index(0x0);
 5100     scale(0x0);
 5101     disp($offset);
 5102   %}
 5103 %}
 5104 
 5105 //----------Complex Operands for Compressed OOPs-------------------------------
 5106 // Compressed OOPs with narrow_oop_shift == 0.
 5107 
 5108 // Indirect Memory Reference, compressed OOP
 5109 operand indirectNarrow(iRegNsrc reg) %{
 5110   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
 5111   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5112   match(DecodeN reg);
 5113   op_cost(100);
 5114   format %{ &quot;[$reg]&quot; %}
 5115   interface(MEMORY_INTER) %{
 5116     base($reg);
 5117     index(0x0);
 5118     scale(0x0);
 5119     disp(0x0);
 5120   %}
 5121 %}
 5122 
 5123 operand indirectNarrow_klass(iRegNsrc reg) %{
 5124   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0);
 5125   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5126   match(DecodeNKlass reg);
 5127   op_cost(100);
 5128   format %{ &quot;[$reg]&quot; %}
 5129   interface(MEMORY_INTER) %{
 5130     base($reg);
 5131     index(0x0);
 5132     scale(0x0);
 5133     disp(0x0);
 5134   %}
 5135 %}
 5136 
 5137 // Indirect with Offset, compressed OOP
 5138 operand indOffset16Narrow(iRegNsrc reg, immL16 offset) %{
 5139   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
 5140   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5141   match(AddP (DecodeN reg) offset);
 5142   op_cost(100);
 5143   format %{ &quot;[$reg + $offset]&quot; %}
 5144   interface(MEMORY_INTER) %{
 5145     base($reg);
 5146     index(0x0);
 5147     scale(0x0);
 5148     disp($offset);
 5149   %}
 5150 %}
 5151 
 5152 operand indOffset16Narrow_klass(iRegNsrc reg, immL16 offset) %{
 5153   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0);
 5154   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5155   match(AddP (DecodeNKlass reg) offset);
 5156   op_cost(100);
 5157   format %{ &quot;[$reg + $offset]&quot; %}
 5158   interface(MEMORY_INTER) %{
 5159     base($reg);
 5160     index(0x0);
 5161     scale(0x0);
 5162     disp($offset);
 5163   %}
 5164 %}
 5165 
 5166 // Indirect with 4-aligned Offset, compressed OOP
 5167 operand indOffset16NarrowAlg4(iRegNsrc reg, immL16Alg4 offset) %{
 5168   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
 5169   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5170   match(AddP (DecodeN reg) offset);
 5171   op_cost(100);
 5172   format %{ &quot;[$reg + $offset]&quot; %}
 5173   interface(MEMORY_INTER) %{
 5174     base($reg);
 5175     index(0x0);
 5176     scale(0x0);
 5177     disp($offset);
 5178   %}
 5179 %}
 5180 
 5181 operand indOffset16NarrowAlg4_klass(iRegNsrc reg, immL16Alg4 offset) %{
 5182   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0);
 5183   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5184   match(AddP (DecodeNKlass reg) offset);
 5185   op_cost(100);
 5186   format %{ &quot;[$reg + $offset]&quot; %}
 5187   interface(MEMORY_INTER) %{
 5188     base($reg);
 5189     index(0x0);
 5190     scale(0x0);
 5191     disp($offset);
 5192   %}
 5193 %}
 5194 
 5195 //----------Special Memory Operands--------------------------------------------
 5196 // Stack Slot Operand
 5197 //
 5198 // This operand is used for loading and storing temporary values on
 5199 // the stack where a match requires a value to flow through memory.
 5200 operand stackSlotI(sRegI reg) %{
 5201   constraint(ALLOC_IN_RC(stack_slots));
 5202   op_cost(100);
 5203   //match(RegI);
 5204   format %{ &quot;[sp+$reg]&quot; %}
 5205   interface(MEMORY_INTER) %{
 5206     base(0x1);   // R1_SP
 5207     index(0x0);
 5208     scale(0x0);
 5209     disp($reg);  // Stack Offset
 5210   %}
 5211 %}
 5212 
 5213 operand stackSlotL(sRegL reg) %{
 5214   constraint(ALLOC_IN_RC(stack_slots));
 5215   op_cost(100);
 5216   //match(RegL);
 5217   format %{ &quot;[sp+$reg]&quot; %}
 5218   interface(MEMORY_INTER) %{
 5219     base(0x1);   // R1_SP
 5220     index(0x0);
 5221     scale(0x0);
 5222     disp($reg);  // Stack Offset
 5223   %}
 5224 %}
 5225 
 5226 operand stackSlotP(sRegP reg) %{
 5227   constraint(ALLOC_IN_RC(stack_slots));
 5228   op_cost(100);
 5229   //match(RegP);
 5230   format %{ &quot;[sp+$reg]&quot; %}
 5231   interface(MEMORY_INTER) %{
 5232     base(0x1);   // R1_SP
 5233     index(0x0);
 5234     scale(0x0);
 5235     disp($reg);  // Stack Offset
 5236   %}
 5237 %}
 5238 
 5239 operand stackSlotF(sRegF reg) %{
 5240   constraint(ALLOC_IN_RC(stack_slots));
 5241   op_cost(100);
 5242   //match(RegF);
 5243   format %{ &quot;[sp+$reg]&quot; %}
 5244   interface(MEMORY_INTER) %{
 5245     base(0x1);   // R1_SP
 5246     index(0x0);
 5247     scale(0x0);
 5248     disp($reg);  // Stack Offset
 5249   %}
 5250 %}
 5251 
 5252 operand stackSlotD(sRegD reg) %{
 5253   constraint(ALLOC_IN_RC(stack_slots));
 5254   op_cost(100);
 5255   //match(RegD);
 5256   format %{ &quot;[sp+$reg]&quot; %}
 5257   interface(MEMORY_INTER) %{
 5258     base(0x1);   // R1_SP
 5259     index(0x0);
 5260     scale(0x0);
 5261     disp($reg);  // Stack Offset
 5262   %}
 5263 %}
 5264 
 5265 // Operands for expressing Control Flow
 5266 // NOTE: Label is a predefined operand which should not be redefined in
 5267 //       the AD file. It is generically handled within the ADLC.
 5268 
 5269 //----------Conditional Branch Operands----------------------------------------
 5270 // Comparison Op
 5271 //
 5272 // This is the operation of the comparison, and is limited to the
 5273 // following set of codes: L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE
 5274 // (!=).
 5275 //
 5276 // Other attributes of the comparison, such as unsignedness, are specified
 5277 // by the comparison instruction that sets a condition code flags register.
 5278 // That result is represented by a flags operand whose subtype is appropriate
 5279 // to the unsignedness (etc.) of the comparison.
 5280 //
 5281 // Later, the instruction which matches both the Comparison Op (a Bool) and
 5282 // the flags (produced by the Cmp) specifies the coding of the comparison op
 5283 // by matching a specific subtype of Bool operand below.
 5284 
 5285 // When used for floating point comparisons: unordered same as less.
 5286 operand cmpOp() %{
 5287   match(Bool);
 5288   format %{ &quot;&quot; %}
 5289   interface(COND_INTER) %{
 5290                            // BO only encodes bit 4 of bcondCRbiIsX, as bits 1-3 are always &#39;100&#39;.
 5291                            //           BO          &amp;  BI
 5292     equal(0xA);            // 10 10:   bcondCRbiIs1 &amp; Condition::equal
 5293     not_equal(0x2);        // 00 10:   bcondCRbiIs0 &amp; Condition::equal
 5294     less(0x8);             // 10 00:   bcondCRbiIs1 &amp; Condition::less
 5295     greater_equal(0x0);    // 00 00:   bcondCRbiIs0 &amp; Condition::less
 5296     less_equal(0x1);       // 00 01:   bcondCRbiIs0 &amp; Condition::greater
 5297     greater(0x9);          // 10 01:   bcondCRbiIs1 &amp; Condition::greater
 5298     overflow(0xB);         // 10 11:   bcondCRbiIs1 &amp; Condition::summary_overflow
 5299     no_overflow(0x3);      // 00 11:   bcondCRbiIs0 &amp; Condition::summary_overflow
 5300   %}
 5301 %}
 5302 
 5303 //----------OPERAND CLASSES----------------------------------------------------
 5304 // Operand Classes are groups of operands that are used to simplify
 5305 // instruction definitions by not requiring the AD writer to specify
 5306 // seperate instructions for every form of operand when the
 5307 // instruction accepts multiple operand types with the same basic
 5308 // encoding and format. The classic case of this is memory operands.
 5309 // Indirect is not included since its use is limited to Compare &amp; Swap.
 5310 
 5311 opclass memory(indirect, indOffset16 /*, indIndex, tlsReference*/, indirectNarrow, indirectNarrow_klass, indOffset16Narrow, indOffset16Narrow_klass);
 5312 // Memory operand where offsets are 4-aligned. Required for ld, std.
 5313 opclass memoryAlg4(indirect, indOffset16Alg4, indirectNarrow, indOffset16NarrowAlg4, indOffset16NarrowAlg4_klass);
 5314 opclass indirectMemory(indirect, indirectNarrow);
 5315 
 5316 // Special opclass for I and ConvL2I.
 5317 opclass iRegIsrc_iRegL2Isrc(iRegIsrc, iRegL2Isrc);
 5318 
 5319 // Operand classes to match encode and decode. iRegN_P2N is only used
 5320 // for storeN. I have never seen an encode node elsewhere.
 5321 opclass iRegN_P2N(iRegNsrc, iRegP2N);
 5322 opclass iRegP_N2P(iRegPsrc, iRegN2P, iRegN2P_klass);
 5323 
 5324 //----------PIPELINE-----------------------------------------------------------
 5325 
 5326 pipeline %{
 5327 
 5328 // See J.M.Tendler et al. &quot;Power4 system microarchitecture&quot;, IBM
 5329 // J. Res. &amp; Dev., No. 1, Jan. 2002.
 5330 
 5331 //----------ATTRIBUTES---------------------------------------------------------
 5332 attributes %{
 5333 
 5334   // Power4 instructions are of fixed length.
 5335   fixed_size_instructions;
 5336 
 5337   // TODO: if `bundle&#39; means number of instructions fetched
 5338   // per cycle, this is 8. If `bundle&#39; means Power4 `group&#39;, that is
 5339   // max instructions issued per cycle, this is 5.
 5340   max_instructions_per_bundle = 8;
 5341 
 5342   // A Power4 instruction is 4 bytes long.
 5343   instruction_unit_size = 4;
 5344 
 5345   // The Power4 processor fetches 64 bytes...
 5346   instruction_fetch_unit_size = 64;
 5347 
 5348   // ...in one line
 5349   instruction_fetch_units = 1
 5350 
 5351   // Unused, list one so that array generated by adlc is not empty.
 5352   // Aix compiler chokes if _nop_count = 0.
 5353   nops(fxNop);
 5354 %}
 5355 
 5356 //----------RESOURCES----------------------------------------------------------
 5357 // Resources are the functional units available to the machine
 5358 resources(
 5359    PPC_BR,         // branch unit
 5360    PPC_CR,         // condition unit
 5361    PPC_FX1,        // integer arithmetic unit 1
 5362    PPC_FX2,        // integer arithmetic unit 2
 5363    PPC_LDST1,      // load/store unit 1
 5364    PPC_LDST2,      // load/store unit 2
 5365    PPC_FP1,        // float arithmetic unit 1
 5366    PPC_FP2,        // float arithmetic unit 2
 5367    PPC_LDST = PPC_LDST1 | PPC_LDST2,
 5368    PPC_FX = PPC_FX1 | PPC_FX2,
 5369    PPC_FP = PPC_FP1 | PPC_FP2
 5370  );
 5371 
 5372 //----------PIPELINE DESCRIPTION-----------------------------------------------
 5373 // Pipeline Description specifies the stages in the machine&#39;s pipeline
 5374 pipe_desc(
 5375    // Power4 longest pipeline path
 5376    PPC_IF,   // instruction fetch
 5377    PPC_IC,
 5378    //PPC_BP, // branch prediction
 5379    PPC_D0,   // decode
 5380    PPC_D1,   // decode
 5381    PPC_D2,   // decode
 5382    PPC_D3,   // decode
 5383    PPC_Xfer1,
 5384    PPC_GD,   // group definition
 5385    PPC_MP,   // map
 5386    PPC_ISS,  // issue
 5387    PPC_RF,   // resource fetch
 5388    PPC_EX1,  // execute (all units)
 5389    PPC_EX2,  // execute (FP, LDST)
 5390    PPC_EX3,  // execute (FP, LDST)
 5391    PPC_EX4,  // execute (FP)
 5392    PPC_EX5,  // execute (FP)
 5393    PPC_EX6,  // execute (FP)
 5394    PPC_WB,   // write back
 5395    PPC_Xfer2,
 5396    PPC_CP
 5397  );
 5398 
 5399 //----------PIPELINE CLASSES---------------------------------------------------
 5400 // Pipeline Classes describe the stages in which input and output are
 5401 // referenced by the hardware pipeline.
 5402 
 5403 // Simple pipeline classes.
 5404 
 5405 // Default pipeline class.
 5406 pipe_class pipe_class_default() %{
 5407   single_instruction;
 5408   fixed_latency(2);
 5409 %}
 5410 
 5411 // Pipeline class for empty instructions.
 5412 pipe_class pipe_class_empty() %{
 5413   single_instruction;
 5414   fixed_latency(0);
 5415 %}
 5416 
 5417 // Pipeline class for compares.
 5418 pipe_class pipe_class_compare() %{
 5419   single_instruction;
 5420   fixed_latency(16);
 5421 %}
 5422 
 5423 // Pipeline class for traps.
 5424 pipe_class pipe_class_trap() %{
 5425   single_instruction;
 5426   fixed_latency(100);
 5427 %}
 5428 
 5429 // Pipeline class for memory operations.
 5430 pipe_class pipe_class_memory() %{
 5431   single_instruction;
 5432   fixed_latency(16);
 5433 %}
 5434 
 5435 // Pipeline class for call.
 5436 pipe_class pipe_class_call() %{
 5437   single_instruction;
 5438   fixed_latency(100);
 5439 %}
 5440 
 5441 // Define the class for the Nop node.
 5442 define %{
 5443    MachNop = pipe_class_default;
 5444 %}
 5445 
 5446 %}
 5447 
 5448 //----------INSTRUCTIONS-------------------------------------------------------
 5449 
 5450 // Naming of instructions:
 5451 //   opA_operB / opA_operB_operC:
 5452 //     Operation &#39;op&#39; with one or two source operands &#39;oper&#39;. Result
 5453 //     type is A, source operand types are B and C.
 5454 //     Iff A == B == C, B and C are left out.
 5455 //
 5456 // The instructions are ordered according to the following scheme:
 5457 //  - loads
 5458 //  - load constants
 5459 //  - prefetch
 5460 //  - store
 5461 //  - encode/decode
 5462 //  - membar
 5463 //  - conditional moves
 5464 //  - compare &amp; swap
 5465 //  - arithmetic and logic operations
 5466 //    * int: Add, Sub, Mul, Div, Mod
 5467 //    * int: lShift, arShift, urShift, rot
 5468 //    * float: Add, Sub, Mul, Div
 5469 //    * and, or, xor ...
 5470 //  - register moves: float &lt;-&gt; int, reg &lt;-&gt; stack, repl
 5471 //  - cast (high level type cast, XtoP, castPP, castII, not_null etc.
 5472 //  - conv (low level type cast requiring bit changes (sign extend etc)
 5473 //  - compares, range &amp; zero checks.
 5474 //  - branches
 5475 //  - complex operations, intrinsics, min, max, replicate
 5476 //  - lock
 5477 //  - Calls
 5478 //
 5479 // If there are similar instructions with different types they are sorted:
 5480 // int before float
 5481 // small before big
 5482 // signed before unsigned
 5483 // e.g., loadS before loadUS before loadI before loadF.
 5484 
 5485 
 5486 //----------Load/Store Instructions--------------------------------------------
 5487 
 5488 //----------Load Instructions--------------------------------------------------
 5489 
 5490 // Converts byte to int.
 5491 // As convB2I_reg, but without match rule.  The match rule of convB2I_reg
 5492 // reuses the &#39;amount&#39; operand, but adlc expects that operand specification
 5493 // and operands in match rule are equivalent.
 5494 instruct convB2I_reg_2(iRegIdst dst, iRegIsrc src) %{
 5495   effect(DEF dst, USE src);
 5496   format %{ &quot;EXTSB   $dst, $src \t// byte-&gt;int&quot; %}
 5497   size(4);
 5498   ins_encode %{
 5499     // TODO: PPC port $archOpcode(ppc64Opcode_extsb);
 5500     __ extsb($dst$$Register, $src$$Register);
 5501   %}
 5502   ins_pipe(pipe_class_default);
 5503 %}
 5504 
 5505 instruct loadUB_indirect(iRegIdst dst, indirectMemory mem) %{
 5506   // match-rule, false predicate
 5507   match(Set dst (LoadB mem));
 5508   predicate(false);
 5509 
 5510   format %{ &quot;LBZ     $dst, $mem&quot; %}
 5511   size(4);
 5512   ins_encode( enc_lbz(dst, mem) );
 5513   ins_pipe(pipe_class_memory);
 5514 %}
 5515 
 5516 instruct loadUB_indirect_ac(iRegIdst dst, indirectMemory mem) %{
 5517   // match-rule, false predicate
 5518   match(Set dst (LoadB mem));
 5519   predicate(false);
 5520 
 5521   format %{ &quot;LBZ     $dst, $mem\n\t&quot;
 5522             &quot;TWI     $dst\n\t&quot;
 5523             &quot;ISYNC&quot; %}
 5524   size(12);
 5525   ins_encode( enc_lbz_ac(dst, mem) );
 5526   ins_pipe(pipe_class_memory);
 5527 %}
 5528 
 5529 // Load Byte (8bit signed). LoadB = LoadUB + ConvUB2B.
 5530 instruct loadB_indirect_Ex(iRegIdst dst, indirectMemory mem) %{
 5531   match(Set dst (LoadB mem));
 5532   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5533   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5534   expand %{
 5535     iRegIdst tmp;
 5536     loadUB_indirect(tmp, mem);
 5537     convB2I_reg_2(dst, tmp);
 5538   %}
 5539 %}
 5540 
 5541 instruct loadB_indirect_ac_Ex(iRegIdst dst, indirectMemory mem) %{
 5542   match(Set dst (LoadB mem));
 5543   ins_cost(3*MEMORY_REF_COST + DEFAULT_COST);
 5544   expand %{
 5545     iRegIdst tmp;
 5546     loadUB_indirect_ac(tmp, mem);
 5547     convB2I_reg_2(dst, tmp);
 5548   %}
 5549 %}
 5550 
 5551 instruct loadUB_indOffset16(iRegIdst dst, indOffset16 mem) %{
 5552   // match-rule, false predicate
 5553   match(Set dst (LoadB mem));
 5554   predicate(false);
 5555 
 5556   format %{ &quot;LBZ     $dst, $mem&quot; %}
 5557   size(4);
 5558   ins_encode( enc_lbz(dst, mem) );
 5559   ins_pipe(pipe_class_memory);
 5560 %}
 5561 
 5562 instruct loadUB_indOffset16_ac(iRegIdst dst, indOffset16 mem) %{
 5563   // match-rule, false predicate
 5564   match(Set dst (LoadB mem));
 5565   predicate(false);
 5566 
 5567   format %{ &quot;LBZ     $dst, $mem\n\t&quot;
 5568             &quot;TWI     $dst\n\t&quot;
 5569             &quot;ISYNC&quot; %}
 5570   size(12);
 5571   ins_encode( enc_lbz_ac(dst, mem) );
 5572   ins_pipe(pipe_class_memory);
 5573 %}
 5574 
 5575 // Load Byte (8bit signed). LoadB = LoadUB + ConvUB2B.
 5576 instruct loadB_indOffset16_Ex(iRegIdst dst, indOffset16 mem) %{
 5577   match(Set dst (LoadB mem));
 5578   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5579   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5580 
 5581   expand %{
 5582     iRegIdst tmp;
 5583     loadUB_indOffset16(tmp, mem);
 5584     convB2I_reg_2(dst, tmp);
 5585   %}
 5586 %}
 5587 
 5588 instruct loadB_indOffset16_ac_Ex(iRegIdst dst, indOffset16 mem) %{
 5589   match(Set dst (LoadB mem));
 5590   ins_cost(3*MEMORY_REF_COST + DEFAULT_COST);
 5591 
 5592   expand %{
 5593     iRegIdst tmp;
 5594     loadUB_indOffset16_ac(tmp, mem);
 5595     convB2I_reg_2(dst, tmp);
 5596   %}
 5597 %}
 5598 
 5599 // Load Unsigned Byte (8bit UNsigned) into an int reg.
 5600 instruct loadUB(iRegIdst dst, memory mem) %{
 5601   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5602   match(Set dst (LoadUB mem));
 5603   ins_cost(MEMORY_REF_COST);
 5604 
 5605   format %{ &quot;LBZ     $dst, $mem \t// byte, zero-extend to int&quot; %}
 5606   size(4);
 5607   ins_encode( enc_lbz(dst, mem) );
 5608   ins_pipe(pipe_class_memory);
 5609 %}
 5610 
 5611 // Load  Unsigned Byte (8bit UNsigned) acquire.
 5612 instruct loadUB_ac(iRegIdst dst, memory mem) %{
 5613   match(Set dst (LoadUB mem));
 5614   ins_cost(3*MEMORY_REF_COST);
 5615 
 5616   format %{ &quot;LBZ     $dst, $mem \t// byte, zero-extend to int, acquire\n\t&quot;
 5617             &quot;TWI     $dst\n\t&quot;
 5618             &quot;ISYNC&quot; %}
 5619   size(12);
 5620   ins_encode( enc_lbz_ac(dst, mem) );
 5621   ins_pipe(pipe_class_memory);
 5622 %}
 5623 
 5624 // Load Unsigned Byte (8bit UNsigned) into a Long Register.
 5625 instruct loadUB2L(iRegLdst dst, memory mem) %{
 5626   match(Set dst (ConvI2L (LoadUB mem)));
 5627   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(_kids[0]-&gt;_leaf));
 5628   ins_cost(MEMORY_REF_COST);
 5629 
 5630   format %{ &quot;LBZ     $dst, $mem \t// byte, zero-extend to long&quot; %}
 5631   size(4);
 5632   ins_encode( enc_lbz(dst, mem) );
 5633   ins_pipe(pipe_class_memory);
 5634 %}
 5635 
 5636 instruct loadUB2L_ac(iRegLdst dst, memory mem) %{
 5637   match(Set dst (ConvI2L (LoadUB mem)));
 5638   ins_cost(3*MEMORY_REF_COST);
 5639 
 5640   format %{ &quot;LBZ     $dst, $mem \t// byte, zero-extend to long, acquire\n\t&quot;
 5641             &quot;TWI     $dst\n\t&quot;
 5642             &quot;ISYNC&quot; %}
 5643   size(12);
 5644   ins_encode( enc_lbz_ac(dst, mem) );
 5645   ins_pipe(pipe_class_memory);
 5646 %}
 5647 
 5648 // Load Short (16bit signed)
 5649 instruct loadS(iRegIdst dst, memory mem) %{
 5650   match(Set dst (LoadS mem));
 5651   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5652   ins_cost(MEMORY_REF_COST);
 5653 
 5654   format %{ &quot;LHA     $dst, $mem&quot; %}
 5655   size(4);
 5656   ins_encode %{
 5657     // TODO: PPC port $archOpcode(ppc64Opcode_lha);
 5658     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 5659     __ lha($dst$$Register, Idisp, $mem$$base$$Register);
 5660   %}
 5661   ins_pipe(pipe_class_memory);
 5662 %}
 5663 
 5664 // Load Short (16bit signed) acquire.
 5665 instruct loadS_ac(iRegIdst dst, memory mem) %{
 5666   match(Set dst (LoadS mem));
 5667   ins_cost(3*MEMORY_REF_COST);
 5668 
 5669   format %{ &quot;LHA     $dst, $mem\t acquire\n\t&quot;
 5670             &quot;TWI     $dst\n\t&quot;
 5671             &quot;ISYNC&quot; %}
 5672   size(12);
 5673   ins_encode %{
 5674     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 5675     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 5676     __ lha($dst$$Register, Idisp, $mem$$base$$Register);
 5677     __ twi_0($dst$$Register);
 5678     __ isync();
 5679   %}
 5680   ins_pipe(pipe_class_memory);
 5681 %}
 5682 
 5683 // Load Char (16bit unsigned)
 5684 instruct loadUS(iRegIdst dst, memory mem) %{
 5685   match(Set dst (LoadUS mem));
 5686   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5687   ins_cost(MEMORY_REF_COST);
 5688 
 5689   format %{ &quot;LHZ     $dst, $mem&quot; %}
 5690   size(4);
 5691   ins_encode( enc_lhz(dst, mem) );
 5692   ins_pipe(pipe_class_memory);
 5693 %}
 5694 
 5695 // Load Char (16bit unsigned) acquire.
 5696 instruct loadUS_ac(iRegIdst dst, memory mem) %{
 5697   match(Set dst (LoadUS mem));
 5698   ins_cost(3*MEMORY_REF_COST);
 5699 
 5700   format %{ &quot;LHZ     $dst, $mem \t// acquire\n\t&quot;
 5701             &quot;TWI     $dst\n\t&quot;
 5702             &quot;ISYNC&quot; %}
 5703   size(12);
 5704   ins_encode( enc_lhz_ac(dst, mem) );
 5705   ins_pipe(pipe_class_memory);
 5706 %}
 5707 
 5708 // Load Unsigned Short/Char (16bit UNsigned) into a Long Register.
 5709 instruct loadUS2L(iRegLdst dst, memory mem) %{
 5710   match(Set dst (ConvI2L (LoadUS mem)));
 5711   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(_kids[0]-&gt;_leaf));
 5712   ins_cost(MEMORY_REF_COST);
 5713 
 5714   format %{ &quot;LHZ     $dst, $mem \t// short, zero-extend to long&quot; %}
 5715   size(4);
 5716   ins_encode( enc_lhz(dst, mem) );
 5717   ins_pipe(pipe_class_memory);
 5718 %}
 5719 
 5720 // Load Unsigned Short/Char (16bit UNsigned) into a Long Register acquire.
 5721 instruct loadUS2L_ac(iRegLdst dst, memory mem) %{
 5722   match(Set dst (ConvI2L (LoadUS mem)));
 5723   ins_cost(3*MEMORY_REF_COST);
 5724 
 5725   format %{ &quot;LHZ     $dst, $mem \t// short, zero-extend to long, acquire\n\t&quot;
 5726             &quot;TWI     $dst\n\t&quot;
 5727             &quot;ISYNC&quot; %}
 5728   size(12);
 5729   ins_encode( enc_lhz_ac(dst, mem) );
 5730   ins_pipe(pipe_class_memory);
 5731 %}
 5732 
 5733 // Load Integer.
 5734 instruct loadI(iRegIdst dst, memory mem) %{
 5735   match(Set dst (LoadI mem));
 5736   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5737   ins_cost(MEMORY_REF_COST);
 5738 
 5739   format %{ &quot;LWZ     $dst, $mem&quot; %}
 5740   size(4);
 5741   ins_encode( enc_lwz(dst, mem) );
 5742   ins_pipe(pipe_class_memory);
 5743 %}
 5744 
 5745 // Load Integer acquire.
 5746 instruct loadI_ac(iRegIdst dst, memory mem) %{
 5747   match(Set dst (LoadI mem));
 5748   ins_cost(3*MEMORY_REF_COST);
 5749 
 5750   format %{ &quot;LWZ     $dst, $mem \t// load acquire\n\t&quot;
 5751             &quot;TWI     $dst\n\t&quot;
 5752             &quot;ISYNC&quot; %}
 5753   size(12);
 5754   ins_encode( enc_lwz_ac(dst, mem) );
 5755   ins_pipe(pipe_class_memory);
 5756 %}
 5757 
 5758 // Match loading integer and casting it to unsigned int in
 5759 // long register.
 5760 // LoadI + ConvI2L + AndL 0xffffffff.
 5761 instruct loadUI2L(iRegLdst dst, memory mem, immL_32bits mask) %{
 5762   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 5763   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
 5764   ins_cost(MEMORY_REF_COST);
 5765 
 5766   format %{ &quot;LWZ     $dst, $mem \t// zero-extend to long&quot; %}
 5767   size(4);
 5768   ins_encode( enc_lwz(dst, mem) );
 5769   ins_pipe(pipe_class_memory);
 5770 %}
 5771 
 5772 // Match loading integer and casting it to long.
 5773 instruct loadI2L(iRegLdst dst, memoryAlg4 mem) %{
 5774   match(Set dst (ConvI2L (LoadI mem)));
 5775   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
 5776   ins_cost(MEMORY_REF_COST);
 5777 
 5778   format %{ &quot;LWA     $dst, $mem \t// loadI2L&quot; %}
 5779   size(4);
 5780   ins_encode %{
 5781     // TODO: PPC port $archOpcode(ppc64Opcode_lwa);
 5782     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 5783     __ lwa($dst$$Register, Idisp, $mem$$base$$Register);
 5784   %}
 5785   ins_pipe(pipe_class_memory);
 5786 %}
 5787 
 5788 // Match loading integer and casting it to long - acquire.
 5789 instruct loadI2L_ac(iRegLdst dst, memoryAlg4 mem) %{
 5790   match(Set dst (ConvI2L (LoadI mem)));
 5791   ins_cost(3*MEMORY_REF_COST);
 5792 
 5793   format %{ &quot;LWA     $dst, $mem \t// loadI2L acquire&quot;
 5794             &quot;TWI     $dst\n\t&quot;
 5795             &quot;ISYNC&quot; %}
 5796   size(12);
 5797   ins_encode %{
 5798     // TODO: PPC port $archOpcode(ppc64Opcode_lwa);
 5799     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 5800     __ lwa($dst$$Register, Idisp, $mem$$base$$Register);
 5801     __ twi_0($dst$$Register);
 5802     __ isync();
 5803   %}
 5804   ins_pipe(pipe_class_memory);
 5805 %}
 5806 
 5807 // Load Long - aligned
 5808 instruct loadL(iRegLdst dst, memoryAlg4 mem) %{
 5809   match(Set dst (LoadL mem));
 5810   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5811   ins_cost(MEMORY_REF_COST);
 5812 
 5813   format %{ &quot;LD      $dst, $mem \t// long&quot; %}
 5814   size(4);
 5815   ins_encode( enc_ld(dst, mem) );
 5816   ins_pipe(pipe_class_memory);
 5817 %}
 5818 
 5819 // Load Long - aligned acquire.
 5820 instruct loadL_ac(iRegLdst dst, memoryAlg4 mem) %{
 5821   match(Set dst (LoadL mem));
 5822   ins_cost(3*MEMORY_REF_COST);
 5823 
 5824   format %{ &quot;LD      $dst, $mem \t// long acquire\n\t&quot;
 5825             &quot;TWI     $dst\n\t&quot;
 5826             &quot;ISYNC&quot; %}
 5827   size(12);
 5828   ins_encode( enc_ld_ac(dst, mem) );
 5829   ins_pipe(pipe_class_memory);
 5830 %}
 5831 
 5832 // Load Long - UNaligned
 5833 instruct loadL_unaligned(iRegLdst dst, memoryAlg4 mem) %{
 5834   match(Set dst (LoadL_unaligned mem));
 5835   // predicate(...) // Unaligned_ac is not needed (and wouldn&#39;t make sense).
 5836   ins_cost(MEMORY_REF_COST);
 5837 
 5838   format %{ &quot;LD      $dst, $mem \t// unaligned long&quot; %}
 5839   size(4);
 5840   ins_encode( enc_ld(dst, mem) );
 5841   ins_pipe(pipe_class_memory);
 5842 %}
 5843 
 5844 // Load nodes for superwords
 5845 
 5846 // Load Aligned Packed Byte
 5847 instruct loadV8(iRegLdst dst, memoryAlg4 mem) %{
 5848   predicate(n-&gt;as_LoadVector()-&gt;memory_size() == 8);
 5849   match(Set dst (LoadVector mem));
 5850   ins_cost(MEMORY_REF_COST);
 5851 
 5852   format %{ &quot;LD      $dst, $mem \t// load 8-byte Vector&quot; %}
 5853   size(4);
 5854   ins_encode( enc_ld(dst, mem) );
 5855   ins_pipe(pipe_class_memory);
 5856 %}
 5857 
 5858 // Load Aligned Packed Byte
 5859 instruct loadV16(vecX dst, indirect mem) %{
 5860   predicate(n-&gt;as_LoadVector()-&gt;memory_size() == 16);
 5861   match(Set dst (LoadVector mem));
 5862   ins_cost(MEMORY_REF_COST);
 5863 
 5864   format %{ &quot;LXVD2X      $dst, $mem \t// load 16-byte Vector&quot; %}
 5865   size(4);
 5866   ins_encode %{
 5867     __ lxvd2x($dst$$VectorSRegister, $mem$$Register);
 5868   %}
 5869   ins_pipe(pipe_class_default);
 5870 %}
 5871 
 5872 // Load Range, range = array length (=jint)
 5873 instruct loadRange(iRegIdst dst, memory mem) %{
 5874   match(Set dst (LoadRange mem));
 5875   ins_cost(MEMORY_REF_COST);
 5876 
 5877   format %{ &quot;LWZ     $dst, $mem \t// range&quot; %}
 5878   size(4);
 5879   ins_encode( enc_lwz(dst, mem) );
 5880   ins_pipe(pipe_class_memory);
 5881 %}
 5882 
 5883 // Load Compressed Pointer
 5884 instruct loadN(iRegNdst dst, memory mem) %{
 5885   match(Set dst (LoadN mem));
 5886   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5887   ins_cost(MEMORY_REF_COST);
 5888 
 5889   format %{ &quot;LWZ     $dst, $mem \t// load compressed ptr&quot; %}
 5890   size(4);
 5891   ins_encode( enc_lwz(dst, mem) );
 5892   ins_pipe(pipe_class_memory);
 5893 %}
 5894 
 5895 // Load Compressed Pointer acquire.
 5896 instruct loadN_ac(iRegNdst dst, memory mem) %{
 5897   match(Set dst (LoadN mem));
 5898   ins_cost(3*MEMORY_REF_COST);
 5899 
 5900   format %{ &quot;LWZ     $dst, $mem \t// load acquire compressed ptr\n\t&quot;
 5901             &quot;TWI     $dst\n\t&quot;
 5902             &quot;ISYNC&quot; %}
 5903   size(12);
 5904   ins_encode( enc_lwz_ac(dst, mem) );
 5905   ins_pipe(pipe_class_memory);
 5906 %}
 5907 
 5908 // Load Compressed Pointer and decode it if narrow_oop_shift == 0.
 5909 instruct loadN2P_unscaled(iRegPdst dst, memory mem) %{
 5910   match(Set dst (DecodeN (LoadN mem)));
 5911   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered() &amp;&amp; CompressedOops::shift() == 0);
 5912   ins_cost(MEMORY_REF_COST);
 5913 
 5914   format %{ &quot;LWZ     $dst, $mem \t// DecodeN (unscaled)&quot; %}
 5915   size(4);
 5916   ins_encode( enc_lwz(dst, mem) );
 5917   ins_pipe(pipe_class_memory);
 5918 %}
 5919 
 5920 instruct loadN2P_klass_unscaled(iRegPdst dst, memory mem) %{
 5921   match(Set dst (DecodeNKlass (LoadNKlass mem)));
 5922   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0 &amp;&amp;
 5923             _kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
 5924   ins_cost(MEMORY_REF_COST);
 5925 
 5926   format %{ &quot;LWZ     $dst, $mem \t// DecodeN (unscaled)&quot; %}
 5927   size(4);
 5928   ins_encode( enc_lwz(dst, mem) );
 5929   ins_pipe(pipe_class_memory);
 5930 %}
 5931 
 5932 // Load Pointer
 5933 instruct loadP(iRegPdst dst, memoryAlg4 mem) %{
 5934   match(Set dst (LoadP mem));
 5935   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5936   ins_cost(MEMORY_REF_COST);
 5937 
 5938   format %{ &quot;LD      $dst, $mem \t// ptr&quot; %}
 5939   size(4);
 5940   ins_encode( enc_ld(dst, mem) );
 5941   ins_pipe(pipe_class_memory);
 5942 %}
 5943 
 5944 // Load Pointer acquire.
 5945 instruct loadP_ac(iRegPdst dst, memoryAlg4 mem) %{
 5946   match(Set dst (LoadP mem));
 5947   ins_cost(3*MEMORY_REF_COST);
 5948 
 5949   format %{ &quot;LD      $dst, $mem \t// ptr acquire\n\t&quot;
 5950             &quot;TWI     $dst\n\t&quot;
 5951             &quot;ISYNC&quot; %}
 5952   size(12);
 5953   ins_encode( enc_ld_ac(dst, mem) );
 5954   ins_pipe(pipe_class_memory);
 5955 %}
 5956 
 5957 // LoadP + CastP2L
 5958 instruct loadP2X(iRegLdst dst, memoryAlg4 mem) %{
 5959   match(Set dst (CastP2X (LoadP mem)));
 5960   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
 5961   ins_cost(MEMORY_REF_COST);
 5962 
 5963   format %{ &quot;LD      $dst, $mem \t// ptr + p2x&quot; %}
 5964   size(4);
 5965   ins_encode( enc_ld(dst, mem) );
 5966   ins_pipe(pipe_class_memory);
 5967 %}
 5968 
 5969 // Load compressed klass pointer.
 5970 instruct loadNKlass(iRegNdst dst, memory mem) %{
 5971   match(Set dst (LoadNKlass mem));
 5972   ins_cost(MEMORY_REF_COST);
 5973 
 5974   format %{ &quot;LWZ     $dst, $mem \t// compressed klass ptr&quot; %}
 5975   size(4);
 5976   ins_encode( enc_lwz(dst, mem) );
 5977   ins_pipe(pipe_class_memory);
 5978 %}
 5979 
 5980 // Load Klass Pointer
 5981 instruct loadKlass(iRegPdst dst, memoryAlg4 mem) %{
 5982   match(Set dst (LoadKlass mem));
 5983   ins_cost(MEMORY_REF_COST);
 5984 
 5985   format %{ &quot;LD      $dst, $mem \t// klass ptr&quot; %}
 5986   size(4);
 5987   ins_encode( enc_ld(dst, mem) );
 5988   ins_pipe(pipe_class_memory);
 5989 %}
 5990 
 5991 // Load Float
 5992 instruct loadF(regF dst, memory mem) %{
 5993   match(Set dst (LoadF mem));
 5994   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5995   ins_cost(MEMORY_REF_COST);
 5996 
 5997   format %{ &quot;LFS     $dst, $mem&quot; %}
 5998   size(4);
 5999   ins_encode %{
 6000     // TODO: PPC port $archOpcode(ppc64Opcode_lfs);
 6001     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 6002     __ lfs($dst$$FloatRegister, Idisp, $mem$$base$$Register);
 6003   %}
 6004   ins_pipe(pipe_class_memory);
 6005 %}
 6006 
 6007 // Load Float acquire.
 6008 instruct loadF_ac(regF dst, memory mem, flagsRegCR0 cr0) %{
 6009   match(Set dst (LoadF mem));
 6010   effect(TEMP cr0);
 6011   ins_cost(3*MEMORY_REF_COST);
 6012 
 6013   format %{ &quot;LFS     $dst, $mem \t// acquire\n\t&quot;
 6014             &quot;FCMPU   cr0, $dst, $dst\n\t&quot;
 6015             &quot;BNE     cr0, next\n&quot;
 6016             &quot;next:\n\t&quot;
 6017             &quot;ISYNC&quot; %}
 6018   size(16);
 6019   ins_encode %{
 6020     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6021     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 6022     Label next;
 6023     __ lfs($dst$$FloatRegister, Idisp, $mem$$base$$Register);
 6024     __ fcmpu(CCR0, $dst$$FloatRegister, $dst$$FloatRegister);
 6025     __ bne(CCR0, next);
 6026     __ bind(next);
 6027     __ isync();
 6028   %}
 6029   ins_pipe(pipe_class_memory);
 6030 %}
 6031 
 6032 // Load Double - aligned
 6033 instruct loadD(regD dst, memory mem) %{
 6034   match(Set dst (LoadD mem));
 6035   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 6036   ins_cost(MEMORY_REF_COST);
 6037 
 6038   format %{ &quot;LFD     $dst, $mem&quot; %}
 6039   size(4);
 6040   ins_encode( enc_lfd(dst, mem) );
 6041   ins_pipe(pipe_class_memory);
 6042 %}
 6043 
 6044 // Load Double - aligned acquire.
 6045 instruct loadD_ac(regD dst, memory mem, flagsRegCR0 cr0) %{
 6046   match(Set dst (LoadD mem));
 6047   effect(TEMP cr0);
 6048   ins_cost(3*MEMORY_REF_COST);
 6049 
 6050   format %{ &quot;LFD     $dst, $mem \t// acquire\n\t&quot;
 6051             &quot;FCMPU   cr0, $dst, $dst\n\t&quot;
 6052             &quot;BNE     cr0, next\n&quot;
 6053             &quot;next:\n\t&quot;
 6054             &quot;ISYNC&quot; %}
 6055   size(16);
 6056   ins_encode %{
 6057     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6058     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 6059     Label next;
 6060     __ lfd($dst$$FloatRegister, Idisp, $mem$$base$$Register);
 6061     __ fcmpu(CCR0, $dst$$FloatRegister, $dst$$FloatRegister);
 6062     __ bne(CCR0, next);
 6063     __ bind(next);
 6064     __ isync();
 6065   %}
 6066   ins_pipe(pipe_class_memory);
 6067 %}
 6068 
 6069 // Load Double - UNaligned
 6070 instruct loadD_unaligned(regD dst, memory mem) %{
 6071   match(Set dst (LoadD_unaligned mem));
 6072   // predicate(...) // Unaligned_ac is not needed (and wouldn&#39;t make sense).
 6073   ins_cost(MEMORY_REF_COST);
 6074 
 6075   format %{ &quot;LFD     $dst, $mem&quot; %}
 6076   size(4);
 6077   ins_encode( enc_lfd(dst, mem) );
 6078   ins_pipe(pipe_class_memory);
 6079 %}
 6080 
 6081 //----------Constants--------------------------------------------------------
 6082 
 6083 // Load MachConstantTableBase: add hi offset to global toc.
 6084 // TODO: Handle hidden register r29 in bundler!
 6085 instruct loadToc_hi(iRegLdst dst) %{
 6086   effect(DEF dst);
 6087   ins_cost(DEFAULT_COST);
 6088 
 6089   format %{ &quot;ADDIS   $dst, R29, DISP.hi \t// load TOC hi&quot; %}
 6090   size(4);
 6091   ins_encode %{
 6092     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 6093     __ calculate_address_from_global_toc_hi16only($dst$$Register, __ method_toc());
 6094   %}
 6095   ins_pipe(pipe_class_default);
 6096 %}
 6097 
 6098 // Load MachConstantTableBase: add lo offset to global toc.
 6099 instruct loadToc_lo(iRegLdst dst, iRegLdst src) %{
 6100   effect(DEF dst, USE src);
 6101   ins_cost(DEFAULT_COST);
 6102 
 6103   format %{ &quot;ADDI    $dst, $src, DISP.lo \t// load TOC lo&quot; %}
 6104   size(4);
 6105   ins_encode %{
 6106     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
 6107     __ calculate_address_from_global_toc_lo16only($dst$$Register, __ method_toc());
 6108   %}
 6109   ins_pipe(pipe_class_default);
 6110 %}
 6111 
 6112 // Load 16-bit integer constant 0xssss????
 6113 instruct loadConI16(iRegIdst dst, immI16 src) %{
 6114   match(Set dst src);
 6115 
 6116   format %{ &quot;LI      $dst, $src&quot; %}
 6117   size(4);
 6118   ins_encode %{
 6119     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 6120     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
 6121   %}
 6122   ins_pipe(pipe_class_default);
 6123 %}
 6124 
 6125 // Load integer constant 0x????0000
 6126 instruct loadConIhi16(iRegIdst dst, immIhi16 src) %{
 6127   match(Set dst src);
 6128   ins_cost(DEFAULT_COST);
 6129 
 6130   format %{ &quot;LIS     $dst, $src.hi&quot; %}
 6131   size(4);
 6132   ins_encode %{
 6133     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 6134     // Lis sign extends 16-bit src then shifts it 16 bit to the left.
 6135     __ lis($dst$$Register, (int)((short)(($src$$constant &amp; 0xFFFF0000) &gt;&gt; 16)));
 6136   %}
 6137   ins_pipe(pipe_class_default);
 6138 %}
 6139 
 6140 // Part 2 of loading 32 bit constant: hi16 is is src1 (properly shifted
 6141 // and sign extended), this adds the low 16 bits.
 6142 instruct loadConI32_lo16(iRegIdst dst, iRegIsrc src1, immI16 src2) %{
 6143   // no match-rule, false predicate
 6144   effect(DEF dst, USE src1, USE src2);
 6145   predicate(false);
 6146 
 6147   format %{ &quot;ORI     $dst, $src1.hi, $src2.lo&quot; %}
 6148   size(4);
 6149   ins_encode %{
 6150     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
 6151     __ ori($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0xFFFF);
 6152   %}
 6153   ins_pipe(pipe_class_default);
 6154 %}
 6155 
 6156 instruct loadConI_Ex(iRegIdst dst, immI src) %{
 6157   match(Set dst src);
 6158   ins_cost(DEFAULT_COST*2);
 6159 
 6160   expand %{
 6161     // Would like to use $src$$constant.
 6162     immI16 srcLo %{ _opnds[1]-&gt;constant() %}
 6163     // srcHi can be 0000 if srcLo sign-extends to a negative number.
 6164     immIhi16 srcHi %{ _opnds[1]-&gt;constant() %}
 6165     iRegIdst tmpI;
 6166     loadConIhi16(tmpI, srcHi);
 6167     loadConI32_lo16(dst, tmpI, srcLo);
 6168   %}
 6169 %}
 6170 
 6171 // No constant pool entries required.
 6172 instruct loadConL16(iRegLdst dst, immL16 src) %{
 6173   match(Set dst src);
 6174 
 6175   format %{ &quot;LI      $dst, $src \t// long&quot; %}
 6176   size(4);
 6177   ins_encode %{
 6178     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 6179     __ li($dst$$Register, (int)((short) ($src$$constant &amp; 0xFFFF)));
 6180   %}
 6181   ins_pipe(pipe_class_default);
 6182 %}
 6183 
 6184 // Load long constant 0xssssssss????0000
 6185 instruct loadConL32hi16(iRegLdst dst, immL32hi16 src) %{
 6186   match(Set dst src);
 6187   ins_cost(DEFAULT_COST);
 6188 
 6189   format %{ &quot;LIS     $dst, $src.hi \t// long&quot; %}
 6190   size(4);
 6191   ins_encode %{
 6192     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 6193     __ lis($dst$$Register, (int)((short)(($src$$constant &amp; 0xFFFF0000) &gt;&gt; 16)));
 6194   %}
 6195   ins_pipe(pipe_class_default);
 6196 %}
 6197 
 6198 // To load a 32 bit constant: merge lower 16 bits into already loaded
 6199 // high 16 bits.
 6200 instruct loadConL32_lo16(iRegLdst dst, iRegLsrc src1, immL16 src2) %{
 6201   // no match-rule, false predicate
 6202   effect(DEF dst, USE src1, USE src2);
 6203   predicate(false);
 6204 
 6205   format %{ &quot;ORI     $dst, $src1, $src2.lo&quot; %}
 6206   size(4);
 6207   ins_encode %{
 6208     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
 6209     __ ori($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0xFFFF);
 6210   %}
 6211   ins_pipe(pipe_class_default);
 6212 %}
 6213 
 6214 // Load 32-bit long constant
 6215 instruct loadConL32_Ex(iRegLdst dst, immL32 src) %{
 6216   match(Set dst src);
 6217   ins_cost(DEFAULT_COST*2);
 6218 
 6219   expand %{
 6220     // Would like to use $src$$constant.
 6221     immL16     srcLo %{ _opnds[1]-&gt;constant() /*&amp; 0x0000FFFFL */%}
 6222     // srcHi can be 0000 if srcLo sign-extends to a negative number.
 6223     immL32hi16 srcHi %{ _opnds[1]-&gt;constant() /*&amp; 0xFFFF0000L */%}
 6224     iRegLdst tmpL;
 6225     loadConL32hi16(tmpL, srcHi);
 6226     loadConL32_lo16(dst, tmpL, srcLo);
 6227   %}
 6228 %}
 6229 
 6230 // Load long constant 0x????000000000000.
 6231 instruct loadConLhighest16_Ex(iRegLdst dst, immLhighest16 src) %{
 6232   match(Set dst src);
 6233   ins_cost(DEFAULT_COST);
 6234 
 6235   expand %{
 6236     immL32hi16 srcHi %{ _opnds[1]-&gt;constant() &gt;&gt; 32 /*&amp; 0xFFFF0000L */%}
 6237     immI shift32 %{ 32 %}
 6238     iRegLdst tmpL;
 6239     loadConL32hi16(tmpL, srcHi);
 6240     lshiftL_regL_immI(dst, tmpL, shift32);
 6241   %}
 6242 %}
 6243 
 6244 // Expand node for constant pool load: small offset.
 6245 instruct loadConL(iRegLdst dst, immL src, iRegLdst toc) %{
 6246   effect(DEF dst, USE src, USE toc);
 6247   ins_cost(MEMORY_REF_COST);
 6248 
 6249   ins_num_consts(1);
 6250   // Needed so that CallDynamicJavaDirect can compute the address of this
 6251   // instruction for relocation.
 6252   ins_field_cbuf_insts_offset(int);
 6253 
 6254   format %{ &quot;LD      $dst, offset, $toc \t// load long $src from TOC&quot; %}
 6255   size(4);
 6256   ins_encode( enc_load_long_constL(dst, src, toc) );
 6257   ins_pipe(pipe_class_memory);
 6258 %}
 6259 
 6260 // Expand node for constant pool load: large offset.
 6261 instruct loadConL_hi(iRegLdst dst, immL src, iRegLdst toc) %{
 6262   effect(DEF dst, USE src, USE toc);
 6263   predicate(false);
 6264 
 6265   ins_num_consts(1);
 6266   ins_field_const_toc_offset(int);
 6267   // Needed so that CallDynamicJavaDirect can compute the address of this
 6268   // instruction for relocation.
 6269   ins_field_cbuf_insts_offset(int);
 6270 
 6271   format %{ &quot;ADDIS   $dst, $toc, offset \t// load long $src from TOC (hi)&quot; %}
 6272   size(4);
 6273   ins_encode( enc_load_long_constL_hi(dst, toc, src) );
 6274   ins_pipe(pipe_class_default);
 6275 %}
 6276 
 6277 // Expand node for constant pool load: large offset.
 6278 // No constant pool entries required.
 6279 instruct loadConL_lo(iRegLdst dst, immL src, iRegLdst base) %{
 6280   effect(DEF dst, USE src, USE base);
 6281   predicate(false);
 6282 
 6283   ins_field_const_toc_offset_hi_node(loadConL_hiNode*);
 6284 
 6285   format %{ &quot;LD      $dst, offset, $base \t// load long $src from TOC (lo)&quot; %}
 6286   size(4);
 6287   ins_encode %{
 6288     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
 6289     int offset = ra_-&gt;C-&gt;in_scratch_emit_size() ? 0 : _const_toc_offset_hi_node-&gt;_const_toc_offset;
 6290     __ ld($dst$$Register, MacroAssembler::largeoffset_si16_si16_lo(offset), $base$$Register);
 6291   %}
 6292   ins_pipe(pipe_class_memory);
 6293 %}
 6294 
 6295 // Load long constant from constant table. Expand in case of
 6296 // offset &gt; 16 bit is needed.
 6297 // Adlc adds toc node MachConstantTableBase.
 6298 instruct loadConL_Ex(iRegLdst dst, immL src) %{
 6299   match(Set dst src);
 6300   ins_cost(MEMORY_REF_COST);
 6301 
 6302   format %{ &quot;LD      $dst, offset, $constanttablebase\t// load long $src from table, postalloc expanded&quot; %}
 6303   // We can not inline the enc_class for the expand as that does not support constanttablebase.
 6304   postalloc_expand( postalloc_expand_load_long_constant(dst, src, constanttablebase) );
 6305 %}
 6306 
 6307 // Load NULL as compressed oop.
 6308 instruct loadConN0(iRegNdst dst, immN_0 src) %{
 6309   match(Set dst src);
 6310   ins_cost(DEFAULT_COST);
 6311 
 6312   format %{ &quot;LI      $dst, $src \t// compressed ptr&quot; %}
 6313   size(4);
 6314   ins_encode %{
 6315     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 6316     __ li($dst$$Register, 0);
 6317   %}
 6318   ins_pipe(pipe_class_default);
 6319 %}
 6320 
 6321 // Load hi part of compressed oop constant.
 6322 instruct loadConN_hi(iRegNdst dst, immN src) %{
 6323   effect(DEF dst, USE src);
 6324   ins_cost(DEFAULT_COST);
 6325 
 6326   format %{ &quot;LIS     $dst, $src \t// narrow oop hi&quot; %}
 6327   size(4);
 6328   ins_encode %{
 6329     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 6330     __ lis($dst$$Register, (int)(short)(($src$$constant &gt;&gt; 16) &amp; 0xffff));
 6331   %}
 6332   ins_pipe(pipe_class_default);
 6333 %}
 6334 
 6335 // Add lo part of compressed oop constant to already loaded hi part.
 6336 instruct loadConN_lo(iRegNdst dst, iRegNsrc src1, immN src2) %{
 6337   effect(DEF dst, USE src1, USE src2);
 6338   ins_cost(DEFAULT_COST);
 6339 
 6340   format %{ &quot;ORI     $dst, $src1, $src2 \t// narrow oop lo&quot; %}
 6341   size(4);
 6342   ins_encode %{
 6343     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 6344     assert(__ oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
 6345     int oop_index = __ oop_recorder()-&gt;find_index((jobject)$src2$$constant);
 6346     RelocationHolder rspec = oop_Relocation::spec(oop_index);
 6347     __ relocate(rspec, 1);
 6348     __ ori($dst$$Register, $src1$$Register, $src2$$constant &amp; 0xffff);
 6349   %}
 6350   ins_pipe(pipe_class_default);
 6351 %}
 6352 
 6353 instruct rldicl(iRegLdst dst, iRegLsrc src, immI16 shift, immI16 mask_begin) %{
 6354   effect(DEF dst, USE src, USE shift, USE mask_begin);
 6355 
 6356   size(4);
 6357   ins_encode %{
 6358     __ rldicl($dst$$Register, $src$$Register, $shift$$constant, $mask_begin$$constant);
 6359   %}
 6360   ins_pipe(pipe_class_default);
 6361 %}
 6362 
 6363 // Needed to postalloc expand loadConN: ConN is loaded as ConI
 6364 // leaving the upper 32 bits with sign-extension bits.
 6365 // This clears these bits: dst = src &amp; 0xFFFFFFFF.
 6366 // TODO: Eventually call this maskN_regN_FFFFFFFF.
 6367 instruct clearMs32b(iRegNdst dst, iRegNsrc src) %{
 6368   effect(DEF dst, USE src);
 6369   predicate(false);
 6370 
 6371   format %{ &quot;MASK    $dst, $src, 0xFFFFFFFF&quot; %} // mask
 6372   size(4);
 6373   ins_encode %{
 6374     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 6375     __ clrldi($dst$$Register, $src$$Register, 0x20);
 6376   %}
 6377   ins_pipe(pipe_class_default);
 6378 %}
 6379 
 6380 // Optimize DecodeN for disjoint base.
 6381 // Load base of compressed oops into a register
 6382 instruct loadBase(iRegLdst dst) %{
 6383   effect(DEF dst);
 6384 
 6385   format %{ &quot;LoadConst $dst, heapbase&quot; %}
 6386   ins_encode %{
 6387     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6388     __ load_const_optimized($dst$$Register, CompressedOops::base(), R0);
 6389   %}
 6390   ins_pipe(pipe_class_default);
 6391 %}
 6392 
 6393 // Loading ConN must be postalloc expanded so that edges between
 6394 // the nodes are safe. They may not interfere with a safepoint.
 6395 // GL TODO: This needs three instructions: better put this into the constant pool.
 6396 instruct loadConN_Ex(iRegNdst dst, immN src) %{
 6397   match(Set dst src);
 6398   ins_cost(DEFAULT_COST*2);
 6399 
 6400   format %{ &quot;LoadN   $dst, $src \t// postalloc expanded&quot; %} // mask
 6401   postalloc_expand %{
 6402     MachNode *m1 = new loadConN_hiNode();
 6403     MachNode *m2 = new loadConN_loNode();
 6404     MachNode *m3 = new clearMs32bNode();
 6405     m1-&gt;add_req(NULL);
 6406     m2-&gt;add_req(NULL, m1);
 6407     m3-&gt;add_req(NULL, m2);
 6408     m1-&gt;_opnds[0] = op_dst;
 6409     m1-&gt;_opnds[1] = op_src;
 6410     m2-&gt;_opnds[0] = op_dst;
 6411     m2-&gt;_opnds[1] = op_dst;
 6412     m2-&gt;_opnds[2] = op_src;
 6413     m3-&gt;_opnds[0] = op_dst;
 6414     m3-&gt;_opnds[1] = op_dst;
 6415     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6416     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6417     ra_-&gt;set_pair(m3-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6418     nodes-&gt;push(m1);
 6419     nodes-&gt;push(m2);
 6420     nodes-&gt;push(m3);
 6421   %}
 6422 %}
 6423 
 6424 // We have seen a safepoint between the hi and lo parts, and this node was handled
 6425 // as an oop. Therefore this needs a match rule so that build_oop_map knows this is
 6426 // not a narrow oop.
 6427 instruct loadConNKlass_hi(iRegNdst dst, immNKlass_NM src) %{
 6428   match(Set dst src);
 6429   effect(DEF dst, USE src);
 6430   ins_cost(DEFAULT_COST);
 6431 
 6432   format %{ &quot;LIS     $dst, $src \t// narrow klass hi&quot; %}
 6433   size(4);
 6434   ins_encode %{
 6435     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 6436     intptr_t Csrc = CompressedKlassPointers::encode((Klass *)$src$$constant);
 6437     __ lis($dst$$Register, (int)(short)((Csrc &gt;&gt; 16) &amp; 0xffff));
 6438   %}
 6439   ins_pipe(pipe_class_default);
 6440 %}
 6441 
 6442 // As loadConNKlass_hi this must be recognized as narrow klass, not oop!
 6443 instruct loadConNKlass_mask(iRegNdst dst, immNKlass_NM src1, iRegNsrc src2) %{
 6444   match(Set dst src1);
 6445   effect(TEMP src2);
 6446   ins_cost(DEFAULT_COST);
 6447 
 6448   format %{ &quot;MASK    $dst, $src2, 0xFFFFFFFF&quot; %} // mask
 6449   size(4);
 6450   ins_encode %{
 6451     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 6452     __ clrldi($dst$$Register, $src2$$Register, 0x20);
 6453   %}
 6454   ins_pipe(pipe_class_default);
 6455 %}
 6456 
 6457 // This needs a match rule so that build_oop_map knows this is
 6458 // not a narrow oop.
 6459 instruct loadConNKlass_lo(iRegNdst dst, immNKlass_NM src1, iRegNsrc src2) %{
 6460   match(Set dst src1);
 6461   effect(TEMP src2);
 6462   ins_cost(DEFAULT_COST);
 6463 
 6464   format %{ &quot;ORI     $dst, $src1, $src2 \t// narrow klass lo&quot; %}
 6465   size(4);
 6466   ins_encode %{
 6467     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
 6468     intptr_t Csrc = CompressedKlassPointers::encode((Klass *)$src1$$constant);
 6469     assert(__ oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
 6470     int klass_index = __ oop_recorder()-&gt;find_index((Klass *)$src1$$constant);
 6471     RelocationHolder rspec = metadata_Relocation::spec(klass_index);
 6472 
 6473     __ relocate(rspec, 1);
 6474     __ ori($dst$$Register, $src2$$Register, Csrc &amp; 0xffff);
 6475   %}
 6476   ins_pipe(pipe_class_default);
 6477 %}
 6478 
 6479 // Loading ConNKlass must be postalloc expanded so that edges between
 6480 // the nodes are safe. They may not interfere with a safepoint.
 6481 instruct loadConNKlass_Ex(iRegNdst dst, immNKlass src) %{
 6482   match(Set dst src);
 6483   ins_cost(DEFAULT_COST*2);
 6484 
 6485   format %{ &quot;LoadN   $dst, $src \t// postalloc expanded&quot; %} // mask
 6486   postalloc_expand %{
 6487     // Load high bits into register. Sign extended.
 6488     MachNode *m1 = new loadConNKlass_hiNode();
 6489     m1-&gt;add_req(NULL);
 6490     m1-&gt;_opnds[0] = op_dst;
 6491     m1-&gt;_opnds[1] = op_src;
 6492     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6493     nodes-&gt;push(m1);
 6494 
 6495     MachNode *m2 = m1;
 6496     if (!Assembler::is_uimm((jlong)CompressedKlassPointers::encode((Klass *)op_src-&gt;constant()), 31)) {
 6497       // Value might be 1-extended. Mask out these bits.
 6498       m2 = new loadConNKlass_maskNode();
 6499       m2-&gt;add_req(NULL, m1);
 6500       m2-&gt;_opnds[0] = op_dst;
 6501       m2-&gt;_opnds[1] = op_src;
 6502       m2-&gt;_opnds[2] = op_dst;
 6503       ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6504       nodes-&gt;push(m2);
 6505     }
 6506 
 6507     MachNode *m3 = new loadConNKlass_loNode();
 6508     m3-&gt;add_req(NULL, m2);
 6509     m3-&gt;_opnds[0] = op_dst;
 6510     m3-&gt;_opnds[1] = op_src;
 6511     m3-&gt;_opnds[2] = op_dst;
 6512     ra_-&gt;set_pair(m3-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6513     nodes-&gt;push(m3);
 6514   %}
 6515 %}
 6516 
 6517 // 0x1 is used in object initialization (initial object header).
 6518 // No constant pool entries required.
 6519 instruct loadConP0or1(iRegPdst dst, immP_0or1 src) %{
 6520   match(Set dst src);
 6521 
 6522   format %{ &quot;LI      $dst, $src \t// ptr&quot; %}
 6523   size(4);
 6524   ins_encode %{
 6525     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 6526     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
 6527   %}
 6528   ins_pipe(pipe_class_default);
 6529 %}
 6530 
 6531 // Expand node for constant pool load: small offset.
 6532 // The match rule is needed to generate the correct bottom_type(),
 6533 // however this node should never match. The use of predicate is not
 6534 // possible since ADLC forbids predicates for chain rules. The higher
 6535 // costs do not prevent matching in this case. For that reason the
 6536 // operand immP_NM with predicate(false) is used.
 6537 instruct loadConP(iRegPdst dst, immP_NM src, iRegLdst toc) %{
 6538   match(Set dst src);
 6539   effect(TEMP toc);
 6540 
 6541   ins_num_consts(1);
 6542 
 6543   format %{ &quot;LD      $dst, offset, $toc \t// load ptr $src from TOC&quot; %}
 6544   size(4);
 6545   ins_encode( enc_load_long_constP(dst, src, toc) );
 6546   ins_pipe(pipe_class_memory);
 6547 %}
 6548 
 6549 // Expand node for constant pool load: large offset.
 6550 instruct loadConP_hi(iRegPdst dst, immP_NM src, iRegLdst toc) %{
 6551   effect(DEF dst, USE src, USE toc);
 6552   predicate(false);
 6553 
 6554   ins_num_consts(1);
 6555   ins_field_const_toc_offset(int);
 6556 
 6557   format %{ &quot;ADDIS   $dst, $toc, offset \t// load ptr $src from TOC (hi)&quot; %}
 6558   size(4);
 6559   ins_encode( enc_load_long_constP_hi(dst, src, toc) );
 6560   ins_pipe(pipe_class_default);
 6561 %}
 6562 
 6563 // Expand node for constant pool load: large offset.
 6564 instruct loadConP_lo(iRegPdst dst, immP_NM src, iRegLdst base) %{
 6565   match(Set dst src);
 6566   effect(TEMP base);
 6567 
 6568   ins_field_const_toc_offset_hi_node(loadConP_hiNode*);
 6569 
 6570   format %{ &quot;LD      $dst, offset, $base \t// load ptr $src from TOC (lo)&quot; %}
 6571   size(4);
 6572   ins_encode %{
 6573     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
 6574     int offset = ra_-&gt;C-&gt;in_scratch_emit_size() ? 0 : _const_toc_offset_hi_node-&gt;_const_toc_offset;
 6575     __ ld($dst$$Register, MacroAssembler::largeoffset_si16_si16_lo(offset), $base$$Register);
 6576   %}
 6577   ins_pipe(pipe_class_memory);
 6578 %}
 6579 
 6580 // Load pointer constant from constant table. Expand in case an
 6581 // offset &gt; 16 bit is needed.
 6582 // Adlc adds toc node MachConstantTableBase.
 6583 instruct loadConP_Ex(iRegPdst dst, immP src) %{
 6584   match(Set dst src);
 6585   ins_cost(MEMORY_REF_COST);
 6586 
 6587   // This rule does not use &quot;expand&quot; because then
 6588   // the result type is not known to be an Oop.  An ADLC
 6589   // enhancement will be needed to make that work - not worth it!
 6590 
 6591   // If this instruction rematerializes, it prolongs the live range
 6592   // of the toc node, causing illegal graphs.
 6593   // assert(edge_from_to(_reg_node[reg_lo],def)) fails in verify_good_schedule().
 6594   ins_cannot_rematerialize(true);
 6595 
 6596   format %{ &quot;LD    $dst, offset, $constanttablebase \t//  load ptr $src from table, postalloc expanded&quot; %}
 6597   postalloc_expand( postalloc_expand_load_ptr_constant(dst, src, constanttablebase) );
 6598 %}
 6599 
 6600 // Expand node for constant pool load: small offset.
 6601 instruct loadConF(regF dst, immF src, iRegLdst toc) %{
 6602   effect(DEF dst, USE src, USE toc);
 6603   ins_cost(MEMORY_REF_COST);
 6604 
 6605   ins_num_consts(1);
 6606 
 6607   format %{ &quot;LFS     $dst, offset, $toc \t// load float $src from TOC&quot; %}
 6608   size(4);
 6609   ins_encode %{
 6610     // TODO: PPC port $archOpcode(ppc64Opcode_lfs);
 6611     address float_address = __ float_constant($src$$constant);
 6612     if (float_address == NULL) {
 6613       ciEnv::current()-&gt;record_out_of_memory_failure();
 6614       return;
 6615     }
 6616     __ lfs($dst$$FloatRegister, __ offset_to_method_toc(float_address), $toc$$Register);
 6617   %}
 6618   ins_pipe(pipe_class_memory);
 6619 %}
 6620 
 6621 // Expand node for constant pool load: large offset.
 6622 instruct loadConFComp(regF dst, immF src, iRegLdst toc) %{
 6623   effect(DEF dst, USE src, USE toc);
 6624   ins_cost(MEMORY_REF_COST);
 6625 
 6626   ins_num_consts(1);
 6627 
 6628   format %{ &quot;ADDIS   $toc, $toc, offset_hi\n\t&quot;
 6629             &quot;LFS     $dst, offset_lo, $toc \t// load float $src from TOC (hi/lo)\n\t&quot;
 6630             &quot;ADDIS   $toc, $toc, -offset_hi&quot;%}
 6631   size(12);
 6632   ins_encode %{
 6633     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6634     FloatRegister Rdst    = $dst$$FloatRegister;
 6635     Register Rtoc         = $toc$$Register;
 6636     address float_address = __ float_constant($src$$constant);
 6637     if (float_address == NULL) {
 6638       ciEnv::current()-&gt;record_out_of_memory_failure();
 6639       return;
 6640     }
 6641     int offset            = __ offset_to_method_toc(float_address);
 6642     int hi = (offset + (1&lt;&lt;15))&gt;&gt;16;
 6643     int lo = offset - hi * (1&lt;&lt;16);
 6644 
 6645     __ addis(Rtoc, Rtoc, hi);
 6646     __ lfs(Rdst, lo, Rtoc);
 6647     __ addis(Rtoc, Rtoc, -hi);
 6648   %}
 6649   ins_pipe(pipe_class_memory);
 6650 %}
 6651 
 6652 // Adlc adds toc node MachConstantTableBase.
 6653 instruct loadConF_Ex(regF dst, immF src) %{
 6654   match(Set dst src);
 6655   ins_cost(MEMORY_REF_COST);
 6656 
 6657   // See loadConP.
 6658   ins_cannot_rematerialize(true);
 6659 
 6660   format %{ &quot;LFS     $dst, offset, $constanttablebase \t// load $src from table, postalloc expanded&quot; %}
 6661   postalloc_expand( postalloc_expand_load_float_constant(dst, src, constanttablebase) );
 6662 %}
 6663 
 6664 // Expand node for constant pool load: small offset.
 6665 instruct loadConD(regD dst, immD src, iRegLdst toc) %{
 6666   effect(DEF dst, USE src, USE toc);
 6667   ins_cost(MEMORY_REF_COST);
 6668 
 6669   ins_num_consts(1);
 6670 
 6671   format %{ &quot;LFD     $dst, offset, $toc \t// load double $src from TOC&quot; %}
 6672   size(4);
 6673   ins_encode %{
 6674     // TODO: PPC port $archOpcode(ppc64Opcode_lfd);
 6675     address float_address = __ double_constant($src$$constant);
 6676     if (float_address == NULL) {
 6677       ciEnv::current()-&gt;record_out_of_memory_failure();
 6678       return;
 6679     }
 6680     int offset =  __ offset_to_method_toc(float_address);
 6681     __ lfd($dst$$FloatRegister, offset, $toc$$Register);
 6682   %}
 6683   ins_pipe(pipe_class_memory);
 6684 %}
 6685 
 6686 // Expand node for constant pool load: large offset.
 6687 instruct loadConDComp(regD dst, immD src, iRegLdst toc) %{
 6688   effect(DEF dst, USE src, USE toc);
 6689   ins_cost(MEMORY_REF_COST);
 6690 
 6691   ins_num_consts(1);
 6692 
 6693   format %{ &quot;ADDIS   $toc, $toc, offset_hi\n\t&quot;
 6694             &quot;LFD     $dst, offset_lo, $toc \t// load double $src from TOC (hi/lo)\n\t&quot;
 6695             &quot;ADDIS   $toc, $toc, -offset_hi&quot; %}
 6696   size(12);
 6697   ins_encode %{
 6698     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6699     FloatRegister Rdst    = $dst$$FloatRegister;
 6700     Register      Rtoc    = $toc$$Register;
 6701     address float_address = __ double_constant($src$$constant);
 6702     if (float_address == NULL) {
 6703       ciEnv::current()-&gt;record_out_of_memory_failure();
 6704       return;
 6705     }
 6706     int offset = __ offset_to_method_toc(float_address);
 6707     int hi = (offset + (1&lt;&lt;15))&gt;&gt;16;
 6708     int lo = offset - hi * (1&lt;&lt;16);
 6709 
 6710     __ addis(Rtoc, Rtoc, hi);
 6711     __ lfd(Rdst, lo, Rtoc);
 6712     __ addis(Rtoc, Rtoc, -hi);
 6713   %}
 6714   ins_pipe(pipe_class_memory);
 6715 %}
 6716 
 6717 // Adlc adds toc node MachConstantTableBase.
 6718 instruct loadConD_Ex(regD dst, immD src) %{
 6719   match(Set dst src);
 6720   ins_cost(MEMORY_REF_COST);
 6721 
 6722   // See loadConP.
 6723   ins_cannot_rematerialize(true);
 6724 
 6725   format %{ &quot;ConD    $dst, offset, $constanttablebase \t// load $src from table, postalloc expanded&quot; %}
 6726   postalloc_expand( postalloc_expand_load_double_constant(dst, src, constanttablebase) );
 6727 %}
 6728 
 6729 // Prefetch instructions.
 6730 // Must be safe to execute with invalid address (cannot fault).
 6731 
 6732 // Special prefetch versions which use the dcbz instruction.
 6733 instruct prefetch_alloc_zero(indirectMemory mem, iRegLsrc src) %{
 6734   match(PrefetchAllocation (AddP mem src));
 6735   predicate(AllocatePrefetchStyle == 3);
 6736   ins_cost(MEMORY_REF_COST);
 6737 
 6738   format %{ &quot;PREFETCH $mem, 2, $src \t// Prefetch write-many with zero&quot; %}
 6739   size(4);
 6740   ins_encode %{
 6741     // TODO: PPC port $archOpcode(ppc64Opcode_dcbtst);
 6742     __ dcbz($src$$Register, $mem$$base$$Register);
 6743   %}
 6744   ins_pipe(pipe_class_memory);
 6745 %}
 6746 
 6747 instruct prefetch_alloc_zero_no_offset(indirectMemory mem) %{
 6748   match(PrefetchAllocation mem);
 6749   predicate(AllocatePrefetchStyle == 3);
 6750   ins_cost(MEMORY_REF_COST);
 6751 
 6752   format %{ &quot;PREFETCH $mem, 2 \t// Prefetch write-many with zero&quot; %}
 6753   size(4);
 6754   ins_encode %{
 6755     // TODO: PPC port $archOpcode(ppc64Opcode_dcbtst);
 6756     __ dcbz($mem$$base$$Register);
 6757   %}
 6758   ins_pipe(pipe_class_memory);
 6759 %}
 6760 
 6761 instruct prefetch_alloc(indirectMemory mem, iRegLsrc src) %{
 6762   match(PrefetchAllocation (AddP mem src));
 6763   predicate(AllocatePrefetchStyle != 3);
 6764   ins_cost(MEMORY_REF_COST);
 6765 
 6766   format %{ &quot;PREFETCH $mem, 2, $src \t// Prefetch write-many&quot; %}
 6767   size(4);
 6768   ins_encode %{
 6769     // TODO: PPC port $archOpcode(ppc64Opcode_dcbtst);
 6770     __ dcbtst($src$$Register, $mem$$base$$Register);
 6771   %}
 6772   ins_pipe(pipe_class_memory);
 6773 %}
 6774 
 6775 instruct prefetch_alloc_no_offset(indirectMemory mem) %{
 6776   match(PrefetchAllocation mem);
 6777   predicate(AllocatePrefetchStyle != 3);
 6778   ins_cost(MEMORY_REF_COST);
 6779 
 6780   format %{ &quot;PREFETCH $mem, 2 \t// Prefetch write-many&quot; %}
 6781   size(4);
 6782   ins_encode %{
 6783     // TODO: PPC port $archOpcode(ppc64Opcode_dcbtst);
 6784     __ dcbtst($mem$$base$$Register);
 6785   %}
 6786   ins_pipe(pipe_class_memory);
 6787 %}
 6788 
 6789 //----------Store Instructions-------------------------------------------------
 6790 
 6791 // Store Byte
 6792 instruct storeB(memory mem, iRegIsrc src) %{
 6793   match(Set mem (StoreB mem src));
 6794   ins_cost(MEMORY_REF_COST);
 6795 
 6796   format %{ &quot;STB     $src, $mem \t// byte&quot; %}
 6797   size(4);
 6798   ins_encode %{
 6799     // TODO: PPC port $archOpcode(ppc64Opcode_stb);
 6800     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 6801     __ stb($src$$Register, Idisp, $mem$$base$$Register);
 6802   %}
 6803   ins_pipe(pipe_class_memory);
 6804 %}
 6805 
 6806 // Store Char/Short
 6807 instruct storeC(memory mem, iRegIsrc src) %{
 6808   match(Set mem (StoreC mem src));
 6809   ins_cost(MEMORY_REF_COST);
 6810 
 6811   format %{ &quot;STH     $src, $mem \t// short&quot; %}
 6812   size(4);
 6813   ins_encode %{
 6814     // TODO: PPC port $archOpcode(ppc64Opcode_sth);
 6815     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 6816     __ sth($src$$Register, Idisp, $mem$$base$$Register);
 6817   %}
 6818   ins_pipe(pipe_class_memory);
 6819 %}
 6820 
 6821 // Store Integer
 6822 instruct storeI(memory mem, iRegIsrc src) %{
 6823   match(Set mem (StoreI mem src));
 6824   ins_cost(MEMORY_REF_COST);
 6825 
 6826   format %{ &quot;STW     $src, $mem&quot; %}
 6827   size(4);
 6828   ins_encode( enc_stw(src, mem) );
 6829   ins_pipe(pipe_class_memory);
 6830 %}
 6831 
 6832 // ConvL2I + StoreI.
 6833 instruct storeI_convL2I(memory mem, iRegLsrc src) %{
 6834   match(Set mem (StoreI mem (ConvL2I src)));
 6835   ins_cost(MEMORY_REF_COST);
 6836 
 6837   format %{ &quot;STW     l2i($src), $mem&quot; %}
 6838   size(4);
 6839   ins_encode( enc_stw(src, mem) );
 6840   ins_pipe(pipe_class_memory);
 6841 %}
 6842 
 6843 // Store Long
 6844 instruct storeL(memoryAlg4 mem, iRegLsrc src) %{
 6845   match(Set mem (StoreL mem src));
 6846   ins_cost(MEMORY_REF_COST);
 6847 
 6848   format %{ &quot;STD     $src, $mem \t// long&quot; %}
 6849   size(4);
 6850   ins_encode( enc_std(src, mem) );
 6851   ins_pipe(pipe_class_memory);
 6852 %}
 6853 
 6854 // Store super word nodes.
 6855 
 6856 // Store Aligned Packed Byte long register to memory
 6857 instruct storeA8B(memoryAlg4 mem, iRegLsrc src) %{
 6858   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
 6859   match(Set mem (StoreVector mem src));
 6860   ins_cost(MEMORY_REF_COST);
 6861 
 6862   format %{ &quot;STD     $mem, $src \t// packed8B&quot; %}
 6863   size(4);
 6864   ins_encode( enc_std(src, mem) );
 6865   ins_pipe(pipe_class_memory);
 6866 %}
 6867 
 6868 // Store Packed Byte long register to memory
 6869 instruct storeV16(indirect mem, vecX src) %{
 6870   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 16);
 6871   match(Set mem (StoreVector mem src));
 6872   ins_cost(MEMORY_REF_COST);
 6873 
 6874   format %{ &quot;STXVD2X     $mem, $src \t// store 16-byte Vector&quot; %}
 6875   size(4);
 6876   ins_encode %{
 6877     __ stxvd2x($src$$VectorSRegister, $mem$$Register);
 6878   %}
 6879   ins_pipe(pipe_class_default);
 6880 %}
 6881 
 6882 // Store Compressed Oop
 6883 instruct storeN(memory dst, iRegN_P2N src) %{
 6884   match(Set dst (StoreN dst src));
 6885   ins_cost(MEMORY_REF_COST);
 6886 
 6887   format %{ &quot;STW     $src, $dst \t// compressed oop&quot; %}
 6888   size(4);
 6889   ins_encode( enc_stw(src, dst) );
 6890   ins_pipe(pipe_class_memory);
 6891 %}
 6892 
 6893 // Store Compressed KLass
 6894 instruct storeNKlass(memory dst, iRegN_P2N src) %{
 6895   match(Set dst (StoreNKlass dst src));
 6896   ins_cost(MEMORY_REF_COST);
 6897 
 6898   format %{ &quot;STW     $src, $dst \t// compressed klass&quot; %}
 6899   size(4);
 6900   ins_encode( enc_stw(src, dst) );
 6901   ins_pipe(pipe_class_memory);
 6902 %}
 6903 
 6904 // Store Pointer
 6905 instruct storeP(memoryAlg4 dst, iRegPsrc src) %{
 6906   match(Set dst (StoreP dst src));
 6907   ins_cost(MEMORY_REF_COST);
 6908 
 6909   format %{ &quot;STD     $src, $dst \t// ptr&quot; %}
 6910   size(4);
 6911   ins_encode( enc_std(src, dst) );
 6912   ins_pipe(pipe_class_memory);
 6913 %}
 6914 
 6915 // Store Float
 6916 instruct storeF(memory mem, regF src) %{
 6917   match(Set mem (StoreF mem src));
 6918   ins_cost(MEMORY_REF_COST);
 6919 
 6920   format %{ &quot;STFS    $src, $mem&quot; %}
 6921   size(4);
 6922   ins_encode( enc_stfs(src, mem) );
 6923   ins_pipe(pipe_class_memory);
 6924 %}
 6925 
 6926 // Store Double
 6927 instruct storeD(memory mem, regD src) %{
 6928   match(Set mem (StoreD mem src));
 6929   ins_cost(MEMORY_REF_COST);
 6930 
 6931   format %{ &quot;STFD    $src, $mem&quot; %}
 6932   size(4);
 6933   ins_encode( enc_stfd(src, mem) );
 6934   ins_pipe(pipe_class_memory);
 6935 %}
 6936 
 6937 //----------Store Instructions With Zeros--------------------------------------
 6938 
 6939 // Card-mark for CMS garbage collection.
 6940 // This cardmark does an optimization so that it must not always
 6941 // do a releasing store. For this, it gets the address of
 6942 // CMSCollectorCardTableBarrierSetBSExt::_requires_release as input.
 6943 // (Using releaseFieldAddr in the match rule is a hack.)
 6944 instruct storeCM_CMS(memory mem, iRegLdst releaseFieldAddr, flagsReg crx) %{
 6945   match(Set mem (StoreCM mem releaseFieldAddr));
 6946   effect(TEMP crx);
 6947   predicate(false);
 6948   ins_cost(MEMORY_REF_COST);
 6949 
 6950   // See loadConP.
 6951   ins_cannot_rematerialize(true);
 6952 
 6953   format %{ &quot;STB     #0, $mem \t// CMS card-mark byte (must be 0!), checking requires_release in [$releaseFieldAddr]&quot; %}
 6954   ins_encode( enc_cms_card_mark(mem, releaseFieldAddr, crx) );
 6955   ins_pipe(pipe_class_memory);
 6956 %}
 6957 
 6958 instruct storeCM_G1(memory mem, immI_0 zero) %{
 6959   match(Set mem (StoreCM mem zero));
 6960   predicate(UseG1GC);
 6961   ins_cost(MEMORY_REF_COST);
 6962 
 6963   ins_cannot_rematerialize(true);
 6964 
 6965   format %{ &quot;STB     #0, $mem \t// CMS card-mark byte store (G1)&quot; %}
 6966   size(8);
 6967   ins_encode %{
 6968     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6969     __ li(R0, 0);
 6970     //__ release(); // G1: oops are allowed to get visible after dirty marking
 6971     guarantee($mem$$base$$Register != R1_SP, &quot;use frame_slots_bias&quot;);
 6972     __ stb(R0, $mem$$disp, $mem$$base$$Register);
 6973   %}
 6974   ins_pipe(pipe_class_memory);
 6975 %}
 6976 
 6977 // Convert oop pointer into compressed form.
 6978 
 6979 // Nodes for postalloc expand.
 6980 
 6981 // Shift node for expand.
 6982 instruct encodeP_shift(iRegNdst dst, iRegNsrc src) %{
 6983   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 6984   match(Set dst (EncodeP src));
 6985   predicate(false);
 6986 
 6987   format %{ &quot;SRDI    $dst, $src, 3 \t// encode&quot; %}
 6988   size(4);
 6989   ins_encode %{
 6990     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 6991     __ srdi($dst$$Register, $src$$Register, CompressedOops::shift() &amp; 0x3f);
 6992   %}
 6993   ins_pipe(pipe_class_default);
 6994 %}
 6995 
 6996 // Add node for expand.
 6997 instruct encodeP_sub(iRegPdst dst, iRegPdst src) %{
 6998   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 6999   match(Set dst (EncodeP src));
 7000   predicate(false);
 7001 
 7002   format %{ &quot;SUB     $dst, $src, oop_base \t// encode&quot; %}
 7003   ins_encode %{
 7004     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7005     __ sub_const_optimized($dst$$Register, $src$$Register, CompressedOops::base(), R0);
 7006   %}
 7007   ins_pipe(pipe_class_default);
 7008 %}
 7009 
 7010 // Conditional sub base.
 7011 instruct cond_sub_base(iRegNdst dst, flagsRegSrc crx, iRegPsrc src1) %{
 7012   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7013   match(Set dst (EncodeP (Binary crx src1)));
 7014   predicate(false);
 7015 
 7016   format %{ &quot;BEQ     $crx, done\n\t&quot;
 7017             &quot;SUB     $dst, $src1, heapbase \t// encode: subtract base if != NULL\n&quot;
 7018             &quot;done:&quot; %}
 7019   ins_encode %{
 7020     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7021     Label done;
 7022     __ beq($crx$$CondRegister, done);
 7023     __ sub_const_optimized($dst$$Register, $src1$$Register, CompressedOops::base(), R0);
 7024     __ bind(done);
 7025   %}
 7026   ins_pipe(pipe_class_default);
 7027 %}
 7028 
 7029 // Power 7 can use isel instruction
 7030 instruct cond_set_0_oop(iRegNdst dst, flagsRegSrc crx, iRegPsrc src1) %{
 7031   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7032   match(Set dst (EncodeP (Binary crx src1)));
 7033   predicate(false);
 7034 
 7035   format %{ &quot;CMOVE   $dst, $crx eq, 0, $src1 \t// encode: preserve 0&quot; %}
 7036   size(4);
 7037   ins_encode %{
 7038     // This is a Power7 instruction for which no machine description exists.
 7039     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7040     __ isel_0($dst$$Register, $crx$$CondRegister, Assembler::equal, $src1$$Register);
 7041   %}
 7042   ins_pipe(pipe_class_default);
 7043 %}
 7044 
 7045 // Disjoint narrow oop base.
 7046 instruct encodeP_Disjoint(iRegNdst dst, iRegPsrc src) %{
 7047   match(Set dst (EncodeP src));
 7048   predicate(CompressedOops::base_disjoint());
 7049 
 7050   format %{ &quot;EXTRDI  $dst, $src, #32, #3 \t// encode with disjoint base&quot; %}
 7051   size(4);
 7052   ins_encode %{
 7053     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 7054     __ rldicl($dst$$Register, $src$$Register, 64-CompressedOops::shift(), 32);
 7055   %}
 7056   ins_pipe(pipe_class_default);
 7057 %}
 7058 
 7059 // shift != 0, base != 0
 7060 instruct encodeP_Ex(iRegNdst dst, flagsReg crx, iRegPsrc src) %{
 7061   match(Set dst (EncodeP src));
 7062   effect(TEMP crx);
 7063   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 7064             CompressedOops::shift() != 0 &amp;&amp;
 7065             CompressedOops::base_overlaps());
 7066 
 7067   format %{ &quot;EncodeP $dst, $crx, $src \t// postalloc expanded&quot; %}
 7068   postalloc_expand( postalloc_expand_encode_oop(dst, src, crx));
 7069 %}
 7070 
 7071 // shift != 0, base != 0
 7072 instruct encodeP_not_null_Ex(iRegNdst dst, iRegPsrc src) %{
 7073   match(Set dst (EncodeP src));
 7074   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull &amp;&amp;
 7075             CompressedOops::shift() != 0 &amp;&amp;
 7076             CompressedOops::base_overlaps());
 7077 
 7078   format %{ &quot;EncodeP $dst, $src\t// $src != Null, postalloc expanded&quot; %}
 7079   postalloc_expand( postalloc_expand_encode_oop_not_null(dst, src) );
 7080 %}
 7081 
 7082 // shift != 0, base == 0
 7083 // TODO: This is the same as encodeP_shift. Merge!
 7084 instruct encodeP_not_null_base_null(iRegNdst dst, iRegPsrc src) %{
 7085   match(Set dst (EncodeP src));
 7086   predicate(CompressedOops::shift() != 0 &amp;&amp;
 7087             CompressedOops::base() ==0);
 7088 
 7089   format %{ &quot;SRDI    $dst, $src, #3 \t// encodeP, $src != NULL&quot; %}
 7090   size(4);
 7091   ins_encode %{
 7092     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 7093     __ srdi($dst$$Register, $src$$Register, CompressedOops::shift() &amp; 0x3f);
 7094   %}
 7095   ins_pipe(pipe_class_default);
 7096 %}
 7097 
 7098 // Compressed OOPs with narrow_oop_shift == 0.
 7099 // shift == 0, base == 0
 7100 instruct encodeP_narrow_oop_shift_0(iRegNdst dst, iRegPsrc src) %{
 7101   match(Set dst (EncodeP src));
 7102   predicate(CompressedOops::shift() == 0);
 7103 
 7104   format %{ &quot;MR      $dst, $src \t// Ptr-&gt;Narrow&quot; %}
 7105   // variable size, 0 or 4.
 7106   ins_encode %{
 7107     // TODO: PPC port $archOpcode(ppc64Opcode_or);
 7108     __ mr_if_needed($dst$$Register, $src$$Register);
 7109   %}
 7110   ins_pipe(pipe_class_default);
 7111 %}
 7112 
 7113 // Decode nodes.
 7114 
 7115 // Shift node for expand.
 7116 instruct decodeN_shift(iRegPdst dst, iRegPsrc src) %{
 7117   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7118   match(Set dst (DecodeN src));
 7119   predicate(false);
 7120 
 7121   format %{ &quot;SLDI    $dst, $src, #3 \t// DecodeN&quot; %}
 7122   size(4);
 7123   ins_encode %{
 7124     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
 7125     __ sldi($dst$$Register, $src$$Register, CompressedOops::shift());
 7126   %}
 7127   ins_pipe(pipe_class_default);
 7128 %}
 7129 
 7130 // Add node for expand.
 7131 instruct decodeN_add(iRegPdst dst, iRegPdst src) %{
 7132   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7133   match(Set dst (DecodeN src));
 7134   predicate(false);
 7135 
 7136   format %{ &quot;ADD     $dst, $src, heapbase \t// DecodeN, add oop base&quot; %}
 7137   ins_encode %{
 7138     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7139     __ add_const_optimized($dst$$Register, $src$$Register, CompressedOops::base(), R0);
 7140   %}
 7141   ins_pipe(pipe_class_default);
 7142 %}
 7143 
 7144 // conditianal add base for expand
 7145 instruct cond_add_base(iRegPdst dst, flagsRegSrc crx, iRegPsrc src) %{
 7146   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7147   // NOTICE that the rule is nonsense - we just have to make sure that:
 7148   //  - _matrule-&gt;_rChild-&gt;_opType == &quot;DecodeN&quot; (see InstructForm::captures_bottom_type() in formssel.cpp)
 7149   //  - we have to match &#39;crx&#39; to avoid an &quot;illegal USE of non-input: flagsReg crx&quot; error in ADLC.
 7150   match(Set dst (DecodeN (Binary crx src)));
 7151   predicate(false);
 7152 
 7153   format %{ &quot;BEQ     $crx, done\n\t&quot;
 7154             &quot;ADD     $dst, $src, heapbase \t// DecodeN: add oop base if $src != NULL\n&quot;
 7155             &quot;done:&quot; %}
 7156   ins_encode %{
 7157     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7158     Label done;
 7159     __ beq($crx$$CondRegister, done);
 7160     __ add_const_optimized($dst$$Register, $src$$Register, CompressedOops::base(), R0);
 7161     __ bind(done);
 7162   %}
 7163   ins_pipe(pipe_class_default);
 7164 %}
 7165 
 7166 instruct cond_set_0_ptr(iRegPdst dst, flagsRegSrc crx, iRegPsrc src1) %{
 7167   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7168   // NOTICE that the rule is nonsense - we just have to make sure that:
 7169   //  - _matrule-&gt;_rChild-&gt;_opType == &quot;DecodeN&quot; (see InstructForm::captures_bottom_type() in formssel.cpp)
 7170   //  - we have to match &#39;crx&#39; to avoid an &quot;illegal USE of non-input: flagsReg crx&quot; error in ADLC.
 7171   match(Set dst (DecodeN (Binary crx src1)));
 7172   predicate(false);
 7173 
 7174   format %{ &quot;CMOVE   $dst, $crx eq, 0, $src1 \t// decode: preserve 0&quot; %}
 7175   size(4);
 7176   ins_encode %{
 7177     // This is a Power7 instruction for which no machine description exists.
 7178     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7179     __ isel_0($dst$$Register, $crx$$CondRegister, Assembler::equal, $src1$$Register);
 7180   %}
 7181   ins_pipe(pipe_class_default);
 7182 %}
 7183 
 7184 //  shift != 0, base != 0
 7185 instruct decodeN_Ex(iRegPdst dst, iRegNsrc src, flagsReg crx) %{
 7186   match(Set dst (DecodeN src));
 7187   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 7188              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::Constant) &amp;&amp;
 7189             CompressedOops::shift() != 0 &amp;&amp;
 7190             CompressedOops::base() != 0);
 7191   ins_cost(4 * DEFAULT_COST); // Should be more expensive than decodeN_Disjoint_isel_Ex.
 7192   effect(TEMP crx);
 7193 
 7194   format %{ &quot;DecodeN $dst, $src \t// Kills $crx, postalloc expanded&quot; %}
 7195   postalloc_expand( postalloc_expand_decode_oop(dst, src, crx) );
 7196 %}
 7197 
 7198 // shift != 0, base == 0
 7199 instruct decodeN_nullBase(iRegPdst dst, iRegNsrc src) %{
 7200   match(Set dst (DecodeN src));
 7201   predicate(CompressedOops::shift() != 0 &amp;&amp;
 7202             CompressedOops::base() == 0);
 7203 
 7204   format %{ &quot;SLDI    $dst, $src, #3 \t// DecodeN (zerobased)&quot; %}
 7205   size(4);
 7206   ins_encode %{
 7207     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
 7208     __ sldi($dst$$Register, $src$$Register, CompressedOops::shift());
 7209   %}
 7210   ins_pipe(pipe_class_default);
 7211 %}
 7212 
 7213 // Optimize DecodeN for disjoint base.
 7214 // Shift narrow oop and or it into register that already contains the heap base.
 7215 // Base == dst must hold, and is assured by construction in postaloc_expand.
 7216 instruct decodeN_mergeDisjoint(iRegPdst dst, iRegNsrc src, iRegLsrc base) %{
 7217   match(Set dst (DecodeN src));
 7218   effect(TEMP base);
 7219   predicate(false);
 7220 
 7221   format %{ &quot;RLDIMI  $dst, $src, shift, 32-shift \t// DecodeN (disjoint base)&quot; %}
 7222   size(4);
 7223   ins_encode %{
 7224     // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
 7225     __ rldimi($dst$$Register, $src$$Register, CompressedOops::shift(), 32-CompressedOops::shift());
 7226   %}
 7227   ins_pipe(pipe_class_default);
 7228 %}
 7229 
 7230 // Optimize DecodeN for disjoint base.
 7231 // This node requires only one cycle on the critical path.
 7232 // We must postalloc_expand as we can not express use_def effects where
 7233 // the used register is L and the def&#39;ed register P.
 7234 instruct decodeN_Disjoint_notNull_Ex(iRegPdst dst, iRegNsrc src) %{
 7235   match(Set dst (DecodeN src));
 7236   effect(TEMP_DEF dst);
 7237   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::NotNull ||
 7238              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
 7239             CompressedOops::base_disjoint());
 7240   ins_cost(DEFAULT_COST);
 7241 
 7242   format %{ &quot;MOV     $dst, heapbase \t\n&quot;
 7243             &quot;RLDIMI  $dst, $src, shift, 32-shift \t// decode with disjoint base&quot; %}
 7244   postalloc_expand %{
 7245     loadBaseNode *n1 = new loadBaseNode();
 7246     n1-&gt;add_req(NULL);
 7247     n1-&gt;_opnds[0] = op_dst;
 7248 
 7249     decodeN_mergeDisjointNode *n2 = new decodeN_mergeDisjointNode();
 7250     n2-&gt;add_req(n_region, n_src, n1);
 7251     n2-&gt;_opnds[0] = op_dst;
 7252     n2-&gt;_opnds[1] = op_src;
 7253     n2-&gt;_opnds[2] = op_dst;
 7254     n2-&gt;_bottom_type = _bottom_type;
 7255 
 7256     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7257     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7258 
 7259     nodes-&gt;push(n1);
 7260     nodes-&gt;push(n2);
 7261   %}
 7262 %}
 7263 
 7264 instruct decodeN_Disjoint_isel_Ex(iRegPdst dst, iRegNsrc src, flagsReg crx) %{
 7265   match(Set dst (DecodeN src));
 7266   effect(TEMP_DEF dst, TEMP crx);
 7267   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 7268              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::Constant) &amp;&amp;
 7269             CompressedOops::base_disjoint() &amp;&amp; VM_Version::has_isel());
 7270   ins_cost(3 * DEFAULT_COST);
 7271 
 7272   format %{ &quot;DecodeN  $dst, $src \t// decode with disjoint base using isel&quot; %}
 7273   postalloc_expand %{
 7274     loadBaseNode *n1 = new loadBaseNode();
 7275     n1-&gt;add_req(NULL);
 7276     n1-&gt;_opnds[0] = op_dst;
 7277 
 7278     cmpN_reg_imm0Node *n_compare  = new cmpN_reg_imm0Node();
 7279     n_compare-&gt;add_req(n_region, n_src);
 7280     n_compare-&gt;_opnds[0] = op_crx;
 7281     n_compare-&gt;_opnds[1] = op_src;
 7282     n_compare-&gt;_opnds[2] = new immN_0Oper(TypeNarrowOop::NULL_PTR);
 7283 
 7284     decodeN_mergeDisjointNode *n2 = new decodeN_mergeDisjointNode();
 7285     n2-&gt;add_req(n_region, n_src, n1);
 7286     n2-&gt;_opnds[0] = op_dst;
 7287     n2-&gt;_opnds[1] = op_src;
 7288     n2-&gt;_opnds[2] = op_dst;
 7289     n2-&gt;_bottom_type = _bottom_type;
 7290 
 7291     cond_set_0_ptrNode *n_cond_set = new cond_set_0_ptrNode();
 7292     n_cond_set-&gt;add_req(n_region, n_compare, n2);
 7293     n_cond_set-&gt;_opnds[0] = op_dst;
 7294     n_cond_set-&gt;_opnds[1] = op_crx;
 7295     n_cond_set-&gt;_opnds[2] = op_dst;
 7296     n_cond_set-&gt;_bottom_type = _bottom_type;
 7297 
 7298     assert(ra_-&gt;is_oop(this) == true, &quot;A decodeN node must produce an oop!&quot;);
 7299     ra_-&gt;set_oop(n_cond_set, true);
 7300 
 7301     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7302     ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
 7303     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7304     ra_-&gt;set_pair(n_cond_set-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7305 
 7306     nodes-&gt;push(n1);
 7307     nodes-&gt;push(n_compare);
 7308     nodes-&gt;push(n2);
 7309     nodes-&gt;push(n_cond_set);
 7310   %}
 7311 %}
 7312 
 7313 // src != 0, shift != 0, base != 0
 7314 instruct decodeN_notNull_addBase_Ex(iRegPdst dst, iRegNsrc src) %{
 7315   match(Set dst (DecodeN src));
 7316   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::NotNull ||
 7317              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
 7318             CompressedOops::shift() != 0 &amp;&amp;
 7319             CompressedOops::base() != 0);
 7320   ins_cost(2 * DEFAULT_COST);
 7321 
 7322   format %{ &quot;DecodeN $dst, $src \t// $src != NULL, postalloc expanded&quot; %}
 7323   postalloc_expand( postalloc_expand_decode_oop_not_null(dst, src));
 7324 %}
 7325 
 7326 // Compressed OOPs with narrow_oop_shift == 0.
 7327 instruct decodeN_unscaled(iRegPdst dst, iRegNsrc src) %{
 7328   match(Set dst (DecodeN src));
 7329   predicate(CompressedOops::shift() == 0);
 7330   ins_cost(DEFAULT_COST);
 7331 
 7332   format %{ &quot;MR      $dst, $src \t// DecodeN (unscaled)&quot; %}
 7333   // variable size, 0 or 4.
 7334   ins_encode %{
 7335     // TODO: PPC port $archOpcode(ppc64Opcode_or);
 7336     __ mr_if_needed($dst$$Register, $src$$Register);
 7337   %}
 7338   ins_pipe(pipe_class_default);
 7339 %}
 7340 
 7341 // Convert compressed oop into int for vectors alignment masking.
 7342 instruct decodeN2I_unscaled(iRegIdst dst, iRegNsrc src) %{
 7343   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
 7344   predicate(CompressedOops::shift() == 0);
 7345   ins_cost(DEFAULT_COST);
 7346 
 7347   format %{ &quot;MR      $dst, $src \t// (int)DecodeN (unscaled)&quot; %}
 7348   // variable size, 0 or 4.
 7349   ins_encode %{
 7350     // TODO: PPC port $archOpcode(ppc64Opcode_or);
 7351     __ mr_if_needed($dst$$Register, $src$$Register);
 7352   %}
 7353   ins_pipe(pipe_class_default);
 7354 %}
 7355 
 7356 // Convert klass pointer into compressed form.
 7357 
 7358 // Nodes for postalloc expand.
 7359 
 7360 // Shift node for expand.
 7361 instruct encodePKlass_shift(iRegNdst dst, iRegNsrc src) %{
 7362   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7363   match(Set dst (EncodePKlass src));
 7364   predicate(false);
 7365 
 7366   format %{ &quot;SRDI    $dst, $src, 3 \t// encode&quot; %}
 7367   size(4);
 7368   ins_encode %{
 7369     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 7370     __ srdi($dst$$Register, $src$$Register, CompressedKlassPointers::shift());
 7371   %}
 7372   ins_pipe(pipe_class_default);
 7373 %}
 7374 
 7375 // Add node for expand.
 7376 instruct encodePKlass_sub_base(iRegPdst dst, iRegLsrc base, iRegPdst src) %{
 7377   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7378   match(Set dst (EncodePKlass (Binary base src)));
 7379   predicate(false);
 7380 
 7381   format %{ &quot;SUB     $dst, $base, $src \t// encode&quot; %}
 7382   size(4);
 7383   ins_encode %{
 7384     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
 7385     __ subf($dst$$Register, $base$$Register, $src$$Register);
 7386   %}
 7387   ins_pipe(pipe_class_default);
 7388 %}
 7389 
 7390 // Disjoint narrow oop base.
 7391 instruct encodePKlass_Disjoint(iRegNdst dst, iRegPsrc src) %{
 7392   match(Set dst (EncodePKlass src));
 7393   predicate(false /* TODO: PPC port CompressedKlassPointers::base_disjoint()*/);
 7394 
 7395   format %{ &quot;EXTRDI  $dst, $src, #32, #3 \t// encode with disjoint base&quot; %}
 7396   size(4);
 7397   ins_encode %{
 7398     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 7399     __ rldicl($dst$$Register, $src$$Register, 64-CompressedKlassPointers::shift(), 32);
 7400   %}
 7401   ins_pipe(pipe_class_default);
 7402 %}
 7403 
 7404 // shift != 0, base != 0
 7405 instruct encodePKlass_not_null_Ex(iRegNdst dst, iRegLsrc base, iRegPsrc src) %{
 7406   match(Set dst (EncodePKlass (Binary base src)));
 7407   predicate(false);
 7408 
 7409   format %{ &quot;EncodePKlass $dst, $src\t// $src != Null, postalloc expanded&quot; %}
 7410   postalloc_expand %{
 7411     encodePKlass_sub_baseNode *n1 = new encodePKlass_sub_baseNode();
 7412     n1-&gt;add_req(n_region, n_base, n_src);
 7413     n1-&gt;_opnds[0] = op_dst;
 7414     n1-&gt;_opnds[1] = op_base;
 7415     n1-&gt;_opnds[2] = op_src;
 7416     n1-&gt;_bottom_type = _bottom_type;
 7417 
 7418     encodePKlass_shiftNode *n2 = new encodePKlass_shiftNode();
 7419     n2-&gt;add_req(n_region, n1);
 7420     n2-&gt;_opnds[0] = op_dst;
 7421     n2-&gt;_opnds[1] = op_dst;
 7422     n2-&gt;_bottom_type = _bottom_type;
 7423     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7424     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7425 
 7426     nodes-&gt;push(n1);
 7427     nodes-&gt;push(n2);
 7428   %}
 7429 %}
 7430 
 7431 // shift != 0, base != 0
 7432 instruct encodePKlass_not_null_ExEx(iRegNdst dst, iRegPsrc src) %{
 7433   match(Set dst (EncodePKlass src));
 7434   //predicate(CompressedKlassPointers::shift() != 0 &amp;&amp;
 7435   //          true /* TODO: PPC port CompressedKlassPointers::base_overlaps()*/);
 7436 
 7437   //format %{ &quot;EncodePKlass $dst, $src\t// $src != Null, postalloc expanded&quot; %}
 7438   ins_cost(DEFAULT_COST*2);  // Don&#39;t count constant.
 7439   expand %{
 7440     immL baseImm %{ (jlong)(intptr_t)CompressedKlassPointers::base() %}
 7441     iRegLdst base;
 7442     loadConL_Ex(base, baseImm);
 7443     encodePKlass_not_null_Ex(dst, base, src);
 7444   %}
 7445 %}
 7446 
 7447 // Decode nodes.
 7448 
 7449 // Shift node for expand.
 7450 instruct decodeNKlass_shift(iRegPdst dst, iRegPsrc src) %{
 7451   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7452   match(Set dst (DecodeNKlass src));
 7453   predicate(false);
 7454 
 7455   format %{ &quot;SLDI    $dst, $src, #3 \t// DecodeNKlass&quot; %}
 7456   size(4);
 7457   ins_encode %{
 7458     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
 7459     __ sldi($dst$$Register, $src$$Register, CompressedKlassPointers::shift());
 7460   %}
 7461   ins_pipe(pipe_class_default);
 7462 %}
 7463 
 7464 // Add node for expand.
 7465 
 7466 instruct decodeNKlass_add_base(iRegPdst dst, iRegLsrc base, iRegPdst src) %{
 7467   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7468   match(Set dst (DecodeNKlass (Binary base src)));
 7469   predicate(false);
 7470 
 7471   format %{ &quot;ADD     $dst, $base, $src \t// DecodeNKlass, add klass base&quot; %}
 7472   size(4);
 7473   ins_encode %{
 7474     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 7475     __ add($dst$$Register, $base$$Register, $src$$Register);
 7476   %}
 7477   ins_pipe(pipe_class_default);
 7478 %}
 7479 
 7480 // src != 0, shift != 0, base != 0
 7481 instruct decodeNKlass_notNull_addBase_Ex(iRegPdst dst, iRegLsrc base, iRegNsrc src) %{
 7482   match(Set dst (DecodeNKlass (Binary base src)));
 7483   //effect(kill src); // We need a register for the immediate result after shifting.
 7484   predicate(false);
 7485 
 7486   format %{ &quot;DecodeNKlass $dst =  $base + ($src &lt;&lt; 3) \t// $src != NULL, postalloc expanded&quot; %}
 7487   postalloc_expand %{
 7488     decodeNKlass_add_baseNode *n1 = new decodeNKlass_add_baseNode();
 7489     n1-&gt;add_req(n_region, n_base, n_src);
 7490     n1-&gt;_opnds[0] = op_dst;
 7491     n1-&gt;_opnds[1] = op_base;
 7492     n1-&gt;_opnds[2] = op_src;
 7493     n1-&gt;_bottom_type = _bottom_type;
 7494 
 7495     decodeNKlass_shiftNode *n2 = new decodeNKlass_shiftNode();
 7496     n2-&gt;add_req(n_region, n1);
 7497     n2-&gt;_opnds[0] = op_dst;
 7498     n2-&gt;_opnds[1] = op_dst;
 7499     n2-&gt;_bottom_type = _bottom_type;
 7500 
 7501     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7502     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7503 
 7504     nodes-&gt;push(n1);
 7505     nodes-&gt;push(n2);
 7506   %}
 7507 %}
 7508 
 7509 // src != 0, shift != 0, base != 0
 7510 instruct decodeNKlass_notNull_addBase_ExEx(iRegPdst dst, iRegNsrc src) %{
 7511   match(Set dst (DecodeNKlass src));
 7512   // predicate(CompressedKlassPointers::shift() != 0 &amp;&amp;
 7513   //           CompressedKlassPointers::base() != 0);
 7514 
 7515   //format %{ &quot;DecodeNKlass $dst, $src \t// $src != NULL, expanded&quot; %}
 7516 
 7517   ins_cost(DEFAULT_COST*2);  // Don&#39;t count constant.
 7518   expand %{
 7519     // We add first, then we shift. Like this, we can get along with one register less.
 7520     // But we have to load the base pre-shifted.
 7521     immL baseImm %{ (jlong)((intptr_t)CompressedKlassPointers::base() &gt;&gt; CompressedKlassPointers::shift()) %}
 7522     iRegLdst base;
 7523     loadConL_Ex(base, baseImm);
 7524     decodeNKlass_notNull_addBase_Ex(dst, base, src);
 7525   %}
 7526 %}
 7527 
 7528 //----------MemBar Instructions-----------------------------------------------
 7529 // Memory barrier flavors
 7530 
 7531 instruct membar_acquire() %{
 7532   match(LoadFence);
 7533   ins_cost(4*MEMORY_REF_COST);
 7534 
 7535   format %{ &quot;MEMBAR-acquire&quot; %}
 7536   size(4);
 7537   ins_encode %{
 7538     // TODO: PPC port $archOpcode(ppc64Opcode_lwsync);
 7539     __ acquire();
 7540   %}
 7541   ins_pipe(pipe_class_default);
 7542 %}
 7543 
 7544 instruct unnecessary_membar_acquire() %{
 7545   match(MemBarAcquire);
 7546   ins_cost(0);
 7547 
 7548   format %{ &quot; -- \t// redundant MEMBAR-acquire - empty&quot; %}
 7549   size(0);
 7550   ins_encode( /*empty*/ );
 7551   ins_pipe(pipe_class_default);
 7552 %}
 7553 
 7554 instruct membar_acquire_lock() %{
 7555   match(MemBarAcquireLock);
 7556   ins_cost(0);
 7557 
 7558   format %{ &quot; -- \t// redundant MEMBAR-acquire - empty (acquire as part of CAS in prior FastLock)&quot; %}
 7559   size(0);
 7560   ins_encode( /*empty*/ );
 7561   ins_pipe(pipe_class_default);
 7562 %}
 7563 
 7564 instruct membar_release() %{
 7565   match(MemBarRelease);
 7566   match(StoreFence);
 7567   ins_cost(4*MEMORY_REF_COST);
 7568 
 7569   format %{ &quot;MEMBAR-release&quot; %}
 7570   size(4);
 7571   ins_encode %{
 7572     // TODO: PPC port $archOpcode(ppc64Opcode_lwsync);
 7573     __ release();
 7574   %}
 7575   ins_pipe(pipe_class_default);
 7576 %}
 7577 
 7578 instruct membar_storestore() %{
 7579   match(MemBarStoreStore);
 7580   ins_cost(4*MEMORY_REF_COST);
 7581 
 7582   format %{ &quot;MEMBAR-store-store&quot; %}
 7583   size(4);
 7584   ins_encode %{
 7585     // TODO: PPC port $archOpcode(ppc64Opcode_lwsync);
 7586     __ membar(Assembler::StoreStore);
 7587   %}
 7588   ins_pipe(pipe_class_default);
 7589 %}
 7590 
 7591 instruct membar_release_lock() %{
 7592   match(MemBarReleaseLock);
 7593   ins_cost(0);
 7594 
 7595   format %{ &quot; -- \t// redundant MEMBAR-release - empty (release in FastUnlock)&quot; %}
 7596   size(0);
 7597   ins_encode( /*empty*/ );
 7598   ins_pipe(pipe_class_default);
 7599 %}
 7600 
 7601 instruct membar_volatile() %{
 7602   match(MemBarVolatile);
 7603   ins_cost(4*MEMORY_REF_COST);
 7604 
 7605   format %{ &quot;MEMBAR-volatile&quot; %}
 7606   size(4);
 7607   ins_encode %{
 7608     // TODO: PPC port $archOpcode(ppc64Opcode_sync);
 7609     __ fence();
 7610   %}
 7611   ins_pipe(pipe_class_default);
 7612 %}
 7613 
 7614 // This optimization is wrong on PPC. The following pattern is not supported:
 7615 //  MemBarVolatile
 7616 //   ^        ^
 7617 //   |        |
 7618 //  CtrlProj MemProj
 7619 //   ^        ^
 7620 //   |        |
 7621 //   |       Load
 7622 //   |
 7623 //  MemBarVolatile
 7624 //
 7625 //  The first MemBarVolatile could get optimized out! According to
 7626 //  Vladimir, this pattern can not occur on Oracle platforms.
 7627 //  However, it does occur on PPC64 (because of membars in
 7628 //  inline_unsafe_load_store).
 7629 //
 7630 // Add this node again if we found a good solution for inline_unsafe_load_store().
 7631 // Don&#39;t forget to look at the implementation of post_store_load_barrier again,
 7632 // we did other fixes in that method.
 7633 //instruct unnecessary_membar_volatile() %{
 7634 //  match(MemBarVolatile);
 7635 //  predicate(Matcher::post_store_load_barrier(n));
 7636 //  ins_cost(0);
 7637 //
 7638 //  format %{ &quot; -- \t// redundant MEMBAR-volatile - empty&quot; %}
 7639 //  size(0);
 7640 //  ins_encode( /*empty*/ );
 7641 //  ins_pipe(pipe_class_default);
 7642 //%}
 7643 
 7644 instruct membar_CPUOrder() %{
 7645   match(MemBarCPUOrder);
 7646   ins_cost(0);
 7647 
 7648   format %{ &quot; -- \t// MEMBAR-CPUOrder - empty: PPC64 processors are self-consistent.&quot; %}
 7649   size(0);
 7650   ins_encode( /*empty*/ );
 7651   ins_pipe(pipe_class_default);
 7652 %}
 7653 
 7654 //----------Conditional Move---------------------------------------------------
 7655 
 7656 // Cmove using isel.
 7657 instruct cmovI_reg_isel(cmpOp cmp, flagsRegSrc crx, iRegIdst dst, iRegIsrc src) %{
 7658   match(Set dst (CMoveI (Binary cmp crx) (Binary dst src)));
 7659   predicate(VM_Version::has_isel());
 7660   ins_cost(DEFAULT_COST);
 7661 
 7662   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7663   size(4);
 7664   ins_encode %{
 7665     // This is a Power7 instruction for which no machine description
 7666     // exists. Anyways, the scheduler should be off on Power7.
 7667     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7668     int cc        = $cmp$$cmpcode;
 7669     __ isel($dst$$Register, $crx$$CondRegister,
 7670             (Assembler::Condition)(cc &amp; 3), /*invert*/((~cc) &amp; 8), $src$$Register);
 7671   %}
 7672   ins_pipe(pipe_class_default);
 7673 %}
 7674 
 7675 instruct cmovI_reg(cmpOp cmp, flagsRegSrc crx, iRegIdst dst, iRegIsrc src) %{
 7676   match(Set dst (CMoveI (Binary cmp crx) (Binary dst src)));
 7677   predicate(!VM_Version::has_isel());
 7678   ins_cost(DEFAULT_COST+BRANCH_COST);
 7679 
 7680   ins_variable_size_depending_on_alignment(true);
 7681 
 7682   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7683   // Worst case is branch + move + stop, no stop without scheduler
 7684   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7685   ins_encode( enc_cmove_reg(dst, crx, src, cmp) );
 7686   ins_pipe(pipe_class_default);
 7687 %}
 7688 
 7689 instruct cmovI_imm(cmpOp cmp, flagsRegSrc crx, iRegIdst dst, immI16 src) %{
 7690   match(Set dst (CMoveI (Binary cmp crx) (Binary dst src)));
 7691   ins_cost(DEFAULT_COST+BRANCH_COST);
 7692 
 7693   ins_variable_size_depending_on_alignment(true);
 7694 
 7695   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7696   // Worst case is branch + move + stop, no stop without scheduler
 7697   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7698   ins_encode( enc_cmove_imm(dst, crx, src, cmp) );
 7699   ins_pipe(pipe_class_default);
 7700 %}
 7701 
 7702 // Cmove using isel.
 7703 instruct cmovL_reg_isel(cmpOp cmp, flagsRegSrc crx, iRegLdst dst, iRegLsrc src) %{
 7704   match(Set dst (CMoveL (Binary cmp crx) (Binary dst src)));
 7705   predicate(VM_Version::has_isel());
 7706   ins_cost(DEFAULT_COST);
 7707 
 7708   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7709   size(4);
 7710   ins_encode %{
 7711     // This is a Power7 instruction for which no machine description
 7712     // exists. Anyways, the scheduler should be off on Power7.
 7713     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7714     int cc        = $cmp$$cmpcode;
 7715     __ isel($dst$$Register, $crx$$CondRegister,
 7716             (Assembler::Condition)(cc &amp; 3), /*invert*/((~cc) &amp; 8), $src$$Register);
 7717   %}
 7718   ins_pipe(pipe_class_default);
 7719 %}
 7720 
 7721 instruct cmovL_reg(cmpOp cmp, flagsRegSrc crx, iRegLdst dst, iRegLsrc src) %{
 7722   match(Set dst (CMoveL (Binary cmp crx) (Binary dst src)));
 7723   predicate(!VM_Version::has_isel());
 7724   ins_cost(DEFAULT_COST+BRANCH_COST);
 7725 
 7726   ins_variable_size_depending_on_alignment(true);
 7727 
 7728   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7729   // Worst case is branch + move + stop, no stop without scheduler.
 7730   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7731   ins_encode( enc_cmove_reg(dst, crx, src, cmp) );
 7732   ins_pipe(pipe_class_default);
 7733 %}
 7734 
 7735 instruct cmovL_imm(cmpOp cmp, flagsRegSrc crx, iRegLdst dst, immL16 src) %{
 7736   match(Set dst (CMoveL (Binary cmp crx) (Binary dst src)));
 7737   ins_cost(DEFAULT_COST+BRANCH_COST);
 7738 
 7739   ins_variable_size_depending_on_alignment(true);
 7740 
 7741   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7742   // Worst case is branch + move + stop, no stop without scheduler.
 7743   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7744   ins_encode( enc_cmove_imm(dst, crx, src, cmp) );
 7745   ins_pipe(pipe_class_default);
 7746 %}
 7747 
 7748 // Cmove using isel.
 7749 instruct cmovN_reg_isel(cmpOp cmp, flagsRegSrc crx, iRegNdst dst, iRegNsrc src) %{
 7750   match(Set dst (CMoveN (Binary cmp crx) (Binary dst src)));
 7751   predicate(VM_Version::has_isel());
 7752   ins_cost(DEFAULT_COST);
 7753 
 7754   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7755   size(4);
 7756   ins_encode %{
 7757     // This is a Power7 instruction for which no machine description
 7758     // exists. Anyways, the scheduler should be off on Power7.
 7759     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7760     int cc        = $cmp$$cmpcode;
 7761     __ isel($dst$$Register, $crx$$CondRegister,
 7762             (Assembler::Condition)(cc &amp; 3), /*invert*/((~cc) &amp; 8), $src$$Register);
 7763   %}
 7764   ins_pipe(pipe_class_default);
 7765 %}
 7766 
 7767 // Conditional move for RegN. Only cmov(reg, reg).
 7768 instruct cmovN_reg(cmpOp cmp, flagsRegSrc crx, iRegNdst dst, iRegNsrc src) %{
 7769   match(Set dst (CMoveN (Binary cmp crx) (Binary dst src)));
 7770   predicate(!VM_Version::has_isel());
 7771   ins_cost(DEFAULT_COST+BRANCH_COST);
 7772 
 7773   ins_variable_size_depending_on_alignment(true);
 7774 
 7775   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7776   // Worst case is branch + move + stop, no stop without scheduler.
 7777   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7778   ins_encode( enc_cmove_reg(dst, crx, src, cmp) );
 7779   ins_pipe(pipe_class_default);
 7780 %}
 7781 
 7782 instruct cmovN_imm(cmpOp cmp, flagsRegSrc crx, iRegNdst dst, immN_0 src) %{
 7783   match(Set dst (CMoveN (Binary cmp crx) (Binary dst src)));
 7784   ins_cost(DEFAULT_COST+BRANCH_COST);
 7785 
 7786   ins_variable_size_depending_on_alignment(true);
 7787 
 7788   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7789   // Worst case is branch + move + stop, no stop without scheduler.
 7790   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7791   ins_encode( enc_cmove_imm(dst, crx, src, cmp) );
 7792   ins_pipe(pipe_class_default);
 7793 %}
 7794 
 7795 // Cmove using isel.
 7796 instruct cmovP_reg_isel(cmpOp cmp, flagsRegSrc crx, iRegPdst dst, iRegPsrc src) %{
 7797   match(Set dst (CMoveP (Binary cmp crx) (Binary dst src)));
 7798   predicate(VM_Version::has_isel());
 7799   ins_cost(DEFAULT_COST);
 7800 
 7801   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7802   size(4);
 7803   ins_encode %{
 7804     // This is a Power7 instruction for which no machine description
 7805     // exists. Anyways, the scheduler should be off on Power7.
 7806     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7807     int cc        = $cmp$$cmpcode;
 7808     __ isel($dst$$Register, $crx$$CondRegister,
 7809             (Assembler::Condition)(cc &amp; 3), /*invert*/((~cc) &amp; 8), $src$$Register);
 7810   %}
 7811   ins_pipe(pipe_class_default);
 7812 %}
 7813 
 7814 instruct cmovP_reg(cmpOp cmp, flagsRegSrc crx, iRegPdst dst, iRegP_N2P src) %{
 7815   match(Set dst (CMoveP (Binary cmp crx) (Binary dst src)));
 7816   predicate(!VM_Version::has_isel());
 7817   ins_cost(DEFAULT_COST+BRANCH_COST);
 7818 
 7819   ins_variable_size_depending_on_alignment(true);
 7820 
 7821   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7822   // Worst case is branch + move + stop, no stop without scheduler.
 7823   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7824   ins_encode( enc_cmove_reg(dst, crx, src, cmp) );
 7825   ins_pipe(pipe_class_default);
 7826 %}
 7827 
 7828 instruct cmovP_imm(cmpOp cmp, flagsRegSrc crx, iRegPdst dst, immP_0 src) %{
 7829   match(Set dst (CMoveP (Binary cmp crx) (Binary dst src)));
 7830   ins_cost(DEFAULT_COST+BRANCH_COST);
 7831 
 7832   ins_variable_size_depending_on_alignment(true);
 7833 
 7834   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7835   // Worst case is branch + move + stop, no stop without scheduler.
 7836   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7837   ins_encode( enc_cmove_imm(dst, crx, src, cmp) );
 7838   ins_pipe(pipe_class_default);
 7839 %}
 7840 
 7841 instruct cmovF_reg(cmpOp cmp, flagsRegSrc crx, regF dst, regF src) %{
 7842   match(Set dst (CMoveF (Binary cmp crx) (Binary dst src)));
 7843   ins_cost(DEFAULT_COST+BRANCH_COST);
 7844 
 7845   ins_variable_size_depending_on_alignment(true);
 7846 
 7847   format %{ &quot;CMOVEF  $cmp, $crx, $dst, $src\n\t&quot; %}
 7848   // Worst case is branch + move + stop, no stop without scheduler.
 7849   size((false /* TODO: PPC PORT (InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8));
 7850   ins_encode %{
 7851     // TODO: PPC port $archOpcode(ppc64Opcode_cmovef);
 7852     Label done;
 7853     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, &quot;check encoding&quot;);
 7854     // Branch if not (cmp crx).
 7855     __ bc(cc_to_inverse_boint($cmp$$cmpcode), cc_to_biint($cmp$$cmpcode, $crx$$reg), done);
 7856     __ fmr($dst$$FloatRegister, $src$$FloatRegister);
 7857     // TODO PPC port __ endgroup_if_needed(_size == 12);
 7858     __ bind(done);
 7859   %}
 7860   ins_pipe(pipe_class_default);
 7861 %}
 7862 
 7863 instruct cmovD_reg(cmpOp cmp, flagsRegSrc crx, regD dst, regD src) %{
 7864   match(Set dst (CMoveD (Binary cmp crx) (Binary dst src)));
 7865   ins_cost(DEFAULT_COST+BRANCH_COST);
 7866 
 7867   ins_variable_size_depending_on_alignment(true);
 7868 
 7869   format %{ &quot;CMOVEF  $cmp, $crx, $dst, $src\n\t&quot; %}
 7870   // Worst case is branch + move + stop, no stop without scheduler.
 7871   size((false /* TODO: PPC PORT (InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8));
 7872   ins_encode %{
 7873     // TODO: PPC port $archOpcode(ppc64Opcode_cmovef);
 7874     Label done;
 7875     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, &quot;check encoding&quot;);
 7876     // Branch if not (cmp crx).
 7877     __ bc(cc_to_inverse_boint($cmp$$cmpcode), cc_to_biint($cmp$$cmpcode, $crx$$reg), done);
 7878     __ fmr($dst$$FloatRegister, $src$$FloatRegister);
 7879     // TODO PPC port __ endgroup_if_needed(_size == 12);
 7880     __ bind(done);
 7881   %}
 7882   ins_pipe(pipe_class_default);
 7883 %}
 7884 
 7885 //----------Conditional_store--------------------------------------------------
 7886 // Conditional-store of the updated heap-top.
 7887 // Used during allocation of the shared heap.
 7888 // Sets flags (EQ) on success. Implemented with a CASA on Sparc.
 7889 
 7890 // As compareAndSwapL, but return flag register instead of boolean value in
 7891 // int register.
 7892 // Used by sun/misc/AtomicLongCSImpl.java.
 7893 // Mem_ptr must be a memory operand, else this node does not get
 7894 // Flag_needs_anti_dependence_check set by adlc. If this is not set this node
 7895 // can be rematerialized which leads to errors.
 7896 instruct storeLConditional_regP_regL_regL(flagsReg crx, indirect mem_ptr, iRegLsrc oldVal, iRegLsrc newVal, flagsRegCR0 cr0) %{
 7897   match(Set crx (StoreLConditional mem_ptr (Binary oldVal newVal)));
 7898   effect(TEMP cr0);
 7899   format %{ &quot;CMPXCHGD if ($crx = ($oldVal == *$mem_ptr)) *mem_ptr = $newVal; as bool&quot; %}
 7900   ins_encode %{
 7901     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7902     __ cmpxchgd($crx$$CondRegister, R0, $oldVal$$Register, $newVal$$Register, $mem_ptr$$Register,
 7903                 MacroAssembler::MemBarAcq, MacroAssembler::cmpxchgx_hint_atomic_update(),
 7904                 noreg, NULL, true);
 7905   %}
 7906   ins_pipe(pipe_class_default);
 7907 %}
 7908 
 7909 // As compareAndSwapP, but return flag register instead of boolean value in
 7910 // int register.
 7911 // This instruction is matched if UseTLAB is off.
 7912 // Mem_ptr must be a memory operand, else this node does not get
 7913 // Flag_needs_anti_dependence_check set by adlc. If this is not set this node
 7914 // can be rematerialized which leads to errors.
 7915 instruct storePConditional_regP_regP_regP(flagsRegCR0 cr0, indirect mem_ptr, iRegPsrc oldVal, iRegPsrc newVal) %{
 7916   match(Set cr0 (StorePConditional mem_ptr (Binary oldVal newVal)));
 7917   ins_cost(2*MEMORY_REF_COST);
 7918 
 7919   format %{ &quot;STDCX_  if ($cr0 = ($oldVal == *$mem_ptr)) *mem_ptr = $newVal; as bool&quot; %}
 7920   ins_encode %{
 7921     // TODO: PPC port $archOpcode(ppc64Opcode_stdcx_);
 7922     __ stdcx_($newVal$$Register, $mem_ptr$$Register);
 7923   %}
 7924   ins_pipe(pipe_class_memory);
 7925 %}
 7926 
 7927 // Implement LoadPLocked. Must be ordered against changes of the memory location
 7928 // by storePConditional.
 7929 // Don&#39;t know whether this is ever used.
 7930 instruct loadPLocked(iRegPdst dst, memory mem) %{
 7931   match(Set dst (LoadPLocked mem));
 7932   ins_cost(2*MEMORY_REF_COST);
 7933 
 7934   format %{ &quot;LDARX   $dst, $mem \t// loadPLocked\n\t&quot; %}
 7935   size(4);
 7936   ins_encode %{
 7937     // TODO: PPC port $archOpcode(ppc64Opcode_ldarx);
 7938     __ ldarx($dst$$Register, $mem$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
 7939   %}
 7940   ins_pipe(pipe_class_memory);
 7941 %}
 7942 
 7943 //----------Compare-And-Swap---------------------------------------------------
 7944 
 7945 // CompareAndSwap{P,I,L} have more than one output, therefore &quot;CmpI
 7946 // (CompareAndSwap ...)&quot; or &quot;If (CmpI (CompareAndSwap ..))&quot;  cannot be
 7947 // matched.
 7948 
 7949 // Strong versions:
 7950 
 7951 instruct compareAndSwapB_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 7952   match(Set res (CompareAndSwapB mem_ptr (Binary src1 src2)));
 7953   predicate(VM_Version::has_lqarx());
 7954   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 7955   format %{ &quot;CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 7956   ins_encode %{
 7957     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7958     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 7959     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 7960                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 7961                 $res$$Register, true);
 7962     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 7963       __ isync();
 7964     } else {
 7965       __ sync();
 7966     }
 7967   %}
 7968   ins_pipe(pipe_class_default);
 7969 %}
 7970 
 7971 instruct compareAndSwapB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
 7972   match(Set res (CompareAndSwapB mem_ptr (Binary src1 src2)));
 7973   predicate(!VM_Version::has_lqarx());
 7974   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
 7975   format %{ &quot;CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 7976   ins_encode %{
 7977     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7978     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 7979     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
 7980                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 7981                 $res$$Register, true);
 7982     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 7983       __ isync();
 7984     } else {
 7985       __ sync();
 7986     }
 7987   %}
 7988   ins_pipe(pipe_class_default);
 7989 %}
 7990 
 7991 instruct compareAndSwapS_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 7992   match(Set res (CompareAndSwapS mem_ptr (Binary src1 src2)));
 7993   predicate(VM_Version::has_lqarx());
 7994   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 7995   format %{ &quot;CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 7996   ins_encode %{
 7997     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7998     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 7999     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8000                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8001                 $res$$Register, true);
 8002     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8003       __ isync();
 8004     } else {
 8005       __ sync();
 8006     }
 8007   %}
 8008   ins_pipe(pipe_class_default);
 8009 %}
 8010 
 8011 instruct compareAndSwapS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
 8012   match(Set res (CompareAndSwapS mem_ptr (Binary src1 src2)));
 8013   predicate(!VM_Version::has_lqarx());
 8014   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
 8015   format %{ &quot;CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8016   ins_encode %{
 8017     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8018     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8019     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
 8020                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8021                 $res$$Register, true);
 8022     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8023       __ isync();
 8024     } else {
 8025       __ sync();
 8026     }
 8027   %}
 8028   ins_pipe(pipe_class_default);
 8029 %}
 8030 
 8031 instruct compareAndSwapI_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8032   match(Set res (CompareAndSwapI mem_ptr (Binary src1 src2)));
 8033   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8034   format %{ &quot;CMPXCHGW $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8035   ins_encode %{
 8036     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8037     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8038     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8039                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8040                 $res$$Register, true);
 8041     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8042       __ isync();
 8043     } else {
 8044       __ sync();
 8045     }
 8046   %}
 8047   ins_pipe(pipe_class_default);
 8048 %}
 8049 
 8050 instruct compareAndSwapN_regP_regN_regN(iRegIdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
 8051   match(Set res (CompareAndSwapN mem_ptr (Binary src1 src2)));
 8052   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8053   format %{ &quot;CMPXCHGW $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8054   ins_encode %{
 8055     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8056     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8057     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8058                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8059                 $res$$Register, true);
 8060     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8061       __ isync();
 8062     } else {
 8063       __ sync();
 8064     }
 8065   %}
 8066   ins_pipe(pipe_class_default);
 8067 %}
 8068 
 8069 instruct compareAndSwapL_regP_regL_regL(iRegIdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
 8070   match(Set res (CompareAndSwapL mem_ptr (Binary src1 src2)));
 8071   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8072   format %{ &quot;CMPXCHGD $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8073   ins_encode %{
 8074     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8075     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8076     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8077                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8078                 $res$$Register, NULL, true);
 8079     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8080       __ isync();
 8081     } else {
 8082       __ sync();
 8083     }
 8084   %}
 8085   ins_pipe(pipe_class_default);
 8086 %}
 8087 
 8088 instruct compareAndSwapP_regP_regP_regP(iRegIdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
 8089   match(Set res (CompareAndSwapP mem_ptr (Binary src1 src2)));
 8090   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8091   format %{ &quot;CMPXCHGD $res, $mem_ptr, $src1, $src2; as bool; ptr&quot; %}
 8092   ins_encode %{
 8093     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8094     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8095     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8096                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8097                 $res$$Register, NULL, true);
 8098     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8099       __ isync();
 8100     } else {
 8101       __ sync();
 8102     }
 8103   %}
 8104   ins_pipe(pipe_class_default);
 8105 %}
 8106 
 8107 // Weak versions:
 8108 
 8109 instruct weakCompareAndSwapB_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8110   match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));
 8111   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; VM_Version::has_lqarx());
 8112   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8113   format %{ &quot;weak CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8114   ins_encode %{
 8115     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8116     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8117     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8118                 MacroAssembler::MemBarNone,
 8119                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8120   %}
 8121   ins_pipe(pipe_class_default);
 8122 %}
 8123 
 8124 instruct weakCompareAndSwapB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
 8125   match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));
 8126   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; !VM_Version::has_lqarx());
 8127   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
 8128   format %{ &quot;weak CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8129   ins_encode %{
 8130     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8131     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8132     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
 8133                 MacroAssembler::MemBarNone,
 8134                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8135   %}
 8136   ins_pipe(pipe_class_default);
 8137 %}
 8138 
 8139 instruct weakCompareAndSwapB_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8140   match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));
 8141   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; VM_Version::has_lqarx());
 8142   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8143   format %{ &quot;weak CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8144   ins_encode %{
 8145     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8146     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8147     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8148                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8149                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8150   %}
 8151   ins_pipe(pipe_class_default);
 8152 %}
 8153 
 8154 instruct weakCompareAndSwapB4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
 8155   match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));
 8156   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; !VM_Version::has_lqarx());
 8157   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
 8158   format %{ &quot;weak CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8159   ins_encode %{
 8160     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8161     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8162     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
 8163                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8164                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8165   %}
 8166   ins_pipe(pipe_class_default);
 8167 %}
 8168 
 8169 instruct weakCompareAndSwapS_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8170   match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));
 8171   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; VM_Version::has_lqarx());
 8172   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8173   format %{ &quot;weak CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8174   ins_encode %{
 8175     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8176     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8177     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8178                 MacroAssembler::MemBarNone,
 8179                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8180   %}
 8181   ins_pipe(pipe_class_default);
 8182 %}
 8183 
 8184 instruct weakCompareAndSwapS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
 8185   match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));
 8186   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; !VM_Version::has_lqarx());
 8187   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
 8188   format %{ &quot;weak CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8189   ins_encode %{
 8190     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8191     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8192     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
 8193                 MacroAssembler::MemBarNone,
 8194                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8195   %}
 8196   ins_pipe(pipe_class_default);
 8197 %}
 8198 
 8199 instruct weakCompareAndSwapS_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8200   match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));
 8201   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; VM_Version::has_lqarx());
 8202   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8203   format %{ &quot;weak CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8204   ins_encode %{
 8205     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8206     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8207     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8208                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8209                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8210   %}
 8211   ins_pipe(pipe_class_default);
 8212 %}
 8213 
 8214 instruct weakCompareAndSwapS4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
 8215   match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));
 8216   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; !VM_Version::has_lqarx());
 8217   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
 8218   format %{ &quot;weak CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8219   ins_encode %{
 8220     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8221     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8222     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
 8223                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8224                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8225   %}
 8226   ins_pipe(pipe_class_default);
 8227 %}
 8228 
 8229 instruct weakCompareAndSwapI_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8230   match(Set res (WeakCompareAndSwapI mem_ptr (Binary src1 src2)));
 8231   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8232   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8233   format %{ &quot;weak CMPXCHGW $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8234   ins_encode %{
 8235     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8236     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8237     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8238                 MacroAssembler::MemBarNone,
 8239                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8240   %}
 8241   ins_pipe(pipe_class_default);
 8242 %}
 8243 
 8244 instruct weakCompareAndSwapI_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8245   match(Set res (WeakCompareAndSwapI mem_ptr (Binary src1 src2)));
 8246   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8247   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8248   format %{ &quot;weak CMPXCHGW acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8249   ins_encode %{
 8250     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8251     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8252     // Acquire only needed in successful case. Weak node is allowed to report unsuccessful in additional rare cases and
 8253     // value is never passed to caller.
 8254     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8255                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8256                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8257   %}
 8258   ins_pipe(pipe_class_default);
 8259 %}
 8260 
 8261 instruct weakCompareAndSwapN_regP_regN_regN(iRegIdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
 8262   match(Set res (WeakCompareAndSwapN mem_ptr (Binary src1 src2)));
 8263   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8264   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8265   format %{ &quot;weak CMPXCHGW $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8266   ins_encode %{
 8267     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8268     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8269     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8270                 MacroAssembler::MemBarNone,
 8271                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8272   %}
 8273   ins_pipe(pipe_class_default);
 8274 %}
 8275 
 8276 instruct weakCompareAndSwapN_acq_regP_regN_regN(iRegIdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
 8277   match(Set res (WeakCompareAndSwapN mem_ptr (Binary src1 src2)));
 8278   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8279   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8280   format %{ &quot;weak CMPXCHGW acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8281   ins_encode %{
 8282     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8283     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8284     // Acquire only needed in successful case. Weak node is allowed to report unsuccessful in additional rare cases and
 8285     // value is never passed to caller.
 8286     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8287                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8288                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8289   %}
 8290   ins_pipe(pipe_class_default);
 8291 %}
 8292 
 8293 instruct weakCompareAndSwapL_regP_regL_regL(iRegIdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
 8294   match(Set res (WeakCompareAndSwapL mem_ptr (Binary src1 src2)));
 8295   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8296   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8297   format %{ &quot;weak CMPXCHGD $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8298   ins_encode %{
 8299     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8300     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8301     // value is never passed to caller.
 8302     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8303                 MacroAssembler::MemBarNone,
 8304                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, NULL, true, /*weak*/ true);
 8305   %}
 8306   ins_pipe(pipe_class_default);
 8307 %}
 8308 
 8309 instruct weakCompareAndSwapL_acq_regP_regL_regL(iRegIdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
 8310   match(Set res (WeakCompareAndSwapL mem_ptr (Binary src1 src2)));
 8311   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8312   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8313   format %{ &quot;weak CMPXCHGD acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8314   ins_encode %{
 8315     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8316     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8317     // Acquire only needed in successful case. Weak node is allowed to report unsuccessful in additional rare cases and
 8318     // value is never passed to caller.
 8319     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8320                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8321                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, NULL, true, /*weak*/ true);
 8322   %}
 8323   ins_pipe(pipe_class_default);
 8324 %}
 8325 
 8326 instruct weakCompareAndSwapP_regP_regP_regP(iRegIdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
 8327   match(Set res (WeakCompareAndSwapP mem_ptr (Binary src1 src2)));
 8328   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8329   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8330   format %{ &quot;weak CMPXCHGD $res, $mem_ptr, $src1, $src2; as bool; ptr&quot; %}
 8331   ins_encode %{
 8332     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8333     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8334     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8335                 MacroAssembler::MemBarNone,
 8336                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, NULL, true, /*weak*/ true);
 8337   %}
 8338   ins_pipe(pipe_class_default);
 8339 %}
 8340 
 8341 instruct weakCompareAndSwapP_acq_regP_regP_regP(iRegIdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
 8342   match(Set res (WeakCompareAndSwapP mem_ptr (Binary src1 src2)));
 8343   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8344   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8345   format %{ &quot;weak CMPXCHGD acq $res, $mem_ptr, $src1, $src2; as bool; ptr&quot; %}
 8346   ins_encode %{
 8347     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8348     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8349     // Acquire only needed in successful case. Weak node is allowed to report unsuccessful in additional rare cases and
 8350     // value is never passed to caller.
 8351     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8352                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8353                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, NULL, true, /*weak*/ true);
 8354   %}
 8355   ins_pipe(pipe_class_default);
 8356 %}
 8357 
 8358 // CompareAndExchange
 8359 
 8360 instruct compareAndExchangeB_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8361   match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));
 8362   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; VM_Version::has_lqarx());
 8363   effect(TEMP_DEF res, TEMP cr0);
 8364   format %{ &quot;CMPXCHGB $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8365   ins_encode %{
 8366     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8367     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8368     __ cmpxchgb(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8369                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8370                 noreg, true);
 8371   %}
 8372   ins_pipe(pipe_class_default);
 8373 %}
 8374 
 8375 instruct compareAndExchangeB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{
 8376   match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));
 8377   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; !VM_Version::has_lqarx());
 8378   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);
 8379   format %{ &quot;CMPXCHGB $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8380   ins_encode %{
 8381     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8382     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8383     __ cmpxchgb(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,
 8384                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8385                 noreg, true);
 8386   %}
 8387   ins_pipe(pipe_class_default);
 8388 %}
 8389 
 8390 instruct compareAndExchangeB_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8391   match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));
 8392   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; VM_Version::has_lqarx());
 8393   effect(TEMP_DEF res, TEMP cr0);
 8394   format %{ &quot;CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8395   ins_encode %{
 8396     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8397     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8398     __ cmpxchgb(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8399                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8400                 noreg, true);
 8401     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8402       __ isync();
 8403     } else {
 8404       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8405       __ sync();
 8406     }
 8407   %}
 8408   ins_pipe(pipe_class_default);
 8409 %}
 8410 
 8411 instruct compareAndExchangeB4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{
 8412   match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));
 8413   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; !VM_Version::has_lqarx());
 8414   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);
 8415   format %{ &quot;CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8416   ins_encode %{
 8417     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8418     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8419     __ cmpxchgb(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,
 8420                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8421                 noreg, true);
 8422     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8423       __ isync();
 8424     } else {
 8425       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8426       __ sync();
 8427     }
 8428   %}
 8429   ins_pipe(pipe_class_default);
 8430 %}
 8431 
 8432 instruct compareAndExchangeS_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8433   match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));
 8434   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; VM_Version::has_lqarx());
 8435   effect(TEMP_DEF res, TEMP cr0);
 8436   format %{ &quot;CMPXCHGH $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8437   ins_encode %{
 8438     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8439     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8440     __ cmpxchgh(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8441                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8442                 noreg, true);
 8443   %}
 8444   ins_pipe(pipe_class_default);
 8445 %}
 8446 
 8447 instruct compareAndExchangeS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{
 8448   match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));
 8449   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; !VM_Version::has_lqarx());
 8450   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);
 8451   format %{ &quot;CMPXCHGH $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8452   ins_encode %{
 8453     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8454     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8455     __ cmpxchgh(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,
 8456                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8457                 noreg, true);
 8458   %}
 8459   ins_pipe(pipe_class_default);
 8460 %}
 8461 
 8462 instruct compareAndExchangeS_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8463   match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));
 8464   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; VM_Version::has_lqarx());
 8465   effect(TEMP_DEF res, TEMP cr0);
 8466   format %{ &quot;CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8467   ins_encode %{
 8468     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8469     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8470     __ cmpxchgh(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8471                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8472                 noreg, true);
 8473     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8474       __ isync();
 8475     } else {
 8476       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8477       __ sync();
 8478     }
 8479   %}
 8480   ins_pipe(pipe_class_default);
 8481 %}
 8482 
 8483 instruct compareAndExchangeS4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{
 8484   match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));
 8485   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; !VM_Version::has_lqarx());
 8486   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);
 8487   format %{ &quot;CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8488   ins_encode %{
 8489     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8490     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8491     __ cmpxchgh(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,
 8492                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8493                 noreg, true);
 8494     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8495       __ isync();
 8496     } else {
 8497       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8498       __ sync();
 8499     }
 8500   %}
 8501   ins_pipe(pipe_class_default);
 8502 %}
 8503 
 8504 instruct compareAndExchangeI_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8505   match(Set res (CompareAndExchangeI mem_ptr (Binary src1 src2)));
 8506   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8507   effect(TEMP_DEF res, TEMP cr0);
 8508   format %{ &quot;CMPXCHGW $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8509   ins_encode %{
 8510     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8511     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8512     __ cmpxchgw(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8513                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8514                 noreg, true);
 8515   %}
 8516   ins_pipe(pipe_class_default);
 8517 %}
 8518 
 8519 instruct compareAndExchangeI_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8520   match(Set res (CompareAndExchangeI mem_ptr (Binary src1 src2)));
 8521   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8522   effect(TEMP_DEF res, TEMP cr0);
 8523   format %{ &quot;CMPXCHGW acq $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8524   ins_encode %{
 8525     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8526     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8527     __ cmpxchgw(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8528                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8529                 noreg, true);
 8530     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8531       __ isync();
 8532     } else {
 8533       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8534       __ sync();
 8535     }
 8536   %}
 8537   ins_pipe(pipe_class_default);
 8538 %}
 8539 
 8540 instruct compareAndExchangeN_regP_regN_regN(iRegNdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
 8541   match(Set res (CompareAndExchangeN mem_ptr (Binary src1 src2)));
 8542   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8543   effect(TEMP_DEF res, TEMP cr0);
 8544   format %{ &quot;CMPXCHGW $res, $mem_ptr, $src1, $src2; as narrow oop&quot; %}
 8545   ins_encode %{
 8546     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8547     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8548     __ cmpxchgw(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8549                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8550                 noreg, true);
 8551   %}
 8552   ins_pipe(pipe_class_default);
 8553 %}
 8554 
 8555 instruct compareAndExchangeN_acq_regP_regN_regN(iRegNdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
 8556   match(Set res (CompareAndExchangeN mem_ptr (Binary src1 src2)));
 8557   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8558   effect(TEMP_DEF res, TEMP cr0);
 8559   format %{ &quot;CMPXCHGW acq $res, $mem_ptr, $src1, $src2; as narrow oop&quot; %}
 8560   ins_encode %{
 8561     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8562     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8563     __ cmpxchgw(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8564                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8565                 noreg, true);
 8566     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8567       __ isync();
 8568     } else {
 8569       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8570       __ sync();
 8571     }
 8572   %}
 8573   ins_pipe(pipe_class_default);
 8574 %}
 8575 
 8576 instruct compareAndExchangeL_regP_regL_regL(iRegLdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
 8577   match(Set res (CompareAndExchangeL mem_ptr (Binary src1 src2)));
 8578   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8579   effect(TEMP_DEF res, TEMP cr0);
 8580   format %{ &quot;CMPXCHGD $res, $mem_ptr, $src1, $src2; as long&quot; %}
 8581   ins_encode %{
 8582     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8583     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8584     __ cmpxchgd(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8585                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8586                 noreg, NULL, true);
 8587   %}
 8588   ins_pipe(pipe_class_default);
 8589 %}
 8590 
 8591 instruct compareAndExchangeL_acq_regP_regL_regL(iRegLdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
 8592   match(Set res (CompareAndExchangeL mem_ptr (Binary src1 src2)));
 8593   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8594   effect(TEMP_DEF res, TEMP cr0);
 8595   format %{ &quot;CMPXCHGD acq $res, $mem_ptr, $src1, $src2; as long&quot; %}
 8596   ins_encode %{
 8597     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8598     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8599     __ cmpxchgd(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8600                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8601                 noreg, NULL, true);
 8602     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8603       __ isync();
 8604     } else {
 8605       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8606       __ sync();
 8607     }
 8608   %}
 8609   ins_pipe(pipe_class_default);
 8610 %}
 8611 
 8612 instruct compareAndExchangeP_regP_regP_regP(iRegPdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
 8613   match(Set res (CompareAndExchangeP mem_ptr (Binary src1 src2)));
 8614   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8615   effect(TEMP_DEF res, TEMP cr0);
 8616   format %{ &quot;CMPXCHGD $res, $mem_ptr, $src1, $src2; as ptr; ptr&quot; %}
 8617   ins_encode %{
 8618     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8619     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8620     __ cmpxchgd(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8621                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8622                 noreg, NULL, true);
 8623   %}
 8624   ins_pipe(pipe_class_default);
 8625 %}
 8626 
 8627 instruct compareAndExchangeP_acq_regP_regP_regP(iRegPdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
 8628   match(Set res (CompareAndExchangeP mem_ptr (Binary src1 src2)));
 8629   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8630   effect(TEMP_DEF res, TEMP cr0);
 8631   format %{ &quot;CMPXCHGD acq $res, $mem_ptr, $src1, $src2; as ptr; ptr&quot; %}
 8632   ins_encode %{
 8633     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8634     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8635     __ cmpxchgd(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8636                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8637                 noreg, NULL, true);
 8638     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8639       __ isync();
 8640     } else {
 8641       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8642       __ sync();
 8643     }
 8644   %}
 8645   ins_pipe(pipe_class_default);
 8646 %}
 8647 
 8648 // Special RMW
 8649 
 8650 instruct getAndAddB(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
 8651   match(Set res (GetAndAddB mem_ptr src));
 8652   predicate(VM_Version::has_lqarx());
 8653   effect(TEMP_DEF res, TEMP cr0);
 8654   format %{ &quot;GetAndAddB $res, $mem_ptr, $src&quot; %}
 8655   ins_encode %{
 8656     __ getandaddb($res$$Register, $src$$Register, $mem_ptr$$Register,
 8657                   R0, noreg, noreg, MacroAssembler::cmpxchgx_hint_atomic_update());
 8658     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8659       __ isync();
 8660     } else {
 8661       __ sync();
 8662     }
 8663   %}
 8664   ins_pipe(pipe_class_default);
 8665 %}
 8666 
 8667 instruct getAndAddB4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{
 8668   match(Set res (GetAndAddB mem_ptr src));
 8669   predicate(!VM_Version::has_lqarx());
 8670   effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);
 8671   format %{ &quot;GetAndAddB $res, $mem_ptr, $src&quot; %}
 8672   ins_encode %{
 8673     __ getandaddb($res$$Register, $src$$Register, $mem_ptr$$Register,
 8674                   R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
 8675     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8676       __ isync();
 8677     } else {
 8678       __ sync();
 8679     }
 8680   %}
 8681   ins_pipe(pipe_class_default);
 8682 %}
 8683 
 8684 instruct getAndAddS(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
 8685   match(Set res (GetAndAddS mem_ptr src));
 8686   predicate(VM_Version::has_lqarx());
 8687   effect(TEMP_DEF res, TEMP cr0);
 8688   format %{ &quot;GetAndAddS $res, $mem_ptr, $src&quot; %}
 8689   ins_encode %{
 8690     __ getandaddh($res$$Register, $src$$Register, $mem_ptr$$Register,
 8691                   R0, noreg, noreg, MacroAssembler::cmpxchgx_hint_atomic_update());
 8692     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8693       __ isync();
 8694     } else {
 8695       __ sync();
 8696     }
 8697   %}
 8698   ins_pipe(pipe_class_default);
 8699 %}
 8700 
 8701 instruct getAndAddS4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{
 8702   match(Set res (GetAndAddS mem_ptr src));
 8703   predicate(!VM_Version::has_lqarx());
 8704   effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);
 8705   format %{ &quot;GetAndAddS $res, $mem_ptr, $src&quot; %}
 8706   ins_encode %{
 8707     __ getandaddh($res$$Register, $src$$Register, $mem_ptr$$Register,
 8708                   R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
 8709     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8710       __ isync();
 8711     } else {
 8712       __ sync();
 8713     }
 8714   %}
 8715   ins_pipe(pipe_class_default);
 8716 %}
 8717 
 8718 instruct getAndAddI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
 8719   match(Set res (GetAndAddI mem_ptr src));
 8720   effect(TEMP_DEF res, TEMP cr0);
 8721   format %{ &quot;GetAndAddI $res, $mem_ptr, $src&quot; %}
 8722   ins_encode %{
 8723     __ getandaddw($res$$Register, $src$$Register, $mem_ptr$$Register,
 8724                   R0, MacroAssembler::cmpxchgx_hint_atomic_update());
 8725     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8726       __ isync();
 8727     } else {
 8728       __ sync();
 8729     }
 8730   %}
 8731   ins_pipe(pipe_class_default);
 8732 %}
 8733 
 8734 instruct getAndAddL(iRegLdst res, iRegPdst mem_ptr, iRegLsrc src, flagsRegCR0 cr0) %{
 8735   match(Set res (GetAndAddL mem_ptr src));
 8736   effect(TEMP_DEF res, TEMP cr0);
 8737   format %{ &quot;GetAndAddL $res, $mem_ptr, $src&quot; %}
 8738   ins_encode %{
 8739     __ getandaddd($res$$Register, $src$$Register, $mem_ptr$$Register,
 8740                   R0, MacroAssembler::cmpxchgx_hint_atomic_update());
 8741     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8742       __ isync();
 8743     } else {
 8744       __ sync();
 8745     }
 8746   %}
 8747   ins_pipe(pipe_class_default);
 8748 %}
 8749 
 8750 instruct getAndSetB(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
 8751   match(Set res (GetAndSetB mem_ptr src));
 8752   predicate(VM_Version::has_lqarx());
 8753   effect(TEMP_DEF res, TEMP cr0);
 8754   format %{ &quot;GetAndSetB $res, $mem_ptr, $src&quot; %}
 8755   ins_encode %{
 8756     __ getandsetb($res$$Register, $src$$Register, $mem_ptr$$Register,
 8757                   noreg, noreg, noreg, MacroAssembler::cmpxchgx_hint_atomic_update());
 8758     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8759       __ isync();
 8760     } else {
 8761       __ sync();
 8762     }
 8763   %}
 8764   ins_pipe(pipe_class_default);
 8765 %}
 8766 
 8767 instruct getAndSetB4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{
 8768   match(Set res (GetAndSetB mem_ptr src));
 8769   predicate(!VM_Version::has_lqarx());
 8770   effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);
 8771   format %{ &quot;GetAndSetB $res, $mem_ptr, $src&quot; %}
 8772   ins_encode %{
 8773     __ getandsetb($res$$Register, $src$$Register, $mem_ptr$$Register,
 8774                   R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
 8775     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8776       __ isync();
 8777     } else {
 8778       __ sync();
 8779     }
 8780   %}
 8781   ins_pipe(pipe_class_default);
 8782 %}
 8783 
 8784 instruct getAndSetS(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
 8785   match(Set res (GetAndSetS mem_ptr src));
 8786   predicate(VM_Version::has_lqarx());
 8787   effect(TEMP_DEF res, TEMP cr0);
 8788   format %{ &quot;GetAndSetS $res, $mem_ptr, $src&quot; %}
 8789   ins_encode %{
 8790     __ getandseth($res$$Register, $src$$Register, $mem_ptr$$Register,
 8791                   noreg, noreg, noreg, MacroAssembler::cmpxchgx_hint_atomic_update());
 8792     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8793       __ isync();
 8794     } else {
 8795       __ sync();
 8796     }
 8797   %}
 8798   ins_pipe(pipe_class_default);
 8799 %}
 8800 
 8801 instruct getAndSetS4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{
 8802   match(Set res (GetAndSetS mem_ptr src));
 8803   predicate(!VM_Version::has_lqarx());
 8804   effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);
 8805   format %{ &quot;GetAndSetS $res, $mem_ptr, $src&quot; %}
 8806   ins_encode %{
 8807     __ getandseth($res$$Register, $src$$Register, $mem_ptr$$Register,
 8808                   R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
 8809     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8810       __ isync();
 8811     } else {
 8812       __ sync();
 8813     }
 8814   %}
 8815   ins_pipe(pipe_class_default);
 8816 %}
 8817 
 8818 instruct getAndSetI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
 8819   match(Set res (GetAndSetI mem_ptr src));
 8820   effect(TEMP_DEF res, TEMP cr0);
 8821   format %{ &quot;GetAndSetI $res, $mem_ptr, $src&quot; %}
 8822   ins_encode %{
 8823     __ getandsetw($res$$Register, $src$$Register, $mem_ptr$$Register,
 8824                   MacroAssembler::cmpxchgx_hint_atomic_update());
 8825     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8826       __ isync();
 8827     } else {
 8828       __ sync();
 8829     }
 8830   %}
 8831   ins_pipe(pipe_class_default);
 8832 %}
 8833 
 8834 instruct getAndSetL(iRegLdst res, iRegPdst mem_ptr, iRegLsrc src, flagsRegCR0 cr0) %{
 8835   match(Set res (GetAndSetL mem_ptr src));
 8836   effect(TEMP_DEF res, TEMP cr0);
 8837   format %{ &quot;GetAndSetL $res, $mem_ptr, $src&quot; %}
 8838   ins_encode %{
 8839     __ getandsetd($res$$Register, $src$$Register, $mem_ptr$$Register,
 8840                   MacroAssembler::cmpxchgx_hint_atomic_update());
 8841     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8842       __ isync();
 8843     } else {
 8844       __ sync();
 8845     }
 8846   %}
 8847   ins_pipe(pipe_class_default);
 8848 %}
 8849 
 8850 instruct getAndSetP(iRegPdst res, iRegPdst mem_ptr, iRegPsrc src, flagsRegCR0 cr0) %{
 8851   match(Set res (GetAndSetP mem_ptr src));
 8852   effect(TEMP_DEF res, TEMP cr0);
 8853   format %{ &quot;GetAndSetP $res, $mem_ptr, $src&quot; %}
 8854   ins_encode %{
 8855     __ getandsetd($res$$Register, $src$$Register, $mem_ptr$$Register,
 8856                   MacroAssembler::cmpxchgx_hint_atomic_update());
 8857     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8858       __ isync();
 8859     } else {
 8860       __ sync();
 8861     }
 8862   %}
 8863   ins_pipe(pipe_class_default);
 8864 %}
 8865 
 8866 instruct getAndSetN(iRegNdst res, iRegPdst mem_ptr, iRegNsrc src, flagsRegCR0 cr0) %{
 8867   match(Set res (GetAndSetN mem_ptr src));
 8868   effect(TEMP_DEF res, TEMP cr0);
 8869   format %{ &quot;GetAndSetN $res, $mem_ptr, $src&quot; %}
 8870   ins_encode %{
 8871     __ getandsetw($res$$Register, $src$$Register, $mem_ptr$$Register,
 8872                   MacroAssembler::cmpxchgx_hint_atomic_update());
 8873     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8874       __ isync();
 8875     } else {
 8876       __ sync();
 8877     }
 8878   %}
 8879   ins_pipe(pipe_class_default);
 8880 %}
 8881 
 8882 //----------Arithmetic Instructions--------------------------------------------
 8883 // Addition Instructions
 8884 
 8885 // Register Addition
 8886 instruct addI_reg_reg(iRegIdst dst, iRegIsrc_iRegL2Isrc src1, iRegIsrc_iRegL2Isrc src2) %{
 8887   match(Set dst (AddI src1 src2));
 8888   format %{ &quot;ADD     $dst, $src1, $src2&quot; %}
 8889   size(4);
 8890   ins_encode %{
 8891     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 8892     __ add($dst$$Register, $src1$$Register, $src2$$Register);
 8893   %}
 8894   ins_pipe(pipe_class_default);
 8895 %}
 8896 
 8897 // Expand does not work with above instruct. (??)
 8898 instruct addI_reg_reg_2(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 8899   // no match-rule
 8900   effect(DEF dst, USE src1, USE src2);
 8901   format %{ &quot;ADD     $dst, $src1, $src2&quot; %}
 8902   size(4);
 8903   ins_encode %{
 8904     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 8905     __ add($dst$$Register, $src1$$Register, $src2$$Register);
 8906   %}
 8907   ins_pipe(pipe_class_default);
 8908 %}
 8909 
 8910 instruct tree_addI_addI_addI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, iRegIsrc src3, iRegIsrc src4) %{
 8911   match(Set dst (AddI (AddI (AddI src1 src2) src3) src4));
 8912   ins_cost(DEFAULT_COST*3);
 8913 
 8914   expand %{
 8915     // FIXME: we should do this in the ideal world.
 8916     iRegIdst tmp1;
 8917     iRegIdst tmp2;
 8918     addI_reg_reg(tmp1, src1, src2);
 8919     addI_reg_reg_2(tmp2, src3, src4); // Adlc complains about addI_reg_reg.
 8920     addI_reg_reg(dst, tmp1, tmp2);
 8921   %}
 8922 %}
 8923 
 8924 // Immediate Addition
 8925 instruct addI_reg_imm16(iRegIdst dst, iRegIsrc src1, immI16 src2) %{
 8926   match(Set dst (AddI src1 src2));
 8927   format %{ &quot;ADDI    $dst, $src1, $src2&quot; %}
 8928   size(4);
 8929   ins_encode %{
 8930     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 8931     __ addi($dst$$Register, $src1$$Register, $src2$$constant);
 8932   %}
 8933   ins_pipe(pipe_class_default);
 8934 %}
 8935 
 8936 // Immediate Addition with 16-bit shifted operand
 8937 instruct addI_reg_immhi16(iRegIdst dst, iRegIsrc src1, immIhi16 src2) %{
 8938   match(Set dst (AddI src1 src2));
 8939   format %{ &quot;ADDIS   $dst, $src1, $src2&quot; %}
 8940   size(4);
 8941   ins_encode %{
 8942     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 8943     __ addis($dst$$Register, $src1$$Register, ($src2$$constant)&gt;&gt;16);
 8944   %}
 8945   ins_pipe(pipe_class_default);
 8946 %}
 8947 
 8948 // Long Addition
 8949 instruct addL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 8950   match(Set dst (AddL src1 src2));
 8951   format %{ &quot;ADD     $dst, $src1, $src2 \t// long&quot; %}
 8952   size(4);
 8953   ins_encode %{
 8954     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 8955     __ add($dst$$Register, $src1$$Register, $src2$$Register);
 8956   %}
 8957   ins_pipe(pipe_class_default);
 8958 %}
 8959 
 8960 // Expand does not work with above instruct. (??)
 8961 instruct addL_reg_reg_2(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 8962   // no match-rule
 8963   effect(DEF dst, USE src1, USE src2);
 8964   format %{ &quot;ADD     $dst, $src1, $src2 \t// long&quot; %}
 8965   size(4);
 8966   ins_encode %{
 8967     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 8968     __ add($dst$$Register, $src1$$Register, $src2$$Register);
 8969   %}
 8970   ins_pipe(pipe_class_default);
 8971 %}
 8972 
 8973 instruct tree_addL_addL_addL_reg_reg_Ex(iRegLdst dst, iRegLsrc src1, iRegLsrc src2, iRegLsrc src3, iRegLsrc src4) %{
 8974   match(Set dst (AddL (AddL (AddL src1 src2) src3) src4));
 8975   ins_cost(DEFAULT_COST*3);
 8976 
 8977   expand %{
 8978     // FIXME: we should do this in the ideal world.
 8979     iRegLdst tmp1;
 8980     iRegLdst tmp2;
 8981     addL_reg_reg(tmp1, src1, src2);
 8982     addL_reg_reg_2(tmp2, src3, src4); // Adlc complains about orI_reg_reg.
 8983     addL_reg_reg(dst, tmp1, tmp2);
 8984   %}
 8985 %}
 8986 
 8987 // AddL + ConvL2I.
 8988 instruct addI_regL_regL(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
 8989   match(Set dst (ConvL2I (AddL src1 src2)));
 8990 
 8991   format %{ &quot;ADD     $dst, $src1, $src2 \t// long + l2i&quot; %}
 8992   size(4);
 8993   ins_encode %{
 8994     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 8995     __ add($dst$$Register, $src1$$Register, $src2$$Register);
 8996   %}
 8997   ins_pipe(pipe_class_default);
 8998 %}
 8999 
 9000 // No constant pool entries required.
 9001 instruct addL_reg_imm16(iRegLdst dst, iRegLsrc src1, immL16 src2) %{
 9002   match(Set dst (AddL src1 src2));
 9003 
 9004   format %{ &quot;ADDI    $dst, $src1, $src2&quot; %}
 9005   size(4);
 9006   ins_encode %{
 9007     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 9008     __ addi($dst$$Register, $src1$$Register, $src2$$constant);
 9009   %}
 9010   ins_pipe(pipe_class_default);
 9011 %}
 9012 
 9013 // Long Immediate Addition with 16-bit shifted operand.
 9014 // No constant pool entries required.
 9015 instruct addL_reg_immhi16(iRegLdst dst, iRegLsrc src1, immL32hi16 src2) %{
 9016   match(Set dst (AddL src1 src2));
 9017 
 9018   format %{ &quot;ADDIS   $dst, $src1, $src2&quot; %}
 9019   size(4);
 9020   ins_encode %{
 9021     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 9022     __ addis($dst$$Register, $src1$$Register, ($src2$$constant)&gt;&gt;16);
 9023   %}
 9024   ins_pipe(pipe_class_default);
 9025 %}
 9026 
 9027 // Pointer Register Addition
 9028 instruct addP_reg_reg(iRegPdst dst, iRegP_N2P src1, iRegLsrc src2) %{
 9029   match(Set dst (AddP src1 src2));
 9030   format %{ &quot;ADD     $dst, $src1, $src2&quot; %}
 9031   size(4);
 9032   ins_encode %{
 9033     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 9034     __ add($dst$$Register, $src1$$Register, $src2$$Register);
 9035   %}
 9036   ins_pipe(pipe_class_default);
 9037 %}
 9038 
 9039 // Pointer Immediate Addition
 9040 // No constant pool entries required.
 9041 instruct addP_reg_imm16(iRegPdst dst, iRegP_N2P src1, immL16 src2) %{
 9042   match(Set dst (AddP src1 src2));
 9043 
 9044   format %{ &quot;ADDI    $dst, $src1, $src2&quot; %}
 9045   size(4);
 9046   ins_encode %{
 9047     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 9048     __ addi($dst$$Register, $src1$$Register, $src2$$constant);
 9049   %}
 9050   ins_pipe(pipe_class_default);
 9051 %}
 9052 
 9053 // Pointer Immediate Addition with 16-bit shifted operand.
 9054 // No constant pool entries required.
 9055 instruct addP_reg_immhi16(iRegPdst dst, iRegP_N2P src1, immL32hi16 src2) %{
 9056   match(Set dst (AddP src1 src2));
 9057 
 9058   format %{ &quot;ADDIS   $dst, $src1, $src2&quot; %}
 9059   size(4);
 9060   ins_encode %{
 9061     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 9062     __ addis($dst$$Register, $src1$$Register, ($src2$$constant)&gt;&gt;16);
 9063   %}
 9064   ins_pipe(pipe_class_default);
 9065 %}
 9066 
 9067 //---------------------
 9068 // Subtraction Instructions
 9069 
 9070 // Register Subtraction
 9071 instruct subI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9072   match(Set dst (SubI src1 src2));
 9073   format %{ &quot;SUBF    $dst, $src2, $src1&quot; %}
 9074   size(4);
 9075   ins_encode %{
 9076     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
 9077     __ subf($dst$$Register, $src2$$Register, $src1$$Register);
 9078   %}
 9079   ins_pipe(pipe_class_default);
 9080 %}
 9081 
 9082 // Immediate Subtraction
 9083 // Immediate Subtraction: The compiler converts &quot;x-c0&quot; into &quot;x+ -c0&quot; (see SubLNode::Ideal),
 9084 // Don&#39;t try to use addi with - $src2$$constant since it can overflow when $src2$$constant == minI16.
 9085 
 9086 // SubI from constant (using subfic).
 9087 instruct subI_imm16_reg(iRegIdst dst, immI16 src1, iRegIsrc src2) %{
 9088   match(Set dst (SubI src1 src2));
 9089   format %{ &quot;SUBI    $dst, $src1, $src2&quot; %}
 9090 
 9091   size(4);
 9092   ins_encode %{
 9093     // TODO: PPC port $archOpcode(ppc64Opcode_subfic);
 9094     __ subfic($dst$$Register, $src2$$Register, $src1$$constant);
 9095   %}
 9096   ins_pipe(pipe_class_default);
 9097 %}
 9098 
 9099 // Turn the sign-bit of an integer into a 32-bit mask, 0x0...0 for
 9100 // positive integers and 0xF...F for negative ones.
 9101 instruct signmask32I_regI(iRegIdst dst, iRegIsrc src) %{
 9102   // no match-rule, false predicate
 9103   effect(DEF dst, USE src);
 9104   predicate(false);
 9105 
 9106   format %{ &quot;SRAWI   $dst, $src, #31&quot; %}
 9107   size(4);
 9108   ins_encode %{
 9109     // TODO: PPC port $archOpcode(ppc64Opcode_srawi);
 9110     __ srawi($dst$$Register, $src$$Register, 0x1f);
 9111   %}
 9112   ins_pipe(pipe_class_default);
 9113 %}
 9114 
 9115 instruct absI_reg_Ex(iRegIdst dst, iRegIsrc src) %{
 9116   match(Set dst (AbsI src));
 9117   ins_cost(DEFAULT_COST*3);
 9118 
 9119   expand %{
 9120     iRegIdst tmp1;
 9121     iRegIdst tmp2;
 9122     signmask32I_regI(tmp1, src);
 9123     xorI_reg_reg(tmp2, tmp1, src);
 9124     subI_reg_reg(dst, tmp2, tmp1);
 9125   %}
 9126 %}
 9127 
 9128 instruct negI_regI(iRegIdst dst, immI_0 zero, iRegIsrc src2) %{
 9129   match(Set dst (SubI zero src2));
 9130   format %{ &quot;NEG     $dst, $src2&quot; %}
 9131   size(4);
 9132   ins_encode %{
 9133     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
 9134     __ neg($dst$$Register, $src2$$Register);
 9135   %}
 9136   ins_pipe(pipe_class_default);
 9137 %}
 9138 
 9139 // Long subtraction
 9140 instruct subL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9141   match(Set dst (SubL src1 src2));
 9142   format %{ &quot;SUBF    $dst, $src2, $src1 \t// long&quot; %}
 9143   size(4);
 9144   ins_encode %{
 9145     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
 9146     __ subf($dst$$Register, $src2$$Register, $src1$$Register);
 9147   %}
 9148   ins_pipe(pipe_class_default);
 9149 %}
 9150 
 9151 // SubL + convL2I.
 9152 instruct subI_regL_regL(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9153   match(Set dst (ConvL2I (SubL src1 src2)));
 9154 
 9155   format %{ &quot;SUBF    $dst, $src2, $src1 \t// long + l2i&quot; %}
 9156   size(4);
 9157   ins_encode %{
 9158     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
 9159     __ subf($dst$$Register, $src2$$Register, $src1$$Register);
 9160   %}
 9161   ins_pipe(pipe_class_default);
 9162 %}
 9163 
 9164 // Turn the sign-bit of a long into a 64-bit mask, 0x0...0 for
 9165 // positive longs and 0xF...F for negative ones.
 9166 instruct signmask64I_regL(iRegIdst dst, iRegLsrc src) %{
 9167   // no match-rule, false predicate
 9168   effect(DEF dst, USE src);
 9169   predicate(false);
 9170 
 9171   format %{ &quot;SRADI   $dst, $src, #63&quot; %}
 9172   size(4);
 9173   ins_encode %{
 9174     // TODO: PPC port $archOpcode(ppc64Opcode_sradi);
 9175     __ sradi($dst$$Register, $src$$Register, 0x3f);
 9176   %}
 9177   ins_pipe(pipe_class_default);
 9178 %}
 9179 
 9180 // Turn the sign-bit of a long into a 64-bit mask, 0x0...0 for
 9181 // positive longs and 0xF...F for negative ones.
 9182 instruct signmask64L_regL(iRegLdst dst, iRegLsrc src) %{
 9183   // no match-rule, false predicate
 9184   effect(DEF dst, USE src);
 9185   predicate(false);
 9186 
 9187   format %{ &quot;SRADI   $dst, $src, #63&quot; %}
 9188   size(4);
 9189   ins_encode %{
 9190     // TODO: PPC port $archOpcode(ppc64Opcode_sradi);
 9191     __ sradi($dst$$Register, $src$$Register, 0x3f);
 9192   %}
 9193   ins_pipe(pipe_class_default);
 9194 %}
 9195 
 9196 // Long negation
 9197 instruct negL_reg_reg(iRegLdst dst, immL_0 zero, iRegLsrc src2) %{
 9198   match(Set dst (SubL zero src2));
 9199   format %{ &quot;NEG     $dst, $src2 \t// long&quot; %}
 9200   size(4);
 9201   ins_encode %{
 9202     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
 9203     __ neg($dst$$Register, $src2$$Register);
 9204   %}
 9205   ins_pipe(pipe_class_default);
 9206 %}
 9207 
 9208 // NegL + ConvL2I.
 9209 instruct negI_con0_regL(iRegIdst dst, immL_0 zero, iRegLsrc src2) %{
 9210   match(Set dst (ConvL2I (SubL zero src2)));
 9211 
 9212   format %{ &quot;NEG     $dst, $src2 \t// long + l2i&quot; %}
 9213   size(4);
 9214   ins_encode %{
 9215     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
 9216     __ neg($dst$$Register, $src2$$Register);
 9217   %}
 9218   ins_pipe(pipe_class_default);
 9219 %}
 9220 
 9221 // Multiplication Instructions
 9222 // Integer Multiplication
 9223 
 9224 // Register Multiplication
 9225 instruct mulI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9226   match(Set dst (MulI src1 src2));
 9227   ins_cost(DEFAULT_COST);
 9228 
 9229   format %{ &quot;MULLW   $dst, $src1, $src2&quot; %}
 9230   size(4);
 9231   ins_encode %{
 9232     // TODO: PPC port $archOpcode(ppc64Opcode_mullw);
 9233     __ mullw($dst$$Register, $src1$$Register, $src2$$Register);
 9234   %}
 9235   ins_pipe(pipe_class_default);
 9236 %}
 9237 
 9238 // Immediate Multiplication
 9239 instruct mulI_reg_imm16(iRegIdst dst, iRegIsrc src1, immI16 src2) %{
 9240   match(Set dst (MulI src1 src2));
 9241   ins_cost(DEFAULT_COST);
 9242 
 9243   format %{ &quot;MULLI   $dst, $src1, $src2&quot; %}
 9244   size(4);
 9245   ins_encode %{
 9246     // TODO: PPC port $archOpcode(ppc64Opcode_mulli);
 9247     __ mulli($dst$$Register, $src1$$Register, $src2$$constant);
 9248   %}
 9249   ins_pipe(pipe_class_default);
 9250 %}
 9251 
 9252 instruct mulL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9253   match(Set dst (MulL src1 src2));
 9254   ins_cost(DEFAULT_COST);
 9255 
 9256   format %{ &quot;MULLD   $dst $src1, $src2 \t// long&quot; %}
 9257   size(4);
 9258   ins_encode %{
 9259     // TODO: PPC port $archOpcode(ppc64Opcode_mulld);
 9260     __ mulld($dst$$Register, $src1$$Register, $src2$$Register);
 9261   %}
 9262   ins_pipe(pipe_class_default);
 9263 %}
 9264 
 9265 // Multiply high for optimized long division by constant.
 9266 instruct mulHighL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9267   match(Set dst (MulHiL src1 src2));
 9268   ins_cost(DEFAULT_COST);
 9269 
 9270   format %{ &quot;MULHD   $dst $src1, $src2 \t// long&quot; %}
 9271   size(4);
 9272   ins_encode %{
 9273     // TODO: PPC port $archOpcode(ppc64Opcode_mulhd);
 9274     __ mulhd($dst$$Register, $src1$$Register, $src2$$Register);
 9275   %}
 9276   ins_pipe(pipe_class_default);
 9277 %}
 9278 
 9279 // Immediate Multiplication
 9280 instruct mulL_reg_imm16(iRegLdst dst, iRegLsrc src1, immL16 src2) %{
 9281   match(Set dst (MulL src1 src2));
 9282   ins_cost(DEFAULT_COST);
 9283 
 9284   format %{ &quot;MULLI   $dst, $src1, $src2&quot; %}
 9285   size(4);
 9286   ins_encode %{
 9287     // TODO: PPC port $archOpcode(ppc64Opcode_mulli);
 9288     __ mulli($dst$$Register, $src1$$Register, $src2$$constant);
 9289   %}
 9290   ins_pipe(pipe_class_default);
 9291 %}
 9292 
 9293 // Integer Division with Immediate -1: Negate.
 9294 instruct divI_reg_immIvalueMinus1(iRegIdst dst, iRegIsrc src1, immI_minus1 src2) %{
 9295   match(Set dst (DivI src1 src2));
 9296   ins_cost(DEFAULT_COST);
 9297 
 9298   format %{ &quot;NEG     $dst, $src1 \t// /-1&quot; %}
 9299   size(4);
 9300   ins_encode %{
 9301     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
 9302     __ neg($dst$$Register, $src1$$Register);
 9303   %}
 9304   ins_pipe(pipe_class_default);
 9305 %}
 9306 
 9307 // Integer Division with constant, but not -1.
 9308 // We should be able to improve this by checking the type of src2.
 9309 // It might well be that src2 is known to be positive.
 9310 instruct divI_reg_regnotMinus1(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9311   match(Set dst (DivI src1 src2));
 9312   predicate(n-&gt;in(2)-&gt;find_int_con(-1) != -1); // src2 is a constant, but not -1
 9313   ins_cost(2*DEFAULT_COST);
 9314 
 9315   format %{ &quot;DIVW    $dst, $src1, $src2 \t// /not-1&quot; %}
 9316   size(4);
 9317   ins_encode %{
 9318     // TODO: PPC port $archOpcode(ppc64Opcode_divw);
 9319     __ divw($dst$$Register, $src1$$Register, $src2$$Register);
 9320   %}
 9321   ins_pipe(pipe_class_default);
 9322 %}
 9323 
 9324 instruct cmovI_bne_negI_reg(iRegIdst dst, flagsRegSrc crx, iRegIsrc src1) %{
 9325   effect(USE_DEF dst, USE src1, USE crx);
 9326   predicate(false);
 9327 
 9328   ins_variable_size_depending_on_alignment(true);
 9329 
 9330   format %{ &quot;CMOVE   $dst, neg($src1), $crx&quot; %}
 9331   // Worst case is branch + move + stop, no stop without scheduler.
 9332   size((false /* TODO: PPC PORT (InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8));
 9333   ins_encode %{
 9334     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
 9335     Label done;
 9336     __ bne($crx$$CondRegister, done);
 9337     __ neg($dst$$Register, $src1$$Register);
 9338     // TODO PPC port __ endgroup_if_needed(_size == 12);
 9339     __ bind(done);
 9340   %}
 9341   ins_pipe(pipe_class_default);
 9342 %}
 9343 
 9344 // Integer Division with Registers not containing constants.
 9345 instruct divI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9346   match(Set dst (DivI src1 src2));
 9347   ins_cost(10*DEFAULT_COST);
 9348 
 9349   expand %{
 9350     immI16 imm %{ (int)-1 %}
 9351     flagsReg tmp1;
 9352     cmpI_reg_imm16(tmp1, src2, imm);          // check src2 == -1
 9353     divI_reg_regnotMinus1(dst, src1, src2);   // dst = src1 / src2
 9354     cmovI_bne_negI_reg(dst, tmp1, src1);      // cmove dst = neg(src1) if src2 == -1
 9355   %}
 9356 %}
 9357 
 9358 // Long Division with Immediate -1: Negate.
 9359 instruct divL_reg_immLvalueMinus1(iRegLdst dst, iRegLsrc src1, immL_minus1 src2) %{
 9360   match(Set dst (DivL src1 src2));
 9361   ins_cost(DEFAULT_COST);
 9362 
 9363   format %{ &quot;NEG     $dst, $src1 \t// /-1, long&quot; %}
 9364   size(4);
 9365   ins_encode %{
 9366     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
 9367     __ neg($dst$$Register, $src1$$Register);
 9368   %}
 9369   ins_pipe(pipe_class_default);
 9370 %}
 9371 
 9372 // Long Division with constant, but not -1.
 9373 instruct divL_reg_regnotMinus1(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9374   match(Set dst (DivL src1 src2));
 9375   predicate(n-&gt;in(2)-&gt;find_long_con(-1L) != -1L); // Src2 is a constant, but not -1.
 9376   ins_cost(2*DEFAULT_COST);
 9377 
 9378   format %{ &quot;DIVD    $dst, $src1, $src2 \t// /not-1, long&quot; %}
 9379   size(4);
 9380   ins_encode %{
 9381     // TODO: PPC port $archOpcode(ppc64Opcode_divd);
 9382     __ divd($dst$$Register, $src1$$Register, $src2$$Register);
 9383   %}
 9384   ins_pipe(pipe_class_default);
 9385 %}
 9386 
 9387 instruct cmovL_bne_negL_reg(iRegLdst dst, flagsRegSrc crx, iRegLsrc src1) %{
 9388   effect(USE_DEF dst, USE src1, USE crx);
 9389   predicate(false);
 9390 
 9391   ins_variable_size_depending_on_alignment(true);
 9392 
 9393   format %{ &quot;CMOVE   $dst, neg($src1), $crx&quot; %}
 9394   // Worst case is branch + move + stop, no stop without scheduler.
 9395   size((false /* TODO: PPC PORT (InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8));
 9396   ins_encode %{
 9397     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
 9398     Label done;
 9399     __ bne($crx$$CondRegister, done);
 9400     __ neg($dst$$Register, $src1$$Register);
 9401     // TODO PPC port __ endgroup_if_needed(_size == 12);
 9402     __ bind(done);
 9403   %}
 9404   ins_pipe(pipe_class_default);
 9405 %}
 9406 
 9407 // Long Division with Registers not containing constants.
 9408 instruct divL_reg_reg_Ex(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9409   match(Set dst (DivL src1 src2));
 9410   ins_cost(10*DEFAULT_COST);
 9411 
 9412   expand %{
 9413     immL16 imm %{ (int)-1 %}
 9414     flagsReg tmp1;
 9415     cmpL_reg_imm16(tmp1, src2, imm);          // check src2 == -1
 9416     divL_reg_regnotMinus1(dst, src1, src2);   // dst = src1 / src2
 9417     cmovL_bne_negL_reg(dst, tmp1, src1);      // cmove dst = neg(src1) if src2 == -1
 9418   %}
 9419 %}
 9420 
 9421 // Integer Remainder with registers.
 9422 instruct modI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9423   match(Set dst (ModI src1 src2));
 9424   ins_cost(10*DEFAULT_COST);
 9425 
 9426   expand %{
 9427     immI16 imm %{ (int)-1 %}
 9428     flagsReg tmp1;
 9429     iRegIdst tmp2;
 9430     iRegIdst tmp3;
 9431     cmpI_reg_imm16(tmp1, src2, imm);           // check src2 == -1
 9432     divI_reg_regnotMinus1(tmp2, src1, src2);   // tmp2 = src1 / src2
 9433     cmovI_bne_negI_reg(tmp2, tmp1, src1);      // cmove tmp2 = neg(src1) if src2 == -1
 9434     mulI_reg_reg(tmp3, src2, tmp2);            // tmp3 = src2 * tmp2
 9435     subI_reg_reg(dst, src1, tmp3);             // dst = src1 - tmp3
 9436   %}
 9437 %}
 9438 
 9439 // Long Remainder with registers
 9440 instruct modL_reg_reg_Ex(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9441   match(Set dst (ModL src1 src2));
 9442   ins_cost(10*DEFAULT_COST);
 9443 
 9444   expand %{
 9445     immL16 imm %{ (int)-1 %}
 9446     flagsReg tmp1;
 9447     iRegLdst tmp2;
 9448     iRegLdst tmp3;
 9449     cmpL_reg_imm16(tmp1, src2, imm);             // check src2 == -1
 9450     divL_reg_regnotMinus1(tmp2, src1, src2);     // tmp2 = src1 / src2
 9451     cmovL_bne_negL_reg(tmp2, tmp1, src1);        // cmove tmp2 = neg(src1) if src2 == -1
 9452     mulL_reg_reg(tmp3, src2, tmp2);              // tmp3 = src2 * tmp2
 9453     subL_reg_reg(dst, src1, tmp3);               // dst = src1 - tmp3
 9454   %}
 9455 %}
 9456 
 9457 // Integer Shift Instructions
 9458 
 9459 // Register Shift Left
 9460 
 9461 // Clear all but the lowest #mask bits.
 9462 // Used to normalize shift amounts in registers.
 9463 instruct maskI_reg_imm(iRegIdst dst, iRegIsrc src, uimmI6 mask) %{
 9464   // no match-rule, false predicate
 9465   effect(DEF dst, USE src, USE mask);
 9466   predicate(false);
 9467 
 9468   format %{ &quot;MASK    $dst, $src, $mask \t// clear $mask upper bits&quot; %}
 9469   size(4);
 9470   ins_encode %{
 9471     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 9472     __ clrldi($dst$$Register, $src$$Register, $mask$$constant);
 9473   %}
 9474   ins_pipe(pipe_class_default);
 9475 %}
 9476 
 9477 instruct lShiftI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9478   // no match-rule, false predicate
 9479   effect(DEF dst, USE src1, USE src2);
 9480   predicate(false);
 9481 
 9482   format %{ &quot;SLW     $dst, $src1, $src2&quot; %}
 9483   size(4);
 9484   ins_encode %{
 9485     // TODO: PPC port $archOpcode(ppc64Opcode_slw);
 9486     __ slw($dst$$Register, $src1$$Register, $src2$$Register);
 9487   %}
 9488   ins_pipe(pipe_class_default);
 9489 %}
 9490 
 9491 instruct lShiftI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9492   match(Set dst (LShiftI src1 src2));
 9493   ins_cost(DEFAULT_COST*2);
 9494   expand %{
 9495     uimmI6 mask %{ 0x3b /* clear 59 bits, keep 5 */ %}
 9496     iRegIdst tmpI;
 9497     maskI_reg_imm(tmpI, src2, mask);
 9498     lShiftI_reg_reg(dst, src1, tmpI);
 9499   %}
 9500 %}
 9501 
 9502 // Register Shift Left Immediate
 9503 instruct lShiftI_reg_imm(iRegIdst dst, iRegIsrc src1, immI src2) %{
 9504   match(Set dst (LShiftI src1 src2));
 9505 
 9506   format %{ &quot;SLWI    $dst, $src1, ($src2 &amp; 0x1f)&quot; %}
 9507   size(4);
 9508   ins_encode %{
 9509     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
 9510     __ slwi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x1f);
 9511   %}
 9512   ins_pipe(pipe_class_default);
 9513 %}
 9514 
 9515 // AndI with negpow2-constant + LShiftI
 9516 instruct lShiftI_andI_immInegpow2_imm5(iRegIdst dst, iRegIsrc src1, immInegpow2 src2, uimmI5 src3) %{
 9517   match(Set dst (LShiftI (AndI src1 src2) src3));
 9518   predicate(UseRotateAndMaskInstructionsPPC64);
 9519 
 9520   format %{ &quot;RLWINM  $dst, lShiftI(AndI($src1, $src2), $src3)&quot; %}
 9521   size(4);
 9522   ins_encode %{
 9523     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm); // FIXME: assert that rlwinm is equal to addi
 9524     long src2      = $src2$$constant;
 9525     long src3      = $src3$$constant;
 9526     long maskbits  = src3 + log2_long((jlong) (julong) (juint) -src2);
 9527     if (maskbits &gt;= 32) {
 9528       __ li($dst$$Register, 0); // addi
 9529     } else {
 9530       __ rlwinm($dst$$Register, $src1$$Register, src3 &amp; 0x1f, 0, (31-maskbits) &amp; 0x1f);
 9531     }
 9532   %}
 9533   ins_pipe(pipe_class_default);
 9534 %}
 9535 
 9536 // RShiftI + AndI with negpow2-constant + LShiftI
 9537 instruct lShiftI_andI_immInegpow2_rShiftI_imm5(iRegIdst dst, iRegIsrc src1, immInegpow2 src2, uimmI5 src3) %{
 9538   match(Set dst (LShiftI (AndI (RShiftI src1 src3) src2) src3));
 9539   predicate(UseRotateAndMaskInstructionsPPC64);
 9540 
 9541   format %{ &quot;RLWINM  $dst, lShiftI(AndI(RShiftI($src1, $src3), $src2), $src3)&quot; %}
 9542   size(4);
 9543   ins_encode %{
 9544     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm); // FIXME: assert that rlwinm is equal to addi
 9545     long src2      = $src2$$constant;
 9546     long src3      = $src3$$constant;
 9547     long maskbits  = src3 + log2_long((jlong) (julong) (juint) -src2);
 9548     if (maskbits &gt;= 32) {
 9549       __ li($dst$$Register, 0); // addi
 9550     } else {
 9551       __ rlwinm($dst$$Register, $src1$$Register, 0, 0, (31-maskbits) &amp; 0x1f);
 9552     }
 9553   %}
 9554   ins_pipe(pipe_class_default);
 9555 %}
 9556 
 9557 instruct lShiftL_regL_regI(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
 9558   // no match-rule, false predicate
 9559   effect(DEF dst, USE src1, USE src2);
 9560   predicate(false);
 9561 
 9562   format %{ &quot;SLD     $dst, $src1, $src2&quot; %}
 9563   size(4);
 9564   ins_encode %{
 9565     // TODO: PPC port $archOpcode(ppc64Opcode_sld);
 9566     __ sld($dst$$Register, $src1$$Register, $src2$$Register);
 9567   %}
 9568   ins_pipe(pipe_class_default);
 9569 %}
 9570 
 9571 // Register Shift Left
 9572 instruct lShiftL_regL_regI_Ex(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
 9573   match(Set dst (LShiftL src1 src2));
 9574   ins_cost(DEFAULT_COST*2);
 9575   expand %{
 9576     uimmI6 mask %{ 0x3a /* clear 58 bits, keep 6 */ %}
 9577     iRegIdst tmpI;
 9578     maskI_reg_imm(tmpI, src2, mask);
 9579     lShiftL_regL_regI(dst, src1, tmpI);
 9580   %}
 9581 %}
 9582 
 9583 // Register Shift Left Immediate
 9584 instruct lshiftL_regL_immI(iRegLdst dst, iRegLsrc src1, immI src2) %{
 9585   match(Set dst (LShiftL src1 src2));
 9586   format %{ &quot;SLDI    $dst, $src1, ($src2 &amp; 0x3f)&quot; %}
 9587   size(4);
 9588   ins_encode %{
 9589     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
 9590     __ sldi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9591   %}
 9592   ins_pipe(pipe_class_default);
 9593 %}
 9594 
 9595 // If we shift more than 32 bits, we need not convert I2L.
 9596 instruct lShiftL_regI_immGE32(iRegLdst dst, iRegIsrc src1, uimmI6_ge32 src2) %{
 9597   match(Set dst (LShiftL (ConvI2L src1) src2));
 9598   ins_cost(DEFAULT_COST);
 9599 
 9600   size(4);
 9601   format %{ &quot;SLDI    $dst, i2l($src1), $src2&quot; %}
 9602   ins_encode %{
 9603     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
 9604     __ sldi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9605   %}
 9606   ins_pipe(pipe_class_default);
 9607 %}
 9608 
 9609 // Shift a postivie int to the left.
 9610 // Clrlsldi clears the upper 32 bits and shifts.
 9611 instruct scaledPositiveI2L_lShiftL_convI2L_reg_imm6(iRegLdst dst, iRegIsrc src1, uimmI6 src2) %{
 9612   match(Set dst (LShiftL (ConvI2L src1) src2));
 9613   predicate(((ConvI2LNode*)(_kids[0]-&gt;_leaf))-&gt;type()-&gt;is_long()-&gt;is_positive_int());
 9614 
 9615   format %{ &quot;SLDI    $dst, i2l(positive_int($src1)), $src2&quot; %}
 9616   size(4);
 9617   ins_encode %{
 9618     // TODO: PPC port $archOpcode(ppc64Opcode_rldic);
 9619     __ clrlsldi($dst$$Register, $src1$$Register, 0x20, $src2$$constant);
 9620   %}
 9621   ins_pipe(pipe_class_default);
 9622 %}
 9623 
 9624 instruct arShiftI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9625   // no match-rule, false predicate
 9626   effect(DEF dst, USE src1, USE src2);
 9627   predicate(false);
 9628 
 9629   format %{ &quot;SRAW    $dst, $src1, $src2&quot; %}
 9630   size(4);
 9631   ins_encode %{
 9632     // TODO: PPC port $archOpcode(ppc64Opcode_sraw);
 9633     __ sraw($dst$$Register, $src1$$Register, $src2$$Register);
 9634   %}
 9635   ins_pipe(pipe_class_default);
 9636 %}
 9637 
 9638 // Register Arithmetic Shift Right
 9639 instruct arShiftI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9640   match(Set dst (RShiftI src1 src2));
 9641   ins_cost(DEFAULT_COST*2);
 9642   expand %{
 9643     uimmI6 mask %{ 0x3b /* clear 59 bits, keep 5 */ %}
 9644     iRegIdst tmpI;
 9645     maskI_reg_imm(tmpI, src2, mask);
 9646     arShiftI_reg_reg(dst, src1, tmpI);
 9647   %}
 9648 %}
 9649 
 9650 // Register Arithmetic Shift Right Immediate
 9651 instruct arShiftI_reg_imm(iRegIdst dst, iRegIsrc src1, immI src2) %{
 9652   match(Set dst (RShiftI src1 src2));
 9653 
 9654   format %{ &quot;SRAWI   $dst, $src1, ($src2 &amp; 0x1f)&quot; %}
 9655   size(4);
 9656   ins_encode %{
 9657     // TODO: PPC port $archOpcode(ppc64Opcode_srawi);
 9658     __ srawi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x1f);
 9659   %}
 9660   ins_pipe(pipe_class_default);
 9661 %}
 9662 
 9663 instruct arShiftL_regL_regI(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
 9664   // no match-rule, false predicate
 9665   effect(DEF dst, USE src1, USE src2);
 9666   predicate(false);
 9667 
 9668   format %{ &quot;SRAD    $dst, $src1, $src2&quot; %}
 9669   size(4);
 9670   ins_encode %{
 9671     // TODO: PPC port $archOpcode(ppc64Opcode_srad);
 9672     __ srad($dst$$Register, $src1$$Register, $src2$$Register);
 9673   %}
 9674   ins_pipe(pipe_class_default);
 9675 %}
 9676 
 9677 // Register Shift Right Arithmetic Long
 9678 instruct arShiftL_regL_regI_Ex(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
 9679   match(Set dst (RShiftL src1 src2));
 9680   ins_cost(DEFAULT_COST*2);
 9681 
 9682   expand %{
 9683     uimmI6 mask %{ 0x3a /* clear 58 bits, keep 6 */ %}
 9684     iRegIdst tmpI;
 9685     maskI_reg_imm(tmpI, src2, mask);
 9686     arShiftL_regL_regI(dst, src1, tmpI);
 9687   %}
 9688 %}
 9689 
 9690 // Register Shift Right Immediate
 9691 instruct arShiftL_regL_immI(iRegLdst dst, iRegLsrc src1, immI src2) %{
 9692   match(Set dst (RShiftL src1 src2));
 9693 
 9694   format %{ &quot;SRADI   $dst, $src1, ($src2 &amp; 0x3f)&quot; %}
 9695   size(4);
 9696   ins_encode %{
 9697     // TODO: PPC port $archOpcode(ppc64Opcode_sradi);
 9698     __ sradi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9699   %}
 9700   ins_pipe(pipe_class_default);
 9701 %}
 9702 
 9703 // RShiftL + ConvL2I
 9704 instruct convL2I_arShiftL_regL_immI(iRegIdst dst, iRegLsrc src1, immI src2) %{
 9705   match(Set dst (ConvL2I (RShiftL src1 src2)));
 9706 
 9707   format %{ &quot;SRADI   $dst, $src1, ($src2 &amp; 0x3f) \t// long + l2i&quot; %}
 9708   size(4);
 9709   ins_encode %{
 9710     // TODO: PPC port $archOpcode(ppc64Opcode_sradi);
 9711     __ sradi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9712   %}
 9713   ins_pipe(pipe_class_default);
 9714 %}
 9715 
 9716 instruct urShiftI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9717   // no match-rule, false predicate
 9718   effect(DEF dst, USE src1, USE src2);
 9719   predicate(false);
 9720 
 9721   format %{ &quot;SRW     $dst, $src1, $src2&quot; %}
 9722   size(4);
 9723   ins_encode %{
 9724     // TODO: PPC port $archOpcode(ppc64Opcode_srw);
 9725     __ srw($dst$$Register, $src1$$Register, $src2$$Register);
 9726   %}
 9727   ins_pipe(pipe_class_default);
 9728 %}
 9729 
 9730 // Register Shift Right
 9731 instruct urShiftI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9732   match(Set dst (URShiftI src1 src2));
 9733   ins_cost(DEFAULT_COST*2);
 9734 
 9735   expand %{
 9736     uimmI6 mask %{ 0x3b /* clear 59 bits, keep 5 */ %}
 9737     iRegIdst tmpI;
 9738     maskI_reg_imm(tmpI, src2, mask);
 9739     urShiftI_reg_reg(dst, src1, tmpI);
 9740   %}
 9741 %}
 9742 
 9743 // Register Shift Right Immediate
 9744 instruct urShiftI_reg_imm(iRegIdst dst, iRegIsrc src1, immI src2) %{
 9745   match(Set dst (URShiftI src1 src2));
 9746 
 9747   format %{ &quot;SRWI    $dst, $src1, ($src2 &amp; 0x1f)&quot; %}
 9748   size(4);
 9749   ins_encode %{
 9750     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
 9751     __ srwi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x1f);
 9752   %}
 9753   ins_pipe(pipe_class_default);
 9754 %}
 9755 
 9756 instruct urShiftL_regL_regI(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
 9757   // no match-rule, false predicate
 9758   effect(DEF dst, USE src1, USE src2);
 9759   predicate(false);
 9760 
 9761   format %{ &quot;SRD     $dst, $src1, $src2&quot; %}
 9762   size(4);
 9763   ins_encode %{
 9764     // TODO: PPC port $archOpcode(ppc64Opcode_srd);
 9765     __ srd($dst$$Register, $src1$$Register, $src2$$Register);
 9766   %}
 9767   ins_pipe(pipe_class_default);
 9768 %}
 9769 
 9770 // Register Shift Right
 9771 instruct urShiftL_regL_regI_Ex(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
 9772   match(Set dst (URShiftL src1 src2));
 9773   ins_cost(DEFAULT_COST*2);
 9774 
 9775   expand %{
 9776     uimmI6 mask %{ 0x3a /* clear 58 bits, keep 6 */ %}
 9777     iRegIdst tmpI;
 9778     maskI_reg_imm(tmpI, src2, mask);
 9779     urShiftL_regL_regI(dst, src1, tmpI);
 9780   %}
 9781 %}
 9782 
 9783 // Register Shift Right Immediate
 9784 instruct urShiftL_regL_immI(iRegLdst dst, iRegLsrc src1, immI src2) %{
 9785   match(Set dst (URShiftL src1 src2));
 9786 
 9787   format %{ &quot;SRDI    $dst, $src1, ($src2 &amp; 0x3f)&quot; %}
 9788   size(4);
 9789   ins_encode %{
 9790     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 9791     __ srdi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9792   %}
 9793   ins_pipe(pipe_class_default);
 9794 %}
 9795 
 9796 // URShiftL + ConvL2I.
 9797 instruct convL2I_urShiftL_regL_immI(iRegIdst dst, iRegLsrc src1, immI src2) %{
 9798   match(Set dst (ConvL2I (URShiftL src1 src2)));
 9799 
 9800   format %{ &quot;SRDI    $dst, $src1, ($src2 &amp; 0x3f) \t// long + l2i&quot; %}
 9801   size(4);
 9802   ins_encode %{
 9803     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 9804     __ srdi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9805   %}
 9806   ins_pipe(pipe_class_default);
 9807 %}
 9808 
 9809 // Register Shift Right Immediate with a CastP2X
 9810 instruct shrP_convP2X_reg_imm6(iRegLdst dst, iRegP_N2P src1, uimmI6 src2) %{
 9811   match(Set dst (URShiftL (CastP2X src1) src2));
 9812 
 9813   format %{ &quot;SRDI    $dst, $src1, $src2 \t// Cast ptr $src1 to long and shift&quot; %}
 9814   size(4);
 9815   ins_encode %{
 9816     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 9817     __ srdi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9818   %}
 9819   ins_pipe(pipe_class_default);
 9820 %}
 9821 
 9822 // Bitfield Extract: URShiftI + AndI
 9823 instruct andI_urShiftI_regI_immI_immIpow2minus1(iRegIdst dst, iRegIsrc src1, immI src2, immIpow2minus1 src3) %{
 9824   match(Set dst (AndI (URShiftI src1 src2) src3));
 9825 
 9826   format %{ &quot;EXTRDI  $dst, $src1, shift=$src2, mask=$src3 \t// int bitfield extract&quot; %}
 9827   size(4);
 9828   ins_encode %{
 9829     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 9830     int rshift = ($src2$$constant) &amp; 0x1f;
 9831     int length = log2_long(((jlong) $src3$$constant) + 1);
 9832     if (rshift + length &gt; 32) {
 9833       // if necessary, adjust mask to omit rotated bits.
 9834       length = 32 - rshift;
 9835     }
 9836     __ extrdi($dst$$Register, $src1$$Register, length, 64 - (rshift + length));
 9837   %}
 9838   ins_pipe(pipe_class_default);
 9839 %}
 9840 
 9841 // Bitfield Extract: URShiftL + AndL
 9842 instruct andL_urShiftL_regL_immI_immLpow2minus1(iRegLdst dst, iRegLsrc src1, immI src2, immLpow2minus1 src3) %{
 9843   match(Set dst (AndL (URShiftL src1 src2) src3));
 9844 
 9845   format %{ &quot;EXTRDI  $dst, $src1, shift=$src2, mask=$src3 \t// long bitfield extract&quot; %}
 9846   size(4);
 9847   ins_encode %{
 9848     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 9849     int rshift  = ($src2$$constant) &amp; 0x3f;
 9850     int length = log2_long(((jlong) $src3$$constant) + 1);
 9851     if (rshift + length &gt; 64) {
 9852       // if necessary, adjust mask to omit rotated bits.
 9853       length = 64 - rshift;
 9854     }
 9855     __ extrdi($dst$$Register, $src1$$Register, length, 64 - (rshift + length));
 9856   %}
 9857   ins_pipe(pipe_class_default);
 9858 %}
 9859 
 9860 instruct sxtI_reg(iRegIdst dst, iRegIsrc src) %{
 9861   match(Set dst (ConvL2I (ConvI2L src)));
 9862 
 9863   format %{ &quot;EXTSW   $dst, $src \t// int-&gt;int&quot; %}
 9864   size(4);
 9865   ins_encode %{
 9866     // TODO: PPC port $archOpcode(ppc64Opcode_extsw);
 9867     __ extsw($dst$$Register, $src$$Register);
 9868   %}
 9869   ins_pipe(pipe_class_default);
 9870 %}
 9871 
 9872 //----------Rotate Instructions------------------------------------------------
 9873 
 9874 // Rotate Left by 8-bit immediate
 9875 instruct rotlI_reg_immi8(iRegIdst dst, iRegIsrc src, immI8 lshift, immI8 rshift) %{
 9876   match(Set dst (OrI (LShiftI src lshift) (URShiftI src rshift)));
 9877   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9878 
 9879   format %{ &quot;ROTLWI  $dst, $src, $lshift&quot; %}
 9880   size(4);
 9881   ins_encode %{
 9882     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
 9883     __ rotlwi($dst$$Register, $src$$Register, $lshift$$constant);
 9884   %}
 9885   ins_pipe(pipe_class_default);
 9886 %}
 9887 
 9888 // Rotate Right by 8-bit immediate
 9889 instruct rotrI_reg_immi8(iRegIdst dst, iRegIsrc src, immI8 rshift, immI8 lshift) %{
 9890   match(Set dst (OrI (URShiftI src rshift) (LShiftI src lshift)));
 9891   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9892 
 9893   format %{ &quot;ROTRWI  $dst, $rshift&quot; %}
 9894   size(4);
 9895   ins_encode %{
 9896     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
 9897     __ rotrwi($dst$$Register, $src$$Register, $rshift$$constant);
 9898   %}
 9899   ins_pipe(pipe_class_default);
 9900 %}
 9901 
 9902 //----------Floating Point Arithmetic Instructions-----------------------------
 9903 
 9904 // Add float single precision
 9905 instruct addF_reg_reg(regF dst, regF src1, regF src2) %{
 9906   match(Set dst (AddF src1 src2));
 9907 
 9908   format %{ &quot;FADDS   $dst, $src1, $src2&quot; %}
 9909   size(4);
 9910   ins_encode %{
 9911     // TODO: PPC port $archOpcode(ppc64Opcode_fadds);
 9912     __ fadds($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9913   %}
 9914   ins_pipe(pipe_class_default);
 9915 %}
 9916 
 9917 // Add float double precision
 9918 instruct addD_reg_reg(regD dst, regD src1, regD src2) %{
 9919   match(Set dst (AddD src1 src2));
 9920 
 9921   format %{ &quot;FADD    $dst, $src1, $src2&quot; %}
 9922   size(4);
 9923   ins_encode %{
 9924     // TODO: PPC port $archOpcode(ppc64Opcode_fadd);
 9925     __ fadd($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9926   %}
 9927   ins_pipe(pipe_class_default);
 9928 %}
 9929 
 9930 // Sub float single precision
 9931 instruct subF_reg_reg(regF dst, regF src1, regF src2) %{
 9932   match(Set dst (SubF src1 src2));
 9933 
 9934   format %{ &quot;FSUBS   $dst, $src1, $src2&quot; %}
 9935   size(4);
 9936   ins_encode %{
 9937     // TODO: PPC port $archOpcode(ppc64Opcode_fsubs);
 9938     __ fsubs($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9939   %}
 9940   ins_pipe(pipe_class_default);
 9941 %}
 9942 
 9943 // Sub float double precision
 9944 instruct subD_reg_reg(regD dst, regD src1, regD src2) %{
 9945   match(Set dst (SubD src1 src2));
 9946   format %{ &quot;FSUB    $dst, $src1, $src2&quot; %}
 9947   size(4);
 9948   ins_encode %{
 9949     // TODO: PPC port $archOpcode(ppc64Opcode_fsub);
 9950     __ fsub($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9951   %}
 9952   ins_pipe(pipe_class_default);
 9953 %}
 9954 
 9955 // Mul float single precision
 9956 instruct mulF_reg_reg(regF dst, regF src1, regF src2) %{
 9957   match(Set dst (MulF src1 src2));
 9958   format %{ &quot;FMULS   $dst, $src1, $src2&quot; %}
 9959   size(4);
 9960   ins_encode %{
 9961     // TODO: PPC port $archOpcode(ppc64Opcode_fmuls);
 9962     __ fmuls($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9963   %}
 9964   ins_pipe(pipe_class_default);
 9965 %}
 9966 
 9967 // Mul float double precision
 9968 instruct mulD_reg_reg(regD dst, regD src1, regD src2) %{
 9969   match(Set dst (MulD src1 src2));
 9970   format %{ &quot;FMUL    $dst, $src1, $src2&quot; %}
 9971   size(4);
 9972   ins_encode %{
 9973     // TODO: PPC port $archOpcode(ppc64Opcode_fmul);
 9974     __ fmul($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9975   %}
 9976   ins_pipe(pipe_class_default);
 9977 %}
 9978 
 9979 // Div float single precision
 9980 instruct divF_reg_reg(regF dst, regF src1, regF src2) %{
 9981   match(Set dst (DivF src1 src2));
 9982   format %{ &quot;FDIVS   $dst, $src1, $src2&quot; %}
 9983   size(4);
 9984   ins_encode %{
 9985     // TODO: PPC port $archOpcode(ppc64Opcode_fdivs);
 9986     __ fdivs($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9987   %}
 9988   ins_pipe(pipe_class_default);
 9989 %}
 9990 
 9991 // Div float double precision
 9992 instruct divD_reg_reg(regD dst, regD src1, regD src2) %{
 9993   match(Set dst (DivD src1 src2));
 9994   format %{ &quot;FDIV    $dst, $src1, $src2&quot; %}
 9995   size(4);
 9996   ins_encode %{
 9997     // TODO: PPC port $archOpcode(ppc64Opcode_fdiv);
 9998     __ fdiv($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9999   %}
10000   ins_pipe(pipe_class_default);
10001 %}
10002 
10003 // Absolute float single precision
10004 instruct absF_reg(regF dst, regF src) %{
10005   match(Set dst (AbsF src));
10006   format %{ &quot;FABS    $dst, $src \t// float&quot; %}
10007   size(4);
10008   ins_encode %{
10009     // TODO: PPC port $archOpcode(ppc64Opcode_fabs);
10010     __ fabs($dst$$FloatRegister, $src$$FloatRegister);
10011   %}
10012   ins_pipe(pipe_class_default);
10013 %}
10014 
10015 // Absolute float double precision
10016 instruct absD_reg(regD dst, regD src) %{
10017   match(Set dst (AbsD src));
10018   format %{ &quot;FABS    $dst, $src \t// double&quot; %}
10019   size(4);
10020   ins_encode %{
10021     // TODO: PPC port $archOpcode(ppc64Opcode_fabs);
10022     __ fabs($dst$$FloatRegister, $src$$FloatRegister);
10023   %}
10024   ins_pipe(pipe_class_default);
10025 %}
10026 
10027 instruct negF_reg(regF dst, regF src) %{
10028   match(Set dst (NegF src));
10029   format %{ &quot;FNEG    $dst, $src \t// float&quot; %}
10030   size(4);
10031   ins_encode %{
10032     // TODO: PPC port $archOpcode(ppc64Opcode_fneg);
10033     __ fneg($dst$$FloatRegister, $src$$FloatRegister);
10034   %}
10035   ins_pipe(pipe_class_default);
10036 %}
10037 
10038 instruct negD_reg(regD dst, regD src) %{
10039   match(Set dst (NegD src));
10040   format %{ &quot;FNEG    $dst, $src \t// double&quot; %}
10041   size(4);
10042   ins_encode %{
10043     // TODO: PPC port $archOpcode(ppc64Opcode_fneg);
10044     __ fneg($dst$$FloatRegister, $src$$FloatRegister);
10045   %}
10046   ins_pipe(pipe_class_default);
10047 %}
10048 
10049 // AbsF + NegF.
10050 instruct negF_absF_reg(regF dst, regF src) %{
10051   match(Set dst (NegF (AbsF src)));
10052   format %{ &quot;FNABS   $dst, $src \t// float&quot; %}
10053   size(4);
10054   ins_encode %{
10055     // TODO: PPC port $archOpcode(ppc64Opcode_fnabs);
10056     __ fnabs($dst$$FloatRegister, $src$$FloatRegister);
10057   %}
10058   ins_pipe(pipe_class_default);
10059 %}
10060 
10061 // AbsD + NegD.
10062 instruct negD_absD_reg(regD dst, regD src) %{
10063   match(Set dst (NegD (AbsD src)));
10064   format %{ &quot;FNABS   $dst, $src \t// double&quot; %}
10065   size(4);
10066   ins_encode %{
10067     // TODO: PPC port $archOpcode(ppc64Opcode_fnabs);
10068     __ fnabs($dst$$FloatRegister, $src$$FloatRegister);
10069   %}
10070   ins_pipe(pipe_class_default);
10071 %}
10072 
10073 // VM_Version::has_fsqrt() decides if this node will be used.
10074 // Sqrt float double precision
10075 instruct sqrtD_reg(regD dst, regD src) %{
10076   match(Set dst (SqrtD src));
10077   format %{ &quot;FSQRT   $dst, $src&quot; %}
10078   size(4);
10079   ins_encode %{
10080     // TODO: PPC port $archOpcode(ppc64Opcode_fsqrt);
10081     __ fsqrt($dst$$FloatRegister, $src$$FloatRegister);
10082   %}
10083   ins_pipe(pipe_class_default);
10084 %}
10085 
10086 // Single-precision sqrt.
10087 instruct sqrtF_reg(regF dst, regF src) %{
10088   match(Set dst (SqrtF src));
10089   predicate(VM_Version::has_fsqrts());
10090   ins_cost(DEFAULT_COST);
10091 
10092   format %{ &quot;FSQRTS  $dst, $src&quot; %}
10093   size(4);
10094   ins_encode %{
10095     // TODO: PPC port $archOpcode(ppc64Opcode_fsqrts);
10096     __ fsqrts($dst$$FloatRegister, $src$$FloatRegister);
10097   %}
10098   ins_pipe(pipe_class_default);
10099 %}
10100 
10101 instruct roundDouble_nop(regD dst) %{
10102   match(Set dst (RoundDouble dst));
10103   ins_cost(0);
10104 
10105   format %{ &quot; -- \t// RoundDouble not needed - empty&quot; %}
10106   size(0);
10107   // PPC results are already &quot;rounded&quot; (i.e., normal-format IEEE).
10108   ins_encode( /*empty*/ );
10109   ins_pipe(pipe_class_default);
10110 %}
10111 
10112 instruct roundFloat_nop(regF dst) %{
10113   match(Set dst (RoundFloat dst));
10114   ins_cost(0);
10115 
10116   format %{ &quot; -- \t// RoundFloat not needed - empty&quot; %}
10117   size(0);
10118   // PPC results are already &quot;rounded&quot; (i.e., normal-format IEEE).
10119   ins_encode( /*empty*/ );
10120   ins_pipe(pipe_class_default);
10121 %}
10122 
10123 
10124 // Multiply-Accumulate
10125 // src1 * src2 + src3
10126 instruct maddF_reg_reg(regF dst, regF src1, regF src2, regF src3) %{
10127   match(Set dst (FmaF src3 (Binary src1 src2)));
10128 
10129   format %{ &quot;FMADDS  $dst, $src1, $src2, $src3&quot; %}
10130   size(4);
10131   ins_encode %{
10132     // TODO: PPC port $archOpcode(ppc64Opcode_fmadds);
10133     __ fmadds($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10134   %}
10135   ins_pipe(pipe_class_default);
10136 %}
10137 
10138 // src1 * src2 + src3
10139 instruct maddD_reg_reg(regD dst, regD src1, regD src2, regD src3) %{
10140   match(Set dst (FmaD src3 (Binary src1 src2)));
10141 
10142   format %{ &quot;FMADD   $dst, $src1, $src2, $src3&quot; %}
10143   size(4);
10144   ins_encode %{
10145     // TODO: PPC port $archOpcode(ppc64Opcode_fmadd);
10146     __ fmadd($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10147   %}
10148   ins_pipe(pipe_class_default);
10149 %}
10150 
10151 // -src1 * src2 + src3 = -(src1*src2-src3)
10152 instruct mnsubF_reg_reg(regF dst, regF src1, regF src2, regF src3) %{
10153   match(Set dst (FmaF src3 (Binary (NegF src1) src2)));
10154   match(Set dst (FmaF src3 (Binary src1 (NegF src2))));
10155 
10156   format %{ &quot;FNMSUBS $dst, $src1, $src2, $src3&quot; %}
10157   size(4);
10158   ins_encode %{
10159     // TODO: PPC port $archOpcode(ppc64Opcode_fnmsubs);
10160     __ fnmsubs($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10161   %}
10162   ins_pipe(pipe_class_default);
10163 %}
10164 
10165 // -src1 * src2 + src3 = -(src1*src2-src3)
10166 instruct mnsubD_reg_reg(regD dst, regD src1, regD src2, regD src3) %{
10167   match(Set dst (FmaD src3 (Binary (NegD src1) src2)));
10168   match(Set dst (FmaD src3 (Binary src1 (NegD src2))));
10169 
10170   format %{ &quot;FNMSUB  $dst, $src1, $src2, $src3&quot; %}
10171   size(4);
10172   ins_encode %{
10173     // TODO: PPC port $archOpcode(ppc64Opcode_fnmsub);
10174     __ fnmsub($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10175   %}
10176   ins_pipe(pipe_class_default);
10177 %}
10178 
10179 // -src1 * src2 - src3 = -(src1*src2+src3)
10180 instruct mnaddF_reg_reg(regF dst, regF src1, regF src2, regF src3) %{
10181   match(Set dst (FmaF (NegF src3) (Binary (NegF src1) src2)));
10182   match(Set dst (FmaF (NegF src3) (Binary src1 (NegF src2))));
10183 
10184   format %{ &quot;FNMADDS $dst, $src1, $src2, $src3&quot; %}
10185   size(4);
10186   ins_encode %{
10187     // TODO: PPC port $archOpcode(ppc64Opcode_fnmadds);
10188     __ fnmadds($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10189   %}
10190   ins_pipe(pipe_class_default);
10191 %}
10192 
10193 // -src1 * src2 - src3 = -(src1*src2+src3)
10194 instruct mnaddD_reg_reg(regD dst, regD src1, regD src2, regD src3) %{
10195   match(Set dst (FmaD (NegD src3) (Binary (NegD src1) src2)));
10196   match(Set dst (FmaD (NegD src3) (Binary src1 (NegD src2))));
10197 
10198   format %{ &quot;FNMADD  $dst, $src1, $src2, $src3&quot; %}
10199   size(4);
10200   ins_encode %{
10201     // TODO: PPC port $archOpcode(ppc64Opcode_fnmadd);
10202     __ fnmadd($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10203   %}
10204   ins_pipe(pipe_class_default);
10205 %}
10206 
10207 // src1 * src2 - src3
10208 instruct msubF_reg_reg(regF dst, regF src1, regF src2, regF src3) %{
10209   match(Set dst (FmaF (NegF src3) (Binary src1 src2)));
10210 
10211   format %{ &quot;FMSUBS  $dst, $src1, $src2, $src3&quot; %}
10212   size(4);
10213   ins_encode %{
10214     // TODO: PPC port $archOpcode(ppc64Opcode_fmsubs);
10215     __ fmsubs($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10216   %}
10217   ins_pipe(pipe_class_default);
10218 %}
10219 
10220 // src1 * src2 - src3
10221 instruct msubD_reg_reg(regD dst, regD src1, regD src2, regD src3) %{
10222   match(Set dst (FmaD (NegD src3) (Binary src1 src2)));
10223 
10224   format %{ &quot;FMSUB   $dst, $src1, $src2, $src3&quot; %}
10225   size(4);
10226   ins_encode %{
10227     // TODO: PPC port $archOpcode(ppc64Opcode_fmsub);
10228     __ fmsub($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10229   %}
10230   ins_pipe(pipe_class_default);
10231 %}
10232 
10233 
10234 //----------Logical Instructions-----------------------------------------------
10235 
10236 // And Instructions
10237 
10238 // Register And
10239 instruct andI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
10240   match(Set dst (AndI src1 src2));
10241   format %{ &quot;AND     $dst, $src1, $src2&quot; %}
10242   size(4);
10243   ins_encode %{
10244     // TODO: PPC port $archOpcode(ppc64Opcode_and);
10245     __ andr($dst$$Register, $src1$$Register, $src2$$Register);
10246   %}
10247   ins_pipe(pipe_class_default);
10248 %}
10249 
10250 // Left shifted Immediate And
10251 instruct andI_reg_immIhi16(iRegIdst dst, iRegIsrc src1, immIhi16  src2, flagsRegCR0 cr0) %{
10252   match(Set dst (AndI src1 src2));
10253   effect(KILL cr0);
10254   format %{ &quot;ANDIS   $dst, $src1, $src2.hi&quot; %}
10255   size(4);
10256   ins_encode %{
10257     // TODO: PPC port $archOpcode(ppc64Opcode_andis_);
10258     __ andis_($dst$$Register, $src1$$Register, (int)((unsigned short)(($src2$$constant &amp; 0xFFFF0000) &gt;&gt; 16)));
10259   %}
10260   ins_pipe(pipe_class_default);
10261 %}
10262 
10263 // Immediate And
10264 instruct andI_reg_uimm16(iRegIdst dst, iRegIsrc src1, uimmI16 src2, flagsRegCR0 cr0) %{
10265   match(Set dst (AndI src1 src2));
10266   effect(KILL cr0);
10267 
10268   format %{ &quot;ANDI    $dst, $src1, $src2&quot; %}
10269   size(4);
10270   ins_encode %{
10271     // TODO: PPC port $archOpcode(ppc64Opcode_andi_);
10272     // FIXME: avoid andi_ ?
10273     __ andi_($dst$$Register, $src1$$Register, $src2$$constant);
10274   %}
10275   ins_pipe(pipe_class_default);
10276 %}
10277 
10278 // Immediate And where the immediate is a negative power of 2.
10279 instruct andI_reg_immInegpow2(iRegIdst dst, iRegIsrc src1, immInegpow2 src2) %{
10280   match(Set dst (AndI src1 src2));
10281   format %{ &quot;ANDWI   $dst, $src1, $src2&quot; %}
10282   size(4);
10283   ins_encode %{
10284     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
10285     __ clrrdi($dst$$Register, $src1$$Register, log2_long((jlong)(julong)(juint)-($src2$$constant)));
10286   %}
10287   ins_pipe(pipe_class_default);
10288 %}
10289 
10290 instruct andI_reg_immIpow2minus1(iRegIdst dst, iRegIsrc src1, immIpow2minus1 src2) %{
10291   match(Set dst (AndI src1 src2));
10292   format %{ &quot;ANDWI   $dst, $src1, $src2&quot; %}
10293   size(4);
10294   ins_encode %{
10295     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
10296     __ clrldi($dst$$Register, $src1$$Register, 64-log2_long((((jlong) $src2$$constant)+1)));
10297   %}
10298   ins_pipe(pipe_class_default);
10299 %}
10300 
10301 instruct andI_reg_immIpowerOf2(iRegIdst dst, iRegIsrc src1, immIpowerOf2 src2) %{
10302   match(Set dst (AndI src1 src2));
10303   predicate(UseRotateAndMaskInstructionsPPC64);
10304   format %{ &quot;ANDWI   $dst, $src1, $src2&quot; %}
10305   size(4);
10306   ins_encode %{
10307     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
10308     __ rlwinm($dst$$Register, $src1$$Register, 0,
10309               (31-log2_long((jlong) $src2$$constant)) &amp; 0x1f, (31-log2_long((jlong) $src2$$constant)) &amp; 0x1f);
10310   %}
10311   ins_pipe(pipe_class_default);
10312 %}
10313 
10314 // Register And Long
10315 instruct andL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
10316   match(Set dst (AndL src1 src2));
10317   ins_cost(DEFAULT_COST);
10318 
10319   format %{ &quot;AND     $dst, $src1, $src2 \t// long&quot; %}
10320   size(4);
10321   ins_encode %{
10322     // TODO: PPC port $archOpcode(ppc64Opcode_and);
10323     __ andr($dst$$Register, $src1$$Register, $src2$$Register);
10324   %}
10325   ins_pipe(pipe_class_default);
10326 %}
10327 
10328 // Immediate And long
10329 instruct andL_reg_uimm16(iRegLdst dst, iRegLsrc src1, uimmL16 src2, flagsRegCR0 cr0) %{
10330   match(Set dst (AndL src1 src2));
10331   effect(KILL cr0);
10332 
10333   format %{ &quot;ANDI    $dst, $src1, $src2 \t// long&quot; %}
10334   size(4);
10335   ins_encode %{
10336     // TODO: PPC port $archOpcode(ppc64Opcode_andi_);
10337     // FIXME: avoid andi_ ?
10338     __ andi_($dst$$Register, $src1$$Register, $src2$$constant);
10339   %}
10340   ins_pipe(pipe_class_default);
10341 %}
10342 
10343 // Immediate And Long where the immediate is a negative power of 2.
10344 instruct andL_reg_immLnegpow2(iRegLdst dst, iRegLsrc src1, immLnegpow2 src2) %{
10345   match(Set dst (AndL src1 src2));
10346   format %{ &quot;ANDDI   $dst, $src1, $src2&quot; %}
10347   size(4);
10348   ins_encode %{
10349     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
10350     __ clrrdi($dst$$Register, $src1$$Register, log2_long((jlong)-$src2$$constant));
10351   %}
10352   ins_pipe(pipe_class_default);
10353 %}
10354 
10355 instruct andL_reg_immLpow2minus1(iRegLdst dst, iRegLsrc src1, immLpow2minus1 src2) %{
10356   match(Set dst (AndL src1 src2));
10357   format %{ &quot;ANDDI   $dst, $src1, $src2&quot; %}
10358   size(4);
10359   ins_encode %{
10360     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
10361     __ clrldi($dst$$Register, $src1$$Register, 64-log2_long((((jlong) $src2$$constant)+1)));
10362   %}
10363   ins_pipe(pipe_class_default);
10364 %}
10365 
10366 // AndL + ConvL2I.
10367 instruct convL2I_andL_reg_immLpow2minus1(iRegIdst dst, iRegLsrc src1, immLpow2minus1 src2) %{
10368   match(Set dst (ConvL2I (AndL src1 src2)));
10369   ins_cost(DEFAULT_COST);
10370 
10371   format %{ &quot;ANDDI   $dst, $src1, $src2 \t// long + l2i&quot; %}
10372   size(4);
10373   ins_encode %{
10374     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
10375     __ clrldi($dst$$Register, $src1$$Register, 64-log2_long((((jlong) $src2$$constant)+1)));
10376   %}
10377   ins_pipe(pipe_class_default);
10378 %}
10379 
10380 // Or Instructions
10381 
10382 // Register Or
10383 instruct orI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
10384   match(Set dst (OrI src1 src2));
10385   format %{ &quot;OR      $dst, $src1, $src2&quot; %}
10386   size(4);
10387   ins_encode %{
10388     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10389     __ or_unchecked($dst$$Register, $src1$$Register, $src2$$Register);
10390   %}
10391   ins_pipe(pipe_class_default);
10392 %}
10393 
10394 // Expand does not work with above instruct. (??)
10395 instruct orI_reg_reg_2(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
10396   // no match-rule
10397   effect(DEF dst, USE src1, USE src2);
10398   format %{ &quot;OR      $dst, $src1, $src2&quot; %}
10399   size(4);
10400   ins_encode %{
10401     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10402     __ or_unchecked($dst$$Register, $src1$$Register, $src2$$Register);
10403   %}
10404   ins_pipe(pipe_class_default);
10405 %}
10406 
10407 instruct tree_orI_orI_orI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, iRegIsrc src3, iRegIsrc src4) %{
10408   match(Set dst (OrI (OrI (OrI src1 src2) src3) src4));
10409   ins_cost(DEFAULT_COST*3);
10410 
10411   expand %{
10412     // FIXME: we should do this in the ideal world.
10413     iRegIdst tmp1;
10414     iRegIdst tmp2;
10415     orI_reg_reg(tmp1, src1, src2);
10416     orI_reg_reg_2(tmp2, src3, src4); // Adlc complains about orI_reg_reg.
10417     orI_reg_reg(dst, tmp1, tmp2);
10418   %}
10419 %}
10420 
10421 // Immediate Or
10422 instruct orI_reg_uimm16(iRegIdst dst, iRegIsrc src1, uimmI16 src2) %{
10423   match(Set dst (OrI src1 src2));
10424   format %{ &quot;ORI     $dst, $src1, $src2&quot; %}
10425   size(4);
10426   ins_encode %{
10427     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
10428     __ ori($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0xFFFF);
10429   %}
10430   ins_pipe(pipe_class_default);
10431 %}
10432 
10433 // Register Or Long
10434 instruct orL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
10435   match(Set dst (OrL src1 src2));
10436   ins_cost(DEFAULT_COST);
10437 
10438   size(4);
10439   format %{ &quot;OR      $dst, $src1, $src2 \t// long&quot; %}
10440   ins_encode %{
10441     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10442     __ or_unchecked($dst$$Register, $src1$$Register, $src2$$Register);
10443   %}
10444   ins_pipe(pipe_class_default);
10445 %}
10446 
10447 // OrL + ConvL2I.
10448 instruct orI_regL_regL(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
10449   match(Set dst (ConvL2I (OrL src1 src2)));
10450   ins_cost(DEFAULT_COST);
10451 
10452   format %{ &quot;OR      $dst, $src1, $src2 \t// long + l2i&quot; %}
10453   size(4);
10454   ins_encode %{
10455     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10456     __ or_unchecked($dst$$Register, $src1$$Register, $src2$$Register);
10457   %}
10458   ins_pipe(pipe_class_default);
10459 %}
10460 
10461 // Immediate Or long
10462 instruct orL_reg_uimm16(iRegLdst dst, iRegLsrc src1, uimmL16 con) %{
10463   match(Set dst (OrL src1 con));
10464   ins_cost(DEFAULT_COST);
10465 
10466   format %{ &quot;ORI     $dst, $src1, $con \t// long&quot; %}
10467   size(4);
10468   ins_encode %{
10469     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
10470     __ ori($dst$$Register, $src1$$Register, ($con$$constant) &amp; 0xFFFF);
10471   %}
10472   ins_pipe(pipe_class_default);
10473 %}
10474 
10475 // Xor Instructions
10476 
10477 // Register Xor
10478 instruct xorI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
10479   match(Set dst (XorI src1 src2));
10480   format %{ &quot;XOR     $dst, $src1, $src2&quot; %}
10481   size(4);
10482   ins_encode %{
10483     // TODO: PPC port $archOpcode(ppc64Opcode_xor);
10484     __ xorr($dst$$Register, $src1$$Register, $src2$$Register);
10485   %}
10486   ins_pipe(pipe_class_default);
10487 %}
10488 
10489 // Expand does not work with above instruct. (??)
10490 instruct xorI_reg_reg_2(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
10491   // no match-rule
10492   effect(DEF dst, USE src1, USE src2);
10493   format %{ &quot;XOR     $dst, $src1, $src2&quot; %}
10494   size(4);
10495   ins_encode %{
10496     // TODO: PPC port $archOpcode(ppc64Opcode_xor);
10497     __ xorr($dst$$Register, $src1$$Register, $src2$$Register);
10498   %}
10499   ins_pipe(pipe_class_default);
10500 %}
10501 
10502 instruct tree_xorI_xorI_xorI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, iRegIsrc src3, iRegIsrc src4) %{
10503   match(Set dst (XorI (XorI (XorI src1 src2) src3) src4));
10504   ins_cost(DEFAULT_COST*3);
10505 
10506   expand %{
10507     // FIXME: we should do this in the ideal world.
10508     iRegIdst tmp1;
10509     iRegIdst tmp2;
10510     xorI_reg_reg(tmp1, src1, src2);
10511     xorI_reg_reg_2(tmp2, src3, src4); // Adlc complains about xorI_reg_reg.
10512     xorI_reg_reg(dst, tmp1, tmp2);
10513   %}
10514 %}
10515 
10516 // Immediate Xor
10517 instruct xorI_reg_uimm16(iRegIdst dst, iRegIsrc src1, uimmI16 src2) %{
10518   match(Set dst (XorI src1 src2));
10519   format %{ &quot;XORI    $dst, $src1, $src2&quot; %}
10520   size(4);
10521   ins_encode %{
10522     // TODO: PPC port $archOpcode(ppc64Opcode_xori);
10523     __ xori($dst$$Register, $src1$$Register, $src2$$constant);
10524   %}
10525   ins_pipe(pipe_class_default);
10526 %}
10527 
10528 // Register Xor Long
10529 instruct xorL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
10530   match(Set dst (XorL src1 src2));
10531   ins_cost(DEFAULT_COST);
10532 
10533   format %{ &quot;XOR     $dst, $src1, $src2 \t// long&quot; %}
10534   size(4);
10535   ins_encode %{
10536     // TODO: PPC port $archOpcode(ppc64Opcode_xor);
10537     __ xorr($dst$$Register, $src1$$Register, $src2$$Register);
10538   %}
10539   ins_pipe(pipe_class_default);
10540 %}
10541 
10542 // XorL + ConvL2I.
10543 instruct xorI_regL_regL(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
10544   match(Set dst (ConvL2I (XorL src1 src2)));
10545   ins_cost(DEFAULT_COST);
10546 
10547   format %{ &quot;XOR     $dst, $src1, $src2 \t// long + l2i&quot; %}
10548   size(4);
10549   ins_encode %{
10550     // TODO: PPC port $archOpcode(ppc64Opcode_xor);
10551     __ xorr($dst$$Register, $src1$$Register, $src2$$Register);
10552   %}
10553   ins_pipe(pipe_class_default);
10554 %}
10555 
10556 // Immediate Xor Long
10557 instruct xorL_reg_uimm16(iRegLdst dst, iRegLsrc src1, uimmL16 src2) %{
10558   match(Set dst (XorL src1 src2));
10559   ins_cost(DEFAULT_COST);
10560 
10561   format %{ &quot;XORI    $dst, $src1, $src2 \t// long&quot; %}
10562   size(4);
10563   ins_encode %{
10564     // TODO: PPC port $archOpcode(ppc64Opcode_xori);
10565     __ xori($dst$$Register, $src1$$Register, $src2$$constant);
10566   %}
10567   ins_pipe(pipe_class_default);
10568 %}
10569 
10570 instruct notI_reg(iRegIdst dst, iRegIsrc src1, immI_minus1 src2) %{
10571   match(Set dst (XorI src1 src2));
10572   ins_cost(DEFAULT_COST);
10573 
10574   format %{ &quot;NOT     $dst, $src1 ($src2)&quot; %}
10575   size(4);
10576   ins_encode %{
10577     // TODO: PPC port $archOpcode(ppc64Opcode_nor);
10578     __ nor($dst$$Register, $src1$$Register, $src1$$Register);
10579   %}
10580   ins_pipe(pipe_class_default);
10581 %}
10582 
10583 instruct notL_reg(iRegLdst dst, iRegLsrc src1, immL_minus1 src2) %{
10584   match(Set dst (XorL src1 src2));
10585   ins_cost(DEFAULT_COST);
10586 
10587   format %{ &quot;NOT     $dst, $src1 ($src2) \t// long&quot; %}
10588   size(4);
10589   ins_encode %{
10590     // TODO: PPC port $archOpcode(ppc64Opcode_nor);
10591     __ nor($dst$$Register, $src1$$Register, $src1$$Register);
10592   %}
10593   ins_pipe(pipe_class_default);
10594 %}
10595 
10596 // And-complement
10597 instruct andcI_reg_reg(iRegIdst dst, iRegIsrc src1, immI_minus1 src2, iRegIsrc src3) %{
10598   match(Set dst (AndI (XorI src1 src2) src3));
10599   ins_cost(DEFAULT_COST);
10600 
10601   format %{ &quot;ANDW    $dst, xori($src1, $src2), $src3&quot; %}
10602   size(4);
10603   ins_encode( enc_andc(dst, src3, src1) );
10604   ins_pipe(pipe_class_default);
10605 %}
10606 
10607 // And-complement
10608 instruct andcL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
10609   // no match-rule, false predicate
10610   effect(DEF dst, USE src1, USE src2);
10611   predicate(false);
10612 
10613   format %{ &quot;ANDC    $dst, $src1, $src2&quot; %}
10614   size(4);
10615   ins_encode %{
10616     // TODO: PPC port $archOpcode(ppc64Opcode_andc);
10617     __ andc($dst$$Register, $src1$$Register, $src2$$Register);
10618   %}
10619   ins_pipe(pipe_class_default);
10620 %}
10621 
10622 //----------Moves between int/long and float/double----------------------------
10623 //
10624 // The following rules move values from int/long registers/stack-locations
10625 // to float/double registers/stack-locations and vice versa, without doing any
10626 // conversions. These rules are used to implement the bit-conversion methods
10627 // of java.lang.Float etc., e.g.
10628 //   int   floatToIntBits(float value)
10629 //   float intBitsToFloat(int bits)
10630 //
10631 // Notes on the implementation on ppc64:
10632 // For Power7 and earlier, the rules are limited to those which move between a
10633 // register and a stack-location, because we always have to go through memory
10634 // when moving between a float register and an integer register.
10635 // This restriction is removed in Power8 with the introduction of the mtfprd
10636 // and mffprd instructions.
10637 
10638 instruct moveL2D_reg(regD dst, iRegLsrc src) %{
10639   match(Set dst (MoveL2D src));
10640   predicate(VM_Version::has_mtfprd());
10641 
10642   format %{ &quot;MTFPRD  $dst, $src&quot; %}
10643   size(4);
10644   ins_encode %{
10645     __ mtfprd($dst$$FloatRegister, $src$$Register);
10646   %}
10647   ins_pipe(pipe_class_default);
10648 %}
10649 
10650 instruct moveI2D_reg(regD dst, iRegIsrc src) %{
10651   // no match-rule, false predicate
10652   effect(DEF dst, USE src);
10653   predicate(false);
10654 
10655   format %{ &quot;MTFPRWA $dst, $src&quot; %}
10656   size(4);
10657   ins_encode %{
10658     __ mtfprwa($dst$$FloatRegister, $src$$Register);
10659   %}
10660   ins_pipe(pipe_class_default);
10661 %}
10662 
10663 //---------- Chain stack slots between similar types --------
10664 
10665 // These are needed so that the rules below can match.
10666 
10667 // Load integer from stack slot
10668 instruct stkI_to_regI(iRegIdst dst, stackSlotI src) %{
10669   match(Set dst src);
10670   ins_cost(MEMORY_REF_COST);
10671 
10672   format %{ &quot;LWZ     $dst, $src&quot; %}
10673   size(4);
10674   ins_encode( enc_lwz(dst, src) );
10675   ins_pipe(pipe_class_memory);
10676 %}
10677 
10678 // Store integer to stack slot
10679 instruct regI_to_stkI(stackSlotI dst, iRegIsrc src) %{
10680   match(Set dst src);
10681   ins_cost(MEMORY_REF_COST);
10682 
10683   format %{ &quot;STW     $src, $dst \t// stk&quot; %}
10684   size(4);
10685   ins_encode( enc_stw(src, dst) ); // rs=rt
10686   ins_pipe(pipe_class_memory);
10687 %}
10688 
10689 // Load long from stack slot
10690 instruct stkL_to_regL(iRegLdst dst, stackSlotL src) %{
10691   match(Set dst src);
10692   ins_cost(MEMORY_REF_COST);
10693 
10694   format %{ &quot;LD      $dst, $src \t// long&quot; %}
10695   size(4);
10696   ins_encode( enc_ld(dst, src) );
10697   ins_pipe(pipe_class_memory);
10698 %}
10699 
10700 // Store long to stack slot
10701 instruct regL_to_stkL(stackSlotL dst, iRegLsrc src) %{
10702   match(Set dst src);
10703   ins_cost(MEMORY_REF_COST);
10704 
10705   format %{ &quot;STD     $src, $dst \t// long&quot; %}
10706   size(4);
10707   ins_encode( enc_std(src, dst) ); // rs=rt
10708   ins_pipe(pipe_class_memory);
10709 %}
10710 
10711 //----------Moves between int and float
10712 
10713 // Move float value from float stack-location to integer register.
10714 instruct moveF2I_stack_reg(iRegIdst dst, stackSlotF src) %{
10715   match(Set dst (MoveF2I src));
10716   ins_cost(MEMORY_REF_COST);
10717 
10718   format %{ &quot;LWZ     $dst, $src \t// MoveF2I&quot; %}
10719   size(4);
10720   ins_encode( enc_lwz(dst, src) );
10721   ins_pipe(pipe_class_memory);
10722 %}
10723 
10724 // Move float value from float register to integer stack-location.
10725 instruct moveF2I_reg_stack(stackSlotI dst, regF src) %{
10726   match(Set dst (MoveF2I src));
10727   ins_cost(MEMORY_REF_COST);
10728 
10729   format %{ &quot;STFS    $src, $dst \t// MoveF2I&quot; %}
10730   size(4);
10731   ins_encode( enc_stfs(src, dst) );
10732   ins_pipe(pipe_class_memory);
10733 %}
10734 
10735 // Move integer value from integer stack-location to float register.
10736 instruct moveI2F_stack_reg(regF dst, stackSlotI src) %{
10737   match(Set dst (MoveI2F src));
10738   ins_cost(MEMORY_REF_COST);
10739 
10740   format %{ &quot;LFS     $dst, $src \t// MoveI2F&quot; %}
10741   size(4);
10742   ins_encode %{
10743     // TODO: PPC port $archOpcode(ppc64Opcode_lfs);
10744     int Idisp = $src$$disp + frame_slots_bias($src$$base, ra_);
10745     __ lfs($dst$$FloatRegister, Idisp, $src$$base$$Register);
10746   %}
10747   ins_pipe(pipe_class_memory);
10748 %}
10749 
10750 // Move integer value from integer register to float stack-location.
10751 instruct moveI2F_reg_stack(stackSlotF dst, iRegIsrc src) %{
10752   match(Set dst (MoveI2F src));
10753   ins_cost(MEMORY_REF_COST);
10754 
10755   format %{ &quot;STW     $src, $dst \t// MoveI2F&quot; %}
10756   size(4);
10757   ins_encode( enc_stw(src, dst) );
10758   ins_pipe(pipe_class_memory);
10759 %}
10760 
10761 //----------Moves between long and float
10762 
10763 instruct moveF2L_reg_stack(stackSlotL dst, regF src) %{
10764   // no match-rule, false predicate
10765   effect(DEF dst, USE src);
10766   predicate(false);
10767 
10768   format %{ &quot;storeD  $src, $dst \t// STACK&quot; %}
10769   size(4);
10770   ins_encode( enc_stfd(src, dst) );
10771   ins_pipe(pipe_class_default);
10772 %}
10773 
10774 //----------Moves between long and double
10775 
10776 // Move double value from double stack-location to long register.
10777 instruct moveD2L_stack_reg(iRegLdst dst, stackSlotD src) %{
10778   match(Set dst (MoveD2L src));
10779   ins_cost(MEMORY_REF_COST);
10780   size(4);
10781   format %{ &quot;LD      $dst, $src \t// MoveD2L&quot; %}
10782   ins_encode( enc_ld(dst, src) );
10783   ins_pipe(pipe_class_memory);
10784 %}
10785 
10786 // Move double value from double register to long stack-location.
10787 instruct moveD2L_reg_stack(stackSlotL dst, regD src) %{
10788   match(Set dst (MoveD2L src));
10789   effect(DEF dst, USE src);
10790   ins_cost(MEMORY_REF_COST);
10791 
10792   format %{ &quot;STFD    $src, $dst \t// MoveD2L&quot; %}
10793   size(4);
10794   ins_encode( enc_stfd(src, dst) );
10795   ins_pipe(pipe_class_memory);
10796 %}
10797 
10798 // Move long value from long stack-location to double register.
10799 instruct moveL2D_stack_reg(regD dst, stackSlotL src) %{
10800   match(Set dst (MoveL2D src));
10801   ins_cost(MEMORY_REF_COST);
10802 
10803   format %{ &quot;LFD     $dst, $src \t// MoveL2D&quot; %}
10804   size(4);
10805   ins_encode( enc_lfd(dst, src) );
10806   ins_pipe(pipe_class_memory);
10807 %}
10808 
10809 // Move long value from long register to double stack-location.
10810 instruct moveL2D_reg_stack(stackSlotD dst, iRegLsrc src) %{
10811   match(Set dst (MoveL2D src));
10812   ins_cost(MEMORY_REF_COST);
10813 
10814   format %{ &quot;STD     $src, $dst \t// MoveL2D&quot; %}
10815   size(4);
10816   ins_encode( enc_std(src, dst) );
10817   ins_pipe(pipe_class_memory);
10818 %}
10819 
10820 //----------Register Move Instructions-----------------------------------------
10821 
10822 // Replicate for Superword
10823 
10824 instruct moveReg(iRegLdst dst, iRegIsrc src) %{
10825   predicate(false);
10826   effect(DEF dst, USE src);
10827 
10828   format %{ &quot;MR      $dst, $src \t// replicate &quot; %}
10829   // variable size, 0 or 4.
10830   ins_encode %{
10831     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10832     __ mr_if_needed($dst$$Register, $src$$Register);
10833   %}
10834   ins_pipe(pipe_class_default);
10835 %}
10836 
10837 //----------Cast instructions (Java-level type cast)---------------------------
10838 
10839 // Cast Long to Pointer for unsafe natives.
10840 instruct castX2P(iRegPdst dst, iRegLsrc src) %{
10841   match(Set dst (CastX2P src));
10842 
10843   format %{ &quot;MR      $dst, $src \t// Long-&gt;Ptr&quot; %}
10844   // variable size, 0 or 4.
10845   ins_encode %{
10846     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10847     __ mr_if_needed($dst$$Register, $src$$Register);
10848   %}
10849  ins_pipe(pipe_class_default);
10850 %}
10851 
10852 // Cast Pointer to Long for unsafe natives.
10853 instruct castP2X(iRegLdst dst, iRegP_N2P src) %{
10854   match(Set dst (CastP2X src));
10855 
10856   format %{ &quot;MR      $dst, $src \t// Ptr-&gt;Long&quot; %}
10857   // variable size, 0 or 4.
10858   ins_encode %{
10859     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10860     __ mr_if_needed($dst$$Register, $src$$Register);
10861   %}
10862   ins_pipe(pipe_class_default);
10863 %}
10864 
10865 instruct castPP(iRegPdst dst) %{
10866   match(Set dst (CastPP dst));
10867   format %{ &quot; -- \t// castPP of $dst&quot; %}
10868   size(0);
10869   ins_encode( /*empty*/ );
10870   ins_pipe(pipe_class_default);
10871 %}
10872 
10873 instruct castII(iRegIdst dst) %{
10874   match(Set dst (CastII dst));
10875   format %{ &quot; -- \t// castII of $dst&quot; %}
10876   size(0);
10877   ins_encode( /*empty*/ );
10878   ins_pipe(pipe_class_default);
10879 %}
10880 
10881 instruct castLL(iRegLdst dst) %{
10882   match(Set dst (CastLL dst));
10883   format %{ &quot; -- \t// castLL of $dst&quot; %}
10884   size(0);
10885   ins_encode( /*empty*/ );
10886   ins_pipe(pipe_class_default);
10887 %}
10888 
10889 instruct checkCastPP(iRegPdst dst) %{
10890   match(Set dst (CheckCastPP dst));
10891   format %{ &quot; -- \t// checkcastPP of $dst&quot; %}
10892   size(0);
10893   ins_encode( /*empty*/ );
10894   ins_pipe(pipe_class_default);
10895 %}
10896 
10897 //----------Convert instructions-----------------------------------------------
10898 
10899 // Convert to boolean.
10900 
10901 // int_to_bool(src) : { 1   if src != 0
10902 //                    { 0   else
10903 //
10904 // strategy:
10905 // 1) Count leading zeros of 32 bit-value src,
10906 //    this returns 32 (0b10.0000) iff src == 0 and &lt;32 otherwise.
10907 // 2) Shift 5 bits to the right, result is 0b1 iff src == 0, 0b0 otherwise.
10908 // 3) Xori the result to get 0b1 if src != 0 and 0b0 if src == 0.
10909 
10910 // convI2Bool
10911 instruct convI2Bool_reg__cntlz_Ex(iRegIdst dst, iRegIsrc src) %{
10912   match(Set dst (Conv2B src));
10913   predicate(UseCountLeadingZerosInstructionsPPC64);
10914   ins_cost(DEFAULT_COST);
10915 
10916   expand %{
10917     immI shiftAmount %{ 0x5 %}
10918     uimmI16 mask %{ 0x1 %}
10919     iRegIdst tmp1;
10920     iRegIdst tmp2;
10921     countLeadingZerosI(tmp1, src);
10922     urShiftI_reg_imm(tmp2, tmp1, shiftAmount);
10923     xorI_reg_uimm16(dst, tmp2, mask);
10924   %}
10925 %}
10926 
10927 instruct convI2Bool_reg__cmove(iRegIdst dst, iRegIsrc src, flagsReg crx) %{
10928   match(Set dst (Conv2B src));
10929   effect(TEMP crx);
10930   predicate(!UseCountLeadingZerosInstructionsPPC64);
10931   ins_cost(DEFAULT_COST);
10932 
10933   format %{ &quot;CMPWI   $crx, $src, #0 \t// convI2B&quot;
10934             &quot;LI      $dst, #0\n\t&quot;
10935             &quot;BEQ     $crx, done\n\t&quot;
10936             &quot;LI      $dst, #1\n&quot;
10937             &quot;done:&quot; %}
10938   size(16);
10939   ins_encode( enc_convI2B_regI__cmove(dst, src, crx, 0x0, 0x1) );
10940   ins_pipe(pipe_class_compare);
10941 %}
10942 
10943 // ConvI2B + XorI
10944 instruct xorI_convI2Bool_reg_immIvalue1__cntlz_Ex(iRegIdst dst, iRegIsrc src, immI_1 mask) %{
10945   match(Set dst (XorI (Conv2B src) mask));
10946   predicate(UseCountLeadingZerosInstructionsPPC64);
10947   ins_cost(DEFAULT_COST);
10948 
10949   expand %{
10950     immI shiftAmount %{ 0x5 %}
10951     iRegIdst tmp1;
10952     countLeadingZerosI(tmp1, src);
10953     urShiftI_reg_imm(dst, tmp1, shiftAmount);
10954   %}
10955 %}
10956 
10957 instruct xorI_convI2Bool_reg_immIvalue1__cmove(iRegIdst dst, iRegIsrc src, flagsReg crx, immI_1 mask) %{
10958   match(Set dst (XorI (Conv2B src) mask));
10959   effect(TEMP crx);
10960   predicate(!UseCountLeadingZerosInstructionsPPC64);
10961   ins_cost(DEFAULT_COST);
10962 
10963   format %{ &quot;CMPWI   $crx, $src, #0 \t// Xor(convI2B($src), $mask)&quot;
10964             &quot;LI      $dst, #1\n\t&quot;
10965             &quot;BEQ     $crx, done\n\t&quot;
10966             &quot;LI      $dst, #0\n&quot;
10967             &quot;done:&quot; %}
10968   size(16);
10969   ins_encode( enc_convI2B_regI__cmove(dst, src, crx, 0x1, 0x0) );
10970   ins_pipe(pipe_class_compare);
10971 %}
10972 
10973 // AndI 0b0..010..0 + ConvI2B
10974 instruct convI2Bool_andI_reg_immIpowerOf2(iRegIdst dst, iRegIsrc src, immIpowerOf2 mask) %{
10975   match(Set dst (Conv2B (AndI src mask)));
10976   predicate(UseRotateAndMaskInstructionsPPC64);
10977   ins_cost(DEFAULT_COST);
10978 
10979   format %{ &quot;RLWINM  $dst, $src, $mask \t// convI2B(AndI($src, $mask))&quot; %}
10980   size(4);
10981   ins_encode %{
10982     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
10983     __ rlwinm($dst$$Register, $src$$Register, (32-log2_long((jlong)$mask$$constant)) &amp; 0x1f, 31, 31);
10984   %}
10985   ins_pipe(pipe_class_default);
10986 %}
10987 
10988 // Convert pointer to boolean.
10989 //
10990 // ptr_to_bool(src) : { 1   if src != 0
10991 //                    { 0   else
10992 //
10993 // strategy:
10994 // 1) Count leading zeros of 64 bit-value src,
10995 //    this returns 64 (0b100.0000) iff src == 0 and &lt;64 otherwise.
10996 // 2) Shift 6 bits to the right, result is 0b1 iff src == 0, 0b0 otherwise.
10997 // 3) Xori the result to get 0b1 if src != 0 and 0b0 if src == 0.
10998 
10999 // ConvP2B
11000 instruct convP2Bool_reg__cntlz_Ex(iRegIdst dst, iRegP_N2P src) %{
11001   match(Set dst (Conv2B src));
11002   predicate(UseCountLeadingZerosInstructionsPPC64);
11003   ins_cost(DEFAULT_COST);
11004 
11005   expand %{
11006     immI shiftAmount %{ 0x6 %}
11007     uimmI16 mask %{ 0x1 %}
11008     iRegIdst tmp1;
11009     iRegIdst tmp2;
11010     countLeadingZerosP(tmp1, src);
11011     urShiftI_reg_imm(tmp2, tmp1, shiftAmount);
11012     xorI_reg_uimm16(dst, tmp2, mask);
11013   %}
11014 %}
11015 
11016 instruct convP2Bool_reg__cmove(iRegIdst dst, iRegP_N2P src, flagsReg crx) %{
11017   match(Set dst (Conv2B src));
11018   effect(TEMP crx);
11019   predicate(!UseCountLeadingZerosInstructionsPPC64);
11020   ins_cost(DEFAULT_COST);
11021 
11022   format %{ &quot;CMPDI   $crx, $src, #0 \t// convP2B&quot;
11023             &quot;LI      $dst, #0\n\t&quot;
11024             &quot;BEQ     $crx, done\n\t&quot;
11025             &quot;LI      $dst, #1\n&quot;
11026             &quot;done:&quot; %}
11027   size(16);
11028   ins_encode( enc_convP2B_regP__cmove(dst, src, crx, 0x0, 0x1) );
11029   ins_pipe(pipe_class_compare);
11030 %}
11031 
11032 // ConvP2B + XorI
11033 instruct xorI_convP2Bool_reg__cntlz_Ex(iRegIdst dst, iRegP_N2P src, immI_1 mask) %{
11034   match(Set dst (XorI (Conv2B src) mask));
11035   predicate(UseCountLeadingZerosInstructionsPPC64);
11036   ins_cost(DEFAULT_COST);
11037 
11038   expand %{
11039     immI shiftAmount %{ 0x6 %}
11040     iRegIdst tmp1;
11041     countLeadingZerosP(tmp1, src);
11042     urShiftI_reg_imm(dst, tmp1, shiftAmount);
11043   %}
11044 %}
11045 
11046 instruct xorI_convP2Bool_reg_immIvalue1__cmove(iRegIdst dst, iRegP_N2P src, flagsReg crx, immI_1 mask) %{
11047   match(Set dst (XorI (Conv2B src) mask));
11048   effect(TEMP crx);
11049   predicate(!UseCountLeadingZerosInstructionsPPC64);
11050   ins_cost(DEFAULT_COST);
11051 
11052   format %{ &quot;CMPDI   $crx, $src, #0 \t// XorI(convP2B($src), $mask)&quot;
11053             &quot;LI      $dst, #1\n\t&quot;
11054             &quot;BEQ     $crx, done\n\t&quot;
11055             &quot;LI      $dst, #0\n&quot;
11056             &quot;done:&quot; %}
11057   size(16);
11058   ins_encode( enc_convP2B_regP__cmove(dst, src, crx, 0x1, 0x0) );
11059   ins_pipe(pipe_class_compare);
11060 %}
11061 
11062 // if src1 &lt; src2, return -1 else return 0
11063 instruct cmpLTMask_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
11064   match(Set dst (CmpLTMask src1 src2));
11065   ins_cost(DEFAULT_COST*4);
11066 
11067   expand %{
11068     iRegLdst src1s;
11069     iRegLdst src2s;
11070     iRegLdst diff;
11071     convI2L_reg(src1s, src1); // Ensure proper sign extension.
11072     convI2L_reg(src2s, src2); // Ensure proper sign extension.
11073     subL_reg_reg(diff, src1s, src2s);
11074     // Need to consider &gt;=33 bit result, therefore we need signmaskL.
11075     signmask64I_regL(dst, diff);
11076   %}
11077 %}
11078 
11079 instruct cmpLTMask_reg_immI0(iRegIdst dst, iRegIsrc src1, immI_0 src2) %{
11080   match(Set dst (CmpLTMask src1 src2)); // if src1 &lt; src2, return -1 else return 0
11081   format %{ &quot;SRAWI   $dst, $src1, $src2 \t// CmpLTMask&quot; %}
11082   size(4);
11083   ins_encode %{
11084     // TODO: PPC port $archOpcode(ppc64Opcode_srawi);
11085     __ srawi($dst$$Register, $src1$$Register, 0x1f);
11086   %}
11087   ins_pipe(pipe_class_default);
11088 %}
11089 
11090 //----------Arithmetic Conversion Instructions---------------------------------
11091 
11092 // Convert to Byte  -- nop
11093 // Convert to Short -- nop
11094 
11095 // Convert to Int
11096 
11097 instruct convB2I_reg(iRegIdst dst, iRegIsrc src, immI_24 amount) %{
11098   match(Set dst (RShiftI (LShiftI src amount) amount));
11099   format %{ &quot;EXTSB   $dst, $src \t// byte-&gt;int&quot; %}
11100   size(4);
11101   ins_encode %{
11102     // TODO: PPC port $archOpcode(ppc64Opcode_extsb);
11103     __ extsb($dst$$Register, $src$$Register);
11104   %}
11105   ins_pipe(pipe_class_default);
11106 %}
11107 
11108 instruct extsh(iRegIdst dst, iRegIsrc src) %{
11109   effect(DEF dst, USE src);
11110 
11111   size(4);
11112   ins_encode %{
11113     __ extsh($dst$$Register, $src$$Register);
11114   %}
11115   ins_pipe(pipe_class_default);
11116 %}
11117 
11118 // LShiftI 16 + RShiftI 16 converts short to int.
11119 instruct convS2I_reg(iRegIdst dst, iRegIsrc src, immI_16 amount) %{
11120   match(Set dst (RShiftI (LShiftI src amount) amount));
11121   format %{ &quot;EXTSH   $dst, $src \t// short-&gt;int&quot; %}
11122   size(4);
11123   ins_encode %{
11124     // TODO: PPC port $archOpcode(ppc64Opcode_extsh);
11125     __ extsh($dst$$Register, $src$$Register);
11126   %}
11127   ins_pipe(pipe_class_default);
11128 %}
11129 
11130 // ConvL2I + ConvI2L: Sign extend int in long register.
11131 instruct sxtI_L2L_reg(iRegLdst dst, iRegLsrc src) %{
11132   match(Set dst (ConvI2L (ConvL2I src)));
11133 
11134   format %{ &quot;EXTSW   $dst, $src \t// long-&gt;long&quot; %}
11135   size(4);
11136   ins_encode %{
11137     // TODO: PPC port $archOpcode(ppc64Opcode_extsw);
11138     __ extsw($dst$$Register, $src$$Register);
11139   %}
11140   ins_pipe(pipe_class_default);
11141 %}
11142 
11143 instruct convL2I_reg(iRegIdst dst, iRegLsrc src) %{
11144   match(Set dst (ConvL2I src));
11145   format %{ &quot;MR      $dst, $src \t// long-&gt;int&quot; %}
11146   // variable size, 0 or 4
11147   ins_encode %{
11148     // TODO: PPC port $archOpcode(ppc64Opcode_or);
11149     __ mr_if_needed($dst$$Register, $src$$Register);
11150   %}
11151   ins_pipe(pipe_class_default);
11152 %}
11153 
11154 instruct convD2IRaw_regD(regD dst, regD src) %{
11155   // no match-rule, false predicate
11156   effect(DEF dst, USE src);
11157   predicate(false);
11158 
11159   format %{ &quot;FCTIWZ $dst, $src \t// convD2I, $src != NaN&quot; %}
11160   size(4);
11161   ins_encode %{
11162     // TODO: PPC port $archOpcode(ppc64Opcode_fctiwz);;
11163     __ fctiwz($dst$$FloatRegister, $src$$FloatRegister);
11164   %}
11165   ins_pipe(pipe_class_default);
11166 %}
11167 
11168 instruct cmovI_bso_stackSlotL(iRegIdst dst, flagsRegSrc crx, stackSlotL src) %{
11169   // no match-rule, false predicate
11170   effect(DEF dst, USE crx, USE src);
11171   predicate(false);
11172 
11173   ins_variable_size_depending_on_alignment(true);
11174 
11175   format %{ &quot;cmovI   $crx, $dst, $src&quot; %}
11176   // Worst case is branch + move + stop, no stop without scheduler.
11177   size((false /* TODO: PPC PORT(InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8));
11178   ins_encode( enc_cmove_bso_stackSlotL(dst, crx, src) );
11179   ins_pipe(pipe_class_default);
11180 %}
11181 
11182 instruct cmovI_bso_reg(iRegIdst dst, flagsRegSrc crx, regD src) %{
11183   // no match-rule, false predicate
11184   effect(DEF dst, USE crx, USE src);
11185   predicate(false);
11186 
11187   ins_variable_size_depending_on_alignment(true);
11188 
11189   format %{ &quot;cmovI   $crx, $dst, $src&quot; %}
11190   // Worst case is branch + move + stop, no stop without scheduler.
11191   size((false /* TODO: PPC PORT(InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8));
11192   ins_encode( enc_cmove_bso_reg(dst, crx, src) );
11193   ins_pipe(pipe_class_default);
11194 %}
11195 
11196 instruct cmovI_bso_stackSlotL_conLvalue0_Ex(iRegIdst dst, flagsRegSrc crx, stackSlotL mem) %{
11197   // no match-rule, false predicate
11198   effect(DEF dst, USE crx, USE mem);
11199   predicate(false);
11200 
11201   format %{ &quot;CmovI   $dst, $crx, $mem \t// postalloc expanded&quot; %}
11202   postalloc_expand %{
11203     //
11204     // replaces
11205     //
11206     //   region  dst  crx  mem
11207     //    \       |    |   /
11208     //     dst=cmovI_bso_stackSlotL_conLvalue0
11209     //
11210     // with
11211     //
11212     //   region  dst
11213     //    \       /
11214     //     dst=loadConI16(0)
11215     //      |
11216     //      ^  region  dst  crx  mem
11217     //      |   \       |    |    /
11218     //      dst=cmovI_bso_stackSlotL
11219     //
11220 
11221     // Create new nodes.
11222     MachNode *m1 = new loadConI16Node();
11223     MachNode *m2 = new cmovI_bso_stackSlotLNode();
11224 
11225     // inputs for new nodes
11226     m1-&gt;add_req(n_region);
11227     m2-&gt;add_req(n_region, n_crx, n_mem);
11228 
11229     // precedences for new nodes
11230     m2-&gt;add_prec(m1);
11231 
11232     // operands for new nodes
11233     m1-&gt;_opnds[0] = op_dst;
11234     m1-&gt;_opnds[1] = new immI16Oper(0);
11235 
11236     m2-&gt;_opnds[0] = op_dst;
11237     m2-&gt;_opnds[1] = op_crx;
11238     m2-&gt;_opnds[2] = op_mem;
11239 
11240     // registers for new nodes
11241     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11242     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11243 
11244     // Insert new nodes.
11245     nodes-&gt;push(m1);
11246     nodes-&gt;push(m2);
11247   %}
11248 %}
11249 
11250 instruct cmovI_bso_reg_conLvalue0_Ex(iRegIdst dst, flagsRegSrc crx, regD src) %{
11251   // no match-rule, false predicate
11252   effect(DEF dst, USE crx, USE src);
11253   predicate(false);
11254 
11255   format %{ &quot;CmovI   $dst, $crx, $src \t// postalloc expanded&quot; %}
11256   postalloc_expand %{
11257     //
11258     // replaces
11259     //
11260     //   region  dst  crx  src
11261     //    \       |    |   /
11262     //     dst=cmovI_bso_reg_conLvalue0
11263     //
11264     // with
11265     //
11266     //   region  dst
11267     //    \       /
11268     //     dst=loadConI16(0)
11269     //      |
11270     //      ^  region  dst  crx  src
11271     //      |   \       |    |    /
11272     //      dst=cmovI_bso_reg
11273     //
11274 
11275     // Create new nodes.
11276     MachNode *m1 = new loadConI16Node();
11277     MachNode *m2 = new cmovI_bso_regNode();
11278 
11279     // inputs for new nodes
11280     m1-&gt;add_req(n_region);
11281     m2-&gt;add_req(n_region, n_crx, n_src);
11282 
11283     // precedences for new nodes
11284     m2-&gt;add_prec(m1);
11285 
11286     // operands for new nodes
11287     m1-&gt;_opnds[0] = op_dst;
11288     m1-&gt;_opnds[1] = new immI16Oper(0);
11289 
11290     m2-&gt;_opnds[0] = op_dst;
11291     m2-&gt;_opnds[1] = op_crx;
11292     m2-&gt;_opnds[2] = op_src;
11293 
11294     // registers for new nodes
11295     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11296     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11297 
11298     // Insert new nodes.
11299     nodes-&gt;push(m1);
11300     nodes-&gt;push(m2);
11301   %}
11302 %}
11303 
11304 // Double to Int conversion, NaN is mapped to 0.
11305 instruct convD2I_reg_ExEx(iRegIdst dst, regD src) %{
11306   match(Set dst (ConvD2I src));
11307   predicate(!VM_Version::has_mtfprd());
11308   ins_cost(DEFAULT_COST);
11309 
11310   expand %{
11311     regD tmpD;
11312     stackSlotL tmpS;
11313     flagsReg crx;
11314     cmpDUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11315     convD2IRaw_regD(tmpD, src);                         // Convert float to int (speculated).
11316     moveD2L_reg_stack(tmpS, tmpD);                      // Store float to stack (speculated).
11317     cmovI_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); // Cmove based on NaN check.
11318   %}
11319 %}
11320 
11321 // Double to Int conversion, NaN is mapped to 0. Special version for Power8.
11322 instruct convD2I_reg_mffprd_ExEx(iRegIdst dst, regD src) %{
11323   match(Set dst (ConvD2I src));
11324   predicate(VM_Version::has_mtfprd());
11325   ins_cost(DEFAULT_COST);
11326 
11327   expand %{
11328     regD tmpD;
11329     flagsReg crx;
11330     cmpDUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11331     convD2IRaw_regD(tmpD, src);                         // Convert float to int (speculated).
11332     cmovI_bso_reg_conLvalue0_Ex(dst, crx, tmpD);        // Cmove based on NaN check.
11333   %}
11334 %}
11335 
11336 instruct convF2IRaw_regF(regF dst, regF src) %{
11337   // no match-rule, false predicate
11338   effect(DEF dst, USE src);
11339   predicate(false);
11340 
11341   format %{ &quot;FCTIWZ $dst, $src \t// convF2I, $src != NaN&quot; %}
11342   size(4);
11343   ins_encode %{
11344     // TODO: PPC port $archOpcode(ppc64Opcode_fctiwz);
11345     __ fctiwz($dst$$FloatRegister, $src$$FloatRegister);
11346   %}
11347   ins_pipe(pipe_class_default);
11348 %}
11349 
11350 // Float to Int conversion, NaN is mapped to 0.
11351 instruct convF2I_regF_ExEx(iRegIdst dst, regF src) %{
11352   match(Set dst (ConvF2I src));
11353   predicate(!VM_Version::has_mtfprd());
11354   ins_cost(DEFAULT_COST);
11355 
11356   expand %{
11357     regF tmpF;
11358     stackSlotL tmpS;
11359     flagsReg crx;
11360     cmpFUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11361     convF2IRaw_regF(tmpF, src);                         // Convert float to int (speculated).
11362     moveF2L_reg_stack(tmpS, tmpF);                      // Store float to stack (speculated).
11363     cmovI_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); // Cmove based on NaN check.
11364   %}
11365 %}
11366 
11367 // Float to Int conversion, NaN is mapped to 0. Special version for Power8.
11368 instruct convF2I_regF_mffprd_ExEx(iRegIdst dst, regF src) %{
11369   match(Set dst (ConvF2I src));
11370   predicate(VM_Version::has_mtfprd());
11371   ins_cost(DEFAULT_COST);
11372 
11373   expand %{
11374     regF tmpF;
11375     flagsReg crx;
11376     cmpFUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11377     convF2IRaw_regF(tmpF, src);                         // Convert float to int (speculated).
11378     cmovI_bso_reg_conLvalue0_Ex(dst, crx, tmpF);        // Cmove based on NaN check.
11379   %}
11380 %}
11381 
11382 // Convert to Long
11383 
11384 instruct convI2L_reg(iRegLdst dst, iRegIsrc src) %{
11385   match(Set dst (ConvI2L src));
11386   format %{ &quot;EXTSW   $dst, $src \t// int-&gt;long&quot; %}
11387   size(4);
11388   ins_encode %{
11389     // TODO: PPC port $archOpcode(ppc64Opcode_extsw);
11390     __ extsw($dst$$Register, $src$$Register);
11391   %}
11392   ins_pipe(pipe_class_default);
11393 %}
11394 
11395 // Zero-extend: convert unsigned int to long (convUI2L).
11396 instruct zeroExtendL_regI(iRegLdst dst, iRegIsrc src, immL_32bits mask) %{
11397   match(Set dst (AndL (ConvI2L src) mask));
11398   ins_cost(DEFAULT_COST);
11399 
11400   format %{ &quot;CLRLDI  $dst, $src, #32 \t// zero-extend int to long&quot; %}
11401   size(4);
11402   ins_encode %{
11403     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
11404     __ clrldi($dst$$Register, $src$$Register, 32);
11405   %}
11406   ins_pipe(pipe_class_default);
11407 %}
11408 
11409 // Zero-extend: convert unsigned int to long in long register.
11410 instruct zeroExtendL_regL(iRegLdst dst, iRegLsrc src, immL_32bits mask) %{
11411   match(Set dst (AndL src mask));
11412   ins_cost(DEFAULT_COST);
11413 
11414   format %{ &quot;CLRLDI  $dst, $src, #32 \t// zero-extend int to long&quot; %}
11415   size(4);
11416   ins_encode %{
11417     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
11418     __ clrldi($dst$$Register, $src$$Register, 32);
11419   %}
11420   ins_pipe(pipe_class_default);
11421 %}
11422 
11423 instruct convF2LRaw_regF(regF dst, regF src) %{
11424   // no match-rule, false predicate
11425   effect(DEF dst, USE src);
11426   predicate(false);
11427 
11428   format %{ &quot;FCTIDZ $dst, $src \t// convF2L, $src != NaN&quot; %}
11429   size(4);
11430   ins_encode %{
11431     // TODO: PPC port $archOpcode(ppc64Opcode_fctiwz);
11432     __ fctidz($dst$$FloatRegister, $src$$FloatRegister);
11433   %}
11434   ins_pipe(pipe_class_default);
11435 %}
11436 
11437 instruct cmovL_bso_stackSlotL(iRegLdst dst, flagsRegSrc crx, stackSlotL src) %{
11438   // no match-rule, false predicate
11439   effect(DEF dst, USE crx, USE src);
11440   predicate(false);
11441 
11442   ins_variable_size_depending_on_alignment(true);
11443 
11444   format %{ &quot;cmovL   $crx, $dst, $src&quot; %}
11445   // Worst case is branch + move + stop, no stop without scheduler.
11446   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
11447   ins_encode( enc_cmove_bso_stackSlotL(dst, crx, src) );
11448   ins_pipe(pipe_class_default);
11449 %}
11450 
11451 instruct cmovL_bso_reg(iRegLdst dst, flagsRegSrc crx, regD src) %{
11452   // no match-rule, false predicate
11453   effect(DEF dst, USE crx, USE src);
11454   predicate(false);
11455 
11456   ins_variable_size_depending_on_alignment(true);
11457 
11458   format %{ &quot;cmovL   $crx, $dst, $src&quot; %}
11459   // Worst case is branch + move + stop, no stop without scheduler.
11460   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
11461   ins_encode( enc_cmove_bso_reg(dst, crx, src) );
11462   ins_pipe(pipe_class_default);
11463 %}
11464 
11465 instruct cmovL_bso_stackSlotL_conLvalue0_Ex(iRegLdst dst, flagsRegSrc crx, stackSlotL mem) %{
11466   // no match-rule, false predicate
11467   effect(DEF dst, USE crx, USE mem);
11468   predicate(false);
11469 
11470   format %{ &quot;CmovL   $dst, $crx, $mem \t// postalloc expanded&quot; %}
11471   postalloc_expand %{
11472     //
11473     // replaces
11474     //
11475     //   region  dst  crx  mem
11476     //    \       |    |   /
11477     //     dst=cmovL_bso_stackSlotL_conLvalue0
11478     //
11479     // with
11480     //
11481     //   region  dst
11482     //    \       /
11483     //     dst=loadConL16(0)
11484     //      |
11485     //      ^  region  dst  crx  mem
11486     //      |   \       |    |    /
11487     //      dst=cmovL_bso_stackSlotL
11488     //
11489 
11490     // Create new nodes.
11491     MachNode *m1 = new loadConL16Node();
11492     MachNode *m2 = new cmovL_bso_stackSlotLNode();
11493 
11494     // inputs for new nodes
11495     m1-&gt;add_req(n_region);
11496     m2-&gt;add_req(n_region, n_crx, n_mem);
11497     m2-&gt;add_prec(m1);
11498 
11499     // operands for new nodes
11500     m1-&gt;_opnds[0] = op_dst;
11501     m1-&gt;_opnds[1] = new immL16Oper(0);
11502     m2-&gt;_opnds[0] = op_dst;
11503     m2-&gt;_opnds[1] = op_crx;
11504     m2-&gt;_opnds[2] = op_mem;
11505 
11506     // registers for new nodes
11507     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11508     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11509 
11510     // Insert new nodes.
11511     nodes-&gt;push(m1);
11512     nodes-&gt;push(m2);
11513   %}
11514 %}
11515 
11516 instruct cmovL_bso_reg_conLvalue0_Ex(iRegLdst dst, flagsRegSrc crx, regD src) %{
11517   // no match-rule, false predicate
11518   effect(DEF dst, USE crx, USE src);
11519   predicate(false);
11520 
11521   format %{ &quot;CmovL   $dst, $crx, $src \t// postalloc expanded&quot; %}
11522   postalloc_expand %{
11523     //
11524     // replaces
11525     //
11526     //   region  dst  crx  src
11527     //    \       |    |   /
11528     //     dst=cmovL_bso_reg_conLvalue0
11529     //
11530     // with
11531     //
11532     //   region  dst
11533     //    \       /
11534     //     dst=loadConL16(0)
11535     //      |
11536     //      ^  region  dst  crx  src
11537     //      |   \       |    |    /
11538     //      dst=cmovL_bso_reg
11539     //
11540 
11541     // Create new nodes.
11542     MachNode *m1 = new loadConL16Node();
11543     MachNode *m2 = new cmovL_bso_regNode();
11544 
11545     // inputs for new nodes
11546     m1-&gt;add_req(n_region);
11547     m2-&gt;add_req(n_region, n_crx, n_src);
11548     m2-&gt;add_prec(m1);
11549 
11550     // operands for new nodes
11551     m1-&gt;_opnds[0] = op_dst;
11552     m1-&gt;_opnds[1] = new immL16Oper(0);
11553     m2-&gt;_opnds[0] = op_dst;
11554     m2-&gt;_opnds[1] = op_crx;
11555     m2-&gt;_opnds[2] = op_src;
11556 
11557     // registers for new nodes
11558     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11559     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11560 
11561     // Insert new nodes.
11562     nodes-&gt;push(m1);
11563     nodes-&gt;push(m2);
11564   %}
11565 %}
11566 
11567 // Float to Long conversion, NaN is mapped to 0.
11568 instruct convF2L_reg_ExEx(iRegLdst dst, regF src) %{
11569   match(Set dst (ConvF2L src));
11570   predicate(!VM_Version::has_mtfprd());
11571   ins_cost(DEFAULT_COST);
11572 
11573   expand %{
11574     regF tmpF;
11575     stackSlotL tmpS;
11576     flagsReg crx;
11577     cmpFUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11578     convF2LRaw_regF(tmpF, src);                         // Convert float to long (speculated).
11579     moveF2L_reg_stack(tmpS, tmpF);                      // Store float to stack (speculated).
11580     cmovL_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); // Cmove based on NaN check.
11581   %}
11582 %}
11583 
11584 // Float to Long conversion, NaN is mapped to 0. Special version for Power8.
11585 instruct convF2L_reg_mffprd_ExEx(iRegLdst dst, regF src) %{
11586   match(Set dst (ConvF2L src));
11587   predicate(VM_Version::has_mtfprd());
11588   ins_cost(DEFAULT_COST);
11589 
11590   expand %{
11591     regF tmpF;
11592     flagsReg crx;
11593     cmpFUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11594     convF2LRaw_regF(tmpF, src);                         // Convert float to long (speculated).
11595     cmovL_bso_reg_conLvalue0_Ex(dst, crx, tmpF);        // Cmove based on NaN check.
11596   %}
11597 %}
11598 
11599 instruct convD2LRaw_regD(regD dst, regD src) %{
11600   // no match-rule, false predicate
11601   effect(DEF dst, USE src);
11602   predicate(false);
11603 
11604   format %{ &quot;FCTIDZ $dst, $src \t// convD2L $src != NaN&quot; %}
11605   size(4);
11606   ins_encode %{
11607     // TODO: PPC port $archOpcode(ppc64Opcode_fctiwz);
11608     __ fctidz($dst$$FloatRegister, $src$$FloatRegister);
11609   %}
11610   ins_pipe(pipe_class_default);
11611 %}
11612 
11613 // Double to Long conversion, NaN is mapped to 0.
11614 instruct convD2L_reg_ExEx(iRegLdst dst, regD src) %{
11615   match(Set dst (ConvD2L src));
11616   predicate(!VM_Version::has_mtfprd());
11617   ins_cost(DEFAULT_COST);
11618 
11619   expand %{
11620     regD tmpD;
11621     stackSlotL tmpS;
11622     flagsReg crx;
11623     cmpDUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11624     convD2LRaw_regD(tmpD, src);                         // Convert float to long (speculated).
11625     moveD2L_reg_stack(tmpS, tmpD);                      // Store float to stack (speculated).
11626     cmovL_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); // Cmove based on NaN check.
11627   %}
11628 %}
11629 
11630 // Double to Long conversion, NaN is mapped to 0. Special version for Power8.
11631 instruct convD2L_reg_mffprd_ExEx(iRegLdst dst, regD src) %{
11632   match(Set dst (ConvD2L src));
11633   predicate(VM_Version::has_mtfprd());
11634   ins_cost(DEFAULT_COST);
11635 
11636   expand %{
11637     regD tmpD;
11638     flagsReg crx;
11639     cmpDUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11640     convD2LRaw_regD(tmpD, src);                         // Convert float to long (speculated).
11641     cmovL_bso_reg_conLvalue0_Ex(dst, crx, tmpD);        // Cmove based on NaN check.
11642   %}
11643 %}
11644 
11645 // Convert to Float
11646 
11647 // Placed here as needed in expand.
11648 instruct convL2DRaw_regD(regD dst, regD src) %{
11649   // no match-rule, false predicate
11650   effect(DEF dst, USE src);
11651   predicate(false);
11652 
11653   format %{ &quot;FCFID $dst, $src \t// convL2D&quot; %}
11654   size(4);
11655   ins_encode %{
11656     // TODO: PPC port $archOpcode(ppc64Opcode_fcfid);
11657     __ fcfid($dst$$FloatRegister, $src$$FloatRegister);
11658   %}
11659   ins_pipe(pipe_class_default);
11660 %}
11661 
11662 // Placed here as needed in expand.
11663 instruct convD2F_reg(regF dst, regD src) %{
11664   match(Set dst (ConvD2F src));
11665   format %{ &quot;FRSP    $dst, $src \t// convD2F&quot; %}
11666   size(4);
11667   ins_encode %{
11668     // TODO: PPC port $archOpcode(ppc64Opcode_frsp);
11669     __ frsp($dst$$FloatRegister, $src$$FloatRegister);
11670   %}
11671   ins_pipe(pipe_class_default);
11672 %}
11673 
11674 // Integer to Float conversion.
11675 instruct convI2F_ireg_Ex(regF dst, iRegIsrc src) %{
11676   match(Set dst (ConvI2F src));
11677   predicate(!VM_Version::has_fcfids());
11678   ins_cost(DEFAULT_COST);
11679 
11680   expand %{
11681     iRegLdst tmpL;
11682     stackSlotL tmpS;
11683     regD tmpD;
11684     regD tmpD2;
11685     convI2L_reg(tmpL, src);              // Sign-extension int to long.
11686     regL_to_stkL(tmpS, tmpL);            // Store long to stack.
11687     moveL2D_stack_reg(tmpD, tmpS);       // Load long into double register.
11688     convL2DRaw_regD(tmpD2, tmpD);        // Convert to double.
11689     convD2F_reg(dst, tmpD2);             // Convert double to float.
11690   %}
11691 %}
11692 
11693 instruct convL2FRaw_regF(regF dst, regD src) %{
11694   // no match-rule, false predicate
11695   effect(DEF dst, USE src);
11696   predicate(false);
11697 
11698   format %{ &quot;FCFIDS $dst, $src \t// convL2F&quot; %}
11699   size(4);
11700   ins_encode %{
11701     // TODO: PPC port $archOpcode(ppc64Opcode_fcfid);
11702     __ fcfids($dst$$FloatRegister, $src$$FloatRegister);
11703   %}
11704   ins_pipe(pipe_class_default);
11705 %}
11706 
11707 // Integer to Float conversion. Special version for Power7.
11708 instruct convI2F_ireg_fcfids_Ex(regF dst, iRegIsrc src) %{
11709   match(Set dst (ConvI2F src));
11710   predicate(VM_Version::has_fcfids() &amp;&amp; !VM_Version::has_mtfprd());
11711   ins_cost(DEFAULT_COST);
11712 
11713   expand %{
11714     iRegLdst tmpL;
11715     stackSlotL tmpS;
11716     regD tmpD;
11717     convI2L_reg(tmpL, src);              // Sign-extension int to long.
11718     regL_to_stkL(tmpS, tmpL);            // Store long to stack.
11719     moveL2D_stack_reg(tmpD, tmpS);       // Load long into double register.
11720     convL2FRaw_regF(dst, tmpD);          // Convert to float.
11721   %}
11722 %}
11723 
11724 // Integer to Float conversion. Special version for Power8.
11725 instruct convI2F_ireg_mtfprd_Ex(regF dst, iRegIsrc src) %{
11726   match(Set dst (ConvI2F src));
11727   predicate(VM_Version::has_fcfids() &amp;&amp; VM_Version::has_mtfprd());
11728   ins_cost(DEFAULT_COST);
11729 
11730   expand %{
11731     regD tmpD;
11732     moveI2D_reg(tmpD, src);
11733     convL2FRaw_regF(dst, tmpD);          // Convert to float.
11734   %}
11735 %}
11736 
11737 // L2F to avoid runtime call.
11738 instruct convL2F_ireg_fcfids_Ex(regF dst, iRegLsrc src) %{
11739   match(Set dst (ConvL2F src));
11740   predicate(VM_Version::has_fcfids() &amp;&amp; !VM_Version::has_mtfprd());
11741   ins_cost(DEFAULT_COST);
11742 
11743   expand %{
11744     stackSlotL tmpS;
11745     regD tmpD;
11746     regL_to_stkL(tmpS, src);             // Store long to stack.
11747     moveL2D_stack_reg(tmpD, tmpS);       // Load long into double register.
11748     convL2FRaw_regF(dst, tmpD);          // Convert to float.
11749   %}
11750 %}
11751 
11752 // L2F to avoid runtime call.  Special version for Power8.
11753 instruct convL2F_ireg_mtfprd_Ex(regF dst, iRegLsrc src) %{
11754   match(Set dst (ConvL2F src));
11755   predicate(VM_Version::has_fcfids() &amp;&amp; VM_Version::has_mtfprd());
11756   ins_cost(DEFAULT_COST);
11757 
11758   expand %{
11759     regD tmpD;
11760     moveL2D_reg(tmpD, src);
11761     convL2FRaw_regF(dst, tmpD);          // Convert to float.
11762   %}
11763 %}
11764 
11765 // Moved up as used in expand.
11766 //instruct convD2F_reg(regF dst, regD src) %{%}
11767 
11768 // Convert to Double
11769 
11770 // Integer to Double conversion.
11771 instruct convI2D_reg_Ex(regD dst, iRegIsrc src) %{
11772   match(Set dst (ConvI2D src));
11773   predicate(!VM_Version::has_mtfprd());
11774   ins_cost(DEFAULT_COST);
11775 
11776   expand %{
11777     iRegLdst tmpL;
11778     stackSlotL tmpS;
11779     regD tmpD;
11780     convI2L_reg(tmpL, src);              // Sign-extension int to long.
11781     regL_to_stkL(tmpS, tmpL);            // Store long to stack.
11782     moveL2D_stack_reg(tmpD, tmpS);       // Load long into double register.
11783     convL2DRaw_regD(dst, tmpD);          // Convert to double.
11784   %}
11785 %}
11786 
11787 // Integer to Double conversion. Special version for Power8.
11788 instruct convI2D_reg_mtfprd_Ex(regD dst, iRegIsrc src) %{
11789   match(Set dst (ConvI2D src));
11790   predicate(VM_Version::has_mtfprd());
11791   ins_cost(DEFAULT_COST);
11792 
11793   expand %{
11794     regD tmpD;
11795     moveI2D_reg(tmpD, src);
11796     convL2DRaw_regD(dst, tmpD);          // Convert to double.
11797   %}
11798 %}
11799 
11800 // Long to Double conversion
11801 instruct convL2D_reg_Ex(regD dst, stackSlotL src) %{
11802   match(Set dst (ConvL2D src));
11803   ins_cost(DEFAULT_COST + MEMORY_REF_COST);
11804 
11805   expand %{
11806     regD tmpD;
11807     moveL2D_stack_reg(tmpD, src);
11808     convL2DRaw_regD(dst, tmpD);
11809   %}
11810 %}
11811 
11812 // Long to Double conversion. Special version for Power8.
11813 instruct convL2D_reg_mtfprd_Ex(regD dst, iRegLsrc src) %{
11814   match(Set dst (ConvL2D src));
11815   predicate(VM_Version::has_mtfprd());
11816   ins_cost(DEFAULT_COST);
11817 
11818   expand %{
11819     regD tmpD;
11820     moveL2D_reg(tmpD, src);
11821     convL2DRaw_regD(dst, tmpD);          // Convert to double.
11822   %}
11823 %}
11824 
11825 instruct convF2D_reg(regD dst, regF src) %{
11826   match(Set dst (ConvF2D src));
11827   format %{ &quot;FMR     $dst, $src \t// float-&gt;double&quot; %}
11828   // variable size, 0 or 4
11829   ins_encode %{
11830     // TODO: PPC port $archOpcode(ppc64Opcode_fmr);
11831     __ fmr_if_needed($dst$$FloatRegister, $src$$FloatRegister);
11832   %}
11833   ins_pipe(pipe_class_default);
11834 %}
11835 
11836 //----------Control Flow Instructions------------------------------------------
11837 // Compare Instructions
11838 
11839 // Compare Integers
11840 instruct cmpI_reg_reg(flagsReg crx, iRegIsrc src1, iRegIsrc src2) %{
11841   match(Set crx (CmpI src1 src2));
11842   size(4);
11843   format %{ &quot;CMPW    $crx, $src1, $src2&quot; %}
11844   ins_encode %{
11845     // TODO: PPC port $archOpcode(ppc64Opcode_cmp);
11846     __ cmpw($crx$$CondRegister, $src1$$Register, $src2$$Register);
11847   %}
11848   ins_pipe(pipe_class_compare);
11849 %}
11850 
11851 instruct cmpI_reg_imm16(flagsReg crx, iRegIsrc src1, immI16 src2) %{
11852   match(Set crx (CmpI src1 src2));
11853   format %{ &quot;CMPWI   $crx, $src1, $src2&quot; %}
11854   size(4);
11855   ins_encode %{
11856     // TODO: PPC port $archOpcode(ppc64Opcode_cmpi);
11857     __ cmpwi($crx$$CondRegister, $src1$$Register, $src2$$constant);
11858   %}
11859   ins_pipe(pipe_class_compare);
11860 %}
11861 
11862 // (src1 &amp; src2) == 0?
11863 instruct testI_reg_imm(flagsRegCR0 cr0, iRegIsrc src1, uimmI16 src2, immI_0 zero) %{
11864   match(Set cr0 (CmpI (AndI src1 src2) zero));
11865   // r0 is killed
11866   format %{ &quot;ANDI    R0, $src1, $src2 \t// BTST int&quot; %}
11867   size(4);
11868   ins_encode %{
11869     // TODO: PPC port $archOpcode(ppc64Opcode_andi_);
11870     __ andi_(R0, $src1$$Register, $src2$$constant);
11871   %}
11872   ins_pipe(pipe_class_compare);
11873 %}
11874 
11875 instruct cmpL_reg_reg(flagsReg crx, iRegLsrc src1, iRegLsrc src2) %{
11876   match(Set crx (CmpL src1 src2));
11877   format %{ &quot;CMPD    $crx, $src1, $src2&quot; %}
11878   size(4);
11879   ins_encode %{
11880     // TODO: PPC port $archOpcode(ppc64Opcode_cmp);
11881     __ cmpd($crx$$CondRegister, $src1$$Register, $src2$$Register);
11882   %}
11883   ins_pipe(pipe_class_compare);
11884 %}
11885 
11886 instruct cmpL_reg_imm16(flagsReg crx, iRegLsrc src1, immL16 src2) %{
11887   match(Set crx (CmpL src1 src2));
11888   format %{ &quot;CMPDI   $crx, $src1, $src2&quot; %}
11889   size(4);
11890   ins_encode %{
11891     // TODO: PPC port $archOpcode(ppc64Opcode_cmpi);
11892     __ cmpdi($crx$$CondRegister, $src1$$Register, $src2$$constant);
11893   %}
11894   ins_pipe(pipe_class_compare);
11895 %}
11896 
11897 // Added CmpUL for LoopPredicate.
11898 instruct cmpUL_reg_reg(flagsReg crx, iRegLsrc src1, iRegLsrc src2) %{
11899   match(Set crx (CmpUL src1 src2));
11900   format %{ &quot;CMPLD   $crx, $src1, $src2&quot; %}
11901   size(4);
11902   ins_encode %{
11903     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
11904     __ cmpld($crx$$CondRegister, $src1$$Register, $src2$$Register);
11905   %}
11906   ins_pipe(pipe_class_compare);
11907 %}
11908 
11909 instruct cmpUL_reg_imm16(flagsReg crx, iRegLsrc src1, uimmL16 src2) %{
11910   match(Set crx (CmpUL src1 src2));
11911   format %{ &quot;CMPLDI  $crx, $src1, $src2&quot; %}
11912   size(4);
11913   ins_encode %{
11914     // TODO: PPC port $archOpcode(ppc64Opcode_cmpli);
11915     __ cmpldi($crx$$CondRegister, $src1$$Register, $src2$$constant);
11916   %}
11917   ins_pipe(pipe_class_compare);
11918 %}
11919 
11920 instruct testL_reg_reg(flagsRegCR0 cr0, iRegLsrc src1, iRegLsrc src2, immL_0 zero) %{
11921   match(Set cr0 (CmpL (AndL src1 src2) zero));
11922   // r0 is killed
11923   format %{ &quot;AND     R0, $src1, $src2 \t// BTST long&quot; %}
11924   size(4);
11925   ins_encode %{
11926     // TODO: PPC port $archOpcode(ppc64Opcode_and_);
11927     __ and_(R0, $src1$$Register, $src2$$Register);
11928   %}
11929   ins_pipe(pipe_class_compare);
11930 %}
11931 
11932 instruct testL_reg_imm(flagsRegCR0 cr0, iRegLsrc src1, uimmL16 src2, immL_0 zero) %{
11933   match(Set cr0 (CmpL (AndL src1 src2) zero));
11934   // r0 is killed
11935   format %{ &quot;ANDI    R0, $src1, $src2 \t// BTST long&quot; %}
11936   size(4);
11937   ins_encode %{
11938     // TODO: PPC port $archOpcode(ppc64Opcode_andi_);
11939     __ andi_(R0, $src1$$Register, $src2$$constant);
11940   %}
11941   ins_pipe(pipe_class_compare);
11942 %}
11943 
11944 instruct cmovI_conIvalueMinus1_conIvalue1(iRegIdst dst, flagsRegSrc crx) %{
11945   // no match-rule, false predicate
11946   effect(DEF dst, USE crx);
11947   predicate(false);
11948 
11949   ins_variable_size_depending_on_alignment(true);
11950 
11951   format %{ &quot;cmovI   $crx, $dst, -1, 0, +1&quot; %}
11952   // Worst case is branch + move + branch + move + stop, no stop without scheduler.
11953   size((false /* TODO: PPC PORTInsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 20 : 16));
11954   ins_encode %{
11955     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
11956     Label done;
11957     // li(Rdst, 0);              // equal -&gt; 0
11958     __ beq($crx$$CondRegister, done);
11959     __ li($dst$$Register, 1);    // greater -&gt; +1
11960     __ bgt($crx$$CondRegister, done);
11961     __ li($dst$$Register, -1);   // unordered or less -&gt; -1
11962     // TODO: PPC port__ endgroup_if_needed(_size == 20);
11963     __ bind(done);
11964   %}
11965   ins_pipe(pipe_class_compare);
11966 %}
11967 
11968 instruct cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(iRegIdst dst, flagsRegSrc crx) %{
11969   // no match-rule, false predicate
11970   effect(DEF dst, USE crx);
11971   predicate(false);
11972 
11973   format %{ &quot;CmovI    $crx, $dst, -1, 0, +1 \t// postalloc expanded&quot; %}
11974   postalloc_expand %{
11975     //
11976     // replaces
11977     //
11978     //   region  crx
11979     //    \       |
11980     //     dst=cmovI_conIvalueMinus1_conIvalue0_conIvalue1
11981     //
11982     // with
11983     //
11984     //   region
11985     //    \
11986     //     dst=loadConI16(0)
11987     //      |
11988     //      ^  region  crx
11989     //      |   \       |
11990     //      dst=cmovI_conIvalueMinus1_conIvalue1
11991     //
11992 
11993     // Create new nodes.
11994     MachNode *m1 = new loadConI16Node();
11995     MachNode *m2 = new cmovI_conIvalueMinus1_conIvalue1Node();
11996 
11997     // inputs for new nodes
11998     m1-&gt;add_req(n_region);
11999     m2-&gt;add_req(n_region, n_crx);
12000     m2-&gt;add_prec(m1);
12001 
12002     // operands for new nodes
12003     m1-&gt;_opnds[0] = op_dst;
12004     m1-&gt;_opnds[1] = new immI16Oper(0);
12005     m2-&gt;_opnds[0] = op_dst;
12006     m2-&gt;_opnds[1] = op_crx;
12007 
12008     // registers for new nodes
12009     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
12010     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
12011 
12012     // Insert new nodes.
12013     nodes-&gt;push(m1);
12014     nodes-&gt;push(m2);
12015   %}
12016 %}
12017 
12018 // Manifest a CmpL3 result in an integer register. Very painful.
12019 // This is the test to avoid.
12020 // (src1 &lt; src2) ? -1 : ((src1 &gt; src2) ? 1 : 0)
12021 instruct cmpL3_reg_reg_ExEx(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
12022   match(Set dst (CmpL3 src1 src2));
12023   ins_cost(DEFAULT_COST*5+BRANCH_COST);
12024 
12025   expand %{
12026     flagsReg tmp1;
12027     cmpL_reg_reg(tmp1, src1, src2);
12028     cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(dst, tmp1);
12029   %}
12030 %}
12031 
12032 // Implicit range checks.
12033 // A range check in the ideal world has one of the following shapes:
12034 //  - (If le (CmpU length index)), (IfTrue  throw exception)
12035 //  - (If lt (CmpU index length)), (IfFalse throw exception)
12036 //
12037 // Match range check &#39;If le (CmpU length index)&#39;.
12038 instruct rangeCheck_iReg_uimm15(cmpOp cmp, iRegIsrc src_length, uimmI15 index, label labl) %{
12039   match(If cmp (CmpU src_length index));
12040   effect(USE labl);
12041   predicate(TrapBasedRangeChecks &amp;&amp;
12042             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le &amp;&amp;
12043             PROB_UNLIKELY(_leaf-&gt;as_If()-&gt;_prob) &gt;= PROB_ALWAYS &amp;&amp;
12044             (Matcher::branches_to_uncommon_trap(_leaf)));
12045 
12046   ins_is_TrapBasedCheckNode(true);
12047 
12048   format %{ &quot;TWI     $index $cmp $src_length \t// RangeCheck =&gt; trap $labl&quot; %}
12049   size(4);
12050   ins_encode %{
12051     // TODO: PPC port $archOpcode(ppc64Opcode_twi);
12052     if ($cmp$$cmpcode == 0x1 /* less_equal */) {
12053       __ trap_range_check_le($src_length$$Register, $index$$constant);
12054     } else {
12055       // Both successors are uncommon traps, probability is 0.
12056       // Node got flipped during fixup flow.
12057       assert($cmp$$cmpcode == 0x9, &quot;must be greater&quot;);
12058       __ trap_range_check_g($src_length$$Register, $index$$constant);
12059     }
12060   %}
12061   ins_pipe(pipe_class_trap);
12062 %}
12063 
12064 // Match range check &#39;If lt (CmpU index length)&#39;.
12065 instruct rangeCheck_iReg_iReg(cmpOp cmp, iRegIsrc src_index, iRegIsrc src_length, label labl) %{
12066   match(If cmp (CmpU src_index src_length));
12067   effect(USE labl);
12068   predicate(TrapBasedRangeChecks &amp;&amp;
12069             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt &amp;&amp;
12070             _leaf-&gt;as_If()-&gt;_prob &gt;= PROB_ALWAYS &amp;&amp;
12071             (Matcher::branches_to_uncommon_trap(_leaf)));
12072 
12073   ins_is_TrapBasedCheckNode(true);
12074 
12075   format %{ &quot;TW      $src_index $cmp $src_length \t// RangeCheck =&gt; trap $labl&quot; %}
12076   size(4);
12077   ins_encode %{
12078     // TODO: PPC port $archOpcode(ppc64Opcode_tw);
12079     if ($cmp$$cmpcode == 0x0 /* greater_equal */) {
12080       __ trap_range_check_ge($src_index$$Register, $src_length$$Register);
12081     } else {
12082       // Both successors are uncommon traps, probability is 0.
12083       // Node got flipped during fixup flow.
12084       assert($cmp$$cmpcode == 0x8, &quot;must be less&quot;);
12085       __ trap_range_check_l($src_index$$Register, $src_length$$Register);
12086     }
12087   %}
12088   ins_pipe(pipe_class_trap);
12089 %}
12090 
12091 // Match range check &#39;If lt (CmpU index length)&#39;.
12092 instruct rangeCheck_uimm15_iReg(cmpOp cmp, iRegIsrc src_index, uimmI15 length, label labl) %{
12093   match(If cmp (CmpU src_index length));
12094   effect(USE labl);
12095   predicate(TrapBasedRangeChecks &amp;&amp;
12096             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt &amp;&amp;
12097             _leaf-&gt;as_If()-&gt;_prob &gt;= PROB_ALWAYS &amp;&amp;
12098             (Matcher::branches_to_uncommon_trap(_leaf)));
12099 
12100   ins_is_TrapBasedCheckNode(true);
12101 
12102   format %{ &quot;TWI     $src_index $cmp $length \t// RangeCheck =&gt; trap $labl&quot; %}
12103   size(4);
12104   ins_encode %{
12105     // TODO: PPC port $archOpcode(ppc64Opcode_twi);
12106     if ($cmp$$cmpcode == 0x0 /* greater_equal */) {
12107       __ trap_range_check_ge($src_index$$Register, $length$$constant);
12108     } else {
12109       // Both successors are uncommon traps, probability is 0.
12110       // Node got flipped during fixup flow.
12111       assert($cmp$$cmpcode == 0x8, &quot;must be less&quot;);
12112       __ trap_range_check_l($src_index$$Register, $length$$constant);
12113     }
12114   %}
12115   ins_pipe(pipe_class_trap);
12116 %}
12117 
12118 instruct compU_reg_reg(flagsReg crx, iRegIsrc src1, iRegIsrc src2) %{
12119   match(Set crx (CmpU src1 src2));
12120   format %{ &quot;CMPLW   $crx, $src1, $src2 \t// unsigned&quot; %}
12121   size(4);
12122   ins_encode %{
12123     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
12124     __ cmplw($crx$$CondRegister, $src1$$Register, $src2$$Register);
12125   %}
12126   ins_pipe(pipe_class_compare);
12127 %}
12128 
12129 instruct compU_reg_uimm16(flagsReg crx, iRegIsrc src1, uimmI16 src2) %{
12130   match(Set crx (CmpU src1 src2));
12131   size(4);
12132   format %{ &quot;CMPLWI  $crx, $src1, $src2&quot; %}
12133   ins_encode %{
12134     // TODO: PPC port $archOpcode(ppc64Opcode_cmpli);
12135     __ cmplwi($crx$$CondRegister, $src1$$Register, $src2$$constant);
12136   %}
12137   ins_pipe(pipe_class_compare);
12138 %}
12139 
12140 // Implicit zero checks (more implicit null checks).
12141 // No constant pool entries required.
12142 instruct zeroCheckN_iReg_imm0(cmpOp cmp, iRegNsrc value, immN_0 zero, label labl) %{
12143   match(If cmp (CmpN value zero));
12144   effect(USE labl);
12145   predicate(TrapBasedNullChecks &amp;&amp;
12146             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
12147             _leaf-&gt;as_If()-&gt;_prob &gt;= PROB_LIKELY_MAG(4) &amp;&amp;
12148             Matcher::branches_to_uncommon_trap(_leaf));
12149   ins_cost(1);
12150 
12151   ins_is_TrapBasedCheckNode(true);
12152 
12153   format %{ &quot;TDI     $value $cmp $zero \t// ZeroCheckN =&gt; trap $labl&quot; %}
12154   size(4);
12155   ins_encode %{
12156     // TODO: PPC port $archOpcode(ppc64Opcode_tdi);
12157     if ($cmp$$cmpcode == 0xA) {
12158       __ trap_null_check($value$$Register);
12159     } else {
12160       // Both successors are uncommon traps, probability is 0.
12161       // Node got flipped during fixup flow.
12162       assert($cmp$$cmpcode == 0x2 , &quot;must be equal(0xA) or notEqual(0x2)&quot;);
12163       __ trap_null_check($value$$Register, Assembler::traptoGreaterThanUnsigned);
12164     }
12165   %}
12166   ins_pipe(pipe_class_trap);
12167 %}
12168 
12169 // Compare narrow oops.
12170 instruct cmpN_reg_reg(flagsReg crx, iRegNsrc src1, iRegNsrc src2) %{
12171   match(Set crx (CmpN src1 src2));
12172 
12173   size(4);
12174   ins_cost(2);
12175   format %{ &quot;CMPLW   $crx, $src1, $src2 \t// compressed ptr&quot; %}
12176   ins_encode %{
12177     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
12178     __ cmplw($crx$$CondRegister, $src1$$Register, $src2$$Register);
12179   %}
12180   ins_pipe(pipe_class_compare);
12181 %}
12182 
12183 instruct cmpN_reg_imm0(flagsReg crx, iRegNsrc src1, immN_0 src2) %{
12184   match(Set crx (CmpN src1 src2));
12185   // Make this more expensive than zeroCheckN_iReg_imm0.
12186   ins_cost(2);
12187 
12188   format %{ &quot;CMPLWI  $crx, $src1, $src2 \t// compressed ptr&quot; %}
12189   size(4);
12190   ins_encode %{
12191     // TODO: PPC port $archOpcode(ppc64Opcode_cmpli);
12192     __ cmplwi($crx$$CondRegister, $src1$$Register, $src2$$constant);
12193   %}
12194   ins_pipe(pipe_class_compare);
12195 %}
12196 
12197 // Implicit zero checks (more implicit null checks).
12198 // No constant pool entries required.
12199 instruct zeroCheckP_reg_imm0(cmpOp cmp, iRegP_N2P value, immP_0 zero, label labl) %{
12200   match(If cmp (CmpP value zero));
12201   effect(USE labl);
12202   predicate(TrapBasedNullChecks &amp;&amp;
12203             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
12204             _leaf-&gt;as_If()-&gt;_prob &gt;= PROB_LIKELY_MAG(4) &amp;&amp;
12205             Matcher::branches_to_uncommon_trap(_leaf));
12206   ins_cost(1); // Should not be cheaper than zeroCheckN.
12207 
12208   ins_is_TrapBasedCheckNode(true);
12209 
12210   format %{ &quot;TDI     $value $cmp $zero \t// ZeroCheckP =&gt; trap $labl&quot; %}
12211   size(4);
12212   ins_encode %{
12213     // TODO: PPC port $archOpcode(ppc64Opcode_tdi);
12214     if ($cmp$$cmpcode == 0xA) {
12215       __ trap_null_check($value$$Register);
12216     } else {
12217       // Both successors are uncommon traps, probability is 0.
12218       // Node got flipped during fixup flow.
12219       assert($cmp$$cmpcode == 0x2 , &quot;must be equal(0xA) or notEqual(0x2)&quot;);
12220       __ trap_null_check($value$$Register, Assembler::traptoGreaterThanUnsigned);
12221     }
12222   %}
12223   ins_pipe(pipe_class_trap);
12224 %}
12225 
12226 // Compare Pointers
12227 instruct cmpP_reg_reg(flagsReg crx, iRegP_N2P src1, iRegP_N2P src2) %{
12228   match(Set crx (CmpP src1 src2));
12229   format %{ &quot;CMPLD   $crx, $src1, $src2 \t// ptr&quot; %}
12230   size(4);
12231   ins_encode %{
12232     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
12233     __ cmpld($crx$$CondRegister, $src1$$Register, $src2$$Register);
12234   %}
12235   ins_pipe(pipe_class_compare);
12236 %}
12237 
12238 instruct cmpP_reg_null(flagsReg crx, iRegP_N2P src1, immP_0or1 src2) %{
12239   match(Set crx (CmpP src1 src2));
12240   format %{ &quot;CMPLDI   $crx, $src1, $src2 \t// ptr&quot; %}
12241   size(4);
12242   ins_encode %{
12243     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
12244     __ cmpldi($crx$$CondRegister, $src1$$Register, (int)((short)($src2$$constant &amp; 0xFFFF)));
12245   %}
12246   ins_pipe(pipe_class_compare);
12247 %}
12248 
12249 // Used in postalloc expand.
12250 instruct cmpP_reg_imm16(flagsReg crx, iRegPsrc src1, immL16 src2) %{
12251   // This match rule prevents reordering of node before a safepoint.
12252   // This only makes sense if this instructions is used exclusively
12253   // for the expansion of EncodeP!
12254   match(Set crx (CmpP src1 src2));
12255   predicate(false);
12256 
12257   format %{ &quot;CMPDI   $crx, $src1, $src2&quot; %}
12258   size(4);
12259   ins_encode %{
12260     // TODO: PPC port $archOpcode(ppc64Opcode_cmpi);
12261     __ cmpdi($crx$$CondRegister, $src1$$Register, $src2$$constant);
12262   %}
12263   ins_pipe(pipe_class_compare);
12264 %}
12265 
12266 //----------Float Compares----------------------------------------------------
12267 
12268 instruct cmpFUnordered_reg_reg(flagsReg crx, regF src1, regF src2) %{
12269   // Needs matchrule, see cmpDUnordered.
12270   match(Set crx (CmpF src1 src2));
12271   // no match-rule, false predicate
12272   predicate(false);
12273 
12274   format %{ &quot;cmpFUrd $crx, $src1, $src2&quot; %}
12275   size(4);
12276   ins_encode %{
12277     // TODO: PPC port $archOpcode(ppc64Opcode_fcmpu);
12278     __ fcmpu($crx$$CondRegister, $src1$$FloatRegister, $src2$$FloatRegister);
12279   %}
12280   ins_pipe(pipe_class_default);
12281 %}
12282 
12283 instruct cmov_bns_less(flagsReg crx) %{
12284   // no match-rule, false predicate
12285   effect(DEF crx);
12286   predicate(false);
12287 
12288   ins_variable_size_depending_on_alignment(true);
12289 
12290   format %{ &quot;cmov    $crx&quot; %}
12291   // Worst case is branch + move + stop, no stop without scheduler.
12292   size((false /* TODO: PPC PORT(InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 16 : 12));
12293   ins_encode %{
12294     // TODO: PPC port $archOpcode(ppc64Opcode_cmovecr);
12295     Label done;
12296     __ bns($crx$$CondRegister, done);        // not unordered -&gt; keep crx
12297     __ li(R0, 0);
12298     __ cmpwi($crx$$CondRegister, R0, 1);     // unordered -&gt; set crx to &#39;less&#39;
12299     // TODO PPC port __ endgroup_if_needed(_size == 16);
12300     __ bind(done);
12301   %}
12302   ins_pipe(pipe_class_default);
12303 %}
12304 
12305 // Compare floating, generate condition code.
12306 instruct cmpF_reg_reg_Ex(flagsReg crx, regF src1, regF src2) %{
12307   // FIXME: should we match &#39;If cmp (CmpF src1 src2))&#39; ??
12308   //
12309   // The following code sequence occurs a lot in mpegaudio:
12310   //
12311   // block BXX:
12312   // 0: instruct cmpFUnordered_reg_reg (cmpF_reg_reg-0):
12313   //    cmpFUrd CCR6, F11, F9
12314   // 4: instruct cmov_bns_less (cmpF_reg_reg-1):
12315   //    cmov CCR6
12316   // 8: instruct branchConSched:
12317   //    B_FARle CCR6, B56  P=0.500000 C=-1.000000
12318   match(Set crx (CmpF src1 src2));
12319   ins_cost(DEFAULT_COST+BRANCH_COST);
12320 
12321   format %{ &quot;CmpF    $crx, $src1, $src2 \t// postalloc expanded&quot; %}
12322   postalloc_expand %{
12323     //
12324     // replaces
12325     //
12326     //   region  src1  src2
12327     //    \       |     |
12328     //     crx=cmpF_reg_reg
12329     //
12330     // with
12331     //
12332     //   region  src1  src2
12333     //    \       |     |
12334     //     crx=cmpFUnordered_reg_reg
12335     //      |
12336     //      ^  region
12337     //      |   \
12338     //      crx=cmov_bns_less
12339     //
12340 
12341     // Create new nodes.
12342     MachNode *m1 = new cmpFUnordered_reg_regNode();
12343     MachNode *m2 = new cmov_bns_lessNode();
12344 
12345     // inputs for new nodes
12346     m1-&gt;add_req(n_region, n_src1, n_src2);
12347     m2-&gt;add_req(n_region);
12348     m2-&gt;add_prec(m1);
12349 
12350     // operands for new nodes
12351     m1-&gt;_opnds[0] = op_crx;
12352     m1-&gt;_opnds[1] = op_src1;
12353     m1-&gt;_opnds[2] = op_src2;
12354     m2-&gt;_opnds[0] = op_crx;
12355 
12356     // registers for new nodes
12357     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // crx
12358     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // crx
12359 
12360     // Insert new nodes.
12361     nodes-&gt;push(m1);
12362     nodes-&gt;push(m2);
12363   %}
12364 %}
12365 
12366 // Compare float, generate -1,0,1
12367 instruct cmpF3_reg_reg_ExEx(iRegIdst dst, regF src1, regF src2) %{
12368   match(Set dst (CmpF3 src1 src2));
12369   ins_cost(DEFAULT_COST*5+BRANCH_COST);
12370 
12371   expand %{
12372     flagsReg tmp1;
12373     cmpFUnordered_reg_reg(tmp1, src1, src2);
12374     cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(dst, tmp1);
12375   %}
12376 %}
12377 
12378 instruct cmpDUnordered_reg_reg(flagsReg crx, regD src1, regD src2) %{
12379   // Needs matchrule so that ideal opcode is Cmp. This causes that gcm places the
12380   // node right before the conditional move using it.
12381   // In jck test api/java_awt/geom/QuadCurve2DFloat/index.html#SetCurveTesttestCase7,
12382   // compilation of java.awt.geom.RectangularShape::getBounds()Ljava/awt/Rectangle
12383   // crashed in register allocation where the flags Reg between cmpDUnoredered and a
12384   // conditional move was supposed to be spilled.
12385   match(Set crx (CmpD src1 src2));
12386   // False predicate, shall not be matched.
12387   predicate(false);
12388 
12389   format %{ &quot;cmpFUrd $crx, $src1, $src2&quot; %}
12390   size(4);
12391   ins_encode %{
12392     // TODO: PPC port $archOpcode(ppc64Opcode_fcmpu);
12393     __ fcmpu($crx$$CondRegister, $src1$$FloatRegister, $src2$$FloatRegister);
12394   %}
12395   ins_pipe(pipe_class_default);
12396 %}
12397 
12398 instruct cmpD_reg_reg_Ex(flagsReg crx, regD src1, regD src2) %{
12399   match(Set crx (CmpD src1 src2));
12400   ins_cost(DEFAULT_COST+BRANCH_COST);
12401 
12402   format %{ &quot;CmpD    $crx, $src1, $src2 \t// postalloc expanded&quot; %}
12403   postalloc_expand %{
12404     //
12405     // replaces
12406     //
12407     //   region  src1  src2
12408     //    \       |     |
12409     //     crx=cmpD_reg_reg
12410     //
12411     // with
12412     //
12413     //   region  src1  src2
12414     //    \       |     |
12415     //     crx=cmpDUnordered_reg_reg
12416     //      |
12417     //      ^  region
12418     //      |   \
12419     //      crx=cmov_bns_less
12420     //
12421 
12422     // create new nodes
12423     MachNode *m1 = new cmpDUnordered_reg_regNode();
12424     MachNode *m2 = new cmov_bns_lessNode();
12425 
12426     // inputs for new nodes
12427     m1-&gt;add_req(n_region, n_src1, n_src2);
12428     m2-&gt;add_req(n_region);
12429     m2-&gt;add_prec(m1);
12430 
12431     // operands for new nodes
12432     m1-&gt;_opnds[0] = op_crx;
12433     m1-&gt;_opnds[1] = op_src1;
12434     m1-&gt;_opnds[2] = op_src2;
12435     m2-&gt;_opnds[0] = op_crx;
12436 
12437     // registers for new nodes
12438     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // crx
12439     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // crx
12440 
12441     // Insert new nodes.
12442     nodes-&gt;push(m1);
12443     nodes-&gt;push(m2);
12444   %}
12445 %}
12446 
12447 // Compare double, generate -1,0,1
12448 instruct cmpD3_reg_reg_ExEx(iRegIdst dst, regD src1, regD src2) %{
12449   match(Set dst (CmpD3 src1 src2));
12450   ins_cost(DEFAULT_COST*5+BRANCH_COST);
12451 
12452   expand %{
12453     flagsReg tmp1;
12454     cmpDUnordered_reg_reg(tmp1, src1, src2);
12455     cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(dst, tmp1);
12456   %}
12457 %}
12458 
12459 // Compare char
12460 instruct cmprb_Digit_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsReg crx) %{
12461   match(Set dst (Digit src1));
12462   effect(TEMP src2, TEMP crx);
12463   ins_cost(3 * DEFAULT_COST);
12464 
12465   format %{ &quot;LI      $src2, 0x3930\n\t&quot;
12466             &quot;CMPRB   $crx, 0, $src1, $src2\n\t&quot;
12467             &quot;SETB    $dst, $crx&quot; %}
12468   size(12);
12469   ins_encode %{
12470     // 0x30: 0, 0x39: 9
12471     __ li($src2$$Register, 0x3930);
12472     // compare src1 with ranges 0x30 to 0x39
12473     __ cmprb($crx$$CondRegister, 0, $src1$$Register, $src2$$Register);
12474     __ setb($dst$$Register, $crx$$CondRegister);
12475   %}
12476   ins_pipe(pipe_class_default);
12477 %}
12478 
12479 instruct cmprb_LowerCase_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsReg crx) %{
12480   match(Set dst (LowerCase src1));
12481   effect(TEMP src2, TEMP crx);
12482   ins_cost(12 * DEFAULT_COST);
12483 
12484   format %{ &quot;LI      $src2, 0x7A61\n\t&quot;
12485             &quot;CMPRB   $crx, 0, $src1, $src2\n\t&quot;
12486             &quot;BGT     $crx, done\n\t&quot;
12487             &quot;LIS     $src2, (signed short)0xF6DF\n\t&quot;
12488             &quot;ORI     $src2, $src2, 0xFFF8\n\t&quot;
12489             &quot;CMPRB   $crx, 1, $src1, $src2\n\t&quot;
12490             &quot;BGT     $crx, done\n\t&quot;
12491             &quot;LIS     $src2, (signed short)0xAAB5\n\t&quot;
12492             &quot;ORI     $src2, $src2, 0xBABA\n\t&quot;
12493             &quot;INSRDI  $src2, $src2, 32, 0\n\t&quot;
12494             &quot;CMPEQB  $crx, 1, $src1, $src2\n&quot;
12495             &quot;done:\n\t&quot;
12496             &quot;SETB    $dst, $crx&quot; %}
12497 
12498   size(48);
12499   ins_encode %{
12500     Label done;
12501     // 0x61: a, 0x7A: z
12502     __ li($src2$$Register, 0x7A61);
12503     // compare src1 with ranges 0x61 to 0x7A
12504     __ cmprb($crx$$CondRegister, 0, $src1$$Register, $src2$$Register);
12505     __ bgt($crx$$CondRegister, done);
12506 
12507     // 0xDF: sharp s, 0xFF: y with diaeresis, 0xF7 is not the lower case
12508     __ lis($src2$$Register, (signed short)0xF6DF);
12509     __ ori($src2$$Register, $src2$$Register, 0xFFF8);
12510     // compare src1 with ranges 0xDF to 0xF6 and 0xF8 to 0xFF
12511     __ cmprb($crx$$CondRegister, 1, $src1$$Register, $src2$$Register);
12512     __ bgt($crx$$CondRegister, done);
12513 
12514     // 0xAA: feminine ordinal indicator
12515     // 0xB5: micro sign
12516     // 0xBA: masculine ordinal indicator
12517     __ lis($src2$$Register, (signed short)0xAAB5);
12518     __ ori($src2$$Register, $src2$$Register, 0xBABA);
12519     __ insrdi($src2$$Register, $src2$$Register, 32, 0);
12520     // compare src1 with 0xAA, 0xB5, and 0xBA
12521     __ cmpeqb($crx$$CondRegister, $src1$$Register, $src2$$Register);
12522 
12523     __ bind(done);
12524     __ setb($dst$$Register, $crx$$CondRegister);
12525   %}
12526   ins_pipe(pipe_class_default);
12527 %}
12528 
12529 instruct cmprb_UpperCase_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsReg crx) %{
12530   match(Set dst (UpperCase src1));
12531   effect(TEMP src2, TEMP crx);
12532   ins_cost(7 * DEFAULT_COST);
12533 
12534   format %{ &quot;LI      $src2, 0x5A41\n\t&quot;
12535             &quot;CMPRB   $crx, 0, $src1, $src2\n\t&quot;
12536             &quot;BGT     $crx, done\n\t&quot;
12537             &quot;LIS     $src2, (signed short)0xD6C0\n\t&quot;
12538             &quot;ORI     $src2, $src2, 0xDED8\n\t&quot;
12539             &quot;CMPRB   $crx, 1, $src1, $src2\n&quot;
12540             &quot;done:\n\t&quot;
12541             &quot;SETB    $dst, $crx&quot; %}
12542 
12543   size(28);
12544   ins_encode %{
12545     Label done;
12546     // 0x41: A, 0x5A: Z
12547     __ li($src2$$Register, 0x5A41);
12548     // compare src1 with a range 0x41 to 0x5A
12549     __ cmprb($crx$$CondRegister, 0, $src1$$Register, $src2$$Register);
12550     __ bgt($crx$$CondRegister, done);
12551 
12552     // 0xC0: a with grave, 0xDE: thorn, 0xD7 is not the upper case
12553     __ lis($src2$$Register, (signed short)0xD6C0);
12554     __ ori($src2$$Register, $src2$$Register, 0xDED8);
12555     // compare src1 with ranges 0xC0 to 0xD6 and 0xD8 to 0xDE
12556     __ cmprb($crx$$CondRegister, 1, $src1$$Register, $src2$$Register);
12557 
12558     __ bind(done);
12559     __ setb($dst$$Register, $crx$$CondRegister);
12560   %}
12561   ins_pipe(pipe_class_default);
12562 %}
12563 
12564 instruct cmprb_Whitespace_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsReg crx) %{
12565   match(Set dst (Whitespace src1));
12566   effect(TEMP src2, TEMP crx);
12567   ins_cost(4 * DEFAULT_COST);
12568 
12569   format %{ &quot;LI      $src2, 0x0D09\n\t&quot;
12570             &quot;ADDIS   $src2, 0x201C\n\t&quot;
12571             &quot;CMPRB   $crx, 1, $src1, $src2\n\t&quot;
12572             &quot;SETB    $dst, $crx&quot; %}
12573   size(16);
12574   ins_encode %{
12575     // 0x09 to 0x0D, 0x1C to 0x20
12576     __ li($src2$$Register, 0x0D09);
12577     __ addis($src2$$Register, $src2$$Register, 0x0201C);
12578     // compare src with ranges 0x09 to 0x0D and 0x1C to 0x20
12579     __ cmprb($crx$$CondRegister, 1, $src1$$Register, $src2$$Register);
12580     __ setb($dst$$Register, $crx$$CondRegister);
12581   %}
12582   ins_pipe(pipe_class_default);
12583 %}
12584 
12585 //----------Branches---------------------------------------------------------
12586 // Jump
12587 
12588 // Direct Branch.
12589 instruct branch(label labl) %{
12590   match(Goto);
12591   effect(USE labl);
12592   ins_cost(BRANCH_COST);
12593 
12594   format %{ &quot;B       $labl&quot; %}
12595   size(4);
12596   ins_encode %{
12597     // TODO: PPC port $archOpcode(ppc64Opcode_b);
12598      Label d;    // dummy
12599      __ bind(d);
12600      Label* p = $labl$$label;
12601      // `p&#39; is `NULL&#39; when this encoding class is used only to
12602      // determine the size of the encoded instruction.
12603      Label&amp; l = (NULL == p)? d : *(p);
12604      __ b(l);
12605   %}
12606   ins_pipe(pipe_class_default);
12607 %}
12608 
12609 // Conditional Near Branch
12610 instruct branchCon(cmpOp cmp, flagsRegSrc crx, label lbl) %{
12611   // Same match rule as `branchConFar&#39;.
12612   match(If cmp crx);
12613   effect(USE lbl);
12614   ins_cost(BRANCH_COST);
12615 
12616   // If set to 1 this indicates that the current instruction is a
12617   // short variant of a long branch. This avoids using this
12618   // instruction in first-pass matching. It will then only be used in
12619   // the `Shorten_branches&#39; pass.
12620   ins_short_branch(1);
12621 
12622   format %{ &quot;B$cmp     $crx, $lbl&quot; %}
12623   size(4);
12624   ins_encode( enc_bc(crx, cmp, lbl) );
12625   ins_pipe(pipe_class_default);
12626 %}
12627 
12628 // This is for cases when the ppc64 `bc&#39; instruction does not
12629 // reach far enough. So we emit a far branch here, which is more
12630 // expensive.
12631 //
12632 // Conditional Far Branch
12633 instruct branchConFar(cmpOp cmp, flagsRegSrc crx, label lbl) %{
12634   // Same match rule as `branchCon&#39;.
12635   match(If cmp crx);
12636   effect(USE crx, USE lbl);
12637   predicate(!false /* TODO: PPC port HB_Schedule*/);
12638   // Higher cost than `branchCon&#39;.
12639   ins_cost(5*BRANCH_COST);
12640 
12641   // This is not a short variant of a branch, but the long variant.
12642   ins_short_branch(0);
12643 
12644   format %{ &quot;B_FAR$cmp $crx, $lbl&quot; %}
12645   size(8);
12646   ins_encode( enc_bc_far(crx, cmp, lbl) );
12647   ins_pipe(pipe_class_default);
12648 %}
12649 
12650 // Conditional Branch used with Power6 scheduler (can be far or short).
12651 instruct branchConSched(cmpOp cmp, flagsRegSrc crx, label lbl) %{
12652   // Same match rule as `branchCon&#39;.
12653   match(If cmp crx);
12654   effect(USE crx, USE lbl);
12655   predicate(false /* TODO: PPC port HB_Schedule*/);
12656   // Higher cost than `branchCon&#39;.
12657   ins_cost(5*BRANCH_COST);
12658 
12659   // Actually size doesn&#39;t depend on alignment but on shortening.
12660   ins_variable_size_depending_on_alignment(true);
12661   // long variant.
12662   ins_short_branch(0);
12663 
12664   format %{ &quot;B_FAR$cmp $crx, $lbl&quot; %}
12665   size(8); // worst case
12666   ins_encode( enc_bc_short_far(crx, cmp, lbl) );
12667   ins_pipe(pipe_class_default);
12668 %}
12669 
12670 instruct branchLoopEnd(cmpOp cmp, flagsRegSrc crx, label labl) %{
12671   match(CountedLoopEnd cmp crx);
12672   effect(USE labl);
12673   ins_cost(BRANCH_COST);
12674 
12675   // short variant.
12676   ins_short_branch(1);
12677 
12678   format %{ &quot;B$cmp     $crx, $labl \t// counted loop end&quot; %}
12679   size(4);
12680   ins_encode( enc_bc(crx, cmp, labl) );
12681   ins_pipe(pipe_class_default);
12682 %}
12683 
12684 instruct branchLoopEndFar(cmpOp cmp, flagsRegSrc crx, label labl) %{
12685   match(CountedLoopEnd cmp crx);
12686   effect(USE labl);
12687   predicate(!false /* TODO: PPC port HB_Schedule */);
12688   ins_cost(BRANCH_COST);
12689 
12690   // Long variant.
12691   ins_short_branch(0);
12692 
12693   format %{ &quot;B_FAR$cmp $crx, $labl \t// counted loop end&quot; %}
12694   size(8);
12695   ins_encode( enc_bc_far(crx, cmp, labl) );
12696   ins_pipe(pipe_class_default);
12697 %}
12698 
12699 // Conditional Branch used with Power6 scheduler (can be far or short).
12700 instruct branchLoopEndSched(cmpOp cmp, flagsRegSrc crx, label labl) %{
12701   match(CountedLoopEnd cmp crx);
12702   effect(USE labl);
12703   predicate(false /* TODO: PPC port HB_Schedule */);
12704   // Higher cost than `branchCon&#39;.
12705   ins_cost(5*BRANCH_COST);
12706 
12707   // Actually size doesn&#39;t depend on alignment but on shortening.
12708   ins_variable_size_depending_on_alignment(true);
12709   // Long variant.
12710   ins_short_branch(0);
12711 
12712   format %{ &quot;B_FAR$cmp $crx, $labl \t// counted loop end&quot; %}
12713   size(8); // worst case
12714   ins_encode( enc_bc_short_far(crx, cmp, labl) );
12715   ins_pipe(pipe_class_default);
12716 %}
12717 
12718 // ============================================================================
12719 // Java runtime operations, intrinsics and other complex operations.
12720 
12721 // The 2nd slow-half of a subtype check. Scan the subklass&#39;s 2ndary superklass
12722 // array for an instance of the superklass. Set a hidden internal cache on a
12723 // hit (cache is checked with exposed code in gen_subtype_check()). Return
12724 // not zero for a miss or zero for a hit. The encoding ALSO sets flags.
12725 //
12726 // GL TODO: Improve this.
12727 // - result should not be a TEMP
12728 // - Add match rule as on sparc avoiding additional Cmp.
12729 instruct partialSubtypeCheck(iRegPdst result, iRegP_N2P subklass, iRegP_N2P superklass,
12730                              iRegPdst tmp_klass, iRegPdst tmp_arrayptr) %{
12731   match(Set result (PartialSubtypeCheck subklass superklass));
12732   effect(TEMP_DEF result, TEMP tmp_klass, TEMP tmp_arrayptr);
12733   ins_cost(DEFAULT_COST*10);
12734 
12735   format %{ &quot;PartialSubtypeCheck $result = ($subklass instanceOf $superklass) tmp: $tmp_klass, $tmp_arrayptr&quot; %}
12736   ins_encode %{
12737     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12738     __ check_klass_subtype_slow_path($subklass$$Register, $superklass$$Register, $tmp_arrayptr$$Register,
12739                                      $tmp_klass$$Register, NULL, $result$$Register);
12740   %}
12741   ins_pipe(pipe_class_default);
12742 %}
12743 
12744 // inlined locking and unlocking
12745 
12746 instruct cmpFastLock(flagsReg crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2) %{
12747   match(Set crx (FastLock oop box));
12748   effect(TEMP tmp1, TEMP tmp2);
12749   predicate(!Compile::current()-&gt;use_rtm());
12750 
12751   format %{ &quot;FASTLOCK  $oop, $box, $tmp1, $tmp2&quot; %}
12752   ins_encode %{
12753     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12754     __ compiler_fast_lock_object($crx$$CondRegister, $oop$$Register, $box$$Register,
12755                                  $tmp1$$Register, $tmp2$$Register, /*tmp3*/ R0,
12756                                  UseBiasedLocking &amp;&amp; !UseOptoBiasInlining);
12757     // If locking was successfull, crx should indicate &#39;EQ&#39;.
12758     // The compiler generates a branch to the runtime call to
12759     // _complete_monitor_locking_Java for the case where crx is &#39;NE&#39;.
12760   %}
12761   ins_pipe(pipe_class_compare);
12762 %}
12763 
12764 // Separate version for TM. Use bound register for box to enable USE_KILL.
12765 instruct cmpFastLock_tm(flagsReg crx, iRegPdst oop, rarg2RegP box, iRegPdst tmp1, iRegPdst tmp2, iRegPdst tmp3) %{
12766   match(Set crx (FastLock oop box));
12767   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, USE_KILL box);
12768   predicate(Compile::current()-&gt;use_rtm());
12769 
12770   format %{ &quot;FASTLOCK  $oop, $box, $tmp1, $tmp2, $tmp3 (TM)&quot; %}
12771   ins_encode %{
12772     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12773     __ compiler_fast_lock_object($crx$$CondRegister, $oop$$Register, $box$$Register,
12774                                  $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,
12775                                  /*Biased Locking*/ false,
12776                                  _rtm_counters, _stack_rtm_counters,
12777                                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
12778                                  /*TM*/ true, ra_-&gt;C-&gt;profile_rtm());
12779     // If locking was successfull, crx should indicate &#39;EQ&#39;.
12780     // The compiler generates a branch to the runtime call to
12781     // _complete_monitor_locking_Java for the case where crx is &#39;NE&#39;.
12782   %}
12783   ins_pipe(pipe_class_compare);
12784 %}
12785 
12786 instruct cmpFastUnlock(flagsReg crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2, iRegPdst tmp3) %{
12787   match(Set crx (FastUnlock oop box));
12788   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);
12789   predicate(!Compile::current()-&gt;use_rtm());
12790 
12791   format %{ &quot;FASTUNLOCK  $oop, $box, $tmp1, $tmp2&quot; %}
12792   ins_encode %{
12793     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12794     __ compiler_fast_unlock_object($crx$$CondRegister, $oop$$Register, $box$$Register,
12795                                    $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,
12796                                    UseBiasedLocking &amp;&amp; !UseOptoBiasInlining,
12797                                    false);
12798     // If unlocking was successfull, crx should indicate &#39;EQ&#39;.
12799     // The compiler generates a branch to the runtime call to
12800     // _complete_monitor_unlocking_Java for the case where crx is &#39;NE&#39;.
12801   %}
12802   ins_pipe(pipe_class_compare);
12803 %}
12804 
12805 instruct cmpFastUnlock_tm(flagsReg crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2, iRegPdst tmp3) %{
12806   match(Set crx (FastUnlock oop box));
12807   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);
12808   predicate(Compile::current()-&gt;use_rtm());
12809 
12810   format %{ &quot;FASTUNLOCK  $oop, $box, $tmp1, $tmp2 (TM)&quot; %}
12811   ins_encode %{
12812     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12813     __ compiler_fast_unlock_object($crx$$CondRegister, $oop$$Register, $box$$Register,
12814                                    $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,
12815                                    /*Biased Locking*/ false, /*TM*/ true);
12816     // If unlocking was successfull, crx should indicate &#39;EQ&#39;.
12817     // The compiler generates a branch to the runtime call to
12818     // _complete_monitor_unlocking_Java for the case where crx is &#39;NE&#39;.
12819   %}
12820   ins_pipe(pipe_class_compare);
12821 %}
12822 
12823 // Align address.
12824 instruct align_addr(iRegPdst dst, iRegPsrc src, immLnegpow2 mask) %{
12825   match(Set dst (CastX2P (AndL (CastP2X src) mask)));
12826 
12827   format %{ &quot;ANDDI   $dst, $src, $mask \t// next aligned address&quot; %}
12828   size(4);
12829   ins_encode %{
12830     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
12831     __ clrrdi($dst$$Register, $src$$Register, log2_long((jlong)-$mask$$constant));
12832   %}
12833   ins_pipe(pipe_class_default);
12834 %}
12835 
12836 // Array size computation.
12837 instruct array_size(iRegLdst dst, iRegPsrc end, iRegPsrc start) %{
12838   match(Set dst (SubL (CastP2X end) (CastP2X start)));
12839 
12840   format %{ &quot;SUB     $dst, $end, $start \t// array size in bytes&quot; %}
12841   size(4);
12842   ins_encode %{
12843     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
12844     __ subf($dst$$Register, $start$$Register, $end$$Register);
12845   %}
12846   ins_pipe(pipe_class_default);
12847 %}
12848 
12849 // Clear-array with constant short array length. The versions below can use dcbz with cnt &gt; 30.
12850 instruct inlineCallClearArrayShort(immLmax30 cnt, rarg2RegP base, Universe dummy, regCTR ctr) %{
12851   match(Set dummy (ClearArray cnt base));
12852   effect(USE_KILL base, KILL ctr);
12853   ins_cost(2 * MEMORY_REF_COST);
12854 
12855   format %{ &quot;ClearArray $cnt, $base&quot; %}
12856   ins_encode %{
12857     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12858     __ clear_memory_constlen($base$$Register, $cnt$$constant, R0); // kills base, R0
12859   %}
12860   ins_pipe(pipe_class_default);
12861 %}
12862 
12863 // Clear-array with constant large array length.
12864 instruct inlineCallClearArrayLarge(immL cnt, rarg2RegP base, Universe dummy, iRegLdst tmp, regCTR ctr) %{
12865   match(Set dummy (ClearArray cnt base));
12866   effect(USE_KILL base, TEMP tmp, KILL ctr);
12867   ins_cost(3 * MEMORY_REF_COST);
12868 
12869   format %{ &quot;ClearArray $cnt, $base \t// KILL $tmp&quot; %}
12870   ins_encode %{
12871     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12872     __ clear_memory_doubleword($base$$Register, $tmp$$Register, R0, $cnt$$constant); // kills base, R0
12873   %}
12874   ins_pipe(pipe_class_default);
12875 %}
12876 
12877 // Clear-array with dynamic array length.
12878 instruct inlineCallClearArray(rarg1RegL cnt, rarg2RegP base, Universe dummy, regCTR ctr) %{
12879   match(Set dummy (ClearArray cnt base));
12880   effect(USE_KILL cnt, USE_KILL base, KILL ctr);
12881   ins_cost(4 * MEMORY_REF_COST);
12882 
12883   format %{ &quot;ClearArray $cnt, $base&quot; %}
12884   ins_encode %{
12885     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12886     __ clear_memory_doubleword($base$$Register, $cnt$$Register, R0); // kills cnt, base, R0
12887   %}
12888   ins_pipe(pipe_class_default);
12889 %}
12890 
12891 instruct string_compareL(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt1, rarg4RegI cnt2, iRegIdst result,
12892                          iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
12893   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
12894   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
12895   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ctr, KILL cr0, TEMP tmp);
12896   ins_cost(300);
12897   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result \t// KILL $tmp&quot; %}
12898   ins_encode %{
12899     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12900     __ string_compare($str1$$Register, $str2$$Register,
12901                       $cnt1$$Register, $cnt2$$Register,
12902                       $tmp$$Register,
12903                       $result$$Register, StrIntrinsicNode::LL);
12904   %}
12905   ins_pipe(pipe_class_default);
12906 %}
12907 
12908 instruct string_compareU(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt1, rarg4RegI cnt2, iRegIdst result,
12909                          iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
12910   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
12911   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
12912   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ctr, KILL cr0, TEMP tmp);
12913   ins_cost(300);
12914   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result \t// KILL $tmp&quot; %}
12915   ins_encode %{
12916     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12917     __ string_compare($str1$$Register, $str2$$Register,
12918                       $cnt1$$Register, $cnt2$$Register,
12919                       $tmp$$Register,
12920                       $result$$Register, StrIntrinsicNode::UU);
12921   %}
12922   ins_pipe(pipe_class_default);
12923 %}
12924 
12925 instruct string_compareLU(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt1, rarg4RegI cnt2, iRegIdst result,
12926                           iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
12927   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
12928   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
12929   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ctr, KILL cr0, TEMP tmp);
12930   ins_cost(300);
12931   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result \t// KILL $tmp&quot; %}
12932   ins_encode %{
12933     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12934     __ string_compare($str1$$Register, $str2$$Register,
12935                       $cnt1$$Register, $cnt2$$Register,
12936                       $tmp$$Register,
12937                       $result$$Register, StrIntrinsicNode::LU);
12938   %}
12939   ins_pipe(pipe_class_default);
12940 %}
12941 
12942 instruct string_compareUL(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt1, rarg4RegI cnt2, iRegIdst result,
12943                           iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
12944   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
12945   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
12946   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ctr, KILL cr0, TEMP tmp);
12947   ins_cost(300);
12948   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result \t// KILL $tmp&quot; %}
12949   ins_encode %{
12950     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12951     __ string_compare($str2$$Register, $str1$$Register,
12952                       $cnt2$$Register, $cnt1$$Register,
12953                       $tmp$$Register,
12954                       $result$$Register, StrIntrinsicNode::UL);
12955   %}
12956   ins_pipe(pipe_class_default);
12957 %}
12958 
12959 instruct string_equalsL(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt, iRegIdst result,
12960                         iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
12961   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
12962   match(Set result (StrEquals (Binary str1 str2) cnt));
12963   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt, TEMP tmp, KILL ctr, KILL cr0);
12964   ins_cost(300);
12965   format %{ &quot;String Equals byte[] $str1,$str2,$cnt -&gt; $result \t// KILL $tmp&quot; %}
12966   ins_encode %{
12967     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12968     __ array_equals(false, $str1$$Register, $str2$$Register,
12969                     $cnt$$Register, $tmp$$Register,
12970                     $result$$Register, true /* byte */);
12971   %}
12972   ins_pipe(pipe_class_default);
12973 %}
12974 
12975 instruct string_equalsU(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt, iRegIdst result,
12976                         iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
12977   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
12978   match(Set result (StrEquals (Binary str1 str2) cnt));
12979   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt, TEMP tmp, KILL ctr, KILL cr0);
12980   ins_cost(300);
12981   format %{ &quot;String Equals char[]  $str1,$str2,$cnt -&gt; $result \t// KILL $tmp&quot; %}
12982   ins_encode %{
12983     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12984     __ array_equals(false, $str1$$Register, $str2$$Register,
12985                     $cnt$$Register, $tmp$$Register,
12986                     $result$$Register, false /* byte */);
12987   %}
12988   ins_pipe(pipe_class_default);
12989 %}
12990 
12991 instruct array_equalsB(rarg1RegP ary1, rarg2RegP ary2, iRegIdst result,
12992                        iRegIdst tmp1, iRegIdst tmp2, regCTR ctr, flagsRegCR0 cr0, flagsRegCR0 cr1) %{
12993   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
12994   match(Set result (AryEq ary1 ary2));
12995   effect(TEMP_DEF result, USE_KILL ary1, USE_KILL ary2, TEMP tmp1, TEMP tmp2, KILL ctr, KILL cr0, KILL cr1);
12996   ins_cost(300);
12997   format %{ &quot;Array Equals $ary1,$ary2 -&gt; $result \t// KILL $tmp1,$tmp2&quot; %}
12998   ins_encode %{
12999     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13000     __ array_equals(true, $ary1$$Register, $ary2$$Register,
13001                     $tmp1$$Register, $tmp2$$Register,
13002                     $result$$Register, true /* byte */);
13003   %}
13004   ins_pipe(pipe_class_default);
13005 %}
13006 
13007 instruct array_equalsC(rarg1RegP ary1, rarg2RegP ary2, iRegIdst result,
13008                        iRegIdst tmp1, iRegIdst tmp2, regCTR ctr, flagsRegCR0 cr0, flagsRegCR0 cr1) %{
13009   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
13010   match(Set result (AryEq ary1 ary2));
13011   effect(TEMP_DEF result, USE_KILL ary1, USE_KILL ary2, TEMP tmp1, TEMP tmp2, KILL ctr, KILL cr0, KILL cr1);
13012   ins_cost(300);
13013   format %{ &quot;Array Equals $ary1,$ary2 -&gt; $result \t// KILL $tmp1,$tmp2&quot; %}
13014   ins_encode %{
13015     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13016     __ array_equals(true, $ary1$$Register, $ary2$$Register,
13017                     $tmp1$$Register, $tmp2$$Register,
13018                     $result$$Register, false /* byte */);
13019   %}
13020   ins_pipe(pipe_class_default);
13021 %}
13022 
13023 instruct indexOf_imm1_char_U(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13024                              immP needleImm, immL offsetImm, immI_1 needlecntImm,
13025                              iRegIdst tmp1, iRegIdst tmp2,
13026                              flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13027   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary (AddP needleImm offsetImm) needlecntImm)));
13028   effect(TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13029   // Required for EA: check if it is still a type_array.
13030   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
13031   ins_cost(150);
13032 
13033   format %{ &quot;String IndexOf CSCL1 $haystack[0..$haycnt], $needleImm+$offsetImm[0..$needlecntImm]&quot;
13034             &quot;-&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13035 
13036   ins_encode %{
13037     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13038     immPOper *needleOper = (immPOper *)$needleImm;
13039     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
13040     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
13041     jchar chr;
13042 #ifdef VM_LITTLE_ENDIAN
13043     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte()) &lt;&lt; 8) |
13044            ((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte());
13045 #else
13046     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte()) &lt;&lt; 8) |
13047            ((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte());
13048 #endif
13049     __ string_indexof_char($result$$Register,
13050                            $haystack$$Register, $haycnt$$Register,
13051                            R0, chr,
13052                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
13053   %}
13054   ins_pipe(pipe_class_compare);
13055 %}
13056 
13057 instruct indexOf_imm1_char_L(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13058                              immP needleImm, immL offsetImm, immI_1 needlecntImm,
13059                              iRegIdst tmp1, iRegIdst tmp2,
13060                              flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13061   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary (AddP needleImm offsetImm) needlecntImm)));
13062   effect(TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13063   // Required for EA: check if it is still a type_array.
13064   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
13065   ins_cost(150);
13066 
13067   format %{ &quot;String IndexOf CSCL1 $haystack[0..$haycnt], $needleImm+$offsetImm[0..$needlecntImm]&quot;
13068             &quot;-&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13069 
13070   ins_encode %{
13071     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13072     immPOper *needleOper = (immPOper *)$needleImm;
13073     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
13074     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
13075     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
13076     __ string_indexof_char($result$$Register,
13077                            $haystack$$Register, $haycnt$$Register,
13078                            R0, chr,
13079                            $tmp1$$Register, $tmp2$$Register, true /*is_byte*/);
13080   %}
13081   ins_pipe(pipe_class_compare);
13082 %}
13083 
13084 instruct indexOf_imm1_char_UL(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13085                               immP needleImm, immL offsetImm, immI_1 needlecntImm,
13086                               iRegIdst tmp1, iRegIdst tmp2,
13087                               flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13088   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary (AddP needleImm offsetImm) needlecntImm)));
13089   effect(TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13090   // Required for EA: check if it is still a type_array.
13091   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
13092   ins_cost(150);
13093 
13094   format %{ &quot;String IndexOf CSCL1 $haystack[0..$haycnt], $needleImm+$offsetImm[0..$needlecntImm]&quot;
13095             &quot;-&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13096 
13097   ins_encode %{
13098     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13099     immPOper *needleOper = (immPOper *)$needleImm;
13100     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
13101     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
13102     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
13103     __ string_indexof_char($result$$Register,
13104                            $haystack$$Register, $haycnt$$Register,
13105                            R0, chr,
13106                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
13107   %}
13108   ins_pipe(pipe_class_compare);
13109 %}
13110 
13111 instruct indexOf_imm1_U(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13112                         rscratch2RegP needle, immI_1 needlecntImm,
13113                         iRegIdst tmp1, iRegIdst tmp2,
13114                         flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13115   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
13116   effect(USE_KILL needle, TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13117   // Required for EA: check if it is still a type_array.
13118   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU &amp;&amp;
13119             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
13120             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
13121   ins_cost(180);
13122 
13123   format %{ &quot;String IndexOf SCL1 $haystack[0..$haycnt], $needle[0..$needlecntImm]&quot;
13124             &quot; -&gt; $result \t// KILL $haycnt, $needle, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13125   ins_encode %{
13126     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13127     Node *ndl = in(operand_index($needle));  // The node that defines needle.
13128     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
13129     guarantee(needle_values, &quot;sanity&quot;);
13130     jchar chr;
13131 #ifdef VM_LITTLE_ENDIAN
13132     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte()) &lt;&lt; 8) |
13133            ((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte());
13134 #else
13135     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte()) &lt;&lt; 8) |
13136            ((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte());
13137 #endif
13138     __ string_indexof_char($result$$Register,
13139                            $haystack$$Register, $haycnt$$Register,
13140                            R0, chr,
13141                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
13142   %}
13143   ins_pipe(pipe_class_compare);
13144 %}
13145 
13146 instruct indexOf_imm1_L(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13147                         rscratch2RegP needle, immI_1 needlecntImm,
13148                         iRegIdst tmp1, iRegIdst tmp2,
13149                         flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13150   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
13151   effect(USE_KILL needle, TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13152   // Required for EA: check if it is still a type_array.
13153   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL &amp;&amp;
13154             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
13155             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
13156   ins_cost(180);
13157 
13158   format %{ &quot;String IndexOf SCL1 $haystack[0..$haycnt], $needle[0..$needlecntImm]&quot;
13159             &quot; -&gt; $result \t// KILL $haycnt, $needle, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13160   ins_encode %{
13161     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13162     Node *ndl = in(operand_index($needle));  // The node that defines needle.
13163     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
13164     guarantee(needle_values, &quot;sanity&quot;);
13165     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
13166     __ string_indexof_char($result$$Register,
13167                            $haystack$$Register, $haycnt$$Register,
13168                            R0, chr,
13169                            $tmp1$$Register, $tmp2$$Register, true /*is_byte*/);
13170   %}
13171   ins_pipe(pipe_class_compare);
13172 %}
13173 
13174 instruct indexOf_imm1_UL(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13175                          rscratch2RegP needle, immI_1 needlecntImm,
13176                          iRegIdst tmp1, iRegIdst tmp2,
13177                          flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13178   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
13179   effect(USE_KILL needle, TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13180   // Required for EA: check if it is still a type_array.
13181   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL &amp;&amp;
13182             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
13183             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
13184   ins_cost(180);
13185 
13186   format %{ &quot;String IndexOf SCL1 $haystack[0..$haycnt], $needle[0..$needlecntImm]&quot;
13187             &quot; -&gt; $result \t// KILL $haycnt, $needle, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13188   ins_encode %{
13189     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13190     Node *ndl = in(operand_index($needle));  // The node that defines needle.
13191     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
13192     guarantee(needle_values, &quot;sanity&quot;);
13193     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
13194     __ string_indexof_char($result$$Register,
13195                            $haystack$$Register, $haycnt$$Register,
13196                            R0, chr,
13197                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
13198   %}
13199   ins_pipe(pipe_class_compare);
13200 %}
13201 
13202 instruct indexOfChar_U(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13203                        iRegIsrc ch, iRegIdst tmp1, iRegIdst tmp2,
13204                        flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13205   match(Set result (StrIndexOfChar (Binary haystack haycnt) ch));
13206   effect(TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13207   ins_cost(180);
13208 
13209   format %{ &quot;String IndexOfChar $haystack[0..$haycnt], $ch&quot;
13210             &quot; -&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13211   ins_encode %{
13212     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13213     __ string_indexof_char($result$$Register,
13214                            $haystack$$Register, $haycnt$$Register,
13215                            $ch$$Register, 0 /* this is not used if the character is already in a register */,
13216                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
13217   %}
13218   ins_pipe(pipe_class_compare);
13219 %}
13220 
13221 instruct indexOf_imm_U(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt,
13222                        iRegPsrc needle, uimmI15 needlecntImm,
13223                        iRegIdst tmp1, iRegIdst tmp2, iRegIdst tmp3, iRegIdst tmp4, iRegIdst tmp5,
13224                        flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
13225   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
13226   effect(USE_KILL haycnt, /* better: TDEF haycnt, */ TEMP_DEF result,
13227          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
13228   // Required for EA: check if it is still a type_array.
13229   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU &amp;&amp;
13230             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
13231             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
13232   ins_cost(250);
13233 
13234   format %{ &quot;String IndexOf SCL $haystack[0..$haycnt], $needle[0..$needlecntImm]&quot;
13235             &quot; -&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $tmp3, $tmp4, $tmp5, $cr0, $cr1&quot; %}
13236   ins_encode %{
13237     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13238     Node *ndl = in(operand_index($needle));  // The node that defines needle.
13239     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
13240 
13241     __ string_indexof($result$$Register,
13242                       $haystack$$Register, $haycnt$$Register,
13243                       $needle$$Register, needle_values, $tmp5$$Register, $needlecntImm$$constant,
13244                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::UU);
13245   %}
13246   ins_pipe(pipe_class_compare);
13247 %}
13248 
13249 instruct indexOf_imm_L(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt,
13250                        iRegPsrc needle, uimmI15 needlecntImm,
13251                        iRegIdst tmp1, iRegIdst tmp2, iRegIdst tmp3, iRegIdst tmp4, iRegIdst tmp5,
13252                        flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
13253   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
13254   effect(USE_KILL haycnt, /* better: TDEF haycnt, */ TEMP_DEF result,
13255          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
13256   // Required for EA: check if it is still a type_array.
13257   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL &amp;&amp;
13258             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
13259             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
13260   ins_cost(250);
13261 
13262   format %{ &quot;String IndexOf SCL $haystack[0..$haycnt], $needle[0..$needlecntImm]&quot;
13263             &quot; -&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $tmp3, $tmp4, $tmp5, $cr0, $cr1&quot; %}
13264   ins_encode %{
13265     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13266     Node *ndl = in(operand_index($needle));  // The node that defines needle.
13267     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
13268 
13269     __ string_indexof($result$$Register,
13270                       $haystack$$Register, $haycnt$$Register,
13271                       $needle$$Register, needle_values, $tmp5$$Register, $needlecntImm$$constant,
13272                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::LL);
13273   %}
13274   ins_pipe(pipe_class_compare);
13275 %}
13276 
13277 instruct indexOf_imm_UL(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt,
13278                         iRegPsrc needle, uimmI15 needlecntImm,
13279                         iRegIdst tmp1, iRegIdst tmp2, iRegIdst tmp3, iRegIdst tmp4, iRegIdst tmp5,
13280                         flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
13281   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
13282   effect(USE_KILL haycnt, /* better: TDEF haycnt, */ TEMP_DEF result,
13283          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
13284   // Required for EA: check if it is still a type_array.
13285   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL &amp;&amp;
13286             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
13287             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
13288   ins_cost(250);
13289 
13290   format %{ &quot;String IndexOf SCL $haystack[0..$haycnt], $needle[0..$needlecntImm]&quot;
13291             &quot; -&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $tmp3, $tmp4, $tmp5, $cr0, $cr1&quot; %}
13292   ins_encode %{
13293     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13294     Node *ndl = in(operand_index($needle));  // The node that defines needle.
13295     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
13296 
13297     __ string_indexof($result$$Register,
13298                       $haystack$$Register, $haycnt$$Register,
13299                       $needle$$Register, needle_values, $tmp5$$Register, $needlecntImm$$constant,
13300                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::UL);
13301   %}
13302   ins_pipe(pipe_class_compare);
13303 %}
13304 
13305 instruct indexOf_U(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt, iRegPsrc needle, rscratch2RegI needlecnt,
13306                    iRegLdst tmp1, iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4,
13307                    flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
13308   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
13309   effect(USE_KILL haycnt, USE_KILL needlecnt, /*better: TDEF haycnt, TDEF needlecnt,*/
13310          TEMP_DEF result,
13311          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
13312   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
13313   ins_cost(300);
13314 
13315   format %{ &quot;String IndexOf $haystack[0..$haycnt], $needle[0..$needlecnt]&quot;
13316              &quot; -&gt; $result \t// KILL $haycnt, $needlecnt, $tmp1, $tmp2, $tmp3, $tmp4, $cr0, $cr1&quot; %}
13317   ins_encode %{
13318     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13319     __ string_indexof($result$$Register,
13320                       $haystack$$Register, $haycnt$$Register,
13321                       $needle$$Register, NULL, $needlecnt$$Register, 0,  // needlecnt not constant.
13322                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::UU);
13323   %}
13324   ins_pipe(pipe_class_compare);
13325 %}
13326 
13327 instruct indexOf_L(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt, iRegPsrc needle, rscratch2RegI needlecnt,
13328                    iRegLdst tmp1, iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4,
13329                    flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
13330   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
13331   effect(USE_KILL haycnt, USE_KILL needlecnt, /*better: TDEF haycnt, TDEF needlecnt,*/
13332          TEMP_DEF result,
13333          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
13334   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
13335   ins_cost(300);
13336 
13337   format %{ &quot;String IndexOf $haystack[0..$haycnt], $needle[0..$needlecnt]&quot;
13338              &quot; -&gt; $result \t// KILL $haycnt, $needlecnt, $tmp1, $tmp2, $tmp3, $tmp4, $cr0, $cr1&quot; %}
13339   ins_encode %{
13340     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13341     __ string_indexof($result$$Register,
13342                       $haystack$$Register, $haycnt$$Register,
13343                       $needle$$Register, NULL, $needlecnt$$Register, 0,  // needlecnt not constant.
13344                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::LL);
13345   %}
13346   ins_pipe(pipe_class_compare);
13347 %}
13348 
13349 instruct indexOf_UL(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt, iRegPsrc needle, rscratch2RegI needlecnt,
13350                     iRegLdst tmp1, iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4,
13351                     flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
13352   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
13353   effect(USE_KILL haycnt, USE_KILL needlecnt, /*better: TDEF haycnt, TDEF needlecnt,*/
13354          TEMP_DEF result,
13355          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
13356   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
13357   ins_cost(300);
13358 
13359   format %{ &quot;String IndexOf $haystack[0..$haycnt], $needle[0..$needlecnt]&quot;
13360              &quot; -&gt; $result \t// KILL $haycnt, $needlecnt, $tmp1, $tmp2, $tmp3, $tmp4, $cr0, $cr1&quot; %}
13361   ins_encode %{
13362     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13363     __ string_indexof($result$$Register,
13364                       $haystack$$Register, $haycnt$$Register,
13365                       $needle$$Register, NULL, $needlecnt$$Register, 0,  // needlecnt not constant.
13366                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::UL);
13367   %}
13368   ins_pipe(pipe_class_compare);
13369 %}
13370 
13371 // char[] to byte[] compression
13372 instruct string_compress(rarg1RegP src, rarg2RegP dst, iRegIsrc len, iRegIdst result, iRegLdst tmp1,
13373                          iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4, iRegLdst tmp5, regCTR ctr, flagsRegCR0 cr0) %{
13374   match(Set result (StrCompressedCopy src (Binary dst len)));
13375   effect(TEMP_DEF result, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5,
13376          USE_KILL src, USE_KILL dst, KILL ctr, KILL cr0);
13377   ins_cost(300);
13378   format %{ &quot;String Compress $src,$dst,$len -&gt; $result \t// KILL $tmp1, $tmp2, $tmp3, $tmp4, $tmp5&quot; %}
13379   ins_encode %{
13380     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13381     Label Lskip, Ldone;
13382     __ li($result$$Register, 0);
13383     __ string_compress_16($src$$Register, $dst$$Register, $len$$Register, $tmp1$$Register,
13384                           $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, $tmp5$$Register, Ldone);
13385     __ rldicl_($tmp1$$Register, $len$$Register, 0, 64-3); // Remaining characters.
13386     __ beq(CCR0, Lskip);
13387     __ string_compress($src$$Register, $dst$$Register, $tmp1$$Register, $tmp2$$Register, Ldone);
13388     __ bind(Lskip);
13389     __ mr($result$$Register, $len$$Register);
13390     __ bind(Ldone);
13391   %}
13392   ins_pipe(pipe_class_default);
13393 %}
13394 
13395 // byte[] to char[] inflation
13396 instruct string_inflate(Universe dummy, rarg1RegP src, rarg2RegP dst, iRegIsrc len, iRegLdst tmp1,
13397                         iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4, iRegLdst tmp5, regCTR ctr, flagsRegCR0 cr0) %{
13398   match(Set dummy (StrInflatedCopy src (Binary dst len)));
13399   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, USE_KILL src, USE_KILL dst, KILL ctr, KILL cr0);
13400   ins_cost(300);
13401   format %{ &quot;String Inflate $src,$dst,$len \t// KILL $tmp1, $tmp2, $tmp3, $tmp4, $tmp5&quot; %}
13402   ins_encode %{
13403     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13404     Label Ldone;
13405     __ string_inflate_16($src$$Register, $dst$$Register, $len$$Register, $tmp1$$Register,
13406                          $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, $tmp5$$Register);
13407     __ rldicl_($tmp1$$Register, $len$$Register, 0, 64-3); // Remaining characters.
13408     __ beq(CCR0, Ldone);
13409     __ string_inflate($src$$Register, $dst$$Register, $tmp1$$Register, $tmp2$$Register);
13410     __ bind(Ldone);
13411   %}
13412   ins_pipe(pipe_class_default);
13413 %}
13414 
13415 // StringCoding.java intrinsics
13416 instruct has_negatives(rarg1RegP ary1, iRegIsrc len, iRegIdst result, iRegLdst tmp1, iRegLdst tmp2,
13417                        regCTR ctr, flagsRegCR0 cr0)
13418 %{
13419   match(Set result (HasNegatives ary1 len));
13420   effect(TEMP_DEF result, USE_KILL ary1, TEMP tmp1, TEMP tmp2, KILL ctr, KILL cr0);
13421   ins_cost(300);
13422   format %{ &quot;has negatives byte[] $ary1,$len -&gt; $result \t// KILL $tmp1, $tmp2&quot; %}
13423   ins_encode %{
13424     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13425     __ has_negatives($ary1$$Register, $len$$Register, $result$$Register,
13426                      $tmp1$$Register, $tmp2$$Register);
13427   %}
13428   ins_pipe(pipe_class_default);
13429 %}
13430 
13431 // encode char[] to byte[] in ISO_8859_1
13432 instruct encode_iso_array(rarg1RegP src, rarg2RegP dst, iRegIsrc len, iRegIdst result, iRegLdst tmp1,
13433                           iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4, iRegLdst tmp5, regCTR ctr, flagsRegCR0 cr0) %{
13434   match(Set result (EncodeISOArray src (Binary dst len)));
13435   effect(TEMP_DEF result, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5,
13436          USE_KILL src, USE_KILL dst, KILL ctr, KILL cr0);
13437   ins_cost(300);
13438   format %{ &quot;Encode array $src,$dst,$len -&gt; $result \t// KILL $tmp1, $tmp2, $tmp3, $tmp4, $tmp5&quot; %}
13439   ins_encode %{
13440     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13441     Label Lslow, Lfailure1, Lfailure2, Ldone;
13442     __ string_compress_16($src$$Register, $dst$$Register, $len$$Register, $tmp1$$Register,
13443                           $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, $tmp5$$Register, Lfailure1);
13444     __ rldicl_($result$$Register, $len$$Register, 0, 64-3); // Remaining characters.
13445     __ beq(CCR0, Ldone);
13446     __ bind(Lslow);
13447     __ string_compress($src$$Register, $dst$$Register, $result$$Register, $tmp2$$Register, Lfailure2);
13448     __ li($result$$Register, 0);
13449     __ b(Ldone);
13450 
13451     __ bind(Lfailure1);
13452     __ mr($result$$Register, $len$$Register);
13453     __ mfctr($tmp1$$Register);
13454     __ rldimi_($result$$Register, $tmp1$$Register, 3, 0); // Remaining characters.
13455     __ beq(CCR0, Ldone);
13456     __ b(Lslow);
13457 
13458     __ bind(Lfailure2);
13459     __ mfctr($result$$Register); // Remaining characters.
13460 
13461     __ bind(Ldone);
13462     __ subf($result$$Register, $result$$Register, $len$$Register);
13463   %}
13464   ins_pipe(pipe_class_default);
13465 %}
13466 
13467 
13468 //---------- Min/Max Instructions ---------------------------------------------
13469 
13470 instruct minI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
13471   match(Set dst (MinI src1 src2));
13472   ins_cost(DEFAULT_COST*6);
13473 
13474   expand %{
13475     iRegLdst src1s;
13476     iRegLdst src2s;
13477     iRegLdst diff;
13478     iRegLdst sm;
13479     iRegLdst doz; // difference or zero
13480     convI2L_reg(src1s, src1); // Ensure proper sign extension.
13481     convI2L_reg(src2s, src2); // Ensure proper sign extension.
13482     subL_reg_reg(diff, src2s, src1s);
13483     // Need to consider &gt;=33 bit result, therefore we need signmaskL.
13484     signmask64L_regL(sm, diff);
13485     andL_reg_reg(doz, diff, sm); // &lt;=0
13486     addI_regL_regL(dst, doz, src1s);
13487   %}
13488 %}
13489 
13490 instruct minI_reg_reg_isel(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
13491   match(Set dst (MinI src1 src2));
13492   effect(KILL cr0);
13493   predicate(VM_Version::has_isel());
13494   ins_cost(DEFAULT_COST*2);
13495 
13496   ins_encode %{
13497     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13498     __ cmpw(CCR0, $src1$$Register, $src2$$Register);
13499     __ isel($dst$$Register, CCR0, Assembler::less, /*invert*/false, $src1$$Register, $src2$$Register);
13500   %}
13501   ins_pipe(pipe_class_default);
13502 %}
13503 
13504 instruct maxI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
13505   match(Set dst (MaxI src1 src2));
13506   ins_cost(DEFAULT_COST*6);
13507 
13508   expand %{
13509     iRegLdst src1s;
13510     iRegLdst src2s;
13511     iRegLdst diff;
13512     iRegLdst sm;
13513     iRegLdst doz; // difference or zero
13514     convI2L_reg(src1s, src1); // Ensure proper sign extension.
13515     convI2L_reg(src2s, src2); // Ensure proper sign extension.
13516     subL_reg_reg(diff, src2s, src1s);
13517     // Need to consider &gt;=33 bit result, therefore we need signmaskL.
13518     signmask64L_regL(sm, diff);
13519     andcL_reg_reg(doz, diff, sm); // &gt;=0
13520     addI_regL_regL(dst, doz, src1s);
13521   %}
13522 %}
13523 
13524 instruct maxI_reg_reg_isel(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
13525   match(Set dst (MaxI src1 src2));
13526   effect(KILL cr0);
13527   predicate(VM_Version::has_isel());
13528   ins_cost(DEFAULT_COST*2);
13529 
13530   ins_encode %{
13531     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13532     __ cmpw(CCR0, $src1$$Register, $src2$$Register);
13533     __ isel($dst$$Register, CCR0, Assembler::greater, /*invert*/false, $src1$$Register, $src2$$Register);
13534   %}
13535   ins_pipe(pipe_class_default);
13536 %}
13537 
13538 //---------- Population Count Instructions ------------------------------------
13539 
13540 // Popcnt for Power7.
13541 instruct popCountI(iRegIdst dst, iRegIsrc src) %{
13542   match(Set dst (PopCountI src));
13543   predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_popcntw());
13544   ins_cost(DEFAULT_COST);
13545 
13546   format %{ &quot;POPCNTW $dst, $src&quot; %}
13547   size(4);
13548   ins_encode %{
13549     // TODO: PPC port $archOpcode(ppc64Opcode_popcntb);
13550     __ popcntw($dst$$Register, $src$$Register);
13551   %}
13552   ins_pipe(pipe_class_default);
13553 %}
13554 
13555 // Popcnt for Power7.
13556 instruct popCountL(iRegIdst dst, iRegLsrc src) %{
13557   predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_popcntw());
13558   match(Set dst (PopCountL src));
13559   ins_cost(DEFAULT_COST);
13560 
13561   format %{ &quot;POPCNTD $dst, $src&quot; %}
13562   size(4);
13563   ins_encode %{
13564     // TODO: PPC port $archOpcode(ppc64Opcode_popcntb);
13565     __ popcntd($dst$$Register, $src$$Register);
13566   %}
13567   ins_pipe(pipe_class_default);
13568 %}
13569 
13570 instruct countLeadingZerosI(iRegIdst dst, iRegIsrc src) %{
13571   match(Set dst (CountLeadingZerosI src));
13572   predicate(UseCountLeadingZerosInstructionsPPC64);  // See Matcher::match_rule_supported.
13573   ins_cost(DEFAULT_COST);
13574 
13575   format %{ &quot;CNTLZW  $dst, $src&quot; %}
13576   size(4);
13577   ins_encode %{
13578     // TODO: PPC port $archOpcode(ppc64Opcode_cntlzw);
13579     __ cntlzw($dst$$Register, $src$$Register);
13580   %}
13581   ins_pipe(pipe_class_default);
13582 %}
13583 
13584 instruct countLeadingZerosL(iRegIdst dst, iRegLsrc src) %{
13585   match(Set dst (CountLeadingZerosL src));
13586   predicate(UseCountLeadingZerosInstructionsPPC64);  // See Matcher::match_rule_supported.
13587   ins_cost(DEFAULT_COST);
13588 
13589   format %{ &quot;CNTLZD  $dst, $src&quot; %}
13590   size(4);
13591   ins_encode %{
13592     // TODO: PPC port $archOpcode(ppc64Opcode_cntlzd);
13593     __ cntlzd($dst$$Register, $src$$Register);
13594   %}
13595   ins_pipe(pipe_class_default);
13596 %}
13597 
13598 instruct countLeadingZerosP(iRegIdst dst, iRegPsrc src) %{
13599   // no match-rule, false predicate
13600   effect(DEF dst, USE src);
13601   predicate(false);
13602 
13603   format %{ &quot;CNTLZD  $dst, $src&quot; %}
13604   size(4);
13605   ins_encode %{
13606     // TODO: PPC port $archOpcode(ppc64Opcode_cntlzd);
13607     __ cntlzd($dst$$Register, $src$$Register);
13608   %}
13609   ins_pipe(pipe_class_default);
13610 %}
13611 
13612 instruct countTrailingZerosI_Ex(iRegIdst dst, iRegIsrc src) %{
13613   match(Set dst (CountTrailingZerosI src));
13614   predicate(UseCountLeadingZerosInstructionsPPC64 &amp;&amp; !UseCountTrailingZerosInstructionsPPC64);
13615   ins_cost(DEFAULT_COST);
13616 
13617   expand %{
13618     immI16 imm1 %{ (int)-1 %}
13619     immI16 imm2 %{ (int)32 %}
13620     immI_minus1 m1 %{ -1 %}
13621     iRegIdst tmpI1;
13622     iRegIdst tmpI2;
13623     iRegIdst tmpI3;
13624     addI_reg_imm16(tmpI1, src, imm1);
13625     andcI_reg_reg(tmpI2, src, m1, tmpI1);
13626     countLeadingZerosI(tmpI3, tmpI2);
13627     subI_imm16_reg(dst, imm2, tmpI3);
13628   %}
13629 %}
13630 
13631 instruct countTrailingZerosI_cnttzw(iRegIdst dst, iRegIsrc src) %{
13632   match(Set dst (CountTrailingZerosI src));
13633   predicate(UseCountTrailingZerosInstructionsPPC64);
13634   ins_cost(DEFAULT_COST);
13635 
13636   format %{ &quot;CNTTZW  $dst, $src&quot; %}
13637   size(4);
13638   ins_encode %{
13639     __ cnttzw($dst$$Register, $src$$Register);
13640   %}
13641   ins_pipe(pipe_class_default);
13642 %}
13643 
13644 instruct countTrailingZerosL_Ex(iRegIdst dst, iRegLsrc src) %{
13645   match(Set dst (CountTrailingZerosL src));
13646   predicate(UseCountLeadingZerosInstructionsPPC64 &amp;&amp; !UseCountTrailingZerosInstructionsPPC64);
13647   ins_cost(DEFAULT_COST);
13648 
13649   expand %{
13650     immL16 imm1 %{ (long)-1 %}
13651     immI16 imm2 %{ (int)64 %}
13652     iRegLdst tmpL1;
13653     iRegLdst tmpL2;
13654     iRegIdst tmpL3;
13655     addL_reg_imm16(tmpL1, src, imm1);
13656     andcL_reg_reg(tmpL2, tmpL1, src);
13657     countLeadingZerosL(tmpL3, tmpL2);
13658     subI_imm16_reg(dst, imm2, tmpL3);
13659  %}
13660 %}
13661 
13662 instruct countTrailingZerosL_cnttzd(iRegIdst dst, iRegLsrc src) %{
13663   match(Set dst (CountTrailingZerosL src));
13664   predicate(UseCountTrailingZerosInstructionsPPC64);
13665   ins_cost(DEFAULT_COST);
13666 
13667   format %{ &quot;CNTTZD  $dst, $src&quot; %}
13668   size(4);
13669   ins_encode %{
13670     __ cnttzd($dst$$Register, $src$$Register);
13671   %}
13672   ins_pipe(pipe_class_default);
13673 %}
13674 
13675 // Expand nodes for byte_reverse_int.
13676 instruct insrwi_a(iRegIdst dst, iRegIsrc src, immI16 pos, immI16 shift) %{
13677   effect(DEF dst, USE src, USE pos, USE shift);
13678   predicate(false);
13679 
13680   format %{ &quot;INSRWI  $dst, $src, $pos, $shift&quot; %}
13681   size(4);
13682   ins_encode %{
13683     // TODO: PPC port $archOpcode(ppc64Opcode_rlwimi);
13684     __ insrwi($dst$$Register, $src$$Register, $shift$$constant, $pos$$constant);
13685   %}
13686   ins_pipe(pipe_class_default);
13687 %}
13688 
13689 // As insrwi_a, but with USE_DEF.
13690 instruct insrwi(iRegIdst dst, iRegIsrc src, immI16 pos, immI16 shift) %{
13691   effect(USE_DEF dst, USE src, USE pos, USE shift);
13692   predicate(false);
13693 
13694   format %{ &quot;INSRWI  $dst, $src, $pos, $shift&quot; %}
13695   size(4);
13696   ins_encode %{
13697     // TODO: PPC port $archOpcode(ppc64Opcode_rlwimi);
13698     __ insrwi($dst$$Register, $src$$Register, $shift$$constant, $pos$$constant);
13699   %}
13700   ins_pipe(pipe_class_default);
13701 %}
13702 
13703 // Just slightly faster than java implementation.
13704 instruct bytes_reverse_int_Ex(iRegIdst dst, iRegIsrc src) %{
13705   match(Set dst (ReverseBytesI src));
13706   ins_cost(7*DEFAULT_COST);
13707 
13708   expand %{
13709     immI16 imm24 %{ (int) 24 %}
13710     immI16 imm16 %{ (int) 16 %}
13711     immI16  imm8 %{ (int)  8 %}
13712     immI16  imm4 %{ (int)  4 %}
13713     immI16  imm0 %{ (int)  0 %}
13714     iRegLdst tmpI1;
13715     iRegLdst tmpI2;
13716     iRegLdst tmpI3;
13717 
13718     urShiftI_reg_imm(tmpI1, src, imm24);
13719     insrwi_a(dst, tmpI1, imm24, imm8);
13720     urShiftI_reg_imm(tmpI2, src, imm16);
13721     insrwi(dst, tmpI2, imm8, imm16);
13722     urShiftI_reg_imm(tmpI3, src, imm8);
13723     insrwi(dst, tmpI3, imm8, imm8);
13724     insrwi(dst, src, imm0, imm8);
13725   %}
13726 %}
13727 
13728 instruct bytes_reverse_long_Ex(iRegLdst dst, iRegLsrc src) %{
13729   match(Set dst (ReverseBytesL src));
13730   ins_cost(15*DEFAULT_COST);
13731 
13732   expand %{
13733     immI16 imm56 %{ (int) 56 %}
13734     immI16 imm48 %{ (int) 48 %}
13735     immI16 imm40 %{ (int) 40 %}
13736     immI16 imm32 %{ (int) 32 %}
13737     immI16 imm24 %{ (int) 24 %}
13738     immI16 imm16 %{ (int) 16 %}
13739     immI16  imm8 %{ (int)  8 %}
13740     immI16  imm0 %{ (int)  0 %}
13741     iRegLdst tmpL1;
13742     iRegLdst tmpL2;
13743     iRegLdst tmpL3;
13744     iRegLdst tmpL4;
13745     iRegLdst tmpL5;
13746     iRegLdst tmpL6;
13747 
13748                                         // src   : |a|b|c|d|e|f|g|h|
13749     rldicl(tmpL1, src, imm8, imm24);    // tmpL1 : | | | |e|f|g|h|a|
13750     rldicl(tmpL2, tmpL1, imm32, imm24); // tmpL2 : | | | |a| | | |e|
13751     rldicl(tmpL3, tmpL2, imm32, imm0);  // tmpL3 : | | | |e| | | |a|
13752     rldicl(tmpL1, src, imm16, imm24);   // tmpL1 : | | | |f|g|h|a|b|
13753     rldicl(tmpL2, tmpL1, imm32, imm24); // tmpL2 : | | | |b| | | |f|
13754     rldicl(tmpL4, tmpL2, imm40, imm0);  // tmpL4 : | | |f| | | |b| |
13755     orL_reg_reg(tmpL5, tmpL3, tmpL4);   // tmpL5 : | | |f|e| | |b|a|
13756     rldicl(tmpL1, src, imm24, imm24);   // tmpL1 : | | | |g|h|a|b|c|
13757     rldicl(tmpL2, tmpL1, imm32, imm24); // tmpL2 : | | | |c| | | |g|
13758     rldicl(tmpL3, tmpL2, imm48, imm0);  // tmpL3 : | |g| | | |c| | |
13759     rldicl(tmpL1, src, imm32, imm24);   // tmpL1 : | | | |h|a|b|c|d|
13760     rldicl(tmpL2, tmpL1, imm32, imm24); // tmpL2 : | | | |d| | | |h|
13761     rldicl(tmpL4, tmpL2, imm56, imm0);  // tmpL4 : |h| | | |d| | | |
13762     orL_reg_reg(tmpL6, tmpL3, tmpL4);   // tmpL6 : |h|g| | |d|c| | |
13763     orL_reg_reg(dst, tmpL5, tmpL6);     // dst   : |h|g|f|e|d|c|b|a|
13764   %}
13765 %}
13766 
13767 instruct bytes_reverse_ushort_Ex(iRegIdst dst, iRegIsrc src) %{
13768   match(Set dst (ReverseBytesUS src));
13769   ins_cost(2*DEFAULT_COST);
13770 
13771   expand %{
13772     immI16  imm16 %{ (int) 16 %}
13773     immI16   imm8 %{ (int)  8 %}
13774 
13775     urShiftI_reg_imm(dst, src, imm8);
13776     insrwi(dst, src, imm16, imm8);
13777   %}
13778 %}
13779 
13780 instruct bytes_reverse_short_Ex(iRegIdst dst, iRegIsrc src) %{
13781   match(Set dst (ReverseBytesS src));
13782   ins_cost(3*DEFAULT_COST);
13783 
13784   expand %{
13785     immI16  imm16 %{ (int) 16 %}
13786     immI16   imm8 %{ (int)  8 %}
13787     iRegLdst tmpI1;
13788 
13789     urShiftI_reg_imm(tmpI1, src, imm8);
13790     insrwi(tmpI1, src, imm16, imm8);
13791     extsh(dst, tmpI1);
13792   %}
13793 %}
13794 
13795 // Load Integer reversed byte order
13796 instruct loadI_reversed(iRegIdst dst, indirect mem) %{
13797   match(Set dst (ReverseBytesI (LoadI mem)));
13798   ins_cost(MEMORY_REF_COST);
13799 
13800   size(4);
13801   ins_encode %{
13802     __ lwbrx($dst$$Register, $mem$$Register);
13803   %}
13804   ins_pipe(pipe_class_default);
13805 %}
13806 
13807 // Load Long - aligned and reversed
13808 instruct loadL_reversed(iRegLdst dst, indirect mem) %{
13809   match(Set dst (ReverseBytesL (LoadL mem)));
13810   predicate(VM_Version::has_ldbrx());
13811   ins_cost(MEMORY_REF_COST);
13812 
13813   size(4);
13814   ins_encode %{
13815     __ ldbrx($dst$$Register, $mem$$Register);
13816   %}
13817   ins_pipe(pipe_class_default);
13818 %}
13819 
13820 // Load unsigned short / char reversed byte order
13821 instruct loadUS_reversed(iRegIdst dst, indirect mem) %{
13822   match(Set dst (ReverseBytesUS (LoadUS mem)));
13823   ins_cost(MEMORY_REF_COST);
13824 
13825   size(4);
13826   ins_encode %{
13827     __ lhbrx($dst$$Register, $mem$$Register);
13828   %}
13829   ins_pipe(pipe_class_default);
13830 %}
13831 
13832 // Load short reversed byte order
13833 instruct loadS_reversed(iRegIdst dst, indirect mem) %{
13834   match(Set dst (ReverseBytesS (LoadS mem)));
13835   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
13836 
13837   size(8);
13838   ins_encode %{
13839     __ lhbrx($dst$$Register, $mem$$Register);
13840     __ extsh($dst$$Register, $dst$$Register);
13841   %}
13842   ins_pipe(pipe_class_default);
13843 %}
13844 
13845 // Store Integer reversed byte order
13846 instruct storeI_reversed(iRegIsrc src, indirect mem) %{
13847   match(Set mem (StoreI mem (ReverseBytesI src)));
13848   ins_cost(MEMORY_REF_COST);
13849 
13850   size(4);
13851   ins_encode %{
13852     __ stwbrx($src$$Register, $mem$$Register);
13853   %}
13854   ins_pipe(pipe_class_default);
13855 %}
13856 
13857 // Store Long reversed byte order
13858 instruct storeL_reversed(iRegLsrc src, indirect mem) %{
13859   match(Set mem (StoreL mem (ReverseBytesL src)));
13860   predicate(VM_Version::has_stdbrx());
13861   ins_cost(MEMORY_REF_COST);
13862 
13863   size(4);
13864   ins_encode %{
13865     __ stdbrx($src$$Register, $mem$$Register);
13866   %}
13867   ins_pipe(pipe_class_default);
13868 %}
13869 
13870 // Store unsigned short / char reversed byte order
13871 instruct storeUS_reversed(iRegIsrc src, indirect mem) %{
13872   match(Set mem (StoreC mem (ReverseBytesUS src)));
13873   ins_cost(MEMORY_REF_COST);
13874 
13875   size(4);
13876   ins_encode %{
13877     __ sthbrx($src$$Register, $mem$$Register);
13878   %}
13879   ins_pipe(pipe_class_default);
13880 %}
13881 
13882 // Store short reversed byte order
13883 instruct storeS_reversed(iRegIsrc src, indirect mem) %{
13884   match(Set mem (StoreC mem (ReverseBytesS src)));
13885   ins_cost(MEMORY_REF_COST);
13886 
13887   size(4);
13888   ins_encode %{
13889     __ sthbrx($src$$Register, $mem$$Register);
13890   %}
13891   ins_pipe(pipe_class_default);
13892 %}
13893 
13894 instruct mtvsrwz(vecX temp1, iRegIsrc src) %{
13895   effect(DEF temp1, USE src);
13896 
13897   format %{ &quot;MTVSRWZ $temp1, $src \t// Move to 16-byte register&quot; %}
13898   size(4);
13899   ins_encode %{
13900     __ mtvsrwz($temp1$$VectorSRegister, $src$$Register);
13901   %}
13902   ins_pipe(pipe_class_default);
13903 %}
13904 
13905 instruct xxspltw(vecX dst, vecX src, immI8 imm1) %{
13906   effect(DEF dst, USE src, USE imm1);
13907 
13908   format %{ &quot;XXSPLTW $dst, $src, $imm1 \t// Splat word&quot; %}
13909   size(4);
13910   ins_encode %{
13911     __ xxspltw($dst$$VectorSRegister, $src$$VectorSRegister, $imm1$$constant);
13912   %}
13913   ins_pipe(pipe_class_default);
13914 %}
13915 
13916 instruct xscvdpspn_regF(vecX dst, regF src) %{
13917   effect(DEF dst, USE src);
13918 
13919   format %{ &quot;XSCVDPSPN $dst, $src \t// Convert scalar single precision to vector single precision&quot; %}
13920   size(4);
13921   ins_encode %{
13922     __ xscvdpspn($dst$$VectorSRegister, $src$$FloatRegister-&gt;to_vsr());
13923   %}
13924   ins_pipe(pipe_class_default);
13925 %}
13926 
13927 //---------- Replicate Vector Instructions ------------------------------------
13928 
13929 // Insrdi does replicate if src == dst.
13930 instruct repl32(iRegLdst dst) %{
13931   predicate(false);
13932   effect(USE_DEF dst);
13933 
13934   format %{ &quot;INSRDI  $dst, #0, $dst, #32 \t// replicate&quot; %}
13935   size(4);
13936   ins_encode %{
13937     // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
13938     __ insrdi($dst$$Register, $dst$$Register, 32, 0);
13939   %}
13940   ins_pipe(pipe_class_default);
13941 %}
13942 
13943 // Insrdi does replicate if src == dst.
13944 instruct repl48(iRegLdst dst) %{
13945   predicate(false);
13946   effect(USE_DEF dst);
13947 
13948   format %{ &quot;INSRDI  $dst, #0, $dst, #48 \t// replicate&quot; %}
13949   size(4);
13950   ins_encode %{
13951     // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
13952     __ insrdi($dst$$Register, $dst$$Register, 48, 0);
13953   %}
13954   ins_pipe(pipe_class_default);
13955 %}
13956 
13957 // Insrdi does replicate if src == dst.
13958 instruct repl56(iRegLdst dst) %{
13959   predicate(false);
13960   effect(USE_DEF dst);
13961 
13962   format %{ &quot;INSRDI  $dst, #0, $dst, #56 \t// replicate&quot; %}
13963   size(4);
13964   ins_encode %{
13965     // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
13966     __ insrdi($dst$$Register, $dst$$Register, 56, 0);
13967   %}
13968   ins_pipe(pipe_class_default);
13969 %}
13970 
13971 instruct repl8B_reg_Ex(iRegLdst dst, iRegIsrc src) %{
13972   match(Set dst (ReplicateB src));
13973   predicate(n-&gt;as_Vector()-&gt;length() == 8);
13974   expand %{
13975     moveReg(dst, src);
13976     repl56(dst);
13977     repl48(dst);
13978     repl32(dst);
13979   %}
13980 %}
13981 
13982 instruct repl8B_immI0(iRegLdst dst, immI_0 zero) %{
13983   match(Set dst (ReplicateB zero));
13984   predicate(n-&gt;as_Vector()-&gt;length() == 8);
13985   format %{ &quot;LI      $dst, #0 \t// replicate8B&quot; %}
13986   size(4);
13987   ins_encode %{
13988     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
13989     __ li($dst$$Register, (int)((short)($zero$$constant &amp; 0xFFFF)));
13990   %}
13991   ins_pipe(pipe_class_default);
13992 %}
13993 
13994 instruct repl8B_immIminus1(iRegLdst dst, immI_minus1 src) %{
13995   match(Set dst (ReplicateB src));
13996   predicate(n-&gt;as_Vector()-&gt;length() == 8);
13997   format %{ &quot;LI      $dst, #-1 \t// replicate8B&quot; %}
13998   size(4);
13999   ins_encode %{
14000     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14001     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
14002   %}
14003   ins_pipe(pipe_class_default);
14004 %}
14005 
14006 instruct repl16B_reg_Ex(vecX dst, iRegIsrc src) %{
14007   match(Set dst (ReplicateB src));
14008   predicate(n-&gt;as_Vector()-&gt;length() == 16);
14009 
14010   expand %{
14011     iRegLdst tmpL;
14012     vecX tmpV;
14013     immI8  imm1 %{ (int)  1 %}
14014     moveReg(tmpL, src);
14015     repl56(tmpL);
14016     repl48(tmpL);
14017     mtvsrwz(tmpV, tmpL);
14018     xxspltw(dst, tmpV, imm1);
14019   %}
14020 %}
14021 
14022 instruct repl16B_immI0(vecX dst, immI_0 zero) %{
14023   match(Set dst (ReplicateB zero));
14024   predicate(n-&gt;as_Vector()-&gt;length() == 16);
14025 
14026   format %{ &quot;XXLXOR      $dst, $zero \t// replicate16B&quot; %}
14027   size(4);
14028   ins_encode %{
14029     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14030   %}
14031   ins_pipe(pipe_class_default);
14032 %}
14033 
14034 instruct repl16B_immIminus1(vecX dst, immI_minus1 src) %{
14035   match(Set dst (ReplicateB src));
14036   predicate(n-&gt;as_Vector()-&gt;length() == 16);
14037 
14038   format %{ &quot;XXLEQV      $dst, $src \t// replicate16B&quot; %}
14039   size(4);
14040   ins_encode %{
14041     __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14042   %}
14043   ins_pipe(pipe_class_default);
14044 %}
14045 
14046 instruct repl4S_reg_Ex(iRegLdst dst, iRegIsrc src) %{
14047   match(Set dst (ReplicateS src));
14048   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14049   expand %{
14050     moveReg(dst, src);
14051     repl48(dst);
14052     repl32(dst);
14053   %}
14054 %}
14055 
14056 instruct repl4S_immI0(iRegLdst dst, immI_0 zero) %{
14057   match(Set dst (ReplicateS zero));
14058   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14059   format %{ &quot;LI      $dst, #0 \t// replicate4S&quot; %}
14060   size(4);
14061   ins_encode %{
14062     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14063     __ li($dst$$Register, (int)((short)($zero$$constant &amp; 0xFFFF)));
14064   %}
14065   ins_pipe(pipe_class_default);
14066 %}
14067 
14068 instruct repl4S_immIminus1(iRegLdst dst, immI_minus1 src) %{
14069   match(Set dst (ReplicateS src));
14070   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14071   format %{ &quot;LI      $dst, -1 \t// replicate4S&quot; %}
14072   size(4);
14073   ins_encode %{
14074     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14075     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
14076   %}
14077   ins_pipe(pipe_class_default);
14078 %}
14079 
14080 instruct repl8S_reg_Ex(vecX dst, iRegIsrc src) %{
14081   match(Set dst (ReplicateS src));
14082   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14083 
14084   expand %{
14085     iRegLdst tmpL;
14086     vecX tmpV;
14087     immI8  zero %{ (int)  0 %}
14088     moveReg(tmpL, src);
14089     repl48(tmpL);
14090     repl32(tmpL);
14091     mtvsrd(tmpV, tmpL);
14092     xxpermdi(dst, tmpV, tmpV, zero);
14093   %}
14094 %}
14095 
14096 instruct repl8S_immI0(vecX dst, immI_0 zero) %{
14097   match(Set dst (ReplicateS zero));
14098   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14099 
14100   format %{ &quot;XXLXOR      $dst, $zero \t// replicate8S&quot; %}
14101   size(4);
14102   ins_encode %{
14103     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14104   %}
14105   ins_pipe(pipe_class_default);
14106 %}
14107 
14108 instruct repl8S_immIminus1(vecX dst, immI_minus1 src) %{
14109   match(Set dst (ReplicateS src));
14110   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14111 
14112   format %{ &quot;XXLEQV      $dst, $src \t// replicate8S&quot; %}
14113   size(4);
14114   ins_encode %{
14115     __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14116   %}
14117   ins_pipe(pipe_class_default);
14118 %}
14119 
14120 instruct repl2I_reg_Ex(iRegLdst dst, iRegIsrc src) %{
14121   match(Set dst (ReplicateI src));
14122   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14123   ins_cost(2 * DEFAULT_COST);
14124   expand %{
14125     moveReg(dst, src);
14126     repl32(dst);
14127   %}
14128 %}
14129 
14130 instruct repl2I_immI0(iRegLdst dst, immI_0 zero) %{
14131   match(Set dst (ReplicateI zero));
14132   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14133   format %{ &quot;LI      $dst, #0 \t// replicate2I&quot; %}
14134   size(4);
14135   ins_encode %{
14136     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14137     __ li($dst$$Register, (int)((short)($zero$$constant &amp; 0xFFFF)));
14138   %}
14139   ins_pipe(pipe_class_default);
14140 %}
14141 
14142 instruct repl2I_immIminus1(iRegLdst dst, immI_minus1 src) %{
14143   match(Set dst (ReplicateI src));
14144   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14145   format %{ &quot;LI      $dst, -1 \t// replicate2I&quot; %}
14146   size(4);
14147   ins_encode %{
14148     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14149     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
14150   %}
14151   ins_pipe(pipe_class_default);
14152 %}
14153 
14154 instruct repl4I_reg_Ex(vecX dst, iRegIsrc src) %{
14155   match(Set dst (ReplicateI src));
14156   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14157   ins_cost(2 * DEFAULT_COST);
14158 
14159   expand %{
14160     iRegLdst tmpL;
14161     vecX tmpV;
14162     immI8  zero %{ (int)  0 %}
14163     moveReg(tmpL, src);
14164     repl32(tmpL);
14165     mtvsrd(tmpV, tmpL);
14166     xxpermdi(dst, tmpV, tmpV, zero);
14167   %}
14168 %}
14169 
14170 instruct repl4I_immI0(vecX dst, immI_0 zero) %{
14171   match(Set dst (ReplicateI zero));
14172   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14173 
14174   format %{ &quot;XXLXOR      $dst, $zero \t// replicate4I&quot; %}
14175   size(4);
14176   ins_encode %{
14177     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14178   %}
14179   ins_pipe(pipe_class_default);
14180 %}
14181 
14182 instruct repl4I_immIminus1(vecX dst, immI_minus1 src) %{
14183   match(Set dst (ReplicateI src));
14184   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14185 
14186   format %{ &quot;XXLEQV      $dst, $dst, $dst \t// replicate4I&quot; %}
14187   size(4);
14188   ins_encode %{
14189     __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14190   %}
14191   ins_pipe(pipe_class_default);
14192 %}
14193 
14194 // Move float to int register via stack, replicate.
14195 instruct repl2F_reg_Ex(iRegLdst dst, regF src) %{
14196   match(Set dst (ReplicateF src));
14197   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14198   ins_cost(2 * MEMORY_REF_COST + DEFAULT_COST);
14199   expand %{
14200     stackSlotL tmpS;
14201     iRegIdst tmpI;
14202     moveF2I_reg_stack(tmpS, src);   // Move float to stack.
14203     moveF2I_stack_reg(tmpI, tmpS);  // Move stack to int reg.
14204     moveReg(dst, tmpI);             // Move int to long reg.
14205     repl32(dst);                    // Replicate bitpattern.
14206   %}
14207 %}
14208 
14209 // Replicate scalar constant to packed float values in Double register
14210 instruct repl2F_immF_Ex(iRegLdst dst, immF src) %{
14211   match(Set dst (ReplicateF src));
14212   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14213   ins_cost(5 * DEFAULT_COST);
14214 
14215   format %{ &quot;LD      $dst, offset, $constanttablebase\t// load replicated float $src $src from table, postalloc expanded&quot; %}
14216   postalloc_expand( postalloc_expand_load_replF_constant(dst, src, constanttablebase) );
14217 %}
14218 
14219 // Replicate scalar zero constant to packed float values in Double register
14220 instruct repl2F_immF0(iRegLdst dst, immF_0 zero) %{
14221   match(Set dst (ReplicateF zero));
14222   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14223 
14224   format %{ &quot;LI      $dst, #0 \t// replicate2F&quot; %}
14225   ins_encode %{
14226     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14227     __ li($dst$$Register, 0x0);
14228   %}
14229   ins_pipe(pipe_class_default);
14230 %}
14231 
14232 
14233 //----------Vector Arithmetic Instructions--------------------------------------
14234 
14235 // Vector Addition Instructions
14236 
14237 instruct vadd16B_reg(vecX dst, vecX src1, vecX src2) %{
14238   match(Set dst (AddVB src1 src2));
14239   predicate(n-&gt;as_Vector()-&gt;length() == 16);
14240   format %{ &quot;VADDUBM  $dst,$src1,$src2\t// add packed16B&quot; %}
14241   size(4);
14242   ins_encode %{
14243     __ vaddubm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14244   %}
14245   ins_pipe(pipe_class_default);
14246 %}
14247 
14248 instruct vadd8S_reg(vecX dst, vecX src1, vecX src2) %{
14249   match(Set dst (AddVS src1 src2));
14250   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14251   format %{ &quot;VADDUHM  $dst,$src1,$src2\t// add packed8S&quot; %}
14252   size(4);
14253   ins_encode %{
14254     __ vadduhm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14255   %}
14256   ins_pipe(pipe_class_default);
14257 %}
14258 
14259 instruct vadd4I_reg(vecX dst, vecX src1, vecX src2) %{
14260   match(Set dst (AddVI src1 src2));
14261   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14262   format %{ &quot;VADDUWM  $dst,$src1,$src2\t// add packed4I&quot; %}
14263   size(4);
14264   ins_encode %{
14265     __ vadduwm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14266   %}
14267   ins_pipe(pipe_class_default);
14268 %}
14269 
14270 instruct vadd4F_reg(vecX dst, vecX src1, vecX src2) %{
14271   match(Set dst (AddVF src1 src2));
14272   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14273   format %{ &quot;VADDFP  $dst,$src1,$src2\t// add packed4F&quot; %}
14274   size(4);
14275   ins_encode %{
14276     __ vaddfp($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14277   %}
14278   ins_pipe(pipe_class_default);
14279 %}
14280 
14281 instruct vadd2L_reg(vecX dst, vecX src1, vecX src2) %{
14282   match(Set dst (AddVL src1 src2));
14283   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14284   format %{ &quot;VADDUDM  $dst,$src1,$src2\t// add packed2L&quot; %}
14285   size(4);
14286   ins_encode %{
14287     __ vaddudm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14288   %}
14289   ins_pipe(pipe_class_default);
14290 %}
14291 
14292 instruct vadd2D_reg(vecX dst, vecX src1, vecX src2) %{
14293   match(Set dst (AddVD src1 src2));
14294   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14295   format %{ &quot;XVADDDP  $dst,$src1,$src2\t// add packed2D&quot; %}
14296   size(4);
14297   ins_encode %{
14298     __ xvadddp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14299   %}
14300   ins_pipe(pipe_class_default);
14301 %}
14302 
14303 // Vector Subtraction Instructions
14304 
14305 instruct vsub16B_reg(vecX dst, vecX src1, vecX src2) %{
14306   match(Set dst (SubVB src1 src2));
14307   predicate(n-&gt;as_Vector()-&gt;length() == 16);
14308   format %{ &quot;VSUBUBM  $dst,$src1,$src2\t// sub packed16B&quot; %}
14309   size(4);
14310   ins_encode %{
14311     __ vsububm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14312   %}
14313   ins_pipe(pipe_class_default);
14314 %}
14315 
14316 instruct vsub8S_reg(vecX dst, vecX src1, vecX src2) %{
14317   match(Set dst (SubVS src1 src2));
14318   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14319   format %{ &quot;VSUBUHM  $dst,$src1,$src2\t// sub packed8S&quot; %}
14320   size(4);
14321   ins_encode %{
14322     __ vsubuhm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14323   %}
14324   ins_pipe(pipe_class_default);
14325 %}
14326 
14327 instruct vsub4I_reg(vecX dst, vecX src1, vecX src2) %{
14328   match(Set dst (SubVI src1 src2));
14329   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14330   format %{ &quot;VSUBUWM  $dst,$src1,$src2\t// sub packed4I&quot; %}
14331   size(4);
14332   ins_encode %{
14333     __ vsubuwm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14334   %}
14335   ins_pipe(pipe_class_default);
14336 %}
14337 
14338 instruct vsub4F_reg(vecX dst, vecX src1, vecX src2) %{
14339   match(Set dst (SubVF src1 src2));
14340   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14341   format %{ &quot;VSUBFP  $dst,$src1,$src2\t// sub packed4F&quot; %}
14342   size(4);
14343   ins_encode %{
14344     __ vsubfp($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14345   %}
14346   ins_pipe(pipe_class_default);
14347 %}
14348 
14349 instruct vsub2L_reg(vecX dst, vecX src1, vecX src2) %{
14350   match(Set dst (SubVL src1 src2));
14351   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14352   format %{ &quot;VSUBUDM  $dst,$src1,$src2\t// sub packed2L&quot; %}
14353   size(4);
14354   ins_encode %{
14355     __ vsubudm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14356   %}
14357   ins_pipe(pipe_class_default);
14358 %}
14359 
14360 instruct vsub2D_reg(vecX dst, vecX src1, vecX src2) %{
14361   match(Set dst (SubVD src1 src2));
14362   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14363   format %{ &quot;XVSUBDP  $dst,$src1,$src2\t// sub packed2D&quot; %}
14364   size(4);
14365   ins_encode %{
14366     __ xvsubdp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14367   %}
14368   ins_pipe(pipe_class_default);
14369 %}
14370 
14371 // Vector Multiplication Instructions
14372 
14373 instruct vmul8S_reg(vecX dst, vecX src1, vecX src2, vecX tmp) %{
14374   match(Set dst (MulVS src1 src2));
14375   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14376   effect(TEMP tmp);
14377   format %{ &quot;VSPLTISH  $tmp,0\t// mul packed8S&quot; %}
14378   format %{ &quot;VMLADDUHM  $dst,$src1,$src2\t// mul packed8S&quot; %}
14379   size(8);
14380   ins_encode %{
14381     __ vspltish($tmp$$VectorSRegister-&gt;to_vr(), 0);
14382     __ vmladduhm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr(), $tmp$$VectorSRegister-&gt;to_vr());
14383   %}
14384   ins_pipe(pipe_class_default);
14385 %}
14386 
14387 instruct vmul4I_reg(vecX dst, vecX src1, vecX src2) %{
14388   match(Set dst (MulVI src1 src2));
14389   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14390   format %{ &quot;VMULUWM  $dst,$src1,$src2\t// mul packed4I&quot; %}
14391   size(4);
14392   ins_encode %{
14393     __ vmuluwm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14394   %}
14395   ins_pipe(pipe_class_default);
14396 %}
14397 
14398 instruct vmul4F_reg(vecX dst, vecX src1, vecX src2) %{
14399   match(Set dst (MulVF src1 src2));
14400   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14401   format %{ &quot;XVMULSP  $dst,$src1,$src2\t// mul packed4F&quot; %}
14402   size(4);
14403   ins_encode %{
14404     __ xvmulsp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14405   %}
14406   ins_pipe(pipe_class_default);
14407 %}
14408 
14409 instruct vmul2D_reg(vecX dst, vecX src1, vecX src2) %{
14410   match(Set dst (MulVD src1 src2));
14411   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14412   format %{ &quot;XVMULDP  $dst,$src1,$src2\t// mul packed2D&quot; %}
14413   size(4);
14414   ins_encode %{
14415     __ xvmuldp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14416   %}
14417   ins_pipe(pipe_class_default);
14418 %}
14419 
14420 // Vector Division Instructions
14421 
14422 instruct vdiv4F_reg(vecX dst, vecX src1, vecX src2) %{
14423   match(Set dst (DivVF src1 src2));
14424   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14425   format %{ &quot;XVDIVSP  $dst,$src1,$src2\t// div packed4F&quot; %}
14426   size(4);
14427   ins_encode %{
14428     __ xvdivsp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14429   %}
14430   ins_pipe(pipe_class_default);
14431 %}
14432 
14433 instruct vdiv2D_reg(vecX dst, vecX src1, vecX src2) %{
14434   match(Set dst (DivVD src1 src2));
14435   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14436   format %{ &quot;XVDIVDP  $dst,$src1,$src2\t// div packed2D&quot; %}
14437   size(4);
14438   ins_encode %{
14439     __ xvdivdp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14440   %}
14441   ins_pipe(pipe_class_default);
14442 %}
14443 
14444 // Vector Absolute Instructions
14445 
14446 instruct vabs4F_reg(vecX dst, vecX src) %{
14447   match(Set dst (AbsVF src));
14448   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14449   format %{ &quot;XVABSSP $dst,$src\t// absolute packed4F&quot; %}
14450   size(4);
14451   ins_encode %{
14452     __ xvabssp($dst$$VectorSRegister, $src$$VectorSRegister);
14453   %}
14454   ins_pipe(pipe_class_default);
14455 %}
14456 
14457 instruct vabs2D_reg(vecX dst, vecX src) %{
14458   match(Set dst (AbsVD src));
14459   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14460   format %{ &quot;XVABSDP $dst,$src\t// absolute packed2D&quot; %}
14461   size(4);
14462   ins_encode %{
14463     __ xvabsdp($dst$$VectorSRegister, $src$$VectorSRegister);
14464   %}
14465   ins_pipe(pipe_class_default);
14466 %}
14467 
14468 // Round Instructions
14469 instruct roundD_reg(regD dst, regD src, immI8 rmode) %{
14470   match(Set dst (RoundDoubleMode src rmode));
14471   format %{ &quot;RoundDoubleMode $src,$rmode&quot; %}
14472   size(4);
14473   ins_encode %{
14474     switch ($rmode$$constant) {
14475       case RoundDoubleModeNode::rmode_rint:
14476         __ frin($dst$$FloatRegister, $src$$FloatRegister);
14477         break;
14478       case RoundDoubleModeNode::rmode_floor:
14479         __ frim($dst$$FloatRegister, $src$$FloatRegister);
14480         break;
14481       case RoundDoubleModeNode::rmode_ceil:
14482         __ frip($dst$$FloatRegister, $src$$FloatRegister);
14483         break;
14484       default:
14485         ShouldNotReachHere();
14486     }
14487   %}
14488   ins_pipe(pipe_class_default);
14489 %}
14490 
14491 // Vector Round Instructions
14492 instruct vround2D_reg(vecX dst, vecX src, immI8 rmode) %{
14493   match(Set dst (RoundDoubleModeV src rmode));
14494   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14495   format %{ &quot;RoundDoubleModeV $src,$rmode&quot; %}
14496   size(4);
14497   ins_encode %{
14498     switch ($rmode$$constant) {
14499       case RoundDoubleModeNode::rmode_rint:
14500         __ xvrdpi($dst$$VectorSRegister, $src$$VectorSRegister);
14501         break;
14502       case RoundDoubleModeNode::rmode_floor:
14503         __ xvrdpim($dst$$VectorSRegister, $src$$VectorSRegister);
14504         break;
14505       case RoundDoubleModeNode::rmode_ceil:
14506         __ xvrdpip($dst$$VectorSRegister, $src$$VectorSRegister);
14507         break;
14508       default:
14509         ShouldNotReachHere();
14510     }
14511   %}
14512   ins_pipe(pipe_class_default);
14513 %}
14514 
14515 // Vector Negate Instructions
14516 
14517 instruct vneg4F_reg(vecX dst, vecX src) %{
14518   match(Set dst (NegVF src));
14519   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14520   format %{ &quot;XVNEGSP $dst,$src\t// negate packed4F&quot; %}
14521   size(4);
14522   ins_encode %{
14523     __ xvnegsp($dst$$VectorSRegister, $src$$VectorSRegister);
14524   %}
14525   ins_pipe(pipe_class_default);
14526 %}
14527 
14528 instruct vneg2D_reg(vecX dst, vecX src) %{
14529   match(Set dst (NegVD src));
14530   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14531   format %{ &quot;XVNEGDP $dst,$src\t// negate packed2D&quot; %}
14532   size(4);
14533   ins_encode %{
14534     __ xvnegdp($dst$$VectorSRegister, $src$$VectorSRegister);
14535   %}
14536   ins_pipe(pipe_class_default);
14537 %}
14538 
14539 // Vector Square Root Instructions
14540 
14541 instruct vsqrt4F_reg(vecX dst, vecX src) %{
14542   match(Set dst (SqrtVF src));
14543   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14544   format %{ &quot;XVSQRTSP $dst,$src\t// sqrt packed4F&quot; %}
14545   size(4);
14546   ins_encode %{
14547     __ xvsqrtsp($dst$$VectorSRegister, $src$$VectorSRegister);
14548   %}
14549   ins_pipe(pipe_class_default);
14550 %}
14551 
14552 instruct vsqrt2D_reg(vecX dst, vecX src) %{
14553   match(Set dst (SqrtVD src));
14554   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14555   format %{ &quot;XVSQRTDP  $dst,$src\t// sqrt packed2D&quot; %}
14556   size(4);
14557   ins_encode %{
14558     __ xvsqrtdp($dst$$VectorSRegister, $src$$VectorSRegister);
14559   %}
14560   ins_pipe(pipe_class_default);
14561 %}
14562 
14563 // Vector Population Count Instructions
14564 
14565 instruct vpopcnt4I_reg(vecX dst, vecX src) %{
14566   match(Set dst (PopCountVI src));
14567   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14568   format %{ &quot;VPOPCNTW $dst,$src\t// pop count packed4I&quot; %}
14569   size(4);
14570   ins_encode %{
14571     __ vpopcntw($dst$$VectorSRegister-&gt;to_vr(), $src$$VectorSRegister-&gt;to_vr());
14572   %}
14573   ins_pipe(pipe_class_default);
14574 %}
14575 
14576 // --------------------------------- FMA --------------------------------------
14577 // dst + src1 * src2
14578 instruct vfma4F(vecX dst, vecX src1, vecX src2) %{
14579   match(Set dst (FmaVF dst (Binary src1 src2)));
14580   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14581 
14582   format %{ &quot;XVMADDASP   $dst, $src1, $src2&quot; %}
14583 
14584   size(4);
14585   ins_encode %{
14586     __ xvmaddasp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14587   %}
14588   ins_pipe(pipe_class_default);
14589 %}
14590 
14591 // dst - src1 * src2
14592 instruct vfma4F_neg1(vecX dst, vecX src1, vecX src2) %{
14593   match(Set dst (FmaVF dst (Binary (NegVF src1) src2)));
14594   match(Set dst (FmaVF dst (Binary src1 (NegVF src2))));
14595   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14596 
14597   format %{ &quot;XVNMSUBASP   $dst, $src1, $src2&quot; %}
14598 
14599   size(4);
14600   ins_encode %{
14601     __ xvnmsubasp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14602   %}
14603   ins_pipe(pipe_class_default);
14604 %}
14605 
14606 // - dst + src1 * src2
14607 instruct vfma4F_neg2(vecX dst, vecX src1, vecX src2) %{
14608   match(Set dst (FmaVF (NegVF dst) (Binary src1 src2)));
14609   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14610 
14611   format %{ &quot;XVMSUBASP   $dst, $src1, $src2&quot; %}
14612 
14613   size(4);
14614   ins_encode %{
14615     __ xvmsubasp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14616   %}
14617   ins_pipe(pipe_class_default);
14618 %}
14619 
14620 // dst + src1 * src2
14621 instruct vfma2D(vecX dst, vecX src1, vecX src2) %{
14622   match(Set dst (FmaVD  dst (Binary src1 src2)));
14623   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14624 
14625   format %{ &quot;XVMADDADP   $dst, $src1, $src2&quot; %}
14626 
14627   size(4);
14628   ins_encode %{
14629     __ xvmaddadp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14630   %}
14631   ins_pipe(pipe_class_default);
14632 %}
14633 
14634 // dst - src1 * src2
14635 instruct vfma2D_neg1(vecX dst, vecX src1, vecX src2) %{
14636   match(Set dst (FmaVD  dst (Binary (NegVD src1) src2)));
14637   match(Set dst (FmaVD  dst (Binary src1 (NegVD src2))));
14638   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14639 
14640   format %{ &quot;XVNMSUBADP   $dst, $src1, $src2&quot; %}
14641 
14642   size(4);
14643   ins_encode %{
14644     __ xvnmsubadp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14645   %}
14646   ins_pipe(pipe_class_default);
14647 %}
14648 
14649 // - dst + src1 * src2
14650 instruct vfma2D_neg2(vecX dst, vecX src1, vecX src2) %{
14651   match(Set dst (FmaVD (NegVD dst) (Binary src1 src2)));
14652   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14653 
14654   format %{ &quot;XVMSUBADP   $dst, $src1, $src2&quot; %}
14655 
14656   size(4);
14657   ins_encode %{
14658     __ xvmsubadp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14659   %}
14660   ins_pipe(pipe_class_default);
14661 %}
14662 
14663 //----------Overflow Math Instructions-----------------------------------------
14664 
14665 // Note that we have to make sure that XER.SO is reset before using overflow instructions.
14666 // Simple Overflow operations can be matched by very few instructions (e.g. addExact: xor, and_, bc).
14667 // Seems like only Long intrinsincs have an advantage. (The only expensive one is OverflowMulL.)
14668 
14669 instruct overflowAddL_reg_reg(flagsRegCR0 cr0, iRegLsrc op1, iRegLsrc op2) %{
14670   match(Set cr0 (OverflowAddL op1 op2));
14671 
14672   format %{ &quot;add_    $op1, $op2\t# overflow check long&quot; %}
14673   ins_encode %{
14674     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
14675     __ li(R0, 0);
14676     __ mtxer(R0); // clear XER.SO
14677     __ addo_(R0, $op1$$Register, $op2$$Register);
14678   %}
14679   ins_pipe(pipe_class_default);
14680 %}
14681 
14682 instruct overflowSubL_reg_reg(flagsRegCR0 cr0, iRegLsrc op1, iRegLsrc op2) %{
14683   match(Set cr0 (OverflowSubL op1 op2));
14684 
14685   format %{ &quot;subfo_  R0, $op2, $op1\t# overflow check long&quot; %}
14686   ins_encode %{
14687     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
14688     __ li(R0, 0);
14689     __ mtxer(R0); // clear XER.SO
14690     __ subfo_(R0, $op2$$Register, $op1$$Register);
14691   %}
14692   ins_pipe(pipe_class_default);
14693 %}
14694 
14695 instruct overflowNegL_reg(flagsRegCR0 cr0, immL_0 zero, iRegLsrc op2) %{
14696   match(Set cr0 (OverflowSubL zero op2));
14697 
14698   format %{ &quot;nego_   R0, $op2\t# overflow check long&quot; %}
14699   ins_encode %{
14700     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
14701     __ li(R0, 0);
14702     __ mtxer(R0); // clear XER.SO
14703     __ nego_(R0, $op2$$Register);
14704   %}
14705   ins_pipe(pipe_class_default);
14706 %}
14707 
14708 instruct overflowMulL_reg_reg(flagsRegCR0 cr0, iRegLsrc op1, iRegLsrc op2) %{
14709   match(Set cr0 (OverflowMulL op1 op2));
14710 
14711   format %{ &quot;mulldo_ R0, $op1, $op2\t# overflow check long&quot; %}
14712   ins_encode %{
14713     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
14714     __ li(R0, 0);
14715     __ mtxer(R0); // clear XER.SO
14716     __ mulldo_(R0, $op1$$Register, $op2$$Register);
14717   %}
14718   ins_pipe(pipe_class_default);
14719 %}
14720 
14721 instruct repl4F_reg_Ex(vecX dst, regF src) %{
14722   match(Set dst (ReplicateF src));
14723   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14724   ins_cost(DEFAULT_COST);
14725   expand %{
14726     vecX tmpV;
14727     immI8  zero %{ (int)  0 %}
14728 
14729     xscvdpspn_regF(tmpV, src);
14730     xxspltw(dst, tmpV, zero);
14731   %}
14732 %}
14733 
14734 instruct repl4F_immF_Ex(vecX dst, immF src, iRegLdst tmp) %{
14735   match(Set dst (ReplicateF src));
14736   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14737   effect(TEMP tmp);
14738   ins_cost(10 * DEFAULT_COST);
14739 
14740   postalloc_expand( postalloc_expand_load_replF_constant_vsx(dst, src, constanttablebase, tmp) );
14741 %}
14742 
14743 instruct repl4F_immF0(vecX dst, immF_0 zero) %{
14744   match(Set dst (ReplicateF zero));
14745   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14746 
14747   format %{ &quot;XXLXOR      $dst, $zero \t// replicate4F&quot; %}
14748   ins_encode %{
14749     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14750   %}
14751   ins_pipe(pipe_class_default);
14752 %}
14753 
14754 instruct repl2D_reg_Ex(vecX dst, regD src) %{
14755   match(Set dst (ReplicateD src));
14756   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14757 
14758   format %{ &quot;XXPERMDI      $dst, $src, $src, 0 \t// Splat doubleword&quot; %}
14759   size(4);
14760   ins_encode %{
14761     __ xxpermdi($dst$$VectorSRegister, $src$$FloatRegister-&gt;to_vsr(), $src$$FloatRegister-&gt;to_vsr(), 0);
14762   %}
14763   ins_pipe(pipe_class_default);
14764 %}
14765 
14766 instruct repl2D_immD0(vecX dst, immD_0 zero) %{
14767   match(Set dst (ReplicateD zero));
14768   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14769 
14770   format %{ &quot;XXLXOR      $dst, $zero \t// replicate2D&quot; %}
14771   size(4);
14772   ins_encode %{
14773     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14774   %}
14775   ins_pipe(pipe_class_default);
14776 %}
14777 
14778 instruct mtvsrd(vecX dst, iRegLsrc src) %{
14779   predicate(false);
14780   effect(DEF dst, USE src);
14781 
14782   format %{ &quot;MTVSRD      $dst, $src \t// Move to 16-byte register&quot; %}
14783   size(4);
14784   ins_encode %{
14785     __ mtvsrd($dst$$VectorSRegister, $src$$Register);
14786   %}
14787   ins_pipe(pipe_class_default);
14788 %}
14789 
14790 instruct xxspltd(vecX dst, vecX src, immI8 zero) %{
14791   effect(DEF dst, USE src, USE zero);
14792 
14793   format %{ &quot;XXSPLATD      $dst, $src, $zero \t// Splat doubleword&quot; %}
14794   size(4);
14795   ins_encode %{
14796     __ xxpermdi($dst$$VectorSRegister, $src$$VectorSRegister, $src$$VectorSRegister, $zero$$constant);
14797   %}
14798   ins_pipe(pipe_class_default);
14799 %}
14800 
14801 instruct xxpermdi(vecX dst, vecX src1, vecX src2, immI8 zero) %{
14802   effect(DEF dst, USE src1, USE src2, USE zero);
14803 
14804   format %{ &quot;XXPERMDI      $dst, $src1, $src2, $zero \t// Splat doubleword&quot; %}
14805   size(4);
14806   ins_encode %{
14807     __ xxpermdi($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister, $zero$$constant);
14808   %}
14809   ins_pipe(pipe_class_default);
14810 %}
14811 
14812 instruct repl2L_reg_Ex(vecX dst, iRegLsrc src) %{
14813   match(Set dst (ReplicateL src));
14814   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14815   expand %{
14816     vecX tmpV;
14817     immI8  zero %{ (int)  0 %}
14818     mtvsrd(tmpV, src);
14819     xxpermdi(dst, tmpV, tmpV, zero);
14820   %}
14821 %}
14822 
14823 instruct repl2L_immI0(vecX dst, immI_0 zero) %{
14824   match(Set dst (ReplicateL zero));
14825   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14826 
14827   format %{ &quot;XXLXOR      $dst, $zero \t// replicate2L&quot; %}
14828   size(4);
14829   ins_encode %{
14830     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14831   %}
14832   ins_pipe(pipe_class_default);
14833 %}
14834 
14835 instruct repl2L_immIminus1(vecX dst, immI_minus1 src) %{
14836   match(Set dst (ReplicateL src));
14837   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14838 
14839   format %{ &quot;XXLEQV      $dst, $src \t// replicate2L&quot; %}
14840   size(4);
14841   ins_encode %{
14842     __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14843   %}
14844   ins_pipe(pipe_class_default);
14845 %}
14846 
14847 // ============================================================================
14848 // Safepoint Instruction
14849 
14850 instruct safePoint_poll(iRegPdst poll) %{
14851   match(SafePoint poll);
14852 
14853   // It caused problems to add the effect that r0 is killed, but this
14854   // effect no longer needs to be mentioned, since r0 is not contained
14855   // in a reg_class.
14856 
14857   format %{ &quot;LD      R0, #0, $poll \t// Safepoint poll for GC&quot; %}
14858   size(4);
14859   ins_encode( enc_poll(0x0, poll) );
14860   ins_pipe(pipe_class_default);
14861 %}
14862 
14863 // ============================================================================
14864 // Call Instructions
14865 
14866 // Call Java Static Instruction
14867 
14868 // Schedulable version of call static node.
14869 instruct CallStaticJavaDirect(method meth) %{
14870   match(CallStaticJava);
14871   effect(USE meth);
14872   ins_cost(CALL_COST);
14873 
14874   ins_num_consts(3 /* up to 3 patchable constants: inline cache, 2 call targets. */);
14875 
14876   format %{ &quot;CALL,static $meth \t// ==&gt; &quot; %}
14877   size(4);
14878   ins_encode( enc_java_static_call(meth) );
14879   ins_pipe(pipe_class_call);
14880 %}
14881 
14882 // Call Java Dynamic Instruction
14883 
14884 // Used by postalloc expand of CallDynamicJavaDirectSchedEx (actual call).
14885 // Loading of IC was postalloc expanded. The nodes loading the IC are reachable
14886 // via fields ins_field_load_ic_hi_node and ins_field_load_ic_node.
14887 // The call destination must still be placed in the constant pool.
14888 instruct CallDynamicJavaDirectSched(method meth) %{
14889   match(CallDynamicJava); // To get all the data fields we need ...
14890   effect(USE meth);
14891   predicate(false);       // ... but never match.
14892 
14893   ins_field_load_ic_hi_node(loadConL_hiNode*);
14894   ins_field_load_ic_node(loadConLNode*);
14895   ins_num_consts(1 /* 1 patchable constant: call destination */);
14896 
14897   format %{ &quot;BL        \t// dynamic $meth ==&gt; &quot; %}
14898   size(4);
14899   ins_encode( enc_java_dynamic_call_sched(meth) );
14900   ins_pipe(pipe_class_call);
14901 %}
14902 
14903 // Schedulable (i.e. postalloc expanded) version of call dynamic java.
14904 // We use postalloc expanded calls if we use inline caches
14905 // and do not update method data.
14906 //
14907 // This instruction has two constants: inline cache (IC) and call destination.
14908 // Loading the inline cache will be postalloc expanded, thus leaving a call with
14909 // one constant.
14910 instruct CallDynamicJavaDirectSched_Ex(method meth) %{
14911   match(CallDynamicJava);
14912   effect(USE meth);
14913   predicate(UseInlineCaches);
14914   ins_cost(CALL_COST);
14915 
14916   ins_num_consts(2 /* 2 patchable constants: inline cache, call destination. */);
14917 
14918   format %{ &quot;CALL,dynamic $meth \t// postalloc expanded&quot; %}
14919   postalloc_expand( postalloc_expand_java_dynamic_call_sched(meth, constanttablebase) );
14920 %}
14921 
14922 // Compound version of call dynamic java
14923 // We use postalloc expanded calls if we use inline caches
14924 // and do not update method data.
14925 instruct CallDynamicJavaDirect(method meth) %{
14926   match(CallDynamicJava);
14927   effect(USE meth);
14928   predicate(!UseInlineCaches);
14929   ins_cost(CALL_COST);
14930 
14931   // Enc_java_to_runtime_call needs up to 4 constants (method data oop).
14932   ins_num_consts(4);
14933 
14934   format %{ &quot;CALL,dynamic $meth \t// ==&gt; &quot; %}
14935   ins_encode( enc_java_dynamic_call(meth, constanttablebase) );
14936   ins_pipe(pipe_class_call);
14937 %}
14938 
14939 // Call Runtime Instruction
14940 
14941 instruct CallRuntimeDirect(method meth) %{
14942   match(CallRuntime);
14943   effect(USE meth);
14944   ins_cost(CALL_COST);
14945 
14946   // Enc_java_to_runtime_call needs up to 3 constants: call target,
14947   // env for callee, C-toc.
14948   ins_num_consts(3);
14949 
14950   format %{ &quot;CALL,runtime&quot; %}
14951   ins_encode( enc_java_to_runtime_call(meth) );
14952   ins_pipe(pipe_class_call);
14953 %}
14954 
14955 // Call Leaf
14956 
14957 // Used by postalloc expand of CallLeafDirect_Ex (mtctr).
14958 instruct CallLeafDirect_mtctr(iRegLdst dst, iRegLsrc src) %{
14959   effect(DEF dst, USE src);
14960 
14961   ins_num_consts(1);
14962 
14963   format %{ &quot;MTCTR   $src&quot; %}
14964   size(4);
14965   ins_encode( enc_leaf_call_mtctr(src) );
14966   ins_pipe(pipe_class_default);
14967 %}
14968 
14969 // Used by postalloc expand of CallLeafDirect_Ex (actual call).
14970 instruct CallLeafDirect(method meth) %{
14971   match(CallLeaf);   // To get the data all the data fields we need ...
14972   effect(USE meth);
14973   predicate(false);  // but never match.
14974 
14975   format %{ &quot;BCTRL     \t// leaf call $meth ==&gt; &quot; %}
14976   size(4);
14977   ins_encode %{
14978     // TODO: PPC port $archOpcode(ppc64Opcode_bctrl);
14979     __ bctrl();
14980   %}
14981   ins_pipe(pipe_class_call);
14982 %}
14983 
14984 // postalloc expand of CallLeafDirect.
14985 // Load adress to call from TOC, then bl to it.
14986 instruct CallLeafDirect_Ex(method meth) %{
14987   match(CallLeaf);
14988   effect(USE meth);
14989   ins_cost(CALL_COST);
14990 
14991   // Postalloc_expand_java_to_runtime_call needs up to 3 constants: call target,
14992   // env for callee, C-toc.
14993   ins_num_consts(3);
14994 
14995   format %{ &quot;CALL,runtime leaf $meth \t// postalloc expanded&quot; %}
14996   postalloc_expand( postalloc_expand_java_to_runtime_call(meth, constanttablebase) );
14997 %}
14998 
14999 // Call runtime without safepoint - same as CallLeaf.
15000 // postalloc expand of CallLeafNoFPDirect.
15001 // Load adress to call from TOC, then bl to it.
15002 instruct CallLeafNoFPDirect_Ex(method meth) %{
15003   match(CallLeafNoFP);
15004   effect(USE meth);
15005   ins_cost(CALL_COST);
15006 
15007   // Enc_java_to_runtime_call needs up to 3 constants: call target,
15008   // env for callee, C-toc.
15009   ins_num_consts(3);
15010 
15011   format %{ &quot;CALL,runtime leaf nofp $meth \t// postalloc expanded&quot; %}
15012   postalloc_expand( postalloc_expand_java_to_runtime_call(meth, constanttablebase) );
15013 %}
15014 
15015 // Tail Call; Jump from runtime stub to Java code.
15016 // Also known as an &#39;interprocedural jump&#39;.
15017 // Target of jump will eventually return to caller.
15018 // TailJump below removes the return address.
15019 instruct TailCalljmpInd(iRegPdstNoScratch jump_target, inline_cache_regP method_oop) %{
15020   match(TailCall jump_target method_oop);
15021   ins_cost(CALL_COST);
15022 
15023   format %{ &quot;MTCTR   $jump_target \t// $method_oop holds method oop\n\t&quot;
15024             &quot;BCTR         \t// tail call&quot; %}
15025   size(8);
15026   ins_encode %{
15027     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
15028     __ mtctr($jump_target$$Register);
15029     __ bctr();
15030   %}
15031   ins_pipe(pipe_class_call);
15032 %}
15033 
15034 // Return Instruction
15035 instruct Ret() %{
15036   match(Return);
15037   format %{ &quot;BLR      \t// branch to link register&quot; %}
15038   size(4);
15039   ins_encode %{
15040     // TODO: PPC port $archOpcode(ppc64Opcode_blr);
15041     // LR is restored in MachEpilogNode. Just do the RET here.
15042     __ blr();
15043   %}
15044   ins_pipe(pipe_class_default);
15045 %}
15046 
15047 // Tail Jump; remove the return address; jump to target.
15048 // TailCall above leaves the return address around.
15049 // TailJump is used in only one place, the rethrow_Java stub (fancy_jump=2).
15050 // ex_oop (Exception Oop) is needed in %o0 at the jump. As there would be a
15051 // &quot;restore&quot; before this instruction (in Epilogue), we need to materialize it
15052 // in %i0.
15053 instruct tailjmpInd(iRegPdstNoScratch jump_target, rarg1RegP ex_oop) %{
15054   match(TailJump jump_target ex_oop);
15055   ins_cost(CALL_COST);
15056 
15057   format %{ &quot;LD      R4_ARG2 = LR\n\t&quot;
15058             &quot;MTCTR   $jump_target\n\t&quot;
15059             &quot;BCTR     \t// TailJump, exception oop: $ex_oop&quot; %}
15060   size(12);
15061   ins_encode %{
15062     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
15063     __ ld(R4_ARG2/* issuing pc */, _abi(lr), R1_SP);
15064     __ mtctr($jump_target$$Register);
15065     __ bctr();
15066   %}
15067   ins_pipe(pipe_class_call);
15068 %}
15069 
15070 // Create exception oop: created by stack-crawling runtime code.
15071 // Created exception is now available to this handler, and is setup
15072 // just prior to jumping to this handler. No code emitted.
15073 instruct CreateException(rarg1RegP ex_oop) %{
15074   match(Set ex_oop (CreateEx));
15075   ins_cost(0);
15076 
15077   format %{ &quot; -- \t// exception oop; no code emitted&quot; %}
15078   size(0);
15079   ins_encode( /*empty*/ );
15080   ins_pipe(pipe_class_default);
15081 %}
15082 
15083 // Rethrow exception: The exception oop will come in the first
15084 // argument position. Then JUMP (not call) to the rethrow stub code.
15085 instruct RethrowException() %{
15086   match(Rethrow);
15087   ins_cost(CALL_COST);
15088 
15089   format %{ &quot;Jmp     rethrow_stub&quot; %}
15090   ins_encode %{
15091     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
15092     cbuf.set_insts_mark();
15093     __ b64_patchable((address)OptoRuntime::rethrow_stub(), relocInfo::runtime_call_type);
15094   %}
15095   ins_pipe(pipe_class_call);
15096 %}
15097 
15098 // Die now.
15099 instruct ShouldNotReachHere() %{
15100   match(Halt);
15101   ins_cost(CALL_COST);
15102 
15103   format %{ &quot;ShouldNotReachHere&quot; %}
15104   size(4);
15105   ins_encode %{
15106     // TODO: PPC port $archOpcode(ppc64Opcode_tdi);
15107     __ trap_should_not_reach_here();
15108   %}
15109   ins_pipe(pipe_class_default);
15110 %}
15111 
15112 // This name is KNOWN by the ADLC and cannot be changed.  The ADLC
15113 // forces a &#39;TypeRawPtr::BOTTOM&#39; output type for this guy.
15114 // Get a DEF on threadRegP, no costs, no encoding, use
15115 // &#39;ins_should_rematerialize(true)&#39; to avoid spilling.
15116 instruct tlsLoadP(threadRegP dst) %{
15117   match(Set dst (ThreadLocal));
15118   ins_cost(0);
15119 
15120   ins_should_rematerialize(true);
15121 
15122   format %{ &quot; -- \t// $dst=Thread::current(), empty&quot; %}
15123   size(0);
15124   ins_encode( /*empty*/ );
15125   ins_pipe(pipe_class_empty);
15126 %}
15127 
15128 //---Some PPC specific nodes---------------------------------------------------
15129 
15130 // Stop a group.
15131 instruct endGroup() %{
15132   ins_cost(0);
15133 
15134   ins_is_nop(true);
15135 
15136   format %{ &quot;End Bundle (ori r1, r1, 0)&quot; %}
15137   size(4);
15138   ins_encode %{
15139     // TODO: PPC port $archOpcode(ppc64Opcode_endgroup);
15140     __ endgroup();
15141   %}
15142   ins_pipe(pipe_class_default);
15143 %}
15144 
15145 // Nop instructions
15146 
15147 instruct fxNop() %{
15148   ins_cost(0);
15149 
15150   ins_is_nop(true);
15151 
15152   format %{ &quot;fxNop&quot; %}
15153   size(4);
15154   ins_encode %{
15155     // TODO: PPC port $archOpcode(ppc64Opcode_fmr);
15156     __ nop();
15157   %}
15158   ins_pipe(pipe_class_default);
15159 %}
15160 
15161 instruct fpNop0() %{
15162   ins_cost(0);
15163 
15164   ins_is_nop(true);
15165 
15166   format %{ &quot;fpNop0&quot; %}
15167   size(4);
15168   ins_encode %{
15169     // TODO: PPC port $archOpcode(ppc64Opcode_fmr);
15170     __ fpnop0();
15171   %}
15172   ins_pipe(pipe_class_default);
15173 %}
15174 
15175 instruct fpNop1() %{
15176   ins_cost(0);
15177 
15178   ins_is_nop(true);
15179 
15180   format %{ &quot;fpNop1&quot; %}
15181   size(4);
15182   ins_encode %{
15183     // TODO: PPC port $archOpcode(ppc64Opcode_fmr);
15184     __ fpnop1();
15185   %}
15186   ins_pipe(pipe_class_default);
15187 %}
15188 
15189 instruct brNop0() %{
15190   ins_cost(0);
15191   size(4);
15192   format %{ &quot;brNop0&quot; %}
15193   ins_encode %{
15194     // TODO: PPC port $archOpcode(ppc64Opcode_mcrf);
15195     __ brnop0();
15196   %}
15197   ins_is_nop(true);
15198   ins_pipe(pipe_class_default);
15199 %}
15200 
15201 instruct brNop1() %{
15202   ins_cost(0);
15203 
15204   ins_is_nop(true);
15205 
15206   format %{ &quot;brNop1&quot; %}
15207   size(4);
15208   ins_encode %{
15209     // TODO: PPC port $archOpcode(ppc64Opcode_mcrf);
15210     __ brnop1();
15211   %}
15212   ins_pipe(pipe_class_default);
15213 %}
15214 
15215 instruct brNop2() %{
15216   ins_cost(0);
15217 
15218   ins_is_nop(true);
15219 
15220   format %{ &quot;brNop2&quot; %}
15221   size(4);
15222   ins_encode %{
15223     // TODO: PPC port $archOpcode(ppc64Opcode_mcrf);
15224     __ brnop2();
15225   %}
15226   ins_pipe(pipe_class_default);
15227 %}
15228 
15229 instruct cacheWB(indirect addr)
15230 %{
15231   match(CacheWB addr);
15232 
15233   ins_cost(100);
15234   format %{ &quot;cache writeback, address = $addr&quot; %}
15235   ins_encode %{
15236     assert($addr-&gt;index_position() &lt; 0, &quot;should be&quot;);
15237     assert($addr$$disp == 0, &quot;should be&quot;);
15238     __ cache_wb(Address($addr$$base$$Register));
15239   %}
15240   ins_pipe(pipe_class_default);
15241 %}
15242 
15243 instruct cacheWBPreSync()
15244 %{
15245   match(CacheWBPreSync);
15246 
15247   ins_cost(0);
15248   format %{ &quot;cache writeback presync&quot; %}
15249   ins_encode %{
15250     __ cache_wbsync(true);
15251   %}
15252   ins_pipe(pipe_class_default);
15253 %}
15254 
15255 instruct cacheWBPostSync()
15256 %{
15257   match(CacheWBPostSync);
15258 
15259   ins_cost(100);
15260   format %{ &quot;cache writeback postsync&quot; %}
15261   ins_encode %{
15262     __ cache_wbsync(false);
15263   %}
15264   ins_pipe(pipe_class_default);
15265 %}
15266 
15267 //----------PEEPHOLE RULES-----------------------------------------------------
15268 // These must follow all instruction definitions as they use the names
15269 // defined in the instructions definitions.
15270 //
15271 // peepmatch ( root_instr_name [preceeding_instruction]* );
15272 //
15273 // peepconstraint %{
15274 // (instruction_number.operand_name relational_op instruction_number.operand_name
15275 //  [, ...] );
15276 // // instruction numbers are zero-based using left to right order in peepmatch
15277 //
15278 // peepreplace ( instr_name ( [instruction_number.operand_name]* ) );
15279 // // provide an instruction_number.operand_name for each operand that appears
15280 // // in the replacement instruction&#39;s match rule
15281 //
15282 // ---------VM FLAGS---------------------------------------------------------
15283 //
15284 // All peephole optimizations can be turned off using -XX:-OptoPeephole
15285 //
15286 // Each peephole rule is given an identifying number starting with zero and
15287 // increasing by one in the order seen by the parser. An individual peephole
15288 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
15289 // on the command-line.
15290 //
15291 // ---------CURRENT LIMITATIONS----------------------------------------------
15292 //
15293 // Only match adjacent instructions in same basic block
15294 // Only equality constraints
15295 // Only constraints between operands, not (0.dest_reg == EAX_enc)
15296 // Only one replacement instruction
15297 //
15298 // ---------EXAMPLE----------------------------------------------------------
15299 //
15300 // // pertinent parts of existing instructions in architecture description
15301 // instruct movI(eRegI dst, eRegI src) %{
15302 //   match(Set dst (CopyI src));
15303 // %}
15304 //
15305 // instruct incI_eReg(eRegI dst, immI1 src, eFlagsReg cr) %{
15306 //   match(Set dst (AddI dst src));
15307 //   effect(KILL cr);
15308 // %}
15309 //
15310 // // Change (inc mov) to lea
15311 // peephole %{
15312 //   // increment preceeded by register-register move
15313 //   peepmatch ( incI_eReg movI );
15314 //   // require that the destination register of the increment
15315 //   // match the destination register of the move
15316 //   peepconstraint ( 0.dst == 1.dst );
15317 //   // construct a replacement instruction that sets
15318 //   // the destination to ( move&#39;s source register + one )
15319 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
15320 // %}
15321 //
15322 // Implementation no longer uses movX instructions since
15323 // machine-independent system no longer uses CopyX nodes.
15324 //
15325 // peephole %{
15326 //   peepmatch ( incI_eReg movI );
15327 //   peepconstraint ( 0.dst == 1.dst );
15328 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
15329 // %}
15330 //
15331 // peephole %{
15332 //   peepmatch ( decI_eReg movI );
15333 //   peepconstraint ( 0.dst == 1.dst );
15334 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
15335 // %}
15336 //
15337 // peephole %{
15338 //   peepmatch ( addI_eReg_imm movI );
15339 //   peepconstraint ( 0.dst == 1.dst );
15340 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
15341 // %}
15342 //
15343 // peephole %{
15344 //   peepmatch ( addP_eReg_imm movP );
15345 //   peepconstraint ( 0.dst == 1.dst );
15346 //   peepreplace ( leaP_eReg_immI( 0.dst 1.src 0.src ) );
15347 // %}
15348 
15349 // // Change load of spilled value to only a spill
15350 // instruct storeI(memory mem, eRegI src) %{
15351 //   match(Set mem (StoreI mem src));
15352 // %}
15353 //
15354 // instruct loadI(eRegI dst, memory mem) %{
15355 //   match(Set dst (LoadI mem));
15356 // %}
15357 //
15358 peephole %{
15359   peepmatch ( loadI storeI );
15360   peepconstraint ( 1.src == 0.dst, 1.mem == 0.mem );
15361   peepreplace ( storeI( 1.mem 1.mem 1.src ) );
15362 %}
15363 
15364 peephole %{
15365   peepmatch ( loadL storeL );
15366   peepconstraint ( 1.src == 0.dst, 1.mem == 0.mem );
15367   peepreplace ( storeL( 1.mem 1.mem 1.src ) );
15368 %}
15369 
15370 peephole %{
15371   peepmatch ( loadP storeP );
15372   peepconstraint ( 1.src == 0.dst, 1.dst == 0.mem );
15373   peepreplace ( storeP( 1.dst 1.dst 1.src ) );
15374 %}
15375 
15376 //----------SMARTSPILL RULES---------------------------------------------------
15377 // These must follow all instruction definitions as they use the names
15378 // defined in the instructions definitions.
    </pre>
  </body>
</html>
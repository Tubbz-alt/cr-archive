<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/sparc/macroAssembler_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;compiler/disassembler.hpp&quot;
  29 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  30 #include &quot;gc/shared/barrierSet.hpp&quot;
  31 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  32 #include &quot;interpreter/interpreter.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
  34 #include &quot;memory/universe.hpp&quot;
  35 #include &quot;oops/accessDecorators.hpp&quot;
  36 #include &quot;oops/compressedOops.hpp&quot;
  37 #include &quot;oops/klass.inline.hpp&quot;
  38 #include &quot;prims/methodHandles.hpp&quot;
  39 #include &quot;runtime/biasedLocking.hpp&quot;
  40 #include &quot;runtime/flags/flagSetting.hpp&quot;
  41 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  42 #include &quot;runtime/jniHandles.inline.hpp&quot;
  43 #include &quot;runtime/objectMonitor.hpp&quot;
  44 #include &quot;runtime/os.inline.hpp&quot;
  45 #include &quot;runtime/safepoint.hpp&quot;
  46 #include &quot;runtime/safepointMechanism.hpp&quot;
  47 #include &quot;runtime/sharedRuntime.hpp&quot;
  48 #include &quot;runtime/stubRoutines.hpp&quot;
  49 #include &quot;utilities/align.hpp&quot;
  50 #include &quot;utilities/macros.hpp&quot;
  51 #ifdef COMPILER2
  52 #include &quot;opto/intrinsicnode.hpp&quot;
  53 #endif
  54 
  55 #ifdef PRODUCT
  56 #define BLOCK_COMMENT(str) /* nothing */
  57 #define STOP(error) stop(error)
  58 #else
  59 #define BLOCK_COMMENT(str) block_comment(str)
  60 #define STOP(error) block_comment(error); stop(error)
  61 #endif
  62 
  63 // Convert the raw encoding form into the form expected by the
  64 // constructor for Address.
  65 Address Address::make_raw(int base, int index, int scale, int disp, relocInfo::relocType disp_reloc) {
  66   assert(scale == 0, &quot;not supported&quot;);
  67   RelocationHolder rspec;
  68   if (disp_reloc != relocInfo::none) {
  69     rspec = Relocation::spec_simple(disp_reloc);
  70   }
  71 
  72   Register rindex = as_Register(index);
  73   if (rindex != G0) {
  74     Address madr(as_Register(base), rindex);
  75     madr._rspec = rspec;
  76     return madr;
  77   } else {
  78     Address madr(as_Register(base), disp);
  79     madr._rspec = rspec;
  80     return madr;
  81   }
  82 }
  83 
  84 Address Argument::address_in_frame() const {
  85   // Warning: In LP64 mode disp will occupy more than 10 bits, but
  86   //          op codes such as ld or ldx, only access disp() to get
  87   //          their simm13 argument.
  88   int disp = ((_number - Argument::n_register_parameters + frame::memory_parameter_word_sp_offset) * BytesPerWord) + STACK_BIAS;
  89   if (is_in())
  90     return Address(FP, disp); // In argument.
  91   else
  92     return Address(SP, disp); // Out argument.
  93 }
  94 
  95 static const char* argumentNames[][2] = {
  96   {&quot;A0&quot;,&quot;P0&quot;}, {&quot;A1&quot;,&quot;P1&quot;}, {&quot;A2&quot;,&quot;P2&quot;}, {&quot;A3&quot;,&quot;P3&quot;}, {&quot;A4&quot;,&quot;P4&quot;},
  97   {&quot;A5&quot;,&quot;P5&quot;}, {&quot;A6&quot;,&quot;P6&quot;}, {&quot;A7&quot;,&quot;P7&quot;}, {&quot;A8&quot;,&quot;P8&quot;}, {&quot;A9&quot;,&quot;P9&quot;},
  98   {&quot;A(n&gt;9)&quot;,&quot;P(n&gt;9)&quot;}
  99 };
 100 
 101 const char* Argument::name() const {
 102   int nofArgs = sizeof argumentNames / sizeof argumentNames[0];
 103   int num = number();
 104   if (num &gt;= nofArgs)  num = nofArgs - 1;
 105   return argumentNames[num][is_in() ? 1 : 0];
 106 }
 107 
 108 #ifdef ASSERT
 109 // On RISC, there&#39;s no benefit to verifying instruction boundaries.
 110 bool AbstractAssembler::pd_check_instruction_mark() { return false; }
 111 #endif
 112 
 113 // Patch instruction inst at offset inst_pos to refer to dest_pos
 114 // and return the resulting instruction.
 115 // We should have pcs, not offsets, but since all is relative, it will work out
 116 // OK.
 117 int MacroAssembler::patched_branch(int dest_pos, int inst, int inst_pos) {
 118   int m; // mask for displacement field
 119   int v; // new value for displacement field
 120   const int word_aligned_ones = -4;
 121   switch (inv_op(inst)) {
 122   default: ShouldNotReachHere();
 123   case call_op:    m = wdisp(word_aligned_ones, 0, 30);  v = wdisp(dest_pos, inst_pos, 30); break;
 124   case branch_op:
 125     switch (inv_op2(inst)) {
 126       case fbp_op2:    m = wdisp(  word_aligned_ones, 0, 19);  v = wdisp(  dest_pos, inst_pos, 19); break;
 127       case bp_op2:     m = wdisp(  word_aligned_ones, 0, 19);  v = wdisp(  dest_pos, inst_pos, 19); break;
 128       case fb_op2:     m = wdisp(  word_aligned_ones, 0, 22);  v = wdisp(  dest_pos, inst_pos, 22); break;
 129       case br_op2:     m = wdisp(  word_aligned_ones, 0, 22);  v = wdisp(  dest_pos, inst_pos, 22); break;
 130       case bpr_op2: {
 131         if (is_cbcond(inst)) {
 132           m = wdisp10(word_aligned_ones, 0);
 133           v = wdisp10(dest_pos, inst_pos);
 134         } else {
 135           m = wdisp16(word_aligned_ones, 0);
 136           v = wdisp16(dest_pos, inst_pos);
 137         }
 138         break;
 139       }
 140       default: ShouldNotReachHere();
 141     }
 142   }
 143   return  inst &amp; ~m  |  v;
 144 }
 145 
 146 // Return the offset of the branch destionation of instruction inst
 147 // at offset pos.
 148 // Should have pcs, but since all is relative, it works out.
 149 int MacroAssembler::branch_destination(int inst, int pos) {
 150   int r;
 151   switch (inv_op(inst)) {
 152   default: ShouldNotReachHere();
 153   case call_op:        r = inv_wdisp(inst, pos, 30);  break;
 154   case branch_op:
 155     switch (inv_op2(inst)) {
 156       case fbp_op2:    r = inv_wdisp(  inst, pos, 19);  break;
 157       case bp_op2:     r = inv_wdisp(  inst, pos, 19);  break;
 158       case fb_op2:     r = inv_wdisp(  inst, pos, 22);  break;
 159       case br_op2:     r = inv_wdisp(  inst, pos, 22);  break;
 160       case bpr_op2: {
 161         if (is_cbcond(inst)) {
 162           r = inv_wdisp10(inst, pos);
 163         } else {
 164           r = inv_wdisp16(inst, pos);
 165         }
 166         break;
 167       }
 168       default: ShouldNotReachHere();
 169     }
 170   }
 171   return r;
 172 }
 173 
 174 void MacroAssembler::resolve_jobject(Register value, Register tmp) {
 175   Label done, not_weak;
 176   br_null(value, false, Assembler::pn, done); // Use NULL as-is.
 177   delayed()-&gt;andcc(value, JNIHandles::weak_tag_mask, G0); // Test for jweak
 178   brx(Assembler::zero, true, Assembler::pt, not_weak);
 179   delayed()-&gt;nop();
 180   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
 181                  Address(value, -JNIHandles::weak_tag_value), value, tmp);
 182   verify_oop(value);
 183   br (Assembler::always, true, Assembler::pt, done);
 184   delayed()-&gt;nop();
 185   bind(not_weak);
 186   access_load_at(T_OBJECT, IN_NATIVE, Address(value, 0), value, tmp);
 187   verify_oop(value);
 188   bind(done);
 189 }
 190 
 191 void MacroAssembler::null_check(Register reg, int offset) {
 192   if (needs_explicit_null_check((intptr_t)offset)) {
 193     // provoke OS NULL exception if reg = NULL by
 194     // accessing M[reg] w/o changing any registers
 195     ld_ptr(reg, 0, G0);
 196   }
 197   else {
 198     // nothing to do, (later) access of M[reg + offset]
 199     // will provoke OS NULL exception if reg = NULL
 200   }
 201 }
 202 
 203 // Ring buffer jumps
 204 
 205 
 206 void MacroAssembler::jmp2(Register r1, Register r2, const char* file, int line ) {
 207   assert_not_delayed();
 208   jmpl(r1, r2, G0);
 209 }
 210 void MacroAssembler::jmp(Register r1, int offset, const char* file, int line ) {
 211   assert_not_delayed();
 212   jmp(r1, offset);
 213 }
 214 
 215 // This code sequence is relocatable to any address, even on LP64.
 216 void MacroAssembler::jumpl(const AddressLiteral&amp; addrlit, Register temp, Register d, int offset, const char* file, int line) {
 217   assert_not_delayed();
 218   // Force fixed length sethi because NativeJump and NativeFarCall don&#39;t handle
 219   // variable length instruction streams.
 220   patchable_sethi(addrlit, temp);
 221   Address a(temp, addrlit.low10() + offset);  // Add the offset to the displacement.
 222   jmpl(a.base(), a.disp(), d);
 223 }
 224 
 225 void MacroAssembler::jump(const AddressLiteral&amp; addrlit, Register temp, int offset, const char* file, int line) {
 226   jumpl(addrlit, temp, G0, offset, file, line);
 227 }
 228 
 229 
 230 // Conditional breakpoint (for assertion checks in assembly code)
 231 void MacroAssembler::breakpoint_trap(Condition c, CC cc) {
 232   trap(c, cc, G0, ST_RESERVED_FOR_USER_0);
 233 }
 234 
 235 // We want to use ST_BREAKPOINT here, but the debugger is confused by it.
 236 void MacroAssembler::breakpoint_trap() {
 237   trap(ST_RESERVED_FOR_USER_0);
 238 }
 239 
 240 void MacroAssembler::safepoint_poll(Label&amp; slow_path, bool a, Register thread_reg, Register temp_reg) {
 241   if (SafepointMechanism::uses_thread_local_poll()) {
 242     ldx(Address(thread_reg, Thread::polling_page_offset()), temp_reg, 0);
 243     // Armed page has poll bit set.
 244     and3(temp_reg, SafepointMechanism::poll_bit(), temp_reg);
 245     br_notnull(temp_reg, a, Assembler::pn, slow_path);
 246   } else {
 247     AddressLiteral sync_state(SafepointSynchronize::address_of_state());
 248 
 249     load_contents(sync_state, temp_reg);
 250     cmp(temp_reg, SafepointSynchronize::_not_synchronized);
 251     br(Assembler::notEqual, a, Assembler::pn, slow_path);
 252   }
 253 }
 254 
 255 void MacroAssembler::enter() {
 256   Unimplemented();
 257 }
 258 
 259 void MacroAssembler::leave() {
 260   Unimplemented();
 261 }
 262 
 263 // Calls to C land
 264 
 265 #ifdef ASSERT
 266 // a hook for debugging
 267 static Thread* reinitialize_thread() {
 268   return Thread::current();
 269 }
 270 #else
 271 #define reinitialize_thread Thread::current
 272 #endif
 273 
 274 #ifdef ASSERT
 275 address last_get_thread = NULL;
 276 #endif
 277 
 278 // call this when G2_thread is not known to be valid
 279 void MacroAssembler::get_thread() {
 280   save_frame(0);                // to avoid clobbering O0
 281   mov(G1, L0);                  // avoid clobbering G1
 282   mov(G5_method, L1);           // avoid clobbering G5
 283   mov(G3, L2);                  // avoid clobbering G3 also
 284   mov(G4, L5);                  // avoid clobbering G4
 285 #ifdef ASSERT
 286   AddressLiteral last_get_thread_addrlit(&amp;last_get_thread);
 287   set(last_get_thread_addrlit, L3);
 288   rdpc(L4);
 289   inc(L4, 3 * BytesPerInstWord); // skip rdpc + inc + st_ptr to point L4 at call  st_ptr(L4, L3, 0);
 290 #endif
 291   call(CAST_FROM_FN_PTR(address, reinitialize_thread), relocInfo::runtime_call_type);
 292   delayed()-&gt;nop();
 293   mov(L0, G1);
 294   mov(L1, G5_method);
 295   mov(L2, G3);
 296   mov(L5, G4);
 297   restore(O0, 0, G2_thread);
 298 }
 299 
 300 static Thread* verify_thread_subroutine(Thread* gthread_value) {
 301   Thread* correct_value = Thread::current();
 302   guarantee(gthread_value == correct_value, &quot;G2_thread value must be the thread&quot;);
 303   return correct_value;
 304 }
 305 
 306 void MacroAssembler::verify_thread() {
 307   if (VerifyThread) {
 308     // NOTE: this chops off the heads of the 64-bit O registers.
 309     // make sure G2_thread contains the right value
 310     save_frame_and_mov(0, Lmethod, Lmethod);   // to avoid clobbering O0 (and propagate Lmethod)
 311     mov(G1, L1);                // avoid clobbering G1
 312     // G2 saved below
 313     mov(G3, L3);                // avoid clobbering G3
 314     mov(G4, L4);                // avoid clobbering G4
 315     mov(G5_method, L5);         // avoid clobbering G5_method
 316     call(CAST_FROM_FN_PTR(address,verify_thread_subroutine), relocInfo::runtime_call_type);
 317     delayed()-&gt;mov(G2_thread, O0);
 318 
 319     mov(L1, G1);                // Restore G1
 320     // G2 restored below
 321     mov(L3, G3);                // restore G3
 322     mov(L4, G4);                // restore G4
 323     mov(L5, G5_method);         // restore G5_method
 324     restore(O0, 0, G2_thread);
 325   }
 326 }
 327 
 328 
 329 void MacroAssembler::save_thread(const Register thread_cache) {
 330   verify_thread();
 331   if (thread_cache-&gt;is_valid()) {
 332     assert(thread_cache-&gt;is_local() || thread_cache-&gt;is_in(), &quot;bad volatile&quot;);
 333     mov(G2_thread, thread_cache);
 334   }
 335   if (VerifyThread) {
 336     // smash G2_thread, as if the VM were about to anyway
 337     set(0x67676767, G2_thread);
 338   }
 339 }
 340 
 341 
 342 void MacroAssembler::restore_thread(const Register thread_cache) {
 343   if (thread_cache-&gt;is_valid()) {
 344     assert(thread_cache-&gt;is_local() || thread_cache-&gt;is_in(), &quot;bad volatile&quot;);
 345     mov(thread_cache, G2_thread);
 346     verify_thread();
 347   } else {
 348     // do it the slow way
 349     get_thread();
 350   }
 351 }
 352 
 353 
 354 // %%% maybe get rid of [re]set_last_Java_frame
 355 void MacroAssembler::set_last_Java_frame(Register last_java_sp, Register last_Java_pc) {
 356   assert_not_delayed();
 357   Address flags(G2_thread, JavaThread::frame_anchor_offset() +
 358                            JavaFrameAnchor::flags_offset());
 359   Address pc_addr(G2_thread, JavaThread::last_Java_pc_offset());
 360 
 361   // Always set last_Java_pc and flags first because once last_Java_sp is visible
 362   // has_last_Java_frame is true and users will look at the rest of the fields.
 363   // (Note: flags should always be zero before we get here so doesn&#39;t need to be set.)
 364 
 365 #ifdef ASSERT
 366   // Verify that flags was zeroed on return to Java
 367   Label PcOk;
 368   save_frame(0);                // to avoid clobbering O0
 369   ld_ptr(pc_addr, L0);
 370   br_null_short(L0, Assembler::pt, PcOk);
 371   STOP(&quot;last_Java_pc not zeroed before leaving Java&quot;);
 372   bind(PcOk);
 373 
 374   // Verify that flags was zeroed on return to Java
 375   Label FlagsOk;
 376   ld(flags, L0);
 377   tst(L0);
 378   br(Assembler::zero, false, Assembler::pt, FlagsOk);
 379   delayed() -&gt; restore();
 380   STOP(&quot;flags not zeroed before leaving Java&quot;);
 381   bind(FlagsOk);
 382 #endif /* ASSERT */
 383   //
 384   // When returning from calling out from Java mode the frame anchor&#39;s last_Java_pc
 385   // will always be set to NULL. It is set here so that if we are doing a call to
 386   // native (not VM) that we capture the known pc and don&#39;t have to rely on the
 387   // native call having a standard frame linkage where we can find the pc.
 388 
 389   if (last_Java_pc-&gt;is_valid()) {
 390     st_ptr(last_Java_pc, pc_addr);
 391   }
 392 
 393 #ifdef ASSERT
 394   // Make sure that we have an odd stack
 395   Label StackOk;
 396   andcc(last_java_sp, 0x01, G0);
 397   br(Assembler::notZero, false, Assembler::pt, StackOk);
 398   delayed()-&gt;nop();
 399   STOP(&quot;Stack Not Biased in set_last_Java_frame&quot;);
 400   bind(StackOk);
 401 #endif // ASSERT
 402   assert( last_java_sp != G4_scratch, &quot;bad register usage in set_last_Java_frame&quot;);
 403   add( last_java_sp, STACK_BIAS, G4_scratch );
 404   st_ptr(G4_scratch, G2_thread, JavaThread::last_Java_sp_offset());
 405 }
 406 
 407 void MacroAssembler::reset_last_Java_frame(void) {
 408   assert_not_delayed();
 409 
 410   Address sp_addr(G2_thread, JavaThread::last_Java_sp_offset());
 411   Address pc_addr(G2_thread, JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_pc_offset());
 412   Address flags  (G2_thread, JavaThread::frame_anchor_offset() + JavaFrameAnchor::flags_offset());
 413 
 414 #ifdef ASSERT
 415   // check that it WAS previously set
 416     save_frame_and_mov(0, Lmethod, Lmethod);     // Propagate Lmethod to helper frame
 417     ld_ptr(sp_addr, L0);
 418     tst(L0);
 419     breakpoint_trap(Assembler::zero, Assembler::ptr_cc);
 420     restore();
 421 #endif // ASSERT
 422 
 423   st_ptr(G0, sp_addr);
 424   // Always return last_Java_pc to zero
 425   st_ptr(G0, pc_addr);
 426   // Always null flags after return to Java
 427   st(G0, flags);
 428 }
 429 
 430 
 431 void MacroAssembler::call_VM_base(
 432   Register        oop_result,
 433   Register        thread_cache,
 434   Register        last_java_sp,
 435   address         entry_point,
 436   int             number_of_arguments,
 437   bool            check_exceptions)
 438 {
 439   assert_not_delayed();
 440 
 441   // determine last_java_sp register
 442   if (!last_java_sp-&gt;is_valid()) {
 443     last_java_sp = SP;
 444   }
 445   // debugging support
 446   assert(number_of_arguments &gt;= 0   , &quot;cannot have negative number of arguments&quot;);
 447 
 448   // 64-bit last_java_sp is biased!
 449   set_last_Java_frame(last_java_sp, noreg);
 450   if (VerifyThread)  mov(G2_thread, O0); // about to be smashed; pass early
 451   save_thread(thread_cache);
 452   // do the call
 453   call(entry_point, relocInfo::runtime_call_type);
 454   if (!VerifyThread)
 455     delayed()-&gt;mov(G2_thread, O0);  // pass thread as first argument
 456   else
 457     delayed()-&gt;nop();             // (thread already passed)
 458   restore_thread(thread_cache);
 459   reset_last_Java_frame();
 460 
 461   // check for pending exceptions. use Gtemp as scratch register.
 462   if (check_exceptions) {
 463     check_and_forward_exception(Gtemp);
 464   }
 465 
 466 #ifdef ASSERT
 467   set(badHeapWordVal, G3);
 468   set(badHeapWordVal, G4);
 469   set(badHeapWordVal, G5);
 470 #endif
 471 
 472   // get oop result if there is one and reset the value in the thread
 473   if (oop_result-&gt;is_valid()) {
 474     get_vm_result(oop_result);
 475   }
 476 }
 477 
 478 void MacroAssembler::check_and_forward_exception(Register scratch_reg)
 479 {
 480   Label L;
 481 
 482   check_and_handle_popframe(scratch_reg);
 483   check_and_handle_earlyret(scratch_reg);
 484 
 485   Address exception_addr(G2_thread, Thread::pending_exception_offset());
 486   ld_ptr(exception_addr, scratch_reg);
 487   br_null_short(scratch_reg, pt, L);
 488   // we use O7 linkage so that forward_exception_entry has the issuing PC
 489   call(StubRoutines::forward_exception_entry(), relocInfo::runtime_call_type);
 490   delayed()-&gt;nop();
 491   bind(L);
 492 }
 493 
 494 
 495 void MacroAssembler::check_and_handle_popframe(Register scratch_reg) {
 496 }
 497 
 498 
 499 void MacroAssembler::check_and_handle_earlyret(Register scratch_reg) {
 500 }
 501 
 502 
 503 void MacroAssembler::call_VM(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions) {
 504   call_VM_base(oop_result, noreg, noreg, entry_point, number_of_arguments, check_exceptions);
 505 }
 506 
 507 
 508 void MacroAssembler::call_VM(Register oop_result, address entry_point, Register arg_1, bool check_exceptions) {
 509   // O0 is reserved for the thread
 510   mov(arg_1, O1);
 511   call_VM(oop_result, entry_point, 1, check_exceptions);
 512 }
 513 
 514 
 515 void MacroAssembler::call_VM(Register oop_result, address entry_point, Register arg_1, Register arg_2, bool check_exceptions) {
 516   // O0 is reserved for the thread
 517   mov(arg_1, O1);
 518   mov(arg_2, O2); assert(arg_2 != O1, &quot;smashed argument&quot;);
 519   call_VM(oop_result, entry_point, 2, check_exceptions);
 520 }
 521 
 522 
 523 void MacroAssembler::call_VM(Register oop_result, address entry_point, Register arg_1, Register arg_2, Register arg_3, bool check_exceptions) {
 524   // O0 is reserved for the thread
 525   mov(arg_1, O1);
 526   mov(arg_2, O2); assert(arg_2 != O1,                &quot;smashed argument&quot;);
 527   mov(arg_3, O3); assert(arg_3 != O1 &amp;&amp; arg_3 != O2, &quot;smashed argument&quot;);
 528   call_VM(oop_result, entry_point, 3, check_exceptions);
 529 }
 530 
 531 
 532 
 533 // Note: The following call_VM overloadings are useful when a &quot;save&quot;
 534 // has already been performed by a stub, and the last Java frame is
 535 // the previous one.  In that case, last_java_sp must be passed as FP
 536 // instead of SP.
 537 
 538 
 539 void MacroAssembler::call_VM(Register oop_result, Register last_java_sp, address entry_point, int number_of_arguments, bool check_exceptions) {
 540   call_VM_base(oop_result, noreg, last_java_sp, entry_point, number_of_arguments, check_exceptions);
 541 }
 542 
 543 
 544 void MacroAssembler::call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, bool check_exceptions) {
 545   // O0 is reserved for the thread
 546   mov(arg_1, O1);
 547   call_VM(oop_result, last_java_sp, entry_point, 1, check_exceptions);
 548 }
 549 
 550 
 551 void MacroAssembler::call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, bool check_exceptions) {
 552   // O0 is reserved for the thread
 553   mov(arg_1, O1);
 554   mov(arg_2, O2); assert(arg_2 != O1, &quot;smashed argument&quot;);
 555   call_VM(oop_result, last_java_sp, entry_point, 2, check_exceptions);
 556 }
 557 
 558 
 559 void MacroAssembler::call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, bool check_exceptions) {
 560   // O0 is reserved for the thread
 561   mov(arg_1, O1);
 562   mov(arg_2, O2); assert(arg_2 != O1,                &quot;smashed argument&quot;);
 563   mov(arg_3, O3); assert(arg_3 != O1 &amp;&amp; arg_3 != O2, &quot;smashed argument&quot;);
 564   call_VM(oop_result, last_java_sp, entry_point, 3, check_exceptions);
 565 }
 566 
 567 
 568 
 569 void MacroAssembler::call_VM_leaf_base(Register thread_cache, address entry_point, int number_of_arguments) {
 570   assert_not_delayed();
 571   save_thread(thread_cache);
 572   // do the call
 573   call(entry_point, relocInfo::runtime_call_type);
 574   delayed()-&gt;nop();
 575   restore_thread(thread_cache);
 576 #ifdef ASSERT
 577   set(badHeapWordVal, G3);
 578   set(badHeapWordVal, G4);
 579   set(badHeapWordVal, G5);
 580 #endif
 581 }
 582 
 583 
 584 void MacroAssembler::call_VM_leaf(Register thread_cache, address entry_point, int number_of_arguments) {
 585   call_VM_leaf_base(thread_cache, entry_point, number_of_arguments);
 586 }
 587 
 588 
 589 void MacroAssembler::call_VM_leaf(Register thread_cache, address entry_point, Register arg_1) {
 590   mov(arg_1, O0);
 591   call_VM_leaf(thread_cache, entry_point, 1);
 592 }
 593 
 594 
 595 void MacroAssembler::call_VM_leaf(Register thread_cache, address entry_point, Register arg_1, Register arg_2) {
 596   mov(arg_1, O0);
 597   mov(arg_2, O1); assert(arg_2 != O0, &quot;smashed argument&quot;);
 598   call_VM_leaf(thread_cache, entry_point, 2);
 599 }
 600 
 601 
 602 void MacroAssembler::call_VM_leaf(Register thread_cache, address entry_point, Register arg_1, Register arg_2, Register arg_3) {
 603   mov(arg_1, O0);
 604   mov(arg_2, O1); assert(arg_2 != O0,                &quot;smashed argument&quot;);
 605   mov(arg_3, O2); assert(arg_3 != O0 &amp;&amp; arg_3 != O1, &quot;smashed argument&quot;);
 606   call_VM_leaf(thread_cache, entry_point, 3);
 607 }
 608 
 609 
 610 void MacroAssembler::get_vm_result(Register oop_result) {
 611   verify_thread();
 612   Address vm_result_addr(G2_thread, JavaThread::vm_result_offset());
 613   ld_ptr(    vm_result_addr, oop_result);
 614   st_ptr(G0, vm_result_addr);
 615   verify_oop(oop_result);
 616 }
 617 
 618 
 619 void MacroAssembler::get_vm_result_2(Register metadata_result) {
 620   verify_thread();
 621   Address vm_result_addr_2(G2_thread, JavaThread::vm_result_2_offset());
 622   ld_ptr(vm_result_addr_2, metadata_result);
 623   st_ptr(G0, vm_result_addr_2);
 624 }
 625 
 626 
 627 // We require that C code which does not return a value in vm_result will
 628 // leave it undisturbed.
 629 void MacroAssembler::set_vm_result(Register oop_result) {
 630   verify_thread();
 631   Address vm_result_addr(G2_thread, JavaThread::vm_result_offset());
 632   verify_oop(oop_result);
 633 
 634 # ifdef ASSERT
 635     // Check that we are not overwriting any other oop.
 636     save_frame_and_mov(0, Lmethod, Lmethod);     // Propagate Lmethod
 637     ld_ptr(vm_result_addr, L0);
 638     tst(L0);
 639     restore();
 640     breakpoint_trap(notZero, Assembler::ptr_cc);
 641     // }
 642 # endif
 643 
 644   st_ptr(oop_result, vm_result_addr);
 645 }
 646 
 647 
 648 void MacroAssembler::ic_call(address entry, bool emit_delay, jint method_index) {
 649   RelocationHolder rspec = virtual_call_Relocation::spec(pc(), method_index);
 650   patchable_set((intptr_t)Universe::non_oop_word(), G5_inline_cache_reg);
 651   relocate(rspec);
 652   call(entry, relocInfo::none);
 653   if (emit_delay) {
 654     delayed()-&gt;nop();
 655   }
 656 }
 657 
 658 
 659 void MacroAssembler::internal_sethi(const AddressLiteral&amp; addrlit, Register d, bool ForceRelocatable) {
 660   address save_pc;
 661   int shiftcnt;
 662 #ifdef VALIDATE_PIPELINE
 663   assert_no_delay(&quot;Cannot put two instructions in delay-slot.&quot;);
 664 #endif
 665   v9_dep();
 666   save_pc = pc();
 667 
 668   int msb32 = (int) (addrlit.value() &gt;&gt; 32);
 669   int lsb32 = (int) (addrlit.value());
 670 
 671   if (msb32 == 0 &amp;&amp; lsb32 &gt;= 0) {
 672     Assembler::sethi(lsb32, d, addrlit.rspec());
 673   }
 674   else if (msb32 == -1) {
 675     Assembler::sethi(~lsb32, d, addrlit.rspec());
 676     xor3(d, ~low10(~0), d);
 677   }
 678   else {
 679     Assembler::sethi(msb32, d, addrlit.rspec());  // msb 22-bits
 680     if (msb32 &amp; 0x3ff)                            // Any bits?
 681       or3(d, msb32 &amp; 0x3ff, d);                   // msb 32-bits are now in lsb 32
 682     if (lsb32 &amp; 0xFFFFFC00) {                     // done?
 683       if ((lsb32 &gt;&gt; 20) &amp; 0xfff) {                // Any bits set?
 684         sllx(d, 12, d);                           // Make room for next 12 bits
 685         or3(d, (lsb32 &gt;&gt; 20) &amp; 0xfff, d);         // Or in next 12
 686         shiftcnt = 0;                             // We already shifted
 687       }
 688       else
 689         shiftcnt = 12;
 690       if ((lsb32 &gt;&gt; 10) &amp; 0x3ff) {
 691         sllx(d, shiftcnt + 10, d);                // Make room for last 10 bits
 692         or3(d, (lsb32 &gt;&gt; 10) &amp; 0x3ff, d);         // Or in next 10
 693         shiftcnt = 0;
 694       }
 695       else
 696         shiftcnt = 10;
 697       sllx(d, shiftcnt + 10, d);                  // Shift leaving disp field 0&#39;d
 698     }
 699     else
 700       sllx(d, 32, d);
 701   }
 702   // Pad out the instruction sequence so it can be patched later.
 703   if (ForceRelocatable || (addrlit.rtype() != relocInfo::none &amp;&amp;
 704                            addrlit.rtype() != relocInfo::runtime_call_type)) {
 705     while (pc() &lt; (save_pc + (7 * BytesPerInstWord)))
 706       nop();
 707   }
 708 }
 709 
 710 
 711 void MacroAssembler::sethi(const AddressLiteral&amp; addrlit, Register d) {
 712   internal_sethi(addrlit, d, false);
 713 }
 714 
 715 
 716 void MacroAssembler::patchable_sethi(const AddressLiteral&amp; addrlit, Register d) {
 717   internal_sethi(addrlit, d, true);
 718 }
 719 
 720 
 721 int MacroAssembler::insts_for_sethi(address a, bool worst_case) {
 722   if (worst_case)  return 7;
 723   intptr_t iaddr = (intptr_t) a;
 724   int msb32 = (int) (iaddr &gt;&gt; 32);
 725   int lsb32 = (int) (iaddr);
 726   int count;
 727   if (msb32 == 0 &amp;&amp; lsb32 &gt;= 0)
 728     count = 1;
 729   else if (msb32 == -1)
 730     count = 2;
 731   else {
 732     count = 2;
 733     if (msb32 &amp; 0x3ff)
 734       count++;
 735     if (lsb32 &amp; 0xFFFFFC00 ) {
 736       if ((lsb32 &gt;&gt; 20) &amp; 0xfff)  count += 2;
 737       if ((lsb32 &gt;&gt; 10) &amp; 0x3ff)  count += 2;
 738     }
 739   }
 740   return count;
 741 }
 742 
 743 int MacroAssembler::worst_case_insts_for_set() {
 744   return insts_for_sethi(NULL, true) + 1;
 745 }
 746 
 747 
 748 // Keep in sync with MacroAssembler::insts_for_internal_set
 749 void MacroAssembler::internal_set(const AddressLiteral&amp; addrlit, Register d, bool ForceRelocatable) {
 750   intptr_t value = addrlit.value();
 751 
 752   if (!ForceRelocatable &amp;&amp; addrlit.rspec().type() == relocInfo::none) {
 753     // can optimize
 754     if (-4096 &lt;= value &amp;&amp; value &lt;= 4095) {
 755       or3(G0, value, d); // setsw (this leaves upper 32 bits sign-extended)
 756       return;
 757     }
 758     if (inv_hi22(hi22(value)) == value) {
 759       sethi(addrlit, d);
 760       return;
 761     }
 762   }
 763   assert_no_delay(&quot;Cannot put two instructions in delay-slot.&quot;);
 764   internal_sethi(addrlit, d, ForceRelocatable);
 765   if (ForceRelocatable || addrlit.rspec().type() != relocInfo::none || addrlit.low10() != 0) {
 766     add(d, addrlit.low10(), d, addrlit.rspec());
 767   }
 768 }
 769 
 770 // Keep in sync with MacroAssembler::internal_set
 771 int MacroAssembler::insts_for_internal_set(intptr_t value) {
 772   // can optimize
 773   if (-4096 &lt;= value &amp;&amp; value &lt;= 4095) {
 774     return 1;
 775   }
 776   if (inv_hi22(hi22(value)) == value) {
 777     return insts_for_sethi((address) value);
 778   }
 779   int count = insts_for_sethi((address) value);
 780   AddressLiteral al(value);
 781   if (al.low10() != 0) {
 782     count++;
 783   }
 784   return count;
 785 }
 786 
 787 void MacroAssembler::set(const AddressLiteral&amp; al, Register d) {
 788   internal_set(al, d, false);
 789 }
 790 
 791 void MacroAssembler::set(intptr_t value, Register d) {
 792   AddressLiteral al(value);
 793   internal_set(al, d, false);
 794 }
 795 
 796 void MacroAssembler::set(address addr, Register d, RelocationHolder const&amp; rspec) {
 797   AddressLiteral al(addr, rspec);
 798   internal_set(al, d, false);
 799 }
 800 
 801 void MacroAssembler::patchable_set(const AddressLiteral&amp; al, Register d) {
 802   internal_set(al, d, true);
 803 }
 804 
 805 void MacroAssembler::patchable_set(intptr_t value, Register d) {
 806   AddressLiteral al(value);
 807   internal_set(al, d, true);
 808 }
 809 
 810 
 811 void MacroAssembler::set64(jlong value, Register d, Register tmp) {
 812   assert_not_delayed();
 813   v9_dep();
 814 
 815   int hi = (int)(value &gt;&gt; 32);
 816   int lo = (int)(value &amp; ~0);
 817   int bits_33to2 = (int)((value &gt;&gt; 2) &amp; ~0);
 818   // (Matcher::isSimpleConstant64 knows about the following optimizations.)
 819   if (Assembler::is_simm13(lo) &amp;&amp; value == lo) {
 820     or3(G0, lo, d);
 821   } else if (hi == 0) {
 822     Assembler::sethi(lo, d);   // hardware version zero-extends to upper 32
 823     if (low10(lo) != 0)
 824       or3(d, low10(lo), d);
 825   }
 826   else if ((hi &gt;&gt; 2) == 0) {
 827     Assembler::sethi(bits_33to2, d);  // hardware version zero-extends to upper 32
 828     sllx(d, 2, d);
 829     if (low12(lo) != 0)
 830       or3(d, low12(lo), d);
 831   }
 832   else if (hi == -1) {
 833     Assembler::sethi(~lo, d);  // hardware version zero-extends to upper 32
 834     xor3(d, low10(lo) ^ ~low10(~0), d);
 835   }
 836   else if (lo == 0) {
 837     if (Assembler::is_simm13(hi)) {
 838       or3(G0, hi, d);
 839     } else {
 840       Assembler::sethi(hi, d);   // hardware version zero-extends to upper 32
 841       if (low10(hi) != 0)
 842         or3(d, low10(hi), d);
 843     }
 844     sllx(d, 32, d);
 845   }
 846   else {
 847     Assembler::sethi(hi, tmp);
 848     Assembler::sethi(lo,   d); // macro assembler version sign-extends
 849     if (low10(hi) != 0)
 850       or3 (tmp, low10(hi), tmp);
 851     if (low10(lo) != 0)
 852       or3 (  d, low10(lo),   d);
 853     sllx(tmp, 32, tmp);
 854     or3 (d, tmp, d);
 855   }
 856 }
 857 
 858 int MacroAssembler::insts_for_set64(jlong value) {
 859   v9_dep();
 860 
 861   int hi = (int) (value &gt;&gt; 32);
 862   int lo = (int) (value &amp; ~0);
 863   int count = 0;
 864 
 865   // (Matcher::isSimpleConstant64 knows about the following optimizations.)
 866   if (Assembler::is_simm13(lo) &amp;&amp; value == lo) {
 867     count++;
 868   } else if (hi == 0) {
 869     count++;
 870     if (low10(lo) != 0)
 871       count++;
 872   }
 873   else if (hi == -1) {
 874     count += 2;
 875   }
 876   else if (lo == 0) {
 877     if (Assembler::is_simm13(hi)) {
 878       count++;
 879     } else {
 880       count++;
 881       if (low10(hi) != 0)
 882         count++;
 883     }
 884     count++;
 885   }
 886   else {
 887     count += 2;
 888     if (low10(hi) != 0)
 889       count++;
 890     if (low10(lo) != 0)
 891       count++;
 892     count += 2;
 893   }
 894   return count;
 895 }
 896 
 897 // compute size in bytes of sparc frame, given
 898 // number of extraWords
 899 int MacroAssembler::total_frame_size_in_bytes(int extraWords) {
 900 
 901   int nWords = frame::memory_parameter_word_sp_offset;
 902 
 903   nWords += extraWords;
 904 
 905   if (nWords &amp; 1) ++nWords; // round up to double-word
 906 
 907   return nWords * BytesPerWord;
 908 }
 909 
 910 
 911 // save_frame: given number of &quot;extra&quot; words in frame,
 912 // issue approp. save instruction (p 200, v8 manual)
 913 
 914 void MacroAssembler::save_frame(int extraWords) {
 915   int delta = -total_frame_size_in_bytes(extraWords);
 916   if (is_simm13(delta)) {
 917     save(SP, delta, SP);
 918   } else {
 919     set(delta, G3_scratch);
 920     save(SP, G3_scratch, SP);
 921   }
 922 }
 923 
 924 
 925 void MacroAssembler::save_frame_c1(int size_in_bytes) {
 926   if (is_simm13(-size_in_bytes)) {
 927     save(SP, -size_in_bytes, SP);
 928   } else {
 929     set(-size_in_bytes, G3_scratch);
 930     save(SP, G3_scratch, SP);
 931   }
 932 }
 933 
 934 
 935 void MacroAssembler::save_frame_and_mov(int extraWords,
 936                                         Register s1, Register d1,
 937                                         Register s2, Register d2) {
 938   assert_not_delayed();
 939 
 940   // The trick here is to use precisely the same memory word
 941   // that trap handlers also use to save the register.
 942   // This word cannot be used for any other purpose, but
 943   // it works fine to save the register&#39;s value, whether or not
 944   // an interrupt flushes register windows at any given moment!
 945   Address s1_addr;
 946   if (s1-&gt;is_valid() &amp;&amp; (s1-&gt;is_in() || s1-&gt;is_local())) {
 947     s1_addr = s1-&gt;address_in_saved_window();
 948     st_ptr(s1, s1_addr);
 949   }
 950 
 951   Address s2_addr;
 952   if (s2-&gt;is_valid() &amp;&amp; (s2-&gt;is_in() || s2-&gt;is_local())) {
 953     s2_addr = s2-&gt;address_in_saved_window();
 954     st_ptr(s2, s2_addr);
 955   }
 956 
 957   save_frame(extraWords);
 958 
 959   if (s1_addr.base() == SP) {
 960     ld_ptr(s1_addr.after_save(), d1);
 961   } else if (s1-&gt;is_valid()) {
 962     mov(s1-&gt;after_save(), d1);
 963   }
 964 
 965   if (s2_addr.base() == SP) {
 966     ld_ptr(s2_addr.after_save(), d2);
 967   } else if (s2-&gt;is_valid()) {
 968     mov(s2-&gt;after_save(), d2);
 969   }
 970 }
 971 
 972 
 973 AddressLiteral MacroAssembler::allocate_metadata_address(Metadata* obj) {
 974   assert(oop_recorder() != NULL, &quot;this assembler needs a Recorder&quot;);
 975   int index = oop_recorder()-&gt;allocate_metadata_index(obj);
 976   RelocationHolder rspec = metadata_Relocation::spec(index);
 977   return AddressLiteral((address)obj, rspec);
 978 }
 979 
 980 AddressLiteral MacroAssembler::constant_metadata_address(Metadata* obj) {
 981   assert(oop_recorder() != NULL, &quot;this assembler needs a Recorder&quot;);
 982   int index = oop_recorder()-&gt;find_index(obj);
 983   RelocationHolder rspec = metadata_Relocation::spec(index);
 984   return AddressLiteral((address)obj, rspec);
 985 }
 986 
 987 
 988 AddressLiteral MacroAssembler::constant_oop_address(jobject obj) {
 989 #ifdef ASSERT
 990   {
 991     ThreadInVMfromUnknown tiv;
 992     assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
 993     assert(Universe::heap()-&gt;is_in(JNIHandles::resolve(obj)), &quot;not an oop&quot;);
 994   }
 995 #endif
 996   int oop_index = oop_recorder()-&gt;find_index(obj);
 997   return AddressLiteral(obj, oop_Relocation::spec(oop_index));
 998 }
 999 
1000 void  MacroAssembler::set_narrow_oop(jobject obj, Register d) {
1001   assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
1002   int oop_index = oop_recorder()-&gt;find_index(obj);
1003   RelocationHolder rspec = oop_Relocation::spec(oop_index);
1004 
1005   assert_not_delayed();
1006   // Relocation with special format (see relocInfo_sparc.hpp).
1007   relocate(rspec, 1);
1008   // Assembler::sethi(0x3fffff, d);
1009   emit_int32( op(branch_op) | rd(d) | op2(sethi_op2) | hi22(0x3fffff) );
1010   // Don&#39;t add relocation for &#39;add&#39;. Do patching during &#39;sethi&#39; processing.
1011   add(d, 0x3ff, d);
1012 
1013 }
1014 
1015 void  MacroAssembler::set_narrow_klass(Klass* k, Register d) {
1016   assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
1017   int klass_index = oop_recorder()-&gt;find_index(k);
1018   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
1019   narrowOop encoded_k = CompressedKlassPointers::encode(k);
1020 
1021   assert_not_delayed();
1022   // Relocation with special format (see relocInfo_sparc.hpp).
1023   relocate(rspec, 1);
1024   // Assembler::sethi(encoded_k, d);
1025   emit_int32( op(branch_op) | rd(d) | op2(sethi_op2) | hi22(encoded_k) );
1026   // Don&#39;t add relocation for &#39;add&#39;. Do patching during &#39;sethi&#39; processing.
1027   add(d, low10(encoded_k), d);
1028 
1029 }
1030 
1031 void MacroAssembler::align(int modulus) {
1032   while (offset() % modulus != 0) nop();
1033 }
1034 
1035 void RegistersForDebugging::print(outputStream* s) {
1036   FlagSetting fs(Debugging, true);
1037   int j;
1038   for (j = 0; j &lt; 8; ++j) {
1039     if (j != 6) { s-&gt;print(&quot;i%d = &quot;, j); os::print_location(s, i[j]); }
1040     else        { s-&gt;print( &quot;fp = &quot;   ); os::print_location(s, i[j]); }
1041   }
1042   s-&gt;cr();
1043 
1044   for (j = 0;  j &lt; 8;  ++j) {
1045     s-&gt;print(&quot;l%d = &quot;, j); os::print_location(s, l[j]);
1046   }
1047   s-&gt;cr();
1048 
1049   for (j = 0; j &lt; 8; ++j) {
1050     if (j != 6) { s-&gt;print(&quot;o%d = &quot;, j); os::print_location(s, o[j]); }
1051     else        { s-&gt;print( &quot;sp = &quot;   ); os::print_location(s, o[j]); }
1052   }
1053   s-&gt;cr();
1054 
1055   for (j = 0; j &lt; 8; ++j) {
1056     s-&gt;print(&quot;g%d = &quot;, j); os::print_location(s, g[j]);
1057   }
1058   s-&gt;cr();
1059 
1060   // print out floats with compression
1061   for (j = 0; j &lt; 32; ) {
1062     jfloat val = f[j];
1063     int last = j;
1064     for ( ;  last+1 &lt; 32;  ++last ) {
1065       char b1[1024], b2[1024];
1066       sprintf(b1, &quot;%f&quot;, val);
1067       sprintf(b2, &quot;%f&quot;, f[last+1]);
1068       if (strcmp(b1, b2))
1069         break;
1070     }
1071     s-&gt;print(&quot;f%d&quot;, j);
1072     if ( j != last )  s-&gt;print(&quot; - f%d&quot;, last);
1073     s-&gt;print(&quot; = %f&quot;, val);
1074     s-&gt;fill_to(25);
1075     s-&gt;print_cr(&quot; (0x%x)&quot;, *(int*)&amp;val);
1076     j = last + 1;
1077   }
1078   s-&gt;cr();
1079 
1080   // and doubles (evens only)
1081   for (j = 0; j &lt; 32; ) {
1082     jdouble val = d[j];
1083     int last = j;
1084     for ( ;  last+1 &lt; 32;  ++last ) {
1085       char b1[1024], b2[1024];
1086       sprintf(b1, &quot;%f&quot;, val);
1087       sprintf(b2, &quot;%f&quot;, d[last+1]);
1088       if (strcmp(b1, b2))
1089         break;
1090     }
1091     s-&gt;print(&quot;d%d&quot;, 2 * j);
1092     if ( j != last )  s-&gt;print(&quot; - d%d&quot;, last);
1093     s-&gt;print(&quot; = %f&quot;, val);
1094     s-&gt;fill_to(30);
1095     s-&gt;print(&quot;(0x%x)&quot;, *(int*)&amp;val);
1096     s-&gt;fill_to(42);
1097     s-&gt;print_cr(&quot;(0x%x)&quot;, *(1 + (int*)&amp;val));
1098     j = last + 1;
1099   }
1100   s-&gt;cr();
1101 }
1102 
1103 void RegistersForDebugging::save_registers(MacroAssembler* a) {
1104   a-&gt;sub(FP, align_up(sizeof(RegistersForDebugging), sizeof(jdouble)) - STACK_BIAS, O0);
1105   a-&gt;flushw();
1106   int i;
1107   for (i = 0; i &lt; 8; ++i) {
1108     a-&gt;ld_ptr(as_iRegister(i)-&gt;address_in_saved_window().after_save(), L1);  a-&gt;st_ptr( L1, O0, i_offset(i));
1109     a-&gt;ld_ptr(as_lRegister(i)-&gt;address_in_saved_window().after_save(), L1);  a-&gt;st_ptr( L1, O0, l_offset(i));
1110     a-&gt;st_ptr(as_oRegister(i)-&gt;after_save(), O0, o_offset(i));
1111     a-&gt;st_ptr(as_gRegister(i)-&gt;after_save(), O0, g_offset(i));
1112   }
1113   for (i = 0;  i &lt; 32; ++i) {
1114     a-&gt;stf(FloatRegisterImpl::S, as_FloatRegister(i), O0, f_offset(i));
1115   }
1116   for (i = 0; i &lt; 64; i += 2) {
1117     a-&gt;stf(FloatRegisterImpl::D, as_FloatRegister(i), O0, d_offset(i));
1118   }
1119 }
1120 
1121 void RegistersForDebugging::restore_registers(MacroAssembler* a, Register r) {
1122   for (int i = 1; i &lt; 8;  ++i) {
1123     a-&gt;ld_ptr(r, g_offset(i), as_gRegister(i));
1124   }
1125   for (int j = 0; j &lt; 32; ++j) {
1126     a-&gt;ldf(FloatRegisterImpl::S, O0, f_offset(j), as_FloatRegister(j));
1127   }
1128   for (int k = 0; k &lt; 64; k += 2) {
1129     a-&gt;ldf(FloatRegisterImpl::D, O0, d_offset(k), as_FloatRegister(k));
1130   }
1131 }
1132 
1133 void MacroAssembler::_verify_oop(Register reg, const char* msg, const char * file, int line) {
1134   // plausibility check for oops
1135   if (!VerifyOops) return;
1136 
1137   if (reg == G0)  return;       // always NULL, which is always an oop
1138 
1139   BLOCK_COMMENT(&quot;verify_oop {&quot;);
1140   char buffer[64];
1141 #ifdef COMPILER1
1142   if (CommentedAssembly) {
1143     snprintf(buffer, sizeof(buffer), &quot;verify_oop at %d&quot;, offset());
1144     block_comment(buffer);
1145   }
1146 #endif
1147 
1148   const char* real_msg = NULL;
1149   {
1150     ResourceMark rm;
1151     stringStream ss;
1152     ss.print(&quot;%s at offset %d (%s:%d)&quot;, msg, offset(), file, line);
1153     real_msg = code_string(ss.as_string());
1154   }
1155 
1156   // Call indirectly to solve generation ordering problem
1157   AddressLiteral a(StubRoutines::verify_oop_subroutine_entry_address());
1158 
1159   // Make some space on stack above the current register window.
1160   // Enough to hold 8 64-bit registers.
1161   add(SP,-8*8,SP);
1162 
1163   // Save some 64-bit registers; a normal &#39;save&#39; chops the heads off
1164   // of 64-bit longs in the 32-bit build.
1165   stx(O0,SP,frame::register_save_words*wordSize+STACK_BIAS+0*8);
1166   stx(O1,SP,frame::register_save_words*wordSize+STACK_BIAS+1*8);
1167   mov(reg,O0); // Move arg into O0; arg might be in O7 which is about to be crushed
1168   stx(O7,SP,frame::register_save_words*wordSize+STACK_BIAS+7*8);
1169 
1170   // Size of set() should stay the same
1171   patchable_set((intptr_t)real_msg, O1);
1172   // Load address to call to into O7
1173   load_ptr_contents(a, O7);
1174   // Register call to verify_oop_subroutine
1175   callr(O7, G0);
1176   delayed()-&gt;nop();
1177   // recover frame size
1178   add(SP, 8*8,SP);
1179   BLOCK_COMMENT(&quot;} verify_oop&quot;);
1180 }
1181 
1182 void MacroAssembler::_verify_oop_addr(Address addr, const char* msg, const char * file, int line) {
1183   // plausibility check for oops
1184   if (!VerifyOops) return;
1185 
1186   const char* real_msg = NULL;
1187   {
1188     ResourceMark rm;
1189     stringStream ss;
1190     ss.print(&quot;%s at SP+%d (%s:%d)&quot;, msg, addr.disp(), file, line);
1191     real_msg = code_string(ss.as_string());
1192   }
1193 
1194   // Call indirectly to solve generation ordering problem
1195   AddressLiteral a(StubRoutines::verify_oop_subroutine_entry_address());
1196 
1197   // Make some space on stack above the current register window.
1198   // Enough to hold 8 64-bit registers.
1199   add(SP,-8*8,SP);
1200 
1201   // Save some 64-bit registers; a normal &#39;save&#39; chops the heads off
1202   // of 64-bit longs in the 32-bit build.
1203   stx(O0,SP,frame::register_save_words*wordSize+STACK_BIAS+0*8);
1204   stx(O1,SP,frame::register_save_words*wordSize+STACK_BIAS+1*8);
1205   ld_ptr(addr.base(), addr.disp() + 8*8, O0); // Load arg into O0; arg might be in O7 which is about to be crushed
1206   stx(O7,SP,frame::register_save_words*wordSize+STACK_BIAS+7*8);
1207 
1208   // Size of set() should stay the same
1209   patchable_set((intptr_t)real_msg, O1);
1210   // Load address to call to into O7
1211   load_ptr_contents(a, O7);
1212   // Register call to verify_oop_subroutine
1213   callr(O7, G0);
1214   delayed()-&gt;nop();
1215   // recover frame size
1216   add(SP, 8*8,SP);
1217 }
1218 
1219 // side-door communication with signalHandler in os_solaris.cpp
1220 address MacroAssembler::_verify_oop_implicit_branch[3] = { NULL };
1221 
1222 // This macro is expanded just once; it creates shared code.  Contract:
1223 // receives an oop in O0.  Must restore O0 &amp; O7 from TLS.  Must not smash ANY
1224 // registers, including flags.  May not use a register &#39;save&#39;, as this blows
1225 // the high bits of the O-regs if they contain Long values.  Acts as a &#39;leaf&#39;
1226 // call.
1227 void MacroAssembler::verify_oop_subroutine() {
1228   // Leaf call; no frame.
1229   Label succeed, fail, null_or_fail;
1230 
1231   // O0 and O7 were saved already (O0 in O0&#39;s TLS home, O7 in O5&#39;s TLS home).
1232   // O0 is now the oop to be checked.  O7 is the return address.
1233   Register O0_obj = O0;
1234 
1235   // Save some more registers for temps.
1236   stx(O2,SP,frame::register_save_words*wordSize+STACK_BIAS+2*8);
1237   stx(O3,SP,frame::register_save_words*wordSize+STACK_BIAS+3*8);
1238   stx(O4,SP,frame::register_save_words*wordSize+STACK_BIAS+4*8);
1239   stx(O5,SP,frame::register_save_words*wordSize+STACK_BIAS+5*8);
1240 
1241   // Save flags
1242   Register O5_save_flags = O5;
1243   rdccr( O5_save_flags );
1244 
1245   { // count number of verifies
1246     Register O2_adr   = O2;
1247     Register O3_accum = O3;
1248     inc_counter(StubRoutines::verify_oop_count_addr(), O2_adr, O3_accum);
1249   }
1250 
1251   Register O2_mask = O2;
1252   Register O3_bits = O3;
1253   Register O4_temp = O4;
1254 
1255   // mark lower end of faulting range
1256   assert(_verify_oop_implicit_branch[0] == NULL, &quot;set once&quot;);
1257   _verify_oop_implicit_branch[0] = pc();
1258 
1259   // We can&#39;t check the mark oop because it could be in the process of
1260   // locking or unlocking while this is running.
1261   set(Universe::verify_oop_mask (), O2_mask);
1262   set(Universe::verify_oop_bits (), O3_bits);
1263 
1264   // assert((obj &amp; oop_mask) == oop_bits);
1265   and3(O0_obj, O2_mask, O4_temp);
1266   cmp_and_brx_short(O4_temp, O3_bits, notEqual, pn, null_or_fail);
1267 
1268   if ((NULL_WORD &amp; Universe::verify_oop_mask()) == Universe::verify_oop_bits()) {
1269     // the null_or_fail case is useless; must test for null separately
1270     br_null_short(O0_obj, pn, succeed);
1271   }
1272 
1273   // Check the Klass* of this object for being in the right area of memory.
1274   // Cannot do the load in the delay above slot in case O0 is null
1275   load_klass(O0_obj, O0_obj);
1276   // assert((klass != NULL)
1277   br_null_short(O0_obj, pn, fail);
1278 
1279   wrccr( O5_save_flags ); // Restore CCR&#39;s
1280 
1281   // mark upper end of faulting range
1282   _verify_oop_implicit_branch[1] = pc();
1283 
1284   //-----------------------
1285   // all tests pass
1286   bind(succeed);
1287 
1288   // Restore prior 64-bit registers
1289   ldx(SP,frame::register_save_words*wordSize+STACK_BIAS+0*8,O0);
1290   ldx(SP,frame::register_save_words*wordSize+STACK_BIAS+1*8,O1);
1291   ldx(SP,frame::register_save_words*wordSize+STACK_BIAS+2*8,O2);
1292   ldx(SP,frame::register_save_words*wordSize+STACK_BIAS+3*8,O3);
1293   ldx(SP,frame::register_save_words*wordSize+STACK_BIAS+4*8,O4);
1294   ldx(SP,frame::register_save_words*wordSize+STACK_BIAS+5*8,O5);
1295 
1296   retl();                       // Leaf return; restore prior O7 in delay slot
1297   delayed()-&gt;ldx(SP,frame::register_save_words*wordSize+STACK_BIAS+7*8,O7);
1298 
1299   //-----------------------
1300   bind(null_or_fail);           // nulls are less common but OK
1301   br_null(O0_obj, false, pt, succeed);
1302   delayed()-&gt;wrccr( O5_save_flags ); // Restore CCR&#39;s
1303 
1304   //-----------------------
1305   // report failure:
1306   bind(fail);
1307   _verify_oop_implicit_branch[2] = pc();
1308 
1309   wrccr( O5_save_flags ); // Restore CCR&#39;s
1310 
1311   save_frame(align_up(sizeof(RegistersForDebugging) / BytesPerWord, 2));
1312 
1313   // stop_subroutine expects message pointer in I1.
1314   mov(I1, O1);
1315 
1316   // Restore prior 64-bit registers
1317   ldx(FP,frame::register_save_words*wordSize+STACK_BIAS+0*8,I0);
1318   ldx(FP,frame::register_save_words*wordSize+STACK_BIAS+1*8,I1);
1319   ldx(FP,frame::register_save_words*wordSize+STACK_BIAS+2*8,I2);
1320   ldx(FP,frame::register_save_words*wordSize+STACK_BIAS+3*8,I3);
1321   ldx(FP,frame::register_save_words*wordSize+STACK_BIAS+4*8,I4);
1322   ldx(FP,frame::register_save_words*wordSize+STACK_BIAS+5*8,I5);
1323 
1324   // factor long stop-sequence into subroutine to save space
1325   assert(StubRoutines::Sparc::stop_subroutine_entry_address(), &quot;hasn&#39;t been generated yet&quot;);
1326 
1327   // call indirectly to solve generation ordering problem
1328   AddressLiteral al(StubRoutines::Sparc::stop_subroutine_entry_address());
1329   load_ptr_contents(al, O5);
1330   jmpl(O5, 0, O7);
1331   delayed()-&gt;nop();
1332 }
1333 
1334 
1335 void MacroAssembler::stop(const char* msg) {
1336   // save frame first to get O7 for return address
1337   // add one word to size in case struct is odd number of words long
1338   // It must be doubleword-aligned for storing doubles into it.
1339 
1340     save_frame(align_up(sizeof(RegistersForDebugging) / BytesPerWord, 2));
1341 
1342     // stop_subroutine expects message pointer in I1.
1343     // Size of set() should stay the same
1344     patchable_set((intptr_t)msg, O1);
1345 
1346     // factor long stop-sequence into subroutine to save space
1347     assert(StubRoutines::Sparc::stop_subroutine_entry_address(), &quot;hasn&#39;t been generated yet&quot;);
1348 
1349     // call indirectly to solve generation ordering problem
1350     AddressLiteral a(StubRoutines::Sparc::stop_subroutine_entry_address());
1351     load_ptr_contents(a, O5);
1352     jmpl(O5, 0, O7);
1353     delayed()-&gt;nop();
1354 
1355     breakpoint_trap();   // make stop actually stop rather than writing
1356                          // unnoticeable results in the output files.
1357 
1358     // restore(); done in callee to save space!
1359 }
1360 
1361 
1362 void MacroAssembler::warn(const char* msg) {
1363   save_frame(align_up(sizeof(RegistersForDebugging) / BytesPerWord, 2));
1364   RegistersForDebugging::save_registers(this);
1365   mov(O0, L0);
1366   // Size of set() should stay the same
1367   patchable_set((intptr_t)msg, O0);
1368   call( CAST_FROM_FN_PTR(address, warning) );
1369   delayed()-&gt;nop();
1370 //  ret();
1371 //  delayed()-&gt;restore();
1372   RegistersForDebugging::restore_registers(this, L0);
1373   restore();
1374 }
1375 
1376 
1377 void MacroAssembler::untested(const char* what) {
1378   // We must be able to turn interactive prompting off
1379   // in order to run automated test scripts on the VM
1380   // Use the flag ShowMessageBoxOnError
1381 
1382   const char* b = NULL;
1383   {
1384     ResourceMark rm;
1385     stringStream ss;
1386     ss.print(&quot;untested: %s&quot;, what);
1387     b = code_string(ss.as_string());
1388   }
1389   if (ShowMessageBoxOnError) { STOP(b); }
1390   else                       { warn(b); }
1391 }
1392 
1393 
1394 void MacroAssembler::unimplemented(const char* what) {
1395   const char* buf = NULL;
1396   {
1397     ResourceMark rm;
1398     stringStream ss;
1399     ss.print(&quot;unimplemented: %s&quot;, what);
1400     buf = code_string(ss.as_string());
1401   }
1402   stop(buf);
1403 }
1404 
1405 
1406 void MacroAssembler::stop_subroutine() {
1407   RegistersForDebugging::save_registers(this);
1408 
1409   // for the sake of the debugger, stick a PC on the current frame
1410   // (this assumes that the caller has performed an extra &quot;save&quot;)
1411   mov(I7, L7);
1412   add(O7, -7 * BytesPerInt, I7);
1413 
1414   save_frame(); // one more save to free up another O7 register
1415   mov(I0, O1); // addr of reg save area
1416 
1417   // We expect pointer to message in I1. Caller must set it up in O1
1418   mov(I1, O0); // get msg
1419   call (CAST_FROM_FN_PTR(address, MacroAssembler::debug), relocInfo::runtime_call_type);
1420   delayed()-&gt;nop();
1421 
1422   restore();
1423 
1424   RegistersForDebugging::restore_registers(this, O0);
1425 
1426   save_frame(0);
1427   call(CAST_FROM_FN_PTR(address,breakpoint));
1428   delayed()-&gt;nop();
1429   restore();
1430 
1431   mov(L7, I7);
1432   retl();
1433   delayed()-&gt;restore(); // see stop above
1434 }
1435 
1436 
1437 void MacroAssembler::debug(char* msg, RegistersForDebugging* regs) {
1438   if ( ShowMessageBoxOnError ) {
1439     JavaThread* thread = JavaThread::current();
1440     JavaThreadState saved_state = thread-&gt;thread_state();
1441     thread-&gt;set_thread_state(_thread_in_vm);
1442       {
1443         // In order to get locks work, we need to fake a in_VM state
1444         ttyLocker ttyl;
1445         ::tty-&gt;print_cr(&quot;EXECUTION STOPPED: %s\n&quot;, msg);
1446         if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
1447         BytecodeCounter::print();
1448         }
1449         if (os::message_box(msg, &quot;Execution stopped, print registers?&quot;))
1450           regs-&gt;print(::tty);
1451       }
1452     BREAKPOINT;
1453       ThreadStateTransition::transition(JavaThread::current(), _thread_in_vm, saved_state);
1454   }
1455   else {
1456      ::tty-&gt;print_cr(&quot;=============== DEBUG MESSAGE: %s ================\n&quot;, msg);
1457   }
1458   assert(false, &quot;DEBUG MESSAGE: %s&quot;, msg);
1459 }
1460 
1461 
1462 void MacroAssembler::calc_mem_param_words(Register Rparam_words, Register Rresult) {
1463   subcc( Rparam_words, Argument::n_register_parameters, Rresult); // how many mem words?
1464   Label no_extras;
1465   br( negative, true, pt, no_extras ); // if neg, clear reg
1466   delayed()-&gt;set(0, Rresult);          // annuled, so only if taken
1467   bind( no_extras );
1468 }
1469 
1470 
1471 void MacroAssembler::calc_frame_size(Register Rextra_words, Register Rresult) {
1472   add(Rextra_words, frame::memory_parameter_word_sp_offset, Rresult);
1473   bclr(1, Rresult);
1474   sll(Rresult, LogBytesPerWord, Rresult);  // Rresult has total frame bytes
1475 }
1476 
1477 
1478 void MacroAssembler::calc_frame_size_and_save(Register Rextra_words, Register Rresult) {
1479   calc_frame_size(Rextra_words, Rresult);
1480   neg(Rresult);
1481   save(SP, Rresult, SP);
1482 }
1483 
1484 
1485 // ---------------------------------------------------------
1486 Assembler::RCondition cond2rcond(Assembler::Condition c) {
1487   switch (c) {
1488     /*case zero: */
1489     case Assembler::equal:        return Assembler::rc_z;
1490     case Assembler::lessEqual:    return Assembler::rc_lez;
1491     case Assembler::less:         return Assembler::rc_lz;
1492     /*case notZero:*/
1493     case Assembler::notEqual:     return Assembler::rc_nz;
1494     case Assembler::greater:      return Assembler::rc_gz;
1495     case Assembler::greaterEqual: return Assembler::rc_gez;
1496   }
1497   ShouldNotReachHere();
1498   return Assembler::rc_z;
1499 }
1500 
1501 // compares (32 bit) register with zero and branches.  NOT FOR USE WITH 64-bit POINTERS
1502 void MacroAssembler::cmp_zero_and_br(Condition c, Register s1, Label&amp; L, bool a, Predict p) {
1503   tst(s1);
1504   br (c, a, p, L);
1505 }
1506 
1507 // Compares a pointer register with zero and branches on null.
1508 // Does a test &amp; branch on 32-bit systems and a register-branch on 64-bit.
1509 void MacroAssembler::br_null( Register s1, bool a, Predict p, Label&amp; L ) {
1510   assert_not_delayed();
1511   bpr( rc_z, a, p, s1, L );
1512 }
1513 
1514 void MacroAssembler::br_notnull( Register s1, bool a, Predict p, Label&amp; L ) {
1515   assert_not_delayed();
1516   bpr( rc_nz, a, p, s1, L );
1517 }
1518 
1519 // Compare registers and branch with nop in delay slot or cbcond without delay slot.
1520 
1521 // Compare integer (32 bit) values (icc only).
1522 void MacroAssembler::cmp_and_br_short(Register s1, Register s2, Condition c,
1523                                       Predict p, Label&amp; L) {
1524   assert_not_delayed();
1525   if (use_cbcond(L)) {
1526     Assembler::cbcond(c, icc, s1, s2, L);
1527   } else {
1528     cmp(s1, s2);
1529     br(c, false, p, L);
1530     delayed()-&gt;nop();
1531   }
1532 }
1533 
1534 // Compare integer (32 bit) values (icc only).
1535 void MacroAssembler::cmp_and_br_short(Register s1, int simm13a, Condition c,
1536                                       Predict p, Label&amp; L) {
1537   assert_not_delayed();
1538   if (is_simm(simm13a,5) &amp;&amp; use_cbcond(L)) {
1539     Assembler::cbcond(c, icc, s1, simm13a, L);
1540   } else {
1541     cmp(s1, simm13a);
1542     br(c, false, p, L);
1543     delayed()-&gt;nop();
1544   }
1545 }
1546 
1547 // Branch that tests xcc in LP64 and icc in !LP64
1548 void MacroAssembler::cmp_and_brx_short(Register s1, Register s2, Condition c,
1549                                        Predict p, Label&amp; L) {
1550   assert_not_delayed();
1551   if (use_cbcond(L)) {
1552     Assembler::cbcond(c, ptr_cc, s1, s2, L);
1553   } else {
1554     cmp(s1, s2);
1555     brx(c, false, p, L);
1556     delayed()-&gt;nop();
1557   }
1558 }
1559 
1560 // Branch that tests xcc in LP64 and icc in !LP64
1561 void MacroAssembler::cmp_and_brx_short(Register s1, int simm13a, Condition c,
1562                                        Predict p, Label&amp; L) {
1563   assert_not_delayed();
1564   if (is_simm(simm13a,5) &amp;&amp; use_cbcond(L)) {
1565     Assembler::cbcond(c, ptr_cc, s1, simm13a, L);
1566   } else {
1567     cmp(s1, simm13a);
1568     brx(c, false, p, L);
1569     delayed()-&gt;nop();
1570   }
1571 }
1572 
1573 // Short branch version for compares a pointer with zero.
1574 
1575 void MacroAssembler::br_null_short(Register s1, Predict p, Label&amp; L) {
1576   assert_not_delayed();
1577   if (use_cbcond(L)) {
1578     Assembler::cbcond(zero, ptr_cc, s1, 0, L);
1579   } else {
1580     br_null(s1, false, p, L);
1581     delayed()-&gt;nop();
1582   }
1583 }
1584 
1585 void MacroAssembler::br_notnull_short(Register s1, Predict p, Label&amp; L) {
1586   assert_not_delayed();
1587   if (use_cbcond(L)) {
1588     Assembler::cbcond(notZero, ptr_cc, s1, 0, L);
1589   } else {
1590     br_notnull(s1, false, p, L);
1591     delayed()-&gt;nop();
1592   }
1593 }
1594 
1595 // Unconditional short branch
1596 void MacroAssembler::ba_short(Label&amp; L) {
1597   assert_not_delayed();
1598   if (use_cbcond(L)) {
1599     Assembler::cbcond(equal, icc, G0, G0, L);
1600   } else {
1601     br(always, false, pt, L);
1602     delayed()-&gt;nop();
1603   }
1604 }
1605 
1606 // Branch if &#39;icc&#39; says zero or not (i.e. icc.z == 1|0).
1607 
1608 void MacroAssembler::br_icc_zero(bool iszero, Predict p, Label &amp;L) {
1609   assert_not_delayed();
1610   Condition cf = (iszero ? Assembler::zero : Assembler::notZero);
1611   br(cf, false, p, L);
1612   delayed()-&gt;nop();
1613 }
1614 
1615 // instruction sequences factored across compiler &amp; interpreter
1616 
1617 
1618 void MacroAssembler::lcmp( Register Ra_hi, Register Ra_low,
1619                            Register Rb_hi, Register Rb_low,
1620                            Register Rresult) {
1621 
1622   Label check_low_parts, done;
1623 
1624   cmp(Ra_hi, Rb_hi );  // compare hi parts
1625   br(equal, true, pt, check_low_parts);
1626   delayed()-&gt;cmp(Ra_low, Rb_low); // test low parts
1627 
1628   // And, with an unsigned comparison, it does not matter if the numbers
1629   // are negative or not.
1630   // E.g., -2 cmp -1: the low parts are 0xfffffffe and 0xffffffff.
1631   // The second one is bigger (unsignedly).
1632 
1633   // Other notes:  The first move in each triplet can be unconditional
1634   // (and therefore probably prefetchable).
1635   // And the equals case for the high part does not need testing,
1636   // since that triplet is reached only after finding the high halves differ.
1637 
1638   mov(-1, Rresult);
1639   ba(done);
1640   delayed()-&gt;movcc(greater, false, icc,  1, Rresult);
1641 
1642   bind(check_low_parts);
1643 
1644   mov(                               -1, Rresult);
1645   movcc(equal,           false, icc,  0, Rresult);
1646   movcc(greaterUnsigned, false, icc,  1, Rresult);
1647 
1648   bind(done);
1649 }
1650 
1651 void MacroAssembler::lneg( Register Rhi, Register Rlow ) {
1652   subcc(  G0, Rlow, Rlow );
1653   subc(   G0, Rhi,  Rhi  );
1654 }
1655 
1656 void MacroAssembler::lshl( Register Rin_high,  Register Rin_low,
1657                            Register Rcount,
1658                            Register Rout_high, Register Rout_low,
1659                            Register Rtemp ) {
1660 
1661 
1662   Register Ralt_count = Rtemp;
1663   Register Rxfer_bits = Rtemp;
1664 
1665   assert( Ralt_count != Rin_high
1666       &amp;&amp;  Ralt_count != Rin_low
1667       &amp;&amp;  Ralt_count != Rcount
1668       &amp;&amp;  Rxfer_bits != Rin_low
1669       &amp;&amp;  Rxfer_bits != Rin_high
1670       &amp;&amp;  Rxfer_bits != Rcount
1671       &amp;&amp;  Rxfer_bits != Rout_low
1672       &amp;&amp;  Rout_low   != Rin_high,
1673         &quot;register alias checks&quot;);
1674 
1675   Label big_shift, done;
1676 
1677   // This code can be optimized to use the 64 bit shifts in V9.
1678   // Here we use the 32 bit shifts.
1679 
1680   and3( Rcount, 0x3f, Rcount);     // take least significant 6 bits
1681   subcc(Rcount,   31, Ralt_count);
1682   br(greater, true, pn, big_shift);
1683   delayed()-&gt;dec(Ralt_count);
1684 
1685   // shift &lt; 32 bits, Ralt_count = Rcount-31
1686 
1687   // We get the transfer bits by shifting right by 32-count the low
1688   // register. This is done by shifting right by 31-count and then by one
1689   // more to take care of the special (rare) case where count is zero
1690   // (shifting by 32 would not work).
1691 
1692   neg(Ralt_count);
1693 
1694   // The order of the next two instructions is critical in the case where
1695   // Rin and Rout are the same and should not be reversed.
1696 
1697   srl(Rin_low, Ralt_count, Rxfer_bits); // shift right by 31-count
1698   if (Rcount != Rout_low) {
1699     sll(Rin_low, Rcount, Rout_low); // low half
1700   }
1701   sll(Rin_high, Rcount, Rout_high);
1702   if (Rcount == Rout_low) {
1703     sll(Rin_low, Rcount, Rout_low); // low half
1704   }
1705   srl(Rxfer_bits, 1, Rxfer_bits ); // shift right by one more
1706   ba(done);
1707   delayed()-&gt;or3(Rout_high, Rxfer_bits, Rout_high);   // new hi value: or in shifted old hi part and xfer from low
1708 
1709   // shift &gt;= 32 bits, Ralt_count = Rcount-32
1710   bind(big_shift);
1711   sll(Rin_low, Ralt_count, Rout_high  );
1712   clr(Rout_low);
1713 
1714   bind(done);
1715 }
1716 
1717 
1718 void MacroAssembler::lshr( Register Rin_high,  Register Rin_low,
1719                            Register Rcount,
1720                            Register Rout_high, Register Rout_low,
1721                            Register Rtemp ) {
1722 
1723   Register Ralt_count = Rtemp;
1724   Register Rxfer_bits = Rtemp;
1725 
1726   assert( Ralt_count != Rin_high
1727       &amp;&amp;  Ralt_count != Rin_low
1728       &amp;&amp;  Ralt_count != Rcount
1729       &amp;&amp;  Rxfer_bits != Rin_low
1730       &amp;&amp;  Rxfer_bits != Rin_high
1731       &amp;&amp;  Rxfer_bits != Rcount
1732       &amp;&amp;  Rxfer_bits != Rout_high
1733       &amp;&amp;  Rout_high  != Rin_low,
1734         &quot;register alias checks&quot;);
1735 
1736   Label big_shift, done;
1737 
1738   // This code can be optimized to use the 64 bit shifts in V9.
1739   // Here we use the 32 bit shifts.
1740 
1741   and3( Rcount, 0x3f, Rcount);     // take least significant 6 bits
1742   subcc(Rcount,   31, Ralt_count);
1743   br(greater, true, pn, big_shift);
1744   delayed()-&gt;dec(Ralt_count);
1745 
1746   // shift &lt; 32 bits, Ralt_count = Rcount-31
1747 
1748   // We get the transfer bits by shifting left by 32-count the high
1749   // register. This is done by shifting left by 31-count and then by one
1750   // more to take care of the special (rare) case where count is zero
1751   // (shifting by 32 would not work).
1752 
1753   neg(Ralt_count);
1754   if (Rcount != Rout_low) {
1755     srl(Rin_low, Rcount, Rout_low);
1756   }
1757 
1758   // The order of the next two instructions is critical in the case where
1759   // Rin and Rout are the same and should not be reversed.
1760 
1761   sll(Rin_high, Ralt_count, Rxfer_bits); // shift left by 31-count
1762   sra(Rin_high,     Rcount, Rout_high ); // high half
1763   sll(Rxfer_bits,        1, Rxfer_bits); // shift left by one more
1764   if (Rcount == Rout_low) {
1765     srl(Rin_low, Rcount, Rout_low);
1766   }
1767   ba(done);
1768   delayed()-&gt;or3(Rout_low, Rxfer_bits, Rout_low); // new low value: or shifted old low part and xfer from high
1769 
1770   // shift &gt;= 32 bits, Ralt_count = Rcount-32
1771   bind(big_shift);
1772 
1773   sra(Rin_high, Ralt_count, Rout_low);
1774   sra(Rin_high,         31, Rout_high); // sign into hi
1775 
1776   bind( done );
1777 }
1778 
1779 
1780 
1781 void MacroAssembler::lushr( Register Rin_high,  Register Rin_low,
1782                             Register Rcount,
1783                             Register Rout_high, Register Rout_low,
1784                             Register Rtemp ) {
1785 
1786   Register Ralt_count = Rtemp;
1787   Register Rxfer_bits = Rtemp;
1788 
1789   assert( Ralt_count != Rin_high
1790       &amp;&amp;  Ralt_count != Rin_low
1791       &amp;&amp;  Ralt_count != Rcount
1792       &amp;&amp;  Rxfer_bits != Rin_low
1793       &amp;&amp;  Rxfer_bits != Rin_high
1794       &amp;&amp;  Rxfer_bits != Rcount
1795       &amp;&amp;  Rxfer_bits != Rout_high
1796       &amp;&amp;  Rout_high  != Rin_low,
1797         &quot;register alias checks&quot;);
1798 
1799   Label big_shift, done;
1800 
1801   // This code can be optimized to use the 64 bit shifts in V9.
1802   // Here we use the 32 bit shifts.
1803 
1804   and3( Rcount, 0x3f, Rcount);     // take least significant 6 bits
1805   subcc(Rcount,   31, Ralt_count);
1806   br(greater, true, pn, big_shift);
1807   delayed()-&gt;dec(Ralt_count);
1808 
1809   // shift &lt; 32 bits, Ralt_count = Rcount-31
1810 
1811   // We get the transfer bits by shifting left by 32-count the high
1812   // register. This is done by shifting left by 31-count and then by one
1813   // more to take care of the special (rare) case where count is zero
1814   // (shifting by 32 would not work).
1815 
1816   neg(Ralt_count);
1817   if (Rcount != Rout_low) {
1818     srl(Rin_low, Rcount, Rout_low);
1819   }
1820 
1821   // The order of the next two instructions is critical in the case where
1822   // Rin and Rout are the same and should not be reversed.
1823 
1824   sll(Rin_high, Ralt_count, Rxfer_bits); // shift left by 31-count
1825   srl(Rin_high,     Rcount, Rout_high ); // high half
1826   sll(Rxfer_bits,        1, Rxfer_bits); // shift left by one more
1827   if (Rcount == Rout_low) {
1828     srl(Rin_low, Rcount, Rout_low);
1829   }
1830   ba(done);
1831   delayed()-&gt;or3(Rout_low, Rxfer_bits, Rout_low); // new low value: or shifted old low part and xfer from high
1832 
1833   // shift &gt;= 32 bits, Ralt_count = Rcount-32
1834   bind(big_shift);
1835 
1836   srl(Rin_high, Ralt_count, Rout_low);
1837   clr(Rout_high);
1838 
1839   bind( done );
1840 }
1841 
1842 void MacroAssembler::lcmp( Register Ra, Register Rb, Register Rresult) {
1843   cmp(Ra, Rb);
1844   mov(-1, Rresult);
1845   movcc(equal,   false, xcc,  0, Rresult);
1846   movcc(greater, false, xcc,  1, Rresult);
1847 }
1848 
1849 
1850 void MacroAssembler::load_sized_value(Address src, Register dst, size_t size_in_bytes, bool is_signed) {
1851   switch (size_in_bytes) {
1852   case  8:  ld_long(src, dst); break;
1853   case  4:  ld(     src, dst); break;
1854   case  2:  is_signed ? ldsh(src, dst) : lduh(src, dst); break;
1855   case  1:  is_signed ? ldsb(src, dst) : ldub(src, dst); break;
1856   default:  ShouldNotReachHere();
1857   }
1858 }
1859 
1860 void MacroAssembler::store_sized_value(Register src, Address dst, size_t size_in_bytes) {
1861   switch (size_in_bytes) {
1862   case  8:  st_long(src, dst); break;
1863   case  4:  st(     src, dst); break;
1864   case  2:  sth(    src, dst); break;
1865   case  1:  stb(    src, dst); break;
1866   default:  ShouldNotReachHere();
1867   }
1868 }
1869 
1870 
1871 void MacroAssembler::float_cmp( bool is_float, int unordered_result,
1872                                 FloatRegister Fa, FloatRegister Fb,
1873                                 Register Rresult) {
1874   if (is_float) {
1875     fcmp(FloatRegisterImpl::S, fcc0, Fa, Fb);
1876   } else {
1877     fcmp(FloatRegisterImpl::D, fcc0, Fa, Fb);
1878   }
1879 
1880   if (unordered_result == 1) {
1881     mov(                                    -1, Rresult);
1882     movcc(f_equal,              true, fcc0,  0, Rresult);
1883     movcc(f_unorderedOrGreater, true, fcc0,  1, Rresult);
1884   } else {
1885     mov(                                    -1, Rresult);
1886     movcc(f_equal,              true, fcc0,  0, Rresult);
1887     movcc(f_greater,            true, fcc0,  1, Rresult);
1888   }
1889 }
1890 
1891 
1892 void MacroAssembler::save_all_globals_into_locals() {
1893   mov(G1,L1);
1894   mov(G2,L2);
1895   mov(G3,L3);
1896   mov(G4,L4);
1897   mov(G5,L5);
1898   mov(G6,L6);
1899   mov(G7,L7);
1900 }
1901 
1902 void MacroAssembler::restore_globals_from_locals() {
1903   mov(L1,G1);
1904   mov(L2,G2);
1905   mov(L3,G3);
1906   mov(L4,G4);
1907   mov(L5,G5);
1908   mov(L6,G6);
1909   mov(L7,G7);
1910 }
1911 
1912 RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,
1913                                                       Register tmp,
1914                                                       int offset) {
1915   intptr_t value = *delayed_value_addr;
1916   if (value != 0)
1917     return RegisterOrConstant(value + offset);
1918 
1919   // load indirectly to solve generation ordering problem
1920   AddressLiteral a(delayed_value_addr);
1921   load_ptr_contents(a, tmp);
1922 
1923 #ifdef ASSERT
1924   tst(tmp);
1925   breakpoint_trap(zero, xcc);
1926 #endif
1927 
1928   if (offset != 0)
1929     add(tmp, offset, tmp);
1930 
1931   return RegisterOrConstant(tmp);
1932 }
1933 
1934 
1935 RegisterOrConstant MacroAssembler::regcon_andn_ptr(RegisterOrConstant s1, RegisterOrConstant s2, RegisterOrConstant d, Register temp) {
1936   assert(d.register_or_noreg() != G0, &quot;lost side effect&quot;);
1937   if ((s2.is_constant() &amp;&amp; s2.as_constant() == 0) ||
1938       (s2.is_register() &amp;&amp; s2.as_register() == G0)) {
1939     // Do nothing, just move value.
1940     if (s1.is_register()) {
1941       if (d.is_constant())  d = temp;
1942       mov(s1.as_register(), d.as_register());
1943       return d;
1944     } else {
1945       return s1;
1946     }
1947   }
1948 
1949   if (s1.is_register()) {
1950     assert_different_registers(s1.as_register(), temp);
1951     if (d.is_constant())  d = temp;
1952     andn(s1.as_register(), ensure_simm13_or_reg(s2, temp), d.as_register());
1953     return d;
1954   } else {
1955     if (s2.is_register()) {
1956       assert_different_registers(s2.as_register(), temp);
1957       if (d.is_constant())  d = temp;
1958       set(s1.as_constant(), temp);
1959       andn(temp, s2.as_register(), d.as_register());
1960       return d;
1961     } else {
1962       intptr_t res = s1.as_constant() &amp; ~s2.as_constant();
1963       return res;
1964     }
1965   }
1966 }
1967 
1968 RegisterOrConstant MacroAssembler::regcon_inc_ptr(RegisterOrConstant s1, RegisterOrConstant s2, RegisterOrConstant d, Register temp) {
1969   assert(d.register_or_noreg() != G0, &quot;lost side effect&quot;);
1970   if ((s2.is_constant() &amp;&amp; s2.as_constant() == 0) ||
1971       (s2.is_register() &amp;&amp; s2.as_register() == G0)) {
1972     // Do nothing, just move value.
1973     if (s1.is_register()) {
1974       if (d.is_constant())  d = temp;
1975       mov(s1.as_register(), d.as_register());
1976       return d;
1977     } else {
1978       return s1;
1979     }
1980   }
1981 
1982   if (s1.is_register()) {
1983     assert_different_registers(s1.as_register(), temp);
1984     if (d.is_constant())  d = temp;
1985     add(s1.as_register(), ensure_simm13_or_reg(s2, temp), d.as_register());
1986     return d;
1987   } else {
1988     if (s2.is_register()) {
1989       assert_different_registers(s2.as_register(), temp);
1990       if (d.is_constant())  d = temp;
1991       add(s2.as_register(), ensure_simm13_or_reg(s1, temp), d.as_register());
1992       return d;
1993     } else {
1994       intptr_t res = s1.as_constant() + s2.as_constant();
1995       return res;
1996     }
1997   }
1998 }
1999 
2000 RegisterOrConstant MacroAssembler::regcon_sll_ptr(RegisterOrConstant s1, RegisterOrConstant s2, RegisterOrConstant d, Register temp) {
2001   assert(d.register_or_noreg() != G0, &quot;lost side effect&quot;);
2002   if (!is_simm13(s2.constant_or_zero()))
2003     s2 = (s2.as_constant() &amp; 0xFF);
2004   if ((s2.is_constant() &amp;&amp; s2.as_constant() == 0) ||
2005       (s2.is_register() &amp;&amp; s2.as_register() == G0)) {
2006     // Do nothing, just move value.
2007     if (s1.is_register()) {
2008       if (d.is_constant())  d = temp;
2009       mov(s1.as_register(), d.as_register());
2010       return d;
2011     } else {
2012       return s1;
2013     }
2014   }
2015 
2016   if (s1.is_register()) {
2017     assert_different_registers(s1.as_register(), temp);
2018     if (d.is_constant())  d = temp;
2019     sll_ptr(s1.as_register(), ensure_simm13_or_reg(s2, temp), d.as_register());
2020     return d;
2021   } else {
2022     if (s2.is_register()) {
2023       assert_different_registers(s2.as_register(), temp);
2024       if (d.is_constant())  d = temp;
2025       set(s1.as_constant(), temp);
2026       sll_ptr(temp, s2.as_register(), d.as_register());
2027       return d;
2028     } else {
2029       intptr_t res = s1.as_constant() &lt;&lt; s2.as_constant();
2030       return res;
2031     }
2032   }
2033 }
2034 
2035 
2036 // Look up the method for a megamorphic invokeinterface call.
2037 // The target method is determined by &lt;intf_klass, itable_index&gt;.
2038 // The receiver klass is in recv_klass.
2039 // On success, the result will be in method_result, and execution falls through.
2040 // On failure, execution transfers to the given label.
2041 void MacroAssembler::lookup_interface_method(Register recv_klass,
2042                                              Register intf_klass,
2043                                              RegisterOrConstant itable_index,
2044                                              Register method_result,
2045                                              Register scan_temp,
2046                                              Register sethi_temp,
2047                                              Label&amp; L_no_such_interface,
2048                                              bool return_method) {
2049   assert_different_registers(recv_klass, intf_klass, method_result, scan_temp);
2050   assert(!return_method || itable_index.is_constant() || itable_index.as_register() == method_result,
2051          &quot;caller must use same register for non-constant itable index as for method&quot;);
2052 
2053   Label L_no_such_interface_restore;
2054   bool did_save = false;
2055   if (scan_temp == noreg || sethi_temp == noreg) {
2056     Register recv_2 = recv_klass-&gt;is_global() ? recv_klass : L0;
2057     Register intf_2 = intf_klass-&gt;is_global() ? intf_klass : L1;
2058     assert(method_result-&gt;is_global(), &quot;must be able to return value&quot;);
2059     scan_temp  = L2;
2060     sethi_temp = L3;
2061     save_frame_and_mov(0, recv_klass, recv_2, intf_klass, intf_2);
2062     recv_klass = recv_2;
2063     intf_klass = intf_2;
2064     did_save = true;
2065   }
2066 
2067   // Compute start of first itableOffsetEntry (which is at the end of the vtable)
2068   int vtable_base = in_bytes(Klass::vtable_start_offset());
2069   int scan_step   = itableOffsetEntry::size() * wordSize;
2070   int vte_size    = vtableEntry::size_in_bytes();
2071 
2072   lduw(recv_klass, in_bytes(Klass::vtable_length_offset()), scan_temp);
2073   // %%% We should store the aligned, prescaled offset in the klassoop.
2074   // Then the next several instructions would fold away.
2075 
2076   int itb_offset = vtable_base;
2077   int itb_scale = exact_log2(vtableEntry::size_in_bytes());
2078   sll(scan_temp, itb_scale,  scan_temp);
2079   add(scan_temp, itb_offset, scan_temp);
2080   add(recv_klass, scan_temp, scan_temp);
2081 
2082   if (return_method) {
2083     // Adjust recv_klass by scaled itable_index, so we can free itable_index.
2084     RegisterOrConstant itable_offset = itable_index;
2085     itable_offset = regcon_sll_ptr(itable_index, exact_log2(itableMethodEntry::size() * wordSize), itable_offset);
2086     itable_offset = regcon_inc_ptr(itable_offset, itableMethodEntry::method_offset_in_bytes(), itable_offset);
2087     add(recv_klass, ensure_simm13_or_reg(itable_offset, sethi_temp), recv_klass);
2088   }
2089 
2090   // for (scan = klass-&gt;itable(); scan-&gt;interface() != NULL; scan += scan_step) {
2091   //   if (scan-&gt;interface() == intf) {
2092   //     result = (klass + scan-&gt;offset() + itable_index);
2093   //   }
2094   // }
2095   Label L_search, L_found_method;
2096 
2097   for (int peel = 1; peel &gt;= 0; peel--) {
2098     // %%%% Could load both offset and interface in one ldx, if they were
2099     // in the opposite order.  This would save a load.
2100     ld_ptr(scan_temp, itableOffsetEntry::interface_offset_in_bytes(), method_result);
2101 
2102     // Check that this entry is non-null.  A null entry means that
2103     // the receiver class doesn&#39;t implement the interface, and wasn&#39;t the
2104     // same as when the caller was compiled.
2105     bpr(Assembler::rc_z, false, Assembler::pn, method_result, did_save ? L_no_such_interface_restore : L_no_such_interface);
2106     delayed()-&gt;cmp(method_result, intf_klass);
2107 
2108     if (peel) {
2109       brx(Assembler::equal,    false, Assembler::pt, L_found_method);
2110     } else {
2111       brx(Assembler::notEqual, false, Assembler::pn, L_search);
2112       // (invert the test to fall through to found_method...)
2113     }
2114     delayed()-&gt;add(scan_temp, scan_step, scan_temp);
2115 
2116     if (!peel)  break;
2117 
2118     bind(L_search);
2119   }
2120 
2121   bind(L_found_method);
2122 
2123   if (return_method) {
2124     // Got a hit.
2125     int ito_offset = itableOffsetEntry::offset_offset_in_bytes();
2126     // scan_temp[-scan_step] points to the vtable offset we need
2127     ito_offset -= scan_step;
2128     lduw(scan_temp, ito_offset, scan_temp);
2129     ld_ptr(recv_klass, scan_temp, method_result);
2130   }
2131 
2132   if (did_save) {
2133     Label L_done;
2134     ba(L_done);
2135     delayed()-&gt;restore();
2136 
2137     bind(L_no_such_interface_restore);
2138     ba(L_no_such_interface);
2139     delayed()-&gt;restore();
2140 
2141     bind(L_done);
2142   }
2143 }
2144 
2145 
2146 // virtual method calling
2147 void MacroAssembler::lookup_virtual_method(Register recv_klass,
2148                                            RegisterOrConstant vtable_index,
2149                                            Register method_result) {
2150   assert_different_registers(recv_klass, method_result, vtable_index.register_or_noreg());
2151   Register sethi_temp = method_result;
2152   const int base = in_bytes(Klass::vtable_start_offset()) +
2153                    // method pointer offset within the vtable entry:
2154                    vtableEntry::method_offset_in_bytes();
2155   RegisterOrConstant vtable_offset = vtable_index;
2156   // Each of the following three lines potentially generates an instruction.
2157   // But the total number of address formation instructions will always be
2158   // at most two, and will often be zero.  In any case, it will be optimal.
2159   // If vtable_index is a register, we will have (sll_ptr N,x; inc_ptr B,x; ld_ptr k,x).
2160   // If vtable_index is a constant, we will have at most (set B+X&lt;&lt;N,t; ld_ptr k,t).
2161   vtable_offset = regcon_sll_ptr(vtable_index, exact_log2(vtableEntry::size_in_bytes()), vtable_offset);
2162   vtable_offset = regcon_inc_ptr(vtable_offset, base, vtable_offset, sethi_temp);
2163   Address vtable_entry_addr(recv_klass, ensure_simm13_or_reg(vtable_offset, sethi_temp));
2164   ld_ptr(vtable_entry_addr, method_result);
2165 }
2166 
2167 
2168 void MacroAssembler::check_klass_subtype(Register sub_klass,
2169                                          Register super_klass,
2170                                          Register temp_reg,
2171                                          Register temp2_reg,
2172                                          Label&amp; L_success) {
2173   Register sub_2 = sub_klass;
2174   Register sup_2 = super_klass;
2175   if (!sub_2-&gt;is_global())  sub_2 = L0;
2176   if (!sup_2-&gt;is_global())  sup_2 = L1;
2177   bool did_save = false;
2178   if (temp_reg == noreg || temp2_reg == noreg) {
2179     temp_reg = L2;
2180     temp2_reg = L3;
2181     save_frame_and_mov(0, sub_klass, sub_2, super_klass, sup_2);
2182     sub_klass = sub_2;
2183     super_klass = sup_2;
2184     did_save = true;
2185   }
2186   Label L_failure, L_pop_to_failure, L_pop_to_success;
2187   check_klass_subtype_fast_path(sub_klass, super_klass,
2188                                 temp_reg, temp2_reg,
2189                                 (did_save ? &amp;L_pop_to_success : &amp;L_success),
2190                                 (did_save ? &amp;L_pop_to_failure : &amp;L_failure), NULL);
2191 
2192   if (!did_save)
2193     save_frame_and_mov(0, sub_klass, sub_2, super_klass, sup_2);
2194   check_klass_subtype_slow_path(sub_2, sup_2,
2195                                 L2, L3, L4, L5,
2196                                 NULL, &amp;L_pop_to_failure);
2197 
2198   // on success:
2199   bind(L_pop_to_success);
2200   restore();
2201   ba_short(L_success);
2202 
2203   // on failure:
2204   bind(L_pop_to_failure);
2205   restore();
2206   bind(L_failure);
2207 }
2208 
2209 
2210 void MacroAssembler::check_klass_subtype_fast_path(Register sub_klass,
2211                                                    Register super_klass,
2212                                                    Register temp_reg,
2213                                                    Register temp2_reg,
2214                                                    Label* L_success,
2215                                                    Label* L_failure,
2216                                                    Label* L_slow_path,
2217                                         RegisterOrConstant super_check_offset) {
2218   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
2219   int sco_offset = in_bytes(Klass::super_check_offset_offset());
2220 
2221   bool must_load_sco  = (super_check_offset.constant_or_zero() == -1);
2222   bool need_slow_path = (must_load_sco ||
2223                          super_check_offset.constant_or_zero() == sco_offset);
2224 
2225   assert_different_registers(sub_klass, super_klass, temp_reg);
2226   if (super_check_offset.is_register()) {
2227     assert_different_registers(sub_klass, super_klass, temp_reg,
2228                                super_check_offset.as_register());
2229   } else if (must_load_sco) {
2230     assert(temp2_reg != noreg, &quot;supply either a temp or a register offset&quot;);
2231   }
2232 
2233   Label L_fallthrough;
2234   int label_nulls = 0;
2235   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
2236   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
2237   if (L_slow_path == NULL) { L_slow_path = &amp;L_fallthrough; label_nulls++; }
2238   assert(label_nulls &lt;= 1 ||
2239          (L_slow_path == &amp;L_fallthrough &amp;&amp; label_nulls &lt;= 2 &amp;&amp; !need_slow_path),
2240          &quot;at most one NULL in the batch, usually&quot;);
2241 
2242   // If the pointers are equal, we are done (e.g., String[] elements).
2243   // This self-check enables sharing of secondary supertype arrays among
2244   // non-primary types such as array-of-interface.  Otherwise, each such
2245   // type would need its own customized SSA.
2246   // We move this check to the front of the fast path because many
2247   // type checks are in fact trivially successful in this manner,
2248   // so we get a nicely predicted branch right at the start of the check.
2249   cmp(super_klass, sub_klass);
2250   brx(Assembler::equal, false, Assembler::pn, *L_success);
2251   delayed()-&gt;nop();
2252 
2253   // Check the supertype display:
2254   if (must_load_sco) {
2255     // The super check offset is always positive...
2256     lduw(super_klass, sco_offset, temp2_reg);
2257     super_check_offset = RegisterOrConstant(temp2_reg);
2258     // super_check_offset is register.
2259     assert_different_registers(sub_klass, super_klass, temp_reg, super_check_offset.as_register());
2260   }
2261   ld_ptr(sub_klass, super_check_offset, temp_reg);
2262   cmp(super_klass, temp_reg);
2263 
2264   // This check has worked decisively for primary supers.
2265   // Secondary supers are sought in the super_cache (&#39;super_cache_addr&#39;).
2266   // (Secondary supers are interfaces and very deeply nested subtypes.)
2267   // This works in the same check above because of a tricky aliasing
2268   // between the super_cache and the primary super display elements.
2269   // (The &#39;super_check_addr&#39; can address either, as the case requires.)
2270   // Note that the cache is updated below if it does not help us find
2271   // what we need immediately.
2272   // So if it was a primary super, we can just fail immediately.
2273   // Otherwise, it&#39;s the slow path for us (no success at this point).
2274 
2275   // Hacked ba(), which may only be used just before L_fallthrough.
2276 #define FINAL_JUMP(label)            \
2277   if (&amp;(label) != &amp;L_fallthrough) {  \
2278     ba(label);  delayed()-&gt;nop();    \
2279   }
2280 
2281   if (super_check_offset.is_register()) {
2282     brx(Assembler::equal, false, Assembler::pn, *L_success);
2283     delayed()-&gt;cmp(super_check_offset.as_register(), sc_offset);
2284 
2285     if (L_failure == &amp;L_fallthrough) {
2286       brx(Assembler::equal, false, Assembler::pt, *L_slow_path);
2287       delayed()-&gt;nop();
2288     } else {
2289       brx(Assembler::notEqual, false, Assembler::pn, *L_failure);
2290       delayed()-&gt;nop();
2291       FINAL_JUMP(*L_slow_path);
2292     }
2293   } else if (super_check_offset.as_constant() == sc_offset) {
2294     // Need a slow path; fast failure is impossible.
2295     if (L_slow_path == &amp;L_fallthrough) {
2296       brx(Assembler::equal, false, Assembler::pt, *L_success);
2297       delayed()-&gt;nop();
2298     } else {
2299       brx(Assembler::notEqual, false, Assembler::pn, *L_slow_path);
2300       delayed()-&gt;nop();
2301       FINAL_JUMP(*L_success);
2302     }
2303   } else {
2304     // No slow path; it&#39;s a fast decision.
2305     if (L_failure == &amp;L_fallthrough) {
2306       brx(Assembler::equal, false, Assembler::pt, *L_success);
2307       delayed()-&gt;nop();
2308     } else {
2309       brx(Assembler::notEqual, false, Assembler::pn, *L_failure);
2310       delayed()-&gt;nop();
2311       FINAL_JUMP(*L_success);
2312     }
2313   }
2314 
2315   bind(L_fallthrough);
2316 
2317 #undef FINAL_JUMP
2318 }
2319 
2320 
2321 void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,
2322                                                    Register super_klass,
2323                                                    Register count_temp,
2324                                                    Register scan_temp,
2325                                                    Register scratch_reg,
2326                                                    Register coop_reg,
2327                                                    Label* L_success,
2328                                                    Label* L_failure) {
2329   assert_different_registers(sub_klass, super_klass,
2330                              count_temp, scan_temp, scratch_reg, coop_reg);
2331 
2332   Label L_fallthrough, L_loop;
2333   int label_nulls = 0;
2334   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
2335   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
2336   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
2337 
2338   // a couple of useful fields in sub_klass:
2339   int ss_offset = in_bytes(Klass::secondary_supers_offset());
2340   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
2341 
2342   // Do a linear scan of the secondary super-klass chain.
2343   // This code is rarely used, so simplicity is a virtue here.
2344 
2345 #ifndef PRODUCT
2346   int* pst_counter = &amp;SharedRuntime::_partial_subtype_ctr;
2347   inc_counter((address) pst_counter, count_temp, scan_temp);
2348 #endif
2349 
2350   // We will consult the secondary-super array.
2351   ld_ptr(sub_klass, ss_offset, scan_temp);
2352 
2353   Register search_key = super_klass;
2354 
2355   // Load the array length.  (Positive movl does right thing on LP64.)
2356   lduw(scan_temp, Array&lt;Klass*&gt;::length_offset_in_bytes(), count_temp);
2357 
2358   // Check for empty secondary super list
2359   tst(count_temp);
2360 
2361   // In the array of super classes elements are pointer sized.
2362   int element_size = wordSize;
2363 
2364   // Top of search loop
2365   bind(L_loop);
2366   br(Assembler::equal, false, Assembler::pn, *L_failure);
2367   delayed()-&gt;add(scan_temp, element_size, scan_temp);
2368 
2369   // Skip the array header in all array accesses.
2370   int elem_offset = Array&lt;Klass*&gt;::base_offset_in_bytes();
2371   elem_offset -= element_size;   // the scan pointer was pre-incremented also
2372 
2373   // Load next super to check
2374     ld_ptr( scan_temp, elem_offset, scratch_reg );
2375 
2376   // Look for Rsuper_klass on Rsub_klass&#39;s secondary super-class-overflow list
2377   cmp(scratch_reg, search_key);
2378 
2379   // A miss means we are NOT a subtype and need to keep looping
2380   brx(Assembler::notEqual, false, Assembler::pn, L_loop);
2381   delayed()-&gt;deccc(count_temp); // decrement trip counter in delay slot
2382 
2383   // Success.  Cache the super we found and proceed in triumph.
2384   st_ptr(super_klass, sub_klass, sc_offset);
2385 
2386   if (L_success != &amp;L_fallthrough) {
2387     ba(*L_success);
2388     delayed()-&gt;nop();
2389   }
2390 
2391   bind(L_fallthrough);
2392 }
2393 
2394 
2395 RegisterOrConstant MacroAssembler::argument_offset(RegisterOrConstant arg_slot,
2396                                                    Register temp_reg,
2397                                                    int extra_slot_offset) {
2398   // cf. TemplateTable::prepare_invoke(), if (load_receiver).
2399   int stackElementSize = Interpreter::stackElementSize;
2400   int offset = extra_slot_offset * stackElementSize;
2401   if (arg_slot.is_constant()) {
2402     offset += arg_slot.as_constant() * stackElementSize;
2403     return offset;
2404   } else {
2405     assert(temp_reg != noreg, &quot;must specify&quot;);
2406     sll_ptr(arg_slot.as_register(), exact_log2(stackElementSize), temp_reg);
2407     if (offset != 0)
2408       add(temp_reg, offset, temp_reg);
2409     return temp_reg;
2410   }
2411 }
2412 
2413 
2414 Address MacroAssembler::argument_address(RegisterOrConstant arg_slot,
2415                                          Register temp_reg,
2416                                          int extra_slot_offset) {
2417   return Address(Gargs, argument_offset(arg_slot, temp_reg, extra_slot_offset));
2418 }
2419 
2420 
2421 void MacroAssembler::biased_locking_enter(Register obj_reg, Register mark_reg,
2422                                           Register temp_reg,
2423                                           Label&amp; done, Label* slow_case,
2424                                           BiasedLockingCounters* counters) {
2425   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
2426 
2427   if (PrintBiasedLockingStatistics) {
2428     assert_different_registers(obj_reg, mark_reg, temp_reg, O7);
2429     if (counters == NULL)
2430       counters = BiasedLocking::counters();
2431   }
2432 
2433   Label cas_label;
2434 
2435   // Biased locking
2436   // See whether the lock is currently biased toward our thread and
2437   // whether the epoch is still valid
2438   // Note that the runtime guarantees sufficient alignment of JavaThread
2439   // pointers to allow age to be placed into low bits
2440   assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, &quot;biased locking makes assumptions about bit layout&quot;);
2441   and3(mark_reg, markWord::biased_lock_mask_in_place, temp_reg);
2442   cmp_and_brx_short(temp_reg, markWord::biased_lock_pattern, Assembler::notEqual, Assembler::pn, cas_label);
2443 
2444   load_klass(obj_reg, temp_reg);
2445   ld_ptr(Address(temp_reg, Klass::prototype_header_offset()), temp_reg);
2446   or3(G2_thread, temp_reg, temp_reg);
2447   xor3(mark_reg, temp_reg, temp_reg);
2448   andcc(temp_reg, ~((int) markWord::age_mask_in_place), temp_reg);
2449   if (counters != NULL) {
2450     cond_inc(Assembler::equal, (address) counters-&gt;biased_lock_entry_count_addr(), mark_reg, temp_reg);
2451     // Reload mark_reg as we may need it later
2452     ld_ptr(Address(obj_reg, oopDesc::mark_offset_in_bytes()), mark_reg);
2453   }
2454   brx(Assembler::equal, true, Assembler::pt, done);
2455   delayed()-&gt;nop();
2456 
2457   Label try_revoke_bias;
2458   Label try_rebias;
2459   Address mark_addr = Address(obj_reg, oopDesc::mark_offset_in_bytes());
2460   assert(mark_addr.disp() == 0, &quot;cas must take a zero displacement&quot;);
2461 
2462   // At this point we know that the header has the bias pattern and
2463   // that we are not the bias owner in the current epoch. We need to
2464   // figure out more details about the state of the header in order to
2465   // know what operations can be legally performed on the object&#39;s
2466   // header.
2467 
2468   // If the low three bits in the xor result aren&#39;t clear, that means
2469   // the prototype header is no longer biased and we have to revoke
2470   // the bias on this object.
2471   btst(markWord::biased_lock_mask_in_place, temp_reg);
2472   brx(Assembler::notZero, false, Assembler::pn, try_revoke_bias);
2473 
2474   // Biasing is still enabled for this data type. See whether the
2475   // epoch of the current bias is still valid, meaning that the epoch
2476   // bits of the mark word are equal to the epoch bits of the
2477   // prototype header. (Note that the prototype header&#39;s epoch bits
2478   // only change at a safepoint.) If not, attempt to rebias the object
2479   // toward the current thread. Note that we must be absolutely sure
2480   // that the current epoch is invalid in order to do this because
2481   // otherwise the manipulations it performs on the mark word are
2482   // illegal.
2483   delayed()-&gt;btst(markWord::epoch_mask_in_place, temp_reg);
2484   brx(Assembler::notZero, false, Assembler::pn, try_rebias);
2485 
2486   // The epoch of the current bias is still valid but we know nothing
2487   // about the owner; it might be set or it might be clear. Try to
2488   // acquire the bias of the object using an atomic operation. If this
2489   // fails we will go in to the runtime to revoke the object&#39;s bias.
2490   // Note that we first construct the presumed unbiased header so we
2491   // don&#39;t accidentally blow away another thread&#39;s valid bias.
2492   delayed()-&gt;and3(mark_reg,
2493                   markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place,
2494                   mark_reg);
2495   or3(G2_thread, mark_reg, temp_reg);
2496   cas_ptr(mark_addr.base(), mark_reg, temp_reg);
2497   // If the biasing toward our thread failed, this means that
2498   // another thread succeeded in biasing it toward itself and we
2499   // need to revoke that bias. The revocation will occur in the
2500   // interpreter runtime in the slow case.
2501   cmp(mark_reg, temp_reg);
2502   if (counters != NULL) {
2503     cond_inc(Assembler::zero, (address) counters-&gt;anonymously_biased_lock_entry_count_addr(), mark_reg, temp_reg);
2504   }
2505   if (slow_case != NULL) {
2506     brx(Assembler::notEqual, true, Assembler::pn, *slow_case);
2507     delayed()-&gt;nop();
2508   }
2509   ba_short(done);
2510 
2511   bind(try_rebias);
2512   // At this point we know the epoch has expired, meaning that the
2513   // current &quot;bias owner&quot;, if any, is actually invalid. Under these
2514   // circumstances _only_, we are allowed to use the current header&#39;s
2515   // value as the comparison value when doing the cas to acquire the
2516   // bias in the current epoch. In other words, we allow transfer of
2517   // the bias from one thread to another directly in this situation.
2518   //
2519   // FIXME: due to a lack of registers we currently blow away the age
2520   // bits in this situation. Should attempt to preserve them.
2521   load_klass(obj_reg, temp_reg);
2522   ld_ptr(Address(temp_reg, Klass::prototype_header_offset()), temp_reg);
2523   or3(G2_thread, temp_reg, temp_reg);
2524   cas_ptr(mark_addr.base(), mark_reg, temp_reg);
2525   // If the biasing toward our thread failed, this means that
2526   // another thread succeeded in biasing it toward itself and we
2527   // need to revoke that bias. The revocation will occur in the
2528   // interpreter runtime in the slow case.
2529   cmp(mark_reg, temp_reg);
2530   if (counters != NULL) {
2531     cond_inc(Assembler::zero, (address) counters-&gt;rebiased_lock_entry_count_addr(), mark_reg, temp_reg);
2532   }
2533   if (slow_case != NULL) {
2534     brx(Assembler::notEqual, true, Assembler::pn, *slow_case);
2535     delayed()-&gt;nop();
2536   }
2537   ba_short(done);
2538 
2539   bind(try_revoke_bias);
2540   // The prototype mark in the klass doesn&#39;t have the bias bit set any
2541   // more, indicating that objects of this data type are not supposed
2542   // to be biased any more. We are going to try to reset the mark of
2543   // this object to the prototype value and fall through to the
2544   // CAS-based locking scheme. Note that if our CAS fails, it means
2545   // that another thread raced us for the privilege of revoking the
2546   // bias of this particular object, so it&#39;s okay to continue in the
2547   // normal locking code.
2548   //
2549   // FIXME: due to a lack of registers we currently blow away the age
2550   // bits in this situation. Should attempt to preserve them.
2551   load_klass(obj_reg, temp_reg);
2552   ld_ptr(Address(temp_reg, Klass::prototype_header_offset()), temp_reg);
2553   cas_ptr(mark_addr.base(), mark_reg, temp_reg);
2554   // Fall through to the normal CAS-based lock, because no matter what
2555   // the result of the above CAS, some thread must have succeeded in
2556   // removing the bias bit from the object&#39;s header.
2557   if (counters != NULL) {
2558     cmp(mark_reg, temp_reg);
2559     cond_inc(Assembler::zero, (address) counters-&gt;revoked_lock_entry_count_addr(), mark_reg, temp_reg);
2560   }
2561 
2562   bind(cas_label);
2563 }
2564 
2565 void MacroAssembler::biased_locking_exit (Address mark_addr, Register temp_reg, Label&amp; done,
2566                                           bool allow_delay_slot_filling) {
2567   // Check for biased locking unlock case, which is a no-op
2568   // Note: we do not have to check the thread ID for two reasons.
2569   // First, the interpreter checks for IllegalMonitorStateException at
2570   // a higher level. Second, if the bias was revoked while we held the
2571   // lock, the object could not be rebiased toward another thread, so
2572   // the bias bit would be clear.
2573   ld_ptr(mark_addr, temp_reg);
2574   and3(temp_reg, markWord::biased_lock_mask_in_place, temp_reg);
2575   cmp(temp_reg, markWord::biased_lock_pattern);
2576   brx(Assembler::equal, allow_delay_slot_filling, Assembler::pt, done);
2577   delayed();
2578   if (!allow_delay_slot_filling) {
2579     nop();
2580   }
2581 }
2582 
2583 
2584 // compiler_lock_object() and compiler_unlock_object() are direct transliterations
2585 // of i486.ad fast_lock() and fast_unlock().  See those methods for detailed comments.
2586 // The code could be tightened up considerably.
2587 //
2588 // box-&gt;dhw disposition - post-conditions at DONE_LABEL.
2589 // -   Successful inflated lock:  box-&gt;dhw != 0.
2590 //     Any non-zero value suffices.
2591 //     Consider G2_thread, rsp, boxReg, or markWord::unused_mark()
2592 // -   Successful Stack-lock: box-&gt;dhw == mark.
2593 //     box-&gt;dhw must contain the displaced mark word value
2594 // -   Failure -- icc.ZFlag == 0 and box-&gt;dhw is undefined.
2595 //     The slow-path enter() is responsible for setting
2596 //     box-&gt;dhw = NonZero (typically markWord::unused_mark()).
2597 // -   Biased: box-&gt;dhw is undefined
2598 //
2599 // SPARC refworkload performance - specifically jetstream and scimark - are
2600 // extremely sensitive to the size of the code emitted by compiler_lock_object
2601 // and compiler_unlock_object.  Critically, the key factor is code size, not path
2602 // length.  (Simply experiments to pad CLO with unexecuted NOPs demonstrte the
2603 // effect).
2604 
2605 
2606 void MacroAssembler::compiler_lock_object(Register Roop, Register Rmark,
2607                                           Register Rbox, Register Rscratch,
2608                                           BiasedLockingCounters* counters,
2609                                           bool try_bias) {
2610    Address mark_addr(Roop, oopDesc::mark_offset_in_bytes());
2611 
2612    verify_oop(Roop);
2613    Label done ;
2614 
2615    if (counters != NULL) {
2616      inc_counter((address) counters-&gt;total_entry_count_addr(), Rmark, Rscratch);
2617    }
2618 
2619    // Aggressively avoid the Store-before-CAS penalty
2620    // Defer the store into box-&gt;dhw until after the CAS
2621    Label IsInflated, Recursive ;
2622 
2623 // Anticipate CAS -- Avoid RTS-&gt;RTO upgrade
2624 // prefetch (mark_addr, Assembler::severalWritesAndPossiblyReads);
2625 
2626    ld_ptr(mark_addr, Rmark);           // fetch obj-&gt;mark
2627    // Triage: biased, stack-locked, neutral, inflated
2628 
2629    if (try_bias) {
2630      biased_locking_enter(Roop, Rmark, Rscratch, done, NULL, counters);
2631      // Invariant: if control reaches this point in the emitted stream
2632      // then Rmark has not been modified.
2633    }
2634    andcc(Rmark, 2, G0);
2635    brx(Assembler::notZero, false, Assembler::pn, IsInflated);
2636    delayed()-&gt;                         // Beware - dangling delay-slot
2637 
2638    // Try stack-lock acquisition.
2639    // Transiently install BUSY (0) encoding in the mark word.
2640    // if the CAS of 0 into the mark was successful then we execute:
2641    //   ST box-&gt;dhw  = mark   -- save fetched mark in on-stack basiclock box
2642    //   ST obj-&gt;mark = box    -- overwrite transient 0 value
2643    // This presumes TSO, of course.
2644 
2645    mov(0, Rscratch);
2646    or3(Rmark, markWord::unlocked_value, Rmark);
2647    assert(mark_addr.disp() == 0, &quot;cas must take a zero displacement&quot;);
2648    cas_ptr(mark_addr.base(), Rmark, Rscratch);
2649 // prefetch (mark_addr, Assembler::severalWritesAndPossiblyReads);
2650    cmp(Rscratch, Rmark);
2651    brx(Assembler::notZero, false, Assembler::pn, Recursive);
2652    delayed()-&gt;st_ptr(Rmark, Rbox, BasicLock::displaced_header_offset_in_bytes());
2653    if (counters != NULL) {
2654      cond_inc(Assembler::equal, (address) counters-&gt;fast_path_entry_count_addr(), Rmark, Rscratch);
2655    }
2656    ba(done);
2657    delayed()-&gt;st_ptr(Rbox, mark_addr);
2658 
2659    bind(Recursive);
2660    // Stack-lock attempt failed - check for recursive stack-lock.
2661    // Tests show that we can remove the recursive case with no impact
2662    // on refworkload 0.83.  If we need to reduce the size of the code
2663    // emitted by compiler_lock_object() the recursive case is perfect
2664    // candidate.
2665    //
2666    // A more extreme idea is to always inflate on stack-lock recursion.
2667    // This lets us eliminate the recursive checks in compiler_lock_object
2668    // and compiler_unlock_object and the (box-&gt;dhw == 0) encoding.
2669    // A brief experiment - requiring changes to synchronizer.cpp, interpreter,
2670    // and showed a performance *increase*.  In the same experiment I eliminated
2671    // the fast-path stack-lock code from the interpreter and always passed
2672    // control to the &quot;slow&quot; operators in synchronizer.cpp.
2673 
2674    // RScratch contains the fetched obj-&gt;mark value from the failed CAS.
2675    sub(Rscratch, STACK_BIAS, Rscratch);
2676    sub(Rscratch, SP, Rscratch);
2677    assert(os::vm_page_size() &gt; 0xfff, &quot;page size too small - change the constant&quot;);
2678    andcc(Rscratch, 0xfffff003, Rscratch);
2679    if (counters != NULL) {
2680      // Accounting needs the Rscratch register
2681      st_ptr(Rscratch, Rbox, BasicLock::displaced_header_offset_in_bytes());
2682      cond_inc(Assembler::equal, (address) counters-&gt;fast_path_entry_count_addr(), Rmark, Rscratch);
2683      ba_short(done);
2684    } else {
2685      ba(done);
2686      delayed()-&gt;st_ptr(Rscratch, Rbox, BasicLock::displaced_header_offset_in_bytes());
2687    }
2688 
2689    bind   (IsInflated);
2690 
2691    // Try to CAS m-&gt;owner from null to Self
2692    // Invariant: if we acquire the lock then _recursions should be 0.
2693    add(Rmark, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), Rmark);
2694    mov(G2_thread, Rscratch);
2695    cas_ptr(Rmark, G0, Rscratch);
2696    andcc(Rscratch, Rscratch, G0);             // set ICCs for done: icc.zf iff success
2697    // set icc.zf : 1=success 0=failure
2698    // ST box-&gt;displaced_header = NonZero.
2699    // Any non-zero value suffices:
2700    //    markWord::unused_mark(), G2_thread, RBox, RScratch, rsp, etc.
2701    st_ptr(Rbox, Rbox, BasicLock::displaced_header_offset_in_bytes());
2702    // Intentional fall-through into done
2703 
2704    bind   (done);
2705 }
2706 
2707 void MacroAssembler::compiler_unlock_object(Register Roop, Register Rmark,
2708                                             Register Rbox, Register Rscratch,
2709                                             bool try_bias) {
2710    Address mark_addr(Roop, oopDesc::mark_offset_in_bytes());
2711 
2712    Label done ;
2713 
2714    // Beware ... If the aggregate size of the code emitted by CLO and CUO is
2715    // is too large performance rolls abruptly off a cliff.
2716    // This could be related to inlining policies, code cache management, or
2717    // I$ effects.
2718    Label LStacked ;
2719 
2720    if (try_bias) {
2721       // TODO: eliminate redundant LDs of obj-&gt;mark
2722       biased_locking_exit(mark_addr, Rscratch, done);
2723    }
2724 
2725    ld_ptr(Roop, oopDesc::mark_offset_in_bytes(), Rmark);
2726    ld_ptr(Rbox, BasicLock::displaced_header_offset_in_bytes(), Rscratch);
2727    andcc(Rscratch, Rscratch, G0);
2728    brx(Assembler::zero, false, Assembler::pn, done);
2729    delayed()-&gt;nop();      // consider: relocate fetch of mark, above, into this DS
2730    andcc(Rmark, 2, G0);
2731    brx(Assembler::zero, false, Assembler::pt, LStacked);
2732    delayed()-&gt;nop();
2733 
2734    // It&#39;s inflated
2735    // Conceptually we need a #loadstore|#storestore &quot;release&quot; MEMBAR before
2736    // the ST of 0 into _owner which releases the lock.  This prevents loads
2737    // and stores within the critical section from reordering (floating)
2738    // past the store that releases the lock.  But TSO is a strong memory model
2739    // and that particular flavor of barrier is a noop, so we can safely elide it.
2740    // Note that we use 1-0 locking by default for the inflated case.  We
2741    // close the resultant (and rare) race by having contended threads in
2742    // monitorenter periodically poll _owner.
2743 
2744    // 1-0 form : avoids CAS and MEMBAR in the common case
2745    // Do not bother to ratify that m-&gt;Owner == Self.
2746    ld_ptr(Address(Rmark, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), Rbox);
2747    orcc(Rbox, G0, G0);
2748    brx(Assembler::notZero, false, Assembler::pn, done);
2749    delayed()-&gt;
2750    ld_ptr(Address(Rmark, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)), Rscratch);
2751    ld_ptr(Address(Rmark, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)), Rbox);
2752    orcc(Rbox, Rscratch, G0);
2753    brx(Assembler::zero, false, Assembler::pt, done);
2754    delayed()-&gt;
2755    st_ptr(G0, Address(Rmark, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));
2756 
2757    membar(StoreLoad);
2758    // Check that _succ is (or remains) non-zero
2759    ld_ptr(Address(Rmark, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), Rscratch);
2760    andcc(Rscratch, Rscratch, G0);
2761    brx(Assembler::notZero, false, Assembler::pt, done);
2762    delayed()-&gt;andcc(G0, G0, G0);
2763    add(Rmark, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), Rmark);
2764    mov(G2_thread, Rscratch);
2765    cas_ptr(Rmark, G0, Rscratch);
2766    cmp(Rscratch, G0);
2767    // invert icc.zf and goto done
2768    // A slightly better v8+/v9 idiom would be the following:
2769    //   movrnz Rscratch,1,Rscratch
2770    //   ba done
2771    //   xorcc Rscratch,1,G0
2772    // In v8+ mode the idiom would be valid IFF Rscratch was a G or O register
2773    brx(Assembler::notZero, false, Assembler::pt, done);
2774    delayed()-&gt;cmp(G0, G0);
2775    br(Assembler::always, false, Assembler::pt, done);
2776    delayed()-&gt;cmp(G0, 1);
2777 
2778    bind   (LStacked);
2779    // Consider: we could replace the expensive CAS in the exit
2780    // path with a simple ST of the displaced mark value fetched from
2781    // the on-stack basiclock box.  That admits a race where a thread T2
2782    // in the slow lock path -- inflating with monitor M -- could race a
2783    // thread T1 in the fast unlock path, resulting in a missed wakeup for T2.
2784    // More precisely T1 in the stack-lock unlock path could &quot;stomp&quot; the
2785    // inflated mark value M installed by T2, resulting in an orphan
2786    // object monitor M and T2 becoming stranded.  We can remedy that situation
2787    // by having T2 periodically poll the object&#39;s mark word using timed wait
2788    // operations.  If T2 discovers that a stomp has occurred it vacates
2789    // the monitor M and wakes any other threads stranded on the now-orphan M.
2790    // In addition the monitor scavenger, which performs deflation,
2791    // would also need to check for orpan monitors and stranded threads.
2792    //
2793    // Finally, inflation is also used when T2 needs to assign a hashCode
2794    // to O and O is stack-locked by T1.  The &quot;stomp&quot; race could cause
2795    // an assigned hashCode value to be lost.  We can avoid that condition
2796    // and provide the necessary hashCode stability invariants by ensuring
2797    // that hashCode generation is idempotent between copying GCs.
2798    // For example we could compute the hashCode of an object O as
2799    // O&#39;s heap address XOR some high quality RNG value that is refreshed
2800    // at GC-time.  The monitor scavenger would install the hashCode
2801    // found in any orphan monitors.  Again, the mechanism admits a
2802    // lost-update &quot;stomp&quot; WAW race but detects and recovers as needed.
2803    //
2804    // A prototype implementation showed excellent results, although
2805    // the scavenger and timeout code was rather involved.
2806 
2807    cas_ptr(mark_addr.base(), Rbox, Rscratch);
2808    cmp(Rbox, Rscratch);
2809    // Intentional fall through into done ...
2810 
2811    bind(done);
2812 }
2813 
2814 void MacroAssembler::verify_tlab() {
2815 #ifdef ASSERT
2816   if (UseTLAB &amp;&amp; VerifyOops) {
2817     Label next, next2, ok;
2818     Register t1 = L0;
2819     Register t2 = L1;
2820     Register t3 = L2;
2821 
2822     save_frame(0);
2823     ld_ptr(G2_thread, in_bytes(JavaThread::tlab_top_offset()), t1);
2824     ld_ptr(G2_thread, in_bytes(JavaThread::tlab_start_offset()), t2);
2825     or3(t1, t2, t3);
2826     cmp_and_br_short(t1, t2, Assembler::greaterEqual, Assembler::pn, next);
2827     STOP(&quot;assert(top &gt;= start)&quot;);
2828     should_not_reach_here();
2829 
2830     bind(next);
2831     ld_ptr(G2_thread, in_bytes(JavaThread::tlab_top_offset()), t1);
2832     ld_ptr(G2_thread, in_bytes(JavaThread::tlab_end_offset()), t2);
2833     or3(t3, t2, t3);
2834     cmp_and_br_short(t1, t2, Assembler::lessEqual, Assembler::pn, next2);
2835     STOP(&quot;assert(top &lt;= end)&quot;);
2836     should_not_reach_here();
2837 
2838     bind(next2);
2839     and3(t3, MinObjAlignmentInBytesMask, t3);
2840     cmp_and_br_short(t3, 0, Assembler::lessEqual, Assembler::pn, ok);
2841     STOP(&quot;assert(aligned)&quot;);
2842     should_not_reach_here();
2843 
2844     bind(ok);
2845     restore();
2846   }
2847 #endif
2848 }
2849 
2850 
2851 void MacroAssembler::eden_allocate(
2852   Register obj,                        // result: pointer to object after successful allocation
2853   Register var_size_in_bytes,          // object size in bytes if unknown at compile time; invalid otherwise
2854   int      con_size_in_bytes,          // object size in bytes if   known at compile time
2855   Register t1,                         // temp register
2856   Register t2,                         // temp register
2857   Label&amp;   slow_case                   // continuation point if fast allocation fails
2858 ){
2859   // make sure arguments make sense
2860   assert_different_registers(obj, var_size_in_bytes, t1, t2);
2861   assert(0 &lt;= con_size_in_bytes &amp;&amp; Assembler::is_simm13(con_size_in_bytes), &quot;illegal object size&quot;);
2862   assert((con_size_in_bytes &amp; MinObjAlignmentInBytesMask) == 0, &quot;object size is not multiple of alignment&quot;);
2863 
2864   if (!Universe::heap()-&gt;supports_inline_contig_alloc()) {
2865     // No allocation in the shared eden.
2866     ba(slow_case);
2867     delayed()-&gt;nop();
2868   } else {
2869     // get eden boundaries
2870     // note: we need both top &amp; top_addr!
2871     const Register top_addr = t1;
2872     const Register end      = t2;
2873 
2874     CollectedHeap* ch = Universe::heap();
2875     set((intx)ch-&gt;top_addr(), top_addr);
2876     intx delta = (intx)ch-&gt;end_addr() - (intx)ch-&gt;top_addr();
2877     ld_ptr(top_addr, delta, end);
2878     ld_ptr(top_addr, 0, obj);
2879 
2880     // try to allocate
2881     Label retry;
2882     bind(retry);
2883 #ifdef ASSERT
2884     // make sure eden top is properly aligned
2885     {
2886       Label L;
2887       btst(MinObjAlignmentInBytesMask, obj);
2888       br(Assembler::zero, false, Assembler::pt, L);
2889       delayed()-&gt;nop();
2890       STOP(&quot;eden top is not properly aligned&quot;);
2891       bind(L);
2892     }
2893 #endif // ASSERT
2894     const Register free = end;
2895     sub(end, obj, free);                                   // compute amount of free space
2896     if (var_size_in_bytes-&gt;is_valid()) {
2897       // size is unknown at compile time
2898       cmp(free, var_size_in_bytes);
2899       brx(Assembler::lessUnsigned, false, Assembler::pn, slow_case); // if there is not enough space go the slow case
2900       delayed()-&gt;add(obj, var_size_in_bytes, end);
2901     } else {
2902       // size is known at compile time
2903       cmp(free, con_size_in_bytes);
2904       brx(Assembler::lessUnsigned, false, Assembler::pn, slow_case); // if there is not enough space go the slow case
2905       delayed()-&gt;add(obj, con_size_in_bytes, end);
2906     }
2907     // Compare obj with the value at top_addr; if still equal, swap the value of
2908     // end with the value at top_addr. If not equal, read the value at top_addr
2909     // into end.
2910     cas_ptr(top_addr, obj, end);
2911     // if someone beat us on the allocation, try again, otherwise continue
2912     cmp(obj, end);
2913     brx(Assembler::notEqual, false, Assembler::pn, retry);
2914     delayed()-&gt;mov(end, obj);                              // nop if successfull since obj == end
2915 
2916 #ifdef ASSERT
2917     // make sure eden top is properly aligned
2918     {
2919       Label L;
2920       const Register top_addr = t1;
2921 
2922       set((intx)ch-&gt;top_addr(), top_addr);
2923       ld_ptr(top_addr, 0, top_addr);
2924       btst(MinObjAlignmentInBytesMask, top_addr);
2925       br(Assembler::zero, false, Assembler::pt, L);
2926       delayed()-&gt;nop();
2927       STOP(&quot;eden top is not properly aligned&quot;);
2928       bind(L);
2929     }
2930 #endif // ASSERT
2931   }
2932 }
2933 
2934 
2935 void MacroAssembler::tlab_allocate(
2936   Register obj,                        // result: pointer to object after successful allocation
2937   Register var_size_in_bytes,          // object size in bytes if unknown at compile time; invalid otherwise
2938   int      con_size_in_bytes,          // object size in bytes if   known at compile time
2939   Register t1,                         // temp register
2940   Label&amp;   slow_case                   // continuation point if fast allocation fails
2941 ){
2942   // make sure arguments make sense
2943   assert_different_registers(obj, var_size_in_bytes, t1);
2944   assert(0 &lt;= con_size_in_bytes &amp;&amp; is_simm13(con_size_in_bytes), &quot;illegal object size&quot;);
2945   assert((con_size_in_bytes &amp; MinObjAlignmentInBytesMask) == 0, &quot;object size is not multiple of alignment&quot;);
2946 
2947   const Register free  = t1;
2948 
2949   verify_tlab();
2950 
2951   ld_ptr(G2_thread, in_bytes(JavaThread::tlab_top_offset()), obj);
2952 
2953   // calculate amount of free space
2954   ld_ptr(G2_thread, in_bytes(JavaThread::tlab_end_offset()), free);
2955   sub(free, obj, free);
2956 
2957   Label done;
2958   if (var_size_in_bytes == noreg) {
2959     cmp(free, con_size_in_bytes);
2960   } else {
2961     cmp(free, var_size_in_bytes);
2962   }
2963   br(Assembler::less, false, Assembler::pn, slow_case);
2964   // calculate the new top pointer
2965   if (var_size_in_bytes == noreg) {
2966     delayed()-&gt;add(obj, con_size_in_bytes, free);
2967   } else {
2968     delayed()-&gt;add(obj, var_size_in_bytes, free);
2969   }
2970 
2971   bind(done);
2972 
2973 #ifdef ASSERT
2974   // make sure new free pointer is properly aligned
2975   {
2976     Label L;
2977     btst(MinObjAlignmentInBytesMask, free);
2978     br(Assembler::zero, false, Assembler::pt, L);
2979     delayed()-&gt;nop();
2980     STOP(&quot;updated TLAB free is not properly aligned&quot;);
2981     bind(L);
2982   }
2983 #endif // ASSERT
2984 
2985   // update the tlab top pointer
2986   st_ptr(free, G2_thread, in_bytes(JavaThread::tlab_top_offset()));
2987   verify_tlab();
2988 }
2989 
2990 void MacroAssembler::zero_memory(Register base, Register index) {
2991   assert_different_registers(base, index);
2992   Label loop;
2993   bind(loop);
2994   subcc(index, HeapWordSize, index);
2995   brx(Assembler::greaterEqual, true, Assembler::pt, loop);
2996   delayed()-&gt;st_ptr(G0, base, index);
2997 }
2998 
2999 void MacroAssembler::incr_allocated_bytes(RegisterOrConstant size_in_bytes,
3000                                           Register t1, Register t2) {
3001   // Bump total bytes allocated by this thread
3002   assert(t1-&gt;is_global(), &quot;must be global reg&quot;); // so all 64 bits are saved on a context switch
3003   assert_different_registers(size_in_bytes.register_or_noreg(), t1, t2);
3004   // v8 support has gone the way of the dodo
3005   ldx(G2_thread, in_bytes(JavaThread::allocated_bytes_offset()), t1);
3006   add(t1, ensure_simm13_or_reg(size_in_bytes, t2), t1);
3007   stx(t1, G2_thread, in_bytes(JavaThread::allocated_bytes_offset()));
3008 }
3009 
3010 Assembler::Condition MacroAssembler::negate_condition(Assembler::Condition cond) {
3011   switch (cond) {
3012     // Note some conditions are synonyms for others
3013     case Assembler::never:                return Assembler::always;
3014     case Assembler::zero:                 return Assembler::notZero;
3015     case Assembler::lessEqual:            return Assembler::greater;
3016     case Assembler::less:                 return Assembler::greaterEqual;
3017     case Assembler::lessEqualUnsigned:    return Assembler::greaterUnsigned;
3018     case Assembler::lessUnsigned:         return Assembler::greaterEqualUnsigned;
3019     case Assembler::negative:             return Assembler::positive;
3020     case Assembler::overflowSet:          return Assembler::overflowClear;
3021     case Assembler::always:               return Assembler::never;
3022     case Assembler::notZero:              return Assembler::zero;
3023     case Assembler::greater:              return Assembler::lessEqual;
3024     case Assembler::greaterEqual:         return Assembler::less;
3025     case Assembler::greaterUnsigned:      return Assembler::lessEqualUnsigned;
3026     case Assembler::greaterEqualUnsigned: return Assembler::lessUnsigned;
3027     case Assembler::positive:             return Assembler::negative;
3028     case Assembler::overflowClear:        return Assembler::overflowSet;
3029   }
3030 
3031   ShouldNotReachHere(); return Assembler::overflowClear;
3032 }
3033 
3034 void MacroAssembler::cond_inc(Assembler::Condition cond, address counter_ptr,
3035                               Register Rtmp1, Register Rtmp2 /*, Register Rtmp3, Register Rtmp4 */) {
3036   Condition negated_cond = negate_condition(cond);
3037   Label L;
3038   brx(negated_cond, false, Assembler::pt, L);
3039   delayed()-&gt;nop();
3040   inc_counter(counter_ptr, Rtmp1, Rtmp2);
3041   bind(L);
3042 }
3043 
3044 void MacroAssembler::inc_counter(address counter_addr, Register Rtmp1, Register Rtmp2) {
3045   AddressLiteral addrlit(counter_addr);
3046   sethi(addrlit, Rtmp1);                 // Move hi22 bits into temporary register.
3047   Address addr(Rtmp1, addrlit.low10());  // Build an address with low10 bits.
3048   ld(addr, Rtmp2);
3049   inc(Rtmp2);
3050   st(Rtmp2, addr);
3051 }
3052 
3053 void MacroAssembler::inc_counter(int* counter_addr, Register Rtmp1, Register Rtmp2) {
3054   inc_counter((address) counter_addr, Rtmp1, Rtmp2);
3055 }
3056 
3057 SkipIfEqual::SkipIfEqual(
3058     MacroAssembler* masm, Register temp, const bool* flag_addr,
3059     Assembler::Condition condition) {
3060   _masm = masm;
3061   AddressLiteral flag(flag_addr);
3062   _masm-&gt;sethi(flag, temp);
3063   _masm-&gt;ldub(temp, flag.low10(), temp);
3064   _masm-&gt;tst(temp);
3065   _masm-&gt;br(condition, false, Assembler::pt, _label);
3066   _masm-&gt;delayed()-&gt;nop();
3067 }
3068 
3069 SkipIfEqual::~SkipIfEqual() {
3070   _masm-&gt;bind(_label);
3071 }
3072 
3073 void MacroAssembler::bang_stack_with_offset(int offset) {
3074   // stack grows down, caller passes positive offset
3075   assert(offset &gt; 0, &quot;must bang with negative offset&quot;);
3076   set((-offset)+STACK_BIAS, G3_scratch);
3077   st(G0, SP, G3_scratch);
3078 }
3079 
3080 // Writes to stack successive pages until offset reached to check for
3081 // stack overflow + shadow pages.  This clobbers tsp and scratch.
3082 void MacroAssembler::bang_stack_size(Register Rsize, Register Rtsp,
3083                                      Register Rscratch) {
3084   // Use stack pointer in temp stack pointer
3085   mov(SP, Rtsp);
3086 
3087   // Bang stack for total size given plus stack shadow page size.
3088   // Bang one page at a time because a large size can overflow yellow and
3089   // red zones (the bang will fail but stack overflow handling can&#39;t tell that
3090   // it was a stack overflow bang vs a regular segv).
3091   int offset = os::vm_page_size();
3092   Register Roffset = Rscratch;
3093 
3094   Label loop;
3095   bind(loop);
3096   set((-offset)+STACK_BIAS, Rscratch);
3097   st(G0, Rtsp, Rscratch);
3098   set(offset, Roffset);
3099   sub(Rsize, Roffset, Rsize);
3100   cmp(Rsize, G0);
3101   br(Assembler::greater, false, Assembler::pn, loop);
3102   delayed()-&gt;sub(Rtsp, Roffset, Rtsp);
3103 
3104   // Bang down shadow pages too.
3105   // At this point, (tmp-0) is the last address touched, so don&#39;t
3106   // touch it again.  (It was touched as (tmp-pagesize) but then tmp
3107   // was post-decremented.)  Skip this address by starting at i=1, and
3108   // touch a few more pages below.  N.B.  It is important to touch all
3109   // the way down to and including i=StackShadowPages.
3110   for (int i = 1; i &lt; JavaThread::stack_shadow_zone_size() / os::vm_page_size(); i++) {
3111     set((-i*offset)+STACK_BIAS, Rscratch);
3112     st(G0, Rtsp, Rscratch);
3113   }
3114 }
3115 
3116 void MacroAssembler::reserved_stack_check() {
3117   // testing if reserved zone needs to be enabled
3118   Label no_reserved_zone_enabling;
3119 
3120   ld_ptr(G2_thread, JavaThread::reserved_stack_activation_offset(), G4_scratch);
3121   cmp_and_brx_short(SP, G4_scratch, Assembler::lessUnsigned, Assembler::pt, no_reserved_zone_enabling);
3122 
3123   call_VM_leaf(L0, CAST_FROM_FN_PTR(address, SharedRuntime::enable_stack_reserved_zone), G2_thread);
3124 
3125   AddressLiteral stub(StubRoutines::throw_delayed_StackOverflowError_entry());
3126   jump_to(stub, G4_scratch);
3127   delayed()-&gt;restore();
3128 
3129   should_not_reach_here();
3130 
3131   bind(no_reserved_zone_enabling);
3132 }
3133 // ((OopHandle)result).resolve();
3134 void MacroAssembler::resolve_oop_handle(Register result, Register tmp) {
3135   // OopHandle::resolve is an indirection.
3136   access_load_at(T_OBJECT, IN_NATIVE, Address(result, 0), result, tmp);
3137 }
3138 
3139 void MacroAssembler::load_mirror(Register mirror, Register method, Register tmp) {
3140   const int mirror_offset = in_bytes(Klass::java_mirror_offset());
3141   ld_ptr(method, in_bytes(Method::const_offset()), mirror);
3142   ld_ptr(mirror, in_bytes(ConstMethod::constants_offset()), mirror);
3143   ld_ptr(mirror, ConstantPool::pool_holder_offset_in_bytes(), mirror);
3144   ld_ptr(mirror, mirror_offset, mirror);
3145   resolve_oop_handle(mirror, tmp);
3146 }
3147 
3148 void MacroAssembler::load_klass(Register src_oop, Register klass) {
3149   // The number of bytes in this code is used by
3150   // MachCallDynamicJavaNode::ret_addr_offset()
3151   // if this changes, change that.
3152   if (UseCompressedClassPointers) {
3153     lduw(src_oop, oopDesc::klass_offset_in_bytes(), klass);
3154     decode_klass_not_null(klass);
3155   } else {
3156     ld_ptr(src_oop, oopDesc::klass_offset_in_bytes(), klass);
3157   }
3158 }
3159 
3160 void MacroAssembler::store_klass(Register klass, Register dst_oop) {
3161   if (UseCompressedClassPointers) {
3162     assert(dst_oop != klass, &quot;not enough registers&quot;);
3163     encode_klass_not_null(klass);
3164     st(klass, dst_oop, oopDesc::klass_offset_in_bytes());
3165   } else {
3166     st_ptr(klass, dst_oop, oopDesc::klass_offset_in_bytes());
3167   }
3168 }
3169 
3170 void MacroAssembler::store_klass_gap(Register s, Register d) {
3171   if (UseCompressedClassPointers) {
3172     assert(s != d, &quot;not enough registers&quot;);
3173     st(s, d, oopDesc::klass_gap_offset_in_bytes());
3174   }
3175 }
3176 
3177 void MacroAssembler::access_store_at(BasicType type, DecoratorSet decorators,
3178                                      Register src, Address dst, Register tmp) {
3179   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3180   decorators = AccessInternal::decorator_fixup(decorators);
3181   bool as_raw = (decorators &amp; AS_RAW) != 0;
3182   if (as_raw) {
3183     bs-&gt;BarrierSetAssembler::store_at(this, decorators, type, src, dst, tmp);
3184   } else {
3185     bs-&gt;store_at(this, decorators, type, src, dst, tmp);
3186   }
3187 }
3188 
3189 void MacroAssembler::access_load_at(BasicType type, DecoratorSet decorators,
3190                                     Address src, Register dst, Register tmp) {
3191   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3192   decorators = AccessInternal::decorator_fixup(decorators);
3193   bool as_raw = (decorators &amp; AS_RAW) != 0;
3194   if (as_raw) {
3195     bs-&gt;BarrierSetAssembler::load_at(this, decorators, type, src, dst, tmp);
3196   } else {
3197     bs-&gt;load_at(this, decorators, type, src, dst, tmp);
3198   }
3199 }
3200 
3201 void MacroAssembler::load_heap_oop(const Address&amp; s, Register d, Register tmp, DecoratorSet decorators) {
3202   access_load_at(T_OBJECT, IN_HEAP | decorators, s, d, tmp);
3203 }
3204 
3205 void MacroAssembler::load_heap_oop(Register s1, Register s2, Register d, Register tmp, DecoratorSet decorators) {
3206   access_load_at(T_OBJECT, IN_HEAP | decorators, Address(s1, s2), d, tmp);
3207 }
3208 
3209 void MacroAssembler::load_heap_oop(Register s1, int simm13a, Register d, Register tmp, DecoratorSet decorators) {
3210   access_load_at(T_OBJECT, IN_HEAP | decorators, Address(s1, simm13a), d, tmp);
3211 }
3212 
3213 void MacroAssembler::load_heap_oop(Register s1, RegisterOrConstant s2, Register d, Register tmp, DecoratorSet decorators) {
3214   if (s2.is_constant()) {
3215     access_load_at(T_OBJECT, IN_HEAP | decorators, Address(s1, s2.as_constant()), d, tmp);
3216   } else {
3217     access_load_at(T_OBJECT, IN_HEAP | decorators, Address(s1, s2.as_register()), d, tmp);
3218   }
3219 }
3220 
3221 void MacroAssembler::store_heap_oop(Register d, Register s1, Register s2, Register tmp, DecoratorSet decorators) {
3222   access_store_at(T_OBJECT, IN_HEAP | decorators, d, Address(s1, s2), tmp);
3223 }
3224 
3225 void MacroAssembler::store_heap_oop(Register d, Register s1, int simm13a, Register tmp, DecoratorSet decorators) {
3226   access_store_at(T_OBJECT, IN_HEAP | decorators, d, Address(s1, simm13a), tmp);
3227 }
3228 
3229 void MacroAssembler::store_heap_oop(Register d, const Address&amp; a, int offset, Register tmp, DecoratorSet decorators) {
3230   if (a.has_index()) {
3231     assert(!a.has_disp(), &quot;not supported yet&quot;);
3232     assert(offset == 0, &quot;not supported yet&quot;);
3233     access_store_at(T_OBJECT, IN_HEAP | decorators, d, Address(a.base(), a.index()), tmp);
3234   } else {
3235     access_store_at(T_OBJECT, IN_HEAP | decorators, d, Address(a.base(), a.disp() + offset), tmp);
3236   }
3237 }
3238 
3239 
3240 void MacroAssembler::encode_heap_oop(Register src, Register dst) {
3241   assert (UseCompressedOops, &quot;must be compressed&quot;);
3242   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
3243   assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3244   verify_oop(src);
3245   if (CompressedOops::base() == NULL) {
3246     srlx(src, LogMinObjAlignmentInBytes, dst);
3247     return;
3248   }
3249   Label done;
3250   if (src == dst) {
3251     // optimize for frequent case src == dst
3252     bpr(rc_nz, true, Assembler::pt, src, done);
3253     delayed() -&gt; sub(src, G6_heapbase, dst); // annuled if not taken
3254     bind(done);
3255     srlx(src, LogMinObjAlignmentInBytes, dst);
3256   } else {
3257     bpr(rc_z, false, Assembler::pn, src, done);
3258     delayed() -&gt; mov(G0, dst);
3259     // could be moved before branch, and annulate delay,
3260     // but may add some unneeded work decoding null
3261     sub(src, G6_heapbase, dst);
3262     srlx(dst, LogMinObjAlignmentInBytes, dst);
3263     bind(done);
3264   }
3265 }
3266 
3267 
3268 void MacroAssembler::encode_heap_oop_not_null(Register r) {
3269   assert (UseCompressedOops, &quot;must be compressed&quot;);
3270   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
3271   assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3272   verify_oop(r);
3273   if (CompressedOops::base() != NULL)
3274     sub(r, G6_heapbase, r);
3275   srlx(r, LogMinObjAlignmentInBytes, r);
3276 }
3277 
3278 void MacroAssembler::encode_heap_oop_not_null(Register src, Register dst) {
3279   assert (UseCompressedOops, &quot;must be compressed&quot;);
3280   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
3281   assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3282   verify_oop(src);
3283   if (CompressedOops::base() == NULL) {
3284     srlx(src, LogMinObjAlignmentInBytes, dst);
3285   } else {
3286     sub(src, G6_heapbase, dst);
3287     srlx(dst, LogMinObjAlignmentInBytes, dst);
3288   }
3289 }
3290 
3291 // Same algorithm as oops.inline.hpp decode_heap_oop.
3292 void  MacroAssembler::decode_heap_oop(Register src, Register dst) {
3293   assert (UseCompressedOops, &quot;must be compressed&quot;);
3294   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
3295   assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3296   sllx(src, LogMinObjAlignmentInBytes, dst);
3297   if (CompressedOops::base() != NULL) {
3298     Label done;
3299     bpr(rc_nz, true, Assembler::pt, dst, done);
3300     delayed() -&gt; add(dst, G6_heapbase, dst); // annuled if not taken
3301     bind(done);
3302   }
3303   verify_oop(dst);
3304 }
3305 
3306 void  MacroAssembler::decode_heap_oop_not_null(Register r) {
3307   // Do not add assert code to this unless you change vtableStubs_sparc.cpp
3308   // pd_code_size_limit.
3309   // Also do not verify_oop as this is called by verify_oop.
3310   assert (UseCompressedOops, &quot;must be compressed&quot;);
3311   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
3312   assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3313   sllx(r, LogMinObjAlignmentInBytes, r);
3314   if (CompressedOops::base() != NULL)
3315     add(r, G6_heapbase, r);
3316 }
3317 
3318 void  MacroAssembler::decode_heap_oop_not_null(Register src, Register dst) {
3319   // Do not add assert code to this unless you change vtableStubs_sparc.cpp
3320   // pd_code_size_limit.
3321   // Also do not verify_oop as this is called by verify_oop.
3322   assert (UseCompressedOops, &quot;must be compressed&quot;);
3323   assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3324   sllx(src, LogMinObjAlignmentInBytes, dst);
3325   if (CompressedOops::base() != NULL)
3326     add(dst, G6_heapbase, dst);
3327 }
3328 
3329 void MacroAssembler::encode_klass_not_null(Register r) {
3330   assert (UseCompressedClassPointers, &quot;must be compressed&quot;);
3331   if (CompressedKlassPointers::base() != NULL) {
3332     assert(r != G6_heapbase, &quot;bad register choice&quot;);
3333     set((intptr_t)CompressedKlassPointers::base(), G6_heapbase);
3334     sub(r, G6_heapbase, r);
3335     if (CompressedKlassPointers::shift() != 0) {
3336       assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
3337       srlx(r, LogKlassAlignmentInBytes, r);
3338     }
3339     reinit_heapbase();
3340   } else {
3341     assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift() || CompressedKlassPointers::shift() == 0, &quot;decode alg wrong&quot;);
3342     srlx(r, CompressedKlassPointers::shift(), r);
3343   }
3344 }
3345 
3346 void MacroAssembler::encode_klass_not_null(Register src, Register dst) {
3347   if (src == dst) {
3348     encode_klass_not_null(src);
3349   } else {
3350     assert (UseCompressedClassPointers, &quot;must be compressed&quot;);
3351     if (CompressedKlassPointers::base() != NULL) {
3352       set((intptr_t)CompressedKlassPointers::base(), dst);
3353       sub(src, dst, dst);
3354       if (CompressedKlassPointers::shift() != 0) {
3355         srlx(dst, LogKlassAlignmentInBytes, dst);
3356       }
3357     } else {
3358       // shift src into dst
3359       assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift() || CompressedKlassPointers::shift() == 0, &quot;decode alg wrong&quot;);
3360       srlx(src, CompressedKlassPointers::shift(), dst);
3361     }
3362   }
3363 }
3364 
3365 // Function instr_size_for_decode_klass_not_null() counts the instructions
3366 // generated by decode_klass_not_null() and reinit_heapbase().  Hence, if
3367 // the instructions they generate change, then this method needs to be updated.
3368 int MacroAssembler::instr_size_for_decode_klass_not_null() {
3369   assert (UseCompressedClassPointers, &quot;only for compressed klass ptrs&quot;);
3370   int num_instrs = 1;  // shift src,dst or add
3371   if (CompressedKlassPointers::base() != NULL) {
3372     // set + add + set
3373     num_instrs += insts_for_internal_set((intptr_t)CompressedKlassPointers::base()) +
3374                   insts_for_internal_set((intptr_t)CompressedOops::ptrs_base());
3375     if (CompressedKlassPointers::shift() != 0) {
3376       num_instrs += 1;  // sllx
3377     }
3378   }
3379   return num_instrs * BytesPerInstWord;
3380 }
3381 
3382 // !!! If the instructions that get generated here change then function
3383 // instr_size_for_decode_klass_not_null() needs to get updated.
3384 void  MacroAssembler::decode_klass_not_null(Register r) {
3385   // Do not add assert code to this unless you change vtableStubs_sparc.cpp
3386   // pd_code_size_limit.
3387   assert (UseCompressedClassPointers, &quot;must be compressed&quot;);
3388   if (CompressedKlassPointers::base() != NULL) {
3389     assert(r != G6_heapbase, &quot;bad register choice&quot;);
3390     set((intptr_t)CompressedKlassPointers::base(), G6_heapbase);
3391     if (CompressedKlassPointers::shift() != 0)
3392       sllx(r, LogKlassAlignmentInBytes, r);
3393     add(r, G6_heapbase, r);
3394     reinit_heapbase();
3395   } else {
3396     assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift() || CompressedKlassPointers::shift() == 0, &quot;decode alg wrong&quot;);
3397     sllx(r, CompressedKlassPointers::shift(), r);
3398   }
3399 }
3400 
3401 void  MacroAssembler::decode_klass_not_null(Register src, Register dst) {
3402   if (src == dst) {
3403     decode_klass_not_null(src);
3404   } else {
3405     // Do not add assert code to this unless you change vtableStubs_sparc.cpp
3406     // pd_code_size_limit.
3407     assert (UseCompressedClassPointers, &quot;must be compressed&quot;);
3408     if (CompressedKlassPointers::base() != NULL) {
3409       if (CompressedKlassPointers::shift() != 0) {
3410         assert((src != G6_heapbase) &amp;&amp; (dst != G6_heapbase), &quot;bad register choice&quot;);
3411         set((intptr_t)CompressedKlassPointers::base(), G6_heapbase);
3412         sllx(src, LogKlassAlignmentInBytes, dst);
3413         add(dst, G6_heapbase, dst);
3414         reinit_heapbase();
3415       } else {
3416         set((intptr_t)CompressedKlassPointers::base(), dst);
3417         add(src, dst, dst);
3418       }
3419     } else {
3420       // shift/mov src into dst.
3421       assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift() || CompressedKlassPointers::shift() == 0, &quot;decode alg wrong&quot;);
3422       sllx(src, CompressedKlassPointers::shift(), dst);
3423     }
3424   }
3425 }
3426 
3427 void MacroAssembler::reinit_heapbase() {
3428   if (UseCompressedOops || UseCompressedClassPointers) {
3429     if (Universe::heap() != NULL) {
3430       set((intptr_t)CompressedOops::ptrs_base(), G6_heapbase);
3431     } else {
3432       AddressLiteral base(CompressedOops::ptrs_base_addr());
3433       load_ptr_contents(base, G6_heapbase);
3434     }
3435   }
3436 }
3437 
3438 #ifdef COMPILER2
3439 
3440 // Compress char[] to byte[] by compressing 16 bytes at once. Return 0 on failure.
3441 void MacroAssembler::string_compress_16(Register src, Register dst, Register cnt, Register result,
3442                                         Register tmp1, Register tmp2, Register tmp3, Register tmp4,
3443                                         FloatRegister ftmp1, FloatRegister ftmp2, FloatRegister ftmp3, Label&amp; Ldone) {
3444   Label Lloop, Lslow;
3445   assert(UseVIS &gt;= 3, &quot;VIS3 is required&quot;);
3446   assert_different_registers(src, dst, cnt, tmp1, tmp2, tmp3, tmp4, result);
3447   assert_different_registers(ftmp1, ftmp2, ftmp3);
3448 
3449   // Check if cnt &gt;= 8 (= 16 bytes)
3450   cmp(cnt, 8);
3451   br(Assembler::less, false, Assembler::pn, Lslow);
3452   delayed()-&gt;mov(cnt, result); // copy count
3453 
3454   // Check for 8-byte alignment of src and dst
3455   or3(src, dst, tmp1);
3456   andcc(tmp1, 7, G0);
3457   br(Assembler::notZero, false, Assembler::pn, Lslow);
3458   delayed()-&gt;nop();
3459 
3460   // Set mask for bshuffle instruction
3461   Register mask = tmp4;
3462   set(0x13579bdf, mask);
3463   bmask(mask, G0, G0);
3464 
3465   // Set mask to 0xff00 ff00 ff00 ff00 to check for non-latin1 characters
3466   Assembler::sethi(0xff00fc00, mask); // mask = 0x0000 0000 ff00 fc00
3467   add(mask, 0x300, mask);             // mask = 0x0000 0000 ff00 ff00
3468   sllx(mask, 32, tmp1);               // tmp1 = 0xff00 ff00 0000 0000
3469   or3(mask, tmp1, mask);              // mask = 0xff00 ff00 ff00 ff00
3470 
3471   // Load first 8 bytes
3472   ldx(src, 0, tmp1);
3473 
3474   bind(Lloop);
3475   // Load next 8 bytes
3476   ldx(src, 8, tmp2);
3477 
3478   // Check for non-latin1 character by testing if the most significant byte of a char is set.
3479   // Although we have to move the data between integer and floating point registers, this is
3480   // still faster than the corresponding VIS instructions (ford/fand/fcmpd).
3481   or3(tmp1, tmp2, tmp3);
3482   btst(tmp3, mask);
3483   // annul zeroing if branch is not taken to preserve original count
3484   brx(Assembler::notZero, true, Assembler::pn, Ldone);
3485   delayed()-&gt;mov(G0, result); // 0 - failed
3486 
3487   // Move bytes into float register
3488   movxtod(tmp1, ftmp1);
3489   movxtod(tmp2, ftmp2);
3490 
3491   // Compress by copying one byte per char from ftmp1 and ftmp2 to ftmp3
3492   bshuffle(ftmp1, ftmp2, ftmp3);
3493   stf(FloatRegisterImpl::D, ftmp3, dst, 0);
3494 
3495   // Increment addresses and decrement count
3496   inc(src, 16);
3497   inc(dst, 8);
3498   dec(cnt, 8);
3499 
3500   cmp(cnt, 8);
3501   // annul LDX if branch is not taken to prevent access past end of string
3502   br(Assembler::greaterEqual, true, Assembler::pt, Lloop);
3503   delayed()-&gt;ldx(src, 0, tmp1);
3504 
3505   // Fallback to slow version
3506   bind(Lslow);
3507 }
3508 
3509 // Compress char[] to byte[]. Return 0 on failure.
3510 void MacroAssembler::string_compress(Register src, Register dst, Register cnt, Register result, Register tmp, Label&amp; Ldone) {
3511   Label Lloop;
3512   assert_different_registers(src, dst, cnt, tmp, result);
3513 
3514   lduh(src, 0, tmp);
3515 
3516   bind(Lloop);
3517   inc(src, sizeof(jchar));
3518   cmp(tmp, 0xff);
3519   // annul zeroing if branch is not taken to preserve original count
3520   br(Assembler::greater, true, Assembler::pn, Ldone); // don&#39;t check xcc
3521   delayed()-&gt;mov(G0, result); // 0 - failed
3522   deccc(cnt);
3523   stb(tmp, dst, 0);
3524   inc(dst);
3525   // annul LDUH if branch is not taken to prevent access past end of string
3526   br(Assembler::notZero, true, Assembler::pt, Lloop);
3527   delayed()-&gt;lduh(src, 0, tmp); // hoisted
3528 }
3529 
3530 // Inflate byte[] to char[] by inflating 16 bytes at once.
3531 void MacroAssembler::string_inflate_16(Register src, Register dst, Register cnt, Register tmp,
3532                                        FloatRegister ftmp1, FloatRegister ftmp2, FloatRegister ftmp3, FloatRegister ftmp4, Label&amp; Ldone) {
3533   Label Lloop, Lslow;
3534   assert(UseVIS &gt;= 3, &quot;VIS3 is required&quot;);
3535   assert_different_registers(src, dst, cnt, tmp);
3536   assert_different_registers(ftmp1, ftmp2, ftmp3, ftmp4);
3537 
3538   // Check if cnt &gt;= 8 (= 16 bytes)
3539   cmp(cnt, 8);
3540   br(Assembler::less, false, Assembler::pn, Lslow);
3541   delayed()-&gt;nop();
3542 
3543   // Check for 8-byte alignment of src and dst
3544   or3(src, dst, tmp);
3545   andcc(tmp, 7, G0);
3546   br(Assembler::notZero, false, Assembler::pn, Lslow);
3547   // Initialize float register to zero
3548   FloatRegister zerof = ftmp4;
3549   delayed()-&gt;fzero(FloatRegisterImpl::D, zerof);
3550 
3551   // Load first 8 bytes
3552   ldf(FloatRegisterImpl::D, src, 0, ftmp1);
3553 
3554   bind(Lloop);
3555   inc(src, 8);
3556   dec(cnt, 8);
3557 
3558   // Inflate the string by interleaving each byte from the source array
3559   // with a zero byte and storing the result in the destination array.
3560   fpmerge(zerof, ftmp1-&gt;successor(), ftmp2);
3561   stf(FloatRegisterImpl::D, ftmp2, dst, 8);
3562   fpmerge(zerof, ftmp1, ftmp3);
3563   stf(FloatRegisterImpl::D, ftmp3, dst, 0);
3564 
3565   inc(dst, 16);
3566 
3567   cmp(cnt, 8);
3568   // annul LDX if branch is not taken to prevent access past end of string
3569   br(Assembler::greaterEqual, true, Assembler::pt, Lloop);
3570   delayed()-&gt;ldf(FloatRegisterImpl::D, src, 0, ftmp1);
3571 
3572   // Fallback to slow version
3573   bind(Lslow);
3574 }
3575 
3576 // Inflate byte[] to char[].
3577 void MacroAssembler::string_inflate(Register src, Register dst, Register cnt, Register tmp, Label&amp; Ldone) {
3578   Label Loop;
3579   assert_different_registers(src, dst, cnt, tmp);
3580 
3581   ldub(src, 0, tmp);
3582   bind(Loop);
3583   inc(src);
3584   deccc(cnt);
3585   sth(tmp, dst, 0);
3586   inc(dst, sizeof(jchar));
3587   // annul LDUB if branch is not taken to prevent access past end of string
3588   br(Assembler::notZero, true, Assembler::pt, Loop);
3589   delayed()-&gt;ldub(src, 0, tmp); // hoisted
3590 }
3591 
3592 void MacroAssembler::string_compare(Register str1, Register str2,
3593                                     Register cnt1, Register cnt2,
3594                                     Register tmp1, Register tmp2,
3595                                     Register result, int ae) {
3596   Label Ldone, Lloop;
3597   assert_different_registers(str1, str2, cnt1, cnt2, tmp1, result);
3598   int stride1, stride2;
3599 
3600   // Note: Making use of the fact that compareTo(a, b) == -compareTo(b, a)
3601   // we interchange str1 and str2 in the UL case and negate the result.
3602   // Like this, str1 is always latin1 encoded, expect for the UU case.
3603 
3604   if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {
3605     srl(cnt2, 1, cnt2);
3606   }
3607 
3608   // See if the lengths are different, and calculate min in cnt1.
3609   // Save diff in case we need it for a tie-breaker.
3610   Label Lskip;
3611   Register diff = tmp1;
3612   subcc(cnt1, cnt2, diff);
3613   br(Assembler::greater, true, Assembler::pt, Lskip);
3614   // cnt2 is shorter, so use its count:
3615   delayed()-&gt;mov(cnt2, cnt1);
3616   bind(Lskip);
3617 
3618   // Rename registers
3619   Register limit1 = cnt1;
3620   Register limit2 = limit1;
3621   Register chr1   = result;
3622   Register chr2   = cnt2;
3623   if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {
3624     // We need an additional register to keep track of two limits
3625     assert_different_registers(str1, str2, cnt1, cnt2, tmp1, tmp2, result);
3626     limit2 = tmp2;
3627   }
3628 
3629   // Is the minimum length zero?
3630   cmp(limit1, (int)0); // use cast to resolve overloading ambiguity
3631   br(Assembler::equal, true, Assembler::pn, Ldone);
3632   // result is difference in lengths
3633   if (ae == StrIntrinsicNode::UU) {
3634     delayed()-&gt;sra(diff, 1, result);  // Divide by 2 to get number of chars
3635   } else {
3636     delayed()-&gt;mov(diff, result);
3637   }
3638 
3639   // Load first characters
3640   if (ae == StrIntrinsicNode::LL) {
3641     stride1 = stride2 = sizeof(jbyte);
3642     ldub(str1, 0, chr1);
3643     ldub(str2, 0, chr2);
3644   } else if (ae == StrIntrinsicNode::UU) {
3645     stride1 = stride2 = sizeof(jchar);
3646     lduh(str1, 0, chr1);
3647     lduh(str2, 0, chr2);
3648   } else {
3649     stride1 = sizeof(jbyte);
3650     stride2 = sizeof(jchar);
3651     ldub(str1, 0, chr1);
3652     lduh(str2, 0, chr2);
3653   }
3654 
3655   // Compare first characters
3656   subcc(chr1, chr2, chr1);
3657   br(Assembler::notZero, false, Assembler::pt, Ldone);
3658   assert(chr1 == result, &quot;result must be pre-placed&quot;);
3659   delayed()-&gt;nop();
3660 
3661   // Check if the strings start at same location
3662   cmp(str1, str2);
3663   brx(Assembler::equal, true, Assembler::pn, Ldone);
3664   delayed()-&gt;mov(G0, result);  // result is zero
3665 
3666   // We have no guarantee that on 64 bit the higher half of limit is 0
3667   signx(limit1);
3668 
3669   // Get limit
3670   if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {
3671     sll(limit1, 1, limit2);
3672     subcc(limit2, stride2, chr2);
3673   }
3674   subcc(limit1, stride1, chr1);
3675   br(Assembler::zero, true, Assembler::pn, Ldone);
3676   // result is difference in lengths
3677   if (ae == StrIntrinsicNode::UU) {
3678     delayed()-&gt;sra(diff, 1, result);  // Divide by 2 to get number of chars
3679   } else {
3680     delayed()-&gt;mov(diff, result);
3681   }
3682 
3683   // Shift str1 and str2 to the end of the arrays, negate limit
3684   add(str1, limit1, str1);
3685   add(str2, limit2, str2);
3686   neg(chr1, limit1);  // limit1 = -(limit1-stride1)
3687   if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {
3688     neg(chr2, limit2);  // limit2 = -(limit2-stride2)
3689   }
3690 
3691   // Compare the rest of the characters
3692   load_sized_value(Address(str1, limit1), chr1, (ae == StrIntrinsicNode::UU) ? 2 : 1, false);
3693 
3694   bind(Lloop);
3695   load_sized_value(Address(str2, limit2), chr2, (ae == StrIntrinsicNode::LL) ? 1 : 2, false);
3696 
3697   subcc(chr1, chr2, chr1);
3698   br(Assembler::notZero, false, Assembler::pt, Ldone);
3699   assert(chr1 == result, &quot;result must be pre-placed&quot;);
3700   delayed()-&gt;inccc(limit1, stride1);
3701   if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {
3702     inccc(limit2, stride2);
3703   }
3704 
3705   // annul LDUB if branch is not taken to prevent access past end of string
3706   br(Assembler::notZero, true, Assembler::pt, Lloop);
3707   delayed()-&gt;load_sized_value(Address(str1, limit1), chr1, (ae == StrIntrinsicNode::UU) ? 2 : 1, false);
3708 
3709   // If strings are equal up to min length, return the length difference.
3710   if (ae == StrIntrinsicNode::UU) {
3711     // Divide by 2 to get number of chars
3712     sra(diff, 1, result);
3713   } else {
3714     mov(diff, result);
3715   }
3716 
3717   // Otherwise, return the difference between the first mismatched chars.
3718   bind(Ldone);
3719   if(ae == StrIntrinsicNode::UL) {
3720     // Negate result (see note above)
3721     neg(result);
3722   }
3723 }
3724 
3725 void MacroAssembler::array_equals(bool is_array_equ, Register ary1, Register ary2,
3726                                   Register limit, Register tmp, Register result, bool is_byte) {
3727   Label Ldone, Lloop, Lremaining;
3728   assert_different_registers(ary1, ary2, limit, tmp, result);
3729 
3730   int length_offset  = arrayOopDesc::length_offset_in_bytes();
3731   int base_offset    = arrayOopDesc::base_offset_in_bytes(is_byte ? T_BYTE : T_CHAR);
3732   assert(base_offset % 8 == 0, &quot;Base offset must be 8-byte aligned&quot;);
3733 
3734   if (is_array_equ) {
3735     // return true if the same array
3736     cmp(ary1, ary2);
3737     brx(Assembler::equal, true, Assembler::pn, Ldone);
3738     delayed()-&gt;mov(1, result);  // equal
3739 
3740     br_null(ary1, true, Assembler::pn, Ldone);
3741     delayed()-&gt;clr(result);     // not equal
3742 
3743     br_null(ary2, true, Assembler::pn, Ldone);
3744     delayed()-&gt;clr(result);     // not equal
3745 
3746     // load the lengths of arrays
3747     ld(Address(ary1, length_offset), limit);
3748     ld(Address(ary2, length_offset), tmp);
3749 
3750     // return false if the two arrays are not equal length
3751     cmp(limit, tmp);
3752     br(Assembler::notEqual, true, Assembler::pn, Ldone);
3753     delayed()-&gt;clr(result);     // not equal
3754   }
3755 
3756   cmp_zero_and_br(Assembler::zero, limit, Ldone, true, Assembler::pn);
3757   delayed()-&gt;mov(1, result); // zero-length arrays are equal
3758 
3759   if (is_array_equ) {
3760     // load array addresses
3761     add(ary1, base_offset, ary1);
3762     add(ary2, base_offset, ary2);
3763     // set byte count
3764     if (!is_byte) {
3765       sll(limit, exact_log2(sizeof(jchar)), limit);
3766     }
3767   } else {
3768     // We have no guarantee that on 64 bit the higher half of limit is 0
3769     signx(limit);
3770   }
3771 
3772 #ifdef ASSERT
3773   // Sanity check for doubleword (8-byte) alignment of ary1 and ary2.
3774   // Guaranteed on 64-bit systems (see arrayOopDesc::header_size_in_bytes()).
3775   Label Laligned;
3776   or3(ary1, ary2, tmp);
3777   andcc(tmp, 7, tmp);
3778   br_null_short(tmp, Assembler::pn, Laligned);
3779   STOP(&quot;First array element is not 8-byte aligned.&quot;);
3780   should_not_reach_here();
3781   bind(Laligned);
3782 #endif
3783 
3784   // Shift ary1 and ary2 to the end of the arrays, negate limit
3785   add(ary1, limit, ary1);
3786   add(ary2, limit, ary2);
3787   neg(limit, limit);
3788 
3789   // MAIN LOOP
3790   // Load and compare array elements of size &#39;byte_width&#39; until the elements are not
3791   // equal or we reached the end of the arrays. If the size of the arrays is not a
3792   // multiple of &#39;byte_width&#39;, we simply read over the end of the array, bail out and
3793   // compare the remaining bytes below by skipping the garbage bytes.
3794   ldx(ary1, limit, result);
3795   bind(Lloop);
3796   ldx(ary2, limit, tmp);
3797   inccc(limit, 8);
3798   // Bail out if we reached the end (but still do the comparison)
3799   br(Assembler::positive, false, Assembler::pn, Lremaining);
3800   delayed()-&gt;cmp(result, tmp);
3801   // Check equality of elements
3802   brx(Assembler::equal, false, Assembler::pt, target(Lloop));
3803   delayed()-&gt;ldx(ary1, limit, result);
3804 
3805   ba(Ldone);
3806   delayed()-&gt;clr(result); // not equal
3807 
3808   // TAIL COMPARISON
3809   // We got here because we reached the end of the arrays. &#39;limit&#39; is the number of
3810   // garbage bytes we may have compared by reading over the end of the arrays. Shift
3811   // out the garbage and compare the remaining elements.
3812   bind(Lremaining);
3813   // Optimistic shortcut: elements potentially including garbage are equal
3814   brx(Assembler::equal, true, Assembler::pt, target(Ldone));
3815   delayed()-&gt;mov(1, result); // equal
3816   // Shift &#39;limit&#39; bytes to the right and compare
3817   sll(limit, 3, limit); // bytes to bits
3818   srlx(result, limit, result);
3819   srlx(tmp, limit, tmp);
3820   cmp(result, tmp);
3821   clr(result);
3822   movcc(Assembler::equal, false, xcc, 1, result);
3823 
3824   bind(Ldone);
3825 }
3826 
3827 void MacroAssembler::has_negatives(Register inp, Register size, Register result, Register t2, Register t3, Register t4, Register t5) {
3828 
3829   // test for negative bytes in input string of a given size
3830   // result 1 if found, 0 otherwise.
3831 
3832   Label Lcore, Ltail, Lreturn, Lcore_rpt;
3833 
3834   assert_different_registers(inp, size, t2, t3, t4, t5, result);
3835 
3836   Register i     = result;  // result used as integer index i until very end
3837   Register lmask = t2;      // t2 is aliased to lmask
3838 
3839   // INITIALIZATION
3840   // ===========================================================
3841   // initialize highbits mask -&gt; lmask = 0x8080808080808080  (8B/64b)
3842   // compute unaligned offset -&gt; i
3843   // compute core end index   -&gt; t5
3844   Assembler::sethi(0x80808000, t2);   //! sethi macro fails to emit optimal
3845   add(t2, 0x80, t2);
3846   sllx(t2, 32, t3);
3847   or3(t3, t2, lmask);                 // 0x8080808080808080 -&gt; lmask
3848   sra(size,0,size);
3849   andcc(inp, 0x7, i);                 // unaligned offset -&gt; i
3850   br(Assembler::zero, true, Assembler::pn, Lcore); // starts 8B aligned?
3851   delayed()-&gt;add(size, -8, t5);       // (annuled) core end index -&gt; t5
3852 
3853   // ===========================================================
3854 
3855   // UNALIGNED HEAD
3856   // ===========================================================
3857   // * unaligned head handling: grab aligned 8B containing unaligned inp(ut)
3858   // * obliterate (ignore) bytes outside string by shifting off reg ends
3859   // * compare with bitmask, short circuit return true if one or more high
3860   //   bits set.
3861   cmp(size, 0);
3862   br(Assembler::zero, true, Assembler::pn, Lreturn); // short-circuit?
3863   delayed()-&gt;mov(0,result);      // annuled so i not clobbered for following
3864   neg(i, t4);
3865   add(i, size, t5);
3866   ldx(inp, t4, t3);  // raw aligned 8B containing unaligned head -&gt; t3
3867   mov(8, t4);
3868   sub(t4, t5, t4);
3869   sra(t4, 31, t5);
3870   andn(t4, t5, t5);
3871   add(i, t5, t4);
3872   sll(t5, 3, t5);
3873   sll(t4, 3, t4);   // # bits to shift right, left -&gt; t5,t4
3874   srlx(t3, t5, t3);
3875   sllx(t3, t4, t3); // bytes outside string in 8B header obliterated -&gt; t3
3876   andcc(lmask, t3, G0);
3877   brx(Assembler::notZero, true, Assembler::pn, Lreturn); // short circuit?
3878   delayed()-&gt;mov(1,result);      // annuled so i not clobbered for following
3879   add(size, -8, t5);             // core end index -&gt; t5
3880   mov(8, t4);
3881   sub(t4, i, i);                 // # bytes examined in unalgn head (&lt;8) -&gt; i
3882   // ===========================================================
3883 
3884   // ALIGNED CORE
3885   // ===========================================================
3886   // * iterate index i over aligned 8B sections of core, comparing with
3887   //   bitmask, short circuit return true if one or more high bits set
3888   // t5 contains core end index/loop limit which is the index
3889   //     of the MSB of last (unaligned) 8B fully contained in the string.
3890   // inp   contains address of first byte in string/array
3891   // lmask contains 8B high bit mask for comparison
3892   // i     contains next index to be processed (adr. inp+i is on 8B boundary)
3893   bind(Lcore);
3894   cmp_and_br_short(i, t5, Assembler::greater, Assembler::pn, Ltail);
3895   bind(Lcore_rpt);
3896   ldx(inp, i, t3);
3897   andcc(t3, lmask, G0);
3898   brx(Assembler::notZero, true, Assembler::pn, Lreturn);
3899   delayed()-&gt;mov(1, result);    // annuled so i not clobbered for following
3900   add(i, 8, i);
3901   cmp_and_br_short(i, t5, Assembler::lessEqual, Assembler::pn, Lcore_rpt);
3902   // ===========================================================
3903 
3904   // ALIGNED TAIL (&lt;8B)
3905   // ===========================================================
3906   // handle aligned tail of 7B or less as complete 8B, obliterating end of
3907   // string bytes by shifting them off end, compare what&#39;s left with bitmask
3908   // inp   contains address of first byte in string/array
3909   // lmask contains 8B high bit mask for comparison
3910   // i     contains next index to be processed (adr. inp+i is on 8B boundary)
3911   bind(Ltail);
3912   subcc(size, i, t4);   // # of remaining bytes in string -&gt; t4
3913   // return 0 if no more remaining bytes
3914   br(Assembler::lessEqual, true, Assembler::pn, Lreturn);
3915   delayed()-&gt;mov(0, result); // annuled so i not clobbered for following
3916   ldx(inp, i, t3);       // load final 8B (aligned) containing tail -&gt; t3
3917   mov(8, t5);
3918   sub(t5, t4, t4);
3919   mov(0, result);        // ** i clobbered at this point
3920   sll(t4, 3, t4);        // bits beyond end of string          -&gt; t4
3921   srlx(t3, t4, t3);      // bytes beyond end now obliterated   -&gt; t3
3922   andcc(lmask, t3, G0);
3923   movcc(Assembler::notZero, false, xcc,  1, result);
3924   bind(Lreturn);
3925 }
3926 
3927 #endif
3928 
3929 
3930 // Use BIS for zeroing (count is in bytes).
3931 void MacroAssembler::bis_zeroing(Register to, Register count, Register temp, Label&amp; Ldone) {
3932   assert(UseBlockZeroing &amp;&amp; VM_Version::has_blk_zeroing(), &quot;only works with BIS zeroing&quot;);
3933   Register end = count;
3934   int cache_line_size = VM_Version::prefetch_data_size();
3935   assert(cache_line_size &gt; 0, &quot;cache line size should be known for this code&quot;);
3936   // Minimum count when BIS zeroing can be used since
3937   // it needs membar which is expensive.
3938   int block_zero_size  = MAX2(cache_line_size*3, (int)BlockZeroingLowLimit);
3939 
3940   Label small_loop;
3941   // Check if count is negative (dead code) or zero.
3942   // Note, count uses 64bit in 64 bit VM.
3943   cmp_and_brx_short(count, 0, Assembler::lessEqual, Assembler::pn, Ldone);
3944 
3945   // Use BIS zeroing only for big arrays since it requires membar.
3946   if (Assembler::is_simm13(block_zero_size)) { // &lt; 4096
3947     cmp(count, block_zero_size);
3948   } else {
3949     set(block_zero_size, temp);
3950     cmp(count, temp);
3951   }
3952   br(Assembler::lessUnsigned, false, Assembler::pt, small_loop);
3953   delayed()-&gt;add(to, count, end);
3954 
3955   // Note: size is &gt;= three (32 bytes) cache lines.
3956 
3957   // Clean the beginning of space up to next cache line.
3958   for (int offs = 0; offs &lt; cache_line_size; offs += 8) {
3959     stx(G0, to, offs);
3960   }
3961 
3962   // align to next cache line
3963   add(to, cache_line_size, to);
3964   and3(to, -cache_line_size, to);
3965 
3966   // Note: size left &gt;= two (32 bytes) cache lines.
3967 
3968   // BIS should not be used to zero tail (64 bytes)
3969   // to avoid zeroing a header of the following object.
3970   sub(end, (cache_line_size*2)-8, end);
3971 
3972   Label bis_loop;
3973   bind(bis_loop);
3974   stxa(G0, to, G0, Assembler::ASI_ST_BLKINIT_PRIMARY);
3975   add(to, cache_line_size, to);
3976   cmp_and_brx_short(to, end, Assembler::lessUnsigned, Assembler::pt, bis_loop);
3977 
3978   // BIS needs membar.
3979   membar(Assembler::StoreLoad);
3980 
3981   add(end, (cache_line_size*2)-8, end); // restore end
3982   cmp_and_brx_short(to, end, Assembler::greaterEqualUnsigned, Assembler::pn, Ldone);
3983 
3984   // Clean the tail.
3985   bind(small_loop);
3986   stx(G0, to, 0);
3987   add(to, 8, to);
3988   cmp_and_brx_short(to, end, Assembler::lessUnsigned, Assembler::pt, small_loop);
3989   nop(); // Separate short branches
3990 }
3991 
3992 /**
3993  * Update CRC-32[C] with a byte value according to constants in table
3994  *
3995  * @param [in,out]crc   Register containing the crc.
3996  * @param [in]val       Register containing the byte to fold into the CRC.
3997  * @param [in]table     Register containing the table of crc constants.
3998  *
3999  * uint32_t crc;
4000  * val = crc_table[(val ^ crc) &amp; 0xFF];
4001  * crc = val ^ (crc &gt;&gt; 8);
4002  */
4003 void MacroAssembler::update_byte_crc32(Register crc, Register val, Register table) {
4004   xor3(val, crc, val);
4005   and3(val, 0xFF, val);
4006   sllx(val, 2, val);
4007   lduw(table, val, val);
4008   srlx(crc, 8, crc);
4009   xor3(val, crc, crc);
4010 }
4011 
4012 // Reverse byte order of lower 32 bits, assuming upper 32 bits all zeros
4013 void MacroAssembler::reverse_bytes_32(Register src, Register dst, Register tmp) {
4014     srlx(src, 24, dst);
4015 
4016     sllx(src, 32+8, tmp);
4017     srlx(tmp, 32+24, tmp);
4018     sllx(tmp, 8, tmp);
4019     or3(dst, tmp, dst);
4020 
4021     sllx(src, 32+16, tmp);
4022     srlx(tmp, 32+24, tmp);
4023     sllx(tmp, 16, tmp);
4024     or3(dst, tmp, dst);
4025 
4026     sllx(src, 32+24, tmp);
4027     srlx(tmp, 32, tmp);
4028     or3(dst, tmp, dst);
4029 }
4030 
4031 void MacroAssembler::movitof_revbytes(Register src, FloatRegister dst, Register tmp1, Register tmp2) {
4032   reverse_bytes_32(src, tmp1, tmp2);
4033   movxtod(tmp1, dst);
4034 }
4035 
4036 void MacroAssembler::movftoi_revbytes(FloatRegister src, Register dst, Register tmp1, Register tmp2) {
4037   movdtox(src, tmp1);
4038   reverse_bytes_32(tmp1, dst, tmp2);
4039 }
4040 
4041 void MacroAssembler::fold_128bit_crc32(Register xcrc_hi, Register xcrc_lo, Register xK_hi, Register xK_lo, Register xtmp_hi, Register xtmp_lo, Register buf, int offset) {
4042   xmulx(xcrc_hi, xK_hi, xtmp_lo);
4043   xmulxhi(xcrc_hi, xK_hi, xtmp_hi);
4044   xmulxhi(xcrc_lo, xK_lo, xcrc_hi);
4045   xmulx(xcrc_lo, xK_lo, xcrc_lo);
4046   xor3(xcrc_lo, xtmp_lo, xcrc_lo);
4047   xor3(xcrc_hi, xtmp_hi, xcrc_hi);
4048   ldxl(buf, G0, xtmp_lo);
4049   inc(buf, 8);
4050   ldxl(buf, G0, xtmp_hi);
4051   inc(buf, 8);
4052   xor3(xcrc_lo, xtmp_lo, xcrc_lo);
4053   xor3(xcrc_hi, xtmp_hi, xcrc_hi);
4054 }
4055 
4056 void MacroAssembler::fold_128bit_crc32(Register xcrc_hi, Register xcrc_lo, Register xK_hi, Register xK_lo, Register xtmp_hi, Register xtmp_lo, Register xbuf_hi, Register xbuf_lo) {
4057   mov(xcrc_lo, xtmp_lo);
4058   mov(xcrc_hi, xtmp_hi);
4059   xmulx(xtmp_hi, xK_hi, xtmp_lo);
4060   xmulxhi(xtmp_hi, xK_hi, xtmp_hi);
4061   xmulxhi(xcrc_lo, xK_lo, xcrc_hi);
4062   xmulx(xcrc_lo, xK_lo, xcrc_lo);
4063   xor3(xcrc_lo, xbuf_lo, xcrc_lo);
4064   xor3(xcrc_hi, xbuf_hi, xcrc_hi);
4065   xor3(xcrc_lo, xtmp_lo, xcrc_lo);
4066   xor3(xcrc_hi, xtmp_hi, xcrc_hi);
4067 }
4068 
4069 void MacroAssembler::fold_8bit_crc32(Register xcrc, Register table, Register xtmp, Register tmp) {
4070   and3(xcrc, 0xFF, tmp);
4071   sllx(tmp, 2, tmp);
4072   lduw(table, tmp, xtmp);
4073   srlx(xcrc, 8, xcrc);
4074   xor3(xtmp, xcrc, xcrc);
4075 }
4076 
4077 void MacroAssembler::fold_8bit_crc32(Register crc, Register table, Register tmp) {
4078   and3(crc, 0xFF, tmp);
4079   srlx(crc, 8, crc);
4080   sllx(tmp, 2, tmp);
4081   lduw(table, tmp, tmp);
4082   xor3(tmp, crc, crc);
4083 }
4084 
4085 #define CRC32_TMP_REG_NUM 18
4086 
4087 #define CRC32_CONST_64  0x163cd6124
4088 #define CRC32_CONST_96  0x0ccaa009e
4089 #define CRC32_CONST_160 0x1751997d0
4090 #define CRC32_CONST_480 0x1c6e41596
4091 #define CRC32_CONST_544 0x154442bd4
4092 
4093 void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len, Register table) {
4094 
4095   Label L_cleanup_loop, L_cleanup_check, L_align_loop, L_align_check;
4096   Label L_main_loop_prologue;
4097   Label L_fold_512b, L_fold_512b_loop, L_fold_128b;
4098   Label L_fold_tail, L_fold_tail_loop;
4099   Label L_8byte_fold_check;
4100 
4101   const Register tmp[CRC32_TMP_REG_NUM] = {L0, L1, L2, L3, L4, L5, L6, G1, I0, I1, I2, I3, I4, I5, I7, O4, O5, G3};
4102 
4103   Register const_64  = tmp[CRC32_TMP_REG_NUM-1];
4104   Register const_96  = tmp[CRC32_TMP_REG_NUM-1];
4105   Register const_160 = tmp[CRC32_TMP_REG_NUM-2];
4106   Register const_480 = tmp[CRC32_TMP_REG_NUM-1];
4107   Register const_544 = tmp[CRC32_TMP_REG_NUM-2];
4108 
4109   set(ExternalAddress(StubRoutines::crc_table_addr()), table);
4110 
4111   not1(crc); // ~c
4112   clruwu(crc); // clear upper 32 bits of crc
4113 
4114   // Check if below cutoff, proceed directly to cleanup code
4115   mov(31, G4);
4116   cmp_and_br_short(len, G4, Assembler::lessEqualUnsigned, Assembler::pt, L_cleanup_check);
4117 
4118   // Align buffer to 8 byte boundry
4119   mov(8, O5);
4120   and3(buf, 0x7, O4);
4121   sub(O5, O4, O5);
4122   and3(O5, 0x7, O5);
4123   sub(len, O5, len);
4124   ba(L_align_check);
4125   delayed()-&gt;nop();
4126 
4127   // Alignment loop, table look up method for up to 7 bytes
4128   bind(L_align_loop);
4129   ldub(buf, 0, O4);
4130   inc(buf);
4131   dec(O5);
4132   xor3(O4, crc, O4);
4133   and3(O4, 0xFF, O4);
4134   sllx(O4, 2, O4);
4135   lduw(table, O4, O4);
4136   srlx(crc, 8, crc);
4137   xor3(O4, crc, crc);
4138   bind(L_align_check);
4139   nop();
4140   cmp_and_br_short(O5, 0, Assembler::notEqual, Assembler::pt, L_align_loop);
4141 
4142   // Aligned on 64-bit (8-byte) boundry at this point
4143   // Check if still above cutoff (31-bytes)
4144   mov(31, G4);
4145   cmp_and_br_short(len, G4, Assembler::lessEqualUnsigned, Assembler::pt, L_cleanup_check);
4146   // At least 32 bytes left to process
4147 
4148   // Free up registers by storing them to FP registers
4149   for (int i = 0; i &lt; CRC32_TMP_REG_NUM; i++) {
4150     movxtod(tmp[i], as_FloatRegister(2*i));
4151   }
4152 
4153   // Determine which loop to enter
4154   // Shared prologue
4155   ldxl(buf, G0, tmp[0]);
4156   inc(buf, 8);
4157   ldxl(buf, G0, tmp[1]);
4158   inc(buf, 8);
4159   xor3(tmp[0], crc, tmp[0]); // Fold CRC into first few bytes
4160   and3(crc, 0, crc); // Clear out the crc register
4161   // Main loop needs 128-bytes at least
4162   mov(128, G4);
4163   mov(64, tmp[2]);
4164   cmp_and_br_short(len, G4, Assembler::greaterEqualUnsigned, Assembler::pt, L_main_loop_prologue);
4165   // Less than 64 bytes
4166   nop();
4167   cmp_and_br_short(len, tmp[2], Assembler::lessUnsigned, Assembler::pt, L_fold_tail);
4168   // Between 64 and 127 bytes
4169   set64(CRC32_CONST_96,  const_96,  tmp[8]);
4170   set64(CRC32_CONST_160, const_160, tmp[9]);
4171   fold_128bit_crc32(tmp[1], tmp[0], const_96, const_160, tmp[2], tmp[3], buf, 0);
4172   fold_128bit_crc32(tmp[1], tmp[0], const_96, const_160, tmp[4], tmp[5], buf, 16);
4173   fold_128bit_crc32(tmp[1], tmp[0], const_96, const_160, tmp[6], tmp[7], buf, 32);
4174   dec(len, 48);
4175   ba(L_fold_tail);
4176   delayed()-&gt;nop();
4177 
4178   bind(L_main_loop_prologue);
4179   for (int i = 2; i &lt; 8; i++) {
4180     ldxl(buf, G0, tmp[i]);
4181     inc(buf, 8);
4182   }
4183 
4184   // Fold total 512 bits of polynomial on each iteration,
4185   // 128 bits per each of 4 parallel streams
4186   set64(CRC32_CONST_480, const_480, tmp[8]);
4187   set64(CRC32_CONST_544, const_544, tmp[9]);
4188 
4189   mov(128, G4);
4190   bind(L_fold_512b_loop);
4191   fold_128bit_crc32(tmp[1], tmp[0], const_480, const_544, tmp[9],  tmp[8],  buf,  0);
4192   fold_128bit_crc32(tmp[3], tmp[2], const_480, const_544, tmp[11], tmp[10], buf, 16);
4193   fold_128bit_crc32(tmp[5], tmp[4], const_480, const_544, tmp[13], tmp[12], buf, 32);
4194   fold_128bit_crc32(tmp[7], tmp[6], const_480, const_544, tmp[15], tmp[14], buf, 64);
4195   dec(len, 64);
4196   cmp_and_br_short(len, G4, Assembler::greaterEqualUnsigned, Assembler::pt, L_fold_512b_loop);
4197 
4198   // Fold 512 bits to 128 bits
4199   bind(L_fold_512b);
4200   set64(CRC32_CONST_96,  const_96,  tmp[8]);
4201   set64(CRC32_CONST_160, const_160, tmp[9]);
4202 
4203   fold_128bit_crc32(tmp[1], tmp[0], const_96, const_160, tmp[8], tmp[9], tmp[3], tmp[2]);
4204   fold_128bit_crc32(tmp[1], tmp[0], const_96, const_160, tmp[8], tmp[9], tmp[5], tmp[4]);
4205   fold_128bit_crc32(tmp[1], tmp[0], const_96, const_160, tmp[8], tmp[9], tmp[7], tmp[6]);
4206   dec(len, 48);
4207 
4208   // Fold the rest of 128 bits data chunks
4209   bind(L_fold_tail);
4210   mov(32, G4);
4211   cmp_and_br_short(len, G4, Assembler::lessEqualUnsigned, Assembler::pt, L_fold_128b);
4212 
4213   set64(CRC32_CONST_96,  const_96,  tmp[8]);
4214   set64(CRC32_CONST_160, const_160, tmp[9]);
4215 
4216   bind(L_fold_tail_loop);
4217   fold_128bit_crc32(tmp[1], tmp[0], const_96, const_160, tmp[2], tmp[3], buf, 0);
4218   sub(len, 16, len);
4219   cmp_and_br_short(len, G4, Assembler::greaterEqualUnsigned, Assembler::pt, L_fold_tail_loop);
4220 
4221   // Fold the 128 bits in tmps 0 - 1 into tmp 1
4222   bind(L_fold_128b);
4223 
4224   set64(CRC32_CONST_64, const_64, tmp[4]);
4225 
4226   xmulx(const_64, tmp[0], tmp[2]);
4227   xmulxhi(const_64, tmp[0], tmp[3]);
4228 
4229   srl(tmp[2], G0, tmp[4]);
4230   xmulx(const_64, tmp[4], tmp[4]);
4231 
4232   srlx(tmp[2], 32, tmp[2]);
4233   sllx(tmp[3], 32, tmp[3]);
4234   or3(tmp[2], tmp[3], tmp[2]);
4235 
4236   xor3(tmp[4], tmp[1], tmp[4]);
4237   xor3(tmp[4], tmp[2], tmp[1]);
4238   dec(len, 8);
4239 
4240   // Use table lookup for the 8 bytes left in tmp[1]
4241   dec(len, 8);
4242 
4243   // 8 8-bit folds to compute 32-bit CRC.
4244   for (int j = 0; j &lt; 4; j++) {
4245     fold_8bit_crc32(tmp[1], table, tmp[2], tmp[3]);
4246   }
4247   srl(tmp[1], G0, crc); // move 32 bits to general register
4248   for (int j = 0; j &lt; 4; j++) {
4249     fold_8bit_crc32(crc, table, tmp[3]);
4250   }
4251 
4252   bind(L_8byte_fold_check);
4253 
4254   // Restore int registers saved in FP registers
4255   for (int i = 0; i &lt; CRC32_TMP_REG_NUM; i++) {
4256     movdtox(as_FloatRegister(2*i), tmp[i]);
4257   }
4258 
4259   ba(L_cleanup_check);
4260   delayed()-&gt;nop();
4261 
4262   // Table look-up method for the remaining few bytes
4263   bind(L_cleanup_loop);
4264   ldub(buf, 0, O4);
4265   inc(buf);
4266   dec(len);
4267   xor3(O4, crc, O4);
4268   and3(O4, 0xFF, O4);
4269   sllx(O4, 2, O4);
4270   lduw(table, O4, O4);
4271   srlx(crc, 8, crc);
4272   xor3(O4, crc, crc);
4273   bind(L_cleanup_check);
4274   nop();
4275   cmp_and_br_short(len, 0, Assembler::greaterUnsigned, Assembler::pt, L_cleanup_loop);
4276 
4277   not1(crc);
4278 }
4279 
4280 #define CHUNK_LEN   128          /* 128 x 8B = 1KB */
4281 #define CHUNK_K1    0x1307a0206  /* reverseBits(pow(x, CHUNK_LEN*8*8*3 - 32) mod P(x)) &lt;&lt; 1 */
4282 #define CHUNK_K2    0x1a0f717c4  /* reverseBits(pow(x, CHUNK_LEN*8*8*2 - 32) mod P(x)) &lt;&lt; 1 */
4283 #define CHUNK_K3    0x0170076fa  /* reverseBits(pow(x, CHUNK_LEN*8*8*1 - 32) mod P(x)) &lt;&lt; 1 */
4284 
4285 void MacroAssembler::kernel_crc32c(Register crc, Register buf, Register len, Register table) {
4286 
4287   Label L_crc32c_head, L_crc32c_aligned;
4288   Label L_crc32c_parallel, L_crc32c_parallel_loop;
4289   Label L_crc32c_serial, L_crc32c_x32_loop, L_crc32c_x8, L_crc32c_x8_loop;
4290   Label L_crc32c_done, L_crc32c_tail, L_crc32c_return;
4291 
4292   set(ExternalAddress(StubRoutines::crc32c_table_addr()), table);
4293 
4294   cmp_and_br_short(len, 0, Assembler::lessEqual, Assembler::pn, L_crc32c_return);
4295 
4296   // clear upper 32 bits of crc
4297   clruwu(crc);
4298 
4299   and3(buf, 7, G4);
4300   cmp_and_brx_short(G4, 0, Assembler::equal, Assembler::pt, L_crc32c_aligned);
4301 
4302   mov(8, G1);
4303   sub(G1, G4, G4);
4304 
4305   // ------ process the misaligned head (7 bytes or less) ------
4306   bind(L_crc32c_head);
4307 
4308   // crc = (crc &gt;&gt;&gt; 8) ^ byteTable[(crc ^ b) &amp; 0xFF];
4309   ldub(buf, 0, G1);
4310   update_byte_crc32(crc, G1, table);
4311 
4312   inc(buf);
4313   dec(len);
4314   cmp_and_br_short(len, 0, Assembler::equal, Assembler::pn, L_crc32c_return);
4315   dec(G4);
4316   cmp_and_br_short(G4, 0, Assembler::greater, Assembler::pt, L_crc32c_head);
4317 
4318   // ------ process the 8-byte-aligned body ------
4319   bind(L_crc32c_aligned);
4320   nop();
4321   cmp_and_br_short(len, 8, Assembler::less, Assembler::pn, L_crc32c_tail);
4322 
4323   // reverse the byte order of lower 32 bits to big endian, and move to FP side
4324   movitof_revbytes(crc, F0, G1, G3);
4325 
4326   set(CHUNK_LEN*8*4, G4);
4327   cmp_and_br_short(len, G4, Assembler::less, Assembler::pt, L_crc32c_serial);
4328 
4329   // ------ process four 1KB chunks in parallel ------
4330   bind(L_crc32c_parallel);
4331 
4332   fzero(FloatRegisterImpl::D, F2);
4333   fzero(FloatRegisterImpl::D, F4);
4334   fzero(FloatRegisterImpl::D, F6);
4335 
4336   mov(CHUNK_LEN - 1, G4);
4337   bind(L_crc32c_parallel_loop);
4338   // schedule ldf&#39;s ahead of crc32c&#39;s to hide the load-use latency
4339   ldf(FloatRegisterImpl::D, buf, 0,            F8);
4340   ldf(FloatRegisterImpl::D, buf, CHUNK_LEN*8,  F10);
4341   ldf(FloatRegisterImpl::D, buf, CHUNK_LEN*16, F12);
4342   ldf(FloatRegisterImpl::D, buf, CHUNK_LEN*24, F14);
4343   crc32c(F0, F8,  F0);
4344   crc32c(F2, F10, F2);
4345   crc32c(F4, F12, F4);
4346   crc32c(F6, F14, F6);
4347   inc(buf, 8);
4348   dec(G4);
4349   cmp_and_br_short(G4, 0, Assembler::greater, Assembler::pt, L_crc32c_parallel_loop);
4350 
4351   ldf(FloatRegisterImpl::D, buf, 0,            F8);
4352   ldf(FloatRegisterImpl::D, buf, CHUNK_LEN*8,  F10);
4353   ldf(FloatRegisterImpl::D, buf, CHUNK_LEN*16, F12);
4354   crc32c(F0, F8,  F0);
4355   crc32c(F2, F10, F2);
4356   crc32c(F4, F12, F4);
4357 
4358   inc(buf, CHUNK_LEN*24);
4359   ldfl(FloatRegisterImpl::D, buf, G0, F14);  // load in little endian
4360   inc(buf, 8);
4361 
4362   prefetch(buf, 0,            Assembler::severalReads);
4363   prefetch(buf, CHUNK_LEN*8,  Assembler::severalReads);
4364   prefetch(buf, CHUNK_LEN*16, Assembler::severalReads);
4365   prefetch(buf, CHUNK_LEN*24, Assembler::severalReads);
4366 
4367   // move to INT side, and reverse the byte order of lower 32 bits to little endian
4368   movftoi_revbytes(F0, O4, G1, G4);
4369   movftoi_revbytes(F2, O5, G1, G4);
4370   movftoi_revbytes(F4, G5, G1, G4);
4371 
4372   // combine the results of 4 chunks
4373   set64(CHUNK_K1, G3, G1);
4374   xmulx(O4, G3, O4);
4375   set64(CHUNK_K2, G3, G1);
4376   xmulx(O5, G3, O5);
4377   set64(CHUNK_K3, G3, G1);
4378   xmulx(G5, G3, G5);
4379 
4380   movdtox(F14, G4);
4381   xor3(O4, O5, O5);
4382   xor3(G5, O5, O5);
4383   xor3(G4, O5, O5);
4384 
4385   // reverse the byte order to big endian, via stack, and move to FP side
4386   // TODO: use new revb instruction
4387   add(SP, -8, G1);
4388   srlx(G1, 3, G1);
4389   sllx(G1, 3, G1);
4390   stx(O5, G1, G0);
4391   ldfl(FloatRegisterImpl::D, G1, G0, F2);  // load in little endian
4392 
4393   crc32c(F6, F2, F0);
4394 
4395   set(CHUNK_LEN*8*4, G4);
4396   sub(len, G4, len);
4397   cmp_and_br_short(len, G4, Assembler::greaterEqual, Assembler::pt, L_crc32c_parallel);
4398   nop();
4399   cmp_and_br_short(len, 0, Assembler::equal, Assembler::pt, L_crc32c_done);
4400 
4401   bind(L_crc32c_serial);
4402 
4403   mov(32, G4);
4404   cmp_and_br_short(len, G4, Assembler::less, Assembler::pn, L_crc32c_x8);
4405 
4406   // ------ process 32B chunks ------
4407   bind(L_crc32c_x32_loop);
4408   ldf(FloatRegisterImpl::D, buf, 0, F2);
4409   crc32c(F0, F2, F0);
4410   ldf(FloatRegisterImpl::D, buf, 8, F2);
4411   crc32c(F0, F2, F0);
4412   ldf(FloatRegisterImpl::D, buf, 16, F2);
4413   crc32c(F0, F2, F0);
4414   ldf(FloatRegisterImpl::D, buf, 24, F2);
4415   inc(buf, 32);
4416   crc32c(F0, F2, F0);
4417   dec(len, 32);
4418   cmp_and_br_short(len, G4, Assembler::greaterEqual, Assembler::pt, L_crc32c_x32_loop);
4419 
4420   bind(L_crc32c_x8);
4421   nop();
4422   cmp_and_br_short(len, 8, Assembler::less, Assembler::pt, L_crc32c_done);
4423 
4424   // ------ process 8B chunks ------
4425   bind(L_crc32c_x8_loop);
4426   ldf(FloatRegisterImpl::D, buf, 0, F2);
4427   inc(buf, 8);
4428   crc32c(F0, F2, F0);
4429   dec(len, 8);
4430   cmp_and_br_short(len, 8, Assembler::greaterEqual, Assembler::pt, L_crc32c_x8_loop);
4431 
4432   bind(L_crc32c_done);
4433 
4434   // move to INT side, and reverse the byte order of lower 32 bits to little endian
4435   movftoi_revbytes(F0, crc, G1, G3);
4436 
4437   cmp_and_br_short(len, 0, Assembler::equal, Assembler::pt, L_crc32c_return);
4438 
4439   // ------ process the misaligned tail (7 bytes or less) ------
4440   bind(L_crc32c_tail);
4441 
4442   // crc = (crc &gt;&gt;&gt; 8) ^ byteTable[(crc ^ b) &amp; 0xFF];
4443   ldub(buf, 0, G1);
4444   update_byte_crc32(crc, G1, table);
4445 
4446   inc(buf);
4447   dec(len);
4448   cmp_and_br_short(len, 0, Assembler::greater, Assembler::pt, L_crc32c_tail);
4449 
4450   bind(L_crc32c_return);
4451   nop();
4452 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/sparc/sparc.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
    1 //
    2 // Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
   23 //
   24 
   25 // SPARC Architecture Description File
   26 
   27 //----------REGISTER DEFINITION BLOCK------------------------------------------
   28 // This information is used by the matcher and the register allocator to
   29 // describe individual registers and classes of registers within the target
   30 // archtecture.
   31 register %{
   32 //----------Architecture Description Register Definitions----------------------
   33 // General Registers
   34 // &quot;reg_def&quot;  name ( register save type, C convention save type,
   35 //                   ideal register type, encoding, vm name );
   36 // Register Save Types:
   37 //
   38 // NS  = No-Save:       The register allocator assumes that these registers
   39 //                      can be used without saving upon entry to the method, &amp;
   40 //                      that they do not need to be saved at call sites.
   41 //
   42 // SOC = Save-On-Call:  The register allocator assumes that these registers
   43 //                      can be used without saving upon entry to the method,
   44 //                      but that they must be saved at call sites.
   45 //
   46 // SOE = Save-On-Entry: The register allocator assumes that these registers
   47 //                      must be saved before using them upon entry to the
   48 //                      method, but they do not need to be saved at call
   49 //                      sites.
   50 //
   51 // AS  = Always-Save:   The register allocator assumes that these registers
   52 //                      must be saved before using them upon entry to the
   53 //                      method, &amp; that they must be saved at call sites.
   54 //
   55 // Ideal Register Type is used to determine how to save &amp; restore a
   56 // register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   57 // spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
   58 //
   59 // The encoding number is the actual bit-pattern placed into the opcodes.
   60 
   61 
   62 // ----------------------------
   63 // Integer/Long Registers
   64 // ----------------------------
   65 
   66 // Need to expose the hi/lo aspect of 64-bit registers
   67 // This register set is used for both the 64-bit build and
   68 // the 32-bit build with 1-register longs.
   69 
   70 // Global Registers 0-7
   71 reg_def R_G0H( NS,  NS, Op_RegI,128, G0-&gt;as_VMReg()-&gt;next());
   72 reg_def R_G0 ( NS,  NS, Op_RegI,  0, G0-&gt;as_VMReg());
   73 reg_def R_G1H(SOC, SOC, Op_RegI,129, G1-&gt;as_VMReg()-&gt;next());
   74 reg_def R_G1 (SOC, SOC, Op_RegI,  1, G1-&gt;as_VMReg());
   75 reg_def R_G2H( NS,  NS, Op_RegI,130, G2-&gt;as_VMReg()-&gt;next());
   76 reg_def R_G2 ( NS,  NS, Op_RegI,  2, G2-&gt;as_VMReg());
   77 reg_def R_G3H(SOC, SOC, Op_RegI,131, G3-&gt;as_VMReg()-&gt;next());
   78 reg_def R_G3 (SOC, SOC, Op_RegI,  3, G3-&gt;as_VMReg());
   79 reg_def R_G4H(SOC, SOC, Op_RegI,132, G4-&gt;as_VMReg()-&gt;next());
   80 reg_def R_G4 (SOC, SOC, Op_RegI,  4, G4-&gt;as_VMReg());
   81 reg_def R_G5H(SOC, SOC, Op_RegI,133, G5-&gt;as_VMReg()-&gt;next());
   82 reg_def R_G5 (SOC, SOC, Op_RegI,  5, G5-&gt;as_VMReg());
   83 reg_def R_G6H( NS,  NS, Op_RegI,134, G6-&gt;as_VMReg()-&gt;next());
   84 reg_def R_G6 ( NS,  NS, Op_RegI,  6, G6-&gt;as_VMReg());
   85 reg_def R_G7H( NS,  NS, Op_RegI,135, G7-&gt;as_VMReg()-&gt;next());
   86 reg_def R_G7 ( NS,  NS, Op_RegI,  7, G7-&gt;as_VMReg());
   87 
   88 // Output Registers 0-7
   89 reg_def R_O0H(SOC, SOC, Op_RegI,136, O0-&gt;as_VMReg()-&gt;next());
   90 reg_def R_O0 (SOC, SOC, Op_RegI,  8, O0-&gt;as_VMReg());
   91 reg_def R_O1H(SOC, SOC, Op_RegI,137, O1-&gt;as_VMReg()-&gt;next());
   92 reg_def R_O1 (SOC, SOC, Op_RegI,  9, O1-&gt;as_VMReg());
   93 reg_def R_O2H(SOC, SOC, Op_RegI,138, O2-&gt;as_VMReg()-&gt;next());
   94 reg_def R_O2 (SOC, SOC, Op_RegI, 10, O2-&gt;as_VMReg());
   95 reg_def R_O3H(SOC, SOC, Op_RegI,139, O3-&gt;as_VMReg()-&gt;next());
   96 reg_def R_O3 (SOC, SOC, Op_RegI, 11, O3-&gt;as_VMReg());
   97 reg_def R_O4H(SOC, SOC, Op_RegI,140, O4-&gt;as_VMReg()-&gt;next());
   98 reg_def R_O4 (SOC, SOC, Op_RegI, 12, O4-&gt;as_VMReg());
   99 reg_def R_O5H(SOC, SOC, Op_RegI,141, O5-&gt;as_VMReg()-&gt;next());
  100 reg_def R_O5 (SOC, SOC, Op_RegI, 13, O5-&gt;as_VMReg());
  101 reg_def R_SPH( NS,  NS, Op_RegI,142, SP-&gt;as_VMReg()-&gt;next());
  102 reg_def R_SP ( NS,  NS, Op_RegI, 14, SP-&gt;as_VMReg());
  103 reg_def R_O7H(SOC, SOC, Op_RegI,143, O7-&gt;as_VMReg()-&gt;next());
  104 reg_def R_O7 (SOC, SOC, Op_RegI, 15, O7-&gt;as_VMReg());
  105 
  106 // Local Registers 0-7
  107 reg_def R_L0H( NS,  NS, Op_RegI,144, L0-&gt;as_VMReg()-&gt;next());
  108 reg_def R_L0 ( NS,  NS, Op_RegI, 16, L0-&gt;as_VMReg());
  109 reg_def R_L1H( NS,  NS, Op_RegI,145, L1-&gt;as_VMReg()-&gt;next());
  110 reg_def R_L1 ( NS,  NS, Op_RegI, 17, L1-&gt;as_VMReg());
  111 reg_def R_L2H( NS,  NS, Op_RegI,146, L2-&gt;as_VMReg()-&gt;next());
  112 reg_def R_L2 ( NS,  NS, Op_RegI, 18, L2-&gt;as_VMReg());
  113 reg_def R_L3H( NS,  NS, Op_RegI,147, L3-&gt;as_VMReg()-&gt;next());
  114 reg_def R_L3 ( NS,  NS, Op_RegI, 19, L3-&gt;as_VMReg());
  115 reg_def R_L4H( NS,  NS, Op_RegI,148, L4-&gt;as_VMReg()-&gt;next());
  116 reg_def R_L4 ( NS,  NS, Op_RegI, 20, L4-&gt;as_VMReg());
  117 reg_def R_L5H( NS,  NS, Op_RegI,149, L5-&gt;as_VMReg()-&gt;next());
  118 reg_def R_L5 ( NS,  NS, Op_RegI, 21, L5-&gt;as_VMReg());
  119 reg_def R_L6H( NS,  NS, Op_RegI,150, L6-&gt;as_VMReg()-&gt;next());
  120 reg_def R_L6 ( NS,  NS, Op_RegI, 22, L6-&gt;as_VMReg());
  121 reg_def R_L7H( NS,  NS, Op_RegI,151, L7-&gt;as_VMReg()-&gt;next());
  122 reg_def R_L7 ( NS,  NS, Op_RegI, 23, L7-&gt;as_VMReg());
  123 
  124 // Input Registers 0-7
  125 reg_def R_I0H( NS,  NS, Op_RegI,152, I0-&gt;as_VMReg()-&gt;next());
  126 reg_def R_I0 ( NS,  NS, Op_RegI, 24, I0-&gt;as_VMReg());
  127 reg_def R_I1H( NS,  NS, Op_RegI,153, I1-&gt;as_VMReg()-&gt;next());
  128 reg_def R_I1 ( NS,  NS, Op_RegI, 25, I1-&gt;as_VMReg());
  129 reg_def R_I2H( NS,  NS, Op_RegI,154, I2-&gt;as_VMReg()-&gt;next());
  130 reg_def R_I2 ( NS,  NS, Op_RegI, 26, I2-&gt;as_VMReg());
  131 reg_def R_I3H( NS,  NS, Op_RegI,155, I3-&gt;as_VMReg()-&gt;next());
  132 reg_def R_I3 ( NS,  NS, Op_RegI, 27, I3-&gt;as_VMReg());
  133 reg_def R_I4H( NS,  NS, Op_RegI,156, I4-&gt;as_VMReg()-&gt;next());
  134 reg_def R_I4 ( NS,  NS, Op_RegI, 28, I4-&gt;as_VMReg());
  135 reg_def R_I5H( NS,  NS, Op_RegI,157, I5-&gt;as_VMReg()-&gt;next());
  136 reg_def R_I5 ( NS,  NS, Op_RegI, 29, I5-&gt;as_VMReg());
  137 reg_def R_FPH( NS,  NS, Op_RegI,158, FP-&gt;as_VMReg()-&gt;next());
  138 reg_def R_FP ( NS,  NS, Op_RegI, 30, FP-&gt;as_VMReg());
  139 reg_def R_I7H( NS,  NS, Op_RegI,159, I7-&gt;as_VMReg()-&gt;next());
  140 reg_def R_I7 ( NS,  NS, Op_RegI, 31, I7-&gt;as_VMReg());
  141 
  142 // ----------------------------
  143 // Float/Double Registers
  144 // ----------------------------
  145 
  146 // Float Registers
  147 reg_def R_F0 ( SOC, SOC, Op_RegF,  0, F0-&gt;as_VMReg());
  148 reg_def R_F1 ( SOC, SOC, Op_RegF,  1, F1-&gt;as_VMReg());
  149 reg_def R_F2 ( SOC, SOC, Op_RegF,  2, F2-&gt;as_VMReg());
  150 reg_def R_F3 ( SOC, SOC, Op_RegF,  3, F3-&gt;as_VMReg());
  151 reg_def R_F4 ( SOC, SOC, Op_RegF,  4, F4-&gt;as_VMReg());
  152 reg_def R_F5 ( SOC, SOC, Op_RegF,  5, F5-&gt;as_VMReg());
  153 reg_def R_F6 ( SOC, SOC, Op_RegF,  6, F6-&gt;as_VMReg());
  154 reg_def R_F7 ( SOC, SOC, Op_RegF,  7, F7-&gt;as_VMReg());
  155 reg_def R_F8 ( SOC, SOC, Op_RegF,  8, F8-&gt;as_VMReg());
  156 reg_def R_F9 ( SOC, SOC, Op_RegF,  9, F9-&gt;as_VMReg());
  157 reg_def R_F10( SOC, SOC, Op_RegF, 10, F10-&gt;as_VMReg());
  158 reg_def R_F11( SOC, SOC, Op_RegF, 11, F11-&gt;as_VMReg());
  159 reg_def R_F12( SOC, SOC, Op_RegF, 12, F12-&gt;as_VMReg());
  160 reg_def R_F13( SOC, SOC, Op_RegF, 13, F13-&gt;as_VMReg());
  161 reg_def R_F14( SOC, SOC, Op_RegF, 14, F14-&gt;as_VMReg());
  162 reg_def R_F15( SOC, SOC, Op_RegF, 15, F15-&gt;as_VMReg());
  163 reg_def R_F16( SOC, SOC, Op_RegF, 16, F16-&gt;as_VMReg());
  164 reg_def R_F17( SOC, SOC, Op_RegF, 17, F17-&gt;as_VMReg());
  165 reg_def R_F18( SOC, SOC, Op_RegF, 18, F18-&gt;as_VMReg());
  166 reg_def R_F19( SOC, SOC, Op_RegF, 19, F19-&gt;as_VMReg());
  167 reg_def R_F20( SOC, SOC, Op_RegF, 20, F20-&gt;as_VMReg());
  168 reg_def R_F21( SOC, SOC, Op_RegF, 21, F21-&gt;as_VMReg());
  169 reg_def R_F22( SOC, SOC, Op_RegF, 22, F22-&gt;as_VMReg());
  170 reg_def R_F23( SOC, SOC, Op_RegF, 23, F23-&gt;as_VMReg());
  171 reg_def R_F24( SOC, SOC, Op_RegF, 24, F24-&gt;as_VMReg());
  172 reg_def R_F25( SOC, SOC, Op_RegF, 25, F25-&gt;as_VMReg());
  173 reg_def R_F26( SOC, SOC, Op_RegF, 26, F26-&gt;as_VMReg());
  174 reg_def R_F27( SOC, SOC, Op_RegF, 27, F27-&gt;as_VMReg());
  175 reg_def R_F28( SOC, SOC, Op_RegF, 28, F28-&gt;as_VMReg());
  176 reg_def R_F29( SOC, SOC, Op_RegF, 29, F29-&gt;as_VMReg());
  177 reg_def R_F30( SOC, SOC, Op_RegF, 30, F30-&gt;as_VMReg());
  178 reg_def R_F31( SOC, SOC, Op_RegF, 31, F31-&gt;as_VMReg());
  179 
  180 // Double Registers
  181 // The rules of ADL require that double registers be defined in pairs.
  182 // Each pair must be two 32-bit values, but not necessarily a pair of
  183 // single float registers.  In each pair, ADLC-assigned register numbers
  184 // must be adjacent, with the lower number even.  Finally, when the
  185 // CPU stores such a register pair to memory, the word associated with
  186 // the lower ADLC-assigned number must be stored to the lower address.
  187 
  188 // These definitions specify the actual bit encodings of the sparc
  189 // double fp register numbers.  FloatRegisterImpl in register_sparc.hpp
  190 // wants 0-63, so we have to convert every time we want to use fp regs
  191 // with the macroassembler, using reg_to_DoubleFloatRegister_object().
  192 // 255 is a flag meaning &quot;don&#39;t go here&quot;.
  193 // I believe we can&#39;t handle callee-save doubles D32 and up until
  194 // the place in the sparc stack crawler that asserts on the 255 is
  195 // fixed up.
  196 reg_def R_D32 (SOC, SOC, Op_RegD,  1, F32-&gt;as_VMReg());
  197 reg_def R_D32x(SOC, SOC, Op_RegD,255, F32-&gt;as_VMReg()-&gt;next());
  198 reg_def R_D34 (SOC, SOC, Op_RegD,  3, F34-&gt;as_VMReg());
  199 reg_def R_D34x(SOC, SOC, Op_RegD,255, F34-&gt;as_VMReg()-&gt;next());
  200 reg_def R_D36 (SOC, SOC, Op_RegD,  5, F36-&gt;as_VMReg());
  201 reg_def R_D36x(SOC, SOC, Op_RegD,255, F36-&gt;as_VMReg()-&gt;next());
  202 reg_def R_D38 (SOC, SOC, Op_RegD,  7, F38-&gt;as_VMReg());
  203 reg_def R_D38x(SOC, SOC, Op_RegD,255, F38-&gt;as_VMReg()-&gt;next());
  204 reg_def R_D40 (SOC, SOC, Op_RegD,  9, F40-&gt;as_VMReg());
  205 reg_def R_D40x(SOC, SOC, Op_RegD,255, F40-&gt;as_VMReg()-&gt;next());
  206 reg_def R_D42 (SOC, SOC, Op_RegD, 11, F42-&gt;as_VMReg());
  207 reg_def R_D42x(SOC, SOC, Op_RegD,255, F42-&gt;as_VMReg()-&gt;next());
  208 reg_def R_D44 (SOC, SOC, Op_RegD, 13, F44-&gt;as_VMReg());
  209 reg_def R_D44x(SOC, SOC, Op_RegD,255, F44-&gt;as_VMReg()-&gt;next());
  210 reg_def R_D46 (SOC, SOC, Op_RegD, 15, F46-&gt;as_VMReg());
  211 reg_def R_D46x(SOC, SOC, Op_RegD,255, F46-&gt;as_VMReg()-&gt;next());
  212 reg_def R_D48 (SOC, SOC, Op_RegD, 17, F48-&gt;as_VMReg());
  213 reg_def R_D48x(SOC, SOC, Op_RegD,255, F48-&gt;as_VMReg()-&gt;next());
  214 reg_def R_D50 (SOC, SOC, Op_RegD, 19, F50-&gt;as_VMReg());
  215 reg_def R_D50x(SOC, SOC, Op_RegD,255, F50-&gt;as_VMReg()-&gt;next());
  216 reg_def R_D52 (SOC, SOC, Op_RegD, 21, F52-&gt;as_VMReg());
  217 reg_def R_D52x(SOC, SOC, Op_RegD,255, F52-&gt;as_VMReg()-&gt;next());
  218 reg_def R_D54 (SOC, SOC, Op_RegD, 23, F54-&gt;as_VMReg());
  219 reg_def R_D54x(SOC, SOC, Op_RegD,255, F54-&gt;as_VMReg()-&gt;next());
  220 reg_def R_D56 (SOC, SOC, Op_RegD, 25, F56-&gt;as_VMReg());
  221 reg_def R_D56x(SOC, SOC, Op_RegD,255, F56-&gt;as_VMReg()-&gt;next());
  222 reg_def R_D58 (SOC, SOC, Op_RegD, 27, F58-&gt;as_VMReg());
  223 reg_def R_D58x(SOC, SOC, Op_RegD,255, F58-&gt;as_VMReg()-&gt;next());
  224 reg_def R_D60 (SOC, SOC, Op_RegD, 29, F60-&gt;as_VMReg());
  225 reg_def R_D60x(SOC, SOC, Op_RegD,255, F60-&gt;as_VMReg()-&gt;next());
  226 reg_def R_D62 (SOC, SOC, Op_RegD, 31, F62-&gt;as_VMReg());
  227 reg_def R_D62x(SOC, SOC, Op_RegD,255, F62-&gt;as_VMReg()-&gt;next());
  228 
  229 
  230 // ----------------------------
  231 // Special Registers
  232 // Condition Codes Flag Registers
  233 // I tried to break out ICC and XCC but it&#39;s not very pretty.
  234 // Every Sparc instruction which defs/kills one also kills the other.
  235 // Hence every compare instruction which defs one kind of flags ends
  236 // up needing a kill of the other.
  237 reg_def CCR (SOC, SOC,  Op_RegFlags, 0, VMRegImpl::Bad());
  238 
  239 reg_def FCC0(SOC, SOC,  Op_RegFlags, 0, VMRegImpl::Bad());
  240 reg_def FCC1(SOC, SOC,  Op_RegFlags, 1, VMRegImpl::Bad());
  241 reg_def FCC2(SOC, SOC,  Op_RegFlags, 2, VMRegImpl::Bad());
  242 reg_def FCC3(SOC, SOC,  Op_RegFlags, 3, VMRegImpl::Bad());
  243 
  244 // ----------------------------
  245 // Specify the enum values for the registers.  These enums are only used by the
  246 // OptoReg &quot;class&quot;. We can convert these enum values at will to VMReg when needed
  247 // for visibility to the rest of the vm. The order of this enum influences the
  248 // register allocator so having the freedom to set this order and not be stuck
  249 // with the order that is natural for the rest of the vm is worth it.
  250 alloc_class chunk0(
  251   R_L0,R_L0H, R_L1,R_L1H, R_L2,R_L2H, R_L3,R_L3H, R_L4,R_L4H, R_L5,R_L5H, R_L6,R_L6H, R_L7,R_L7H,
  252   R_G0,R_G0H, R_G1,R_G1H, R_G2,R_G2H, R_G3,R_G3H, R_G4,R_G4H, R_G5,R_G5H, R_G6,R_G6H, R_G7,R_G7H,
  253   R_O7,R_O7H, R_SP,R_SPH, R_O0,R_O0H, R_O1,R_O1H, R_O2,R_O2H, R_O3,R_O3H, R_O4,R_O4H, R_O5,R_O5H,
  254   R_I0,R_I0H, R_I1,R_I1H, R_I2,R_I2H, R_I3,R_I3H, R_I4,R_I4H, R_I5,R_I5H, R_FP,R_FPH, R_I7,R_I7H);
  255 
  256 // Note that a register is not allocatable unless it is also mentioned
  257 // in a widely-used reg_class below.  Thus, R_G7 and R_G0 are outside i_reg.
  258 
  259 alloc_class chunk1(
  260   // The first registers listed here are those most likely to be used
  261   // as temporaries.  We move F0..F7 away from the front of the list,
  262   // to reduce the likelihood of interferences with parameters and
  263   // return values.  Likewise, we avoid using F0/F1 for parameters,
  264   // since they are used for return values.
  265   // This FPU fine-tuning is worth about 1% on the SPEC geomean.
  266   R_F8 ,R_F9 ,R_F10,R_F11,R_F12,R_F13,R_F14,R_F15,
  267   R_F16,R_F17,R_F18,R_F19,R_F20,R_F21,R_F22,R_F23,
  268   R_F24,R_F25,R_F26,R_F27,R_F28,R_F29,R_F30,R_F31,
  269   R_F0 ,R_F1 ,R_F2 ,R_F3 ,R_F4 ,R_F5 ,R_F6 ,R_F7 , // used for arguments and return values
  270   R_D32,R_D32x,R_D34,R_D34x,R_D36,R_D36x,R_D38,R_D38x,
  271   R_D40,R_D40x,R_D42,R_D42x,R_D44,R_D44x,R_D46,R_D46x,
  272   R_D48,R_D48x,R_D50,R_D50x,R_D52,R_D52x,R_D54,R_D54x,
  273   R_D56,R_D56x,R_D58,R_D58x,R_D60,R_D60x,R_D62,R_D62x);
  274 
  275 alloc_class chunk2(CCR, FCC0, FCC1, FCC2, FCC3);
  276 
  277 //----------Architecture Description Register Classes--------------------------
  278 // Several register classes are automatically defined based upon information in
  279 // this architecture description.
  280 // 1) reg_class inline_cache_reg           ( as defined in frame section )
  281 // 2) reg_class interpreter_method_oop_reg ( as defined in frame section )
  282 // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
  283 //
  284 
  285 // G0 is not included in integer class since it has special meaning.
  286 reg_class g0_reg(R_G0);
  287 
  288 // ----------------------------
  289 // Integer Register Classes
  290 // ----------------------------
  291 // Exclusions from i_reg:
  292 // R_G0: hardwired zero
  293 // R_G2: reserved by HotSpot to the TLS register (invariant within Java)
  294 // R_G6: reserved by Solaris ABI to tools
  295 // R_G7: reserved by Solaris ABI to libthread
  296 // R_O7: Used as a temp in many encodings
  297 reg_class int_reg(R_G1,R_G3,R_G4,R_G5,R_O0,R_O1,R_O2,R_O3,R_O4,R_O5,R_L0,R_L1,R_L2,R_L3,R_L4,R_L5,R_L6,R_L7,R_I0,R_I1,R_I2,R_I3,R_I4,R_I5);
  298 
  299 // Class for all integer registers, except the G registers.  This is used for
  300 // encodings which use G registers as temps.  The regular inputs to such
  301 // instructions use a &quot;notemp_&quot; prefix, as a hack to ensure that the allocator
  302 // will not put an input into a temp register.
  303 reg_class notemp_int_reg(R_O0,R_O1,R_O2,R_O3,R_O4,R_O5,R_L0,R_L1,R_L2,R_L3,R_L4,R_L5,R_L6,R_L7,R_I0,R_I1,R_I2,R_I3,R_I4,R_I5);
  304 
  305 reg_class g1_regI(R_G1);
  306 reg_class g3_regI(R_G3);
  307 reg_class g4_regI(R_G4);
  308 reg_class o0_regI(R_O0);
  309 reg_class o7_regI(R_O7);
  310 
  311 // ----------------------------
  312 // Pointer Register Classes
  313 // ----------------------------
  314 // 64-bit build means 64-bit pointers means hi/lo pairs
  315 reg_class ptr_reg(            R_G1H,R_G1,             R_G3H,R_G3, R_G4H,R_G4, R_G5H,R_G5,
  316                   R_O0H,R_O0, R_O1H,R_O1, R_O2H,R_O2, R_O3H,R_O3, R_O4H,R_O4, R_O5H,R_O5,
  317                   R_L0H,R_L0, R_L1H,R_L1, R_L2H,R_L2, R_L3H,R_L3, R_L4H,R_L4, R_L5H,R_L5, R_L6H,R_L6, R_L7H,R_L7,
  318                   R_I0H,R_I0, R_I1H,R_I1, R_I2H,R_I2, R_I3H,R_I3, R_I4H,R_I4, R_I5H,R_I5 );
  319 // Lock encodings use G3 and G4 internally
  320 reg_class lock_ptr_reg(       R_G1H,R_G1,                                     R_G5H,R_G5,
  321                   R_O0H,R_O0, R_O1H,R_O1, R_O2H,R_O2, R_O3H,R_O3, R_O4H,R_O4, R_O5H,R_O5,
  322                   R_L0H,R_L0, R_L1H,R_L1, R_L2H,R_L2, R_L3H,R_L3, R_L4H,R_L4, R_L5H,R_L5, R_L6H,R_L6, R_L7H,R_L7,
  323                   R_I0H,R_I0, R_I1H,R_I1, R_I2H,R_I2, R_I3H,R_I3, R_I4H,R_I4, R_I5H,R_I5 );
  324 // Special class for storeP instructions, which can store SP or RPC to TLS.
  325 // It is also used for memory addressing, allowing direct TLS addressing.
  326 reg_class sp_ptr_reg(         R_G1H,R_G1, R_G2H,R_G2, R_G3H,R_G3, R_G4H,R_G4, R_G5H,R_G5,
  327                   R_O0H,R_O0, R_O1H,R_O1, R_O2H,R_O2, R_O3H,R_O3, R_O4H,R_O4, R_O5H,R_O5, R_SPH,R_SP,
  328                   R_L0H,R_L0, R_L1H,R_L1, R_L2H,R_L2, R_L3H,R_L3, R_L4H,R_L4, R_L5H,R_L5, R_L6H,R_L6, R_L7H,R_L7,
  329                   R_I0H,R_I0, R_I1H,R_I1, R_I2H,R_I2, R_I3H,R_I3, R_I4H,R_I4, R_I5H,R_I5, R_FPH,R_FP );
  330 // R_L7 is the lowest-priority callee-save (i.e., NS) register
  331 // We use it to save R_G2 across calls out of Java.
  332 reg_class l7_regP(R_L7H,R_L7);
  333 
  334 // Other special pointer regs
  335 reg_class g1_regP(R_G1H,R_G1);
  336 reg_class g2_regP(R_G2H,R_G2);
  337 reg_class g3_regP(R_G3H,R_G3);
  338 reg_class g4_regP(R_G4H,R_G4);
  339 reg_class g5_regP(R_G5H,R_G5);
  340 reg_class i0_regP(R_I0H,R_I0);
  341 reg_class o0_regP(R_O0H,R_O0);
  342 reg_class o1_regP(R_O1H,R_O1);
  343 reg_class o2_regP(R_O2H,R_O2);
  344 reg_class o7_regP(R_O7H,R_O7);
  345 
  346 
  347 // ----------------------------
  348 // Long Register Classes
  349 // ----------------------------
  350 // Longs in 1 register.  Aligned adjacent hi/lo pairs.
  351 // Note:  O7 is never in this class; it is sometimes used as an encoding temp.
  352 reg_class long_reg(             R_G1H,R_G1,             R_G3H,R_G3, R_G4H,R_G4, R_G5H,R_G5
  353                    ,R_O0H,R_O0, R_O1H,R_O1, R_O2H,R_O2, R_O3H,R_O3, R_O4H,R_O4, R_O5H,R_O5
  354 // 64-bit, longs in 1 register: use all 64-bit integer registers
  355                    ,R_L0H,R_L0, R_L1H,R_L1, R_L2H,R_L2, R_L3H,R_L3, R_L4H,R_L4, R_L5H,R_L5, R_L6H,R_L6, R_L7H,R_L7
  356                    ,R_I0H,R_I0, R_I1H,R_I1, R_I2H,R_I2, R_I3H,R_I3, R_I4H,R_I4, R_I5H,R_I5
  357                   );
  358 
  359 reg_class g1_regL(R_G1H,R_G1);
  360 reg_class g3_regL(R_G3H,R_G3);
  361 reg_class o2_regL(R_O2H,R_O2);
  362 reg_class o7_regL(R_O7H,R_O7);
  363 
  364 // ----------------------------
  365 // Special Class for Condition Code Flags Register
  366 reg_class int_flags(CCR);
  367 reg_class float_flags(FCC0,FCC1,FCC2,FCC3);
  368 reg_class float_flag0(FCC0);
  369 
  370 
  371 // ----------------------------
  372 // Float Point Register Classes
  373 // ----------------------------
  374 // Skip F30/F31, they are reserved for mem-mem copies
  375 reg_class sflt_reg(R_F0,R_F1,R_F2,R_F3,R_F4,R_F5,R_F6,R_F7,R_F8,R_F9,R_F10,R_F11,R_F12,R_F13,R_F14,R_F15,R_F16,R_F17,R_F18,R_F19,R_F20,R_F21,R_F22,R_F23,R_F24,R_F25,R_F26,R_F27,R_F28,R_F29);
  376 
  377 // Paired floating point registers--they show up in the same order as the floats,
  378 // but they are used with the &quot;Op_RegD&quot; type, and always occur in even/odd pairs.
  379 reg_class dflt_reg(R_F0, R_F1, R_F2, R_F3, R_F4, R_F5, R_F6, R_F7, R_F8, R_F9, R_F10,R_F11,R_F12,R_F13,R_F14,R_F15,
  380                    R_F16,R_F17,R_F18,R_F19,R_F20,R_F21,R_F22,R_F23,R_F24,R_F25,R_F26,R_F27,R_F28,R_F29,
  381                    /* Use extra V9 double registers; this AD file does not support V8 */
  382                    R_D32,R_D32x,R_D34,R_D34x,R_D36,R_D36x,R_D38,R_D38x,R_D40,R_D40x,R_D42,R_D42x,R_D44,R_D44x,R_D46,R_D46x,
  383                    R_D48,R_D48x,R_D50,R_D50x,R_D52,R_D52x,R_D54,R_D54x,R_D56,R_D56x,R_D58,R_D58x,R_D60,R_D60x,R_D62,R_D62x
  384                    );
  385 
  386 // Paired floating point registers--they show up in the same order as the floats,
  387 // but they are used with the &quot;Op_RegD&quot; type, and always occur in even/odd pairs.
  388 // This class is usable for mis-aligned loads as happen in I2C adapters.
  389 reg_class dflt_low_reg(R_F0, R_F1, R_F2, R_F3, R_F4, R_F5, R_F6, R_F7, R_F8, R_F9, R_F10,R_F11,R_F12,R_F13,R_F14,R_F15,
  390                    R_F16,R_F17,R_F18,R_F19,R_F20,R_F21,R_F22,R_F23,R_F24,R_F25,R_F26,R_F27,R_F28,R_F29);
  391 %}
  392 
  393 //----------DEFINITION BLOCK---------------------------------------------------
  394 // Define name --&gt; value mappings to inform the ADLC of an integer valued name
  395 // Current support includes integer values in the range [0, 0x7FFFFFFF]
  396 // Format:
  397 //        int_def  &lt;name&gt;         ( &lt;int_value&gt;, &lt;expression&gt;);
  398 // Generated Code in ad_&lt;arch&gt;.hpp
  399 //        #define  &lt;name&gt;   (&lt;expression&gt;)
  400 //        // value == &lt;int_value&gt;
  401 // Generated code in ad_&lt;arch&gt;.cpp adlc_verification()
  402 //        assert( &lt;name&gt; == &lt;int_value&gt;, &quot;Expect (&lt;expression&gt;) to equal &lt;int_value&gt;&quot;);
  403 //
  404 definitions %{
  405 // The default cost (of an ALU instruction).
  406   int_def DEFAULT_COST      (    100,     100);
  407   int_def HUGE_COST         (1000000, 1000000);
  408 
  409 // Memory refs are twice as expensive as run-of-the-mill.
  410   int_def MEMORY_REF_COST   (    200, DEFAULT_COST * 2);
  411 
  412 // Branches are even more expensive.
  413   int_def BRANCH_COST       (    300, DEFAULT_COST * 3);
  414   int_def CALL_COST         (    300, DEFAULT_COST * 3);
  415 %}
  416 
  417 
  418 //----------SOURCE BLOCK-------------------------------------------------------
  419 // This is a block of C++ code which provides values, functions, and
  420 // definitions necessary in the rest of the architecture description
  421 source_hpp %{
  422 // Header information of the source block.
  423 // Method declarations/definitions which are used outside
  424 // the ad-scope can conveniently be defined here.
  425 //
  426 // To keep related declarations/definitions/uses close together,
  427 // we switch between source %{ }% and source_hpp %{ }% freely as needed.
  428 
  429 // Must be visible to the DFA in dfa_sparc.cpp
  430 extern bool can_branch_register( Node *bol, Node *cmp );
  431 
  432 extern bool use_block_zeroing(Node* count);
  433 
  434 // Macros to extract hi &amp; lo halves from a long pair.
  435 // G0 is not part of any long pair, so assert on that.
  436 // Prevents accidentally using G1 instead of G0.
  437 #define LONG_HI_REG(x) (x)
  438 #define LONG_LO_REG(x) (x)
  439 
  440 class CallStubImpl {
  441 
  442   //--------------------------------------------------------------
  443   //---&lt;  Used for optimization in Compile::Shorten_branches  &gt;---
  444   //--------------------------------------------------------------
  445 
  446  public:
  447   // Size of call trampoline stub.
  448   static uint size_call_trampoline() {
  449     return 0; // no call trampolines on this platform
  450   }
  451 
  452   // number of relocations needed by a call trampoline stub
  453   static uint reloc_call_trampoline() {
  454     return 0; // no call trampolines on this platform
  455   }
  456 };
  457 
  458 class HandlerImpl {
  459 
  460  public:
  461 
  462   static int emit_exception_handler(CodeBuffer &amp;cbuf);
  463   static int emit_deopt_handler(CodeBuffer&amp; cbuf);
  464 
  465   static uint size_exception_handler() {
  466     return ( NativeJump::instruction_size ); // sethi;jmp;nop
  467   }
  468 
  469   static uint size_deopt_handler() {
  470     return ( 4+  NativeJump::instruction_size ); // save;sethi;jmp;restore
  471   }
  472 };
  473 
  474 %}
  475 
  476 source %{
  477 #define __ _masm.
  478 
  479 // tertiary op of a LoadP or StoreP encoding
  480 #define REGP_OP true
  481 
  482 static FloatRegister reg_to_SingleFloatRegister_object(int register_encoding);
  483 static FloatRegister reg_to_DoubleFloatRegister_object(int register_encoding);
  484 static Register reg_to_register_object(int register_encoding);
  485 
  486 // Used by the DFA in dfa_sparc.cpp.
  487 // Check for being able to use a V9 branch-on-register.  Requires a
  488 // compare-vs-zero, equal/not-equal, of a value which was zero- or sign-
  489 // extended.  Doesn&#39;t work following an integer ADD, for example, because of
  490 // overflow (-1 incremented yields 0 plus a carry in the high-order word).  On
  491 // 32-bit V9 systems, interrupts currently blow away the high-order 32 bits and
  492 // replace them with zero, which could become sign-extension in a different OS
  493 // release.  There&#39;s no obvious reason why an interrupt will ever fill these
  494 // bits with non-zero junk (the registers are reloaded with standard LD
  495 // instructions which either zero-fill or sign-fill).
  496 bool can_branch_register( Node *bol, Node *cmp ) {
  497   if( !BranchOnRegister ) return false;
  498   if( cmp-&gt;Opcode() == Op_CmpP )
  499     return true;  // No problems with pointer compares
  500   if( cmp-&gt;Opcode() == Op_CmpL )
  501     return true;  // No problems with long compares
  502 
  503   if( !SparcV9RegsHiBitsZero ) return false;
  504   if( bol-&gt;as_Bool()-&gt;_test._test != BoolTest::ne &amp;&amp;
  505       bol-&gt;as_Bool()-&gt;_test._test != BoolTest::eq )
  506      return false;
  507 
  508   // Check for comparing against a &#39;safe&#39; value.  Any operation which
  509   // clears out the high word is safe.  Thus, loads and certain shifts
  510   // are safe, as are non-negative constants.  Any operation which
  511   // preserves zero bits in the high word is safe as long as each of its
  512   // inputs are safe.  Thus, phis and bitwise booleans are safe if their
  513   // inputs are safe.  At present, the only important case to recognize
  514   // seems to be loads.  Constants should fold away, and shifts &amp;
  515   // logicals can use the &#39;cc&#39; forms.
  516   Node *x = cmp-&gt;in(1);
  517   if( x-&gt;is_Load() ) return true;
  518   if( x-&gt;is_Phi() ) {
  519     for( uint i = 1; i &lt; x-&gt;req(); i++ )
  520       if( !x-&gt;in(i)-&gt;is_Load() )
  521         return false;
  522     return true;
  523   }
  524   return false;
  525 }
  526 
  527 bool use_block_zeroing(Node* count) {
  528   // Use BIS for zeroing if count is not constant
  529   // or it is &gt;= BlockZeroingLowLimit.
  530   return UseBlockZeroing &amp;&amp; (count-&gt;find_intptr_t_con(BlockZeroingLowLimit) &gt;= BlockZeroingLowLimit);
  531 }
  532 
  533 // ****************************************************************************
  534 
  535 // REQUIRED FUNCTIONALITY
  536 
  537 // !!!!! Special hack to get all type of calls to specify the byte offset
  538 //       from the start of the call to the point where the return address
  539 //       will point.
  540 //       The &quot;return address&quot; is the address of the call instruction, plus 8.
  541 
  542 int MachCallStaticJavaNode::ret_addr_offset() {
  543   int offset = NativeCall::instruction_size;  // call; delay slot
  544   if (_method_handle_invoke)
  545     offset += 4;  // restore SP
  546   return offset;
  547 }
  548 
  549 int MachCallDynamicJavaNode::ret_addr_offset() {
  550   int vtable_index = this-&gt;_vtable_index;
  551   if (vtable_index &lt; 0) {
  552     // must be invalid_vtable_index, not nonvirtual_vtable_index
  553     assert(vtable_index == Method::invalid_vtable_index, &quot;correct sentinel value&quot;);
  554     return (NativeMovConstReg::instruction_size +
  555            NativeCall::instruction_size);  // sethi; setlo; call; delay slot
  556   } else {
  557     assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
  558     int entry_offset = in_bytes(Klass::vtable_start_offset()) + vtable_index*vtableEntry::size_in_bytes();
  559     int v_off = entry_offset + vtableEntry::method_offset_in_bytes();
  560     int klass_load_size;
  561     if (UseCompressedClassPointers) {
  562       assert(Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
  563       klass_load_size = MacroAssembler::instr_size_for_decode_klass_not_null() + 1*BytesPerInstWord;
  564     } else {
  565       klass_load_size = 1*BytesPerInstWord;
  566     }
  567     if (Assembler::is_simm13(v_off)) {
  568       return klass_load_size +
  569              (2*BytesPerInstWord +           // ld_ptr, ld_ptr
  570              NativeCall::instruction_size);  // call; delay slot
  571     } else {
  572       return klass_load_size +
  573              (4*BytesPerInstWord +           // set_hi, set, ld_ptr, ld_ptr
  574              NativeCall::instruction_size);  // call; delay slot
  575     }
  576   }
  577 }
  578 
  579 int MachCallRuntimeNode::ret_addr_offset() {
  580   if (MacroAssembler::is_far_target(entry_point())) {
  581     return NativeFarCall::instruction_size;
  582   } else {
  583     return NativeCall::instruction_size;
  584   }
  585 }
  586 
  587 // Indicate if the safepoint node needs the polling page as an input.
  588 // Since Sparc does not have absolute addressing, it does.
  589 bool SafePointNode::needs_polling_address_input() {
  590   return true;
  591 }
  592 
  593 // emit an interrupt that is caught by the debugger (for debugging compiler)
  594 void emit_break(CodeBuffer &amp;cbuf) {
  595   MacroAssembler _masm(&amp;cbuf);
  596   __ breakpoint_trap();
  597 }
  598 
  599 #ifndef PRODUCT
  600 void MachBreakpointNode::format( PhaseRegAlloc *, outputStream *st ) const {
  601   st-&gt;print(&quot;TA&quot;);
  602 }
  603 #endif
  604 
  605 void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  606   emit_break(cbuf);
  607 }
  608 
  609 uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
  610   return MachNode::size(ra_);
  611 }
  612 
  613 // Traceable jump
  614 void  emit_jmpl(CodeBuffer &amp;cbuf, int jump_target) {
  615   MacroAssembler _masm(&amp;cbuf);
  616   Register rdest = reg_to_register_object(jump_target);
  617   __ JMP(rdest, 0);
  618   __ delayed()-&gt;nop();
  619 }
  620 
  621 // Traceable jump and set exception pc
  622 void  emit_jmpl_set_exception_pc(CodeBuffer &amp;cbuf, int jump_target) {
  623   MacroAssembler _masm(&amp;cbuf);
  624   Register rdest = reg_to_register_object(jump_target);
  625   __ JMP(rdest, 0);
  626   __ delayed()-&gt;add(O7, frame::pc_return_offset, Oissuing_pc );
  627 }
  628 
  629 void emit_nop(CodeBuffer &amp;cbuf) {
  630   MacroAssembler _masm(&amp;cbuf);
  631   __ nop();
  632 }
  633 
  634 void emit_illtrap(CodeBuffer &amp;cbuf) {
  635   MacroAssembler _masm(&amp;cbuf);
  636   __ illtrap(0);
  637 }
  638 
  639 
  640 intptr_t get_offset_from_base(const MachNode* n, const TypePtr* atype, int disp32) {
  641   assert(n-&gt;rule() != loadUB_rule, &quot;&quot;);
  642 
  643   intptr_t offset = 0;
  644   const TypePtr *adr_type = TYPE_PTR_SENTINAL;  // Check for base==RegI, disp==immP
  645   const Node* addr = n-&gt;get_base_and_disp(offset, adr_type);
  646   assert(adr_type == (const TypePtr*)-1, &quot;VerifyOops: no support for sparc operands with base==RegI, disp==immP&quot;);
  647   assert(addr != NULL &amp;&amp; addr != (Node*)-1, &quot;invalid addr&quot;);
  648   assert(addr-&gt;bottom_type()-&gt;isa_oopptr() == atype, &quot;&quot;);
  649   atype = atype-&gt;add_offset(offset);
  650   assert(disp32 == offset, &quot;wrong disp32&quot;);
  651   return atype-&gt;_offset;
  652 }
  653 
  654 
  655 intptr_t get_offset_from_base_2(const MachNode* n, const TypePtr* atype, int disp32) {
  656   assert(n-&gt;rule() != loadUB_rule, &quot;&quot;);
  657 
  658   intptr_t offset = 0;
  659   Node* addr = n-&gt;in(2);
  660   assert(addr-&gt;bottom_type()-&gt;isa_oopptr() == atype, &quot;&quot;);
  661   if (addr-&gt;is_Mach() &amp;&amp; addr-&gt;as_Mach()-&gt;ideal_Opcode() == Op_AddP) {
  662     Node* a = addr-&gt;in(2/*AddPNode::Address*/);
  663     Node* o = addr-&gt;in(3/*AddPNode::Offset*/);
  664     offset = o-&gt;is_Con() ? o-&gt;bottom_type()-&gt;is_intptr_t()-&gt;get_con() : Type::OffsetBot;
  665     atype = a-&gt;bottom_type()-&gt;is_ptr()-&gt;add_offset(offset);
  666     assert(atype-&gt;isa_oop_ptr(), &quot;still an oop&quot;);
  667   }
  668   offset = atype-&gt;is_ptr()-&gt;_offset;
  669   if (offset != Type::OffsetBot)  offset += disp32;
  670   return offset;
  671 }
  672 
  673 static inline jlong replicate_immI(int con, int count, int width) {
  674   // Load a constant replicated &quot;count&quot; times with width &quot;width&quot;
  675   assert(count*width == 8 &amp;&amp; width &lt;= 4, &quot;sanity&quot;);
  676   int bit_width = width * 8;
  677   jlong val = con;
  678   val &amp;= (((jlong) 1) &lt;&lt; bit_width) - 1;  // mask off sign bits
  679   for (int i = 0; i &lt; count - 1; i++) {
  680     val |= (val &lt;&lt; bit_width);
  681   }
  682   return val;
  683 }
  684 
  685 static inline jlong replicate_immF(float con) {
  686   // Replicate float con 2 times and pack into vector.
  687   int val = *((int*)&amp;con);
  688   jlong lval = val;
  689   lval = (lval &lt;&lt; 32) | (lval &amp; 0xFFFFFFFFl);
  690   return lval;
  691 }
  692 
  693 // Standard Sparc opcode form2 field breakdown
  694 static inline void emit2_19(CodeBuffer &amp;cbuf, int f30, int f29, int f25, int f22, int f20, int f19, int f0 ) {
  695   f0 &amp;= (1&lt;&lt;19)-1;     // Mask displacement to 19 bits
  696   int op = (f30 &lt;&lt; 30) |
  697            (f29 &lt;&lt; 29) |
  698            (f25 &lt;&lt; 25) |
  699            (f22 &lt;&lt; 22) |
  700            (f20 &lt;&lt; 20) |
  701            (f19 &lt;&lt; 19) |
  702            (f0  &lt;&lt;  0);
  703   cbuf.insts()-&gt;emit_int32(op);
  704 }
  705 
  706 // Standard Sparc opcode form2 field breakdown
  707 static inline void emit2_22(CodeBuffer &amp;cbuf, int f30, int f25, int f22, int f0 ) {
  708   f0 &gt;&gt;= 10;           // Drop 10 bits
  709   f0 &amp;= (1&lt;&lt;22)-1;     // Mask displacement to 22 bits
  710   int op = (f30 &lt;&lt; 30) |
  711            (f25 &lt;&lt; 25) |
  712            (f22 &lt;&lt; 22) |
  713            (f0  &lt;&lt;  0);
  714   cbuf.insts()-&gt;emit_int32(op);
  715 }
  716 
  717 // Standard Sparc opcode form3 field breakdown
  718 static inline void emit3(CodeBuffer &amp;cbuf, int f30, int f25, int f19, int f14, int f5, int f0 ) {
  719   int op = (f30 &lt;&lt; 30) |
  720            (f25 &lt;&lt; 25) |
  721            (f19 &lt;&lt; 19) |
  722            (f14 &lt;&lt; 14) |
  723            (f5  &lt;&lt;  5) |
  724            (f0  &lt;&lt;  0);
  725   cbuf.insts()-&gt;emit_int32(op);
  726 }
  727 
  728 // Standard Sparc opcode form3 field breakdown
  729 static inline void emit3_simm13(CodeBuffer &amp;cbuf, int f30, int f25, int f19, int f14, int simm13 ) {
  730   simm13 &amp;= (1&lt;&lt;13)-1; // Mask to 13 bits
  731   int op = (f30 &lt;&lt; 30) |
  732            (f25 &lt;&lt; 25) |
  733            (f19 &lt;&lt; 19) |
  734            (f14 &lt;&lt; 14) |
  735            (1   &lt;&lt; 13) | // bit to indicate immediate-mode
  736            (simm13&lt;&lt;0);
  737   cbuf.insts()-&gt;emit_int32(op);
  738 }
  739 
  740 static inline void emit3_simm10(CodeBuffer &amp;cbuf, int f30, int f25, int f19, int f14, int simm10 ) {
  741   simm10 &amp;= (1&lt;&lt;10)-1; // Mask to 10 bits
  742   emit3_simm13(cbuf,f30,f25,f19,f14,simm10);
  743 }
  744 
  745 #ifdef ASSERT
  746 // Helper function for VerifyOops in emit_form3_mem_reg
  747 void verify_oops_warning(const MachNode *n, int ideal_op, int mem_op) {
  748   warning(&quot;VerifyOops encountered unexpected instruction:&quot;);
  749   n-&gt;dump(2);
  750   warning(&quot;Instruction has ideal_Opcode==Op_%s and op_ld==Op_%s \n&quot;, NodeClassNames[ideal_op], NodeClassNames[mem_op]);
  751 }
  752 #endif
  753 
  754 
  755 void emit_form3_mem_reg(CodeBuffer &amp;cbuf, PhaseRegAlloc* ra, const MachNode* n, int primary, int tertiary,
  756                         int src1_enc, int disp32, int src2_enc, int dst_enc) {
  757 
  758 #ifdef ASSERT
  759   // The following code implements the +VerifyOops feature.
  760   // It verifies oop values which are loaded into or stored out of
  761   // the current method activation.  +VerifyOops complements techniques
  762   // like ScavengeALot, because it eagerly inspects oops in transit,
  763   // as they enter or leave the stack, as opposed to ScavengeALot,
  764   // which inspects oops &quot;at rest&quot;, in the stack or heap, at safepoints.
  765   // For this reason, +VerifyOops can sometimes detect bugs very close
  766   // to their point of creation.  It can also serve as a cross-check
  767   // on the validity of oop maps, when used toegether with ScavengeALot.
  768 
  769   // It would be good to verify oops at other points, especially
  770   // when an oop is used as a base pointer for a load or store.
  771   // This is presently difficult, because it is hard to know when
  772   // a base address is biased or not.  (If we had such information,
  773   // it would be easy and useful to make a two-argument version of
  774   // verify_oop which unbiases the base, and performs verification.)
  775 
  776   assert((uint)tertiary == 0xFFFFFFFF || tertiary == REGP_OP, &quot;valid tertiary&quot;);
  777   bool is_verified_oop_base  = false;
  778   bool is_verified_oop_load  = false;
  779   bool is_verified_oop_store = false;
  780   int tmp_enc = -1;
  781   if (VerifyOops &amp;&amp; src1_enc != R_SP_enc) {
  782     // classify the op, mainly for an assert check
  783     int st_op = 0, ld_op = 0;
  784     switch (primary) {
  785     case Assembler::stb_op3:  st_op = Op_StoreB; break;
  786     case Assembler::sth_op3:  st_op = Op_StoreC; break;
  787     case Assembler::stx_op3:  // may become StoreP or stay StoreI or StoreD0
  788     case Assembler::stw_op3:  st_op = Op_StoreI; break;
  789     case Assembler::std_op3:  st_op = Op_StoreL; break;
  790     case Assembler::stf_op3:  st_op = Op_StoreF; break;
  791     case Assembler::stdf_op3: st_op = Op_StoreD; break;
  792 
  793     case Assembler::ldsb_op3: ld_op = Op_LoadB; break;
  794     case Assembler::ldub_op3: ld_op = Op_LoadUB; break;
  795     case Assembler::lduh_op3: ld_op = Op_LoadUS; break;
  796     case Assembler::ldsh_op3: ld_op = Op_LoadS; break;
  797     case Assembler::ldx_op3:  // may become LoadP or stay LoadI
  798     case Assembler::ldsw_op3: // may become LoadP or stay LoadI
  799     case Assembler::lduw_op3: ld_op = Op_LoadI; break;
  800     case Assembler::ldd_op3:  ld_op = Op_LoadL; break;
  801     case Assembler::ldf_op3:  ld_op = Op_LoadF; break;
  802     case Assembler::lddf_op3: ld_op = Op_LoadD; break;
  803     case Assembler::prefetch_op3: ld_op = Op_LoadI; break;
  804 
  805     default: ShouldNotReachHere();
  806     }
  807     if (tertiary == REGP_OP) {
  808       if      (st_op == Op_StoreI)  st_op = Op_StoreP;
  809       else if (ld_op == Op_LoadI)   ld_op = Op_LoadP;
  810       else                          ShouldNotReachHere();
  811       if (st_op) {
  812         // a store
  813         // inputs are (0:control, 1:memory, 2:address, 3:value)
  814         Node* n2 = n-&gt;in(3);
  815         if (n2 != NULL) {
  816           const Type* t = n2-&gt;bottom_type();
  817           is_verified_oop_store = t-&gt;isa_oop_ptr() ? (t-&gt;is_ptr()-&gt;_offset==0) : false;
  818         }
  819       } else {
  820         // a load
  821         const Type* t = n-&gt;bottom_type();
  822         is_verified_oop_load = t-&gt;isa_oop_ptr() ? (t-&gt;is_ptr()-&gt;_offset==0) : false;
  823       }
  824     }
  825 
  826     if (ld_op) {
  827       // a Load
  828       // inputs are (0:control, 1:memory, 2:address)
  829       if (!(n-&gt;ideal_Opcode()==ld_op)       &amp;&amp; // Following are special cases
  830           !(n-&gt;ideal_Opcode()==Op_LoadPLocked &amp;&amp; ld_op==Op_LoadP) &amp;&amp;
  831           !(n-&gt;ideal_Opcode()==Op_LoadI     &amp;&amp; ld_op==Op_LoadF) &amp;&amp;
  832           !(n-&gt;ideal_Opcode()==Op_LoadF     &amp;&amp; ld_op==Op_LoadI) &amp;&amp;
  833           !(n-&gt;ideal_Opcode()==Op_LoadRange &amp;&amp; ld_op==Op_LoadI) &amp;&amp;
  834           !(n-&gt;ideal_Opcode()==Op_LoadKlass &amp;&amp; ld_op==Op_LoadP) &amp;&amp;
  835           !(n-&gt;ideal_Opcode()==Op_LoadL     &amp;&amp; ld_op==Op_LoadI) &amp;&amp;
  836           !(n-&gt;ideal_Opcode()==Op_LoadL_unaligned &amp;&amp; ld_op==Op_LoadI) &amp;&amp;
  837           !(n-&gt;ideal_Opcode()==Op_LoadD_unaligned &amp;&amp; ld_op==Op_LoadF) &amp;&amp;
  838           !(n-&gt;ideal_Opcode()==Op_ConvI2F   &amp;&amp; ld_op==Op_LoadF) &amp;&amp;
  839           !(n-&gt;ideal_Opcode()==Op_ConvI2D   &amp;&amp; ld_op==Op_LoadF) &amp;&amp;
  840           !(n-&gt;ideal_Opcode()==Op_PrefetchAllocation &amp;&amp; ld_op==Op_LoadI) &amp;&amp;
  841           !(n-&gt;ideal_Opcode()==Op_LoadVector &amp;&amp; ld_op==Op_LoadD) &amp;&amp;
  842           !(n-&gt;rule() == loadUB_rule)) {
  843         verify_oops_warning(n, n-&gt;ideal_Opcode(), ld_op);
  844       }
  845     } else if (st_op) {
  846       // a Store
  847       // inputs are (0:control, 1:memory, 2:address, 3:value)
  848       if (!(n-&gt;ideal_Opcode()==st_op)    &amp;&amp; // Following are special cases
  849           !(n-&gt;ideal_Opcode()==Op_StoreCM &amp;&amp; st_op==Op_StoreB) &amp;&amp;
  850           !(n-&gt;ideal_Opcode()==Op_StoreI &amp;&amp; st_op==Op_StoreF) &amp;&amp;
  851           !(n-&gt;ideal_Opcode()==Op_StoreF &amp;&amp; st_op==Op_StoreI) &amp;&amp;
  852           !(n-&gt;ideal_Opcode()==Op_StoreL &amp;&amp; st_op==Op_StoreI) &amp;&amp;
  853           !(n-&gt;ideal_Opcode()==Op_StoreVector &amp;&amp; st_op==Op_StoreD) &amp;&amp;
  854           !(n-&gt;ideal_Opcode()==Op_StoreD &amp;&amp; st_op==Op_StoreI &amp;&amp; n-&gt;rule() == storeD0_rule)) {
  855         verify_oops_warning(n, n-&gt;ideal_Opcode(), st_op);
  856       }
  857     }
  858 
  859     if (src2_enc == R_G0_enc &amp;&amp; n-&gt;rule() != loadUB_rule &amp;&amp; n-&gt;ideal_Opcode() != Op_StoreCM ) {
  860       Node* addr = n-&gt;in(2);
  861       if (!(addr-&gt;is_Mach() &amp;&amp; addr-&gt;as_Mach()-&gt;ideal_Opcode() == Op_AddP)) {
  862         const TypeOopPtr* atype = addr-&gt;bottom_type()-&gt;isa_instptr();  // %%% oopptr?
  863         if (atype != NULL) {
  864           intptr_t offset = get_offset_from_base(n, atype, disp32);
  865           intptr_t offset_2 = get_offset_from_base_2(n, atype, disp32);
  866           if (offset != offset_2) {
  867             get_offset_from_base(n, atype, disp32);
  868             get_offset_from_base_2(n, atype, disp32);
  869           }
  870           assert(offset == offset_2, &quot;different offsets&quot;);
  871           if (offset == disp32) {
  872             // we now know that src1 is a true oop pointer
  873             is_verified_oop_base = true;
  874             if (ld_op &amp;&amp; src1_enc == dst_enc &amp;&amp; ld_op != Op_LoadF &amp;&amp; ld_op != Op_LoadD) {
  875               if( primary == Assembler::ldd_op3 ) {
  876                 is_verified_oop_base = false; // Cannot &#39;ldd&#39; into O7
  877               } else {
  878                 tmp_enc = dst_enc;
  879                 dst_enc = R_O7_enc; // Load into O7; preserve source oop
  880                 assert(src1_enc != dst_enc, &quot;&quot;);
  881               }
  882             }
  883           }
  884           if (st_op &amp;&amp; (( offset == oopDesc::klass_offset_in_bytes())
  885                        || offset == oopDesc::mark_offset_in_bytes())) {
  886                       // loading the mark should not be allowed either, but
  887                       // we don&#39;t check this since it conflicts with InlineObjectHash
  888                       // usage of LoadINode to get the mark. We could keep the
  889                       // check if we create a new LoadMarkNode
  890             // but do not verify the object before its header is initialized
  891             ShouldNotReachHere();
  892           }
  893         }
  894       }
  895     }
  896   }
  897 #endif
  898 
  899   uint instr = (Assembler::ldst_op &lt;&lt; 30)
  900              | (dst_enc        &lt;&lt; 25)
  901              | (primary        &lt;&lt; 19)
  902              | (src1_enc       &lt;&lt; 14);
  903 
  904   uint index = src2_enc;
  905   int disp = disp32;
  906 
  907   if (src1_enc == R_SP_enc || src1_enc == R_FP_enc) {
  908     disp += STACK_BIAS;
  909     // Check that stack offset fits, load into O7 if not
  910     if (!Assembler::is_simm13(disp)) {
  911       MacroAssembler _masm(&amp;cbuf);
  912       __ set(disp, O7);
  913       if (index != R_G0_enc) {
  914         __ add(O7, reg_to_register_object(index), O7);
  915       }
  916       index = R_O7_enc;
  917       disp = 0;
  918     }
  919   }
  920 
  921   if( disp == 0 ) {
  922     // use reg-reg form
  923     // bit 13 is already zero
  924     instr |= index;
  925   } else {
  926     // use reg-imm form
  927     instr |= 0x00002000;          // set bit 13 to one
  928     instr |= disp &amp; 0x1FFF;
  929   }
  930 
  931   cbuf.insts()-&gt;emit_int32(instr);
  932 
  933 #ifdef ASSERT
  934   if (VerifyOops) {
  935     MacroAssembler _masm(&amp;cbuf);
  936     if (is_verified_oop_base) {
  937       __ verify_oop(reg_to_register_object(src1_enc));
  938     }
  939     if (is_verified_oop_store) {
  940       __ verify_oop(reg_to_register_object(dst_enc));
  941     }
  942     if (tmp_enc != -1) {
  943       __ mov(O7, reg_to_register_object(tmp_enc));
  944     }
  945     if (is_verified_oop_load) {
  946       __ verify_oop(reg_to_register_object(dst_enc));
  947     }
  948   }
  949 #endif
  950 }
  951 
  952 void emit_call_reloc(CodeBuffer &amp;cbuf, intptr_t entry_point, RelocationHolder const&amp; rspec, bool preserve_g2 = false) {
  953   // The method which records debug information at every safepoint
  954   // expects the call to be the first instruction in the snippet as
  955   // it creates a PcDesc structure which tracks the offset of a call
  956   // from the start of the codeBlob. This offset is computed as
  957   // code_end() - code_begin() of the code which has been emitted
  958   // so far.
  959   // In this particular case we have skirted around the problem by
  960   // putting the &quot;mov&quot; instruction in the delay slot but the problem
  961   // may bite us again at some other point and a cleaner/generic
  962   // solution using relocations would be needed.
  963   MacroAssembler _masm(&amp;cbuf);
  964   __ set_inst_mark();
  965 
  966   // We flush the current window just so that there is a valid stack copy
  967   // the fact that the current window becomes active again instantly is
  968   // not a problem there is nothing live in it.
  969 
  970 #ifdef ASSERT
  971   int startpos = __ offset();
  972 #endif /* ASSERT */
  973 
  974   __ call((address)entry_point, rspec);
  975 
  976   if (preserve_g2)   __ delayed()-&gt;mov(G2, L7);
  977   else __ delayed()-&gt;nop();
  978 
  979   if (preserve_g2)   __ mov(L7, G2);
  980 
  981 #ifdef ASSERT
  982   if (preserve_g2 &amp;&amp; (VerifyCompiledCode || VerifyOops)) {
  983     // Trash argument dump slots.
  984     __ set(0xb0b8ac0db0b8ac0d, G1);
  985     __ mov(G1, G5);
  986     __ stx(G1, SP, STACK_BIAS + 0x80);
  987     __ stx(G1, SP, STACK_BIAS + 0x88);
  988     __ stx(G1, SP, STACK_BIAS + 0x90);
  989     __ stx(G1, SP, STACK_BIAS + 0x98);
  990     __ stx(G1, SP, STACK_BIAS + 0xA0);
  991     __ stx(G1, SP, STACK_BIAS + 0xA8);
  992   }
  993 #endif /*ASSERT*/
  994 }
  995 
  996 //=============================================================================
  997 // REQUIRED FUNCTIONALITY for encoding
  998 void emit_lo(CodeBuffer &amp;cbuf, int val) {  }
  999 void emit_hi(CodeBuffer &amp;cbuf, int val) {  }
 1000 
 1001 
 1002 //=============================================================================
 1003 const RegMask&amp; MachConstantBaseNode::_out_RegMask = PTR_REG_mask();
 1004 
 1005 int ConstantTable::calculate_table_base_offset() const {
 1006   if (UseRDPCForConstantTableBase) {
 1007     // The table base offset might be less but then it fits into
 1008     // simm13 anyway and we are good (cf. MachConstantBaseNode::emit).
 1009     return Assembler::min_simm13();
 1010   } else {
 1011     int offset = -(size() / 2);
 1012     if (!Assembler::is_simm13(offset)) {
 1013       offset = Assembler::min_simm13();
 1014     }
 1015     return offset;
 1016   }
 1017 }
 1018 
 1019 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
 1020 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
 1021   ShouldNotReachHere();
 1022 }
 1023 
 1024 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
 1025   Compile* C = ra_-&gt;C;
 1026   ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();
 1027   MacroAssembler _masm(&amp;cbuf);
 1028 
 1029   Register r = as_Register(ra_-&gt;get_encode(this));
 1030   CodeSection* consts_section = __ code()-&gt;consts();
 1031   int consts_size = consts_section-&gt;align_at_start(consts_section-&gt;size());
 1032   assert(constant_table.size() == consts_size, &quot;must be: %d == %d&quot;, constant_table.size(), consts_size);
 1033 
 1034   if (UseRDPCForConstantTableBase) {
 1035     // For the following RDPC logic to work correctly the consts
 1036     // section must be allocated right before the insts section.  This
 1037     // assert checks for that.  The layout and the SECT_* constants
 1038     // are defined in src/share/vm/asm/codeBuffer.hpp.
 1039     assert(CodeBuffer::SECT_CONSTS + 1 == CodeBuffer::SECT_INSTS, &quot;must be&quot;);
 1040     int insts_offset = __ offset();
 1041 
 1042     // Layout:
 1043     //
 1044     // |----------- consts section ------------|----------- insts section -----------...
 1045     // |------ constant table -----|- padding -|------------------x----
 1046     //                                                            \ current PC (RDPC instruction)
 1047     // |&lt;------------- consts_size -----------&gt;|&lt;- insts_offset -&gt;|
 1048     //                                                            \ table base
 1049     // The table base offset is later added to the load displacement
 1050     // so it has to be negative.
 1051     int table_base_offset = -(consts_size + insts_offset);
 1052     int disp;
 1053 
 1054     // If the displacement from the current PC to the constant table
 1055     // base fits into simm13 we set the constant table base to the
 1056     // current PC.
 1057     if (Assembler::is_simm13(table_base_offset)) {
 1058       constant_table.set_table_base_offset(table_base_offset);
 1059       disp = 0;
 1060     } else {
 1061       // Otherwise we set the constant table base offset to the
 1062       // maximum negative displacement of load instructions to keep
 1063       // the disp as small as possible:
 1064       //
 1065       // |&lt;------------- consts_size -----------&gt;|&lt;- insts_offset -&gt;|
 1066       // |&lt;--------- min_simm13 ---------&gt;|&lt;-------- disp ---------&gt;|
 1067       //                                  \ table base
 1068       table_base_offset = Assembler::min_simm13();
 1069       constant_table.set_table_base_offset(table_base_offset);
 1070       disp = (consts_size + insts_offset) + table_base_offset;
 1071     }
 1072 
 1073     __ rdpc(r);
 1074 
 1075     if (disp == 0) {
 1076       // Emitting an additional &#39;nop&#39; instruction in order not to cause a code
 1077       // size adjustment in the code following the table setup (if the instruction
 1078       // immediately following after this section is a CTI).
 1079       __ nop();
 1080     }
 1081     else {
 1082       assert(r != O7, &quot;need temporary&quot;);
 1083       __ sub(r, __ ensure_simm13_or_reg(disp, O7), r);
 1084     }
 1085   }
 1086   else {
 1087     // Materialize the constant table base.
 1088     address baseaddr = consts_section-&gt;start() + -(constant_table.table_base_offset());
 1089     RelocationHolder rspec = internal_word_Relocation::spec(baseaddr);
 1090     AddressLiteral base(baseaddr, rspec);
 1091     __ set(base, r);
 1092   }
 1093 }
 1094 
 1095 uint MachConstantBaseNode::size(PhaseRegAlloc*) const {
 1096   if (UseRDPCForConstantTableBase) {
 1097     // This is really the worst case but generally it&#39;s only 1 instruction.
 1098     return (1 /*rdpc*/ + 1 /*sub*/ + MacroAssembler::worst_case_insts_for_set()) * BytesPerInstWord;
 1099   } else {
 1100     return MacroAssembler::worst_case_insts_for_set() * BytesPerInstWord;
 1101   }
 1102 }
 1103 
 1104 #ifndef PRODUCT
 1105 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
 1106   char reg[128];
 1107   ra_-&gt;dump_register(this, reg);
 1108   if (UseRDPCForConstantTableBase) {
 1109     st-&gt;print(&quot;RDPC   %s\t! constant table base&quot;, reg);
 1110   } else {
 1111     st-&gt;print(&quot;SET    &amp;constanttable,%s\t! constant table base&quot;, reg);
 1112   }
 1113 }
 1114 #endif
 1115 
 1116 
 1117 //=============================================================================
 1118 
 1119 #ifndef PRODUCT
 1120 void MachPrologNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1121   Compile* C = ra_-&gt;C;
 1122 
 1123   for (int i = 0; i &lt; OptoPrologueNops; i++) {
 1124     st-&gt;print_cr(&quot;NOP&quot;); st-&gt;print(&quot;\t&quot;);
 1125   }
 1126 
 1127   if( VerifyThread ) {
 1128     st-&gt;print_cr(&quot;Verify_Thread&quot;); st-&gt;print(&quot;\t&quot;);
 1129   }
 1130 
 1131   size_t framesize = C-&gt;output()-&gt;frame_size_in_bytes();
 1132   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();
 1133 
 1134   // Calls to C2R adapters often do not accept exceptional returns.
 1135   // We require that their callers must bang for them.  But be careful, because
 1136   // some VM calls (such as call site linkage) can use several kilobytes of
 1137   // stack.  But the stack safety zone should account for that.
 1138   // See bugs 4446381, 4468289, 4497237.
 1139   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {
 1140     st-&gt;print_cr(&quot;! stack bang (%d bytes)&quot;, bangsize); st-&gt;print(&quot;\t&quot;);
 1141   }
 1142 
 1143   if (Assembler::is_simm13(-framesize)) {
 1144     st-&gt;print   (&quot;SAVE   R_SP,-&quot; SIZE_FORMAT &quot;,R_SP&quot;,framesize);
 1145   } else {
 1146     st-&gt;print_cr(&quot;SETHI  R_SP,hi%%(-&quot; SIZE_FORMAT &quot;),R_G3&quot;,framesize); st-&gt;print(&quot;\t&quot;);
 1147     st-&gt;print_cr(&quot;ADD    R_G3,lo%%(-&quot; SIZE_FORMAT &quot;),R_G3&quot;,framesize); st-&gt;print(&quot;\t&quot;);
 1148     st-&gt;print   (&quot;SAVE   R_SP,R_G3,R_SP&quot;);
 1149   }
 1150 
 1151 }
 1152 #endif
 1153 
 1154 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1155   Compile* C = ra_-&gt;C;
 1156   MacroAssembler _masm(&amp;cbuf);
 1157 
 1158   for (int i = 0; i &lt; OptoPrologueNops; i++) {
 1159     __ nop();
 1160   }
 1161 
 1162   __ verify_thread();
 1163 
 1164   size_t framesize = C-&gt;output()-&gt;frame_size_in_bytes();
 1165   assert(framesize &gt;= 16*wordSize, &quot;must have room for reg. save area&quot;);
 1166   assert(framesize%(2*wordSize) == 0, &quot;must preserve 2*wordSize alignment&quot;);
 1167   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();
 1168 
 1169   // Calls to C2R adapters often do not accept exceptional returns.
 1170   // We require that their callers must bang for them.  But be careful, because
 1171   // some VM calls (such as call site linkage) can use several kilobytes of
 1172   // stack.  But the stack safety zone should account for that.
 1173   // See bugs 4446381, 4468289, 4497237.
 1174   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {
 1175     __ generate_stack_overflow_check(bangsize);
 1176   }
 1177 
 1178   if (Assembler::is_simm13(-framesize)) {
 1179     __ save(SP, -framesize, SP);
 1180   } else {
 1181     __ sethi(-framesize &amp; ~0x3ff, G3);
 1182     __ add(G3, -framesize &amp; 0x3ff, G3);
 1183     __ save(SP, G3, SP);
 1184   }
 1185   C-&gt;output()-&gt;set_frame_complete( __ offset() );
 1186 
 1187   if (!UseRDPCForConstantTableBase &amp;&amp; C-&gt;has_mach_constant_base_node()) {
 1188     // NOTE: We set the table base offset here because users might be
 1189     // emitted before MachConstantBaseNode.
 1190     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();
 1191     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
 1192   }
 1193 }
 1194 
 1195 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
 1196   return MachNode::size(ra_);
 1197 }
 1198 
 1199 int MachPrologNode::reloc() const {
 1200   return 10; // a large enough number
 1201 }
 1202 
 1203 //=============================================================================
 1204 #ifndef PRODUCT
 1205 void MachEpilogNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1206   Compile* C = ra_-&gt;C;
 1207 
 1208   if(do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
 1209     if (SafepointMechanism::uses_global_page_poll()) {
 1210       st-&gt;print(&quot;SETHI  #PollAddr,L0\t! Load Polling address\n\t&quot;);
 1211     } else {
 1212       st-&gt;print(&quot;LDX    [R_G2 + #poll_offset],L0\t! Load local polling address\n\t&quot;);
 1213     }
 1214     st-&gt;print(&quot;LDX    [L0],G0\t!Poll for Safepointing\n\t&quot;);
 1215   }
 1216 
 1217   if(do_polling()) {
 1218     if (UseCBCond &amp;&amp; !ra_-&gt;C-&gt;is_method_compilation()) {
 1219       st-&gt;print(&quot;NOP\n\t&quot;);
 1220     }
 1221     st-&gt;print(&quot;RET\n\t&quot;);
 1222   }
 1223 
 1224   st-&gt;print(&quot;RESTORE&quot;);
 1225 }
 1226 #endif
 1227 
 1228 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1229   MacroAssembler _masm(&amp;cbuf);
 1230   Compile* C = ra_-&gt;C;
 1231 
 1232   __ verify_thread();
 1233 
 1234   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
 1235     __ reserved_stack_check();
 1236   }
 1237 
 1238   // If this does safepoint polling, then do it here
 1239   if(do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
 1240     if (SafepointMechanism::uses_thread_local_poll()) {
 1241       __ ld_ptr(Address(G2_thread, Thread::polling_page_offset()), L0);
 1242     } else {
 1243       AddressLiteral polling_page(os::get_polling_page());
 1244       __ sethi(polling_page, L0);
 1245     }
 1246     __ relocate(relocInfo::poll_return_type);
 1247     __ ld_ptr(L0, 0, G0);
 1248   }
 1249 
 1250   // If this is a return, then stuff the restore in the delay slot
 1251   if(do_polling()) {
 1252     if (UseCBCond &amp;&amp; !ra_-&gt;C-&gt;is_method_compilation()) {
 1253       // Insert extra padding for the case when the epilogue is preceded by
 1254       // a cbcond jump, which can&#39;t be followed by a CTI instruction
 1255       __ nop();
 1256     }
 1257     __ ret();
 1258     __ delayed()-&gt;restore();
 1259   } else {
 1260     __ restore();
 1261   }
 1262 }
 1263 
 1264 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
 1265   return MachNode::size(ra_);
 1266 }
 1267 
 1268 int MachEpilogNode::reloc() const {
 1269   return 16; // a large enough number
 1270 }
 1271 
 1272 const Pipeline * MachEpilogNode::pipeline() const {
 1273   return MachNode::pipeline_class();
 1274 }
 1275 
 1276 int MachEpilogNode::safepoint_offset() const {
 1277   assert(SafepointMechanism::uses_global_page_poll(), &quot;sanity&quot;);
 1278   assert( do_polling(), &quot;no return for this epilog node&quot;);
 1279   return MacroAssembler::insts_for_sethi(os::get_polling_page()) * BytesPerInstWord;
 1280 }
 1281 
 1282 //=============================================================================
 1283 
 1284 // Figure out which register class each belongs in: rc_int, rc_float, rc_stack
 1285 enum RC { rc_bad, rc_int, rc_float, rc_stack };
 1286 static enum RC rc_class( OptoReg::Name reg ) {
 1287   if (!OptoReg::is_valid(reg)) return rc_bad;
 1288   if (OptoReg::is_stack(reg)) return rc_stack;
 1289   VMReg r = OptoReg::as_VMReg(reg);
 1290   if (r-&gt;is_Register()) return rc_int;
 1291   assert(r-&gt;is_FloatRegister(), &quot;must be&quot;);
 1292   return rc_float;
 1293 }
 1294 
 1295 #ifndef PRODUCT
 1296 ATTRIBUTE_PRINTF(2, 3)
 1297 static void print_helper(outputStream* st, const char* format, ...) {
 1298   const int tab_size = 8;
 1299   if (st-&gt;position() &gt; tab_size) {
 1300     st-&gt;cr();
 1301     st-&gt;sp();
 1302   }
 1303   va_list ap;
 1304   va_start(ap, format);
 1305   st-&gt;vprint(format, ap);
 1306   va_end(ap);
 1307 }
 1308 #endif // !PRODUCT
 1309 
 1310 static void impl_helper(const MachNode* mach, CodeBuffer* cbuf, PhaseRegAlloc* ra, bool is_load, int offset, int reg, int opcode, const char *op_str, outputStream* st) {
 1311   if (cbuf) {
 1312     emit_form3_mem_reg(*cbuf, ra, mach, opcode, -1, R_SP_enc, offset, 0, Matcher::_regEncode[reg]);
 1313   }
 1314 #ifndef PRODUCT
 1315   else {
 1316     if (is_load) {
 1317       print_helper(st, &quot;%s   [R_SP + #%d],R_%s\t! spill&quot;, op_str, offset, OptoReg::regname(reg));
 1318     } else {
 1319       print_helper(st, &quot;%s   R_%s,[R_SP + #%d]\t! spill&quot;, op_str, OptoReg::regname(reg), offset);
 1320     }
 1321   }
 1322 #endif
 1323 }
 1324 
 1325 static void impl_mov_helper(CodeBuffer *cbuf, int src, int dst, int op1, int op2, const char *op_str, outputStream* st) {
 1326   if (cbuf) {
 1327     emit3(*cbuf, Assembler::arith_op, Matcher::_regEncode[dst], op1, 0, op2, Matcher::_regEncode[src]);
 1328   }
 1329 #ifndef PRODUCT
 1330   else {
 1331     print_helper(st, &quot;%s  R_%s,R_%s\t! spill&quot;, op_str, OptoReg::regname(src), OptoReg::regname(dst));
 1332   }
 1333 #endif
 1334 }
 1335 
 1336 static void mach_spill_copy_implementation_helper(const MachNode* mach,
 1337                                                   CodeBuffer *cbuf,
 1338                                                   PhaseRegAlloc *ra_,
 1339                                                   outputStream* st) {
 1340   // Get registers to move
 1341   OptoReg::Name src_second = ra_-&gt;get_reg_second(mach-&gt;in(1));
 1342   OptoReg::Name src_first  = ra_-&gt;get_reg_first(mach-&gt;in(1));
 1343   OptoReg::Name dst_second = ra_-&gt;get_reg_second(mach);
 1344   OptoReg::Name dst_first  = ra_-&gt;get_reg_first(mach);
 1345 
 1346   enum RC src_second_rc = rc_class(src_second);
 1347   enum RC src_first_rc  = rc_class(src_first);
 1348   enum RC dst_second_rc = rc_class(dst_second);
 1349   enum RC dst_first_rc  = rc_class(dst_first);
 1350 
 1351   assert(OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first), &quot;must move at least 1 register&quot;);
 1352 
 1353   if (src_first == dst_first &amp;&amp; src_second == dst_second) {
 1354     return; // Self copy, no move
 1355   }
 1356 
 1357   // --------------------------------------
 1358   // Check for mem-mem move.  Load into unused float registers and fall into
 1359   // the float-store case.
 1360   if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack) {
 1361     int offset = ra_-&gt;reg2offset(src_first);
 1362     // Further check for aligned-adjacent pair, so we can use a double load
 1363     if ((src_first&amp;1) == 0 &amp;&amp; src_first+1 == src_second) {
 1364       src_second    = OptoReg::Name(R_F31_num);
 1365       src_second_rc = rc_float;
 1366       impl_helper(mach, cbuf, ra_, true, offset, R_F30_num, Assembler::lddf_op3, &quot;LDDF&quot;, st);
 1367     } else {
 1368       impl_helper(mach, cbuf, ra_, true, offset, R_F30_num, Assembler::ldf_op3, &quot;LDF &quot;, st);
 1369     }
 1370     src_first    = OptoReg::Name(R_F30_num);
 1371     src_first_rc = rc_float;
 1372   }
 1373 
 1374   if( src_second_rc == rc_stack &amp;&amp; dst_second_rc == rc_stack ) {
 1375     int offset = ra_-&gt;reg2offset(src_second);
 1376     impl_helper(mach, cbuf, ra_, true, offset, R_F31_num, Assembler::ldf_op3, &quot;LDF &quot;, st);
 1377     src_second    = OptoReg::Name(R_F31_num);
 1378     src_second_rc = rc_float;
 1379   }
 1380 
 1381   // --------------------------------------
 1382   // Check for float-&gt;int copy; requires a trip through memory
 1383   if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_int &amp;&amp; UseVIS &lt; 3) {
 1384     int offset = frame::register_save_words*wordSize;
 1385     if (cbuf) {
 1386       emit3_simm13(*cbuf, Assembler::arith_op, R_SP_enc, Assembler::sub_op3, R_SP_enc, 16);
 1387       impl_helper(mach, cbuf, ra_, false, offset, src_first,  Assembler::stf_op3, &quot;STF &quot;, st);
 1388       impl_helper(mach, cbuf, ra_,  true, offset, dst_first, Assembler::lduw_op3, &quot;LDUW&quot;, st);
 1389       emit3_simm13(*cbuf, Assembler::arith_op, R_SP_enc, Assembler::add_op3, R_SP_enc, 16);
 1390     }
 1391 #ifndef PRODUCT
 1392     else {
 1393       print_helper(st, &quot;SUB    R_SP,16,R_SP&quot;);
 1394       impl_helper(mach, cbuf, ra_, false, offset, src_first,  Assembler::stf_op3, &quot;STF &quot;, st);
 1395       impl_helper(mach, cbuf, ra_,  true, offset, dst_first, Assembler::lduw_op3, &quot;LDUW&quot;, st);
 1396       print_helper(st, &quot;ADD    R_SP,16,R_SP&quot;);
 1397     }
 1398 #endif
 1399   }
 1400 
 1401   // Check for float-&gt;int copy on T4
 1402   if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_int &amp;&amp; UseVIS &gt;= 3) {
 1403     // Further check for aligned-adjacent pair, so we can use a double move
 1404     if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp; (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1405       impl_mov_helper(cbuf, src_first, dst_first, Assembler::mftoi_op3, Assembler::mdtox_opf, &quot;MOVDTOX&quot;, st);
 1406       return;
 1407     }
 1408     impl_mov_helper(cbuf, src_first, dst_first, Assembler::mftoi_op3, Assembler::mstouw_opf, &quot;MOVSTOUW&quot;, st);
 1409   }
 1410   // Check for int-&gt;float copy on T4
 1411   if (src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_float &amp;&amp; UseVIS &gt;= 3) {
 1412     // Further check for aligned-adjacent pair, so we can use a double move
 1413     if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp; (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1414       impl_mov_helper(cbuf, src_first, dst_first, Assembler::mftoi_op3, Assembler::mxtod_opf, &quot;MOVXTOD&quot;, st);
 1415       return;
 1416     }
 1417     impl_mov_helper(cbuf, src_first, dst_first, Assembler::mftoi_op3, Assembler::mwtos_opf, &quot;MOVWTOS&quot;, st);
 1418   }
 1419 
 1420   // --------------------------------------
 1421   // In the 32-bit 1-reg-longs build ONLY, I see mis-aligned long destinations.
 1422   // In such cases, I have to do the big-endian swap.  For aligned targets, the
 1423   // hardware does the flop for me.  Doubles are always aligned, so no problem
 1424   // there.  Misaligned sources only come from native-long-returns (handled
 1425   // special below).
 1426 
 1427   // --------------------------------------
 1428   // Check for integer reg-reg copy
 1429   if (src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_int) {
 1430     // Else normal reg-reg copy
 1431     assert(src_second != dst_first, &quot;smashed second before evacuating it&quot;);
 1432     impl_mov_helper(cbuf, src_first, dst_first, Assembler::or_op3, 0, &quot;MOV  &quot;, st);
 1433     assert((src_first &amp; 1) == 0 &amp;&amp; (dst_first &amp; 1) == 0, &quot;never move second-halves of int registers&quot;);
 1434     // This moves an aligned adjacent pair.
 1435     // See if we are done.
 1436     if (src_first + 1 == src_second &amp;&amp; dst_first + 1 == dst_second) {
 1437       return;
 1438     }
 1439   }
 1440 
 1441   // Check for integer store
 1442   if (src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_stack) {
 1443     int offset = ra_-&gt;reg2offset(dst_first);
 1444     // Further check for aligned-adjacent pair, so we can use a double store
 1445     if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp; (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1446       impl_helper(mach, cbuf, ra_, false, offset, src_first, Assembler::stx_op3, &quot;STX &quot;, st);
 1447       return;
 1448     }
 1449     impl_helper(mach, cbuf, ra_, false, offset, src_first, Assembler::stw_op3, &quot;STW &quot;, st);
 1450   }
 1451 
 1452   // Check for integer load
 1453   if (dst_first_rc == rc_int &amp;&amp; src_first_rc == rc_stack) {
 1454     int offset = ra_-&gt;reg2offset(src_first);
 1455     // Further check for aligned-adjacent pair, so we can use a double load
 1456     if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp; (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1457       impl_helper(mach, cbuf, ra_, true, offset, dst_first, Assembler::ldx_op3, &quot;LDX &quot;, st);
 1458       return;
 1459     }
 1460     impl_helper(mach, cbuf, ra_, true, offset, dst_first, Assembler::lduw_op3, &quot;LDUW&quot;, st);
 1461   }
 1462 
 1463   // Check for float reg-reg copy
 1464   if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_float) {
 1465     // Further check for aligned-adjacent pair, so we can use a double move
 1466     if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp; (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1467       impl_mov_helper(cbuf, src_first, dst_first, Assembler::fpop1_op3, Assembler::fmovd_opf, &quot;FMOVD&quot;, st);
 1468       return;
 1469     }
 1470     impl_mov_helper(cbuf, src_first, dst_first, Assembler::fpop1_op3, Assembler::fmovs_opf, &quot;FMOVS&quot;, st);
 1471   }
 1472 
 1473   // Check for float store
 1474   if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_stack) {
 1475     int offset = ra_-&gt;reg2offset(dst_first);
 1476     // Further check for aligned-adjacent pair, so we can use a double store
 1477     if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp; (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1478       impl_helper(mach, cbuf, ra_, false, offset, src_first, Assembler::stdf_op3, &quot;STDF&quot;, st);
 1479       return;
 1480     }
 1481     impl_helper(mach, cbuf, ra_, false, offset, src_first, Assembler::stf_op3, &quot;STF &quot;, st);
 1482   }
 1483 
 1484   // Check for float load
 1485   if (dst_first_rc == rc_float &amp;&amp; src_first_rc == rc_stack) {
 1486     int offset = ra_-&gt;reg2offset(src_first);
 1487     // Further check for aligned-adjacent pair, so we can use a double load
 1488     if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp; (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1489       impl_helper(mach, cbuf, ra_, true, offset, dst_first, Assembler::lddf_op3, &quot;LDDF&quot;, st);
 1490       return;
 1491     }
 1492     impl_helper(mach, cbuf, ra_, true, offset, dst_first, Assembler::ldf_op3, &quot;LDF &quot;, st);
 1493   }
 1494 
 1495   // --------------------------------------------------------------------
 1496   // Check for hi bits still needing moving.  Only happens for misaligned
 1497   // arguments to native calls.
 1498   if (src_second == dst_second) {
 1499     return; // Self copy; no move
 1500   }
 1501   assert(src_second_rc != rc_bad &amp;&amp; dst_second_rc != rc_bad, &quot;src_second &amp; dst_second cannot be Bad&quot;);
 1502 
 1503   Unimplemented();
 1504 }
 1505 
 1506 uint MachSpillCopyNode::implementation(CodeBuffer *cbuf,
 1507                                        PhaseRegAlloc *ra_,
 1508                                        bool do_size,
 1509                                        outputStream* st) const {
 1510   assert(!do_size, &quot;not supported&quot;);
 1511   mach_spill_copy_implementation_helper(this, cbuf, ra_, st);
 1512   return 0;
 1513 }
 1514 
 1515 #ifndef PRODUCT
 1516 void MachSpillCopyNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1517   implementation( NULL, ra_, false, st );
 1518 }
 1519 #endif
 1520 
 1521 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1522   implementation( &amp;cbuf, ra_, false, NULL );
 1523 }
 1524 
 1525 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1526   return MachNode::size(ra_);
 1527 }
 1528 
 1529 //=============================================================================
 1530 #ifndef PRODUCT
 1531 void MachNopNode::format(PhaseRegAlloc *, outputStream *st) const {
 1532   st-&gt;print(&quot;NOP \t# %d bytes pad for loops and calls&quot;, 4 * _count);
 1533 }
 1534 #endif
 1535 
 1536 void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *) const {
 1537   MacroAssembler _masm(&amp;cbuf);
 1538   for (int i = 0; i &lt; _count; i += 1) {
 1539     __ nop();
 1540   }
 1541 }
 1542 
 1543 uint MachNopNode::size(PhaseRegAlloc *ra_) const {
 1544   return 4 * _count;
 1545 }
 1546 
 1547 
 1548 //=============================================================================
 1549 #ifndef PRODUCT
 1550 void BoxLockNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1551   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1552   int reg = ra_-&gt;get_reg_first(this);
 1553   st-&gt;print(&quot;LEA    [R_SP+#%d+BIAS],%s&quot;,offset,Matcher::regName[reg]);
 1554 }
 1555 #endif
 1556 
 1557 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1558   MacroAssembler _masm(&amp;cbuf);
 1559   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem()) + STACK_BIAS;
 1560   int reg = ra_-&gt;get_encode(this);
 1561 
 1562   if (Assembler::is_simm13(offset)) {
 1563      __ add(SP, offset, reg_to_register_object(reg));
 1564   } else {
 1565      __ set(offset, O7);
 1566      __ add(SP, O7, reg_to_register_object(reg));
 1567   }
 1568 }
 1569 
 1570 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 1571   // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_)
 1572   assert(ra_ == ra_-&gt;C-&gt;regalloc(), &quot;sanity&quot;);
 1573   return ra_-&gt;C-&gt;output()-&gt;scratch_emit_size(this);
 1574 }
 1575 
 1576 //=============================================================================
 1577 #ifndef PRODUCT
 1578 void MachUEPNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1579   st-&gt;print_cr(&quot;\nUEP:&quot;);
 1580   if (UseCompressedClassPointers) {
 1581     assert(Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
 1582     st-&gt;print_cr(&quot;\tLDUW   [R_O0 + oopDesc::klass_offset_in_bytes],R_G5\t! Inline cache check - compressed klass&quot;);
 1583     if (CompressedKlassPointers::base() != 0) {
 1584       st-&gt;print_cr(&quot;\tSET    CompressedKlassPointers::base,R_G6_heap_base&quot;);
 1585       if (CompressedKlassPointers::shift() != 0) {
 1586         st-&gt;print_cr(&quot;\tSLL    R_G5,CompressedKlassPointers::shift,R_G5&quot;);
 1587       }
 1588       st-&gt;print_cr(&quot;\tADD    R_G5,R_G6_heap_base,R_G5&quot;);
 1589       st-&gt;print_cr(&quot;\tSET    CompressedOops::ptrs_base,R_G6_heap_base&quot;);
 1590     } else {
 1591       st-&gt;print_cr(&quot;\tSLL    R_G5,CompressedKlassPointers::shift,R_G5&quot;);
 1592     }
 1593   } else {
 1594     st-&gt;print_cr(&quot;\tLDX    [R_O0 + oopDesc::klass_offset_in_bytes],R_G5\t! Inline cache check&quot;);
 1595   }
 1596   st-&gt;print_cr(&quot;\tCMP    R_G5,R_G3&quot; );
 1597   st-&gt;print   (&quot;\tTne    xcc,R_G0+ST_RESERVED_FOR_USER_0+2&quot;);
 1598 }
 1599 #endif
 1600 
 1601 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1602   MacroAssembler _masm(&amp;cbuf);
 1603   Register G5_ic_reg  = reg_to_register_object(Matcher::inline_cache_reg_encode());
 1604   Register temp_reg   = G3;
 1605   assert( G5_ic_reg != temp_reg, &quot;conflicting registers&quot; );
 1606 
 1607   // Load klass from receiver
 1608   __ load_klass(O0, temp_reg);
 1609   // Compare against expected klass
 1610   __ cmp(temp_reg, G5_ic_reg);
 1611   // Branch to miss code, checks xcc or icc depending
 1612   __ trap(Assembler::notEqual, Assembler::ptr_cc, G0, ST_RESERVED_FOR_USER_0+2);
 1613 }
 1614 
 1615 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
 1616   return MachNode::size(ra_);
 1617 }
 1618 
 1619 
 1620 //=============================================================================
 1621 
 1622 
 1623 // Emit exception handler code.
 1624 int HandlerImpl::emit_exception_handler(CodeBuffer&amp; cbuf) {
 1625   Register temp_reg = G3;
 1626   AddressLiteral exception_blob(OptoRuntime::exception_blob()-&gt;entry_point());
 1627   MacroAssembler _masm(&amp;cbuf);
 1628 
 1629   address base = __ start_a_stub(size_exception_handler());
 1630   if (base == NULL) {
 1631     ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 1632     return 0;  // CodeBuffer::expand failed
 1633   }
 1634 
 1635   int offset = __ offset();
 1636 
 1637   __ JUMP(exception_blob, temp_reg, 0); // sethi;jmp
 1638   __ delayed()-&gt;nop();
 1639 
 1640   assert(__ offset() - offset &lt;= (int) size_exception_handler(), &quot;overflow&quot;);
 1641 
 1642   __ end_a_stub();
 1643 
 1644   return offset;
 1645 }
 1646 
 1647 int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
 1648   // Can&#39;t use any of the current frame&#39;s registers as we may have deopted
 1649   // at a poll and everything (including G3) can be live.
 1650   Register temp_reg = L0;
 1651   AddressLiteral deopt_blob(SharedRuntime::deopt_blob()-&gt;unpack());
 1652   MacroAssembler _masm(&amp;cbuf);
 1653 
 1654   address base = __ start_a_stub(size_deopt_handler());
 1655   if (base == NULL) {
 1656     ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 1657     return 0;  // CodeBuffer::expand failed
 1658   }
 1659 
 1660   int offset = __ offset();
 1661   __ save_frame(0);
 1662   __ JUMP(deopt_blob, temp_reg, 0); // sethi;jmp
 1663   __ delayed()-&gt;restore();
 1664 
 1665   assert(__ offset() - offset &lt;= (int) size_deopt_handler(), &quot;overflow&quot;);
 1666 
 1667   __ end_a_stub();
 1668   return offset;
 1669 
 1670 }
 1671 
 1672 // Given a register encoding, produce a Integer Register object
 1673 static Register reg_to_register_object(int register_encoding) {
 1674   assert(L5-&gt;encoding() == R_L5_enc &amp;&amp; G1-&gt;encoding() == R_G1_enc, &quot;right coding&quot;);
 1675   return as_Register(register_encoding);
 1676 }
 1677 
 1678 // Given a register encoding, produce a single-precision Float Register object
 1679 static FloatRegister reg_to_SingleFloatRegister_object(int register_encoding) {
 1680   assert(F5-&gt;encoding(FloatRegisterImpl::S) == R_F5_enc &amp;&amp; F12-&gt;encoding(FloatRegisterImpl::S) == R_F12_enc, &quot;right coding&quot;);
 1681   return as_SingleFloatRegister(register_encoding);
 1682 }
 1683 
 1684 // Given a register encoding, produce a double-precision Float Register object
 1685 static FloatRegister reg_to_DoubleFloatRegister_object(int register_encoding) {
 1686   assert(F4-&gt;encoding(FloatRegisterImpl::D) == R_F4_enc, &quot;right coding&quot;);
 1687   assert(F32-&gt;encoding(FloatRegisterImpl::D) == R_D32_enc, &quot;right coding&quot;);
 1688   return as_DoubleFloatRegister(register_encoding);
 1689 }
 1690 
 1691 const bool Matcher::match_rule_supported(int opcode) {
 1692   if (!has_match_rule(opcode))
 1693     return false;
 1694 
 1695   switch (opcode) {
 1696   case Op_CountLeadingZerosI:
 1697   case Op_CountLeadingZerosL:
 1698   case Op_CountTrailingZerosI:
 1699   case Op_CountTrailingZerosL:
 1700   case Op_PopCountI:
 1701   case Op_PopCountL:
 1702     if (!UsePopCountInstruction)
 1703       return false;
 1704   case Op_CompareAndSwapL:
 1705   case Op_CompareAndSwapP:
 1706     if (!VM_Version::supports_cx8())
 1707       return false;
 1708     break;
 1709   }
 1710 
 1711   return true;  // Per default match rules are supported.
 1712 }
 1713 
 1714 const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {
 1715 
 1716   // TODO
 1717   // identify extra cases that we might want to provide match rules for
 1718   // e.g. Op_ vector nodes and other intrinsics while guarding with vlen
 1719   bool ret_value = match_rule_supported(opcode);
 1720   // Add rules here.
 1721 
 1722   return ret_value;  // Per default match rules are supported.
 1723 }
 1724 
 1725 const bool Matcher::has_predicated_vectors(void) {
 1726   return false;
 1727 }
 1728 
 1729 const int Matcher::float_pressure(int default_pressure_threshold) {
 1730   return default_pressure_threshold;
 1731 }
 1732 
 1733 int Matcher::regnum_to_fpu_offset(int regnum) {
 1734   return regnum - 32; // The FP registers are in the second chunk
 1735 }
 1736 
 1737 #ifdef ASSERT
 1738 address last_rethrow = NULL;  // debugging aid for Rethrow encoding
 1739 #endif
 1740 
 1741 // Vector width in bytes
 1742 const int Matcher::vector_width_in_bytes(BasicType bt) {
 1743   assert(MaxVectorSize == 8, &quot;&quot;);
 1744   return 8;
 1745 }
 1746 
 1747 // Vector ideal reg
 1748 const uint Matcher::vector_ideal_reg(int size) {
 1749   assert(MaxVectorSize == 8, &quot;&quot;);
 1750   return Op_RegD;
 1751 }
 1752 
 1753 const uint Matcher::vector_shift_count_ideal_reg(int size) {
 1754   fatal(&quot;vector shift is not supported&quot;);
 1755   return Node::NotAMachineReg;
 1756 }
 1757 
 1758 // Limits on vector size (number of elements) loaded into vector.
 1759 const int Matcher::max_vector_size(const BasicType bt) {
 1760   assert(is_java_primitive(bt), &quot;only primitive type vectors&quot;);
 1761   return vector_width_in_bytes(bt)/type2aelembytes(bt);
 1762 }
 1763 
 1764 const int Matcher::min_vector_size(const BasicType bt) {
 1765   return max_vector_size(bt); // Same as max.
 1766 }
 1767 
 1768 // SPARC doesn&#39;t support misaligned vectors store/load.
 1769 const bool Matcher::misaligned_vectors_ok() {
 1770   return false;
 1771 }
 1772 
 1773 // Current (2013) SPARC platforms need to read original key
 1774 // to construct decryption expanded key
 1775 const bool Matcher::pass_original_key_for_aes() {
 1776   return true;
 1777 }
 1778 
 1779 // NOTE: All currently supported SPARC HW provides fast conversion.
 1780 const bool Matcher::convL2FSupported(void) { return true; }
 1781 
 1782 // Is this branch offset short enough that a short branch can be used?
 1783 //
 1784 // NOTE: If the platform does not provide any short branch variants, then
 1785 //       this method should return false for offset 0.
 1786 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1787   // The passed offset is relative to address of the branch.
 1788   // Don&#39;t need to adjust the offset.
 1789   return UseCBCond &amp;&amp; Assembler::is_simm12(offset);
 1790 }
 1791 
 1792 const bool Matcher::isSimpleConstant64(jlong value) {
 1793   // Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.
 1794   // Depends on optimizations in MacroAssembler::setx.
 1795   int hi = (int)(value &gt;&gt; 32);
 1796   int lo = (int)(value &amp; ~0);
 1797   return (hi == 0) || (hi == -1) || (lo == 0);
 1798 }
 1799 
 1800 // No scaling for the parameter the ClearArray node.
 1801 const bool Matcher::init_array_count_is_in_bytes = true;
 1802 
 1803 // No additional cost for CMOVL.
 1804 const int Matcher::long_cmove_cost() { return 0; }
 1805 
 1806 // CMOVF/CMOVD are expensive on e.g., T4 and SPARC64.
 1807 const int Matcher::float_cmove_cost() {
 1808   return VM_Version::has_fast_cmove() ? 0 : ConditionalMoveLimit;
 1809 }
 1810 
 1811 // Does the CPU require late expand (see block.cpp for description of late expand)?
 1812 const bool Matcher::require_postalloc_expand = false;
 1813 
 1814 // Do we need to mask the count passed to shift instructions or does
 1815 // the cpu only look at the lower 5/6 bits anyway?
 1816 const bool Matcher::need_masked_shift_count = false;
 1817 
 1818 // No support for generic vector operands.
 1819 const bool Matcher::supports_generic_vector_operands  = false;
 1820 
 1821 MachOper* Matcher::specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {
 1822   ShouldNotReachHere(); // generic vector operands not supported
 1823   return NULL;
 1824 }
 1825 
 1826 bool Matcher::is_generic_reg2reg_move(MachNode* m) {
 1827   ShouldNotReachHere();  // generic vector operands not supported
 1828   return false;
 1829 }
 1830 
 1831 bool Matcher::is_generic_vector(MachOper* opnd)  {
 1832   ShouldNotReachHere();  // generic vector operands not supported
 1833   return false;
 1834 }
 1835 
 1836 bool Matcher::narrow_oop_use_complex_address() {
 1837   assert(UseCompressedOops, &quot;only for compressed oops code&quot;);
 1838   return false;
 1839 }
 1840 
 1841 bool Matcher::narrow_klass_use_complex_address() {
 1842   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 1843   return false;
 1844 }
 1845 
 1846 bool Matcher::const_oop_prefer_decode() {
 1847   // TODO: Check if loading ConP from TOC in heap-based mode is better:
 1848   // Prefer ConN+DecodeN over ConP in simple compressed oops mode.
 1849   // return CompressedOops::base() == NULL;
 1850   return true;
 1851 }
 1852 
 1853 bool Matcher::const_klass_prefer_decode() {
 1854   // TODO: Check if loading ConP from TOC in heap-based mode is better:
 1855   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
 1856   // return CompressedKlassPointers::base() == NULL;
 1857   return true;
 1858 }
 1859 
 1860 // Is it better to copy float constants, or load them directly from memory?
 1861 // Intel can load a float constant from a direct address, requiring no
 1862 // extra registers.  Most RISCs will have to materialize an address into a
 1863 // register first, so they would do better to copy the constant from stack.
 1864 const bool Matcher::rematerialize_float_constants = false;
 1865 
 1866 // If CPU can load and store mis-aligned doubles directly then no fixup is
 1867 // needed.  Else we split the double into 2 integer pieces and move it
 1868 // piece-by-piece.  Only happens when passing doubles into C code as the
 1869 // Java calling convention forces doubles to be aligned.
 1870 const bool Matcher::misaligned_doubles_ok = true;
 1871 
 1872 // No-op on SPARC.
 1873 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
 1874 }
 1875 
 1876 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.
 1877 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 1878 
 1879 // Are floats converted to double when stored to stack during deoptimization?
 1880 // Sparc does not handle callee-save floats.
 1881 bool Matcher::float_in_double() { return false; }
 1882 
 1883 // Do ints take an entire long register or just half?
 1884 // Note that we if-def off of _LP64.
 1885 // The relevant question is how the int is callee-saved.  In _LP64
 1886 // the whole long is written but de-opt&#39;ing will have to extract
 1887 // the relevant 32 bits, in not-_LP64 only the low 32 bits is written.
 1888 const bool Matcher::int_in_long = true;
 1889 
 1890 // Return whether or not this register is ever used as an argument.  This
 1891 // function is used on startup to build the trampoline stubs in generateOptoStub.
 1892 // Registers not mentioned will be killed by the VM call in the trampoline, and
 1893 // arguments in those registers not be available to the callee.
 1894 bool Matcher::can_be_java_arg( int reg ) {
 1895   // Standard sparc 6 args in registers
 1896   if( reg == R_I0_num ||
 1897       reg == R_I1_num ||
 1898       reg == R_I2_num ||
 1899       reg == R_I3_num ||
 1900       reg == R_I4_num ||
 1901       reg == R_I5_num ) return true;
 1902   // 64-bit builds can pass 64-bit pointers and longs in
 1903   // the high I registers
 1904   if( reg == R_I0H_num ||
 1905       reg == R_I1H_num ||
 1906       reg == R_I2H_num ||
 1907       reg == R_I3H_num ||
 1908       reg == R_I4H_num ||
 1909       reg == R_I5H_num ) return true;
 1910 
 1911   if ((UseCompressedOops) &amp;&amp; (reg == R_G6_num || reg == R_G6H_num)) {
 1912     return true;
 1913   }
 1914 
 1915   // A few float args in registers
 1916   if( reg &gt;= R_F0_num &amp;&amp; reg &lt;= R_F7_num ) return true;
 1917 
 1918   return false;
 1919 }
 1920 
 1921 bool Matcher::is_spillable_arg( int reg ) {
 1922   return can_be_java_arg(reg);
 1923 }
 1924 
 1925 bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
 1926   // Use hardware SDIVX instruction when it is
 1927   // faster than a code which use multiply.
 1928   return VM_Version::has_fast_idiv();
 1929 }
 1930 
 1931 // Register for DIVI projection of divmodI
 1932 RegMask Matcher::divI_proj_mask() {
 1933   ShouldNotReachHere();
 1934   return RegMask();
 1935 }
 1936 
 1937 // Register for MODI projection of divmodI
 1938 RegMask Matcher::modI_proj_mask() {
 1939   ShouldNotReachHere();
 1940   return RegMask();
 1941 }
 1942 
 1943 // Register for DIVL projection of divmodL
 1944 RegMask Matcher::divL_proj_mask() {
 1945   ShouldNotReachHere();
 1946   return RegMask();
 1947 }
 1948 
 1949 // Register for MODL projection of divmodL
 1950 RegMask Matcher::modL_proj_mask() {
 1951   ShouldNotReachHere();
 1952   return RegMask();
 1953 }
 1954 
 1955 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1956   return L7_REGP_mask();
 1957 }
 1958 
 1959 
 1960 const bool Matcher::convi2l_type_required = true;
 1961 
 1962 // Should the Matcher clone shifts on addressing modes, expecting them
 1963 // to be subsumed into complex addressing expressions or compute them
 1964 // into registers?
 1965 bool Matcher::clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {
 1966   return clone_base_plus_offset_address(m, mstack, address_visited);
 1967 }
 1968 
 1969 void Compile::reshape_address(AddPNode* addp) {
 1970 }
 1971 
 1972 %}
 1973 
 1974 
 1975 // The intptr_t operand types, defined by textual substitution.
 1976 // (Cf. opto/type.hpp.  This lets us avoid many, many other ifdefs.)
 1977 #define immX      immL
 1978 #define immX13    immL13
 1979 #define immX13m7  immL13m7
 1980 #define iRegX     iRegL
 1981 #define g1RegX    g1RegL
 1982 
 1983 //----------ENCODING BLOCK-----------------------------------------------------
 1984 // This block specifies the encoding classes used by the compiler to output
 1985 // byte streams.  Encoding classes are parameterized macros used by
 1986 // Machine Instruction Nodes in order to generate the bit encoding of the
 1987 // instruction.  Operands specify their base encoding interface with the
 1988 // interface keyword.  There are currently supported four interfaces,
 1989 // REG_INTER, CONST_INTER, MEMORY_INTER, &amp; COND_INTER.  REG_INTER causes an
 1990 // operand to generate a function which returns its register number when
 1991 // queried.   CONST_INTER causes an operand to generate a function which
 1992 // returns the value of the constant when queried.  MEMORY_INTER causes an
 1993 // operand to generate four functions which return the Base Register, the
 1994 // Index Register, the Scale Value, and the Offset Value of the operand when
 1995 // queried.  COND_INTER causes an operand to generate six functions which
 1996 // return the encoding code (ie - encoding bits for the instruction)
 1997 // associated with each basic boolean condition for a conditional instruction.
 1998 //
 1999 // Instructions specify two basic values for encoding.  Again, a function
 2000 // is available to check if the constant displacement is an oop. They use the
 2001 // ins_encode keyword to specify their encoding classes (which must be
 2002 // a sequence of enc_class names, and their parameters, specified in
 2003 // the encoding block), and they use the
 2004 // opcode keyword to specify, in order, their primary, secondary, and
 2005 // tertiary opcode.  Only the opcode sections which a particular instruction
 2006 // needs for encoding need to be specified.
 2007 encode %{
 2008   enc_class enc_untested %{
 2009 #ifdef ASSERT
 2010     MacroAssembler _masm(&amp;cbuf);
 2011     __ untested(&quot;encoding&quot;);
 2012 #endif
 2013   %}
 2014 
 2015   enc_class form3_mem_reg( memory mem, iRegI dst ) %{
 2016     emit_form3_mem_reg(cbuf, ra_, this, $primary, $tertiary,
 2017                        $mem$$base, $mem$$disp, $mem$$index, $dst$$reg);
 2018   %}
 2019 
 2020   enc_class simple_form3_mem_reg( memory mem, iRegI dst ) %{
 2021     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1,
 2022                        $mem$$base, $mem$$disp, $mem$$index, $dst$$reg);
 2023   %}
 2024 
 2025   enc_class form3_mem_prefetch_read( memory mem ) %{
 2026     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1,
 2027                        $mem$$base, $mem$$disp, $mem$$index, 0/*prefetch function many-reads*/);
 2028   %}
 2029 
 2030   enc_class form3_mem_prefetch_write( memory mem ) %{
 2031     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1,
 2032                        $mem$$base, $mem$$disp, $mem$$index, 2/*prefetch function many-writes*/);
 2033   %}
 2034 
 2035   enc_class form3_mem_reg_long_unaligned_marshal( memory mem, iRegL reg ) %{
 2036     assert(Assembler::is_simm13($mem$$disp  ), &quot;need disp and disp+4&quot;);
 2037     assert(Assembler::is_simm13($mem$$disp+4), &quot;need disp and disp+4&quot;);
 2038     guarantee($mem$$index == R_G0_enc, &quot;double index?&quot;);
 2039     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1, $mem$$base, $mem$$disp+4, R_G0_enc, R_O7_enc );
 2040     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1, $mem$$base, $mem$$disp,   R_G0_enc, $reg$$reg );
 2041     emit3_simm13( cbuf, Assembler::arith_op, $reg$$reg, Assembler::sllx_op3, $reg$$reg, 0x1020 );
 2042     emit3( cbuf, Assembler::arith_op, $reg$$reg, Assembler::or_op3, $reg$$reg, 0, R_O7_enc );
 2043   %}
 2044 
 2045   enc_class form3_mem_reg_double_unaligned( memory mem, RegD_low reg ) %{
 2046     assert(Assembler::is_simm13($mem$$disp  ), &quot;need disp and disp+4&quot;);
 2047     assert(Assembler::is_simm13($mem$$disp+4), &quot;need disp and disp+4&quot;);
 2048     guarantee($mem$$index == R_G0_enc, &quot;double index?&quot;);
 2049     // Load long with 2 instructions
 2050     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1, $mem$$base, $mem$$disp,   R_G0_enc, $reg$$reg+0 );
 2051     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1, $mem$$base, $mem$$disp+4, R_G0_enc, $reg$$reg+1 );
 2052   %}
 2053 
 2054   //%%% form3_mem_plus_4_reg is a hack--get rid of it
 2055   enc_class form3_mem_plus_4_reg( memory mem, iRegI dst ) %{
 2056     guarantee($mem$$disp, &quot;cannot offset a reg-reg operand by 4&quot;);
 2057     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1, $mem$$base, $mem$$disp + 4, $mem$$index, $dst$$reg);
 2058   %}
 2059 
 2060   enc_class form3_g0_rs2_rd_move( iRegI rs2, iRegI rd ) %{
 2061     // Encode a reg-reg copy.  If it is useless, then empty encoding.
 2062     if( $rs2$$reg != $rd$$reg )
 2063       emit3( cbuf, Assembler::arith_op, $rd$$reg, Assembler::or_op3, 0, 0, $rs2$$reg );
 2064   %}
 2065 
 2066   // Target lo half of long
 2067   enc_class form3_g0_rs2_rd_move_lo( iRegI rs2, iRegL rd ) %{
 2068     // Encode a reg-reg copy.  If it is useless, then empty encoding.
 2069     if( $rs2$$reg != LONG_LO_REG($rd$$reg) )
 2070       emit3( cbuf, Assembler::arith_op, LONG_LO_REG($rd$$reg), Assembler::or_op3, 0, 0, $rs2$$reg );
 2071   %}
 2072 
 2073   // Source lo half of long
 2074   enc_class form3_g0_rs2_rd_move_lo2( iRegL rs2, iRegI rd ) %{
 2075     // Encode a reg-reg copy.  If it is useless, then empty encoding.
 2076     if( LONG_LO_REG($rs2$$reg) != $rd$$reg )
 2077       emit3( cbuf, Assembler::arith_op, $rd$$reg, Assembler::or_op3, 0, 0, LONG_LO_REG($rs2$$reg) );
 2078   %}
 2079 
 2080   // Target hi half of long
 2081   enc_class form3_rs1_rd_copysign_hi( iRegI rs1, iRegL rd ) %{
 2082     emit3_simm13( cbuf, Assembler::arith_op, $rd$$reg, Assembler::sra_op3, $rs1$$reg, 31 );
 2083   %}
 2084 
 2085   // Source lo half of long, and leave it sign extended.
 2086   enc_class form3_rs1_rd_signextend_lo1( iRegL rs1, iRegI rd ) %{
 2087     // Sign extend low half
 2088     emit3( cbuf, Assembler::arith_op, $rd$$reg, Assembler::sra_op3, $rs1$$reg, 0, 0 );
 2089   %}
 2090 
 2091   // Source hi half of long, and leave it sign extended.
 2092   enc_class form3_rs1_rd_copy_hi1( iRegL rs1, iRegI rd ) %{
 2093     // Shift high half to low half
 2094     emit3_simm13( cbuf, Assembler::arith_op, $rd$$reg, Assembler::srlx_op3, $rs1$$reg, 32 );
 2095   %}
 2096 
 2097   // Source hi half of long
 2098   enc_class form3_g0_rs2_rd_move_hi2( iRegL rs2, iRegI rd ) %{
 2099     // Encode a reg-reg copy.  If it is useless, then empty encoding.
 2100     if( LONG_HI_REG($rs2$$reg) != $rd$$reg )
 2101       emit3( cbuf, Assembler::arith_op, $rd$$reg, Assembler::or_op3, 0, 0, LONG_HI_REG($rs2$$reg) );
 2102   %}
 2103 
 2104   enc_class form3_rs1_rs2_rd( iRegI rs1, iRegI rs2, iRegI rd ) %{
 2105     emit3( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, 0, $rs2$$reg );
 2106   %}
 2107 
 2108   enc_class enc_to_bool( iRegI src, iRegI dst ) %{
 2109     emit3       ( cbuf, Assembler::arith_op,         0, Assembler::subcc_op3, 0, 0, $src$$reg );
 2110     emit3_simm13( cbuf, Assembler::arith_op, $dst$$reg, Assembler::addc_op3 , 0, 0 );
 2111   %}
 2112 
 2113   enc_class enc_ltmask( iRegI p, iRegI q, iRegI dst ) %{
 2114     emit3       ( cbuf, Assembler::arith_op,         0, Assembler::subcc_op3, $p$$reg, 0, $q$$reg );
 2115     // clear if nothing else is happening
 2116     emit3_simm13( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3, 0,  0 );
 2117     // blt,a,pn done
 2118     emit2_19    ( cbuf, Assembler::branch_op, 1/*annul*/, Assembler::less, Assembler::bp_op2, Assembler::icc, 0/*predict not taken*/, 2 );
 2119     // mov dst,-1 in delay slot
 2120     emit3_simm13( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3, 0, -1 );
 2121   %}
 2122 
 2123   enc_class form3_rs1_imm5_rd( iRegI rs1, immU5 imm5, iRegI rd ) %{
 2124     emit3_simm13( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, $imm5$$constant &amp; 0x1F );
 2125   %}
 2126 
 2127   enc_class form3_sd_rs1_imm6_rd( iRegL rs1, immU6 imm6, iRegL rd ) %{
 2128     emit3_simm13( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, ($imm6$$constant &amp; 0x3F) | 0x1000 );
 2129   %}
 2130 
 2131   enc_class form3_sd_rs1_rs2_rd( iRegL rs1, iRegI rs2, iRegL rd ) %{
 2132     emit3( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, 0x80, $rs2$$reg );
 2133   %}
 2134 
 2135   enc_class form3_rs1_simm13_rd( iRegI rs1, immI13 simm13, iRegI rd ) %{
 2136     emit3_simm13( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, $simm13$$constant );
 2137   %}
 2138 
 2139   enc_class move_return_pc_to_o1() %{
 2140     emit3_simm13( cbuf, Assembler::arith_op, R_O1_enc, Assembler::add_op3, R_O7_enc, frame::pc_return_offset );
 2141   %}
 2142 
 2143   /* %%% merge with enc_to_bool */
 2144   enc_class enc_convP2B( iRegI dst, iRegP src ) %{
 2145     MacroAssembler _masm(&amp;cbuf);
 2146 
 2147     Register   src_reg = reg_to_register_object($src$$reg);
 2148     Register   dst_reg = reg_to_register_object($dst$$reg);
 2149     __ movr(Assembler::rc_nz, src_reg, 1, dst_reg);
 2150   %}
 2151 
 2152   enc_class enc_cadd_cmpLTMask( iRegI p, iRegI q, iRegI y, iRegI tmp ) %{
 2153     // (Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)))
 2154     MacroAssembler _masm(&amp;cbuf);
 2155 
 2156     Register   p_reg = reg_to_register_object($p$$reg);
 2157     Register   q_reg = reg_to_register_object($q$$reg);
 2158     Register   y_reg = reg_to_register_object($y$$reg);
 2159     Register tmp_reg = reg_to_register_object($tmp$$reg);
 2160 
 2161     __ subcc( p_reg, q_reg,   p_reg );
 2162     __ add  ( p_reg, y_reg, tmp_reg );
 2163     __ movcc( Assembler::less, false, Assembler::icc, tmp_reg, p_reg );
 2164   %}
 2165 
 2166   enc_class form_d2i_helper(regD src, regF dst) %{
 2167     // fcmp %fcc0,$src,$src
 2168     emit3( cbuf, Assembler::arith_op , Assembler::fcc0, Assembler::fpop2_op3, $src$$reg, Assembler::fcmpd_opf, $src$$reg );
 2169     // branch %fcc0 not-nan, predict taken
 2170     emit2_19( cbuf, Assembler::branch_op, 0/*annul*/, Assembler::f_ordered, Assembler::fbp_op2, Assembler::fcc0, 1/*predict taken*/, 4 );
 2171     // fdtoi $src,$dst
 2172     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fdtoi_opf, $src$$reg );
 2173     // fitos $dst,$dst (if nan)
 2174     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fitos_opf, $dst$$reg );
 2175     // clear $dst (if nan)
 2176     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3, $dst$$reg, Assembler::fsubs_opf, $dst$$reg );
 2177     // carry on here...
 2178   %}
 2179 
 2180   enc_class form_d2l_helper(regD src, regD dst) %{
 2181     // fcmp %fcc0,$src,$src  check for NAN
 2182     emit3( cbuf, Assembler::arith_op , Assembler::fcc0, Assembler::fpop2_op3, $src$$reg, Assembler::fcmpd_opf, $src$$reg );
 2183     // branch %fcc0 not-nan, predict taken
 2184     emit2_19( cbuf, Assembler::branch_op, 0/*annul*/, Assembler::f_ordered, Assembler::fbp_op2, Assembler::fcc0, 1/*predict taken*/, 4 );
 2185     // fdtox $src,$dst   convert in delay slot
 2186     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fdtox_opf, $src$$reg );
 2187     // fxtod $dst,$dst  (if nan)
 2188     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fxtod_opf, $dst$$reg );
 2189     // clear $dst (if nan)
 2190     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3, $dst$$reg, Assembler::fsubd_opf, $dst$$reg );
 2191     // carry on here...
 2192   %}
 2193 
 2194   enc_class form_f2i_helper(regF src, regF dst) %{
 2195     // fcmps %fcc0,$src,$src
 2196     emit3( cbuf, Assembler::arith_op , Assembler::fcc0, Assembler::fpop2_op3, $src$$reg, Assembler::fcmps_opf, $src$$reg );
 2197     // branch %fcc0 not-nan, predict taken
 2198     emit2_19( cbuf, Assembler::branch_op, 0/*annul*/, Assembler::f_ordered, Assembler::fbp_op2, Assembler::fcc0, 1/*predict taken*/, 4 );
 2199     // fstoi $src,$dst
 2200     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fstoi_opf, $src$$reg );
 2201     // fitos $dst,$dst (if nan)
 2202     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fitos_opf, $dst$$reg );
 2203     // clear $dst (if nan)
 2204     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3, $dst$$reg, Assembler::fsubs_opf, $dst$$reg );
 2205     // carry on here...
 2206   %}
 2207 
 2208   enc_class form_f2l_helper(regF src, regD dst) %{
 2209     // fcmps %fcc0,$src,$src
 2210     emit3( cbuf, Assembler::arith_op , Assembler::fcc0, Assembler::fpop2_op3, $src$$reg, Assembler::fcmps_opf, $src$$reg );
 2211     // branch %fcc0 not-nan, predict taken
 2212     emit2_19( cbuf, Assembler::branch_op, 0/*annul*/, Assembler::f_ordered, Assembler::fbp_op2, Assembler::fcc0, 1/*predict taken*/, 4 );
 2213     // fstox $src,$dst
 2214     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fstox_opf, $src$$reg );
 2215     // fxtod $dst,$dst (if nan)
 2216     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fxtod_opf, $dst$$reg );
 2217     // clear $dst (if nan)
 2218     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3, $dst$$reg, Assembler::fsubd_opf, $dst$$reg );
 2219     // carry on here...
 2220   %}
 2221 
 2222   enc_class form3_opf_rs2F_rdF(regF rs2, regF rd) %{ emit3(cbuf,$secondary,$rd$$reg,$primary,0,$tertiary,$rs2$$reg); %}
 2223   enc_class form3_opf_rs2F_rdD(regF rs2, regD rd) %{ emit3(cbuf,$secondary,$rd$$reg,$primary,0,$tertiary,$rs2$$reg); %}
 2224   enc_class form3_opf_rs2D_rdF(regD rs2, regF rd) %{ emit3(cbuf,$secondary,$rd$$reg,$primary,0,$tertiary,$rs2$$reg); %}
 2225   enc_class form3_opf_rs2D_rdD(regD rs2, regD rd) %{ emit3(cbuf,$secondary,$rd$$reg,$primary,0,$tertiary,$rs2$$reg); %}
 2226 
 2227   enc_class form3_opf_rs2D_lo_rdF(regD rs2, regF rd) %{ emit3(cbuf,$secondary,$rd$$reg,$primary,0,$tertiary,$rs2$$reg+1); %}
 2228 
 2229   enc_class form3_opf_rs2D_hi_rdD_hi(regD rs2, regD rd) %{ emit3(cbuf,$secondary,$rd$$reg,$primary,0,$tertiary,$rs2$$reg); %}
 2230   enc_class form3_opf_rs2D_lo_rdD_lo(regD rs2, regD rd) %{ emit3(cbuf,$secondary,$rd$$reg+1,$primary,0,$tertiary,$rs2$$reg+1); %}
 2231 
 2232   enc_class form3_opf_rs1F_rs2F_rdF( regF rs1, regF rs2, regF rd ) %{
 2233     emit3( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, $tertiary, $rs2$$reg );
 2234   %}
 2235 
 2236   enc_class form3_opf_rs1D_rs2D_rdD( regD rs1, regD rs2, regD rd ) %{
 2237     emit3( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, $tertiary, $rs2$$reg );
 2238   %}
 2239 
 2240   enc_class form3_opf_rs1F_rs2F_fcc( regF rs1, regF rs2, flagsRegF fcc ) %{
 2241     emit3( cbuf, $secondary, $fcc$$reg, $primary, $rs1$$reg, $tertiary, $rs2$$reg );
 2242   %}
 2243 
 2244   enc_class form3_opf_rs1D_rs2D_fcc( regD rs1, regD rs2, flagsRegF fcc ) %{
 2245     emit3( cbuf, $secondary, $fcc$$reg, $primary, $rs1$$reg, $tertiary, $rs2$$reg );
 2246   %}
 2247 
 2248   enc_class form3_convI2F(regF rs2, regF rd) %{
 2249     emit3(cbuf,Assembler::arith_op,$rd$$reg,Assembler::fpop1_op3,0,$secondary,$rs2$$reg);
 2250   %}
 2251 
 2252   // Encloding class for traceable jumps
 2253   enc_class form_jmpl(g3RegP dest) %{
 2254     emit_jmpl(cbuf, $dest$$reg);
 2255   %}
 2256 
 2257   enc_class form_jmpl_set_exception_pc(g1RegP dest) %{
 2258     emit_jmpl_set_exception_pc(cbuf, $dest$$reg);
 2259   %}
 2260 
 2261   enc_class form2_nop() %{
 2262     emit_nop(cbuf);
 2263   %}
 2264 
 2265   enc_class form2_illtrap() %{
 2266     emit_illtrap(cbuf);
 2267   %}
 2268 
 2269 
 2270   // Compare longs and convert into -1, 0, 1.
 2271   enc_class cmpl_flag( iRegL src1, iRegL src2, iRegI dst ) %{
 2272     // CMP $src1,$src2
 2273     emit3( cbuf, Assembler::arith_op, 0, Assembler::subcc_op3, $src1$$reg, 0, $src2$$reg );
 2274     // blt,a,pn done
 2275     emit2_19( cbuf, Assembler::branch_op, 1/*annul*/, Assembler::less   , Assembler::bp_op2, Assembler::xcc, 0/*predict not taken*/, 5 );
 2276     // mov dst,-1 in delay slot
 2277     emit3_simm13( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3, 0, -1 );
 2278     // bgt,a,pn done
 2279     emit2_19( cbuf, Assembler::branch_op, 1/*annul*/, Assembler::greater, Assembler::bp_op2, Assembler::xcc, 0/*predict not taken*/, 3 );
 2280     // mov dst,1 in delay slot
 2281     emit3_simm13( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3, 0,  1 );
 2282     // CLR    $dst
 2283     emit3( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3 , 0, 0, 0 );
 2284   %}
 2285 
 2286   enc_class enc_PartialSubtypeCheck() %{
 2287     MacroAssembler _masm(&amp;cbuf);
 2288     __ call(StubRoutines::Sparc::partial_subtype_check(), relocInfo::runtime_call_type);
 2289     __ delayed()-&gt;nop();
 2290   %}
 2291 
 2292   enc_class enc_bp( label labl, cmpOp cmp, flagsReg cc ) %{
 2293     MacroAssembler _masm(&amp;cbuf);
 2294     Label* L = $labl$$label;
 2295     Assembler::Predict predict_taken =
 2296       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 2297 
 2298     __ bp( (Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 2299     __ delayed()-&gt;nop();
 2300   %}
 2301 
 2302   enc_class enc_bpr( label labl, cmpOp_reg cmp, iRegI op1 ) %{
 2303     MacroAssembler _masm(&amp;cbuf);
 2304     Label* L = $labl$$label;
 2305     Assembler::Predict predict_taken =
 2306       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 2307 
 2308     __ bpr( (Assembler::RCondition)($cmp$$cmpcode), false, predict_taken, as_Register($op1$$reg), *L);
 2309     __ delayed()-&gt;nop();
 2310   %}
 2311 
 2312   enc_class enc_cmov_reg( cmpOp cmp, iRegI dst, iRegI src, immI pcc) %{
 2313     int op = (Assembler::arith_op &lt;&lt; 30) |
 2314              ($dst$$reg &lt;&lt; 25) |
 2315              (Assembler::movcc_op3 &lt;&lt; 19) |
 2316              (1 &lt;&lt; 18) |                    // cc2 bit for &#39;icc&#39;
 2317              ($cmp$$cmpcode &lt;&lt; 14) |
 2318              (0 &lt;&lt; 13) |                    // select register move
 2319              ($pcc$$constant &lt;&lt; 11) |       // cc1, cc0 bits for &#39;icc&#39; or &#39;xcc&#39;
 2320              ($src$$reg &lt;&lt; 0);
 2321     cbuf.insts()-&gt;emit_int32(op);
 2322   %}
 2323 
 2324   enc_class enc_cmov_imm( cmpOp cmp, iRegI dst, immI11 src, immI pcc ) %{
 2325     int simm11 = $src$$constant &amp; ((1&lt;&lt;11)-1); // Mask to 11 bits
 2326     int op = (Assembler::arith_op &lt;&lt; 30) |
 2327              ($dst$$reg &lt;&lt; 25) |
 2328              (Assembler::movcc_op3 &lt;&lt; 19) |
 2329              (1 &lt;&lt; 18) |                    // cc2 bit for &#39;icc&#39;
 2330              ($cmp$$cmpcode &lt;&lt; 14) |
 2331              (1 &lt;&lt; 13) |                    // select immediate move
 2332              ($pcc$$constant &lt;&lt; 11) |       // cc1, cc0 bits for &#39;icc&#39;
 2333              (simm11 &lt;&lt; 0);
 2334     cbuf.insts()-&gt;emit_int32(op);
 2335   %}
 2336 
 2337   enc_class enc_cmov_reg_f( cmpOpF cmp, iRegI dst, iRegI src, flagsRegF fcc ) %{
 2338     int op = (Assembler::arith_op &lt;&lt; 30) |
 2339              ($dst$$reg &lt;&lt; 25) |
 2340              (Assembler::movcc_op3 &lt;&lt; 19) |
 2341              (0 &lt;&lt; 18) |                    // cc2 bit for &#39;fccX&#39;
 2342              ($cmp$$cmpcode &lt;&lt; 14) |
 2343              (0 &lt;&lt; 13) |                    // select register move
 2344              ($fcc$$reg &lt;&lt; 11) |            // cc1, cc0 bits for fcc0-fcc3
 2345              ($src$$reg &lt;&lt; 0);
 2346     cbuf.insts()-&gt;emit_int32(op);
 2347   %}
 2348 
 2349   enc_class enc_cmov_imm_f( cmpOp cmp, iRegI dst, immI11 src, flagsRegF fcc ) %{
 2350     int simm11 = $src$$constant &amp; ((1&lt;&lt;11)-1); // Mask to 11 bits
 2351     int op = (Assembler::arith_op &lt;&lt; 30) |
 2352              ($dst$$reg &lt;&lt; 25) |
 2353              (Assembler::movcc_op3 &lt;&lt; 19) |
 2354              (0 &lt;&lt; 18) |                    // cc2 bit for &#39;fccX&#39;
 2355              ($cmp$$cmpcode &lt;&lt; 14) |
 2356              (1 &lt;&lt; 13) |                    // select immediate move
 2357              ($fcc$$reg &lt;&lt; 11) |            // cc1, cc0 bits for fcc0-fcc3
 2358              (simm11 &lt;&lt; 0);
 2359     cbuf.insts()-&gt;emit_int32(op);
 2360   %}
 2361 
 2362   enc_class enc_cmovf_reg( cmpOp cmp, regD dst, regD src, immI pcc ) %{
 2363     int op = (Assembler::arith_op &lt;&lt; 30) |
 2364              ($dst$$reg &lt;&lt; 25) |
 2365              (Assembler::fpop2_op3 &lt;&lt; 19) |
 2366              (0 &lt;&lt; 18) |
 2367              ($cmp$$cmpcode &lt;&lt; 14) |
 2368              (1 &lt;&lt; 13) |                    // select register move
 2369              ($pcc$$constant &lt;&lt; 11) |       // cc1-cc0 bits for &#39;icc&#39; or &#39;xcc&#39;
 2370              ($primary &lt;&lt; 5) |              // select single, double or quad
 2371              ($src$$reg &lt;&lt; 0);
 2372     cbuf.insts()-&gt;emit_int32(op);
 2373   %}
 2374 
 2375   enc_class enc_cmovff_reg( cmpOpF cmp, flagsRegF fcc, regD dst, regD src ) %{
 2376     int op = (Assembler::arith_op &lt;&lt; 30) |
 2377              ($dst$$reg &lt;&lt; 25) |
 2378              (Assembler::fpop2_op3 &lt;&lt; 19) |
 2379              (0 &lt;&lt; 18) |
 2380              ($cmp$$cmpcode &lt;&lt; 14) |
 2381              ($fcc$$reg &lt;&lt; 11) |            // cc2-cc0 bits for &#39;fccX&#39;
 2382              ($primary &lt;&lt; 5) |              // select single, double or quad
 2383              ($src$$reg &lt;&lt; 0);
 2384     cbuf.insts()-&gt;emit_int32(op);
 2385   %}
 2386 
 2387   // Used by the MIN/MAX encodings.  Same as a CMOV, but
 2388   // the condition comes from opcode-field instead of an argument.
 2389   enc_class enc_cmov_reg_minmax( iRegI dst, iRegI src ) %{
 2390     int op = (Assembler::arith_op &lt;&lt; 30) |
 2391              ($dst$$reg &lt;&lt; 25) |
 2392              (Assembler::movcc_op3 &lt;&lt; 19) |
 2393              (1 &lt;&lt; 18) |                    // cc2 bit for &#39;icc&#39;
 2394              ($primary &lt;&lt; 14) |
 2395              (0 &lt;&lt; 13) |                    // select register move
 2396              (0 &lt;&lt; 11) |                    // cc1, cc0 bits for &#39;icc&#39;
 2397              ($src$$reg &lt;&lt; 0);
 2398     cbuf.insts()-&gt;emit_int32(op);
 2399   %}
 2400 
 2401   enc_class enc_cmov_reg_minmax_long( iRegL dst, iRegL src ) %{
 2402     int op = (Assembler::arith_op &lt;&lt; 30) |
 2403              ($dst$$reg &lt;&lt; 25) |
 2404              (Assembler::movcc_op3 &lt;&lt; 19) |
 2405              (6 &lt;&lt; 16) |                    // cc2 bit for &#39;xcc&#39;
 2406              ($primary &lt;&lt; 14) |
 2407              (0 &lt;&lt; 13) |                    // select register move
 2408              (0 &lt;&lt; 11) |                    // cc1, cc0 bits for &#39;icc&#39;
 2409              ($src$$reg &lt;&lt; 0);
 2410     cbuf.insts()-&gt;emit_int32(op);
 2411   %}
 2412 
 2413   enc_class Set13( immI13 src, iRegI rd ) %{
 2414     emit3_simm13( cbuf, Assembler::arith_op, $rd$$reg, Assembler::or_op3, 0, $src$$constant );
 2415   %}
 2416 
 2417   enc_class SetHi22( immI src, iRegI rd ) %{
 2418     emit2_22( cbuf, Assembler::branch_op, $rd$$reg, Assembler::sethi_op2, $src$$constant );
 2419   %}
 2420 
 2421   enc_class Set32( immI src, iRegI rd ) %{
 2422     MacroAssembler _masm(&amp;cbuf);
 2423     __ set($src$$constant, reg_to_register_object($rd$$reg));
 2424   %}
 2425 
 2426   enc_class call_epilog %{
 2427     if( VerifyStackAtCalls ) {
 2428       MacroAssembler _masm(&amp;cbuf);
 2429       int framesize = ra_-&gt;C-&gt;output()-&gt;frame_size_in_bytes();
 2430       Register temp_reg = G3;
 2431       __ add(SP, framesize, temp_reg);
 2432       __ cmp(temp_reg, FP);
 2433       __ breakpoint_trap(Assembler::notEqual, Assembler::ptr_cc);
 2434     }
 2435   %}
 2436 
 2437   // Long values come back from native calls in O0:O1 in the 32-bit VM, copy the value
 2438   // to G1 so the register allocator will not have to deal with the misaligned register
 2439   // pair.
 2440   enc_class adjust_long_from_native_call %{
 2441   %}
 2442 
 2443   enc_class Java_To_Runtime (method meth) %{    // CALL Java_To_Runtime
 2444     // CALL directly to the runtime
 2445     // The user of this is responsible for ensuring that R_L7 is empty (killed).
 2446     emit_call_reloc(cbuf, $meth$$method, runtime_call_Relocation::spec(), /*preserve_g2=*/true);
 2447   %}
 2448 
 2449   enc_class preserve_SP %{
 2450     MacroAssembler _masm(&amp;cbuf);
 2451     __ mov(SP, L7_mh_SP_save);
 2452   %}
 2453 
 2454   enc_class restore_SP %{
 2455     MacroAssembler _masm(&amp;cbuf);
 2456     __ mov(L7_mh_SP_save, SP);
 2457   %}
 2458 
 2459   enc_class Java_Static_Call (method meth) %{    // JAVA STATIC CALL
 2460     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to determine
 2461     // who we intended to call.
 2462     if (!_method) {
 2463       emit_call_reloc(cbuf, $meth$$method, runtime_call_Relocation::spec());
 2464     } else {
 2465       int method_index = resolved_method_index(cbuf);
 2466       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 2467                                                   : static_call_Relocation::spec(method_index);
 2468       emit_call_reloc(cbuf, $meth$$method, rspec);
 2469 
 2470       // Emit stub for static call.
 2471       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 2472       if (stub == NULL) {
 2473         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 2474         return;
 2475       }
 2476     }
 2477   %}
 2478 
 2479   enc_class Java_Dynamic_Call (method meth) %{    // JAVA DYNAMIC CALL
 2480     MacroAssembler _masm(&amp;cbuf);
 2481     __ set_inst_mark();
 2482     int vtable_index = this-&gt;_vtable_index;
 2483     // MachCallDynamicJavaNode::ret_addr_offset uses this same test
 2484     if (vtable_index &lt; 0) {
 2485       // must be invalid_vtable_index, not nonvirtual_vtable_index
 2486       assert(vtable_index == Method::invalid_vtable_index, &quot;correct sentinel value&quot;);
 2487       Register G5_ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
 2488       assert(G5_ic_reg == G5_inline_cache_reg, &quot;G5_inline_cache_reg used in assemble_ic_buffer_code()&quot;);
 2489       assert(G5_ic_reg == G5_megamorphic_method, &quot;G5_megamorphic_method used in megamorphic call stub&quot;);
 2490       __ ic_call((address)$meth$$method, /*emit_delay=*/true, resolved_method_index(cbuf));
 2491     } else {
 2492       assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
 2493       // Just go thru the vtable
 2494       // get receiver klass (receiver already checked for non-null)
 2495       // If we end up going thru a c2i adapter interpreter expects method in G5
 2496       int off = __ offset();
 2497       __ load_klass(O0, G3_scratch);
 2498       int klass_load_size;
 2499       if (UseCompressedClassPointers) {
 2500         assert(Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
 2501         klass_load_size = MacroAssembler::instr_size_for_decode_klass_not_null() + 1*BytesPerInstWord;
 2502       } else {
 2503         klass_load_size = 1*BytesPerInstWord;
 2504       }
 2505       int entry_offset = in_bytes(Klass::vtable_start_offset()) + vtable_index*vtableEntry::size_in_bytes();
 2506       int v_off = entry_offset + vtableEntry::method_offset_in_bytes();
 2507       if (Assembler::is_simm13(v_off)) {
 2508         __ ld_ptr(G3, v_off, G5_method);
 2509       } else {
 2510         // Generate 2 instructions
 2511         __ Assembler::sethi(v_off &amp; ~0x3ff, G5_method);
 2512         __ or3(G5_method, v_off &amp; 0x3ff, G5_method);
 2513         // ld_ptr, set_hi, set
 2514         assert(__ offset() - off == klass_load_size + 2*BytesPerInstWord,
 2515                &quot;Unexpected instruction size(s)&quot;);
 2516         __ ld_ptr(G3, G5_method, G5_method);
 2517       }
 2518       // NOTE: for vtable dispatches, the vtable entry will never be null.
 2519       // However it may very well end up in handle_wrong_method if the
 2520       // method is abstract for the particular class.
 2521       __ ld_ptr(G5_method, in_bytes(Method::from_compiled_offset()), G3_scratch);
 2522       // jump to target (either compiled code or c2iadapter)
 2523       __ jmpl(G3_scratch, G0, O7);
 2524       __ delayed()-&gt;nop();
 2525     }
 2526   %}
 2527 
 2528   enc_class Java_Compiled_Call (method meth) %{    // JAVA COMPILED CALL
 2529     MacroAssembler _masm(&amp;cbuf);
 2530 
 2531     Register G5_ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
 2532     Register temp_reg = G3;   // caller must kill G3!  We cannot reuse G5_ic_reg here because
 2533                               // we might be calling a C2I adapter which needs it.
 2534 
 2535     assert(temp_reg != G5_ic_reg, &quot;conflicting registers&quot;);
 2536     // Load nmethod
 2537     __ ld_ptr(G5_ic_reg, in_bytes(Method::from_compiled_offset()), temp_reg);
 2538 
 2539     // CALL to compiled java, indirect the contents of G3
 2540     __ set_inst_mark();
 2541     __ callr(temp_reg, G0);
 2542     __ delayed()-&gt;nop();
 2543   %}
 2544 
 2545 enc_class idiv_reg(iRegIsafe src1, iRegIsafe src2, iRegIsafe dst) %{
 2546     MacroAssembler _masm(&amp;cbuf);
 2547     Register Rdividend = reg_to_register_object($src1$$reg);
 2548     Register Rdivisor = reg_to_register_object($src2$$reg);
 2549     Register Rresult = reg_to_register_object($dst$$reg);
 2550 
 2551     __ sra(Rdivisor, 0, Rdivisor);
 2552     __ sra(Rdividend, 0, Rdividend);
 2553     __ sdivx(Rdividend, Rdivisor, Rresult);
 2554 %}
 2555 
 2556 enc_class idiv_imm(iRegIsafe src1, immI13 imm, iRegIsafe dst) %{
 2557     MacroAssembler _masm(&amp;cbuf);
 2558 
 2559     Register Rdividend = reg_to_register_object($src1$$reg);
 2560     int divisor = $imm$$constant;
 2561     Register Rresult = reg_to_register_object($dst$$reg);
 2562 
 2563     __ sra(Rdividend, 0, Rdividend);
 2564     __ sdivx(Rdividend, divisor, Rresult);
 2565 %}
 2566 
 2567 enc_class enc_mul_hi(iRegIsafe dst, iRegIsafe src1, iRegIsafe src2) %{
 2568     MacroAssembler _masm(&amp;cbuf);
 2569     Register Rsrc1 = reg_to_register_object($src1$$reg);
 2570     Register Rsrc2 = reg_to_register_object($src2$$reg);
 2571     Register Rdst  = reg_to_register_object($dst$$reg);
 2572 
 2573     __ sra( Rsrc1, 0, Rsrc1 );
 2574     __ sra( Rsrc2, 0, Rsrc2 );
 2575     __ mulx( Rsrc1, Rsrc2, Rdst );
 2576     __ srlx( Rdst, 32, Rdst );
 2577 %}
 2578 
 2579 enc_class irem_reg(iRegIsafe src1, iRegIsafe src2, iRegIsafe dst, o7RegL scratch) %{
 2580     MacroAssembler _masm(&amp;cbuf);
 2581     Register Rdividend = reg_to_register_object($src1$$reg);
 2582     Register Rdivisor = reg_to_register_object($src2$$reg);
 2583     Register Rresult = reg_to_register_object($dst$$reg);
 2584     Register Rscratch = reg_to_register_object($scratch$$reg);
 2585 
 2586     assert(Rdividend != Rscratch, &quot;&quot;);
 2587     assert(Rdivisor  != Rscratch, &quot;&quot;);
 2588 
 2589     __ sra(Rdividend, 0, Rdividend);
 2590     __ sra(Rdivisor, 0, Rdivisor);
 2591     __ sdivx(Rdividend, Rdivisor, Rscratch);
 2592     __ mulx(Rscratch, Rdivisor, Rscratch);
 2593     __ sub(Rdividend, Rscratch, Rresult);
 2594 %}
 2595 
 2596 enc_class irem_imm(iRegIsafe src1, immI13 imm, iRegIsafe dst, o7RegL scratch) %{
 2597     MacroAssembler _masm(&amp;cbuf);
 2598 
 2599     Register Rdividend = reg_to_register_object($src1$$reg);
 2600     int divisor = $imm$$constant;
 2601     Register Rresult = reg_to_register_object($dst$$reg);
 2602     Register Rscratch = reg_to_register_object($scratch$$reg);
 2603 
 2604     assert(Rdividend != Rscratch, &quot;&quot;);
 2605 
 2606     __ sra(Rdividend, 0, Rdividend);
 2607     __ sdivx(Rdividend, divisor, Rscratch);
 2608     __ mulx(Rscratch, divisor, Rscratch);
 2609     __ sub(Rdividend, Rscratch, Rresult);
 2610 %}
 2611 
 2612 enc_class fabss (sflt_reg dst, sflt_reg src) %{
 2613     MacroAssembler _masm(&amp;cbuf);
 2614 
 2615     FloatRegister Fdst = reg_to_SingleFloatRegister_object($dst$$reg);
 2616     FloatRegister Fsrc = reg_to_SingleFloatRegister_object($src$$reg);
 2617 
 2618     __ fabs(FloatRegisterImpl::S, Fsrc, Fdst);
 2619 %}
 2620 
 2621 enc_class fabsd (dflt_reg dst, dflt_reg src) %{
 2622     MacroAssembler _masm(&amp;cbuf);
 2623 
 2624     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2625     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2626 
 2627     __ fabs(FloatRegisterImpl::D, Fsrc, Fdst);
 2628 %}
 2629 
 2630 enc_class fnegd (dflt_reg dst, dflt_reg src) %{
 2631     MacroAssembler _masm(&amp;cbuf);
 2632 
 2633     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2634     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2635 
 2636     __ fneg(FloatRegisterImpl::D, Fsrc, Fdst);
 2637 %}
 2638 
 2639 enc_class fsqrts (sflt_reg dst, sflt_reg src) %{
 2640     MacroAssembler _masm(&amp;cbuf);
 2641 
 2642     FloatRegister Fdst = reg_to_SingleFloatRegister_object($dst$$reg);
 2643     FloatRegister Fsrc = reg_to_SingleFloatRegister_object($src$$reg);
 2644 
 2645     __ fsqrt(FloatRegisterImpl::S, Fsrc, Fdst);
 2646 %}
 2647 
 2648 enc_class fsqrtd (dflt_reg dst, dflt_reg src) %{
 2649     MacroAssembler _masm(&amp;cbuf);
 2650 
 2651     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2652     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2653 
 2654     __ fsqrt(FloatRegisterImpl::D, Fsrc, Fdst);
 2655 %}
 2656 
 2657 
 2658 enc_class fmadds (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
 2659     MacroAssembler _masm(&amp;cbuf);
 2660 
 2661     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2662     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2663     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2664     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2665 
 2666     __ fmadd(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2667 %}
 2668 
 2669 enc_class fmaddd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
 2670     MacroAssembler _masm(&amp;cbuf);
 2671 
 2672     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2673     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2674     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2675     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2676 
 2677     __ fmadd(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2678 %}
 2679 
 2680 enc_class fmsubs (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
 2681     MacroAssembler _masm(&amp;cbuf);
 2682 
 2683     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2684     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2685     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2686     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2687 
 2688     __ fmsub(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2689 %}
 2690 
 2691 enc_class fmsubd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
 2692     MacroAssembler _masm(&amp;cbuf);
 2693 
 2694     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2695     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2696     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2697     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2698 
 2699     __ fmsub(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2700 %}
 2701 
 2702 enc_class fnmadds (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
 2703     MacroAssembler _masm(&amp;cbuf);
 2704 
 2705     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2706     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2707     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2708     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2709 
 2710     __ fnmadd(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2711 %}
 2712 
 2713 enc_class fnmaddd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
 2714     MacroAssembler _masm(&amp;cbuf);
 2715 
 2716     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2717     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2718     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2719     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2720 
 2721     __ fnmadd(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2722 %}
 2723 
 2724 enc_class fnmsubs (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
 2725     MacroAssembler _masm(&amp;cbuf);
 2726 
 2727     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2728     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2729     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2730     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2731 
 2732     __ fnmsub(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2733 %}
 2734 
 2735 enc_class fnmsubd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
 2736     MacroAssembler _masm(&amp;cbuf);
 2737 
 2738     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2739     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2740     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2741     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2742 
 2743     __ fnmsub(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2744 %}
 2745 
 2746 
 2747 enc_class fmovs (dflt_reg dst, dflt_reg src) %{
 2748     MacroAssembler _masm(&amp;cbuf);
 2749 
 2750     FloatRegister Fdst = reg_to_SingleFloatRegister_object($dst$$reg);
 2751     FloatRegister Fsrc = reg_to_SingleFloatRegister_object($src$$reg);
 2752 
 2753     __ fmov(FloatRegisterImpl::S, Fsrc, Fdst);
 2754 %}
 2755 
 2756 enc_class fmovd (dflt_reg dst, dflt_reg src) %{
 2757     MacroAssembler _masm(&amp;cbuf);
 2758 
 2759     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2760     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2761 
 2762     __ fmov(FloatRegisterImpl::D, Fsrc, Fdst);
 2763 %}
 2764 
 2765 enc_class Fast_Lock(iRegP oop, iRegP box, o7RegP scratch, iRegP scratch2) %{
 2766     MacroAssembler _masm(&amp;cbuf);
 2767 
 2768     Register Roop  = reg_to_register_object($oop$$reg);
 2769     Register Rbox  = reg_to_register_object($box$$reg);
 2770     Register Rscratch = reg_to_register_object($scratch$$reg);
 2771     Register Rmark =    reg_to_register_object($scratch2$$reg);
 2772 
 2773     assert(Roop  != Rscratch, &quot;&quot;);
 2774     assert(Roop  != Rmark, &quot;&quot;);
 2775     assert(Rbox  != Rscratch, &quot;&quot;);
 2776     assert(Rbox  != Rmark, &quot;&quot;);
 2777 
 2778     __ compiler_lock_object(Roop, Rmark, Rbox, Rscratch, _counters, UseBiasedLocking &amp;&amp; !UseOptoBiasInlining);
 2779 %}
 2780 
 2781 enc_class Fast_Unlock(iRegP oop, iRegP box, o7RegP scratch, iRegP scratch2) %{
 2782     MacroAssembler _masm(&amp;cbuf);
 2783 
 2784     Register Roop  = reg_to_register_object($oop$$reg);
 2785     Register Rbox  = reg_to_register_object($box$$reg);
 2786     Register Rscratch = reg_to_register_object($scratch$$reg);
 2787     Register Rmark =    reg_to_register_object($scratch2$$reg);
 2788 
 2789     assert(Roop  != Rscratch, &quot;&quot;);
 2790     assert(Roop  != Rmark, &quot;&quot;);
 2791     assert(Rbox  != Rscratch, &quot;&quot;);
 2792     assert(Rbox  != Rmark, &quot;&quot;);
 2793 
 2794     __ compiler_unlock_object(Roop, Rmark, Rbox, Rscratch, UseBiasedLocking &amp;&amp; !UseOptoBiasInlining);
 2795   %}
 2796 
 2797   enc_class enc_cas( iRegP mem, iRegP old, iRegP new ) %{
 2798     MacroAssembler _masm(&amp;cbuf);
 2799     Register Rmem = reg_to_register_object($mem$$reg);
 2800     Register Rold = reg_to_register_object($old$$reg);
 2801     Register Rnew = reg_to_register_object($new$$reg);
 2802 
 2803     __ cas_ptr(Rmem, Rold, Rnew); // Swap(*Rmem,Rnew) if *Rmem == Rold
 2804     __ cmp( Rold, Rnew );
 2805   %}
 2806 
 2807   enc_class enc_casx( iRegP mem, iRegL old, iRegL new) %{
 2808     Register Rmem = reg_to_register_object($mem$$reg);
 2809     Register Rold = reg_to_register_object($old$$reg);
 2810     Register Rnew = reg_to_register_object($new$$reg);
 2811 
 2812     MacroAssembler _masm(&amp;cbuf);
 2813     __ mov(Rnew, O7);
 2814     __ casx(Rmem, Rold, O7);
 2815     __ cmp( Rold, O7 );
 2816   %}
 2817 
 2818   // raw int cas, used for compareAndSwap
 2819   enc_class enc_casi( iRegP mem, iRegL old, iRegL new) %{
 2820     Register Rmem = reg_to_register_object($mem$$reg);
 2821     Register Rold = reg_to_register_object($old$$reg);
 2822     Register Rnew = reg_to_register_object($new$$reg);
 2823 
 2824     MacroAssembler _masm(&amp;cbuf);
 2825     __ mov(Rnew, O7);
 2826     __ cas(Rmem, Rold, O7);
 2827     __ cmp( Rold, O7 );
 2828   %}
 2829 
 2830   // raw int cas without using tmp register for compareAndExchange
 2831   enc_class enc_casi_exch( iRegP mem, iRegL old, iRegL new) %{
 2832     Register Rmem = reg_to_register_object($mem$$reg);
 2833     Register Rold = reg_to_register_object($old$$reg);
 2834     Register Rnew = reg_to_register_object($new$$reg);
 2835 
 2836     MacroAssembler _masm(&amp;cbuf);
 2837     __ cas(Rmem, Rold, Rnew);
 2838   %}
 2839 
 2840   // 64-bit cas without using tmp register for compareAndExchange
 2841   enc_class enc_casx_exch( iRegP mem, iRegL old, iRegL new) %{
 2842     Register Rmem = reg_to_register_object($mem$$reg);
 2843     Register Rold = reg_to_register_object($old$$reg);
 2844     Register Rnew = reg_to_register_object($new$$reg);
 2845 
 2846     MacroAssembler _masm(&amp;cbuf);
 2847     __ casx(Rmem, Rold, Rnew);
 2848   %}
 2849 
 2850   enc_class enc_lflags_ne_to_boolean( iRegI res ) %{
 2851     Register Rres = reg_to_register_object($res$$reg);
 2852 
 2853     MacroAssembler _masm(&amp;cbuf);
 2854     __ mov(1, Rres);
 2855     __ movcc( Assembler::notEqual, false, Assembler::xcc, G0, Rres );
 2856   %}
 2857 
 2858   enc_class enc_iflags_ne_to_boolean( iRegI res ) %{
 2859     Register Rres = reg_to_register_object($res$$reg);
 2860 
 2861     MacroAssembler _masm(&amp;cbuf);
 2862     __ mov(1, Rres);
 2863     __ movcc( Assembler::notEqual, false, Assembler::icc, G0, Rres );
 2864   %}
 2865 
 2866   enc_class floating_cmp ( iRegP dst, regF src1, regF src2 ) %{
 2867     MacroAssembler _masm(&amp;cbuf);
 2868     Register Rdst = reg_to_register_object($dst$$reg);
 2869     FloatRegister Fsrc1 = $primary ? reg_to_SingleFloatRegister_object($src1$$reg)
 2870                                      : reg_to_DoubleFloatRegister_object($src1$$reg);
 2871     FloatRegister Fsrc2 = $primary ? reg_to_SingleFloatRegister_object($src2$$reg)
 2872                                      : reg_to_DoubleFloatRegister_object($src2$$reg);
 2873 
 2874     // Convert condition code fcc0 into -1,0,1; unordered reports less-than (-1)
 2875     __ float_cmp( $primary, -1, Fsrc1, Fsrc2, Rdst);
 2876   %}
 2877 
 2878   enc_class enc_rethrow() %{
 2879     cbuf.set_insts_mark();
 2880     Register temp_reg = G3;
 2881     AddressLiteral rethrow_stub(OptoRuntime::rethrow_stub());
 2882     assert(temp_reg != reg_to_register_object(R_I0_num), &quot;temp must not break oop_reg&quot;);
 2883     MacroAssembler _masm(&amp;cbuf);
 2884 #ifdef ASSERT
 2885     __ save_frame(0);
 2886     AddressLiteral last_rethrow_addrlit(&amp;last_rethrow);
 2887     __ sethi(last_rethrow_addrlit, L1);
 2888     Address addr(L1, last_rethrow_addrlit.low10());
 2889     __ rdpc(L2);
 2890     __ inc(L2, 3 * BytesPerInstWord);  // skip this &amp; 2 more insns to point at jump_to
 2891     __ st_ptr(L2, addr);
 2892     __ restore();
 2893 #endif
 2894     __ JUMP(rethrow_stub, temp_reg, 0); // sethi;jmp
 2895     __ delayed()-&gt;nop();
 2896   %}
 2897 
 2898   enc_class emit_mem_nop() %{
 2899     // Generates the instruction LDUXA [o6,g0],#0x82,g0
 2900     cbuf.insts()-&gt;emit_int32((unsigned int) 0xc0839040);
 2901   %}
 2902 
 2903   enc_class emit_fadd_nop() %{
 2904     // Generates the instruction FMOVS f31,f31
 2905     cbuf.insts()-&gt;emit_int32((unsigned int) 0xbfa0003f);
 2906   %}
 2907 
 2908   enc_class emit_br_nop() %{
 2909     // Generates the instruction BPN,PN .
 2910     cbuf.insts()-&gt;emit_int32((unsigned int) 0x00400000);
 2911   %}
 2912 
 2913   enc_class enc_membar_acquire %{
 2914     MacroAssembler _masm(&amp;cbuf);
 2915     __ membar( Assembler::Membar_mask_bits(Assembler::LoadStore | Assembler::LoadLoad) );
 2916   %}
 2917 
 2918   enc_class enc_membar_release %{
 2919     MacroAssembler _masm(&amp;cbuf);
 2920     __ membar( Assembler::Membar_mask_bits(Assembler::LoadStore | Assembler::StoreStore) );
 2921   %}
 2922 
 2923   enc_class enc_membar_volatile %{
 2924     MacroAssembler _masm(&amp;cbuf);
 2925     __ membar( Assembler::Membar_mask_bits(Assembler::StoreLoad) );
 2926   %}
 2927 
 2928 %}
 2929 
 2930 //----------FRAME--------------------------------------------------------------
 2931 // Definition of frame structure and management information.
 2932 //
 2933 //  S T A C K   L A Y O U T    Allocators stack-slot number
 2934 //                             |   (to get allocators register number
 2935 //  G  Owned by    |        |  v    add VMRegImpl::stack0)
 2936 //  r   CALLER     |        |
 2937 //  o     |        +--------+      pad to even-align allocators stack-slot
 2938 //  w     V        |  pad0  |        numbers; owned by CALLER
 2939 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
 2940 //  h     ^        |   in   |  5
 2941 //        |        |  args  |  4   Holes in incoming args owned by SELF
 2942 //  |     |        |        |  3
 2943 //  |     |        +--------+
 2944 //  V     |        | old out|      Empty on Intel, window on Sparc
 2945 //        |    old |preserve|      Must be even aligned.
 2946 //        |     SP-+--------+----&gt; Matcher::_old_SP, 8 (or 16 in LP64)-byte aligned
 2947 //        |        |   in   |  3   area for Intel ret address
 2948 //     Owned by    |preserve|      Empty on Sparc.
 2949 //       SELF      +--------+
 2950 //        |        |  pad2  |  2   pad to align old SP
 2951 //        |        +--------+  1
 2952 //        |        | locks  |  0
 2953 //        |        +--------+----&gt; VMRegImpl::stack0, 8 (or 16 in LP64)-byte aligned
 2954 //        |        |  pad1  | 11   pad to align new SP
 2955 //        |        +--------+
 2956 //        |        |        | 10
 2957 //        |        | spills |  9   spills
 2958 //        V        |        |  8   (pad0 slot for callee)
 2959 //      -----------+--------+----&gt; Matcher::_out_arg_limit, unaligned
 2960 //        ^        |  out   |  7
 2961 //        |        |  args  |  6   Holes in outgoing args owned by CALLEE
 2962 //     Owned by    +--------+
 2963 //      CALLEE     | new out|  6   Empty on Intel, window on Sparc
 2964 //        |    new |preserve|      Must be even-aligned.
 2965 //        |     SP-+--------+----&gt; Matcher::_new_SP, even aligned
 2966 //        |        |        |
 2967 //
 2968 // Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is
 2969 //         known from SELF&#39;s arguments and the Java calling convention.
 2970 //         Region 6-7 is determined per call site.
 2971 // Note 2: If the calling convention leaves holes in the incoming argument
 2972 //         area, those holes are owned by SELF.  Holes in the outgoing area
 2973 //         are owned by the CALLEE.  Holes should not be nessecary in the
 2974 //         incoming area, as the Java calling convention is completely under
 2975 //         the control of the AD file.  Doubles can be sorted and packed to
 2976 //         avoid holes.  Holes in the outgoing arguments may be necessary for
 2977 //         varargs C calling conventions.
 2978 // Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is
 2979 //         even aligned with pad0 as needed.
 2980 //         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
 2981 //         region 6-11 is even aligned; it may be padded out more so that
 2982 //         the region from SP to FP meets the minimum stack alignment.
 2983 
 2984 frame %{
 2985   // What direction does stack grow in (assumed to be same for native &amp; Java)
 2986   stack_direction(TOWARDS_LOW);
 2987 
 2988   // These two registers define part of the calling convention
 2989   // between compiled code and the interpreter.
 2990   inline_cache_reg(R_G5);                // Inline Cache Register or Method* for I2C
 2991   interpreter_method_oop_reg(R_G5);      // Method Oop Register when calling interpreter
 2992 
 2993   // Optional: name the operand used by cisc-spilling to access [stack_pointer + offset]
 2994   cisc_spilling_operand_name(indOffset);
 2995 
 2996   // Number of stack slots consumed by a Monitor enter
 2997   sync_stack_slots(2);
 2998 
 2999   // Compiled code&#39;s Frame Pointer
 3000   frame_pointer(R_SP);
 3001 
 3002   // Stack alignment requirement
 3003   stack_alignment(StackAlignmentInBytes);
 3004   //  LP64: Alignment size in bytes (128-bit -&gt; 16 bytes)
 3005   // !LP64: Alignment size in bytes (64-bit  -&gt;  8 bytes)
 3006 
 3007   // Number of stack slots between incoming argument block and the start of
 3008   // a new frame.  The PROLOG must add this many slots to the stack.  The
 3009   // EPILOG must remove this many slots.
 3010   in_preserve_stack_slots(0);
 3011 
 3012   // Number of outgoing stack slots killed above the out_preserve_stack_slots
 3013   // for calls to C.  Supports the var-args backing area for register parms.
 3014   // ADLC doesn&#39;t support parsing expressions, so I folded the math by hand.
 3015   // (callee_register_argument_save_area_words (6) + callee_aggregate_return_pointer_words (0)) * 2-stack-slots-per-word
 3016   varargs_C_out_slots_killed(12);
 3017 
 3018   // The after-PROLOG location of the return address.  Location of
 3019   // return address specifies a type (REG or STACK) and a number
 3020   // representing the register number (i.e. - use a register name) or
 3021   // stack slot.
 3022   return_addr(REG R_I7);          // Ret Addr is in register I7
 3023 
 3024   // Body of function which returns an OptoRegs array locating
 3025   // arguments either in registers or in stack slots for calling
 3026   // java
 3027   calling_convention %{
 3028     (void) SharedRuntime::java_calling_convention(sig_bt, regs, length, is_outgoing);
 3029 
 3030   %}
 3031 
 3032   // Body of function which returns an OptoRegs array locating
 3033   // arguments either in registers or in stack slots for calling
 3034   // C.
 3035   c_calling_convention %{
 3036     // This is obviously always outgoing
 3037     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 3038   %}
 3039 
 3040   // Location of native (C/C++) and interpreter return values.  This is specified to
 3041   // be the  same as Java.  In the 32-bit VM, long values are actually returned from
 3042   // native calls in O0:O1 and returned to the interpreter in I0:I1.  The copying
 3043   // to and from the register pairs is done by the appropriate call and epilog
 3044   // opcodes.  This simplifies the register allocator.
 3045   c_return_value %{
 3046     assert( ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot; );
 3047     static int lo_out[Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, R_O0_num,     R_O0_num,     R_O0_num,     R_F0_num,     R_F0_num, R_O0_num };
 3048     static int hi_out[Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, R_O0H_num,    OptoReg::Bad, R_F1_num, R_O0H_num};
 3049     static int lo_in [Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, R_I0_num,     R_I0_num,     R_I0_num,     R_F0_num,     R_F0_num, R_I0_num };
 3050     static int hi_in [Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, R_I0H_num,    OptoReg::Bad, R_F1_num, R_I0H_num};
 3051     return OptoRegPair( (is_outgoing?hi_out:hi_in)[ideal_reg],
 3052                         (is_outgoing?lo_out:lo_in)[ideal_reg] );
 3053   %}
 3054 
 3055   // Location of compiled Java return values.  Same as C
 3056   return_value %{
 3057     assert( ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot; );
 3058     static int lo_out[Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, R_O0_num,     R_O0_num,     R_O0_num,     R_F0_num,     R_F0_num, R_O0_num };
 3059     static int hi_out[Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, R_O0H_num,    OptoReg::Bad, R_F1_num, R_O0H_num};
 3060     static int lo_in [Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, R_I0_num,     R_I0_num,     R_I0_num,     R_F0_num,     R_F0_num, R_I0_num };
 3061     static int hi_in [Op_RegL+1] = { OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, R_I0H_num,    OptoReg::Bad, R_F1_num, R_I0H_num};
 3062     return OptoRegPair( (is_outgoing?hi_out:hi_in)[ideal_reg],
 3063                         (is_outgoing?lo_out:lo_in)[ideal_reg] );
 3064   %}
 3065 
 3066 %}
 3067 
 3068 
 3069 //----------ATTRIBUTES---------------------------------------------------------
 3070 //----------Operand Attributes-------------------------------------------------
 3071 op_attrib op_cost(1);          // Required cost attribute
 3072 
 3073 //----------Instruction Attributes---------------------------------------------
 3074 ins_attrib ins_cost(DEFAULT_COST); // Required cost attribute
 3075 ins_attrib ins_size(32);           // Required size attribute (in bits)
 3076 
 3077 // avoid_back_to_back attribute is an expression that must return
 3078 // one of the following values defined in MachNode:
 3079 // AVOID_NONE   - instruction can be placed anywhere
 3080 // AVOID_BEFORE - instruction cannot be placed after an
 3081 //                instruction with MachNode::AVOID_AFTER
 3082 // AVOID_AFTER  - the next instruction cannot be the one
 3083 //                with MachNode::AVOID_BEFORE
 3084 // AVOID_BEFORE_AND_AFTER - BEFORE and AFTER attributes at
 3085 //                          the same time
 3086 ins_attrib ins_avoid_back_to_back(MachNode::AVOID_NONE);
 3087 
 3088 ins_attrib ins_short_branch(0);    // Required flag: is this instruction a
 3089                                    // non-matching short branch variant of some
 3090                                                             // long branch?
 3091 
 3092 //----------OPERANDS-----------------------------------------------------------
 3093 // Operand definitions must precede instruction definitions for correct parsing
 3094 // in the ADLC because operands constitute user defined types which are used in
 3095 // instruction definitions.
 3096 
 3097 //----------Simple Operands----------------------------------------------------
 3098 // Immediate Operands
 3099 // Integer Immediate: 32-bit
 3100 operand immI() %{
 3101   match(ConI);
 3102 
 3103   op_cost(0);
 3104   // formats are generated automatically for constants and base registers
 3105   format %{ %}
 3106   interface(CONST_INTER);
 3107 %}
 3108 
 3109 // Integer Immediate: 0-bit
 3110 operand immI0() %{
 3111   predicate(n-&gt;get_int() == 0);
 3112   match(ConI);
 3113   op_cost(0);
 3114 
 3115   format %{ %}
 3116   interface(CONST_INTER);
 3117 %}
 3118 
 3119 // Integer Immediate: 5-bit
 3120 operand immI5() %{
 3121   predicate(Assembler::is_simm5(n-&gt;get_int()));
 3122   match(ConI);
 3123   op_cost(0);
 3124   format %{ %}
 3125   interface(CONST_INTER);
 3126 %}
 3127 
 3128 // Integer Immediate: 8-bit
 3129 operand immI8() %{
 3130   predicate(Assembler::is_simm8(n-&gt;get_int()));
 3131   match(ConI);
 3132   op_cost(0);
 3133   format %{ %}
 3134   interface(CONST_INTER);
 3135 %}
 3136 
 3137 // Integer Immediate: the value 10
 3138 operand immI10() %{
 3139   predicate(n-&gt;get_int() == 10);
 3140   match(ConI);
 3141   op_cost(0);
 3142 
 3143   format %{ %}
 3144   interface(CONST_INTER);
 3145 %}
 3146 
 3147 // Integer Immediate: 11-bit
 3148 operand immI11() %{
 3149   predicate(Assembler::is_simm11(n-&gt;get_int()));
 3150   match(ConI);
 3151   op_cost(0);
 3152   format %{ %}
 3153   interface(CONST_INTER);
 3154 %}
 3155 
 3156 // Integer Immediate: 13-bit
 3157 operand immI13() %{
 3158   predicate(Assembler::is_simm13(n-&gt;get_int()));
 3159   match(ConI);
 3160   op_cost(0);
 3161 
 3162   format %{ %}
 3163   interface(CONST_INTER);
 3164 %}
 3165 
 3166 // Integer Immediate: 13-bit minus 7
 3167 operand immI13m7() %{
 3168   predicate((-4096 &lt; n-&gt;get_int()) &amp;&amp; ((n-&gt;get_int() + 7) &lt;= 4095));
 3169   match(ConI);
 3170   op_cost(0);
 3171 
 3172   format %{ %}
 3173   interface(CONST_INTER);
 3174 %}
 3175 
 3176 // Integer Immediate: 16-bit
 3177 operand immI16() %{
 3178   predicate(Assembler::is_simm16(n-&gt;get_int()));
 3179   match(ConI);
 3180   op_cost(0);
 3181   format %{ %}
 3182   interface(CONST_INTER);
 3183 %}
 3184 
 3185 // Integer Immediate: the values 1-31
 3186 operand immI_1_31() %{
 3187   predicate(n-&gt;get_int() &gt;= 1 &amp;&amp; n-&gt;get_int() &lt;= 31);
 3188   match(ConI);
 3189   op_cost(0);
 3190 
 3191   format %{ %}
 3192   interface(CONST_INTER);
 3193 %}
 3194 
 3195 // Integer Immediate: the values 32-63
 3196 operand immI_32_63() %{
 3197   predicate(n-&gt;get_int() &gt;= 32 &amp;&amp; n-&gt;get_int() &lt;= 63);
 3198   match(ConI);
 3199   op_cost(0);
 3200 
 3201   format %{ %}
 3202   interface(CONST_INTER);
 3203 %}
 3204 
 3205 // Immediates for special shifts (sign extend)
 3206 
 3207 // Integer Immediate: the value 16
 3208 operand immI_16() %{
 3209   predicate(n-&gt;get_int() == 16);
 3210   match(ConI);
 3211   op_cost(0);
 3212 
 3213   format %{ %}
 3214   interface(CONST_INTER);
 3215 %}
 3216 
 3217 // Integer Immediate: the value 24
 3218 operand immI_24() %{
 3219   predicate(n-&gt;get_int() == 24);
 3220   match(ConI);
 3221   op_cost(0);
 3222 
 3223   format %{ %}
 3224   interface(CONST_INTER);
 3225 %}
 3226 // Integer Immediate: the value 255
 3227 operand immI_255() %{
 3228   predicate( n-&gt;get_int() == 255 );
 3229   match(ConI);
 3230   op_cost(0);
 3231 
 3232   format %{ %}
 3233   interface(CONST_INTER);
 3234 %}
 3235 
 3236 // Integer Immediate: the value 65535
 3237 operand immI_65535() %{
 3238   predicate(n-&gt;get_int() == 65535);
 3239   match(ConI);
 3240   op_cost(0);
 3241 
 3242   format %{ %}
 3243   interface(CONST_INTER);
 3244 %}
 3245 
 3246 // Integer Immediate: the values 0-31
 3247 operand immU5() %{
 3248   predicate(n-&gt;get_int() &gt;= 0 &amp;&amp; n-&gt;get_int() &lt;= 31);
 3249   match(ConI);
 3250   op_cost(0);
 3251 
 3252   format %{ %}
 3253   interface(CONST_INTER);
 3254 %}
 3255 
 3256 // Integer Immediate: 6-bit
 3257 operand immU6() %{
 3258   predicate(n-&gt;get_int() &gt;= 0 &amp;&amp; n-&gt;get_int() &lt;= 63);
 3259   match(ConI);
 3260   op_cost(0);
 3261   format %{ %}
 3262   interface(CONST_INTER);
 3263 %}
 3264 
 3265 // Unsigned Integer Immediate: 12-bit (non-negative that fits in simm13)
 3266 operand immU12() %{
 3267   predicate((0 &lt;= n-&gt;get_int()) &amp;&amp; Assembler::is_simm13(n-&gt;get_int()));
 3268   match(ConI);
 3269   op_cost(0);
 3270 
 3271   format %{ %}
 3272   interface(CONST_INTER);
 3273 %}
 3274 
 3275 // Unsigned Long Immediate: 12-bit (non-negative that fits in simm13)
 3276 operand immUL12() %{
 3277   predicate((0 &lt;= n-&gt;get_long()) &amp;&amp; (n-&gt;get_long() == (int)n-&gt;get_long()) &amp;&amp; Assembler::is_simm13((int)n-&gt;get_long()));
 3278   match(ConL);
 3279   op_cost(0);
 3280 
 3281   format %{ %}
 3282   interface(CONST_INTER);
 3283 %}
 3284 
 3285 // Integer Immediate non-negative
 3286 operand immU31()
 3287 %{
 3288   predicate(n-&gt;get_int() &gt;= 0);
 3289   match(ConI);
 3290 
 3291   op_cost(0);
 3292   format %{ %}
 3293   interface(CONST_INTER);
 3294 %}
 3295 
 3296 // Long Immediate: the value FF
 3297 operand immL_FF() %{
 3298   predicate( n-&gt;get_long() == 0xFFL );
 3299   match(ConL);
 3300   op_cost(0);
 3301 
 3302   format %{ %}
 3303   interface(CONST_INTER);
 3304 %}
 3305 
 3306 // Long Immediate: the value FFFF
 3307 operand immL_FFFF() %{
 3308   predicate( n-&gt;get_long() == 0xFFFFL );
 3309   match(ConL);
 3310   op_cost(0);
 3311 
 3312   format %{ %}
 3313   interface(CONST_INTER);
 3314 %}
 3315 
 3316 // Pointer Immediate: 32 or 64-bit
 3317 operand immP() %{
 3318   match(ConP);
 3319 
 3320   op_cost(5);
 3321   // formats are generated automatically for constants and base registers
 3322   format %{ %}
 3323   interface(CONST_INTER);
 3324 %}
 3325 
 3326 // Pointer Immediate: 64-bit
 3327 operand immP_set() %{
 3328   predicate(!VM_Version::has_fast_ld());
 3329   match(ConP);
 3330 
 3331   op_cost(5);
 3332   // formats are generated automatically for constants and base registers
 3333   format %{ %}
 3334   interface(CONST_INTER);
 3335 %}
 3336 
 3337 // Pointer Immediate: 64-bit
 3338 // From Niagara2 processors on a load should be better than materializing.
 3339 operand immP_load() %{
 3340   predicate(VM_Version::has_fast_ld() &amp;&amp; (n-&gt;bottom_type()-&gt;isa_oop_ptr() || (MacroAssembler::insts_for_set(n-&gt;get_ptr()) &gt; 3)));
 3341   match(ConP);
 3342 
 3343   op_cost(5);
 3344   // formats are generated automatically for constants and base registers
 3345   format %{ %}
 3346   interface(CONST_INTER);
 3347 %}
 3348 
 3349 // Pointer Immediate: 64-bit
 3350 operand immP_no_oop_cheap() %{
 3351   predicate(VM_Version::has_fast_ld() &amp;&amp; !n-&gt;bottom_type()-&gt;isa_oop_ptr() &amp;&amp; (MacroAssembler::insts_for_set(n-&gt;get_ptr()) &lt;= 3));
 3352   match(ConP);
 3353 
 3354   op_cost(5);
 3355   // formats are generated automatically for constants and base registers
 3356   format %{ %}
 3357   interface(CONST_INTER);
 3358 %}
 3359 
 3360 operand immP13() %{
 3361   predicate((-4096 &lt; n-&gt;get_ptr()) &amp;&amp; (n-&gt;get_ptr() &lt;= 4095));
 3362   match(ConP);
 3363   op_cost(0);
 3364 
 3365   format %{ %}
 3366   interface(CONST_INTER);
 3367 %}
 3368 
 3369 operand immP0() %{
 3370   predicate(n-&gt;get_ptr() == 0);
 3371   match(ConP);
 3372   op_cost(0);
 3373 
 3374   format %{ %}
 3375   interface(CONST_INTER);
 3376 %}
 3377 
 3378 operand immP_poll() %{
 3379   predicate(n-&gt;get_ptr() != 0 &amp;&amp; n-&gt;get_ptr() == (intptr_t)os::get_polling_page());
 3380   match(ConP);
 3381 
 3382   // formats are generated automatically for constants and base registers
 3383   format %{ %}
 3384   interface(CONST_INTER);
 3385 %}
 3386 
 3387 // Pointer Immediate
 3388 operand immN()
 3389 %{
 3390   match(ConN);
 3391 
 3392   op_cost(10);
 3393   format %{ %}
 3394   interface(CONST_INTER);
 3395 %}
 3396 
 3397 operand immNKlass()
 3398 %{
 3399   match(ConNKlass);
 3400 
 3401   op_cost(10);
 3402   format %{ %}
 3403   interface(CONST_INTER);
 3404 %}
 3405 
 3406 // NULL Pointer Immediate
 3407 operand immN0()
 3408 %{
 3409   predicate(n-&gt;get_narrowcon() == 0);
 3410   match(ConN);
 3411 
 3412   op_cost(0);
 3413   format %{ %}
 3414   interface(CONST_INTER);
 3415 %}
 3416 
 3417 operand immL() %{
 3418   match(ConL);
 3419   op_cost(40);
 3420   // formats are generated automatically for constants and base registers
 3421   format %{ %}
 3422   interface(CONST_INTER);
 3423 %}
 3424 
 3425 operand immL0() %{
 3426   predicate(n-&gt;get_long() == 0L);
 3427   match(ConL);
 3428   op_cost(0);
 3429   // formats are generated automatically for constants and base registers
 3430   format %{ %}
 3431   interface(CONST_INTER);
 3432 %}
 3433 
 3434 // Integer Immediate: 5-bit
 3435 operand immL5() %{
 3436   predicate(n-&gt;get_long() == (int)n-&gt;get_long() &amp;&amp; Assembler::is_simm5((int)n-&gt;get_long()));
 3437   match(ConL);
 3438   op_cost(0);
 3439   format %{ %}
 3440   interface(CONST_INTER);
 3441 %}
 3442 
 3443 // Long Immediate: 13-bit
 3444 operand immL13() %{
 3445   predicate((-4096L &lt; n-&gt;get_long()) &amp;&amp; (n-&gt;get_long() &lt;= 4095L));
 3446   match(ConL);
 3447   op_cost(0);
 3448 
 3449   format %{ %}
 3450   interface(CONST_INTER);
 3451 %}
 3452 
 3453 // Long Immediate: 13-bit minus 7
 3454 operand immL13m7() %{
 3455   predicate((-4096L &lt; n-&gt;get_long()) &amp;&amp; ((n-&gt;get_long() + 7L) &lt;= 4095L));
 3456   match(ConL);
 3457   op_cost(0);
 3458 
 3459   format %{ %}
 3460   interface(CONST_INTER);
 3461 %}
 3462 
 3463 // Long Immediate: low 32-bit mask
 3464 operand immL_32bits() %{
 3465   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 3466   match(ConL);
 3467   op_cost(0);
 3468 
 3469   format %{ %}
 3470   interface(CONST_INTER);
 3471 %}
 3472 
 3473 // Long Immediate: cheap (materialize in &lt;= 3 instructions)
 3474 operand immL_cheap() %{
 3475   predicate(!VM_Version::has_fast_ld() || MacroAssembler::insts_for_set64(n-&gt;get_long()) &lt;= 3);
 3476   match(ConL);
 3477   op_cost(0);
 3478 
 3479   format %{ %}
 3480   interface(CONST_INTER);
 3481 %}
 3482 
 3483 // Long Immediate: expensive (materialize in &gt; 3 instructions)
 3484 operand immL_expensive() %{
 3485   predicate(VM_Version::has_fast_ld() &amp;&amp; MacroAssembler::insts_for_set64(n-&gt;get_long()) &gt; 3);
 3486   match(ConL);
 3487   op_cost(0);
 3488 
 3489   format %{ %}
 3490   interface(CONST_INTER);
 3491 %}
 3492 
 3493 // Double Immediate
 3494 operand immD() %{
 3495   match(ConD);
 3496 
 3497   op_cost(40);
 3498   format %{ %}
 3499   interface(CONST_INTER);
 3500 %}
 3501 
 3502 // Double Immediate: +0.0d
 3503 operand immD0() %{
 3504   predicate(jlong_cast(n-&gt;getd()) == 0);
 3505   match(ConD);
 3506 
 3507   op_cost(0);
 3508   format %{ %}
 3509   interface(CONST_INTER);
 3510 %}
 3511 
 3512 // Float Immediate
 3513 operand immF() %{
 3514   match(ConF);
 3515 
 3516   op_cost(20);
 3517   format %{ %}
 3518   interface(CONST_INTER);
 3519 %}
 3520 
 3521 // Float Immediate: +0.0f
 3522 operand immF0() %{
 3523   predicate(jint_cast(n-&gt;getf()) == 0);
 3524   match(ConF);
 3525 
 3526   op_cost(0);
 3527   format %{ %}
 3528   interface(CONST_INTER);
 3529 %}
 3530 
 3531 // Integer Register Operands
 3532 // Integer Register
 3533 operand iRegI() %{
 3534   constraint(ALLOC_IN_RC(int_reg));
 3535   match(RegI);
 3536 
 3537   match(notemp_iRegI);
 3538   match(g1RegI);
 3539   match(o0RegI);
 3540   match(iRegIsafe);
 3541 
 3542   format %{ %}
 3543   interface(REG_INTER);
 3544 %}
 3545 
 3546 operand notemp_iRegI() %{
 3547   constraint(ALLOC_IN_RC(notemp_int_reg));
 3548   match(RegI);
 3549 
 3550   match(o0RegI);
 3551 
 3552   format %{ %}
 3553   interface(REG_INTER);
 3554 %}
 3555 
 3556 operand o0RegI() %{
 3557   constraint(ALLOC_IN_RC(o0_regI));
 3558   match(iRegI);
 3559 
 3560   format %{ %}
 3561   interface(REG_INTER);
 3562 %}
 3563 
 3564 // Pointer Register
 3565 operand iRegP() %{
 3566   constraint(ALLOC_IN_RC(ptr_reg));
 3567   match(RegP);
 3568 
 3569   match(lock_ptr_RegP);
 3570   match(g1RegP);
 3571   match(g2RegP);
 3572   match(g3RegP);
 3573   match(g4RegP);
 3574   match(i0RegP);
 3575   match(o0RegP);
 3576   match(o1RegP);
 3577   match(l7RegP);
 3578 
 3579   format %{ %}
 3580   interface(REG_INTER);
 3581 %}
 3582 
 3583 operand sp_ptr_RegP() %{
 3584   constraint(ALLOC_IN_RC(sp_ptr_reg));
 3585   match(RegP);
 3586   match(iRegP);
 3587 
 3588   format %{ %}
 3589   interface(REG_INTER);
 3590 %}
 3591 
 3592 operand lock_ptr_RegP() %{
 3593   constraint(ALLOC_IN_RC(lock_ptr_reg));
 3594   match(RegP);
 3595   match(i0RegP);
 3596   match(o0RegP);
 3597   match(o1RegP);
 3598   match(l7RegP);
 3599 
 3600   format %{ %}
 3601   interface(REG_INTER);
 3602 %}
 3603 
 3604 operand g1RegP() %{
 3605   constraint(ALLOC_IN_RC(g1_regP));
 3606   match(iRegP);
 3607 
 3608   format %{ %}
 3609   interface(REG_INTER);
 3610 %}
 3611 
 3612 operand g2RegP() %{
 3613   constraint(ALLOC_IN_RC(g2_regP));
 3614   match(iRegP);
 3615 
 3616   format %{ %}
 3617   interface(REG_INTER);
 3618 %}
 3619 
 3620 operand g3RegP() %{
 3621   constraint(ALLOC_IN_RC(g3_regP));
 3622   match(iRegP);
 3623 
 3624   format %{ %}
 3625   interface(REG_INTER);
 3626 %}
 3627 
 3628 operand g1RegI() %{
 3629   constraint(ALLOC_IN_RC(g1_regI));
 3630   match(iRegI);
 3631 
 3632   format %{ %}
 3633   interface(REG_INTER);
 3634 %}
 3635 
 3636 operand g3RegI() %{
 3637   constraint(ALLOC_IN_RC(g3_regI));
 3638   match(iRegI);
 3639 
 3640   format %{ %}
 3641   interface(REG_INTER);
 3642 %}
 3643 
 3644 operand g4RegI() %{
 3645   constraint(ALLOC_IN_RC(g4_regI));
 3646   match(iRegI);
 3647 
 3648   format %{ %}
 3649   interface(REG_INTER);
 3650 %}
 3651 
 3652 operand g4RegP() %{
 3653   constraint(ALLOC_IN_RC(g4_regP));
 3654   match(iRegP);
 3655 
 3656   format %{ %}
 3657   interface(REG_INTER);
 3658 %}
 3659 
 3660 operand i0RegP() %{
 3661   constraint(ALLOC_IN_RC(i0_regP));
 3662   match(iRegP);
 3663 
 3664   format %{ %}
 3665   interface(REG_INTER);
 3666 %}
 3667 
 3668 operand o0RegP() %{
 3669   constraint(ALLOC_IN_RC(o0_regP));
 3670   match(iRegP);
 3671 
 3672   format %{ %}
 3673   interface(REG_INTER);
 3674 %}
 3675 
 3676 operand o1RegP() %{
 3677   constraint(ALLOC_IN_RC(o1_regP));
 3678   match(iRegP);
 3679 
 3680   format %{ %}
 3681   interface(REG_INTER);
 3682 %}
 3683 
 3684 operand o2RegP() %{
 3685   constraint(ALLOC_IN_RC(o2_regP));
 3686   match(iRegP);
 3687 
 3688   format %{ %}
 3689   interface(REG_INTER);
 3690 %}
 3691 
 3692 operand o7RegP() %{
 3693   constraint(ALLOC_IN_RC(o7_regP));
 3694   match(iRegP);
 3695 
 3696   format %{ %}
 3697   interface(REG_INTER);
 3698 %}
 3699 
 3700 operand l7RegP() %{
 3701   constraint(ALLOC_IN_RC(l7_regP));
 3702   match(iRegP);
 3703 
 3704   format %{ %}
 3705   interface(REG_INTER);
 3706 %}
 3707 
 3708 operand o7RegI() %{
 3709   constraint(ALLOC_IN_RC(o7_regI));
 3710   match(iRegI);
 3711 
 3712   format %{ %}
 3713   interface(REG_INTER);
 3714 %}
 3715 
 3716 operand iRegN() %{
 3717   constraint(ALLOC_IN_RC(int_reg));
 3718   match(RegN);
 3719 
 3720   format %{ %}
 3721   interface(REG_INTER);
 3722 %}
 3723 
 3724 // Long Register
 3725 operand iRegL() %{
 3726   constraint(ALLOC_IN_RC(long_reg));
 3727   match(RegL);
 3728 
 3729   format %{ %}
 3730   interface(REG_INTER);
 3731 %}
 3732 
 3733 operand o2RegL() %{
 3734   constraint(ALLOC_IN_RC(o2_regL));
 3735   match(iRegL);
 3736 
 3737   format %{ %}
 3738   interface(REG_INTER);
 3739 %}
 3740 
 3741 operand o7RegL() %{
 3742   constraint(ALLOC_IN_RC(o7_regL));
 3743   match(iRegL);
 3744 
 3745   format %{ %}
 3746   interface(REG_INTER);
 3747 %}
 3748 
 3749 operand g1RegL() %{
 3750   constraint(ALLOC_IN_RC(g1_regL));
 3751   match(iRegL);
 3752 
 3753   format %{ %}
 3754   interface(REG_INTER);
 3755 %}
 3756 
 3757 operand g3RegL() %{
 3758   constraint(ALLOC_IN_RC(g3_regL));
 3759   match(iRegL);
 3760 
 3761   format %{ %}
 3762   interface(REG_INTER);
 3763 %}
 3764 
 3765 // Int Register safe
 3766 // This is 64bit safe
 3767 operand iRegIsafe() %{
 3768   constraint(ALLOC_IN_RC(long_reg));
 3769 
 3770   match(iRegI);
 3771 
 3772   format %{ %}
 3773   interface(REG_INTER);
 3774 %}
 3775 
 3776 // Condition Code Flag Register
 3777 operand flagsReg() %{
 3778   constraint(ALLOC_IN_RC(int_flags));
 3779   match(RegFlags);
 3780 
 3781   format %{ &quot;ccr&quot; %} // both ICC and XCC
 3782   interface(REG_INTER);
 3783 %}
 3784 
 3785 // Condition Code Register, unsigned comparisons.
 3786 operand flagsRegU() %{
 3787   constraint(ALLOC_IN_RC(int_flags));
 3788   match(RegFlags);
 3789 
 3790   format %{ &quot;icc_U&quot; %}
 3791   interface(REG_INTER);
 3792 %}
 3793 
 3794 // Condition Code Register, pointer comparisons.
 3795 operand flagsRegP() %{
 3796   constraint(ALLOC_IN_RC(int_flags));
 3797   match(RegFlags);
 3798 
 3799   format %{ &quot;xcc_P&quot; %}
 3800   interface(REG_INTER);
 3801 %}
 3802 
 3803 // Condition Code Register, long comparisons.
 3804 operand flagsRegL() %{
 3805   constraint(ALLOC_IN_RC(int_flags));
 3806   match(RegFlags);
 3807 
 3808   format %{ &quot;xcc_L&quot; %}
 3809   interface(REG_INTER);
 3810 %}
 3811 
 3812 // Condition Code Register, unsigned long comparisons.
 3813 operand flagsRegUL() %{
 3814   constraint(ALLOC_IN_RC(int_flags));
 3815   match(RegFlags);
 3816 
 3817   format %{ &quot;xcc_UL&quot; %}
 3818   interface(REG_INTER);
 3819 %}
 3820 
 3821 // Condition Code Register, floating comparisons, unordered same as &quot;less&quot;.
 3822 operand flagsRegF() %{
 3823   constraint(ALLOC_IN_RC(float_flags));
 3824   match(RegFlags);
 3825   match(flagsRegF0);
 3826 
 3827   format %{ %}
 3828   interface(REG_INTER);
 3829 %}
 3830 
 3831 operand flagsRegF0() %{
 3832   constraint(ALLOC_IN_RC(float_flag0));
 3833   match(RegFlags);
 3834 
 3835   format %{ %}
 3836   interface(REG_INTER);
 3837 %}
 3838 
 3839 
 3840 // Condition Code Flag Register used by long compare
 3841 operand flagsReg_long_LTGE() %{
 3842   constraint(ALLOC_IN_RC(int_flags));
 3843   match(RegFlags);
 3844   format %{ &quot;icc_LTGE&quot; %}
 3845   interface(REG_INTER);
 3846 %}
 3847 operand flagsReg_long_EQNE() %{
 3848   constraint(ALLOC_IN_RC(int_flags));
 3849   match(RegFlags);
 3850   format %{ &quot;icc_EQNE&quot; %}
 3851   interface(REG_INTER);
 3852 %}
 3853 operand flagsReg_long_LEGT() %{
 3854   constraint(ALLOC_IN_RC(int_flags));
 3855   match(RegFlags);
 3856   format %{ &quot;icc_LEGT&quot; %}
 3857   interface(REG_INTER);
 3858 %}
 3859 
 3860 
 3861 operand regD() %{
 3862   constraint(ALLOC_IN_RC(dflt_reg));
 3863   match(RegD);
 3864 
 3865   match(regD_low);
 3866 
 3867   format %{ %}
 3868   interface(REG_INTER);
 3869 %}
 3870 
 3871 operand regF() %{
 3872   constraint(ALLOC_IN_RC(sflt_reg));
 3873   match(RegF);
 3874 
 3875   format %{ %}
 3876   interface(REG_INTER);
 3877 %}
 3878 
 3879 operand regD_low() %{
 3880   constraint(ALLOC_IN_RC(dflt_low_reg));
 3881   match(regD);
 3882 
 3883   format %{ %}
 3884   interface(REG_INTER);
 3885 %}
 3886 
 3887 // Special Registers
 3888 
 3889 // Method Register
 3890 operand inline_cache_regP(iRegP reg) %{
 3891   constraint(ALLOC_IN_RC(g5_regP)); // G5=inline_cache_reg but uses 2 bits instead of 1
 3892   match(reg);
 3893   format %{ %}
 3894   interface(REG_INTER);
 3895 %}
 3896 
 3897 operand interpreter_method_oop_regP(iRegP reg) %{
 3898   constraint(ALLOC_IN_RC(g5_regP)); // G5=interpreter_method_oop_reg but uses 2 bits instead of 1
 3899   match(reg);
 3900   format %{ %}
 3901   interface(REG_INTER);
 3902 %}
 3903 
 3904 
 3905 //----------Complex Operands---------------------------------------------------
 3906 // Indirect Memory Reference
 3907 operand indirect(sp_ptr_RegP reg) %{
 3908   constraint(ALLOC_IN_RC(sp_ptr_reg));
 3909   match(reg);
 3910 
 3911   op_cost(100);
 3912   format %{ &quot;[$reg]&quot; %}
 3913   interface(MEMORY_INTER) %{
 3914     base($reg);
 3915     index(0x0);
 3916     scale(0x0);
 3917     disp(0x0);
 3918   %}
 3919 %}
 3920 
 3921 // Indirect with simm13 Offset
 3922 operand indOffset13(sp_ptr_RegP reg, immX13 offset) %{
 3923   constraint(ALLOC_IN_RC(sp_ptr_reg));
 3924   match(AddP reg offset);
 3925 
 3926   op_cost(100);
 3927   format %{ &quot;[$reg + $offset]&quot; %}
 3928   interface(MEMORY_INTER) %{
 3929     base($reg);
 3930     index(0x0);
 3931     scale(0x0);
 3932     disp($offset);
 3933   %}
 3934 %}
 3935 
 3936 // Indirect with simm13 Offset minus 7
 3937 operand indOffset13m7(sp_ptr_RegP reg, immX13m7 offset) %{
 3938   constraint(ALLOC_IN_RC(sp_ptr_reg));
 3939   match(AddP reg offset);
 3940 
 3941   op_cost(100);
 3942   format %{ &quot;[$reg + $offset]&quot; %}
 3943   interface(MEMORY_INTER) %{
 3944     base($reg);
 3945     index(0x0);
 3946     scale(0x0);
 3947     disp($offset);
 3948   %}
 3949 %}
 3950 
 3951 // Note:  Intel has a swapped version also, like this:
 3952 //operand indOffsetX(iRegI reg, immP offset) %{
 3953 //  constraint(ALLOC_IN_RC(int_reg));
 3954 //  match(AddP offset reg);
 3955 //
 3956 //  op_cost(100);
 3957 //  format %{ &quot;[$reg + $offset]&quot; %}
 3958 //  interface(MEMORY_INTER) %{
 3959 //    base($reg);
 3960 //    index(0x0);
 3961 //    scale(0x0);
 3962 //    disp($offset);
 3963 //  %}
 3964 //%}
 3965 //// However, it doesn&#39;t make sense for SPARC, since
 3966 // we have no particularly good way to embed oops in
 3967 // single instructions.
 3968 
 3969 // Indirect with Register Index
 3970 operand indIndex(iRegP addr, iRegX index) %{
 3971   constraint(ALLOC_IN_RC(ptr_reg));
 3972   match(AddP addr index);
 3973 
 3974   op_cost(100);
 3975   format %{ &quot;[$addr + $index]&quot; %}
 3976   interface(MEMORY_INTER) %{
 3977     base($addr);
 3978     index($index);
 3979     scale(0x0);
 3980     disp(0x0);
 3981   %}
 3982 %}
 3983 
 3984 //----------Special Memory Operands--------------------------------------------
 3985 // Stack Slot Operand - This operand is used for loading and storing temporary
 3986 //                      values on the stack where a match requires a value to
 3987 //                      flow through memory.
 3988 operand stackSlotI(sRegI reg) %{
 3989   constraint(ALLOC_IN_RC(stack_slots));
 3990   op_cost(100);
 3991   //match(RegI);
 3992   format %{ &quot;[$reg]&quot; %}
 3993   interface(MEMORY_INTER) %{
 3994     base(0xE);   // R_SP
 3995     index(0x0);
 3996     scale(0x0);
 3997     disp($reg);  // Stack Offset
 3998   %}
 3999 %}
 4000 
 4001 operand stackSlotP(sRegP reg) %{
 4002   constraint(ALLOC_IN_RC(stack_slots));
 4003   op_cost(100);
 4004   //match(RegP);
 4005   format %{ &quot;[$reg]&quot; %}
 4006   interface(MEMORY_INTER) %{
 4007     base(0xE);   // R_SP
 4008     index(0x0);
 4009     scale(0x0);
 4010     disp($reg);  // Stack Offset
 4011   %}
 4012 %}
 4013 
 4014 operand stackSlotF(sRegF reg) %{
 4015   constraint(ALLOC_IN_RC(stack_slots));
 4016   op_cost(100);
 4017   //match(RegF);
 4018   format %{ &quot;[$reg]&quot; %}
 4019   interface(MEMORY_INTER) %{
 4020     base(0xE);   // R_SP
 4021     index(0x0);
 4022     scale(0x0);
 4023     disp($reg);  // Stack Offset
 4024   %}
 4025 %}
 4026 operand stackSlotD(sRegD reg) %{
 4027   constraint(ALLOC_IN_RC(stack_slots));
 4028   op_cost(100);
 4029   //match(RegD);
 4030   format %{ &quot;[$reg]&quot; %}
 4031   interface(MEMORY_INTER) %{
 4032     base(0xE);   // R_SP
 4033     index(0x0);
 4034     scale(0x0);
 4035     disp($reg);  // Stack Offset
 4036   %}
 4037 %}
 4038 operand stackSlotL(sRegL reg) %{
 4039   constraint(ALLOC_IN_RC(stack_slots));
 4040   op_cost(100);
 4041   //match(RegL);
 4042   format %{ &quot;[$reg]&quot; %}
 4043   interface(MEMORY_INTER) %{
 4044     base(0xE);   // R_SP
 4045     index(0x0);
 4046     scale(0x0);
 4047     disp($reg);  // Stack Offset
 4048   %}
 4049 %}
 4050 
 4051 // Operands for expressing Control Flow
 4052 // NOTE:  Label is a predefined operand which should not be redefined in
 4053 //        the AD file.  It is generically handled within the ADLC.
 4054 
 4055 //----------Conditional Branch Operands----------------------------------------
 4056 // Comparison Op  - This is the operation of the comparison, and is limited to
 4057 //                  the following set of codes:
 4058 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
 4059 //
 4060 // Other attributes of the comparison, such as unsignedness, are specified
 4061 // by the comparison instruction that sets a condition code flags register.
 4062 // That result is represented by a flags operand whose subtype is appropriate
 4063 // to the unsignedness (etc.) of the comparison.
 4064 //
 4065 // Later, the instruction which matches both the Comparison Op (a Bool) and
 4066 // the flags (produced by the Cmp) specifies the coding of the comparison op
 4067 // by matching a specific subtype of Bool operand below, such as cmpOpU.
 4068 
 4069 operand cmpOp() %{
 4070   match(Bool);
 4071 
 4072   format %{ &quot;&quot; %}
 4073   interface(COND_INTER) %{
 4074     equal(0x1);
 4075     not_equal(0x9);
 4076     less(0x3);
 4077     greater_equal(0xB);
 4078     less_equal(0x2);
 4079     greater(0xA);
 4080     overflow(0x7);
 4081     no_overflow(0xF);
 4082   %}
 4083 %}
 4084 
 4085 // Comparison Op, unsigned
 4086 operand cmpOpU() %{
 4087   match(Bool);
 4088   predicate(n-&gt;as_Bool()-&gt;_test._test != BoolTest::overflow &amp;&amp;
 4089             n-&gt;as_Bool()-&gt;_test._test != BoolTest::no_overflow);
 4090 
 4091   format %{ &quot;u&quot; %}
 4092   interface(COND_INTER) %{
 4093     equal(0x1);
 4094     not_equal(0x9);
 4095     less(0x5);
 4096     greater_equal(0xD);
 4097     less_equal(0x4);
 4098     greater(0xC);
 4099     overflow(0x7);
 4100     no_overflow(0xF);
 4101   %}
 4102 %}
 4103 
 4104 // Comparison Op, pointer (same as unsigned)
 4105 operand cmpOpP() %{
 4106   match(Bool);
 4107   predicate(n-&gt;as_Bool()-&gt;_test._test != BoolTest::overflow &amp;&amp;
 4108             n-&gt;as_Bool()-&gt;_test._test != BoolTest::no_overflow);
 4109 
 4110   format %{ &quot;p&quot; %}
 4111   interface(COND_INTER) %{
 4112     equal(0x1);
 4113     not_equal(0x9);
 4114     less(0x5);
 4115     greater_equal(0xD);
 4116     less_equal(0x4);
 4117     greater(0xC);
 4118     overflow(0x7);
 4119     no_overflow(0xF);
 4120   %}
 4121 %}
 4122 
 4123 // Comparison Op, branch-register encoding
 4124 operand cmpOp_reg() %{
 4125   match(Bool);
 4126   predicate(n-&gt;as_Bool()-&gt;_test._test != BoolTest::overflow &amp;&amp;
 4127             n-&gt;as_Bool()-&gt;_test._test != BoolTest::no_overflow);
 4128 
 4129   format %{ &quot;&quot; %}
 4130   interface(COND_INTER) %{
 4131     equal        (0x1);
 4132     not_equal    (0x5);
 4133     less         (0x3);
 4134     greater_equal(0x7);
 4135     less_equal   (0x2);
 4136     greater      (0x6);
 4137     overflow(0x7); // not supported
 4138     no_overflow(0xF); // not supported
 4139   %}
 4140 %}
 4141 
 4142 // Comparison Code, floating, unordered same as less
 4143 operand cmpOpF() %{
 4144   match(Bool);
 4145   predicate(n-&gt;as_Bool()-&gt;_test._test != BoolTest::overflow &amp;&amp;
 4146             n-&gt;as_Bool()-&gt;_test._test != BoolTest::no_overflow);
 4147 
 4148   format %{ &quot;fl&quot; %}
 4149   interface(COND_INTER) %{
 4150     equal(0x9);
 4151     not_equal(0x1);
 4152     less(0x3);
 4153     greater_equal(0xB);
 4154     less_equal(0xE);
 4155     greater(0x6);
 4156 
 4157     overflow(0x7); // not supported
 4158     no_overflow(0xF); // not supported
 4159   %}
 4160 %}
 4161 
 4162 // Used by long compare
 4163 operand cmpOp_commute() %{
 4164   match(Bool);
 4165   predicate(n-&gt;as_Bool()-&gt;_test._test != BoolTest::overflow &amp;&amp;
 4166             n-&gt;as_Bool()-&gt;_test._test != BoolTest::no_overflow);
 4167 
 4168   format %{ &quot;&quot; %}
 4169   interface(COND_INTER) %{
 4170     equal(0x1);
 4171     not_equal(0x9);
 4172     less(0xA);
 4173     greater_equal(0x2);
 4174     less_equal(0xB);
 4175     greater(0x3);
 4176     overflow(0x7);
 4177     no_overflow(0xF);
 4178   %}
 4179 %}
 4180 
 4181 //----------OPERAND CLASSES----------------------------------------------------
 4182 // Operand Classes are groups of operands that are used to simplify
 4183 // instruction definitions by not requiring the AD writer to specify separate
 4184 // instructions for every form of operand when the instruction accepts
 4185 // multiple operand types with the same basic encoding and format.  The classic
 4186 // case of this is memory operands.
 4187 opclass memory( indirect, indOffset13, indIndex );
 4188 opclass indIndexMemory( indIndex );
 4189 
 4190 //----------PIPELINE-----------------------------------------------------------
 4191 pipeline %{
 4192 
 4193 //----------ATTRIBUTES---------------------------------------------------------
 4194 attributes %{
 4195   fixed_size_instructions;           // Fixed size instructions
 4196   branch_has_delay_slot;             // Branch has delay slot following
 4197   max_instructions_per_bundle = 4;   // Up to 4 instructions per bundle
 4198   instruction_unit_size = 4;         // An instruction is 4 bytes long
 4199   instruction_fetch_unit_size = 16;  // The processor fetches one line
 4200   instruction_fetch_units = 1;       // of 16 bytes
 4201 
 4202   // List of nop instructions
 4203   nops( Nop_A0, Nop_A1, Nop_MS, Nop_FA, Nop_BR );
 4204 %}
 4205 
 4206 //----------RESOURCES----------------------------------------------------------
 4207 // Resources are the functional units available to the machine
 4208 resources(A0, A1, MS, BR, FA, FM, IDIV, FDIV, IALU = A0 | A1);
 4209 
 4210 //----------PIPELINE DESCRIPTION-----------------------------------------------
 4211 // Pipeline Description specifies the stages in the machine&#39;s pipeline
 4212 
 4213 pipe_desc(A, P, F, B, I, J, S, R, E, C, M, W, X, T, D);
 4214 
 4215 //----------PIPELINE CLASSES---------------------------------------------------
 4216 // Pipeline Classes describe the stages in which input and output are
 4217 // referenced by the hardware pipeline.
 4218 
 4219 // Integer ALU reg-reg operation
 4220 pipe_class ialu_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 4221     single_instruction;
 4222     dst   : E(write);
 4223     src1  : R(read);
 4224     src2  : R(read);
 4225     IALU  : R;
 4226 %}
 4227 
 4228 // Integer ALU reg-reg long operation
 4229 pipe_class ialu_reg_reg_2(iRegL dst, iRegL src1, iRegL src2) %{
 4230     instruction_count(2);
 4231     dst   : E(write);
 4232     src1  : R(read);
 4233     src2  : R(read);
 4234     IALU  : R;
 4235     IALU  : R;
 4236 %}
 4237 
 4238 // Integer ALU reg-reg long dependent operation
 4239 pipe_class ialu_reg_reg_2_dep(iRegL dst, iRegL src1, iRegL src2, flagsReg cr) %{
 4240     instruction_count(1); multiple_bundles;
 4241     dst   : E(write);
 4242     src1  : R(read);
 4243     src2  : R(read);
 4244     cr    : E(write);
 4245     IALU  : R(2);
 4246 %}
 4247 
 4248 // Integer ALU reg-imm operaion
 4249 pipe_class ialu_reg_imm(iRegI dst, iRegI src1, immI13 src2) %{
 4250     single_instruction;
 4251     dst   : E(write);
 4252     src1  : R(read);
 4253     IALU  : R;
 4254 %}
 4255 
 4256 // Integer ALU reg-reg operation with condition code
 4257 pipe_class ialu_cc_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 4258     single_instruction;
 4259     dst   : E(write);
 4260     cr    : E(write);
 4261     src1  : R(read);
 4262     src2  : R(read);
 4263     IALU  : R;
 4264 %}
 4265 
 4266 // Integer ALU reg-imm operation with condition code
 4267 pipe_class ialu_cc_reg_imm(iRegI dst, iRegI src1, immI13 src2, flagsReg cr) %{
 4268     single_instruction;
 4269     dst   : E(write);
 4270     cr    : E(write);
 4271     src1  : R(read);
 4272     IALU  : R;
 4273 %}
 4274 
 4275 // Integer ALU zero-reg operation
 4276 pipe_class ialu_zero_reg(iRegI dst, immI0 zero, iRegI src2) %{
 4277     single_instruction;
 4278     dst   : E(write);
 4279     src2  : R(read);
 4280     IALU  : R;
 4281 %}
 4282 
 4283 // Integer ALU zero-reg operation with condition code only
 4284 pipe_class ialu_cconly_zero_reg(flagsReg cr, iRegI src) %{
 4285     single_instruction;
 4286     cr    : E(write);
 4287     src   : R(read);
 4288     IALU  : R;
 4289 %}
 4290 
 4291 // Integer ALU reg-reg operation with condition code only
 4292 pipe_class ialu_cconly_reg_reg(flagsReg cr, iRegI src1, iRegI src2) %{
 4293     single_instruction;
 4294     cr    : E(write);
 4295     src1  : R(read);
 4296     src2  : R(read);
 4297     IALU  : R;
 4298 %}
 4299 
 4300 // Integer ALU reg-imm operation with condition code only
 4301 pipe_class ialu_cconly_reg_imm(flagsReg cr, iRegI src1, immI13 src2) %{
 4302     single_instruction;
 4303     cr    : E(write);
 4304     src1  : R(read);
 4305     IALU  : R;
 4306 %}
 4307 
 4308 // Integer ALU reg-reg-zero operation with condition code only
 4309 pipe_class ialu_cconly_reg_reg_zero(flagsReg cr, iRegI src1, iRegI src2, immI0 zero) %{
 4310     single_instruction;
 4311     cr    : E(write);
 4312     src1  : R(read);
 4313     src2  : R(read);
 4314     IALU  : R;
 4315 %}
 4316 
 4317 // Integer ALU reg-imm-zero operation with condition code only
 4318 pipe_class ialu_cconly_reg_imm_zero(flagsReg cr, iRegI src1, immI13 src2, immI0 zero) %{
 4319     single_instruction;
 4320     cr    : E(write);
 4321     src1  : R(read);
 4322     IALU  : R;
 4323 %}
 4324 
 4325 // Integer ALU reg-reg operation with condition code, src1 modified
 4326 pipe_class ialu_cc_rwreg_reg(flagsReg cr, iRegI src1, iRegI src2) %{
 4327     single_instruction;
 4328     cr    : E(write);
 4329     src1  : E(write);
 4330     src1  : R(read);
 4331     src2  : R(read);
 4332     IALU  : R;
 4333 %}
 4334 
 4335 // Integer ALU reg-imm operation with condition code, src1 modified
 4336 pipe_class ialu_cc_rwreg_imm(flagsReg cr, iRegI src1, immI13 src2) %{
 4337     single_instruction;
 4338     cr    : E(write);
 4339     src1  : E(write);
 4340     src1  : R(read);
 4341     IALU  : R;
 4342 %}
 4343 
 4344 pipe_class cmpL_reg(iRegI dst, iRegL src1, iRegL src2, flagsReg cr ) %{
 4345     multiple_bundles;
 4346     dst   : E(write)+4;
 4347     cr    : E(write);
 4348     src1  : R(read);
 4349     src2  : R(read);
 4350     IALU  : R(3);
 4351     BR    : R(2);
 4352 %}
 4353 
 4354 // Integer ALU operation
 4355 pipe_class ialu_none(iRegI dst) %{
 4356     single_instruction;
 4357     dst   : E(write);
 4358     IALU  : R;
 4359 %}
 4360 
 4361 // Integer ALU reg operation
 4362 pipe_class ialu_reg(iRegI dst, iRegI src) %{
 4363     single_instruction; may_have_no_code;
 4364     dst   : E(write);
 4365     src   : R(read);
 4366     IALU  : R;
 4367 %}
 4368 
 4369 // Integer ALU reg conditional operation
 4370 // This instruction has a 1 cycle stall, and cannot execute
 4371 // in the same cycle as the instruction setting the condition
 4372 // code. We kludge this by pretending to read the condition code
 4373 // 1 cycle earlier, and by marking the functional units as busy
 4374 // for 2 cycles with the result available 1 cycle later than
 4375 // is really the case.
 4376 pipe_class ialu_reg_flags( iRegI op2_out, iRegI op2_in, iRegI op1, flagsReg cr ) %{
 4377     single_instruction;
 4378     op2_out : C(write);
 4379     op1     : R(read);
 4380     cr      : R(read);       // This is really E, with a 1 cycle stall
 4381     BR      : R(2);
 4382     MS      : R(2);
 4383 %}
 4384 
 4385 pipe_class ialu_clr_and_mover( iRegI dst, iRegP src ) %{
 4386     instruction_count(1); multiple_bundles;
 4387     dst     : C(write)+1;
 4388     src     : R(read)+1;
 4389     IALU    : R(1);
 4390     BR      : E(2);
 4391     MS      : E(2);
 4392 %}
 4393 
 4394 // Integer ALU reg operation
 4395 pipe_class ialu_move_reg_L_to_I(iRegI dst, iRegL src) %{
 4396     single_instruction; may_have_no_code;
 4397     dst   : E(write);
 4398     src   : R(read);
 4399     IALU  : R;
 4400 %}
 4401 pipe_class ialu_move_reg_I_to_L(iRegL dst, iRegI src) %{
 4402     single_instruction; may_have_no_code;
 4403     dst   : E(write);
 4404     src   : R(read);
 4405     IALU  : R;
 4406 %}
 4407 
 4408 // Two integer ALU reg operations
 4409 pipe_class ialu_reg_2(iRegL dst, iRegL src) %{
 4410     instruction_count(2);
 4411     dst   : E(write);
 4412     src   : R(read);
 4413     A0    : R;
 4414     A1    : R;
 4415 %}
 4416 
 4417 // Two integer ALU reg operations
 4418 pipe_class ialu_move_reg_L_to_L(iRegL dst, iRegL src) %{
 4419     instruction_count(2); may_have_no_code;
 4420     dst   : E(write);
 4421     src   : R(read);
 4422     A0    : R;
 4423     A1    : R;
 4424 %}
 4425 
 4426 // Integer ALU imm operation
 4427 pipe_class ialu_imm(iRegI dst, immI13 src) %{
 4428     single_instruction;
 4429     dst   : E(write);
 4430     IALU  : R;
 4431 %}
 4432 
 4433 // Integer ALU reg-reg with carry operation
 4434 pipe_class ialu_reg_reg_cy(iRegI dst, iRegI src1, iRegI src2, iRegI cy) %{
 4435     single_instruction;
 4436     dst   : E(write);
 4437     src1  : R(read);
 4438     src2  : R(read);
 4439     IALU  : R;
 4440 %}
 4441 
 4442 // Integer ALU cc operation
 4443 pipe_class ialu_cc(iRegI dst, flagsReg cc) %{
 4444     single_instruction;
 4445     dst   : E(write);
 4446     cc    : R(read);
 4447     IALU  : R;
 4448 %}
 4449 
 4450 // Integer ALU cc / second IALU operation
 4451 pipe_class ialu_reg_ialu( iRegI dst, iRegI src ) %{
 4452     instruction_count(1); multiple_bundles;
 4453     dst   : E(write)+1;
 4454     src   : R(read);
 4455     IALU  : R;
 4456 %}
 4457 
 4458 // Integer ALU cc / second IALU operation
 4459 pipe_class ialu_reg_reg_ialu( iRegI dst, iRegI p, iRegI q ) %{
 4460     instruction_count(1); multiple_bundles;
 4461     dst   : E(write)+1;
 4462     p     : R(read);
 4463     q     : R(read);
 4464     IALU  : R;
 4465 %}
 4466 
 4467 // Integer ALU hi-lo-reg operation
 4468 pipe_class ialu_hi_lo_reg(iRegI dst, immI src) %{
 4469     instruction_count(1); multiple_bundles;
 4470     dst   : E(write)+1;
 4471     IALU  : R(2);
 4472 %}
 4473 
 4474 // Float ALU hi-lo-reg operation (with temp)
 4475 pipe_class ialu_hi_lo_reg_temp(regF dst, immF src, g3RegP tmp) %{
 4476     instruction_count(1); multiple_bundles;
 4477     dst   : E(write)+1;
 4478     IALU  : R(2);
 4479 %}
 4480 
 4481 // Long Constant
 4482 pipe_class loadConL( iRegL dst, immL src ) %{
 4483     instruction_count(2); multiple_bundles;
 4484     dst   : E(write)+1;
 4485     IALU  : R(2);
 4486     IALU  : R(2);
 4487 %}
 4488 
 4489 // Pointer Constant
 4490 pipe_class loadConP( iRegP dst, immP src ) %{
 4491     instruction_count(0); multiple_bundles;
 4492     fixed_latency(6);
 4493 %}
 4494 
 4495 // Polling Address
 4496 pipe_class loadConP_poll( iRegP dst, immP_poll src ) %{
 4497     instruction_count(0); multiple_bundles;
 4498     fixed_latency(6);
 4499 %}
 4500 
 4501 // Long Constant small
 4502 pipe_class loadConLlo( iRegL dst, immL src ) %{
 4503     instruction_count(2);
 4504     dst   : E(write);
 4505     IALU  : R;
 4506     IALU  : R;
 4507 %}
 4508 
 4509 // [PHH] This is wrong for 64-bit.  See LdImmF/D.
 4510 pipe_class loadConFD(regF dst, immF src, g3RegP tmp) %{
 4511     instruction_count(1); multiple_bundles;
 4512     src   : R(read);
 4513     dst   : M(write)+1;
 4514     IALU  : R;
 4515     MS    : E;
 4516 %}
 4517 
 4518 // Integer ALU nop operation
 4519 pipe_class ialu_nop() %{
 4520     single_instruction;
 4521     IALU  : R;
 4522 %}
 4523 
 4524 // Integer ALU nop operation
 4525 pipe_class ialu_nop_A0() %{
 4526     single_instruction;
 4527     A0    : R;
 4528 %}
 4529 
 4530 // Integer ALU nop operation
 4531 pipe_class ialu_nop_A1() %{
 4532     single_instruction;
 4533     A1    : R;
 4534 %}
 4535 
 4536 // Integer Multiply reg-reg operation
 4537 pipe_class imul_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 4538     single_instruction;
 4539     dst   : E(write);
 4540     src1  : R(read);
 4541     src2  : R(read);
 4542     MS    : R(5);
 4543 %}
 4544 
 4545 // Integer Multiply reg-imm operation
 4546 pipe_class imul_reg_imm(iRegI dst, iRegI src1, immI13 src2) %{
 4547     single_instruction;
 4548     dst   : E(write);
 4549     src1  : R(read);
 4550     MS    : R(5);
 4551 %}
 4552 
 4553 pipe_class mulL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 4554     single_instruction;
 4555     dst   : E(write)+4;
 4556     src1  : R(read);
 4557     src2  : R(read);
 4558     MS    : R(6);
 4559 %}
 4560 
 4561 pipe_class mulL_reg_imm(iRegL dst, iRegL src1, immL13 src2) %{
 4562     single_instruction;
 4563     dst   : E(write)+4;
 4564     src1  : R(read);
 4565     MS    : R(6);
 4566 %}
 4567 
 4568 // Integer Divide reg-reg
 4569 pipe_class sdiv_reg_reg(iRegI dst, iRegI src1, iRegI src2, iRegI temp, flagsReg cr) %{
 4570     instruction_count(1); multiple_bundles;
 4571     dst   : E(write);
 4572     temp  : E(write);
 4573     src1  : R(read);
 4574     src2  : R(read);
 4575     temp  : R(read);
 4576     MS    : R(38);
 4577 %}
 4578 
 4579 // Integer Divide reg-imm
 4580 pipe_class sdiv_reg_imm(iRegI dst, iRegI src1, immI13 src2, iRegI temp, flagsReg cr) %{
 4581     instruction_count(1); multiple_bundles;
 4582     dst   : E(write);
 4583     temp  : E(write);
 4584     src1  : R(read);
 4585     temp  : R(read);
 4586     MS    : R(38);
 4587 %}
 4588 
 4589 // Long Divide
 4590 pipe_class divL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 4591     dst  : E(write)+71;
 4592     src1 : R(read);
 4593     src2 : R(read)+1;
 4594     MS   : R(70);
 4595 %}
 4596 
 4597 pipe_class divL_reg_imm(iRegL dst, iRegL src1, immL13 src2) %{
 4598     dst  : E(write)+71;
 4599     src1 : R(read);
 4600     MS   : R(70);
 4601 %}
 4602 
 4603 // Floating Point Add Float
 4604 pipe_class faddF_reg_reg(regF dst, regF src1, regF src2) %{
 4605     single_instruction;
 4606     dst   : X(write);
 4607     src1  : E(read);
 4608     src2  : E(read);
 4609     FA    : R;
 4610 %}
 4611 
 4612 // Floating Point Add Double
 4613 pipe_class faddD_reg_reg(regD dst, regD src1, regD src2) %{
 4614     single_instruction;
 4615     dst   : X(write);
 4616     src1  : E(read);
 4617     src2  : E(read);
 4618     FA    : R;
 4619 %}
 4620 
 4621 // Floating Point Conditional Move based on integer flags
 4622 pipe_class int_conditional_float_move (cmpOp cmp, flagsReg cr, regF dst, regF src) %{
 4623     single_instruction;
 4624     dst   : X(write);
 4625     src   : E(read);
 4626     cr    : R(read);
 4627     FA    : R(2);
 4628     BR    : R(2);
 4629 %}
 4630 
 4631 // Floating Point Conditional Move based on integer flags
 4632 pipe_class int_conditional_double_move (cmpOp cmp, flagsReg cr, regD dst, regD src) %{
 4633     single_instruction;
 4634     dst   : X(write);
 4635     src   : E(read);
 4636     cr    : R(read);
 4637     FA    : R(2);
 4638     BR    : R(2);
 4639 %}
 4640 
 4641 // Floating Point Multiply Float
 4642 pipe_class fmulF_reg_reg(regF dst, regF src1, regF src2) %{
 4643     single_instruction;
 4644     dst   : X(write);
 4645     src1  : E(read);
 4646     src2  : E(read);
 4647     FM    : R;
 4648 %}
 4649 
 4650 // Floating Point Multiply Double
 4651 pipe_class fmulD_reg_reg(regD dst, regD src1, regD src2) %{
 4652     single_instruction;
 4653     dst   : X(write);
 4654     src1  : E(read);
 4655     src2  : E(read);
 4656     FM    : R;
 4657 %}
 4658 
 4659 // Floating Point Divide Float
 4660 pipe_class fdivF_reg_reg(regF dst, regF src1, regF src2) %{
 4661     single_instruction;
 4662     dst   : X(write);
 4663     src1  : E(read);
 4664     src2  : E(read);
 4665     FM    : R;
 4666     FDIV  : C(14);
 4667 %}
 4668 
 4669 // Floating Point Divide Double
 4670 pipe_class fdivD_reg_reg(regD dst, regD src1, regD src2) %{
 4671     single_instruction;
 4672     dst   : X(write);
 4673     src1  : E(read);
 4674     src2  : E(read);
 4675     FM    : R;
 4676     FDIV  : C(17);
 4677 %}
 4678 
 4679 // Fused floating-point multiply-add float.
 4680 pipe_class fmaF_regx4(regF dst, regF src1, regF src2, regF src3) %{
 4681     single_instruction;
 4682     dst   : X(write);
 4683     src1  : E(read);
 4684     src2  : E(read);
 4685     src3  : E(read);
 4686     FM    : R;
 4687 %}
 4688 
 4689 // Fused gloating-point multiply-add double.
 4690 pipe_class fmaD_regx4(regD dst, regD src1, regD src2, regD src3) %{
 4691     single_instruction;
 4692     dst   : X(write);
 4693     src1  : E(read);
 4694     src2  : E(read);
 4695     src3  : E(read);
 4696     FM    : R;
 4697 %}
 4698 
 4699 // Floating Point Move/Negate/Abs Float
 4700 pipe_class faddF_reg(regF dst, regF src) %{
 4701     single_instruction;
 4702     dst   : W(write);
 4703     src   : E(read);
 4704     FA    : R(1);
 4705 %}
 4706 
 4707 // Floating Point Move/Negate/Abs Double
 4708 pipe_class faddD_reg(regD dst, regD src) %{
 4709     single_instruction;
 4710     dst   : W(write);
 4711     src   : E(read);
 4712     FA    : R;
 4713 %}
 4714 
 4715 // Floating Point Convert F-&gt;D
 4716 pipe_class fcvtF2D(regD dst, regF src) %{
 4717     single_instruction;
 4718     dst   : X(write);
 4719     src   : E(read);
 4720     FA    : R;
 4721 %}
 4722 
 4723 // Floating Point Convert I-&gt;D
 4724 pipe_class fcvtI2D(regD dst, regF src) %{
 4725     single_instruction;
 4726     dst   : X(write);
 4727     src   : E(read);
 4728     FA    : R;
 4729 %}
 4730 
 4731 // Floating Point Convert LHi-&gt;D
 4732 pipe_class fcvtLHi2D(regD dst, regD src) %{
 4733     single_instruction;
 4734     dst   : X(write);
 4735     src   : E(read);
 4736     FA    : R;
 4737 %}
 4738 
 4739 // Floating Point Convert L-&gt;D
 4740 pipe_class fcvtL2D(regD dst, regF src) %{
 4741     single_instruction;
 4742     dst   : X(write);
 4743     src   : E(read);
 4744     FA    : R;
 4745 %}
 4746 
 4747 // Floating Point Convert L-&gt;F
 4748 pipe_class fcvtL2F(regD dst, regF src) %{
 4749     single_instruction;
 4750     dst   : X(write);
 4751     src   : E(read);
 4752     FA    : R;
 4753 %}
 4754 
 4755 // Floating Point Convert D-&gt;F
 4756 pipe_class fcvtD2F(regD dst, regF src) %{
 4757     single_instruction;
 4758     dst   : X(write);
 4759     src   : E(read);
 4760     FA    : R;
 4761 %}
 4762 
 4763 // Floating Point Convert I-&gt;L
 4764 pipe_class fcvtI2L(regD dst, regF src) %{
 4765     single_instruction;
 4766     dst   : X(write);
 4767     src   : E(read);
 4768     FA    : R;
 4769 %}
 4770 
 4771 // Floating Point Convert D-&gt;F
 4772 pipe_class fcvtD2I(regF dst, regD src, flagsReg cr) %{
 4773     instruction_count(1); multiple_bundles;
 4774     dst   : X(write)+6;
 4775     src   : E(read);
 4776     FA    : R;
 4777 %}
 4778 
 4779 // Floating Point Convert D-&gt;L
 4780 pipe_class fcvtD2L(regD dst, regD src, flagsReg cr) %{
 4781     instruction_count(1); multiple_bundles;
 4782     dst   : X(write)+6;
 4783     src   : E(read);
 4784     FA    : R;
 4785 %}
 4786 
 4787 // Floating Point Convert F-&gt;I
 4788 pipe_class fcvtF2I(regF dst, regF src, flagsReg cr) %{
 4789     instruction_count(1); multiple_bundles;
 4790     dst   : X(write)+6;
 4791     src   : E(read);
 4792     FA    : R;
 4793 %}
 4794 
 4795 // Floating Point Convert F-&gt;L
 4796 pipe_class fcvtF2L(regD dst, regF src, flagsReg cr) %{
 4797     instruction_count(1); multiple_bundles;
 4798     dst   : X(write)+6;
 4799     src   : E(read);
 4800     FA    : R;
 4801 %}
 4802 
 4803 // Floating Point Convert I-&gt;F
 4804 pipe_class fcvtI2F(regF dst, regF src) %{
 4805     single_instruction;
 4806     dst   : X(write);
 4807     src   : E(read);
 4808     FA    : R;
 4809 %}
 4810 
 4811 // Floating Point Compare
 4812 pipe_class faddF_fcc_reg_reg_zero(flagsRegF cr, regF src1, regF src2, immI0 zero) %{
 4813     single_instruction;
 4814     cr    : X(write);
 4815     src1  : E(read);
 4816     src2  : E(read);
 4817     FA    : R;
 4818 %}
 4819 
 4820 // Floating Point Compare
 4821 pipe_class faddD_fcc_reg_reg_zero(flagsRegF cr, regD src1, regD src2, immI0 zero) %{
 4822     single_instruction;
 4823     cr    : X(write);
 4824     src1  : E(read);
 4825     src2  : E(read);
 4826     FA    : R;
 4827 %}
 4828 
 4829 // Floating Add Nop
 4830 pipe_class fadd_nop() %{
 4831     single_instruction;
 4832     FA  : R;
 4833 %}
 4834 
 4835 // Integer Store to Memory
 4836 pipe_class istore_mem_reg(memory mem, iRegI src) %{
 4837     single_instruction;
 4838     mem   : R(read);
 4839     src   : C(read);
 4840     MS    : R;
 4841 %}
 4842 
 4843 // Integer Store to Memory
 4844 pipe_class istore_mem_spORreg(memory mem, sp_ptr_RegP src) %{
 4845     single_instruction;
 4846     mem   : R(read);
 4847     src   : C(read);
 4848     MS    : R;
 4849 %}
 4850 
 4851 // Integer Store Zero to Memory
 4852 pipe_class istore_mem_zero(memory mem, immI0 src) %{
 4853     single_instruction;
 4854     mem   : R(read);
 4855     MS    : R;
 4856 %}
 4857 
 4858 // Special Stack Slot Store
 4859 pipe_class istore_stk_reg(stackSlotI stkSlot, iRegI src) %{
 4860     single_instruction;
 4861     stkSlot : R(read);
 4862     src     : C(read);
 4863     MS      : R;
 4864 %}
 4865 
 4866 // Special Stack Slot Store
 4867 pipe_class lstoreI_stk_reg(stackSlotL stkSlot, iRegI src) %{
 4868     instruction_count(2); multiple_bundles;
 4869     stkSlot : R(read);
 4870     src     : C(read);
 4871     MS      : R(2);
 4872 %}
 4873 
 4874 // Float Store
 4875 pipe_class fstoreF_mem_reg(memory mem, RegF src) %{
 4876     single_instruction;
 4877     mem : R(read);
 4878     src : C(read);
 4879     MS  : R;
 4880 %}
 4881 
 4882 // Float Store
 4883 pipe_class fstoreF_mem_zero(memory mem, immF0 src) %{
 4884     single_instruction;
 4885     mem : R(read);
 4886     MS  : R;
 4887 %}
 4888 
 4889 // Double Store
 4890 pipe_class fstoreD_mem_reg(memory mem, RegD src) %{
 4891     instruction_count(1);
 4892     mem : R(read);
 4893     src : C(read);
 4894     MS  : R;
 4895 %}
 4896 
 4897 // Double Store
 4898 pipe_class fstoreD_mem_zero(memory mem, immD0 src) %{
 4899     single_instruction;
 4900     mem : R(read);
 4901     MS  : R;
 4902 %}
 4903 
 4904 // Special Stack Slot Float Store
 4905 pipe_class fstoreF_stk_reg(stackSlotI stkSlot, RegF src) %{
 4906     single_instruction;
 4907     stkSlot : R(read);
 4908     src     : C(read);
 4909     MS      : R;
 4910 %}
 4911 
 4912 // Special Stack Slot Double Store
 4913 pipe_class fstoreD_stk_reg(stackSlotI stkSlot, RegD src) %{
 4914     single_instruction;
 4915     stkSlot : R(read);
 4916     src     : C(read);
 4917     MS      : R;
 4918 %}
 4919 
 4920 // Integer Load (when sign bit propagation not needed)
 4921 pipe_class iload_mem(iRegI dst, memory mem) %{
 4922     single_instruction;
 4923     mem : R(read);
 4924     dst : C(write);
 4925     MS  : R;
 4926 %}
 4927 
 4928 // Integer Load from stack operand
 4929 pipe_class iload_stkD(iRegI dst, stackSlotD mem ) %{
 4930     single_instruction;
 4931     mem : R(read);
 4932     dst : C(write);
 4933     MS  : R;
 4934 %}
 4935 
 4936 // Integer Load (when sign bit propagation or masking is needed)
 4937 pipe_class iload_mask_mem(iRegI dst, memory mem) %{
 4938     single_instruction;
 4939     mem : R(read);
 4940     dst : M(write);
 4941     MS  : R;
 4942 %}
 4943 
 4944 // Float Load
 4945 pipe_class floadF_mem(regF dst, memory mem) %{
 4946     single_instruction;
 4947     mem : R(read);
 4948     dst : M(write);
 4949     MS  : R;
 4950 %}
 4951 
 4952 // Float Load
 4953 pipe_class floadD_mem(regD dst, memory mem) %{
 4954     instruction_count(1); multiple_bundles; // Again, unaligned argument is only multiple case
 4955     mem : R(read);
 4956     dst : M(write);
 4957     MS  : R;
 4958 %}
 4959 
 4960 // Float Load
 4961 pipe_class floadF_stk(regF dst, stackSlotI stkSlot) %{
 4962     single_instruction;
 4963     stkSlot : R(read);
 4964     dst : M(write);
 4965     MS  : R;
 4966 %}
 4967 
 4968 // Float Load
 4969 pipe_class floadD_stk(regD dst, stackSlotI stkSlot) %{
 4970     single_instruction;
 4971     stkSlot : R(read);
 4972     dst : M(write);
 4973     MS  : R;
 4974 %}
 4975 
 4976 // Memory Nop
 4977 pipe_class mem_nop() %{
 4978     single_instruction;
 4979     MS  : R;
 4980 %}
 4981 
 4982 pipe_class sethi(iRegP dst, immI src) %{
 4983     single_instruction;
 4984     dst  : E(write);
 4985     IALU : R;
 4986 %}
 4987 
 4988 pipe_class loadPollP(iRegP poll) %{
 4989     single_instruction;
 4990     poll : R(read);
 4991     MS   : R;
 4992 %}
 4993 
 4994 pipe_class br(Universe br, label labl) %{
 4995     single_instruction_with_delay_slot;
 4996     BR  : R;
 4997 %}
 4998 
 4999 pipe_class br_cc(Universe br, cmpOp cmp, flagsReg cr, label labl) %{
 5000     single_instruction_with_delay_slot;
 5001     cr    : E(read);
 5002     BR    : R;
 5003 %}
 5004 
 5005 pipe_class br_reg(Universe br, cmpOp cmp, iRegI op1, label labl) %{
 5006     single_instruction_with_delay_slot;
 5007     op1 : E(read);
 5008     BR  : R;
 5009     MS  : R;
 5010 %}
 5011 
 5012 // Compare and branch
 5013 pipe_class cmp_br_reg_reg(Universe br, cmpOp cmp, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 5014     instruction_count(2); has_delay_slot;
 5015     cr    : E(write);
 5016     src1  : R(read);
 5017     src2  : R(read);
 5018     IALU  : R;
 5019     BR    : R;
 5020 %}
 5021 
 5022 // Compare and branch
 5023 pipe_class cmp_br_reg_imm(Universe br, cmpOp cmp, iRegI src1, immI13 src2, label labl, flagsReg cr) %{
 5024     instruction_count(2); has_delay_slot;
 5025     cr    : E(write);
 5026     src1  : R(read);
 5027     IALU  : R;
 5028     BR    : R;
 5029 %}
 5030 
 5031 // Compare and branch using cbcond
 5032 pipe_class cbcond_reg_reg(Universe br, cmpOp cmp, iRegI src1, iRegI src2, label labl) %{
 5033     single_instruction;
 5034     src1  : E(read);
 5035     src2  : E(read);
 5036     IALU  : R;
 5037     BR    : R;
 5038 %}
 5039 
 5040 // Compare and branch using cbcond
 5041 pipe_class cbcond_reg_imm(Universe br, cmpOp cmp, iRegI src1, immI5 src2, label labl) %{
 5042     single_instruction;
 5043     src1  : E(read);
 5044     IALU  : R;
 5045     BR    : R;
 5046 %}
 5047 
 5048 pipe_class br_fcc(Universe br, cmpOpF cc, flagsReg cr, label labl) %{
 5049     single_instruction_with_delay_slot;
 5050     cr    : E(read);
 5051     BR    : R;
 5052 %}
 5053 
 5054 pipe_class br_nop() %{
 5055     single_instruction;
 5056     BR  : R;
 5057 %}
 5058 
 5059 pipe_class simple_call(method meth) %{
 5060     instruction_count(2); multiple_bundles; force_serialization;
 5061     fixed_latency(100);
 5062     BR  : R(1);
 5063     MS  : R(1);
 5064     A0  : R(1);
 5065 %}
 5066 
 5067 pipe_class compiled_call(method meth) %{
 5068     instruction_count(1); multiple_bundles; force_serialization;
 5069     fixed_latency(100);
 5070     MS  : R(1);
 5071 %}
 5072 
 5073 pipe_class call(method meth) %{
 5074     instruction_count(0); multiple_bundles; force_serialization;
 5075     fixed_latency(100);
 5076 %}
 5077 
 5078 pipe_class tail_call(Universe ignore, label labl) %{
 5079     single_instruction; has_delay_slot;
 5080     fixed_latency(100);
 5081     BR  : R(1);
 5082     MS  : R(1);
 5083 %}
 5084 
 5085 pipe_class ret(Universe ignore) %{
 5086     single_instruction; has_delay_slot;
 5087     BR  : R(1);
 5088     MS  : R(1);
 5089 %}
 5090 
 5091 pipe_class ret_poll(g3RegP poll) %{
 5092     instruction_count(3); has_delay_slot;
 5093     poll : E(read);
 5094     MS   : R;
 5095 %}
 5096 
 5097 // The real do-nothing guy
 5098 pipe_class empty( ) %{
 5099     instruction_count(0);
 5100 %}
 5101 
 5102 pipe_class long_memory_op() %{
 5103     instruction_count(0); multiple_bundles; force_serialization;
 5104     fixed_latency(25);
 5105     MS  : R(1);
 5106 %}
 5107 
 5108 // Check-cast
 5109 pipe_class partial_subtype_check_pipe(Universe ignore, iRegP array, iRegP match ) %{
 5110     array : R(read);
 5111     match  : R(read);
 5112     IALU   : R(2);
 5113     BR     : R(2);
 5114     MS     : R;
 5115 %}
 5116 
 5117 // Convert FPU flags into +1,0,-1
 5118 pipe_class floating_cmp( iRegI dst, regF src1, regF src2 ) %{
 5119     src1  : E(read);
 5120     src2  : E(read);
 5121     dst   : E(write);
 5122     FA    : R;
 5123     MS    : R(2);
 5124     BR    : R(2);
 5125 %}
 5126 
 5127 // Compare for p &lt; q, and conditionally add y
 5128 pipe_class cadd_cmpltmask( iRegI p, iRegI q, iRegI y ) %{
 5129     p     : E(read);
 5130     q     : E(read);
 5131     y     : E(read);
 5132     IALU  : R(3)
 5133 %}
 5134 
 5135 // Perform a compare, then move conditionally in a branch delay slot.
 5136 pipe_class min_max( iRegI src2, iRegI srcdst ) %{
 5137     src2   : E(read);
 5138     srcdst : E(read);
 5139     IALU   : R;
 5140     BR     : R;
 5141 %}
 5142 
 5143 // Define the class for the Nop node
 5144 define %{
 5145    MachNop = ialu_nop;
 5146 %}
 5147 
 5148 %}
 5149 
 5150 //----------INSTRUCTIONS-------------------------------------------------------
 5151 
 5152 //------------Special Stack Slot instructions - no match rules-----------------
 5153 instruct stkI_to_regF(regF dst, stackSlotI src) %{
 5154   // No match rule to avoid chain rule match.
 5155   effect(DEF dst, USE src);
 5156   ins_cost(MEMORY_REF_COST);
 5157   format %{ &quot;LDF    $src,$dst\t! stkI to regF&quot; %}
 5158   opcode(Assembler::ldf_op3);
 5159   ins_encode(simple_form3_mem_reg(src, dst));
 5160   ins_pipe(floadF_stk);
 5161 %}
 5162 
 5163 instruct stkL_to_regD(regD dst, stackSlotL src) %{
 5164   // No match rule to avoid chain rule match.
 5165   effect(DEF dst, USE src);
 5166   ins_cost(MEMORY_REF_COST);
 5167   format %{ &quot;LDDF   $src,$dst\t! stkL to regD&quot; %}
 5168   opcode(Assembler::lddf_op3);
 5169   ins_encode(simple_form3_mem_reg(src, dst));
 5170   ins_pipe(floadD_stk);
 5171 %}
 5172 
 5173 instruct regF_to_stkI(stackSlotI dst, regF src) %{
 5174   // No match rule to avoid chain rule match.
 5175   effect(DEF dst, USE src);
 5176   ins_cost(MEMORY_REF_COST);
 5177   format %{ &quot;STF    $src,$dst\t! regF to stkI&quot; %}
 5178   opcode(Assembler::stf_op3);
 5179   ins_encode(simple_form3_mem_reg(dst, src));
 5180   ins_pipe(fstoreF_stk_reg);
 5181 %}
 5182 
 5183 instruct regD_to_stkL(stackSlotL dst, regD src) %{
 5184   // No match rule to avoid chain rule match.
 5185   effect(DEF dst, USE src);
 5186   ins_cost(MEMORY_REF_COST);
 5187   format %{ &quot;STDF   $src,$dst\t! regD to stkL&quot; %}
 5188   opcode(Assembler::stdf_op3);
 5189   ins_encode(simple_form3_mem_reg(dst, src));
 5190   ins_pipe(fstoreD_stk_reg);
 5191 %}
 5192 
 5193 instruct regI_to_stkLHi(stackSlotL dst, iRegI src) %{
 5194   effect(DEF dst, USE src);
 5195   ins_cost(MEMORY_REF_COST*2);
 5196   format %{ &quot;STW    $src,$dst.hi\t! long\n\t&quot;
 5197             &quot;STW    R_G0,$dst.lo&quot; %}
 5198   opcode(Assembler::stw_op3);
 5199   ins_encode(simple_form3_mem_reg(dst, src), form3_mem_plus_4_reg(dst, R_G0));
 5200   ins_pipe(lstoreI_stk_reg);
 5201 %}
 5202 
 5203 instruct regL_to_stkD(stackSlotD dst, iRegL src) %{
 5204   // No match rule to avoid chain rule match.
 5205   effect(DEF dst, USE src);
 5206   ins_cost(MEMORY_REF_COST);
 5207   format %{ &quot;STX    $src,$dst\t! regL to stkD&quot; %}
 5208   opcode(Assembler::stx_op3);
 5209   ins_encode(simple_form3_mem_reg( dst, src ) );
 5210   ins_pipe(istore_stk_reg);
 5211 %}
 5212 
 5213 //---------- Chain stack slots between similar types --------
 5214 
 5215 // Load integer from stack slot
 5216 instruct stkI_to_regI( iRegI dst, stackSlotI src ) %{
 5217   match(Set dst src);
 5218   ins_cost(MEMORY_REF_COST);
 5219 
 5220   format %{ &quot;LDUW   $src,$dst\t!stk&quot; %}
 5221   opcode(Assembler::lduw_op3);
 5222   ins_encode(simple_form3_mem_reg( src, dst ) );
 5223   ins_pipe(iload_mem);
 5224 %}
 5225 
 5226 // Store integer to stack slot
 5227 instruct regI_to_stkI( stackSlotI dst, iRegI src ) %{
 5228   match(Set dst src);
 5229   ins_cost(MEMORY_REF_COST);
 5230 
 5231   format %{ &quot;STW    $src,$dst\t!stk&quot; %}
 5232   opcode(Assembler::stw_op3);
 5233   ins_encode(simple_form3_mem_reg( dst, src ) );
 5234   ins_pipe(istore_mem_reg);
 5235 %}
 5236 
 5237 // Load long from stack slot
 5238 instruct stkL_to_regL( iRegL dst, stackSlotL src ) %{
 5239   match(Set dst src);
 5240 
 5241   ins_cost(MEMORY_REF_COST);
 5242   format %{ &quot;LDX    $src,$dst\t! long&quot; %}
 5243   opcode(Assembler::ldx_op3);
 5244   ins_encode(simple_form3_mem_reg( src, dst ) );
 5245   ins_pipe(iload_mem);
 5246 %}
 5247 
 5248 // Store long to stack slot
 5249 instruct regL_to_stkL(stackSlotL dst, iRegL src) %{
 5250   match(Set dst src);
 5251 
 5252   ins_cost(MEMORY_REF_COST);
 5253   format %{ &quot;STX    $src,$dst\t! long&quot; %}
 5254   opcode(Assembler::stx_op3);
 5255   ins_encode(simple_form3_mem_reg( dst, src ) );
 5256   ins_pipe(istore_mem_reg);
 5257 %}
 5258 
 5259 // Load pointer from stack slot, 64-bit encoding
 5260 instruct stkP_to_regP( iRegP dst, stackSlotP src ) %{
 5261   match(Set dst src);
 5262   ins_cost(MEMORY_REF_COST);
 5263   format %{ &quot;LDX    $src,$dst\t!ptr&quot; %}
 5264   opcode(Assembler::ldx_op3);
 5265   ins_encode(simple_form3_mem_reg( src, dst ) );
 5266   ins_pipe(iload_mem);
 5267 %}
 5268 
 5269 // Store pointer to stack slot
 5270 instruct regP_to_stkP(stackSlotP dst, iRegP src) %{
 5271   match(Set dst src);
 5272   ins_cost(MEMORY_REF_COST);
 5273   format %{ &quot;STX    $src,$dst\t!ptr&quot; %}
 5274   opcode(Assembler::stx_op3);
 5275   ins_encode(simple_form3_mem_reg( dst, src ) );
 5276   ins_pipe(istore_mem_reg);
 5277 %}
 5278 
 5279 //------------Special Nop instructions for bundling - no match rules-----------
 5280 // Nop using the A0 functional unit
 5281 instruct Nop_A0() %{
 5282   ins_cost(0);
 5283 
 5284   format %{ &quot;NOP    ! Alu Pipeline&quot; %}
 5285   opcode(Assembler::or_op3, Assembler::arith_op);
 5286   ins_encode( form2_nop() );
 5287   ins_pipe(ialu_nop_A0);
 5288 %}
 5289 
 5290 // Nop using the A1 functional unit
 5291 instruct Nop_A1( ) %{
 5292   ins_cost(0);
 5293 
 5294   format %{ &quot;NOP    ! Alu Pipeline&quot; %}
 5295   opcode(Assembler::or_op3, Assembler::arith_op);
 5296   ins_encode( form2_nop() );
 5297   ins_pipe(ialu_nop_A1);
 5298 %}
 5299 
 5300 // Nop using the memory functional unit
 5301 instruct Nop_MS( ) %{
 5302   ins_cost(0);
 5303 
 5304   format %{ &quot;NOP    ! Memory Pipeline&quot; %}
 5305   ins_encode( emit_mem_nop );
 5306   ins_pipe(mem_nop);
 5307 %}
 5308 
 5309 // Nop using the floating add functional unit
 5310 instruct Nop_FA( ) %{
 5311   ins_cost(0);
 5312 
 5313   format %{ &quot;NOP    ! Floating Add Pipeline&quot; %}
 5314   ins_encode( emit_fadd_nop );
 5315   ins_pipe(fadd_nop);
 5316 %}
 5317 
 5318 // Nop using the branch functional unit
 5319 instruct Nop_BR( ) %{
 5320   ins_cost(0);
 5321 
 5322   format %{ &quot;NOP    ! Branch Pipeline&quot; %}
 5323   ins_encode( emit_br_nop );
 5324   ins_pipe(br_nop);
 5325 %}
 5326 
 5327 //----------Load/Store/Move Instructions---------------------------------------
 5328 //----------Load Instructions--------------------------------------------------
 5329 // Load Byte (8bit signed)
 5330 instruct loadB(iRegI dst, memory mem) %{
 5331   match(Set dst (LoadB mem));
 5332   ins_cost(MEMORY_REF_COST);
 5333 
 5334   size(4);
 5335   format %{ &quot;LDSB   $mem,$dst\t! byte&quot; %}
 5336   ins_encode %{
 5337     __ ldsb($mem$$Address, $dst$$Register);
 5338   %}
 5339   ins_pipe(iload_mask_mem);
 5340 %}
 5341 
 5342 // Load Byte (8bit signed) into a Long Register
 5343 instruct loadB2L(iRegL dst, memory mem) %{
 5344   match(Set dst (ConvI2L (LoadB mem)));
 5345   ins_cost(MEMORY_REF_COST);
 5346 
 5347   size(4);
 5348   format %{ &quot;LDSB   $mem,$dst\t! byte -&gt; long&quot; %}
 5349   ins_encode %{
 5350     __ ldsb($mem$$Address, $dst$$Register);
 5351   %}
 5352   ins_pipe(iload_mask_mem);
 5353 %}
 5354 
 5355 // Load Unsigned Byte (8bit UNsigned) into an int reg
 5356 instruct loadUB(iRegI dst, memory mem) %{
 5357   match(Set dst (LoadUB mem));
 5358   ins_cost(MEMORY_REF_COST);
 5359 
 5360   size(4);
 5361   format %{ &quot;LDUB   $mem,$dst\t! ubyte&quot; %}
 5362   ins_encode %{
 5363     __ ldub($mem$$Address, $dst$$Register);
 5364   %}
 5365   ins_pipe(iload_mem);
 5366 %}
 5367 
 5368 // Load Unsigned Byte (8bit UNsigned) into a Long Register
 5369 instruct loadUB2L(iRegL dst, memory mem) %{
 5370   match(Set dst (ConvI2L (LoadUB mem)));
 5371   ins_cost(MEMORY_REF_COST);
 5372 
 5373   size(4);
 5374   format %{ &quot;LDUB   $mem,$dst\t! ubyte -&gt; long&quot; %}
 5375   ins_encode %{
 5376     __ ldub($mem$$Address, $dst$$Register);
 5377   %}
 5378   ins_pipe(iload_mem);
 5379 %}
 5380 
 5381 // Load Unsigned Byte (8 bit UNsigned) with 32-bit mask into Long Register
 5382 instruct loadUB2L_immI(iRegL dst, memory mem, immI mask) %{
 5383   match(Set dst (ConvI2L (AndI (LoadUB mem) mask)));
 5384   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5385 
 5386   size(2*4);
 5387   format %{ &quot;LDUB   $mem,$dst\t# ubyte &amp; 32-bit mask -&gt; long\n\t&quot;
 5388             &quot;AND    $dst,right_n_bits($mask, 8),$dst&quot; %}
 5389   ins_encode %{
 5390     __ ldub($mem$$Address, $dst$$Register);
 5391     __ and3($dst$$Register, $mask$$constant &amp; right_n_bits(8), $dst$$Register);
 5392   %}
 5393   ins_pipe(iload_mem);
 5394 %}
 5395 
 5396 // Load Short (16bit signed)
 5397 instruct loadS(iRegI dst, memory mem) %{
 5398   match(Set dst (LoadS mem));
 5399   ins_cost(MEMORY_REF_COST);
 5400 
 5401   size(4);
 5402   format %{ &quot;LDSH   $mem,$dst\t! short&quot; %}
 5403   ins_encode %{
 5404     __ ldsh($mem$$Address, $dst$$Register);
 5405   %}
 5406   ins_pipe(iload_mask_mem);
 5407 %}
 5408 
 5409 // Load Short (16 bit signed) to Byte (8 bit signed)
 5410 instruct loadS2B(iRegI dst, indOffset13m7 mem, immI_24 twentyfour) %{
 5411   match(Set dst (RShiftI (LShiftI (LoadS mem) twentyfour) twentyfour));
 5412   ins_cost(MEMORY_REF_COST);
 5413 
 5414   size(4);
 5415 
 5416   format %{ &quot;LDSB   $mem+1,$dst\t! short -&gt; byte&quot; %}
 5417   ins_encode %{
 5418     __ ldsb($mem$$Address, $dst$$Register, 1);
 5419   %}
 5420   ins_pipe(iload_mask_mem);
 5421 %}
 5422 
 5423 // Load Short (16bit signed) into a Long Register
 5424 instruct loadS2L(iRegL dst, memory mem) %{
 5425   match(Set dst (ConvI2L (LoadS mem)));
 5426   ins_cost(MEMORY_REF_COST);
 5427 
 5428   size(4);
 5429   format %{ &quot;LDSH   $mem,$dst\t! short -&gt; long&quot; %}
 5430   ins_encode %{
 5431     __ ldsh($mem$$Address, $dst$$Register);
 5432   %}
 5433   ins_pipe(iload_mask_mem);
 5434 %}
 5435 
 5436 // Load Unsigned Short/Char (16bit UNsigned)
 5437 instruct loadUS(iRegI dst, memory mem) %{
 5438   match(Set dst (LoadUS mem));
 5439   ins_cost(MEMORY_REF_COST);
 5440 
 5441   size(4);
 5442   format %{ &quot;LDUH   $mem,$dst\t! ushort/char&quot; %}
 5443   ins_encode %{
 5444     __ lduh($mem$$Address, $dst$$Register);
 5445   %}
 5446   ins_pipe(iload_mem);
 5447 %}
 5448 
 5449 // Load Unsigned Short/Char (16 bit UNsigned) to Byte (8 bit signed)
 5450 instruct loadUS2B(iRegI dst, indOffset13m7 mem, immI_24 twentyfour) %{
 5451   match(Set dst (RShiftI (LShiftI (LoadUS mem) twentyfour) twentyfour));
 5452   ins_cost(MEMORY_REF_COST);
 5453 
 5454   size(4);
 5455   format %{ &quot;LDSB   $mem+1,$dst\t! ushort -&gt; byte&quot; %}
 5456   ins_encode %{
 5457     __ ldsb($mem$$Address, $dst$$Register, 1);
 5458   %}
 5459   ins_pipe(iload_mask_mem);
 5460 %}
 5461 
 5462 // Load Unsigned Short/Char (16bit UNsigned) into a Long Register
 5463 instruct loadUS2L(iRegL dst, memory mem) %{
 5464   match(Set dst (ConvI2L (LoadUS mem)));
 5465   ins_cost(MEMORY_REF_COST);
 5466 
 5467   size(4);
 5468   format %{ &quot;LDUH   $mem,$dst\t! ushort/char -&gt; long&quot; %}
 5469   ins_encode %{
 5470     __ lduh($mem$$Address, $dst$$Register);
 5471   %}
 5472   ins_pipe(iload_mem);
 5473 %}
 5474 
 5475 // Load Unsigned Short/Char (16bit UNsigned) with mask 0xFF into a Long Register
 5476 instruct loadUS2L_immI_255(iRegL dst, indOffset13m7 mem, immI_255 mask) %{
 5477   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 5478   ins_cost(MEMORY_REF_COST);
 5479 
 5480   size(4);
 5481   format %{ &quot;LDUB   $mem+1,$dst\t! ushort/char &amp; 0xFF -&gt; long&quot; %}
 5482   ins_encode %{
 5483     __ ldub($mem$$Address, $dst$$Register, 1);  // LSB is index+1 on BE
 5484   %}
 5485   ins_pipe(iload_mem);
 5486 %}
 5487 
 5488 // Load Unsigned Short/Char (16bit UNsigned) with a 13-bit mask into a Long Register
 5489 instruct loadUS2L_immI13(iRegL dst, memory mem, immI13 mask) %{
 5490   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 5491   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5492 
 5493   size(2*4);
 5494   format %{ &quot;LDUH   $mem,$dst\t! ushort/char &amp; 13-bit mask -&gt; long\n\t&quot;
 5495             &quot;AND    $dst,$mask,$dst&quot; %}
 5496   ins_encode %{
 5497     Register Rdst = $dst$$Register;
 5498     __ lduh($mem$$Address, Rdst);
 5499     __ and3(Rdst, $mask$$constant, Rdst);
 5500   %}
 5501   ins_pipe(iload_mem);
 5502 %}
 5503 
 5504 // Load Unsigned Short/Char (16bit UNsigned) with a 32-bit mask into a Long Register
 5505 instruct loadUS2L_immI(iRegL dst, memory mem, immI mask, iRegL tmp) %{
 5506   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 5507   effect(TEMP dst, TEMP tmp);
 5508   ins_cost(MEMORY_REF_COST + 2*DEFAULT_COST);
 5509 
 5510   format %{ &quot;LDUH   $mem,$dst\t! ushort/char &amp; 32-bit mask -&gt; long\n\t&quot;
 5511             &quot;SET    right_n_bits($mask, 16),$tmp\n\t&quot;
 5512             &quot;AND    $dst,$tmp,$dst&quot; %}
 5513   ins_encode %{
 5514     Register Rdst = $dst$$Register;
 5515     Register Rtmp = $tmp$$Register;
 5516     __ lduh($mem$$Address, Rdst);
 5517     __ set($mask$$constant &amp; right_n_bits(16), Rtmp);
 5518     __ and3(Rdst, Rtmp, Rdst);
 5519   %}
 5520   ins_pipe(iload_mem);
 5521 %}
 5522 
 5523 // Load Integer
 5524 instruct loadI(iRegI dst, memory mem) %{
 5525   match(Set dst (LoadI mem));
 5526   ins_cost(MEMORY_REF_COST);
 5527 
 5528   size(4);
 5529   format %{ &quot;LDUW   $mem,$dst\t! int&quot; %}
 5530   ins_encode %{
 5531     __ lduw($mem$$Address, $dst$$Register);
 5532   %}
 5533   ins_pipe(iload_mem);
 5534 %}
 5535 
 5536 // Load Integer to Byte (8 bit signed)
 5537 instruct loadI2B(iRegI dst, indOffset13m7 mem, immI_24 twentyfour) %{
 5538   match(Set dst (RShiftI (LShiftI (LoadI mem) twentyfour) twentyfour));
 5539   ins_cost(MEMORY_REF_COST);
 5540 
 5541   size(4);
 5542 
 5543   format %{ &quot;LDSB   $mem+3,$dst\t! int -&gt; byte&quot; %}
 5544   ins_encode %{
 5545     __ ldsb($mem$$Address, $dst$$Register, 3);
 5546   %}
 5547   ins_pipe(iload_mask_mem);
 5548 %}
 5549 
 5550 // Load Integer to Unsigned Byte (8 bit UNsigned)
 5551 instruct loadI2UB(iRegI dst, indOffset13m7 mem, immI_255 mask) %{
 5552   match(Set dst (AndI (LoadI mem) mask));
 5553   ins_cost(MEMORY_REF_COST);
 5554 
 5555   size(4);
 5556 
 5557   format %{ &quot;LDUB   $mem+3,$dst\t! int -&gt; ubyte&quot; %}
 5558   ins_encode %{
 5559     __ ldub($mem$$Address, $dst$$Register, 3);
 5560   %}
 5561   ins_pipe(iload_mask_mem);
 5562 %}
 5563 
 5564 // Load Integer to Short (16 bit signed)
 5565 instruct loadI2S(iRegI dst, indOffset13m7 mem, immI_16 sixteen) %{
 5566   match(Set dst (RShiftI (LShiftI (LoadI mem) sixteen) sixteen));
 5567   ins_cost(MEMORY_REF_COST);
 5568 
 5569   size(4);
 5570 
 5571   format %{ &quot;LDSH   $mem+2,$dst\t! int -&gt; short&quot; %}
 5572   ins_encode %{
 5573     __ ldsh($mem$$Address, $dst$$Register, 2);
 5574   %}
 5575   ins_pipe(iload_mask_mem);
 5576 %}
 5577 
 5578 // Load Integer to Unsigned Short (16 bit UNsigned)
 5579 instruct loadI2US(iRegI dst, indOffset13m7 mem, immI_65535 mask) %{
 5580   match(Set dst (AndI (LoadI mem) mask));
 5581   ins_cost(MEMORY_REF_COST);
 5582 
 5583   size(4);
 5584 
 5585   format %{ &quot;LDUH   $mem+2,$dst\t! int -&gt; ushort/char&quot; %}
 5586   ins_encode %{
 5587     __ lduh($mem$$Address, $dst$$Register, 2);
 5588   %}
 5589   ins_pipe(iload_mask_mem);
 5590 %}
 5591 
 5592 // Load Integer into a Long Register
 5593 instruct loadI2L(iRegL dst, memory mem) %{
 5594   match(Set dst (ConvI2L (LoadI mem)));
 5595   ins_cost(MEMORY_REF_COST);
 5596 
 5597   size(4);
 5598   format %{ &quot;LDSW   $mem,$dst\t! int -&gt; long&quot; %}
 5599   ins_encode %{
 5600     __ ldsw($mem$$Address, $dst$$Register);
 5601   %}
 5602   ins_pipe(iload_mask_mem);
 5603 %}
 5604 
 5605 // Load Integer with mask 0xFF into a Long Register
 5606 instruct loadI2L_immI_255(iRegL dst, indOffset13m7 mem, immI_255 mask) %{
 5607   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5608   ins_cost(MEMORY_REF_COST);
 5609 
 5610   size(4);
 5611   format %{ &quot;LDUB   $mem+3,$dst\t! int &amp; 0xFF -&gt; long&quot; %}
 5612   ins_encode %{
 5613     __ ldub($mem$$Address, $dst$$Register, 3);  // LSB is index+3 on BE
 5614   %}
 5615   ins_pipe(iload_mem);
 5616 %}
 5617 
 5618 // Load Integer with mask 0xFFFF into a Long Register
 5619 instruct loadI2L_immI_65535(iRegL dst, indOffset13m7 mem, immI_65535 mask) %{
 5620   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5621   ins_cost(MEMORY_REF_COST);
 5622 
 5623   size(4);
 5624   format %{ &quot;LDUH   $mem+2,$dst\t! int &amp; 0xFFFF -&gt; long&quot; %}
 5625   ins_encode %{
 5626     __ lduh($mem$$Address, $dst$$Register, 2);  // LSW is index+2 on BE
 5627   %}
 5628   ins_pipe(iload_mem);
 5629 %}
 5630 
 5631 // Load Integer with a 12-bit mask into a Long Register
 5632 instruct loadI2L_immU12(iRegL dst, memory mem, immU12 mask) %{
 5633   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5634   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5635 
 5636   size(2*4);
 5637   format %{ &quot;LDUW   $mem,$dst\t! int &amp; 12-bit mask -&gt; long\n\t&quot;
 5638             &quot;AND    $dst,$mask,$dst&quot; %}
 5639   ins_encode %{
 5640     Register Rdst = $dst$$Register;
 5641     __ lduw($mem$$Address, Rdst);
 5642     __ and3(Rdst, $mask$$constant, Rdst);
 5643   %}
 5644   ins_pipe(iload_mem);
 5645 %}
 5646 
 5647 // Load Integer with a 31-bit mask into a Long Register
 5648 instruct loadI2L_immU31(iRegL dst, memory mem, immU31 mask, iRegL tmp) %{
 5649   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5650   effect(TEMP dst, TEMP tmp);
 5651   ins_cost(MEMORY_REF_COST + 2*DEFAULT_COST);
 5652 
 5653   format %{ &quot;LDUW   $mem,$dst\t! int &amp; 31-bit mask -&gt; long\n\t&quot;
 5654             &quot;SET    $mask,$tmp\n\t&quot;
 5655             &quot;AND    $dst,$tmp,$dst&quot; %}
 5656   ins_encode %{
 5657     Register Rdst = $dst$$Register;
 5658     Register Rtmp = $tmp$$Register;
 5659     __ lduw($mem$$Address, Rdst);
 5660     __ set($mask$$constant, Rtmp);
 5661     __ and3(Rdst, Rtmp, Rdst);
 5662   %}
 5663   ins_pipe(iload_mem);
 5664 %}
 5665 
 5666 // Load Unsigned Integer into a Long Register
 5667 instruct loadUI2L(iRegL dst, memory mem, immL_32bits mask) %{
 5668   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 5669   ins_cost(MEMORY_REF_COST);
 5670 
 5671   size(4);
 5672   format %{ &quot;LDUW   $mem,$dst\t! uint -&gt; long&quot; %}
 5673   ins_encode %{
 5674     __ lduw($mem$$Address, $dst$$Register);
 5675   %}
 5676   ins_pipe(iload_mem);
 5677 %}
 5678 
 5679 // Load Long - aligned
 5680 instruct loadL(iRegL dst, memory mem ) %{
 5681   match(Set dst (LoadL mem));
 5682   ins_cost(MEMORY_REF_COST);
 5683 
 5684   size(4);
 5685   format %{ &quot;LDX    $mem,$dst\t! long&quot; %}
 5686   ins_encode %{
 5687     __ ldx($mem$$Address, $dst$$Register);
 5688   %}
 5689   ins_pipe(iload_mem);
 5690 %}
 5691 
 5692 // Load Long - UNaligned
 5693 instruct loadL_unaligned(iRegL dst, memory mem, o7RegI tmp) %{
 5694   match(Set dst (LoadL_unaligned mem));
 5695   effect(KILL tmp);
 5696   ins_cost(MEMORY_REF_COST*2+DEFAULT_COST);
 5697   format %{ &quot;LDUW   $mem+4,R_O7\t! misaligned long\n&quot;
 5698           &quot;\tLDUW   $mem  ,$dst\n&quot;
 5699           &quot;\tSLLX   #32, $dst, $dst\n&quot;
 5700           &quot;\tOR     $dst, R_O7, $dst&quot; %}
 5701   opcode(Assembler::lduw_op3);
 5702   ins_encode(form3_mem_reg_long_unaligned_marshal( mem, dst ));
 5703   ins_pipe(iload_mem);
 5704 %}
 5705 
 5706 // Load Range
 5707 instruct loadRange(iRegI dst, memory mem) %{
 5708   match(Set dst (LoadRange mem));
 5709   ins_cost(MEMORY_REF_COST);
 5710 
 5711   format %{ &quot;LDUW   $mem,$dst\t! range&quot; %}
 5712   opcode(Assembler::lduw_op3);
 5713   ins_encode(simple_form3_mem_reg( mem, dst ) );
 5714   ins_pipe(iload_mem);
 5715 %}
 5716 
 5717 // Load Integer into %f register (for fitos/fitod)
 5718 instruct loadI_freg(regF dst, memory mem) %{
 5719   match(Set dst (LoadI mem));
 5720   ins_cost(MEMORY_REF_COST);
 5721 
 5722   format %{ &quot;LDF    $mem,$dst\t! for fitos/fitod&quot; %}
 5723   opcode(Assembler::ldf_op3);
 5724   ins_encode(simple_form3_mem_reg( mem, dst ) );
 5725   ins_pipe(floadF_mem);
 5726 %}
 5727 
 5728 // Load Pointer
 5729 instruct loadP(iRegP dst, memory mem) %{
 5730   match(Set dst (LoadP mem));
 5731   ins_cost(MEMORY_REF_COST);
 5732   size(4);
 5733 
 5734   format %{ &quot;LDX    $mem,$dst\t! ptr&quot; %}
 5735   ins_encode %{
 5736     __ ldx($mem$$Address, $dst$$Register);
 5737   %}
 5738   ins_pipe(iload_mem);
 5739 %}
 5740 
 5741 // Load Compressed Pointer
 5742 instruct loadN(iRegN dst, memory mem) %{
 5743   match(Set dst (LoadN mem));
 5744   ins_cost(MEMORY_REF_COST);
 5745   size(4);
 5746 
 5747   format %{ &quot;LDUW   $mem,$dst\t! compressed ptr&quot; %}
 5748   ins_encode %{
 5749     __ lduw($mem$$Address, $dst$$Register);
 5750   %}
 5751   ins_pipe(iload_mem);
 5752 %}
 5753 
 5754 // Load Klass Pointer
 5755 instruct loadKlass(iRegP dst, memory mem) %{
 5756   match(Set dst (LoadKlass mem));
 5757   ins_cost(MEMORY_REF_COST);
 5758   size(4);
 5759 
 5760   format %{ &quot;LDX    $mem,$dst\t! klass ptr&quot; %}
 5761   ins_encode %{
 5762     __ ldx($mem$$Address, $dst$$Register);
 5763   %}
 5764   ins_pipe(iload_mem);
 5765 %}
 5766 
 5767 // Load narrow Klass Pointer
 5768 instruct loadNKlass(iRegN dst, memory mem) %{
 5769   match(Set dst (LoadNKlass mem));
 5770   ins_cost(MEMORY_REF_COST);
 5771   size(4);
 5772 
 5773   format %{ &quot;LDUW   $mem,$dst\t! compressed klass ptr&quot; %}
 5774   ins_encode %{
 5775     __ lduw($mem$$Address, $dst$$Register);
 5776   %}
 5777   ins_pipe(iload_mem);
 5778 %}
 5779 
 5780 // Load Double
 5781 instruct loadD(regD dst, memory mem) %{
 5782   match(Set dst (LoadD mem));
 5783   ins_cost(MEMORY_REF_COST);
 5784 
 5785   format %{ &quot;LDDF   $mem,$dst&quot; %}
 5786   opcode(Assembler::lddf_op3);
 5787   ins_encode(simple_form3_mem_reg( mem, dst ) );
 5788   ins_pipe(floadD_mem);
 5789 %}
 5790 
 5791 // Load Double - UNaligned
 5792 instruct loadD_unaligned(regD_low dst, memory mem ) %{
 5793   match(Set dst (LoadD_unaligned mem));
 5794   ins_cost(MEMORY_REF_COST*2+DEFAULT_COST);
 5795   format %{ &quot;LDF    $mem  ,$dst.hi\t! misaligned double\n&quot;
 5796           &quot;\tLDF    $mem+4,$dst.lo\t!&quot; %}
 5797   opcode(Assembler::ldf_op3);
 5798   ins_encode( form3_mem_reg_double_unaligned( mem, dst ));
 5799   ins_pipe(iload_mem);
 5800 %}
 5801 
 5802 // Load Float
 5803 instruct loadF(regF dst, memory mem) %{
 5804   match(Set dst (LoadF mem));
 5805   ins_cost(MEMORY_REF_COST);
 5806 
 5807   format %{ &quot;LDF    $mem,$dst&quot; %}
 5808   opcode(Assembler::ldf_op3);
 5809   ins_encode(simple_form3_mem_reg( mem, dst ) );
 5810   ins_pipe(floadF_mem);
 5811 %}
 5812 
 5813 // Load Constant
 5814 instruct loadConI( iRegI dst, immI src ) %{
 5815   match(Set dst src);
 5816   ins_cost(DEFAULT_COST * 3/2);
 5817   format %{ &quot;SET    $src,$dst&quot; %}
 5818   ins_encode( Set32(src, dst) );
 5819   ins_pipe(ialu_hi_lo_reg);
 5820 %}
 5821 
 5822 instruct loadConI13( iRegI dst, immI13 src ) %{
 5823   match(Set dst src);
 5824 
 5825   size(4);
 5826   format %{ &quot;MOV    $src,$dst&quot; %}
 5827   ins_encode( Set13( src, dst ) );
 5828   ins_pipe(ialu_imm);
 5829 %}
 5830 
 5831 instruct loadConP_set(iRegP dst, immP_set con) %{
 5832   match(Set dst con);
 5833   ins_cost(DEFAULT_COST * 3/2);
 5834   format %{ &quot;SET    $con,$dst\t! ptr&quot; %}
 5835   ins_encode %{
 5836     relocInfo::relocType constant_reloc = _opnds[1]-&gt;constant_reloc();
 5837       intptr_t val = $con$$constant;
 5838     if (constant_reloc == relocInfo::oop_type) {
 5839       __ set_oop_constant((jobject) val, $dst$$Register);
 5840     } else if (constant_reloc == relocInfo::metadata_type) {
 5841       __ set_metadata_constant((Metadata*)val, $dst$$Register);
 5842     } else {          // non-oop pointers, e.g. card mark base, heap top
 5843       assert(constant_reloc == relocInfo::none, &quot;unexpected reloc type&quot;);
 5844       __ set(val, $dst$$Register);
 5845     }
 5846   %}
 5847   ins_pipe(loadConP);
 5848 %}
 5849 
 5850 instruct loadConP_load(iRegP dst, immP_load con) %{
 5851   match(Set dst con);
 5852   ins_cost(MEMORY_REF_COST);
 5853   format %{ &quot;LD     [$constanttablebase + $constantoffset],$dst\t! load from constant table: ptr=$con&quot; %}
 5854   ins_encode %{
 5855     RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset($con), $dst$$Register);
 5856     __ ld_ptr($constanttablebase, con_offset, $dst$$Register);
 5857   %}
 5858   ins_pipe(loadConP);
 5859 %}
 5860 
 5861 instruct loadConP_no_oop_cheap(iRegP dst, immP_no_oop_cheap con) %{
 5862   match(Set dst con);
 5863   ins_cost(DEFAULT_COST * 3/2);
 5864   format %{ &quot;SET    $con,$dst\t! non-oop ptr&quot; %}
 5865   ins_encode %{
 5866     if (_opnds[1]-&gt;constant_reloc() == relocInfo::metadata_type) {
 5867       __ set_metadata_constant((Metadata*)$con$$constant, $dst$$Register);
 5868     } else {
 5869       __ set($con$$constant, $dst$$Register);
 5870     }
 5871   %}
 5872   ins_pipe(loadConP);
 5873 %}
 5874 
 5875 instruct loadConP0(iRegP dst, immP0 src) %{
 5876   match(Set dst src);
 5877 
 5878   size(4);
 5879   format %{ &quot;CLR    $dst\t!ptr&quot; %}
 5880   ins_encode %{
 5881     __ clr($dst$$Register);
 5882   %}
 5883   ins_pipe(ialu_imm);
 5884 %}
 5885 
 5886 instruct loadConP_poll(iRegP dst, immP_poll src) %{
 5887   match(Set dst src);
 5888   ins_cost(DEFAULT_COST);
 5889   format %{ &quot;SET    $src,$dst\t!ptr&quot; %}
 5890   ins_encode %{
 5891     AddressLiteral polling_page(os::get_polling_page());
 5892     __ sethi(polling_page, reg_to_register_object($dst$$reg));
 5893   %}
 5894   ins_pipe(loadConP_poll);
 5895 %}
 5896 
 5897 instruct loadConN0(iRegN dst, immN0 src) %{
 5898   match(Set dst src);
 5899 
 5900   size(4);
 5901   format %{ &quot;CLR    $dst\t! compressed NULL ptr&quot; %}
 5902   ins_encode %{
 5903     __ clr($dst$$Register);
 5904   %}
 5905   ins_pipe(ialu_imm);
 5906 %}
 5907 
 5908 instruct loadConN(iRegN dst, immN src) %{
 5909   match(Set dst src);
 5910   ins_cost(DEFAULT_COST * 3/2);
 5911   format %{ &quot;SET    $src,$dst\t! compressed ptr&quot; %}
 5912   ins_encode %{
 5913     Register dst = $dst$$Register;
 5914     __ set_narrow_oop((jobject)$src$$constant, dst);
 5915   %}
 5916   ins_pipe(ialu_hi_lo_reg);
 5917 %}
 5918 
 5919 instruct loadConNKlass(iRegN dst, immNKlass src) %{
 5920   match(Set dst src);
 5921   ins_cost(DEFAULT_COST * 3/2);
 5922   format %{ &quot;SET    $src,$dst\t! compressed klass ptr&quot; %}
 5923   ins_encode %{
 5924     Register dst = $dst$$Register;
 5925     __ set_narrow_klass((Klass*)$src$$constant, dst);
 5926   %}
 5927   ins_pipe(ialu_hi_lo_reg);
 5928 %}
 5929 
 5930 // Materialize long value (predicated by immL_cheap).
 5931 instruct loadConL_set64(iRegL dst, immL_cheap con, o7RegL tmp) %{
 5932   match(Set dst con);
 5933   effect(KILL tmp);
 5934   ins_cost(DEFAULT_COST * 3);
 5935   format %{ &quot;SET64   $con,$dst KILL $tmp\t! cheap long&quot; %}
 5936   ins_encode %{
 5937     __ set64($con$$constant, $dst$$Register, $tmp$$Register);
 5938   %}
 5939   ins_pipe(loadConL);
 5940 %}
 5941 
 5942 // Load long value from constant table (predicated by immL_expensive).
 5943 instruct loadConL_ldx(iRegL dst, immL_expensive con) %{
 5944   match(Set dst con);
 5945   ins_cost(MEMORY_REF_COST);
 5946   format %{ &quot;LDX     [$constanttablebase + $constantoffset],$dst\t! load from constant table: long=$con&quot; %}
 5947   ins_encode %{
 5948       RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset($con), $dst$$Register);
 5949     __ ldx($constanttablebase, con_offset, $dst$$Register);
 5950   %}
 5951   ins_pipe(loadConL);
 5952 %}
 5953 
 5954 instruct loadConL0( iRegL dst, immL0 src ) %{
 5955   match(Set dst src);
 5956   ins_cost(DEFAULT_COST);
 5957   size(4);
 5958   format %{ &quot;CLR    $dst\t! long&quot; %}
 5959   ins_encode( Set13( src, dst ) );
 5960   ins_pipe(ialu_imm);
 5961 %}
 5962 
 5963 instruct loadConL13( iRegL dst, immL13 src ) %{
 5964   match(Set dst src);
 5965   ins_cost(DEFAULT_COST * 2);
 5966 
 5967   size(4);
 5968   format %{ &quot;MOV    $src,$dst\t! long&quot; %}
 5969   ins_encode( Set13( src, dst ) );
 5970   ins_pipe(ialu_imm);
 5971 %}
 5972 
 5973 instruct loadConF(regF dst, immF con, o7RegI tmp) %{
 5974   match(Set dst con);
 5975   effect(KILL tmp);
 5976   format %{ &quot;LDF    [$constanttablebase + $constantoffset],$dst\t! load from constant table: float=$con&quot; %}
 5977   ins_encode %{
 5978       RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset($con), $tmp$$Register);
 5979     __ ldf(FloatRegisterImpl::S, $constanttablebase, con_offset, $dst$$FloatRegister);
 5980   %}
 5981   ins_pipe(loadConFD);
 5982 %}
 5983 
 5984 instruct loadConD(regD dst, immD con, o7RegI tmp) %{
 5985   match(Set dst con);
 5986   effect(KILL tmp);
 5987   format %{ &quot;LDDF   [$constanttablebase + $constantoffset],$dst\t! load from constant table: double=$con&quot; %}
 5988   ins_encode %{
 5989     // XXX This is a quick fix for 6833573.
 5990     //__ ldf(FloatRegisterImpl::D, $constanttablebase, $constantoffset($con), $dst$$FloatRegister);
 5991     RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset($con), $tmp$$Register);
 5992     __ ldf(FloatRegisterImpl::D, $constanttablebase, con_offset, as_DoubleFloatRegister($dst$$reg));
 5993   %}
 5994   ins_pipe(loadConFD);
 5995 %}
 5996 
 5997 // Prefetch instructions for allocation.
 5998 // Must be safe to execute with invalid address (cannot fault).
 5999 
 6000 instruct prefetchAlloc( memory mem ) %{
 6001   predicate(AllocatePrefetchInstr == 0);
 6002   match( PrefetchAllocation mem );
 6003   ins_cost(MEMORY_REF_COST);
 6004 
 6005   format %{ &quot;PREFETCH $mem,2\t! Prefetch allocation&quot; %}
 6006   opcode(Assembler::prefetch_op3);
 6007   ins_encode( form3_mem_prefetch_write( mem ) );
 6008   ins_pipe(iload_mem);
 6009 %}
 6010 
 6011 // Use BIS instruction to prefetch for allocation.
 6012 // Could fault, need space at the end of TLAB.
 6013 instruct prefetchAlloc_bis( iRegP dst ) %{
 6014   predicate(AllocatePrefetchInstr == 1);
 6015   match( PrefetchAllocation dst );
 6016   ins_cost(MEMORY_REF_COST);
 6017   size(4);
 6018 
 6019   format %{ &quot;STXA   [$dst]\t! // Prefetch allocation using BIS&quot; %}
 6020   ins_encode %{
 6021     __ stxa(G0, $dst$$Register, G0, Assembler::ASI_ST_BLKINIT_PRIMARY);
 6022   %}
 6023   ins_pipe(istore_mem_reg);
 6024 %}
 6025 
 6026 // Next code is used for finding next cache line address to prefetch.
 6027 instruct cacheLineAdr( iRegP dst, iRegP src, immL13 mask ) %{
 6028   match(Set dst (CastX2P (AndL (CastP2X src) mask)));
 6029   ins_cost(DEFAULT_COST);
 6030   size(4);
 6031 
 6032   format %{ &quot;AND    $src,$mask,$dst\t! next cache line address&quot; %}
 6033   ins_encode %{
 6034     __ and3($src$$Register, $mask$$constant, $dst$$Register);
 6035   %}
 6036   ins_pipe(ialu_reg_imm);
 6037 %}
 6038 
 6039 //----------Store Instructions-------------------------------------------------
 6040 // Store Byte
 6041 instruct storeB(memory mem, iRegI src) %{
 6042   match(Set mem (StoreB mem src));
 6043   ins_cost(MEMORY_REF_COST);
 6044 
 6045   format %{ &quot;STB    $src,$mem\t! byte&quot; %}
 6046   opcode(Assembler::stb_op3);
 6047   ins_encode(simple_form3_mem_reg( mem, src ) );
 6048   ins_pipe(istore_mem_reg);
 6049 %}
 6050 
 6051 instruct storeB0(memory mem, immI0 src) %{
 6052   match(Set mem (StoreB mem src));
 6053   ins_cost(MEMORY_REF_COST);
 6054 
 6055   format %{ &quot;STB    $src,$mem\t! byte&quot; %}
 6056   opcode(Assembler::stb_op3);
 6057   ins_encode(simple_form3_mem_reg( mem, R_G0 ) );
 6058   ins_pipe(istore_mem_zero);
 6059 %}
 6060 
 6061 instruct storeCM0(memory mem, immI0 src) %{
 6062   match(Set mem (StoreCM mem src));
 6063   ins_cost(MEMORY_REF_COST);
 6064 
 6065   format %{ &quot;STB    $src,$mem\t! CMS card-mark byte 0&quot; %}
 6066   opcode(Assembler::stb_op3);
 6067   ins_encode(simple_form3_mem_reg( mem, R_G0 ) );
 6068   ins_pipe(istore_mem_zero);
 6069 %}
 6070 
 6071 // Store Char/Short
 6072 instruct storeC(memory mem, iRegI src) %{
 6073   match(Set mem (StoreC mem src));
 6074   ins_cost(MEMORY_REF_COST);
 6075 
 6076   format %{ &quot;STH    $src,$mem\t! short&quot; %}
 6077   opcode(Assembler::sth_op3);
 6078   ins_encode(simple_form3_mem_reg( mem, src ) );
 6079   ins_pipe(istore_mem_reg);
 6080 %}
 6081 
 6082 instruct storeC0(memory mem, immI0 src) %{
 6083   match(Set mem (StoreC mem src));
 6084   ins_cost(MEMORY_REF_COST);
 6085 
 6086   format %{ &quot;STH    $src,$mem\t! short&quot; %}
 6087   opcode(Assembler::sth_op3);
 6088   ins_encode(simple_form3_mem_reg( mem, R_G0 ) );
 6089   ins_pipe(istore_mem_zero);
 6090 %}
 6091 
 6092 // Store Integer
 6093 instruct storeI(memory mem, iRegI src) %{
 6094   match(Set mem (StoreI mem src));
 6095   ins_cost(MEMORY_REF_COST);
 6096 
 6097   format %{ &quot;STW    $src,$mem&quot; %}
 6098   opcode(Assembler::stw_op3);
 6099   ins_encode(simple_form3_mem_reg( mem, src ) );
 6100   ins_pipe(istore_mem_reg);
 6101 %}
 6102 
 6103 // Store Long
 6104 instruct storeL(memory mem, iRegL src) %{
 6105   match(Set mem (StoreL mem src));
 6106   ins_cost(MEMORY_REF_COST);
 6107   format %{ &quot;STX    $src,$mem\t! long&quot; %}
 6108   opcode(Assembler::stx_op3);
 6109   ins_encode(simple_form3_mem_reg( mem, src ) );
 6110   ins_pipe(istore_mem_reg);
 6111 %}
 6112 
 6113 instruct storeI0(memory mem, immI0 src) %{
 6114   match(Set mem (StoreI mem src));
 6115   ins_cost(MEMORY_REF_COST);
 6116 
 6117   format %{ &quot;STW    $src,$mem&quot; %}
 6118   opcode(Assembler::stw_op3);
 6119   ins_encode(simple_form3_mem_reg( mem, R_G0 ) );
 6120   ins_pipe(istore_mem_zero);
 6121 %}
 6122 
 6123 instruct storeL0(memory mem, immL0 src) %{
 6124   match(Set mem (StoreL mem src));
 6125   ins_cost(MEMORY_REF_COST);
 6126 
 6127   format %{ &quot;STX    $src,$mem&quot; %}
 6128   opcode(Assembler::stx_op3);
 6129   ins_encode(simple_form3_mem_reg( mem, R_G0 ) );
 6130   ins_pipe(istore_mem_zero);
 6131 %}
 6132 
 6133 // Store Integer from float register (used after fstoi)
 6134 instruct storeI_Freg(memory mem, regF src) %{
 6135   match(Set mem (StoreI mem src));
 6136   ins_cost(MEMORY_REF_COST);
 6137 
 6138   format %{ &quot;STF    $src,$mem\t! after fstoi/fdtoi&quot; %}
 6139   opcode(Assembler::stf_op3);
 6140   ins_encode(simple_form3_mem_reg( mem, src ) );
 6141   ins_pipe(fstoreF_mem_reg);
 6142 %}
 6143 
 6144 // Store Pointer
 6145 instruct storeP(memory dst, sp_ptr_RegP src) %{
 6146   match(Set dst (StoreP dst src));
 6147   ins_cost(MEMORY_REF_COST);
 6148 
 6149   format %{ &quot;STX    $src,$dst\t! ptr&quot; %}
 6150   opcode(Assembler::stx_op3, 0, REGP_OP);
 6151   ins_encode( form3_mem_reg( dst, src ) );
 6152   ins_pipe(istore_mem_spORreg);
 6153 %}
 6154 
 6155 instruct storeP0(memory dst, immP0 src) %{
 6156   match(Set dst (StoreP dst src));
 6157   ins_cost(MEMORY_REF_COST);
 6158 
 6159   format %{ &quot;STX    $src,$dst\t! ptr&quot; %}
 6160   opcode(Assembler::stx_op3, 0, REGP_OP);
 6161   ins_encode( form3_mem_reg( dst, R_G0 ) );
 6162   ins_pipe(istore_mem_zero);
 6163 %}
 6164 
 6165 // Store Compressed Pointer
 6166 instruct storeN(memory dst, iRegN src) %{
 6167    match(Set dst (StoreN dst src));
 6168    ins_cost(MEMORY_REF_COST);
 6169    size(4);
 6170 
 6171    format %{ &quot;STW    $src,$dst\t! compressed ptr&quot; %}
 6172    ins_encode %{
 6173      Register base = as_Register($dst$$base);
 6174      Register index = as_Register($dst$$index);
 6175      Register src = $src$$Register;
 6176      if (index != G0) {
 6177        __ stw(src, base, index);
 6178      } else {
 6179        __ stw(src, base, $dst$$disp);
 6180      }
 6181    %}
 6182    ins_pipe(istore_mem_spORreg);
 6183 %}
 6184 
 6185 instruct storeNKlass(memory dst, iRegN src) %{
 6186    match(Set dst (StoreNKlass dst src));
 6187    ins_cost(MEMORY_REF_COST);
 6188    size(4);
 6189 
 6190    format %{ &quot;STW    $src,$dst\t! compressed klass ptr&quot; %}
 6191    ins_encode %{
 6192      Register base = as_Register($dst$$base);
 6193      Register index = as_Register($dst$$index);
 6194      Register src = $src$$Register;
 6195      if (index != G0) {
 6196        __ stw(src, base, index);
 6197      } else {
 6198        __ stw(src, base, $dst$$disp);
 6199      }
 6200    %}
 6201    ins_pipe(istore_mem_spORreg);
 6202 %}
 6203 
 6204 instruct storeN0(memory dst, immN0 src) %{
 6205    match(Set dst (StoreN dst src));
 6206    ins_cost(MEMORY_REF_COST);
 6207    size(4);
 6208 
 6209    format %{ &quot;STW    $src,$dst\t! compressed ptr&quot; %}
 6210    ins_encode %{
 6211      Register base = as_Register($dst$$base);
 6212      Register index = as_Register($dst$$index);
 6213      if (index != G0) {
 6214        __ stw(0, base, index);
 6215      } else {
 6216        __ stw(0, base, $dst$$disp);
 6217      }
 6218    %}
 6219    ins_pipe(istore_mem_zero);
 6220 %}
 6221 
 6222 // Store Double
 6223 instruct storeD( memory mem, regD src) %{
 6224   match(Set mem (StoreD mem src));
 6225   ins_cost(MEMORY_REF_COST);
 6226 
 6227   format %{ &quot;STDF   $src,$mem&quot; %}
 6228   opcode(Assembler::stdf_op3);
 6229   ins_encode(simple_form3_mem_reg( mem, src ) );
 6230   ins_pipe(fstoreD_mem_reg);
 6231 %}
 6232 
 6233 instruct storeD0( memory mem, immD0 src) %{
 6234   match(Set mem (StoreD mem src));
 6235   ins_cost(MEMORY_REF_COST);
 6236 
 6237   format %{ &quot;STX    $src,$mem&quot; %}
 6238   opcode(Assembler::stx_op3);
 6239   ins_encode(simple_form3_mem_reg( mem, R_G0 ) );
 6240   ins_pipe(fstoreD_mem_zero);
 6241 %}
 6242 
 6243 // Store Float
 6244 instruct storeF( memory mem, regF src) %{
 6245   match(Set mem (StoreF mem src));
 6246   ins_cost(MEMORY_REF_COST);
 6247 
 6248   format %{ &quot;STF    $src,$mem&quot; %}
 6249   opcode(Assembler::stf_op3);
 6250   ins_encode(simple_form3_mem_reg( mem, src ) );
 6251   ins_pipe(fstoreF_mem_reg);
 6252 %}
 6253 
 6254 instruct storeF0( memory mem, immF0 src) %{
 6255   match(Set mem (StoreF mem src));
 6256   ins_cost(MEMORY_REF_COST);
 6257 
 6258   format %{ &quot;STW    $src,$mem\t! storeF0&quot; %}
 6259   opcode(Assembler::stw_op3);
 6260   ins_encode(simple_form3_mem_reg( mem, R_G0 ) );
 6261   ins_pipe(fstoreF_mem_zero);
 6262 %}
 6263 
 6264 // Convert oop pointer into compressed form
 6265 instruct encodeHeapOop(iRegN dst, iRegP src) %{
 6266   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull);
 6267   match(Set dst (EncodeP src));
 6268   format %{ &quot;encode_heap_oop $src, $dst&quot; %}
 6269   ins_encode %{
 6270     __ encode_heap_oop($src$$Register, $dst$$Register);
 6271   %}
 6272   ins_avoid_back_to_back(CompressedOops::base() == NULL ? AVOID_NONE : AVOID_BEFORE);
 6273   ins_pipe(ialu_reg);
 6274 %}
 6275 
 6276 instruct encodeHeapOop_not_null(iRegN dst, iRegP src) %{
 6277   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull);
 6278   match(Set dst (EncodeP src));
 6279   format %{ &quot;encode_heap_oop_not_null $src, $dst&quot; %}
 6280   ins_encode %{
 6281     __ encode_heap_oop_not_null($src$$Register, $dst$$Register);
 6282   %}
 6283   ins_pipe(ialu_reg);
 6284 %}
 6285 
 6286 instruct decodeHeapOop(iRegP dst, iRegN src) %{
 6287   predicate(n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 6288             n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::Constant);
 6289   match(Set dst (DecodeN src));
 6290   format %{ &quot;decode_heap_oop $src, $dst&quot; %}
 6291   ins_encode %{
 6292     __ decode_heap_oop($src$$Register, $dst$$Register);
 6293   %}
 6294   ins_pipe(ialu_reg);
 6295 %}
 6296 
 6297 instruct decodeHeapOop_not_null(iRegP dst, iRegN src) %{
 6298   predicate(n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::NotNull ||
 6299             n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant);
 6300   match(Set dst (DecodeN src));
 6301   format %{ &quot;decode_heap_oop_not_null $src, $dst&quot; %}
 6302   ins_encode %{
 6303     __ decode_heap_oop_not_null($src$$Register, $dst$$Register);
 6304   %}
 6305   ins_pipe(ialu_reg);
 6306 %}
 6307 
 6308 instruct encodeKlass_not_null(iRegN dst, iRegP src) %{
 6309   match(Set dst (EncodePKlass src));
 6310   format %{ &quot;encode_klass_not_null $src, $dst&quot; %}
 6311   ins_encode %{
 6312     __ encode_klass_not_null($src$$Register, $dst$$Register);
 6313   %}
 6314   ins_pipe(ialu_reg);
 6315 %}
 6316 
 6317 instruct decodeKlass_not_null(iRegP dst, iRegN src) %{
 6318   match(Set dst (DecodeNKlass src));
 6319   format %{ &quot;decode_klass_not_null $src, $dst&quot; %}
 6320   ins_encode %{
 6321     __ decode_klass_not_null($src$$Register, $dst$$Register);
 6322   %}
 6323   ins_pipe(ialu_reg);
 6324 %}
 6325 
 6326 //----------MemBar Instructions-----------------------------------------------
 6327 // Memory barrier flavors
 6328 
 6329 instruct membar_acquire() %{
 6330   match(MemBarAcquire);
 6331   match(LoadFence);
 6332   ins_cost(4*MEMORY_REF_COST);
 6333 
 6334   size(0);
 6335   format %{ &quot;MEMBAR-acquire&quot; %}
 6336   ins_encode( enc_membar_acquire );
 6337   ins_pipe(long_memory_op);
 6338 %}
 6339 
 6340 instruct membar_acquire_lock() %{
 6341   match(MemBarAcquireLock);
 6342   ins_cost(0);
 6343 
 6344   size(0);
 6345   format %{ &quot;!MEMBAR-acquire (CAS in prior FastLock so empty encoding)&quot; %}
 6346   ins_encode( );
 6347   ins_pipe(empty);
 6348 %}
 6349 
 6350 instruct membar_release() %{
 6351   match(MemBarRelease);
 6352   match(StoreFence);
 6353   ins_cost(4*MEMORY_REF_COST);
 6354 
 6355   size(0);
 6356   format %{ &quot;MEMBAR-release&quot; %}
 6357   ins_encode( enc_membar_release );
 6358   ins_pipe(long_memory_op);
 6359 %}
 6360 
 6361 instruct membar_release_lock() %{
 6362   match(MemBarReleaseLock);
 6363   ins_cost(0);
 6364 
 6365   size(0);
 6366   format %{ &quot;!MEMBAR-release (CAS in succeeding FastUnlock so empty encoding)&quot; %}
 6367   ins_encode( );
 6368   ins_pipe(empty);
 6369 %}
 6370 
 6371 instruct membar_volatile() %{
 6372   match(MemBarVolatile);
 6373   ins_cost(4*MEMORY_REF_COST);
 6374 
 6375   size(4);
 6376   format %{ &quot;MEMBAR-volatile&quot; %}
 6377   ins_encode( enc_membar_volatile );
 6378   ins_pipe(long_memory_op);
 6379 %}
 6380 
 6381 instruct unnecessary_membar_volatile() %{
 6382   match(MemBarVolatile);
 6383   predicate(Matcher::post_store_load_barrier(n));
 6384   ins_cost(0);
 6385 
 6386   size(0);
 6387   format %{ &quot;!MEMBAR-volatile (unnecessary so empty encoding)&quot; %}
 6388   ins_encode( );
 6389   ins_pipe(empty);
 6390 %}
 6391 
 6392 instruct membar_storestore() %{
 6393   match(MemBarStoreStore);
 6394   ins_cost(0);
 6395 
 6396   size(0);
 6397   format %{ &quot;!MEMBAR-storestore (empty encoding)&quot; %}
 6398   ins_encode( );
 6399   ins_pipe(empty);
 6400 %}
 6401 
 6402 //----------Register Move Instructions-----------------------------------------
 6403 instruct roundDouble_nop(regD dst) %{
 6404   match(Set dst (RoundDouble dst));
 6405   ins_cost(0);
 6406   // SPARC results are already &quot;rounded&quot; (i.e., normal-format IEEE)
 6407   ins_encode( );
 6408   ins_pipe(empty);
 6409 %}
 6410 
 6411 
 6412 instruct roundFloat_nop(regF dst) %{
 6413   match(Set dst (RoundFloat dst));
 6414   ins_cost(0);
 6415   // SPARC results are already &quot;rounded&quot; (i.e., normal-format IEEE)
 6416   ins_encode( );
 6417   ins_pipe(empty);
 6418 %}
 6419 
 6420 
 6421 // Cast Index to Pointer for unsafe natives
 6422 instruct castX2P(iRegX src, iRegP dst) %{
 6423   match(Set dst (CastX2P src));
 6424 
 6425   format %{ &quot;MOV    $src,$dst\t! IntX-&gt;Ptr&quot; %}
 6426   ins_encode( form3_g0_rs2_rd_move( src, dst ) );
 6427   ins_pipe(ialu_reg);
 6428 %}
 6429 
 6430 // Cast Pointer to Index for unsafe natives
 6431 instruct castP2X(iRegP src, iRegX dst) %{
 6432   match(Set dst (CastP2X src));
 6433 
 6434   format %{ &quot;MOV    $src,$dst\t! Ptr-&gt;IntX&quot; %}
 6435   ins_encode( form3_g0_rs2_rd_move( src, dst ) );
 6436   ins_pipe(ialu_reg);
 6437 %}
 6438 
 6439 instruct stfSSD(stackSlotD stkSlot, regD src) %{
 6440   // %%%% TO DO: Tell the coalescer that this kind of node is a copy!
 6441   match(Set stkSlot src);   // chain rule
 6442   ins_cost(MEMORY_REF_COST);
 6443   format %{ &quot;STDF   $src,$stkSlot\t!stk&quot; %}
 6444   opcode(Assembler::stdf_op3);
 6445   ins_encode(simple_form3_mem_reg(stkSlot, src));
 6446   ins_pipe(fstoreD_stk_reg);
 6447 %}
 6448 
 6449 instruct ldfSSD(regD dst, stackSlotD stkSlot) %{
 6450   // %%%% TO DO: Tell the coalescer that this kind of node is a copy!
 6451   match(Set dst stkSlot);   // chain rule
 6452   ins_cost(MEMORY_REF_COST);
 6453   format %{ &quot;LDDF   $stkSlot,$dst\t!stk&quot; %}
 6454   opcode(Assembler::lddf_op3);
 6455   ins_encode(simple_form3_mem_reg(stkSlot, dst));
 6456   ins_pipe(floadD_stk);
 6457 %}
 6458 
 6459 instruct stfSSF(stackSlotF stkSlot, regF src) %{
 6460   // %%%% TO DO: Tell the coalescer that this kind of node is a copy!
 6461   match(Set stkSlot src);   // chain rule
 6462   ins_cost(MEMORY_REF_COST);
 6463   format %{ &quot;STF   $src,$stkSlot\t!stk&quot; %}
 6464   opcode(Assembler::stf_op3);
 6465   ins_encode(simple_form3_mem_reg(stkSlot, src));
 6466   ins_pipe(fstoreF_stk_reg);
 6467 %}
 6468 
 6469 //----------Conditional Move---------------------------------------------------
 6470 // Conditional move
 6471 instruct cmovIP_reg(cmpOpP cmp, flagsRegP pcc, iRegI dst, iRegI src) %{
 6472   match(Set dst (CMoveI (Binary cmp pcc) (Binary dst src)));
 6473   ins_cost(150);
 6474   format %{ &quot;MOV$cmp $pcc,$src,$dst&quot; %}
 6475   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::ptr_cc)) );
 6476   ins_pipe(ialu_reg);
 6477 %}
 6478 
 6479 instruct cmovIP_imm(cmpOpP cmp, flagsRegP pcc, iRegI dst, immI11 src) %{
 6480   match(Set dst (CMoveI (Binary cmp pcc) (Binary dst src)));
 6481   ins_cost(140);
 6482   format %{ &quot;MOV$cmp $pcc,$src,$dst&quot; %}
 6483   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::ptr_cc)) );
 6484   ins_pipe(ialu_imm);
 6485 %}
 6486 
 6487 instruct cmovII_reg(cmpOp cmp, flagsReg icc, iRegI dst, iRegI src) %{
 6488   match(Set dst (CMoveI (Binary cmp icc) (Binary dst src)));
 6489   ins_cost(150);
 6490   size(4);
 6491   format %{ &quot;MOV$cmp  $icc,$src,$dst&quot; %}
 6492   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6493   ins_pipe(ialu_reg);
 6494 %}
 6495 
 6496 instruct cmovII_imm(cmpOp cmp, flagsReg icc, iRegI dst, immI11 src) %{
 6497   match(Set dst (CMoveI (Binary cmp icc) (Binary dst src)));
 6498   ins_cost(140);
 6499   size(4);
 6500   format %{ &quot;MOV$cmp  $icc,$src,$dst&quot; %}
 6501   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::icc)) );
 6502   ins_pipe(ialu_imm);
 6503 %}
 6504 
 6505 instruct cmovIIu_reg(cmpOpU cmp, flagsRegU icc, iRegI dst, iRegI src) %{
 6506   match(Set dst (CMoveI (Binary cmp icc) (Binary dst src)));
 6507   ins_cost(150);
 6508   size(4);
 6509   format %{ &quot;MOV$cmp  $icc,$src,$dst&quot; %}
 6510   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6511   ins_pipe(ialu_reg);
 6512 %}
 6513 
 6514 instruct cmovIIu_imm(cmpOpU cmp, flagsRegU icc, iRegI dst, immI11 src) %{
 6515   match(Set dst (CMoveI (Binary cmp icc) (Binary dst src)));
 6516   ins_cost(140);
 6517   size(4);
 6518   format %{ &quot;MOV$cmp  $icc,$src,$dst&quot; %}
 6519   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::icc)) );
 6520   ins_pipe(ialu_imm);
 6521 %}
 6522 
 6523 instruct cmovIF_reg(cmpOpF cmp, flagsRegF fcc, iRegI dst, iRegI src) %{
 6524   match(Set dst (CMoveI (Binary cmp fcc) (Binary dst src)));
 6525   ins_cost(150);
 6526   size(4);
 6527   format %{ &quot;MOV$cmp $fcc,$src,$dst&quot; %}
 6528   ins_encode( enc_cmov_reg_f(cmp,dst,src, fcc) );
 6529   ins_pipe(ialu_reg);
 6530 %}
 6531 
 6532 instruct cmovIF_imm(cmpOpF cmp, flagsRegF fcc, iRegI dst, immI11 src) %{
 6533   match(Set dst (CMoveI (Binary cmp fcc) (Binary dst src)));
 6534   ins_cost(140);
 6535   size(4);
 6536   format %{ &quot;MOV$cmp $fcc,$src,$dst&quot; %}
 6537   ins_encode( enc_cmov_imm_f(cmp,dst,src, fcc) );
 6538   ins_pipe(ialu_imm);
 6539 %}
 6540 
 6541 // Conditional move for RegN. Only cmov(reg,reg).
 6542 instruct cmovNP_reg(cmpOpP cmp, flagsRegP pcc, iRegN dst, iRegN src) %{
 6543   match(Set dst (CMoveN (Binary cmp pcc) (Binary dst src)));
 6544   ins_cost(150);
 6545   format %{ &quot;MOV$cmp $pcc,$src,$dst&quot; %}
 6546   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::ptr_cc)) );
 6547   ins_pipe(ialu_reg);
 6548 %}
 6549 
 6550 // This instruction also works with CmpN so we don&#39;t need cmovNN_reg.
 6551 instruct cmovNI_reg(cmpOp cmp, flagsReg icc, iRegN dst, iRegN src) %{
 6552   match(Set dst (CMoveN (Binary cmp icc) (Binary dst src)));
 6553   ins_cost(150);
 6554   size(4);
 6555   format %{ &quot;MOV$cmp  $icc,$src,$dst&quot; %}
 6556   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6557   ins_pipe(ialu_reg);
 6558 %}
 6559 
 6560 // This instruction also works with CmpN so we don&#39;t need cmovNN_reg.
 6561 instruct cmovNIu_reg(cmpOpU cmp, flagsRegU icc, iRegN dst, iRegN src) %{
 6562   match(Set dst (CMoveN (Binary cmp icc) (Binary dst src)));
 6563   ins_cost(150);
 6564   size(4);
 6565   format %{ &quot;MOV$cmp  $icc,$src,$dst&quot; %}
 6566   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6567   ins_pipe(ialu_reg);
 6568 %}
 6569 
 6570 instruct cmovNF_reg(cmpOpF cmp, flagsRegF fcc, iRegN dst, iRegN src) %{
 6571   match(Set dst (CMoveN (Binary cmp fcc) (Binary dst src)));
 6572   ins_cost(150);
 6573   size(4);
 6574   format %{ &quot;MOV$cmp $fcc,$src,$dst&quot; %}
 6575   ins_encode( enc_cmov_reg_f(cmp,dst,src, fcc) );
 6576   ins_pipe(ialu_reg);
 6577 %}
 6578 
 6579 // Conditional move
 6580 instruct cmovPP_reg(cmpOpP cmp, flagsRegP pcc, iRegP dst, iRegP src) %{
 6581   match(Set dst (CMoveP (Binary cmp pcc) (Binary dst src)));
 6582   ins_cost(150);
 6583   format %{ &quot;MOV$cmp $pcc,$src,$dst\t! ptr&quot; %}
 6584   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::ptr_cc)) );
 6585   ins_pipe(ialu_reg);
 6586 %}
 6587 
 6588 instruct cmovPP_imm(cmpOpP cmp, flagsRegP pcc, iRegP dst, immP0 src) %{
 6589   match(Set dst (CMoveP (Binary cmp pcc) (Binary dst src)));
 6590   ins_cost(140);
 6591   format %{ &quot;MOV$cmp $pcc,$src,$dst\t! ptr&quot; %}
 6592   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::ptr_cc)) );
 6593   ins_pipe(ialu_imm);
 6594 %}
 6595 
 6596 // This instruction also works with CmpN so we don&#39;t need cmovPN_reg.
 6597 instruct cmovPI_reg(cmpOp cmp, flagsReg icc, iRegP dst, iRegP src) %{
 6598   match(Set dst (CMoveP (Binary cmp icc) (Binary dst src)));
 6599   ins_cost(150);
 6600 
 6601   size(4);
 6602   format %{ &quot;MOV$cmp  $icc,$src,$dst\t! ptr&quot; %}
 6603   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6604   ins_pipe(ialu_reg);
 6605 %}
 6606 
 6607 instruct cmovPIu_reg(cmpOpU cmp, flagsRegU icc, iRegP dst, iRegP src) %{
 6608   match(Set dst (CMoveP (Binary cmp icc) (Binary dst src)));
 6609   ins_cost(150);
 6610 
 6611   size(4);
 6612   format %{ &quot;MOV$cmp  $icc,$src,$dst\t! ptr&quot; %}
 6613   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6614   ins_pipe(ialu_reg);
 6615 %}
 6616 
 6617 instruct cmovPI_imm(cmpOp cmp, flagsReg icc, iRegP dst, immP0 src) %{
 6618   match(Set dst (CMoveP (Binary cmp icc) (Binary dst src)));
 6619   ins_cost(140);
 6620 
 6621   size(4);
 6622   format %{ &quot;MOV$cmp  $icc,$src,$dst\t! ptr&quot; %}
 6623   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::icc)) );
 6624   ins_pipe(ialu_imm);
 6625 %}
 6626 
 6627 instruct cmovPIu_imm(cmpOpU cmp, flagsRegU icc, iRegP dst, immP0 src) %{
 6628   match(Set dst (CMoveP (Binary cmp icc) (Binary dst src)));
 6629   ins_cost(140);
 6630 
 6631   size(4);
 6632   format %{ &quot;MOV$cmp  $icc,$src,$dst\t! ptr&quot; %}
 6633   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::icc)) );
 6634   ins_pipe(ialu_imm);
 6635 %}
 6636 
 6637 instruct cmovPF_reg(cmpOpF cmp, flagsRegF fcc, iRegP dst, iRegP src) %{
 6638   match(Set dst (CMoveP (Binary cmp fcc) (Binary dst src)));
 6639   ins_cost(150);
 6640   size(4);
 6641   format %{ &quot;MOV$cmp $fcc,$src,$dst&quot; %}
 6642   ins_encode( enc_cmov_reg_f(cmp,dst,src, fcc) );
 6643   ins_pipe(ialu_imm);
 6644 %}
 6645 
 6646 instruct cmovPF_imm(cmpOpF cmp, flagsRegF fcc, iRegP dst, immP0 src) %{
 6647   match(Set dst (CMoveP (Binary cmp fcc) (Binary dst src)));
 6648   ins_cost(140);
 6649   size(4);
 6650   format %{ &quot;MOV$cmp $fcc,$src,$dst&quot; %}
 6651   ins_encode( enc_cmov_imm_f(cmp,dst,src, fcc) );
 6652   ins_pipe(ialu_imm);
 6653 %}
 6654 
 6655 // Conditional move
 6656 instruct cmovFP_reg(cmpOpP cmp, flagsRegP pcc, regF dst, regF src) %{
 6657   match(Set dst (CMoveF (Binary cmp pcc) (Binary dst src)));
 6658   ins_cost(150);
 6659   opcode(0x101);
 6660   format %{ &quot;FMOVD$cmp $pcc,$src,$dst&quot; %}
 6661   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::ptr_cc)) );
 6662   ins_pipe(int_conditional_float_move);
 6663 %}
 6664 
 6665 instruct cmovFI_reg(cmpOp cmp, flagsReg icc, regF dst, regF src) %{
 6666   match(Set dst (CMoveF (Binary cmp icc) (Binary dst src)));
 6667   ins_cost(150);
 6668 
 6669   size(4);
 6670   format %{ &quot;FMOVS$cmp $icc,$src,$dst&quot; %}
 6671   opcode(0x101);
 6672   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::icc)) );
 6673   ins_pipe(int_conditional_float_move);
 6674 %}
 6675 
 6676 instruct cmovFIu_reg(cmpOpU cmp, flagsRegU icc, regF dst, regF src) %{
 6677   match(Set dst (CMoveF (Binary cmp icc) (Binary dst src)));
 6678   ins_cost(150);
 6679 
 6680   size(4);
 6681   format %{ &quot;FMOVS$cmp $icc,$src,$dst&quot; %}
 6682   opcode(0x101);
 6683   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::icc)) );
 6684   ins_pipe(int_conditional_float_move);
 6685 %}
 6686 
 6687 // Conditional move,
 6688 instruct cmovFF_reg(cmpOpF cmp, flagsRegF fcc, regF dst, regF src) %{
 6689   match(Set dst (CMoveF (Binary cmp fcc) (Binary dst src)));
 6690   ins_cost(150);
 6691   size(4);
 6692   format %{ &quot;FMOVF$cmp $fcc,$src,$dst&quot; %}
 6693   opcode(0x1);
 6694   ins_encode( enc_cmovff_reg(cmp,fcc,dst,src) );
 6695   ins_pipe(int_conditional_double_move);
 6696 %}
 6697 
 6698 // Conditional move
 6699 instruct cmovDP_reg(cmpOpP cmp, flagsRegP pcc, regD dst, regD src) %{
 6700   match(Set dst (CMoveD (Binary cmp pcc) (Binary dst src)));
 6701   ins_cost(150);
 6702   size(4);
 6703   opcode(0x102);
 6704   format %{ &quot;FMOVD$cmp $pcc,$src,$dst&quot; %}
 6705   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::ptr_cc)) );
 6706   ins_pipe(int_conditional_double_move);
 6707 %}
 6708 
 6709 instruct cmovDI_reg(cmpOp cmp, flagsReg icc, regD dst, regD src) %{
 6710   match(Set dst (CMoveD (Binary cmp icc) (Binary dst src)));
 6711   ins_cost(150);
 6712 
 6713   size(4);
 6714   format %{ &quot;FMOVD$cmp $icc,$src,$dst&quot; %}
 6715   opcode(0x102);
 6716   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::icc)) );
 6717   ins_pipe(int_conditional_double_move);
 6718 %}
 6719 
 6720 instruct cmovDIu_reg(cmpOpU cmp, flagsRegU icc, regD dst, regD src) %{
 6721   match(Set dst (CMoveD (Binary cmp icc) (Binary dst src)));
 6722   ins_cost(150);
 6723 
 6724   size(4);
 6725   format %{ &quot;FMOVD$cmp $icc,$src,$dst&quot; %}
 6726   opcode(0x102);
 6727   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::icc)) );
 6728   ins_pipe(int_conditional_double_move);
 6729 %}
 6730 
 6731 // Conditional move,
 6732 instruct cmovDF_reg(cmpOpF cmp, flagsRegF fcc, regD dst, regD src) %{
 6733   match(Set dst (CMoveD (Binary cmp fcc) (Binary dst src)));
 6734   ins_cost(150);
 6735   size(4);
 6736   format %{ &quot;FMOVD$cmp $fcc,$src,$dst&quot; %}
 6737   opcode(0x2);
 6738   ins_encode( enc_cmovff_reg(cmp,fcc,dst,src) );
 6739   ins_pipe(int_conditional_double_move);
 6740 %}
 6741 
 6742 // Conditional move
 6743 instruct cmovLP_reg(cmpOpP cmp, flagsRegP pcc, iRegL dst, iRegL src) %{
 6744   match(Set dst (CMoveL (Binary cmp pcc) (Binary dst src)));
 6745   ins_cost(150);
 6746   format %{ &quot;MOV$cmp $pcc,$src,$dst\t! long&quot; %}
 6747   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::ptr_cc)) );
 6748   ins_pipe(ialu_reg);
 6749 %}
 6750 
 6751 instruct cmovLP_imm(cmpOpP cmp, flagsRegP pcc, iRegL dst, immI11 src) %{
 6752   match(Set dst (CMoveL (Binary cmp pcc) (Binary dst src)));
 6753   ins_cost(140);
 6754   format %{ &quot;MOV$cmp $pcc,$src,$dst\t! long&quot; %}
 6755   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::ptr_cc)) );
 6756   ins_pipe(ialu_imm);
 6757 %}
 6758 
 6759 instruct cmovLI_reg(cmpOp cmp, flagsReg icc, iRegL dst, iRegL src) %{
 6760   match(Set dst (CMoveL (Binary cmp icc) (Binary dst src)));
 6761   ins_cost(150);
 6762 
 6763   size(4);
 6764   format %{ &quot;MOV$cmp  $icc,$src,$dst\t! long&quot; %}
 6765   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6766   ins_pipe(ialu_reg);
 6767 %}
 6768 
 6769 
 6770 instruct cmovLIu_reg(cmpOpU cmp, flagsRegU icc, iRegL dst, iRegL src) %{
 6771   match(Set dst (CMoveL (Binary cmp icc) (Binary dst src)));
 6772   ins_cost(150);
 6773 
 6774   size(4);
 6775   format %{ &quot;MOV$cmp  $icc,$src,$dst\t! long&quot; %}
 6776   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::icc)) );
 6777   ins_pipe(ialu_reg);
 6778 %}
 6779 
 6780 
 6781 instruct cmovLF_reg(cmpOpF cmp, flagsRegF fcc, iRegL dst, iRegL src) %{
 6782   match(Set dst (CMoveL (Binary cmp fcc) (Binary dst src)));
 6783   ins_cost(150);
 6784 
 6785   size(4);
 6786   format %{ &quot;MOV$cmp  $fcc,$src,$dst\t! long&quot; %}
 6787   ins_encode( enc_cmov_reg_f(cmp,dst,src, fcc) );
 6788   ins_pipe(ialu_reg);
 6789 %}
 6790 
 6791 
 6792 
 6793 //----------OS and Locking Instructions----------------------------------------
 6794 
 6795 // This name is KNOWN by the ADLC and cannot be changed.
 6796 // The ADLC forces a &#39;TypeRawPtr::BOTTOM&#39; output type
 6797 // for this guy.
 6798 instruct tlsLoadP(g2RegP dst) %{
 6799   match(Set dst (ThreadLocal));
 6800 
 6801   size(0);
 6802   ins_cost(0);
 6803   format %{ &quot;# TLS is in G2&quot; %}
 6804   ins_encode( /*empty encoding*/ );
 6805   ins_pipe(ialu_none);
 6806 %}
 6807 
 6808 instruct checkCastPP( iRegP dst ) %{
 6809   match(Set dst (CheckCastPP dst));
 6810 
 6811   size(0);
 6812   format %{ &quot;# checkcastPP of $dst&quot; %}
 6813   ins_encode( /*empty encoding*/ );
 6814   ins_pipe(empty);
 6815 %}
 6816 
 6817 
 6818 instruct castPP( iRegP dst ) %{
 6819   match(Set dst (CastPP dst));
 6820   format %{ &quot;# castPP of $dst&quot; %}
 6821   ins_encode( /*empty encoding*/ );
 6822   ins_pipe(empty);
 6823 %}
 6824 
 6825 instruct castII( iRegI dst ) %{
 6826   match(Set dst (CastII dst));
 6827   format %{ &quot;# castII of $dst&quot; %}
 6828   ins_encode( /*empty encoding*/ );
 6829   ins_cost(0);
 6830   ins_pipe(empty);
 6831 %}
 6832 
 6833 instruct castLL( iRegL dst ) %{
 6834   match(Set dst (CastLL dst));
 6835   format %{ &quot;# castLL of $dst&quot; %}
 6836   ins_encode( /*empty encoding*/ );
 6837   ins_cost(0);
 6838   ins_pipe(empty);
 6839 %}
 6840 
 6841 //----------Arithmetic Instructions--------------------------------------------
 6842 // Addition Instructions
 6843 // Register Addition
 6844 instruct addI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 6845   match(Set dst (AddI src1 src2));
 6846 
 6847   size(4);
 6848   format %{ &quot;ADD    $src1,$src2,$dst&quot; %}
 6849   ins_encode %{
 6850     __ add($src1$$Register, $src2$$Register, $dst$$Register);
 6851   %}
 6852   ins_pipe(ialu_reg_reg);
 6853 %}
 6854 
 6855 // Immediate Addition
 6856 instruct addI_reg_imm13(iRegI dst, iRegI src1, immI13 src2) %{
 6857   match(Set dst (AddI src1 src2));
 6858 
 6859   size(4);
 6860   format %{ &quot;ADD    $src1,$src2,$dst&quot; %}
 6861   opcode(Assembler::add_op3, Assembler::arith_op);
 6862   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 6863   ins_pipe(ialu_reg_imm);
 6864 %}
 6865 
 6866 // Pointer Register Addition
 6867 instruct addP_reg_reg(iRegP dst, iRegP src1, iRegX src2) %{
 6868   match(Set dst (AddP src1 src2));
 6869 
 6870   size(4);
 6871   format %{ &quot;ADD    $src1,$src2,$dst&quot; %}
 6872   opcode(Assembler::add_op3, Assembler::arith_op);
 6873   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 6874   ins_pipe(ialu_reg_reg);
 6875 %}
 6876 
 6877 // Pointer Immediate Addition
 6878 instruct addP_reg_imm13(iRegP dst, iRegP src1, immX13 src2) %{
 6879   match(Set dst (AddP src1 src2));
 6880 
 6881   size(4);
 6882   format %{ &quot;ADD    $src1,$src2,$dst&quot; %}
 6883   opcode(Assembler::add_op3, Assembler::arith_op);
 6884   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 6885   ins_pipe(ialu_reg_imm);
 6886 %}
 6887 
 6888 // Long Addition
 6889 instruct addL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 6890   match(Set dst (AddL src1 src2));
 6891 
 6892   size(4);
 6893   format %{ &quot;ADD    $src1,$src2,$dst\t! long&quot; %}
 6894   opcode(Assembler::add_op3, Assembler::arith_op);
 6895   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 6896   ins_pipe(ialu_reg_reg);
 6897 %}
 6898 
 6899 instruct addL_reg_imm13(iRegL dst, iRegL src1, immL13 con) %{
 6900   match(Set dst (AddL src1 con));
 6901 
 6902   size(4);
 6903   format %{ &quot;ADD    $src1,$con,$dst&quot; %}
 6904   opcode(Assembler::add_op3, Assembler::arith_op);
 6905   ins_encode( form3_rs1_simm13_rd( src1, con, dst ) );
 6906   ins_pipe(ialu_reg_imm);
 6907 %}
 6908 
 6909 //----------Conditional_store--------------------------------------------------
 6910 // Conditional-store of the updated heap-top.
 6911 // Used during allocation of the shared heap.
 6912 // Sets flags (EQ) on success.  Implemented with a CASA on Sparc.
 6913 
 6914 // LoadP-locked.  Same as a regular pointer load when used with a compare-swap
 6915 instruct loadPLocked(iRegP dst, memory mem) %{
 6916   match(Set dst (LoadPLocked mem));
 6917   ins_cost(MEMORY_REF_COST);
 6918 
 6919   format %{ &quot;LDX    $mem,$dst\t! ptr&quot; %}
 6920   opcode(Assembler::ldx_op3, 0, REGP_OP);
 6921   ins_encode( form3_mem_reg( mem, dst ) );
 6922   ins_pipe(iload_mem);
 6923 %}
 6924 
 6925 instruct storePConditional( iRegP heap_top_ptr, iRegP oldval, g3RegP newval, flagsRegP pcc ) %{
 6926   match(Set pcc (StorePConditional heap_top_ptr (Binary oldval newval)));
 6927   effect( KILL newval );
 6928   format %{ &quot;CASA   [$heap_top_ptr],$oldval,R_G3\t! If $oldval==[$heap_top_ptr] Then store R_G3 into [$heap_top_ptr], set R_G3=[$heap_top_ptr] in any case\n\t&quot;
 6929             &quot;CMP    R_G3,$oldval\t\t! See if we made progress&quot;  %}
 6930   ins_encode( enc_cas(heap_top_ptr,oldval,newval) );
 6931   ins_pipe( long_memory_op );
 6932 %}
 6933 
 6934 // Conditional-store of an int value.
 6935 instruct storeIConditional( iRegP mem_ptr, iRegI oldval, g3RegI newval, flagsReg icc ) %{
 6936   match(Set icc (StoreIConditional mem_ptr (Binary oldval newval)));
 6937   effect( KILL newval );
 6938   format %{ &quot;CASA   [$mem_ptr],$oldval,$newval\t! If $oldval==[$mem_ptr] Then store $newval into [$mem_ptr], set $newval=[$mem_ptr] in any case\n\t&quot;
 6939             &quot;CMP    $oldval,$newval\t\t! See if we made progress&quot;  %}
 6940   ins_encode( enc_cas(mem_ptr,oldval,newval) );
 6941   ins_pipe( long_memory_op );
 6942 %}
 6943 
 6944 // Conditional-store of a long value.
 6945 instruct storeLConditional( iRegP mem_ptr, iRegL oldval, g3RegL newval, flagsRegL xcc ) %{
 6946   match(Set xcc (StoreLConditional mem_ptr (Binary oldval newval)));
 6947   effect( KILL newval );
 6948   format %{ &quot;CASXA  [$mem_ptr],$oldval,$newval\t! If $oldval==[$mem_ptr] Then store $newval into [$mem_ptr], set $newval=[$mem_ptr] in any case\n\t&quot;
 6949             &quot;CMP    $oldval,$newval\t\t! See if we made progress&quot;  %}
 6950   ins_encode( enc_cas(mem_ptr,oldval,newval) );
 6951   ins_pipe( long_memory_op );
 6952 %}
 6953 
 6954 // No flag versions for CompareAndSwap{P,I,L} because matcher can&#39;t match them
 6955 
 6956 instruct compareAndSwapL_bool(iRegP mem_ptr, iRegL oldval, iRegL newval, iRegI res, o7RegI tmp1, flagsReg ccr ) %{
 6957   predicate(VM_Version::supports_cx8());
 6958   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
 6959   match(Set res (WeakCompareAndSwapL mem_ptr (Binary oldval newval)));
 6960   effect( USE mem_ptr, KILL ccr, KILL tmp1);
 6961   format %{
 6962             &quot;MOV    $newval,O7\n\t&quot;
 6963             &quot;CASXA  [$mem_ptr],$oldval,O7\t! If $oldval==[$mem_ptr] Then store O7 into [$mem_ptr], set O7=[$mem_ptr] in any case\n\t&quot;
 6964             &quot;CMP    $oldval,O7\t\t! See if we made progress\n\t&quot;
 6965             &quot;MOV    1,$res\n\t&quot;
 6966             &quot;MOVne  xcc,R_G0,$res&quot;
 6967   %}
 6968   ins_encode( enc_casx(mem_ptr, oldval, newval),
 6969               enc_lflags_ne_to_boolean(res) );
 6970   ins_pipe( long_memory_op );
 6971 %}
 6972 
 6973 
 6974 instruct compareAndSwapI_bool(iRegP mem_ptr, iRegI oldval, iRegI newval, iRegI res, o7RegI tmp1, flagsReg ccr ) %{
 6975   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
 6976   match(Set res (WeakCompareAndSwapI mem_ptr (Binary oldval newval)));
 6977   effect( USE mem_ptr, KILL ccr, KILL tmp1);
 6978   format %{
 6979             &quot;MOV    $newval,O7\n\t&quot;
 6980             &quot;CASA   [$mem_ptr],$oldval,O7\t! If $oldval==[$mem_ptr] Then store O7 into [$mem_ptr], set O7=[$mem_ptr] in any case\n\t&quot;
 6981             &quot;CMP    $oldval,O7\t\t! See if we made progress\n\t&quot;
 6982             &quot;MOV    1,$res\n\t&quot;
 6983             &quot;MOVne  icc,R_G0,$res&quot;
 6984   %}
 6985   ins_encode( enc_casi(mem_ptr, oldval, newval),
 6986               enc_iflags_ne_to_boolean(res) );
 6987   ins_pipe( long_memory_op );
 6988 %}
 6989 
 6990 instruct compareAndSwapP_bool(iRegP mem_ptr, iRegP oldval, iRegP newval, iRegI res, o7RegI tmp1, flagsReg ccr ) %{
 6991   predicate(VM_Version::supports_cx8());
 6992   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
 6993   match(Set res (WeakCompareAndSwapP mem_ptr (Binary oldval newval)));
 6994   effect( USE mem_ptr, KILL ccr, KILL tmp1);
 6995   format %{
 6996             &quot;MOV    $newval,O7\n\t&quot;
 6997             &quot;CASA_PTR  [$mem_ptr],$oldval,O7\t! If $oldval==[$mem_ptr] Then store O7 into [$mem_ptr], set O7=[$mem_ptr] in any case\n\t&quot;
 6998             &quot;CMP    $oldval,O7\t\t! See if we made progress\n\t&quot;
 6999             &quot;MOV    1,$res\n\t&quot;
 7000             &quot;MOVne  xcc,R_G0,$res&quot;
 7001   %}
 7002   ins_encode( enc_casx(mem_ptr, oldval, newval),
 7003               enc_lflags_ne_to_boolean(res) );
 7004   ins_pipe( long_memory_op );
 7005 %}
 7006 
 7007 instruct compareAndSwapN_bool(iRegP mem_ptr, iRegN oldval, iRegN newval, iRegI res, o7RegI tmp1, flagsReg ccr ) %{
 7008   match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));
 7009   match(Set res (WeakCompareAndSwapN mem_ptr (Binary oldval newval)));
 7010   effect( USE mem_ptr, KILL ccr, KILL tmp1);
 7011   format %{
 7012             &quot;MOV    $newval,O7\n\t&quot;
 7013             &quot;CASA   [$mem_ptr],$oldval,O7\t! If $oldval==[$mem_ptr] Then store O7 into [$mem_ptr], set O7=[$mem_ptr] in any case\n\t&quot;
 7014             &quot;CMP    $oldval,O7\t\t! See if we made progress\n\t&quot;
 7015             &quot;MOV    1,$res\n\t&quot;
 7016             &quot;MOVne  icc,R_G0,$res&quot;
 7017   %}
 7018   ins_encode( enc_casi(mem_ptr, oldval, newval),
 7019               enc_iflags_ne_to_boolean(res) );
 7020   ins_pipe( long_memory_op );
 7021 %}
 7022 
 7023 instruct compareAndExchangeI(iRegP mem_ptr, iRegI oldval, iRegI newval)
 7024 %{
 7025   match(Set newval (CompareAndExchangeI mem_ptr (Binary oldval newval)));
 7026   effect( USE mem_ptr );
 7027 
 7028   format %{
 7029             &quot;CASA   [$mem_ptr],$oldval,$newval\t! If $oldval==[$mem_ptr] Then store $newval into [$mem_ptr] and set $newval=[$mem_ptr]\n\t&quot;
 7030   %}
 7031   ins_encode( enc_casi_exch(mem_ptr, oldval, newval) );
 7032   ins_pipe( long_memory_op );
 7033 %}
 7034 
 7035 instruct compareAndExchangeL(iRegP mem_ptr, iRegL oldval, iRegL newval)
 7036 %{
 7037   match(Set newval (CompareAndExchangeL mem_ptr (Binary oldval newval)));
 7038   effect( USE mem_ptr );
 7039 
 7040   format %{
 7041             &quot;CASXA  [$mem_ptr],$oldval,$newval\t! If $oldval==[$mem_ptr] Then store $newval into [$mem_ptr] and set $newval=[$mem_ptr]\n\t&quot;
 7042   %}
 7043   ins_encode( enc_casx_exch(mem_ptr, oldval, newval) );
 7044   ins_pipe( long_memory_op );
 7045 %}
 7046 
 7047 instruct compareAndExchangeP(iRegP mem_ptr, iRegP oldval, iRegP newval)
 7048 %{
 7049   match(Set newval (CompareAndExchangeP mem_ptr (Binary oldval newval)));
 7050   effect( USE mem_ptr );
 7051 
 7052   format %{
 7053             &quot;CASXA  [$mem_ptr],$oldval,$newval\t! If $oldval==[$mem_ptr] Then store $newval into [$mem_ptr] and set $newval=[$mem_ptr]\n\t&quot;
 7054   %}
 7055   ins_encode( enc_casx_exch(mem_ptr, oldval, newval) );
 7056   ins_pipe( long_memory_op );
 7057 %}
 7058 
 7059 instruct compareAndExchangeN(iRegP mem_ptr, iRegN oldval, iRegN newval)
 7060 %{
 7061   match(Set newval (CompareAndExchangeN mem_ptr (Binary oldval newval)));
 7062   effect( USE mem_ptr );
 7063 
 7064   format %{
 7065             &quot;CASA   [$mem_ptr],$oldval,$newval\t! If $oldval==[$mem_ptr] Then store $newval into [$mem_ptr] and set $newval=[$mem_ptr]\n\t&quot;
 7066   %}
 7067   ins_encode( enc_casi_exch(mem_ptr, oldval, newval) );
 7068   ins_pipe( long_memory_op );
 7069 %}
 7070 
 7071 instruct xchgI( memory mem, iRegI newval) %{
 7072   match(Set newval (GetAndSetI mem newval));
 7073   format %{ &quot;SWAP  [$mem],$newval&quot; %}
 7074   size(4);
 7075   ins_encode %{
 7076     __ swap($mem$$Address, $newval$$Register);
 7077   %}
 7078   ins_pipe( long_memory_op );
 7079 %}
 7080 
 7081 
 7082 instruct xchgN( memory mem, iRegN newval) %{
 7083   match(Set newval (GetAndSetN mem newval));
 7084   format %{ &quot;SWAP  [$mem],$newval&quot; %}
 7085   size(4);
 7086   ins_encode %{
 7087     __ swap($mem$$Address, $newval$$Register);
 7088   %}
 7089   ins_pipe( long_memory_op );
 7090 %}
 7091 
 7092 //---------------------
 7093 // Subtraction Instructions
 7094 // Register Subtraction
 7095 instruct subI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7096   match(Set dst (SubI src1 src2));
 7097 
 7098   size(4);
 7099   format %{ &quot;SUB    $src1,$src2,$dst&quot; %}
 7100   opcode(Assembler::sub_op3, Assembler::arith_op);
 7101   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7102   ins_pipe(ialu_reg_reg);
 7103 %}
 7104 
 7105 // Immediate Subtraction
 7106 instruct subI_reg_imm13(iRegI dst, iRegI src1, immI13 src2) %{
 7107   match(Set dst (SubI src1 src2));
 7108 
 7109   size(4);
 7110   format %{ &quot;SUB    $src1,$src2,$dst&quot; %}
 7111   opcode(Assembler::sub_op3, Assembler::arith_op);
 7112   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7113   ins_pipe(ialu_reg_imm);
 7114 %}
 7115 
 7116 instruct subI_zero_reg(iRegI dst, immI0 zero, iRegI src2) %{
 7117   match(Set dst (SubI zero src2));
 7118 
 7119   size(4);
 7120   format %{ &quot;NEG    $src2,$dst&quot; %}
 7121   opcode(Assembler::sub_op3, Assembler::arith_op);
 7122   ins_encode( form3_rs1_rs2_rd( R_G0, src2, dst ) );
 7123   ins_pipe(ialu_zero_reg);
 7124 %}
 7125 
 7126 // Long subtraction
 7127 instruct subL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 7128   match(Set dst (SubL src1 src2));
 7129 
 7130   size(4);
 7131   format %{ &quot;SUB    $src1,$src2,$dst\t! long&quot; %}
 7132   opcode(Assembler::sub_op3, Assembler::arith_op);
 7133   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7134   ins_pipe(ialu_reg_reg);
 7135 %}
 7136 
 7137 // Immediate Subtraction
 7138 instruct subL_reg_imm13(iRegL dst, iRegL src1, immL13 con) %{
 7139   match(Set dst (SubL src1 con));
 7140 
 7141   size(4);
 7142   format %{ &quot;SUB    $src1,$con,$dst\t! long&quot; %}
 7143   opcode(Assembler::sub_op3, Assembler::arith_op);
 7144   ins_encode( form3_rs1_simm13_rd( src1, con, dst ) );
 7145   ins_pipe(ialu_reg_imm);
 7146 %}
 7147 
 7148 // Long negation
 7149 instruct negL_reg_reg(iRegL dst, immL0 zero, iRegL src2) %{
 7150   match(Set dst (SubL zero src2));
 7151 
 7152   size(4);
 7153   format %{ &quot;NEG    $src2,$dst\t! long&quot; %}
 7154   opcode(Assembler::sub_op3, Assembler::arith_op);
 7155   ins_encode( form3_rs1_rs2_rd( R_G0, src2, dst ) );
 7156   ins_pipe(ialu_zero_reg);
 7157 %}
 7158 
 7159 // Multiplication Instructions
 7160 // Integer Multiplication
 7161 // Register Multiplication
 7162 instruct mulI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7163   match(Set dst (MulI src1 src2));
 7164 
 7165   size(4);
 7166   format %{ &quot;MULX   $src1,$src2,$dst&quot; %}
 7167   opcode(Assembler::mulx_op3, Assembler::arith_op);
 7168   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7169   ins_pipe(imul_reg_reg);
 7170 %}
 7171 
 7172 // Immediate Multiplication
 7173 instruct mulI_reg_imm13(iRegI dst, iRegI src1, immI13 src2) %{
 7174   match(Set dst (MulI src1 src2));
 7175 
 7176   size(4);
 7177   format %{ &quot;MULX   $src1,$src2,$dst&quot; %}
 7178   opcode(Assembler::mulx_op3, Assembler::arith_op);
 7179   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7180   ins_pipe(imul_reg_imm);
 7181 %}
 7182 
 7183 instruct mulL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 7184   match(Set dst (MulL src1 src2));
 7185   ins_cost(DEFAULT_COST * 5);
 7186   size(4);
 7187   format %{ &quot;MULX   $src1,$src2,$dst\t! long&quot; %}
 7188   opcode(Assembler::mulx_op3, Assembler::arith_op);
 7189   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7190   ins_pipe(mulL_reg_reg);
 7191 %}
 7192 
 7193 // Immediate Multiplication
 7194 instruct mulL_reg_imm13(iRegL dst, iRegL src1, immL13 src2) %{
 7195   match(Set dst (MulL src1 src2));
 7196   ins_cost(DEFAULT_COST * 5);
 7197   size(4);
 7198   format %{ &quot;MULX   $src1,$src2,$dst&quot; %}
 7199   opcode(Assembler::mulx_op3, Assembler::arith_op);
 7200   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7201   ins_pipe(mulL_reg_imm);
 7202 %}
 7203 
 7204 // Integer Division
 7205 // Register Division
 7206 instruct divI_reg_reg(iRegI dst, iRegIsafe src1, iRegIsafe src2) %{
 7207   match(Set dst (DivI src1 src2));
 7208   ins_cost((2+71)*DEFAULT_COST);
 7209 
 7210   format %{ &quot;SRA     $src2,0,$src2\n\t&quot;
 7211             &quot;SRA     $src1,0,$src1\n\t&quot;
 7212             &quot;SDIVX   $src1,$src2,$dst&quot; %}
 7213   ins_encode( idiv_reg( src1, src2, dst ) );
 7214   ins_pipe(sdiv_reg_reg);
 7215 %}
 7216 
 7217 // Immediate Division
 7218 instruct divI_reg_imm13(iRegI dst, iRegIsafe src1, immI13 src2) %{
 7219   match(Set dst (DivI src1 src2));
 7220   ins_cost((2+71)*DEFAULT_COST);
 7221 
 7222   format %{ &quot;SRA     $src1,0,$src1\n\t&quot;
 7223             &quot;SDIVX   $src1,$src2,$dst&quot; %}
 7224   ins_encode( idiv_imm( src1, src2, dst ) );
 7225   ins_pipe(sdiv_reg_imm);
 7226 %}
 7227 
 7228 //----------Div-By-10-Expansion------------------------------------------------
 7229 // Extract hi bits of a 32x32-&gt;64 bit multiply.
 7230 // Expand rule only, not matched
 7231 instruct mul_hi(iRegIsafe dst, iRegIsafe src1, iRegIsafe src2 ) %{
 7232   effect( DEF dst, USE src1, USE src2 );
 7233   format %{ &quot;MULX   $src1,$src2,$dst\t! Used in div-by-10\n\t&quot;
 7234             &quot;SRLX   $dst,#32,$dst\t\t! Extract only hi word of result&quot; %}
 7235   ins_encode( enc_mul_hi(dst,src1,src2));
 7236   ins_pipe(sdiv_reg_reg);
 7237 %}
 7238 
 7239 // Magic constant, reciprocal of 10
 7240 instruct loadConI_x66666667(iRegIsafe dst) %{
 7241   effect( DEF dst );
 7242 
 7243   size(8);
 7244   format %{ &quot;SET    0x66666667,$dst\t! Used in div-by-10&quot; %}
 7245   ins_encode( Set32(0x66666667, dst) );
 7246   ins_pipe(ialu_hi_lo_reg);
 7247 %}
 7248 
 7249 // Register Shift Right Arithmetic Long by 32-63
 7250 instruct sra_31( iRegI dst, iRegI src ) %{
 7251   effect( DEF dst, USE src );
 7252   format %{ &quot;SRA    $src,31,$dst\t! Used in div-by-10&quot; %}
 7253   ins_encode( form3_rs1_rd_copysign_hi(src,dst) );
 7254   ins_pipe(ialu_reg_reg);
 7255 %}
 7256 
 7257 // Arithmetic Shift Right by 8-bit immediate
 7258 instruct sra_reg_2( iRegI dst, iRegI src ) %{
 7259   effect( DEF dst, USE src );
 7260   format %{ &quot;SRA    $src,2,$dst\t! Used in div-by-10&quot; %}
 7261   opcode(Assembler::sra_op3, Assembler::arith_op);
 7262   ins_encode( form3_rs1_simm13_rd( src, 0x2, dst ) );
 7263   ins_pipe(ialu_reg_imm);
 7264 %}
 7265 
 7266 // Integer DIV with 10
 7267 instruct divI_10( iRegI dst, iRegIsafe src, immI10 div ) %{
 7268   match(Set dst (DivI src div));
 7269   ins_cost((6+6)*DEFAULT_COST);
 7270   expand %{
 7271     iRegIsafe tmp1;               // Killed temps;
 7272     iRegIsafe tmp2;               // Killed temps;
 7273     iRegI tmp3;                   // Killed temps;
 7274     iRegI tmp4;                   // Killed temps;
 7275     loadConI_x66666667( tmp1 );   // SET  0x66666667 -&gt; tmp1
 7276     mul_hi( tmp2, src, tmp1 );    // MUL  hibits(src * tmp1) -&gt; tmp2
 7277     sra_31( tmp3, src );          // SRA  src,31 -&gt; tmp3
 7278     sra_reg_2( tmp4, tmp2 );      // SRA  tmp2,2 -&gt; tmp4
 7279     subI_reg_reg( dst,tmp4,tmp3); // SUB  tmp4 - tmp3 -&gt; dst
 7280   %}
 7281 %}
 7282 
 7283 // Register Long Division
 7284 instruct divL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 7285   match(Set dst (DivL src1 src2));
 7286   ins_cost(DEFAULT_COST*71);
 7287   size(4);
 7288   format %{ &quot;SDIVX  $src1,$src2,$dst\t! long&quot; %}
 7289   opcode(Assembler::sdivx_op3, Assembler::arith_op);
 7290   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7291   ins_pipe(divL_reg_reg);
 7292 %}
 7293 
 7294 // Register Long Division
 7295 instruct divL_reg_imm13(iRegL dst, iRegL src1, immL13 src2) %{
 7296   match(Set dst (DivL src1 src2));
 7297   ins_cost(DEFAULT_COST*71);
 7298   size(4);
 7299   format %{ &quot;SDIVX  $src1,$src2,$dst\t! long&quot; %}
 7300   opcode(Assembler::sdivx_op3, Assembler::arith_op);
 7301   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7302   ins_pipe(divL_reg_imm);
 7303 %}
 7304 
 7305 // Integer Remainder
 7306 // Register Remainder
 7307 instruct modI_reg_reg(iRegI dst, iRegIsafe src1, iRegIsafe src2, o7RegP temp, flagsReg ccr ) %{
 7308   match(Set dst (ModI src1 src2));
 7309   effect( KILL ccr, KILL temp);
 7310 
 7311   format %{ &quot;SREM   $src1,$src2,$dst&quot; %}
 7312   ins_encode( irem_reg(src1, src2, dst, temp) );
 7313   ins_pipe(sdiv_reg_reg);
 7314 %}
 7315 
 7316 // Immediate Remainder
 7317 instruct modI_reg_imm13(iRegI dst, iRegIsafe src1, immI13 src2, o7RegP temp, flagsReg ccr ) %{
 7318   match(Set dst (ModI src1 src2));
 7319   effect( KILL ccr, KILL temp);
 7320 
 7321   format %{ &quot;SREM   $src1,$src2,$dst&quot; %}
 7322   ins_encode( irem_imm(src1, src2, dst, temp) );
 7323   ins_pipe(sdiv_reg_imm);
 7324 %}
 7325 
 7326 // Register Long Remainder
 7327 instruct divL_reg_reg_1(iRegL dst, iRegL src1, iRegL src2) %{
 7328   effect(DEF dst, USE src1, USE src2);
 7329   size(4);
 7330   format %{ &quot;SDIVX  $src1,$src2,$dst\t! long&quot; %}
 7331   opcode(Assembler::sdivx_op3, Assembler::arith_op);
 7332   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7333   ins_pipe(divL_reg_reg);
 7334 %}
 7335 
 7336 // Register Long Division
 7337 instruct divL_reg_imm13_1(iRegL dst, iRegL src1, immL13 src2) %{
 7338   effect(DEF dst, USE src1, USE src2);
 7339   size(4);
 7340   format %{ &quot;SDIVX  $src1,$src2,$dst\t! long&quot; %}
 7341   opcode(Assembler::sdivx_op3, Assembler::arith_op);
 7342   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7343   ins_pipe(divL_reg_imm);
 7344 %}
 7345 
 7346 instruct mulL_reg_reg_1(iRegL dst, iRegL src1, iRegL src2) %{
 7347   effect(DEF dst, USE src1, USE src2);
 7348   size(4);
 7349   format %{ &quot;MULX   $src1,$src2,$dst\t! long&quot; %}
 7350   opcode(Assembler::mulx_op3, Assembler::arith_op);
 7351   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7352   ins_pipe(mulL_reg_reg);
 7353 %}
 7354 
 7355 // Immediate Multiplication
 7356 instruct mulL_reg_imm13_1(iRegL dst, iRegL src1, immL13 src2) %{
 7357   effect(DEF dst, USE src1, USE src2);
 7358   size(4);
 7359   format %{ &quot;MULX   $src1,$src2,$dst&quot; %}
 7360   opcode(Assembler::mulx_op3, Assembler::arith_op);
 7361   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7362   ins_pipe(mulL_reg_imm);
 7363 %}
 7364 
 7365 instruct subL_reg_reg_1(iRegL dst, iRegL src1, iRegL src2) %{
 7366   effect(DEF dst, USE src1, USE src2);
 7367   size(4);
 7368   format %{ &quot;SUB    $src1,$src2,$dst\t! long&quot; %}
 7369   opcode(Assembler::sub_op3, Assembler::arith_op);
 7370   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7371   ins_pipe(ialu_reg_reg);
 7372 %}
 7373 
 7374 instruct subL_reg_reg_2(iRegL dst, iRegL src1, iRegL src2) %{
 7375   effect(DEF dst, USE src1, USE src2);
 7376   size(4);
 7377   format %{ &quot;SUB    $src1,$src2,$dst\t! long&quot; %}
 7378   opcode(Assembler::sub_op3, Assembler::arith_op);
 7379   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7380   ins_pipe(ialu_reg_reg);
 7381 %}
 7382 
 7383 // Register Long Remainder
 7384 instruct modL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 7385   match(Set dst (ModL src1 src2));
 7386   ins_cost(DEFAULT_COST*(71 + 6 + 1));
 7387   expand %{
 7388     iRegL tmp1;
 7389     iRegL tmp2;
 7390     divL_reg_reg_1(tmp1, src1, src2);
 7391     mulL_reg_reg_1(tmp2, tmp1, src2);
 7392     subL_reg_reg_1(dst,  src1, tmp2);
 7393   %}
 7394 %}
 7395 
 7396 // Register Long Remainder
 7397 instruct modL_reg_imm13(iRegL dst, iRegL src1, immL13 src2) %{
 7398   match(Set dst (ModL src1 src2));
 7399   ins_cost(DEFAULT_COST*(71 + 6 + 1));
 7400   expand %{
 7401     iRegL tmp1;
 7402     iRegL tmp2;
 7403     divL_reg_imm13_1(tmp1, src1, src2);
 7404     mulL_reg_imm13_1(tmp2, tmp1, src2);
 7405     subL_reg_reg_2  (dst,  src1, tmp2);
 7406   %}
 7407 %}
 7408 
 7409 // Integer Shift Instructions
 7410 // Register Shift Left
 7411 instruct shlI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7412   match(Set dst (LShiftI src1 src2));
 7413 
 7414   size(4);
 7415   format %{ &quot;SLL    $src1,$src2,$dst&quot; %}
 7416   opcode(Assembler::sll_op3, Assembler::arith_op);
 7417   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7418   ins_pipe(ialu_reg_reg);
 7419 %}
 7420 
 7421 // Register Shift Left Immediate
 7422 instruct shlI_reg_imm5(iRegI dst, iRegI src1, immU5 src2) %{
 7423   match(Set dst (LShiftI src1 src2));
 7424 
 7425   size(4);
 7426   format %{ &quot;SLL    $src1,$src2,$dst&quot; %}
 7427   opcode(Assembler::sll_op3, Assembler::arith_op);
 7428   ins_encode( form3_rs1_imm5_rd( src1, src2, dst ) );
 7429   ins_pipe(ialu_reg_imm);
 7430 %}
 7431 
 7432 // Register Shift Left
 7433 instruct shlL_reg_reg(iRegL dst, iRegL src1, iRegI src2) %{
 7434   match(Set dst (LShiftL src1 src2));
 7435 
 7436   size(4);
 7437   format %{ &quot;SLLX   $src1,$src2,$dst&quot; %}
 7438   opcode(Assembler::sllx_op3, Assembler::arith_op);
 7439   ins_encode( form3_sd_rs1_rs2_rd( src1, src2, dst ) );
 7440   ins_pipe(ialu_reg_reg);
 7441 %}
 7442 
 7443 // Register Shift Left Immediate
 7444 instruct shlL_reg_imm6(iRegL dst, iRegL src1, immU6 src2) %{
 7445   match(Set dst (LShiftL src1 src2));
 7446 
 7447   size(4);
 7448   format %{ &quot;SLLX   $src1,$src2,$dst&quot; %}
 7449   opcode(Assembler::sllx_op3, Assembler::arith_op);
 7450   ins_encode( form3_sd_rs1_imm6_rd( src1, src2, dst ) );
 7451   ins_pipe(ialu_reg_imm);
 7452 %}
 7453 
 7454 // Register Arithmetic Shift Right
 7455 instruct sarI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7456   match(Set dst (RShiftI src1 src2));
 7457   size(4);
 7458   format %{ &quot;SRA    $src1,$src2,$dst&quot; %}
 7459   opcode(Assembler::sra_op3, Assembler::arith_op);
 7460   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7461   ins_pipe(ialu_reg_reg);
 7462 %}
 7463 
 7464 // Register Arithmetic Shift Right Immediate
 7465 instruct sarI_reg_imm5(iRegI dst, iRegI src1, immU5 src2) %{
 7466   match(Set dst (RShiftI src1 src2));
 7467 
 7468   size(4);
 7469   format %{ &quot;SRA    $src1,$src2,$dst&quot; %}
 7470   opcode(Assembler::sra_op3, Assembler::arith_op);
 7471   ins_encode( form3_rs1_imm5_rd( src1, src2, dst ) );
 7472   ins_pipe(ialu_reg_imm);
 7473 %}
 7474 
 7475 // Register Shift Right Arithmatic Long
 7476 instruct sarL_reg_reg(iRegL dst, iRegL src1, iRegI src2) %{
 7477   match(Set dst (RShiftL src1 src2));
 7478 
 7479   size(4);
 7480   format %{ &quot;SRAX   $src1,$src2,$dst&quot; %}
 7481   opcode(Assembler::srax_op3, Assembler::arith_op);
 7482   ins_encode( form3_sd_rs1_rs2_rd( src1, src2, dst ) );
 7483   ins_pipe(ialu_reg_reg);
 7484 %}
 7485 
 7486 // Register Shift Left Immediate
 7487 instruct sarL_reg_imm6(iRegL dst, iRegL src1, immU6 src2) %{
 7488   match(Set dst (RShiftL src1 src2));
 7489 
 7490   size(4);
 7491   format %{ &quot;SRAX   $src1,$src2,$dst&quot; %}
 7492   opcode(Assembler::srax_op3, Assembler::arith_op);
 7493   ins_encode( form3_sd_rs1_imm6_rd( src1, src2, dst ) );
 7494   ins_pipe(ialu_reg_imm);
 7495 %}
 7496 
 7497 // Register Shift Right
 7498 instruct shrI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7499   match(Set dst (URShiftI src1 src2));
 7500 
 7501   size(4);
 7502   format %{ &quot;SRL    $src1,$src2,$dst&quot; %}
 7503   opcode(Assembler::srl_op3, Assembler::arith_op);
 7504   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7505   ins_pipe(ialu_reg_reg);
 7506 %}
 7507 
 7508 // Register Shift Right Immediate
 7509 instruct shrI_reg_imm5(iRegI dst, iRegI src1, immU5 src2) %{
 7510   match(Set dst (URShiftI src1 src2));
 7511 
 7512   size(4);
 7513   format %{ &quot;SRL    $src1,$src2,$dst&quot; %}
 7514   opcode(Assembler::srl_op3, Assembler::arith_op);
 7515   ins_encode( form3_rs1_imm5_rd( src1, src2, dst ) );
 7516   ins_pipe(ialu_reg_imm);
 7517 %}
 7518 
 7519 // Register Shift Right
 7520 instruct shrL_reg_reg(iRegL dst, iRegL src1, iRegI src2) %{
 7521   match(Set dst (URShiftL src1 src2));
 7522 
 7523   size(4);
 7524   format %{ &quot;SRLX   $src1,$src2,$dst&quot; %}
 7525   opcode(Assembler::srlx_op3, Assembler::arith_op);
 7526   ins_encode( form3_sd_rs1_rs2_rd( src1, src2, dst ) );
 7527   ins_pipe(ialu_reg_reg);
 7528 %}
 7529 
 7530 // Register Shift Right Immediate
 7531 instruct shrL_reg_imm6(iRegL dst, iRegL src1, immU6 src2) %{
 7532   match(Set dst (URShiftL src1 src2));
 7533 
 7534   size(4);
 7535   format %{ &quot;SRLX   $src1,$src2,$dst&quot; %}
 7536   opcode(Assembler::srlx_op3, Assembler::arith_op);
 7537   ins_encode( form3_sd_rs1_imm6_rd( src1, src2, dst ) );
 7538   ins_pipe(ialu_reg_imm);
 7539 %}
 7540 
 7541 // Register Shift Right Immediate with a CastP2X
 7542 instruct shrP_reg_imm6(iRegL dst, iRegP src1, immU6 src2) %{
 7543   match(Set dst (URShiftL (CastP2X src1) src2));
 7544   size(4);
 7545   format %{ &quot;SRLX   $src1,$src2,$dst\t! Cast ptr $src1 to long and shift&quot; %}
 7546   opcode(Assembler::srlx_op3, Assembler::arith_op);
 7547   ins_encode( form3_sd_rs1_imm6_rd( src1, src2, dst ) );
 7548   ins_pipe(ialu_reg_imm);
 7549 %}
 7550 
 7551 
 7552 //----------Floating Point Arithmetic Instructions-----------------------------
 7553 
 7554 //  Add float single precision
 7555 instruct addF_reg_reg(regF dst, regF src1, regF src2) %{
 7556   match(Set dst (AddF src1 src2));
 7557 
 7558   size(4);
 7559   format %{ &quot;FADDS  $src1,$src2,$dst&quot; %}
 7560   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fadds_opf);
 7561   ins_encode(form3_opf_rs1F_rs2F_rdF(src1, src2, dst));
 7562   ins_pipe(faddF_reg_reg);
 7563 %}
 7564 
 7565 //  Add float double precision
 7566 instruct addD_reg_reg(regD dst, regD src1, regD src2) %{
 7567   match(Set dst (AddD src1 src2));
 7568 
 7569   size(4);
 7570   format %{ &quot;FADDD  $src1,$src2,$dst&quot; %}
 7571   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::faddd_opf);
 7572   ins_encode(form3_opf_rs1D_rs2D_rdD(src1, src2, dst));
 7573   ins_pipe(faddD_reg_reg);
 7574 %}
 7575 
 7576 //  Sub float single precision
 7577 instruct subF_reg_reg(regF dst, regF src1, regF src2) %{
 7578   match(Set dst (SubF src1 src2));
 7579 
 7580   size(4);
 7581   format %{ &quot;FSUBS  $src1,$src2,$dst&quot; %}
 7582   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fsubs_opf);
 7583   ins_encode(form3_opf_rs1F_rs2F_rdF(src1, src2, dst));
 7584   ins_pipe(faddF_reg_reg);
 7585 %}
 7586 
 7587 //  Sub float double precision
 7588 instruct subD_reg_reg(regD dst, regD src1, regD src2) %{
 7589   match(Set dst (SubD src1 src2));
 7590 
 7591   size(4);
 7592   format %{ &quot;FSUBD  $src1,$src2,$dst&quot; %}
 7593   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fsubd_opf);
 7594   ins_encode(form3_opf_rs1D_rs2D_rdD(src1, src2, dst));
 7595   ins_pipe(faddD_reg_reg);
 7596 %}
 7597 
 7598 //  Mul float single precision
 7599 instruct mulF_reg_reg(regF dst, regF src1, regF src2) %{
 7600   match(Set dst (MulF src1 src2));
 7601 
 7602   size(4);
 7603   format %{ &quot;FMULS  $src1,$src2,$dst&quot; %}
 7604   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fmuls_opf);
 7605   ins_encode(form3_opf_rs1F_rs2F_rdF(src1, src2, dst));
 7606   ins_pipe(fmulF_reg_reg);
 7607 %}
 7608 
 7609 //  Mul float double precision
 7610 instruct mulD_reg_reg(regD dst, regD src1, regD src2) %{
 7611   match(Set dst (MulD src1 src2));
 7612 
 7613   size(4);
 7614   format %{ &quot;FMULD  $src1,$src2,$dst&quot; %}
 7615   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fmuld_opf);
 7616   ins_encode(form3_opf_rs1D_rs2D_rdD(src1, src2, dst));
 7617   ins_pipe(fmulD_reg_reg);
 7618 %}
 7619 
 7620 //  Div float single precision
 7621 instruct divF_reg_reg(regF dst, regF src1, regF src2) %{
 7622   match(Set dst (DivF src1 src2));
 7623 
 7624   size(4);
 7625   format %{ &quot;FDIVS  $src1,$src2,$dst&quot; %}
 7626   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fdivs_opf);
 7627   ins_encode(form3_opf_rs1F_rs2F_rdF(src1, src2, dst));
 7628   ins_pipe(fdivF_reg_reg);
 7629 %}
 7630 
 7631 //  Div float double precision
 7632 instruct divD_reg_reg(regD dst, regD src1, regD src2) %{
 7633   match(Set dst (DivD src1 src2));
 7634 
 7635   size(4);
 7636   format %{ &quot;FDIVD  $src1,$src2,$dst&quot; %}
 7637   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fdivd_opf);
 7638   ins_encode(form3_opf_rs1D_rs2D_rdD(src1, src2, dst));
 7639   ins_pipe(fdivD_reg_reg);
 7640 %}
 7641 
 7642 //  Absolute float double precision
 7643 instruct absD_reg(regD dst, regD src) %{
 7644   match(Set dst (AbsD src));
 7645 
 7646   format %{ &quot;FABSd  $src,$dst&quot; %}
 7647   ins_encode(fabsd(dst, src));
 7648   ins_pipe(faddD_reg);
 7649 %}
 7650 
 7651 //  Absolute float single precision
 7652 instruct absF_reg(regF dst, regF src) %{
 7653   match(Set dst (AbsF src));
 7654 
 7655   format %{ &quot;FABSs  $src,$dst&quot; %}
 7656   ins_encode(fabss(dst, src));
 7657   ins_pipe(faddF_reg);
 7658 %}
 7659 
 7660 instruct negF_reg(regF dst, regF src) %{
 7661   match(Set dst (NegF src));
 7662 
 7663   size(4);
 7664   format %{ &quot;FNEGs  $src,$dst&quot; %}
 7665   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fnegs_opf);
 7666   ins_encode(form3_opf_rs2F_rdF(src, dst));
 7667   ins_pipe(faddF_reg);
 7668 %}
 7669 
 7670 instruct negD_reg(regD dst, regD src) %{
 7671   match(Set dst (NegD src));
 7672 
 7673   format %{ &quot;FNEGd  $src,$dst&quot; %}
 7674   ins_encode(fnegd(dst, src));
 7675   ins_pipe(faddD_reg);
 7676 %}
 7677 
 7678 //  Sqrt float double precision
 7679 instruct sqrtF_reg_reg(regF dst, regF src) %{
 7680   match(Set dst (ConvD2F (SqrtD (ConvF2D src))));
 7681 
 7682   size(4);
 7683   format %{ &quot;FSQRTS $src,$dst&quot; %}
 7684   ins_encode(fsqrts(dst, src));
 7685   ins_pipe(fdivF_reg_reg);
 7686 %}
 7687 
 7688 //  Sqrt float double precision
 7689 instruct sqrtD_reg_reg(regD dst, regD src) %{
 7690   match(Set dst (SqrtD src));
 7691 
 7692   size(4);
 7693   format %{ &quot;FSQRTD $src,$dst&quot; %}
 7694   ins_encode(fsqrtd(dst, src));
 7695   ins_pipe(fdivD_reg_reg);
 7696 %}
 7697 
 7698 // Single/Double precision fused floating-point multiply-add (d = a * b + c).
 7699 instruct fmaF_regx4(regF dst, regF a, regF b, regF c) %{
 7700   predicate(UseFMA);
 7701   match(Set dst (FmaF c (Binary a b)));
 7702   format %{ &quot;fmadds $a,$b,$c,$dst\t# $dst = $a * $b + $c&quot; %}
 7703   ins_encode(fmadds(dst, a, b, c));
 7704   ins_pipe(fmaF_regx4);
 7705 %}
 7706 
 7707 instruct fmaD_regx4(regD dst, regD a, regD b, regD c) %{
 7708   predicate(UseFMA);
 7709   match(Set dst (FmaD c (Binary a b)));
 7710   format %{ &quot;fmaddd $a,$b,$c,$dst\t# $dst = $a * $b + $c&quot; %}
 7711   ins_encode(fmaddd(dst, a, b, c));
 7712   ins_pipe(fmaD_regx4);
 7713 %}
 7714 
 7715 // Additional patterns matching complement versions that we can map directly to
 7716 // variants of the fused multiply-add instructions.
 7717 
 7718 // Single/Double precision fused floating-point multiply-sub (d = a * b - c)
 7719 instruct fmsubF_regx4(regF dst, regF a, regF b, regF c) %{
 7720   predicate(UseFMA);
 7721   match(Set dst (FmaF (NegF c) (Binary a b)));
 7722   format %{ &quot;fmsubs $a,$b,$c,$dst\t# $dst = $a * $b - $c&quot; %}
 7723   ins_encode(fmsubs(dst, a, b, c));
 7724   ins_pipe(fmaF_regx4);
 7725 %}
 7726 
 7727 instruct fmsubD_regx4(regD dst, regD a, regD b, regD c) %{
 7728   predicate(UseFMA);
 7729   match(Set dst (FmaD (NegD c) (Binary a b)));
 7730   format %{ &quot;fmsubd $a,$b,$c,$dst\t# $dst = $a * $b - $c&quot; %}
 7731   ins_encode(fmsubd(dst, a, b, c));
 7732   ins_pipe(fmaD_regx4);
 7733 %}
 7734 
 7735 // Single/Double precision fused floating-point neg. multiply-add,
 7736 //      d = -1 * a * b - c = -(a * b + c)
 7737 instruct fnmaddF_regx4(regF dst, regF a, regF b, regF c) %{
 7738   predicate(UseFMA);
 7739   match(Set dst (FmaF (NegF c) (Binary (NegF a) b)));
 7740   match(Set dst (FmaF (NegF c) (Binary a (NegF b))));
 7741   format %{ &quot;fnmadds $a,$b,$c,$dst\t# $dst = -($a * $b + $c)&quot; %}
 7742   ins_encode(fnmadds(dst, a, b, c));
 7743   ins_pipe(fmaF_regx4);
 7744 %}
 7745 
 7746 instruct fnmaddD_regx4(regD dst, regD a, regD b, regD c) %{
 7747   predicate(UseFMA);
 7748   match(Set dst (FmaD (NegD c) (Binary (NegD a) b)));
 7749   match(Set dst (FmaD (NegD c) (Binary a (NegD b))));
 7750   format %{ &quot;fnmaddd $a,$b,$c,$dst\t# $dst = -($a * $b + $c)&quot; %}
 7751   ins_encode(fnmaddd(dst, a, b, c));
 7752   ins_pipe(fmaD_regx4);
 7753 %}
 7754 
 7755 // Single/Double precision fused floating-point neg. multiply-sub,
 7756 //      d = -1 * a * b + c = -(a * b - c)
 7757 instruct fnmsubF_regx4(regF dst, regF a, regF b, regF c) %{
 7758   predicate(UseFMA);
 7759   match(Set dst (FmaF c (Binary (NegF a) b)));
 7760   match(Set dst (FmaF c (Binary a (NegF b))));
 7761   format %{ &quot;fnmsubs $a,$b,$c,$dst\t# $dst = -($a * $b - $c)&quot; %}
 7762   ins_encode(fnmsubs(dst, a, b, c));
 7763   ins_pipe(fmaF_regx4);
 7764 %}
 7765 
 7766 instruct fnmsubD_regx4(regD dst, regD a, regD b, regD c) %{
 7767   predicate(UseFMA);
 7768   match(Set dst (FmaD c (Binary (NegD a) b)));
 7769   match(Set dst (FmaD c (Binary a (NegD b))));
 7770   format %{ &quot;fnmsubd $a,$b,$c,$dst\t# $dst = -($a * $b - $c)&quot; %}
 7771   ins_encode(fnmsubd(dst, a, b, c));
 7772   ins_pipe(fmaD_regx4);
 7773 %}
 7774 
 7775 //----------Logical Instructions-----------------------------------------------
 7776 // And Instructions
 7777 // Register And
 7778 instruct andI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7779   match(Set dst (AndI src1 src2));
 7780 
 7781   size(4);
 7782   format %{ &quot;AND    $src1,$src2,$dst&quot; %}
 7783   opcode(Assembler::and_op3, Assembler::arith_op);
 7784   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7785   ins_pipe(ialu_reg_reg);
 7786 %}
 7787 
 7788 // Immediate And
 7789 instruct andI_reg_imm13(iRegI dst, iRegI src1, immI13 src2) %{
 7790   match(Set dst (AndI src1 src2));
 7791 
 7792   size(4);
 7793   format %{ &quot;AND    $src1,$src2,$dst&quot; %}
 7794   opcode(Assembler::and_op3, Assembler::arith_op);
 7795   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7796   ins_pipe(ialu_reg_imm);
 7797 %}
 7798 
 7799 // Register And Long
 7800 instruct andL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 7801   match(Set dst (AndL src1 src2));
 7802 
 7803   ins_cost(DEFAULT_COST);
 7804   size(4);
 7805   format %{ &quot;AND    $src1,$src2,$dst\t! long&quot; %}
 7806   opcode(Assembler::and_op3, Assembler::arith_op);
 7807   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7808   ins_pipe(ialu_reg_reg);
 7809 %}
 7810 
 7811 instruct andL_reg_imm13(iRegL dst, iRegL src1, immL13 con) %{
 7812   match(Set dst (AndL src1 con));
 7813 
 7814   ins_cost(DEFAULT_COST);
 7815   size(4);
 7816   format %{ &quot;AND    $src1,$con,$dst\t! long&quot; %}
 7817   opcode(Assembler::and_op3, Assembler::arith_op);
 7818   ins_encode( form3_rs1_simm13_rd( src1, con, dst ) );
 7819   ins_pipe(ialu_reg_imm);
 7820 %}
 7821 
 7822 // Or Instructions
 7823 // Register Or
 7824 instruct orI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7825   match(Set dst (OrI src1 src2));
 7826 
 7827   size(4);
 7828   format %{ &quot;OR     $src1,$src2,$dst&quot; %}
 7829   opcode(Assembler::or_op3, Assembler::arith_op);
 7830   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7831   ins_pipe(ialu_reg_reg);
 7832 %}
 7833 
 7834 // Immediate Or
 7835 instruct orI_reg_imm13(iRegI dst, iRegI src1, immI13 src2) %{
 7836   match(Set dst (OrI src1 src2));
 7837 
 7838   size(4);
 7839   format %{ &quot;OR     $src1,$src2,$dst&quot; %}
 7840   opcode(Assembler::or_op3, Assembler::arith_op);
 7841   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7842   ins_pipe(ialu_reg_imm);
 7843 %}
 7844 
 7845 // Register Or Long
 7846 instruct orL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 7847   match(Set dst (OrL src1 src2));
 7848 
 7849   ins_cost(DEFAULT_COST);
 7850   size(4);
 7851   format %{ &quot;OR     $src1,$src2,$dst\t! long&quot; %}
 7852   opcode(Assembler::or_op3, Assembler::arith_op);
 7853   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7854   ins_pipe(ialu_reg_reg);
 7855 %}
 7856 
 7857 instruct orL_reg_imm13(iRegL dst, iRegL src1, immL13 con) %{
 7858   match(Set dst (OrL src1 con));
 7859   ins_cost(DEFAULT_COST*2);
 7860 
 7861   ins_cost(DEFAULT_COST);
 7862   size(4);
 7863   format %{ &quot;OR     $src1,$con,$dst\t! long&quot; %}
 7864   opcode(Assembler::or_op3, Assembler::arith_op);
 7865   ins_encode( form3_rs1_simm13_rd( src1, con, dst ) );
 7866   ins_pipe(ialu_reg_imm);
 7867 %}
 7868 
 7869 instruct orL_reg_castP2X(iRegL dst, iRegL src1, sp_ptr_RegP src2) %{
 7870   match(Set dst (OrL src1 (CastP2X src2)));
 7871 
 7872   ins_cost(DEFAULT_COST);
 7873   size(4);
 7874   format %{ &quot;OR     $src1,$src2,$dst\t! long&quot; %}
 7875   opcode(Assembler::or_op3, Assembler::arith_op);
 7876   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7877   ins_pipe(ialu_reg_reg);
 7878 %}
 7879 
 7880 // Xor Instructions
 7881 // Register Xor
 7882 instruct xorI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7883   match(Set dst (XorI src1 src2));
 7884 
 7885   size(4);
 7886   format %{ &quot;XOR    $src1,$src2,$dst&quot; %}
 7887   opcode(Assembler::xor_op3, Assembler::arith_op);
 7888   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7889   ins_pipe(ialu_reg_reg);
 7890 %}
 7891 
 7892 // Immediate Xor
 7893 instruct xorI_reg_imm13(iRegI dst, iRegI src1, immI13 src2) %{
 7894   match(Set dst (XorI src1 src2));
 7895 
 7896   size(4);
 7897   format %{ &quot;XOR    $src1,$src2,$dst&quot; %}
 7898   opcode(Assembler::xor_op3, Assembler::arith_op);
 7899   ins_encode( form3_rs1_simm13_rd( src1, src2, dst ) );
 7900   ins_pipe(ialu_reg_imm);
 7901 %}
 7902 
 7903 // Register Xor Long
 7904 instruct xorL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 7905   match(Set dst (XorL src1 src2));
 7906 
 7907   ins_cost(DEFAULT_COST);
 7908   size(4);
 7909   format %{ &quot;XOR    $src1,$src2,$dst\t! long&quot; %}
 7910   opcode(Assembler::xor_op3, Assembler::arith_op);
 7911   ins_encode( form3_rs1_rs2_rd( src1, src2, dst ) );
 7912   ins_pipe(ialu_reg_reg);
 7913 %}
 7914 
 7915 instruct xorL_reg_imm13(iRegL dst, iRegL src1, immL13 con) %{
 7916   match(Set dst (XorL src1 con));
 7917 
 7918   ins_cost(DEFAULT_COST);
 7919   size(4);
 7920   format %{ &quot;XOR    $src1,$con,$dst\t! long&quot; %}
 7921   opcode(Assembler::xor_op3, Assembler::arith_op);
 7922   ins_encode( form3_rs1_simm13_rd( src1, con, dst ) );
 7923   ins_pipe(ialu_reg_imm);
 7924 %}
 7925 
 7926 //----------Convert to Boolean-------------------------------------------------
 7927 // Nice hack for 32-bit tests but doesn&#39;t work for
 7928 // 64-bit pointers.
 7929 instruct convI2B( iRegI dst, iRegI src, flagsReg ccr ) %{
 7930   match(Set dst (Conv2B src));
 7931   effect( KILL ccr );
 7932   ins_cost(DEFAULT_COST*2);
 7933   format %{ &quot;CMP    R_G0,$src\n\t&quot;
 7934             &quot;ADDX   R_G0,0,$dst&quot; %}
 7935   ins_encode( enc_to_bool( src, dst ) );
 7936   ins_pipe(ialu_reg_ialu);
 7937 %}
 7938 
 7939 instruct convP2B( iRegI dst, iRegP src ) %{
 7940   match(Set dst (Conv2B src));
 7941   ins_cost(DEFAULT_COST*2);
 7942   format %{ &quot;MOV    $src,$dst\n\t&quot;
 7943             &quot;MOVRNZ $src,1,$dst&quot; %}
 7944   ins_encode( form3_g0_rs2_rd_move( src, dst ), enc_convP2B( dst, src ) );
 7945   ins_pipe(ialu_clr_and_mover);
 7946 %}
 7947 
 7948 instruct cmpLTMask0( iRegI dst, iRegI src, immI0 zero, flagsReg ccr ) %{
 7949   match(Set dst (CmpLTMask src zero));
 7950   effect(KILL ccr);
 7951   size(4);
 7952   format %{ &quot;SRA    $src,#31,$dst\t# cmpLTMask0&quot; %}
 7953   ins_encode %{
 7954     __ sra($src$$Register, 31, $dst$$Register);
 7955   %}
 7956   ins_pipe(ialu_reg_imm);
 7957 %}
 7958 
 7959 instruct cmpLTMask_reg_reg( iRegI dst, iRegI p, iRegI q, flagsReg ccr ) %{
 7960   match(Set dst (CmpLTMask p q));
 7961   effect( KILL ccr );
 7962   ins_cost(DEFAULT_COST*4);
 7963   format %{ &quot;CMP    $p,$q\n\t&quot;
 7964             &quot;MOV    #0,$dst\n\t&quot;
 7965             &quot;BLT,a  .+8\n\t&quot;
 7966             &quot;MOV    #-1,$dst&quot; %}
 7967   ins_encode( enc_ltmask(p,q,dst) );
 7968   ins_pipe(ialu_reg_reg_ialu);
 7969 %}
 7970 
 7971 instruct cadd_cmpLTMask( iRegI p, iRegI q, iRegI y, iRegI tmp, flagsReg ccr ) %{
 7972   match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
 7973   effect(KILL ccr, TEMP tmp);
 7974   ins_cost(DEFAULT_COST*3);
 7975 
 7976   format %{ &quot;SUBcc  $p,$q,$p\t! p&#39; = p-q\n\t&quot;
 7977             &quot;ADD    $p,$y,$tmp\t! g3=p-q+y\n\t&quot;
 7978             &quot;MOVlt  $tmp,$p\t! p&#39; &lt; 0 ? p&#39;+y : p&#39;&quot; %}
 7979   ins_encode(enc_cadd_cmpLTMask(p, q, y, tmp));
 7980   ins_pipe(cadd_cmpltmask);
 7981 %}
 7982 
 7983 instruct and_cmpLTMask(iRegI p, iRegI q, iRegI y, flagsReg ccr) %{
 7984   match(Set p (AndI (CmpLTMask p q) y));
 7985   effect(KILL ccr);
 7986   ins_cost(DEFAULT_COST*3);
 7987 
 7988   format %{ &quot;CMP  $p,$q\n\t&quot;
 7989             &quot;MOV  $y,$p\n\t&quot;
 7990             &quot;MOVge G0,$p&quot; %}
 7991   ins_encode %{
 7992     __ cmp($p$$Register, $q$$Register);
 7993     __ mov($y$$Register, $p$$Register);
 7994     __ movcc(Assembler::greaterEqual, false, Assembler::icc, G0, $p$$Register);
 7995   %}
 7996   ins_pipe(ialu_reg_reg_ialu);
 7997 %}
 7998 
 7999 //-----------------------------------------------------------------
 8000 // Direct raw moves between float and general registers using VIS3.
 8001 
 8002 //  ins_pipe(faddF_reg);
 8003 instruct MoveF2I_reg_reg(iRegI dst, regF src) %{
 8004   predicate(UseVIS &gt;= 3);
 8005   match(Set dst (MoveF2I src));
 8006 
 8007   format %{ &quot;MOVSTOUW $src,$dst\t! MoveF2I&quot; %}
 8008   ins_encode %{
 8009     __ movstouw($src$$FloatRegister, $dst$$Register);
 8010   %}
 8011   ins_pipe(ialu_reg_reg);
 8012 %}
 8013 
 8014 instruct MoveI2F_reg_reg(regF dst, iRegI src) %{
 8015   predicate(UseVIS &gt;= 3);
 8016   match(Set dst (MoveI2F src));
 8017 
 8018   format %{ &quot;MOVWTOS $src,$dst\t! MoveI2F&quot; %}
 8019   ins_encode %{
 8020     __ movwtos($src$$Register, $dst$$FloatRegister);
 8021   %}
 8022   ins_pipe(ialu_reg_reg);
 8023 %}
 8024 
 8025 instruct MoveD2L_reg_reg(iRegL dst, regD src) %{
 8026   predicate(UseVIS &gt;= 3);
 8027   match(Set dst (MoveD2L src));
 8028 
 8029   format %{ &quot;MOVDTOX $src,$dst\t! MoveD2L&quot; %}
 8030   ins_encode %{
 8031     __ movdtox(as_DoubleFloatRegister($src$$reg), $dst$$Register);
 8032   %}
 8033   ins_pipe(ialu_reg_reg);
 8034 %}
 8035 
 8036 instruct MoveL2D_reg_reg(regD dst, iRegL src) %{
 8037   predicate(UseVIS &gt;= 3);
 8038   match(Set dst (MoveL2D src));
 8039 
 8040   format %{ &quot;MOVXTOD $src,$dst\t! MoveL2D&quot; %}
 8041   ins_encode %{
 8042     __ movxtod($src$$Register, as_DoubleFloatRegister($dst$$reg));
 8043   %}
 8044   ins_pipe(ialu_reg_reg);
 8045 %}
 8046 
 8047 
 8048 // Raw moves between float and general registers using stack.
 8049 
 8050 instruct MoveF2I_stack_reg(iRegI dst, stackSlotF src) %{
 8051   match(Set dst (MoveF2I src));
 8052   effect(DEF dst, USE src);
 8053   ins_cost(MEMORY_REF_COST);
 8054 
 8055   format %{ &quot;LDUW   $src,$dst\t! MoveF2I&quot; %}
 8056   opcode(Assembler::lduw_op3);
 8057   ins_encode(simple_form3_mem_reg( src, dst ) );
 8058   ins_pipe(iload_mem);
 8059 %}
 8060 
 8061 instruct MoveI2F_stack_reg(regF dst, stackSlotI src) %{
 8062   match(Set dst (MoveI2F src));
 8063   effect(DEF dst, USE src);
 8064   ins_cost(MEMORY_REF_COST);
 8065 
 8066   format %{ &quot;LDF    $src,$dst\t! MoveI2F&quot; %}
 8067   opcode(Assembler::ldf_op3);
 8068   ins_encode(simple_form3_mem_reg(src, dst));
 8069   ins_pipe(floadF_stk);
 8070 %}
 8071 
 8072 instruct MoveD2L_stack_reg(iRegL dst, stackSlotD src) %{
 8073   match(Set dst (MoveD2L src));
 8074   effect(DEF dst, USE src);
 8075   ins_cost(MEMORY_REF_COST);
 8076 
 8077   format %{ &quot;LDX    $src,$dst\t! MoveD2L&quot; %}
 8078   opcode(Assembler::ldx_op3);
 8079   ins_encode(simple_form3_mem_reg( src, dst ) );
 8080   ins_pipe(iload_mem);
 8081 %}
 8082 
 8083 instruct MoveL2D_stack_reg(regD dst, stackSlotL src) %{
 8084   match(Set dst (MoveL2D src));
 8085   effect(DEF dst, USE src);
 8086   ins_cost(MEMORY_REF_COST);
 8087 
 8088   format %{ &quot;LDDF   $src,$dst\t! MoveL2D&quot; %}
 8089   opcode(Assembler::lddf_op3);
 8090   ins_encode(simple_form3_mem_reg(src, dst));
 8091   ins_pipe(floadD_stk);
 8092 %}
 8093 
 8094 instruct MoveF2I_reg_stack(stackSlotI dst, regF src) %{
 8095   match(Set dst (MoveF2I src));
 8096   effect(DEF dst, USE src);
 8097   ins_cost(MEMORY_REF_COST);
 8098 
 8099   format %{ &quot;STF   $src,$dst\t! MoveF2I&quot; %}
 8100   opcode(Assembler::stf_op3);
 8101   ins_encode(simple_form3_mem_reg(dst, src));
 8102   ins_pipe(fstoreF_stk_reg);
 8103 %}
 8104 
 8105 instruct MoveI2F_reg_stack(stackSlotF dst, iRegI src) %{
 8106   match(Set dst (MoveI2F src));
 8107   effect(DEF dst, USE src);
 8108   ins_cost(MEMORY_REF_COST);
 8109 
 8110   format %{ &quot;STW    $src,$dst\t! MoveI2F&quot; %}
 8111   opcode(Assembler::stw_op3);
 8112   ins_encode(simple_form3_mem_reg( dst, src ) );
 8113   ins_pipe(istore_mem_reg);
 8114 %}
 8115 
 8116 instruct MoveD2L_reg_stack(stackSlotL dst, regD src) %{
 8117   match(Set dst (MoveD2L src));
 8118   effect(DEF dst, USE src);
 8119   ins_cost(MEMORY_REF_COST);
 8120 
 8121   format %{ &quot;STDF   $src,$dst\t! MoveD2L&quot; %}
 8122   opcode(Assembler::stdf_op3);
 8123   ins_encode(simple_form3_mem_reg(dst, src));
 8124   ins_pipe(fstoreD_stk_reg);
 8125 %}
 8126 
 8127 instruct MoveL2D_reg_stack(stackSlotD dst, iRegL src) %{
 8128   match(Set dst (MoveL2D src));
 8129   effect(DEF dst, USE src);
 8130   ins_cost(MEMORY_REF_COST);
 8131 
 8132   format %{ &quot;STX    $src,$dst\t! MoveL2D&quot; %}
 8133   opcode(Assembler::stx_op3);
 8134   ins_encode(simple_form3_mem_reg( dst, src ) );
 8135   ins_pipe(istore_mem_reg);
 8136 %}
 8137 
 8138 
 8139 //----------Arithmetic Conversion Instructions---------------------------------
 8140 // The conversions operations are all Alpha sorted.  Please keep it that way!
 8141 
 8142 instruct convD2F_reg(regF dst, regD src) %{
 8143   match(Set dst (ConvD2F src));
 8144   size(4);
 8145   format %{ &quot;FDTOS  $src,$dst&quot; %}
 8146   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fdtos_opf);
 8147   ins_encode(form3_opf_rs2D_rdF(src, dst));
 8148   ins_pipe(fcvtD2F);
 8149 %}
 8150 
 8151 
 8152 // Convert a double to an int in a float register.
 8153 // If the double is a NAN, stuff a zero in instead.
 8154 instruct convD2I_helper(regF dst, regD src, flagsRegF0 fcc0) %{
 8155   effect(DEF dst, USE src, KILL fcc0);
 8156   format %{ &quot;FCMPd  fcc0,$src,$src\t! check for NAN\n\t&quot;
 8157             &quot;FBO,pt fcc0,skip\t! branch on ordered, predict taken\n\t&quot;
 8158             &quot;FDTOI  $src,$dst\t! convert in delay slot\n\t&quot;
 8159             &quot;FITOS  $dst,$dst\t! change NaN/max-int to valid float\n\t&quot;
 8160             &quot;FSUBs  $dst,$dst,$dst\t! cleared only if nan\n&quot;
 8161       &quot;skip:&quot; %}
 8162   ins_encode(form_d2i_helper(src,dst));
 8163   ins_pipe(fcvtD2I);
 8164 %}
 8165 
 8166 instruct convD2I_stk(stackSlotI dst, regD src) %{
 8167   match(Set dst (ConvD2I src));
 8168   ins_cost(DEFAULT_COST*2 + MEMORY_REF_COST*2 + BRANCH_COST);
 8169   expand %{
 8170     regF tmp;
 8171     convD2I_helper(tmp, src);
 8172     regF_to_stkI(dst, tmp);
 8173   %}
 8174 %}
 8175 
 8176 instruct convD2I_reg(iRegI dst, regD src) %{
 8177   predicate(UseVIS &gt;= 3);
 8178   match(Set dst (ConvD2I src));
 8179   ins_cost(DEFAULT_COST*2 + BRANCH_COST);
 8180   expand %{
 8181     regF tmp;
 8182     convD2I_helper(tmp, src);
 8183     MoveF2I_reg_reg(dst, tmp);
 8184   %}
 8185 %}
 8186 
 8187 
 8188 // Convert a double to a long in a double register.
 8189 // If the double is a NAN, stuff a zero in instead.
 8190 instruct convD2L_helper(regD dst, regD src, flagsRegF0 fcc0) %{
 8191   effect(DEF dst, USE src, KILL fcc0);
 8192   format %{ &quot;FCMPd  fcc0,$src,$src\t! check for NAN\n\t&quot;
 8193             &quot;FBO,pt fcc0,skip\t! branch on ordered, predict taken\n\t&quot;
 8194             &quot;FDTOX  $src,$dst\t! convert in delay slot\n\t&quot;
 8195             &quot;FXTOD  $dst,$dst\t! change NaN/max-long to valid double\n\t&quot;
 8196             &quot;FSUBd  $dst,$dst,$dst\t! cleared only if nan\n&quot;
 8197       &quot;skip:&quot; %}
 8198   ins_encode(form_d2l_helper(src,dst));
 8199   ins_pipe(fcvtD2L);
 8200 %}
 8201 
 8202 instruct convD2L_stk(stackSlotL dst, regD src) %{
 8203   match(Set dst (ConvD2L src));
 8204   ins_cost(DEFAULT_COST*2 + MEMORY_REF_COST*2 + BRANCH_COST);
 8205   expand %{
 8206     regD tmp;
 8207     convD2L_helper(tmp, src);
 8208     regD_to_stkL(dst, tmp);
 8209   %}
 8210 %}
 8211 
 8212 instruct convD2L_reg(iRegL dst, regD src) %{
 8213   predicate(UseVIS &gt;= 3);
 8214   match(Set dst (ConvD2L src));
 8215   ins_cost(DEFAULT_COST*2 + BRANCH_COST);
 8216   expand %{
 8217     regD tmp;
 8218     convD2L_helper(tmp, src);
 8219     MoveD2L_reg_reg(dst, tmp);
 8220   %}
 8221 %}
 8222 
 8223 
 8224 instruct convF2D_reg(regD dst, regF src) %{
 8225   match(Set dst (ConvF2D src));
 8226   format %{ &quot;FSTOD  $src,$dst&quot; %}
 8227   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fstod_opf);
 8228   ins_encode(form3_opf_rs2F_rdD(src, dst));
 8229   ins_pipe(fcvtF2D);
 8230 %}
 8231 
 8232 
 8233 // Convert a float to an int in a float register.
 8234 // If the float is a NAN, stuff a zero in instead.
 8235 instruct convF2I_helper(regF dst, regF src, flagsRegF0 fcc0) %{
 8236   effect(DEF dst, USE src, KILL fcc0);
 8237   format %{ &quot;FCMPs  fcc0,$src,$src\t! check for NAN\n\t&quot;
 8238             &quot;FBO,pt fcc0,skip\t! branch on ordered, predict taken\n\t&quot;
 8239             &quot;FSTOI  $src,$dst\t! convert in delay slot\n\t&quot;
 8240             &quot;FITOS  $dst,$dst\t! change NaN/max-int to valid float\n\t&quot;
 8241             &quot;FSUBs  $dst,$dst,$dst\t! cleared only if nan\n&quot;
 8242       &quot;skip:&quot; %}
 8243   ins_encode(form_f2i_helper(src,dst));
 8244   ins_pipe(fcvtF2I);
 8245 %}
 8246 
 8247 instruct convF2I_stk(stackSlotI dst, regF src) %{
 8248   match(Set dst (ConvF2I src));
 8249   ins_cost(DEFAULT_COST*2 + MEMORY_REF_COST*2 + BRANCH_COST);
 8250   expand %{
 8251     regF tmp;
 8252     convF2I_helper(tmp, src);
 8253     regF_to_stkI(dst, tmp);
 8254   %}
 8255 %}
 8256 
 8257 instruct convF2I_reg(iRegI dst, regF src) %{
 8258   predicate(UseVIS &gt;= 3);
 8259   match(Set dst (ConvF2I src));
 8260   ins_cost(DEFAULT_COST*2 + BRANCH_COST);
 8261   expand %{
 8262     regF tmp;
 8263     convF2I_helper(tmp, src);
 8264     MoveF2I_reg_reg(dst, tmp);
 8265   %}
 8266 %}
 8267 
 8268 
 8269 // Convert a float to a long in a float register.
 8270 // If the float is a NAN, stuff a zero in instead.
 8271 instruct convF2L_helper(regD dst, regF src, flagsRegF0 fcc0) %{
 8272   effect(DEF dst, USE src, KILL fcc0);
 8273   format %{ &quot;FCMPs  fcc0,$src,$src\t! check for NAN\n\t&quot;
 8274             &quot;FBO,pt fcc0,skip\t! branch on ordered, predict taken\n\t&quot;
 8275             &quot;FSTOX  $src,$dst\t! convert in delay slot\n\t&quot;
 8276             &quot;FXTOD  $dst,$dst\t! change NaN/max-long to valid double\n\t&quot;
 8277             &quot;FSUBd  $dst,$dst,$dst\t! cleared only if nan\n&quot;
 8278       &quot;skip:&quot; %}
 8279   ins_encode(form_f2l_helper(src,dst));
 8280   ins_pipe(fcvtF2L);
 8281 %}
 8282 
 8283 instruct convF2L_stk(stackSlotL dst, regF src) %{
 8284   match(Set dst (ConvF2L src));
 8285   ins_cost(DEFAULT_COST*2 + MEMORY_REF_COST*2 + BRANCH_COST);
 8286   expand %{
 8287     regD tmp;
 8288     convF2L_helper(tmp, src);
 8289     regD_to_stkL(dst, tmp);
 8290   %}
 8291 %}
 8292 
 8293 instruct convF2L_reg(iRegL dst, regF src) %{
 8294   predicate(UseVIS &gt;= 3);
 8295   match(Set dst (ConvF2L src));
 8296   ins_cost(DEFAULT_COST*2 + BRANCH_COST);
 8297   expand %{
 8298     regD tmp;
 8299     convF2L_helper(tmp, src);
 8300     MoveD2L_reg_reg(dst, tmp);
 8301   %}
 8302 %}
 8303 
 8304 
 8305 instruct convI2D_helper(regD dst, regF tmp) %{
 8306   effect(USE tmp, DEF dst);
 8307   format %{ &quot;FITOD  $tmp,$dst&quot; %}
 8308   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fitod_opf);
 8309   ins_encode(form3_opf_rs2F_rdD(tmp, dst));
 8310   ins_pipe(fcvtI2D);
 8311 %}
 8312 
 8313 instruct convI2D_stk(stackSlotI src, regD dst) %{
 8314   match(Set dst (ConvI2D src));
 8315   ins_cost(DEFAULT_COST + MEMORY_REF_COST);
 8316   expand %{
 8317     regF tmp;
 8318     stkI_to_regF(tmp, src);
 8319     convI2D_helper(dst, tmp);
 8320   %}
 8321 %}
 8322 
 8323 instruct convI2D_reg(regD_low dst, iRegI src) %{
 8324   predicate(UseVIS &gt;= 3);
 8325   match(Set dst (ConvI2D src));
 8326   expand %{
 8327     regF tmp;
 8328     MoveI2F_reg_reg(tmp, src);
 8329     convI2D_helper(dst, tmp);
 8330   %}
 8331 %}
 8332 
 8333 instruct convI2D_mem(regD_low dst, memory mem) %{
 8334   match(Set dst (ConvI2D (LoadI mem)));
 8335   ins_cost(DEFAULT_COST + MEMORY_REF_COST);
 8336   format %{ &quot;LDF    $mem,$dst\n\t&quot;
 8337             &quot;FITOD  $dst,$dst&quot; %}
 8338   opcode(Assembler::ldf_op3, Assembler::fitod_opf);
 8339   ins_encode(simple_form3_mem_reg( mem, dst ), form3_convI2F(dst, dst));
 8340   ins_pipe(floadF_mem);
 8341 %}
 8342 
 8343 
 8344 instruct convI2F_helper(regF dst, regF tmp) %{
 8345   effect(DEF dst, USE tmp);
 8346   format %{ &quot;FITOS  $tmp,$dst&quot; %}
 8347   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fitos_opf);
 8348   ins_encode(form3_opf_rs2F_rdF(tmp, dst));
 8349   ins_pipe(fcvtI2F);
 8350 %}
 8351 
 8352 instruct convI2F_stk(regF dst, stackSlotI src) %{
 8353   match(Set dst (ConvI2F src));
 8354   ins_cost(DEFAULT_COST + MEMORY_REF_COST);
 8355   expand %{
 8356     regF tmp;
 8357     stkI_to_regF(tmp,src);
 8358     convI2F_helper(dst, tmp);
 8359   %}
 8360 %}
 8361 
 8362 instruct convI2F_reg(regF dst, iRegI src) %{
 8363   predicate(UseVIS &gt;= 3);
 8364   match(Set dst (ConvI2F src));
 8365   ins_cost(DEFAULT_COST);
 8366   expand %{
 8367     regF tmp;
 8368     MoveI2F_reg_reg(tmp, src);
 8369     convI2F_helper(dst, tmp);
 8370   %}
 8371 %}
 8372 
 8373 instruct convI2F_mem( regF dst, memory mem ) %{
 8374   match(Set dst (ConvI2F (LoadI mem)));
 8375   ins_cost(DEFAULT_COST + MEMORY_REF_COST);
 8376   format %{ &quot;LDF    $mem,$dst\n\t&quot;
 8377             &quot;FITOS  $dst,$dst&quot; %}
 8378   opcode(Assembler::ldf_op3, Assembler::fitos_opf);
 8379   ins_encode(simple_form3_mem_reg( mem, dst ), form3_convI2F(dst, dst));
 8380   ins_pipe(floadF_mem);
 8381 %}
 8382 
 8383 
 8384 instruct convI2L_reg(iRegL dst, iRegI src) %{
 8385   match(Set dst (ConvI2L src));
 8386   size(4);
 8387   format %{ &quot;SRA    $src,0,$dst\t! int-&gt;long&quot; %}
 8388   opcode(Assembler::sra_op3, Assembler::arith_op);
 8389   ins_encode( form3_rs1_rs2_rd( src, R_G0, dst ) );
 8390   ins_pipe(ialu_reg_reg);
 8391 %}
 8392 
 8393 // Zero-extend convert int to long
 8394 instruct convI2L_reg_zex(iRegL dst, iRegI src, immL_32bits mask ) %{
 8395   match(Set dst (AndL (ConvI2L src) mask) );
 8396   size(4);
 8397   format %{ &quot;SRL    $src,0,$dst\t! zero-extend int to long&quot; %}
 8398   opcode(Assembler::srl_op3, Assembler::arith_op);
 8399   ins_encode( form3_rs1_rs2_rd( src, R_G0, dst ) );
 8400   ins_pipe(ialu_reg_reg);
 8401 %}
 8402 
 8403 // Zero-extend long
 8404 instruct zerox_long(iRegL dst, iRegL src, immL_32bits mask ) %{
 8405   match(Set dst (AndL src mask) );
 8406   size(4);
 8407   format %{ &quot;SRL    $src,0,$dst\t! zero-extend long&quot; %}
 8408   opcode(Assembler::srl_op3, Assembler::arith_op);
 8409   ins_encode( form3_rs1_rs2_rd( src, R_G0, dst ) );
 8410   ins_pipe(ialu_reg_reg);
 8411 %}
 8412 
 8413 
 8414 //-----------
 8415 // Long to Double conversion using V8 opcodes.
 8416 // Still useful because cheetah traps and becomes
 8417 // amazingly slow for some common numbers.
 8418 
 8419 // Magic constant, 0x43300000
 8420 instruct loadConI_x43300000(iRegI dst) %{
 8421   effect(DEF dst);
 8422   size(4);
 8423   format %{ &quot;SETHI  HI(0x43300000),$dst\t! 2^52&quot; %}
 8424   ins_encode(SetHi22(0x43300000, dst));
 8425   ins_pipe(ialu_none);
 8426 %}
 8427 
 8428 // Magic constant, 0x41f00000
 8429 instruct loadConI_x41f00000(iRegI dst) %{
 8430   effect(DEF dst);
 8431   size(4);
 8432   format %{ &quot;SETHI  HI(0x41f00000),$dst\t! 2^32&quot; %}
 8433   ins_encode(SetHi22(0x41f00000, dst));
 8434   ins_pipe(ialu_none);
 8435 %}
 8436 
 8437 // Construct a double from two float halves
 8438 instruct regDHi_regDLo_to_regD(regD_low dst, regD_low src1, regD_low src2) %{
 8439   effect(DEF dst, USE src1, USE src2);
 8440   size(8);
 8441   format %{ &quot;FMOVS  $src1.hi,$dst.hi\n\t&quot;
 8442             &quot;FMOVS  $src2.lo,$dst.lo&quot; %}
 8443   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fmovs_opf);
 8444   ins_encode(form3_opf_rs2D_hi_rdD_hi(src1, dst), form3_opf_rs2D_lo_rdD_lo(src2, dst));
 8445   ins_pipe(faddD_reg_reg);
 8446 %}
 8447 
 8448 // Convert integer in high half of a double register (in the lower half of
 8449 // the double register file) to double
 8450 instruct convI2D_regDHi_regD(regD dst, regD_low src) %{
 8451   effect(DEF dst, USE src);
 8452   size(4);
 8453   format %{ &quot;FITOD  $src,$dst&quot; %}
 8454   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fitod_opf);
 8455   ins_encode(form3_opf_rs2D_rdD(src, dst));
 8456   ins_pipe(fcvtLHi2D);
 8457 %}
 8458 
 8459 // Add float double precision
 8460 instruct addD_regD_regD(regD dst, regD src1, regD src2) %{
 8461   effect(DEF dst, USE src1, USE src2);
 8462   size(4);
 8463   format %{ &quot;FADDD  $src1,$src2,$dst&quot; %}
 8464   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::faddd_opf);
 8465   ins_encode(form3_opf_rs1D_rs2D_rdD(src1, src2, dst));
 8466   ins_pipe(faddD_reg_reg);
 8467 %}
 8468 
 8469 // Sub float double precision
 8470 instruct subD_regD_regD(regD dst, regD src1, regD src2) %{
 8471   effect(DEF dst, USE src1, USE src2);
 8472   size(4);
 8473   format %{ &quot;FSUBD  $src1,$src2,$dst&quot; %}
 8474   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fsubd_opf);
 8475   ins_encode(form3_opf_rs1D_rs2D_rdD(src1, src2, dst));
 8476   ins_pipe(faddD_reg_reg);
 8477 %}
 8478 
 8479 // Mul float double precision
 8480 instruct mulD_regD_regD(regD dst, regD src1, regD src2) %{
 8481   effect(DEF dst, USE src1, USE src2);
 8482   size(4);
 8483   format %{ &quot;FMULD  $src1,$src2,$dst&quot; %}
 8484   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fmuld_opf);
 8485   ins_encode(form3_opf_rs1D_rs2D_rdD(src1, src2, dst));
 8486   ins_pipe(fmulD_reg_reg);
 8487 %}
 8488 
 8489 // Long to Double conversion using fast fxtof
 8490 instruct convL2D_helper(regD dst, regD tmp) %{
 8491   effect(DEF dst, USE tmp);
 8492   size(4);
 8493   format %{ &quot;FXTOD  $tmp,$dst&quot; %}
 8494   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fxtod_opf);
 8495   ins_encode(form3_opf_rs2D_rdD(tmp, dst));
 8496   ins_pipe(fcvtL2D);
 8497 %}
 8498 
 8499 instruct convL2D_stk_fast_fxtof(regD dst, stackSlotL src) %{
 8500   match(Set dst (ConvL2D src));
 8501   ins_cost(DEFAULT_COST + 3 * MEMORY_REF_COST);
 8502   expand %{
 8503     regD tmp;
 8504     stkL_to_regD(tmp, src);
 8505     convL2D_helper(dst, tmp);
 8506   %}
 8507 %}
 8508 
 8509 instruct convL2D_reg(regD dst, iRegL src) %{
 8510   predicate(UseVIS &gt;= 3);
 8511   match(Set dst (ConvL2D src));
 8512   expand %{
 8513     regD tmp;
 8514     MoveL2D_reg_reg(tmp, src);
 8515     convL2D_helper(dst, tmp);
 8516   %}
 8517 %}
 8518 
 8519 // Long to Float conversion using fast fxtof
 8520 instruct convL2F_helper(regF dst, regD tmp) %{
 8521   effect(DEF dst, USE tmp);
 8522   size(4);
 8523   format %{ &quot;FXTOS  $tmp,$dst&quot; %}
 8524   opcode(Assembler::fpop1_op3, Assembler::arith_op, Assembler::fxtos_opf);
 8525   ins_encode(form3_opf_rs2D_rdF(tmp, dst));
 8526   ins_pipe(fcvtL2F);
 8527 %}
 8528 
 8529 instruct convL2F_stk_fast_fxtof(regF dst, stackSlotL src) %{
 8530   match(Set dst (ConvL2F src));
 8531   ins_cost(DEFAULT_COST + MEMORY_REF_COST);
 8532   expand %{
 8533     regD tmp;
 8534     stkL_to_regD(tmp, src);
 8535     convL2F_helper(dst, tmp);
 8536   %}
 8537 %}
 8538 
 8539 instruct convL2F_reg(regF dst, iRegL src) %{
 8540   predicate(UseVIS &gt;= 3);
 8541   match(Set dst (ConvL2F src));
 8542   ins_cost(DEFAULT_COST);
 8543   expand %{
 8544     regD tmp;
 8545     MoveL2D_reg_reg(tmp, src);
 8546     convL2F_helper(dst, tmp);
 8547   %}
 8548 %}
 8549 
 8550 //-----------
 8551 
 8552 instruct convL2I_reg(iRegI dst, iRegL src) %{
 8553   match(Set dst (ConvL2I src));
 8554   size(4);
 8555   format %{ &quot;SRA    $src,R_G0,$dst\t! long-&gt;int&quot; %}
 8556   ins_encode( form3_rs1_rd_signextend_lo1( src, dst ) );
 8557   ins_pipe(ialu_reg);
 8558 %}
 8559 
 8560 // Register Shift Right Immediate
 8561 instruct shrL_reg_imm6_L2I(iRegI dst, iRegL src, immI_32_63 cnt) %{
 8562   match(Set dst (ConvL2I (RShiftL src cnt)));
 8563 
 8564   size(4);
 8565   format %{ &quot;SRAX   $src,$cnt,$dst&quot; %}
 8566   opcode(Assembler::srax_op3, Assembler::arith_op);
 8567   ins_encode( form3_sd_rs1_imm6_rd( src, cnt, dst ) );
 8568   ins_pipe(ialu_reg_imm);
 8569 %}
 8570 
 8571 //----------Control Flow Instructions------------------------------------------
 8572 // Compare Instructions
 8573 // Compare Integers
 8574 instruct compI_iReg(flagsReg icc, iRegI op1, iRegI op2) %{
 8575   match(Set icc (CmpI op1 op2));
 8576   effect( DEF icc, USE op1, USE op2 );
 8577 
 8578   size(4);
 8579   format %{ &quot;CMP    $op1,$op2&quot; %}
 8580   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8581   ins_encode( form3_rs1_rs2_rd( op1, op2, R_G0 ) );
 8582   ins_pipe(ialu_cconly_reg_reg);
 8583 %}
 8584 
 8585 instruct compU_iReg(flagsRegU icc, iRegI op1, iRegI op2) %{
 8586   match(Set icc (CmpU op1 op2));
 8587 
 8588   size(4);
 8589   format %{ &quot;CMP    $op1,$op2\t! unsigned&quot; %}
 8590   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8591   ins_encode( form3_rs1_rs2_rd( op1, op2, R_G0 ) );
 8592   ins_pipe(ialu_cconly_reg_reg);
 8593 %}
 8594 
 8595 instruct compUL_iReg(flagsRegUL xcc, iRegL op1, iRegL op2) %{
 8596   match(Set xcc (CmpUL op1 op2));
 8597   effect(DEF xcc, USE op1, USE op2);
 8598 
 8599   size(4);
 8600   format %{ &quot;CMP    $op1,$op2\t! unsigned long&quot; %}
 8601   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8602   ins_encode(form3_rs1_rs2_rd(op1, op2, R_G0));
 8603   ins_pipe(ialu_cconly_reg_reg);
 8604 %}
 8605 
 8606 instruct compI_iReg_imm13(flagsReg icc, iRegI op1, immI13 op2) %{
 8607   match(Set icc (CmpI op1 op2));
 8608   effect( DEF icc, USE op1 );
 8609 
 8610   size(4);
 8611   format %{ &quot;CMP    $op1,$op2&quot; %}
 8612   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8613   ins_encode( form3_rs1_simm13_rd( op1, op2, R_G0 ) );
 8614   ins_pipe(ialu_cconly_reg_imm);
 8615 %}
 8616 
 8617 instruct testI_reg_reg( flagsReg icc, iRegI op1, iRegI op2, immI0 zero ) %{
 8618   match(Set icc (CmpI (AndI op1 op2) zero));
 8619 
 8620   size(4);
 8621   format %{ &quot;BTST   $op2,$op1&quot; %}
 8622   opcode(Assembler::andcc_op3, Assembler::arith_op);
 8623   ins_encode( form3_rs1_rs2_rd( op1, op2, R_G0 ) );
 8624   ins_pipe(ialu_cconly_reg_reg_zero);
 8625 %}
 8626 
 8627 instruct testI_reg_imm( flagsReg icc, iRegI op1, immI13 op2, immI0 zero ) %{
 8628   match(Set icc (CmpI (AndI op1 op2) zero));
 8629 
 8630   size(4);
 8631   format %{ &quot;BTST   $op2,$op1&quot; %}
 8632   opcode(Assembler::andcc_op3, Assembler::arith_op);
 8633   ins_encode( form3_rs1_simm13_rd( op1, op2, R_G0 ) );
 8634   ins_pipe(ialu_cconly_reg_imm_zero);
 8635 %}
 8636 
 8637 instruct compL_reg_reg(flagsRegL xcc, iRegL op1, iRegL op2 ) %{
 8638   match(Set xcc (CmpL op1 op2));
 8639   effect( DEF xcc, USE op1, USE op2 );
 8640 
 8641   size(4);
 8642   format %{ &quot;CMP    $op1,$op2\t\t! long&quot; %}
 8643   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8644   ins_encode( form3_rs1_rs2_rd( op1, op2, R_G0 ) );
 8645   ins_pipe(ialu_cconly_reg_reg);
 8646 %}
 8647 
 8648 instruct compL_reg_con(flagsRegL xcc, iRegL op1, immL13 con) %{
 8649   match(Set xcc (CmpL op1 con));
 8650   effect( DEF xcc, USE op1, USE con );
 8651 
 8652   size(4);
 8653   format %{ &quot;CMP    $op1,$con\t\t! long&quot; %}
 8654   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8655   ins_encode( form3_rs1_simm13_rd( op1, con, R_G0 ) );
 8656   ins_pipe(ialu_cconly_reg_reg);
 8657 %}
 8658 
 8659 instruct testL_reg_reg(flagsRegL xcc, iRegL op1, iRegL op2, immL0 zero) %{
 8660   match(Set xcc (CmpL (AndL op1 op2) zero));
 8661   effect( DEF xcc, USE op1, USE op2 );
 8662 
 8663   size(4);
 8664   format %{ &quot;BTST   $op1,$op2\t\t! long&quot; %}
 8665   opcode(Assembler::andcc_op3, Assembler::arith_op);
 8666   ins_encode( form3_rs1_rs2_rd( op1, op2, R_G0 ) );
 8667   ins_pipe(ialu_cconly_reg_reg);
 8668 %}
 8669 
 8670 // useful for checking the alignment of a pointer:
 8671 instruct testL_reg_con(flagsRegL xcc, iRegL op1, immL13 con, immL0 zero) %{
 8672   match(Set xcc (CmpL (AndL op1 con) zero));
 8673   effect( DEF xcc, USE op1, USE con );
 8674 
 8675   size(4);
 8676   format %{ &quot;BTST   $op1,$con\t\t! long&quot; %}
 8677   opcode(Assembler::andcc_op3, Assembler::arith_op);
 8678   ins_encode( form3_rs1_simm13_rd( op1, con, R_G0 ) );
 8679   ins_pipe(ialu_cconly_reg_reg);
 8680 %}
 8681 
 8682 instruct compU_iReg_imm13(flagsRegU icc, iRegI op1, immU12 op2 ) %{
 8683   match(Set icc (CmpU op1 op2));
 8684 
 8685   size(4);
 8686   format %{ &quot;CMP    $op1,$op2\t! unsigned&quot; %}
 8687   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8688   ins_encode( form3_rs1_simm13_rd( op1, op2, R_G0 ) );
 8689   ins_pipe(ialu_cconly_reg_imm);
 8690 %}
 8691 
 8692 instruct compUL_iReg_imm13(flagsRegUL xcc, iRegL op1, immUL12 op2) %{
 8693   match(Set xcc (CmpUL op1 op2));
 8694   effect(DEF xcc, USE op1, USE op2);
 8695 
 8696   size(4);
 8697   format %{ &quot;CMP    $op1,$op2\t! unsigned long&quot; %}
 8698   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8699   ins_encode(form3_rs1_simm13_rd(op1, op2, R_G0));
 8700   ins_pipe(ialu_cconly_reg_imm);
 8701 %}
 8702 
 8703 // Compare Pointers
 8704 instruct compP_iRegP(flagsRegP pcc, iRegP op1, iRegP op2 ) %{
 8705   match(Set pcc (CmpP op1 op2));
 8706 
 8707   size(4);
 8708   format %{ &quot;CMP    $op1,$op2\t! ptr&quot; %}
 8709   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8710   ins_encode( form3_rs1_rs2_rd( op1, op2, R_G0 ) );
 8711   ins_pipe(ialu_cconly_reg_reg);
 8712 %}
 8713 
 8714 instruct compP_iRegP_imm13(flagsRegP pcc, iRegP op1, immP13 op2 ) %{
 8715   match(Set pcc (CmpP op1 op2));
 8716 
 8717   size(4);
 8718   format %{ &quot;CMP    $op1,$op2\t! ptr&quot; %}
 8719   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8720   ins_encode( form3_rs1_simm13_rd( op1, op2, R_G0 ) );
 8721   ins_pipe(ialu_cconly_reg_imm);
 8722 %}
 8723 
 8724 // Compare Narrow oops
 8725 instruct compN_iRegN(flagsReg icc, iRegN op1, iRegN op2 ) %{
 8726   match(Set icc (CmpN op1 op2));
 8727 
 8728   size(4);
 8729   format %{ &quot;CMP    $op1,$op2\t! compressed ptr&quot; %}
 8730   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8731   ins_encode( form3_rs1_rs2_rd( op1, op2, R_G0 ) );
 8732   ins_pipe(ialu_cconly_reg_reg);
 8733 %}
 8734 
 8735 instruct compN_iRegN_immN0(flagsReg icc, iRegN op1, immN0 op2 ) %{
 8736   match(Set icc (CmpN op1 op2));
 8737 
 8738   size(4);
 8739   format %{ &quot;CMP    $op1,$op2\t! compressed ptr&quot; %}
 8740   opcode(Assembler::subcc_op3, Assembler::arith_op);
 8741   ins_encode( form3_rs1_simm13_rd( op1, op2, R_G0 ) );
 8742   ins_pipe(ialu_cconly_reg_imm);
 8743 %}
 8744 
 8745 //----------Max and Min--------------------------------------------------------
 8746 // Min Instructions
 8747 // Conditional move for min
 8748 instruct cmovI_reg_lt( iRegI op2, iRegI op1, flagsReg icc ) %{
 8749   effect( USE_DEF op2, USE op1, USE icc );
 8750 
 8751   size(4);
 8752   format %{ &quot;MOVlt  icc,$op1,$op2\t! min&quot; %}
 8753   opcode(Assembler::less);
 8754   ins_encode( enc_cmov_reg_minmax(op2,op1) );
 8755   ins_pipe(ialu_reg_flags);
 8756 %}
 8757 
 8758 // Min Register with Register.
 8759 instruct minI_eReg(iRegI op1, iRegI op2) %{
 8760   match(Set op2 (MinI op1 op2));
 8761   ins_cost(DEFAULT_COST*2);
 8762   expand %{
 8763     flagsReg icc;
 8764     compI_iReg(icc,op1,op2);
 8765     cmovI_reg_lt(op2,op1,icc);
 8766   %}
 8767 %}
 8768 
 8769 // Max Instructions
 8770 // Conditional move for max
 8771 instruct cmovI_reg_gt( iRegI op2, iRegI op1, flagsReg icc ) %{
 8772   effect( USE_DEF op2, USE op1, USE icc );
 8773   format %{ &quot;MOVgt  icc,$op1,$op2\t! max&quot; %}
 8774   opcode(Assembler::greater);
 8775   ins_encode( enc_cmov_reg_minmax(op2,op1) );
 8776   ins_pipe(ialu_reg_flags);
 8777 %}
 8778 
 8779 // Max Register with Register
 8780 instruct maxI_eReg(iRegI op1, iRegI op2) %{
 8781   match(Set op2 (MaxI op1 op2));
 8782   ins_cost(DEFAULT_COST*2);
 8783   expand %{
 8784     flagsReg icc;
 8785     compI_iReg(icc,op1,op2);
 8786     cmovI_reg_gt(op2,op1,icc);
 8787   %}
 8788 %}
 8789 
 8790 
 8791 //----------Float Compares----------------------------------------------------
 8792 // Compare floating, generate condition code
 8793 instruct cmpF_cc(flagsRegF fcc, regF src1, regF src2) %{
 8794   match(Set fcc (CmpF src1 src2));
 8795 
 8796   size(4);
 8797   format %{ &quot;FCMPs  $fcc,$src1,$src2&quot; %}
 8798   opcode(Assembler::fpop2_op3, Assembler::arith_op, Assembler::fcmps_opf);
 8799   ins_encode( form3_opf_rs1F_rs2F_fcc( src1, src2, fcc ) );
 8800   ins_pipe(faddF_fcc_reg_reg_zero);
 8801 %}
 8802 
 8803 instruct cmpD_cc(flagsRegF fcc, regD src1, regD src2) %{
 8804   match(Set fcc (CmpD src1 src2));
 8805 
 8806   size(4);
 8807   format %{ &quot;FCMPd  $fcc,$src1,$src2&quot; %}
 8808   opcode(Assembler::fpop2_op3, Assembler::arith_op, Assembler::fcmpd_opf);
 8809   ins_encode( form3_opf_rs1D_rs2D_fcc( src1, src2, fcc ) );
 8810   ins_pipe(faddD_fcc_reg_reg_zero);
 8811 %}
 8812 
 8813 
 8814 // Compare floating, generate -1,0,1
 8815 instruct cmpF_reg(iRegI dst, regF src1, regF src2, flagsRegF0 fcc0) %{
 8816   match(Set dst (CmpF3 src1 src2));
 8817   effect(KILL fcc0);
 8818   ins_cost(DEFAULT_COST*3+BRANCH_COST*3);
 8819   format %{ &quot;fcmpl  $dst,$src1,$src2&quot; %}
 8820   // Primary = float
 8821   opcode( true );
 8822   ins_encode( floating_cmp( dst, src1, src2 ) );
 8823   ins_pipe( floating_cmp );
 8824 %}
 8825 
 8826 instruct cmpD_reg(iRegI dst, regD src1, regD src2, flagsRegF0 fcc0) %{
 8827   match(Set dst (CmpD3 src1 src2));
 8828   effect(KILL fcc0);
 8829   ins_cost(DEFAULT_COST*3+BRANCH_COST*3);
 8830   format %{ &quot;dcmpl  $dst,$src1,$src2&quot; %}
 8831   // Primary = double (not float)
 8832   opcode( false );
 8833   ins_encode( floating_cmp( dst, src1, src2 ) );
 8834   ins_pipe( floating_cmp );
 8835 %}
 8836 
 8837 //----------Branches---------------------------------------------------------
 8838 // Jump
 8839 // (compare &#39;operand indIndex&#39; and &#39;instruct addP_reg_reg&#39; above)
 8840 instruct jumpXtnd(iRegX switch_val, o7RegI table) %{
 8841   match(Jump switch_val);
 8842   effect(TEMP table);
 8843 
 8844   ins_cost(350);
 8845 
 8846   format %{  &quot;ADD    $constanttablebase, $constantoffset, O7\n\t&quot;
 8847              &quot;LD     [O7 + $switch_val], O7\n\t&quot;
 8848              &quot;JUMP   O7&quot; %}
 8849   ins_encode %{
 8850     // Calculate table address into a register.
 8851     Register table_reg;
 8852     Register label_reg = O7;
 8853     // If we are calculating the size of this instruction don&#39;t trust
 8854     // zero offsets because they might change when
 8855     // MachConstantBaseNode decides to optimize the constant table
 8856     // base.
 8857     if ((constant_offset() == 0) &amp;&amp; !Compile::current()-&gt;output()-&gt;in_scratch_emit_size()) {
 8858       table_reg = $constanttablebase;
 8859     } else {
 8860       table_reg = O7;
 8861       RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset, O7);
 8862       __ add($constanttablebase, con_offset, table_reg);
 8863     }
 8864 
 8865     // Jump to base address + switch value
 8866     __ ld_ptr(table_reg, $switch_val$$Register, label_reg);
 8867     __ jmp(label_reg, G0);
 8868     __ delayed()-&gt;nop();
 8869   %}
 8870   ins_pipe(ialu_reg_reg);
 8871 %}
 8872 
 8873 // Direct Branch.  Use V8 version with longer range.
 8874 instruct branch(label labl) %{
 8875   match(Goto);
 8876   effect(USE labl);
 8877 
 8878   size(8);
 8879   ins_cost(BRANCH_COST);
 8880   format %{ &quot;BA     $labl&quot; %}
 8881   ins_encode %{
 8882     Label* L = $labl$$label;
 8883     __ ba(*L);
 8884     __ delayed()-&gt;nop();
 8885   %}
 8886   ins_avoid_back_to_back(AVOID_BEFORE);
 8887   ins_pipe(br);
 8888 %}
 8889 
 8890 // Direct Branch, short with no delay slot
 8891 instruct branch_short(label labl) %{
 8892   match(Goto);
 8893   predicate(UseCBCond);
 8894   effect(USE labl);
 8895 
 8896   size(4); // Assuming no NOP inserted.
 8897   ins_cost(BRANCH_COST);
 8898   format %{ &quot;BA     $labl\t! short branch&quot; %}
 8899   ins_encode %{
 8900     Label* L = $labl$$label;
 8901     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 8902     __ ba_short(*L);
 8903   %}
 8904   ins_short_branch(1);
 8905   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 8906   ins_pipe(cbcond_reg_imm);
 8907 %}
 8908 
 8909 // Conditional Direct Branch
 8910 instruct branchCon(cmpOp cmp, flagsReg icc, label labl) %{
 8911   match(If cmp icc);
 8912   effect(USE labl);
 8913 
 8914   size(8);
 8915   ins_cost(BRANCH_COST);
 8916   format %{ &quot;BP$cmp   $icc,$labl&quot; %}
 8917   // Prim = bits 24-22, Secnd = bits 31-30
 8918   ins_encode( enc_bp( labl, cmp, icc ) );
 8919   ins_avoid_back_to_back(AVOID_BEFORE);
 8920   ins_pipe(br_cc);
 8921 %}
 8922 
 8923 instruct branchConU(cmpOpU cmp, flagsRegU icc, label labl) %{
 8924   match(If cmp icc);
 8925   effect(USE labl);
 8926 
 8927   ins_cost(BRANCH_COST);
 8928   format %{ &quot;BP$cmp  $icc,$labl&quot; %}
 8929   // Prim = bits 24-22, Secnd = bits 31-30
 8930   ins_encode( enc_bp( labl, cmp, icc ) );
 8931   ins_avoid_back_to_back(AVOID_BEFORE);
 8932   ins_pipe(br_cc);
 8933 %}
 8934 
 8935 instruct branchConP(cmpOpP cmp, flagsRegP pcc, label labl) %{
 8936   match(If cmp pcc);
 8937   effect(USE labl);
 8938 
 8939   size(8);
 8940   ins_cost(BRANCH_COST);
 8941   format %{ &quot;BP$cmp  $pcc,$labl&quot; %}
 8942   ins_encode %{
 8943     Label* L = $labl$$label;
 8944     Assembler::Predict predict_taken =
 8945       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 8946 
 8947     __ bp( (Assembler::Condition)($cmp$$cmpcode), false, Assembler::ptr_cc, predict_taken, *L);
 8948     __ delayed()-&gt;nop();
 8949   %}
 8950   ins_avoid_back_to_back(AVOID_BEFORE);
 8951   ins_pipe(br_cc);
 8952 %}
 8953 
 8954 instruct branchConF(cmpOpF cmp, flagsRegF fcc, label labl) %{
 8955   match(If cmp fcc);
 8956   effect(USE labl);
 8957 
 8958   size(8);
 8959   ins_cost(BRANCH_COST);
 8960   format %{ &quot;FBP$cmp $fcc,$labl&quot; %}
 8961   ins_encode %{
 8962     Label* L = $labl$$label;
 8963     Assembler::Predict predict_taken =
 8964       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 8965 
 8966     __ fbp( (Assembler::Condition)($cmp$$cmpcode), false, (Assembler::CC)($fcc$$reg), predict_taken, *L);
 8967     __ delayed()-&gt;nop();
 8968   %}
 8969   ins_avoid_back_to_back(AVOID_BEFORE);
 8970   ins_pipe(br_fcc);
 8971 %}
 8972 
 8973 instruct branchLoopEnd(cmpOp cmp, flagsReg icc, label labl) %{
 8974   match(CountedLoopEnd cmp icc);
 8975   effect(USE labl);
 8976 
 8977   size(8);
 8978   ins_cost(BRANCH_COST);
 8979   format %{ &quot;BP$cmp   $icc,$labl\t! Loop end&quot; %}
 8980   // Prim = bits 24-22, Secnd = bits 31-30
 8981   ins_encode( enc_bp( labl, cmp, icc ) );
 8982   ins_avoid_back_to_back(AVOID_BEFORE);
 8983   ins_pipe(br_cc);
 8984 %}
 8985 
 8986 instruct branchLoopEndU(cmpOpU cmp, flagsRegU icc, label labl) %{
 8987   match(CountedLoopEnd cmp icc);
 8988   effect(USE labl);
 8989 
 8990   size(8);
 8991   ins_cost(BRANCH_COST);
 8992   format %{ &quot;BP$cmp  $icc,$labl\t! Loop end&quot; %}
 8993   // Prim = bits 24-22, Secnd = bits 31-30
 8994   ins_encode( enc_bp( labl, cmp, icc ) );
 8995   ins_avoid_back_to_back(AVOID_BEFORE);
 8996   ins_pipe(br_cc);
 8997 %}
 8998 
 8999 // Compare and branch instructions
 9000 instruct cmpI_reg_branch(cmpOp cmp, iRegI op1, iRegI op2, label labl, flagsReg icc) %{
 9001   match(If cmp (CmpI op1 op2));
 9002   effect(USE labl, KILL icc);
 9003 
 9004   size(12);
 9005   ins_cost(BRANCH_COST);
 9006   format %{ &quot;CMP    $op1,$op2\t! int\n\t&quot;
 9007             &quot;BP$cmp   $labl&quot; %}
 9008   ins_encode %{
 9009     Label* L = $labl$$label;
 9010     Assembler::Predict predict_taken =
 9011       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9012     __ cmp($op1$$Register, $op2$$Register);
 9013     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 9014     __ delayed()-&gt;nop();
 9015   %}
 9016   ins_pipe(cmp_br_reg_reg);
 9017 %}
 9018 
 9019 instruct cmpI_imm_branch(cmpOp cmp, iRegI op1, immI5 op2, label labl, flagsReg icc) %{
 9020   match(If cmp (CmpI op1 op2));
 9021   effect(USE labl, KILL icc);
 9022 
 9023   size(12);
 9024   ins_cost(BRANCH_COST);
 9025   format %{ &quot;CMP    $op1,$op2\t! int\n\t&quot;
 9026             &quot;BP$cmp   $labl&quot; %}
 9027   ins_encode %{
 9028     Label* L = $labl$$label;
 9029     Assembler::Predict predict_taken =
 9030       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9031     __ cmp($op1$$Register, $op2$$constant);
 9032     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 9033     __ delayed()-&gt;nop();
 9034   %}
 9035   ins_pipe(cmp_br_reg_imm);
 9036 %}
 9037 
 9038 instruct cmpU_reg_branch(cmpOpU cmp, iRegI op1, iRegI op2, label labl, flagsRegU icc) %{
 9039   match(If cmp (CmpU op1 op2));
 9040   effect(USE labl, KILL icc);
 9041 
 9042   size(12);
 9043   ins_cost(BRANCH_COST);
 9044   format %{ &quot;CMP    $op1,$op2\t! unsigned\n\t&quot;
 9045             &quot;BP$cmp  $labl&quot; %}
 9046   ins_encode %{
 9047     Label* L = $labl$$label;
 9048     Assembler::Predict predict_taken =
 9049       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9050     __ cmp($op1$$Register, $op2$$Register);
 9051     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 9052     __ delayed()-&gt;nop();
 9053   %}
 9054   ins_pipe(cmp_br_reg_reg);
 9055 %}
 9056 
 9057 instruct cmpU_imm_branch(cmpOpU cmp, iRegI op1, immI5 op2, label labl, flagsRegU icc) %{
 9058   match(If cmp (CmpU op1 op2));
 9059   effect(USE labl, KILL icc);
 9060 
 9061   size(12);
 9062   ins_cost(BRANCH_COST);
 9063   format %{ &quot;CMP    $op1,$op2\t! unsigned\n\t&quot;
 9064             &quot;BP$cmp  $labl&quot; %}
 9065   ins_encode %{
 9066     Label* L = $labl$$label;
 9067     Assembler::Predict predict_taken =
 9068       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9069     __ cmp($op1$$Register, $op2$$constant);
 9070     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 9071     __ delayed()-&gt;nop();
 9072   %}
 9073   ins_pipe(cmp_br_reg_imm);
 9074 %}
 9075 
 9076 instruct cmpUL_reg_branch(cmpOpU cmp, iRegL op1, iRegL op2, label labl, flagsRegUL xcc) %{
 9077   match(If cmp (CmpUL op1 op2));
 9078   effect(USE labl, KILL xcc);
 9079 
 9080   size(12);
 9081   ins_cost(BRANCH_COST);
 9082   format %{ &quot;CMP    $op1,$op2\t! unsigned long\n\t&quot;
 9083             &quot;BP$cmp   $labl&quot; %}
 9084   ins_encode %{
 9085     Label* L = $labl$$label;
 9086     Assembler::Predict predict_taken =
 9087       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9088     __ cmp($op1$$Register, $op2$$Register);
 9089     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::xcc, predict_taken, *L);
 9090     __ delayed()-&gt;nop();
 9091   %}
 9092   ins_pipe(cmp_br_reg_reg);
 9093 %}
 9094 
 9095 instruct cmpUL_imm_branch(cmpOpU cmp, iRegL op1, immL5 op2, label labl, flagsRegUL xcc) %{
 9096   match(If cmp (CmpUL op1 op2));
 9097   effect(USE labl, KILL xcc);
 9098 
 9099   size(12);
 9100   ins_cost(BRANCH_COST);
 9101   format %{ &quot;CMP    $op1,$op2\t! unsigned long\n\t&quot;
 9102             &quot;BP$cmp   $labl&quot; %}
 9103   ins_encode %{
 9104     Label* L = $labl$$label;
 9105     Assembler::Predict predict_taken =
 9106       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9107     __ cmp($op1$$Register, $op2$$constant);
 9108     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::xcc, predict_taken, *L);
 9109     __ delayed()-&gt;nop();
 9110   %}
 9111   ins_pipe(cmp_br_reg_imm);
 9112 %}
 9113 
 9114 instruct cmpL_reg_branch(cmpOp cmp, iRegL op1, iRegL op2, label labl, flagsRegL xcc) %{
 9115   match(If cmp (CmpL op1 op2));
 9116   effect(USE labl, KILL xcc);
 9117 
 9118   size(12);
 9119   ins_cost(BRANCH_COST);
 9120   format %{ &quot;CMP    $op1,$op2\t! long\n\t&quot;
 9121             &quot;BP$cmp   $labl&quot; %}
 9122   ins_encode %{
 9123     Label* L = $labl$$label;
 9124     Assembler::Predict predict_taken =
 9125       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9126     __ cmp($op1$$Register, $op2$$Register);
 9127     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::xcc, predict_taken, *L);
 9128     __ delayed()-&gt;nop();
 9129   %}
 9130   ins_pipe(cmp_br_reg_reg);
 9131 %}
 9132 
 9133 instruct cmpL_imm_branch(cmpOp cmp, iRegL op1, immL5 op2, label labl, flagsRegL xcc) %{
 9134   match(If cmp (CmpL op1 op2));
 9135   effect(USE labl, KILL xcc);
 9136 
 9137   size(12);
 9138   ins_cost(BRANCH_COST);
 9139   format %{ &quot;CMP    $op1,$op2\t! long\n\t&quot;
 9140             &quot;BP$cmp   $labl&quot; %}
 9141   ins_encode %{
 9142     Label* L = $labl$$label;
 9143     Assembler::Predict predict_taken =
 9144       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9145     __ cmp($op1$$Register, $op2$$constant);
 9146     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::xcc, predict_taken, *L);
 9147     __ delayed()-&gt;nop();
 9148   %}
 9149   ins_pipe(cmp_br_reg_imm);
 9150 %}
 9151 
 9152 // Compare Pointers and branch
 9153 instruct cmpP_reg_branch(cmpOpP cmp, iRegP op1, iRegP op2, label labl, flagsRegP pcc) %{
 9154   match(If cmp (CmpP op1 op2));
 9155   effect(USE labl, KILL pcc);
 9156 
 9157   size(12);
 9158   ins_cost(BRANCH_COST);
 9159   format %{ &quot;CMP    $op1,$op2\t! ptr\n\t&quot;
 9160             &quot;B$cmp   $labl&quot; %}
 9161   ins_encode %{
 9162     Label* L = $labl$$label;
 9163     Assembler::Predict predict_taken =
 9164       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9165     __ cmp($op1$$Register, $op2$$Register);
 9166     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::ptr_cc, predict_taken, *L);
 9167     __ delayed()-&gt;nop();
 9168   %}
 9169   ins_pipe(cmp_br_reg_reg);
 9170 %}
 9171 
 9172 instruct cmpP_null_branch(cmpOpP cmp, iRegP op1, immP0 null, label labl, flagsRegP pcc) %{
 9173   match(If cmp (CmpP op1 null));
 9174   effect(USE labl, KILL pcc);
 9175 
 9176   size(12);
 9177   ins_cost(BRANCH_COST);
 9178   format %{ &quot;CMP    $op1,0\t! ptr\n\t&quot;
 9179             &quot;B$cmp   $labl&quot; %}
 9180   ins_encode %{
 9181     Label* L = $labl$$label;
 9182     Assembler::Predict predict_taken =
 9183       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9184     __ cmp($op1$$Register, G0);
 9185     // bpr() is not used here since it has shorter distance.
 9186     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::ptr_cc, predict_taken, *L);
 9187     __ delayed()-&gt;nop();
 9188   %}
 9189   ins_pipe(cmp_br_reg_reg);
 9190 %}
 9191 
 9192 instruct cmpN_reg_branch(cmpOp cmp, iRegN op1, iRegN op2, label labl, flagsReg icc) %{
 9193   match(If cmp (CmpN op1 op2));
 9194   effect(USE labl, KILL icc);
 9195 
 9196   size(12);
 9197   ins_cost(BRANCH_COST);
 9198   format %{ &quot;CMP    $op1,$op2\t! compressed ptr\n\t&quot;
 9199             &quot;BP$cmp   $labl&quot; %}
 9200   ins_encode %{
 9201     Label* L = $labl$$label;
 9202     Assembler::Predict predict_taken =
 9203       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9204     __ cmp($op1$$Register, $op2$$Register);
 9205     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 9206     __ delayed()-&gt;nop();
 9207   %}
 9208   ins_pipe(cmp_br_reg_reg);
 9209 %}
 9210 
 9211 instruct cmpN_null_branch(cmpOp cmp, iRegN op1, immN0 null, label labl, flagsReg icc) %{
 9212   match(If cmp (CmpN op1 null));
 9213   effect(USE labl, KILL icc);
 9214 
 9215   size(12);
 9216   ins_cost(BRANCH_COST);
 9217   format %{ &quot;CMP    $op1,0\t! compressed ptr\n\t&quot;
 9218             &quot;BP$cmp   $labl&quot; %}
 9219   ins_encode %{
 9220     Label* L = $labl$$label;
 9221     Assembler::Predict predict_taken =
 9222       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9223     __ cmp($op1$$Register, G0);
 9224     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 9225     __ delayed()-&gt;nop();
 9226   %}
 9227   ins_pipe(cmp_br_reg_reg);
 9228 %}
 9229 
 9230 // Loop back branch
 9231 instruct cmpI_reg_branchLoopEnd(cmpOp cmp, iRegI op1, iRegI op2, label labl, flagsReg icc) %{
 9232   match(CountedLoopEnd cmp (CmpI op1 op2));
 9233   effect(USE labl, KILL icc);
 9234 
 9235   size(12);
 9236   ins_cost(BRANCH_COST);
 9237   format %{ &quot;CMP    $op1,$op2\t! int\n\t&quot;
 9238             &quot;BP$cmp   $labl\t! Loop end&quot; %}
 9239   ins_encode %{
 9240     Label* L = $labl$$label;
 9241     Assembler::Predict predict_taken =
 9242       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9243     __ cmp($op1$$Register, $op2$$Register);
 9244     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 9245     __ delayed()-&gt;nop();
 9246   %}
 9247   ins_pipe(cmp_br_reg_reg);
 9248 %}
 9249 
 9250 instruct cmpI_imm_branchLoopEnd(cmpOp cmp, iRegI op1, immI5 op2, label labl, flagsReg icc) %{
 9251   match(CountedLoopEnd cmp (CmpI op1 op2));
 9252   effect(USE labl, KILL icc);
 9253 
 9254   size(12);
 9255   ins_cost(BRANCH_COST);
 9256   format %{ &quot;CMP    $op1,$op2\t! int\n\t&quot;
 9257             &quot;BP$cmp   $labl\t! Loop end&quot; %}
 9258   ins_encode %{
 9259     Label* L = $labl$$label;
 9260     Assembler::Predict predict_taken =
 9261       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9262     __ cmp($op1$$Register, $op2$$constant);
 9263     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 9264     __ delayed()-&gt;nop();
 9265   %}
 9266   ins_pipe(cmp_br_reg_imm);
 9267 %}
 9268 
 9269 // Short compare and branch instructions
 9270 instruct cmpI_reg_branch_short(cmpOp cmp, iRegI op1, iRegI op2, label labl, flagsReg icc) %{
 9271   match(If cmp (CmpI op1 op2));
 9272   predicate(UseCBCond);
 9273   effect(USE labl, KILL icc);
 9274 
 9275   size(4); // Assuming no NOP inserted.
 9276   ins_cost(BRANCH_COST);
 9277   format %{ &quot;CWB$cmp  $op1,$op2,$labl\t! int&quot; %}
 9278   ins_encode %{
 9279     Label* L = $labl$$label;
 9280     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9281     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, $op2$$Register, *L);
 9282   %}
 9283   ins_short_branch(1);
 9284   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9285   ins_pipe(cbcond_reg_reg);
 9286 %}
 9287 
 9288 instruct cmpI_imm_branch_short(cmpOp cmp, iRegI op1, immI5 op2, label labl, flagsReg icc) %{
 9289   match(If cmp (CmpI op1 op2));
 9290   predicate(UseCBCond);
 9291   effect(USE labl, KILL icc);
 9292 
 9293   size(4); // Assuming no NOP inserted.
 9294   ins_cost(BRANCH_COST);
 9295   format %{ &quot;CWB$cmp  $op1,$op2,$labl\t! int&quot; %}
 9296   ins_encode %{
 9297     Label* L = $labl$$label;
 9298     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9299     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, $op2$$constant, *L);
 9300   %}
 9301   ins_short_branch(1);
 9302   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9303   ins_pipe(cbcond_reg_imm);
 9304 %}
 9305 
 9306 instruct cmpU_reg_branch_short(cmpOpU cmp, iRegI op1, iRegI op2, label labl, flagsRegU icc) %{
 9307   match(If cmp (CmpU op1 op2));
 9308   predicate(UseCBCond);
 9309   effect(USE labl, KILL icc);
 9310 
 9311   size(4); // Assuming no NOP inserted.
 9312   ins_cost(BRANCH_COST);
 9313   format %{ &quot;CWB$cmp $op1,$op2,$labl\t! unsigned&quot; %}
 9314   ins_encode %{
 9315     Label* L = $labl$$label;
 9316     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9317     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, $op2$$Register, *L);
 9318   %}
 9319   ins_short_branch(1);
 9320   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9321   ins_pipe(cbcond_reg_reg);
 9322 %}
 9323 
 9324 instruct cmpU_imm_branch_short(cmpOpU cmp, iRegI op1, immI5 op2, label labl, flagsRegU icc) %{
 9325   match(If cmp (CmpU op1 op2));
 9326   predicate(UseCBCond);
 9327   effect(USE labl, KILL icc);
 9328 
 9329   size(4); // Assuming no NOP inserted.
 9330   ins_cost(BRANCH_COST);
 9331   format %{ &quot;CWB$cmp $op1,$op2,$labl\t! unsigned&quot; %}
 9332   ins_encode %{
 9333     Label* L = $labl$$label;
 9334     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9335     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, $op2$$constant, *L);
 9336   %}
 9337   ins_short_branch(1);
 9338   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9339   ins_pipe(cbcond_reg_imm);
 9340 %}
 9341 
 9342 instruct cmpUL_reg_branch_short(cmpOpU cmp, iRegL op1, iRegL op2, label labl, flagsRegUL xcc) %{
 9343   match(If cmp (CmpUL op1 op2));
 9344   predicate(UseCBCond);
 9345   effect(USE labl, KILL xcc);
 9346 
 9347   size(4);
 9348   ins_cost(BRANCH_COST);
 9349   format %{ &quot;CXB$cmp  $op1,$op2,$labl\t! unsigned long&quot; %}
 9350   ins_encode %{
 9351     Label* L = $labl$$label;
 9352     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9353     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::xcc, $op1$$Register, $op2$$Register, *L);
 9354   %}
 9355   ins_short_branch(1);
 9356   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9357   ins_pipe(cbcond_reg_reg);
 9358 %}
 9359 
 9360 instruct cmpUL_imm_branch_short(cmpOpU cmp, iRegL op1, immL5 op2, label labl, flagsRegUL xcc) %{
 9361   match(If cmp (CmpUL op1 op2));
 9362   predicate(UseCBCond);
 9363   effect(USE labl, KILL xcc);
 9364 
 9365   size(4);
 9366   ins_cost(BRANCH_COST);
 9367   format %{ &quot;CXB$cmp  $op1,$op2,$labl\t! unsigned long&quot; %}
 9368   ins_encode %{
 9369     Label* L = $labl$$label;
 9370     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9371     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::xcc, $op1$$Register, $op2$$constant, *L);
 9372   %}
 9373   ins_short_branch(1);
 9374   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9375   ins_pipe(cbcond_reg_imm);
 9376 %}
 9377 
 9378 instruct cmpL_reg_branch_short(cmpOp cmp, iRegL op1, iRegL op2, label labl, flagsRegL xcc) %{
 9379   match(If cmp (CmpL op1 op2));
 9380   predicate(UseCBCond);
 9381   effect(USE labl, KILL xcc);
 9382 
 9383   size(4); // Assuming no NOP inserted.
 9384   ins_cost(BRANCH_COST);
 9385   format %{ &quot;CXB$cmp  $op1,$op2,$labl\t! long&quot; %}
 9386   ins_encode %{
 9387     Label* L = $labl$$label;
 9388     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9389     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::xcc, $op1$$Register, $op2$$Register, *L);
 9390   %}
 9391   ins_short_branch(1);
 9392   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9393   ins_pipe(cbcond_reg_reg);
 9394 %}
 9395 
 9396 instruct cmpL_imm_branch_short(cmpOp cmp, iRegL op1, immL5 op2, label labl, flagsRegL xcc) %{
 9397   match(If cmp (CmpL op1 op2));
 9398   predicate(UseCBCond);
 9399   effect(USE labl, KILL xcc);
 9400 
 9401   size(4); // Assuming no NOP inserted.
 9402   ins_cost(BRANCH_COST);
 9403   format %{ &quot;CXB$cmp  $op1,$op2,$labl\t! long&quot; %}
 9404   ins_encode %{
 9405     Label* L = $labl$$label;
 9406     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9407     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::xcc, $op1$$Register, $op2$$constant, *L);
 9408   %}
 9409   ins_short_branch(1);
 9410   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9411   ins_pipe(cbcond_reg_imm);
 9412 %}
 9413 
 9414 // Compare Pointers and branch
 9415 instruct cmpP_reg_branch_short(cmpOpP cmp, iRegP op1, iRegP op2, label labl, flagsRegP pcc) %{
 9416   match(If cmp (CmpP op1 op2));
 9417   predicate(UseCBCond);
 9418   effect(USE labl, KILL pcc);
 9419 
 9420   size(4); // Assuming no NOP inserted.
 9421   ins_cost(BRANCH_COST);
 9422   format %{ &quot;CXB$cmp $op1,$op2,$labl\t! ptr&quot; %}
 9423   ins_encode %{
 9424     Label* L = $labl$$label;
 9425     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9426     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::ptr_cc, $op1$$Register, $op2$$Register, *L);
 9427   %}
 9428   ins_short_branch(1);
 9429   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9430   ins_pipe(cbcond_reg_reg);
 9431 %}
 9432 
 9433 instruct cmpP_null_branch_short(cmpOpP cmp, iRegP op1, immP0 null, label labl, flagsRegP pcc) %{
 9434   match(If cmp (CmpP op1 null));
 9435   predicate(UseCBCond);
 9436   effect(USE labl, KILL pcc);
 9437 
 9438   size(4); // Assuming no NOP inserted.
 9439   ins_cost(BRANCH_COST);
 9440   format %{ &quot;CXB$cmp $op1,0,$labl\t! ptr&quot; %}
 9441   ins_encode %{
 9442     Label* L = $labl$$label;
 9443     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9444     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::ptr_cc, $op1$$Register, G0, *L);
 9445   %}
 9446   ins_short_branch(1);
 9447   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9448   ins_pipe(cbcond_reg_reg);
 9449 %}
 9450 
 9451 instruct cmpN_reg_branch_short(cmpOp cmp, iRegN op1, iRegN op2, label labl, flagsReg icc) %{
 9452   match(If cmp (CmpN op1 op2));
 9453   predicate(UseCBCond);
 9454   effect(USE labl, KILL icc);
 9455 
 9456   size(4); // Assuming no NOP inserted.
 9457   ins_cost(BRANCH_COST);
 9458   format %{ &quot;CWB$cmp  $op1,$op2,$labl\t! compressed ptr&quot; %}
 9459   ins_encode %{
 9460     Label* L = $labl$$label;
 9461     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9462     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, $op2$$Register, *L);
 9463   %}
 9464   ins_short_branch(1);
 9465   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9466   ins_pipe(cbcond_reg_reg);
 9467 %}
 9468 
 9469 instruct cmpN_null_branch_short(cmpOp cmp, iRegN op1, immN0 null, label labl, flagsReg icc) %{
 9470   match(If cmp (CmpN op1 null));
 9471   predicate(UseCBCond);
 9472   effect(USE labl, KILL icc);
 9473 
 9474   size(4); // Assuming no NOP inserted.
 9475   ins_cost(BRANCH_COST);
 9476   format %{ &quot;CWB$cmp  $op1,0,$labl\t! compressed ptr&quot; %}
 9477   ins_encode %{
 9478     Label* L = $labl$$label;
 9479     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9480     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, G0, *L);
 9481   %}
 9482   ins_short_branch(1);
 9483   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9484   ins_pipe(cbcond_reg_reg);
 9485 %}
 9486 
 9487 // Loop back branch
 9488 instruct cmpI_reg_branchLoopEnd_short(cmpOp cmp, iRegI op1, iRegI op2, label labl, flagsReg icc) %{
 9489   match(CountedLoopEnd cmp (CmpI op1 op2));
 9490   predicate(UseCBCond);
 9491   effect(USE labl, KILL icc);
 9492 
 9493   size(4); // Assuming no NOP inserted.
 9494   ins_cost(BRANCH_COST);
 9495   format %{ &quot;CWB$cmp  $op1,$op2,$labl\t! Loop end&quot; %}
 9496   ins_encode %{
 9497     Label* L = $labl$$label;
 9498     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9499     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, $op2$$Register, *L);
 9500   %}
 9501   ins_short_branch(1);
 9502   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9503   ins_pipe(cbcond_reg_reg);
 9504 %}
 9505 
 9506 instruct cmpI_imm_branchLoopEnd_short(cmpOp cmp, iRegI op1, immI5 op2, label labl, flagsReg icc) %{
 9507   match(CountedLoopEnd cmp (CmpI op1 op2));
 9508   predicate(UseCBCond);
 9509   effect(USE labl, KILL icc);
 9510 
 9511   size(4); // Assuming no NOP inserted.
 9512   ins_cost(BRANCH_COST);
 9513   format %{ &quot;CWB$cmp  $op1,$op2,$labl\t! Loop end&quot; %}
 9514   ins_encode %{
 9515     Label* L = $labl$$label;
 9516     assert(__ use_cbcond(*L), &quot;back to back cbcond&quot;);
 9517     __ cbcond((Assembler::Condition)($cmp$$cmpcode), Assembler::icc, $op1$$Register, $op2$$constant, *L);
 9518   %}
 9519   ins_short_branch(1);
 9520   ins_avoid_back_to_back(AVOID_BEFORE_AND_AFTER);
 9521   ins_pipe(cbcond_reg_imm);
 9522 %}
 9523 
 9524 // Branch-on-register tests all 64 bits.  We assume that values
 9525 // in 64-bit registers always remains zero or sign extended
 9526 // unless our code munges the high bits.  Interrupts can chop
 9527 // the high order bits to zero or sign at any time.
 9528 instruct branchCon_regI(cmpOp_reg cmp, iRegI op1, immI0 zero, label labl) %{
 9529   match(If cmp (CmpI op1 zero));
 9530   predicate(can_branch_register(_kids[0]-&gt;_leaf, _kids[1]-&gt;_leaf));
 9531   effect(USE labl);
 9532 
 9533   size(8);
 9534   ins_cost(BRANCH_COST);
 9535   format %{ &quot;BR$cmp   $op1,$labl&quot; %}
 9536   ins_encode( enc_bpr( labl, cmp, op1 ) );
 9537   ins_avoid_back_to_back(AVOID_BEFORE);
 9538   ins_pipe(br_reg);
 9539 %}
 9540 
 9541 instruct branchCon_regP(cmpOp_reg cmp, iRegP op1, immP0 null, label labl) %{
 9542   match(If cmp (CmpP op1 null));
 9543   predicate(can_branch_register(_kids[0]-&gt;_leaf, _kids[1]-&gt;_leaf));
 9544   effect(USE labl);
 9545 
 9546   size(8);
 9547   ins_cost(BRANCH_COST);
 9548   format %{ &quot;BR$cmp   $op1,$labl&quot; %}
 9549   ins_encode( enc_bpr( labl, cmp, op1 ) );
 9550   ins_avoid_back_to_back(AVOID_BEFORE);
 9551   ins_pipe(br_reg);
 9552 %}
 9553 
 9554 instruct branchCon_regL(cmpOp_reg cmp, iRegL op1, immL0 zero, label labl) %{
 9555   match(If cmp (CmpL op1 zero));
 9556   predicate(can_branch_register(_kids[0]-&gt;_leaf, _kids[1]-&gt;_leaf));
 9557   effect(USE labl);
 9558 
 9559   size(8);
 9560   ins_cost(BRANCH_COST);
 9561   format %{ &quot;BR$cmp   $op1,$labl&quot; %}
 9562   ins_encode( enc_bpr( labl, cmp, op1 ) );
 9563   ins_avoid_back_to_back(AVOID_BEFORE);
 9564   ins_pipe(br_reg);
 9565 %}
 9566 
 9567 
 9568 // ============================================================================
 9569 // Long Compare
 9570 //
 9571 // Currently we hold longs in 2 registers.  Comparing such values efficiently
 9572 // is tricky.  The flavor of compare used depends on whether we are testing
 9573 // for LT, LE, or EQ.  For a simple LT test we can check just the sign bit.
 9574 // The GE test is the negated LT test.  The LE test can be had by commuting
 9575 // the operands (yielding a GE test) and then negating; negate again for the
 9576 // GT test.  The EQ test is done by ORcc&#39;ing the high and low halves, and the
 9577 // NE test is negated from that.
 9578 
 9579 // Due to a shortcoming in the ADLC, it mixes up expressions like:
 9580 // (foo (CmpI (CmpL X Y) 0)) and (bar (CmpI (CmpL X 0L) 0)).  Note the
 9581 // difference between &#39;Y&#39; and &#39;0L&#39;.  The tree-matches for the CmpI sections
 9582 // are collapsed internally in the ADLC&#39;s dfa-gen code.  The match for
 9583 // (CmpI (CmpL X Y) 0) is silently replaced with (CmpI (CmpL X 0L) 0) and the
 9584 // foo match ends up with the wrong leaf.  One fix is to not match both
 9585 // reg-reg and reg-zero forms of long-compare.  This is unfortunate because
 9586 // both forms beat the trinary form of long-compare and both are very useful
 9587 // on Intel which has so few registers.
 9588 
 9589 instruct branchCon_long(cmpOp cmp, flagsRegL xcc, label labl) %{
 9590   match(If cmp xcc);
 9591   effect(USE labl);
 9592 
 9593   size(8);
 9594   ins_cost(BRANCH_COST);
 9595   format %{ &quot;BP$cmp   $xcc,$labl&quot; %}
 9596   ins_encode %{
 9597     Label* L = $labl$$label;
 9598     Assembler::Predict predict_taken =
 9599       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9600 
 9601     __ bp( (Assembler::Condition)($cmp$$cmpcode), false, Assembler::xcc, predict_taken, *L);
 9602     __ delayed()-&gt;nop();
 9603   %}
 9604   ins_avoid_back_to_back(AVOID_BEFORE);
 9605   ins_pipe(br_cc);
 9606 %}
 9607 
 9608 instruct branchConU_long(cmpOpU cmp, flagsRegUL xcc, label labl) %{
 9609   match(If cmp xcc);
 9610   effect(USE labl);
 9611 
 9612   size(8);
 9613   ins_cost(BRANCH_COST);
 9614   format %{ &quot;BP$cmp   $xcc,$labl&quot; %}
 9615   ins_encode %{
 9616     Label* L = $labl$$label;
 9617     Assembler::Predict predict_taken =
 9618       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 9619 
 9620     __ bp((Assembler::Condition)($cmp$$cmpcode), false, Assembler::xcc, predict_taken, *L);
 9621     __ delayed()-&gt;nop();
 9622   %}
 9623   ins_avoid_back_to_back(AVOID_BEFORE);
 9624   ins_pipe(br_cc);
 9625 %}
 9626 
 9627 // Manifest a CmpL3 result in an integer register.  Very painful.
 9628 // This is the test to avoid.
 9629 instruct cmpL3_reg_reg(iRegI dst, iRegL src1, iRegL src2, flagsReg ccr ) %{
 9630   match(Set dst (CmpL3 src1 src2) );
 9631   effect( KILL ccr );
 9632   ins_cost(6*DEFAULT_COST);
 9633   size(24);
 9634   format %{ &quot;CMP    $src1,$src2\t\t! long\n&quot;
 9635           &quot;\tBLT,a,pn done\n&quot;
 9636           &quot;\tMOV    -1,$dst\t! delay slot\n&quot;
 9637           &quot;\tBGT,a,pn done\n&quot;
 9638           &quot;\tMOV    1,$dst\t! delay slot\n&quot;
 9639           &quot;\tCLR    $dst\n&quot;
 9640     &quot;done:&quot;     %}
 9641   ins_encode( cmpl_flag(src1,src2,dst) );
 9642   ins_pipe(cmpL_reg);
 9643 %}
 9644 
 9645 // Conditional move
 9646 instruct cmovLL_reg(cmpOp cmp, flagsRegL xcc, iRegL dst, iRegL src) %{
 9647   match(Set dst (CMoveL (Binary cmp xcc) (Binary dst src)));
 9648   ins_cost(150);
 9649   format %{ &quot;MOV$cmp  $xcc,$src,$dst\t! long&quot; %}
 9650   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::xcc)) );
 9651   ins_pipe(ialu_reg);
 9652 %}
 9653 
 9654 instruct cmovLL_imm(cmpOp cmp, flagsRegL xcc, iRegL dst, immL0 src) %{
 9655   match(Set dst (CMoveL (Binary cmp xcc) (Binary dst src)));
 9656   ins_cost(140);
 9657   format %{ &quot;MOV$cmp  $xcc,$src,$dst\t! long&quot; %}
 9658   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::xcc)) );
 9659   ins_pipe(ialu_imm);
 9660 %}
 9661 
 9662 instruct cmovIL_reg(cmpOp cmp, flagsRegL xcc, iRegI dst, iRegI src) %{
 9663   match(Set dst (CMoveI (Binary cmp xcc) (Binary dst src)));
 9664   ins_cost(150);
 9665   format %{ &quot;MOV$cmp  $xcc,$src,$dst&quot; %}
 9666   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::xcc)) );
 9667   ins_pipe(ialu_reg);
 9668 %}
 9669 
 9670 instruct cmovIL_imm(cmpOp cmp, flagsRegL xcc, iRegI dst, immI11 src) %{
 9671   match(Set dst (CMoveI (Binary cmp xcc) (Binary dst src)));
 9672   ins_cost(140);
 9673   format %{ &quot;MOV$cmp  $xcc,$src,$dst&quot; %}
 9674   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::xcc)) );
 9675   ins_pipe(ialu_imm);
 9676 %}
 9677 
 9678 instruct cmovNL_reg(cmpOp cmp, flagsRegL xcc, iRegN dst, iRegN src) %{
 9679   match(Set dst (CMoveN (Binary cmp xcc) (Binary dst src)));
 9680   ins_cost(150);
 9681   format %{ &quot;MOV$cmp  $xcc,$src,$dst&quot; %}
 9682   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::xcc)) );
 9683   ins_pipe(ialu_reg);
 9684 %}
 9685 
 9686 instruct cmovPL_reg(cmpOp cmp, flagsRegL xcc, iRegP dst, iRegP src) %{
 9687   match(Set dst (CMoveP (Binary cmp xcc) (Binary dst src)));
 9688   ins_cost(150);
 9689   format %{ &quot;MOV$cmp  $xcc,$src,$dst&quot; %}
 9690   ins_encode( enc_cmov_reg(cmp,dst,src, (Assembler::xcc)) );
 9691   ins_pipe(ialu_reg);
 9692 %}
 9693 
 9694 instruct cmovPL_imm(cmpOp cmp, flagsRegL xcc, iRegP dst, immP0 src) %{
 9695   match(Set dst (CMoveP (Binary cmp xcc) (Binary dst src)));
 9696   ins_cost(140);
 9697   format %{ &quot;MOV$cmp  $xcc,$src,$dst&quot; %}
 9698   ins_encode( enc_cmov_imm(cmp,dst,src, (Assembler::xcc)) );
 9699   ins_pipe(ialu_imm);
 9700 %}
 9701 
 9702 instruct cmovFL_reg(cmpOp cmp, flagsRegL xcc, regF dst, regF src) %{
 9703   match(Set dst (CMoveF (Binary cmp xcc) (Binary dst src)));
 9704   ins_cost(150);
 9705   opcode(0x101);
 9706   format %{ &quot;FMOVS$cmp $xcc,$src,$dst&quot; %}
 9707   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::xcc)) );
 9708   ins_pipe(int_conditional_float_move);
 9709 %}
 9710 
 9711 instruct cmovDL_reg(cmpOp cmp, flagsRegL xcc, regD dst, regD src) %{
 9712   match(Set dst (CMoveD (Binary cmp xcc) (Binary dst src)));
 9713   ins_cost(150);
 9714   opcode(0x102);
 9715   format %{ &quot;FMOVD$cmp $xcc,$src,$dst&quot; %}
 9716   ins_encode( enc_cmovf_reg(cmp,dst,src, (Assembler::xcc)) );
 9717   ins_pipe(int_conditional_float_move);
 9718 %}
 9719 
 9720 // ============================================================================
 9721 // Safepoint Instruction
 9722 instruct safePoint_poll(iRegP poll) %{
 9723   match(SafePoint poll);
 9724   effect(USE poll);
 9725 
 9726   size(4);
 9727   format %{ &quot;LDX    [$poll],R_G0\t! Safepoint: poll for GC&quot; %}
 9728   ins_encode %{
 9729     __ relocate(relocInfo::poll_type);
 9730     __ ld_ptr($poll$$Register, 0, G0);
 9731   %}
 9732   ins_pipe(loadPollP);
 9733 %}
 9734 
 9735 // ============================================================================
 9736 // Call Instructions
 9737 // Call Java Static Instruction
 9738 instruct CallStaticJavaDirect( method meth ) %{
 9739   match(CallStaticJava);
 9740   predicate(! ((CallStaticJavaNode*)n)-&gt;is_method_handle_invoke());
 9741   effect(USE meth);
 9742 
 9743   size(8);
 9744   ins_cost(CALL_COST);
 9745   format %{ &quot;CALL,static  ; NOP ==&gt; &quot; %}
 9746   ins_encode( Java_Static_Call( meth ), call_epilog );
 9747   ins_avoid_back_to_back(AVOID_BEFORE);
 9748   ins_pipe(simple_call);
 9749 %}
 9750 
 9751 // Call Java Static Instruction (method handle version)
 9752 instruct CallStaticJavaHandle(method meth, l7RegP l7_mh_SP_save) %{
 9753   match(CallStaticJava);
 9754   predicate(((CallStaticJavaNode*)n)-&gt;is_method_handle_invoke());
 9755   effect(USE meth, KILL l7_mh_SP_save);
 9756 
 9757   size(16);
 9758   ins_cost(CALL_COST);
 9759   format %{ &quot;CALL,static/MethodHandle&quot; %}
 9760   ins_encode(preserve_SP, Java_Static_Call(meth), restore_SP, call_epilog);
 9761   ins_pipe(simple_call);
 9762 %}
 9763 
 9764 // Call Java Dynamic Instruction
 9765 instruct CallDynamicJavaDirect( method meth ) %{
 9766   match(CallDynamicJava);
 9767   effect(USE meth);
 9768 
 9769   ins_cost(CALL_COST);
 9770   format %{ &quot;SET    (empty),R_G5\n\t&quot;
 9771             &quot;CALL,dynamic  ; NOP ==&gt; &quot; %}
 9772   ins_encode( Java_Dynamic_Call( meth ), call_epilog );
 9773   ins_pipe(call);
 9774 %}
 9775 
 9776 // Call Runtime Instruction
 9777 instruct CallRuntimeDirect(method meth, l7RegP l7) %{
 9778   match(CallRuntime);
 9779   effect(USE meth, KILL l7);
 9780   ins_cost(CALL_COST);
 9781   format %{ &quot;CALL,runtime&quot; %}
 9782   ins_encode( Java_To_Runtime( meth ),
 9783               call_epilog, adjust_long_from_native_call );
 9784   ins_avoid_back_to_back(AVOID_BEFORE);
 9785   ins_pipe(simple_call);
 9786 %}
 9787 
 9788 // Call runtime without safepoint - same as CallRuntime
 9789 instruct CallLeafDirect(method meth, l7RegP l7) %{
 9790   match(CallLeaf);
 9791   effect(USE meth, KILL l7);
 9792   ins_cost(CALL_COST);
 9793   format %{ &quot;CALL,runtime leaf&quot; %}
 9794   ins_encode( Java_To_Runtime( meth ),
 9795               call_epilog,
 9796               adjust_long_from_native_call );
 9797   ins_avoid_back_to_back(AVOID_BEFORE);
 9798   ins_pipe(simple_call);
 9799 %}
 9800 
 9801 // Call runtime without safepoint - same as CallLeaf
 9802 instruct CallLeafNoFPDirect(method meth, l7RegP l7) %{
 9803   match(CallLeafNoFP);
 9804   effect(USE meth, KILL l7);
 9805   ins_cost(CALL_COST);
 9806   format %{ &quot;CALL,runtime leaf nofp&quot; %}
 9807   ins_encode( Java_To_Runtime( meth ),
 9808               call_epilog,
 9809               adjust_long_from_native_call );
 9810   ins_avoid_back_to_back(AVOID_BEFORE);
 9811   ins_pipe(simple_call);
 9812 %}
 9813 
 9814 // Tail Call; Jump from runtime stub to Java code.
 9815 // Also known as an &#39;interprocedural jump&#39;.
 9816 // Target of jump will eventually return to caller.
 9817 // TailJump below removes the return address.
 9818 instruct TailCalljmpInd(g3RegP jump_target, inline_cache_regP method_oop) %{
 9819   match(TailCall jump_target method_oop );
 9820 
 9821   ins_cost(CALL_COST);
 9822   format %{ &quot;Jmp     $jump_target  ; NOP \t! $method_oop holds method oop&quot; %}
 9823   ins_encode(form_jmpl(jump_target));
 9824   ins_avoid_back_to_back(AVOID_BEFORE);
 9825   ins_pipe(tail_call);
 9826 %}
 9827 
 9828 
 9829 // Return Instruction
 9830 instruct Ret() %{
 9831   match(Return);
 9832 
 9833   // The epilogue node did the ret already.
 9834   size(0);
 9835   format %{ &quot;! return&quot; %}
 9836   ins_encode();
 9837   ins_pipe(empty);
 9838 %}
 9839 
 9840 
 9841 // Tail Jump; remove the return address; jump to target.
 9842 // TailCall above leaves the return address around.
 9843 // TailJump is used in only one place, the rethrow_Java stub (fancy_jump=2).
 9844 // ex_oop (Exception Oop) is needed in %o0 at the jump. As there would be a
 9845 // &quot;restore&quot; before this instruction (in Epilogue), we need to materialize it
 9846 // in %i0.
 9847 instruct tailjmpInd(g1RegP jump_target, i0RegP ex_oop) %{
 9848   match( TailJump jump_target ex_oop );
 9849   ins_cost(CALL_COST);
 9850   format %{ &quot;! discard R_O7\n\t&quot;
 9851             &quot;Jmp     $jump_target  ; ADD O7,8,O1 \t! $ex_oop holds exc. oop&quot; %}
 9852   ins_encode(form_jmpl_set_exception_pc(jump_target));
 9853   // opcode(Assembler::jmpl_op3, Assembler::arith_op);
 9854   // The hack duplicates the exception oop into G3, so that CreateEx can use it there.
 9855   // ins_encode( form3_rs1_simm13_rd( jump_target, 0x00, R_G0 ), move_return_pc_to_o1() );
 9856   ins_avoid_back_to_back(AVOID_BEFORE);
 9857   ins_pipe(tail_call);
 9858 %}
 9859 
 9860 // Create exception oop: created by stack-crawling runtime code.
 9861 // Created exception is now available to this handler, and is setup
 9862 // just prior to jumping to this handler.  No code emitted.
 9863 instruct CreateException( o0RegP ex_oop )
 9864 %{
 9865   match(Set ex_oop (CreateEx));
 9866   ins_cost(0);
 9867 
 9868   size(0);
 9869   // use the following format syntax
 9870   format %{ &quot;! exception oop is in R_O0; no code emitted&quot; %}
 9871   ins_encode();
 9872   ins_pipe(empty);
 9873 %}
 9874 
 9875 
 9876 // Rethrow exception:
 9877 // The exception oop will come in the first argument position.
 9878 // Then JUMP (not call) to the rethrow stub code.
 9879 instruct RethrowException()
 9880 %{
 9881   match(Rethrow);
 9882   ins_cost(CALL_COST);
 9883 
 9884   // use the following format syntax
 9885   format %{ &quot;Jmp    rethrow_stub&quot; %}
 9886   ins_encode(enc_rethrow);
 9887   ins_avoid_back_to_back(AVOID_BEFORE);
 9888   ins_pipe(tail_call);
 9889 %}
 9890 
 9891 
 9892 // Die now
 9893 instruct ShouldNotReachHere( )
 9894 %{
 9895   match(Halt);
 9896   ins_cost(CALL_COST);
 9897 
 9898   size(4);
 9899   // Use the following format syntax
 9900   format %{ &quot;ILLTRAP   ; ShouldNotReachHere&quot; %}
 9901   ins_encode( form2_illtrap() );
 9902   ins_pipe(tail_call);
 9903 %}
 9904 
 9905 // ============================================================================
 9906 // The 2nd slow-half of a subtype check.  Scan the subklass&#39;s 2ndary superklass
 9907 // array for an instance of the superklass.  Set a hidden internal cache on a
 9908 // hit (cache is checked with exposed code in gen_subtype_check()).  Return
 9909 // not zero for a miss or zero for a hit.  The encoding ALSO sets flags.
 9910 instruct partialSubtypeCheck( o0RegP index, o1RegP sub, o2RegP super, flagsRegP pcc, o7RegP o7 ) %{
 9911   match(Set index (PartialSubtypeCheck sub super));
 9912   effect( KILL pcc, KILL o7 );
 9913   ins_cost(DEFAULT_COST*10);
 9914   format %{ &quot;CALL   PartialSubtypeCheck\n\tNOP&quot; %}
 9915   ins_encode( enc_PartialSubtypeCheck() );
 9916   ins_avoid_back_to_back(AVOID_BEFORE);
 9917   ins_pipe(partial_subtype_check_pipe);
 9918 %}
 9919 
 9920 instruct partialSubtypeCheck_vs_zero( flagsRegP pcc, o1RegP sub, o2RegP super, immP0 zero, o0RegP idx, o7RegP o7 ) %{
 9921   match(Set pcc (CmpP (PartialSubtypeCheck sub super) zero));
 9922   effect( KILL idx, KILL o7 );
 9923   ins_cost(DEFAULT_COST*10);
 9924   format %{ &quot;CALL   PartialSubtypeCheck\n\tNOP\t# (sets condition codes)&quot; %}
 9925   ins_encode( enc_PartialSubtypeCheck() );
 9926   ins_avoid_back_to_back(AVOID_BEFORE);
 9927   ins_pipe(partial_subtype_check_pipe);
 9928 %}
 9929 
 9930 
 9931 // ============================================================================
 9932 // inlined locking and unlocking
 9933 
 9934 instruct cmpFastLock(flagsRegP pcc, iRegP object, o1RegP box, iRegP scratch2, o7RegP scratch ) %{
 9935   match(Set pcc (FastLock object box));
 9936 
 9937   effect(TEMP scratch2, USE_KILL box, KILL scratch);
 9938   ins_cost(100);
 9939 
 9940   format %{ &quot;FASTLOCK  $object,$box\t! kills $box,$scratch,$scratch2&quot; %}
 9941   ins_encode( Fast_Lock(object, box, scratch, scratch2) );
 9942   ins_pipe(long_memory_op);
 9943 %}
 9944 
 9945 
 9946 instruct cmpFastUnlock(flagsRegP pcc, iRegP object, o1RegP box, iRegP scratch2, o7RegP scratch ) %{
 9947   match(Set pcc (FastUnlock object box));
 9948   effect(TEMP scratch2, USE_KILL box, KILL scratch);
 9949   ins_cost(100);
 9950 
 9951   format %{ &quot;FASTUNLOCK  $object,$box\t! kills $box,$scratch,$scratch2&quot; %}
 9952   ins_encode( Fast_Unlock(object, box, scratch, scratch2) );
 9953   ins_pipe(long_memory_op);
 9954 %}
 9955 
 9956 // The encodings are generic.
 9957 instruct clear_array(iRegX cnt, iRegP base, iRegX temp, Universe dummy, flagsReg ccr) %{
 9958   predicate(!use_block_zeroing(n-&gt;in(2)) );
 9959   match(Set dummy (ClearArray cnt base));
 9960   effect(TEMP temp, KILL ccr);
 9961   ins_cost(300);
 9962   format %{ &quot;MOV    $cnt,$temp\n&quot;
 9963     &quot;loop:   SUBcc  $temp,8,$temp\t! Count down a dword of bytes\n&quot;
 9964     &quot;        BRge   loop\t\t! Clearing loop\n&quot;
 9965     &quot;        STX    G0,[$base+$temp]\t! delay slot&quot; %}
 9966 
 9967   ins_encode %{
 9968     // Compiler ensures base is doubleword aligned and cnt is count of doublewords
 9969     Register nof_bytes_arg    = $cnt$$Register;
 9970     Register nof_bytes_tmp    = $temp$$Register;
 9971     Register base_pointer_arg = $base$$Register;
 9972 
 9973     Label loop;
 9974     __ mov(nof_bytes_arg, nof_bytes_tmp);
 9975 
 9976     // Loop and clear, walking backwards through the array.
 9977     // nof_bytes_tmp (if &gt;0) is always the number of bytes to zero
 9978     __ bind(loop);
 9979     __ deccc(nof_bytes_tmp, 8);
 9980     __ br(Assembler::greaterEqual, true, Assembler::pt, loop);
 9981     __ delayed()-&gt; stx(G0, base_pointer_arg, nof_bytes_tmp);
 9982     // %%%% this mini-loop must not cross a cache boundary!
 9983   %}
 9984   ins_pipe(long_memory_op);
 9985 %}
 9986 
 9987 instruct clear_array_bis(g1RegX cnt, o0RegP base, Universe dummy, flagsReg ccr) %{
 9988   predicate(use_block_zeroing(n-&gt;in(2)));
 9989   match(Set dummy (ClearArray cnt base));
 9990   effect(USE_KILL cnt, USE_KILL base, KILL ccr);
 9991   ins_cost(300);
 9992   format %{ &quot;CLEAR  [$base, $cnt]\t! ClearArray&quot; %}
 9993 
 9994   ins_encode %{
 9995 
 9996     assert(MinObjAlignmentInBytes &gt;= BytesPerLong, &quot;need alternate implementation&quot;);
 9997     Register to    = $base$$Register;
 9998     Register count = $cnt$$Register;
 9999 
10000     Label Ldone;
10001     __ nop(); // Separate short branches
10002     // Use BIS for zeroing (temp is not used).
10003     __ bis_zeroing(to, count, G0, Ldone);
10004     __ bind(Ldone);
10005 
10006   %}
10007   ins_pipe(long_memory_op);
10008 %}
10009 
10010 instruct clear_array_bis_2(g1RegX cnt, o0RegP base, iRegX tmp, Universe dummy, flagsReg ccr) %{
10011   predicate(use_block_zeroing(n-&gt;in(2)) &amp;&amp; !Assembler::is_simm13((int)BlockZeroingLowLimit));
10012   match(Set dummy (ClearArray cnt base));
10013   effect(TEMP tmp, USE_KILL cnt, USE_KILL base, KILL ccr);
10014   ins_cost(300);
10015   format %{ &quot;CLEAR  [$base, $cnt]\t! ClearArray&quot; %}
10016 
10017   ins_encode %{
10018 
10019     assert(MinObjAlignmentInBytes &gt;= BytesPerLong, &quot;need alternate implementation&quot;);
10020     Register to    = $base$$Register;
10021     Register count = $cnt$$Register;
10022     Register temp  = $tmp$$Register;
10023 
10024     Label Ldone;
10025     __ nop(); // Separate short branches
10026     // Use BIS for zeroing
10027     __ bis_zeroing(to, count, temp, Ldone);
10028     __ bind(Ldone);
10029 
10030   %}
10031   ins_pipe(long_memory_op);
10032 %}
10033 
10034 instruct string_compareL(o0RegP str1, o1RegP str2, g3RegI cnt1, g4RegI cnt2, notemp_iRegI result,
10035                          o7RegI tmp, flagsReg ccr) %{
10036   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10037   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10038   effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ccr, KILL tmp);
10039   ins_cost(300);
10040   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp&quot; %}
10041   ins_encode %{
10042     __ string_compare($str1$$Register, $str2$$Register,
10043                       $cnt1$$Register, $cnt2$$Register,
10044                       $tmp$$Register, $tmp$$Register,
10045                       $result$$Register, StrIntrinsicNode::LL);
10046   %}
10047   ins_pipe(long_memory_op);
10048 %}
10049 
10050 instruct string_compareU(o0RegP str1, o1RegP str2, g3RegI cnt1, g4RegI cnt2, notemp_iRegI result,
10051                          o7RegI tmp, flagsReg ccr) %{
10052   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
10053   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10054   effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ccr, KILL tmp);
10055   ins_cost(300);
10056   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp&quot; %}
10057   ins_encode %{
10058     __ string_compare($str1$$Register, $str2$$Register,
10059                       $cnt1$$Register, $cnt2$$Register,
10060                       $tmp$$Register, $tmp$$Register,
10061                       $result$$Register, StrIntrinsicNode::UU);
10062   %}
10063   ins_pipe(long_memory_op);
10064 %}
10065 
10066 instruct string_compareLU(o0RegP str1, o1RegP str2, g3RegI cnt1, g4RegI cnt2, notemp_iRegI result,
10067                           o7RegI tmp1, g1RegI tmp2, flagsReg ccr) %{
10068   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
10069   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10070   effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ccr, KILL tmp1, KILL tmp2);
10071   ins_cost(300);
10072   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1,$tmp2&quot; %}
10073   ins_encode %{
10074     __ string_compare($str1$$Register, $str2$$Register,
10075                       $cnt1$$Register, $cnt2$$Register,
10076                       $tmp1$$Register, $tmp2$$Register,
10077                       $result$$Register, StrIntrinsicNode::LU);
10078   %}
10079   ins_pipe(long_memory_op);
10080 %}
10081 
10082 instruct string_compareUL(o0RegP str1, o1RegP str2, g3RegI cnt1, g4RegI cnt2, notemp_iRegI result,
10083                           o7RegI tmp1, g1RegI tmp2, flagsReg ccr) %{
10084   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
10085   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10086   effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ccr, KILL tmp1, KILL tmp2);
10087   ins_cost(300);
10088   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1,$tmp2&quot; %}
10089   ins_encode %{
10090     __ string_compare($str2$$Register, $str1$$Register,
10091                       $cnt2$$Register, $cnt1$$Register,
10092                       $tmp1$$Register, $tmp2$$Register,
10093                       $result$$Register, StrIntrinsicNode::UL);
10094   %}
10095   ins_pipe(long_memory_op);
10096 %}
10097 
10098 instruct string_equalsL(o0RegP str1, o1RegP str2, g3RegI cnt, notemp_iRegI result,
10099                         o7RegI tmp, flagsReg ccr) %{
10100   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10101   match(Set result (StrEquals (Binary str1 str2) cnt));
10102   effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp, KILL ccr);
10103   ins_cost(300);
10104   format %{ &quot;String Equals byte[] $str1,$str2,$cnt -&gt; $result   // KILL $tmp&quot; %}
10105   ins_encode %{
10106     __ array_equals(false, $str1$$Register, $str2$$Register,
10107                     $cnt$$Register, $tmp$$Register,
10108                     $result$$Register, true /* byte */);
10109   %}
10110   ins_pipe(long_memory_op);
10111 %}
10112 
10113 instruct string_equalsU(o0RegP str1, o1RegP str2, g3RegI cnt, notemp_iRegI result,
10114                         o7RegI tmp, flagsReg ccr) %{
10115   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
10116   match(Set result (StrEquals (Binary str1 str2) cnt));
10117   effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp, KILL ccr);
10118   ins_cost(300);
10119   format %{ &quot;String Equals char[]  $str1,$str2,$cnt -&gt; $result   // KILL $tmp&quot; %}
10120   ins_encode %{
10121     __ array_equals(false, $str1$$Register, $str2$$Register,
10122                     $cnt$$Register, $tmp$$Register,
10123                     $result$$Register, false /* byte */);
10124   %}
10125   ins_pipe(long_memory_op);
10126 %}
10127 
10128 instruct array_equalsB(o0RegP ary1, o1RegP ary2, g3RegI tmp1, notemp_iRegI result,
10129                        o7RegI tmp2, flagsReg ccr) %{
10130   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10131   match(Set result (AryEq ary1 ary2));
10132   effect(USE_KILL ary1, USE_KILL ary2, KILL tmp1, KILL tmp2, KILL ccr);
10133   ins_cost(300);
10134   format %{ &quot;Array Equals $ary1,$ary2 -&gt; $result   // KILL $tmp1,$tmp2&quot; %}
10135   ins_encode %{
10136     __ array_equals(true, $ary1$$Register, $ary2$$Register,
10137                     $tmp1$$Register, $tmp2$$Register,
10138                     $result$$Register, true /* byte */);
10139   %}
10140   ins_pipe(long_memory_op);
10141 %}
10142 
10143 instruct array_equalsC(o0RegP ary1, o1RegP ary2, g3RegI tmp1, notemp_iRegI result,
10144                        o7RegI tmp2, flagsReg ccr) %{
10145   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
10146   match(Set result (AryEq ary1 ary2));
10147   effect(USE_KILL ary1, USE_KILL ary2, KILL tmp1, KILL tmp2, KILL ccr);
10148   ins_cost(300);
10149   format %{ &quot;Array Equals $ary1,$ary2 -&gt; $result   // KILL $tmp1,$tmp2&quot; %}
10150   ins_encode %{
10151     __ array_equals(true, $ary1$$Register, $ary2$$Register,
10152                     $tmp1$$Register, $tmp2$$Register,
10153                     $result$$Register, false /* byte */);
10154   %}
10155   ins_pipe(long_memory_op);
10156 %}
10157 
10158 instruct has_negatives(o0RegP pAryR, g3RegI iSizeR, notemp_iRegI resultR,
10159                        iRegL tmp1L, iRegL tmp2L, iRegL tmp3L, iRegL tmp4L,
10160                        flagsReg ccr)
10161 %{
10162   match(Set resultR (HasNegatives pAryR iSizeR));
10163   effect(TEMP resultR, TEMP tmp1L, TEMP tmp2L, TEMP tmp3L, TEMP tmp4L, USE pAryR, USE iSizeR, KILL ccr);
10164   format %{ &quot;has negatives byte[] $pAryR,$iSizeR -&gt; $resultR // KILL $tmp1L,$tmp2L,$tmp3L,$tmp4L&quot; %}
10165   ins_encode %{
10166     __ has_negatives($pAryR$$Register, $iSizeR$$Register,
10167                      $resultR$$Register,
10168                      $tmp1L$$Register, $tmp2L$$Register,
10169                      $tmp3L$$Register, $tmp4L$$Register);
10170   %}
10171   ins_pipe(long_memory_op);
10172 %}
10173 
10174 // char[] to byte[] compression
10175 instruct string_compress(o0RegP src, o1RegP dst, g3RegI len, notemp_iRegI result, iRegL tmp, flagsReg ccr) %{
10176   predicate(UseVIS &lt; 3);
10177   match(Set result (StrCompressedCopy src (Binary dst len)));
10178   effect(TEMP result, TEMP tmp, USE_KILL src, USE_KILL dst, USE_KILL len, KILL ccr);
10179   ins_cost(300);
10180   format %{ &quot;String Compress $src,$dst,$len -&gt; $result    // KILL $tmp&quot; %}
10181   ins_encode %{
10182     Label Ldone;
10183     __ signx($len$$Register);
10184     __ cmp_zero_and_br(Assembler::zero, $len$$Register, Ldone, false, Assembler::pn);
10185     __ delayed()-&gt;mov($len$$Register, $result$$Register); // copy count
10186     __ string_compress($src$$Register, $dst$$Register, $len$$Register, $result$$Register, $tmp$$Register, Ldone);
10187     __ bind(Ldone);
10188   %}
10189   ins_pipe(long_memory_op);
10190 %}
10191 
10192 // fast char[] to byte[] compression using VIS instructions
10193 instruct string_compress_fast(o0RegP src, o1RegP dst, g3RegI len, notemp_iRegI result,
10194                               iRegL tmp1, iRegL tmp2, iRegL tmp3, iRegL tmp4,
10195                               regD ftmp1, regD ftmp2, regD ftmp3, flagsReg ccr) %{
10196   predicate(UseVIS &gt;= 3);
10197   match(Set result (StrCompressedCopy src (Binary dst len)));
10198   effect(TEMP result, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP ftmp1, TEMP ftmp2, TEMP ftmp3, USE_KILL src, USE_KILL dst, USE_KILL len, KILL ccr);
10199   ins_cost(300);
10200   format %{ &quot;String Compress Fast $src,$dst,$len -&gt; $result    // KILL $tmp1,$tmp2,$tmp3,$tmp4,$ftmp1,$ftmp2,$ftmp3&quot; %}
10201   ins_encode %{
10202     Label Ldone;
10203     __ signx($len$$Register);
10204     __ string_compress_16($src$$Register, $dst$$Register, $len$$Register, $result$$Register,
10205                           $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register,
10206                           $ftmp1$$FloatRegister, $ftmp2$$FloatRegister, $ftmp3$$FloatRegister, Ldone);
10207     __ cmp_and_brx_short($len$$Register, 0, Assembler::equal, Assembler::pn, Ldone);
10208     __ string_compress($src$$Register, $dst$$Register, $len$$Register, $result$$Register, $tmp1$$Register, Ldone);
10209     __ bind(Ldone);
10210   %}
10211   ins_pipe(long_memory_op);
10212 %}
10213 
10214 // byte[] to char[] inflation
10215 instruct string_inflate(Universe dummy, o0RegP src, o1RegP dst, g3RegI len,
10216                         iRegL tmp, flagsReg ccr) %{
10217   match(Set dummy (StrInflatedCopy src (Binary dst len)));
10218   effect(TEMP tmp, USE_KILL src, USE_KILL dst, USE_KILL len, KILL ccr);
10219   ins_cost(300);
10220   format %{ &quot;String Inflate $src,$dst,$len    // KILL $tmp&quot; %}
10221   ins_encode %{
10222     Label Ldone;
10223     __ signx($len$$Register);
10224     __ cmp_and_brx_short($len$$Register, 0, Assembler::equal, Assembler::pn, Ldone);
10225     __ string_inflate($src$$Register, $dst$$Register, $len$$Register, $tmp$$Register, Ldone);
10226     __ bind(Ldone);
10227   %}
10228   ins_pipe(long_memory_op);
10229 %}
10230 
10231 // fast byte[] to char[] inflation using VIS instructions
10232 instruct string_inflate_fast(Universe dummy, o0RegP src, o1RegP dst, g3RegI len,
10233                              iRegL tmp, regD ftmp1, regD ftmp2, regD ftmp3, regD ftmp4, flagsReg ccr) %{
10234   predicate(UseVIS &gt;= 3);
10235   match(Set dummy (StrInflatedCopy src (Binary dst len)));
10236   effect(TEMP tmp, TEMP ftmp1, TEMP ftmp2, TEMP ftmp3, TEMP ftmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL ccr);
10237   ins_cost(300);
10238   format %{ &quot;String Inflate Fast $src,$dst,$len    // KILL $tmp,$ftmp1,$ftmp2,$ftmp3,$ftmp4&quot; %}
10239   ins_encode %{
10240     Label Ldone;
10241     __ signx($len$$Register);
10242     __ string_inflate_16($src$$Register, $dst$$Register, $len$$Register, $tmp$$Register,
10243                          $ftmp1$$FloatRegister, $ftmp2$$FloatRegister, $ftmp3$$FloatRegister, $ftmp4$$FloatRegister, Ldone);
10244     __ cmp_and_brx_short($len$$Register, 0, Assembler::equal, Assembler::pn, Ldone);
10245     __ string_inflate($src$$Register, $dst$$Register, $len$$Register, $tmp$$Register, Ldone);
10246     __ bind(Ldone);
10247   %}
10248   ins_pipe(long_memory_op);
10249 %}
10250 
10251 
10252 //---------- Zeros Count Instructions ------------------------------------------
10253 
10254 instruct countLeadingZerosI(iRegIsafe dst, iRegI src, iRegI tmp, flagsReg cr) %{
10255   predicate(UsePopCountInstruction);  // See Matcher::match_rule_supported
10256   match(Set dst (CountLeadingZerosI src));
10257   effect(TEMP dst, TEMP tmp, KILL cr);
10258 
10259   // x |= (x &gt;&gt; 1);
10260   // x |= (x &gt;&gt; 2);
10261   // x |= (x &gt;&gt; 4);
10262   // x |= (x &gt;&gt; 8);
10263   // x |= (x &gt;&gt; 16);
10264   // return (WORDBITS - popc(x));
10265   format %{ &quot;SRL     $src,1,$tmp\t! count leading zeros (int)\n\t&quot;
10266             &quot;SRL     $src,0,$dst\t! 32-bit zero extend\n\t&quot;
10267             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10268             &quot;SRL     $dst,2,$tmp\n\t&quot;
10269             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10270             &quot;SRL     $dst,4,$tmp\n\t&quot;
10271             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10272             &quot;SRL     $dst,8,$tmp\n\t&quot;
10273             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10274             &quot;SRL     $dst,16,$tmp\n\t&quot;
10275             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10276             &quot;POPC    $dst,$dst\n\t&quot;
10277             &quot;MOV     32,$tmp\n\t&quot;
10278             &quot;SUB     $tmp,$dst,$dst&quot; %}
10279   ins_encode %{
10280     Register Rdst = $dst$$Register;
10281     Register Rsrc = $src$$Register;
10282     Register Rtmp = $tmp$$Register;
10283     __ srl(Rsrc, 1,    Rtmp);
10284     __ srl(Rsrc, 0,    Rdst);
10285     __ or3(Rdst, Rtmp, Rdst);
10286     __ srl(Rdst, 2,    Rtmp);
10287     __ or3(Rdst, Rtmp, Rdst);
10288     __ srl(Rdst, 4,    Rtmp);
10289     __ or3(Rdst, Rtmp, Rdst);
10290     __ srl(Rdst, 8,    Rtmp);
10291     __ or3(Rdst, Rtmp, Rdst);
10292     __ srl(Rdst, 16,   Rtmp);
10293     __ or3(Rdst, Rtmp, Rdst);
10294     __ popc(Rdst, Rdst);
10295     __ mov(BitsPerInt, Rtmp);
10296     __ sub(Rtmp, Rdst, Rdst);
10297   %}
10298   ins_pipe(ialu_reg);
10299 %}
10300 
10301 instruct countLeadingZerosL(iRegIsafe dst, iRegL src, iRegL tmp, flagsReg cr) %{
10302   predicate(UsePopCountInstruction);  // See Matcher::match_rule_supported
10303   match(Set dst (CountLeadingZerosL src));
10304   effect(TEMP dst, TEMP tmp, KILL cr);
10305 
10306   // x |= (x &gt;&gt; 1);
10307   // x |= (x &gt;&gt; 2);
10308   // x |= (x &gt;&gt; 4);
10309   // x |= (x &gt;&gt; 8);
10310   // x |= (x &gt;&gt; 16);
10311   // x |= (x &gt;&gt; 32);
10312   // return (WORDBITS - popc(x));
10313   format %{ &quot;SRLX    $src,1,$tmp\t! count leading zeros (long)\n\t&quot;
10314             &quot;OR      $src,$tmp,$dst\n\t&quot;
10315             &quot;SRLX    $dst,2,$tmp\n\t&quot;
10316             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10317             &quot;SRLX    $dst,4,$tmp\n\t&quot;
10318             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10319             &quot;SRLX    $dst,8,$tmp\n\t&quot;
10320             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10321             &quot;SRLX    $dst,16,$tmp\n\t&quot;
10322             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10323             &quot;SRLX    $dst,32,$tmp\n\t&quot;
10324             &quot;OR      $dst,$tmp,$dst\n\t&quot;
10325             &quot;POPC    $dst,$dst\n\t&quot;
10326             &quot;MOV     64,$tmp\n\t&quot;
10327             &quot;SUB     $tmp,$dst,$dst&quot; %}
10328   ins_encode %{
10329     Register Rdst = $dst$$Register;
10330     Register Rsrc = $src$$Register;
10331     Register Rtmp = $tmp$$Register;
10332     __ srlx(Rsrc, 1,    Rtmp);
10333     __ or3( Rsrc, Rtmp, Rdst);
10334     __ srlx(Rdst, 2,    Rtmp);
10335     __ or3( Rdst, Rtmp, Rdst);
10336     __ srlx(Rdst, 4,    Rtmp);
10337     __ or3( Rdst, Rtmp, Rdst);
10338     __ srlx(Rdst, 8,    Rtmp);
10339     __ or3( Rdst, Rtmp, Rdst);
10340     __ srlx(Rdst, 16,   Rtmp);
10341     __ or3( Rdst, Rtmp, Rdst);
10342     __ srlx(Rdst, 32,   Rtmp);
10343     __ or3( Rdst, Rtmp, Rdst);
10344     __ popc(Rdst, Rdst);
10345     __ mov(BitsPerLong, Rtmp);
10346     __ sub(Rtmp, Rdst, Rdst);
10347   %}
10348   ins_pipe(ialu_reg);
10349 %}
10350 
10351 instruct countTrailingZerosI(iRegIsafe dst, iRegI src, flagsReg cr) %{
10352   predicate(UsePopCountInstruction);  // See Matcher::match_rule_supported
10353   match(Set dst (CountTrailingZerosI src));
10354   effect(TEMP dst, KILL cr);
10355 
10356   // return popc(~x &amp; (x - 1));
10357   format %{ &quot;SUB     $src,1,$dst\t! count trailing zeros (int)\n\t&quot;
10358             &quot;ANDN    $dst,$src,$dst\n\t&quot;
10359             &quot;SRL     $dst,R_G0,$dst\n\t&quot;
10360             &quot;POPC    $dst,$dst&quot; %}
10361   ins_encode %{
10362     Register Rdst = $dst$$Register;
10363     Register Rsrc = $src$$Register;
10364     __ sub(Rsrc, 1, Rdst);
10365     __ andn(Rdst, Rsrc, Rdst);
10366     __ srl(Rdst, G0, Rdst);
10367     __ popc(Rdst, Rdst);
10368   %}
10369   ins_pipe(ialu_reg);
10370 %}
10371 
10372 instruct countTrailingZerosL(iRegIsafe dst, iRegL src, flagsReg cr) %{
10373   predicate(UsePopCountInstruction);  // See Matcher::match_rule_supported
10374   match(Set dst (CountTrailingZerosL src));
10375   effect(TEMP dst, KILL cr);
10376 
10377   // return popc(~x &amp; (x - 1));
10378   format %{ &quot;SUB     $src,1,$dst\t! count trailing zeros (long)\n\t&quot;
10379             &quot;ANDN    $dst,$src,$dst\n\t&quot;
10380             &quot;POPC    $dst,$dst&quot; %}
10381   ins_encode %{
10382     Register Rdst = $dst$$Register;
10383     Register Rsrc = $src$$Register;
10384     __ sub(Rsrc, 1, Rdst);
10385     __ andn(Rdst, Rsrc, Rdst);
10386     __ popc(Rdst, Rdst);
10387   %}
10388   ins_pipe(ialu_reg);
10389 %}
10390 
10391 
10392 //---------- Population Count Instructions -------------------------------------
10393 
10394 instruct popCountI(iRegIsafe dst, iRegI src) %{
10395   predicate(UsePopCountInstruction);
10396   match(Set dst (PopCountI src));
10397 
10398   format %{ &quot;SRL    $src, G0, $dst\t! clear upper word for 64 bit POPC\n\t&quot;
10399             &quot;POPC   $dst, $dst&quot; %}
10400   ins_encode %{
10401     __ srl($src$$Register, G0, $dst$$Register);
10402     __ popc($dst$$Register, $dst$$Register);
10403   %}
10404   ins_pipe(ialu_reg);
10405 %}
10406 
10407 // Note: Long.bitCount(long) returns an int.
10408 instruct popCountL(iRegIsafe dst, iRegL src) %{
10409   predicate(UsePopCountInstruction);
10410   match(Set dst (PopCountL src));
10411 
10412   format %{ &quot;POPC   $src, $dst&quot; %}
10413   ins_encode %{
10414     __ popc($src$$Register, $dst$$Register);
10415   %}
10416   ins_pipe(ialu_reg);
10417 %}
10418 
10419 
10420 // ============================================================================
10421 //------------Bytes reverse--------------------------------------------------
10422 
10423 instruct bytes_reverse_int(iRegI dst, stackSlotI src) %{
10424   match(Set dst (ReverseBytesI src));
10425 
10426   // Op cost is artificially doubled to make sure that load or store
10427   // instructions are preferred over this one which requires a spill
10428   // onto a stack slot.
10429   ins_cost(2*DEFAULT_COST + MEMORY_REF_COST);
10430   format %{ &quot;LDUWA  $src, $dst\t!asi=primary_little&quot; %}
10431 
10432   ins_encode %{
10433     __ set($src$$disp + STACK_BIAS, O7);
10434     __ lduwa($src$$base$$Register, O7, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10435   %}
10436   ins_pipe( iload_mem );
10437 %}
10438 
10439 instruct bytes_reverse_long(iRegL dst, stackSlotL src) %{
10440   match(Set dst (ReverseBytesL src));
10441 
10442   // Op cost is artificially doubled to make sure that load or store
10443   // instructions are preferred over this one which requires a spill
10444   // onto a stack slot.
10445   ins_cost(2*DEFAULT_COST + MEMORY_REF_COST);
10446   format %{ &quot;LDXA   $src, $dst\t!asi=primary_little&quot; %}
10447 
10448   ins_encode %{
10449     __ set($src$$disp + STACK_BIAS, O7);
10450     __ ldxa($src$$base$$Register, O7, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10451   %}
10452   ins_pipe( iload_mem );
10453 %}
10454 
10455 instruct bytes_reverse_unsigned_short(iRegI dst, stackSlotI src) %{
10456   match(Set dst (ReverseBytesUS src));
10457 
10458   // Op cost is artificially doubled to make sure that load or store
10459   // instructions are preferred over this one which requires a spill
10460   // onto a stack slot.
10461   ins_cost(2*DEFAULT_COST + MEMORY_REF_COST);
10462   format %{ &quot;LDUHA  $src, $dst\t!asi=primary_little\n\t&quot; %}
10463 
10464   ins_encode %{
10465     // the value was spilled as an int so bias the load
10466     __ set($src$$disp + STACK_BIAS + 2, O7);
10467     __ lduha($src$$base$$Register, O7, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10468   %}
10469   ins_pipe( iload_mem );
10470 %}
10471 
10472 instruct bytes_reverse_short(iRegI dst, stackSlotI src) %{
10473   match(Set dst (ReverseBytesS src));
10474 
10475   // Op cost is artificially doubled to make sure that load or store
10476   // instructions are preferred over this one which requires a spill
10477   // onto a stack slot.
10478   ins_cost(2*DEFAULT_COST + MEMORY_REF_COST);
10479   format %{ &quot;LDSHA  $src, $dst\t!asi=primary_little\n\t&quot; %}
10480 
10481   ins_encode %{
10482     // the value was spilled as an int so bias the load
10483     __ set($src$$disp + STACK_BIAS + 2, O7);
10484     __ ldsha($src$$base$$Register, O7, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10485   %}
10486   ins_pipe( iload_mem );
10487 %}
10488 
10489 // Load Integer reversed byte order
10490 instruct loadI_reversed(iRegI dst, indIndexMemory src) %{
10491   match(Set dst (ReverseBytesI (LoadI src)));
10492 
10493   ins_cost(DEFAULT_COST + MEMORY_REF_COST);
10494   size(4);
10495   format %{ &quot;LDUWA  $src, $dst\t!asi=primary_little&quot; %}
10496 
10497   ins_encode %{
10498     __ lduwa($src$$base$$Register, $src$$index$$Register, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10499   %}
10500   ins_pipe(iload_mem);
10501 %}
10502 
10503 // Load Long - aligned and reversed
10504 instruct loadL_reversed(iRegL dst, indIndexMemory src) %{
10505   match(Set dst (ReverseBytesL (LoadL src)));
10506 
10507   ins_cost(MEMORY_REF_COST);
10508   size(4);
10509   format %{ &quot;LDXA   $src, $dst\t!asi=primary_little&quot; %}
10510 
10511   ins_encode %{
10512     __ ldxa($src$$base$$Register, $src$$index$$Register, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10513   %}
10514   ins_pipe(iload_mem);
10515 %}
10516 
10517 // Load unsigned short / char reversed byte order
10518 instruct loadUS_reversed(iRegI dst, indIndexMemory src) %{
10519   match(Set dst (ReverseBytesUS (LoadUS src)));
10520 
10521   ins_cost(MEMORY_REF_COST);
10522   size(4);
10523   format %{ &quot;LDUHA  $src, $dst\t!asi=primary_little&quot; %}
10524 
10525   ins_encode %{
10526     __ lduha($src$$base$$Register, $src$$index$$Register, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10527   %}
10528   ins_pipe(iload_mem);
10529 %}
10530 
10531 // Load short reversed byte order
10532 instruct loadS_reversed(iRegI dst, indIndexMemory src) %{
10533   match(Set dst (ReverseBytesS (LoadS src)));
10534 
10535   ins_cost(MEMORY_REF_COST);
10536   size(4);
10537   format %{ &quot;LDSHA  $src, $dst\t!asi=primary_little&quot; %}
10538 
10539   ins_encode %{
10540     __ ldsha($src$$base$$Register, $src$$index$$Register, Assembler::ASI_PRIMARY_LITTLE, $dst$$Register);
10541   %}
10542   ins_pipe(iload_mem);
10543 %}
10544 
10545 // Store Integer reversed byte order
10546 instruct storeI_reversed(indIndexMemory dst, iRegI src) %{
10547   match(Set dst (StoreI dst (ReverseBytesI src)));
10548 
10549   ins_cost(MEMORY_REF_COST);
10550   size(4);
10551   format %{ &quot;STWA   $src, $dst\t!asi=primary_little&quot; %}
10552 
10553   ins_encode %{
10554     __ stwa($src$$Register, $dst$$base$$Register, $dst$$index$$Register, Assembler::ASI_PRIMARY_LITTLE);
10555   %}
10556   ins_pipe(istore_mem_reg);
10557 %}
10558 
10559 // Store Long reversed byte order
10560 instruct storeL_reversed(indIndexMemory dst, iRegL src) %{
10561   match(Set dst (StoreL dst (ReverseBytesL src)));
10562 
10563   ins_cost(MEMORY_REF_COST);
10564   size(4);
10565   format %{ &quot;STXA   $src, $dst\t!asi=primary_little&quot; %}
10566 
10567   ins_encode %{
10568     __ stxa($src$$Register, $dst$$base$$Register, $dst$$index$$Register, Assembler::ASI_PRIMARY_LITTLE);
10569   %}
10570   ins_pipe(istore_mem_reg);
10571 %}
10572 
10573 // Store unsighed short/char reversed byte order
10574 instruct storeUS_reversed(indIndexMemory dst, iRegI src) %{
10575   match(Set dst (StoreC dst (ReverseBytesUS src)));
10576 
10577   ins_cost(MEMORY_REF_COST);
10578   size(4);
10579   format %{ &quot;STHA   $src, $dst\t!asi=primary_little&quot; %}
10580 
10581   ins_encode %{
10582     __ stha($src$$Register, $dst$$base$$Register, $dst$$index$$Register, Assembler::ASI_PRIMARY_LITTLE);
10583   %}
10584   ins_pipe(istore_mem_reg);
10585 %}
10586 
10587 // Store short reversed byte order
10588 instruct storeS_reversed(indIndexMemory dst, iRegI src) %{
10589   match(Set dst (StoreC dst (ReverseBytesS src)));
10590 
10591   ins_cost(MEMORY_REF_COST);
10592   size(4);
10593   format %{ &quot;STHA   $src, $dst\t!asi=primary_little&quot; %}
10594 
10595   ins_encode %{
10596     __ stha($src$$Register, $dst$$base$$Register, $dst$$index$$Register, Assembler::ASI_PRIMARY_LITTLE);
10597   %}
10598   ins_pipe(istore_mem_reg);
10599 %}
10600 
10601 // ====================VECTOR INSTRUCTIONS=====================================
10602 
10603 // Load Aligned Packed values into a Double Register
10604 instruct loadV8(regD dst, memory mem) %{
10605   predicate(n-&gt;as_LoadVector()-&gt;memory_size() == 8);
10606   match(Set dst (LoadVector mem));
10607   ins_cost(MEMORY_REF_COST);
10608   size(4);
10609   format %{ &quot;LDDF   $mem,$dst\t! load vector (8 bytes)&quot; %}
10610   ins_encode %{
10611     __ ldf(FloatRegisterImpl::D, $mem$$Address, as_DoubleFloatRegister($dst$$reg));
10612   %}
10613   ins_pipe(floadD_mem);
10614 %}
10615 
10616 // Store Vector in Double register to memory
10617 instruct storeV8(memory mem, regD src) %{
10618   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
10619   match(Set mem (StoreVector mem src));
10620   ins_cost(MEMORY_REF_COST);
10621   size(4);
10622   format %{ &quot;STDF   $src,$mem\t! store vector (8 bytes)&quot; %}
10623   ins_encode %{
10624     __ stf(FloatRegisterImpl::D, as_DoubleFloatRegister($src$$reg), $mem$$Address);
10625   %}
10626   ins_pipe(fstoreD_mem_reg);
10627 %}
10628 
10629 // Store Zero into vector in memory
10630 instruct storeV8B_zero(memory mem, immI0 zero) %{
10631   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
10632   match(Set mem (StoreVector mem (ReplicateB zero)));
10633   ins_cost(MEMORY_REF_COST);
10634   size(4);
10635   format %{ &quot;STX    $zero,$mem\t! store zero vector (8 bytes)&quot; %}
10636   ins_encode %{
10637     __ stx(G0, $mem$$Address);
10638   %}
10639   ins_pipe(fstoreD_mem_zero);
10640 %}
10641 
10642 instruct storeV4S_zero(memory mem, immI0 zero) %{
10643   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
10644   match(Set mem (StoreVector mem (ReplicateS zero)));
10645   ins_cost(MEMORY_REF_COST);
10646   size(4);
10647   format %{ &quot;STX    $zero,$mem\t! store zero vector (4 shorts)&quot; %}
10648   ins_encode %{
10649     __ stx(G0, $mem$$Address);
10650   %}
10651   ins_pipe(fstoreD_mem_zero);
10652 %}
10653 
10654 instruct storeV2I_zero(memory mem, immI0 zero) %{
10655   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
10656   match(Set mem (StoreVector mem (ReplicateI zero)));
10657   ins_cost(MEMORY_REF_COST);
10658   size(4);
10659   format %{ &quot;STX    $zero,$mem\t! store zero vector (2 ints)&quot; %}
10660   ins_encode %{
10661     __ stx(G0, $mem$$Address);
10662   %}
10663   ins_pipe(fstoreD_mem_zero);
10664 %}
10665 
10666 instruct storeV2F_zero(memory mem, immF0 zero) %{
10667   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
10668   match(Set mem (StoreVector mem (ReplicateF zero)));
10669   ins_cost(MEMORY_REF_COST);
10670   size(4);
10671   format %{ &quot;STX    $zero,$mem\t! store zero vector (2 floats)&quot; %}
10672   ins_encode %{
10673     __ stx(G0, $mem$$Address);
10674   %}
10675   ins_pipe(fstoreD_mem_zero);
10676 %}
10677 
10678 // Replicate scalar to packed byte values into Double register
10679 instruct Repl8B_reg(regD dst, iRegI src, iRegL tmp, o7RegL tmp2) %{
10680   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; UseVIS &gt;= 3);
10681   match(Set dst (ReplicateB src));
10682   effect(DEF dst, USE src, TEMP tmp, KILL tmp2);
10683   format %{ &quot;SLLX  $src,56,$tmp\n\t&quot;
10684             &quot;SRLX  $tmp, 8,$tmp2\n\t&quot;
10685             &quot;OR    $tmp,$tmp2,$tmp\n\t&quot;
10686             &quot;SRLX  $tmp,16,$tmp2\n\t&quot;
10687             &quot;OR    $tmp,$tmp2,$tmp\n\t&quot;
10688             &quot;SRLX  $tmp,32,$tmp2\n\t&quot;
10689             &quot;OR    $tmp,$tmp2,$tmp\t! replicate8B\n\t&quot;
10690             &quot;MOVXTOD $tmp,$dst\t! MoveL2D&quot; %}
10691   ins_encode %{
10692     Register Rsrc = $src$$Register;
10693     Register Rtmp = $tmp$$Register;
10694     Register Rtmp2 = $tmp2$$Register;
10695     __ sllx(Rsrc,    56, Rtmp);
10696     __ srlx(Rtmp,     8, Rtmp2);
10697     __ or3 (Rtmp, Rtmp2, Rtmp);
10698     __ srlx(Rtmp,    16, Rtmp2);
10699     __ or3 (Rtmp, Rtmp2, Rtmp);
10700     __ srlx(Rtmp,    32, Rtmp2);
10701     __ or3 (Rtmp, Rtmp2, Rtmp);
10702     __ movxtod(Rtmp, as_DoubleFloatRegister($dst$$reg));
10703   %}
10704   ins_pipe(ialu_reg);
10705 %}
10706 
10707 // Replicate scalar to packed byte values into Double stack
10708 instruct Repl8B_stk(stackSlotD dst, iRegI src, iRegL tmp, o7RegL tmp2) %{
10709   predicate(n-&gt;as_Vector()-&gt;length() == 8 &amp;&amp; UseVIS &lt; 3);
10710   match(Set dst (ReplicateB src));
10711   effect(DEF dst, USE src, TEMP tmp, KILL tmp2);
10712   format %{ &quot;SLLX  $src,56,$tmp\n\t&quot;
10713             &quot;SRLX  $tmp, 8,$tmp2\n\t&quot;
10714             &quot;OR    $tmp,$tmp2,$tmp\n\t&quot;
10715             &quot;SRLX  $tmp,16,$tmp2\n\t&quot;
10716             &quot;OR    $tmp,$tmp2,$tmp\n\t&quot;
10717             &quot;SRLX  $tmp,32,$tmp2\n\t&quot;
10718             &quot;OR    $tmp,$tmp2,$tmp\t! replicate8B\n\t&quot;
10719             &quot;STX   $tmp,$dst\t! regL to stkD&quot; %}
10720   ins_encode %{
10721     Register Rsrc = $src$$Register;
10722     Register Rtmp = $tmp$$Register;
10723     Register Rtmp2 = $tmp2$$Register;
10724     __ sllx(Rsrc,    56, Rtmp);
10725     __ srlx(Rtmp,     8, Rtmp2);
10726     __ or3 (Rtmp, Rtmp2, Rtmp);
10727     __ srlx(Rtmp,    16, Rtmp2);
10728     __ or3 (Rtmp, Rtmp2, Rtmp);
10729     __ srlx(Rtmp,    32, Rtmp2);
10730     __ or3 (Rtmp, Rtmp2, Rtmp);
10731     __ set ($dst$$disp + STACK_BIAS, Rtmp2);
10732     __ stx (Rtmp, Rtmp2, $dst$$base$$Register);
10733   %}
10734   ins_pipe(ialu_reg);
10735 %}
10736 
10737 // Replicate scalar constant to packed byte values in Double register
10738 instruct Repl8B_immI(regD dst, immI13 con, o7RegI tmp) %{
10739   predicate(n-&gt;as_Vector()-&gt;length() == 8);
10740   match(Set dst (ReplicateB con));
10741   effect(KILL tmp);
10742   format %{ &quot;LDDF   [$constanttablebase + $constantoffset],$dst\t! load from constant table: Repl8B($con)&quot; %}
10743   ins_encode %{
10744     // XXX This is a quick fix for 6833573.
10745     //__ ldf(FloatRegisterImpl::D, $constanttablebase, $constantoffset(replicate_immI($con$$constant, 8, 1)), $dst$$FloatRegister);
10746     RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset(replicate_immI($con$$constant, 8, 1)), $tmp$$Register);
10747     __ ldf(FloatRegisterImpl::D, $constanttablebase, con_offset, as_DoubleFloatRegister($dst$$reg));
10748   %}
10749   ins_pipe(loadConFD);
10750 %}
10751 
10752 // Replicate scalar to packed char/short values into Double register
10753 instruct Repl4S_reg(regD dst, iRegI src, iRegL tmp, o7RegL tmp2) %{
10754   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; UseVIS &gt;= 3);
10755   match(Set dst (ReplicateS src));
10756   effect(DEF dst, USE src, TEMP tmp, KILL tmp2);
10757   format %{ &quot;SLLX  $src,48,$tmp\n\t&quot;
10758             &quot;SRLX  $tmp,16,$tmp2\n\t&quot;
10759             &quot;OR    $tmp,$tmp2,$tmp\n\t&quot;
10760             &quot;SRLX  $tmp,32,$tmp2\n\t&quot;
10761             &quot;OR    $tmp,$tmp2,$tmp\t! replicate4S\n\t&quot;
10762             &quot;MOVXTOD $tmp,$dst\t! MoveL2D&quot; %}
10763   ins_encode %{
10764     Register Rsrc = $src$$Register;
10765     Register Rtmp = $tmp$$Register;
10766     Register Rtmp2 = $tmp2$$Register;
10767     __ sllx(Rsrc,    48, Rtmp);
10768     __ srlx(Rtmp,    16, Rtmp2);
10769     __ or3 (Rtmp, Rtmp2, Rtmp);
10770     __ srlx(Rtmp,    32, Rtmp2);
10771     __ or3 (Rtmp, Rtmp2, Rtmp);
10772     __ movxtod(Rtmp, as_DoubleFloatRegister($dst$$reg));
10773   %}
10774   ins_pipe(ialu_reg);
10775 %}
10776 
10777 // Replicate scalar to packed char/short values into Double stack
10778 instruct Repl4S_stk(stackSlotD dst, iRegI src, iRegL tmp, o7RegL tmp2) %{
10779   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; UseVIS &lt; 3);
10780   match(Set dst (ReplicateS src));
10781   effect(DEF dst, USE src, TEMP tmp, KILL tmp2);
10782   format %{ &quot;SLLX  $src,48,$tmp\n\t&quot;
10783             &quot;SRLX  $tmp,16,$tmp2\n\t&quot;
10784             &quot;OR    $tmp,$tmp2,$tmp\n\t&quot;
10785             &quot;SRLX  $tmp,32,$tmp2\n\t&quot;
10786             &quot;OR    $tmp,$tmp2,$tmp\t! replicate4S\n\t&quot;
10787             &quot;STX   $tmp,$dst\t! regL to stkD&quot; %}
10788   ins_encode %{
10789     Register Rsrc = $src$$Register;
10790     Register Rtmp = $tmp$$Register;
10791     Register Rtmp2 = $tmp2$$Register;
10792     __ sllx(Rsrc,    48, Rtmp);
10793     __ srlx(Rtmp,    16, Rtmp2);
10794     __ or3 (Rtmp, Rtmp2, Rtmp);
10795     __ srlx(Rtmp,    32, Rtmp2);
10796     __ or3 (Rtmp, Rtmp2, Rtmp);
10797     __ set ($dst$$disp + STACK_BIAS, Rtmp2);
10798     __ stx (Rtmp, Rtmp2, $dst$$base$$Register);
10799   %}
10800   ins_pipe(ialu_reg);
10801 %}
10802 
10803 // Replicate scalar constant to packed char/short values in Double register
10804 instruct Repl4S_immI(regD dst, immI con, o7RegI tmp) %{
10805   predicate(n-&gt;as_Vector()-&gt;length() == 4);
10806   match(Set dst (ReplicateS con));
10807   effect(KILL tmp);
10808   format %{ &quot;LDDF   [$constanttablebase + $constantoffset],$dst\t! load from constant table: Repl4S($con)&quot; %}
10809   ins_encode %{
10810     // XXX This is a quick fix for 6833573.
10811     //__ ldf(FloatRegisterImpl::D, $constanttablebase, $constantoffset(replicate_immI($con$$constant, 4, 2)), $dst$$FloatRegister);
10812     RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset(replicate_immI($con$$constant, 4, 2)), $tmp$$Register);
10813     __ ldf(FloatRegisterImpl::D, $constanttablebase, con_offset, as_DoubleFloatRegister($dst$$reg));
10814   %}
10815   ins_pipe(loadConFD);
10816 %}
10817 
10818 // Replicate scalar to packed int values into Double register
10819 instruct Repl2I_reg(regD dst, iRegI src, iRegL tmp, o7RegL tmp2) %{
10820   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; UseVIS &gt;= 3);
10821   match(Set dst (ReplicateI src));
10822   effect(DEF dst, USE src, TEMP tmp, KILL tmp2);
10823   format %{ &quot;SLLX  $src,32,$tmp\n\t&quot;
10824             &quot;SRLX  $tmp,32,$tmp2\n\t&quot;
10825             &quot;OR    $tmp,$tmp2,$tmp\t! replicate2I\n\t&quot;
10826             &quot;MOVXTOD $tmp,$dst\t! MoveL2D&quot; %}
10827   ins_encode %{
10828     Register Rsrc = $src$$Register;
10829     Register Rtmp = $tmp$$Register;
10830     Register Rtmp2 = $tmp2$$Register;
10831     __ sllx(Rsrc,    32, Rtmp);
10832     __ srlx(Rtmp,    32, Rtmp2);
10833     __ or3 (Rtmp, Rtmp2, Rtmp);
10834     __ movxtod(Rtmp, as_DoubleFloatRegister($dst$$reg));
10835   %}
10836   ins_pipe(ialu_reg);
10837 %}
10838 
10839 // Replicate scalar to packed int values into Double stack
10840 instruct Repl2I_stk(stackSlotD dst, iRegI src, iRegL tmp, o7RegL tmp2) %{
10841   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; UseVIS &lt; 3);
10842   match(Set dst (ReplicateI src));
10843   effect(DEF dst, USE src, TEMP tmp, KILL tmp2);
10844   format %{ &quot;SLLX  $src,32,$tmp\n\t&quot;
10845             &quot;SRLX  $tmp,32,$tmp2\n\t&quot;
10846             &quot;OR    $tmp,$tmp2,$tmp\t! replicate2I\n\t&quot;
10847             &quot;STX   $tmp,$dst\t! regL to stkD&quot; %}
10848   ins_encode %{
10849     Register Rsrc = $src$$Register;
10850     Register Rtmp = $tmp$$Register;
10851     Register Rtmp2 = $tmp2$$Register;
10852     __ sllx(Rsrc,    32, Rtmp);
10853     __ srlx(Rtmp,    32, Rtmp2);
10854     __ or3 (Rtmp, Rtmp2, Rtmp);
10855     __ set ($dst$$disp + STACK_BIAS, Rtmp2);
10856     __ stx (Rtmp, Rtmp2, $dst$$base$$Register);
10857   %}
10858   ins_pipe(ialu_reg);
10859 %}
10860 
10861 // Replicate scalar zero constant to packed int values in Double register
10862 instruct Repl2I_immI(regD dst, immI con, o7RegI tmp) %{
10863   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10864   match(Set dst (ReplicateI con));
10865   effect(KILL tmp);
10866   format %{ &quot;LDDF   [$constanttablebase + $constantoffset],$dst\t! load from constant table: Repl2I($con)&quot; %}
10867   ins_encode %{
10868     // XXX This is a quick fix for 6833573.
10869     //__ ldf(FloatRegisterImpl::D, $constanttablebase, $constantoffset(replicate_immI($con$$constant, 2, 4)), $dst$$FloatRegister);
10870     RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset(replicate_immI($con$$constant, 2, 4)), $tmp$$Register);
10871     __ ldf(FloatRegisterImpl::D, $constanttablebase, con_offset, as_DoubleFloatRegister($dst$$reg));
10872   %}
10873   ins_pipe(loadConFD);
10874 %}
10875 
10876 // Replicate scalar to packed float values into Double stack
10877 instruct Repl2F_stk(stackSlotD dst, regF src) %{
10878   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10879   match(Set dst (ReplicateF src));
10880   ins_cost(MEMORY_REF_COST*2);
10881   format %{ &quot;STF    $src,$dst.hi\t! packed2F\n\t&quot;
10882             &quot;STF    $src,$dst.lo&quot; %}
10883   opcode(Assembler::stf_op3);
10884   ins_encode(simple_form3_mem_reg(dst, src), form3_mem_plus_4_reg(dst, src));
10885   ins_pipe(fstoreF_stk_reg);
10886 %}
10887 
10888 // Replicate scalar zero constant to packed float values in Double register
10889 instruct Repl2F_immF(regD dst, immF con, o7RegI tmp) %{
10890   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10891   match(Set dst (ReplicateF con));
10892   effect(KILL tmp);
10893   format %{ &quot;LDDF   [$constanttablebase + $constantoffset],$dst\t! load from constant table: Repl2F($con)&quot; %}
10894   ins_encode %{
10895     // XXX This is a quick fix for 6833573.
10896     //__ ldf(FloatRegisterImpl::D, $constanttablebase, $constantoffset(replicate_immF($con$$constant)), $dst$$FloatRegister);
10897     RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset(replicate_immF($con$$constant)), $tmp$$Register);
10898     __ ldf(FloatRegisterImpl::D, $constanttablebase, con_offset, as_DoubleFloatRegister($dst$$reg));
10899   %}
10900   ins_pipe(loadConFD);
10901 %}
10902 
10903 //----------PEEPHOLE RULES-----------------------------------------------------
10904 // These must follow all instruction definitions as they use the names
10905 // defined in the instructions definitions.
10906 //
10907 // peepmatch ( root_instr_name [preceding_instruction]* );
10908 //
10909 // peepconstraint %{
10910 // (instruction_number.operand_name relational_op instruction_number.operand_name
10911 //  [, ...] );
10912 // // instruction numbers are zero-based using left to right order in peepmatch
10913 //
10914 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
10915 // // provide an instruction_number.operand_name for each operand that appears
10916 // // in the replacement instruction&#39;s match rule
10917 //
10918 // ---------VM FLAGS---------------------------------------------------------
10919 //
10920 // All peephole optimizations can be turned off using -XX:-OptoPeephole
10921 //
10922 // Each peephole rule is given an identifying number starting with zero and
10923 // increasing by one in the order seen by the parser.  An individual peephole
10924 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
10925 // on the command-line.
10926 //
10927 // ---------CURRENT LIMITATIONS----------------------------------------------
10928 //
10929 // Only match adjacent instructions in same basic block
10930 // Only equality constraints
10931 // Only constraints between operands, not (0.dest_reg == EAX_enc)
10932 // Only one replacement instruction
10933 //
10934 // ---------EXAMPLE----------------------------------------------------------
10935 //
10936 // // pertinent parts of existing instructions in architecture description
10937 // instruct movI(eRegI dst, eRegI src) %{
10938 //   match(Set dst (CopyI src));
10939 // %}
10940 //
10941 // instruct incI_eReg(eRegI dst, immI1 src, eFlagsReg cr) %{
10942 //   match(Set dst (AddI dst src));
10943 //   effect(KILL cr);
10944 // %}
10945 //
10946 // // Change (inc mov) to lea
10947 // peephole %{
10948 //   // increment preceeded by register-register move
10949 //   peepmatch ( incI_eReg movI );
10950 //   // require that the destination register of the increment
10951 //   // match the destination register of the move
10952 //   peepconstraint ( 0.dst == 1.dst );
10953 //   // construct a replacement instruction that sets
10954 //   // the destination to ( move&#39;s source register + one )
10955 //   peepreplace ( incI_eReg_immI1( 0.dst 1.src 0.src ) );
10956 // %}
10957 //
10958 
10959 // // Change load of spilled value to only a spill
10960 // instruct storeI(memory mem, eRegI src) %{
10961 //   match(Set mem (StoreI mem src));
10962 // %}
10963 //
10964 // instruct loadI(eRegI dst, memory mem) %{
10965 //   match(Set dst (LoadI mem));
10966 // %}
10967 //
10968 // peephole %{
10969 //   peepmatch ( loadI storeI );
10970 //   peepconstraint ( 1.src == 0.dst, 1.mem == 0.mem );
10971 //   peepreplace ( storeI( 1.mem 1.mem 1.src ) );
10972 // %}
10973 
10974 //----------SMARTSPILL RULES---------------------------------------------------
10975 // These must follow all instruction definitions as they use the names
10976 // defined in the instructions definitions.
10977 //
10978 // SPARC will probably not have any of these rules due to RISC instruction set.
10979 
10980 //----------PIPELINE-----------------------------------------------------------
10981 // Rules which define the behavior of the target architectures pipeline.
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/macroAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>    1 /*
<a name="1" id="anc1"></a><span class="line-modified">    2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
    3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4  *
    5  * This code is free software; you can redistribute it and/or modify it
    6  * under the terms of the GNU General Public License version 2 only, as
    7  * published by the Free Software Foundation.
    8  *
    9  * This code is distributed in the hope that it will be useful, but WITHOUT
   10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12  * version 2 for more details (a copy is included in the LICENSE file that
   13  * accompanied this code).
   14  *
   15  * You should have received a copy of the GNU General Public License version
   16  * 2 along with this work; if not, write to the Free Software Foundation,
   17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18  *
   19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20  * or visit www.oracle.com if you need additional information or have any
   21  * questions.
   22  *
   23  */
   24 
   25 #include &quot;precompiled.hpp&quot;
   26 #include &quot;jvm.h&quot;
   27 #include &quot;asm/assembler.hpp&quot;
   28 #include &quot;asm/assembler.inline.hpp&quot;
   29 #include &quot;compiler/disassembler.hpp&quot;
   30 #include &quot;gc/shared/barrierSet.hpp&quot;
   31 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
   32 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
   33 #include &quot;interpreter/interpreter.hpp&quot;
   34 #include &quot;memory/resourceArea.hpp&quot;
   35 #include &quot;memory/universe.hpp&quot;
   36 #include &quot;oops/accessDecorators.hpp&quot;
   37 #include &quot;oops/compressedOops.inline.hpp&quot;
   38 #include &quot;oops/klass.inline.hpp&quot;
   39 #include &quot;prims/methodHandles.hpp&quot;
   40 #include &quot;runtime/biasedLocking.hpp&quot;
   41 #include &quot;runtime/flags/flagSetting.hpp&quot;
   42 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
   43 #include &quot;runtime/objectMonitor.hpp&quot;
   44 #include &quot;runtime/os.hpp&quot;
   45 #include &quot;runtime/safepoint.hpp&quot;
   46 #include &quot;runtime/safepointMechanism.hpp&quot;
   47 #include &quot;runtime/sharedRuntime.hpp&quot;
   48 #include &quot;runtime/stubRoutines.hpp&quot;
   49 #include &quot;runtime/thread.hpp&quot;
   50 #include &quot;utilities/macros.hpp&quot;
   51 #include &quot;crc32c.h&quot;
   52 #ifdef COMPILER2
   53 #include &quot;opto/intrinsicnode.hpp&quot;
   54 #endif
   55 
   56 #ifdef PRODUCT
   57 #define BLOCK_COMMENT(str) /* nothing */
   58 #define STOP(error) stop(error)
   59 #else
   60 #define BLOCK_COMMENT(str) block_comment(str)
   61 #define STOP(error) block_comment(error); stop(error)
   62 #endif
   63 
   64 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
   65 
   66 #ifdef ASSERT
   67 bool AbstractAssembler::pd_check_instruction_mark() { return true; }
   68 #endif
   69 
   70 static Assembler::Condition reverse[] = {
   71     Assembler::noOverflow     /* overflow      = 0x0 */ ,
   72     Assembler::overflow       /* noOverflow    = 0x1 */ ,
   73     Assembler::aboveEqual     /* carrySet      = 0x2, below         = 0x2 */ ,
   74     Assembler::below          /* aboveEqual    = 0x3, carryClear    = 0x3 */ ,
   75     Assembler::notZero        /* zero          = 0x4, equal         = 0x4 */ ,
   76     Assembler::zero           /* notZero       = 0x5, notEqual      = 0x5 */ ,
   77     Assembler::above          /* belowEqual    = 0x6 */ ,
   78     Assembler::belowEqual     /* above         = 0x7 */ ,
   79     Assembler::positive       /* negative      = 0x8 */ ,
   80     Assembler::negative       /* positive      = 0x9 */ ,
   81     Assembler::noParity       /* parity        = 0xa */ ,
   82     Assembler::parity         /* noParity      = 0xb */ ,
   83     Assembler::greaterEqual   /* less          = 0xc */ ,
   84     Assembler::less           /* greaterEqual  = 0xd */ ,
   85     Assembler::greater        /* lessEqual     = 0xe */ ,
   86     Assembler::lessEqual      /* greater       = 0xf, */
   87 
   88 };
   89 
   90 
   91 // Implementation of MacroAssembler
   92 
   93 // First all the versions that have distinct versions depending on 32/64 bit
   94 // Unless the difference is trivial (1 line or so).
   95 
   96 #ifndef _LP64
   97 
   98 // 32bit versions
   99 
  100 Address MacroAssembler::as_Address(AddressLiteral adr) {
  101   return Address(adr.target(), adr.rspec());
  102 }
  103 
  104 Address MacroAssembler::as_Address(ArrayAddress adr) {
  105   return Address::make_array(adr);
  106 }
  107 
  108 void MacroAssembler::call_VM_leaf_base(address entry_point,
  109                                        int number_of_arguments) {
  110   call(RuntimeAddress(entry_point));
  111   increment(rsp, number_of_arguments * wordSize);
  112 }
  113 
  114 void MacroAssembler::cmpklass(Address src1, Metadata* obj) {
  115   cmp_literal32(src1, (int32_t)obj, metadata_Relocation::spec_for_immediate());
  116 }
  117 
  118 void MacroAssembler::cmpklass(Register src1, Metadata* obj) {
  119   cmp_literal32(src1, (int32_t)obj, metadata_Relocation::spec_for_immediate());
  120 }
  121 
  122 void MacroAssembler::cmpoop_raw(Address src1, jobject obj) {
  123   cmp_literal32(src1, (int32_t)obj, oop_Relocation::spec_for_immediate());
  124 }
  125 
  126 void MacroAssembler::cmpoop_raw(Register src1, jobject obj) {
  127   cmp_literal32(src1, (int32_t)obj, oop_Relocation::spec_for_immediate());
  128 }
  129 
  130 void MacroAssembler::cmpoop(Address src1, jobject obj) {
  131   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
  132   bs-&gt;obj_equals(this, src1, obj);
  133 }
  134 
  135 void MacroAssembler::cmpoop(Register src1, jobject obj) {
  136   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
  137   bs-&gt;obj_equals(this, src1, obj);
  138 }
  139 
  140 void MacroAssembler::extend_sign(Register hi, Register lo) {
  141   // According to Intel Doc. AP-526, &quot;Integer Divide&quot;, p.18.
  142   if (VM_Version::is_P6() &amp;&amp; hi == rdx &amp;&amp; lo == rax) {
  143     cdql();
  144   } else {
  145     movl(hi, lo);
  146     sarl(hi, 31);
  147   }
  148 }
  149 
  150 void MacroAssembler::jC2(Register tmp, Label&amp; L) {
  151   // set parity bit if FPU flag C2 is set (via rax)
  152   save_rax(tmp);
  153   fwait(); fnstsw_ax();
  154   sahf();
  155   restore_rax(tmp);
  156   // branch
  157   jcc(Assembler::parity, L);
  158 }
  159 
  160 void MacroAssembler::jnC2(Register tmp, Label&amp; L) {
  161   // set parity bit if FPU flag C2 is set (via rax)
  162   save_rax(tmp);
  163   fwait(); fnstsw_ax();
  164   sahf();
  165   restore_rax(tmp);
  166   // branch
  167   jcc(Assembler::noParity, L);
  168 }
  169 
  170 // 32bit can do a case table jump in one instruction but we no longer allow the base
  171 // to be installed in the Address class
  172 void MacroAssembler::jump(ArrayAddress entry) {
  173   jmp(as_Address(entry));
  174 }
  175 
  176 // Note: y_lo will be destroyed
  177 void MacroAssembler::lcmp2int(Register x_hi, Register x_lo, Register y_hi, Register y_lo) {
  178   // Long compare for Java (semantics as described in JVM spec.)
  179   Label high, low, done;
  180 
  181   cmpl(x_hi, y_hi);
  182   jcc(Assembler::less, low);
  183   jcc(Assembler::greater, high);
  184   // x_hi is the return register
  185   xorl(x_hi, x_hi);
  186   cmpl(x_lo, y_lo);
  187   jcc(Assembler::below, low);
  188   jcc(Assembler::equal, done);
  189 
  190   bind(high);
  191   xorl(x_hi, x_hi);
  192   increment(x_hi);
  193   jmp(done);
  194 
  195   bind(low);
  196   xorl(x_hi, x_hi);
  197   decrementl(x_hi);
  198 
  199   bind(done);
  200 }
  201 
  202 void MacroAssembler::lea(Register dst, AddressLiteral src) {
  203     mov_literal32(dst, (int32_t)src.target(), src.rspec());
  204 }
  205 
  206 void MacroAssembler::lea(Address dst, AddressLiteral adr) {
  207   // leal(dst, as_Address(adr));
  208   // see note in movl as to why we must use a move
  209   mov_literal32(dst, (int32_t) adr.target(), adr.rspec());
  210 }
  211 
  212 void MacroAssembler::leave() {
  213   mov(rsp, rbp);
  214   pop(rbp);
  215 }
  216 
  217 void MacroAssembler::lmul(int x_rsp_offset, int y_rsp_offset) {
  218   // Multiplication of two Java long values stored on the stack
  219   // as illustrated below. Result is in rdx:rax.
  220   //
  221   // rsp ---&gt; [  ??  ] \               \
  222   //            ....    | y_rsp_offset  |
  223   //          [ y_lo ] /  (in bytes)    | x_rsp_offset
  224   //          [ y_hi ]                  | (in bytes)
  225   //            ....                    |
  226   //          [ x_lo ]                 /
  227   //          [ x_hi ]
  228   //            ....
  229   //
  230   // Basic idea: lo(result) = lo(x_lo * y_lo)
  231   //             hi(result) = hi(x_lo * y_lo) + lo(x_hi * y_lo) + lo(x_lo * y_hi)
  232   Address x_hi(rsp, x_rsp_offset + wordSize); Address x_lo(rsp, x_rsp_offset);
  233   Address y_hi(rsp, y_rsp_offset + wordSize); Address y_lo(rsp, y_rsp_offset);
  234   Label quick;
  235   // load x_hi, y_hi and check if quick
  236   // multiplication is possible
  237   movl(rbx, x_hi);
  238   movl(rcx, y_hi);
  239   movl(rax, rbx);
  240   orl(rbx, rcx);                                 // rbx, = 0 &lt;=&gt; x_hi = 0 and y_hi = 0
  241   jcc(Assembler::zero, quick);                   // if rbx, = 0 do quick multiply
  242   // do full multiplication
  243   // 1st step
  244   mull(y_lo);                                    // x_hi * y_lo
  245   movl(rbx, rax);                                // save lo(x_hi * y_lo) in rbx,
  246   // 2nd step
  247   movl(rax, x_lo);
  248   mull(rcx);                                     // x_lo * y_hi
  249   addl(rbx, rax);                                // add lo(x_lo * y_hi) to rbx,
  250   // 3rd step
  251   bind(quick);                                   // note: rbx, = 0 if quick multiply!
  252   movl(rax, x_lo);
  253   mull(y_lo);                                    // x_lo * y_lo
  254   addl(rdx, rbx);                                // correct hi(x_lo * y_lo)
  255 }
  256 
  257 void MacroAssembler::lneg(Register hi, Register lo) {
  258   negl(lo);
  259   adcl(hi, 0);
  260   negl(hi);
  261 }
  262 
  263 void MacroAssembler::lshl(Register hi, Register lo) {
  264   // Java shift left long support (semantics as described in JVM spec., p.305)
  265   // (basic idea for shift counts s &gt;= n: x &lt;&lt; s == (x &lt;&lt; n) &lt;&lt; (s - n))
  266   // shift value is in rcx !
  267   assert(hi != rcx, &quot;must not use rcx&quot;);
  268   assert(lo != rcx, &quot;must not use rcx&quot;);
  269   const Register s = rcx;                        // shift count
  270   const int      n = BitsPerWord;
  271   Label L;
  272   andl(s, 0x3f);                                 // s := s &amp; 0x3f (s &lt; 0x40)
  273   cmpl(s, n);                                    // if (s &lt; n)
  274   jcc(Assembler::less, L);                       // else (s &gt;= n)
  275   movl(hi, lo);                                  // x := x &lt;&lt; n
  276   xorl(lo, lo);
  277   // Note: subl(s, n) is not needed since the Intel shift instructions work rcx mod n!
  278   bind(L);                                       // s (mod n) &lt; n
  279   shldl(hi, lo);                                 // x := x &lt;&lt; s
  280   shll(lo);
  281 }
  282 
  283 
  284 void MacroAssembler::lshr(Register hi, Register lo, bool sign_extension) {
  285   // Java shift right long support (semantics as described in JVM spec., p.306 &amp; p.310)
  286   // (basic idea for shift counts s &gt;= n: x &gt;&gt; s == (x &gt;&gt; n) &gt;&gt; (s - n))
  287   assert(hi != rcx, &quot;must not use rcx&quot;);
  288   assert(lo != rcx, &quot;must not use rcx&quot;);
  289   const Register s = rcx;                        // shift count
  290   const int      n = BitsPerWord;
  291   Label L;
  292   andl(s, 0x3f);                                 // s := s &amp; 0x3f (s &lt; 0x40)
  293   cmpl(s, n);                                    // if (s &lt; n)
  294   jcc(Assembler::less, L);                       // else (s &gt;= n)
  295   movl(lo, hi);                                  // x := x &gt;&gt; n
  296   if (sign_extension) sarl(hi, 31);
  297   else                xorl(hi, hi);
  298   // Note: subl(s, n) is not needed since the Intel shift instructions work rcx mod n!
  299   bind(L);                                       // s (mod n) &lt; n
  300   shrdl(lo, hi);                                 // x := x &gt;&gt; s
  301   if (sign_extension) sarl(hi);
  302   else                shrl(hi);
  303 }
  304 
  305 void MacroAssembler::movoop(Register dst, jobject obj) {
  306   mov_literal32(dst, (int32_t)obj, oop_Relocation::spec_for_immediate());
  307 }
  308 
  309 void MacroAssembler::movoop(Address dst, jobject obj) {
  310   mov_literal32(dst, (int32_t)obj, oop_Relocation::spec_for_immediate());
  311 }
  312 
  313 void MacroAssembler::mov_metadata(Register dst, Metadata* obj) {
  314   mov_literal32(dst, (int32_t)obj, metadata_Relocation::spec_for_immediate());
  315 }
  316 
  317 void MacroAssembler::mov_metadata(Address dst, Metadata* obj) {
  318   mov_literal32(dst, (int32_t)obj, metadata_Relocation::spec_for_immediate());
  319 }
  320 
  321 void MacroAssembler::movptr(Register dst, AddressLiteral src, Register scratch) {
  322   // scratch register is not used,
  323   // it is defined to match parameters of 64-bit version of this method.
  324   if (src.is_lval()) {
  325     mov_literal32(dst, (intptr_t)src.target(), src.rspec());
  326   } else {
  327     movl(dst, as_Address(src));
  328   }
  329 }
  330 
  331 void MacroAssembler::movptr(ArrayAddress dst, Register src) {
  332   movl(as_Address(dst), src);
  333 }
  334 
  335 void MacroAssembler::movptr(Register dst, ArrayAddress src) {
  336   movl(dst, as_Address(src));
  337 }
  338 
  339 // src should NEVER be a real pointer. Use AddressLiteral for true pointers
  340 void MacroAssembler::movptr(Address dst, intptr_t src) {
  341   movl(dst, src);
  342 }
  343 
  344 
  345 void MacroAssembler::pop_callee_saved_registers() {
  346   pop(rcx);
  347   pop(rdx);
  348   pop(rdi);
  349   pop(rsi);
  350 }
  351 
  352 void MacroAssembler::push_callee_saved_registers() {
  353   push(rsi);
  354   push(rdi);
  355   push(rdx);
  356   push(rcx);
  357 }
  358 
  359 void MacroAssembler::pushoop(jobject obj) {
  360   push_literal32((int32_t)obj, oop_Relocation::spec_for_immediate());
  361 }
  362 
  363 void MacroAssembler::pushklass(Metadata* obj) {
  364   push_literal32((int32_t)obj, metadata_Relocation::spec_for_immediate());
  365 }
  366 
  367 void MacroAssembler::pushptr(AddressLiteral src) {
  368   if (src.is_lval()) {
  369     push_literal32((int32_t)src.target(), src.rspec());
  370   } else {
  371     pushl(as_Address(src));
  372   }
  373 }
  374 
  375 void MacroAssembler::set_word_if_not_zero(Register dst) {
  376   xorl(dst, dst);
  377   set_byte_if_not_zero(dst);
  378 }
  379 
  380 static void pass_arg0(MacroAssembler* masm, Register arg) {
  381   masm-&gt;push(arg);
  382 }
  383 
  384 static void pass_arg1(MacroAssembler* masm, Register arg) {
  385   masm-&gt;push(arg);
  386 }
  387 
  388 static void pass_arg2(MacroAssembler* masm, Register arg) {
  389   masm-&gt;push(arg);
  390 }
  391 
  392 static void pass_arg3(MacroAssembler* masm, Register arg) {
  393   masm-&gt;push(arg);
  394 }
  395 
  396 #ifndef PRODUCT
  397 extern &quot;C&quot; void findpc(intptr_t x);
  398 #endif
  399 
  400 void MacroAssembler::debug32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip, char* msg) {
  401   // In order to get locks to work, we need to fake a in_VM state
  402   JavaThread* thread = JavaThread::current();
  403   JavaThreadState saved_state = thread-&gt;thread_state();
  404   thread-&gt;set_thread_state(_thread_in_vm);
  405   if (ShowMessageBoxOnError) {
  406     JavaThread* thread = JavaThread::current();
  407     JavaThreadState saved_state = thread-&gt;thread_state();
  408     thread-&gt;set_thread_state(_thread_in_vm);
  409     if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
  410       ttyLocker ttyl;
  411       BytecodeCounter::print();
  412     }
  413     // To see where a verify_oop failed, get $ebx+40/X for this frame.
  414     // This is the value of eip which points to where verify_oop will return.
  415     if (os::message_box(msg, &quot;Execution stopped, print registers?&quot;)) {
  416       print_state32(rdi, rsi, rbp, rsp, rbx, rdx, rcx, rax, eip);
  417       BREAKPOINT;
  418     }
  419   }
  420   fatal(&quot;DEBUG MESSAGE: %s&quot;, msg);
  421 }
  422 
  423 void MacroAssembler::print_state32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip) {
  424   ttyLocker ttyl;
  425   FlagSetting fs(Debugging, true);
  426   tty-&gt;print_cr(&quot;eip = 0x%08x&quot;, eip);
  427 #ifndef PRODUCT
  428   if ((WizardMode || Verbose) &amp;&amp; PrintMiscellaneous) {
  429     tty-&gt;cr();
  430     findpc(eip);
  431     tty-&gt;cr();
  432   }
  433 #endif
  434 #define PRINT_REG(rax) \
  435   { tty-&gt;print(&quot;%s = &quot;, #rax); os::print_location(tty, rax); }
  436   PRINT_REG(rax);
  437   PRINT_REG(rbx);
  438   PRINT_REG(rcx);
  439   PRINT_REG(rdx);
  440   PRINT_REG(rdi);
  441   PRINT_REG(rsi);
  442   PRINT_REG(rbp);
  443   PRINT_REG(rsp);
  444 #undef PRINT_REG
  445   // Print some words near top of staack.
  446   int* dump_sp = (int*) rsp;
  447   for (int col1 = 0; col1 &lt; 8; col1++) {
  448     tty-&gt;print(&quot;(rsp+0x%03x) 0x%08x: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
  449     os::print_location(tty, *dump_sp++);
  450   }
  451   for (int row = 0; row &lt; 16; row++) {
  452     tty-&gt;print(&quot;(rsp+0x%03x) 0x%08x: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
  453     for (int col = 0; col &lt; 8; col++) {
  454       tty-&gt;print(&quot; 0x%08x&quot;, *dump_sp++);
  455     }
  456     tty-&gt;cr();
  457   }
  458   // Print some instructions around pc:
  459   Disassembler::decode((address)eip-64, (address)eip);
  460   tty-&gt;print_cr(&quot;--------&quot;);
  461   Disassembler::decode((address)eip, (address)eip+32);
  462 }
  463 
  464 void MacroAssembler::stop(const char* msg) {
  465   ExternalAddress message((address)msg);
  466   // push address of message
  467   pushptr(message.addr());
  468   { Label L; call(L, relocInfo::none); bind(L); }     // push eip
  469   pusha();                                            // push registers
  470   call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::debug32)));
  471   hlt();
  472 }
  473 
  474 void MacroAssembler::warn(const char* msg) {
  475   push_CPU_state();
  476 
  477   ExternalAddress message((address) msg);
  478   // push address of message
  479   pushptr(message.addr());
  480 
  481   call(RuntimeAddress(CAST_FROM_FN_PTR(address, warning)));
  482   addl(rsp, wordSize);       // discard argument
  483   pop_CPU_state();
  484 }
  485 
  486 void MacroAssembler::print_state() {
  487   { Label L; call(L, relocInfo::none); bind(L); }     // push eip
  488   pusha();                                            // push registers
  489 
  490   push_CPU_state();
  491   call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::print_state32)));
  492   pop_CPU_state();
  493 
  494   popa();
  495   addl(rsp, wordSize);
  496 }
  497 
  498 #else // _LP64
  499 
  500 // 64 bit versions
  501 
  502 Address MacroAssembler::as_Address(AddressLiteral adr) {
  503   // amd64 always does this as a pc-rel
  504   // we can be absolute or disp based on the instruction type
  505   // jmp/call are displacements others are absolute
  506   assert(!adr.is_lval(), &quot;must be rval&quot;);
  507   assert(reachable(adr), &quot;must be&quot;);
  508   return Address((int32_t)(intptr_t)(adr.target() - pc()), adr.target(), adr.reloc());
  509 
  510 }
  511 
  512 Address MacroAssembler::as_Address(ArrayAddress adr) {
  513   AddressLiteral base = adr.base();
  514   lea(rscratch1, base);
  515   Address index = adr.index();
  516   assert(index._disp == 0, &quot;must not have disp&quot;); // maybe it can?
  517   Address array(rscratch1, index._index, index._scale, index._disp);
  518   return array;
  519 }
  520 
  521 void MacroAssembler::call_VM_leaf_base(address entry_point, int num_args) {
  522   Label L, E;
  523 
  524 #ifdef _WIN64
  525   // Windows always allocates space for it&#39;s register args
  526   assert(num_args &lt;= 4, &quot;only register arguments supported&quot;);
  527   subq(rsp,  frame::arg_reg_save_area_bytes);
  528 #endif
  529 
  530   // Align stack if necessary
  531   testl(rsp, 15);
  532   jcc(Assembler::zero, L);
  533 
  534   subq(rsp, 8);
  535   {
  536     call(RuntimeAddress(entry_point));
  537   }
  538   addq(rsp, 8);
  539   jmp(E);
  540 
  541   bind(L);
  542   {
  543     call(RuntimeAddress(entry_point));
  544   }
  545 
  546   bind(E);
  547 
  548 #ifdef _WIN64
  549   // restore stack pointer
  550   addq(rsp, frame::arg_reg_save_area_bytes);
  551 #endif
  552 
  553 }
  554 
  555 void MacroAssembler::cmp64(Register src1, AddressLiteral src2) {
  556   assert(!src2.is_lval(), &quot;should use cmpptr&quot;);
  557 
  558   if (reachable(src2)) {
  559     cmpq(src1, as_Address(src2));
  560   } else {
  561     lea(rscratch1, src2);
  562     Assembler::cmpq(src1, Address(rscratch1, 0));
  563   }
  564 }
  565 
  566 int MacroAssembler::corrected_idivq(Register reg) {
  567   // Full implementation of Java ldiv and lrem; checks for special
  568   // case as described in JVM spec., p.243 &amp; p.271.  The function
  569   // returns the (pc) offset of the idivl instruction - may be needed
  570   // for implicit exceptions.
  571   //
  572   //         normal case                           special case
  573   //
  574   // input : rax: dividend                         min_long
  575   //         reg: divisor   (may not be eax/edx)   -1
  576   //
  577   // output: rax: quotient  (= rax idiv reg)       min_long
  578   //         rdx: remainder (= rax irem reg)       0
  579   assert(reg != rax &amp;&amp; reg != rdx, &quot;reg cannot be rax or rdx register&quot;);
  580   static const int64_t min_long = 0x8000000000000000;
  581   Label normal_case, special_case;
  582 
  583   // check for special case
  584   cmp64(rax, ExternalAddress((address) &amp;min_long));
  585   jcc(Assembler::notEqual, normal_case);
  586   xorl(rdx, rdx); // prepare rdx for possible special case (where
  587                   // remainder = 0)
  588   cmpq(reg, -1);
  589   jcc(Assembler::equal, special_case);
  590 
  591   // handle normal case
  592   bind(normal_case);
  593   cdqq();
  594   int idivq_offset = offset();
  595   idivq(reg);
  596 
  597   // normal and special case exit
  598   bind(special_case);
  599 
  600   return idivq_offset;
  601 }
  602 
  603 void MacroAssembler::decrementq(Register reg, int value) {
  604   if (value == min_jint) { subq(reg, value); return; }
  605   if (value &lt;  0) { incrementq(reg, -value); return; }
  606   if (value == 0) {                        ; return; }
  607   if (value == 1 &amp;&amp; UseIncDec) { decq(reg) ; return; }
  608   /* else */      { subq(reg, value)       ; return; }
  609 }
  610 
  611 void MacroAssembler::decrementq(Address dst, int value) {
  612   if (value == min_jint) { subq(dst, value); return; }
  613   if (value &lt;  0) { incrementq(dst, -value); return; }
  614   if (value == 0) {                        ; return; }
  615   if (value == 1 &amp;&amp; UseIncDec) { decq(dst) ; return; }
  616   /* else */      { subq(dst, value)       ; return; }
  617 }
  618 
  619 void MacroAssembler::incrementq(AddressLiteral dst) {
  620   if (reachable(dst)) {
  621     incrementq(as_Address(dst));
  622   } else {
  623     lea(rscratch1, dst);
  624     incrementq(Address(rscratch1, 0));
  625   }
  626 }
  627 
  628 void MacroAssembler::incrementq(Register reg, int value) {
  629   if (value == min_jint) { addq(reg, value); return; }
  630   if (value &lt;  0) { decrementq(reg, -value); return; }
  631   if (value == 0) {                        ; return; }
  632   if (value == 1 &amp;&amp; UseIncDec) { incq(reg) ; return; }
  633   /* else */      { addq(reg, value)       ; return; }
  634 }
  635 
  636 void MacroAssembler::incrementq(Address dst, int value) {
  637   if (value == min_jint) { addq(dst, value); return; }
  638   if (value &lt;  0) { decrementq(dst, -value); return; }
  639   if (value == 0) {                        ; return; }
  640   if (value == 1 &amp;&amp; UseIncDec) { incq(dst) ; return; }
  641   /* else */      { addq(dst, value)       ; return; }
  642 }
  643 
  644 // 32bit can do a case table jump in one instruction but we no longer allow the base
  645 // to be installed in the Address class
  646 void MacroAssembler::jump(ArrayAddress entry) {
  647   lea(rscratch1, entry.base());
  648   Address dispatch = entry.index();
  649   assert(dispatch._base == noreg, &quot;must be&quot;);
  650   dispatch._base = rscratch1;
  651   jmp(dispatch);
  652 }
  653 
  654 void MacroAssembler::lcmp2int(Register x_hi, Register x_lo, Register y_hi, Register y_lo) {
  655   ShouldNotReachHere(); // 64bit doesn&#39;t use two regs
  656   cmpq(x_lo, y_lo);
  657 }
  658 
  659 void MacroAssembler::lea(Register dst, AddressLiteral src) {
  660     mov_literal64(dst, (intptr_t)src.target(), src.rspec());
  661 }
  662 
  663 void MacroAssembler::lea(Address dst, AddressLiteral adr) {
  664   mov_literal64(rscratch1, (intptr_t)adr.target(), adr.rspec());
  665   movptr(dst, rscratch1);
  666 }
  667 
  668 void MacroAssembler::leave() {
  669   // %%% is this really better? Why not on 32bit too?
  670   emit_int8((unsigned char)0xC9); // LEAVE
  671 }
  672 
  673 void MacroAssembler::lneg(Register hi, Register lo) {
  674   ShouldNotReachHere(); // 64bit doesn&#39;t use two regs
  675   negq(lo);
  676 }
  677 
  678 void MacroAssembler::movoop(Register dst, jobject obj) {
  679   mov_literal64(dst, (intptr_t)obj, oop_Relocation::spec_for_immediate());
  680 }
  681 
  682 void MacroAssembler::movoop(Address dst, jobject obj) {
  683   mov_literal64(rscratch1, (intptr_t)obj, oop_Relocation::spec_for_immediate());
  684   movq(dst, rscratch1);
  685 }
  686 
  687 void MacroAssembler::mov_metadata(Register dst, Metadata* obj) {
  688   mov_literal64(dst, (intptr_t)obj, metadata_Relocation::spec_for_immediate());
  689 }
  690 
  691 void MacroAssembler::mov_metadata(Address dst, Metadata* obj) {
  692   mov_literal64(rscratch1, (intptr_t)obj, metadata_Relocation::spec_for_immediate());
  693   movq(dst, rscratch1);
  694 }
  695 
  696 void MacroAssembler::movptr(Register dst, AddressLiteral src, Register scratch) {
  697   if (src.is_lval()) {
  698     mov_literal64(dst, (intptr_t)src.target(), src.rspec());
  699   } else {
  700     if (reachable(src)) {
  701       movq(dst, as_Address(src));
  702     } else {
  703       lea(scratch, src);
  704       movq(dst, Address(scratch, 0));
  705     }
  706   }
  707 }
  708 
  709 void MacroAssembler::movptr(ArrayAddress dst, Register src) {
  710   movq(as_Address(dst), src);
  711 }
  712 
  713 void MacroAssembler::movptr(Register dst, ArrayAddress src) {
  714   movq(dst, as_Address(src));
  715 }
  716 
  717 // src should NEVER be a real pointer. Use AddressLiteral for true pointers
  718 void MacroAssembler::movptr(Address dst, intptr_t src) {
  719   mov64(rscratch1, src);
  720   movq(dst, rscratch1);
  721 }
  722 
  723 // These are mostly for initializing NULL
  724 void MacroAssembler::movptr(Address dst, int32_t src) {
  725   movslq(dst, src);
  726 }
  727 
  728 void MacroAssembler::movptr(Register dst, int32_t src) {
  729   mov64(dst, (intptr_t)src);
  730 }
  731 
  732 void MacroAssembler::pushoop(jobject obj) {
  733   movoop(rscratch1, obj);
  734   push(rscratch1);
  735 }
  736 
  737 void MacroAssembler::pushklass(Metadata* obj) {
  738   mov_metadata(rscratch1, obj);
  739   push(rscratch1);
  740 }
  741 
  742 void MacroAssembler::pushptr(AddressLiteral src) {
  743   lea(rscratch1, src);
  744   if (src.is_lval()) {
  745     push(rscratch1);
  746   } else {
  747     pushq(Address(rscratch1, 0));
  748   }
  749 }
  750 
  751 void MacroAssembler::reset_last_Java_frame(bool clear_fp) {
  752   // we must set sp to zero to clear frame
  753   movptr(Address(r15_thread, JavaThread::last_Java_sp_offset()), NULL_WORD);
  754   // must clear fp, so that compiled frames are not confused; it is
  755   // possible that we need it only for debugging
  756   if (clear_fp) {
  757     movptr(Address(r15_thread, JavaThread::last_Java_fp_offset()), NULL_WORD);
  758   }
  759 
  760   // Always clear the pc because it could have been set by make_walkable()
  761   movptr(Address(r15_thread, JavaThread::last_Java_pc_offset()), NULL_WORD);
  762   vzeroupper();
  763 }
  764 
  765 void MacroAssembler::set_last_Java_frame(Register last_java_sp,
  766                                          Register last_java_fp,
  767                                          address  last_java_pc) {
  768   vzeroupper();
  769   // determine last_java_sp register
  770   if (!last_java_sp-&gt;is_valid()) {
  771     last_java_sp = rsp;
  772   }
  773 
  774   // last_java_fp is optional
  775   if (last_java_fp-&gt;is_valid()) {
  776     movptr(Address(r15_thread, JavaThread::last_Java_fp_offset()),
  777            last_java_fp);
  778   }
  779 
  780   // last_java_pc is optional
  781   if (last_java_pc != NULL) {
  782     Address java_pc(r15_thread,
  783                     JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_pc_offset());
  784     lea(rscratch1, InternalAddress(last_java_pc));
  785     movptr(java_pc, rscratch1);
  786   }
  787 
  788   movptr(Address(r15_thread, JavaThread::last_Java_sp_offset()), last_java_sp);
  789 }
  790 
  791 static void pass_arg0(MacroAssembler* masm, Register arg) {
  792   if (c_rarg0 != arg ) {
  793     masm-&gt;mov(c_rarg0, arg);
  794   }
  795 }
  796 
  797 static void pass_arg1(MacroAssembler* masm, Register arg) {
  798   if (c_rarg1 != arg ) {
  799     masm-&gt;mov(c_rarg1, arg);
  800   }
  801 }
  802 
  803 static void pass_arg2(MacroAssembler* masm, Register arg) {
  804   if (c_rarg2 != arg ) {
  805     masm-&gt;mov(c_rarg2, arg);
  806   }
  807 }
  808 
  809 static void pass_arg3(MacroAssembler* masm, Register arg) {
  810   if (c_rarg3 != arg ) {
  811     masm-&gt;mov(c_rarg3, arg);
  812   }
  813 }
  814 
  815 void MacroAssembler::stop(const char* msg) {
  816   if (ShowMessageBoxOnError) {
  817     address rip = pc();
  818     pusha(); // get regs on stack
  819     lea(c_rarg1, InternalAddress(rip));
  820     movq(c_rarg2, rsp); // pass pointer to regs array
  821   }
  822   lea(c_rarg0, ExternalAddress((address) msg));
  823   andq(rsp, -16); // align stack as required by ABI
  824   call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::debug64)));
  825   hlt();
  826 }
  827 
  828 void MacroAssembler::warn(const char* msg) {
  829   push(rbp);
  830   movq(rbp, rsp);
  831   andq(rsp, -16);     // align stack as required by push_CPU_state and call
  832   push_CPU_state();   // keeps alignment at 16 bytes
  833   lea(c_rarg0, ExternalAddress((address) msg));
  834   lea(rax, ExternalAddress(CAST_FROM_FN_PTR(address, warning)));
  835   call(rax);
  836   pop_CPU_state();
  837   mov(rsp, rbp);
  838   pop(rbp);
  839 }
  840 
  841 void MacroAssembler::print_state() {
  842   address rip = pc();
  843   pusha();            // get regs on stack
  844   push(rbp);
  845   movq(rbp, rsp);
  846   andq(rsp, -16);     // align stack as required by push_CPU_state and call
  847   push_CPU_state();   // keeps alignment at 16 bytes
  848 
  849   lea(c_rarg0, InternalAddress(rip));
  850   lea(c_rarg1, Address(rbp, wordSize)); // pass pointer to regs array
  851   call_VM_leaf(CAST_FROM_FN_PTR(address, MacroAssembler::print_state64), c_rarg0, c_rarg1);
  852 
  853   pop_CPU_state();
  854   mov(rsp, rbp);
  855   pop(rbp);
  856   popa();
  857 }
  858 
  859 #ifndef PRODUCT
  860 extern &quot;C&quot; void findpc(intptr_t x);
  861 #endif
  862 
  863 void MacroAssembler::debug64(char* msg, int64_t pc, int64_t regs[]) {
  864   // In order to get locks to work, we need to fake a in_VM state
  865   if (ShowMessageBoxOnError) {
  866     JavaThread* thread = JavaThread::current();
  867     JavaThreadState saved_state = thread-&gt;thread_state();
  868     thread-&gt;set_thread_state(_thread_in_vm);
  869 #ifndef PRODUCT
  870     if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
  871       ttyLocker ttyl;
  872       BytecodeCounter::print();
  873     }
  874 #endif
  875     // To see where a verify_oop failed, get $ebx+40/X for this frame.
  876     // XXX correct this offset for amd64
  877     // This is the value of eip which points to where verify_oop will return.
  878     if (os::message_box(msg, &quot;Execution stopped, print registers?&quot;)) {
  879       print_state64(pc, regs);
  880       BREAKPOINT;
  881     }
  882   }
  883   fatal(&quot;DEBUG MESSAGE: %s&quot;, msg);
  884 }
  885 
  886 void MacroAssembler::print_state64(int64_t pc, int64_t regs[]) {
  887   ttyLocker ttyl;
  888   FlagSetting fs(Debugging, true);
  889   tty-&gt;print_cr(&quot;rip = 0x%016lx&quot;, (intptr_t)pc);
  890 #ifndef PRODUCT
  891   tty-&gt;cr();
  892   findpc(pc);
  893   tty-&gt;cr();
  894 #endif
  895 #define PRINT_REG(rax, value) \
  896   { tty-&gt;print(&quot;%s = &quot;, #rax); os::print_location(tty, value); }
  897   PRINT_REG(rax, regs[15]);
  898   PRINT_REG(rbx, regs[12]);
  899   PRINT_REG(rcx, regs[14]);
  900   PRINT_REG(rdx, regs[13]);
  901   PRINT_REG(rdi, regs[8]);
  902   PRINT_REG(rsi, regs[9]);
  903   PRINT_REG(rbp, regs[10]);
  904   PRINT_REG(rsp, regs[11]);
  905   PRINT_REG(r8 , regs[7]);
  906   PRINT_REG(r9 , regs[6]);
  907   PRINT_REG(r10, regs[5]);
  908   PRINT_REG(r11, regs[4]);
  909   PRINT_REG(r12, regs[3]);
  910   PRINT_REG(r13, regs[2]);
  911   PRINT_REG(r14, regs[1]);
  912   PRINT_REG(r15, regs[0]);
  913 #undef PRINT_REG
  914   // Print some words near top of staack.
  915   int64_t* rsp = (int64_t*) regs[11];
  916   int64_t* dump_sp = rsp;
  917   for (int col1 = 0; col1 &lt; 8; col1++) {
  918     tty-&gt;print(&quot;(rsp+0x%03x) 0x%016lx: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
  919     os::print_location(tty, *dump_sp++);
  920   }
  921   for (int row = 0; row &lt; 25; row++) {
  922     tty-&gt;print(&quot;(rsp+0x%03x) 0x%016lx: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
  923     for (int col = 0; col &lt; 4; col++) {
  924       tty-&gt;print(&quot; 0x%016lx&quot;, (intptr_t)*dump_sp++);
  925     }
  926     tty-&gt;cr();
  927   }
  928   // Print some instructions around pc:
  929   Disassembler::decode((address)pc-64, (address)pc);
  930   tty-&gt;print_cr(&quot;--------&quot;);
  931   Disassembler::decode((address)pc, (address)pc+32);
  932 }
  933 
  934 #endif // _LP64
  935 
  936 // Now versions that are common to 32/64 bit
  937 
  938 void MacroAssembler::addptr(Register dst, int32_t imm32) {
  939   LP64_ONLY(addq(dst, imm32)) NOT_LP64(addl(dst, imm32));
  940 }
  941 
  942 void MacroAssembler::addptr(Register dst, Register src) {
  943   LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src));
  944 }
  945 
  946 void MacroAssembler::addptr(Address dst, Register src) {
  947   LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src));
  948 }
  949 
  950 void MacroAssembler::addsd(XMMRegister dst, AddressLiteral src) {
  951   if (reachable(src)) {
  952     Assembler::addsd(dst, as_Address(src));
  953   } else {
  954     lea(rscratch1, src);
  955     Assembler::addsd(dst, Address(rscratch1, 0));
  956   }
  957 }
  958 
  959 void MacroAssembler::addss(XMMRegister dst, AddressLiteral src) {
  960   if (reachable(src)) {
  961     addss(dst, as_Address(src));
  962   } else {
  963     lea(rscratch1, src);
  964     addss(dst, Address(rscratch1, 0));
  965   }
  966 }
  967 
  968 void MacroAssembler::addpd(XMMRegister dst, AddressLiteral src) {
  969   if (reachable(src)) {
  970     Assembler::addpd(dst, as_Address(src));
  971   } else {
  972     lea(rscratch1, src);
  973     Assembler::addpd(dst, Address(rscratch1, 0));
  974   }
  975 }
  976 
  977 void MacroAssembler::align(int modulus) {
  978   align(modulus, offset());
  979 }
  980 
  981 void MacroAssembler::align(int modulus, int target) {
  982   if (target % modulus != 0) {
  983     nop(modulus - (target % modulus));
  984   }
  985 }
  986 
  987 void MacroAssembler::andpd(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
  988   // Used in sign-masking with aligned address.
  989   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
  990   if (reachable(src)) {
  991     Assembler::andpd(dst, as_Address(src));
  992   } else {
  993     lea(scratch_reg, src);
  994     Assembler::andpd(dst, Address(scratch_reg, 0));
  995   }
  996 }
  997 
  998 void MacroAssembler::andps(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
  999   // Used in sign-masking with aligned address.
 1000   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
 1001   if (reachable(src)) {
 1002     Assembler::andps(dst, as_Address(src));
 1003   } else {
 1004     lea(scratch_reg, src);
 1005     Assembler::andps(dst, Address(scratch_reg, 0));
 1006   }
 1007 }
 1008 
 1009 void MacroAssembler::andptr(Register dst, int32_t imm32) {
 1010   LP64_ONLY(andq(dst, imm32)) NOT_LP64(andl(dst, imm32));
 1011 }
 1012 
 1013 void MacroAssembler::atomic_incl(Address counter_addr) {
 1014   lock();
 1015   incrementl(counter_addr);
 1016 }
 1017 
 1018 void MacroAssembler::atomic_incl(AddressLiteral counter_addr, Register scr) {
 1019   if (reachable(counter_addr)) {
 1020     atomic_incl(as_Address(counter_addr));
 1021   } else {
 1022     lea(scr, counter_addr);
 1023     atomic_incl(Address(scr, 0));
 1024   }
 1025 }
 1026 
 1027 #ifdef _LP64
 1028 void MacroAssembler::atomic_incq(Address counter_addr) {
 1029   lock();
 1030   incrementq(counter_addr);
 1031 }
 1032 
 1033 void MacroAssembler::atomic_incq(AddressLiteral counter_addr, Register scr) {
 1034   if (reachable(counter_addr)) {
 1035     atomic_incq(as_Address(counter_addr));
 1036   } else {
 1037     lea(scr, counter_addr);
 1038     atomic_incq(Address(scr, 0));
 1039   }
 1040 }
 1041 #endif
 1042 
 1043 // Writes to stack successive pages until offset reached to check for
 1044 // stack overflow + shadow pages.  This clobbers tmp.
 1045 void MacroAssembler::bang_stack_size(Register size, Register tmp) {
 1046   movptr(tmp, rsp);
 1047   // Bang stack for total size given plus shadow page size.
 1048   // Bang one page at a time because large size can bang beyond yellow and
 1049   // red zones.
 1050   Label loop;
 1051   bind(loop);
 1052   movl(Address(tmp, (-os::vm_page_size())), size );
 1053   subptr(tmp, os::vm_page_size());
 1054   subl(size, os::vm_page_size());
 1055   jcc(Assembler::greater, loop);
 1056 
 1057   // Bang down shadow pages too.
 1058   // At this point, (tmp-0) is the last address touched, so don&#39;t
 1059   // touch it again.  (It was touched as (tmp-pagesize) but then tmp
 1060   // was post-decremented.)  Skip this address by starting at i=1, and
 1061   // touch a few more pages below.  N.B.  It is important to touch all
 1062   // the way down including all pages in the shadow zone.
 1063   for (int i = 1; i &lt; ((int)JavaThread::stack_shadow_zone_size() / os::vm_page_size()); i++) {
 1064     // this could be any sized move but this is can be a debugging crumb
 1065     // so the bigger the better.
 1066     movptr(Address(tmp, (-i*os::vm_page_size())), size );
 1067   }
 1068 }
 1069 
 1070 void MacroAssembler::reserved_stack_check() {
 1071     // testing if reserved zone needs to be enabled
 1072     Label no_reserved_zone_enabling;
 1073     Register thread = NOT_LP64(rsi) LP64_ONLY(r15_thread);
 1074     NOT_LP64(get_thread(rsi);)
 1075 
 1076     cmpptr(rsp, Address(thread, JavaThread::reserved_stack_activation_offset()));
 1077     jcc(Assembler::below, no_reserved_zone_enabling);
 1078 
 1079     call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::enable_stack_reserved_zone), thread);
 1080     jump(RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()));
 1081     should_not_reach_here();
 1082 
 1083     bind(no_reserved_zone_enabling);
 1084 }
 1085 
 1086 int MacroAssembler::biased_locking_enter(Register lock_reg,
 1087                                          Register obj_reg,
 1088                                          Register swap_reg,
 1089                                          Register tmp_reg,
 1090                                          bool swap_reg_contains_mark,
 1091                                          Label&amp; done,
 1092                                          Label* slow_case,
 1093                                          BiasedLockingCounters* counters) {
 1094   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
 1095   assert(swap_reg == rax, &quot;swap_reg must be rax for cmpxchgq&quot;);
 1096   assert(tmp_reg != noreg, &quot;tmp_reg must be supplied&quot;);
 1097   assert_different_registers(lock_reg, obj_reg, swap_reg, tmp_reg);
 1098   assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, &quot;biased locking makes assumptions about bit layout&quot;);
 1099   Address mark_addr      (obj_reg, oopDesc::mark_offset_in_bytes());
 1100   NOT_LP64( Address saved_mark_addr(lock_reg, 0); )
 1101 
 1102   if (PrintBiasedLockingStatistics &amp;&amp; counters == NULL) {
 1103     counters = BiasedLocking::counters();
 1104   }
 1105   // Biased locking
 1106   // See whether the lock is currently biased toward our thread and
 1107   // whether the epoch is still valid
 1108   // Note that the runtime guarantees sufficient alignment of JavaThread
 1109   // pointers to allow age to be placed into low bits
 1110   // First check to see whether biasing is even enabled for this object
 1111   Label cas_label;
 1112   int null_check_offset = -1;
 1113   if (!swap_reg_contains_mark) {
 1114     null_check_offset = offset();
 1115     movptr(swap_reg, mark_addr);
 1116   }
 1117   movptr(tmp_reg, swap_reg);
 1118   andptr(tmp_reg, markWord::biased_lock_mask_in_place);
 1119   cmpptr(tmp_reg, markWord::biased_lock_pattern);
 1120   jcc(Assembler::notEqual, cas_label);
 1121   // The bias pattern is present in the object&#39;s header. Need to check
 1122   // whether the bias owner and the epoch are both still current.
 1123 #ifndef _LP64
 1124   // Note that because there is no current thread register on x86_32 we
 1125   // need to store off the mark word we read out of the object to
 1126   // avoid reloading it and needing to recheck invariants below. This
 1127   // store is unfortunate but it makes the overall code shorter and
 1128   // simpler.
 1129   movptr(saved_mark_addr, swap_reg);
 1130 #endif
 1131   if (swap_reg_contains_mark) {
 1132     null_check_offset = offset();
 1133   }
 1134   load_prototype_header(tmp_reg, obj_reg);
 1135 #ifdef _LP64
 1136   orptr(tmp_reg, r15_thread);
 1137   xorptr(tmp_reg, swap_reg);
 1138   Register header_reg = tmp_reg;
 1139 #else
 1140   xorptr(tmp_reg, swap_reg);
 1141   get_thread(swap_reg);
 1142   xorptr(swap_reg, tmp_reg);
 1143   Register header_reg = swap_reg;
 1144 #endif
 1145   andptr(header_reg, ~((int) markWord::age_mask_in_place));
 1146   if (counters != NULL) {
 1147     cond_inc32(Assembler::zero,
 1148                ExternalAddress((address) counters-&gt;biased_lock_entry_count_addr()));
 1149   }
 1150   jcc(Assembler::equal, done);
 1151 
 1152   Label try_revoke_bias;
 1153   Label try_rebias;
 1154 
 1155   // At this point we know that the header has the bias pattern and
 1156   // that we are not the bias owner in the current epoch. We need to
 1157   // figure out more details about the state of the header in order to
 1158   // know what operations can be legally performed on the object&#39;s
 1159   // header.
 1160 
 1161   // If the low three bits in the xor result aren&#39;t clear, that means
 1162   // the prototype header is no longer biased and we have to revoke
 1163   // the bias on this object.
 1164   testptr(header_reg, markWord::biased_lock_mask_in_place);
 1165   jccb(Assembler::notZero, try_revoke_bias);
 1166 
 1167   // Biasing is still enabled for this data type. See whether the
 1168   // epoch of the current bias is still valid, meaning that the epoch
 1169   // bits of the mark word are equal to the epoch bits of the
 1170   // prototype header. (Note that the prototype header&#39;s epoch bits
 1171   // only change at a safepoint.) If not, attempt to rebias the object
 1172   // toward the current thread. Note that we must be absolutely sure
 1173   // that the current epoch is invalid in order to do this because
 1174   // otherwise the manipulations it performs on the mark word are
 1175   // illegal.
 1176   testptr(header_reg, markWord::epoch_mask_in_place);
 1177   jccb(Assembler::notZero, try_rebias);
 1178 
 1179   // The epoch of the current bias is still valid but we know nothing
 1180   // about the owner; it might be set or it might be clear. Try to
 1181   // acquire the bias of the object using an atomic operation. If this
 1182   // fails we will go in to the runtime to revoke the object&#39;s bias.
 1183   // Note that we first construct the presumed unbiased header so we
 1184   // don&#39;t accidentally blow away another thread&#39;s valid bias.
 1185   NOT_LP64( movptr(swap_reg, saved_mark_addr); )
 1186   andptr(swap_reg,
 1187          markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);
 1188 #ifdef _LP64
 1189   movptr(tmp_reg, swap_reg);
 1190   orptr(tmp_reg, r15_thread);
 1191 #else
 1192   get_thread(tmp_reg);
 1193   orptr(tmp_reg, swap_reg);
 1194 #endif
 1195   lock();
 1196   cmpxchgptr(tmp_reg, mark_addr); // compare tmp_reg and swap_reg
 1197   // If the biasing toward our thread failed, this means that
 1198   // another thread succeeded in biasing it toward itself and we
 1199   // need to revoke that bias. The revocation will occur in the
 1200   // interpreter runtime in the slow case.
 1201   if (counters != NULL) {
 1202     cond_inc32(Assembler::zero,
 1203                ExternalAddress((address) counters-&gt;anonymously_biased_lock_entry_count_addr()));
 1204   }
 1205   if (slow_case != NULL) {
 1206     jcc(Assembler::notZero, *slow_case);
 1207   }
 1208   jmp(done);
 1209 
 1210   bind(try_rebias);
 1211   // At this point we know the epoch has expired, meaning that the
 1212   // current &quot;bias owner&quot;, if any, is actually invalid. Under these
 1213   // circumstances _only_, we are allowed to use the current header&#39;s
 1214   // value as the comparison value when doing the cas to acquire the
 1215   // bias in the current epoch. In other words, we allow transfer of
 1216   // the bias from one thread to another directly in this situation.
 1217   //
 1218   // FIXME: due to a lack of registers we currently blow away the age
 1219   // bits in this situation. Should attempt to preserve them.
 1220   load_prototype_header(tmp_reg, obj_reg);
 1221 #ifdef _LP64
 1222   orptr(tmp_reg, r15_thread);
 1223 #else
 1224   get_thread(swap_reg);
 1225   orptr(tmp_reg, swap_reg);
 1226   movptr(swap_reg, saved_mark_addr);
 1227 #endif
 1228   lock();
 1229   cmpxchgptr(tmp_reg, mark_addr); // compare tmp_reg and swap_reg
 1230   // If the biasing toward our thread failed, then another thread
 1231   // succeeded in biasing it toward itself and we need to revoke that
 1232   // bias. The revocation will occur in the runtime in the slow case.
 1233   if (counters != NULL) {
 1234     cond_inc32(Assembler::zero,
 1235                ExternalAddress((address) counters-&gt;rebiased_lock_entry_count_addr()));
 1236   }
 1237   if (slow_case != NULL) {
 1238     jcc(Assembler::notZero, *slow_case);
 1239   }
 1240   jmp(done);
 1241 
 1242   bind(try_revoke_bias);
 1243   // The prototype mark in the klass doesn&#39;t have the bias bit set any
 1244   // more, indicating that objects of this data type are not supposed
 1245   // to be biased any more. We are going to try to reset the mark of
 1246   // this object to the prototype value and fall through to the
 1247   // CAS-based locking scheme. Note that if our CAS fails, it means
 1248   // that another thread raced us for the privilege of revoking the
 1249   // bias of this particular object, so it&#39;s okay to continue in the
 1250   // normal locking code.
 1251   //
 1252   // FIXME: due to a lack of registers we currently blow away the age
 1253   // bits in this situation. Should attempt to preserve them.
 1254   NOT_LP64( movptr(swap_reg, saved_mark_addr); )
 1255   load_prototype_header(tmp_reg, obj_reg);
 1256   lock();
 1257   cmpxchgptr(tmp_reg, mark_addr); // compare tmp_reg and swap_reg
 1258   // Fall through to the normal CAS-based lock, because no matter what
 1259   // the result of the above CAS, some thread must have succeeded in
 1260   // removing the bias bit from the object&#39;s header.
 1261   if (counters != NULL) {
 1262     cond_inc32(Assembler::zero,
 1263                ExternalAddress((address) counters-&gt;revoked_lock_entry_count_addr()));
 1264   }
 1265 
 1266   bind(cas_label);
 1267 
 1268   return null_check_offset;
 1269 }
 1270 
 1271 void MacroAssembler::biased_locking_exit(Register obj_reg, Register temp_reg, Label&amp; done) {
 1272   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
 1273 
 1274   // Check for biased locking unlock case, which is a no-op
 1275   // Note: we do not have to check the thread ID for two reasons.
 1276   // First, the interpreter checks for IllegalMonitorStateException at
 1277   // a higher level. Second, if the bias was revoked while we held the
 1278   // lock, the object could not be rebiased toward another thread, so
 1279   // the bias bit would be clear.
 1280   movptr(temp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
 1281   andptr(temp_reg, markWord::biased_lock_mask_in_place);
 1282   cmpptr(temp_reg, markWord::biased_lock_pattern);
 1283   jcc(Assembler::equal, done);
 1284 }
 1285 
 1286 #ifdef COMPILER2
 1287 
 1288 #if INCLUDE_RTM_OPT
 1289 
 1290 // Update rtm_counters based on abort status
 1291 // input: abort_status
 1292 //        rtm_counters (RTMLockingCounters*)
 1293 // flags are killed
 1294 void MacroAssembler::rtm_counters_update(Register abort_status, Register rtm_counters) {
 1295 
 1296   atomic_incptr(Address(rtm_counters, RTMLockingCounters::abort_count_offset()));
 1297   if (PrintPreciseRTMLockingStatistics) {
 1298     for (int i = 0; i &lt; RTMLockingCounters::ABORT_STATUS_LIMIT; i++) {
 1299       Label check_abort;
 1300       testl(abort_status, (1&lt;&lt;i));
 1301       jccb(Assembler::equal, check_abort);
 1302       atomic_incptr(Address(rtm_counters, RTMLockingCounters::abortX_count_offset() + (i * sizeof(uintx))));
 1303       bind(check_abort);
 1304     }
 1305   }
 1306 }
 1307 
 1308 // Branch if (random &amp; (count-1) != 0), count is 2^n
 1309 // tmp, scr and flags are killed
 1310 void MacroAssembler::branch_on_random_using_rdtsc(Register tmp, Register scr, int count, Label&amp; brLabel) {
 1311   assert(tmp == rax, &quot;&quot;);
 1312   assert(scr == rdx, &quot;&quot;);
 1313   rdtsc(); // modifies EDX:EAX
 1314   andptr(tmp, count-1);
 1315   jccb(Assembler::notZero, brLabel);
 1316 }
 1317 
 1318 // Perform abort ratio calculation, set no_rtm bit if high ratio
 1319 // input:  rtm_counters_Reg (RTMLockingCounters* address)
 1320 // tmpReg, rtm_counters_Reg and flags are killed
 1321 void MacroAssembler::rtm_abort_ratio_calculation(Register tmpReg,
 1322                                                  Register rtm_counters_Reg,
 1323                                                  RTMLockingCounters* rtm_counters,
 1324                                                  Metadata* method_data) {
 1325   Label L_done, L_check_always_rtm1, L_check_always_rtm2;
 1326 
 1327   if (RTMLockingCalculationDelay &gt; 0) {
 1328     // Delay calculation
 1329     movptr(tmpReg, ExternalAddress((address) RTMLockingCounters::rtm_calculation_flag_addr()), tmpReg);
 1330     testptr(tmpReg, tmpReg);
 1331     jccb(Assembler::equal, L_done);
 1332   }
 1333   // Abort ratio calculation only if abort_count &gt; RTMAbortThreshold
 1334   //   Aborted transactions = abort_count * 100
 1335   //   All transactions = total_count *  RTMTotalCountIncrRate
 1336   //   Set no_rtm bit if (Aborted transactions &gt;= All transactions * RTMAbortRatio)
 1337 
 1338   movptr(tmpReg, Address(rtm_counters_Reg, RTMLockingCounters::abort_count_offset()));
 1339   cmpptr(tmpReg, RTMAbortThreshold);
 1340   jccb(Assembler::below, L_check_always_rtm2);
 1341   imulptr(tmpReg, tmpReg, 100);
 1342 
 1343   Register scrReg = rtm_counters_Reg;
 1344   movptr(scrReg, Address(rtm_counters_Reg, RTMLockingCounters::total_count_offset()));
 1345   imulptr(scrReg, scrReg, RTMTotalCountIncrRate);
 1346   imulptr(scrReg, scrReg, RTMAbortRatio);
 1347   cmpptr(tmpReg, scrReg);
 1348   jccb(Assembler::below, L_check_always_rtm1);
 1349   if (method_data != NULL) {
 1350     // set rtm_state to &quot;no rtm&quot; in MDO
 1351     mov_metadata(tmpReg, method_data);
 1352     lock();
 1353     orl(Address(tmpReg, MethodData::rtm_state_offset_in_bytes()), NoRTM);
 1354   }
 1355   jmpb(L_done);
 1356   bind(L_check_always_rtm1);
 1357   // Reload RTMLockingCounters* address
 1358   lea(rtm_counters_Reg, ExternalAddress((address)rtm_counters));
 1359   bind(L_check_always_rtm2);
 1360   movptr(tmpReg, Address(rtm_counters_Reg, RTMLockingCounters::total_count_offset()));
 1361   cmpptr(tmpReg, RTMLockingThreshold / RTMTotalCountIncrRate);
 1362   jccb(Assembler::below, L_done);
 1363   if (method_data != NULL) {
 1364     // set rtm_state to &quot;always rtm&quot; in MDO
 1365     mov_metadata(tmpReg, method_data);
 1366     lock();
 1367     orl(Address(tmpReg, MethodData::rtm_state_offset_in_bytes()), UseRTM);
 1368   }
 1369   bind(L_done);
 1370 }
 1371 
 1372 // Update counters and perform abort ratio calculation
 1373 // input:  abort_status_Reg
 1374 // rtm_counters_Reg, flags are killed
 1375 void MacroAssembler::rtm_profiling(Register abort_status_Reg,
 1376                                    Register rtm_counters_Reg,
 1377                                    RTMLockingCounters* rtm_counters,
 1378                                    Metadata* method_data,
 1379                                    bool profile_rtm) {
 1380 
 1381   assert(rtm_counters != NULL, &quot;should not be NULL when profiling RTM&quot;);
 1382   // update rtm counters based on rax value at abort
 1383   // reads abort_status_Reg, updates flags
 1384   lea(rtm_counters_Reg, ExternalAddress((address)rtm_counters));
 1385   rtm_counters_update(abort_status_Reg, rtm_counters_Reg);
 1386   if (profile_rtm) {
 1387     // Save abort status because abort_status_Reg is used by following code.
 1388     if (RTMRetryCount &gt; 0) {
 1389       push(abort_status_Reg);
 1390     }
 1391     assert(rtm_counters != NULL, &quot;should not be NULL when profiling RTM&quot;);
 1392     rtm_abort_ratio_calculation(abort_status_Reg, rtm_counters_Reg, rtm_counters, method_data);
 1393     // restore abort status
 1394     if (RTMRetryCount &gt; 0) {
 1395       pop(abort_status_Reg);
 1396     }
 1397   }
 1398 }
 1399 
 1400 // Retry on abort if abort&#39;s status is 0x6: can retry (0x2) | memory conflict (0x4)
 1401 // inputs: retry_count_Reg
 1402 //       : abort_status_Reg
 1403 // output: retry_count_Reg decremented by 1
 1404 // flags are killed
 1405 void MacroAssembler::rtm_retry_lock_on_abort(Register retry_count_Reg, Register abort_status_Reg, Label&amp; retryLabel) {
 1406   Label doneRetry;
 1407   assert(abort_status_Reg == rax, &quot;&quot;);
 1408   // The abort reason bits are in eax (see all states in rtmLocking.hpp)
 1409   // 0x6 = conflict on which we can retry (0x2) | memory conflict (0x4)
 1410   // if reason is in 0x6 and retry count != 0 then retry
 1411   andptr(abort_status_Reg, 0x6);
 1412   jccb(Assembler::zero, doneRetry);
 1413   testl(retry_count_Reg, retry_count_Reg);
 1414   jccb(Assembler::zero, doneRetry);
 1415   pause();
 1416   decrementl(retry_count_Reg);
 1417   jmp(retryLabel);
 1418   bind(doneRetry);
 1419 }
 1420 
 1421 // Spin and retry if lock is busy,
 1422 // inputs: box_Reg (monitor address)
 1423 //       : retry_count_Reg
 1424 // output: retry_count_Reg decremented by 1
 1425 //       : clear z flag if retry count exceeded
 1426 // tmp_Reg, scr_Reg, flags are killed
 1427 void MacroAssembler::rtm_retry_lock_on_busy(Register retry_count_Reg, Register box_Reg,
 1428                                             Register tmp_Reg, Register scr_Reg, Label&amp; retryLabel) {
 1429   Label SpinLoop, SpinExit, doneRetry;
 1430   int owner_offset = OM_OFFSET_NO_MONITOR_VALUE_TAG(owner);
 1431 
 1432   testl(retry_count_Reg, retry_count_Reg);
 1433   jccb(Assembler::zero, doneRetry);
 1434   decrementl(retry_count_Reg);
 1435   movptr(scr_Reg, RTMSpinLoopCount);
 1436 
 1437   bind(SpinLoop);
 1438   pause();
 1439   decrementl(scr_Reg);
 1440   jccb(Assembler::lessEqual, SpinExit);
 1441   movptr(tmp_Reg, Address(box_Reg, owner_offset));
 1442   testptr(tmp_Reg, tmp_Reg);
 1443   jccb(Assembler::notZero, SpinLoop);
 1444 
 1445   bind(SpinExit);
 1446   jmp(retryLabel);
 1447   bind(doneRetry);
 1448   incrementl(retry_count_Reg); // clear z flag
 1449 }
 1450 
 1451 // Use RTM for normal stack locks
 1452 // Input: objReg (object to lock)
 1453 void MacroAssembler::rtm_stack_locking(Register objReg, Register tmpReg, Register scrReg,
 1454                                        Register retry_on_abort_count_Reg,
 1455                                        RTMLockingCounters* stack_rtm_counters,
 1456                                        Metadata* method_data, bool profile_rtm,
 1457                                        Label&amp; DONE_LABEL, Label&amp; IsInflated) {
 1458   assert(UseRTMForStackLocks, &quot;why call this otherwise?&quot;);
 1459   assert(!UseBiasedLocking, &quot;Biased locking is not supported with RTM locking&quot;);
 1460   assert(tmpReg == rax, &quot;&quot;);
 1461   assert(scrReg == rdx, &quot;&quot;);
 1462   Label L_rtm_retry, L_decrement_retry, L_on_abort;
 1463 
 1464   if (RTMRetryCount &gt; 0) {
 1465     movl(retry_on_abort_count_Reg, RTMRetryCount); // Retry on abort
 1466     bind(L_rtm_retry);
 1467   }
 1468   movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));
 1469   testptr(tmpReg, markWord::monitor_value);  // inflated vs stack-locked|neutral|biased
 1470   jcc(Assembler::notZero, IsInflated);
 1471 
 1472   if (PrintPreciseRTMLockingStatistics || profile_rtm) {
 1473     Label L_noincrement;
 1474     if (RTMTotalCountIncrRate &gt; 1) {
 1475       // tmpReg, scrReg and flags are killed
 1476       branch_on_random_using_rdtsc(tmpReg, scrReg, RTMTotalCountIncrRate, L_noincrement);
 1477     }
 1478     assert(stack_rtm_counters != NULL, &quot;should not be NULL when profiling RTM&quot;);
 1479     atomic_incptr(ExternalAddress((address)stack_rtm_counters-&gt;total_count_addr()), scrReg);
 1480     bind(L_noincrement);
 1481   }
 1482   xbegin(L_on_abort);
 1483   movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));       // fetch markword
 1484   andptr(tmpReg, markWord::biased_lock_mask_in_place); // look at 3 lock bits
 1485   cmpptr(tmpReg, markWord::unlocked_value);            // bits = 001 unlocked
 1486   jcc(Assembler::equal, DONE_LABEL);        // all done if unlocked
 1487 
 1488   Register abort_status_Reg = tmpReg; // status of abort is stored in RAX
 1489   if (UseRTMXendForLockBusy) {
 1490     xend();
 1491     movptr(abort_status_Reg, 0x2);   // Set the abort status to 2 (so we can retry)
 1492     jmp(L_decrement_retry);
 1493   }
 1494   else {
 1495     xabort(0);
 1496   }
 1497   bind(L_on_abort);
 1498   if (PrintPreciseRTMLockingStatistics || profile_rtm) {
 1499     rtm_profiling(abort_status_Reg, scrReg, stack_rtm_counters, method_data, profile_rtm);
 1500   }
 1501   bind(L_decrement_retry);
 1502   if (RTMRetryCount &gt; 0) {
 1503     // retry on lock abort if abort status is &#39;can retry&#39; (0x2) or &#39;memory conflict&#39; (0x4)
 1504     rtm_retry_lock_on_abort(retry_on_abort_count_Reg, abort_status_Reg, L_rtm_retry);
 1505   }
 1506 }
 1507 
 1508 // Use RTM for inflating locks
 1509 // inputs: objReg (object to lock)
 1510 //         boxReg (on-stack box address (displaced header location) - KILLED)
 1511 //         tmpReg (ObjectMonitor address + markWord::monitor_value)
 1512 void MacroAssembler::rtm_inflated_locking(Register objReg, Register boxReg, Register tmpReg,
 1513                                           Register scrReg, Register retry_on_busy_count_Reg,
 1514                                           Register retry_on_abort_count_Reg,
 1515                                           RTMLockingCounters* rtm_counters,
 1516                                           Metadata* method_data, bool profile_rtm,
 1517                                           Label&amp; DONE_LABEL) {
 1518   assert(UseRTMLocking, &quot;why call this otherwise?&quot;);
 1519   assert(tmpReg == rax, &quot;&quot;);
 1520   assert(scrReg == rdx, &quot;&quot;);
 1521   Label L_rtm_retry, L_decrement_retry, L_on_abort;
 1522   int owner_offset = OM_OFFSET_NO_MONITOR_VALUE_TAG(owner);
 1523 
 1524   // Without cast to int32_t this style of movptr will destroy r10 which is typically obj.
 1525   movptr(Address(boxReg, 0), (int32_t)intptr_t(markWord::unused_mark().value()));
 1526   movptr(boxReg, tmpReg); // Save ObjectMonitor address
 1527 
 1528   if (RTMRetryCount &gt; 0) {
 1529     movl(retry_on_busy_count_Reg, RTMRetryCount);  // Retry on lock busy
 1530     movl(retry_on_abort_count_Reg, RTMRetryCount); // Retry on abort
 1531     bind(L_rtm_retry);
 1532   }
 1533   if (PrintPreciseRTMLockingStatistics || profile_rtm) {
 1534     Label L_noincrement;
 1535     if (RTMTotalCountIncrRate &gt; 1) {
 1536       // tmpReg, scrReg and flags are killed
 1537       branch_on_random_using_rdtsc(tmpReg, scrReg, RTMTotalCountIncrRate, L_noincrement);
 1538     }
 1539     assert(rtm_counters != NULL, &quot;should not be NULL when profiling RTM&quot;);
 1540     atomic_incptr(ExternalAddress((address)rtm_counters-&gt;total_count_addr()), scrReg);
 1541     bind(L_noincrement);
 1542   }
 1543   xbegin(L_on_abort);
 1544   movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));
 1545   movptr(tmpReg, Address(tmpReg, owner_offset));
 1546   testptr(tmpReg, tmpReg);
 1547   jcc(Assembler::zero, DONE_LABEL);
 1548   if (UseRTMXendForLockBusy) {
 1549     xend();
 1550     jmp(L_decrement_retry);
 1551   }
 1552   else {
 1553     xabort(0);
 1554   }
 1555   bind(L_on_abort);
 1556   Register abort_status_Reg = tmpReg; // status of abort is stored in RAX
 1557   if (PrintPreciseRTMLockingStatistics || profile_rtm) {
 1558     rtm_profiling(abort_status_Reg, scrReg, rtm_counters, method_data, profile_rtm);
 1559   }
 1560   if (RTMRetryCount &gt; 0) {
 1561     // retry on lock abort if abort status is &#39;can retry&#39; (0x2) or &#39;memory conflict&#39; (0x4)
 1562     rtm_retry_lock_on_abort(retry_on_abort_count_Reg, abort_status_Reg, L_rtm_retry);
 1563   }
 1564 
 1565   movptr(tmpReg, Address(boxReg, owner_offset)) ;
 1566   testptr(tmpReg, tmpReg) ;
 1567   jccb(Assembler::notZero, L_decrement_retry) ;
 1568 
 1569   // Appears unlocked - try to swing _owner from null to non-null.
 1570   // Invariant: tmpReg == 0.  tmpReg is EAX which is the implicit cmpxchg comparand.
 1571 #ifdef _LP64
 1572   Register threadReg = r15_thread;
 1573 #else
 1574   get_thread(scrReg);
 1575   Register threadReg = scrReg;
 1576 #endif
 1577   lock();
 1578   cmpxchgptr(threadReg, Address(boxReg, owner_offset)); // Updates tmpReg
 1579 
 1580   if (RTMRetryCount &gt; 0) {
 1581     // success done else retry
 1582     jccb(Assembler::equal, DONE_LABEL) ;
 1583     bind(L_decrement_retry);
 1584     // Spin and retry if lock is busy.
 1585     rtm_retry_lock_on_busy(retry_on_busy_count_Reg, boxReg, tmpReg, scrReg, L_rtm_retry);
 1586   }
 1587   else {
 1588     bind(L_decrement_retry);
 1589   }
 1590 }
 1591 
 1592 #endif //  INCLUDE_RTM_OPT
 1593 
 1594 // fast_lock and fast_unlock used by C2
 1595 
 1596 // Because the transitions from emitted code to the runtime
 1597 // monitorenter/exit helper stubs are so slow it&#39;s critical that
 1598 // we inline both the stack-locking fast path and the inflated fast path.
 1599 //
 1600 // See also: cmpFastLock and cmpFastUnlock.
 1601 //
 1602 // What follows is a specialized inline transliteration of the code
 1603 // in enter() and exit(). If we&#39;re concerned about I$ bloat another
 1604 // option would be to emit TrySlowEnter and TrySlowExit methods
 1605 // at startup-time.  These methods would accept arguments as
 1606 // (rax,=Obj, rbx=Self, rcx=box, rdx=Scratch) and return success-failure
 1607 // indications in the icc.ZFlag.  fast_lock and fast_unlock would simply
 1608 // marshal the arguments and emit calls to TrySlowEnter and TrySlowExit.
 1609 // In practice, however, the # of lock sites is bounded and is usually small.
 1610 // Besides the call overhead, TrySlowEnter and TrySlowExit might suffer
 1611 // if the processor uses simple bimodal branch predictors keyed by EIP
 1612 // Since the helper routines would be called from multiple synchronization
 1613 // sites.
 1614 //
 1615 // An even better approach would be write &quot;MonitorEnter()&quot; and &quot;MonitorExit()&quot;
 1616 // in java - using j.u.c and unsafe - and just bind the lock and unlock sites
 1617 // to those specialized methods.  That&#39;d give us a mostly platform-independent
 1618 // implementation that the JITs could optimize and inline at their pleasure.
 1619 // Done correctly, the only time we&#39;d need to cross to native could would be
 1620 // to park() or unpark() threads.  We&#39;d also need a few more unsafe operators
 1621 // to (a) prevent compiler-JIT reordering of non-volatile accesses, and
 1622 // (b) explicit barriers or fence operations.
 1623 //
 1624 // TODO:
 1625 //
 1626 // *  Arrange for C2 to pass &quot;Self&quot; into fast_lock and fast_unlock in one of the registers (scr).
 1627 //    This avoids manifesting the Self pointer in the fast_lock and fast_unlock terminals.
 1628 //    Given TLAB allocation, Self is usually manifested in a register, so passing it into
 1629 //    the lock operators would typically be faster than reifying Self.
 1630 //
 1631 // *  Ideally I&#39;d define the primitives as:
 1632 //       fast_lock   (nax Obj, nax box, EAX tmp, nax scr) where box, tmp and scr are KILLED.
 1633 //       fast_unlock (nax Obj, EAX box, nax tmp) where box and tmp are KILLED
 1634 //    Unfortunately ADLC bugs prevent us from expressing the ideal form.
 1635 //    Instead, we&#39;re stuck with a rather awkward and brittle register assignments below.
 1636 //    Furthermore the register assignments are overconstrained, possibly resulting in
 1637 //    sub-optimal code near the synchronization site.
 1638 //
 1639 // *  Eliminate the sp-proximity tests and just use &quot;== Self&quot; tests instead.
 1640 //    Alternately, use a better sp-proximity test.
 1641 //
 1642 // *  Currently ObjectMonitor._Owner can hold either an sp value or a (THREAD *) value.
 1643 //    Either one is sufficient to uniquely identify a thread.
 1644 //    TODO: eliminate use of sp in _owner and use get_thread(tr) instead.
 1645 //
 1646 // *  Intrinsify notify() and notifyAll() for the common cases where the
 1647 //    object is locked by the calling thread but the waitlist is empty.
 1648 //    avoid the expensive JNI call to JVM_Notify() and JVM_NotifyAll().
 1649 //
 1650 // *  use jccb and jmpb instead of jcc and jmp to improve code density.
 1651 //    But beware of excessive branch density on AMD Opterons.
 1652 //
 1653 // *  Both fast_lock and fast_unlock set the ICC.ZF to indicate success
 1654 //    or failure of the fast path.  If the fast path fails then we pass
 1655 //    control to the slow path, typically in C.  In fast_lock and
 1656 //    fast_unlock we often branch to DONE_LABEL, just to find that C2
 1657 //    will emit a conditional branch immediately after the node.
 1658 //    So we have branches to branches and lots of ICC.ZF games.
 1659 //    Instead, it might be better to have C2 pass a &quot;FailureLabel&quot;
 1660 //    into fast_lock and fast_unlock.  In the case of success, control
 1661 //    will drop through the node.  ICC.ZF is undefined at exit.
 1662 //    In the case of failure, the node will branch directly to the
 1663 //    FailureLabel
 1664 
 1665 
 1666 // obj: object to lock
 1667 // box: on-stack box address (displaced header location) - KILLED
 1668 // rax,: tmp -- KILLED
 1669 // scr: tmp -- KILLED
 1670 void MacroAssembler::fast_lock(Register objReg, Register boxReg, Register tmpReg,
 1671                                Register scrReg, Register cx1Reg, Register cx2Reg,
 1672                                BiasedLockingCounters* counters,
 1673                                RTMLockingCounters* rtm_counters,
 1674                                RTMLockingCounters* stack_rtm_counters,
 1675                                Metadata* method_data,
 1676                                bool use_rtm, bool profile_rtm) {
 1677   // Ensure the register assignments are disjoint
 1678   assert(tmpReg == rax, &quot;&quot;);
 1679 
 1680   if (use_rtm) {
 1681     assert_different_registers(objReg, boxReg, tmpReg, scrReg, cx1Reg, cx2Reg);
 1682   } else {
 1683     assert(cx1Reg == noreg, &quot;&quot;);
 1684     assert(cx2Reg == noreg, &quot;&quot;);
 1685     assert_different_registers(objReg, boxReg, tmpReg, scrReg);
 1686   }
 1687 
 1688   if (counters != NULL) {
 1689     atomic_incl(ExternalAddress((address)counters-&gt;total_entry_count_addr()), scrReg);
 1690   }
 1691 
 1692   // Possible cases that we&#39;ll encounter in fast_lock
 1693   // ------------------------------------------------
 1694   // * Inflated
 1695   //    -- unlocked
 1696   //    -- Locked
 1697   //       = by self
 1698   //       = by other
 1699   // * biased
 1700   //    -- by Self
 1701   //    -- by other
 1702   // * neutral
 1703   // * stack-locked
 1704   //    -- by self
 1705   //       = sp-proximity test hits
 1706   //       = sp-proximity test generates false-negative
 1707   //    -- by other
 1708   //
 1709 
 1710   Label IsInflated, DONE_LABEL;
 1711 
 1712   // it&#39;s stack-locked, biased or neutral
 1713   // TODO: optimize away redundant LDs of obj-&gt;mark and improve the markword triage
 1714   // order to reduce the number of conditional branches in the most common cases.
 1715   // Beware -- there&#39;s a subtle invariant that fetch of the markword
 1716   // at [FETCH], below, will never observe a biased encoding (*101b).
 1717   // If this invariant is not held we risk exclusion (safety) failure.
 1718   if (UseBiasedLocking &amp;&amp; !UseOptoBiasInlining) {
 1719     biased_locking_enter(boxReg, objReg, tmpReg, scrReg, false, DONE_LABEL, NULL, counters);
 1720   }
 1721 
 1722 #if INCLUDE_RTM_OPT
 1723   if (UseRTMForStackLocks &amp;&amp; use_rtm) {
 1724     rtm_stack_locking(objReg, tmpReg, scrReg, cx2Reg,
 1725                       stack_rtm_counters, method_data, profile_rtm,
 1726                       DONE_LABEL, IsInflated);
 1727   }
 1728 #endif // INCLUDE_RTM_OPT
 1729 
 1730   movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));          // [FETCH]
 1731   testptr(tmpReg, markWord::monitor_value); // inflated vs stack-locked|neutral|biased
 1732   jccb(Assembler::notZero, IsInflated);
 1733 
 1734   // Attempt stack-locking ...
 1735   orptr (tmpReg, markWord::unlocked_value);
 1736   movptr(Address(boxReg, 0), tmpReg);          // Anticipate successful CAS
 1737   lock();
 1738   cmpxchgptr(boxReg, Address(objReg, oopDesc::mark_offset_in_bytes()));      // Updates tmpReg
 1739   if (counters != NULL) {
 1740     cond_inc32(Assembler::equal,
 1741                ExternalAddress((address)counters-&gt;fast_path_entry_count_addr()));
 1742   }
 1743   jcc(Assembler::equal, DONE_LABEL);           // Success
 1744 
 1745   // Recursive locking.
 1746   // The object is stack-locked: markword contains stack pointer to BasicLock.
 1747   // Locked by current thread if difference with current SP is less than one page.
 1748   subptr(tmpReg, rsp);
 1749   // Next instruction set ZFlag == 1 (Success) if difference is less then one page.
 1750   andptr(tmpReg, (int32_t) (NOT_LP64(0xFFFFF003) LP64_ONLY(7 - os::vm_page_size())) );
 1751   movptr(Address(boxReg, 0), tmpReg);
 1752   if (counters != NULL) {
 1753     cond_inc32(Assembler::equal,
 1754                ExternalAddress((address)counters-&gt;fast_path_entry_count_addr()));
 1755   }
 1756   jmp(DONE_LABEL);
 1757 
 1758   bind(IsInflated);
 1759   // The object is inflated. tmpReg contains pointer to ObjectMonitor* + markWord::monitor_value
 1760 
 1761 #if INCLUDE_RTM_OPT
 1762   // Use the same RTM locking code in 32- and 64-bit VM.
 1763   if (use_rtm) {
 1764     rtm_inflated_locking(objReg, boxReg, tmpReg, scrReg, cx1Reg, cx2Reg,
 1765                          rtm_counters, method_data, profile_rtm, DONE_LABEL);
 1766   } else {
 1767 #endif // INCLUDE_RTM_OPT
 1768 
 1769 #ifndef _LP64
 1770   // The object is inflated.
 1771 
 1772   // boxReg refers to the on-stack BasicLock in the current frame.
 1773   // We&#39;d like to write:
 1774   //   set box-&gt;_displaced_header = markWord::unused_mark().  Any non-0 value suffices.
 1775   // This is convenient but results a ST-before-CAS penalty.  The following CAS suffers
 1776   // additional latency as we have another ST in the store buffer that must drain.
 1777 
 1778   // avoid ST-before-CAS
 1779   // register juggle because we need tmpReg for cmpxchgptr below
 1780   movptr(scrReg, boxReg);
 1781   movptr(boxReg, tmpReg);                   // consider: LEA box, [tmp-2]
 1782 
 1783   // Optimistic form: consider XORL tmpReg,tmpReg
 1784   movptr(tmpReg, NULL_WORD);
 1785 
 1786   // Appears unlocked - try to swing _owner from null to non-null.
 1787   // Ideally, I&#39;d manifest &quot;Self&quot; with get_thread and then attempt
 1788   // to CAS the register containing Self into m-&gt;Owner.
 1789   // But we don&#39;t have enough registers, so instead we can either try to CAS
 1790   // rsp or the address of the box (in scr) into &amp;m-&gt;owner.  If the CAS succeeds
 1791   // we later store &quot;Self&quot; into m-&gt;Owner.  Transiently storing a stack address
 1792   // (rsp or the address of the box) into  m-&gt;owner is harmless.
 1793   // Invariant: tmpReg == 0.  tmpReg is EAX which is the implicit cmpxchg comparand.
 1794   lock();
 1795   cmpxchgptr(scrReg, Address(boxReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));
 1796   movptr(Address(scrReg, 0), 3);          // box-&gt;_displaced_header = 3
 1797   // If we weren&#39;t able to swing _owner from NULL to the BasicLock
 1798   // then take the slow path.
 1799   jccb  (Assembler::notZero, DONE_LABEL);
 1800   // update _owner from BasicLock to thread
 1801   get_thread (scrReg);                    // beware: clobbers ICCs
 1802   movptr(Address(boxReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), scrReg);
 1803   xorptr(boxReg, boxReg);                 // set icc.ZFlag = 1 to indicate success
 1804 
 1805   // If the CAS fails we can either retry or pass control to the slow path.
 1806   // We use the latter tactic.
 1807   // Pass the CAS result in the icc.ZFlag into DONE_LABEL
 1808   // If the CAS was successful ...
 1809   //   Self has acquired the lock
 1810   //   Invariant: m-&gt;_recursions should already be 0, so we don&#39;t need to explicitly set it.
 1811   // Intentional fall-through into DONE_LABEL ...
 1812 #else // _LP64
 1813   // It&#39;s inflated and we use scrReg for ObjectMonitor* in this section.
 1814   movq(scrReg, tmpReg);
 1815   xorq(tmpReg, tmpReg);
 1816   lock();
 1817   cmpxchgptr(r15_thread, Address(scrReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));
 1818   // Unconditionally set box-&gt;_displaced_header = markWord::unused_mark().
 1819   // Without cast to int32_t this style of movptr will destroy r10 which is typically obj.
 1820   movptr(Address(boxReg, 0), (int32_t)intptr_t(markWord::unused_mark().value()));
 1821   // Intentional fall-through into DONE_LABEL ...
 1822   // Propagate ICC.ZF from CAS above into DONE_LABEL.
 1823 #endif // _LP64
 1824 #if INCLUDE_RTM_OPT
 1825   } // use_rtm()
 1826 #endif
 1827   // DONE_LABEL is a hot target - we&#39;d really like to place it at the
 1828   // start of cache line by padding with NOPs.
 1829   // See the AMD and Intel software optimization manuals for the
 1830   // most efficient &quot;long&quot; NOP encodings.
 1831   // Unfortunately none of our alignment mechanisms suffice.
 1832   bind(DONE_LABEL);
 1833 
 1834   // At DONE_LABEL the icc ZFlag is set as follows ...
 1835   // fast_unlock uses the same protocol.
 1836   // ZFlag == 1 -&gt; Success
 1837   // ZFlag == 0 -&gt; Failure - force control through the slow path
 1838 }
 1839 
 1840 // obj: object to unlock
 1841 // box: box address (displaced header location), killed.  Must be EAX.
 1842 // tmp: killed, cannot be obj nor box.
 1843 //
 1844 // Some commentary on balanced locking:
 1845 //
 1846 // fast_lock and fast_unlock are emitted only for provably balanced lock sites.
 1847 // Methods that don&#39;t have provably balanced locking are forced to run in the
 1848 // interpreter - such methods won&#39;t be compiled to use fast_lock and fast_unlock.
 1849 // The interpreter provides two properties:
 1850 // I1:  At return-time the interpreter automatically and quietly unlocks any
 1851 //      objects acquired the current activation (frame).  Recall that the
 1852 //      interpreter maintains an on-stack list of locks currently held by
 1853 //      a frame.
 1854 // I2:  If a method attempts to unlock an object that is not held by the
 1855 //      the frame the interpreter throws IMSX.
 1856 //
 1857 // Lets say A(), which has provably balanced locking, acquires O and then calls B().
 1858 // B() doesn&#39;t have provably balanced locking so it runs in the interpreter.
 1859 // Control returns to A() and A() unlocks O.  By I1 and I2, above, we know that O
 1860 // is still locked by A().
 1861 //
 1862 // The only other source of unbalanced locking would be JNI.  The &quot;Java Native Interface:
 1863 // Programmer&#39;s Guide and Specification&quot; claims that an object locked by jni_monitorenter
 1864 // should not be unlocked by &quot;normal&quot; java-level locking and vice-versa.  The specification
 1865 // doesn&#39;t specify what will occur if a program engages in such mixed-mode locking, however.
 1866 // Arguably given that the spec legislates the JNI case as undefined our implementation
 1867 // could reasonably *avoid* checking owner in fast_unlock().
 1868 // In the interest of performance we elide m-&gt;Owner==Self check in unlock.
 1869 // A perfectly viable alternative is to elide the owner check except when
 1870 // Xcheck:jni is enabled.
 1871 
 1872 void MacroAssembler::fast_unlock(Register objReg, Register boxReg, Register tmpReg, bool use_rtm) {
 1873   assert(boxReg == rax, &quot;&quot;);
 1874   assert_different_registers(objReg, boxReg, tmpReg);
 1875 
 1876   Label DONE_LABEL, Stacked, CheckSucc;
 1877 
 1878   // Critically, the biased locking test must have precedence over
 1879   // and appear before the (box-&gt;dhw == 0) recursive stack-lock test.
 1880   if (UseBiasedLocking &amp;&amp; !UseOptoBiasInlining) {
 1881     biased_locking_exit(objReg, tmpReg, DONE_LABEL);
 1882   }
 1883 
 1884 #if INCLUDE_RTM_OPT
 1885   if (UseRTMForStackLocks &amp;&amp; use_rtm) {
 1886     assert(!UseBiasedLocking, &quot;Biased locking is not supported with RTM locking&quot;);
 1887     Label L_regular_unlock;
 1888     movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); // fetch markword
 1889     andptr(tmpReg, markWord::biased_lock_mask_in_place);              // look at 3 lock bits
 1890     cmpptr(tmpReg, markWord::unlocked_value);                         // bits = 001 unlocked
 1891     jccb(Assembler::notEqual, L_regular_unlock);                      // if !HLE RegularLock
 1892     xend();                                                           // otherwise end...
 1893     jmp(DONE_LABEL);                                                  // ... and we&#39;re done
 1894     bind(L_regular_unlock);
 1895   }
 1896 #endif
 1897 
 1898   cmpptr(Address(boxReg, 0), (int32_t)NULL_WORD);                   // Examine the displaced header
 1899   jcc   (Assembler::zero, DONE_LABEL);                              // 0 indicates recursive stack-lock
 1900   movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); // Examine the object&#39;s markword
 1901   testptr(tmpReg, markWord::monitor_value);                         // Inflated?
 1902   jccb  (Assembler::zero, Stacked);
 1903 
 1904   // It&#39;s inflated.
 1905 #if INCLUDE_RTM_OPT
 1906   if (use_rtm) {
 1907     Label L_regular_inflated_unlock;
 1908     int owner_offset = OM_OFFSET_NO_MONITOR_VALUE_TAG(owner);
 1909     movptr(boxReg, Address(tmpReg, owner_offset));
 1910     testptr(boxReg, boxReg);
 1911     jccb(Assembler::notZero, L_regular_inflated_unlock);
 1912     xend();
 1913     jmpb(DONE_LABEL);
 1914     bind(L_regular_inflated_unlock);
 1915   }
 1916 #endif
 1917 
 1918   // Despite our balanced locking property we still check that m-&gt;_owner == Self
 1919   // as java routines or native JNI code called by this thread might
 1920   // have released the lock.
 1921   // Refer to the comments in synchronizer.cpp for how we might encode extra
 1922   // state in _succ so we can avoid fetching EntryList|cxq.
 1923   //
 1924   // I&#39;d like to add more cases in fast_lock() and fast_unlock() --
 1925   // such as recursive enter and exit -- but we have to be wary of
 1926   // I$ bloat, T$ effects and BP$ effects.
 1927   //
 1928   // If there&#39;s no contention try a 1-0 exit.  That is, exit without
 1929   // a costly MEMBAR or CAS.  See synchronizer.cpp for details on how
 1930   // we detect and recover from the race that the 1-0 exit admits.
 1931   //
 1932   // Conceptually fast_unlock() must execute a STST|LDST &quot;release&quot; barrier
 1933   // before it STs null into _owner, releasing the lock.  Updates
 1934   // to data protected by the critical section must be visible before
 1935   // we drop the lock (and thus before any other thread could acquire
 1936   // the lock and observe the fields protected by the lock).
 1937   // IA32&#39;s memory-model is SPO, so STs are ordered with respect to
 1938   // each other and there&#39;s no need for an explicit barrier (fence).
 1939   // See also http://gee.cs.oswego.edu/dl/jmm/cookbook.html.
 1940 #ifndef _LP64
 1941   get_thread (boxReg);
 1942 
 1943   // Note that we could employ various encoding schemes to reduce
 1944   // the number of loads below (currently 4) to just 2 or 3.
 1945   // Refer to the comments in synchronizer.cpp.
 1946   // In practice the chain of fetches doesn&#39;t seem to impact performance, however.
 1947   xorptr(boxReg, boxReg);
 1948   orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));
 1949   jccb  (Assembler::notZero, DONE_LABEL);
 1950   movptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));
 1951   orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));
 1952   jccb  (Assembler::notZero, CheckSucc);
 1953   movptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), NULL_WORD);
 1954   jmpb  (DONE_LABEL);
 1955 
 1956   bind (Stacked);
 1957   // It&#39;s not inflated and it&#39;s not recursively stack-locked and it&#39;s not biased.
 1958   // It must be stack-locked.
 1959   // Try to reset the header to displaced header.
 1960   // The &quot;box&quot; value on the stack is stable, so we can reload
 1961   // and be assured we observe the same value as above.
 1962   movptr(tmpReg, Address(boxReg, 0));
 1963   lock();
 1964   cmpxchgptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); // Uses RAX which is box
 1965   // Intention fall-thru into DONE_LABEL
 1966 
 1967   // DONE_LABEL is a hot target - we&#39;d really like to place it at the
 1968   // start of cache line by padding with NOPs.
 1969   // See the AMD and Intel software optimization manuals for the
 1970   // most efficient &quot;long&quot; NOP encodings.
 1971   // Unfortunately none of our alignment mechanisms suffice.
 1972   bind (CheckSucc);
 1973 #else // _LP64
 1974   // It&#39;s inflated
 1975   xorptr(boxReg, boxReg);
 1976   orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));
 1977   jccb  (Assembler::notZero, DONE_LABEL);
 1978   movptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));
 1979   orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));
 1980   jccb  (Assembler::notZero, CheckSucc);
 1981   // Without cast to int32_t this style of movptr will destroy r10 which is typically obj.
 1982   movptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), (int32_t)NULL_WORD);
 1983   jmpb  (DONE_LABEL);
 1984 
 1985   // Try to avoid passing control into the slow_path ...
 1986   Label LSuccess, LGoSlowPath ;
 1987   bind  (CheckSucc);
 1988 
 1989   // The following optional optimization can be elided if necessary
 1990   // Effectively: if (succ == null) goto slow path
 1991   // The code reduces the window for a race, however,
 1992   // and thus benefits performance.
 1993   cmpptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), (int32_t)NULL_WORD);
 1994   jccb  (Assembler::zero, LGoSlowPath);
 1995 
 1996   xorptr(boxReg, boxReg);
 1997   // Without cast to int32_t this style of movptr will destroy r10 which is typically obj.
 1998   movptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), (int32_t)NULL_WORD);
 1999 
 2000   // Memory barrier/fence
 2001   // Dekker pivot point -- fulcrum : ST Owner; MEMBAR; LD Succ
 2002   // Instead of MFENCE we use a dummy locked add of 0 to the top-of-stack.
 2003   // This is faster on Nehalem and AMD Shanghai/Barcelona.
 2004   // See https://blogs.oracle.com/dave/entry/instruction_selection_for_volatile_fences
 2005   // We might also restructure (ST Owner=0;barrier;LD _Succ) to
 2006   // (mov box,0; xchgq box, &amp;m-&gt;Owner; LD _succ) .
 2007   lock(); addl(Address(rsp, 0), 0);
 2008 
 2009   cmpptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), (int32_t)NULL_WORD);
 2010   jccb  (Assembler::notZero, LSuccess);
 2011 
 2012   // Rare inopportune interleaving - race.
 2013   // The successor vanished in the small window above.
 2014   // The lock is contended -- (cxq|EntryList) != null -- and there&#39;s no apparent successor.
 2015   // We need to ensure progress and succession.
 2016   // Try to reacquire the lock.
 2017   // If that fails then the new owner is responsible for succession and this
 2018   // thread needs to take no further action and can exit via the fast path (success).
 2019   // If the re-acquire succeeds then pass control into the slow path.
 2020   // As implemented, this latter mode is horrible because we generated more
 2021   // coherence traffic on the lock *and* artifically extended the critical section
 2022   // length while by virtue of passing control into the slow path.
 2023 
 2024   // box is really RAX -- the following CMPXCHG depends on that binding
 2025   // cmpxchg R,[M] is equivalent to rax = CAS(M,rax,R)
 2026   lock();
 2027   cmpxchgptr(r15_thread, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));
 2028   // There&#39;s no successor so we tried to regrab the lock.
 2029   // If that didn&#39;t work, then another thread grabbed the
 2030   // lock so we&#39;re done (and exit was a success).
 2031   jccb  (Assembler::notEqual, LSuccess);
 2032   // Intentional fall-through into slow path
 2033 
 2034   bind  (LGoSlowPath);
 2035   orl   (boxReg, 1);                      // set ICC.ZF=0 to indicate failure
 2036   jmpb  (DONE_LABEL);
 2037 
 2038   bind  (LSuccess);
 2039   testl (boxReg, 0);                      // set ICC.ZF=1 to indicate success
 2040   jmpb  (DONE_LABEL);
 2041 
 2042   bind  (Stacked);
 2043   movptr(tmpReg, Address (boxReg, 0));      // re-fetch
 2044   lock();
 2045   cmpxchgptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); // Uses RAX which is box
 2046 
 2047 #endif
 2048   bind(DONE_LABEL);
 2049 }
 2050 #endif // COMPILER2
 2051 
 2052 void MacroAssembler::c2bool(Register x) {
 2053   // implements x == 0 ? 0 : 1
 2054   // note: must only look at least-significant byte of x
 2055   //       since C-style booleans are stored in one byte
 2056   //       only! (was bug)
 2057   andl(x, 0xFF);
 2058   setb(Assembler::notZero, x);
 2059 }
 2060 
 2061 // Wouldn&#39;t need if AddressLiteral version had new name
 2062 void MacroAssembler::call(Label&amp; L, relocInfo::relocType rtype) {
 2063   Assembler::call(L, rtype);
 2064 }
 2065 
 2066 void MacroAssembler::call(Register entry) {
 2067   Assembler::call(entry);
 2068 }
 2069 
 2070 void MacroAssembler::call(AddressLiteral entry) {
 2071   if (reachable(entry)) {
 2072     Assembler::call_literal(entry.target(), entry.rspec());
 2073   } else {
 2074     lea(rscratch1, entry);
 2075     Assembler::call(rscratch1);
 2076   }
 2077 }
 2078 
 2079 void MacroAssembler::ic_call(address entry, jint method_index) {
 2080   RelocationHolder rh = virtual_call_Relocation::spec(pc(), method_index);
 2081   movptr(rax, (intptr_t)Universe::non_oop_word());
 2082   call(AddressLiteral(entry, rh));
 2083 }
 2084 
 2085 // Implementation of call_VM versions
 2086 
 2087 void MacroAssembler::call_VM(Register oop_result,
 2088                              address entry_point,
 2089                              bool check_exceptions) {
 2090   Label C, E;
 2091   call(C, relocInfo::none);
 2092   jmp(E);
 2093 
 2094   bind(C);
 2095   call_VM_helper(oop_result, entry_point, 0, check_exceptions);
 2096   ret(0);
 2097 
 2098   bind(E);
 2099 }
 2100 
 2101 void MacroAssembler::call_VM(Register oop_result,
 2102                              address entry_point,
 2103                              Register arg_1,
 2104                              bool check_exceptions) {
 2105   Label C, E;
 2106   call(C, relocInfo::none);
 2107   jmp(E);
 2108 
 2109   bind(C);
 2110   pass_arg1(this, arg_1);
 2111   call_VM_helper(oop_result, entry_point, 1, check_exceptions);
 2112   ret(0);
 2113 
 2114   bind(E);
 2115 }
 2116 
 2117 void MacroAssembler::call_VM(Register oop_result,
 2118                              address entry_point,
 2119                              Register arg_1,
 2120                              Register arg_2,
 2121                              bool check_exceptions) {
 2122   Label C, E;
 2123   call(C, relocInfo::none);
 2124   jmp(E);
 2125 
 2126   bind(C);
 2127 
 2128   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
 2129 
 2130   pass_arg2(this, arg_2);
 2131   pass_arg1(this, arg_1);
 2132   call_VM_helper(oop_result, entry_point, 2, check_exceptions);
 2133   ret(0);
 2134 
 2135   bind(E);
 2136 }
 2137 
 2138 void MacroAssembler::call_VM(Register oop_result,
 2139                              address entry_point,
 2140                              Register arg_1,
 2141                              Register arg_2,
 2142                              Register arg_3,
 2143                              bool check_exceptions) {
 2144   Label C, E;
 2145   call(C, relocInfo::none);
 2146   jmp(E);
 2147 
 2148   bind(C);
 2149 
 2150   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
 2151   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
 2152   pass_arg3(this, arg_3);
 2153 
 2154   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
 2155   pass_arg2(this, arg_2);
 2156 
 2157   pass_arg1(this, arg_1);
 2158   call_VM_helper(oop_result, entry_point, 3, check_exceptions);
 2159   ret(0);
 2160 
 2161   bind(E);
 2162 }
 2163 
 2164 void MacroAssembler::call_VM(Register oop_result,
 2165                              Register last_java_sp,
 2166                              address entry_point,
 2167                              int number_of_arguments,
 2168                              bool check_exceptions) {
 2169   Register thread = LP64_ONLY(r15_thread) NOT_LP64(noreg);
 2170   call_VM_base(oop_result, thread, last_java_sp, entry_point, number_of_arguments, check_exceptions);
 2171 }
 2172 
 2173 void MacroAssembler::call_VM(Register oop_result,
 2174                              Register last_java_sp,
 2175                              address entry_point,
 2176                              Register arg_1,
 2177                              bool check_exceptions) {
 2178   pass_arg1(this, arg_1);
 2179   call_VM(oop_result, last_java_sp, entry_point, 1, check_exceptions);
 2180 }
 2181 
 2182 void MacroAssembler::call_VM(Register oop_result,
 2183                              Register last_java_sp,
 2184                              address entry_point,
 2185                              Register arg_1,
 2186                              Register arg_2,
 2187                              bool check_exceptions) {
 2188 
 2189   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
 2190   pass_arg2(this, arg_2);
 2191   pass_arg1(this, arg_1);
 2192   call_VM(oop_result, last_java_sp, entry_point, 2, check_exceptions);
 2193 }
 2194 
 2195 void MacroAssembler::call_VM(Register oop_result,
 2196                              Register last_java_sp,
 2197                              address entry_point,
 2198                              Register arg_1,
 2199                              Register arg_2,
 2200                              Register arg_3,
 2201                              bool check_exceptions) {
 2202   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
 2203   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
 2204   pass_arg3(this, arg_3);
 2205   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
 2206   pass_arg2(this, arg_2);
 2207   pass_arg1(this, arg_1);
 2208   call_VM(oop_result, last_java_sp, entry_point, 3, check_exceptions);
 2209 }
 2210 
 2211 void MacroAssembler::super_call_VM(Register oop_result,
 2212                                    Register last_java_sp,
 2213                                    address entry_point,
 2214                                    int number_of_arguments,
 2215                                    bool check_exceptions) {
 2216   Register thread = LP64_ONLY(r15_thread) NOT_LP64(noreg);
 2217   MacroAssembler::call_VM_base(oop_result, thread, last_java_sp, entry_point, number_of_arguments, check_exceptions);
 2218 }
 2219 
 2220 void MacroAssembler::super_call_VM(Register oop_result,
 2221                                    Register last_java_sp,
 2222                                    address entry_point,
 2223                                    Register arg_1,
 2224                                    bool check_exceptions) {
 2225   pass_arg1(this, arg_1);
 2226   super_call_VM(oop_result, last_java_sp, entry_point, 1, check_exceptions);
 2227 }
 2228 
 2229 void MacroAssembler::super_call_VM(Register oop_result,
 2230                                    Register last_java_sp,
 2231                                    address entry_point,
 2232                                    Register arg_1,
 2233                                    Register arg_2,
 2234                                    bool check_exceptions) {
 2235 
 2236   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
 2237   pass_arg2(this, arg_2);
 2238   pass_arg1(this, arg_1);
 2239   super_call_VM(oop_result, last_java_sp, entry_point, 2, check_exceptions);
 2240 }
 2241 
 2242 void MacroAssembler::super_call_VM(Register oop_result,
 2243                                    Register last_java_sp,
 2244                                    address entry_point,
 2245                                    Register arg_1,
 2246                                    Register arg_2,
 2247                                    Register arg_3,
 2248                                    bool check_exceptions) {
 2249   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
 2250   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
 2251   pass_arg3(this, arg_3);
 2252   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
 2253   pass_arg2(this, arg_2);
 2254   pass_arg1(this, arg_1);
 2255   super_call_VM(oop_result, last_java_sp, entry_point, 3, check_exceptions);
 2256 }
 2257 
 2258 void MacroAssembler::call_VM_base(Register oop_result,
 2259                                   Register java_thread,
 2260                                   Register last_java_sp,
 2261                                   address  entry_point,
 2262                                   int      number_of_arguments,
 2263                                   bool     check_exceptions) {
 2264   // determine java_thread register
 2265   if (!java_thread-&gt;is_valid()) {
 2266 #ifdef _LP64
 2267     java_thread = r15_thread;
 2268 #else
 2269     java_thread = rdi;
 2270     get_thread(java_thread);
 2271 #endif // LP64
 2272   }
 2273   // determine last_java_sp register
 2274   if (!last_java_sp-&gt;is_valid()) {
 2275     last_java_sp = rsp;
 2276   }
 2277   // debugging support
 2278   assert(number_of_arguments &gt;= 0   , &quot;cannot have negative number of arguments&quot;);
 2279   LP64_ONLY(assert(java_thread == r15_thread, &quot;unexpected register&quot;));
 2280 #ifdef ASSERT
 2281   // TraceBytecodes does not use r12 but saves it over the call, so don&#39;t verify
 2282   // r12 is the heapbase.
 2283   LP64_ONLY(if ((UseCompressedOops || UseCompressedClassPointers) &amp;&amp; !TraceBytecodes) verify_heapbase(&quot;call_VM_base: heap base corrupted?&quot;);)
 2284 #endif // ASSERT
 2285 
 2286   assert(java_thread != oop_result  , &quot;cannot use the same register for java_thread &amp; oop_result&quot;);
 2287   assert(java_thread != last_java_sp, &quot;cannot use the same register for java_thread &amp; last_java_sp&quot;);
 2288 
 2289   // push java thread (becomes first argument of C function)
 2290 
 2291   NOT_LP64(push(java_thread); number_of_arguments++);
 2292   LP64_ONLY(mov(c_rarg0, r15_thread));
 2293 
 2294   // set last Java frame before call
 2295   assert(last_java_sp != rbp, &quot;can&#39;t use ebp/rbp&quot;);
 2296 
 2297   // Only interpreter should have to set fp
 2298   set_last_Java_frame(java_thread, last_java_sp, rbp, NULL);
 2299 
 2300   // do the call, remove parameters
 2301   MacroAssembler::call_VM_leaf_base(entry_point, number_of_arguments);
 2302 
 2303   // restore the thread (cannot use the pushed argument since arguments
 2304   // may be overwritten by C code generated by an optimizing compiler);
 2305   // however can use the register value directly if it is callee saved.
 2306   if (LP64_ONLY(true ||) java_thread == rdi || java_thread == rsi) {
 2307     // rdi &amp; rsi (also r15) are callee saved -&gt; nothing to do
 2308 #ifdef ASSERT
 2309     guarantee(java_thread != rax, &quot;change this code&quot;);
 2310     push(rax);
 2311     { Label L;
 2312       get_thread(rax);
 2313       cmpptr(java_thread, rax);
 2314       jcc(Assembler::equal, L);
 2315       STOP(&quot;MacroAssembler::call_VM_base: rdi not callee saved?&quot;);
 2316       bind(L);
 2317     }
 2318     pop(rax);
 2319 #endif
 2320   } else {
 2321     get_thread(java_thread);
 2322   }
 2323   // reset last Java frame
 2324   // Only interpreter should have to clear fp
 2325   reset_last_Java_frame(java_thread, true);
 2326 
 2327    // C++ interp handles this in the interpreter
 2328   check_and_handle_popframe(java_thread);
 2329   check_and_handle_earlyret(java_thread);
 2330 
 2331   if (check_exceptions) {
 2332     // check for pending exceptions (java_thread is set upon return)
 2333     cmpptr(Address(java_thread, Thread::pending_exception_offset()), (int32_t) NULL_WORD);
 2334 #ifndef _LP64
 2335     jump_cc(Assembler::notEqual,
 2336             RuntimeAddress(StubRoutines::forward_exception_entry()));
 2337 #else
 2338     // This used to conditionally jump to forward_exception however it is
 2339     // possible if we relocate that the branch will not reach. So we must jump
 2340     // around so we can always reach
 2341 
 2342     Label ok;
 2343     jcc(Assembler::equal, ok);
 2344     jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
 2345     bind(ok);
 2346 #endif // LP64
 2347   }
 2348 
 2349   // get oop result if there is one and reset the value in the thread
 2350   if (oop_result-&gt;is_valid()) {
 2351     get_vm_result(oop_result, java_thread);
 2352   }
 2353 }
 2354 
 2355 void MacroAssembler::call_VM_helper(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions) {
 2356 
 2357   // Calculate the value for last_Java_sp
 2358   // somewhat subtle. call_VM does an intermediate call
 2359   // which places a return address on the stack just under the
 2360   // stack pointer as the user finsihed with it. This allows
 2361   // use to retrieve last_Java_pc from last_Java_sp[-1].
 2362   // On 32bit we then have to push additional args on the stack to accomplish
 2363   // the actual requested call. On 64bit call_VM only can use register args
 2364   // so the only extra space is the return address that call_VM created.
 2365   // This hopefully explains the calculations here.
 2366 
 2367 #ifdef _LP64
 2368   // We&#39;ve pushed one address, correct last_Java_sp
 2369   lea(rax, Address(rsp, wordSize));
 2370 #else
 2371   lea(rax, Address(rsp, (1 + number_of_arguments) * wordSize));
 2372 #endif // LP64
 2373 
 2374   call_VM_base(oop_result, noreg, rax, entry_point, number_of_arguments, check_exceptions);
 2375 
 2376 }
 2377 
 2378 // Use this method when MacroAssembler version of call_VM_leaf_base() should be called from Interpreter.
 2379 void MacroAssembler::call_VM_leaf0(address entry_point) {
 2380   MacroAssembler::call_VM_leaf_base(entry_point, 0);
 2381 }
 2382 
 2383 void MacroAssembler::call_VM_leaf(address entry_point, int number_of_arguments) {
 2384   call_VM_leaf_base(entry_point, number_of_arguments);
 2385 }
 2386 
 2387 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0) {
 2388   pass_arg0(this, arg_0);
 2389   call_VM_leaf(entry_point, 1);
 2390 }
 2391 
 2392 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0, Register arg_1) {
 2393 
 2394   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
 2395   pass_arg1(this, arg_1);
 2396   pass_arg0(this, arg_0);
 2397   call_VM_leaf(entry_point, 2);
 2398 }
 2399 
 2400 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2) {
 2401   LP64_ONLY(assert(arg_0 != c_rarg2, &quot;smashed arg&quot;));
 2402   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
 2403   pass_arg2(this, arg_2);
 2404   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
 2405   pass_arg1(this, arg_1);
 2406   pass_arg0(this, arg_0);
 2407   call_VM_leaf(entry_point, 3);
 2408 }
 2409 
 2410 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0) {
 2411   pass_arg0(this, arg_0);
 2412   MacroAssembler::call_VM_leaf_base(entry_point, 1);
 2413 }
 2414 
 2415 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1) {
 2416 
 2417   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
 2418   pass_arg1(this, arg_1);
 2419   pass_arg0(this, arg_0);
 2420   MacroAssembler::call_VM_leaf_base(entry_point, 2);
 2421 }
 2422 
 2423 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2) {
 2424   LP64_ONLY(assert(arg_0 != c_rarg2, &quot;smashed arg&quot;));
 2425   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
 2426   pass_arg2(this, arg_2);
 2427   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
 2428   pass_arg1(this, arg_1);
 2429   pass_arg0(this, arg_0);
 2430   MacroAssembler::call_VM_leaf_base(entry_point, 3);
 2431 }
 2432 
 2433 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2, Register arg_3) {
 2434   LP64_ONLY(assert(arg_0 != c_rarg3, &quot;smashed arg&quot;));
 2435   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
 2436   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
 2437   pass_arg3(this, arg_3);
 2438   LP64_ONLY(assert(arg_0 != c_rarg2, &quot;smashed arg&quot;));
 2439   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
 2440   pass_arg2(this, arg_2);
 2441   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
 2442   pass_arg1(this, arg_1);
 2443   pass_arg0(this, arg_0);
 2444   MacroAssembler::call_VM_leaf_base(entry_point, 4);
 2445 }
 2446 
 2447 void MacroAssembler::get_vm_result(Register oop_result, Register java_thread) {
 2448   movptr(oop_result, Address(java_thread, JavaThread::vm_result_offset()));
 2449   movptr(Address(java_thread, JavaThread::vm_result_offset()), NULL_WORD);
<a name="2" id="anc2"></a><span class="line-modified"> 2450   verify_oop_msg(oop_result, &quot;broken oop in call_VM_base&quot;);</span>
 2451 }
 2452 
 2453 void MacroAssembler::get_vm_result_2(Register metadata_result, Register java_thread) {
 2454   movptr(metadata_result, Address(java_thread, JavaThread::vm_result_2_offset()));
 2455   movptr(Address(java_thread, JavaThread::vm_result_2_offset()), NULL_WORD);
 2456 }
 2457 
 2458 void MacroAssembler::check_and_handle_earlyret(Register java_thread) {
 2459 }
 2460 
 2461 void MacroAssembler::check_and_handle_popframe(Register java_thread) {
 2462 }
 2463 
 2464 void MacroAssembler::cmp32(AddressLiteral src1, int32_t imm) {
 2465   if (reachable(src1)) {
 2466     cmpl(as_Address(src1), imm);
 2467   } else {
 2468     lea(rscratch1, src1);
 2469     cmpl(Address(rscratch1, 0), imm);
 2470   }
 2471 }
 2472 
 2473 void MacroAssembler::cmp32(Register src1, AddressLiteral src2) {
 2474   assert(!src2.is_lval(), &quot;use cmpptr&quot;);
 2475   if (reachable(src2)) {
 2476     cmpl(src1, as_Address(src2));
 2477   } else {
 2478     lea(rscratch1, src2);
 2479     cmpl(src1, Address(rscratch1, 0));
 2480   }
 2481 }
 2482 
 2483 void MacroAssembler::cmp32(Register src1, int32_t imm) {
 2484   Assembler::cmpl(src1, imm);
 2485 }
 2486 
 2487 void MacroAssembler::cmp32(Register src1, Address src2) {
 2488   Assembler::cmpl(src1, src2);
 2489 }
 2490 
 2491 void MacroAssembler::cmpsd2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less) {
 2492   ucomisd(opr1, opr2);
 2493 
 2494   Label L;
 2495   if (unordered_is_less) {
 2496     movl(dst, -1);
 2497     jcc(Assembler::parity, L);
 2498     jcc(Assembler::below , L);
 2499     movl(dst, 0);
 2500     jcc(Assembler::equal , L);
 2501     increment(dst);
 2502   } else { // unordered is greater
 2503     movl(dst, 1);
 2504     jcc(Assembler::parity, L);
 2505     jcc(Assembler::above , L);
 2506     movl(dst, 0);
 2507     jcc(Assembler::equal , L);
 2508     decrementl(dst);
 2509   }
 2510   bind(L);
 2511 }
 2512 
 2513 void MacroAssembler::cmpss2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less) {
 2514   ucomiss(opr1, opr2);
 2515 
 2516   Label L;
 2517   if (unordered_is_less) {
 2518     movl(dst, -1);
 2519     jcc(Assembler::parity, L);
 2520     jcc(Assembler::below , L);
 2521     movl(dst, 0);
 2522     jcc(Assembler::equal , L);
 2523     increment(dst);
 2524   } else { // unordered is greater
 2525     movl(dst, 1);
 2526     jcc(Assembler::parity, L);
 2527     jcc(Assembler::above , L);
 2528     movl(dst, 0);
 2529     jcc(Assembler::equal , L);
 2530     decrementl(dst);
 2531   }
 2532   bind(L);
 2533 }
 2534 
 2535 
 2536 void MacroAssembler::cmp8(AddressLiteral src1, int imm) {
 2537   if (reachable(src1)) {
 2538     cmpb(as_Address(src1), imm);
 2539   } else {
 2540     lea(rscratch1, src1);
 2541     cmpb(Address(rscratch1, 0), imm);
 2542   }
 2543 }
 2544 
 2545 void MacroAssembler::cmpptr(Register src1, AddressLiteral src2) {
 2546 #ifdef _LP64
 2547   if (src2.is_lval()) {
 2548     movptr(rscratch1, src2);
 2549     Assembler::cmpq(src1, rscratch1);
 2550   } else if (reachable(src2)) {
 2551     cmpq(src1, as_Address(src2));
 2552   } else {
 2553     lea(rscratch1, src2);
 2554     Assembler::cmpq(src1, Address(rscratch1, 0));
 2555   }
 2556 #else
 2557   if (src2.is_lval()) {
 2558     cmp_literal32(src1, (int32_t) src2.target(), src2.rspec());
 2559   } else {
 2560     cmpl(src1, as_Address(src2));
 2561   }
 2562 #endif // _LP64
 2563 }
 2564 
 2565 void MacroAssembler::cmpptr(Address src1, AddressLiteral src2) {
 2566   assert(src2.is_lval(), &quot;not a mem-mem compare&quot;);
 2567 #ifdef _LP64
 2568   // moves src2&#39;s literal address
 2569   movptr(rscratch1, src2);
 2570   Assembler::cmpq(src1, rscratch1);
 2571 #else
 2572   cmp_literal32(src1, (int32_t) src2.target(), src2.rspec());
 2573 #endif // _LP64
 2574 }
 2575 
 2576 void MacroAssembler::cmpoop(Register src1, Register src2) {
 2577   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 2578   bs-&gt;obj_equals(this, src1, src2);
 2579 }
 2580 
 2581 void MacroAssembler::cmpoop(Register src1, Address src2) {
 2582   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 2583   bs-&gt;obj_equals(this, src1, src2);
 2584 }
 2585 
 2586 #ifdef _LP64
 2587 void MacroAssembler::cmpoop(Register src1, jobject src2) {
 2588   movoop(rscratch1, src2);
 2589   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 2590   bs-&gt;obj_equals(this, src1, rscratch1);
 2591 }
 2592 #endif
 2593 
 2594 void MacroAssembler::locked_cmpxchgptr(Register reg, AddressLiteral adr) {
 2595   if (reachable(adr)) {
 2596     lock();
 2597     cmpxchgptr(reg, as_Address(adr));
 2598   } else {
 2599     lea(rscratch1, adr);
 2600     lock();
 2601     cmpxchgptr(reg, Address(rscratch1, 0));
 2602   }
 2603 }
 2604 
 2605 void MacroAssembler::cmpxchgptr(Register reg, Address adr) {
 2606   LP64_ONLY(cmpxchgq(reg, adr)) NOT_LP64(cmpxchgl(reg, adr));
 2607 }
 2608 
 2609 void MacroAssembler::comisd(XMMRegister dst, AddressLiteral src) {
 2610   if (reachable(src)) {
 2611     Assembler::comisd(dst, as_Address(src));
 2612   } else {
 2613     lea(rscratch1, src);
 2614     Assembler::comisd(dst, Address(rscratch1, 0));
 2615   }
 2616 }
 2617 
 2618 void MacroAssembler::comiss(XMMRegister dst, AddressLiteral src) {
 2619   if (reachable(src)) {
 2620     Assembler::comiss(dst, as_Address(src));
 2621   } else {
 2622     lea(rscratch1, src);
 2623     Assembler::comiss(dst, Address(rscratch1, 0));
 2624   }
 2625 }
 2626 
 2627 
 2628 void MacroAssembler::cond_inc32(Condition cond, AddressLiteral counter_addr) {
 2629   Condition negated_cond = negate_condition(cond);
 2630   Label L;
 2631   jcc(negated_cond, L);
 2632   pushf(); // Preserve flags
 2633   atomic_incl(counter_addr);
 2634   popf();
 2635   bind(L);
 2636 }
 2637 
 2638 int MacroAssembler::corrected_idivl(Register reg) {
 2639   // Full implementation of Java idiv and irem; checks for
 2640   // special case as described in JVM spec., p.243 &amp; p.271.
 2641   // The function returns the (pc) offset of the idivl
 2642   // instruction - may be needed for implicit exceptions.
 2643   //
 2644   //         normal case                           special case
 2645   //
 2646   // input : rax,: dividend                         min_int
 2647   //         reg: divisor   (may not be rax,/rdx)   -1
 2648   //
 2649   // output: rax,: quotient  (= rax, idiv reg)       min_int
 2650   //         rdx: remainder (= rax, irem reg)       0
 2651   assert(reg != rax &amp;&amp; reg != rdx, &quot;reg cannot be rax, or rdx register&quot;);
 2652   const int min_int = 0x80000000;
 2653   Label normal_case, special_case;
 2654 
 2655   // check for special case
 2656   cmpl(rax, min_int);
 2657   jcc(Assembler::notEqual, normal_case);
 2658   xorl(rdx, rdx); // prepare rdx for possible special case (where remainder = 0)
 2659   cmpl(reg, -1);
 2660   jcc(Assembler::equal, special_case);
 2661 
 2662   // handle normal case
 2663   bind(normal_case);
 2664   cdql();
 2665   int idivl_offset = offset();
 2666   idivl(reg);
 2667 
 2668   // normal and special case exit
 2669   bind(special_case);
 2670 
 2671   return idivl_offset;
 2672 }
 2673 
 2674 
 2675 
 2676 void MacroAssembler::decrementl(Register reg, int value) {
 2677   if (value == min_jint) {subl(reg, value) ; return; }
 2678   if (value &lt;  0) { incrementl(reg, -value); return; }
 2679   if (value == 0) {                        ; return; }
 2680   if (value == 1 &amp;&amp; UseIncDec) { decl(reg) ; return; }
 2681   /* else */      { subl(reg, value)       ; return; }
 2682 }
 2683 
 2684 void MacroAssembler::decrementl(Address dst, int value) {
 2685   if (value == min_jint) {subl(dst, value) ; return; }
 2686   if (value &lt;  0) { incrementl(dst, -value); return; }
 2687   if (value == 0) {                        ; return; }
 2688   if (value == 1 &amp;&amp; UseIncDec) { decl(dst) ; return; }
 2689   /* else */      { subl(dst, value)       ; return; }
 2690 }
 2691 
 2692 void MacroAssembler::division_with_shift (Register reg, int shift_value) {
 2693   assert (shift_value &gt; 0, &quot;illegal shift value&quot;);
 2694   Label _is_positive;
 2695   testl (reg, reg);
 2696   jcc (Assembler::positive, _is_positive);
 2697   int offset = (1 &lt;&lt; shift_value) - 1 ;
 2698 
 2699   if (offset == 1) {
 2700     incrementl(reg);
 2701   } else {
 2702     addl(reg, offset);
 2703   }
 2704 
 2705   bind (_is_positive);
 2706   sarl(reg, shift_value);
 2707 }
 2708 
 2709 void MacroAssembler::divsd(XMMRegister dst, AddressLiteral src) {
 2710   if (reachable(src)) {
 2711     Assembler::divsd(dst, as_Address(src));
 2712   } else {
 2713     lea(rscratch1, src);
 2714     Assembler::divsd(dst, Address(rscratch1, 0));
 2715   }
 2716 }
 2717 
 2718 void MacroAssembler::divss(XMMRegister dst, AddressLiteral src) {
 2719   if (reachable(src)) {
 2720     Assembler::divss(dst, as_Address(src));
 2721   } else {
 2722     lea(rscratch1, src);
 2723     Assembler::divss(dst, Address(rscratch1, 0));
 2724   }
 2725 }
 2726 
<a name="3" id="anc3"></a>










 2727 void MacroAssembler::enter() {
 2728   push(rbp);
 2729   mov(rbp, rsp);
 2730 }
 2731 
 2732 // A 5 byte nop that is safe for patching (see patch_verified_entry)
 2733 void MacroAssembler::fat_nop() {
 2734   if (UseAddressNop) {
 2735     addr_nop_5();
 2736   } else {
 2737     emit_int8(0x26); // es:
 2738     emit_int8(0x2e); // cs:
 2739     emit_int8(0x64); // fs:
 2740     emit_int8(0x65); // gs:
 2741     emit_int8((unsigned char)0x90);
 2742   }
 2743 }
 2744 
<a name="4" id="anc4"></a><span class="line-modified"> 2745 #ifndef _LP64</span>
 2746 void MacroAssembler::fcmp(Register tmp) {
 2747   fcmp(tmp, 1, true, true);
 2748 }
 2749 
 2750 void MacroAssembler::fcmp(Register tmp, int index, bool pop_left, bool pop_right) {
 2751   assert(!pop_right || pop_left, &quot;usage error&quot;);
 2752   if (VM_Version::supports_cmov()) {
 2753     assert(tmp == noreg, &quot;unneeded temp&quot;);
 2754     if (pop_left) {
 2755       fucomip(index);
 2756     } else {
 2757       fucomi(index);
 2758     }
 2759     if (pop_right) {
 2760       fpop();
 2761     }
 2762   } else {
 2763     assert(tmp != noreg, &quot;need temp&quot;);
 2764     if (pop_left) {
 2765       if (pop_right) {
 2766         fcompp();
 2767       } else {
 2768         fcomp(index);
 2769       }
 2770     } else {
 2771       fcom(index);
 2772     }
 2773     // convert FPU condition into eflags condition via rax,
 2774     save_rax(tmp);
 2775     fwait(); fnstsw_ax();
 2776     sahf();
 2777     restore_rax(tmp);
 2778   }
 2779   // condition codes set as follows:
 2780   //
 2781   // CF (corresponds to C0) if x &lt; y
 2782   // PF (corresponds to C2) if unordered
 2783   // ZF (corresponds to C3) if x = y
 2784 }
 2785 
 2786 void MacroAssembler::fcmp2int(Register dst, bool unordered_is_less) {
 2787   fcmp2int(dst, unordered_is_less, 1, true, true);
 2788 }
 2789 
 2790 void MacroAssembler::fcmp2int(Register dst, bool unordered_is_less, int index, bool pop_left, bool pop_right) {
 2791   fcmp(VM_Version::supports_cmov() ? noreg : dst, index, pop_left, pop_right);
 2792   Label L;
 2793   if (unordered_is_less) {
 2794     movl(dst, -1);
 2795     jcc(Assembler::parity, L);
 2796     jcc(Assembler::below , L);
 2797     movl(dst, 0);
 2798     jcc(Assembler::equal , L);
 2799     increment(dst);
 2800   } else { // unordered is greater
 2801     movl(dst, 1);
 2802     jcc(Assembler::parity, L);
 2803     jcc(Assembler::above , L);
 2804     movl(dst, 0);
 2805     jcc(Assembler::equal , L);
 2806     decrementl(dst);
 2807   }
 2808   bind(L);
 2809 }
 2810 
 2811 void MacroAssembler::fld_d(AddressLiteral src) {
 2812   fld_d(as_Address(src));
 2813 }
 2814 
 2815 void MacroAssembler::fld_s(AddressLiteral src) {
 2816   fld_s(as_Address(src));
 2817 }
 2818 
 2819 void MacroAssembler::fld_x(AddressLiteral src) {
 2820   Assembler::fld_x(as_Address(src));
 2821 }
 2822 
 2823 void MacroAssembler::fldcw(AddressLiteral src) {
 2824   Assembler::fldcw(as_Address(src));
 2825 }
 2826 
 2827 void MacroAssembler::fpop() {
 2828   ffree();
 2829   fincstp();
 2830 }
 2831 
 2832 void MacroAssembler::fremr(Register tmp) {
 2833   save_rax(tmp);
 2834   { Label L;
 2835     bind(L);
 2836     fprem();
 2837     fwait(); fnstsw_ax();
 2838     sahf();
 2839     jcc(Assembler::parity, L);
 2840   }
 2841   restore_rax(tmp);
 2842   // Result is in ST0.
 2843   // Note: fxch &amp; fpop to get rid of ST1
 2844   // (otherwise FPU stack could overflow eventually)
 2845   fxch(1);
 2846   fpop();
 2847 }
<a name="5" id="anc5"></a><span class="line-added"> 2848 </span>
<span class="line-added"> 2849 void MacroAssembler::empty_FPU_stack() {</span>
<span class="line-added"> 2850   if (VM_Version::supports_mmx()) {</span>
<span class="line-added"> 2851     emms();</span>
<span class="line-added"> 2852   } else {</span>
<span class="line-added"> 2853     for (int i = 8; i-- &gt; 0; ) ffree(i);</span>
<span class="line-added"> 2854   }</span>
<span class="line-added"> 2855 }</span>
 2856 #endif // !LP64
 2857 
 2858 void MacroAssembler::mulpd(XMMRegister dst, AddressLiteral src) {
 2859   if (reachable(src)) {
 2860     Assembler::mulpd(dst, as_Address(src));
 2861   } else {
 2862     lea(rscratch1, src);
 2863     Assembler::mulpd(dst, Address(rscratch1, 0));
 2864   }
 2865 }
 2866 
 2867 void MacroAssembler::load_float(Address src) {
<a name="6" id="anc6"></a><span class="line-added"> 2868 #ifdef _LP64</span>
<span class="line-added"> 2869   movflt(xmm0, src);</span>
<span class="line-added"> 2870 #else</span>
 2871   if (UseSSE &gt;= 1) {
 2872     movflt(xmm0, src);
 2873   } else {
<a name="7" id="anc7"></a><span class="line-modified"> 2874     fld_s(src);</span>

 2875   }
<a name="8" id="anc8"></a><span class="line-added"> 2876 #endif // LP64</span>
 2877 }
 2878 
 2879 void MacroAssembler::store_float(Address dst) {
<a name="9" id="anc9"></a><span class="line-added"> 2880 #ifdef _LP64</span>
<span class="line-added"> 2881   movflt(dst, xmm0);</span>
<span class="line-added"> 2882 #else</span>
 2883   if (UseSSE &gt;= 1) {
 2884     movflt(dst, xmm0);
 2885   } else {
<a name="10" id="anc10"></a><span class="line-modified"> 2886     fstp_s(dst);</span>

 2887   }
<a name="11" id="anc11"></a><span class="line-added"> 2888 #endif // LP64</span>
 2889 }
 2890 
 2891 void MacroAssembler::load_double(Address src) {
<a name="12" id="anc12"></a><span class="line-added"> 2892 #ifdef _LP64</span>
<span class="line-added"> 2893   movdbl(xmm0, src);</span>
<span class="line-added"> 2894 #else</span>
 2895   if (UseSSE &gt;= 2) {
 2896     movdbl(xmm0, src);
 2897   } else {
<a name="13" id="anc13"></a><span class="line-modified"> 2898     fld_d(src);</span>

 2899   }
<a name="14" id="anc14"></a><span class="line-added"> 2900 #endif // LP64</span>
 2901 }
 2902 
 2903 void MacroAssembler::store_double(Address dst) {
<a name="15" id="anc15"></a><span class="line-added"> 2904 #ifdef _LP64</span>
<span class="line-added"> 2905   movdbl(dst, xmm0);</span>
<span class="line-added"> 2906 #else</span>
 2907   if (UseSSE &gt;= 2) {
 2908     movdbl(dst, xmm0);
 2909   } else {
<a name="16" id="anc16"></a><span class="line-modified"> 2910     fstp_d(dst);</span>

 2911   }
<a name="17" id="anc17"></a><span class="line-added"> 2912 #endif // LP64</span>
 2913 }
 2914 
 2915 // dst = c = a * b + c
 2916 void MacroAssembler::fmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c) {
 2917   Assembler::vfmadd231sd(c, a, b);
 2918   if (dst != c) {
 2919     movdbl(dst, c);
 2920   }
 2921 }
 2922 
 2923 // dst = c = a * b + c
 2924 void MacroAssembler::fmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c) {
 2925   Assembler::vfmadd231ss(c, a, b);
 2926   if (dst != c) {
 2927     movflt(dst, c);
 2928   }
 2929 }
 2930 
 2931 // dst = c = a * b + c
 2932 void MacroAssembler::vfmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len) {
 2933   Assembler::vfmadd231pd(c, a, b, vector_len);
 2934   if (dst != c) {
 2935     vmovdqu(dst, c);
 2936   }
 2937 }
 2938 
 2939 // dst = c = a * b + c
 2940 void MacroAssembler::vfmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len) {
 2941   Assembler::vfmadd231ps(c, a, b, vector_len);
 2942   if (dst != c) {
 2943     vmovdqu(dst, c);
 2944   }
 2945 }
 2946 
 2947 // dst = c = a * b + c
 2948 void MacroAssembler::vfmad(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len) {
 2949   Assembler::vfmadd231pd(c, a, b, vector_len);
 2950   if (dst != c) {
 2951     vmovdqu(dst, c);
 2952   }
 2953 }
 2954 
 2955 // dst = c = a * b + c
 2956 void MacroAssembler::vfmaf(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len) {
 2957   Assembler::vfmadd231ps(c, a, b, vector_len);
 2958   if (dst != c) {
 2959     vmovdqu(dst, c);
 2960   }
 2961 }
 2962 
 2963 void MacroAssembler::incrementl(AddressLiteral dst) {
 2964   if (reachable(dst)) {
 2965     incrementl(as_Address(dst));
 2966   } else {
 2967     lea(rscratch1, dst);
 2968     incrementl(Address(rscratch1, 0));
 2969   }
 2970 }
 2971 
 2972 void MacroAssembler::incrementl(ArrayAddress dst) {
 2973   incrementl(as_Address(dst));
 2974 }
 2975 
 2976 void MacroAssembler::incrementl(Register reg, int value) {
 2977   if (value == min_jint) {addl(reg, value) ; return; }
 2978   if (value &lt;  0) { decrementl(reg, -value); return; }
 2979   if (value == 0) {                        ; return; }
 2980   if (value == 1 &amp;&amp; UseIncDec) { incl(reg) ; return; }
 2981   /* else */      { addl(reg, value)       ; return; }
 2982 }
 2983 
 2984 void MacroAssembler::incrementl(Address dst, int value) {
 2985   if (value == min_jint) {addl(dst, value) ; return; }
 2986   if (value &lt;  0) { decrementl(dst, -value); return; }
 2987   if (value == 0) {                        ; return; }
 2988   if (value == 1 &amp;&amp; UseIncDec) { incl(dst) ; return; }
 2989   /* else */      { addl(dst, value)       ; return; }
 2990 }
 2991 
 2992 void MacroAssembler::jump(AddressLiteral dst) {
 2993   if (reachable(dst)) {
 2994     jmp_literal(dst.target(), dst.rspec());
 2995   } else {
 2996     lea(rscratch1, dst);
 2997     jmp(rscratch1);
 2998   }
 2999 }
 3000 
 3001 void MacroAssembler::jump_cc(Condition cc, AddressLiteral dst) {
 3002   if (reachable(dst)) {
 3003     InstructionMark im(this);
 3004     relocate(dst.reloc());
 3005     const int short_size = 2;
 3006     const int long_size = 6;
 3007     int offs = (intptr_t)dst.target() - ((intptr_t)pc());
 3008     if (dst.reloc() == relocInfo::none &amp;&amp; is8bit(offs - short_size)) {
 3009       // 0111 tttn #8-bit disp
 3010       emit_int8(0x70 | cc);
 3011       emit_int8((offs - short_size) &amp; 0xFF);
 3012     } else {
 3013       // 0000 1111 1000 tttn #32-bit disp
 3014       emit_int8(0x0F);
 3015       emit_int8((unsigned char)(0x80 | cc));
 3016       emit_int32(offs - long_size);
 3017     }
 3018   } else {
 3019 #ifdef ASSERT
 3020     warning(&quot;reversing conditional branch&quot;);
 3021 #endif /* ASSERT */
 3022     Label skip;
 3023     jccb(reverse[cc], skip);
 3024     lea(rscratch1, dst);
 3025     Assembler::jmp(rscratch1);
 3026     bind(skip);
 3027   }
 3028 }
 3029 
 3030 void MacroAssembler::ldmxcsr(AddressLiteral src) {
 3031   if (reachable(src)) {
 3032     Assembler::ldmxcsr(as_Address(src));
 3033   } else {
 3034     lea(rscratch1, src);
 3035     Assembler::ldmxcsr(Address(rscratch1, 0));
 3036   }
 3037 }
 3038 
 3039 int MacroAssembler::load_signed_byte(Register dst, Address src) {
 3040   int off;
 3041   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
 3042     off = offset();
 3043     movsbl(dst, src); // movsxb
 3044   } else {
 3045     off = load_unsigned_byte(dst, src);
 3046     shll(dst, 24);
 3047     sarl(dst, 24);
 3048   }
 3049   return off;
 3050 }
 3051 
 3052 // Note: load_signed_short used to be called load_signed_word.
 3053 // Although the &#39;w&#39; in x86 opcodes refers to the term &quot;word&quot; in the assembler
 3054 // manual, which means 16 bits, that usage is found nowhere in HotSpot code.
 3055 // The term &quot;word&quot; in HotSpot means a 32- or 64-bit machine word.
 3056 int MacroAssembler::load_signed_short(Register dst, Address src) {
 3057   int off;
 3058   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
 3059     // This is dubious to me since it seems safe to do a signed 16 =&gt; 64 bit
 3060     // version but this is what 64bit has always done. This seems to imply
 3061     // that users are only using 32bits worth.
 3062     off = offset();
 3063     movswl(dst, src); // movsxw
 3064   } else {
 3065     off = load_unsigned_short(dst, src);
 3066     shll(dst, 16);
 3067     sarl(dst, 16);
 3068   }
 3069   return off;
 3070 }
 3071 
 3072 int MacroAssembler::load_unsigned_byte(Register dst, Address src) {
 3073   // According to Intel Doc. AP-526, &quot;Zero-Extension of Short&quot;, p.16,
 3074   // and &quot;3.9 Partial Register Penalties&quot;, p. 22).
 3075   int off;
 3076   if (LP64_ONLY(true || ) VM_Version::is_P6() || src.uses(dst)) {
 3077     off = offset();
 3078     movzbl(dst, src); // movzxb
 3079   } else {
 3080     xorl(dst, dst);
 3081     off = offset();
 3082     movb(dst, src);
 3083   }
 3084   return off;
 3085 }
 3086 
 3087 // Note: load_unsigned_short used to be called load_unsigned_word.
 3088 int MacroAssembler::load_unsigned_short(Register dst, Address src) {
 3089   // According to Intel Doc. AP-526, &quot;Zero-Extension of Short&quot;, p.16,
 3090   // and &quot;3.9 Partial Register Penalties&quot;, p. 22).
 3091   int off;
 3092   if (LP64_ONLY(true ||) VM_Version::is_P6() || src.uses(dst)) {
 3093     off = offset();
 3094     movzwl(dst, src); // movzxw
 3095   } else {
 3096     xorl(dst, dst);
 3097     off = offset();
 3098     movw(dst, src);
 3099   }
 3100   return off;
 3101 }
 3102 
 3103 void MacroAssembler::load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2) {
 3104   switch (size_in_bytes) {
 3105 #ifndef _LP64
 3106   case  8:
 3107     assert(dst2 != noreg, &quot;second dest register required&quot;);
 3108     movl(dst,  src);
 3109     movl(dst2, src.plus_disp(BytesPerInt));
 3110     break;
 3111 #else
 3112   case  8:  movq(dst, src); break;
 3113 #endif
 3114   case  4:  movl(dst, src); break;
 3115   case  2:  is_signed ? load_signed_short(dst, src) : load_unsigned_short(dst, src); break;
 3116   case  1:  is_signed ? load_signed_byte( dst, src) : load_unsigned_byte( dst, src); break;
 3117   default:  ShouldNotReachHere();
 3118   }
 3119 }
 3120 
 3121 void MacroAssembler::store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2) {
 3122   switch (size_in_bytes) {
 3123 #ifndef _LP64
 3124   case  8:
 3125     assert(src2 != noreg, &quot;second source register required&quot;);
 3126     movl(dst,                        src);
 3127     movl(dst.plus_disp(BytesPerInt), src2);
 3128     break;
 3129 #else
 3130   case  8:  movq(dst, src); break;
 3131 #endif
 3132   case  4:  movl(dst, src); break;
 3133   case  2:  movw(dst, src); break;
 3134   case  1:  movb(dst, src); break;
 3135   default:  ShouldNotReachHere();
 3136   }
 3137 }
 3138 
 3139 void MacroAssembler::mov32(AddressLiteral dst, Register src) {
 3140   if (reachable(dst)) {
 3141     movl(as_Address(dst), src);
 3142   } else {
 3143     lea(rscratch1, dst);
 3144     movl(Address(rscratch1, 0), src);
 3145   }
 3146 }
 3147 
 3148 void MacroAssembler::mov32(Register dst, AddressLiteral src) {
 3149   if (reachable(src)) {
 3150     movl(dst, as_Address(src));
 3151   } else {
 3152     lea(rscratch1, src);
 3153     movl(dst, Address(rscratch1, 0));
 3154   }
 3155 }
 3156 
 3157 // C++ bool manipulation
 3158 
 3159 void MacroAssembler::movbool(Register dst, Address src) {
 3160   if(sizeof(bool) == 1)
 3161     movb(dst, src);
 3162   else if(sizeof(bool) == 2)
 3163     movw(dst, src);
 3164   else if(sizeof(bool) == 4)
 3165     movl(dst, src);
 3166   else
 3167     // unsupported
 3168     ShouldNotReachHere();
 3169 }
 3170 
 3171 void MacroAssembler::movbool(Address dst, bool boolconst) {
 3172   if(sizeof(bool) == 1)
 3173     movb(dst, (int) boolconst);
 3174   else if(sizeof(bool) == 2)
 3175     movw(dst, (int) boolconst);
 3176   else if(sizeof(bool) == 4)
 3177     movl(dst, (int) boolconst);
 3178   else
 3179     // unsupported
 3180     ShouldNotReachHere();
 3181 }
 3182 
 3183 void MacroAssembler::movbool(Address dst, Register src) {
 3184   if(sizeof(bool) == 1)
 3185     movb(dst, src);
 3186   else if(sizeof(bool) == 2)
 3187     movw(dst, src);
 3188   else if(sizeof(bool) == 4)
 3189     movl(dst, src);
 3190   else
 3191     // unsupported
 3192     ShouldNotReachHere();
 3193 }
 3194 
 3195 void MacroAssembler::movbyte(ArrayAddress dst, int src) {
 3196   movb(as_Address(dst), src);
 3197 }
 3198 
 3199 void MacroAssembler::movdl(XMMRegister dst, AddressLiteral src) {
 3200   if (reachable(src)) {
 3201     movdl(dst, as_Address(src));
 3202   } else {
 3203     lea(rscratch1, src);
 3204     movdl(dst, Address(rscratch1, 0));
 3205   }
 3206 }
 3207 
 3208 void MacroAssembler::movq(XMMRegister dst, AddressLiteral src) {
 3209   if (reachable(src)) {
 3210     movq(dst, as_Address(src));
 3211   } else {
 3212     lea(rscratch1, src);
 3213     movq(dst, Address(rscratch1, 0));
 3214   }
 3215 }
 3216 
 3217 #ifdef COMPILER2
 3218 void MacroAssembler::setvectmask(Register dst, Register src) {
 3219   guarantee(PostLoopMultiversioning, &quot;must be&quot;);
 3220   Assembler::movl(dst, 1);
 3221   Assembler::shlxl(dst, dst, src);
 3222   Assembler::decl(dst);
 3223   Assembler::kmovdl(k1, dst);
 3224   Assembler::movl(dst, src);
 3225 }
 3226 
 3227 void MacroAssembler::restorevectmask() {
 3228   guarantee(PostLoopMultiversioning, &quot;must be&quot;);
 3229   Assembler::knotwl(k1, k0);
 3230 }
 3231 #endif // COMPILER2
 3232 
 3233 void MacroAssembler::movdbl(XMMRegister dst, AddressLiteral src) {
 3234   if (reachable(src)) {
 3235     if (UseXmmLoadAndClearUpper) {
 3236       movsd (dst, as_Address(src));
 3237     } else {
 3238       movlpd(dst, as_Address(src));
 3239     }
 3240   } else {
 3241     lea(rscratch1, src);
 3242     if (UseXmmLoadAndClearUpper) {
 3243       movsd (dst, Address(rscratch1, 0));
 3244     } else {
 3245       movlpd(dst, Address(rscratch1, 0));
 3246     }
 3247   }
 3248 }
 3249 
 3250 void MacroAssembler::movflt(XMMRegister dst, AddressLiteral src) {
 3251   if (reachable(src)) {
 3252     movss(dst, as_Address(src));
 3253   } else {
 3254     lea(rscratch1, src);
 3255     movss(dst, Address(rscratch1, 0));
 3256   }
 3257 }
 3258 
 3259 void MacroAssembler::movptr(Register dst, Register src) {
 3260   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
 3261 }
 3262 
 3263 void MacroAssembler::movptr(Register dst, Address src) {
 3264   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
 3265 }
 3266 
 3267 // src should NEVER be a real pointer. Use AddressLiteral for true pointers
 3268 void MacroAssembler::movptr(Register dst, intptr_t src) {
 3269   LP64_ONLY(mov64(dst, src)) NOT_LP64(movl(dst, src));
 3270 }
 3271 
 3272 void MacroAssembler::movptr(Address dst, Register src) {
 3273   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
 3274 }
 3275 
 3276 void MacroAssembler::movdqu(Address dst, XMMRegister src) {
 3277     assert(((src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
 3278     Assembler::movdqu(dst, src);
 3279 }
 3280 
 3281 void MacroAssembler::movdqu(XMMRegister dst, Address src) {
 3282     assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
 3283     Assembler::movdqu(dst, src);
 3284 }
 3285 
 3286 void MacroAssembler::movdqu(XMMRegister dst, XMMRegister src) {
 3287     assert(((dst-&gt;encoding() &lt; 16  &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
 3288     Assembler::movdqu(dst, src);
 3289 }
 3290 
 3291 void MacroAssembler::movdqu(XMMRegister dst, AddressLiteral src, Register scratchReg) {
 3292   if (reachable(src)) {
 3293     movdqu(dst, as_Address(src));
 3294   } else {
 3295     lea(scratchReg, src);
 3296     movdqu(dst, Address(scratchReg, 0));
 3297   }
 3298 }
 3299 
 3300 void MacroAssembler::vmovdqu(Address dst, XMMRegister src) {
 3301     assert(((src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
 3302     Assembler::vmovdqu(dst, src);
 3303 }
 3304 
 3305 void MacroAssembler::vmovdqu(XMMRegister dst, Address src) {
 3306     assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
 3307     Assembler::vmovdqu(dst, src);
 3308 }
 3309 
 3310 void MacroAssembler::vmovdqu(XMMRegister dst, XMMRegister src) {
 3311     assert(((dst-&gt;encoding() &lt; 16  &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
 3312     Assembler::vmovdqu(dst, src);
 3313 }
 3314 
 3315 void MacroAssembler::vmovdqu(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
 3316   if (reachable(src)) {
 3317     vmovdqu(dst, as_Address(src));
 3318   }
 3319   else {
 3320     lea(scratch_reg, src);
 3321     vmovdqu(dst, Address(scratch_reg, 0));
 3322   }
 3323 }
 3324 
 3325 void MacroAssembler::evmovdquq(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch) {
 3326   if (reachable(src)) {
 3327     Assembler::evmovdquq(dst, as_Address(src), vector_len);
 3328   } else {
 3329     lea(rscratch, src);
 3330     Assembler::evmovdquq(dst, Address(rscratch, 0), vector_len);
 3331   }
 3332 }
 3333 
 3334 void MacroAssembler::movdqa(XMMRegister dst, AddressLiteral src) {
 3335   if (reachable(src)) {
 3336     Assembler::movdqa(dst, as_Address(src));
 3337   } else {
 3338     lea(rscratch1, src);
 3339     Assembler::movdqa(dst, Address(rscratch1, 0));
 3340   }
 3341 }
 3342 
 3343 void MacroAssembler::movsd(XMMRegister dst, AddressLiteral src) {
 3344   if (reachable(src)) {
 3345     Assembler::movsd(dst, as_Address(src));
 3346   } else {
 3347     lea(rscratch1, src);
 3348     Assembler::movsd(dst, Address(rscratch1, 0));
 3349   }
 3350 }
 3351 
 3352 void MacroAssembler::movss(XMMRegister dst, AddressLiteral src) {
 3353   if (reachable(src)) {
 3354     Assembler::movss(dst, as_Address(src));
 3355   } else {
 3356     lea(rscratch1, src);
 3357     Assembler::movss(dst, Address(rscratch1, 0));
 3358   }
 3359 }
 3360 
 3361 void MacroAssembler::mulsd(XMMRegister dst, AddressLiteral src) {
 3362   if (reachable(src)) {
 3363     Assembler::mulsd(dst, as_Address(src));
 3364   } else {
 3365     lea(rscratch1, src);
 3366     Assembler::mulsd(dst, Address(rscratch1, 0));
 3367   }
 3368 }
 3369 
 3370 void MacroAssembler::mulss(XMMRegister dst, AddressLiteral src) {
 3371   if (reachable(src)) {
 3372     Assembler::mulss(dst, as_Address(src));
 3373   } else {
 3374     lea(rscratch1, src);
 3375     Assembler::mulss(dst, Address(rscratch1, 0));
 3376   }
 3377 }
 3378 
 3379 void MacroAssembler::null_check(Register reg, int offset) {
 3380   if (needs_explicit_null_check(offset)) {
 3381     // provoke OS NULL exception if reg = NULL by
 3382     // accessing M[reg] w/o changing any (non-CC) registers
 3383     // NOTE: cmpl is plenty here to provoke a segv
 3384     cmpptr(rax, Address(reg, 0));
 3385     // Note: should probably use testl(rax, Address(reg, 0));
 3386     //       may be shorter code (however, this version of
 3387     //       testl needs to be implemented first)
 3388   } else {
 3389     // nothing to do, (later) access of M[reg + offset]
 3390     // will provoke OS NULL exception if reg = NULL
 3391   }
 3392 }
 3393 
 3394 void MacroAssembler::os_breakpoint() {
 3395   // instead of directly emitting a breakpoint, call os:breakpoint for better debugability
 3396   // (e.g., MSVC can&#39;t call ps() otherwise)
 3397   call(RuntimeAddress(CAST_FROM_FN_PTR(address, os::breakpoint)));
 3398 }
 3399 
 3400 void MacroAssembler::unimplemented(const char* what) {
 3401   const char* buf = NULL;
 3402   {
 3403     ResourceMark rm;
 3404     stringStream ss;
 3405     ss.print(&quot;unimplemented: %s&quot;, what);
 3406     buf = code_string(ss.as_string());
 3407   }
 3408   stop(buf);
 3409 }
 3410 
 3411 #ifdef _LP64
 3412 #define XSTATE_BV 0x200
 3413 #endif
 3414 
 3415 void MacroAssembler::pop_CPU_state() {
 3416   pop_FPU_state();
 3417   pop_IU_state();
 3418 }
 3419 
 3420 void MacroAssembler::pop_FPU_state() {
 3421 #ifndef _LP64
 3422   frstor(Address(rsp, 0));
 3423 #else
 3424   fxrstor(Address(rsp, 0));
 3425 #endif
 3426   addptr(rsp, FPUStateSizeInWords * wordSize);
 3427 }
 3428 
 3429 void MacroAssembler::pop_IU_state() {
 3430   popa();
 3431   LP64_ONLY(addq(rsp, 8));
 3432   popf();
 3433 }
 3434 
 3435 // Save Integer and Float state
 3436 // Warning: Stack must be 16 byte aligned (64bit)
 3437 void MacroAssembler::push_CPU_state() {
 3438   push_IU_state();
 3439   push_FPU_state();
 3440 }
 3441 
 3442 void MacroAssembler::push_FPU_state() {
 3443   subptr(rsp, FPUStateSizeInWords * wordSize);
 3444 #ifndef _LP64
 3445   fnsave(Address(rsp, 0));
 3446   fwait();
 3447 #else
 3448   fxsave(Address(rsp, 0));
 3449 #endif // LP64
 3450 }
 3451 
 3452 void MacroAssembler::push_IU_state() {
 3453   // Push flags first because pusha kills them
 3454   pushf();
 3455   // Make sure rsp stays 16-byte aligned
 3456   LP64_ONLY(subq(rsp, 8));
 3457   pusha();
 3458 }
 3459 
 3460 void MacroAssembler::reset_last_Java_frame(Register java_thread, bool clear_fp) { // determine java_thread register
 3461   if (!java_thread-&gt;is_valid()) {
 3462     java_thread = rdi;
 3463     get_thread(java_thread);
 3464   }
 3465   // we must set sp to zero to clear frame
 3466   movptr(Address(java_thread, JavaThread::last_Java_sp_offset()), NULL_WORD);
 3467   if (clear_fp) {
 3468     movptr(Address(java_thread, JavaThread::last_Java_fp_offset()), NULL_WORD);
 3469   }
 3470 
 3471   // Always clear the pc because it could have been set by make_walkable()
 3472   movptr(Address(java_thread, JavaThread::last_Java_pc_offset()), NULL_WORD);
 3473 
 3474   vzeroupper();
 3475 }
 3476 
 3477 void MacroAssembler::restore_rax(Register tmp) {
 3478   if (tmp == noreg) pop(rax);
 3479   else if (tmp != rax) mov(rax, tmp);
 3480 }
 3481 
 3482 void MacroAssembler::round_to(Register reg, int modulus) {
 3483   addptr(reg, modulus - 1);
 3484   andptr(reg, -modulus);
 3485 }
 3486 
 3487 void MacroAssembler::save_rax(Register tmp) {
 3488   if (tmp == noreg) push(rax);
 3489   else if (tmp != rax) mov(tmp, rax);
 3490 }
 3491 
 3492 void MacroAssembler::safepoint_poll(Label&amp; slow_path, Register thread_reg, Register temp_reg) {
 3493   if (SafepointMechanism::uses_thread_local_poll()) {
 3494 #ifdef _LP64
 3495     assert(thread_reg == r15_thread, &quot;should be&quot;);
 3496 #else
 3497     if (thread_reg == noreg) {
 3498       thread_reg = temp_reg;
 3499       get_thread(thread_reg);
 3500     }
 3501 #endif
 3502     testb(Address(thread_reg, Thread::polling_page_offset()), SafepointMechanism::poll_bit());
 3503     jcc(Assembler::notZero, slow_path); // handshake bit set implies poll
 3504   } else {
 3505     cmp32(ExternalAddress(SafepointSynchronize::address_of_state()),
 3506         SafepointSynchronize::_not_synchronized);
 3507     jcc(Assembler::notEqual, slow_path);
 3508   }
 3509 }
 3510 
 3511 // Calls to C land
 3512 //
 3513 // When entering C land, the rbp, &amp; rsp of the last Java frame have to be recorded
 3514 // in the (thread-local) JavaThread object. When leaving C land, the last Java fp
 3515 // has to be reset to 0. This is required to allow proper stack traversal.
 3516 void MacroAssembler::set_last_Java_frame(Register java_thread,
 3517                                          Register last_java_sp,
 3518                                          Register last_java_fp,
 3519                                          address  last_java_pc) {
 3520   vzeroupper();
 3521   // determine java_thread register
 3522   if (!java_thread-&gt;is_valid()) {
 3523     java_thread = rdi;
 3524     get_thread(java_thread);
 3525   }
 3526   // determine last_java_sp register
 3527   if (!last_java_sp-&gt;is_valid()) {
 3528     last_java_sp = rsp;
 3529   }
 3530 
 3531   // last_java_fp is optional
 3532 
 3533   if (last_java_fp-&gt;is_valid()) {
 3534     movptr(Address(java_thread, JavaThread::last_Java_fp_offset()), last_java_fp);
 3535   }
 3536 
 3537   // last_java_pc is optional
 3538 
 3539   if (last_java_pc != NULL) {
 3540     lea(Address(java_thread,
 3541                  JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_pc_offset()),
 3542         InternalAddress(last_java_pc));
 3543 
 3544   }
 3545   movptr(Address(java_thread, JavaThread::last_Java_sp_offset()), last_java_sp);
 3546 }
 3547 
 3548 void MacroAssembler::shlptr(Register dst, int imm8) {
 3549   LP64_ONLY(shlq(dst, imm8)) NOT_LP64(shll(dst, imm8));
 3550 }
 3551 
 3552 void MacroAssembler::shrptr(Register dst, int imm8) {
 3553   LP64_ONLY(shrq(dst, imm8)) NOT_LP64(shrl(dst, imm8));
 3554 }
 3555 
 3556 void MacroAssembler::sign_extend_byte(Register reg) {
 3557   if (LP64_ONLY(true ||) (VM_Version::is_P6() &amp;&amp; reg-&gt;has_byte_register())) {
 3558     movsbl(reg, reg); // movsxb
 3559   } else {
 3560     shll(reg, 24);
 3561     sarl(reg, 24);
 3562   }
 3563 }
 3564 
 3565 void MacroAssembler::sign_extend_short(Register reg) {
 3566   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
 3567     movswl(reg, reg); // movsxw
 3568   } else {
 3569     shll(reg, 16);
 3570     sarl(reg, 16);
 3571   }
 3572 }
 3573 
 3574 void MacroAssembler::testl(Register dst, AddressLiteral src) {
 3575   assert(reachable(src), &quot;Address should be reachable&quot;);
 3576   testl(dst, as_Address(src));
 3577 }
 3578 
 3579 void MacroAssembler::pcmpeqb(XMMRegister dst, XMMRegister src) {
 3580   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3581   Assembler::pcmpeqb(dst, src);
 3582 }
 3583 
 3584 void MacroAssembler::pcmpeqw(XMMRegister dst, XMMRegister src) {
 3585   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3586   Assembler::pcmpeqw(dst, src);
 3587 }
 3588 
 3589 void MacroAssembler::pcmpestri(XMMRegister dst, Address src, int imm8) {
 3590   assert((dst-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
 3591   Assembler::pcmpestri(dst, src, imm8);
 3592 }
 3593 
 3594 void MacroAssembler::pcmpestri(XMMRegister dst, XMMRegister src, int imm8) {
 3595   assert((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
 3596   Assembler::pcmpestri(dst, src, imm8);
 3597 }
 3598 
 3599 void MacroAssembler::pmovzxbw(XMMRegister dst, XMMRegister src) {
 3600   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3601   Assembler::pmovzxbw(dst, src);
 3602 }
 3603 
 3604 void MacroAssembler::pmovzxbw(XMMRegister dst, Address src) {
 3605   assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3606   Assembler::pmovzxbw(dst, src);
 3607 }
 3608 
 3609 void MacroAssembler::pmovmskb(Register dst, XMMRegister src) {
 3610   assert((src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
 3611   Assembler::pmovmskb(dst, src);
 3612 }
 3613 
 3614 void MacroAssembler::ptest(XMMRegister dst, XMMRegister src) {
 3615   assert((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
 3616   Assembler::ptest(dst, src);
 3617 }
 3618 
 3619 void MacroAssembler::sqrtsd(XMMRegister dst, AddressLiteral src) {
 3620   if (reachable(src)) {
 3621     Assembler::sqrtsd(dst, as_Address(src));
 3622   } else {
 3623     lea(rscratch1, src);
 3624     Assembler::sqrtsd(dst, Address(rscratch1, 0));
 3625   }
 3626 }
 3627 
 3628 void MacroAssembler::sqrtss(XMMRegister dst, AddressLiteral src) {
 3629   if (reachable(src)) {
 3630     Assembler::sqrtss(dst, as_Address(src));
 3631   } else {
 3632     lea(rscratch1, src);
 3633     Assembler::sqrtss(dst, Address(rscratch1, 0));
 3634   }
 3635 }
 3636 
 3637 void MacroAssembler::subsd(XMMRegister dst, AddressLiteral src) {
 3638   if (reachable(src)) {
 3639     Assembler::subsd(dst, as_Address(src));
 3640   } else {
 3641     lea(rscratch1, src);
 3642     Assembler::subsd(dst, Address(rscratch1, 0));
 3643   }
 3644 }
 3645 
 3646 void MacroAssembler::roundsd(XMMRegister dst, AddressLiteral src, int32_t rmode, Register scratch_reg) {
 3647   if (reachable(src)) {
 3648     Assembler::roundsd(dst, as_Address(src), rmode);
 3649   } else {
 3650     lea(scratch_reg, src);
 3651     Assembler::roundsd(dst, Address(scratch_reg, 0), rmode);
 3652   }
 3653 }
 3654 
 3655 void MacroAssembler::subss(XMMRegister dst, AddressLiteral src) {
 3656   if (reachable(src)) {
 3657     Assembler::subss(dst, as_Address(src));
 3658   } else {
 3659     lea(rscratch1, src);
 3660     Assembler::subss(dst, Address(rscratch1, 0));
 3661   }
 3662 }
 3663 
 3664 void MacroAssembler::ucomisd(XMMRegister dst, AddressLiteral src) {
 3665   if (reachable(src)) {
 3666     Assembler::ucomisd(dst, as_Address(src));
 3667   } else {
 3668     lea(rscratch1, src);
 3669     Assembler::ucomisd(dst, Address(rscratch1, 0));
 3670   }
 3671 }
 3672 
 3673 void MacroAssembler::ucomiss(XMMRegister dst, AddressLiteral src) {
 3674   if (reachable(src)) {
 3675     Assembler::ucomiss(dst, as_Address(src));
 3676   } else {
 3677     lea(rscratch1, src);
 3678     Assembler::ucomiss(dst, Address(rscratch1, 0));
 3679   }
 3680 }
 3681 
 3682 void MacroAssembler::xorpd(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
 3683   // Used in sign-bit flipping with aligned address.
 3684   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
 3685   if (reachable(src)) {
 3686     Assembler::xorpd(dst, as_Address(src));
 3687   } else {
 3688     lea(scratch_reg, src);
 3689     Assembler::xorpd(dst, Address(scratch_reg, 0));
 3690   }
 3691 }
 3692 
 3693 void MacroAssembler::xorpd(XMMRegister dst, XMMRegister src) {
 3694   if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512dq() &amp;&amp; (dst-&gt;encoding() == src-&gt;encoding())) {
 3695     Assembler::vpxor(dst, dst, src, Assembler::AVX_512bit);
 3696   }
 3697   else {
 3698     Assembler::xorpd(dst, src);
 3699   }
 3700 }
 3701 
 3702 void MacroAssembler::xorps(XMMRegister dst, XMMRegister src) {
 3703   if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512dq() &amp;&amp; (dst-&gt;encoding() == src-&gt;encoding())) {
 3704     Assembler::vpxor(dst, dst, src, Assembler::AVX_512bit);
 3705   } else {
 3706     Assembler::xorps(dst, src);
 3707   }
 3708 }
 3709 
 3710 void MacroAssembler::xorps(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
 3711   // Used in sign-bit flipping with aligned address.
 3712   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
 3713   if (reachable(src)) {
 3714     Assembler::xorps(dst, as_Address(src));
 3715   } else {
 3716     lea(scratch_reg, src);
 3717     Assembler::xorps(dst, Address(scratch_reg, 0));
 3718   }
 3719 }
 3720 
 3721 void MacroAssembler::pshufb(XMMRegister dst, AddressLiteral src) {
 3722   // Used in sign-bit flipping with aligned address.
 3723   bool aligned_adr = (((intptr_t)src.target() &amp; 15) == 0);
 3724   assert((UseAVX &gt; 0) || aligned_adr, &quot;SSE mode requires address alignment 16 bytes&quot;);
 3725   if (reachable(src)) {
 3726     Assembler::pshufb(dst, as_Address(src));
 3727   } else {
 3728     lea(rscratch1, src);
 3729     Assembler::pshufb(dst, Address(rscratch1, 0));
 3730   }
 3731 }
 3732 
 3733 // AVX 3-operands instructions
 3734 
 3735 void MacroAssembler::vaddsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
 3736   if (reachable(src)) {
 3737     vaddsd(dst, nds, as_Address(src));
 3738   } else {
 3739     lea(rscratch1, src);
 3740     vaddsd(dst, nds, Address(rscratch1, 0));
 3741   }
 3742 }
 3743 
 3744 void MacroAssembler::vaddss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
 3745   if (reachable(src)) {
 3746     vaddss(dst, nds, as_Address(src));
 3747   } else {
 3748     lea(rscratch1, src);
 3749     vaddss(dst, nds, Address(rscratch1, 0));
 3750   }
 3751 }
 3752 
 3753 void MacroAssembler::vpaddd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch) {
 3754   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
 3755   if (reachable(src)) {
 3756     Assembler::vpaddd(dst, nds, as_Address(src), vector_len);
 3757   } else {
 3758     lea(rscratch, src);
 3759     Assembler::vpaddd(dst, nds, Address(rscratch, 0), vector_len);
 3760   }
 3761 }
 3762 
 3763 void MacroAssembler::vabsss(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len) {
 3764   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
 3765   vandps(dst, nds, negate_field, vector_len);
 3766 }
 3767 
 3768 void MacroAssembler::vabssd(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len) {
 3769   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
 3770   vandpd(dst, nds, negate_field, vector_len);
 3771 }
 3772 
 3773 void MacroAssembler::vpaddb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
 3774   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3775   Assembler::vpaddb(dst, nds, src, vector_len);
 3776 }
 3777 
 3778 void MacroAssembler::vpaddb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
 3779   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3780   Assembler::vpaddb(dst, nds, src, vector_len);
 3781 }
 3782 
 3783 void MacroAssembler::vpaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
 3784   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3785   Assembler::vpaddw(dst, nds, src, vector_len);
 3786 }
 3787 
 3788 void MacroAssembler::vpaddw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
 3789   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3790   Assembler::vpaddw(dst, nds, src, vector_len);
 3791 }
 3792 
 3793 void MacroAssembler::vpand(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
 3794   if (reachable(src)) {
 3795     Assembler::vpand(dst, nds, as_Address(src), vector_len);
 3796   } else {
 3797     lea(scratch_reg, src);
 3798     Assembler::vpand(dst, nds, Address(scratch_reg, 0), vector_len);
 3799   }
 3800 }
 3801 
 3802 void MacroAssembler::vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len) {
 3803   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3804   Assembler::vpbroadcastw(dst, src, vector_len);
 3805 }
 3806 
 3807 void MacroAssembler::vpcmpeqb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
 3808   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3809   Assembler::vpcmpeqb(dst, nds, src, vector_len);
 3810 }
 3811 
 3812 void MacroAssembler::vpcmpeqw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
 3813   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3814   Assembler::vpcmpeqw(dst, nds, src, vector_len);
 3815 }
 3816 
 3817 void MacroAssembler::vpmovzxbw(XMMRegister dst, Address src, int vector_len) {
 3818   assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3819   Assembler::vpmovzxbw(dst, src, vector_len);
 3820 }
 3821 
 3822 void MacroAssembler::vpmovmskb(Register dst, XMMRegister src) {
 3823   assert((src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
 3824   Assembler::vpmovmskb(dst, src);
 3825 }
 3826 
 3827 void MacroAssembler::vpmullw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
 3828   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3829   Assembler::vpmullw(dst, nds, src, vector_len);
 3830 }
 3831 
 3832 void MacroAssembler::vpmullw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
 3833   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3834   Assembler::vpmullw(dst, nds, src, vector_len);
 3835 }
 3836 
 3837 void MacroAssembler::vpsubb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
 3838   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3839   Assembler::vpsubb(dst, nds, src, vector_len);
 3840 }
 3841 
 3842 void MacroAssembler::vpsubb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
 3843   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3844   Assembler::vpsubb(dst, nds, src, vector_len);
 3845 }
 3846 
 3847 void MacroAssembler::vpsubw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
 3848   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3849   Assembler::vpsubw(dst, nds, src, vector_len);
 3850 }
 3851 
 3852 void MacroAssembler::vpsubw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
 3853   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3854   Assembler::vpsubw(dst, nds, src, vector_len);
 3855 }
 3856 
 3857 void MacroAssembler::vpsraw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
 3858   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; shift-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3859   Assembler::vpsraw(dst, nds, shift, vector_len);
 3860 }
 3861 
 3862 void MacroAssembler::vpsraw(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
 3863   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3864   Assembler::vpsraw(dst, nds, shift, vector_len);
 3865 }
 3866 
 3867 void MacroAssembler::evpsraq(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
 3868   assert(UseAVX &gt; 2,&quot;&quot;);
 3869   if (!VM_Version::supports_avx512vl() &amp;&amp; vector_len &lt; 2) {
 3870      vector_len = 2;
 3871   }
 3872   Assembler::evpsraq(dst, nds, shift, vector_len);
 3873 }
 3874 
 3875 void MacroAssembler::evpsraq(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
 3876   assert(UseAVX &gt; 2,&quot;&quot;);
 3877   if (!VM_Version::supports_avx512vl() &amp;&amp; vector_len &lt; 2) {
 3878      vector_len = 2;
 3879   }
 3880   Assembler::evpsraq(dst, nds, shift, vector_len);
 3881 }
 3882 
 3883 void MacroAssembler::vpsrlw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
 3884   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; shift-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3885   Assembler::vpsrlw(dst, nds, shift, vector_len);
 3886 }
 3887 
 3888 void MacroAssembler::vpsrlw(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
 3889   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3890   Assembler::vpsrlw(dst, nds, shift, vector_len);
 3891 }
 3892 
 3893 void MacroAssembler::vpsllw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
 3894   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; shift-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3895   Assembler::vpsllw(dst, nds, shift, vector_len);
 3896 }
 3897 
 3898 void MacroAssembler::vpsllw(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
 3899   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3900   Assembler::vpsllw(dst, nds, shift, vector_len);
 3901 }
 3902 
 3903 void MacroAssembler::vptest(XMMRegister dst, XMMRegister src) {
 3904   assert((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
 3905   Assembler::vptest(dst, src);
 3906 }
 3907 
 3908 void MacroAssembler::punpcklbw(XMMRegister dst, XMMRegister src) {
 3909   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3910   Assembler::punpcklbw(dst, src);
 3911 }
 3912 
 3913 void MacroAssembler::pshufd(XMMRegister dst, Address src, int mode) {
 3914   assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
 3915   Assembler::pshufd(dst, src, mode);
 3916 }
 3917 
 3918 void MacroAssembler::pshuflw(XMMRegister dst, XMMRegister src, int mode) {
 3919   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
 3920   Assembler::pshuflw(dst, src, mode);
 3921 }
 3922 
 3923 void MacroAssembler::vandpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
 3924   if (reachable(src)) {
 3925     vandpd(dst, nds, as_Address(src), vector_len);
 3926   } else {
 3927     lea(scratch_reg, src);
 3928     vandpd(dst, nds, Address(scratch_reg, 0), vector_len);
 3929   }
 3930 }
 3931 
 3932 void MacroAssembler::vandps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
 3933   if (reachable(src)) {
 3934     vandps(dst, nds, as_Address(src), vector_len);
 3935   } else {
 3936     lea(scratch_reg, src);
 3937     vandps(dst, nds, Address(scratch_reg, 0), vector_len);
 3938   }
 3939 }
 3940 
 3941 void MacroAssembler::vdivsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
 3942   if (reachable(src)) {
 3943     vdivsd(dst, nds, as_Address(src));
 3944   } else {
 3945     lea(rscratch1, src);
 3946     vdivsd(dst, nds, Address(rscratch1, 0));
 3947   }
 3948 }
 3949 
 3950 void MacroAssembler::vdivss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
 3951   if (reachable(src)) {
 3952     vdivss(dst, nds, as_Address(src));
 3953   } else {
 3954     lea(rscratch1, src);
 3955     vdivss(dst, nds, Address(rscratch1, 0));
 3956   }
 3957 }
 3958 
 3959 void MacroAssembler::vmulsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
 3960   if (reachable(src)) {
 3961     vmulsd(dst, nds, as_Address(src));
 3962   } else {
 3963     lea(rscratch1, src);
 3964     vmulsd(dst, nds, Address(rscratch1, 0));
 3965   }
 3966 }
 3967 
 3968 void MacroAssembler::vmulss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
 3969   if (reachable(src)) {
 3970     vmulss(dst, nds, as_Address(src));
 3971   } else {
 3972     lea(rscratch1, src);
 3973     vmulss(dst, nds, Address(rscratch1, 0));
 3974   }
 3975 }
 3976 
 3977 void MacroAssembler::vsubsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
 3978   if (reachable(src)) {
 3979     vsubsd(dst, nds, as_Address(src));
 3980   } else {
 3981     lea(rscratch1, src);
 3982     vsubsd(dst, nds, Address(rscratch1, 0));
 3983   }
 3984 }
 3985 
 3986 void MacroAssembler::vsubss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
 3987   if (reachable(src)) {
 3988     vsubss(dst, nds, as_Address(src));
 3989   } else {
 3990     lea(rscratch1, src);
 3991     vsubss(dst, nds, Address(rscratch1, 0));
 3992   }
 3993 }
 3994 
 3995 void MacroAssembler::vnegatess(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
 3996   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
 3997   vxorps(dst, nds, src, Assembler::AVX_128bit);
 3998 }
 3999 
 4000 void MacroAssembler::vnegatesd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
 4001   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
 4002   vxorpd(dst, nds, src, Assembler::AVX_128bit);
 4003 }
 4004 
 4005 void MacroAssembler::vxorpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
 4006   if (reachable(src)) {
 4007     vxorpd(dst, nds, as_Address(src), vector_len);
 4008   } else {
 4009     lea(scratch_reg, src);
 4010     vxorpd(dst, nds, Address(scratch_reg, 0), vector_len);
 4011   }
 4012 }
 4013 
 4014 void MacroAssembler::vxorps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
 4015   if (reachable(src)) {
 4016     vxorps(dst, nds, as_Address(src), vector_len);
 4017   } else {
 4018     lea(scratch_reg, src);
 4019     vxorps(dst, nds, Address(scratch_reg, 0), vector_len);
 4020   }
 4021 }
 4022 
 4023 void MacroAssembler::vpxor(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
 4024   if (UseAVX &gt; 1 || (vector_len &lt; 1)) {
 4025     if (reachable(src)) {
 4026       Assembler::vpxor(dst, nds, as_Address(src), vector_len);
 4027     } else {
 4028       lea(scratch_reg, src);
 4029       Assembler::vpxor(dst, nds, Address(scratch_reg, 0), vector_len);
 4030     }
 4031   }
 4032   else {
 4033     MacroAssembler::vxorpd(dst, nds, src, vector_len, scratch_reg);
 4034   }
 4035 }
 4036 
 4037 //-------------------------------------------------------------------------------------------
 4038 #ifdef COMPILER2
 4039 // Generic instructions support for use in .ad files C2 code generation
 4040 
 4041 void MacroAssembler::vabsnegd(int opcode, XMMRegister dst, XMMRegister src, Register scr) {
 4042   if (dst != src) {
 4043     movdqu(dst, src);
 4044   }
 4045   if (opcode == Op_AbsVD) {
 4046     andpd(dst, ExternalAddress(StubRoutines::x86::vector_double_sign_mask()), scr);
 4047   } else {
 4048     assert((opcode == Op_NegVD),&quot;opcode should be Op_NegD&quot;);
 4049     xorpd(dst, ExternalAddress(StubRoutines::x86::vector_double_sign_flip()), scr);
 4050   }
 4051 }
 4052 
 4053 void MacroAssembler::vabsnegd(int opcode, XMMRegister dst, XMMRegister src, int vector_len, Register scr) {
 4054   if (opcode == Op_AbsVD) {
 4055     vandpd(dst, src, ExternalAddress(StubRoutines::x86::vector_double_sign_mask()), vector_len, scr);
 4056   } else {
 4057     assert((opcode == Op_NegVD),&quot;opcode should be Op_NegD&quot;);
 4058     vxorpd(dst, src, ExternalAddress(StubRoutines::x86::vector_double_sign_flip()), vector_len, scr);
 4059   }
 4060 }
 4061 
 4062 void MacroAssembler::vabsnegf(int opcode, XMMRegister dst, XMMRegister src, Register scr) {
 4063   if (dst != src) {
 4064     movdqu(dst, src);
 4065   }
 4066   if (opcode == Op_AbsVF) {
 4067     andps(dst, ExternalAddress(StubRoutines::x86::vector_float_sign_mask()), scr);
 4068   } else {
 4069     assert((opcode == Op_NegVF),&quot;opcode should be Op_NegF&quot;);
 4070     xorps(dst, ExternalAddress(StubRoutines::x86::vector_float_sign_flip()), scr);
 4071   }
 4072 }
 4073 
 4074 void MacroAssembler::vabsnegf(int opcode, XMMRegister dst, XMMRegister src, int vector_len, Register scr) {
 4075   if (opcode == Op_AbsVF) {
 4076     vandps(dst, src, ExternalAddress(StubRoutines::x86::vector_float_sign_mask()), vector_len, scr);
 4077   } else {
 4078     assert((opcode == Op_NegVF),&quot;opcode should be Op_NegF&quot;);
 4079     vxorps(dst, src, ExternalAddress(StubRoutines::x86::vector_float_sign_flip()), vector_len, scr);
 4080   }
 4081 }
 4082 
 4083 void MacroAssembler::vextendbw(bool sign, XMMRegister dst, XMMRegister src) {
 4084   if (sign) {
 4085     pmovsxbw(dst, src);
 4086   } else {
 4087     pmovzxbw(dst, src);
 4088   }
 4089 }
 4090 
 4091 void MacroAssembler::vextendbw(bool sign, XMMRegister dst, XMMRegister src, int vector_len) {
 4092   if (sign) {
 4093     vpmovsxbw(dst, src, vector_len);
 4094   } else {
 4095     vpmovzxbw(dst, src, vector_len);
 4096   }
 4097 }
 4098 
 4099 void MacroAssembler::vshiftd(int opcode, XMMRegister dst, XMMRegister src) {
 4100   if (opcode == Op_RShiftVI) {
 4101     psrad(dst, src);
 4102   } else if (opcode == Op_LShiftVI) {
 4103     pslld(dst, src);
 4104   } else {
 4105     assert((opcode == Op_URShiftVI),&quot;opcode should be Op_URShiftVI&quot;);
 4106     psrld(dst, src);
 4107   }
 4108 }
 4109 
 4110 void MacroAssembler::vshiftd(int opcode, XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
 4111   if (opcode == Op_RShiftVI) {
 4112     vpsrad(dst, nds, src, vector_len);
 4113   } else if (opcode == Op_LShiftVI) {
 4114     vpslld(dst, nds, src, vector_len);
 4115   } else {
 4116     assert((opcode == Op_URShiftVI),&quot;opcode should be Op_URShiftVI&quot;);
 4117     vpsrld(dst, nds, src, vector_len);
 4118   }
 4119 }
 4120 
 4121 void MacroAssembler::vshiftw(int opcode, XMMRegister dst, XMMRegister src) {
 4122   if ((opcode == Op_RShiftVS) || (opcode == Op_RShiftVB)) {
 4123     psraw(dst, src);
 4124   } else if ((opcode == Op_LShiftVS) || (opcode == Op_LShiftVB)) {
 4125     psllw(dst, src);
 4126   } else {
 4127     assert(((opcode == Op_URShiftVS) || (opcode == Op_URShiftVB)),&quot;opcode should be one of Op_URShiftVS or Op_URShiftVB&quot;);
 4128     psrlw(dst, src);
 4129   }
 4130 }
 4131 
 4132 void MacroAssembler::vshiftw(int opcode, XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
 4133   if ((opcode == Op_RShiftVS) || (opcode == Op_RShiftVB)) {
 4134     vpsraw(dst, nds, src, vector_len);
 4135   } else if ((opcode == Op_LShiftVS) || (opcode == Op_LShiftVB)) {
 4136     vpsllw(dst, nds, src, vector_len);
 4137   } else {
 4138     assert(((opcode == Op_URShiftVS) || (opcode == Op_URShiftVB)),&quot;opcode should be one of Op_URShiftVS or Op_URShiftVB&quot;);
 4139     vpsrlw(dst, nds, src, vector_len);
 4140   }
 4141 }
 4142 
 4143 void MacroAssembler::vshiftq(int opcode, XMMRegister dst, XMMRegister src) {
 4144   if (opcode == Op_RShiftVL) {
 4145     psrlq(dst, src);  // using srl to implement sra on pre-avs512 systems
 4146   } else if (opcode == Op_LShiftVL) {
 4147     psllq(dst, src);
 4148   } else {
 4149     assert((opcode == Op_URShiftVL),&quot;opcode should be Op_URShiftVL&quot;);
 4150     psrlq(dst, src);
 4151   }
 4152 }
 4153 
 4154 void MacroAssembler::vshiftq(int opcode, XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
 4155   if (opcode == Op_RShiftVL) {
 4156     evpsraq(dst, nds, src, vector_len);
 4157   } else if (opcode == Op_LShiftVL) {
 4158     vpsllq(dst, nds, src, vector_len);
 4159   } else {
 4160     assert((opcode == Op_URShiftVL),&quot;opcode should be Op_URShiftVL&quot;);
 4161     vpsrlq(dst, nds, src, vector_len);
 4162   }
 4163 }
 4164 #endif
 4165 //-------------------------------------------------------------------------------------------
 4166 
 4167 void MacroAssembler::clear_jweak_tag(Register possibly_jweak) {
 4168   const int32_t inverted_jweak_mask = ~static_cast&lt;int32_t&gt;(JNIHandles::weak_tag_mask);
 4169   STATIC_ASSERT(inverted_jweak_mask == -2); // otherwise check this code
 4170   // The inverted mask is sign-extended
 4171   andptr(possibly_jweak, inverted_jweak_mask);
 4172 }
 4173 
 4174 void MacroAssembler::resolve_jobject(Register value,
 4175                                      Register thread,
 4176                                      Register tmp) {
 4177   assert_different_registers(value, thread, tmp);
 4178   Label done, not_weak;
 4179   testptr(value, value);
 4180   jcc(Assembler::zero, done);                // Use NULL as-is.
 4181   testptr(value, JNIHandles::weak_tag_mask); // Test for jweak tag.
 4182   jcc(Assembler::zero, not_weak);
 4183   // Resolve jweak.
 4184   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
 4185                  value, Address(value, -JNIHandles::weak_tag_value), tmp, thread);
 4186   verify_oop(value);
 4187   jmp(done);
 4188   bind(not_weak);
 4189   // Resolve (untagged) jobject.
 4190   access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp, thread);
 4191   verify_oop(value);
 4192   bind(done);
 4193 }
 4194 
 4195 void MacroAssembler::subptr(Register dst, int32_t imm32) {
 4196   LP64_ONLY(subq(dst, imm32)) NOT_LP64(subl(dst, imm32));
 4197 }
 4198 
 4199 // Force generation of a 4 byte immediate value even if it fits into 8bit
 4200 void MacroAssembler::subptr_imm32(Register dst, int32_t imm32) {
 4201   LP64_ONLY(subq_imm32(dst, imm32)) NOT_LP64(subl_imm32(dst, imm32));
 4202 }
 4203 
 4204 void MacroAssembler::subptr(Register dst, Register src) {
 4205   LP64_ONLY(subq(dst, src)) NOT_LP64(subl(dst, src));
 4206 }
 4207 
 4208 // C++ bool manipulation
 4209 void MacroAssembler::testbool(Register dst) {
 4210   if(sizeof(bool) == 1)
 4211     testb(dst, 0xff);
 4212   else if(sizeof(bool) == 2) {
 4213     // testw implementation needed for two byte bools
 4214     ShouldNotReachHere();
 4215   } else if(sizeof(bool) == 4)
 4216     testl(dst, dst);
 4217   else
 4218     // unsupported
 4219     ShouldNotReachHere();
 4220 }
 4221 
 4222 void MacroAssembler::testptr(Register dst, Register src) {
 4223   LP64_ONLY(testq(dst, src)) NOT_LP64(testl(dst, src));
 4224 }
 4225 
 4226 // Defines obj, preserves var_size_in_bytes, okay for t2 == var_size_in_bytes.
 4227 void MacroAssembler::tlab_allocate(Register thread, Register obj,
 4228                                    Register var_size_in_bytes,
 4229                                    int con_size_in_bytes,
 4230                                    Register t1,
 4231                                    Register t2,
 4232                                    Label&amp; slow_case) {
 4233   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 4234   bs-&gt;tlab_allocate(this, thread, obj, var_size_in_bytes, con_size_in_bytes, t1, t2, slow_case);
 4235 }
 4236 
 4237 // Defines obj, preserves var_size_in_bytes
 4238 void MacroAssembler::eden_allocate(Register thread, Register obj,
 4239                                    Register var_size_in_bytes,
 4240                                    int con_size_in_bytes,
 4241                                    Register t1,
 4242                                    Label&amp; slow_case) {
 4243   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 4244   bs-&gt;eden_allocate(this, thread, obj, var_size_in_bytes, con_size_in_bytes, t1, slow_case);
 4245 }
 4246 
 4247 // Preserves the contents of address, destroys the contents length_in_bytes and temp.
 4248 void MacroAssembler::zero_memory(Register address, Register length_in_bytes, int offset_in_bytes, Register temp) {
 4249   assert(address != length_in_bytes &amp;&amp; address != temp &amp;&amp; temp != length_in_bytes, &quot;registers must be different&quot;);
 4250   assert((offset_in_bytes &amp; (BytesPerWord - 1)) == 0, &quot;offset must be a multiple of BytesPerWord&quot;);
 4251   Label done;
 4252 
 4253   testptr(length_in_bytes, length_in_bytes);
 4254   jcc(Assembler::zero, done);
 4255 
 4256   // initialize topmost word, divide index by 2, check if odd and test if zero
 4257   // note: for the remaining code to work, index must be a multiple of BytesPerWord
 4258 #ifdef ASSERT
 4259   {
 4260     Label L;
 4261     testptr(length_in_bytes, BytesPerWord - 1);
 4262     jcc(Assembler::zero, L);
 4263     stop(&quot;length must be a multiple of BytesPerWord&quot;);
 4264     bind(L);
 4265   }
 4266 #endif
 4267   Register index = length_in_bytes;
 4268   xorptr(temp, temp);    // use _zero reg to clear memory (shorter code)
 4269   if (UseIncDec) {
 4270     shrptr(index, 3);  // divide by 8/16 and set carry flag if bit 2 was set
 4271   } else {
 4272     shrptr(index, 2);  // use 2 instructions to avoid partial flag stall
 4273     shrptr(index, 1);
 4274   }
 4275 #ifndef _LP64
 4276   // index could have not been a multiple of 8 (i.e., bit 2 was set)
 4277   {
 4278     Label even;
 4279     // note: if index was a multiple of 8, then it cannot
 4280     //       be 0 now otherwise it must have been 0 before
 4281     //       =&gt; if it is even, we don&#39;t need to check for 0 again
 4282     jcc(Assembler::carryClear, even);
 4283     // clear topmost word (no jump would be needed if conditional assignment worked here)
 4284     movptr(Address(address, index, Address::times_8, offset_in_bytes - 0*BytesPerWord), temp);
 4285     // index could be 0 now, must check again
 4286     jcc(Assembler::zero, done);
 4287     bind(even);
 4288   }
 4289 #endif // !_LP64
 4290   // initialize remaining object fields: index is a multiple of 2 now
 4291   {
 4292     Label loop;
 4293     bind(loop);
 4294     movptr(Address(address, index, Address::times_8, offset_in_bytes - 1*BytesPerWord), temp);
 4295     NOT_LP64(movptr(Address(address, index, Address::times_8, offset_in_bytes - 2*BytesPerWord), temp);)
 4296     decrement(index);
 4297     jcc(Assembler::notZero, loop);
 4298   }
 4299 
 4300   bind(done);
 4301 }
 4302 
 4303 // Look up the method for a megamorphic invokeinterface call.
 4304 // The target method is determined by &lt;intf_klass, itable_index&gt;.
 4305 // The receiver klass is in recv_klass.
 4306 // On success, the result will be in method_result, and execution falls through.
 4307 // On failure, execution transfers to the given label.
 4308 void MacroAssembler::lookup_interface_method(Register recv_klass,
 4309                                              Register intf_klass,
 4310                                              RegisterOrConstant itable_index,
 4311                                              Register method_result,
 4312                                              Register scan_temp,
 4313                                              Label&amp; L_no_such_interface,
 4314                                              bool return_method) {
 4315   assert_different_registers(recv_klass, intf_klass, scan_temp);
 4316   assert_different_registers(method_result, intf_klass, scan_temp);
 4317   assert(recv_klass != method_result || !return_method,
 4318          &quot;recv_klass can be destroyed when method isn&#39;t needed&quot;);
 4319 
 4320   assert(itable_index.is_constant() || itable_index.as_register() == method_result,
 4321          &quot;caller must use same register for non-constant itable index as for method&quot;);
 4322 
 4323   // Compute start of first itableOffsetEntry (which is at the end of the vtable)
 4324   int vtable_base = in_bytes(Klass::vtable_start_offset());
 4325   int itentry_off = itableMethodEntry::method_offset_in_bytes();
 4326   int scan_step   = itableOffsetEntry::size() * wordSize;
 4327   int vte_size    = vtableEntry::size_in_bytes();
 4328   Address::ScaleFactor times_vte_scale = Address::times_ptr;
 4329   assert(vte_size == wordSize, &quot;else adjust times_vte_scale&quot;);
 4330 
 4331   movl(scan_temp, Address(recv_klass, Klass::vtable_length_offset()));
 4332 
 4333   // %%% Could store the aligned, prescaled offset in the klassoop.
 4334   lea(scan_temp, Address(recv_klass, scan_temp, times_vte_scale, vtable_base));
 4335 
 4336   if (return_method) {
 4337     // Adjust recv_klass by scaled itable_index, so we can free itable_index.
 4338     assert(itableMethodEntry::size() * wordSize == wordSize, &quot;adjust the scaling in the code below&quot;);
 4339     lea(recv_klass, Address(recv_klass, itable_index, Address::times_ptr, itentry_off));
 4340   }
 4341 
 4342   // for (scan = klass-&gt;itable(); scan-&gt;interface() != NULL; scan += scan_step) {
 4343   //   if (scan-&gt;interface() == intf) {
 4344   //     result = (klass + scan-&gt;offset() + itable_index);
 4345   //   }
 4346   // }
 4347   Label search, found_method;
 4348 
 4349   for (int peel = 1; peel &gt;= 0; peel--) {
 4350     movptr(method_result, Address(scan_temp, itableOffsetEntry::interface_offset_in_bytes()));
 4351     cmpptr(intf_klass, method_result);
 4352 
 4353     if (peel) {
 4354       jccb(Assembler::equal, found_method);
 4355     } else {
 4356       jccb(Assembler::notEqual, search);
 4357       // (invert the test to fall through to found_method...)
 4358     }
 4359 
 4360     if (!peel)  break;
 4361 
 4362     bind(search);
 4363 
 4364     // Check that the previous entry is non-null.  A null entry means that
 4365     // the receiver class doesn&#39;t implement the interface, and wasn&#39;t the
 4366     // same as when the caller was compiled.
 4367     testptr(method_result, method_result);
 4368     jcc(Assembler::zero, L_no_such_interface);
 4369     addptr(scan_temp, scan_step);
 4370   }
 4371 
 4372   bind(found_method);
 4373 
 4374   if (return_method) {
 4375     // Got a hit.
 4376     movl(scan_temp, Address(scan_temp, itableOffsetEntry::offset_offset_in_bytes()));
 4377     movptr(method_result, Address(recv_klass, scan_temp, Address::times_1));
 4378   }
 4379 }
 4380 
 4381 
 4382 // virtual method calling
 4383 void MacroAssembler::lookup_virtual_method(Register recv_klass,
 4384                                            RegisterOrConstant vtable_index,
 4385                                            Register method_result) {
 4386   const int base = in_bytes(Klass::vtable_start_offset());
 4387   assert(vtableEntry::size() * wordSize == wordSize, &quot;else adjust the scaling in the code below&quot;);
 4388   Address vtable_entry_addr(recv_klass,
 4389                             vtable_index, Address::times_ptr,
 4390                             base + vtableEntry::method_offset_in_bytes());
 4391   movptr(method_result, vtable_entry_addr);
 4392 }
 4393 
 4394 
 4395 void MacroAssembler::check_klass_subtype(Register sub_klass,
 4396                            Register super_klass,
 4397                            Register temp_reg,
 4398                            Label&amp; L_success) {
 4399   Label L_failure;
 4400   check_klass_subtype_fast_path(sub_klass, super_klass, temp_reg,        &amp;L_success, &amp;L_failure, NULL);
 4401   check_klass_subtype_slow_path(sub_klass, super_klass, temp_reg, noreg, &amp;L_success, NULL);
 4402   bind(L_failure);
 4403 }
 4404 
 4405 
 4406 void MacroAssembler::check_klass_subtype_fast_path(Register sub_klass,
 4407                                                    Register super_klass,
 4408                                                    Register temp_reg,
 4409                                                    Label* L_success,
 4410                                                    Label* L_failure,
 4411                                                    Label* L_slow_path,
 4412                                         RegisterOrConstant super_check_offset) {
 4413   assert_different_registers(sub_klass, super_klass, temp_reg);
 4414   bool must_load_sco = (super_check_offset.constant_or_zero() == -1);
 4415   if (super_check_offset.is_register()) {
 4416     assert_different_registers(sub_klass, super_klass,
 4417                                super_check_offset.as_register());
 4418   } else if (must_load_sco) {
 4419     assert(temp_reg != noreg, &quot;supply either a temp or a register offset&quot;);
 4420   }
 4421 
 4422   Label L_fallthrough;
 4423   int label_nulls = 0;
 4424   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
 4425   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
 4426   if (L_slow_path == NULL) { L_slow_path = &amp;L_fallthrough; label_nulls++; }
 4427   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
 4428 
 4429   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
 4430   int sco_offset = in_bytes(Klass::super_check_offset_offset());
 4431   Address super_check_offset_addr(super_klass, sco_offset);
 4432 
 4433   // Hacked jcc, which &quot;knows&quot; that L_fallthrough, at least, is in
 4434   // range of a jccb.  If this routine grows larger, reconsider at
 4435   // least some of these.
 4436 #define local_jcc(assembler_cond, label)                                \
 4437   if (&amp;(label) == &amp;L_fallthrough)  jccb(assembler_cond, label);         \
 4438   else                             jcc( assembler_cond, label) /*omit semi*/
 4439 
 4440   // Hacked jmp, which may only be used just before L_fallthrough.
 4441 #define final_jmp(label)                                                \
 4442   if (&amp;(label) == &amp;L_fallthrough) { /*do nothing*/ }                    \
 4443   else                            jmp(label)                /*omit semi*/
 4444 
 4445   // If the pointers are equal, we are done (e.g., String[] elements).
 4446   // This self-check enables sharing of secondary supertype arrays among
 4447   // non-primary types such as array-of-interface.  Otherwise, each such
 4448   // type would need its own customized SSA.
 4449   // We move this check to the front of the fast path because many
 4450   // type checks are in fact trivially successful in this manner,
 4451   // so we get a nicely predicted branch right at the start of the check.
 4452   cmpptr(sub_klass, super_klass);
 4453   local_jcc(Assembler::equal, *L_success);
 4454 
 4455   // Check the supertype display:
 4456   if (must_load_sco) {
 4457     // Positive movl does right thing on LP64.
 4458     movl(temp_reg, super_check_offset_addr);
 4459     super_check_offset = RegisterOrConstant(temp_reg);
 4460   }
 4461   Address super_check_addr(sub_klass, super_check_offset, Address::times_1, 0);
 4462   cmpptr(super_klass, super_check_addr); // load displayed supertype
 4463 
 4464   // This check has worked decisively for primary supers.
 4465   // Secondary supers are sought in the super_cache (&#39;super_cache_addr&#39;).
 4466   // (Secondary supers are interfaces and very deeply nested subtypes.)
 4467   // This works in the same check above because of a tricky aliasing
 4468   // between the super_cache and the primary super display elements.
 4469   // (The &#39;super_check_addr&#39; can address either, as the case requires.)
 4470   // Note that the cache is updated below if it does not help us find
 4471   // what we need immediately.
 4472   // So if it was a primary super, we can just fail immediately.
 4473   // Otherwise, it&#39;s the slow path for us (no success at this point).
 4474 
 4475   if (super_check_offset.is_register()) {
 4476     local_jcc(Assembler::equal, *L_success);
 4477     cmpl(super_check_offset.as_register(), sc_offset);
 4478     if (L_failure == &amp;L_fallthrough) {
 4479       local_jcc(Assembler::equal, *L_slow_path);
 4480     } else {
 4481       local_jcc(Assembler::notEqual, *L_failure);
 4482       final_jmp(*L_slow_path);
 4483     }
 4484   } else if (super_check_offset.as_constant() == sc_offset) {
 4485     // Need a slow path; fast failure is impossible.
 4486     if (L_slow_path == &amp;L_fallthrough) {
 4487       local_jcc(Assembler::equal, *L_success);
 4488     } else {
 4489       local_jcc(Assembler::notEqual, *L_slow_path);
 4490       final_jmp(*L_success);
 4491     }
 4492   } else {
 4493     // No slow path; it&#39;s a fast decision.
 4494     if (L_failure == &amp;L_fallthrough) {
 4495       local_jcc(Assembler::equal, *L_success);
 4496     } else {
 4497       local_jcc(Assembler::notEqual, *L_failure);
 4498       final_jmp(*L_success);
 4499     }
 4500   }
 4501 
 4502   bind(L_fallthrough);
 4503 
 4504 #undef local_jcc
 4505 #undef final_jmp
 4506 }
 4507 
 4508 
 4509 void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,
 4510                                                    Register super_klass,
 4511                                                    Register temp_reg,
 4512                                                    Register temp2_reg,
 4513                                                    Label* L_success,
 4514                                                    Label* L_failure,
 4515                                                    bool set_cond_codes) {
 4516   assert_different_registers(sub_klass, super_klass, temp_reg);
 4517   if (temp2_reg != noreg)
 4518     assert_different_registers(sub_klass, super_klass, temp_reg, temp2_reg);
 4519 #define IS_A_TEMP(reg) ((reg) == temp_reg || (reg) == temp2_reg)
 4520 
 4521   Label L_fallthrough;
 4522   int label_nulls = 0;
 4523   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
 4524   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
 4525   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
 4526 
 4527   // a couple of useful fields in sub_klass:
 4528   int ss_offset = in_bytes(Klass::secondary_supers_offset());
 4529   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
 4530   Address secondary_supers_addr(sub_klass, ss_offset);
 4531   Address super_cache_addr(     sub_klass, sc_offset);
 4532 
 4533   // Do a linear scan of the secondary super-klass chain.
 4534   // This code is rarely used, so simplicity is a virtue here.
 4535   // The repne_scan instruction uses fixed registers, which we must spill.
 4536   // Don&#39;t worry too much about pre-existing connections with the input regs.
 4537 
 4538   assert(sub_klass != rax, &quot;killed reg&quot;); // killed by mov(rax, super)
 4539   assert(sub_klass != rcx, &quot;killed reg&quot;); // killed by lea(rcx, &amp;pst_counter)
 4540 
 4541   // Get super_klass value into rax (even if it was in rdi or rcx).
 4542   bool pushed_rax = false, pushed_rcx = false, pushed_rdi = false;
 4543   if (super_klass != rax || UseCompressedOops) {
 4544     if (!IS_A_TEMP(rax)) { push(rax); pushed_rax = true; }
 4545     mov(rax, super_klass);
 4546   }
 4547   if (!IS_A_TEMP(rcx)) { push(rcx); pushed_rcx = true; }
 4548   if (!IS_A_TEMP(rdi)) { push(rdi); pushed_rdi = true; }
 4549 
 4550 #ifndef PRODUCT
 4551   int* pst_counter = &amp;SharedRuntime::_partial_subtype_ctr;
 4552   ExternalAddress pst_counter_addr((address) pst_counter);
 4553   NOT_LP64(  incrementl(pst_counter_addr) );
 4554   LP64_ONLY( lea(rcx, pst_counter_addr) );
 4555   LP64_ONLY( incrementl(Address(rcx, 0)) );
 4556 #endif //PRODUCT
 4557 
 4558   // We will consult the secondary-super array.
 4559   movptr(rdi, secondary_supers_addr);
 4560   // Load the array length.  (Positive movl does right thing on LP64.)
 4561   movl(rcx, Address(rdi, Array&lt;Klass*&gt;::length_offset_in_bytes()));
 4562   // Skip to start of data.
 4563   addptr(rdi, Array&lt;Klass*&gt;::base_offset_in_bytes());
 4564 
 4565   // Scan RCX words at [RDI] for an occurrence of RAX.
 4566   // Set NZ/Z based on last compare.
 4567   // Z flag value will not be set by &#39;repne&#39; if RCX == 0 since &#39;repne&#39; does
 4568   // not change flags (only scas instruction which is repeated sets flags).
 4569   // Set Z = 0 (not equal) before &#39;repne&#39; to indicate that class was not found.
 4570 
 4571     testptr(rax,rax); // Set Z = 0
 4572     repne_scan();
 4573 
 4574   // Unspill the temp. registers:
 4575   if (pushed_rdi)  pop(rdi);
 4576   if (pushed_rcx)  pop(rcx);
 4577   if (pushed_rax)  pop(rax);
 4578 
 4579   if (set_cond_codes) {
 4580     // Special hack for the AD files:  rdi is guaranteed non-zero.
 4581     assert(!pushed_rdi, &quot;rdi must be left non-NULL&quot;);
 4582     // Also, the condition codes are properly set Z/NZ on succeed/failure.
 4583   }
 4584 
 4585   if (L_failure == &amp;L_fallthrough)
 4586         jccb(Assembler::notEqual, *L_failure);
 4587   else  jcc(Assembler::notEqual, *L_failure);
 4588 
 4589   // Success.  Cache the super we found and proceed in triumph.
 4590   movptr(super_cache_addr, super_klass);
 4591 
 4592   if (L_success != &amp;L_fallthrough) {
 4593     jmp(*L_success);
 4594   }
 4595 
 4596 #undef IS_A_TEMP
 4597 
 4598   bind(L_fallthrough);
 4599 }
 4600 
 4601 void MacroAssembler::clinit_barrier(Register klass, Register thread, Label* L_fast_path, Label* L_slow_path) {
 4602   assert(L_fast_path != NULL || L_slow_path != NULL, &quot;at least one is required&quot;);
 4603 
 4604   Label L_fallthrough;
 4605   if (L_fast_path == NULL) {
 4606     L_fast_path = &amp;L_fallthrough;
 4607   } else if (L_slow_path == NULL) {
 4608     L_slow_path = &amp;L_fallthrough;
 4609   }
 4610 
 4611   // Fast path check: class is fully initialized
 4612   cmpb(Address(klass, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
 4613   jcc(Assembler::equal, *L_fast_path);
 4614 
 4615   // Fast path check: current thread is initializer thread
 4616   cmpptr(thread, Address(klass, InstanceKlass::init_thread_offset()));
 4617   if (L_slow_path == &amp;L_fallthrough) {
 4618     jcc(Assembler::equal, *L_fast_path);
 4619     bind(*L_slow_path);
 4620   } else if (L_fast_path == &amp;L_fallthrough) {
 4621     jcc(Assembler::notEqual, *L_slow_path);
 4622     bind(*L_fast_path);
 4623   } else {
 4624     Unimplemented();
 4625   }
 4626 }
 4627 
 4628 void MacroAssembler::cmov32(Condition cc, Register dst, Address src) {
 4629   if (VM_Version::supports_cmov()) {
 4630     cmovl(cc, dst, src);
 4631   } else {
 4632     Label L;
 4633     jccb(negate_condition(cc), L);
 4634     movl(dst, src);
 4635     bind(L);
 4636   }
 4637 }
 4638 
 4639 void MacroAssembler::cmov32(Condition cc, Register dst, Register src) {
 4640   if (VM_Version::supports_cmov()) {
 4641     cmovl(cc, dst, src);
 4642   } else {
 4643     Label L;
 4644     jccb(negate_condition(cc), L);
 4645     movl(dst, src);
 4646     bind(L);
 4647   }
 4648 }
 4649 
<a name="18" id="anc18"></a><span class="line-modified"> 4650 void MacroAssembler::_verify_oop(Register reg, const char* s, const char* file, int line) {</span>
 4651   if (!VerifyOops) return;
 4652 
 4653   // Pass register number to verify_oop_subroutine
 4654   const char* b = NULL;
 4655   {
 4656     ResourceMark rm;
 4657     stringStream ss;
<a name="19" id="anc19"></a><span class="line-modified"> 4658     ss.print(&quot;verify_oop: %s: %s (%s:%d)&quot;, reg-&gt;name(), s, file, line);</span>
 4659     b = code_string(ss.as_string());
 4660   }
 4661   BLOCK_COMMENT(&quot;verify_oop {&quot;);
 4662 #ifdef _LP64
 4663   push(rscratch1);                    // save r10, trashed by movptr()
 4664 #endif
 4665   push(rax);                          // save rax,
 4666   push(reg);                          // pass register argument
 4667   ExternalAddress buffer((address) b);
 4668   // avoid using pushptr, as it modifies scratch registers
 4669   // and our contract is not to modify anything
 4670   movptr(rax, buffer.addr());
 4671   push(rax);
 4672   // call indirectly to solve generation ordering problem
 4673   movptr(rax, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
 4674   call(rax);
 4675   // Caller pops the arguments (oop, message) and restores rax, r10
 4676   BLOCK_COMMENT(&quot;} verify_oop&quot;);
 4677 }
 4678 
 4679 
 4680 RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,
 4681                                                       Register tmp,
 4682                                                       int offset) {
 4683   intptr_t value = *delayed_value_addr;
 4684   if (value != 0)
 4685     return RegisterOrConstant(value + offset);
 4686 
 4687   // load indirectly to solve generation ordering problem
 4688   movptr(tmp, ExternalAddress((address) delayed_value_addr));
 4689 
 4690 #ifdef ASSERT
 4691   { Label L;
 4692     testptr(tmp, tmp);
 4693     if (WizardMode) {
 4694       const char* buf = NULL;
 4695       {
 4696         ResourceMark rm;
 4697         stringStream ss;
 4698         ss.print(&quot;DelayedValue=&quot; INTPTR_FORMAT, delayed_value_addr[1]);
 4699         buf = code_string(ss.as_string());
 4700       }
 4701       jcc(Assembler::notZero, L);
 4702       STOP(buf);
 4703     } else {
 4704       jccb(Assembler::notZero, L);
 4705       hlt();
 4706     }
 4707     bind(L);
 4708   }
 4709 #endif
 4710 
 4711   if (offset != 0)
 4712     addptr(tmp, offset);
 4713 
 4714   return RegisterOrConstant(tmp);
 4715 }
 4716 
 4717 
 4718 Address MacroAssembler::argument_address(RegisterOrConstant arg_slot,
 4719                                          int extra_slot_offset) {
 4720   // cf. TemplateTable::prepare_invoke(), if (load_receiver).
 4721   int stackElementSize = Interpreter::stackElementSize;
 4722   int offset = Interpreter::expr_offset_in_bytes(extra_slot_offset+0);
 4723 #ifdef ASSERT
 4724   int offset1 = Interpreter::expr_offset_in_bytes(extra_slot_offset+1);
 4725   assert(offset1 - offset == stackElementSize, &quot;correct arithmetic&quot;);
 4726 #endif
 4727   Register             scale_reg    = noreg;
 4728   Address::ScaleFactor scale_factor = Address::no_scale;
 4729   if (arg_slot.is_constant()) {
 4730     offset += arg_slot.as_constant() * stackElementSize;
 4731   } else {
 4732     scale_reg    = arg_slot.as_register();
 4733     scale_factor = Address::times(stackElementSize);
 4734   }
 4735   offset += wordSize;           // return PC is on stack
 4736   return Address(rsp, scale_reg, scale_factor, offset);
 4737 }
 4738 
 4739 
<a name="20" id="anc20"></a><span class="line-modified"> 4740 void MacroAssembler::_verify_oop_addr(Address addr, const char* s, const char* file, int line) {</span>
 4741   if (!VerifyOops) return;
 4742 
 4743   // Address adjust(addr.base(), addr.index(), addr.scale(), addr.disp() + BytesPerWord);
 4744   // Pass register number to verify_oop_subroutine
 4745   const char* b = NULL;
 4746   {
 4747     ResourceMark rm;
 4748     stringStream ss;
<a name="21" id="anc21"></a><span class="line-modified"> 4749     ss.print(&quot;verify_oop_addr: %s (%s:%d)&quot;, s, file, line);</span>
 4750     b = code_string(ss.as_string());
 4751   }
 4752 #ifdef _LP64
 4753   push(rscratch1);                    // save r10, trashed by movptr()
 4754 #endif
 4755   push(rax);                          // save rax,
 4756   // addr may contain rsp so we will have to adjust it based on the push
 4757   // we just did (and on 64 bit we do two pushes)
 4758   // NOTE: 64bit seemed to have had a bug in that it did movq(addr, rax); which
 4759   // stores rax into addr which is backwards of what was intended.
 4760   if (addr.uses(rsp)) {
 4761     lea(rax, addr);
 4762     pushptr(Address(rax, LP64_ONLY(2 *) BytesPerWord));
 4763   } else {
 4764     pushptr(addr);
 4765   }
 4766 
 4767   ExternalAddress buffer((address) b);
 4768   // pass msg argument
 4769   // avoid using pushptr, as it modifies scratch registers
 4770   // and our contract is not to modify anything
 4771   movptr(rax, buffer.addr());
 4772   push(rax);
 4773 
 4774   // call indirectly to solve generation ordering problem
 4775   movptr(rax, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
 4776   call(rax);
 4777   // Caller pops the arguments (addr, message) and restores rax, r10.
 4778 }
 4779 
 4780 void MacroAssembler::verify_tlab() {
 4781 #ifdef ASSERT
 4782   if (UseTLAB &amp;&amp; VerifyOops) {
 4783     Label next, ok;
 4784     Register t1 = rsi;
 4785     Register thread_reg = NOT_LP64(rbx) LP64_ONLY(r15_thread);
 4786 
 4787     push(t1);
 4788     NOT_LP64(push(thread_reg));
 4789     NOT_LP64(get_thread(thread_reg));
 4790 
 4791     movptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_top_offset())));
 4792     cmpptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_start_offset())));
 4793     jcc(Assembler::aboveEqual, next);
 4794     STOP(&quot;assert(top &gt;= start)&quot;);
 4795     should_not_reach_here();
 4796 
 4797     bind(next);
 4798     movptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_end_offset())));
 4799     cmpptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_top_offset())));
 4800     jcc(Assembler::aboveEqual, ok);
 4801     STOP(&quot;assert(top &lt;= end)&quot;);
 4802     should_not_reach_here();
 4803 
 4804     bind(ok);
 4805     NOT_LP64(pop(thread_reg));
 4806     pop(t1);
 4807   }
 4808 #endif
 4809 }
 4810 
 4811 class ControlWord {
 4812  public:
 4813   int32_t _value;
 4814 
 4815   int  rounding_control() const        { return  (_value &gt;&gt; 10) &amp; 3      ; }
 4816   int  precision_control() const       { return  (_value &gt;&gt;  8) &amp; 3      ; }
 4817   bool precision() const               { return ((_value &gt;&gt;  5) &amp; 1) != 0; }
 4818   bool underflow() const               { return ((_value &gt;&gt;  4) &amp; 1) != 0; }
 4819   bool overflow() const                { return ((_value &gt;&gt;  3) &amp; 1) != 0; }
 4820   bool zero_divide() const             { return ((_value &gt;&gt;  2) &amp; 1) != 0; }
 4821   bool denormalized() const            { return ((_value &gt;&gt;  1) &amp; 1) != 0; }
 4822   bool invalid() const                 { return ((_value &gt;&gt;  0) &amp; 1) != 0; }
 4823 
 4824   void print() const {
 4825     // rounding control
 4826     const char* rc;
 4827     switch (rounding_control()) {
 4828       case 0: rc = &quot;round near&quot;; break;
 4829       case 1: rc = &quot;round down&quot;; break;
 4830       case 2: rc = &quot;round up  &quot;; break;
 4831       case 3: rc = &quot;chop      &quot;; break;
 4832     };
 4833     // precision control
 4834     const char* pc;
 4835     switch (precision_control()) {
 4836       case 0: pc = &quot;24 bits &quot;; break;
 4837       case 1: pc = &quot;reserved&quot;; break;
 4838       case 2: pc = &quot;53 bits &quot;; break;
 4839       case 3: pc = &quot;64 bits &quot;; break;
 4840     };
 4841     // flags
 4842     char f[9];
 4843     f[0] = &#39; &#39;;
 4844     f[1] = &#39; &#39;;
 4845     f[2] = (precision   ()) ? &#39;P&#39; : &#39;p&#39;;
 4846     f[3] = (underflow   ()) ? &#39;U&#39; : &#39;u&#39;;
 4847     f[4] = (overflow    ()) ? &#39;O&#39; : &#39;o&#39;;
 4848     f[5] = (zero_divide ()) ? &#39;Z&#39; : &#39;z&#39;;
 4849     f[6] = (denormalized()) ? &#39;D&#39; : &#39;d&#39;;
 4850     f[7] = (invalid     ()) ? &#39;I&#39; : &#39;i&#39;;
 4851     f[8] = &#39;\x0&#39;;
 4852     // output
 4853     printf(&quot;%04x  masks = %s, %s, %s&quot;, _value &amp; 0xFFFF, f, rc, pc);
 4854   }
 4855 
 4856 };
 4857 
 4858 class StatusWord {
 4859  public:
 4860   int32_t _value;
 4861 
 4862   bool busy() const                    { return ((_value &gt;&gt; 15) &amp; 1) != 0; }
 4863   bool C3() const                      { return ((_value &gt;&gt; 14) &amp; 1) != 0; }
 4864   bool C2() const                      { return ((_value &gt;&gt; 10) &amp; 1) != 0; }
 4865   bool C1() const                      { return ((_value &gt;&gt;  9) &amp; 1) != 0; }
 4866   bool C0() const                      { return ((_value &gt;&gt;  8) &amp; 1) != 0; }
 4867   int  top() const                     { return  (_value &gt;&gt; 11) &amp; 7      ; }
 4868   bool error_status() const            { return ((_value &gt;&gt;  7) &amp; 1) != 0; }
 4869   bool stack_fault() const             { return ((_value &gt;&gt;  6) &amp; 1) != 0; }
 4870   bool precision() const               { return ((_value &gt;&gt;  5) &amp; 1) != 0; }
 4871   bool underflow() const               { return ((_value &gt;&gt;  4) &amp; 1) != 0; }
 4872   bool overflow() const                { return ((_value &gt;&gt;  3) &amp; 1) != 0; }
 4873   bool zero_divide() const             { return ((_value &gt;&gt;  2) &amp; 1) != 0; }
 4874   bool denormalized() const            { return ((_value &gt;&gt;  1) &amp; 1) != 0; }
 4875   bool invalid() const                 { return ((_value &gt;&gt;  0) &amp; 1) != 0; }
 4876 
 4877   void print() const {
 4878     // condition codes
 4879     char c[5];
 4880     c[0] = (C3()) ? &#39;3&#39; : &#39;-&#39;;
 4881     c[1] = (C2()) ? &#39;2&#39; : &#39;-&#39;;
 4882     c[2] = (C1()) ? &#39;1&#39; : &#39;-&#39;;
 4883     c[3] = (C0()) ? &#39;0&#39; : &#39;-&#39;;
 4884     c[4] = &#39;\x0&#39;;
 4885     // flags
 4886     char f[9];
 4887     f[0] = (error_status()) ? &#39;E&#39; : &#39;-&#39;;
 4888     f[1] = (stack_fault ()) ? &#39;S&#39; : &#39;-&#39;;
 4889     f[2] = (precision   ()) ? &#39;P&#39; : &#39;-&#39;;
 4890     f[3] = (underflow   ()) ? &#39;U&#39; : &#39;-&#39;;
 4891     f[4] = (overflow    ()) ? &#39;O&#39; : &#39;-&#39;;
 4892     f[5] = (zero_divide ()) ? &#39;Z&#39; : &#39;-&#39;;
 4893     f[6] = (denormalized()) ? &#39;D&#39; : &#39;-&#39;;
 4894     f[7] = (invalid     ()) ? &#39;I&#39; : &#39;-&#39;;
 4895     f[8] = &#39;\x0&#39;;
 4896     // output
 4897     printf(&quot;%04x  flags = %s, cc =  %s, top = %d&quot;, _value &amp; 0xFFFF, f, c, top());
 4898   }
 4899 
 4900 };
 4901 
 4902 class TagWord {
 4903  public:
 4904   int32_t _value;
 4905 
 4906   int tag_at(int i) const              { return (_value &gt;&gt; (i*2)) &amp; 3; }
 4907 
 4908   void print() const {
 4909     printf(&quot;%04x&quot;, _value &amp; 0xFFFF);
 4910   }
 4911 
 4912 };
 4913 
 4914 class FPU_Register {
 4915  public:
 4916   int32_t _m0;
 4917   int32_t _m1;
 4918   int16_t _ex;
 4919 
 4920   bool is_indefinite() const           {
 4921     return _ex == -1 &amp;&amp; _m1 == (int32_t)0xC0000000 &amp;&amp; _m0 == 0;
 4922   }
 4923 
 4924   void print() const {
 4925     char  sign = (_ex &lt; 0) ? &#39;-&#39; : &#39;+&#39;;
 4926     const char* kind = (_ex == 0x7FFF || _ex == (int16_t)-1) ? &quot;NaN&quot; : &quot;   &quot;;
 4927     printf(&quot;%c%04hx.%08x%08x  %s&quot;, sign, _ex, _m1, _m0, kind);
 4928   };
 4929 
 4930 };
 4931 
 4932 class FPU_State {
 4933  public:
 4934   enum {
 4935     register_size       = 10,
 4936     number_of_registers =  8,
 4937     register_mask       =  7
 4938   };
 4939 
 4940   ControlWord  _control_word;
 4941   StatusWord   _status_word;
 4942   TagWord      _tag_word;
 4943   int32_t      _error_offset;
 4944   int32_t      _error_selector;
 4945   int32_t      _data_offset;
 4946   int32_t      _data_selector;
 4947   int8_t       _register[register_size * number_of_registers];
 4948 
 4949   int tag_for_st(int i) const          { return _tag_word.tag_at((_status_word.top() + i) &amp; register_mask); }
 4950   FPU_Register* st(int i) const        { return (FPU_Register*)&amp;_register[register_size * i]; }
 4951 
 4952   const char* tag_as_string(int tag) const {
 4953     switch (tag) {
 4954       case 0: return &quot;valid&quot;;
 4955       case 1: return &quot;zero&quot;;
 4956       case 2: return &quot;special&quot;;
 4957       case 3: return &quot;empty&quot;;
 4958     }
 4959     ShouldNotReachHere();
 4960     return NULL;
 4961   }
 4962 
 4963   void print() const {
 4964     // print computation registers
 4965     { int t = _status_word.top();
 4966       for (int i = 0; i &lt; number_of_registers; i++) {
 4967         int j = (i - t) &amp; register_mask;
 4968         printf(&quot;%c r%d = ST%d = &quot;, (j == 0 ? &#39;*&#39; : &#39; &#39;), i, j);
 4969         st(j)-&gt;print();
 4970         printf(&quot; %s\n&quot;, tag_as_string(_tag_word.tag_at(i)));
 4971       }
 4972     }
 4973     printf(&quot;\n&quot;);
 4974     // print control registers
 4975     printf(&quot;ctrl = &quot;); _control_word.print(); printf(&quot;\n&quot;);
 4976     printf(&quot;stat = &quot;); _status_word .print(); printf(&quot;\n&quot;);
 4977     printf(&quot;tags = &quot;); _tag_word    .print(); printf(&quot;\n&quot;);
 4978   }
 4979 
 4980 };
 4981 
 4982 class Flag_Register {
 4983  public:
 4984   int32_t _value;
 4985 
 4986   bool overflow() const                { return ((_value &gt;&gt; 11) &amp; 1) != 0; }
 4987   bool direction() const               { return ((_value &gt;&gt; 10) &amp; 1) != 0; }
 4988   bool sign() const                    { return ((_value &gt;&gt;  7) &amp; 1) != 0; }
 4989   bool zero() const                    { return ((_value &gt;&gt;  6) &amp; 1) != 0; }
 4990   bool auxiliary_carry() const         { return ((_value &gt;&gt;  4) &amp; 1) != 0; }
 4991   bool parity() const                  { return ((_value &gt;&gt;  2) &amp; 1) != 0; }
 4992   bool carry() const                   { return ((_value &gt;&gt;  0) &amp; 1) != 0; }
 4993 
 4994   void print() const {
 4995     // flags
 4996     char f[8];
 4997     f[0] = (overflow       ()) ? &#39;O&#39; : &#39;-&#39;;
 4998     f[1] = (direction      ()) ? &#39;D&#39; : &#39;-&#39;;
 4999     f[2] = (sign           ()) ? &#39;S&#39; : &#39;-&#39;;
 5000     f[3] = (zero           ()) ? &#39;Z&#39; : &#39;-&#39;;
 5001     f[4] = (auxiliary_carry()) ? &#39;A&#39; : &#39;-&#39;;
 5002     f[5] = (parity         ()) ? &#39;P&#39; : &#39;-&#39;;
 5003     f[6] = (carry          ()) ? &#39;C&#39; : &#39;-&#39;;
 5004     f[7] = &#39;\x0&#39;;
 5005     // output
 5006     printf(&quot;%08x  flags = %s&quot;, _value, f);
 5007   }
 5008 
 5009 };
 5010 
 5011 class IU_Register {
 5012  public:
 5013   int32_t _value;
 5014 
 5015   void print() const {
 5016     printf(&quot;%08x  %11d&quot;, _value, _value);
 5017   }
 5018 
 5019 };
 5020 
 5021 class IU_State {
 5022  public:
 5023   Flag_Register _eflags;
 5024   IU_Register   _rdi;
 5025   IU_Register   _rsi;
 5026   IU_Register   _rbp;
 5027   IU_Register   _rsp;
 5028   IU_Register   _rbx;
 5029   IU_Register   _rdx;
 5030   IU_Register   _rcx;
 5031   IU_Register   _rax;
 5032 
 5033   void print() const {
 5034     // computation registers
 5035     printf(&quot;rax,  = &quot;); _rax.print(); printf(&quot;\n&quot;);
 5036     printf(&quot;rbx,  = &quot;); _rbx.print(); printf(&quot;\n&quot;);
 5037     printf(&quot;rcx  = &quot;); _rcx.print(); printf(&quot;\n&quot;);
 5038     printf(&quot;rdx  = &quot;); _rdx.print(); printf(&quot;\n&quot;);
 5039     printf(&quot;rdi  = &quot;); _rdi.print(); printf(&quot;\n&quot;);
 5040     printf(&quot;rsi  = &quot;); _rsi.print(); printf(&quot;\n&quot;);
 5041     printf(&quot;rbp,  = &quot;); _rbp.print(); printf(&quot;\n&quot;);
 5042     printf(&quot;rsp  = &quot;); _rsp.print(); printf(&quot;\n&quot;);
 5043     printf(&quot;\n&quot;);
 5044     // control registers
 5045     printf(&quot;flgs = &quot;); _eflags.print(); printf(&quot;\n&quot;);
 5046   }
 5047 };
 5048 
 5049 
 5050 class CPU_State {
 5051  public:
 5052   FPU_State _fpu_state;
 5053   IU_State  _iu_state;
 5054 
 5055   void print() const {
 5056     printf(&quot;--------------------------------------------------\n&quot;);
 5057     _iu_state .print();
 5058     printf(&quot;\n&quot;);
 5059     _fpu_state.print();
 5060     printf(&quot;--------------------------------------------------\n&quot;);
 5061   }
 5062 
 5063 };
 5064 
 5065 
 5066 static void _print_CPU_state(CPU_State* state) {
 5067   state-&gt;print();
 5068 };
 5069 
 5070 
 5071 void MacroAssembler::print_CPU_state() {
 5072   push_CPU_state();
 5073   push(rsp);                // pass CPU state
 5074   call(RuntimeAddress(CAST_FROM_FN_PTR(address, _print_CPU_state)));
 5075   addptr(rsp, wordSize);       // discard argument
 5076   pop_CPU_state();
 5077 }
 5078 
 5079 
 5080 #ifndef _LP64
 5081 static bool _verify_FPU(int stack_depth, char* s, CPU_State* state) {
 5082   static int counter = 0;
 5083   FPU_State* fs = &amp;state-&gt;_fpu_state;
 5084   counter++;
 5085   // For leaf calls, only verify that the top few elements remain empty.
 5086   // We only need 1 empty at the top for C2 code.
 5087   if( stack_depth &lt; 0 ) {
 5088     if( fs-&gt;tag_for_st(7) != 3 ) {
 5089       printf(&quot;FPR7 not empty\n&quot;);
 5090       state-&gt;print();
 5091       assert(false, &quot;error&quot;);
 5092       return false;
 5093     }
 5094     return true;                // All other stack states do not matter
 5095   }
 5096 
 5097   assert((fs-&gt;_control_word._value &amp; 0xffff) == StubRoutines::_fpu_cntrl_wrd_std,
 5098          &quot;bad FPU control word&quot;);
 5099 
 5100   // compute stack depth
 5101   int i = 0;
 5102   while (i &lt; FPU_State::number_of_registers &amp;&amp; fs-&gt;tag_for_st(i)  &lt; 3) i++;
 5103   int d = i;
 5104   while (i &lt; FPU_State::number_of_registers &amp;&amp; fs-&gt;tag_for_st(i) == 3) i++;
 5105   // verify findings
 5106   if (i != FPU_State::number_of_registers) {
 5107     // stack not contiguous
 5108     printf(&quot;%s: stack not contiguous at ST%d\n&quot;, s, i);
 5109     state-&gt;print();
 5110     assert(false, &quot;error&quot;);
 5111     return false;
 5112   }
 5113   // check if computed stack depth corresponds to expected stack depth
 5114   if (stack_depth &lt; 0) {
 5115     // expected stack depth is -stack_depth or less
 5116     if (d &gt; -stack_depth) {
 5117       // too many elements on the stack
 5118       printf(&quot;%s: &lt;= %d stack elements expected but found %d\n&quot;, s, -stack_depth, d);
 5119       state-&gt;print();
 5120       assert(false, &quot;error&quot;);
 5121       return false;
 5122     }
 5123   } else {
 5124     // expected stack depth is stack_depth
 5125     if (d != stack_depth) {
 5126       // wrong stack depth
 5127       printf(&quot;%s: %d stack elements expected but found %d\n&quot;, s, stack_depth, d);
 5128       state-&gt;print();
 5129       assert(false, &quot;error&quot;);
 5130       return false;
 5131     }
 5132   }
 5133   // everything is cool
 5134   return true;
 5135 }
 5136 
 5137 void MacroAssembler::verify_FPU(int stack_depth, const char* s) {
 5138   if (!VerifyFPU) return;
 5139   push_CPU_state();
 5140   push(rsp);                // pass CPU state
 5141   ExternalAddress msg((address) s);
 5142   // pass message string s
 5143   pushptr(msg.addr());
 5144   push(stack_depth);        // pass stack depth
 5145   call(RuntimeAddress(CAST_FROM_FN_PTR(address, _verify_FPU)));
 5146   addptr(rsp, 3 * wordSize);   // discard arguments
 5147   // check for error
 5148   { Label L;
 5149     testl(rax, rax);
 5150     jcc(Assembler::notZero, L);
 5151     int3();                  // break if error condition
 5152     bind(L);
 5153   }
 5154   pop_CPU_state();
 5155 }
 5156 #endif // _LP64
 5157 
 5158 void MacroAssembler::restore_cpu_control_state_after_jni() {
 5159   // Either restore the MXCSR register after returning from the JNI Call
 5160   // or verify that it wasn&#39;t changed (with -Xcheck:jni flag).
 5161   if (VM_Version::supports_sse()) {
 5162     if (RestoreMXCSROnJNICalls) {
 5163       ldmxcsr(ExternalAddress(StubRoutines::addr_mxcsr_std()));
 5164     } else if (CheckJNICalls) {
 5165       call(RuntimeAddress(StubRoutines::x86::verify_mxcsr_entry()));
 5166     }
 5167   }
 5168   // Clear upper bits of YMM registers to avoid SSE &lt;-&gt; AVX transition penalty.
 5169   vzeroupper();
 5170   // Reset k1 to 0xffff.
 5171 
 5172 #ifdef COMPILER2
 5173   if (PostLoopMultiversioning &amp;&amp; VM_Version::supports_evex()) {
 5174     push(rcx);
 5175     movl(rcx, 0xffff);
 5176     kmovwl(k1, rcx);
 5177     pop(rcx);
 5178   }
 5179 #endif // COMPILER2
 5180 
 5181 #ifndef _LP64
 5182   // Either restore the x87 floating pointer control word after returning
 5183   // from the JNI call or verify that it wasn&#39;t changed.
 5184   if (CheckJNICalls) {
 5185     call(RuntimeAddress(StubRoutines::x86::verify_fpu_cntrl_wrd_entry()));
 5186   }
 5187 #endif // _LP64
 5188 }
 5189 
 5190 // ((OopHandle)result).resolve();
 5191 void MacroAssembler::resolve_oop_handle(Register result, Register tmp) {
 5192   assert_different_registers(result, tmp);
 5193 
 5194   // Only 64 bit platforms support GCs that require a tmp register
 5195   // Only IN_HEAP loads require a thread_tmp register
 5196   // OopHandle::resolve is an indirection like jobject.
 5197   access_load_at(T_OBJECT, IN_NATIVE,
 5198                  result, Address(result, 0), tmp, /*tmp_thread*/noreg);
 5199 }
 5200 
 5201 // ((WeakHandle)result).resolve();
 5202 void MacroAssembler::resolve_weak_handle(Register rresult, Register rtmp) {
 5203   assert_different_registers(rresult, rtmp);
 5204   Label resolved;
 5205 
 5206   // A null weak handle resolves to null.
 5207   cmpptr(rresult, 0);
 5208   jcc(Assembler::equal, resolved);
 5209 
 5210   // Only 64 bit platforms support GCs that require a tmp register
 5211   // Only IN_HEAP loads require a thread_tmp register
 5212   // WeakHandle::resolve is an indirection like jweak.
 5213   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
 5214                  rresult, Address(rresult, 0), rtmp, /*tmp_thread*/noreg);
 5215   bind(resolved);
 5216 }
 5217 
 5218 void MacroAssembler::load_mirror(Register mirror, Register method, Register tmp) {
 5219   // get mirror
 5220   const int mirror_offset = in_bytes(Klass::java_mirror_offset());
 5221   load_method_holder(mirror, method);
 5222   movptr(mirror, Address(mirror, mirror_offset));
 5223   resolve_oop_handle(mirror, tmp);
 5224 }
 5225 
 5226 void MacroAssembler::load_method_holder_cld(Register rresult, Register rmethod) {
 5227   load_method_holder(rresult, rmethod);
 5228   movptr(rresult, Address(rresult, InstanceKlass::class_loader_data_offset()));
 5229 }
 5230 
 5231 void MacroAssembler::load_method_holder(Register holder, Register method) {
 5232   movptr(holder, Address(method, Method::const_offset()));                      // ConstMethod*
 5233   movptr(holder, Address(holder, ConstMethod::constants_offset()));             // ConstantPool*
 5234   movptr(holder, Address(holder, ConstantPool::pool_holder_offset_in_bytes())); // InstanceKlass*
 5235 }
 5236 
 5237 void MacroAssembler::load_klass(Register dst, Register src) {
 5238 #ifdef _LP64
 5239   if (UseCompressedClassPointers) {
 5240     movl(dst, Address(src, oopDesc::klass_offset_in_bytes()));
 5241     decode_klass_not_null(dst);
 5242   } else
 5243 #endif
 5244     movptr(dst, Address(src, oopDesc::klass_offset_in_bytes()));
 5245 }
 5246 
 5247 void MacroAssembler::load_prototype_header(Register dst, Register src) {
 5248   load_klass(dst, src);
 5249   movptr(dst, Address(dst, Klass::prototype_header_offset()));
 5250 }
 5251 
 5252 void MacroAssembler::store_klass(Register dst, Register src) {
 5253 #ifdef _LP64
 5254   if (UseCompressedClassPointers) {
 5255     encode_klass_not_null(src);
 5256     movl(Address(dst, oopDesc::klass_offset_in_bytes()), src);
 5257   } else
 5258 #endif
 5259     movptr(Address(dst, oopDesc::klass_offset_in_bytes()), src);
 5260 }
 5261 
 5262 void MacroAssembler::access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
 5263                                     Register tmp1, Register thread_tmp) {
 5264   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 5265   decorators = AccessInternal::decorator_fixup(decorators);
 5266   bool as_raw = (decorators &amp; AS_RAW) != 0;
 5267   if (as_raw) {
 5268     bs-&gt;BarrierSetAssembler::load_at(this, decorators, type, dst, src, tmp1, thread_tmp);
 5269   } else {
 5270     bs-&gt;load_at(this, decorators, type, dst, src, tmp1, thread_tmp);
 5271   }
 5272 }
 5273 
 5274 void MacroAssembler::access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
 5275                                      Register tmp1, Register tmp2) {
 5276   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 5277   decorators = AccessInternal::decorator_fixup(decorators);
 5278   bool as_raw = (decorators &amp; AS_RAW) != 0;
 5279   if (as_raw) {
 5280     bs-&gt;BarrierSetAssembler::store_at(this, decorators, type, dst, src, tmp1, tmp2);
 5281   } else {
 5282     bs-&gt;store_at(this, decorators, type, dst, src, tmp1, tmp2);
 5283   }
 5284 }
 5285 
 5286 void MacroAssembler::resolve(DecoratorSet decorators, Register obj) {
 5287   // Use stronger ACCESS_WRITE|ACCESS_READ by default.
 5288   if ((decorators &amp; (ACCESS_READ | ACCESS_WRITE)) == 0) {
 5289     decorators |= ACCESS_READ | ACCESS_WRITE;
 5290   }
 5291   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 5292   return bs-&gt;resolve(this, decorators, obj);
 5293 }
 5294 
 5295 void MacroAssembler::load_heap_oop(Register dst, Address src, Register tmp1,
 5296                                    Register thread_tmp, DecoratorSet decorators) {
 5297   access_load_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, thread_tmp);
 5298 }
 5299 
 5300 // Doesn&#39;t do verfication, generates fixed size code
 5301 void MacroAssembler::load_heap_oop_not_null(Register dst, Address src, Register tmp1,
 5302                                             Register thread_tmp, DecoratorSet decorators) {
 5303   access_load_at(T_OBJECT, IN_HEAP | IS_NOT_NULL | decorators, dst, src, tmp1, thread_tmp);
 5304 }
 5305 
 5306 void MacroAssembler::store_heap_oop(Address dst, Register src, Register tmp1,
 5307                                     Register tmp2, DecoratorSet decorators) {
 5308   access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, tmp2);
 5309 }
 5310 
 5311 // Used for storing NULLs.
 5312 void MacroAssembler::store_heap_oop_null(Address dst) {
 5313   access_store_at(T_OBJECT, IN_HEAP, dst, noreg, noreg, noreg);
 5314 }
 5315 
 5316 #ifdef _LP64
 5317 void MacroAssembler::store_klass_gap(Register dst, Register src) {
 5318   if (UseCompressedClassPointers) {
 5319     // Store to klass gap in destination
 5320     movl(Address(dst, oopDesc::klass_gap_offset_in_bytes()), src);
 5321   }
 5322 }
 5323 
 5324 #ifdef ASSERT
 5325 void MacroAssembler::verify_heapbase(const char* msg) {
 5326   assert (UseCompressedOops, &quot;should be compressed&quot;);
 5327   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
 5328   if (CheckCompressedOops) {
 5329     Label ok;
 5330     push(rscratch1); // cmpptr trashes rscratch1
 5331     cmpptr(r12_heapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));
 5332     jcc(Assembler::equal, ok);
 5333     STOP(msg);
 5334     bind(ok);
 5335     pop(rscratch1);
 5336   }
 5337 }
 5338 #endif
 5339 
 5340 // Algorithm must match oop.inline.hpp encode_heap_oop.
 5341 void MacroAssembler::encode_heap_oop(Register r) {
 5342 #ifdef ASSERT
 5343   verify_heapbase(&quot;MacroAssembler::encode_heap_oop: heap base corrupted?&quot;);
 5344 #endif
<a name="22" id="anc22"></a><span class="line-modified"> 5345   verify_oop_msg(r, &quot;broken oop in encode_heap_oop&quot;);</span>
 5346   if (CompressedOops::base() == NULL) {
 5347     if (CompressedOops::shift() != 0) {
 5348       assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
 5349       shrq(r, LogMinObjAlignmentInBytes);
 5350     }
 5351     return;
 5352   }
 5353   testq(r, r);
 5354   cmovq(Assembler::equal, r, r12_heapbase);
 5355   subq(r, r12_heapbase);
 5356   shrq(r, LogMinObjAlignmentInBytes);
 5357 }
 5358 
 5359 void MacroAssembler::encode_heap_oop_not_null(Register r) {
 5360 #ifdef ASSERT
 5361   verify_heapbase(&quot;MacroAssembler::encode_heap_oop_not_null: heap base corrupted?&quot;);
 5362   if (CheckCompressedOops) {
 5363     Label ok;
 5364     testq(r, r);
 5365     jcc(Assembler::notEqual, ok);
 5366     STOP(&quot;null oop passed to encode_heap_oop_not_null&quot;);
 5367     bind(ok);
 5368   }
 5369 #endif
<a name="23" id="anc23"></a><span class="line-modified"> 5370   verify_oop_msg(r, &quot;broken oop in encode_heap_oop_not_null&quot;);</span>
 5371   if (CompressedOops::base() != NULL) {
 5372     subq(r, r12_heapbase);
 5373   }
 5374   if (CompressedOops::shift() != 0) {
 5375     assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
 5376     shrq(r, LogMinObjAlignmentInBytes);
 5377   }
 5378 }
 5379 
 5380 void MacroAssembler::encode_heap_oop_not_null(Register dst, Register src) {
 5381 #ifdef ASSERT
 5382   verify_heapbase(&quot;MacroAssembler::encode_heap_oop_not_null2: heap base corrupted?&quot;);
 5383   if (CheckCompressedOops) {
 5384     Label ok;
 5385     testq(src, src);
 5386     jcc(Assembler::notEqual, ok);
 5387     STOP(&quot;null oop passed to encode_heap_oop_not_null2&quot;);
 5388     bind(ok);
 5389   }
 5390 #endif
<a name="24" id="anc24"></a><span class="line-modified"> 5391   verify_oop_msg(src, &quot;broken oop in encode_heap_oop_not_null2&quot;);</span>
 5392   if (dst != src) {
 5393     movq(dst, src);
 5394   }
 5395   if (CompressedOops::base() != NULL) {
 5396     subq(dst, r12_heapbase);
 5397   }
 5398   if (CompressedOops::shift() != 0) {
 5399     assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
 5400     shrq(dst, LogMinObjAlignmentInBytes);
 5401   }
 5402 }
 5403 
 5404 void  MacroAssembler::decode_heap_oop(Register r) {
 5405 #ifdef ASSERT
 5406   verify_heapbase(&quot;MacroAssembler::decode_heap_oop: heap base corrupted?&quot;);
 5407 #endif
 5408   if (CompressedOops::base() == NULL) {
 5409     if (CompressedOops::shift() != 0) {
 5410       assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
 5411       shlq(r, LogMinObjAlignmentInBytes);
 5412     }
 5413   } else {
 5414     Label done;
 5415     shlq(r, LogMinObjAlignmentInBytes);
 5416     jccb(Assembler::equal, done);
 5417     addq(r, r12_heapbase);
 5418     bind(done);
 5419   }
<a name="25" id="anc25"></a><span class="line-modified"> 5420   verify_oop_msg(r, &quot;broken oop in decode_heap_oop&quot;);</span>
 5421 }
 5422 
 5423 void  MacroAssembler::decode_heap_oop_not_null(Register r) {
 5424   // Note: it will change flags
 5425   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
 5426   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
 5427   // Cannot assert, unverified entry point counts instructions (see .ad file)
 5428   // vtableStubs also counts instructions in pd_code_size_limit.
 5429   // Also do not verify_oop as this is called by verify_oop.
 5430   if (CompressedOops::shift() != 0) {
 5431     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
 5432     shlq(r, LogMinObjAlignmentInBytes);
 5433     if (CompressedOops::base() != NULL) {
 5434       addq(r, r12_heapbase);
 5435     }
 5436   } else {
 5437     assert (CompressedOops::base() == NULL, &quot;sanity&quot;);
 5438   }
 5439 }
 5440 
 5441 void  MacroAssembler::decode_heap_oop_not_null(Register dst, Register src) {
 5442   // Note: it will change flags
 5443   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
 5444   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
 5445   // Cannot assert, unverified entry point counts instructions (see .ad file)
 5446   // vtableStubs also counts instructions in pd_code_size_limit.
 5447   // Also do not verify_oop as this is called by verify_oop.
 5448   if (CompressedOops::shift() != 0) {
 5449     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
 5450     if (LogMinObjAlignmentInBytes == Address::times_8) {
 5451       leaq(dst, Address(r12_heapbase, src, Address::times_8, 0));
 5452     } else {
 5453       if (dst != src) {
 5454         movq(dst, src);
 5455       }
 5456       shlq(dst, LogMinObjAlignmentInBytes);
 5457       if (CompressedOops::base() != NULL) {
 5458         addq(dst, r12_heapbase);
 5459       }
 5460     }
 5461   } else {
 5462     assert (CompressedOops::base() == NULL, &quot;sanity&quot;);
 5463     if (dst != src) {
 5464       movq(dst, src);
 5465     }
 5466   }
 5467 }
 5468 
 5469 void MacroAssembler::encode_klass_not_null(Register r) {
 5470   if (CompressedKlassPointers::base() != NULL) {
 5471     // Use r12 as a scratch register in which to temporarily load the narrow_klass_base.
 5472     assert(r != r12_heapbase, &quot;Encoding a klass in r12&quot;);
 5473     mov64(r12_heapbase, (int64_t)CompressedKlassPointers::base());
 5474     subq(r, r12_heapbase);
 5475   }
 5476   if (CompressedKlassPointers::shift() != 0) {
 5477     assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
 5478     shrq(r, LogKlassAlignmentInBytes);
 5479   }
 5480   if (CompressedKlassPointers::base() != NULL) {
 5481     reinit_heapbase();
 5482   }
 5483 }
 5484 
 5485 void MacroAssembler::encode_klass_not_null(Register dst, Register src) {
 5486   if (dst == src) {
 5487     encode_klass_not_null(src);
 5488   } else {
 5489     if (CompressedKlassPointers::base() != NULL) {
 5490       mov64(dst, (int64_t)CompressedKlassPointers::base());
 5491       negq(dst);
 5492       addq(dst, src);
 5493     } else {
 5494       movptr(dst, src);
 5495     }
 5496     if (CompressedKlassPointers::shift() != 0) {
 5497       assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
 5498       shrq(dst, LogKlassAlignmentInBytes);
 5499     }
 5500   }
 5501 }
 5502 
 5503 // Function instr_size_for_decode_klass_not_null() counts the instructions
 5504 // generated by decode_klass_not_null(register r) and reinit_heapbase(),
 5505 // when (Universe::heap() != NULL).  Hence, if the instructions they
 5506 // generate change, then this method needs to be updated.
 5507 int MacroAssembler::instr_size_for_decode_klass_not_null() {
 5508   assert (UseCompressedClassPointers, &quot;only for compressed klass ptrs&quot;);
 5509   if (CompressedKlassPointers::base() != NULL) {
 5510     // mov64 + addq + shlq? + mov64  (for reinit_heapbase()).
 5511     return (CompressedKlassPointers::shift() == 0 ? 20 : 24);
 5512   } else {
 5513     // longest load decode klass function, mov64, leaq
 5514     return 16;
 5515   }
 5516 }
 5517 
 5518 // !!! If the instructions that get generated here change then function
 5519 // instr_size_for_decode_klass_not_null() needs to get updated.
 5520 void  MacroAssembler::decode_klass_not_null(Register r) {
 5521   // Note: it will change flags
 5522   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
 5523   assert(r != r12_heapbase, &quot;Decoding a klass in r12&quot;);
 5524   // Cannot assert, unverified entry point counts instructions (see .ad file)
 5525   // vtableStubs also counts instructions in pd_code_size_limit.
 5526   // Also do not verify_oop as this is called by verify_oop.
 5527   if (CompressedKlassPointers::shift() != 0) {
 5528     assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
 5529     shlq(r, LogKlassAlignmentInBytes);
 5530   }
 5531   // Use r12 as a scratch register in which to temporarily load the narrow_klass_base.
 5532   if (CompressedKlassPointers::base() != NULL) {
 5533     mov64(r12_heapbase, (int64_t)CompressedKlassPointers::base());
 5534     addq(r, r12_heapbase);
 5535     reinit_heapbase();
 5536   }
 5537 }
 5538 
 5539 void  MacroAssembler::decode_klass_not_null(Register dst, Register src) {
 5540   // Note: it will change flags
 5541   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
 5542   if (dst == src) {
 5543     decode_klass_not_null(dst);
 5544   } else {
 5545     // Cannot assert, unverified entry point counts instructions (see .ad file)
 5546     // vtableStubs also counts instructions in pd_code_size_limit.
 5547     // Also do not verify_oop as this is called by verify_oop.
 5548     mov64(dst, (int64_t)CompressedKlassPointers::base());
 5549     if (CompressedKlassPointers::shift() != 0) {
 5550       assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
 5551       assert(LogKlassAlignmentInBytes == Address::times_8, &quot;klass not aligned on 64bits?&quot;);
 5552       leaq(dst, Address(dst, src, Address::times_8, 0));
 5553     } else {
 5554       addq(dst, src);
 5555     }
 5556   }
 5557 }
 5558 
 5559 void  MacroAssembler::set_narrow_oop(Register dst, jobject obj) {
 5560   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
 5561   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
 5562   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
 5563   int oop_index = oop_recorder()-&gt;find_index(obj);
 5564   RelocationHolder rspec = oop_Relocation::spec(oop_index);
 5565   mov_narrow_oop(dst, oop_index, rspec);
 5566 }
 5567 
 5568 void  MacroAssembler::set_narrow_oop(Address dst, jobject obj) {
 5569   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
 5570   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
 5571   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
 5572   int oop_index = oop_recorder()-&gt;find_index(obj);
 5573   RelocationHolder rspec = oop_Relocation::spec(oop_index);
 5574   mov_narrow_oop(dst, oop_index, rspec);
 5575 }
 5576 
 5577 void  MacroAssembler::set_narrow_klass(Register dst, Klass* k) {
 5578   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
 5579   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
 5580   int klass_index = oop_recorder()-&gt;find_index(k);
 5581   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
 5582   mov_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
 5583 }
 5584 
 5585 void  MacroAssembler::set_narrow_klass(Address dst, Klass* k) {
 5586   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
 5587   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
 5588   int klass_index = oop_recorder()-&gt;find_index(k);
 5589   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
 5590   mov_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
 5591 }
 5592 
 5593 void  MacroAssembler::cmp_narrow_oop(Register dst, jobject obj) {
 5594   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
 5595   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
 5596   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
 5597   int oop_index = oop_recorder()-&gt;find_index(obj);
 5598   RelocationHolder rspec = oop_Relocation::spec(oop_index);
 5599   Assembler::cmp_narrow_oop(dst, oop_index, rspec);
 5600 }
 5601 
 5602 void  MacroAssembler::cmp_narrow_oop(Address dst, jobject obj) {
 5603   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
 5604   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
 5605   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
 5606   int oop_index = oop_recorder()-&gt;find_index(obj);
 5607   RelocationHolder rspec = oop_Relocation::spec(oop_index);
 5608   Assembler::cmp_narrow_oop(dst, oop_index, rspec);
 5609 }
 5610 
 5611 void  MacroAssembler::cmp_narrow_klass(Register dst, Klass* k) {
 5612   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
 5613   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
 5614   int klass_index = oop_recorder()-&gt;find_index(k);
 5615   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
 5616   Assembler::cmp_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
 5617 }
 5618 
 5619 void  MacroAssembler::cmp_narrow_klass(Address dst, Klass* k) {
 5620   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
 5621   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
 5622   int klass_index = oop_recorder()-&gt;find_index(k);
 5623   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
 5624   Assembler::cmp_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
 5625 }
 5626 
 5627 void MacroAssembler::reinit_heapbase() {
 5628   if (UseCompressedOops || UseCompressedClassPointers) {
 5629     if (Universe::heap() != NULL) {
 5630       if (CompressedOops::base() == NULL) {
 5631         MacroAssembler::xorptr(r12_heapbase, r12_heapbase);
 5632       } else {
 5633         mov64(r12_heapbase, (int64_t)CompressedOops::ptrs_base());
 5634       }
 5635     } else {
 5636       movptr(r12_heapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));
 5637     }
 5638   }
 5639 }
 5640 
 5641 #endif // _LP64
 5642 
 5643 // C2 compiled method&#39;s prolog code.
 5644 void MacroAssembler::verified_entry(int framesize, int stack_bang_size, bool fp_mode_24b, bool is_stub) {
 5645 
 5646   // WARNING: Initial instruction MUST be 5 bytes or longer so that
 5647   // NativeJump::patch_verified_entry will be able to patch out the entry
 5648   // code safely. The push to verify stack depth is ok at 5 bytes,
 5649   // the frame allocation can be either 3 or 6 bytes. So if we don&#39;t do
 5650   // stack bang then we must use the 6 byte frame allocation even if
 5651   // we have no frame. :-(
 5652   assert(stack_bang_size &gt;= framesize || stack_bang_size &lt;= 0, &quot;stack bang size incorrect&quot;);
 5653 
 5654   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
 5655   // Remove word for return addr
 5656   framesize -= wordSize;
 5657   stack_bang_size -= wordSize;
 5658 
 5659   // Calls to C2R adapters often do not accept exceptional returns.
 5660   // We require that their callers must bang for them.  But be careful, because
 5661   // some VM calls (such as call site linkage) can use several kilobytes of
 5662   // stack.  But the stack safety zone should account for that.
 5663   // See bugs 4446381, 4468289, 4497237.
 5664   if (stack_bang_size &gt; 0) {
 5665     generate_stack_overflow_check(stack_bang_size);
 5666 
 5667     // We always push rbp, so that on return to interpreter rbp, will be
 5668     // restored correctly and we can correct the stack.
 5669     push(rbp);
 5670     // Save caller&#39;s stack pointer into RBP if the frame pointer is preserved.
 5671     if (PreserveFramePointer) {
 5672       mov(rbp, rsp);
 5673     }
 5674     // Remove word for ebp
 5675     framesize -= wordSize;
 5676 
 5677     // Create frame
 5678     if (framesize) {
 5679       subptr(rsp, framesize);
 5680     }
 5681   } else {
 5682     // Create frame (force generation of a 4 byte immediate value)
 5683     subptr_imm32(rsp, framesize);
 5684 
 5685     // Save RBP register now.
 5686     framesize -= wordSize;
 5687     movptr(Address(rsp, framesize), rbp);
 5688     // Save caller&#39;s stack pointer into RBP if the frame pointer is preserved.
 5689     if (PreserveFramePointer) {
 5690       movptr(rbp, rsp);
 5691       if (framesize &gt; 0) {
 5692         addptr(rbp, framesize);
 5693       }
 5694     }
 5695   }
 5696 
 5697   if (VerifyStackAtCalls) { // Majik cookie to verify stack depth
 5698     framesize -= wordSize;
 5699     movptr(Address(rsp, framesize), (int32_t)0xbadb100d);
 5700   }
 5701 
 5702 #ifndef _LP64
 5703   // If method sets FPU control word do it now
 5704   if (fp_mode_24b) {
 5705     fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));
 5706   }
 5707   if (UseSSE &gt;= 2 &amp;&amp; VerifyFPU) {
 5708     verify_FPU(0, &quot;FPU stack must be clean on entry&quot;);
 5709   }
 5710 #endif
 5711 
 5712 #ifdef ASSERT
 5713   if (VerifyStackAtCalls) {
 5714     Label L;
 5715     push(rax);
 5716     mov(rax, rsp);
 5717     andptr(rax, StackAlignmentInBytes-1);
 5718     cmpptr(rax, StackAlignmentInBytes-wordSize);
 5719     pop(rax);
 5720     jcc(Assembler::equal, L);
 5721     STOP(&quot;Stack is not properly aligned!&quot;);
 5722     bind(L);
 5723   }
 5724 #endif
 5725 
 5726   if (!is_stub) {
 5727     BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 5728     bs-&gt;nmethod_entry_barrier(this);
 5729   }
 5730 }
 5731 
 5732 // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39; using XMM/YMM registers
 5733 void MacroAssembler::xmm_clear_mem(Register base, Register cnt, XMMRegister xtmp) {
 5734   // cnt - number of qwords (8-byte words).
 5735   // base - start address, qword aligned.
 5736   Label L_zero_64_bytes, L_loop, L_sloop, L_tail, L_end;
 5737   if (UseAVX &gt;= 2) {
 5738     vpxor(xtmp, xtmp, xtmp, AVX_256bit);
 5739   } else {
 5740     pxor(xtmp, xtmp);
 5741   }
 5742   jmp(L_zero_64_bytes);
 5743 
 5744   BIND(L_loop);
 5745   if (UseAVX &gt;= 2) {
 5746     vmovdqu(Address(base,  0), xtmp);
 5747     vmovdqu(Address(base, 32), xtmp);
 5748   } else {
 5749     movdqu(Address(base,  0), xtmp);
 5750     movdqu(Address(base, 16), xtmp);
 5751     movdqu(Address(base, 32), xtmp);
 5752     movdqu(Address(base, 48), xtmp);
 5753   }
 5754   addptr(base, 64);
 5755 
 5756   BIND(L_zero_64_bytes);
 5757   subptr(cnt, 8);
 5758   jccb(Assembler::greaterEqual, L_loop);
 5759   addptr(cnt, 4);
 5760   jccb(Assembler::less, L_tail);
 5761   // Copy trailing 32 bytes
 5762   if (UseAVX &gt;= 2) {
 5763     vmovdqu(Address(base, 0), xtmp);
 5764   } else {
 5765     movdqu(Address(base,  0), xtmp);
 5766     movdqu(Address(base, 16), xtmp);
 5767   }
 5768   addptr(base, 32);
 5769   subptr(cnt, 4);
 5770 
 5771   BIND(L_tail);
 5772   addptr(cnt, 4);
 5773   jccb(Assembler::lessEqual, L_end);
 5774   decrement(cnt);
 5775 
 5776   BIND(L_sloop);
 5777   movq(Address(base, 0), xtmp);
 5778   addptr(base, 8);
 5779   decrement(cnt);
 5780   jccb(Assembler::greaterEqual, L_sloop);
 5781   BIND(L_end);
 5782 }
 5783 
 5784 void MacroAssembler::clear_mem(Register base, Register cnt, Register tmp, XMMRegister xtmp, bool is_large) {
 5785   // cnt - number of qwords (8-byte words).
 5786   // base - start address, qword aligned.
 5787   // is_large - if optimizers know cnt is larger than InitArrayShortSize
 5788   assert(base==rdi, &quot;base register must be edi for rep stos&quot;);
 5789   assert(tmp==rax,   &quot;tmp register must be eax for rep stos&quot;);
 5790   assert(cnt==rcx,   &quot;cnt register must be ecx for rep stos&quot;);
 5791   assert(InitArrayShortSize % BytesPerLong == 0,
 5792     &quot;InitArrayShortSize should be the multiple of BytesPerLong&quot;);
 5793 
 5794   Label DONE;
 5795 
 5796   if (!is_large || !UseXMMForObjInit) {
 5797     xorptr(tmp, tmp);
 5798   }
 5799 
 5800   if (!is_large) {
 5801     Label LOOP, LONG;
 5802     cmpptr(cnt, InitArrayShortSize/BytesPerLong);
 5803     jccb(Assembler::greater, LONG);
 5804 
 5805     NOT_LP64(shlptr(cnt, 1);) // convert to number of 32-bit words for 32-bit VM
 5806 
 5807     decrement(cnt);
 5808     jccb(Assembler::negative, DONE); // Zero length
 5809 
 5810     // Use individual pointer-sized stores for small counts:
 5811     BIND(LOOP);
 5812     movptr(Address(base, cnt, Address::times_ptr), tmp);
 5813     decrement(cnt);
 5814     jccb(Assembler::greaterEqual, LOOP);
 5815     jmpb(DONE);
 5816 
 5817     BIND(LONG);
 5818   }
 5819 
 5820   // Use longer rep-prefixed ops for non-small counts:
 5821   if (UseFastStosb) {
 5822     shlptr(cnt, 3); // convert to number of bytes
 5823     rep_stosb();
 5824   } else if (UseXMMForObjInit) {
 5825     movptr(tmp, base);
 5826     xmm_clear_mem(tmp, cnt, xtmp);
 5827   } else {
 5828     NOT_LP64(shlptr(cnt, 1);) // convert to number of 32-bit words for 32-bit VM
 5829     rep_stos();
 5830   }
 5831 
 5832   BIND(DONE);
 5833 }
 5834 
 5835 #ifdef COMPILER2
 5836 
 5837 // IndexOf for constant substrings with size &gt;= 8 chars
 5838 // which don&#39;t need to be loaded through stack.
 5839 void MacroAssembler::string_indexofC8(Register str1, Register str2,
 5840                                       Register cnt1, Register cnt2,
 5841                                       int int_cnt2,  Register result,
 5842                                       XMMRegister vec, Register tmp,
 5843                                       int ae) {
 5844   ShortBranchVerifier sbv(this);
 5845   assert(UseSSE42Intrinsics, &quot;SSE4.2 intrinsics are required&quot;);
 5846   assert(ae != StrIntrinsicNode::LU, &quot;Invalid encoding&quot;);
 5847 
 5848   // This method uses the pcmpestri instruction with bound registers
 5849   //   inputs:
 5850   //     xmm - substring
 5851   //     rax - substring length (elements count)
 5852   //     mem - scanned string
 5853   //     rdx - string length (elements count)
 5854   //     0xd - mode: 1100 (substring search) + 01 (unsigned shorts)
 5855   //     0xc - mode: 1100 (substring search) + 00 (unsigned bytes)
 5856   //   outputs:
 5857   //     rcx - matched index in string
 5858   assert(cnt1 == rdx &amp;&amp; cnt2 == rax &amp;&amp; tmp == rcx, &quot;pcmpestri&quot;);
 5859   int mode   = (ae == StrIntrinsicNode::LL) ? 0x0c : 0x0d; // bytes or shorts
 5860   int stride = (ae == StrIntrinsicNode::LL) ? 16 : 8; //UU, UL -&gt; 8
 5861   Address::ScaleFactor scale1 = (ae == StrIntrinsicNode::LL) ? Address::times_1 : Address::times_2;
 5862   Address::ScaleFactor scale2 = (ae == StrIntrinsicNode::UL) ? Address::times_1 : scale1;
 5863 
 5864   Label RELOAD_SUBSTR, SCAN_TO_SUBSTR, SCAN_SUBSTR,
 5865         RET_FOUND, RET_NOT_FOUND, EXIT, FOUND_SUBSTR,
 5866         MATCH_SUBSTR_HEAD, RELOAD_STR, FOUND_CANDIDATE;
 5867 
 5868   // Note, inline_string_indexOf() generates checks:
 5869   // if (substr.count &gt; string.count) return -1;
 5870   // if (substr.count == 0) return 0;
 5871   assert(int_cnt2 &gt;= stride, &quot;this code is used only for cnt2 &gt;= 8 chars&quot;);
 5872 
 5873   // Load substring.
 5874   if (ae == StrIntrinsicNode::UL) {
 5875     pmovzxbw(vec, Address(str2, 0));
 5876   } else {
 5877     movdqu(vec, Address(str2, 0));
 5878   }
 5879   movl(cnt2, int_cnt2);
 5880   movptr(result, str1); // string addr
 5881 
 5882   if (int_cnt2 &gt; stride) {
 5883     jmpb(SCAN_TO_SUBSTR);
 5884 
 5885     // Reload substr for rescan, this code
 5886     // is executed only for large substrings (&gt; 8 chars)
 5887     bind(RELOAD_SUBSTR);
 5888     if (ae == StrIntrinsicNode::UL) {
 5889       pmovzxbw(vec, Address(str2, 0));
 5890     } else {
 5891       movdqu(vec, Address(str2, 0));
 5892     }
 5893     negptr(cnt2); // Jumped here with negative cnt2, convert to positive
 5894 
 5895     bind(RELOAD_STR);
 5896     // We came here after the beginning of the substring was
 5897     // matched but the rest of it was not so we need to search
 5898     // again. Start from the next element after the previous match.
 5899 
 5900     // cnt2 is number of substring reminding elements and
 5901     // cnt1 is number of string reminding elements when cmp failed.
 5902     // Restored cnt1 = cnt1 - cnt2 + int_cnt2
 5903     subl(cnt1, cnt2);
 5904     addl(cnt1, int_cnt2);
 5905     movl(cnt2, int_cnt2); // Now restore cnt2
 5906 
 5907     decrementl(cnt1);     // Shift to next element
 5908     cmpl(cnt1, cnt2);
 5909     jcc(Assembler::negative, RET_NOT_FOUND);  // Left less then substring
 5910 
 5911     addptr(result, (1&lt;&lt;scale1));
 5912 
 5913   } // (int_cnt2 &gt; 8)
 5914 
 5915   // Scan string for start of substr in 16-byte vectors
 5916   bind(SCAN_TO_SUBSTR);
 5917   pcmpestri(vec, Address(result, 0), mode);
 5918   jccb(Assembler::below, FOUND_CANDIDATE);   // CF == 1
 5919   subl(cnt1, stride);
 5920   jccb(Assembler::lessEqual, RET_NOT_FOUND); // Scanned full string
 5921   cmpl(cnt1, cnt2);
 5922   jccb(Assembler::negative, RET_NOT_FOUND);  // Left less then substring
 5923   addptr(result, 16);
 5924   jmpb(SCAN_TO_SUBSTR);
 5925 
 5926   // Found a potential substr
 5927   bind(FOUND_CANDIDATE);
 5928   // Matched whole vector if first element matched (tmp(rcx) == 0).
 5929   if (int_cnt2 == stride) {
 5930     jccb(Assembler::overflow, RET_FOUND);    // OF == 1
 5931   } else { // int_cnt2 &gt; 8
 5932     jccb(Assembler::overflow, FOUND_SUBSTR);
 5933   }
 5934   // After pcmpestri tmp(rcx) contains matched element index
 5935   // Compute start addr of substr
 5936   lea(result, Address(result, tmp, scale1));
 5937 
 5938   // Make sure string is still long enough
 5939   subl(cnt1, tmp);
 5940   cmpl(cnt1, cnt2);
 5941   if (int_cnt2 == stride) {
 5942     jccb(Assembler::greaterEqual, SCAN_TO_SUBSTR);
 5943   } else { // int_cnt2 &gt; 8
 5944     jccb(Assembler::greaterEqual, MATCH_SUBSTR_HEAD);
 5945   }
 5946   // Left less then substring.
 5947 
 5948   bind(RET_NOT_FOUND);
 5949   movl(result, -1);
 5950   jmp(EXIT);
 5951 
 5952   if (int_cnt2 &gt; stride) {
 5953     // This code is optimized for the case when whole substring
 5954     // is matched if its head is matched.
 5955     bind(MATCH_SUBSTR_HEAD);
 5956     pcmpestri(vec, Address(result, 0), mode);
 5957     // Reload only string if does not match
 5958     jcc(Assembler::noOverflow, RELOAD_STR); // OF == 0
 5959 
 5960     Label CONT_SCAN_SUBSTR;
 5961     // Compare the rest of substring (&gt; 8 chars).
 5962     bind(FOUND_SUBSTR);
 5963     // First 8 chars are already matched.
 5964     negptr(cnt2);
 5965     addptr(cnt2, stride);
 5966 
 5967     bind(SCAN_SUBSTR);
 5968     subl(cnt1, stride);
 5969     cmpl(cnt2, -stride); // Do not read beyond substring
 5970     jccb(Assembler::lessEqual, CONT_SCAN_SUBSTR);
 5971     // Back-up strings to avoid reading beyond substring:
 5972     // cnt1 = cnt1 - cnt2 + 8
 5973     addl(cnt1, cnt2); // cnt2 is negative
 5974     addl(cnt1, stride);
 5975     movl(cnt2, stride); negptr(cnt2);
 5976     bind(CONT_SCAN_SUBSTR);
 5977     if (int_cnt2 &lt; (int)G) {
 5978       int tail_off1 = int_cnt2&lt;&lt;scale1;
 5979       int tail_off2 = int_cnt2&lt;&lt;scale2;
 5980       if (ae == StrIntrinsicNode::UL) {
 5981         pmovzxbw(vec, Address(str2, cnt2, scale2, tail_off2));
 5982       } else {
 5983         movdqu(vec, Address(str2, cnt2, scale2, tail_off2));
 5984       }
 5985       pcmpestri(vec, Address(result, cnt2, scale1, tail_off1), mode);
 5986     } else {
 5987       // calculate index in register to avoid integer overflow (int_cnt2*2)
 5988       movl(tmp, int_cnt2);
 5989       addptr(tmp, cnt2);
 5990       if (ae == StrIntrinsicNode::UL) {
 5991         pmovzxbw(vec, Address(str2, tmp, scale2, 0));
 5992       } else {
 5993         movdqu(vec, Address(str2, tmp, scale2, 0));
 5994       }
 5995       pcmpestri(vec, Address(result, tmp, scale1, 0), mode);
 5996     }
 5997     // Need to reload strings pointers if not matched whole vector
 5998     jcc(Assembler::noOverflow, RELOAD_SUBSTR); // OF == 0
 5999     addptr(cnt2, stride);
 6000     jcc(Assembler::negative, SCAN_SUBSTR);
 6001     // Fall through if found full substring
 6002 
 6003   } // (int_cnt2 &gt; 8)
 6004 
 6005   bind(RET_FOUND);
 6006   // Found result if we matched full small substring.
 6007   // Compute substr offset
 6008   subptr(result, str1);
 6009   if (ae == StrIntrinsicNode::UU || ae == StrIntrinsicNode::UL) {
 6010     shrl(result, 1); // index
 6011   }
 6012   bind(EXIT);
 6013 
 6014 } // string_indexofC8
 6015 
 6016 // Small strings are loaded through stack if they cross page boundary.
 6017 void MacroAssembler::string_indexof(Register str1, Register str2,
 6018                                     Register cnt1, Register cnt2,
 6019                                     int int_cnt2,  Register result,
 6020                                     XMMRegister vec, Register tmp,
 6021                                     int ae) {
 6022   ShortBranchVerifier sbv(this);
 6023   assert(UseSSE42Intrinsics, &quot;SSE4.2 intrinsics are required&quot;);
 6024   assert(ae != StrIntrinsicNode::LU, &quot;Invalid encoding&quot;);
 6025 
 6026   //
 6027   // int_cnt2 is length of small (&lt; 8 chars) constant substring
 6028   // or (-1) for non constant substring in which case its length
 6029   // is in cnt2 register.
 6030   //
 6031   // Note, inline_string_indexOf() generates checks:
 6032   // if (substr.count &gt; string.count) return -1;
 6033   // if (substr.count == 0) return 0;
 6034   //
 6035   int stride = (ae == StrIntrinsicNode::LL) ? 16 : 8; //UU, UL -&gt; 8
 6036   assert(int_cnt2 == -1 || (0 &lt; int_cnt2 &amp;&amp; int_cnt2 &lt; stride), &quot;should be != 0&quot;);
 6037   // This method uses the pcmpestri instruction with bound registers
 6038   //   inputs:
 6039   //     xmm - substring
 6040   //     rax - substring length (elements count)
 6041   //     mem - scanned string
 6042   //     rdx - string length (elements count)
 6043   //     0xd - mode: 1100 (substring search) + 01 (unsigned shorts)
 6044   //     0xc - mode: 1100 (substring search) + 00 (unsigned bytes)
 6045   //   outputs:
 6046   //     rcx - matched index in string
 6047   assert(cnt1 == rdx &amp;&amp; cnt2 == rax &amp;&amp; tmp == rcx, &quot;pcmpestri&quot;);
 6048   int mode = (ae == StrIntrinsicNode::LL) ? 0x0c : 0x0d; // bytes or shorts
 6049   Address::ScaleFactor scale1 = (ae == StrIntrinsicNode::LL) ? Address::times_1 : Address::times_2;
 6050   Address::ScaleFactor scale2 = (ae == StrIntrinsicNode::UL) ? Address::times_1 : scale1;
 6051 
 6052   Label RELOAD_SUBSTR, SCAN_TO_SUBSTR, SCAN_SUBSTR, ADJUST_STR,
 6053         RET_FOUND, RET_NOT_FOUND, CLEANUP, FOUND_SUBSTR,
 6054         FOUND_CANDIDATE;
 6055 
 6056   { //========================================================
 6057     // We don&#39;t know where these strings are located
 6058     // and we can&#39;t read beyond them. Load them through stack.
 6059     Label BIG_STRINGS, CHECK_STR, COPY_SUBSTR, COPY_STR;
 6060 
 6061     movptr(tmp, rsp); // save old SP
 6062 
 6063     if (int_cnt2 &gt; 0) {     // small (&lt; 8 chars) constant substring
 6064       if (int_cnt2 == (1&gt;&gt;scale2)) { // One byte
 6065         assert((ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UL), &quot;Only possible for latin1 encoding&quot;);
 6066         load_unsigned_byte(result, Address(str2, 0));
 6067         movdl(vec, result); // move 32 bits
 6068       } else if (ae == StrIntrinsicNode::LL &amp;&amp; int_cnt2 == 3) {  // Three bytes
 6069         // Not enough header space in 32-bit VM: 12+3 = 15.
 6070         movl(result, Address(str2, -1));
 6071         shrl(result, 8);
 6072         movdl(vec, result); // move 32 bits
 6073       } else if (ae != StrIntrinsicNode::UL &amp;&amp; int_cnt2 == (2&gt;&gt;scale2)) {  // One char
 6074         load_unsigned_short(result, Address(str2, 0));
 6075         movdl(vec, result); // move 32 bits
 6076       } else if (ae != StrIntrinsicNode::UL &amp;&amp; int_cnt2 == (4&gt;&gt;scale2)) { // Two chars
 6077         movdl(vec, Address(str2, 0)); // move 32 bits
 6078       } else if (ae != StrIntrinsicNode::UL &amp;&amp; int_cnt2 == (8&gt;&gt;scale2)) { // Four chars
 6079         movq(vec, Address(str2, 0));  // move 64 bits
 6080       } else { // cnt2 = { 3, 5, 6, 7 } || (ae == StrIntrinsicNode::UL &amp;&amp; cnt2 ={2, ..., 7})
 6081         // Array header size is 12 bytes in 32-bit VM
 6082         // + 6 bytes for 3 chars == 18 bytes,
 6083         // enough space to load vec and shift.
 6084         assert(HeapWordSize*TypeArrayKlass::header_size() &gt;= 12,&quot;sanity&quot;);
 6085         if (ae == StrIntrinsicNode::UL) {
 6086           int tail_off = int_cnt2-8;
 6087           pmovzxbw(vec, Address(str2, tail_off));
 6088           psrldq(vec, -2*tail_off);
 6089         }
 6090         else {
 6091           int tail_off = int_cnt2*(1&lt;&lt;scale2);
 6092           movdqu(vec, Address(str2, tail_off-16));
 6093           psrldq(vec, 16-tail_off);
 6094         }
 6095       }
 6096     } else { // not constant substring
 6097       cmpl(cnt2, stride);
 6098       jccb(Assembler::aboveEqual, BIG_STRINGS); // Both strings are big enough
 6099 
 6100       // We can read beyond string if srt+16 does not cross page boundary
 6101       // since heaps are aligned and mapped by pages.
 6102       assert(os::vm_page_size() &lt; (int)G, &quot;default page should be small&quot;);
 6103       movl(result, str2); // We need only low 32 bits
 6104       andl(result, (os::vm_page_size()-1));
 6105       cmpl(result, (os::vm_page_size()-16));
 6106       jccb(Assembler::belowEqual, CHECK_STR);
 6107 
 6108       // Move small strings to stack to allow load 16 bytes into vec.
 6109       subptr(rsp, 16);
 6110       int stk_offset = wordSize-(1&lt;&lt;scale2);
 6111       push(cnt2);
 6112 
 6113       bind(COPY_SUBSTR);
 6114       if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UL) {
 6115         load_unsigned_byte(result, Address(str2, cnt2, scale2, -1));
 6116         movb(Address(rsp, cnt2, scale2, stk_offset), result);
 6117       } else if (ae == StrIntrinsicNode::UU) {
 6118         load_unsigned_short(result, Address(str2, cnt2, scale2, -2));
 6119         movw(Address(rsp, cnt2, scale2, stk_offset), result);
 6120       }
 6121       decrement(cnt2);
 6122       jccb(Assembler::notZero, COPY_SUBSTR);
 6123 
 6124       pop(cnt2);
 6125       movptr(str2, rsp);  // New substring address
 6126     } // non constant
 6127 
 6128     bind(CHECK_STR);
 6129     cmpl(cnt1, stride);
 6130     jccb(Assembler::aboveEqual, BIG_STRINGS);
 6131 
 6132     // Check cross page boundary.
 6133     movl(result, str1); // We need only low 32 bits
 6134     andl(result, (os::vm_page_size()-1));
 6135     cmpl(result, (os::vm_page_size()-16));
 6136     jccb(Assembler::belowEqual, BIG_STRINGS);
 6137 
 6138     subptr(rsp, 16);
 6139     int stk_offset = -(1&lt;&lt;scale1);
 6140     if (int_cnt2 &lt; 0) { // not constant
 6141       push(cnt2);
 6142       stk_offset += wordSize;
 6143     }
 6144     movl(cnt2, cnt1);
 6145 
 6146     bind(COPY_STR);
 6147     if (ae == StrIntrinsicNode::LL) {
 6148       load_unsigned_byte(result, Address(str1, cnt2, scale1, -1));
 6149       movb(Address(rsp, cnt2, scale1, stk_offset), result);
 6150     } else {
 6151       load_unsigned_short(result, Address(str1, cnt2, scale1, -2));
 6152       movw(Address(rsp, cnt2, scale1, stk_offset), result);
 6153     }
 6154     decrement(cnt2);
 6155     jccb(Assembler::notZero, COPY_STR);
 6156 
 6157     if (int_cnt2 &lt; 0) { // not constant
 6158       pop(cnt2);
 6159     }
 6160     movptr(str1, rsp);  // New string address
 6161 
 6162     bind(BIG_STRINGS);
 6163     // Load substring.
 6164     if (int_cnt2 &lt; 0) { // -1
 6165       if (ae == StrIntrinsicNode::UL) {
 6166         pmovzxbw(vec, Address(str2, 0));
 6167       } else {
 6168         movdqu(vec, Address(str2, 0));
 6169       }
 6170       push(cnt2);       // substr count
 6171       push(str2);       // substr addr
 6172       push(str1);       // string addr
 6173     } else {
 6174       // Small (&lt; 8 chars) constant substrings are loaded already.
 6175       movl(cnt2, int_cnt2);
 6176     }
 6177     push(tmp);  // original SP
 6178 
 6179   } // Finished loading
 6180 
 6181   //========================================================
 6182   // Start search
 6183   //
 6184 
 6185   movptr(result, str1); // string addr
 6186 
 6187   if (int_cnt2  &lt; 0) {  // Only for non constant substring
 6188     jmpb(SCAN_TO_SUBSTR);
 6189 
 6190     // SP saved at sp+0
 6191     // String saved at sp+1*wordSize
 6192     // Substr saved at sp+2*wordSize
 6193     // Substr count saved at sp+3*wordSize
 6194 
 6195     // Reload substr for rescan, this code
 6196     // is executed only for large substrings (&gt; 8 chars)
 6197     bind(RELOAD_SUBSTR);
 6198     movptr(str2, Address(rsp, 2*wordSize));
 6199     movl(cnt2, Address(rsp, 3*wordSize));
 6200     if (ae == StrIntrinsicNode::UL) {
 6201       pmovzxbw(vec, Address(str2, 0));
 6202     } else {
 6203       movdqu(vec, Address(str2, 0));
 6204     }
 6205     // We came here after the beginning of the substring was
 6206     // matched but the rest of it was not so we need to search
 6207     // again. Start from the next element after the previous match.
 6208     subptr(str1, result); // Restore counter
 6209     if (ae == StrIntrinsicNode::UU || ae == StrIntrinsicNode::UL) {
 6210       shrl(str1, 1);
 6211     }
 6212     addl(cnt1, str1);
 6213     decrementl(cnt1);   // Shift to next element
 6214     cmpl(cnt1, cnt2);
 6215     jcc(Assembler::negative, RET_NOT_FOUND);  // Left less then substring
 6216 
 6217     addptr(result, (1&lt;&lt;scale1));
 6218   } // non constant
 6219 
 6220   // Scan string for start of substr in 16-byte vectors
 6221   bind(SCAN_TO_SUBSTR);
 6222   assert(cnt1 == rdx &amp;&amp; cnt2 == rax &amp;&amp; tmp == rcx, &quot;pcmpestri&quot;);
 6223   pcmpestri(vec, Address(result, 0), mode);
 6224   jccb(Assembler::below, FOUND_CANDIDATE);   // CF == 1
 6225   subl(cnt1, stride);
 6226   jccb(Assembler::lessEqual, RET_NOT_FOUND); // Scanned full string
 6227   cmpl(cnt1, cnt2);
 6228   jccb(Assembler::negative, RET_NOT_FOUND);  // Left less then substring
 6229   addptr(result, 16);
 6230 
 6231   bind(ADJUST_STR);
 6232   cmpl(cnt1, stride); // Do not read beyond string
 6233   jccb(Assembler::greaterEqual, SCAN_TO_SUBSTR);
 6234   // Back-up string to avoid reading beyond string.
 6235   lea(result, Address(result, cnt1, scale1, -16));
 6236   movl(cnt1, stride);
 6237   jmpb(SCAN_TO_SUBSTR);
 6238 
 6239   // Found a potential substr
 6240   bind(FOUND_CANDIDATE);
 6241   // After pcmpestri tmp(rcx) contains matched element index
 6242 
 6243   // Make sure string is still long enough
 6244   subl(cnt1, tmp);
 6245   cmpl(cnt1, cnt2);
 6246   jccb(Assembler::greaterEqual, FOUND_SUBSTR);
 6247   // Left less then substring.
 6248 
 6249   bind(RET_NOT_FOUND);
 6250   movl(result, -1);
 6251   jmp(CLEANUP);
 6252 
 6253   bind(FOUND_SUBSTR);
 6254   // Compute start addr of substr
 6255   lea(result, Address(result, tmp, scale1));
 6256   if (int_cnt2 &gt; 0) { // Constant substring
 6257     // Repeat search for small substring (&lt; 8 chars)
 6258     // from new point without reloading substring.
 6259     // Have to check that we don&#39;t read beyond string.
 6260     cmpl(tmp, stride-int_cnt2);
 6261     jccb(Assembler::greater, ADJUST_STR);
 6262     // Fall through if matched whole substring.
 6263   } else { // non constant
 6264     assert(int_cnt2 == -1, &quot;should be != 0&quot;);
 6265 
 6266     addl(tmp, cnt2);
 6267     // Found result if we matched whole substring.
 6268     cmpl(tmp, stride);
 6269     jcc(Assembler::lessEqual, RET_FOUND);
 6270 
 6271     // Repeat search for small substring (&lt;= 8 chars)
 6272     // from new point &#39;str1&#39; without reloading substring.
 6273     cmpl(cnt2, stride);
 6274     // Have to check that we don&#39;t read beyond string.
 6275     jccb(Assembler::lessEqual, ADJUST_STR);
 6276 
 6277     Label CHECK_NEXT, CONT_SCAN_SUBSTR, RET_FOUND_LONG;
 6278     // Compare the rest of substring (&gt; 8 chars).
 6279     movptr(str1, result);
 6280 
 6281     cmpl(tmp, cnt2);
 6282     // First 8 chars are already matched.
 6283     jccb(Assembler::equal, CHECK_NEXT);
 6284 
 6285     bind(SCAN_SUBSTR);
 6286     pcmpestri(vec, Address(str1, 0), mode);
 6287     // Need to reload strings pointers if not matched whole vector
 6288     jcc(Assembler::noOverflow, RELOAD_SUBSTR); // OF == 0
 6289 
 6290     bind(CHECK_NEXT);
 6291     subl(cnt2, stride);
 6292     jccb(Assembler::lessEqual, RET_FOUND_LONG); // Found full substring
 6293     addptr(str1, 16);
 6294     if (ae == StrIntrinsicNode::UL) {
 6295       addptr(str2, 8);
 6296     } else {
 6297       addptr(str2, 16);
 6298     }
 6299     subl(cnt1, stride);
 6300     cmpl(cnt2, stride); // Do not read beyond substring
 6301     jccb(Assembler::greaterEqual, CONT_SCAN_SUBSTR);
 6302     // Back-up strings to avoid reading beyond substring.
 6303 
 6304     if (ae == StrIntrinsicNode::UL) {
 6305       lea(str2, Address(str2, cnt2, scale2, -8));
 6306       lea(str1, Address(str1, cnt2, scale1, -16));
 6307     } else {
 6308       lea(str2, Address(str2, cnt2, scale2, -16));
 6309       lea(str1, Address(str1, cnt2, scale1, -16));
 6310     }
 6311     subl(cnt1, cnt2);
 6312     movl(cnt2, stride);
 6313     addl(cnt1, stride);
 6314     bind(CONT_SCAN_SUBSTR);
 6315     if (ae == StrIntrinsicNode::UL) {
 6316       pmovzxbw(vec, Address(str2, 0));
 6317     } else {
 6318       movdqu(vec, Address(str2, 0));
 6319     }
 6320     jmp(SCAN_SUBSTR);
 6321 
 6322     bind(RET_FOUND_LONG);
 6323     movptr(str1, Address(rsp, wordSize));
 6324   } // non constant
 6325 
 6326   bind(RET_FOUND);
 6327   // Compute substr offset
 6328   subptr(result, str1);
 6329   if (ae == StrIntrinsicNode::UU || ae == StrIntrinsicNode::UL) {
 6330     shrl(result, 1); // index
 6331   }
 6332   bind(CLEANUP);
 6333   pop(rsp); // restore SP
 6334 
 6335 } // string_indexof
 6336 
 6337 void MacroAssembler::string_indexof_char(Register str1, Register cnt1, Register ch, Register result,
 6338                                          XMMRegister vec1, XMMRegister vec2, XMMRegister vec3, Register tmp) {
 6339   ShortBranchVerifier sbv(this);
 6340   assert(UseSSE42Intrinsics, &quot;SSE4.2 intrinsics are required&quot;);
 6341 
 6342   int stride = 8;
 6343 
 6344   Label FOUND_CHAR, SCAN_TO_CHAR, SCAN_TO_CHAR_LOOP,
 6345         SCAN_TO_8_CHAR, SCAN_TO_8_CHAR_LOOP, SCAN_TO_16_CHAR_LOOP,
 6346         RET_NOT_FOUND, SCAN_TO_8_CHAR_INIT,
 6347         FOUND_SEQ_CHAR, DONE_LABEL;
 6348 
 6349   movptr(result, str1);
 6350   if (UseAVX &gt;= 2) {
 6351     cmpl(cnt1, stride);
 6352     jcc(Assembler::less, SCAN_TO_CHAR);
 6353     cmpl(cnt1, 2*stride);
 6354     jcc(Assembler::less, SCAN_TO_8_CHAR_INIT);
 6355     movdl(vec1, ch);
 6356     vpbroadcastw(vec1, vec1, Assembler::AVX_256bit);
 6357     vpxor(vec2, vec2);
 6358     movl(tmp, cnt1);
 6359     andl(tmp, 0xFFFFFFF0);  //vector count (in chars)
 6360     andl(cnt1,0x0000000F);  //tail count (in chars)
 6361 
 6362     bind(SCAN_TO_16_CHAR_LOOP);
 6363     vmovdqu(vec3, Address(result, 0));
 6364     vpcmpeqw(vec3, vec3, vec1, 1);
 6365     vptest(vec2, vec3);
 6366     jcc(Assembler::carryClear, FOUND_CHAR);
 6367     addptr(result, 32);
 6368     subl(tmp, 2*stride);
 6369     jcc(Assembler::notZero, SCAN_TO_16_CHAR_LOOP);
 6370     jmp(SCAN_TO_8_CHAR);
 6371     bind(SCAN_TO_8_CHAR_INIT);
 6372     movdl(vec1, ch);
 6373     pshuflw(vec1, vec1, 0x00);
 6374     pshufd(vec1, vec1, 0);
 6375     pxor(vec2, vec2);
 6376   }
 6377   bind(SCAN_TO_8_CHAR);
 6378   cmpl(cnt1, stride);
 6379   jcc(Assembler::less, SCAN_TO_CHAR);
 6380   if (UseAVX &lt; 2) {
 6381     movdl(vec1, ch);
 6382     pshuflw(vec1, vec1, 0x00);
 6383     pshufd(vec1, vec1, 0);
 6384     pxor(vec2, vec2);
 6385   }
 6386   movl(tmp, cnt1);
 6387   andl(tmp, 0xFFFFFFF8);  //vector count (in chars)
 6388   andl(cnt1,0x00000007);  //tail count (in chars)
 6389 
 6390   bind(SCAN_TO_8_CHAR_LOOP);
 6391   movdqu(vec3, Address(result, 0));
 6392   pcmpeqw(vec3, vec1);
 6393   ptest(vec2, vec3);
 6394   jcc(Assembler::carryClear, FOUND_CHAR);
 6395   addptr(result, 16);
 6396   subl(tmp, stride);
 6397   jcc(Assembler::notZero, SCAN_TO_8_CHAR_LOOP);
 6398   bind(SCAN_TO_CHAR);
 6399   testl(cnt1, cnt1);
 6400   jcc(Assembler::zero, RET_NOT_FOUND);
 6401   bind(SCAN_TO_CHAR_LOOP);
 6402   load_unsigned_short(tmp, Address(result, 0));
 6403   cmpl(ch, tmp);
 6404   jccb(Assembler::equal, FOUND_SEQ_CHAR);
 6405   addptr(result, 2);
 6406   subl(cnt1, 1);
 6407   jccb(Assembler::zero, RET_NOT_FOUND);
 6408   jmp(SCAN_TO_CHAR_LOOP);
 6409 
 6410   bind(RET_NOT_FOUND);
 6411   movl(result, -1);
 6412   jmpb(DONE_LABEL);
 6413 
 6414   bind(FOUND_CHAR);
 6415   if (UseAVX &gt;= 2) {
 6416     vpmovmskb(tmp, vec3);
 6417   } else {
 6418     pmovmskb(tmp, vec3);
 6419   }
 6420   bsfl(ch, tmp);
 6421   addl(result, ch);
 6422 
 6423   bind(FOUND_SEQ_CHAR);
 6424   subptr(result, str1);
 6425   shrl(result, 1);
 6426 
 6427   bind(DONE_LABEL);
 6428 } // string_indexof_char
 6429 
 6430 // helper function for string_compare
 6431 void MacroAssembler::load_next_elements(Register elem1, Register elem2, Register str1, Register str2,
 6432                                         Address::ScaleFactor scale, Address::ScaleFactor scale1,
 6433                                         Address::ScaleFactor scale2, Register index, int ae) {
 6434   if (ae == StrIntrinsicNode::LL) {
 6435     load_unsigned_byte(elem1, Address(str1, index, scale, 0));
 6436     load_unsigned_byte(elem2, Address(str2, index, scale, 0));
 6437   } else if (ae == StrIntrinsicNode::UU) {
 6438     load_unsigned_short(elem1, Address(str1, index, scale, 0));
 6439     load_unsigned_short(elem2, Address(str2, index, scale, 0));
 6440   } else {
 6441     load_unsigned_byte(elem1, Address(str1, index, scale1, 0));
 6442     load_unsigned_short(elem2, Address(str2, index, scale2, 0));
 6443   }
 6444 }
 6445 
 6446 // Compare strings, used for char[] and byte[].
 6447 void MacroAssembler::string_compare(Register str1, Register str2,
 6448                                     Register cnt1, Register cnt2, Register result,
 6449                                     XMMRegister vec1, int ae) {
 6450   ShortBranchVerifier sbv(this);
 6451   Label LENGTH_DIFF_LABEL, POP_LABEL, DONE_LABEL, WHILE_HEAD_LABEL;
 6452   Label COMPARE_WIDE_VECTORS_LOOP_FAILED;  // used only _LP64 &amp;&amp; AVX3
 6453   int stride, stride2, adr_stride, adr_stride1, adr_stride2;
 6454   int stride2x2 = 0x40;
 6455   Address::ScaleFactor scale = Address::no_scale;
 6456   Address::ScaleFactor scale1 = Address::no_scale;
 6457   Address::ScaleFactor scale2 = Address::no_scale;
 6458 
 6459   if (ae != StrIntrinsicNode::LL) {
 6460     stride2x2 = 0x20;
 6461   }
 6462 
 6463   if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {
 6464     shrl(cnt2, 1);
 6465   }
 6466   // Compute the minimum of the string lengths and the
 6467   // difference of the string lengths (stack).
 6468   // Do the conditional move stuff
 6469   movl(result, cnt1);
 6470   subl(cnt1, cnt2);
 6471   push(cnt1);
 6472   cmov32(Assembler::lessEqual, cnt2, result);    // cnt2 = min(cnt1, cnt2)
 6473 
 6474   // Is the minimum length zero?
 6475   testl(cnt2, cnt2);
 6476   jcc(Assembler::zero, LENGTH_DIFF_LABEL);
 6477   if (ae == StrIntrinsicNode::LL) {
 6478     // Load first bytes
 6479     load_unsigned_byte(result, Address(str1, 0));  // result = str1[0]
 6480     load_unsigned_byte(cnt1, Address(str2, 0));    // cnt1   = str2[0]
 6481   } else if (ae == StrIntrinsicNode::UU) {
 6482     // Load first characters
 6483     load_unsigned_short(result, Address(str1, 0));
 6484     load_unsigned_short(cnt1, Address(str2, 0));
 6485   } else {
 6486     load_unsigned_byte(result, Address(str1, 0));
 6487     load_unsigned_short(cnt1, Address(str2, 0));
 6488   }
 6489   subl(result, cnt1);
 6490   jcc(Assembler::notZero,  POP_LABEL);
 6491 
 6492   if (ae == StrIntrinsicNode::UU) {
 6493     // Divide length by 2 to get number of chars
 6494     shrl(cnt2, 1);
 6495   }
 6496   cmpl(cnt2, 1);
 6497   jcc(Assembler::equal, LENGTH_DIFF_LABEL);
 6498 
 6499   // Check if the strings start at the same location and setup scale and stride
 6500   if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
 6501     cmpptr(str1, str2);
 6502     jcc(Assembler::equal, LENGTH_DIFF_LABEL);
 6503     if (ae == StrIntrinsicNode::LL) {
 6504       scale = Address::times_1;
 6505       stride = 16;
 6506     } else {
 6507       scale = Address::times_2;
 6508       stride = 8;
 6509     }
 6510   } else {
 6511     scale1 = Address::times_1;
 6512     scale2 = Address::times_2;
 6513     // scale not used
 6514     stride = 8;
 6515   }
 6516 
 6517   if (UseAVX &gt;= 2 &amp;&amp; UseSSE42Intrinsics) {
 6518     Label COMPARE_WIDE_VECTORS, VECTOR_NOT_EQUAL, COMPARE_WIDE_TAIL, COMPARE_SMALL_STR;
 6519     Label COMPARE_WIDE_VECTORS_LOOP, COMPARE_16_CHARS, COMPARE_INDEX_CHAR;
 6520     Label COMPARE_WIDE_VECTORS_LOOP_AVX2;
 6521     Label COMPARE_TAIL_LONG;
 6522     Label COMPARE_WIDE_VECTORS_LOOP_AVX3;  // used only _LP64 &amp;&amp; AVX3
 6523 
 6524     int pcmpmask = 0x19;
 6525     if (ae == StrIntrinsicNode::LL) {
 6526       pcmpmask &amp;= ~0x01;
 6527     }
 6528 
 6529     // Setup to compare 16-chars (32-bytes) vectors,
 6530     // start from first character again because it has aligned address.
 6531     if (ae == StrIntrinsicNode::LL) {
 6532       stride2 = 32;
 6533     } else {
 6534       stride2 = 16;
 6535     }
 6536     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
 6537       adr_stride = stride &lt;&lt; scale;
 6538     } else {
 6539       adr_stride1 = 8;  //stride &lt;&lt; scale1;
 6540       adr_stride2 = 16; //stride &lt;&lt; scale2;
 6541     }
 6542 
 6543     assert(result == rax &amp;&amp; cnt2 == rdx &amp;&amp; cnt1 == rcx, &quot;pcmpestri&quot;);
 6544     // rax and rdx are used by pcmpestri as elements counters
 6545     movl(result, cnt2);
 6546     andl(cnt2, ~(stride2-1));   // cnt2 holds the vector count
 6547     jcc(Assembler::zero, COMPARE_TAIL_LONG);
 6548 
 6549     // fast path : compare first 2 8-char vectors.
 6550     bind(COMPARE_16_CHARS);
 6551     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
 6552       movdqu(vec1, Address(str1, 0));
 6553     } else {
 6554       pmovzxbw(vec1, Address(str1, 0));
 6555     }
 6556     pcmpestri(vec1, Address(str2, 0), pcmpmask);
 6557     jccb(Assembler::below, COMPARE_INDEX_CHAR);
 6558 
 6559     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
 6560       movdqu(vec1, Address(str1, adr_stride));
 6561       pcmpestri(vec1, Address(str2, adr_stride), pcmpmask);
 6562     } else {
 6563       pmovzxbw(vec1, Address(str1, adr_stride1));
 6564       pcmpestri(vec1, Address(str2, adr_stride2), pcmpmask);
 6565     }
 6566     jccb(Assembler::aboveEqual, COMPARE_WIDE_VECTORS);
 6567     addl(cnt1, stride);
 6568 
 6569     // Compare the characters at index in cnt1
 6570     bind(COMPARE_INDEX_CHAR); // cnt1 has the offset of the mismatching character
 6571     load_next_elements(result, cnt2, str1, str2, scale, scale1, scale2, cnt1, ae);
 6572     subl(result, cnt2);
 6573     jmp(POP_LABEL);
 6574 
 6575     // Setup the registers to start vector comparison loop
 6576     bind(COMPARE_WIDE_VECTORS);
 6577     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
 6578       lea(str1, Address(str1, result, scale));
 6579       lea(str2, Address(str2, result, scale));
 6580     } else {
 6581       lea(str1, Address(str1, result, scale1));
 6582       lea(str2, Address(str2, result, scale2));
 6583     }
 6584     subl(result, stride2);
 6585     subl(cnt2, stride2);
 6586     jcc(Assembler::zero, COMPARE_WIDE_TAIL);
 6587     negptr(result);
 6588 
 6589     //  In a loop, compare 16-chars (32-bytes) at once using (vpxor+vptest)
 6590     bind(COMPARE_WIDE_VECTORS_LOOP);
 6591 
 6592 #ifdef _LP64
 6593     if ((AVX3Threshold == 0) &amp;&amp; VM_Version::supports_avx512vlbw()) { // trying 64 bytes fast loop
 6594       cmpl(cnt2, stride2x2);
 6595       jccb(Assembler::below, COMPARE_WIDE_VECTORS_LOOP_AVX2);
 6596       testl(cnt2, stride2x2-1);   // cnt2 holds the vector count
 6597       jccb(Assembler::notZero, COMPARE_WIDE_VECTORS_LOOP_AVX2);   // means we cannot subtract by 0x40
 6598 
 6599       bind(COMPARE_WIDE_VECTORS_LOOP_AVX3); // the hottest loop
 6600       if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
 6601         evmovdquq(vec1, Address(str1, result, scale), Assembler::AVX_512bit);
 6602         evpcmpeqb(k7, vec1, Address(str2, result, scale), Assembler::AVX_512bit); // k7 == 11..11, if operands equal, otherwise k7 has some 0
 6603       } else {
 6604         vpmovzxbw(vec1, Address(str1, result, scale1), Assembler::AVX_512bit);
 6605         evpcmpeqb(k7, vec1, Address(str2, result, scale2), Assembler::AVX_512bit); // k7 == 11..11, if operands equal, otherwise k7 has some 0
 6606       }
 6607       kortestql(k7, k7);
 6608       jcc(Assembler::aboveEqual, COMPARE_WIDE_VECTORS_LOOP_FAILED);     // miscompare
 6609       addptr(result, stride2x2);  // update since we already compared at this addr
 6610       subl(cnt2, stride2x2);      // and sub the size too
 6611       jccb(Assembler::notZero, COMPARE_WIDE_VECTORS_LOOP_AVX3);
 6612 
 6613       vpxor(vec1, vec1);
 6614       jmpb(COMPARE_WIDE_TAIL);
 6615     }//if (VM_Version::supports_avx512vlbw())
 6616 #endif // _LP64
 6617 
 6618 
 6619     bind(COMPARE_WIDE_VECTORS_LOOP_AVX2);
 6620     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
 6621       vmovdqu(vec1, Address(str1, result, scale));
 6622       vpxor(vec1, Address(str2, result, scale));
 6623     } else {
 6624       vpmovzxbw(vec1, Address(str1, result, scale1), Assembler::AVX_256bit);
 6625       vpxor(vec1, Address(str2, result, scale2));
 6626     }
 6627     vptest(vec1, vec1);
 6628     jcc(Assembler::notZero, VECTOR_NOT_EQUAL);
 6629     addptr(result, stride2);
 6630     subl(cnt2, stride2);
 6631     jcc(Assembler::notZero, COMPARE_WIDE_VECTORS_LOOP);
 6632     // clean upper bits of YMM registers
 6633     vpxor(vec1, vec1);
 6634 
 6635     // compare wide vectors tail
 6636     bind(COMPARE_WIDE_TAIL);
 6637     testptr(result, result);
 6638     jcc(Assembler::zero, LENGTH_DIFF_LABEL);
 6639 
 6640     movl(result, stride2);
 6641     movl(cnt2, result);
 6642     negptr(result);
 6643     jmp(COMPARE_WIDE_VECTORS_LOOP_AVX2);
 6644 
 6645     // Identifies the mismatching (higher or lower)16-bytes in the 32-byte vectors.
 6646     bind(VECTOR_NOT_EQUAL);
 6647     // clean upper bits of YMM registers
 6648     vpxor(vec1, vec1);
 6649     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
 6650       lea(str1, Address(str1, result, scale));
 6651       lea(str2, Address(str2, result, scale));
 6652     } else {
 6653       lea(str1, Address(str1, result, scale1));
 6654       lea(str2, Address(str2, result, scale2));
 6655     }
 6656     jmp(COMPARE_16_CHARS);
 6657 
 6658     // Compare tail chars, length between 1 to 15 chars
 6659     bind(COMPARE_TAIL_LONG);
 6660     movl(cnt2, result);
 6661     cmpl(cnt2, stride);
 6662     jcc(Assembler::less, COMPARE_SMALL_STR);
 6663 
 6664     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
 6665       movdqu(vec1, Address(str1, 0));
 6666     } else {
 6667       pmovzxbw(vec1, Address(str1, 0));
 6668     }
 6669     pcmpestri(vec1, Address(str2, 0), pcmpmask);
 6670     jcc(Assembler::below, COMPARE_INDEX_CHAR);
 6671     subptr(cnt2, stride);
 6672     jcc(Assembler::zero, LENGTH_DIFF_LABEL);
 6673     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
 6674       lea(str1, Address(str1, result, scale));
 6675       lea(str2, Address(str2, result, scale));
 6676     } else {
 6677       lea(str1, Address(str1, result, scale1));
 6678       lea(str2, Address(str2, result, scale2));
 6679     }
 6680     negptr(cnt2);
 6681     jmpb(WHILE_HEAD_LABEL);
 6682 
 6683     bind(COMPARE_SMALL_STR);
 6684   } else if (UseSSE42Intrinsics) {
 6685     Label COMPARE_WIDE_VECTORS, VECTOR_NOT_EQUAL, COMPARE_TAIL;
 6686     int pcmpmask = 0x19;
 6687     // Setup to compare 8-char (16-byte) vectors,
 6688     // start from first character again because it has aligned address.
 6689     movl(result, cnt2);
 6690     andl(cnt2, ~(stride - 1));   // cnt2 holds the vector count
 6691     if (ae == StrIntrinsicNode::LL) {
 6692       pcmpmask &amp;= ~0x01;
 6693     }
 6694     jcc(Assembler::zero, COMPARE_TAIL);
 6695     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
 6696       lea(str1, Address(str1, result, scale));
 6697       lea(str2, Address(str2, result, scale));
 6698     } else {
 6699       lea(str1, Address(str1, result, scale1));
 6700       lea(str2, Address(str2, result, scale2));
 6701     }
 6702     negptr(result);
 6703 
 6704     // pcmpestri
 6705     //   inputs:
 6706     //     vec1- substring
 6707     //     rax - negative string length (elements count)
 6708     //     mem - scanned string
 6709     //     rdx - string length (elements count)
 6710     //     pcmpmask - cmp mode: 11000 (string compare with negated result)
 6711     //               + 00 (unsigned bytes) or  + 01 (unsigned shorts)
 6712     //   outputs:
 6713     //     rcx - first mismatched element index
 6714     assert(result == rax &amp;&amp; cnt2 == rdx &amp;&amp; cnt1 == rcx, &quot;pcmpestri&quot;);
 6715 
 6716     bind(COMPARE_WIDE_VECTORS);
 6717     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
 6718       movdqu(vec1, Address(str1, result, scale));
 6719       pcmpestri(vec1, Address(str2, result, scale), pcmpmask);
 6720     } else {
 6721       pmovzxbw(vec1, Address(str1, result, scale1));
 6722       pcmpestri(vec1, Address(str2, result, scale2), pcmpmask);
 6723     }
 6724     // After pcmpestri cnt1(rcx) contains mismatched element index
 6725 
 6726     jccb(Assembler::below, VECTOR_NOT_EQUAL);  // CF==1
 6727     addptr(result, stride);
 6728     subptr(cnt2, stride);
 6729     jccb(Assembler::notZero, COMPARE_WIDE_VECTORS);
 6730 
 6731     // compare wide vectors tail
 6732     testptr(result, result);
 6733     jcc(Assembler::zero, LENGTH_DIFF_LABEL);
 6734 
 6735     movl(cnt2, stride);
 6736     movl(result, stride);
 6737     negptr(result);
 6738     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
 6739       movdqu(vec1, Address(str1, result, scale));
 6740       pcmpestri(vec1, Address(str2, result, scale), pcmpmask);
 6741     } else {
 6742       pmovzxbw(vec1, Address(str1, result, scale1));
 6743       pcmpestri(vec1, Address(str2, result, scale2), pcmpmask);
 6744     }
 6745     jccb(Assembler::aboveEqual, LENGTH_DIFF_LABEL);
 6746 
 6747     // Mismatched characters in the vectors
 6748     bind(VECTOR_NOT_EQUAL);
 6749     addptr(cnt1, result);
 6750     load_next_elements(result, cnt2, str1, str2, scale, scale1, scale2, cnt1, ae);
 6751     subl(result, cnt2);
 6752     jmpb(POP_LABEL);
 6753 
 6754     bind(COMPARE_TAIL); // limit is zero
 6755     movl(cnt2, result);
 6756     // Fallthru to tail compare
 6757   }
 6758   // Shift str2 and str1 to the end of the arrays, negate min
 6759   if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {
 6760     lea(str1, Address(str1, cnt2, scale));
 6761     lea(str2, Address(str2, cnt2, scale));
 6762   } else {
 6763     lea(str1, Address(str1, cnt2, scale1));
 6764     lea(str2, Address(str2, cnt2, scale2));
 6765   }
 6766   decrementl(cnt2);  // first character was compared already
 6767   negptr(cnt2);
 6768 
 6769   // Compare the rest of the elements
 6770   bind(WHILE_HEAD_LABEL);
 6771   load_next_elements(result, cnt1, str1, str2, scale, scale1, scale2, cnt2, ae);
 6772   subl(result, cnt1);
 6773   jccb(Assembler::notZero, POP_LABEL);
 6774   increment(cnt2);
 6775   jccb(Assembler::notZero, WHILE_HEAD_LABEL);
 6776 
 6777   // Strings are equal up to min length.  Return the length difference.
 6778   bind(LENGTH_DIFF_LABEL);
 6779   pop(result);
 6780   if (ae == StrIntrinsicNode::UU) {
 6781     // Divide diff by 2 to get number of chars
 6782     sarl(result, 1);
 6783   }
 6784   jmpb(DONE_LABEL);
 6785 
 6786 #ifdef _LP64
 6787   if (VM_Version::supports_avx512vlbw()) {
 6788 
 6789     bind(COMPARE_WIDE_VECTORS_LOOP_FAILED);
 6790 
 6791     kmovql(cnt1, k7);
 6792     notq(cnt1);
 6793     bsfq(cnt2, cnt1);
 6794     if (ae != StrIntrinsicNode::LL) {
 6795       // Divide diff by 2 to get number of chars
 6796       sarl(cnt2, 1);
 6797     }
 6798     addq(result, cnt2);
 6799     if (ae == StrIntrinsicNode::LL) {
 6800       load_unsigned_byte(cnt1, Address(str2, result));
 6801       load_unsigned_byte(result, Address(str1, result));
 6802     } else if (ae == StrIntrinsicNode::UU) {
 6803       load_unsigned_short(cnt1, Address(str2, result, scale));
 6804       load_unsigned_short(result, Address(str1, result, scale));
 6805     } else {
 6806       load_unsigned_short(cnt1, Address(str2, result, scale2));
 6807       load_unsigned_byte(result, Address(str1, result, scale1));
 6808     }
 6809     subl(result, cnt1);
 6810     jmpb(POP_LABEL);
 6811   }//if (VM_Version::supports_avx512vlbw())
 6812 #endif // _LP64
 6813 
 6814   // Discard the stored length difference
 6815   bind(POP_LABEL);
 6816   pop(cnt1);
 6817 
 6818   // That&#39;s it
 6819   bind(DONE_LABEL);
 6820   if(ae == StrIntrinsicNode::UL) {
 6821     negl(result);
 6822   }
 6823 
 6824 }
 6825 
 6826 // Search for Non-ASCII character (Negative byte value) in a byte array,
 6827 // return true if it has any and false otherwise.
 6828 //   ..\jdk\src\java.base\share\classes\java\lang\StringCoding.java
 6829 //   @HotSpotIntrinsicCandidate
 6830 //   private static boolean hasNegatives(byte[] ba, int off, int len) {
 6831 //     for (int i = off; i &lt; off + len; i++) {
 6832 //       if (ba[i] &lt; 0) {
 6833 //         return true;
 6834 //       }
 6835 //     }
 6836 //     return false;
 6837 //   }
 6838 void MacroAssembler::has_negatives(Register ary1, Register len,
 6839   Register result, Register tmp1,
 6840   XMMRegister vec1, XMMRegister vec2) {
 6841   // rsi: byte array
 6842   // rcx: len
 6843   // rax: result
 6844   ShortBranchVerifier sbv(this);
 6845   assert_different_registers(ary1, len, result, tmp1);
 6846   assert_different_registers(vec1, vec2);
 6847   Label TRUE_LABEL, FALSE_LABEL, DONE, COMPARE_CHAR, COMPARE_VECTORS, COMPARE_BYTE;
 6848 
 6849   // len == 0
 6850   testl(len, len);
 6851   jcc(Assembler::zero, FALSE_LABEL);
 6852 
 6853   if ((AVX3Threshold == 0) &amp;&amp; (UseAVX &gt; 2) &amp;&amp; // AVX512
 6854     VM_Version::supports_avx512vlbw() &amp;&amp;
 6855     VM_Version::supports_bmi2()) {
 6856 
 6857     Label test_64_loop, test_tail;
 6858     Register tmp3_aliased = len;
 6859 
 6860     movl(tmp1, len);
 6861     vpxor(vec2, vec2, vec2, Assembler::AVX_512bit);
 6862 
 6863     andl(tmp1, 64 - 1);   // tail count (in chars) 0x3F
 6864     andl(len, ~(64 - 1));    // vector count (in chars)
 6865     jccb(Assembler::zero, test_tail);
 6866 
 6867     lea(ary1, Address(ary1, len, Address::times_1));
 6868     negptr(len);
 6869 
 6870     bind(test_64_loop);
 6871     // Check whether our 64 elements of size byte contain negatives
 6872     evpcmpgtb(k2, vec2, Address(ary1, len, Address::times_1), Assembler::AVX_512bit);
 6873     kortestql(k2, k2);
 6874     jcc(Assembler::notZero, TRUE_LABEL);
 6875 
 6876     addptr(len, 64);
 6877     jccb(Assembler::notZero, test_64_loop);
 6878 
 6879 
 6880     bind(test_tail);
 6881     // bail out when there is nothing to be done
 6882     testl(tmp1, -1);
 6883     jcc(Assembler::zero, FALSE_LABEL);
 6884 
 6885     // ~(~0 &lt;&lt; len) applied up to two times (for 32-bit scenario)
 6886 #ifdef _LP64
 6887     mov64(tmp3_aliased, 0xFFFFFFFFFFFFFFFF);
 6888     shlxq(tmp3_aliased, tmp3_aliased, tmp1);
 6889     notq(tmp3_aliased);
 6890     kmovql(k3, tmp3_aliased);
 6891 #else
 6892     Label k_init;
 6893     jmp(k_init);
 6894 
 6895     // We could not read 64-bits from a general purpose register thus we move
 6896     // data required to compose 64 1&#39;s to the instruction stream
 6897     // We emit 64 byte wide series of elements from 0..63 which later on would
 6898     // be used as a compare targets with tail count contained in tmp1 register.
 6899     // Result would be a k register having tmp1 consecutive number or 1
 6900     // counting from least significant bit.
 6901     address tmp = pc();
 6902     emit_int64(0x0706050403020100);
 6903     emit_int64(0x0F0E0D0C0B0A0908);
 6904     emit_int64(0x1716151413121110);
 6905     emit_int64(0x1F1E1D1C1B1A1918);
 6906     emit_int64(0x2726252423222120);
 6907     emit_int64(0x2F2E2D2C2B2A2928);
 6908     emit_int64(0x3736353433323130);
 6909     emit_int64(0x3F3E3D3C3B3A3938);
 6910 
 6911     bind(k_init);
 6912     lea(len, InternalAddress(tmp));
 6913     // create mask to test for negative byte inside a vector
 6914     evpbroadcastb(vec1, tmp1, Assembler::AVX_512bit);
 6915     evpcmpgtb(k3, vec1, Address(len, 0), Assembler::AVX_512bit);
 6916 
 6917 #endif
 6918     evpcmpgtb(k2, k3, vec2, Address(ary1, 0), Assembler::AVX_512bit);
 6919     ktestq(k2, k3);
 6920     jcc(Assembler::notZero, TRUE_LABEL);
 6921 
 6922     jmp(FALSE_LABEL);
 6923   } else {
 6924     movl(result, len); // copy
 6925 
 6926     if (UseAVX &gt;= 2 &amp;&amp; UseSSE &gt;= 2) {
 6927       // With AVX2, use 32-byte vector compare
 6928       Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;
 6929 
 6930       // Compare 32-byte vectors
 6931       andl(result, 0x0000001f);  //   tail count (in bytes)
 6932       andl(len, 0xffffffe0);   // vector count (in bytes)
 6933       jccb(Assembler::zero, COMPARE_TAIL);
 6934 
 6935       lea(ary1, Address(ary1, len, Address::times_1));
 6936       negptr(len);
 6937 
 6938       movl(tmp1, 0x80808080);   // create mask to test for Unicode chars in vector
 6939       movdl(vec2, tmp1);
 6940       vpbroadcastd(vec2, vec2, Assembler::AVX_256bit);
 6941 
 6942       bind(COMPARE_WIDE_VECTORS);
 6943       vmovdqu(vec1, Address(ary1, len, Address::times_1));
 6944       vptest(vec1, vec2);
 6945       jccb(Assembler::notZero, TRUE_LABEL);
 6946       addptr(len, 32);
 6947       jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);
 6948 
 6949       testl(result, result);
 6950       jccb(Assembler::zero, FALSE_LABEL);
 6951 
 6952       vmovdqu(vec1, Address(ary1, result, Address::times_1, -32));
 6953       vptest(vec1, vec2);
 6954       jccb(Assembler::notZero, TRUE_LABEL);
 6955       jmpb(FALSE_LABEL);
 6956 
 6957       bind(COMPARE_TAIL); // len is zero
 6958       movl(len, result);
 6959       // Fallthru to tail compare
 6960     } else if (UseSSE42Intrinsics) {
 6961       // With SSE4.2, use double quad vector compare
 6962       Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;
 6963 
 6964       // Compare 16-byte vectors
 6965       andl(result, 0x0000000f);  //   tail count (in bytes)
 6966       andl(len, 0xfffffff0);   // vector count (in bytes)
 6967       jcc(Assembler::zero, COMPARE_TAIL);
 6968 
 6969       lea(ary1, Address(ary1, len, Address::times_1));
 6970       negptr(len);
 6971 
 6972       movl(tmp1, 0x80808080);
 6973       movdl(vec2, tmp1);
 6974       pshufd(vec2, vec2, 0);
 6975 
 6976       bind(COMPARE_WIDE_VECTORS);
 6977       movdqu(vec1, Address(ary1, len, Address::times_1));
 6978       ptest(vec1, vec2);
 6979       jcc(Assembler::notZero, TRUE_LABEL);
 6980       addptr(len, 16);
 6981       jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);
 6982 
 6983       testl(result, result);
 6984       jcc(Assembler::zero, FALSE_LABEL);
 6985 
 6986       movdqu(vec1, Address(ary1, result, Address::times_1, -16));
 6987       ptest(vec1, vec2);
 6988       jccb(Assembler::notZero, TRUE_LABEL);
 6989       jmpb(FALSE_LABEL);
 6990 
 6991       bind(COMPARE_TAIL); // len is zero
 6992       movl(len, result);
 6993       // Fallthru to tail compare
 6994     }
 6995   }
 6996   // Compare 4-byte vectors
 6997   andl(len, 0xfffffffc); // vector count (in bytes)
 6998   jccb(Assembler::zero, COMPARE_CHAR);
 6999 
 7000   lea(ary1, Address(ary1, len, Address::times_1));
 7001   negptr(len);
 7002 
 7003   bind(COMPARE_VECTORS);
 7004   movl(tmp1, Address(ary1, len, Address::times_1));
 7005   andl(tmp1, 0x80808080);
 7006   jccb(Assembler::notZero, TRUE_LABEL);
 7007   addptr(len, 4);
 7008   jcc(Assembler::notZero, COMPARE_VECTORS);
 7009 
 7010   // Compare trailing char (final 2 bytes), if any
 7011   bind(COMPARE_CHAR);
 7012   testl(result, 0x2);   // tail  char
 7013   jccb(Assembler::zero, COMPARE_BYTE);
 7014   load_unsigned_short(tmp1, Address(ary1, 0));
 7015   andl(tmp1, 0x00008080);
 7016   jccb(Assembler::notZero, TRUE_LABEL);
 7017   subptr(result, 2);
 7018   lea(ary1, Address(ary1, 2));
 7019 
 7020   bind(COMPARE_BYTE);
 7021   testl(result, 0x1);   // tail  byte
 7022   jccb(Assembler::zero, FALSE_LABEL);
 7023   load_unsigned_byte(tmp1, Address(ary1, 0));
 7024   andl(tmp1, 0x00000080);
 7025   jccb(Assembler::notEqual, TRUE_LABEL);
 7026   jmpb(FALSE_LABEL);
 7027 
 7028   bind(TRUE_LABEL);
 7029   movl(result, 1);   // return true
 7030   jmpb(DONE);
 7031 
 7032   bind(FALSE_LABEL);
 7033   xorl(result, result); // return false
 7034 
 7035   // That&#39;s it
 7036   bind(DONE);
 7037   if (UseAVX &gt;= 2 &amp;&amp; UseSSE &gt;= 2) {
 7038     // clean upper bits of YMM registers
 7039     vpxor(vec1, vec1);
 7040     vpxor(vec2, vec2);
 7041   }
 7042 }
 7043 // Compare char[] or byte[] arrays aligned to 4 bytes or substrings.
 7044 void MacroAssembler::arrays_equals(bool is_array_equ, Register ary1, Register ary2,
 7045                                    Register limit, Register result, Register chr,
 7046                                    XMMRegister vec1, XMMRegister vec2, bool is_char) {
 7047   ShortBranchVerifier sbv(this);
 7048   Label TRUE_LABEL, FALSE_LABEL, DONE, COMPARE_VECTORS, COMPARE_CHAR, COMPARE_BYTE;
 7049 
 7050   int length_offset  = arrayOopDesc::length_offset_in_bytes();
 7051   int base_offset    = arrayOopDesc::base_offset_in_bytes(is_char ? T_CHAR : T_BYTE);
 7052 
 7053   if (is_array_equ) {
 7054     // Check the input args
 7055     cmpoop(ary1, ary2);
 7056     jcc(Assembler::equal, TRUE_LABEL);
 7057 
 7058     // Need additional checks for arrays_equals.
 7059     testptr(ary1, ary1);
 7060     jcc(Assembler::zero, FALSE_LABEL);
 7061     testptr(ary2, ary2);
 7062     jcc(Assembler::zero, FALSE_LABEL);
 7063 
 7064     // Check the lengths
 7065     movl(limit, Address(ary1, length_offset));
 7066     cmpl(limit, Address(ary2, length_offset));
 7067     jcc(Assembler::notEqual, FALSE_LABEL);
 7068   }
 7069 
 7070   // count == 0
 7071   testl(limit, limit);
 7072   jcc(Assembler::zero, TRUE_LABEL);
 7073 
 7074   if (is_array_equ) {
 7075     // Load array address
 7076     lea(ary1, Address(ary1, base_offset));
 7077     lea(ary2, Address(ary2, base_offset));
 7078   }
 7079 
 7080   if (is_array_equ &amp;&amp; is_char) {
 7081     // arrays_equals when used for char[].
 7082     shll(limit, 1);      // byte count != 0
 7083   }
 7084   movl(result, limit); // copy
 7085 
 7086   if (UseAVX &gt;= 2) {
 7087     // With AVX2, use 32-byte vector compare
 7088     Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;
 7089 
 7090     // Compare 32-byte vectors
 7091     andl(result, 0x0000001f);  //   tail count (in bytes)
 7092     andl(limit, 0xffffffe0);   // vector count (in bytes)
 7093     jcc(Assembler::zero, COMPARE_TAIL);
 7094 
 7095     lea(ary1, Address(ary1, limit, Address::times_1));
 7096     lea(ary2, Address(ary2, limit, Address::times_1));
 7097     negptr(limit);
 7098 
 7099 #ifdef _LP64
 7100     if ((AVX3Threshold == 0) &amp;&amp; VM_Version::supports_avx512vlbw()) { // trying 64 bytes fast loop
 7101       Label COMPARE_WIDE_VECTORS_LOOP_AVX2, COMPARE_WIDE_VECTORS_LOOP_AVX3;
 7102 
 7103       cmpl(limit, -64);
 7104       jcc(Assembler::greater, COMPARE_WIDE_VECTORS_LOOP_AVX2);
 7105 
 7106       bind(COMPARE_WIDE_VECTORS_LOOP_AVX3); // the hottest loop
 7107 
 7108       evmovdquq(vec1, Address(ary1, limit, Address::times_1), Assembler::AVX_512bit);
 7109       evpcmpeqb(k7, vec1, Address(ary2, limit, Address::times_1), Assembler::AVX_512bit);
 7110       kortestql(k7, k7);
 7111       jcc(Assembler::aboveEqual, FALSE_LABEL);     // miscompare
 7112       addptr(limit, 64);  // update since we already compared at this addr
 7113       cmpl(limit, -64);
 7114       jccb(Assembler::lessEqual, COMPARE_WIDE_VECTORS_LOOP_AVX3);
 7115 
 7116       // At this point we may still need to compare -limit+result bytes.
 7117       // We could execute the next two instruction and just continue via non-wide path:
 7118       //  cmpl(limit, 0);
 7119       //  jcc(Assembler::equal, COMPARE_TAIL);  // true
 7120       // But since we stopped at the points ary{1,2}+limit which are
 7121       // not farther than 64 bytes from the ends of arrays ary{1,2}+result
 7122       // (|limit| &lt;= 32 and result &lt; 32),
 7123       // we may just compare the last 64 bytes.
 7124       //
 7125       addptr(result, -64);   // it is safe, bc we just came from this area
 7126       evmovdquq(vec1, Address(ary1, result, Address::times_1), Assembler::AVX_512bit);
 7127       evpcmpeqb(k7, vec1, Address(ary2, result, Address::times_1), Assembler::AVX_512bit);
 7128       kortestql(k7, k7);
 7129       jcc(Assembler::aboveEqual, FALSE_LABEL);     // miscompare
 7130 
 7131       jmp(TRUE_LABEL);
 7132 
 7133       bind(COMPARE_WIDE_VECTORS_LOOP_AVX2);
 7134 
 7135     }//if (VM_Version::supports_avx512vlbw())
 7136 #endif //_LP64
 7137     bind(COMPARE_WIDE_VECTORS);
 7138     vmovdqu(vec1, Address(ary1, limit, Address::times_1));
 7139     vmovdqu(vec2, Address(ary2, limit, Address::times_1));
 7140     vpxor(vec1, vec2);
 7141 
 7142     vptest(vec1, vec1);
 7143     jcc(Assembler::notZero, FALSE_LABEL);
 7144     addptr(limit, 32);
 7145     jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);
 7146 
 7147     testl(result, result);
 7148     jcc(Assembler::zero, TRUE_LABEL);
 7149 
 7150     vmovdqu(vec1, Address(ary1, result, Address::times_1, -32));
 7151     vmovdqu(vec2, Address(ary2, result, Address::times_1, -32));
 7152     vpxor(vec1, vec2);
 7153 
 7154     vptest(vec1, vec1);
 7155     jccb(Assembler::notZero, FALSE_LABEL);
 7156     jmpb(TRUE_LABEL);
 7157 
 7158     bind(COMPARE_TAIL); // limit is zero
 7159     movl(limit, result);
 7160     // Fallthru to tail compare
 7161   } else if (UseSSE42Intrinsics) {
 7162     // With SSE4.2, use double quad vector compare
 7163     Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;
 7164 
 7165     // Compare 16-byte vectors
 7166     andl(result, 0x0000000f);  //   tail count (in bytes)
 7167     andl(limit, 0xfffffff0);   // vector count (in bytes)
 7168     jcc(Assembler::zero, COMPARE_TAIL);
 7169 
 7170     lea(ary1, Address(ary1, limit, Address::times_1));
 7171     lea(ary2, Address(ary2, limit, Address::times_1));
 7172     negptr(limit);
 7173 
 7174     bind(COMPARE_WIDE_VECTORS);
 7175     movdqu(vec1, Address(ary1, limit, Address::times_1));
 7176     movdqu(vec2, Address(ary2, limit, Address::times_1));
 7177     pxor(vec1, vec2);
 7178 
 7179     ptest(vec1, vec1);
 7180     jcc(Assembler::notZero, FALSE_LABEL);
 7181     addptr(limit, 16);
 7182     jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);
 7183 
 7184     testl(result, result);
 7185     jcc(Assembler::zero, TRUE_LABEL);
 7186 
 7187     movdqu(vec1, Address(ary1, result, Address::times_1, -16));
 7188     movdqu(vec2, Address(ary2, result, Address::times_1, -16));
 7189     pxor(vec1, vec2);
 7190 
 7191     ptest(vec1, vec1);
 7192     jccb(Assembler::notZero, FALSE_LABEL);
 7193     jmpb(TRUE_LABEL);
 7194 
 7195     bind(COMPARE_TAIL); // limit is zero
 7196     movl(limit, result);
 7197     // Fallthru to tail compare
 7198   }
 7199 
 7200   // Compare 4-byte vectors
 7201   andl(limit, 0xfffffffc); // vector count (in bytes)
 7202   jccb(Assembler::zero, COMPARE_CHAR);
 7203 
 7204   lea(ary1, Address(ary1, limit, Address::times_1));
 7205   lea(ary2, Address(ary2, limit, Address::times_1));
 7206   negptr(limit);
 7207 
 7208   bind(COMPARE_VECTORS);
 7209   movl(chr, Address(ary1, limit, Address::times_1));
 7210   cmpl(chr, Address(ary2, limit, Address::times_1));
 7211   jccb(Assembler::notEqual, FALSE_LABEL);
 7212   addptr(limit, 4);
 7213   jcc(Assembler::notZero, COMPARE_VECTORS);
 7214 
 7215   // Compare trailing char (final 2 bytes), if any
 7216   bind(COMPARE_CHAR);
 7217   testl(result, 0x2);   // tail  char
 7218   jccb(Assembler::zero, COMPARE_BYTE);
 7219   load_unsigned_short(chr, Address(ary1, 0));
 7220   load_unsigned_short(limit, Address(ary2, 0));
 7221   cmpl(chr, limit);
 7222   jccb(Assembler::notEqual, FALSE_LABEL);
 7223 
 7224   if (is_array_equ &amp;&amp; is_char) {
 7225     bind(COMPARE_BYTE);
 7226   } else {
 7227     lea(ary1, Address(ary1, 2));
 7228     lea(ary2, Address(ary2, 2));
 7229 
 7230     bind(COMPARE_BYTE);
 7231     testl(result, 0x1);   // tail  byte
 7232     jccb(Assembler::zero, TRUE_LABEL);
 7233     load_unsigned_byte(chr, Address(ary1, 0));
 7234     load_unsigned_byte(limit, Address(ary2, 0));
 7235     cmpl(chr, limit);
 7236     jccb(Assembler::notEqual, FALSE_LABEL);
 7237   }
 7238   bind(TRUE_LABEL);
 7239   movl(result, 1);   // return true
 7240   jmpb(DONE);
 7241 
 7242   bind(FALSE_LABEL);
 7243   xorl(result, result); // return false
 7244 
 7245   // That&#39;s it
 7246   bind(DONE);
 7247   if (UseAVX &gt;= 2) {
 7248     // clean upper bits of YMM registers
 7249     vpxor(vec1, vec1);
 7250     vpxor(vec2, vec2);
 7251   }
 7252 }
 7253 
 7254 #endif
 7255 
 7256 void MacroAssembler::generate_fill(BasicType t, bool aligned,
 7257                                    Register to, Register value, Register count,
 7258                                    Register rtmp, XMMRegister xtmp) {
 7259   ShortBranchVerifier sbv(this);
 7260   assert_different_registers(to, value, count, rtmp);
 7261   Label L_exit;
 7262   Label L_fill_2_bytes, L_fill_4_bytes;
 7263 
 7264   int shift = -1;
 7265   switch (t) {
 7266     case T_BYTE:
 7267       shift = 2;
 7268       break;
 7269     case T_SHORT:
 7270       shift = 1;
 7271       break;
 7272     case T_INT:
 7273       shift = 0;
 7274       break;
 7275     default: ShouldNotReachHere();
 7276   }
 7277 
 7278   if (t == T_BYTE) {
 7279     andl(value, 0xff);
 7280     movl(rtmp, value);
 7281     shll(rtmp, 8);
 7282     orl(value, rtmp);
 7283   }
 7284   if (t == T_SHORT) {
 7285     andl(value, 0xffff);
 7286   }
 7287   if (t == T_BYTE || t == T_SHORT) {
 7288     movl(rtmp, value);
 7289     shll(rtmp, 16);
 7290     orl(value, rtmp);
 7291   }
 7292 
 7293   cmpl(count, 2&lt;&lt;shift); // Short arrays (&lt; 8 bytes) fill by element
 7294   jcc(Assembler::below, L_fill_4_bytes); // use unsigned cmp
 7295   if (!UseUnalignedLoadStores &amp;&amp; !aligned &amp;&amp; (t == T_BYTE || t == T_SHORT)) {
 7296     Label L_skip_align2;
 7297     // align source address at 4 bytes address boundary
 7298     if (t == T_BYTE) {
 7299       Label L_skip_align1;
 7300       // One byte misalignment happens only for byte arrays
 7301       testptr(to, 1);
 7302       jccb(Assembler::zero, L_skip_align1);
 7303       movb(Address(to, 0), value);
 7304       increment(to);
 7305       decrement(count);
 7306       BIND(L_skip_align1);
 7307     }
 7308     // Two bytes misalignment happens only for byte and short (char) arrays
 7309     testptr(to, 2);
 7310     jccb(Assembler::zero, L_skip_align2);
 7311     movw(Address(to, 0), value);
 7312     addptr(to, 2);
 7313     subl(count, 1&lt;&lt;(shift-1));
 7314     BIND(L_skip_align2);
 7315   }
 7316   if (UseSSE &lt; 2) {
 7317     Label L_fill_32_bytes_loop, L_check_fill_8_bytes, L_fill_8_bytes_loop, L_fill_8_bytes;
 7318     // Fill 32-byte chunks
 7319     subl(count, 8 &lt;&lt; shift);
 7320     jcc(Assembler::less, L_check_fill_8_bytes);
 7321     align(16);
 7322 
 7323     BIND(L_fill_32_bytes_loop);
 7324 
 7325     for (int i = 0; i &lt; 32; i += 4) {
 7326       movl(Address(to, i), value);
 7327     }
 7328 
 7329     addptr(to, 32);
 7330     subl(count, 8 &lt;&lt; shift);
 7331     jcc(Assembler::greaterEqual, L_fill_32_bytes_loop);
 7332     BIND(L_check_fill_8_bytes);
 7333     addl(count, 8 &lt;&lt; shift);
 7334     jccb(Assembler::zero, L_exit);
 7335     jmpb(L_fill_8_bytes);
 7336 
 7337     //
 7338     // length is too short, just fill qwords
 7339     //
 7340     BIND(L_fill_8_bytes_loop);
 7341     movl(Address(to, 0), value);
 7342     movl(Address(to, 4), value);
 7343     addptr(to, 8);
 7344     BIND(L_fill_8_bytes);
 7345     subl(count, 1 &lt;&lt; (shift + 1));
 7346     jcc(Assembler::greaterEqual, L_fill_8_bytes_loop);
 7347     // fall through to fill 4 bytes
 7348   } else {
 7349     Label L_fill_32_bytes;
 7350     if (!UseUnalignedLoadStores) {
 7351       // align to 8 bytes, we know we are 4 byte aligned to start
 7352       testptr(to, 4);
 7353       jccb(Assembler::zero, L_fill_32_bytes);
 7354       movl(Address(to, 0), value);
 7355       addptr(to, 4);
 7356       subl(count, 1&lt;&lt;shift);
 7357     }
 7358     BIND(L_fill_32_bytes);
 7359     {
 7360       assert( UseSSE &gt;= 2, &quot;supported cpu only&quot; );
 7361       Label L_fill_32_bytes_loop, L_check_fill_8_bytes, L_fill_8_bytes_loop, L_fill_8_bytes;
 7362       movdl(xtmp, value);
 7363       if (UseAVX &gt;= 2 &amp;&amp; UseUnalignedLoadStores) {
 7364         Label L_check_fill_32_bytes;
 7365         if (UseAVX &gt; 2) {
 7366           // Fill 64-byte chunks
 7367           Label L_fill_64_bytes_loop_avx3, L_check_fill_64_bytes_avx2;
 7368 
 7369           // If number of bytes to fill &lt; AVX3Threshold, perform fill using AVX2
 7370           cmpl(count, AVX3Threshold);
 7371           jccb(Assembler::below, L_check_fill_64_bytes_avx2);
 7372 
 7373           vpbroadcastd(xtmp, xtmp, Assembler::AVX_512bit);
 7374 
 7375           subl(count, 16 &lt;&lt; shift);
 7376           jccb(Assembler::less, L_check_fill_32_bytes);
 7377           align(16);
 7378 
 7379           BIND(L_fill_64_bytes_loop_avx3);
 7380           evmovdqul(Address(to, 0), xtmp, Assembler::AVX_512bit);
 7381           addptr(to, 64);
 7382           subl(count, 16 &lt;&lt; shift);
 7383           jcc(Assembler::greaterEqual, L_fill_64_bytes_loop_avx3);
 7384           jmpb(L_check_fill_32_bytes);
 7385 
 7386           BIND(L_check_fill_64_bytes_avx2);
 7387         }
 7388         // Fill 64-byte chunks
 7389         Label L_fill_64_bytes_loop;
 7390         vpbroadcastd(xtmp, xtmp, Assembler::AVX_256bit);
 7391 
 7392         subl(count, 16 &lt;&lt; shift);
 7393         jcc(Assembler::less, L_check_fill_32_bytes);
 7394         align(16);
 7395 
 7396         BIND(L_fill_64_bytes_loop);
 7397         vmovdqu(Address(to, 0), xtmp);
 7398         vmovdqu(Address(to, 32), xtmp);
 7399         addptr(to, 64);
 7400         subl(count, 16 &lt;&lt; shift);
 7401         jcc(Assembler::greaterEqual, L_fill_64_bytes_loop);
 7402 
 7403         BIND(L_check_fill_32_bytes);
 7404         addl(count, 8 &lt;&lt; shift);
 7405         jccb(Assembler::less, L_check_fill_8_bytes);
 7406         vmovdqu(Address(to, 0), xtmp);
 7407         addptr(to, 32);
 7408         subl(count, 8 &lt;&lt; shift);
 7409 
 7410         BIND(L_check_fill_8_bytes);
 7411         // clean upper bits of YMM registers
 7412         movdl(xtmp, value);
 7413         pshufd(xtmp, xtmp, 0);
 7414       } else {
 7415         // Fill 32-byte chunks
 7416         pshufd(xtmp, xtmp, 0);
 7417 
 7418         subl(count, 8 &lt;&lt; shift);
 7419         jcc(Assembler::less, L_check_fill_8_bytes);
 7420         align(16);
 7421 
 7422         BIND(L_fill_32_bytes_loop);
 7423 
 7424         if (UseUnalignedLoadStores) {
 7425           movdqu(Address(to, 0), xtmp);
 7426           movdqu(Address(to, 16), xtmp);
 7427         } else {
 7428           movq(Address(to, 0), xtmp);
 7429           movq(Address(to, 8), xtmp);
 7430           movq(Address(to, 16), xtmp);
 7431           movq(Address(to, 24), xtmp);
 7432         }
 7433 
 7434         addptr(to, 32);
 7435         subl(count, 8 &lt;&lt; shift);
 7436         jcc(Assembler::greaterEqual, L_fill_32_bytes_loop);
 7437 
 7438         BIND(L_check_fill_8_bytes);
 7439       }
 7440       addl(count, 8 &lt;&lt; shift);
 7441       jccb(Assembler::zero, L_exit);
 7442       jmpb(L_fill_8_bytes);
 7443 
 7444       //
 7445       // length is too short, just fill qwords
 7446       //
 7447       BIND(L_fill_8_bytes_loop);
 7448       movq(Address(to, 0), xtmp);
 7449       addptr(to, 8);
 7450       BIND(L_fill_8_bytes);
 7451       subl(count, 1 &lt;&lt; (shift + 1));
 7452       jcc(Assembler::greaterEqual, L_fill_8_bytes_loop);
 7453     }
 7454   }
 7455   // fill trailing 4 bytes
 7456   BIND(L_fill_4_bytes);
 7457   testl(count, 1&lt;&lt;shift);
 7458   jccb(Assembler::zero, L_fill_2_bytes);
 7459   movl(Address(to, 0), value);
 7460   if (t == T_BYTE || t == T_SHORT) {
 7461     Label L_fill_byte;
 7462     addptr(to, 4);
 7463     BIND(L_fill_2_bytes);
 7464     // fill trailing 2 bytes
 7465     testl(count, 1&lt;&lt;(shift-1));
 7466     jccb(Assembler::zero, L_fill_byte);
 7467     movw(Address(to, 0), value);
 7468     if (t == T_BYTE) {
 7469       addptr(to, 2);
 7470       BIND(L_fill_byte);
 7471       // fill trailing byte
 7472       testl(count, 1);
 7473       jccb(Assembler::zero, L_exit);
 7474       movb(Address(to, 0), value);
 7475     } else {
 7476       BIND(L_fill_byte);
 7477     }
 7478   } else {
 7479     BIND(L_fill_2_bytes);
 7480   }
 7481   BIND(L_exit);
 7482 }
 7483 
 7484 // encode char[] to byte[] in ISO_8859_1
 7485    //@HotSpotIntrinsicCandidate
 7486    //private static int implEncodeISOArray(byte[] sa, int sp,
 7487    //byte[] da, int dp, int len) {
 7488    //  int i = 0;
 7489    //  for (; i &lt; len; i++) {
 7490    //    char c = StringUTF16.getChar(sa, sp++);
 7491    //    if (c &gt; &#39;\u00FF&#39;)
 7492    //      break;
 7493    //    da[dp++] = (byte)c;
 7494    //  }
 7495    //  return i;
 7496    //}
 7497 void MacroAssembler::encode_iso_array(Register src, Register dst, Register len,
 7498   XMMRegister tmp1Reg, XMMRegister tmp2Reg,
 7499   XMMRegister tmp3Reg, XMMRegister tmp4Reg,
 7500   Register tmp5, Register result) {
 7501 
 7502   // rsi: src
 7503   // rdi: dst
 7504   // rdx: len
 7505   // rcx: tmp5
 7506   // rax: result
 7507   ShortBranchVerifier sbv(this);
 7508   assert_different_registers(src, dst, len, tmp5, result);
 7509   Label L_done, L_copy_1_char, L_copy_1_char_exit;
 7510 
 7511   // set result
 7512   xorl(result, result);
 7513   // check for zero length
 7514   testl(len, len);
 7515   jcc(Assembler::zero, L_done);
 7516 
 7517   movl(result, len);
 7518 
 7519   // Setup pointers
 7520   lea(src, Address(src, len, Address::times_2)); // char[]
 7521   lea(dst, Address(dst, len, Address::times_1)); // byte[]
 7522   negptr(len);
 7523 
 7524   if (UseSSE42Intrinsics || UseAVX &gt;= 2) {
 7525     Label L_copy_8_chars, L_copy_8_chars_exit;
 7526     Label L_chars_16_check, L_copy_16_chars, L_copy_16_chars_exit;
 7527 
 7528     if (UseAVX &gt;= 2) {
 7529       Label L_chars_32_check, L_copy_32_chars, L_copy_32_chars_exit;
 7530       movl(tmp5, 0xff00ff00);   // create mask to test for Unicode chars in vector
 7531       movdl(tmp1Reg, tmp5);
 7532       vpbroadcastd(tmp1Reg, tmp1Reg, Assembler::AVX_256bit);
 7533       jmp(L_chars_32_check);
 7534 
 7535       bind(L_copy_32_chars);
 7536       vmovdqu(tmp3Reg, Address(src, len, Address::times_2, -64));
 7537       vmovdqu(tmp4Reg, Address(src, len, Address::times_2, -32));
 7538       vpor(tmp2Reg, tmp3Reg, tmp4Reg, /* vector_len */ 1);
 7539       vptest(tmp2Reg, tmp1Reg);       // check for Unicode chars in  vector
 7540       jccb(Assembler::notZero, L_copy_32_chars_exit);
 7541       vpackuswb(tmp3Reg, tmp3Reg, tmp4Reg, /* vector_len */ 1);
 7542       vpermq(tmp4Reg, tmp3Reg, 0xD8, /* vector_len */ 1);
 7543       vmovdqu(Address(dst, len, Address::times_1, -32), tmp4Reg);
 7544 
 7545       bind(L_chars_32_check);
 7546       addptr(len, 32);
 7547       jcc(Assembler::lessEqual, L_copy_32_chars);
 7548 
 7549       bind(L_copy_32_chars_exit);
 7550       subptr(len, 16);
 7551       jccb(Assembler::greater, L_copy_16_chars_exit);
 7552 
 7553     } else if (UseSSE42Intrinsics) {
 7554       movl(tmp5, 0xff00ff00);   // create mask to test for Unicode chars in vector
 7555       movdl(tmp1Reg, tmp5);
 7556       pshufd(tmp1Reg, tmp1Reg, 0);
 7557       jmpb(L_chars_16_check);
 7558     }
 7559 
 7560     bind(L_copy_16_chars);
 7561     if (UseAVX &gt;= 2) {
 7562       vmovdqu(tmp2Reg, Address(src, len, Address::times_2, -32));
 7563       vptest(tmp2Reg, tmp1Reg);
 7564       jcc(Assembler::notZero, L_copy_16_chars_exit);
 7565       vpackuswb(tmp2Reg, tmp2Reg, tmp1Reg, /* vector_len */ 1);
 7566       vpermq(tmp3Reg, tmp2Reg, 0xD8, /* vector_len */ 1);
 7567     } else {
 7568       if (UseAVX &gt; 0) {
 7569         movdqu(tmp3Reg, Address(src, len, Address::times_2, -32));
 7570         movdqu(tmp4Reg, Address(src, len, Address::times_2, -16));
 7571         vpor(tmp2Reg, tmp3Reg, tmp4Reg, /* vector_len */ 0);
 7572       } else {
 7573         movdqu(tmp3Reg, Address(src, len, Address::times_2, -32));
 7574         por(tmp2Reg, tmp3Reg);
 7575         movdqu(tmp4Reg, Address(src, len, Address::times_2, -16));
 7576         por(tmp2Reg, tmp4Reg);
 7577       }
 7578       ptest(tmp2Reg, tmp1Reg);       // check for Unicode chars in  vector
 7579       jccb(Assembler::notZero, L_copy_16_chars_exit);
 7580       packuswb(tmp3Reg, tmp4Reg);
 7581     }
 7582     movdqu(Address(dst, len, Address::times_1, -16), tmp3Reg);
 7583 
 7584     bind(L_chars_16_check);
 7585     addptr(len, 16);
 7586     jcc(Assembler::lessEqual, L_copy_16_chars);
 7587 
 7588     bind(L_copy_16_chars_exit);
 7589     if (UseAVX &gt;= 2) {
 7590       // clean upper bits of YMM registers
 7591       vpxor(tmp2Reg, tmp2Reg);
 7592       vpxor(tmp3Reg, tmp3Reg);
 7593       vpxor(tmp4Reg, tmp4Reg);
 7594       movdl(tmp1Reg, tmp5);
 7595       pshufd(tmp1Reg, tmp1Reg, 0);
 7596     }
 7597     subptr(len, 8);
 7598     jccb(Assembler::greater, L_copy_8_chars_exit);
 7599 
 7600     bind(L_copy_8_chars);
 7601     movdqu(tmp3Reg, Address(src, len, Address::times_2, -16));
 7602     ptest(tmp3Reg, tmp1Reg);
 7603     jccb(Assembler::notZero, L_copy_8_chars_exit);
 7604     packuswb(tmp3Reg, tmp1Reg);
 7605     movq(Address(dst, len, Address::times_1, -8), tmp3Reg);
 7606     addptr(len, 8);
 7607     jccb(Assembler::lessEqual, L_copy_8_chars);
 7608 
 7609     bind(L_copy_8_chars_exit);
 7610     subptr(len, 8);
 7611     jccb(Assembler::zero, L_done);
 7612   }
 7613 
 7614   bind(L_copy_1_char);
 7615   load_unsigned_short(tmp5, Address(src, len, Address::times_2, 0));
 7616   testl(tmp5, 0xff00);      // check if Unicode char
 7617   jccb(Assembler::notZero, L_copy_1_char_exit);
 7618   movb(Address(dst, len, Address::times_1, 0), tmp5);
 7619   addptr(len, 1);
 7620   jccb(Assembler::less, L_copy_1_char);
 7621 
 7622   bind(L_copy_1_char_exit);
 7623   addptr(result, len); // len is negative count of not processed elements
 7624 
 7625   bind(L_done);
 7626 }
 7627 
 7628 #ifdef _LP64
 7629 /**
 7630  * Helper for multiply_to_len().
 7631  */
 7632 void MacroAssembler::add2_with_carry(Register dest_hi, Register dest_lo, Register src1, Register src2) {
 7633   addq(dest_lo, src1);
 7634   adcq(dest_hi, 0);
 7635   addq(dest_lo, src2);
 7636   adcq(dest_hi, 0);
 7637 }
 7638 
 7639 /**
 7640  * Multiply 64 bit by 64 bit first loop.
 7641  */
 7642 void MacroAssembler::multiply_64_x_64_loop(Register x, Register xstart, Register x_xstart,
 7643                                            Register y, Register y_idx, Register z,
 7644                                            Register carry, Register product,
 7645                                            Register idx, Register kdx) {
 7646   //
 7647   //  jlong carry, x[], y[], z[];
 7648   //  for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx-, kdx--) {
 7649   //    huge_128 product = y[idx] * x[xstart] + carry;
 7650   //    z[kdx] = (jlong)product;
 7651   //    carry  = (jlong)(product &gt;&gt;&gt; 64);
 7652   //  }
 7653   //  z[xstart] = carry;
 7654   //
 7655 
 7656   Label L_first_loop, L_first_loop_exit;
 7657   Label L_one_x, L_one_y, L_multiply;
 7658 
 7659   decrementl(xstart);
 7660   jcc(Assembler::negative, L_one_x);
 7661 
 7662   movq(x_xstart, Address(x, xstart, Address::times_4,  0));
 7663   rorq(x_xstart, 32); // convert big-endian to little-endian
 7664 
 7665   bind(L_first_loop);
 7666   decrementl(idx);
 7667   jcc(Assembler::negative, L_first_loop_exit);
 7668   decrementl(idx);
 7669   jcc(Assembler::negative, L_one_y);
 7670   movq(y_idx, Address(y, idx, Address::times_4,  0));
 7671   rorq(y_idx, 32); // convert big-endian to little-endian
 7672   bind(L_multiply);
 7673   movq(product, x_xstart);
 7674   mulq(y_idx); // product(rax) * y_idx -&gt; rdx:rax
 7675   addq(product, carry);
 7676   adcq(rdx, 0);
 7677   subl(kdx, 2);
 7678   movl(Address(z, kdx, Address::times_4,  4), product);
 7679   shrq(product, 32);
 7680   movl(Address(z, kdx, Address::times_4,  0), product);
 7681   movq(carry, rdx);
 7682   jmp(L_first_loop);
 7683 
 7684   bind(L_one_y);
 7685   movl(y_idx, Address(y,  0));
 7686   jmp(L_multiply);
 7687 
 7688   bind(L_one_x);
 7689   movl(x_xstart, Address(x,  0));
 7690   jmp(L_first_loop);
 7691 
 7692   bind(L_first_loop_exit);
 7693 }
 7694 
 7695 /**
 7696  * Multiply 64 bit by 64 bit and add 128 bit.
 7697  */
 7698 void MacroAssembler::multiply_add_128_x_128(Register x_xstart, Register y, Register z,
 7699                                             Register yz_idx, Register idx,
 7700                                             Register carry, Register product, int offset) {
 7701   //     huge_128 product = (y[idx] * x_xstart) + z[kdx] + carry;
 7702   //     z[kdx] = (jlong)product;
 7703 
 7704   movq(yz_idx, Address(y, idx, Address::times_4,  offset));
 7705   rorq(yz_idx, 32); // convert big-endian to little-endian
 7706   movq(product, x_xstart);
 7707   mulq(yz_idx);     // product(rax) * yz_idx -&gt; rdx:product(rax)
 7708   movq(yz_idx, Address(z, idx, Address::times_4,  offset));
 7709   rorq(yz_idx, 32); // convert big-endian to little-endian
 7710 
 7711   add2_with_carry(rdx, product, carry, yz_idx);
 7712 
 7713   movl(Address(z, idx, Address::times_4,  offset+4), product);
 7714   shrq(product, 32);
 7715   movl(Address(z, idx, Address::times_4,  offset), product);
 7716 
 7717 }
 7718 
 7719 /**
 7720  * Multiply 128 bit by 128 bit. Unrolled inner loop.
 7721  */
 7722 void MacroAssembler::multiply_128_x_128_loop(Register x_xstart, Register y, Register z,
 7723                                              Register yz_idx, Register idx, Register jdx,
 7724                                              Register carry, Register product,
 7725                                              Register carry2) {
 7726   //   jlong carry, x[], y[], z[];
 7727   //   int kdx = ystart+1;
 7728   //   for (int idx=ystart-2; idx &gt;= 0; idx -= 2) { // Third loop
 7729   //     huge_128 product = (y[idx+1] * x_xstart) + z[kdx+idx+1] + carry;
 7730   //     z[kdx+idx+1] = (jlong)product;
 7731   //     jlong carry2  = (jlong)(product &gt;&gt;&gt; 64);
 7732   //     product = (y[idx] * x_xstart) + z[kdx+idx] + carry2;
 7733   //     z[kdx+idx] = (jlong)product;
 7734   //     carry  = (jlong)(product &gt;&gt;&gt; 64);
 7735   //   }
 7736   //   idx += 2;
 7737   //   if (idx &gt; 0) {
 7738   //     product = (y[idx] * x_xstart) + z[kdx+idx] + carry;
 7739   //     z[kdx+idx] = (jlong)product;
 7740   //     carry  = (jlong)(product &gt;&gt;&gt; 64);
 7741   //   }
 7742   //
 7743 
 7744   Label L_third_loop, L_third_loop_exit, L_post_third_loop_done;
 7745 
 7746   movl(jdx, idx);
 7747   andl(jdx, 0xFFFFFFFC);
 7748   shrl(jdx, 2);
 7749 
 7750   bind(L_third_loop);
 7751   subl(jdx, 1);
 7752   jcc(Assembler::negative, L_third_loop_exit);
 7753   subl(idx, 4);
 7754 
 7755   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry, product, 8);
 7756   movq(carry2, rdx);
 7757 
 7758   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry2, product, 0);
 7759   movq(carry, rdx);
 7760   jmp(L_third_loop);
 7761 
 7762   bind (L_third_loop_exit);
 7763 
 7764   andl (idx, 0x3);
 7765   jcc(Assembler::zero, L_post_third_loop_done);
 7766 
 7767   Label L_check_1;
 7768   subl(idx, 2);
 7769   jcc(Assembler::negative, L_check_1);
 7770 
 7771   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry, product, 0);
 7772   movq(carry, rdx);
 7773 
 7774   bind (L_check_1);
 7775   addl (idx, 0x2);
 7776   andl (idx, 0x1);
 7777   subl(idx, 1);
 7778   jcc(Assembler::negative, L_post_third_loop_done);
 7779 
 7780   movl(yz_idx, Address(y, idx, Address::times_4,  0));
 7781   movq(product, x_xstart);
 7782   mulq(yz_idx); // product(rax) * yz_idx -&gt; rdx:product(rax)
 7783   movl(yz_idx, Address(z, idx, Address::times_4,  0));
 7784 
 7785   add2_with_carry(rdx, product, yz_idx, carry);
 7786 
 7787   movl(Address(z, idx, Address::times_4,  0), product);
 7788   shrq(product, 32);
 7789 
 7790   shlq(rdx, 32);
 7791   orq(product, rdx);
 7792   movq(carry, product);
 7793 
 7794   bind(L_post_third_loop_done);
 7795 }
 7796 
 7797 /**
 7798  * Multiply 128 bit by 128 bit using BMI2. Unrolled inner loop.
 7799  *
 7800  */
 7801 void MacroAssembler::multiply_128_x_128_bmi2_loop(Register y, Register z,
 7802                                                   Register carry, Register carry2,
 7803                                                   Register idx, Register jdx,
 7804                                                   Register yz_idx1, Register yz_idx2,
 7805                                                   Register tmp, Register tmp3, Register tmp4) {
 7806   assert(UseBMI2Instructions, &quot;should be used only when BMI2 is available&quot;);
 7807 
 7808   //   jlong carry, x[], y[], z[];
 7809   //   int kdx = ystart+1;
 7810   //   for (int idx=ystart-2; idx &gt;= 0; idx -= 2) { // Third loop
 7811   //     huge_128 tmp3 = (y[idx+1] * rdx) + z[kdx+idx+1] + carry;
 7812   //     jlong carry2  = (jlong)(tmp3 &gt;&gt;&gt; 64);
 7813   //     huge_128 tmp4 = (y[idx]   * rdx) + z[kdx+idx] + carry2;
 7814   //     carry  = (jlong)(tmp4 &gt;&gt;&gt; 64);
 7815   //     z[kdx+idx+1] = (jlong)tmp3;
 7816   //     z[kdx+idx] = (jlong)tmp4;
 7817   //   }
 7818   //   idx += 2;
 7819   //   if (idx &gt; 0) {
 7820   //     yz_idx1 = (y[idx] * rdx) + z[kdx+idx] + carry;
 7821   //     z[kdx+idx] = (jlong)yz_idx1;
 7822   //     carry  = (jlong)(yz_idx1 &gt;&gt;&gt; 64);
 7823   //   }
 7824   //
 7825 
 7826   Label L_third_loop, L_third_loop_exit, L_post_third_loop_done;
 7827 
 7828   movl(jdx, idx);
 7829   andl(jdx, 0xFFFFFFFC);
 7830   shrl(jdx, 2);
 7831 
 7832   bind(L_third_loop);
 7833   subl(jdx, 1);
 7834   jcc(Assembler::negative, L_third_loop_exit);
 7835   subl(idx, 4);
 7836 
 7837   movq(yz_idx1,  Address(y, idx, Address::times_4,  8));
 7838   rorxq(yz_idx1, yz_idx1, 32); // convert big-endian to little-endian
 7839   movq(yz_idx2, Address(y, idx, Address::times_4,  0));
 7840   rorxq(yz_idx2, yz_idx2, 32);
 7841 
 7842   mulxq(tmp4, tmp3, yz_idx1);  //  yz_idx1 * rdx -&gt; tmp4:tmp3
 7843   mulxq(carry2, tmp, yz_idx2); //  yz_idx2 * rdx -&gt; carry2:tmp
 7844 
 7845   movq(yz_idx1,  Address(z, idx, Address::times_4,  8));
 7846   rorxq(yz_idx1, yz_idx1, 32);
 7847   movq(yz_idx2, Address(z, idx, Address::times_4,  0));
 7848   rorxq(yz_idx2, yz_idx2, 32);
 7849 
 7850   if (VM_Version::supports_adx()) {
 7851     adcxq(tmp3, carry);
 7852     adoxq(tmp3, yz_idx1);
 7853 
 7854     adcxq(tmp4, tmp);
 7855     adoxq(tmp4, yz_idx2);
 7856 
 7857     movl(carry, 0); // does not affect flags
 7858     adcxq(carry2, carry);
 7859     adoxq(carry2, carry);
 7860   } else {
 7861     add2_with_carry(tmp4, tmp3, carry, yz_idx1);
 7862     add2_with_carry(carry2, tmp4, tmp, yz_idx2);
 7863   }
 7864   movq(carry, carry2);
 7865 
 7866   movl(Address(z, idx, Address::times_4, 12), tmp3);
 7867   shrq(tmp3, 32);
 7868   movl(Address(z, idx, Address::times_4,  8), tmp3);
 7869 
 7870   movl(Address(z, idx, Address::times_4,  4), tmp4);
 7871   shrq(tmp4, 32);
 7872   movl(Address(z, idx, Address::times_4,  0), tmp4);
 7873 
 7874   jmp(L_third_loop);
 7875 
 7876   bind (L_third_loop_exit);
 7877 
 7878   andl (idx, 0x3);
 7879   jcc(Assembler::zero, L_post_third_loop_done);
 7880 
 7881   Label L_check_1;
 7882   subl(idx, 2);
 7883   jcc(Assembler::negative, L_check_1);
 7884 
 7885   movq(yz_idx1, Address(y, idx, Address::times_4,  0));
 7886   rorxq(yz_idx1, yz_idx1, 32);
 7887   mulxq(tmp4, tmp3, yz_idx1); //  yz_idx1 * rdx -&gt; tmp4:tmp3
 7888   movq(yz_idx2, Address(z, idx, Address::times_4,  0));
 7889   rorxq(yz_idx2, yz_idx2, 32);
 7890 
 7891   add2_with_carry(tmp4, tmp3, carry, yz_idx2);
 7892 
 7893   movl(Address(z, idx, Address::times_4,  4), tmp3);
 7894   shrq(tmp3, 32);
 7895   movl(Address(z, idx, Address::times_4,  0), tmp3);
 7896   movq(carry, tmp4);
 7897 
 7898   bind (L_check_1);
 7899   addl (idx, 0x2);
 7900   andl (idx, 0x1);
 7901   subl(idx, 1);
 7902   jcc(Assembler::negative, L_post_third_loop_done);
 7903   movl(tmp4, Address(y, idx, Address::times_4,  0));
 7904   mulxq(carry2, tmp3, tmp4);  //  tmp4 * rdx -&gt; carry2:tmp3
 7905   movl(tmp4, Address(z, idx, Address::times_4,  0));
 7906 
 7907   add2_with_carry(carry2, tmp3, tmp4, carry);
 7908 
 7909   movl(Address(z, idx, Address::times_4,  0), tmp3);
 7910   shrq(tmp3, 32);
 7911 
 7912   shlq(carry2, 32);
 7913   orq(tmp3, carry2);
 7914   movq(carry, tmp3);
 7915 
 7916   bind(L_post_third_loop_done);
 7917 }
 7918 
 7919 /**
 7920  * Code for BigInteger::multiplyToLen() instrinsic.
 7921  *
 7922  * rdi: x
 7923  * rax: xlen
 7924  * rsi: y
 7925  * rcx: ylen
 7926  * r8:  z
 7927  * r11: zlen
 7928  * r12: tmp1
 7929  * r13: tmp2
 7930  * r14: tmp3
 7931  * r15: tmp4
 7932  * rbx: tmp5
 7933  *
 7934  */
 7935 void MacroAssembler::multiply_to_len(Register x, Register xlen, Register y, Register ylen, Register z, Register zlen,
 7936                                      Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5) {
 7937   ShortBranchVerifier sbv(this);
 7938   assert_different_registers(x, xlen, y, ylen, z, zlen, tmp1, tmp2, tmp3, tmp4, tmp5, rdx);
 7939 
 7940   push(tmp1);
 7941   push(tmp2);
 7942   push(tmp3);
 7943   push(tmp4);
 7944   push(tmp5);
 7945 
 7946   push(xlen);
 7947   push(zlen);
 7948 
 7949   const Register idx = tmp1;
 7950   const Register kdx = tmp2;
 7951   const Register xstart = tmp3;
 7952 
 7953   const Register y_idx = tmp4;
 7954   const Register carry = tmp5;
 7955   const Register product  = xlen;
 7956   const Register x_xstart = zlen;  // reuse register
 7957 
 7958   // First Loop.
 7959   //
 7960   //  final static long LONG_MASK = 0xffffffffL;
 7961   //  int xstart = xlen - 1;
 7962   //  int ystart = ylen - 1;
 7963   //  long carry = 0;
 7964   //  for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx-, kdx--) {
 7965   //    long product = (y[idx] &amp; LONG_MASK) * (x[xstart] &amp; LONG_MASK) + carry;
 7966   //    z[kdx] = (int)product;
 7967   //    carry = product &gt;&gt;&gt; 32;
 7968   //  }
 7969   //  z[xstart] = (int)carry;
 7970   //
 7971 
 7972   movl(idx, ylen);      // idx = ylen;
 7973   movl(kdx, zlen);      // kdx = xlen+ylen;
 7974   xorq(carry, carry);   // carry = 0;
 7975 
 7976   Label L_done;
 7977 
 7978   movl(xstart, xlen);
 7979   decrementl(xstart);
 7980   jcc(Assembler::negative, L_done);
 7981 
 7982   multiply_64_x_64_loop(x, xstart, x_xstart, y, y_idx, z, carry, product, idx, kdx);
 7983 
 7984   Label L_second_loop;
 7985   testl(kdx, kdx);
 7986   jcc(Assembler::zero, L_second_loop);
 7987 
 7988   Label L_carry;
 7989   subl(kdx, 1);
 7990   jcc(Assembler::zero, L_carry);
 7991 
 7992   movl(Address(z, kdx, Address::times_4,  0), carry);
 7993   shrq(carry, 32);
 7994   subl(kdx, 1);
 7995 
 7996   bind(L_carry);
 7997   movl(Address(z, kdx, Address::times_4,  0), carry);
 7998 
 7999   // Second and third (nested) loops.
 8000   //
 8001   // for (int i = xstart-1; i &gt;= 0; i--) { // Second loop
 8002   //   carry = 0;
 8003   //   for (int jdx=ystart, k=ystart+1+i; jdx &gt;= 0; jdx--, k--) { // Third loop
 8004   //     long product = (y[jdx] &amp; LONG_MASK) * (x[i] &amp; LONG_MASK) +
 8005   //                    (z[k] &amp; LONG_MASK) + carry;
 8006   //     z[k] = (int)product;
 8007   //     carry = product &gt;&gt;&gt; 32;
 8008   //   }
 8009   //   z[i] = (int)carry;
 8010   // }
 8011   //
 8012   // i = xlen, j = tmp1, k = tmp2, carry = tmp5, x[i] = rdx
 8013 
 8014   const Register jdx = tmp1;
 8015 
 8016   bind(L_second_loop);
 8017   xorl(carry, carry);    // carry = 0;
 8018   movl(jdx, ylen);       // j = ystart+1
 8019 
 8020   subl(xstart, 1);       // i = xstart-1;
 8021   jcc(Assembler::negative, L_done);
 8022 
 8023   push (z);
 8024 
 8025   Label L_last_x;
 8026   lea(z, Address(z, xstart, Address::times_4, 4)); // z = z + k - j
 8027   subl(xstart, 1);       // i = xstart-1;
 8028   jcc(Assembler::negative, L_last_x);
 8029 
 8030   if (UseBMI2Instructions) {
 8031     movq(rdx,  Address(x, xstart, Address::times_4,  0));
 8032     rorxq(rdx, rdx, 32); // convert big-endian to little-endian
 8033   } else {
 8034     movq(x_xstart, Address(x, xstart, Address::times_4,  0));
 8035     rorq(x_xstart, 32);  // convert big-endian to little-endian
 8036   }
 8037 
 8038   Label L_third_loop_prologue;
 8039   bind(L_third_loop_prologue);
 8040 
 8041   push (x);
 8042   push (xstart);
 8043   push (ylen);
 8044 
 8045 
 8046   if (UseBMI2Instructions) {
 8047     multiply_128_x_128_bmi2_loop(y, z, carry, x, jdx, ylen, product, tmp2, x_xstart, tmp3, tmp4);
 8048   } else { // !UseBMI2Instructions
 8049     multiply_128_x_128_loop(x_xstart, y, z, y_idx, jdx, ylen, carry, product, x);
 8050   }
 8051 
 8052   pop(ylen);
 8053   pop(xlen);
 8054   pop(x);
 8055   pop(z);
 8056 
 8057   movl(tmp3, xlen);
 8058   addl(tmp3, 1);
 8059   movl(Address(z, tmp3, Address::times_4,  0), carry);
 8060   subl(tmp3, 1);
 8061   jccb(Assembler::negative, L_done);
 8062 
 8063   shrq(carry, 32);
 8064   movl(Address(z, tmp3, Address::times_4,  0), carry);
 8065   jmp(L_second_loop);
 8066 
 8067   // Next infrequent code is moved outside loops.
 8068   bind(L_last_x);
 8069   if (UseBMI2Instructions) {
 8070     movl(rdx, Address(x,  0));
 8071   } else {
 8072     movl(x_xstart, Address(x,  0));
 8073   }
 8074   jmp(L_third_loop_prologue);
 8075 
 8076   bind(L_done);
 8077 
 8078   pop(zlen);
 8079   pop(xlen);
 8080 
 8081   pop(tmp5);
 8082   pop(tmp4);
 8083   pop(tmp3);
 8084   pop(tmp2);
 8085   pop(tmp1);
 8086 }
 8087 
 8088 void MacroAssembler::vectorized_mismatch(Register obja, Register objb, Register length, Register log2_array_indxscale,
 8089   Register result, Register tmp1, Register tmp2, XMMRegister rymm0, XMMRegister rymm1, XMMRegister rymm2){
 8090   assert(UseSSE42Intrinsics, &quot;SSE4.2 must be enabled.&quot;);
 8091   Label VECTOR16_LOOP, VECTOR8_LOOP, VECTOR4_LOOP;
 8092   Label VECTOR8_TAIL, VECTOR4_TAIL;
 8093   Label VECTOR32_NOT_EQUAL, VECTOR16_NOT_EQUAL, VECTOR8_NOT_EQUAL, VECTOR4_NOT_EQUAL;
 8094   Label SAME_TILL_END, DONE;
 8095   Label BYTES_LOOP, BYTES_TAIL, BYTES_NOT_EQUAL;
 8096 
 8097   //scale is in rcx in both Win64 and Unix
 8098   ShortBranchVerifier sbv(this);
 8099 
 8100   shlq(length);
 8101   xorq(result, result);
 8102 
 8103   if ((AVX3Threshold == 0) &amp;&amp; (UseAVX &gt; 2) &amp;&amp;
 8104       VM_Version::supports_avx512vlbw()) {
 8105     Label VECTOR64_LOOP, VECTOR64_NOT_EQUAL, VECTOR32_TAIL;
 8106 
 8107     cmpq(length, 64);
 8108     jcc(Assembler::less, VECTOR32_TAIL);
 8109 
 8110     movq(tmp1, length);
 8111     andq(tmp1, 0x3F);      // tail count
 8112     andq(length, ~(0x3F)); //vector count
 8113 
 8114     bind(VECTOR64_LOOP);
 8115     // AVX512 code to compare 64 byte vectors.
 8116     evmovdqub(rymm0, Address(obja, result), Assembler::AVX_512bit);
 8117     evpcmpeqb(k7, rymm0, Address(objb, result), Assembler::AVX_512bit);
 8118     kortestql(k7, k7);
 8119     jcc(Assembler::aboveEqual, VECTOR64_NOT_EQUAL);     // mismatch
 8120     addq(result, 64);
 8121     subq(length, 64);
 8122     jccb(Assembler::notZero, VECTOR64_LOOP);
 8123 
 8124     //bind(VECTOR64_TAIL);
 8125     testq(tmp1, tmp1);
 8126     jcc(Assembler::zero, SAME_TILL_END);
 8127 
 8128     //bind(VECTOR64_TAIL);
 8129     // AVX512 code to compare upto 63 byte vectors.
 8130     mov64(tmp2, 0xFFFFFFFFFFFFFFFF);
 8131     shlxq(tmp2, tmp2, tmp1);
 8132     notq(tmp2);
 8133     kmovql(k3, tmp2);
 8134 
 8135     evmovdqub(rymm0, k3, Address(obja, result), Assembler::AVX_512bit);
 8136     evpcmpeqb(k7, k3, rymm0, Address(objb, result), Assembler::AVX_512bit);
 8137 
 8138     ktestql(k7, k3);
 8139     jcc(Assembler::below, SAME_TILL_END);     // not mismatch
 8140 
 8141     bind(VECTOR64_NOT_EQUAL);
 8142     kmovql(tmp1, k7);
 8143     notq(tmp1);
 8144     tzcntq(tmp1, tmp1);
 8145     addq(result, tmp1);
 8146     shrq(result);
 8147     jmp(DONE);
 8148     bind(VECTOR32_TAIL);
 8149   }
 8150 
 8151   cmpq(length, 8);
 8152   jcc(Assembler::equal, VECTOR8_LOOP);
 8153   jcc(Assembler::less, VECTOR4_TAIL);
 8154 
 8155   if (UseAVX &gt;= 2) {
 8156     Label VECTOR16_TAIL, VECTOR32_LOOP;
 8157 
 8158     cmpq(length, 16);
 8159     jcc(Assembler::equal, VECTOR16_LOOP);
 8160     jcc(Assembler::less, VECTOR8_LOOP);
 8161 
 8162     cmpq(length, 32);
 8163     jccb(Assembler::less, VECTOR16_TAIL);
 8164 
 8165     subq(length, 32);
 8166     bind(VECTOR32_LOOP);
 8167     vmovdqu(rymm0, Address(obja, result));
 8168     vmovdqu(rymm1, Address(objb, result));
 8169     vpxor(rymm2, rymm0, rymm1, Assembler::AVX_256bit);
 8170     vptest(rymm2, rymm2);
 8171     jcc(Assembler::notZero, VECTOR32_NOT_EQUAL);//mismatch found
 8172     addq(result, 32);
 8173     subq(length, 32);
 8174     jcc(Assembler::greaterEqual, VECTOR32_LOOP);
 8175     addq(length, 32);
 8176     jcc(Assembler::equal, SAME_TILL_END);
 8177     //falling through if less than 32 bytes left //close the branch here.
 8178 
 8179     bind(VECTOR16_TAIL);
 8180     cmpq(length, 16);
 8181     jccb(Assembler::less, VECTOR8_TAIL);
 8182     bind(VECTOR16_LOOP);
 8183     movdqu(rymm0, Address(obja, result));
 8184     movdqu(rymm1, Address(objb, result));
 8185     vpxor(rymm2, rymm0, rymm1, Assembler::AVX_128bit);
 8186     ptest(rymm2, rymm2);
 8187     jcc(Assembler::notZero, VECTOR16_NOT_EQUAL);//mismatch found
 8188     addq(result, 16);
 8189     subq(length, 16);
 8190     jcc(Assembler::equal, SAME_TILL_END);
 8191     //falling through if less than 16 bytes left
 8192   } else {//regular intrinsics
 8193 
 8194     cmpq(length, 16);
 8195     jccb(Assembler::less, VECTOR8_TAIL);
 8196 
 8197     subq(length, 16);
 8198     bind(VECTOR16_LOOP);
 8199     movdqu(rymm0, Address(obja, result));
 8200     movdqu(rymm1, Address(objb, result));
 8201     pxor(rymm0, rymm1);
 8202     ptest(rymm0, rymm0);
 8203     jcc(Assembler::notZero, VECTOR16_NOT_EQUAL);//mismatch found
 8204     addq(result, 16);
 8205     subq(length, 16);
 8206     jccb(Assembler::greaterEqual, VECTOR16_LOOP);
 8207     addq(length, 16);
 8208     jcc(Assembler::equal, SAME_TILL_END);
 8209     //falling through if less than 16 bytes left
 8210   }
 8211 
 8212   bind(VECTOR8_TAIL);
 8213   cmpq(length, 8);
 8214   jccb(Assembler::less, VECTOR4_TAIL);
 8215   bind(VECTOR8_LOOP);
 8216   movq(tmp1, Address(obja, result));
 8217   movq(tmp2, Address(objb, result));
 8218   xorq(tmp1, tmp2);
 8219   testq(tmp1, tmp1);
 8220   jcc(Assembler::notZero, VECTOR8_NOT_EQUAL);//mismatch found
 8221   addq(result, 8);
 8222   subq(length, 8);
 8223   jcc(Assembler::equal, SAME_TILL_END);
 8224   //falling through if less than 8 bytes left
 8225 
 8226   bind(VECTOR4_TAIL);
 8227   cmpq(length, 4);
 8228   jccb(Assembler::less, BYTES_TAIL);
 8229   bind(VECTOR4_LOOP);
 8230   movl(tmp1, Address(obja, result));
 8231   xorl(tmp1, Address(objb, result));
 8232   testl(tmp1, tmp1);
 8233   jcc(Assembler::notZero, VECTOR4_NOT_EQUAL);//mismatch found
 8234   addq(result, 4);
 8235   subq(length, 4);
 8236   jcc(Assembler::equal, SAME_TILL_END);
 8237   //falling through if less than 4 bytes left
 8238 
 8239   bind(BYTES_TAIL);
 8240   bind(BYTES_LOOP);
 8241   load_unsigned_byte(tmp1, Address(obja, result));
 8242   load_unsigned_byte(tmp2, Address(objb, result));
 8243   xorl(tmp1, tmp2);
 8244   testl(tmp1, tmp1);
 8245   jcc(Assembler::notZero, BYTES_NOT_EQUAL);//mismatch found
 8246   decq(length);
 8247   jcc(Assembler::zero, SAME_TILL_END);
 8248   incq(result);
 8249   load_unsigned_byte(tmp1, Address(obja, result));
 8250   load_unsigned_byte(tmp2, Address(objb, result));
 8251   xorl(tmp1, tmp2);
 8252   testl(tmp1, tmp1);
 8253   jcc(Assembler::notZero, BYTES_NOT_EQUAL);//mismatch found
 8254   decq(length);
 8255   jcc(Assembler::zero, SAME_TILL_END);
 8256   incq(result);
 8257   load_unsigned_byte(tmp1, Address(obja, result));
 8258   load_unsigned_byte(tmp2, Address(objb, result));
 8259   xorl(tmp1, tmp2);
 8260   testl(tmp1, tmp1);
 8261   jcc(Assembler::notZero, BYTES_NOT_EQUAL);//mismatch found
 8262   jmp(SAME_TILL_END);
 8263 
 8264   if (UseAVX &gt;= 2) {
 8265     bind(VECTOR32_NOT_EQUAL);
 8266     vpcmpeqb(rymm2, rymm2, rymm2, Assembler::AVX_256bit);
 8267     vpcmpeqb(rymm0, rymm0, rymm1, Assembler::AVX_256bit);
 8268     vpxor(rymm0, rymm0, rymm2, Assembler::AVX_256bit);
 8269     vpmovmskb(tmp1, rymm0);
 8270     bsfq(tmp1, tmp1);
 8271     addq(result, tmp1);
 8272     shrq(result);
 8273     jmp(DONE);
 8274   }
 8275 
 8276   bind(VECTOR16_NOT_EQUAL);
 8277   if (UseAVX &gt;= 2) {
 8278     vpcmpeqb(rymm2, rymm2, rymm2, Assembler::AVX_128bit);
 8279     vpcmpeqb(rymm0, rymm0, rymm1, Assembler::AVX_128bit);
 8280     pxor(rymm0, rymm2);
 8281   } else {
 8282     pcmpeqb(rymm2, rymm2);
 8283     pxor(rymm0, rymm1);
 8284     pcmpeqb(rymm0, rymm1);
 8285     pxor(rymm0, rymm2);
 8286   }
 8287   pmovmskb(tmp1, rymm0);
 8288   bsfq(tmp1, tmp1);
 8289   addq(result, tmp1);
 8290   shrq(result);
 8291   jmpb(DONE);
 8292 
 8293   bind(VECTOR8_NOT_EQUAL);
 8294   bind(VECTOR4_NOT_EQUAL);
 8295   bsfq(tmp1, tmp1);
 8296   shrq(tmp1, 3);
 8297   addq(result, tmp1);
 8298   bind(BYTES_NOT_EQUAL);
 8299   shrq(result);
 8300   jmpb(DONE);
 8301 
 8302   bind(SAME_TILL_END);
 8303   mov64(result, -1);
 8304 
 8305   bind(DONE);
 8306 }
 8307 
 8308 //Helper functions for square_to_len()
 8309 
 8310 /**
 8311  * Store the squares of x[], right shifted one bit (divided by 2) into z[]
 8312  * Preserves x and z and modifies rest of the registers.
 8313  */
 8314 void MacroAssembler::square_rshift(Register x, Register xlen, Register z, Register tmp1, Register tmp3, Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
 8315   // Perform square and right shift by 1
 8316   // Handle odd xlen case first, then for even xlen do the following
 8317   // jlong carry = 0;
 8318   // for (int j=0, i=0; j &lt; xlen; j+=2, i+=4) {
 8319   //     huge_128 product = x[j:j+1] * x[j:j+1];
 8320   //     z[i:i+1] = (carry &lt;&lt; 63) | (jlong)(product &gt;&gt;&gt; 65);
 8321   //     z[i+2:i+3] = (jlong)(product &gt;&gt;&gt; 1);
 8322   //     carry = (jlong)product;
 8323   // }
 8324 
 8325   xorq(tmp5, tmp5);     // carry
 8326   xorq(rdxReg, rdxReg);
 8327   xorl(tmp1, tmp1);     // index for x
 8328   xorl(tmp4, tmp4);     // index for z
 8329 
 8330   Label L_first_loop, L_first_loop_exit;
 8331 
 8332   testl(xlen, 1);
 8333   jccb(Assembler::zero, L_first_loop); //jump if xlen is even
 8334 
 8335   // Square and right shift by 1 the odd element using 32 bit multiply
 8336   movl(raxReg, Address(x, tmp1, Address::times_4, 0));
 8337   imulq(raxReg, raxReg);
 8338   shrq(raxReg, 1);
 8339   adcq(tmp5, 0);
 8340   movq(Address(z, tmp4, Address::times_4, 0), raxReg);
 8341   incrementl(tmp1);
 8342   addl(tmp4, 2);
 8343 
 8344   // Square and  right shift by 1 the rest using 64 bit multiply
 8345   bind(L_first_loop);
 8346   cmpptr(tmp1, xlen);
 8347   jccb(Assembler::equal, L_first_loop_exit);
 8348 
 8349   // Square
 8350   movq(raxReg, Address(x, tmp1, Address::times_4,  0));
 8351   rorq(raxReg, 32);    // convert big-endian to little-endian
 8352   mulq(raxReg);        // 64-bit multiply rax * rax -&gt; rdx:rax
 8353 
 8354   // Right shift by 1 and save carry
 8355   shrq(tmp5, 1);       // rdx:rax:tmp5 = (tmp5:rdx:rax) &gt;&gt;&gt; 1
 8356   rcrq(rdxReg, 1);
 8357   rcrq(raxReg, 1);
 8358   adcq(tmp5, 0);
 8359 
 8360   // Store result in z
 8361   movq(Address(z, tmp4, Address::times_4, 0), rdxReg);
 8362   movq(Address(z, tmp4, Address::times_4, 8), raxReg);
 8363 
 8364   // Update indices for x and z
 8365   addl(tmp1, 2);
 8366   addl(tmp4, 4);
 8367   jmp(L_first_loop);
 8368 
 8369   bind(L_first_loop_exit);
 8370 }
 8371 
 8372 
 8373 /**
 8374  * Perform the following multiply add operation using BMI2 instructions
 8375  * carry:sum = sum + op1*op2 + carry
 8376  * op2 should be in rdx
 8377  * op2 is preserved, all other registers are modified
 8378  */
 8379 void MacroAssembler::multiply_add_64_bmi2(Register sum, Register op1, Register op2, Register carry, Register tmp2) {
 8380   // assert op2 is rdx
 8381   mulxq(tmp2, op1, op1);  //  op1 * op2 -&gt; tmp2:op1
 8382   addq(sum, carry);
 8383   adcq(tmp2, 0);
 8384   addq(sum, op1);
 8385   adcq(tmp2, 0);
 8386   movq(carry, tmp2);
 8387 }
 8388 
 8389 /**
 8390  * Perform the following multiply add operation:
 8391  * carry:sum = sum + op1*op2 + carry
 8392  * Preserves op1, op2 and modifies rest of registers
 8393  */
 8394 void MacroAssembler::multiply_add_64(Register sum, Register op1, Register op2, Register carry, Register rdxReg, Register raxReg) {
 8395   // rdx:rax = op1 * op2
 8396   movq(raxReg, op2);
 8397   mulq(op1);
 8398 
 8399   //  rdx:rax = sum + carry + rdx:rax
 8400   addq(sum, carry);
 8401   adcq(rdxReg, 0);
 8402   addq(sum, raxReg);
 8403   adcq(rdxReg, 0);
 8404 
 8405   // carry:sum = rdx:sum
 8406   movq(carry, rdxReg);
 8407 }
 8408 
 8409 /**
 8410  * Add 64 bit long carry into z[] with carry propogation.
 8411  * Preserves z and carry register values and modifies rest of registers.
 8412  *
 8413  */
 8414 void MacroAssembler::add_one_64(Register z, Register zlen, Register carry, Register tmp1) {
 8415   Label L_fourth_loop, L_fourth_loop_exit;
 8416 
 8417   movl(tmp1, 1);
 8418   subl(zlen, 2);
 8419   addq(Address(z, zlen, Address::times_4, 0), carry);
 8420 
 8421   bind(L_fourth_loop);
 8422   jccb(Assembler::carryClear, L_fourth_loop_exit);
 8423   subl(zlen, 2);
 8424   jccb(Assembler::negative, L_fourth_loop_exit);
 8425   addq(Address(z, zlen, Address::times_4, 0), tmp1);
 8426   jmp(L_fourth_loop);
 8427   bind(L_fourth_loop_exit);
 8428 }
 8429 
 8430 /**
 8431  * Shift z[] left by 1 bit.
 8432  * Preserves x, len, z and zlen registers and modifies rest of the registers.
 8433  *
 8434  */
 8435 void MacroAssembler::lshift_by_1(Register x, Register len, Register z, Register zlen, Register tmp1, Register tmp2, Register tmp3, Register tmp4) {
 8436 
 8437   Label L_fifth_loop, L_fifth_loop_exit;
 8438 
 8439   // Fifth loop
 8440   // Perform primitiveLeftShift(z, zlen, 1)
 8441 
 8442   const Register prev_carry = tmp1;
 8443   const Register new_carry = tmp4;
 8444   const Register value = tmp2;
 8445   const Register zidx = tmp3;
 8446 
 8447   // int zidx, carry;
 8448   // long value;
 8449   // carry = 0;
 8450   // for (zidx = zlen-2; zidx &gt;=0; zidx -= 2) {
 8451   //    (carry:value)  = (z[i] &lt;&lt; 1) | carry ;
 8452   //    z[i] = value;
 8453   // }
 8454 
 8455   movl(zidx, zlen);
 8456   xorl(prev_carry, prev_carry); // clear carry flag and prev_carry register
 8457 
 8458   bind(L_fifth_loop);
 8459   decl(zidx);  // Use decl to preserve carry flag
 8460   decl(zidx);
 8461   jccb(Assembler::negative, L_fifth_loop_exit);
 8462 
 8463   if (UseBMI2Instructions) {
 8464      movq(value, Address(z, zidx, Address::times_4, 0));
 8465      rclq(value, 1);
 8466      rorxq(value, value, 32);
 8467      movq(Address(z, zidx, Address::times_4,  0), value);  // Store back in big endian form
 8468   }
 8469   else {
 8470     // clear new_carry
 8471     xorl(new_carry, new_carry);
 8472 
 8473     // Shift z[i] by 1, or in previous carry and save new carry
 8474     movq(value, Address(z, zidx, Address::times_4, 0));
 8475     shlq(value, 1);
 8476     adcl(new_carry, 0);
 8477 
 8478     orq(value, prev_carry);
 8479     rorq(value, 0x20);
 8480     movq(Address(z, zidx, Address::times_4,  0), value);  // Store back in big endian form
 8481 
 8482     // Set previous carry = new carry
 8483     movl(prev_carry, new_carry);
 8484   }
 8485   jmp(L_fifth_loop);
 8486 
 8487   bind(L_fifth_loop_exit);
 8488 }
 8489 
 8490 
 8491 /**
 8492  * Code for BigInteger::squareToLen() intrinsic
 8493  *
 8494  * rdi: x
 8495  * rsi: len
 8496  * r8:  z
 8497  * rcx: zlen
 8498  * r12: tmp1
 8499  * r13: tmp2
 8500  * r14: tmp3
 8501  * r15: tmp4
 8502  * rbx: tmp5
 8503  *
 8504  */
 8505 void MacroAssembler::square_to_len(Register x, Register len, Register z, Register zlen, Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
 8506 
 8507   Label L_second_loop, L_second_loop_exit, L_third_loop, L_third_loop_exit, L_last_x, L_multiply;
 8508   push(tmp1);
 8509   push(tmp2);
 8510   push(tmp3);
 8511   push(tmp4);
 8512   push(tmp5);
 8513 
 8514   // First loop
 8515   // Store the squares, right shifted one bit (i.e., divided by 2).
 8516   square_rshift(x, len, z, tmp1, tmp3, tmp4, tmp5, rdxReg, raxReg);
 8517 
 8518   // Add in off-diagonal sums.
 8519   //
 8520   // Second, third (nested) and fourth loops.
 8521   // zlen +=2;
 8522   // for (int xidx=len-2,zidx=zlen-4; xidx &gt; 0; xidx-=2,zidx-=4) {
 8523   //    carry = 0;
 8524   //    long op2 = x[xidx:xidx+1];
 8525   //    for (int j=xidx-2,k=zidx; j &gt;= 0; j-=2) {
 8526   //       k -= 2;
 8527   //       long op1 = x[j:j+1];
 8528   //       long sum = z[k:k+1];
 8529   //       carry:sum = multiply_add_64(sum, op1, op2, carry, tmp_regs);
 8530   //       z[k:k+1] = sum;
 8531   //    }
 8532   //    add_one_64(z, k, carry, tmp_regs);
 8533   // }
 8534 
 8535   const Register carry = tmp5;
 8536   const Register sum = tmp3;
 8537   const Register op1 = tmp4;
 8538   Register op2 = tmp2;
 8539 
 8540   push(zlen);
 8541   push(len);
 8542   addl(zlen,2);
 8543   bind(L_second_loop);
 8544   xorq(carry, carry);
 8545   subl(zlen, 4);
 8546   subl(len, 2);
 8547   push(zlen);
 8548   push(len);
 8549   cmpl(len, 0);
 8550   jccb(Assembler::lessEqual, L_second_loop_exit);
 8551 
 8552   // Multiply an array by one 64 bit long.
 8553   if (UseBMI2Instructions) {
 8554     op2 = rdxReg;
 8555     movq(op2, Address(x, len, Address::times_4,  0));
 8556     rorxq(op2, op2, 32);
 8557   }
 8558   else {
 8559     movq(op2, Address(x, len, Address::times_4,  0));
 8560     rorq(op2, 32);
 8561   }
 8562 
 8563   bind(L_third_loop);
 8564   decrementl(len);
 8565   jccb(Assembler::negative, L_third_loop_exit);
 8566   decrementl(len);
 8567   jccb(Assembler::negative, L_last_x);
 8568 
 8569   movq(op1, Address(x, len, Address::times_4,  0));
 8570   rorq(op1, 32);
 8571 
 8572   bind(L_multiply);
 8573   subl(zlen, 2);
 8574   movq(sum, Address(z, zlen, Address::times_4,  0));
 8575 
 8576   // Multiply 64 bit by 64 bit and add 64 bits lower half and upper 64 bits as carry.
 8577   if (UseBMI2Instructions) {
 8578     multiply_add_64_bmi2(sum, op1, op2, carry, tmp2);
 8579   }
 8580   else {
 8581     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
 8582   }
 8583 
 8584   movq(Address(z, zlen, Address::times_4, 0), sum);
 8585 
 8586   jmp(L_third_loop);
 8587   bind(L_third_loop_exit);
 8588 
 8589   // Fourth loop
 8590   // Add 64 bit long carry into z with carry propogation.
 8591   // Uses offsetted zlen.
 8592   add_one_64(z, zlen, carry, tmp1);
 8593 
 8594   pop(len);
 8595   pop(zlen);
 8596   jmp(L_second_loop);
 8597 
 8598   // Next infrequent code is moved outside loops.
 8599   bind(L_last_x);
 8600   movl(op1, Address(x, 0));
 8601   jmp(L_multiply);
 8602 
 8603   bind(L_second_loop_exit);
 8604   pop(len);
 8605   pop(zlen);
 8606   pop(len);
 8607   pop(zlen);
 8608 
 8609   // Fifth loop
 8610   // Shift z left 1 bit.
 8611   lshift_by_1(x, len, z, zlen, tmp1, tmp2, tmp3, tmp4);
 8612 
 8613   // z[zlen-1] |= x[len-1] &amp; 1;
 8614   movl(tmp3, Address(x, len, Address::times_4, -4));
 8615   andl(tmp3, 1);
 8616   orl(Address(z, zlen, Address::times_4,  -4), tmp3);
 8617 
 8618   pop(tmp5);
 8619   pop(tmp4);
 8620   pop(tmp3);
 8621   pop(tmp2);
 8622   pop(tmp1);
 8623 }
 8624 
 8625 /**
 8626  * Helper function for mul_add()
 8627  * Multiply the in[] by int k and add to out[] starting at offset offs using
 8628  * 128 bit by 32 bit multiply and return the carry in tmp5.
 8629  * Only quad int aligned length of in[] is operated on in this function.
 8630  * k is in rdxReg for BMI2Instructions, for others it is in tmp2.
 8631  * This function preserves out, in and k registers.
 8632  * len and offset point to the appropriate index in &quot;in&quot; &amp; &quot;out&quot; correspondingly
 8633  * tmp5 has the carry.
 8634  * other registers are temporary and are modified.
 8635  *
 8636  */
 8637 void MacroAssembler::mul_add_128_x_32_loop(Register out, Register in,
 8638   Register offset, Register len, Register tmp1, Register tmp2, Register tmp3,
 8639   Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
 8640 
 8641   Label L_first_loop, L_first_loop_exit;
 8642 
 8643   movl(tmp1, len);
 8644   shrl(tmp1, 2);
 8645 
 8646   bind(L_first_loop);
 8647   subl(tmp1, 1);
 8648   jccb(Assembler::negative, L_first_loop_exit);
 8649 
 8650   subl(len, 4);
 8651   subl(offset, 4);
 8652 
 8653   Register op2 = tmp2;
 8654   const Register sum = tmp3;
 8655   const Register op1 = tmp4;
 8656   const Register carry = tmp5;
 8657 
 8658   if (UseBMI2Instructions) {
 8659     op2 = rdxReg;
 8660   }
 8661 
 8662   movq(op1, Address(in, len, Address::times_4,  8));
 8663   rorq(op1, 32);
 8664   movq(sum, Address(out, offset, Address::times_4,  8));
 8665   rorq(sum, 32);
 8666   if (UseBMI2Instructions) {
 8667     multiply_add_64_bmi2(sum, op1, op2, carry, raxReg);
 8668   }
 8669   else {
 8670     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
 8671   }
 8672   // Store back in big endian from little endian
 8673   rorq(sum, 0x20);
 8674   movq(Address(out, offset, Address::times_4,  8), sum);
 8675 
 8676   movq(op1, Address(in, len, Address::times_4,  0));
 8677   rorq(op1, 32);
 8678   movq(sum, Address(out, offset, Address::times_4,  0));
 8679   rorq(sum, 32);
 8680   if (UseBMI2Instructions) {
 8681     multiply_add_64_bmi2(sum, op1, op2, carry, raxReg);
 8682   }
 8683   else {
 8684     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
 8685   }
 8686   // Store back in big endian from little endian
 8687   rorq(sum, 0x20);
 8688   movq(Address(out, offset, Address::times_4,  0), sum);
 8689 
 8690   jmp(L_first_loop);
 8691   bind(L_first_loop_exit);
 8692 }
 8693 
 8694 /**
 8695  * Code for BigInteger::mulAdd() intrinsic
 8696  *
 8697  * rdi: out
 8698  * rsi: in
 8699  * r11: offs (out.length - offset)
 8700  * rcx: len
 8701  * r8:  k
 8702  * r12: tmp1
 8703  * r13: tmp2
 8704  * r14: tmp3
 8705  * r15: tmp4
 8706  * rbx: tmp5
 8707  * Multiply the in[] by word k and add to out[], return the carry in rax
 8708  */
 8709 void MacroAssembler::mul_add(Register out, Register in, Register offs,
 8710    Register len, Register k, Register tmp1, Register tmp2, Register tmp3,
 8711    Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
 8712 
 8713   Label L_carry, L_last_in, L_done;
 8714 
 8715 // carry = 0;
 8716 // for (int j=len-1; j &gt;= 0; j--) {
 8717 //    long product = (in[j] &amp; LONG_MASK) * kLong +
 8718 //                   (out[offs] &amp; LONG_MASK) + carry;
 8719 //    out[offs--] = (int)product;
 8720 //    carry = product &gt;&gt;&gt; 32;
 8721 // }
 8722 //
 8723   push(tmp1);
 8724   push(tmp2);
 8725   push(tmp3);
 8726   push(tmp4);
 8727   push(tmp5);
 8728 
 8729   Register op2 = tmp2;
 8730   const Register sum = tmp3;
 8731   const Register op1 = tmp4;
 8732   const Register carry =  tmp5;
 8733 
 8734   if (UseBMI2Instructions) {
 8735     op2 = rdxReg;
 8736     movl(op2, k);
 8737   }
 8738   else {
 8739     movl(op2, k);
 8740   }
 8741 
 8742   xorq(carry, carry);
 8743 
 8744   //First loop
 8745 
 8746   //Multiply in[] by k in a 4 way unrolled loop using 128 bit by 32 bit multiply
 8747   //The carry is in tmp5
 8748   mul_add_128_x_32_loop(out, in, offs, len, tmp1, tmp2, tmp3, tmp4, tmp5, rdxReg, raxReg);
 8749 
 8750   //Multiply the trailing in[] entry using 64 bit by 32 bit, if any
 8751   decrementl(len);
 8752   jccb(Assembler::negative, L_carry);
 8753   decrementl(len);
 8754   jccb(Assembler::negative, L_last_in);
 8755 
 8756   movq(op1, Address(in, len, Address::times_4,  0));
 8757   rorq(op1, 32);
 8758 
 8759   subl(offs, 2);
 8760   movq(sum, Address(out, offs, Address::times_4,  0));
 8761   rorq(sum, 32);
 8762 
 8763   if (UseBMI2Instructions) {
 8764     multiply_add_64_bmi2(sum, op1, op2, carry, raxReg);
 8765   }
 8766   else {
 8767     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
 8768   }
 8769 
 8770   // Store back in big endian from little endian
 8771   rorq(sum, 0x20);
 8772   movq(Address(out, offs, Address::times_4,  0), sum);
 8773 
 8774   testl(len, len);
 8775   jccb(Assembler::zero, L_carry);
 8776 
 8777   //Multiply the last in[] entry, if any
 8778   bind(L_last_in);
 8779   movl(op1, Address(in, 0));
 8780   movl(sum, Address(out, offs, Address::times_4,  -4));
 8781 
 8782   movl(raxReg, k);
 8783   mull(op1); //tmp4 * eax -&gt; edx:eax
 8784   addl(sum, carry);
 8785   adcl(rdxReg, 0);
 8786   addl(sum, raxReg);
 8787   adcl(rdxReg, 0);
 8788   movl(carry, rdxReg);
 8789 
 8790   movl(Address(out, offs, Address::times_4,  -4), sum);
 8791 
 8792   bind(L_carry);
 8793   //return tmp5/carry as carry in rax
 8794   movl(rax, carry);
 8795 
 8796   bind(L_done);
 8797   pop(tmp5);
 8798   pop(tmp4);
 8799   pop(tmp3);
 8800   pop(tmp2);
 8801   pop(tmp1);
 8802 }
 8803 #endif
 8804 
 8805 /**
 8806  * Emits code to update CRC-32 with a byte value according to constants in table
 8807  *
 8808  * @param [in,out]crc   Register containing the crc.
 8809  * @param [in]val       Register containing the byte to fold into the CRC.
 8810  * @param [in]table     Register containing the table of crc constants.
 8811  *
 8812  * uint32_t crc;
 8813  * val = crc_table[(val ^ crc) &amp; 0xFF];
 8814  * crc = val ^ (crc &gt;&gt; 8);
 8815  *
 8816  */
 8817 void MacroAssembler::update_byte_crc32(Register crc, Register val, Register table) {
 8818   xorl(val, crc);
 8819   andl(val, 0xFF);
 8820   shrl(crc, 8); // unsigned shift
 8821   xorl(crc, Address(table, val, Address::times_4, 0));
 8822 }
 8823 
 8824 /**
 8825 * Fold four 128-bit data chunks
 8826 */
 8827 void MacroAssembler::fold_128bit_crc32_avx512(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset) {
 8828   evpclmulhdq(xtmp, xK, xcrc, Assembler::AVX_512bit); // [123:64]
 8829   evpclmulldq(xcrc, xK, xcrc, Assembler::AVX_512bit); // [63:0]
 8830   evpxorq(xcrc, xcrc, Address(buf, offset), Assembler::AVX_512bit /* vector_len */);
 8831   evpxorq(xcrc, xcrc, xtmp, Assembler::AVX_512bit /* vector_len */);
 8832 }
 8833 
 8834 /**
 8835  * Fold 128-bit data chunk
 8836  */
 8837 void MacroAssembler::fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset) {
 8838   if (UseAVX &gt; 0) {
 8839     vpclmulhdq(xtmp, xK, xcrc); // [123:64]
 8840     vpclmulldq(xcrc, xK, xcrc); // [63:0]
 8841     vpxor(xcrc, xcrc, Address(buf, offset), 0 /* vector_len */);
 8842     pxor(xcrc, xtmp);
 8843   } else {
 8844     movdqa(xtmp, xcrc);
 8845     pclmulhdq(xtmp, xK);   // [123:64]
 8846     pclmulldq(xcrc, xK);   // [63:0]
 8847     pxor(xcrc, xtmp);
 8848     movdqu(xtmp, Address(buf, offset));
 8849     pxor(xcrc, xtmp);
 8850   }
 8851 }
 8852 
 8853 void MacroAssembler::fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, XMMRegister xbuf) {
 8854   if (UseAVX &gt; 0) {
 8855     vpclmulhdq(xtmp, xK, xcrc);
 8856     vpclmulldq(xcrc, xK, xcrc);
 8857     pxor(xcrc, xbuf);
 8858     pxor(xcrc, xtmp);
 8859   } else {
 8860     movdqa(xtmp, xcrc);
 8861     pclmulhdq(xtmp, xK);
 8862     pclmulldq(xcrc, xK);
 8863     pxor(xcrc, xbuf);
 8864     pxor(xcrc, xtmp);
 8865   }
 8866 }
 8867 
 8868 /**
 8869  * 8-bit folds to compute 32-bit CRC
 8870  *
 8871  * uint64_t xcrc;
 8872  * timesXtoThe32[xcrc &amp; 0xFF] ^ (xcrc &gt;&gt; 8);
 8873  */
 8874 void MacroAssembler::fold_8bit_crc32(XMMRegister xcrc, Register table, XMMRegister xtmp, Register tmp) {
 8875   movdl(tmp, xcrc);
 8876   andl(tmp, 0xFF);
 8877   movdl(xtmp, Address(table, tmp, Address::times_4, 0));
 8878   psrldq(xcrc, 1); // unsigned shift one byte
 8879   pxor(xcrc, xtmp);
 8880 }
 8881 
 8882 /**
 8883  * uint32_t crc;
 8884  * timesXtoThe32[crc &amp; 0xFF] ^ (crc &gt;&gt; 8);
 8885  */
 8886 void MacroAssembler::fold_8bit_crc32(Register crc, Register table, Register tmp) {
 8887   movl(tmp, crc);
 8888   andl(tmp, 0xFF);
 8889   shrl(crc, 8);
 8890   xorl(crc, Address(table, tmp, Address::times_4, 0));
 8891 }
 8892 
 8893 /**
 8894  * @param crc   register containing existing CRC (32-bit)
 8895  * @param buf   register pointing to input byte buffer (byte*)
 8896  * @param len   register containing number of bytes
 8897  * @param table register that will contain address of CRC table
 8898  * @param tmp   scratch register
 8899  */
 8900 void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len, Register table, Register tmp) {
 8901   assert_different_registers(crc, buf, len, table, tmp, rax);
 8902 
 8903   Label L_tail, L_tail_restore, L_tail_loop, L_exit, L_align_loop, L_aligned;
 8904   Label L_fold_tail, L_fold_128b, L_fold_512b, L_fold_512b_loop, L_fold_tail_loop;
 8905 
 8906   // For EVEX with VL and BW, provide a standard mask, VL = 128 will guide the merge
 8907   // context for the registers used, where all instructions below are using 128-bit mode
 8908   // On EVEX without VL and BW, these instructions will all be AVX.
 8909   lea(table, ExternalAddress(StubRoutines::crc_table_addr()));
 8910   notl(crc); // ~crc
 8911   cmpl(len, 16);
 8912   jcc(Assembler::less, L_tail);
 8913 
 8914   // Align buffer to 16 bytes
 8915   movl(tmp, buf);
 8916   andl(tmp, 0xF);
 8917   jccb(Assembler::zero, L_aligned);
 8918   subl(tmp,  16);
 8919   addl(len, tmp);
 8920 
 8921   align(4);
 8922   BIND(L_align_loop);
 8923   movsbl(rax, Address(buf, 0)); // load byte with sign extension
 8924   update_byte_crc32(crc, rax, table);
 8925   increment(buf);
 8926   incrementl(tmp);
 8927   jccb(Assembler::less, L_align_loop);
 8928 
 8929   BIND(L_aligned);
 8930   movl(tmp, len); // save
 8931   shrl(len, 4);
 8932   jcc(Assembler::zero, L_tail_restore);
 8933 
 8934   // Fold crc into first bytes of vector
 8935   movdqa(xmm1, Address(buf, 0));
 8936   movdl(rax, xmm1);
 8937   xorl(crc, rax);
 8938   if (VM_Version::supports_sse4_1()) {
 8939     pinsrd(xmm1, crc, 0);
 8940   } else {
 8941     pinsrw(xmm1, crc, 0);
 8942     shrl(crc, 16);
 8943     pinsrw(xmm1, crc, 1);
 8944   }
 8945   addptr(buf, 16);
 8946   subl(len, 4); // len &gt; 0
 8947   jcc(Assembler::less, L_fold_tail);
 8948 
 8949   movdqa(xmm2, Address(buf,  0));
 8950   movdqa(xmm3, Address(buf, 16));
 8951   movdqa(xmm4, Address(buf, 32));
 8952   addptr(buf, 48);
 8953   subl(len, 3);
 8954   jcc(Assembler::lessEqual, L_fold_512b);
 8955 
 8956   // Fold total 512 bits of polynomial on each iteration,
 8957   // 128 bits per each of 4 parallel streams.
 8958   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 32));
 8959 
 8960   align(32);
 8961   BIND(L_fold_512b_loop);
 8962   fold_128bit_crc32(xmm1, xmm0, xmm5, buf,  0);
 8963   fold_128bit_crc32(xmm2, xmm0, xmm5, buf, 16);
 8964   fold_128bit_crc32(xmm3, xmm0, xmm5, buf, 32);
 8965   fold_128bit_crc32(xmm4, xmm0, xmm5, buf, 48);
 8966   addptr(buf, 64);
 8967   subl(len, 4);
 8968   jcc(Assembler::greater, L_fold_512b_loop);
 8969 
 8970   // Fold 512 bits to 128 bits.
 8971   BIND(L_fold_512b);
 8972   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 16));
 8973   fold_128bit_crc32(xmm1, xmm0, xmm5, xmm2);
 8974   fold_128bit_crc32(xmm1, xmm0, xmm5, xmm3);
 8975   fold_128bit_crc32(xmm1, xmm0, xmm5, xmm4);
 8976 
 8977   // Fold the rest of 128 bits data chunks
 8978   BIND(L_fold_tail);
 8979   addl(len, 3);
 8980   jccb(Assembler::lessEqual, L_fold_128b);
 8981   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 16));
 8982 
 8983   BIND(L_fold_tail_loop);
 8984   fold_128bit_crc32(xmm1, xmm0, xmm5, buf,  0);
 8985   addptr(buf, 16);
 8986   decrementl(len);
 8987   jccb(Assembler::greater, L_fold_tail_loop);
 8988 
 8989   // Fold 128 bits in xmm1 down into 32 bits in crc register.
 8990   BIND(L_fold_128b);
 8991   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr()));
 8992   if (UseAVX &gt; 0) {
 8993     vpclmulqdq(xmm2, xmm0, xmm1, 0x1);
 8994     vpand(xmm3, xmm0, xmm2, 0 /* vector_len */);
 8995     vpclmulqdq(xmm0, xmm0, xmm3, 0x1);
 8996   } else {
 8997     movdqa(xmm2, xmm0);
 8998     pclmulqdq(xmm2, xmm1, 0x1);
 8999     movdqa(xmm3, xmm0);
 9000     pand(xmm3, xmm2);
 9001     pclmulqdq(xmm0, xmm3, 0x1);
 9002   }
 9003   psrldq(xmm1, 8);
 9004   psrldq(xmm2, 4);
 9005   pxor(xmm0, xmm1);
 9006   pxor(xmm0, xmm2);
 9007 
 9008   // 8 8-bit folds to compute 32-bit CRC.
 9009   for (int j = 0; j &lt; 4; j++) {
 9010     fold_8bit_crc32(xmm0, table, xmm1, rax);
 9011   }
 9012   movdl(crc, xmm0); // mov 32 bits to general register
 9013   for (int j = 0; j &lt; 4; j++) {
 9014     fold_8bit_crc32(crc, table, rax);
 9015   }
 9016 
 9017   BIND(L_tail_restore);
 9018   movl(len, tmp); // restore
 9019   BIND(L_tail);
 9020   andl(len, 0xf);
 9021   jccb(Assembler::zero, L_exit);
 9022 
 9023   // Fold the rest of bytes
 9024   align(4);
 9025   BIND(L_tail_loop);
 9026   movsbl(rax, Address(buf, 0)); // load byte with sign extension
 9027   update_byte_crc32(crc, rax, table);
 9028   increment(buf);
 9029   decrementl(len);
 9030   jccb(Assembler::greater, L_tail_loop);
 9031 
 9032   BIND(L_exit);
 9033   notl(crc); // ~c
 9034 }
 9035 
 9036 #ifdef _LP64
 9037 // S. Gueron / Information Processing Letters 112 (2012) 184
 9038 // Algorithm 4: Computing carry-less multiplication using a precomputed lookup table.
 9039 // Input: A 32 bit value B = [byte3, byte2, byte1, byte0].
 9040 // Output: the 64-bit carry-less product of B * CONST
 9041 void MacroAssembler::crc32c_ipl_alg4(Register in, uint32_t n,
 9042                                      Register tmp1, Register tmp2, Register tmp3) {
 9043   lea(tmp3, ExternalAddress(StubRoutines::crc32c_table_addr()));
 9044   if (n &gt; 0) {
 9045     addq(tmp3, n * 256 * 8);
 9046   }
 9047   //    Q1 = TABLEExt[n][B &amp; 0xFF];
 9048   movl(tmp1, in);
 9049   andl(tmp1, 0x000000FF);
 9050   shll(tmp1, 3);
 9051   addq(tmp1, tmp3);
 9052   movq(tmp1, Address(tmp1, 0));
 9053 
 9054   //    Q2 = TABLEExt[n][B &gt;&gt; 8 &amp; 0xFF];
 9055   movl(tmp2, in);
 9056   shrl(tmp2, 8);
 9057   andl(tmp2, 0x000000FF);
 9058   shll(tmp2, 3);
 9059   addq(tmp2, tmp3);
 9060   movq(tmp2, Address(tmp2, 0));
 9061 
 9062   shlq(tmp2, 8);
 9063   xorq(tmp1, tmp2);
 9064 
 9065   //    Q3 = TABLEExt[n][B &gt;&gt; 16 &amp; 0xFF];
 9066   movl(tmp2, in);
 9067   shrl(tmp2, 16);
 9068   andl(tmp2, 0x000000FF);
 9069   shll(tmp2, 3);
 9070   addq(tmp2, tmp3);
 9071   movq(tmp2, Address(tmp2, 0));
 9072 
 9073   shlq(tmp2, 16);
 9074   xorq(tmp1, tmp2);
 9075 
 9076   //    Q4 = TABLEExt[n][B &gt;&gt; 24 &amp; 0xFF];
 9077   shrl(in, 24);
 9078   andl(in, 0x000000FF);
 9079   shll(in, 3);
 9080   addq(in, tmp3);
 9081   movq(in, Address(in, 0));
 9082 
 9083   shlq(in, 24);
 9084   xorq(in, tmp1);
 9085   //    return Q1 ^ Q2 &lt;&lt; 8 ^ Q3 &lt;&lt; 16 ^ Q4 &lt;&lt; 24;
 9086 }
 9087 
 9088 void MacroAssembler::crc32c_pclmulqdq(XMMRegister w_xtmp1,
 9089                                       Register in_out,
 9090                                       uint32_t const_or_pre_comp_const_index, bool is_pclmulqdq_supported,
 9091                                       XMMRegister w_xtmp2,
 9092                                       Register tmp1,
 9093                                       Register n_tmp2, Register n_tmp3) {
 9094   if (is_pclmulqdq_supported) {
 9095     movdl(w_xtmp1, in_out); // modified blindly
 9096 
 9097     movl(tmp1, const_or_pre_comp_const_index);
 9098     movdl(w_xtmp2, tmp1);
 9099     pclmulqdq(w_xtmp1, w_xtmp2, 0);
 9100 
 9101     movdq(in_out, w_xtmp1);
 9102   } else {
 9103     crc32c_ipl_alg4(in_out, const_or_pre_comp_const_index, tmp1, n_tmp2, n_tmp3);
 9104   }
 9105 }
 9106 
 9107 // Recombination Alternative 2: No bit-reflections
 9108 // T1 = (CRC_A * U1) &lt;&lt; 1
 9109 // T2 = (CRC_B * U2) &lt;&lt; 1
 9110 // C1 = T1 &gt;&gt; 32
 9111 // C2 = T2 &gt;&gt; 32
 9112 // T1 = T1 &amp; 0xFFFFFFFF
 9113 // T2 = T2 &amp; 0xFFFFFFFF
 9114 // T1 = CRC32(0, T1)
 9115 // T2 = CRC32(0, T2)
 9116 // C1 = C1 ^ T1
 9117 // C2 = C2 ^ T2
 9118 // CRC = C1 ^ C2 ^ CRC_C
 9119 void MacroAssembler::crc32c_rec_alt2(uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported, Register in_out, Register in1, Register in2,
 9120                                      XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
 9121                                      Register tmp1, Register tmp2,
 9122                                      Register n_tmp3) {
 9123   crc32c_pclmulqdq(w_xtmp1, in_out, const_or_pre_comp_const_index_u1, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
 9124   crc32c_pclmulqdq(w_xtmp2, in1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
 9125   shlq(in_out, 1);
 9126   movl(tmp1, in_out);
 9127   shrq(in_out, 32);
 9128   xorl(tmp2, tmp2);
 9129   crc32(tmp2, tmp1, 4);
 9130   xorl(in_out, tmp2); // we don&#39;t care about upper 32 bit contents here
 9131   shlq(in1, 1);
 9132   movl(tmp1, in1);
 9133   shrq(in1, 32);
 9134   xorl(tmp2, tmp2);
 9135   crc32(tmp2, tmp1, 4);
 9136   xorl(in1, tmp2);
 9137   xorl(in_out, in1);
 9138   xorl(in_out, in2);
 9139 }
 9140 
 9141 // Set N to predefined value
 9142 // Subtract from a lenght of a buffer
 9143 // execute in a loop:
 9144 // CRC_A = 0xFFFFFFFF, CRC_B = 0, CRC_C = 0
 9145 // for i = 1 to N do
 9146 //  CRC_A = CRC32(CRC_A, A[i])
 9147 //  CRC_B = CRC32(CRC_B, B[i])
 9148 //  CRC_C = CRC32(CRC_C, C[i])
 9149 // end for
 9150 // Recombine
 9151 void MacroAssembler::crc32c_proc_chunk(uint32_t size, uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported,
 9152                                        Register in_out1, Register in_out2, Register in_out3,
 9153                                        Register tmp1, Register tmp2, Register tmp3,
 9154                                        XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
 9155                                        Register tmp4, Register tmp5,
 9156                                        Register n_tmp6) {
 9157   Label L_processPartitions;
 9158   Label L_processPartition;
 9159   Label L_exit;
 9160 
 9161   bind(L_processPartitions);
 9162   cmpl(in_out1, 3 * size);
 9163   jcc(Assembler::less, L_exit);
 9164     xorl(tmp1, tmp1);
 9165     xorl(tmp2, tmp2);
 9166     movq(tmp3, in_out2);
 9167     addq(tmp3, size);
 9168 
 9169     bind(L_processPartition);
 9170       crc32(in_out3, Address(in_out2, 0), 8);
 9171       crc32(tmp1, Address(in_out2, size), 8);
 9172       crc32(tmp2, Address(in_out2, size * 2), 8);
 9173       addq(in_out2, 8);
 9174       cmpq(in_out2, tmp3);
 9175       jcc(Assembler::less, L_processPartition);
 9176     crc32c_rec_alt2(const_or_pre_comp_const_index_u1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, in_out3, tmp1, tmp2,
 9177             w_xtmp1, w_xtmp2, w_xtmp3,
 9178             tmp4, tmp5,
 9179             n_tmp6);
 9180     addq(in_out2, 2 * size);
 9181     subl(in_out1, 3 * size);
 9182     jmp(L_processPartitions);
 9183 
 9184   bind(L_exit);
 9185 }
 9186 #else
 9187 void MacroAssembler::crc32c_ipl_alg4(Register in_out, uint32_t n,
 9188                                      Register tmp1, Register tmp2, Register tmp3,
 9189                                      XMMRegister xtmp1, XMMRegister xtmp2) {
 9190   lea(tmp3, ExternalAddress(StubRoutines::crc32c_table_addr()));
 9191   if (n &gt; 0) {
 9192     addl(tmp3, n * 256 * 8);
 9193   }
 9194   //    Q1 = TABLEExt[n][B &amp; 0xFF];
 9195   movl(tmp1, in_out);
 9196   andl(tmp1, 0x000000FF);
 9197   shll(tmp1, 3);
 9198   addl(tmp1, tmp3);
 9199   movq(xtmp1, Address(tmp1, 0));
 9200 
 9201   //    Q2 = TABLEExt[n][B &gt;&gt; 8 &amp; 0xFF];
 9202   movl(tmp2, in_out);
 9203   shrl(tmp2, 8);
 9204   andl(tmp2, 0x000000FF);
 9205   shll(tmp2, 3);
 9206   addl(tmp2, tmp3);
 9207   movq(xtmp2, Address(tmp2, 0));
 9208 
 9209   psllq(xtmp2, 8);
 9210   pxor(xtmp1, xtmp2);
 9211 
 9212   //    Q3 = TABLEExt[n][B &gt;&gt; 16 &amp; 0xFF];
 9213   movl(tmp2, in_out);
 9214   shrl(tmp2, 16);
 9215   andl(tmp2, 0x000000FF);
 9216   shll(tmp2, 3);
 9217   addl(tmp2, tmp3);
 9218   movq(xtmp2, Address(tmp2, 0));
 9219 
 9220   psllq(xtmp2, 16);
 9221   pxor(xtmp1, xtmp2);
 9222 
 9223   //    Q4 = TABLEExt[n][B &gt;&gt; 24 &amp; 0xFF];
 9224   shrl(in_out, 24);
 9225   andl(in_out, 0x000000FF);
 9226   shll(in_out, 3);
 9227   addl(in_out, tmp3);
 9228   movq(xtmp2, Address(in_out, 0));
 9229 
 9230   psllq(xtmp2, 24);
 9231   pxor(xtmp1, xtmp2); // Result in CXMM
 9232   //    return Q1 ^ Q2 &lt;&lt; 8 ^ Q3 &lt;&lt; 16 ^ Q4 &lt;&lt; 24;
 9233 }
 9234 
 9235 void MacroAssembler::crc32c_pclmulqdq(XMMRegister w_xtmp1,
 9236                                       Register in_out,
 9237                                       uint32_t const_or_pre_comp_const_index, bool is_pclmulqdq_supported,
 9238                                       XMMRegister w_xtmp2,
 9239                                       Register tmp1,
 9240                                       Register n_tmp2, Register n_tmp3) {
 9241   if (is_pclmulqdq_supported) {
 9242     movdl(w_xtmp1, in_out);
 9243 
 9244     movl(tmp1, const_or_pre_comp_const_index);
 9245     movdl(w_xtmp2, tmp1);
 9246     pclmulqdq(w_xtmp1, w_xtmp2, 0);
 9247     // Keep result in XMM since GPR is 32 bit in length
 9248   } else {
 9249     crc32c_ipl_alg4(in_out, const_or_pre_comp_const_index, tmp1, n_tmp2, n_tmp3, w_xtmp1, w_xtmp2);
 9250   }
 9251 }
 9252 
 9253 void MacroAssembler::crc32c_rec_alt2(uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported, Register in_out, Register in1, Register in2,
 9254                                      XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
 9255                                      Register tmp1, Register tmp2,
 9256                                      Register n_tmp3) {
 9257   crc32c_pclmulqdq(w_xtmp1, in_out, const_or_pre_comp_const_index_u1, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
 9258   crc32c_pclmulqdq(w_xtmp2, in1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
 9259 
 9260   psllq(w_xtmp1, 1);
 9261   movdl(tmp1, w_xtmp1);
 9262   psrlq(w_xtmp1, 32);
 9263   movdl(in_out, w_xtmp1);
 9264 
 9265   xorl(tmp2, tmp2);
 9266   crc32(tmp2, tmp1, 4);
 9267   xorl(in_out, tmp2);
 9268 
 9269   psllq(w_xtmp2, 1);
 9270   movdl(tmp1, w_xtmp2);
 9271   psrlq(w_xtmp2, 32);
 9272   movdl(in1, w_xtmp2);
 9273 
 9274   xorl(tmp2, tmp2);
 9275   crc32(tmp2, tmp1, 4);
 9276   xorl(in1, tmp2);
 9277   xorl(in_out, in1);
 9278   xorl(in_out, in2);
 9279 }
 9280 
 9281 void MacroAssembler::crc32c_proc_chunk(uint32_t size, uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported,
 9282                                        Register in_out1, Register in_out2, Register in_out3,
 9283                                        Register tmp1, Register tmp2, Register tmp3,
 9284                                        XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
 9285                                        Register tmp4, Register tmp5,
 9286                                        Register n_tmp6) {
 9287   Label L_processPartitions;
 9288   Label L_processPartition;
 9289   Label L_exit;
 9290 
 9291   bind(L_processPartitions);
 9292   cmpl(in_out1, 3 * size);
 9293   jcc(Assembler::less, L_exit);
 9294     xorl(tmp1, tmp1);
 9295     xorl(tmp2, tmp2);
 9296     movl(tmp3, in_out2);
 9297     addl(tmp3, size);
 9298 
 9299     bind(L_processPartition);
 9300       crc32(in_out3, Address(in_out2, 0), 4);
 9301       crc32(tmp1, Address(in_out2, size), 4);
 9302       crc32(tmp2, Address(in_out2, size*2), 4);
 9303       crc32(in_out3, Address(in_out2, 0+4), 4);
 9304       crc32(tmp1, Address(in_out2, size+4), 4);
 9305       crc32(tmp2, Address(in_out2, size*2+4), 4);
 9306       addl(in_out2, 8);
 9307       cmpl(in_out2, tmp3);
 9308       jcc(Assembler::less, L_processPartition);
 9309 
 9310         push(tmp3);
 9311         push(in_out1);
 9312         push(in_out2);
 9313         tmp4 = tmp3;
 9314         tmp5 = in_out1;
 9315         n_tmp6 = in_out2;
 9316 
 9317       crc32c_rec_alt2(const_or_pre_comp_const_index_u1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, in_out3, tmp1, tmp2,
 9318             w_xtmp1, w_xtmp2, w_xtmp3,
 9319             tmp4, tmp5,
 9320             n_tmp6);
 9321 
 9322         pop(in_out2);
 9323         pop(in_out1);
 9324         pop(tmp3);
 9325 
 9326     addl(in_out2, 2 * size);
 9327     subl(in_out1, 3 * size);
 9328     jmp(L_processPartitions);
 9329 
 9330   bind(L_exit);
 9331 }
 9332 #endif //LP64
 9333 
 9334 #ifdef _LP64
 9335 // Algorithm 2: Pipelined usage of the CRC32 instruction.
 9336 // Input: A buffer I of L bytes.
 9337 // Output: the CRC32C value of the buffer.
 9338 // Notations:
 9339 // Write L = 24N + r, with N = floor (L/24).
 9340 // r = L mod 24 (0 &lt;= r &lt; 24).
 9341 // Consider I as the concatenation of A|B|C|R, where A, B, C, each,
 9342 // N quadwords, and R consists of r bytes.
 9343 // A[j] = I [8j+7:8j], j= 0, 1, ..., N-1
 9344 // B[j] = I [N + 8j+7:N + 8j], j= 0, 1, ..., N-1
 9345 // C[j] = I [2N + 8j+7:2N + 8j], j= 0, 1, ..., N-1
 9346 // if r &gt; 0 R[j] = I [3N +j], j= 0, 1, ...,r-1
 9347 void MacroAssembler::crc32c_ipl_alg2_alt2(Register in_out, Register in1, Register in2,
 9348                                           Register tmp1, Register tmp2, Register tmp3,
 9349                                           Register tmp4, Register tmp5, Register tmp6,
 9350                                           XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
 9351                                           bool is_pclmulqdq_supported) {
 9352   uint32_t const_or_pre_comp_const_index[CRC32C_NUM_PRECOMPUTED_CONSTANTS];
 9353   Label L_wordByWord;
 9354   Label L_byteByByteProlog;
 9355   Label L_byteByByte;
 9356   Label L_exit;
 9357 
 9358   if (is_pclmulqdq_supported ) {
 9359     const_or_pre_comp_const_index[1] = *(uint32_t *)StubRoutines::_crc32c_table_addr;
 9360     const_or_pre_comp_const_index[0] = *((uint32_t *)StubRoutines::_crc32c_table_addr+1);
 9361 
 9362     const_or_pre_comp_const_index[3] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 2);
 9363     const_or_pre_comp_const_index[2] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 3);
 9364 
 9365     const_or_pre_comp_const_index[5] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 4);
 9366     const_or_pre_comp_const_index[4] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 5);
 9367     assert((CRC32C_NUM_PRECOMPUTED_CONSTANTS - 1 ) == 5, &quot;Checking whether you declared all of the constants based on the number of \&quot;chunks\&quot;&quot;);
 9368   } else {
 9369     const_or_pre_comp_const_index[0] = 1;
 9370     const_or_pre_comp_const_index[1] = 0;
 9371 
 9372     const_or_pre_comp_const_index[2] = 3;
 9373     const_or_pre_comp_const_index[3] = 2;
 9374 
 9375     const_or_pre_comp_const_index[4] = 5;
 9376     const_or_pre_comp_const_index[5] = 4;
 9377    }
 9378   crc32c_proc_chunk(CRC32C_HIGH, const_or_pre_comp_const_index[0], const_or_pre_comp_const_index[1], is_pclmulqdq_supported,
 9379                     in2, in1, in_out,
 9380                     tmp1, tmp2, tmp3,
 9381                     w_xtmp1, w_xtmp2, w_xtmp3,
 9382                     tmp4, tmp5,
 9383                     tmp6);
 9384   crc32c_proc_chunk(CRC32C_MIDDLE, const_or_pre_comp_const_index[2], const_or_pre_comp_const_index[3], is_pclmulqdq_supported,
 9385                     in2, in1, in_out,
 9386                     tmp1, tmp2, tmp3,
 9387                     w_xtmp1, w_xtmp2, w_xtmp3,
 9388                     tmp4, tmp5,
 9389                     tmp6);
 9390   crc32c_proc_chunk(CRC32C_LOW, const_or_pre_comp_const_index[4], const_or_pre_comp_const_index[5], is_pclmulqdq_supported,
 9391                     in2, in1, in_out,
 9392                     tmp1, tmp2, tmp3,
 9393                     w_xtmp1, w_xtmp2, w_xtmp3,
 9394                     tmp4, tmp5,
 9395                     tmp6);
 9396   movl(tmp1, in2);
 9397   andl(tmp1, 0x00000007);
 9398   negl(tmp1);
 9399   addl(tmp1, in2);
 9400   addq(tmp1, in1);
 9401 
 9402   BIND(L_wordByWord);
 9403   cmpq(in1, tmp1);
 9404   jcc(Assembler::greaterEqual, L_byteByByteProlog);
 9405     crc32(in_out, Address(in1, 0), 4);
 9406     addq(in1, 4);
 9407     jmp(L_wordByWord);
 9408 
 9409   BIND(L_byteByByteProlog);
 9410   andl(in2, 0x00000007);
 9411   movl(tmp2, 1);
 9412 
 9413   BIND(L_byteByByte);
 9414   cmpl(tmp2, in2);
 9415   jccb(Assembler::greater, L_exit);
 9416     crc32(in_out, Address(in1, 0), 1);
 9417     incq(in1);
 9418     incl(tmp2);
 9419     jmp(L_byteByByte);
 9420 
 9421   BIND(L_exit);
 9422 }
 9423 #else
 9424 void MacroAssembler::crc32c_ipl_alg2_alt2(Register in_out, Register in1, Register in2,
 9425                                           Register tmp1, Register  tmp2, Register tmp3,
 9426                                           Register tmp4, Register  tmp5, Register tmp6,
 9427                                           XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
 9428                                           bool is_pclmulqdq_supported) {
 9429   uint32_t const_or_pre_comp_const_index[CRC32C_NUM_PRECOMPUTED_CONSTANTS];
 9430   Label L_wordByWord;
 9431   Label L_byteByByteProlog;
 9432   Label L_byteByByte;
 9433   Label L_exit;
 9434 
 9435   if (is_pclmulqdq_supported) {
 9436     const_or_pre_comp_const_index[1] = *(uint32_t *)StubRoutines::_crc32c_table_addr;
 9437     const_or_pre_comp_const_index[0] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 1);
 9438 
 9439     const_or_pre_comp_const_index[3] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 2);
 9440     const_or_pre_comp_const_index[2] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 3);
 9441 
 9442     const_or_pre_comp_const_index[5] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 4);
 9443     const_or_pre_comp_const_index[4] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 5);
 9444   } else {
 9445     const_or_pre_comp_const_index[0] = 1;
 9446     const_or_pre_comp_const_index[1] = 0;
 9447 
 9448     const_or_pre_comp_const_index[2] = 3;
 9449     const_or_pre_comp_const_index[3] = 2;
 9450 
 9451     const_or_pre_comp_const_index[4] = 5;
 9452     const_or_pre_comp_const_index[5] = 4;
 9453   }
 9454   crc32c_proc_chunk(CRC32C_HIGH, const_or_pre_comp_const_index[0], const_or_pre_comp_const_index[1], is_pclmulqdq_supported,
 9455                     in2, in1, in_out,
 9456                     tmp1, tmp2, tmp3,
 9457                     w_xtmp1, w_xtmp2, w_xtmp3,
 9458                     tmp4, tmp5,
 9459                     tmp6);
 9460   crc32c_proc_chunk(CRC32C_MIDDLE, const_or_pre_comp_const_index[2], const_or_pre_comp_const_index[3], is_pclmulqdq_supported,
 9461                     in2, in1, in_out,
 9462                     tmp1, tmp2, tmp3,
 9463                     w_xtmp1, w_xtmp2, w_xtmp3,
 9464                     tmp4, tmp5,
 9465                     tmp6);
 9466   crc32c_proc_chunk(CRC32C_LOW, const_or_pre_comp_const_index[4], const_or_pre_comp_const_index[5], is_pclmulqdq_supported,
 9467                     in2, in1, in_out,
 9468                     tmp1, tmp2, tmp3,
 9469                     w_xtmp1, w_xtmp2, w_xtmp3,
 9470                     tmp4, tmp5,
 9471                     tmp6);
 9472   movl(tmp1, in2);
 9473   andl(tmp1, 0x00000007);
 9474   negl(tmp1);
 9475   addl(tmp1, in2);
 9476   addl(tmp1, in1);
 9477 
 9478   BIND(L_wordByWord);
 9479   cmpl(in1, tmp1);
 9480   jcc(Assembler::greaterEqual, L_byteByByteProlog);
 9481     crc32(in_out, Address(in1,0), 4);
 9482     addl(in1, 4);
 9483     jmp(L_wordByWord);
 9484 
 9485   BIND(L_byteByByteProlog);
 9486   andl(in2, 0x00000007);
 9487   movl(tmp2, 1);
 9488 
 9489   BIND(L_byteByByte);
 9490   cmpl(tmp2, in2);
 9491   jccb(Assembler::greater, L_exit);
 9492     movb(tmp1, Address(in1, 0));
 9493     crc32(in_out, tmp1, 1);
 9494     incl(in1);
 9495     incl(tmp2);
 9496     jmp(L_byteByByte);
 9497 
 9498   BIND(L_exit);
 9499 }
 9500 #endif // LP64
 9501 #undef BIND
 9502 #undef BLOCK_COMMENT
 9503 
 9504 // Compress char[] array to byte[].
 9505 //   ..\jdk\src\java.base\share\classes\java\lang\StringUTF16.java
 9506 //   @HotSpotIntrinsicCandidate
 9507 //   private static int compress(char[] src, int srcOff, byte[] dst, int dstOff, int len) {
 9508 //     for (int i = 0; i &lt; len; i++) {
 9509 //       int c = src[srcOff++];
 9510 //       if (c &gt;&gt;&gt; 8 != 0) {
 9511 //         return 0;
 9512 //       }
 9513 //       dst[dstOff++] = (byte)c;
 9514 //     }
 9515 //     return len;
 9516 //   }
 9517 void MacroAssembler::char_array_compress(Register src, Register dst, Register len,
 9518   XMMRegister tmp1Reg, XMMRegister tmp2Reg,
 9519   XMMRegister tmp3Reg, XMMRegister tmp4Reg,
 9520   Register tmp5, Register result) {
 9521   Label copy_chars_loop, return_length, return_zero, done;
 9522 
 9523   // rsi: src
 9524   // rdi: dst
 9525   // rdx: len
 9526   // rcx: tmp5
 9527   // rax: result
 9528 
 9529   // rsi holds start addr of source char[] to be compressed
 9530   // rdi holds start addr of destination byte[]
 9531   // rdx holds length
 9532 
 9533   assert(len != result, &quot;&quot;);
 9534 
 9535   // save length for return
 9536   push(len);
 9537 
 9538   if ((AVX3Threshold == 0) &amp;&amp; (UseAVX &gt; 2) &amp;&amp; // AVX512
 9539     VM_Version::supports_avx512vlbw() &amp;&amp;
 9540     VM_Version::supports_bmi2()) {
 9541 
 9542     Label copy_32_loop, copy_loop_tail, below_threshold;
 9543 
 9544     // alignment
 9545     Label post_alignment;
 9546 
 9547     // if length of the string is less than 16, handle it in an old fashioned way
 9548     testl(len, -32);
 9549     jcc(Assembler::zero, below_threshold);
 9550 
 9551     // First check whether a character is compressable ( &lt;= 0xFF).
 9552     // Create mask to test for Unicode chars inside zmm vector
 9553     movl(result, 0x00FF);
 9554     evpbroadcastw(tmp2Reg, result, Assembler::AVX_512bit);
 9555 
 9556     testl(len, -64);
 9557     jcc(Assembler::zero, post_alignment);
 9558 
 9559     movl(tmp5, dst);
 9560     andl(tmp5, (32 - 1));
 9561     negl(tmp5);
 9562     andl(tmp5, (32 - 1));
 9563 
 9564     // bail out when there is nothing to be done
 9565     testl(tmp5, 0xFFFFFFFF);
 9566     jcc(Assembler::zero, post_alignment);
 9567 
 9568     // ~(~0 &lt;&lt; len), where len is the # of remaining elements to process
 9569     movl(result, 0xFFFFFFFF);
 9570     shlxl(result, result, tmp5);
 9571     notl(result);
 9572     kmovdl(k3, result);
 9573 
 9574     evmovdquw(tmp1Reg, k3, Address(src, 0), Assembler::AVX_512bit);
 9575     evpcmpuw(k2, k3, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);
 9576     ktestd(k2, k3);
 9577     jcc(Assembler::carryClear, return_zero);
 9578 
 9579     evpmovwb(Address(dst, 0), k3, tmp1Reg, Assembler::AVX_512bit);
 9580 
 9581     addptr(src, tmp5);
 9582     addptr(src, tmp5);
 9583     addptr(dst, tmp5);
 9584     subl(len, tmp5);
 9585 
 9586     bind(post_alignment);
 9587     // end of alignment
 9588 
 9589     movl(tmp5, len);
 9590     andl(tmp5, (32 - 1));    // tail count (in chars)
 9591     andl(len, ~(32 - 1));    // vector count (in chars)
 9592     jcc(Assembler::zero, copy_loop_tail);
 9593 
 9594     lea(src, Address(src, len, Address::times_2));
 9595     lea(dst, Address(dst, len, Address::times_1));
 9596     negptr(len);
 9597 
 9598     bind(copy_32_loop);
 9599     evmovdquw(tmp1Reg, Address(src, len, Address::times_2), Assembler::AVX_512bit);
 9600     evpcmpuw(k2, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);
 9601     kortestdl(k2, k2);
 9602     jcc(Assembler::carryClear, return_zero);
 9603 
 9604     // All elements in current processed chunk are valid candidates for
 9605     // compression. Write a truncated byte elements to the memory.
 9606     evpmovwb(Address(dst, len, Address::times_1), tmp1Reg, Assembler::AVX_512bit);
 9607     addptr(len, 32);
 9608     jcc(Assembler::notZero, copy_32_loop);
 9609 
 9610     bind(copy_loop_tail);
 9611     // bail out when there is nothing to be done
 9612     testl(tmp5, 0xFFFFFFFF);
 9613     jcc(Assembler::zero, return_length);
 9614 
 9615     movl(len, tmp5);
 9616 
 9617     // ~(~0 &lt;&lt; len), where len is the # of remaining elements to process
 9618     movl(result, 0xFFFFFFFF);
 9619     shlxl(result, result, len);
 9620     notl(result);
 9621 
 9622     kmovdl(k3, result);
 9623 
 9624     evmovdquw(tmp1Reg, k3, Address(src, 0), Assembler::AVX_512bit);
 9625     evpcmpuw(k2, k3, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);
 9626     ktestd(k2, k3);
 9627     jcc(Assembler::carryClear, return_zero);
 9628 
 9629     evpmovwb(Address(dst, 0), k3, tmp1Reg, Assembler::AVX_512bit);
 9630     jmp(return_length);
 9631 
 9632     bind(below_threshold);
 9633   }
 9634 
 9635   if (UseSSE42Intrinsics) {
 9636     Label copy_32_loop, copy_16, copy_tail;
 9637 
 9638     movl(result, len);
 9639 
 9640     movl(tmp5, 0xff00ff00);   // create mask to test for Unicode chars in vectors
 9641 
 9642     // vectored compression
 9643     andl(len, 0xfffffff0);    // vector count (in chars)
 9644     andl(result, 0x0000000f);    // tail count (in chars)
 9645     testl(len, len);
 9646     jcc(Assembler::zero, copy_16);
 9647 
 9648     // compress 16 chars per iter
 9649     movdl(tmp1Reg, tmp5);
 9650     pshufd(tmp1Reg, tmp1Reg, 0);   // store Unicode mask in tmp1Reg
 9651     pxor(tmp4Reg, tmp4Reg);
 9652 
 9653     lea(src, Address(src, len, Address::times_2));
 9654     lea(dst, Address(dst, len, Address::times_1));
 9655     negptr(len);
 9656 
 9657     bind(copy_32_loop);
 9658     movdqu(tmp2Reg, Address(src, len, Address::times_2));     // load 1st 8 characters
 9659     por(tmp4Reg, tmp2Reg);
 9660     movdqu(tmp3Reg, Address(src, len, Address::times_2, 16)); // load next 8 characters
 9661     por(tmp4Reg, tmp3Reg);
 9662     ptest(tmp4Reg, tmp1Reg);       // check for Unicode chars in next vector
 9663     jcc(Assembler::notZero, return_zero);
 9664     packuswb(tmp2Reg, tmp3Reg);    // only ASCII chars; compress each to 1 byte
 9665     movdqu(Address(dst, len, Address::times_1), tmp2Reg);
 9666     addptr(len, 16);
 9667     jcc(Assembler::notZero, copy_32_loop);
 9668 
 9669     // compress next vector of 8 chars (if any)
 9670     bind(copy_16);
 9671     movl(len, result);
 9672     andl(len, 0xfffffff8);    // vector count (in chars)
 9673     andl(result, 0x00000007);    // tail count (in chars)
 9674     testl(len, len);
 9675     jccb(Assembler::zero, copy_tail);
 9676 
 9677     movdl(tmp1Reg, tmp5);
 9678     pshufd(tmp1Reg, tmp1Reg, 0);   // store Unicode mask in tmp1Reg
 9679     pxor(tmp3Reg, tmp3Reg);
 9680 
 9681     movdqu(tmp2Reg, Address(src, 0));
 9682     ptest(tmp2Reg, tmp1Reg);       // check for Unicode chars in vector
 9683     jccb(Assembler::notZero, return_zero);
 9684     packuswb(tmp2Reg, tmp3Reg);    // only LATIN1 chars; compress each to 1 byte
 9685     movq(Address(dst, 0), tmp2Reg);
 9686     addptr(src, 16);
 9687     addptr(dst, 8);
 9688 
 9689     bind(copy_tail);
 9690     movl(len, result);
 9691   }
 9692   // compress 1 char per iter
 9693   testl(len, len);
 9694   jccb(Assembler::zero, return_length);
 9695   lea(src, Address(src, len, Address::times_2));
 9696   lea(dst, Address(dst, len, Address::times_1));
 9697   negptr(len);
 9698 
 9699   bind(copy_chars_loop);
 9700   load_unsigned_short(result, Address(src, len, Address::times_2));
 9701   testl(result, 0xff00);      // check if Unicode char
 9702   jccb(Assembler::notZero, return_zero);
 9703   movb(Address(dst, len, Address::times_1), result);  // ASCII char; compress to 1 byte
 9704   increment(len);
 9705   jcc(Assembler::notZero, copy_chars_loop);
 9706 
 9707   // if compression succeeded, return length
 9708   bind(return_length);
 9709   pop(result);
 9710   jmpb(done);
 9711 
 9712   // if compression failed, return 0
 9713   bind(return_zero);
 9714   xorl(result, result);
 9715   addptr(rsp, wordSize);
 9716 
 9717   bind(done);
 9718 }
 9719 
 9720 // Inflate byte[] array to char[].
 9721 //   ..\jdk\src\java.base\share\classes\java\lang\StringLatin1.java
 9722 //   @HotSpotIntrinsicCandidate
 9723 //   private static void inflate(byte[] src, int srcOff, char[] dst, int dstOff, int len) {
 9724 //     for (int i = 0; i &lt; len; i++) {
 9725 //       dst[dstOff++] = (char)(src[srcOff++] &amp; 0xff);
 9726 //     }
 9727 //   }
 9728 void MacroAssembler::byte_array_inflate(Register src, Register dst, Register len,
 9729   XMMRegister tmp1, Register tmp2) {
 9730   Label copy_chars_loop, done, below_threshold, avx3_threshold;
 9731   // rsi: src
 9732   // rdi: dst
 9733   // rdx: len
 9734   // rcx: tmp2
 9735 
 9736   // rsi holds start addr of source byte[] to be inflated
 9737   // rdi holds start addr of destination char[]
 9738   // rdx holds length
 9739   assert_different_registers(src, dst, len, tmp2);
 9740   movl(tmp2, len);
 9741   if ((UseAVX &gt; 2) &amp;&amp; // AVX512
 9742     VM_Version::supports_avx512vlbw() &amp;&amp;
 9743     VM_Version::supports_bmi2()) {
 9744 
 9745     Label copy_32_loop, copy_tail;
 9746     Register tmp3_aliased = len;
 9747 
 9748     // if length of the string is less than 16, handle it in an old fashioned way
 9749     testl(len, -16);
 9750     jcc(Assembler::zero, below_threshold);
 9751 
 9752     testl(len, -1 * AVX3Threshold);
 9753     jcc(Assembler::zero, avx3_threshold);
 9754 
 9755     // In order to use only one arithmetic operation for the main loop we use
 9756     // this pre-calculation
 9757     andl(tmp2, (32 - 1)); // tail count (in chars), 32 element wide loop
 9758     andl(len, -32);     // vector count
 9759     jccb(Assembler::zero, copy_tail);
 9760 
 9761     lea(src, Address(src, len, Address::times_1));
 9762     lea(dst, Address(dst, len, Address::times_2));
 9763     negptr(len);
 9764 
 9765 
 9766     // inflate 32 chars per iter
 9767     bind(copy_32_loop);
 9768     vpmovzxbw(tmp1, Address(src, len, Address::times_1), Assembler::AVX_512bit);
 9769     evmovdquw(Address(dst, len, Address::times_2), tmp1, Assembler::AVX_512bit);
 9770     addptr(len, 32);
 9771     jcc(Assembler::notZero, copy_32_loop);
 9772 
 9773     bind(copy_tail);
 9774     // bail out when there is nothing to be done
 9775     testl(tmp2, -1); // we don&#39;t destroy the contents of tmp2 here
 9776     jcc(Assembler::zero, done);
 9777 
 9778     // ~(~0 &lt;&lt; length), where length is the # of remaining elements to process
 9779     movl(tmp3_aliased, -1);
 9780     shlxl(tmp3_aliased, tmp3_aliased, tmp2);
 9781     notl(tmp3_aliased);
 9782     kmovdl(k2, tmp3_aliased);
 9783     evpmovzxbw(tmp1, k2, Address(src, 0), Assembler::AVX_512bit);
 9784     evmovdquw(Address(dst, 0), k2, tmp1, Assembler::AVX_512bit);
 9785 
 9786     jmp(done);
 9787     bind(avx3_threshold);
 9788   }
 9789   if (UseSSE42Intrinsics) {
 9790     Label copy_16_loop, copy_8_loop, copy_bytes, copy_new_tail, copy_tail;
 9791 
 9792     if (UseAVX &gt; 1) {
 9793       andl(tmp2, (16 - 1));
 9794       andl(len, -16);
 9795       jccb(Assembler::zero, copy_new_tail);
 9796     } else {
 9797       andl(tmp2, 0x00000007);   // tail count (in chars)
 9798       andl(len, 0xfffffff8);    // vector count (in chars)
 9799       jccb(Assembler::zero, copy_tail);
 9800     }
 9801 
 9802     // vectored inflation
 9803     lea(src, Address(src, len, Address::times_1));
 9804     lea(dst, Address(dst, len, Address::times_2));
 9805     negptr(len);
 9806 
 9807     if (UseAVX &gt; 1) {
 9808       bind(copy_16_loop);
 9809       vpmovzxbw(tmp1, Address(src, len, Address::times_1), Assembler::AVX_256bit);
 9810       vmovdqu(Address(dst, len, Address::times_2), tmp1);
 9811       addptr(len, 16);
 9812       jcc(Assembler::notZero, copy_16_loop);
 9813 
 9814       bind(below_threshold);
 9815       bind(copy_new_tail);
 9816       movl(len, tmp2);
 9817       andl(tmp2, 0x00000007);
 9818       andl(len, 0xFFFFFFF8);
 9819       jccb(Assembler::zero, copy_tail);
 9820 
 9821       pmovzxbw(tmp1, Address(src, 0));
 9822       movdqu(Address(dst, 0), tmp1);
 9823       addptr(src, 8);
 9824       addptr(dst, 2 * 8);
 9825 
 9826       jmp(copy_tail, true);
 9827     }
 9828 
 9829     // inflate 8 chars per iter
 9830     bind(copy_8_loop);
 9831     pmovzxbw(tmp1, Address(src, len, Address::times_1));  // unpack to 8 words
 9832     movdqu(Address(dst, len, Address::times_2), tmp1);
 9833     addptr(len, 8);
 9834     jcc(Assembler::notZero, copy_8_loop);
 9835 
 9836     bind(copy_tail);
 9837     movl(len, tmp2);
 9838 
 9839     cmpl(len, 4);
 9840     jccb(Assembler::less, copy_bytes);
 9841 
 9842     movdl(tmp1, Address(src, 0));  // load 4 byte chars
 9843     pmovzxbw(tmp1, tmp1);
 9844     movq(Address(dst, 0), tmp1);
 9845     subptr(len, 4);
 9846     addptr(src, 4);
 9847     addptr(dst, 8);
 9848 
 9849     bind(copy_bytes);
 9850   } else {
 9851     bind(below_threshold);
 9852   }
 9853 
 9854   testl(len, len);
 9855   jccb(Assembler::zero, done);
 9856   lea(src, Address(src, len, Address::times_1));
 9857   lea(dst, Address(dst, len, Address::times_2));
 9858   negptr(len);
 9859 
 9860   // inflate 1 char per iter
 9861   bind(copy_chars_loop);
 9862   load_unsigned_byte(tmp2, Address(src, len, Address::times_1));  // load byte char
 9863   movw(Address(dst, len, Address::times_2), tmp2);  // inflate byte char to word
 9864   increment(len);
 9865   jcc(Assembler::notZero, copy_chars_loop);
 9866 
 9867   bind(done);
 9868 }
 9869 
 9870 #ifdef _LP64
 9871 void MacroAssembler::convert_f2i(Register dst, XMMRegister src) {
 9872   Label done;
 9873   cvttss2sil(dst, src);
 9874   // Conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
 9875   cmpl(dst, 0x80000000); // float_sign_flip
 9876   jccb(Assembler::notEqual, done);
 9877   subptr(rsp, 8);
 9878   movflt(Address(rsp, 0), src);
 9879   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2i_fixup())));
 9880   pop(dst);
 9881   bind(done);
 9882 }
 9883 
 9884 void MacroAssembler::convert_d2i(Register dst, XMMRegister src) {
 9885   Label done;
 9886   cvttsd2sil(dst, src);
 9887   // Conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
 9888   cmpl(dst, 0x80000000); // float_sign_flip
 9889   jccb(Assembler::notEqual, done);
 9890   subptr(rsp, 8);
 9891   movdbl(Address(rsp, 0), src);
 9892   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2i_fixup())));
 9893   pop(dst);
 9894   bind(done);
 9895 }
 9896 
 9897 void MacroAssembler::convert_f2l(Register dst, XMMRegister src) {
 9898   Label done;
 9899   cvttss2siq(dst, src);
 9900   cmp64(dst, ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
 9901   jccb(Assembler::notEqual, done);
 9902   subptr(rsp, 8);
 9903   movflt(Address(rsp, 0), src);
 9904   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2l_fixup())));
 9905   pop(dst);
 9906   bind(done);
 9907 }
 9908 
 9909 void MacroAssembler::convert_d2l(Register dst, XMMRegister src) {
 9910   Label done;
 9911   cvttsd2siq(dst, src);
 9912   cmp64(dst, ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
 9913   jccb(Assembler::notEqual, done);
 9914   subptr(rsp, 8);
 9915   movdbl(Address(rsp, 0), src);
 9916   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2l_fixup())));
 9917   pop(dst);
 9918   bind(done);
 9919 }
 9920 
 9921 void MacroAssembler::cache_wb(Address line)
 9922 {
 9923   // 64 bit cpus always support clflush
 9924   assert(VM_Version::supports_clflush(), &quot;clflush should be available&quot;);
 9925   bool optimized = VM_Version::supports_clflushopt();
 9926   bool no_evict = VM_Version::supports_clwb();
 9927 
 9928   // prefer clwb (writeback without evict) otherwise
 9929   // prefer clflushopt (potentially parallel writeback with evict)
 9930   // otherwise fallback on clflush (serial writeback with evict)
 9931 
 9932   if (optimized) {
 9933     if (no_evict) {
 9934       clwb(line);
 9935     } else {
 9936       clflushopt(line);
 9937     }
 9938   } else {
 9939     // no need for fence when using CLFLUSH
 9940     clflush(line);
 9941   }
 9942 }
 9943 
 9944 void MacroAssembler::cache_wbsync(bool is_pre)
 9945 {
 9946   assert(VM_Version::supports_clflush(), &quot;clflush should be available&quot;);
 9947   bool optimized = VM_Version::supports_clflushopt();
 9948   bool no_evict = VM_Version::supports_clwb();
 9949 
 9950   // pick the correct implementation
 9951 
 9952   if (!is_pre &amp;&amp; (optimized || no_evict)) {
 9953     // need an sfence for post flush when using clflushopt or clwb
 9954     // otherwise no no need for any synchroniaztion
 9955 
 9956     sfence();
 9957   }
 9958 }
 9959 #endif // _LP64
 9960 
 9961 Assembler::Condition MacroAssembler::negate_condition(Assembler::Condition cond) {
 9962   switch (cond) {
 9963     // Note some conditions are synonyms for others
 9964     case Assembler::zero:         return Assembler::notZero;
 9965     case Assembler::notZero:      return Assembler::zero;
 9966     case Assembler::less:         return Assembler::greaterEqual;
 9967     case Assembler::lessEqual:    return Assembler::greater;
 9968     case Assembler::greater:      return Assembler::lessEqual;
 9969     case Assembler::greaterEqual: return Assembler::less;
 9970     case Assembler::below:        return Assembler::aboveEqual;
 9971     case Assembler::belowEqual:   return Assembler::above;
 9972     case Assembler::above:        return Assembler::belowEqual;
 9973     case Assembler::aboveEqual:   return Assembler::below;
 9974     case Assembler::overflow:     return Assembler::noOverflow;
 9975     case Assembler::noOverflow:   return Assembler::overflow;
 9976     case Assembler::negative:     return Assembler::positive;
 9977     case Assembler::positive:     return Assembler::negative;
 9978     case Assembler::parity:       return Assembler::noParity;
 9979     case Assembler::noParity:     return Assembler::parity;
 9980   }
 9981   ShouldNotReachHere(); return Assembler::overflow;
 9982 }
 9983 
 9984 SkipIfEqual::SkipIfEqual(
 9985     MacroAssembler* masm, const bool* flag_addr, bool value) {
 9986   _masm = masm;
 9987   _masm-&gt;cmp8(ExternalAddress((address)flag_addr), value);
 9988   _masm-&gt;jcc(Assembler::equal, _label);
 9989 }
 9990 
 9991 SkipIfEqual::~SkipIfEqual() {
 9992   _masm-&gt;bind(_label);
 9993 }
 9994 
 9995 // 32-bit Windows has its own fast-path implementation
 9996 // of get_thread
 9997 #if !defined(WIN32) || defined(_LP64)
 9998 
 9999 // This is simply a call to Thread::current()
10000 void MacroAssembler::get_thread(Register thread) {
10001   if (thread != rax) {
10002     push(rax);
10003   }
10004   LP64_ONLY(push(rdi);)
10005   LP64_ONLY(push(rsi);)
10006   push(rdx);
10007   push(rcx);
10008 #ifdef _LP64
10009   push(r8);
10010   push(r9);
10011   push(r10);
10012   push(r11);
10013 #endif
10014 
10015   MacroAssembler::call_VM_leaf_base(CAST_FROM_FN_PTR(address, Thread::current), 0);
10016 
10017 #ifdef _LP64
10018   pop(r11);
10019   pop(r10);
10020   pop(r9);
10021   pop(r8);
10022 #endif
10023   pop(rcx);
10024   pop(rdx);
10025   LP64_ONLY(pop(rsi);)
10026   LP64_ONLY(pop(rdi);)
10027   if (thread != rax) {
10028     mov(thread, rax);
10029     pop(rax);
10030   }
10031 }
10032 
10033 #endif // !WIN32 || _LP64
<a name="26" id="anc26"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="26" type="hidden" />
</body>
</html>
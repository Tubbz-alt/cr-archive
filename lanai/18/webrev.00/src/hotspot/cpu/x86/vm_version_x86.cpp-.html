<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/x86/vm_version_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;asm/macroAssembler.hpp&quot;
  28 #include &quot;asm/macroAssembler.inline.hpp&quot;
  29 #include &quot;logging/log.hpp&quot;
  30 #include &quot;logging/logStream.hpp&quot;
  31 #include &quot;memory/resourceArea.hpp&quot;
  32 #include &quot;runtime/java.hpp&quot;
  33 #include &quot;runtime/os.hpp&quot;
  34 #include &quot;runtime/stubCodeGenerator.hpp&quot;
  35 #include &quot;runtime/vm_version.hpp&quot;
  36 #include &quot;utilities/virtualizationSupport.hpp&quot;
  37 
  38 #include OS_HEADER_INLINE(os)
  39 
  40 int VM_Version::_cpu;
  41 int VM_Version::_model;
  42 int VM_Version::_stepping;
  43 VM_Version::CpuidInfo VM_Version::_cpuid_info = { 0, };
  44 
  45 // Address of instruction which causes SEGV
  46 address VM_Version::_cpuinfo_segv_addr = 0;
  47 // Address of instruction after the one which causes SEGV
  48 address VM_Version::_cpuinfo_cont_addr = 0;
  49 
  50 static BufferBlob* stub_blob;
  51 static const int stub_size = 1100;
  52 
  53 extern &quot;C&quot; {
  54   typedef void (*get_cpu_info_stub_t)(void*);
  55 }
  56 static get_cpu_info_stub_t get_cpu_info_stub = NULL;
  57 
  58 
  59 class VM_Version_StubGenerator: public StubCodeGenerator {
  60  public:
  61 
  62   VM_Version_StubGenerator(CodeBuffer *c) : StubCodeGenerator(c) {}
  63 
  64   address generate_get_cpu_info() {
  65     // Flags to test CPU type.
  66     const uint32_t HS_EFL_AC = 0x40000;
  67     const uint32_t HS_EFL_ID = 0x200000;
  68     // Values for when we don&#39;t have a CPUID instruction.
  69     const int      CPU_FAMILY_SHIFT = 8;
  70     const uint32_t CPU_FAMILY_386 = (3 &lt;&lt; CPU_FAMILY_SHIFT);
  71     const uint32_t CPU_FAMILY_486 = (4 &lt;&lt; CPU_FAMILY_SHIFT);
  72     bool use_evex = FLAG_IS_DEFAULT(UseAVX) || (UseAVX &gt; 2);
  73 
  74     Label detect_486, cpu486, detect_586, std_cpuid1, std_cpuid4;
  75     Label sef_cpuid, ext_cpuid, ext_cpuid1, ext_cpuid5, ext_cpuid7, ext_cpuid8, done, wrapup;
  76     Label legacy_setup, save_restore_except, legacy_save_restore, start_simd_check;
  77 
  78     StubCodeMark mark(this, &quot;VM_Version&quot;, &quot;get_cpu_info_stub&quot;);
  79 #   define __ _masm-&gt;
  80 
  81     address start = __ pc();
  82 
  83     //
  84     // void get_cpu_info(VM_Version::CpuidInfo* cpuid_info);
  85     //
  86     // LP64: rcx and rdx are first and second argument registers on windows
  87 
  88     __ push(rbp);
  89 #ifdef _LP64
  90     __ mov(rbp, c_rarg0); // cpuid_info address
  91 #else
  92     __ movptr(rbp, Address(rsp, 8)); // cpuid_info address
  93 #endif
  94     __ push(rbx);
  95     __ push(rsi);
  96     __ pushf();          // preserve rbx, and flags
  97     __ pop(rax);
  98     __ push(rax);
  99     __ mov(rcx, rax);
 100     //
 101     // if we are unable to change the AC flag, we have a 386
 102     //
 103     __ xorl(rax, HS_EFL_AC);
 104     __ push(rax);
 105     __ popf();
 106     __ pushf();
 107     __ pop(rax);
 108     __ cmpptr(rax, rcx);
 109     __ jccb(Assembler::notEqual, detect_486);
 110 
 111     __ movl(rax, CPU_FAMILY_386);
 112     __ movl(Address(rbp, in_bytes(VM_Version::std_cpuid1_offset())), rax);
 113     __ jmp(done);
 114 
 115     //
 116     // If we are unable to change the ID flag, we have a 486 which does
 117     // not support the &quot;cpuid&quot; instruction.
 118     //
 119     __ bind(detect_486);
 120     __ mov(rax, rcx);
 121     __ xorl(rax, HS_EFL_ID);
 122     __ push(rax);
 123     __ popf();
 124     __ pushf();
 125     __ pop(rax);
 126     __ cmpptr(rcx, rax);
 127     __ jccb(Assembler::notEqual, detect_586);
 128 
 129     __ bind(cpu486);
 130     __ movl(rax, CPU_FAMILY_486);
 131     __ movl(Address(rbp, in_bytes(VM_Version::std_cpuid1_offset())), rax);
 132     __ jmp(done);
 133 
 134     //
 135     // At this point, we have a chip which supports the &quot;cpuid&quot; instruction
 136     //
 137     __ bind(detect_586);
 138     __ xorl(rax, rax);
 139     __ cpuid();
 140     __ orl(rax, rax);
 141     __ jcc(Assembler::equal, cpu486);   // if cpuid doesn&#39;t support an input
 142                                         // value of at least 1, we give up and
 143                                         // assume a 486
 144     __ lea(rsi, Address(rbp, in_bytes(VM_Version::std_cpuid0_offset())));
 145     __ movl(Address(rsi, 0), rax);
 146     __ movl(Address(rsi, 4), rbx);
 147     __ movl(Address(rsi, 8), rcx);
 148     __ movl(Address(rsi,12), rdx);
 149 
 150     __ cmpl(rax, 0xa);                  // Is cpuid(0xB) supported?
 151     __ jccb(Assembler::belowEqual, std_cpuid4);
 152 
 153     //
 154     // cpuid(0xB) Processor Topology
 155     //
 156     __ movl(rax, 0xb);
 157     __ xorl(rcx, rcx);   // Threads level
 158     __ cpuid();
 159 
 160     __ lea(rsi, Address(rbp, in_bytes(VM_Version::tpl_cpuidB0_offset())));
 161     __ movl(Address(rsi, 0), rax);
 162     __ movl(Address(rsi, 4), rbx);
 163     __ movl(Address(rsi, 8), rcx);
 164     __ movl(Address(rsi,12), rdx);
 165 
 166     __ movl(rax, 0xb);
 167     __ movl(rcx, 1);     // Cores level
 168     __ cpuid();
 169     __ push(rax);
 170     __ andl(rax, 0x1f);  // Determine if valid topology level
 171     __ orl(rax, rbx);    // eax[4:0] | ebx[0:15] == 0 indicates invalid level
 172     __ andl(rax, 0xffff);
 173     __ pop(rax);
 174     __ jccb(Assembler::equal, std_cpuid4);
 175 
 176     __ lea(rsi, Address(rbp, in_bytes(VM_Version::tpl_cpuidB1_offset())));
 177     __ movl(Address(rsi, 0), rax);
 178     __ movl(Address(rsi, 4), rbx);
 179     __ movl(Address(rsi, 8), rcx);
 180     __ movl(Address(rsi,12), rdx);
 181 
 182     __ movl(rax, 0xb);
 183     __ movl(rcx, 2);     // Packages level
 184     __ cpuid();
 185     __ push(rax);
 186     __ andl(rax, 0x1f);  // Determine if valid topology level
 187     __ orl(rax, rbx);    // eax[4:0] | ebx[0:15] == 0 indicates invalid level
 188     __ andl(rax, 0xffff);
 189     __ pop(rax);
 190     __ jccb(Assembler::equal, std_cpuid4);
 191 
 192     __ lea(rsi, Address(rbp, in_bytes(VM_Version::tpl_cpuidB2_offset())));
 193     __ movl(Address(rsi, 0), rax);
 194     __ movl(Address(rsi, 4), rbx);
 195     __ movl(Address(rsi, 8), rcx);
 196     __ movl(Address(rsi,12), rdx);
 197 
 198     //
 199     // cpuid(0x4) Deterministic cache params
 200     //
 201     __ bind(std_cpuid4);
 202     __ movl(rax, 4);
 203     __ cmpl(rax, Address(rbp, in_bytes(VM_Version::std_cpuid0_offset()))); // Is cpuid(0x4) supported?
 204     __ jccb(Assembler::greater, std_cpuid1);
 205 
 206     __ xorl(rcx, rcx);   // L1 cache
 207     __ cpuid();
 208     __ push(rax);
 209     __ andl(rax, 0x1f);  // Determine if valid cache parameters used
 210     __ orl(rax, rax);    // eax[4:0] == 0 indicates invalid cache
 211     __ pop(rax);
 212     __ jccb(Assembler::equal, std_cpuid1);
 213 
 214     __ lea(rsi, Address(rbp, in_bytes(VM_Version::dcp_cpuid4_offset())));
 215     __ movl(Address(rsi, 0), rax);
 216     __ movl(Address(rsi, 4), rbx);
 217     __ movl(Address(rsi, 8), rcx);
 218     __ movl(Address(rsi,12), rdx);
 219 
 220     //
 221     // Standard cpuid(0x1)
 222     //
 223     __ bind(std_cpuid1);
 224     __ movl(rax, 1);
 225     __ cpuid();
 226     __ lea(rsi, Address(rbp, in_bytes(VM_Version::std_cpuid1_offset())));
 227     __ movl(Address(rsi, 0), rax);
 228     __ movl(Address(rsi, 4), rbx);
 229     __ movl(Address(rsi, 8), rcx);
 230     __ movl(Address(rsi,12), rdx);
 231 
 232     //
 233     // Check if OS has enabled XGETBV instruction to access XCR0
 234     // (OSXSAVE feature flag) and CPU supports AVX
 235     //
 236     __ andl(rcx, 0x18000000); // cpuid1 bits osxsave | avx
 237     __ cmpl(rcx, 0x18000000);
 238     __ jccb(Assembler::notEqual, sef_cpuid); // jump if AVX is not supported
 239 
 240     //
 241     // XCR0, XFEATURE_ENABLED_MASK register
 242     //
 243     __ xorl(rcx, rcx);   // zero for XCR0 register
 244     __ xgetbv();
 245     __ lea(rsi, Address(rbp, in_bytes(VM_Version::xem_xcr0_offset())));
 246     __ movl(Address(rsi, 0), rax);
 247     __ movl(Address(rsi, 4), rdx);
 248 
 249     //
 250     // cpuid(0x7) Structured Extended Features
 251     //
 252     __ bind(sef_cpuid);
 253     __ movl(rax, 7);
 254     __ cmpl(rax, Address(rbp, in_bytes(VM_Version::std_cpuid0_offset()))); // Is cpuid(0x7) supported?
 255     __ jccb(Assembler::greater, ext_cpuid);
 256 
 257     __ xorl(rcx, rcx);
 258     __ cpuid();
 259     __ lea(rsi, Address(rbp, in_bytes(VM_Version::sef_cpuid7_offset())));
 260     __ movl(Address(rsi, 0), rax);
 261     __ movl(Address(rsi, 4), rbx);
 262     __ movl(Address(rsi, 8), rcx);
 263     __ movl(Address(rsi, 12), rdx);
 264 
 265     //
 266     // Extended cpuid(0x80000000)
 267     //
 268     __ bind(ext_cpuid);
 269     __ movl(rax, 0x80000000);
 270     __ cpuid();
 271     __ cmpl(rax, 0x80000000);     // Is cpuid(0x80000001) supported?
 272     __ jcc(Assembler::belowEqual, done);
 273     __ cmpl(rax, 0x80000004);     // Is cpuid(0x80000005) supported?
 274     __ jcc(Assembler::belowEqual, ext_cpuid1);
 275     __ cmpl(rax, 0x80000006);     // Is cpuid(0x80000007) supported?
 276     __ jccb(Assembler::belowEqual, ext_cpuid5);
 277     __ cmpl(rax, 0x80000007);     // Is cpuid(0x80000008) supported?
 278     __ jccb(Assembler::belowEqual, ext_cpuid7);
 279     __ cmpl(rax, 0x80000008);     // Is cpuid(0x80000009 and above) supported?
 280     __ jccb(Assembler::belowEqual, ext_cpuid8);
 281     __ cmpl(rax, 0x8000001E);     // Is cpuid(0x8000001E) supported?
 282     __ jccb(Assembler::below, ext_cpuid8);
 283     //
 284     // Extended cpuid(0x8000001E)
 285     //
 286     __ movl(rax, 0x8000001E);
 287     __ cpuid();
 288     __ lea(rsi, Address(rbp, in_bytes(VM_Version::ext_cpuid1E_offset())));
 289     __ movl(Address(rsi, 0), rax);
 290     __ movl(Address(rsi, 4), rbx);
 291     __ movl(Address(rsi, 8), rcx);
 292     __ movl(Address(rsi,12), rdx);
 293 
 294     //
 295     // Extended cpuid(0x80000008)
 296     //
 297     __ bind(ext_cpuid8);
 298     __ movl(rax, 0x80000008);
 299     __ cpuid();
 300     __ lea(rsi, Address(rbp, in_bytes(VM_Version::ext_cpuid8_offset())));
 301     __ movl(Address(rsi, 0), rax);
 302     __ movl(Address(rsi, 4), rbx);
 303     __ movl(Address(rsi, 8), rcx);
 304     __ movl(Address(rsi,12), rdx);
 305 
 306     //
 307     // Extended cpuid(0x80000007)
 308     //
 309     __ bind(ext_cpuid7);
 310     __ movl(rax, 0x80000007);
 311     __ cpuid();
 312     __ lea(rsi, Address(rbp, in_bytes(VM_Version::ext_cpuid7_offset())));
 313     __ movl(Address(rsi, 0), rax);
 314     __ movl(Address(rsi, 4), rbx);
 315     __ movl(Address(rsi, 8), rcx);
 316     __ movl(Address(rsi,12), rdx);
 317 
 318     //
 319     // Extended cpuid(0x80000005)
 320     //
 321     __ bind(ext_cpuid5);
 322     __ movl(rax, 0x80000005);
 323     __ cpuid();
 324     __ lea(rsi, Address(rbp, in_bytes(VM_Version::ext_cpuid5_offset())));
 325     __ movl(Address(rsi, 0), rax);
 326     __ movl(Address(rsi, 4), rbx);
 327     __ movl(Address(rsi, 8), rcx);
 328     __ movl(Address(rsi,12), rdx);
 329 
 330     //
 331     // Extended cpuid(0x80000001)
 332     //
 333     __ bind(ext_cpuid1);
 334     __ movl(rax, 0x80000001);
 335     __ cpuid();
 336     __ lea(rsi, Address(rbp, in_bytes(VM_Version::ext_cpuid1_offset())));
 337     __ movl(Address(rsi, 0), rax);
 338     __ movl(Address(rsi, 4), rbx);
 339     __ movl(Address(rsi, 8), rcx);
 340     __ movl(Address(rsi,12), rdx);
 341 
 342     //
 343     // Check if OS has enabled XGETBV instruction to access XCR0
 344     // (OSXSAVE feature flag) and CPU supports AVX
 345     //
 346     __ lea(rsi, Address(rbp, in_bytes(VM_Version::std_cpuid1_offset())));
 347     __ movl(rcx, 0x18000000); // cpuid1 bits osxsave | avx
 348     __ andl(rcx, Address(rsi, 8)); // cpuid1 bits osxsave | avx
 349     __ cmpl(rcx, 0x18000000);
 350     __ jccb(Assembler::notEqual, done); // jump if AVX is not supported
 351 
 352     __ movl(rax, 0x6);
 353     __ andl(rax, Address(rbp, in_bytes(VM_Version::xem_xcr0_offset()))); // xcr0 bits sse | ymm
 354     __ cmpl(rax, 0x6);
 355     __ jccb(Assembler::equal, start_simd_check); // return if AVX is not supported
 356 
 357     // we need to bridge farther than imm8, so we use this island as a thunk
 358     __ bind(done);
 359     __ jmp(wrapup);
 360 
 361     __ bind(start_simd_check);
 362     //
 363     // Some OSs have a bug when upper 128/256bits of YMM/ZMM
 364     // registers are not restored after a signal processing.
 365     // Generate SEGV here (reference through NULL)
 366     // and check upper YMM/ZMM bits after it.
 367     //
 368     intx saved_useavx = UseAVX;
 369     intx saved_usesse = UseSSE;
 370 
 371     // If UseAVX is unitialized or is set by the user to include EVEX
 372     if (use_evex) {
 373       // check _cpuid_info.sef_cpuid7_ebx.bits.avx512f
 374       __ lea(rsi, Address(rbp, in_bytes(VM_Version::sef_cpuid7_offset())));
 375       __ movl(rax, 0x10000);
 376       __ andl(rax, Address(rsi, 4)); // xcr0 bits sse | ymm
 377       __ cmpl(rax, 0x10000);
 378       __ jccb(Assembler::notEqual, legacy_setup); // jump if EVEX is not supported
 379       // check _cpuid_info.xem_xcr0_eax.bits.opmask
 380       // check _cpuid_info.xem_xcr0_eax.bits.zmm512
 381       // check _cpuid_info.xem_xcr0_eax.bits.zmm32
 382       __ movl(rax, 0xE0);
 383       __ andl(rax, Address(rbp, in_bytes(VM_Version::xem_xcr0_offset()))); // xcr0 bits sse | ymm
 384       __ cmpl(rax, 0xE0);
 385       __ jccb(Assembler::notEqual, legacy_setup); // jump if EVEX is not supported
 386 
 387       if (FLAG_IS_DEFAULT(UseAVX)) {
 388         __ lea(rsi, Address(rbp, in_bytes(VM_Version::std_cpuid1_offset())));
 389         __ movl(rax, Address(rsi, 0));
 390         __ cmpl(rax, 0x50654);              // If it is Skylake
 391         __ jcc(Assembler::equal, legacy_setup);
 392       }
 393       // EVEX setup: run in lowest evex mode
 394       VM_Version::set_evex_cpuFeatures(); // Enable temporary to pass asserts
 395       UseAVX = 3;
 396       UseSSE = 2;
 397 #ifdef _WINDOWS
 398       // xmm5-xmm15 are not preserved by caller on windows
 399       // https://msdn.microsoft.com/en-us/library/9z1stfyw.aspx
 400       __ subptr(rsp, 64);
 401       __ evmovdqul(Address(rsp, 0), xmm7, Assembler::AVX_512bit);
 402 #ifdef _LP64
 403       __ subptr(rsp, 64);
 404       __ evmovdqul(Address(rsp, 0), xmm8, Assembler::AVX_512bit);
 405       __ subptr(rsp, 64);
 406       __ evmovdqul(Address(rsp, 0), xmm31, Assembler::AVX_512bit);
 407 #endif // _LP64
 408 #endif // _WINDOWS
 409 
 410       // load value into all 64 bytes of zmm7 register
 411       __ movl(rcx, VM_Version::ymm_test_value());
 412       __ movdl(xmm0, rcx);
 413       __ vpbroadcastd(xmm0, xmm0, Assembler::AVX_512bit);
 414       __ evmovdqul(xmm7, xmm0, Assembler::AVX_512bit);
 415 #ifdef _LP64
 416       __ evmovdqul(xmm8, xmm0, Assembler::AVX_512bit);
 417       __ evmovdqul(xmm31, xmm0, Assembler::AVX_512bit);
 418 #endif
 419       VM_Version::clean_cpuFeatures();
 420       __ jmp(save_restore_except);
 421     }
 422 
 423     __ bind(legacy_setup);
 424     // AVX setup
 425     VM_Version::set_avx_cpuFeatures(); // Enable temporary to pass asserts
 426     UseAVX = 1;
 427     UseSSE = 2;
 428 #ifdef _WINDOWS
 429     __ subptr(rsp, 32);
 430     __ vmovdqu(Address(rsp, 0), xmm7);
 431 #ifdef _LP64
 432     __ subptr(rsp, 32);
 433     __ vmovdqu(Address(rsp, 0), xmm8);
 434     __ subptr(rsp, 32);
 435     __ vmovdqu(Address(rsp, 0), xmm15);
 436 #endif // _LP64
 437 #endif // _WINDOWS
 438 
 439     // load value into all 32 bytes of ymm7 register
 440     __ movl(rcx, VM_Version::ymm_test_value());
 441 
 442     __ movdl(xmm0, rcx);
 443     __ pshufd(xmm0, xmm0, 0x00);
 444     __ vinsertf128_high(xmm0, xmm0);
 445     __ vmovdqu(xmm7, xmm0);
 446 #ifdef _LP64
 447     __ vmovdqu(xmm8, xmm0);
 448     __ vmovdqu(xmm15, xmm0);
 449 #endif
 450     VM_Version::clean_cpuFeatures();
 451 
 452     __ bind(save_restore_except);
 453     __ xorl(rsi, rsi);
 454     VM_Version::set_cpuinfo_segv_addr(__ pc());
 455     // Generate SEGV
 456     __ movl(rax, Address(rsi, 0));
 457 
 458     VM_Version::set_cpuinfo_cont_addr(__ pc());
 459     // Returns here after signal. Save xmm0 to check it later.
 460 
 461     // If UseAVX is unitialized or is set by the user to include EVEX
 462     if (use_evex) {
 463       // check _cpuid_info.sef_cpuid7_ebx.bits.avx512f
 464       __ lea(rsi, Address(rbp, in_bytes(VM_Version::sef_cpuid7_offset())));
 465       __ movl(rax, 0x10000);
 466       __ andl(rax, Address(rsi, 4));
 467       __ cmpl(rax, 0x10000);
 468       __ jcc(Assembler::notEqual, legacy_save_restore);
 469       // check _cpuid_info.xem_xcr0_eax.bits.opmask
 470       // check _cpuid_info.xem_xcr0_eax.bits.zmm512
 471       // check _cpuid_info.xem_xcr0_eax.bits.zmm32
 472       __ movl(rax, 0xE0);
 473       __ andl(rax, Address(rbp, in_bytes(VM_Version::xem_xcr0_offset()))); // xcr0 bits sse | ymm
 474       __ cmpl(rax, 0xE0);
 475       __ jcc(Assembler::notEqual, legacy_save_restore);
 476 
 477       if (FLAG_IS_DEFAULT(UseAVX)) {
 478         __ lea(rsi, Address(rbp, in_bytes(VM_Version::std_cpuid1_offset())));
 479         __ movl(rax, Address(rsi, 0));
 480         __ cmpl(rax, 0x50654);              // If it is Skylake
 481         __ jcc(Assembler::equal, legacy_save_restore);
 482       }
 483       // EVEX check: run in lowest evex mode
 484       VM_Version::set_evex_cpuFeatures(); // Enable temporary to pass asserts
 485       UseAVX = 3;
 486       UseSSE = 2;
 487       __ lea(rsi, Address(rbp, in_bytes(VM_Version::zmm_save_offset())));
 488       __ evmovdqul(Address(rsi, 0), xmm0, Assembler::AVX_512bit);
 489       __ evmovdqul(Address(rsi, 64), xmm7, Assembler::AVX_512bit);
 490 #ifdef _LP64
 491       __ evmovdqul(Address(rsi, 128), xmm8, Assembler::AVX_512bit);
 492       __ evmovdqul(Address(rsi, 192), xmm31, Assembler::AVX_512bit);
 493 #endif
 494 
 495 #ifdef _WINDOWS
 496 #ifdef _LP64
 497       __ evmovdqul(xmm31, Address(rsp, 0), Assembler::AVX_512bit);
 498       __ addptr(rsp, 64);
 499       __ evmovdqul(xmm8, Address(rsp, 0), Assembler::AVX_512bit);
 500       __ addptr(rsp, 64);
 501 #endif // _LP64
 502       __ evmovdqul(xmm7, Address(rsp, 0), Assembler::AVX_512bit);
 503       __ addptr(rsp, 64);
 504 #endif // _WINDOWS
 505       generate_vzeroupper(wrapup);
 506       VM_Version::clean_cpuFeatures();
 507       UseAVX = saved_useavx;
 508       UseSSE = saved_usesse;
 509       __ jmp(wrapup);
 510    }
 511 
 512     __ bind(legacy_save_restore);
 513     // AVX check
 514     VM_Version::set_avx_cpuFeatures(); // Enable temporary to pass asserts
 515     UseAVX = 1;
 516     UseSSE = 2;
 517     __ lea(rsi, Address(rbp, in_bytes(VM_Version::ymm_save_offset())));
 518     __ vmovdqu(Address(rsi, 0), xmm0);
 519     __ vmovdqu(Address(rsi, 32), xmm7);
 520 #ifdef _LP64
 521     __ vmovdqu(Address(rsi, 64), xmm8);
 522     __ vmovdqu(Address(rsi, 96), xmm15);
 523 #endif
 524 
 525 #ifdef _WINDOWS
 526 #ifdef _LP64
 527     __ vmovdqu(xmm15, Address(rsp, 0));
 528     __ addptr(rsp, 32);
 529     __ vmovdqu(xmm8, Address(rsp, 0));
 530     __ addptr(rsp, 32);
 531 #endif // _LP64
 532     __ vmovdqu(xmm7, Address(rsp, 0));
 533     __ addptr(rsp, 32);
 534 #endif // _WINDOWS
 535     generate_vzeroupper(wrapup);
 536     VM_Version::clean_cpuFeatures();
 537     UseAVX = saved_useavx;
 538     UseSSE = saved_usesse;
 539 
 540     __ bind(wrapup);
 541     __ popf();
 542     __ pop(rsi);
 543     __ pop(rbx);
 544     __ pop(rbp);
 545     __ ret(0);
 546 
 547 #   undef __
 548 
 549     return start;
 550   };
 551   void generate_vzeroupper(Label&amp; L_wrapup) {
 552 #   define __ _masm-&gt;
 553     __ lea(rsi, Address(rbp, in_bytes(VM_Version::std_cpuid0_offset())));
 554     __ cmpl(Address(rsi, 4), 0x756e6547);  // &#39;uneG&#39;
 555     __ jcc(Assembler::notEqual, L_wrapup);
 556     __ movl(rcx, 0x0FFF0FF0);
 557     __ lea(rsi, Address(rbp, in_bytes(VM_Version::std_cpuid1_offset())));
 558     __ andl(rcx, Address(rsi, 0));
 559     __ cmpl(rcx, 0x00050670);              // If it is Xeon Phi 3200/5200/7200
 560     __ jcc(Assembler::equal, L_wrapup);
 561     __ cmpl(rcx, 0x00080650);              // If it is Future Xeon Phi
 562     __ jcc(Assembler::equal, L_wrapup);
 563     __ vzeroupper();
 564 #   undef __
 565   }
 566 };
 567 
 568 void VM_Version::get_processor_features() {
 569 
 570   _cpu = 4; // 486 by default
 571   _model = 0;
 572   _stepping = 0;
 573   _features = 0;
 574   _logical_processors_per_package = 1;
 575   // i486 internal cache is both I&amp;D and has a 16-byte line size
 576   _L1_data_cache_line_size = 16;
 577 
 578   // Get raw processor info
 579 
 580   get_cpu_info_stub(&amp;_cpuid_info);
 581 
 582   assert_is_initialized();
 583   _cpu = extended_cpu_family();
 584   _model = extended_cpu_model();
 585   _stepping = cpu_stepping();
 586 
 587   if (cpu_family() &gt; 4) { // it supports CPUID
 588     _features = feature_flags();
 589     // Logical processors are only available on P4s and above,
 590     // and only if hyperthreading is available.
 591     _logical_processors_per_package = logical_processor_count();
 592     _L1_data_cache_line_size = L1_line_size();
 593   }
 594 
 595   _supports_cx8 = supports_cmpxchg8();
 596   // xchg and xadd instructions
 597   _supports_atomic_getset4 = true;
 598   _supports_atomic_getadd4 = true;
 599   LP64_ONLY(_supports_atomic_getset8 = true);
 600   LP64_ONLY(_supports_atomic_getadd8 = true);
 601 
 602 #ifdef _LP64
 603   // OS should support SSE for x64 and hardware should support at least SSE2.
 604   if (!VM_Version::supports_sse2()) {
 605     vm_exit_during_initialization(&quot;Unknown x64 processor: SSE2 not supported&quot;);
 606   }
 607   // in 64 bit the use of SSE2 is the minimum
 608   if (UseSSE &lt; 2) UseSSE = 2;
 609 #endif
 610 
 611 #ifdef AMD64
 612   // flush_icache_stub have to be generated first.
 613   // That is why Icache line size is hard coded in ICache class,
 614   // see icache_x86.hpp. It is also the reason why we can&#39;t use
 615   // clflush instruction in 32-bit VM since it could be running
 616   // on CPU which does not support it.
 617   //
 618   // The only thing we can do is to verify that flushed
 619   // ICache::line_size has correct value.
 620   guarantee(_cpuid_info.std_cpuid1_edx.bits.clflush != 0, &quot;clflush is not supported&quot;);
 621   // clflush_size is size in quadwords (8 bytes).
 622   guarantee(_cpuid_info.std_cpuid1_ebx.bits.clflush_size == 8, &quot;such clflush size is not supported&quot;);
 623 #endif
 624 
 625 #ifdef _LP64
 626   // assigning this field effectively enables Unsafe.writebackMemory()
 627   // by initing UnsafeConstant.DATA_CACHE_LINE_FLUSH_SIZE to non-zero
 628   // that is only implemented on x86_64 and only if the OS plays ball
 629   if (os::supports_map_sync()) {
 630     // publish data cache line flush size to generic field, otherwise
 631     // let if default to zero thereby disabling writeback
 632     _data_cache_line_flush_size = _cpuid_info.std_cpuid1_ebx.bits.clflush_size * 8;
 633   }
 634 #endif
 635   // If the OS doesn&#39;t support SSE, we can&#39;t use this feature even if the HW does
 636   if (!os::supports_sse())
 637     _features &amp;= ~(CPU_SSE|CPU_SSE2|CPU_SSE3|CPU_SSSE3|CPU_SSE4A|CPU_SSE4_1|CPU_SSE4_2);
 638 
 639   if (UseSSE &lt; 4) {
 640     _features &amp;= ~CPU_SSE4_1;
 641     _features &amp;= ~CPU_SSE4_2;
 642   }
 643 
 644   if (UseSSE &lt; 3) {
 645     _features &amp;= ~CPU_SSE3;
 646     _features &amp;= ~CPU_SSSE3;
 647     _features &amp;= ~CPU_SSE4A;
 648   }
 649 
 650   if (UseSSE &lt; 2)
 651     _features &amp;= ~CPU_SSE2;
 652 
 653   if (UseSSE &lt; 1)
 654     _features &amp;= ~CPU_SSE;
 655 
 656   //since AVX instructions is slower than SSE in some ZX cpus, force USEAVX=0.
 657   if (is_zx() &amp;&amp; ((cpu_family() == 6) || (cpu_family() == 7))) {
 658     UseAVX = 0;
 659   }
 660 
 661   // first try initial setting and detect what we can support
 662   int use_avx_limit = 0;
 663   if (UseAVX &gt; 0) {
 664     if (UseAVX &gt; 2 &amp;&amp; supports_evex()) {
 665       use_avx_limit = 3;
 666     } else if (UseAVX &gt; 1 &amp;&amp; supports_avx2()) {
 667       use_avx_limit = 2;
 668     } else if (UseAVX &gt; 0 &amp;&amp; supports_avx()) {
 669       use_avx_limit = 1;
 670     } else {
 671       use_avx_limit = 0;
 672     }
 673   }
 674   if (FLAG_IS_DEFAULT(UseAVX)) {
 675     // Don&#39;t use AVX-512 on older Skylakes unless explicitly requested.
 676     if (use_avx_limit &gt; 2 &amp;&amp; is_intel_skylake() &amp;&amp; _stepping &lt; 5) {
 677       FLAG_SET_DEFAULT(UseAVX, 2);
 678     } else {
 679       FLAG_SET_DEFAULT(UseAVX, use_avx_limit);
 680     }
 681   }
 682   if (UseAVX &gt; use_avx_limit) {
 683     warning(&quot;UseAVX=%d is not supported on this CPU, setting it to UseAVX=%d&quot;, (int) UseAVX, use_avx_limit);
 684     FLAG_SET_DEFAULT(UseAVX, use_avx_limit);
 685   } else if (UseAVX &lt; 0) {
 686     warning(&quot;UseAVX=%d is not valid, setting it to UseAVX=0&quot;, (int) UseAVX);
 687     FLAG_SET_DEFAULT(UseAVX, 0);
 688   }
 689 
 690   if (UseAVX &lt; 3) {
 691     _features &amp;= ~CPU_AVX512F;
 692     _features &amp;= ~CPU_AVX512DQ;
 693     _features &amp;= ~CPU_AVX512CD;
 694     _features &amp;= ~CPU_AVX512BW;
 695     _features &amp;= ~CPU_AVX512VL;
 696     _features &amp;= ~CPU_AVX512_VPOPCNTDQ;
 697     _features &amp;= ~CPU_AVX512_VPCLMULQDQ;
 698     _features &amp;= ~CPU_VAES;
 699     _features &amp;= ~CPU_VNNI;
 700     _features &amp;= ~CPU_VBMI2;
 701   }
 702 
 703   if (UseAVX &lt; 2)
 704     _features &amp;= ~CPU_AVX2;
 705 
 706   if (UseAVX &lt; 1) {
 707     _features &amp;= ~CPU_AVX;
 708     _features &amp;= ~CPU_VZEROUPPER;
 709   }
 710 
 711   if (logical_processors_per_package() == 1) {
 712     // HT processor could be installed on a system which doesn&#39;t support HT.
 713     _features &amp;= ~CPU_HT;
 714   }
 715 
 716   if (is_intel()) { // Intel cpus specific settings
 717     if (is_knights_family()) {
 718       _features &amp;= ~CPU_VZEROUPPER;
 719     }
 720   }
 721 
 722   char buf[256];
 723   jio_snprintf(buf, sizeof(buf), &quot;(%u cores per cpu, %u threads per core) family %d model %d stepping %d%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s&quot;,
 724                cores_per_cpu(), threads_per_core(),
 725                cpu_family(), _model, _stepping,
 726                (supports_cmov() ? &quot;, cmov&quot; : &quot;&quot;),
 727                (supports_cmpxchg8() ? &quot;, cx8&quot; : &quot;&quot;),
 728                (supports_fxsr() ? &quot;, fxsr&quot; : &quot;&quot;),
 729                (supports_mmx()  ? &quot;, mmx&quot;  : &quot;&quot;),
 730                (supports_sse()  ? &quot;, sse&quot;  : &quot;&quot;),
 731                (supports_sse2() ? &quot;, sse2&quot; : &quot;&quot;),
 732                (supports_sse3() ? &quot;, sse3&quot; : &quot;&quot;),
 733                (supports_ssse3()? &quot;, ssse3&quot;: &quot;&quot;),
 734                (supports_sse4_1() ? &quot;, sse4.1&quot; : &quot;&quot;),
 735                (supports_sse4_2() ? &quot;, sse4.2&quot; : &quot;&quot;),
 736                (supports_popcnt() ? &quot;, popcnt&quot; : &quot;&quot;),
 737                (supports_avx()    ? &quot;, avx&quot; : &quot;&quot;),
 738                (supports_avx2()   ? &quot;, avx2&quot; : &quot;&quot;),
 739                (supports_aes()    ? &quot;, aes&quot; : &quot;&quot;),
 740                (supports_clmul()  ? &quot;, clmul&quot; : &quot;&quot;),
 741                (supports_erms()   ? &quot;, erms&quot; : &quot;&quot;),
 742                (supports_rtm()    ? &quot;, rtm&quot; : &quot;&quot;),
 743                (supports_mmx_ext() ? &quot;, mmxext&quot; : &quot;&quot;),
 744                (supports_3dnow_prefetch() ? &quot;, 3dnowpref&quot; : &quot;&quot;),
 745                (supports_lzcnt()   ? &quot;, lzcnt&quot;: &quot;&quot;),
 746                (supports_sse4a()   ? &quot;, sse4a&quot;: &quot;&quot;),
 747                (supports_ht() ? &quot;, ht&quot;: &quot;&quot;),
 748                (supports_tsc() ? &quot;, tsc&quot;: &quot;&quot;),
 749                (supports_tscinv_bit() ? &quot;, tscinvbit&quot;: &quot;&quot;),
 750                (supports_tscinv() ? &quot;, tscinv&quot;: &quot;&quot;),
 751                (supports_bmi1() ? &quot;, bmi1&quot; : &quot;&quot;),
 752                (supports_bmi2() ? &quot;, bmi2&quot; : &quot;&quot;),
 753                (supports_adx() ? &quot;, adx&quot; : &quot;&quot;),
 754                (supports_evex() ? &quot;, evex&quot; : &quot;&quot;),
 755                (supports_sha() ? &quot;, sha&quot; : &quot;&quot;),
 756                (supports_fma() ? &quot;, fma&quot; : &quot;&quot;),
 757                (supports_vbmi2() ? &quot;, vbmi2&quot; : &quot;&quot;),
 758                (supports_vaes() ? &quot;, vaes&quot; : &quot;&quot;),
 759                (supports_vnni() ? &quot;, vnni&quot; : &quot;&quot;));
 760   _features_string = os::strdup(buf);
 761 
 762   // UseSSE is set to the smaller of what hardware supports and what
 763   // the command line requires.  I.e., you cannot set UseSSE to 2 on
 764   // older Pentiums which do not support it.
 765   int use_sse_limit = 0;
 766   if (UseSSE &gt; 0) {
 767     if (UseSSE &gt; 3 &amp;&amp; supports_sse4_1()) {
 768       use_sse_limit = 4;
 769     } else if (UseSSE &gt; 2 &amp;&amp; supports_sse3()) {
 770       use_sse_limit = 3;
 771     } else if (UseSSE &gt; 1 &amp;&amp; supports_sse2()) {
 772       use_sse_limit = 2;
 773     } else if (UseSSE &gt; 0 &amp;&amp; supports_sse()) {
 774       use_sse_limit = 1;
 775     } else {
 776       use_sse_limit = 0;
 777     }
 778   }
 779   if (FLAG_IS_DEFAULT(UseSSE)) {
 780     FLAG_SET_DEFAULT(UseSSE, use_sse_limit);
 781   } else if (UseSSE &gt; use_sse_limit) {
 782     warning(&quot;UseSSE=%d is not supported on this CPU, setting it to UseSSE=%d&quot;, (int) UseSSE, use_sse_limit);
 783     FLAG_SET_DEFAULT(UseSSE, use_sse_limit);
 784   } else if (UseSSE &lt; 0) {
 785     warning(&quot;UseSSE=%d is not valid, setting it to UseSSE=0&quot;, (int) UseSSE);
 786     FLAG_SET_DEFAULT(UseSSE, 0);
 787   }
 788 
 789   // Use AES instructions if available.
 790   if (supports_aes()) {
 791     if (FLAG_IS_DEFAULT(UseAES)) {
 792       FLAG_SET_DEFAULT(UseAES, true);
 793     }
 794     if (!UseAES) {
 795       if (UseAESIntrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESIntrinsics)) {
 796         warning(&quot;AES intrinsics require UseAES flag to be enabled. Intrinsics will be disabled.&quot;);
 797       }
 798       FLAG_SET_DEFAULT(UseAESIntrinsics, false);
 799     } else {
 800       if (UseSSE &gt; 2) {
 801         if (FLAG_IS_DEFAULT(UseAESIntrinsics)) {
 802           FLAG_SET_DEFAULT(UseAESIntrinsics, true);
 803         }
 804       } else {
 805         // The AES intrinsic stubs require AES instruction support (of course)
 806         // but also require sse3 mode or higher for instructions it use.
 807         if (UseAESIntrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESIntrinsics)) {
 808           warning(&quot;X86 AES intrinsics require SSE3 instructions or higher. Intrinsics will be disabled.&quot;);
 809         }
 810         FLAG_SET_DEFAULT(UseAESIntrinsics, false);
 811       }
 812 
 813       // --AES-CTR begins--
 814       if (!UseAESIntrinsics) {
 815         if (UseAESCTRIntrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESCTRIntrinsics)) {
 816           warning(&quot;AES-CTR intrinsics require UseAESIntrinsics flag to be enabled. Intrinsics will be disabled.&quot;);
 817           FLAG_SET_DEFAULT(UseAESCTRIntrinsics, false);
 818         }
 819       } else {
 820         if (supports_sse4_1()) {
 821           if (FLAG_IS_DEFAULT(UseAESCTRIntrinsics)) {
 822             FLAG_SET_DEFAULT(UseAESCTRIntrinsics, true);
 823           }
 824         } else {
 825            // The AES-CTR intrinsic stubs require AES instruction support (of course)
 826            // but also require sse4.1 mode or higher for instructions it use.
 827           if (UseAESCTRIntrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESCTRIntrinsics)) {
 828              warning(&quot;X86 AES-CTR intrinsics require SSE4.1 instructions or higher. Intrinsics will be disabled.&quot;);
 829            }
 830            FLAG_SET_DEFAULT(UseAESCTRIntrinsics, false);
 831         }
 832       }
 833       // --AES-CTR ends--
 834     }
 835   } else if (UseAES || UseAESIntrinsics || UseAESCTRIntrinsics) {
 836     if (UseAES &amp;&amp; !FLAG_IS_DEFAULT(UseAES)) {
 837       warning(&quot;AES instructions are not available on this CPU&quot;);
 838       FLAG_SET_DEFAULT(UseAES, false);
 839     }
 840     if (UseAESIntrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESIntrinsics)) {
 841       warning(&quot;AES intrinsics are not available on this CPU&quot;);
 842       FLAG_SET_DEFAULT(UseAESIntrinsics, false);
 843     }
 844     if (UseAESCTRIntrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESCTRIntrinsics)) {
 845       warning(&quot;AES-CTR intrinsics are not available on this CPU&quot;);
 846       FLAG_SET_DEFAULT(UseAESCTRIntrinsics, false);
 847     }
 848   }
 849 
 850   // Use CLMUL instructions if available.
 851   if (supports_clmul()) {
 852     if (FLAG_IS_DEFAULT(UseCLMUL)) {
 853       UseCLMUL = true;
 854     }
 855   } else if (UseCLMUL) {
 856     if (!FLAG_IS_DEFAULT(UseCLMUL))
 857       warning(&quot;CLMUL instructions not available on this CPU (AVX may also be required)&quot;);
 858     FLAG_SET_DEFAULT(UseCLMUL, false);
 859   }
 860 
 861   if (UseCLMUL &amp;&amp; (UseSSE &gt; 2)) {
 862     if (FLAG_IS_DEFAULT(UseCRC32Intrinsics)) {
 863       UseCRC32Intrinsics = true;
 864     }
 865   } else if (UseCRC32Intrinsics) {
 866     if (!FLAG_IS_DEFAULT(UseCRC32Intrinsics))
 867       warning(&quot;CRC32 Intrinsics requires CLMUL instructions (not available on this CPU)&quot;);
 868     FLAG_SET_DEFAULT(UseCRC32Intrinsics, false);
 869   }
 870 
 871   if (supports_sse4_2() &amp;&amp; supports_clmul()) {
 872     if (FLAG_IS_DEFAULT(UseCRC32CIntrinsics)) {
 873       UseCRC32CIntrinsics = true;
 874     }
 875   } else if (UseCRC32CIntrinsics) {
 876     if (!FLAG_IS_DEFAULT(UseCRC32CIntrinsics)) {
 877       warning(&quot;CRC32C intrinsics are not available on this CPU&quot;);
 878     }
 879     FLAG_SET_DEFAULT(UseCRC32CIntrinsics, false);
 880   }
 881 
 882   // GHASH/GCM intrinsics
 883   if (UseCLMUL &amp;&amp; (UseSSE &gt; 2)) {
 884     if (FLAG_IS_DEFAULT(UseGHASHIntrinsics)) {
 885       UseGHASHIntrinsics = true;
 886     }
 887   } else if (UseGHASHIntrinsics) {
 888     if (!FLAG_IS_DEFAULT(UseGHASHIntrinsics))
 889       warning(&quot;GHASH intrinsic requires CLMUL and SSE2 instructions on this CPU&quot;);
 890     FLAG_SET_DEFAULT(UseGHASHIntrinsics, false);
 891   }
 892 
 893   // Base64 Intrinsics (Check the condition for which the intrinsic will be active)
 894   if ((UseAVX &gt; 2) &amp;&amp; supports_avx512vl() &amp;&amp; supports_avx512bw()) {
 895     if (FLAG_IS_DEFAULT(UseBASE64Intrinsics)) {
 896       UseBASE64Intrinsics = true;
 897     }
 898   } else if (UseBASE64Intrinsics) {
 899      if (!FLAG_IS_DEFAULT(UseBASE64Intrinsics))
 900       warning(&quot;Base64 intrinsic requires EVEX instructions on this CPU&quot;);
 901     FLAG_SET_DEFAULT(UseBASE64Intrinsics, false);
 902   }
 903 
 904   if (supports_fma() &amp;&amp; UseSSE &gt;= 2) { // Check UseSSE since FMA code uses SSE instructions
 905     if (FLAG_IS_DEFAULT(UseFMA)) {
 906       UseFMA = true;
 907     }
 908   } else if (UseFMA) {
 909     warning(&quot;FMA instructions are not available on this CPU&quot;);
 910     FLAG_SET_DEFAULT(UseFMA, false);
 911   }
 912 
 913   if (supports_sha() LP64_ONLY(|| supports_avx2() &amp;&amp; supports_bmi2())) {
 914     if (FLAG_IS_DEFAULT(UseSHA)) {
 915       UseSHA = true;
 916     }
 917   } else if (UseSHA) {
 918     warning(&quot;SHA instructions are not available on this CPU&quot;);
 919     FLAG_SET_DEFAULT(UseSHA, false);
 920   }
 921 
 922   if (supports_sha() &amp;&amp; supports_sse4_1() &amp;&amp; UseSHA) {
 923     if (FLAG_IS_DEFAULT(UseSHA1Intrinsics)) {
 924       FLAG_SET_DEFAULT(UseSHA1Intrinsics, true);
 925     }
 926   } else if (UseSHA1Intrinsics) {
 927     warning(&quot;Intrinsics for SHA-1 crypto hash functions not available on this CPU.&quot;);
 928     FLAG_SET_DEFAULT(UseSHA1Intrinsics, false);
 929   }
 930 
 931   if (supports_sse4_1() &amp;&amp; UseSHA) {
 932     if (FLAG_IS_DEFAULT(UseSHA256Intrinsics)) {
 933       FLAG_SET_DEFAULT(UseSHA256Intrinsics, true);
 934     }
 935   } else if (UseSHA256Intrinsics) {
 936     warning(&quot;Intrinsics for SHA-224 and SHA-256 crypto hash functions not available on this CPU.&quot;);
 937     FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);
 938   }
 939 
 940 #ifdef _LP64
 941   // These are only supported on 64-bit
 942   if (UseSHA &amp;&amp; supports_avx2() &amp;&amp; supports_bmi2()) {
 943     if (FLAG_IS_DEFAULT(UseSHA512Intrinsics)) {
 944       FLAG_SET_DEFAULT(UseSHA512Intrinsics, true);
 945     }
 946   } else
 947 #endif
 948   if (UseSHA512Intrinsics) {
 949     warning(&quot;Intrinsics for SHA-384 and SHA-512 crypto hash functions not available on this CPU.&quot;);
 950     FLAG_SET_DEFAULT(UseSHA512Intrinsics, false);
 951   }
 952 
 953   if (!(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics)) {
 954     FLAG_SET_DEFAULT(UseSHA, false);
 955   }
 956 
 957   if (UseAdler32Intrinsics) {
 958     warning(&quot;Adler32Intrinsics not available on this CPU.&quot;);
 959     FLAG_SET_DEFAULT(UseAdler32Intrinsics, false);
 960   }
 961 
 962   if (!supports_rtm() &amp;&amp; UseRTMLocking) {
 963     // Can&#39;t continue because UseRTMLocking affects UseBiasedLocking flag
 964     // setting during arguments processing. See use_biased_locking().
 965     // VM_Version_init() is executed after UseBiasedLocking is used
 966     // in Thread::allocate().
 967     vm_exit_during_initialization(&quot;RTM instructions are not available on this CPU&quot;);
 968   }
 969 
 970 #if INCLUDE_RTM_OPT
 971   if (UseRTMLocking) {
 972     if (is_client_compilation_mode_vm()) {
 973       // Only C2 does RTM locking optimization.
 974       // Can&#39;t continue because UseRTMLocking affects UseBiasedLocking flag
 975       // setting during arguments processing. See use_biased_locking().
 976       vm_exit_during_initialization(&quot;RTM locking optimization is not supported in this VM&quot;);
 977     }
 978     if (is_intel_family_core()) {
 979       if ((_model == CPU_MODEL_HASWELL_E3) ||
 980           (_model == CPU_MODEL_HASWELL_E7 &amp;&amp; _stepping &lt; 3) ||
 981           (_model == CPU_MODEL_BROADWELL  &amp;&amp; _stepping &lt; 4)) {
 982         // currently a collision between SKL and HSW_E3
 983         if (!UnlockExperimentalVMOptions &amp;&amp; UseAVX &lt; 3) {
 984           vm_exit_during_initialization(&quot;UseRTMLocking is only available as experimental option on this &quot;
 985                                         &quot;platform. It must be enabled via -XX:+UnlockExperimentalVMOptions flag.&quot;);
 986         } else {
 987           warning(&quot;UseRTMLocking is only available as experimental option on this platform.&quot;);
 988         }
 989       }
 990     }
 991     if (!FLAG_IS_CMDLINE(UseRTMLocking)) {
 992       // RTM locking should be used only for applications with
 993       // high lock contention. For now we do not use it by default.
 994       vm_exit_during_initialization(&quot;UseRTMLocking flag should be only set on command line&quot;);
 995     }
 996   } else { // !UseRTMLocking
 997     if (UseRTMForStackLocks) {
 998       if (!FLAG_IS_DEFAULT(UseRTMForStackLocks)) {
 999         warning(&quot;UseRTMForStackLocks flag should be off when UseRTMLocking flag is off&quot;);
1000       }
1001       FLAG_SET_DEFAULT(UseRTMForStackLocks, false);
1002     }
1003     if (UseRTMDeopt) {
1004       FLAG_SET_DEFAULT(UseRTMDeopt, false);
1005     }
1006     if (PrintPreciseRTMLockingStatistics) {
1007       FLAG_SET_DEFAULT(PrintPreciseRTMLockingStatistics, false);
1008     }
1009   }
1010 #else
1011   if (UseRTMLocking) {
1012     // Only C2 does RTM locking optimization.
1013     // Can&#39;t continue because UseRTMLocking affects UseBiasedLocking flag
1014     // setting during arguments processing. See use_biased_locking().
1015     vm_exit_during_initialization(&quot;RTM locking optimization is not supported in this VM&quot;);
1016   }
1017 #endif
1018 
1019 #ifdef COMPILER2
1020   if (UseFPUForSpilling) {
1021     if (UseSSE &lt; 2) {
1022       // Only supported with SSE2+
1023       FLAG_SET_DEFAULT(UseFPUForSpilling, false);
1024     }
1025   }
1026 #endif
1027 
1028 #if COMPILER2_OR_JVMCI
1029   int max_vector_size = 0;
1030   if (UseSSE &lt; 2) {
1031     // Vectors (in XMM) are only supported with SSE2+
1032     // SSE is always 2 on x64.
1033     max_vector_size = 0;
1034   } else if (UseAVX == 0 || !os_supports_avx_vectors()) {
1035     // 16 byte vectors (in XMM) are supported with SSE2+
1036     max_vector_size = 16;
1037   } else if (UseAVX == 1 || UseAVX == 2) {
1038     // 32 bytes vectors (in YMM) are only supported with AVX+
1039     max_vector_size = 32;
1040   } else if (UseAVX &gt; 2) {
1041     // 64 bytes vectors (in ZMM) are only supported with AVX 3
1042     max_vector_size = 64;
1043   }
1044 
1045 #ifdef _LP64
1046   int min_vector_size = 4; // We require MaxVectorSize to be at least 4 on 64bit
1047 #else
1048   int min_vector_size = 0;
1049 #endif
1050 
1051   if (!FLAG_IS_DEFAULT(MaxVectorSize)) {
1052     if (MaxVectorSize &lt; min_vector_size) {
1053       warning(&quot;MaxVectorSize must be at least %i on this platform&quot;, min_vector_size);
1054       FLAG_SET_DEFAULT(MaxVectorSize, min_vector_size);
1055     }
1056     if (MaxVectorSize &gt; max_vector_size) {
1057       warning(&quot;MaxVectorSize must be at most %i on this platform&quot;, max_vector_size);
1058       FLAG_SET_DEFAULT(MaxVectorSize, max_vector_size);
1059     }
1060     if (!is_power_of_2(MaxVectorSize)) {
1061       warning(&quot;MaxVectorSize must be a power of 2, setting to default: %i&quot;, max_vector_size);
1062       FLAG_SET_DEFAULT(MaxVectorSize, max_vector_size);
1063     }
1064   } else {
1065     // If default, use highest supported configuration
1066     FLAG_SET_DEFAULT(MaxVectorSize, max_vector_size);
1067   }
1068 
1069 #if defined(COMPILER2) &amp;&amp; defined(ASSERT)
1070   if (MaxVectorSize &gt; 0) {
1071     if (supports_avx() &amp;&amp; PrintMiscellaneous &amp;&amp; Verbose &amp;&amp; TraceNewVectors) {
1072       tty-&gt;print_cr(&quot;State of YMM registers after signal handle:&quot;);
1073       int nreg = 2 LP64_ONLY(+2);
1074       const char* ymm_name[4] = {&quot;0&quot;, &quot;7&quot;, &quot;8&quot;, &quot;15&quot;};
1075       for (int i = 0; i &lt; nreg; i++) {
1076         tty-&gt;print(&quot;YMM%s:&quot;, ymm_name[i]);
1077         for (int j = 7; j &gt;=0; j--) {
1078           tty-&gt;print(&quot; %x&quot;, _cpuid_info.ymm_save[i*8 + j]);
1079         }
1080         tty-&gt;cr();
1081       }
1082     }
1083   }
1084 #endif // COMPILER2 &amp;&amp; ASSERT
1085 
1086   if (!FLAG_IS_DEFAULT(AVX3Threshold)) {
1087     if (!is_power_of_2(AVX3Threshold)) {
1088       warning(&quot;AVX3Threshold must be a power of 2&quot;);
1089       FLAG_SET_DEFAULT(AVX3Threshold, 4096);
1090     }
1091   }
1092 
1093 #ifdef _LP64
1094   if (FLAG_IS_DEFAULT(UseMultiplyToLenIntrinsic)) {
1095     UseMultiplyToLenIntrinsic = true;
1096   }
1097   if (FLAG_IS_DEFAULT(UseSquareToLenIntrinsic)) {
1098     UseSquareToLenIntrinsic = true;
1099   }
1100   if (FLAG_IS_DEFAULT(UseMulAddIntrinsic)) {
1101     UseMulAddIntrinsic = true;
1102   }
1103   if (FLAG_IS_DEFAULT(UseMontgomeryMultiplyIntrinsic)) {
1104     UseMontgomeryMultiplyIntrinsic = true;
1105   }
1106   if (FLAG_IS_DEFAULT(UseMontgomerySquareIntrinsic)) {
1107     UseMontgomerySquareIntrinsic = true;
1108   }
1109 #else
1110   if (UseMultiplyToLenIntrinsic) {
1111     if (!FLAG_IS_DEFAULT(UseMultiplyToLenIntrinsic)) {
1112       warning(&quot;multiplyToLen intrinsic is not available in 32-bit VM&quot;);
1113     }
1114     FLAG_SET_DEFAULT(UseMultiplyToLenIntrinsic, false);
1115   }
1116   if (UseMontgomeryMultiplyIntrinsic) {
1117     if (!FLAG_IS_DEFAULT(UseMontgomeryMultiplyIntrinsic)) {
1118       warning(&quot;montgomeryMultiply intrinsic is not available in 32-bit VM&quot;);
1119     }
1120     FLAG_SET_DEFAULT(UseMontgomeryMultiplyIntrinsic, false);
1121   }
1122   if (UseMontgomerySquareIntrinsic) {
1123     if (!FLAG_IS_DEFAULT(UseMontgomerySquareIntrinsic)) {
1124       warning(&quot;montgomerySquare intrinsic is not available in 32-bit VM&quot;);
1125     }
1126     FLAG_SET_DEFAULT(UseMontgomerySquareIntrinsic, false);
1127   }
1128   if (UseSquareToLenIntrinsic) {
1129     if (!FLAG_IS_DEFAULT(UseSquareToLenIntrinsic)) {
1130       warning(&quot;squareToLen intrinsic is not available in 32-bit VM&quot;);
1131     }
1132     FLAG_SET_DEFAULT(UseSquareToLenIntrinsic, false);
1133   }
1134   if (UseMulAddIntrinsic) {
1135     if (!FLAG_IS_DEFAULT(UseMulAddIntrinsic)) {
1136       warning(&quot;mulAdd intrinsic is not available in 32-bit VM&quot;);
1137     }
1138     FLAG_SET_DEFAULT(UseMulAddIntrinsic, false);
1139   }
1140 #endif // _LP64
1141 #endif // COMPILER2_OR_JVMCI
1142 
1143   // On new cpus instructions which update whole XMM register should be used
1144   // to prevent partial register stall due to dependencies on high half.
1145   //
1146   // UseXmmLoadAndClearUpper == true  --&gt; movsd(xmm, mem)
1147   // UseXmmLoadAndClearUpper == false --&gt; movlpd(xmm, mem)
1148   // UseXmmRegToRegMoveAll == true  --&gt; movaps(xmm, xmm), movapd(xmm, xmm).
1149   // UseXmmRegToRegMoveAll == false --&gt; movss(xmm, xmm),  movsd(xmm, xmm).
1150 
1151 
1152   if (is_zx()) { // ZX cpus specific settings
1153     if (FLAG_IS_DEFAULT(UseStoreImmI16)) {
1154       UseStoreImmI16 = false; // don&#39;t use it on ZX cpus
1155     }
1156     if ((cpu_family() == 6) || (cpu_family() == 7)) {
1157       if (FLAG_IS_DEFAULT(UseAddressNop)) {
1158         // Use it on all ZX cpus
1159         UseAddressNop = true;
1160       }
1161     }
1162     if (FLAG_IS_DEFAULT(UseXmmLoadAndClearUpper)) {
1163       UseXmmLoadAndClearUpper = true; // use movsd on all ZX cpus
1164     }
1165     if (FLAG_IS_DEFAULT(UseXmmRegToRegMoveAll)) {
1166       if (supports_sse3()) {
1167         UseXmmRegToRegMoveAll = true; // use movaps, movapd on new ZX cpus
1168       } else {
1169         UseXmmRegToRegMoveAll = false;
1170       }
1171     }
1172     if (((cpu_family() == 6) || (cpu_family() == 7)) &amp;&amp; supports_sse3()) { // new ZX cpus
1173 #ifdef COMPILER2
1174       if (FLAG_IS_DEFAULT(MaxLoopPad)) {
1175         // For new ZX cpus do the next optimization:
1176         // don&#39;t align the beginning of a loop if there are enough instructions
1177         // left (NumberOfLoopInstrToAlign defined in c2_globals.hpp)
1178         // in current fetch line (OptoLoopAlignment) or the padding
1179         // is big (&gt; MaxLoopPad).
1180         // Set MaxLoopPad to 11 for new ZX cpus to reduce number of
1181         // generated NOP instructions. 11 is the largest size of one
1182         // address NOP instruction &#39;0F 1F&#39; (see Assembler::nop(i)).
1183         MaxLoopPad = 11;
1184       }
1185 #endif // COMPILER2
1186       if (FLAG_IS_DEFAULT(UseXMMForArrayCopy)) {
1187         UseXMMForArrayCopy = true; // use SSE2 movq on new ZX cpus
1188       }
1189       if (supports_sse4_2()) { // new ZX cpus
1190         if (FLAG_IS_DEFAULT(UseUnalignedLoadStores)) {
1191           UseUnalignedLoadStores = true; // use movdqu on newest ZX cpus
1192         }
1193       }
1194       if (supports_sse4_2()) {
1195         if (FLAG_IS_DEFAULT(UseSSE42Intrinsics)) {
1196           FLAG_SET_DEFAULT(UseSSE42Intrinsics, true);
1197         }
1198       } else {
1199         if (UseSSE42Intrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESIntrinsics)) {
1200           warning(&quot;SSE4.2 intrinsics require SSE4.2 instructions or higher. Intrinsics will be disabled.&quot;);
1201         }
1202         FLAG_SET_DEFAULT(UseSSE42Intrinsics, false);
1203       }
1204     }
1205 
1206     if (FLAG_IS_DEFAULT(AllocatePrefetchInstr) &amp;&amp; supports_3dnow_prefetch()) {
1207       FLAG_SET_DEFAULT(AllocatePrefetchInstr, 3);
1208     }
1209   }
1210 
1211   if (is_amd_family()) { // AMD cpus specific settings
1212     if (supports_sse2() &amp;&amp; FLAG_IS_DEFAULT(UseAddressNop)) {
1213       // Use it on new AMD cpus starting from Opteron.
1214       UseAddressNop = true;
1215     }
1216     if (supports_sse2() &amp;&amp; FLAG_IS_DEFAULT(UseNewLongLShift)) {
1217       // Use it on new AMD cpus starting from Opteron.
1218       UseNewLongLShift = true;
1219     }
1220     if (FLAG_IS_DEFAULT(UseXmmLoadAndClearUpper)) {
1221       if (supports_sse4a()) {
1222         UseXmmLoadAndClearUpper = true; // use movsd only on &#39;10h&#39; Opteron
1223       } else {
1224         UseXmmLoadAndClearUpper = false;
1225       }
1226     }
1227     if (FLAG_IS_DEFAULT(UseXmmRegToRegMoveAll)) {
1228       if (supports_sse4a()) {
1229         UseXmmRegToRegMoveAll = true; // use movaps, movapd only on &#39;10h&#39;
1230       } else {
1231         UseXmmRegToRegMoveAll = false;
1232       }
1233     }
1234     if (FLAG_IS_DEFAULT(UseXmmI2F)) {
1235       if (supports_sse4a()) {
1236         UseXmmI2F = true;
1237       } else {
1238         UseXmmI2F = false;
1239       }
1240     }
1241     if (FLAG_IS_DEFAULT(UseXmmI2D)) {
1242       if (supports_sse4a()) {
1243         UseXmmI2D = true;
1244       } else {
1245         UseXmmI2D = false;
1246       }
1247     }
1248     if (supports_sse4_2()) {
1249       if (FLAG_IS_DEFAULT(UseSSE42Intrinsics)) {
1250         FLAG_SET_DEFAULT(UseSSE42Intrinsics, true);
1251       }
1252     } else {
1253       if (UseSSE42Intrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESIntrinsics)) {
1254         warning(&quot;SSE4.2 intrinsics require SSE4.2 instructions or higher. Intrinsics will be disabled.&quot;);
1255       }
1256       FLAG_SET_DEFAULT(UseSSE42Intrinsics, false);
1257     }
1258 
1259     // some defaults for AMD family 15h
1260     if (cpu_family() == 0x15) {
1261       // On family 15h processors default is no sw prefetch
1262       if (FLAG_IS_DEFAULT(AllocatePrefetchStyle)) {
1263         FLAG_SET_DEFAULT(AllocatePrefetchStyle, 0);
1264       }
1265       // Also, if some other prefetch style is specified, default instruction type is PREFETCHW
1266       if (FLAG_IS_DEFAULT(AllocatePrefetchInstr)) {
1267         FLAG_SET_DEFAULT(AllocatePrefetchInstr, 3);
1268       }
1269       // On family 15h processors use XMM and UnalignedLoadStores for Array Copy
1270       if (supports_sse2() &amp;&amp; FLAG_IS_DEFAULT(UseXMMForArrayCopy)) {
1271         FLAG_SET_DEFAULT(UseXMMForArrayCopy, true);
1272       }
1273       if (supports_sse2() &amp;&amp; FLAG_IS_DEFAULT(UseUnalignedLoadStores)) {
1274         FLAG_SET_DEFAULT(UseUnalignedLoadStores, true);
1275       }
1276     }
1277 
1278 #ifdef COMPILER2
1279     if (cpu_family() &lt; 0x17 &amp;&amp; MaxVectorSize &gt; 16) {
1280       // Limit vectors size to 16 bytes on AMD cpus &lt; 17h.
1281       FLAG_SET_DEFAULT(MaxVectorSize, 16);
1282     }
1283 #endif // COMPILER2
1284 
1285     // Some defaults for AMD family 17h || Hygon family 18h
1286     if (cpu_family() == 0x17 || cpu_family() == 0x18) {
1287       // On family 17h processors use XMM and UnalignedLoadStores for Array Copy
1288       if (supports_sse2() &amp;&amp; FLAG_IS_DEFAULT(UseXMMForArrayCopy)) {
1289         FLAG_SET_DEFAULT(UseXMMForArrayCopy, true);
1290       }
1291       if (supports_sse2() &amp;&amp; FLAG_IS_DEFAULT(UseUnalignedLoadStores)) {
1292         FLAG_SET_DEFAULT(UseUnalignedLoadStores, true);
1293       }
1294 #ifdef COMPILER2
1295       if (supports_sse4_2() &amp;&amp; FLAG_IS_DEFAULT(UseFPUForSpilling)) {
1296         FLAG_SET_DEFAULT(UseFPUForSpilling, true);
1297       }
1298 #endif
1299     }
1300   }
1301 
1302   if (is_intel()) { // Intel cpus specific settings
1303     if (FLAG_IS_DEFAULT(UseStoreImmI16)) {
1304       UseStoreImmI16 = false; // don&#39;t use it on Intel cpus
1305     }
1306     if (cpu_family() == 6 || cpu_family() == 15) {
1307       if (FLAG_IS_DEFAULT(UseAddressNop)) {
1308         // Use it on all Intel cpus starting from PentiumPro
1309         UseAddressNop = true;
1310       }
1311     }
1312     if (FLAG_IS_DEFAULT(UseXmmLoadAndClearUpper)) {
1313       UseXmmLoadAndClearUpper = true; // use movsd on all Intel cpus
1314     }
1315     if (FLAG_IS_DEFAULT(UseXmmRegToRegMoveAll)) {
1316       if (supports_sse3()) {
1317         UseXmmRegToRegMoveAll = true; // use movaps, movapd on new Intel cpus
1318       } else {
1319         UseXmmRegToRegMoveAll = false;
1320       }
1321     }
1322     if (cpu_family() == 6 &amp;&amp; supports_sse3()) { // New Intel cpus
1323 #ifdef COMPILER2
1324       if (FLAG_IS_DEFAULT(MaxLoopPad)) {
1325         // For new Intel cpus do the next optimization:
1326         // don&#39;t align the beginning of a loop if there are enough instructions
1327         // left (NumberOfLoopInstrToAlign defined in c2_globals.hpp)
1328         // in current fetch line (OptoLoopAlignment) or the padding
1329         // is big (&gt; MaxLoopPad).
1330         // Set MaxLoopPad to 11 for new Intel cpus to reduce number of
1331         // generated NOP instructions. 11 is the largest size of one
1332         // address NOP instruction &#39;0F 1F&#39; (see Assembler::nop(i)).
1333         MaxLoopPad = 11;
1334       }
1335 #endif // COMPILER2
1336       if (FLAG_IS_DEFAULT(UseXMMForArrayCopy)) {
1337         UseXMMForArrayCopy = true; // use SSE2 movq on new Intel cpus
1338       }
1339       if ((supports_sse4_2() &amp;&amp; supports_ht()) || supports_avx()) { // Newest Intel cpus
1340         if (FLAG_IS_DEFAULT(UseUnalignedLoadStores)) {
1341           UseUnalignedLoadStores = true; // use movdqu on newest Intel cpus
1342         }
1343       }
1344       if (supports_sse4_2()) {
1345         if (FLAG_IS_DEFAULT(UseSSE42Intrinsics)) {
1346           FLAG_SET_DEFAULT(UseSSE42Intrinsics, true);
1347         }
1348       } else {
1349         if (UseSSE42Intrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESIntrinsics)) {
1350           warning(&quot;SSE4.2 intrinsics require SSE4.2 instructions or higher. Intrinsics will be disabled.&quot;);
1351         }
1352         FLAG_SET_DEFAULT(UseSSE42Intrinsics, false);
1353       }
1354     }
1355     if (is_atom_family() || is_knights_family()) {
1356 #ifdef COMPILER2
1357       if (FLAG_IS_DEFAULT(OptoScheduling)) {
1358         OptoScheduling = true;
1359       }
1360 #endif
1361       if (supports_sse4_2()) { // Silvermont
1362         if (FLAG_IS_DEFAULT(UseUnalignedLoadStores)) {
1363           UseUnalignedLoadStores = true; // use movdqu on newest Intel cpus
1364         }
1365       }
1366       if (FLAG_IS_DEFAULT(UseIncDec)) {
1367         FLAG_SET_DEFAULT(UseIncDec, false);
1368       }
1369     }
1370     if (FLAG_IS_DEFAULT(AllocatePrefetchInstr) &amp;&amp; supports_3dnow_prefetch()) {
1371       FLAG_SET_DEFAULT(AllocatePrefetchInstr, 3);
1372     }
1373   }
1374 
1375 #ifdef _LP64
1376   if (UseSSE42Intrinsics) {
1377     if (FLAG_IS_DEFAULT(UseVectorizedMismatchIntrinsic)) {
1378       UseVectorizedMismatchIntrinsic = true;
1379     }
1380   } else if (UseVectorizedMismatchIntrinsic) {
1381     if (!FLAG_IS_DEFAULT(UseVectorizedMismatchIntrinsic))
1382       warning(&quot;vectorizedMismatch intrinsics are not available on this CPU&quot;);
1383     FLAG_SET_DEFAULT(UseVectorizedMismatchIntrinsic, false);
1384   }
1385 #else
1386   if (UseVectorizedMismatchIntrinsic) {
1387     if (!FLAG_IS_DEFAULT(UseVectorizedMismatchIntrinsic)) {
1388       warning(&quot;vectorizedMismatch intrinsic is not available in 32-bit VM&quot;);
1389     }
1390     FLAG_SET_DEFAULT(UseVectorizedMismatchIntrinsic, false);
1391   }
1392 #endif // _LP64
1393 
1394   // Use count leading zeros count instruction if available.
1395   if (supports_lzcnt()) {
1396     if (FLAG_IS_DEFAULT(UseCountLeadingZerosInstruction)) {
1397       UseCountLeadingZerosInstruction = true;
1398     }
1399    } else if (UseCountLeadingZerosInstruction) {
1400     warning(&quot;lzcnt instruction is not available on this CPU&quot;);
1401     FLAG_SET_DEFAULT(UseCountLeadingZerosInstruction, false);
1402   }
1403 
1404   // Use count trailing zeros instruction if available
1405   if (supports_bmi1()) {
1406     // tzcnt does not require VEX prefix
1407     if (FLAG_IS_DEFAULT(UseCountTrailingZerosInstruction)) {
1408       if (!UseBMI1Instructions &amp;&amp; !FLAG_IS_DEFAULT(UseBMI1Instructions)) {
1409         // Don&#39;t use tzcnt if BMI1 is switched off on command line.
1410         UseCountTrailingZerosInstruction = false;
1411       } else {
1412         UseCountTrailingZerosInstruction = true;
1413       }
1414     }
1415   } else if (UseCountTrailingZerosInstruction) {
1416     warning(&quot;tzcnt instruction is not available on this CPU&quot;);
1417     FLAG_SET_DEFAULT(UseCountTrailingZerosInstruction, false);
1418   }
1419 
1420   // BMI instructions (except tzcnt) use an encoding with VEX prefix.
1421   // VEX prefix is generated only when AVX &gt; 0.
1422   if (supports_bmi1() &amp;&amp; supports_avx()) {
1423     if (FLAG_IS_DEFAULT(UseBMI1Instructions)) {
1424       UseBMI1Instructions = true;
1425     }
1426   } else if (UseBMI1Instructions) {
1427     warning(&quot;BMI1 instructions are not available on this CPU (AVX is also required)&quot;);
1428     FLAG_SET_DEFAULT(UseBMI1Instructions, false);
1429   }
1430 
1431   if (supports_bmi2() &amp;&amp; supports_avx()) {
1432     if (FLAG_IS_DEFAULT(UseBMI2Instructions)) {
1433       UseBMI2Instructions = true;
1434     }
1435   } else if (UseBMI2Instructions) {
1436     warning(&quot;BMI2 instructions are not available on this CPU (AVX is also required)&quot;);
1437     FLAG_SET_DEFAULT(UseBMI2Instructions, false);
1438   }
1439 
1440   // Use population count instruction if available.
1441   if (supports_popcnt()) {
1442     if (FLAG_IS_DEFAULT(UsePopCountInstruction)) {
1443       UsePopCountInstruction = true;
1444     }
1445   } else if (UsePopCountInstruction) {
1446     warning(&quot;POPCNT instruction is not available on this CPU&quot;);
1447     FLAG_SET_DEFAULT(UsePopCountInstruction, false);
1448   }
1449 
1450   // Use fast-string operations if available.
1451   if (supports_erms()) {
1452     if (FLAG_IS_DEFAULT(UseFastStosb)) {
1453       UseFastStosb = true;
1454     }
1455   } else if (UseFastStosb) {
1456     warning(&quot;fast-string operations are not available on this CPU&quot;);
1457     FLAG_SET_DEFAULT(UseFastStosb, false);
1458   }
1459 
1460   // Use XMM/YMM MOVDQU instruction for Object Initialization
1461   if (!UseFastStosb &amp;&amp; UseSSE &gt;= 2 &amp;&amp; UseUnalignedLoadStores) {
1462     if (FLAG_IS_DEFAULT(UseXMMForObjInit)) {
1463       UseXMMForObjInit = true;
1464     }
1465   } else if (UseXMMForObjInit) {
1466     warning(&quot;UseXMMForObjInit requires SSE2 and unaligned load/stores. Feature is switched off.&quot;);
1467     FLAG_SET_DEFAULT(UseXMMForObjInit, false);
1468   }
1469 
1470 #ifdef COMPILER2
1471   if (FLAG_IS_DEFAULT(AlignVector)) {
1472     // Modern processors allow misaligned memory operations for vectors.
1473     AlignVector = !UseUnalignedLoadStores;
1474   }
1475 #endif // COMPILER2
1476 
1477   if (FLAG_IS_DEFAULT(AllocatePrefetchInstr)) {
1478     if (AllocatePrefetchInstr == 3 &amp;&amp; !supports_3dnow_prefetch()) {
1479       FLAG_SET_DEFAULT(AllocatePrefetchInstr, 0);
1480     } else if (!supports_sse() &amp;&amp; supports_3dnow_prefetch()) {
1481       FLAG_SET_DEFAULT(AllocatePrefetchInstr, 3);
1482     }
1483   }
1484 
1485   // Allocation prefetch settings
1486   intx cache_line_size = prefetch_data_size();
1487   if (FLAG_IS_DEFAULT(AllocatePrefetchStepSize) &amp;&amp;
1488       (cache_line_size &gt; AllocatePrefetchStepSize)) {
1489     FLAG_SET_DEFAULT(AllocatePrefetchStepSize, cache_line_size);
1490   }
1491 
1492   if ((AllocatePrefetchDistance == 0) &amp;&amp; (AllocatePrefetchStyle != 0)) {
1493     assert(!FLAG_IS_DEFAULT(AllocatePrefetchDistance), &quot;default value should not be 0&quot;);
1494     if (!FLAG_IS_DEFAULT(AllocatePrefetchStyle)) {
1495       warning(&quot;AllocatePrefetchDistance is set to 0 which disable prefetching. Ignoring AllocatePrefetchStyle flag.&quot;);
1496     }
1497     FLAG_SET_DEFAULT(AllocatePrefetchStyle, 0);
1498   }
1499 
1500   if (FLAG_IS_DEFAULT(AllocatePrefetchDistance)) {
1501     bool use_watermark_prefetch = (AllocatePrefetchStyle == 2);
1502     FLAG_SET_DEFAULT(AllocatePrefetchDistance, allocate_prefetch_distance(use_watermark_prefetch));
1503   }
1504 
1505   if (is_intel() &amp;&amp; cpu_family() == 6 &amp;&amp; supports_sse3()) {
1506     if (FLAG_IS_DEFAULT(AllocatePrefetchLines) &amp;&amp;
1507         supports_sse4_2() &amp;&amp; supports_ht()) { // Nehalem based cpus
1508       FLAG_SET_DEFAULT(AllocatePrefetchLines, 4);
1509     }
1510 #ifdef COMPILER2
1511     if (FLAG_IS_DEFAULT(UseFPUForSpilling) &amp;&amp; supports_sse4_2()) {
1512       FLAG_SET_DEFAULT(UseFPUForSpilling, true);
1513     }
1514 #endif
1515   }
1516 
1517   if (is_zx() &amp;&amp; ((cpu_family() == 6) || (cpu_family() == 7)) &amp;&amp; supports_sse4_2()) {
1518 #ifdef COMPILER2
1519     if (FLAG_IS_DEFAULT(UseFPUForSpilling)) {
1520       FLAG_SET_DEFAULT(UseFPUForSpilling, true);
1521     }
1522 #endif
1523   }
1524 
1525 #ifdef _LP64
1526   // Prefetch settings
1527 
1528   // Prefetch interval for gc copy/scan == 9 dcache lines.  Derived from
1529   // 50-warehouse specjbb runs on a 2-way 1.8ghz opteron using a 4gb heap.
1530   // Tested intervals from 128 to 2048 in increments of 64 == one cache line.
1531   // 256 bytes (4 dcache lines) was the nearest runner-up to 576.
1532 
1533   // gc copy/scan is disabled if prefetchw isn&#39;t supported, because
1534   // Prefetch::write emits an inlined prefetchw on Linux.
1535   // Do not use the 3dnow prefetchw instruction.  It isn&#39;t supported on em64t.
1536   // The used prefetcht0 instruction works for both amd64 and em64t.
1537 
1538   if (FLAG_IS_DEFAULT(PrefetchCopyIntervalInBytes)) {
1539     FLAG_SET_DEFAULT(PrefetchCopyIntervalInBytes, 576);
1540   }
1541   if (FLAG_IS_DEFAULT(PrefetchScanIntervalInBytes)) {
1542     FLAG_SET_DEFAULT(PrefetchScanIntervalInBytes, 576);
1543   }
1544   if (FLAG_IS_DEFAULT(PrefetchFieldsAhead)) {
1545     FLAG_SET_DEFAULT(PrefetchFieldsAhead, 1);
1546   }
1547 #endif
1548 
1549   if (FLAG_IS_DEFAULT(ContendedPaddingWidth) &amp;&amp;
1550      (cache_line_size &gt; ContendedPaddingWidth))
1551      ContendedPaddingWidth = cache_line_size;
1552 
1553   // This machine allows unaligned memory accesses
1554   if (FLAG_IS_DEFAULT(UseUnalignedAccesses)) {
1555     FLAG_SET_DEFAULT(UseUnalignedAccesses, true);
1556   }
1557 
1558 #ifndef PRODUCT
1559   if (log_is_enabled(Info, os, cpu)) {
1560     LogStream ls(Log(os, cpu)::info());
1561     outputStream* log = &amp;ls;
1562     log-&gt;print_cr(&quot;Logical CPUs per core: %u&quot;,
1563                   logical_processors_per_package());
1564     log-&gt;print_cr(&quot;L1 data cache line size: %u&quot;, L1_data_cache_line_size());
1565     log-&gt;print(&quot;UseSSE=%d&quot;, (int) UseSSE);
1566     if (UseAVX &gt; 0) {
1567       log-&gt;print(&quot;  UseAVX=%d&quot;, (int) UseAVX);
1568     }
1569     if (UseAES) {
1570       log-&gt;print(&quot;  UseAES=1&quot;);
1571     }
1572 #ifdef COMPILER2
1573     if (MaxVectorSize &gt; 0) {
1574       log-&gt;print(&quot;  MaxVectorSize=%d&quot;, (int) MaxVectorSize);
1575     }
1576 #endif
1577     log-&gt;cr();
1578     log-&gt;print(&quot;Allocation&quot;);
1579     if (AllocatePrefetchStyle &lt;= 0 || (UseSSE == 0 &amp;&amp; !supports_3dnow_prefetch())) {
1580       log-&gt;print_cr(&quot;: no prefetching&quot;);
1581     } else {
1582       log-&gt;print(&quot; prefetching: &quot;);
1583       if (UseSSE == 0 &amp;&amp; supports_3dnow_prefetch()) {
1584         log-&gt;print(&quot;PREFETCHW&quot;);
1585       } else if (UseSSE &gt;= 1) {
1586         if (AllocatePrefetchInstr == 0) {
1587           log-&gt;print(&quot;PREFETCHNTA&quot;);
1588         } else if (AllocatePrefetchInstr == 1) {
1589           log-&gt;print(&quot;PREFETCHT0&quot;);
1590         } else if (AllocatePrefetchInstr == 2) {
1591           log-&gt;print(&quot;PREFETCHT2&quot;);
1592         } else if (AllocatePrefetchInstr == 3) {
1593           log-&gt;print(&quot;PREFETCHW&quot;);
1594         }
1595       }
1596       if (AllocatePrefetchLines &gt; 1) {
1597         log-&gt;print_cr(&quot; at distance %d, %d lines of %d bytes&quot;, (int) AllocatePrefetchDistance, (int) AllocatePrefetchLines, (int) AllocatePrefetchStepSize);
1598       } else {
1599         log-&gt;print_cr(&quot; at distance %d, one line of %d bytes&quot;, (int) AllocatePrefetchDistance, (int) AllocatePrefetchStepSize);
1600       }
1601     }
1602 
1603     if (PrefetchCopyIntervalInBytes &gt; 0) {
1604       log-&gt;print_cr(&quot;PrefetchCopyIntervalInBytes %d&quot;, (int) PrefetchCopyIntervalInBytes);
1605     }
1606     if (PrefetchScanIntervalInBytes &gt; 0) {
1607       log-&gt;print_cr(&quot;PrefetchScanIntervalInBytes %d&quot;, (int) PrefetchScanIntervalInBytes);
1608     }
1609     if (PrefetchFieldsAhead &gt; 0) {
1610       log-&gt;print_cr(&quot;PrefetchFieldsAhead %d&quot;, (int) PrefetchFieldsAhead);
1611     }
1612     if (ContendedPaddingWidth &gt; 0) {
1613       log-&gt;print_cr(&quot;ContendedPaddingWidth %d&quot;, (int) ContendedPaddingWidth);
1614     }
1615   }
1616 #endif // !PRODUCT
1617 }
1618 
1619 void VM_Version::print_platform_virtualization_info(outputStream* st) {
1620   VirtualizationType vrt = VM_Version::get_detected_virtualization();
1621   if (vrt == XenHVM) {
1622     st-&gt;print_cr(&quot;Xen hardware-assisted virtualization detected&quot;);
1623   } else if (vrt == KVM) {
1624     st-&gt;print_cr(&quot;KVM virtualization detected&quot;);
1625   } else if (vrt == VMWare) {
1626     st-&gt;print_cr(&quot;VMWare virtualization detected&quot;);
1627     VirtualizationSupport::print_virtualization_info(st);
1628   } else if (vrt == HyperV) {
1629     st-&gt;print_cr(&quot;HyperV virtualization detected&quot;);
1630   }
1631 }
1632 
1633 void VM_Version::check_virt_cpuid(uint32_t idx, uint32_t *regs) {
1634 // TODO support 32 bit
1635 #if defined(_LP64)
1636 #if defined(_MSC_VER)
1637   // Allocate space for the code
1638   const int code_size = 100;
1639   ResourceMark rm;
1640   CodeBuffer cb(&quot;detect_virt&quot;, code_size, 0);
1641   MacroAssembler* a = new MacroAssembler(&amp;cb);
1642   address code = a-&gt;pc();
1643   void (*test)(uint32_t idx, uint32_t *regs) = (void(*)(uint32_t idx, uint32_t *regs))code;
1644 
1645   a-&gt;movq(r9, rbx); // save nonvolatile register
1646 
1647   // next line would not work on 32-bit
1648   a-&gt;movq(rax, c_rarg0 /* rcx */);
1649   a-&gt;movq(r8, c_rarg1 /* rdx */);
1650   a-&gt;cpuid();
1651   a-&gt;movl(Address(r8,  0), rax);
1652   a-&gt;movl(Address(r8,  4), rbx);
1653   a-&gt;movl(Address(r8,  8), rcx);
1654   a-&gt;movl(Address(r8, 12), rdx);
1655 
1656   a-&gt;movq(rbx, r9); // restore nonvolatile register
1657   a-&gt;ret(0);
1658 
1659   uint32_t *code_end = (uint32_t *)a-&gt;pc();
1660   a-&gt;flush();
1661 
1662   // execute code
1663   (*test)(idx, regs);
1664 #elif defined(__GNUC__)
1665   __asm__ volatile (
1666      &quot;        cpuid;&quot;
1667      &quot;        mov %%eax,(%1);&quot;
1668      &quot;        mov %%ebx,4(%1);&quot;
1669      &quot;        mov %%ecx,8(%1);&quot;
1670      &quot;        mov %%edx,12(%1);&quot;
1671      : &quot;+a&quot; (idx)
1672      : &quot;S&quot; (regs)
1673      : &quot;ebx&quot;, &quot;ecx&quot;, &quot;edx&quot;, &quot;memory&quot; );
1674 #endif
1675 #endif
1676 }
1677 
1678 
1679 bool VM_Version::use_biased_locking() {
1680 #if INCLUDE_RTM_OPT
1681   // RTM locking is most useful when there is high lock contention and
1682   // low data contention.  With high lock contention the lock is usually
1683   // inflated and biased locking is not suitable for that case.
1684   // RTM locking code requires that biased locking is off.
1685   // Note: we can&#39;t switch off UseBiasedLocking in get_processor_features()
1686   // because it is used by Thread::allocate() which is called before
1687   // VM_Version::initialize().
1688   if (UseRTMLocking &amp;&amp; UseBiasedLocking) {
1689     if (FLAG_IS_DEFAULT(UseBiasedLocking)) {
1690       FLAG_SET_DEFAULT(UseBiasedLocking, false);
1691     } else {
1692       warning(&quot;Biased locking is not supported with RTM locking; ignoring UseBiasedLocking flag.&quot; );
1693       UseBiasedLocking = false;
1694     }
1695   }
1696 #endif
1697   return UseBiasedLocking;
1698 }
1699 
1700 // On Xen, the cpuid instruction returns
1701 //  eax / registers[0]: Version of Xen
1702 //  ebx / registers[1]: chars &#39;XenV&#39;
1703 //  ecx / registers[2]: chars &#39;MMXe&#39;
1704 //  edx / registers[3]: chars &#39;nVMM&#39;
1705 //
1706 // On KVM / VMWare / MS Hyper-V, the cpuid instruction returns
1707 //  ebx / registers[1]: chars &#39;KVMK&#39; / &#39;VMwa&#39; / &#39;Micr&#39;
1708 //  ecx / registers[2]: chars &#39;VMKV&#39; / &#39;reVM&#39; / &#39;osof&#39;
1709 //  edx / registers[3]: chars &#39;M&#39;    / &#39;ware&#39; / &#39;t Hv&#39;
1710 //
1711 // more information :
1712 // https://kb.vmware.com/s/article/1009458
1713 //
1714 void VM_Version::check_virtualizations() {
1715 #if defined(_LP64)
1716   uint32_t registers[4];
1717   char signature[13];
1718   uint32_t base;
1719   signature[12] = &#39;\0&#39;;
1720   memset((void*)registers, 0, 4*sizeof(uint32_t));
1721 
1722   for (base = 0x40000000; base &lt; 0x40010000; base += 0x100) {
1723     check_virt_cpuid(base, registers);
1724 
1725     *(uint32_t *)(signature + 0) = registers[1];
1726     *(uint32_t *)(signature + 4) = registers[2];
1727     *(uint32_t *)(signature + 8) = registers[3];
1728 
1729     if (strncmp(&quot;VMwareVMware&quot;, signature, 12) == 0) {
1730       Abstract_VM_Version::_detected_virtualization = VMWare;
1731       // check for extended metrics from guestlib
1732       VirtualizationSupport::initialize();
1733     }
1734 
1735     if (strncmp(&quot;Microsoft Hv&quot;, signature, 12) == 0) {
1736       Abstract_VM_Version::_detected_virtualization = HyperV;
1737     }
1738 
1739     if (strncmp(&quot;KVMKVMKVM&quot;, signature, 9) == 0) {
1740       Abstract_VM_Version::_detected_virtualization = KVM;
1741     }
1742 
1743     if (strncmp(&quot;XenVMMXenVMM&quot;, signature, 12) == 0) {
1744       Abstract_VM_Version::_detected_virtualization = XenHVM;
1745     }
1746   }
1747 #endif
1748 }
1749 
1750 void VM_Version::initialize() {
1751   ResourceMark rm;
1752   // Making this stub must be FIRST use of assembler
1753 
1754   stub_blob = BufferBlob::create(&quot;get_cpu_info_stub&quot;, stub_size);
1755   if (stub_blob == NULL) {
1756     vm_exit_during_initialization(&quot;Unable to allocate get_cpu_info_stub&quot;);
1757   }
1758   CodeBuffer c(stub_blob);
1759   VM_Version_StubGenerator g(&amp;c);
1760   get_cpu_info_stub = CAST_TO_FN_PTR(get_cpu_info_stub_t,
1761                                      g.generate_get_cpu_info());
1762 
1763   get_processor_features();
1764   if (cpu_family() &gt; 4) { // it supports CPUID
1765     check_virtualizations();
1766   }
1767 }
    </pre>
  </body>
</html>
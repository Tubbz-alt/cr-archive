<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/x86_32.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>    1 //
    2 // Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
   23 //
   24 
   25 // X86 Architecture Description File
   26 
   27 //----------REGISTER DEFINITION BLOCK------------------------------------------
   28 // This information is used by the matcher and the register allocator to
   29 // describe individual registers and classes of registers within the target
   30 // architecture.
   31 
   32 register %{
   33 //----------Architecture Description Register Definitions----------------------
   34 // General Registers
   35 // &quot;reg_def&quot;  name ( register save type, C convention save type,
   36 //                   ideal register type, encoding );
   37 // Register Save Types:
   38 //
   39 // NS  = No-Save:       The register allocator assumes that these registers
   40 //                      can be used without saving upon entry to the method, &amp;
   41 //                      that they do not need to be saved at call sites.
   42 //
   43 // SOC = Save-On-Call:  The register allocator assumes that these registers
   44 //                      can be used without saving upon entry to the method,
   45 //                      but that they must be saved at call sites.
   46 //
   47 // SOE = Save-On-Entry: The register allocator assumes that these registers
   48 //                      must be saved before using them upon entry to the
   49 //                      method, but they do not need to be saved at call
   50 //                      sites.
   51 //
   52 // AS  = Always-Save:   The register allocator assumes that these registers
   53 //                      must be saved before using them upon entry to the
   54 //                      method, &amp; that they must be saved at call sites.
   55 //
   56 // Ideal Register Type is used to determine how to save &amp; restore a
   57 // register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   58 // spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
   59 //
   60 // The encoding number is the actual bit-pattern placed into the opcodes.
   61 
   62 // General Registers
   63 // Previously set EBX, ESI, and EDI as save-on-entry for java code
   64 // Turn off SOE in java-code due to frequent use of uncommon-traps.
   65 // Now that allocator is better, turn on ESI and EDI as SOE registers.
   66 
   67 reg_def EBX(SOC, SOE, Op_RegI, 3, rbx-&gt;as_VMReg());
   68 reg_def ECX(SOC, SOC, Op_RegI, 1, rcx-&gt;as_VMReg());
   69 reg_def ESI(SOC, SOE, Op_RegI, 6, rsi-&gt;as_VMReg());
   70 reg_def EDI(SOC, SOE, Op_RegI, 7, rdi-&gt;as_VMReg());
   71 // now that adapter frames are gone EBP is always saved and restored by the prolog/epilog code
   72 reg_def EBP(NS, SOE, Op_RegI, 5, rbp-&gt;as_VMReg());
   73 reg_def EDX(SOC, SOC, Op_RegI, 2, rdx-&gt;as_VMReg());
   74 reg_def EAX(SOC, SOC, Op_RegI, 0, rax-&gt;as_VMReg());
   75 reg_def ESP( NS,  NS, Op_RegI, 4, rsp-&gt;as_VMReg());
   76 
   77 // Float registers.  We treat TOS/FPR0 special.  It is invisible to the
   78 // allocator, and only shows up in the encodings.
   79 reg_def FPR0L( SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());
   80 reg_def FPR0H( SOC, SOC, Op_RegF, 0, VMRegImpl::Bad());
   81 // Ok so here&#39;s the trick FPR1 is really st(0) except in the midst
   82 // of emission of assembly for a machnode. During the emission the fpu stack
   83 // is pushed making FPR1 == st(1) temporarily. However at any safepoint
   84 // the stack will not have this element so FPR1 == st(0) from the
   85 // oopMap viewpoint. This same weirdness with numbering causes
   86 // instruction encoding to have to play games with the register
   87 // encode to correct for this 0/1 issue. See MachSpillCopyNode::implementation
   88 // where it does flt-&gt;flt moves to see an example
   89 //
   90 reg_def FPR1L( SOC, SOC, Op_RegF, 1, as_FloatRegister(0)-&gt;as_VMReg());
   91 reg_def FPR1H( SOC, SOC, Op_RegF, 1, as_FloatRegister(0)-&gt;as_VMReg()-&gt;next());
   92 reg_def FPR2L( SOC, SOC, Op_RegF, 2, as_FloatRegister(1)-&gt;as_VMReg());
   93 reg_def FPR2H( SOC, SOC, Op_RegF, 2, as_FloatRegister(1)-&gt;as_VMReg()-&gt;next());
   94 reg_def FPR3L( SOC, SOC, Op_RegF, 3, as_FloatRegister(2)-&gt;as_VMReg());
   95 reg_def FPR3H( SOC, SOC, Op_RegF, 3, as_FloatRegister(2)-&gt;as_VMReg()-&gt;next());
   96 reg_def FPR4L( SOC, SOC, Op_RegF, 4, as_FloatRegister(3)-&gt;as_VMReg());
   97 reg_def FPR4H( SOC, SOC, Op_RegF, 4, as_FloatRegister(3)-&gt;as_VMReg()-&gt;next());
   98 reg_def FPR5L( SOC, SOC, Op_RegF, 5, as_FloatRegister(4)-&gt;as_VMReg());
   99 reg_def FPR5H( SOC, SOC, Op_RegF, 5, as_FloatRegister(4)-&gt;as_VMReg()-&gt;next());
  100 reg_def FPR6L( SOC, SOC, Op_RegF, 6, as_FloatRegister(5)-&gt;as_VMReg());
  101 reg_def FPR6H( SOC, SOC, Op_RegF, 6, as_FloatRegister(5)-&gt;as_VMReg()-&gt;next());
  102 reg_def FPR7L( SOC, SOC, Op_RegF, 7, as_FloatRegister(6)-&gt;as_VMReg());
  103 reg_def FPR7H( SOC, SOC, Op_RegF, 7, as_FloatRegister(6)-&gt;as_VMReg()-&gt;next());
  104 //
  105 // Empty fill registers, which are never used, but supply alignment to xmm regs
  106 //
  107 reg_def FILL0( SOC, SOC, Op_RegF, 8, VMRegImpl::Bad());
  108 reg_def FILL1( SOC, SOC, Op_RegF, 9, VMRegImpl::Bad());
  109 reg_def FILL2( SOC, SOC, Op_RegF, 10, VMRegImpl::Bad());
  110 reg_def FILL3( SOC, SOC, Op_RegF, 11, VMRegImpl::Bad());
  111 reg_def FILL4( SOC, SOC, Op_RegF, 12, VMRegImpl::Bad());
  112 reg_def FILL5( SOC, SOC, Op_RegF, 13, VMRegImpl::Bad());
  113 reg_def FILL6( SOC, SOC, Op_RegF, 14, VMRegImpl::Bad());
  114 reg_def FILL7( SOC, SOC, Op_RegF, 15, VMRegImpl::Bad());
  115 
  116 // Specify priority of register selection within phases of register
  117 // allocation.  Highest priority is first.  A useful heuristic is to
  118 // give registers a low priority when they are required by machine
  119 // instructions, like EAX and EDX.  Registers which are used as
  120 // pairs must fall on an even boundary (witness the FPR#L&#39;s in this list).
  121 // For the Intel integer registers, the equivalent Long pairs are
  122 // EDX:EAX, EBX:ECX, and EDI:EBP.
  123 alloc_class chunk0( ECX,   EBX,   EBP,   EDI,   EAX,   EDX,   ESI, ESP,
  124                     FPR0L, FPR0H, FPR1L, FPR1H, FPR2L, FPR2H,
  125                     FPR3L, FPR3H, FPR4L, FPR4H, FPR5L, FPR5H,
  126                     FPR6L, FPR6H, FPR7L, FPR7H,
  127                     FILL0, FILL1, FILL2, FILL3, FILL4, FILL5, FILL6, FILL7);
  128 
  129 
  130 //----------Architecture Description Register Classes--------------------------
  131 // Several register classes are automatically defined based upon information in
  132 // this architecture description.
  133 // 1) reg_class inline_cache_reg           ( /* as def&#39;d in frame section */ )
  134 // 2) reg_class compiler_method_oop_reg    ( /* as def&#39;d in frame section */ )
  135 // 2) reg_class interpreter_method_oop_reg ( /* as def&#39;d in frame section */ )
  136 // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
  137 //
  138 // Class for no registers (empty set).
  139 reg_class no_reg();
  140 
  141 // Class for all registers
  142 reg_class any_reg_with_ebp(EAX, EDX, EBP, EDI, ESI, ECX, EBX, ESP);
  143 // Class for all registers (excluding EBP)
  144 reg_class any_reg_no_ebp(EAX, EDX, EDI, ESI, ECX, EBX, ESP);
  145 // Dynamic register class that selects at runtime between register classes
  146 // any_reg and any_no_ebp_reg (depending on the value of the flag PreserveFramePointer).
  147 // Equivalent to: return PreserveFramePointer ? any_no_ebp_reg : any_reg;
  148 reg_class_dynamic any_reg(any_reg_no_ebp, any_reg_with_ebp, %{ PreserveFramePointer %});
  149 
  150 // Class for general registers
  151 reg_class int_reg_with_ebp(EAX, EDX, EBP, EDI, ESI, ECX, EBX);
  152 // Class for general registers (excluding EBP).
  153 // This register class can be used for implicit null checks on win95.
  154 // It is also safe for use by tailjumps (we don&#39;t want to allocate in ebp).
  155 // Used also if the PreserveFramePointer flag is true.
  156 reg_class int_reg_no_ebp(EAX, EDX, EDI, ESI, ECX, EBX);
  157 // Dynamic register class that selects between int_reg and int_reg_no_ebp.
  158 reg_class_dynamic int_reg(int_reg_no_ebp, int_reg_with_ebp, %{ PreserveFramePointer %});
  159 
  160 // Class of &quot;X&quot; registers
  161 reg_class int_x_reg(EBX, ECX, EDX, EAX);
  162 
  163 // Class of registers that can appear in an address with no offset.
  164 // EBP and ESP require an extra instruction byte for zero offset.
  165 // Used in fast-unlock
  166 reg_class p_reg(EDX, EDI, ESI, EBX);
  167 
  168 // Class for general registers excluding ECX
  169 reg_class ncx_reg_with_ebp(EAX, EDX, EBP, EDI, ESI, EBX);
  170 // Class for general registers excluding ECX (and EBP)
  171 reg_class ncx_reg_no_ebp(EAX, EDX, EDI, ESI, EBX);
  172 // Dynamic register class that selects between ncx_reg and ncx_reg_no_ebp.
  173 reg_class_dynamic ncx_reg(ncx_reg_no_ebp, ncx_reg_with_ebp, %{ PreserveFramePointer %});
  174 
  175 // Class for general registers excluding EAX
  176 reg_class nax_reg(EDX, EDI, ESI, ECX, EBX);
  177 
  178 // Class for general registers excluding EAX and EBX.
  179 reg_class nabx_reg_with_ebp(EDX, EDI, ESI, ECX, EBP);
  180 // Class for general registers excluding EAX and EBX (and EBP)
  181 reg_class nabx_reg_no_ebp(EDX, EDI, ESI, ECX);
  182 // Dynamic register class that selects between nabx_reg and nabx_reg_no_ebp.
  183 reg_class_dynamic nabx_reg(nabx_reg_no_ebp, nabx_reg_with_ebp, %{ PreserveFramePointer %});
  184 
  185 // Class of EAX (for multiply and divide operations)
  186 reg_class eax_reg(EAX);
  187 
  188 // Class of EBX (for atomic add)
  189 reg_class ebx_reg(EBX);
  190 
  191 // Class of ECX (for shift and JCXZ operations and cmpLTMask)
  192 reg_class ecx_reg(ECX);
  193 
  194 // Class of EDX (for multiply and divide operations)
  195 reg_class edx_reg(EDX);
  196 
  197 // Class of EDI (for synchronization)
  198 reg_class edi_reg(EDI);
  199 
  200 // Class of ESI (for synchronization)
  201 reg_class esi_reg(ESI);
  202 
  203 // Singleton class for stack pointer
  204 reg_class sp_reg(ESP);
  205 
  206 // Singleton class for instruction pointer
  207 // reg_class ip_reg(EIP);
  208 
  209 // Class of integer register pairs
  210 reg_class long_reg_with_ebp( EAX,EDX, ECX,EBX, EBP,EDI );
  211 // Class of integer register pairs (excluding EBP and EDI);
  212 reg_class long_reg_no_ebp( EAX,EDX, ECX,EBX );
  213 // Dynamic register class that selects between long_reg and long_reg_no_ebp.
  214 reg_class_dynamic long_reg(long_reg_no_ebp, long_reg_with_ebp, %{ PreserveFramePointer %});
  215 
  216 // Class of integer register pairs that aligns with calling convention
  217 reg_class eadx_reg( EAX,EDX );
  218 reg_class ebcx_reg( ECX,EBX );
  219 
  220 // Not AX or DX, used in divides
  221 reg_class nadx_reg_with_ebp(EBX, ECX, ESI, EDI, EBP);
  222 // Not AX or DX (and neither EBP), used in divides
  223 reg_class nadx_reg_no_ebp(EBX, ECX, ESI, EDI);
  224 // Dynamic register class that selects between nadx_reg and nadx_reg_no_ebp.
  225 reg_class_dynamic nadx_reg(nadx_reg_no_ebp, nadx_reg_with_ebp, %{ PreserveFramePointer %});
  226 
  227 // Floating point registers.  Notice FPR0 is not a choice.
  228 // FPR0 is not ever allocated; we use clever encodings to fake
  229 // a 2-address instructions out of Intels FP stack.
  230 reg_class fp_flt_reg( FPR1L,FPR2L,FPR3L,FPR4L,FPR5L,FPR6L,FPR7L );
  231 
  232 reg_class fp_dbl_reg( FPR1L,FPR1H, FPR2L,FPR2H, FPR3L,FPR3H,
  233                       FPR4L,FPR4H, FPR5L,FPR5H, FPR6L,FPR6H,
  234                       FPR7L,FPR7H );
  235 
  236 reg_class fp_flt_reg0( FPR1L );
  237 reg_class fp_dbl_reg0( FPR1L,FPR1H );
  238 reg_class fp_dbl_reg1( FPR2L,FPR2H );
  239 reg_class fp_dbl_notreg0( FPR2L,FPR2H, FPR3L,FPR3H, FPR4L,FPR4H,
  240                           FPR5L,FPR5H, FPR6L,FPR6H, FPR7L,FPR7H );
  241 
  242 %}
  243 
  244 
  245 //----------SOURCE BLOCK-------------------------------------------------------
  246 // This is a block of C++ code which provides values, functions, and
  247 // definitions necessary in the rest of the architecture description
  248 source_hpp %{
  249 // Must be visible to the DFA in dfa_x86_32.cpp
  250 extern bool is_operand_hi32_zero(Node* n);
  251 %}
  252 
  253 source %{
  254 #define   RELOC_IMM32    Assembler::imm_operand
  255 #define   RELOC_DISP32   Assembler::disp32_operand
  256 
  257 #define __ _masm.
  258 
  259 // How to find the high register of a Long pair, given the low register
  260 #define   HIGH_FROM_LOW(x) ((x)+2)
  261 
  262 // These masks are used to provide 128-bit aligned bitmasks to the XMM
  263 // instructions, to allow sign-masking or sign-bit flipping.  They allow
  264 // fast versions of NegF/NegD and AbsF/AbsD.
  265 
  266 // Note: &#39;double&#39; and &#39;long long&#39; have 32-bits alignment on x86.
  267 static jlong* double_quadword(jlong *adr, jlong lo, jlong hi) {
  268   // Use the expression (adr)&amp;(~0xF) to provide 128-bits aligned address
  269   // of 128-bits operands for SSE instructions.
  270   jlong *operand = (jlong*)(((uintptr_t)adr)&amp;((uintptr_t)(~0xF)));
  271   // Store the value to a 128-bits operand.
  272   operand[0] = lo;
  273   operand[1] = hi;
  274   return operand;
  275 }
  276 
  277 // Buffer for 128-bits masks used by SSE instructions.
  278 static jlong fp_signmask_pool[(4+1)*2]; // 4*128bits(data) + 128bits(alignment)
  279 
  280 // Static initialization during VM startup.
  281 static jlong *float_signmask_pool  = double_quadword(&amp;fp_signmask_pool[1*2], CONST64(0x7FFFFFFF7FFFFFFF), CONST64(0x7FFFFFFF7FFFFFFF));
  282 static jlong *double_signmask_pool = double_quadword(&amp;fp_signmask_pool[2*2], CONST64(0x7FFFFFFFFFFFFFFF), CONST64(0x7FFFFFFFFFFFFFFF));
  283 static jlong *float_signflip_pool  = double_quadword(&amp;fp_signmask_pool[3*2], CONST64(0x8000000080000000), CONST64(0x8000000080000000));
  284 static jlong *double_signflip_pool = double_quadword(&amp;fp_signmask_pool[4*2], CONST64(0x8000000000000000), CONST64(0x8000000000000000));
  285 
  286 // Offset hacking within calls.
  287 static int pre_call_resets_size() {
  288   int size = 0;
  289   Compile* C = Compile::current();
  290   if (C-&gt;in_24_bit_fp_mode()) {
  291     size += 6; // fldcw
  292   }
  293   if (VM_Version::supports_vzeroupper()) {
  294     size += 3; // vzeroupper
  295   }
  296   return size;
  297 }
  298 
  299 // !!!!! Special hack to get all type of calls to specify the byte offset
  300 //       from the start of the call to the point where the return address
  301 //       will point.
  302 int MachCallStaticJavaNode::ret_addr_offset() {
  303   return 5 + pre_call_resets_size();  // 5 bytes from start of call to where return address points
  304 }
  305 
  306 int MachCallDynamicJavaNode::ret_addr_offset() {
  307   return 10 + pre_call_resets_size();  // 10 bytes from start of call to where return address points
  308 }
  309 
  310 static int sizeof_FFree_Float_Stack_All = -1;
  311 
  312 int MachCallRuntimeNode::ret_addr_offset() {
  313   assert(sizeof_FFree_Float_Stack_All != -1, &quot;must have been emitted already&quot;);
  314   return sizeof_FFree_Float_Stack_All + 5 + pre_call_resets_size();
  315 }
  316 
  317 // Indicate if the safepoint node needs the polling page as an input.
  318 // Since x86 does have absolute addressing, it doesn&#39;t.
  319 bool SafePointNode::needs_polling_address_input() {
  320   return SafepointMechanism::uses_thread_local_poll();
  321 }
  322 
  323 //
  324 // Compute padding required for nodes which need alignment
  325 //
  326 
  327 // The address of the call instruction needs to be 4-byte aligned to
  328 // ensure that it does not span a cache line so that it can be patched.
  329 int CallStaticJavaDirectNode::compute_padding(int current_offset) const {
  330   current_offset += pre_call_resets_size();  // skip fldcw, if any
  331   current_offset += 1;      // skip call opcode byte
  332   return align_up(current_offset, alignment_required()) - current_offset;
  333 }
  334 
  335 // The address of the call instruction needs to be 4-byte aligned to
  336 // ensure that it does not span a cache line so that it can be patched.
  337 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const {
  338   current_offset += pre_call_resets_size();  // skip fldcw, if any
  339   current_offset += 5;      // skip MOV instruction
  340   current_offset += 1;      // skip call opcode byte
  341   return align_up(current_offset, alignment_required()) - current_offset;
  342 }
  343 
  344 // EMIT_RM()
  345 void emit_rm(CodeBuffer &amp;cbuf, int f1, int f2, int f3) {
  346   unsigned char c = (unsigned char)((f1 &lt;&lt; 6) | (f2 &lt;&lt; 3) | f3);
  347   cbuf.insts()-&gt;emit_int8(c);
  348 }
  349 
  350 // EMIT_CC()
  351 void emit_cc(CodeBuffer &amp;cbuf, int f1, int f2) {
  352   unsigned char c = (unsigned char)( f1 | f2 );
  353   cbuf.insts()-&gt;emit_int8(c);
  354 }
  355 
  356 // EMIT_OPCODE()
  357 void emit_opcode(CodeBuffer &amp;cbuf, int code) {
  358   cbuf.insts()-&gt;emit_int8((unsigned char) code);
  359 }
  360 
  361 // EMIT_OPCODE() w/ relocation information
  362 void emit_opcode(CodeBuffer &amp;cbuf, int code, relocInfo::relocType reloc, int offset = 0) {
  363   cbuf.relocate(cbuf.insts_mark() + offset, reloc);
  364   emit_opcode(cbuf, code);
  365 }
  366 
  367 // EMIT_D8()
  368 void emit_d8(CodeBuffer &amp;cbuf, int d8) {
  369   cbuf.insts()-&gt;emit_int8((unsigned char) d8);
  370 }
  371 
  372 // EMIT_D16()
  373 void emit_d16(CodeBuffer &amp;cbuf, int d16) {
  374   cbuf.insts()-&gt;emit_int16(d16);
  375 }
  376 
  377 // EMIT_D32()
  378 void emit_d32(CodeBuffer &amp;cbuf, int d32) {
  379   cbuf.insts()-&gt;emit_int32(d32);
  380 }
  381 
  382 // emit 32 bit value and construct relocation entry from relocInfo::relocType
  383 void emit_d32_reloc(CodeBuffer &amp;cbuf, int d32, relocInfo::relocType reloc,
  384         int format) {
  385   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  386   cbuf.insts()-&gt;emit_int32(d32);
  387 }
  388 
  389 // emit 32 bit value and construct relocation entry from RelocationHolder
  390 void emit_d32_reloc(CodeBuffer &amp;cbuf, int d32, RelocationHolder const&amp; rspec,
  391         int format) {
  392 #ifdef ASSERT
  393   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp; d32 != 0 &amp;&amp; d32 != (int)Universe::non_oop_word()) {
  394     assert(oopDesc::is_oop(cast_to_oop(d32)), &quot;cannot embed broken oops in code&quot;);
  395   }
  396 #endif
  397   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  398   cbuf.insts()-&gt;emit_int32(d32);
  399 }
  400 
  401 // Access stack slot for load or store
  402 void store_to_stackslot(CodeBuffer &amp;cbuf, int opcode, int rm_field, int disp) {
  403   emit_opcode( cbuf, opcode );               // (e.g., FILD   [ESP+src])
  404   if( -128 &lt;= disp &amp;&amp; disp &lt;= 127 ) {
  405     emit_rm( cbuf, 0x01, rm_field, ESP_enc );  // R/M byte
  406     emit_rm( cbuf, 0x00, ESP_enc, ESP_enc);    // SIB byte
  407     emit_d8 (cbuf, disp);     // Displacement  // R/M byte
  408   } else {
  409     emit_rm( cbuf, 0x02, rm_field, ESP_enc );  // R/M byte
  410     emit_rm( cbuf, 0x00, ESP_enc, ESP_enc);    // SIB byte
  411     emit_d32(cbuf, disp);     // Displacement  // R/M byte
  412   }
  413 }
  414 
  415    // rRegI ereg, memory mem) %{    // emit_reg_mem
  416 void encode_RegMem( CodeBuffer &amp;cbuf, int reg_encoding, int base, int index, int scale, int displace, relocInfo::relocType disp_reloc ) {
  417   // There is no index &amp; no scale, use form without SIB byte
  418   if ((index == 0x4) &amp;&amp;
  419       (scale == 0) &amp;&amp; (base != ESP_enc)) {
  420     // If no displacement, mode is 0x0; unless base is [EBP]
  421     if ( (displace == 0) &amp;&amp; (base != EBP_enc) ) {
  422       emit_rm(cbuf, 0x0, reg_encoding, base);
  423     }
  424     else {                    // If 8-bit displacement, mode 0x1
  425       if ((displace &gt;= -128) &amp;&amp; (displace &lt;= 127)
  426           &amp;&amp; (disp_reloc == relocInfo::none) ) {
  427         emit_rm(cbuf, 0x1, reg_encoding, base);
  428         emit_d8(cbuf, displace);
  429       }
  430       else {                  // If 32-bit displacement
  431         if (base == -1) { // Special flag for absolute address
  432           emit_rm(cbuf, 0x0, reg_encoding, 0x5);
  433           // (manual lies; no SIB needed here)
  434           if ( disp_reloc != relocInfo::none ) {
  435             emit_d32_reloc(cbuf, displace, disp_reloc, 1);
  436           } else {
  437             emit_d32      (cbuf, displace);
  438           }
  439         }
  440         else {                // Normal base + offset
  441           emit_rm(cbuf, 0x2, reg_encoding, base);
  442           if ( disp_reloc != relocInfo::none ) {
  443             emit_d32_reloc(cbuf, displace, disp_reloc, 1);
  444           } else {
  445             emit_d32      (cbuf, displace);
  446           }
  447         }
  448       }
  449     }
  450   }
  451   else {                      // Else, encode with the SIB byte
  452     // If no displacement, mode is 0x0; unless base is [EBP]
  453     if (displace == 0 &amp;&amp; (base != EBP_enc)) {  // If no displacement
  454       emit_rm(cbuf, 0x0, reg_encoding, 0x4);
  455       emit_rm(cbuf, scale, index, base);
  456     }
  457     else {                    // If 8-bit displacement, mode 0x1
  458       if ((displace &gt;= -128) &amp;&amp; (displace &lt;= 127)
  459           &amp;&amp; (disp_reloc == relocInfo::none) ) {
  460         emit_rm(cbuf, 0x1, reg_encoding, 0x4);
  461         emit_rm(cbuf, scale, index, base);
  462         emit_d8(cbuf, displace);
  463       }
  464       else {                  // If 32-bit displacement
  465         if (base == 0x04 ) {
  466           emit_rm(cbuf, 0x2, reg_encoding, 0x4);
  467           emit_rm(cbuf, scale, index, 0x04);
  468         } else {
  469           emit_rm(cbuf, 0x2, reg_encoding, 0x4);
  470           emit_rm(cbuf, scale, index, base);
  471         }
  472         if ( disp_reloc != relocInfo::none ) {
  473           emit_d32_reloc(cbuf, displace, disp_reloc, 1);
  474         } else {
  475           emit_d32      (cbuf, displace);
  476         }
  477       }
  478     }
  479   }
  480 }
  481 
  482 
  483 void encode_Copy( CodeBuffer &amp;cbuf, int dst_encoding, int src_encoding ) {
  484   if( dst_encoding == src_encoding ) {
  485     // reg-reg copy, use an empty encoding
  486   } else {
  487     emit_opcode( cbuf, 0x8B );
  488     emit_rm(cbuf, 0x3, dst_encoding, src_encoding );
  489   }
  490 }
  491 
  492 void emit_cmpfp_fixup(MacroAssembler&amp; _masm) {
  493   Label exit;
  494   __ jccb(Assembler::noParity, exit);
  495   __ pushf();
  496   //
  497   // comiss/ucomiss instructions set ZF,PF,CF flags and
  498   // zero OF,AF,SF for NaN values.
  499   // Fixup flags by zeroing ZF,PF so that compare of NaN
  500   // values returns &#39;less than&#39; result (CF is set).
  501   // Leave the rest of flags unchanged.
  502   //
  503   //    7 6 5 4 3 2 1 0
  504   //   |S|Z|r|A|r|P|r|C|  (r - reserved bit)
  505   //    0 0 1 0 1 0 1 1   (0x2B)
  506   //
  507   __ andl(Address(rsp, 0), 0xffffff2b);
  508   __ popf();
  509   __ bind(exit);
  510 }
  511 
  512 void emit_cmpfp3(MacroAssembler&amp; _masm, Register dst) {
  513   Label done;
  514   __ movl(dst, -1);
  515   __ jcc(Assembler::parity, done);
  516   __ jcc(Assembler::below, done);
  517   __ setb(Assembler::notEqual, dst);
  518   __ movzbl(dst, dst);
  519   __ bind(done);
  520 }
  521 
  522 
  523 //=============================================================================
  524 const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
  525 
<a name="1" id="anc1"></a><span class="line-modified">  526 int Compile::ConstantTable::calculate_table_base_offset() const {</span>
  527   return 0;  // absolute addressing, no offset
  528 }
  529 
  530 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  531 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  532   ShouldNotReachHere();
  533 }
  534 
  535 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  536   // Empty encoding
  537 }
  538 
  539 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  540   return 0;
  541 }
  542 
  543 #ifndef PRODUCT
  544 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  545   st-&gt;print(&quot;# MachConstantBaseNode (empty encoding)&quot;);
  546 }
  547 #endif
  548 
  549 
  550 //=============================================================================
  551 #ifndef PRODUCT
  552 void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  553   Compile* C = ra_-&gt;C;
  554 
<a name="2" id="anc2"></a><span class="line-modified">  555   int framesize = C-&gt;frame_size_in_bytes();</span>
<span class="line-modified">  556   int bangsize = C-&gt;bang_size_in_bytes();</span>
  557   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  558   // Remove wordSize for return addr which is already pushed.
  559   framesize -= wordSize;
  560 
<a name="3" id="anc3"></a><span class="line-modified">  561   if (C-&gt;need_stack_bang(bangsize)) {</span>
  562     framesize -= wordSize;
  563     st-&gt;print(&quot;# stack bang (%d bytes)&quot;, bangsize);
  564     st-&gt;print(&quot;\n\t&quot;);
  565     st-&gt;print(&quot;PUSH   EBP\t# Save EBP&quot;);
  566     if (PreserveFramePointer) {
  567       st-&gt;print(&quot;\n\t&quot;);
  568       st-&gt;print(&quot;MOV    EBP, ESP\t# Save the caller&#39;s SP into EBP&quot;);
  569     }
  570     if (framesize) {
  571       st-&gt;print(&quot;\n\t&quot;);
  572       st-&gt;print(&quot;SUB    ESP, #%d\t# Create frame&quot;,framesize);
  573     }
  574   } else {
  575     st-&gt;print(&quot;SUB    ESP, #%d\t# Create frame&quot;,framesize);
  576     st-&gt;print(&quot;\n\t&quot;);
  577     framesize -= wordSize;
  578     st-&gt;print(&quot;MOV    [ESP + #%d], EBP\t# Save EBP&quot;,framesize);
  579     if (PreserveFramePointer) {
  580       st-&gt;print(&quot;\n\t&quot;);
  581       st-&gt;print(&quot;MOV    EBP, ESP\t# Save the caller&#39;s SP into EBP&quot;);
  582       if (framesize &gt; 0) {
  583         st-&gt;print(&quot;\n\t&quot;);
  584         st-&gt;print(&quot;ADD    EBP, #%d&quot;, framesize);
  585       }
  586     }
  587   }
  588 
  589   if (VerifyStackAtCalls) {
  590     st-&gt;print(&quot;\n\t&quot;);
  591     framesize -= wordSize;
  592     st-&gt;print(&quot;MOV    [ESP + #%d], 0xBADB100D\t# Majik cookie for stack depth check&quot;,framesize);
  593   }
  594 
  595   if( C-&gt;in_24_bit_fp_mode() ) {
  596     st-&gt;print(&quot;\n\t&quot;);
  597     st-&gt;print(&quot;FLDCW  \t# load 24 bit fpu control word&quot;);
  598   }
  599   if (UseSSE &gt;= 2 &amp;&amp; VerifyFPU) {
  600     st-&gt;print(&quot;\n\t&quot;);
  601     st-&gt;print(&quot;# verify FPU stack (must be clean on entry)&quot;);
  602   }
  603 
  604 #ifdef ASSERT
  605   if (VerifyStackAtCalls) {
  606     st-&gt;print(&quot;\n\t&quot;);
  607     st-&gt;print(&quot;# stack alignment check&quot;);
  608   }
  609 #endif
  610   st-&gt;cr();
  611 }
  612 #endif
  613 
  614 
  615 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  616   Compile* C = ra_-&gt;C;
  617   MacroAssembler _masm(&amp;cbuf);
  618 
<a name="4" id="anc4"></a><span class="line-modified">  619   int framesize = C-&gt;frame_size_in_bytes();</span>
<span class="line-modified">  620   int bangsize = C-&gt;bang_size_in_bytes();</span>
  621 
<a name="5" id="anc5"></a><span class="line-modified">  622   __ verified_entry(framesize, C-&gt;need_stack_bang(bangsize)?bangsize:0, C-&gt;in_24_bit_fp_mode(), C-&gt;stub_function() != NULL);</span>
  623 
<a name="6" id="anc6"></a><span class="line-modified">  624   C-&gt;set_frame_complete(cbuf.insts_size());</span>
  625 
  626   if (C-&gt;has_mach_constant_base_node()) {
  627     // NOTE: We set the table base offset here because users might be
  628     // emitted before MachConstantBaseNode.
<a name="7" id="anc7"></a><span class="line-modified">  629     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();</span>
  630     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  631   }
  632 }
  633 
  634 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
  635   return MachNode::size(ra_); // too many variables; just compute it the hard way
  636 }
  637 
  638 int MachPrologNode::reloc() const {
  639   return 0; // a large enough number
  640 }
  641 
  642 //=============================================================================
  643 #ifndef PRODUCT
  644 void MachEpilogNode::format( PhaseRegAlloc *ra_, outputStream* st ) const {
  645   Compile *C = ra_-&gt;C;
<a name="8" id="anc8"></a><span class="line-modified">  646   int framesize = C-&gt;frame_size_in_bytes();</span>
  647   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  648   // Remove two words for return addr and rbp,
  649   framesize -= 2*wordSize;
  650 
  651   if (C-&gt;max_vector_size() &gt; 16) {
  652     st-&gt;print(&quot;VZEROUPPER&quot;);
  653     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  654   }
  655   if (C-&gt;in_24_bit_fp_mode()) {
  656     st-&gt;print(&quot;FLDCW  standard control word&quot;);
  657     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  658   }
  659   if (framesize) {
  660     st-&gt;print(&quot;ADD    ESP,%d\t# Destroy frame&quot;,framesize);
  661     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  662   }
  663   st-&gt;print_cr(&quot;POPL   EBP&quot;); st-&gt;print(&quot;\t&quot;);
  664   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  665     st-&gt;print(&quot;TEST   PollPage,EAX\t! Poll Safepoint&quot;);
  666     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  667   }
  668 }
  669 #endif
  670 
  671 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  672   Compile *C = ra_-&gt;C;
  673   MacroAssembler _masm(&amp;cbuf);
  674 
  675   if (C-&gt;max_vector_size() &gt; 16) {
  676     // Clear upper bits of YMM registers when current compiled code uses
  677     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  678     _masm.vzeroupper();
  679   }
  680   // If method set FPU control word, restore to standard control word
  681   if (C-&gt;in_24_bit_fp_mode()) {
  682     _masm.fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
  683   }
  684 
<a name="9" id="anc9"></a><span class="line-modified">  685   int framesize = C-&gt;frame_size_in_bytes();</span>
  686   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  687   // Remove two words for return addr and rbp,
  688   framesize -= 2*wordSize;
  689 
  690   // Note that VerifyStackAtCalls&#39; Majik cookie does not change the frame size popped here
  691 
  692   if (framesize &gt;= 128) {
  693     emit_opcode(cbuf, 0x81); // add  SP, #framesize
  694     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
  695     emit_d32(cbuf, framesize);
  696   } else if (framesize) {
  697     emit_opcode(cbuf, 0x83); // add  SP, #framesize
  698     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
  699     emit_d8(cbuf, framesize);
  700   }
  701 
  702   emit_opcode(cbuf, 0x58 | EBP_enc);
  703 
  704   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  705     __ reserved_stack_check();
  706   }
  707 
  708   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  709     if (SafepointMechanism::uses_thread_local_poll()) {
  710       Register pollReg = as_Register(EBX_enc);
  711       MacroAssembler masm(&amp;cbuf);
  712       masm.get_thread(pollReg);
  713       masm.movl(pollReg, Address(pollReg, in_bytes(Thread::polling_page_offset())));
  714       masm.relocate(relocInfo::poll_return_type);
  715       masm.testl(rax, Address(pollReg, 0));
  716     } else {
  717       cbuf.relocate(cbuf.insts_end(), relocInfo::poll_return_type, 0);
  718       emit_opcode(cbuf,0x85);
  719       emit_rm(cbuf, 0x0, EAX_enc, 0x5); // EAX
  720       emit_d32(cbuf, (intptr_t)os::get_polling_page());
  721     }
  722   }
  723 }
  724 
  725 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
  726   return MachNode::size(ra_); // too many variables; just compute it
  727                               // the hard way
  728 }
  729 
  730 int MachEpilogNode::reloc() const {
  731   return 0; // a large enough number
  732 }
  733 
  734 const Pipeline * MachEpilogNode::pipeline() const {
  735   return MachNode::pipeline_class();
  736 }
  737 
  738 int MachEpilogNode::safepoint_offset() const { return 0; }
  739 
  740 //=============================================================================
  741 
  742 enum RC { rc_bad, rc_int, rc_float, rc_xmm, rc_stack };
  743 static enum RC rc_class( OptoReg::Name reg ) {
  744 
  745   if( !OptoReg::is_valid(reg)  ) return rc_bad;
  746   if (OptoReg::is_stack(reg)) return rc_stack;
  747 
  748   VMReg r = OptoReg::as_VMReg(reg);
  749   if (r-&gt;is_Register()) return rc_int;
  750   if (r-&gt;is_FloatRegister()) {
  751     assert(UseSSE &lt; 2, &quot;shouldn&#39;t be used in SSE2+ mode&quot;);
  752     return rc_float;
  753   }
  754   assert(r-&gt;is_XMMRegister(), &quot;must be&quot;);
  755   return rc_xmm;
  756 }
  757 
  758 static int impl_helper( CodeBuffer *cbuf, bool do_size, bool is_load, int offset, int reg,
  759                         int opcode, const char *op_str, int size, outputStream* st ) {
  760   if( cbuf ) {
  761     emit_opcode  (*cbuf, opcode );
  762     encode_RegMem(*cbuf, Matcher::_regEncode[reg], ESP_enc, 0x4, 0, offset, relocInfo::none);
  763 #ifndef PRODUCT
  764   } else if( !do_size ) {
  765     if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
  766     if( opcode == 0x8B || opcode == 0x89 ) { // MOV
  767       if( is_load ) st-&gt;print(&quot;%s   %s,[ESP + #%d]&quot;,op_str,Matcher::regName[reg],offset);
  768       else          st-&gt;print(&quot;%s   [ESP + #%d],%s&quot;,op_str,offset,Matcher::regName[reg]);
  769     } else { // FLD, FST, PUSH, POP
  770       st-&gt;print(&quot;%s [ESP + #%d]&quot;,op_str,offset);
  771     }
  772 #endif
  773   }
  774   int offset_size = (offset == 0) ? 0 : ((offset &lt;= 127) ? 1 : 4);
  775   return size+3+offset_size;
  776 }
  777 
  778 // Helper for XMM registers.  Extra opcode bits, limited syntax.
  779 static int impl_x_helper( CodeBuffer *cbuf, bool do_size, bool is_load,
  780                          int offset, int reg_lo, int reg_hi, int size, outputStream* st ) {
  781   int in_size_in_bits = Assembler::EVEX_32bit;
  782   int evex_encoding = 0;
  783   if (reg_lo+1 == reg_hi) {
  784     in_size_in_bits = Assembler::EVEX_64bit;
  785     evex_encoding = Assembler::VEX_W;
  786   }
  787   if (cbuf) {
  788     MacroAssembler _masm(cbuf);
  789     // EVEX spills remain EVEX: Compressed displacemement is better than AVX on spill mem operations,
  790     //                          it maps more cases to single byte displacement
  791     _masm.set_managed();
  792     if (reg_lo+1 == reg_hi) { // double move?
  793       if (is_load) {
  794         __ movdbl(as_XMMRegister(Matcher::_regEncode[reg_lo]), Address(rsp, offset));
  795       } else {
  796         __ movdbl(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[reg_lo]));
  797       }
  798     } else {
  799       if (is_load) {
  800         __ movflt(as_XMMRegister(Matcher::_regEncode[reg_lo]), Address(rsp, offset));
  801       } else {
  802         __ movflt(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[reg_lo]));
  803       }
  804     }
  805 #ifndef PRODUCT
  806   } else if (!do_size) {
  807     if (size != 0) st-&gt;print(&quot;\n\t&quot;);
  808     if (reg_lo+1 == reg_hi) { // double move?
  809       if (is_load) st-&gt;print(&quot;%s %s,[ESP + #%d]&quot;,
  810                               UseXmmLoadAndClearUpper ? &quot;MOVSD &quot; : &quot;MOVLPD&quot;,
  811                               Matcher::regName[reg_lo], offset);
  812       else         st-&gt;print(&quot;MOVSD  [ESP + #%d],%s&quot;,
  813                               offset, Matcher::regName[reg_lo]);
  814     } else {
  815       if (is_load) st-&gt;print(&quot;MOVSS  %s,[ESP + #%d]&quot;,
  816                               Matcher::regName[reg_lo], offset);
  817       else         st-&gt;print(&quot;MOVSS  [ESP + #%d],%s&quot;,
  818                               offset, Matcher::regName[reg_lo]);
  819     }
  820 #endif
  821   }
  822   bool is_single_byte = false;
  823   if ((UseAVX &gt; 2) &amp;&amp; (offset != 0)) {
  824     is_single_byte = Assembler::query_compressed_disp_byte(offset, true, 0, Assembler::EVEX_T1S, in_size_in_bits, evex_encoding);
  825   }
  826   int offset_size = 0;
  827   if (UseAVX &gt; 2 ) {
  828     offset_size = (offset == 0) ? 0 : ((is_single_byte) ? 1 : 4);
  829   } else {
  830     offset_size = (offset == 0) ? 0 : ((offset &lt;= 127) ? 1 : 4);
  831   }
  832   size += (UseAVX &gt; 2) ? 2 : 0; // Need an additional two bytes for EVEX
  833   // VEX_2bytes prefix is used if UseAVX &gt; 0, so it takes the same 2 bytes as SIMD prefix.
  834   return size+5+offset_size;
  835 }
  836 
  837 
  838 static int impl_movx_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
  839                             int src_hi, int dst_hi, int size, outputStream* st ) {
  840   if (cbuf) {
  841     MacroAssembler _masm(cbuf);
  842     // EVEX spills remain EVEX: logic complex between full EVEX, partial and AVX, manage EVEX spill code one way.
  843     _masm.set_managed();
  844     if (src_lo+1 == src_hi &amp;&amp; dst_lo+1 == dst_hi) { // double move?
  845       __ movdbl(as_XMMRegister(Matcher::_regEncode[dst_lo]),
  846                 as_XMMRegister(Matcher::_regEncode[src_lo]));
  847     } else {
  848       __ movflt(as_XMMRegister(Matcher::_regEncode[dst_lo]),
  849                 as_XMMRegister(Matcher::_regEncode[src_lo]));
  850     }
  851 #ifndef PRODUCT
  852   } else if (!do_size) {
  853     if (size != 0) st-&gt;print(&quot;\n\t&quot;);
  854     if (UseXmmRegToRegMoveAll) {//Use movaps,movapd to move between xmm registers
  855       if (src_lo+1 == src_hi &amp;&amp; dst_lo+1 == dst_hi) { // double move?
  856         st-&gt;print(&quot;MOVAPD %s,%s&quot;,Matcher::regName[dst_lo],Matcher::regName[src_lo]);
  857       } else {
  858         st-&gt;print(&quot;MOVAPS %s,%s&quot;,Matcher::regName[dst_lo],Matcher::regName[src_lo]);
  859       }
  860     } else {
  861       if( src_lo+1 == src_hi &amp;&amp; dst_lo+1 == dst_hi ) { // double move?
  862         st-&gt;print(&quot;MOVSD  %s,%s&quot;,Matcher::regName[dst_lo],Matcher::regName[src_lo]);
  863       } else {
  864         st-&gt;print(&quot;MOVSS  %s,%s&quot;,Matcher::regName[dst_lo],Matcher::regName[src_lo]);
  865       }
  866     }
  867 #endif
  868   }
  869   // VEX_2bytes prefix is used if UseAVX &gt; 0, and it takes the same 2 bytes as SIMD prefix.
  870   // Only MOVAPS SSE prefix uses 1 byte.  EVEX uses an additional 2 bytes.
  871   int sz = (UseAVX &gt; 2) ? 6 : 4;
  872   if (!(src_lo+1 == src_hi &amp;&amp; dst_lo+1 == dst_hi) &amp;&amp;
  873       UseXmmRegToRegMoveAll &amp;&amp; (UseAVX == 0)) sz = 3;
  874   return size + sz;
  875 }
  876 
  877 static int impl_movgpr2x_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
  878                             int src_hi, int dst_hi, int size, outputStream* st ) {
  879   // 32-bit
  880   if (cbuf) {
  881     MacroAssembler _masm(cbuf);
  882     // EVEX spills remain EVEX: logic complex between full EVEX, partial and AVX, manage EVEX spill code one way.
  883     _masm.set_managed();
  884     __ movdl(as_XMMRegister(Matcher::_regEncode[dst_lo]),
  885              as_Register(Matcher::_regEncode[src_lo]));
  886 #ifndef PRODUCT
  887   } else if (!do_size) {
  888     st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
  889 #endif
  890   }
  891   return (UseAVX&gt; 2) ? 6 : 4;
  892 }
  893 
  894 
  895 static int impl_movx2gpr_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
  896                                  int src_hi, int dst_hi, int size, outputStream* st ) {
  897   // 32-bit
  898   if (cbuf) {
  899     MacroAssembler _masm(cbuf);
  900     // EVEX spills remain EVEX: logic complex between full EVEX, partial and AVX, manage EVEX spill code one way.
  901     _masm.set_managed();
  902     __ movdl(as_Register(Matcher::_regEncode[dst_lo]),
  903              as_XMMRegister(Matcher::_regEncode[src_lo]));
  904 #ifndef PRODUCT
  905   } else if (!do_size) {
  906     st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
  907 #endif
  908   }
  909   return (UseAVX&gt; 2) ? 6 : 4;
  910 }
  911 
  912 static int impl_mov_helper( CodeBuffer *cbuf, bool do_size, int src, int dst, int size, outputStream* st ) {
  913   if( cbuf ) {
  914     emit_opcode(*cbuf, 0x8B );
  915     emit_rm    (*cbuf, 0x3, Matcher::_regEncode[dst], Matcher::_regEncode[src] );
  916 #ifndef PRODUCT
  917   } else if( !do_size ) {
  918     if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
  919     st-&gt;print(&quot;MOV    %s,%s&quot;,Matcher::regName[dst],Matcher::regName[src]);
  920 #endif
  921   }
  922   return size+2;
  923 }
  924 
  925 static int impl_fp_store_helper( CodeBuffer *cbuf, bool do_size, int src_lo, int src_hi, int dst_lo, int dst_hi,
  926                                  int offset, int size, outputStream* st ) {
  927   if( src_lo != FPR1L_num ) {      // Move value to top of FP stack, if not already there
  928     if( cbuf ) {
  929       emit_opcode( *cbuf, 0xD9 );  // FLD (i.e., push it)
  930       emit_d8( *cbuf, 0xC0-1+Matcher::_regEncode[src_lo] );
  931 #ifndef PRODUCT
  932     } else if( !do_size ) {
  933       if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
  934       st-&gt;print(&quot;FLD    %s&quot;,Matcher::regName[src_lo]);
  935 #endif
  936     }
  937     size += 2;
  938   }
  939 
  940   int st_op = (src_lo != FPR1L_num) ? EBX_num /*store &amp; pop*/ : EDX_num /*store no pop*/;
  941   const char *op_str;
  942   int op;
  943   if( src_lo+1 == src_hi &amp;&amp; dst_lo+1 == dst_hi ) { // double store?
  944     op_str = (src_lo != FPR1L_num) ? &quot;FSTP_D&quot; : &quot;FST_D &quot;;
  945     op = 0xDD;
  946   } else {                   // 32-bit store
  947     op_str = (src_lo != FPR1L_num) ? &quot;FSTP_S&quot; : &quot;FST_S &quot;;
  948     op = 0xD9;
  949     assert( !OptoReg::is_valid(src_hi) &amp;&amp; !OptoReg::is_valid(dst_hi), &quot;no non-adjacent float-stores&quot; );
  950   }
  951 
  952   return impl_helper(cbuf,do_size,false,offset,st_op,op,op_str,size, st);
  953 }
  954 
  955 // Next two methods are shared by 32- and 64-bit VM. They are defined in x86.ad.
  956 static int vec_mov_helper(CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
  957                           int src_hi, int dst_hi, uint ireg, outputStream* st);
  958 
  959 static int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,
  960                             int stack_offset, int reg, uint ireg, outputStream* st);
  961 
  962 static int vec_stack_to_stack_helper(CodeBuffer *cbuf, bool do_size, int src_offset,
  963                                      int dst_offset, uint ireg, outputStream* st) {
  964   int calc_size = 0;
  965   int src_offset_size = (src_offset == 0) ? 0 : ((src_offset &lt; 0x80) ? 1 : 4);
  966   int dst_offset_size = (dst_offset == 0) ? 0 : ((dst_offset &lt; 0x80) ? 1 : 4);
  967   switch (ireg) {
  968   case Op_VecS:
  969     calc_size = 3+src_offset_size + 3+dst_offset_size;
  970     break;
  971   case Op_VecD: {
  972     calc_size = 3+src_offset_size + 3+dst_offset_size;
  973     int tmp_src_offset = src_offset + 4;
  974     int tmp_dst_offset = dst_offset + 4;
  975     src_offset_size = (tmp_src_offset == 0) ? 0 : ((tmp_src_offset &lt; 0x80) ? 1 : 4);
  976     dst_offset_size = (tmp_dst_offset == 0) ? 0 : ((tmp_dst_offset &lt; 0x80) ? 1 : 4);
  977     calc_size += 3+src_offset_size + 3+dst_offset_size;
  978     break;
  979   }
  980   case Op_VecX:
  981   case Op_VecY:
  982   case Op_VecZ:
  983     calc_size = 6 + 6 + 5+src_offset_size + 5+dst_offset_size;
  984     break;
  985   default:
  986     ShouldNotReachHere();
  987   }
  988   if (cbuf) {
  989     MacroAssembler _masm(cbuf);
  990     int offset = __ offset();
  991     switch (ireg) {
  992     case Op_VecS:
  993       __ pushl(Address(rsp, src_offset));
  994       __ popl (Address(rsp, dst_offset));
  995       break;
  996     case Op_VecD:
  997       __ pushl(Address(rsp, src_offset));
  998       __ popl (Address(rsp, dst_offset));
  999       __ pushl(Address(rsp, src_offset+4));
 1000       __ popl (Address(rsp, dst_offset+4));
 1001       break;
 1002     case Op_VecX:
 1003       __ movdqu(Address(rsp, -16), xmm0);
 1004       __ movdqu(xmm0, Address(rsp, src_offset));
 1005       __ movdqu(Address(rsp, dst_offset), xmm0);
 1006       __ movdqu(xmm0, Address(rsp, -16));
 1007       break;
 1008     case Op_VecY:
 1009       __ vmovdqu(Address(rsp, -32), xmm0);
 1010       __ vmovdqu(xmm0, Address(rsp, src_offset));
 1011       __ vmovdqu(Address(rsp, dst_offset), xmm0);
 1012       __ vmovdqu(xmm0, Address(rsp, -32));
 1013       break;
 1014     case Op_VecZ:
 1015       __ evmovdquq(Address(rsp, -64), xmm0, 2);
 1016       __ evmovdquq(xmm0, Address(rsp, src_offset), 2);
 1017       __ evmovdquq(Address(rsp, dst_offset), xmm0, 2);
 1018       __ evmovdquq(xmm0, Address(rsp, -64), 2);
 1019       break;
 1020     default:
 1021       ShouldNotReachHere();
 1022     }
 1023     int size = __ offset() - offset;
 1024     assert(size == calc_size, &quot;incorrect size calculation&quot;);
 1025     return size;
 1026 #ifndef PRODUCT
 1027   } else if (!do_size) {
 1028     switch (ireg) {
 1029     case Op_VecS:
 1030       st-&gt;print(&quot;pushl   [rsp + #%d]\t# 32-bit mem-mem spill\n\t&quot;
 1031                 &quot;popl    [rsp + #%d]&quot;,
 1032                 src_offset, dst_offset);
 1033       break;
 1034     case Op_VecD:
 1035       st-&gt;print(&quot;pushl   [rsp + #%d]\t# 64-bit mem-mem spill\n\t&quot;
 1036                 &quot;popq    [rsp + #%d]\n\t&quot;
 1037                 &quot;pushl   [rsp + #%d]\n\t&quot;
 1038                 &quot;popq    [rsp + #%d]&quot;,
 1039                 src_offset, dst_offset, src_offset+4, dst_offset+4);
 1040       break;
 1041      case Op_VecX:
 1042       st-&gt;print(&quot;movdqu  [rsp - #16], xmm0\t# 128-bit mem-mem spill\n\t&quot;
 1043                 &quot;movdqu  xmm0, [rsp + #%d]\n\t&quot;
 1044                 &quot;movdqu  [rsp + #%d], xmm0\n\t&quot;
 1045                 &quot;movdqu  xmm0, [rsp - #16]&quot;,
 1046                 src_offset, dst_offset);
 1047       break;
 1048     case Op_VecY:
 1049       st-&gt;print(&quot;vmovdqu [rsp - #32], xmm0\t# 256-bit mem-mem spill\n\t&quot;
 1050                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1051                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1052                 &quot;vmovdqu xmm0, [rsp - #32]&quot;,
 1053                 src_offset, dst_offset);
 1054       break;
 1055     case Op_VecZ:
 1056       st-&gt;print(&quot;vmovdqu [rsp - #64], xmm0\t# 512-bit mem-mem spill\n\t&quot;
 1057                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1058                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1059                 &quot;vmovdqu xmm0, [rsp - #64]&quot;,
 1060                 src_offset, dst_offset);
 1061       break;
 1062     default:
 1063       ShouldNotReachHere();
 1064     }
 1065 #endif
 1066   }
 1067   return calc_size;
 1068 }
 1069 
 1070 uint MachSpillCopyNode::implementation( CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream* st ) const {
 1071   // Get registers to move
 1072   OptoReg::Name src_second = ra_-&gt;get_reg_second(in(1));
 1073   OptoReg::Name src_first = ra_-&gt;get_reg_first(in(1));
 1074   OptoReg::Name dst_second = ra_-&gt;get_reg_second(this );
 1075   OptoReg::Name dst_first = ra_-&gt;get_reg_first(this );
 1076 
 1077   enum RC src_second_rc = rc_class(src_second);
 1078   enum RC src_first_rc = rc_class(src_first);
 1079   enum RC dst_second_rc = rc_class(dst_second);
 1080   enum RC dst_first_rc = rc_class(dst_first);
 1081 
 1082   assert( OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first), &quot;must move at least 1 register&quot; );
 1083 
 1084   // Generate spill code!
 1085   int size = 0;
 1086 
 1087   if( src_first == dst_first &amp;&amp; src_second == dst_second )
 1088     return size;            // Self copy, no move
 1089 
 1090   if (bottom_type()-&gt;isa_vect() != NULL) {
 1091     uint ireg = ideal_reg();
 1092     assert((src_first_rc != rc_int &amp;&amp; dst_first_rc != rc_int), &quot;sanity&quot;);
 1093     assert((src_first_rc != rc_float &amp;&amp; dst_first_rc != rc_float), &quot;sanity&quot;);
 1094     assert((ireg == Op_VecS || ireg == Op_VecD || ireg == Op_VecX || ireg == Op_VecY || ireg == Op_VecZ ), &quot;sanity&quot;);
 1095     if( src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack ) {
 1096       // mem -&gt; mem
 1097       int src_offset = ra_-&gt;reg2offset(src_first);
 1098       int dst_offset = ra_-&gt;reg2offset(dst_first);
 1099       return vec_stack_to_stack_helper(cbuf, do_size, src_offset, dst_offset, ireg, st);
 1100     } else if (src_first_rc == rc_xmm &amp;&amp; dst_first_rc == rc_xmm ) {
 1101       return vec_mov_helper(cbuf, do_size, src_first, dst_first, src_second, dst_second, ireg, st);
 1102     } else if (src_first_rc == rc_xmm &amp;&amp; dst_first_rc == rc_stack ) {
 1103       int stack_offset = ra_-&gt;reg2offset(dst_first);
 1104       return vec_spill_helper(cbuf, do_size, false, stack_offset, src_first, ireg, st);
 1105     } else if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_xmm ) {
 1106       int stack_offset = ra_-&gt;reg2offset(src_first);
 1107       return vec_spill_helper(cbuf, do_size, true,  stack_offset, dst_first, ireg, st);
 1108     } else {
 1109       ShouldNotReachHere();
 1110     }
 1111   }
 1112 
 1113   // --------------------------------------
 1114   // Check for mem-mem move.  push/pop to move.
 1115   if( src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack ) {
 1116     if( src_second == dst_first ) { // overlapping stack copy ranges
 1117       assert( src_second_rc == rc_stack &amp;&amp; dst_second_rc == rc_stack, &quot;we only expect a stk-stk copy here&quot; );
 1118       size = impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_second),ESI_num,0xFF,&quot;PUSH  &quot;,size, st);
 1119       size = impl_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_second),EAX_num,0x8F,&quot;POP   &quot;,size, st);
 1120       src_second_rc = dst_second_rc = rc_bad;  // flag as already moved the second bits
 1121     }
 1122     // move low bits
 1123     size = impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_first),ESI_num,0xFF,&quot;PUSH  &quot;,size, st);
 1124     size = impl_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_first),EAX_num,0x8F,&quot;POP   &quot;,size, st);
 1125     if( src_second_rc == rc_stack &amp;&amp; dst_second_rc == rc_stack ) { // mov second bits
 1126       size = impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_second),ESI_num,0xFF,&quot;PUSH  &quot;,size, st);
 1127       size = impl_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_second),EAX_num,0x8F,&quot;POP   &quot;,size, st);
 1128     }
 1129     return size;
 1130   }
 1131 
 1132   // --------------------------------------
 1133   // Check for integer reg-reg copy
 1134   if( src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_int )
 1135     size = impl_mov_helper(cbuf,do_size,src_first,dst_first,size, st);
 1136 
 1137   // Check for integer store
 1138   if( src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_stack )
 1139     size = impl_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_first),src_first,0x89,&quot;MOV &quot;,size, st);
 1140 
 1141   // Check for integer load
 1142   if( dst_first_rc == rc_int &amp;&amp; src_first_rc == rc_stack )
 1143     size = impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_first),dst_first,0x8B,&quot;MOV &quot;,size, st);
 1144 
 1145   // Check for integer reg-xmm reg copy
 1146   if( src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_xmm ) {
 1147     assert( (src_second_rc == rc_bad &amp;&amp; dst_second_rc == rc_bad),
 1148             &quot;no 64 bit integer-float reg moves&quot; );
 1149     return impl_movgpr2x_helper(cbuf,do_size,src_first,dst_first,src_second, dst_second, size, st);
 1150   }
 1151   // --------------------------------------
 1152   // Check for float reg-reg copy
 1153   if( src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_float ) {
 1154     assert( (src_second_rc == rc_bad &amp;&amp; dst_second_rc == rc_bad) ||
 1155             (src_first+1 == src_second &amp;&amp; dst_first+1 == dst_second), &quot;no non-adjacent float-moves&quot; );
 1156     if( cbuf ) {
 1157 
 1158       // Note the mucking with the register encode to compensate for the 0/1
 1159       // indexing issue mentioned in a comment in the reg_def sections
 1160       // for FPR registers many lines above here.
 1161 
 1162       if( src_first != FPR1L_num ) {
 1163         emit_opcode  (*cbuf, 0xD9 );           // FLD    ST(i)
 1164         emit_d8      (*cbuf, 0xC0+Matcher::_regEncode[src_first]-1 );
 1165         emit_opcode  (*cbuf, 0xDD );           // FSTP   ST(i)
 1166         emit_d8      (*cbuf, 0xD8+Matcher::_regEncode[dst_first] );
 1167      } else {
 1168         emit_opcode  (*cbuf, 0xDD );           // FST    ST(i)
 1169         emit_d8      (*cbuf, 0xD0+Matcher::_regEncode[dst_first]-1 );
 1170      }
 1171 #ifndef PRODUCT
 1172     } else if( !do_size ) {
 1173       if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
 1174       if( src_first != FPR1L_num ) st-&gt;print(&quot;FLD    %s\n\tFSTP   %s&quot;,Matcher::regName[src_first],Matcher::regName[dst_first]);
 1175       else                      st-&gt;print(             &quot;FST    %s&quot;,                            Matcher::regName[dst_first]);
 1176 #endif
 1177     }
 1178     return size + ((src_first != FPR1L_num) ? 2+2 : 2);
 1179   }
 1180 
 1181   // Check for float store
 1182   if( src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_stack ) {
 1183     return impl_fp_store_helper(cbuf,do_size,src_first,src_second,dst_first,dst_second,ra_-&gt;reg2offset(dst_first),size, st);
 1184   }
 1185 
 1186   // Check for float load
 1187   if( dst_first_rc == rc_float &amp;&amp; src_first_rc == rc_stack ) {
 1188     int offset = ra_-&gt;reg2offset(src_first);
 1189     const char *op_str;
 1190     int op;
 1191     if( src_first+1 == src_second &amp;&amp; dst_first+1 == dst_second ) { // double load?
 1192       op_str = &quot;FLD_D&quot;;
 1193       op = 0xDD;
 1194     } else {                   // 32-bit load
 1195       op_str = &quot;FLD_S&quot;;
 1196       op = 0xD9;
 1197       assert( src_second_rc == rc_bad &amp;&amp; dst_second_rc == rc_bad, &quot;no non-adjacent float-loads&quot; );
 1198     }
 1199     if( cbuf ) {
 1200       emit_opcode  (*cbuf, op );
 1201       encode_RegMem(*cbuf, 0x0, ESP_enc, 0x4, 0, offset, relocInfo::none);
 1202       emit_opcode  (*cbuf, 0xDD );           // FSTP   ST(i)
 1203       emit_d8      (*cbuf, 0xD8+Matcher::_regEncode[dst_first] );
 1204 #ifndef PRODUCT
 1205     } else if( !do_size ) {
 1206       if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
 1207       st-&gt;print(&quot;%s  ST,[ESP + #%d]\n\tFSTP   %s&quot;,op_str, offset,Matcher::regName[dst_first]);
 1208 #endif
 1209     }
 1210     int offset_size = (offset == 0) ? 0 : ((offset &lt;= 127) ? 1 : 4);
 1211     return size + 3+offset_size+2;
 1212   }
 1213 
 1214   // Check for xmm reg-reg copy
 1215   if( src_first_rc == rc_xmm &amp;&amp; dst_first_rc == rc_xmm ) {
 1216     assert( (src_second_rc == rc_bad &amp;&amp; dst_second_rc == rc_bad) ||
 1217             (src_first+1 == src_second &amp;&amp; dst_first+1 == dst_second),
 1218             &quot;no non-adjacent float-moves&quot; );
 1219     return impl_movx_helper(cbuf,do_size,src_first,dst_first,src_second, dst_second, size, st);
 1220   }
 1221 
 1222   // Check for xmm reg-integer reg copy
 1223   if( src_first_rc == rc_xmm &amp;&amp; dst_first_rc == rc_int ) {
 1224     assert( (src_second_rc == rc_bad &amp;&amp; dst_second_rc == rc_bad),
 1225             &quot;no 64 bit float-integer reg moves&quot; );
 1226     return impl_movx2gpr_helper(cbuf,do_size,src_first,dst_first,src_second, dst_second, size, st);
 1227   }
 1228 
 1229   // Check for xmm store
 1230   if( src_first_rc == rc_xmm &amp;&amp; dst_first_rc == rc_stack ) {
 1231     return impl_x_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_first),src_first, src_second, size, st);
 1232   }
 1233 
 1234   // Check for float xmm load
 1235   if( dst_first_rc == rc_xmm &amp;&amp; src_first_rc == rc_stack ) {
 1236     return impl_x_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_first),dst_first, dst_second, size, st);
 1237   }
 1238 
 1239   // Copy from float reg to xmm reg
 1240   if( dst_first_rc == rc_xmm &amp;&amp; src_first_rc == rc_float ) {
 1241     // copy to the top of stack from floating point reg
 1242     // and use LEA to preserve flags
 1243     if( cbuf ) {
 1244       emit_opcode(*cbuf,0x8D);  // LEA  ESP,[ESP-8]
 1245       emit_rm(*cbuf, 0x1, ESP_enc, 0x04);
 1246       emit_rm(*cbuf, 0x0, 0x04, ESP_enc);
 1247       emit_d8(*cbuf,0xF8);
 1248 #ifndef PRODUCT
 1249     } else if( !do_size ) {
 1250       if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
 1251       st-&gt;print(&quot;LEA    ESP,[ESP-8]&quot;);
 1252 #endif
 1253     }
 1254     size += 4;
 1255 
 1256     size = impl_fp_store_helper(cbuf,do_size,src_first,src_second,dst_first,dst_second,0,size, st);
 1257 
 1258     // Copy from the temp memory to the xmm reg.
 1259     size = impl_x_helper(cbuf,do_size,true ,0,dst_first, dst_second, size, st);
 1260 
 1261     if( cbuf ) {
 1262       emit_opcode(*cbuf,0x8D);  // LEA  ESP,[ESP+8]
 1263       emit_rm(*cbuf, 0x1, ESP_enc, 0x04);
 1264       emit_rm(*cbuf, 0x0, 0x04, ESP_enc);
 1265       emit_d8(*cbuf,0x08);
 1266 #ifndef PRODUCT
 1267     } else if( !do_size ) {
 1268       if( size != 0 ) st-&gt;print(&quot;\n\t&quot;);
 1269       st-&gt;print(&quot;LEA    ESP,[ESP+8]&quot;);
 1270 #endif
 1271     }
 1272     size += 4;
 1273     return size;
 1274   }
 1275 
 1276   assert( size &gt; 0, &quot;missed a case&quot; );
 1277 
 1278   // --------------------------------------------------------------------
 1279   // Check for second bits still needing moving.
 1280   if( src_second == dst_second )
 1281     return size;               // Self copy; no move
 1282   assert( src_second_rc != rc_bad &amp;&amp; dst_second_rc != rc_bad, &quot;src_second &amp; dst_second cannot be Bad&quot; );
 1283 
 1284   // Check for second word int-int move
 1285   if( src_second_rc == rc_int &amp;&amp; dst_second_rc == rc_int )
 1286     return impl_mov_helper(cbuf,do_size,src_second,dst_second,size, st);
 1287 
 1288   // Check for second word integer store
 1289   if( src_second_rc == rc_int &amp;&amp; dst_second_rc == rc_stack )
 1290     return impl_helper(cbuf,do_size,false,ra_-&gt;reg2offset(dst_second),src_second,0x89,&quot;MOV &quot;,size, st);
 1291 
 1292   // Check for second word integer load
 1293   if( dst_second_rc == rc_int &amp;&amp; src_second_rc == rc_stack )
 1294     return impl_helper(cbuf,do_size,true ,ra_-&gt;reg2offset(src_second),dst_second,0x8B,&quot;MOV &quot;,size, st);
 1295 
 1296 
 1297   Unimplemented();
 1298   return 0; // Mute compiler
 1299 }
 1300 
 1301 #ifndef PRODUCT
 1302 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream* st) const {
 1303   implementation( NULL, ra_, false, st );
 1304 }
 1305 #endif
 1306 
 1307 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1308   implementation( &amp;cbuf, ra_, false, NULL );
 1309 }
 1310 
 1311 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1312   return MachNode::size(ra_);
 1313 }
 1314 
 1315 
 1316 //=============================================================================
 1317 #ifndef PRODUCT
 1318 void BoxLockNode::format( PhaseRegAlloc *ra_, outputStream* st ) const {
 1319   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1320   int reg = ra_-&gt;get_reg_first(this);
 1321   st-&gt;print(&quot;LEA    %s,[ESP + #%d]&quot;,Matcher::regName[reg],offset);
 1322 }
 1323 #endif
 1324 
 1325 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1326   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1327   int reg = ra_-&gt;get_encode(this);
 1328   if( offset &gt;= 128 ) {
 1329     emit_opcode(cbuf, 0x8D);      // LEA  reg,[SP+offset]
 1330     emit_rm(cbuf, 0x2, reg, 0x04);
 1331     emit_rm(cbuf, 0x0, 0x04, ESP_enc);
 1332     emit_d32(cbuf, offset);
 1333   }
 1334   else {
 1335     emit_opcode(cbuf, 0x8D);      // LEA  reg,[SP+offset]
 1336     emit_rm(cbuf, 0x1, reg, 0x04);
 1337     emit_rm(cbuf, 0x0, 0x04, ESP_enc);
 1338     emit_d8(cbuf, offset);
 1339   }
 1340 }
 1341 
 1342 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 1343   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1344   if( offset &gt;= 128 ) {
 1345     return 7;
 1346   }
 1347   else {
 1348     return 4;
 1349   }
 1350 }
 1351 
 1352 //=============================================================================
 1353 #ifndef PRODUCT
 1354 void MachUEPNode::format( PhaseRegAlloc *ra_, outputStream* st ) const {
 1355   st-&gt;print_cr(  &quot;CMP    EAX,[ECX+4]\t# Inline cache check&quot;);
 1356   st-&gt;print_cr(&quot;\tJNE    SharedRuntime::handle_ic_miss_stub&quot;);
 1357   st-&gt;print_cr(&quot;\tNOP&quot;);
 1358   st-&gt;print_cr(&quot;\tNOP&quot;);
 1359   if( !OptoBreakpoint )
 1360     st-&gt;print_cr(&quot;\tNOP&quot;);
 1361 }
 1362 #endif
 1363 
 1364 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1365   MacroAssembler masm(&amp;cbuf);
 1366 #ifdef ASSERT
 1367   uint insts_size = cbuf.insts_size();
 1368 #endif
 1369   masm.cmpptr(rax, Address(rcx, oopDesc::klass_offset_in_bytes()));
 1370   masm.jump_cc(Assembler::notEqual,
 1371                RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1372   /* WARNING these NOPs are critical so that verified entry point is properly
 1373      aligned for patching by NativeJump::patch_verified_entry() */
 1374   int nops_cnt = 2;
 1375   if( !OptoBreakpoint ) // Leave space for int3
 1376      nops_cnt += 1;
 1377   masm.nop(nops_cnt);
 1378 
 1379   assert(cbuf.insts_size() - insts_size == size(ra_), &quot;checking code size of inline cache node&quot;);
 1380 }
 1381 
 1382 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
 1383   return OptoBreakpoint ? 11 : 12;
 1384 }
 1385 
 1386 
 1387 //=============================================================================
 1388 
 1389 int Matcher::regnum_to_fpu_offset(int regnum) {
 1390   return regnum - 32; // The FP registers are in the second chunk
 1391 }
 1392 
 1393 // This is UltraSparc specific, true just means we have fast l2f conversion
 1394 const bool Matcher::convL2FSupported(void) {
 1395   return true;
 1396 }
 1397 
 1398 // Is this branch offset short enough that a short branch can be used?
 1399 //
 1400 // NOTE: If the platform does not provide any short branch variants, then
 1401 //       this method should return false for offset 0.
 1402 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1403   // The passed offset is relative to address of the branch.
 1404   // On 86 a branch displacement is calculated relative to address
 1405   // of a next instruction.
 1406   offset -= br_size;
 1407 
 1408   // the short version of jmpConUCF2 contains multiple branches,
 1409   // making the reach slightly less
 1410   if (rule == jmpConUCF2_rule)
 1411     return (-126 &lt;= offset &amp;&amp; offset &lt;= 125);
 1412   return (-128 &lt;= offset &amp;&amp; offset &lt;= 127);
 1413 }
 1414 
 1415 const bool Matcher::isSimpleConstant64(jlong value) {
 1416   // Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.
 1417   return false;
 1418 }
 1419 
 1420 // The ecx parameter to rep stos for the ClearArray node is in dwords.
 1421 const bool Matcher::init_array_count_is_in_bytes = false;
 1422 
 1423 // Needs 2 CMOV&#39;s for longs.
 1424 const int Matcher::long_cmove_cost() { return 1; }
 1425 
 1426 // No CMOVF/CMOVD with SSE/SSE2
 1427 const int Matcher::float_cmove_cost() { return (UseSSE&gt;=1) ? ConditionalMoveLimit : 0; }
 1428 
 1429 // Does the CPU require late expand (see block.cpp for description of late expand)?
 1430 const bool Matcher::require_postalloc_expand = false;
 1431 
 1432 // Do we need to mask the count passed to shift instructions or does
 1433 // the cpu only look at the lower 5/6 bits anyway?
 1434 const bool Matcher::need_masked_shift_count = false;
 1435 
 1436 bool Matcher::narrow_oop_use_complex_address() {
 1437   ShouldNotCallThis();
 1438   return true;
 1439 }
 1440 
 1441 bool Matcher::narrow_klass_use_complex_address() {
 1442   ShouldNotCallThis();
 1443   return true;
 1444 }
 1445 
 1446 bool Matcher::const_oop_prefer_decode() {
 1447   ShouldNotCallThis();
 1448   return true;
 1449 }
 1450 
 1451 bool Matcher::const_klass_prefer_decode() {
 1452   ShouldNotCallThis();
 1453   return true;
 1454 }
 1455 
 1456 // Is it better to copy float constants, or load them directly from memory?
 1457 // Intel can load a float constant from a direct address, requiring no
 1458 // extra registers.  Most RISCs will have to materialize an address into a
 1459 // register first, so they would do better to copy the constant from stack.
 1460 const bool Matcher::rematerialize_float_constants = true;
 1461 
 1462 // If CPU can load and store mis-aligned doubles directly then no fixup is
 1463 // needed.  Else we split the double into 2 integer pieces and move it
 1464 // piece-by-piece.  Only happens when passing doubles into C code as the
 1465 // Java calling convention forces doubles to be aligned.
 1466 const bool Matcher::misaligned_doubles_ok = true;
 1467 
 1468 
 1469 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
 1470   // Get the memory operand from the node
 1471   uint numopnds = node-&gt;num_opnds();        // Virtual call for number of operands
 1472   uint skipped  = node-&gt;oper_input_base();  // Sum of leaves skipped so far
 1473   assert( idx &gt;= skipped, &quot;idx too low in pd_implicit_null_fixup&quot; );
 1474   uint opcnt     = 1;                 // First operand
 1475   uint num_edges = node-&gt;_opnds[1]-&gt;num_edges(); // leaves for first operand
 1476   while( idx &gt;= skipped+num_edges ) {
 1477     skipped += num_edges;
 1478     opcnt++;                          // Bump operand count
 1479     assert( opcnt &lt; numopnds, &quot;Accessing non-existent operand&quot; );
 1480     num_edges = node-&gt;_opnds[opcnt]-&gt;num_edges(); // leaves for next operand
 1481   }
 1482 
 1483   MachOper *memory = node-&gt;_opnds[opcnt];
 1484   MachOper *new_memory = NULL;
 1485   switch (memory-&gt;opcode()) {
 1486   case DIRECT:
 1487   case INDOFFSET32X:
 1488     // No transformation necessary.
 1489     return;
 1490   case INDIRECT:
 1491     new_memory = new indirect_win95_safeOper( );
 1492     break;
 1493   case INDOFFSET8:
 1494     new_memory = new indOffset8_win95_safeOper(memory-&gt;disp(NULL, NULL, 0));
 1495     break;
 1496   case INDOFFSET32:
 1497     new_memory = new indOffset32_win95_safeOper(memory-&gt;disp(NULL, NULL, 0));
 1498     break;
 1499   case INDINDEXOFFSET:
 1500     new_memory = new indIndexOffset_win95_safeOper(memory-&gt;disp(NULL, NULL, 0));
 1501     break;
 1502   case INDINDEXSCALE:
 1503     new_memory = new indIndexScale_win95_safeOper(memory-&gt;scale());
 1504     break;
 1505   case INDINDEXSCALEOFFSET:
 1506     new_memory = new indIndexScaleOffset_win95_safeOper(memory-&gt;scale(), memory-&gt;disp(NULL, NULL, 0));
 1507     break;
 1508   case LOAD_LONG_INDIRECT:
 1509   case LOAD_LONG_INDOFFSET32:
 1510     // Does not use EBP as address register, use { EDX, EBX, EDI, ESI}
 1511     return;
 1512   default:
 1513     assert(false, &quot;unexpected memory operand in pd_implicit_null_fixup()&quot;);
 1514     return;
 1515   }
 1516   node-&gt;_opnds[opcnt] = new_memory;
 1517 }
 1518 
<a name="10" id="anc10"></a><span class="line-modified"> 1519 // Advertise here if the CPU requires explicit rounding operations</span>
<span class="line-removed"> 1520 // to implement the UseStrictFP mode.</span>
 1521 const bool Matcher::strict_fp_requires_explicit_rounding = true;
 1522 
 1523 // Are floats conerted to double when stored to stack during deoptimization?
 1524 // On x32 it is stored with convertion only when FPU is used for floats.
 1525 bool Matcher::float_in_double() { return (UseSSE == 0); }
 1526 
 1527 // Do ints take an entire long register or just half?
 1528 const bool Matcher::int_in_long = false;
 1529 
 1530 // Return whether or not this register is ever used as an argument.  This
 1531 // function is used on startup to build the trampoline stubs in generateOptoStub.
 1532 // Registers not mentioned will be killed by the VM call in the trampoline, and
 1533 // arguments in those registers not be available to the callee.
 1534 bool Matcher::can_be_java_arg( int reg ) {
 1535   if(  reg == ECX_num   || reg == EDX_num   ) return true;
 1536   if( (reg == XMM0_num  || reg == XMM1_num ) &amp;&amp; UseSSE&gt;=1 ) return true;
 1537   if( (reg == XMM0b_num || reg == XMM1b_num) &amp;&amp; UseSSE&gt;=2 ) return true;
 1538   return false;
 1539 }
 1540 
 1541 bool Matcher::is_spillable_arg( int reg ) {
 1542   return can_be_java_arg(reg);
 1543 }
 1544 
 1545 bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
 1546   // Use hardware integer DIV instruction when
 1547   // it is faster than a code which use multiply.
 1548   // Only when constant divisor fits into 32 bit
 1549   // (min_jint is excluded to get only correct
 1550   // positive 32 bit values from negative).
 1551   return VM_Version::has_fast_idiv() &amp;&amp;
 1552          (divisor == (int)divisor &amp;&amp; divisor != min_jint);
 1553 }
 1554 
 1555 // Register for DIVI projection of divmodI
 1556 RegMask Matcher::divI_proj_mask() {
 1557   return EAX_REG_mask();
 1558 }
 1559 
 1560 // Register for MODI projection of divmodI
 1561 RegMask Matcher::modI_proj_mask() {
 1562   return EDX_REG_mask();
 1563 }
 1564 
 1565 // Register for DIVL projection of divmodL
 1566 RegMask Matcher::divL_proj_mask() {
 1567   ShouldNotReachHere();
 1568   return RegMask();
 1569 }
 1570 
 1571 // Register for MODL projection of divmodL
 1572 RegMask Matcher::modL_proj_mask() {
 1573   ShouldNotReachHere();
 1574   return RegMask();
 1575 }
 1576 
 1577 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1578   return NO_REG_mask();
 1579 }
 1580 
 1581 // Returns true if the high 32 bits of the value is known to be zero.
 1582 bool is_operand_hi32_zero(Node* n) {
 1583   int opc = n-&gt;Opcode();
 1584   if (opc == Op_AndL) {
 1585     Node* o2 = n-&gt;in(2);
 1586     if (o2-&gt;is_Con() &amp;&amp; (o2-&gt;get_long() &amp; 0xFFFFFFFF00000000LL) == 0LL) {
 1587       return true;
 1588     }
 1589   }
 1590   if (opc == Op_ConL &amp;&amp; (n-&gt;get_long() &amp; 0xFFFFFFFF00000000LL) == 0LL) {
 1591     return true;
 1592   }
 1593   return false;
 1594 }
 1595 
 1596 %}
 1597 
 1598 //----------ENCODING BLOCK-----------------------------------------------------
 1599 // This block specifies the encoding classes used by the compiler to output
 1600 // byte streams.  Encoding classes generate functions which are called by
 1601 // Machine Instruction Nodes in order to generate the bit encoding of the
 1602 // instruction.  Operands specify their base encoding interface with the
 1603 // interface keyword.  There are currently supported four interfaces,
 1604 // REG_INTER, CONST_INTER, MEMORY_INTER, &amp; COND_INTER.  REG_INTER causes an
 1605 // operand to generate a function which returns its register number when
 1606 // queried.   CONST_INTER causes an operand to generate a function which
 1607 // returns the value of the constant when queried.  MEMORY_INTER causes an
 1608 // operand to generate four functions which return the Base Register, the
 1609 // Index Register, the Scale Value, and the Offset Value of the operand when
 1610 // queried.  COND_INTER causes an operand to generate six functions which
 1611 // return the encoding code (ie - encoding bits for the instruction)
 1612 // associated with each basic boolean condition for a conditional instruction.
 1613 // Instructions specify two basic values for encoding.  They use the
 1614 // ins_encode keyword to specify their encoding class (which must be one of
 1615 // the class names specified in the encoding block), and they use the
 1616 // opcode keyword to specify, in order, their primary, secondary, and
 1617 // tertiary opcode.  Only the opcode sections which a particular instruction
 1618 // needs for encoding need to be specified.
 1619 encode %{
 1620   // Build emit functions for each basic byte or larger field in the intel
 1621   // encoding scheme (opcode, rm, sib, immediate), and call them from C++
 1622   // code in the enc_class source block.  Emit functions will live in the
 1623   // main source block for now.  In future, we can generalize this by
 1624   // adding a syntax that specifies the sizes of fields in an order,
 1625   // so that the adlc can build the emit functions automagically
 1626 
 1627   // Emit primary opcode
 1628   enc_class OpcP %{
 1629     emit_opcode(cbuf, $primary);
 1630   %}
 1631 
 1632   // Emit secondary opcode
 1633   enc_class OpcS %{
 1634     emit_opcode(cbuf, $secondary);
 1635   %}
 1636 
 1637   // Emit opcode directly
 1638   enc_class Opcode(immI d8) %{
 1639     emit_opcode(cbuf, $d8$$constant);
 1640   %}
 1641 
 1642   enc_class SizePrefix %{
 1643     emit_opcode(cbuf,0x66);
 1644   %}
 1645 
 1646   enc_class RegReg (rRegI dst, rRegI src) %{    // RegReg(Many)
 1647     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 1648   %}
 1649 
 1650   enc_class OpcRegReg (immI opcode, rRegI dst, rRegI src) %{    // OpcRegReg(Many)
 1651     emit_opcode(cbuf,$opcode$$constant);
 1652     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 1653   %}
 1654 
 1655   enc_class mov_r32_imm0( rRegI dst ) %{
 1656     emit_opcode( cbuf, 0xB8 + $dst$$reg ); // 0xB8+ rd   -- MOV r32  ,imm32
 1657     emit_d32   ( cbuf, 0x0  );             //                         imm32==0x0
 1658   %}
 1659 
 1660   enc_class cdq_enc %{
 1661     // Full implementation of Java idiv and irem; checks for
 1662     // special case as described in JVM spec., p.243 &amp; p.271.
 1663     //
 1664     //         normal case                           special case
 1665     //
 1666     // input : rax,: dividend                         min_int
 1667     //         reg: divisor                          -1
 1668     //
 1669     // output: rax,: quotient  (= rax, idiv reg)       min_int
 1670     //         rdx: remainder (= rax, irem reg)       0
 1671     //
 1672     //  Code sequnce:
 1673     //
 1674     //  81 F8 00 00 00 80    cmp         rax,80000000h
 1675     //  0F 85 0B 00 00 00    jne         normal_case
 1676     //  33 D2                xor         rdx,edx
 1677     //  83 F9 FF             cmp         rcx,0FFh
 1678     //  0F 84 03 00 00 00    je          done
 1679     //                  normal_case:
 1680     //  99                   cdq
 1681     //  F7 F9                idiv        rax,ecx
 1682     //                  done:
 1683     //
 1684     emit_opcode(cbuf,0x81); emit_d8(cbuf,0xF8);
 1685     emit_opcode(cbuf,0x00); emit_d8(cbuf,0x00);
 1686     emit_opcode(cbuf,0x00); emit_d8(cbuf,0x80);                     // cmp rax,80000000h
 1687     emit_opcode(cbuf,0x0F); emit_d8(cbuf,0x85);
 1688     emit_opcode(cbuf,0x0B); emit_d8(cbuf,0x00);
 1689     emit_opcode(cbuf,0x00); emit_d8(cbuf,0x00);                     // jne normal_case
 1690     emit_opcode(cbuf,0x33); emit_d8(cbuf,0xD2);                     // xor rdx,edx
 1691     emit_opcode(cbuf,0x83); emit_d8(cbuf,0xF9); emit_d8(cbuf,0xFF); // cmp rcx,0FFh
 1692     emit_opcode(cbuf,0x0F); emit_d8(cbuf,0x84);
 1693     emit_opcode(cbuf,0x03); emit_d8(cbuf,0x00);
 1694     emit_opcode(cbuf,0x00); emit_d8(cbuf,0x00);                     // je done
 1695     // normal_case:
 1696     emit_opcode(cbuf,0x99);                                         // cdq
 1697     // idiv (note: must be emitted by the user of this rule)
 1698     // normal:
 1699   %}
 1700 
 1701   // Dense encoding for older common ops
 1702   enc_class Opc_plus(immI opcode, rRegI reg) %{
 1703     emit_opcode(cbuf, $opcode$$constant + $reg$$reg);
 1704   %}
 1705 
 1706 
 1707   // Opcde enc_class for 8/32 bit immediate instructions with sign-extension
 1708   enc_class OpcSE (immI imm) %{ // Emit primary opcode and set sign-extend bit
 1709     // Check for 8-bit immediate, and set sign extend bit in opcode
 1710     if (($imm$$constant &gt;= -128) &amp;&amp; ($imm$$constant &lt;= 127)) {
 1711       emit_opcode(cbuf, $primary | 0x02);
 1712     }
 1713     else {                          // If 32-bit immediate
 1714       emit_opcode(cbuf, $primary);
 1715     }
 1716   %}
 1717 
 1718   enc_class OpcSErm (rRegI dst, immI imm) %{    // OpcSEr/m
 1719     // Emit primary opcode and set sign-extend bit
 1720     // Check for 8-bit immediate, and set sign extend bit in opcode
 1721     if (($imm$$constant &gt;= -128) &amp;&amp; ($imm$$constant &lt;= 127)) {
 1722       emit_opcode(cbuf, $primary | 0x02);    }
 1723     else {                          // If 32-bit immediate
 1724       emit_opcode(cbuf, $primary);
 1725     }
 1726     // Emit r/m byte with secondary opcode, after primary opcode.
 1727     emit_rm(cbuf, 0x3, $secondary, $dst$$reg);
 1728   %}
 1729 
 1730   enc_class Con8or32 (immI imm) %{    // Con8or32(storeImmI), 8 or 32 bits
 1731     // Check for 8-bit immediate, and set sign extend bit in opcode
 1732     if (($imm$$constant &gt;= -128) &amp;&amp; ($imm$$constant &lt;= 127)) {
 1733       $$$emit8$imm$$constant;
 1734     }
 1735     else {                          // If 32-bit immediate
 1736       // Output immediate
 1737       $$$emit32$imm$$constant;
 1738     }
 1739   %}
 1740 
 1741   enc_class Long_OpcSErm_Lo(eRegL dst, immL imm) %{
 1742     // Emit primary opcode and set sign-extend bit
 1743     // Check for 8-bit immediate, and set sign extend bit in opcode
 1744     int con = (int)$imm$$constant; // Throw away top bits
 1745     emit_opcode(cbuf, ((con &gt;= -128) &amp;&amp; (con &lt;= 127)) ? ($primary | 0x02) : $primary);
 1746     // Emit r/m byte with secondary opcode, after primary opcode.
 1747     emit_rm(cbuf, 0x3, $secondary, $dst$$reg);
 1748     if ((con &gt;= -128) &amp;&amp; (con &lt;= 127)) emit_d8 (cbuf,con);
 1749     else                               emit_d32(cbuf,con);
 1750   %}
 1751 
 1752   enc_class Long_OpcSErm_Hi(eRegL dst, immL imm) %{
 1753     // Emit primary opcode and set sign-extend bit
 1754     // Check for 8-bit immediate, and set sign extend bit in opcode
 1755     int con = (int)($imm$$constant &gt;&gt; 32); // Throw away bottom bits
 1756     emit_opcode(cbuf, ((con &gt;= -128) &amp;&amp; (con &lt;= 127)) ? ($primary | 0x02) : $primary);
 1757     // Emit r/m byte with tertiary opcode, after primary opcode.
 1758     emit_rm(cbuf, 0x3, $tertiary, HIGH_FROM_LOW($dst$$reg));
 1759     if ((con &gt;= -128) &amp;&amp; (con &lt;= 127)) emit_d8 (cbuf,con);
 1760     else                               emit_d32(cbuf,con);
 1761   %}
 1762 
 1763   enc_class OpcSReg (rRegI dst) %{    // BSWAP
 1764     emit_cc(cbuf, $secondary, $dst$$reg );
 1765   %}
 1766 
 1767   enc_class bswap_long_bytes(eRegL dst) %{ // BSWAP
 1768     int destlo = $dst$$reg;
 1769     int desthi = HIGH_FROM_LOW(destlo);
 1770     // bswap lo
 1771     emit_opcode(cbuf, 0x0F);
 1772     emit_cc(cbuf, 0xC8, destlo);
 1773     // bswap hi
 1774     emit_opcode(cbuf, 0x0F);
 1775     emit_cc(cbuf, 0xC8, desthi);
 1776     // xchg lo and hi
 1777     emit_opcode(cbuf, 0x87);
 1778     emit_rm(cbuf, 0x3, destlo, desthi);
 1779   %}
 1780 
 1781   enc_class RegOpc (rRegI div) %{    // IDIV, IMOD, JMP indirect, ...
 1782     emit_rm(cbuf, 0x3, $secondary, $div$$reg );
 1783   %}
 1784 
 1785   enc_class enc_cmov(cmpOp cop ) %{ // CMOV
 1786     $$$emit8$primary;
 1787     emit_cc(cbuf, $secondary, $cop$$cmpcode);
 1788   %}
 1789 
 1790   enc_class enc_cmov_dpr(cmpOp cop, regDPR src ) %{ // CMOV
 1791     int op = 0xDA00 + $cop$$cmpcode + ($src$$reg-1);
 1792     emit_d8(cbuf, op &gt;&gt; 8 );
 1793     emit_d8(cbuf, op &amp; 255);
 1794   %}
 1795 
 1796   // emulate a CMOV with a conditional branch around a MOV
 1797   enc_class enc_cmov_branch( cmpOp cop, immI brOffs ) %{ // CMOV
 1798     // Invert sense of branch from sense of CMOV
 1799     emit_cc( cbuf, 0x70, ($cop$$cmpcode^1) );
 1800     emit_d8( cbuf, $brOffs$$constant );
 1801   %}
 1802 
 1803   enc_class enc_PartialSubtypeCheck( ) %{
 1804     Register Redi = as_Register(EDI_enc); // result register
 1805     Register Reax = as_Register(EAX_enc); // super class
 1806     Register Recx = as_Register(ECX_enc); // killed
 1807     Register Resi = as_Register(ESI_enc); // sub class
 1808     Label miss;
 1809 
 1810     MacroAssembler _masm(&amp;cbuf);
 1811     __ check_klass_subtype_slow_path(Resi, Reax, Recx, Redi,
 1812                                      NULL, &amp;miss,
 1813                                      /*set_cond_codes:*/ true);
 1814     if ($primary) {
 1815       __ xorptr(Redi, Redi);
 1816     }
 1817     __ bind(miss);
 1818   %}
 1819 
 1820   enc_class FFree_Float_Stack_All %{    // Free_Float_Stack_All
 1821     MacroAssembler masm(&amp;cbuf);
 1822     int start = masm.offset();
 1823     if (UseSSE &gt;= 2) {
 1824       if (VerifyFPU) {
 1825         masm.verify_FPU(0, &quot;must be empty in SSE2+ mode&quot;);
 1826       }
 1827     } else {
 1828       // External c_calling_convention expects the FPU stack to be &#39;clean&#39;.
 1829       // Compiled code leaves it dirty.  Do cleanup now.
 1830       masm.empty_FPU_stack();
 1831     }
 1832     if (sizeof_FFree_Float_Stack_All == -1) {
 1833       sizeof_FFree_Float_Stack_All = masm.offset() - start;
 1834     } else {
 1835       assert(masm.offset() - start == sizeof_FFree_Float_Stack_All, &quot;wrong size&quot;);
 1836     }
 1837   %}
 1838 
 1839   enc_class Verify_FPU_For_Leaf %{
 1840     if( VerifyFPU ) {
 1841       MacroAssembler masm(&amp;cbuf);
 1842       masm.verify_FPU( -3, &quot;Returning from Runtime Leaf call&quot;);
 1843     }
 1844   %}
 1845 
 1846   enc_class Java_To_Runtime (method meth) %{    // CALL Java_To_Runtime, Java_To_Runtime_Leaf
 1847     // This is the instruction starting address for relocation info.
 1848     cbuf.set_insts_mark();
 1849     $$$emit8$primary;
 1850     // CALL directly to the runtime
 1851     emit_d32_reloc(cbuf, ($meth$$method - (int)(cbuf.insts_end()) - 4),
 1852                 runtime_call_Relocation::spec(), RELOC_IMM32 );
 1853 
 1854     if (UseSSE &gt;= 2) {
 1855       MacroAssembler _masm(&amp;cbuf);
 1856       BasicType rt = tf()-&gt;return_type();
 1857 
 1858       if ((rt == T_FLOAT || rt == T_DOUBLE) &amp;&amp; !return_value_is_used()) {
 1859         // A C runtime call where the return value is unused.  In SSE2+
 1860         // mode the result needs to be removed from the FPU stack.  It&#39;s
 1861         // likely that this function call could be removed by the
 1862         // optimizer if the C function is a pure function.
 1863         __ ffree(0);
 1864       } else if (rt == T_FLOAT) {
 1865         __ lea(rsp, Address(rsp, -4));
 1866         __ fstp_s(Address(rsp, 0));
 1867         __ movflt(xmm0, Address(rsp, 0));
 1868         __ lea(rsp, Address(rsp,  4));
 1869       } else if (rt == T_DOUBLE) {
 1870         __ lea(rsp, Address(rsp, -8));
 1871         __ fstp_d(Address(rsp, 0));
 1872         __ movdbl(xmm0, Address(rsp, 0));
 1873         __ lea(rsp, Address(rsp,  8));
 1874       }
 1875     }
 1876   %}
 1877 
 1878   enc_class pre_call_resets %{
 1879     // If method sets FPU control word restore it here
 1880     debug_only(int off0 = cbuf.insts_size());
 1881     if (ra_-&gt;C-&gt;in_24_bit_fp_mode()) {
 1882       MacroAssembler _masm(&amp;cbuf);
 1883       __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
 1884     }
 1885     // Clear upper bits of YMM registers when current compiled code uses
 1886     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
 1887     MacroAssembler _masm(&amp;cbuf);
 1888     __ vzeroupper();
 1889     debug_only(int off1 = cbuf.insts_size());
 1890     assert(off1 - off0 == pre_call_resets_size(), &quot;correct size prediction&quot;);
 1891   %}
 1892 
 1893   enc_class post_call_FPU %{
 1894     // If method sets FPU control word do it here also
 1895     if (Compile::current()-&gt;in_24_bit_fp_mode()) {
 1896       MacroAssembler masm(&amp;cbuf);
 1897       masm.fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));
 1898     }
 1899   %}
 1900 
 1901   enc_class Java_Static_Call (method meth) %{    // JAVA STATIC CALL
 1902     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to determine
 1903     // who we intended to call.
 1904     cbuf.set_insts_mark();
 1905     $$$emit8$primary;
 1906 
 1907     if (!_method) {
 1908       emit_d32_reloc(cbuf, ($meth$$method - (int)(cbuf.insts_end()) - 4),
 1909                      runtime_call_Relocation::spec(),
 1910                      RELOC_IMM32);
 1911     } else {
 1912       int method_index = resolved_method_index(cbuf);
 1913       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 1914                                                   : static_call_Relocation::spec(method_index);
 1915       emit_d32_reloc(cbuf, ($meth$$method - (int)(cbuf.insts_end()) - 4),
 1916                      rspec, RELOC_DISP32);
 1917       // Emit stubs for static call.
 1918       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 1919       if (stub == NULL) {
 1920         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 1921         return;
 1922       }
 1923     }
 1924   %}
 1925 
 1926   enc_class Java_Dynamic_Call (method meth) %{    // JAVA DYNAMIC CALL
 1927     MacroAssembler _masm(&amp;cbuf);
 1928     __ ic_call((address)$meth$$method, resolved_method_index(cbuf));
 1929   %}
 1930 
 1931   enc_class Java_Compiled_Call (method meth) %{    // JAVA COMPILED CALL
 1932     int disp = in_bytes(Method::from_compiled_offset());
 1933     assert( -128 &lt;= disp &amp;&amp; disp &lt;= 127, &quot;compiled_code_offset isn&#39;t small&quot;);
 1934 
 1935     // CALL *[EAX+in_bytes(Method::from_compiled_code_entry_point_offset())]
 1936     cbuf.set_insts_mark();
 1937     $$$emit8$primary;
 1938     emit_rm(cbuf, 0x01, $secondary, EAX_enc );  // R/M byte
 1939     emit_d8(cbuf, disp);             // Displacement
 1940 
 1941   %}
 1942 
 1943 //   Following encoding is no longer used, but may be restored if calling
 1944 //   convention changes significantly.
 1945 //   Became: Xor_Reg(EBP), Java_To_Runtime( labl )
 1946 //
 1947 //   enc_class Java_Interpreter_Call (label labl) %{    // JAVA INTERPRETER CALL
 1948 //     // int ic_reg     = Matcher::inline_cache_reg();
 1949 //     // int ic_encode  = Matcher::_regEncode[ic_reg];
 1950 //     // int imo_reg    = Matcher::interpreter_method_oop_reg();
 1951 //     // int imo_encode = Matcher::_regEncode[imo_reg];
 1952 //
 1953 //     // // Interpreter expects method_oop in EBX, currently a callee-saved register,
 1954 //     // // so we load it immediately before the call
 1955 //     // emit_opcode(cbuf, 0x8B);                     // MOV    imo_reg,ic_reg  # method_oop
 1956 //     // emit_rm(cbuf, 0x03, imo_encode, ic_encode ); // R/M byte
 1957 //
 1958 //     // xor rbp,ebp
 1959 //     emit_opcode(cbuf, 0x33);
 1960 //     emit_rm(cbuf, 0x3, EBP_enc, EBP_enc);
 1961 //
 1962 //     // CALL to interpreter.
 1963 //     cbuf.set_insts_mark();
 1964 //     $$$emit8$primary;
 1965 //     emit_d32_reloc(cbuf, ($labl$$label - (int)(cbuf.insts_end()) - 4),
 1966 //                 runtime_call_Relocation::spec(), RELOC_IMM32 );
 1967 //   %}
 1968 
 1969   enc_class RegOpcImm (rRegI dst, immI8 shift) %{    // SHL, SAR, SHR
 1970     $$$emit8$primary;
 1971     emit_rm(cbuf, 0x3, $secondary, $dst$$reg);
 1972     $$$emit8$shift$$constant;
 1973   %}
 1974 
 1975   enc_class LdImmI (rRegI dst, immI src) %{    // Load Immediate
 1976     // Load immediate does not have a zero or sign extended version
 1977     // for 8-bit immediates
 1978     emit_opcode(cbuf, 0xB8 + $dst$$reg);
 1979     $$$emit32$src$$constant;
 1980   %}
 1981 
 1982   enc_class LdImmP (rRegI dst, immI src) %{    // Load Immediate
 1983     // Load immediate does not have a zero or sign extended version
 1984     // for 8-bit immediates
 1985     emit_opcode(cbuf, $primary + $dst$$reg);
 1986     $$$emit32$src$$constant;
 1987   %}
 1988 
 1989   enc_class LdImmL_Lo( eRegL dst, immL src) %{    // Load Immediate
 1990     // Load immediate does not have a zero or sign extended version
 1991     // for 8-bit immediates
 1992     int dst_enc = $dst$$reg;
 1993     int src_con = $src$$constant &amp; 0x0FFFFFFFFL;
 1994     if (src_con == 0) {
 1995       // xor dst, dst
 1996       emit_opcode(cbuf, 0x33);
 1997       emit_rm(cbuf, 0x3, dst_enc, dst_enc);
 1998     } else {
 1999       emit_opcode(cbuf, $primary + dst_enc);
 2000       emit_d32(cbuf, src_con);
 2001     }
 2002   %}
 2003 
 2004   enc_class LdImmL_Hi( eRegL dst, immL src) %{    // Load Immediate
 2005     // Load immediate does not have a zero or sign extended version
 2006     // for 8-bit immediates
 2007     int dst_enc = $dst$$reg + 2;
 2008     int src_con = ((julong)($src$$constant)) &gt;&gt; 32;
 2009     if (src_con == 0) {
 2010       // xor dst, dst
 2011       emit_opcode(cbuf, 0x33);
 2012       emit_rm(cbuf, 0x3, dst_enc, dst_enc);
 2013     } else {
 2014       emit_opcode(cbuf, $primary + dst_enc);
 2015       emit_d32(cbuf, src_con);
 2016     }
 2017   %}
 2018 
 2019 
 2020   // Encode a reg-reg copy.  If it is useless, then empty encoding.
 2021   enc_class enc_Copy( rRegI dst, rRegI src ) %{
 2022     encode_Copy( cbuf, $dst$$reg, $src$$reg );
 2023   %}
 2024 
 2025   enc_class enc_CopyL_Lo( rRegI dst, eRegL src ) %{
 2026     encode_Copy( cbuf, $dst$$reg, $src$$reg );
 2027   %}
 2028 
 2029   enc_class RegReg (rRegI dst, rRegI src) %{    // RegReg(Many)
 2030     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2031   %}
 2032 
 2033   enc_class RegReg_Lo(eRegL dst, eRegL src) %{    // RegReg(Many)
 2034     $$$emit8$primary;
 2035     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2036   %}
 2037 
 2038   enc_class RegReg_Hi(eRegL dst, eRegL src) %{    // RegReg(Many)
 2039     $$$emit8$secondary;
 2040     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($src$$reg));
 2041   %}
 2042 
 2043   enc_class RegReg_Lo2(eRegL dst, eRegL src) %{    // RegReg(Many)
 2044     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2045   %}
 2046 
 2047   enc_class RegReg_Hi2(eRegL dst, eRegL src) %{    // RegReg(Many)
 2048     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($src$$reg));
 2049   %}
 2050 
 2051   enc_class RegReg_HiLo( eRegL src, rRegI dst ) %{
 2052     emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($src$$reg));
 2053   %}
 2054 
 2055   enc_class Con32 (immI src) %{    // Con32(storeImmI)
 2056     // Output immediate
 2057     $$$emit32$src$$constant;
 2058   %}
 2059 
 2060   enc_class Con32FPR_as_bits(immFPR src) %{        // storeF_imm
 2061     // Output Float immediate bits
 2062     jfloat jf = $src$$constant;
 2063     int    jf_as_bits = jint_cast( jf );
 2064     emit_d32(cbuf, jf_as_bits);
 2065   %}
 2066 
 2067   enc_class Con32F_as_bits(immF src) %{      // storeX_imm
 2068     // Output Float immediate bits
 2069     jfloat jf = $src$$constant;
 2070     int    jf_as_bits = jint_cast( jf );
 2071     emit_d32(cbuf, jf_as_bits);
 2072   %}
 2073 
 2074   enc_class Con16 (immI src) %{    // Con16(storeImmI)
 2075     // Output immediate
 2076     $$$emit16$src$$constant;
 2077   %}
 2078 
 2079   enc_class Con_d32(immI src) %{
 2080     emit_d32(cbuf,$src$$constant);
 2081   %}
 2082 
 2083   enc_class conmemref (eRegP t1) %{    // Con32(storeImmI)
 2084     // Output immediate memory reference
 2085     emit_rm(cbuf, 0x00, $t1$$reg, 0x05 );
 2086     emit_d32(cbuf, 0x00);
 2087   %}
 2088 
 2089   enc_class lock_prefix( ) %{
 2090     emit_opcode(cbuf,0xF0);         // [Lock]
 2091   %}
 2092 
 2093   // Cmp-xchg long value.
 2094   // Note: we need to swap rbx, and rcx before and after the
 2095   //       cmpxchg8 instruction because the instruction uses
 2096   //       rcx as the high order word of the new value to store but
 2097   //       our register encoding uses rbx,.
 2098   enc_class enc_cmpxchg8(eSIRegP mem_ptr) %{
 2099 
 2100     // XCHG  rbx,ecx
 2101     emit_opcode(cbuf,0x87);
 2102     emit_opcode(cbuf,0xD9);
 2103     // [Lock]
 2104     emit_opcode(cbuf,0xF0);
 2105     // CMPXCHG8 [Eptr]
 2106     emit_opcode(cbuf,0x0F);
 2107     emit_opcode(cbuf,0xC7);
 2108     emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );
 2109     // XCHG  rbx,ecx
 2110     emit_opcode(cbuf,0x87);
 2111     emit_opcode(cbuf,0xD9);
 2112   %}
 2113 
 2114   enc_class enc_cmpxchg(eSIRegP mem_ptr) %{
 2115     // [Lock]
 2116     emit_opcode(cbuf,0xF0);
 2117 
 2118     // CMPXCHG [Eptr]
 2119     emit_opcode(cbuf,0x0F);
 2120     emit_opcode(cbuf,0xB1);
 2121     emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );
 2122   %}
 2123 
 2124   enc_class enc_cmpxchgb(eSIRegP mem_ptr) %{
 2125     // [Lock]
 2126     emit_opcode(cbuf,0xF0);
 2127 
 2128     // CMPXCHGB [Eptr]
 2129     emit_opcode(cbuf,0x0F);
 2130     emit_opcode(cbuf,0xB0);
 2131     emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );
 2132   %}
 2133 
 2134   enc_class enc_cmpxchgw(eSIRegP mem_ptr) %{
 2135     // [Lock]
 2136     emit_opcode(cbuf,0xF0);
 2137 
 2138     // 16-bit mode
 2139     emit_opcode(cbuf, 0x66);
 2140 
 2141     // CMPXCHGW [Eptr]
 2142     emit_opcode(cbuf,0x0F);
 2143     emit_opcode(cbuf,0xB1);
 2144     emit_rm( cbuf, 0x0, 1, $mem_ptr$$reg );
 2145   %}
 2146 
 2147   enc_class enc_flags_ne_to_boolean( iRegI res ) %{
 2148     int res_encoding = $res$$reg;
 2149 
 2150     // MOV  res,0
 2151     emit_opcode( cbuf, 0xB8 + res_encoding);
 2152     emit_d32( cbuf, 0 );
 2153     // JNE,s  fail
 2154     emit_opcode(cbuf,0x75);
 2155     emit_d8(cbuf, 5 );
 2156     // MOV  res,1
 2157     emit_opcode( cbuf, 0xB8 + res_encoding);
 2158     emit_d32( cbuf, 1 );
 2159     // fail:
 2160   %}
 2161 
 2162   enc_class set_instruction_start( ) %{
 2163     cbuf.set_insts_mark();            // Mark start of opcode for reloc info in mem operand
 2164   %}
 2165 
 2166   enc_class RegMem (rRegI ereg, memory mem) %{    // emit_reg_mem
 2167     int reg_encoding = $ereg$$reg;
 2168     int base  = $mem$$base;
 2169     int index = $mem$$index;
 2170     int scale = $mem$$scale;
 2171     int displace = $mem$$disp;
 2172     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();
 2173     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);
 2174   %}
 2175 
 2176   enc_class RegMem_Hi(eRegL ereg, memory mem) %{    // emit_reg_mem
 2177     int reg_encoding = HIGH_FROM_LOW($ereg$$reg);  // Hi register of pair, computed from lo
 2178     int base  = $mem$$base;
 2179     int index = $mem$$index;
 2180     int scale = $mem$$scale;
 2181     int displace = $mem$$disp + 4;      // Offset is 4 further in memory
 2182     assert( $mem-&gt;disp_reloc() == relocInfo::none, &quot;Cannot add 4 to oop&quot; );
 2183     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, relocInfo::none);
 2184   %}
 2185 
 2186   enc_class move_long_small_shift( eRegL dst, immI_1_31 cnt ) %{
 2187     int r1, r2;
 2188     if( $tertiary == 0xA4 ) { r1 = $dst$$reg;  r2 = HIGH_FROM_LOW($dst$$reg); }
 2189     else                    { r2 = $dst$$reg;  r1 = HIGH_FROM_LOW($dst$$reg); }
 2190     emit_opcode(cbuf,0x0F);
 2191     emit_opcode(cbuf,$tertiary);
 2192     emit_rm(cbuf, 0x3, r1, r2);
 2193     emit_d8(cbuf,$cnt$$constant);
 2194     emit_d8(cbuf,$primary);
 2195     emit_rm(cbuf, 0x3, $secondary, r1);
 2196     emit_d8(cbuf,$cnt$$constant);
 2197   %}
 2198 
 2199   enc_class move_long_big_shift_sign( eRegL dst, immI_32_63 cnt ) %{
 2200     emit_opcode( cbuf, 0x8B ); // Move
 2201     emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg));
 2202     if( $cnt$$constant &gt; 32 ) { // Shift, if not by zero
 2203       emit_d8(cbuf,$primary);
 2204       emit_rm(cbuf, 0x3, $secondary, $dst$$reg);
 2205       emit_d8(cbuf,$cnt$$constant-32);
 2206     }
 2207     emit_d8(cbuf,$primary);
 2208     emit_rm(cbuf, 0x3, $secondary, HIGH_FROM_LOW($dst$$reg));
 2209     emit_d8(cbuf,31);
 2210   %}
 2211 
 2212   enc_class move_long_big_shift_clr( eRegL dst, immI_32_63 cnt ) %{
 2213     int r1, r2;
 2214     if( $secondary == 0x5 ) { r1 = $dst$$reg;  r2 = HIGH_FROM_LOW($dst$$reg); }
 2215     else                    { r2 = $dst$$reg;  r1 = HIGH_FROM_LOW($dst$$reg); }
 2216 
 2217     emit_opcode( cbuf, 0x8B ); // Move r1,r2
 2218     emit_rm(cbuf, 0x3, r1, r2);
 2219     if( $cnt$$constant &gt; 32 ) { // Shift, if not by zero
 2220       emit_opcode(cbuf,$primary);
 2221       emit_rm(cbuf, 0x3, $secondary, r1);
 2222       emit_d8(cbuf,$cnt$$constant-32);
 2223     }
 2224     emit_opcode(cbuf,0x33);  // XOR r2,r2
 2225     emit_rm(cbuf, 0x3, r2, r2);
 2226   %}
 2227 
 2228   // Clone of RegMem but accepts an extra parameter to access each
 2229   // half of a double in memory; it never needs relocation info.
 2230   enc_class Mov_MemD_half_to_Reg (immI opcode, memory mem, immI disp_for_half, rRegI rm_reg) %{
 2231     emit_opcode(cbuf,$opcode$$constant);
 2232     int reg_encoding = $rm_reg$$reg;
 2233     int base     = $mem$$base;
 2234     int index    = $mem$$index;
 2235     int scale    = $mem$$scale;
 2236     int displace = $mem$$disp + $disp_for_half$$constant;
 2237     relocInfo::relocType disp_reloc = relocInfo::none;
 2238     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);
 2239   %}
 2240 
 2241   // !!!!! Special Custom Code used by MemMove, and stack access instructions !!!!!
 2242   //
 2243   // Clone of RegMem except the RM-byte&#39;s reg/opcode field is an ADLC-time constant
 2244   // and it never needs relocation information.
 2245   // Frequently used to move data between FPU&#39;s Stack Top and memory.
 2246   enc_class RMopc_Mem_no_oop (immI rm_opcode, memory mem) %{
 2247     int rm_byte_opcode = $rm_opcode$$constant;
 2248     int base     = $mem$$base;
 2249     int index    = $mem$$index;
 2250     int scale    = $mem$$scale;
 2251     int displace = $mem$$disp;
 2252     assert( $mem-&gt;disp_reloc() == relocInfo::none, &quot;No oops here because no reloc info allowed&quot; );
 2253     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, relocInfo::none);
 2254   %}
 2255 
 2256   enc_class RMopc_Mem (immI rm_opcode, memory mem) %{
 2257     int rm_byte_opcode = $rm_opcode$$constant;
 2258     int base     = $mem$$base;
 2259     int index    = $mem$$index;
 2260     int scale    = $mem$$scale;
 2261     int displace = $mem$$disp;
 2262     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc(); // disp-as-oop when working with static globals
 2263     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, disp_reloc);
 2264   %}
 2265 
 2266   enc_class RegLea (rRegI dst, rRegI src0, immI src1 ) %{    // emit_reg_lea
 2267     int reg_encoding = $dst$$reg;
 2268     int base         = $src0$$reg;      // 0xFFFFFFFF indicates no base
 2269     int index        = 0x04;            // 0x04 indicates no index
 2270     int scale        = 0x00;            // 0x00 indicates no scale
 2271     int displace     = $src1$$constant; // 0x00 indicates no displacement
 2272     relocInfo::relocType disp_reloc = relocInfo::none;
 2273     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);
 2274   %}
 2275 
 2276   enc_class min_enc (rRegI dst, rRegI src) %{    // MIN
 2277     // Compare dst,src
 2278     emit_opcode(cbuf,0x3B);
 2279     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2280     // jmp dst &lt; src around move
 2281     emit_opcode(cbuf,0x7C);
 2282     emit_d8(cbuf,2);
 2283     // move dst,src
 2284     emit_opcode(cbuf,0x8B);
 2285     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2286   %}
 2287 
 2288   enc_class max_enc (rRegI dst, rRegI src) %{    // MAX
 2289     // Compare dst,src
 2290     emit_opcode(cbuf,0x3B);
 2291     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2292     // jmp dst &gt; src around move
 2293     emit_opcode(cbuf,0x7F);
 2294     emit_d8(cbuf,2);
 2295     // move dst,src
 2296     emit_opcode(cbuf,0x8B);
 2297     emit_rm(cbuf, 0x3, $dst$$reg, $src$$reg);
 2298   %}
 2299 
 2300   enc_class enc_FPR_store(memory mem, regDPR src) %{
 2301     // If src is FPR1, we can just FST to store it.
 2302     // Else we need to FLD it to FPR1, then FSTP to store/pop it.
 2303     int reg_encoding = 0x2; // Just store
 2304     int base  = $mem$$base;
 2305     int index = $mem$$index;
 2306     int scale = $mem$$scale;
 2307     int displace = $mem$$disp;
 2308     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc(); // disp-as-oop when working with static globals
 2309     if( $src$$reg != FPR1L_enc ) {
 2310       reg_encoding = 0x3;  // Store &amp; pop
 2311       emit_opcode( cbuf, 0xD9 ); // FLD (i.e., push it)
 2312       emit_d8( cbuf, 0xC0-1+$src$$reg );
 2313     }
 2314     cbuf.set_insts_mark();       // Mark start of opcode for reloc info in mem operand
 2315     emit_opcode(cbuf,$primary);
 2316     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace, disp_reloc);
 2317   %}
 2318 
 2319   enc_class neg_reg(rRegI dst) %{
 2320     // NEG $dst
 2321     emit_opcode(cbuf,0xF7);
 2322     emit_rm(cbuf, 0x3, 0x03, $dst$$reg );
 2323   %}
 2324 
 2325   enc_class setLT_reg(eCXRegI dst) %{
 2326     // SETLT $dst
 2327     emit_opcode(cbuf,0x0F);
 2328     emit_opcode(cbuf,0x9C);
 2329     emit_rm( cbuf, 0x3, 0x4, $dst$$reg );
 2330   %}
 2331 
 2332   enc_class enc_cmpLTP(ncxRegI p, ncxRegI q, ncxRegI y, eCXRegI tmp) %{    // cadd_cmpLT
 2333     int tmpReg = $tmp$$reg;
 2334 
 2335     // SUB $p,$q
 2336     emit_opcode(cbuf,0x2B);
 2337     emit_rm(cbuf, 0x3, $p$$reg, $q$$reg);
 2338     // SBB $tmp,$tmp
 2339     emit_opcode(cbuf,0x1B);
 2340     emit_rm(cbuf, 0x3, tmpReg, tmpReg);
 2341     // AND $tmp,$y
 2342     emit_opcode(cbuf,0x23);
 2343     emit_rm(cbuf, 0x3, tmpReg, $y$$reg);
 2344     // ADD $p,$tmp
 2345     emit_opcode(cbuf,0x03);
 2346     emit_rm(cbuf, 0x3, $p$$reg, tmpReg);
 2347   %}
 2348 
 2349   enc_class shift_left_long( eRegL dst, eCXRegI shift ) %{
 2350     // TEST shift,32
 2351     emit_opcode(cbuf,0xF7);
 2352     emit_rm(cbuf, 0x3, 0, ECX_enc);
 2353     emit_d32(cbuf,0x20);
 2354     // JEQ,s small
 2355     emit_opcode(cbuf, 0x74);
 2356     emit_d8(cbuf, 0x04);
 2357     // MOV    $dst.hi,$dst.lo
 2358     emit_opcode( cbuf, 0x8B );
 2359     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg );
 2360     // CLR    $dst.lo
 2361     emit_opcode(cbuf, 0x33);
 2362     emit_rm(cbuf, 0x3, $dst$$reg, $dst$$reg);
 2363 // small:
 2364     // SHLD   $dst.hi,$dst.lo,$shift
 2365     emit_opcode(cbuf,0x0F);
 2366     emit_opcode(cbuf,0xA5);
 2367     emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg));
 2368     // SHL    $dst.lo,$shift&quot;
 2369     emit_opcode(cbuf,0xD3);
 2370     emit_rm(cbuf, 0x3, 0x4, $dst$$reg );
 2371   %}
 2372 
 2373   enc_class shift_right_long( eRegL dst, eCXRegI shift ) %{
 2374     // TEST shift,32
 2375     emit_opcode(cbuf,0xF7);
 2376     emit_rm(cbuf, 0x3, 0, ECX_enc);
 2377     emit_d32(cbuf,0x20);
 2378     // JEQ,s small
 2379     emit_opcode(cbuf, 0x74);
 2380     emit_d8(cbuf, 0x04);
 2381     // MOV    $dst.lo,$dst.hi
 2382     emit_opcode( cbuf, 0x8B );
 2383     emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg) );
 2384     // CLR    $dst.hi
 2385     emit_opcode(cbuf, 0x33);
 2386     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($dst$$reg));
 2387 // small:
 2388     // SHRD   $dst.lo,$dst.hi,$shift
 2389     emit_opcode(cbuf,0x0F);
 2390     emit_opcode(cbuf,0xAD);
 2391     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg);
 2392     // SHR    $dst.hi,$shift&quot;
 2393     emit_opcode(cbuf,0xD3);
 2394     emit_rm(cbuf, 0x3, 0x5, HIGH_FROM_LOW($dst$$reg) );
 2395   %}
 2396 
 2397   enc_class shift_right_arith_long( eRegL dst, eCXRegI shift ) %{
 2398     // TEST shift,32
 2399     emit_opcode(cbuf,0xF7);
 2400     emit_rm(cbuf, 0x3, 0, ECX_enc);
 2401     emit_d32(cbuf,0x20);
 2402     // JEQ,s small
 2403     emit_opcode(cbuf, 0x74);
 2404     emit_d8(cbuf, 0x05);
 2405     // MOV    $dst.lo,$dst.hi
 2406     emit_opcode( cbuf, 0x8B );
 2407     emit_rm(cbuf, 0x3, $dst$$reg, HIGH_FROM_LOW($dst$$reg) );
 2408     // SAR    $dst.hi,31
 2409     emit_opcode(cbuf, 0xC1);
 2410     emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW($dst$$reg) );
 2411     emit_d8(cbuf, 0x1F );
 2412 // small:
 2413     // SHRD   $dst.lo,$dst.hi,$shift
 2414     emit_opcode(cbuf,0x0F);
 2415     emit_opcode(cbuf,0xAD);
 2416     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg);
 2417     // SAR    $dst.hi,$shift&quot;
 2418     emit_opcode(cbuf,0xD3);
 2419     emit_rm(cbuf, 0x3, 0x7, HIGH_FROM_LOW($dst$$reg) );
 2420   %}
 2421 
 2422 
 2423   // ----------------- Encodings for floating point unit -----------------
 2424   // May leave result in FPU-TOS or FPU reg depending on opcodes
 2425   enc_class OpcReg_FPR(regFPR src) %{    // FMUL, FDIV
 2426     $$$emit8$primary;
 2427     emit_rm(cbuf, 0x3, $secondary, $src$$reg );
 2428   %}
 2429 
 2430   // Pop argument in FPR0 with FSTP ST(0)
 2431   enc_class PopFPU() %{
 2432     emit_opcode( cbuf, 0xDD );
 2433     emit_d8( cbuf, 0xD8 );
 2434   %}
 2435 
 2436   // !!!!! equivalent to Pop_Reg_F
 2437   enc_class Pop_Reg_DPR( regDPR dst ) %{
 2438     emit_opcode( cbuf, 0xDD );           // FSTP   ST(i)
 2439     emit_d8( cbuf, 0xD8+$dst$$reg );
 2440   %}
 2441 
 2442   enc_class Push_Reg_DPR( regDPR dst ) %{
 2443     emit_opcode( cbuf, 0xD9 );
 2444     emit_d8( cbuf, 0xC0-1+$dst$$reg );   // FLD ST(i-1)
 2445   %}
 2446 
 2447   enc_class strictfp_bias1( regDPR dst ) %{
 2448     emit_opcode( cbuf, 0xDB );           // FLD m80real
 2449     emit_opcode( cbuf, 0x2D );
 2450     emit_d32( cbuf, (int)StubRoutines::addr_fpu_subnormal_bias1() );
 2451     emit_opcode( cbuf, 0xDE );           // FMULP ST(dst), ST0
 2452     emit_opcode( cbuf, 0xC8+$dst$$reg );
 2453   %}
 2454 
 2455   enc_class strictfp_bias2( regDPR dst ) %{
 2456     emit_opcode( cbuf, 0xDB );           // FLD m80real
 2457     emit_opcode( cbuf, 0x2D );
 2458     emit_d32( cbuf, (int)StubRoutines::addr_fpu_subnormal_bias2() );
 2459     emit_opcode( cbuf, 0xDE );           // FMULP ST(dst), ST0
 2460     emit_opcode( cbuf, 0xC8+$dst$$reg );
 2461   %}
 2462 
 2463   // Special case for moving an integer register to a stack slot.
 2464   enc_class OpcPRegSS( stackSlotI dst, rRegI src ) %{ // RegSS
 2465     store_to_stackslot( cbuf, $primary, $src$$reg, $dst$$disp );
 2466   %}
 2467 
 2468   // Special case for moving a register to a stack slot.
 2469   enc_class RegSS( stackSlotI dst, rRegI src ) %{ // RegSS
 2470     // Opcode already emitted
 2471     emit_rm( cbuf, 0x02, $src$$reg, ESP_enc );   // R/M byte
 2472     emit_rm( cbuf, 0x00, ESP_enc, ESP_enc);          // SIB byte
 2473     emit_d32(cbuf, $dst$$disp);   // Displacement
 2474   %}
 2475 
 2476   // Push the integer in stackSlot &#39;src&#39; onto FP-stack
 2477   enc_class Push_Mem_I( memory src ) %{    // FILD   [ESP+src]
 2478     store_to_stackslot( cbuf, $primary, $secondary, $src$$disp );
 2479   %}
 2480 
 2481   // Push FPU&#39;s TOS float to a stack-slot, and pop FPU-stack
 2482   enc_class Pop_Mem_FPR( stackSlotF dst ) %{ // FSTP_S [ESP+dst]
 2483     store_to_stackslot( cbuf, 0xD9, 0x03, $dst$$disp );
 2484   %}
 2485 
 2486   // Same as Pop_Mem_F except for opcode
 2487   // Push FPU&#39;s TOS double to a stack-slot, and pop FPU-stack
 2488   enc_class Pop_Mem_DPR( stackSlotD dst ) %{ // FSTP_D [ESP+dst]
 2489     store_to_stackslot( cbuf, 0xDD, 0x03, $dst$$disp );
 2490   %}
 2491 
 2492   enc_class Pop_Reg_FPR( regFPR dst ) %{
 2493     emit_opcode( cbuf, 0xDD );           // FSTP   ST(i)
 2494     emit_d8( cbuf, 0xD8+$dst$$reg );
 2495   %}
 2496 
 2497   enc_class Push_Reg_FPR( regFPR dst ) %{
 2498     emit_opcode( cbuf, 0xD9 );           // FLD    ST(i-1)
 2499     emit_d8( cbuf, 0xC0-1+$dst$$reg );
 2500   %}
 2501 
 2502   // Push FPU&#39;s float to a stack-slot, and pop FPU-stack
 2503   enc_class Pop_Mem_Reg_FPR( stackSlotF dst, regFPR src ) %{
 2504     int pop = 0x02;
 2505     if ($src$$reg != FPR1L_enc) {
 2506       emit_opcode( cbuf, 0xD9 );         // FLD    ST(i-1)
 2507       emit_d8( cbuf, 0xC0-1+$src$$reg );
 2508       pop = 0x03;
 2509     }
 2510     store_to_stackslot( cbuf, 0xD9, pop, $dst$$disp ); // FST&lt;P&gt;_S  [ESP+dst]
 2511   %}
 2512 
 2513   // Push FPU&#39;s double to a stack-slot, and pop FPU-stack
 2514   enc_class Pop_Mem_Reg_DPR( stackSlotD dst, regDPR src ) %{
 2515     int pop = 0x02;
 2516     if ($src$$reg != FPR1L_enc) {
 2517       emit_opcode( cbuf, 0xD9 );         // FLD    ST(i-1)
 2518       emit_d8( cbuf, 0xC0-1+$src$$reg );
 2519       pop = 0x03;
 2520     }
 2521     store_to_stackslot( cbuf, 0xDD, pop, $dst$$disp ); // FST&lt;P&gt;_D  [ESP+dst]
 2522   %}
 2523 
 2524   // Push FPU&#39;s double to a FPU-stack-slot, and pop FPU-stack
 2525   enc_class Pop_Reg_Reg_DPR( regDPR dst, regFPR src ) %{
 2526     int pop = 0xD0 - 1; // -1 since we skip FLD
 2527     if ($src$$reg != FPR1L_enc) {
 2528       emit_opcode( cbuf, 0xD9 );         // FLD    ST(src-1)
 2529       emit_d8( cbuf, 0xC0-1+$src$$reg );
 2530       pop = 0xD8;
 2531     }
 2532     emit_opcode( cbuf, 0xDD );
 2533     emit_d8( cbuf, pop+$dst$$reg );      // FST&lt;P&gt; ST(i)
 2534   %}
 2535 
 2536 
 2537   enc_class Push_Reg_Mod_DPR( regDPR dst, regDPR src) %{
 2538     // load dst in FPR0
 2539     emit_opcode( cbuf, 0xD9 );
 2540     emit_d8( cbuf, 0xC0-1+$dst$$reg );
 2541     if ($src$$reg != FPR1L_enc) {
 2542       // fincstp
 2543       emit_opcode (cbuf, 0xD9);
 2544       emit_opcode (cbuf, 0xF7);
 2545       // swap src with FPR1:
 2546       // FXCH FPR1 with src
 2547       emit_opcode(cbuf, 0xD9);
 2548       emit_d8(cbuf, 0xC8-1+$src$$reg );
 2549       // fdecstp
 2550       emit_opcode (cbuf, 0xD9);
 2551       emit_opcode (cbuf, 0xF6);
 2552     }
 2553   %}
 2554 
 2555   enc_class Push_ModD_encoding(regD src0, regD src1) %{
 2556     MacroAssembler _masm(&amp;cbuf);
 2557     __ subptr(rsp, 8);
 2558     __ movdbl(Address(rsp, 0), $src1$$XMMRegister);
 2559     __ fld_d(Address(rsp, 0));
 2560     __ movdbl(Address(rsp, 0), $src0$$XMMRegister);
 2561     __ fld_d(Address(rsp, 0));
 2562   %}
 2563 
 2564   enc_class Push_ModF_encoding(regF src0, regF src1) %{
 2565     MacroAssembler _masm(&amp;cbuf);
 2566     __ subptr(rsp, 4);
 2567     __ movflt(Address(rsp, 0), $src1$$XMMRegister);
 2568     __ fld_s(Address(rsp, 0));
 2569     __ movflt(Address(rsp, 0), $src0$$XMMRegister);
 2570     __ fld_s(Address(rsp, 0));
 2571   %}
 2572 
 2573   enc_class Push_ResultD(regD dst) %{
 2574     MacroAssembler _masm(&amp;cbuf);
 2575     __ fstp_d(Address(rsp, 0));
 2576     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
 2577     __ addptr(rsp, 8);
 2578   %}
 2579 
 2580   enc_class Push_ResultF(regF dst, immI d8) %{
 2581     MacroAssembler _masm(&amp;cbuf);
 2582     __ fstp_s(Address(rsp, 0));
 2583     __ movflt($dst$$XMMRegister, Address(rsp, 0));
 2584     __ addptr(rsp, $d8$$constant);
 2585   %}
 2586 
 2587   enc_class Push_SrcD(regD src) %{
 2588     MacroAssembler _masm(&amp;cbuf);
 2589     __ subptr(rsp, 8);
 2590     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
 2591     __ fld_d(Address(rsp, 0));
 2592   %}
 2593 
 2594   enc_class push_stack_temp_qword() %{
 2595     MacroAssembler _masm(&amp;cbuf);
 2596     __ subptr(rsp, 8);
 2597   %}
 2598 
 2599   enc_class pop_stack_temp_qword() %{
 2600     MacroAssembler _masm(&amp;cbuf);
 2601     __ addptr(rsp, 8);
 2602   %}
 2603 
 2604   enc_class push_xmm_to_fpr1(regD src) %{
 2605     MacroAssembler _masm(&amp;cbuf);
 2606     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
 2607     __ fld_d(Address(rsp, 0));
 2608   %}
 2609 
 2610   enc_class Push_Result_Mod_DPR( regDPR src) %{
 2611     if ($src$$reg != FPR1L_enc) {
 2612       // fincstp
 2613       emit_opcode (cbuf, 0xD9);
 2614       emit_opcode (cbuf, 0xF7);
 2615       // FXCH FPR1 with src
 2616       emit_opcode(cbuf, 0xD9);
 2617       emit_d8(cbuf, 0xC8-1+$src$$reg );
 2618       // fdecstp
 2619       emit_opcode (cbuf, 0xD9);
 2620       emit_opcode (cbuf, 0xF6);
 2621     }
 2622     // // following asm replaced with Pop_Reg_F or Pop_Mem_F
 2623     // // FSTP   FPR$dst$$reg
 2624     // emit_opcode( cbuf, 0xDD );
 2625     // emit_d8( cbuf, 0xD8+$dst$$reg );
 2626   %}
 2627 
 2628   enc_class fnstsw_sahf_skip_parity() %{
 2629     // fnstsw ax
 2630     emit_opcode( cbuf, 0xDF );
 2631     emit_opcode( cbuf, 0xE0 );
 2632     // sahf
 2633     emit_opcode( cbuf, 0x9E );
 2634     // jnp  ::skip
 2635     emit_opcode( cbuf, 0x7B );
 2636     emit_opcode( cbuf, 0x05 );
 2637   %}
 2638 
 2639   enc_class emitModDPR() %{
 2640     // fprem must be iterative
 2641     // :: loop
 2642     // fprem
 2643     emit_opcode( cbuf, 0xD9 );
 2644     emit_opcode( cbuf, 0xF8 );
 2645     // wait
 2646     emit_opcode( cbuf, 0x9b );
 2647     // fnstsw ax
 2648     emit_opcode( cbuf, 0xDF );
 2649     emit_opcode( cbuf, 0xE0 );
 2650     // sahf
 2651     emit_opcode( cbuf, 0x9E );
 2652     // jp  ::loop
 2653     emit_opcode( cbuf, 0x0F );
 2654     emit_opcode( cbuf, 0x8A );
 2655     emit_opcode( cbuf, 0xF4 );
 2656     emit_opcode( cbuf, 0xFF );
 2657     emit_opcode( cbuf, 0xFF );
 2658     emit_opcode( cbuf, 0xFF );
 2659   %}
 2660 
 2661   enc_class fpu_flags() %{
 2662     // fnstsw_ax
 2663     emit_opcode( cbuf, 0xDF);
 2664     emit_opcode( cbuf, 0xE0);
 2665     // test ax,0x0400
 2666     emit_opcode( cbuf, 0x66 );   // operand-size prefix for 16-bit immediate
 2667     emit_opcode( cbuf, 0xA9 );
 2668     emit_d16   ( cbuf, 0x0400 );
 2669     // // // This sequence works, but stalls for 12-16 cycles on PPro
 2670     // // test rax,0x0400
 2671     // emit_opcode( cbuf, 0xA9 );
 2672     // emit_d32   ( cbuf, 0x00000400 );
 2673     //
 2674     // jz exit (no unordered comparison)
 2675     emit_opcode( cbuf, 0x74 );
 2676     emit_d8    ( cbuf, 0x02 );
 2677     // mov ah,1 - treat as LT case (set carry flag)
 2678     emit_opcode( cbuf, 0xB4 );
 2679     emit_d8    ( cbuf, 0x01 );
 2680     // sahf
 2681     emit_opcode( cbuf, 0x9E);
 2682   %}
 2683 
 2684   enc_class cmpF_P6_fixup() %{
 2685     // Fixup the integer flags in case comparison involved a NaN
 2686     //
 2687     // JNP exit (no unordered comparison, P-flag is set by NaN)
 2688     emit_opcode( cbuf, 0x7B );
 2689     emit_d8    ( cbuf, 0x03 );
 2690     // MOV AH,1 - treat as LT case (set carry flag)
 2691     emit_opcode( cbuf, 0xB4 );
 2692     emit_d8    ( cbuf, 0x01 );
 2693     // SAHF
 2694     emit_opcode( cbuf, 0x9E);
 2695     // NOP     // target for branch to avoid branch to branch
 2696     emit_opcode( cbuf, 0x90);
 2697   %}
 2698 
 2699 //     fnstsw_ax();
 2700 //     sahf();
 2701 //     movl(dst, nan_result);
 2702 //     jcc(Assembler::parity, exit);
 2703 //     movl(dst, less_result);
 2704 //     jcc(Assembler::below, exit);
 2705 //     movl(dst, equal_result);
 2706 //     jcc(Assembler::equal, exit);
 2707 //     movl(dst, greater_result);
 2708 
 2709 // less_result     =  1;
 2710 // greater_result  = -1;
 2711 // equal_result    = 0;
 2712 // nan_result      = -1;
 2713 
 2714   enc_class CmpF_Result(rRegI dst) %{
 2715     // fnstsw_ax();
 2716     emit_opcode( cbuf, 0xDF);
 2717     emit_opcode( cbuf, 0xE0);
 2718     // sahf
 2719     emit_opcode( cbuf, 0x9E);
 2720     // movl(dst, nan_result);
 2721     emit_opcode( cbuf, 0xB8 + $dst$$reg);
 2722     emit_d32( cbuf, -1 );
 2723     // jcc(Assembler::parity, exit);
 2724     emit_opcode( cbuf, 0x7A );
 2725     emit_d8    ( cbuf, 0x13 );
 2726     // movl(dst, less_result);
 2727     emit_opcode( cbuf, 0xB8 + $dst$$reg);
 2728     emit_d32( cbuf, -1 );
 2729     // jcc(Assembler::below, exit);
 2730     emit_opcode( cbuf, 0x72 );
 2731     emit_d8    ( cbuf, 0x0C );
 2732     // movl(dst, equal_result);
 2733     emit_opcode( cbuf, 0xB8 + $dst$$reg);
 2734     emit_d32( cbuf, 0 );
 2735     // jcc(Assembler::equal, exit);
 2736     emit_opcode( cbuf, 0x74 );
 2737     emit_d8    ( cbuf, 0x05 );
 2738     // movl(dst, greater_result);
 2739     emit_opcode( cbuf, 0xB8 + $dst$$reg);
 2740     emit_d32( cbuf, 1 );
 2741   %}
 2742 
 2743 
 2744   // Compare the longs and set flags
 2745   // BROKEN!  Do Not use as-is
 2746   enc_class cmpl_test( eRegL src1, eRegL src2 ) %{
 2747     // CMP    $src1.hi,$src2.hi
 2748     emit_opcode( cbuf, 0x3B );
 2749     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($src1$$reg), HIGH_FROM_LOW($src2$$reg) );
 2750     // JNE,s  done
 2751     emit_opcode(cbuf,0x75);
 2752     emit_d8(cbuf, 2 );
 2753     // CMP    $src1.lo,$src2.lo
 2754     emit_opcode( cbuf, 0x3B );
 2755     emit_rm(cbuf, 0x3, $src1$$reg, $src2$$reg );
 2756 // done:
 2757   %}
 2758 
 2759   enc_class convert_int_long( regL dst, rRegI src ) %{
 2760     // mov $dst.lo,$src
 2761     int dst_encoding = $dst$$reg;
 2762     int src_encoding = $src$$reg;
 2763     encode_Copy( cbuf, dst_encoding  , src_encoding );
 2764     // mov $dst.hi,$src
 2765     encode_Copy( cbuf, HIGH_FROM_LOW(dst_encoding), src_encoding );
 2766     // sar $dst.hi,31
 2767     emit_opcode( cbuf, 0xC1 );
 2768     emit_rm(cbuf, 0x3, 7, HIGH_FROM_LOW(dst_encoding) );
 2769     emit_d8(cbuf, 0x1F );
 2770   %}
 2771 
 2772   enc_class convert_long_double( eRegL src ) %{
 2773     // push $src.hi
 2774     emit_opcode(cbuf, 0x50+HIGH_FROM_LOW($src$$reg));
 2775     // push $src.lo
 2776     emit_opcode(cbuf, 0x50+$src$$reg  );
 2777     // fild 64-bits at [SP]
 2778     emit_opcode(cbuf,0xdf);
 2779     emit_d8(cbuf, 0x6C);
 2780     emit_d8(cbuf, 0x24);
 2781     emit_d8(cbuf, 0x00);
 2782     // pop stack
 2783     emit_opcode(cbuf, 0x83); // add  SP, #8
 2784     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
 2785     emit_d8(cbuf, 0x8);
 2786   %}
 2787 
 2788   enc_class multiply_con_and_shift_high( eDXRegI dst, nadxRegI src1, eADXRegL_low_only src2, immI_32_63 cnt, eFlagsReg cr ) %{
 2789     // IMUL   EDX:EAX,$src1
 2790     emit_opcode( cbuf, 0xF7 );
 2791     emit_rm( cbuf, 0x3, 0x5, $src1$$reg );
 2792     // SAR    EDX,$cnt-32
 2793     int shift_count = ((int)$cnt$$constant) - 32;
 2794     if (shift_count &gt; 0) {
 2795       emit_opcode(cbuf, 0xC1);
 2796       emit_rm(cbuf, 0x3, 7, $dst$$reg );
 2797       emit_d8(cbuf, shift_count);
 2798     }
 2799   %}
 2800 
 2801   // this version doesn&#39;t have add sp, 8
 2802   enc_class convert_long_double2( eRegL src ) %{
 2803     // push $src.hi
 2804     emit_opcode(cbuf, 0x50+HIGH_FROM_LOW($src$$reg));
 2805     // push $src.lo
 2806     emit_opcode(cbuf, 0x50+$src$$reg  );
 2807     // fild 64-bits at [SP]
 2808     emit_opcode(cbuf,0xdf);
 2809     emit_d8(cbuf, 0x6C);
 2810     emit_d8(cbuf, 0x24);
 2811     emit_d8(cbuf, 0x00);
 2812   %}
 2813 
 2814   enc_class long_int_multiply( eADXRegL dst, nadxRegI src) %{
 2815     // Basic idea: long = (long)int * (long)int
 2816     // IMUL EDX:EAX, src
 2817     emit_opcode( cbuf, 0xF7 );
 2818     emit_rm( cbuf, 0x3, 0x5, $src$$reg);
 2819   %}
 2820 
 2821   enc_class long_uint_multiply( eADXRegL dst, nadxRegI src) %{
 2822     // Basic Idea:  long = (int &amp; 0xffffffffL) * (int &amp; 0xffffffffL)
 2823     // MUL EDX:EAX, src
 2824     emit_opcode( cbuf, 0xF7 );
 2825     emit_rm( cbuf, 0x3, 0x4, $src$$reg);
 2826   %}
 2827 
 2828   enc_class long_multiply( eADXRegL dst, eRegL src, rRegI tmp ) %{
 2829     // Basic idea: lo(result) = lo(x_lo * y_lo)
 2830     //             hi(result) = hi(x_lo * y_lo) + lo(x_hi * y_lo) + lo(x_lo * y_hi)
 2831     // MOV    $tmp,$src.lo
 2832     encode_Copy( cbuf, $tmp$$reg, $src$$reg );
 2833     // IMUL   $tmp,EDX
 2834     emit_opcode( cbuf, 0x0F );
 2835     emit_opcode( cbuf, 0xAF );
 2836     emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($dst$$reg) );
 2837     // MOV    EDX,$src.hi
 2838     encode_Copy( cbuf, HIGH_FROM_LOW($dst$$reg), HIGH_FROM_LOW($src$$reg) );
 2839     // IMUL   EDX,EAX
 2840     emit_opcode( cbuf, 0x0F );
 2841     emit_opcode( cbuf, 0xAF );
 2842     emit_rm( cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $dst$$reg );
 2843     // ADD    $tmp,EDX
 2844     emit_opcode( cbuf, 0x03 );
 2845     emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($dst$$reg) );
 2846     // MUL   EDX:EAX,$src.lo
 2847     emit_opcode( cbuf, 0xF7 );
 2848     emit_rm( cbuf, 0x3, 0x4, $src$$reg );
 2849     // ADD    EDX,ESI
 2850     emit_opcode( cbuf, 0x03 );
 2851     emit_rm( cbuf, 0x3, HIGH_FROM_LOW($dst$$reg), $tmp$$reg );
 2852   %}
 2853 
 2854   enc_class long_multiply_con( eADXRegL dst, immL_127 src, rRegI tmp ) %{
 2855     // Basic idea: lo(result) = lo(src * y_lo)
 2856     //             hi(result) = hi(src * y_lo) + lo(src * y_hi)
 2857     // IMUL   $tmp,EDX,$src
 2858     emit_opcode( cbuf, 0x6B );
 2859     emit_rm( cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($dst$$reg) );
 2860     emit_d8( cbuf, (int)$src$$constant );
 2861     // MOV    EDX,$src
 2862     emit_opcode(cbuf, 0xB8 + EDX_enc);
 2863     emit_d32( cbuf, (int)$src$$constant );
 2864     // MUL   EDX:EAX,EDX
 2865     emit_opcode( cbuf, 0xF7 );
 2866     emit_rm( cbuf, 0x3, 0x4, EDX_enc );
 2867     // ADD    EDX,ESI
 2868     emit_opcode( cbuf, 0x03 );
 2869     emit_rm( cbuf, 0x3, EDX_enc, $tmp$$reg );
 2870   %}
 2871 
 2872   enc_class long_div( eRegL src1, eRegL src2 ) %{
 2873     // PUSH src1.hi
 2874     emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src1$$reg) );
 2875     // PUSH src1.lo
 2876     emit_opcode(cbuf,               0x50+$src1$$reg  );
 2877     // PUSH src2.hi
 2878     emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src2$$reg) );
 2879     // PUSH src2.lo
 2880     emit_opcode(cbuf,               0x50+$src2$$reg  );
 2881     // CALL directly to the runtime
 2882     cbuf.set_insts_mark();
 2883     emit_opcode(cbuf,0xE8);       // Call into runtime
 2884     emit_d32_reloc(cbuf, (CAST_FROM_FN_PTR(address, SharedRuntime::ldiv) - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );
 2885     // Restore stack
 2886     emit_opcode(cbuf, 0x83); // add  SP, #framesize
 2887     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
 2888     emit_d8(cbuf, 4*4);
 2889   %}
 2890 
 2891   enc_class long_mod( eRegL src1, eRegL src2 ) %{
 2892     // PUSH src1.hi
 2893     emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src1$$reg) );
 2894     // PUSH src1.lo
 2895     emit_opcode(cbuf,               0x50+$src1$$reg  );
 2896     // PUSH src2.hi
 2897     emit_opcode(cbuf, HIGH_FROM_LOW(0x50+$src2$$reg) );
 2898     // PUSH src2.lo
 2899     emit_opcode(cbuf,               0x50+$src2$$reg  );
 2900     // CALL directly to the runtime
 2901     cbuf.set_insts_mark();
 2902     emit_opcode(cbuf,0xE8);       // Call into runtime
 2903     emit_d32_reloc(cbuf, (CAST_FROM_FN_PTR(address, SharedRuntime::lrem ) - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );
 2904     // Restore stack
 2905     emit_opcode(cbuf, 0x83); // add  SP, #framesize
 2906     emit_rm(cbuf, 0x3, 0x00, ESP_enc);
 2907     emit_d8(cbuf, 4*4);
 2908   %}
 2909 
 2910   enc_class long_cmp_flags0( eRegL src, rRegI tmp ) %{
 2911     // MOV   $tmp,$src.lo
 2912     emit_opcode(cbuf, 0x8B);
 2913     emit_rm(cbuf, 0x3, $tmp$$reg, $src$$reg);
 2914     // OR    $tmp,$src.hi
 2915     emit_opcode(cbuf, 0x0B);
 2916     emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src$$reg));
 2917   %}
 2918 
 2919   enc_class long_cmp_flags1( eRegL src1, eRegL src2 ) %{
 2920     // CMP    $src1.lo,$src2.lo
 2921     emit_opcode( cbuf, 0x3B );
 2922     emit_rm(cbuf, 0x3, $src1$$reg, $src2$$reg );
 2923     // JNE,s  skip
 2924     emit_cc(cbuf, 0x70, 0x5);
 2925     emit_d8(cbuf,2);
 2926     // CMP    $src1.hi,$src2.hi
 2927     emit_opcode( cbuf, 0x3B );
 2928     emit_rm(cbuf, 0x3, HIGH_FROM_LOW($src1$$reg), HIGH_FROM_LOW($src2$$reg) );
 2929   %}
 2930 
 2931   enc_class long_cmp_flags2( eRegL src1, eRegL src2, rRegI tmp ) %{
 2932     // CMP    $src1.lo,$src2.lo\t! Long compare; set flags for low bits
 2933     emit_opcode( cbuf, 0x3B );
 2934     emit_rm(cbuf, 0x3, $src1$$reg, $src2$$reg );
 2935     // MOV    $tmp,$src1.hi
 2936     emit_opcode( cbuf, 0x8B );
 2937     emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src1$$reg) );
 2938     // SBB   $tmp,$src2.hi\t! Compute flags for long compare
 2939     emit_opcode( cbuf, 0x1B );
 2940     emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src2$$reg) );
 2941   %}
 2942 
 2943   enc_class long_cmp_flags3( eRegL src, rRegI tmp ) %{
 2944     // XOR    $tmp,$tmp
 2945     emit_opcode(cbuf,0x33);  // XOR
 2946     emit_rm(cbuf,0x3, $tmp$$reg, $tmp$$reg);
 2947     // CMP    $tmp,$src.lo
 2948     emit_opcode( cbuf, 0x3B );
 2949     emit_rm(cbuf, 0x3, $tmp$$reg, $src$$reg );
 2950     // SBB    $tmp,$src.hi
 2951     emit_opcode( cbuf, 0x1B );
 2952     emit_rm(cbuf, 0x3, $tmp$$reg, HIGH_FROM_LOW($src$$reg) );
 2953   %}
 2954 
 2955  // Sniff, sniff... smells like Gnu Superoptimizer
 2956   enc_class neg_long( eRegL dst ) %{
 2957     emit_opcode(cbuf,0xF7);    // NEG hi
 2958     emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW($dst$$reg));
 2959     emit_opcode(cbuf,0xF7);    // NEG lo
 2960     emit_rm    (cbuf,0x3, 0x3,               $dst$$reg );
 2961     emit_opcode(cbuf,0x83);    // SBB hi,0
 2962     emit_rm    (cbuf,0x3, 0x3, HIGH_FROM_LOW($dst$$reg));
 2963     emit_d8    (cbuf,0 );
 2964   %}
 2965 
 2966   enc_class enc_pop_rdx() %{
 2967     emit_opcode(cbuf,0x5A);
 2968   %}
 2969 
 2970   enc_class enc_rethrow() %{
 2971     cbuf.set_insts_mark();
 2972     emit_opcode(cbuf, 0xE9);        // jmp    entry
 2973     emit_d32_reloc(cbuf, (int)OptoRuntime::rethrow_stub() - ((int)cbuf.insts_end())-4,
 2974                    runtime_call_Relocation::spec(), RELOC_IMM32 );
 2975   %}
 2976 
 2977 
 2978   // Convert a double to an int.  Java semantics require we do complex
 2979   // manglelations in the corner cases.  So we set the rounding mode to
 2980   // &#39;zero&#39;, store the darned double down as an int, and reset the
 2981   // rounding mode to &#39;nearest&#39;.  The hardware throws an exception which
 2982   // patches up the correct value directly to the stack.
 2983   enc_class DPR2I_encoding( regDPR src ) %{
 2984     // Flip to round-to-zero mode.  We attempted to allow invalid-op
 2985     // exceptions here, so that a NAN or other corner-case value will
 2986     // thrown an exception (but normal values get converted at full speed).
 2987     // However, I2C adapters and other float-stack manglers leave pending
 2988     // invalid-op exceptions hanging.  We would have to clear them before
 2989     // enabling them and that is more expensive than just testing for the
 2990     // invalid value Intel stores down in the corner cases.
 2991     emit_opcode(cbuf,0xD9);            // FLDCW  trunc
 2992     emit_opcode(cbuf,0x2D);
 2993     emit_d32(cbuf,(int)StubRoutines::addr_fpu_cntrl_wrd_trunc());
 2994     // Allocate a word
 2995     emit_opcode(cbuf,0x83);            // SUB ESP,4
 2996     emit_opcode(cbuf,0xEC);
 2997     emit_d8(cbuf,0x04);
 2998     // Encoding assumes a double has been pushed into FPR0.
 2999     // Store down the double as an int, popping the FPU stack
 3000     emit_opcode(cbuf,0xDB);            // FISTP [ESP]
 3001     emit_opcode(cbuf,0x1C);
 3002     emit_d8(cbuf,0x24);
 3003     // Restore the rounding mode; mask the exception
 3004     emit_opcode(cbuf,0xD9);            // FLDCW   std/24-bit mode
 3005     emit_opcode(cbuf,0x2D);
 3006     emit_d32( cbuf, Compile::current()-&gt;in_24_bit_fp_mode()
 3007         ? (int)StubRoutines::addr_fpu_cntrl_wrd_24()
 3008         : (int)StubRoutines::addr_fpu_cntrl_wrd_std());
 3009 
 3010     // Load the converted int; adjust CPU stack
 3011     emit_opcode(cbuf,0x58);       // POP EAX
 3012     emit_opcode(cbuf,0x3D);       // CMP EAX,imm
 3013     emit_d32   (cbuf,0x80000000); //         0x80000000
 3014     emit_opcode(cbuf,0x75);       // JNE around_slow_call
 3015     emit_d8    (cbuf,0x07);       // Size of slow_call
 3016     // Push src onto stack slow-path
 3017     emit_opcode(cbuf,0xD9 );      // FLD     ST(i)
 3018     emit_d8    (cbuf,0xC0-1+$src$$reg );
 3019     // CALL directly to the runtime
 3020     cbuf.set_insts_mark();
 3021     emit_opcode(cbuf,0xE8);       // Call into runtime
 3022     emit_d32_reloc(cbuf, (StubRoutines::d2i_wrapper() - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );
 3023     // Carry on here...
 3024   %}
 3025 
 3026   enc_class DPR2L_encoding( regDPR src ) %{
 3027     emit_opcode(cbuf,0xD9);            // FLDCW  trunc
 3028     emit_opcode(cbuf,0x2D);
 3029     emit_d32(cbuf,(int)StubRoutines::addr_fpu_cntrl_wrd_trunc());
 3030     // Allocate a word
 3031     emit_opcode(cbuf,0x83);            // SUB ESP,8
 3032     emit_opcode(cbuf,0xEC);
 3033     emit_d8(cbuf,0x08);
 3034     // Encoding assumes a double has been pushed into FPR0.
 3035     // Store down the double as a long, popping the FPU stack
 3036     emit_opcode(cbuf,0xDF);            // FISTP [ESP]
 3037     emit_opcode(cbuf,0x3C);
 3038     emit_d8(cbuf,0x24);
 3039     // Restore the rounding mode; mask the exception
 3040     emit_opcode(cbuf,0xD9);            // FLDCW   std/24-bit mode
 3041     emit_opcode(cbuf,0x2D);
 3042     emit_d32( cbuf, Compile::current()-&gt;in_24_bit_fp_mode()
 3043         ? (int)StubRoutines::addr_fpu_cntrl_wrd_24()
 3044         : (int)StubRoutines::addr_fpu_cntrl_wrd_std());
 3045 
 3046     // Load the converted int; adjust CPU stack
 3047     emit_opcode(cbuf,0x58);       // POP EAX
 3048     emit_opcode(cbuf,0x5A);       // POP EDX
 3049     emit_opcode(cbuf,0x81);       // CMP EDX,imm
 3050     emit_d8    (cbuf,0xFA);       // rdx
 3051     emit_d32   (cbuf,0x80000000); //         0x80000000
 3052     emit_opcode(cbuf,0x75);       // JNE around_slow_call
 3053     emit_d8    (cbuf,0x07+4);     // Size of slow_call
 3054     emit_opcode(cbuf,0x85);       // TEST EAX,EAX
 3055     emit_opcode(cbuf,0xC0);       // 2/rax,/rax,
 3056     emit_opcode(cbuf,0x75);       // JNE around_slow_call
 3057     emit_d8    (cbuf,0x07);       // Size of slow_call
 3058     // Push src onto stack slow-path
 3059     emit_opcode(cbuf,0xD9 );      // FLD     ST(i)
 3060     emit_d8    (cbuf,0xC0-1+$src$$reg );
 3061     // CALL directly to the runtime
 3062     cbuf.set_insts_mark();
 3063     emit_opcode(cbuf,0xE8);       // Call into runtime
 3064     emit_d32_reloc(cbuf, (StubRoutines::d2l_wrapper() - cbuf.insts_end()) - 4, runtime_call_Relocation::spec(), RELOC_IMM32 );
 3065     // Carry on here...
 3066   %}
 3067 
 3068   enc_class FMul_ST_reg( eRegFPR src1 ) %{
 3069     // Operand was loaded from memory into fp ST (stack top)
 3070     // FMUL   ST,$src  /* D8 C8+i */
 3071     emit_opcode(cbuf, 0xD8);
 3072     emit_opcode(cbuf, 0xC8 + $src1$$reg);
 3073   %}
 3074 
 3075   enc_class FAdd_ST_reg( eRegFPR src2 ) %{
 3076     // FADDP  ST,src2  /* D8 C0+i */
 3077     emit_opcode(cbuf, 0xD8);
 3078     emit_opcode(cbuf, 0xC0 + $src2$$reg);
 3079     //could use FADDP  src2,fpST  /* DE C0+i */
 3080   %}
 3081 
 3082   enc_class FAddP_reg_ST( eRegFPR src2 ) %{
 3083     // FADDP  src2,ST  /* DE C0+i */
 3084     emit_opcode(cbuf, 0xDE);
 3085     emit_opcode(cbuf, 0xC0 + $src2$$reg);
 3086   %}
 3087 
 3088   enc_class subFPR_divFPR_encode( eRegFPR src1, eRegFPR src2) %{
 3089     // Operand has been loaded into fp ST (stack top)
 3090       // FSUB   ST,$src1
 3091       emit_opcode(cbuf, 0xD8);
 3092       emit_opcode(cbuf, 0xE0 + $src1$$reg);
 3093 
 3094       // FDIV
 3095       emit_opcode(cbuf, 0xD8);
 3096       emit_opcode(cbuf, 0xF0 + $src2$$reg);
 3097   %}
 3098 
 3099   enc_class MulFAddF (eRegFPR src1, eRegFPR src2) %{
 3100     // Operand was loaded from memory into fp ST (stack top)
 3101     // FADD   ST,$src  /* D8 C0+i */
 3102     emit_opcode(cbuf, 0xD8);
 3103     emit_opcode(cbuf, 0xC0 + $src1$$reg);
 3104 
 3105     // FMUL  ST,src2  /* D8 C*+i */
 3106     emit_opcode(cbuf, 0xD8);
 3107     emit_opcode(cbuf, 0xC8 + $src2$$reg);
 3108   %}
 3109 
 3110 
 3111   enc_class MulFAddFreverse (eRegFPR src1, eRegFPR src2) %{
 3112     // Operand was loaded from memory into fp ST (stack top)
 3113     // FADD   ST,$src  /* D8 C0+i */
 3114     emit_opcode(cbuf, 0xD8);
 3115     emit_opcode(cbuf, 0xC0 + $src1$$reg);
 3116 
 3117     // FMULP  src2,ST  /* DE C8+i */
 3118     emit_opcode(cbuf, 0xDE);
 3119     emit_opcode(cbuf, 0xC8 + $src2$$reg);
 3120   %}
 3121 
 3122   // Atomically load the volatile long
 3123   enc_class enc_loadL_volatile( memory mem, stackSlotL dst ) %{
 3124     emit_opcode(cbuf,0xDF);
 3125     int rm_byte_opcode = 0x05;
 3126     int base     = $mem$$base;
 3127     int index    = $mem$$index;
 3128     int scale    = $mem$$scale;
 3129     int displace = $mem$$disp;
 3130     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc(); // disp-as-oop when working with static globals
 3131     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, disp_reloc);
 3132     store_to_stackslot( cbuf, 0x0DF, 0x07, $dst$$disp );
 3133   %}
 3134 
 3135   // Volatile Store Long.  Must be atomic, so move it into
 3136   // the FP TOS and then do a 64-bit FIST.  Has to probe the
 3137   // target address before the store (for null-ptr checks)
 3138   // so the memory operand is used twice in the encoding.
 3139   enc_class enc_storeL_volatile( memory mem, stackSlotL src ) %{
 3140     store_to_stackslot( cbuf, 0x0DF, 0x05, $src$$disp );
 3141     cbuf.set_insts_mark();            // Mark start of FIST in case $mem has an oop
 3142     emit_opcode(cbuf,0xDF);
 3143     int rm_byte_opcode = 0x07;
 3144     int base     = $mem$$base;
 3145     int index    = $mem$$index;
 3146     int scale    = $mem$$scale;
 3147     int displace = $mem$$disp;
 3148     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc(); // disp-as-oop when working with static globals
 3149     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, disp_reloc);
 3150   %}
 3151 
 3152   // Safepoint Poll.  This polls the safepoint page, and causes an
 3153   // exception if it is not readable. Unfortunately, it kills the condition code
 3154   // in the process
 3155   // We current use TESTL [spp],EDI
 3156   // A better choice might be TESTB [spp + pagesize() - CacheLineSize()],0
 3157 
 3158   enc_class Safepoint_Poll() %{
 3159     cbuf.relocate(cbuf.insts_mark(), relocInfo::poll_type, 0);
 3160     emit_opcode(cbuf,0x85);
 3161     emit_rm (cbuf, 0x0, 0x7, 0x5);
 3162     emit_d32(cbuf, (intptr_t)os::get_polling_page());
 3163   %}
 3164 %}
 3165 
 3166 
 3167 //----------FRAME--------------------------------------------------------------
 3168 // Definition of frame structure and management information.
 3169 //
 3170 //  S T A C K   L A Y O U T    Allocators stack-slot number
 3171 //                             |   (to get allocators register number
 3172 //  G  Owned by    |        |  v    add OptoReg::stack0())
 3173 //  r   CALLER     |        |
 3174 //  o     |        +--------+      pad to even-align allocators stack-slot
 3175 //  w     V        |  pad0  |        numbers; owned by CALLER
 3176 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
 3177 //  h     ^        |   in   |  5
 3178 //        |        |  args  |  4   Holes in incoming args owned by SELF
 3179 //  |     |        |        |  3
 3180 //  |     |        +--------+
 3181 //  V     |        | old out|      Empty on Intel, window on Sparc
 3182 //        |    old |preserve|      Must be even aligned.
 3183 //        |     SP-+--------+----&gt; Matcher::_old_SP, even aligned
 3184 //        |        |   in   |  3   area for Intel ret address
 3185 //     Owned by    |preserve|      Empty on Sparc.
 3186 //       SELF      +--------+
 3187 //        |        |  pad2  |  2   pad to align old SP
 3188 //        |        +--------+  1
 3189 //        |        | locks  |  0
 3190 //        |        +--------+----&gt; OptoReg::stack0(), even aligned
 3191 //        |        |  pad1  | 11   pad to align new SP
 3192 //        |        +--------+
 3193 //        |        |        | 10
 3194 //        |        | spills |  9   spills
 3195 //        V        |        |  8   (pad0 slot for callee)
 3196 //      -----------+--------+----&gt; Matcher::_out_arg_limit, unaligned
 3197 //        ^        |  out   |  7
 3198 //        |        |  args  |  6   Holes in outgoing args owned by CALLEE
 3199 //     Owned by    +--------+
 3200 //      CALLEE     | new out|  6   Empty on Intel, window on Sparc
 3201 //        |    new |preserve|      Must be even-aligned.
 3202 //        |     SP-+--------+----&gt; Matcher::_new_SP, even aligned
 3203 //        |        |        |
 3204 //
 3205 // Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is
 3206 //         known from SELF&#39;s arguments and the Java calling convention.
 3207 //         Region 6-7 is determined per call site.
 3208 // Note 2: If the calling convention leaves holes in the incoming argument
 3209 //         area, those holes are owned by SELF.  Holes in the outgoing area
 3210 //         are owned by the CALLEE.  Holes should not be nessecary in the
 3211 //         incoming area, as the Java calling convention is completely under
 3212 //         the control of the AD file.  Doubles can be sorted and packed to
 3213 //         avoid holes.  Holes in the outgoing arguments may be nessecary for
 3214 //         varargs C calling conventions.
 3215 // Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is
 3216 //         even aligned with pad0 as needed.
 3217 //         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
 3218 //         region 6-11 is even aligned; it may be padded out more so that
 3219 //         the region from SP to FP meets the minimum stack alignment.
 3220 
 3221 frame %{
 3222   // What direction does stack grow in (assumed to be same for C &amp; Java)
 3223   stack_direction(TOWARDS_LOW);
 3224 
 3225   // These three registers define part of the calling convention
 3226   // between compiled code and the interpreter.
 3227   inline_cache_reg(EAX);                // Inline Cache Register
 3228   interpreter_method_oop_reg(EBX);      // Method Oop Register when calling interpreter
 3229 
 3230   // Optional: name the operand used by cisc-spilling to access [stack_pointer + offset]
 3231   cisc_spilling_operand_name(indOffset32);
 3232 
 3233   // Number of stack slots consumed by locking an object
 3234   sync_stack_slots(1);
 3235 
 3236   // Compiled code&#39;s Frame Pointer
 3237   frame_pointer(ESP);
 3238   // Interpreter stores its frame pointer in a register which is
 3239   // stored to the stack by I2CAdaptors.
 3240   // I2CAdaptors convert from interpreted java to compiled java.
 3241   interpreter_frame_pointer(EBP);
 3242 
 3243   // Stack alignment requirement
 3244   // Alignment size in bytes (128-bit -&gt; 16 bytes)
 3245   stack_alignment(StackAlignmentInBytes);
 3246 
 3247   // Number of stack slots between incoming argument block and the start of
 3248   // a new frame.  The PROLOG must add this many slots to the stack.  The
 3249   // EPILOG must remove this many slots.  Intel needs one slot for
 3250   // return address and one for rbp, (must save rbp)
 3251   in_preserve_stack_slots(2+VerifyStackAtCalls);
 3252 
 3253   // Number of outgoing stack slots killed above the out_preserve_stack_slots
 3254   // for calls to C.  Supports the var-args backing area for register parms.
 3255   varargs_C_out_slots_killed(0);
 3256 
 3257   // The after-PROLOG location of the return address.  Location of
 3258   // return address specifies a type (REG or STACK) and a number
 3259   // representing the register number (i.e. - use a register name) or
 3260   // stack slot.
 3261   // Ret Addr is on stack in slot 0 if no locks or verification or alignment.
 3262   // Otherwise, it is above the locks and verification slot and alignment word
 3263   return_addr(STACK - 1 +
 3264               align_up((Compile::current()-&gt;in_preserve_stack_slots() +
 3265                         Compile::current()-&gt;fixed_slots()),
 3266                        stack_alignment_in_slots()));
 3267 
 3268   // Body of function which returns an integer array locating
 3269   // arguments either in registers or in stack slots.  Passed an array
 3270   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count.  Stack-slot
 3271   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 3272   // arguments for a CALLEE.  Incoming stack arguments are
 3273   // automatically biased by the preserve_stack_slots field above.
 3274   calling_convention %{
 3275     // No difference between ingoing/outgoing just pass false
 3276     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
 3277   %}
 3278 
 3279 
 3280   // Body of function which returns an integer array locating
 3281   // arguments either in registers or in stack slots.  Passed an array
 3282   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count.  Stack-slot
 3283   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 3284   // arguments for a CALLEE.  Incoming stack arguments are
 3285   // automatically biased by the preserve_stack_slots field above.
 3286   c_calling_convention %{
 3287     // This is obviously always outgoing
 3288     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 3289   %}
 3290 
 3291   // Location of C &amp; interpreter return values
 3292   c_return_value %{
 3293     assert( ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot; );
 3294     static int lo[Op_RegL+1] = { 0, 0, OptoReg::Bad, EAX_num,      EAX_num,      FPR1L_num,    FPR1L_num, EAX_num };
 3295     static int hi[Op_RegL+1] = { 0, 0, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, FPR1H_num, EDX_num };
 3296 
 3297     // in SSE2+ mode we want to keep the FPU stack clean so pretend
 3298     // that C functions return float and double results in XMM0.
 3299     if( ideal_reg == Op_RegD &amp;&amp; UseSSE&gt;=2 )
 3300       return OptoRegPair(XMM0b_num,XMM0_num);
 3301     if( ideal_reg == Op_RegF &amp;&amp; UseSSE&gt;=2 )
 3302       return OptoRegPair(OptoReg::Bad,XMM0_num);
 3303 
 3304     return OptoRegPair(hi[ideal_reg],lo[ideal_reg]);
 3305   %}
 3306 
 3307   // Location of return values
 3308   return_value %{
 3309     assert( ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot; );
 3310     static int lo[Op_RegL+1] = { 0, 0, OptoReg::Bad, EAX_num,      EAX_num,      FPR1L_num,    FPR1L_num, EAX_num };
 3311     static int hi[Op_RegL+1] = { 0, 0, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, OptoReg::Bad, FPR1H_num, EDX_num };
 3312     if( ideal_reg == Op_RegD &amp;&amp; UseSSE&gt;=2 )
 3313       return OptoRegPair(XMM0b_num,XMM0_num);
 3314     if( ideal_reg == Op_RegF &amp;&amp; UseSSE&gt;=1 )
 3315       return OptoRegPair(OptoReg::Bad,XMM0_num);
 3316     return OptoRegPair(hi[ideal_reg],lo[ideal_reg]);
 3317   %}
 3318 
 3319 %}
 3320 
 3321 //----------ATTRIBUTES---------------------------------------------------------
 3322 //----------Operand Attributes-------------------------------------------------
 3323 op_attrib op_cost(0);        // Required cost attribute
 3324 
 3325 //----------Instruction Attributes---------------------------------------------
 3326 ins_attrib ins_cost(100);       // Required cost attribute
 3327 ins_attrib ins_size(8);         // Required size attribute (in bits)
 3328 ins_attrib ins_short_branch(0); // Required flag: is this instruction a
 3329                                 // non-matching short branch variant of some
 3330                                                             // long branch?
 3331 ins_attrib ins_alignment(1);    // Required alignment attribute (must be a power of 2)
 3332                                 // specifies the alignment that some part of the instruction (not
 3333                                 // necessarily the start) requires.  If &gt; 1, a compute_padding()
 3334                                 // function must be provided for the instruction
 3335 
 3336 //----------OPERANDS-----------------------------------------------------------
 3337 // Operand definitions must precede instruction definitions for correct parsing
 3338 // in the ADLC because operands constitute user defined types which are used in
 3339 // instruction definitions.
 3340 
 3341 //----------Simple Operands----------------------------------------------------
 3342 // Immediate Operands
 3343 // Integer Immediate
 3344 operand immI() %{
 3345   match(ConI);
 3346 
 3347   op_cost(10);
 3348   format %{ %}
 3349   interface(CONST_INTER);
 3350 %}
 3351 
 3352 // Constant for test vs zero
 3353 operand immI0() %{
 3354   predicate(n-&gt;get_int() == 0);
 3355   match(ConI);
 3356 
 3357   op_cost(0);
 3358   format %{ %}
 3359   interface(CONST_INTER);
 3360 %}
 3361 
 3362 // Constant for increment
 3363 operand immI1() %{
 3364   predicate(n-&gt;get_int() == 1);
 3365   match(ConI);
 3366 
 3367   op_cost(0);
 3368   format %{ %}
 3369   interface(CONST_INTER);
 3370 %}
 3371 
 3372 // Constant for decrement
 3373 operand immI_M1() %{
 3374   predicate(n-&gt;get_int() == -1);
 3375   match(ConI);
 3376 
 3377   op_cost(0);
 3378   format %{ %}
 3379   interface(CONST_INTER);
 3380 %}
 3381 
 3382 // Valid scale values for addressing modes
 3383 operand immI2() %{
 3384   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; (n-&gt;get_int() &lt;= 3));
 3385   match(ConI);
 3386 
 3387   format %{ %}
 3388   interface(CONST_INTER);
 3389 %}
 3390 
 3391 operand immI8() %{
 3392   predicate((-128 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 127));
 3393   match(ConI);
 3394 
 3395   op_cost(5);
 3396   format %{ %}
 3397   interface(CONST_INTER);
 3398 %}
 3399 
 3400 operand immI16() %{
 3401   predicate((-32768 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 32767));
 3402   match(ConI);
 3403 
 3404   op_cost(10);
 3405   format %{ %}
 3406   interface(CONST_INTER);
 3407 %}
 3408 
 3409 // Int Immediate non-negative
 3410 operand immU31()
 3411 %{
 3412   predicate(n-&gt;get_int() &gt;= 0);
 3413   match(ConI);
 3414 
 3415   op_cost(0);
 3416   format %{ %}
 3417   interface(CONST_INTER);
 3418 %}
 3419 
 3420 // Constant for long shifts
 3421 operand immI_32() %{
 3422   predicate( n-&gt;get_int() == 32 );
 3423   match(ConI);
 3424 
 3425   op_cost(0);
 3426   format %{ %}
 3427   interface(CONST_INTER);
 3428 %}
 3429 
 3430 operand immI_1_31() %{
 3431   predicate( n-&gt;get_int() &gt;= 1 &amp;&amp; n-&gt;get_int() &lt;= 31 );
 3432   match(ConI);
 3433 
 3434   op_cost(0);
 3435   format %{ %}
 3436   interface(CONST_INTER);
 3437 %}
 3438 
 3439 operand immI_32_63() %{
 3440   predicate( n-&gt;get_int() &gt;= 32 &amp;&amp; n-&gt;get_int() &lt;= 63 );
 3441   match(ConI);
 3442   op_cost(0);
 3443 
 3444   format %{ %}
 3445   interface(CONST_INTER);
 3446 %}
 3447 
 3448 operand immI_1() %{
 3449   predicate( n-&gt;get_int() == 1 );
 3450   match(ConI);
 3451 
 3452   op_cost(0);
 3453   format %{ %}
 3454   interface(CONST_INTER);
 3455 %}
 3456 
 3457 operand immI_2() %{
 3458   predicate( n-&gt;get_int() == 2 );
 3459   match(ConI);
 3460 
 3461   op_cost(0);
 3462   format %{ %}
 3463   interface(CONST_INTER);
 3464 %}
 3465 
 3466 operand immI_3() %{
 3467   predicate( n-&gt;get_int() == 3 );
 3468   match(ConI);
 3469 
 3470   op_cost(0);
 3471   format %{ %}
 3472   interface(CONST_INTER);
 3473 %}
 3474 
 3475 // Pointer Immediate
 3476 operand immP() %{
 3477   match(ConP);
 3478 
 3479   op_cost(10);
 3480   format %{ %}
 3481   interface(CONST_INTER);
 3482 %}
 3483 
 3484 // NULL Pointer Immediate
 3485 operand immP0() %{
 3486   predicate( n-&gt;get_ptr() == 0 );
 3487   match(ConP);
 3488   op_cost(0);
 3489 
 3490   format %{ %}
 3491   interface(CONST_INTER);
 3492 %}
 3493 
 3494 // Long Immediate
 3495 operand immL() %{
 3496   match(ConL);
 3497 
 3498   op_cost(20);
 3499   format %{ %}
 3500   interface(CONST_INTER);
 3501 %}
 3502 
 3503 // Long Immediate zero
 3504 operand immL0() %{
 3505   predicate( n-&gt;get_long() == 0L );
 3506   match(ConL);
 3507   op_cost(0);
 3508 
 3509   format %{ %}
 3510   interface(CONST_INTER);
 3511 %}
 3512 
 3513 // Long Immediate zero
 3514 operand immL_M1() %{
 3515   predicate( n-&gt;get_long() == -1L );
 3516   match(ConL);
 3517   op_cost(0);
 3518 
 3519   format %{ %}
 3520   interface(CONST_INTER);
 3521 %}
 3522 
 3523 // Long immediate from 0 to 127.
 3524 // Used for a shorter form of long mul by 10.
 3525 operand immL_127() %{
 3526   predicate((0 &lt;= n-&gt;get_long()) &amp;&amp; (n-&gt;get_long() &lt;= 127));
 3527   match(ConL);
 3528   op_cost(0);
 3529 
 3530   format %{ %}
 3531   interface(CONST_INTER);
 3532 %}
 3533 
 3534 // Long Immediate: low 32-bit mask
 3535 operand immL_32bits() %{
 3536   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 3537   match(ConL);
 3538   op_cost(0);
 3539 
 3540   format %{ %}
 3541   interface(CONST_INTER);
 3542 %}
 3543 
 3544 // Long Immediate: low 32-bit mask
 3545 operand immL32() %{
 3546   predicate(n-&gt;get_long() == (int)(n-&gt;get_long()));
 3547   match(ConL);
 3548   op_cost(20);
 3549 
 3550   format %{ %}
 3551   interface(CONST_INTER);
 3552 %}
 3553 
 3554 //Double Immediate zero
 3555 operand immDPR0() %{
 3556   // Do additional (and counter-intuitive) test against NaN to work around VC++
 3557   // bug that generates code such that NaNs compare equal to 0.0
 3558   predicate( UseSSE&lt;=1 &amp;&amp; n-&gt;getd() == 0.0 &amp;&amp; !g_isnan(n-&gt;getd()) );
 3559   match(ConD);
 3560 
 3561   op_cost(5);
 3562   format %{ %}
 3563   interface(CONST_INTER);
 3564 %}
 3565 
 3566 // Double Immediate one
 3567 operand immDPR1() %{
 3568   predicate( UseSSE&lt;=1 &amp;&amp; n-&gt;getd() == 1.0 );
 3569   match(ConD);
 3570 
 3571   op_cost(5);
 3572   format %{ %}
 3573   interface(CONST_INTER);
 3574 %}
 3575 
 3576 // Double Immediate
 3577 operand immDPR() %{
 3578   predicate(UseSSE&lt;=1);
 3579   match(ConD);
 3580 
 3581   op_cost(5);
 3582   format %{ %}
 3583   interface(CONST_INTER);
 3584 %}
 3585 
 3586 operand immD() %{
 3587   predicate(UseSSE&gt;=2);
 3588   match(ConD);
 3589 
 3590   op_cost(5);
 3591   format %{ %}
 3592   interface(CONST_INTER);
 3593 %}
 3594 
 3595 // Double Immediate zero
 3596 operand immD0() %{
 3597   // Do additional (and counter-intuitive) test against NaN to work around VC++
 3598   // bug that generates code such that NaNs compare equal to 0.0 AND do not
 3599   // compare equal to -0.0.
 3600   predicate( UseSSE&gt;=2 &amp;&amp; jlong_cast(n-&gt;getd()) == 0 );
 3601   match(ConD);
 3602 
 3603   format %{ %}
 3604   interface(CONST_INTER);
 3605 %}
 3606 
 3607 // Float Immediate zero
 3608 operand immFPR0() %{
 3609   predicate(UseSSE == 0 &amp;&amp; n-&gt;getf() == 0.0F);
 3610   match(ConF);
 3611 
 3612   op_cost(5);
 3613   format %{ %}
 3614   interface(CONST_INTER);
 3615 %}
 3616 
 3617 // Float Immediate one
 3618 operand immFPR1() %{
 3619   predicate(UseSSE == 0 &amp;&amp; n-&gt;getf() == 1.0F);
 3620   match(ConF);
 3621 
 3622   op_cost(5);
 3623   format %{ %}
 3624   interface(CONST_INTER);
 3625 %}
 3626 
 3627 // Float Immediate
 3628 operand immFPR() %{
 3629   predicate( UseSSE == 0 );
 3630   match(ConF);
 3631 
 3632   op_cost(5);
 3633   format %{ %}
 3634   interface(CONST_INTER);
 3635 %}
 3636 
 3637 // Float Immediate
 3638 operand immF() %{
 3639   predicate(UseSSE &gt;= 1);
 3640   match(ConF);
 3641 
 3642   op_cost(5);
 3643   format %{ %}
 3644   interface(CONST_INTER);
 3645 %}
 3646 
 3647 // Float Immediate zero.  Zero and not -0.0
 3648 operand immF0() %{
 3649   predicate( UseSSE &gt;= 1 &amp;&amp; jint_cast(n-&gt;getf()) == 0 );
 3650   match(ConF);
 3651 
 3652   op_cost(5);
 3653   format %{ %}
 3654   interface(CONST_INTER);
 3655 %}
 3656 
 3657 // Immediates for special shifts (sign extend)
 3658 
 3659 // Constants for increment
 3660 operand immI_16() %{
 3661   predicate( n-&gt;get_int() == 16 );
 3662   match(ConI);
 3663 
 3664   format %{ %}
 3665   interface(CONST_INTER);
 3666 %}
 3667 
 3668 operand immI_24() %{
 3669   predicate( n-&gt;get_int() == 24 );
 3670   match(ConI);
 3671 
 3672   format %{ %}
 3673   interface(CONST_INTER);
 3674 %}
 3675 
 3676 // Constant for byte-wide masking
 3677 operand immI_255() %{
 3678   predicate( n-&gt;get_int() == 255 );
 3679   match(ConI);
 3680 
 3681   format %{ %}
 3682   interface(CONST_INTER);
 3683 %}
 3684 
 3685 // Constant for short-wide masking
 3686 operand immI_65535() %{
 3687   predicate(n-&gt;get_int() == 65535);
 3688   match(ConI);
 3689 
 3690   format %{ %}
 3691   interface(CONST_INTER);
 3692 %}
 3693 
 3694 // Register Operands
 3695 // Integer Register
 3696 operand rRegI() %{
 3697   constraint(ALLOC_IN_RC(int_reg));
 3698   match(RegI);
 3699   match(xRegI);
 3700   match(eAXRegI);
 3701   match(eBXRegI);
 3702   match(eCXRegI);
 3703   match(eDXRegI);
 3704   match(eDIRegI);
 3705   match(eSIRegI);
 3706 
 3707   format %{ %}
 3708   interface(REG_INTER);
 3709 %}
 3710 
 3711 // Subset of Integer Register
 3712 operand xRegI(rRegI reg) %{
 3713   constraint(ALLOC_IN_RC(int_x_reg));
 3714   match(reg);
 3715   match(eAXRegI);
 3716   match(eBXRegI);
 3717   match(eCXRegI);
 3718   match(eDXRegI);
 3719 
 3720   format %{ %}
 3721   interface(REG_INTER);
 3722 %}
 3723 
 3724 // Special Registers
 3725 operand eAXRegI(xRegI reg) %{
 3726   constraint(ALLOC_IN_RC(eax_reg));
 3727   match(reg);
 3728   match(rRegI);
 3729 
 3730   format %{ &quot;EAX&quot; %}
 3731   interface(REG_INTER);
 3732 %}
 3733 
 3734 // Special Registers
 3735 operand eBXRegI(xRegI reg) %{
 3736   constraint(ALLOC_IN_RC(ebx_reg));
 3737   match(reg);
 3738   match(rRegI);
 3739 
 3740   format %{ &quot;EBX&quot; %}
 3741   interface(REG_INTER);
 3742 %}
 3743 
 3744 operand eCXRegI(xRegI reg) %{
 3745   constraint(ALLOC_IN_RC(ecx_reg));
 3746   match(reg);
 3747   match(rRegI);
 3748 
 3749   format %{ &quot;ECX&quot; %}
 3750   interface(REG_INTER);
 3751 %}
 3752 
 3753 operand eDXRegI(xRegI reg) %{
 3754   constraint(ALLOC_IN_RC(edx_reg));
 3755   match(reg);
 3756   match(rRegI);
 3757 
 3758   format %{ &quot;EDX&quot; %}
 3759   interface(REG_INTER);
 3760 %}
 3761 
 3762 operand eDIRegI(xRegI reg) %{
 3763   constraint(ALLOC_IN_RC(edi_reg));
 3764   match(reg);
 3765   match(rRegI);
 3766 
 3767   format %{ &quot;EDI&quot; %}
 3768   interface(REG_INTER);
 3769 %}
 3770 
 3771 operand naxRegI() %{
 3772   constraint(ALLOC_IN_RC(nax_reg));
 3773   match(RegI);
 3774   match(eCXRegI);
 3775   match(eDXRegI);
 3776   match(eSIRegI);
 3777   match(eDIRegI);
 3778 
 3779   format %{ %}
 3780   interface(REG_INTER);
 3781 %}
 3782 
 3783 operand nadxRegI() %{
 3784   constraint(ALLOC_IN_RC(nadx_reg));
 3785   match(RegI);
 3786   match(eBXRegI);
 3787   match(eCXRegI);
 3788   match(eSIRegI);
 3789   match(eDIRegI);
 3790 
 3791   format %{ %}
 3792   interface(REG_INTER);
 3793 %}
 3794 
 3795 operand ncxRegI() %{
 3796   constraint(ALLOC_IN_RC(ncx_reg));
 3797   match(RegI);
 3798   match(eAXRegI);
 3799   match(eDXRegI);
 3800   match(eSIRegI);
 3801   match(eDIRegI);
 3802 
 3803   format %{ %}
 3804   interface(REG_INTER);
 3805 %}
 3806 
 3807 // // This operand was used by cmpFastUnlock, but conflicted with &#39;object&#39; reg
 3808 // //
 3809 operand eSIRegI(xRegI reg) %{
 3810    constraint(ALLOC_IN_RC(esi_reg));
 3811    match(reg);
 3812    match(rRegI);
 3813 
 3814    format %{ &quot;ESI&quot; %}
 3815    interface(REG_INTER);
 3816 %}
 3817 
 3818 // Pointer Register
 3819 operand anyRegP() %{
 3820   constraint(ALLOC_IN_RC(any_reg));
 3821   match(RegP);
 3822   match(eAXRegP);
 3823   match(eBXRegP);
 3824   match(eCXRegP);
 3825   match(eDIRegP);
 3826   match(eRegP);
 3827 
 3828   format %{ %}
 3829   interface(REG_INTER);
 3830 %}
 3831 
 3832 operand eRegP() %{
 3833   constraint(ALLOC_IN_RC(int_reg));
 3834   match(RegP);
 3835   match(eAXRegP);
 3836   match(eBXRegP);
 3837   match(eCXRegP);
 3838   match(eDIRegP);
 3839 
 3840   format %{ %}
 3841   interface(REG_INTER);
 3842 %}
 3843 
 3844 // On windows95, EBP is not safe to use for implicit null tests.
 3845 operand eRegP_no_EBP() %{
 3846   constraint(ALLOC_IN_RC(int_reg_no_ebp));
 3847   match(RegP);
 3848   match(eAXRegP);
 3849   match(eBXRegP);
 3850   match(eCXRegP);
 3851   match(eDIRegP);
 3852 
 3853   op_cost(100);
 3854   format %{ %}
 3855   interface(REG_INTER);
 3856 %}
 3857 
 3858 operand naxRegP() %{
 3859   constraint(ALLOC_IN_RC(nax_reg));
 3860   match(RegP);
 3861   match(eBXRegP);
 3862   match(eDXRegP);
 3863   match(eCXRegP);
 3864   match(eSIRegP);
 3865   match(eDIRegP);
 3866 
 3867   format %{ %}
 3868   interface(REG_INTER);
 3869 %}
 3870 
 3871 operand nabxRegP() %{
 3872   constraint(ALLOC_IN_RC(nabx_reg));
 3873   match(RegP);
 3874   match(eCXRegP);
 3875   match(eDXRegP);
 3876   match(eSIRegP);
 3877   match(eDIRegP);
 3878 
 3879   format %{ %}
 3880   interface(REG_INTER);
 3881 %}
 3882 
 3883 operand pRegP() %{
 3884   constraint(ALLOC_IN_RC(p_reg));
 3885   match(RegP);
 3886   match(eBXRegP);
 3887   match(eDXRegP);
 3888   match(eSIRegP);
 3889   match(eDIRegP);
 3890 
 3891   format %{ %}
 3892   interface(REG_INTER);
 3893 %}
 3894 
 3895 // Special Registers
 3896 // Return a pointer value
 3897 operand eAXRegP(eRegP reg) %{
 3898   constraint(ALLOC_IN_RC(eax_reg));
 3899   match(reg);
 3900   format %{ &quot;EAX&quot; %}
 3901   interface(REG_INTER);
 3902 %}
 3903 
 3904 // Used in AtomicAdd
 3905 operand eBXRegP(eRegP reg) %{
 3906   constraint(ALLOC_IN_RC(ebx_reg));
 3907   match(reg);
 3908   format %{ &quot;EBX&quot; %}
 3909   interface(REG_INTER);
 3910 %}
 3911 
 3912 // Tail-call (interprocedural jump) to interpreter
 3913 operand eCXRegP(eRegP reg) %{
 3914   constraint(ALLOC_IN_RC(ecx_reg));
 3915   match(reg);
 3916   format %{ &quot;ECX&quot; %}
 3917   interface(REG_INTER);
 3918 %}
 3919 
 3920 operand eDXRegP(eRegP reg) %{
 3921   constraint(ALLOC_IN_RC(edx_reg));
 3922   match(reg);
 3923   format %{ &quot;EDX&quot; %}
 3924   interface(REG_INTER);
 3925 %}
 3926 
 3927 operand eSIRegP(eRegP reg) %{
 3928   constraint(ALLOC_IN_RC(esi_reg));
 3929   match(reg);
 3930   format %{ &quot;ESI&quot; %}
 3931   interface(REG_INTER);
 3932 %}
 3933 
 3934 // Used in rep stosw
 3935 operand eDIRegP(eRegP reg) %{
 3936   constraint(ALLOC_IN_RC(edi_reg));
 3937   match(reg);
 3938   format %{ &quot;EDI&quot; %}
 3939   interface(REG_INTER);
 3940 %}
 3941 
 3942 operand eRegL() %{
 3943   constraint(ALLOC_IN_RC(long_reg));
 3944   match(RegL);
 3945   match(eADXRegL);
 3946 
 3947   format %{ %}
 3948   interface(REG_INTER);
 3949 %}
 3950 
 3951 operand eADXRegL( eRegL reg ) %{
 3952   constraint(ALLOC_IN_RC(eadx_reg));
 3953   match(reg);
 3954 
 3955   format %{ &quot;EDX:EAX&quot; %}
 3956   interface(REG_INTER);
 3957 %}
 3958 
 3959 operand eBCXRegL( eRegL reg ) %{
 3960   constraint(ALLOC_IN_RC(ebcx_reg));
 3961   match(reg);
 3962 
 3963   format %{ &quot;EBX:ECX&quot; %}
 3964   interface(REG_INTER);
 3965 %}
 3966 
 3967 // Special case for integer high multiply
 3968 operand eADXRegL_low_only() %{
 3969   constraint(ALLOC_IN_RC(eadx_reg));
 3970   match(RegL);
 3971 
 3972   format %{ &quot;EAX&quot; %}
 3973   interface(REG_INTER);
 3974 %}
 3975 
 3976 // Flags register, used as output of compare instructions
 3977 operand eFlagsReg() %{
 3978   constraint(ALLOC_IN_RC(int_flags));
 3979   match(RegFlags);
 3980 
 3981   format %{ &quot;EFLAGS&quot; %}
 3982   interface(REG_INTER);
 3983 %}
 3984 
 3985 // Flags register, used as output of FLOATING POINT compare instructions
 3986 operand eFlagsRegU() %{
 3987   constraint(ALLOC_IN_RC(int_flags));
 3988   match(RegFlags);
 3989 
 3990   format %{ &quot;EFLAGS_U&quot; %}
 3991   interface(REG_INTER);
 3992 %}
 3993 
 3994 operand eFlagsRegUCF() %{
 3995   constraint(ALLOC_IN_RC(int_flags));
 3996   match(RegFlags);
 3997   predicate(false);
 3998 
 3999   format %{ &quot;EFLAGS_U_CF&quot; %}
 4000   interface(REG_INTER);
 4001 %}
 4002 
 4003 // Condition Code Register used by long compare
 4004 operand flagsReg_long_LTGE() %{
 4005   constraint(ALLOC_IN_RC(int_flags));
 4006   match(RegFlags);
 4007   format %{ &quot;FLAGS_LTGE&quot; %}
 4008   interface(REG_INTER);
 4009 %}
 4010 operand flagsReg_long_EQNE() %{
 4011   constraint(ALLOC_IN_RC(int_flags));
 4012   match(RegFlags);
 4013   format %{ &quot;FLAGS_EQNE&quot; %}
 4014   interface(REG_INTER);
 4015 %}
 4016 operand flagsReg_long_LEGT() %{
 4017   constraint(ALLOC_IN_RC(int_flags));
 4018   match(RegFlags);
 4019   format %{ &quot;FLAGS_LEGT&quot; %}
 4020   interface(REG_INTER);
 4021 %}
 4022 
 4023 // Condition Code Register used by unsigned long compare
 4024 operand flagsReg_ulong_LTGE() %{
 4025   constraint(ALLOC_IN_RC(int_flags));
 4026   match(RegFlags);
 4027   format %{ &quot;FLAGS_U_LTGE&quot; %}
 4028   interface(REG_INTER);
 4029 %}
 4030 operand flagsReg_ulong_EQNE() %{
 4031   constraint(ALLOC_IN_RC(int_flags));
 4032   match(RegFlags);
 4033   format %{ &quot;FLAGS_U_EQNE&quot; %}
 4034   interface(REG_INTER);
 4035 %}
 4036 operand flagsReg_ulong_LEGT() %{
 4037   constraint(ALLOC_IN_RC(int_flags));
 4038   match(RegFlags);
 4039   format %{ &quot;FLAGS_U_LEGT&quot; %}
 4040   interface(REG_INTER);
 4041 %}
 4042 
 4043 // Float register operands
 4044 operand regDPR() %{
 4045   predicate( UseSSE &lt; 2 );
 4046   constraint(ALLOC_IN_RC(fp_dbl_reg));
 4047   match(RegD);
 4048   match(regDPR1);
 4049   match(regDPR2);
 4050   format %{ %}
 4051   interface(REG_INTER);
 4052 %}
 4053 
 4054 operand regDPR1(regDPR reg) %{
 4055   predicate( UseSSE &lt; 2 );
 4056   constraint(ALLOC_IN_RC(fp_dbl_reg0));
 4057   match(reg);
 4058   format %{ &quot;FPR1&quot; %}
 4059   interface(REG_INTER);
 4060 %}
 4061 
 4062 operand regDPR2(regDPR reg) %{
 4063   predicate( UseSSE &lt; 2 );
 4064   constraint(ALLOC_IN_RC(fp_dbl_reg1));
 4065   match(reg);
 4066   format %{ &quot;FPR2&quot; %}
 4067   interface(REG_INTER);
 4068 %}
 4069 
 4070 operand regnotDPR1(regDPR reg) %{
 4071   predicate( UseSSE &lt; 2 );
 4072   constraint(ALLOC_IN_RC(fp_dbl_notreg0));
 4073   match(reg);
 4074   format %{ %}
 4075   interface(REG_INTER);
 4076 %}
 4077 
 4078 // Float register operands
 4079 operand regFPR() %{
 4080   predicate( UseSSE &lt; 2 );
 4081   constraint(ALLOC_IN_RC(fp_flt_reg));
 4082   match(RegF);
 4083   match(regFPR1);
 4084   format %{ %}
 4085   interface(REG_INTER);
 4086 %}
 4087 
 4088 // Float register operands
 4089 operand regFPR1(regFPR reg) %{
 4090   predicate( UseSSE &lt; 2 );
 4091   constraint(ALLOC_IN_RC(fp_flt_reg0));
 4092   match(reg);
 4093   format %{ &quot;FPR1&quot; %}
 4094   interface(REG_INTER);
 4095 %}
 4096 
 4097 // XMM Float register operands
 4098 operand regF() %{
 4099   predicate( UseSSE&gt;=1 );
 4100   constraint(ALLOC_IN_RC(float_reg_legacy));
 4101   match(RegF);
 4102   format %{ %}
 4103   interface(REG_INTER);
 4104 %}
 4105 
 4106 // Float register operands
 4107 operand vlRegF() %{
 4108    constraint(ALLOC_IN_RC(float_reg_vl));
 4109    match(RegF);
 4110 
 4111    format %{ %}
 4112    interface(REG_INTER);
 4113 %}
 4114 
 4115 // XMM Double register operands
 4116 operand regD() %{
 4117   predicate( UseSSE&gt;=2 );
 4118   constraint(ALLOC_IN_RC(double_reg_legacy));
 4119   match(RegD);
 4120   format %{ %}
 4121   interface(REG_INTER);
 4122 %}
 4123 
 4124 // Double register operands
 4125 operand vlRegD() %{
 4126    constraint(ALLOC_IN_RC(double_reg_vl));
 4127    match(RegD);
 4128 
 4129    format %{ %}
 4130    interface(REG_INTER);
 4131 %}
 4132 
 4133 //----------Memory Operands----------------------------------------------------
 4134 // Direct Memory Operand
 4135 operand direct(immP addr) %{
 4136   match(addr);
 4137 
 4138   format %{ &quot;[$addr]&quot; %}
 4139   interface(MEMORY_INTER) %{
 4140     base(0xFFFFFFFF);
 4141     index(0x4);
 4142     scale(0x0);
 4143     disp($addr);
 4144   %}
 4145 %}
 4146 
 4147 // Indirect Memory Operand
 4148 operand indirect(eRegP reg) %{
 4149   constraint(ALLOC_IN_RC(int_reg));
 4150   match(reg);
 4151 
 4152   format %{ &quot;[$reg]&quot; %}
 4153   interface(MEMORY_INTER) %{
 4154     base($reg);
 4155     index(0x4);
 4156     scale(0x0);
 4157     disp(0x0);
 4158   %}
 4159 %}
 4160 
 4161 // Indirect Memory Plus Short Offset Operand
 4162 operand indOffset8(eRegP reg, immI8 off) %{
 4163   match(AddP reg off);
 4164 
 4165   format %{ &quot;[$reg + $off]&quot; %}
 4166   interface(MEMORY_INTER) %{
 4167     base($reg);
 4168     index(0x4);
 4169     scale(0x0);
 4170     disp($off);
 4171   %}
 4172 %}
 4173 
 4174 // Indirect Memory Plus Long Offset Operand
 4175 operand indOffset32(eRegP reg, immI off) %{
 4176   match(AddP reg off);
 4177 
 4178   format %{ &quot;[$reg + $off]&quot; %}
 4179   interface(MEMORY_INTER) %{
 4180     base($reg);
 4181     index(0x4);
 4182     scale(0x0);
 4183     disp($off);
 4184   %}
 4185 %}
 4186 
 4187 // Indirect Memory Plus Long Offset Operand
 4188 operand indOffset32X(rRegI reg, immP off) %{
 4189   match(AddP off reg);
 4190 
 4191   format %{ &quot;[$reg + $off]&quot; %}
 4192   interface(MEMORY_INTER) %{
 4193     base($reg);
 4194     index(0x4);
 4195     scale(0x0);
 4196     disp($off);
 4197   %}
 4198 %}
 4199 
 4200 // Indirect Memory Plus Index Register Plus Offset Operand
 4201 operand indIndexOffset(eRegP reg, rRegI ireg, immI off) %{
 4202   match(AddP (AddP reg ireg) off);
 4203 
 4204   op_cost(10);
 4205   format %{&quot;[$reg + $off + $ireg]&quot; %}
 4206   interface(MEMORY_INTER) %{
 4207     base($reg);
 4208     index($ireg);
 4209     scale(0x0);
 4210     disp($off);
 4211   %}
 4212 %}
 4213 
 4214 // Indirect Memory Plus Index Register Plus Offset Operand
 4215 operand indIndex(eRegP reg, rRegI ireg) %{
 4216   match(AddP reg ireg);
 4217 
 4218   op_cost(10);
 4219   format %{&quot;[$reg + $ireg]&quot; %}
 4220   interface(MEMORY_INTER) %{
 4221     base($reg);
 4222     index($ireg);
 4223     scale(0x0);
 4224     disp(0x0);
 4225   %}
 4226 %}
 4227 
 4228 // // -------------------------------------------------------------------------
 4229 // // 486 architecture doesn&#39;t support &quot;scale * index + offset&quot; with out a base
 4230 // // -------------------------------------------------------------------------
 4231 // // Scaled Memory Operands
 4232 // // Indirect Memory Times Scale Plus Offset Operand
 4233 // operand indScaleOffset(immP off, rRegI ireg, immI2 scale) %{
 4234 //   match(AddP off (LShiftI ireg scale));
 4235 //
 4236 //   op_cost(10);
 4237 //   format %{&quot;[$off + $ireg &lt;&lt; $scale]&quot; %}
 4238 //   interface(MEMORY_INTER) %{
 4239 //     base(0x4);
 4240 //     index($ireg);
 4241 //     scale($scale);
 4242 //     disp($off);
 4243 //   %}
 4244 // %}
 4245 
 4246 // Indirect Memory Times Scale Plus Index Register
 4247 operand indIndexScale(eRegP reg, rRegI ireg, immI2 scale) %{
 4248   match(AddP reg (LShiftI ireg scale));
 4249 
 4250   op_cost(10);
 4251   format %{&quot;[$reg + $ireg &lt;&lt; $scale]&quot; %}
 4252   interface(MEMORY_INTER) %{
 4253     base($reg);
 4254     index($ireg);
 4255     scale($scale);
 4256     disp(0x0);
 4257   %}
 4258 %}
 4259 
 4260 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 4261 operand indIndexScaleOffset(eRegP reg, immI off, rRegI ireg, immI2 scale) %{
 4262   match(AddP (AddP reg (LShiftI ireg scale)) off);
 4263 
 4264   op_cost(10);
 4265   format %{&quot;[$reg + $off + $ireg &lt;&lt; $scale]&quot; %}
 4266   interface(MEMORY_INTER) %{
 4267     base($reg);
 4268     index($ireg);
 4269     scale($scale);
 4270     disp($off);
 4271   %}
 4272 %}
 4273 
 4274 //----------Load Long Memory Operands------------------------------------------
 4275 // The load-long idiom will use it&#39;s address expression again after loading
 4276 // the first word of the long.  If the load-long destination overlaps with
 4277 // registers used in the addressing expression, the 2nd half will be loaded
 4278 // from a clobbered address.  Fix this by requiring that load-long use
 4279 // address registers that do not overlap with the load-long target.
 4280 
 4281 // load-long support
 4282 operand load_long_RegP() %{
 4283   constraint(ALLOC_IN_RC(esi_reg));
 4284   match(RegP);
 4285   match(eSIRegP);
 4286   op_cost(100);
 4287   format %{  %}
 4288   interface(REG_INTER);
 4289 %}
 4290 
 4291 // Indirect Memory Operand Long
 4292 operand load_long_indirect(load_long_RegP reg) %{
 4293   constraint(ALLOC_IN_RC(esi_reg));
 4294   match(reg);
 4295 
 4296   format %{ &quot;[$reg]&quot; %}
 4297   interface(MEMORY_INTER) %{
 4298     base($reg);
 4299     index(0x4);
 4300     scale(0x0);
 4301     disp(0x0);
 4302   %}
 4303 %}
 4304 
 4305 // Indirect Memory Plus Long Offset Operand
 4306 operand load_long_indOffset32(load_long_RegP reg, immI off) %{
 4307   match(AddP reg off);
 4308 
 4309   format %{ &quot;[$reg + $off]&quot; %}
 4310   interface(MEMORY_INTER) %{
 4311     base($reg);
 4312     index(0x4);
 4313     scale(0x0);
 4314     disp($off);
 4315   %}
 4316 %}
 4317 
 4318 opclass load_long_memory(load_long_indirect, load_long_indOffset32);
 4319 
 4320 
 4321 //----------Special Memory Operands--------------------------------------------
 4322 // Stack Slot Operand - This operand is used for loading and storing temporary
 4323 //                      values on the stack where a match requires a value to
 4324 //                      flow through memory.
 4325 operand stackSlotP(sRegP reg) %{
 4326   constraint(ALLOC_IN_RC(stack_slots));
 4327   // No match rule because this operand is only generated in matching
 4328   format %{ &quot;[$reg]&quot; %}
 4329   interface(MEMORY_INTER) %{
 4330     base(0x4);   // ESP
 4331     index(0x4);  // No Index
 4332     scale(0x0);  // No Scale
 4333     disp($reg);  // Stack Offset
 4334   %}
 4335 %}
 4336 
 4337 operand stackSlotI(sRegI reg) %{
 4338   constraint(ALLOC_IN_RC(stack_slots));
 4339   // No match rule because this operand is only generated in matching
 4340   format %{ &quot;[$reg]&quot; %}
 4341   interface(MEMORY_INTER) %{
 4342     base(0x4);   // ESP
 4343     index(0x4);  // No Index
 4344     scale(0x0);  // No Scale
 4345     disp($reg);  // Stack Offset
 4346   %}
 4347 %}
 4348 
 4349 operand stackSlotF(sRegF reg) %{
 4350   constraint(ALLOC_IN_RC(stack_slots));
 4351   // No match rule because this operand is only generated in matching
 4352   format %{ &quot;[$reg]&quot; %}
 4353   interface(MEMORY_INTER) %{
 4354     base(0x4);   // ESP
 4355     index(0x4);  // No Index
 4356     scale(0x0);  // No Scale
 4357     disp($reg);  // Stack Offset
 4358   %}
 4359 %}
 4360 
 4361 operand stackSlotD(sRegD reg) %{
 4362   constraint(ALLOC_IN_RC(stack_slots));
 4363   // No match rule because this operand is only generated in matching
 4364   format %{ &quot;[$reg]&quot; %}
 4365   interface(MEMORY_INTER) %{
 4366     base(0x4);   // ESP
 4367     index(0x4);  // No Index
 4368     scale(0x0);  // No Scale
 4369     disp($reg);  // Stack Offset
 4370   %}
 4371 %}
 4372 
 4373 operand stackSlotL(sRegL reg) %{
 4374   constraint(ALLOC_IN_RC(stack_slots));
 4375   // No match rule because this operand is only generated in matching
 4376   format %{ &quot;[$reg]&quot; %}
 4377   interface(MEMORY_INTER) %{
 4378     base(0x4);   // ESP
 4379     index(0x4);  // No Index
 4380     scale(0x0);  // No Scale
 4381     disp($reg);  // Stack Offset
 4382   %}
 4383 %}
 4384 
 4385 //----------Memory Operands - Win95 Implicit Null Variants----------------
 4386 // Indirect Memory Operand
 4387 operand indirect_win95_safe(eRegP_no_EBP reg)
 4388 %{
 4389   constraint(ALLOC_IN_RC(int_reg));
 4390   match(reg);
 4391 
 4392   op_cost(100);
 4393   format %{ &quot;[$reg]&quot; %}
 4394   interface(MEMORY_INTER) %{
 4395     base($reg);
 4396     index(0x4);
 4397     scale(0x0);
 4398     disp(0x0);
 4399   %}
 4400 %}
 4401 
 4402 // Indirect Memory Plus Short Offset Operand
 4403 operand indOffset8_win95_safe(eRegP_no_EBP reg, immI8 off)
 4404 %{
 4405   match(AddP reg off);
 4406 
 4407   op_cost(100);
 4408   format %{ &quot;[$reg + $off]&quot; %}
 4409   interface(MEMORY_INTER) %{
 4410     base($reg);
 4411     index(0x4);
 4412     scale(0x0);
 4413     disp($off);
 4414   %}
 4415 %}
 4416 
 4417 // Indirect Memory Plus Long Offset Operand
 4418 operand indOffset32_win95_safe(eRegP_no_EBP reg, immI off)
 4419 %{
 4420   match(AddP reg off);
 4421 
 4422   op_cost(100);
 4423   format %{ &quot;[$reg + $off]&quot; %}
 4424   interface(MEMORY_INTER) %{
 4425     base($reg);
 4426     index(0x4);
 4427     scale(0x0);
 4428     disp($off);
 4429   %}
 4430 %}
 4431 
 4432 // Indirect Memory Plus Index Register Plus Offset Operand
 4433 operand indIndexOffset_win95_safe(eRegP_no_EBP reg, rRegI ireg, immI off)
 4434 %{
 4435   match(AddP (AddP reg ireg) off);
 4436 
 4437   op_cost(100);
 4438   format %{&quot;[$reg + $off + $ireg]&quot; %}
 4439   interface(MEMORY_INTER) %{
 4440     base($reg);
 4441     index($ireg);
 4442     scale(0x0);
 4443     disp($off);
 4444   %}
 4445 %}
 4446 
 4447 // Indirect Memory Times Scale Plus Index Register
 4448 operand indIndexScale_win95_safe(eRegP_no_EBP reg, rRegI ireg, immI2 scale)
 4449 %{
 4450   match(AddP reg (LShiftI ireg scale));
 4451 
 4452   op_cost(100);
 4453   format %{&quot;[$reg + $ireg &lt;&lt; $scale]&quot; %}
 4454   interface(MEMORY_INTER) %{
 4455     base($reg);
 4456     index($ireg);
 4457     scale($scale);
 4458     disp(0x0);
 4459   %}
 4460 %}
 4461 
 4462 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 4463 operand indIndexScaleOffset_win95_safe(eRegP_no_EBP reg, immI off, rRegI ireg, immI2 scale)
 4464 %{
 4465   match(AddP (AddP reg (LShiftI ireg scale)) off);
 4466 
 4467   op_cost(100);
 4468   format %{&quot;[$reg + $off + $ireg &lt;&lt; $scale]&quot; %}
 4469   interface(MEMORY_INTER) %{
 4470     base($reg);
 4471     index($ireg);
 4472     scale($scale);
 4473     disp($off);
 4474   %}
 4475 %}
 4476 
 4477 //----------Conditional Branch Operands----------------------------------------
 4478 // Comparison Op  - This is the operation of the comparison, and is limited to
 4479 //                  the following set of codes:
 4480 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
 4481 //
 4482 // Other attributes of the comparison, such as unsignedness, are specified
 4483 // by the comparison instruction that sets a condition code flags register.
 4484 // That result is represented by a flags operand whose subtype is appropriate
 4485 // to the unsignedness (etc.) of the comparison.
 4486 //
 4487 // Later, the instruction which matches both the Comparison Op (a Bool) and
 4488 // the flags (produced by the Cmp) specifies the coding of the comparison op
 4489 // by matching a specific subtype of Bool operand below, such as cmpOpU.
 4490 
 4491 // Comparision Code
 4492 operand cmpOp() %{
 4493   match(Bool);
 4494 
 4495   format %{ &quot;&quot; %}
 4496   interface(COND_INTER) %{
 4497     equal(0x4, &quot;e&quot;);
 4498     not_equal(0x5, &quot;ne&quot;);
 4499     less(0xC, &quot;l&quot;);
 4500     greater_equal(0xD, &quot;ge&quot;);
 4501     less_equal(0xE, &quot;le&quot;);
 4502     greater(0xF, &quot;g&quot;);
 4503     overflow(0x0, &quot;o&quot;);
 4504     no_overflow(0x1, &quot;no&quot;);
 4505   %}
 4506 %}
 4507 
 4508 // Comparison Code, unsigned compare.  Used by FP also, with
 4509 // C2 (unordered) turned into GT or LT already.  The other bits
 4510 // C0 and C3 are turned into Carry &amp; Zero flags.
 4511 operand cmpOpU() %{
 4512   match(Bool);
 4513 
 4514   format %{ &quot;&quot; %}
 4515   interface(COND_INTER) %{
 4516     equal(0x4, &quot;e&quot;);
 4517     not_equal(0x5, &quot;ne&quot;);
 4518     less(0x2, &quot;b&quot;);
 4519     greater_equal(0x3, &quot;nb&quot;);
 4520     less_equal(0x6, &quot;be&quot;);
 4521     greater(0x7, &quot;nbe&quot;);
 4522     overflow(0x0, &quot;o&quot;);
 4523     no_overflow(0x1, &quot;no&quot;);
 4524   %}
 4525 %}
 4526 
 4527 // Floating comparisons that don&#39;t require any fixup for the unordered case
 4528 operand cmpOpUCF() %{
 4529   match(Bool);
 4530   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
 4531             n-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ||
 4532             n-&gt;as_Bool()-&gt;_test._test == BoolTest::le ||
 4533             n-&gt;as_Bool()-&gt;_test._test == BoolTest::gt);
 4534   format %{ &quot;&quot; %}
 4535   interface(COND_INTER) %{
 4536     equal(0x4, &quot;e&quot;);
 4537     not_equal(0x5, &quot;ne&quot;);
 4538     less(0x2, &quot;b&quot;);
 4539     greater_equal(0x3, &quot;nb&quot;);
 4540     less_equal(0x6, &quot;be&quot;);
 4541     greater(0x7, &quot;nbe&quot;);
 4542     overflow(0x0, &quot;o&quot;);
 4543     no_overflow(0x1, &quot;no&quot;);
 4544   %}
 4545 %}
 4546 
 4547 
 4548 // Floating comparisons that can be fixed up with extra conditional jumps
 4549 operand cmpOpUCF2() %{
 4550   match(Bool);
 4551   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
 4552             n-&gt;as_Bool()-&gt;_test._test == BoolTest::eq);
 4553   format %{ &quot;&quot; %}
 4554   interface(COND_INTER) %{
 4555     equal(0x4, &quot;e&quot;);
 4556     not_equal(0x5, &quot;ne&quot;);
 4557     less(0x2, &quot;b&quot;);
 4558     greater_equal(0x3, &quot;nb&quot;);
 4559     less_equal(0x6, &quot;be&quot;);
 4560     greater(0x7, &quot;nbe&quot;);
 4561     overflow(0x0, &quot;o&quot;);
 4562     no_overflow(0x1, &quot;no&quot;);
 4563   %}
 4564 %}
 4565 
 4566 // Comparison Code for FP conditional move
 4567 operand cmpOp_fcmov() %{
 4568   match(Bool);
 4569 
 4570   predicate(n-&gt;as_Bool()-&gt;_test._test != BoolTest::overflow &amp;&amp;
 4571             n-&gt;as_Bool()-&gt;_test._test != BoolTest::no_overflow);
 4572   format %{ &quot;&quot; %}
 4573   interface(COND_INTER) %{
 4574     equal        (0x0C8);
 4575     not_equal    (0x1C8);
 4576     less         (0x0C0);
 4577     greater_equal(0x1C0);
 4578     less_equal   (0x0D0);
 4579     greater      (0x1D0);
 4580     overflow(0x0, &quot;o&quot;); // not really supported by the instruction
 4581     no_overflow(0x1, &quot;no&quot;); // not really supported by the instruction
 4582   %}
 4583 %}
 4584 
 4585 // Comparison Code used in long compares
 4586 operand cmpOp_commute() %{
 4587   match(Bool);
 4588 
 4589   format %{ &quot;&quot; %}
 4590   interface(COND_INTER) %{
 4591     equal(0x4, &quot;e&quot;);
 4592     not_equal(0x5, &quot;ne&quot;);
 4593     less(0xF, &quot;g&quot;);
 4594     greater_equal(0xE, &quot;le&quot;);
 4595     less_equal(0xD, &quot;ge&quot;);
 4596     greater(0xC, &quot;l&quot;);
 4597     overflow(0x0, &quot;o&quot;);
 4598     no_overflow(0x1, &quot;no&quot;);
 4599   %}
 4600 %}
 4601 
 4602 // Comparison Code used in unsigned long compares
 4603 operand cmpOpU_commute() %{
 4604   match(Bool);
 4605 
 4606   format %{ &quot;&quot; %}
 4607   interface(COND_INTER) %{
 4608     equal(0x4, &quot;e&quot;);
 4609     not_equal(0x5, &quot;ne&quot;);
 4610     less(0x7, &quot;nbe&quot;);
 4611     greater_equal(0x6, &quot;be&quot;);
 4612     less_equal(0x3, &quot;nb&quot;);
 4613     greater(0x2, &quot;b&quot;);
 4614     overflow(0x0, &quot;o&quot;);
 4615     no_overflow(0x1, &quot;no&quot;);
 4616   %}
 4617 %}
 4618 
 4619 //----------OPERAND CLASSES----------------------------------------------------
 4620 // Operand Classes are groups of operands that are used as to simplify
 4621 // instruction definitions by not requiring the AD writer to specify separate
 4622 // instructions for every form of operand when the instruction accepts
 4623 // multiple operand types with the same basic encoding and format.  The classic
 4624 // case of this is memory operands.
 4625 
 4626 opclass memory(direct, indirect, indOffset8, indOffset32, indOffset32X, indIndexOffset,
 4627                indIndex, indIndexScale, indIndexScaleOffset);
 4628 
 4629 // Long memory operations are encoded in 2 instructions and a +4 offset.
 4630 // This means some kind of offset is always required and you cannot use
 4631 // an oop as the offset (done when working on static globals).
 4632 opclass long_memory(direct, indirect, indOffset8, indOffset32, indIndexOffset,
 4633                     indIndex, indIndexScale, indIndexScaleOffset);
 4634 
 4635 
 4636 //----------PIPELINE-----------------------------------------------------------
 4637 // Rules which define the behavior of the target architectures pipeline.
 4638 pipeline %{
 4639 
 4640 //----------ATTRIBUTES---------------------------------------------------------
 4641 attributes %{
 4642   variable_size_instructions;        // Fixed size instructions
 4643   max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
 4644   instruction_unit_size = 1;         // An instruction is 1 bytes long
 4645   instruction_fetch_unit_size = 16;  // The processor fetches one line
 4646   instruction_fetch_units = 1;       // of 16 bytes
 4647 
 4648   // List of nop instructions
 4649   nops( MachNop );
 4650 %}
 4651 
 4652 //----------RESOURCES----------------------------------------------------------
 4653 // Resources are the functional units available to the machine
 4654 
 4655 // Generic P2/P3 pipeline
 4656 // 3 decoders, only D0 handles big operands; a &quot;bundle&quot; is the limit of
 4657 // 3 instructions decoded per cycle.
 4658 // 2 load/store ops per cycle, 1 branch, 1 FPU,
 4659 // 2 ALU op, only ALU0 handles mul/div instructions.
 4660 resources( D0, D1, D2, DECODE = D0 | D1 | D2,
 4661            MS0, MS1, MEM = MS0 | MS1,
 4662            BR, FPU,
 4663            ALU0, ALU1, ALU = ALU0 | ALU1 );
 4664 
 4665 //----------PIPELINE DESCRIPTION-----------------------------------------------
 4666 // Pipeline Description specifies the stages in the machine&#39;s pipeline
 4667 
 4668 // Generic P2/P3 pipeline
 4669 pipe_desc(S0, S1, S2, S3, S4, S5);
 4670 
 4671 //----------PIPELINE CLASSES---------------------------------------------------
 4672 // Pipeline Classes describe the stages in which input and output are
 4673 // referenced by the hardware pipeline.
 4674 
 4675 // Naming convention: ialu or fpu
 4676 // Then: _reg
 4677 // Then: _reg if there is a 2nd register
 4678 // Then: _long if it&#39;s a pair of instructions implementing a long
 4679 // Then: _fat if it requires the big decoder
 4680 //   Or: _mem if it requires the big decoder and a memory unit.
 4681 
 4682 // Integer ALU reg operation
 4683 pipe_class ialu_reg(rRegI dst) %{
 4684     single_instruction;
 4685     dst    : S4(write);
 4686     dst    : S3(read);
 4687     DECODE : S0;        // any decoder
 4688     ALU    : S3;        // any alu
 4689 %}
 4690 
 4691 // Long ALU reg operation
 4692 pipe_class ialu_reg_long(eRegL dst) %{
 4693     instruction_count(2);
 4694     dst    : S4(write);
 4695     dst    : S3(read);
 4696     DECODE : S0(2);     // any 2 decoders
 4697     ALU    : S3(2);     // both alus
 4698 %}
 4699 
 4700 // Integer ALU reg operation using big decoder
 4701 pipe_class ialu_reg_fat(rRegI dst) %{
 4702     single_instruction;
 4703     dst    : S4(write);
 4704     dst    : S3(read);
 4705     D0     : S0;        // big decoder only
 4706     ALU    : S3;        // any alu
 4707 %}
 4708 
 4709 // Long ALU reg operation using big decoder
 4710 pipe_class ialu_reg_long_fat(eRegL dst) %{
 4711     instruction_count(2);
 4712     dst    : S4(write);
 4713     dst    : S3(read);
 4714     D0     : S0(2);     // big decoder only; twice
 4715     ALU    : S3(2);     // any 2 alus
 4716 %}
 4717 
 4718 // Integer ALU reg-reg operation
 4719 pipe_class ialu_reg_reg(rRegI dst, rRegI src) %{
 4720     single_instruction;
 4721     dst    : S4(write);
 4722     src    : S3(read);
 4723     DECODE : S0;        // any decoder
 4724     ALU    : S3;        // any alu
 4725 %}
 4726 
 4727 // Long ALU reg-reg operation
 4728 pipe_class ialu_reg_reg_long(eRegL dst, eRegL src) %{
 4729     instruction_count(2);
 4730     dst    : S4(write);
 4731     src    : S3(read);
 4732     DECODE : S0(2);     // any 2 decoders
 4733     ALU    : S3(2);     // both alus
 4734 %}
 4735 
 4736 // Integer ALU reg-reg operation
 4737 pipe_class ialu_reg_reg_fat(rRegI dst, memory src) %{
 4738     single_instruction;
 4739     dst    : S4(write);
 4740     src    : S3(read);
 4741     D0     : S0;        // big decoder only
 4742     ALU    : S3;        // any alu
 4743 %}
 4744 
 4745 // Long ALU reg-reg operation
 4746 pipe_class ialu_reg_reg_long_fat(eRegL dst, eRegL src) %{
 4747     instruction_count(2);
 4748     dst    : S4(write);
 4749     src    : S3(read);
 4750     D0     : S0(2);     // big decoder only; twice
 4751     ALU    : S3(2);     // both alus
 4752 %}
 4753 
 4754 // Integer ALU reg-mem operation
 4755 pipe_class ialu_reg_mem(rRegI dst, memory mem) %{
 4756     single_instruction;
 4757     dst    : S5(write);
 4758     mem    : S3(read);
 4759     D0     : S0;        // big decoder only
 4760     ALU    : S4;        // any alu
 4761     MEM    : S3;        // any mem
 4762 %}
 4763 
 4764 // Long ALU reg-mem operation
 4765 pipe_class ialu_reg_long_mem(eRegL dst, load_long_memory mem) %{
 4766     instruction_count(2);
 4767     dst    : S5(write);
 4768     mem    : S3(read);
 4769     D0     : S0(2);     // big decoder only; twice
 4770     ALU    : S4(2);     // any 2 alus
 4771     MEM    : S3(2);     // both mems
 4772 %}
 4773 
 4774 // Integer mem operation (prefetch)
 4775 pipe_class ialu_mem(memory mem)
 4776 %{
 4777     single_instruction;
 4778     mem    : S3(read);
 4779     D0     : S0;        // big decoder only
 4780     MEM    : S3;        // any mem
 4781 %}
 4782 
 4783 // Integer Store to Memory
 4784 pipe_class ialu_mem_reg(memory mem, rRegI src) %{
 4785     single_instruction;
 4786     mem    : S3(read);
 4787     src    : S5(read);
 4788     D0     : S0;        // big decoder only
 4789     ALU    : S4;        // any alu
 4790     MEM    : S3;
 4791 %}
 4792 
 4793 // Long Store to Memory
 4794 pipe_class ialu_mem_long_reg(memory mem, eRegL src) %{
 4795     instruction_count(2);
 4796     mem    : S3(read);
 4797     src    : S5(read);
 4798     D0     : S0(2);     // big decoder only; twice
 4799     ALU    : S4(2);     // any 2 alus
 4800     MEM    : S3(2);     // Both mems
 4801 %}
 4802 
 4803 // Integer Store to Memory
 4804 pipe_class ialu_mem_imm(memory mem) %{
 4805     single_instruction;
 4806     mem    : S3(read);
 4807     D0     : S0;        // big decoder only
 4808     ALU    : S4;        // any alu
 4809     MEM    : S3;
 4810 %}
 4811 
 4812 // Integer ALU0 reg-reg operation
 4813 pipe_class ialu_reg_reg_alu0(rRegI dst, rRegI src) %{
 4814     single_instruction;
 4815     dst    : S4(write);
 4816     src    : S3(read);
 4817     D0     : S0;        // Big decoder only
 4818     ALU0   : S3;        // only alu0
 4819 %}
 4820 
 4821 // Integer ALU0 reg-mem operation
 4822 pipe_class ialu_reg_mem_alu0(rRegI dst, memory mem) %{
 4823     single_instruction;
 4824     dst    : S5(write);
 4825     mem    : S3(read);
 4826     D0     : S0;        // big decoder only
 4827     ALU0   : S4;        // ALU0 only
 4828     MEM    : S3;        // any mem
 4829 %}
 4830 
 4831 // Integer ALU reg-reg operation
 4832 pipe_class ialu_cr_reg_reg(eFlagsReg cr, rRegI src1, rRegI src2) %{
 4833     single_instruction;
 4834     cr     : S4(write);
 4835     src1   : S3(read);
 4836     src2   : S3(read);
 4837     DECODE : S0;        // any decoder
 4838     ALU    : S3;        // any alu
 4839 %}
 4840 
 4841 // Integer ALU reg-imm operation
 4842 pipe_class ialu_cr_reg_imm(eFlagsReg cr, rRegI src1) %{
 4843     single_instruction;
 4844     cr     : S4(write);
 4845     src1   : S3(read);
 4846     DECODE : S0;        // any decoder
 4847     ALU    : S3;        // any alu
 4848 %}
 4849 
 4850 // Integer ALU reg-mem operation
 4851 pipe_class ialu_cr_reg_mem(eFlagsReg cr, rRegI src1, memory src2) %{
 4852     single_instruction;
 4853     cr     : S4(write);
 4854     src1   : S3(read);
 4855     src2   : S3(read);
 4856     D0     : S0;        // big decoder only
 4857     ALU    : S4;        // any alu
 4858     MEM    : S3;
 4859 %}
 4860 
 4861 // Conditional move reg-reg
 4862 pipe_class pipe_cmplt( rRegI p, rRegI q, rRegI y ) %{
 4863     instruction_count(4);
 4864     y      : S4(read);
 4865     q      : S3(read);
 4866     p      : S3(read);
 4867     DECODE : S0(4);     // any decoder
 4868 %}
 4869 
 4870 // Conditional move reg-reg
 4871 pipe_class pipe_cmov_reg( rRegI dst, rRegI src, eFlagsReg cr ) %{
 4872     single_instruction;
 4873     dst    : S4(write);
 4874     src    : S3(read);
 4875     cr     : S3(read);
 4876     DECODE : S0;        // any decoder
 4877 %}
 4878 
 4879 // Conditional move reg-mem
 4880 pipe_class pipe_cmov_mem( eFlagsReg cr, rRegI dst, memory src) %{
 4881     single_instruction;
 4882     dst    : S4(write);
 4883     src    : S3(read);
 4884     cr     : S3(read);
 4885     DECODE : S0;        // any decoder
 4886     MEM    : S3;
 4887 %}
 4888 
 4889 // Conditional move reg-reg long
 4890 pipe_class pipe_cmov_reg_long( eFlagsReg cr, eRegL dst, eRegL src) %{
 4891     single_instruction;
 4892     dst    : S4(write);
 4893     src    : S3(read);
 4894     cr     : S3(read);
 4895     DECODE : S0(2);     // any 2 decoders
 4896 %}
 4897 
 4898 // Conditional move double reg-reg
 4899 pipe_class pipe_cmovDPR_reg( eFlagsReg cr, regDPR1 dst, regDPR src) %{
 4900     single_instruction;
 4901     dst    : S4(write);
 4902     src    : S3(read);
 4903     cr     : S3(read);
 4904     DECODE : S0;        // any decoder
 4905 %}
 4906 
 4907 // Float reg-reg operation
 4908 pipe_class fpu_reg(regDPR dst) %{
 4909     instruction_count(2);
 4910     dst    : S3(read);
 4911     DECODE : S0(2);     // any 2 decoders
 4912     FPU    : S3;
 4913 %}
 4914 
 4915 // Float reg-reg operation
 4916 pipe_class fpu_reg_reg(regDPR dst, regDPR src) %{
 4917     instruction_count(2);
 4918     dst    : S4(write);
 4919     src    : S3(read);
 4920     DECODE : S0(2);     // any 2 decoders
 4921     FPU    : S3;
 4922 %}
 4923 
 4924 // Float reg-reg operation
 4925 pipe_class fpu_reg_reg_reg(regDPR dst, regDPR src1, regDPR src2) %{
 4926     instruction_count(3);
 4927     dst    : S4(write);
 4928     src1   : S3(read);
 4929     src2   : S3(read);
 4930     DECODE : S0(3);     // any 3 decoders
 4931     FPU    : S3(2);
 4932 %}
 4933 
 4934 // Float reg-reg operation
 4935 pipe_class fpu_reg_reg_reg_reg(regDPR dst, regDPR src1, regDPR src2, regDPR src3) %{
 4936     instruction_count(4);
 4937     dst    : S4(write);
 4938     src1   : S3(read);
 4939     src2   : S3(read);
 4940     src3   : S3(read);
 4941     DECODE : S0(4);     // any 3 decoders
 4942     FPU    : S3(2);
 4943 %}
 4944 
 4945 // Float reg-reg operation
 4946 pipe_class fpu_reg_mem_reg_reg(regDPR dst, memory src1, regDPR src2, regDPR src3) %{
 4947     instruction_count(4);
 4948     dst    : S4(write);
 4949     src1   : S3(read);
 4950     src2   : S3(read);
 4951     src3   : S3(read);
 4952     DECODE : S1(3);     // any 3 decoders
 4953     D0     : S0;        // Big decoder only
 4954     FPU    : S3(2);
 4955     MEM    : S3;
 4956 %}
 4957 
 4958 // Float reg-mem operation
 4959 pipe_class fpu_reg_mem(regDPR dst, memory mem) %{
 4960     instruction_count(2);
 4961     dst    : S5(write);
 4962     mem    : S3(read);
 4963     D0     : S0;        // big decoder only
 4964     DECODE : S1;        // any decoder for FPU POP
 4965     FPU    : S4;
 4966     MEM    : S3;        // any mem
 4967 %}
 4968 
 4969 // Float reg-mem operation
 4970 pipe_class fpu_reg_reg_mem(regDPR dst, regDPR src1, memory mem) %{
 4971     instruction_count(3);
 4972     dst    : S5(write);
 4973     src1   : S3(read);
 4974     mem    : S3(read);
 4975     D0     : S0;        // big decoder only
 4976     DECODE : S1(2);     // any decoder for FPU POP
 4977     FPU    : S4;
 4978     MEM    : S3;        // any mem
 4979 %}
 4980 
 4981 // Float mem-reg operation
 4982 pipe_class fpu_mem_reg(memory mem, regDPR src) %{
 4983     instruction_count(2);
 4984     src    : S5(read);
 4985     mem    : S3(read);
 4986     DECODE : S0;        // any decoder for FPU PUSH
 4987     D0     : S1;        // big decoder only
 4988     FPU    : S4;
 4989     MEM    : S3;        // any mem
 4990 %}
 4991 
 4992 pipe_class fpu_mem_reg_reg(memory mem, regDPR src1, regDPR src2) %{
 4993     instruction_count(3);
 4994     src1   : S3(read);
 4995     src2   : S3(read);
 4996     mem    : S3(read);
 4997     DECODE : S0(2);     // any decoder for FPU PUSH
 4998     D0     : S1;        // big decoder only
 4999     FPU    : S4;
 5000     MEM    : S3;        // any mem
 5001 %}
 5002 
 5003 pipe_class fpu_mem_reg_mem(memory mem, regDPR src1, memory src2) %{
 5004     instruction_count(3);
 5005     src1   : S3(read);
 5006     src2   : S3(read);
 5007     mem    : S4(read);
 5008     DECODE : S0;        // any decoder for FPU PUSH
 5009     D0     : S0(2);     // big decoder only
 5010     FPU    : S4;
 5011     MEM    : S3(2);     // any mem
 5012 %}
 5013 
 5014 pipe_class fpu_mem_mem(memory dst, memory src1) %{
 5015     instruction_count(2);
 5016     src1   : S3(read);
 5017     dst    : S4(read);
 5018     D0     : S0(2);     // big decoder only
 5019     MEM    : S3(2);     // any mem
 5020 %}
 5021 
 5022 pipe_class fpu_mem_mem_mem(memory dst, memory src1, memory src2) %{
 5023     instruction_count(3);
 5024     src1   : S3(read);
 5025     src2   : S3(read);
 5026     dst    : S4(read);
 5027     D0     : S0(3);     // big decoder only
 5028     FPU    : S4;
 5029     MEM    : S3(3);     // any mem
 5030 %}
 5031 
 5032 pipe_class fpu_mem_reg_con(memory mem, regDPR src1) %{
 5033     instruction_count(3);
 5034     src1   : S4(read);
 5035     mem    : S4(read);
 5036     DECODE : S0;        // any decoder for FPU PUSH
 5037     D0     : S0(2);     // big decoder only
 5038     FPU    : S4;
 5039     MEM    : S3(2);     // any mem
 5040 %}
 5041 
 5042 // Float load constant
 5043 pipe_class fpu_reg_con(regDPR dst) %{
 5044     instruction_count(2);
 5045     dst    : S5(write);
 5046     D0     : S0;        // big decoder only for the load
 5047     DECODE : S1;        // any decoder for FPU POP
 5048     FPU    : S4;
 5049     MEM    : S3;        // any mem
 5050 %}
 5051 
 5052 // Float load constant
 5053 pipe_class fpu_reg_reg_con(regDPR dst, regDPR src) %{
 5054     instruction_count(3);
 5055     dst    : S5(write);
 5056     src    : S3(read);
 5057     D0     : S0;        // big decoder only for the load
 5058     DECODE : S1(2);     // any decoder for FPU POP
 5059     FPU    : S4;
 5060     MEM    : S3;        // any mem
 5061 %}
 5062 
 5063 // UnConditional branch
 5064 pipe_class pipe_jmp( label labl ) %{
 5065     single_instruction;
 5066     BR   : S3;
 5067 %}
 5068 
 5069 // Conditional branch
 5070 pipe_class pipe_jcc( cmpOp cmp, eFlagsReg cr, label labl ) %{
 5071     single_instruction;
 5072     cr    : S1(read);
 5073     BR    : S3;
 5074 %}
 5075 
 5076 // Allocation idiom
 5077 pipe_class pipe_cmpxchg( eRegP dst, eRegP heap_ptr ) %{
 5078     instruction_count(1); force_serialization;
 5079     fixed_latency(6);
 5080     heap_ptr : S3(read);
 5081     DECODE   : S0(3);
 5082     D0       : S2;
 5083     MEM      : S3;
 5084     ALU      : S3(2);
 5085     dst      : S5(write);
 5086     BR       : S5;
 5087 %}
 5088 
 5089 // Generic big/slow expanded idiom
 5090 pipe_class pipe_slow(  ) %{
 5091     instruction_count(10); multiple_bundles; force_serialization;
 5092     fixed_latency(100);
 5093     D0  : S0(2);
 5094     MEM : S3(2);
 5095 %}
 5096 
 5097 // The real do-nothing guy
 5098 pipe_class empty( ) %{
 5099     instruction_count(0);
 5100 %}
 5101 
 5102 // Define the class for the Nop node
 5103 define %{
 5104    MachNop = empty;
 5105 %}
 5106 
 5107 %}
 5108 
 5109 //----------INSTRUCTIONS-------------------------------------------------------
 5110 //
 5111 // match      -- States which machine-independent subtree may be replaced
 5112 //               by this instruction.
 5113 // ins_cost   -- The estimated cost of this instruction is used by instruction
 5114 //               selection to identify a minimum cost tree of machine
 5115 //               instructions that matches a tree of machine-independent
 5116 //               instructions.
 5117 // format     -- A string providing the disassembly for this instruction.
 5118 //               The value of an instruction&#39;s operand may be inserted
 5119 //               by referring to it with a &#39;$&#39; prefix.
 5120 // opcode     -- Three instruction opcodes may be provided.  These are referred
 5121 //               to within an encode class as $primary, $secondary, and $tertiary
 5122 //               respectively.  The primary opcode is commonly used to
 5123 //               indicate the type of machine instruction, while secondary
 5124 //               and tertiary are often used for prefix options or addressing
 5125 //               modes.
 5126 // ins_encode -- A list of encode classes with parameters. The encode class
 5127 //               name must have been defined in an &#39;enc_class&#39; specification
 5128 //               in the encode section of the architecture description.
 5129 
 5130 //----------BSWAP-Instruction--------------------------------------------------
 5131 instruct bytes_reverse_int(rRegI dst) %{
 5132   match(Set dst (ReverseBytesI dst));
 5133 
 5134   format %{ &quot;BSWAP  $dst&quot; %}
 5135   opcode(0x0F, 0xC8);
 5136   ins_encode( OpcP, OpcSReg(dst) );
 5137   ins_pipe( ialu_reg );
 5138 %}
 5139 
 5140 instruct bytes_reverse_long(eRegL dst) %{
 5141   match(Set dst (ReverseBytesL dst));
 5142 
 5143   format %{ &quot;BSWAP  $dst.lo\n\t&quot;
 5144             &quot;BSWAP  $dst.hi\n\t&quot;
 5145             &quot;XCHG   $dst.lo $dst.hi&quot; %}
 5146 
 5147   ins_cost(125);
 5148   ins_encode( bswap_long_bytes(dst) );
 5149   ins_pipe( ialu_reg_reg);
 5150 %}
 5151 
 5152 instruct bytes_reverse_unsigned_short(rRegI dst, eFlagsReg cr) %{
 5153   match(Set dst (ReverseBytesUS dst));
 5154   effect(KILL cr);
 5155 
 5156   format %{ &quot;BSWAP  $dst\n\t&quot;
 5157             &quot;SHR    $dst,16\n\t&quot; %}
 5158   ins_encode %{
 5159     __ bswapl($dst$$Register);
 5160     __ shrl($dst$$Register, 16);
 5161   %}
 5162   ins_pipe( ialu_reg );
 5163 %}
 5164 
 5165 instruct bytes_reverse_short(rRegI dst, eFlagsReg cr) %{
 5166   match(Set dst (ReverseBytesS dst));
 5167   effect(KILL cr);
 5168 
 5169   format %{ &quot;BSWAP  $dst\n\t&quot;
 5170             &quot;SAR    $dst,16\n\t&quot; %}
 5171   ins_encode %{
 5172     __ bswapl($dst$$Register);
 5173     __ sarl($dst$$Register, 16);
 5174   %}
 5175   ins_pipe( ialu_reg );
 5176 %}
 5177 
 5178 
 5179 //---------- Zeros Count Instructions ------------------------------------------
 5180 
 5181 instruct countLeadingZerosI(rRegI dst, rRegI src, eFlagsReg cr) %{
 5182   predicate(UseCountLeadingZerosInstruction);
 5183   match(Set dst (CountLeadingZerosI src));
 5184   effect(KILL cr);
 5185 
 5186   format %{ &quot;LZCNT  $dst, $src\t# count leading zeros (int)&quot; %}
 5187   ins_encode %{
 5188     __ lzcntl($dst$$Register, $src$$Register);
 5189   %}
 5190   ins_pipe(ialu_reg);
 5191 %}
 5192 
 5193 instruct countLeadingZerosI_bsr(rRegI dst, rRegI src, eFlagsReg cr) %{
 5194   predicate(!UseCountLeadingZerosInstruction);
 5195   match(Set dst (CountLeadingZerosI src));
 5196   effect(KILL cr);
 5197 
 5198   format %{ &quot;BSR    $dst, $src\t# count leading zeros (int)\n\t&quot;
 5199             &quot;JNZ    skip\n\t&quot;
 5200             &quot;MOV    $dst, -1\n&quot;
 5201       &quot;skip:\n\t&quot;
 5202             &quot;NEG    $dst\n\t&quot;
 5203             &quot;ADD    $dst, 31&quot; %}
 5204   ins_encode %{
 5205     Register Rdst = $dst$$Register;
 5206     Register Rsrc = $src$$Register;
 5207     Label skip;
 5208     __ bsrl(Rdst, Rsrc);
 5209     __ jccb(Assembler::notZero, skip);
 5210     __ movl(Rdst, -1);
 5211     __ bind(skip);
 5212     __ negl(Rdst);
 5213     __ addl(Rdst, BitsPerInt - 1);
 5214   %}
 5215   ins_pipe(ialu_reg);
 5216 %}
 5217 
 5218 instruct countLeadingZerosL(rRegI dst, eRegL src, eFlagsReg cr) %{
 5219   predicate(UseCountLeadingZerosInstruction);
 5220   match(Set dst (CountLeadingZerosL src));
 5221   effect(TEMP dst, KILL cr);
 5222 
 5223   format %{ &quot;LZCNT  $dst, $src.hi\t# count leading zeros (long)\n\t&quot;
 5224             &quot;JNC    done\n\t&quot;
 5225             &quot;LZCNT  $dst, $src.lo\n\t&quot;
 5226             &quot;ADD    $dst, 32\n&quot;
 5227       &quot;done:&quot; %}
 5228   ins_encode %{
 5229     Register Rdst = $dst$$Register;
 5230     Register Rsrc = $src$$Register;
 5231     Label done;
 5232     __ lzcntl(Rdst, HIGH_FROM_LOW(Rsrc));
 5233     __ jccb(Assembler::carryClear, done);
 5234     __ lzcntl(Rdst, Rsrc);
 5235     __ addl(Rdst, BitsPerInt);
 5236     __ bind(done);
 5237   %}
 5238   ins_pipe(ialu_reg);
 5239 %}
 5240 
 5241 instruct countLeadingZerosL_bsr(rRegI dst, eRegL src, eFlagsReg cr) %{
 5242   predicate(!UseCountLeadingZerosInstruction);
 5243   match(Set dst (CountLeadingZerosL src));
 5244   effect(TEMP dst, KILL cr);
 5245 
 5246   format %{ &quot;BSR    $dst, $src.hi\t# count leading zeros (long)\n\t&quot;
 5247             &quot;JZ     msw_is_zero\n\t&quot;
 5248             &quot;ADD    $dst, 32\n\t&quot;
 5249             &quot;JMP    not_zero\n&quot;
 5250       &quot;msw_is_zero:\n\t&quot;
 5251             &quot;BSR    $dst, $src.lo\n\t&quot;
 5252             &quot;JNZ    not_zero\n\t&quot;
 5253             &quot;MOV    $dst, -1\n&quot;
 5254       &quot;not_zero:\n\t&quot;
 5255             &quot;NEG    $dst\n\t&quot;
 5256             &quot;ADD    $dst, 63\n&quot; %}
 5257  ins_encode %{
 5258     Register Rdst = $dst$$Register;
 5259     Register Rsrc = $src$$Register;
 5260     Label msw_is_zero;
 5261     Label not_zero;
 5262     __ bsrl(Rdst, HIGH_FROM_LOW(Rsrc));
 5263     __ jccb(Assembler::zero, msw_is_zero);
 5264     __ addl(Rdst, BitsPerInt);
 5265     __ jmpb(not_zero);
 5266     __ bind(msw_is_zero);
 5267     __ bsrl(Rdst, Rsrc);
 5268     __ jccb(Assembler::notZero, not_zero);
 5269     __ movl(Rdst, -1);
 5270     __ bind(not_zero);
 5271     __ negl(Rdst);
 5272     __ addl(Rdst, BitsPerLong - 1);
 5273   %}
 5274   ins_pipe(ialu_reg);
 5275 %}
 5276 
 5277 instruct countTrailingZerosI(rRegI dst, rRegI src, eFlagsReg cr) %{
 5278   predicate(UseCountTrailingZerosInstruction);
 5279   match(Set dst (CountTrailingZerosI src));
 5280   effect(KILL cr);
 5281 
 5282   format %{ &quot;TZCNT    $dst, $src\t# count trailing zeros (int)&quot; %}
 5283   ins_encode %{
 5284     __ tzcntl($dst$$Register, $src$$Register);
 5285   %}
 5286   ins_pipe(ialu_reg);
 5287 %}
 5288 
 5289 instruct countTrailingZerosI_bsf(rRegI dst, rRegI src, eFlagsReg cr) %{
 5290   predicate(!UseCountTrailingZerosInstruction);
 5291   match(Set dst (CountTrailingZerosI src));
 5292   effect(KILL cr);
 5293 
 5294   format %{ &quot;BSF    $dst, $src\t# count trailing zeros (int)\n\t&quot;
 5295             &quot;JNZ    done\n\t&quot;
 5296             &quot;MOV    $dst, 32\n&quot;
 5297       &quot;done:&quot; %}
 5298   ins_encode %{
 5299     Register Rdst = $dst$$Register;
 5300     Label done;
 5301     __ bsfl(Rdst, $src$$Register);
 5302     __ jccb(Assembler::notZero, done);
 5303     __ movl(Rdst, BitsPerInt);
 5304     __ bind(done);
 5305   %}
 5306   ins_pipe(ialu_reg);
 5307 %}
 5308 
 5309 instruct countTrailingZerosL(rRegI dst, eRegL src, eFlagsReg cr) %{
 5310   predicate(UseCountTrailingZerosInstruction);
 5311   match(Set dst (CountTrailingZerosL src));
 5312   effect(TEMP dst, KILL cr);
 5313 
 5314   format %{ &quot;TZCNT  $dst, $src.lo\t# count trailing zeros (long) \n\t&quot;
 5315             &quot;JNC    done\n\t&quot;
 5316             &quot;TZCNT  $dst, $src.hi\n\t&quot;
 5317             &quot;ADD    $dst, 32\n&quot;
 5318             &quot;done:&quot; %}
 5319   ins_encode %{
 5320     Register Rdst = $dst$$Register;
 5321     Register Rsrc = $src$$Register;
 5322     Label done;
 5323     __ tzcntl(Rdst, Rsrc);
 5324     __ jccb(Assembler::carryClear, done);
 5325     __ tzcntl(Rdst, HIGH_FROM_LOW(Rsrc));
 5326     __ addl(Rdst, BitsPerInt);
 5327     __ bind(done);
 5328   %}
 5329   ins_pipe(ialu_reg);
 5330 %}
 5331 
 5332 instruct countTrailingZerosL_bsf(rRegI dst, eRegL src, eFlagsReg cr) %{
 5333   predicate(!UseCountTrailingZerosInstruction);
 5334   match(Set dst (CountTrailingZerosL src));
 5335   effect(TEMP dst, KILL cr);
 5336 
 5337   format %{ &quot;BSF    $dst, $src.lo\t# count trailing zeros (long)\n\t&quot;
 5338             &quot;JNZ    done\n\t&quot;
 5339             &quot;BSF    $dst, $src.hi\n\t&quot;
 5340             &quot;JNZ    msw_not_zero\n\t&quot;
 5341             &quot;MOV    $dst, 32\n&quot;
 5342       &quot;msw_not_zero:\n\t&quot;
 5343             &quot;ADD    $dst, 32\n&quot;
 5344       &quot;done:&quot; %}
 5345   ins_encode %{
 5346     Register Rdst = $dst$$Register;
 5347     Register Rsrc = $src$$Register;
 5348     Label msw_not_zero;
 5349     Label done;
 5350     __ bsfl(Rdst, Rsrc);
 5351     __ jccb(Assembler::notZero, done);
 5352     __ bsfl(Rdst, HIGH_FROM_LOW(Rsrc));
 5353     __ jccb(Assembler::notZero, msw_not_zero);
 5354     __ movl(Rdst, BitsPerInt);
 5355     __ bind(msw_not_zero);
 5356     __ addl(Rdst, BitsPerInt);
 5357     __ bind(done);
 5358   %}
 5359   ins_pipe(ialu_reg);
 5360 %}
 5361 
 5362 
 5363 //---------- Population Count Instructions -------------------------------------
 5364 
 5365 instruct popCountI(rRegI dst, rRegI src, eFlagsReg cr) %{
 5366   predicate(UsePopCountInstruction);
 5367   match(Set dst (PopCountI src));
 5368   effect(KILL cr);
 5369 
 5370   format %{ &quot;POPCNT $dst, $src&quot; %}
 5371   ins_encode %{
 5372     __ popcntl($dst$$Register, $src$$Register);
 5373   %}
 5374   ins_pipe(ialu_reg);
 5375 %}
 5376 
 5377 instruct popCountI_mem(rRegI dst, memory mem, eFlagsReg cr) %{
 5378   predicate(UsePopCountInstruction);
 5379   match(Set dst (PopCountI (LoadI mem)));
 5380   effect(KILL cr);
 5381 
 5382   format %{ &quot;POPCNT $dst, $mem&quot; %}
 5383   ins_encode %{
 5384     __ popcntl($dst$$Register, $mem$$Address);
 5385   %}
 5386   ins_pipe(ialu_reg);
 5387 %}
 5388 
 5389 // Note: Long.bitCount(long) returns an int.
 5390 instruct popCountL(rRegI dst, eRegL src, rRegI tmp, eFlagsReg cr) %{
 5391   predicate(UsePopCountInstruction);
 5392   match(Set dst (PopCountL src));
 5393   effect(KILL cr, TEMP tmp, TEMP dst);
 5394 
 5395   format %{ &quot;POPCNT $dst, $src.lo\n\t&quot;
 5396             &quot;POPCNT $tmp, $src.hi\n\t&quot;
 5397             &quot;ADD    $dst, $tmp&quot; %}
 5398   ins_encode %{
 5399     __ popcntl($dst$$Register, $src$$Register);
 5400     __ popcntl($tmp$$Register, HIGH_FROM_LOW($src$$Register));
 5401     __ addl($dst$$Register, $tmp$$Register);
 5402   %}
 5403   ins_pipe(ialu_reg);
 5404 %}
 5405 
 5406 // Note: Long.bitCount(long) returns an int.
 5407 instruct popCountL_mem(rRegI dst, memory mem, rRegI tmp, eFlagsReg cr) %{
 5408   predicate(UsePopCountInstruction);
 5409   match(Set dst (PopCountL (LoadL mem)));
 5410   effect(KILL cr, TEMP tmp, TEMP dst);
 5411 
 5412   format %{ &quot;POPCNT $dst, $mem\n\t&quot;
 5413             &quot;POPCNT $tmp, $mem+4\n\t&quot;
 5414             &quot;ADD    $dst, $tmp&quot; %}
 5415   ins_encode %{
 5416     //__ popcntl($dst$$Register, $mem$$Address$$first);
 5417     //__ popcntl($tmp$$Register, $mem$$Address$$second);
 5418     __ popcntl($dst$$Register, Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp, relocInfo::none));
 5419     __ popcntl($tmp$$Register, Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp + 4, relocInfo::none));
 5420     __ addl($dst$$Register, $tmp$$Register);
 5421   %}
 5422   ins_pipe(ialu_reg);
 5423 %}
 5424 
 5425 
 5426 //----------Load/Store/Move Instructions---------------------------------------
 5427 //----------Load Instructions--------------------------------------------------
 5428 // Load Byte (8bit signed)
 5429 instruct loadB(xRegI dst, memory mem) %{
 5430   match(Set dst (LoadB mem));
 5431 
 5432   ins_cost(125);
 5433   format %{ &quot;MOVSX8 $dst,$mem\t# byte&quot; %}
 5434 
 5435   ins_encode %{
 5436     __ movsbl($dst$$Register, $mem$$Address);
 5437   %}
 5438 
 5439   ins_pipe(ialu_reg_mem);
 5440 %}
 5441 
 5442 // Load Byte (8bit signed) into Long Register
 5443 instruct loadB2L(eRegL dst, memory mem, eFlagsReg cr) %{
 5444   match(Set dst (ConvI2L (LoadB mem)));
 5445   effect(KILL cr);
 5446 
 5447   ins_cost(375);
 5448   format %{ &quot;MOVSX8 $dst.lo,$mem\t# byte -&gt; long\n\t&quot;
 5449             &quot;MOV    $dst.hi,$dst.lo\n\t&quot;
 5450             &quot;SAR    $dst.hi,7&quot; %}
 5451 
 5452   ins_encode %{
 5453     __ movsbl($dst$$Register, $mem$$Address);
 5454     __ movl(HIGH_FROM_LOW($dst$$Register), $dst$$Register); // This is always a different register.
 5455     __ sarl(HIGH_FROM_LOW($dst$$Register), 7); // 24+1 MSB are already signed extended.
 5456   %}
 5457 
 5458   ins_pipe(ialu_reg_mem);
 5459 %}
 5460 
 5461 // Load Unsigned Byte (8bit UNsigned)
 5462 instruct loadUB(xRegI dst, memory mem) %{
 5463   match(Set dst (LoadUB mem));
 5464 
 5465   ins_cost(125);
 5466   format %{ &quot;MOVZX8 $dst,$mem\t# ubyte -&gt; int&quot; %}
 5467 
 5468   ins_encode %{
 5469     __ movzbl($dst$$Register, $mem$$Address);
 5470   %}
 5471 
 5472   ins_pipe(ialu_reg_mem);
 5473 %}
 5474 
 5475 // Load Unsigned Byte (8 bit UNsigned) into Long Register
 5476 instruct loadUB2L(eRegL dst, memory mem, eFlagsReg cr) %{
 5477   match(Set dst (ConvI2L (LoadUB mem)));
 5478   effect(KILL cr);
 5479 
 5480   ins_cost(250);
 5481   format %{ &quot;MOVZX8 $dst.lo,$mem\t# ubyte -&gt; long\n\t&quot;
 5482             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5483 
 5484   ins_encode %{
 5485     Register Rdst = $dst$$Register;
 5486     __ movzbl(Rdst, $mem$$Address);
 5487     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5488   %}
 5489 
 5490   ins_pipe(ialu_reg_mem);
 5491 %}
 5492 
 5493 // Load Unsigned Byte (8 bit UNsigned) with mask into Long Register
 5494 instruct loadUB2L_immI(eRegL dst, memory mem, immI mask, eFlagsReg cr) %{
 5495   match(Set dst (ConvI2L (AndI (LoadUB mem) mask)));
 5496   effect(KILL cr);
 5497 
 5498   format %{ &quot;MOVZX8 $dst.lo,$mem\t# ubyte &amp; 32-bit mask -&gt; long\n\t&quot;
 5499             &quot;XOR    $dst.hi,$dst.hi\n\t&quot;
 5500             &quot;AND    $dst.lo,right_n_bits($mask, 8)&quot; %}
 5501   ins_encode %{
 5502     Register Rdst = $dst$$Register;
 5503     __ movzbl(Rdst, $mem$$Address);
 5504     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5505     __ andl(Rdst, $mask$$constant &amp; right_n_bits(8));
 5506   %}
 5507   ins_pipe(ialu_reg_mem);
 5508 %}
 5509 
 5510 // Load Short (16bit signed)
 5511 instruct loadS(rRegI dst, memory mem) %{
 5512   match(Set dst (LoadS mem));
 5513 
 5514   ins_cost(125);
 5515   format %{ &quot;MOVSX  $dst,$mem\t# short&quot; %}
 5516 
 5517   ins_encode %{
 5518     __ movswl($dst$$Register, $mem$$Address);
 5519   %}
 5520 
 5521   ins_pipe(ialu_reg_mem);
 5522 %}
 5523 
 5524 // Load Short (16 bit signed) to Byte (8 bit signed)
 5525 instruct loadS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 5526   match(Set dst (RShiftI (LShiftI (LoadS mem) twentyfour) twentyfour));
 5527 
 5528   ins_cost(125);
 5529   format %{ &quot;MOVSX  $dst, $mem\t# short -&gt; byte&quot; %}
 5530   ins_encode %{
 5531     __ movsbl($dst$$Register, $mem$$Address);
 5532   %}
 5533   ins_pipe(ialu_reg_mem);
 5534 %}
 5535 
 5536 // Load Short (16bit signed) into Long Register
 5537 instruct loadS2L(eRegL dst, memory mem, eFlagsReg cr) %{
 5538   match(Set dst (ConvI2L (LoadS mem)));
 5539   effect(KILL cr);
 5540 
 5541   ins_cost(375);
 5542   format %{ &quot;MOVSX  $dst.lo,$mem\t# short -&gt; long\n\t&quot;
 5543             &quot;MOV    $dst.hi,$dst.lo\n\t&quot;
 5544             &quot;SAR    $dst.hi,15&quot; %}
 5545 
 5546   ins_encode %{
 5547     __ movswl($dst$$Register, $mem$$Address);
 5548     __ movl(HIGH_FROM_LOW($dst$$Register), $dst$$Register); // This is always a different register.
 5549     __ sarl(HIGH_FROM_LOW($dst$$Register), 15); // 16+1 MSB are already signed extended.
 5550   %}
 5551 
 5552   ins_pipe(ialu_reg_mem);
 5553 %}
 5554 
 5555 // Load Unsigned Short/Char (16bit unsigned)
 5556 instruct loadUS(rRegI dst, memory mem) %{
 5557   match(Set dst (LoadUS mem));
 5558 
 5559   ins_cost(125);
 5560   format %{ &quot;MOVZX  $dst,$mem\t# ushort/char -&gt; int&quot; %}
 5561 
 5562   ins_encode %{
 5563     __ movzwl($dst$$Register, $mem$$Address);
 5564   %}
 5565 
 5566   ins_pipe(ialu_reg_mem);
 5567 %}
 5568 
 5569 // Load Unsigned Short/Char (16 bit UNsigned) to Byte (8 bit signed)
 5570 instruct loadUS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 5571   match(Set dst (RShiftI (LShiftI (LoadUS mem) twentyfour) twentyfour));
 5572 
 5573   ins_cost(125);
 5574   format %{ &quot;MOVSX  $dst, $mem\t# ushort -&gt; byte&quot; %}
 5575   ins_encode %{
 5576     __ movsbl($dst$$Register, $mem$$Address);
 5577   %}
 5578   ins_pipe(ialu_reg_mem);
 5579 %}
 5580 
 5581 // Load Unsigned Short/Char (16 bit UNsigned) into Long Register
 5582 instruct loadUS2L(eRegL dst, memory mem, eFlagsReg cr) %{
 5583   match(Set dst (ConvI2L (LoadUS mem)));
 5584   effect(KILL cr);
 5585 
 5586   ins_cost(250);
 5587   format %{ &quot;MOVZX  $dst.lo,$mem\t# ushort/char -&gt; long\n\t&quot;
 5588             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5589 
 5590   ins_encode %{
 5591     __ movzwl($dst$$Register, $mem$$Address);
 5592     __ xorl(HIGH_FROM_LOW($dst$$Register), HIGH_FROM_LOW($dst$$Register));
 5593   %}
 5594 
 5595   ins_pipe(ialu_reg_mem);
 5596 %}
 5597 
 5598 // Load Unsigned Short/Char (16 bit UNsigned) with mask 0xFF into Long Register
 5599 instruct loadUS2L_immI_255(eRegL dst, memory mem, immI_255 mask, eFlagsReg cr) %{
 5600   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 5601   effect(KILL cr);
 5602 
 5603   format %{ &quot;MOVZX8 $dst.lo,$mem\t# ushort/char &amp; 0xFF -&gt; long\n\t&quot;
 5604             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5605   ins_encode %{
 5606     Register Rdst = $dst$$Register;
 5607     __ movzbl(Rdst, $mem$$Address);
 5608     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5609   %}
 5610   ins_pipe(ialu_reg_mem);
 5611 %}
 5612 
 5613 // Load Unsigned Short/Char (16 bit UNsigned) with a 32-bit mask into Long Register
 5614 instruct loadUS2L_immI(eRegL dst, memory mem, immI mask, eFlagsReg cr) %{
 5615   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 5616   effect(KILL cr);
 5617 
 5618   format %{ &quot;MOVZX  $dst.lo, $mem\t# ushort/char &amp; 32-bit mask -&gt; long\n\t&quot;
 5619             &quot;XOR    $dst.hi,$dst.hi\n\t&quot;
 5620             &quot;AND    $dst.lo,right_n_bits($mask, 16)&quot; %}
 5621   ins_encode %{
 5622     Register Rdst = $dst$$Register;
 5623     __ movzwl(Rdst, $mem$$Address);
 5624     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5625     __ andl(Rdst, $mask$$constant &amp; right_n_bits(16));
 5626   %}
 5627   ins_pipe(ialu_reg_mem);
 5628 %}
 5629 
 5630 // Load Integer
 5631 instruct loadI(rRegI dst, memory mem) %{
 5632   match(Set dst (LoadI mem));
 5633 
 5634   ins_cost(125);
 5635   format %{ &quot;MOV    $dst,$mem\t# int&quot; %}
 5636 
 5637   ins_encode %{
 5638     __ movl($dst$$Register, $mem$$Address);
 5639   %}
 5640 
 5641   ins_pipe(ialu_reg_mem);
 5642 %}
 5643 
 5644 // Load Integer (32 bit signed) to Byte (8 bit signed)
 5645 instruct loadI2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 5646   match(Set dst (RShiftI (LShiftI (LoadI mem) twentyfour) twentyfour));
 5647 
 5648   ins_cost(125);
 5649   format %{ &quot;MOVSX  $dst, $mem\t# int -&gt; byte&quot; %}
 5650   ins_encode %{
 5651     __ movsbl($dst$$Register, $mem$$Address);
 5652   %}
 5653   ins_pipe(ialu_reg_mem);
 5654 %}
 5655 
 5656 // Load Integer (32 bit signed) to Unsigned Byte (8 bit UNsigned)
 5657 instruct loadI2UB(rRegI dst, memory mem, immI_255 mask) %{
 5658   match(Set dst (AndI (LoadI mem) mask));
 5659 
 5660   ins_cost(125);
 5661   format %{ &quot;MOVZX  $dst, $mem\t# int -&gt; ubyte&quot; %}
 5662   ins_encode %{
 5663     __ movzbl($dst$$Register, $mem$$Address);
 5664   %}
 5665   ins_pipe(ialu_reg_mem);
 5666 %}
 5667 
 5668 // Load Integer (32 bit signed) to Short (16 bit signed)
 5669 instruct loadI2S(rRegI dst, memory mem, immI_16 sixteen) %{
 5670   match(Set dst (RShiftI (LShiftI (LoadI mem) sixteen) sixteen));
 5671 
 5672   ins_cost(125);
 5673   format %{ &quot;MOVSX  $dst, $mem\t# int -&gt; short&quot; %}
 5674   ins_encode %{
 5675     __ movswl($dst$$Register, $mem$$Address);
 5676   %}
 5677   ins_pipe(ialu_reg_mem);
 5678 %}
 5679 
 5680 // Load Integer (32 bit signed) to Unsigned Short/Char (16 bit UNsigned)
 5681 instruct loadI2US(rRegI dst, memory mem, immI_65535 mask) %{
 5682   match(Set dst (AndI (LoadI mem) mask));
 5683 
 5684   ins_cost(125);
 5685   format %{ &quot;MOVZX  $dst, $mem\t# int -&gt; ushort/char&quot; %}
 5686   ins_encode %{
 5687     __ movzwl($dst$$Register, $mem$$Address);
 5688   %}
 5689   ins_pipe(ialu_reg_mem);
 5690 %}
 5691 
 5692 // Load Integer into Long Register
 5693 instruct loadI2L(eRegL dst, memory mem, eFlagsReg cr) %{
 5694   match(Set dst (ConvI2L (LoadI mem)));
 5695   effect(KILL cr);
 5696 
 5697   ins_cost(375);
 5698   format %{ &quot;MOV    $dst.lo,$mem\t# int -&gt; long\n\t&quot;
 5699             &quot;MOV    $dst.hi,$dst.lo\n\t&quot;
 5700             &quot;SAR    $dst.hi,31&quot; %}
 5701 
 5702   ins_encode %{
 5703     __ movl($dst$$Register, $mem$$Address);
 5704     __ movl(HIGH_FROM_LOW($dst$$Register), $dst$$Register); // This is always a different register.
 5705     __ sarl(HIGH_FROM_LOW($dst$$Register), 31);
 5706   %}
 5707 
 5708   ins_pipe(ialu_reg_mem);
 5709 %}
 5710 
 5711 // Load Integer with mask 0xFF into Long Register
 5712 instruct loadI2L_immI_255(eRegL dst, memory mem, immI_255 mask, eFlagsReg cr) %{
 5713   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5714   effect(KILL cr);
 5715 
 5716   format %{ &quot;MOVZX8 $dst.lo,$mem\t# int &amp; 0xFF -&gt; long\n\t&quot;
 5717             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5718   ins_encode %{
 5719     Register Rdst = $dst$$Register;
 5720     __ movzbl(Rdst, $mem$$Address);
 5721     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5722   %}
 5723   ins_pipe(ialu_reg_mem);
 5724 %}
 5725 
 5726 // Load Integer with mask 0xFFFF into Long Register
 5727 instruct loadI2L_immI_65535(eRegL dst, memory mem, immI_65535 mask, eFlagsReg cr) %{
 5728   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5729   effect(KILL cr);
 5730 
 5731   format %{ &quot;MOVZX  $dst.lo,$mem\t# int &amp; 0xFFFF -&gt; long\n\t&quot;
 5732             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5733   ins_encode %{
 5734     Register Rdst = $dst$$Register;
 5735     __ movzwl(Rdst, $mem$$Address);
 5736     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5737   %}
 5738   ins_pipe(ialu_reg_mem);
 5739 %}
 5740 
 5741 // Load Integer with 31-bit mask into Long Register
 5742 instruct loadI2L_immU31(eRegL dst, memory mem, immU31 mask, eFlagsReg cr) %{
 5743   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5744   effect(KILL cr);
 5745 
 5746   format %{ &quot;MOV    $dst.lo,$mem\t# int &amp; 31-bit mask -&gt; long\n\t&quot;
 5747             &quot;XOR    $dst.hi,$dst.hi\n\t&quot;
 5748             &quot;AND    $dst.lo,$mask&quot; %}
 5749   ins_encode %{
 5750     Register Rdst = $dst$$Register;
 5751     __ movl(Rdst, $mem$$Address);
 5752     __ xorl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rdst));
 5753     __ andl(Rdst, $mask$$constant);
 5754   %}
 5755   ins_pipe(ialu_reg_mem);
 5756 %}
 5757 
 5758 // Load Unsigned Integer into Long Register
 5759 instruct loadUI2L(eRegL dst, memory mem, immL_32bits mask, eFlagsReg cr) %{
 5760   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 5761   effect(KILL cr);
 5762 
 5763   ins_cost(250);
 5764   format %{ &quot;MOV    $dst.lo,$mem\t# uint -&gt; long\n\t&quot;
 5765             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 5766 
 5767   ins_encode %{
 5768     __ movl($dst$$Register, $mem$$Address);
 5769     __ xorl(HIGH_FROM_LOW($dst$$Register), HIGH_FROM_LOW($dst$$Register));
 5770   %}
 5771 
 5772   ins_pipe(ialu_reg_mem);
 5773 %}
 5774 
 5775 // Load Long.  Cannot clobber address while loading, so restrict address
 5776 // register to ESI
 5777 instruct loadL(eRegL dst, load_long_memory mem) %{
 5778   predicate(!((LoadLNode*)n)-&gt;require_atomic_access());
 5779   match(Set dst (LoadL mem));
 5780 
 5781   ins_cost(250);
 5782   format %{ &quot;MOV    $dst.lo,$mem\t# long\n\t&quot;
 5783             &quot;MOV    $dst.hi,$mem+4&quot; %}
 5784 
 5785   ins_encode %{
 5786     Address Amemlo = Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp, relocInfo::none);
 5787     Address Amemhi = Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp + 4, relocInfo::none);
 5788     __ movl($dst$$Register, Amemlo);
 5789     __ movl(HIGH_FROM_LOW($dst$$Register), Amemhi);
 5790   %}
 5791 
 5792   ins_pipe(ialu_reg_long_mem);
 5793 %}
 5794 
 5795 // Volatile Load Long.  Must be atomic, so do 64-bit FILD
 5796 // then store it down to the stack and reload on the int
 5797 // side.
 5798 instruct loadL_volatile(stackSlotL dst, memory mem) %{
 5799   predicate(UseSSE&lt;=1 &amp;&amp; ((LoadLNode*)n)-&gt;require_atomic_access());
 5800   match(Set dst (LoadL mem));
 5801 
 5802   ins_cost(200);
 5803   format %{ &quot;FILD   $mem\t# Atomic volatile long load\n\t&quot;
 5804             &quot;FISTp  $dst&quot; %}
 5805   ins_encode(enc_loadL_volatile(mem,dst));
 5806   ins_pipe( fpu_reg_mem );
 5807 %}
 5808 
 5809 instruct loadLX_volatile(stackSlotL dst, memory mem, regD tmp) %{
 5810   predicate(UseSSE&gt;=2 &amp;&amp; ((LoadLNode*)n)-&gt;require_atomic_access());
 5811   match(Set dst (LoadL mem));
 5812   effect(TEMP tmp);
 5813   ins_cost(180);
 5814   format %{ &quot;MOVSD  $tmp,$mem\t# Atomic volatile long load\n\t&quot;
 5815             &quot;MOVSD  $dst,$tmp&quot; %}
 5816   ins_encode %{
 5817     __ movdbl($tmp$$XMMRegister, $mem$$Address);
 5818     __ movdbl(Address(rsp, $dst$$disp), $tmp$$XMMRegister);
 5819   %}
 5820   ins_pipe( pipe_slow );
 5821 %}
 5822 
 5823 instruct loadLX_reg_volatile(eRegL dst, memory mem, regD tmp) %{
 5824   predicate(UseSSE&gt;=2 &amp;&amp; ((LoadLNode*)n)-&gt;require_atomic_access());
 5825   match(Set dst (LoadL mem));
 5826   effect(TEMP tmp);
 5827   ins_cost(160);
 5828   format %{ &quot;MOVSD  $tmp,$mem\t# Atomic volatile long load\n\t&quot;
 5829             &quot;MOVD   $dst.lo,$tmp\n\t&quot;
 5830             &quot;PSRLQ  $tmp,32\n\t&quot;
 5831             &quot;MOVD   $dst.hi,$tmp&quot; %}
 5832   ins_encode %{
 5833     __ movdbl($tmp$$XMMRegister, $mem$$Address);
 5834     __ movdl($dst$$Register, $tmp$$XMMRegister);
 5835     __ psrlq($tmp$$XMMRegister, 32);
 5836     __ movdl(HIGH_FROM_LOW($dst$$Register), $tmp$$XMMRegister);
 5837   %}
 5838   ins_pipe( pipe_slow );
 5839 %}
 5840 
 5841 // Load Range
 5842 instruct loadRange(rRegI dst, memory mem) %{
 5843   match(Set dst (LoadRange mem));
 5844 
 5845   ins_cost(125);
 5846   format %{ &quot;MOV    $dst,$mem&quot; %}
 5847   opcode(0x8B);
 5848   ins_encode( OpcP, RegMem(dst,mem));
 5849   ins_pipe( ialu_reg_mem );
 5850 %}
 5851 
 5852 
 5853 // Load Pointer
 5854 instruct loadP(eRegP dst, memory mem) %{
 5855   match(Set dst (LoadP mem));
 5856 
 5857   ins_cost(125);
 5858   format %{ &quot;MOV    $dst,$mem&quot; %}
 5859   opcode(0x8B);
 5860   ins_encode( OpcP, RegMem(dst,mem));
 5861   ins_pipe( ialu_reg_mem );
 5862 %}
 5863 
 5864 // Load Klass Pointer
 5865 instruct loadKlass(eRegP dst, memory mem) %{
 5866   match(Set dst (LoadKlass mem));
 5867 
 5868   ins_cost(125);
 5869   format %{ &quot;MOV    $dst,$mem&quot; %}
 5870   opcode(0x8B);
 5871   ins_encode( OpcP, RegMem(dst,mem));
 5872   ins_pipe( ialu_reg_mem );
 5873 %}
 5874 
 5875 // Load Double
 5876 instruct loadDPR(regDPR dst, memory mem) %{
 5877   predicate(UseSSE&lt;=1);
 5878   match(Set dst (LoadD mem));
 5879 
 5880   ins_cost(150);
 5881   format %{ &quot;FLD_D  ST,$mem\n\t&quot;
 5882             &quot;FSTP   $dst&quot; %}
 5883   opcode(0xDD);               /* DD /0 */
 5884   ins_encode( OpcP, RMopc_Mem(0x00,mem),
 5885               Pop_Reg_DPR(dst) );
 5886   ins_pipe( fpu_reg_mem );
 5887 %}
 5888 
 5889 // Load Double to XMM
 5890 instruct loadD(regD dst, memory mem) %{
 5891   predicate(UseSSE&gt;=2 &amp;&amp; UseXmmLoadAndClearUpper);
 5892   match(Set dst (LoadD mem));
 5893   ins_cost(145);
 5894   format %{ &quot;MOVSD  $dst,$mem&quot; %}
 5895   ins_encode %{
 5896     __ movdbl ($dst$$XMMRegister, $mem$$Address);
 5897   %}
 5898   ins_pipe( pipe_slow );
 5899 %}
 5900 
 5901 instruct loadD_partial(regD dst, memory mem) %{
 5902   predicate(UseSSE&gt;=2 &amp;&amp; !UseXmmLoadAndClearUpper);
 5903   match(Set dst (LoadD mem));
 5904   ins_cost(145);
 5905   format %{ &quot;MOVLPD $dst,$mem&quot; %}
 5906   ins_encode %{
 5907     __ movdbl ($dst$$XMMRegister, $mem$$Address);
 5908   %}
 5909   ins_pipe( pipe_slow );
 5910 %}
 5911 
 5912 // Load to XMM register (single-precision floating point)
 5913 // MOVSS instruction
 5914 instruct loadF(regF dst, memory mem) %{
 5915   predicate(UseSSE&gt;=1);
 5916   match(Set dst (LoadF mem));
 5917   ins_cost(145);
 5918   format %{ &quot;MOVSS  $dst,$mem&quot; %}
 5919   ins_encode %{
 5920     __ movflt ($dst$$XMMRegister, $mem$$Address);
 5921   %}
 5922   ins_pipe( pipe_slow );
 5923 %}
 5924 
 5925 // Load Float
 5926 instruct loadFPR(regFPR dst, memory mem) %{
 5927   predicate(UseSSE==0);
 5928   match(Set dst (LoadF mem));
 5929 
 5930   ins_cost(150);
 5931   format %{ &quot;FLD_S  ST,$mem\n\t&quot;
 5932             &quot;FSTP   $dst&quot; %}
 5933   opcode(0xD9);               /* D9 /0 */
 5934   ins_encode( OpcP, RMopc_Mem(0x00,mem),
 5935               Pop_Reg_FPR(dst) );
 5936   ins_pipe( fpu_reg_mem );
 5937 %}
 5938 
 5939 // Load Effective Address
 5940 instruct leaP8(eRegP dst, indOffset8 mem) %{
 5941   match(Set dst mem);
 5942 
 5943   ins_cost(110);
 5944   format %{ &quot;LEA    $dst,$mem&quot; %}
 5945   opcode(0x8D);
 5946   ins_encode( OpcP, RegMem(dst,mem));
 5947   ins_pipe( ialu_reg_reg_fat );
 5948 %}
 5949 
 5950 instruct leaP32(eRegP dst, indOffset32 mem) %{
 5951   match(Set dst mem);
 5952 
 5953   ins_cost(110);
 5954   format %{ &quot;LEA    $dst,$mem&quot; %}
 5955   opcode(0x8D);
 5956   ins_encode( OpcP, RegMem(dst,mem));
 5957   ins_pipe( ialu_reg_reg_fat );
 5958 %}
 5959 
 5960 instruct leaPIdxOff(eRegP dst, indIndexOffset mem) %{
 5961   match(Set dst mem);
 5962 
 5963   ins_cost(110);
 5964   format %{ &quot;LEA    $dst,$mem&quot; %}
 5965   opcode(0x8D);
 5966   ins_encode( OpcP, RegMem(dst,mem));
 5967   ins_pipe( ialu_reg_reg_fat );
 5968 %}
 5969 
 5970 instruct leaPIdxScale(eRegP dst, indIndexScale mem) %{
 5971   match(Set dst mem);
 5972 
 5973   ins_cost(110);
 5974   format %{ &quot;LEA    $dst,$mem&quot; %}
 5975   opcode(0x8D);
 5976   ins_encode( OpcP, RegMem(dst,mem));
 5977   ins_pipe( ialu_reg_reg_fat );
 5978 %}
 5979 
 5980 instruct leaPIdxScaleOff(eRegP dst, indIndexScaleOffset mem) %{
 5981   match(Set dst mem);
 5982 
 5983   ins_cost(110);
 5984   format %{ &quot;LEA    $dst,$mem&quot; %}
 5985   opcode(0x8D);
 5986   ins_encode( OpcP, RegMem(dst,mem));
 5987   ins_pipe( ialu_reg_reg_fat );
 5988 %}
 5989 
 5990 // Load Constant
 5991 instruct loadConI(rRegI dst, immI src) %{
 5992   match(Set dst src);
 5993 
 5994   format %{ &quot;MOV    $dst,$src&quot; %}
 5995   ins_encode( LdImmI(dst, src) );
 5996   ins_pipe( ialu_reg_fat );
 5997 %}
 5998 
 5999 // Load Constant zero
 6000 instruct loadConI0(rRegI dst, immI0 src, eFlagsReg cr) %{
 6001   match(Set dst src);
 6002   effect(KILL cr);
 6003 
 6004   ins_cost(50);
 6005   format %{ &quot;XOR    $dst,$dst&quot; %}
 6006   opcode(0x33);  /* + rd */
 6007   ins_encode( OpcP, RegReg( dst, dst ) );
 6008   ins_pipe( ialu_reg );
 6009 %}
 6010 
 6011 instruct loadConP(eRegP dst, immP src) %{
 6012   match(Set dst src);
 6013 
 6014   format %{ &quot;MOV    $dst,$src&quot; %}
 6015   opcode(0xB8);  /* + rd */
 6016   ins_encode( LdImmP(dst, src) );
 6017   ins_pipe( ialu_reg_fat );
 6018 %}
 6019 
 6020 instruct loadConL(eRegL dst, immL src, eFlagsReg cr) %{
 6021   match(Set dst src);
 6022   effect(KILL cr);
 6023   ins_cost(200);
 6024   format %{ &quot;MOV    $dst.lo,$src.lo\n\t&quot;
 6025             &quot;MOV    $dst.hi,$src.hi&quot; %}
 6026   opcode(0xB8);
 6027   ins_encode( LdImmL_Lo(dst, src), LdImmL_Hi(dst, src) );
 6028   ins_pipe( ialu_reg_long_fat );
 6029 %}
 6030 
 6031 instruct loadConL0(eRegL dst, immL0 src, eFlagsReg cr) %{
 6032   match(Set dst src);
 6033   effect(KILL cr);
 6034   ins_cost(150);
 6035   format %{ &quot;XOR    $dst.lo,$dst.lo\n\t&quot;
 6036             &quot;XOR    $dst.hi,$dst.hi&quot; %}
 6037   opcode(0x33,0x33);
 6038   ins_encode( RegReg_Lo(dst,dst), RegReg_Hi(dst, dst) );
 6039   ins_pipe( ialu_reg_long );
 6040 %}
 6041 
 6042 // The instruction usage is guarded by predicate in operand immFPR().
 6043 instruct loadConFPR(regFPR dst, immFPR con) %{
 6044   match(Set dst con);
 6045   ins_cost(125);
 6046   format %{ &quot;FLD_S  ST,[$constantaddress]\t# load from constant table: float=$con\n\t&quot;
 6047             &quot;FSTP   $dst&quot; %}
 6048   ins_encode %{
 6049     __ fld_s($constantaddress($con));
 6050     __ fstp_d($dst$$reg);
 6051   %}
 6052   ins_pipe(fpu_reg_con);
 6053 %}
 6054 
 6055 // The instruction usage is guarded by predicate in operand immFPR0().
 6056 instruct loadConFPR0(regFPR dst, immFPR0 con) %{
 6057   match(Set dst con);
 6058   ins_cost(125);
 6059   format %{ &quot;FLDZ   ST\n\t&quot;
 6060             &quot;FSTP   $dst&quot; %}
 6061   ins_encode %{
 6062     __ fldz();
 6063     __ fstp_d($dst$$reg);
 6064   %}
 6065   ins_pipe(fpu_reg_con);
 6066 %}
 6067 
 6068 // The instruction usage is guarded by predicate in operand immFPR1().
 6069 instruct loadConFPR1(regFPR dst, immFPR1 con) %{
 6070   match(Set dst con);
 6071   ins_cost(125);
 6072   format %{ &quot;FLD1   ST\n\t&quot;
 6073             &quot;FSTP   $dst&quot; %}
 6074   ins_encode %{
 6075     __ fld1();
 6076     __ fstp_d($dst$$reg);
 6077   %}
 6078   ins_pipe(fpu_reg_con);
 6079 %}
 6080 
 6081 // The instruction usage is guarded by predicate in operand immF().
 6082 instruct loadConF(regF dst, immF con) %{
 6083   match(Set dst con);
 6084   ins_cost(125);
 6085   format %{ &quot;MOVSS  $dst,[$constantaddress]\t# load from constant table: float=$con&quot; %}
 6086   ins_encode %{
 6087     __ movflt($dst$$XMMRegister, $constantaddress($con));
 6088   %}
 6089   ins_pipe(pipe_slow);
 6090 %}
 6091 
 6092 // The instruction usage is guarded by predicate in operand immF0().
 6093 instruct loadConF0(regF dst, immF0 src) %{
 6094   match(Set dst src);
 6095   ins_cost(100);
 6096   format %{ &quot;XORPS  $dst,$dst\t# float 0.0&quot; %}
 6097   ins_encode %{
 6098     __ xorps($dst$$XMMRegister, $dst$$XMMRegister);
 6099   %}
 6100   ins_pipe(pipe_slow);
 6101 %}
 6102 
 6103 // The instruction usage is guarded by predicate in operand immDPR().
 6104 instruct loadConDPR(regDPR dst, immDPR con) %{
 6105   match(Set dst con);
 6106   ins_cost(125);
 6107 
 6108   format %{ &quot;FLD_D  ST,[$constantaddress]\t# load from constant table: double=$con\n\t&quot;
 6109             &quot;FSTP   $dst&quot; %}
 6110   ins_encode %{
 6111     __ fld_d($constantaddress($con));
 6112     __ fstp_d($dst$$reg);
 6113   %}
 6114   ins_pipe(fpu_reg_con);
 6115 %}
 6116 
 6117 // The instruction usage is guarded by predicate in operand immDPR0().
 6118 instruct loadConDPR0(regDPR dst, immDPR0 con) %{
 6119   match(Set dst con);
 6120   ins_cost(125);
 6121 
 6122   format %{ &quot;FLDZ   ST\n\t&quot;
 6123             &quot;FSTP   $dst&quot; %}
 6124   ins_encode %{
 6125     __ fldz();
 6126     __ fstp_d($dst$$reg);
 6127   %}
 6128   ins_pipe(fpu_reg_con);
 6129 %}
 6130 
 6131 // The instruction usage is guarded by predicate in operand immDPR1().
 6132 instruct loadConDPR1(regDPR dst, immDPR1 con) %{
 6133   match(Set dst con);
 6134   ins_cost(125);
 6135 
 6136   format %{ &quot;FLD1   ST\n\t&quot;
 6137             &quot;FSTP   $dst&quot; %}
 6138   ins_encode %{
 6139     __ fld1();
 6140     __ fstp_d($dst$$reg);
 6141   %}
 6142   ins_pipe(fpu_reg_con);
 6143 %}
 6144 
 6145 // The instruction usage is guarded by predicate in operand immD().
 6146 instruct loadConD(regD dst, immD con) %{
 6147   match(Set dst con);
 6148   ins_cost(125);
 6149   format %{ &quot;MOVSD  $dst,[$constantaddress]\t# load from constant table: double=$con&quot; %}
 6150   ins_encode %{
 6151     __ movdbl($dst$$XMMRegister, $constantaddress($con));
 6152   %}
 6153   ins_pipe(pipe_slow);
 6154 %}
 6155 
 6156 // The instruction usage is guarded by predicate in operand immD0().
 6157 instruct loadConD0(regD dst, immD0 src) %{
 6158   match(Set dst src);
 6159   ins_cost(100);
 6160   format %{ &quot;XORPD  $dst,$dst\t# double 0.0&quot; %}
 6161   ins_encode %{
 6162     __ xorpd ($dst$$XMMRegister, $dst$$XMMRegister);
 6163   %}
 6164   ins_pipe( pipe_slow );
 6165 %}
 6166 
 6167 // Load Stack Slot
 6168 instruct loadSSI(rRegI dst, stackSlotI src) %{
 6169   match(Set dst src);
 6170   ins_cost(125);
 6171 
 6172   format %{ &quot;MOV    $dst,$src&quot; %}
 6173   opcode(0x8B);
 6174   ins_encode( OpcP, RegMem(dst,src));
 6175   ins_pipe( ialu_reg_mem );
 6176 %}
 6177 
 6178 instruct loadSSL(eRegL dst, stackSlotL src) %{
 6179   match(Set dst src);
 6180 
 6181   ins_cost(200);
 6182   format %{ &quot;MOV    $dst,$src.lo\n\t&quot;
 6183             &quot;MOV    $dst+4,$src.hi&quot; %}
 6184   opcode(0x8B, 0x8B);
 6185   ins_encode( OpcP, RegMem( dst, src ), OpcS, RegMem_Hi( dst, src ) );
 6186   ins_pipe( ialu_mem_long_reg );
 6187 %}
 6188 
 6189 // Load Stack Slot
 6190 instruct loadSSP(eRegP dst, stackSlotP src) %{
 6191   match(Set dst src);
 6192   ins_cost(125);
 6193 
 6194   format %{ &quot;MOV    $dst,$src&quot; %}
 6195   opcode(0x8B);
 6196   ins_encode( OpcP, RegMem(dst,src));
 6197   ins_pipe( ialu_reg_mem );
 6198 %}
 6199 
 6200 // Load Stack Slot
 6201 instruct loadSSF(regFPR dst, stackSlotF src) %{
 6202   match(Set dst src);
 6203   ins_cost(125);
 6204 
 6205   format %{ &quot;FLD_S  $src\n\t&quot;
 6206             &quot;FSTP   $dst&quot; %}
 6207   opcode(0xD9);               /* D9 /0, FLD m32real */
 6208   ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),
 6209               Pop_Reg_FPR(dst) );
 6210   ins_pipe( fpu_reg_mem );
 6211 %}
 6212 
 6213 // Load Stack Slot
 6214 instruct loadSSD(regDPR dst, stackSlotD src) %{
 6215   match(Set dst src);
 6216   ins_cost(125);
 6217 
 6218   format %{ &quot;FLD_D  $src\n\t&quot;
 6219             &quot;FSTP   $dst&quot; %}
 6220   opcode(0xDD);               /* DD /0, FLD m64real */
 6221   ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),
 6222               Pop_Reg_DPR(dst) );
 6223   ins_pipe( fpu_reg_mem );
 6224 %}
 6225 
 6226 // Prefetch instructions for allocation.
 6227 // Must be safe to execute with invalid address (cannot fault).
 6228 
 6229 instruct prefetchAlloc0( memory mem ) %{
 6230   predicate(UseSSE==0 &amp;&amp; AllocatePrefetchInstr!=3);
 6231   match(PrefetchAllocation mem);
 6232   ins_cost(0);
 6233   size(0);
 6234   format %{ &quot;Prefetch allocation (non-SSE is empty encoding)&quot; %}
 6235   ins_encode();
 6236   ins_pipe(empty);
 6237 %}
 6238 
 6239 instruct prefetchAlloc( memory mem ) %{
 6240   predicate(AllocatePrefetchInstr==3);
 6241   match( PrefetchAllocation mem );
 6242   ins_cost(100);
 6243 
 6244   format %{ &quot;PREFETCHW $mem\t! Prefetch allocation into L1 cache and mark modified&quot; %}
 6245   ins_encode %{
 6246     __ prefetchw($mem$$Address);
 6247   %}
 6248   ins_pipe(ialu_mem);
 6249 %}
 6250 
 6251 instruct prefetchAllocNTA( memory mem ) %{
 6252   predicate(UseSSE&gt;=1 &amp;&amp; AllocatePrefetchInstr==0);
 6253   match(PrefetchAllocation mem);
 6254   ins_cost(100);
 6255 
 6256   format %{ &quot;PREFETCHNTA $mem\t! Prefetch allocation into non-temporal cache for write&quot; %}
 6257   ins_encode %{
 6258     __ prefetchnta($mem$$Address);
 6259   %}
 6260   ins_pipe(ialu_mem);
 6261 %}
 6262 
 6263 instruct prefetchAllocT0( memory mem ) %{
 6264   predicate(UseSSE&gt;=1 &amp;&amp; AllocatePrefetchInstr==1);
 6265   match(PrefetchAllocation mem);
 6266   ins_cost(100);
 6267 
 6268   format %{ &quot;PREFETCHT0 $mem\t! Prefetch allocation into L1 and L2 caches for write&quot; %}
 6269   ins_encode %{
 6270     __ prefetcht0($mem$$Address);
 6271   %}
 6272   ins_pipe(ialu_mem);
 6273 %}
 6274 
 6275 instruct prefetchAllocT2( memory mem ) %{
 6276   predicate(UseSSE&gt;=1 &amp;&amp; AllocatePrefetchInstr==2);
 6277   match(PrefetchAllocation mem);
 6278   ins_cost(100);
 6279 
 6280   format %{ &quot;PREFETCHT2 $mem\t! Prefetch allocation into L2 cache for write&quot; %}
 6281   ins_encode %{
 6282     __ prefetcht2($mem$$Address);
 6283   %}
 6284   ins_pipe(ialu_mem);
 6285 %}
 6286 
 6287 //----------Store Instructions-------------------------------------------------
 6288 
 6289 // Store Byte
 6290 instruct storeB(memory mem, xRegI src) %{
 6291   match(Set mem (StoreB mem src));
 6292 
 6293   ins_cost(125);
 6294   format %{ &quot;MOV8   $mem,$src&quot; %}
 6295   opcode(0x88);
 6296   ins_encode( OpcP, RegMem( src, mem ) );
 6297   ins_pipe( ialu_mem_reg );
 6298 %}
 6299 
 6300 // Store Char/Short
 6301 instruct storeC(memory mem, rRegI src) %{
 6302   match(Set mem (StoreC mem src));
 6303 
 6304   ins_cost(125);
 6305   format %{ &quot;MOV16  $mem,$src&quot; %}
 6306   opcode(0x89, 0x66);
 6307   ins_encode( OpcS, OpcP, RegMem( src, mem ) );
 6308   ins_pipe( ialu_mem_reg );
 6309 %}
 6310 
 6311 // Store Integer
 6312 instruct storeI(memory mem, rRegI src) %{
 6313   match(Set mem (StoreI mem src));
 6314 
 6315   ins_cost(125);
 6316   format %{ &quot;MOV    $mem,$src&quot; %}
 6317   opcode(0x89);
 6318   ins_encode( OpcP, RegMem( src, mem ) );
 6319   ins_pipe( ialu_mem_reg );
 6320 %}
 6321 
 6322 // Store Long
 6323 instruct storeL(long_memory mem, eRegL src) %{
 6324   predicate(!((StoreLNode*)n)-&gt;require_atomic_access());
 6325   match(Set mem (StoreL mem src));
 6326 
 6327   ins_cost(200);
 6328   format %{ &quot;MOV    $mem,$src.lo\n\t&quot;
 6329             &quot;MOV    $mem+4,$src.hi&quot; %}
 6330   opcode(0x89, 0x89);
 6331   ins_encode( OpcP, RegMem( src, mem ), OpcS, RegMem_Hi( src, mem ) );
 6332   ins_pipe( ialu_mem_long_reg );
 6333 %}
 6334 
 6335 // Store Long to Integer
 6336 instruct storeL2I(memory mem, eRegL src) %{
 6337   match(Set mem (StoreI mem (ConvL2I src)));
 6338 
 6339   format %{ &quot;MOV    $mem,$src.lo\t# long -&gt; int&quot; %}
 6340   ins_encode %{
 6341     __ movl($mem$$Address, $src$$Register);
 6342   %}
 6343   ins_pipe(ialu_mem_reg);
 6344 %}
 6345 
 6346 // Volatile Store Long.  Must be atomic, so move it into
 6347 // the FP TOS and then do a 64-bit FIST.  Has to probe the
 6348 // target address before the store (for null-ptr checks)
 6349 // so the memory operand is used twice in the encoding.
 6350 instruct storeL_volatile(memory mem, stackSlotL src, eFlagsReg cr ) %{
 6351   predicate(UseSSE&lt;=1 &amp;&amp; ((StoreLNode*)n)-&gt;require_atomic_access());
 6352   match(Set mem (StoreL mem src));
 6353   effect( KILL cr );
 6354   ins_cost(400);
 6355   format %{ &quot;CMP    $mem,EAX\t# Probe address for implicit null check\n\t&quot;
 6356             &quot;FILD   $src\n\t&quot;
 6357             &quot;FISTp  $mem\t # 64-bit atomic volatile long store&quot; %}
 6358   opcode(0x3B);
 6359   ins_encode( OpcP, RegMem( EAX, mem ), enc_storeL_volatile(mem,src));
 6360   ins_pipe( fpu_reg_mem );
 6361 %}
 6362 
 6363 instruct storeLX_volatile(memory mem, stackSlotL src, regD tmp, eFlagsReg cr) %{
 6364   predicate(UseSSE&gt;=2 &amp;&amp; ((StoreLNode*)n)-&gt;require_atomic_access());
 6365   match(Set mem (StoreL mem src));
 6366   effect( TEMP tmp, KILL cr );
 6367   ins_cost(380);
 6368   format %{ &quot;CMP    $mem,EAX\t# Probe address for implicit null check\n\t&quot;
 6369             &quot;MOVSD  $tmp,$src\n\t&quot;
 6370             &quot;MOVSD  $mem,$tmp\t # 64-bit atomic volatile long store&quot; %}
 6371   ins_encode %{
 6372     __ cmpl(rax, $mem$$Address);
 6373     __ movdbl($tmp$$XMMRegister, Address(rsp, $src$$disp));
 6374     __ movdbl($mem$$Address, $tmp$$XMMRegister);
 6375   %}
 6376   ins_pipe( pipe_slow );
 6377 %}
 6378 
 6379 instruct storeLX_reg_volatile(memory mem, eRegL src, regD tmp2, regD tmp, eFlagsReg cr) %{
 6380   predicate(UseSSE&gt;=2 &amp;&amp; ((StoreLNode*)n)-&gt;require_atomic_access());
 6381   match(Set mem (StoreL mem src));
 6382   effect( TEMP tmp2 , TEMP tmp, KILL cr );
 6383   ins_cost(360);
 6384   format %{ &quot;CMP    $mem,EAX\t# Probe address for implicit null check\n\t&quot;
 6385             &quot;MOVD   $tmp,$src.lo\n\t&quot;
 6386             &quot;MOVD   $tmp2,$src.hi\n\t&quot;
 6387             &quot;PUNPCKLDQ $tmp,$tmp2\n\t&quot;
 6388             &quot;MOVSD  $mem,$tmp\t # 64-bit atomic volatile long store&quot; %}
 6389   ins_encode %{
 6390     __ cmpl(rax, $mem$$Address);
 6391     __ movdl($tmp$$XMMRegister, $src$$Register);
 6392     __ movdl($tmp2$$XMMRegister, HIGH_FROM_LOW($src$$Register));
 6393     __ punpckldq($tmp$$XMMRegister, $tmp2$$XMMRegister);
 6394     __ movdbl($mem$$Address, $tmp$$XMMRegister);
 6395   %}
 6396   ins_pipe( pipe_slow );
 6397 %}
 6398 
 6399 // Store Pointer; for storing unknown oops and raw pointers
 6400 instruct storeP(memory mem, anyRegP src) %{
 6401   match(Set mem (StoreP mem src));
 6402 
 6403   ins_cost(125);
 6404   format %{ &quot;MOV    $mem,$src&quot; %}
 6405   opcode(0x89);
 6406   ins_encode( OpcP, RegMem( src, mem ) );
 6407   ins_pipe( ialu_mem_reg );
 6408 %}
 6409 
 6410 // Store Integer Immediate
 6411 instruct storeImmI(memory mem, immI src) %{
 6412   match(Set mem (StoreI mem src));
 6413 
 6414   ins_cost(150);
 6415   format %{ &quot;MOV    $mem,$src&quot; %}
 6416   opcode(0xC7);               /* C7 /0 */
 6417   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32( src ));
 6418   ins_pipe( ialu_mem_imm );
 6419 %}
 6420 
 6421 // Store Short/Char Immediate
 6422 instruct storeImmI16(memory mem, immI16 src) %{
 6423   predicate(UseStoreImmI16);
 6424   match(Set mem (StoreC mem src));
 6425 
 6426   ins_cost(150);
 6427   format %{ &quot;MOV16  $mem,$src&quot; %}
 6428   opcode(0xC7);     /* C7 /0 Same as 32 store immediate with prefix */
 6429   ins_encode( SizePrefix, OpcP, RMopc_Mem(0x00,mem),  Con16( src ));
 6430   ins_pipe( ialu_mem_imm );
 6431 %}
 6432 
 6433 // Store Pointer Immediate; null pointers or constant oops that do not
 6434 // need card-mark barriers.
 6435 instruct storeImmP(memory mem, immP src) %{
 6436   match(Set mem (StoreP mem src));
 6437 
 6438   ins_cost(150);
 6439   format %{ &quot;MOV    $mem,$src&quot; %}
 6440   opcode(0xC7);               /* C7 /0 */
 6441   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32( src ));
 6442   ins_pipe( ialu_mem_imm );
 6443 %}
 6444 
 6445 // Store Byte Immediate
 6446 instruct storeImmB(memory mem, immI8 src) %{
 6447   match(Set mem (StoreB mem src));
 6448 
 6449   ins_cost(150);
 6450   format %{ &quot;MOV8   $mem,$src&quot; %}
 6451   opcode(0xC6);               /* C6 /0 */
 6452   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con8or32( src ));
 6453   ins_pipe( ialu_mem_imm );
 6454 %}
 6455 
 6456 // Store CMS card-mark Immediate
 6457 instruct storeImmCM(memory mem, immI8 src) %{
 6458   match(Set mem (StoreCM mem src));
 6459 
 6460   ins_cost(150);
 6461   format %{ &quot;MOV8   $mem,$src\t! CMS card-mark imm0&quot; %}
 6462   opcode(0xC6);               /* C6 /0 */
 6463   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con8or32( src ));
 6464   ins_pipe( ialu_mem_imm );
 6465 %}
 6466 
 6467 // Store Double
 6468 instruct storeDPR( memory mem, regDPR1 src) %{
 6469   predicate(UseSSE&lt;=1);
 6470   match(Set mem (StoreD mem src));
 6471 
 6472   ins_cost(100);
 6473   format %{ &quot;FST_D  $mem,$src&quot; %}
 6474   opcode(0xDD);       /* DD /2 */
 6475   ins_encode( enc_FPR_store(mem,src) );
 6476   ins_pipe( fpu_mem_reg );
 6477 %}
 6478 
 6479 // Store double does rounding on x86
 6480 instruct storeDPR_rounded( memory mem, regDPR1 src) %{
 6481   predicate(UseSSE&lt;=1);
 6482   match(Set mem (StoreD mem (RoundDouble src)));
 6483 
 6484   ins_cost(100);
 6485   format %{ &quot;FST_D  $mem,$src\t# round&quot; %}
 6486   opcode(0xDD);       /* DD /2 */
 6487   ins_encode( enc_FPR_store(mem,src) );
 6488   ins_pipe( fpu_mem_reg );
 6489 %}
 6490 
 6491 // Store XMM register to memory (double-precision floating points)
 6492 // MOVSD instruction
 6493 instruct storeD(memory mem, regD src) %{
 6494   predicate(UseSSE&gt;=2);
 6495   match(Set mem (StoreD mem src));
 6496   ins_cost(95);
 6497   format %{ &quot;MOVSD  $mem,$src&quot; %}
 6498   ins_encode %{
 6499     __ movdbl($mem$$Address, $src$$XMMRegister);
 6500   %}
 6501   ins_pipe( pipe_slow );
 6502 %}
 6503 
 6504 // Load Double
 6505 instruct MoveD2VL(vlRegD dst, regD src) %{
 6506   match(Set dst src);
 6507   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 6508   ins_encode %{
 6509     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 6510   %}
 6511   ins_pipe( fpu_reg_reg );
 6512 %}
 6513 
 6514 // Load Double
 6515 instruct MoveVL2D(regD dst, vlRegD src) %{
 6516   match(Set dst src);
 6517   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 6518   ins_encode %{
 6519     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 6520   %}
 6521   ins_pipe( fpu_reg_reg );
 6522 %}
 6523 
 6524 // Store XMM register to memory (single-precision floating point)
 6525 // MOVSS instruction
 6526 instruct storeF(memory mem, regF src) %{
 6527   predicate(UseSSE&gt;=1);
 6528   match(Set mem (StoreF mem src));
 6529   ins_cost(95);
 6530   format %{ &quot;MOVSS  $mem,$src&quot; %}
 6531   ins_encode %{
 6532     __ movflt($mem$$Address, $src$$XMMRegister);
 6533   %}
 6534   ins_pipe( pipe_slow );
 6535 %}
 6536 
 6537 // Load Float
 6538 instruct MoveF2VL(vlRegF dst, regF src) %{
 6539   match(Set dst src);
 6540   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 6541   ins_encode %{
 6542     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 6543   %}
 6544   ins_pipe( fpu_reg_reg );
 6545 %}
 6546 
 6547 // Load Float
 6548 instruct MoveVL2F(regF dst, vlRegF src) %{
 6549   match(Set dst src);
 6550   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 6551   ins_encode %{
 6552     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 6553   %}
 6554   ins_pipe( fpu_reg_reg );
 6555 %}
 6556 
 6557 // Store Float
 6558 instruct storeFPR( memory mem, regFPR1 src) %{
 6559   predicate(UseSSE==0);
 6560   match(Set mem (StoreF mem src));
 6561 
 6562   ins_cost(100);
 6563   format %{ &quot;FST_S  $mem,$src&quot; %}
 6564   opcode(0xD9);       /* D9 /2 */
 6565   ins_encode( enc_FPR_store(mem,src) );
 6566   ins_pipe( fpu_mem_reg );
 6567 %}
 6568 
 6569 // Store Float does rounding on x86
 6570 instruct storeFPR_rounded( memory mem, regFPR1 src) %{
 6571   predicate(UseSSE==0);
 6572   match(Set mem (StoreF mem (RoundFloat src)));
 6573 
 6574   ins_cost(100);
 6575   format %{ &quot;FST_S  $mem,$src\t# round&quot; %}
 6576   opcode(0xD9);       /* D9 /2 */
 6577   ins_encode( enc_FPR_store(mem,src) );
 6578   ins_pipe( fpu_mem_reg );
 6579 %}
 6580 
 6581 // Store Float does rounding on x86
 6582 instruct storeFPR_Drounded( memory mem, regDPR1 src) %{
 6583   predicate(UseSSE&lt;=1);
 6584   match(Set mem (StoreF mem (ConvD2F src)));
 6585 
 6586   ins_cost(100);
 6587   format %{ &quot;FST_S  $mem,$src\t# D-round&quot; %}
 6588   opcode(0xD9);       /* D9 /2 */
 6589   ins_encode( enc_FPR_store(mem,src) );
 6590   ins_pipe( fpu_mem_reg );
 6591 %}
 6592 
 6593 // Store immediate Float value (it is faster than store from FPU register)
 6594 // The instruction usage is guarded by predicate in operand immFPR().
 6595 instruct storeFPR_imm( memory mem, immFPR src) %{
 6596   match(Set mem (StoreF mem src));
 6597 
 6598   ins_cost(50);
 6599   format %{ &quot;MOV    $mem,$src\t# store float&quot; %}
 6600   opcode(0xC7);               /* C7 /0 */
 6601   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32FPR_as_bits( src ));
 6602   ins_pipe( ialu_mem_imm );
 6603 %}
 6604 
 6605 // Store immediate Float value (it is faster than store from XMM register)
 6606 // The instruction usage is guarded by predicate in operand immF().
 6607 instruct storeF_imm( memory mem, immF src) %{
 6608   match(Set mem (StoreF mem src));
 6609 
 6610   ins_cost(50);
 6611   format %{ &quot;MOV    $mem,$src\t# store float&quot; %}
 6612   opcode(0xC7);               /* C7 /0 */
 6613   ins_encode( OpcP, RMopc_Mem(0x00,mem),  Con32F_as_bits( src ));
 6614   ins_pipe( ialu_mem_imm );
 6615 %}
 6616 
 6617 // Store Integer to stack slot
 6618 instruct storeSSI(stackSlotI dst, rRegI src) %{
 6619   match(Set dst src);
 6620 
 6621   ins_cost(100);
 6622   format %{ &quot;MOV    $dst,$src&quot; %}
 6623   opcode(0x89);
 6624   ins_encode( OpcPRegSS( dst, src ) );
 6625   ins_pipe( ialu_mem_reg );
 6626 %}
 6627 
 6628 // Store Integer to stack slot
 6629 instruct storeSSP(stackSlotP dst, eRegP src) %{
 6630   match(Set dst src);
 6631 
 6632   ins_cost(100);
 6633   format %{ &quot;MOV    $dst,$src&quot; %}
 6634   opcode(0x89);
 6635   ins_encode( OpcPRegSS( dst, src ) );
 6636   ins_pipe( ialu_mem_reg );
 6637 %}
 6638 
 6639 // Store Long to stack slot
 6640 instruct storeSSL(stackSlotL dst, eRegL src) %{
 6641   match(Set dst src);
 6642 
 6643   ins_cost(200);
 6644   format %{ &quot;MOV    $dst,$src.lo\n\t&quot;
 6645             &quot;MOV    $dst+4,$src.hi&quot; %}
 6646   opcode(0x89, 0x89);
 6647   ins_encode( OpcP, RegMem( src, dst ), OpcS, RegMem_Hi( src, dst ) );
 6648   ins_pipe( ialu_mem_long_reg );
 6649 %}
 6650 
 6651 //----------MemBar Instructions-----------------------------------------------
 6652 // Memory barrier flavors
 6653 
 6654 instruct membar_acquire() %{
 6655   match(MemBarAcquire);
 6656   match(LoadFence);
 6657   ins_cost(400);
 6658 
 6659   size(0);
 6660   format %{ &quot;MEMBAR-acquire ! (empty encoding)&quot; %}
 6661   ins_encode();
 6662   ins_pipe(empty);
 6663 %}
 6664 
 6665 instruct membar_acquire_lock() %{
 6666   match(MemBarAcquireLock);
 6667   ins_cost(0);
 6668 
 6669   size(0);
 6670   format %{ &quot;MEMBAR-acquire (prior CMPXCHG in FastLock so empty encoding)&quot; %}
 6671   ins_encode( );
 6672   ins_pipe(empty);
 6673 %}
 6674 
 6675 instruct membar_release() %{
 6676   match(MemBarRelease);
 6677   match(StoreFence);
 6678   ins_cost(400);
 6679 
 6680   size(0);
 6681   format %{ &quot;MEMBAR-release ! (empty encoding)&quot; %}
 6682   ins_encode( );
 6683   ins_pipe(empty);
 6684 %}
 6685 
 6686 instruct membar_release_lock() %{
 6687   match(MemBarReleaseLock);
 6688   ins_cost(0);
 6689 
 6690   size(0);
 6691   format %{ &quot;MEMBAR-release (a FastUnlock follows so empty encoding)&quot; %}
 6692   ins_encode( );
 6693   ins_pipe(empty);
 6694 %}
 6695 
 6696 instruct membar_volatile(eFlagsReg cr) %{
 6697   match(MemBarVolatile);
 6698   effect(KILL cr);
 6699   ins_cost(400);
 6700 
 6701   format %{
 6702     $$template
 6703     $$emit$$&quot;LOCK ADDL [ESP + #0], 0\t! membar_volatile&quot;
 6704   %}
 6705   ins_encode %{
 6706     __ membar(Assembler::StoreLoad);
 6707   %}
 6708   ins_pipe(pipe_slow);
 6709 %}
 6710 
 6711 instruct unnecessary_membar_volatile() %{
 6712   match(MemBarVolatile);
 6713   predicate(Matcher::post_store_load_barrier(n));
 6714   ins_cost(0);
 6715 
 6716   size(0);
 6717   format %{ &quot;MEMBAR-volatile (unnecessary so empty encoding)&quot; %}
 6718   ins_encode( );
 6719   ins_pipe(empty);
 6720 %}
 6721 
 6722 instruct membar_storestore() %{
 6723   match(MemBarStoreStore);
 6724   ins_cost(0);
 6725 
 6726   size(0);
 6727   format %{ &quot;MEMBAR-storestore (empty encoding)&quot; %}
 6728   ins_encode( );
 6729   ins_pipe(empty);
 6730 %}
 6731 
 6732 //----------Move Instructions--------------------------------------------------
 6733 instruct castX2P(eAXRegP dst, eAXRegI src) %{
 6734   match(Set dst (CastX2P src));
 6735   format %{ &quot;# X2P  $dst, $src&quot; %}
 6736   ins_encode( /*empty encoding*/ );
 6737   ins_cost(0);
 6738   ins_pipe(empty);
 6739 %}
 6740 
 6741 instruct castP2X(rRegI dst, eRegP src ) %{
 6742   match(Set dst (CastP2X src));
 6743   ins_cost(50);
 6744   format %{ &quot;MOV    $dst, $src\t# CastP2X&quot; %}
 6745   ins_encode( enc_Copy( dst, src) );
 6746   ins_pipe( ialu_reg_reg );
 6747 %}
 6748 
 6749 //----------Conditional Move---------------------------------------------------
 6750 // Conditional move
 6751 instruct jmovI_reg(cmpOp cop, eFlagsReg cr, rRegI dst, rRegI src) %{
 6752   predicate(!VM_Version::supports_cmov() );
 6753   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6754   ins_cost(200);
 6755   format %{ &quot;J$cop,us skip\t# signed cmove\n\t&quot;
 6756             &quot;MOV    $dst,$src\n&quot;
 6757       &quot;skip:&quot; %}
 6758   ins_encode %{
 6759     Label Lskip;
 6760     // Invert sense of branch from sense of CMOV
 6761     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 6762     __ movl($dst$$Register, $src$$Register);
 6763     __ bind(Lskip);
 6764   %}
 6765   ins_pipe( pipe_cmov_reg );
 6766 %}
 6767 
 6768 instruct jmovI_regU(cmpOpU cop, eFlagsRegU cr, rRegI dst, rRegI src) %{
 6769   predicate(!VM_Version::supports_cmov() );
 6770   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6771   ins_cost(200);
 6772   format %{ &quot;J$cop,us skip\t# unsigned cmove\n\t&quot;
 6773             &quot;MOV    $dst,$src\n&quot;
 6774       &quot;skip:&quot; %}
 6775   ins_encode %{
 6776     Label Lskip;
 6777     // Invert sense of branch from sense of CMOV
 6778     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 6779     __ movl($dst$$Register, $src$$Register);
 6780     __ bind(Lskip);
 6781   %}
 6782   ins_pipe( pipe_cmov_reg );
 6783 %}
 6784 
 6785 instruct cmovI_reg(rRegI dst, rRegI src, eFlagsReg cr, cmpOp cop ) %{
 6786   predicate(VM_Version::supports_cmov() );
 6787   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6788   ins_cost(200);
 6789   format %{ &quot;CMOV$cop $dst,$src&quot; %}
 6790   opcode(0x0F,0x40);
 6791   ins_encode( enc_cmov(cop), RegReg( dst, src ) );
 6792   ins_pipe( pipe_cmov_reg );
 6793 %}
 6794 
 6795 instruct cmovI_regU( cmpOpU cop, eFlagsRegU cr, rRegI dst, rRegI src ) %{
 6796   predicate(VM_Version::supports_cmov() );
 6797   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6798   ins_cost(200);
 6799   format %{ &quot;CMOV$cop $dst,$src&quot; %}
 6800   opcode(0x0F,0x40);
 6801   ins_encode( enc_cmov(cop), RegReg( dst, src ) );
 6802   ins_pipe( pipe_cmov_reg );
 6803 %}
 6804 
 6805 instruct cmovI_regUCF( cmpOpUCF cop, eFlagsRegUCF cr, rRegI dst, rRegI src ) %{
 6806   predicate(VM_Version::supports_cmov() );
 6807   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6808   ins_cost(200);
 6809   expand %{
 6810     cmovI_regU(cop, cr, dst, src);
 6811   %}
 6812 %}
 6813 
 6814 // Conditional move
 6815 instruct cmovI_mem(cmpOp cop, eFlagsReg cr, rRegI dst, memory src) %{
 6816   predicate(VM_Version::supports_cmov() );
 6817   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6818   ins_cost(250);
 6819   format %{ &quot;CMOV$cop $dst,$src&quot; %}
 6820   opcode(0x0F,0x40);
 6821   ins_encode( enc_cmov(cop), RegMem( dst, src ) );
 6822   ins_pipe( pipe_cmov_mem );
 6823 %}
 6824 
 6825 // Conditional move
 6826 instruct cmovI_memU(cmpOpU cop, eFlagsRegU cr, rRegI dst, memory src) %{
 6827   predicate(VM_Version::supports_cmov() );
 6828   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6829   ins_cost(250);
 6830   format %{ &quot;CMOV$cop $dst,$src&quot; %}
 6831   opcode(0x0F,0x40);
 6832   ins_encode( enc_cmov(cop), RegMem( dst, src ) );
 6833   ins_pipe( pipe_cmov_mem );
 6834 %}
 6835 
 6836 instruct cmovI_memUCF(cmpOpUCF cop, eFlagsRegUCF cr, rRegI dst, memory src) %{
 6837   predicate(VM_Version::supports_cmov() );
 6838   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6839   ins_cost(250);
 6840   expand %{
 6841     cmovI_memU(cop, cr, dst, src);
 6842   %}
 6843 %}
 6844 
 6845 // Conditional move
 6846 instruct cmovP_reg(eRegP dst, eRegP src, eFlagsReg cr, cmpOp cop ) %{
 6847   predicate(VM_Version::supports_cmov() );
 6848   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6849   ins_cost(200);
 6850   format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 6851   opcode(0x0F,0x40);
 6852   ins_encode( enc_cmov(cop), RegReg( dst, src ) );
 6853   ins_pipe( pipe_cmov_reg );
 6854 %}
 6855 
 6856 // Conditional move (non-P6 version)
 6857 // Note:  a CMoveP is generated for  stubs and native wrappers
 6858 //        regardless of whether we are on a P6, so we
 6859 //        emulate a cmov here
 6860 instruct cmovP_reg_nonP6(eRegP dst, eRegP src, eFlagsReg cr, cmpOp cop ) %{
 6861   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6862   ins_cost(300);
 6863   format %{ &quot;Jn$cop   skip\n\t&quot;
 6864           &quot;MOV    $dst,$src\t# pointer\n&quot;
 6865       &quot;skip:&quot; %}
 6866   opcode(0x8b);
 6867   ins_encode( enc_cmov_branch(cop, 0x2), OpcP, RegReg(dst, src));
 6868   ins_pipe( pipe_cmov_reg );
 6869 %}
 6870 
 6871 // Conditional move
 6872 instruct cmovP_regU(cmpOpU cop, eFlagsRegU cr, eRegP dst, eRegP src ) %{
 6873   predicate(VM_Version::supports_cmov() );
 6874   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6875   ins_cost(200);
 6876   format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 6877   opcode(0x0F,0x40);
 6878   ins_encode( enc_cmov(cop), RegReg( dst, src ) );
 6879   ins_pipe( pipe_cmov_reg );
 6880 %}
 6881 
 6882 instruct cmovP_regUCF(cmpOpUCF cop, eFlagsRegUCF cr, eRegP dst, eRegP src ) %{
 6883   predicate(VM_Version::supports_cmov() );
 6884   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6885   ins_cost(200);
 6886   expand %{
 6887     cmovP_regU(cop, cr, dst, src);
 6888   %}
 6889 %}
 6890 
 6891 // DISABLED: Requires the ADLC to emit a bottom_type call that
 6892 // correctly meets the two pointer arguments; one is an incoming
 6893 // register but the other is a memory operand.  ALSO appears to
 6894 // be buggy with implicit null checks.
 6895 //
 6896 //// Conditional move
 6897 //instruct cmovP_mem(cmpOp cop, eFlagsReg cr, eRegP dst, memory src) %{
 6898 //  predicate(VM_Version::supports_cmov() );
 6899 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 6900 //  ins_cost(250);
 6901 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 6902 //  opcode(0x0F,0x40);
 6903 //  ins_encode( enc_cmov(cop), RegMem( dst, src ) );
 6904 //  ins_pipe( pipe_cmov_mem );
 6905 //%}
 6906 //
 6907 //// Conditional move
 6908 //instruct cmovP_memU(cmpOpU cop, eFlagsRegU cr, eRegP dst, memory src) %{
 6909 //  predicate(VM_Version::supports_cmov() );
 6910 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 6911 //  ins_cost(250);
 6912 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 6913 //  opcode(0x0F,0x40);
 6914 //  ins_encode( enc_cmov(cop), RegMem( dst, src ) );
 6915 //  ins_pipe( pipe_cmov_mem );
 6916 //%}
 6917 
 6918 // Conditional move
 6919 instruct fcmovDPR_regU(cmpOp_fcmov cop, eFlagsRegU cr, regDPR1 dst, regDPR src) %{
 6920   predicate(UseSSE&lt;=1);
 6921   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 6922   ins_cost(200);
 6923   format %{ &quot;FCMOV$cop $dst,$src\t# double&quot; %}
 6924   opcode(0xDA);
 6925   ins_encode( enc_cmov_dpr(cop,src) );
 6926   ins_pipe( pipe_cmovDPR_reg );
 6927 %}
 6928 
 6929 // Conditional move
 6930 instruct fcmovFPR_regU(cmpOp_fcmov cop, eFlagsRegU cr, regFPR1 dst, regFPR src) %{
 6931   predicate(UseSSE==0);
 6932   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 6933   ins_cost(200);
 6934   format %{ &quot;FCMOV$cop $dst,$src\t# float&quot; %}
 6935   opcode(0xDA);
 6936   ins_encode( enc_cmov_dpr(cop,src) );
 6937   ins_pipe( pipe_cmovDPR_reg );
 6938 %}
 6939 
 6940 // Float CMOV on Intel doesn&#39;t handle *signed* compares, only unsigned.
 6941 instruct fcmovDPR_regS(cmpOp cop, eFlagsReg cr, regDPR dst, regDPR src) %{
 6942   predicate(UseSSE&lt;=1);
 6943   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 6944   ins_cost(200);
 6945   format %{ &quot;Jn$cop   skip\n\t&quot;
 6946             &quot;MOV    $dst,$src\t# double\n&quot;
 6947       &quot;skip:&quot; %}
 6948   opcode (0xdd, 0x3);     /* DD D8+i or DD /3 */
 6949   ins_encode( enc_cmov_branch( cop, 0x4 ), Push_Reg_DPR(src), OpcP, RegOpc(dst) );
 6950   ins_pipe( pipe_cmovDPR_reg );
 6951 %}
 6952 
 6953 // Float CMOV on Intel doesn&#39;t handle *signed* compares, only unsigned.
 6954 instruct fcmovFPR_regS(cmpOp cop, eFlagsReg cr, regFPR dst, regFPR src) %{
 6955   predicate(UseSSE==0);
 6956   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 6957   ins_cost(200);
 6958   format %{ &quot;Jn$cop    skip\n\t&quot;
 6959             &quot;MOV    $dst,$src\t# float\n&quot;
 6960       &quot;skip:&quot; %}
 6961   opcode (0xdd, 0x3);     /* DD D8+i or DD /3 */
 6962   ins_encode( enc_cmov_branch( cop, 0x4 ), Push_Reg_FPR(src), OpcP, RegOpc(dst) );
 6963   ins_pipe( pipe_cmovDPR_reg );
 6964 %}
 6965 
 6966 // No CMOVE with SSE/SSE2
 6967 instruct fcmovF_regS(cmpOp cop, eFlagsReg cr, regF dst, regF src) %{
 6968   predicate (UseSSE&gt;=1);
 6969   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 6970   ins_cost(200);
 6971   format %{ &quot;Jn$cop   skip\n\t&quot;
 6972             &quot;MOVSS  $dst,$src\t# float\n&quot;
 6973       &quot;skip:&quot; %}
 6974   ins_encode %{
 6975     Label skip;
 6976     // Invert sense of branch from sense of CMOV
 6977     __ jccb((Assembler::Condition)($cop$$cmpcode^1), skip);
 6978     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 6979     __ bind(skip);
 6980   %}
 6981   ins_pipe( pipe_slow );
 6982 %}
 6983 
 6984 // No CMOVE with SSE/SSE2
 6985 instruct fcmovD_regS(cmpOp cop, eFlagsReg cr, regD dst, regD src) %{
 6986   predicate (UseSSE&gt;=2);
 6987   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 6988   ins_cost(200);
 6989   format %{ &quot;Jn$cop   skip\n\t&quot;
 6990             &quot;MOVSD  $dst,$src\t# float\n&quot;
 6991       &quot;skip:&quot; %}
 6992   ins_encode %{
 6993     Label skip;
 6994     // Invert sense of branch from sense of CMOV
 6995     __ jccb((Assembler::Condition)($cop$$cmpcode^1), skip);
 6996     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 6997     __ bind(skip);
 6998   %}
 6999   ins_pipe( pipe_slow );
 7000 %}
 7001 
 7002 // unsigned version
 7003 instruct fcmovF_regU(cmpOpU cop, eFlagsRegU cr, regF dst, regF src) %{
 7004   predicate (UseSSE&gt;=1);
 7005   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7006   ins_cost(200);
 7007   format %{ &quot;Jn$cop   skip\n\t&quot;
 7008             &quot;MOVSS  $dst,$src\t# float\n&quot;
 7009       &quot;skip:&quot; %}
 7010   ins_encode %{
 7011     Label skip;
 7012     // Invert sense of branch from sense of CMOV
 7013     __ jccb((Assembler::Condition)($cop$$cmpcode^1), skip);
 7014     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 7015     __ bind(skip);
 7016   %}
 7017   ins_pipe( pipe_slow );
 7018 %}
 7019 
 7020 instruct fcmovF_regUCF(cmpOpUCF cop, eFlagsRegUCF cr, regF dst, regF src) %{
 7021   predicate (UseSSE&gt;=1);
 7022   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7023   ins_cost(200);
 7024   expand %{
 7025     fcmovF_regU(cop, cr, dst, src);
 7026   %}
 7027 %}
 7028 
 7029 // unsigned version
 7030 instruct fcmovD_regU(cmpOpU cop, eFlagsRegU cr, regD dst, regD src) %{
 7031   predicate (UseSSE&gt;=2);
 7032   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7033   ins_cost(200);
 7034   format %{ &quot;Jn$cop   skip\n\t&quot;
 7035             &quot;MOVSD  $dst,$src\t# float\n&quot;
 7036       &quot;skip:&quot; %}
 7037   ins_encode %{
 7038     Label skip;
 7039     // Invert sense of branch from sense of CMOV
 7040     __ jccb((Assembler::Condition)($cop$$cmpcode^1), skip);
 7041     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 7042     __ bind(skip);
 7043   %}
 7044   ins_pipe( pipe_slow );
 7045 %}
 7046 
 7047 instruct fcmovD_regUCF(cmpOpUCF cop, eFlagsRegUCF cr, regD dst, regD src) %{
 7048   predicate (UseSSE&gt;=2);
 7049   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7050   ins_cost(200);
 7051   expand %{
 7052     fcmovD_regU(cop, cr, dst, src);
 7053   %}
 7054 %}
 7055 
 7056 instruct cmovL_reg(cmpOp cop, eFlagsReg cr, eRegL dst, eRegL src) %{
 7057   predicate(VM_Version::supports_cmov() );
 7058   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7059   ins_cost(200);
 7060   format %{ &quot;CMOV$cop $dst.lo,$src.lo\n\t&quot;
 7061             &quot;CMOV$cop $dst.hi,$src.hi&quot; %}
 7062   opcode(0x0F,0x40);
 7063   ins_encode( enc_cmov(cop), RegReg_Lo2( dst, src ), enc_cmov(cop), RegReg_Hi2( dst, src ) );
 7064   ins_pipe( pipe_cmov_reg_long );
 7065 %}
 7066 
 7067 instruct cmovL_regU(cmpOpU cop, eFlagsRegU cr, eRegL dst, eRegL src) %{
 7068   predicate(VM_Version::supports_cmov() );
 7069   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7070   ins_cost(200);
 7071   format %{ &quot;CMOV$cop $dst.lo,$src.lo\n\t&quot;
 7072             &quot;CMOV$cop $dst.hi,$src.hi&quot; %}
 7073   opcode(0x0F,0x40);
 7074   ins_encode( enc_cmov(cop), RegReg_Lo2( dst, src ), enc_cmov(cop), RegReg_Hi2( dst, src ) );
 7075   ins_pipe( pipe_cmov_reg_long );
 7076 %}
 7077 
 7078 instruct cmovL_regUCF(cmpOpUCF cop, eFlagsRegUCF cr, eRegL dst, eRegL src) %{
 7079   predicate(VM_Version::supports_cmov() );
 7080   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7081   ins_cost(200);
 7082   expand %{
 7083     cmovL_regU(cop, cr, dst, src);
 7084   %}
 7085 %}
 7086 
 7087 //----------Arithmetic Instructions--------------------------------------------
 7088 //----------Addition Instructions----------------------------------------------
 7089 
 7090 // Integer Addition Instructions
 7091 instruct addI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 7092   match(Set dst (AddI dst src));
 7093   effect(KILL cr);
 7094 
 7095   size(2);
 7096   format %{ &quot;ADD    $dst,$src&quot; %}
 7097   opcode(0x03);
 7098   ins_encode( OpcP, RegReg( dst, src) );
 7099   ins_pipe( ialu_reg_reg );
 7100 %}
 7101 
 7102 instruct addI_eReg_imm(rRegI dst, immI src, eFlagsReg cr) %{
 7103   match(Set dst (AddI dst src));
 7104   effect(KILL cr);
 7105 
 7106   format %{ &quot;ADD    $dst,$src&quot; %}
 7107   opcode(0x81, 0x00); /* /0 id */
 7108   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 7109   ins_pipe( ialu_reg );
 7110 %}
 7111 
 7112 instruct incI_eReg(rRegI dst, immI1 src, eFlagsReg cr) %{
 7113   predicate(UseIncDec);
 7114   match(Set dst (AddI dst src));
 7115   effect(KILL cr);
 7116 
 7117   size(1);
 7118   format %{ &quot;INC    $dst&quot; %}
 7119   opcode(0x40); /*  */
 7120   ins_encode( Opc_plus( primary, dst ) );
 7121   ins_pipe( ialu_reg );
 7122 %}
 7123 
 7124 instruct leaI_eReg_immI(rRegI dst, rRegI src0, immI src1) %{
 7125   match(Set dst (AddI src0 src1));
 7126   ins_cost(110);
 7127 
 7128   format %{ &quot;LEA    $dst,[$src0 + $src1]&quot; %}
 7129   opcode(0x8D); /* 0x8D /r */
 7130   ins_encode( OpcP, RegLea( dst, src0, src1 ) );
 7131   ins_pipe( ialu_reg_reg );
 7132 %}
 7133 
 7134 instruct leaP_eReg_immI(eRegP dst, eRegP src0, immI src1) %{
 7135   match(Set dst (AddP src0 src1));
 7136   ins_cost(110);
 7137 
 7138   format %{ &quot;LEA    $dst,[$src0 + $src1]\t# ptr&quot; %}
 7139   opcode(0x8D); /* 0x8D /r */
 7140   ins_encode( OpcP, RegLea( dst, src0, src1 ) );
 7141   ins_pipe( ialu_reg_reg );
 7142 %}
 7143 
 7144 instruct decI_eReg(rRegI dst, immI_M1 src, eFlagsReg cr) %{
 7145   predicate(UseIncDec);
 7146   match(Set dst (AddI dst src));
 7147   effect(KILL cr);
 7148 
 7149   size(1);
 7150   format %{ &quot;DEC    $dst&quot; %}
 7151   opcode(0x48); /*  */
 7152   ins_encode( Opc_plus( primary, dst ) );
 7153   ins_pipe( ialu_reg );
 7154 %}
 7155 
 7156 instruct addP_eReg(eRegP dst, rRegI src, eFlagsReg cr) %{
 7157   match(Set dst (AddP dst src));
 7158   effect(KILL cr);
 7159 
 7160   size(2);
 7161   format %{ &quot;ADD    $dst,$src&quot; %}
 7162   opcode(0x03);
 7163   ins_encode( OpcP, RegReg( dst, src) );
 7164   ins_pipe( ialu_reg_reg );
 7165 %}
 7166 
 7167 instruct addP_eReg_imm(eRegP dst, immI src, eFlagsReg cr) %{
 7168   match(Set dst (AddP dst src));
 7169   effect(KILL cr);
 7170 
 7171   format %{ &quot;ADD    $dst,$src&quot; %}
 7172   opcode(0x81,0x00); /* Opcode 81 /0 id */
 7173   // ins_encode( RegImm( dst, src) );
 7174   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 7175   ins_pipe( ialu_reg );
 7176 %}
 7177 
 7178 instruct addI_eReg_mem(rRegI dst, memory src, eFlagsReg cr) %{
 7179   match(Set dst (AddI dst (LoadI src)));
 7180   effect(KILL cr);
 7181 
 7182   ins_cost(125);
 7183   format %{ &quot;ADD    $dst,$src&quot; %}
 7184   opcode(0x03);
 7185   ins_encode( OpcP, RegMem( dst, src) );
 7186   ins_pipe( ialu_reg_mem );
 7187 %}
 7188 
 7189 instruct addI_mem_eReg(memory dst, rRegI src, eFlagsReg cr) %{
 7190   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7191   effect(KILL cr);
 7192 
 7193   ins_cost(150);
 7194   format %{ &quot;ADD    $dst,$src&quot; %}
 7195   opcode(0x01);  /* Opcode 01 /r */
 7196   ins_encode( OpcP, RegMem( src, dst ) );
 7197   ins_pipe( ialu_mem_reg );
 7198 %}
 7199 
 7200 // Add Memory with Immediate
 7201 instruct addI_mem_imm(memory dst, immI src, eFlagsReg cr) %{
 7202   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7203   effect(KILL cr);
 7204 
 7205   ins_cost(125);
 7206   format %{ &quot;ADD    $dst,$src&quot; %}
 7207   opcode(0x81);               /* Opcode 81 /0 id */
 7208   ins_encode( OpcSE( src ), RMopc_Mem(0x00,dst), Con8or32( src ) );
 7209   ins_pipe( ialu_mem_imm );
 7210 %}
 7211 
 7212 instruct incI_mem(memory dst, immI1 src, eFlagsReg cr) %{
 7213   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7214   effect(KILL cr);
 7215 
 7216   ins_cost(125);
 7217   format %{ &quot;INC    $dst&quot; %}
 7218   opcode(0xFF);               /* Opcode FF /0 */
 7219   ins_encode( OpcP, RMopc_Mem(0x00,dst));
 7220   ins_pipe( ialu_mem_imm );
 7221 %}
 7222 
 7223 instruct decI_mem(memory dst, immI_M1 src, eFlagsReg cr) %{
 7224   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7225   effect(KILL cr);
 7226 
 7227   ins_cost(125);
 7228   format %{ &quot;DEC    $dst&quot; %}
 7229   opcode(0xFF);               /* Opcode FF /1 */
 7230   ins_encode( OpcP, RMopc_Mem(0x01,dst));
 7231   ins_pipe( ialu_mem_imm );
 7232 %}
 7233 
 7234 
 7235 instruct checkCastPP( eRegP dst ) %{
 7236   match(Set dst (CheckCastPP dst));
 7237 
 7238   size(0);
 7239   format %{ &quot;#checkcastPP of $dst&quot; %}
 7240   ins_encode( /*empty encoding*/ );
 7241   ins_pipe( empty );
 7242 %}
 7243 
 7244 instruct castPP( eRegP dst ) %{
 7245   match(Set dst (CastPP dst));
 7246   format %{ &quot;#castPP of $dst&quot; %}
 7247   ins_encode( /*empty encoding*/ );
 7248   ins_pipe( empty );
 7249 %}
 7250 
 7251 instruct castII( rRegI dst ) %{
 7252   match(Set dst (CastII dst));
 7253   format %{ &quot;#castII of $dst&quot; %}
 7254   ins_encode( /*empty encoding*/ );
 7255   ins_cost(0);
 7256   ins_pipe( empty );
 7257 %}
 7258 
 7259 instruct castLL( eRegL dst ) %{
 7260   match(Set dst (CastLL dst));
 7261   format %{ &quot;#castLL of $dst&quot; %}
 7262   ins_encode( /*empty encoding*/ );
 7263   ins_cost(0);
 7264   ins_pipe( empty );
 7265 %}
 7266 
 7267 
 7268 // Load-locked - same as a regular pointer load when used with compare-swap
 7269 instruct loadPLocked(eRegP dst, memory mem) %{
 7270   match(Set dst (LoadPLocked mem));
 7271 
 7272   ins_cost(125);
 7273   format %{ &quot;MOV    $dst,$mem\t# Load ptr. locked&quot; %}
 7274   opcode(0x8B);
 7275   ins_encode( OpcP, RegMem(dst,mem));
 7276   ins_pipe( ialu_reg_mem );
 7277 %}
 7278 
 7279 // Conditional-store of the updated heap-top.
 7280 // Used during allocation of the shared heap.
 7281 // Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.
 7282 instruct storePConditional( memory heap_top_ptr, eAXRegP oldval, eRegP newval, eFlagsReg cr ) %{
 7283   match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));
 7284   // EAX is killed if there is contention, but then it&#39;s also unused.
 7285   // In the common case of no contention, EAX holds the new oop address.
 7286   format %{ &quot;CMPXCHG $heap_top_ptr,$newval\t# If EAX==$heap_top_ptr Then store $newval into $heap_top_ptr&quot; %}
 7287   ins_encode( lock_prefix, Opcode(0x0F), Opcode(0xB1), RegMem(newval,heap_top_ptr) );
 7288   ins_pipe( pipe_cmpxchg );
 7289 %}
 7290 
 7291 // Conditional-store of an int value.
 7292 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG on Intel.
 7293 instruct storeIConditional( memory mem, eAXRegI oldval, rRegI newval, eFlagsReg cr ) %{
 7294   match(Set cr (StoreIConditional mem (Binary oldval newval)));
 7295   effect(KILL oldval);
 7296   format %{ &quot;CMPXCHG $mem,$newval\t# If EAX==$mem Then store $newval into $mem&quot; %}
 7297   ins_encode( lock_prefix, Opcode(0x0F), Opcode(0xB1), RegMem(newval, mem) );
 7298   ins_pipe( pipe_cmpxchg );
 7299 %}
 7300 
 7301 // Conditional-store of a long value.
 7302 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG8 on Intel.
 7303 instruct storeLConditional( memory mem, eADXRegL oldval, eBCXRegL newval, eFlagsReg cr ) %{
 7304   match(Set cr (StoreLConditional mem (Binary oldval newval)));
 7305   effect(KILL oldval);
 7306   format %{ &quot;XCHG   EBX,ECX\t# correct order for CMPXCHG8 instruction\n\t&quot;
 7307             &quot;CMPXCHG8 $mem,ECX:EBX\t# If EDX:EAX==$mem Then store ECX:EBX into $mem\n\t&quot;
 7308             &quot;XCHG   EBX,ECX&quot;
 7309   %}
 7310   ins_encode %{
 7311     // Note: we need to swap rbx, and rcx before and after the
 7312     //       cmpxchg8 instruction because the instruction uses
 7313     //       rcx as the high order word of the new value to store but
 7314     //       our register encoding uses rbx.
 7315     __ xchgl(as_Register(EBX_enc), as_Register(ECX_enc));
 7316     __ lock();
 7317     __ cmpxchg8($mem$$Address);
 7318     __ xchgl(as_Register(EBX_enc), as_Register(ECX_enc));
 7319   %}
 7320   ins_pipe( pipe_cmpxchg );
 7321 %}
 7322 
 7323 // No flag versions for CompareAndSwap{P,I,L} because matcher can&#39;t match them
 7324 
 7325 instruct compareAndSwapL( rRegI res, eSIRegP mem_ptr, eADXRegL oldval, eBCXRegL newval, eFlagsReg cr ) %{
 7326   predicate(VM_Version::supports_cx8());
 7327   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
 7328   match(Set res (WeakCompareAndSwapL mem_ptr (Binary oldval newval)));
 7329   effect(KILL cr, KILL oldval);
 7330   format %{ &quot;CMPXCHG8 [$mem_ptr],$newval\t# If EDX:EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot;
 7331             &quot;MOV    $res,0\n\t&quot;
 7332             &quot;JNE,s  fail\n\t&quot;
 7333             &quot;MOV    $res,1\n&quot;
 7334           &quot;fail:&quot; %}
 7335   ins_encode( enc_cmpxchg8(mem_ptr),
 7336               enc_flags_ne_to_boolean(res) );
 7337   ins_pipe( pipe_cmpxchg );
 7338 %}
 7339 
 7340 instruct compareAndSwapP( rRegI res,  pRegP mem_ptr, eAXRegP oldval, eCXRegP newval, eFlagsReg cr) %{
 7341   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
 7342   match(Set res (WeakCompareAndSwapP mem_ptr (Binary oldval newval)));
 7343   effect(KILL cr, KILL oldval);
 7344   format %{ &quot;CMPXCHG [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot;
 7345             &quot;MOV    $res,0\n\t&quot;
 7346             &quot;JNE,s  fail\n\t&quot;
 7347             &quot;MOV    $res,1\n&quot;
 7348           &quot;fail:&quot; %}
 7349   ins_encode( enc_cmpxchg(mem_ptr), enc_flags_ne_to_boolean(res) );
 7350   ins_pipe( pipe_cmpxchg );
 7351 %}
 7352 
 7353 instruct compareAndSwapB( rRegI res, pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr ) %{
 7354   match(Set res (CompareAndSwapB mem_ptr (Binary oldval newval)));
 7355   match(Set res (WeakCompareAndSwapB mem_ptr (Binary oldval newval)));
 7356   effect(KILL cr, KILL oldval);
 7357   format %{ &quot;CMPXCHGB [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot;
 7358             &quot;MOV    $res,0\n\t&quot;
 7359             &quot;JNE,s  fail\n\t&quot;
 7360             &quot;MOV    $res,1\n&quot;
 7361           &quot;fail:&quot; %}
 7362   ins_encode( enc_cmpxchgb(mem_ptr),
 7363               enc_flags_ne_to_boolean(res) );
 7364   ins_pipe( pipe_cmpxchg );
 7365 %}
 7366 
 7367 instruct compareAndSwapS( rRegI res, pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr ) %{
 7368   match(Set res (CompareAndSwapS mem_ptr (Binary oldval newval)));
 7369   match(Set res (WeakCompareAndSwapS mem_ptr (Binary oldval newval)));
 7370   effect(KILL cr, KILL oldval);
 7371   format %{ &quot;CMPXCHGW [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot;
 7372             &quot;MOV    $res,0\n\t&quot;
 7373             &quot;JNE,s  fail\n\t&quot;
 7374             &quot;MOV    $res,1\n&quot;
 7375           &quot;fail:&quot; %}
 7376   ins_encode( enc_cmpxchgw(mem_ptr),
 7377               enc_flags_ne_to_boolean(res) );
 7378   ins_pipe( pipe_cmpxchg );
 7379 %}
 7380 
 7381 instruct compareAndSwapI( rRegI res, pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr) %{
 7382   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
 7383   match(Set res (WeakCompareAndSwapI mem_ptr (Binary oldval newval)));
 7384   effect(KILL cr, KILL oldval);
 7385   format %{ &quot;CMPXCHG [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot;
 7386             &quot;MOV    $res,0\n\t&quot;
 7387             &quot;JNE,s  fail\n\t&quot;
 7388             &quot;MOV    $res,1\n&quot;
 7389           &quot;fail:&quot; %}
 7390   ins_encode( enc_cmpxchg(mem_ptr), enc_flags_ne_to_boolean(res) );
 7391   ins_pipe( pipe_cmpxchg );
 7392 %}
 7393 
 7394 instruct compareAndExchangeL( eSIRegP mem_ptr, eADXRegL oldval, eBCXRegL newval, eFlagsReg cr ) %{
 7395   predicate(VM_Version::supports_cx8());
 7396   match(Set oldval (CompareAndExchangeL mem_ptr (Binary oldval newval)));
 7397   effect(KILL cr);
 7398   format %{ &quot;CMPXCHG8 [$mem_ptr],$newval\t# If EDX:EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot; %}
 7399   ins_encode( enc_cmpxchg8(mem_ptr) );
 7400   ins_pipe( pipe_cmpxchg );
 7401 %}
 7402 
 7403 instruct compareAndExchangeP( pRegP mem_ptr, eAXRegP oldval, eCXRegP newval, eFlagsReg cr) %{
 7404   match(Set oldval (CompareAndExchangeP mem_ptr (Binary oldval newval)));
 7405   effect(KILL cr);
 7406   format %{ &quot;CMPXCHG [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot; %}
 7407   ins_encode( enc_cmpxchg(mem_ptr) );
 7408   ins_pipe( pipe_cmpxchg );
 7409 %}
 7410 
 7411 instruct compareAndExchangeB( pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr) %{
 7412   match(Set oldval (CompareAndExchangeB mem_ptr (Binary oldval newval)));
 7413   effect(KILL cr);
 7414   format %{ &quot;CMPXCHGB [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot; %}
 7415   ins_encode( enc_cmpxchgb(mem_ptr) );
 7416   ins_pipe( pipe_cmpxchg );
 7417 %}
 7418 
 7419 instruct compareAndExchangeS( pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr) %{
 7420   match(Set oldval (CompareAndExchangeS mem_ptr (Binary oldval newval)));
 7421   effect(KILL cr);
 7422   format %{ &quot;CMPXCHGW [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot; %}
 7423   ins_encode( enc_cmpxchgw(mem_ptr) );
 7424   ins_pipe( pipe_cmpxchg );
 7425 %}
 7426 
 7427 instruct compareAndExchangeI( pRegP mem_ptr, eAXRegI oldval, eCXRegI newval, eFlagsReg cr) %{
 7428   match(Set oldval (CompareAndExchangeI mem_ptr (Binary oldval newval)));
 7429   effect(KILL cr);
 7430   format %{ &quot;CMPXCHG [$mem_ptr],$newval\t# If EAX==[$mem_ptr] Then store $newval into [$mem_ptr]\n\t&quot; %}
 7431   ins_encode( enc_cmpxchg(mem_ptr) );
 7432   ins_pipe( pipe_cmpxchg );
 7433 %}
 7434 
 7435 instruct xaddB_no_res( memory mem, Universe dummy, immI add, eFlagsReg cr) %{
 7436   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7437   match(Set dummy (GetAndAddB mem add));
 7438   effect(KILL cr);
 7439   format %{ &quot;ADDB  [$mem],$add&quot; %}
 7440   ins_encode %{
 7441     __ lock();
 7442     __ addb($mem$$Address, $add$$constant);
 7443   %}
 7444   ins_pipe( pipe_cmpxchg );
 7445 %}
 7446 
 7447 // Important to match to xRegI: only 8-bit regs.
 7448 instruct xaddB( memory mem, xRegI newval, eFlagsReg cr) %{
 7449   match(Set newval (GetAndAddB mem newval));
 7450   effect(KILL cr);
 7451   format %{ &quot;XADDB  [$mem],$newval&quot; %}
 7452   ins_encode %{
 7453     __ lock();
 7454     __ xaddb($mem$$Address, $newval$$Register);
 7455   %}
 7456   ins_pipe( pipe_cmpxchg );
 7457 %}
 7458 
 7459 instruct xaddS_no_res( memory mem, Universe dummy, immI add, eFlagsReg cr) %{
 7460   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7461   match(Set dummy (GetAndAddS mem add));
 7462   effect(KILL cr);
 7463   format %{ &quot;ADDS  [$mem],$add&quot; %}
 7464   ins_encode %{
 7465     __ lock();
 7466     __ addw($mem$$Address, $add$$constant);
 7467   %}
 7468   ins_pipe( pipe_cmpxchg );
 7469 %}
 7470 
 7471 instruct xaddS( memory mem, rRegI newval, eFlagsReg cr) %{
 7472   match(Set newval (GetAndAddS mem newval));
 7473   effect(KILL cr);
 7474   format %{ &quot;XADDS  [$mem],$newval&quot; %}
 7475   ins_encode %{
 7476     __ lock();
 7477     __ xaddw($mem$$Address, $newval$$Register);
 7478   %}
 7479   ins_pipe( pipe_cmpxchg );
 7480 %}
 7481 
 7482 instruct xaddI_no_res( memory mem, Universe dummy, immI add, eFlagsReg cr) %{
 7483   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7484   match(Set dummy (GetAndAddI mem add));
 7485   effect(KILL cr);
 7486   format %{ &quot;ADDL  [$mem],$add&quot; %}
 7487   ins_encode %{
 7488     __ lock();
 7489     __ addl($mem$$Address, $add$$constant);
 7490   %}
 7491   ins_pipe( pipe_cmpxchg );
 7492 %}
 7493 
 7494 instruct xaddI( memory mem, rRegI newval, eFlagsReg cr) %{
 7495   match(Set newval (GetAndAddI mem newval));
 7496   effect(KILL cr);
 7497   format %{ &quot;XADDL  [$mem],$newval&quot; %}
 7498   ins_encode %{
 7499     __ lock();
 7500     __ xaddl($mem$$Address, $newval$$Register);
 7501   %}
 7502   ins_pipe( pipe_cmpxchg );
 7503 %}
 7504 
 7505 // Important to match to xRegI: only 8-bit regs.
 7506 instruct xchgB( memory mem, xRegI newval) %{
 7507   match(Set newval (GetAndSetB mem newval));
 7508   format %{ &quot;XCHGB  $newval,[$mem]&quot; %}
 7509   ins_encode %{
 7510     __ xchgb($newval$$Register, $mem$$Address);
 7511   %}
 7512   ins_pipe( pipe_cmpxchg );
 7513 %}
 7514 
 7515 instruct xchgS( memory mem, rRegI newval) %{
 7516   match(Set newval (GetAndSetS mem newval));
 7517   format %{ &quot;XCHGW  $newval,[$mem]&quot; %}
 7518   ins_encode %{
 7519     __ xchgw($newval$$Register, $mem$$Address);
 7520   %}
 7521   ins_pipe( pipe_cmpxchg );
 7522 %}
 7523 
 7524 instruct xchgI( memory mem, rRegI newval) %{
 7525   match(Set newval (GetAndSetI mem newval));
 7526   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 7527   ins_encode %{
 7528     __ xchgl($newval$$Register, $mem$$Address);
 7529   %}
 7530   ins_pipe( pipe_cmpxchg );
 7531 %}
 7532 
 7533 instruct xchgP( memory mem, pRegP newval) %{
 7534   match(Set newval (GetAndSetP mem newval));
 7535   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 7536   ins_encode %{
 7537     __ xchgl($newval$$Register, $mem$$Address);
 7538   %}
 7539   ins_pipe( pipe_cmpxchg );
 7540 %}
 7541 
 7542 //----------Subtraction Instructions-------------------------------------------
 7543 
 7544 // Integer Subtraction Instructions
 7545 instruct subI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 7546   match(Set dst (SubI dst src));
 7547   effect(KILL cr);
 7548 
 7549   size(2);
 7550   format %{ &quot;SUB    $dst,$src&quot; %}
 7551   opcode(0x2B);
 7552   ins_encode( OpcP, RegReg( dst, src) );
 7553   ins_pipe( ialu_reg_reg );
 7554 %}
 7555 
 7556 instruct subI_eReg_imm(rRegI dst, immI src, eFlagsReg cr) %{
 7557   match(Set dst (SubI dst src));
 7558   effect(KILL cr);
 7559 
 7560   format %{ &quot;SUB    $dst,$src&quot; %}
 7561   opcode(0x81,0x05);  /* Opcode 81 /5 */
 7562   // ins_encode( RegImm( dst, src) );
 7563   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 7564   ins_pipe( ialu_reg );
 7565 %}
 7566 
 7567 instruct subI_eReg_mem(rRegI dst, memory src, eFlagsReg cr) %{
 7568   match(Set dst (SubI dst (LoadI src)));
 7569   effect(KILL cr);
 7570 
 7571   ins_cost(125);
 7572   format %{ &quot;SUB    $dst,$src&quot; %}
 7573   opcode(0x2B);
 7574   ins_encode( OpcP, RegMem( dst, src) );
 7575   ins_pipe( ialu_reg_mem );
 7576 %}
 7577 
 7578 instruct subI_mem_eReg(memory dst, rRegI src, eFlagsReg cr) %{
 7579   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
 7580   effect(KILL cr);
 7581 
 7582   ins_cost(150);
 7583   format %{ &quot;SUB    $dst,$src&quot; %}
 7584   opcode(0x29);  /* Opcode 29 /r */
 7585   ins_encode( OpcP, RegMem( src, dst ) );
 7586   ins_pipe( ialu_mem_reg );
 7587 %}
 7588 
 7589 // Subtract from a pointer
 7590 instruct subP_eReg(eRegP dst, rRegI src, immI0 zero, eFlagsReg cr) %{
 7591   match(Set dst (AddP dst (SubI zero src)));
 7592   effect(KILL cr);
 7593 
 7594   size(2);
 7595   format %{ &quot;SUB    $dst,$src&quot; %}
 7596   opcode(0x2B);
 7597   ins_encode( OpcP, RegReg( dst, src) );
 7598   ins_pipe( ialu_reg_reg );
 7599 %}
 7600 
 7601 instruct negI_eReg(rRegI dst, immI0 zero, eFlagsReg cr) %{
 7602   match(Set dst (SubI zero dst));
 7603   effect(KILL cr);
 7604 
 7605   size(2);
 7606   format %{ &quot;NEG    $dst&quot; %}
 7607   opcode(0xF7,0x03);  // Opcode F7 /3
 7608   ins_encode( OpcP, RegOpc( dst ) );
 7609   ins_pipe( ialu_reg );
 7610 %}
 7611 
 7612 //----------Multiplication/Division Instructions-------------------------------
 7613 // Integer Multiplication Instructions
 7614 // Multiply Register
 7615 instruct mulI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 7616   match(Set dst (MulI dst src));
 7617   effect(KILL cr);
 7618 
 7619   size(3);
 7620   ins_cost(300);
 7621   format %{ &quot;IMUL   $dst,$src&quot; %}
 7622   opcode(0xAF, 0x0F);
 7623   ins_encode( OpcS, OpcP, RegReg( dst, src) );
 7624   ins_pipe( ialu_reg_reg_alu0 );
 7625 %}
 7626 
 7627 // Multiply 32-bit Immediate
 7628 instruct mulI_eReg_imm(rRegI dst, rRegI src, immI imm, eFlagsReg cr) %{
 7629   match(Set dst (MulI src imm));
 7630   effect(KILL cr);
 7631 
 7632   ins_cost(300);
 7633   format %{ &quot;IMUL   $dst,$src,$imm&quot; %}
 7634   opcode(0x69);  /* 69 /r id */
 7635   ins_encode( OpcSE(imm), RegReg( dst, src ), Con8or32( imm ) );
 7636   ins_pipe( ialu_reg_reg_alu0 );
 7637 %}
 7638 
 7639 instruct loadConL_low_only(eADXRegL_low_only dst, immL32 src, eFlagsReg cr) %{
 7640   match(Set dst src);
 7641   effect(KILL cr);
 7642 
 7643   // Note that this is artificially increased to make it more expensive than loadConL
 7644   ins_cost(250);
 7645   format %{ &quot;MOV    EAX,$src\t// low word only&quot; %}
 7646   opcode(0xB8);
 7647   ins_encode( LdImmL_Lo(dst, src) );
 7648   ins_pipe( ialu_reg_fat );
 7649 %}
 7650 
 7651 // Multiply by 32-bit Immediate, taking the shifted high order results
 7652 //  (special case for shift by 32)
 7653 instruct mulI_imm_high(eDXRegI dst, nadxRegI src1, eADXRegL_low_only src2, immI_32 cnt, eFlagsReg cr) %{
 7654   match(Set dst (ConvL2I (RShiftL (MulL (ConvI2L src1) src2) cnt)));
 7655   predicate( _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;Opcode() == Op_ConL &amp;&amp;
 7656              _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;get_con() &gt;= min_jint &amp;&amp;
 7657              _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;get_con() &lt;= max_jint );
 7658   effect(USE src1, KILL cr);
 7659 
 7660   // Note that this is adjusted by 150 to compensate for the overcosting of loadConL_low_only
 7661   ins_cost(0*100 + 1*400 - 150);
 7662   format %{ &quot;IMUL   EDX:EAX,$src1&quot; %}
 7663   ins_encode( multiply_con_and_shift_high( dst, src1, src2, cnt, cr ) );
 7664   ins_pipe( pipe_slow );
 7665 %}
 7666 
 7667 // Multiply by 32-bit Immediate, taking the shifted high order results
 7668 instruct mulI_imm_RShift_high(eDXRegI dst, nadxRegI src1, eADXRegL_low_only src2, immI_32_63 cnt, eFlagsReg cr) %{
 7669   match(Set dst (ConvL2I (RShiftL (MulL (ConvI2L src1) src2) cnt)));
 7670   predicate( _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;Opcode() == Op_ConL &amp;&amp;
 7671              _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;get_con() &gt;= min_jint &amp;&amp;
 7672              _kids[0]-&gt;_kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;get_con() &lt;= max_jint );
 7673   effect(USE src1, KILL cr);
 7674 
 7675   // Note that this is adjusted by 150 to compensate for the overcosting of loadConL_low_only
 7676   ins_cost(1*100 + 1*400 - 150);
 7677   format %{ &quot;IMUL   EDX:EAX,$src1\n\t&quot;
 7678             &quot;SAR    EDX,$cnt-32&quot; %}
 7679   ins_encode( multiply_con_and_shift_high( dst, src1, src2, cnt, cr ) );
 7680   ins_pipe( pipe_slow );
 7681 %}
 7682 
 7683 // Multiply Memory 32-bit Immediate
 7684 instruct mulI_mem_imm(rRegI dst, memory src, immI imm, eFlagsReg cr) %{
 7685   match(Set dst (MulI (LoadI src) imm));
 7686   effect(KILL cr);
 7687 
 7688   ins_cost(300);
 7689   format %{ &quot;IMUL   $dst,$src,$imm&quot; %}
 7690   opcode(0x69);  /* 69 /r id */
 7691   ins_encode( OpcSE(imm), RegMem( dst, src ), Con8or32( imm ) );
 7692   ins_pipe( ialu_reg_mem_alu0 );
 7693 %}
 7694 
 7695 // Multiply Memory
 7696 instruct mulI(rRegI dst, memory src, eFlagsReg cr) %{
 7697   match(Set dst (MulI dst (LoadI src)));
 7698   effect(KILL cr);
 7699 
 7700   ins_cost(350);
 7701   format %{ &quot;IMUL   $dst,$src&quot; %}
 7702   opcode(0xAF, 0x0F);
 7703   ins_encode( OpcS, OpcP, RegMem( dst, src) );
 7704   ins_pipe( ialu_reg_mem_alu0 );
 7705 %}
 7706 
 7707 instruct mulAddS2I_rReg(rRegI dst, rRegI src1, rRegI src2, rRegI src3, eFlagsReg cr)
 7708 %{
 7709   match(Set dst (MulAddS2I (Binary dst src1) (Binary src2 src3)));
 7710   effect(KILL cr, KILL src2);
 7711 
 7712   expand %{ mulI_eReg(dst, src1, cr);
 7713            mulI_eReg(src2, src3, cr);
 7714            addI_eReg(dst, src2, cr); %}
 7715 %}
 7716 
 7717 // Multiply Register Int to Long
 7718 instruct mulI2L(eADXRegL dst, eAXRegI src, nadxRegI src1, eFlagsReg flags) %{
 7719   // Basic Idea: long = (long)int * (long)int
 7720   match(Set dst (MulL (ConvI2L src) (ConvI2L src1)));
 7721   effect(DEF dst, USE src, USE src1, KILL flags);
 7722 
 7723   ins_cost(300);
 7724   format %{ &quot;IMUL   $dst,$src1&quot; %}
 7725 
 7726   ins_encode( long_int_multiply( dst, src1 ) );
 7727   ins_pipe( ialu_reg_reg_alu0 );
 7728 %}
 7729 
 7730 instruct mulIS_eReg(eADXRegL dst, immL_32bits mask, eFlagsReg flags, eAXRegI src, nadxRegI src1) %{
 7731   // Basic Idea:  long = (int &amp; 0xffffffffL) * (int &amp; 0xffffffffL)
 7732   match(Set dst (MulL (AndL (ConvI2L src) mask) (AndL (ConvI2L src1) mask)));
 7733   effect(KILL flags);
 7734 
 7735   ins_cost(300);
 7736   format %{ &quot;MUL    $dst,$src1&quot; %}
 7737 
 7738   ins_encode( long_uint_multiply(dst, src1) );
 7739   ins_pipe( ialu_reg_reg_alu0 );
 7740 %}
 7741 
 7742 // Multiply Register Long
 7743 instruct mulL_eReg(eADXRegL dst, eRegL src, rRegI tmp, eFlagsReg cr) %{
 7744   match(Set dst (MulL dst src));
 7745   effect(KILL cr, TEMP tmp);
 7746   ins_cost(4*100+3*400);
 7747 // Basic idea: lo(result) = lo(x_lo * y_lo)
 7748 //             hi(result) = hi(x_lo * y_lo) + lo(x_hi * y_lo) + lo(x_lo * y_hi)
 7749   format %{ &quot;MOV    $tmp,$src.lo\n\t&quot;
 7750             &quot;IMUL   $tmp,EDX\n\t&quot;
 7751             &quot;MOV    EDX,$src.hi\n\t&quot;
 7752             &quot;IMUL   EDX,EAX\n\t&quot;
 7753             &quot;ADD    $tmp,EDX\n\t&quot;
 7754             &quot;MUL    EDX:EAX,$src.lo\n\t&quot;
 7755             &quot;ADD    EDX,$tmp&quot; %}
 7756   ins_encode( long_multiply( dst, src, tmp ) );
 7757   ins_pipe( pipe_slow );
 7758 %}
 7759 
 7760 // Multiply Register Long where the left operand&#39;s high 32 bits are zero
 7761 instruct mulL_eReg_lhi0(eADXRegL dst, eRegL src, rRegI tmp, eFlagsReg cr) %{
 7762   predicate(is_operand_hi32_zero(n-&gt;in(1)));
 7763   match(Set dst (MulL dst src));
 7764   effect(KILL cr, TEMP tmp);
 7765   ins_cost(2*100+2*400);
 7766 // Basic idea: lo(result) = lo(x_lo * y_lo)
 7767 //             hi(result) = hi(x_lo * y_lo) + lo(x_lo * y_hi) where lo(x_hi * y_lo) = 0 because x_hi = 0
 7768   format %{ &quot;MOV    $tmp,$src.hi\n\t&quot;
 7769             &quot;IMUL   $tmp,EAX\n\t&quot;
 7770             &quot;MUL    EDX:EAX,$src.lo\n\t&quot;
 7771             &quot;ADD    EDX,$tmp&quot; %}
 7772   ins_encode %{
 7773     __ movl($tmp$$Register, HIGH_FROM_LOW($src$$Register));
 7774     __ imull($tmp$$Register, rax);
 7775     __ mull($src$$Register);
 7776     __ addl(rdx, $tmp$$Register);
 7777   %}
 7778   ins_pipe( pipe_slow );
 7779 %}
 7780 
 7781 // Multiply Register Long where the right operand&#39;s high 32 bits are zero
 7782 instruct mulL_eReg_rhi0(eADXRegL dst, eRegL src, rRegI tmp, eFlagsReg cr) %{
 7783   predicate(is_operand_hi32_zero(n-&gt;in(2)));
 7784   match(Set dst (MulL dst src));
 7785   effect(KILL cr, TEMP tmp);
 7786   ins_cost(2*100+2*400);
 7787 // Basic idea: lo(result) = lo(x_lo * y_lo)
 7788 //             hi(result) = hi(x_lo * y_lo) + lo(x_hi * y_lo) where lo(x_lo * y_hi) = 0 because y_hi = 0
 7789   format %{ &quot;MOV    $tmp,$src.lo\n\t&quot;
 7790             &quot;IMUL   $tmp,EDX\n\t&quot;
 7791             &quot;MUL    EDX:EAX,$src.lo\n\t&quot;
 7792             &quot;ADD    EDX,$tmp&quot; %}
 7793   ins_encode %{
 7794     __ movl($tmp$$Register, $src$$Register);
 7795     __ imull($tmp$$Register, rdx);
 7796     __ mull($src$$Register);
 7797     __ addl(rdx, $tmp$$Register);
 7798   %}
 7799   ins_pipe( pipe_slow );
 7800 %}
 7801 
 7802 // Multiply Register Long where the left and the right operands&#39; high 32 bits are zero
 7803 instruct mulL_eReg_hi0(eADXRegL dst, eRegL src, eFlagsReg cr) %{
 7804   predicate(is_operand_hi32_zero(n-&gt;in(1)) &amp;&amp; is_operand_hi32_zero(n-&gt;in(2)));
 7805   match(Set dst (MulL dst src));
 7806   effect(KILL cr);
 7807   ins_cost(1*400);
 7808 // Basic idea: lo(result) = lo(x_lo * y_lo)
 7809 //             hi(result) = hi(x_lo * y_lo) where lo(x_hi * y_lo) = 0 and lo(x_lo * y_hi) = 0 because x_hi = 0 and y_hi = 0
 7810   format %{ &quot;MUL    EDX:EAX,$src.lo\n\t&quot; %}
 7811   ins_encode %{
 7812     __ mull($src$$Register);
 7813   %}
 7814   ins_pipe( pipe_slow );
 7815 %}
 7816 
 7817 // Multiply Register Long by small constant
 7818 instruct mulL_eReg_con(eADXRegL dst, immL_127 src, rRegI tmp, eFlagsReg cr) %{
 7819   match(Set dst (MulL dst src));
 7820   effect(KILL cr, TEMP tmp);
 7821   ins_cost(2*100+2*400);
 7822   size(12);
 7823 // Basic idea: lo(result) = lo(src * EAX)
 7824 //             hi(result) = hi(src * EAX) + lo(src * EDX)
 7825   format %{ &quot;IMUL   $tmp,EDX,$src\n\t&quot;
 7826             &quot;MOV    EDX,$src\n\t&quot;
 7827             &quot;MUL    EDX\t# EDX*EAX -&gt; EDX:EAX\n\t&quot;
 7828             &quot;ADD    EDX,$tmp&quot; %}
 7829   ins_encode( long_multiply_con( dst, src, tmp ) );
 7830   ins_pipe( pipe_slow );
 7831 %}
 7832 
 7833 // Integer DIV with Register
 7834 instruct divI_eReg(eAXRegI rax, eDXRegI rdx, eCXRegI div, eFlagsReg cr) %{
 7835   match(Set rax (DivI rax div));
 7836   effect(KILL rdx, KILL cr);
 7837   size(26);
 7838   ins_cost(30*100+10*100);
 7839   format %{ &quot;CMP    EAX,0x80000000\n\t&quot;
 7840             &quot;JNE,s  normal\n\t&quot;
 7841             &quot;XOR    EDX,EDX\n\t&quot;
 7842             &quot;CMP    ECX,-1\n\t&quot;
 7843             &quot;JE,s   done\n&quot;
 7844     &quot;normal: CDQ\n\t&quot;
 7845             &quot;IDIV   $div\n\t&quot;
 7846     &quot;done:&quot;        %}
 7847   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 7848   ins_encode( cdq_enc, OpcP, RegOpc(div) );
 7849   ins_pipe( ialu_reg_reg_alu0 );
 7850 %}
 7851 
 7852 // Divide Register Long
 7853 instruct divL_eReg( eADXRegL dst, eRegL src1, eRegL src2, eFlagsReg cr, eCXRegI cx, eBXRegI bx ) %{
 7854   match(Set dst (DivL src1 src2));
 7855   effect( KILL cr, KILL cx, KILL bx );
 7856   ins_cost(10000);
 7857   format %{ &quot;PUSH   $src1.hi\n\t&quot;
 7858             &quot;PUSH   $src1.lo\n\t&quot;
 7859             &quot;PUSH   $src2.hi\n\t&quot;
 7860             &quot;PUSH   $src2.lo\n\t&quot;
 7861             &quot;CALL   SharedRuntime::ldiv\n\t&quot;
 7862             &quot;ADD    ESP,16&quot; %}
 7863   ins_encode( long_div(src1,src2) );
 7864   ins_pipe( pipe_slow );
 7865 %}
 7866 
 7867 // Integer DIVMOD with Register, both quotient and mod results
 7868 instruct divModI_eReg_divmod(eAXRegI rax, eDXRegI rdx, eCXRegI div, eFlagsReg cr) %{
 7869   match(DivModI rax div);
 7870   effect(KILL cr);
 7871   size(26);
 7872   ins_cost(30*100+10*100);
 7873   format %{ &quot;CMP    EAX,0x80000000\n\t&quot;
 7874             &quot;JNE,s  normal\n\t&quot;
 7875             &quot;XOR    EDX,EDX\n\t&quot;
 7876             &quot;CMP    ECX,-1\n\t&quot;
 7877             &quot;JE,s   done\n&quot;
 7878     &quot;normal: CDQ\n\t&quot;
 7879             &quot;IDIV   $div\n\t&quot;
 7880     &quot;done:&quot;        %}
 7881   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 7882   ins_encode( cdq_enc, OpcP, RegOpc(div) );
 7883   ins_pipe( pipe_slow );
 7884 %}
 7885 
 7886 // Integer MOD with Register
 7887 instruct modI_eReg(eDXRegI rdx, eAXRegI rax, eCXRegI div, eFlagsReg cr) %{
 7888   match(Set rdx (ModI rax div));
 7889   effect(KILL rax, KILL cr);
 7890 
 7891   size(26);
 7892   ins_cost(300);
 7893   format %{ &quot;CDQ\n\t&quot;
 7894             &quot;IDIV   $div&quot; %}
 7895   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 7896   ins_encode( cdq_enc, OpcP, RegOpc(div) );
 7897   ins_pipe( ialu_reg_reg_alu0 );
 7898 %}
 7899 
 7900 // Remainder Register Long
 7901 instruct modL_eReg( eADXRegL dst, eRegL src1, eRegL src2, eFlagsReg cr, eCXRegI cx, eBXRegI bx ) %{
 7902   match(Set dst (ModL src1 src2));
 7903   effect( KILL cr, KILL cx, KILL bx );
 7904   ins_cost(10000);
 7905   format %{ &quot;PUSH   $src1.hi\n\t&quot;
 7906             &quot;PUSH   $src1.lo\n\t&quot;
 7907             &quot;PUSH   $src2.hi\n\t&quot;
 7908             &quot;PUSH   $src2.lo\n\t&quot;
 7909             &quot;CALL   SharedRuntime::lrem\n\t&quot;
 7910             &quot;ADD    ESP,16&quot; %}
 7911   ins_encode( long_mod(src1,src2) );
 7912   ins_pipe( pipe_slow );
 7913 %}
 7914 
 7915 // Divide Register Long (no special case since divisor != -1)
 7916 instruct divL_eReg_imm32( eADXRegL dst, immL32 imm, rRegI tmp, rRegI tmp2, eFlagsReg cr ) %{
 7917   match(Set dst (DivL dst imm));
 7918   effect( TEMP tmp, TEMP tmp2, KILL cr );
 7919   ins_cost(1000);
 7920   format %{ &quot;MOV    $tmp,abs($imm) # ldiv EDX:EAX,$imm\n\t&quot;
 7921             &quot;XOR    $tmp2,$tmp2\n\t&quot;
 7922             &quot;CMP    $tmp,EDX\n\t&quot;
 7923             &quot;JA,s   fast\n\t&quot;
 7924             &quot;MOV    $tmp2,EAX\n\t&quot;
 7925             &quot;MOV    EAX,EDX\n\t&quot;
 7926             &quot;MOV    EDX,0\n\t&quot;
 7927             &quot;JLE,s  pos\n\t&quot;
 7928             &quot;LNEG   EAX : $tmp2\n\t&quot;
 7929             &quot;DIV    $tmp # unsigned division\n\t&quot;
 7930             &quot;XCHG   EAX,$tmp2\n\t&quot;
 7931             &quot;DIV    $tmp\n\t&quot;
 7932             &quot;LNEG   $tmp2 : EAX\n\t&quot;
 7933             &quot;JMP,s  done\n&quot;
 7934     &quot;pos:\n\t&quot;
 7935             &quot;DIV    $tmp\n\t&quot;
 7936             &quot;XCHG   EAX,$tmp2\n&quot;
 7937     &quot;fast:\n\t&quot;
 7938             &quot;DIV    $tmp\n&quot;
 7939     &quot;done:\n\t&quot;
 7940             &quot;MOV    EDX,$tmp2\n\t&quot;
 7941             &quot;NEG    EDX:EAX # if $imm &lt; 0&quot; %}
 7942   ins_encode %{
 7943     int con = (int)$imm$$constant;
 7944     assert(con != 0 &amp;&amp; con != -1 &amp;&amp; con != min_jint, &quot;wrong divisor&quot;);
 7945     int pcon = (con &gt; 0) ? con : -con;
 7946     Label Lfast, Lpos, Ldone;
 7947 
 7948     __ movl($tmp$$Register, pcon);
 7949     __ xorl($tmp2$$Register,$tmp2$$Register);
 7950     __ cmpl($tmp$$Register, HIGH_FROM_LOW($dst$$Register));
 7951     __ jccb(Assembler::above, Lfast); // result fits into 32 bit
 7952 
 7953     __ movl($tmp2$$Register, $dst$$Register); // save
 7954     __ movl($dst$$Register, HIGH_FROM_LOW($dst$$Register));
 7955     __ movl(HIGH_FROM_LOW($dst$$Register),0); // preserve flags
 7956     __ jccb(Assembler::lessEqual, Lpos); // result is positive
 7957 
 7958     // Negative dividend.
 7959     // convert value to positive to use unsigned division
 7960     __ lneg($dst$$Register, $tmp2$$Register);
 7961     __ divl($tmp$$Register);
 7962     __ xchgl($dst$$Register, $tmp2$$Register);
 7963     __ divl($tmp$$Register);
 7964     // revert result back to negative
 7965     __ lneg($tmp2$$Register, $dst$$Register);
 7966     __ jmpb(Ldone);
 7967 
 7968     __ bind(Lpos);
 7969     __ divl($tmp$$Register); // Use unsigned division
 7970     __ xchgl($dst$$Register, $tmp2$$Register);
 7971     // Fallthrow for final divide, tmp2 has 32 bit hi result
 7972 
 7973     __ bind(Lfast);
 7974     // fast path: src is positive
 7975     __ divl($tmp$$Register); // Use unsigned division
 7976 
 7977     __ bind(Ldone);
 7978     __ movl(HIGH_FROM_LOW($dst$$Register),$tmp2$$Register);
 7979     if (con &lt; 0) {
 7980       __ lneg(HIGH_FROM_LOW($dst$$Register), $dst$$Register);
 7981     }
 7982   %}
 7983   ins_pipe( pipe_slow );
 7984 %}
 7985 
 7986 // Remainder Register Long (remainder fit into 32 bits)
 7987 instruct modL_eReg_imm32( eADXRegL dst, immL32 imm, rRegI tmp, rRegI tmp2, eFlagsReg cr ) %{
 7988   match(Set dst (ModL dst imm));
 7989   effect( TEMP tmp, TEMP tmp2, KILL cr );
 7990   ins_cost(1000);
 7991   format %{ &quot;MOV    $tmp,abs($imm) # lrem EDX:EAX,$imm\n\t&quot;
 7992             &quot;CMP    $tmp,EDX\n\t&quot;
 7993             &quot;JA,s   fast\n\t&quot;
 7994             &quot;MOV    $tmp2,EAX\n\t&quot;
 7995             &quot;MOV    EAX,EDX\n\t&quot;
 7996             &quot;MOV    EDX,0\n\t&quot;
 7997             &quot;JLE,s  pos\n\t&quot;
 7998             &quot;LNEG   EAX : $tmp2\n\t&quot;
 7999             &quot;DIV    $tmp # unsigned division\n\t&quot;
 8000             &quot;MOV    EAX,$tmp2\n\t&quot;
 8001             &quot;DIV    $tmp\n\t&quot;
 8002             &quot;NEG    EDX\n\t&quot;
 8003             &quot;JMP,s  done\n&quot;
 8004     &quot;pos:\n\t&quot;
 8005             &quot;DIV    $tmp\n\t&quot;
 8006             &quot;MOV    EAX,$tmp2\n&quot;
 8007     &quot;fast:\n\t&quot;
 8008             &quot;DIV    $tmp\n&quot;
 8009     &quot;done:\n\t&quot;
 8010             &quot;MOV    EAX,EDX\n\t&quot;
 8011             &quot;SAR    EDX,31\n\t&quot; %}
 8012   ins_encode %{
 8013     int con = (int)$imm$$constant;
 8014     assert(con != 0 &amp;&amp; con != -1 &amp;&amp; con != min_jint, &quot;wrong divisor&quot;);
 8015     int pcon = (con &gt; 0) ? con : -con;
 8016     Label  Lfast, Lpos, Ldone;
 8017 
 8018     __ movl($tmp$$Register, pcon);
 8019     __ cmpl($tmp$$Register, HIGH_FROM_LOW($dst$$Register));
 8020     __ jccb(Assembler::above, Lfast); // src is positive and result fits into 32 bit
 8021 
 8022     __ movl($tmp2$$Register, $dst$$Register); // save
 8023     __ movl($dst$$Register, HIGH_FROM_LOW($dst$$Register));
 8024     __ movl(HIGH_FROM_LOW($dst$$Register),0); // preserve flags
 8025     __ jccb(Assembler::lessEqual, Lpos); // result is positive
 8026 
 8027     // Negative dividend.
 8028     // convert value to positive to use unsigned division
 8029     __ lneg($dst$$Register, $tmp2$$Register);
 8030     __ divl($tmp$$Register);
 8031     __ movl($dst$$Register, $tmp2$$Register);
 8032     __ divl($tmp$$Register);
 8033     // revert remainder back to negative
 8034     __ negl(HIGH_FROM_LOW($dst$$Register));
 8035     __ jmpb(Ldone);
 8036 
 8037     __ bind(Lpos);
 8038     __ divl($tmp$$Register);
 8039     __ movl($dst$$Register, $tmp2$$Register);
 8040 
 8041     __ bind(Lfast);
 8042     // fast path: src is positive
 8043     __ divl($tmp$$Register);
 8044 
 8045     __ bind(Ldone);
 8046     __ movl($dst$$Register, HIGH_FROM_LOW($dst$$Register));
 8047     __ sarl(HIGH_FROM_LOW($dst$$Register), 31); // result sign
 8048 
 8049   %}
 8050   ins_pipe( pipe_slow );
 8051 %}
 8052 
 8053 // Integer Shift Instructions
 8054 // Shift Left by one
 8055 instruct shlI_eReg_1(rRegI dst, immI1 shift, eFlagsReg cr) %{
 8056   match(Set dst (LShiftI dst shift));
 8057   effect(KILL cr);
 8058 
 8059   size(2);
 8060   format %{ &quot;SHL    $dst,$shift&quot; %}
 8061   opcode(0xD1, 0x4);  /* D1 /4 */
 8062   ins_encode( OpcP, RegOpc( dst ) );
 8063   ins_pipe( ialu_reg );
 8064 %}
 8065 
 8066 // Shift Left by 8-bit immediate
 8067 instruct salI_eReg_imm(rRegI dst, immI8 shift, eFlagsReg cr) %{
 8068   match(Set dst (LShiftI dst shift));
 8069   effect(KILL cr);
 8070 
 8071   size(3);
 8072   format %{ &quot;SHL    $dst,$shift&quot; %}
 8073   opcode(0xC1, 0x4);  /* C1 /4 ib */
 8074   ins_encode( RegOpcImm( dst, shift) );
 8075   ins_pipe( ialu_reg );
 8076 %}
 8077 
 8078 // Shift Left by variable
 8079 instruct salI_eReg_CL(rRegI dst, eCXRegI shift, eFlagsReg cr) %{
 8080   match(Set dst (LShiftI dst shift));
 8081   effect(KILL cr);
 8082 
 8083   size(2);
 8084   format %{ &quot;SHL    $dst,$shift&quot; %}
 8085   opcode(0xD3, 0x4);  /* D3 /4 */
 8086   ins_encode( OpcP, RegOpc( dst ) );
 8087   ins_pipe( ialu_reg_reg );
 8088 %}
 8089 
 8090 // Arithmetic shift right by one
 8091 instruct sarI_eReg_1(rRegI dst, immI1 shift, eFlagsReg cr) %{
 8092   match(Set dst (RShiftI dst shift));
 8093   effect(KILL cr);
 8094 
 8095   size(2);
 8096   format %{ &quot;SAR    $dst,$shift&quot; %}
 8097   opcode(0xD1, 0x7);  /* D1 /7 */
 8098   ins_encode( OpcP, RegOpc( dst ) );
 8099   ins_pipe( ialu_reg );
 8100 %}
 8101 
 8102 // Arithmetic shift right by one
 8103 instruct sarI_mem_1(memory dst, immI1 shift, eFlagsReg cr) %{
 8104   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8105   effect(KILL cr);
 8106   format %{ &quot;SAR    $dst,$shift&quot; %}
 8107   opcode(0xD1, 0x7);  /* D1 /7 */
 8108   ins_encode( OpcP, RMopc_Mem(secondary,dst) );
 8109   ins_pipe( ialu_mem_imm );
 8110 %}
 8111 
 8112 // Arithmetic Shift Right by 8-bit immediate
 8113 instruct sarI_eReg_imm(rRegI dst, immI8 shift, eFlagsReg cr) %{
 8114   match(Set dst (RShiftI dst shift));
 8115   effect(KILL cr);
 8116 
 8117   size(3);
 8118   format %{ &quot;SAR    $dst,$shift&quot; %}
 8119   opcode(0xC1, 0x7);  /* C1 /7 ib */
 8120   ins_encode( RegOpcImm( dst, shift ) );
 8121   ins_pipe( ialu_mem_imm );
 8122 %}
 8123 
 8124 // Arithmetic Shift Right by 8-bit immediate
 8125 instruct sarI_mem_imm(memory dst, immI8 shift, eFlagsReg cr) %{
 8126   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8127   effect(KILL cr);
 8128 
 8129   format %{ &quot;SAR    $dst,$shift&quot; %}
 8130   opcode(0xC1, 0x7);  /* C1 /7 ib */
 8131   ins_encode( OpcP, RMopc_Mem(secondary, dst ), Con8or32( shift ) );
 8132   ins_pipe( ialu_mem_imm );
 8133 %}
 8134 
 8135 // Arithmetic Shift Right by variable
 8136 instruct sarI_eReg_CL(rRegI dst, eCXRegI shift, eFlagsReg cr) %{
 8137   match(Set dst (RShiftI dst shift));
 8138   effect(KILL cr);
 8139 
 8140   size(2);
 8141   format %{ &quot;SAR    $dst,$shift&quot; %}
 8142   opcode(0xD3, 0x7);  /* D3 /7 */
 8143   ins_encode( OpcP, RegOpc( dst ) );
 8144   ins_pipe( ialu_reg_reg );
 8145 %}
 8146 
 8147 // Logical shift right by one
 8148 instruct shrI_eReg_1(rRegI dst, immI1 shift, eFlagsReg cr) %{
 8149   match(Set dst (URShiftI dst shift));
 8150   effect(KILL cr);
 8151 
 8152   size(2);
 8153   format %{ &quot;SHR    $dst,$shift&quot; %}
 8154   opcode(0xD1, 0x5);  /* D1 /5 */
 8155   ins_encode( OpcP, RegOpc( dst ) );
 8156   ins_pipe( ialu_reg );
 8157 %}
 8158 
 8159 // Logical Shift Right by 8-bit immediate
 8160 instruct shrI_eReg_imm(rRegI dst, immI8 shift, eFlagsReg cr) %{
 8161   match(Set dst (URShiftI dst shift));
 8162   effect(KILL cr);
 8163 
 8164   size(3);
 8165   format %{ &quot;SHR    $dst,$shift&quot; %}
 8166   opcode(0xC1, 0x5);  /* C1 /5 ib */
 8167   ins_encode( RegOpcImm( dst, shift) );
 8168   ins_pipe( ialu_reg );
 8169 %}
 8170 
 8171 
 8172 // Logical Shift Right by 24, followed by Arithmetic Shift Left by 24.
 8173 // This idiom is used by the compiler for the i2b bytecode.
 8174 instruct i2b(rRegI dst, xRegI src, immI_24 twentyfour) %{
 8175   match(Set dst (RShiftI (LShiftI src twentyfour) twentyfour));
 8176 
 8177   size(3);
 8178   format %{ &quot;MOVSX  $dst,$src :8&quot; %}
 8179   ins_encode %{
 8180     __ movsbl($dst$$Register, $src$$Register);
 8181   %}
 8182   ins_pipe(ialu_reg_reg);
 8183 %}
 8184 
 8185 // Logical Shift Right by 16, followed by Arithmetic Shift Left by 16.
 8186 // This idiom is used by the compiler the i2s bytecode.
 8187 instruct i2s(rRegI dst, xRegI src, immI_16 sixteen) %{
 8188   match(Set dst (RShiftI (LShiftI src sixteen) sixteen));
 8189 
 8190   size(3);
 8191   format %{ &quot;MOVSX  $dst,$src :16&quot; %}
 8192   ins_encode %{
 8193     __ movswl($dst$$Register, $src$$Register);
 8194   %}
 8195   ins_pipe(ialu_reg_reg);
 8196 %}
 8197 
 8198 
 8199 // Logical Shift Right by variable
 8200 instruct shrI_eReg_CL(rRegI dst, eCXRegI shift, eFlagsReg cr) %{
 8201   match(Set dst (URShiftI dst shift));
 8202   effect(KILL cr);
 8203 
 8204   size(2);
 8205   format %{ &quot;SHR    $dst,$shift&quot; %}
 8206   opcode(0xD3, 0x5);  /* D3 /5 */
 8207   ins_encode( OpcP, RegOpc( dst ) );
 8208   ins_pipe( ialu_reg_reg );
 8209 %}
 8210 
 8211 
 8212 //----------Logical Instructions-----------------------------------------------
 8213 //----------Integer Logical Instructions---------------------------------------
 8214 // And Instructions
 8215 // And Register with Register
 8216 instruct andI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 8217   match(Set dst (AndI dst src));
 8218   effect(KILL cr);
 8219 
 8220   size(2);
 8221   format %{ &quot;AND    $dst,$src&quot; %}
 8222   opcode(0x23);
 8223   ins_encode( OpcP, RegReg( dst, src) );
 8224   ins_pipe( ialu_reg_reg );
 8225 %}
 8226 
 8227 // And Register with Immediate
 8228 instruct andI_eReg_imm(rRegI dst, immI src, eFlagsReg cr) %{
 8229   match(Set dst (AndI dst src));
 8230   effect(KILL cr);
 8231 
 8232   format %{ &quot;AND    $dst,$src&quot; %}
 8233   opcode(0x81,0x04);  /* Opcode 81 /4 */
 8234   // ins_encode( RegImm( dst, src) );
 8235   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 8236   ins_pipe( ialu_reg );
 8237 %}
 8238 
 8239 // And Register with Memory
 8240 instruct andI_eReg_mem(rRegI dst, memory src, eFlagsReg cr) %{
 8241   match(Set dst (AndI dst (LoadI src)));
 8242   effect(KILL cr);
 8243 
 8244   ins_cost(125);
 8245   format %{ &quot;AND    $dst,$src&quot; %}
 8246   opcode(0x23);
 8247   ins_encode( OpcP, RegMem( dst, src) );
 8248   ins_pipe( ialu_reg_mem );
 8249 %}
 8250 
 8251 // And Memory with Register
 8252 instruct andI_mem_eReg(memory dst, rRegI src, eFlagsReg cr) %{
 8253   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 8254   effect(KILL cr);
 8255 
 8256   ins_cost(150);
 8257   format %{ &quot;AND    $dst,$src&quot; %}
 8258   opcode(0x21);  /* Opcode 21 /r */
 8259   ins_encode( OpcP, RegMem( src, dst ) );
 8260   ins_pipe( ialu_mem_reg );
 8261 %}
 8262 
 8263 // And Memory with Immediate
 8264 instruct andI_mem_imm(memory dst, immI src, eFlagsReg cr) %{
 8265   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 8266   effect(KILL cr);
 8267 
 8268   ins_cost(125);
 8269   format %{ &quot;AND    $dst,$src&quot; %}
 8270   opcode(0x81, 0x4);  /* Opcode 81 /4 id */
 8271   // ins_encode( MemImm( dst, src) );
 8272   ins_encode( OpcSE( src ), RMopc_Mem(secondary, dst ), Con8or32( src ) );
 8273   ins_pipe( ialu_mem_imm );
 8274 %}
 8275 
 8276 // BMI1 instructions
 8277 instruct andnI_rReg_rReg_rReg(rRegI dst, rRegI src1, rRegI src2, immI_M1 minus_1, eFlagsReg cr) %{
 8278   match(Set dst (AndI (XorI src1 minus_1) src2));
 8279   predicate(UseBMI1Instructions);
 8280   effect(KILL cr);
 8281 
 8282   format %{ &quot;ANDNL  $dst, $src1, $src2&quot; %}
 8283 
 8284   ins_encode %{
 8285     __ andnl($dst$$Register, $src1$$Register, $src2$$Register);
 8286   %}
 8287   ins_pipe(ialu_reg);
 8288 %}
 8289 
 8290 instruct andnI_rReg_rReg_mem(rRegI dst, rRegI src1, memory src2, immI_M1 minus_1, eFlagsReg cr) %{
 8291   match(Set dst (AndI (XorI src1 minus_1) (LoadI src2) ));
 8292   predicate(UseBMI1Instructions);
 8293   effect(KILL cr);
 8294 
 8295   ins_cost(125);
 8296   format %{ &quot;ANDNL  $dst, $src1, $src2&quot; %}
 8297 
 8298   ins_encode %{
 8299     __ andnl($dst$$Register, $src1$$Register, $src2$$Address);
 8300   %}
 8301   ins_pipe(ialu_reg_mem);
 8302 %}
 8303 
 8304 instruct blsiI_rReg_rReg(rRegI dst, rRegI src, immI0 imm_zero, eFlagsReg cr) %{
 8305   match(Set dst (AndI (SubI imm_zero src) src));
 8306   predicate(UseBMI1Instructions);
 8307   effect(KILL cr);
 8308 
 8309   format %{ &quot;BLSIL  $dst, $src&quot; %}
 8310 
 8311   ins_encode %{
 8312     __ blsil($dst$$Register, $src$$Register);
 8313   %}
 8314   ins_pipe(ialu_reg);
 8315 %}
 8316 
 8317 instruct blsiI_rReg_mem(rRegI dst, memory src, immI0 imm_zero, eFlagsReg cr) %{
 8318   match(Set dst (AndI (SubI imm_zero (LoadI src) ) (LoadI src) ));
 8319   predicate(UseBMI1Instructions);
 8320   effect(KILL cr);
 8321 
 8322   ins_cost(125);
 8323   format %{ &quot;BLSIL  $dst, $src&quot; %}
 8324 
 8325   ins_encode %{
 8326     __ blsil($dst$$Register, $src$$Address);
 8327   %}
 8328   ins_pipe(ialu_reg_mem);
 8329 %}
 8330 
 8331 instruct blsmskI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, eFlagsReg cr)
 8332 %{
 8333   match(Set dst (XorI (AddI src minus_1) src));
 8334   predicate(UseBMI1Instructions);
 8335   effect(KILL cr);
 8336 
 8337   format %{ &quot;BLSMSKL $dst, $src&quot; %}
 8338 
 8339   ins_encode %{
 8340     __ blsmskl($dst$$Register, $src$$Register);
 8341   %}
 8342 
 8343   ins_pipe(ialu_reg);
 8344 %}
 8345 
 8346 instruct blsmskI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, eFlagsReg cr)
 8347 %{
 8348   match(Set dst (XorI (AddI (LoadI src) minus_1) (LoadI src) ));
 8349   predicate(UseBMI1Instructions);
 8350   effect(KILL cr);
 8351 
 8352   ins_cost(125);
 8353   format %{ &quot;BLSMSKL $dst, $src&quot; %}
 8354 
 8355   ins_encode %{
 8356     __ blsmskl($dst$$Register, $src$$Address);
 8357   %}
 8358 
 8359   ins_pipe(ialu_reg_mem);
 8360 %}
 8361 
 8362 instruct blsrI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, eFlagsReg cr)
 8363 %{
 8364   match(Set dst (AndI (AddI src minus_1) src) );
 8365   predicate(UseBMI1Instructions);
 8366   effect(KILL cr);
 8367 
 8368   format %{ &quot;BLSRL  $dst, $src&quot; %}
 8369 
 8370   ins_encode %{
 8371     __ blsrl($dst$$Register, $src$$Register);
 8372   %}
 8373 
 8374   ins_pipe(ialu_reg);
 8375 %}
 8376 
 8377 instruct blsrI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, eFlagsReg cr)
 8378 %{
 8379   match(Set dst (AndI (AddI (LoadI src) minus_1) (LoadI src) ));
 8380   predicate(UseBMI1Instructions);
 8381   effect(KILL cr);
 8382 
 8383   ins_cost(125);
 8384   format %{ &quot;BLSRL  $dst, $src&quot; %}
 8385 
 8386   ins_encode %{
 8387     __ blsrl($dst$$Register, $src$$Address);
 8388   %}
 8389 
 8390   ins_pipe(ialu_reg_mem);
 8391 %}
 8392 
 8393 // Or Instructions
 8394 // Or Register with Register
 8395 instruct orI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 8396   match(Set dst (OrI dst src));
 8397   effect(KILL cr);
 8398 
 8399   size(2);
 8400   format %{ &quot;OR     $dst,$src&quot; %}
 8401   opcode(0x0B);
 8402   ins_encode( OpcP, RegReg( dst, src) );
 8403   ins_pipe( ialu_reg_reg );
 8404 %}
 8405 
 8406 instruct orI_eReg_castP2X(rRegI dst, eRegP src, eFlagsReg cr) %{
 8407   match(Set dst (OrI dst (CastP2X src)));
 8408   effect(KILL cr);
 8409 
 8410   size(2);
 8411   format %{ &quot;OR     $dst,$src&quot; %}
 8412   opcode(0x0B);
 8413   ins_encode( OpcP, RegReg( dst, src) );
 8414   ins_pipe( ialu_reg_reg );
 8415 %}
 8416 
 8417 
 8418 // Or Register with Immediate
 8419 instruct orI_eReg_imm(rRegI dst, immI src, eFlagsReg cr) %{
 8420   match(Set dst (OrI dst src));
 8421   effect(KILL cr);
 8422 
 8423   format %{ &quot;OR     $dst,$src&quot; %}
 8424   opcode(0x81,0x01);  /* Opcode 81 /1 id */
 8425   // ins_encode( RegImm( dst, src) );
 8426   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 8427   ins_pipe( ialu_reg );
 8428 %}
 8429 
 8430 // Or Register with Memory
 8431 instruct orI_eReg_mem(rRegI dst, memory src, eFlagsReg cr) %{
 8432   match(Set dst (OrI dst (LoadI src)));
 8433   effect(KILL cr);
 8434 
 8435   ins_cost(125);
 8436   format %{ &quot;OR     $dst,$src&quot; %}
 8437   opcode(0x0B);
 8438   ins_encode( OpcP, RegMem( dst, src) );
 8439   ins_pipe( ialu_reg_mem );
 8440 %}
 8441 
 8442 // Or Memory with Register
 8443 instruct orI_mem_eReg(memory dst, rRegI src, eFlagsReg cr) %{
 8444   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 8445   effect(KILL cr);
 8446 
 8447   ins_cost(150);
 8448   format %{ &quot;OR     $dst,$src&quot; %}
 8449   opcode(0x09);  /* Opcode 09 /r */
 8450   ins_encode( OpcP, RegMem( src, dst ) );
 8451   ins_pipe( ialu_mem_reg );
 8452 %}
 8453 
 8454 // Or Memory with Immediate
 8455 instruct orI_mem_imm(memory dst, immI src, eFlagsReg cr) %{
 8456   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 8457   effect(KILL cr);
 8458 
 8459   ins_cost(125);
 8460   format %{ &quot;OR     $dst,$src&quot; %}
 8461   opcode(0x81,0x1);  /* Opcode 81 /1 id */
 8462   // ins_encode( MemImm( dst, src) );
 8463   ins_encode( OpcSE( src ), RMopc_Mem(secondary, dst ), Con8or32( src ) );
 8464   ins_pipe( ialu_mem_imm );
 8465 %}
 8466 
 8467 // ROL/ROR
 8468 // ROL expand
 8469 instruct rolI_eReg_imm1(rRegI dst, immI1 shift, eFlagsReg cr) %{
 8470   effect(USE_DEF dst, USE shift, KILL cr);
 8471 
 8472   format %{ &quot;ROL    $dst, $shift&quot; %}
 8473   opcode(0xD1, 0x0); /* Opcode D1 /0 */
 8474   ins_encode( OpcP, RegOpc( dst ));
 8475   ins_pipe( ialu_reg );
 8476 %}
 8477 
 8478 instruct rolI_eReg_imm8(rRegI dst, immI8 shift, eFlagsReg cr) %{
 8479   effect(USE_DEF dst, USE shift, KILL cr);
 8480 
 8481   format %{ &quot;ROL    $dst, $shift&quot; %}
 8482   opcode(0xC1, 0x0); /*Opcode /C1  /0  */
 8483   ins_encode( RegOpcImm(dst, shift) );
 8484   ins_pipe(ialu_reg);
 8485 %}
 8486 
 8487 instruct rolI_eReg_CL(ncxRegI dst, eCXRegI shift, eFlagsReg cr) %{
 8488   effect(USE_DEF dst, USE shift, KILL cr);
 8489 
 8490   format %{ &quot;ROL    $dst, $shift&quot; %}
 8491   opcode(0xD3, 0x0);    /* Opcode D3 /0 */
 8492   ins_encode(OpcP, RegOpc(dst));
 8493   ins_pipe( ialu_reg_reg );
 8494 %}
 8495 // end of ROL expand
 8496 
 8497 // ROL 32bit by one once
 8498 instruct rolI_eReg_i1(rRegI dst, immI1 lshift, immI_M1 rshift, eFlagsReg cr) %{
 8499   match(Set dst ( OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 8500 
 8501   expand %{
 8502     rolI_eReg_imm1(dst, lshift, cr);
 8503   %}
 8504 %}
 8505 
 8506 // ROL 32bit var by imm8 once
 8507 instruct rolI_eReg_i8(rRegI dst, immI8 lshift, immI8 rshift, eFlagsReg cr) %{
 8508   predicate(  0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 8509   match(Set dst ( OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 8510 
 8511   expand %{
 8512     rolI_eReg_imm8(dst, lshift, cr);
 8513   %}
 8514 %}
 8515 
 8516 // ROL 32bit var by var once
 8517 instruct rolI_eReg_Var_C0(ncxRegI dst, eCXRegI shift, immI0 zero, eFlagsReg cr) %{
 8518   match(Set dst ( OrI (LShiftI dst shift) (URShiftI dst (SubI zero shift))));
 8519 
 8520   expand %{
 8521     rolI_eReg_CL(dst, shift, cr);
 8522   %}
 8523 %}
 8524 
 8525 // ROL 32bit var by var once
 8526 instruct rolI_eReg_Var_C32(ncxRegI dst, eCXRegI shift, immI_32 c32, eFlagsReg cr) %{
 8527   match(Set dst ( OrI (LShiftI dst shift) (URShiftI dst (SubI c32 shift))));
 8528 
 8529   expand %{
 8530     rolI_eReg_CL(dst, shift, cr);
 8531   %}
 8532 %}
 8533 
 8534 // ROR expand
 8535 instruct rorI_eReg_imm1(rRegI dst, immI1 shift, eFlagsReg cr) %{
 8536   effect(USE_DEF dst, USE shift, KILL cr);
 8537 
 8538   format %{ &quot;ROR    $dst, $shift&quot; %}
 8539   opcode(0xD1,0x1);  /* Opcode D1 /1 */
 8540   ins_encode( OpcP, RegOpc( dst ) );
 8541   ins_pipe( ialu_reg );
 8542 %}
 8543 
 8544 instruct rorI_eReg_imm8(rRegI dst, immI8 shift, eFlagsReg cr) %{
 8545   effect (USE_DEF dst, USE shift, KILL cr);
 8546 
 8547   format %{ &quot;ROR    $dst, $shift&quot; %}
 8548   opcode(0xC1, 0x1); /* Opcode /C1 /1 ib */
 8549   ins_encode( RegOpcImm(dst, shift) );
 8550   ins_pipe( ialu_reg );
 8551 %}
 8552 
 8553 instruct rorI_eReg_CL(ncxRegI dst, eCXRegI shift, eFlagsReg cr)%{
 8554   effect(USE_DEF dst, USE shift, KILL cr);
 8555 
 8556   format %{ &quot;ROR    $dst, $shift&quot; %}
 8557   opcode(0xD3, 0x1);    /* Opcode D3 /1 */
 8558   ins_encode(OpcP, RegOpc(dst));
 8559   ins_pipe( ialu_reg_reg );
 8560 %}
 8561 // end of ROR expand
 8562 
 8563 // ROR right once
 8564 instruct rorI_eReg_i1(rRegI dst, immI1 rshift, immI_M1 lshift, eFlagsReg cr) %{
 8565   match(Set dst ( OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 8566 
 8567   expand %{
 8568     rorI_eReg_imm1(dst, rshift, cr);
 8569   %}
 8570 %}
 8571 
 8572 // ROR 32bit by immI8 once
 8573 instruct rorI_eReg_i8(rRegI dst, immI8 rshift, immI8 lshift, eFlagsReg cr) %{
 8574   predicate(  0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 8575   match(Set dst ( OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 8576 
 8577   expand %{
 8578     rorI_eReg_imm8(dst, rshift, cr);
 8579   %}
 8580 %}
 8581 
 8582 // ROR 32bit var by var once
 8583 instruct rorI_eReg_Var_C0(ncxRegI dst, eCXRegI shift, immI0 zero, eFlagsReg cr) %{
 8584   match(Set dst ( OrI (URShiftI dst shift) (LShiftI dst (SubI zero shift))));
 8585 
 8586   expand %{
 8587     rorI_eReg_CL(dst, shift, cr);
 8588   %}
 8589 %}
 8590 
 8591 // ROR 32bit var by var once
 8592 instruct rorI_eReg_Var_C32(ncxRegI dst, eCXRegI shift, immI_32 c32, eFlagsReg cr) %{
 8593   match(Set dst ( OrI (URShiftI dst shift) (LShiftI dst (SubI c32 shift))));
 8594 
 8595   expand %{
 8596     rorI_eReg_CL(dst, shift, cr);
 8597   %}
 8598 %}
 8599 
 8600 // Xor Instructions
 8601 // Xor Register with Register
 8602 instruct xorI_eReg(rRegI dst, rRegI src, eFlagsReg cr) %{
 8603   match(Set dst (XorI dst src));
 8604   effect(KILL cr);
 8605 
 8606   size(2);
 8607   format %{ &quot;XOR    $dst,$src&quot; %}
 8608   opcode(0x33);
 8609   ins_encode( OpcP, RegReg( dst, src) );
 8610   ins_pipe( ialu_reg_reg );
 8611 %}
 8612 
 8613 // Xor Register with Immediate -1
 8614 instruct xorI_eReg_im1(rRegI dst, immI_M1 imm) %{
 8615   match(Set dst (XorI dst imm));
 8616 
 8617   size(2);
 8618   format %{ &quot;NOT    $dst&quot; %}
 8619   ins_encode %{
 8620      __ notl($dst$$Register);
 8621   %}
 8622   ins_pipe( ialu_reg );
 8623 %}
 8624 
 8625 // Xor Register with Immediate
 8626 instruct xorI_eReg_imm(rRegI dst, immI src, eFlagsReg cr) %{
 8627   match(Set dst (XorI dst src));
 8628   effect(KILL cr);
 8629 
 8630   format %{ &quot;XOR    $dst,$src&quot; %}
 8631   opcode(0x81,0x06);  /* Opcode 81 /6 id */
 8632   // ins_encode( RegImm( dst, src) );
 8633   ins_encode( OpcSErm( dst, src ), Con8or32( src ) );
 8634   ins_pipe( ialu_reg );
 8635 %}
 8636 
 8637 // Xor Register with Memory
 8638 instruct xorI_eReg_mem(rRegI dst, memory src, eFlagsReg cr) %{
 8639   match(Set dst (XorI dst (LoadI src)));
 8640   effect(KILL cr);
 8641 
 8642   ins_cost(125);
 8643   format %{ &quot;XOR    $dst,$src&quot; %}
 8644   opcode(0x33);
 8645   ins_encode( OpcP, RegMem(dst, src) );
 8646   ins_pipe( ialu_reg_mem );
 8647 %}
 8648 
 8649 // Xor Memory with Register
 8650 instruct xorI_mem_eReg(memory dst, rRegI src, eFlagsReg cr) %{
 8651   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 8652   effect(KILL cr);
 8653 
 8654   ins_cost(150);
 8655   format %{ &quot;XOR    $dst,$src&quot; %}
 8656   opcode(0x31);  /* Opcode 31 /r */
 8657   ins_encode( OpcP, RegMem( src, dst ) );
 8658   ins_pipe( ialu_mem_reg );
 8659 %}
 8660 
 8661 // Xor Memory with Immediate
 8662 instruct xorI_mem_imm(memory dst, immI src, eFlagsReg cr) %{
 8663   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 8664   effect(KILL cr);
 8665 
 8666   ins_cost(125);
 8667   format %{ &quot;XOR    $dst,$src&quot; %}
 8668   opcode(0x81,0x6);  /* Opcode 81 /6 id */
 8669   ins_encode( OpcSE( src ), RMopc_Mem(secondary, dst ), Con8or32( src ) );
 8670   ins_pipe( ialu_mem_imm );
 8671 %}
 8672 
 8673 //----------Convert Int to Boolean---------------------------------------------
 8674 
 8675 instruct movI_nocopy(rRegI dst, rRegI src) %{
 8676   effect( DEF dst, USE src );
 8677   format %{ &quot;MOV    $dst,$src&quot; %}
 8678   ins_encode( enc_Copy( dst, src) );
 8679   ins_pipe( ialu_reg_reg );
 8680 %}
 8681 
 8682 instruct ci2b( rRegI dst, rRegI src, eFlagsReg cr ) %{
 8683   effect( USE_DEF dst, USE src, KILL cr );
 8684 
 8685   size(4);
 8686   format %{ &quot;NEG    $dst\n\t&quot;
 8687             &quot;ADC    $dst,$src&quot; %}
 8688   ins_encode( neg_reg(dst),
 8689               OpcRegReg(0x13,dst,src) );
 8690   ins_pipe( ialu_reg_reg_long );
 8691 %}
 8692 
 8693 instruct convI2B( rRegI dst, rRegI src, eFlagsReg cr ) %{
 8694   match(Set dst (Conv2B src));
 8695 
 8696   expand %{
 8697     movI_nocopy(dst,src);
 8698     ci2b(dst,src,cr);
 8699   %}
 8700 %}
 8701 
 8702 instruct movP_nocopy(rRegI dst, eRegP src) %{
 8703   effect( DEF dst, USE src );
 8704   format %{ &quot;MOV    $dst,$src&quot; %}
 8705   ins_encode( enc_Copy( dst, src) );
 8706   ins_pipe( ialu_reg_reg );
 8707 %}
 8708 
 8709 instruct cp2b( rRegI dst, eRegP src, eFlagsReg cr ) %{
 8710   effect( USE_DEF dst, USE src, KILL cr );
 8711   format %{ &quot;NEG    $dst\n\t&quot;
 8712             &quot;ADC    $dst,$src&quot; %}
 8713   ins_encode( neg_reg(dst),
 8714               OpcRegReg(0x13,dst,src) );
 8715   ins_pipe( ialu_reg_reg_long );
 8716 %}
 8717 
 8718 instruct convP2B( rRegI dst, eRegP src, eFlagsReg cr ) %{
 8719   match(Set dst (Conv2B src));
 8720 
 8721   expand %{
 8722     movP_nocopy(dst,src);
 8723     cp2b(dst,src,cr);
 8724   %}
 8725 %}
 8726 
 8727 instruct cmpLTMask(eCXRegI dst, ncxRegI p, ncxRegI q, eFlagsReg cr) %{
 8728   match(Set dst (CmpLTMask p q));
 8729   effect(KILL cr);
 8730   ins_cost(400);
 8731 
 8732   // SETlt can only use low byte of EAX,EBX, ECX, or EDX as destination
 8733   format %{ &quot;XOR    $dst,$dst\n\t&quot;
 8734             &quot;CMP    $p,$q\n\t&quot;
 8735             &quot;SETlt  $dst\n\t&quot;
 8736             &quot;NEG    $dst&quot; %}
 8737   ins_encode %{
 8738     Register Rp = $p$$Register;
 8739     Register Rq = $q$$Register;
 8740     Register Rd = $dst$$Register;
 8741     Label done;
 8742     __ xorl(Rd, Rd);
 8743     __ cmpl(Rp, Rq);
 8744     __ setb(Assembler::less, Rd);
 8745     __ negl(Rd);
 8746   %}
 8747 
 8748   ins_pipe(pipe_slow);
 8749 %}
 8750 
 8751 instruct cmpLTMask0(rRegI dst, immI0 zero, eFlagsReg cr) %{
 8752   match(Set dst (CmpLTMask dst zero));
 8753   effect(DEF dst, KILL cr);
 8754   ins_cost(100);
 8755 
 8756   format %{ &quot;SAR    $dst,31\t# cmpLTMask0&quot; %}
 8757   ins_encode %{
 8758   __ sarl($dst$$Register, 31);
 8759   %}
 8760   ins_pipe(ialu_reg);
 8761 %}
 8762 
 8763 /* better to save a register than avoid a branch */
 8764 instruct cadd_cmpLTMask(rRegI p, rRegI q, rRegI y, eFlagsReg cr) %{
 8765   match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
 8766   effect(KILL cr);
 8767   ins_cost(400);
 8768   format %{ &quot;SUB    $p,$q\t# cadd_cmpLTMask\n\t&quot;
 8769             &quot;JGE    done\n\t&quot;
 8770             &quot;ADD    $p,$y\n&quot;
 8771             &quot;done:  &quot; %}
 8772   ins_encode %{
 8773     Register Rp = $p$$Register;
 8774     Register Rq = $q$$Register;
 8775     Register Ry = $y$$Register;
 8776     Label done;
 8777     __ subl(Rp, Rq);
 8778     __ jccb(Assembler::greaterEqual, done);
 8779     __ addl(Rp, Ry);
 8780     __ bind(done);
 8781   %}
 8782 
 8783   ins_pipe(pipe_cmplt);
 8784 %}
 8785 
 8786 /* better to save a register than avoid a branch */
 8787 instruct and_cmpLTMask(rRegI p, rRegI q, rRegI y, eFlagsReg cr) %{
 8788   match(Set y (AndI (CmpLTMask p q) y));
 8789   effect(KILL cr);
 8790 
 8791   ins_cost(300);
 8792 
 8793   format %{ &quot;CMPL     $p, $q\t# and_cmpLTMask\n\t&quot;
 8794             &quot;JLT      done\n\t&quot;
 8795             &quot;XORL     $y, $y\n&quot;
 8796             &quot;done:  &quot; %}
 8797   ins_encode %{
 8798     Register Rp = $p$$Register;
 8799     Register Rq = $q$$Register;
 8800     Register Ry = $y$$Register;
 8801     Label done;
 8802     __ cmpl(Rp, Rq);
 8803     __ jccb(Assembler::less, done);
 8804     __ xorl(Ry, Ry);
 8805     __ bind(done);
 8806   %}
 8807 
 8808   ins_pipe(pipe_cmplt);
 8809 %}
 8810 
 8811 /* If I enable this, I encourage spilling in the inner loop of compress.
 8812 instruct cadd_cmpLTMask_mem(ncxRegI p, ncxRegI q, memory y, eCXRegI tmp, eFlagsReg cr) %{
 8813   match(Set p (AddI (AndI (CmpLTMask p q) (LoadI y)) (SubI p q)));
 8814 */
 8815 //----------Overflow Math Instructions-----------------------------------------
 8816 
 8817 instruct overflowAddI_eReg(eFlagsReg cr, eAXRegI op1, rRegI op2)
 8818 %{
 8819   match(Set cr (OverflowAddI op1 op2));
 8820   effect(DEF cr, USE_KILL op1, USE op2);
 8821 
 8822   format %{ &quot;ADD    $op1, $op2\t# overflow check int&quot; %}
 8823 
 8824   ins_encode %{
 8825     __ addl($op1$$Register, $op2$$Register);
 8826   %}
 8827   ins_pipe(ialu_reg_reg);
 8828 %}
 8829 
 8830 instruct overflowAddI_rReg_imm(eFlagsReg cr, eAXRegI op1, immI op2)
 8831 %{
 8832   match(Set cr (OverflowAddI op1 op2));
 8833   effect(DEF cr, USE_KILL op1, USE op2);
 8834 
 8835   format %{ &quot;ADD    $op1, $op2\t# overflow check int&quot; %}
 8836 
 8837   ins_encode %{
 8838     __ addl($op1$$Register, $op2$$constant);
 8839   %}
 8840   ins_pipe(ialu_reg_reg);
 8841 %}
 8842 
 8843 instruct overflowSubI_rReg(eFlagsReg cr, rRegI op1, rRegI op2)
 8844 %{
 8845   match(Set cr (OverflowSubI op1 op2));
 8846 
 8847   format %{ &quot;CMP    $op1, $op2\t# overflow check int&quot; %}
 8848   ins_encode %{
 8849     __ cmpl($op1$$Register, $op2$$Register);
 8850   %}
 8851   ins_pipe(ialu_reg_reg);
 8852 %}
 8853 
 8854 instruct overflowSubI_rReg_imm(eFlagsReg cr, rRegI op1, immI op2)
 8855 %{
 8856   match(Set cr (OverflowSubI op1 op2));
 8857 
 8858   format %{ &quot;CMP    $op1, $op2\t# overflow check int&quot; %}
 8859   ins_encode %{
 8860     __ cmpl($op1$$Register, $op2$$constant);
 8861   %}
 8862   ins_pipe(ialu_reg_reg);
 8863 %}
 8864 
 8865 instruct overflowNegI_rReg(eFlagsReg cr, immI0 zero, eAXRegI op2)
 8866 %{
 8867   match(Set cr (OverflowSubI zero op2));
 8868   effect(DEF cr, USE_KILL op2);
 8869 
 8870   format %{ &quot;NEG    $op2\t# overflow check int&quot; %}
 8871   ins_encode %{
 8872     __ negl($op2$$Register);
 8873   %}
 8874   ins_pipe(ialu_reg_reg);
 8875 %}
 8876 
 8877 instruct overflowMulI_rReg(eFlagsReg cr, eAXRegI op1, rRegI op2)
 8878 %{
 8879   match(Set cr (OverflowMulI op1 op2));
 8880   effect(DEF cr, USE_KILL op1, USE op2);
 8881 
 8882   format %{ &quot;IMUL    $op1, $op2\t# overflow check int&quot; %}
 8883   ins_encode %{
 8884     __ imull($op1$$Register, $op2$$Register);
 8885   %}
 8886   ins_pipe(ialu_reg_reg_alu0);
 8887 %}
 8888 
 8889 instruct overflowMulI_rReg_imm(eFlagsReg cr, rRegI op1, immI op2, rRegI tmp)
 8890 %{
 8891   match(Set cr (OverflowMulI op1 op2));
 8892   effect(DEF cr, TEMP tmp, USE op1, USE op2);
 8893 
 8894   format %{ &quot;IMUL    $tmp, $op1, $op2\t# overflow check int&quot; %}
 8895   ins_encode %{
 8896     __ imull($tmp$$Register, $op1$$Register, $op2$$constant);
 8897   %}
 8898   ins_pipe(ialu_reg_reg_alu0);
 8899 %}
 8900 
 8901 // Integer Absolute Instructions
 8902 instruct absI_rReg(rRegI dst, rRegI src, rRegI tmp, eFlagsReg cr)
 8903 %{
 8904   match(Set dst (AbsI src));
 8905   effect(TEMP dst, TEMP tmp, KILL cr);
 8906   format %{ &quot;movl $tmp, $src\n\t&quot;
 8907             &quot;sarl $tmp, 31\n\t&quot;
 8908             &quot;movl $dst, $src\n\t&quot;
 8909             &quot;xorl $dst, $tmp\n\t&quot;
 8910             &quot;subl $dst, $tmp\n&quot;
 8911           %}
 8912   ins_encode %{
 8913     __ movl($tmp$$Register, $src$$Register);
 8914     __ sarl($tmp$$Register, 31);
 8915     __ movl($dst$$Register, $src$$Register);
 8916     __ xorl($dst$$Register, $tmp$$Register);
 8917     __ subl($dst$$Register, $tmp$$Register);
 8918   %}
 8919 
 8920   ins_pipe(ialu_reg_reg);
 8921 %}
 8922 
 8923 //----------Long Instructions------------------------------------------------
 8924 // Add Long Register with Register
 8925 instruct addL_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 8926   match(Set dst (AddL dst src));
 8927   effect(KILL cr);
 8928   ins_cost(200);
 8929   format %{ &quot;ADD    $dst.lo,$src.lo\n\t&quot;
 8930             &quot;ADC    $dst.hi,$src.hi&quot; %}
 8931   opcode(0x03, 0x13);
 8932   ins_encode( RegReg_Lo(dst, src), RegReg_Hi(dst,src) );
 8933   ins_pipe( ialu_reg_reg_long );
 8934 %}
 8935 
 8936 // Add Long Register with Immediate
 8937 instruct addL_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 8938   match(Set dst (AddL dst src));
 8939   effect(KILL cr);
 8940   format %{ &quot;ADD    $dst.lo,$src.lo\n\t&quot;
 8941             &quot;ADC    $dst.hi,$src.hi&quot; %}
 8942   opcode(0x81,0x00,0x02);  /* Opcode 81 /0, 81 /2 */
 8943   ins_encode( Long_OpcSErm_Lo( dst, src ), Long_OpcSErm_Hi( dst, src ) );
 8944   ins_pipe( ialu_reg_long );
 8945 %}
 8946 
 8947 // Add Long Register with Memory
 8948 instruct addL_eReg_mem(eRegL dst, load_long_memory mem, eFlagsReg cr) %{
 8949   match(Set dst (AddL dst (LoadL mem)));
 8950   effect(KILL cr);
 8951   ins_cost(125);
 8952   format %{ &quot;ADD    $dst.lo,$mem\n\t&quot;
 8953             &quot;ADC    $dst.hi,$mem+4&quot; %}
 8954   opcode(0x03, 0x13);
 8955   ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );
 8956   ins_pipe( ialu_reg_long_mem );
 8957 %}
 8958 
 8959 // Subtract Long Register with Register.
 8960 instruct subL_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 8961   match(Set dst (SubL dst src));
 8962   effect(KILL cr);
 8963   ins_cost(200);
 8964   format %{ &quot;SUB    $dst.lo,$src.lo\n\t&quot;
 8965             &quot;SBB    $dst.hi,$src.hi&quot; %}
 8966   opcode(0x2B, 0x1B);
 8967   ins_encode( RegReg_Lo(dst, src), RegReg_Hi(dst,src) );
 8968   ins_pipe( ialu_reg_reg_long );
 8969 %}
 8970 
 8971 // Subtract Long Register with Immediate
 8972 instruct subL_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 8973   match(Set dst (SubL dst src));
 8974   effect(KILL cr);
 8975   format %{ &quot;SUB    $dst.lo,$src.lo\n\t&quot;
 8976             &quot;SBB    $dst.hi,$src.hi&quot; %}
 8977   opcode(0x81,0x05,0x03);  /* Opcode 81 /5, 81 /3 */
 8978   ins_encode( Long_OpcSErm_Lo( dst, src ), Long_OpcSErm_Hi( dst, src ) );
 8979   ins_pipe( ialu_reg_long );
 8980 %}
 8981 
 8982 // Subtract Long Register with Memory
 8983 instruct subL_eReg_mem(eRegL dst, load_long_memory mem, eFlagsReg cr) %{
 8984   match(Set dst (SubL dst (LoadL mem)));
 8985   effect(KILL cr);
 8986   ins_cost(125);
 8987   format %{ &quot;SUB    $dst.lo,$mem\n\t&quot;
 8988             &quot;SBB    $dst.hi,$mem+4&quot; %}
 8989   opcode(0x2B, 0x1B);
 8990   ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );
 8991   ins_pipe( ialu_reg_long_mem );
 8992 %}
 8993 
 8994 instruct negL_eReg(eRegL dst, immL0 zero, eFlagsReg cr) %{
 8995   match(Set dst (SubL zero dst));
 8996   effect(KILL cr);
 8997   ins_cost(300);
 8998   format %{ &quot;NEG    $dst.hi\n\tNEG    $dst.lo\n\tSBB    $dst.hi,0&quot; %}
 8999   ins_encode( neg_long(dst) );
 9000   ins_pipe( ialu_reg_reg_long );
 9001 %}
 9002 
 9003 // And Long Register with Register
 9004 instruct andL_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 9005   match(Set dst (AndL dst src));
 9006   effect(KILL cr);
 9007   format %{ &quot;AND    $dst.lo,$src.lo\n\t&quot;
 9008             &quot;AND    $dst.hi,$src.hi&quot; %}
 9009   opcode(0x23,0x23);
 9010   ins_encode( RegReg_Lo( dst, src), RegReg_Hi( dst, src) );
 9011   ins_pipe( ialu_reg_reg_long );
 9012 %}
 9013 
 9014 // And Long Register with Immediate
 9015 instruct andL_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 9016   match(Set dst (AndL dst src));
 9017   effect(KILL cr);
 9018   format %{ &quot;AND    $dst.lo,$src.lo\n\t&quot;
 9019             &quot;AND    $dst.hi,$src.hi&quot; %}
 9020   opcode(0x81,0x04,0x04);  /* Opcode 81 /4, 81 /4 */
 9021   ins_encode( Long_OpcSErm_Lo( dst, src ), Long_OpcSErm_Hi( dst, src ) );
 9022   ins_pipe( ialu_reg_long );
 9023 %}
 9024 
 9025 // And Long Register with Memory
 9026 instruct andL_eReg_mem(eRegL dst, load_long_memory mem, eFlagsReg cr) %{
 9027   match(Set dst (AndL dst (LoadL mem)));
 9028   effect(KILL cr);
 9029   ins_cost(125);
 9030   format %{ &quot;AND    $dst.lo,$mem\n\t&quot;
 9031             &quot;AND    $dst.hi,$mem+4&quot; %}
 9032   opcode(0x23, 0x23);
 9033   ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );
 9034   ins_pipe( ialu_reg_long_mem );
 9035 %}
 9036 
 9037 // BMI1 instructions
 9038 instruct andnL_eReg_eReg_eReg(eRegL dst, eRegL src1, eRegL src2, immL_M1 minus_1, eFlagsReg cr) %{
 9039   match(Set dst (AndL (XorL src1 minus_1) src2));
 9040   predicate(UseBMI1Instructions);
 9041   effect(KILL cr, TEMP dst);
 9042 
 9043   format %{ &quot;ANDNL  $dst.lo, $src1.lo, $src2.lo\n\t&quot;
 9044             &quot;ANDNL  $dst.hi, $src1.hi, $src2.hi&quot;
 9045          %}
 9046 
 9047   ins_encode %{
 9048     Register Rdst = $dst$$Register;
 9049     Register Rsrc1 = $src1$$Register;
 9050     Register Rsrc2 = $src2$$Register;
 9051     __ andnl(Rdst, Rsrc1, Rsrc2);
 9052     __ andnl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc1), HIGH_FROM_LOW(Rsrc2));
 9053   %}
 9054   ins_pipe(ialu_reg_reg_long);
 9055 %}
 9056 
 9057 instruct andnL_eReg_eReg_mem(eRegL dst, eRegL src1, memory src2, immL_M1 minus_1, eFlagsReg cr) %{
 9058   match(Set dst (AndL (XorL src1 minus_1) (LoadL src2) ));
 9059   predicate(UseBMI1Instructions);
 9060   effect(KILL cr, TEMP dst);
 9061 
 9062   ins_cost(125);
 9063   format %{ &quot;ANDNL  $dst.lo, $src1.lo, $src2\n\t&quot;
 9064             &quot;ANDNL  $dst.hi, $src1.hi, $src2+4&quot;
 9065          %}
 9066 
 9067   ins_encode %{
 9068     Register Rdst = $dst$$Register;
 9069     Register Rsrc1 = $src1$$Register;
 9070     Address src2_hi = Address::make_raw($src2$$base, $src2$$index, $src2$$scale, $src2$$disp + 4, relocInfo::none);
 9071 
 9072     __ andnl(Rdst, Rsrc1, $src2$$Address);
 9073     __ andnl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc1), src2_hi);
 9074   %}
 9075   ins_pipe(ialu_reg_mem);
 9076 %}
 9077 
 9078 instruct blsiL_eReg_eReg(eRegL dst, eRegL src, immL0 imm_zero, eFlagsReg cr) %{
 9079   match(Set dst (AndL (SubL imm_zero src) src));
 9080   predicate(UseBMI1Instructions);
 9081   effect(KILL cr, TEMP dst);
 9082 
 9083   format %{ &quot;MOVL   $dst.hi, 0\n\t&quot;
 9084             &quot;BLSIL  $dst.lo, $src.lo\n\t&quot;
 9085             &quot;JNZ    done\n\t&quot;
 9086             &quot;BLSIL  $dst.hi, $src.hi\n&quot;
 9087             &quot;done:&quot;
 9088          %}
 9089 
 9090   ins_encode %{
 9091     Label done;
 9092     Register Rdst = $dst$$Register;
 9093     Register Rsrc = $src$$Register;
 9094     __ movl(HIGH_FROM_LOW(Rdst), 0);
 9095     __ blsil(Rdst, Rsrc);
 9096     __ jccb(Assembler::notZero, done);
 9097     __ blsil(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc));
 9098     __ bind(done);
 9099   %}
 9100   ins_pipe(ialu_reg);
 9101 %}
 9102 
 9103 instruct blsiL_eReg_mem(eRegL dst, memory src, immL0 imm_zero, eFlagsReg cr) %{
 9104   match(Set dst (AndL (SubL imm_zero (LoadL src) ) (LoadL src) ));
 9105   predicate(UseBMI1Instructions);
 9106   effect(KILL cr, TEMP dst);
 9107 
 9108   ins_cost(125);
 9109   format %{ &quot;MOVL   $dst.hi, 0\n\t&quot;
 9110             &quot;BLSIL  $dst.lo, $src\n\t&quot;
 9111             &quot;JNZ    done\n\t&quot;
 9112             &quot;BLSIL  $dst.hi, $src+4\n&quot;
 9113             &quot;done:&quot;
 9114          %}
 9115 
 9116   ins_encode %{
 9117     Label done;
 9118     Register Rdst = $dst$$Register;
 9119     Address src_hi = Address::make_raw($src$$base, $src$$index, $src$$scale, $src$$disp + 4, relocInfo::none);
 9120 
 9121     __ movl(HIGH_FROM_LOW(Rdst), 0);
 9122     __ blsil(Rdst, $src$$Address);
 9123     __ jccb(Assembler::notZero, done);
 9124     __ blsil(HIGH_FROM_LOW(Rdst), src_hi);
 9125     __ bind(done);
 9126   %}
 9127   ins_pipe(ialu_reg_mem);
 9128 %}
 9129 
 9130 instruct blsmskL_eReg_eReg(eRegL dst, eRegL src, immL_M1 minus_1, eFlagsReg cr)
 9131 %{
 9132   match(Set dst (XorL (AddL src minus_1) src));
 9133   predicate(UseBMI1Instructions);
 9134   effect(KILL cr, TEMP dst);
 9135 
 9136   format %{ &quot;MOVL    $dst.hi, 0\n\t&quot;
 9137             &quot;BLSMSKL $dst.lo, $src.lo\n\t&quot;
 9138             &quot;JNC     done\n\t&quot;
 9139             &quot;BLSMSKL $dst.hi, $src.hi\n&quot;
 9140             &quot;done:&quot;
 9141          %}
 9142 
 9143   ins_encode %{
 9144     Label done;
 9145     Register Rdst = $dst$$Register;
 9146     Register Rsrc = $src$$Register;
 9147     __ movl(HIGH_FROM_LOW(Rdst), 0);
 9148     __ blsmskl(Rdst, Rsrc);
 9149     __ jccb(Assembler::carryClear, done);
 9150     __ blsmskl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc));
 9151     __ bind(done);
 9152   %}
 9153 
 9154   ins_pipe(ialu_reg);
 9155 %}
 9156 
 9157 instruct blsmskL_eReg_mem(eRegL dst, memory src, immL_M1 minus_1, eFlagsReg cr)
 9158 %{
 9159   match(Set dst (XorL (AddL (LoadL src) minus_1) (LoadL src) ));
 9160   predicate(UseBMI1Instructions);
 9161   effect(KILL cr, TEMP dst);
 9162 
 9163   ins_cost(125);
 9164   format %{ &quot;MOVL    $dst.hi, 0\n\t&quot;
 9165             &quot;BLSMSKL $dst.lo, $src\n\t&quot;
 9166             &quot;JNC     done\n\t&quot;
 9167             &quot;BLSMSKL $dst.hi, $src+4\n&quot;
 9168             &quot;done:&quot;
 9169          %}
 9170 
 9171   ins_encode %{
 9172     Label done;
 9173     Register Rdst = $dst$$Register;
 9174     Address src_hi = Address::make_raw($src$$base, $src$$index, $src$$scale, $src$$disp + 4, relocInfo::none);
 9175 
 9176     __ movl(HIGH_FROM_LOW(Rdst), 0);
 9177     __ blsmskl(Rdst, $src$$Address);
 9178     __ jccb(Assembler::carryClear, done);
 9179     __ blsmskl(HIGH_FROM_LOW(Rdst), src_hi);
 9180     __ bind(done);
 9181   %}
 9182 
 9183   ins_pipe(ialu_reg_mem);
 9184 %}
 9185 
 9186 instruct blsrL_eReg_eReg(eRegL dst, eRegL src, immL_M1 minus_1, eFlagsReg cr)
 9187 %{
 9188   match(Set dst (AndL (AddL src minus_1) src) );
 9189   predicate(UseBMI1Instructions);
 9190   effect(KILL cr, TEMP dst);
 9191 
 9192   format %{ &quot;MOVL   $dst.hi, $src.hi\n\t&quot;
 9193             &quot;BLSRL  $dst.lo, $src.lo\n\t&quot;
 9194             &quot;JNC    done\n\t&quot;
 9195             &quot;BLSRL  $dst.hi, $src.hi\n&quot;
 9196             &quot;done:&quot;
 9197   %}
 9198 
 9199   ins_encode %{
 9200     Label done;
 9201     Register Rdst = $dst$$Register;
 9202     Register Rsrc = $src$$Register;
 9203     __ movl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc));
 9204     __ blsrl(Rdst, Rsrc);
 9205     __ jccb(Assembler::carryClear, done);
 9206     __ blsrl(HIGH_FROM_LOW(Rdst), HIGH_FROM_LOW(Rsrc));
 9207     __ bind(done);
 9208   %}
 9209 
 9210   ins_pipe(ialu_reg);
 9211 %}
 9212 
 9213 instruct blsrL_eReg_mem(eRegL dst, memory src, immL_M1 minus_1, eFlagsReg cr)
 9214 %{
 9215   match(Set dst (AndL (AddL (LoadL src) minus_1) (LoadL src) ));
 9216   predicate(UseBMI1Instructions);
 9217   effect(KILL cr, TEMP dst);
 9218 
 9219   ins_cost(125);
 9220   format %{ &quot;MOVL   $dst.hi, $src+4\n\t&quot;
 9221             &quot;BLSRL  $dst.lo, $src\n\t&quot;
 9222             &quot;JNC    done\n\t&quot;
 9223             &quot;BLSRL  $dst.hi, $src+4\n&quot;
 9224             &quot;done:&quot;
 9225   %}
 9226 
 9227   ins_encode %{
 9228     Label done;
 9229     Register Rdst = $dst$$Register;
 9230     Address src_hi = Address::make_raw($src$$base, $src$$index, $src$$scale, $src$$disp + 4, relocInfo::none);
 9231     __ movl(HIGH_FROM_LOW(Rdst), src_hi);
 9232     __ blsrl(Rdst, $src$$Address);
 9233     __ jccb(Assembler::carryClear, done);
 9234     __ blsrl(HIGH_FROM_LOW(Rdst), src_hi);
 9235     __ bind(done);
 9236   %}
 9237 
 9238   ins_pipe(ialu_reg_mem);
 9239 %}
 9240 
 9241 // Or Long Register with Register
 9242 instruct orl_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 9243   match(Set dst (OrL dst src));
 9244   effect(KILL cr);
 9245   format %{ &quot;OR     $dst.lo,$src.lo\n\t&quot;
 9246             &quot;OR     $dst.hi,$src.hi&quot; %}
 9247   opcode(0x0B,0x0B);
 9248   ins_encode( RegReg_Lo( dst, src), RegReg_Hi( dst, src) );
 9249   ins_pipe( ialu_reg_reg_long );
 9250 %}
 9251 
 9252 // Or Long Register with Immediate
 9253 instruct orl_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 9254   match(Set dst (OrL dst src));
 9255   effect(KILL cr);
 9256   format %{ &quot;OR     $dst.lo,$src.lo\n\t&quot;
 9257             &quot;OR     $dst.hi,$src.hi&quot; %}
 9258   opcode(0x81,0x01,0x01);  /* Opcode 81 /1, 81 /1 */
 9259   ins_encode( Long_OpcSErm_Lo( dst, src ), Long_OpcSErm_Hi( dst, src ) );
 9260   ins_pipe( ialu_reg_long );
 9261 %}
 9262 
 9263 // Or Long Register with Memory
 9264 instruct orl_eReg_mem(eRegL dst, load_long_memory mem, eFlagsReg cr) %{
 9265   match(Set dst (OrL dst (LoadL mem)));
 9266   effect(KILL cr);
 9267   ins_cost(125);
 9268   format %{ &quot;OR     $dst.lo,$mem\n\t&quot;
 9269             &quot;OR     $dst.hi,$mem+4&quot; %}
 9270   opcode(0x0B,0x0B);
 9271   ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );
 9272   ins_pipe( ialu_reg_long_mem );
 9273 %}
 9274 
 9275 // Xor Long Register with Register
 9276 instruct xorl_eReg(eRegL dst, eRegL src, eFlagsReg cr) %{
 9277   match(Set dst (XorL dst src));
 9278   effect(KILL cr);
 9279   format %{ &quot;XOR    $dst.lo,$src.lo\n\t&quot;
 9280             &quot;XOR    $dst.hi,$src.hi&quot; %}
 9281   opcode(0x33,0x33);
 9282   ins_encode( RegReg_Lo( dst, src), RegReg_Hi( dst, src) );
 9283   ins_pipe( ialu_reg_reg_long );
 9284 %}
 9285 
 9286 // Xor Long Register with Immediate -1
 9287 instruct xorl_eReg_im1(eRegL dst, immL_M1 imm) %{
 9288   match(Set dst (XorL dst imm));
 9289   format %{ &quot;NOT    $dst.lo\n\t&quot;
 9290             &quot;NOT    $dst.hi&quot; %}
 9291   ins_encode %{
 9292      __ notl($dst$$Register);
 9293      __ notl(HIGH_FROM_LOW($dst$$Register));
 9294   %}
 9295   ins_pipe( ialu_reg_long );
 9296 %}
 9297 
 9298 // Xor Long Register with Immediate
 9299 instruct xorl_eReg_imm(eRegL dst, immL src, eFlagsReg cr) %{
 9300   match(Set dst (XorL dst src));
 9301   effect(KILL cr);
 9302   format %{ &quot;XOR    $dst.lo,$src.lo\n\t&quot;
 9303             &quot;XOR    $dst.hi,$src.hi&quot; %}
 9304   opcode(0x81,0x06,0x06);  /* Opcode 81 /6, 81 /6 */
 9305   ins_encode( Long_OpcSErm_Lo( dst, src ), Long_OpcSErm_Hi( dst, src ) );
 9306   ins_pipe( ialu_reg_long );
 9307 %}
 9308 
 9309 // Xor Long Register with Memory
 9310 instruct xorl_eReg_mem(eRegL dst, load_long_memory mem, eFlagsReg cr) %{
 9311   match(Set dst (XorL dst (LoadL mem)));
 9312   effect(KILL cr);
 9313   ins_cost(125);
 9314   format %{ &quot;XOR    $dst.lo,$mem\n\t&quot;
 9315             &quot;XOR    $dst.hi,$mem+4&quot; %}
 9316   opcode(0x33,0x33);
 9317   ins_encode( OpcP, RegMem( dst, mem), OpcS, RegMem_Hi(dst,mem) );
 9318   ins_pipe( ialu_reg_long_mem );
 9319 %}
 9320 
 9321 // Shift Left Long by 1
 9322 instruct shlL_eReg_1(eRegL dst, immI_1 cnt, eFlagsReg cr) %{
 9323   predicate(UseNewLongLShift);
 9324   match(Set dst (LShiftL dst cnt));
 9325   effect(KILL cr);
 9326   ins_cost(100);
 9327   format %{ &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9328             &quot;ADC    $dst.hi,$dst.hi&quot; %}
 9329   ins_encode %{
 9330     __ addl($dst$$Register,$dst$$Register);
 9331     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9332   %}
 9333   ins_pipe( ialu_reg_long );
 9334 %}
 9335 
 9336 // Shift Left Long by 2
 9337 instruct shlL_eReg_2(eRegL dst, immI_2 cnt, eFlagsReg cr) %{
 9338   predicate(UseNewLongLShift);
 9339   match(Set dst (LShiftL dst cnt));
 9340   effect(KILL cr);
 9341   ins_cost(100);
 9342   format %{ &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9343             &quot;ADC    $dst.hi,$dst.hi\n\t&quot;
 9344             &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9345             &quot;ADC    $dst.hi,$dst.hi&quot; %}
 9346   ins_encode %{
 9347     __ addl($dst$$Register,$dst$$Register);
 9348     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9349     __ addl($dst$$Register,$dst$$Register);
 9350     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9351   %}
 9352   ins_pipe( ialu_reg_long );
 9353 %}
 9354 
 9355 // Shift Left Long by 3
 9356 instruct shlL_eReg_3(eRegL dst, immI_3 cnt, eFlagsReg cr) %{
 9357   predicate(UseNewLongLShift);
 9358   match(Set dst (LShiftL dst cnt));
 9359   effect(KILL cr);
 9360   ins_cost(100);
 9361   format %{ &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9362             &quot;ADC    $dst.hi,$dst.hi\n\t&quot;
 9363             &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9364             &quot;ADC    $dst.hi,$dst.hi\n\t&quot;
 9365             &quot;ADD    $dst.lo,$dst.lo\n\t&quot;
 9366             &quot;ADC    $dst.hi,$dst.hi&quot; %}
 9367   ins_encode %{
 9368     __ addl($dst$$Register,$dst$$Register);
 9369     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9370     __ addl($dst$$Register,$dst$$Register);
 9371     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9372     __ addl($dst$$Register,$dst$$Register);
 9373     __ adcl(HIGH_FROM_LOW($dst$$Register),HIGH_FROM_LOW($dst$$Register));
 9374   %}
 9375   ins_pipe( ialu_reg_long );
 9376 %}
 9377 
 9378 // Shift Left Long by 1-31
 9379 instruct shlL_eReg_1_31(eRegL dst, immI_1_31 cnt, eFlagsReg cr) %{
 9380   match(Set dst (LShiftL dst cnt));
 9381   effect(KILL cr);
 9382   ins_cost(200);
 9383   format %{ &quot;SHLD   $dst.hi,$dst.lo,$cnt\n\t&quot;
 9384             &quot;SHL    $dst.lo,$cnt&quot; %}
 9385   opcode(0xC1, 0x4, 0xA4);  /* 0F/A4, then C1 /4 ib */
 9386   ins_encode( move_long_small_shift(dst,cnt) );
 9387   ins_pipe( ialu_reg_long );
 9388 %}
 9389 
 9390 // Shift Left Long by 32-63
 9391 instruct shlL_eReg_32_63(eRegL dst, immI_32_63 cnt, eFlagsReg cr) %{
 9392   match(Set dst (LShiftL dst cnt));
 9393   effect(KILL cr);
 9394   ins_cost(300);
 9395   format %{ &quot;MOV    $dst.hi,$dst.lo\n&quot;
 9396           &quot;\tSHL    $dst.hi,$cnt-32\n&quot;
 9397           &quot;\tXOR    $dst.lo,$dst.lo&quot; %}
 9398   opcode(0xC1, 0x4);  /* C1 /4 ib */
 9399   ins_encode( move_long_big_shift_clr(dst,cnt) );
 9400   ins_pipe( ialu_reg_long );
 9401 %}
 9402 
 9403 // Shift Left Long by variable
 9404 instruct salL_eReg_CL(eRegL dst, eCXRegI shift, eFlagsReg cr) %{
 9405   match(Set dst (LShiftL dst shift));
 9406   effect(KILL cr);
 9407   ins_cost(500+200);
 9408   size(17);
 9409   format %{ &quot;TEST   $shift,32\n\t&quot;
 9410             &quot;JEQ,s  small\n\t&quot;
 9411             &quot;MOV    $dst.hi,$dst.lo\n\t&quot;
 9412             &quot;XOR    $dst.lo,$dst.lo\n&quot;
 9413     &quot;small:\tSHLD   $dst.hi,$dst.lo,$shift\n\t&quot;
 9414             &quot;SHL    $dst.lo,$shift&quot; %}
 9415   ins_encode( shift_left_long( dst, shift ) );
 9416   ins_pipe( pipe_slow );
 9417 %}
 9418 
 9419 // Shift Right Long by 1-31
 9420 instruct shrL_eReg_1_31(eRegL dst, immI_1_31 cnt, eFlagsReg cr) %{
 9421   match(Set dst (URShiftL dst cnt));
 9422   effect(KILL cr);
 9423   ins_cost(200);
 9424   format %{ &quot;SHRD   $dst.lo,$dst.hi,$cnt\n\t&quot;
 9425             &quot;SHR    $dst.hi,$cnt&quot; %}
 9426   opcode(0xC1, 0x5, 0xAC);  /* 0F/AC, then C1 /5 ib */
 9427   ins_encode( move_long_small_shift(dst,cnt) );
 9428   ins_pipe( ialu_reg_long );
 9429 %}
 9430 
 9431 // Shift Right Long by 32-63
 9432 instruct shrL_eReg_32_63(eRegL dst, immI_32_63 cnt, eFlagsReg cr) %{
 9433   match(Set dst (URShiftL dst cnt));
 9434   effect(KILL cr);
 9435   ins_cost(300);
 9436   format %{ &quot;MOV    $dst.lo,$dst.hi\n&quot;
 9437           &quot;\tSHR    $dst.lo,$cnt-32\n&quot;
 9438           &quot;\tXOR    $dst.hi,$dst.hi&quot; %}
 9439   opcode(0xC1, 0x5);  /* C1 /5 ib */
 9440   ins_encode( move_long_big_shift_clr(dst,cnt) );
 9441   ins_pipe( ialu_reg_long );
 9442 %}
 9443 
 9444 // Shift Right Long by variable
 9445 instruct shrL_eReg_CL(eRegL dst, eCXRegI shift, eFlagsReg cr) %{
 9446   match(Set dst (URShiftL dst shift));
 9447   effect(KILL cr);
 9448   ins_cost(600);
 9449   size(17);
 9450   format %{ &quot;TEST   $shift,32\n\t&quot;
 9451             &quot;JEQ,s  small\n\t&quot;
 9452             &quot;MOV    $dst.lo,$dst.hi\n\t&quot;
 9453             &quot;XOR    $dst.hi,$dst.hi\n&quot;
 9454     &quot;small:\tSHRD   $dst.lo,$dst.hi,$shift\n\t&quot;
 9455             &quot;SHR    $dst.hi,$shift&quot; %}
 9456   ins_encode( shift_right_long( dst, shift ) );
 9457   ins_pipe( pipe_slow );
 9458 %}
 9459 
 9460 // Shift Right Long by 1-31
 9461 instruct sarL_eReg_1_31(eRegL dst, immI_1_31 cnt, eFlagsReg cr) %{
 9462   match(Set dst (RShiftL dst cnt));
 9463   effect(KILL cr);
 9464   ins_cost(200);
 9465   format %{ &quot;SHRD   $dst.lo,$dst.hi,$cnt\n\t&quot;
 9466             &quot;SAR    $dst.hi,$cnt&quot; %}
 9467   opcode(0xC1, 0x7, 0xAC);  /* 0F/AC, then C1 /7 ib */
 9468   ins_encode( move_long_small_shift(dst,cnt) );
 9469   ins_pipe( ialu_reg_long );
 9470 %}
 9471 
 9472 // Shift Right Long by 32-63
 9473 instruct sarL_eReg_32_63( eRegL dst, immI_32_63 cnt, eFlagsReg cr) %{
 9474   match(Set dst (RShiftL dst cnt));
 9475   effect(KILL cr);
 9476   ins_cost(300);
 9477   format %{ &quot;MOV    $dst.lo,$dst.hi\n&quot;
 9478           &quot;\tSAR    $dst.lo,$cnt-32\n&quot;
 9479           &quot;\tSAR    $dst.hi,31&quot; %}
 9480   opcode(0xC1, 0x7);  /* C1 /7 ib */
 9481   ins_encode( move_long_big_shift_sign(dst,cnt) );
 9482   ins_pipe( ialu_reg_long );
 9483 %}
 9484 
 9485 // Shift Right arithmetic Long by variable
 9486 instruct sarL_eReg_CL(eRegL dst, eCXRegI shift, eFlagsReg cr) %{
 9487   match(Set dst (RShiftL dst shift));
 9488   effect(KILL cr);
 9489   ins_cost(600);
 9490   size(18);
 9491   format %{ &quot;TEST   $shift,32\n\t&quot;
 9492             &quot;JEQ,s  small\n\t&quot;
 9493             &quot;MOV    $dst.lo,$dst.hi\n\t&quot;
 9494             &quot;SAR    $dst.hi,31\n&quot;
 9495     &quot;small:\tSHRD   $dst.lo,$dst.hi,$shift\n\t&quot;
 9496             &quot;SAR    $dst.hi,$shift&quot; %}
 9497   ins_encode( shift_right_arith_long( dst, shift ) );
 9498   ins_pipe( pipe_slow );
 9499 %}
 9500 
 9501 
 9502 //----------Double Instructions------------------------------------------------
 9503 // Double Math
 9504 
 9505 // Compare &amp; branch
 9506 
 9507 // P6 version of float compare, sets condition codes in EFLAGS
 9508 instruct cmpDPR_cc_P6(eFlagsRegU cr, regDPR src1, regDPR src2, eAXRegI rax) %{
 9509   predicate(VM_Version::supports_cmov() &amp;&amp; UseSSE &lt;=1);
 9510   match(Set cr (CmpD src1 src2));
 9511   effect(KILL rax);
 9512   ins_cost(150);
 9513   format %{ &quot;FLD    $src1\n\t&quot;
 9514             &quot;FUCOMIP ST,$src2  // P6 instruction\n\t&quot;
 9515             &quot;JNP    exit\n\t&quot;
 9516             &quot;MOV    ah,1       // saw a NaN, set CF\n\t&quot;
 9517             &quot;SAHF\n&quot;
 9518      &quot;exit:\tNOP               // avoid branch to branch&quot; %}
 9519   opcode(0xDF, 0x05); /* DF E8+i or DF /5 */
 9520   ins_encode( Push_Reg_DPR(src1),
 9521               OpcP, RegOpc(src2),
 9522               cmpF_P6_fixup );
 9523   ins_pipe( pipe_slow );
 9524 %}
 9525 
 9526 instruct cmpDPR_cc_P6CF(eFlagsRegUCF cr, regDPR src1, regDPR src2) %{
 9527   predicate(VM_Version::supports_cmov() &amp;&amp; UseSSE &lt;=1);
 9528   match(Set cr (CmpD src1 src2));
 9529   ins_cost(150);
 9530   format %{ &quot;FLD    $src1\n\t&quot;
 9531             &quot;FUCOMIP ST,$src2  // P6 instruction&quot; %}
 9532   opcode(0xDF, 0x05); /* DF E8+i or DF /5 */
 9533   ins_encode( Push_Reg_DPR(src1),
 9534               OpcP, RegOpc(src2));
 9535   ins_pipe( pipe_slow );
 9536 %}
 9537 
 9538 // Compare &amp; branch
 9539 instruct cmpDPR_cc(eFlagsRegU cr, regDPR src1, regDPR src2, eAXRegI rax) %{
 9540   predicate(UseSSE&lt;=1);
 9541   match(Set cr (CmpD src1 src2));
 9542   effect(KILL rax);
 9543   ins_cost(200);
 9544   format %{ &quot;FLD    $src1\n\t&quot;
 9545             &quot;FCOMp  $src2\n\t&quot;
 9546             &quot;FNSTSW AX\n\t&quot;
 9547             &quot;TEST   AX,0x400\n\t&quot;
 9548             &quot;JZ,s   flags\n\t&quot;
 9549             &quot;MOV    AH,1\t# unordered treat as LT\n&quot;
 9550     &quot;flags:\tSAHF&quot; %}
 9551   opcode(0xD8, 0x3); /* D8 D8+i or D8 /3 */
 9552   ins_encode( Push_Reg_DPR(src1),
 9553               OpcP, RegOpc(src2),
 9554               fpu_flags);
 9555   ins_pipe( pipe_slow );
 9556 %}
 9557 
 9558 // Compare vs zero into -1,0,1
 9559 instruct cmpDPR_0(rRegI dst, regDPR src1, immDPR0 zero, eAXRegI rax, eFlagsReg cr) %{
 9560   predicate(UseSSE&lt;=1);
 9561   match(Set dst (CmpD3 src1 zero));
 9562   effect(KILL cr, KILL rax);
 9563   ins_cost(280);
 9564   format %{ &quot;FTSTD  $dst,$src1&quot; %}
 9565   opcode(0xE4, 0xD9);
 9566   ins_encode( Push_Reg_DPR(src1),
 9567               OpcS, OpcP, PopFPU,
 9568               CmpF_Result(dst));
 9569   ins_pipe( pipe_slow );
 9570 %}
 9571 
 9572 // Compare into -1,0,1
 9573 instruct cmpDPR_reg(rRegI dst, regDPR src1, regDPR src2, eAXRegI rax, eFlagsReg cr) %{
 9574   predicate(UseSSE&lt;=1);
 9575   match(Set dst (CmpD3 src1 src2));
 9576   effect(KILL cr, KILL rax);
 9577   ins_cost(300);
 9578   format %{ &quot;FCMPD  $dst,$src1,$src2&quot; %}
 9579   opcode(0xD8, 0x3); /* D8 D8+i or D8 /3 */
 9580   ins_encode( Push_Reg_DPR(src1),
 9581               OpcP, RegOpc(src2),
 9582               CmpF_Result(dst));
 9583   ins_pipe( pipe_slow );
 9584 %}
 9585 
 9586 // float compare and set condition codes in EFLAGS by XMM regs
 9587 instruct cmpD_cc(eFlagsRegU cr, regD src1, regD src2) %{
 9588   predicate(UseSSE&gt;=2);
 9589   match(Set cr (CmpD src1 src2));
 9590   ins_cost(145);
 9591   format %{ &quot;UCOMISD $src1,$src2\n\t&quot;
 9592             &quot;JNP,s   exit\n\t&quot;
 9593             &quot;PUSHF\t# saw NaN, set CF\n\t&quot;
 9594             &quot;AND     [rsp], #0xffffff2b\n\t&quot;
 9595             &quot;POPF\n&quot;
 9596     &quot;exit:&quot; %}
 9597   ins_encode %{
 9598     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
 9599     emit_cmpfp_fixup(_masm);
 9600   %}
 9601   ins_pipe( pipe_slow );
 9602 %}
 9603 
 9604 instruct cmpD_ccCF(eFlagsRegUCF cr, regD src1, regD src2) %{
 9605   predicate(UseSSE&gt;=2);
 9606   match(Set cr (CmpD src1 src2));
 9607   ins_cost(100);
 9608   format %{ &quot;UCOMISD $src1,$src2&quot; %}
 9609   ins_encode %{
 9610     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
 9611   %}
 9612   ins_pipe( pipe_slow );
 9613 %}
 9614 
 9615 // float compare and set condition codes in EFLAGS by XMM regs
 9616 instruct cmpD_ccmem(eFlagsRegU cr, regD src1, memory src2) %{
 9617   predicate(UseSSE&gt;=2);
 9618   match(Set cr (CmpD src1 (LoadD src2)));
 9619   ins_cost(145);
 9620   format %{ &quot;UCOMISD $src1,$src2\n\t&quot;
 9621             &quot;JNP,s   exit\n\t&quot;
 9622             &quot;PUSHF\t# saw NaN, set CF\n\t&quot;
 9623             &quot;AND     [rsp], #0xffffff2b\n\t&quot;
 9624             &quot;POPF\n&quot;
 9625     &quot;exit:&quot; %}
 9626   ins_encode %{
 9627     __ ucomisd($src1$$XMMRegister, $src2$$Address);
 9628     emit_cmpfp_fixup(_masm);
 9629   %}
 9630   ins_pipe( pipe_slow );
 9631 %}
 9632 
 9633 instruct cmpD_ccmemCF(eFlagsRegUCF cr, regD src1, memory src2) %{
 9634   predicate(UseSSE&gt;=2);
 9635   match(Set cr (CmpD src1 (LoadD src2)));
 9636   ins_cost(100);
 9637   format %{ &quot;UCOMISD $src1,$src2&quot; %}
 9638   ins_encode %{
 9639     __ ucomisd($src1$$XMMRegister, $src2$$Address);
 9640   %}
 9641   ins_pipe( pipe_slow );
 9642 %}
 9643 
 9644 // Compare into -1,0,1 in XMM
 9645 instruct cmpD_reg(xRegI dst, regD src1, regD src2, eFlagsReg cr) %{
 9646   predicate(UseSSE&gt;=2);
 9647   match(Set dst (CmpD3 src1 src2));
 9648   effect(KILL cr);
 9649   ins_cost(255);
 9650   format %{ &quot;UCOMISD $src1, $src2\n\t&quot;
 9651             &quot;MOV     $dst, #-1\n\t&quot;
 9652             &quot;JP,s    done\n\t&quot;
 9653             &quot;JB,s    done\n\t&quot;
 9654             &quot;SETNE   $dst\n\t&quot;
 9655             &quot;MOVZB   $dst, $dst\n&quot;
 9656     &quot;done:&quot; %}
 9657   ins_encode %{
 9658     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
 9659     emit_cmpfp3(_masm, $dst$$Register);
 9660   %}
 9661   ins_pipe( pipe_slow );
 9662 %}
 9663 
 9664 // Compare into -1,0,1 in XMM and memory
 9665 instruct cmpD_regmem(xRegI dst, regD src1, memory src2, eFlagsReg cr) %{
 9666   predicate(UseSSE&gt;=2);
 9667   match(Set dst (CmpD3 src1 (LoadD src2)));
 9668   effect(KILL cr);
 9669   ins_cost(275);
 9670   format %{ &quot;UCOMISD $src1, $src2\n\t&quot;
 9671             &quot;MOV     $dst, #-1\n\t&quot;
 9672             &quot;JP,s    done\n\t&quot;
 9673             &quot;JB,s    done\n\t&quot;
 9674             &quot;SETNE   $dst\n\t&quot;
 9675             &quot;MOVZB   $dst, $dst\n&quot;
 9676     &quot;done:&quot; %}
 9677   ins_encode %{
 9678     __ ucomisd($src1$$XMMRegister, $src2$$Address);
 9679     emit_cmpfp3(_masm, $dst$$Register);
 9680   %}
 9681   ins_pipe( pipe_slow );
 9682 %}
 9683 
 9684 
 9685 instruct subDPR_reg(regDPR dst, regDPR src) %{
 9686   predicate (UseSSE &lt;=1);
 9687   match(Set dst (SubD dst src));
 9688 
 9689   format %{ &quot;FLD    $src\n\t&quot;
 9690             &quot;DSUBp  $dst,ST&quot; %}
 9691   opcode(0xDE, 0x5); /* DE E8+i  or DE /5 */
 9692   ins_cost(150);
 9693   ins_encode( Push_Reg_DPR(src),
 9694               OpcP, RegOpc(dst) );
 9695   ins_pipe( fpu_reg_reg );
 9696 %}
 9697 
 9698 instruct subDPR_reg_round(stackSlotD dst, regDPR src1, regDPR src2) %{
 9699   predicate (UseSSE &lt;=1);
 9700   match(Set dst (RoundDouble (SubD src1 src2)));
 9701   ins_cost(250);
 9702 
 9703   format %{ &quot;FLD    $src2\n\t&quot;
 9704             &quot;DSUB   ST,$src1\n\t&quot;
 9705             &quot;FSTP_D $dst\t# D-round&quot; %}
 9706   opcode(0xD8, 0x5);
 9707   ins_encode( Push_Reg_DPR(src2),
 9708               OpcP, RegOpc(src1), Pop_Mem_DPR(dst) );
 9709   ins_pipe( fpu_mem_reg_reg );
 9710 %}
 9711 
 9712 
 9713 instruct subDPR_reg_mem(regDPR dst, memory src) %{
 9714   predicate (UseSSE &lt;=1);
 9715   match(Set dst (SubD dst (LoadD src)));
 9716   ins_cost(150);
 9717 
 9718   format %{ &quot;FLD    $src\n\t&quot;
 9719             &quot;DSUBp  $dst,ST&quot; %}
 9720   opcode(0xDE, 0x5, 0xDD); /* DE C0+i */  /* LoadD  DD /0 */
 9721   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),
 9722               OpcP, RegOpc(dst) );
 9723   ins_pipe( fpu_reg_mem );
 9724 %}
 9725 
 9726 instruct absDPR_reg(regDPR1 dst, regDPR1 src) %{
 9727   predicate (UseSSE&lt;=1);
 9728   match(Set dst (AbsD src));
 9729   ins_cost(100);
 9730   format %{ &quot;FABS&quot; %}
 9731   opcode(0xE1, 0xD9);
 9732   ins_encode( OpcS, OpcP );
 9733   ins_pipe( fpu_reg_reg );
 9734 %}
 9735 
 9736 instruct negDPR_reg(regDPR1 dst, regDPR1 src) %{
 9737   predicate(UseSSE&lt;=1);
 9738   match(Set dst (NegD src));
 9739   ins_cost(100);
 9740   format %{ &quot;FCHS&quot; %}
 9741   opcode(0xE0, 0xD9);
 9742   ins_encode( OpcS, OpcP );
 9743   ins_pipe( fpu_reg_reg );
 9744 %}
 9745 
 9746 instruct addDPR_reg(regDPR dst, regDPR src) %{
 9747   predicate(UseSSE&lt;=1);
 9748   match(Set dst (AddD dst src));
 9749   format %{ &quot;FLD    $src\n\t&quot;
 9750             &quot;DADD   $dst,ST&quot; %}
 9751   size(4);
 9752   ins_cost(150);
 9753   opcode(0xDE, 0x0); /* DE C0+i or DE /0*/
 9754   ins_encode( Push_Reg_DPR(src),
 9755               OpcP, RegOpc(dst) );
 9756   ins_pipe( fpu_reg_reg );
 9757 %}
 9758 
 9759 
 9760 instruct addDPR_reg_round(stackSlotD dst, regDPR src1, regDPR src2) %{
 9761   predicate(UseSSE&lt;=1);
 9762   match(Set dst (RoundDouble (AddD src1 src2)));
 9763   ins_cost(250);
 9764 
 9765   format %{ &quot;FLD    $src2\n\t&quot;
 9766             &quot;DADD   ST,$src1\n\t&quot;
 9767             &quot;FSTP_D $dst\t# D-round&quot; %}
 9768   opcode(0xD8, 0x0); /* D8 C0+i or D8 /0*/
 9769   ins_encode( Push_Reg_DPR(src2),
 9770               OpcP, RegOpc(src1), Pop_Mem_DPR(dst) );
 9771   ins_pipe( fpu_mem_reg_reg );
 9772 %}
 9773 
 9774 
 9775 instruct addDPR_reg_mem(regDPR dst, memory src) %{
 9776   predicate(UseSSE&lt;=1);
 9777   match(Set dst (AddD dst (LoadD src)));
 9778   ins_cost(150);
 9779 
 9780   format %{ &quot;FLD    $src\n\t&quot;
 9781             &quot;DADDp  $dst,ST&quot; %}
 9782   opcode(0xDE, 0x0, 0xDD); /* DE C0+i */  /* LoadD  DD /0 */
 9783   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),
 9784               OpcP, RegOpc(dst) );
 9785   ins_pipe( fpu_reg_mem );
 9786 %}
 9787 
 9788 // add-to-memory
 9789 instruct addDPR_mem_reg(memory dst, regDPR src) %{
 9790   predicate(UseSSE&lt;=1);
 9791   match(Set dst (StoreD dst (RoundDouble (AddD (LoadD dst) src))));
 9792   ins_cost(150);
 9793 
 9794   format %{ &quot;FLD_D  $dst\n\t&quot;
 9795             &quot;DADD   ST,$src\n\t&quot;
 9796             &quot;FST_D  $dst&quot; %}
 9797   opcode(0xDD, 0x0);
 9798   ins_encode( Opcode(0xDD), RMopc_Mem(0x00,dst),
 9799               Opcode(0xD8), RegOpc(src),
 9800               set_instruction_start,
 9801               Opcode(0xDD), RMopc_Mem(0x03,dst) );
 9802   ins_pipe( fpu_reg_mem );
 9803 %}
 9804 
 9805 instruct addDPR_reg_imm1(regDPR dst, immDPR1 con) %{
 9806   predicate(UseSSE&lt;=1);
 9807   match(Set dst (AddD dst con));
 9808   ins_cost(125);
 9809   format %{ &quot;FLD1\n\t&quot;
 9810             &quot;DADDp  $dst,ST&quot; %}
 9811   ins_encode %{
 9812     __ fld1();
 9813     __ faddp($dst$$reg);
 9814   %}
 9815   ins_pipe(fpu_reg);
 9816 %}
 9817 
 9818 instruct addDPR_reg_imm(regDPR dst, immDPR con) %{
 9819   predicate(UseSSE&lt;=1 &amp;&amp; _kids[1]-&gt;_leaf-&gt;getd() != 0.0 &amp;&amp; _kids[1]-&gt;_leaf-&gt;getd() != 1.0 );
 9820   match(Set dst (AddD dst con));
 9821   ins_cost(200);
 9822   format %{ &quot;FLD_D  [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
 9823             &quot;DADDp  $dst,ST&quot; %}
 9824   ins_encode %{
 9825     __ fld_d($constantaddress($con));
 9826     __ faddp($dst$$reg);
 9827   %}
 9828   ins_pipe(fpu_reg_mem);
 9829 %}
 9830 
 9831 instruct addDPR_reg_imm_round(stackSlotD dst, regDPR src, immDPR con) %{
 9832   predicate(UseSSE&lt;=1 &amp;&amp; _kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;getd() != 0.0 &amp;&amp; _kids[0]-&gt;_kids[1]-&gt;_leaf-&gt;getd() != 1.0 );
 9833   match(Set dst (RoundDouble (AddD src con)));
 9834   ins_cost(200);
 9835   format %{ &quot;FLD_D  [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
 9836             &quot;DADD   ST,$src\n\t&quot;
 9837             &quot;FSTP_D $dst\t# D-round&quot; %}
 9838   ins_encode %{
 9839     __ fld_d($constantaddress($con));
 9840     __ fadd($src$$reg);
 9841     __ fstp_d(Address(rsp, $dst$$disp));
 9842   %}
 9843   ins_pipe(fpu_mem_reg_con);
 9844 %}
 9845 
 9846 instruct mulDPR_reg(regDPR dst, regDPR src) %{
 9847   predicate(UseSSE&lt;=1);
 9848   match(Set dst (MulD dst src));
 9849   format %{ &quot;FLD    $src\n\t&quot;
 9850             &quot;DMULp  $dst,ST&quot; %}
 9851   opcode(0xDE, 0x1); /* DE C8+i or DE /1*/
 9852   ins_cost(150);
 9853   ins_encode( Push_Reg_DPR(src),
 9854               OpcP, RegOpc(dst) );
 9855   ins_pipe( fpu_reg_reg );
 9856 %}
 9857 
 9858 // Strict FP instruction biases argument before multiply then
 9859 // biases result to avoid double rounding of subnormals.
 9860 //
 9861 // scale arg1 by multiplying arg1 by 2^(-15360)
 9862 // load arg2
 9863 // multiply scaled arg1 by arg2
 9864 // rescale product by 2^(15360)
 9865 //
 9866 instruct strictfp_mulDPR_reg(regDPR1 dst, regnotDPR1 src) %{
 9867   predicate( UseSSE&lt;=1 &amp;&amp; Compile::current()-&gt;has_method() &amp;&amp; Compile::current()-&gt;method()-&gt;is_strict() );
 9868   match(Set dst (MulD dst src));
 9869   ins_cost(1);   // Select this instruction for all strict FP double multiplies
 9870 
 9871   format %{ &quot;FLD    StubRoutines::_fpu_subnormal_bias1\n\t&quot;
 9872             &quot;DMULp  $dst,ST\n\t&quot;
 9873             &quot;FLD    $src\n\t&quot;
 9874             &quot;DMULp  $dst,ST\n\t&quot;
 9875             &quot;FLD    StubRoutines::_fpu_subnormal_bias2\n\t&quot;
 9876             &quot;DMULp  $dst,ST\n\t&quot; %}
 9877   opcode(0xDE, 0x1); /* DE C8+i or DE /1*/
 9878   ins_encode( strictfp_bias1(dst),
 9879               Push_Reg_DPR(src),
 9880               OpcP, RegOpc(dst),
 9881               strictfp_bias2(dst) );
 9882   ins_pipe( fpu_reg_reg );
 9883 %}
 9884 
 9885 instruct mulDPR_reg_imm(regDPR dst, immDPR con) %{
 9886   predicate( UseSSE&lt;=1 &amp;&amp; _kids[1]-&gt;_leaf-&gt;getd() != 0.0 &amp;&amp; _kids[1]-&gt;_leaf-&gt;getd() != 1.0 );
 9887   match(Set dst (MulD dst con));
 9888   ins_cost(200);
 9889   format %{ &quot;FLD_D  [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
 9890             &quot;DMULp  $dst,ST&quot; %}
 9891   ins_encode %{
 9892     __ fld_d($constantaddress($con));
 9893     __ fmulp($dst$$reg);
 9894   %}
 9895   ins_pipe(fpu_reg_mem);
 9896 %}
 9897 
 9898 
 9899 instruct mulDPR_reg_mem(regDPR dst, memory src) %{
 9900   predicate( UseSSE&lt;=1 );
 9901   match(Set dst (MulD dst (LoadD src)));
 9902   ins_cost(200);
 9903   format %{ &quot;FLD_D  $src\n\t&quot;
 9904             &quot;DMULp  $dst,ST&quot; %}
 9905   opcode(0xDE, 0x1, 0xDD); /* DE C8+i or DE /1*/  /* LoadD  DD /0 */
 9906   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),
 9907               OpcP, RegOpc(dst) );
 9908   ins_pipe( fpu_reg_mem );
 9909 %}
 9910 
 9911 //
 9912 // Cisc-alternate to reg-reg multiply
 9913 instruct mulDPR_reg_mem_cisc(regDPR dst, regDPR src, memory mem) %{
 9914   predicate( UseSSE&lt;=1 );
 9915   match(Set dst (MulD src (LoadD mem)));
 9916   ins_cost(250);
 9917   format %{ &quot;FLD_D  $mem\n\t&quot;
 9918             &quot;DMUL   ST,$src\n\t&quot;
 9919             &quot;FSTP_D $dst&quot; %}
 9920   opcode(0xD8, 0x1, 0xD9); /* D8 C8+i */  /* LoadD D9 /0 */
 9921   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,mem),
 9922               OpcReg_FPR(src),
 9923               Pop_Reg_DPR(dst) );
 9924   ins_pipe( fpu_reg_reg_mem );
 9925 %}
 9926 
 9927 
 9928 // MACRO3 -- addDPR a mulDPR
 9929 // This instruction is a &#39;2-address&#39; instruction in that the result goes
 9930 // back to src2.  This eliminates a move from the macro; possibly the
 9931 // register allocator will have to add it back (and maybe not).
 9932 instruct addDPR_mulDPR_reg(regDPR src2, regDPR src1, regDPR src0) %{
 9933   predicate( UseSSE&lt;=1 );
 9934   match(Set src2 (AddD (MulD src0 src1) src2));
 9935   format %{ &quot;FLD    $src0\t# ===MACRO3d===\n\t&quot;
 9936             &quot;DMUL   ST,$src1\n\t&quot;
 9937             &quot;DADDp  $src2,ST&quot; %}
 9938   ins_cost(250);
 9939   opcode(0xDD); /* LoadD DD /0 */
 9940   ins_encode( Push_Reg_FPR(src0),
 9941               FMul_ST_reg(src1),
 9942               FAddP_reg_ST(src2) );
 9943   ins_pipe( fpu_reg_reg_reg );
 9944 %}
 9945 
 9946 
 9947 // MACRO3 -- subDPR a mulDPR
 9948 instruct subDPR_mulDPR_reg(regDPR src2, regDPR src1, regDPR src0) %{
 9949   predicate( UseSSE&lt;=1 );
 9950   match(Set src2 (SubD (MulD src0 src1) src2));
 9951   format %{ &quot;FLD    $src0\t# ===MACRO3d===\n\t&quot;
 9952             &quot;DMUL   ST,$src1\n\t&quot;
 9953             &quot;DSUBRp $src2,ST&quot; %}
 9954   ins_cost(250);
 9955   ins_encode( Push_Reg_FPR(src0),
 9956               FMul_ST_reg(src1),
 9957               Opcode(0xDE), Opc_plus(0xE0,src2));
 9958   ins_pipe( fpu_reg_reg_reg );
 9959 %}
 9960 
 9961 
 9962 instruct divDPR_reg(regDPR dst, regDPR src) %{
 9963   predicate( UseSSE&lt;=1 );
 9964   match(Set dst (DivD dst src));
 9965 
 9966   format %{ &quot;FLD    $src\n\t&quot;
 9967             &quot;FDIVp  $dst,ST&quot; %}
 9968   opcode(0xDE, 0x7); /* DE F8+i or DE /7*/
 9969   ins_cost(150);
 9970   ins_encode( Push_Reg_DPR(src),
 9971               OpcP, RegOpc(dst) );
 9972   ins_pipe( fpu_reg_reg );
 9973 %}
 9974 
 9975 // Strict FP instruction biases argument before division then
 9976 // biases result, to avoid double rounding of subnormals.
 9977 //
 9978 // scale dividend by multiplying dividend by 2^(-15360)
 9979 // load divisor
 9980 // divide scaled dividend by divisor
 9981 // rescale quotient by 2^(15360)
 9982 //
 9983 instruct strictfp_divDPR_reg(regDPR1 dst, regnotDPR1 src) %{
 9984   predicate (UseSSE&lt;=1);
 9985   match(Set dst (DivD dst src));
 9986   predicate( UseSSE&lt;=1 &amp;&amp; Compile::current()-&gt;has_method() &amp;&amp; Compile::current()-&gt;method()-&gt;is_strict() );
 9987   ins_cost(01);
 9988 
 9989   format %{ &quot;FLD    StubRoutines::_fpu_subnormal_bias1\n\t&quot;
 9990             &quot;DMULp  $dst,ST\n\t&quot;
 9991             &quot;FLD    $src\n\t&quot;
 9992             &quot;FDIVp  $dst,ST\n\t&quot;
 9993             &quot;FLD    StubRoutines::_fpu_subnormal_bias2\n\t&quot;
 9994             &quot;DMULp  $dst,ST\n\t&quot; %}
 9995   opcode(0xDE, 0x7); /* DE F8+i or DE /7*/
 9996   ins_encode( strictfp_bias1(dst),
 9997               Push_Reg_DPR(src),
 9998               OpcP, RegOpc(dst),
 9999               strictfp_bias2(dst) );
10000   ins_pipe( fpu_reg_reg );
10001 %}
10002 
10003 instruct divDPR_reg_round(stackSlotD dst, regDPR src1, regDPR src2) %{
10004   predicate( UseSSE&lt;=1 &amp;&amp; !(Compile::current()-&gt;has_method() &amp;&amp; Compile::current()-&gt;method()-&gt;is_strict()) );
10005   match(Set dst (RoundDouble (DivD src1 src2)));
10006 
10007   format %{ &quot;FLD    $src1\n\t&quot;
10008             &quot;FDIV   ST,$src2\n\t&quot;
10009             &quot;FSTP_D $dst\t# D-round&quot; %}
10010   opcode(0xD8, 0x6); /* D8 F0+i or D8 /6 */
10011   ins_encode( Push_Reg_DPR(src1),
10012               OpcP, RegOpc(src2), Pop_Mem_DPR(dst) );
10013   ins_pipe( fpu_mem_reg_reg );
10014 %}
10015 
10016 
10017 instruct modDPR_reg(regDPR dst, regDPR src, eAXRegI rax, eFlagsReg cr) %{
10018   predicate(UseSSE&lt;=1);
10019   match(Set dst (ModD dst src));
10020   effect(KILL rax, KILL cr); // emitModDPR() uses EAX and EFLAGS
10021 
10022   format %{ &quot;DMOD   $dst,$src&quot; %}
10023   ins_cost(250);
10024   ins_encode(Push_Reg_Mod_DPR(dst, src),
10025               emitModDPR(),
10026               Push_Result_Mod_DPR(src),
10027               Pop_Reg_DPR(dst));
10028   ins_pipe( pipe_slow );
10029 %}
10030 
10031 instruct modD_reg(regD dst, regD src0, regD src1, eAXRegI rax, eFlagsReg cr) %{
10032   predicate(UseSSE&gt;=2);
10033   match(Set dst (ModD src0 src1));
10034   effect(KILL rax, KILL cr);
10035 
10036   format %{ &quot;SUB    ESP,8\t # DMOD\n&quot;
10037           &quot;\tMOVSD  [ESP+0],$src1\n&quot;
10038           &quot;\tFLD_D  [ESP+0]\n&quot;
10039           &quot;\tMOVSD  [ESP+0],$src0\n&quot;
10040           &quot;\tFLD_D  [ESP+0]\n&quot;
10041      &quot;loop:\tFPREM\n&quot;
10042           &quot;\tFWAIT\n&quot;
10043           &quot;\tFNSTSW AX\n&quot;
10044           &quot;\tSAHF\n&quot;
10045           &quot;\tJP     loop\n&quot;
10046           &quot;\tFSTP_D [ESP+0]\n&quot;
10047           &quot;\tMOVSD  $dst,[ESP+0]\n&quot;
10048           &quot;\tADD    ESP,8\n&quot;
10049           &quot;\tFSTP   ST0\t # Restore FPU Stack&quot;
10050     %}
10051   ins_cost(250);
10052   ins_encode( Push_ModD_encoding(src0, src1), emitModDPR(), Push_ResultD(dst), PopFPU);
10053   ins_pipe( pipe_slow );
10054 %}
10055 
10056 instruct atanDPR_reg(regDPR dst, regDPR src) %{
10057   predicate (UseSSE&lt;=1);
10058   match(Set dst(AtanD dst src));
10059   format %{ &quot;DATA   $dst,$src&quot; %}
10060   opcode(0xD9, 0xF3);
10061   ins_encode( Push_Reg_DPR(src),
10062               OpcP, OpcS, RegOpc(dst) );
10063   ins_pipe( pipe_slow );
10064 %}
10065 
10066 instruct atanD_reg(regD dst, regD src, eFlagsReg cr) %{
10067   predicate (UseSSE&gt;=2);
10068   match(Set dst(AtanD dst src));
10069   effect(KILL cr); // Push_{Src|Result}D() uses &quot;{SUB|ADD} ESP,8&quot;
10070   format %{ &quot;DATA   $dst,$src&quot; %}
10071   opcode(0xD9, 0xF3);
10072   ins_encode( Push_SrcD(src),
10073               OpcP, OpcS, Push_ResultD(dst) );
10074   ins_pipe( pipe_slow );
10075 %}
10076 
10077 instruct sqrtDPR_reg(regDPR dst, regDPR src) %{
10078   predicate (UseSSE&lt;=1);
10079   match(Set dst (SqrtD src));
10080   format %{ &quot;DSQRT  $dst,$src&quot; %}
10081   opcode(0xFA, 0xD9);
10082   ins_encode( Push_Reg_DPR(src),
10083               OpcS, OpcP, Pop_Reg_DPR(dst) );
10084   ins_pipe( pipe_slow );
10085 %}
10086 
10087 //-------------Float Instructions-------------------------------
10088 // Float Math
10089 
10090 // Code for float compare:
10091 //     fcompp();
10092 //     fwait(); fnstsw_ax();
10093 //     sahf();
10094 //     movl(dst, unordered_result);
10095 //     jcc(Assembler::parity, exit);
10096 //     movl(dst, less_result);
10097 //     jcc(Assembler::below, exit);
10098 //     movl(dst, equal_result);
10099 //     jcc(Assembler::equal, exit);
10100 //     movl(dst, greater_result);
10101 //   exit:
10102 
10103 // P6 version of float compare, sets condition codes in EFLAGS
10104 instruct cmpFPR_cc_P6(eFlagsRegU cr, regFPR src1, regFPR src2, eAXRegI rax) %{
10105   predicate(VM_Version::supports_cmov() &amp;&amp; UseSSE == 0);
10106   match(Set cr (CmpF src1 src2));
10107   effect(KILL rax);
10108   ins_cost(150);
10109   format %{ &quot;FLD    $src1\n\t&quot;
10110             &quot;FUCOMIP ST,$src2  // P6 instruction\n\t&quot;
10111             &quot;JNP    exit\n\t&quot;
10112             &quot;MOV    ah,1       // saw a NaN, set CF (treat as LT)\n\t&quot;
10113             &quot;SAHF\n&quot;
10114      &quot;exit:\tNOP               // avoid branch to branch&quot; %}
10115   opcode(0xDF, 0x05); /* DF E8+i or DF /5 */
10116   ins_encode( Push_Reg_DPR(src1),
10117               OpcP, RegOpc(src2),
10118               cmpF_P6_fixup );
10119   ins_pipe( pipe_slow );
10120 %}
10121 
10122 instruct cmpFPR_cc_P6CF(eFlagsRegUCF cr, regFPR src1, regFPR src2) %{
10123   predicate(VM_Version::supports_cmov() &amp;&amp; UseSSE == 0);
10124   match(Set cr (CmpF src1 src2));
10125   ins_cost(100);
10126   format %{ &quot;FLD    $src1\n\t&quot;
10127             &quot;FUCOMIP ST,$src2  // P6 instruction&quot; %}
10128   opcode(0xDF, 0x05); /* DF E8+i or DF /5 */
10129   ins_encode( Push_Reg_DPR(src1),
10130               OpcP, RegOpc(src2));
10131   ins_pipe( pipe_slow );
10132 %}
10133 
10134 
10135 // Compare &amp; branch
10136 instruct cmpFPR_cc(eFlagsRegU cr, regFPR src1, regFPR src2, eAXRegI rax) %{
10137   predicate(UseSSE == 0);
10138   match(Set cr (CmpF src1 src2));
10139   effect(KILL rax);
10140   ins_cost(200);
10141   format %{ &quot;FLD    $src1\n\t&quot;
10142             &quot;FCOMp  $src2\n\t&quot;
10143             &quot;FNSTSW AX\n\t&quot;
10144             &quot;TEST   AX,0x400\n\t&quot;
10145             &quot;JZ,s   flags\n\t&quot;
10146             &quot;MOV    AH,1\t# unordered treat as LT\n&quot;
10147     &quot;flags:\tSAHF&quot; %}
10148   opcode(0xD8, 0x3); /* D8 D8+i or D8 /3 */
10149   ins_encode( Push_Reg_DPR(src1),
10150               OpcP, RegOpc(src2),
10151               fpu_flags);
10152   ins_pipe( pipe_slow );
10153 %}
10154 
10155 // Compare vs zero into -1,0,1
10156 instruct cmpFPR_0(rRegI dst, regFPR src1, immFPR0 zero, eAXRegI rax, eFlagsReg cr) %{
10157   predicate(UseSSE == 0);
10158   match(Set dst (CmpF3 src1 zero));
10159   effect(KILL cr, KILL rax);
10160   ins_cost(280);
10161   format %{ &quot;FTSTF  $dst,$src1&quot; %}
10162   opcode(0xE4, 0xD9);
10163   ins_encode( Push_Reg_DPR(src1),
10164               OpcS, OpcP, PopFPU,
10165               CmpF_Result(dst));
10166   ins_pipe( pipe_slow );
10167 %}
10168 
10169 // Compare into -1,0,1
10170 instruct cmpFPR_reg(rRegI dst, regFPR src1, regFPR src2, eAXRegI rax, eFlagsReg cr) %{
10171   predicate(UseSSE == 0);
10172   match(Set dst (CmpF3 src1 src2));
10173   effect(KILL cr, KILL rax);
10174   ins_cost(300);
10175   format %{ &quot;FCMPF  $dst,$src1,$src2&quot; %}
10176   opcode(0xD8, 0x3); /* D8 D8+i or D8 /3 */
10177   ins_encode( Push_Reg_DPR(src1),
10178               OpcP, RegOpc(src2),
10179               CmpF_Result(dst));
10180   ins_pipe( pipe_slow );
10181 %}
10182 
10183 // float compare and set condition codes in EFLAGS by XMM regs
10184 instruct cmpF_cc(eFlagsRegU cr, regF src1, regF src2) %{
10185   predicate(UseSSE&gt;=1);
10186   match(Set cr (CmpF src1 src2));
10187   ins_cost(145);
10188   format %{ &quot;UCOMISS $src1,$src2\n\t&quot;
10189             &quot;JNP,s   exit\n\t&quot;
10190             &quot;PUSHF\t# saw NaN, set CF\n\t&quot;
10191             &quot;AND     [rsp], #0xffffff2b\n\t&quot;
10192             &quot;POPF\n&quot;
10193     &quot;exit:&quot; %}
10194   ins_encode %{
10195     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10196     emit_cmpfp_fixup(_masm);
10197   %}
10198   ins_pipe( pipe_slow );
10199 %}
10200 
10201 instruct cmpF_ccCF(eFlagsRegUCF cr, regF src1, regF src2) %{
10202   predicate(UseSSE&gt;=1);
10203   match(Set cr (CmpF src1 src2));
10204   ins_cost(100);
10205   format %{ &quot;UCOMISS $src1,$src2&quot; %}
10206   ins_encode %{
10207     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10208   %}
10209   ins_pipe( pipe_slow );
10210 %}
10211 
10212 // float compare and set condition codes in EFLAGS by XMM regs
10213 instruct cmpF_ccmem(eFlagsRegU cr, regF src1, memory src2) %{
10214   predicate(UseSSE&gt;=1);
10215   match(Set cr (CmpF src1 (LoadF src2)));
10216   ins_cost(165);
10217   format %{ &quot;UCOMISS $src1,$src2\n\t&quot;
10218             &quot;JNP,s   exit\n\t&quot;
10219             &quot;PUSHF\t# saw NaN, set CF\n\t&quot;
10220             &quot;AND     [rsp], #0xffffff2b\n\t&quot;
10221             &quot;POPF\n&quot;
10222     &quot;exit:&quot; %}
10223   ins_encode %{
10224     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10225     emit_cmpfp_fixup(_masm);
10226   %}
10227   ins_pipe( pipe_slow );
10228 %}
10229 
10230 instruct cmpF_ccmemCF(eFlagsRegUCF cr, regF src1, memory src2) %{
10231   predicate(UseSSE&gt;=1);
10232   match(Set cr (CmpF src1 (LoadF src2)));
10233   ins_cost(100);
10234   format %{ &quot;UCOMISS $src1,$src2&quot; %}
10235   ins_encode %{
10236     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10237   %}
10238   ins_pipe( pipe_slow );
10239 %}
10240 
10241 // Compare into -1,0,1 in XMM
10242 instruct cmpF_reg(xRegI dst, regF src1, regF src2, eFlagsReg cr) %{
10243   predicate(UseSSE&gt;=1);
10244   match(Set dst (CmpF3 src1 src2));
10245   effect(KILL cr);
10246   ins_cost(255);
10247   format %{ &quot;UCOMISS $src1, $src2\n\t&quot;
10248             &quot;MOV     $dst, #-1\n\t&quot;
10249             &quot;JP,s    done\n\t&quot;
10250             &quot;JB,s    done\n\t&quot;
10251             &quot;SETNE   $dst\n\t&quot;
10252             &quot;MOVZB   $dst, $dst\n&quot;
10253     &quot;done:&quot; %}
10254   ins_encode %{
10255     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10256     emit_cmpfp3(_masm, $dst$$Register);
10257   %}
10258   ins_pipe( pipe_slow );
10259 %}
10260 
10261 // Compare into -1,0,1 in XMM and memory
10262 instruct cmpF_regmem(xRegI dst, regF src1, memory src2, eFlagsReg cr) %{
10263   predicate(UseSSE&gt;=1);
10264   match(Set dst (CmpF3 src1 (LoadF src2)));
10265   effect(KILL cr);
10266   ins_cost(275);
10267   format %{ &quot;UCOMISS $src1, $src2\n\t&quot;
10268             &quot;MOV     $dst, #-1\n\t&quot;
10269             &quot;JP,s    done\n\t&quot;
10270             &quot;JB,s    done\n\t&quot;
10271             &quot;SETNE   $dst\n\t&quot;
10272             &quot;MOVZB   $dst, $dst\n&quot;
10273     &quot;done:&quot; %}
10274   ins_encode %{
10275     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10276     emit_cmpfp3(_masm, $dst$$Register);
10277   %}
10278   ins_pipe( pipe_slow );
10279 %}
10280 
10281 // Spill to obtain 24-bit precision
10282 instruct subFPR24_reg(stackSlotF dst, regFPR src1, regFPR src2) %{
10283   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10284   match(Set dst (SubF src1 src2));
10285 
10286   format %{ &quot;FSUB   $dst,$src1 - $src2&quot; %}
10287   opcode(0xD8, 0x4); /* D8 E0+i or D8 /4 mod==0x3 ;; result in TOS */
10288   ins_encode( Push_Reg_FPR(src1),
10289               OpcReg_FPR(src2),
10290               Pop_Mem_FPR(dst) );
10291   ins_pipe( fpu_mem_reg_reg );
10292 %}
10293 //
10294 // This instruction does not round to 24-bits
10295 instruct subFPR_reg(regFPR dst, regFPR src) %{
10296   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10297   match(Set dst (SubF dst src));
10298 
10299   format %{ &quot;FSUB   $dst,$src&quot; %}
10300   opcode(0xDE, 0x5); /* DE E8+i  or DE /5 */
10301   ins_encode( Push_Reg_FPR(src),
10302               OpcP, RegOpc(dst) );
10303   ins_pipe( fpu_reg_reg );
10304 %}
10305 
10306 // Spill to obtain 24-bit precision
10307 instruct addFPR24_reg(stackSlotF dst, regFPR src1, regFPR src2) %{
10308   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10309   match(Set dst (AddF src1 src2));
10310 
10311   format %{ &quot;FADD   $dst,$src1,$src2&quot; %}
10312   opcode(0xD8, 0x0); /* D8 C0+i */
10313   ins_encode( Push_Reg_FPR(src2),
10314               OpcReg_FPR(src1),
10315               Pop_Mem_FPR(dst) );
10316   ins_pipe( fpu_mem_reg_reg );
10317 %}
10318 //
10319 // This instruction does not round to 24-bits
10320 instruct addFPR_reg(regFPR dst, regFPR src) %{
10321   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10322   match(Set dst (AddF dst src));
10323 
10324   format %{ &quot;FLD    $src\n\t&quot;
10325             &quot;FADDp  $dst,ST&quot; %}
10326   opcode(0xDE, 0x0); /* DE C0+i or DE /0*/
10327   ins_encode( Push_Reg_FPR(src),
10328               OpcP, RegOpc(dst) );
10329   ins_pipe( fpu_reg_reg );
10330 %}
10331 
10332 instruct absFPR_reg(regFPR1 dst, regFPR1 src) %{
10333   predicate(UseSSE==0);
10334   match(Set dst (AbsF src));
10335   ins_cost(100);
10336   format %{ &quot;FABS&quot; %}
10337   opcode(0xE1, 0xD9);
10338   ins_encode( OpcS, OpcP );
10339   ins_pipe( fpu_reg_reg );
10340 %}
10341 
10342 instruct negFPR_reg(regFPR1 dst, regFPR1 src) %{
10343   predicate(UseSSE==0);
10344   match(Set dst (NegF src));
10345   ins_cost(100);
10346   format %{ &quot;FCHS&quot; %}
10347   opcode(0xE0, 0xD9);
10348   ins_encode( OpcS, OpcP );
10349   ins_pipe( fpu_reg_reg );
10350 %}
10351 
10352 // Cisc-alternate to addFPR_reg
10353 // Spill to obtain 24-bit precision
10354 instruct addFPR24_reg_mem(stackSlotF dst, regFPR src1, memory src2) %{
10355   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10356   match(Set dst (AddF src1 (LoadF src2)));
10357 
10358   format %{ &quot;FLD    $src2\n\t&quot;
10359             &quot;FADD   ST,$src1\n\t&quot;
10360             &quot;FSTP_S $dst&quot; %}
10361   opcode(0xD8, 0x0, 0xD9); /* D8 C0+i */  /* LoadF  D9 /0 */
10362   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10363               OpcReg_FPR(src1),
10364               Pop_Mem_FPR(dst) );
10365   ins_pipe( fpu_mem_reg_mem );
10366 %}
10367 //
10368 // Cisc-alternate to addFPR_reg
10369 // This instruction does not round to 24-bits
10370 instruct addFPR_reg_mem(regFPR dst, memory src) %{
10371   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10372   match(Set dst (AddF dst (LoadF src)));
10373 
10374   format %{ &quot;FADD   $dst,$src&quot; %}
10375   opcode(0xDE, 0x0, 0xD9); /* DE C0+i or DE /0*/  /* LoadF  D9 /0 */
10376   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src),
10377               OpcP, RegOpc(dst) );
10378   ins_pipe( fpu_reg_mem );
10379 %}
10380 
10381 // // Following two instructions for _222_mpegaudio
10382 // Spill to obtain 24-bit precision
10383 instruct addFPR24_mem_reg(stackSlotF dst, regFPR src2, memory src1 ) %{
10384   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10385   match(Set dst (AddF src1 src2));
10386 
10387   format %{ &quot;FADD   $dst,$src1,$src2&quot; %}
10388   opcode(0xD8, 0x0, 0xD9); /* D8 C0+i */  /* LoadF  D9 /0 */
10389   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src1),
10390               OpcReg_FPR(src2),
10391               Pop_Mem_FPR(dst) );
10392   ins_pipe( fpu_mem_reg_mem );
10393 %}
10394 
10395 // Cisc-spill variant
10396 // Spill to obtain 24-bit precision
10397 instruct addFPR24_mem_cisc(stackSlotF dst, memory src1, memory src2) %{
10398   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10399   match(Set dst (AddF src1 (LoadF src2)));
10400 
10401   format %{ &quot;FADD   $dst,$src1,$src2 cisc&quot; %}
10402   opcode(0xD8, 0x0, 0xD9); /* D8 C0+i */  /* LoadF  D9 /0 */
10403   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10404               set_instruction_start,
10405               OpcP, RMopc_Mem(secondary,src1),
10406               Pop_Mem_FPR(dst) );
10407   ins_pipe( fpu_mem_mem_mem );
10408 %}
10409 
10410 // Spill to obtain 24-bit precision
10411 instruct addFPR24_mem_mem(stackSlotF dst, memory src1, memory src2) %{
10412   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10413   match(Set dst (AddF src1 src2));
10414 
10415   format %{ &quot;FADD   $dst,$src1,$src2&quot; %}
10416   opcode(0xD8, 0x0, 0xD9); /* D8 /0 */  /* LoadF  D9 /0 */
10417   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10418               set_instruction_start,
10419               OpcP, RMopc_Mem(secondary,src1),
10420               Pop_Mem_FPR(dst) );
10421   ins_pipe( fpu_mem_mem_mem );
10422 %}
10423 
10424 
10425 // Spill to obtain 24-bit precision
10426 instruct addFPR24_reg_imm(stackSlotF dst, regFPR src, immFPR con) %{
10427   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10428   match(Set dst (AddF src con));
10429   format %{ &quot;FLD    $src\n\t&quot;
10430             &quot;FADD_S [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10431             &quot;FSTP_S $dst&quot;  %}
10432   ins_encode %{
10433     __ fld_s($src$$reg - 1);  // FLD ST(i-1)
10434     __ fadd_s($constantaddress($con));
10435     __ fstp_s(Address(rsp, $dst$$disp));
10436   %}
10437   ins_pipe(fpu_mem_reg_con);
10438 %}
10439 //
10440 // This instruction does not round to 24-bits
10441 instruct addFPR_reg_imm(regFPR dst, regFPR src, immFPR con) %{
10442   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10443   match(Set dst (AddF src con));
10444   format %{ &quot;FLD    $src\n\t&quot;
10445             &quot;FADD_S [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10446             &quot;FSTP   $dst&quot;  %}
10447   ins_encode %{
10448     __ fld_s($src$$reg - 1);  // FLD ST(i-1)
10449     __ fadd_s($constantaddress($con));
10450     __ fstp_d($dst$$reg);
10451   %}
10452   ins_pipe(fpu_reg_reg_con);
10453 %}
10454 
10455 // Spill to obtain 24-bit precision
10456 instruct mulFPR24_reg(stackSlotF dst, regFPR src1, regFPR src2) %{
10457   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10458   match(Set dst (MulF src1 src2));
10459 
10460   format %{ &quot;FLD    $src1\n\t&quot;
10461             &quot;FMUL   $src2\n\t&quot;
10462             &quot;FSTP_S $dst&quot;  %}
10463   opcode(0xD8, 0x1); /* D8 C8+i or D8 /1 ;; result in TOS */
10464   ins_encode( Push_Reg_FPR(src1),
10465               OpcReg_FPR(src2),
10466               Pop_Mem_FPR(dst) );
10467   ins_pipe( fpu_mem_reg_reg );
10468 %}
10469 //
10470 // This instruction does not round to 24-bits
10471 instruct mulFPR_reg(regFPR dst, regFPR src1, regFPR src2) %{
10472   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10473   match(Set dst (MulF src1 src2));
10474 
10475   format %{ &quot;FLD    $src1\n\t&quot;
10476             &quot;FMUL   $src2\n\t&quot;
10477             &quot;FSTP_S $dst&quot;  %}
10478   opcode(0xD8, 0x1); /* D8 C8+i */
10479   ins_encode( Push_Reg_FPR(src2),
10480               OpcReg_FPR(src1),
10481               Pop_Reg_FPR(dst) );
10482   ins_pipe( fpu_reg_reg_reg );
10483 %}
10484 
10485 
10486 // Spill to obtain 24-bit precision
10487 // Cisc-alternate to reg-reg multiply
10488 instruct mulFPR24_reg_mem(stackSlotF dst, regFPR src1, memory src2) %{
10489   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10490   match(Set dst (MulF src1 (LoadF src2)));
10491 
10492   format %{ &quot;FLD_S  $src2\n\t&quot;
10493             &quot;FMUL   $src1\n\t&quot;
10494             &quot;FSTP_S $dst&quot;  %}
10495   opcode(0xD8, 0x1, 0xD9); /* D8 C8+i or DE /1*/  /* LoadF D9 /0 */
10496   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10497               OpcReg_FPR(src1),
10498               Pop_Mem_FPR(dst) );
10499   ins_pipe( fpu_mem_reg_mem );
10500 %}
10501 //
10502 // This instruction does not round to 24-bits
10503 // Cisc-alternate to reg-reg multiply
10504 instruct mulFPR_reg_mem(regFPR dst, regFPR src1, memory src2) %{
10505   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10506   match(Set dst (MulF src1 (LoadF src2)));
10507 
10508   format %{ &quot;FMUL   $dst,$src1,$src2&quot; %}
10509   opcode(0xD8, 0x1, 0xD9); /* D8 C8+i */  /* LoadF D9 /0 */
10510   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10511               OpcReg_FPR(src1),
10512               Pop_Reg_FPR(dst) );
10513   ins_pipe( fpu_reg_reg_mem );
10514 %}
10515 
10516 // Spill to obtain 24-bit precision
10517 instruct mulFPR24_mem_mem(stackSlotF dst, memory src1, memory src2) %{
10518   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10519   match(Set dst (MulF src1 src2));
10520 
10521   format %{ &quot;FMUL   $dst,$src1,$src2&quot; %}
10522   opcode(0xD8, 0x1, 0xD9); /* D8 /1 */  /* LoadF D9 /0 */
10523   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,src2),
10524               set_instruction_start,
10525               OpcP, RMopc_Mem(secondary,src1),
10526               Pop_Mem_FPR(dst) );
10527   ins_pipe( fpu_mem_mem_mem );
10528 %}
10529 
10530 // Spill to obtain 24-bit precision
10531 instruct mulFPR24_reg_imm(stackSlotF dst, regFPR src, immFPR con) %{
10532   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10533   match(Set dst (MulF src con));
10534 
10535   format %{ &quot;FLD    $src\n\t&quot;
10536             &quot;FMUL_S [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10537             &quot;FSTP_S $dst&quot;  %}
10538   ins_encode %{
10539     __ fld_s($src$$reg - 1);  // FLD ST(i-1)
10540     __ fmul_s($constantaddress($con));
10541     __ fstp_s(Address(rsp, $dst$$disp));
10542   %}
10543   ins_pipe(fpu_mem_reg_con);
10544 %}
10545 //
10546 // This instruction does not round to 24-bits
10547 instruct mulFPR_reg_imm(regFPR dst, regFPR src, immFPR con) %{
10548   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10549   match(Set dst (MulF src con));
10550 
10551   format %{ &quot;FLD    $src\n\t&quot;
10552             &quot;FMUL_S [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10553             &quot;FSTP   $dst&quot;  %}
10554   ins_encode %{
10555     __ fld_s($src$$reg - 1);  // FLD ST(i-1)
10556     __ fmul_s($constantaddress($con));
10557     __ fstp_d($dst$$reg);
10558   %}
10559   ins_pipe(fpu_reg_reg_con);
10560 %}
10561 
10562 
10563 //
10564 // MACRO1 -- subsume unshared load into mulFPR
10565 // This instruction does not round to 24-bits
10566 instruct mulFPR_reg_load1(regFPR dst, regFPR src, memory mem1 ) %{
10567   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10568   match(Set dst (MulF (LoadF mem1) src));
10569 
10570   format %{ &quot;FLD    $mem1    ===MACRO1===\n\t&quot;
10571             &quot;FMUL   ST,$src\n\t&quot;
10572             &quot;FSTP   $dst&quot; %}
10573   opcode(0xD8, 0x1, 0xD9); /* D8 C8+i or D8 /1 */  /* LoadF D9 /0 */
10574   ins_encode( Opcode(tertiary), RMopc_Mem(0x00,mem1),
10575               OpcReg_FPR(src),
10576               Pop_Reg_FPR(dst) );
10577   ins_pipe( fpu_reg_reg_mem );
10578 %}
10579 //
10580 // MACRO2 -- addFPR a mulFPR which subsumed an unshared load
10581 // This instruction does not round to 24-bits
10582 instruct addFPR_mulFPR_reg_load1(regFPR dst, memory mem1, regFPR src1, regFPR src2) %{
10583   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10584   match(Set dst (AddF (MulF (LoadF mem1) src1) src2));
10585   ins_cost(95);
10586 
10587   format %{ &quot;FLD    $mem1     ===MACRO2===\n\t&quot;
10588             &quot;FMUL   ST,$src1  subsume mulFPR left load\n\t&quot;
10589             &quot;FADD   ST,$src2\n\t&quot;
10590             &quot;FSTP   $dst&quot; %}
10591   opcode(0xD9); /* LoadF D9 /0 */
10592   ins_encode( OpcP, RMopc_Mem(0x00,mem1),
10593               FMul_ST_reg(src1),
10594               FAdd_ST_reg(src2),
10595               Pop_Reg_FPR(dst) );
10596   ins_pipe( fpu_reg_mem_reg_reg );
10597 %}
10598 
10599 // MACRO3 -- addFPR a mulFPR
10600 // This instruction does not round to 24-bits.  It is a &#39;2-address&#39;
10601 // instruction in that the result goes back to src2.  This eliminates
10602 // a move from the macro; possibly the register allocator will have
10603 // to add it back (and maybe not).
10604 instruct addFPR_mulFPR_reg(regFPR src2, regFPR src1, regFPR src0) %{
10605   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10606   match(Set src2 (AddF (MulF src0 src1) src2));
10607 
10608   format %{ &quot;FLD    $src0     ===MACRO3===\n\t&quot;
10609             &quot;FMUL   ST,$src1\n\t&quot;
10610             &quot;FADDP  $src2,ST&quot; %}
10611   opcode(0xD9); /* LoadF D9 /0 */
10612   ins_encode( Push_Reg_FPR(src0),
10613               FMul_ST_reg(src1),
10614               FAddP_reg_ST(src2) );
10615   ins_pipe( fpu_reg_reg_reg );
10616 %}
10617 
10618 // MACRO4 -- divFPR subFPR
10619 // This instruction does not round to 24-bits
10620 instruct subFPR_divFPR_reg(regFPR dst, regFPR src1, regFPR src2, regFPR src3) %{
10621   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10622   match(Set dst (DivF (SubF src2 src1) src3));
10623 
10624   format %{ &quot;FLD    $src2   ===MACRO4===\n\t&quot;
10625             &quot;FSUB   ST,$src1\n\t&quot;
10626             &quot;FDIV   ST,$src3\n\t&quot;
10627             &quot;FSTP  $dst&quot; %}
10628   opcode(0xDE, 0x7); /* DE F8+i or DE /7*/
10629   ins_encode( Push_Reg_FPR(src2),
10630               subFPR_divFPR_encode(src1,src3),
10631               Pop_Reg_FPR(dst) );
10632   ins_pipe( fpu_reg_reg_reg_reg );
10633 %}
10634 
10635 // Spill to obtain 24-bit precision
10636 instruct divFPR24_reg(stackSlotF dst, regFPR src1, regFPR src2) %{
10637   predicate(UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10638   match(Set dst (DivF src1 src2));
10639 
10640   format %{ &quot;FDIV   $dst,$src1,$src2&quot; %}
10641   opcode(0xD8, 0x6); /* D8 F0+i or DE /6*/
10642   ins_encode( Push_Reg_FPR(src1),
10643               OpcReg_FPR(src2),
10644               Pop_Mem_FPR(dst) );
10645   ins_pipe( fpu_mem_reg_reg );
10646 %}
10647 //
10648 // This instruction does not round to 24-bits
10649 instruct divFPR_reg(regFPR dst, regFPR src) %{
10650   predicate(UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10651   match(Set dst (DivF dst src));
10652 
10653   format %{ &quot;FDIV   $dst,$src&quot; %}
10654   opcode(0xDE, 0x7); /* DE F8+i or DE /7*/
10655   ins_encode( Push_Reg_FPR(src),
10656               OpcP, RegOpc(dst) );
10657   ins_pipe( fpu_reg_reg );
10658 %}
10659 
10660 
10661 // Spill to obtain 24-bit precision
10662 instruct modFPR24_reg(stackSlotF dst, regFPR src1, regFPR src2, eAXRegI rax, eFlagsReg cr) %{
10663   predicate( UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
10664   match(Set dst (ModF src1 src2));
10665   effect(KILL rax, KILL cr); // emitModDPR() uses EAX and EFLAGS
10666 
10667   format %{ &quot;FMOD   $dst,$src1,$src2&quot; %}
10668   ins_encode( Push_Reg_Mod_DPR(src1, src2),
10669               emitModDPR(),
10670               Push_Result_Mod_DPR(src2),
10671               Pop_Mem_FPR(dst));
10672   ins_pipe( pipe_slow );
10673 %}
10674 //
10675 // This instruction does not round to 24-bits
10676 instruct modFPR_reg(regFPR dst, regFPR src, eAXRegI rax, eFlagsReg cr) %{
10677   predicate( UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
10678   match(Set dst (ModF dst src));
10679   effect(KILL rax, KILL cr); // emitModDPR() uses EAX and EFLAGS
10680 
10681   format %{ &quot;FMOD   $dst,$src&quot; %}
10682   ins_encode(Push_Reg_Mod_DPR(dst, src),
10683               emitModDPR(),
10684               Push_Result_Mod_DPR(src),
10685               Pop_Reg_FPR(dst));
10686   ins_pipe( pipe_slow );
10687 %}
10688 
10689 instruct modF_reg(regF dst, regF src0, regF src1, eAXRegI rax, eFlagsReg cr) %{
10690   predicate(UseSSE&gt;=1);
10691   match(Set dst (ModF src0 src1));
10692   effect(KILL rax, KILL cr);
10693   format %{ &quot;SUB    ESP,4\t # FMOD\n&quot;
10694           &quot;\tMOVSS  [ESP+0],$src1\n&quot;
10695           &quot;\tFLD_S  [ESP+0]\n&quot;
10696           &quot;\tMOVSS  [ESP+0],$src0\n&quot;
10697           &quot;\tFLD_S  [ESP+0]\n&quot;
10698      &quot;loop:\tFPREM\n&quot;
10699           &quot;\tFWAIT\n&quot;
10700           &quot;\tFNSTSW AX\n&quot;
10701           &quot;\tSAHF\n&quot;
10702           &quot;\tJP     loop\n&quot;
10703           &quot;\tFSTP_S [ESP+0]\n&quot;
10704           &quot;\tMOVSS  $dst,[ESP+0]\n&quot;
10705           &quot;\tADD    ESP,4\n&quot;
10706           &quot;\tFSTP   ST0\t # Restore FPU Stack&quot;
10707     %}
10708   ins_cost(250);
10709   ins_encode( Push_ModF_encoding(src0, src1), emitModDPR(), Push_ResultF(dst,0x4), PopFPU);
10710   ins_pipe( pipe_slow );
10711 %}
10712 
10713 
10714 //----------Arithmetic Conversion Instructions---------------------------------
10715 // The conversions operations are all Alpha sorted.  Please keep it that way!
10716 
10717 instruct roundFloat_mem_reg(stackSlotF dst, regFPR src) %{
10718   predicate(UseSSE==0);
10719   match(Set dst (RoundFloat src));
10720   ins_cost(125);
10721   format %{ &quot;FST_S  $dst,$src\t# F-round&quot; %}
10722   ins_encode( Pop_Mem_Reg_FPR(dst, src) );
10723   ins_pipe( fpu_mem_reg );
10724 %}
10725 
10726 instruct roundDouble_mem_reg(stackSlotD dst, regDPR src) %{
10727   predicate(UseSSE&lt;=1);
10728   match(Set dst (RoundDouble src));
10729   ins_cost(125);
10730   format %{ &quot;FST_D  $dst,$src\t# D-round&quot; %}
10731   ins_encode( Pop_Mem_Reg_DPR(dst, src) );
10732   ins_pipe( fpu_mem_reg );
10733 %}
10734 
10735 // Force rounding to 24-bit precision and 6-bit exponent
10736 instruct convDPR2FPR_reg(stackSlotF dst, regDPR src) %{
10737   predicate(UseSSE==0);
10738   match(Set dst (ConvD2F src));
10739   format %{ &quot;FST_S  $dst,$src\t# F-round&quot; %}
10740   expand %{
10741     roundFloat_mem_reg(dst,src);
10742   %}
10743 %}
10744 
10745 // Force rounding to 24-bit precision and 6-bit exponent
10746 instruct convDPR2F_reg(regF dst, regDPR src, eFlagsReg cr) %{
10747   predicate(UseSSE==1);
10748   match(Set dst (ConvD2F src));
10749   effect( KILL cr );
10750   format %{ &quot;SUB    ESP,4\n\t&quot;
10751             &quot;FST_S  [ESP],$src\t# F-round\n\t&quot;
10752             &quot;MOVSS  $dst,[ESP]\n\t&quot;
10753             &quot;ADD ESP,4&quot; %}
10754   ins_encode %{
10755     __ subptr(rsp, 4);
10756     if ($src$$reg != FPR1L_enc) {
10757       __ fld_s($src$$reg-1);
10758       __ fstp_s(Address(rsp, 0));
10759     } else {
10760       __ fst_s(Address(rsp, 0));
10761     }
10762     __ movflt($dst$$XMMRegister, Address(rsp, 0));
10763     __ addptr(rsp, 4);
10764   %}
10765   ins_pipe( pipe_slow );
10766 %}
10767 
10768 // Force rounding double precision to single precision
10769 instruct convD2F_reg(regF dst, regD src) %{
10770   predicate(UseSSE&gt;=2);
10771   match(Set dst (ConvD2F src));
10772   format %{ &quot;CVTSD2SS $dst,$src\t# F-round&quot; %}
10773   ins_encode %{
10774     __ cvtsd2ss ($dst$$XMMRegister, $src$$XMMRegister);
10775   %}
10776   ins_pipe( pipe_slow );
10777 %}
10778 
10779 instruct convFPR2DPR_reg_reg(regDPR dst, regFPR src) %{
10780   predicate(UseSSE==0);
10781   match(Set dst (ConvF2D src));
10782   format %{ &quot;FST_S  $dst,$src\t# D-round&quot; %}
10783   ins_encode( Pop_Reg_Reg_DPR(dst, src));
10784   ins_pipe( fpu_reg_reg );
10785 %}
10786 
10787 instruct convFPR2D_reg(stackSlotD dst, regFPR src) %{
10788   predicate(UseSSE==1);
10789   match(Set dst (ConvF2D src));
10790   format %{ &quot;FST_D  $dst,$src\t# D-round&quot; %}
10791   expand %{
10792     roundDouble_mem_reg(dst,src);
10793   %}
10794 %}
10795 
10796 instruct convF2DPR_reg(regDPR dst, regF src, eFlagsReg cr) %{
10797   predicate(UseSSE==1);
10798   match(Set dst (ConvF2D src));
10799   effect( KILL cr );
10800   format %{ &quot;SUB    ESP,4\n\t&quot;
10801             &quot;MOVSS  [ESP] $src\n\t&quot;
10802             &quot;FLD_S  [ESP]\n\t&quot;
10803             &quot;ADD    ESP,4\n\t&quot;
10804             &quot;FSTP   $dst\t# D-round&quot; %}
10805   ins_encode %{
10806     __ subptr(rsp, 4);
10807     __ movflt(Address(rsp, 0), $src$$XMMRegister);
10808     __ fld_s(Address(rsp, 0));
10809     __ addptr(rsp, 4);
10810     __ fstp_d($dst$$reg);
10811   %}
10812   ins_pipe( pipe_slow );
10813 %}
10814 
10815 instruct convF2D_reg(regD dst, regF src) %{
10816   predicate(UseSSE&gt;=2);
10817   match(Set dst (ConvF2D src));
10818   format %{ &quot;CVTSS2SD $dst,$src\t# D-round&quot; %}
10819   ins_encode %{
10820     __ cvtss2sd ($dst$$XMMRegister, $src$$XMMRegister);
10821   %}
10822   ins_pipe( pipe_slow );
10823 %}
10824 
10825 // Convert a double to an int.  If the double is a NAN, stuff a zero in instead.
10826 instruct convDPR2I_reg_reg( eAXRegI dst, eDXRegI tmp, regDPR src, eFlagsReg cr ) %{
10827   predicate(UseSSE&lt;=1);
10828   match(Set dst (ConvD2I src));
10829   effect( KILL tmp, KILL cr );
10830   format %{ &quot;FLD    $src\t# Convert double to int \n\t&quot;
10831             &quot;FLDCW  trunc mode\n\t&quot;
10832             &quot;SUB    ESP,4\n\t&quot;
10833             &quot;FISTp  [ESP + #0]\n\t&quot;
10834             &quot;FLDCW  std/24-bit mode\n\t&quot;
10835             &quot;POP    EAX\n\t&quot;
10836             &quot;CMP    EAX,0x80000000\n\t&quot;
10837             &quot;JNE,s  fast\n\t&quot;
10838             &quot;FLD_D  $src\n\t&quot;
10839             &quot;CALL   d2i_wrapper\n&quot;
10840       &quot;fast:&quot; %}
10841   ins_encode( Push_Reg_DPR(src), DPR2I_encoding(src) );
10842   ins_pipe( pipe_slow );
10843 %}
10844 
10845 // Convert a double to an int.  If the double is a NAN, stuff a zero in instead.
10846 instruct convD2I_reg_reg( eAXRegI dst, eDXRegI tmp, regD src, eFlagsReg cr ) %{
10847   predicate(UseSSE&gt;=2);
10848   match(Set dst (ConvD2I src));
10849   effect( KILL tmp, KILL cr );
10850   format %{ &quot;CVTTSD2SI $dst, $src\n\t&quot;
10851             &quot;CMP    $dst,0x80000000\n\t&quot;
10852             &quot;JNE,s  fast\n\t&quot;
10853             &quot;SUB    ESP, 8\n\t&quot;
10854             &quot;MOVSD  [ESP], $src\n\t&quot;
10855             &quot;FLD_D  [ESP]\n\t&quot;
10856             &quot;ADD    ESP, 8\n\t&quot;
10857             &quot;CALL   d2i_wrapper\n&quot;
10858       &quot;fast:&quot; %}
10859   ins_encode %{
10860     Label fast;
10861     __ cvttsd2sil($dst$$Register, $src$$XMMRegister);
10862     __ cmpl($dst$$Register, 0x80000000);
10863     __ jccb(Assembler::notEqual, fast);
10864     __ subptr(rsp, 8);
10865     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
10866     __ fld_d(Address(rsp, 0));
10867     __ addptr(rsp, 8);
10868     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::d2i_wrapper())));
10869     __ bind(fast);
10870   %}
10871   ins_pipe( pipe_slow );
10872 %}
10873 
10874 instruct convDPR2L_reg_reg( eADXRegL dst, regDPR src, eFlagsReg cr ) %{
10875   predicate(UseSSE&lt;=1);
10876   match(Set dst (ConvD2L src));
10877   effect( KILL cr );
10878   format %{ &quot;FLD    $src\t# Convert double to long\n\t&quot;
10879             &quot;FLDCW  trunc mode\n\t&quot;
10880             &quot;SUB    ESP,8\n\t&quot;
10881             &quot;FISTp  [ESP + #0]\n\t&quot;
10882             &quot;FLDCW  std/24-bit mode\n\t&quot;
10883             &quot;POP    EAX\n\t&quot;
10884             &quot;POP    EDX\n\t&quot;
10885             &quot;CMP    EDX,0x80000000\n\t&quot;
10886             &quot;JNE,s  fast\n\t&quot;
10887             &quot;TEST   EAX,EAX\n\t&quot;
10888             &quot;JNE,s  fast\n\t&quot;
10889             &quot;FLD    $src\n\t&quot;
10890             &quot;CALL   d2l_wrapper\n&quot;
10891       &quot;fast:&quot; %}
10892   ins_encode( Push_Reg_DPR(src),  DPR2L_encoding(src) );
10893   ins_pipe( pipe_slow );
10894 %}
10895 
10896 // XMM lacks a float/double-&gt;long conversion, so use the old FPU stack.
10897 instruct convD2L_reg_reg( eADXRegL dst, regD src, eFlagsReg cr ) %{
10898   predicate (UseSSE&gt;=2);
10899   match(Set dst (ConvD2L src));
10900   effect( KILL cr );
10901   format %{ &quot;SUB    ESP,8\t# Convert double to long\n\t&quot;
10902             &quot;MOVSD  [ESP],$src\n\t&quot;
10903             &quot;FLD_D  [ESP]\n\t&quot;
10904             &quot;FLDCW  trunc mode\n\t&quot;
10905             &quot;FISTp  [ESP + #0]\n\t&quot;
10906             &quot;FLDCW  std/24-bit mode\n\t&quot;
10907             &quot;POP    EAX\n\t&quot;
10908             &quot;POP    EDX\n\t&quot;
10909             &quot;CMP    EDX,0x80000000\n\t&quot;
10910             &quot;JNE,s  fast\n\t&quot;
10911             &quot;TEST   EAX,EAX\n\t&quot;
10912             &quot;JNE,s  fast\n\t&quot;
10913             &quot;SUB    ESP,8\n\t&quot;
10914             &quot;MOVSD  [ESP],$src\n\t&quot;
10915             &quot;FLD_D  [ESP]\n\t&quot;
10916             &quot;ADD    ESP,8\n\t&quot;
10917             &quot;CALL   d2l_wrapper\n&quot;
10918       &quot;fast:&quot; %}
10919   ins_encode %{
10920     Label fast;
10921     __ subptr(rsp, 8);
10922     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
10923     __ fld_d(Address(rsp, 0));
10924     __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_trunc()));
10925     __ fistp_d(Address(rsp, 0));
10926     // Restore the rounding mode, mask the exception
10927     if (Compile::current()-&gt;in_24_bit_fp_mode()) {
10928       __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));
10929     } else {
10930       __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
10931     }
10932     // Load the converted long, adjust CPU stack
10933     __ pop(rax);
10934     __ pop(rdx);
10935     __ cmpl(rdx, 0x80000000);
10936     __ jccb(Assembler::notEqual, fast);
10937     __ testl(rax, rax);
10938     __ jccb(Assembler::notEqual, fast);
10939     __ subptr(rsp, 8);
10940     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
10941     __ fld_d(Address(rsp, 0));
10942     __ addptr(rsp, 8);
10943     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::d2l_wrapper())));
10944     __ bind(fast);
10945   %}
10946   ins_pipe( pipe_slow );
10947 %}
10948 
10949 // Convert a double to an int.  Java semantics require we do complex
10950 // manglations in the corner cases.  So we set the rounding mode to
10951 // &#39;zero&#39;, store the darned double down as an int, and reset the
10952 // rounding mode to &#39;nearest&#39;.  The hardware stores a flag value down
10953 // if we would overflow or converted a NAN; we check for this and
10954 // and go the slow path if needed.
10955 instruct convFPR2I_reg_reg(eAXRegI dst, eDXRegI tmp, regFPR src, eFlagsReg cr ) %{
10956   predicate(UseSSE==0);
10957   match(Set dst (ConvF2I src));
10958   effect( KILL tmp, KILL cr );
10959   format %{ &quot;FLD    $src\t# Convert float to int \n\t&quot;
10960             &quot;FLDCW  trunc mode\n\t&quot;
10961             &quot;SUB    ESP,4\n\t&quot;
10962             &quot;FISTp  [ESP + #0]\n\t&quot;
10963             &quot;FLDCW  std/24-bit mode\n\t&quot;
10964             &quot;POP    EAX\n\t&quot;
10965             &quot;CMP    EAX,0x80000000\n\t&quot;
10966             &quot;JNE,s  fast\n\t&quot;
10967             &quot;FLD    $src\n\t&quot;
10968             &quot;CALL   d2i_wrapper\n&quot;
10969       &quot;fast:&quot; %}
10970   // DPR2I_encoding works for FPR2I
10971   ins_encode( Push_Reg_FPR(src), DPR2I_encoding(src) );
10972   ins_pipe( pipe_slow );
10973 %}
10974 
10975 // Convert a float in xmm to an int reg.
10976 instruct convF2I_reg(eAXRegI dst, eDXRegI tmp, regF src, eFlagsReg cr ) %{
10977   predicate(UseSSE&gt;=1);
10978   match(Set dst (ConvF2I src));
10979   effect( KILL tmp, KILL cr );
10980   format %{ &quot;CVTTSS2SI $dst, $src\n\t&quot;
10981             &quot;CMP    $dst,0x80000000\n\t&quot;
10982             &quot;JNE,s  fast\n\t&quot;
10983             &quot;SUB    ESP, 4\n\t&quot;
10984             &quot;MOVSS  [ESP], $src\n\t&quot;
10985             &quot;FLD    [ESP]\n\t&quot;
10986             &quot;ADD    ESP, 4\n\t&quot;
10987             &quot;CALL   d2i_wrapper\n&quot;
10988       &quot;fast:&quot; %}
10989   ins_encode %{
10990     Label fast;
10991     __ cvttss2sil($dst$$Register, $src$$XMMRegister);
10992     __ cmpl($dst$$Register, 0x80000000);
10993     __ jccb(Assembler::notEqual, fast);
10994     __ subptr(rsp, 4);
10995     __ movflt(Address(rsp, 0), $src$$XMMRegister);
10996     __ fld_s(Address(rsp, 0));
10997     __ addptr(rsp, 4);
10998     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::d2i_wrapper())));
10999     __ bind(fast);
11000   %}
11001   ins_pipe( pipe_slow );
11002 %}
11003 
11004 instruct convFPR2L_reg_reg( eADXRegL dst, regFPR src, eFlagsReg cr ) %{
11005   predicate(UseSSE==0);
11006   match(Set dst (ConvF2L src));
11007   effect( KILL cr );
11008   format %{ &quot;FLD    $src\t# Convert float to long\n\t&quot;
11009             &quot;FLDCW  trunc mode\n\t&quot;
11010             &quot;SUB    ESP,8\n\t&quot;
11011             &quot;FISTp  [ESP + #0]\n\t&quot;
11012             &quot;FLDCW  std/24-bit mode\n\t&quot;
11013             &quot;POP    EAX\n\t&quot;
11014             &quot;POP    EDX\n\t&quot;
11015             &quot;CMP    EDX,0x80000000\n\t&quot;
11016             &quot;JNE,s  fast\n\t&quot;
11017             &quot;TEST   EAX,EAX\n\t&quot;
11018             &quot;JNE,s  fast\n\t&quot;
11019             &quot;FLD    $src\n\t&quot;
11020             &quot;CALL   d2l_wrapper\n&quot;
11021       &quot;fast:&quot; %}
11022   // DPR2L_encoding works for FPR2L
11023   ins_encode( Push_Reg_FPR(src), DPR2L_encoding(src) );
11024   ins_pipe( pipe_slow );
11025 %}
11026 
11027 // XMM lacks a float/double-&gt;long conversion, so use the old FPU stack.
11028 instruct convF2L_reg_reg( eADXRegL dst, regF src, eFlagsReg cr ) %{
11029   predicate (UseSSE&gt;=1);
11030   match(Set dst (ConvF2L src));
11031   effect( KILL cr );
11032   format %{ &quot;SUB    ESP,8\t# Convert float to long\n\t&quot;
11033             &quot;MOVSS  [ESP],$src\n\t&quot;
11034             &quot;FLD_S  [ESP]\n\t&quot;
11035             &quot;FLDCW  trunc mode\n\t&quot;
11036             &quot;FISTp  [ESP + #0]\n\t&quot;
11037             &quot;FLDCW  std/24-bit mode\n\t&quot;
11038             &quot;POP    EAX\n\t&quot;
11039             &quot;POP    EDX\n\t&quot;
11040             &quot;CMP    EDX,0x80000000\n\t&quot;
11041             &quot;JNE,s  fast\n\t&quot;
11042             &quot;TEST   EAX,EAX\n\t&quot;
11043             &quot;JNE,s  fast\n\t&quot;
11044             &quot;SUB    ESP,4\t# Convert float to long\n\t&quot;
11045             &quot;MOVSS  [ESP],$src\n\t&quot;
11046             &quot;FLD_S  [ESP]\n\t&quot;
11047             &quot;ADD    ESP,4\n\t&quot;
11048             &quot;CALL   d2l_wrapper\n&quot;
11049       &quot;fast:&quot; %}
11050   ins_encode %{
11051     Label fast;
11052     __ subptr(rsp, 8);
11053     __ movflt(Address(rsp, 0), $src$$XMMRegister);
11054     __ fld_s(Address(rsp, 0));
11055     __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_trunc()));
11056     __ fistp_d(Address(rsp, 0));
11057     // Restore the rounding mode, mask the exception
11058     if (Compile::current()-&gt;in_24_bit_fp_mode()) {
11059       __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));
11060     } else {
11061       __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
11062     }
11063     // Load the converted long, adjust CPU stack
11064     __ pop(rax);
11065     __ pop(rdx);
11066     __ cmpl(rdx, 0x80000000);
11067     __ jccb(Assembler::notEqual, fast);
11068     __ testl(rax, rax);
11069     __ jccb(Assembler::notEqual, fast);
11070     __ subptr(rsp, 4);
11071     __ movflt(Address(rsp, 0), $src$$XMMRegister);
11072     __ fld_s(Address(rsp, 0));
11073     __ addptr(rsp, 4);
11074     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::d2l_wrapper())));
11075     __ bind(fast);
11076   %}
11077   ins_pipe( pipe_slow );
11078 %}
11079 
11080 instruct convI2DPR_reg(regDPR dst, stackSlotI src) %{
11081   predicate( UseSSE&lt;=1 );
11082   match(Set dst (ConvI2D src));
11083   format %{ &quot;FILD   $src\n\t&quot;
11084             &quot;FSTP   $dst&quot; %}
11085   opcode(0xDB, 0x0);  /* DB /0 */
11086   ins_encode(Push_Mem_I(src), Pop_Reg_DPR(dst));
11087   ins_pipe( fpu_reg_mem );
11088 %}
11089 
11090 instruct convI2D_reg(regD dst, rRegI src) %{
11091   predicate( UseSSE&gt;=2 &amp;&amp; !UseXmmI2D );
11092   match(Set dst (ConvI2D src));
11093   format %{ &quot;CVTSI2SD $dst,$src&quot; %}
11094   ins_encode %{
11095     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Register);
11096   %}
11097   ins_pipe( pipe_slow );
11098 %}
11099 
11100 instruct convI2D_mem(regD dst, memory mem) %{
11101   predicate( UseSSE&gt;=2 );
11102   match(Set dst (ConvI2D (LoadI mem)));
11103   format %{ &quot;CVTSI2SD $dst,$mem&quot; %}
11104   ins_encode %{
11105     __ cvtsi2sdl ($dst$$XMMRegister, $mem$$Address);
11106   %}
11107   ins_pipe( pipe_slow );
11108 %}
11109 
11110 instruct convXI2D_reg(regD dst, rRegI src)
11111 %{
11112   predicate( UseSSE&gt;=2 &amp;&amp; UseXmmI2D );
11113   match(Set dst (ConvI2D src));
11114 
11115   format %{ &quot;MOVD  $dst,$src\n\t&quot;
11116             &quot;CVTDQ2PD $dst,$dst\t# i2d&quot; %}
11117   ins_encode %{
11118     __ movdl($dst$$XMMRegister, $src$$Register);
11119     __ cvtdq2pd($dst$$XMMRegister, $dst$$XMMRegister);
11120   %}
11121   ins_pipe(pipe_slow); // XXX
11122 %}
11123 
11124 instruct convI2DPR_mem(regDPR dst, memory mem) %{
11125   predicate( UseSSE&lt;=1 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
11126   match(Set dst (ConvI2D (LoadI mem)));
11127   format %{ &quot;FILD   $mem\n\t&quot;
11128             &quot;FSTP   $dst&quot; %}
11129   opcode(0xDB);      /* DB /0 */
11130   ins_encode( OpcP, RMopc_Mem(0x00,mem),
11131               Pop_Reg_DPR(dst));
11132   ins_pipe( fpu_reg_mem );
11133 %}
11134 
11135 // Convert a byte to a float; no rounding step needed.
11136 instruct conv24I2FPR_reg(regFPR dst, stackSlotI src) %{
11137   predicate( UseSSE==0 &amp;&amp; n-&gt;in(1)-&gt;Opcode() == Op_AndI &amp;&amp; n-&gt;in(1)-&gt;in(2)-&gt;is_Con() &amp;&amp; n-&gt;in(1)-&gt;in(2)-&gt;get_int() == 255 );
11138   match(Set dst (ConvI2F src));
11139   format %{ &quot;FILD   $src\n\t&quot;
11140             &quot;FSTP   $dst&quot; %}
11141 
11142   opcode(0xDB, 0x0);  /* DB /0 */
11143   ins_encode(Push_Mem_I(src), Pop_Reg_FPR(dst));
11144   ins_pipe( fpu_reg_mem );
11145 %}
11146 
11147 // In 24-bit mode, force exponent rounding by storing back out
11148 instruct convI2FPR_SSF(stackSlotF dst, stackSlotI src) %{
11149   predicate( UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
11150   match(Set dst (ConvI2F src));
11151   ins_cost(200);
11152   format %{ &quot;FILD   $src\n\t&quot;
11153             &quot;FSTP_S $dst&quot; %}
11154   opcode(0xDB, 0x0);  /* DB /0 */
11155   ins_encode( Push_Mem_I(src),
11156               Pop_Mem_FPR(dst));
11157   ins_pipe( fpu_mem_mem );
11158 %}
11159 
11160 // In 24-bit mode, force exponent rounding by storing back out
11161 instruct convI2FPR_SSF_mem(stackSlotF dst, memory mem) %{
11162   predicate( UseSSE==0 &amp;&amp; Compile::current()-&gt;select_24_bit_instr());
11163   match(Set dst (ConvI2F (LoadI mem)));
11164   ins_cost(200);
11165   format %{ &quot;FILD   $mem\n\t&quot;
11166             &quot;FSTP_S $dst&quot; %}
11167   opcode(0xDB);  /* DB /0 */
11168   ins_encode( OpcP, RMopc_Mem(0x00,mem),
11169               Pop_Mem_FPR(dst));
11170   ins_pipe( fpu_mem_mem );
11171 %}
11172 
11173 // This instruction does not round to 24-bits
11174 instruct convI2FPR_reg(regFPR dst, stackSlotI src) %{
11175   predicate( UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
11176   match(Set dst (ConvI2F src));
11177   format %{ &quot;FILD   $src\n\t&quot;
11178             &quot;FSTP   $dst&quot; %}
11179   opcode(0xDB, 0x0);  /* DB /0 */
11180   ins_encode( Push_Mem_I(src),
11181               Pop_Reg_FPR(dst));
11182   ins_pipe( fpu_reg_mem );
11183 %}
11184 
11185 // This instruction does not round to 24-bits
11186 instruct convI2FPR_mem(regFPR dst, memory mem) %{
11187   predicate( UseSSE==0 &amp;&amp; !Compile::current()-&gt;select_24_bit_instr());
11188   match(Set dst (ConvI2F (LoadI mem)));
11189   format %{ &quot;FILD   $mem\n\t&quot;
11190             &quot;FSTP   $dst&quot; %}
11191   opcode(0xDB);      /* DB /0 */
11192   ins_encode( OpcP, RMopc_Mem(0x00,mem),
11193               Pop_Reg_FPR(dst));
11194   ins_pipe( fpu_reg_mem );
11195 %}
11196 
11197 // Convert an int to a float in xmm; no rounding step needed.
11198 instruct convI2F_reg(regF dst, rRegI src) %{
11199   predicate( UseSSE==1 || UseSSE&gt;=2 &amp;&amp; !UseXmmI2F );
11200   match(Set dst (ConvI2F src));
11201   format %{ &quot;CVTSI2SS $dst, $src&quot; %}
11202   ins_encode %{
11203     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Register);
11204   %}
11205   ins_pipe( pipe_slow );
11206 %}
11207 
11208  instruct convXI2F_reg(regF dst, rRegI src)
11209 %{
11210   predicate( UseSSE&gt;=2 &amp;&amp; UseXmmI2F );
11211   match(Set dst (ConvI2F src));
11212 
11213   format %{ &quot;MOVD  $dst,$src\n\t&quot;
11214             &quot;CVTDQ2PS $dst,$dst\t# i2f&quot; %}
11215   ins_encode %{
11216     __ movdl($dst$$XMMRegister, $src$$Register);
11217     __ cvtdq2ps($dst$$XMMRegister, $dst$$XMMRegister);
11218   %}
11219   ins_pipe(pipe_slow); // XXX
11220 %}
11221 
11222 instruct convI2L_reg( eRegL dst, rRegI src, eFlagsReg cr) %{
11223   match(Set dst (ConvI2L src));
11224   effect(KILL cr);
11225   ins_cost(375);
11226   format %{ &quot;MOV    $dst.lo,$src\n\t&quot;
11227             &quot;MOV    $dst.hi,$src\n\t&quot;
11228             &quot;SAR    $dst.hi,31&quot; %}
11229   ins_encode(convert_int_long(dst,src));
11230   ins_pipe( ialu_reg_reg_long );
11231 %}
11232 
11233 // Zero-extend convert int to long
11234 instruct convI2L_reg_zex(eRegL dst, rRegI src, immL_32bits mask, eFlagsReg flags ) %{
11235   match(Set dst (AndL (ConvI2L src) mask) );
11236   effect( KILL flags );
11237   ins_cost(250);
11238   format %{ &quot;MOV    $dst.lo,$src\n\t&quot;
11239             &quot;XOR    $dst.hi,$dst.hi&quot; %}
11240   opcode(0x33); // XOR
11241   ins_encode(enc_Copy(dst,src), OpcP, RegReg_Hi2(dst,dst) );
11242   ins_pipe( ialu_reg_reg_long );
11243 %}
11244 
11245 // Zero-extend long
11246 instruct zerox_long(eRegL dst, eRegL src, immL_32bits mask, eFlagsReg flags ) %{
11247   match(Set dst (AndL src mask) );
11248   effect( KILL flags );
11249   ins_cost(250);
11250   format %{ &quot;MOV    $dst.lo,$src.lo\n\t&quot;
11251             &quot;XOR    $dst.hi,$dst.hi\n\t&quot; %}
11252   opcode(0x33); // XOR
11253   ins_encode(enc_Copy(dst,src), OpcP, RegReg_Hi2(dst,dst) );
11254   ins_pipe( ialu_reg_reg_long );
11255 %}
11256 
11257 instruct convL2DPR_reg( stackSlotD dst, eRegL src, eFlagsReg cr) %{
11258   predicate (UseSSE&lt;=1);
11259   match(Set dst (ConvL2D src));
11260   effect( KILL cr );
11261   format %{ &quot;PUSH   $src.hi\t# Convert long to double\n\t&quot;
11262             &quot;PUSH   $src.lo\n\t&quot;
11263             &quot;FILD   ST,[ESP + #0]\n\t&quot;
11264             &quot;ADD    ESP,8\n\t&quot;
11265             &quot;FSTP_D $dst\t# D-round&quot; %}
11266   opcode(0xDF, 0x5);  /* DF /5 */
11267   ins_encode(convert_long_double(src), Pop_Mem_DPR(dst));
11268   ins_pipe( pipe_slow );
11269 %}
11270 
11271 instruct convL2D_reg( regD dst, eRegL src, eFlagsReg cr) %{
11272   predicate (UseSSE&gt;=2);
11273   match(Set dst (ConvL2D src));
11274   effect( KILL cr );
11275   format %{ &quot;PUSH   $src.hi\t# Convert long to double\n\t&quot;
11276             &quot;PUSH   $src.lo\n\t&quot;
11277             &quot;FILD_D [ESP]\n\t&quot;
11278             &quot;FSTP_D [ESP]\n\t&quot;
11279             &quot;MOVSD  $dst,[ESP]\n\t&quot;
11280             &quot;ADD    ESP,8&quot; %}
11281   opcode(0xDF, 0x5);  /* DF /5 */
11282   ins_encode(convert_long_double2(src), Push_ResultD(dst));
11283   ins_pipe( pipe_slow );
11284 %}
11285 
11286 instruct convL2F_reg( regF dst, eRegL src, eFlagsReg cr) %{
11287   predicate (UseSSE&gt;=1);
11288   match(Set dst (ConvL2F src));
11289   effect( KILL cr );
11290   format %{ &quot;PUSH   $src.hi\t# Convert long to single float\n\t&quot;
11291             &quot;PUSH   $src.lo\n\t&quot;
11292             &quot;FILD_D [ESP]\n\t&quot;
11293             &quot;FSTP_S [ESP]\n\t&quot;
11294             &quot;MOVSS  $dst,[ESP]\n\t&quot;
11295             &quot;ADD    ESP,8&quot; %}
11296   opcode(0xDF, 0x5);  /* DF /5 */
11297   ins_encode(convert_long_double2(src), Push_ResultF(dst,0x8));
11298   ins_pipe( pipe_slow );
11299 %}
11300 
11301 instruct convL2FPR_reg( stackSlotF dst, eRegL src, eFlagsReg cr) %{
11302   match(Set dst (ConvL2F src));
11303   effect( KILL cr );
11304   format %{ &quot;PUSH   $src.hi\t# Convert long to single float\n\t&quot;
11305             &quot;PUSH   $src.lo\n\t&quot;
11306             &quot;FILD   ST,[ESP + #0]\n\t&quot;
11307             &quot;ADD    ESP,8\n\t&quot;
11308             &quot;FSTP_S $dst\t# F-round&quot; %}
11309   opcode(0xDF, 0x5);  /* DF /5 */
11310   ins_encode(convert_long_double(src), Pop_Mem_FPR(dst));
11311   ins_pipe( pipe_slow );
11312 %}
11313 
11314 instruct convL2I_reg( rRegI dst, eRegL src ) %{
11315   match(Set dst (ConvL2I src));
11316   effect( DEF dst, USE src );
11317   format %{ &quot;MOV    $dst,$src.lo&quot; %}
11318   ins_encode(enc_CopyL_Lo(dst,src));
11319   ins_pipe( ialu_reg_reg );
11320 %}
11321 
11322 instruct MoveF2I_stack_reg(rRegI dst, stackSlotF src) %{
11323   match(Set dst (MoveF2I src));
11324   effect( DEF dst, USE src );
11325   ins_cost(100);
11326   format %{ &quot;MOV    $dst,$src\t# MoveF2I_stack_reg&quot; %}
11327   ins_encode %{
11328     __ movl($dst$$Register, Address(rsp, $src$$disp));
11329   %}
11330   ins_pipe( ialu_reg_mem );
11331 %}
11332 
11333 instruct MoveFPR2I_reg_stack(stackSlotI dst, regFPR src) %{
11334   predicate(UseSSE==0);
11335   match(Set dst (MoveF2I src));
11336   effect( DEF dst, USE src );
11337 
11338   ins_cost(125);
11339   format %{ &quot;FST_S  $dst,$src\t# MoveF2I_reg_stack&quot; %}
11340   ins_encode( Pop_Mem_Reg_FPR(dst, src) );
11341   ins_pipe( fpu_mem_reg );
11342 %}
11343 
11344 instruct MoveF2I_reg_stack_sse(stackSlotI dst, regF src) %{
11345   predicate(UseSSE&gt;=1);
11346   match(Set dst (MoveF2I src));
11347   effect( DEF dst, USE src );
11348 
11349   ins_cost(95);
11350   format %{ &quot;MOVSS  $dst,$src\t# MoveF2I_reg_stack_sse&quot; %}
11351   ins_encode %{
11352     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
11353   %}
11354   ins_pipe( pipe_slow );
11355 %}
11356 
11357 instruct MoveF2I_reg_reg_sse(rRegI dst, regF src) %{
11358   predicate(UseSSE&gt;=2);
11359   match(Set dst (MoveF2I src));
11360   effect( DEF dst, USE src );
11361   ins_cost(85);
11362   format %{ &quot;MOVD   $dst,$src\t# MoveF2I_reg_reg_sse&quot; %}
11363   ins_encode %{
11364     __ movdl($dst$$Register, $src$$XMMRegister);
11365   %}
11366   ins_pipe( pipe_slow );
11367 %}
11368 
11369 instruct MoveI2F_reg_stack(stackSlotF dst, rRegI src) %{
11370   match(Set dst (MoveI2F src));
11371   effect( DEF dst, USE src );
11372 
11373   ins_cost(100);
11374   format %{ &quot;MOV    $dst,$src\t# MoveI2F_reg_stack&quot; %}
11375   ins_encode %{
11376     __ movl(Address(rsp, $dst$$disp), $src$$Register);
11377   %}
11378   ins_pipe( ialu_mem_reg );
11379 %}
11380 
11381 
11382 instruct MoveI2FPR_stack_reg(regFPR dst, stackSlotI src) %{
11383   predicate(UseSSE==0);
11384   match(Set dst (MoveI2F src));
11385   effect(DEF dst, USE src);
11386 
11387   ins_cost(125);
11388   format %{ &quot;FLD_S  $src\n\t&quot;
11389             &quot;FSTP   $dst\t# MoveI2F_stack_reg&quot; %}
11390   opcode(0xD9);               /* D9 /0, FLD m32real */
11391   ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),
11392               Pop_Reg_FPR(dst) );
11393   ins_pipe( fpu_reg_mem );
11394 %}
11395 
11396 instruct MoveI2F_stack_reg_sse(regF dst, stackSlotI src) %{
11397   predicate(UseSSE&gt;=1);
11398   match(Set dst (MoveI2F src));
11399   effect( DEF dst, USE src );
11400 
11401   ins_cost(95);
11402   format %{ &quot;MOVSS  $dst,$src\t# MoveI2F_stack_reg_sse&quot; %}
11403   ins_encode %{
11404     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
11405   %}
11406   ins_pipe( pipe_slow );
11407 %}
11408 
11409 instruct MoveI2F_reg_reg_sse(regF dst, rRegI src) %{
11410   predicate(UseSSE&gt;=2);
11411   match(Set dst (MoveI2F src));
11412   effect( DEF dst, USE src );
11413 
11414   ins_cost(85);
11415   format %{ &quot;MOVD   $dst,$src\t# MoveI2F_reg_reg_sse&quot; %}
11416   ins_encode %{
11417     __ movdl($dst$$XMMRegister, $src$$Register);
11418   %}
11419   ins_pipe( pipe_slow );
11420 %}
11421 
11422 instruct MoveD2L_stack_reg(eRegL dst, stackSlotD src) %{
11423   match(Set dst (MoveD2L src));
11424   effect(DEF dst, USE src);
11425 
11426   ins_cost(250);
11427   format %{ &quot;MOV    $dst.lo,$src\n\t&quot;
11428             &quot;MOV    $dst.hi,$src+4\t# MoveD2L_stack_reg&quot; %}
11429   opcode(0x8B, 0x8B);
11430   ins_encode( OpcP, RegMem(dst,src), OpcS, RegMem_Hi(dst,src));
11431   ins_pipe( ialu_mem_long_reg );
11432 %}
11433 
11434 instruct MoveDPR2L_reg_stack(stackSlotL dst, regDPR src) %{
11435   predicate(UseSSE&lt;=1);
11436   match(Set dst (MoveD2L src));
11437   effect(DEF dst, USE src);
11438 
11439   ins_cost(125);
11440   format %{ &quot;FST_D  $dst,$src\t# MoveD2L_reg_stack&quot; %}
11441   ins_encode( Pop_Mem_Reg_DPR(dst, src) );
11442   ins_pipe( fpu_mem_reg );
11443 %}
11444 
11445 instruct MoveD2L_reg_stack_sse(stackSlotL dst, regD src) %{
11446   predicate(UseSSE&gt;=2);
11447   match(Set dst (MoveD2L src));
11448   effect(DEF dst, USE src);
11449   ins_cost(95);
11450   format %{ &quot;MOVSD  $dst,$src\t# MoveD2L_reg_stack_sse&quot; %}
11451   ins_encode %{
11452     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
11453   %}
11454   ins_pipe( pipe_slow );
11455 %}
11456 
11457 instruct MoveD2L_reg_reg_sse(eRegL dst, regD src, regD tmp) %{
11458   predicate(UseSSE&gt;=2);
11459   match(Set dst (MoveD2L src));
11460   effect(DEF dst, USE src, TEMP tmp);
11461   ins_cost(85);
11462   format %{ &quot;MOVD   $dst.lo,$src\n\t&quot;
11463             &quot;PSHUFLW $tmp,$src,0x4E\n\t&quot;
11464             &quot;MOVD   $dst.hi,$tmp\t# MoveD2L_reg_reg_sse&quot; %}
11465   ins_encode %{
11466     __ movdl($dst$$Register, $src$$XMMRegister);
11467     __ pshuflw($tmp$$XMMRegister, $src$$XMMRegister, 0x4e);
11468     __ movdl(HIGH_FROM_LOW($dst$$Register), $tmp$$XMMRegister);
11469   %}
11470   ins_pipe( pipe_slow );
11471 %}
11472 
11473 instruct MoveL2D_reg_stack(stackSlotD dst, eRegL src) %{
11474   match(Set dst (MoveL2D src));
11475   effect(DEF dst, USE src);
11476 
11477   ins_cost(200);
11478   format %{ &quot;MOV    $dst,$src.lo\n\t&quot;
11479             &quot;MOV    $dst+4,$src.hi\t# MoveL2D_reg_stack&quot; %}
11480   opcode(0x89, 0x89);
11481   ins_encode( OpcP, RegMem( src, dst ), OpcS, RegMem_Hi( src, dst ) );
11482   ins_pipe( ialu_mem_long_reg );
11483 %}
11484 
11485 
11486 instruct MoveL2DPR_stack_reg(regDPR dst, stackSlotL src) %{
11487   predicate(UseSSE&lt;=1);
11488   match(Set dst (MoveL2D src));
11489   effect(DEF dst, USE src);
11490   ins_cost(125);
11491 
11492   format %{ &quot;FLD_D  $src\n\t&quot;
11493             &quot;FSTP   $dst\t# MoveL2D_stack_reg&quot; %}
11494   opcode(0xDD);               /* DD /0, FLD m64real */
11495   ins_encode( OpcP, RMopc_Mem_no_oop(0x00,src),
11496               Pop_Reg_DPR(dst) );
11497   ins_pipe( fpu_reg_mem );
11498 %}
11499 
11500 
11501 instruct MoveL2D_stack_reg_sse(regD dst, stackSlotL src) %{
11502   predicate(UseSSE&gt;=2 &amp;&amp; UseXmmLoadAndClearUpper);
11503   match(Set dst (MoveL2D src));
11504   effect(DEF dst, USE src);
11505 
11506   ins_cost(95);
11507   format %{ &quot;MOVSD  $dst,$src\t# MoveL2D_stack_reg_sse&quot; %}
11508   ins_encode %{
11509     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
11510   %}
11511   ins_pipe( pipe_slow );
11512 %}
11513 
11514 instruct MoveL2D_stack_reg_sse_partial(regD dst, stackSlotL src) %{
11515   predicate(UseSSE&gt;=2 &amp;&amp; !UseXmmLoadAndClearUpper);
11516   match(Set dst (MoveL2D src));
11517   effect(DEF dst, USE src);
11518 
11519   ins_cost(95);
11520   format %{ &quot;MOVLPD $dst,$src\t# MoveL2D_stack_reg_sse&quot; %}
11521   ins_encode %{
11522     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
11523   %}
11524   ins_pipe( pipe_slow );
11525 %}
11526 
11527 instruct MoveL2D_reg_reg_sse(regD dst, eRegL src, regD tmp) %{
11528   predicate(UseSSE&gt;=2);
11529   match(Set dst (MoveL2D src));
11530   effect(TEMP dst, USE src, TEMP tmp);
11531   ins_cost(85);
11532   format %{ &quot;MOVD   $dst,$src.lo\n\t&quot;
11533             &quot;MOVD   $tmp,$src.hi\n\t&quot;
11534             &quot;PUNPCKLDQ $dst,$tmp\t# MoveL2D_reg_reg_sse&quot; %}
11535   ins_encode %{
11536     __ movdl($dst$$XMMRegister, $src$$Register);
11537     __ movdl($tmp$$XMMRegister, HIGH_FROM_LOW($src$$Register));
11538     __ punpckldq($dst$$XMMRegister, $tmp$$XMMRegister);
11539   %}
11540   ins_pipe( pipe_slow );
11541 %}
11542 
11543 
11544 // =======================================================================
11545 // fast clearing of an array
11546 instruct rep_stos(eCXRegI cnt, eDIRegP base, regD tmp, eAXRegI zero, Universe dummy, eFlagsReg cr) %{
11547   predicate(!((ClearArrayNode*)n)-&gt;is_large());
11548   match(Set dummy (ClearArray cnt base));
11549   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);
11550 
11551   format %{ $$template
11552     $$emit$$&quot;XOR    EAX,EAX\t# ClearArray:\n\t&quot;
11553     $$emit$$&quot;CMP    InitArrayShortSize,rcx\n\t&quot;
11554     $$emit$$&quot;JG     LARGE\n\t&quot;
11555     $$emit$$&quot;SHL    ECX, 1\n\t&quot;
11556     $$emit$$&quot;DEC    ECX\n\t&quot;
11557     $$emit$$&quot;JS     DONE\t# Zero length\n\t&quot;
11558     $$emit$$&quot;MOV    EAX,(EDI,ECX,4)\t# LOOP\n\t&quot;
11559     $$emit$$&quot;DEC    ECX\n\t&quot;
11560     $$emit$$&quot;JGE    LOOP\n\t&quot;
11561     $$emit$$&quot;JMP    DONE\n\t&quot;
11562     $$emit$$&quot;# LARGE:\n\t&quot;
11563     if (UseFastStosb) {
11564        $$emit$$&quot;SHL    ECX,3\t# Convert doublewords to bytes\n\t&quot;
11565        $$emit$$&quot;REP STOSB\t# store EAX into [EDI++] while ECX--\n\t&quot;
11566     } else if (UseXMMForObjInit) {
11567        $$emit$$&quot;MOV     RDI,RAX\n\t&quot;
11568        $$emit$$&quot;VPXOR    YMM0,YMM0,YMM0\n\t&quot;
11569        $$emit$$&quot;JMPQ    L_zero_64_bytes\n\t&quot;
11570        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11571        $$emit$$&quot;VMOVDQU YMM0,(RAX)\n\t&quot;
11572        $$emit$$&quot;VMOVDQU YMM0,0x20(RAX)\n\t&quot;
11573        $$emit$$&quot;ADD     0x40,RAX\n\t&quot;
11574        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11575        $$emit$$&quot;SUB     0x8,RCX\n\t&quot;
11576        $$emit$$&quot;JGE     L_loop\n\t&quot;
11577        $$emit$$&quot;ADD     0x4,RCX\n\t&quot;
11578        $$emit$$&quot;JL      L_tail\n\t&quot;
11579        $$emit$$&quot;VMOVDQU YMM0,(RAX)\n\t&quot;
11580        $$emit$$&quot;ADD     0x20,RAX\n\t&quot;
11581        $$emit$$&quot;SUB     0x4,RCX\n\t&quot;
11582        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11583        $$emit$$&quot;ADD     0x4,RCX\n\t&quot;
11584        $$emit$$&quot;JLE     L_end\n\t&quot;
11585        $$emit$$&quot;DEC     RCX\n\t&quot;
11586        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11587        $$emit$$&quot;VMOVQ   XMM0,(RAX)\n\t&quot;
11588        $$emit$$&quot;ADD     0x8,RAX\n\t&quot;
11589        $$emit$$&quot;DEC     RCX\n\t&quot;
11590        $$emit$$&quot;JGE     L_sloop\n\t&quot;
11591        $$emit$$&quot;# L_end:\n\t&quot;
11592     } else {
11593        $$emit$$&quot;SHL    ECX,1\t# Convert doublewords to words\n\t&quot;
11594        $$emit$$&quot;REP STOS\t# store EAX into [EDI++] while ECX--\n\t&quot;
11595     }
11596     $$emit$$&quot;# DONE&quot;
11597   %}
11598   ins_encode %{
11599     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,
11600                  $tmp$$XMMRegister, false);
11601   %}
11602   ins_pipe( pipe_slow );
11603 %}
11604 
11605 instruct rep_stos_large(eCXRegI cnt, eDIRegP base, regD tmp, eAXRegI zero, Universe dummy, eFlagsReg cr) %{
11606   predicate(((ClearArrayNode*)n)-&gt;is_large());
11607   match(Set dummy (ClearArray cnt base));
11608   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);
11609   format %{ $$template
11610     if (UseFastStosb) {
11611        $$emit$$&quot;XOR    EAX,EAX\t# ClearArray:\n\t&quot;
11612        $$emit$$&quot;SHL    ECX,3\t# Convert doublewords to bytes\n\t&quot;
11613        $$emit$$&quot;REP STOSB\t# store EAX into [EDI++] while ECX--\n\t&quot;
11614     } else if (UseXMMForObjInit) {
11615        $$emit$$&quot;MOV     RDI,RAX\t# ClearArray:\n\t&quot;
11616        $$emit$$&quot;VPXOR   YMM0,YMM0,YMM0\n\t&quot;
11617        $$emit$$&quot;JMPQ    L_zero_64_bytes\n\t&quot;
11618        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11619        $$emit$$&quot;VMOVDQU YMM0,(RAX)\n\t&quot;
11620        $$emit$$&quot;VMOVDQU YMM0,0x20(RAX)\n\t&quot;
11621        $$emit$$&quot;ADD     0x40,RAX\n\t&quot;
11622        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11623        $$emit$$&quot;SUB     0x8,RCX\n\t&quot;
11624        $$emit$$&quot;JGE     L_loop\n\t&quot;
11625        $$emit$$&quot;ADD     0x4,RCX\n\t&quot;
11626        $$emit$$&quot;JL      L_tail\n\t&quot;
11627        $$emit$$&quot;VMOVDQU YMM0,(RAX)\n\t&quot;
11628        $$emit$$&quot;ADD     0x20,RAX\n\t&quot;
11629        $$emit$$&quot;SUB     0x4,RCX\n\t&quot;
11630        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11631        $$emit$$&quot;ADD     0x4,RCX\n\t&quot;
11632        $$emit$$&quot;JLE     L_end\n\t&quot;
11633        $$emit$$&quot;DEC     RCX\n\t&quot;
11634        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11635        $$emit$$&quot;VMOVQ   XMM0,(RAX)\n\t&quot;
11636        $$emit$$&quot;ADD     0x8,RAX\n\t&quot;
11637        $$emit$$&quot;DEC     RCX\n\t&quot;
11638        $$emit$$&quot;JGE     L_sloop\n\t&quot;
11639        $$emit$$&quot;# L_end:\n\t&quot;
11640     } else {
11641        $$emit$$&quot;XOR    EAX,EAX\t# ClearArray:\n\t&quot;
11642        $$emit$$&quot;SHL    ECX,1\t# Convert doublewords to words\n\t&quot;
11643        $$emit$$&quot;REP STOS\t# store EAX into [EDI++] while ECX--\n\t&quot;
11644     }
11645     $$emit$$&quot;# DONE&quot;
11646   %}
11647   ins_encode %{
11648     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,
11649                  $tmp$$XMMRegister, true);
11650   %}
11651   ins_pipe( pipe_slow );
11652 %}
11653 
11654 instruct string_compareL(eDIRegP str1, eCXRegI cnt1, eSIRegP str2, eDXRegI cnt2,
11655                          eAXRegI result, regD tmp1, eFlagsReg cr) %{
11656   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11657   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11658   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11659 
11660   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11661   ins_encode %{
11662     __ string_compare($str1$$Register, $str2$$Register,
11663                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11664                       $tmp1$$XMMRegister, StrIntrinsicNode::LL);
11665   %}
11666   ins_pipe( pipe_slow );
11667 %}
11668 
11669 instruct string_compareU(eDIRegP str1, eCXRegI cnt1, eSIRegP str2, eDXRegI cnt2,
11670                          eAXRegI result, regD tmp1, eFlagsReg cr) %{
11671   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11672   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11673   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11674 
11675   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11676   ins_encode %{
11677     __ string_compare($str1$$Register, $str2$$Register,
11678                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11679                       $tmp1$$XMMRegister, StrIntrinsicNode::UU);
11680   %}
11681   ins_pipe( pipe_slow );
11682 %}
11683 
11684 instruct string_compareLU(eDIRegP str1, eCXRegI cnt1, eSIRegP str2, eDXRegI cnt2,
11685                           eAXRegI result, regD tmp1, eFlagsReg cr) %{
11686   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
11687   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11688   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11689 
11690   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11691   ins_encode %{
11692     __ string_compare($str1$$Register, $str2$$Register,
11693                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11694                       $tmp1$$XMMRegister, StrIntrinsicNode::LU);
11695   %}
11696   ins_pipe( pipe_slow );
11697 %}
11698 
11699 instruct string_compareUL(eSIRegP str1, eDXRegI cnt1, eDIRegP str2, eCXRegI cnt2,
11700                           eAXRegI result, regD tmp1, eFlagsReg cr) %{
11701   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
11702   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11703   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11704 
11705   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11706   ins_encode %{
11707     __ string_compare($str2$$Register, $str1$$Register,
11708                       $cnt2$$Register, $cnt1$$Register, $result$$Register,
11709                       $tmp1$$XMMRegister, StrIntrinsicNode::UL);
11710   %}
11711   ins_pipe( pipe_slow );
11712 %}
11713 
11714 // fast string equals
11715 instruct string_equals(eDIRegP str1, eSIRegP str2, eCXRegI cnt, eAXRegI result,
11716                        regD tmp1, regD tmp2, eBXRegI tmp3, eFlagsReg cr) %{
11717   match(Set result (StrEquals (Binary str1 str2) cnt));
11718   effect(TEMP tmp1, TEMP tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);
11719 
11720   format %{ &quot;String Equals $str1,$str2,$cnt -&gt; $result    // KILL $tmp1, $tmp2, $tmp3&quot; %}
11721   ins_encode %{
11722     __ arrays_equals(false, $str1$$Register, $str2$$Register,
11723                      $cnt$$Register, $result$$Register, $tmp3$$Register,
11724                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11725   %}
11726 
11727   ins_pipe( pipe_slow );
11728 %}
11729 
11730 // fast search of substring with known size.
11731 instruct string_indexof_conL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, immI int_cnt2,
11732                              eBXRegI result, regD vec1, eAXRegI cnt2, eCXRegI tmp, eFlagsReg cr) %{
11733   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11734   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11735   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11736 
11737   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec1, $cnt1, $cnt2, $tmp&quot; %}
11738   ins_encode %{
11739     int icnt2 = (int)$int_cnt2$$constant;
11740     if (icnt2 &gt;= 16) {
11741       // IndexOf for constant substrings with size &gt;= 16 elements
11742       // which don&#39;t need to be loaded through stack.
11743       __ string_indexofC8($str1$$Register, $str2$$Register,
11744                           $cnt1$$Register, $cnt2$$Register,
11745                           icnt2, $result$$Register,
11746                           $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11747     } else {
11748       // Small strings are loaded through stack if they cross page boundary.
11749       __ string_indexof($str1$$Register, $str2$$Register,
11750                         $cnt1$$Register, $cnt2$$Register,
11751                         icnt2, $result$$Register,
11752                         $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11753     }
11754   %}
11755   ins_pipe( pipe_slow );
11756 %}
11757 
11758 // fast search of substring with known size.
11759 instruct string_indexof_conU(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, immI int_cnt2,
11760                              eBXRegI result, regD vec1, eAXRegI cnt2, eCXRegI tmp, eFlagsReg cr) %{
11761   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11762   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11763   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11764 
11765   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec1, $cnt1, $cnt2, $tmp&quot; %}
11766   ins_encode %{
11767     int icnt2 = (int)$int_cnt2$$constant;
11768     if (icnt2 &gt;= 8) {
11769       // IndexOf for constant substrings with size &gt;= 8 elements
11770       // which don&#39;t need to be loaded through stack.
11771       __ string_indexofC8($str1$$Register, $str2$$Register,
11772                           $cnt1$$Register, $cnt2$$Register,
11773                           icnt2, $result$$Register,
11774                           $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11775     } else {
11776       // Small strings are loaded through stack if they cross page boundary.
11777       __ string_indexof($str1$$Register, $str2$$Register,
11778                         $cnt1$$Register, $cnt2$$Register,
11779                         icnt2, $result$$Register,
11780                         $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11781     }
11782   %}
11783   ins_pipe( pipe_slow );
11784 %}
11785 
11786 // fast search of substring with known size.
11787 instruct string_indexof_conUL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, immI int_cnt2,
11788                              eBXRegI result, regD vec1, eAXRegI cnt2, eCXRegI tmp, eFlagsReg cr) %{
11789   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11790   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11791   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11792 
11793   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec1, $cnt1, $cnt2, $tmp&quot; %}
11794   ins_encode %{
11795     int icnt2 = (int)$int_cnt2$$constant;
11796     if (icnt2 &gt;= 8) {
11797       // IndexOf for constant substrings with size &gt;= 8 elements
11798       // which don&#39;t need to be loaded through stack.
11799       __ string_indexofC8($str1$$Register, $str2$$Register,
11800                           $cnt1$$Register, $cnt2$$Register,
11801                           icnt2, $result$$Register,
11802                           $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11803     } else {
11804       // Small strings are loaded through stack if they cross page boundary.
11805       __ string_indexof($str1$$Register, $str2$$Register,
11806                         $cnt1$$Register, $cnt2$$Register,
11807                         icnt2, $result$$Register,
11808                         $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11809     }
11810   %}
11811   ins_pipe( pipe_slow );
11812 %}
11813 
11814 instruct string_indexofL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, eAXRegI cnt2,
11815                          eBXRegI result, regD vec1, eCXRegI tmp, eFlagsReg cr) %{
11816   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11817   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11818   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11819 
11820   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11821   ins_encode %{
11822     __ string_indexof($str1$$Register, $str2$$Register,
11823                       $cnt1$$Register, $cnt2$$Register,
11824                       (-1), $result$$Register,
11825                       $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11826   %}
11827   ins_pipe( pipe_slow );
11828 %}
11829 
11830 instruct string_indexofU(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, eAXRegI cnt2,
11831                          eBXRegI result, regD vec1, eCXRegI tmp, eFlagsReg cr) %{
11832   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11833   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11834   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11835 
11836   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11837   ins_encode %{
11838     __ string_indexof($str1$$Register, $str2$$Register,
11839                       $cnt1$$Register, $cnt2$$Register,
11840                       (-1), $result$$Register,
11841                       $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11842   %}
11843   ins_pipe( pipe_slow );
11844 %}
11845 
11846 instruct string_indexofUL(eDIRegP str1, eDXRegI cnt1, eSIRegP str2, eAXRegI cnt2,
11847                          eBXRegI result, regD vec1, eCXRegI tmp, eFlagsReg cr) %{
11848   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11849   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11850   effect(TEMP vec1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11851 
11852   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11853   ins_encode %{
11854     __ string_indexof($str1$$Register, $str2$$Register,
11855                       $cnt1$$Register, $cnt2$$Register,
11856                       (-1), $result$$Register,
11857                       $vec1$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11858   %}
11859   ins_pipe( pipe_slow );
11860 %}
11861 
11862 instruct string_indexofU_char(eDIRegP str1, eDXRegI cnt1, eAXRegI ch,
11863                               eBXRegI result, regD vec1, regD vec2, regD vec3, eCXRegI tmp, eFlagsReg cr) %{
11864   predicate(UseSSE42Intrinsics);
11865   match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));
11866   effect(TEMP vec1, TEMP vec2, TEMP vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);
11867   format %{ &quot;String IndexOf char[] $str1,$cnt1,$ch -&gt; $result   // KILL all&quot; %}
11868   ins_encode %{
11869     __ string_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,
11870                            $vec1$$XMMRegister, $vec2$$XMMRegister, $vec3$$XMMRegister, $tmp$$Register);
11871   %}
11872   ins_pipe( pipe_slow );
11873 %}
11874 
11875 // fast array equals
11876 instruct array_equalsB(eDIRegP ary1, eSIRegP ary2, eAXRegI result,
11877                        regD tmp1, regD tmp2, eCXRegI tmp3, eBXRegI tmp4, eFlagsReg cr)
11878 %{
11879   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11880   match(Set result (AryEq ary1 ary2));
11881   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11882   //ins_cost(300);
11883 
11884   format %{ &quot;Array Equals byte[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11885   ins_encode %{
11886     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11887                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11888                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11889   %}
11890   ins_pipe( pipe_slow );
11891 %}
11892 
11893 instruct array_equalsC(eDIRegP ary1, eSIRegP ary2, eAXRegI result,
11894                        regD tmp1, regD tmp2, eCXRegI tmp3, eBXRegI tmp4, eFlagsReg cr)
11895 %{
11896   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11897   match(Set result (AryEq ary1 ary2));
11898   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11899   //ins_cost(300);
11900 
11901   format %{ &quot;Array Equals char[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11902   ins_encode %{
11903     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11904                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11905                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, true /* char */);
11906   %}
11907   ins_pipe( pipe_slow );
11908 %}
11909 
11910 instruct has_negatives(eSIRegP ary1, eCXRegI len, eAXRegI result,
11911                       regD tmp1, regD tmp2, eBXRegI tmp3, eFlagsReg cr)
11912 %{
11913   match(Set result (HasNegatives ary1 len));
11914   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL len, KILL tmp3, KILL cr);
11915 
11916   format %{ &quot;has negatives byte[] $ary1,$len -&gt; $result   // KILL $tmp1, $tmp2, $tmp3&quot; %}
11917   ins_encode %{
11918     __ has_negatives($ary1$$Register, $len$$Register,
11919                      $result$$Register, $tmp3$$Register,
11920                      $tmp1$$XMMRegister, $tmp2$$XMMRegister);
11921   %}
11922   ins_pipe( pipe_slow );
11923 %}
11924 
11925 // fast char[] to byte[] compression
11926 instruct string_compress(eSIRegP src, eDIRegP dst, eDXRegI len, regD tmp1, regD tmp2, regD tmp3, regD tmp4,
11927                          eCXRegI tmp5, eAXRegI result, eFlagsReg cr) %{
11928   match(Set result (StrCompressedCopy src (Binary dst len)));
11929   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11930 
11931   format %{ &quot;String Compress $src,$dst -&gt; $result    // KILL RAX, RCX, RDX&quot; %}
11932   ins_encode %{
11933     __ char_array_compress($src$$Register, $dst$$Register, $len$$Register,
11934                            $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11935                            $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11936   %}
11937   ins_pipe( pipe_slow );
11938 %}
11939 
11940 // fast byte[] to char[] inflation
11941 instruct string_inflate(Universe dummy, eSIRegP src, eDIRegP dst, eDXRegI len,
11942                         regD tmp1, eCXRegI tmp2, eFlagsReg cr) %{
11943   match(Set dummy (StrInflatedCopy src (Binary dst len)));
11944   effect(TEMP tmp1, TEMP tmp2, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);
11945 
11946   format %{ &quot;String Inflate $src,$dst    // KILL $tmp1, $tmp2&quot; %}
11947   ins_encode %{
11948     __ byte_array_inflate($src$$Register, $dst$$Register, $len$$Register,
11949                           $tmp1$$XMMRegister, $tmp2$$Register);
11950   %}
11951   ins_pipe( pipe_slow );
11952 %}
11953 
11954 // encode char[] to byte[] in ISO_8859_1
11955 instruct encode_iso_array(eSIRegP src, eDIRegP dst, eDXRegI len,
11956                           regD tmp1, regD tmp2, regD tmp3, regD tmp4,
11957                           eCXRegI tmp5, eAXRegI result, eFlagsReg cr) %{
11958   match(Set result (EncodeISOArray src (Binary dst len)));
11959   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11960 
11961   format %{ &quot;Encode array $src,$dst,$len -&gt; $result    // KILL ECX, EDX, $tmp1, $tmp2, $tmp3, $tmp4, ESI, EDI &quot; %}
11962   ins_encode %{
11963     __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,
11964                         $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11965                         $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11966   %}
11967   ins_pipe( pipe_slow );
11968 %}
11969 
11970 
11971 //----------Control Flow Instructions------------------------------------------
11972 // Signed compare Instructions
11973 instruct compI_eReg(eFlagsReg cr, rRegI op1, rRegI op2) %{
11974   match(Set cr (CmpI op1 op2));
11975   effect( DEF cr, USE op1, USE op2 );
11976   format %{ &quot;CMP    $op1,$op2&quot; %}
11977   opcode(0x3B);  /* Opcode 3B /r */
11978   ins_encode( OpcP, RegReg( op1, op2) );
11979   ins_pipe( ialu_cr_reg_reg );
11980 %}
11981 
11982 instruct compI_eReg_imm(eFlagsReg cr, rRegI op1, immI op2) %{
11983   match(Set cr (CmpI op1 op2));
11984   effect( DEF cr, USE op1 );
11985   format %{ &quot;CMP    $op1,$op2&quot; %}
11986   opcode(0x81,0x07);  /* Opcode 81 /7 */
11987   // ins_encode( RegImm( op1, op2) );  /* Was CmpImm */
11988   ins_encode( OpcSErm( op1, op2 ), Con8or32( op2 ) );
11989   ins_pipe( ialu_cr_reg_imm );
11990 %}
11991 
11992 // Cisc-spilled version of cmpI_eReg
11993 instruct compI_eReg_mem(eFlagsReg cr, rRegI op1, memory op2) %{
11994   match(Set cr (CmpI op1 (LoadI op2)));
11995 
11996   format %{ &quot;CMP    $op1,$op2&quot; %}
11997   ins_cost(500);
11998   opcode(0x3B);  /* Opcode 3B /r */
11999   ins_encode( OpcP, RegMem( op1, op2) );
12000   ins_pipe( ialu_cr_reg_mem );
12001 %}
12002 
12003 instruct testI_reg( eFlagsReg cr, rRegI src, immI0 zero ) %{
12004   match(Set cr (CmpI src zero));
12005   effect( DEF cr, USE src );
12006 
12007   format %{ &quot;TEST   $src,$src&quot; %}
12008   opcode(0x85);
12009   ins_encode( OpcP, RegReg( src, src ) );
12010   ins_pipe( ialu_cr_reg_imm );
12011 %}
12012 
12013 instruct testI_reg_imm( eFlagsReg cr, rRegI src, immI con, immI0 zero ) %{
12014   match(Set cr (CmpI (AndI src con) zero));
12015 
12016   format %{ &quot;TEST   $src,$con&quot; %}
12017   opcode(0xF7,0x00);
12018   ins_encode( OpcP, RegOpc(src), Con32(con) );
12019   ins_pipe( ialu_cr_reg_imm );
12020 %}
12021 
12022 instruct testI_reg_mem( eFlagsReg cr, rRegI src, memory mem, immI0 zero ) %{
12023   match(Set cr (CmpI (AndI src mem) zero));
12024 
12025   format %{ &quot;TEST   $src,$mem&quot; %}
12026   opcode(0x85);
12027   ins_encode( OpcP, RegMem( src, mem ) );
12028   ins_pipe( ialu_cr_reg_mem );
12029 %}
12030 
12031 // Unsigned compare Instructions; really, same as signed except they
12032 // produce an eFlagsRegU instead of eFlagsReg.
12033 instruct compU_eReg(eFlagsRegU cr, rRegI op1, rRegI op2) %{
12034   match(Set cr (CmpU op1 op2));
12035 
12036   format %{ &quot;CMPu   $op1,$op2&quot; %}
12037   opcode(0x3B);  /* Opcode 3B /r */
12038   ins_encode( OpcP, RegReg( op1, op2) );
12039   ins_pipe( ialu_cr_reg_reg );
12040 %}
12041 
12042 instruct compU_eReg_imm(eFlagsRegU cr, rRegI op1, immI op2) %{
12043   match(Set cr (CmpU op1 op2));
12044 
12045   format %{ &quot;CMPu   $op1,$op2&quot; %}
12046   opcode(0x81,0x07);  /* Opcode 81 /7 */
12047   ins_encode( OpcSErm( op1, op2 ), Con8or32( op2 ) );
12048   ins_pipe( ialu_cr_reg_imm );
12049 %}
12050 
12051 // // Cisc-spilled version of cmpU_eReg
12052 instruct compU_eReg_mem(eFlagsRegU cr, rRegI op1, memory op2) %{
12053   match(Set cr (CmpU op1 (LoadI op2)));
12054 
12055   format %{ &quot;CMPu   $op1,$op2&quot; %}
12056   ins_cost(500);
12057   opcode(0x3B);  /* Opcode 3B /r */
12058   ins_encode( OpcP, RegMem( op1, op2) );
12059   ins_pipe( ialu_cr_reg_mem );
12060 %}
12061 
12062 // // Cisc-spilled version of cmpU_eReg
12063 //instruct compU_mem_eReg(eFlagsRegU cr, memory op1, rRegI op2) %{
12064 //  match(Set cr (CmpU (LoadI op1) op2));
12065 //
12066 //  format %{ &quot;CMPu   $op1,$op2&quot; %}
12067 //  ins_cost(500);
12068 //  opcode(0x39);  /* Opcode 39 /r */
12069 //  ins_encode( OpcP, RegMem( op1, op2) );
12070 //%}
12071 
12072 instruct testU_reg( eFlagsRegU cr, rRegI src, immI0 zero ) %{
12073   match(Set cr (CmpU src zero));
12074 
12075   format %{ &quot;TESTu  $src,$src&quot; %}
12076   opcode(0x85);
12077   ins_encode( OpcP, RegReg( src, src ) );
12078   ins_pipe( ialu_cr_reg_imm );
12079 %}
12080 
12081 // Unsigned pointer compare Instructions
12082 instruct compP_eReg(eFlagsRegU cr, eRegP op1, eRegP op2) %{
12083   match(Set cr (CmpP op1 op2));
12084 
12085   format %{ &quot;CMPu   $op1,$op2&quot; %}
12086   opcode(0x3B);  /* Opcode 3B /r */
12087   ins_encode( OpcP, RegReg( op1, op2) );
12088   ins_pipe( ialu_cr_reg_reg );
12089 %}
12090 
12091 instruct compP_eReg_imm(eFlagsRegU cr, eRegP op1, immP op2) %{
12092   match(Set cr (CmpP op1 op2));
12093 
12094   format %{ &quot;CMPu   $op1,$op2&quot; %}
12095   opcode(0x81,0x07);  /* Opcode 81 /7 */
12096   ins_encode( OpcSErm( op1, op2 ), Con8or32( op2 ) );
12097   ins_pipe( ialu_cr_reg_imm );
12098 %}
12099 
12100 // // Cisc-spilled version of cmpP_eReg
12101 instruct compP_eReg_mem(eFlagsRegU cr, eRegP op1, memory op2) %{
12102   match(Set cr (CmpP op1 (LoadP op2)));
12103 
12104   format %{ &quot;CMPu   $op1,$op2&quot; %}
12105   ins_cost(500);
12106   opcode(0x3B);  /* Opcode 3B /r */
12107   ins_encode( OpcP, RegMem( op1, op2) );
12108   ins_pipe( ialu_cr_reg_mem );
12109 %}
12110 
12111 // // Cisc-spilled version of cmpP_eReg
12112 //instruct compP_mem_eReg(eFlagsRegU cr, memory op1, eRegP op2) %{
12113 //  match(Set cr (CmpP (LoadP op1) op2));
12114 //
12115 //  format %{ &quot;CMPu   $op1,$op2&quot; %}
12116 //  ins_cost(500);
12117 //  opcode(0x39);  /* Opcode 39 /r */
12118 //  ins_encode( OpcP, RegMem( op1, op2) );
12119 //%}
12120 
12121 // Compare raw pointer (used in out-of-heap check).
12122 // Only works because non-oop pointers must be raw pointers
12123 // and raw pointers have no anti-dependencies.
12124 instruct compP_mem_eReg( eFlagsRegU cr, eRegP op1, memory op2 ) %{
12125   predicate( n-&gt;in(2)-&gt;in(2)-&gt;bottom_type()-&gt;reloc() == relocInfo::none );
12126   match(Set cr (CmpP op1 (LoadP op2)));
12127 
12128   format %{ &quot;CMPu   $op1,$op2&quot; %}
12129   opcode(0x3B);  /* Opcode 3B /r */
12130   ins_encode( OpcP, RegMem( op1, op2) );
12131   ins_pipe( ialu_cr_reg_mem );
12132 %}
12133 
12134 //
12135 // This will generate a signed flags result. This should be ok
12136 // since any compare to a zero should be eq/neq.
12137 instruct testP_reg( eFlagsReg cr, eRegP src, immP0 zero ) %{
12138   match(Set cr (CmpP src zero));
12139 
12140   format %{ &quot;TEST   $src,$src&quot; %}
12141   opcode(0x85);
12142   ins_encode( OpcP, RegReg( src, src ) );
12143   ins_pipe( ialu_cr_reg_imm );
12144 %}
12145 
12146 // Cisc-spilled version of testP_reg
12147 // This will generate a signed flags result. This should be ok
12148 // since any compare to a zero should be eq/neq.
12149 instruct testP_Reg_mem( eFlagsReg cr, memory op, immI0 zero ) %{
12150   match(Set cr (CmpP (LoadP op) zero));
12151 
12152   format %{ &quot;TEST   $op,0xFFFFFFFF&quot; %}
12153   ins_cost(500);
12154   opcode(0xF7);               /* Opcode F7 /0 */
12155   ins_encode( OpcP, RMopc_Mem(0x00,op), Con_d32(0xFFFFFFFF) );
12156   ins_pipe( ialu_cr_reg_imm );
12157 %}
12158 
12159 // Yanked all unsigned pointer compare operations.
12160 // Pointer compares are done with CmpP which is already unsigned.
12161 
12162 //----------Max and Min--------------------------------------------------------
12163 // Min Instructions
12164 ////
12165 //   *** Min and Max using the conditional move are slower than the
12166 //   *** branch version on a Pentium III.
12167 // // Conditional move for min
12168 //instruct cmovI_reg_lt( rRegI op2, rRegI op1, eFlagsReg cr ) %{
12169 //  effect( USE_DEF op2, USE op1, USE cr );
12170 //  format %{ &quot;CMOVlt $op2,$op1\t! min&quot; %}
12171 //  opcode(0x4C,0x0F);
12172 //  ins_encode( OpcS, OpcP, RegReg( op2, op1 ) );
12173 //  ins_pipe( pipe_cmov_reg );
12174 //%}
12175 //
12176 //// Min Register with Register (P6 version)
12177 //instruct minI_eReg_p6( rRegI op1, rRegI op2 ) %{
12178 //  predicate(VM_Version::supports_cmov() );
12179 //  match(Set op2 (MinI op1 op2));
12180 //  ins_cost(200);
12181 //  expand %{
12182 //    eFlagsReg cr;
12183 //    compI_eReg(cr,op1,op2);
12184 //    cmovI_reg_lt(op2,op1,cr);
12185 //  %}
12186 //%}
12187 
12188 // Min Register with Register (generic version)
12189 instruct minI_eReg(rRegI dst, rRegI src, eFlagsReg flags) %{
12190   match(Set dst (MinI dst src));
12191   effect(KILL flags);
12192   ins_cost(300);
12193 
12194   format %{ &quot;MIN    $dst,$src&quot; %}
12195   opcode(0xCC);
12196   ins_encode( min_enc(dst,src) );
12197   ins_pipe( pipe_slow );
12198 %}
12199 
12200 // Max Register with Register
12201 //   *** Min and Max using the conditional move are slower than the
12202 //   *** branch version on a Pentium III.
12203 // // Conditional move for max
12204 //instruct cmovI_reg_gt( rRegI op2, rRegI op1, eFlagsReg cr ) %{
12205 //  effect( USE_DEF op2, USE op1, USE cr );
12206 //  format %{ &quot;CMOVgt $op2,$op1\t! max&quot; %}
12207 //  opcode(0x4F,0x0F);
12208 //  ins_encode( OpcS, OpcP, RegReg( op2, op1 ) );
12209 //  ins_pipe( pipe_cmov_reg );
12210 //%}
12211 //
12212 // // Max Register with Register (P6 version)
12213 //instruct maxI_eReg_p6( rRegI op1, rRegI op2 ) %{
12214 //  predicate(VM_Version::supports_cmov() );
12215 //  match(Set op2 (MaxI op1 op2));
12216 //  ins_cost(200);
12217 //  expand %{
12218 //    eFlagsReg cr;
12219 //    compI_eReg(cr,op1,op2);
12220 //    cmovI_reg_gt(op2,op1,cr);
12221 //  %}
12222 //%}
12223 
12224 // Max Register with Register (generic version)
12225 instruct maxI_eReg(rRegI dst, rRegI src, eFlagsReg flags) %{
12226   match(Set dst (MaxI dst src));
12227   effect(KILL flags);
12228   ins_cost(300);
12229 
12230   format %{ &quot;MAX    $dst,$src&quot; %}
12231   opcode(0xCC);
12232   ins_encode( max_enc(dst,src) );
12233   ins_pipe( pipe_slow );
12234 %}
12235 
12236 // ============================================================================
12237 // Counted Loop limit node which represents exact final iterator value.
12238 // Note: the resulting value should fit into integer range since
12239 // counted loops have limit check on overflow.
12240 instruct loopLimit_eReg(eAXRegI limit, nadxRegI init, immI stride, eDXRegI limit_hi, nadxRegI tmp, eFlagsReg flags) %{
12241   match(Set limit (LoopLimit (Binary init limit) stride));
12242   effect(TEMP limit_hi, TEMP tmp, KILL flags);
12243   ins_cost(300);
12244 
12245   format %{ &quot;loopLimit $init,$limit,$stride  # $limit = $init + $stride *( $limit - $init + $stride -1)/ $stride, kills $limit_hi&quot; %}
12246   ins_encode %{
12247     int strd = (int)$stride$$constant;
12248     assert(strd != 1 &amp;&amp; strd != -1, &quot;sanity&quot;);
12249     int m1 = (strd &gt; 0) ? 1 : -1;
12250     // Convert limit to long (EAX:EDX)
12251     __ cdql();
12252     // Convert init to long (init:tmp)
12253     __ movl($tmp$$Register, $init$$Register);
12254     __ sarl($tmp$$Register, 31);
12255     // $limit - $init
12256     __ subl($limit$$Register, $init$$Register);
12257     __ sbbl($limit_hi$$Register, $tmp$$Register);
12258     // + ($stride - 1)
12259     if (strd &gt; 0) {
12260       __ addl($limit$$Register, (strd - 1));
12261       __ adcl($limit_hi$$Register, 0);
12262       __ movl($tmp$$Register, strd);
12263     } else {
12264       __ addl($limit$$Register, (strd + 1));
12265       __ adcl($limit_hi$$Register, -1);
12266       __ lneg($limit_hi$$Register, $limit$$Register);
12267       __ movl($tmp$$Register, -strd);
12268     }
12269     // signed devision: (EAX:EDX) / pos_stride
12270     __ idivl($tmp$$Register);
12271     if (strd &lt; 0) {
12272       // restore sign
12273       __ negl($tmp$$Register);
12274     }
12275     // (EAX) * stride
12276     __ mull($tmp$$Register);
12277     // + init (ignore upper bits)
12278     __ addl($limit$$Register, $init$$Register);
12279   %}
12280   ins_pipe( pipe_slow );
12281 %}
12282 
12283 // ============================================================================
12284 // Branch Instructions
12285 // Jump Table
12286 instruct jumpXtnd(rRegI switch_val) %{
12287   match(Jump switch_val);
12288   ins_cost(350);
12289   format %{  &quot;JMP    [$constantaddress](,$switch_val,1)\n\t&quot; %}
12290   ins_encode %{
12291     // Jump to Address(table_base + switch_reg)
12292     Address index(noreg, $switch_val$$Register, Address::times_1);
12293     __ jump(ArrayAddress($constantaddress, index));
12294   %}
12295   ins_pipe(pipe_jmp);
12296 %}
12297 
12298 // Jump Direct - Label defines a relative address from JMP+1
12299 instruct jmpDir(label labl) %{
12300   match(Goto);
12301   effect(USE labl);
12302 
12303   ins_cost(300);
12304   format %{ &quot;JMP    $labl&quot; %}
12305   size(5);
12306   ins_encode %{
12307     Label* L = $labl$$label;
12308     __ jmp(*L, false); // Always long jump
12309   %}
12310   ins_pipe( pipe_jmp );
12311 %}
12312 
12313 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12314 instruct jmpCon(cmpOp cop, eFlagsReg cr, label labl) %{
12315   match(If cop cr);
12316   effect(USE labl);
12317 
12318   ins_cost(300);
12319   format %{ &quot;J$cop    $labl&quot; %}
12320   size(6);
12321   ins_encode %{
12322     Label* L = $labl$$label;
12323     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12324   %}
12325   ins_pipe( pipe_jcc );
12326 %}
12327 
12328 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12329 instruct jmpLoopEnd(cmpOp cop, eFlagsReg cr, label labl) %{
12330   predicate(!n-&gt;has_vector_mask_set());
12331   match(CountedLoopEnd cop cr);
12332   effect(USE labl);
12333 
12334   ins_cost(300);
12335   format %{ &quot;J$cop    $labl\t# Loop end&quot; %}
12336   size(6);
12337   ins_encode %{
12338     Label* L = $labl$$label;
12339     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12340   %}
12341   ins_pipe( pipe_jcc );
12342 %}
12343 
12344 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12345 instruct jmpLoopEndU(cmpOpU cop, eFlagsRegU cmp, label labl) %{
12346   predicate(!n-&gt;has_vector_mask_set());
12347   match(CountedLoopEnd cop cmp);
12348   effect(USE labl);
12349 
12350   ins_cost(300);
12351   format %{ &quot;J$cop,u  $labl\t# Loop end&quot; %}
12352   size(6);
12353   ins_encode %{
12354     Label* L = $labl$$label;
12355     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12356   %}
12357   ins_pipe( pipe_jcc );
12358 %}
12359 
12360 instruct jmpLoopEndUCF(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{
12361   predicate(!n-&gt;has_vector_mask_set());
12362   match(CountedLoopEnd cop cmp);
12363   effect(USE labl);
12364 
12365   ins_cost(200);
12366   format %{ &quot;J$cop,u  $labl\t# Loop end&quot; %}
12367   size(6);
12368   ins_encode %{
12369     Label* L = $labl$$label;
12370     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12371   %}
12372   ins_pipe( pipe_jcc );
12373 %}
12374 
12375 // mask version
12376 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12377 instruct jmpLoopEnd_and_restoreMask(cmpOp cop, eFlagsReg cr, label labl) %{
12378   predicate(n-&gt;has_vector_mask_set());
12379   match(CountedLoopEnd cop cr);
12380   effect(USE labl);
12381 
12382   ins_cost(400);
12383   format %{ &quot;J$cop    $labl\t# Loop end\n\t&quot;
12384             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12385   size(10);
12386   ins_encode %{
12387     Label* L = $labl$$label;
12388     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12389     __ restorevectmask();
12390   %}
12391   ins_pipe( pipe_jcc );
12392 %}
12393 
12394 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12395 instruct jmpLoopEndU_and_restoreMask(cmpOpU cop, eFlagsRegU cmp, label labl) %{
12396   predicate(n-&gt;has_vector_mask_set());
12397   match(CountedLoopEnd cop cmp);
12398   effect(USE labl);
12399 
12400   ins_cost(400);
12401   format %{ &quot;J$cop,u  $labl\t# Loop end\n\t&quot;
12402             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12403   size(10);
12404   ins_encode %{
12405     Label* L = $labl$$label;
12406     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12407     __ restorevectmask();
12408   %}
12409   ins_pipe( pipe_jcc );
12410 %}
12411 
12412 instruct jmpLoopEndUCF_and_restoreMask(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{
12413   predicate(n-&gt;has_vector_mask_set());
12414   match(CountedLoopEnd cop cmp);
12415   effect(USE labl);
12416 
12417   ins_cost(300);
12418   format %{ &quot;J$cop,u  $labl\t# Loop end\n\t&quot;
12419             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12420   size(10);
12421   ins_encode %{
12422     Label* L = $labl$$label;
12423     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12424     __ restorevectmask();
12425   %}
12426   ins_pipe( pipe_jcc );
12427 %}
12428 
12429 // Jump Direct Conditional - using unsigned comparison
12430 instruct jmpConU(cmpOpU cop, eFlagsRegU cmp, label labl) %{
12431   match(If cop cmp);
12432   effect(USE labl);
12433 
12434   ins_cost(300);
12435   format %{ &quot;J$cop,u  $labl&quot; %}
12436   size(6);
12437   ins_encode %{
12438     Label* L = $labl$$label;
12439     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12440   %}
12441   ins_pipe(pipe_jcc);
12442 %}
12443 
12444 instruct jmpConUCF(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{
12445   match(If cop cmp);
12446   effect(USE labl);
12447 
12448   ins_cost(200);
12449   format %{ &quot;J$cop,u  $labl&quot; %}
12450   size(6);
12451   ins_encode %{
12452     Label* L = $labl$$label;
12453     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12454   %}
12455   ins_pipe(pipe_jcc);
12456 %}
12457 
12458 instruct jmpConUCF2(cmpOpUCF2 cop, eFlagsRegUCF cmp, label labl) %{
12459   match(If cop cmp);
12460   effect(USE labl);
12461 
12462   ins_cost(200);
12463   format %{ $$template
12464     if ($cop$$cmpcode == Assembler::notEqual) {
12465       $$emit$$&quot;JP,u   $labl\n\t&quot;
12466       $$emit$$&quot;J$cop,u   $labl&quot;
12467     } else {
12468       $$emit$$&quot;JP,u   done\n\t&quot;
12469       $$emit$$&quot;J$cop,u   $labl\n\t&quot;
12470       $$emit$$&quot;done:&quot;
12471     }
12472   %}
12473   ins_encode %{
12474     Label* l = $labl$$label;
12475     if ($cop$$cmpcode == Assembler::notEqual) {
12476       __ jcc(Assembler::parity, *l, false);
12477       __ jcc(Assembler::notEqual, *l, false);
12478     } else if ($cop$$cmpcode == Assembler::equal) {
12479       Label done;
12480       __ jccb(Assembler::parity, done);
12481       __ jcc(Assembler::equal, *l, false);
12482       __ bind(done);
12483     } else {
12484        ShouldNotReachHere();
12485     }
12486   %}
12487   ins_pipe(pipe_jcc);
12488 %}
12489 
12490 // ============================================================================
12491 // The 2nd slow-half of a subtype check.  Scan the subklass&#39;s 2ndary superklass
12492 // array for an instance of the superklass.  Set a hidden internal cache on a
12493 // hit (cache is checked with exposed code in gen_subtype_check()).  Return
12494 // NZ for a miss or zero for a hit.  The encoding ALSO sets flags.
12495 instruct partialSubtypeCheck( eDIRegP result, eSIRegP sub, eAXRegP super, eCXRegI rcx, eFlagsReg cr ) %{
12496   match(Set result (PartialSubtypeCheck sub super));
12497   effect( KILL rcx, KILL cr );
12498 
12499   ins_cost(1100);  // slightly larger than the next version
12500   format %{ &quot;MOV    EDI,[$sub+Klass::secondary_supers]\n\t&quot;
12501             &quot;MOV    ECX,[EDI+ArrayKlass::length]\t# length to scan\n\t&quot;
12502             &quot;ADD    EDI,ArrayKlass::base_offset\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12503             &quot;REPNE SCASD\t# Scan *EDI++ for a match with EAX while CX-- != 0\n\t&quot;
12504             &quot;JNE,s  miss\t\t# Missed: EDI not-zero\n\t&quot;
12505             &quot;MOV    [$sub+Klass::secondary_super_cache],$super\t# Hit: update cache\n\t&quot;
12506             &quot;XOR    $result,$result\t\t Hit: EDI zero\n\t&quot;
12507      &quot;miss:\t&quot; %}
12508 
12509   opcode(0x1); // Force a XOR of EDI
12510   ins_encode( enc_PartialSubtypeCheck() );
12511   ins_pipe( pipe_slow );
12512 %}
12513 
12514 instruct partialSubtypeCheck_vs_Zero( eFlagsReg cr, eSIRegP sub, eAXRegP super, eCXRegI rcx, eDIRegP result, immP0 zero ) %{
12515   match(Set cr (CmpP (PartialSubtypeCheck sub super) zero));
12516   effect( KILL rcx, KILL result );
12517 
12518   ins_cost(1000);
12519   format %{ &quot;MOV    EDI,[$sub+Klass::secondary_supers]\n\t&quot;
12520             &quot;MOV    ECX,[EDI+ArrayKlass::length]\t# length to scan\n\t&quot;
12521             &quot;ADD    EDI,ArrayKlass::base_offset\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12522             &quot;REPNE SCASD\t# Scan *EDI++ for a match with EAX while CX-- != 0\n\t&quot;
12523             &quot;JNE,s  miss\t\t# Missed: flags NZ\n\t&quot;
12524             &quot;MOV    [$sub+Klass::secondary_super_cache],$super\t# Hit: update cache, flags Z\n\t&quot;
12525      &quot;miss:\t&quot; %}
12526 
12527   opcode(0x0);  // No need to XOR EDI
12528   ins_encode( enc_PartialSubtypeCheck() );
12529   ins_pipe( pipe_slow );
12530 %}
12531 
12532 // ============================================================================
12533 // Branch Instructions -- short offset versions
12534 //
12535 // These instructions are used to replace jumps of a long offset (the default
12536 // match) with jumps of a shorter offset.  These instructions are all tagged
12537 // with the ins_short_branch attribute, which causes the ADLC to suppress the
12538 // match rules in general matching.  Instead, the ADLC generates a conversion
12539 // method in the MachNode which can be used to do in-place replacement of the
12540 // long variant with the shorter variant.  The compiler will determine if a
12541 // branch can be taken by the is_short_branch_offset() predicate in the machine
12542 // specific code section of the file.
12543 
12544 // Jump Direct - Label defines a relative address from JMP+1
12545 instruct jmpDir_short(label labl) %{
12546   match(Goto);
12547   effect(USE labl);
12548 
12549   ins_cost(300);
12550   format %{ &quot;JMP,s  $labl&quot; %}
12551   size(2);
12552   ins_encode %{
12553     Label* L = $labl$$label;
12554     __ jmpb(*L);
12555   %}
12556   ins_pipe( pipe_jmp );
12557   ins_short_branch(1);
12558 %}
12559 
12560 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12561 instruct jmpCon_short(cmpOp cop, eFlagsReg cr, label labl) %{
12562   match(If cop cr);
12563   effect(USE labl);
12564 
12565   ins_cost(300);
12566   format %{ &quot;J$cop,s  $labl&quot; %}
12567   size(2);
12568   ins_encode %{
12569     Label* L = $labl$$label;
12570     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12571   %}
12572   ins_pipe( pipe_jcc );
12573   ins_short_branch(1);
12574 %}
12575 
12576 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12577 instruct jmpLoopEnd_short(cmpOp cop, eFlagsReg cr, label labl) %{
12578   match(CountedLoopEnd cop cr);
12579   effect(USE labl);
12580 
12581   ins_cost(300);
12582   format %{ &quot;J$cop,s  $labl\t# Loop end&quot; %}
12583   size(2);
12584   ins_encode %{
12585     Label* L = $labl$$label;
12586     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12587   %}
12588   ins_pipe( pipe_jcc );
12589   ins_short_branch(1);
12590 %}
12591 
12592 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12593 instruct jmpLoopEndU_short(cmpOpU cop, eFlagsRegU cmp, label labl) %{
12594   match(CountedLoopEnd cop cmp);
12595   effect(USE labl);
12596 
12597   ins_cost(300);
12598   format %{ &quot;J$cop,us $labl\t# Loop end&quot; %}
12599   size(2);
12600   ins_encode %{
12601     Label* L = $labl$$label;
12602     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12603   %}
12604   ins_pipe( pipe_jcc );
12605   ins_short_branch(1);
12606 %}
12607 
12608 instruct jmpLoopEndUCF_short(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{
12609   match(CountedLoopEnd cop cmp);
12610   effect(USE labl);
12611 
12612   ins_cost(300);
12613   format %{ &quot;J$cop,us $labl\t# Loop end&quot; %}
12614   size(2);
12615   ins_encode %{
12616     Label* L = $labl$$label;
12617     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12618   %}
12619   ins_pipe( pipe_jcc );
12620   ins_short_branch(1);
12621 %}
12622 
12623 // Jump Direct Conditional - using unsigned comparison
12624 instruct jmpConU_short(cmpOpU cop, eFlagsRegU cmp, label labl) %{
12625   match(If cop cmp);
12626   effect(USE labl);
12627 
12628   ins_cost(300);
12629   format %{ &quot;J$cop,us $labl&quot; %}
12630   size(2);
12631   ins_encode %{
12632     Label* L = $labl$$label;
12633     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12634   %}
12635   ins_pipe( pipe_jcc );
12636   ins_short_branch(1);
12637 %}
12638 
12639 instruct jmpConUCF_short(cmpOpUCF cop, eFlagsRegUCF cmp, label labl) %{
12640   match(If cop cmp);
12641   effect(USE labl);
12642 
12643   ins_cost(300);
12644   format %{ &quot;J$cop,us $labl&quot; %}
12645   size(2);
12646   ins_encode %{
12647     Label* L = $labl$$label;
12648     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12649   %}
12650   ins_pipe( pipe_jcc );
12651   ins_short_branch(1);
12652 %}
12653 
12654 instruct jmpConUCF2_short(cmpOpUCF2 cop, eFlagsRegUCF cmp, label labl) %{
12655   match(If cop cmp);
12656   effect(USE labl);
12657 
12658   ins_cost(300);
12659   format %{ $$template
12660     if ($cop$$cmpcode == Assembler::notEqual) {
12661       $$emit$$&quot;JP,u,s   $labl\n\t&quot;
12662       $$emit$$&quot;J$cop,u,s   $labl&quot;
12663     } else {
12664       $$emit$$&quot;JP,u,s   done\n\t&quot;
12665       $$emit$$&quot;J$cop,u,s  $labl\n\t&quot;
12666       $$emit$$&quot;done:&quot;
12667     }
12668   %}
12669   size(4);
12670   ins_encode %{
12671     Label* l = $labl$$label;
12672     if ($cop$$cmpcode == Assembler::notEqual) {
12673       __ jccb(Assembler::parity, *l);
12674       __ jccb(Assembler::notEqual, *l);
12675     } else if ($cop$$cmpcode == Assembler::equal) {
12676       Label done;
12677       __ jccb(Assembler::parity, done);
12678       __ jccb(Assembler::equal, *l);
12679       __ bind(done);
12680     } else {
12681        ShouldNotReachHere();
12682     }
12683   %}
12684   ins_pipe(pipe_jcc);
12685   ins_short_branch(1);
12686 %}
12687 
12688 // ============================================================================
12689 // Long Compare
12690 //
12691 // Currently we hold longs in 2 registers.  Comparing such values efficiently
12692 // is tricky.  The flavor of compare used depends on whether we are testing
12693 // for LT, LE, or EQ.  For a simple LT test we can check just the sign bit.
12694 // The GE test is the negated LT test.  The LE test can be had by commuting
12695 // the operands (yielding a GE test) and then negating; negate again for the
12696 // GT test.  The EQ test is done by ORcc&#39;ing the high and low halves, and the
12697 // NE test is negated from that.
12698 
12699 // Due to a shortcoming in the ADLC, it mixes up expressions like:
12700 // (foo (CmpI (CmpL X Y) 0)) and (bar (CmpI (CmpL X 0L) 0)).  Note the
12701 // difference between &#39;Y&#39; and &#39;0L&#39;.  The tree-matches for the CmpI sections
12702 // are collapsed internally in the ADLC&#39;s dfa-gen code.  The match for
12703 // (CmpI (CmpL X Y) 0) is silently replaced with (CmpI (CmpL X 0L) 0) and the
12704 // foo match ends up with the wrong leaf.  One fix is to not match both
12705 // reg-reg and reg-zero forms of long-compare.  This is unfortunate because
12706 // both forms beat the trinary form of long-compare and both are very useful
12707 // on Intel which has so few registers.
12708 
12709 // Manifest a CmpL result in an integer register.  Very painful.
12710 // This is the test to avoid.
12711 instruct cmpL3_reg_reg(eSIRegI dst, eRegL src1, eRegL src2, eFlagsReg flags ) %{
12712   match(Set dst (CmpL3 src1 src2));
12713   effect( KILL flags );
12714   ins_cost(1000);
12715   format %{ &quot;XOR    $dst,$dst\n\t&quot;
12716             &quot;CMP    $src1.hi,$src2.hi\n\t&quot;
12717             &quot;JLT,s  m_one\n\t&quot;
12718             &quot;JGT,s  p_one\n\t&quot;
12719             &quot;CMP    $src1.lo,$src2.lo\n\t&quot;
12720             &quot;JB,s   m_one\n\t&quot;
12721             &quot;JEQ,s  done\n&quot;
12722     &quot;p_one:\tINC    $dst\n\t&quot;
12723             &quot;JMP,s  done\n&quot;
12724     &quot;m_one:\tDEC    $dst\n&quot;
12725      &quot;done:&quot; %}
12726   ins_encode %{
12727     Label p_one, m_one, done;
12728     __ xorptr($dst$$Register, $dst$$Register);
12729     __ cmpl(HIGH_FROM_LOW($src1$$Register), HIGH_FROM_LOW($src2$$Register));
12730     __ jccb(Assembler::less,    m_one);
12731     __ jccb(Assembler::greater, p_one);
12732     __ cmpl($src1$$Register, $src2$$Register);
12733     __ jccb(Assembler::below,   m_one);
12734     __ jccb(Assembler::equal,   done);
12735     __ bind(p_one);
12736     __ incrementl($dst$$Register);
12737     __ jmpb(done);
12738     __ bind(m_one);
12739     __ decrementl($dst$$Register);
12740     __ bind(done);
12741   %}
12742   ins_pipe( pipe_slow );
12743 %}
12744 
12745 //======
12746 // Manifest a CmpL result in the normal flags.  Only good for LT or GE
12747 // compares.  Can be used for LE or GT compares by reversing arguments.
12748 // NOT GOOD FOR EQ/NE tests.
12749 instruct cmpL_zero_flags_LTGE( flagsReg_long_LTGE flags, eRegL src, immL0 zero ) %{
12750   match( Set flags (CmpL src zero ));
12751   ins_cost(100);
12752   format %{ &quot;TEST   $src.hi,$src.hi&quot; %}
12753   opcode(0x85);
12754   ins_encode( OpcP, RegReg_Hi2( src, src ) );
12755   ins_pipe( ialu_cr_reg_reg );
12756 %}
12757 
12758 // Manifest a CmpL result in the normal flags.  Only good for LT or GE
12759 // compares.  Can be used for LE or GT compares by reversing arguments.
12760 // NOT GOOD FOR EQ/NE tests.
12761 instruct cmpL_reg_flags_LTGE( flagsReg_long_LTGE flags, eRegL src1, eRegL src2, rRegI tmp ) %{
12762   match( Set flags (CmpL src1 src2 ));
12763   effect( TEMP tmp );
12764   ins_cost(300);
12765   format %{ &quot;CMP    $src1.lo,$src2.lo\t! Long compare; set flags for low bits\n\t&quot;
12766             &quot;MOV    $tmp,$src1.hi\n\t&quot;
12767             &quot;SBB    $tmp,$src2.hi\t! Compute flags for long compare&quot; %}
12768   ins_encode( long_cmp_flags2( src1, src2, tmp ) );
12769   ins_pipe( ialu_cr_reg_reg );
12770 %}
12771 
12772 // Long compares reg &lt; zero/req OR reg &gt;= zero/req.
12773 // Just a wrapper for a normal branch, plus the predicate test.
12774 instruct cmpL_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, label labl) %{
12775   match(If cmp flags);
12776   effect(USE labl);
12777   predicate( _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
12778   expand %{
12779     jmpCon(cmp,flags,labl);    // JLT or JGE...
12780   %}
12781 %}
12782 
12783 //======
12784 // Manifest a CmpUL result in the normal flags.  Only good for LT or GE
12785 // compares.  Can be used for LE or GT compares by reversing arguments.
12786 // NOT GOOD FOR EQ/NE tests.
12787 instruct cmpUL_zero_flags_LTGE(flagsReg_ulong_LTGE flags, eRegL src, immL0 zero) %{
12788   match(Set flags (CmpUL src zero));
12789   ins_cost(100);
12790   format %{ &quot;TEST   $src.hi,$src.hi&quot; %}
12791   opcode(0x85);
12792   ins_encode(OpcP, RegReg_Hi2(src, src));
12793   ins_pipe(ialu_cr_reg_reg);
12794 %}
12795 
12796 // Manifest a CmpUL result in the normal flags.  Only good for LT or GE
12797 // compares.  Can be used for LE or GT compares by reversing arguments.
12798 // NOT GOOD FOR EQ/NE tests.
12799 instruct cmpUL_reg_flags_LTGE(flagsReg_ulong_LTGE flags, eRegL src1, eRegL src2, rRegI tmp) %{
12800   match(Set flags (CmpUL src1 src2));
12801   effect(TEMP tmp);
12802   ins_cost(300);
12803   format %{ &quot;CMP    $src1.lo,$src2.lo\t! Unsigned long compare; set flags for low bits\n\t&quot;
12804             &quot;MOV    $tmp,$src1.hi\n\t&quot;
12805             &quot;SBB    $tmp,$src2.hi\t! Compute flags for unsigned long compare&quot; %}
12806   ins_encode(long_cmp_flags2(src1, src2, tmp));
12807   ins_pipe(ialu_cr_reg_reg);
12808 %}
12809 
12810 // Unsigned long compares reg &lt; zero/req OR reg &gt;= zero/req.
12811 // Just a wrapper for a normal branch, plus the predicate test.
12812 instruct cmpUL_LTGE(cmpOpU cmp, flagsReg_ulong_LTGE flags, label labl) %{
12813   match(If cmp flags);
12814   effect(USE labl);
12815   predicate(_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge);
12816   expand %{
12817     jmpCon(cmp, flags, labl);    // JLT or JGE...
12818   %}
12819 %}
12820 
12821 // Compare 2 longs and CMOVE longs.
12822 instruct cmovLL_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, eRegL dst, eRegL src) %{
12823   match(Set dst (CMoveL (Binary cmp flags) (Binary dst src)));
12824   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ));
12825   ins_cost(400);
12826   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
12827             &quot;CMOV$cmp $dst.hi,$src.hi&quot; %}
12828   opcode(0x0F,0x40);
12829   ins_encode( enc_cmov(cmp), RegReg_Lo2( dst, src ), enc_cmov(cmp), RegReg_Hi2( dst, src ) );
12830   ins_pipe( pipe_cmov_reg_long );
12831 %}
12832 
12833 instruct cmovLL_mem_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, eRegL dst, load_long_memory src) %{
12834   match(Set dst (CMoveL (Binary cmp flags) (Binary dst (LoadL src))));
12835   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ));
12836   ins_cost(500);
12837   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
12838             &quot;CMOV$cmp $dst.hi,$src.hi&quot; %}
12839   opcode(0x0F,0x40);
12840   ins_encode( enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src) );
12841   ins_pipe( pipe_cmov_reg_long );
12842 %}
12843 
12844 // Compare 2 longs and CMOVE ints.
12845 instruct cmovII_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, rRegI dst, rRegI src) %{
12846   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ));
12847   match(Set dst (CMoveI (Binary cmp flags) (Binary dst src)));
12848   ins_cost(200);
12849   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
12850   opcode(0x0F,0x40);
12851   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
12852   ins_pipe( pipe_cmov_reg );
12853 %}
12854 
12855 instruct cmovII_mem_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, rRegI dst, memory src) %{
12856   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ));
12857   match(Set dst (CMoveI (Binary cmp flags) (Binary dst (LoadI src))));
12858   ins_cost(250);
12859   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
12860   opcode(0x0F,0x40);
12861   ins_encode( enc_cmov(cmp), RegMem( dst, src ) );
12862   ins_pipe( pipe_cmov_mem );
12863 %}
12864 
12865 // Compare 2 longs and CMOVE ints.
12866 instruct cmovPP_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, eRegP dst, eRegP src) %{
12867   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ));
12868   match(Set dst (CMoveP (Binary cmp flags) (Binary dst src)));
12869   ins_cost(200);
12870   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
12871   opcode(0x0F,0x40);
12872   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
12873   ins_pipe( pipe_cmov_reg );
12874 %}
12875 
12876 // Compare 2 longs and CMOVE doubles
12877 instruct cmovDDPR_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, regDPR dst, regDPR src) %{
12878   predicate( UseSSE&lt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
12879   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
12880   ins_cost(200);
12881   expand %{
12882     fcmovDPR_regS(cmp,flags,dst,src);
12883   %}
12884 %}
12885 
12886 // Compare 2 longs and CMOVE doubles
12887 instruct cmovDD_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, regD dst, regD src) %{
12888   predicate( UseSSE&gt;=2 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
12889   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
12890   ins_cost(200);
12891   expand %{
12892     fcmovD_regS(cmp,flags,dst,src);
12893   %}
12894 %}
12895 
12896 instruct cmovFFPR_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, regFPR dst, regFPR src) %{
12897   predicate( UseSSE==0 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
12898   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
12899   ins_cost(200);
12900   expand %{
12901     fcmovFPR_regS(cmp,flags,dst,src);
12902   %}
12903 %}
12904 
12905 instruct cmovFF_reg_LTGE(cmpOp cmp, flagsReg_long_LTGE flags, regF dst, regF src) %{
12906   predicate( UseSSE&gt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
12907   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
12908   ins_cost(200);
12909   expand %{
12910     fcmovF_regS(cmp,flags,dst,src);
12911   %}
12912 %}
12913 
12914 //======
12915 // Manifest a CmpL result in the normal flags.  Only good for EQ/NE compares.
12916 instruct cmpL_zero_flags_EQNE( flagsReg_long_EQNE flags, eRegL src, immL0 zero, rRegI tmp ) %{
12917   match( Set flags (CmpL src zero ));
12918   effect(TEMP tmp);
12919   ins_cost(200);
12920   format %{ &quot;MOV    $tmp,$src.lo\n\t&quot;
12921             &quot;OR     $tmp,$src.hi\t! Long is EQ/NE 0?&quot; %}
12922   ins_encode( long_cmp_flags0( src, tmp ) );
12923   ins_pipe( ialu_reg_reg_long );
12924 %}
12925 
12926 // Manifest a CmpL result in the normal flags.  Only good for EQ/NE compares.
12927 instruct cmpL_reg_flags_EQNE( flagsReg_long_EQNE flags, eRegL src1, eRegL src2 ) %{
12928   match( Set flags (CmpL src1 src2 ));
12929   ins_cost(200+300);
12930   format %{ &quot;CMP    $src1.lo,$src2.lo\t! Long compare; set flags for low bits\n\t&quot;
12931             &quot;JNE,s  skip\n\t&quot;
12932             &quot;CMP    $src1.hi,$src2.hi\n\t&quot;
12933      &quot;skip:\t&quot; %}
12934   ins_encode( long_cmp_flags1( src1, src2 ) );
12935   ins_pipe( ialu_cr_reg_reg );
12936 %}
12937 
12938 // Long compare reg == zero/reg OR reg != zero/reg
12939 // Just a wrapper for a normal branch, plus the predicate test.
12940 instruct cmpL_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, label labl) %{
12941   match(If cmp flags);
12942   effect(USE labl);
12943   predicate( _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
12944   expand %{
12945     jmpCon(cmp,flags,labl);    // JEQ or JNE...
12946   %}
12947 %}
12948 
12949 //======
12950 // Manifest a CmpUL result in the normal flags.  Only good for EQ/NE compares.
12951 instruct cmpUL_zero_flags_EQNE(flagsReg_ulong_EQNE flags, eRegL src, immL0 zero, rRegI tmp) %{
12952   match(Set flags (CmpUL src zero));
12953   effect(TEMP tmp);
12954   ins_cost(200);
12955   format %{ &quot;MOV    $tmp,$src.lo\n\t&quot;
12956             &quot;OR     $tmp,$src.hi\t! Unsigned long is EQ/NE 0?&quot; %}
12957   ins_encode(long_cmp_flags0(src, tmp));
12958   ins_pipe(ialu_reg_reg_long);
12959 %}
12960 
12961 // Manifest a CmpUL result in the normal flags.  Only good for EQ/NE compares.
12962 instruct cmpUL_reg_flags_EQNE(flagsReg_ulong_EQNE flags, eRegL src1, eRegL src2) %{
12963   match(Set flags (CmpUL src1 src2));
12964   ins_cost(200+300);
12965   format %{ &quot;CMP    $src1.lo,$src2.lo\t! Unsigned long compare; set flags for low bits\n\t&quot;
12966             &quot;JNE,s  skip\n\t&quot;
12967             &quot;CMP    $src1.hi,$src2.hi\n\t&quot;
12968      &quot;skip:\t&quot; %}
12969   ins_encode(long_cmp_flags1(src1, src2));
12970   ins_pipe(ialu_cr_reg_reg);
12971 %}
12972 
12973 // Unsigned long compare reg == zero/reg OR reg != zero/reg
12974 // Just a wrapper for a normal branch, plus the predicate test.
12975 instruct cmpUL_EQNE(cmpOpU cmp, flagsReg_ulong_EQNE flags, label labl) %{
12976   match(If cmp flags);
12977   effect(USE labl);
12978   predicate(_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne);
12979   expand %{
12980     jmpCon(cmp, flags, labl);    // JEQ or JNE...
12981   %}
12982 %}
12983 
12984 // Compare 2 longs and CMOVE longs.
12985 instruct cmovLL_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, eRegL dst, eRegL src) %{
12986   match(Set dst (CMoveL (Binary cmp flags) (Binary dst src)));
12987   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ));
12988   ins_cost(400);
12989   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
12990             &quot;CMOV$cmp $dst.hi,$src.hi&quot; %}
12991   opcode(0x0F,0x40);
12992   ins_encode( enc_cmov(cmp), RegReg_Lo2( dst, src ), enc_cmov(cmp), RegReg_Hi2( dst, src ) );
12993   ins_pipe( pipe_cmov_reg_long );
12994 %}
12995 
12996 instruct cmovLL_mem_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, eRegL dst, load_long_memory src) %{
12997   match(Set dst (CMoveL (Binary cmp flags) (Binary dst (LoadL src))));
12998   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ));
12999   ins_cost(500);
13000   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
13001             &quot;CMOV$cmp $dst.hi,$src.hi&quot; %}
13002   opcode(0x0F,0x40);
13003   ins_encode( enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src) );
13004   ins_pipe( pipe_cmov_reg_long );
13005 %}
13006 
13007 // Compare 2 longs and CMOVE ints.
13008 instruct cmovII_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, rRegI dst, rRegI src) %{
13009   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ));
13010   match(Set dst (CMoveI (Binary cmp flags) (Binary dst src)));
13011   ins_cost(200);
13012   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13013   opcode(0x0F,0x40);
13014   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
13015   ins_pipe( pipe_cmov_reg );
13016 %}
13017 
13018 instruct cmovII_mem_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, rRegI dst, memory src) %{
13019   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ));
13020   match(Set dst (CMoveI (Binary cmp flags) (Binary dst (LoadI src))));
13021   ins_cost(250);
13022   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13023   opcode(0x0F,0x40);
13024   ins_encode( enc_cmov(cmp), RegMem( dst, src ) );
13025   ins_pipe( pipe_cmov_mem );
13026 %}
13027 
13028 // Compare 2 longs and CMOVE ints.
13029 instruct cmovPP_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, eRegP dst, eRegP src) %{
13030   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ));
13031   match(Set dst (CMoveP (Binary cmp flags) (Binary dst src)));
13032   ins_cost(200);
13033   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13034   opcode(0x0F,0x40);
13035   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
13036   ins_pipe( pipe_cmov_reg );
13037 %}
13038 
13039 // Compare 2 longs and CMOVE doubles
13040 instruct cmovDDPR_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, regDPR dst, regDPR src) %{
13041   predicate( UseSSE&lt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
13042   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
13043   ins_cost(200);
13044   expand %{
13045     fcmovDPR_regS(cmp,flags,dst,src);
13046   %}
13047 %}
13048 
13049 // Compare 2 longs and CMOVE doubles
13050 instruct cmovDD_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, regD dst, regD src) %{
13051   predicate( UseSSE&gt;=2 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
13052   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
13053   ins_cost(200);
13054   expand %{
13055     fcmovD_regS(cmp,flags,dst,src);
13056   %}
13057 %}
13058 
13059 instruct cmovFFPR_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, regFPR dst, regFPR src) %{
13060   predicate( UseSSE==0 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
13061   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
13062   ins_cost(200);
13063   expand %{
13064     fcmovFPR_regS(cmp,flags,dst,src);
13065   %}
13066 %}
13067 
13068 instruct cmovFF_reg_EQNE(cmpOp cmp, flagsReg_long_EQNE flags, regF dst, regF src) %{
13069   predicate( UseSSE&gt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
13070   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
13071   ins_cost(200);
13072   expand %{
13073     fcmovF_regS(cmp,flags,dst,src);
13074   %}
13075 %}
13076 
13077 //======
13078 // Manifest a CmpL result in the normal flags.  Only good for LE or GT compares.
13079 // Same as cmpL_reg_flags_LEGT except must negate src
13080 instruct cmpL_zero_flags_LEGT( flagsReg_long_LEGT flags, eRegL src, immL0 zero, rRegI tmp ) %{
13081   match( Set flags (CmpL src zero ));
13082   effect( TEMP tmp );
13083   ins_cost(300);
13084   format %{ &quot;XOR    $tmp,$tmp\t# Long compare for -$src &lt; 0, use commuted test\n\t&quot;
13085             &quot;CMP    $tmp,$src.lo\n\t&quot;
13086             &quot;SBB    $tmp,$src.hi\n\t&quot; %}
13087   ins_encode( long_cmp_flags3(src, tmp) );
13088   ins_pipe( ialu_reg_reg_long );
13089 %}
13090 
13091 // Manifest a CmpL result in the normal flags.  Only good for LE or GT compares.
13092 // Same as cmpL_reg_flags_LTGE except operands swapped.  Swapping operands
13093 // requires a commuted test to get the same result.
13094 instruct cmpL_reg_flags_LEGT( flagsReg_long_LEGT flags, eRegL src1, eRegL src2, rRegI tmp ) %{
13095   match( Set flags (CmpL src1 src2 ));
13096   effect( TEMP tmp );
13097   ins_cost(300);
13098   format %{ &quot;CMP    $src2.lo,$src1.lo\t! Long compare, swapped operands, use with commuted test\n\t&quot;
13099             &quot;MOV    $tmp,$src2.hi\n\t&quot;
13100             &quot;SBB    $tmp,$src1.hi\t! Compute flags for long compare&quot; %}
13101   ins_encode( long_cmp_flags2( src2, src1, tmp ) );
13102   ins_pipe( ialu_cr_reg_reg );
13103 %}
13104 
13105 // Long compares reg &lt; zero/req OR reg &gt;= zero/req.
13106 // Just a wrapper for a normal branch, plus the predicate test
13107 instruct cmpL_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, label labl) %{
13108   match(If cmp flags);
13109   effect(USE labl);
13110   predicate( _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le );
13111   ins_cost(300);
13112   expand %{
13113     jmpCon(cmp,flags,labl);    // JGT or JLE...
13114   %}
13115 %}
13116 
13117 //======
13118 // Manifest a CmpUL result in the normal flags.  Only good for LE or GT compares.
13119 // Same as cmpUL_reg_flags_LEGT except must negate src
13120 instruct cmpUL_zero_flags_LEGT(flagsReg_ulong_LEGT flags, eRegL src, immL0 zero, rRegI tmp) %{
13121   match(Set flags (CmpUL src zero));
13122   effect(TEMP tmp);
13123   ins_cost(300);
13124   format %{ &quot;XOR    $tmp,$tmp\t# Unsigned long compare for -$src &lt; 0, use commuted test\n\t&quot;
13125             &quot;CMP    $tmp,$src.lo\n\t&quot;
13126             &quot;SBB    $tmp,$src.hi\n\t&quot; %}
13127   ins_encode(long_cmp_flags3(src, tmp));
13128   ins_pipe(ialu_reg_reg_long);
13129 %}
13130 
13131 // Manifest a CmpUL result in the normal flags.  Only good for LE or GT compares.
13132 // Same as cmpUL_reg_flags_LTGE except operands swapped.  Swapping operands
13133 // requires a commuted test to get the same result.
13134 instruct cmpUL_reg_flags_LEGT(flagsReg_ulong_LEGT flags, eRegL src1, eRegL src2, rRegI tmp) %{
13135   match(Set flags (CmpUL src1 src2));
13136   effect(TEMP tmp);
13137   ins_cost(300);
13138   format %{ &quot;CMP    $src2.lo,$src1.lo\t! Unsigned long compare, swapped operands, use with commuted test\n\t&quot;
13139             &quot;MOV    $tmp,$src2.hi\n\t&quot;
13140             &quot;SBB    $tmp,$src1.hi\t! Compute flags for unsigned long compare&quot; %}
13141   ins_encode(long_cmp_flags2( src2, src1, tmp));
13142   ins_pipe(ialu_cr_reg_reg);
13143 %}
13144 
13145 // Unsigned long compares reg &lt; zero/req OR reg &gt;= zero/req.
13146 // Just a wrapper for a normal branch, plus the predicate test
13147 instruct cmpUL_LEGT(cmpOpU_commute cmp, flagsReg_ulong_LEGT flags, label labl) %{
13148   match(If cmp flags);
13149   effect(USE labl);
13150   predicate(_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le);
13151   ins_cost(300);
13152   expand %{
13153     jmpCon(cmp, flags, labl);    // JGT or JLE...
13154   %}
13155 %}
13156 
13157 // Compare 2 longs and CMOVE longs.
13158 instruct cmovLL_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, eRegL dst, eRegL src) %{
13159   match(Set dst (CMoveL (Binary cmp flags) (Binary dst src)));
13160   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt ));
13161   ins_cost(400);
13162   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
13163             &quot;CMOV$cmp $dst.hi,$src.hi&quot; %}
13164   opcode(0x0F,0x40);
13165   ins_encode( enc_cmov(cmp), RegReg_Lo2( dst, src ), enc_cmov(cmp), RegReg_Hi2( dst, src ) );
13166   ins_pipe( pipe_cmov_reg_long );
13167 %}
13168 
13169 instruct cmovLL_mem_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, eRegL dst, load_long_memory src) %{
13170   match(Set dst (CMoveL (Binary cmp flags) (Binary dst (LoadL src))));
13171   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt ));
13172   ins_cost(500);
13173   format %{ &quot;CMOV$cmp $dst.lo,$src.lo\n\t&quot;
13174             &quot;CMOV$cmp $dst.hi,$src.hi+4&quot; %}
13175   opcode(0x0F,0x40);
13176   ins_encode( enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src) );
13177   ins_pipe( pipe_cmov_reg_long );
13178 %}
13179 
13180 // Compare 2 longs and CMOVE ints.
13181 instruct cmovII_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, rRegI dst, rRegI src) %{
13182   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt ));
13183   match(Set dst (CMoveI (Binary cmp flags) (Binary dst src)));
13184   ins_cost(200);
13185   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13186   opcode(0x0F,0x40);
13187   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
13188   ins_pipe( pipe_cmov_reg );
13189 %}
13190 
13191 instruct cmovII_mem_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, rRegI dst, memory src) %{
13192   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt ));
13193   match(Set dst (CMoveI (Binary cmp flags) (Binary dst (LoadI src))));
13194   ins_cost(250);
13195   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13196   opcode(0x0F,0x40);
13197   ins_encode( enc_cmov(cmp), RegMem( dst, src ) );
13198   ins_pipe( pipe_cmov_mem );
13199 %}
13200 
13201 // Compare 2 longs and CMOVE ptrs.
13202 instruct cmovPP_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, eRegP dst, eRegP src) %{
13203   predicate(VM_Version::supports_cmov() &amp;&amp; ( _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt ));
13204   match(Set dst (CMoveP (Binary cmp flags) (Binary dst src)));
13205   ins_cost(200);
13206   format %{ &quot;CMOV$cmp $dst,$src&quot; %}
13207   opcode(0x0F,0x40);
13208   ins_encode( enc_cmov(cmp), RegReg( dst, src ) );
13209   ins_pipe( pipe_cmov_reg );
13210 %}
13211 
13212 // Compare 2 longs and CMOVE doubles
13213 instruct cmovDDPR_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, regDPR dst, regDPR src) %{
13214   predicate( UseSSE&lt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
13215   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
13216   ins_cost(200);
13217   expand %{
13218     fcmovDPR_regS(cmp,flags,dst,src);
13219   %}
13220 %}
13221 
13222 // Compare 2 longs and CMOVE doubles
13223 instruct cmovDD_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, regD dst, regD src) %{
13224   predicate( UseSSE&gt;=2 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
13225   match(Set dst (CMoveD (Binary cmp flags) (Binary dst src)));
13226   ins_cost(200);
13227   expand %{
13228     fcmovD_regS(cmp,flags,dst,src);
13229   %}
13230 %}
13231 
13232 instruct cmovFFPR_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, regFPR dst, regFPR src) %{
13233   predicate( UseSSE==0 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
13234   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
13235   ins_cost(200);
13236   expand %{
13237     fcmovFPR_regS(cmp,flags,dst,src);
13238   %}
13239 %}
13240 
13241 
13242 instruct cmovFF_reg_LEGT(cmpOp_commute cmp, flagsReg_long_LEGT flags, regF dst, regF src) %{
13243   predicate( UseSSE&gt;=1 &amp;&amp; _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
13244   match(Set dst (CMoveF (Binary cmp flags) (Binary dst src)));
13245   ins_cost(200);
13246   expand %{
13247     fcmovF_regS(cmp,flags,dst,src);
13248   %}
13249 %}
13250 
13251 
13252 // ============================================================================
13253 // Procedure Call/Return Instructions
13254 // Call Java Static Instruction
13255 // Note: If this code changes, the corresponding ret_addr_offset() and
13256 //       compute_padding() functions will have to be adjusted.
13257 instruct CallStaticJavaDirect(method meth) %{
13258   match(CallStaticJava);
13259   effect(USE meth);
13260 
13261   ins_cost(300);
13262   format %{ &quot;CALL,static &quot; %}
13263   opcode(0xE8); /* E8 cd */
13264   ins_encode( pre_call_resets,
13265               Java_Static_Call( meth ),
13266               call_epilog,
13267               post_call_FPU );
13268   ins_pipe( pipe_slow );
13269   ins_alignment(4);
13270 %}
13271 
13272 // Call Java Dynamic Instruction
13273 // Note: If this code changes, the corresponding ret_addr_offset() and
13274 //       compute_padding() functions will have to be adjusted.
13275 instruct CallDynamicJavaDirect(method meth) %{
13276   match(CallDynamicJava);
13277   effect(USE meth);
13278 
13279   ins_cost(300);
13280   format %{ &quot;MOV    EAX,(oop)-1\n\t&quot;
13281             &quot;CALL,dynamic&quot; %}
13282   opcode(0xE8); /* E8 cd */
13283   ins_encode( pre_call_resets,
13284               Java_Dynamic_Call( meth ),
13285               call_epilog,
13286               post_call_FPU );
13287   ins_pipe( pipe_slow );
13288   ins_alignment(4);
13289 %}
13290 
13291 // Call Runtime Instruction
13292 instruct CallRuntimeDirect(method meth) %{
13293   match(CallRuntime );
13294   effect(USE meth);
13295 
13296   ins_cost(300);
13297   format %{ &quot;CALL,runtime &quot; %}
13298   opcode(0xE8); /* E8 cd */
13299   // Use FFREEs to clear entries in float stack
13300   ins_encode( pre_call_resets,
13301               FFree_Float_Stack_All,
13302               Java_To_Runtime( meth ),
13303               post_call_FPU );
13304   ins_pipe( pipe_slow );
13305 %}
13306 
13307 // Call runtime without safepoint
13308 instruct CallLeafDirect(method meth) %{
13309   match(CallLeaf);
13310   effect(USE meth);
13311 
13312   ins_cost(300);
13313   format %{ &quot;CALL_LEAF,runtime &quot; %}
13314   opcode(0xE8); /* E8 cd */
13315   ins_encode( pre_call_resets,
13316               FFree_Float_Stack_All,
13317               Java_To_Runtime( meth ),
13318               Verify_FPU_For_Leaf, post_call_FPU );
13319   ins_pipe( pipe_slow );
13320 %}
13321 
13322 instruct CallLeafNoFPDirect(method meth) %{
13323   match(CallLeafNoFP);
13324   effect(USE meth);
13325 
13326   ins_cost(300);
13327   format %{ &quot;CALL_LEAF_NOFP,runtime &quot; %}
13328   opcode(0xE8); /* E8 cd */
13329   ins_encode(pre_call_resets, Java_To_Runtime(meth));
13330   ins_pipe( pipe_slow );
13331 %}
13332 
13333 
13334 // Return Instruction
13335 // Remove the return address &amp; jump to it.
13336 instruct Ret() %{
13337   match(Return);
13338   format %{ &quot;RET&quot; %}
13339   opcode(0xC3);
13340   ins_encode(OpcP);
13341   ins_pipe( pipe_jmp );
13342 %}
13343 
13344 // Tail Call; Jump from runtime stub to Java code.
13345 // Also known as an &#39;interprocedural jump&#39;.
13346 // Target of jump will eventually return to caller.
13347 // TailJump below removes the return address.
13348 instruct TailCalljmpInd(eRegP_no_EBP jump_target, eBXRegP method_oop) %{
13349   match(TailCall jump_target method_oop );
13350   ins_cost(300);
13351   format %{ &quot;JMP    $jump_target \t# EBX holds method oop&quot; %}
13352   opcode(0xFF, 0x4);  /* Opcode FF /4 */
13353   ins_encode( OpcP, RegOpc(jump_target) );
13354   ins_pipe( pipe_jmp );
13355 %}
13356 
13357 
13358 // Tail Jump; remove the return address; jump to target.
13359 // TailCall above leaves the return address around.
13360 instruct tailjmpInd(eRegP_no_EBP jump_target, eAXRegP ex_oop) %{
13361   match( TailJump jump_target ex_oop );
13362   ins_cost(300);
13363   format %{ &quot;POP    EDX\t# pop return address into dummy\n\t&quot;
13364             &quot;JMP    $jump_target &quot; %}
13365   opcode(0xFF, 0x4);  /* Opcode FF /4 */
13366   ins_encode( enc_pop_rdx,
13367               OpcP, RegOpc(jump_target) );
13368   ins_pipe( pipe_jmp );
13369 %}
13370 
13371 // Create exception oop: created by stack-crawling runtime code.
13372 // Created exception is now available to this handler, and is setup
13373 // just prior to jumping to this handler.  No code emitted.
13374 instruct CreateException( eAXRegP ex_oop )
13375 %{
13376   match(Set ex_oop (CreateEx));
13377 
13378   size(0);
13379   // use the following format syntax
13380   format %{ &quot;# exception oop is in EAX; no code emitted&quot; %}
13381   ins_encode();
13382   ins_pipe( empty );
13383 %}
13384 
13385 
13386 // Rethrow exception:
13387 // The exception oop will come in the first argument position.
13388 // Then JUMP (not call) to the rethrow stub code.
13389 instruct RethrowException()
13390 %{
13391   match(Rethrow);
13392 
13393   // use the following format syntax
13394   format %{ &quot;JMP    rethrow_stub&quot; %}
13395   ins_encode(enc_rethrow);
13396   ins_pipe( pipe_jmp );
13397 %}
13398 
13399 // inlined locking and unlocking
13400 
13401 instruct cmpFastLockRTM(eFlagsReg cr, eRegP object, eBXRegP box, eAXRegI tmp, eDXRegI scr, rRegI cx1, rRegI cx2) %{
13402   predicate(Compile::current()-&gt;use_rtm());
13403   match(Set cr (FastLock object box));
13404   effect(TEMP tmp, TEMP scr, TEMP cx1, TEMP cx2, USE_KILL box);
13405   ins_cost(300);
13406   format %{ &quot;FASTLOCK $object,$box\t! kills $box,$tmp,$scr,$cx1,$cx2&quot; %}
13407   ins_encode %{
13408     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
13409                  $scr$$Register, $cx1$$Register, $cx2$$Register,
13410                  _counters, _rtm_counters, _stack_rtm_counters,
13411                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
13412                  true, ra_-&gt;C-&gt;profile_rtm());
13413   %}
13414   ins_pipe(pipe_slow);
13415 %}
13416 
13417 instruct cmpFastLock(eFlagsReg cr, eRegP object, eBXRegP box, eAXRegI tmp, eRegP scr) %{
13418   predicate(!Compile::current()-&gt;use_rtm());
13419   match(Set cr (FastLock object box));
13420   effect(TEMP tmp, TEMP scr, USE_KILL box);
13421   ins_cost(300);
13422   format %{ &quot;FASTLOCK $object,$box\t! kills $box,$tmp,$scr&quot; %}
13423   ins_encode %{
13424     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
13425                  $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);
13426   %}
13427   ins_pipe(pipe_slow);
13428 %}
13429 
13430 instruct cmpFastUnlock(eFlagsReg cr, eRegP object, eAXRegP box, eRegP tmp ) %{
13431   match(Set cr (FastUnlock object box));
13432   effect(TEMP tmp, USE_KILL box);
13433   ins_cost(300);
13434   format %{ &quot;FASTUNLOCK $object,$box\t! kills $box,$tmp&quot; %}
13435   ins_encode %{
13436     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
13437   %}
13438   ins_pipe(pipe_slow);
13439 %}
13440 
13441 
13442 
13443 // ============================================================================
13444 // Safepoint Instruction
13445 instruct safePoint_poll(eFlagsReg cr) %{
13446   predicate(SafepointMechanism::uses_global_page_poll());
13447   match(SafePoint);
13448   effect(KILL cr);
13449 
13450   // TODO-FIXME: we currently poll at offset 0 of the safepoint polling page.
13451   // On SPARC that might be acceptable as we can generate the address with
13452   // just a sethi, saving an or.  By polling at offset 0 we can end up
13453   // putting additional pressure on the index-0 in the D$.  Because of
13454   // alignment (just like the situation at hand) the lower indices tend
13455   // to see more traffic.  It&#39;d be better to change the polling address
13456   // to offset 0 of the last $line in the polling page.
13457 
13458   format %{ &quot;TSTL   #polladdr,EAX\t! Safepoint: poll for GC&quot; %}
13459   ins_cost(125);
13460   size(6) ;
13461   ins_encode( Safepoint_Poll() );
13462   ins_pipe( ialu_reg_mem );
13463 %}
13464 
13465 instruct safePoint_poll_tls(eFlagsReg cr, eRegP_no_EBP poll) %{
13466   predicate(SafepointMechanism::uses_thread_local_poll());
13467   match(SafePoint poll);
13468   effect(KILL cr, USE poll);
13469 
13470   format %{ &quot;TSTL   #EAX,[$poll]\t! Safepoint: poll for GC&quot; %}
13471   ins_cost(125);
13472   // EBP would need size(3)
13473   size(2); /* setting an explicit size will cause debug builds to assert if size is incorrect */
13474   ins_encode %{
13475     __ relocate(relocInfo::poll_type);
13476     address pre_pc = __ pc();
13477     __ testl(rax, Address($poll$$Register, 0));
13478     address post_pc = __ pc();
13479     guarantee(pre_pc[0] == 0x85, &quot;must emit test-ax [reg]&quot;);
13480   %}
13481   ins_pipe(ialu_reg_mem);
13482 %}
13483 
13484 
13485 // ============================================================================
13486 // This name is KNOWN by the ADLC and cannot be changed.
13487 // The ADLC forces a &#39;TypeRawPtr::BOTTOM&#39; output type
13488 // for this guy.
13489 instruct tlsLoadP(eRegP dst, eFlagsReg cr) %{
13490   match(Set dst (ThreadLocal));
13491   effect(DEF dst, KILL cr);
13492 
13493   format %{ &quot;MOV    $dst, Thread::current()&quot; %}
13494   ins_encode %{
13495     Register dstReg = as_Register($dst$$reg);
13496     __ get_thread(dstReg);
13497   %}
13498   ins_pipe( ialu_reg_fat );
13499 %}
13500 
13501 
13502 
13503 //----------PEEPHOLE RULES-----------------------------------------------------
13504 // These must follow all instruction definitions as they use the names
13505 // defined in the instructions definitions.
13506 //
13507 // peepmatch ( root_instr_name [preceding_instruction]* );
13508 //
13509 // peepconstraint %{
13510 // (instruction_number.operand_name relational_op instruction_number.operand_name
13511 //  [, ...] );
13512 // // instruction numbers are zero-based using left to right order in peepmatch
13513 //
13514 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
13515 // // provide an instruction_number.operand_name for each operand that appears
13516 // // in the replacement instruction&#39;s match rule
13517 //
13518 // ---------VM FLAGS---------------------------------------------------------
13519 //
13520 // All peephole optimizations can be turned off using -XX:-OptoPeephole
13521 //
13522 // Each peephole rule is given an identifying number starting with zero and
13523 // increasing by one in the order seen by the parser.  An individual peephole
13524 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
13525 // on the command-line.
13526 //
13527 // ---------CURRENT LIMITATIONS----------------------------------------------
13528 //
13529 // Only match adjacent instructions in same basic block
13530 // Only equality constraints
13531 // Only constraints between operands, not (0.dest_reg == EAX_enc)
13532 // Only one replacement instruction
13533 //
13534 // ---------EXAMPLE----------------------------------------------------------
13535 //
13536 // // pertinent parts of existing instructions in architecture description
13537 // instruct movI(rRegI dst, rRegI src) %{
13538 //   match(Set dst (CopyI src));
13539 // %}
13540 //
13541 // instruct incI_eReg(rRegI dst, immI1 src, eFlagsReg cr) %{
13542 //   match(Set dst (AddI dst src));
13543 //   effect(KILL cr);
13544 // %}
13545 //
13546 // // Change (inc mov) to lea
13547 // peephole %{
13548 //   // increment preceeded by register-register move
13549 //   peepmatch ( incI_eReg movI );
13550 //   // require that the destination register of the increment
13551 //   // match the destination register of the move
13552 //   peepconstraint ( 0.dst == 1.dst );
13553 //   // construct a replacement instruction that sets
13554 //   // the destination to ( move&#39;s source register + one )
13555 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13556 // %}
13557 //
13558 // Implementation no longer uses movX instructions since
13559 // machine-independent system no longer uses CopyX nodes.
13560 //
13561 // peephole %{
13562 //   peepmatch ( incI_eReg movI );
13563 //   peepconstraint ( 0.dst == 1.dst );
13564 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13565 // %}
13566 //
13567 // peephole %{
13568 //   peepmatch ( decI_eReg movI );
13569 //   peepconstraint ( 0.dst == 1.dst );
13570 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13571 // %}
13572 //
13573 // peephole %{
13574 //   peepmatch ( addI_eReg_imm movI );
13575 //   peepconstraint ( 0.dst == 1.dst );
13576 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
13577 // %}
13578 //
13579 // peephole %{
13580 //   peepmatch ( addP_eReg_imm movP );
13581 //   peepconstraint ( 0.dst == 1.dst );
13582 //   peepreplace ( leaP_eReg_immI( 0.dst 1.src 0.src ) );
13583 // %}
13584 
13585 // // Change load of spilled value to only a spill
13586 // instruct storeI(memory mem, rRegI src) %{
13587 //   match(Set mem (StoreI mem src));
13588 // %}
13589 //
13590 // instruct loadI(rRegI dst, memory mem) %{
13591 //   match(Set dst (LoadI mem));
13592 // %}
13593 //
13594 peephole %{
13595   peepmatch ( loadI storeI );
13596   peepconstraint ( 1.src == 0.dst, 1.mem == 0.mem );
13597   peepreplace ( storeI( 1.mem 1.mem 1.src ) );
13598 %}
13599 
13600 //----------SMARTSPILL RULES---------------------------------------------------
13601 // These must follow all instruction definitions as they use the names
13602 // defined in the instructions definitions.
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
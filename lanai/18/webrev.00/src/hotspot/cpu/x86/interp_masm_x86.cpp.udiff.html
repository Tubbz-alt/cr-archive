<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/x86/interp_masm_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="globals_x86.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interp_masm_x86.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/interp_masm_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -37,10 +37,11 @@</span>
  #include &quot;runtime/biasedLocking.hpp&quot;
  #include &quot;runtime/frame.inline.hpp&quot;
  #include &quot;runtime/safepointMechanism.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;runtime/thread.inline.hpp&quot;
<span class="udiff-line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  // Implementation of InterpreterMacroAssembler
  
  void InterpreterMacroAssembler::jump_to_entry(address entry) {
    assert(entry, &quot;Entry must have been generated by now&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -48,11 +49,11 @@</span>
  }
  
  void InterpreterMacroAssembler::profile_obj_type(Register obj, const Address&amp; mdo_addr) {
    Label update, next, none;
  
<span class="udiff-line-modified-removed">-   verify_oop(obj);</span>
<span class="udiff-line-modified-added">+   interp_verify_oop(obj, atos);</span>
  
    testptr(obj, obj);
    jccb(Assembler::notZero, update);
    orptr(mdo_addr, TypeEntries::null_seen);
    jmpb(next);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -346,11 +347,11 @@</span>
    const Address val_addr(rcx, JvmtiThreadState::earlyret_value_offset());
  #ifdef _LP64
    switch (state) {
      case atos: movptr(rax, oop_addr);
                 movptr(oop_addr, (int32_t)NULL_WORD);
<span class="udiff-line-modified-removed">-                verify_oop(rax, state);              break;</span>
<span class="udiff-line-modified-added">+                interp_verify_oop(rax, state);         break;</span>
      case ltos: movptr(rax, val_addr);                 break;
      case btos:                                   // fall through
      case ztos:                                   // fall through
      case ctos:                                   // fall through
      case stos:                                   // fall through
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -367,11 +368,11 @@</span>
    const Address val_addr1(rcx, JvmtiThreadState::earlyret_value_offset()
                               + in_ByteSize(wordSize));
    switch (state) {
      case atos: movptr(rax, oop_addr);
                 movptr(oop_addr, NULL_WORD);
<span class="udiff-line-modified-removed">-                verify_oop(rax, state);                break;</span>
<span class="udiff-line-modified-added">+                interp_verify_oop(rax, state);         break;</span>
      case ltos:
                 movl(rdx, val_addr1);               // fall through
      case btos:                                     // fall through
      case ztos:                                     // fall through
      case ctos:                                     // fall through
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -653,15 +654,15 @@</span>
    case ftos: pop_f(xmm0);               break;
    case dtos: pop_d(xmm0);               break;
    case vtos: /* nothing to do */        break;
    default:   ShouldNotReachHere();
    }
<span class="udiff-line-modified-removed">-   verify_oop(rax, state);</span>
<span class="udiff-line-modified-added">+   interp_verify_oop(rax, state);</span>
  }
  
  void InterpreterMacroAssembler::push(TosState state) {
<span class="udiff-line-modified-removed">-   verify_oop(rax, state);</span>
<span class="udiff-line-modified-added">+   interp_verify_oop(rax, state);</span>
    switch (state) {
    case atos: push_ptr();                break;
    case btos:
    case ztos:
    case ctos:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -719,11 +720,11 @@</span>
        }
        break;
      case vtos: /* nothing to do */                           break;
      default  : ShouldNotReachHere();
    }
<span class="udiff-line-modified-removed">-   verify_oop(rax, state);</span>
<span class="udiff-line-modified-added">+   interp_verify_oop(rax, state);</span>
  }
  
  
  void InterpreterMacroAssembler::push_l(Register lo, Register hi) {
    push(hi);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -742,11 +743,11 @@</span>
    fstp_d(Address(rsp, 0));
  }
  
  
  void InterpreterMacroAssembler::push(TosState state) {
<span class="udiff-line-modified-removed">-   verify_oop(rax, state);</span>
<span class="udiff-line-modified-added">+   interp_verify_oop(rax, state);</span>
    switch (state) {
      case atos: push_ptr(rax); break;
      case btos:                                               // fall through
      case ztos:                                               // fall through
      case ctos:                                               // fall through
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -841,11 +842,11 @@</span>
      jcc(Assembler::greaterEqual, L);
      stop(&quot;broken stack frame&quot;);
      bind(L);
    }
    if (verifyoop) {
<span class="udiff-line-modified-removed">-     verify_oop(rax, state);</span>
<span class="udiff-line-modified-added">+     interp_verify_oop(rax, state);</span>
    }
  
    address* const safepoint_table = Interpreter::safept_table(state);
  #ifdef _LP64
    Label no_safepoint, dispatch;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1618,42 +1619,14 @@</span>
      // Record the receiver type.
      record_klass_in_profile(receiver, mdp, reg2, true);
      bind(skip_receiver_profile);
  
      // The method data pointer needs to be updated to reflect the new target.
<span class="udiff-line-removed">- #if INCLUDE_JVMCI</span>
<span class="udiff-line-removed">-     if (MethodProfileWidth == 0) {</span>
<span class="udiff-line-removed">-       update_mdp_by_constant(mdp, in_bytes(VirtualCallData::virtual_call_data_size()));</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- #else // INCLUDE_JVMCI</span>
<span class="udiff-line-removed">-     update_mdp_by_constant(mdp,</span>
<span class="udiff-line-removed">-                            in_bytes(VirtualCallData::</span>
<span class="udiff-line-removed">-                                     virtual_call_data_size()));</span>
<span class="udiff-line-removed">- #endif // INCLUDE_JVMCI</span>
<span class="udiff-line-removed">-     bind(profile_continue);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #if INCLUDE_JVMCI</span>
<span class="udiff-line-removed">- void InterpreterMacroAssembler::profile_called_method(Register method, Register mdp, Register reg2) {</span>
<span class="udiff-line-removed">-   assert_different_registers(method, mdp, reg2);</span>
<span class="udiff-line-removed">-   if (ProfileInterpreter &amp;&amp; MethodProfileWidth &gt; 0) {</span>
<span class="udiff-line-removed">-     Label profile_continue;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // If no method data exists, go to profile_continue.</span>
<span class="udiff-line-removed">-     test_method_data_pointer(mdp, profile_continue);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     Label done;</span>
<span class="udiff-line-removed">-     record_item_in_profile_helper(method, mdp, reg2, 0, done, MethodProfileWidth,</span>
<span class="udiff-line-removed">-       &amp;VirtualCallData::method_offset, &amp;VirtualCallData::method_count_offset, in_bytes(VirtualCallData::nonprofiled_receiver_count_offset()));</span>
<span class="udiff-line-removed">-     bind(done);</span>
<span class="udiff-line-removed">- </span>
      update_mdp_by_constant(mdp, in_bytes(VirtualCallData::virtual_call_data_size()));
      bind(profile_continue);
    }
  }
<span class="udiff-line-removed">- #endif // INCLUDE_JVMCI</span>
  
  // This routine creates a state machine for updating the multi-row
  // type profile at a virtual call site (or other type-sensitive bytecode).
  // The machine visits each row (of receiver/count) until the receiver type
  // is found, or until it runs out of rows.  At the same time, it remembers
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1956,13 +1929,13 @@</span>
    }
  }
  
  
  
<span class="udiff-line-modified-removed">- void InterpreterMacroAssembler::verify_oop(Register reg, TosState state) {</span>
<span class="udiff-line-modified-added">+ void InterpreterMacroAssembler::_interp_verify_oop(Register reg, TosState state, const char* file, int line) {</span>
    if (state == atos) {
<span class="udiff-line-modified-removed">-     MacroAssembler::verify_oop(reg);</span>
<span class="udiff-line-modified-added">+     MacroAssembler::_verify_oop(reg, &quot;broken oop&quot;, file, line);</span>
    }
  }
  
  void InterpreterMacroAssembler::verify_FPU(int stack_depth, TosState state) {
  #ifndef _LP64
</pre>
<center><a href="globals_x86.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interp_masm_x86.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
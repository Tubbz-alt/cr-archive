<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/vm_version_x86.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="vm_version_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vtableStubs_x86_32.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/vm_version_x86.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 276   union XemXcr0Eax {
 277     uint32_t value;
 278     struct {
 279       uint32_t x87     : 1,
 280                sse     : 1,
 281                ymm     : 1,
 282                bndregs : 1,
 283                bndcsr  : 1,
 284                opmask  : 1,
 285                zmm512  : 1,
 286                zmm32   : 1,
 287                        : 24;
 288     } bits;
 289   };
 290 
 291 protected:
 292   static int _cpu;
 293   static int _model;
 294   static int _stepping;
 295 


 296   static address   _cpuinfo_segv_addr; // address of instruction which causes SEGV
 297   static address   _cpuinfo_cont_addr; // address of instruction after the one which causes SEGV
 298 
 299   enum Feature_Flag {
 300     CPU_CX8      = (1 &lt;&lt; 0), // next bits are from cpuid 1 (EDX)
 301     CPU_CMOV     = (1 &lt;&lt; 1),
 302     CPU_FXSR     = (1 &lt;&lt; 2),
 303     CPU_HT       = (1 &lt;&lt; 3),
 304     CPU_MMX      = (1 &lt;&lt; 4),
 305     CPU_3DNOW_PREFETCH = (1 &lt;&lt; 5), // Processor supports 3dnow prefetch and prefetchw instructions
 306                                    // may not necessarily support other 3dnow instructions
 307     CPU_SSE      = (1 &lt;&lt; 6),
 308     CPU_SSE2     = (1 &lt;&lt; 7),
 309     CPU_SSE3     = (1 &lt;&lt; 8),  // SSE3 comes from cpuid 1 (ECX)
 310     CPU_SSSE3    = (1 &lt;&lt; 9),
 311     CPU_SSE4A    = (1 &lt;&lt; 10),
 312     CPU_SSE4_1   = (1 &lt;&lt; 11),
 313     CPU_SSE4_2   = (1 &lt;&lt; 12),
 314     CPU_POPCNT   = (1 &lt;&lt; 13),
 315     CPU_LZCNT    = (1 &lt;&lt; 14),
</pre>
<hr />
<pre>
 319     CPU_AVX2     = (1 &lt;&lt; 18),
 320     CPU_AES      = (1 &lt;&lt; 19),
 321     CPU_ERMS     = (1 &lt;&lt; 20), // enhanced &#39;rep movsb/stosb&#39; instructions
 322     CPU_CLMUL    = (1 &lt;&lt; 21), // carryless multiply for CRC
 323     CPU_BMI1     = (1 &lt;&lt; 22),
 324     CPU_BMI2     = (1 &lt;&lt; 23),
 325     CPU_RTM      = (1 &lt;&lt; 24), // Restricted Transactional Memory instructions
 326     CPU_ADX      = (1 &lt;&lt; 25),
 327     CPU_AVX512F  = (1 &lt;&lt; 26), // AVX 512bit foundation instructions
 328     CPU_AVX512DQ = (1 &lt;&lt; 27),
 329     CPU_AVX512PF = (1 &lt;&lt; 28),
 330     CPU_AVX512ER = (1 &lt;&lt; 29),
 331     CPU_AVX512CD = (1 &lt;&lt; 30)
 332     // Keeping sign bit 31 unassigned.
 333   };
 334 
 335 #define CPU_AVX512BW ((uint64_t)UCONST64(0x100000000)) // enums are limited to 31 bit
 336 #define CPU_AVX512VL ((uint64_t)UCONST64(0x200000000)) // EVEX instructions with smaller vector length
 337 #define CPU_SHA ((uint64_t)UCONST64(0x400000000))      // SHA instructions
 338 #define CPU_FMA ((uint64_t)UCONST64(0x800000000))      // FMA instructions
<span class="line-modified"> 339 #define CPU_VZEROUPPER ((uint64_t)UCONST64(0x1000000000))       // Vzeroupper instruction</span>
<span class="line-modified"> 340 #define CPU_AVX512_VPOPCNTDQ ((uint64_t)UCONST64(0x2000000000)) // Vector popcount</span>
<span class="line-modified"> 341 #define CPU_AVX512_VPCLMULQDQ ((uint64_t)UCONST64(0x4000000000)) //Vector carryless multiplication</span>
<span class="line-modified"> 342 #define CPU_VAES ((uint64_t)UCONST64(0x8000000000))    // Vector AES instructions</span>
<span class="line-modified"> 343 #define CPU_VNNI ((uint64_t)UCONST64(0x10000000000))   // Vector Neural Network Instructions</span>

 344 
 345 #define CPU_FLUSH ((uint64_t)UCONST64(0x20000000000))  // flush instruction
 346 #define CPU_FLUSHOPT ((uint64_t)UCONST64(0x40000000000)) // flushopt instruction
 347 #define CPU_CLWB ((uint64_t)UCONST64(0x80000000000))   // clwb instruction
<span class="line-removed"> 348 #define CPU_VBMI2 ((uint64_t)UCONST64(0x100000000000))   // VBMI2 shift left double instructions</span>
 349 

 350 
 351 enum Extended_Family {
 352     // AMD
 353     CPU_FAMILY_AMD_11H       = 0x11,
 354     // ZX
 355     CPU_FAMILY_ZX_CORE_F6    = 6,
 356     CPU_FAMILY_ZX_CORE_F7    = 7,
 357     // Intel
 358     CPU_FAMILY_INTEL_CORE    = 6,
 359     CPU_MODEL_NEHALEM        = 0x1e,
 360     CPU_MODEL_NEHALEM_EP     = 0x1a,
 361     CPU_MODEL_NEHALEM_EX     = 0x2e,
 362     CPU_MODEL_WESTMERE       = 0x25,
 363     CPU_MODEL_WESTMERE_EP    = 0x2c,
 364     CPU_MODEL_WESTMERE_EX    = 0x2f,
 365     CPU_MODEL_SANDYBRIDGE    = 0x2a,
 366     CPU_MODEL_SANDYBRIDGE_EP = 0x2d,
 367     CPU_MODEL_IVYBRIDGE_EP   = 0x3a,
 368     CPU_MODEL_HASWELL_E3     = 0x3c,
 369     CPU_MODEL_HASWELL_E7     = 0x3f,
</pre>
<hr />
<pre>
 482     result += _cpuid_info.std_cpuid1_eax.bits.ext_family;
 483     return result;
 484   }
 485 
 486   static uint32_t extended_cpu_model() {
 487     uint32_t result = _cpuid_info.std_cpuid1_eax.bits.model;
 488     result |= _cpuid_info.std_cpuid1_eax.bits.ext_model &lt;&lt; 4;
 489     return result;
 490   }
 491 
 492   static uint32_t cpu_stepping() {
 493     uint32_t result = _cpuid_info.std_cpuid1_eax.bits.stepping;
 494     return result;
 495   }
 496 
 497   static uint logical_processor_count() {
 498     uint result = threads_per_core();
 499     return result;
 500   }
 501 


 502   static uint64_t feature_flags() {
 503     uint64_t result = 0;
 504     if (_cpuid_info.std_cpuid1_edx.bits.cmpxchg8 != 0)
 505       result |= CPU_CX8;
 506     if (_cpuid_info.std_cpuid1_edx.bits.cmov != 0)
 507       result |= CPU_CMOV;
 508     if (_cpuid_info.std_cpuid1_edx.bits.clflush != 0)
 509       result |= CPU_FLUSH;
 510 #ifdef _LP64
 511     // clflush should always be available on x86_64
 512     // if not we are in real trouble because we rely on it
 513     // to flush the code cache.
 514     assert ((result &amp; CPU_FLUSH) != 0, &quot;clflush should be available&quot;);
 515 #endif
 516     if (_cpuid_info.std_cpuid1_edx.bits.fxsr != 0 || (is_amd_family() &amp;&amp;
 517         _cpuid_info.ext_cpuid1_edx.bits.fxsr != 0))
 518       result |= CPU_FXSR;
 519     // HT flag is set for multi-core processors also.
 520     if (threads_per_core() &gt; 1)
 521       result |= CPU_HT;
</pre>
<hr />
<pre>
 549           _cpuid_info.xem_xcr0_eax.bits.zmm512 != 0 &amp;&amp;
 550           _cpuid_info.xem_xcr0_eax.bits.zmm32 != 0) {
 551         result |= CPU_AVX512F;
 552         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512cd != 0)
 553           result |= CPU_AVX512CD;
 554         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512dq != 0)
 555           result |= CPU_AVX512DQ;
 556         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512pf != 0)
 557           result |= CPU_AVX512PF;
 558         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512er != 0)
 559           result |= CPU_AVX512ER;
 560         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512bw != 0)
 561           result |= CPU_AVX512BW;
 562         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512vl != 0)
 563           result |= CPU_AVX512VL;
 564         if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_vpopcntdq != 0)
 565           result |= CPU_AVX512_VPOPCNTDQ;
 566         if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_vpclmulqdq != 0)
 567           result |= CPU_AVX512_VPCLMULQDQ;
 568         if (_cpuid_info.sef_cpuid7_ecx.bits.vaes != 0)
<span class="line-modified"> 569           result |= CPU_VAES;</span>
 570         if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_vnni != 0)
<span class="line-modified"> 571           result |= CPU_VNNI;</span>
 572         if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_vbmi2 != 0)
<span class="line-modified"> 573           result |= CPU_VBMI2;</span>
 574       }
 575     }
 576     if (_cpuid_info.sef_cpuid7_ebx.bits.bmi1 != 0)
 577       result |= CPU_BMI1;
 578     if (_cpuid_info.std_cpuid1_edx.bits.tsc != 0)
 579       result |= CPU_TSC;
 580     if (_cpuid_info.ext_cpuid7_edx.bits.tsc_invariance != 0)
 581       result |= CPU_TSCINV;
 582     if (_cpuid_info.std_cpuid1_ecx.bits.aes != 0)
 583       result |= CPU_AES;
 584     if (_cpuid_info.sef_cpuid7_ebx.bits.erms != 0)
 585       result |= CPU_ERMS;
 586     if (_cpuid_info.std_cpuid1_ecx.bits.clmul != 0)
 587       result |= CPU_CLMUL;
 588     if (_cpuid_info.sef_cpuid7_ebx.bits.rtm != 0)
 589       result |= CPU_RTM;
 590     if (_cpuid_info.sef_cpuid7_ebx.bits.adx != 0)
 591        result |= CPU_ADX;
 592     if (_cpuid_info.sef_cpuid7_ebx.bits.bmi2 != 0)
 593       result |= CPU_BMI2;
</pre>
<hr />
<pre>
 841   static bool supports_bmi2()     { return (_features &amp; CPU_BMI2) != 0; }
 842   static bool supports_adx()      { return (_features &amp; CPU_ADX) != 0; }
 843   static bool supports_evex()     { return (_features &amp; CPU_AVX512F) != 0; }
 844   static bool supports_avx512dq() { return (_features &amp; CPU_AVX512DQ) != 0; }
 845   static bool supports_avx512pf() { return (_features &amp; CPU_AVX512PF) != 0; }
 846   static bool supports_avx512er() { return (_features &amp; CPU_AVX512ER) != 0; }
 847   static bool supports_avx512cd() { return (_features &amp; CPU_AVX512CD) != 0; }
 848   static bool supports_avx512bw() { return (_features &amp; CPU_AVX512BW) != 0; }
 849   static bool supports_avx512vl() { return (_features &amp; CPU_AVX512VL) != 0; }
 850   static bool supports_avx512vlbw() { return (supports_evex() &amp;&amp; supports_avx512bw() &amp;&amp; supports_avx512vl()); }
 851   static bool supports_avx512vldq() { return (supports_evex() &amp;&amp; supports_avx512dq() &amp;&amp; supports_avx512vl()); }
 852   static bool supports_avx512vlbwdq() { return (supports_evex() &amp;&amp; supports_avx512vl() &amp;&amp;
 853                                                 supports_avx512bw() &amp;&amp; supports_avx512dq()); }
 854   static bool supports_avx512novl() { return (supports_evex() &amp;&amp; !supports_avx512vl()); }
 855   static bool supports_avx512nobw() { return (supports_evex() &amp;&amp; !supports_avx512bw()); }
 856   static bool supports_avx256only() { return (supports_avx2() &amp;&amp; !supports_evex()); }
 857   static bool supports_avxonly()    { return ((supports_avx2() || supports_avx()) &amp;&amp; !supports_evex()); }
 858   static bool supports_sha()        { return (_features &amp; CPU_SHA) != 0; }
 859   static bool supports_fma()        { return (_features &amp; CPU_FMA) != 0 &amp;&amp; supports_avx(); }
 860   static bool supports_vzeroupper() { return (_features &amp; CPU_VZEROUPPER) != 0; }
<span class="line-modified"> 861   static bool supports_vpopcntdq()  { return (_features &amp; CPU_AVX512_VPOPCNTDQ) != 0; }</span>
 862   static bool supports_avx512_vpclmulqdq() { return (_features &amp; CPU_AVX512_VPCLMULQDQ) != 0; }
<span class="line-modified"> 863   static bool supports_vaes()       { return (_features &amp; CPU_VAES) != 0; }</span>
<span class="line-modified"> 864   static bool supports_vnni()       { return (_features &amp; CPU_VNNI) != 0; }</span>
<span class="line-modified"> 865   static bool supports_vbmi2()      { return (_features &amp; CPU_VBMI2) != 0; }</span>
 866 
 867   // Intel features
 868   static bool is_intel_family_core() { return is_intel() &amp;&amp;
 869                                        extended_cpu_family() == CPU_FAMILY_INTEL_CORE; }
 870 
 871   static bool is_intel_skylake() { return is_intel_family_core() &amp;&amp;
 872                                           extended_cpu_model() == CPU_MODEL_SKYLAKE; }
 873 
 874   static bool is_intel_tsc_synched_at_init()  {
 875     if (is_intel_family_core()) {
 876       uint32_t ext_model = extended_cpu_model();
 877       if (ext_model == CPU_MODEL_NEHALEM_EP     ||
 878           ext_model == CPU_MODEL_WESTMERE_EP    ||
 879           ext_model == CPU_MODEL_SANDYBRIDGE_EP ||
 880           ext_model == CPU_MODEL_IVYBRIDGE_EP) {
 881         // &lt;= 2-socket invariant tsc support. EX versions are usually used
 882         // in &gt; 2-socket systems and likely don&#39;t synchronize tscs at
 883         // initialization.
 884         // Code that uses tsc values must be prepared for them to arbitrarily
 885         // jump forward or backward.
 886         return true;
 887       }
 888     }
 889     return false;
 890   }
 891 






 892   // AMD features
 893   static bool supports_3dnow_prefetch()    { return (_features &amp; CPU_3DNOW_PREFETCH) != 0; }
 894   static bool supports_mmx_ext()  { return is_amd_family() &amp;&amp; _cpuid_info.ext_cpuid1_edx.bits.mmx_amd != 0; }
 895   static bool supports_lzcnt()    { return (_features &amp; CPU_LZCNT) != 0; }
 896   static bool supports_sse4a()    { return (_features &amp; CPU_SSE4A) != 0; }
 897 
 898   static bool is_amd_Barcelona()  { return is_amd() &amp;&amp;
 899                                            extended_cpu_family() == CPU_FAMILY_AMD_11H; }
 900 
 901   // Intel and AMD newer cores support fast timestamps well
 902   static bool supports_tscinv_bit() {
 903     return (_features &amp; CPU_TSCINV) != 0;
 904   }
 905   static bool supports_tscinv() {
 906     return supports_tscinv_bit() &amp;&amp;
 907       ((is_amd_family() &amp;&amp; !is_amd_Barcelona()) ||
 908         is_intel_tsc_synched_at_init());
 909   }
 910 
 911   // Intel Core and newer cpus have fast IDIV instruction (excluding Atom).
</pre>
</td>
<td>
<hr />
<pre>
 276   union XemXcr0Eax {
 277     uint32_t value;
 278     struct {
 279       uint32_t x87     : 1,
 280                sse     : 1,
 281                ymm     : 1,
 282                bndregs : 1,
 283                bndcsr  : 1,
 284                opmask  : 1,
 285                zmm512  : 1,
 286                zmm32   : 1,
 287                        : 24;
 288     } bits;
 289   };
 290 
 291 protected:
 292   static int _cpu;
 293   static int _model;
 294   static int _stepping;
 295 
<span class="line-added"> 296   static bool _has_intel_jcc_erratum;</span>
<span class="line-added"> 297 </span>
 298   static address   _cpuinfo_segv_addr; // address of instruction which causes SEGV
 299   static address   _cpuinfo_cont_addr; // address of instruction after the one which causes SEGV
 300 
 301   enum Feature_Flag {
 302     CPU_CX8      = (1 &lt;&lt; 0), // next bits are from cpuid 1 (EDX)
 303     CPU_CMOV     = (1 &lt;&lt; 1),
 304     CPU_FXSR     = (1 &lt;&lt; 2),
 305     CPU_HT       = (1 &lt;&lt; 3),
 306     CPU_MMX      = (1 &lt;&lt; 4),
 307     CPU_3DNOW_PREFETCH = (1 &lt;&lt; 5), // Processor supports 3dnow prefetch and prefetchw instructions
 308                                    // may not necessarily support other 3dnow instructions
 309     CPU_SSE      = (1 &lt;&lt; 6),
 310     CPU_SSE2     = (1 &lt;&lt; 7),
 311     CPU_SSE3     = (1 &lt;&lt; 8),  // SSE3 comes from cpuid 1 (ECX)
 312     CPU_SSSE3    = (1 &lt;&lt; 9),
 313     CPU_SSE4A    = (1 &lt;&lt; 10),
 314     CPU_SSE4_1   = (1 &lt;&lt; 11),
 315     CPU_SSE4_2   = (1 &lt;&lt; 12),
 316     CPU_POPCNT   = (1 &lt;&lt; 13),
 317     CPU_LZCNT    = (1 &lt;&lt; 14),
</pre>
<hr />
<pre>
 321     CPU_AVX2     = (1 &lt;&lt; 18),
 322     CPU_AES      = (1 &lt;&lt; 19),
 323     CPU_ERMS     = (1 &lt;&lt; 20), // enhanced &#39;rep movsb/stosb&#39; instructions
 324     CPU_CLMUL    = (1 &lt;&lt; 21), // carryless multiply for CRC
 325     CPU_BMI1     = (1 &lt;&lt; 22),
 326     CPU_BMI2     = (1 &lt;&lt; 23),
 327     CPU_RTM      = (1 &lt;&lt; 24), // Restricted Transactional Memory instructions
 328     CPU_ADX      = (1 &lt;&lt; 25),
 329     CPU_AVX512F  = (1 &lt;&lt; 26), // AVX 512bit foundation instructions
 330     CPU_AVX512DQ = (1 &lt;&lt; 27),
 331     CPU_AVX512PF = (1 &lt;&lt; 28),
 332     CPU_AVX512ER = (1 &lt;&lt; 29),
 333     CPU_AVX512CD = (1 &lt;&lt; 30)
 334     // Keeping sign bit 31 unassigned.
 335   };
 336 
 337 #define CPU_AVX512BW ((uint64_t)UCONST64(0x100000000)) // enums are limited to 31 bit
 338 #define CPU_AVX512VL ((uint64_t)UCONST64(0x200000000)) // EVEX instructions with smaller vector length
 339 #define CPU_SHA ((uint64_t)UCONST64(0x400000000))      // SHA instructions
 340 #define CPU_FMA ((uint64_t)UCONST64(0x800000000))      // FMA instructions
<span class="line-modified"> 341 #define CPU_VZEROUPPER ((uint64_t)UCONST64(0x1000000000))        // Vzeroupper instruction</span>
<span class="line-modified"> 342 #define CPU_AVX512_VPOPCNTDQ ((uint64_t)UCONST64(0x2000000000))  // Vector popcount</span>
<span class="line-modified"> 343 #define CPU_AVX512_VPCLMULQDQ ((uint64_t)UCONST64(0x4000000000)) // Vector carryless multiplication</span>
<span class="line-modified"> 344 #define CPU_AVX512_VAES ((uint64_t)UCONST64(0x8000000000))       // Vector AES instructions</span>
<span class="line-modified"> 345 #define CPU_AVX512_VNNI ((uint64_t)UCONST64(0x10000000000))      // Vector Neural Network Instructions</span>
<span class="line-added"> 346 #define CPU_AVX512_VBMI2 ((uint64_t)UCONST64(0x100000000000))    // VBMI2 shift left double instructions</span>
 347 
 348 #define CPU_FLUSH ((uint64_t)UCONST64(0x20000000000))  // flush instruction
 349 #define CPU_FLUSHOPT ((uint64_t)UCONST64(0x40000000000)) // flushopt instruction
 350 #define CPU_CLWB ((uint64_t)UCONST64(0x80000000000))   // clwb instruction

 351 
<span class="line-added"> 352 // NB! When adding new CPU feature detection consider updating feature string in VM_Version::get_processor_features().</span>
 353 
 354 enum Extended_Family {
 355     // AMD
 356     CPU_FAMILY_AMD_11H       = 0x11,
 357     // ZX
 358     CPU_FAMILY_ZX_CORE_F6    = 6,
 359     CPU_FAMILY_ZX_CORE_F7    = 7,
 360     // Intel
 361     CPU_FAMILY_INTEL_CORE    = 6,
 362     CPU_MODEL_NEHALEM        = 0x1e,
 363     CPU_MODEL_NEHALEM_EP     = 0x1a,
 364     CPU_MODEL_NEHALEM_EX     = 0x2e,
 365     CPU_MODEL_WESTMERE       = 0x25,
 366     CPU_MODEL_WESTMERE_EP    = 0x2c,
 367     CPU_MODEL_WESTMERE_EX    = 0x2f,
 368     CPU_MODEL_SANDYBRIDGE    = 0x2a,
 369     CPU_MODEL_SANDYBRIDGE_EP = 0x2d,
 370     CPU_MODEL_IVYBRIDGE_EP   = 0x3a,
 371     CPU_MODEL_HASWELL_E3     = 0x3c,
 372     CPU_MODEL_HASWELL_E7     = 0x3f,
</pre>
<hr />
<pre>
 485     result += _cpuid_info.std_cpuid1_eax.bits.ext_family;
 486     return result;
 487   }
 488 
 489   static uint32_t extended_cpu_model() {
 490     uint32_t result = _cpuid_info.std_cpuid1_eax.bits.model;
 491     result |= _cpuid_info.std_cpuid1_eax.bits.ext_model &lt;&lt; 4;
 492     return result;
 493   }
 494 
 495   static uint32_t cpu_stepping() {
 496     uint32_t result = _cpuid_info.std_cpuid1_eax.bits.stepping;
 497     return result;
 498   }
 499 
 500   static uint logical_processor_count() {
 501     uint result = threads_per_core();
 502     return result;
 503   }
 504 
<span class="line-added"> 505   static bool compute_has_intel_jcc_erratum();</span>
<span class="line-added"> 506 </span>
 507   static uint64_t feature_flags() {
 508     uint64_t result = 0;
 509     if (_cpuid_info.std_cpuid1_edx.bits.cmpxchg8 != 0)
 510       result |= CPU_CX8;
 511     if (_cpuid_info.std_cpuid1_edx.bits.cmov != 0)
 512       result |= CPU_CMOV;
 513     if (_cpuid_info.std_cpuid1_edx.bits.clflush != 0)
 514       result |= CPU_FLUSH;
 515 #ifdef _LP64
 516     // clflush should always be available on x86_64
 517     // if not we are in real trouble because we rely on it
 518     // to flush the code cache.
 519     assert ((result &amp; CPU_FLUSH) != 0, &quot;clflush should be available&quot;);
 520 #endif
 521     if (_cpuid_info.std_cpuid1_edx.bits.fxsr != 0 || (is_amd_family() &amp;&amp;
 522         _cpuid_info.ext_cpuid1_edx.bits.fxsr != 0))
 523       result |= CPU_FXSR;
 524     // HT flag is set for multi-core processors also.
 525     if (threads_per_core() &gt; 1)
 526       result |= CPU_HT;
</pre>
<hr />
<pre>
 554           _cpuid_info.xem_xcr0_eax.bits.zmm512 != 0 &amp;&amp;
 555           _cpuid_info.xem_xcr0_eax.bits.zmm32 != 0) {
 556         result |= CPU_AVX512F;
 557         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512cd != 0)
 558           result |= CPU_AVX512CD;
 559         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512dq != 0)
 560           result |= CPU_AVX512DQ;
 561         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512pf != 0)
 562           result |= CPU_AVX512PF;
 563         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512er != 0)
 564           result |= CPU_AVX512ER;
 565         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512bw != 0)
 566           result |= CPU_AVX512BW;
 567         if (_cpuid_info.sef_cpuid7_ebx.bits.avx512vl != 0)
 568           result |= CPU_AVX512VL;
 569         if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_vpopcntdq != 0)
 570           result |= CPU_AVX512_VPOPCNTDQ;
 571         if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_vpclmulqdq != 0)
 572           result |= CPU_AVX512_VPCLMULQDQ;
 573         if (_cpuid_info.sef_cpuid7_ecx.bits.vaes != 0)
<span class="line-modified"> 574           result |= CPU_AVX512_VAES;</span>
 575         if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_vnni != 0)
<span class="line-modified"> 576           result |= CPU_AVX512_VNNI;</span>
 577         if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_vbmi2 != 0)
<span class="line-modified"> 578           result |= CPU_AVX512_VBMI2;</span>
 579       }
 580     }
 581     if (_cpuid_info.sef_cpuid7_ebx.bits.bmi1 != 0)
 582       result |= CPU_BMI1;
 583     if (_cpuid_info.std_cpuid1_edx.bits.tsc != 0)
 584       result |= CPU_TSC;
 585     if (_cpuid_info.ext_cpuid7_edx.bits.tsc_invariance != 0)
 586       result |= CPU_TSCINV;
 587     if (_cpuid_info.std_cpuid1_ecx.bits.aes != 0)
 588       result |= CPU_AES;
 589     if (_cpuid_info.sef_cpuid7_ebx.bits.erms != 0)
 590       result |= CPU_ERMS;
 591     if (_cpuid_info.std_cpuid1_ecx.bits.clmul != 0)
 592       result |= CPU_CLMUL;
 593     if (_cpuid_info.sef_cpuid7_ebx.bits.rtm != 0)
 594       result |= CPU_RTM;
 595     if (_cpuid_info.sef_cpuid7_ebx.bits.adx != 0)
 596        result |= CPU_ADX;
 597     if (_cpuid_info.sef_cpuid7_ebx.bits.bmi2 != 0)
 598       result |= CPU_BMI2;
</pre>
<hr />
<pre>
 846   static bool supports_bmi2()     { return (_features &amp; CPU_BMI2) != 0; }
 847   static bool supports_adx()      { return (_features &amp; CPU_ADX) != 0; }
 848   static bool supports_evex()     { return (_features &amp; CPU_AVX512F) != 0; }
 849   static bool supports_avx512dq() { return (_features &amp; CPU_AVX512DQ) != 0; }
 850   static bool supports_avx512pf() { return (_features &amp; CPU_AVX512PF) != 0; }
 851   static bool supports_avx512er() { return (_features &amp; CPU_AVX512ER) != 0; }
 852   static bool supports_avx512cd() { return (_features &amp; CPU_AVX512CD) != 0; }
 853   static bool supports_avx512bw() { return (_features &amp; CPU_AVX512BW) != 0; }
 854   static bool supports_avx512vl() { return (_features &amp; CPU_AVX512VL) != 0; }
 855   static bool supports_avx512vlbw() { return (supports_evex() &amp;&amp; supports_avx512bw() &amp;&amp; supports_avx512vl()); }
 856   static bool supports_avx512vldq() { return (supports_evex() &amp;&amp; supports_avx512dq() &amp;&amp; supports_avx512vl()); }
 857   static bool supports_avx512vlbwdq() { return (supports_evex() &amp;&amp; supports_avx512vl() &amp;&amp;
 858                                                 supports_avx512bw() &amp;&amp; supports_avx512dq()); }
 859   static bool supports_avx512novl() { return (supports_evex() &amp;&amp; !supports_avx512vl()); }
 860   static bool supports_avx512nobw() { return (supports_evex() &amp;&amp; !supports_avx512bw()); }
 861   static bool supports_avx256only() { return (supports_avx2() &amp;&amp; !supports_evex()); }
 862   static bool supports_avxonly()    { return ((supports_avx2() || supports_avx()) &amp;&amp; !supports_evex()); }
 863   static bool supports_sha()        { return (_features &amp; CPU_SHA) != 0; }
 864   static bool supports_fma()        { return (_features &amp; CPU_FMA) != 0 &amp;&amp; supports_avx(); }
 865   static bool supports_vzeroupper() { return (_features &amp; CPU_VZEROUPPER) != 0; }
<span class="line-modified"> 866   static bool supports_avx512_vpopcntdq()  { return (_features &amp; CPU_AVX512_VPOPCNTDQ) != 0; }</span>
 867   static bool supports_avx512_vpclmulqdq() { return (_features &amp; CPU_AVX512_VPCLMULQDQ) != 0; }
<span class="line-modified"> 868   static bool supports_avx512_vaes()       { return (_features &amp; CPU_AVX512_VAES) != 0; }</span>
<span class="line-modified"> 869   static bool supports_avx512_vnni()       { return (_features &amp; CPU_AVX512_VNNI) != 0; }</span>
<span class="line-modified"> 870   static bool supports_avx512_vbmi2()      { return (_features &amp; CPU_AVX512_VBMI2) != 0; }</span>
 871 
 872   // Intel features
 873   static bool is_intel_family_core() { return is_intel() &amp;&amp;
 874                                        extended_cpu_family() == CPU_FAMILY_INTEL_CORE; }
 875 
 876   static bool is_intel_skylake() { return is_intel_family_core() &amp;&amp;
 877                                           extended_cpu_model() == CPU_MODEL_SKYLAKE; }
 878 
 879   static bool is_intel_tsc_synched_at_init()  {
 880     if (is_intel_family_core()) {
 881       uint32_t ext_model = extended_cpu_model();
 882       if (ext_model == CPU_MODEL_NEHALEM_EP     ||
 883           ext_model == CPU_MODEL_WESTMERE_EP    ||
 884           ext_model == CPU_MODEL_SANDYBRIDGE_EP ||
 885           ext_model == CPU_MODEL_IVYBRIDGE_EP) {
 886         // &lt;= 2-socket invariant tsc support. EX versions are usually used
 887         // in &gt; 2-socket systems and likely don&#39;t synchronize tscs at
 888         // initialization.
 889         // Code that uses tsc values must be prepared for them to arbitrarily
 890         // jump forward or backward.
 891         return true;
 892       }
 893     }
 894     return false;
 895   }
 896 
<span class="line-added"> 897   // This checks if the JVM is potentially affected by an erratum on Intel CPUs (SKX102)</span>
<span class="line-added"> 898   // that causes unpredictable behaviour when jcc crosses 64 byte boundaries. Its microcode</span>
<span class="line-added"> 899   // mitigation causes regressions when jumps or fused conditional branches cross or end at</span>
<span class="line-added"> 900   // 32 byte boundaries.</span>
<span class="line-added"> 901   static bool has_intel_jcc_erratum() { return _has_intel_jcc_erratum; }</span>
<span class="line-added"> 902 </span>
 903   // AMD features
 904   static bool supports_3dnow_prefetch()    { return (_features &amp; CPU_3DNOW_PREFETCH) != 0; }
 905   static bool supports_mmx_ext()  { return is_amd_family() &amp;&amp; _cpuid_info.ext_cpuid1_edx.bits.mmx_amd != 0; }
 906   static bool supports_lzcnt()    { return (_features &amp; CPU_LZCNT) != 0; }
 907   static bool supports_sse4a()    { return (_features &amp; CPU_SSE4A) != 0; }
 908 
 909   static bool is_amd_Barcelona()  { return is_amd() &amp;&amp;
 910                                            extended_cpu_family() == CPU_FAMILY_AMD_11H; }
 911 
 912   // Intel and AMD newer cores support fast timestamps well
 913   static bool supports_tscinv_bit() {
 914     return (_features &amp; CPU_TSCINV) != 0;
 915   }
 916   static bool supports_tscinv() {
 917     return supports_tscinv_bit() &amp;&amp;
 918       ((is_amd_family() &amp;&amp; !is_amd_Barcelona()) ||
 919         is_intel_tsc_synched_at_init());
 920   }
 921 
 922   // Intel Core and newer cpus have fast IDIV instruction (excluding Atom).
</pre>
</td>
</tr>
</table>
<center><a href="vm_version_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vtableStubs_x86_32.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
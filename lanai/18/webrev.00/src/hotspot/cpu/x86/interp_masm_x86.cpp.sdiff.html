<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/interp_masm_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="globals_x86.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interp_masm_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/interp_masm_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;interp_masm_x86.hpp&quot;
  27 #include &quot;interpreter/interpreter.hpp&quot;
  28 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  29 #include &quot;logging/log.hpp&quot;
  30 #include &quot;oops/arrayOop.hpp&quot;
  31 #include &quot;oops/markWord.hpp&quot;
  32 #include &quot;oops/methodData.hpp&quot;
  33 #include &quot;oops/method.hpp&quot;
  34 #include &quot;prims/jvmtiExport.hpp&quot;
  35 #include &quot;prims/jvmtiThreadState.hpp&quot;
  36 #include &quot;runtime/basicLock.hpp&quot;
  37 #include &quot;runtime/biasedLocking.hpp&quot;
  38 #include &quot;runtime/frame.inline.hpp&quot;
  39 #include &quot;runtime/safepointMechanism.hpp&quot;
  40 #include &quot;runtime/sharedRuntime.hpp&quot;
  41 #include &quot;runtime/thread.inline.hpp&quot;

  42 
  43 // Implementation of InterpreterMacroAssembler
  44 
  45 void InterpreterMacroAssembler::jump_to_entry(address entry) {
  46   assert(entry, &quot;Entry must have been generated by now&quot;);
  47   jump(RuntimeAddress(entry));
  48 }
  49 
  50 void InterpreterMacroAssembler::profile_obj_type(Register obj, const Address&amp; mdo_addr) {
  51   Label update, next, none;
  52 
<span class="line-modified">  53   verify_oop(obj);</span>
  54 
  55   testptr(obj, obj);
  56   jccb(Assembler::notZero, update);
  57   orptr(mdo_addr, TypeEntries::null_seen);
  58   jmpb(next);
  59 
  60   bind(update);
  61   load_klass(obj, obj);
  62 
  63   xorptr(obj, mdo_addr);
  64   testptr(obj, TypeEntries::type_klass_mask);
  65   jccb(Assembler::zero, next); // klass seen before, nothing to
  66                                // do. The unknown bit may have been
  67                                // set already but no need to check.
  68 
  69   testptr(obj, TypeEntries::type_unknown);
  70   jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
  71 
  72   cmpptr(mdo_addr, 0);
  73   jccb(Assembler::equal, none);
</pre>
<hr />
<pre>
 331     // Call Interpreter::remove_activation_preserving_args_entry() to get the
 332     // address of the same-named entrypoint in the generated interpreter code.
 333     call_VM_leaf(CAST_FROM_FN_PTR(address, Interpreter::remove_activation_preserving_args_entry));
 334     jmp(rax);
 335     bind(L);
 336     NOT_LP64(get_thread(java_thread);)
 337   }
 338 }
 339 
 340 void InterpreterMacroAssembler::load_earlyret_value(TosState state) {
 341   Register thread = LP64_ONLY(r15_thread) NOT_LP64(rcx);
 342   NOT_LP64(get_thread(thread);)
 343   movptr(rcx, Address(thread, JavaThread::jvmti_thread_state_offset()));
 344   const Address tos_addr(rcx, JvmtiThreadState::earlyret_tos_offset());
 345   const Address oop_addr(rcx, JvmtiThreadState::earlyret_oop_offset());
 346   const Address val_addr(rcx, JvmtiThreadState::earlyret_value_offset());
 347 #ifdef _LP64
 348   switch (state) {
 349     case atos: movptr(rax, oop_addr);
 350                movptr(oop_addr, (int32_t)NULL_WORD);
<span class="line-modified"> 351                verify_oop(rax, state);              break;</span>
 352     case ltos: movptr(rax, val_addr);                 break;
 353     case btos:                                   // fall through
 354     case ztos:                                   // fall through
 355     case ctos:                                   // fall through
 356     case stos:                                   // fall through
 357     case itos: movl(rax, val_addr);                 break;
 358     case ftos: load_float(val_addr);                break;
 359     case dtos: load_double(val_addr);               break;
 360     case vtos: /* nothing to do */                  break;
 361     default  : ShouldNotReachHere();
 362   }
 363   // Clean up tos value in the thread object
 364   movl(tos_addr,  (int) ilgl);
 365   movl(val_addr,  (int32_t) NULL_WORD);
 366 #else
 367   const Address val_addr1(rcx, JvmtiThreadState::earlyret_value_offset()
 368                              + in_ByteSize(wordSize));
 369   switch (state) {
 370     case atos: movptr(rax, oop_addr);
 371                movptr(oop_addr, NULL_WORD);
<span class="line-modified"> 372                verify_oop(rax, state);                break;</span>
 373     case ltos:
 374                movl(rdx, val_addr1);               // fall through
 375     case btos:                                     // fall through
 376     case ztos:                                     // fall through
 377     case ctos:                                     // fall through
 378     case stos:                                     // fall through
 379     case itos: movl(rax, val_addr);                   break;
 380     case ftos: load_float(val_addr);                  break;
 381     case dtos: load_double(val_addr);                 break;
 382     case vtos: /* nothing to do */                    break;
 383     default  : ShouldNotReachHere();
 384   }
 385 #endif // _LP64
 386   // Clean up tos value in the thread object
 387   movl(tos_addr,  (int32_t) ilgl);
 388   movptr(val_addr,  NULL_WORD);
 389   NOT_LP64(movptr(val_addr1, NULL_WORD);)
 390 }
 391 
 392 
</pre>
<hr />
<pre>
 638 void InterpreterMacroAssembler::push_l(Register r) {
 639   subptr(rsp, 2 * wordSize);
 640   movptr(Address(rsp, Interpreter::expr_offset_in_bytes(0)), r         );
 641   movptr(Address(rsp, Interpreter::expr_offset_in_bytes(1)), NULL_WORD );
 642 }
 643 
 644 void InterpreterMacroAssembler::pop(TosState state) {
 645   switch (state) {
 646   case atos: pop_ptr();                 break;
 647   case btos:
 648   case ztos:
 649   case ctos:
 650   case stos:
 651   case itos: pop_i();                   break;
 652   case ltos: pop_l();                   break;
 653   case ftos: pop_f(xmm0);               break;
 654   case dtos: pop_d(xmm0);               break;
 655   case vtos: /* nothing to do */        break;
 656   default:   ShouldNotReachHere();
 657   }
<span class="line-modified"> 658   verify_oop(rax, state);</span>
 659 }
 660 
 661 void InterpreterMacroAssembler::push(TosState state) {
<span class="line-modified"> 662   verify_oop(rax, state);</span>
 663   switch (state) {
 664   case atos: push_ptr();                break;
 665   case btos:
 666   case ztos:
 667   case ctos:
 668   case stos:
 669   case itos: push_i();                  break;
 670   case ltos: push_l();                  break;
 671   case ftos: push_f(xmm0);              break;
 672   case dtos: push_d(xmm0);              break;
 673   case vtos: /* nothing to do */        break;
 674   default  : ShouldNotReachHere();
 675   }
 676 }
 677 #else
 678 void InterpreterMacroAssembler::pop_i(Register r) {
 679   pop(r);
 680 }
 681 
 682 void InterpreterMacroAssembler::pop_l(Register lo, Register hi) {
</pre>
<hr />
<pre>
 704     case stos:                                               // fall through
 705     case itos: pop_i(rax);                                   break;
 706     case ltos: pop_l(rax, rdx);                              break;
 707     case ftos:
 708       if (UseSSE &gt;= 1) {
 709         pop_f(xmm0);
 710       } else {
 711         pop_f();
 712       }
 713       break;
 714     case dtos:
 715       if (UseSSE &gt;= 2) {
 716         pop_d(xmm0);
 717       } else {
 718         pop_d();
 719       }
 720       break;
 721     case vtos: /* nothing to do */                           break;
 722     default  : ShouldNotReachHere();
 723   }
<span class="line-modified"> 724   verify_oop(rax, state);</span>
 725 }
 726 
 727 
 728 void InterpreterMacroAssembler::push_l(Register lo, Register hi) {
 729   push(hi);
 730   push(lo);
 731 }
 732 
 733 void InterpreterMacroAssembler::push_f() {
 734   // Do not schedule for no AGI! Never write beyond rsp!
 735   subptr(rsp, 1 * wordSize);
 736   fstp_s(Address(rsp, 0));
 737 }
 738 
 739 void InterpreterMacroAssembler::push_d() {
 740   // Do not schedule for no AGI! Never write beyond rsp!
 741   subptr(rsp, 2 * wordSize);
 742   fstp_d(Address(rsp, 0));
 743 }
 744 
 745 
 746 void InterpreterMacroAssembler::push(TosState state) {
<span class="line-modified"> 747   verify_oop(rax, state);</span>
 748   switch (state) {
 749     case atos: push_ptr(rax); break;
 750     case btos:                                               // fall through
 751     case ztos:                                               // fall through
 752     case ctos:                                               // fall through
 753     case stos:                                               // fall through
 754     case itos: push_i(rax);                                    break;
 755     case ltos: push_l(rax, rdx);                               break;
 756     case ftos:
 757       if (UseSSE &gt;= 1) {
 758         push_f(xmm0);
 759       } else {
 760         push_f();
 761       }
 762       break;
 763     case dtos:
 764       if (UseSSE &gt;= 2) {
 765         push_d(xmm0);
 766       } else {
 767         push_d();
</pre>
<hr />
<pre>
 826 }
 827 
 828 void InterpreterMacroAssembler::dispatch_base(TosState state,
 829                                               address* table,
 830                                               bool verifyoop,
 831                                               bool generate_poll) {
 832   verify_FPU(1, state);
 833   if (VerifyActivationFrameSize) {
 834     Label L;
 835     mov(rcx, rbp);
 836     subptr(rcx, rsp);
 837     int32_t min_frame_size =
 838       (frame::link_offset - frame::interpreter_frame_initial_sp_offset) *
 839       wordSize;
 840     cmpptr(rcx, (int32_t)min_frame_size);
 841     jcc(Assembler::greaterEqual, L);
 842     stop(&quot;broken stack frame&quot;);
 843     bind(L);
 844   }
 845   if (verifyoop) {
<span class="line-modified"> 846     verify_oop(rax, state);</span>
 847   }
 848 
 849   address* const safepoint_table = Interpreter::safept_table(state);
 850 #ifdef _LP64
 851   Label no_safepoint, dispatch;
 852   if (SafepointMechanism::uses_thread_local_poll() &amp;&amp; table != safepoint_table &amp;&amp; generate_poll) {
 853     NOT_PRODUCT(block_comment(&quot;Thread-local Safepoint poll&quot;));
 854     testb(Address(r15_thread, Thread::polling_page_offset()), SafepointMechanism::poll_bit());
 855 
 856     jccb(Assembler::zero, no_safepoint);
 857     lea(rscratch1, ExternalAddress((address)safepoint_table));
 858     jmpb(dispatch);
 859   }
 860 
 861   bind(no_safepoint);
 862   lea(rscratch1, ExternalAddress((address)table));
 863   bind(dispatch);
 864   jmp(Address(rscratch1, rbx, Address::times_8));
 865 
 866 #else
</pre>
<hr />
<pre>
1603 
1604     // If no method data exists, go to profile_continue.
1605     test_method_data_pointer(mdp, profile_continue);
1606 
1607     Label skip_receiver_profile;
1608     if (receiver_can_be_null) {
1609       Label not_null;
1610       testptr(receiver, receiver);
1611       jccb(Assembler::notZero, not_null);
1612       // We are making a call.  Increment the count for null receiver.
1613       increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));
1614       jmp(skip_receiver_profile);
1615       bind(not_null);
1616     }
1617 
1618     // Record the receiver type.
1619     record_klass_in_profile(receiver, mdp, reg2, true);
1620     bind(skip_receiver_profile);
1621 
1622     // The method data pointer needs to be updated to reflect the new target.
<span class="line-removed">1623 #if INCLUDE_JVMCI</span>
<span class="line-removed">1624     if (MethodProfileWidth == 0) {</span>
<span class="line-removed">1625       update_mdp_by_constant(mdp, in_bytes(VirtualCallData::virtual_call_data_size()));</span>
<span class="line-removed">1626     }</span>
<span class="line-removed">1627 #else // INCLUDE_JVMCI</span>
<span class="line-removed">1628     update_mdp_by_constant(mdp,</span>
<span class="line-removed">1629                            in_bytes(VirtualCallData::</span>
<span class="line-removed">1630                                     virtual_call_data_size()));</span>
<span class="line-removed">1631 #endif // INCLUDE_JVMCI</span>
<span class="line-removed">1632     bind(profile_continue);</span>
<span class="line-removed">1633   }</span>
<span class="line-removed">1634 }</span>
<span class="line-removed">1635 </span>
<span class="line-removed">1636 #if INCLUDE_JVMCI</span>
<span class="line-removed">1637 void InterpreterMacroAssembler::profile_called_method(Register method, Register mdp, Register reg2) {</span>
<span class="line-removed">1638   assert_different_registers(method, mdp, reg2);</span>
<span class="line-removed">1639   if (ProfileInterpreter &amp;&amp; MethodProfileWidth &gt; 0) {</span>
<span class="line-removed">1640     Label profile_continue;</span>
<span class="line-removed">1641 </span>
<span class="line-removed">1642     // If no method data exists, go to profile_continue.</span>
<span class="line-removed">1643     test_method_data_pointer(mdp, profile_continue);</span>
<span class="line-removed">1644 </span>
<span class="line-removed">1645     Label done;</span>
<span class="line-removed">1646     record_item_in_profile_helper(method, mdp, reg2, 0, done, MethodProfileWidth,</span>
<span class="line-removed">1647       &amp;VirtualCallData::method_offset, &amp;VirtualCallData::method_count_offset, in_bytes(VirtualCallData::nonprofiled_receiver_count_offset()));</span>
<span class="line-removed">1648     bind(done);</span>
<span class="line-removed">1649 </span>
1650     update_mdp_by_constant(mdp, in_bytes(VirtualCallData::virtual_call_data_size()));
1651     bind(profile_continue);
1652   }
1653 }
<span class="line-removed">1654 #endif // INCLUDE_JVMCI</span>
1655 
1656 // This routine creates a state machine for updating the multi-row
1657 // type profile at a virtual call site (or other type-sensitive bytecode).
1658 // The machine visits each row (of receiver/count) until the receiver type
1659 // is found, or until it runs out of rows.  At the same time, it remembers
1660 // the location of the first empty row.  (An empty row records null for its
1661 // receiver, and can be allocated for a newly-observed receiver type.)
1662 // Because there are two degrees of freedom in the state, a simple linear
1663 // search will not work; it must be a decision tree.  Hence this helper
1664 // function is recursive, to generate the required tree structured code.
1665 // It&#39;s the interpreter, so we are trading off code space for speed.
1666 // See below for example code.
1667 void InterpreterMacroAssembler::record_klass_in_profile_helper(
1668                                         Register receiver, Register mdp,
1669                                         Register reg2, int start_row,
1670                                         Label&amp; done, bool is_virtual_call) {
1671   if (TypeProfileWidth == 0) {
1672     if (is_virtual_call) {
1673       increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));
1674     }
</pre>
<hr />
<pre>
1941     imulptr(index, reg2); // XXX l ?
1942     addptr(index, in_bytes(MultiBranchData::case_array_offset())); // XXX l ?
1943 
1944     // Update the case count
1945     increment_mdp_data_at(mdp,
1946                           index,
1947                           in_bytes(MultiBranchData::relative_count_offset()));
1948 
1949     // The method data pointer needs to be updated.
1950     update_mdp_by_offset(mdp,
1951                          index,
1952                          in_bytes(MultiBranchData::
1953                                   relative_displacement_offset()));
1954 
1955     bind(profile_continue);
1956   }
1957 }
1958 
1959 
1960 
<span class="line-modified">1961 void InterpreterMacroAssembler::verify_oop(Register reg, TosState state) {</span>
1962   if (state == atos) {
<span class="line-modified">1963     MacroAssembler::verify_oop(reg);</span>
1964   }
1965 }
1966 
1967 void InterpreterMacroAssembler::verify_FPU(int stack_depth, TosState state) {
1968 #ifndef _LP64
1969   if ((state == ftos &amp;&amp; UseSSE &lt; 1) ||
1970       (state == dtos &amp;&amp; UseSSE &lt; 2)) {
1971     MacroAssembler::verify_FPU(stack_depth);
1972   }
1973 #endif
1974 }
1975 
1976 // Jump if ((*counter_addr += increment) &amp; mask) satisfies the condition.
1977 void InterpreterMacroAssembler::increment_mask_and_jump(Address counter_addr,
1978                                                         int increment, Address mask,
1979                                                         Register scratch, bool preloaded,
1980                                                         Condition cond, Label* where) {
1981   if (!preloaded) {
1982     movl(scratch, counter_addr);
1983   }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;interp_masm_x86.hpp&quot;
  27 #include &quot;interpreter/interpreter.hpp&quot;
  28 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  29 #include &quot;logging/log.hpp&quot;
  30 #include &quot;oops/arrayOop.hpp&quot;
  31 #include &quot;oops/markWord.hpp&quot;
  32 #include &quot;oops/methodData.hpp&quot;
  33 #include &quot;oops/method.hpp&quot;
  34 #include &quot;prims/jvmtiExport.hpp&quot;
  35 #include &quot;prims/jvmtiThreadState.hpp&quot;
  36 #include &quot;runtime/basicLock.hpp&quot;
  37 #include &quot;runtime/biasedLocking.hpp&quot;
  38 #include &quot;runtime/frame.inline.hpp&quot;
  39 #include &quot;runtime/safepointMechanism.hpp&quot;
  40 #include &quot;runtime/sharedRuntime.hpp&quot;
  41 #include &quot;runtime/thread.inline.hpp&quot;
<span class="line-added">  42 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  43 
  44 // Implementation of InterpreterMacroAssembler
  45 
  46 void InterpreterMacroAssembler::jump_to_entry(address entry) {
  47   assert(entry, &quot;Entry must have been generated by now&quot;);
  48   jump(RuntimeAddress(entry));
  49 }
  50 
  51 void InterpreterMacroAssembler::profile_obj_type(Register obj, const Address&amp; mdo_addr) {
  52   Label update, next, none;
  53 
<span class="line-modified">  54   interp_verify_oop(obj, atos);</span>
  55 
  56   testptr(obj, obj);
  57   jccb(Assembler::notZero, update);
  58   orptr(mdo_addr, TypeEntries::null_seen);
  59   jmpb(next);
  60 
  61   bind(update);
  62   load_klass(obj, obj);
  63 
  64   xorptr(obj, mdo_addr);
  65   testptr(obj, TypeEntries::type_klass_mask);
  66   jccb(Assembler::zero, next); // klass seen before, nothing to
  67                                // do. The unknown bit may have been
  68                                // set already but no need to check.
  69 
  70   testptr(obj, TypeEntries::type_unknown);
  71   jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
  72 
  73   cmpptr(mdo_addr, 0);
  74   jccb(Assembler::equal, none);
</pre>
<hr />
<pre>
 332     // Call Interpreter::remove_activation_preserving_args_entry() to get the
 333     // address of the same-named entrypoint in the generated interpreter code.
 334     call_VM_leaf(CAST_FROM_FN_PTR(address, Interpreter::remove_activation_preserving_args_entry));
 335     jmp(rax);
 336     bind(L);
 337     NOT_LP64(get_thread(java_thread);)
 338   }
 339 }
 340 
 341 void InterpreterMacroAssembler::load_earlyret_value(TosState state) {
 342   Register thread = LP64_ONLY(r15_thread) NOT_LP64(rcx);
 343   NOT_LP64(get_thread(thread);)
 344   movptr(rcx, Address(thread, JavaThread::jvmti_thread_state_offset()));
 345   const Address tos_addr(rcx, JvmtiThreadState::earlyret_tos_offset());
 346   const Address oop_addr(rcx, JvmtiThreadState::earlyret_oop_offset());
 347   const Address val_addr(rcx, JvmtiThreadState::earlyret_value_offset());
 348 #ifdef _LP64
 349   switch (state) {
 350     case atos: movptr(rax, oop_addr);
 351                movptr(oop_addr, (int32_t)NULL_WORD);
<span class="line-modified"> 352                interp_verify_oop(rax, state);         break;</span>
 353     case ltos: movptr(rax, val_addr);                 break;
 354     case btos:                                   // fall through
 355     case ztos:                                   // fall through
 356     case ctos:                                   // fall through
 357     case stos:                                   // fall through
 358     case itos: movl(rax, val_addr);                 break;
 359     case ftos: load_float(val_addr);                break;
 360     case dtos: load_double(val_addr);               break;
 361     case vtos: /* nothing to do */                  break;
 362     default  : ShouldNotReachHere();
 363   }
 364   // Clean up tos value in the thread object
 365   movl(tos_addr,  (int) ilgl);
 366   movl(val_addr,  (int32_t) NULL_WORD);
 367 #else
 368   const Address val_addr1(rcx, JvmtiThreadState::earlyret_value_offset()
 369                              + in_ByteSize(wordSize));
 370   switch (state) {
 371     case atos: movptr(rax, oop_addr);
 372                movptr(oop_addr, NULL_WORD);
<span class="line-modified"> 373                interp_verify_oop(rax, state);         break;</span>
 374     case ltos:
 375                movl(rdx, val_addr1);               // fall through
 376     case btos:                                     // fall through
 377     case ztos:                                     // fall through
 378     case ctos:                                     // fall through
 379     case stos:                                     // fall through
 380     case itos: movl(rax, val_addr);                   break;
 381     case ftos: load_float(val_addr);                  break;
 382     case dtos: load_double(val_addr);                 break;
 383     case vtos: /* nothing to do */                    break;
 384     default  : ShouldNotReachHere();
 385   }
 386 #endif // _LP64
 387   // Clean up tos value in the thread object
 388   movl(tos_addr,  (int32_t) ilgl);
 389   movptr(val_addr,  NULL_WORD);
 390   NOT_LP64(movptr(val_addr1, NULL_WORD);)
 391 }
 392 
 393 
</pre>
<hr />
<pre>
 639 void InterpreterMacroAssembler::push_l(Register r) {
 640   subptr(rsp, 2 * wordSize);
 641   movptr(Address(rsp, Interpreter::expr_offset_in_bytes(0)), r         );
 642   movptr(Address(rsp, Interpreter::expr_offset_in_bytes(1)), NULL_WORD );
 643 }
 644 
 645 void InterpreterMacroAssembler::pop(TosState state) {
 646   switch (state) {
 647   case atos: pop_ptr();                 break;
 648   case btos:
 649   case ztos:
 650   case ctos:
 651   case stos:
 652   case itos: pop_i();                   break;
 653   case ltos: pop_l();                   break;
 654   case ftos: pop_f(xmm0);               break;
 655   case dtos: pop_d(xmm0);               break;
 656   case vtos: /* nothing to do */        break;
 657   default:   ShouldNotReachHere();
 658   }
<span class="line-modified"> 659   interp_verify_oop(rax, state);</span>
 660 }
 661 
 662 void InterpreterMacroAssembler::push(TosState state) {
<span class="line-modified"> 663   interp_verify_oop(rax, state);</span>
 664   switch (state) {
 665   case atos: push_ptr();                break;
 666   case btos:
 667   case ztos:
 668   case ctos:
 669   case stos:
 670   case itos: push_i();                  break;
 671   case ltos: push_l();                  break;
 672   case ftos: push_f(xmm0);              break;
 673   case dtos: push_d(xmm0);              break;
 674   case vtos: /* nothing to do */        break;
 675   default  : ShouldNotReachHere();
 676   }
 677 }
 678 #else
 679 void InterpreterMacroAssembler::pop_i(Register r) {
 680   pop(r);
 681 }
 682 
 683 void InterpreterMacroAssembler::pop_l(Register lo, Register hi) {
</pre>
<hr />
<pre>
 705     case stos:                                               // fall through
 706     case itos: pop_i(rax);                                   break;
 707     case ltos: pop_l(rax, rdx);                              break;
 708     case ftos:
 709       if (UseSSE &gt;= 1) {
 710         pop_f(xmm0);
 711       } else {
 712         pop_f();
 713       }
 714       break;
 715     case dtos:
 716       if (UseSSE &gt;= 2) {
 717         pop_d(xmm0);
 718       } else {
 719         pop_d();
 720       }
 721       break;
 722     case vtos: /* nothing to do */                           break;
 723     default  : ShouldNotReachHere();
 724   }
<span class="line-modified"> 725   interp_verify_oop(rax, state);</span>
 726 }
 727 
 728 
 729 void InterpreterMacroAssembler::push_l(Register lo, Register hi) {
 730   push(hi);
 731   push(lo);
 732 }
 733 
 734 void InterpreterMacroAssembler::push_f() {
 735   // Do not schedule for no AGI! Never write beyond rsp!
 736   subptr(rsp, 1 * wordSize);
 737   fstp_s(Address(rsp, 0));
 738 }
 739 
 740 void InterpreterMacroAssembler::push_d() {
 741   // Do not schedule for no AGI! Never write beyond rsp!
 742   subptr(rsp, 2 * wordSize);
 743   fstp_d(Address(rsp, 0));
 744 }
 745 
 746 
 747 void InterpreterMacroAssembler::push(TosState state) {
<span class="line-modified"> 748   interp_verify_oop(rax, state);</span>
 749   switch (state) {
 750     case atos: push_ptr(rax); break;
 751     case btos:                                               // fall through
 752     case ztos:                                               // fall through
 753     case ctos:                                               // fall through
 754     case stos:                                               // fall through
 755     case itos: push_i(rax);                                    break;
 756     case ltos: push_l(rax, rdx);                               break;
 757     case ftos:
 758       if (UseSSE &gt;= 1) {
 759         push_f(xmm0);
 760       } else {
 761         push_f();
 762       }
 763       break;
 764     case dtos:
 765       if (UseSSE &gt;= 2) {
 766         push_d(xmm0);
 767       } else {
 768         push_d();
</pre>
<hr />
<pre>
 827 }
 828 
 829 void InterpreterMacroAssembler::dispatch_base(TosState state,
 830                                               address* table,
 831                                               bool verifyoop,
 832                                               bool generate_poll) {
 833   verify_FPU(1, state);
 834   if (VerifyActivationFrameSize) {
 835     Label L;
 836     mov(rcx, rbp);
 837     subptr(rcx, rsp);
 838     int32_t min_frame_size =
 839       (frame::link_offset - frame::interpreter_frame_initial_sp_offset) *
 840       wordSize;
 841     cmpptr(rcx, (int32_t)min_frame_size);
 842     jcc(Assembler::greaterEqual, L);
 843     stop(&quot;broken stack frame&quot;);
 844     bind(L);
 845   }
 846   if (verifyoop) {
<span class="line-modified"> 847     interp_verify_oop(rax, state);</span>
 848   }
 849 
 850   address* const safepoint_table = Interpreter::safept_table(state);
 851 #ifdef _LP64
 852   Label no_safepoint, dispatch;
 853   if (SafepointMechanism::uses_thread_local_poll() &amp;&amp; table != safepoint_table &amp;&amp; generate_poll) {
 854     NOT_PRODUCT(block_comment(&quot;Thread-local Safepoint poll&quot;));
 855     testb(Address(r15_thread, Thread::polling_page_offset()), SafepointMechanism::poll_bit());
 856 
 857     jccb(Assembler::zero, no_safepoint);
 858     lea(rscratch1, ExternalAddress((address)safepoint_table));
 859     jmpb(dispatch);
 860   }
 861 
 862   bind(no_safepoint);
 863   lea(rscratch1, ExternalAddress((address)table));
 864   bind(dispatch);
 865   jmp(Address(rscratch1, rbx, Address::times_8));
 866 
 867 #else
</pre>
<hr />
<pre>
1604 
1605     // If no method data exists, go to profile_continue.
1606     test_method_data_pointer(mdp, profile_continue);
1607 
1608     Label skip_receiver_profile;
1609     if (receiver_can_be_null) {
1610       Label not_null;
1611       testptr(receiver, receiver);
1612       jccb(Assembler::notZero, not_null);
1613       // We are making a call.  Increment the count for null receiver.
1614       increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));
1615       jmp(skip_receiver_profile);
1616       bind(not_null);
1617     }
1618 
1619     // Record the receiver type.
1620     record_klass_in_profile(receiver, mdp, reg2, true);
1621     bind(skip_receiver_profile);
1622 
1623     // The method data pointer needs to be updated to reflect the new target.



























1624     update_mdp_by_constant(mdp, in_bytes(VirtualCallData::virtual_call_data_size()));
1625     bind(profile_continue);
1626   }
1627 }

1628 
1629 // This routine creates a state machine for updating the multi-row
1630 // type profile at a virtual call site (or other type-sensitive bytecode).
1631 // The machine visits each row (of receiver/count) until the receiver type
1632 // is found, or until it runs out of rows.  At the same time, it remembers
1633 // the location of the first empty row.  (An empty row records null for its
1634 // receiver, and can be allocated for a newly-observed receiver type.)
1635 // Because there are two degrees of freedom in the state, a simple linear
1636 // search will not work; it must be a decision tree.  Hence this helper
1637 // function is recursive, to generate the required tree structured code.
1638 // It&#39;s the interpreter, so we are trading off code space for speed.
1639 // See below for example code.
1640 void InterpreterMacroAssembler::record_klass_in_profile_helper(
1641                                         Register receiver, Register mdp,
1642                                         Register reg2, int start_row,
1643                                         Label&amp; done, bool is_virtual_call) {
1644   if (TypeProfileWidth == 0) {
1645     if (is_virtual_call) {
1646       increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));
1647     }
</pre>
<hr />
<pre>
1914     imulptr(index, reg2); // XXX l ?
1915     addptr(index, in_bytes(MultiBranchData::case_array_offset())); // XXX l ?
1916 
1917     // Update the case count
1918     increment_mdp_data_at(mdp,
1919                           index,
1920                           in_bytes(MultiBranchData::relative_count_offset()));
1921 
1922     // The method data pointer needs to be updated.
1923     update_mdp_by_offset(mdp,
1924                          index,
1925                          in_bytes(MultiBranchData::
1926                                   relative_displacement_offset()));
1927 
1928     bind(profile_continue);
1929   }
1930 }
1931 
1932 
1933 
<span class="line-modified">1934 void InterpreterMacroAssembler::_interp_verify_oop(Register reg, TosState state, const char* file, int line) {</span>
1935   if (state == atos) {
<span class="line-modified">1936     MacroAssembler::_verify_oop(reg, &quot;broken oop&quot;, file, line);</span>
1937   }
1938 }
1939 
1940 void InterpreterMacroAssembler::verify_FPU(int stack_depth, TosState state) {
1941 #ifndef _LP64
1942   if ((state == ftos &amp;&amp; UseSSE &lt; 1) ||
1943       (state == dtos &amp;&amp; UseSSE &lt; 2)) {
1944     MacroAssembler::verify_FPU(stack_depth);
1945   }
1946 #endif
1947 }
1948 
1949 // Jump if ((*counter_addr += increment) &amp; mask) satisfies the condition.
1950 void InterpreterMacroAssembler::increment_mask_and_jump(Address counter_addr,
1951                                                         int increment, Address mask,
1952                                                         Register scratch, bool preloaded,
1953                                                         Condition cond, Label* where) {
1954   if (!preloaded) {
1955     movl(scratch, counter_addr);
1956   }
</pre>
</td>
</tr>
</table>
<center><a href="globals_x86.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interp_masm_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
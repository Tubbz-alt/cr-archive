<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/c2/shenandoahBarrierSetC2.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../c1/shenandoahBarrierSetC1.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahSupport.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/c2/shenandoahBarrierSetC2.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 799           Compile::current()-&gt;dependencies()-&gt;assert_leaf_type(ik);
 800         }
 801       }
 802     } else {
 803       return true;
 804         }
 805   } else if (src_type-&gt;isa_aryptr()) {
 806     BasicType src_elem  = src_type-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
 807     if (is_reference_type(src_elem)) {
 808       return true;
 809     }
 810   } else {
 811     return true;
 812   }
 813   return false;
 814 }
 815 
 816 void ShenandoahBarrierSetC2::clone_at_expansion(PhaseMacroExpand* phase, ArrayCopyNode* ac) const {
 817   Node* ctrl = ac-&gt;in(TypeFunc::Control);
 818   Node* mem = ac-&gt;in(TypeFunc::Memory);
<span class="line-modified"> 819   Node* src = ac-&gt;in(ArrayCopyNode::Src);</span>
 820   Node* src_offset = ac-&gt;in(ArrayCopyNode::SrcPos);
<span class="line-modified"> 821   Node* dest = ac-&gt;in(ArrayCopyNode::Dest);</span>
 822   Node* dest_offset = ac-&gt;in(ArrayCopyNode::DestPos);
 823   Node* length = ac-&gt;in(ArrayCopyNode::Length);
<span class="line-modified"> 824   assert (src_offset == NULL &amp;&amp; dest_offset == NULL, &quot;for clone offsets should be null&quot;);</span>
<span class="line-modified"> 825   assert (src-&gt;is_AddP(), &quot;for clone the src should be the interior ptr&quot;);</span>
<span class="line-modified"> 826   assert (dest-&gt;is_AddP(), &quot;for clone the dst should be the interior ptr&quot;);</span>
 827 
 828   if (ShenandoahCloneBarrier &amp;&amp; clone_needs_barrier(src, phase-&gt;igvn())) {
 829     // Check if heap is has forwarded objects. If it does, we need to call into the special
 830     // routine that would fix up source references before we can continue.
 831 
 832     enum { _heap_stable = 1, _heap_unstable, PATH_LIMIT };
 833     Node* region = new RegionNode(PATH_LIMIT);
 834     Node* mem_phi = new PhiNode(region, Type::MEMORY, TypeRawPtr::BOTTOM);
 835 
 836     Node* thread = phase-&gt;transform_later(new ThreadLocalNode());
 837     Node* offset = phase-&gt;igvn().MakeConX(in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
 838     Node* gc_state_addr = phase-&gt;transform_later(new AddPNode(phase-&gt;C-&gt;top(), thread, offset));
 839 
 840     uint gc_state_idx = Compile::AliasIdxRaw;
 841     const TypePtr* gc_state_adr_type = NULL; // debug-mode-only argument
 842     debug_only(gc_state_adr_type = phase-&gt;C-&gt;get_adr_type(gc_state_idx));
 843 
 844     Node* gc_state    = phase-&gt;transform_later(new LoadBNode(ctrl, mem, gc_state_addr, gc_state_adr_type, TypeInt::BYTE, MemNode::unordered));
 845     Node* stable_and  = phase-&gt;transform_later(new AndINode(gc_state, phase-&gt;igvn().intcon(ShenandoahHeap::HAS_FORWARDED)));
 846     Node* stable_cmp  = phase-&gt;transform_later(new CmpINode(stable_and, phase-&gt;igvn().zerocon(T_INT)));
 847     Node* stable_test = phase-&gt;transform_later(new BoolNode(stable_cmp, BoolTest::ne));
 848 
 849     IfNode* stable_iff  = phase-&gt;transform_later(new IfNode(ctrl, stable_test, PROB_UNLIKELY(0.999), COUNT_UNKNOWN))-&gt;as_If();
 850     Node* stable_ctrl   = phase-&gt;transform_later(new IfFalseNode(stable_iff));
 851     Node* unstable_ctrl = phase-&gt;transform_later(new IfTrueNode(stable_iff));
 852 
 853     // Heap is stable, no need to do anything additional
 854     region-&gt;init_req(_heap_stable, stable_ctrl);
 855     mem_phi-&gt;init_req(_heap_stable, mem);
 856 
 857     // Heap is unstable, call into clone barrier stub
 858     Node* call = phase-&gt;make_leaf_call(unstable_ctrl, mem,
 859                     ShenandoahBarrierSetC2::shenandoah_clone_barrier_Type(),
 860                     CAST_FROM_FN_PTR(address, ShenandoahRuntime::shenandoah_clone_barrier),
 861                     &quot;shenandoah_clone&quot;,
 862                     TypeRawPtr::BOTTOM,
<span class="line-modified"> 863                     src-&gt;in(AddPNode::Base));</span>
 864     call = phase-&gt;transform_later(call);
 865 
 866     ctrl = phase-&gt;transform_later(new ProjNode(call, TypeFunc::Control));
 867     mem = phase-&gt;transform_later(new ProjNode(call, TypeFunc::Memory));
 868     region-&gt;init_req(_heap_unstable, ctrl);
 869     mem_phi-&gt;init_req(_heap_unstable, mem);
 870 
 871     // Wire up the actual arraycopy stub now
 872     ctrl = phase-&gt;transform_later(region);
 873     mem = phase-&gt;transform_later(mem_phi);
 874 
 875     const char* name = &quot;arraycopy&quot;;
 876     call = phase-&gt;make_leaf_call(ctrl, mem,
 877                                  OptoRuntime::fast_arraycopy_Type(),
 878                                  phase-&gt;basictype2arraycopy(T_LONG, NULL, NULL, true, name, true),
 879                                  name, TypeRawPtr::BOTTOM,
 880                                  src, dest, length
 881                                  LP64_ONLY(COMMA phase-&gt;top()));
 882     call = phase-&gt;transform_later(call);
 883 
</pre>
</td>
<td>
<hr />
<pre>
 799           Compile::current()-&gt;dependencies()-&gt;assert_leaf_type(ik);
 800         }
 801       }
 802     } else {
 803       return true;
 804         }
 805   } else if (src_type-&gt;isa_aryptr()) {
 806     BasicType src_elem  = src_type-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
 807     if (is_reference_type(src_elem)) {
 808       return true;
 809     }
 810   } else {
 811     return true;
 812   }
 813   return false;
 814 }
 815 
 816 void ShenandoahBarrierSetC2::clone_at_expansion(PhaseMacroExpand* phase, ArrayCopyNode* ac) const {
 817   Node* ctrl = ac-&gt;in(TypeFunc::Control);
 818   Node* mem = ac-&gt;in(TypeFunc::Memory);
<span class="line-modified"> 819   Node* src_base = ac-&gt;in(ArrayCopyNode::Src);</span>
 820   Node* src_offset = ac-&gt;in(ArrayCopyNode::SrcPos);
<span class="line-modified"> 821   Node* dest_base = ac-&gt;in(ArrayCopyNode::Dest);</span>
 822   Node* dest_offset = ac-&gt;in(ArrayCopyNode::DestPos);
 823   Node* length = ac-&gt;in(ArrayCopyNode::Length);
<span class="line-modified"> 824 </span>
<span class="line-modified"> 825   Node* src = phase-&gt;basic_plus_adr(src_base, src_offset);</span>
<span class="line-modified"> 826   Node* dest = phase-&gt;basic_plus_adr(dest_base, dest_offset);</span>
 827 
 828   if (ShenandoahCloneBarrier &amp;&amp; clone_needs_barrier(src, phase-&gt;igvn())) {
 829     // Check if heap is has forwarded objects. If it does, we need to call into the special
 830     // routine that would fix up source references before we can continue.
 831 
 832     enum { _heap_stable = 1, _heap_unstable, PATH_LIMIT };
 833     Node* region = new RegionNode(PATH_LIMIT);
 834     Node* mem_phi = new PhiNode(region, Type::MEMORY, TypeRawPtr::BOTTOM);
 835 
 836     Node* thread = phase-&gt;transform_later(new ThreadLocalNode());
 837     Node* offset = phase-&gt;igvn().MakeConX(in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
 838     Node* gc_state_addr = phase-&gt;transform_later(new AddPNode(phase-&gt;C-&gt;top(), thread, offset));
 839 
 840     uint gc_state_idx = Compile::AliasIdxRaw;
 841     const TypePtr* gc_state_adr_type = NULL; // debug-mode-only argument
 842     debug_only(gc_state_adr_type = phase-&gt;C-&gt;get_adr_type(gc_state_idx));
 843 
 844     Node* gc_state    = phase-&gt;transform_later(new LoadBNode(ctrl, mem, gc_state_addr, gc_state_adr_type, TypeInt::BYTE, MemNode::unordered));
 845     Node* stable_and  = phase-&gt;transform_later(new AndINode(gc_state, phase-&gt;igvn().intcon(ShenandoahHeap::HAS_FORWARDED)));
 846     Node* stable_cmp  = phase-&gt;transform_later(new CmpINode(stable_and, phase-&gt;igvn().zerocon(T_INT)));
 847     Node* stable_test = phase-&gt;transform_later(new BoolNode(stable_cmp, BoolTest::ne));
 848 
 849     IfNode* stable_iff  = phase-&gt;transform_later(new IfNode(ctrl, stable_test, PROB_UNLIKELY(0.999), COUNT_UNKNOWN))-&gt;as_If();
 850     Node* stable_ctrl   = phase-&gt;transform_later(new IfFalseNode(stable_iff));
 851     Node* unstable_ctrl = phase-&gt;transform_later(new IfTrueNode(stable_iff));
 852 
 853     // Heap is stable, no need to do anything additional
 854     region-&gt;init_req(_heap_stable, stable_ctrl);
 855     mem_phi-&gt;init_req(_heap_stable, mem);
 856 
 857     // Heap is unstable, call into clone barrier stub
 858     Node* call = phase-&gt;make_leaf_call(unstable_ctrl, mem,
 859                     ShenandoahBarrierSetC2::shenandoah_clone_barrier_Type(),
 860                     CAST_FROM_FN_PTR(address, ShenandoahRuntime::shenandoah_clone_barrier),
 861                     &quot;shenandoah_clone&quot;,
 862                     TypeRawPtr::BOTTOM,
<span class="line-modified"> 863                     src_base);</span>
 864     call = phase-&gt;transform_later(call);
 865 
 866     ctrl = phase-&gt;transform_later(new ProjNode(call, TypeFunc::Control));
 867     mem = phase-&gt;transform_later(new ProjNode(call, TypeFunc::Memory));
 868     region-&gt;init_req(_heap_unstable, ctrl);
 869     mem_phi-&gt;init_req(_heap_unstable, mem);
 870 
 871     // Wire up the actual arraycopy stub now
 872     ctrl = phase-&gt;transform_later(region);
 873     mem = phase-&gt;transform_later(mem_phi);
 874 
 875     const char* name = &quot;arraycopy&quot;;
 876     call = phase-&gt;make_leaf_call(ctrl, mem,
 877                                  OptoRuntime::fast_arraycopy_Type(),
 878                                  phase-&gt;basictype2arraycopy(T_LONG, NULL, NULL, true, name, true),
 879                                  name, TypeRawPtr::BOTTOM,
 880                                  src, dest, length
 881                                  LP64_ONLY(COMMA phase-&gt;top()));
 882     call = phase-&gt;transform_later(call);
 883 
</pre>
</td>
</tr>
</table>
<center><a href="../c1/shenandoahBarrierSetC1.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahSupport.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
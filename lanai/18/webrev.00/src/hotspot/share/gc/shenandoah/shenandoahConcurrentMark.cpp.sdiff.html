<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahConcurrentMark.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahCollectionSet.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahControlThread.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahConcurrentMark.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 
 27 #include &quot;classfile/symbolTable.hpp&quot;
 28 #include &quot;classfile/systemDictionary.hpp&quot;
 29 #include &quot;code/codeCache.hpp&quot;
 30 
 31 #include &quot;gc/shared/weakProcessor.inline.hpp&quot;
 32 #include &quot;gc/shared/gcTimer.hpp&quot;
 33 #include &quot;gc/shared/referenceProcessor.hpp&quot;
 34 #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
 35 #include &quot;gc/shared/strongRootsScope.hpp&quot;
 36 
 37 #include &quot;gc/shenandoah/shenandoahBarrierSet.inline.hpp&quot;
 38 #include &quot;gc/shenandoah/shenandoahClosures.inline.hpp&quot;
 39 #include &quot;gc/shenandoah/shenandoahConcurrentMark.inline.hpp&quot;
 40 #include &quot;gc/shenandoah/shenandoahMarkCompact.hpp&quot;
 41 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 42 #include &quot;gc/shenandoah/shenandoahRootProcessor.inline.hpp&quot;
 43 #include &quot;gc/shenandoah/shenandoahOopClosures.inline.hpp&quot;

 44 #include &quot;gc/shenandoah/shenandoahTaskqueue.inline.hpp&quot;
<span class="line-removed"> 45 #include &quot;gc/shenandoah/shenandoahTimingTracker.hpp&quot;</span>
 46 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
 47 
 48 #include &quot;memory/iterator.inline.hpp&quot;
 49 #include &quot;memory/metaspace.hpp&quot;
 50 #include &quot;memory/resourceArea.hpp&quot;
 51 #include &quot;oops/oop.inline.hpp&quot;
 52 #include &quot;runtime/handles.inline.hpp&quot;
 53 
 54 template&lt;UpdateRefsMode UPDATE_REFS&gt;
 55 class ShenandoahInitMarkRootsClosure : public OopClosure {
 56 private:
 57   ShenandoahObjToScanQueue* _queue;
 58   ShenandoahHeap* _heap;
 59   ShenandoahMarkingContext* const _mark_context;
 60 
 61   template &lt;class T&gt;
 62   inline void do_oop_work(T* p) {
 63     ShenandoahConcurrentMark::mark_through_ref&lt;T, UPDATE_REFS, NO_DEDUP&gt;(p, _heap, _queue, _mark_context);
 64   }
 65 
</pre>
<hr />
<pre>
 67   ShenandoahInitMarkRootsClosure(ShenandoahObjToScanQueue* q) :
 68     _queue(q),
 69     _heap(ShenandoahHeap::heap()),
 70     _mark_context(_heap-&gt;marking_context()) {};
 71 
 72   void do_oop(narrowOop* p) { do_oop_work(p); }
 73   void do_oop(oop* p)       { do_oop_work(p); }
 74 };
 75 
 76 ShenandoahMarkRefsSuperClosure::ShenandoahMarkRefsSuperClosure(ShenandoahObjToScanQueue* q, ReferenceProcessor* rp) :
 77   MetadataVisitingOopIterateClosure(rp),
 78   _queue(q),
 79   _heap(ShenandoahHeap::heap()),
 80   _mark_context(_heap-&gt;marking_context())
 81 { }
 82 
 83 template&lt;UpdateRefsMode UPDATE_REFS&gt;
 84 class ShenandoahInitMarkRootsTask : public AbstractGangTask {
 85 private:
 86   ShenandoahAllRootScanner* _rp;
<span class="line-removed"> 87   bool _process_refs;</span>
 88 public:
<span class="line-modified"> 89   ShenandoahInitMarkRootsTask(ShenandoahAllRootScanner* rp, bool process_refs) :</span>
 90     AbstractGangTask(&quot;Shenandoah init mark roots task&quot;),
<span class="line-modified"> 91     _rp(rp),</span>
<span class="line-removed"> 92     _process_refs(process_refs) {</span>
 93   }
 94 
 95   void work(uint worker_id) {
 96     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
 97     ShenandoahParallelWorkerSession worker_session(worker_id);
 98 
 99     ShenandoahHeap* heap = ShenandoahHeap::heap();
100     ShenandoahObjToScanQueueSet* queues = heap-&gt;concurrent_mark()-&gt;task_queues();
101     assert(queues-&gt;get_reserved() &gt; worker_id, &quot;Queue has not been reserved for worker id: %d&quot;, worker_id);
102 
103     ShenandoahObjToScanQueue* q = queues-&gt;queue(worker_id);
104 
105     ShenandoahInitMarkRootsClosure&lt;UPDATE_REFS&gt; mark_cl(q);
106     do_work(heap, &amp;mark_cl, worker_id);
107   }
108 
109 private:
110   void do_work(ShenandoahHeap* heap, OopClosure* oops, uint worker_id) {
111     // The rationale for selecting the roots to scan is as follows:
112     //   a. With unload_classes = true, we only want to scan the actual strong roots from the
</pre>
<hr />
<pre>
165   void work(uint worker_id) {
166     ShenandoahHeap* heap = ShenandoahHeap::heap();
167     ShenandoahConcurrentWorkerSession worker_session(worker_id);
168     ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);
169     ShenandoahObjToScanQueue* q = _cm-&gt;get_queue(worker_id);
170     ReferenceProcessor* rp;
171     if (heap-&gt;process_references()) {
172       rp = heap-&gt;ref_processor();
173       shenandoah_assert_rp_isalive_installed();
174     } else {
175       rp = NULL;
176     }
177 
178     _cm-&gt;concurrent_scan_code_roots(worker_id, rp);
179     _cm-&gt;mark_loop(worker_id, _terminator, rp,
180                    true, // cancellable
181                    ShenandoahStringDedup::is_enabled()); // perform string dedup
182   }
183 };
184 
<span class="line-modified">185 class ShenandoahSATBThreadsClosure : public ThreadClosure {</span>
186 private:
187   ShenandoahSATBBufferClosure* _satb_cl;

188   uintx _claim_token;
189 
190 public:
<span class="line-modified">191   ShenandoahSATBThreadsClosure(ShenandoahSATBBufferClosure* satb_cl) :</span>
<span class="line-modified">192     _satb_cl(satb_cl),</span>
193     _claim_token(Threads::thread_claim_token()) {}
194 
195   void do_thread(Thread* thread) {
196     if (thread-&gt;claim_threads_do(true, _claim_token)) {
197       ShenandoahThreadLocalData::satb_mark_queue(thread).apply_closure_and_empty(_satb_cl);










198     }
199   }
200 };
201 
202 class ShenandoahFinalMarkingTask : public AbstractGangTask {
203 private:
204   ShenandoahConcurrentMark* _cm;
205   TaskTerminator*           _terminator;
206   bool _dedup_string;
207 
208 public:
209   ShenandoahFinalMarkingTask(ShenandoahConcurrentMark* cm, TaskTerminator* terminator, bool dedup_string) :
210     AbstractGangTask(&quot;Shenandoah Final Marking&quot;), _cm(cm), _terminator(terminator), _dedup_string(dedup_string) {
211   }
212 
213   void work(uint worker_id) {
214     ShenandoahHeap* heap = ShenandoahHeap::heap();
215 
216     ShenandoahParallelWorkerSession worker_session(worker_id);








217     // First drain remaining SATB buffers.
218     // Notice that this is not strictly necessary for mark-compact. But since
219     // it requires a StrongRootsScope around the task, we need to claim the
220     // threads, and performance-wise it doesn&#39;t really matter. Adds about 1ms to
221     // full-gc.
222     {
223       ShenandoahObjToScanQueue* q = _cm-&gt;get_queue(worker_id);

224       ShenandoahSATBBufferClosure cl(q);
225       SATBMarkQueueSet&amp; satb_mq_set = ShenandoahBarrierSet::satb_mark_queue_set();
226       while (satb_mq_set.apply_closure_to_completed_buffer(&amp;cl));
<span class="line-removed">227       ShenandoahSATBThreadsClosure tc(&amp;cl);</span>
<span class="line-removed">228       Threads::threads_do(&amp;tc);</span>
<span class="line-removed">229     }</span>
230 
<span class="line-modified">231     ReferenceProcessor* rp;</span>
<span class="line-modified">232     if (heap-&gt;process_references()) {</span>
<span class="line-modified">233       rp = heap-&gt;ref_processor();</span>
<span class="line-modified">234       shenandoah_assert_rp_isalive_installed();</span>
<span class="line-modified">235     } else {</span>
<span class="line-modified">236       rp = NULL;</span>










237     }
238 
239     if (heap-&gt;is_degenerated_gc_in_progress()) {
240       // Degenerated cycle may bypass concurrent cycle, so code roots might not be scanned,
241       // let&#39;s check here.
242       _cm-&gt;concurrent_scan_code_roots(worker_id, rp);
243     }
244 
245     _cm-&gt;mark_loop(worker_id, _terminator, rp,
246                    false, // not cancellable
247                    _dedup_string);
248 
249     assert(_cm-&gt;task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
250   }
251 };
252 
253 void ShenandoahConcurrentMark::mark_roots(ShenandoahPhaseTimings::Phase root_phase) {
254   assert(Thread::current()-&gt;is_VM_thread(), &quot;can only do this in VMThread&quot;);
255   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
256 
257   ShenandoahHeap* heap = ShenandoahHeap::heap();
258 
259   ShenandoahGCPhase phase(root_phase);
260 
261   WorkGang* workers = heap-&gt;workers();
262   uint nworkers = workers-&gt;active_workers();
263 
264   assert(nworkers &lt;= task_queues()-&gt;size(), &quot;Just check&quot;);
265 
266   ShenandoahAllRootScanner root_proc(nworkers, root_phase);
267   TASKQUEUE_STATS_ONLY(task_queues()-&gt;reset_taskqueue_stats());
268   task_queues()-&gt;reserve(nworkers);
269 
270   if (heap-&gt;has_forwarded_objects()) {
<span class="line-modified">271     ShenandoahInitMarkRootsTask&lt;RESOLVE&gt; mark_roots(&amp;root_proc, _heap-&gt;process_references());</span>
272     workers-&gt;run_task(&amp;mark_roots);
273   } else {
274     // No need to update references, which means the heap is stable.
275     // Can save time not walking through forwarding pointers.
<span class="line-modified">276     ShenandoahInitMarkRootsTask&lt;NONE&gt; mark_roots(&amp;root_proc, _heap-&gt;process_references());</span>
277     workers-&gt;run_task(&amp;mark_roots);
278   }
279 
280   if (ShenandoahConcurrentScanCodeRoots) {
281     clear_claim_codecache();
282   }
283 }
284 
285 void ShenandoahConcurrentMark::update_roots(ShenandoahPhaseTimings::Phase root_phase) {
286   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
287   assert(root_phase == ShenandoahPhaseTimings::full_gc_roots ||
288          root_phase == ShenandoahPhaseTimings::degen_gc_update_roots,
289          &quot;Only for these phases&quot;);
290 
291   ShenandoahGCPhase phase(root_phase);
292 
293   bool check_alive = root_phase == ShenandoahPhaseTimings::degen_gc_update_roots;
294 
295 #if COMPILER2_OR_JVMCI
296   DerivedPointerTable::clear();
297 #endif
298 
299   uint nworkers = _heap-&gt;workers()-&gt;active_workers();
300 
301   ShenandoahRootUpdater root_updater(nworkers, root_phase);
302   ShenandoahUpdateRootsTask update_roots(&amp;root_updater, check_alive);
303   _heap-&gt;workers()-&gt;run_task(&amp;update_roots);
304 
305 #if COMPILER2_OR_JVMCI
306   DerivedPointerTable::update_pointers();
307 #endif
308 }
309 
310 class ShenandoahUpdateThreadRootsTask : public AbstractGangTask {
311 private:
312   ShenandoahThreadRoots           _thread_roots;
313   ShenandoahPhaseTimings::Phase   _phase;

314 public:
315   ShenandoahUpdateThreadRootsTask(bool is_par, ShenandoahPhaseTimings::Phase phase) :
316     AbstractGangTask(&quot;Shenandoah Update Thread Roots&quot;),
317     _thread_roots(is_par),
<span class="line-modified">318     _phase(phase) {</span>
<span class="line-modified">319     ShenandoahHeap::heap()-&gt;phase_timings()-&gt;record_workers_start(_phase);</span>
<span class="line-removed">320   }</span>
321 
<span class="line-removed">322   ~ShenandoahUpdateThreadRootsTask() {</span>
<span class="line-removed">323     ShenandoahHeap::heap()-&gt;phase_timings()-&gt;record_workers_end(_phase);</span>
<span class="line-removed">324   }</span>
325   void work(uint worker_id) {
326     ShenandoahUpdateRefsClosure cl;
327     _thread_roots.oops_do(&amp;cl, NULL, worker_id);
328   }
329 };
330 
331 void ShenandoahConcurrentMark::update_thread_roots(ShenandoahPhaseTimings::Phase root_phase) {
332   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
333 
334   ShenandoahGCPhase phase(root_phase);
335 
336 #if COMPILER2_OR_JVMCI
337   DerivedPointerTable::clear();
338 #endif
339 
340   WorkGang* workers = _heap-&gt;workers();
341   bool is_par = workers-&gt;active_workers() &gt; 1;
342 
343   ShenandoahUpdateThreadRootsTask task(is_par, root_phase);
344   workers-&gt;run_task(&amp;task);
</pre>
<hr />
<pre>
387   uint nworkers = workers-&gt;active_workers();
388 
389   ShenandoahGCPhase conc_mark_phase(ShenandoahPhaseTimings::conc_mark);
390 
391   if (_heap-&gt;process_references()) {
392     ReferenceProcessor* rp = _heap-&gt;ref_processor();
393     rp-&gt;set_active_mt_degree(nworkers);
394 
395     // enable (&quot;weak&quot;) refs discovery
396     rp-&gt;enable_discovery(true /*verify_no_refs*/);
397     rp-&gt;setup_policy(_heap-&gt;soft_ref_policy()-&gt;should_clear_all_soft_refs());
398   }
399 
400   shenandoah_assert_rp_isalive_not_installed();
401   ShenandoahIsAliveSelector is_alive;
402   ReferenceProcessorIsAliveMutator fix_isalive(_heap-&gt;ref_processor(), is_alive.is_alive_closure());
403 
404   task_queues()-&gt;reserve(nworkers);
405 
406   {
<span class="line-removed">407     ShenandoahTerminationTracker term(ShenandoahPhaseTimings::conc_termination);</span>
408     TaskTerminator terminator(nworkers, task_queues());
409     ShenandoahConcurrentMarkingTask task(this, &amp;terminator);
410     workers-&gt;run_task(&amp;task);
411   }
412 
413   assert(task_queues()-&gt;is_empty() || _heap-&gt;cancelled_gc(), &quot;Should be empty when not cancelled&quot;);
414 }
415 
416 void ShenandoahConcurrentMark::finish_mark_from_roots(bool full_gc) {
417   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
418 
419   uint nworkers = _heap-&gt;workers()-&gt;active_workers();
420 
421   // Finally mark everything else we&#39;ve got in our queues during the previous steps.
422   // It does two different things for concurrent vs. mark-compact GC:
423   // - For concurrent GC, it starts with empty task queues, drains the remaining
424   //   SATB buffers, and then completes the marking closure.
425   // - For mark-compact GC, it starts out with the task queues seeded by initial
426   //   root scan, and completes the closure, thus marking through all live objects
427   // The implementation is the same, so it&#39;s shared here.
428   {
429     ShenandoahGCPhase phase(full_gc ?
430                             ShenandoahPhaseTimings::full_gc_mark_finish_queues :
431                             ShenandoahPhaseTimings::finish_queues);
432     task_queues()-&gt;reserve(nworkers);
433 
434     shenandoah_assert_rp_isalive_not_installed();
435     ShenandoahIsAliveSelector is_alive;
436     ReferenceProcessorIsAliveMutator fix_isalive(_heap-&gt;ref_processor(), is_alive.is_alive_closure());
437 
<span class="line-removed">438     ShenandoahTerminationTracker termination_tracker(full_gc ?</span>
<span class="line-removed">439                                                      ShenandoahPhaseTimings::full_gc_mark_termination :</span>
<span class="line-removed">440                                                      ShenandoahPhaseTimings::termination);</span>
<span class="line-removed">441 </span>
442     StrongRootsScope scope(nworkers);
443     TaskTerminator terminator(nworkers, task_queues());
444     ShenandoahFinalMarkingTask task(this, &amp;terminator, ShenandoahStringDedup::is_enabled());
445     _heap-&gt;workers()-&gt;run_task(&amp;task);
446   }
447 
448   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
449 
450   // When we&#39;re done marking everything, we process weak references.
451   if (_heap-&gt;process_references()) {
452     weak_refs_work(full_gc);
453   }
454 
455   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
456   TASKQUEUE_STATS_ONLY(task_queues()-&gt;print_taskqueue_stats());
457   TASKQUEUE_STATS_ONLY(task_queues()-&gt;reset_taskqueue_stats());
458 }
459 
460 // Weak Reference Closures
461 class ShenandoahCMDrainMarkingStackClosure: public VoidClosure {
</pre>
<hr />
<pre>
619   ReferenceProcessor* rp = _heap-&gt;ref_processor();
620 
621   // NOTE: We cannot shortcut on has_discovered_references() here, because
622   // we will miss marking JNI Weak refs then, see implementation in
623   // ReferenceProcessor::process_discovered_references.
624   weak_refs_work_doit(full_gc);
625 
626   rp-&gt;verify_no_references_recorded();
627   assert(!rp-&gt;discovery_enabled(), &quot;Post condition&quot;);
628 
629 }
630 
631 void ShenandoahConcurrentMark::weak_refs_work_doit(bool full_gc) {
632   ReferenceProcessor* rp = _heap-&gt;ref_processor();
633 
634   ShenandoahPhaseTimings::Phase phase_process =
635           full_gc ?
636           ShenandoahPhaseTimings::full_gc_weakrefs_process :
637           ShenandoahPhaseTimings::weakrefs_process;
638 
<span class="line-removed">639   ShenandoahPhaseTimings::Phase phase_process_termination =</span>
<span class="line-removed">640           full_gc ?</span>
<span class="line-removed">641           ShenandoahPhaseTimings::full_gc_weakrefs_termination :</span>
<span class="line-removed">642           ShenandoahPhaseTimings::weakrefs_termination;</span>
<span class="line-removed">643 </span>
644   shenandoah_assert_rp_isalive_not_installed();
645   ShenandoahIsAliveSelector is_alive;
646   ReferenceProcessorIsAliveMutator fix_isalive(rp, is_alive.is_alive_closure());
647 
648   WorkGang* workers = _heap-&gt;workers();
649   uint nworkers = workers-&gt;active_workers();
650 
651   rp-&gt;setup_policy(_heap-&gt;soft_ref_policy()-&gt;should_clear_all_soft_refs());
652   rp-&gt;set_active_mt_degree(nworkers);
653 
654   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
655 
656   // complete_gc and keep_alive closures instantiated here are only needed for
657   // single-threaded path in RP. They share the queue 0 for tracking work, which
658   // simplifies implementation. Since RP may decide to call complete_gc several
659   // times, we need to be able to reuse the terminator.
660   uint serial_worker_id = 0;
661   TaskTerminator terminator(1, task_queues());
662   ShenandoahCMDrainMarkingStackClosure complete_gc(serial_worker_id, &amp;terminator, /* reset_terminator = */ true);
663 
664   ShenandoahRefProcTaskExecutor executor(workers);
665 
666   ReferenceProcessorPhaseTimes pt(_heap-&gt;gc_timer(), rp-&gt;num_queues());
667 
668   {
669     ShenandoahGCPhase phase(phase_process);
<span class="line-removed">670     ShenandoahTerminationTracker phase_term(phase_process_termination);</span>
671 
672     if (_heap-&gt;has_forwarded_objects()) {
673       ShenandoahCMKeepAliveUpdateClosure keep_alive(get_queue(serial_worker_id));
674       rp-&gt;process_discovered_references(is_alive.is_alive_closure(), &amp;keep_alive,
675                                         &amp;complete_gc, &amp;executor,
676                                         &amp;pt);
677 
678     } else {
679       ShenandoahCMKeepAliveClosure keep_alive(get_queue(serial_worker_id));
680       rp-&gt;process_discovered_references(is_alive.is_alive_closure(), &amp;keep_alive,
681                                         &amp;complete_gc, &amp;executor,
682                                         &amp;pt);
683 
684     }
685 
686     pt.print_all_references();
687 
688     assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
689   }
690 }
</pre>
<hr />
<pre>
697   virtual bool should_return() { return _heap-&gt;cancelled_gc(); }
698 };
699 
700 class ShenandoahPrecleanCompleteGCClosure : public VoidClosure {
701 public:
702   void do_void() {
703     ShenandoahHeap* sh = ShenandoahHeap::heap();
704     ShenandoahConcurrentMark* scm = sh-&gt;concurrent_mark();
705     assert(sh-&gt;process_references(), &quot;why else would we be here?&quot;);
706     TaskTerminator terminator(1, scm-&gt;task_queues());
707 
708     ReferenceProcessor* rp = sh-&gt;ref_processor();
709     shenandoah_assert_rp_isalive_installed();
710 
711     scm-&gt;mark_loop(0, &amp;terminator, rp,
712                    false, // not cancellable
713                    false); // do not do strdedup
714   }
715 };
716 
<span class="line-removed">717 class ShenandoahPrecleanKeepAliveUpdateClosure : public OopClosure {</span>
<span class="line-removed">718 private:</span>
<span class="line-removed">719   ShenandoahObjToScanQueue* _queue;</span>
<span class="line-removed">720   ShenandoahHeap* _heap;</span>
<span class="line-removed">721   ShenandoahMarkingContext* const _mark_context;</span>
<span class="line-removed">722 </span>
<span class="line-removed">723   template &lt;class T&gt;</span>
<span class="line-removed">724   inline void do_oop_work(T* p) {</span>
<span class="line-removed">725     ShenandoahConcurrentMark::mark_through_ref&lt;T, CONCURRENT, NO_DEDUP&gt;(p, _heap, _queue, _mark_context);</span>
<span class="line-removed">726   }</span>
<span class="line-removed">727 </span>
<span class="line-removed">728 public:</span>
<span class="line-removed">729   ShenandoahPrecleanKeepAliveUpdateClosure(ShenandoahObjToScanQueue* q) :</span>
<span class="line-removed">730     _queue(q),</span>
<span class="line-removed">731     _heap(ShenandoahHeap::heap()),</span>
<span class="line-removed">732     _mark_context(_heap-&gt;marking_context()) {}</span>
<span class="line-removed">733 </span>
<span class="line-removed">734   void do_oop(narrowOop* p) { do_oop_work(p); }</span>
<span class="line-removed">735   void do_oop(oop* p)       { do_oop_work(p); }</span>
<span class="line-removed">736 };</span>
<span class="line-removed">737 </span>
738 class ShenandoahPrecleanTask : public AbstractGangTask {
739 private:
740   ReferenceProcessor* _rp;
741 
742 public:
743   ShenandoahPrecleanTask(ReferenceProcessor* rp) :
744           AbstractGangTask(&quot;Precleaning task&quot;),
745           _rp(rp) {}
746 
747   void work(uint worker_id) {
748     assert(worker_id == 0, &quot;The code below is single-threaded, only one worker is expected&quot;);
749     ShenandoahParallelWorkerSession worker_session(worker_id);
750 
751     ShenandoahHeap* sh = ShenandoahHeap::heap();

752 
753     ShenandoahObjToScanQueue* q = sh-&gt;concurrent_mark()-&gt;get_queue(worker_id);
754 
755     ShenandoahCancelledGCYieldClosure yield;
756     ShenandoahPrecleanCompleteGCClosure complete_gc;
757 
<span class="line-modified">758     if (sh-&gt;has_forwarded_objects()) {</span>
<span class="line-modified">759       ShenandoahForwardedIsAliveClosure is_alive;</span>
<span class="line-modified">760       ShenandoahPrecleanKeepAliveUpdateClosure keep_alive(q);</span>
<span class="line-modified">761       ResourceMark rm;</span>
<span class="line-modified">762       _rp-&gt;preclean_discovered_references(&amp;is_alive, &amp;keep_alive,</span>
<span class="line-modified">763                                           &amp;complete_gc, &amp;yield,</span>
<span class="line-removed">764                                           NULL);</span>
<span class="line-removed">765     } else {</span>
<span class="line-removed">766       ShenandoahIsAliveClosure is_alive;</span>
<span class="line-removed">767       ShenandoahCMKeepAliveClosure keep_alive(q);</span>
<span class="line-removed">768       ResourceMark rm;</span>
<span class="line-removed">769       _rp-&gt;preclean_discovered_references(&amp;is_alive, &amp;keep_alive,</span>
<span class="line-removed">770                                           &amp;complete_gc, &amp;yield,</span>
<span class="line-removed">771                                           NULL);</span>
<span class="line-removed">772     }</span>
773   }
774 };
775 
776 void ShenandoahConcurrentMark::preclean_weak_refs() {
777   // Pre-cleaning weak references before diving into STW makes sense at the
778   // end of concurrent mark. This will filter out the references which referents
779   // are alive. Note that ReferenceProcessor already filters out these on reference
780   // discovery, and the bulk of work is done here. This phase processes leftovers
781   // that missed the initial filtering, i.e. when referent was marked alive after
782   // reference was discovered by RP.
783 
784   assert(_heap-&gt;process_references(), &quot;sanity&quot;);
785 
786   // Shortcut if no references were discovered to avoid winding up threads.
787   ReferenceProcessor* rp = _heap-&gt;ref_processor();
788   if (!rp-&gt;has_discovered_references()) {
789     return;
790   }
791 
792   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
</pre>
<hr />
<pre>
925 
926     while (satb_mq_set.completed_buffers_num() &gt; 0) {
927       satb_mq_set.apply_closure_to_completed_buffer(&amp;drain_satb);
928     }
929 
930     uint work = 0;
931     for (uint i = 0; i &lt; stride; i++) {
932       if (q-&gt;pop(t) ||
933           queues-&gt;steal(worker_id, t)) {
934         do_task&lt;T&gt;(q, cl, live_data, &amp;t);
935         work++;
936       } else {
937         break;
938       }
939     }
940 
941     if (work == 0) {
942       // No work encountered in current stride, try to terminate.
943       // Need to leave the STS here otherwise it might block safepoints.
944       ShenandoahSuspendibleThreadSetLeaver stsl(CANCELLABLE &amp;&amp; ShenandoahSuspendibleWorkers);
<span class="line-removed">945       ShenandoahTerminationTimingsTracker term_tracker(worker_id);</span>
946       ShenandoahTerminatorTerminator tt(heap);
947       if (terminator-&gt;offer_termination(&amp;tt)) return;
948     }
949   }
950 }
951 
952 bool ShenandoahConcurrentMark::claim_codecache() {
953   assert(ShenandoahConcurrentScanCodeRoots, &quot;must not be called otherwise&quot;);
954   return _claimed_codecache.try_set();
955 }
956 
957 void ShenandoahConcurrentMark::clear_claim_codecache() {
958   assert(ShenandoahConcurrentScanCodeRoots, &quot;must not be called otherwise&quot;);
959   _claimed_codecache.unset();
960 }
</pre>
</td>
<td>
<hr />
<pre>
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 
 27 #include &quot;classfile/symbolTable.hpp&quot;
 28 #include &quot;classfile/systemDictionary.hpp&quot;
 29 #include &quot;code/codeCache.hpp&quot;
 30 
 31 #include &quot;gc/shared/weakProcessor.inline.hpp&quot;
 32 #include &quot;gc/shared/gcTimer.hpp&quot;
 33 #include &quot;gc/shared/referenceProcessor.hpp&quot;
 34 #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
 35 #include &quot;gc/shared/strongRootsScope.hpp&quot;
 36 
 37 #include &quot;gc/shenandoah/shenandoahBarrierSet.inline.hpp&quot;
 38 #include &quot;gc/shenandoah/shenandoahClosures.inline.hpp&quot;
 39 #include &quot;gc/shenandoah/shenandoahConcurrentMark.inline.hpp&quot;
 40 #include &quot;gc/shenandoah/shenandoahMarkCompact.hpp&quot;
 41 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 42 #include &quot;gc/shenandoah/shenandoahRootProcessor.inline.hpp&quot;
 43 #include &quot;gc/shenandoah/shenandoahOopClosures.inline.hpp&quot;
<span class="line-added"> 44 #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;</span>
 45 #include &quot;gc/shenandoah/shenandoahTaskqueue.inline.hpp&quot;

 46 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
 47 
 48 #include &quot;memory/iterator.inline.hpp&quot;
 49 #include &quot;memory/metaspace.hpp&quot;
 50 #include &quot;memory/resourceArea.hpp&quot;
 51 #include &quot;oops/oop.inline.hpp&quot;
 52 #include &quot;runtime/handles.inline.hpp&quot;
 53 
 54 template&lt;UpdateRefsMode UPDATE_REFS&gt;
 55 class ShenandoahInitMarkRootsClosure : public OopClosure {
 56 private:
 57   ShenandoahObjToScanQueue* _queue;
 58   ShenandoahHeap* _heap;
 59   ShenandoahMarkingContext* const _mark_context;
 60 
 61   template &lt;class T&gt;
 62   inline void do_oop_work(T* p) {
 63     ShenandoahConcurrentMark::mark_through_ref&lt;T, UPDATE_REFS, NO_DEDUP&gt;(p, _heap, _queue, _mark_context);
 64   }
 65 
</pre>
<hr />
<pre>
 67   ShenandoahInitMarkRootsClosure(ShenandoahObjToScanQueue* q) :
 68     _queue(q),
 69     _heap(ShenandoahHeap::heap()),
 70     _mark_context(_heap-&gt;marking_context()) {};
 71 
 72   void do_oop(narrowOop* p) { do_oop_work(p); }
 73   void do_oop(oop* p)       { do_oop_work(p); }
 74 };
 75 
 76 ShenandoahMarkRefsSuperClosure::ShenandoahMarkRefsSuperClosure(ShenandoahObjToScanQueue* q, ReferenceProcessor* rp) :
 77   MetadataVisitingOopIterateClosure(rp),
 78   _queue(q),
 79   _heap(ShenandoahHeap::heap()),
 80   _mark_context(_heap-&gt;marking_context())
 81 { }
 82 
 83 template&lt;UpdateRefsMode UPDATE_REFS&gt;
 84 class ShenandoahInitMarkRootsTask : public AbstractGangTask {
 85 private:
 86   ShenandoahAllRootScanner* _rp;

 87 public:
<span class="line-modified"> 88   ShenandoahInitMarkRootsTask(ShenandoahAllRootScanner* rp) :</span>
 89     AbstractGangTask(&quot;Shenandoah init mark roots task&quot;),
<span class="line-modified"> 90     _rp(rp) {</span>

 91   }
 92 
 93   void work(uint worker_id) {
 94     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
 95     ShenandoahParallelWorkerSession worker_session(worker_id);
 96 
 97     ShenandoahHeap* heap = ShenandoahHeap::heap();
 98     ShenandoahObjToScanQueueSet* queues = heap-&gt;concurrent_mark()-&gt;task_queues();
 99     assert(queues-&gt;get_reserved() &gt; worker_id, &quot;Queue has not been reserved for worker id: %d&quot;, worker_id);
100 
101     ShenandoahObjToScanQueue* q = queues-&gt;queue(worker_id);
102 
103     ShenandoahInitMarkRootsClosure&lt;UPDATE_REFS&gt; mark_cl(q);
104     do_work(heap, &amp;mark_cl, worker_id);
105   }
106 
107 private:
108   void do_work(ShenandoahHeap* heap, OopClosure* oops, uint worker_id) {
109     // The rationale for selecting the roots to scan is as follows:
110     //   a. With unload_classes = true, we only want to scan the actual strong roots from the
</pre>
<hr />
<pre>
163   void work(uint worker_id) {
164     ShenandoahHeap* heap = ShenandoahHeap::heap();
165     ShenandoahConcurrentWorkerSession worker_session(worker_id);
166     ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);
167     ShenandoahObjToScanQueue* q = _cm-&gt;get_queue(worker_id);
168     ReferenceProcessor* rp;
169     if (heap-&gt;process_references()) {
170       rp = heap-&gt;ref_processor();
171       shenandoah_assert_rp_isalive_installed();
172     } else {
173       rp = NULL;
174     }
175 
176     _cm-&gt;concurrent_scan_code_roots(worker_id, rp);
177     _cm-&gt;mark_loop(worker_id, _terminator, rp,
178                    true, // cancellable
179                    ShenandoahStringDedup::is_enabled()); // perform string dedup
180   }
181 };
182 
<span class="line-modified">183 class ShenandoahSATBAndRemarkCodeRootsThreadsClosure : public ThreadClosure {</span>
184 private:
185   ShenandoahSATBBufferClosure* _satb_cl;
<span class="line-added">186   MarkingCodeBlobClosure*      _code_cl;</span>
187   uintx _claim_token;
188 
189 public:
<span class="line-modified">190   ShenandoahSATBAndRemarkCodeRootsThreadsClosure(ShenandoahSATBBufferClosure* satb_cl, MarkingCodeBlobClosure* code_cl) :</span>
<span class="line-modified">191     _satb_cl(satb_cl), _code_cl(code_cl),</span>
192     _claim_token(Threads::thread_claim_token()) {}
193 
194   void do_thread(Thread* thread) {
195     if (thread-&gt;claim_threads_do(true, _claim_token)) {
196       ShenandoahThreadLocalData::satb_mark_queue(thread).apply_closure_and_empty(_satb_cl);
<span class="line-added">197       if (_code_cl != NULL &amp;&amp; thread-&gt;is_Java_thread()) {</span>
<span class="line-added">198         // In theory it should not be neccessary to explicitly walk the nmethods to find roots for concurrent marking</span>
<span class="line-added">199         // however the liveness of oops reachable from nmethods have very complex lifecycles:</span>
<span class="line-added">200         // * Alive if on the stack of an executing method</span>
<span class="line-added">201         // * Weakly reachable otherwise</span>
<span class="line-added">202         // Some objects reachable from nmethods, such as the class loader (or klass_holder) of the receiver should be</span>
<span class="line-added">203         // live by the SATB invariant but other oops recorded in nmethods may behave differently.</span>
<span class="line-added">204         JavaThread* jt = (JavaThread*)thread;</span>
<span class="line-added">205         jt-&gt;nmethods_do(_code_cl);</span>
<span class="line-added">206       }</span>
207     }
208   }
209 };
210 
211 class ShenandoahFinalMarkingTask : public AbstractGangTask {
212 private:
213   ShenandoahConcurrentMark* _cm;
214   TaskTerminator*           _terminator;
215   bool _dedup_string;
216 
217 public:
218   ShenandoahFinalMarkingTask(ShenandoahConcurrentMark* cm, TaskTerminator* terminator, bool dedup_string) :
219     AbstractGangTask(&quot;Shenandoah Final Marking&quot;), _cm(cm), _terminator(terminator), _dedup_string(dedup_string) {
220   }
221 
222   void work(uint worker_id) {
223     ShenandoahHeap* heap = ShenandoahHeap::heap();
224 
225     ShenandoahParallelWorkerSession worker_session(worker_id);
<span class="line-added">226     ReferenceProcessor* rp;</span>
<span class="line-added">227     if (heap-&gt;process_references()) {</span>
<span class="line-added">228       rp = heap-&gt;ref_processor();</span>
<span class="line-added">229       shenandoah_assert_rp_isalive_installed();</span>
<span class="line-added">230     } else {</span>
<span class="line-added">231       rp = NULL;</span>
<span class="line-added">232     }</span>
<span class="line-added">233 </span>
234     // First drain remaining SATB buffers.
235     // Notice that this is not strictly necessary for mark-compact. But since
236     // it requires a StrongRootsScope around the task, we need to claim the
237     // threads, and performance-wise it doesn&#39;t really matter. Adds about 1ms to
238     // full-gc.
239     {
240       ShenandoahObjToScanQueue* q = _cm-&gt;get_queue(worker_id);
<span class="line-added">241 </span>
242       ShenandoahSATBBufferClosure cl(q);
243       SATBMarkQueueSet&amp; satb_mq_set = ShenandoahBarrierSet::satb_mark_queue_set();
244       while (satb_mq_set.apply_closure_to_completed_buffer(&amp;cl));



245 
<span class="line-modified">246       if (heap-&gt;unload_classes() &amp;&amp; !ShenandoahConcurrentRoots::can_do_concurrent_class_unloading()) {</span>
<span class="line-modified">247         if (heap-&gt;has_forwarded_objects()) {</span>
<span class="line-modified">248           ShenandoahMarkResolveRefsClosure resolve_mark_cl(q, rp);</span>
<span class="line-modified">249           MarkingCodeBlobClosure blobsCl(&amp;resolve_mark_cl, !CodeBlobToOopClosure::FixRelocations);</span>
<span class="line-modified">250           ShenandoahSATBAndRemarkCodeRootsThreadsClosure tc(&amp;cl, &amp;blobsCl);</span>
<span class="line-modified">251           Threads::threads_do(&amp;tc);</span>
<span class="line-added">252         } else {</span>
<span class="line-added">253           ShenandoahMarkRefsClosure mark_cl(q, rp);</span>
<span class="line-added">254           MarkingCodeBlobClosure blobsCl(&amp;mark_cl, !CodeBlobToOopClosure::FixRelocations);</span>
<span class="line-added">255           ShenandoahSATBAndRemarkCodeRootsThreadsClosure tc(&amp;cl, &amp;blobsCl);</span>
<span class="line-added">256           Threads::threads_do(&amp;tc);</span>
<span class="line-added">257         }</span>
<span class="line-added">258       } else {</span>
<span class="line-added">259         ShenandoahSATBAndRemarkCodeRootsThreadsClosure tc(&amp;cl, NULL);</span>
<span class="line-added">260         Threads::threads_do(&amp;tc);</span>
<span class="line-added">261       }</span>
262     }
263 
264     if (heap-&gt;is_degenerated_gc_in_progress()) {
265       // Degenerated cycle may bypass concurrent cycle, so code roots might not be scanned,
266       // let&#39;s check here.
267       _cm-&gt;concurrent_scan_code_roots(worker_id, rp);
268     }
269 
270     _cm-&gt;mark_loop(worker_id, _terminator, rp,
271                    false, // not cancellable
272                    _dedup_string);
273 
274     assert(_cm-&gt;task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
275   }
276 };
277 
278 void ShenandoahConcurrentMark::mark_roots(ShenandoahPhaseTimings::Phase root_phase) {
279   assert(Thread::current()-&gt;is_VM_thread(), &quot;can only do this in VMThread&quot;);
280   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
281 
282   ShenandoahHeap* heap = ShenandoahHeap::heap();
283 
284   ShenandoahGCPhase phase(root_phase);
285 
286   WorkGang* workers = heap-&gt;workers();
287   uint nworkers = workers-&gt;active_workers();
288 
289   assert(nworkers &lt;= task_queues()-&gt;size(), &quot;Just check&quot;);
290 
291   ShenandoahAllRootScanner root_proc(nworkers, root_phase);
292   TASKQUEUE_STATS_ONLY(task_queues()-&gt;reset_taskqueue_stats());
293   task_queues()-&gt;reserve(nworkers);
294 
295   if (heap-&gt;has_forwarded_objects()) {
<span class="line-modified">296     ShenandoahInitMarkRootsTask&lt;RESOLVE&gt; mark_roots(&amp;root_proc);</span>
297     workers-&gt;run_task(&amp;mark_roots);
298   } else {
299     // No need to update references, which means the heap is stable.
300     // Can save time not walking through forwarding pointers.
<span class="line-modified">301     ShenandoahInitMarkRootsTask&lt;NONE&gt; mark_roots(&amp;root_proc);</span>
302     workers-&gt;run_task(&amp;mark_roots);
303   }
304 
305   if (ShenandoahConcurrentScanCodeRoots) {
306     clear_claim_codecache();
307   }
308 }
309 
310 void ShenandoahConcurrentMark::update_roots(ShenandoahPhaseTimings::Phase root_phase) {
311   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
312   assert(root_phase == ShenandoahPhaseTimings::full_gc_roots ||
313          root_phase == ShenandoahPhaseTimings::degen_gc_update_roots,
314          &quot;Only for these phases&quot;);
315 
316   ShenandoahGCPhase phase(root_phase);
317 
318   bool check_alive = root_phase == ShenandoahPhaseTimings::degen_gc_update_roots;
319 
320 #if COMPILER2_OR_JVMCI
321   DerivedPointerTable::clear();
322 #endif
323 
324   uint nworkers = _heap-&gt;workers()-&gt;active_workers();
325 
326   ShenandoahRootUpdater root_updater(nworkers, root_phase);
327   ShenandoahUpdateRootsTask update_roots(&amp;root_updater, check_alive);
328   _heap-&gt;workers()-&gt;run_task(&amp;update_roots);
329 
330 #if COMPILER2_OR_JVMCI
331   DerivedPointerTable::update_pointers();
332 #endif
333 }
334 
335 class ShenandoahUpdateThreadRootsTask : public AbstractGangTask {
336 private:
337   ShenandoahThreadRoots           _thread_roots;
338   ShenandoahPhaseTimings::Phase   _phase;
<span class="line-added">339   ShenandoahGCWorkerPhase         _worker_phase;</span>
340 public:
341   ShenandoahUpdateThreadRootsTask(bool is_par, ShenandoahPhaseTimings::Phase phase) :
342     AbstractGangTask(&quot;Shenandoah Update Thread Roots&quot;),
343     _thread_roots(is_par),
<span class="line-modified">344     _phase(phase),</span>
<span class="line-modified">345     _worker_phase(phase) {}</span>

346 



347   void work(uint worker_id) {
348     ShenandoahUpdateRefsClosure cl;
349     _thread_roots.oops_do(&amp;cl, NULL, worker_id);
350   }
351 };
352 
353 void ShenandoahConcurrentMark::update_thread_roots(ShenandoahPhaseTimings::Phase root_phase) {
354   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
355 
356   ShenandoahGCPhase phase(root_phase);
357 
358 #if COMPILER2_OR_JVMCI
359   DerivedPointerTable::clear();
360 #endif
361 
362   WorkGang* workers = _heap-&gt;workers();
363   bool is_par = workers-&gt;active_workers() &gt; 1;
364 
365   ShenandoahUpdateThreadRootsTask task(is_par, root_phase);
366   workers-&gt;run_task(&amp;task);
</pre>
<hr />
<pre>
409   uint nworkers = workers-&gt;active_workers();
410 
411   ShenandoahGCPhase conc_mark_phase(ShenandoahPhaseTimings::conc_mark);
412 
413   if (_heap-&gt;process_references()) {
414     ReferenceProcessor* rp = _heap-&gt;ref_processor();
415     rp-&gt;set_active_mt_degree(nworkers);
416 
417     // enable (&quot;weak&quot;) refs discovery
418     rp-&gt;enable_discovery(true /*verify_no_refs*/);
419     rp-&gt;setup_policy(_heap-&gt;soft_ref_policy()-&gt;should_clear_all_soft_refs());
420   }
421 
422   shenandoah_assert_rp_isalive_not_installed();
423   ShenandoahIsAliveSelector is_alive;
424   ReferenceProcessorIsAliveMutator fix_isalive(_heap-&gt;ref_processor(), is_alive.is_alive_closure());
425 
426   task_queues()-&gt;reserve(nworkers);
427 
428   {

429     TaskTerminator terminator(nworkers, task_queues());
430     ShenandoahConcurrentMarkingTask task(this, &amp;terminator);
431     workers-&gt;run_task(&amp;task);
432   }
433 
434   assert(task_queues()-&gt;is_empty() || _heap-&gt;cancelled_gc(), &quot;Should be empty when not cancelled&quot;);
435 }
436 
437 void ShenandoahConcurrentMark::finish_mark_from_roots(bool full_gc) {
438   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
439 
440   uint nworkers = _heap-&gt;workers()-&gt;active_workers();
441 
442   // Finally mark everything else we&#39;ve got in our queues during the previous steps.
443   // It does two different things for concurrent vs. mark-compact GC:
444   // - For concurrent GC, it starts with empty task queues, drains the remaining
445   //   SATB buffers, and then completes the marking closure.
446   // - For mark-compact GC, it starts out with the task queues seeded by initial
447   //   root scan, and completes the closure, thus marking through all live objects
448   // The implementation is the same, so it&#39;s shared here.
449   {
450     ShenandoahGCPhase phase(full_gc ?
451                             ShenandoahPhaseTimings::full_gc_mark_finish_queues :
452                             ShenandoahPhaseTimings::finish_queues);
453     task_queues()-&gt;reserve(nworkers);
454 
455     shenandoah_assert_rp_isalive_not_installed();
456     ShenandoahIsAliveSelector is_alive;
457     ReferenceProcessorIsAliveMutator fix_isalive(_heap-&gt;ref_processor(), is_alive.is_alive_closure());
458 




459     StrongRootsScope scope(nworkers);
460     TaskTerminator terminator(nworkers, task_queues());
461     ShenandoahFinalMarkingTask task(this, &amp;terminator, ShenandoahStringDedup::is_enabled());
462     _heap-&gt;workers()-&gt;run_task(&amp;task);
463   }
464 
465   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
466 
467   // When we&#39;re done marking everything, we process weak references.
468   if (_heap-&gt;process_references()) {
469     weak_refs_work(full_gc);
470   }
471 
472   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
473   TASKQUEUE_STATS_ONLY(task_queues()-&gt;print_taskqueue_stats());
474   TASKQUEUE_STATS_ONLY(task_queues()-&gt;reset_taskqueue_stats());
475 }
476 
477 // Weak Reference Closures
478 class ShenandoahCMDrainMarkingStackClosure: public VoidClosure {
</pre>
<hr />
<pre>
636   ReferenceProcessor* rp = _heap-&gt;ref_processor();
637 
638   // NOTE: We cannot shortcut on has_discovered_references() here, because
639   // we will miss marking JNI Weak refs then, see implementation in
640   // ReferenceProcessor::process_discovered_references.
641   weak_refs_work_doit(full_gc);
642 
643   rp-&gt;verify_no_references_recorded();
644   assert(!rp-&gt;discovery_enabled(), &quot;Post condition&quot;);
645 
646 }
647 
648 void ShenandoahConcurrentMark::weak_refs_work_doit(bool full_gc) {
649   ReferenceProcessor* rp = _heap-&gt;ref_processor();
650 
651   ShenandoahPhaseTimings::Phase phase_process =
652           full_gc ?
653           ShenandoahPhaseTimings::full_gc_weakrefs_process :
654           ShenandoahPhaseTimings::weakrefs_process;
655 





656   shenandoah_assert_rp_isalive_not_installed();
657   ShenandoahIsAliveSelector is_alive;
658   ReferenceProcessorIsAliveMutator fix_isalive(rp, is_alive.is_alive_closure());
659 
660   WorkGang* workers = _heap-&gt;workers();
661   uint nworkers = workers-&gt;active_workers();
662 
663   rp-&gt;setup_policy(_heap-&gt;soft_ref_policy()-&gt;should_clear_all_soft_refs());
664   rp-&gt;set_active_mt_degree(nworkers);
665 
666   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
667 
668   // complete_gc and keep_alive closures instantiated here are only needed for
669   // single-threaded path in RP. They share the queue 0 for tracking work, which
670   // simplifies implementation. Since RP may decide to call complete_gc several
671   // times, we need to be able to reuse the terminator.
672   uint serial_worker_id = 0;
673   TaskTerminator terminator(1, task_queues());
674   ShenandoahCMDrainMarkingStackClosure complete_gc(serial_worker_id, &amp;terminator, /* reset_terminator = */ true);
675 
676   ShenandoahRefProcTaskExecutor executor(workers);
677 
678   ReferenceProcessorPhaseTimes pt(_heap-&gt;gc_timer(), rp-&gt;num_queues());
679 
680   {
681     ShenandoahGCPhase phase(phase_process);

682 
683     if (_heap-&gt;has_forwarded_objects()) {
684       ShenandoahCMKeepAliveUpdateClosure keep_alive(get_queue(serial_worker_id));
685       rp-&gt;process_discovered_references(is_alive.is_alive_closure(), &amp;keep_alive,
686                                         &amp;complete_gc, &amp;executor,
687                                         &amp;pt);
688 
689     } else {
690       ShenandoahCMKeepAliveClosure keep_alive(get_queue(serial_worker_id));
691       rp-&gt;process_discovered_references(is_alive.is_alive_closure(), &amp;keep_alive,
692                                         &amp;complete_gc, &amp;executor,
693                                         &amp;pt);
694 
695     }
696 
697     pt.print_all_references();
698 
699     assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
700   }
701 }
</pre>
<hr />
<pre>
708   virtual bool should_return() { return _heap-&gt;cancelled_gc(); }
709 };
710 
711 class ShenandoahPrecleanCompleteGCClosure : public VoidClosure {
712 public:
713   void do_void() {
714     ShenandoahHeap* sh = ShenandoahHeap::heap();
715     ShenandoahConcurrentMark* scm = sh-&gt;concurrent_mark();
716     assert(sh-&gt;process_references(), &quot;why else would we be here?&quot;);
717     TaskTerminator terminator(1, scm-&gt;task_queues());
718 
719     ReferenceProcessor* rp = sh-&gt;ref_processor();
720     shenandoah_assert_rp_isalive_installed();
721 
722     scm-&gt;mark_loop(0, &amp;terminator, rp,
723                    false, // not cancellable
724                    false); // do not do strdedup
725   }
726 };
727 





















728 class ShenandoahPrecleanTask : public AbstractGangTask {
729 private:
730   ReferenceProcessor* _rp;
731 
732 public:
733   ShenandoahPrecleanTask(ReferenceProcessor* rp) :
734           AbstractGangTask(&quot;Precleaning task&quot;),
735           _rp(rp) {}
736 
737   void work(uint worker_id) {
738     assert(worker_id == 0, &quot;The code below is single-threaded, only one worker is expected&quot;);
739     ShenandoahParallelWorkerSession worker_session(worker_id);
740 
741     ShenandoahHeap* sh = ShenandoahHeap::heap();
<span class="line-added">742     assert(!sh-&gt;has_forwarded_objects(), &quot;No forwarded objects expected here&quot;);</span>
743 
744     ShenandoahObjToScanQueue* q = sh-&gt;concurrent_mark()-&gt;get_queue(worker_id);
745 
746     ShenandoahCancelledGCYieldClosure yield;
747     ShenandoahPrecleanCompleteGCClosure complete_gc;
748 
<span class="line-modified">749     ShenandoahIsAliveClosure is_alive;</span>
<span class="line-modified">750     ShenandoahCMKeepAliveClosure keep_alive(q);</span>
<span class="line-modified">751     ResourceMark rm;</span>
<span class="line-modified">752     _rp-&gt;preclean_discovered_references(&amp;is_alive, &amp;keep_alive,</span>
<span class="line-modified">753                                         &amp;complete_gc, &amp;yield,</span>
<span class="line-modified">754                                         NULL);</span>









755   }
756 };
757 
758 void ShenandoahConcurrentMark::preclean_weak_refs() {
759   // Pre-cleaning weak references before diving into STW makes sense at the
760   // end of concurrent mark. This will filter out the references which referents
761   // are alive. Note that ReferenceProcessor already filters out these on reference
762   // discovery, and the bulk of work is done here. This phase processes leftovers
763   // that missed the initial filtering, i.e. when referent was marked alive after
764   // reference was discovered by RP.
765 
766   assert(_heap-&gt;process_references(), &quot;sanity&quot;);
767 
768   // Shortcut if no references were discovered to avoid winding up threads.
769   ReferenceProcessor* rp = _heap-&gt;ref_processor();
770   if (!rp-&gt;has_discovered_references()) {
771     return;
772   }
773 
774   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
</pre>
<hr />
<pre>
907 
908     while (satb_mq_set.completed_buffers_num() &gt; 0) {
909       satb_mq_set.apply_closure_to_completed_buffer(&amp;drain_satb);
910     }
911 
912     uint work = 0;
913     for (uint i = 0; i &lt; stride; i++) {
914       if (q-&gt;pop(t) ||
915           queues-&gt;steal(worker_id, t)) {
916         do_task&lt;T&gt;(q, cl, live_data, &amp;t);
917         work++;
918       } else {
919         break;
920       }
921     }
922 
923     if (work == 0) {
924       // No work encountered in current stride, try to terminate.
925       // Need to leave the STS here otherwise it might block safepoints.
926       ShenandoahSuspendibleThreadSetLeaver stsl(CANCELLABLE &amp;&amp; ShenandoahSuspendibleWorkers);

927       ShenandoahTerminatorTerminator tt(heap);
928       if (terminator-&gt;offer_termination(&amp;tt)) return;
929     }
930   }
931 }
932 
933 bool ShenandoahConcurrentMark::claim_codecache() {
934   assert(ShenandoahConcurrentScanCodeRoots, &quot;must not be called otherwise&quot;);
935   return _claimed_codecache.try_set();
936 }
937 
938 void ShenandoahConcurrentMark::clear_claim_codecache() {
939   assert(ShenandoahConcurrentScanCodeRoots, &quot;must not be called otherwise&quot;);
940   _claimed_codecache.unset();
941 }
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahCollectionSet.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahControlThread.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
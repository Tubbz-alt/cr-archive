<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/gc/shenandoah/shenandoah_globals.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahVerifier.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../z/c2/zBarrierSetC2.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoah_globals.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -39,141 +39,144 @@</span>
                              lp64_product,                                   \
                              range,                                          \
                              constraint)                                     \
                                                                              \
    experimental(size_t, ShenandoahHeapRegionSize, 0,                         \
<span class="udiff-line-modified-removed">-           &quot;Size of the Shenandoah regions. Set to zero to detect &quot;          \</span>
<span class="udiff-line-removed">-           &quot;automatically.&quot;)                                                 \</span>
<span class="udiff-line-modified-added">+           &quot;Static heap region size. Set zero to enable automatic sizing.&quot;)  \</span>
                                                                              \
    experimental(size_t, ShenandoahTargetNumRegions, 2048,                    \
<span class="udiff-line-modified-removed">-           &quot;Target number of regions. We try to get around that many &quot;       \</span>
<span class="udiff-line-modified-removed">-           &quot;regions, based on Shenandoah{Min,Max}RegionSize.&quot;)               \</span>
<span class="udiff-line-modified-added">+           &quot;With automatic region sizing, this is the approximate number &quot;   \</span>
<span class="udiff-line-modified-added">+           &quot;of regions that would be used, within min/max region size &quot;      \</span>
<span class="udiff-line-added">+           &quot;limits.&quot;)                                                        \</span>
                                                                              \
    experimental(size_t, ShenandoahMinRegionSize, 256 * K,                    \
<span class="udiff-line-modified-removed">-           &quot;Minimum Shenandoah heap region size.&quot;)                           \</span>
<span class="udiff-line-modified-added">+           &quot;With automatic region sizing, the regions would be at least &quot;    \</span>
<span class="udiff-line-added">+           &quot;this large.&quot;)                                                    \</span>
                                                                              \
    experimental(size_t, ShenandoahMaxRegionSize, 32 * M,                     \
<span class="udiff-line-modified-removed">-           &quot;Maximum Shenandoah heap region size.&quot;)                           \</span>
<span class="udiff-line-modified-added">+           &quot;With automatic region sizing, the regions would be at most &quot;     \</span>
<span class="udiff-line-added">+           &quot;this large.&quot;)                                                    \</span>
                                                                              \
    experimental(intx, ShenandoahHumongousThreshold, 100,                     \
<span class="udiff-line-modified-removed">-           &quot;How large should the object be to get allocated in humongous &quot;   \</span>
<span class="udiff-line-modified-removed">-           &quot;region, in percents of heap region size. This also caps the &quot;    \</span>
<span class="udiff-line-modified-removed">-           &quot;maximum TLAB size.&quot;)                                             \</span>
<span class="udiff-line-modified-added">+           &quot;Humongous objects are allocated in separate regions. &quot;           \</span>
<span class="udiff-line-modified-added">+           &quot;This setting defines how large the object should be to be &quot;      \</span>
<span class="udiff-line-modified-added">+           &quot;deemed humongous. Value is in  percents of heap region size. &quot;   \</span>
<span class="udiff-line-added">+           &quot;This also caps the maximum TLAB size.&quot;)                          \</span>
            range(1, 100)                                                     \
                                                                              \
<span class="udiff-line-removed">-   experimental(ccstr, ShenandoahGCHeuristics, &quot;adaptive&quot;,                   \</span>
<span class="udiff-line-removed">-           &quot;The heuristics to use in Shenandoah GC. Possible values:&quot;        \</span>
<span class="udiff-line-removed">-           &quot; *) adaptive - adapt to maintain the given amount of free heap;&quot; \</span>
<span class="udiff-line-removed">-           &quot; *) static  -  start concurrent GC when static free heap &quot;       \</span>
<span class="udiff-line-removed">-           &quot;               threshold and static allocation threshold are &quot;   \</span>
<span class="udiff-line-removed">-           &quot;               tripped;&quot;                                         \</span>
<span class="udiff-line-removed">-           &quot; *) aggressive - run concurrent GC continuously, evacuate &quot;      \</span>
<span class="udiff-line-removed">-           &quot;               everything;&quot;                                      \</span>
<span class="udiff-line-removed">-           &quot; *) compact - run GC with lower footprint target, may end up &quot;   \</span>
<span class="udiff-line-removed">-           &quot;               doing continuous GC, evacuate lots of live &quot;      \</span>
<span class="udiff-line-removed">-           &quot;               objects, uncommit heap aggressively;&quot;)            \</span>
<span class="udiff-line-removed">-                                                                             \</span>
    experimental(ccstr, ShenandoahGCMode, &quot;normal&quot;,                           \
<span class="udiff-line-modified-removed">-           &quot;The GC mode to use in Shenandoah GC. Possible values&quot;            \</span>
<span class="udiff-line-modified-removed">-           &quot; *) normal    - normal GC (mark-evac-update)&quot;                    \</span>
<span class="udiff-line-modified-removed">-           &quot; *) traversal - traversal GC (single-pass)&quot;                      \</span>
<span class="udiff-line-modified-removed">-           &quot; *) passive   - disable concurrent GC, do stop-the-world GC&quot;)    \</span>
<span class="udiff-line-modified-added">+           &quot;GC mode to use.  Among other things, this defines which &quot;        \</span>
<span class="udiff-line-modified-added">+           &quot;barriers are in in use. Possible values are:&quot;                    \</span>
<span class="udiff-line-modified-added">+           &quot; normal - default concurrent GC (three pass mark-evac-update);&quot;  \</span>
<span class="udiff-line-modified-added">+           &quot; traversal - traversal concurrent GC (single-pass); &quot;            \</span>
<span class="udiff-line-added">+           &quot; passive - stop the world GC only (either degenerated or full)&quot;) \</span>
                                                                              \
<span class="udiff-line-modified-removed">-   experimental(ccstr, ShenandoahUpdateRefsEarly, &quot;adaptive&quot;,                \</span>
<span class="udiff-line-modified-removed">-           &quot;Run a separate concurrent reference updating phase after&quot;        \</span>
<span class="udiff-line-modified-removed">-           &quot;concurrent evacuation. Possible values: &#39;on&#39;, &#39;off&#39;, &#39;adaptive&#39;&quot;)\</span>
<span class="udiff-line-modified-added">+   experimental(ccstr, ShenandoahGCHeuristics, &quot;adaptive&quot;,                   \</span>
<span class="udiff-line-modified-added">+           &quot;GC heuristics to use. This fine-tunes the GC mode selected, &quot;    \</span>
<span class="udiff-line-modified-added">+           &quot;by choosing when to start the GC, how much to process on each &quot;  \</span>
<span class="udiff-line-added">+           &quot;cycle, and what other features to automatically enable. &quot;        \</span>
<span class="udiff-line-added">+           &quot;Possible values are:&quot;                                            \</span>
<span class="udiff-line-added">+           &quot; adaptive - adapt to maintain the given amount of free heap &quot;    \</span>
<span class="udiff-line-added">+           &quot;at all times, even during the GC cycle;&quot;                         \</span>
<span class="udiff-line-added">+           &quot; static -  trigger GC when free heap falls below the threshold;&quot; \</span>
<span class="udiff-line-added">+           &quot; aggressive - run GC continuously, try to evacuate everything;&quot;  \</span>
<span class="udiff-line-added">+           &quot; compact - run GC more frequently and with deeper targets to &quot;   \</span>
<span class="udiff-line-added">+           &quot;free up more memory.&quot;)                                           \</span>
                                                                              \
    experimental(uintx, ShenandoahRefProcFrequency, 5,                        \
<span class="udiff-line-modified-removed">-           &quot;How often should (weak, soft, etc) references be processed. &quot;    \</span>
<span class="udiff-line-modified-removed">-           &quot;References get processed at every Nth GC cycle. Set to zero &quot;    \</span>
<span class="udiff-line-modified-removed">-           &quot;to disable reference processing.&quot;)                               \</span>
<span class="udiff-line-modified-added">+           &quot;Process process weak (soft, phantom, finalizers) references &quot;    \</span>
<span class="udiff-line-modified-added">+           &quot;every Nth cycle. Normally affects concurrent GC cycles only, &quot;   \</span>
<span class="udiff-line-modified-added">+           &quot;as degenerated and full GCs would try to process references &quot;    \</span>
<span class="udiff-line-added">+           &quot;regardless. Set to zero to disable reference processing &quot;        \</span>
<span class="udiff-line-added">+           &quot;completely.&quot;)                                                    \</span>
                                                                              \
    experimental(uintx, ShenandoahUnloadClassesFrequency, 1,                  \
<span class="udiff-line-modified-removed">-           &quot;How often should classes get unloaded. &quot;                         \</span>
<span class="udiff-line-modified-removed">-           &quot;Class unloading is performed at every Nth GC cycle. &quot;            \</span>
<span class="udiff-line-modified-removed">-           &quot;Set to zero to disable class unloading during concurrent GC.&quot;)   \</span>
<span class="udiff-line-modified-added">+           &quot;Unload the classes every Nth cycle. Normally affects concurrent &quot;\</span>
<span class="udiff-line-modified-added">+           &quot;GC cycles, as degenerated and full GCs would try to unload &quot;     \</span>
<span class="udiff-line-modified-added">+           &quot;classes regardless. Set to zero to disable class unloading.&quot;)    \</span>
                                                                              \
    experimental(uintx, ShenandoahGarbageThreshold, 60,                       \
<span class="udiff-line-modified-removed">-           &quot;Sets the percentage of garbage a region need to contain before &quot; \</span>
<span class="udiff-line-modified-removed">-           &quot;it can be marked for collection. Does not apply to all &quot;         \</span>
<span class="udiff-line-modified-removed">-           &quot;heuristics.&quot;)                                                    \</span>
<span class="udiff-line-modified-added">+           &quot;How much garbage a region has to contain before it would be &quot;    \</span>
<span class="udiff-line-modified-added">+           &quot;taken for collection. This a guideline only , as GC heuristics &quot; \</span>
<span class="udiff-line-modified-added">+           &quot;may select the region for collection even if it has little &quot;     \</span>
<span class="udiff-line-added">+           &quot;garbage. In percents of heap region size.&quot;)                      \</span>
            range(0,100)                                                      \
                                                                              \
    experimental(uintx, ShenandoahInitFreeThreshold, 70,                      \
<span class="udiff-line-modified-removed">-           &quot;Initial remaining free heap threshold for learning steps in &quot;    \</span>
<span class="udiff-line-modified-removed">-           &quot;heuristics. In percents of total heap size. Does not apply to &quot;  \</span>
<span class="udiff-line-modified-removed">-           &quot;all heuristics.&quot;)                                                \</span>
<span class="udiff-line-modified-added">+           &quot;How much heap should be free before some heuristics trigger the &quot;\</span>
<span class="udiff-line-modified-added">+           &quot;initial (learning) cycles. Affects cycle frequency on startup &quot;  \</span>
<span class="udiff-line-modified-added">+           &quot;and after drastic state changes, e.g. after degenerated/full &quot;   \</span>
<span class="udiff-line-added">+           &quot;GC cycles. In percents of total heap size.&quot;)                     \</span>
            range(0,100)                                                      \
                                                                              \
    experimental(uintx, ShenandoahMinFreeThreshold, 10,                       \
<span class="udiff-line-modified-removed">-           &quot;Minimum remaining free space threshold, after which collection &quot; \</span>
<span class="udiff-line-modified-removed">-           &quot;definitely triggers. Does not apply to all heuristics.&quot;)         \</span>
<span class="udiff-line-modified-added">+           &quot;How much heap should be free before most heuristics trigger the &quot;\</span>
<span class="udiff-line-modified-added">+           &quot;collection, even without other triggers. Provides the safety &quot;   \</span>
<span class="udiff-line-added">+           &quot;margin for many heuristics. In percents of total heap size.&quot;)    \</span>
            range(0,100)                                                      \
                                                                              \
    experimental(uintx, ShenandoahAllocationThreshold, 0,                     \
<span class="udiff-line-modified-removed">-           &quot;Set percentage of memory allocated since last GC cycle before &quot;  \</span>
<span class="udiff-line-modified-removed">-           &quot;a new GC cycle can be started. Set to zero to effectively &quot;      \</span>
<span class="udiff-line-modified-removed">-           &quot;disable.&quot;)                                                       \</span>
<span class="udiff-line-modified-added">+           &quot;How many new allocations should happen since the last GC cycle &quot; \</span>
<span class="udiff-line-modified-added">+           &quot;before some heuristics trigger the collection. In percents of &quot;  \</span>
<span class="udiff-line-modified-added">+           &quot;total heap size. Set to zero to effectively disable.&quot;)           \</span>
<span class="udiff-line-added">+           range(0,100)                                                      \</span>
<span class="udiff-line-added">+                                                                             \</span>
<span class="udiff-line-added">+   experimental(uintx, ShenandoahAllocSpikeFactor, 5,                        \</span>
<span class="udiff-line-added">+           &quot;How much of heap should some heuristics reserve for absorbing &quot;  \</span>
<span class="udiff-line-added">+           &quot;the allocation spikes. Larger value wastes more memory in &quot;      \</span>
<span class="udiff-line-added">+           &quot;non-emergency cases, but provides more safety in emergency &quot;     \</span>
<span class="udiff-line-added">+           &quot;cases. In percents of total heap size.&quot;)                         \</span>
            range(0,100)                                                      \
                                                                              \
    experimental(uintx, ShenandoahLearningSteps, 5,                           \
<span class="udiff-line-modified-removed">-           &quot;Number of GC cycles to run in order to learn application &quot;       \</span>
<span class="udiff-line-modified-removed">-           &quot;and GC performance for adaptive heuristics.&quot;)                    \</span>
<span class="udiff-line-modified-added">+           &quot;The number of cycles some heuristics take to collect in order &quot;  \</span>
<span class="udiff-line-modified-added">+           &quot;to learn application and GC performance.&quot;)                       \</span>
            range(0,100)                                                      \
                                                                              \
    experimental(uintx, ShenandoahImmediateThreshold, 90,                     \
<span class="udiff-line-modified-removed">-           &quot;If mark identifies more than this much immediate garbage &quot;       \</span>
<span class="udiff-line-modified-removed">-           &quot;regions, it shall recycle them, and shall not continue the &quot;     \</span>
<span class="udiff-line-modified-removed">-           &quot;rest of the GC cycle. The value is in percents of total &quot;        \</span>
<span class="udiff-line-modified-removed">-           &quot;number of candidate regions for collection set. Setting this &quot;   \</span>
<span class="udiff-line-removed">-           &quot;threshold to 100% effectively disables this shortcut.&quot;)          \</span>
<span class="udiff-line-modified-added">+           &quot;The cycle may shortcut when enough garbage can be reclaimed &quot;    \</span>
<span class="udiff-line-modified-added">+           &quot;from the immediate garbage (completely garbage regions). &quot;       \</span>
<span class="udiff-line-modified-added">+           &quot;In percents of total garbage found. Setting this threshold &quot;     \</span>
<span class="udiff-line-modified-added">+           &quot;to 100 effectively disables the shortcut.&quot;)                      \</span>
            range(0,100)                                                      \
                                                                              \
<span class="udiff-line-removed">-   experimental(uintx, ShenandoahMergeUpdateRefsMinGap, 100,                 \</span>
<span class="udiff-line-removed">-           &quot;If GC is currently running in separate update-refs mode &quot;        \</span>
<span class="udiff-line-removed">-           &quot;this numbers gives the threshold when to switch to &quot;             \</span>
<span class="udiff-line-removed">-           &quot;merged update-refs mode. Number is percentage relative to&quot;       \</span>
<span class="udiff-line-removed">-           &quot;duration(marking)+duration(update-refs).&quot;)                       \</span>
<span class="udiff-line-removed">-                                                                             \</span>
<span class="udiff-line-removed">-   experimental(uintx, ShenandoahMergeUpdateRefsMaxGap, 200,                 \</span>
<span class="udiff-line-removed">-           &quot;If GC is currently running in merged update-refs mode &quot;          \</span>
<span class="udiff-line-removed">-           &quot;this numbers gives the threshold when to switch to &quot;             \</span>
<span class="udiff-line-removed">-           &quot;separate update-refs mode. Number is percentage relative &quot;       \</span>
<span class="udiff-line-removed">-           &quot;to duration(marking)+duration(update-refs).&quot;)                    \</span>
<span class="udiff-line-removed">-                                                                             \</span>
    experimental(uintx, ShenandoahGuaranteedGCInterval, 5*60*1000,            \
<span class="udiff-line-modified-removed">-           &quot;Most heuristics would guarantee a concurrent GC cycle at &quot;       \</span>
<span class="udiff-line-modified-added">+           &quot;Many heuristics would guarantee a concurrent GC cycle at &quot;       \</span>
            &quot;least with this interval. This is useful when large idle &quot;       \
            &quot;intervals are present, where GC can run without stealing &quot;       \
            &quot;time from active application. Time is in milliseconds. &quot;         \
<span class="udiff-line-modified-removed">-           &quot;(Setting this interval to 0 disables this feature).&quot;)            \</span>
<span class="udiff-line-modified-added">+           &quot;Setting this to 0 disables the feature.&quot;)                        \</span>
                                                                              \
    experimental(bool, ShenandoahAlwaysClearSoftRefs, false,                  \
<span class="udiff-line-modified-removed">-           &quot;Clear soft references always, instead of using any smart &quot;       \</span>
<span class="udiff-line-modified-removed">-           &quot;cleanup policy. This minimizes footprint at expense of more &quot;    \</span>
<span class="udiff-line-modified-removed">-           &quot;softref churn in applications.&quot;)                                 \</span>
<span class="udiff-line-modified-added">+           &quot;Unconditionally clear soft references, instead of using any &quot;    \</span>
<span class="udiff-line-modified-added">+           &quot;other cleanup policy. This minimizes footprint at expense of&quot;    \</span>
<span class="udiff-line-modified-added">+           &quot;more soft reference churn in applications.&quot;)                     \</span>
                                                                              \
    experimental(bool, ShenandoahUncommit, true,                              \
<span class="udiff-line-modified-removed">-           &quot;Allow Shenandoah to uncommit unused memory.&quot;)                    \</span>
<span class="udiff-line-modified-added">+           &quot;Allow to uncommit memory under unused regions and metadata. &quot;    \</span>
<span class="udiff-line-added">+           &quot;This optimizes footprint at expense of allocation latency in &quot;   \</span>
<span class="udiff-line-added">+           &quot;regions that require committing back. Uncommits would be &quot;       \</span>
<span class="udiff-line-added">+           &quot;disabled by some heuristics, or with static heap size.&quot;)         \</span>
                                                                              \
    experimental(uintx, ShenandoahUncommitDelay, 5*60*1000,                   \
<span class="udiff-line-modified-removed">-           &quot;Shenandoah would start to uncommit memory for regions that were&quot; \</span>
<span class="udiff-line-modified-removed">-           &quot; not used for more than this time. First use after that would &quot;  \</span>
<span class="udiff-line-modified-removed">-           &quot;incur allocation stalls. Actively used regions would never be &quot;  \</span>
<span class="udiff-line-modified-removed">-           &quot;uncommitted, because they never decay. Time is in milliseconds.&quot; \</span>
<span class="udiff-line-modified-removed">-           &quot;Setting this delay to 0 effectively makes Shenandoah to &quot;        \</span>
<span class="udiff-line-modified-removed">-           &quot;uncommit the regions almost immediately.&quot;)                       \</span>
<span class="udiff-line-modified-added">+           &quot;Uncommit memory for regions that were not used for more than &quot;   \</span>
<span class="udiff-line-modified-added">+           &quot;this time. First use after that would incur allocation stalls. &quot; \</span>
<span class="udiff-line-modified-added">+           &quot;Actively used regions would never be uncommitted, because they &quot; \</span>
<span class="udiff-line-modified-added">+           &quot;do not become unused longer than this delay. Time is in &quot;        \</span>
<span class="udiff-line-modified-added">+           &quot;milliseconds. Setting this delay to 0 effectively uncommits &quot;    \</span>
<span class="udiff-line-modified-added">+           &quot;regions almost immediately after they become unused.&quot;)           \</span>
                                                                              \
    experimental(bool, ShenandoahRegionSampling, false,                       \
<span class="udiff-line-modified-removed">-           &quot;Turns on heap region sampling via JVMStat&quot;)                      \</span>
<span class="udiff-line-modified-added">+           &quot;Provide heap region sampling data via jvmstat.&quot;)                 \</span>
                                                                              \
    experimental(int, ShenandoahRegionSamplingRate, 40,                       \
<span class="udiff-line-modified-removed">-           &quot;Sampling rate for heap region sampling. &quot;                        \</span>
<span class="udiff-line-modified-removed">-           &quot;Number of milliseconds between samples&quot;)                         \</span>
<span class="udiff-line-modified-added">+           &quot;Sampling rate for heap region sampling. In milliseconds between &quot;\</span>
<span class="udiff-line-modified-added">+           &quot;the samples. Higher values provide more fidelity, at expense &quot;   \</span>
<span class="udiff-line-added">+           &quot;of more sampling overhead.&quot;)                                     \</span>
                                                                              \
    experimental(uintx, ShenandoahControlIntervalMin, 1,                      \
<span class="udiff-line-modified-removed">-           &quot;The minumum sleep interval for control loop that drives &quot;        \</span>
<span class="udiff-line-modified-added">+           &quot;The minimum sleep interval for the control loop that drives &quot;    \</span>
            &quot;the cycles. Lower values would increase GC responsiveness &quot;      \
            &quot;to changing heap conditions, at the expense of higher perf &quot;     \
            &quot;overhead. Time is in milliseconds.&quot;)                             \
                                                                              \
    experimental(uintx, ShenandoahControlIntervalMax, 10,                     \
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -186,160 +189,148 @@</span>
            &quot;The time period for one step in control loop interval &quot;          \
            &quot;adjustment. Lower values make adjustments faster, at the &quot;       \
            &quot;expense of higher perf overhead. Time is in milliseconds.&quot;)      \
                                                                              \
    experimental(bool, ShenandoahCriticalControlThreadPriority, false,        \
<span class="udiff-line-modified-removed">-           &quot;Shenandoah control thread runs at critical scheduling priority.&quot;)\</span>
<span class="udiff-line-modified-added">+           &quot;Run control thread runs at critical scheduling priority.&quot;)       \</span>
                                                                              \
    diagnostic(bool, ShenandoahVerify, false,                                 \
<span class="udiff-line-modified-removed">-           &quot;Verify the Shenandoah garbage collector&quot;)                        \</span>
<span class="udiff-line-modified-added">+           &quot;Enable internal verification. This would catch many GC bugs, &quot;   \</span>
<span class="udiff-line-added">+           &quot;but it would also stall the collector during the verification, &quot; \</span>
<span class="udiff-line-added">+           &quot;which prolongs the pauses and might hide other bugs.&quot;)           \</span>
                                                                              \
    diagnostic(intx, ShenandoahVerifyLevel, 4,                                \
<span class="udiff-line-modified-removed">-           &quot;Shenandoah verification level: &quot;                                 \</span>
<span class="udiff-line-modified-removed">-           &quot;0 = basic heap checks; &quot;                                         \</span>
<span class="udiff-line-modified-removed">-           &quot;1 = previous level, plus basic region checks; &quot;                  \</span>
<span class="udiff-line-modified-removed">-           &quot;2 = previous level, plus all roots; &quot;                            \</span>
<span class="udiff-line-modified-removed">-           &quot;3 = previous level, plus all reachable objects; &quot;                \</span>
<span class="udiff-line-modified-removed">-           &quot;4 = previous level, plus all marked objects&quot;)                    \</span>
<span class="udiff-line-modified-added">+           &quot;Verification level, higher levels check more, taking more time. &quot;\</span>
<span class="udiff-line-modified-added">+           &quot;Accepted values are:&quot;                                            \</span>
<span class="udiff-line-modified-added">+           &quot; 0 = basic heap checks; &quot;                                        \</span>
<span class="udiff-line-modified-added">+           &quot; 1 = previous level, plus basic region checks; &quot;                 \</span>
<span class="udiff-line-modified-added">+           &quot; 2 = previous level, plus all roots; &quot;                           \</span>
<span class="udiff-line-modified-added">+           &quot; 3 = previous level, plus all reachable objects; &quot;               \</span>
<span class="udiff-line-added">+           &quot; 4 = previous level, plus all marked objects&quot;)                   \</span>
                                                                              \
    diagnostic(bool, ShenandoahElasticTLAB, true,                             \
            &quot;Use Elastic TLABs with Shenandoah&quot;)                              \
                                                                              \
    diagnostic(bool, ShenandoahAllowMixedAllocs, true,                        \
<span class="udiff-line-modified-removed">-           &quot;Allow mixing mutator and collector allocations in a single &quot;     \</span>
<span class="udiff-line-modified-removed">-           &quot;region&quot;)                                                         \</span>
<span class="udiff-line-removed">-                                                                             \</span>
<span class="udiff-line-removed">-   experimental(uintx, ShenandoahAllocSpikeFactor, 5,                        \</span>
<span class="udiff-line-removed">-           &quot;The amount of heap space to reserve for absorbing the &quot;          \</span>
<span class="udiff-line-removed">-           &quot;allocation spikes. Larger value wastes more memory in &quot;          \</span>
<span class="udiff-line-removed">-           &quot;non-emergency cases, but provides more safety in emergency &quot;     \</span>
<span class="udiff-line-removed">-           &quot;cases. In percents of total heap size.&quot;)                         \</span>
<span class="udiff-line-removed">-           range(0,100)                                                      \</span>
<span class="udiff-line-modified-added">+           &quot;Allow mixing mutator and collector allocations into a single &quot;   \</span>
<span class="udiff-line-modified-added">+           &quot;region. Some heuristics enable/disable it for their needs&quot;)      \</span>
                                                                              \
    experimental(uintx, ShenandoahEvacReserve, 5,                             \
<span class="udiff-line-modified-removed">-           &quot;Maximum amount of free space to reserve for evacuation. &quot;        \</span>
<span class="udiff-line-modified-removed">-           &quot;Larger values make GC more aggressive, while leaving less &quot;      \</span>
<span class="udiff-line-modified-removed">-           &quot;headroom for application to allocate in. &quot;                       \</span>
<span class="udiff-line-modified-removed">-           &quot;In percents of total heap size.&quot;)                                \</span>
<span class="udiff-line-modified-added">+           &quot;How much of heap to reserve for evacuations. Larger values make &quot;\</span>
<span class="udiff-line-modified-added">+           &quot;GC evacuate more live objects on every cycle, while leaving &quot;    \</span>
<span class="udiff-line-modified-added">+           &quot;less headroom for application to allocate in. In percents of &quot;   \</span>
<span class="udiff-line-modified-added">+           &quot;total heap size.&quot;)                                               \</span>
            range(1,100)                                                      \
                                                                              \
    experimental(double, ShenandoahEvacWaste, 1.2,                            \
<span class="udiff-line-modified-removed">-           &quot;How much waste evacuations produce within the reserved &quot;         \</span>
<span class="udiff-line-modified-removed">-           &quot;space. Larger values make evacuations more resilient &quot;           \</span>
<span class="udiff-line-modified-removed">-           &quot;against allocation failures, at expense of smaller csets &quot;       \</span>
<span class="udiff-line-modified-removed">-           &quot;on each cycle.&quot;)                                                 \</span>
<span class="udiff-line-modified-added">+           &quot;How much waste evacuations produce within the reserved space. &quot;  \</span>
<span class="udiff-line-modified-added">+           &quot;Larger values make evacuations more resilient against &quot;          \</span>
<span class="udiff-line-modified-added">+           &quot;evacuation conflicts, at expense of evacuating less on each &quot;    \</span>
<span class="udiff-line-modified-added">+           &quot;GC cycle.&quot;)                                                      \</span>
            range(1.0,100.0)                                                  \
                                                                              \
    experimental(bool, ShenandoahEvacReserveOverflow, true,                   \
<span class="udiff-line-modified-removed">-           &quot;Allow evacuations to overflow the reserved space. &quot;              \</span>
<span class="udiff-line-modified-removed">-           &quot;Enabling it will make evacuations more resilient when &quot;          \</span>
<span class="udiff-line-modified-removed">-           &quot;evacuation reserve/waste is incorrect, at the risk that &quot;        \</span>
<span class="udiff-line-modified-removed">-           &quot;application allocations run out of memory too early.&quot;)           \</span>
<span class="udiff-line-removed">-                                                                             \</span>
<span class="udiff-line-removed">-   diagnostic(bool, ShenandoahAllocationTrace, false,                        \</span>
<span class="udiff-line-removed">-           &quot;Trace allocation latencies and stalls. Can be expensive when &quot;   \</span>
<span class="udiff-line-removed">-           &quot;lots of allocations happen, and may introduce scalability &quot;      \</span>
<span class="udiff-line-removed">-           &quot;bottlenecks.&quot;)                                                   \</span>
<span class="udiff-line-removed">-                                                                             \</span>
<span class="udiff-line-removed">-   diagnostic(intx, ShenandoahAllocationStallThreshold, 10000,               \</span>
<span class="udiff-line-removed">-           &quot;When allocation tracing is enabled, the allocation stalls &quot;      \</span>
<span class="udiff-line-removed">-           &quot;larger than this threshold would be reported as warnings. &quot;      \</span>
<span class="udiff-line-removed">-           &quot;Time is in microseconds.&quot;)                                       \</span>
<span class="udiff-line-removed">-                                                                             \</span>
<span class="udiff-line-removed">-   experimental(uintx, ShenandoahEvacAssist, 10,                             \</span>
<span class="udiff-line-removed">-           &quot;How many objects to evacuate on LRB assist path. &quot;               \</span>
<span class="udiff-line-removed">-           &quot;Use zero to disable.&quot;)                                           \</span>
<span class="udiff-line-modified-added">+           &quot;Allow evacuations to overflow the reserved space. Enabling it &quot;  \</span>
<span class="udiff-line-modified-added">+           &quot;will make evacuations more resilient when evacuation &quot;           \</span>
<span class="udiff-line-modified-added">+           &quot;reserve/waste is incorrect, at the risk that application &quot;       \</span>
<span class="udiff-line-modified-added">+           &quot;runs out of memory too early.&quot;)                                  \</span>
                                                                              \
    experimental(bool, ShenandoahPacing, true,                                \
            &quot;Pace application allocations to give GC chance to start &quot;        \
            &quot;and complete before allocation failure is reached.&quot;)             \
                                                                              \
    experimental(uintx, ShenandoahPacingMaxDelay, 10,                         \
<span class="udiff-line-modified-removed">-           &quot;Max delay for pacing application allocations. &quot;                  \</span>
<span class="udiff-line-modified-removed">-           &quot;Time is in milliseconds.&quot;)                                       \</span>
<span class="udiff-line-modified-added">+           &quot;Max delay for pacing application allocations. Larger values &quot;    \</span>
<span class="udiff-line-modified-added">+           &quot;provide more resilience against out of memory, at expense at &quot;   \</span>
<span class="udiff-line-added">+           &quot;hiding the GC latencies in the allocation path. Time is in &quot;     \</span>
<span class="udiff-line-added">+           &quot;milliseconds. Setting it to arbitrarily large value makes &quot;      \</span>
<span class="udiff-line-added">+           &quot;GC effectively stall the threads indefinitely instead of going &quot; \</span>
<span class="udiff-line-added">+           &quot;to degenerated or Full GC.&quot;)                                     \</span>
                                                                              \
    experimental(uintx, ShenandoahPacingIdleSlack, 2,                         \
<span class="udiff-line-modified-removed">-           &quot;Percent of heap counted as non-taxable allocations during idle. &quot;\</span>
<span class="udiff-line-modified-removed">-           &quot;Larger value makes the pacing milder during idle phases, &quot;       \</span>
<span class="udiff-line-modified-removed">-           &quot;requiring less rendezvous with control thread. Lower value &quot;     \</span>
<span class="udiff-line-modified-removed">-           &quot;makes the pacing control less responsive to out-of-cycle allocs.&quot;)\</span>
<span class="udiff-line-modified-added">+           &quot;How much of heap counted as non-taxable allocations during idle &quot;\</span>
<span class="udiff-line-modified-added">+           &quot;phases. Larger value makes the pacing milder when collector is &quot; \</span>
<span class="udiff-line-modified-added">+           &quot;idle, requiring less rendezvous with control thread. Lower &quot;     \</span>
<span class="udiff-line-modified-added">+           &quot;value makes the pacing control less responsive to out-of-cycle &quot; \</span>
<span class="udiff-line-added">+           &quot;allocs. In percent of total heap size.&quot;)                         \</span>
            range(0, 100)                                                     \
                                                                              \
    experimental(uintx, ShenandoahPacingCycleSlack, 10,                       \
<span class="udiff-line-modified-removed">-           &quot;Percent of free space taken as non-taxable allocations during &quot;  \</span>
<span class="udiff-line-modified-added">+           &quot;How much of free space to take as non-taxable allocations &quot;      \</span>
            &quot;the GC cycle. Larger value makes the pacing milder at the &quot;      \
            &quot;beginning of the GC cycle. Lower value makes the pacing less &quot;   \
<span class="udiff-line-modified-removed">-           &quot;uniform during the cycle.&quot;)                                      \</span>
<span class="udiff-line-modified-added">+           &quot;uniform during the cycle. In percent of free space.&quot;)            \</span>
            range(0, 100)                                                     \
                                                                              \
    experimental(double, ShenandoahPacingSurcharge, 1.1,                      \
            &quot;Additional pacing tax surcharge to help unclutter the heap. &quot;    \
            &quot;Larger values makes the pacing more aggressive. Lower values &quot;   \
            &quot;risk GC cycles finish with less memory than were available at &quot;  \
            &quot;the beginning of it.&quot;)                                           \
            range(1.0, 100.0)                                                 \
                                                                              \
    experimental(uintx, ShenandoahCriticalFreeThreshold, 1,                   \
<span class="udiff-line-modified-removed">-           &quot;Percent of heap that needs to be free after recovery cycles, &quot;   \</span>
<span class="udiff-line-modified-removed">-           &quot;either Degenerated or Full GC. If this much space is not &quot;       \</span>
<span class="udiff-line-modified-removed">-           &quot;available, next recovery step would triggered.&quot;)                 \</span>
<span class="udiff-line-modified-added">+           &quot;How much of the heap needs to be free after recovery cycles, &quot;   \</span>
<span class="udiff-line-modified-added">+           &quot;either Degenerated or Full GC to be claimed successful. If this &quot;\</span>
<span class="udiff-line-modified-added">+           &quot;much space is not available, next recovery step would be &quot;       \</span>
<span class="udiff-line-added">+           &quot;triggered.&quot;)                                                     \</span>
            range(0, 100)                                                     \
                                                                              \
    diagnostic(bool, ShenandoahDegeneratedGC, true,                           \
<span class="udiff-line-modified-removed">-           &quot;Use Degenerated GC as the graceful degradation step. Disabling &quot; \</span>
<span class="udiff-line-modified-removed">-           &quot;this leads to degradation to Full GC&quot;)                           \</span>
<span class="udiff-line-modified-added">+           &quot;Enable Degenerated GC as the graceful degradation step. &quot;        \</span>
<span class="udiff-line-modified-added">+           &quot;Disabling this option leads to degradation to Full GC instead. &quot; \</span>
<span class="udiff-line-added">+           &quot;When running in passive mode, this can be toggled to measure &quot;   \</span>
<span class="udiff-line-added">+           &quot;either Degenerated GC or Full GC costs.&quot;)                        \</span>
                                                                              \
    experimental(uintx, ShenandoahFullGCThreshold, 3,                         \
<span class="udiff-line-modified-removed">-           &quot;How many back-to-back Degenerated GCs to do before triggering &quot;  \</span>
<span class="udiff-line-modified-removed">-           &quot;a Full GC.&quot;)                                                     \</span>
<span class="udiff-line-modified-added">+           &quot;How many back-to-back Degenerated GCs should happen before &quot;     \</span>
<span class="udiff-line-modified-added">+           &quot;going to a Full GC.&quot;)                                            \</span>
                                                                              \
    experimental(bool, ShenandoahImplicitGCInvokesConcurrent, false,          \
<span class="udiff-line-modified-removed">-           &quot;Should internally-caused GCs invoke concurrent cycles, or go to&quot; \</span>
<span class="udiff-line-modified-removed">-           &quot;stop-the-world (degenerated/full)?&quot;)                             \</span>
<span class="udiff-line-modified-added">+           &quot;Should internally-caused GC requests invoke concurrent cycles, &quot; \</span>
<span class="udiff-line-modified-added">+           &quot;should they do the stop-the-world (Degenerated / Full GC)? &quot;     \</span>
<span class="udiff-line-added">+           &quot;Many heuristics automatically enable this. This option is &quot;      \</span>
<span class="udiff-line-added">+           &quot;similar to global ExplicitGCInvokesConcurrent.&quot;)                 \</span>
                                                                              \
    diagnostic(bool, ShenandoahHumongousMoves, true,                          \
            &quot;Allow moving humongous regions. This makes GC more resistant &quot;   \
            &quot;to external fragmentation that may otherwise fail other &quot;        \
            &quot;humongous allocations, at the expense of higher GC copying &quot;     \
<span class="udiff-line-modified-removed">-           &quot;costs. Currently affects stop-the-world (full) cycle only.&quot;)     \</span>
<span class="udiff-line-modified-added">+           &quot;costs. Currently affects stop-the-world (Full) cycle only.&quot;)     \</span>
                                                                              \
    diagnostic(bool, ShenandoahOOMDuringEvacALot, false,                      \
<span class="udiff-line-modified-removed">-           &quot;Simulate OOM during evacuation frequently.&quot;)                     \</span>
<span class="udiff-line-modified-added">+           &quot;Testing: simulate OOM during evacuation.&quot;)                       \</span>
                                                                              \
    diagnostic(bool, ShenandoahAllocFailureALot, false,                       \
<span class="udiff-line-modified-removed">-           &quot;Make lots of artificial allocation failures.&quot;)                   \</span>
<span class="udiff-line-removed">-                                                                             \</span>
<span class="udiff-line-removed">-   diagnostic(bool, ShenandoahTerminationTrace, false,                       \</span>
<span class="udiff-line-removed">-           &quot;Tracing task termination timings&quot;)                               \</span>
<span class="udiff-line-modified-added">+           &quot;Testing: make lots of artificial allocation failures.&quot;)          \</span>
                                                                              \
    diagnostic(bool, ShenandoahAlwaysPreTouch, false,                         \
<span class="udiff-line-modified-removed">-           &quot;Pre-touch heap memory, overrides global AlwaysPreTouch&quot;)         \</span>
<span class="udiff-line-modified-added">+           &quot;Pre-touch heap memory, overrides global AlwaysPreTouch.&quot;)        \</span>
                                                                              \
    experimental(intx, ShenandoahMarkScanPrefetch, 32,                        \
            &quot;How many objects to prefetch ahead when traversing mark bitmaps.&quot;\
            &quot;Set to 0 to disable prefetching.&quot;)                               \
            range(0, 256)                                                     \
                                                                              \
    experimental(uintx, ShenandoahMarkLoopStride, 1000,                       \
<span class="udiff-line-modified-removed">-           &quot;How many items are processed during one marking step&quot;)           \</span>
<span class="udiff-line-modified-added">+           &quot;How many items to process during one marking iteration before &quot;  \</span>
<span class="udiff-line-added">+           &quot;checking for cancellation, yielding, etc. Larger values improve &quot;\</span>
<span class="udiff-line-added">+           &quot;marking performance at expense of responsiveness.&quot;)              \</span>
                                                                              \
    experimental(uintx, ShenandoahParallelRegionStride, 1024,                 \
<span class="udiff-line-modified-removed">-           &quot;How many regions are processed in one stride during parallel &quot;   \</span>
<span class="udiff-line-modified-removed">-           &quot;iteration.&quot;)                                                     \</span>
<span class="udiff-line-modified-added">+           &quot;How many regions to process at once during parallel region &quot;     \</span>
<span class="udiff-line-modified-added">+           &quot;iteration. Affects heaps with lots of regions.&quot;)                 \</span>
                                                                              \
    experimental(size_t, ShenandoahSATBBufferSize, 1 * K,                     \
            &quot;Number of entries in an SATB log buffer.&quot;)                       \
            range(1, max_uintx)                                               \
                                                                              \
    experimental(uintx, ShenandoahSATBBufferFlushInterval, 100,               \
            &quot;Forcefully flush non-empty SATB buffers at this interval. &quot;      \
            &quot;Time is in milliseconds.&quot;)                                       \
                                                                              \
<span class="udiff-line-modified-removed">-   experimental(uint, ShenandoahParallelSafepointThreads, 4,                 \</span>
<span class="udiff-line-removed">-           &quot;Number of parallel threads used for safepoint prolog/epilog&quot;)    \</span>
<span class="udiff-line-removed">-                                                                             \</span>
<span class="udiff-line-removed">-   experimental(bool, ShenandoahPreclean, true,                              \</span>
<span class="udiff-line-modified-added">+   diagnostic(bool, ShenandoahPreclean, true,                                \</span>
            &quot;Do concurrent preclean phase before final mark: process &quot;        \
            &quot;definitely alive references to avoid dealing with them during &quot;  \
            &quot;pause.&quot;)                                                         \
                                                                              \
    experimental(bool, ShenandoahSuspendibleWorkers, false,                   \
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -361,32 +352,29 @@</span>
            &quot;Turn on/off clone barriers in Shenandoah&quot;)                       \
                                                                              \
    diagnostic(bool, ShenandoahLoadRefBarrier, true,                          \
            &quot;Turn on/off load-reference barriers in Shenandoah&quot;)              \
                                                                              \
<span class="udiff-line-modified-removed">-   experimental(bool, ShenandoahConcurrentScanCodeRoots, true,               \</span>
<span class="udiff-line-modified-added">+   diagnostic(bool, ShenandoahConcurrentScanCodeRoots, true,                 \</span>
            &quot;Scan code roots concurrently, instead of during a pause&quot;)        \
                                                                              \
<span class="udiff-line-modified-removed">-   experimental(uintx, ShenandoahCodeRootsStyle, 2,                          \</span>
<span class="udiff-line-modified-removed">-           &quot;Use this style to scan code cache:&quot;                              \</span>
<span class="udiff-line-modified-added">+   diagnostic(uintx, ShenandoahCodeRootsStyle, 2,                            \</span>
<span class="udiff-line-modified-added">+           &quot;Use this style to scan the code cache roots:&quot;                    \</span>
            &quot; 0 - sequential iterator;&quot;                                       \
            &quot; 1 - parallel iterator;&quot;                                         \
            &quot; 2 - parallel iterator with cset filters;&quot;)                      \
                                                                              \
    diagnostic(bool, ShenandoahOptimizeStaticFinals, true,                    \
            &quot;Optimize barriers on static final fields. &quot;                      \
            &quot;Turn it off for maximum compatibility with reflection or JNI &quot;   \
            &quot;code that manipulates final fields.&quot;)                            \
                                                                              \
<span class="udiff-line-removed">-   experimental(bool, ShenandoahCommonGCStateLoads, false,                   \</span>
<span class="udiff-line-removed">-          &quot;Enable commonming for GC state loads in generated code.&quot;)         \</span>
<span class="udiff-line-removed">-                                                                             \</span>
    develop(bool, ShenandoahVerifyOptoBarriers, false,                        \
<span class="udiff-line-modified-removed">-           &quot;Verify no missing barriers in C2&quot;)                               \</span>
<span class="udiff-line-modified-added">+           &quot;Verify no missing barriers in C2.&quot;)                              \</span>
                                                                              \
<span class="udiff-line-modified-removed">-   experimental(bool, ShenandoahLoopOptsAfterExpansion, true,                \</span>
<span class="udiff-line-modified-removed">-           &quot;Attempt more loop opts after barrier expansion&quot;)                 \</span>
<span class="udiff-line-modified-added">+   diagnostic(bool, ShenandoahLoopOptsAfterExpansion, true,                  \</span>
<span class="udiff-line-modified-added">+           &quot;Attempt more loop opts after barrier expansion.&quot;)                \</span>
                                                                              \
    diagnostic(bool, ShenandoahSelfFixing, true,                              \
            &quot;Fix references with load reference barrier. Disabling this &quot;     \
            &quot;might degrade performance.&quot;)                                     \
  
</pre>
<center><a href="shenandoahVerifier.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../z/c2/zBarrierSetC2.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
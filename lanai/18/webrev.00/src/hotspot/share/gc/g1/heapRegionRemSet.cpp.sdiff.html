<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/heapRegionRemSet.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="heapRegionManager.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegionRemSet.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/heapRegionRemSet.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 75   _n_fine_entries(0),
 76   _first_all_fine_prts(NULL),
 77   _last_all_fine_prts(NULL),
 78   _fine_eviction_start(0),
 79   _sparse_table()
 80 {
 81   typedef PerRegionTable* PerRegionTablePtr;
 82 
 83   if (_max_fine_entries == 0) {
 84     assert(_mod_max_fine_entries_mask == 0, &quot;Both or none.&quot;);
 85     size_t max_entries_log = (size_t)log2_long((jlong)G1RSetRegionEntries);
 86     _max_fine_entries = (size_t)1 &lt;&lt; max_entries_log;
 87     _mod_max_fine_entries_mask = _max_fine_entries - 1;
 88 
 89     assert(_fine_eviction_sample_size == 0
 90            &amp;&amp; _fine_eviction_stride == 0, &quot;All init at same time.&quot;);
 91     _fine_eviction_sample_size = MAX2((size_t)4, max_entries_log);
 92     _fine_eviction_stride = _max_fine_entries / _fine_eviction_sample_size;
 93   }
 94 
<span class="line-modified"> 95   _fine_grain_regions = NEW_C_HEAP_ARRAY3(PerRegionTablePtr, _max_fine_entries,</span>
<span class="line-removed"> 96                         mtGC, CURRENT_PC, AllocFailStrategy::RETURN_NULL);</span>
<span class="line-removed"> 97 </span>
<span class="line-removed"> 98   if (_fine_grain_regions == NULL) {</span>
<span class="line-removed"> 99     vm_exit_out_of_memory(sizeof(void*)*_max_fine_entries, OOM_MALLOC_ERROR,</span>
<span class="line-removed">100                           &quot;Failed to allocate _fine_grain_entries.&quot;);</span>
<span class="line-removed">101   }</span>
<span class="line-removed">102 </span>
103   for (size_t i = 0; i &lt; _max_fine_entries; i++) {
104     _fine_grain_regions[i] = NULL;
105   }
106 }
107 
108 void OtherRegionsTable::link_to_all(PerRegionTable* prt) {
109   // We always append to the beginning of the list for convenience;
110   // the order of entries in this list does not matter.
111   if (_first_all_fine_prts != NULL) {
<span class="line-removed">112     assert(_first_all_fine_prts-&gt;prev() == NULL, &quot;invariant&quot;);</span>
<span class="line-removed">113     _first_all_fine_prts-&gt;set_prev(prt);</span>
114     prt-&gt;set_next(_first_all_fine_prts);
115   } else {
116     // this is the first element we insert. Adjust the &quot;last&quot; pointer
117     _last_all_fine_prts = prt;
118     assert(prt-&gt;next() == NULL, &quot;just checking&quot;);
119   }
<span class="line-removed">120   // the new element is always the first element without a predecessor</span>
<span class="line-removed">121   prt-&gt;set_prev(NULL);</span>
122   _first_all_fine_prts = prt;
123 
<span class="line-removed">124   assert(prt-&gt;prev() == NULL, &quot;just checking&quot;);</span>
125   assert(_first_all_fine_prts == prt, &quot;just checking&quot;);
126   assert((_first_all_fine_prts == NULL &amp;&amp; _last_all_fine_prts == NULL) ||
127          (_first_all_fine_prts != NULL &amp;&amp; _last_all_fine_prts != NULL),
128          &quot;just checking&quot;);
129   assert(_last_all_fine_prts == NULL || _last_all_fine_prts-&gt;next() == NULL,
130          &quot;just checking&quot;);
<span class="line-removed">131   assert(_first_all_fine_prts == NULL || _first_all_fine_prts-&gt;prev() == NULL,</span>
<span class="line-removed">132          &quot;just checking&quot;);</span>
<span class="line-removed">133 }</span>
<span class="line-removed">134 </span>
<span class="line-removed">135 void OtherRegionsTable::unlink_from_all(PerRegionTable* prt) {</span>
<span class="line-removed">136   if (prt-&gt;prev() != NULL) {</span>
<span class="line-removed">137     assert(_first_all_fine_prts != prt, &quot;just checking&quot;);</span>
<span class="line-removed">138     prt-&gt;prev()-&gt;set_next(prt-&gt;next());</span>
<span class="line-removed">139     // removing the last element in the list?</span>
<span class="line-removed">140     if (_last_all_fine_prts == prt) {</span>
<span class="line-removed">141       _last_all_fine_prts = prt-&gt;prev();</span>
<span class="line-removed">142     }</span>
<span class="line-removed">143   } else {</span>
<span class="line-removed">144     assert(_first_all_fine_prts == prt, &quot;just checking&quot;);</span>
<span class="line-removed">145     _first_all_fine_prts = prt-&gt;next();</span>
<span class="line-removed">146     // list is empty now?</span>
<span class="line-removed">147     if (_first_all_fine_prts == NULL) {</span>
<span class="line-removed">148       _last_all_fine_prts = NULL;</span>
<span class="line-removed">149     }</span>
<span class="line-removed">150   }</span>
<span class="line-removed">151 </span>
<span class="line-removed">152   if (prt-&gt;next() != NULL) {</span>
<span class="line-removed">153     prt-&gt;next()-&gt;set_prev(prt-&gt;prev());</span>
<span class="line-removed">154   }</span>
<span class="line-removed">155 </span>
<span class="line-removed">156   prt-&gt;set_next(NULL);</span>
<span class="line-removed">157   prt-&gt;set_prev(NULL);</span>
<span class="line-removed">158 </span>
<span class="line-removed">159   assert((_first_all_fine_prts == NULL &amp;&amp; _last_all_fine_prts == NULL) ||</span>
<span class="line-removed">160          (_first_all_fine_prts != NULL &amp;&amp; _last_all_fine_prts != NULL),</span>
<span class="line-removed">161          &quot;just checking&quot;);</span>
<span class="line-removed">162   assert(_last_all_fine_prts == NULL || _last_all_fine_prts-&gt;next() == NULL,</span>
<span class="line-removed">163          &quot;just checking&quot;);</span>
<span class="line-removed">164   assert(_first_all_fine_prts == NULL || _first_all_fine_prts-&gt;prev() == NULL,</span>
<span class="line-removed">165          &quot;just checking&quot;);</span>
166 }
167 
168 CardIdx_t OtherRegionsTable::card_within_region(OopOrNarrowOopStar within_region, HeapRegion* hr) {
169   assert(hr-&gt;is_in_reserved(within_region),
170          &quot;HeapWord &quot; PTR_FORMAT &quot; is outside of region %u [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
171          p2i(within_region), hr-&gt;hrm_index(), p2i(hr-&gt;bottom()), p2i(hr-&gt;end()));
172   CardIdx_t result = (CardIdx_t)(pointer_delta((HeapWord*)within_region, hr-&gt;bottom()) &gt;&gt; (CardTable::card_shift - LogHeapWordSize));
173   return result;
174 }
175 
176 void OtherRegionsTable::add_reference(OopOrNarrowOopStar from, uint tid) {
177   // Note that this may be a continued H region.
178   HeapRegion* from_hr = _g1h-&gt;heap_region_containing(from);
179   RegionIdx_t from_hrm_ind = (RegionIdx_t) from_hr-&gt;hrm_index();
180 
181   // If the region is already coarsened, return.
182   if (_coarse_map.at(from_hrm_ind)) {
183     assert(contains_reference(from), &quot;We just found &quot; PTR_FORMAT &quot; in the Coarse table&quot;, p2i(from));
184     return;
185   }
</pre>
<hr />
<pre>
230 
231       // Transfer from sparse to fine-grain. The cards from the sparse table
232       // were already added to the total in _num_occupied.
233       SparsePRTEntry *sprt_entry = _sparse_table.get_entry(from_hrm_ind);
234       assert(sprt_entry != NULL, &quot;There should have been an entry&quot;);
235       for (int i = 0; i &lt; sprt_entry-&gt;num_valid_cards(); i++) {
236         CardIdx_t c = sprt_entry-&gt;card(i);
237         prt-&gt;add_card(c);
238       }
239       // Now we can delete the sparse entry.
240       bool res = _sparse_table.delete_entry(from_hrm_ind);
241       assert(res, &quot;It should have been there.&quot;);
242     }
243     assert(prt != NULL &amp;&amp; prt-&gt;hr() == from_hr, &quot;consequence&quot;);
244   }
245   // Note that we can&#39;t assert &quot;prt-&gt;hr() == from_hr&quot;, because of the
246   // possibility of concurrent reuse.  But see head comment of
247   // OtherRegionsTable for why this is OK.
248   assert(prt != NULL, &quot;Inv&quot;);
249 
<span class="line-removed">250   bool added = prt-&gt;add_reference(from);</span>
251   if (prt-&gt;add_reference(from)) {
252     num_added_by_coarsening++;
253   }
254   Atomic::add(&amp;_num_occupied, num_added_by_coarsening, memory_order_relaxed);
255   assert(contains_reference(from), &quot;We just added &quot; PTR_FORMAT &quot; to the PRT (%d)&quot;, p2i(from), prt-&gt;contains_reference(from));
256 }
257 
258 PerRegionTable*
259 OtherRegionsTable::find_region_table(size_t ind, HeapRegion* hr) const {
260   assert(ind &lt; _max_fine_entries, &quot;Preconditions.&quot;);
261   PerRegionTable* prt = _fine_grain_regions[ind];
262   while (prt != NULL &amp;&amp; prt-&gt;hr() != hr) {
263     prt = prt-&gt;collision_list_next();
264   }
265   // Loop postcondition is the method postcondition.
266   return prt;
267 }
268 
269 jint OtherRegionsTable::_n_coarsenings = 0;
270 
</pre>
</td>
<td>
<hr />
<pre>
 75   _n_fine_entries(0),
 76   _first_all_fine_prts(NULL),
 77   _last_all_fine_prts(NULL),
 78   _fine_eviction_start(0),
 79   _sparse_table()
 80 {
 81   typedef PerRegionTable* PerRegionTablePtr;
 82 
 83   if (_max_fine_entries == 0) {
 84     assert(_mod_max_fine_entries_mask == 0, &quot;Both or none.&quot;);
 85     size_t max_entries_log = (size_t)log2_long((jlong)G1RSetRegionEntries);
 86     _max_fine_entries = (size_t)1 &lt;&lt; max_entries_log;
 87     _mod_max_fine_entries_mask = _max_fine_entries - 1;
 88 
 89     assert(_fine_eviction_sample_size == 0
 90            &amp;&amp; _fine_eviction_stride == 0, &quot;All init at same time.&quot;);
 91     _fine_eviction_sample_size = MAX2((size_t)4, max_entries_log);
 92     _fine_eviction_stride = _max_fine_entries / _fine_eviction_sample_size;
 93   }
 94 
<span class="line-modified"> 95   _fine_grain_regions = NEW_C_HEAP_ARRAY(PerRegionTablePtr, _max_fine_entries, mtGC);</span>







 96   for (size_t i = 0; i &lt; _max_fine_entries; i++) {
 97     _fine_grain_regions[i] = NULL;
 98   }
 99 }
100 
101 void OtherRegionsTable::link_to_all(PerRegionTable* prt) {
102   // We always append to the beginning of the list for convenience;
103   // the order of entries in this list does not matter.
104   if (_first_all_fine_prts != NULL) {


105     prt-&gt;set_next(_first_all_fine_prts);
106   } else {
107     // this is the first element we insert. Adjust the &quot;last&quot; pointer
108     _last_all_fine_prts = prt;
109     assert(prt-&gt;next() == NULL, &quot;just checking&quot;);
110   }


111   _first_all_fine_prts = prt;
112 

113   assert(_first_all_fine_prts == prt, &quot;just checking&quot;);
114   assert((_first_all_fine_prts == NULL &amp;&amp; _last_all_fine_prts == NULL) ||
115          (_first_all_fine_prts != NULL &amp;&amp; _last_all_fine_prts != NULL),
116          &quot;just checking&quot;);
117   assert(_last_all_fine_prts == NULL || _last_all_fine_prts-&gt;next() == NULL,
118          &quot;just checking&quot;);



































119 }
120 
121 CardIdx_t OtherRegionsTable::card_within_region(OopOrNarrowOopStar within_region, HeapRegion* hr) {
122   assert(hr-&gt;is_in_reserved(within_region),
123          &quot;HeapWord &quot; PTR_FORMAT &quot; is outside of region %u [&quot; PTR_FORMAT &quot;, &quot; PTR_FORMAT &quot;)&quot;,
124          p2i(within_region), hr-&gt;hrm_index(), p2i(hr-&gt;bottom()), p2i(hr-&gt;end()));
125   CardIdx_t result = (CardIdx_t)(pointer_delta((HeapWord*)within_region, hr-&gt;bottom()) &gt;&gt; (CardTable::card_shift - LogHeapWordSize));
126   return result;
127 }
128 
129 void OtherRegionsTable::add_reference(OopOrNarrowOopStar from, uint tid) {
130   // Note that this may be a continued H region.
131   HeapRegion* from_hr = _g1h-&gt;heap_region_containing(from);
132   RegionIdx_t from_hrm_ind = (RegionIdx_t) from_hr-&gt;hrm_index();
133 
134   // If the region is already coarsened, return.
135   if (_coarse_map.at(from_hrm_ind)) {
136     assert(contains_reference(from), &quot;We just found &quot; PTR_FORMAT &quot; in the Coarse table&quot;, p2i(from));
137     return;
138   }
</pre>
<hr />
<pre>
183 
184       // Transfer from sparse to fine-grain. The cards from the sparse table
185       // were already added to the total in _num_occupied.
186       SparsePRTEntry *sprt_entry = _sparse_table.get_entry(from_hrm_ind);
187       assert(sprt_entry != NULL, &quot;There should have been an entry&quot;);
188       for (int i = 0; i &lt; sprt_entry-&gt;num_valid_cards(); i++) {
189         CardIdx_t c = sprt_entry-&gt;card(i);
190         prt-&gt;add_card(c);
191       }
192       // Now we can delete the sparse entry.
193       bool res = _sparse_table.delete_entry(from_hrm_ind);
194       assert(res, &quot;It should have been there.&quot;);
195     }
196     assert(prt != NULL &amp;&amp; prt-&gt;hr() == from_hr, &quot;consequence&quot;);
197   }
198   // Note that we can&#39;t assert &quot;prt-&gt;hr() == from_hr&quot;, because of the
199   // possibility of concurrent reuse.  But see head comment of
200   // OtherRegionsTable for why this is OK.
201   assert(prt != NULL, &quot;Inv&quot;);
202 

203   if (prt-&gt;add_reference(from)) {
204     num_added_by_coarsening++;
205   }
206   Atomic::add(&amp;_num_occupied, num_added_by_coarsening, memory_order_relaxed);
207   assert(contains_reference(from), &quot;We just added &quot; PTR_FORMAT &quot; to the PRT (%d)&quot;, p2i(from), prt-&gt;contains_reference(from));
208 }
209 
210 PerRegionTable*
211 OtherRegionsTable::find_region_table(size_t ind, HeapRegion* hr) const {
212   assert(ind &lt; _max_fine_entries, &quot;Preconditions.&quot;);
213   PerRegionTable* prt = _fine_grain_regions[ind];
214   while (prt != NULL &amp;&amp; prt-&gt;hr() != hr) {
215     prt = prt-&gt;collision_list_next();
216   }
217   // Loop postcondition is the method postcondition.
218   return prt;
219 }
220 
221 jint OtherRegionsTable::_n_coarsenings = 0;
222 
</pre>
</td>
</tr>
</table>
<center><a href="heapRegionManager.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegionRemSet.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1ConcurrentRefine.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1ConcurrentMarkThread.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1DirtyCardQueue.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1ConcurrentRefine.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 55   _threads(NULL),
 56   _num_max_threads(0)
 57 {
 58 }
 59 
 60 G1ConcurrentRefineThreadControl::~G1ConcurrentRefineThreadControl() {
 61   for (uint i = 0; i &lt; _num_max_threads; i++) {
 62     G1ConcurrentRefineThread* t = _threads[i];
 63     if (t != NULL) {
 64       delete t;
 65     }
 66   }
 67   FREE_C_HEAP_ARRAY(G1ConcurrentRefineThread*, _threads);
 68 }
 69 
 70 jint G1ConcurrentRefineThreadControl::initialize(G1ConcurrentRefine* cr, uint num_max_threads) {
 71   assert(cr != NULL, &quot;G1ConcurrentRefine must not be NULL&quot;);
 72   _cr = cr;
 73   _num_max_threads = num_max_threads;
 74 
<span class="line-modified"> 75   _threads = NEW_C_HEAP_ARRAY_RETURN_NULL(G1ConcurrentRefineThread*, num_max_threads, mtGC);</span>
<span class="line-removed"> 76   if (_threads == NULL) {</span>
<span class="line-removed"> 77     vm_shutdown_during_initialization(&quot;Could not allocate thread holder array.&quot;);</span>
<span class="line-removed"> 78     return JNI_ENOMEM;</span>
<span class="line-removed"> 79   }</span>
 80 
 81   for (uint i = 0; i &lt; num_max_threads; i++) {
 82     if (UseDynamicNumberOfGCThreads &amp;&amp; i != 0 /* Always start first thread. */) {
 83       _threads[i] = NULL;
 84     } else {
 85       _threads[i] = create_refinement_thread(i, true);
 86       if (_threads[i] == NULL) {
 87         vm_shutdown_during_initialization(&quot;Could not allocate refinement threads.&quot;);
 88         return JNI_ENOMEM;
 89       }
 90     }
 91   }
 92 
 93   if (num_max_threads &gt; 0) {
 94     G1BarrierSet::dirty_card_queue_set().set_primary_refinement_thread(_threads[0]);
 95   }
 96 
 97   return JNI_OK;
 98 }
 99 
</pre>
<hr />
<pre>
286   return MIN2(yellow + size, max_red_zone);
287 }
288 
289 G1ConcurrentRefine* G1ConcurrentRefine::create(jint* ecode) {
290   size_t min_yellow_zone_size = calc_min_yellow_zone_size();
291   size_t green_zone = calc_init_green_zone();
292   size_t yellow_zone = calc_init_yellow_zone(green_zone, min_yellow_zone_size);
293   size_t red_zone = calc_init_red_zone(green_zone, yellow_zone);
294 
295   LOG_ZONES(&quot;Initial Refinement Zones: &quot;
296             &quot;green: &quot; SIZE_FORMAT &quot;, &quot;
297             &quot;yellow: &quot; SIZE_FORMAT &quot;, &quot;
298             &quot;red: &quot; SIZE_FORMAT &quot;, &quot;
299             &quot;min yellow size: &quot; SIZE_FORMAT,
300             green_zone, yellow_zone, red_zone, min_yellow_zone_size);
301 
302   G1ConcurrentRefine* cr = new G1ConcurrentRefine(green_zone,
303                                                   yellow_zone,
304                                                   red_zone,
305                                                   min_yellow_zone_size);
<span class="line-removed">306 </span>
<span class="line-removed">307   if (cr == NULL) {</span>
<span class="line-removed">308     *ecode = JNI_ENOMEM;</span>
<span class="line-removed">309     vm_shutdown_during_initialization(&quot;Could not create G1ConcurrentRefine&quot;);</span>
<span class="line-removed">310     return NULL;</span>
<span class="line-removed">311   }</span>
<span class="line-removed">312 </span>
313   *ecode = cr-&gt;initialize();
314   return cr;
315 }
316 
317 void G1ConcurrentRefine::stop() {
318   _thread_control.stop();
319 }
320 
321 G1ConcurrentRefine::~G1ConcurrentRefine() {
322 }
323 
324 void G1ConcurrentRefine::threads_do(ThreadClosure *tc) {
325   _thread_control.worker_threads_do(tc);
326 }
327 
328 uint G1ConcurrentRefine::max_num_threads() {
329   return G1ConcRefinementThreads;
330 }
331 
332 void G1ConcurrentRefine::print_threads_on(outputStream* st) const {
</pre>
<hr />
<pre>
445   return deactivation_level(thresholds);
446 }
447 
448 uint G1ConcurrentRefine::worker_id_offset() {
449   return G1DirtyCardQueueSet::num_par_ids();
450 }
451 
452 void G1ConcurrentRefine::maybe_activate_more_threads(uint worker_id, size_t num_cur_cards) {
453   if (num_cur_cards &gt; activation_threshold(worker_id + 1)) {
454     _thread_control.maybe_activate_next(worker_id);
455   }
456 }
457 
458 bool G1ConcurrentRefine::do_refinement_step(uint worker_id,
459                                             size_t* total_refined_cards) {
460   G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();
461 
462   size_t curr_cards = dcqs.num_cards();
463   // If the number of the cards falls down into the yellow zone,
464   // that means that the transition period after the evacuation pause has ended.
<span class="line-modified">465   // Since the value written to the DCQS is the same for all threads, there is no</span>
<span class="line-modified">466   // need to synchronize.</span>
<span class="line-removed">467   if (dcqs.max_cards_padding() &gt; 0 &amp;&amp; curr_cards &lt;= yellow_zone()) {</span>
<span class="line-removed">468     dcqs.set_max_cards_padding(0);</span>
469   }
470 
471   maybe_activate_more_threads(worker_id, curr_cards);
472 
473   // Process the next buffer, if there are enough left.
474   return dcqs.refine_completed_buffer_concurrently(worker_id + worker_id_offset(),
475                                                    deactivation_threshold(worker_id),
476                                                    total_refined_cards);
477 }
</pre>
</td>
<td>
<hr />
<pre>
 55   _threads(NULL),
 56   _num_max_threads(0)
 57 {
 58 }
 59 
 60 G1ConcurrentRefineThreadControl::~G1ConcurrentRefineThreadControl() {
 61   for (uint i = 0; i &lt; _num_max_threads; i++) {
 62     G1ConcurrentRefineThread* t = _threads[i];
 63     if (t != NULL) {
 64       delete t;
 65     }
 66   }
 67   FREE_C_HEAP_ARRAY(G1ConcurrentRefineThread*, _threads);
 68 }
 69 
 70 jint G1ConcurrentRefineThreadControl::initialize(G1ConcurrentRefine* cr, uint num_max_threads) {
 71   assert(cr != NULL, &quot;G1ConcurrentRefine must not be NULL&quot;);
 72   _cr = cr;
 73   _num_max_threads = num_max_threads;
 74 
<span class="line-modified"> 75   _threads = NEW_C_HEAP_ARRAY(G1ConcurrentRefineThread*, num_max_threads, mtGC);</span>




 76 
 77   for (uint i = 0; i &lt; num_max_threads; i++) {
 78     if (UseDynamicNumberOfGCThreads &amp;&amp; i != 0 /* Always start first thread. */) {
 79       _threads[i] = NULL;
 80     } else {
 81       _threads[i] = create_refinement_thread(i, true);
 82       if (_threads[i] == NULL) {
 83         vm_shutdown_during_initialization(&quot;Could not allocate refinement threads.&quot;);
 84         return JNI_ENOMEM;
 85       }
 86     }
 87   }
 88 
 89   if (num_max_threads &gt; 0) {
 90     G1BarrierSet::dirty_card_queue_set().set_primary_refinement_thread(_threads[0]);
 91   }
 92 
 93   return JNI_OK;
 94 }
 95 
</pre>
<hr />
<pre>
282   return MIN2(yellow + size, max_red_zone);
283 }
284 
285 G1ConcurrentRefine* G1ConcurrentRefine::create(jint* ecode) {
286   size_t min_yellow_zone_size = calc_min_yellow_zone_size();
287   size_t green_zone = calc_init_green_zone();
288   size_t yellow_zone = calc_init_yellow_zone(green_zone, min_yellow_zone_size);
289   size_t red_zone = calc_init_red_zone(green_zone, yellow_zone);
290 
291   LOG_ZONES(&quot;Initial Refinement Zones: &quot;
292             &quot;green: &quot; SIZE_FORMAT &quot;, &quot;
293             &quot;yellow: &quot; SIZE_FORMAT &quot;, &quot;
294             &quot;red: &quot; SIZE_FORMAT &quot;, &quot;
295             &quot;min yellow size: &quot; SIZE_FORMAT,
296             green_zone, yellow_zone, red_zone, min_yellow_zone_size);
297 
298   G1ConcurrentRefine* cr = new G1ConcurrentRefine(green_zone,
299                                                   yellow_zone,
300                                                   red_zone,
301                                                   min_yellow_zone_size);







302   *ecode = cr-&gt;initialize();
303   return cr;
304 }
305 
306 void G1ConcurrentRefine::stop() {
307   _thread_control.stop();
308 }
309 
310 G1ConcurrentRefine::~G1ConcurrentRefine() {
311 }
312 
313 void G1ConcurrentRefine::threads_do(ThreadClosure *tc) {
314   _thread_control.worker_threads_do(tc);
315 }
316 
317 uint G1ConcurrentRefine::max_num_threads() {
318   return G1ConcRefinementThreads;
319 }
320 
321 void G1ConcurrentRefine::print_threads_on(outputStream* st) const {
</pre>
<hr />
<pre>
434   return deactivation_level(thresholds);
435 }
436 
437 uint G1ConcurrentRefine::worker_id_offset() {
438   return G1DirtyCardQueueSet::num_par_ids();
439 }
440 
441 void G1ConcurrentRefine::maybe_activate_more_threads(uint worker_id, size_t num_cur_cards) {
442   if (num_cur_cards &gt; activation_threshold(worker_id + 1)) {
443     _thread_control.maybe_activate_next(worker_id);
444   }
445 }
446 
447 bool G1ConcurrentRefine::do_refinement_step(uint worker_id,
448                                             size_t* total_refined_cards) {
449   G1DirtyCardQueueSet&amp; dcqs = G1BarrierSet::dirty_card_queue_set();
450 
451   size_t curr_cards = dcqs.num_cards();
452   // If the number of the cards falls down into the yellow zone,
453   // that means that the transition period after the evacuation pause has ended.
<span class="line-modified">454   if (curr_cards &lt;= yellow_zone()) {</span>
<span class="line-modified">455     dcqs.discard_max_cards_padding();</span>


456   }
457 
458   maybe_activate_more_threads(worker_id, curr_cards);
459 
460   // Process the next buffer, if there are enough left.
461   return dcqs.refine_completed_buffer_concurrently(worker_id + worker_id_offset(),
462                                                    deactivation_threshold(worker_id),
463                                                    total_refined_cards);
464 }
</pre>
</td>
</tr>
</table>
<center><a href="g1ConcurrentMarkThread.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1DirtyCardQueue.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
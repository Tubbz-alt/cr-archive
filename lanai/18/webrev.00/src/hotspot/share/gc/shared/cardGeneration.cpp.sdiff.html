<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/cardGeneration.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="c2/barrierSetC2.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="cardTable.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/cardGeneration.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 36 #include &quot;memory/memRegion.hpp&quot;
 37 #include &quot;logging/log.hpp&quot;
 38 #include &quot;runtime/java.hpp&quot;
 39 
 40 CardGeneration::CardGeneration(ReservedSpace rs,
 41                                size_t initial_byte_size,
 42                                CardTableRS* remset) :
 43   Generation(rs, initial_byte_size), _rs(remset),
 44   _shrink_factor(0), _min_heap_delta_bytes(), _capacity_at_prologue(),
 45   _used_at_prologue()
 46 {
 47   HeapWord* start = (HeapWord*)rs.base();
 48   size_t reserved_byte_size = rs.size();
 49   assert((uintptr_t(start) &amp; 3) == 0, &quot;bad alignment&quot;);
 50   assert((reserved_byte_size &amp; 3) == 0, &quot;bad alignment&quot;);
 51   MemRegion reserved_mr(start, heap_word_size(reserved_byte_size));
 52   _bts = new BlockOffsetSharedArray(reserved_mr,
 53                                     heap_word_size(initial_byte_size));
 54   MemRegion committed_mr(start, heap_word_size(initial_byte_size));
 55   _rs-&gt;resize_covered_region(committed_mr);
<span class="line-removed"> 56   if (_bts == NULL) {</span>
<span class="line-removed"> 57     vm_exit_during_initialization(&quot;Could not allocate a BlockOffsetArray&quot;);</span>
<span class="line-removed"> 58   }</span>
 59 
 60   // Verify that the start and end of this generation is the start of a card.
 61   // If this wasn&#39;t true, a single card could span more than on generation,
 62   // which would cause problems when we commit/uncommit memory, and when we
 63   // clear and dirty cards.
 64   guarantee(_rs-&gt;is_aligned(reserved_mr.start()), &quot;generation must be card aligned&quot;);
 65   if (reserved_mr.end() != GenCollectedHeap::heap()-&gt;reserved_region().end()) {
 66     // Don&#39;t check at the very end of the heap as we&#39;ll assert that we&#39;re probing off
 67     // the end if we try.
 68     guarantee(_rs-&gt;is_aligned(reserved_mr.end()), &quot;generation must be card aligned&quot;);
 69   }
 70   _min_heap_delta_bytes = MinHeapDeltaBytes;
 71   _capacity_at_prologue = initial_byte_size;
 72   _used_at_prologue = 0;
 73 }
 74 
 75 bool CardGeneration::grow_by(size_t bytes) {
 76   assert_correct_size_change_locking();
 77   bool result = _virtual_space.expand_by(bytes);
 78   if (result) {
</pre>
</td>
<td>
<hr />
<pre>
 36 #include &quot;memory/memRegion.hpp&quot;
 37 #include &quot;logging/log.hpp&quot;
 38 #include &quot;runtime/java.hpp&quot;
 39 
 40 CardGeneration::CardGeneration(ReservedSpace rs,
 41                                size_t initial_byte_size,
 42                                CardTableRS* remset) :
 43   Generation(rs, initial_byte_size), _rs(remset),
 44   _shrink_factor(0), _min_heap_delta_bytes(), _capacity_at_prologue(),
 45   _used_at_prologue()
 46 {
 47   HeapWord* start = (HeapWord*)rs.base();
 48   size_t reserved_byte_size = rs.size();
 49   assert((uintptr_t(start) &amp; 3) == 0, &quot;bad alignment&quot;);
 50   assert((reserved_byte_size &amp; 3) == 0, &quot;bad alignment&quot;);
 51   MemRegion reserved_mr(start, heap_word_size(reserved_byte_size));
 52   _bts = new BlockOffsetSharedArray(reserved_mr,
 53                                     heap_word_size(initial_byte_size));
 54   MemRegion committed_mr(start, heap_word_size(initial_byte_size));
 55   _rs-&gt;resize_covered_region(committed_mr);



 56 
 57   // Verify that the start and end of this generation is the start of a card.
 58   // If this wasn&#39;t true, a single card could span more than on generation,
 59   // which would cause problems when we commit/uncommit memory, and when we
 60   // clear and dirty cards.
 61   guarantee(_rs-&gt;is_aligned(reserved_mr.start()), &quot;generation must be card aligned&quot;);
 62   if (reserved_mr.end() != GenCollectedHeap::heap()-&gt;reserved_region().end()) {
 63     // Don&#39;t check at the very end of the heap as we&#39;ll assert that we&#39;re probing off
 64     // the end if we try.
 65     guarantee(_rs-&gt;is_aligned(reserved_mr.end()), &quot;generation must be card aligned&quot;);
 66   }
 67   _min_heap_delta_bytes = MinHeapDeltaBytes;
 68   _capacity_at_prologue = initial_byte_size;
 69   _used_at_prologue = 0;
 70 }
 71 
 72 bool CardGeneration::grow_by(size_t bytes) {
 73   assert_correct_size_change_locking();
 74   bool result = _virtual_space.expand_by(bytes);
 75   if (result) {
</pre>
</td>
</tr>
</table>
<center><a href="c2/barrierSetC2.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="cardTable.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
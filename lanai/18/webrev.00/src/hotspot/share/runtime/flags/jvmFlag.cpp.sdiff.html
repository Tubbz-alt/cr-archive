<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/flags/jvmFlag.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../deoptimization.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jvmFlag.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/flags/jvmFlag.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 136 }
 137 
 138 void JVMFlag::set_origin(Flags origin) {
 139   assert((origin &amp; VALUE_ORIGIN_MASK) == origin, &quot;sanity&quot;);
 140   Flags new_origin = Flags((origin == COMMAND_LINE) ? Flags(origin | ORIG_COMMAND_LINE) : origin);
 141   _flags = Flags((_flags &amp; ~VALUE_ORIGIN_MASK) | new_origin);
 142 }
 143 
 144 bool JVMFlag::is_default() {
 145   return (get_origin() == DEFAULT);
 146 }
 147 
 148 bool JVMFlag::is_ergonomic() {
 149   return (get_origin() == ERGONOMIC);
 150 }
 151 
 152 bool JVMFlag::is_command_line() {
 153   return (_flags &amp; ORIG_COMMAND_LINE) != 0;
 154 }
 155 




 156 void JVMFlag::set_command_line() {
 157   _flags = Flags(_flags | ORIG_COMMAND_LINE);
 158 }
 159 
 160 bool JVMFlag::is_product() const {
 161   return (_flags &amp; KIND_PRODUCT) != 0;
 162 }
 163 
 164 bool JVMFlag::is_manageable() const {
 165   return (_flags &amp; KIND_MANAGEABLE) != 0;
 166 }
 167 
 168 bool JVMFlag::is_diagnostic() const {
 169   return (_flags &amp; KIND_DIAGNOSTIC) != 0;
 170 }
 171 
 172 bool JVMFlag::is_experimental() const {
 173   return (_flags &amp; KIND_EXPERIMENTAL) != 0;
 174 }
 175 
</pre>
<hr />
<pre>
 822 }
 823 
 824 // Returns the address of the index&#39;th element
 825 JVMFlag* JVMFlagEx::flag_from_enum(JVMFlagsEnum flag) {
 826   assert((size_t)flag &lt; JVMFlag::numFlags, &quot;bad command line flag index&quot;);
 827   return &amp;JVMFlag::flags[flag];
 828 }
 829 
 830 bool JVMFlagEx::is_default(JVMFlagsEnum flag) {
 831   return flag_from_enum(flag)-&gt;is_default();
 832 }
 833 
 834 bool JVMFlagEx::is_ergo(JVMFlagsEnum flag) {
 835   return flag_from_enum(flag)-&gt;is_ergonomic();
 836 }
 837 
 838 bool JVMFlagEx::is_cmdline(JVMFlagsEnum flag) {
 839   return flag_from_enum(flag)-&gt;is_command_line();
 840 }
 841 






 842 void JVMFlagEx::setOnCmdLine(JVMFlagsEnum flag) {
 843   JVMFlag* faddr = flag_from_enum(flag);
 844   assert(faddr != NULL, &quot;Unknown flag&quot;);
 845   faddr-&gt;set_command_line();
 846 }
 847 
 848 template&lt;class E, class T&gt;
 849 static void trace_flag_changed(const JVMFlag* flag, const T old_value, const T new_value, const JVMFlag::Flags origin) {
 850   E e;
 851   e.set_name(flag-&gt;_name);
 852   e.set_oldValue(old_value);
 853   e.set_newValue(new_value);
 854   e.set_origin(origin);
 855   e.commit();
 856 }
 857 
 858 static JVMFlag::Error apply_constraint_and_check_range_bool(const JVMFlag* flag, bool new_value, bool verbose) {
 859   JVMFlag::Error status = JVMFlag::SUCCESS;
 860   JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);
 861   if (constraint != NULL) {
</pre>
</td>
<td>
<hr />
<pre>
 136 }
 137 
 138 void JVMFlag::set_origin(Flags origin) {
 139   assert((origin &amp; VALUE_ORIGIN_MASK) == origin, &quot;sanity&quot;);
 140   Flags new_origin = Flags((origin == COMMAND_LINE) ? Flags(origin | ORIG_COMMAND_LINE) : origin);
 141   _flags = Flags((_flags &amp; ~VALUE_ORIGIN_MASK) | new_origin);
 142 }
 143 
 144 bool JVMFlag::is_default() {
 145   return (get_origin() == DEFAULT);
 146 }
 147 
 148 bool JVMFlag::is_ergonomic() {
 149   return (get_origin() == ERGONOMIC);
 150 }
 151 
 152 bool JVMFlag::is_command_line() {
 153   return (_flags &amp; ORIG_COMMAND_LINE) != 0;
 154 }
 155 
<span class="line-added"> 156 bool JVMFlag::is_jimage_resource() {</span>
<span class="line-added"> 157   return (get_origin() == JIMAGE_RESOURCE);</span>
<span class="line-added"> 158 }</span>
<span class="line-added"> 159 </span>
 160 void JVMFlag::set_command_line() {
 161   _flags = Flags(_flags | ORIG_COMMAND_LINE);
 162 }
 163 
 164 bool JVMFlag::is_product() const {
 165   return (_flags &amp; KIND_PRODUCT) != 0;
 166 }
 167 
 168 bool JVMFlag::is_manageable() const {
 169   return (_flags &amp; KIND_MANAGEABLE) != 0;
 170 }
 171 
 172 bool JVMFlag::is_diagnostic() const {
 173   return (_flags &amp; KIND_DIAGNOSTIC) != 0;
 174 }
 175 
 176 bool JVMFlag::is_experimental() const {
 177   return (_flags &amp; KIND_EXPERIMENTAL) != 0;
 178 }
 179 
</pre>
<hr />
<pre>
 826 }
 827 
 828 // Returns the address of the index&#39;th element
 829 JVMFlag* JVMFlagEx::flag_from_enum(JVMFlagsEnum flag) {
 830   assert((size_t)flag &lt; JVMFlag::numFlags, &quot;bad command line flag index&quot;);
 831   return &amp;JVMFlag::flags[flag];
 832 }
 833 
 834 bool JVMFlagEx::is_default(JVMFlagsEnum flag) {
 835   return flag_from_enum(flag)-&gt;is_default();
 836 }
 837 
 838 bool JVMFlagEx::is_ergo(JVMFlagsEnum flag) {
 839   return flag_from_enum(flag)-&gt;is_ergonomic();
 840 }
 841 
 842 bool JVMFlagEx::is_cmdline(JVMFlagsEnum flag) {
 843   return flag_from_enum(flag)-&gt;is_command_line();
 844 }
 845 
<span class="line-added"> 846 bool JVMFlagEx::is_jimage_resource(JVMFlagsEnum flag) {</span>
<span class="line-added"> 847   assert((size_t)flag &lt; JVMFlag::numFlags, &quot;bad command line flag index&quot;);</span>
<span class="line-added"> 848   JVMFlag* f = &amp;JVMFlag::flags[flag];</span>
<span class="line-added"> 849   return f-&gt;is_jimage_resource();</span>
<span class="line-added"> 850 }</span>
<span class="line-added"> 851 </span>
 852 void JVMFlagEx::setOnCmdLine(JVMFlagsEnum flag) {
 853   JVMFlag* faddr = flag_from_enum(flag);
 854   assert(faddr != NULL, &quot;Unknown flag&quot;);
 855   faddr-&gt;set_command_line();
 856 }
 857 
 858 template&lt;class E, class T&gt;
 859 static void trace_flag_changed(const JVMFlag* flag, const T old_value, const T new_value, const JVMFlag::Flags origin) {
 860   E e;
 861   e.set_name(flag-&gt;_name);
 862   e.set_oldValue(old_value);
 863   e.set_newValue(new_value);
 864   e.set_origin(origin);
 865   e.commit();
 866 }
 867 
 868 static JVMFlag::Error apply_constraint_and_check_range_bool(const JVMFlag* flag, bool new_value, bool verbose) {
 869   JVMFlag::Error status = JVMFlag::SUCCESS;
 870   JVMFlagConstraint* constraint = JVMFlagConstraintList::find_if_needs_check(flag);
 871   if (constraint != NULL) {
</pre>
</td>
</tr>
</table>
<center><a href="../deoptimization.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="jvmFlag.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
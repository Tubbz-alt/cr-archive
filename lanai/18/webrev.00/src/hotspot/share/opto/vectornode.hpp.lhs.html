<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/vectornode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #ifndef SHARE_OPTO_VECTORNODE_HPP
 25 #define SHARE_OPTO_VECTORNODE_HPP
 26 
 27 #include &quot;opto/matcher.hpp&quot;
 28 #include &quot;opto/memnode.hpp&quot;
 29 #include &quot;opto/node.hpp&quot;
 30 #include &quot;opto/opcodes.hpp&quot;
 31 
 32 //------------------------------VectorNode-------------------------------------
 33 // Vector Operation
 34 class VectorNode : public TypeNode {
 35  public:
 36 
 37   VectorNode(Node* n1, const TypeVect* vt) : TypeNode(vt, 2) {
 38     init_class_id(Class_Vector);
 39     init_req(1, n1);
 40   }
 41   VectorNode(Node* n1, Node* n2, const TypeVect* vt) : TypeNode(vt, 3) {
 42     init_class_id(Class_Vector);
 43     init_req(1, n1);
 44     init_req(2, n2);
 45   }
 46 
 47   VectorNode(Node* n1, Node* n2, Node* n3, const TypeVect* vt) : TypeNode(vt, 4) {
 48     init_class_id(Class_Vector);
 49     init_req(1, n1);
 50     init_req(2, n2);
 51     init_req(3, n3);
 52   }
 53 
 54   const TypeVect* vect_type() const { return type()-&gt;is_vect(); }
 55   uint length() const { return vect_type()-&gt;length(); } // Vector length
 56   uint length_in_bytes() const { return vect_type()-&gt;length_in_bytes(); }
 57 
 58   virtual int Opcode() const;
 59 
 60   virtual uint ideal_reg() const { return Matcher::vector_ideal_reg(vect_type()-&gt;length_in_bytes()); }
 61 
 62   static VectorNode* scalar2vector(Node* s, uint vlen, const Type* opd_t);
 63   static VectorNode* shift_count(Node* shift, Node* cnt, uint vlen, BasicType bt);
 64   static VectorNode* make(int opc, Node* n1, Node* n2, uint vlen, BasicType bt);
 65   static VectorNode* make(int opc, Node* n1, Node* n2, Node* n3, uint vlen, BasicType bt);
 66 
 67   static int  opcode(int opc, BasicType bt);
 68   static bool implemented(int opc, uint vlen, BasicType bt);
 69   static bool is_shift(Node* n);
 70   static bool is_type_transition_short_to_int(Node* n);
 71   static bool is_type_transition_to_int(Node* n);
 72   static bool is_muladds2i(Node* n);
 73   static bool is_roundopD(Node * n);
 74   static bool is_invariant_vector(Node* n);
 75   // [Start, end) half-open range defining which operands are vectors
 76   static void vector_operands(Node* n, uint* start, uint* end);
 77 
 78   static bool is_vector_shift(int opc);
<a name="1" id="anc1"></a><span class="line-modified"> 79   static bool is_shift_count(int opc);</span>







 80 };
 81 
 82 //===========================Vector=ALU=Operations=============================
 83 
 84 //------------------------------AddVBNode--------------------------------------
 85 // Vector add byte
 86 class AddVBNode : public VectorNode {
 87  public:
 88   AddVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 89   virtual int Opcode() const;
 90 };
 91 
 92 //------------------------------AddVSNode--------------------------------------
 93 // Vector add char/short
 94 class AddVSNode : public VectorNode {
 95  public:
 96   AddVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 97   virtual int Opcode() const;
 98 };
 99 
100 //------------------------------AddVINode--------------------------------------
101 // Vector add int
102 class AddVINode : public VectorNode {
103  public:
104   AddVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
105   virtual int Opcode() const;
106 };
107 
108 //------------------------------AddVLNode--------------------------------------
109 // Vector add long
110 class AddVLNode : public VectorNode {
111 public:
112   AddVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
113   virtual int Opcode() const;
114 };
115 
116 //------------------------------AddVFNode--------------------------------------
117 // Vector add float
118 class AddVFNode : public VectorNode {
119 public:
120   AddVFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
121   virtual int Opcode() const;
122 };
123 
124 //------------------------------AddVDNode--------------------------------------
125 // Vector add double
126 class AddVDNode : public VectorNode {
127 public:
128   AddVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
129   virtual int Opcode() const;
130 };
131 
132 //------------------------------ReductionNode------------------------------------
133 // Perform reduction of a vector
134 class ReductionNode : public Node {
135  public:
136   ReductionNode(Node *ctrl, Node* in1, Node* in2) : Node(ctrl, in1, in2) {}
137 
138   static ReductionNode* make(int opc, Node *ctrl, Node* in1, Node* in2, BasicType bt);
139   static int  opcode(int opc, BasicType bt);
140   static bool implemented(int opc, uint vlen, BasicType bt);
141 };
142 
143 //------------------------------AddReductionVINode--------------------------------------
144 // Vector add int as a reduction
145 class AddReductionVINode : public ReductionNode {
146 public:
147   AddReductionVINode(Node * ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
148   virtual int Opcode() const;
149   virtual const Type* bottom_type() const { return TypeInt::INT; }
150   virtual uint ideal_reg() const { return Op_RegI; }
151 };
152 
153 //------------------------------AddReductionVLNode--------------------------------------
154 // Vector add long as a reduction
155 class AddReductionVLNode : public ReductionNode {
156 public:
157   AddReductionVLNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
158   virtual int Opcode() const;
159   virtual const Type* bottom_type() const { return TypeLong::LONG; }
160   virtual uint ideal_reg() const { return Op_RegL; }
161 };
162 
163 //------------------------------AddReductionVFNode--------------------------------------
164 // Vector add float as a reduction
165 class AddReductionVFNode : public ReductionNode {
166 public:
167   AddReductionVFNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
168   virtual int Opcode() const;
169   virtual const Type* bottom_type() const { return Type::FLOAT; }
170   virtual uint ideal_reg() const { return Op_RegF; }
171 };
172 
173 //------------------------------AddReductionVDNode--------------------------------------
174 // Vector add double as a reduction
175 class AddReductionVDNode : public ReductionNode {
176 public:
177   AddReductionVDNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
178   virtual int Opcode() const;
179   virtual const Type* bottom_type() const { return Type::DOUBLE; }
180   virtual uint ideal_reg() const { return Op_RegD; }
181 };
182 
183 //------------------------------SubVBNode--------------------------------------
184 // Vector subtract byte
185 class SubVBNode : public VectorNode {
186  public:
187   SubVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
188   virtual int Opcode() const;
189 };
190 
191 //------------------------------SubVSNode--------------------------------------
192 // Vector subtract short
193 class SubVSNode : public VectorNode {
194  public:
195   SubVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
196   virtual int Opcode() const;
197 };
198 
199 //------------------------------SubVINode--------------------------------------
200 // Vector subtract int
201 class SubVINode : public VectorNode {
202  public:
203   SubVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
204   virtual int Opcode() const;
205 };
206 
207 //------------------------------SubVLNode--------------------------------------
208 // Vector subtract long
209 class SubVLNode : public VectorNode {
210  public:
211   SubVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
212   virtual int Opcode() const;
213 };
214 
215 //------------------------------SubVFNode--------------------------------------
216 // Vector subtract float
217 class SubVFNode : public VectorNode {
218  public:
219   SubVFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
220   virtual int Opcode() const;
221 };
222 
223 //------------------------------SubVDNode--------------------------------------
224 // Vector subtract double
225 class SubVDNode : public VectorNode {
226  public:
227   SubVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
228   virtual int Opcode() const;
229 };
230 
231 //------------------------------MulVBNode--------------------------------------
232 // Vector multiply byte
233 class MulVBNode : public VectorNode {
234  public:
235   MulVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
236   virtual int Opcode() const;
237 };
238 
239 //------------------------------MulVSNode--------------------------------------
240 // Vector multiply short
241 class MulVSNode : public VectorNode {
242  public:
243   MulVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
244   virtual int Opcode() const;
245 };
246 
247 //------------------------------MulVINode--------------------------------------
248 // Vector multiply int
249 class MulVINode : public VectorNode {
250  public:
251   MulVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
252   virtual int Opcode() const;
253 };
254 
255 //------------------------------MulVLNode--------------------------------------
256 // Vector multiply long
257 class MulVLNode : public VectorNode {
258 public:
259   MulVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
260   virtual int Opcode() const;
261 };
262 
263 //------------------------------MulVFNode--------------------------------------
264 // Vector multiply float
265 class MulVFNode : public VectorNode {
266 public:
267   MulVFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
268   virtual int Opcode() const;
269 };
270 
271 //------------------------------MulVDNode--------------------------------------
272 // Vector multiply double
273 class MulVDNode : public VectorNode {
274 public:
275   MulVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
276   virtual int Opcode() const;
277 };
278 
279 //------------------------------MulAddVS2VINode--------------------------------
280 // Vector multiply shorts to int and add adjacent ints.
281 class MulAddVS2VINode : public VectorNode {
282   public:
283     MulAddVS2VINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
284     virtual int Opcode() const;
285 };
286 
287 //------------------------------FmaVDNode--------------------------------------
288 // Vector multiply double
289 class FmaVDNode : public VectorNode {
290 public:
291   FmaVDNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt) : VectorNode(in1, in2, in3, vt) {}
292   virtual int Opcode() const;
293 };
294 
295 //------------------------------FmaVFNode--------------------------------------
296 // Vector multiply float
297 class FmaVFNode : public VectorNode {
298 public:
299   FmaVFNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt) : VectorNode(in1, in2, in3, vt) {}
300   virtual int Opcode() const;
301 };
302 
303 //------------------------------CMoveVFNode--------------------------------------
304 // Vector float conditional move
305 class CMoveVFNode : public VectorNode {
306 public:
307   CMoveVFNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt) : VectorNode(in1, in2, in3, vt) {}
308   virtual int Opcode() const;
309 };
310 
311 //------------------------------CMoveVDNode--------------------------------------
312 // Vector double conditional move
313 class CMoveVDNode : public VectorNode {
314 public:
315   CMoveVDNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt) : VectorNode(in1, in2, in3, vt) {}
316   virtual int Opcode() const;
317 };
318 
319 //------------------------------MulReductionVINode--------------------------------------
320 // Vector multiply int as a reduction
321 class MulReductionVINode : public ReductionNode {
322 public:
323   MulReductionVINode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
324   virtual int Opcode() const;
325   virtual const Type* bottom_type() const { return TypeInt::INT; }
326   virtual uint ideal_reg() const { return Op_RegI; }
327 };
328 
329 //------------------------------MulReductionVLNode--------------------------------------
330 // Vector multiply int as a reduction
331 class MulReductionVLNode : public ReductionNode {
332 public:
333   MulReductionVLNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
334   virtual int Opcode() const;
335   virtual const Type* bottom_type() const { return TypeLong::LONG; }
336   virtual uint ideal_reg() const { return Op_RegI; }
337 };
338 
339 //------------------------------MulReductionVFNode--------------------------------------
340 // Vector multiply float as a reduction
341 class MulReductionVFNode : public ReductionNode {
342 public:
343   MulReductionVFNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
344   virtual int Opcode() const;
345   virtual const Type* bottom_type() const { return Type::FLOAT; }
346   virtual uint ideal_reg() const { return Op_RegF; }
347 };
348 
349 //------------------------------MulReductionVDNode--------------------------------------
350 // Vector multiply double as a reduction
351 class MulReductionVDNode : public ReductionNode {
352 public:
353   MulReductionVDNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
354   virtual int Opcode() const;
355   virtual const Type* bottom_type() const { return Type::DOUBLE; }
356   virtual uint ideal_reg() const { return Op_RegD; }
357 };
358 
359 //------------------------------DivVFNode--------------------------------------
360 // Vector divide float
361 class DivVFNode : public VectorNode {
362  public:
363   DivVFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
364   virtual int Opcode() const;
365 };
366 
367 //------------------------------DivVDNode--------------------------------------
368 // Vector Divide double
369 class DivVDNode : public VectorNode {
370  public:
371   DivVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
372   virtual int Opcode() const;
373 };
374 
375 //------------------------------AbsVBNode--------------------------------------
376 // Vector Abs byte
377 class AbsVBNode : public VectorNode {
378 public:
379   AbsVBNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {}
380   virtual int Opcode() const;
381 };
382 
383 //------------------------------AbsVSNode--------------------------------------
384 // Vector Abs short
385 class AbsVSNode : public VectorNode {
386 public:
387   AbsVSNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {}
388   virtual int Opcode() const;
389 };
390 
391 //------------------------------AbsVINode--------------------------------------
392 // Vector Abs int
393 class AbsVINode : public VectorNode {
394 public:
395   AbsVINode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {}
396   virtual int Opcode() const;
397 };
398 
399 //------------------------------AbsVLNode--------------------------------------
400 // Vector Abs long
401 class AbsVLNode : public VectorNode {
402 public:
403   AbsVLNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {}
404   virtual int Opcode() const;
405 };
406 
407 //------------------------------AbsVFNode--------------------------------------
408 // Vector Abs float
409 class AbsVFNode : public VectorNode {
410  public:
411   AbsVFNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}
412   virtual int Opcode() const;
413 };
414 
415 //------------------------------AbsVDNode--------------------------------------
416 // Vector Abs double
417 class AbsVDNode : public VectorNode {
418  public:
419   AbsVDNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}
420   virtual int Opcode() const;
421 };
422 
423 //------------------------------NegVFNode--------------------------------------
424 // Vector Neg float
425 class NegVFNode : public VectorNode {
426  public:
427   NegVFNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}
428   virtual int Opcode() const;
429 };
430 
431 //------------------------------NegVDNode--------------------------------------
432 // Vector Neg double
433 class NegVDNode : public VectorNode {
434  public:
435   NegVDNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}
436   virtual int Opcode() const;
437 };
438 
439 //------------------------------PopCountVINode---------------------------------
440 // Vector popcount integer bits
441 class PopCountVINode : public VectorNode {
442  public:
443   PopCountVINode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}
444   virtual int Opcode() const;
445 };
446 
447 //------------------------------SqrtVFNode--------------------------------------
448 // Vector Sqrt float
449 class SqrtVFNode : public VectorNode {
450  public:
451   SqrtVFNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}
452   virtual int Opcode() const;
453 };
454 //------------------------------RoundDoubleVNode--------------------------------
455 // Vector round double
456 class RoundDoubleModeVNode : public VectorNode {
457  public:
458   RoundDoubleModeVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
459   virtual int Opcode() const;
460 };
461 
462 //------------------------------SqrtVDNode--------------------------------------
463 // Vector Sqrt double
464 class SqrtVDNode : public VectorNode {
465  public:
466   SqrtVDNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}
467   virtual int Opcode() const;
468 };
469 
470 //------------------------------LShiftVBNode-----------------------------------
471 // Vector left shift bytes
472 class LShiftVBNode : public VectorNode {
473  public:
474   LShiftVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
475   virtual int Opcode() const;
476 };
477 
478 //------------------------------LShiftVSNode-----------------------------------
479 // Vector left shift shorts
480 class LShiftVSNode : public VectorNode {
481  public:
482   LShiftVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
483   virtual int Opcode() const;
484 };
485 
486 //------------------------------LShiftVINode-----------------------------------
487 // Vector left shift ints
488 class LShiftVINode : public VectorNode {
489  public:
490   LShiftVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
491   virtual int Opcode() const;
492 };
493 
494 //------------------------------LShiftVLNode-----------------------------------
495 // Vector left shift longs
496 class LShiftVLNode : public VectorNode {
497  public:
498   LShiftVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
499   virtual int Opcode() const;
500 };
501 
502 //------------------------------RShiftVBNode-----------------------------------
503 // Vector right arithmetic (signed) shift bytes
504 class RShiftVBNode : public VectorNode {
505  public:
506   RShiftVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
507   virtual int Opcode() const;
508 };
509 
510 //------------------------------RShiftVSNode-----------------------------------
511 // Vector right arithmetic (signed) shift shorts
512 class RShiftVSNode : public VectorNode {
513  public:
514   RShiftVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
515   virtual int Opcode() const;
516 };
517 
518 //------------------------------RShiftVINode-----------------------------------
519 // Vector right arithmetic (signed) shift ints
520 class RShiftVINode : public VectorNode {
521  public:
522   RShiftVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
523   virtual int Opcode() const;
524 };
525 
526 //------------------------------RShiftVLNode-----------------------------------
527 // Vector right arithmetic (signed) shift longs
528 class RShiftVLNode : public VectorNode {
529  public:
530   RShiftVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
531   virtual int Opcode() const;
532 };
533 
534 //------------------------------URShiftVBNode----------------------------------
535 // Vector right logical (unsigned) shift bytes
536 class URShiftVBNode : public VectorNode {
537  public:
538   URShiftVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
539   virtual int Opcode() const;
540 };
541 
542 //------------------------------URShiftVSNode----------------------------------
543 // Vector right logical (unsigned) shift shorts
544 class URShiftVSNode : public VectorNode {
545  public:
546   URShiftVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
547   virtual int Opcode() const;
548 };
549 
550 //------------------------------URShiftVINode----------------------------------
551 // Vector right logical (unsigned) shift ints
552 class URShiftVINode : public VectorNode {
553  public:
554   URShiftVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
555   virtual int Opcode() const;
556 };
557 
558 //------------------------------URShiftVLNode----------------------------------
559 // Vector right logical (unsigned) shift longs
560 class URShiftVLNode : public VectorNode {
561  public:
562   URShiftVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
563   virtual int Opcode() const;
564 };
565 
566 //------------------------------LShiftCntVNode---------------------------------
567 // Vector left shift count
568 class LShiftCntVNode : public VectorNode {
569  public:
570   LShiftCntVNode(Node* cnt, const TypeVect* vt) : VectorNode(cnt,vt) {}
571   virtual int Opcode() const;
572   virtual uint ideal_reg() const { return Matcher::vector_shift_count_ideal_reg(vect_type()-&gt;length_in_bytes()); }
573 };
574 
575 //------------------------------RShiftCntVNode---------------------------------
576 // Vector right shift count
577 class RShiftCntVNode : public VectorNode {
578  public:
579   RShiftCntVNode(Node* cnt, const TypeVect* vt) : VectorNode(cnt,vt) {}
580   virtual int Opcode() const;
581   virtual uint ideal_reg() const { return Matcher::vector_shift_count_ideal_reg(vect_type()-&gt;length_in_bytes()); }
582 };
583 
584 
585 //------------------------------AndVNode---------------------------------------
586 // Vector and integer
587 class AndVNode : public VectorNode {
588  public:
589   AndVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
590   virtual int Opcode() const;
591 };
592 
593 //------------------------------OrVNode---------------------------------------
594 // Vector or integer
595 class OrVNode : public VectorNode {
596  public:
597   OrVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
598   virtual int Opcode() const;
599 };
600 
601 //------------------------------XorVNode---------------------------------------
602 // Vector xor integer
603 class XorVNode : public VectorNode {
604  public:
605   XorVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
606   virtual int Opcode() const;
607 };
608 
609 //------------------------------MinVNode--------------------------------------
610 // Vector min
611 class MinVNode : public VectorNode {
612 public:
613   MinVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
614   virtual int Opcode() const;
615 };
616 
617 //------------------------------MaxVNode--------------------------------------
618 // Vector max
619 class MaxVNode : public VectorNode {
620 public:
621   MaxVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
622   virtual int Opcode() const;
623 };
624 
625 //------------------------------MinReductionVNode--------------------------------------
626 // Vector min as a reduction
627 class MinReductionVNode : public ReductionNode {
628 public:
629   MinReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
630   virtual int Opcode() const;
631   virtual const Type* bottom_type() const {
632     BasicType bt = in(1)-&gt;bottom_type()-&gt;basic_type();
633     if (bt == T_FLOAT) {
634       return Type::FLOAT;
635     } else if (bt == T_DOUBLE) {
636       return Type::DOUBLE;
637     }
638     assert(false, &quot;unsupported basic type&quot;);
639     return NULL;
640   }
641   virtual uint ideal_reg() const {
642     BasicType bt = in(1)-&gt;bottom_type()-&gt;basic_type();
643     if (bt == T_FLOAT) {
644       return Op_RegF;
645     } else if (bt == T_DOUBLE) {
646       return Op_RegD;
647     }
648     assert(false, &quot;unsupported basic type&quot;);
649     return 0;
650   }
651 };
652 
653 //------------------------------MaxReductionVNode--------------------------------------
654 // Vector max as a reduction
655 class MaxReductionVNode : public ReductionNode {
656 public:
657   MaxReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
658   virtual int Opcode() const;
659   virtual const Type* bottom_type() const {
660     BasicType bt = in(1)-&gt;bottom_type()-&gt;basic_type();
661     if (bt == T_FLOAT) {
662       return Type::FLOAT;
663     } else {
664       return Type::DOUBLE;
665     }
666     assert(false, &quot;unsupported basic type&quot;);
667     return NULL;
668   }
669   virtual uint ideal_reg() const {
670     BasicType bt = in(1)-&gt;bottom_type()-&gt;basic_type();
671     if (bt == T_FLOAT) {
672       return Op_RegF;
673     } else {
674       return Op_RegD;
675     }
676     assert(false, &quot;unsupported basic type&quot;);
677     return 0;
678   }
679 };
680 
681 //================================= M E M O R Y ===============================
682 
683 //------------------------------LoadVectorNode---------------------------------
684 // Load Vector from memory
685 class LoadVectorNode : public LoadNode {
686  public:
687   LoadVectorNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, ControlDependency control_dependency = LoadNode::DependsOnlyOnTest)
688     : LoadNode(c, mem, adr, at, vt, MemNode::unordered, control_dependency) {
689     init_class_id(Class_LoadVector);
690     set_mismatched_access();
691   }
692 
693   const TypeVect* vect_type() const { return type()-&gt;is_vect(); }
694   uint length() const { return vect_type()-&gt;length(); } // Vector length
695 
696   virtual int Opcode() const;
697 
698   virtual uint ideal_reg() const  { return Matcher::vector_ideal_reg(memory_size()); }
699   virtual BasicType memory_type() const { return T_VOID; }
700   virtual int memory_size() const { return vect_type()-&gt;length_in_bytes(); }
701 
702   virtual int store_Opcode() const { return Op_StoreVector; }
703 
704   static LoadVectorNode* make(int opc, Node* ctl, Node* mem,
705                               Node* adr, const TypePtr* atyp,
706                               uint vlen, BasicType bt,
707                               ControlDependency control_dependency = LoadNode::DependsOnlyOnTest);
708   uint element_size(void) { return type2aelembytes(vect_type()-&gt;element_basic_type()); }
709 };
710 
711 //------------------------------StoreVectorNode--------------------------------
712 // Store Vector to memory
713 class StoreVectorNode : public StoreNode {
714  public:
715   StoreVectorNode(Node* c, Node* mem, Node* adr, const TypePtr* at, Node* val)
716     : StoreNode(c, mem, adr, at, val, MemNode::unordered) {
717     assert(val-&gt;is_Vector() || val-&gt;is_LoadVector(), &quot;sanity&quot;);
718     init_class_id(Class_StoreVector);
719     set_mismatched_access();
720   }
721 
722   const TypeVect* vect_type() const { return in(MemNode::ValueIn)-&gt;bottom_type()-&gt;is_vect(); }
723   uint length() const { return vect_type()-&gt;length(); } // Vector length
724 
725   virtual int Opcode() const;
726 
727   virtual uint ideal_reg() const  { return Matcher::vector_ideal_reg(memory_size()); }
728   virtual BasicType memory_type() const { return T_VOID; }
729   virtual int memory_size() const { return vect_type()-&gt;length_in_bytes(); }
730 
731   static StoreVectorNode* make(int opc, Node* ctl, Node* mem,
732                                Node* adr, const TypePtr* atyp, Node* val,
733                                uint vlen);
734 
735   uint element_size(void) { return type2aelembytes(vect_type()-&gt;element_basic_type()); }
736 };
737 
738 
739 //=========================Promote_Scalar_to_Vector============================
740 
741 //------------------------------ReplicateBNode---------------------------------
742 // Replicate byte scalar to be vector
743 class ReplicateBNode : public VectorNode {
744  public:
745   ReplicateBNode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}
746   virtual int Opcode() const;
747 };
748 
749 //------------------------------ReplicateSNode---------------------------------
750 // Replicate short scalar to be vector
751 class ReplicateSNode : public VectorNode {
752  public:
753   ReplicateSNode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}
754   virtual int Opcode() const;
755 };
756 
757 //------------------------------ReplicateINode---------------------------------
758 // Replicate int scalar to be vector
759 class ReplicateINode : public VectorNode {
760  public:
761   ReplicateINode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}
762   virtual int Opcode() const;
763 };
764 
765 //------------------------------ReplicateLNode---------------------------------
766 // Replicate long scalar to be vector
767 class ReplicateLNode : public VectorNode {
768  public:
769   ReplicateLNode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}
770   virtual int Opcode() const;
771 };
772 
773 //------------------------------ReplicateFNode---------------------------------
774 // Replicate float scalar to be vector
775 class ReplicateFNode : public VectorNode {
776  public:
777   ReplicateFNode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}
778   virtual int Opcode() const;
779 };
780 
781 //------------------------------ReplicateDNode---------------------------------
782 // Replicate double scalar to be vector
783 class ReplicateDNode : public VectorNode {
784  public:
785   ReplicateDNode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}
786   virtual int Opcode() const;
787 };
788 
789 //========================Pack_Scalars_into_a_Vector===========================
790 
791 //------------------------------PackNode---------------------------------------
792 // Pack parent class (not for code generation).
793 class PackNode : public VectorNode {
794  public:
795   PackNode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}
796   PackNode(Node* in1, Node* n2, const TypeVect* vt) : VectorNode(in1, n2, vt) {}
797   virtual int Opcode() const;
798 
799   void add_opd(Node* n) {
800     add_req(n);
801   }
802 
803   // Create a binary tree form for Packs. [lo, hi) (half-open) range
804   PackNode* binary_tree_pack(int lo, int hi);
805 
806   static PackNode* make(Node* s, uint vlen, BasicType bt);
807 };
808 
809 //------------------------------PackBNode--------------------------------------
810 // Pack byte scalars into vector
811 class PackBNode : public PackNode {
812  public:
813   PackBNode(Node* in1, const TypeVect* vt)  : PackNode(in1, vt) {}
814   virtual int Opcode() const;
815 };
816 
817 //------------------------------PackSNode--------------------------------------
818 // Pack short scalars into a vector
819 class PackSNode : public PackNode {
820  public:
821   PackSNode(Node* in1, const TypeVect* vt)  : PackNode(in1, vt) {}
822   PackSNode(Node* in1, Node* in2, const TypeVect* vt) : PackNode(in1, in2, vt) {}
823   virtual int Opcode() const;
824 };
825 
826 //------------------------------PackINode--------------------------------------
827 // Pack integer scalars into a vector
828 class PackINode : public PackNode {
829  public:
830   PackINode(Node* in1, const TypeVect* vt)  : PackNode(in1, vt) {}
831   PackINode(Node* in1, Node* in2, const TypeVect* vt) : PackNode(in1, in2, vt) {}
832   virtual int Opcode() const;
833 };
834 
835 //------------------------------PackLNode--------------------------------------
836 // Pack long scalars into a vector
837 class PackLNode : public PackNode {
838  public:
839   PackLNode(Node* in1, const TypeVect* vt)  : PackNode(in1, vt) {}
840   PackLNode(Node* in1, Node* in2, const TypeVect* vt) : PackNode(in1, in2, vt) {}
841   virtual int Opcode() const;
842 };
843 
844 //------------------------------Pack2LNode-------------------------------------
845 // Pack 2 long scalars into a vector
846 class Pack2LNode : public PackNode {
847  public:
848   Pack2LNode(Node* in1, Node* in2, const TypeVect* vt) : PackNode(in1, in2, vt) {}
849   virtual int Opcode() const;
850 };
851 
852 //------------------------------PackFNode--------------------------------------
853 // Pack float scalars into vector
854 class PackFNode : public PackNode {
855  public:
856   PackFNode(Node* in1, const TypeVect* vt)  : PackNode(in1, vt) {}
857   PackFNode(Node* in1, Node* in2, const TypeVect* vt) : PackNode(in1, in2, vt) {}
858   virtual int Opcode() const;
859 };
860 
861 //------------------------------PackDNode--------------------------------------
862 // Pack double scalars into a vector
863 class PackDNode : public PackNode {
864  public:
865   PackDNode(Node* in1, const TypeVect* vt) : PackNode(in1, vt) {}
866   PackDNode(Node* in1, Node* in2, const TypeVect* vt) : PackNode(in1, in2, vt) {}
867   virtual int Opcode() const;
868 };
869 
870 //------------------------------Pack2DNode-------------------------------------
871 // Pack 2 double scalars into a vector
872 class Pack2DNode : public PackNode {
873  public:
874   Pack2DNode(Node* in1, Node* in2, const TypeVect* vt) : PackNode(in1, in2, vt) {}
875   virtual int Opcode() const;
876 };
877 
878 
879 //========================Extract_Scalar_from_Vector===========================
880 
881 //------------------------------ExtractNode------------------------------------
882 // Extract a scalar from a vector at position &quot;pos&quot;
883 class ExtractNode : public Node {
884  public:
885   ExtractNode(Node* src, ConINode* pos) : Node(NULL, src, (Node*)pos) {
886     assert(in(2)-&gt;get_int() &gt;= 0, &quot;positive constants&quot;);
887   }
888   virtual int Opcode() const;
889   uint  pos() const { return in(2)-&gt;get_int(); }
890 
891   static Node* make(Node* v, uint position, BasicType bt);
892 };
893 
894 //------------------------------ExtractBNode-----------------------------------
895 // Extract a byte from a vector at position &quot;pos&quot;
896 class ExtractBNode : public ExtractNode {
897  public:
898   ExtractBNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
899   virtual int Opcode() const;
900   virtual const Type *bottom_type() const { return TypeInt::INT; }
901   virtual uint ideal_reg() const { return Op_RegI; }
902 };
903 
904 //------------------------------ExtractUBNode----------------------------------
905 // Extract a boolean from a vector at position &quot;pos&quot;
906 class ExtractUBNode : public ExtractNode {
907  public:
908   ExtractUBNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
909   virtual int Opcode() const;
910   virtual const Type *bottom_type() const { return TypeInt::INT; }
911   virtual uint ideal_reg() const { return Op_RegI; }
912 };
913 
914 //------------------------------ExtractCNode-----------------------------------
915 // Extract a char from a vector at position &quot;pos&quot;
916 class ExtractCNode : public ExtractNode {
917  public:
918   ExtractCNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
919   virtual int Opcode() const;
920   virtual const Type *bottom_type() const { return TypeInt::INT; }
921   virtual uint ideal_reg() const { return Op_RegI; }
922 };
923 
924 //------------------------------ExtractSNode-----------------------------------
925 // Extract a short from a vector at position &quot;pos&quot;
926 class ExtractSNode : public ExtractNode {
927  public:
928   ExtractSNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
929   virtual int Opcode() const;
930   virtual const Type *bottom_type() const { return TypeInt::INT; }
931   virtual uint ideal_reg() const { return Op_RegI; }
932 };
933 
934 //------------------------------ExtractINode-----------------------------------
935 // Extract an int from a vector at position &quot;pos&quot;
936 class ExtractINode : public ExtractNode {
937  public:
938   ExtractINode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
939   virtual int Opcode() const;
940   virtual const Type *bottom_type() const { return TypeInt::INT; }
941   virtual uint ideal_reg() const { return Op_RegI; }
942 };
943 
944 //------------------------------ExtractLNode-----------------------------------
945 // Extract a long from a vector at position &quot;pos&quot;
946 class ExtractLNode : public ExtractNode {
947  public:
948   ExtractLNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
949   virtual int Opcode() const;
950   virtual const Type *bottom_type() const { return TypeLong::LONG; }
951   virtual uint ideal_reg() const { return Op_RegL; }
952 };
953 
954 //------------------------------ExtractFNode-----------------------------------
955 // Extract a float from a vector at position &quot;pos&quot;
956 class ExtractFNode : public ExtractNode {
957  public:
958   ExtractFNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
959   virtual int Opcode() const;
960   virtual const Type *bottom_type() const { return Type::FLOAT; }
961   virtual uint ideal_reg() const { return Op_RegF; }
962 };
963 
964 //------------------------------ExtractDNode-----------------------------------
965 // Extract a double from a vector at position &quot;pos&quot;
966 class ExtractDNode : public ExtractNode {
967  public:
968   ExtractDNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
969   virtual int Opcode() const;
970   virtual const Type *bottom_type() const { return Type::DOUBLE; }
971   virtual uint ideal_reg() const { return Op_RegD; }
972 };
973 
974 //------------------------------SetVectMaskINode-------------------------------
975 // Provide a mask for a vector predicate machine
976 class SetVectMaskINode : public Node {
977 public:
978   SetVectMaskINode(Node *c, Node *in1) : Node(c, in1) {}
979   virtual int Opcode() const;
980   const Type *bottom_type() const { return TypeInt::INT; }
981   virtual uint ideal_reg() const { return Op_RegI; }
982   virtual const Type *Value(PhaseGVN *phase) const { return TypeInt::INT; }
983 };
984 
985 #endif // SHARE_OPTO_VECTORNODE_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/vectornode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 #ifndef SHARE_OPTO_VECTORNODE_HPP
 25 #define SHARE_OPTO_VECTORNODE_HPP
 26 
 27 #include &quot;opto/matcher.hpp&quot;
 28 #include &quot;opto/memnode.hpp&quot;
 29 #include &quot;opto/node.hpp&quot;
 30 #include &quot;opto/opcodes.hpp&quot;
 31 
 32 //------------------------------VectorNode-------------------------------------
 33 // Vector Operation
 34 class VectorNode : public TypeNode {
 35  public:
 36 
 37   VectorNode(Node* n1, const TypeVect* vt) : TypeNode(vt, 2) {
 38     init_class_id(Class_Vector);
 39     init_req(1, n1);
 40   }
 41   VectorNode(Node* n1, Node* n2, const TypeVect* vt) : TypeNode(vt, 3) {
 42     init_class_id(Class_Vector);
 43     init_req(1, n1);
 44     init_req(2, n2);
 45   }
 46 
 47   VectorNode(Node* n1, Node* n2, Node* n3, const TypeVect* vt) : TypeNode(vt, 4) {
 48     init_class_id(Class_Vector);
 49     init_req(1, n1);
 50     init_req(2, n2);
 51     init_req(3, n3);
 52   }
 53 
 54   const TypeVect* vect_type() const { return type()-&gt;is_vect(); }
 55   uint length() const { return vect_type()-&gt;length(); } // Vector length
 56   uint length_in_bytes() const { return vect_type()-&gt;length_in_bytes(); }
 57 
 58   virtual int Opcode() const;
 59 
 60   virtual uint ideal_reg() const { return Matcher::vector_ideal_reg(vect_type()-&gt;length_in_bytes()); }
 61 
 62   static VectorNode* scalar2vector(Node* s, uint vlen, const Type* opd_t);
 63   static VectorNode* shift_count(Node* shift, Node* cnt, uint vlen, BasicType bt);
 64   static VectorNode* make(int opc, Node* n1, Node* n2, uint vlen, BasicType bt);
 65   static VectorNode* make(int opc, Node* n1, Node* n2, Node* n3, uint vlen, BasicType bt);
 66 
 67   static int  opcode(int opc, BasicType bt);
 68   static bool implemented(int opc, uint vlen, BasicType bt);
 69   static bool is_shift(Node* n);
 70   static bool is_type_transition_short_to_int(Node* n);
 71   static bool is_type_transition_to_int(Node* n);
 72   static bool is_muladds2i(Node* n);
 73   static bool is_roundopD(Node * n);
 74   static bool is_invariant_vector(Node* n);
 75   // [Start, end) half-open range defining which operands are vectors
 76   static void vector_operands(Node* n, uint* start, uint* end);
 77 
 78   static bool is_vector_shift(int opc);
<a name="1" id="anc1"></a><span class="line-modified"> 79   static bool is_vector_shift_count(int opc);</span>
<span class="line-added"> 80 </span>
<span class="line-added"> 81   static bool is_vector_shift(Node* n) {</span>
<span class="line-added"> 82     return is_vector_shift(n-&gt;Opcode());</span>
<span class="line-added"> 83   }</span>
<span class="line-added"> 84   static bool is_vector_shift_count(Node* n) {</span>
<span class="line-added"> 85     return is_vector_shift_count(n-&gt;Opcode());</span>
<span class="line-added"> 86   }</span>
 87 };
 88 
 89 //===========================Vector=ALU=Operations=============================
 90 
 91 //------------------------------AddVBNode--------------------------------------
 92 // Vector add byte
 93 class AddVBNode : public VectorNode {
 94  public:
 95   AddVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
 96   virtual int Opcode() const;
 97 };
 98 
 99 //------------------------------AddVSNode--------------------------------------
100 // Vector add char/short
101 class AddVSNode : public VectorNode {
102  public:
103   AddVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
104   virtual int Opcode() const;
105 };
106 
107 //------------------------------AddVINode--------------------------------------
108 // Vector add int
109 class AddVINode : public VectorNode {
110  public:
111   AddVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
112   virtual int Opcode() const;
113 };
114 
115 //------------------------------AddVLNode--------------------------------------
116 // Vector add long
117 class AddVLNode : public VectorNode {
118 public:
119   AddVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
120   virtual int Opcode() const;
121 };
122 
123 //------------------------------AddVFNode--------------------------------------
124 // Vector add float
125 class AddVFNode : public VectorNode {
126 public:
127   AddVFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
128   virtual int Opcode() const;
129 };
130 
131 //------------------------------AddVDNode--------------------------------------
132 // Vector add double
133 class AddVDNode : public VectorNode {
134 public:
135   AddVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
136   virtual int Opcode() const;
137 };
138 
139 //------------------------------ReductionNode------------------------------------
140 // Perform reduction of a vector
141 class ReductionNode : public Node {
142  public:
143   ReductionNode(Node *ctrl, Node* in1, Node* in2) : Node(ctrl, in1, in2) {}
144 
145   static ReductionNode* make(int opc, Node *ctrl, Node* in1, Node* in2, BasicType bt);
146   static int  opcode(int opc, BasicType bt);
147   static bool implemented(int opc, uint vlen, BasicType bt);
148 };
149 
150 //------------------------------AddReductionVINode--------------------------------------
151 // Vector add int as a reduction
152 class AddReductionVINode : public ReductionNode {
153 public:
154   AddReductionVINode(Node * ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
155   virtual int Opcode() const;
156   virtual const Type* bottom_type() const { return TypeInt::INT; }
157   virtual uint ideal_reg() const { return Op_RegI; }
158 };
159 
160 //------------------------------AddReductionVLNode--------------------------------------
161 // Vector add long as a reduction
162 class AddReductionVLNode : public ReductionNode {
163 public:
164   AddReductionVLNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
165   virtual int Opcode() const;
166   virtual const Type* bottom_type() const { return TypeLong::LONG; }
167   virtual uint ideal_reg() const { return Op_RegL; }
168 };
169 
170 //------------------------------AddReductionVFNode--------------------------------------
171 // Vector add float as a reduction
172 class AddReductionVFNode : public ReductionNode {
173 public:
174   AddReductionVFNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
175   virtual int Opcode() const;
176   virtual const Type* bottom_type() const { return Type::FLOAT; }
177   virtual uint ideal_reg() const { return Op_RegF; }
178 };
179 
180 //------------------------------AddReductionVDNode--------------------------------------
181 // Vector add double as a reduction
182 class AddReductionVDNode : public ReductionNode {
183 public:
184   AddReductionVDNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
185   virtual int Opcode() const;
186   virtual const Type* bottom_type() const { return Type::DOUBLE; }
187   virtual uint ideal_reg() const { return Op_RegD; }
188 };
189 
190 //------------------------------SubVBNode--------------------------------------
191 // Vector subtract byte
192 class SubVBNode : public VectorNode {
193  public:
194   SubVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
195   virtual int Opcode() const;
196 };
197 
198 //------------------------------SubVSNode--------------------------------------
199 // Vector subtract short
200 class SubVSNode : public VectorNode {
201  public:
202   SubVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
203   virtual int Opcode() const;
204 };
205 
206 //------------------------------SubVINode--------------------------------------
207 // Vector subtract int
208 class SubVINode : public VectorNode {
209  public:
210   SubVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
211   virtual int Opcode() const;
212 };
213 
214 //------------------------------SubVLNode--------------------------------------
215 // Vector subtract long
216 class SubVLNode : public VectorNode {
217  public:
218   SubVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
219   virtual int Opcode() const;
220 };
221 
222 //------------------------------SubVFNode--------------------------------------
223 // Vector subtract float
224 class SubVFNode : public VectorNode {
225  public:
226   SubVFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
227   virtual int Opcode() const;
228 };
229 
230 //------------------------------SubVDNode--------------------------------------
231 // Vector subtract double
232 class SubVDNode : public VectorNode {
233  public:
234   SubVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
235   virtual int Opcode() const;
236 };
237 
238 //------------------------------MulVBNode--------------------------------------
239 // Vector multiply byte
240 class MulVBNode : public VectorNode {
241  public:
242   MulVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
243   virtual int Opcode() const;
244 };
245 
246 //------------------------------MulVSNode--------------------------------------
247 // Vector multiply short
248 class MulVSNode : public VectorNode {
249  public:
250   MulVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
251   virtual int Opcode() const;
252 };
253 
254 //------------------------------MulVINode--------------------------------------
255 // Vector multiply int
256 class MulVINode : public VectorNode {
257  public:
258   MulVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
259   virtual int Opcode() const;
260 };
261 
262 //------------------------------MulVLNode--------------------------------------
263 // Vector multiply long
264 class MulVLNode : public VectorNode {
265 public:
266   MulVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
267   virtual int Opcode() const;
268 };
269 
270 //------------------------------MulVFNode--------------------------------------
271 // Vector multiply float
272 class MulVFNode : public VectorNode {
273 public:
274   MulVFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
275   virtual int Opcode() const;
276 };
277 
278 //------------------------------MulVDNode--------------------------------------
279 // Vector multiply double
280 class MulVDNode : public VectorNode {
281 public:
282   MulVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
283   virtual int Opcode() const;
284 };
285 
286 //------------------------------MulAddVS2VINode--------------------------------
287 // Vector multiply shorts to int and add adjacent ints.
288 class MulAddVS2VINode : public VectorNode {
289   public:
290     MulAddVS2VINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
291     virtual int Opcode() const;
292 };
293 
294 //------------------------------FmaVDNode--------------------------------------
295 // Vector multiply double
296 class FmaVDNode : public VectorNode {
297 public:
298   FmaVDNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt) : VectorNode(in1, in2, in3, vt) {}
299   virtual int Opcode() const;
300 };
301 
302 //------------------------------FmaVFNode--------------------------------------
303 // Vector multiply float
304 class FmaVFNode : public VectorNode {
305 public:
306   FmaVFNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt) : VectorNode(in1, in2, in3, vt) {}
307   virtual int Opcode() const;
308 };
309 
310 //------------------------------CMoveVFNode--------------------------------------
311 // Vector float conditional move
312 class CMoveVFNode : public VectorNode {
313 public:
314   CMoveVFNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt) : VectorNode(in1, in2, in3, vt) {}
315   virtual int Opcode() const;
316 };
317 
318 //------------------------------CMoveVDNode--------------------------------------
319 // Vector double conditional move
320 class CMoveVDNode : public VectorNode {
321 public:
322   CMoveVDNode(Node* in1, Node* in2, Node* in3, const TypeVect* vt) : VectorNode(in1, in2, in3, vt) {}
323   virtual int Opcode() const;
324 };
325 
326 //------------------------------MulReductionVINode--------------------------------------
327 // Vector multiply int as a reduction
328 class MulReductionVINode : public ReductionNode {
329 public:
330   MulReductionVINode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
331   virtual int Opcode() const;
332   virtual const Type* bottom_type() const { return TypeInt::INT; }
333   virtual uint ideal_reg() const { return Op_RegI; }
334 };
335 
336 //------------------------------MulReductionVLNode--------------------------------------
337 // Vector multiply int as a reduction
338 class MulReductionVLNode : public ReductionNode {
339 public:
340   MulReductionVLNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
341   virtual int Opcode() const;
342   virtual const Type* bottom_type() const { return TypeLong::LONG; }
343   virtual uint ideal_reg() const { return Op_RegI; }
344 };
345 
346 //------------------------------MulReductionVFNode--------------------------------------
347 // Vector multiply float as a reduction
348 class MulReductionVFNode : public ReductionNode {
349 public:
350   MulReductionVFNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
351   virtual int Opcode() const;
352   virtual const Type* bottom_type() const { return Type::FLOAT; }
353   virtual uint ideal_reg() const { return Op_RegF; }
354 };
355 
356 //------------------------------MulReductionVDNode--------------------------------------
357 // Vector multiply double as a reduction
358 class MulReductionVDNode : public ReductionNode {
359 public:
360   MulReductionVDNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
361   virtual int Opcode() const;
362   virtual const Type* bottom_type() const { return Type::DOUBLE; }
363   virtual uint ideal_reg() const { return Op_RegD; }
364 };
365 
366 //------------------------------DivVFNode--------------------------------------
367 // Vector divide float
368 class DivVFNode : public VectorNode {
369  public:
370   DivVFNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
371   virtual int Opcode() const;
372 };
373 
374 //------------------------------DivVDNode--------------------------------------
375 // Vector Divide double
376 class DivVDNode : public VectorNode {
377  public:
378   DivVDNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
379   virtual int Opcode() const;
380 };
381 
382 //------------------------------AbsVBNode--------------------------------------
383 // Vector Abs byte
384 class AbsVBNode : public VectorNode {
385 public:
386   AbsVBNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {}
387   virtual int Opcode() const;
388 };
389 
390 //------------------------------AbsVSNode--------------------------------------
391 // Vector Abs short
392 class AbsVSNode : public VectorNode {
393 public:
394   AbsVSNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {}
395   virtual int Opcode() const;
396 };
397 
398 //------------------------------AbsVINode--------------------------------------
399 // Vector Abs int
400 class AbsVINode : public VectorNode {
401 public:
402   AbsVINode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {}
403   virtual int Opcode() const;
404 };
405 
406 //------------------------------AbsVLNode--------------------------------------
407 // Vector Abs long
408 class AbsVLNode : public VectorNode {
409 public:
410   AbsVLNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {}
411   virtual int Opcode() const;
412 };
413 
414 //------------------------------AbsVFNode--------------------------------------
415 // Vector Abs float
416 class AbsVFNode : public VectorNode {
417  public:
418   AbsVFNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}
419   virtual int Opcode() const;
420 };
421 
422 //------------------------------AbsVDNode--------------------------------------
423 // Vector Abs double
424 class AbsVDNode : public VectorNode {
425  public:
426   AbsVDNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}
427   virtual int Opcode() const;
428 };
429 
430 //------------------------------NegVFNode--------------------------------------
431 // Vector Neg float
432 class NegVFNode : public VectorNode {
433  public:
434   NegVFNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}
435   virtual int Opcode() const;
436 };
437 
438 //------------------------------NegVDNode--------------------------------------
439 // Vector Neg double
440 class NegVDNode : public VectorNode {
441  public:
442   NegVDNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}
443   virtual int Opcode() const;
444 };
445 
446 //------------------------------PopCountVINode---------------------------------
447 // Vector popcount integer bits
448 class PopCountVINode : public VectorNode {
449  public:
450   PopCountVINode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}
451   virtual int Opcode() const;
452 };
453 
454 //------------------------------SqrtVFNode--------------------------------------
455 // Vector Sqrt float
456 class SqrtVFNode : public VectorNode {
457  public:
458   SqrtVFNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}
459   virtual int Opcode() const;
460 };
461 //------------------------------RoundDoubleVNode--------------------------------
462 // Vector round double
463 class RoundDoubleModeVNode : public VectorNode {
464  public:
465   RoundDoubleModeVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
466   virtual int Opcode() const;
467 };
468 
469 //------------------------------SqrtVDNode--------------------------------------
470 // Vector Sqrt double
471 class SqrtVDNode : public VectorNode {
472  public:
473   SqrtVDNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}
474   virtual int Opcode() const;
475 };
476 
477 //------------------------------LShiftVBNode-----------------------------------
478 // Vector left shift bytes
479 class LShiftVBNode : public VectorNode {
480  public:
481   LShiftVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
482   virtual int Opcode() const;
483 };
484 
485 //------------------------------LShiftVSNode-----------------------------------
486 // Vector left shift shorts
487 class LShiftVSNode : public VectorNode {
488  public:
489   LShiftVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
490   virtual int Opcode() const;
491 };
492 
493 //------------------------------LShiftVINode-----------------------------------
494 // Vector left shift ints
495 class LShiftVINode : public VectorNode {
496  public:
497   LShiftVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
498   virtual int Opcode() const;
499 };
500 
501 //------------------------------LShiftVLNode-----------------------------------
502 // Vector left shift longs
503 class LShiftVLNode : public VectorNode {
504  public:
505   LShiftVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
506   virtual int Opcode() const;
507 };
508 
509 //------------------------------RShiftVBNode-----------------------------------
510 // Vector right arithmetic (signed) shift bytes
511 class RShiftVBNode : public VectorNode {
512  public:
513   RShiftVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
514   virtual int Opcode() const;
515 };
516 
517 //------------------------------RShiftVSNode-----------------------------------
518 // Vector right arithmetic (signed) shift shorts
519 class RShiftVSNode : public VectorNode {
520  public:
521   RShiftVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
522   virtual int Opcode() const;
523 };
524 
525 //------------------------------RShiftVINode-----------------------------------
526 // Vector right arithmetic (signed) shift ints
527 class RShiftVINode : public VectorNode {
528  public:
529   RShiftVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
530   virtual int Opcode() const;
531 };
532 
533 //------------------------------RShiftVLNode-----------------------------------
534 // Vector right arithmetic (signed) shift longs
535 class RShiftVLNode : public VectorNode {
536  public:
537   RShiftVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
538   virtual int Opcode() const;
539 };
540 
541 //------------------------------URShiftVBNode----------------------------------
542 // Vector right logical (unsigned) shift bytes
543 class URShiftVBNode : public VectorNode {
544  public:
545   URShiftVBNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
546   virtual int Opcode() const;
547 };
548 
549 //------------------------------URShiftVSNode----------------------------------
550 // Vector right logical (unsigned) shift shorts
551 class URShiftVSNode : public VectorNode {
552  public:
553   URShiftVSNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
554   virtual int Opcode() const;
555 };
556 
557 //------------------------------URShiftVINode----------------------------------
558 // Vector right logical (unsigned) shift ints
559 class URShiftVINode : public VectorNode {
560  public:
561   URShiftVINode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
562   virtual int Opcode() const;
563 };
564 
565 //------------------------------URShiftVLNode----------------------------------
566 // Vector right logical (unsigned) shift longs
567 class URShiftVLNode : public VectorNode {
568  public:
569   URShiftVLNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
570   virtual int Opcode() const;
571 };
572 
573 //------------------------------LShiftCntVNode---------------------------------
574 // Vector left shift count
575 class LShiftCntVNode : public VectorNode {
576  public:
577   LShiftCntVNode(Node* cnt, const TypeVect* vt) : VectorNode(cnt,vt) {}
578   virtual int Opcode() const;
579   virtual uint ideal_reg() const { return Matcher::vector_shift_count_ideal_reg(vect_type()-&gt;length_in_bytes()); }
580 };
581 
582 //------------------------------RShiftCntVNode---------------------------------
583 // Vector right shift count
584 class RShiftCntVNode : public VectorNode {
585  public:
586   RShiftCntVNode(Node* cnt, const TypeVect* vt) : VectorNode(cnt,vt) {}
587   virtual int Opcode() const;
588   virtual uint ideal_reg() const { return Matcher::vector_shift_count_ideal_reg(vect_type()-&gt;length_in_bytes()); }
589 };
590 
591 
592 //------------------------------AndVNode---------------------------------------
593 // Vector and integer
594 class AndVNode : public VectorNode {
595  public:
596   AndVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
597   virtual int Opcode() const;
598 };
599 
600 //------------------------------OrVNode---------------------------------------
601 // Vector or integer
602 class OrVNode : public VectorNode {
603  public:
604   OrVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
605   virtual int Opcode() const;
606 };
607 
608 //------------------------------XorVNode---------------------------------------
609 // Vector xor integer
610 class XorVNode : public VectorNode {
611  public:
612   XorVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}
613   virtual int Opcode() const;
614 };
615 
616 //------------------------------MinVNode--------------------------------------
617 // Vector min
618 class MinVNode : public VectorNode {
619 public:
620   MinVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
621   virtual int Opcode() const;
622 };
623 
624 //------------------------------MaxVNode--------------------------------------
625 // Vector max
626 class MaxVNode : public VectorNode {
627 public:
628   MaxVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}
629   virtual int Opcode() const;
630 };
631 
632 //------------------------------MinReductionVNode--------------------------------------
633 // Vector min as a reduction
634 class MinReductionVNode : public ReductionNode {
635 public:
636   MinReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
637   virtual int Opcode() const;
638   virtual const Type* bottom_type() const {
639     BasicType bt = in(1)-&gt;bottom_type()-&gt;basic_type();
640     if (bt == T_FLOAT) {
641       return Type::FLOAT;
642     } else if (bt == T_DOUBLE) {
643       return Type::DOUBLE;
644     }
645     assert(false, &quot;unsupported basic type&quot;);
646     return NULL;
647   }
648   virtual uint ideal_reg() const {
649     BasicType bt = in(1)-&gt;bottom_type()-&gt;basic_type();
650     if (bt == T_FLOAT) {
651       return Op_RegF;
652     } else if (bt == T_DOUBLE) {
653       return Op_RegD;
654     }
655     assert(false, &quot;unsupported basic type&quot;);
656     return 0;
657   }
658 };
659 
660 //------------------------------MaxReductionVNode--------------------------------------
661 // Vector max as a reduction
662 class MaxReductionVNode : public ReductionNode {
663 public:
664   MaxReductionVNode(Node *ctrl, Node* in1, Node* in2) : ReductionNode(ctrl, in1, in2) {}
665   virtual int Opcode() const;
666   virtual const Type* bottom_type() const {
667     BasicType bt = in(1)-&gt;bottom_type()-&gt;basic_type();
668     if (bt == T_FLOAT) {
669       return Type::FLOAT;
670     } else {
671       return Type::DOUBLE;
672     }
673     assert(false, &quot;unsupported basic type&quot;);
674     return NULL;
675   }
676   virtual uint ideal_reg() const {
677     BasicType bt = in(1)-&gt;bottom_type()-&gt;basic_type();
678     if (bt == T_FLOAT) {
679       return Op_RegF;
680     } else {
681       return Op_RegD;
682     }
683     assert(false, &quot;unsupported basic type&quot;);
684     return 0;
685   }
686 };
687 
688 //================================= M E M O R Y ===============================
689 
690 //------------------------------LoadVectorNode---------------------------------
691 // Load Vector from memory
692 class LoadVectorNode : public LoadNode {
693  public:
694   LoadVectorNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, ControlDependency control_dependency = LoadNode::DependsOnlyOnTest)
695     : LoadNode(c, mem, adr, at, vt, MemNode::unordered, control_dependency) {
696     init_class_id(Class_LoadVector);
697     set_mismatched_access();
698   }
699 
700   const TypeVect* vect_type() const { return type()-&gt;is_vect(); }
701   uint length() const { return vect_type()-&gt;length(); } // Vector length
702 
703   virtual int Opcode() const;
704 
705   virtual uint ideal_reg() const  { return Matcher::vector_ideal_reg(memory_size()); }
706   virtual BasicType memory_type() const { return T_VOID; }
707   virtual int memory_size() const { return vect_type()-&gt;length_in_bytes(); }
708 
709   virtual int store_Opcode() const { return Op_StoreVector; }
710 
711   static LoadVectorNode* make(int opc, Node* ctl, Node* mem,
712                               Node* adr, const TypePtr* atyp,
713                               uint vlen, BasicType bt,
714                               ControlDependency control_dependency = LoadNode::DependsOnlyOnTest);
715   uint element_size(void) { return type2aelembytes(vect_type()-&gt;element_basic_type()); }
716 };
717 
718 //------------------------------StoreVectorNode--------------------------------
719 // Store Vector to memory
720 class StoreVectorNode : public StoreNode {
721  public:
722   StoreVectorNode(Node* c, Node* mem, Node* adr, const TypePtr* at, Node* val)
723     : StoreNode(c, mem, adr, at, val, MemNode::unordered) {
724     assert(val-&gt;is_Vector() || val-&gt;is_LoadVector(), &quot;sanity&quot;);
725     init_class_id(Class_StoreVector);
726     set_mismatched_access();
727   }
728 
729   const TypeVect* vect_type() const { return in(MemNode::ValueIn)-&gt;bottom_type()-&gt;is_vect(); }
730   uint length() const { return vect_type()-&gt;length(); } // Vector length
731 
732   virtual int Opcode() const;
733 
734   virtual uint ideal_reg() const  { return Matcher::vector_ideal_reg(memory_size()); }
735   virtual BasicType memory_type() const { return T_VOID; }
736   virtual int memory_size() const { return vect_type()-&gt;length_in_bytes(); }
737 
738   static StoreVectorNode* make(int opc, Node* ctl, Node* mem,
739                                Node* adr, const TypePtr* atyp, Node* val,
740                                uint vlen);
741 
742   uint element_size(void) { return type2aelembytes(vect_type()-&gt;element_basic_type()); }
743 };
744 
745 
746 //=========================Promote_Scalar_to_Vector============================
747 
748 //------------------------------ReplicateBNode---------------------------------
749 // Replicate byte scalar to be vector
750 class ReplicateBNode : public VectorNode {
751  public:
752   ReplicateBNode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}
753   virtual int Opcode() const;
754 };
755 
756 //------------------------------ReplicateSNode---------------------------------
757 // Replicate short scalar to be vector
758 class ReplicateSNode : public VectorNode {
759  public:
760   ReplicateSNode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}
761   virtual int Opcode() const;
762 };
763 
764 //------------------------------ReplicateINode---------------------------------
765 // Replicate int scalar to be vector
766 class ReplicateINode : public VectorNode {
767  public:
768   ReplicateINode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}
769   virtual int Opcode() const;
770 };
771 
772 //------------------------------ReplicateLNode---------------------------------
773 // Replicate long scalar to be vector
774 class ReplicateLNode : public VectorNode {
775  public:
776   ReplicateLNode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}
777   virtual int Opcode() const;
778 };
779 
780 //------------------------------ReplicateFNode---------------------------------
781 // Replicate float scalar to be vector
782 class ReplicateFNode : public VectorNode {
783  public:
784   ReplicateFNode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}
785   virtual int Opcode() const;
786 };
787 
788 //------------------------------ReplicateDNode---------------------------------
789 // Replicate double scalar to be vector
790 class ReplicateDNode : public VectorNode {
791  public:
792   ReplicateDNode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}
793   virtual int Opcode() const;
794 };
795 
796 //========================Pack_Scalars_into_a_Vector===========================
797 
798 //------------------------------PackNode---------------------------------------
799 // Pack parent class (not for code generation).
800 class PackNode : public VectorNode {
801  public:
802   PackNode(Node* in1, const TypeVect* vt) : VectorNode(in1, vt) {}
803   PackNode(Node* in1, Node* n2, const TypeVect* vt) : VectorNode(in1, n2, vt) {}
804   virtual int Opcode() const;
805 
806   void add_opd(Node* n) {
807     add_req(n);
808   }
809 
810   // Create a binary tree form for Packs. [lo, hi) (half-open) range
811   PackNode* binary_tree_pack(int lo, int hi);
812 
813   static PackNode* make(Node* s, uint vlen, BasicType bt);
814 };
815 
816 //------------------------------PackBNode--------------------------------------
817 // Pack byte scalars into vector
818 class PackBNode : public PackNode {
819  public:
820   PackBNode(Node* in1, const TypeVect* vt)  : PackNode(in1, vt) {}
821   virtual int Opcode() const;
822 };
823 
824 //------------------------------PackSNode--------------------------------------
825 // Pack short scalars into a vector
826 class PackSNode : public PackNode {
827  public:
828   PackSNode(Node* in1, const TypeVect* vt)  : PackNode(in1, vt) {}
829   PackSNode(Node* in1, Node* in2, const TypeVect* vt) : PackNode(in1, in2, vt) {}
830   virtual int Opcode() const;
831 };
832 
833 //------------------------------PackINode--------------------------------------
834 // Pack integer scalars into a vector
835 class PackINode : public PackNode {
836  public:
837   PackINode(Node* in1, const TypeVect* vt)  : PackNode(in1, vt) {}
838   PackINode(Node* in1, Node* in2, const TypeVect* vt) : PackNode(in1, in2, vt) {}
839   virtual int Opcode() const;
840 };
841 
842 //------------------------------PackLNode--------------------------------------
843 // Pack long scalars into a vector
844 class PackLNode : public PackNode {
845  public:
846   PackLNode(Node* in1, const TypeVect* vt)  : PackNode(in1, vt) {}
847   PackLNode(Node* in1, Node* in2, const TypeVect* vt) : PackNode(in1, in2, vt) {}
848   virtual int Opcode() const;
849 };
850 
851 //------------------------------Pack2LNode-------------------------------------
852 // Pack 2 long scalars into a vector
853 class Pack2LNode : public PackNode {
854  public:
855   Pack2LNode(Node* in1, Node* in2, const TypeVect* vt) : PackNode(in1, in2, vt) {}
856   virtual int Opcode() const;
857 };
858 
859 //------------------------------PackFNode--------------------------------------
860 // Pack float scalars into vector
861 class PackFNode : public PackNode {
862  public:
863   PackFNode(Node* in1, const TypeVect* vt)  : PackNode(in1, vt) {}
864   PackFNode(Node* in1, Node* in2, const TypeVect* vt) : PackNode(in1, in2, vt) {}
865   virtual int Opcode() const;
866 };
867 
868 //------------------------------PackDNode--------------------------------------
869 // Pack double scalars into a vector
870 class PackDNode : public PackNode {
871  public:
872   PackDNode(Node* in1, const TypeVect* vt) : PackNode(in1, vt) {}
873   PackDNode(Node* in1, Node* in2, const TypeVect* vt) : PackNode(in1, in2, vt) {}
874   virtual int Opcode() const;
875 };
876 
877 //------------------------------Pack2DNode-------------------------------------
878 // Pack 2 double scalars into a vector
879 class Pack2DNode : public PackNode {
880  public:
881   Pack2DNode(Node* in1, Node* in2, const TypeVect* vt) : PackNode(in1, in2, vt) {}
882   virtual int Opcode() const;
883 };
884 
885 
886 //========================Extract_Scalar_from_Vector===========================
887 
888 //------------------------------ExtractNode------------------------------------
889 // Extract a scalar from a vector at position &quot;pos&quot;
890 class ExtractNode : public Node {
891  public:
892   ExtractNode(Node* src, ConINode* pos) : Node(NULL, src, (Node*)pos) {
893     assert(in(2)-&gt;get_int() &gt;= 0, &quot;positive constants&quot;);
894   }
895   virtual int Opcode() const;
896   uint  pos() const { return in(2)-&gt;get_int(); }
897 
898   static Node* make(Node* v, uint position, BasicType bt);
899 };
900 
901 //------------------------------ExtractBNode-----------------------------------
902 // Extract a byte from a vector at position &quot;pos&quot;
903 class ExtractBNode : public ExtractNode {
904  public:
905   ExtractBNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
906   virtual int Opcode() const;
907   virtual const Type *bottom_type() const { return TypeInt::INT; }
908   virtual uint ideal_reg() const { return Op_RegI; }
909 };
910 
911 //------------------------------ExtractUBNode----------------------------------
912 // Extract a boolean from a vector at position &quot;pos&quot;
913 class ExtractUBNode : public ExtractNode {
914  public:
915   ExtractUBNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
916   virtual int Opcode() const;
917   virtual const Type *bottom_type() const { return TypeInt::INT; }
918   virtual uint ideal_reg() const { return Op_RegI; }
919 };
920 
921 //------------------------------ExtractCNode-----------------------------------
922 // Extract a char from a vector at position &quot;pos&quot;
923 class ExtractCNode : public ExtractNode {
924  public:
925   ExtractCNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
926   virtual int Opcode() const;
927   virtual const Type *bottom_type() const { return TypeInt::INT; }
928   virtual uint ideal_reg() const { return Op_RegI; }
929 };
930 
931 //------------------------------ExtractSNode-----------------------------------
932 // Extract a short from a vector at position &quot;pos&quot;
933 class ExtractSNode : public ExtractNode {
934  public:
935   ExtractSNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
936   virtual int Opcode() const;
937   virtual const Type *bottom_type() const { return TypeInt::INT; }
938   virtual uint ideal_reg() const { return Op_RegI; }
939 };
940 
941 //------------------------------ExtractINode-----------------------------------
942 // Extract an int from a vector at position &quot;pos&quot;
943 class ExtractINode : public ExtractNode {
944  public:
945   ExtractINode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
946   virtual int Opcode() const;
947   virtual const Type *bottom_type() const { return TypeInt::INT; }
948   virtual uint ideal_reg() const { return Op_RegI; }
949 };
950 
951 //------------------------------ExtractLNode-----------------------------------
952 // Extract a long from a vector at position &quot;pos&quot;
953 class ExtractLNode : public ExtractNode {
954  public:
955   ExtractLNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
956   virtual int Opcode() const;
957   virtual const Type *bottom_type() const { return TypeLong::LONG; }
958   virtual uint ideal_reg() const { return Op_RegL; }
959 };
960 
961 //------------------------------ExtractFNode-----------------------------------
962 // Extract a float from a vector at position &quot;pos&quot;
963 class ExtractFNode : public ExtractNode {
964  public:
965   ExtractFNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
966   virtual int Opcode() const;
967   virtual const Type *bottom_type() const { return Type::FLOAT; }
968   virtual uint ideal_reg() const { return Op_RegF; }
969 };
970 
971 //------------------------------ExtractDNode-----------------------------------
972 // Extract a double from a vector at position &quot;pos&quot;
973 class ExtractDNode : public ExtractNode {
974  public:
975   ExtractDNode(Node* src, ConINode* pos) : ExtractNode(src, pos) {}
976   virtual int Opcode() const;
977   virtual const Type *bottom_type() const { return Type::DOUBLE; }
978   virtual uint ideal_reg() const { return Op_RegD; }
979 };
980 
981 //------------------------------SetVectMaskINode-------------------------------
982 // Provide a mask for a vector predicate machine
983 class SetVectMaskINode : public Node {
984 public:
985   SetVectMaskINode(Node *c, Node *in1) : Node(c, in1) {}
986   virtual int Opcode() const;
987   const Type *bottom_type() const { return TypeInt::INT; }
988   virtual uint ideal_reg() const { return Op_RegI; }
989   virtual const Type *Value(PhaseGVN *phase) const { return TypeInt::INT; }
990 };
991 
992 #endif // SHARE_OPTO_VECTORNODE_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
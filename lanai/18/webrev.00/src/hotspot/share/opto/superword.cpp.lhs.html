<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/superword.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;compiler/compileLog.hpp&quot;
  26 #include &quot;libadt/vectset.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;memory/resourceArea.hpp&quot;
  29 #include &quot;opto/addnode.hpp&quot;
  30 #include &quot;opto/callnode.hpp&quot;
  31 #include &quot;opto/castnode.hpp&quot;
  32 #include &quot;opto/convertnode.hpp&quot;
  33 #include &quot;opto/divnode.hpp&quot;
  34 #include &quot;opto/matcher.hpp&quot;
  35 #include &quot;opto/memnode.hpp&quot;
  36 #include &quot;opto/mulnode.hpp&quot;
  37 #include &quot;opto/opcodes.hpp&quot;
  38 #include &quot;opto/opaquenode.hpp&quot;
  39 #include &quot;opto/superword.hpp&quot;
  40 #include &quot;opto/vectornode.hpp&quot;
  41 #include &quot;opto/movenode.hpp&quot;
<a name="1" id="anc1"></a>
  42 
  43 //
  44 //                  S U P E R W O R D   T R A N S F O R M
  45 //=============================================================================
  46 
  47 //------------------------------SuperWord---------------------------
  48 SuperWord::SuperWord(PhaseIdealLoop* phase) :
  49   _phase(phase),
  50   _arena(phase-&gt;C-&gt;comp_arena()),
  51   _igvn(phase-&gt;_igvn),
  52   _packset(arena(), 8,  0, NULL),         // packs for the current block
  53   _bb_idx(arena(), (int)(1.10 * phase-&gt;C-&gt;unique()), 0, 0), // node idx to index in bb
  54   _block(arena(), 8,  0, NULL),           // nodes in current block
  55   _post_block(arena(), 8, 0, NULL),       // nodes common to current block which are marked as post loop vectorizable
  56   _data_entry(arena(), 8,  0, NULL),      // nodes with all inputs from outside
  57   _mem_slice_head(arena(), 8,  0, NULL),  // memory slice heads
  58   _mem_slice_tail(arena(), 8,  0, NULL),  // memory slice tails
  59   _node_info(arena(), 8,  0, SWNodeInfo::initial), // info needed per node
  60   _clone_map(phase-&gt;C-&gt;clone_map()),      // map of nodes created in cloning
  61   _cmovev_kit(_arena, this),              // map to facilitate CMoveV creation
  62   _align_to_ref(NULL),                    // memory reference to align vectors to
  63   _disjoint_ptrs(arena(), 8,  0, OrderedPair::initial), // runtime disambiguated pointer pairs
  64   _dg(_arena),                            // dependence graph
  65   _visited(arena()),                      // visited node set
  66   _post_visited(arena()),                 // post visited node set
  67   _n_idx_list(arena(), 8),                // scratch list of (node,index) pairs
  68   _nlist(arena(), 8, 0, NULL),            // scratch list of nodes
  69   _stk(arena(), 8, 0, NULL),              // scratch stack of nodes
  70   _lpt(NULL),                             // loop tree node
  71   _lp(NULL),                              // LoopNode
  72   _bb(NULL),                              // basic block
  73   _iv(NULL),                              // induction var
  74   _race_possible(false),                  // cases where SDMU is true
  75   _early_return(true),                    // analysis evaluations routine
  76   _do_vector_loop(phase-&gt;C-&gt;do_vector_loop()),  // whether to do vectorization/simd style
  77   _do_reserve_copy(DoReserveCopyInSuperWord),
  78   _num_work_vecs(0),                      // amount of vector work we have
  79   _num_reductions(0),                     // amount of reduction work we have
  80   _ii_first(-1),                          // first loop generation index - only if do_vector_loop()
  81   _ii_last(-1),                           // last loop generation index - only if do_vector_loop()
  82   _ii_order(arena(), 8, 0, 0)
  83 {
  84 #ifndef PRODUCT
  85   _vector_loop_debug = 0;
  86   if (_phase-&gt;C-&gt;method() != NULL) {
  87     _vector_loop_debug = phase-&gt;C-&gt;directive()-&gt;VectorizeDebugOption;
  88   }
  89 
  90 #endif
  91 }
  92 
  93 //------------------------------transform_loop---------------------------
  94 void SuperWord::transform_loop(IdealLoopTree* lpt, bool do_optimization) {
  95   assert(UseSuperWord, &quot;should be&quot;);
  96   // Do vectors exist on this architecture?
  97   if (Matcher::vector_width_in_bytes(T_BYTE) &lt; 2) return;
  98 
  99   assert(lpt-&gt;_head-&gt;is_CountedLoop(), &quot;must be&quot;);
 100   CountedLoopNode *cl = lpt-&gt;_head-&gt;as_CountedLoop();
 101 
 102   if (!cl-&gt;is_valid_counted_loop()) return; // skip malformed counted loop
 103 
 104   bool post_loop_allowed = (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors() &amp;&amp; cl-&gt;is_post_loop());
 105   if (post_loop_allowed) {
 106     if (cl-&gt;is_reduction_loop()) return; // no predication mapping
 107     Node *limit = cl-&gt;limit();
 108     if (limit-&gt;is_Con()) return; // non constant limits only
 109     // Now check the limit for expressions we do not handle
 110     if (limit-&gt;is_Add()) {
 111       Node *in2 = limit-&gt;in(2);
 112       if (in2-&gt;is_Con()) {
 113         int val = in2-&gt;get_int();
 114         // should not try to program these cases
 115         if (val &lt; 0) return;
 116       }
 117     }
 118   }
 119 
 120   // skip any loop that has not been assigned max unroll by analysis
 121   if (do_optimization) {
 122     if (SuperWordLoopUnrollAnalysis &amp;&amp; cl-&gt;slp_max_unroll() == 0) return;
 123   }
 124 
 125   // Check for no control flow in body (other than exit)
 126   Node *cl_exit = cl-&gt;loopexit();
 127   if (cl-&gt;is_main_loop() &amp;&amp; (cl_exit-&gt;in(0) != lpt-&gt;_head)) {
 128     #ifndef PRODUCT
 129       if (TraceSuperWord) {
 130         tty-&gt;print_cr(&quot;SuperWord::transform_loop: loop too complicated, cl_exit-&gt;in(0) != lpt-&gt;_head&quot;);
 131         tty-&gt;print(&quot;cl_exit %d&quot;, cl_exit-&gt;_idx); cl_exit-&gt;dump();
 132         tty-&gt;print(&quot;cl_exit-&gt;in(0) %d&quot;, cl_exit-&gt;in(0)-&gt;_idx); cl_exit-&gt;in(0)-&gt;dump();
 133         tty-&gt;print(&quot;lpt-&gt;_head %d&quot;, lpt-&gt;_head-&gt;_idx); lpt-&gt;_head-&gt;dump();
 134         lpt-&gt;dump_head();
 135       }
 136     #endif
 137     return;
 138   }
 139 
 140   // Make sure the are no extra control users of the loop backedge
 141   if (cl-&gt;back_control()-&gt;outcnt() != 1) {
 142     return;
 143   }
 144 
 145   // Skip any loops already optimized by slp
 146   if (cl-&gt;is_vectorized_loop()) return;
 147 
 148   if (cl-&gt;is_unroll_only()) return;
 149 
 150   if (cl-&gt;is_main_loop()) {
 151     // Check for pre-loop ending with CountedLoopEnd(Bool(Cmp(x,Opaque1(limit))))
 152     CountedLoopEndNode* pre_end = get_pre_loop_end(cl);
 153     if (pre_end == NULL) return;
 154     Node *pre_opaq1 = pre_end-&gt;limit();
 155     if (pre_opaq1-&gt;Opcode() != Op_Opaque1) return;
 156   }
 157 
 158   init(); // initialize data structures
 159 
 160   set_lpt(lpt);
 161   set_lp(cl);
 162 
 163   // For now, define one block which is the entire loop body
 164   set_bb(cl);
 165 
 166   if (do_optimization) {
 167     assert(_packset.length() == 0, &quot;packset must be empty&quot;);
 168     SLP_extract();
 169     if (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors()) {
 170       if (cl-&gt;is_vectorized_loop() &amp;&amp; cl-&gt;is_main_loop() &amp;&amp; !cl-&gt;is_reduction_loop()) {
 171         IdealLoopTree *lpt_next = lpt-&gt;_next;
 172         CountedLoopNode *cl_next = lpt_next-&gt;_head-&gt;as_CountedLoop();
 173         _phase-&gt;has_range_checks(lpt_next);
 174         if (cl_next-&gt;is_post_loop() &amp;&amp; !cl_next-&gt;range_checks_present()) {
 175           if (!cl_next-&gt;is_vectorized_loop()) {
 176             int slp_max_unroll_factor = cl-&gt;slp_max_unroll();
 177             cl_next-&gt;set_slp_max_unroll(slp_max_unroll_factor);
 178           }
 179         }
 180       }
 181     }
 182   }
 183 }
 184 
 185 //------------------------------early unrolling analysis------------------------------
 186 void SuperWord::unrolling_analysis(int &amp;local_loop_unroll_factor) {
 187   bool is_slp = true;
 188   ResourceMark rm;
 189   size_t ignored_size = lpt()-&gt;_body.size();
 190   int *ignored_loop_nodes = NEW_RESOURCE_ARRAY(int, ignored_size);
 191   Node_Stack nstack((int)ignored_size);
 192   CountedLoopNode *cl = lpt()-&gt;_head-&gt;as_CountedLoop();
 193   Node *cl_exit = cl-&gt;loopexit_or_null();
 194   int rpo_idx = _post_block.length();
 195 
 196   assert(rpo_idx == 0, &quot;post loop block is empty&quot;);
 197 
 198   // First clear the entries
 199   for (uint i = 0; i &lt; lpt()-&gt;_body.size(); i++) {
 200     ignored_loop_nodes[i] = -1;
 201   }
 202 
 203   int max_vector = Matcher::max_vector_size(T_BYTE);
 204   bool post_loop_allowed = (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors() &amp;&amp; cl-&gt;is_post_loop());
 205 
 206   // Process the loop, some/all of the stack entries will not be in order, ergo
 207   // need to preprocess the ignored initial state before we process the loop
 208   for (uint i = 0; i &lt; lpt()-&gt;_body.size(); i++) {
 209     Node* n = lpt()-&gt;_body.at(i);
 210     if (n == cl-&gt;incr() ||
 211       n-&gt;is_reduction() ||
 212       n-&gt;is_AddP() ||
 213       n-&gt;is_Cmp() ||
 214       n-&gt;is_IfTrue() ||
 215       n-&gt;is_CountedLoop() ||
 216       (n == cl_exit)) {
 217       ignored_loop_nodes[i] = n-&gt;_idx;
 218       continue;
 219     }
 220 
 221     if (n-&gt;is_If()) {
 222       IfNode *iff = n-&gt;as_If();
 223       if (iff-&gt;_fcnt != COUNT_UNKNOWN &amp;&amp; iff-&gt;_prob != PROB_UNKNOWN) {
 224         if (lpt()-&gt;is_loop_exit(iff)) {
 225           ignored_loop_nodes[i] = n-&gt;_idx;
 226           continue;
 227         }
 228       }
 229     }
 230 
 231     if (n-&gt;is_Phi() &amp;&amp; (n-&gt;bottom_type() == Type::MEMORY)) {
 232       Node* n_tail = n-&gt;in(LoopNode::LoopBackControl);
 233       if (n_tail != n-&gt;in(LoopNode::EntryControl)) {
 234         if (!n_tail-&gt;is_Mem()) {
 235           is_slp = false;
 236           break;
 237         }
 238       }
 239     }
 240 
 241     // This must happen after check of phi/if
 242     if (n-&gt;is_Phi() || n-&gt;is_If()) {
 243       ignored_loop_nodes[i] = n-&gt;_idx;
 244       continue;
 245     }
 246 
 247     if (n-&gt;is_LoadStore() || n-&gt;is_MergeMem() ||
 248       (n-&gt;is_Proj() &amp;&amp; !n-&gt;as_Proj()-&gt;is_CFG())) {
 249       is_slp = false;
 250       break;
 251     }
 252 
 253     // Ignore nodes with non-primitive type.
 254     BasicType bt;
 255     if (n-&gt;is_Mem()) {
 256       bt = n-&gt;as_Mem()-&gt;memory_type();
 257     } else {
 258       bt = n-&gt;bottom_type()-&gt;basic_type();
 259     }
 260     if (is_java_primitive(bt) == false) {
 261       ignored_loop_nodes[i] = n-&gt;_idx;
 262       continue;
 263     }
 264 
 265     if (n-&gt;is_Mem()) {
 266       MemNode* current = n-&gt;as_Mem();
 267       Node* adr = n-&gt;in(MemNode::Address);
 268       Node* n_ctrl = _phase-&gt;get_ctrl(adr);
 269 
 270       // save a queue of post process nodes
 271       if (n_ctrl != NULL &amp;&amp; lpt()-&gt;is_member(_phase-&gt;get_loop(n_ctrl))) {
 272         // Process the memory expression
 273         int stack_idx = 0;
 274         bool have_side_effects = true;
 275         if (adr-&gt;is_AddP() == false) {
 276           nstack.push(adr, stack_idx++);
 277         } else {
 278           // Mark the components of the memory operation in nstack
 279           SWPointer p1(current, this, &amp;nstack, true);
 280           have_side_effects = p1.node_stack()-&gt;is_nonempty();
 281         }
 282 
 283         // Process the pointer stack
 284         while (have_side_effects) {
 285           Node* pointer_node = nstack.node();
 286           for (uint j = 0; j &lt; lpt()-&gt;_body.size(); j++) {
 287             Node* cur_node = lpt()-&gt;_body.at(j);
 288             if (cur_node == pointer_node) {
 289               ignored_loop_nodes[j] = cur_node-&gt;_idx;
 290               break;
 291             }
 292           }
 293           nstack.pop();
 294           have_side_effects = nstack.is_nonempty();
 295         }
 296       }
 297     }
 298   }
 299 
 300   if (is_slp) {
 301     // Now we try to find the maximum supported consistent vector which the machine
 302     // description can use
 303     bool small_basic_type = false;
 304     bool flag_small_bt = false;
 305     for (uint i = 0; i &lt; lpt()-&gt;_body.size(); i++) {
 306       if (ignored_loop_nodes[i] != -1) continue;
 307 
 308       BasicType bt;
 309       Node* n = lpt()-&gt;_body.at(i);
 310       if (n-&gt;is_Mem()) {
 311         bt = n-&gt;as_Mem()-&gt;memory_type();
 312       } else {
 313         bt = n-&gt;bottom_type()-&gt;basic_type();
 314       }
 315 
 316       if (post_loop_allowed) {
 317         if (!small_basic_type) {
 318           switch (bt) {
 319           case T_CHAR:
 320           case T_BYTE:
 321           case T_SHORT:
 322             small_basic_type = true;
 323             break;
 324 
 325           case T_LONG:
 326             // TODO: Remove when support completed for mask context with LONG.
 327             //       Support needs to be augmented for logical qword operations, currently we map to dword
 328             //       buckets for vectors on logicals as these were legacy.
 329             small_basic_type = true;
 330             break;
 331 
 332           default:
 333             break;
 334           }
 335         }
 336       }
 337 
 338       if (is_java_primitive(bt) == false) continue;
 339 
 340          int cur_max_vector = Matcher::max_vector_size(bt);
 341 
 342       // If a max vector exists which is not larger than _local_loop_unroll_factor
 343       // stop looking, we already have the max vector to map to.
 344       if (cur_max_vector &lt; local_loop_unroll_factor) {
 345         is_slp = false;
 346         if (TraceSuperWordLoopUnrollAnalysis) {
 347           tty-&gt;print_cr(&quot;slp analysis fails: unroll limit greater than max vector\n&quot;);
 348         }
 349         break;
 350       }
 351 
 352       // Map the maximal common vector
 353       if (VectorNode::implemented(n-&gt;Opcode(), cur_max_vector, bt)) {
 354         if (cur_max_vector &lt; max_vector &amp;&amp; !flag_small_bt) {
 355           max_vector = cur_max_vector;
 356         } else if (cur_max_vector &gt; max_vector &amp;&amp; UseSubwordForMaxVector) {
 357           // Analyse subword in the loop to set maximum vector size to take advantage of full vector width for subword types.
 358           // Here we analyze if narrowing is likely to happen and if it is we set vector size more aggressively.
 359           // We check for possibility of narrowing by looking through chain operations using subword types.
 360           if (is_subword_type(bt)) {
 361             uint start, end;
 362             VectorNode::vector_operands(n, &amp;start, &amp;end);
 363 
 364             for (uint j = start; j &lt; end; j++) {
 365               Node* in = n-&gt;in(j);
 366               // Don&#39;t propagate through a memory
 367               if (!in-&gt;is_Mem() &amp;&amp; in_bb(in) &amp;&amp; in-&gt;bottom_type()-&gt;basic_type() == T_INT) {
 368                 bool same_type = true;
 369                 for (DUIterator_Fast kmax, k = in-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 370                   Node *use = in-&gt;fast_out(k);
 371                   if (!in_bb(use) &amp;&amp; use-&gt;bottom_type()-&gt;basic_type() != bt) {
 372                     same_type = false;
 373                     break;
 374                   }
 375                 }
 376                 if (same_type) {
 377                   max_vector = cur_max_vector;
 378                   flag_small_bt = true;
 379                   cl-&gt;mark_subword_loop();
 380                 }
 381               }
 382             }
 383           }
 384         }
 385         // We only process post loops on predicated targets where we want to
 386         // mask map the loop to a single iteration
 387         if (post_loop_allowed) {
 388           _post_block.at_put_grow(rpo_idx++, n);
 389         }
 390       }
 391     }
 392     if (is_slp) {
 393       local_loop_unroll_factor = max_vector;
 394       cl-&gt;mark_passed_slp();
 395     }
 396     cl-&gt;mark_was_slp();
 397     if (cl-&gt;is_main_loop()) {
 398       cl-&gt;set_slp_max_unroll(local_loop_unroll_factor);
 399     } else if (post_loop_allowed) {
 400       if (!small_basic_type) {
 401         // avoid replication context for small basic types in programmable masked loops
 402         cl-&gt;set_slp_max_unroll(local_loop_unroll_factor);
 403       }
 404     }
 405   }
 406 }
 407 
 408 //------------------------------SLP_extract---------------------------
 409 // Extract the superword level parallelism
 410 //
 411 // 1) A reverse post-order of nodes in the block is constructed.  By scanning
 412 //    this list from first to last, all definitions are visited before their uses.
 413 //
 414 // 2) A point-to-point dependence graph is constructed between memory references.
 415 //    This simplies the upcoming &quot;independence&quot; checker.
 416 //
 417 // 3) The maximum depth in the node graph from the beginning of the block
 418 //    to each node is computed.  This is used to prune the graph search
 419 //    in the independence checker.
 420 //
 421 // 4) For integer types, the necessary bit width is propagated backwards
 422 //    from stores to allow packed operations on byte, char, and short
 423 //    integers.  This reverses the promotion to type &quot;int&quot; that javac
 424 //    did for operations like: char c1,c2,c3;  c1 = c2 + c3.
 425 //
 426 // 5) One of the memory references is picked to be an aligned vector reference.
 427 //    The pre-loop trip count is adjusted to align this reference in the
 428 //    unrolled body.
 429 //
 430 // 6) The initial set of pack pairs is seeded with memory references.
 431 //
 432 // 7) The set of pack pairs is extended by following use-&gt;def and def-&gt;use links.
 433 //
 434 // 8) The pairs are combined into vector sized packs.
 435 //
 436 // 9) Reorder the memory slices to co-locate members of the memory packs.
 437 //
 438 // 10) Generate ideal vector nodes for the final set of packs and where necessary,
 439 //    inserting scalar promotion, vector creation from multiple scalars, and
 440 //    extraction of scalar values from vectors.
 441 //
 442 void SuperWord::SLP_extract() {
 443 
 444 #ifndef PRODUCT
 445   if (_do_vector_loop &amp;&amp; TraceSuperWord) {
 446     tty-&gt;print(&quot;SuperWord::SLP_extract\n&quot;);
 447     tty-&gt;print(&quot;input loop\n&quot;);
 448     _lpt-&gt;dump_head();
 449     _lpt-&gt;dump();
 450     for (uint i = 0; i &lt; _lpt-&gt;_body.size(); i++) {
 451       _lpt-&gt;_body.at(i)-&gt;dump();
 452     }
 453   }
 454 #endif
 455   // Ready the block
 456   if (!construct_bb()) {
 457     return; // Exit if no interesting nodes or complex graph.
 458   }
 459 
 460   // build    _dg, _disjoint_ptrs
 461   dependence_graph();
 462 
 463   // compute function depth(Node*)
 464   compute_max_depth();
 465 
 466   CountedLoopNode *cl = lpt()-&gt;_head-&gt;as_CountedLoop();
 467   bool post_loop_allowed = (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors() &amp;&amp; cl-&gt;is_post_loop());
 468   if (cl-&gt;is_main_loop()) {
 469     if (_do_vector_loop) {
 470       if (mark_generations() != -1) {
 471         hoist_loads_in_graph(); // this only rebuild the graph; all basic structs need rebuild explicitly
 472 
 473         if (!construct_bb()) {
 474           return; // Exit if no interesting nodes or complex graph.
 475         }
 476         dependence_graph();
 477         compute_max_depth();
 478       }
 479 
 480 #ifndef PRODUCT
 481       if (TraceSuperWord) {
 482         tty-&gt;print_cr(&quot;\nSuperWord::_do_vector_loop: graph after hoist_loads_in_graph&quot;);
 483         _lpt-&gt;dump_head();
 484         for (int j = 0; j &lt; _block.length(); j++) {
 485           Node* n = _block.at(j);
 486           int d = depth(n);
 487           for (int i = 0; i &lt; d; i++) tty-&gt;print(&quot;%s&quot;, &quot;  &quot;);
 488           tty-&gt;print(&quot;%d :&quot;, d);
 489           n-&gt;dump();
 490         }
 491       }
 492 #endif
 493     }
 494 
 495     compute_vector_element_type();
 496 
 497     // Attempt vectorization
 498 
 499     find_adjacent_refs();
 500 
 501     extend_packlist();
 502 
 503     if (_do_vector_loop) {
 504       if (_packset.length() == 0) {
 505         if (TraceSuperWord) {
 506           tty-&gt;print_cr(&quot;\nSuperWord::_do_vector_loop DFA could not build packset, now trying to build anyway&quot;);
 507         }
 508         pack_parallel();
 509       }
 510     }
 511 
 512     combine_packs();
 513 
 514     construct_my_pack_map();
 515     if (UseVectorCmov) {
 516       merge_packs_to_cmovd();
 517     }
 518 
 519     filter_packs();
 520 
 521     schedule();
 522   } else if (post_loop_allowed) {
 523     int saved_mapped_unroll_factor = cl-&gt;slp_max_unroll();
 524     if (saved_mapped_unroll_factor) {
 525       int vector_mapped_unroll_factor = saved_mapped_unroll_factor;
 526 
 527       // now reset the slp_unroll_factor so that we can check the analysis mapped
 528       // what the vector loop was mapped to
 529       cl-&gt;set_slp_max_unroll(0);
 530 
 531       // do the analysis on the post loop
 532       unrolling_analysis(vector_mapped_unroll_factor);
 533 
 534       // if our analyzed loop is a canonical fit, start processing it
 535       if (vector_mapped_unroll_factor == saved_mapped_unroll_factor) {
 536         // now add the vector nodes to packsets
 537         for (int i = 0; i &lt; _post_block.length(); i++) {
 538           Node* n = _post_block.at(i);
 539           Node_List* singleton = new Node_List();
 540           singleton-&gt;push(n);
 541           _packset.append(singleton);
 542           set_my_pack(n, singleton);
 543         }
 544 
 545         // map base types for vector usage
 546         compute_vector_element_type();
 547       } else {
 548         return;
 549       }
 550     } else {
 551       // for some reason we could not map the slp analysis state of the vectorized loop
 552       return;
 553     }
 554   }
 555 
 556   output();
 557 }
 558 
 559 //------------------------------find_adjacent_refs---------------------------
 560 // Find the adjacent memory references and create pack pairs for them.
 561 // This is the initial set of packs that will then be extended by
 562 // following use-&gt;def and def-&gt;use links.  The align positions are
 563 // assigned relative to the reference &quot;align_to_ref&quot;
 564 void SuperWord::find_adjacent_refs() {
 565   // Get list of memory operations
 566   Node_List memops;
 567   for (int i = 0; i &lt; _block.length(); i++) {
 568     Node* n = _block.at(i);
 569     if (n-&gt;is_Mem() &amp;&amp; !n-&gt;is_LoadStore() &amp;&amp; in_bb(n) &amp;&amp;
 570         is_java_primitive(n-&gt;as_Mem()-&gt;memory_type())) {
 571       int align = memory_alignment(n-&gt;as_Mem(), 0);
 572       if (align != bottom_align) {
 573         memops.push(n);
 574       }
 575     }
 576   }
 577 
 578   Node_List align_to_refs;
 579   int max_idx;
 580   int best_iv_adjustment = 0;
 581   MemNode* best_align_to_mem_ref = NULL;
 582 
 583   while (memops.size() != 0) {
 584     // Find a memory reference to align to.
 585     MemNode* mem_ref = find_align_to_ref(memops, max_idx);
 586     if (mem_ref == NULL) break;
 587     align_to_refs.push(mem_ref);
 588     int iv_adjustment = get_iv_adjustment(mem_ref);
 589 
 590     if (best_align_to_mem_ref == NULL) {
 591       // Set memory reference which is the best from all memory operations
 592       // to be used for alignment. The pre-loop trip count is modified to align
 593       // this reference to a vector-aligned address.
 594       best_align_to_mem_ref = mem_ref;
 595       best_iv_adjustment = iv_adjustment;
 596       NOT_PRODUCT(find_adjacent_refs_trace_1(best_align_to_mem_ref, best_iv_adjustment);)
 597     }
 598 
 599     SWPointer align_to_ref_p(mem_ref, this, NULL, false);
 600     // Set alignment relative to &quot;align_to_ref&quot; for all related memory operations.
 601     for (int i = memops.size() - 1; i &gt;= 0; i--) {
 602       MemNode* s = memops.at(i)-&gt;as_Mem();
 603       if (isomorphic(s, mem_ref) &amp;&amp;
 604            (!_do_vector_loop || same_origin_idx(s, mem_ref))) {
 605         SWPointer p2(s, this, NULL, false);
 606         if (p2.comparable(align_to_ref_p)) {
 607           int align = memory_alignment(s, iv_adjustment);
 608           set_alignment(s, align);
 609         }
 610       }
 611     }
 612 
 613     // Create initial pack pairs of memory operations for which
 614     // alignment is set and vectors will be aligned.
 615     bool create_pack = true;
 616     if (memory_alignment(mem_ref, best_iv_adjustment) == 0 || _do_vector_loop) {
 617       if (!Matcher::misaligned_vectors_ok() || AlignVector) {
 618         int vw = vector_width(mem_ref);
 619         int vw_best = vector_width(best_align_to_mem_ref);
 620         if (vw &gt; vw_best) {
 621           // Do not vectorize a memory access with more elements per vector
 622           // if unaligned memory access is not allowed because number of
 623           // iterations in pre-loop will be not enough to align it.
 624           create_pack = false;
 625         } else {
 626           SWPointer p2(best_align_to_mem_ref, this, NULL, false);
 627           if (align_to_ref_p.invar() != p2.invar()) {
 628             // Do not vectorize memory accesses with different invariants
 629             // if unaligned memory accesses are not allowed.
 630             create_pack = false;
 631           }
 632         }
 633       }
 634     } else {
 635       if (same_velt_type(mem_ref, best_align_to_mem_ref)) {
 636         // Can&#39;t allow vectorization of unaligned memory accesses with the
 637         // same type since it could be overlapped accesses to the same array.
 638         create_pack = false;
 639       } else {
 640         // Allow independent (different type) unaligned memory operations
 641         // if HW supports them.
 642         if (!Matcher::misaligned_vectors_ok() || AlignVector) {
 643           create_pack = false;
 644         } else {
 645           // Check if packs of the same memory type but
 646           // with a different alignment were created before.
 647           for (uint i = 0; i &lt; align_to_refs.size(); i++) {
 648             MemNode* mr = align_to_refs.at(i)-&gt;as_Mem();
 649             if (mr == mem_ref) {
 650               // Skip when we are looking at same memory operation.
 651               continue;
 652             }
 653             if (same_velt_type(mr, mem_ref) &amp;&amp;
 654                 memory_alignment(mr, iv_adjustment) != 0)
 655               create_pack = false;
 656           }
 657         }
 658       }
 659     }
 660     if (create_pack) {
 661       for (uint i = 0; i &lt; memops.size(); i++) {
 662         Node* s1 = memops.at(i);
 663         int align = alignment(s1);
 664         if (align == top_align) continue;
 665         for (uint j = 0; j &lt; memops.size(); j++) {
 666           Node* s2 = memops.at(j);
 667           if (alignment(s2) == top_align) continue;
 668           if (s1 != s2 &amp;&amp; are_adjacent_refs(s1, s2)) {
 669             if (stmts_can_pack(s1, s2, align)) {
 670               Node_List* pair = new Node_List();
 671               pair-&gt;push(s1);
 672               pair-&gt;push(s2);
 673               if (!_do_vector_loop || same_origin_idx(s1, s2)) {
 674                 _packset.append(pair);
 675               }
 676             }
 677           }
 678         }
 679       }
 680     } else { // Don&#39;t create unaligned pack
 681       // First, remove remaining memory ops of the same type from the list.
 682       for (int i = memops.size() - 1; i &gt;= 0; i--) {
 683         MemNode* s = memops.at(i)-&gt;as_Mem();
 684         if (same_velt_type(s, mem_ref)) {
 685           memops.remove(i);
 686         }
 687       }
 688 
 689       // Second, remove already constructed packs of the same type.
 690       for (int i = _packset.length() - 1; i &gt;= 0; i--) {
 691         Node_List* p = _packset.at(i);
 692         MemNode* s = p-&gt;at(0)-&gt;as_Mem();
 693         if (same_velt_type(s, mem_ref)) {
 694           remove_pack_at(i);
 695         }
 696       }
 697 
 698       // If needed find the best memory reference for loop alignment again.
 699       if (same_velt_type(mem_ref, best_align_to_mem_ref)) {
 700         // Put memory ops from remaining packs back on memops list for
 701         // the best alignment search.
 702         uint orig_msize = memops.size();
 703         for (int i = 0; i &lt; _packset.length(); i++) {
 704           Node_List* p = _packset.at(i);
 705           MemNode* s = p-&gt;at(0)-&gt;as_Mem();
 706           assert(!same_velt_type(s, mem_ref), &quot;sanity&quot;);
 707           memops.push(s);
 708         }
 709         best_align_to_mem_ref = find_align_to_ref(memops, max_idx);
 710         if (best_align_to_mem_ref == NULL) {
 711           if (TraceSuperWord) {
 712             tty-&gt;print_cr(&quot;SuperWord::find_adjacent_refs(): best_align_to_mem_ref == NULL&quot;);
 713           }
 714           // best_align_to_mem_ref will be used for adjusting the pre-loop limit in
 715           // SuperWord::align_initial_loop_index. Find one with the biggest vector size,
 716           // smallest data size and smallest iv offset from memory ops from remaining packs.
 717           if (_packset.length() &gt; 0) {
 718             if (orig_msize == 0) {
 719               best_align_to_mem_ref = memops.at(max_idx)-&gt;as_Mem();
 720             } else {
 721               for (uint i = 0; i &lt; orig_msize; i++) {
 722                 memops.remove(0);
 723               }
 724               best_align_to_mem_ref = find_align_to_ref(memops, max_idx);
 725               assert(best_align_to_mem_ref == NULL, &quot;sanity&quot;);
 726               best_align_to_mem_ref = memops.at(max_idx)-&gt;as_Mem();
 727             }
 728             assert(best_align_to_mem_ref != NULL, &quot;sanity&quot;);
 729           }
 730           break;
 731         }
 732         best_iv_adjustment = get_iv_adjustment(best_align_to_mem_ref);
 733         NOT_PRODUCT(find_adjacent_refs_trace_1(best_align_to_mem_ref, best_iv_adjustment);)
 734         // Restore list.
 735         while (memops.size() &gt; orig_msize)
 736           (void)memops.pop();
 737       }
 738     } // unaligned memory accesses
 739 
 740     // Remove used mem nodes.
 741     for (int i = memops.size() - 1; i &gt;= 0; i--) {
 742       MemNode* m = memops.at(i)-&gt;as_Mem();
 743       if (alignment(m) != top_align) {
 744         memops.remove(i);
 745       }
 746     }
 747 
 748   } // while (memops.size() != 0
 749   set_align_to_ref(best_align_to_mem_ref);
 750 
 751   if (TraceSuperWord) {
 752     tty-&gt;print_cr(&quot;\nAfter find_adjacent_refs&quot;);
 753     print_packset();
 754   }
 755 }
 756 
 757 #ifndef PRODUCT
 758 void SuperWord::find_adjacent_refs_trace_1(Node* best_align_to_mem_ref, int best_iv_adjustment) {
 759   if (is_trace_adjacent()) {
 760     tty-&gt;print(&quot;SuperWord::find_adjacent_refs best_align_to_mem_ref = %d, best_iv_adjustment = %d&quot;,
 761        best_align_to_mem_ref-&gt;_idx, best_iv_adjustment);
 762        best_align_to_mem_ref-&gt;dump();
 763   }
 764 }
 765 #endif
 766 
 767 //------------------------------find_align_to_ref---------------------------
 768 // Find a memory reference to align the loop induction variable to.
 769 // Looks first at stores then at loads, looking for a memory reference
 770 // with the largest number of references similar to it.
 771 MemNode* SuperWord::find_align_to_ref(Node_List &amp;memops, int &amp;idx) {
 772   GrowableArray&lt;int&gt; cmp_ct(arena(), memops.size(), memops.size(), 0);
 773 
 774   // Count number of comparable memory ops
 775   for (uint i = 0; i &lt; memops.size(); i++) {
 776     MemNode* s1 = memops.at(i)-&gt;as_Mem();
 777     SWPointer p1(s1, this, NULL, false);
 778     // Discard if pre loop can&#39;t align this reference
 779     if (!ref_is_alignable(p1)) {
 780       *cmp_ct.adr_at(i) = 0;
 781       continue;
 782     }
 783     for (uint j = i+1; j &lt; memops.size(); j++) {
 784       MemNode* s2 = memops.at(j)-&gt;as_Mem();
 785       if (isomorphic(s1, s2)) {
 786         SWPointer p2(s2, this, NULL, false);
 787         if (p1.comparable(p2)) {
 788           (*cmp_ct.adr_at(i))++;
 789           (*cmp_ct.adr_at(j))++;
 790         }
 791       }
 792     }
 793   }
 794 
 795   // Find Store (or Load) with the greatest number of &quot;comparable&quot; references,
 796   // biggest vector size, smallest data size and smallest iv offset.
 797   int max_ct        = 0;
 798   int max_vw        = 0;
 799   int max_idx       = -1;
 800   int min_size      = max_jint;
 801   int min_iv_offset = max_jint;
 802   for (uint j = 0; j &lt; memops.size(); j++) {
 803     MemNode* s = memops.at(j)-&gt;as_Mem();
 804     if (s-&gt;is_Store()) {
 805       int vw = vector_width_in_bytes(s);
 806       assert(vw &gt; 1, &quot;sanity&quot;);
 807       SWPointer p(s, this, NULL, false);
 808       if ( cmp_ct.at(j) &gt;  max_ct ||
 809           (cmp_ct.at(j) == max_ct &amp;&amp;
 810             ( vw &gt;  max_vw ||
 811              (vw == max_vw &amp;&amp;
 812               ( data_size(s) &lt;  min_size ||
 813                (data_size(s) == min_size &amp;&amp;
 814                 p.offset_in_bytes() &lt; min_iv_offset)))))) {
 815         max_ct = cmp_ct.at(j);
 816         max_vw = vw;
 817         max_idx = j;
 818         min_size = data_size(s);
 819         min_iv_offset = p.offset_in_bytes();
 820       }
 821     }
 822   }
 823   // If no stores, look at loads
 824   if (max_ct == 0) {
 825     for (uint j = 0; j &lt; memops.size(); j++) {
 826       MemNode* s = memops.at(j)-&gt;as_Mem();
 827       if (s-&gt;is_Load()) {
 828         int vw = vector_width_in_bytes(s);
 829         assert(vw &gt; 1, &quot;sanity&quot;);
 830         SWPointer p(s, this, NULL, false);
 831         if ( cmp_ct.at(j) &gt;  max_ct ||
 832             (cmp_ct.at(j) == max_ct &amp;&amp;
 833               ( vw &gt;  max_vw ||
 834                (vw == max_vw &amp;&amp;
 835                 ( data_size(s) &lt;  min_size ||
 836                  (data_size(s) == min_size &amp;&amp;
 837                   p.offset_in_bytes() &lt; min_iv_offset)))))) {
 838           max_ct = cmp_ct.at(j);
 839           max_vw = vw;
 840           max_idx = j;
 841           min_size = data_size(s);
 842           min_iv_offset = p.offset_in_bytes();
 843         }
 844       }
 845     }
 846   }
 847 
 848 #ifdef ASSERT
 849   if (TraceSuperWord &amp;&amp; Verbose) {
 850     tty-&gt;print_cr(&quot;\nVector memops after find_align_to_ref&quot;);
 851     for (uint i = 0; i &lt; memops.size(); i++) {
 852       MemNode* s = memops.at(i)-&gt;as_Mem();
 853       s-&gt;dump();
 854     }
 855   }
 856 #endif
 857 
 858   idx = max_idx;
 859   if (max_ct &gt; 0) {
 860 #ifdef ASSERT
 861     if (TraceSuperWord) {
 862       tty-&gt;print(&quot;\nVector align to node: &quot;);
 863       memops.at(max_idx)-&gt;as_Mem()-&gt;dump();
 864     }
 865 #endif
 866     return memops.at(max_idx)-&gt;as_Mem();
 867   }
 868   return NULL;
 869 }
 870 
 871 //------------------span_works_for_memory_size-----------------------------
 872 static bool span_works_for_memory_size(MemNode* mem, int span, int mem_size, int offset) {
 873   bool span_matches_memory = false;
 874   if ((mem_size == type2aelembytes(T_BYTE) || mem_size == type2aelembytes(T_SHORT))
 875     &amp;&amp; ABS(span) == type2aelembytes(T_INT)) {
 876     // There is a mismatch on span size compared to memory.
 877     for (DUIterator_Fast jmax, j = mem-&gt;fast_outs(jmax); j &lt; jmax; j++) {
 878       Node* use = mem-&gt;fast_out(j);
 879       if (!VectorNode::is_type_transition_to_int(use)) {
 880         return false;
 881       }
 882     }
 883     // If all uses transition to integer, it means that we can successfully align even on mismatch.
 884     return true;
 885   }
 886   else {
 887     span_matches_memory = ABS(span) == mem_size;
 888   }
 889   return span_matches_memory &amp;&amp; (ABS(offset) % mem_size) == 0;
 890 }
 891 
 892 //------------------------------ref_is_alignable---------------------------
 893 // Can the preloop align the reference to position zero in the vector?
 894 bool SuperWord::ref_is_alignable(SWPointer&amp; p) {
 895   if (!p.has_iv()) {
 896     return true;   // no induction variable
 897   }
 898   CountedLoopEndNode* pre_end = get_pre_loop_end(lp()-&gt;as_CountedLoop());
 899   assert(pre_end != NULL, &quot;we must have a correct pre-loop&quot;);
 900   assert(pre_end-&gt;stride_is_con(), &quot;pre loop stride is constant&quot;);
 901   int preloop_stride = pre_end-&gt;stride_con();
 902 
 903   int span = preloop_stride * p.scale_in_bytes();
 904   int mem_size = p.memory_size();
 905   int offset   = p.offset_in_bytes();
 906   // Stride one accesses are alignable if offset is aligned to memory operation size.
 907   // Offset can be unaligned when UseUnalignedAccesses is used.
 908   if (span_works_for_memory_size(p.mem(), span, mem_size, offset)) {
 909     return true;
 910   }
 911   // If the initial offset from start of the object is computable,
 912   // check if the pre-loop can align the final offset accordingly.
 913   //
 914   // In other words: Can we find an i such that the offset
 915   // after i pre-loop iterations is aligned to vw?
 916   //   (init_offset + pre_loop) % vw == 0              (1)
 917   // where
 918   //   pre_loop = i * span
 919   // is the number of bytes added to the offset by i pre-loop iterations.
 920   //
 921   // For this to hold we need pre_loop to increase init_offset by
 922   //   pre_loop = vw - (init_offset % vw)
 923   //
 924   // This is only possible if pre_loop is divisible by span because each
 925   // pre-loop iteration increases the initial offset by &#39;span&#39; bytes:
 926   //   (vw - (init_offset % vw)) % span == 0
 927   //
 928   int vw = vector_width_in_bytes(p.mem());
 929   assert(vw &gt; 1, &quot;sanity&quot;);
 930   Node* init_nd = pre_end-&gt;init_trip();
 931   if (init_nd-&gt;is_Con() &amp;&amp; p.invar() == NULL) {
 932     int init = init_nd-&gt;bottom_type()-&gt;is_int()-&gt;get_con();
 933     int init_offset = init * p.scale_in_bytes() + offset;
 934     if (init_offset &lt; 0) { // negative offset from object start?
 935       return false;        // may happen in dead loop
 936     }
 937     if (vw % span == 0) {
 938       // If vm is a multiple of span, we use formula (1).
 939       if (span &gt; 0) {
 940         return (vw - (init_offset % vw)) % span == 0;
 941       } else {
 942         assert(span &lt; 0, &quot;nonzero stride * scale&quot;);
 943         return (init_offset % vw) % -span == 0;
 944       }
 945     } else if (span % vw == 0) {
 946       // If span is a multiple of vw, we can simplify formula (1) to:
 947       //   (init_offset + i * span) % vw == 0
 948       //     =&gt;
 949       //   (init_offset % vw) + ((i * span) % vw) == 0
 950       //     =&gt;
 951       //   init_offset % vw == 0
 952       //
 953       // Because we add a multiple of vw to the initial offset, the final
 954       // offset is a multiple of vw if and only if init_offset is a multiple.
 955       //
 956       return (init_offset % vw) == 0;
 957     }
 958   }
 959   return false;
 960 }
 961 //---------------------------get_vw_bytes_special------------------------
 962 int SuperWord::get_vw_bytes_special(MemNode* s) {
 963   // Get the vector width in bytes.
 964   int vw = vector_width_in_bytes(s);
 965 
 966   // Check for special case where there is an MulAddS2I usage where short vectors are going to need combined.
 967   BasicType btype = velt_basic_type(s);
 968   if (type2aelembytes(btype) == 2) {
 969     bool should_combine_adjacent = true;
 970     for (DUIterator_Fast imax, i = s-&gt;fast_outs(imax); i &lt; imax; i++) {
 971       Node* user = s-&gt;fast_out(i);
 972       if (!VectorNode::is_muladds2i(user)) {
 973         should_combine_adjacent = false;
 974       }
 975     }
 976     if (should_combine_adjacent) {
 977       vw = MIN2(Matcher::max_vector_size(btype)*type2aelembytes(btype), vw * 2);
 978     }
 979   }
 980 
 981   return vw;
 982 }
 983 
 984 //---------------------------get_iv_adjustment---------------------------
 985 // Calculate loop&#39;s iv adjustment for this memory ops.
 986 int SuperWord::get_iv_adjustment(MemNode* mem_ref) {
 987   SWPointer align_to_ref_p(mem_ref, this, NULL, false);
 988   int offset = align_to_ref_p.offset_in_bytes();
 989   int scale  = align_to_ref_p.scale_in_bytes();
 990   int elt_size = align_to_ref_p.memory_size();
 991   int vw       = get_vw_bytes_special(mem_ref);
 992   assert(vw &gt; 1, &quot;sanity&quot;);
 993   int iv_adjustment;
 994   if (scale != 0) {
 995     int stride_sign = (scale * iv_stride()) &gt; 0 ? 1 : -1;
 996     // At least one iteration is executed in pre-loop by default. As result
 997     // several iterations are needed to align memory operations in main-loop even
 998     // if offset is 0.
 999     int iv_adjustment_in_bytes = (stride_sign * vw - (offset % vw));
1000     assert(((ABS(iv_adjustment_in_bytes) % elt_size) == 0),
1001            &quot;(%d) should be divisible by (%d)&quot;, iv_adjustment_in_bytes, elt_size);
1002     iv_adjustment = iv_adjustment_in_bytes/elt_size;
1003   } else {
1004     // This memory op is not dependent on iv (scale == 0)
1005     iv_adjustment = 0;
1006   }
1007 
1008 #ifndef PRODUCT
1009   if (TraceSuperWord) {
1010     tty-&gt;print(&quot;SuperWord::get_iv_adjustment: n = %d, noffset = %d iv_adjust = %d elt_size = %d scale = %d iv_stride = %d vect_size %d: &quot;,
1011       mem_ref-&gt;_idx, offset, iv_adjustment, elt_size, scale, iv_stride(), vw);
1012     mem_ref-&gt;dump();
1013   }
1014 #endif
1015   return iv_adjustment;
1016 }
1017 
1018 //---------------------------dependence_graph---------------------------
1019 // Construct dependency graph.
1020 // Add dependence edges to load/store nodes for memory dependence
1021 //    A.out()-&gt;DependNode.in(1) and DependNode.out()-&gt;B.prec(x)
1022 void SuperWord::dependence_graph() {
1023   CountedLoopNode *cl = lpt()-&gt;_head-&gt;as_CountedLoop();
1024   // First, assign a dependence node to each memory node
1025   for (int i = 0; i &lt; _block.length(); i++ ) {
1026     Node *n = _block.at(i);
1027     if (n-&gt;is_Mem() || (n-&gt;is_Phi() &amp;&amp; n-&gt;bottom_type() == Type::MEMORY)) {
1028       _dg.make_node(n);
1029     }
1030   }
1031 
1032   // For each memory slice, create the dependences
1033   for (int i = 0; i &lt; _mem_slice_head.length(); i++) {
1034     Node* n      = _mem_slice_head.at(i);
1035     Node* n_tail = _mem_slice_tail.at(i);
1036 
1037     // Get slice in predecessor order (last is first)
1038     if (cl-&gt;is_main_loop()) {
1039       mem_slice_preds(n_tail, n, _nlist);
1040     }
1041 
1042 #ifndef PRODUCT
1043     if(TraceSuperWord &amp;&amp; Verbose) {
1044       tty-&gt;print_cr(&quot;SuperWord::dependence_graph: built a new mem slice&quot;);
1045       for (int j = _nlist.length() - 1; j &gt;= 0 ; j--) {
1046         _nlist.at(j)-&gt;dump();
1047       }
1048     }
1049 #endif
1050     // Make the slice dependent on the root
1051     DepMem* slice = _dg.dep(n);
1052     _dg.make_edge(_dg.root(), slice);
1053 
1054     // Create a sink for the slice
1055     DepMem* slice_sink = _dg.make_node(NULL);
1056     _dg.make_edge(slice_sink, _dg.tail());
1057 
1058     // Now visit each pair of memory ops, creating the edges
1059     for (int j = _nlist.length() - 1; j &gt;= 0 ; j--) {
1060       Node* s1 = _nlist.at(j);
1061 
1062       // If no dependency yet, use slice
1063       if (_dg.dep(s1)-&gt;in_cnt() == 0) {
1064         _dg.make_edge(slice, s1);
1065       }
1066       SWPointer p1(s1-&gt;as_Mem(), this, NULL, false);
1067       bool sink_dependent = true;
1068       for (int k = j - 1; k &gt;= 0; k--) {
1069         Node* s2 = _nlist.at(k);
1070         if (s1-&gt;is_Load() &amp;&amp; s2-&gt;is_Load())
1071           continue;
1072         SWPointer p2(s2-&gt;as_Mem(), this, NULL, false);
1073 
1074         int cmp = p1.cmp(p2);
1075         if (SuperWordRTDepCheck &amp;&amp;
1076             p1.base() != p2.base() &amp;&amp; p1.valid() &amp;&amp; p2.valid()) {
1077           // Create a runtime check to disambiguate
1078           OrderedPair pp(p1.base(), p2.base());
1079           _disjoint_ptrs.append_if_missing(pp);
1080         } else if (!SWPointer::not_equal(cmp)) {
1081           // Possibly same address
1082           _dg.make_edge(s1, s2);
1083           sink_dependent = false;
1084         }
1085       }
1086       if (sink_dependent) {
1087         _dg.make_edge(s1, slice_sink);
1088       }
1089     }
1090 
1091     if (TraceSuperWord) {
1092       tty-&gt;print_cr(&quot;\nDependence graph for slice: %d&quot;, n-&gt;_idx);
1093       for (int q = 0; q &lt; _nlist.length(); q++) {
1094         _dg.print(_nlist.at(q));
1095       }
1096       tty-&gt;cr();
1097     }
1098 
1099     _nlist.clear();
1100   }
1101 
1102   if (TraceSuperWord) {
1103     tty-&gt;print_cr(&quot;\ndisjoint_ptrs: %s&quot;, _disjoint_ptrs.length() &gt; 0 ? &quot;&quot; : &quot;NONE&quot;);
1104     for (int r = 0; r &lt; _disjoint_ptrs.length(); r++) {
1105       _disjoint_ptrs.at(r).print();
1106       tty-&gt;cr();
1107     }
1108     tty-&gt;cr();
1109   }
1110 
1111 }
1112 
1113 //---------------------------mem_slice_preds---------------------------
1114 // Return a memory slice (node list) in predecessor order starting at &quot;start&quot;
1115 void SuperWord::mem_slice_preds(Node* start, Node* stop, GrowableArray&lt;Node*&gt; &amp;preds) {
1116   assert(preds.length() == 0, &quot;start empty&quot;);
1117   Node* n = start;
1118   Node* prev = NULL;
1119   while (true) {
1120     NOT_PRODUCT( if(is_trace_mem_slice()) tty-&gt;print_cr(&quot;SuperWord::mem_slice_preds: n %d&quot;, n-&gt;_idx);)
1121     assert(in_bb(n), &quot;must be in block&quot;);
1122     for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1123       Node* out = n-&gt;fast_out(i);
1124       if (out-&gt;is_Load()) {
1125         if (in_bb(out)) {
1126           preds.push(out);
1127           if (TraceSuperWord &amp;&amp; Verbose) {
1128             tty-&gt;print_cr(&quot;SuperWord::mem_slice_preds: added pred(%d)&quot;, out-&gt;_idx);
1129           }
1130         }
1131       } else {
1132         // FIXME
1133         if (out-&gt;is_MergeMem() &amp;&amp; !in_bb(out)) {
1134           // Either unrolling is causing a memory edge not to disappear,
1135           // or need to run igvn.optimize() again before SLP
1136         } else if (out-&gt;is_Phi() &amp;&amp; out-&gt;bottom_type() == Type::MEMORY &amp;&amp; !in_bb(out)) {
1137           // Ditto.  Not sure what else to check further.
1138         } else if (out-&gt;Opcode() == Op_StoreCM &amp;&amp; out-&gt;in(MemNode::OopStore) == n) {
1139           // StoreCM has an input edge used as a precedence edge.
1140           // Maybe an issue when oop stores are vectorized.
1141         } else {
1142           assert(out == prev || prev == NULL, &quot;no branches off of store slice&quot;);
1143         }
1144       }//else
1145     }//for
1146     if (n == stop) break;
1147     preds.push(n);
1148     if (TraceSuperWord &amp;&amp; Verbose) {
1149       tty-&gt;print_cr(&quot;SuperWord::mem_slice_preds: added pred(%d)&quot;, n-&gt;_idx);
1150     }
1151     prev = n;
1152     assert(n-&gt;is_Mem(), &quot;unexpected node %s&quot;, n-&gt;Name());
1153     n = n-&gt;in(MemNode::Memory);
1154   }
1155 }
1156 
1157 //------------------------------stmts_can_pack---------------------------
1158 // Can s1 and s2 be in a pack with s1 immediately preceding s2 and
1159 // s1 aligned at &quot;align&quot;
1160 bool SuperWord::stmts_can_pack(Node* s1, Node* s2, int align) {
1161 
1162   // Do not use superword for non-primitives
1163   BasicType bt1 = velt_basic_type(s1);
1164   BasicType bt2 = velt_basic_type(s2);
1165   if(!is_java_primitive(bt1) || !is_java_primitive(bt2))
1166     return false;
1167   if (Matcher::max_vector_size(bt1) &lt; 2) {
1168     return false; // No vectors for this type
1169   }
1170 
1171   if (isomorphic(s1, s2)) {
1172     if ((independent(s1, s2) &amp;&amp; have_similar_inputs(s1, s2)) || reduction(s1, s2)) {
1173       if (!exists_at(s1, 0) &amp;&amp; !exists_at(s2, 1)) {
1174         if (!s1-&gt;is_Mem() || are_adjacent_refs(s1, s2)) {
1175           int s1_align = alignment(s1);
1176           int s2_align = alignment(s2);
1177           if (s1_align == top_align || s1_align == align) {
1178             if (s2_align == top_align || s2_align == align + data_size(s1)) {
1179               return true;
1180             }
1181           }
1182         }
1183       }
1184     }
1185   }
1186   return false;
1187 }
1188 
1189 //------------------------------exists_at---------------------------
1190 // Does s exist in a pack at position pos?
1191 bool SuperWord::exists_at(Node* s, uint pos) {
1192   for (int i = 0; i &lt; _packset.length(); i++) {
1193     Node_List* p = _packset.at(i);
1194     if (p-&gt;at(pos) == s) {
1195       return true;
1196     }
1197   }
1198   return false;
1199 }
1200 
1201 //------------------------------are_adjacent_refs---------------------------
1202 // Is s1 immediately before s2 in memory?
1203 bool SuperWord::are_adjacent_refs(Node* s1, Node* s2) {
1204   if (!s1-&gt;is_Mem() || !s2-&gt;is_Mem()) return false;
1205   if (!in_bb(s1)    || !in_bb(s2))    return false;
1206 
1207   // Do not use superword for non-primitives
1208   if (!is_java_primitive(s1-&gt;as_Mem()-&gt;memory_type()) ||
1209       !is_java_primitive(s2-&gt;as_Mem()-&gt;memory_type())) {
1210     return false;
1211   }
1212 
1213   // FIXME - co_locate_pack fails on Stores in different mem-slices, so
1214   // only pack memops that are in the same alias set until that&#39;s fixed.
1215   if (_phase-&gt;C-&gt;get_alias_index(s1-&gt;as_Mem()-&gt;adr_type()) !=
1216       _phase-&gt;C-&gt;get_alias_index(s2-&gt;as_Mem()-&gt;adr_type()))
1217     return false;
1218   SWPointer p1(s1-&gt;as_Mem(), this, NULL, false);
1219   SWPointer p2(s2-&gt;as_Mem(), this, NULL, false);
1220   if (p1.base() != p2.base() || !p1.comparable(p2)) return false;
1221   int diff = p2.offset_in_bytes() - p1.offset_in_bytes();
1222   return diff == data_size(s1);
1223 }
1224 
1225 //------------------------------isomorphic---------------------------
1226 // Are s1 and s2 similar?
1227 bool SuperWord::isomorphic(Node* s1, Node* s2) {
1228   if (s1-&gt;Opcode() != s2-&gt;Opcode()) return false;
1229   if (s1-&gt;req() != s2-&gt;req()) return false;
1230   if (!same_velt_type(s1, s2)) return false;
1231   Node* s1_ctrl = s1-&gt;in(0);
1232   Node* s2_ctrl = s2-&gt;in(0);
1233   // If the control nodes are equivalent, no further checks are required to test for isomorphism.
1234   if (s1_ctrl == s2_ctrl) {
1235     return true;
1236   } else {
1237     bool s1_ctrl_inv = ((s1_ctrl == NULL) ? true : lpt()-&gt;is_invariant(s1_ctrl));
1238     bool s2_ctrl_inv = ((s2_ctrl == NULL) ? true : lpt()-&gt;is_invariant(s2_ctrl));
1239     // If the control nodes are not invariant for the loop, fail isomorphism test.
1240     if (!s1_ctrl_inv || !s2_ctrl_inv) {
1241       return false;
1242     }
1243     if(s1_ctrl != NULL &amp;&amp; s2_ctrl != NULL) {
1244       if (s1_ctrl-&gt;is_Proj()) {
1245         s1_ctrl = s1_ctrl-&gt;in(0);
1246         assert(lpt()-&gt;is_invariant(s1_ctrl), &quot;must be invariant&quot;);
1247       }
1248       if (s2_ctrl-&gt;is_Proj()) {
1249         s2_ctrl = s2_ctrl-&gt;in(0);
1250         assert(lpt()-&gt;is_invariant(s2_ctrl), &quot;must be invariant&quot;);
1251       }
1252       if (!s1_ctrl-&gt;is_RangeCheck() || !s2_ctrl-&gt;is_RangeCheck()) {
1253         return false;
1254       }
1255     }
1256     // Control nodes are invariant. However, we have no way of checking whether they resolve
1257     // in an equivalent manner. But, we know that invariant range checks are guaranteed to
1258     // throw before the loop (if they would have thrown). Thus, the loop would not have been reached.
1259     // Therefore, if the control nodes for both are range checks, we accept them to be isomorphic.
1260     for (DUIterator_Fast imax, i = s1-&gt;fast_outs(imax); i &lt; imax; i++) {
1261       Node* t1 = s1-&gt;fast_out(i);
1262       for (DUIterator_Fast jmax, j = s2-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1263         Node* t2 = s2-&gt;fast_out(j);
1264         if (VectorNode::is_muladds2i(t1) &amp;&amp; VectorNode::is_muladds2i(t2)) {
1265           return true;
1266         }
1267       }
1268     }
1269   }
1270   return false;
1271 }
1272 
1273 //------------------------------independent---------------------------
1274 // Is there no data path from s1 to s2 or s2 to s1?
1275 bool SuperWord::independent(Node* s1, Node* s2) {
1276   //  assert(s1-&gt;Opcode() == s2-&gt;Opcode(), &quot;check isomorphic first&quot;);
1277   int d1 = depth(s1);
1278   int d2 = depth(s2);
1279   if (d1 == d2) return s1 != s2;
1280   Node* deep    = d1 &gt; d2 ? s1 : s2;
1281   Node* shallow = d1 &gt; d2 ? s2 : s1;
1282 
1283   visited_clear();
1284 
1285   return independent_path(shallow, deep);
1286 }
1287 
1288 //--------------------------have_similar_inputs-----------------------
1289 // For a node pair (s1, s2) which is isomorphic and independent,
1290 // do s1 and s2 have similar input edges?
1291 bool SuperWord::have_similar_inputs(Node* s1, Node* s2) {
1292   // assert(isomorphic(s1, s2) == true, &quot;check isomorphic&quot;);
1293   // assert(independent(s1, s2) == true, &quot;check independent&quot;);
1294   if (s1-&gt;req() &gt; 1 &amp;&amp; !s1-&gt;is_Store() &amp;&amp; !s1-&gt;is_Load()) {
1295     for (uint i = 1; i &lt; s1-&gt;req(); i++) {
1296       if (s1-&gt;in(i)-&gt;Opcode() != s2-&gt;in(i)-&gt;Opcode()) return false;
1297     }
1298   }
1299   return true;
1300 }
1301 
1302 //------------------------------reduction---------------------------
1303 // Is there a data path between s1 and s2 and the nodes reductions?
1304 bool SuperWord::reduction(Node* s1, Node* s2) {
1305   bool retValue = false;
1306   int d1 = depth(s1);
1307   int d2 = depth(s2);
1308   if (d1 + 1 == d2) {
1309     if (s1-&gt;is_reduction() &amp;&amp; s2-&gt;is_reduction()) {
1310       // This is an ordered set, so s1 should define s2
1311       for (DUIterator_Fast imax, i = s1-&gt;fast_outs(imax); i &lt; imax; i++) {
1312         Node* t1 = s1-&gt;fast_out(i);
1313         if (t1 == s2) {
1314           // both nodes are reductions and connected
1315           retValue = true;
1316         }
1317       }
1318     }
1319   }
1320 
1321   return retValue;
1322 }
1323 
1324 //------------------------------independent_path------------------------------
1325 // Helper for independent
1326 bool SuperWord::independent_path(Node* shallow, Node* deep, uint dp) {
1327   if (dp &gt;= 1000) return false; // stop deep recursion
1328   visited_set(deep);
1329   int shal_depth = depth(shallow);
1330   assert(shal_depth &lt;= depth(deep), &quot;must be&quot;);
1331   for (DepPreds preds(deep, _dg); !preds.done(); preds.next()) {
1332     Node* pred = preds.current();
1333     if (in_bb(pred) &amp;&amp; !visited_test(pred)) {
1334       if (shallow == pred) {
1335         return false;
1336       }
1337       if (shal_depth &lt; depth(pred) &amp;&amp; !independent_path(shallow, pred, dp+1)) {
1338         return false;
1339       }
1340     }
1341   }
1342   return true;
1343 }
1344 
1345 //------------------------------set_alignment---------------------------
1346 void SuperWord::set_alignment(Node* s1, Node* s2, int align) {
1347   set_alignment(s1, align);
1348   if (align == top_align || align == bottom_align) {
1349     set_alignment(s2, align);
1350   } else {
1351     set_alignment(s2, align + data_size(s1));
1352   }
1353 }
1354 
1355 //------------------------------data_size---------------------------
1356 int SuperWord::data_size(Node* s) {
1357   Node* use = NULL; //test if the node is a candidate for CMoveV optimization, then return the size of CMov
1358   if (UseVectorCmov) {
1359     use = _cmovev_kit.is_Bool_candidate(s);
1360     if (use != NULL) {
1361       return data_size(use);
1362     }
1363     use = _cmovev_kit.is_CmpD_candidate(s);
1364     if (use != NULL) {
1365       return data_size(use);
1366     }
1367   }
1368 
1369   int bsize = type2aelembytes(velt_basic_type(s));
1370   assert(bsize != 0, &quot;valid size&quot;);
1371   return bsize;
1372 }
1373 
1374 //------------------------------extend_packlist---------------------------
1375 // Extend packset by following use-&gt;def and def-&gt;use links from pack members.
1376 void SuperWord::extend_packlist() {
1377   bool changed;
1378   do {
1379     packset_sort(_packset.length());
1380     changed = false;
1381     for (int i = 0; i &lt; _packset.length(); i++) {
1382       Node_List* p = _packset.at(i);
1383       changed |= follow_use_defs(p);
1384       changed |= follow_def_uses(p);
1385     }
1386   } while (changed);
1387 
1388   if (_race_possible) {
1389     for (int i = 0; i &lt; _packset.length(); i++) {
1390       Node_List* p = _packset.at(i);
1391       order_def_uses(p);
1392     }
1393   }
1394 
1395   if (TraceSuperWord) {
1396     tty-&gt;print_cr(&quot;\nAfter extend_packlist&quot;);
1397     print_packset();
1398   }
1399 }
1400 
1401 //------------------------------follow_use_defs---------------------------
1402 // Extend the packset by visiting operand definitions of nodes in pack p
1403 bool SuperWord::follow_use_defs(Node_List* p) {
1404   assert(p-&gt;size() == 2, &quot;just checking&quot;);
1405   Node* s1 = p-&gt;at(0);
1406   Node* s2 = p-&gt;at(1);
1407   assert(s1-&gt;req() == s2-&gt;req(), &quot;just checking&quot;);
1408   assert(alignment(s1) + data_size(s1) == alignment(s2), &quot;just checking&quot;);
1409 
1410   if (s1-&gt;is_Load()) return false;
1411 
1412   int align = alignment(s1);
1413   NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print_cr(&quot;SuperWord::follow_use_defs: s1 %d, align %d&quot;, s1-&gt;_idx, align);)
1414   bool changed = false;
1415   int start = s1-&gt;is_Store() ? MemNode::ValueIn   : 1;
1416   int end   = s1-&gt;is_Store() ? MemNode::ValueIn+1 : s1-&gt;req();
1417   for (int j = start; j &lt; end; j++) {
1418     Node* t1 = s1-&gt;in(j);
1419     Node* t2 = s2-&gt;in(j);
1420     if (!in_bb(t1) || !in_bb(t2))
1421       continue;
1422     if (stmts_can_pack(t1, t2, align)) {
1423       if (est_savings(t1, t2) &gt;= 0) {
1424         Node_List* pair = new Node_List();
1425         pair-&gt;push(t1);
1426         pair-&gt;push(t2);
1427         _packset.append(pair);
1428         NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print_cr(&quot;SuperWord::follow_use_defs: set_alignment(%d, %d, %d)&quot;, t1-&gt;_idx, t2-&gt;_idx, align);)
1429         set_alignment(t1, t2, align);
1430         changed = true;
1431       }
1432     }
1433   }
1434   return changed;
1435 }
1436 
1437 //------------------------------follow_def_uses---------------------------
1438 // Extend the packset by visiting uses of nodes in pack p
1439 bool SuperWord::follow_def_uses(Node_List* p) {
1440   bool changed = false;
1441   Node* s1 = p-&gt;at(0);
1442   Node* s2 = p-&gt;at(1);
1443   assert(p-&gt;size() == 2, &quot;just checking&quot;);
1444   assert(s1-&gt;req() == s2-&gt;req(), &quot;just checking&quot;);
1445   assert(alignment(s1) + data_size(s1) == alignment(s2), &quot;just checking&quot;);
1446 
1447   if (s1-&gt;is_Store()) return false;
1448 
1449   int align = alignment(s1);
1450   NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print_cr(&quot;SuperWord::follow_def_uses: s1 %d, align %d&quot;, s1-&gt;_idx, align);)
1451   int savings = -1;
1452   int num_s1_uses = 0;
1453   Node* u1 = NULL;
1454   Node* u2 = NULL;
1455   for (DUIterator_Fast imax, i = s1-&gt;fast_outs(imax); i &lt; imax; i++) {
1456     Node* t1 = s1-&gt;fast_out(i);
1457     num_s1_uses++;
1458     if (!in_bb(t1)) continue;
1459     for (DUIterator_Fast jmax, j = s2-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1460       Node* t2 = s2-&gt;fast_out(j);
1461       if (!in_bb(t2)) continue;
1462       if (t2-&gt;Opcode() == Op_AddI &amp;&amp; t2 == _lp-&gt;as_CountedLoop()-&gt;incr()) continue; // don&#39;t mess with the iv
1463       if (!opnd_positions_match(s1, t1, s2, t2))
1464         continue;
1465       if (stmts_can_pack(t1, t2, align)) {
1466         int my_savings = est_savings(t1, t2);
1467         if (my_savings &gt; savings) {
1468           savings = my_savings;
1469           u1 = t1;
1470           u2 = t2;
1471         }
1472       }
1473     }
1474   }
1475   if (num_s1_uses &gt; 1) {
1476     _race_possible = true;
1477   }
1478   if (savings &gt;= 0) {
1479     Node_List* pair = new Node_List();
1480     pair-&gt;push(u1);
1481     pair-&gt;push(u2);
1482     _packset.append(pair);
1483     NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print_cr(&quot;SuperWord::follow_def_uses: set_alignment(%d, %d, %d)&quot;, u1-&gt;_idx, u2-&gt;_idx, align);)
1484     set_alignment(u1, u2, align);
1485     changed = true;
1486   }
1487   return changed;
1488 }
1489 
1490 //------------------------------order_def_uses---------------------------
1491 // For extended packsets, ordinally arrange uses packset by major component
1492 void SuperWord::order_def_uses(Node_List* p) {
1493   Node* s1 = p-&gt;at(0);
1494 
1495   if (s1-&gt;is_Store()) return;
1496 
1497   // reductions are always managed beforehand
1498   if (s1-&gt;is_reduction()) return;
1499 
1500   for (DUIterator_Fast imax, i = s1-&gt;fast_outs(imax); i &lt; imax; i++) {
1501     Node* t1 = s1-&gt;fast_out(i);
1502 
1503     // Only allow operand swap on commuting operations
1504     if (!t1-&gt;is_Add() &amp;&amp; !t1-&gt;is_Mul() &amp;&amp; !VectorNode::is_muladds2i(t1)) {
1505       break;
1506     }
1507 
1508     // Now find t1&#39;s packset
1509     Node_List* p2 = NULL;
1510     for (int j = 0; j &lt; _packset.length(); j++) {
1511       p2 = _packset.at(j);
1512       Node* first = p2-&gt;at(0);
1513       if (t1 == first) {
1514         break;
1515       }
1516       p2 = NULL;
1517     }
1518     // Arrange all sub components by the major component
1519     if (p2 != NULL) {
1520       for (uint j = 1; j &lt; p-&gt;size(); j++) {
1521         Node* d1 = p-&gt;at(j);
1522         Node* u1 = p2-&gt;at(j);
1523         opnd_positions_match(s1, t1, d1, u1);
1524       }
1525     }
1526   }
1527 }
1528 
1529 //---------------------------opnd_positions_match-------------------------
1530 // Is the use of d1 in u1 at the same operand position as d2 in u2?
1531 bool SuperWord::opnd_positions_match(Node* d1, Node* u1, Node* d2, Node* u2) {
1532   // check reductions to see if they are marshalled to represent the reduction
1533   // operator in a specified opnd
1534   if (u1-&gt;is_reduction() &amp;&amp; u2-&gt;is_reduction()) {
1535     // ensure reductions have phis and reduction definitions feeding the 1st operand
1536     Node* first = u1-&gt;in(2);
1537     if (first-&gt;is_Phi() || first-&gt;is_reduction()) {
1538       u1-&gt;swap_edges(1, 2);
1539     }
1540     // ensure reductions have phis and reduction definitions feeding the 1st operand
1541     first = u2-&gt;in(2);
1542     if (first-&gt;is_Phi() || first-&gt;is_reduction()) {
1543       u2-&gt;swap_edges(1, 2);
1544     }
1545     return true;
1546   }
1547 
1548   uint ct = u1-&gt;req();
1549   if (ct != u2-&gt;req()) return false;
1550   uint i1 = 0;
1551   uint i2 = 0;
1552   do {
1553     for (i1++; i1 &lt; ct; i1++) if (u1-&gt;in(i1) == d1) break;
1554     for (i2++; i2 &lt; ct; i2++) if (u2-&gt;in(i2) == d2) break;
1555     if (i1 != i2) {
1556       if ((i1 == (3-i2)) &amp;&amp; (u2-&gt;is_Add() || u2-&gt;is_Mul())) {
1557         // Further analysis relies on operands position matching.
1558         u2-&gt;swap_edges(i1, i2);
1559       } else if (VectorNode::is_muladds2i(u2) &amp;&amp; u1 != u2) {
1560         if (i1 == 5 - i2) { // ((i1 == 3 &amp;&amp; i2 == 2) || (i1 == 2 &amp;&amp; i2 == 3) || (i1 == 1 &amp;&amp; i2 == 4) || (i1 == 4 &amp;&amp; i2 == 1))
1561           u2-&gt;swap_edges(1, 2);
1562           u2-&gt;swap_edges(3, 4);
1563         }
1564         if (i1 == 3 - i2 || i1 == 7 - i2) { // ((i1 == 1 &amp;&amp; i2 == 2) || (i1 == 2 &amp;&amp; i2 == 1) || (i1 == 3 &amp;&amp; i2 == 4) || (i1 == 4 &amp;&amp; i2 == 3))
1565           u2-&gt;swap_edges(2, 3);
1566           u2-&gt;swap_edges(1, 4);
1567         }
1568         return false; // Just swap the edges, the muladds2i nodes get packed in follow_use_defs
1569       } else {
1570         return false;
1571       }
1572     } else if (i1 == i2 &amp;&amp; VectorNode::is_muladds2i(u2) &amp;&amp; u1 != u2) {
1573       u2-&gt;swap_edges(1, 3);
1574       u2-&gt;swap_edges(2, 4);
1575       return false; // Just swap the edges, the muladds2i nodes get packed in follow_use_defs
1576     }
1577   } while (i1 &lt; ct);
1578   return true;
1579 }
1580 
1581 //------------------------------est_savings---------------------------
1582 // Estimate the savings from executing s1 and s2 as a pack
1583 int SuperWord::est_savings(Node* s1, Node* s2) {
1584   int save_in = 2 - 1; // 2 operations per instruction in packed form
1585 
1586   // inputs
1587   for (uint i = 1; i &lt; s1-&gt;req(); i++) {
1588     Node* x1 = s1-&gt;in(i);
1589     Node* x2 = s2-&gt;in(i);
1590     if (x1 != x2) {
1591       if (are_adjacent_refs(x1, x2)) {
1592         save_in += adjacent_profit(x1, x2);
1593       } else if (!in_packset(x1, x2)) {
1594         save_in -= pack_cost(2);
1595       } else {
1596         save_in += unpack_cost(2);
1597       }
1598     }
1599   }
1600 
1601   // uses of result
1602   uint ct = 0;
1603   int save_use = 0;
1604   for (DUIterator_Fast imax, i = s1-&gt;fast_outs(imax); i &lt; imax; i++) {
1605     Node* s1_use = s1-&gt;fast_out(i);
1606     for (int j = 0; j &lt; _packset.length(); j++) {
1607       Node_List* p = _packset.at(j);
1608       if (p-&gt;at(0) == s1_use) {
1609         for (DUIterator_Fast kmax, k = s2-&gt;fast_outs(kmax); k &lt; kmax; k++) {
1610           Node* s2_use = s2-&gt;fast_out(k);
1611           if (p-&gt;at(p-&gt;size()-1) == s2_use) {
1612             ct++;
1613             if (are_adjacent_refs(s1_use, s2_use)) {
1614               save_use += adjacent_profit(s1_use, s2_use);
1615             }
1616           }
1617         }
1618       }
1619     }
1620   }
1621 
1622   if (ct &lt; s1-&gt;outcnt()) save_use += unpack_cost(1);
1623   if (ct &lt; s2-&gt;outcnt()) save_use += unpack_cost(1);
1624 
1625   return MAX2(save_in, save_use);
1626 }
1627 
1628 //------------------------------costs---------------------------
1629 int SuperWord::adjacent_profit(Node* s1, Node* s2) { return 2; }
1630 int SuperWord::pack_cost(int ct)   { return ct; }
1631 int SuperWord::unpack_cost(int ct) { return ct; }
1632 
1633 //------------------------------combine_packs---------------------------
1634 // Combine packs A and B with A.last == B.first into A.first..,A.last,B.second,..B.last
1635 void SuperWord::combine_packs() {
1636   bool changed = true;
1637   // Combine packs regardless max vector size.
1638   while (changed) {
1639     changed = false;
1640     for (int i = 0; i &lt; _packset.length(); i++) {
1641       Node_List* p1 = _packset.at(i);
1642       if (p1 == NULL) continue;
1643       // Because of sorting we can start at i + 1
1644       for (int j = i + 1; j &lt; _packset.length(); j++) {
1645         Node_List* p2 = _packset.at(j);
1646         if (p2 == NULL) continue;
1647         if (i == j) continue;
1648         if (p1-&gt;at(p1-&gt;size()-1) == p2-&gt;at(0)) {
1649           for (uint k = 1; k &lt; p2-&gt;size(); k++) {
1650             p1-&gt;push(p2-&gt;at(k));
1651           }
1652           _packset.at_put(j, NULL);
1653           changed = true;
1654         }
1655       }
1656     }
1657   }
1658 
1659   // Split packs which have size greater then max vector size.
1660   for (int i = 0; i &lt; _packset.length(); i++) {
1661     Node_List* p1 = _packset.at(i);
1662     if (p1 != NULL) {
1663       BasicType bt = velt_basic_type(p1-&gt;at(0));
1664       uint max_vlen = Matcher::max_vector_size(bt); // Max elements in vector
1665       assert(is_power_of_2(max_vlen), &quot;sanity&quot;);
1666       uint psize = p1-&gt;size();
1667       if (!is_power_of_2(psize)) {
1668         // Skip pack which can&#39;t be vector.
1669         // case1: for(...) { a[i] = i; }    elements values are different (i+x)
1670         // case2: for(...) { a[i] = b[i+1]; }  can&#39;t align both, load and store
1671         _packset.at_put(i, NULL);
1672         continue;
1673       }
1674       if (psize &gt; max_vlen) {
1675         Node_List* pack = new Node_List();
1676         for (uint j = 0; j &lt; psize; j++) {
1677           pack-&gt;push(p1-&gt;at(j));
1678           if (pack-&gt;size() &gt;= max_vlen) {
1679             assert(is_power_of_2(pack-&gt;size()), &quot;sanity&quot;);
1680             _packset.append(pack);
1681             pack = new Node_List();
1682           }
1683         }
1684         _packset.at_put(i, NULL);
1685       }
1686     }
1687   }
1688 
1689   // Compress list.
1690   for (int i = _packset.length() - 1; i &gt;= 0; i--) {
1691     Node_List* p1 = _packset.at(i);
1692     if (p1 == NULL) {
1693       _packset.remove_at(i);
1694     }
1695   }
1696 
1697   if (TraceSuperWord) {
1698     tty-&gt;print_cr(&quot;\nAfter combine_packs&quot;);
1699     print_packset();
1700   }
1701 }
1702 
1703 //-----------------------------construct_my_pack_map--------------------------
1704 // Construct the map from nodes to packs.  Only valid after the
1705 // point where a node is only in one pack (after combine_packs).
1706 void SuperWord::construct_my_pack_map() {
1707   Node_List* rslt = NULL;
1708   for (int i = 0; i &lt; _packset.length(); i++) {
1709     Node_List* p = _packset.at(i);
1710     for (uint j = 0; j &lt; p-&gt;size(); j++) {
1711       Node* s = p-&gt;at(j);
1712       assert(my_pack(s) == NULL, &quot;only in one pack&quot;);
1713       set_my_pack(s, p);
1714     }
1715   }
1716 }
1717 
1718 //------------------------------filter_packs---------------------------
1719 // Remove packs that are not implemented or not profitable.
1720 void SuperWord::filter_packs() {
1721   // Remove packs that are not implemented
1722   for (int i = _packset.length() - 1; i &gt;= 0; i--) {
1723     Node_List* pk = _packset.at(i);
1724     bool impl = implemented(pk);
1725     if (!impl) {
1726 #ifndef PRODUCT
1727       if (TraceSuperWord &amp;&amp; Verbose) {
1728         tty-&gt;print_cr(&quot;Unimplemented&quot;);
1729         pk-&gt;at(0)-&gt;dump();
1730       }
1731 #endif
1732       remove_pack_at(i);
1733     }
1734     Node *n = pk-&gt;at(0);
1735     if (n-&gt;is_reduction()) {
1736       _num_reductions++;
1737     } else {
1738       _num_work_vecs++;
1739     }
1740   }
1741 
1742   // Remove packs that are not profitable
1743   bool changed;
1744   do {
1745     changed = false;
1746     for (int i = _packset.length() - 1; i &gt;= 0; i--) {
1747       Node_List* pk = _packset.at(i);
1748       bool prof = profitable(pk);
1749       if (!prof) {
1750 #ifndef PRODUCT
1751         if (TraceSuperWord &amp;&amp; Verbose) {
1752           tty-&gt;print_cr(&quot;Unprofitable&quot;);
1753           pk-&gt;at(0)-&gt;dump();
1754         }
1755 #endif
1756         remove_pack_at(i);
1757         changed = true;
1758       }
1759     }
1760   } while (changed);
1761 
1762 #ifndef PRODUCT
1763   if (TraceSuperWord) {
1764     tty-&gt;print_cr(&quot;\nAfter filter_packs&quot;);
1765     print_packset();
1766     tty-&gt;cr();
1767   }
1768 #endif
1769 }
1770 
1771 //------------------------------merge_packs_to_cmovd---------------------------
1772 // Merge CMoveD into new vector-nodes
1773 // We want to catch this pattern and subsume CmpD and Bool into CMoveD
1774 //
1775 //                   SubD             ConD
1776 //                  /  |               /
1777 //                 /   |           /   /
1778 //                /    |       /      /
1779 //               /     |   /         /
1780 //              /      /            /
1781 //             /    /  |           /
1782 //            v /      |          /
1783 //         CmpD        |         /
1784 //          |          |        /
1785 //          v          |       /
1786 //         Bool        |      /
1787 //           \         |     /
1788 //             \       |    /
1789 //               \     |   /
1790 //                 \   |  /
1791 //                   \ v /
1792 //                   CMoveD
1793 //
1794 
1795 void SuperWord::merge_packs_to_cmovd() {
1796   for (int i = _packset.length() - 1; i &gt;= 0; i--) {
1797     _cmovev_kit.make_cmovevd_pack(_packset.at(i));
1798   }
1799   #ifndef PRODUCT
1800     if (TraceSuperWord) {
1801       tty-&gt;print_cr(&quot;\nSuperWord::merge_packs_to_cmovd(): After merge&quot;);
1802       print_packset();
1803       tty-&gt;cr();
1804     }
1805   #endif
1806 }
1807 
1808 Node* CMoveKit::is_Bool_candidate(Node* def) const {
1809   Node* use = NULL;
1810   if (!def-&gt;is_Bool() || def-&gt;in(0) != NULL || def-&gt;outcnt() != 1) {
1811     return NULL;
1812   }
1813   for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1814     use = def-&gt;fast_out(j);
1815     if (!_sw-&gt;same_generation(def, use) || !use-&gt;is_CMove()) {
1816       return NULL;
1817     }
1818   }
1819   return use;
1820 }
1821 
1822 Node* CMoveKit::is_CmpD_candidate(Node* def) const {
1823   Node* use = NULL;
1824   if (!def-&gt;is_Cmp() || def-&gt;in(0) != NULL || def-&gt;outcnt() != 1) {
1825     return NULL;
1826   }
1827   for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1828     use = def-&gt;fast_out(j);
1829     if (!_sw-&gt;same_generation(def, use) || (use = is_Bool_candidate(use)) == NULL || !_sw-&gt;same_generation(def, use)) {
1830       return NULL;
1831     }
1832   }
1833   return use;
1834 }
1835 
1836 Node_List* CMoveKit::make_cmovevd_pack(Node_List* cmovd_pk) {
1837   Node *cmovd = cmovd_pk-&gt;at(0);
1838   if (!cmovd-&gt;is_CMove()) {
1839     return NULL;
1840   }
1841   if (cmovd-&gt;Opcode() != Op_CMoveF &amp;&amp; cmovd-&gt;Opcode() != Op_CMoveD) {
1842     return NULL;
1843   }
1844   if (pack(cmovd) != NULL) { // already in the cmov pack
1845     return NULL;
1846   }
1847   if (cmovd-&gt;in(0) != NULL) {
1848     NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) {tty-&gt;print(&quot;CMoveKit::make_cmovevd_pack: CMoveD %d has control flow, escaping...&quot;, cmovd-&gt;_idx); cmovd-&gt;dump();})
1849     return NULL;
1850   }
1851 
1852   Node* bol = cmovd-&gt;as_CMove()-&gt;in(CMoveNode::Condition);
1853   if (!bol-&gt;is_Bool()
1854       || bol-&gt;outcnt() != 1
1855       || !_sw-&gt;same_generation(bol, cmovd)
1856       || bol-&gt;in(0) != NULL  // BoolNode has control flow!!
1857       || _sw-&gt;my_pack(bol) == NULL) {
1858       NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) {tty-&gt;print(&quot;CMoveKit::make_cmovevd_pack: Bool %d does not fit CMoveD %d for building vector, escaping...&quot;, bol-&gt;_idx, cmovd-&gt;_idx); bol-&gt;dump();})
1859       return NULL;
1860   }
1861   Node_List* bool_pk = _sw-&gt;my_pack(bol);
1862   if (bool_pk-&gt;size() != cmovd_pk-&gt;size() ) {
1863     return NULL;
1864   }
1865 
1866   Node* cmpd = bol-&gt;in(1);
1867   if (!cmpd-&gt;is_Cmp()
1868       || cmpd-&gt;outcnt() != 1
1869       || !_sw-&gt;same_generation(cmpd, cmovd)
1870       || cmpd-&gt;in(0) != NULL  // CmpDNode has control flow!!
1871       || _sw-&gt;my_pack(cmpd) == NULL) {
1872       NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) {tty-&gt;print(&quot;CMoveKit::make_cmovevd_pack: CmpD %d does not fit CMoveD %d for building vector, escaping...&quot;, cmpd-&gt;_idx, cmovd-&gt;_idx); cmpd-&gt;dump();})
1873       return NULL;
1874   }
1875   Node_List* cmpd_pk = _sw-&gt;my_pack(cmpd);
1876   if (cmpd_pk-&gt;size() != cmovd_pk-&gt;size() ) {
1877     return NULL;
1878   }
1879 
1880   if (!test_cmpd_pack(cmpd_pk, cmovd_pk)) {
1881     NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) {tty-&gt;print(&quot;CMoveKit::make_cmovevd_pack: cmpd pack for CmpD %d failed vectorization test&quot;, cmpd-&gt;_idx); cmpd-&gt;dump();})
1882     return NULL;
1883   }
1884 
1885   Node_List* new_cmpd_pk = new Node_List();
1886   uint sz = cmovd_pk-&gt;size() - 1;
1887   for (uint i = 0; i &lt;= sz; ++i) {
1888     Node* cmov = cmovd_pk-&gt;at(i);
1889     Node* bol  = bool_pk-&gt;at(i);
1890     Node* cmp  = cmpd_pk-&gt;at(i);
1891 
1892     new_cmpd_pk-&gt;insert(i, cmov);
1893 
1894     map(cmov, new_cmpd_pk);
1895     map(bol, new_cmpd_pk);
1896     map(cmp, new_cmpd_pk);
1897 
1898     _sw-&gt;set_my_pack(cmov, new_cmpd_pk); // and keep old packs for cmp and bool
1899   }
1900   _sw-&gt;_packset.remove(cmovd_pk);
1901   _sw-&gt;_packset.remove(bool_pk);
1902   _sw-&gt;_packset.remove(cmpd_pk);
1903   _sw-&gt;_packset.append(new_cmpd_pk);
1904   NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) {tty-&gt;print_cr(&quot;CMoveKit::make_cmovevd_pack: added syntactic CMoveD pack&quot;); _sw-&gt;print_pack(new_cmpd_pk);})
1905   return new_cmpd_pk;
1906 }
1907 
1908 bool CMoveKit::test_cmpd_pack(Node_List* cmpd_pk, Node_List* cmovd_pk) {
1909   Node* cmpd0 = cmpd_pk-&gt;at(0);
1910   assert(cmpd0-&gt;is_Cmp(), &quot;CMoveKit::test_cmpd_pack: should be CmpDNode&quot;);
1911   assert(cmovd_pk-&gt;at(0)-&gt;is_CMove(), &quot;CMoveKit::test_cmpd_pack: should be CMoveD&quot;);
1912   assert(cmpd_pk-&gt;size() == cmovd_pk-&gt;size(), &quot;CMoveKit::test_cmpd_pack: should be same size&quot;);
1913   Node* in1 = cmpd0-&gt;in(1);
1914   Node* in2 = cmpd0-&gt;in(2);
1915   Node_List* in1_pk = _sw-&gt;my_pack(in1);
1916   Node_List* in2_pk = _sw-&gt;my_pack(in2);
1917 
1918   if (  (in1_pk != NULL &amp;&amp; in1_pk-&gt;size() != cmpd_pk-&gt;size())
1919      || (in2_pk != NULL &amp;&amp; in2_pk-&gt;size() != cmpd_pk-&gt;size()) ) {
1920     return false;
1921   }
1922 
1923   // test if &quot;all&quot; in1 are in the same pack or the same node
1924   if (in1_pk == NULL) {
1925     for (uint j = 1; j &lt; cmpd_pk-&gt;size(); j++) {
1926       if (cmpd_pk-&gt;at(j)-&gt;in(1) != in1) {
1927         return false;
1928       }
1929     }//for: in1_pk is not pack but all CmpD nodes in the pack have the same in(1)
1930   }
1931   // test if &quot;all&quot; in2 are in the same pack or the same node
1932   if (in2_pk == NULL) {
1933     for (uint j = 1; j &lt; cmpd_pk-&gt;size(); j++) {
1934       if (cmpd_pk-&gt;at(j)-&gt;in(2) != in2) {
1935         return false;
1936       }
1937     }//for: in2_pk is not pack but all CmpD nodes in the pack have the same in(2)
1938   }
1939   //now check if cmpd_pk may be subsumed in vector built for cmovd_pk
1940   int cmovd_ind1, cmovd_ind2;
1941   if (cmpd_pk-&gt;at(0)-&gt;in(1) == cmovd_pk-&gt;at(0)-&gt;as_CMove()-&gt;in(CMoveNode::IfFalse)
1942    &amp;&amp; cmpd_pk-&gt;at(0)-&gt;in(2) == cmovd_pk-&gt;at(0)-&gt;as_CMove()-&gt;in(CMoveNode::IfTrue)) {
1943       cmovd_ind1 = CMoveNode::IfFalse;
1944       cmovd_ind2 = CMoveNode::IfTrue;
1945   } else if (cmpd_pk-&gt;at(0)-&gt;in(2) == cmovd_pk-&gt;at(0)-&gt;as_CMove()-&gt;in(CMoveNode::IfFalse)
1946           &amp;&amp; cmpd_pk-&gt;at(0)-&gt;in(1) == cmovd_pk-&gt;at(0)-&gt;as_CMove()-&gt;in(CMoveNode::IfTrue)) {
1947       cmovd_ind2 = CMoveNode::IfFalse;
1948       cmovd_ind1 = CMoveNode::IfTrue;
1949   }
1950   else {
1951     return false;
1952   }
1953 
1954   for (uint j = 1; j &lt; cmpd_pk-&gt;size(); j++) {
1955     if (cmpd_pk-&gt;at(j)-&gt;in(1) != cmovd_pk-&gt;at(j)-&gt;as_CMove()-&gt;in(cmovd_ind1)
1956         || cmpd_pk-&gt;at(j)-&gt;in(2) != cmovd_pk-&gt;at(j)-&gt;as_CMove()-&gt;in(cmovd_ind2)) {
1957         return false;
1958     }//if
1959   }
1960   NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) { tty-&gt;print(&quot;CMoveKit::test_cmpd_pack: cmpd pack for 1st CmpD %d is OK for vectorization: &quot;, cmpd0-&gt;_idx); cmpd0-&gt;dump(); })
1961   return true;
1962 }
1963 
1964 //------------------------------implemented---------------------------
1965 // Can code be generated for pack p?
1966 bool SuperWord::implemented(Node_List* p) {
1967   bool retValue = false;
1968   Node* p0 = p-&gt;at(0);
1969   if (p0 != NULL) {
1970     int opc = p0-&gt;Opcode();
1971     uint size = p-&gt;size();
1972     if (p0-&gt;is_reduction()) {
1973       const Type *arith_type = p0-&gt;bottom_type();
1974       // Length 2 reductions of INT/LONG do not offer performance benefits
1975       if (((arith_type-&gt;basic_type() == T_INT) || (arith_type-&gt;basic_type() == T_LONG)) &amp;&amp; (size == 2)) {
1976         retValue = false;
1977       } else {
1978         retValue = ReductionNode::implemented(opc, size, arith_type-&gt;basic_type());
1979       }
1980     } else {
1981       retValue = VectorNode::implemented(opc, size, velt_basic_type(p0));
1982     }
1983     if (!retValue) {
1984       if (is_cmov_pack(p)) {
1985         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print_cr(&quot;SWPointer::implemented: found cmpd pack&quot;); print_pack(p);})
1986         return true;
1987       }
1988     }
1989   }
1990   return retValue;
1991 }
1992 
1993 bool SuperWord::is_cmov_pack(Node_List* p) {
1994   return _cmovev_kit.pack(p-&gt;at(0)) != NULL;
1995 }
1996 //------------------------------same_inputs--------------------------
1997 // For pack p, are all idx operands the same?
1998 bool SuperWord::same_inputs(Node_List* p, int idx) {
1999   Node* p0 = p-&gt;at(0);
2000   uint vlen = p-&gt;size();
2001   Node* p0_def = p0-&gt;in(idx);
2002   for (uint i = 1; i &lt; vlen; i++) {
2003     Node* pi = p-&gt;at(i);
2004     Node* pi_def = pi-&gt;in(idx);
2005     if (p0_def != pi_def) {
2006       return false;
2007     }
2008   }
2009   return true;
2010 }
2011 
2012 //------------------------------profitable---------------------------
2013 // For pack p, are all operands and all uses (with in the block) vector?
2014 bool SuperWord::profitable(Node_List* p) {
2015   Node* p0 = p-&gt;at(0);
2016   uint start, end;
2017   VectorNode::vector_operands(p0, &amp;start, &amp;end);
2018 
2019   // Return false if some inputs are not vectors or vectors with different
2020   // size or alignment.
2021   // Also, for now, return false if not scalar promotion case when inputs are
2022   // the same. Later, implement PackNode and allow differing, non-vector inputs
2023   // (maybe just the ones from outside the block.)
2024   for (uint i = start; i &lt; end; i++) {
2025     if (!is_vector_use(p0, i)) {
2026       return false;
2027     }
2028   }
2029   // Check if reductions are connected
2030   if (p0-&gt;is_reduction()) {
2031     Node* second_in = p0-&gt;in(2);
2032     Node_List* second_pk = my_pack(second_in);
2033     if ((second_pk == NULL) || (_num_work_vecs == _num_reductions)) {
2034       // Remove reduction flag if no parent pack or if not enough work
2035       // to cover reduction expansion overhead
2036       p0-&gt;remove_flag(Node::Flag_is_reduction);
2037       return false;
2038     } else if (second_pk-&gt;size() != p-&gt;size()) {
2039       return false;
2040     }
2041   }
2042   if (VectorNode::is_shift(p0)) {
2043     // For now, return false if shift count is vector or not scalar promotion
2044     // case (different shift counts) because it is not supported yet.
2045     Node* cnt = p0-&gt;in(2);
2046     Node_List* cnt_pk = my_pack(cnt);
2047     if (cnt_pk != NULL)
2048       return false;
2049     if (!same_inputs(p, 2))
2050       return false;
2051   }
2052   if (!p0-&gt;is_Store()) {
2053     // For now, return false if not all uses are vector.
2054     // Later, implement ExtractNode and allow non-vector uses (maybe
2055     // just the ones outside the block.)
2056     for (uint i = 0; i &lt; p-&gt;size(); i++) {
2057       Node* def = p-&gt;at(i);
2058       if (is_cmov_pack_internal_node(p, def)) {
2059         continue;
2060       }
2061       for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2062         Node* use = def-&gt;fast_out(j);
2063         for (uint k = 0; k &lt; use-&gt;req(); k++) {
2064           Node* n = use-&gt;in(k);
2065           if (def == n) {
2066             // Reductions should only have a Phi use at the loop head or a non-phi use
2067             // outside of the loop if it is the last element of the pack (e.g. SafePoint).
2068             if (def-&gt;is_reduction() &amp;&amp;
2069                 ((use-&gt;is_Phi() &amp;&amp; use-&gt;in(0) == _lpt-&gt;_head) ||
2070                  (!_lpt-&gt;is_member(_phase-&gt;get_loop(_phase-&gt;ctrl_or_self(use))) &amp;&amp; i == p-&gt;size()-1))) {
2071               continue;
2072             }
2073             if (!is_vector_use(use, k)) {
2074               return false;
2075             }
2076           }
2077         }
2078       }
2079     }
2080   }
2081   return true;
2082 }
2083 
2084 //------------------------------schedule---------------------------
2085 // Adjust the memory graph for the packed operations
2086 void SuperWord::schedule() {
2087 
2088   // Co-locate in the memory graph the members of each memory pack
2089   for (int i = 0; i &lt; _packset.length(); i++) {
2090     co_locate_pack(_packset.at(i));
2091   }
2092 }
2093 
2094 //-------------------------------remove_and_insert-------------------
2095 // Remove &quot;current&quot; from its current position in the memory graph and insert
2096 // it after the appropriate insertion point (lip or uip).
2097 void SuperWord::remove_and_insert(MemNode *current, MemNode *prev, MemNode *lip,
2098                                   Node *uip, Unique_Node_List &amp;sched_before) {
2099   Node* my_mem = current-&gt;in(MemNode::Memory);
2100   bool sched_up = sched_before.member(current);
2101 
2102   // remove current_store from its current position in the memmory graph
2103   for (DUIterator i = current-&gt;outs(); current-&gt;has_out(i); i++) {
2104     Node* use = current-&gt;out(i);
2105     if (use-&gt;is_Mem()) {
2106       assert(use-&gt;in(MemNode::Memory) == current, &quot;must be&quot;);
2107       if (use == prev) { // connect prev to my_mem
2108           _igvn.replace_input_of(use, MemNode::Memory, my_mem);
2109           --i; //deleted this edge; rescan position
2110       } else if (sched_before.member(use)) {
2111         if (!sched_up) { // Will be moved together with current
2112           _igvn.replace_input_of(use, MemNode::Memory, uip);
2113           --i; //deleted this edge; rescan position
2114         }
2115       } else {
2116         if (sched_up) { // Will be moved together with current
2117           _igvn.replace_input_of(use, MemNode::Memory, lip);
2118           --i; //deleted this edge; rescan position
2119         }
2120       }
2121     }
2122   }
2123 
2124   Node *insert_pt =  sched_up ?  uip : lip;
2125 
2126   // all uses of insert_pt&#39;s memory state should use current&#39;s instead
2127   for (DUIterator i = insert_pt-&gt;outs(); insert_pt-&gt;has_out(i); i++) {
2128     Node* use = insert_pt-&gt;out(i);
2129     if (use-&gt;is_Mem()) {
2130       assert(use-&gt;in(MemNode::Memory) == insert_pt, &quot;must be&quot;);
2131       _igvn.replace_input_of(use, MemNode::Memory, current);
2132       --i; //deleted this edge; rescan position
2133     } else if (!sched_up &amp;&amp; use-&gt;is_Phi() &amp;&amp; use-&gt;bottom_type() == Type::MEMORY) {
2134       uint pos; //lip (lower insert point) must be the last one in the memory slice
2135       for (pos=1; pos &lt; use-&gt;req(); pos++) {
2136         if (use-&gt;in(pos) == insert_pt) break;
2137       }
2138       _igvn.replace_input_of(use, pos, current);
2139       --i;
2140     }
2141   }
2142 
2143   //connect current to insert_pt
2144   _igvn.replace_input_of(current, MemNode::Memory, insert_pt);
2145 }
2146 
2147 //------------------------------co_locate_pack----------------------------------
2148 // To schedule a store pack, we need to move any sandwiched memory ops either before
2149 // or after the pack, based upon dependence information:
2150 // (1) If any store in the pack depends on the sandwiched memory op, the
2151 //     sandwiched memory op must be scheduled BEFORE the pack;
2152 // (2) If a sandwiched memory op depends on any store in the pack, the
2153 //     sandwiched memory op must be scheduled AFTER the pack;
2154 // (3) If a sandwiched memory op (say, memA) depends on another sandwiched
2155 //     memory op (say memB), memB must be scheduled before memA. So, if memA is
2156 //     scheduled before the pack, memB must also be scheduled before the pack;
2157 // (4) If there is no dependence restriction for a sandwiched memory op, we simply
2158 //     schedule this store AFTER the pack
2159 // (5) We know there is no dependence cycle, so there in no other case;
2160 // (6) Finally, all memory ops in another single pack should be moved in the same direction.
2161 //
2162 // To schedule a load pack, we use the memory state of either the first or the last load in
2163 // the pack, based on the dependence constraint.
2164 void SuperWord::co_locate_pack(Node_List* pk) {
2165   if (pk-&gt;at(0)-&gt;is_Store()) {
2166     MemNode* first     = executed_first(pk)-&gt;as_Mem();
2167     MemNode* last      = executed_last(pk)-&gt;as_Mem();
2168     Unique_Node_List schedule_before_pack;
2169     Unique_Node_List memops;
2170 
2171     MemNode* current   = last-&gt;in(MemNode::Memory)-&gt;as_Mem();
2172     MemNode* previous  = last;
2173     while (true) {
2174       assert(in_bb(current), &quot;stay in block&quot;);
2175       memops.push(previous);
2176       for (DUIterator i = current-&gt;outs(); current-&gt;has_out(i); i++) {
2177         Node* use = current-&gt;out(i);
2178         if (use-&gt;is_Mem() &amp;&amp; use != previous)
2179           memops.push(use);
2180       }
2181       if (current == first) break;
2182       previous = current;
2183       current  = current-&gt;in(MemNode::Memory)-&gt;as_Mem();
2184     }
2185 
2186     // determine which memory operations should be scheduled before the pack
2187     for (uint i = 1; i &lt; memops.size(); i++) {
2188       Node *s1 = memops.at(i);
2189       if (!in_pack(s1, pk) &amp;&amp; !schedule_before_pack.member(s1)) {
2190         for (uint j = 0; j&lt; i; j++) {
2191           Node *s2 = memops.at(j);
2192           if (!independent(s1, s2)) {
2193             if (in_pack(s2, pk) || schedule_before_pack.member(s2)) {
2194               schedule_before_pack.push(s1); // s1 must be scheduled before
2195               Node_List* mem_pk = my_pack(s1);
2196               if (mem_pk != NULL) {
2197                 for (uint ii = 0; ii &lt; mem_pk-&gt;size(); ii++) {
2198                   Node* s = mem_pk-&gt;at(ii);  // follow partner
2199                   if (memops.member(s) &amp;&amp; !schedule_before_pack.member(s))
2200                     schedule_before_pack.push(s);
2201                 }
2202               }
2203               break;
2204             }
2205           }
2206         }
2207       }
2208     }
2209 
2210     Node*    upper_insert_pt = first-&gt;in(MemNode::Memory);
2211     // Following code moves loads connected to upper_insert_pt below aliased stores.
2212     // Collect such loads here and reconnect them back to upper_insert_pt later.
2213     memops.clear();
2214     for (DUIterator i = upper_insert_pt-&gt;outs(); upper_insert_pt-&gt;has_out(i); i++) {
2215       Node* use = upper_insert_pt-&gt;out(i);
2216       if (use-&gt;is_Mem() &amp;&amp; !use-&gt;is_Store()) {
2217         memops.push(use);
2218       }
2219     }
2220 
2221     MemNode* lower_insert_pt = last;
2222     previous                 = last; //previous store in pk
2223     current                  = last-&gt;in(MemNode::Memory)-&gt;as_Mem();
2224 
2225     // start scheduling from &quot;last&quot; to &quot;first&quot;
2226     while (true) {
2227       assert(in_bb(current), &quot;stay in block&quot;);
2228       assert(in_pack(previous, pk), &quot;previous stays in pack&quot;);
2229       Node* my_mem = current-&gt;in(MemNode::Memory);
2230 
2231       if (in_pack(current, pk)) {
2232         // Forward users of my memory state (except &quot;previous) to my input memory state
2233         for (DUIterator i = current-&gt;outs(); current-&gt;has_out(i); i++) {
2234           Node* use = current-&gt;out(i);
2235           if (use-&gt;is_Mem() &amp;&amp; use != previous) {
2236             assert(use-&gt;in(MemNode::Memory) == current, &quot;must be&quot;);
2237             if (schedule_before_pack.member(use)) {
2238               _igvn.replace_input_of(use, MemNode::Memory, upper_insert_pt);
2239             } else {
2240               _igvn.replace_input_of(use, MemNode::Memory, lower_insert_pt);
2241             }
2242             --i; // deleted this edge; rescan position
2243           }
2244         }
2245         previous = current;
2246       } else { // !in_pack(current, pk) ==&gt; a sandwiched store
2247         remove_and_insert(current, previous, lower_insert_pt, upper_insert_pt, schedule_before_pack);
2248       }
2249 
2250       if (current == first) break;
2251       current = my_mem-&gt;as_Mem();
2252     } // end while
2253 
2254     // Reconnect loads back to upper_insert_pt.
2255     for (uint i = 0; i &lt; memops.size(); i++) {
2256       Node *ld = memops.at(i);
2257       if (ld-&gt;in(MemNode::Memory) != upper_insert_pt) {
2258         _igvn.replace_input_of(ld, MemNode::Memory, upper_insert_pt);
2259       }
2260     }
<a name="2" id="anc2"></a><span class="line-modified">2261   } else if (pk-&gt;at(0)-&gt;is_Load()) { //load</span>
<span class="line-modified">2262     // all loads in the pack should have the same memory state. By default,</span>
2263     // we use the memory state of the last load. However, if any load could
2264     // not be moved down due to the dependence constraint, we use the memory
2265     // state of the first load.
<a name="3" id="anc3"></a><span class="line-modified">2266     Node* last_mem  = pk-&gt;at(0)-&gt;in(MemNode::Memory);</span>
<span class="line-modified">2267     Node* first_mem = last_mem;</span>
<span class="line-modified">2268     // Walk the memory graph from the current first load until the</span>
<span class="line-modified">2269     // start of the loop and check if nodes on the way are memory</span>
<span class="line-modified">2270     // edges of loads in the pack. The last one we encounter is the</span>
<span class="line-modified">2271     // first load.</span>
<span class="line-modified">2272     for (Node* current = first_mem; in_bb(current); current = current-&gt;is_Phi() ? current-&gt;in(LoopNode::EntryControl) : current-&gt;in(MemNode::Memory)) {</span>
<span class="line-modified">2273      assert(current-&gt;is_Mem() || (current-&gt;is_Phi() &amp;&amp; current-&gt;in(0) == bb()), &quot;unexpected memory&quot;);</span>
<span class="line-modified">2274      for (uint i = 1; i &lt; pk-&gt;size(); i++) {</span>
<span class="line-modified">2275         Node* ld = pk-&gt;at(i);</span>
<span class="line-modified">2276         if (ld-&gt;in(MemNode::Memory) == current) {</span>
<span class="line-modified">2277           first_mem = current;</span>
<span class="line-modified">2278           break;</span>
<span class="line-modified">2279         }</span>





















2280       }
2281     }
<a name="4" id="anc4"></a><span class="line-modified">2282     // Find the last load by going over the pack again and walking</span>
<span class="line-modified">2283     // the memory graph from the loads of the pack to the memory of</span>
<span class="line-modified">2284     // the first load. If we encounter the memory of the current last</span>
<span class="line-modified">2285     // load, then we started from further down in the memory graph and</span>
<span class="line-modified">2286     // the load we started from is the last load. Check for dependence</span>
<span class="line-modified">2287     // constraints in that loop as well.</span>
<span class="line-modified">2288     bool schedule_last = true;</span>
<span class="line-modified">2289     for (uint i = 0; i &lt; pk-&gt;size(); i++) {</span>





2290       Node* ld = pk-&gt;at(i);
<a name="5" id="anc5"></a><span class="line-modified">2291       for (Node* current = ld-&gt;in(MemNode::Memory); current != first_mem; current = current-&gt;in(MemNode::Memory)) {</span>
<span class="line-modified">2292         assert(current-&gt;is_Mem() &amp;&amp; in_bb(current), &quot;unexpected memory&quot;);</span>
<span class="line-modified">2293         if (current-&gt;in(MemNode::Memory) == last_mem) {</span>
<span class="line-removed">2294           last_mem = ld-&gt;in(MemNode::Memory);</span>
<span class="line-removed">2295         }</span>
<span class="line-removed">2296         if (!independent(current, ld)) {</span>
<span class="line-removed">2297           schedule_last = false; // a later store depends on this load</span>
<span class="line-removed">2298         }</span>
2299       }
2300     }
<a name="6" id="anc6"></a>


2301 
<a name="7" id="anc7"></a><span class="line-modified">2302     Node* mem_input = schedule_last ? last_mem : first_mem;</span>
<span class="line-modified">2303     _igvn.hash_delete(mem_input);</span>
<span class="line-modified">2304     // Give each load the same memory state</span>
<span class="line-modified">2305     for (uint i = 0; i &lt; pk-&gt;size(); i++) {</span>
<span class="line-modified">2306       LoadNode* ld = pk-&gt;at(i)-&gt;as_Load();</span>
<span class="line-modified">2307       _igvn.replace_input_of(ld, MemNode::Memory, mem_input);</span>








2308     }
2309   }
<a name="8" id="anc8"></a>
2310 }
2311 
2312 #ifndef PRODUCT
2313 void SuperWord::print_loop(bool whole) {
2314   Node_Stack stack(_arena, _phase-&gt;C-&gt;unique() &gt;&gt; 2);
2315   Node_List rpo_list;
2316   VectorSet visited(_arena);
2317   visited.set(lpt()-&gt;_head-&gt;_idx);
2318   _phase-&gt;rpo(lpt()-&gt;_head, stack, visited, rpo_list);
2319   _phase-&gt;dump(lpt(), rpo_list.size(), rpo_list );
2320   if(whole) {
2321     tty-&gt;print_cr(&quot;\n Whole loop tree&quot;);
2322     _phase-&gt;dump();
2323     tty-&gt;print_cr(&quot; End of whole loop tree\n&quot;);
2324   }
2325 }
2326 #endif
2327 
2328 //------------------------------output---------------------------
2329 // Convert packs into vector node operations
2330 void SuperWord::output() {
2331   CountedLoopNode *cl = lpt()-&gt;_head-&gt;as_CountedLoop();
2332   Compile* C = _phase-&gt;C;
2333   if (_packset.length() == 0) {
2334     if (cl-&gt;is_main_loop()) {
2335       // Instigate more unrolling for optimization when vectorization fails.
2336       C-&gt;set_major_progress();
2337       cl-&gt;set_notpassed_slp();
2338       cl-&gt;mark_do_unroll_only();
2339     }
2340     return;
2341   }
2342 
2343 #ifndef PRODUCT
2344   if (TraceLoopOpts) {
2345     tty-&gt;print(&quot;SuperWord::output    &quot;);
2346     lpt()-&gt;dump_head();
2347   }
2348 #endif
2349 
2350   if (cl-&gt;is_main_loop()) {
2351     // MUST ENSURE main loop&#39;s initial value is properly aligned:
2352     //  (iv_initial_value + min_iv_offset) % vector_width_in_bytes() == 0
2353 
2354     align_initial_loop_index(align_to_ref());
2355 
2356     // Insert extract (unpack) operations for scalar uses
2357     for (int i = 0; i &lt; _packset.length(); i++) {
2358       insert_extracts(_packset.at(i));
2359     }
2360   }
2361 
2362   uint max_vlen_in_bytes = 0;
2363   uint max_vlen = 0;
2364   bool can_process_post_loop = (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors() &amp;&amp; cl-&gt;is_post_loop());
2365 
2366   NOT_PRODUCT(if(is_trace_loop_reverse()) {tty-&gt;print_cr(&quot;SWPointer::output: print loop before create_reserve_version_of_loop&quot;); print_loop(true);})
2367 
2368   CountedLoopReserveKit make_reversable(_phase, _lpt, do_reserve_copy());
2369 
2370   NOT_PRODUCT(if(is_trace_loop_reverse()) {tty-&gt;print_cr(&quot;SWPointer::output: print loop after create_reserve_version_of_loop&quot;); print_loop(true);})
2371 
2372   if (do_reserve_copy() &amp;&amp; !make_reversable.has_reserved()) {
2373     NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: loop was not reserved correctly, exiting SuperWord&quot;);})
2374     return;
2375   }
2376 
2377   for (int i = 0; i &lt; _block.length(); i++) {
2378     Node* n = _block.at(i);
2379     Node_List* p = my_pack(n);
2380     if (p &amp;&amp; n == executed_last(p)) {
2381       uint vlen = p-&gt;size();
2382       uint vlen_in_bytes = 0;
2383       Node* vn = NULL;
2384       Node* low_adr = p-&gt;at(0);
2385       Node* first   = executed_first(p);
2386       if (can_process_post_loop) {
2387         // override vlen with the main loops vector length
2388         vlen = cl-&gt;slp_max_unroll();
2389       }
2390       NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print_cr(&quot;SWPointer::output: %d executed first, %d executed last in pack&quot;, first-&gt;_idx, n-&gt;_idx); print_pack(p);})
2391       int   opc = n-&gt;Opcode();
2392       if (n-&gt;is_Load()) {
2393         Node* ctl = n-&gt;in(MemNode::Control);
2394         Node* mem = first-&gt;in(MemNode::Memory);
2395         SWPointer p1(n-&gt;as_Mem(), this, NULL, false);
2396         // Identify the memory dependency for the new loadVector node by
2397         // walking up through memory chain.
2398         // This is done to give flexibility to the new loadVector node so that
2399         // it can move above independent storeVector nodes.
2400         while (mem-&gt;is_StoreVector()) {
2401           SWPointer p2(mem-&gt;as_Mem(), this, NULL, false);
2402           int cmp = p1.cmp(p2);
2403           if (SWPointer::not_equal(cmp) || !SWPointer::comparable(cmp)) {
2404             mem = mem-&gt;in(MemNode::Memory);
2405           } else {
2406             break; // dependent memory
2407           }
2408         }
2409         Node* adr = low_adr-&gt;in(MemNode::Address);
2410         const TypePtr* atyp = n-&gt;adr_type();
2411         vn = LoadVectorNode::make(opc, ctl, mem, adr, atyp, vlen, velt_basic_type(n), control_dependency(p));
2412         vlen_in_bytes = vn-&gt;as_LoadVector()-&gt;memory_size();
2413       } else if (n-&gt;is_Store()) {
2414         // Promote value to be stored to vector
2415         Node* val = vector_opd(p, MemNode::ValueIn);
2416         if (val == NULL) {
2417           if (do_reserve_copy()) {
2418             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: val should not be NULL, exiting SuperWord&quot;);})
2419             return; //and reverse to backup IG
2420           }
2421           ShouldNotReachHere();
2422         }
2423 
2424         Node* ctl = n-&gt;in(MemNode::Control);
2425         Node* mem = first-&gt;in(MemNode::Memory);
2426         Node* adr = low_adr-&gt;in(MemNode::Address);
2427         const TypePtr* atyp = n-&gt;adr_type();
2428         vn = StoreVectorNode::make(opc, ctl, mem, adr, atyp, val, vlen);
2429         vlen_in_bytes = vn-&gt;as_StoreVector()-&gt;memory_size();
2430       } else if (VectorNode::is_roundopD(n)) {
2431         Node* in1 = vector_opd(p, 1);
2432         Node* in2 = low_adr-&gt;in(2);
2433         assert(in2-&gt;is_Con(), &quot;Constant rounding mode expected.&quot;);
2434         vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));
2435         vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2436       } else if (VectorNode::is_muladds2i(n)) {
2437         assert(n-&gt;req() == 5u, &quot;MulAddS2I should have 4 operands.&quot;);
2438         Node* in1 = vector_opd(p, 1);
2439         Node* in2 = vector_opd(p, 2);
2440         vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));
2441         vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2442       } else if (n-&gt;req() == 3 &amp;&amp; !is_cmov_pack(p)) {
2443         // Promote operands to vector
2444         Node* in1 = NULL;
2445         bool node_isa_reduction = n-&gt;is_reduction();
2446         if (node_isa_reduction) {
2447           // the input to the first reduction operation is retained
2448           in1 = low_adr-&gt;in(1);
2449         } else {
2450           in1 = vector_opd(p, 1);
2451           if (in1 == NULL) {
2452             if (do_reserve_copy()) {
2453               NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: in1 should not be NULL, exiting SuperWord&quot;);})
2454               return; //and reverse to backup IG
2455             }
2456             ShouldNotReachHere();
2457           }
2458         }
2459         Node* in2 = vector_opd(p, 2);
2460         if (in2 == NULL) {
2461           if (do_reserve_copy()) {
2462             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: in2 should not be NULL, exiting SuperWord&quot;);})
2463             return; //and reverse to backup IG
2464           }
2465           ShouldNotReachHere();
2466         }
2467         if (VectorNode::is_invariant_vector(in1) &amp;&amp; (node_isa_reduction == false) &amp;&amp; (n-&gt;is_Add() || n-&gt;is_Mul())) {
2468           // Move invariant vector input into second position to avoid register spilling.
2469           Node* tmp = in1;
2470           in1 = in2;
2471           in2 = tmp;
2472         }
2473         if (node_isa_reduction) {
2474           const Type *arith_type = n-&gt;bottom_type();
2475           vn = ReductionNode::make(opc, NULL, in1, in2, arith_type-&gt;basic_type());
2476           if (in2-&gt;is_Load()) {
2477             vlen_in_bytes = in2-&gt;as_LoadVector()-&gt;memory_size();
2478           } else {
2479             vlen_in_bytes = in2-&gt;as_Vector()-&gt;length_in_bytes();
2480           }
2481         } else {
2482           vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));
2483           vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2484         }
2485       } else if (opc == Op_SqrtF || opc == Op_SqrtD ||
2486                  opc == Op_AbsF || opc == Op_AbsD ||
2487                  opc == Op_AbsI || opc == Op_AbsL ||
2488                  opc == Op_NegF || opc == Op_NegD ||
2489                  opc == Op_PopCountI) {
2490         assert(n-&gt;req() == 2, &quot;only one input expected&quot;);
2491         Node* in = vector_opd(p, 1);
2492         vn = VectorNode::make(opc, in, NULL, vlen, velt_basic_type(n));
2493         vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2494       } else if (is_cmov_pack(p)) {
2495         if (can_process_post_loop) {
2496           // do not refactor of flow in post loop context
2497           return;
2498         }
2499         if (!n-&gt;is_CMove()) {
2500           continue;
2501         }
2502         // place here CMoveVDNode
2503         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print_cr(&quot;SWPointer::output: print before CMove vectorization&quot;); print_loop(false);})
2504         Node* bol = n-&gt;in(CMoveNode::Condition);
2505         if (!bol-&gt;is_Bool() &amp;&amp; bol-&gt;Opcode() == Op_ExtractI &amp;&amp; bol-&gt;req() &gt; 1 ) {
2506           NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print_cr(&quot;SWPointer::output: %d is not Bool node, trying its in(1) node %d&quot;, bol-&gt;_idx, bol-&gt;in(1)-&gt;_idx); bol-&gt;dump(); bol-&gt;in(1)-&gt;dump();})
2507           bol = bol-&gt;in(1); //may be ExtractNode
2508         }
2509 
2510         assert(bol-&gt;is_Bool(), &quot;should be BoolNode - too late to bail out!&quot;);
2511         if (!bol-&gt;is_Bool()) {
2512           if (do_reserve_copy()) {
2513             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: expected %d bool node, exiting SuperWord&quot;, bol-&gt;_idx); bol-&gt;dump();})
2514             return; //and reverse to backup IG
2515           }
2516           ShouldNotReachHere();
2517         }
2518 
2519         int cond = (int)bol-&gt;as_Bool()-&gt;_test._test;
2520         Node* in_cc  = _igvn.intcon(cond);
2521         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print(&quot;SWPointer::output: created intcon in_cc node %d&quot;, in_cc-&gt;_idx); in_cc-&gt;dump();})
2522         Node* cc = bol-&gt;clone();
2523         cc-&gt;set_req(1, in_cc);
2524         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print(&quot;SWPointer::output: created bool cc node %d&quot;, cc-&gt;_idx); cc-&gt;dump();})
2525 
2526         Node* src1 = vector_opd(p, 2); //2=CMoveNode::IfFalse
2527         if (src1 == NULL) {
2528           if (do_reserve_copy()) {
2529             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: src1 should not be NULL, exiting SuperWord&quot;);})
2530             return; //and reverse to backup IG
2531           }
2532           ShouldNotReachHere();
2533         }
2534         Node* src2 = vector_opd(p, 3); //3=CMoveNode::IfTrue
2535         if (src2 == NULL) {
2536           if (do_reserve_copy()) {
2537             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: src2 should not be NULL, exiting SuperWord&quot;);})
2538             return; //and reverse to backup IG
2539           }
2540           ShouldNotReachHere();
2541         }
2542         BasicType bt = velt_basic_type(n);
2543         const TypeVect* vt = TypeVect::make(bt, vlen);
2544         assert(bt == T_FLOAT || bt == T_DOUBLE, &quot;Only vectorization for FP cmovs is supported&quot;);
2545         if (bt == T_FLOAT) {
2546           vn = new CMoveVFNode(cc, src1, src2, vt);
2547         } else {
2548           assert(bt == T_DOUBLE, &quot;Expected double&quot;);
2549           vn = new CMoveVDNode(cc, src1, src2, vt);
2550         }
2551         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print(&quot;SWPointer::output: created new CMove node %d: &quot;, vn-&gt;_idx); vn-&gt;dump();})
2552       } else if (opc == Op_FmaD || opc == Op_FmaF) {
2553         // Promote operands to vector
2554         Node* in1 = vector_opd(p, 1);
2555         Node* in2 = vector_opd(p, 2);
2556         Node* in3 = vector_opd(p, 3);
2557         vn = VectorNode::make(opc, in1, in2, in3, vlen, velt_basic_type(n));
2558         vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2559       } else {
2560         if (do_reserve_copy()) {
2561           NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: ShouldNotReachHere, exiting SuperWord&quot;);})
2562           return; //and reverse to backup IG
2563         }
2564         ShouldNotReachHere();
2565       }
2566 
2567       assert(vn != NULL, &quot;sanity&quot;);
2568       if (vn == NULL) {
2569         if (do_reserve_copy()){
2570           NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: got NULL node, cannot proceed, exiting SuperWord&quot;);})
2571           return; //and reverse to backup IG
2572         }
2573         ShouldNotReachHere();
2574       }
2575 
2576       _block.at_put(i, vn);
2577       _igvn.register_new_node_with_optimizer(vn);
2578       _phase-&gt;set_ctrl(vn, _phase-&gt;get_ctrl(p-&gt;at(0)));
2579       for (uint j = 0; j &lt; p-&gt;size(); j++) {
2580         Node* pm = p-&gt;at(j);
2581         _igvn.replace_node(pm, vn);
2582       }
2583       _igvn._worklist.push(vn);
2584 
2585       if (can_process_post_loop) {
2586         // first check if the vector size if the maximum vector which we can use on the machine,
2587         // other vector size have reduced values for predicated data mapping.
2588         if (vlen_in_bytes != (uint)MaxVectorSize) {
2589           return;
2590         }
2591       }
2592 
2593       if (vlen_in_bytes &gt;= max_vlen_in_bytes &amp;&amp; vlen &gt; max_vlen) {
2594         max_vlen = vlen;
2595         max_vlen_in_bytes = vlen_in_bytes;
2596       }
2597 #ifdef ASSERT
2598       if (TraceNewVectors) {
2599         tty-&gt;print(&quot;new Vector node: &quot;);
2600         vn-&gt;dump();
2601       }
2602 #endif
2603     }
2604   }//for (int i = 0; i &lt; _block.length(); i++)
2605 
2606   if (max_vlen_in_bytes &gt; C-&gt;max_vector_size()) {
2607     C-&gt;set_max_vector_size(max_vlen_in_bytes);
2608   }
2609   if (max_vlen_in_bytes &gt; 0) {
2610     cl-&gt;mark_loop_vectorized();
2611   }
2612 
2613   if (SuperWordLoopUnrollAnalysis) {
2614     if (cl-&gt;has_passed_slp()) {
2615       uint slp_max_unroll_factor = cl-&gt;slp_max_unroll();
2616       if (slp_max_unroll_factor == max_vlen) {
2617         if (TraceSuperWordLoopUnrollAnalysis) {
2618           tty-&gt;print_cr(&quot;vector loop(unroll=%d, len=%d)\n&quot;, max_vlen, max_vlen_in_bytes*BitsPerByte);
2619         }
2620 
2621         // For atomic unrolled loops which are vector mapped, instigate more unrolling
2622         cl-&gt;set_notpassed_slp();
2623         if (cl-&gt;is_main_loop()) {
2624           // if vector resources are limited, do not allow additional unrolling, also
2625           // do not unroll more on pure vector loops which were not reduced so that we can
2626           // program the post loop to single iteration execution.
2627           if (FLOATPRESSURE &gt; 8) {
2628             C-&gt;set_major_progress();
2629             cl-&gt;mark_do_unroll_only();
2630           }
2631         }
2632 
2633         if (do_reserve_copy()) {
2634           if (can_process_post_loop) {
2635             // Now create the difference of trip and limit and use it as our mask index.
2636             // Note: We limited the unroll of the vectorized loop so that
2637             //       only vlen-1 size iterations can remain to be mask programmed.
2638             Node *incr = cl-&gt;incr();
2639             SubINode *index = new SubINode(cl-&gt;limit(), cl-&gt;init_trip());
2640             _igvn.register_new_node_with_optimizer(index);
2641             SetVectMaskINode  *mask = new SetVectMaskINode(_phase-&gt;get_ctrl(cl-&gt;init_trip()), index);
2642             _igvn.register_new_node_with_optimizer(mask);
2643             // make this a single iteration loop
2644             AddINode *new_incr = new AddINode(incr-&gt;in(1), mask);
2645             _igvn.register_new_node_with_optimizer(new_incr);
2646             _phase-&gt;set_ctrl(new_incr, _phase-&gt;get_ctrl(incr));
2647             _igvn.replace_node(incr, new_incr);
2648             cl-&gt;mark_is_multiversioned();
2649             cl-&gt;loopexit()-&gt;add_flag(Node::Flag_has_vector_mask_set);
2650           }
2651         }
2652       }
2653     }
2654   }
2655 
2656   if (do_reserve_copy()) {
2657     make_reversable.use_new();
2658   }
2659   NOT_PRODUCT(if(is_trace_loop_reverse()) {tty-&gt;print_cr(&quot;\n Final loop after SuperWord&quot;); print_loop(true);})
2660   return;
2661 }
2662 
2663 //------------------------------vector_opd---------------------------
2664 // Create a vector operand for the nodes in pack p for operand: in(opd_idx)
2665 Node* SuperWord::vector_opd(Node_List* p, int opd_idx) {
2666   Node* p0 = p-&gt;at(0);
2667   uint vlen = p-&gt;size();
2668   Node* opd = p0-&gt;in(opd_idx);
2669   CountedLoopNode *cl = lpt()-&gt;_head-&gt;as_CountedLoop();
2670 
2671   if (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors() &amp;&amp; cl-&gt;is_post_loop()) {
2672     // override vlen with the main loops vector length
2673     vlen = cl-&gt;slp_max_unroll();
2674   }
2675 
2676   if (same_inputs(p, opd_idx)) {
2677     if (opd-&gt;is_Vector() || opd-&gt;is_LoadVector()) {
2678       assert(((opd_idx != 2) || !VectorNode::is_shift(p0)), &quot;shift&#39;s count can&#39;t be vector&quot;);
2679       if (opd_idx == 2 &amp;&amp; VectorNode::is_shift(p0)) {
2680         NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;shift&#39;s count can&#39;t be vector&quot;);})
2681         return NULL;
2682       }
2683       return opd; // input is matching vector
2684     }
2685     if ((opd_idx == 2) &amp;&amp; VectorNode::is_shift(p0)) {
2686       Compile* C = _phase-&gt;C;
2687       Node* cnt = opd;
2688       // Vector instructions do not mask shift count, do it here.
2689       juint mask = (p0-&gt;bottom_type() == TypeInt::INT) ? (BitsPerInt - 1) : (BitsPerLong - 1);
2690       const TypeInt* t = opd-&gt;find_int_type();
2691       if (t != NULL &amp;&amp; t-&gt;is_con()) {
2692         juint shift = t-&gt;get_con();
2693         if (shift &gt; mask) { // Unsigned cmp
2694           cnt = ConNode::make(TypeInt::make(shift &amp; mask));
2695         }
2696       } else {
2697         if (t == NULL || t-&gt;_lo &lt; 0 || t-&gt;_hi &gt; (int)mask) {
2698           cnt = ConNode::make(TypeInt::make(mask));
2699           _igvn.register_new_node_with_optimizer(cnt);
2700           cnt = new AndINode(opd, cnt);
2701           _igvn.register_new_node_with_optimizer(cnt);
2702           _phase-&gt;set_ctrl(cnt, _phase-&gt;get_ctrl(opd));
2703         }
2704         assert(opd-&gt;bottom_type()-&gt;isa_int(), &quot;int type only&quot;);
2705         if (!opd-&gt;bottom_type()-&gt;isa_int()) {
2706           NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;Should be int type only&quot;);})
2707           return NULL;
2708         }
<a name="9" id="anc9"></a><span class="line-removed">2709         // Move non constant shift count into vector register.</span>
<span class="line-removed">2710         cnt = VectorNode::shift_count(p0, cnt, vlen, velt_basic_type(p0));</span>
<span class="line-removed">2711       }</span>
<span class="line-removed">2712       if (cnt != opd) {</span>
<span class="line-removed">2713         _igvn.register_new_node_with_optimizer(cnt);</span>
<span class="line-removed">2714         _phase-&gt;set_ctrl(cnt, _phase-&gt;get_ctrl(opd));</span>
2715       }
<a name="10" id="anc10"></a>



2716       return cnt;
2717     }
2718     assert(!opd-&gt;is_StoreVector(), &quot;such vector is not expected here&quot;);
2719     if (opd-&gt;is_StoreVector()) {
2720       NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;StoreVector is not expected here&quot;);})
2721       return NULL;
2722     }
2723     // Convert scalar input to vector with the same number of elements as
2724     // p0&#39;s vector. Use p0&#39;s type because size of operand&#39;s container in
2725     // vector should match p0&#39;s size regardless operand&#39;s size.
2726     const Type* p0_t = velt_type(p0);
2727     VectorNode* vn = VectorNode::scalar2vector(opd, vlen, p0_t);
2728 
2729     _igvn.register_new_node_with_optimizer(vn);
2730     _phase-&gt;set_ctrl(vn, _phase-&gt;get_ctrl(opd));
2731 #ifdef ASSERT
2732     if (TraceNewVectors) {
2733       tty-&gt;print(&quot;new Vector node: &quot;);
2734       vn-&gt;dump();
2735     }
2736 #endif
2737     return vn;
2738   }
2739 
2740   // Insert pack operation
2741   BasicType bt = velt_basic_type(p0);
2742   PackNode* pk = PackNode::make(opd, vlen, bt);
2743   DEBUG_ONLY( const BasicType opd_bt = opd-&gt;bottom_type()-&gt;basic_type(); )
2744 
2745   for (uint i = 1; i &lt; vlen; i++) {
2746     Node* pi = p-&gt;at(i);
2747     Node* in = pi-&gt;in(opd_idx);
2748     assert(my_pack(in) == NULL, &quot;Should already have been unpacked&quot;);
2749     if (my_pack(in) != NULL) {
2750       NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;Should already have been unpacked&quot;);})
2751       return NULL;
2752     }
2753     assert(opd_bt == in-&gt;bottom_type()-&gt;basic_type(), &quot;all same type&quot;);
2754     pk-&gt;add_opd(in);
2755     if (VectorNode::is_muladds2i(pi)) {
2756       Node* in2 = pi-&gt;in(opd_idx + 2);
2757       assert(my_pack(in2) == NULL, &quot;Should already have been unpacked&quot;);
2758       if (my_pack(in2) != NULL) {
2759         NOT_PRODUCT(if (is_trace_loop_reverse() || TraceLoopOpts) { tty-&gt;print_cr(&quot;Should already have been unpacked&quot;); })
2760           return NULL;
2761       }
2762       assert(opd_bt == in2-&gt;bottom_type()-&gt;basic_type(), &quot;all same type&quot;);
2763       pk-&gt;add_opd(in2);
2764     }
2765   }
2766   _igvn.register_new_node_with_optimizer(pk);
2767   _phase-&gt;set_ctrl(pk, _phase-&gt;get_ctrl(opd));
2768 #ifdef ASSERT
2769   if (TraceNewVectors) {
2770     tty-&gt;print(&quot;new Vector node: &quot;);
2771     pk-&gt;dump();
2772   }
2773 #endif
2774   return pk;
2775 }
2776 
2777 //------------------------------insert_extracts---------------------------
2778 // If a use of pack p is not a vector use, then replace the
2779 // use with an extract operation.
2780 void SuperWord::insert_extracts(Node_List* p) {
2781   if (p-&gt;at(0)-&gt;is_Store()) return;
2782   assert(_n_idx_list.is_empty(), &quot;empty (node,index) list&quot;);
2783 
2784   // Inspect each use of each pack member.  For each use that is
2785   // not a vector use, replace the use with an extract operation.
2786 
2787   for (uint i = 0; i &lt; p-&gt;size(); i++) {
2788     Node* def = p-&gt;at(i);
2789     for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2790       Node* use = def-&gt;fast_out(j);
2791       for (uint k = 0; k &lt; use-&gt;req(); k++) {
2792         Node* n = use-&gt;in(k);
2793         if (def == n) {
2794           Node_List* u_pk = my_pack(use);
2795           if ((u_pk == NULL || !is_cmov_pack(u_pk) || use-&gt;is_CMove()) &amp;&amp; !is_vector_use(use, k)) {
2796               _n_idx_list.push(use, k);
2797           }
2798         }
2799       }
2800     }
2801   }
2802 
2803   while (_n_idx_list.is_nonempty()) {
2804     Node* use = _n_idx_list.node();
2805     int   idx = _n_idx_list.index();
2806     _n_idx_list.pop();
2807     Node* def = use-&gt;in(idx);
2808 
2809     if (def-&gt;is_reduction()) continue;
2810 
2811     // Insert extract operation
2812     _igvn.hash_delete(def);
2813     int def_pos = alignment(def) / data_size(def);
2814 
2815     Node* ex = ExtractNode::make(def, def_pos, velt_basic_type(def));
2816     _igvn.register_new_node_with_optimizer(ex);
2817     _phase-&gt;set_ctrl(ex, _phase-&gt;get_ctrl(def));
2818     _igvn.replace_input_of(use, idx, ex);
2819     _igvn._worklist.push(def);
2820 
2821     bb_insert_after(ex, bb_idx(def));
2822     set_velt_type(ex, velt_type(def));
2823   }
2824 }
2825 
2826 //------------------------------is_vector_use---------------------------
2827 // Is use-&gt;in(u_idx) a vector use?
2828 bool SuperWord::is_vector_use(Node* use, int u_idx) {
2829   Node_List* u_pk = my_pack(use);
2830   if (u_pk == NULL) return false;
2831   if (use-&gt;is_reduction()) return true;
2832   Node* def = use-&gt;in(u_idx);
2833   Node_List* d_pk = my_pack(def);
2834   if (d_pk == NULL) {
2835     // check for scalar promotion
2836     Node* n = u_pk-&gt;at(0)-&gt;in(u_idx);
2837     for (uint i = 1; i &lt; u_pk-&gt;size(); i++) {
2838       if (u_pk-&gt;at(i)-&gt;in(u_idx) != n) return false;
2839     }
2840     return true;
2841   }
2842   if (VectorNode::is_muladds2i(use)) {
2843     // MulAddS2I takes shorts and produces ints - hence the special checks
2844     // on alignment and size.
2845     if (u_pk-&gt;size() * 2 != d_pk-&gt;size()) {
2846       return false;
2847     }
2848     for (uint i = 0; i &lt; MIN2(d_pk-&gt;size(), u_pk-&gt;size()); i++) {
2849       Node* ui = u_pk-&gt;at(i);
2850       Node* di = d_pk-&gt;at(i);
2851       if (alignment(ui) != alignment(di) * 2) {
2852         return false;
2853       }
2854     }
2855     return true;
2856   }
2857   if (u_pk-&gt;size() != d_pk-&gt;size())
2858     return false;
2859   for (uint i = 0; i &lt; u_pk-&gt;size(); i++) {
2860     Node* ui = u_pk-&gt;at(i);
2861     Node* di = d_pk-&gt;at(i);
2862     if (ui-&gt;in(u_idx) != di || alignment(ui) != alignment(di))
2863       return false;
2864   }
2865   return true;
2866 }
2867 
2868 //------------------------------construct_bb---------------------------
2869 // Construct reverse postorder list of block members
2870 bool SuperWord::construct_bb() {
2871   Node* entry = bb();
2872 
2873   assert(_stk.length() == 0,            &quot;stk is empty&quot;);
2874   assert(_block.length() == 0,          &quot;block is empty&quot;);
2875   assert(_data_entry.length() == 0,     &quot;data_entry is empty&quot;);
2876   assert(_mem_slice_head.length() == 0, &quot;mem_slice_head is empty&quot;);
2877   assert(_mem_slice_tail.length() == 0, &quot;mem_slice_tail is empty&quot;);
2878 
2879   // Find non-control nodes with no inputs from within block,
2880   // create a temporary map from node _idx to bb_idx for use
2881   // by the visited and post_visited sets,
2882   // and count number of nodes in block.
2883   int bb_ct = 0;
2884   for (uint i = 0; i &lt; lpt()-&gt;_body.size(); i++) {
2885     Node *n = lpt()-&gt;_body.at(i);
2886     set_bb_idx(n, i); // Create a temporary map
2887     if (in_bb(n)) {
2888       if (n-&gt;is_LoadStore() || n-&gt;is_MergeMem() ||
2889           (n-&gt;is_Proj() &amp;&amp; !n-&gt;as_Proj()-&gt;is_CFG())) {
2890         // Bailout if the loop has LoadStore, MergeMem or data Proj
2891         // nodes. Superword optimization does not work with them.
2892         return false;
2893       }
2894       bb_ct++;
2895       if (!n-&gt;is_CFG()) {
2896         bool found = false;
2897         for (uint j = 0; j &lt; n-&gt;req(); j++) {
2898           Node* def = n-&gt;in(j);
2899           if (def &amp;&amp; in_bb(def)) {
2900             found = true;
2901             break;
2902           }
2903         }
2904         if (!found) {
2905           assert(n != entry, &quot;can&#39;t be entry&quot;);
2906           _data_entry.push(n);
2907         }
2908       }
2909     }
2910   }
2911 
2912   // Find memory slices (head and tail)
2913   for (DUIterator_Fast imax, i = lp()-&gt;fast_outs(imax); i &lt; imax; i++) {
2914     Node *n = lp()-&gt;fast_out(i);
2915     if (in_bb(n) &amp;&amp; (n-&gt;is_Phi() &amp;&amp; n-&gt;bottom_type() == Type::MEMORY)) {
2916       Node* n_tail  = n-&gt;in(LoopNode::LoopBackControl);
2917       if (n_tail != n-&gt;in(LoopNode::EntryControl)) {
2918         if (!n_tail-&gt;is_Mem()) {
2919           assert(n_tail-&gt;is_Mem(), &quot;unexpected node for memory slice: %s&quot;, n_tail-&gt;Name());
2920           return false; // Bailout
2921         }
2922         _mem_slice_head.push(n);
2923         _mem_slice_tail.push(n_tail);
2924       }
2925     }
2926   }
2927 
2928   // Create an RPO list of nodes in block
2929 
2930   visited_clear();
2931   post_visited_clear();
2932 
2933   // Push all non-control nodes with no inputs from within block, then control entry
2934   for (int j = 0; j &lt; _data_entry.length(); j++) {
2935     Node* n = _data_entry.at(j);
2936     visited_set(n);
2937     _stk.push(n);
2938   }
2939   visited_set(entry);
2940   _stk.push(entry);
2941 
2942   // Do a depth first walk over out edges
2943   int rpo_idx = bb_ct - 1;
2944   int size;
2945   int reduction_uses = 0;
2946   while ((size = _stk.length()) &gt; 0) {
2947     Node* n = _stk.top(); // Leave node on stack
2948     if (!visited_test_set(n)) {
2949       // forward arc in graph
2950     } else if (!post_visited_test(n)) {
2951       // cross or back arc
2952       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
2953         Node *use = n-&gt;fast_out(i);
2954         if (in_bb(use) &amp;&amp; !visited_test(use) &amp;&amp;
2955             // Don&#39;t go around backedge
2956             (!use-&gt;is_Phi() || n == entry)) {
2957           if (use-&gt;is_reduction()) {
2958             // First see if we can map the reduction on the given system we are on, then
2959             // make a data entry operation for each reduction we see.
2960             BasicType bt = use-&gt;bottom_type()-&gt;basic_type();
2961             if (ReductionNode::implemented(use-&gt;Opcode(), Matcher::min_vector_size(bt), bt)) {
2962               reduction_uses++;
2963             }
2964           }
2965           _stk.push(use);
2966         }
2967       }
2968       if (_stk.length() == size) {
2969         // There were no additional uses, post visit node now
2970         _stk.pop(); // Remove node from stack
2971         assert(rpo_idx &gt;= 0, &quot;&quot;);
2972         _block.at_put_grow(rpo_idx, n);
2973         rpo_idx--;
2974         post_visited_set(n);
2975         assert(rpo_idx &gt;= 0 || _stk.is_empty(), &quot;&quot;);
2976       }
2977     } else {
2978       _stk.pop(); // Remove post-visited node from stack
2979     }
2980   }//while
2981 
2982   int ii_current = -1;
2983   unsigned int load_idx = (unsigned int)-1;
2984   _ii_order.clear();
2985   // Create real map of block indices for nodes
2986   for (int j = 0; j &lt; _block.length(); j++) {
2987     Node* n = _block.at(j);
2988     set_bb_idx(n, j);
2989     if (_do_vector_loop &amp;&amp; n-&gt;is_Load()) {
2990       if (ii_current == -1) {
2991         ii_current = _clone_map.gen(n-&gt;_idx);
2992         _ii_order.push(ii_current);
2993         load_idx = _clone_map.idx(n-&gt;_idx);
2994       } else if (_clone_map.idx(n-&gt;_idx) == load_idx &amp;&amp; _clone_map.gen(n-&gt;_idx) != ii_current) {
2995         ii_current = _clone_map.gen(n-&gt;_idx);
2996         _ii_order.push(ii_current);
2997       }
2998     }
2999   }//for
3000 
3001   // Ensure extra info is allocated.
3002   initialize_bb();
3003 
3004 #ifndef PRODUCT
3005   if (_vector_loop_debug &amp;&amp; _ii_order.length() &gt; 0) {
3006     tty-&gt;print(&quot;SuperWord::construct_bb: List of generations: &quot;);
3007     for (int jj = 0; jj &lt; _ii_order.length(); ++jj) {
3008       tty-&gt;print(&quot;  %d:%d&quot;, jj, _ii_order.at(jj));
3009     }
3010     tty-&gt;print_cr(&quot; &quot;);
3011   }
3012   if (TraceSuperWord) {
3013     print_bb();
3014     tty-&gt;print_cr(&quot;\ndata entry nodes: %s&quot;, _data_entry.length() &gt; 0 ? &quot;&quot; : &quot;NONE&quot;);
3015     for (int m = 0; m &lt; _data_entry.length(); m++) {
3016       tty-&gt;print(&quot;%3d &quot;, m);
3017       _data_entry.at(m)-&gt;dump();
3018     }
3019     tty-&gt;print_cr(&quot;\nmemory slices: %s&quot;, _mem_slice_head.length() &gt; 0 ? &quot;&quot; : &quot;NONE&quot;);
3020     for (int m = 0; m &lt; _mem_slice_head.length(); m++) {
3021       tty-&gt;print(&quot;%3d &quot;, m); _mem_slice_head.at(m)-&gt;dump();
3022       tty-&gt;print(&quot;    &quot;);    _mem_slice_tail.at(m)-&gt;dump();
3023     }
3024   }
3025 #endif
3026   assert(rpo_idx == -1 &amp;&amp; bb_ct == _block.length(), &quot;all block members found&quot;);
3027   return (_mem_slice_head.length() &gt; 0) || (reduction_uses &gt; 0) || (_data_entry.length() &gt; 0);
3028 }
3029 
3030 //------------------------------initialize_bb---------------------------
3031 // Initialize per node info
3032 void SuperWord::initialize_bb() {
3033   Node* last = _block.at(_block.length() - 1);
3034   grow_node_info(bb_idx(last));
3035 }
3036 
3037 //------------------------------bb_insert_after---------------------------
3038 // Insert n into block after pos
3039 void SuperWord::bb_insert_after(Node* n, int pos) {
3040   int n_pos = pos + 1;
3041   // Make room
3042   for (int i = _block.length() - 1; i &gt;= n_pos; i--) {
3043     _block.at_put_grow(i+1, _block.at(i));
3044   }
3045   for (int j = _node_info.length() - 1; j &gt;= n_pos; j--) {
3046     _node_info.at_put_grow(j+1, _node_info.at(j));
3047   }
3048   // Set value
3049   _block.at_put_grow(n_pos, n);
3050   _node_info.at_put_grow(n_pos, SWNodeInfo::initial);
3051   // Adjust map from node-&gt;_idx to _block index
3052   for (int i = n_pos; i &lt; _block.length(); i++) {
3053     set_bb_idx(_block.at(i), i);
3054   }
3055 }
3056 
3057 //------------------------------compute_max_depth---------------------------
3058 // Compute max depth for expressions from beginning of block
3059 // Use to prune search paths during test for independence.
3060 void SuperWord::compute_max_depth() {
3061   int ct = 0;
3062   bool again;
3063   do {
3064     again = false;
3065     for (int i = 0; i &lt; _block.length(); i++) {
3066       Node* n = _block.at(i);
3067       if (!n-&gt;is_Phi()) {
3068         int d_orig = depth(n);
3069         int d_in   = 0;
3070         for (DepPreds preds(n, _dg); !preds.done(); preds.next()) {
3071           Node* pred = preds.current();
3072           if (in_bb(pred)) {
3073             d_in = MAX2(d_in, depth(pred));
3074           }
3075         }
3076         if (d_in + 1 != d_orig) {
3077           set_depth(n, d_in + 1);
3078           again = true;
3079         }
3080       }
3081     }
3082     ct++;
3083   } while (again);
3084 
3085   if (TraceSuperWord &amp;&amp; Verbose) {
3086     tty-&gt;print_cr(&quot;compute_max_depth iterated: %d times&quot;, ct);
3087   }
3088 }
3089 
3090 //-------------------------compute_vector_element_type-----------------------
3091 // Compute necessary vector element type for expressions
3092 // This propagates backwards a narrower integer type when the
3093 // upper bits of the value are not needed.
3094 // Example:  char a,b,c;  a = b + c;
3095 // Normally the type of the add is integer, but for packed character
3096 // operations the type of the add needs to be char.
3097 void SuperWord::compute_vector_element_type() {
3098   if (TraceSuperWord &amp;&amp; Verbose) {
3099     tty-&gt;print_cr(&quot;\ncompute_velt_type:&quot;);
3100   }
3101 
3102   // Initial type
3103   for (int i = 0; i &lt; _block.length(); i++) {
3104     Node* n = _block.at(i);
3105     set_velt_type(n, container_type(n));
3106   }
3107 
3108   // Propagate integer narrowed type backwards through operations
3109   // that don&#39;t depend on higher order bits
3110   for (int i = _block.length() - 1; i &gt;= 0; i--) {
3111     Node* n = _block.at(i);
3112     // Only integer types need be examined
3113     const Type* vtn = velt_type(n);
3114     if (vtn-&gt;basic_type() == T_INT) {
3115       uint start, end;
3116       VectorNode::vector_operands(n, &amp;start, &amp;end);
3117 
3118       for (uint j = start; j &lt; end; j++) {
3119         Node* in  = n-&gt;in(j);
3120         // Don&#39;t propagate through a memory
3121         if (!in-&gt;is_Mem() &amp;&amp; in_bb(in) &amp;&amp; velt_type(in)-&gt;basic_type() == T_INT &amp;&amp;
3122             data_size(n) &lt; data_size(in)) {
3123           bool same_type = true;
3124           for (DUIterator_Fast kmax, k = in-&gt;fast_outs(kmax); k &lt; kmax; k++) {
3125             Node *use = in-&gt;fast_out(k);
3126             if (!in_bb(use) || !same_velt_type(use, n)) {
3127               same_type = false;
3128               break;
3129             }
3130           }
3131           if (same_type) {
3132             // For right shifts of small integer types (bool, byte, char, short)
3133             // we need precise information about sign-ness. Only Load nodes have
3134             // this information because Store nodes are the same for signed and
3135             // unsigned values. And any arithmetic operation after a load may
3136             // expand a value to signed Int so such right shifts can&#39;t be used
3137             // because vector elements do not have upper bits of Int.
3138             const Type* vt = vtn;
3139             if (VectorNode::is_shift(in)) {
3140               Node* load = in-&gt;in(1);
3141               if (load-&gt;is_Load() &amp;&amp; in_bb(load) &amp;&amp; (velt_type(load)-&gt;basic_type() == T_INT)) {
3142                 vt = velt_type(load);
3143               } else if (in-&gt;Opcode() != Op_LShiftI) {
3144                 // Widen type to Int to avoid creation of right shift vector
3145                 // (align + data_size(s1) check in stmts_can_pack() will fail).
3146                 // Note, left shifts work regardless type.
3147                 vt = TypeInt::INT;
3148               }
3149             }
3150             set_velt_type(in, vt);
3151           }
3152         }
3153       }
3154     }
3155   }
3156 #ifndef PRODUCT
3157   if (TraceSuperWord &amp;&amp; Verbose) {
3158     for (int i = 0; i &lt; _block.length(); i++) {
3159       Node* n = _block.at(i);
3160       velt_type(n)-&gt;dump();
3161       tty-&gt;print(&quot;\t&quot;);
3162       n-&gt;dump();
3163     }
3164   }
3165 #endif
3166 }
3167 
3168 //------------------------------memory_alignment---------------------------
3169 // Alignment within a vector memory reference
3170 int SuperWord::memory_alignment(MemNode* s, int iv_adjust) {
3171   #ifndef PRODUCT
3172     if(TraceSuperWord &amp;&amp; Verbose) {
3173       tty-&gt;print(&quot;SuperWord::memory_alignment within a vector memory reference for %d:  &quot;, s-&gt;_idx); s-&gt;dump();
3174     }
3175   #endif
3176   NOT_PRODUCT(SWPointer::Tracer::Depth ddd(0);)
3177   SWPointer p(s, this, NULL, false);
3178   if (!p.valid()) {
3179     NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print(&quot;SWPointer::memory_alignment: SWPointer p invalid, return bottom_align&quot;);)
3180     return bottom_align;
3181   }
3182   int vw = get_vw_bytes_special(s);
3183   if (vw &lt; 2) {
3184     NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print_cr(&quot;SWPointer::memory_alignment: vector_width_in_bytes &lt; 2, return bottom_align&quot;);)
3185     return bottom_align; // No vectors for this type
3186   }
3187   int offset  = p.offset_in_bytes();
3188   offset     += iv_adjust*p.memory_size();
3189   int off_rem = offset % vw;
3190   int off_mod = off_rem &gt;= 0 ? off_rem : off_rem + vw;
3191   if (TraceSuperWord &amp;&amp; Verbose) {
3192     tty-&gt;print_cr(&quot;SWPointer::memory_alignment: off_rem = %d, off_mod = %d&quot;, off_rem, off_mod);
3193   }
3194   return off_mod;
3195 }
3196 
3197 //---------------------------container_type---------------------------
3198 // Smallest type containing range of values
3199 const Type* SuperWord::container_type(Node* n) {
3200   if (n-&gt;is_Mem()) {
3201     BasicType bt = n-&gt;as_Mem()-&gt;memory_type();
3202     if (n-&gt;is_Store() &amp;&amp; (bt == T_CHAR)) {
3203       // Use T_SHORT type instead of T_CHAR for stored values because any
3204       // preceding arithmetic operation extends values to signed Int.
3205       bt = T_SHORT;
3206     }
3207     if (n-&gt;Opcode() == Op_LoadUB) {
3208       // Adjust type for unsigned byte loads, it is important for right shifts.
3209       // T_BOOLEAN is used because there is no basic type representing type
3210       // TypeInt::UBYTE. Use of T_BOOLEAN for vectors is fine because only
3211       // size (one byte) and sign is important.
3212       bt = T_BOOLEAN;
3213     }
3214     return Type::get_const_basic_type(bt);
3215   }
3216   const Type* t = _igvn.type(n);
3217   if (t-&gt;basic_type() == T_INT) {
3218     // A narrow type of arithmetic operations will be determined by
3219     // propagating the type of memory operations.
3220     return TypeInt::INT;
3221   }
3222   return t;
3223 }
3224 
3225 bool SuperWord::same_velt_type(Node* n1, Node* n2) {
3226   const Type* vt1 = velt_type(n1);
3227   const Type* vt2 = velt_type(n2);
3228   if (vt1-&gt;basic_type() == T_INT &amp;&amp; vt2-&gt;basic_type() == T_INT) {
3229     // Compare vectors element sizes for integer types.
3230     return data_size(n1) == data_size(n2);
3231   }
3232   return vt1 == vt2;
3233 }
3234 
3235 //------------------------------in_packset---------------------------
3236 // Are s1 and s2 in a pack pair and ordered as s1,s2?
3237 bool SuperWord::in_packset(Node* s1, Node* s2) {
3238   for (int i = 0; i &lt; _packset.length(); i++) {
3239     Node_List* p = _packset.at(i);
3240     assert(p-&gt;size() == 2, &quot;must be&quot;);
3241     if (p-&gt;at(0) == s1 &amp;&amp; p-&gt;at(p-&gt;size()-1) == s2) {
3242       return true;
3243     }
3244   }
3245   return false;
3246 }
3247 
3248 //------------------------------in_pack---------------------------
3249 // Is s in pack p?
3250 Node_List* SuperWord::in_pack(Node* s, Node_List* p) {
3251   for (uint i = 0; i &lt; p-&gt;size(); i++) {
3252     if (p-&gt;at(i) == s) {
3253       return p;
3254     }
3255   }
3256   return NULL;
3257 }
3258 
3259 //------------------------------remove_pack_at---------------------------
3260 // Remove the pack at position pos in the packset
3261 void SuperWord::remove_pack_at(int pos) {
3262   Node_List* p = _packset.at(pos);
3263   for (uint i = 0; i &lt; p-&gt;size(); i++) {
3264     Node* s = p-&gt;at(i);
3265     set_my_pack(s, NULL);
3266   }
3267   _packset.remove_at(pos);
3268 }
3269 
3270 void SuperWord::packset_sort(int n) {
3271   // simple bubble sort so that we capitalize with O(n) when its already sorted
3272   while (n != 0) {
3273     bool swapped = false;
3274     for (int i = 1; i &lt; n; i++) {
3275       Node_List* q_low = _packset.at(i-1);
3276       Node_List* q_i = _packset.at(i);
3277 
3278       // only swap when we find something to swap
3279       if (alignment(q_low-&gt;at(0)) &gt; alignment(q_i-&gt;at(0))) {
3280         Node_List* t = q_i;
3281         *(_packset.adr_at(i)) = q_low;
3282         *(_packset.adr_at(i-1)) = q_i;
3283         swapped = true;
3284       }
3285     }
3286     if (swapped == false) break;
3287     n--;
3288   }
3289 }
3290 
3291 //------------------------------executed_first---------------------------
3292 // Return the node executed first in pack p.  Uses the RPO block list
3293 // to determine order.
3294 Node* SuperWord::executed_first(Node_List* p) {
3295   Node* n = p-&gt;at(0);
3296   int n_rpo = bb_idx(n);
3297   for (uint i = 1; i &lt; p-&gt;size(); i++) {
3298     Node* s = p-&gt;at(i);
3299     int s_rpo = bb_idx(s);
3300     if (s_rpo &lt; n_rpo) {
3301       n = s;
3302       n_rpo = s_rpo;
3303     }
3304   }
3305   return n;
3306 }
3307 
3308 //------------------------------executed_last---------------------------
3309 // Return the node executed last in pack p.
3310 Node* SuperWord::executed_last(Node_List* p) {
3311   Node* n = p-&gt;at(0);
3312   int n_rpo = bb_idx(n);
3313   for (uint i = 1; i &lt; p-&gt;size(); i++) {
3314     Node* s = p-&gt;at(i);
3315     int s_rpo = bb_idx(s);
3316     if (s_rpo &gt; n_rpo) {
3317       n = s;
3318       n_rpo = s_rpo;
3319     }
3320   }
3321   return n;
3322 }
3323 
3324 LoadNode::ControlDependency SuperWord::control_dependency(Node_List* p) {
3325   LoadNode::ControlDependency dep = LoadNode::DependsOnlyOnTest;
3326   for (uint i = 0; i &lt; p-&gt;size(); i++) {
3327     Node* n = p-&gt;at(i);
3328     assert(n-&gt;is_Load(), &quot;only meaningful for loads&quot;);
3329     if (!n-&gt;depends_only_on_test()) {
3330       if (n-&gt;as_Load()-&gt;has_unknown_control_dependency() &amp;&amp;
3331           dep != LoadNode::Pinned) {
3332         // Upgrade to unknown control...
3333         dep = LoadNode::UnknownControl;
3334       } else {
3335         // Otherwise, we must pin it.
3336         dep = LoadNode::Pinned;
3337       }
3338     }
3339   }
3340   return dep;
3341 }
3342 
3343 
3344 //----------------------------align_initial_loop_index---------------------------
3345 // Adjust pre-loop limit so that in main loop, a load/store reference
3346 // to align_to_ref will be a position zero in the vector.
3347 //   (iv + k) mod vector_align == 0
3348 void SuperWord::align_initial_loop_index(MemNode* align_to_ref) {
3349   CountedLoopNode *main_head = lp()-&gt;as_CountedLoop();
3350   assert(main_head-&gt;is_main_loop(), &quot;&quot;);
3351   CountedLoopEndNode* pre_end = get_pre_loop_end(main_head);
3352   assert(pre_end != NULL, &quot;we must have a correct pre-loop&quot;);
3353   Node *pre_opaq1 = pre_end-&gt;limit();
3354   assert(pre_opaq1-&gt;Opcode() == Op_Opaque1, &quot;&quot;);
3355   Opaque1Node *pre_opaq = (Opaque1Node*)pre_opaq1;
3356   Node *lim0 = pre_opaq-&gt;in(1);
3357 
3358   // Where we put new limit calculations
3359   Node *pre_ctrl = pre_end-&gt;loopnode()-&gt;in(LoopNode::EntryControl);
3360 
3361   // Ensure the original loop limit is available from the
3362   // pre-loop Opaque1 node.
3363   Node *orig_limit = pre_opaq-&gt;original_loop_limit();
3364   assert(orig_limit != NULL &amp;&amp; _igvn.type(orig_limit) != Type::TOP, &quot;&quot;);
3365 
3366   SWPointer align_to_ref_p(align_to_ref, this, NULL, false);
3367   assert(align_to_ref_p.valid(), &quot;sanity&quot;);
3368 
3369   // Given:
3370   //     lim0 == original pre loop limit
3371   //     V == v_align (power of 2)
3372   //     invar == extra invariant piece of the address expression
3373   //     e == offset [ +/- invar ]
3374   //
3375   // When reassociating expressions involving &#39;%&#39; the basic rules are:
3376   //     (a - b) % k == 0   =&gt;  a % k == b % k
3377   // and:
3378   //     (a + b) % k == 0   =&gt;  a % k == (k - b) % k
3379   //
3380   // For stride &gt; 0 &amp;&amp; scale &gt; 0,
3381   //   Derive the new pre-loop limit &quot;lim&quot; such that the two constraints:
3382   //     (1) lim = lim0 + N           (where N is some positive integer &lt; V)
3383   //     (2) (e + lim) % V == 0
3384   //   are true.
3385   //
3386   //   Substituting (1) into (2),
3387   //     (e + lim0 + N) % V == 0
3388   //   solve for N:
3389   //     N = (V - (e + lim0)) % V
3390   //   substitute back into (1), so that new limit
3391   //     lim = lim0 + (V - (e + lim0)) % V
3392   //
3393   // For stride &gt; 0 &amp;&amp; scale &lt; 0
3394   //   Constraints:
3395   //     lim = lim0 + N
3396   //     (e - lim) % V == 0
3397   //   Solving for lim:
3398   //     (e - lim0 - N) % V == 0
3399   //     N = (e - lim0) % V
3400   //     lim = lim0 + (e - lim0) % V
3401   //
3402   // For stride &lt; 0 &amp;&amp; scale &gt; 0
3403   //   Constraints:
3404   //     lim = lim0 - N
3405   //     (e + lim) % V == 0
3406   //   Solving for lim:
3407   //     (e + lim0 - N) % V == 0
3408   //     N = (e + lim0) % V
3409   //     lim = lim0 - (e + lim0) % V
3410   //
3411   // For stride &lt; 0 &amp;&amp; scale &lt; 0
3412   //   Constraints:
3413   //     lim = lim0 - N
3414   //     (e - lim) % V == 0
3415   //   Solving for lim:
3416   //     (e - lim0 + N) % V == 0
3417   //     N = (V - (e - lim0)) % V
3418   //     lim = lim0 - (V - (e - lim0)) % V
3419 
3420   int vw = vector_width_in_bytes(align_to_ref);
3421   int stride   = iv_stride();
3422   int scale    = align_to_ref_p.scale_in_bytes();
3423   int elt_size = align_to_ref_p.memory_size();
3424   int v_align  = vw / elt_size;
3425   assert(v_align &gt; 1, &quot;sanity&quot;);
3426   int offset   = align_to_ref_p.offset_in_bytes() / elt_size;
3427   Node *offsn  = _igvn.intcon(offset);
3428 
3429   Node *e = offsn;
3430   if (align_to_ref_p.invar() != NULL) {
3431     // incorporate any extra invariant piece producing (offset +/- invar) &gt;&gt;&gt; log2(elt)
3432     Node* log2_elt = _igvn.intcon(exact_log2(elt_size));
3433     Node* invar = align_to_ref_p.invar();
3434     if (_igvn.type(invar)-&gt;isa_long()) {
3435       // Computations are done % (vector width/element size) so it&#39;s
3436       // safe to simply convert invar to an int and loose the upper 32
3437       // bit half.
3438       invar = new ConvL2INode(invar);
3439       _igvn.register_new_node_with_optimizer(invar);
3440     }
3441     Node* aref = new URShiftINode(invar, log2_elt);
3442     _igvn.register_new_node_with_optimizer(aref);
3443     _phase-&gt;set_ctrl(aref, pre_ctrl);
3444     if (align_to_ref_p.negate_invar()) {
3445       e = new SubINode(e, aref);
3446     } else {
3447       e = new AddINode(e, aref);
3448     }
3449     _igvn.register_new_node_with_optimizer(e);
3450     _phase-&gt;set_ctrl(e, pre_ctrl);
3451   }
3452   if (vw &gt; ObjectAlignmentInBytes || align_to_ref_p.base()-&gt;is_top()) {
3453     // incorporate base e +/- base &amp;&amp; Mask &gt;&gt;&gt; log2(elt)
3454     Node* xbase = new CastP2XNode(NULL, align_to_ref_p.adr());
3455     _igvn.register_new_node_with_optimizer(xbase);
3456 #ifdef _LP64
3457     xbase  = new ConvL2INode(xbase);
3458     _igvn.register_new_node_with_optimizer(xbase);
3459 #endif
3460     Node* mask = _igvn.intcon(vw-1);
3461     Node* masked_xbase  = new AndINode(xbase, mask);
3462     _igvn.register_new_node_with_optimizer(masked_xbase);
3463     Node* log2_elt = _igvn.intcon(exact_log2(elt_size));
3464     Node* bref     = new URShiftINode(masked_xbase, log2_elt);
3465     _igvn.register_new_node_with_optimizer(bref);
3466     _phase-&gt;set_ctrl(bref, pre_ctrl);
3467     e = new AddINode(e, bref);
3468     _igvn.register_new_node_with_optimizer(e);
3469     _phase-&gt;set_ctrl(e, pre_ctrl);
3470   }
3471 
3472   // compute e +/- lim0
3473   if (scale &lt; 0) {
3474     e = new SubINode(e, lim0);
3475   } else {
3476     e = new AddINode(e, lim0);
3477   }
3478   _igvn.register_new_node_with_optimizer(e);
3479   _phase-&gt;set_ctrl(e, pre_ctrl);
3480 
3481   if (stride * scale &gt; 0) {
3482     // compute V - (e +/- lim0)
3483     Node* va  = _igvn.intcon(v_align);
3484     e = new SubINode(va, e);
3485     _igvn.register_new_node_with_optimizer(e);
3486     _phase-&gt;set_ctrl(e, pre_ctrl);
3487   }
3488   // compute N = (exp) % V
3489   Node* va_msk = _igvn.intcon(v_align - 1);
3490   Node* N = new AndINode(e, va_msk);
3491   _igvn.register_new_node_with_optimizer(N);
3492   _phase-&gt;set_ctrl(N, pre_ctrl);
3493 
3494   //   substitute back into (1), so that new limit
3495   //     lim = lim0 + N
3496   Node* lim;
3497   if (stride &lt; 0) {
3498     lim = new SubINode(lim0, N);
3499   } else {
3500     lim = new AddINode(lim0, N);
3501   }
3502   _igvn.register_new_node_with_optimizer(lim);
3503   _phase-&gt;set_ctrl(lim, pre_ctrl);
3504   Node* constrained =
3505     (stride &gt; 0) ? (Node*) new MinINode(lim, orig_limit)
3506                  : (Node*) new MaxINode(lim, orig_limit);
3507   _igvn.register_new_node_with_optimizer(constrained);
3508   _phase-&gt;set_ctrl(constrained, pre_ctrl);
3509   _igvn.replace_input_of(pre_opaq, 1, constrained);
3510 }
3511 
3512 //----------------------------get_pre_loop_end---------------------------
3513 // Find pre loop end from main loop.  Returns null if none.
3514 CountedLoopEndNode* SuperWord::get_pre_loop_end(CountedLoopNode* cl) {
3515   // The loop cannot be optimized if the graph shape at
3516   // the loop entry is inappropriate.
3517   if (!PhaseIdealLoop::is_canonical_loop_entry(cl)) {
3518     return NULL;
3519   }
3520 
3521   Node* p_f = cl-&gt;skip_predicates()-&gt;in(0)-&gt;in(0);
3522   if (!p_f-&gt;is_IfFalse()) return NULL;
3523   if (!p_f-&gt;in(0)-&gt;is_CountedLoopEnd()) return NULL;
3524   CountedLoopEndNode* pre_end = p_f-&gt;in(0)-&gt;as_CountedLoopEnd();
3525   CountedLoopNode* loop_node = pre_end-&gt;loopnode();
3526   if (loop_node == NULL || !loop_node-&gt;is_pre_loop()) return NULL;
3527   return pre_end;
3528 }
3529 
3530 //------------------------------init---------------------------
3531 void SuperWord::init() {
3532   _dg.init();
3533   _packset.clear();
3534   _disjoint_ptrs.clear();
3535   _block.clear();
3536   _post_block.clear();
3537   _data_entry.clear();
3538   _mem_slice_head.clear();
3539   _mem_slice_tail.clear();
3540   _iteration_first.clear();
3541   _iteration_last.clear();
3542   _node_info.clear();
3543   _align_to_ref = NULL;
3544   _lpt = NULL;
3545   _lp = NULL;
3546   _bb = NULL;
3547   _iv = NULL;
3548   _race_possible = 0;
3549   _early_return = false;
3550   _num_work_vecs = 0;
3551   _num_reductions = 0;
3552 }
3553 
3554 //------------------------------restart---------------------------
3555 void SuperWord::restart() {
3556   _dg.init();
3557   _packset.clear();
3558   _disjoint_ptrs.clear();
3559   _block.clear();
3560   _post_block.clear();
3561   _data_entry.clear();
3562   _mem_slice_head.clear();
3563   _mem_slice_tail.clear();
3564   _node_info.clear();
3565 }
3566 
3567 //------------------------------print_packset---------------------------
3568 void SuperWord::print_packset() {
3569 #ifndef PRODUCT
3570   tty-&gt;print_cr(&quot;packset&quot;);
3571   for (int i = 0; i &lt; _packset.length(); i++) {
3572     tty-&gt;print_cr(&quot;Pack: %d&quot;, i);
3573     Node_List* p = _packset.at(i);
3574     print_pack(p);
3575   }
3576 #endif
3577 }
3578 
3579 //------------------------------print_pack---------------------------
3580 void SuperWord::print_pack(Node_List* p) {
3581   for (uint i = 0; i &lt; p-&gt;size(); i++) {
3582     print_stmt(p-&gt;at(i));
3583   }
3584 }
3585 
3586 //------------------------------print_bb---------------------------
3587 void SuperWord::print_bb() {
3588 #ifndef PRODUCT
3589   tty-&gt;print_cr(&quot;\nBlock&quot;);
3590   for (int i = 0; i &lt; _block.length(); i++) {
3591     Node* n = _block.at(i);
3592     tty-&gt;print(&quot;%d &quot;, i);
3593     if (n) {
3594       n-&gt;dump();
3595     }
3596   }
3597 #endif
3598 }
3599 
3600 //------------------------------print_stmt---------------------------
3601 void SuperWord::print_stmt(Node* s) {
3602 #ifndef PRODUCT
3603   tty-&gt;print(&quot; align: %d \t&quot;, alignment(s));
3604   s-&gt;dump();
3605 #endif
3606 }
3607 
3608 //------------------------------blank---------------------------
3609 char* SuperWord::blank(uint depth) {
3610   static char blanks[101];
3611   assert(depth &lt; 101, &quot;too deep&quot;);
3612   for (uint i = 0; i &lt; depth; i++) blanks[i] = &#39; &#39;;
3613   blanks[depth] = &#39;\0&#39;;
3614   return blanks;
3615 }
3616 
3617 
3618 //==============================SWPointer===========================
3619 #ifndef PRODUCT
3620 int SWPointer::Tracer::_depth = 0;
3621 #endif
3622 //----------------------------SWPointer------------------------
3623 SWPointer::SWPointer(MemNode* mem, SuperWord* slp, Node_Stack *nstack, bool analyze_only) :
3624   _mem(mem), _slp(slp),  _base(NULL),  _adr(NULL),
3625   _scale(0), _offset(0), _invar(NULL), _negate_invar(false),
3626   _nstack(nstack), _analyze_only(analyze_only),
3627   _stack_idx(0)
3628 #ifndef PRODUCT
3629   , _tracer(slp)
3630 #endif
3631 {
3632   NOT_PRODUCT(_tracer.ctor_1(mem);)
3633 
3634   Node* adr = mem-&gt;in(MemNode::Address);
3635   if (!adr-&gt;is_AddP()) {
3636     assert(!valid(), &quot;too complex&quot;);
3637     return;
3638   }
3639   // Match AddP(base, AddP(ptr, k*iv [+ invariant]), constant)
3640   Node* base = adr-&gt;in(AddPNode::Base);
3641   // The base address should be loop invariant
3642   if (!invariant(base)) {
3643     assert(!valid(), &quot;base address is loop variant&quot;);
3644     return;
3645   }
3646   // unsafe references require misaligned vector access support
3647   if (base-&gt;is_top() &amp;&amp; !Matcher::misaligned_vectors_ok()) {
3648     assert(!valid(), &quot;unsafe access&quot;);
3649     return;
3650   }
3651 
3652   NOT_PRODUCT(if(_slp-&gt;is_trace_alignment()) _tracer.store_depth();)
3653   NOT_PRODUCT(_tracer.ctor_2(adr);)
3654 
3655   int i;
3656   for (i = 0; i &lt; 3; i++) {
3657     NOT_PRODUCT(_tracer.ctor_3(adr, i);)
3658 
3659     if (!scaled_iv_plus_offset(adr-&gt;in(AddPNode::Offset))) {
3660       assert(!valid(), &quot;too complex&quot;);
3661       return;
3662     }
3663     adr = adr-&gt;in(AddPNode::Address);
3664     NOT_PRODUCT(_tracer.ctor_4(adr, i);)
3665 
3666     if (base == adr || !adr-&gt;is_AddP()) {
3667       NOT_PRODUCT(_tracer.ctor_5(adr, base, i);)
3668       break; // stop looking at addp&#39;s
3669     }
3670   }
3671   if (!invariant(adr)) {
3672     assert(!valid(), &quot;adr is loop variant&quot;);
3673     return;
3674   }
3675 
3676   if (!base-&gt;is_top() &amp;&amp; adr != base) {
3677     assert(!valid(), &quot;adr and base differ&quot;);
3678     return;
3679   }
3680 
3681   NOT_PRODUCT(if(_slp-&gt;is_trace_alignment()) _tracer.restore_depth();)
3682   NOT_PRODUCT(_tracer.ctor_6(mem);)
3683 
3684   _base = base;
3685   _adr  = adr;
3686   assert(valid(), &quot;Usable&quot;);
3687 }
3688 
3689 // Following is used to create a temporary object during
3690 // the pattern match of an address expression.
3691 SWPointer::SWPointer(SWPointer* p) :
3692   _mem(p-&gt;_mem), _slp(p-&gt;_slp),  _base(NULL),  _adr(NULL),
3693   _scale(0), _offset(0), _invar(NULL), _negate_invar(false),
3694   _nstack(p-&gt;_nstack), _analyze_only(p-&gt;_analyze_only),
3695   _stack_idx(p-&gt;_stack_idx)
3696   #ifndef PRODUCT
3697   , _tracer(p-&gt;_slp)
3698   #endif
3699 {}
3700 
3701 
3702 bool SWPointer::invariant(Node* n) {
3703   NOT_PRODUCT(Tracer::Depth dd;)
3704   Node *n_c = phase()-&gt;get_ctrl(n);
3705   NOT_PRODUCT(_tracer.invariant_1(n, n_c);)
3706   return !lpt()-&gt;is_member(phase()-&gt;get_loop(n_c));
3707 }
3708 //------------------------scaled_iv_plus_offset--------------------
3709 // Match: k*iv + offset
3710 // where: k is a constant that maybe zero, and
3711 //        offset is (k2 [+/- invariant]) where k2 maybe zero and invariant is optional
3712 bool SWPointer::scaled_iv_plus_offset(Node* n) {
3713   NOT_PRODUCT(Tracer::Depth ddd;)
3714   NOT_PRODUCT(_tracer.scaled_iv_plus_offset_1(n);)
3715 
3716   if (scaled_iv(n)) {
3717     NOT_PRODUCT(_tracer.scaled_iv_plus_offset_2(n);)
3718     return true;
3719   }
3720 
3721   if (offset_plus_k(n)) {
3722     NOT_PRODUCT(_tracer.scaled_iv_plus_offset_3(n);)
3723     return true;
3724   }
3725 
3726   int opc = n-&gt;Opcode();
3727   if (opc == Op_AddI) {
3728     if (scaled_iv(n-&gt;in(1)) &amp;&amp; offset_plus_k(n-&gt;in(2))) {
3729       NOT_PRODUCT(_tracer.scaled_iv_plus_offset_4(n);)
3730       return true;
3731     }
3732     if (scaled_iv(n-&gt;in(2)) &amp;&amp; offset_plus_k(n-&gt;in(1))) {
3733       NOT_PRODUCT(_tracer.scaled_iv_plus_offset_5(n);)
3734       return true;
3735     }
3736   } else if (opc == Op_SubI) {
3737     if (scaled_iv(n-&gt;in(1)) &amp;&amp; offset_plus_k(n-&gt;in(2), true)) {
3738       NOT_PRODUCT(_tracer.scaled_iv_plus_offset_6(n);)
3739       return true;
3740     }
3741     if (scaled_iv(n-&gt;in(2)) &amp;&amp; offset_plus_k(n-&gt;in(1))) {
3742       _scale *= -1;
3743       NOT_PRODUCT(_tracer.scaled_iv_plus_offset_7(n);)
3744       return true;
3745     }
3746   }
3747 
3748   NOT_PRODUCT(_tracer.scaled_iv_plus_offset_8(n);)
3749   return false;
3750 }
3751 
3752 //----------------------------scaled_iv------------------------
3753 // Match: k*iv where k is a constant that&#39;s not zero
3754 bool SWPointer::scaled_iv(Node* n) {
3755   NOT_PRODUCT(Tracer::Depth ddd;)
3756   NOT_PRODUCT(_tracer.scaled_iv_1(n);)
3757 
3758   if (_scale != 0) { // already found a scale
3759     NOT_PRODUCT(_tracer.scaled_iv_2(n, _scale);)
3760     return false;
3761   }
3762 
3763   if (n == iv()) {
3764     _scale = 1;
3765     NOT_PRODUCT(_tracer.scaled_iv_3(n, _scale);)
3766     return true;
3767   }
3768   if (_analyze_only &amp;&amp; (invariant(n) == false)) {
3769     _nstack-&gt;push(n, _stack_idx++);
3770   }
3771 
3772   int opc = n-&gt;Opcode();
3773   if (opc == Op_MulI) {
3774     if (n-&gt;in(1) == iv() &amp;&amp; n-&gt;in(2)-&gt;is_Con()) {
3775       _scale = n-&gt;in(2)-&gt;get_int();
3776       NOT_PRODUCT(_tracer.scaled_iv_4(n, _scale);)
3777       return true;
3778     } else if (n-&gt;in(2) == iv() &amp;&amp; n-&gt;in(1)-&gt;is_Con()) {
3779       _scale = n-&gt;in(1)-&gt;get_int();
3780       NOT_PRODUCT(_tracer.scaled_iv_5(n, _scale);)
3781       return true;
3782     }
3783   } else if (opc == Op_LShiftI) {
3784     if (n-&gt;in(1) == iv() &amp;&amp; n-&gt;in(2)-&gt;is_Con()) {
3785       _scale = 1 &lt;&lt; n-&gt;in(2)-&gt;get_int();
3786       NOT_PRODUCT(_tracer.scaled_iv_6(n, _scale);)
3787       return true;
3788     }
3789   } else if (opc == Op_ConvI2L) {
3790     if (n-&gt;in(1)-&gt;Opcode() == Op_CastII &amp;&amp;
3791         n-&gt;in(1)-&gt;as_CastII()-&gt;has_range_check()) {
3792       // Skip range check dependent CastII nodes
3793       n = n-&gt;in(1);
3794     }
3795     if (scaled_iv_plus_offset(n-&gt;in(1))) {
3796       NOT_PRODUCT(_tracer.scaled_iv_7(n);)
3797       return true;
3798     }
3799   } else if (opc == Op_LShiftL) {
3800     if (!has_iv() &amp;&amp; _invar == NULL) {
3801       // Need to preserve the current _offset value, so
3802       // create a temporary object for this expression subtree.
3803       // Hacky, so should re-engineer the address pattern match.
3804       NOT_PRODUCT(Tracer::Depth dddd;)
3805       SWPointer tmp(this);
3806       NOT_PRODUCT(_tracer.scaled_iv_8(n, &amp;tmp);)
3807 
3808       if (tmp.scaled_iv_plus_offset(n-&gt;in(1))) {
3809         if (tmp._invar == NULL || _slp-&gt;do_vector_loop()) {
3810           int mult = 1 &lt;&lt; n-&gt;in(2)-&gt;get_int();
3811           _scale   = tmp._scale  * mult;
3812           _offset += tmp._offset * mult;
3813           NOT_PRODUCT(_tracer.scaled_iv_9(n, _scale, _offset, mult);)
3814           return true;
3815         }
3816       }
3817     }
3818   }
3819   NOT_PRODUCT(_tracer.scaled_iv_10(n);)
3820   return false;
3821 }
3822 
3823 //----------------------------offset_plus_k------------------------
3824 // Match: offset is (k [+/- invariant])
3825 // where k maybe zero and invariant is optional, but not both.
3826 bool SWPointer::offset_plus_k(Node* n, bool negate) {
3827   NOT_PRODUCT(Tracer::Depth ddd;)
3828   NOT_PRODUCT(_tracer.offset_plus_k_1(n);)
3829 
3830   int opc = n-&gt;Opcode();
3831   if (opc == Op_ConI) {
3832     _offset += negate ? -(n-&gt;get_int()) : n-&gt;get_int();
3833     NOT_PRODUCT(_tracer.offset_plus_k_2(n, _offset);)
3834     return true;
3835   } else if (opc == Op_ConL) {
3836     // Okay if value fits into an int
3837     const TypeLong* t = n-&gt;find_long_type();
3838     if (t-&gt;higher_equal(TypeLong::INT)) {
3839       jlong loff = n-&gt;get_long();
3840       jint  off  = (jint)loff;
3841       _offset += negate ? -off : loff;
3842       NOT_PRODUCT(_tracer.offset_plus_k_3(n, _offset);)
3843       return true;
3844     }
3845     NOT_PRODUCT(_tracer.offset_plus_k_4(n);)
3846     return false;
3847   }
3848   if (_invar != NULL) { // already has an invariant
3849     NOT_PRODUCT(_tracer.offset_plus_k_5(n, _invar);)
3850     return false;
3851   }
3852 
3853   if (_analyze_only &amp;&amp; (invariant(n) == false)) {
3854     _nstack-&gt;push(n, _stack_idx++);
3855   }
3856   if (opc == Op_AddI) {
3857     if (n-&gt;in(2)-&gt;is_Con() &amp;&amp; invariant(n-&gt;in(1))) {
3858       _negate_invar = negate;
3859       _invar = n-&gt;in(1);
3860       _offset += negate ? -(n-&gt;in(2)-&gt;get_int()) : n-&gt;in(2)-&gt;get_int();
3861       NOT_PRODUCT(_tracer.offset_plus_k_6(n, _invar, _negate_invar, _offset);)
3862       return true;
3863     } else if (n-&gt;in(1)-&gt;is_Con() &amp;&amp; invariant(n-&gt;in(2))) {
3864       _offset += negate ? -(n-&gt;in(1)-&gt;get_int()) : n-&gt;in(1)-&gt;get_int();
3865       _negate_invar = negate;
3866       _invar = n-&gt;in(2);
3867       NOT_PRODUCT(_tracer.offset_plus_k_7(n, _invar, _negate_invar, _offset);)
3868       return true;
3869     }
3870   }
3871   if (opc == Op_SubI) {
3872     if (n-&gt;in(2)-&gt;is_Con() &amp;&amp; invariant(n-&gt;in(1))) {
3873       _negate_invar = negate;
3874       _invar = n-&gt;in(1);
3875       _offset += !negate ? -(n-&gt;in(2)-&gt;get_int()) : n-&gt;in(2)-&gt;get_int();
3876       NOT_PRODUCT(_tracer.offset_plus_k_8(n, _invar, _negate_invar, _offset);)
3877       return true;
3878     } else if (n-&gt;in(1)-&gt;is_Con() &amp;&amp; invariant(n-&gt;in(2))) {
3879       _offset += negate ? -(n-&gt;in(1)-&gt;get_int()) : n-&gt;in(1)-&gt;get_int();
3880       _negate_invar = !negate;
3881       _invar = n-&gt;in(2);
3882       NOT_PRODUCT(_tracer.offset_plus_k_9(n, _invar, _negate_invar, _offset);)
3883       return true;
3884     }
3885   }
3886   if (invariant(n)) {
3887     if (opc == Op_ConvI2L) {
3888       n = n-&gt;in(1);
3889       if (n-&gt;Opcode() == Op_CastII &amp;&amp;
3890           n-&gt;as_CastII()-&gt;has_range_check()) {
3891         // Skip range check dependent CastII nodes
3892         assert(invariant(n), &quot;sanity&quot;);
3893         n = n-&gt;in(1);
3894       }
3895     }
3896     _negate_invar = negate;
3897     _invar = n;
3898     NOT_PRODUCT(_tracer.offset_plus_k_10(n, _invar, _negate_invar, _offset);)
3899     return true;
3900   }
3901 
3902   NOT_PRODUCT(_tracer.offset_plus_k_11(n);)
3903   return false;
3904 }
3905 
3906 //----------------------------print------------------------
3907 void SWPointer::print() {
3908 #ifndef PRODUCT
3909   tty-&gt;print(&quot;base: %d  adr: %d  scale: %d  offset: %d  invar: %c%d\n&quot;,
3910              _base != NULL ? _base-&gt;_idx : 0,
3911              _adr  != NULL ? _adr-&gt;_idx  : 0,
3912              _scale, _offset,
3913              _negate_invar?&#39;-&#39;:&#39;+&#39;,
3914              _invar != NULL ? _invar-&gt;_idx : 0);
3915 #endif
3916 }
3917 
3918 //----------------------------tracing------------------------
3919 #ifndef PRODUCT
3920 void SWPointer::Tracer::print_depth() {
3921   for (int ii = 0; ii&lt;_depth; ++ii) tty-&gt;print(&quot;  &quot;);
3922 }
3923 
3924 void SWPointer::Tracer::ctor_1 (Node* mem) {
3925   if(_slp-&gt;is_trace_alignment()) {
3926     print_depth(); tty-&gt;print(&quot; %d SWPointer::SWPointer: start alignment analysis&quot;, mem-&gt;_idx); mem-&gt;dump();
3927   }
3928 }
3929 
3930 void SWPointer::Tracer::ctor_2(Node* adr) {
3931   if(_slp-&gt;is_trace_alignment()) {
3932     //store_depth();
3933     inc_depth();
3934     print_depth(); tty-&gt;print(&quot; %d (adr) SWPointer::SWPointer: &quot;, adr-&gt;_idx); adr-&gt;dump();
3935     inc_depth();
3936     print_depth(); tty-&gt;print(&quot; %d (base) SWPointer::SWPointer: &quot;, adr-&gt;in(AddPNode::Base)-&gt;_idx); adr-&gt;in(AddPNode::Base)-&gt;dump();
3937   }
3938 }
3939 
3940 void SWPointer::Tracer::ctor_3(Node* adr, int i) {
3941   if(_slp-&gt;is_trace_alignment()) {
3942     inc_depth();
3943     Node* offset = adr-&gt;in(AddPNode::Offset);
3944     print_depth(); tty-&gt;print(&quot; %d (offset) SWPointer::SWPointer: i = %d: &quot;, offset-&gt;_idx, i); offset-&gt;dump();
3945   }
3946 }
3947 
3948 void SWPointer::Tracer::ctor_4(Node* adr, int i) {
3949   if(_slp-&gt;is_trace_alignment()) {
3950     inc_depth();
3951     print_depth(); tty-&gt;print(&quot; %d (adr) SWPointer::SWPointer: i = %d: &quot;, adr-&gt;_idx, i); adr-&gt;dump();
3952   }
3953 }
3954 
3955 void SWPointer::Tracer::ctor_5(Node* adr, Node* base, int i) {
3956   if(_slp-&gt;is_trace_alignment()) {
3957     inc_depth();
3958     if (base == adr) {
3959       print_depth(); tty-&gt;print_cr(&quot;  \\ %d (adr) == %d (base) SWPointer::SWPointer: breaking analysis at i = %d&quot;, adr-&gt;_idx, base-&gt;_idx, i);
3960     } else if (!adr-&gt;is_AddP()) {
3961       print_depth(); tty-&gt;print_cr(&quot;  \\ %d (adr) is NOT Addp SWPointer::SWPointer: breaking analysis at i = %d&quot;, adr-&gt;_idx, i);
3962     }
3963   }
3964 }
3965 
3966 void SWPointer::Tracer::ctor_6(Node* mem) {
3967   if(_slp-&gt;is_trace_alignment()) {
3968     //restore_depth();
3969     print_depth(); tty-&gt;print_cr(&quot; %d (adr) SWPointer::SWPointer: stop analysis&quot;, mem-&gt;_idx);
3970   }
3971 }
3972 
3973 void SWPointer::Tracer::invariant_1(Node *n, Node *n_c) {
3974   if (_slp-&gt;do_vector_loop() &amp;&amp; _slp-&gt;is_debug() &amp;&amp; _slp-&gt;_lpt-&gt;is_member(_slp-&gt;_phase-&gt;get_loop(n_c)) != (int)_slp-&gt;in_bb(n)) {
3975     int is_member =  _slp-&gt;_lpt-&gt;is_member(_slp-&gt;_phase-&gt;get_loop(n_c));
3976     int in_bb     =  _slp-&gt;in_bb(n);
3977     print_depth(); tty-&gt;print(&quot;  \\ &quot;);  tty-&gt;print_cr(&quot; %d SWPointer::invariant  conditions differ: n_c %d&quot;, n-&gt;_idx, n_c-&gt;_idx);
3978     print_depth(); tty-&gt;print(&quot;  \\ &quot;);  tty-&gt;print_cr(&quot;is_member %d, in_bb %d&quot;, is_member, in_bb);
3979     print_depth(); tty-&gt;print(&quot;  \\ &quot;);  n-&gt;dump();
3980     print_depth(); tty-&gt;print(&quot;  \\ &quot;);  n_c-&gt;dump();
3981   }
3982 }
3983 
3984 void SWPointer::Tracer::scaled_iv_plus_offset_1(Node* n) {
3985   if(_slp-&gt;is_trace_alignment()) {
3986     print_depth(); tty-&gt;print(&quot; %d SWPointer::scaled_iv_plus_offset testing node: &quot;, n-&gt;_idx);
3987     n-&gt;dump();
3988   }
3989 }
3990 
3991 void SWPointer::Tracer::scaled_iv_plus_offset_2(Node* n) {
3992   if(_slp-&gt;is_trace_alignment()) {
3993     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: PASSED&quot;, n-&gt;_idx);
3994   }
3995 }
3996 
3997 void SWPointer::Tracer::scaled_iv_plus_offset_3(Node* n) {
3998   if(_slp-&gt;is_trace_alignment()) {
3999     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: PASSED&quot;, n-&gt;_idx);
4000   }
4001 }
4002 
4003 void SWPointer::Tracer::scaled_iv_plus_offset_4(Node* n) {
4004   if(_slp-&gt;is_trace_alignment()) {
4005     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: Op_AddI PASSED&quot;, n-&gt;_idx);
4006     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(1) is scaled_iv: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4007     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(2) is offset_plus_k: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4008   }
4009 }
4010 
4011 void SWPointer::Tracer::scaled_iv_plus_offset_5(Node* n) {
4012   if(_slp-&gt;is_trace_alignment()) {
4013     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: Op_AddI PASSED&quot;, n-&gt;_idx);
4014     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(2) is scaled_iv: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4015     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(1) is offset_plus_k: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4016   }
4017 }
4018 
4019 void SWPointer::Tracer::scaled_iv_plus_offset_6(Node* n) {
4020   if(_slp-&gt;is_trace_alignment()) {
4021     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: Op_SubI PASSED&quot;, n-&gt;_idx);
4022     print_depth(); tty-&gt;print(&quot;  \\  %d SWPointer::scaled_iv_plus_offset: in(1) is scaled_iv: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4023     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(2) is offset_plus_k: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4024   }
4025 }
4026 
4027 void SWPointer::Tracer::scaled_iv_plus_offset_7(Node* n) {
4028   if(_slp-&gt;is_trace_alignment()) {
4029     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: Op_SubI PASSED&quot;, n-&gt;_idx);
4030     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(2) is scaled_iv: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4031     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(1) is offset_plus_k: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4032   }
4033 }
4034 
4035 void SWPointer::Tracer::scaled_iv_plus_offset_8(Node* n) {
4036   if(_slp-&gt;is_trace_alignment()) {
4037     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: FAILED&quot;, n-&gt;_idx);
4038   }
4039 }
4040 
4041 void SWPointer::Tracer::scaled_iv_1(Node* n) {
4042   if(_slp-&gt;is_trace_alignment()) {
4043     print_depth(); tty-&gt;print(&quot; %d SWPointer::scaled_iv: testing node: &quot;, n-&gt;_idx); n-&gt;dump();
4044   }
4045 }
4046 
4047 void SWPointer::Tracer::scaled_iv_2(Node* n, int scale) {
4048   if(_slp-&gt;is_trace_alignment()) {
4049     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: FAILED since another _scale has been detected before&quot;, n-&gt;_idx);
4050     print_depth(); tty-&gt;print_cr(&quot;  \\ SWPointer::scaled_iv: _scale (%d) != 0&quot;, scale);
4051   }
4052 }
4053 
4054 void SWPointer::Tracer::scaled_iv_3(Node* n, int scale) {
4055   if(_slp-&gt;is_trace_alignment()) {
4056     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: is iv, setting _scale = %d&quot;, n-&gt;_idx, scale);
4057   }
4058 }
4059 
4060 void SWPointer::Tracer::scaled_iv_4(Node* n, int scale) {
4061   if(_slp-&gt;is_trace_alignment()) {
4062     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: Op_MulI PASSED, setting _scale = %d&quot;, n-&gt;_idx, scale);
4063     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(1) is iv: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4064     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(2) is Con: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4065   }
4066 }
4067 
4068 void SWPointer::Tracer::scaled_iv_5(Node* n, int scale) {
4069   if(_slp-&gt;is_trace_alignment()) {
4070     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: Op_MulI PASSED, setting _scale = %d&quot;, n-&gt;_idx, scale);
4071     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(2) is iv: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4072     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(1) is Con: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4073   }
4074 }
4075 
4076 void SWPointer::Tracer::scaled_iv_6(Node* n, int scale) {
4077   if(_slp-&gt;is_trace_alignment()) {
4078     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: Op_LShiftI PASSED, setting _scale = %d&quot;, n-&gt;_idx, scale);
4079     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(1) is iv: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4080     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(2) is Con: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4081   }
4082 }
4083 
4084 void SWPointer::Tracer::scaled_iv_7(Node* n) {
4085   if(_slp-&gt;is_trace_alignment()) {
4086     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: Op_ConvI2L PASSED&quot;, n-&gt;_idx);
4087     print_depth(); tty-&gt;print_cr(&quot;  \\ SWPointer::scaled_iv: in(1) %d is scaled_iv_plus_offset: &quot;, n-&gt;in(1)-&gt;_idx);
4088     inc_depth(); inc_depth();
4089     print_depth(); n-&gt;in(1)-&gt;dump();
4090     dec_depth(); dec_depth();
4091   }
4092 }
4093 
4094 void SWPointer::Tracer::scaled_iv_8(Node* n, SWPointer* tmp) {
4095   if(_slp-&gt;is_trace_alignment()) {
4096     print_depth(); tty-&gt;print(&quot; %d SWPointer::scaled_iv: Op_LShiftL, creating tmp SWPointer: &quot;, n-&gt;_idx); tmp-&gt;print();
4097   }
4098 }
4099 
4100 void SWPointer::Tracer::scaled_iv_9(Node* n, int scale, int _offset, int mult) {
4101   if(_slp-&gt;is_trace_alignment()) {
4102     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: Op_LShiftL PASSED, setting _scale = %d, _offset = %d&quot;, n-&gt;_idx, scale, _offset);
4103     print_depth(); tty-&gt;print_cr(&quot;  \\ SWPointer::scaled_iv: in(1) %d is scaled_iv_plus_offset, in(2) %d used to get mult = %d: _scale = %d, _offset = %d&quot;,
4104     n-&gt;in(1)-&gt;_idx, n-&gt;in(2)-&gt;_idx, mult, scale, _offset);
4105     inc_depth(); inc_depth();
4106     print_depth(); n-&gt;in(1)-&gt;dump();
4107     print_depth(); n-&gt;in(2)-&gt;dump();
4108     dec_depth(); dec_depth();
4109   }
4110 }
4111 
4112 void SWPointer::Tracer::scaled_iv_10(Node* n) {
4113   if(_slp-&gt;is_trace_alignment()) {
4114     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: FAILED&quot;, n-&gt;_idx);
4115   }
4116 }
4117 
4118 void SWPointer::Tracer::offset_plus_k_1(Node* n) {
4119   if(_slp-&gt;is_trace_alignment()) {
4120     print_depth(); tty-&gt;print(&quot; %d SWPointer::offset_plus_k: testing node: &quot;, n-&gt;_idx); n-&gt;dump();
4121   }
4122 }
4123 
4124 void SWPointer::Tracer::offset_plus_k_2(Node* n, int _offset) {
4125   if(_slp-&gt;is_trace_alignment()) {
4126     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_ConI PASSED, setting _offset = %d&quot;, n-&gt;_idx, _offset);
4127   }
4128 }
4129 
4130 void SWPointer::Tracer::offset_plus_k_3(Node* n, int _offset) {
4131   if(_slp-&gt;is_trace_alignment()) {
4132     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_ConL PASSED, setting _offset = %d&quot;, n-&gt;_idx, _offset);
4133   }
4134 }
4135 
4136 void SWPointer::Tracer::offset_plus_k_4(Node* n) {
4137   if(_slp-&gt;is_trace_alignment()) {
4138     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: FAILED&quot;, n-&gt;_idx);
4139     print_depth(); tty-&gt;print_cr(&quot;  \\ &quot; JLONG_FORMAT &quot; SWPointer::offset_plus_k: Op_ConL FAILED, k is too big&quot;, n-&gt;get_long());
4140   }
4141 }
4142 
4143 void SWPointer::Tracer::offset_plus_k_5(Node* n, Node* _invar) {
4144   if(_slp-&gt;is_trace_alignment()) {
4145     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: FAILED since another invariant has been detected before&quot;, n-&gt;_idx);
4146     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: _invar != NULL: &quot;, _invar-&gt;_idx); _invar-&gt;dump();
4147   }
4148 }
4149 
4150 void SWPointer::Tracer::offset_plus_k_6(Node* n, Node* _invar, bool _negate_invar, int _offset) {
4151   if(_slp-&gt;is_trace_alignment()) {
4152     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_AddI PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d&quot;,
4153     n-&gt;_idx, _negate_invar, _invar-&gt;_idx, _offset);
4154     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(2) is Con: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4155     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(1) is invariant: &quot;, _invar-&gt;_idx); _invar-&gt;dump();
4156   }
4157 }
4158 
4159 void SWPointer::Tracer::offset_plus_k_7(Node* n, Node* _invar, bool _negate_invar, int _offset) {
4160   if(_slp-&gt;is_trace_alignment()) {
4161     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_AddI PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d&quot;,
4162     n-&gt;_idx, _negate_invar, _invar-&gt;_idx, _offset);
4163     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(1) is Con: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4164     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(2) is invariant: &quot;, _invar-&gt;_idx); _invar-&gt;dump();
4165   }
4166 }
4167 
4168 void SWPointer::Tracer::offset_plus_k_8(Node* n, Node* _invar, bool _negate_invar, int _offset) {
4169   if(_slp-&gt;is_trace_alignment()) {
4170     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_SubI is PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d&quot;,
4171     n-&gt;_idx, _negate_invar, _invar-&gt;_idx, _offset);
4172     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(2) is Con: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4173     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(1) is invariant: &quot;, _invar-&gt;_idx); _invar-&gt;dump();
4174   }
4175 }
4176 
4177 void SWPointer::Tracer::offset_plus_k_9(Node* n, Node* _invar, bool _negate_invar, int _offset) {
4178   if(_slp-&gt;is_trace_alignment()) {
4179     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_SubI PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d&quot;, n-&gt;_idx, _negate_invar, _invar-&gt;_idx, _offset);
4180     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(1) is Con: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4181     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(2) is invariant: &quot;, _invar-&gt;_idx); _invar-&gt;dump();
4182   }
4183 }
4184 
4185 void SWPointer::Tracer::offset_plus_k_10(Node* n, Node* _invar, bool _negate_invar, int _offset) {
4186   if(_slp-&gt;is_trace_alignment()) {
4187     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d&quot;, n-&gt;_idx, _negate_invar, _invar-&gt;_idx, _offset);
4188     print_depth(); tty-&gt;print_cr(&quot;  \\ %d SWPointer::offset_plus_k: is invariant&quot;, n-&gt;_idx);
4189   }
4190 }
4191 
4192 void SWPointer::Tracer::offset_plus_k_11(Node* n) {
4193   if(_slp-&gt;is_trace_alignment()) {
4194     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: FAILED&quot;, n-&gt;_idx);
4195   }
4196 }
4197 
4198 #endif
4199 // ========================= OrderedPair =====================
4200 
4201 const OrderedPair OrderedPair::initial;
4202 
4203 // ========================= SWNodeInfo =====================
4204 
4205 const SWNodeInfo SWNodeInfo::initial;
4206 
4207 
4208 // ============================ DepGraph ===========================
4209 
4210 //------------------------------make_node---------------------------
4211 // Make a new dependence graph node for an ideal node.
4212 DepMem* DepGraph::make_node(Node* node) {
4213   DepMem* m = new (_arena) DepMem(node);
4214   if (node != NULL) {
4215     assert(_map.at_grow(node-&gt;_idx) == NULL, &quot;one init only&quot;);
4216     _map.at_put_grow(node-&gt;_idx, m);
4217   }
4218   return m;
4219 }
4220 
4221 //------------------------------make_edge---------------------------
4222 // Make a new dependence graph edge from dpred -&gt; dsucc
4223 DepEdge* DepGraph::make_edge(DepMem* dpred, DepMem* dsucc) {
4224   DepEdge* e = new (_arena) DepEdge(dpred, dsucc, dsucc-&gt;in_head(), dpred-&gt;out_head());
4225   dpred-&gt;set_out_head(e);
4226   dsucc-&gt;set_in_head(e);
4227   return e;
4228 }
4229 
4230 // ========================== DepMem ========================
4231 
4232 //------------------------------in_cnt---------------------------
4233 int DepMem::in_cnt() {
4234   int ct = 0;
4235   for (DepEdge* e = _in_head; e != NULL; e = e-&gt;next_in()) ct++;
4236   return ct;
4237 }
4238 
4239 //------------------------------out_cnt---------------------------
4240 int DepMem::out_cnt() {
4241   int ct = 0;
4242   for (DepEdge* e = _out_head; e != NULL; e = e-&gt;next_out()) ct++;
4243   return ct;
4244 }
4245 
4246 //------------------------------print-----------------------------
4247 void DepMem::print() {
4248 #ifndef PRODUCT
4249   tty-&gt;print(&quot;  DepNode %d (&quot;, _node-&gt;_idx);
4250   for (DepEdge* p = _in_head; p != NULL; p = p-&gt;next_in()) {
4251     Node* pred = p-&gt;pred()-&gt;node();
4252     tty-&gt;print(&quot; %d&quot;, pred != NULL ? pred-&gt;_idx : 0);
4253   }
4254   tty-&gt;print(&quot;) [&quot;);
4255   for (DepEdge* s = _out_head; s != NULL; s = s-&gt;next_out()) {
4256     Node* succ = s-&gt;succ()-&gt;node();
4257     tty-&gt;print(&quot; %d&quot;, succ != NULL ? succ-&gt;_idx : 0);
4258   }
4259   tty-&gt;print_cr(&quot; ]&quot;);
4260 #endif
4261 }
4262 
4263 // =========================== DepEdge =========================
4264 
4265 //------------------------------DepPreds---------------------------
4266 void DepEdge::print() {
4267 #ifndef PRODUCT
4268   tty-&gt;print_cr(&quot;DepEdge: %d [ %d ]&quot;, _pred-&gt;node()-&gt;_idx, _succ-&gt;node()-&gt;_idx);
4269 #endif
4270 }
4271 
4272 // =========================== DepPreds =========================
4273 // Iterator over predecessor edges in the dependence graph.
4274 
4275 //------------------------------DepPreds---------------------------
4276 DepPreds::DepPreds(Node* n, DepGraph&amp; dg) {
4277   _n = n;
4278   _done = false;
4279   if (_n-&gt;is_Store() || _n-&gt;is_Load()) {
4280     _next_idx = MemNode::Address;
4281     _end_idx  = n-&gt;req();
4282     _dep_next = dg.dep(_n)-&gt;in_head();
4283   } else if (_n-&gt;is_Mem()) {
4284     _next_idx = 0;
4285     _end_idx  = 0;
4286     _dep_next = dg.dep(_n)-&gt;in_head();
4287   } else {
4288     _next_idx = 1;
4289     _end_idx  = _n-&gt;req();
4290     _dep_next = NULL;
4291   }
4292   next();
4293 }
4294 
4295 //------------------------------next---------------------------
4296 void DepPreds::next() {
4297   if (_dep_next != NULL) {
4298     _current  = _dep_next-&gt;pred()-&gt;node();
4299     _dep_next = _dep_next-&gt;next_in();
4300   } else if (_next_idx &lt; _end_idx) {
4301     _current  = _n-&gt;in(_next_idx++);
4302   } else {
4303     _done = true;
4304   }
4305 }
4306 
4307 // =========================== DepSuccs =========================
4308 // Iterator over successor edges in the dependence graph.
4309 
4310 //------------------------------DepSuccs---------------------------
4311 DepSuccs::DepSuccs(Node* n, DepGraph&amp; dg) {
4312   _n = n;
4313   _done = false;
4314   if (_n-&gt;is_Load()) {
4315     _next_idx = 0;
4316     _end_idx  = _n-&gt;outcnt();
4317     _dep_next = dg.dep(_n)-&gt;out_head();
4318   } else if (_n-&gt;is_Mem() || (_n-&gt;is_Phi() &amp;&amp; _n-&gt;bottom_type() == Type::MEMORY)) {
4319     _next_idx = 0;
4320     _end_idx  = 0;
4321     _dep_next = dg.dep(_n)-&gt;out_head();
4322   } else {
4323     _next_idx = 0;
4324     _end_idx  = _n-&gt;outcnt();
4325     _dep_next = NULL;
4326   }
4327   next();
4328 }
4329 
4330 //-------------------------------next---------------------------
4331 void DepSuccs::next() {
4332   if (_dep_next != NULL) {
4333     _current  = _dep_next-&gt;succ()-&gt;node();
4334     _dep_next = _dep_next-&gt;next_out();
4335   } else if (_next_idx &lt; _end_idx) {
4336     _current  = _n-&gt;raw_out(_next_idx++);
4337   } else {
4338     _done = true;
4339   }
4340 }
4341 
4342 //
4343 // --------------------------------- vectorization/simd -----------------------------------
4344 //
4345 bool SuperWord::same_origin_idx(Node* a, Node* b) const {
4346   return a != NULL &amp;&amp; b != NULL &amp;&amp; _clone_map.same_idx(a-&gt;_idx, b-&gt;_idx);
4347 }
4348 bool SuperWord::same_generation(Node* a, Node* b) const {
4349   return a != NULL &amp;&amp; b != NULL &amp;&amp; _clone_map.same_gen(a-&gt;_idx, b-&gt;_idx);
4350 }
4351 
4352 Node*  SuperWord::find_phi_for_mem_dep(LoadNode* ld) {
4353   assert(in_bb(ld), &quot;must be in block&quot;);
4354   if (_clone_map.gen(ld-&gt;_idx) == _ii_first) {
4355 #ifndef PRODUCT
4356     if (_vector_loop_debug) {
4357       tty-&gt;print_cr(&quot;SuperWord::find_phi_for_mem_dep _clone_map.gen(ld-&gt;_idx)=%d&quot;,
4358         _clone_map.gen(ld-&gt;_idx));
4359     }
4360 #endif
4361     return NULL; //we think that any ld in the first gen being vectorizable
4362   }
4363 
4364   Node* mem = ld-&gt;in(MemNode::Memory);
4365   if (mem-&gt;outcnt() &lt;= 1) {
4366     // we don&#39;t want to remove the only edge from mem node to load
4367 #ifndef PRODUCT
4368     if (_vector_loop_debug) {
4369       tty-&gt;print_cr(&quot;SuperWord::find_phi_for_mem_dep input node %d to load %d has no other outputs and edge mem-&gt;load cannot be removed&quot;,
4370         mem-&gt;_idx, ld-&gt;_idx);
4371       ld-&gt;dump();
4372       mem-&gt;dump();
4373     }
4374 #endif
4375     return NULL;
4376   }
4377   if (!in_bb(mem) || same_generation(mem, ld)) {
4378 #ifndef PRODUCT
4379     if (_vector_loop_debug) {
4380       tty-&gt;print_cr(&quot;SuperWord::find_phi_for_mem_dep _clone_map.gen(mem-&gt;_idx)=%d&quot;,
4381         _clone_map.gen(mem-&gt;_idx));
4382     }
4383 #endif
4384     return NULL; // does not depend on loop volatile node or depends on the same generation
4385   }
4386 
4387   //otherwise first node should depend on mem-phi
4388   Node* first = first_node(ld);
4389   assert(first-&gt;is_Load(), &quot;must be Load&quot;);
4390   Node* phi = first-&gt;as_Load()-&gt;in(MemNode::Memory);
4391   if (!phi-&gt;is_Phi() || phi-&gt;bottom_type() != Type::MEMORY) {
4392 #ifndef PRODUCT
4393     if (_vector_loop_debug) {
4394       tty-&gt;print_cr(&quot;SuperWord::find_phi_for_mem_dep load is not vectorizable node, since it&#39;s `first` does not take input from mem phi&quot;);
4395       ld-&gt;dump();
4396       first-&gt;dump();
4397     }
4398 #endif
4399     return NULL;
4400   }
4401 
4402   Node* tail = 0;
4403   for (int m = 0; m &lt; _mem_slice_head.length(); m++) {
4404     if (_mem_slice_head.at(m) == phi) {
4405       tail = _mem_slice_tail.at(m);
4406     }
4407   }
4408   if (tail == 0) { //test that found phi is in the list  _mem_slice_head
4409 #ifndef PRODUCT
4410     if (_vector_loop_debug) {
4411       tty-&gt;print_cr(&quot;SuperWord::find_phi_for_mem_dep load %d is not vectorizable node, its phi %d is not _mem_slice_head&quot;,
4412         ld-&gt;_idx, phi-&gt;_idx);
4413       ld-&gt;dump();
4414       phi-&gt;dump();
4415     }
4416 #endif
4417     return NULL;
4418   }
4419 
4420   // now all conditions are met
4421   return phi;
4422 }
4423 
4424 Node* SuperWord::first_node(Node* nd) {
4425   for (int ii = 0; ii &lt; _iteration_first.length(); ii++) {
4426     Node* nnn = _iteration_first.at(ii);
4427     if (same_origin_idx(nnn, nd)) {
4428 #ifndef PRODUCT
4429       if (_vector_loop_debug) {
4430         tty-&gt;print_cr(&quot;SuperWord::first_node: %d is the first iteration node for %d (_clone_map.idx(nnn-&gt;_idx) = %d)&quot;,
4431           nnn-&gt;_idx, nd-&gt;_idx, _clone_map.idx(nnn-&gt;_idx));
4432       }
4433 #endif
4434       return nnn;
4435     }
4436   }
4437 
4438 #ifndef PRODUCT
4439   if (_vector_loop_debug) {
4440     tty-&gt;print_cr(&quot;SuperWord::first_node: did not find first iteration node for %d (_clone_map.idx(nd-&gt;_idx)=%d)&quot;,
4441       nd-&gt;_idx, _clone_map.idx(nd-&gt;_idx));
4442   }
4443 #endif
4444   return 0;
4445 }
4446 
4447 Node* SuperWord::last_node(Node* nd) {
4448   for (int ii = 0; ii &lt; _iteration_last.length(); ii++) {
4449     Node* nnn = _iteration_last.at(ii);
4450     if (same_origin_idx(nnn, nd)) {
4451 #ifndef PRODUCT
4452       if (_vector_loop_debug) {
4453         tty-&gt;print_cr(&quot;SuperWord::last_node _clone_map.idx(nnn-&gt;_idx)=%d, _clone_map.idx(nd-&gt;_idx)=%d&quot;,
4454           _clone_map.idx(nnn-&gt;_idx), _clone_map.idx(nd-&gt;_idx));
4455       }
4456 #endif
4457       return nnn;
4458     }
4459   }
4460   return 0;
4461 }
4462 
4463 int SuperWord::mark_generations() {
4464   Node *ii_err = NULL, *tail_err = NULL;
4465   for (int i = 0; i &lt; _mem_slice_head.length(); i++) {
4466     Node* phi  = _mem_slice_head.at(i);
4467     assert(phi-&gt;is_Phi(), &quot;must be phi&quot;);
4468 
4469     Node* tail = _mem_slice_tail.at(i);
4470     if (_ii_last == -1) {
4471       tail_err = tail;
4472       _ii_last = _clone_map.gen(tail-&gt;_idx);
4473     }
4474     else if (_ii_last != _clone_map.gen(tail-&gt;_idx)) {
4475 #ifndef PRODUCT
4476       if (TraceSuperWord &amp;&amp; Verbose) {
4477         tty-&gt;print_cr(&quot;SuperWord::mark_generations _ii_last error - found different generations in two tail nodes &quot;);
4478         tail-&gt;dump();
4479         tail_err-&gt;dump();
4480       }
4481 #endif
4482       return -1;
4483     }
4484 
4485     // find first iteration in the loop
4486     for (DUIterator_Fast imax, i = phi-&gt;fast_outs(imax); i &lt; imax; i++) {
4487       Node* ii = phi-&gt;fast_out(i);
4488       if (in_bb(ii) &amp;&amp; ii-&gt;is_Store()) { // we speculate that normally Stores of one and one only generation have deps from mem phi
4489         if (_ii_first == -1) {
4490           ii_err = ii;
4491           _ii_first = _clone_map.gen(ii-&gt;_idx);
4492         } else if (_ii_first != _clone_map.gen(ii-&gt;_idx)) {
4493 #ifndef PRODUCT
4494           if (TraceSuperWord &amp;&amp; Verbose) {
4495             tty-&gt;print_cr(&quot;SuperWord::mark_generations: _ii_first was found before and not equal to one in this node (%d)&quot;, _ii_first);
4496             ii-&gt;dump();
4497             if (ii_err!= 0) {
4498               ii_err-&gt;dump();
4499             }
4500           }
4501 #endif
4502           return -1; // this phi has Stores from different generations of unroll and cannot be simd/vectorized
4503         }
4504       }
4505     }//for (DUIterator_Fast imax,
4506   }//for (int i...
4507 
4508   if (_ii_first == -1 || _ii_last == -1) {
4509     if (TraceSuperWord &amp;&amp; Verbose) {
4510       tty-&gt;print_cr(&quot;SuperWord::mark_generations unknown error, something vent wrong&quot;);
4511     }
4512     return -1; // something vent wrong
4513   }
4514   // collect nodes in the first and last generations
4515   assert(_iteration_first.length() == 0, &quot;_iteration_first must be empty&quot;);
4516   assert(_iteration_last.length() == 0, &quot;_iteration_last must be empty&quot;);
4517   for (int j = 0; j &lt; _block.length(); j++) {
4518     Node* n = _block.at(j);
4519     node_idx_t gen = _clone_map.gen(n-&gt;_idx);
4520     if ((signed)gen == _ii_first) {
4521       _iteration_first.push(n);
4522     } else if ((signed)gen == _ii_last) {
4523       _iteration_last.push(n);
4524     }
4525   }
4526 
4527   // building order of iterations
4528   if (_ii_order.length() == 0 &amp;&amp; ii_err != 0) {
4529     assert(in_bb(ii_err) &amp;&amp; ii_err-&gt;is_Store(), &quot;should be Store in bb&quot;);
4530     Node* nd = ii_err;
4531     while(_clone_map.gen(nd-&gt;_idx) != _ii_last) {
4532       _ii_order.push(_clone_map.gen(nd-&gt;_idx));
4533       bool found = false;
4534       for (DUIterator_Fast imax, i = nd-&gt;fast_outs(imax); i &lt; imax; i++) {
4535         Node* use = nd-&gt;fast_out(i);
4536         if (same_origin_idx(use, nd) &amp;&amp; use-&gt;as_Store()-&gt;in(MemNode::Memory) == nd) {
4537           found = true;
4538           nd = use;
4539           break;
4540         }
4541       }//for
4542 
4543       if (found == false) {
4544         if (TraceSuperWord &amp;&amp; Verbose) {
4545           tty-&gt;print_cr(&quot;SuperWord::mark_generations: Cannot build order of iterations - no dependent Store for %d&quot;, nd-&gt;_idx);
4546         }
4547         _ii_order.clear();
4548         return -1;
4549       }
4550     } //while
4551     _ii_order.push(_clone_map.gen(nd-&gt;_idx));
4552   }
4553 
4554 #ifndef PRODUCT
4555   if (_vector_loop_debug) {
4556     tty-&gt;print_cr(&quot;SuperWord::mark_generations&quot;);
4557     tty-&gt;print_cr(&quot;First generation (%d) nodes:&quot;, _ii_first);
4558     for (int ii = 0; ii &lt; _iteration_first.length(); ii++)  _iteration_first.at(ii)-&gt;dump();
4559     tty-&gt;print_cr(&quot;Last generation (%d) nodes:&quot;, _ii_last);
4560     for (int ii = 0; ii &lt; _iteration_last.length(); ii++)  _iteration_last.at(ii)-&gt;dump();
4561     tty-&gt;print_cr(&quot; &quot;);
4562 
4563     tty-&gt;print(&quot;SuperWord::List of generations: &quot;);
4564     for (int jj = 0; jj &lt; _ii_order.length(); ++jj) {
4565       tty-&gt;print(&quot;%d:%d &quot;, jj, _ii_order.at(jj));
4566     }
4567     tty-&gt;print_cr(&quot; &quot;);
4568   }
4569 #endif
4570 
4571   return _ii_first;
4572 }
4573 
4574 bool SuperWord::fix_commutative_inputs(Node* gold, Node* fix) {
4575   assert(gold-&gt;is_Add() &amp;&amp; fix-&gt;is_Add() || gold-&gt;is_Mul() &amp;&amp; fix-&gt;is_Mul(), &quot;should be only Add or Mul nodes&quot;);
4576   assert(same_origin_idx(gold, fix), &quot;should be clones of the same node&quot;);
4577   Node* gin1 = gold-&gt;in(1);
4578   Node* gin2 = gold-&gt;in(2);
4579   Node* fin1 = fix-&gt;in(1);
4580   Node* fin2 = fix-&gt;in(2);
4581   bool swapped = false;
4582 
4583   if (in_bb(gin1) &amp;&amp; in_bb(gin2) &amp;&amp; in_bb(fin1) &amp;&amp; in_bb(fin1)) {
4584     if (same_origin_idx(gin1, fin1) &amp;&amp;
4585         same_origin_idx(gin2, fin2)) {
4586       return true; // nothing to fix
4587     }
4588     if (same_origin_idx(gin1, fin2) &amp;&amp;
4589         same_origin_idx(gin2, fin1)) {
4590       fix-&gt;swap_edges(1, 2);
4591       swapped = true;
4592     }
4593   }
4594   // at least one input comes from outside of bb
4595   if (gin1-&gt;_idx == fin1-&gt;_idx)  {
4596     return true; // nothing to fix
4597   }
4598   if (!swapped &amp;&amp; (gin1-&gt;_idx == fin2-&gt;_idx || gin2-&gt;_idx == fin1-&gt;_idx))  { //swapping is expensive, check condition first
4599     fix-&gt;swap_edges(1, 2);
4600     swapped = true;
4601   }
4602 
4603   if (swapped) {
4604 #ifndef PRODUCT
4605     if (_vector_loop_debug) {
4606       tty-&gt;print_cr(&quot;SuperWord::fix_commutative_inputs: fixed node %d&quot;, fix-&gt;_idx);
4607     }
4608 #endif
4609     return true;
4610   }
4611 
4612   if (TraceSuperWord &amp;&amp; Verbose) {
4613     tty-&gt;print_cr(&quot;SuperWord::fix_commutative_inputs: cannot fix node %d&quot;, fix-&gt;_idx);
4614   }
4615 
4616   return false;
4617 }
4618 
4619 bool SuperWord::pack_parallel() {
4620 #ifndef PRODUCT
4621   if (_vector_loop_debug) {
4622     tty-&gt;print_cr(&quot;SuperWord::pack_parallel: START&quot;);
4623   }
4624 #endif
4625 
4626   _packset.clear();
4627 
4628   for (int ii = 0; ii &lt; _iteration_first.length(); ii++) {
4629     Node* nd = _iteration_first.at(ii);
4630     if (in_bb(nd) &amp;&amp; (nd-&gt;is_Load() || nd-&gt;is_Store() || nd-&gt;is_Add() || nd-&gt;is_Mul())) {
4631       Node_List* pk = new Node_List();
4632       pk-&gt;push(nd);
4633       for (int gen = 1; gen &lt; _ii_order.length(); ++gen) {
4634         for (int kk = 0; kk &lt; _block.length(); kk++) {
4635           Node* clone = _block.at(kk);
4636           if (same_origin_idx(clone, nd) &amp;&amp;
4637               _clone_map.gen(clone-&gt;_idx) == _ii_order.at(gen)) {
4638             if (nd-&gt;is_Add() || nd-&gt;is_Mul()) {
4639               fix_commutative_inputs(nd, clone);
4640             }
4641             pk-&gt;push(clone);
4642             if (pk-&gt;size() == 4) {
4643               _packset.append(pk);
4644 #ifndef PRODUCT
4645               if (_vector_loop_debug) {
4646                 tty-&gt;print_cr(&quot;SuperWord::pack_parallel: added pack &quot;);
4647                 pk-&gt;dump();
4648               }
4649 #endif
4650               if (_clone_map.gen(clone-&gt;_idx) != _ii_last) {
4651                 pk = new Node_List();
4652               }
4653             }
4654             break;
4655           }
4656         }
4657       }//for
4658     }//if
4659   }//for
4660 
4661 #ifndef PRODUCT
4662   if (_vector_loop_debug) {
4663     tty-&gt;print_cr(&quot;SuperWord::pack_parallel: END&quot;);
4664   }
4665 #endif
4666 
4667   return true;
4668 }
4669 
4670 bool SuperWord::hoist_loads_in_graph() {
4671   GrowableArray&lt;Node*&gt; loads;
4672 
4673 #ifndef PRODUCT
4674   if (_vector_loop_debug) {
4675     tty-&gt;print_cr(&quot;SuperWord::hoist_loads_in_graph: total number _mem_slice_head.length() = %d&quot;, _mem_slice_head.length());
4676   }
4677 #endif
4678 
4679   for (int i = 0; i &lt; _mem_slice_head.length(); i++) {
4680     Node* n = _mem_slice_head.at(i);
4681     if ( !in_bb(n) || !n-&gt;is_Phi() || n-&gt;bottom_type() != Type::MEMORY) {
4682       if (TraceSuperWord &amp;&amp; Verbose) {
4683         tty-&gt;print_cr(&quot;SuperWord::hoist_loads_in_graph: skipping unexpected node n=%d&quot;, n-&gt;_idx);
4684       }
4685       continue;
4686     }
4687 
4688 #ifndef PRODUCT
4689     if (_vector_loop_debug) {
4690       tty-&gt;print_cr(&quot;SuperWord::hoist_loads_in_graph: processing phi %d  = _mem_slice_head.at(%d);&quot;, n-&gt;_idx, i);
4691     }
4692 #endif
4693 
4694     for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
4695       Node* ld = n-&gt;fast_out(i);
4696       if (ld-&gt;is_Load() &amp;&amp; ld-&gt;as_Load()-&gt;in(MemNode::Memory) == n &amp;&amp; in_bb(ld)) {
4697         for (int i = 0; i &lt; _block.length(); i++) {
4698           Node* ld2 = _block.at(i);
4699           if (ld2-&gt;is_Load() &amp;&amp; same_origin_idx(ld, ld2) &amp;&amp;
4700               !same_generation(ld, ld2)) { // &lt;= do not collect the first generation ld
4701 #ifndef PRODUCT
4702             if (_vector_loop_debug) {
4703               tty-&gt;print_cr(&quot;SuperWord::hoist_loads_in_graph: will try to hoist load ld2-&gt;_idx=%d, cloned from %d (ld-&gt;_idx=%d)&quot;,
4704                 ld2-&gt;_idx, _clone_map.idx(ld-&gt;_idx), ld-&gt;_idx);
4705             }
4706 #endif
4707             // could not do on-the-fly, since iterator is immutable
4708             loads.push(ld2);
4709           }
4710         }// for
4711       }//if
4712     }//for (DUIterator_Fast imax,
4713   }//for (int i = 0; i
4714 
4715   for (int i = 0; i &lt; loads.length(); i++) {
4716     LoadNode* ld = loads.at(i)-&gt;as_Load();
4717     Node* phi = find_phi_for_mem_dep(ld);
4718     if (phi != NULL) {
4719 #ifndef PRODUCT
4720       if (_vector_loop_debug) {
4721         tty-&gt;print_cr(&quot;SuperWord::hoist_loads_in_graph replacing MemNode::Memory(%d) edge in %d with one from %d&quot;,
4722           MemNode::Memory, ld-&gt;_idx, phi-&gt;_idx);
4723       }
4724 #endif
4725       _igvn.replace_input_of(ld, MemNode::Memory, phi);
4726     }
4727   }//for
4728 
4729   restart(); // invalidate all basic structures, since we rebuilt the graph
4730 
4731   if (TraceSuperWord &amp;&amp; Verbose) {
4732     tty-&gt;print_cr(&quot;\nSuperWord::hoist_loads_in_graph() the graph was rebuilt, all structures invalidated and need rebuild&quot;);
4733   }
4734 
4735   return true;
4736 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
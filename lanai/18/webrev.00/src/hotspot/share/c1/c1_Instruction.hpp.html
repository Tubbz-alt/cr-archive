<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/c1/c1_Instruction.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_C1_C1_INSTRUCTION_HPP
  26 #define SHARE_C1_C1_INSTRUCTION_HPP
  27 
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_LIR.hpp&quot;
  30 #include &quot;c1/c1_ValueType.hpp&quot;
  31 #include &quot;ci/ciField.hpp&quot;
  32 
  33 // Predefined classes
  34 class ciField;
  35 class ValueStack;
  36 class InstructionPrinter;
  37 class IRScope;
  38 class LIR_OprDesc;
  39 typedef LIR_OprDesc* LIR_Opr;
  40 
  41 
  42 // Instruction class hierarchy
  43 //
  44 // All leaf classes in the class hierarchy are concrete classes
  45 // (i.e., are instantiated). All other classes are abstract and
  46 // serve factoring.
  47 
  48 class Instruction;
  49 class   Phi;
  50 class   Local;
  51 class   Constant;
  52 class   AccessField;
  53 class     LoadField;
  54 class     StoreField;
  55 class   AccessArray;
  56 class     ArrayLength;
  57 class     AccessIndexed;
  58 class       LoadIndexed;
  59 class       StoreIndexed;
  60 class   NegateOp;
  61 class   Op2;
  62 class     ArithmeticOp;
  63 class     ShiftOp;
  64 class     LogicOp;
  65 class     CompareOp;
  66 class     IfOp;
  67 class   Convert;
  68 class   NullCheck;
  69 class   TypeCast;
  70 class   OsrEntry;
  71 class   ExceptionObject;
  72 class   StateSplit;
  73 class     Invoke;
  74 class     NewInstance;
  75 class     NewArray;
  76 class       NewTypeArray;
  77 class       NewObjectArray;
  78 class       NewMultiArray;
  79 class     TypeCheck;
  80 class       CheckCast;
  81 class       InstanceOf;
  82 class     AccessMonitor;
  83 class       MonitorEnter;
  84 class       MonitorExit;
  85 class     Intrinsic;
  86 class     BlockBegin;
  87 class     BlockEnd;
  88 class       Goto;
  89 class       If;
  90 class       IfInstanceOf;
  91 class       Switch;
  92 class         TableSwitch;
  93 class         LookupSwitch;
  94 class       Return;
  95 class       Throw;
  96 class       Base;
  97 class   RoundFP;
  98 class   UnsafeOp;
  99 class     UnsafeRawOp;
 100 class       UnsafeGetRaw;
 101 class       UnsafePutRaw;
 102 class     UnsafeObjectOp;
 103 class       UnsafeGetObject;
 104 class       UnsafePutObject;
 105 class         UnsafeGetAndSetObject;
 106 class   ProfileCall;
 107 class   ProfileReturnType;
 108 class   ProfileInvoke;
 109 class   RuntimeCall;
 110 class   MemBar;
 111 class   RangeCheckPredicate;
 112 #ifdef ASSERT
 113 class   Assert;
 114 #endif
 115 
 116 // A Value is a reference to the instruction creating the value
 117 typedef Instruction* Value;
 118 typedef GrowableArray&lt;Value&gt; Values;
 119 typedef GrowableArray&lt;ValueStack*&gt; ValueStackStack;
 120 
 121 // BlockClosure is the base class for block traversal/iteration.
 122 
 123 class BlockClosure: public CompilationResourceObj {
 124  public:
 125   virtual void block_do(BlockBegin* block)       = 0;
 126 };
 127 
 128 
 129 // A simple closure class for visiting the values of an Instruction
 130 class ValueVisitor: public StackObj {
 131  public:
 132   virtual void visit(Value* v) = 0;
 133 };
 134 
 135 
 136 // Some array and list classes
 137 typedef GrowableArray&lt;BlockBegin*&gt; BlockBeginArray;
 138 
 139 class BlockList: public GrowableArray&lt;BlockBegin*&gt; {
 140  public:
 141   BlockList(): GrowableArray&lt;BlockBegin*&gt;() {}
 142   BlockList(const int size): GrowableArray&lt;BlockBegin*&gt;(size) {}
 143   BlockList(const int size, BlockBegin* init): GrowableArray&lt;BlockBegin*&gt;(size, size, init) {}
 144 
 145   void iterate_forward(BlockClosure* closure);
 146   void iterate_backward(BlockClosure* closure);
 147   void blocks_do(void f(BlockBegin*));
 148   void values_do(ValueVisitor* f);
 149   void print(bool cfg_only = false, bool live_only = false) PRODUCT_RETURN;
 150 };
 151 
 152 
 153 // InstructionVisitors provide type-based dispatch for instructions.
 154 // For each concrete Instruction class X, a virtual function do_X is
 155 // provided. Functionality that needs to be implemented for all classes
 156 // (e.g., printing, code generation) is factored out into a specialised
 157 // visitor instead of added to the Instruction classes itself.
 158 
 159 class InstructionVisitor: public StackObj {
 160  public:
 161   virtual void do_Phi            (Phi*             x) = 0;
 162   virtual void do_Local          (Local*           x) = 0;
 163   virtual void do_Constant       (Constant*        x) = 0;
 164   virtual void do_LoadField      (LoadField*       x) = 0;
 165   virtual void do_StoreField     (StoreField*      x) = 0;
 166   virtual void do_ArrayLength    (ArrayLength*     x) = 0;
 167   virtual void do_LoadIndexed    (LoadIndexed*     x) = 0;
 168   virtual void do_StoreIndexed   (StoreIndexed*    x) = 0;
 169   virtual void do_NegateOp       (NegateOp*        x) = 0;
 170   virtual void do_ArithmeticOp   (ArithmeticOp*    x) = 0;
 171   virtual void do_ShiftOp        (ShiftOp*         x) = 0;
 172   virtual void do_LogicOp        (LogicOp*         x) = 0;
 173   virtual void do_CompareOp      (CompareOp*       x) = 0;
 174   virtual void do_IfOp           (IfOp*            x) = 0;
 175   virtual void do_Convert        (Convert*         x) = 0;
 176   virtual void do_NullCheck      (NullCheck*       x) = 0;
 177   virtual void do_TypeCast       (TypeCast*        x) = 0;
 178   virtual void do_Invoke         (Invoke*          x) = 0;
 179   virtual void do_NewInstance    (NewInstance*     x) = 0;
 180   virtual void do_NewTypeArray   (NewTypeArray*    x) = 0;
 181   virtual void do_NewObjectArray (NewObjectArray*  x) = 0;
 182   virtual void do_NewMultiArray  (NewMultiArray*   x) = 0;
 183   virtual void do_CheckCast      (CheckCast*       x) = 0;
 184   virtual void do_InstanceOf     (InstanceOf*      x) = 0;
 185   virtual void do_MonitorEnter   (MonitorEnter*    x) = 0;
 186   virtual void do_MonitorExit    (MonitorExit*     x) = 0;
 187   virtual void do_Intrinsic      (Intrinsic*       x) = 0;
 188   virtual void do_BlockBegin     (BlockBegin*      x) = 0;
 189   virtual void do_Goto           (Goto*            x) = 0;
 190   virtual void do_If             (If*              x) = 0;
 191   virtual void do_IfInstanceOf   (IfInstanceOf*    x) = 0;
 192   virtual void do_TableSwitch    (TableSwitch*     x) = 0;
 193   virtual void do_LookupSwitch   (LookupSwitch*    x) = 0;
 194   virtual void do_Return         (Return*          x) = 0;
 195   virtual void do_Throw          (Throw*           x) = 0;
 196   virtual void do_Base           (Base*            x) = 0;
 197   virtual void do_OsrEntry       (OsrEntry*        x) = 0;
 198   virtual void do_ExceptionObject(ExceptionObject* x) = 0;
 199   virtual void do_RoundFP        (RoundFP*         x) = 0;
 200   virtual void do_UnsafeGetRaw   (UnsafeGetRaw*    x) = 0;
 201   virtual void do_UnsafePutRaw   (UnsafePutRaw*    x) = 0;
 202   virtual void do_UnsafeGetObject(UnsafeGetObject* x) = 0;
 203   virtual void do_UnsafePutObject(UnsafePutObject* x) = 0;
 204   virtual void do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) = 0;
 205   virtual void do_ProfileCall    (ProfileCall*     x) = 0;
 206   virtual void do_ProfileReturnType (ProfileReturnType*  x) = 0;
 207   virtual void do_ProfileInvoke  (ProfileInvoke*   x) = 0;
 208   virtual void do_RuntimeCall    (RuntimeCall*     x) = 0;
 209   virtual void do_MemBar         (MemBar*          x) = 0;
 210   virtual void do_RangeCheckPredicate(RangeCheckPredicate* x) = 0;
 211 #ifdef ASSERT
 212   virtual void do_Assert         (Assert*          x) = 0;
 213 #endif
 214 };
 215 
 216 
 217 // Hashing support
 218 //
 219 // Note: This hash functions affect the performance
 220 //       of ValueMap - make changes carefully!
 221 
 222 #define HASH1(x1            )                    ((intx)(x1))
 223 #define HASH2(x1, x2        )                    ((HASH1(x1        ) &lt;&lt; 7) ^ HASH1(x2))
 224 #define HASH3(x1, x2, x3    )                    ((HASH2(x1, x2    ) &lt;&lt; 7) ^ HASH1(x3))
 225 #define HASH4(x1, x2, x3, x4)                    ((HASH3(x1, x2, x3) &lt;&lt; 7) ^ HASH1(x4))
 226 
 227 
 228 // The following macros are used to implement instruction-specific hashing.
 229 // By default, each instruction implements hash() and is_equal(Value), used
 230 // for value numbering/common subexpression elimination. The default imple-
 231 // mentation disables value numbering. Each instruction which can be value-
 232 // numbered, should define corresponding hash() and is_equal(Value) functions
 233 // via the macros below. The f arguments specify all the values/op codes, etc.
 234 // that need to be identical for two instructions to be identical.
 235 //
 236 // Note: The default implementation of hash() returns 0 in order to indicate
 237 //       that the instruction should not be considered for value numbering.
 238 //       The currently used hash functions do not guarantee that never a 0
 239 //       is produced. While this is still correct, it may be a performance
 240 //       bug (no value numbering for that node). However, this situation is
 241 //       so unlikely, that we are not going to handle it specially.
 242 
 243 #define HASHING1(class_name, enabled, f1)             \
 244   virtual intx hash() const {                         \
 245     return (enabled) ? HASH2(name(), f1) : 0;         \
 246   }                                                   \
 247   virtual bool is_equal(Value v) const {              \
 248     if (!(enabled)  ) return false;                   \
 249     class_name* _v = v-&gt;as_##class_name();            \
 250     if (_v == NULL  ) return false;                   \
 251     if (f1 != _v-&gt;f1) return false;                   \
 252     return true;                                      \
 253   }                                                   \
 254 
 255 
 256 #define HASHING2(class_name, enabled, f1, f2)         \
 257   virtual intx hash() const {                         \
 258     return (enabled) ? HASH3(name(), f1, f2) : 0;     \
 259   }                                                   \
 260   virtual bool is_equal(Value v) const {              \
 261     if (!(enabled)  ) return false;                   \
 262     class_name* _v = v-&gt;as_##class_name();            \
 263     if (_v == NULL  ) return false;                   \
 264     if (f1 != _v-&gt;f1) return false;                   \
 265     if (f2 != _v-&gt;f2) return false;                   \
 266     return true;                                      \
 267   }                                                   \
 268 
 269 
 270 #define HASHING3(class_name, enabled, f1, f2, f3)     \
 271   virtual intx hash() const {                         \
 272     return (enabled) ? HASH4(name(), f1, f2, f3) : 0; \
 273   }                                                   \
 274   virtual bool is_equal(Value v) const {              \
 275     if (!(enabled)  ) return false;                   \
 276     class_name* _v = v-&gt;as_##class_name();            \
 277     if (_v == NULL  ) return false;                   \
 278     if (f1 != _v-&gt;f1) return false;                   \
 279     if (f2 != _v-&gt;f2) return false;                   \
 280     if (f3 != _v-&gt;f3) return false;                   \
 281     return true;                                      \
 282   }                                                   \
 283 
 284 
 285 // The mother of all instructions...
 286 
 287 class Instruction: public CompilationResourceObj {
 288  private:
 289   int          _id;                              // the unique instruction id
 290 #ifndef PRODUCT
 291   int          _printable_bci;                   // the bci of the instruction for printing
 292 #endif
 293   int          _use_count;                       // the number of instructions refering to this value (w/o prev/next); only roots can have use count = 0 or &gt; 1
 294   int          _pin_state;                       // set of PinReason describing the reason for pinning
 295   ValueType*   _type;                            // the instruction value type
 296   Instruction* _next;                            // the next instruction if any (NULL for BlockEnd instructions)
 297   Instruction* _subst;                           // the substitution instruction if any
 298   LIR_Opr      _operand;                         // LIR specific information
 299   unsigned int _flags;                           // Flag bits
 300 
 301   ValueStack*  _state_before;                    // Copy of state with input operands still on stack (or NULL)
 302   ValueStack*  _exception_state;                 // Copy of state for exception handling
 303   XHandlers*   _exception_handlers;              // Flat list of exception handlers covering this instruction
 304 
 305   friend class UseCountComputer;
 306   friend class BlockBegin;
 307 
 308   void update_exception_state(ValueStack* state);
 309 
 310  protected:
 311   BlockBegin*  _block;                           // Block that contains this instruction
 312 
 313   void set_type(ValueType* type) {
 314     assert(type != NULL, &quot;type must exist&quot;);
 315     _type = type;
 316   }
 317 
 318   // Helper class to keep track of which arguments need a null check
 319   class ArgsNonNullState {
 320   private:
 321     int _nonnull_state; // mask identifying which args are nonnull
 322   public:
 323     ArgsNonNullState()
 324       : _nonnull_state(AllBits) {}
 325 
 326     // Does argument number i needs a null check?
 327     bool arg_needs_null_check(int i) const {
 328       // No data is kept for arguments starting at position 33 so
 329       // conservatively assume that they need a null check.
 330       if (i &gt;= 0 &amp;&amp; i &lt; (int)sizeof(_nonnull_state) * BitsPerByte) {
 331         return is_set_nth_bit(_nonnull_state, i);
 332       }
 333       return true;
 334     }
 335 
 336     // Set whether argument number i needs a null check or not
 337     void set_arg_needs_null_check(int i, bool check) {
 338       if (i &gt;= 0 &amp;&amp; i &lt; (int)sizeof(_nonnull_state) * BitsPerByte) {
 339         if (check) {
 340           _nonnull_state |= nth_bit(i);
 341         } else {
 342           _nonnull_state &amp;= ~(nth_bit(i));
 343         }
 344       }
 345     }
 346   };
 347 
 348  public:
 349   void* operator new(size_t size) throw() {
 350     Compilation* c = Compilation::current();
 351     void* res = c-&gt;arena()-&gt;Amalloc(size);
 352     ((Instruction*)res)-&gt;_id = c-&gt;get_next_id();
 353     return res;
 354   }
 355 
 356   static const int no_bci = -99;
 357 
 358   enum InstructionFlag {
 359     NeedsNullCheckFlag = 0,
 360     CanTrapFlag,
 361     DirectCompareFlag,
 362     IsEliminatedFlag,
 363     IsSafepointFlag,
 364     IsStaticFlag,
 365     IsStrictfpFlag,
 366     NeedsStoreCheckFlag,
 367     NeedsWriteBarrierFlag,
 368     PreservesStateFlag,
 369     TargetIsFinalFlag,
 370     TargetIsLoadedFlag,
 371     TargetIsStrictfpFlag,
 372     UnorderedIsTrueFlag,
 373     NeedsPatchingFlag,
 374     ThrowIncompatibleClassChangeErrorFlag,
 375     InvokeSpecialReceiverCheckFlag,
 376     ProfileMDOFlag,
 377     IsLinkedInBlockFlag,
 378     NeedsRangeCheckFlag,
 379     InWorkListFlag,
 380     DeoptimizeOnException,
 381     InstructionLastFlag
 382   };
 383 
 384  public:
 385   bool check_flag(InstructionFlag id) const      { return (_flags &amp; (1 &lt;&lt; id)) != 0;    }
 386   void set_flag(InstructionFlag id, bool f)      { _flags = f ? (_flags | (1 &lt;&lt; id)) : (_flags &amp; ~(1 &lt;&lt; id)); };
 387 
 388   // &#39;globally&#39; used condition values
 389   enum Condition {
 390     eql, neq, lss, leq, gtr, geq, aeq, beq
 391   };
 392 
 393   // Instructions may be pinned for many reasons and under certain conditions
 394   // with enough knowledge it&#39;s possible to safely unpin them.
 395   enum PinReason {
 396       PinUnknown           = 1 &lt;&lt; 0
 397     , PinExplicitNullCheck = 1 &lt;&lt; 3
 398     , PinStackForStateSplit= 1 &lt;&lt; 12
 399     , PinStateSplitConstructor= 1 &lt;&lt; 13
 400     , PinGlobalValueNumbering= 1 &lt;&lt; 14
 401   };
 402 
 403   static Condition mirror(Condition cond);
 404   static Condition negate(Condition cond);
 405 
 406   // initialization
 407   static int number_of_instructions() {
 408     return Compilation::current()-&gt;number_of_instructions();
 409   }
 410 
 411   // creation
 412   Instruction(ValueType* type, ValueStack* state_before = NULL, bool type_is_constant = false)
 413   :
 414 #ifndef PRODUCT
 415   _printable_bci(-99),
 416 #endif
 417     _use_count(0)
 418   , _pin_state(0)
 419   , _type(type)
 420   , _next(NULL)
 421   , _subst(NULL)
 422   , _operand(LIR_OprFact::illegalOpr)
 423   , _flags(0)
 424   , _state_before(state_before)
 425   , _exception_handlers(NULL)
 426   , _block(NULL)
 427   {
 428     check_state(state_before);
 429     assert(type != NULL &amp;&amp; (!type-&gt;is_constant() || type_is_constant), &quot;type must exist&quot;);
 430     update_exception_state(_state_before);
 431   }
 432 
 433   // accessors
 434   int id() const                                 { return _id; }
 435 #ifndef PRODUCT
 436   bool has_printable_bci() const                 { return _printable_bci != -99; }
 437   int printable_bci() const                      { assert(has_printable_bci(), &quot;_printable_bci should have been set&quot;); return _printable_bci; }
 438   void set_printable_bci(int bci)                { _printable_bci = bci; }
 439 #endif
 440   int dominator_depth();
 441   int use_count() const                          { return _use_count; }
 442   int pin_state() const                          { return _pin_state; }
 443   bool is_pinned() const                         { return _pin_state != 0 || PinAllInstructions; }
 444   ValueType* type() const                        { return _type; }
 445   BlockBegin *block() const                      { return _block; }
 446   Instruction* prev();                           // use carefully, expensive operation
 447   Instruction* next() const                      { return _next; }
 448   bool has_subst() const                         { return _subst != NULL; }
 449   Instruction* subst()                           { return _subst == NULL ? this : _subst-&gt;subst(); }
 450   LIR_Opr operand() const                        { return _operand; }
 451 
 452   void set_needs_null_check(bool f)              { set_flag(NeedsNullCheckFlag, f); }
 453   bool needs_null_check() const                  { return check_flag(NeedsNullCheckFlag); }
 454   bool is_linked() const                         { return check_flag(IsLinkedInBlockFlag); }
 455   bool can_be_linked()                           { return as_Local() == NULL &amp;&amp; as_Phi() == NULL; }
 456 
 457   bool is_null_obj()                             { return as_Constant() != NULL &amp;&amp; type()-&gt;as_ObjectType()-&gt;constant_value()-&gt;is_null_object(); }
 458 
 459   bool has_uses() const                          { return use_count() &gt; 0; }
 460   ValueStack* state_before() const               { return _state_before; }
 461   ValueStack* exception_state() const            { return _exception_state; }
 462   virtual bool needs_exception_state() const     { return true; }
 463   XHandlers* exception_handlers() const          { return _exception_handlers; }
 464 
 465   // manipulation
 466   void pin(PinReason reason)                     { _pin_state |= reason; }
 467   void pin()                                     { _pin_state |= PinUnknown; }
 468   // DANGEROUS: only used by EliminateStores
 469   void unpin(PinReason reason)                   { assert((reason &amp; PinUnknown) == 0, &quot;can&#39;t unpin unknown state&quot;); _pin_state &amp;= ~reason; }
 470 
 471   Instruction* set_next(Instruction* next) {
 472     assert(next-&gt;has_printable_bci(), &quot;_printable_bci should have been set&quot;);
 473     assert(next != NULL, &quot;must not be NULL&quot;);
 474     assert(as_BlockEnd() == NULL, &quot;BlockEnd instructions must have no next&quot;);
 475     assert(next-&gt;can_be_linked(), &quot;shouldn&#39;t link these instructions into list&quot;);
 476 
 477     BlockBegin *block = this-&gt;block();
 478     next-&gt;_block = block;
 479 
 480     next-&gt;set_flag(Instruction::IsLinkedInBlockFlag, true);
 481     _next = next;
 482     return next;
 483   }
 484 
 485   Instruction* set_next(Instruction* next, int bci) {
 486 #ifndef PRODUCT
 487     next-&gt;set_printable_bci(bci);
 488 #endif
 489     return set_next(next);
 490   }
 491 
 492   // when blocks are merged
 493   void fixup_block_pointers() {
 494     Instruction *cur = next()-&gt;next(); // next()&#39;s block is set in set_next
 495     while (cur &amp;&amp; cur-&gt;_block != block()) {
 496       cur-&gt;_block = block();
 497       cur = cur-&gt;next();
 498     }
 499   }
 500 
 501   Instruction *insert_after(Instruction *i) {
 502     Instruction* n = _next;
 503     set_next(i);
 504     i-&gt;set_next(n);
 505     return _next;
 506   }
 507 
 508   Instruction *insert_after_same_bci(Instruction *i) {
 509 #ifndef PRODUCT
 510     i-&gt;set_printable_bci(printable_bci());
 511 #endif
 512     return insert_after(i);
 513   }
 514 
 515   void set_subst(Instruction* subst)             {
 516     assert(subst == NULL ||
 517            type()-&gt;base() == subst-&gt;type()-&gt;base() ||
 518            subst-&gt;type()-&gt;base() == illegalType, &quot;type can&#39;t change&quot;);
 519     _subst = subst;
 520   }
 521   void set_exception_handlers(XHandlers *xhandlers) { _exception_handlers = xhandlers; }
 522   void set_exception_state(ValueStack* s)        { check_state(s); _exception_state = s; }
 523   void set_state_before(ValueStack* s)           { check_state(s); _state_before = s; }
 524 
 525   // machine-specifics
 526   void set_operand(LIR_Opr operand)              { assert(operand != LIR_OprFact::illegalOpr, &quot;operand must exist&quot;); _operand = operand; }
 527   void clear_operand()                           { _operand = LIR_OprFact::illegalOpr; }
 528 
 529   // generic
 530   virtual Instruction*      as_Instruction()     { return this; } // to satisfy HASHING1 macro
 531   virtual Phi*              as_Phi()             { return NULL; }
 532   virtual Local*            as_Local()           { return NULL; }
 533   virtual Constant*         as_Constant()        { return NULL; }
 534   virtual AccessField*      as_AccessField()     { return NULL; }
 535   virtual LoadField*        as_LoadField()       { return NULL; }
 536   virtual StoreField*       as_StoreField()      { return NULL; }
 537   virtual AccessArray*      as_AccessArray()     { return NULL; }
 538   virtual ArrayLength*      as_ArrayLength()     { return NULL; }
 539   virtual AccessIndexed*    as_AccessIndexed()   { return NULL; }
 540   virtual LoadIndexed*      as_LoadIndexed()     { return NULL; }
 541   virtual StoreIndexed*     as_StoreIndexed()    { return NULL; }
 542   virtual NegateOp*         as_NegateOp()        { return NULL; }
 543   virtual Op2*              as_Op2()             { return NULL; }
 544   virtual ArithmeticOp*     as_ArithmeticOp()    { return NULL; }
 545   virtual ShiftOp*          as_ShiftOp()         { return NULL; }
 546   virtual LogicOp*          as_LogicOp()         { return NULL; }
 547   virtual CompareOp*        as_CompareOp()       { return NULL; }
 548   virtual IfOp*             as_IfOp()            { return NULL; }
 549   virtual Convert*          as_Convert()         { return NULL; }
 550   virtual NullCheck*        as_NullCheck()       { return NULL; }
 551   virtual OsrEntry*         as_OsrEntry()        { return NULL; }
 552   virtual StateSplit*       as_StateSplit()      { return NULL; }
 553   virtual Invoke*           as_Invoke()          { return NULL; }
 554   virtual NewInstance*      as_NewInstance()     { return NULL; }
 555   virtual NewArray*         as_NewArray()        { return NULL; }
 556   virtual NewTypeArray*     as_NewTypeArray()    { return NULL; }
 557   virtual NewObjectArray*   as_NewObjectArray()  { return NULL; }
 558   virtual NewMultiArray*    as_NewMultiArray()   { return NULL; }
 559   virtual TypeCheck*        as_TypeCheck()       { return NULL; }
 560   virtual CheckCast*        as_CheckCast()       { return NULL; }
 561   virtual InstanceOf*       as_InstanceOf()      { return NULL; }
 562   virtual TypeCast*         as_TypeCast()        { return NULL; }
 563   virtual AccessMonitor*    as_AccessMonitor()   { return NULL; }
 564   virtual MonitorEnter*     as_MonitorEnter()    { return NULL; }
 565   virtual MonitorExit*      as_MonitorExit()     { return NULL; }
 566   virtual Intrinsic*        as_Intrinsic()       { return NULL; }
 567   virtual BlockBegin*       as_BlockBegin()      { return NULL; }
 568   virtual BlockEnd*         as_BlockEnd()        { return NULL; }
 569   virtual Goto*             as_Goto()            { return NULL; }
 570   virtual If*               as_If()              { return NULL; }
 571   virtual IfInstanceOf*     as_IfInstanceOf()    { return NULL; }
 572   virtual TableSwitch*      as_TableSwitch()     { return NULL; }
 573   virtual LookupSwitch*     as_LookupSwitch()    { return NULL; }
 574   virtual Return*           as_Return()          { return NULL; }
 575   virtual Throw*            as_Throw()           { return NULL; }
 576   virtual Base*             as_Base()            { return NULL; }
 577   virtual RoundFP*          as_RoundFP()         { return NULL; }
 578   virtual ExceptionObject*  as_ExceptionObject() { return NULL; }
 579   virtual UnsafeOp*         as_UnsafeOp()        { return NULL; }
 580   virtual ProfileInvoke*    as_ProfileInvoke()   { return NULL; }
 581   virtual RangeCheckPredicate* as_RangeCheckPredicate() { return NULL; }
 582 
 583 #ifdef ASSERT
 584   virtual Assert*           as_Assert()          { return NULL; }
 585 #endif
 586 
 587   virtual void visit(InstructionVisitor* v)      = 0;
 588 
 589   virtual bool can_trap() const                  { return false; }
 590 
 591   virtual void input_values_do(ValueVisitor* f)   = 0;
 592   virtual void state_values_do(ValueVisitor* f);
 593   virtual void other_values_do(ValueVisitor* f)   { /* usually no other - override on demand */ }
 594           void       values_do(ValueVisitor* f)   { input_values_do(f); state_values_do(f); other_values_do(f); }
 595 
 596   virtual ciType* exact_type() const;
 597   virtual ciType* declared_type() const          { return NULL; }
 598 
 599   // hashing
 600   virtual const char* name() const               = 0;
 601   HASHING1(Instruction, false, id())             // hashing disabled by default
 602 
 603   // debugging
 604   static void check_state(ValueStack* state)     PRODUCT_RETURN;
 605   void print()                                   PRODUCT_RETURN;
 606   void print_line()                              PRODUCT_RETURN;
 607   void print(InstructionPrinter&amp; ip)             PRODUCT_RETURN;
 608 };
 609 
 610 
 611 // The following macros are used to define base (i.e., non-leaf)
 612 // and leaf instruction classes. They define class-name related
 613 // generic functionality in one place.
 614 
 615 #define BASE(class_name, super_class_name)       \
 616   class class_name: public super_class_name {    \
 617    public:                                       \
 618     virtual class_name* as_##class_name()        { return this; }              \
 619 
 620 
 621 #define LEAF(class_name, super_class_name)       \
 622   BASE(class_name, super_class_name)             \
 623    public:                                       \
 624     virtual const char* name() const             { return #class_name; }       \
 625     virtual void visit(InstructionVisitor* v)    { v-&gt;do_##class_name(this); } \
 626 
 627 
 628 // Debugging support
 629 
 630 
 631 #ifdef ASSERT
 632 class AssertValues: public ValueVisitor {
 633   void visit(Value* x)             { assert((*x) != NULL, &quot;value must exist&quot;); }
 634 };
 635   #define ASSERT_VALUES                          { AssertValues assert_value; values_do(&amp;assert_value); }
 636 #else
 637   #define ASSERT_VALUES
 638 #endif // ASSERT
 639 
 640 
 641 // A Phi is a phi function in the sense of SSA form. It stands for
 642 // the value of a local variable at the beginning of a join block.
 643 // A Phi consists of n operands, one for every incoming branch.
 644 
 645 LEAF(Phi, Instruction)
 646  private:
 647   int         _pf_flags; // the flags of the phi function
 648   int         _index;    // to value on operand stack (index &lt; 0) or to local
 649  public:
 650   // creation
 651   Phi(ValueType* type, BlockBegin* b, int index)
 652   : Instruction(type-&gt;base())
 653   , _pf_flags(0)
 654   , _index(index)
 655   {
 656     _block = b;
 657     NOT_PRODUCT(set_printable_bci(Value(b)-&gt;printable_bci()));
 658     if (type-&gt;is_illegal()) {
 659       make_illegal();
 660     }
 661   }
 662 
 663   // flags
 664   enum Flag {
 665     no_flag         = 0,
 666     visited         = 1 &lt;&lt; 0,
 667     cannot_simplify = 1 &lt;&lt; 1
 668   };
 669 
 670   // accessors
 671   bool  is_local() const          { return _index &gt;= 0; }
 672   bool  is_on_stack() const       { return !is_local(); }
 673   int   local_index() const       { assert(is_local(), &quot;&quot;); return _index; }
 674   int   stack_index() const       { assert(is_on_stack(), &quot;&quot;); return -(_index+1); }
 675 
 676   Value operand_at(int i) const;
 677   int   operand_count() const;
 678 
 679   void   set(Flag f)              { _pf_flags |=  f; }
 680   void   clear(Flag f)            { _pf_flags &amp;= ~f; }
 681   bool   is_set(Flag f) const     { return (_pf_flags &amp; f) != 0; }
 682 
 683   // Invalidates phis corresponding to merges of locals of two different types
 684   // (these should never be referenced, otherwise the bytecodes are illegal)
 685   void   make_illegal() {
 686     set(cannot_simplify);
 687     set_type(illegalType);
 688   }
 689 
 690   bool is_illegal() const {
 691     return type()-&gt;is_illegal();
 692   }
 693 
 694   // generic
 695   virtual void input_values_do(ValueVisitor* f) {
 696   }
 697 };
 698 
 699 
 700 // A local is a placeholder for an incoming argument to a function call.
 701 LEAF(Local, Instruction)
 702  private:
 703   int      _java_index;                          // the local index within the method to which the local belongs
 704   bool     _is_receiver;                         // if local variable holds the receiver: &quot;this&quot; for non-static methods
 705   ciType*  _declared_type;
 706  public:
 707   // creation
 708   Local(ciType* declared, ValueType* type, int index, bool receiver)
 709     : Instruction(type)
 710     , _java_index(index)
 711     , _is_receiver(receiver)
 712     , _declared_type(declared)
 713   {
 714     NOT_PRODUCT(set_printable_bci(-1));
 715   }
 716 
 717   // accessors
 718   int java_index() const                         { return _java_index; }
 719   bool is_receiver() const                       { return _is_receiver; }
 720 
 721   virtual ciType* declared_type() const          { return _declared_type; }
 722 
 723   // generic
 724   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
 725 };
 726 
 727 
 728 LEAF(Constant, Instruction)
 729  public:
 730   // creation
 731   Constant(ValueType* type):
 732       Instruction(type, NULL, /*type_is_constant*/ true)
 733   {
 734     assert(type-&gt;is_constant(), &quot;must be a constant&quot;);
 735   }
 736 
 737   Constant(ValueType* type, ValueStack* state_before):
 738     Instruction(type, state_before, /*type_is_constant*/ true)
 739   {
 740     assert(state_before != NULL, &quot;only used for constants which need patching&quot;);
 741     assert(type-&gt;is_constant(), &quot;must be a constant&quot;);
 742     // since it&#39;s patching it needs to be pinned
 743     pin();
 744   }
 745 
 746   // generic
 747   virtual bool can_trap() const                  { return state_before() != NULL; }
 748   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
 749 
 750   virtual intx hash() const;
 751   virtual bool is_equal(Value v) const;
 752 
 753   virtual ciType* exact_type() const;
 754 
 755   enum CompareResult { not_comparable = -1, cond_false, cond_true };
 756 
 757   virtual CompareResult compare(Instruction::Condition condition, Value right) const;
 758   BlockBegin* compare(Instruction::Condition cond, Value right,
 759                       BlockBegin* true_sux, BlockBegin* false_sux) const {
 760     switch (compare(cond, right)) {
 761     case not_comparable:
 762       return NULL;
 763     case cond_false:
 764       return false_sux;
 765     case cond_true:
 766       return true_sux;
 767     default:
 768       ShouldNotReachHere();
 769       return NULL;
 770     }
 771   }
 772 };
 773 
 774 
 775 BASE(AccessField, Instruction)
 776  private:
 777   Value       _obj;
 778   int         _offset;
 779   ciField*    _field;
 780   NullCheck*  _explicit_null_check;              // For explicit null check elimination
 781 
 782  public:
 783   // creation
 784   AccessField(Value obj, int offset, ciField* field, bool is_static,
 785               ValueStack* state_before, bool needs_patching)
 786   : Instruction(as_ValueType(field-&gt;type()-&gt;basic_type()), state_before)
 787   , _obj(obj)
 788   , _offset(offset)
 789   , _field(field)
 790   , _explicit_null_check(NULL)
 791   {
 792     set_needs_null_check(!is_static);
 793     set_flag(IsStaticFlag, is_static);
 794     set_flag(NeedsPatchingFlag, needs_patching);
 795     ASSERT_VALUES
 796     // pin of all instructions with memory access
 797     pin();
 798   }
 799 
 800   // accessors
 801   Value obj() const                              { return _obj; }
 802   int offset() const                             { return _offset; }
 803   ciField* field() const                         { return _field; }
 804   BasicType field_type() const                   { return _field-&gt;type()-&gt;basic_type(); }
 805   bool is_static() const                         { return check_flag(IsStaticFlag); }
 806   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
 807   bool needs_patching() const                    { return check_flag(NeedsPatchingFlag); }
 808 
 809   // Unresolved getstatic and putstatic can cause initialization.
 810   // Technically it occurs at the Constant that materializes the base
 811   // of the static fields but it&#39;s simpler to model it here.
 812   bool is_init_point() const                     { return is_static() &amp;&amp; (needs_patching() || !_field-&gt;holder()-&gt;is_initialized()); }
 813 
 814   // manipulation
 815 
 816   // Under certain circumstances, if a previous NullCheck instruction
 817   // proved the target object non-null, we can eliminate the explicit
 818   // null check and do an implicit one, simply specifying the debug
 819   // information from the NullCheck. This field should only be consulted
 820   // if needs_null_check() is true.
 821   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
 822 
 823   // generic
 824   virtual bool can_trap() const                  { return needs_null_check() || needs_patching(); }
 825   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_obj); }
 826 };
 827 
 828 
 829 LEAF(LoadField, AccessField)
 830  public:
 831   // creation
 832   LoadField(Value obj, int offset, ciField* field, bool is_static,
 833             ValueStack* state_before, bool needs_patching)
 834   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
 835   {}
 836 
 837   ciType* declared_type() const;
 838 
 839   // generic; cannot be eliminated if needs patching or if volatile.
 840   HASHING3(LoadField, !needs_patching() &amp;&amp; !field()-&gt;is_volatile(), obj()-&gt;subst(), offset(), declared_type())
 841 };
 842 
 843 
 844 LEAF(StoreField, AccessField)
 845  private:
 846   Value _value;
 847 
 848  public:
 849   // creation
 850   StoreField(Value obj, int offset, ciField* field, Value value, bool is_static,
 851              ValueStack* state_before, bool needs_patching)
 852   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
 853   , _value(value)
 854   {
 855     set_flag(NeedsWriteBarrierFlag, as_ValueType(field_type())-&gt;is_object());
 856     ASSERT_VALUES
 857     pin();
 858   }
 859 
 860   // accessors
 861   Value value() const                            { return _value; }
 862   bool needs_write_barrier() const               { return check_flag(NeedsWriteBarrierFlag); }
 863 
 864   // generic
 865   virtual void input_values_do(ValueVisitor* f)   { AccessField::input_values_do(f); f-&gt;visit(&amp;_value); }
 866 };
 867 
 868 
 869 BASE(AccessArray, Instruction)
 870  private:
 871   Value       _array;
 872 
 873  public:
 874   // creation
 875   AccessArray(ValueType* type, Value array, ValueStack* state_before)
 876   : Instruction(type, state_before)
 877   , _array(array)
 878   {
 879     set_needs_null_check(true);
 880     ASSERT_VALUES
 881     pin(); // instruction with side effect (null exception or range check throwing)
 882   }
 883 
 884   Value array() const                            { return _array; }
 885 
 886   // generic
 887   virtual bool can_trap() const                  { return needs_null_check(); }
 888   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_array); }
 889 };
 890 
 891 
 892 LEAF(ArrayLength, AccessArray)
 893  private:
 894   NullCheck*  _explicit_null_check;              // For explicit null check elimination
 895 
 896  public:
 897   // creation
 898   ArrayLength(Value array, ValueStack* state_before)
 899   : AccessArray(intType, array, state_before)
 900   , _explicit_null_check(NULL) {}
 901 
 902   // accessors
 903   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
 904 
 905   // setters
 906   // See LoadField::set_explicit_null_check for documentation
 907   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
 908 
 909   // generic
 910   HASHING1(ArrayLength, true, array()-&gt;subst())
 911 };
 912 
 913 
 914 BASE(AccessIndexed, AccessArray)
 915  private:
 916   Value     _index;
 917   Value     _length;
 918   BasicType _elt_type;
 919   bool      _mismatched;
 920 
 921  public:
 922   // creation
 923   AccessIndexed(Value array, Value index, Value length, BasicType elt_type, ValueStack* state_before, bool mismatched)
 924   : AccessArray(as_ValueType(elt_type), array, state_before)
 925   , _index(index)
 926   , _length(length)
 927   , _elt_type(elt_type)
 928   , _mismatched(mismatched)
 929   {
 930     set_flag(Instruction::NeedsRangeCheckFlag, true);
 931     ASSERT_VALUES
 932   }
 933 
 934   // accessors
 935   Value index() const                            { return _index; }
 936   Value length() const                           { return _length; }
 937   BasicType elt_type() const                     { return _elt_type; }
 938   bool mismatched() const                        { return _mismatched; }
 939 
 940   void clear_length()                            { _length = NULL; }
 941   // perform elimination of range checks involving constants
 942   bool compute_needs_range_check();
 943 
 944   // generic
 945   virtual void input_values_do(ValueVisitor* f)   { AccessArray::input_values_do(f); f-&gt;visit(&amp;_index); if (_length != NULL) f-&gt;visit(&amp;_length); }
 946 };
 947 
 948 
 949 LEAF(LoadIndexed, AccessIndexed)
 950  private:
 951   NullCheck*  _explicit_null_check;              // For explicit null check elimination
 952 
 953  public:
 954   // creation
 955   LoadIndexed(Value array, Value index, Value length, BasicType elt_type, ValueStack* state_before, bool mismatched = false)
 956   : AccessIndexed(array, index, length, elt_type, state_before, mismatched)
 957   , _explicit_null_check(NULL) {}
 958 
 959   // accessors
 960   NullCheck* explicit_null_check() const         { return _explicit_null_check; }
 961 
 962   // setters
 963   // See LoadField::set_explicit_null_check for documentation
 964   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
 965 
 966   ciType* exact_type() const;
 967   ciType* declared_type() const;
 968 
 969   // generic;
 970   HASHING3(LoadIndexed, true, type()-&gt;tag(), array()-&gt;subst(), index()-&gt;subst())
 971 };
 972 
 973 
 974 LEAF(StoreIndexed, AccessIndexed)
 975  private:
 976   Value       _value;
 977 
 978   ciMethod* _profiled_method;
 979   int       _profiled_bci;
 980   bool      _check_boolean;
 981 
 982  public:
 983   // creation
 984   StoreIndexed(Value array, Value index, Value length, BasicType elt_type, Value value, ValueStack* state_before,
 985                bool check_boolean, bool mismatched = false)
 986   : AccessIndexed(array, index, length, elt_type, state_before, mismatched)
 987   , _value(value), _profiled_method(NULL), _profiled_bci(0), _check_boolean(check_boolean)
 988   {
 989     set_flag(NeedsWriteBarrierFlag, (as_ValueType(elt_type)-&gt;is_object()));
 990     set_flag(NeedsStoreCheckFlag, (as_ValueType(elt_type)-&gt;is_object()));
 991     ASSERT_VALUES
 992     pin();
 993   }
 994 
 995   // accessors
 996   Value value() const                            { return _value; }
 997   bool needs_write_barrier() const               { return check_flag(NeedsWriteBarrierFlag); }
 998   bool needs_store_check() const                 { return check_flag(NeedsStoreCheckFlag); }
 999   bool check_boolean() const                     { return _check_boolean; }
1000   // Helpers for MethodData* profiling
1001   void set_should_profile(bool value)                { set_flag(ProfileMDOFlag, value); }
1002   void set_profiled_method(ciMethod* method)         { _profiled_method = method;   }
1003   void set_profiled_bci(int bci)                     { _profiled_bci = bci;         }
1004   bool      should_profile() const                   { return check_flag(ProfileMDOFlag); }
1005   ciMethod* profiled_method() const                  { return _profiled_method;     }
1006   int       profiled_bci() const                     { return _profiled_bci;        }
1007   // generic
1008   virtual void input_values_do(ValueVisitor* f)   { AccessIndexed::input_values_do(f); f-&gt;visit(&amp;_value); }
1009 };
1010 
1011 
1012 LEAF(NegateOp, Instruction)
1013  private:
1014   Value _x;
1015 
1016  public:
1017   // creation
1018   NegateOp(Value x) : Instruction(x-&gt;type()-&gt;base()), _x(x) {
1019     ASSERT_VALUES
1020   }
1021 
1022   // accessors
1023   Value x() const                                { return _x; }
1024 
1025   // generic
1026   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_x); }
1027 };
1028 
1029 
1030 BASE(Op2, Instruction)
1031  private:
1032   Bytecodes::Code _op;
1033   Value           _x;
1034   Value           _y;
1035 
1036  public:
1037   // creation
1038   Op2(ValueType* type, Bytecodes::Code op, Value x, Value y, ValueStack* state_before = NULL)
1039   : Instruction(type, state_before)
1040   , _op(op)
1041   , _x(x)
1042   , _y(y)
1043   {
1044     ASSERT_VALUES
1045   }
1046 
1047   // accessors
1048   Bytecodes::Code op() const                     { return _op; }
1049   Value x() const                                { return _x; }
1050   Value y() const                                { return _y; }
1051 
1052   // manipulators
1053   void swap_operands() {
1054     assert(is_commutative(), &quot;operation must be commutative&quot;);
1055     Value t = _x; _x = _y; _y = t;
1056   }
1057 
1058   // generic
1059   virtual bool is_commutative() const            { return false; }
1060   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
1061 };
1062 
1063 
1064 LEAF(ArithmeticOp, Op2)
1065  public:
1066   // creation
1067   ArithmeticOp(Bytecodes::Code op, Value x, Value y, bool is_strictfp, ValueStack* state_before)
1068   : Op2(x-&gt;type()-&gt;meet(y-&gt;type()), op, x, y, state_before)
1069   {
1070     set_flag(IsStrictfpFlag, is_strictfp);
1071     if (can_trap()) pin();
1072   }
1073 
1074   // accessors
1075   bool        is_strictfp() const                { return check_flag(IsStrictfpFlag); }
1076 
1077   // generic
1078   virtual bool is_commutative() const;
1079   virtual bool can_trap() const;
1080   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1081 };
1082 
1083 
1084 LEAF(ShiftOp, Op2)
1085  public:
1086   // creation
1087   ShiftOp(Bytecodes::Code op, Value x, Value s) : Op2(x-&gt;type()-&gt;base(), op, x, s) {}
1088 
1089   // generic
1090   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1091 };
1092 
1093 
1094 LEAF(LogicOp, Op2)
1095  public:
1096   // creation
1097   LogicOp(Bytecodes::Code op, Value x, Value y) : Op2(x-&gt;type()-&gt;meet(y-&gt;type()), op, x, y) {}
1098 
1099   // generic
1100   virtual bool is_commutative() const;
1101   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1102 };
1103 
1104 
1105 LEAF(CompareOp, Op2)
1106  public:
1107   // creation
1108   CompareOp(Bytecodes::Code op, Value x, Value y, ValueStack* state_before)
1109   : Op2(intType, op, x, y, state_before)
1110   {}
1111 
1112   // generic
1113   HASHING3(Op2, true, op(), x()-&gt;subst(), y()-&gt;subst())
1114 };
1115 
1116 
1117 LEAF(IfOp, Op2)
1118  private:
1119   Value _tval;
1120   Value _fval;
1121 
1122  public:
1123   // creation
1124   IfOp(Value x, Condition cond, Value y, Value tval, Value fval)
1125   : Op2(tval-&gt;type()-&gt;meet(fval-&gt;type()), (Bytecodes::Code)cond, x, y)
1126   , _tval(tval)
1127   , _fval(fval)
1128   {
1129     ASSERT_VALUES
1130     assert(tval-&gt;type()-&gt;tag() == fval-&gt;type()-&gt;tag(), &quot;types must match&quot;);
1131   }
1132 
1133   // accessors
1134   virtual bool is_commutative() const;
1135   Bytecodes::Code op() const                     { ShouldNotCallThis(); return Bytecodes::_illegal; }
1136   Condition cond() const                         { return (Condition)Op2::op(); }
1137   Value tval() const                             { return _tval; }
1138   Value fval() const                             { return _fval; }
1139 
1140   // generic
1141   virtual void input_values_do(ValueVisitor* f)   { Op2::input_values_do(f); f-&gt;visit(&amp;_tval); f-&gt;visit(&amp;_fval); }
1142 };
1143 
1144 
1145 LEAF(Convert, Instruction)
1146  private:
1147   Bytecodes::Code _op;
1148   Value           _value;
1149 
1150  public:
1151   // creation
1152   Convert(Bytecodes::Code op, Value value, ValueType* to_type) : Instruction(to_type), _op(op), _value(value) {
1153     ASSERT_VALUES
1154   }
1155 
1156   // accessors
1157   Bytecodes::Code op() const                     { return _op; }
1158   Value value() const                            { return _value; }
1159 
1160   // generic
1161   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_value); }
1162   HASHING2(Convert, true, op(), value()-&gt;subst())
1163 };
1164 
1165 
1166 LEAF(NullCheck, Instruction)
1167  private:
1168   Value       _obj;
1169 
1170  public:
1171   // creation
1172   NullCheck(Value obj, ValueStack* state_before)
1173   : Instruction(obj-&gt;type()-&gt;base(), state_before)
1174   , _obj(obj)
1175   {
1176     ASSERT_VALUES
1177     set_can_trap(true);
1178     assert(_obj-&gt;type()-&gt;is_object(), &quot;null check must be applied to objects only&quot;);
1179     pin(Instruction::PinExplicitNullCheck);
1180   }
1181 
1182   // accessors
1183   Value obj() const                              { return _obj; }
1184 
1185   // setters
1186   void set_can_trap(bool can_trap)               { set_flag(CanTrapFlag, can_trap); }
1187 
1188   // generic
1189   virtual bool can_trap() const                  { return check_flag(CanTrapFlag); /* null-check elimination sets to false */ }
1190   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_obj); }
1191   HASHING1(NullCheck, true, obj()-&gt;subst())
1192 };
1193 
1194 
1195 // This node is supposed to cast the type of another node to a more precise
1196 // declared type.
1197 LEAF(TypeCast, Instruction)
1198  private:
1199   ciType* _declared_type;
1200   Value   _obj;
1201 
1202  public:
1203   // The type of this node is the same type as the object type (and it might be constant).
1204   TypeCast(ciType* type, Value obj, ValueStack* state_before)
1205   : Instruction(obj-&gt;type(), state_before, obj-&gt;type()-&gt;is_constant()),
1206     _declared_type(type),
1207     _obj(obj) {}
1208 
1209   // accessors
1210   ciType* declared_type() const                  { return _declared_type; }
1211   Value   obj() const                            { return _obj; }
1212 
1213   // generic
1214   virtual void input_values_do(ValueVisitor* f)  { f-&gt;visit(&amp;_obj); }
1215 };
1216 
1217 
1218 BASE(StateSplit, Instruction)
1219  private:
1220   ValueStack* _state;
1221 
1222  protected:
1223   static void substitute(BlockList&amp; list, BlockBegin* old_block, BlockBegin* new_block);
1224 
1225  public:
1226   // creation
1227   StateSplit(ValueType* type, ValueStack* state_before = NULL)
1228   : Instruction(type, state_before)
1229   , _state(NULL)
1230   {
1231     pin(PinStateSplitConstructor);
1232   }
1233 
1234   // accessors
1235   ValueStack* state() const                      { return _state; }
1236   IRScope* scope() const;                        // the state&#39;s scope
1237 
1238   // manipulation
1239   void set_state(ValueStack* state)              { assert(_state == NULL, &quot;overwriting existing state&quot;); check_state(state); _state = state; }
1240 
1241   // generic
1242   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
1243   virtual void state_values_do(ValueVisitor* f);
1244 };
1245 
1246 
1247 LEAF(Invoke, StateSplit)
1248  private:
1249   Bytecodes::Code _code;
1250   Value           _recv;
1251   Values*         _args;
1252   BasicTypeList*  _signature;
1253   int             _vtable_index;
1254   ciMethod*       _target;
1255 
1256  public:
1257   // creation
1258   Invoke(Bytecodes::Code code, ValueType* result_type, Value recv, Values* args,
1259          int vtable_index, ciMethod* target, ValueStack* state_before);
1260 
1261   // accessors
1262   Bytecodes::Code code() const                   { return _code; }
1263   Value receiver() const                         { return _recv; }
1264   bool has_receiver() const                      { return receiver() != NULL; }
1265   int number_of_arguments() const                { return _args-&gt;length(); }
1266   Value argument_at(int i) const                 { return _args-&gt;at(i); }
1267   int vtable_index() const                       { return _vtable_index; }
1268   BasicTypeList* signature() const               { return _signature; }
1269   ciMethod* target() const                       { return _target; }
1270 
1271   ciType* declared_type() const;
1272 
1273   // Returns false if target is not loaded
1274   bool target_is_final() const                   { return check_flag(TargetIsFinalFlag); }
1275   bool target_is_loaded() const                  { return check_flag(TargetIsLoadedFlag); }
1276   // Returns false if target is not loaded
1277   bool target_is_strictfp() const                { return check_flag(TargetIsStrictfpFlag); }
1278 
1279   // JSR 292 support
1280   bool is_invokedynamic() const                  { return code() == Bytecodes::_invokedynamic; }
1281   bool is_method_handle_intrinsic() const        { return target()-&gt;is_method_handle_intrinsic(); }
1282 
1283   virtual bool needs_exception_state() const     { return false; }
1284 
1285   // generic
1286   virtual bool can_trap() const                  { return true; }
1287   virtual void input_values_do(ValueVisitor* f) {
1288     StateSplit::input_values_do(f);
1289     if (has_receiver()) f-&gt;visit(&amp;_recv);
1290     for (int i = 0; i &lt; _args-&gt;length(); i++) f-&gt;visit(_args-&gt;adr_at(i));
1291   }
1292   virtual void state_values_do(ValueVisitor *f);
1293 };
1294 
1295 
1296 LEAF(NewInstance, StateSplit)
1297  private:
1298   ciInstanceKlass* _klass;
1299   bool _is_unresolved;
1300 
1301  public:
1302   // creation
1303   NewInstance(ciInstanceKlass* klass, ValueStack* state_before, bool is_unresolved)
1304   : StateSplit(instanceType, state_before)
1305   , _klass(klass), _is_unresolved(is_unresolved)
1306   {}
1307 
1308   // accessors
1309   ciInstanceKlass* klass() const                 { return _klass; }
1310   bool is_unresolved() const                     { return _is_unresolved; }
1311 
1312   virtual bool needs_exception_state() const     { return false; }
1313 
1314   // generic
1315   virtual bool can_trap() const                  { return true; }
1316   ciType* exact_type() const;
1317   ciType* declared_type() const;
1318 };
1319 
1320 
1321 BASE(NewArray, StateSplit)
1322  private:
1323   Value       _length;
1324 
1325  public:
1326   // creation
1327   NewArray(Value length, ValueStack* state_before)
1328   : StateSplit(objectType, state_before)
1329   , _length(length)
1330   {
1331     // Do not ASSERT_VALUES since length is NULL for NewMultiArray
1332   }
1333 
1334   // accessors
1335   Value length() const                           { return _length; }
1336 
1337   virtual bool needs_exception_state() const     { return false; }
1338 
1339   ciType* exact_type() const                     { return NULL; }
1340   ciType* declared_type() const;
1341 
1342   // generic
1343   virtual bool can_trap() const                  { return true; }
1344   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_length); }
1345 };
1346 
1347 
1348 LEAF(NewTypeArray, NewArray)
1349  private:
1350   BasicType _elt_type;
1351 
1352  public:
1353   // creation
1354   NewTypeArray(Value length, BasicType elt_type, ValueStack* state_before)
1355   : NewArray(length, state_before)
1356   , _elt_type(elt_type)
1357   {}
1358 
1359   // accessors
1360   BasicType elt_type() const                     { return _elt_type; }
1361   ciType* exact_type() const;
1362 };
1363 
1364 
1365 LEAF(NewObjectArray, NewArray)
1366  private:
1367   ciKlass* _klass;
1368 
1369  public:
1370   // creation
1371   NewObjectArray(ciKlass* klass, Value length, ValueStack* state_before) : NewArray(length, state_before), _klass(klass) {}
1372 
1373   // accessors
1374   ciKlass* klass() const                         { return _klass; }
1375   ciType* exact_type() const;
1376 };
1377 
1378 
1379 LEAF(NewMultiArray, NewArray)
1380  private:
1381   ciKlass* _klass;
1382   Values*  _dims;
1383 
1384  public:
1385   // creation
1386   NewMultiArray(ciKlass* klass, Values* dims, ValueStack* state_before) : NewArray(NULL, state_before), _klass(klass), _dims(dims) {
1387     ASSERT_VALUES
1388   }
1389 
1390   // accessors
1391   ciKlass* klass() const                         { return _klass; }
1392   Values* dims() const                           { return _dims; }
1393   int rank() const                               { return dims()-&gt;length(); }
1394 
1395   // generic
1396   virtual void input_values_do(ValueVisitor* f) {
1397     // NOTE: we do not call NewArray::input_values_do since &quot;length&quot;
1398     // is meaningless for a multi-dimensional array; passing the
1399     // zeroth element down to NewArray as its length is a bad idea
1400     // since there will be a copy in the &quot;dims&quot; array which doesn&#39;t
1401     // get updated, and the value must not be traversed twice. Was bug
1402     // - kbr 4/10/2001
1403     StateSplit::input_values_do(f);
1404     for (int i = 0; i &lt; _dims-&gt;length(); i++) f-&gt;visit(_dims-&gt;adr_at(i));
1405   }
1406 };
1407 
1408 
1409 BASE(TypeCheck, StateSplit)
1410  private:
1411   ciKlass*    _klass;
1412   Value       _obj;
1413 
1414   ciMethod* _profiled_method;
1415   int       _profiled_bci;
1416 
1417  public:
1418   // creation
1419   TypeCheck(ciKlass* klass, Value obj, ValueType* type, ValueStack* state_before)
1420   : StateSplit(type, state_before), _klass(klass), _obj(obj),
1421     _profiled_method(NULL), _profiled_bci(0) {
1422     ASSERT_VALUES
1423     set_direct_compare(false);
1424   }
1425 
1426   // accessors
1427   ciKlass* klass() const                         { return _klass; }
1428   Value obj() const                              { return _obj; }
1429   bool is_loaded() const                         { return klass() != NULL; }
1430   bool direct_compare() const                    { return check_flag(DirectCompareFlag); }
1431 
1432   // manipulation
1433   void set_direct_compare(bool flag)             { set_flag(DirectCompareFlag, flag); }
1434 
1435   // generic
1436   virtual bool can_trap() const                  { return true; }
1437   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_obj); }
1438 
1439   // Helpers for MethodData* profiling
1440   void set_should_profile(bool value)                { set_flag(ProfileMDOFlag, value); }
1441   void set_profiled_method(ciMethod* method)         { _profiled_method = method;   }
1442   void set_profiled_bci(int bci)                     { _profiled_bci = bci;         }
1443   bool      should_profile() const                   { return check_flag(ProfileMDOFlag); }
1444   ciMethod* profiled_method() const                  { return _profiled_method;     }
1445   int       profiled_bci() const                     { return _profiled_bci;        }
1446 };
1447 
1448 
1449 LEAF(CheckCast, TypeCheck)
1450  public:
1451   // creation
1452   CheckCast(ciKlass* klass, Value obj, ValueStack* state_before)
1453   : TypeCheck(klass, obj, objectType, state_before) {}
1454 
1455   void set_incompatible_class_change_check() {
1456     set_flag(ThrowIncompatibleClassChangeErrorFlag, true);
1457   }
1458   bool is_incompatible_class_change_check() const {
1459     return check_flag(ThrowIncompatibleClassChangeErrorFlag);
1460   }
1461   void set_invokespecial_receiver_check() {
1462     set_flag(InvokeSpecialReceiverCheckFlag, true);
1463   }
1464   bool is_invokespecial_receiver_check() const {
1465     return check_flag(InvokeSpecialReceiverCheckFlag);
1466   }
1467 
1468   virtual bool needs_exception_state() const {
1469     return !is_invokespecial_receiver_check();
1470   }
1471 
1472   ciType* declared_type() const;
1473 };
1474 
1475 
1476 LEAF(InstanceOf, TypeCheck)
1477  public:
1478   // creation
1479   InstanceOf(ciKlass* klass, Value obj, ValueStack* state_before) : TypeCheck(klass, obj, intType, state_before) {}
1480 
1481   virtual bool needs_exception_state() const     { return false; }
1482 };
1483 
1484 
1485 BASE(AccessMonitor, StateSplit)
1486  private:
1487   Value       _obj;
1488   int         _monitor_no;
1489 
1490  public:
1491   // creation
1492   AccessMonitor(Value obj, int monitor_no, ValueStack* state_before = NULL)
1493   : StateSplit(illegalType, state_before)
1494   , _obj(obj)
1495   , _monitor_no(monitor_no)
1496   {
1497     set_needs_null_check(true);
1498     ASSERT_VALUES
1499   }
1500 
1501   // accessors
1502   Value obj() const                              { return _obj; }
1503   int monitor_no() const                         { return _monitor_no; }
1504 
1505   // generic
1506   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_obj); }
1507 };
1508 
1509 
1510 LEAF(MonitorEnter, AccessMonitor)
1511  public:
1512   // creation
1513   MonitorEnter(Value obj, int monitor_no, ValueStack* state_before)
1514   : AccessMonitor(obj, monitor_no, state_before)
1515   {
1516     ASSERT_VALUES
1517   }
1518 
1519   // generic
1520   virtual bool can_trap() const                  { return true; }
1521 };
1522 
1523 
1524 LEAF(MonitorExit, AccessMonitor)
1525  public:
1526   // creation
1527   MonitorExit(Value obj, int monitor_no)
1528   : AccessMonitor(obj, monitor_no, NULL)
1529   {
1530     ASSERT_VALUES
1531   }
1532 };
1533 
1534 
1535 LEAF(Intrinsic, StateSplit)
1536  private:
1537   vmIntrinsics::ID _id;
1538   Values*          _args;
1539   Value            _recv;
1540   ArgsNonNullState _nonnull_state;
1541 
1542  public:
1543   // preserves_state can be set to true for Intrinsics
1544   // which are guaranteed to preserve register state across any slow
1545   // cases; setting it to true does not mean that the Intrinsic can
1546   // not trap, only that if we continue execution in the same basic
1547   // block after the Intrinsic, all of the registers are intact. This
1548   // allows load elimination and common expression elimination to be
1549   // performed across the Intrinsic.  The default value is false.
1550   Intrinsic(ValueType* type,
1551             vmIntrinsics::ID id,
1552             Values* args,
1553             bool has_receiver,
1554             ValueStack* state_before,
1555             bool preserves_state,
1556             bool cantrap = true)
1557   : StateSplit(type, state_before)
1558   , _id(id)
1559   , _args(args)
1560   , _recv(NULL)
1561   {
1562     assert(args != NULL, &quot;args must exist&quot;);
1563     ASSERT_VALUES
1564     set_flag(PreservesStateFlag, preserves_state);
1565     set_flag(CanTrapFlag,        cantrap);
1566     if (has_receiver) {
1567       _recv = argument_at(0);
1568     }
1569     set_needs_null_check(has_receiver);
1570 
1571     // some intrinsics can&#39;t trap, so don&#39;t force them to be pinned
1572     if (!can_trap() &amp;&amp; !vmIntrinsics::should_be_pinned(_id)) {
1573       unpin(PinStateSplitConstructor);
1574     }
1575   }
1576 
1577   // accessors
1578   vmIntrinsics::ID id() const                    { return _id; }
1579   int number_of_arguments() const                { return _args-&gt;length(); }
1580   Value argument_at(int i) const                 { return _args-&gt;at(i); }
1581 
1582   bool has_receiver() const                      { return (_recv != NULL); }
1583   Value receiver() const                         { assert(has_receiver(), &quot;must have receiver&quot;); return _recv; }
1584   bool preserves_state() const                   { return check_flag(PreservesStateFlag); }
1585 
1586   bool arg_needs_null_check(int i) const {
1587     return _nonnull_state.arg_needs_null_check(i);
1588   }
1589 
1590   void set_arg_needs_null_check(int i, bool check) {
1591     _nonnull_state.set_arg_needs_null_check(i, check);
1592   }
1593 
1594   // generic
1595   virtual bool can_trap() const                  { return check_flag(CanTrapFlag); }
1596   virtual void input_values_do(ValueVisitor* f) {
1597     StateSplit::input_values_do(f);
1598     for (int i = 0; i &lt; _args-&gt;length(); i++) f-&gt;visit(_args-&gt;adr_at(i));
1599   }
1600 };
1601 
1602 
1603 class LIR_List;
1604 
1605 LEAF(BlockBegin, StateSplit)
1606  private:
1607   int        _block_id;                          // the unique block id
1608   int        _bci;                               // start-bci of block
1609   int        _depth_first_number;                // number of this block in a depth-first ordering
1610   int        _linear_scan_number;                // number of this block in linear-scan ordering
1611   int        _dominator_depth;
1612   int        _loop_depth;                        // the loop nesting level of this block
1613   int        _loop_index;                        // number of the innermost loop of this block
1614   int        _flags;                             // the flags associated with this block
1615 
1616   // fields used by BlockListBuilder
1617   int            _total_preds;                   // number of predecessors found by BlockListBuilder
1618   ResourceBitMap _stores_to_locals;              // bit is set when a local variable is stored in the block
1619 
1620   // SSA specific fields: (factor out later)
1621   BlockList   _successors;                       // the successors of this block
1622   BlockList   _predecessors;                     // the predecessors of this block
1623   BlockList   _dominates;                        // list of blocks that are dominated by this block
1624   BlockBegin* _dominator;                        // the dominator of this block
1625   // SSA specific ends
1626   BlockEnd*  _end;                               // the last instruction of this block
1627   BlockList  _exception_handlers;                // the exception handlers potentially invoked by this block
1628   ValueStackStack* _exception_states;            // only for xhandler entries: states of all instructions that have an edge to this xhandler
1629   int        _exception_handler_pco;             // if this block is the start of an exception handler,
1630                                                  // this records the PC offset in the assembly code of the
1631                                                  // first instruction in this block
1632   Label      _label;                             // the label associated with this block
1633   LIR_List*  _lir;                               // the low level intermediate representation for this block
1634 
1635   ResourceBitMap _live_in;                       // set of live LIR_Opr registers at entry to this block
1636   ResourceBitMap _live_out;                      // set of live LIR_Opr registers at exit from this block
1637   ResourceBitMap _live_gen;                      // set of registers used before any redefinition in this block
1638   ResourceBitMap _live_kill;                     // set of registers defined in this block
1639 
1640   ResourceBitMap _fpu_register_usage;
1641   intArray*      _fpu_stack_state;               // For x86 FPU code generation with UseLinearScan
1642   int            _first_lir_instruction_id;      // ID of first LIR instruction in this block
1643   int            _last_lir_instruction_id;       // ID of last LIR instruction in this block
1644 
1645   void iterate_preorder (boolArray&amp; mark, BlockClosure* closure);
1646   void iterate_postorder(boolArray&amp; mark, BlockClosure* closure);
1647 
1648   friend class SuxAndWeightAdjuster;
1649 
1650  public:
1651    void* operator new(size_t size) throw() {
1652     Compilation* c = Compilation::current();
1653     void* res = c-&gt;arena()-&gt;Amalloc(size);
1654     ((BlockBegin*)res)-&gt;_id = c-&gt;get_next_id();
1655     ((BlockBegin*)res)-&gt;_block_id = c-&gt;get_next_block_id();
1656     return res;
1657   }
1658 
1659   // initialization/counting
1660   static int  number_of_blocks() {
1661     return Compilation::current()-&gt;number_of_blocks();
1662   }
1663 
1664   // creation
1665   BlockBegin(int bci)
1666   : StateSplit(illegalType)
1667   , _bci(bci)
1668   , _depth_first_number(-1)
1669   , _linear_scan_number(-1)
1670   , _dominator_depth(-1)
1671   , _loop_depth(0)
1672   , _loop_index(-1)
1673   , _flags(0)
1674   , _total_preds(0)
1675   , _stores_to_locals()
1676   , _successors(2)
1677   , _predecessors(2)
1678   , _dominates(2)
1679   , _dominator(NULL)
1680   , _end(NULL)
1681   , _exception_handlers(1)
1682   , _exception_states(NULL)
1683   , _exception_handler_pco(-1)
1684   , _lir(NULL)
1685   , _live_in()
1686   , _live_out()
1687   , _live_gen()
1688   , _live_kill()
1689   , _fpu_register_usage()
1690   , _fpu_stack_state(NULL)
1691   , _first_lir_instruction_id(-1)
1692   , _last_lir_instruction_id(-1)
1693   {
1694     _block = this;
1695 #ifndef PRODUCT
1696     set_printable_bci(bci);
1697 #endif
1698   }
1699 
1700   // accessors
1701   int block_id() const                           { return _block_id; }
1702   int bci() const                                { return _bci; }
1703   BlockList* successors()                        { return &amp;_successors; }
1704   BlockList* dominates()                         { return &amp;_dominates; }
1705   BlockBegin* dominator() const                  { return _dominator; }
1706   int loop_depth() const                         { return _loop_depth; }
1707   int dominator_depth() const                    { return _dominator_depth; }
1708   int depth_first_number() const                 { return _depth_first_number; }
1709   int linear_scan_number() const                 { return _linear_scan_number; }
1710   BlockEnd* end() const                          { return _end; }
1711   Label* label()                                 { return &amp;_label; }
1712   LIR_List* lir() const                          { return _lir; }
1713   int exception_handler_pco() const              { return _exception_handler_pco; }
1714   ResourceBitMap&amp; live_in()                      { return _live_in;        }
1715   ResourceBitMap&amp; live_out()                     { return _live_out;       }
1716   ResourceBitMap&amp; live_gen()                     { return _live_gen;       }
1717   ResourceBitMap&amp; live_kill()                    { return _live_kill;      }
1718   ResourceBitMap&amp; fpu_register_usage()           { return _fpu_register_usage; }
1719   intArray* fpu_stack_state() const              { return _fpu_stack_state;    }
1720   int first_lir_instruction_id() const           { return _first_lir_instruction_id; }
1721   int last_lir_instruction_id() const            { return _last_lir_instruction_id; }
1722   int total_preds() const                        { return _total_preds; }
1723   BitMap&amp; stores_to_locals()                     { return _stores_to_locals; }
1724 
1725   // manipulation
1726   void set_dominator(BlockBegin* dom)            { _dominator = dom; }
1727   void set_loop_depth(int d)                     { _loop_depth = d; }
1728   void set_dominator_depth(int d)                { _dominator_depth = d; }
1729   void set_depth_first_number(int dfn)           { _depth_first_number = dfn; }
1730   void set_linear_scan_number(int lsn)           { _linear_scan_number = lsn; }
1731   void set_end(BlockEnd* end);
1732   void clear_end();
1733   void disconnect_from_graph();
1734   static void disconnect_edge(BlockBegin* from, BlockBegin* to);
1735   BlockBegin* insert_block_between(BlockBegin* sux);
1736   void substitute_sux(BlockBegin* old_sux, BlockBegin* new_sux);
1737   void set_lir(LIR_List* lir)                    { _lir = lir; }
1738   void set_exception_handler_pco(int pco)        { _exception_handler_pco = pco; }
1739   void set_live_in  (const ResourceBitMap&amp; map)  { _live_in = map;   }
1740   void set_live_out (const ResourceBitMap&amp; map)  { _live_out = map;  }
1741   void set_live_gen (const ResourceBitMap&amp; map)  { _live_gen = map;  }
1742   void set_live_kill(const ResourceBitMap&amp; map)  { _live_kill = map; }
1743   void set_fpu_register_usage(const ResourceBitMap&amp; map) { _fpu_register_usage = map; }
1744   void set_fpu_stack_state(intArray* state)      { _fpu_stack_state = state;  }
1745   void set_first_lir_instruction_id(int id)      { _first_lir_instruction_id = id;  }
1746   void set_last_lir_instruction_id(int id)       { _last_lir_instruction_id = id;  }
1747   void increment_total_preds(int n = 1)          { _total_preds += n; }
1748   void init_stores_to_locals(int locals_count)   { _stores_to_locals.initialize(locals_count); }
1749 
1750   // generic
1751   virtual void state_values_do(ValueVisitor* f);
1752 
1753   // successors and predecessors
1754   int number_of_sux() const;
1755   BlockBegin* sux_at(int i) const;
1756   void add_successor(BlockBegin* sux);
1757   void remove_successor(BlockBegin* pred);
1758   bool is_successor(BlockBegin* sux) const       { return _successors.contains(sux); }
1759 
1760   void add_predecessor(BlockBegin* pred);
1761   void remove_predecessor(BlockBegin* pred);
1762   bool is_predecessor(BlockBegin* pred) const    { return _predecessors.contains(pred); }
1763   int number_of_preds() const                    { return _predecessors.length(); }
1764   BlockBegin* pred_at(int i) const               { return _predecessors.at(i); }
1765 
1766   // exception handlers potentially invoked by this block
1767   void add_exception_handler(BlockBegin* b);
1768   bool is_exception_handler(BlockBegin* b) const { return _exception_handlers.contains(b); }
1769   int  number_of_exception_handlers() const      { return _exception_handlers.length(); }
1770   BlockBegin* exception_handler_at(int i) const  { return _exception_handlers.at(i); }
1771 
1772   // states of the instructions that have an edge to this exception handler
1773   int number_of_exception_states()               { assert(is_set(exception_entry_flag), &quot;only for xhandlers&quot;); return _exception_states == NULL ? 0 : _exception_states-&gt;length(); }
1774   ValueStack* exception_state_at(int idx) const  { assert(is_set(exception_entry_flag), &quot;only for xhandlers&quot;); return _exception_states-&gt;at(idx); }
1775   int add_exception_state(ValueStack* state);
1776 
1777   // flags
1778   enum Flag {
1779     no_flag                       = 0,
1780     std_entry_flag                = 1 &lt;&lt; 0,
1781     osr_entry_flag                = 1 &lt;&lt; 1,
1782     exception_entry_flag          = 1 &lt;&lt; 2,
1783     subroutine_entry_flag         = 1 &lt;&lt; 3,
1784     backward_branch_target_flag   = 1 &lt;&lt; 4,
1785     is_on_work_list_flag          = 1 &lt;&lt; 5,
1786     was_visited_flag              = 1 &lt;&lt; 6,
1787     parser_loop_header_flag       = 1 &lt;&lt; 7,  // set by parser to identify blocks where phi functions can not be created on demand
1788     critical_edge_split_flag      = 1 &lt;&lt; 8, // set for all blocks that are introduced when critical edges are split
1789     linear_scan_loop_header_flag  = 1 &lt;&lt; 9, // set during loop-detection for LinearScan
1790     linear_scan_loop_end_flag     = 1 &lt;&lt; 10, // set during loop-detection for LinearScan
1791     donot_eliminate_range_checks  = 1 &lt;&lt; 11  // Should be try to eliminate range checks in this block
1792   };
1793 
1794   void set(Flag f)                               { _flags |= f; }
1795   void clear(Flag f)                             { _flags &amp;= ~f; }
1796   bool is_set(Flag f) const                      { return (_flags &amp; f) != 0; }
1797   bool is_entry_block() const {
1798     const int entry_mask = std_entry_flag | osr_entry_flag | exception_entry_flag;
1799     return (_flags &amp; entry_mask) != 0;
1800   }
1801 
1802   // iteration
1803   void iterate_preorder   (BlockClosure* closure);
1804   void iterate_postorder  (BlockClosure* closure);
1805 
1806   void block_values_do(ValueVisitor* f);
1807 
1808   // loops
1809   void set_loop_index(int ix)                    { _loop_index = ix;        }
1810   int  loop_index() const                        { return _loop_index;      }
1811 
1812   // merging
1813   bool try_merge(ValueStack* state);             // try to merge states at block begin
1814   void merge(ValueStack* state)                  { bool b = try_merge(state); assert(b, &quot;merge failed&quot;); }
1815 
1816   // debugging
1817   void print_block()                             PRODUCT_RETURN;
1818   void print_block(InstructionPrinter&amp; ip, bool live_only = false) PRODUCT_RETURN;
1819 };
1820 
1821 
1822 BASE(BlockEnd, StateSplit)
1823  private:
1824   BlockList*  _sux;
1825 
1826  protected:
1827   BlockList* sux() const                         { return _sux; }
1828 
1829   void set_sux(BlockList* sux) {
1830 #ifdef ASSERT
1831     assert(sux != NULL, &quot;sux must exist&quot;);
1832     for (int i = sux-&gt;length() - 1; i &gt;= 0; i--) assert(sux-&gt;at(i) != NULL, &quot;sux must exist&quot;);
1833 #endif
1834     _sux = sux;
1835   }
1836 
1837  public:
1838   // creation
1839   BlockEnd(ValueType* type, ValueStack* state_before, bool is_safepoint)
1840   : StateSplit(type, state_before)
1841   , _sux(NULL)
1842   {
1843     set_flag(IsSafepointFlag, is_safepoint);
1844   }
1845 
1846   // accessors
1847   bool is_safepoint() const                      { return check_flag(IsSafepointFlag); }
1848   // For compatibility with old code, for new code use block()
1849   BlockBegin* begin() const                      { return _block; }
1850 
1851   // manipulation
1852   void set_begin(BlockBegin* begin);
1853 
1854   // successors
1855   int number_of_sux() const                      { return _sux != NULL ? _sux-&gt;length() : 0; }
1856   BlockBegin* sux_at(int i) const                { return _sux-&gt;at(i); }
1857   BlockBegin* default_sux() const                { return sux_at(number_of_sux() - 1); }
1858   BlockBegin** addr_sux_at(int i) const          { return _sux-&gt;adr_at(i); }
1859   int sux_index(BlockBegin* sux) const           { return _sux-&gt;find(sux); }
1860   void substitute_sux(BlockBegin* old_sux, BlockBegin* new_sux);
1861 };
1862 
1863 
1864 LEAF(Goto, BlockEnd)
1865  public:
1866   enum Direction {
1867     none,            // Just a regular goto
1868     taken, not_taken // Goto produced from If
1869   };
1870  private:
1871   ciMethod*   _profiled_method;
1872   int         _profiled_bci;
1873   Direction   _direction;
1874  public:
1875   // creation
1876   Goto(BlockBegin* sux, ValueStack* state_before, bool is_safepoint = false)
1877     : BlockEnd(illegalType, state_before, is_safepoint)
1878     , _profiled_method(NULL)
1879     , _profiled_bci(0)
1880     , _direction(none) {
1881     BlockList* s = new BlockList(1);
1882     s-&gt;append(sux);
1883     set_sux(s);
1884   }
1885 
1886   Goto(BlockBegin* sux, bool is_safepoint) : BlockEnd(illegalType, NULL, is_safepoint)
1887                                            , _profiled_method(NULL)
1888                                            , _profiled_bci(0)
1889                                            , _direction(none) {
1890     BlockList* s = new BlockList(1);
1891     s-&gt;append(sux);
1892     set_sux(s);
1893   }
1894 
1895   bool should_profile() const                    { return check_flag(ProfileMDOFlag); }
1896   ciMethod* profiled_method() const              { return _profiled_method; } // set only for profiled branches
1897   int profiled_bci() const                       { return _profiled_bci; }
1898   Direction direction() const                    { return _direction; }
1899 
1900   void set_should_profile(bool value)            { set_flag(ProfileMDOFlag, value); }
1901   void set_profiled_method(ciMethod* method)     { _profiled_method = method; }
1902   void set_profiled_bci(int bci)                 { _profiled_bci = bci; }
1903   void set_direction(Direction d)                { _direction = d; }
1904 };
1905 
1906 #ifdef ASSERT
1907 LEAF(Assert, Instruction)
1908   private:
1909   Value       _x;
1910   Condition   _cond;
1911   Value       _y;
1912   char        *_message;
1913 
1914  public:
1915   // creation
1916   // unordered_is_true is valid for float/double compares only
1917    Assert(Value x, Condition cond, bool unordered_is_true, Value y);
1918 
1919   // accessors
1920   Value x() const                                { return _x; }
1921   Condition cond() const                         { return _cond; }
1922   bool unordered_is_true() const                 { return check_flag(UnorderedIsTrueFlag); }
1923   Value y() const                                { return _y; }
1924   const char *message() const                    { return _message; }
1925 
1926   // generic
1927   virtual void input_values_do(ValueVisitor* f)  { f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
1928 };
1929 #endif
1930 
1931 LEAF(RangeCheckPredicate, StateSplit)
1932  private:
1933   Value       _x;
1934   Condition   _cond;
1935   Value       _y;
1936 
1937   void check_state();
1938 
1939  public:
1940   // creation
1941   // unordered_is_true is valid for float/double compares only
1942    RangeCheckPredicate(Value x, Condition cond, bool unordered_is_true, Value y, ValueStack* state) : StateSplit(illegalType)
1943   , _x(x)
1944   , _cond(cond)
1945   , _y(y)
1946   {
1947     ASSERT_VALUES
1948     set_flag(UnorderedIsTrueFlag, unordered_is_true);
1949     assert(x-&gt;type()-&gt;tag() == y-&gt;type()-&gt;tag(), &quot;types must match&quot;);
1950     this-&gt;set_state(state);
1951     check_state();
1952   }
1953 
1954   // Always deoptimize
1955   RangeCheckPredicate(ValueStack* state) : StateSplit(illegalType)
1956   {
1957     this-&gt;set_state(state);
1958     _x = _y = NULL;
1959     check_state();
1960   }
1961 
1962   // accessors
1963   Value x() const                                { return _x; }
1964   Condition cond() const                         { return _cond; }
1965   bool unordered_is_true() const                 { return check_flag(UnorderedIsTrueFlag); }
1966   Value y() const                                { return _y; }
1967 
1968   void always_fail()                             { _x = _y = NULL; }
1969 
1970   // generic
1971   virtual void input_values_do(ValueVisitor* f)  { StateSplit::input_values_do(f); f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
1972   HASHING3(RangeCheckPredicate, true, x()-&gt;subst(), y()-&gt;subst(), cond())
1973 };
1974 
1975 LEAF(If, BlockEnd)
1976  private:
1977   Value       _x;
1978   Condition   _cond;
1979   Value       _y;
1980   ciMethod*   _profiled_method;
1981   int         _profiled_bci; // Canonicalizer may alter bci of If node
1982   bool        _swapped;      // Is the order reversed with respect to the original If in the
1983                              // bytecode stream?
1984  public:
1985   // creation
1986   // unordered_is_true is valid for float/double compares only
1987   If(Value x, Condition cond, bool unordered_is_true, Value y, BlockBegin* tsux, BlockBegin* fsux, ValueStack* state_before, bool is_safepoint)
1988     : BlockEnd(illegalType, state_before, is_safepoint)
1989   , _x(x)
1990   , _cond(cond)
1991   , _y(y)
1992   , _profiled_method(NULL)
1993   , _profiled_bci(0)
1994   , _swapped(false)
1995   {
1996     ASSERT_VALUES
1997     set_flag(UnorderedIsTrueFlag, unordered_is_true);
1998     assert(x-&gt;type()-&gt;tag() == y-&gt;type()-&gt;tag(), &quot;types must match&quot;);
1999     BlockList* s = new BlockList(2);
2000     s-&gt;append(tsux);
2001     s-&gt;append(fsux);
2002     set_sux(s);
2003   }
2004 
2005   // accessors
2006   Value x() const                                { return _x; }
2007   Condition cond() const                         { return _cond; }
2008   bool unordered_is_true() const                 { return check_flag(UnorderedIsTrueFlag); }
2009   Value y() const                                { return _y; }
2010   BlockBegin* sux_for(bool is_true) const        { return sux_at(is_true ? 0 : 1); }
2011   BlockBegin* tsux() const                       { return sux_for(true); }
2012   BlockBegin* fsux() const                       { return sux_for(false); }
2013   BlockBegin* usux() const                       { return sux_for(unordered_is_true()); }
2014   bool should_profile() const                    { return check_flag(ProfileMDOFlag); }
2015   ciMethod* profiled_method() const              { return _profiled_method; } // set only for profiled branches
2016   int profiled_bci() const                       { return _profiled_bci; }    // set for profiled branches and tiered
2017   bool is_swapped() const                        { return _swapped; }
2018 
2019   // manipulation
2020   void swap_operands() {
2021     Value t = _x; _x = _y; _y = t;
2022     _cond = mirror(_cond);
2023   }
2024 
2025   void swap_sux() {
2026     assert(number_of_sux() == 2, &quot;wrong number of successors&quot;);
2027     BlockList* s = sux();
2028     BlockBegin* t = s-&gt;at(0); s-&gt;at_put(0, s-&gt;at(1)); s-&gt;at_put(1, t);
2029     _cond = negate(_cond);
2030     set_flag(UnorderedIsTrueFlag, !check_flag(UnorderedIsTrueFlag));
2031   }
2032 
2033   void set_should_profile(bool value)             { set_flag(ProfileMDOFlag, value); }
2034   void set_profiled_method(ciMethod* method)      { _profiled_method = method; }
2035   void set_profiled_bci(int bci)                  { _profiled_bci = bci;       }
2036   void set_swapped(bool value)                    { _swapped = value;         }
2037   // generic
2038   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_x); f-&gt;visit(&amp;_y); }
2039 };
2040 
2041 
2042 LEAF(IfInstanceOf, BlockEnd)
2043  private:
2044   ciKlass* _klass;
2045   Value    _obj;
2046   bool     _test_is_instance;                    // jump if instance
2047   int      _instanceof_bci;
2048 
2049  public:
2050   IfInstanceOf(ciKlass* klass, Value obj, bool test_is_instance, int instanceof_bci, BlockBegin* tsux, BlockBegin* fsux)
2051   : BlockEnd(illegalType, NULL, false) // temporary set to false
2052   , _klass(klass)
2053   , _obj(obj)
2054   , _test_is_instance(test_is_instance)
2055   , _instanceof_bci(instanceof_bci)
2056   {
2057     ASSERT_VALUES
2058     assert(instanceof_bci &gt;= 0, &quot;illegal bci&quot;);
2059     BlockList* s = new BlockList(2);
2060     s-&gt;append(tsux);
2061     s-&gt;append(fsux);
2062     set_sux(s);
2063   }
2064 
2065   // accessors
2066   //
2067   // Note 1: If test_is_instance() is true, IfInstanceOf tests if obj *is* an
2068   //         instance of klass; otherwise it tests if it is *not* and instance
2069   //         of klass.
2070   //
2071   // Note 2: IfInstanceOf instructions are created by combining an InstanceOf
2072   //         and an If instruction. The IfInstanceOf bci() corresponds to the
2073   //         bci that the If would have had; the (this-&gt;) instanceof_bci() is
2074   //         the bci of the original InstanceOf instruction.
2075   ciKlass* klass() const                         { return _klass; }
2076   Value obj() const                              { return _obj; }
2077   int instanceof_bci() const                     { return _instanceof_bci; }
2078   bool test_is_instance() const                  { return _test_is_instance; }
2079   BlockBegin* sux_for(bool is_true) const        { return sux_at(is_true ? 0 : 1); }
2080   BlockBegin* tsux() const                       { return sux_for(true); }
2081   BlockBegin* fsux() const                       { return sux_for(false); }
2082 
2083   // manipulation
2084   void swap_sux() {
2085     assert(number_of_sux() == 2, &quot;wrong number of successors&quot;);
2086     BlockList* s = sux();
2087     BlockBegin* t = s-&gt;at(0); s-&gt;at_put(0, s-&gt;at(1)); s-&gt;at_put(1, t);
2088     _test_is_instance = !_test_is_instance;
2089   }
2090 
2091   // generic
2092   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_obj); }
2093 };
2094 
2095 
2096 BASE(Switch, BlockEnd)
2097  private:
2098   Value       _tag;
2099 
2100  public:
2101   // creation
2102   Switch(Value tag, BlockList* sux, ValueStack* state_before, bool is_safepoint)
2103   : BlockEnd(illegalType, state_before, is_safepoint)
2104   , _tag(tag) {
2105     ASSERT_VALUES
2106     set_sux(sux);
2107   }
2108 
2109   // accessors
2110   Value tag() const                              { return _tag; }
2111   int length() const                             { return number_of_sux() - 1; }
2112 
2113   virtual bool needs_exception_state() const     { return false; }
2114 
2115   // generic
2116   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_tag); }
2117 };
2118 
2119 
2120 LEAF(TableSwitch, Switch)
2121  private:
2122   int _lo_key;
2123 
2124  public:
2125   // creation
2126   TableSwitch(Value tag, BlockList* sux, int lo_key, ValueStack* state_before, bool is_safepoint)
2127     : Switch(tag, sux, state_before, is_safepoint)
2128   , _lo_key(lo_key) { assert(_lo_key &lt;= hi_key(), &quot;integer overflow&quot;); }
2129 
2130   // accessors
2131   int lo_key() const                             { return _lo_key; }
2132   int hi_key() const                             { return _lo_key + (length() - 1); }
2133 };
2134 
2135 
2136 LEAF(LookupSwitch, Switch)
2137  private:
2138   intArray* _keys;
2139 
2140  public:
2141   // creation
2142   LookupSwitch(Value tag, BlockList* sux, intArray* keys, ValueStack* state_before, bool is_safepoint)
2143   : Switch(tag, sux, state_before, is_safepoint)
2144   , _keys(keys) {
2145     assert(keys != NULL, &quot;keys must exist&quot;);
2146     assert(keys-&gt;length() == length(), &quot;sux &amp; keys have incompatible lengths&quot;);
2147   }
2148 
2149   // accessors
2150   int key_at(int i) const                        { return _keys-&gt;at(i); }
2151 };
2152 
2153 
2154 LEAF(Return, BlockEnd)
2155  private:
2156   Value _result;
2157 
2158  public:
2159   // creation
2160   Return(Value result) :
2161     BlockEnd(result == NULL ? voidType : result-&gt;type()-&gt;base(), NULL, true),
2162     _result(result) {}
2163 
2164   // accessors
2165   Value result() const                           { return _result; }
2166   bool has_result() const                        { return result() != NULL; }
2167 
2168   // generic
2169   virtual void input_values_do(ValueVisitor* f) {
2170     BlockEnd::input_values_do(f);
2171     if (has_result()) f-&gt;visit(&amp;_result);
2172   }
2173 };
2174 
2175 
2176 LEAF(Throw, BlockEnd)
2177  private:
2178   Value _exception;
2179 
2180  public:
2181   // creation
2182   Throw(Value exception, ValueStack* state_before) : BlockEnd(illegalType, state_before, true), _exception(exception) {
2183     ASSERT_VALUES
2184   }
2185 
2186   // accessors
2187   Value exception() const                        { return _exception; }
2188 
2189   // generic
2190   virtual bool can_trap() const                  { return true; }
2191   virtual void input_values_do(ValueVisitor* f)   { BlockEnd::input_values_do(f); f-&gt;visit(&amp;_exception); }
2192 };
2193 
2194 
2195 LEAF(Base, BlockEnd)
2196  public:
2197   // creation
2198   Base(BlockBegin* std_entry, BlockBegin* osr_entry) : BlockEnd(illegalType, NULL, false) {
2199     assert(std_entry-&gt;is_set(BlockBegin::std_entry_flag), &quot;std entry must be flagged&quot;);
2200     assert(osr_entry == NULL || osr_entry-&gt;is_set(BlockBegin::osr_entry_flag), &quot;osr entry must be flagged&quot;);
2201     BlockList* s = new BlockList(2);
2202     if (osr_entry != NULL) s-&gt;append(osr_entry);
2203     s-&gt;append(std_entry); // must be default sux!
2204     set_sux(s);
2205   }
2206 
2207   // accessors
2208   BlockBegin* std_entry() const                  { return default_sux(); }
2209   BlockBegin* osr_entry() const                  { return number_of_sux() &lt; 2 ? NULL : sux_at(0); }
2210 };
2211 
2212 
2213 LEAF(OsrEntry, Instruction)
2214  public:
2215   // creation
2216 #ifdef _LP64
2217   OsrEntry() : Instruction(longType) { pin(); }
2218 #else
2219   OsrEntry() : Instruction(intType)  { pin(); }
2220 #endif
2221 
2222   // generic
2223   virtual void input_values_do(ValueVisitor* f)   { }
2224 };
2225 
2226 
2227 // Models the incoming exception at a catch site
2228 LEAF(ExceptionObject, Instruction)
2229  public:
2230   // creation
2231   ExceptionObject() : Instruction(objectType) {
2232     pin();
2233   }
2234 
2235   // generic
2236   virtual void input_values_do(ValueVisitor* f)   { }
2237 };
2238 
2239 
2240 // Models needed rounding for floating-point values on Intel.
2241 // Currently only used to represent rounding of double-precision
2242 // values stored into local variables, but could be used to model
2243 // intermediate rounding of single-precision values as well.
2244 LEAF(RoundFP, Instruction)
2245  private:
2246   Value _input;             // floating-point value to be rounded
2247 
2248  public:
2249   RoundFP(Value input)
2250   : Instruction(input-&gt;type()) // Note: should not be used for constants
2251   , _input(input)
2252   {
2253     ASSERT_VALUES
2254   }
2255 
2256   // accessors
2257   Value input() const                            { return _input; }
2258 
2259   // generic
2260   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_input); }
2261 };
2262 
2263 
2264 BASE(UnsafeOp, Instruction)
2265  private:
2266   BasicType _basic_type;    // ValueType can not express byte-sized integers
2267 
2268  protected:
2269   // creation
2270   UnsafeOp(BasicType basic_type, bool is_put)
2271   : Instruction(is_put ? voidType : as_ValueType(basic_type))
2272   , _basic_type(basic_type)
2273   {
2274     //Note:  Unsafe ops are not not guaranteed to throw NPE.
2275     // Convservatively, Unsafe operations must be pinned though we could be
2276     // looser about this if we wanted to..
2277     pin();
2278   }
2279 
2280  public:
2281   // accessors
2282   BasicType basic_type()                         { return _basic_type; }
2283 
2284   // generic
2285   virtual void input_values_do(ValueVisitor* f)   { }
2286 };
2287 
2288 
2289 BASE(UnsafeRawOp, UnsafeOp)
2290  private:
2291   Value _base;                                   // Base address (a Java long)
2292   Value _index;                                  // Index if computed by optimizer; initialized to NULL
2293   int   _log2_scale;                             // Scale factor: 0, 1, 2, or 3.
2294                                                  // Indicates log2 of number of bytes (1, 2, 4, or 8)
2295                                                  // to scale index by.
2296 
2297  protected:
2298   UnsafeRawOp(BasicType basic_type, Value addr, bool is_put)
2299   : UnsafeOp(basic_type, is_put)
2300   , _base(addr)
2301   , _index(NULL)
2302   , _log2_scale(0)
2303   {
2304     // Can not use ASSERT_VALUES because index may be NULL
2305     assert(addr != NULL &amp;&amp; addr-&gt;type()-&gt;is_long(), &quot;just checking&quot;);
2306   }
2307 
2308   UnsafeRawOp(BasicType basic_type, Value base, Value index, int log2_scale, bool is_put)
2309   : UnsafeOp(basic_type, is_put)
2310   , _base(base)
2311   , _index(index)
2312   , _log2_scale(log2_scale)
2313   {
2314   }
2315 
2316  public:
2317   // accessors
2318   Value base()                                   { return _base; }
2319   Value index()                                  { return _index; }
2320   bool  has_index()                              { return (_index != NULL); }
2321   int   log2_scale()                             { return _log2_scale; }
2322 
2323   // setters
2324   void set_base (Value base)                     { _base  = base; }
2325   void set_index(Value index)                    { _index = index; }
2326   void set_log2_scale(int log2_scale)            { _log2_scale = log2_scale; }
2327 
2328   // generic
2329   virtual void input_values_do(ValueVisitor* f)   { UnsafeOp::input_values_do(f);
2330                                                    f-&gt;visit(&amp;_base);
2331                                                    if (has_index()) f-&gt;visit(&amp;_index); }
2332 };
2333 
2334 
2335 LEAF(UnsafeGetRaw, UnsafeRawOp)
2336  private:
2337  bool _may_be_unaligned, _is_wide;  // For OSREntry
2338 
2339  public:
2340  UnsafeGetRaw(BasicType basic_type, Value addr, bool may_be_unaligned, bool is_wide = false)
2341   : UnsafeRawOp(basic_type, addr, false) {
2342     _may_be_unaligned = may_be_unaligned;
2343     _is_wide = is_wide;
2344   }
2345 
2346  UnsafeGetRaw(BasicType basic_type, Value base, Value index, int log2_scale, bool may_be_unaligned, bool is_wide = false)
2347   : UnsafeRawOp(basic_type, base, index, log2_scale, false) {
2348     _may_be_unaligned = may_be_unaligned;
2349     _is_wide = is_wide;
2350   }
2351 
2352   bool may_be_unaligned()                         { return _may_be_unaligned; }
2353   bool is_wide()                                  { return _is_wide; }
2354 };
2355 
2356 
2357 LEAF(UnsafePutRaw, UnsafeRawOp)
2358  private:
2359   Value _value;                                  // Value to be stored
2360 
2361  public:
2362   UnsafePutRaw(BasicType basic_type, Value addr, Value value)
2363   : UnsafeRawOp(basic_type, addr, true)
2364   , _value(value)
2365   {
2366     assert(value != NULL, &quot;just checking&quot;);
2367     ASSERT_VALUES
2368   }
2369 
2370   UnsafePutRaw(BasicType basic_type, Value base, Value index, int log2_scale, Value value)
2371   : UnsafeRawOp(basic_type, base, index, log2_scale, true)
2372   , _value(value)
2373   {
2374     assert(value != NULL, &quot;just checking&quot;);
2375     ASSERT_VALUES
2376   }
2377 
2378   // accessors
2379   Value value()                                  { return _value; }
2380 
2381   // generic
2382   virtual void input_values_do(ValueVisitor* f)   { UnsafeRawOp::input_values_do(f);
2383                                                    f-&gt;visit(&amp;_value); }
2384 };
2385 
2386 
2387 BASE(UnsafeObjectOp, UnsafeOp)
2388  private:
2389   Value _object;                                 // Object to be fetched from or mutated
2390   Value _offset;                                 // Offset within object
2391   bool  _is_volatile;                            // true if volatile - dl/JSR166
2392  public:
2393   UnsafeObjectOp(BasicType basic_type, Value object, Value offset, bool is_put, bool is_volatile)
2394     : UnsafeOp(basic_type, is_put), _object(object), _offset(offset), _is_volatile(is_volatile)
2395   {
2396   }
2397 
2398   // accessors
2399   Value object()                                 { return _object; }
2400   Value offset()                                 { return _offset; }
2401   bool  is_volatile()                            { return _is_volatile; }
2402   // generic
2403   virtual void input_values_do(ValueVisitor* f)   { UnsafeOp::input_values_do(f);
2404                                                    f-&gt;visit(&amp;_object);
2405                                                    f-&gt;visit(&amp;_offset); }
2406 };
2407 
2408 
2409 LEAF(UnsafeGetObject, UnsafeObjectOp)
2410  public:
2411   UnsafeGetObject(BasicType basic_type, Value object, Value offset, bool is_volatile)
2412   : UnsafeObjectOp(basic_type, object, offset, false, is_volatile)
2413   {
2414     ASSERT_VALUES
2415   }
2416 };
2417 
2418 
2419 LEAF(UnsafePutObject, UnsafeObjectOp)
2420  private:
2421   Value _value;                                  // Value to be stored
2422  public:
2423   UnsafePutObject(BasicType basic_type, Value object, Value offset, Value value, bool is_volatile)
2424   : UnsafeObjectOp(basic_type, object, offset, true, is_volatile)
2425     , _value(value)
2426   {
2427     ASSERT_VALUES
2428   }
2429 
2430   // accessors
2431   Value value()                                  { return _value; }
2432 
2433   // generic
2434   virtual void input_values_do(ValueVisitor* f)   { UnsafeObjectOp::input_values_do(f);
2435                                                    f-&gt;visit(&amp;_value); }
2436 };
2437 
2438 LEAF(UnsafeGetAndSetObject, UnsafeObjectOp)
2439  private:
2440   Value _value;                                  // Value to be stored
2441   bool  _is_add;
2442  public:
2443   UnsafeGetAndSetObject(BasicType basic_type, Value object, Value offset, Value value, bool is_add)
2444   : UnsafeObjectOp(basic_type, object, offset, false, false)
2445     , _value(value)
2446     , _is_add(is_add)
2447   {
2448     ASSERT_VALUES
2449   }
2450 
2451   // accessors
2452   bool is_add() const                            { return _is_add; }
2453   Value value()                                  { return _value; }
2454 
2455   // generic
2456   virtual void input_values_do(ValueVisitor* f)   { UnsafeObjectOp::input_values_do(f);
2457                                                    f-&gt;visit(&amp;_value); }
2458 };
2459 
2460 LEAF(ProfileCall, Instruction)
2461  private:
2462   ciMethod*        _method;
2463   int              _bci_of_invoke;
2464   ciMethod*        _callee;         // the method that is called at the given bci
2465   Value            _recv;
2466   ciKlass*         _known_holder;
2467   Values*          _obj_args;       // arguments for type profiling
2468   ArgsNonNullState _nonnull_state;  // Do we know whether some arguments are never null?
2469   bool             _inlined;        // Are we profiling a call that is inlined
2470 
2471  public:
2472   ProfileCall(ciMethod* method, int bci, ciMethod* callee, Value recv, ciKlass* known_holder, Values* obj_args, bool inlined)
2473     : Instruction(voidType)
2474     , _method(method)
2475     , _bci_of_invoke(bci)
2476     , _callee(callee)
2477     , _recv(recv)
2478     , _known_holder(known_holder)
2479     , _obj_args(obj_args)
2480     , _inlined(inlined)
2481   {
2482     // The ProfileCall has side-effects and must occur precisely where located
2483     pin();
2484   }
2485 
2486   ciMethod* method()             const { return _method; }
2487   int bci_of_invoke()            const { return _bci_of_invoke; }
2488   ciMethod* callee()             const { return _callee; }
2489   Value recv()                   const { return _recv; }
2490   ciKlass* known_holder()        const { return _known_holder; }
2491   int nb_profiled_args()         const { return _obj_args == NULL ? 0 : _obj_args-&gt;length(); }
2492   Value profiled_arg_at(int i)   const { return _obj_args-&gt;at(i); }
2493   bool arg_needs_null_check(int i) const {
2494     return _nonnull_state.arg_needs_null_check(i);
2495   }
2496   bool inlined()                 const { return _inlined; }
2497 
2498   void set_arg_needs_null_check(int i, bool check) {
2499     _nonnull_state.set_arg_needs_null_check(i, check);
2500   }
2501 
2502   virtual void input_values_do(ValueVisitor* f)   {
2503     if (_recv != NULL) {
2504       f-&gt;visit(&amp;_recv);
2505     }
2506     for (int i = 0; i &lt; nb_profiled_args(); i++) {
2507       f-&gt;visit(_obj_args-&gt;adr_at(i));
2508     }
2509   }
2510 };
2511 
2512 LEAF(ProfileReturnType, Instruction)
2513  private:
2514   ciMethod*        _method;
2515   ciMethod*        _callee;
2516   int              _bci_of_invoke;
2517   Value            _ret;
2518 
2519  public:
2520   ProfileReturnType(ciMethod* method, int bci, ciMethod* callee, Value ret)
2521     : Instruction(voidType)
2522     , _method(method)
2523     , _callee(callee)
2524     , _bci_of_invoke(bci)
2525     , _ret(ret)
2526   {
2527     set_needs_null_check(true);
2528     // The ProfileType has side-effects and must occur precisely where located
2529     pin();
2530   }
2531 
2532   ciMethod* method()             const { return _method; }
2533   ciMethod* callee()             const { return _callee; }
2534   int bci_of_invoke()            const { return _bci_of_invoke; }
2535   Value ret()                    const { return _ret; }
2536 
2537   virtual void input_values_do(ValueVisitor* f)   {
2538     if (_ret != NULL) {
2539       f-&gt;visit(&amp;_ret);
2540     }
2541   }
2542 };
2543 
2544 // Call some C runtime function that doesn&#39;t safepoint,
2545 // optionally passing the current thread as the first argument.
2546 LEAF(RuntimeCall, Instruction)
2547  private:
2548   const char* _entry_name;
2549   address     _entry;
2550   Values*     _args;
2551   bool        _pass_thread;  // Pass the JavaThread* as an implicit first argument
2552 
2553  public:
2554   RuntimeCall(ValueType* type, const char* entry_name, address entry, Values* args, bool pass_thread = true)
2555     : Instruction(type)
2556     , _entry_name(entry_name)
2557     , _entry(entry)
2558     , _args(args)
2559     , _pass_thread(pass_thread) {
2560     ASSERT_VALUES
2561     pin();
2562   }
2563 
2564   const char* entry_name() const  { return _entry_name; }
2565   address entry() const           { return _entry; }
2566   int number_of_arguments() const { return _args-&gt;length(); }
2567   Value argument_at(int i) const  { return _args-&gt;at(i); }
2568   bool pass_thread() const        { return _pass_thread; }
2569 
2570   virtual void input_values_do(ValueVisitor* f)   {
2571     for (int i = 0; i &lt; _args-&gt;length(); i++) f-&gt;visit(_args-&gt;adr_at(i));
2572   }
2573 };
2574 
2575 // Use to trip invocation counter of an inlined method
2576 
2577 LEAF(ProfileInvoke, Instruction)
2578  private:
2579   ciMethod*   _inlinee;
2580   ValueStack* _state;
2581 
2582  public:
2583   ProfileInvoke(ciMethod* inlinee,  ValueStack* state)
2584     : Instruction(voidType)
2585     , _inlinee(inlinee)
2586     , _state(state)
2587   {
2588     // The ProfileInvoke has side-effects and must occur precisely where located QQQ???
2589     pin();
2590   }
2591 
2592   ciMethod* inlinee()      { return _inlinee; }
2593   ValueStack* state()      { return _state; }
2594   virtual void input_values_do(ValueVisitor*)   {}
2595   virtual void state_values_do(ValueVisitor*);
2596 };
2597 
2598 LEAF(MemBar, Instruction)
2599  private:
2600   LIR_Code _code;
2601 
2602  public:
2603   MemBar(LIR_Code code)
2604     : Instruction(voidType)
2605     , _code(code)
2606   {
2607     pin();
2608   }
2609 
2610   LIR_Code code()           { return _code; }
2611 
2612   virtual void input_values_do(ValueVisitor*)   {}
2613 };
2614 
2615 class BlockPair: public CompilationResourceObj {
2616  private:
2617   BlockBegin* _from;
2618   BlockBegin* _to;
2619  public:
2620   BlockPair(BlockBegin* from, BlockBegin* to): _from(from), _to(to) {}
2621   BlockBegin* from() const { return _from; }
2622   BlockBegin* to() const   { return _to;   }
2623   bool is_same(BlockBegin* from, BlockBegin* to) const { return  _from == from &amp;&amp; _to == to; }
2624   bool is_same(BlockPair* p) const { return  _from == p-&gt;from() &amp;&amp; _to == p-&gt;to(); }
2625   void set_to(BlockBegin* b)   { _to = b; }
2626   void set_from(BlockBegin* b) { _from = b; }
2627 };
2628 
2629 typedef GrowableArray&lt;BlockPair*&gt; BlockPairList;
2630 
2631 inline int         BlockBegin::number_of_sux() const            { assert(_end == NULL || _end-&gt;number_of_sux() == _successors.length(), &quot;mismatch&quot;); return _successors.length(); }
2632 inline BlockBegin* BlockBegin::sux_at(int i) const              { assert(_end == NULL || _end-&gt;sux_at(i) == _successors.at(i), &quot;mismatch&quot;);          return _successors.at(i); }
2633 inline void        BlockBegin::add_successor(BlockBegin* sux)   { assert(_end == NULL, &quot;Would create mismatch with successors of BlockEnd&quot;);         _successors.append(sux); }
2634 
2635 #undef ASSERT_VALUES
2636 
2637 #endif // SHARE_C1_C1_INSTRUCTION_HPP
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/whitebox.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stackwalk.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="whitebox.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/whitebox.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 
  27 #include &lt;new&gt;
  28 
  29 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  30 #include &quot;classfile/modules.hpp&quot;
  31 #include &quot;classfile/protectionDomainCache.hpp&quot;
  32 #include &quot;classfile/stringTable.hpp&quot;
  33 #include &quot;classfile/symbolTable.hpp&quot;
  34 #include &quot;code/codeCache.hpp&quot;
  35 #include &quot;compiler/compilationPolicy.hpp&quot;
  36 #include &quot;compiler/methodMatcher.hpp&quot;
  37 #include &quot;compiler/directivesParser.hpp&quot;

  38 #include &quot;gc/shared/gcConfig.hpp&quot;
  39 #include &quot;gc/shared/genArguments.hpp&quot;
  40 #include &quot;gc/shared/genCollectedHeap.hpp&quot;
  41 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
  42 #include &quot;memory/filemap.hpp&quot;
  43 #include &quot;memory/heapShared.inline.hpp&quot;
  44 #include &quot;memory/metaspaceShared.hpp&quot;
  45 #include &quot;memory/metadataFactory.hpp&quot;
  46 #include &quot;memory/iterator.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;memory/oopFactory.hpp&quot;
  50 #include &quot;oops/array.hpp&quot;
  51 #include &quot;oops/compressedOops.hpp&quot;
  52 #include &quot;oops/constantPool.inline.hpp&quot;
  53 #include &quot;oops/method.inline.hpp&quot;
  54 #include &quot;oops/objArrayKlass.hpp&quot;
  55 #include &quot;oops/objArrayOop.inline.hpp&quot;
  56 #include &quot;oops/oop.inline.hpp&quot;
  57 #include &quot;oops/typeArrayOop.inline.hpp&quot;
</pre>
<hr />
<pre>
  89 #include &quot;gc/g1/g1ConcurrentMark.hpp&quot;
  90 #include &quot;gc/g1/g1ConcurrentMarkThread.hpp&quot;
  91 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  92 #include &quot;gc/g1/heterogeneousHeapRegionManager.hpp&quot;
  93 #endif // INCLUDE_G1GC
  94 #if INCLUDE_PARALLELGC
  95 #include &quot;gc/parallel/parallelScavengeHeap.inline.hpp&quot;
  96 #include &quot;gc/parallel/adjoiningGenerations.hpp&quot;
  97 #endif // INCLUDE_PARALLELGC
  98 #if INCLUDE_NMT
  99 #include &quot;services/mallocSiteTable.hpp&quot;
 100 #include &quot;services/memTracker.hpp&quot;
 101 #include &quot;utilities/nativeCallStack.hpp&quot;
 102 #endif // INCLUDE_NMT
 103 #if INCLUDE_AOT
 104 #include &quot;aot/aotLoader.hpp&quot;
 105 #endif // INCLUDE_AOT
 106 
 107 #ifdef LINUX
 108 #include &quot;osContainer_linux.hpp&quot;

 109 #endif
 110 
 111 #define SIZE_T_MAX_VALUE ((size_t) -1)
 112 
 113 #define CHECK_JNI_EXCEPTION_(env, value)                               \
 114   do {                                                                 \
 115     JavaThread* THREAD = JavaThread::thread_from_jni_environment(env); \
 116     THREAD-&gt;clear_pending_jni_exception_check();                       \
 117     if (HAS_PENDING_EXCEPTION) {                                       \
 118       return(value);                                                   \
 119     }                                                                  \
 120   } while (0)
 121 
 122 #define CHECK_JNI_EXCEPTION(env)                                       \
 123   do {                                                                 \
 124     JavaThread* THREAD = JavaThread::thread_from_jni_environment(env); \
 125     THREAD-&gt;clear_pending_jni_exception_check();                       \
 126     if (HAS_PENDING_EXCEPTION) {                                       \
 127       return;                                                          \
 128     }                                                                  \
</pre>
<hr />
<pre>
 377     return Universe::heap()-&gt;is_in(p);
 378   }
 379 #endif
 380   GenCollectedHeap* gch = GenCollectedHeap::heap();
 381   return !gch-&gt;is_in_young(p);
 382 WB_END
 383 
 384 WB_ENTRY(jlong, WB_GetObjectSize(JNIEnv* env, jobject o, jobject obj))
 385   oop p = JNIHandles::resolve(obj);
 386   return Universe::heap()-&gt;obj_size(p) * HeapWordSize;
 387 WB_END
 388 
 389 WB_ENTRY(jlong, WB_GetHeapSpaceAlignment(JNIEnv* env, jobject o))
 390   return (jlong)SpaceAlignment;
 391 WB_END
 392 
 393 WB_ENTRY(jlong, WB_GetHeapAlignment(JNIEnv* env, jobject o))
 394   return (jlong)HeapAlignment;
 395 WB_END
 396 
<span class="line-modified"> 397 WB_ENTRY(jboolean, WB_SupportsConcurrentGCPhaseControl(JNIEnv* env, jobject o))</span>
<span class="line-modified"> 398   return Universe::heap()-&gt;supports_concurrent_phase_control();</span>
 399 WB_END
 400 
<span class="line-modified"> 401 WB_ENTRY(jboolean, WB_RequestConcurrentGCPhase(JNIEnv* env, jobject o, jstring name))</span>
<span class="line-modified"> 402   Handle h_name(THREAD, JNIHandles::resolve(name));</span>












 403   ResourceMark rm;
 404   const char* c_name = java_lang_String::as_utf8_string(h_name());
<span class="line-modified"> 405   return Universe::heap()-&gt;request_concurrent_phase(c_name);</span>
 406 WB_END
 407 
 408 #if INCLUDE_G1GC
 409 
 410 WB_ENTRY(jboolean, WB_G1IsHumongous(JNIEnv* env, jobject o, jobject obj))
 411   if (UseG1GC) {
 412     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 413     oop result = JNIHandles::resolve(obj);
 414     const HeapRegion* hr = g1h-&gt;heap_region_containing(result);
 415     return hr-&gt;is_humongous();
 416   }
 417   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1IsHumongous: G1 GC is not enabled&quot;);
 418 WB_END
 419 
 420 WB_ENTRY(jboolean, WB_G1BelongsToHumongousRegion(JNIEnv* env, jobject o, jlong addr))
 421   if (UseG1GC) {
 422     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 423     const HeapRegion* hr = g1h-&gt;heap_region_containing((void*) addr);
 424     return hr-&gt;is_humongous();
 425   }
</pre>
<hr />
<pre>
 804   return (jlong)arena;
 805 WB_END
 806 
 807 WB_ENTRY(void, WB_NMTFreeArena(JNIEnv* env, jobject o, jlong arena))
 808   Arena* a = (Arena*)arena;
 809   delete a;
 810 WB_END
 811 
 812 WB_ENTRY(void, WB_NMTArenaMalloc(JNIEnv* env, jobject o, jlong arena, jlong size))
 813   Arena* a = (Arena*)arena;
 814   a-&gt;Amalloc(size_t(size));
 815 WB_END
 816 #endif // INCLUDE_NMT
 817 
 818 static jmethodID reflected_method_to_jmid(JavaThread* thread, JNIEnv* env, jobject method) {
 819   assert(method != NULL, &quot;method should not be null&quot;);
 820   ThreadToNativeFromVM ttn(thread);
 821   return env-&gt;FromReflectedMethod(method);
 822 }
 823 




 824 // Deoptimizes all compiled frames and makes nmethods not entrant if it&#39;s requested
 825 class VM_WhiteBoxDeoptimizeFrames : public VM_WhiteBoxOperation {
 826  private:
 827   int _result;
 828   const bool _make_not_entrant;
 829  public:
 830   VM_WhiteBoxDeoptimizeFrames(bool make_not_entrant) :
 831         _result(0), _make_not_entrant(make_not_entrant) { }
 832   int  result() const { return _result; }
 833 
 834   void doit() {
 835     for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
 836       if (t-&gt;has_last_Java_frame()) {
<span class="line-modified"> 837         for (StackFrameStream fst(t, UseBiasedLocking); !fst.is_done(); fst.next()) {</span>
 838           frame* f = fst.current();
 839           if (f-&gt;can_be_deoptimized() &amp;&amp; !f-&gt;is_deoptimized_frame()) {
<span class="line-modified"> 840             RegisterMap* reg_map = fst.register_map();</span>
<span class="line-removed"> 841             Deoptimization::deoptimize(t, *f, reg_map);</span>
 842             if (_make_not_entrant) {
 843                 CompiledMethod* cm = CodeCache::find_compiled(f-&gt;pc());
 844                 assert(cm != NULL, &quot;sanity check&quot;);
 845                 cm-&gt;make_not_entrant();
 846             }
 847             ++_result;
 848           }
 849         }
 850       }
 851     }
 852   }
 853 };
 854 
 855 WB_ENTRY(jint, WB_DeoptimizeFrames(JNIEnv* env, jobject o, jboolean make_not_entrant))
 856   VM_WhiteBoxDeoptimizeFrames op(make_not_entrant == JNI_TRUE);
 857   VMThread::execute(&amp;op);
 858   return op.result();
 859 WB_END
 860 
 861 WB_ENTRY(void, WB_DeoptimizeAll(JNIEnv* env, jobject o))
</pre>
<hr />
<pre>
 878   result += CodeCache::mark_for_deoptimization(mh());
 879   if (result &gt; 0) {
 880     Deoptimization::deoptimize_all_marked();
 881   }
 882   return result;
 883 WB_END
 884 
 885 WB_ENTRY(jboolean, WB_IsMethodCompiled(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 886   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 887   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 888   MutexLocker mu(Compile_lock);
 889   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 890   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
 891   if (code == NULL) {
 892     return JNI_FALSE;
 893   }
 894   return (code-&gt;is_alive() &amp;&amp; !code-&gt;is_marked_for_deoptimization());
 895 WB_END
 896 
 897 WB_ENTRY(jboolean, WB_IsMethodCompilable(JNIEnv* env, jobject o, jobject method, jint comp_level, jboolean is_osr))
<span class="line-modified"> 898   if (method == NULL || comp_level &gt; MIN2((CompLevel) TieredStopAtLevel, CompLevel_highest_tier)) {</span>
 899     return false;
 900   }
 901   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 902   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 903   MutexLocker mu(Compile_lock);
 904   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 905   if (is_osr) {
 906     return CompilationPolicy::can_be_osr_compiled(mh, comp_level);
 907   } else {
 908     return CompilationPolicy::can_be_compiled(mh, comp_level);
 909   }
 910 WB_END
 911 
 912 WB_ENTRY(jboolean, WB_IsMethodQueuedForCompilation(JNIEnv* env, jobject o, jobject method))
 913   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 914   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 915   MutexLocker mu(Compile_lock);
 916   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 917   return mh-&gt;queued_for_compilation();
 918 WB_END
 919 
 920 WB_ENTRY(jboolean, WB_IsIntrinsicAvailable(JNIEnv* env, jobject o, jobject method, jobject compilation_context, jint compLevel))
<span class="line-modified"> 921   if (compLevel &lt; CompLevel_none || compLevel &gt; MIN2((CompLevel) TieredStopAtLevel, CompLevel_highest_tier)) {</span>
 922     return false; // Intrinsic is not available on a non-existent compilation level.
 923   }
 924   jmethodID method_id, compilation_context_id;
 925   method_id = reflected_method_to_jmid(thread, env, method);
 926   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 927   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(method_id));
 928 
 929   DirectiveSet* directive;
 930   AbstractCompiler* comp = CompileBroker::compiler((int)compLevel);
 931   assert(comp != NULL, &quot;compiler not available&quot;);
 932   if (compilation_context != NULL) {
 933     compilation_context_id = reflected_method_to_jmid(thread, env, compilation_context);
 934     CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 935     methodHandle cch(THREAD, Method::checked_resolve_jmethod_id(compilation_context_id));
 936     directive = DirectivesStack::getMatchingDirective(cch, comp);
 937   } else {
 938     // Calling with NULL matches default directive
 939     directive = DirectivesStack::getDefaultDirective(comp);
 940   }
 941   bool result = comp-&gt;is_intrinsic_available(mh, directive);
</pre>
<hr />
<pre>
 980 WB_END
 981 
 982 WB_ENTRY(jint, WB_GetCompileQueueSize(JNIEnv* env, jobject o, jint comp_level))
 983   if (comp_level == CompLevel_any) {
 984     return CompileBroker::queue_size(CompLevel_full_optimization) /* C2 */ +
 985         CompileBroker::queue_size(CompLevel_full_profile) /* C1 */;
 986   } else {
 987     return CompileBroker::queue_size(comp_level);
 988   }
 989 WB_END
 990 
 991 WB_ENTRY(jboolean, WB_TestSetForceInlineMethod(JNIEnv* env, jobject o, jobject method, jboolean value))
 992   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 993   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 994   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 995   bool result = mh-&gt;force_inline();
 996   mh-&gt;set_force_inline(value == JNI_TRUE);
 997   return result;
 998 WB_END
 999 












1000 bool WhiteBox::compile_method(Method* method, int comp_level, int bci, Thread* THREAD) {
1001   // Screen for unavailable/bad comp level or null method
1002   AbstractCompiler* comp = CompileBroker::compiler(comp_level);
1003   if (method == NULL) {
1004     tty-&gt;print_cr(&quot;WB error: request to compile NULL method&quot;);
1005     return false;
1006   }
<span class="line-modified">1007   if (comp_level &gt; MIN2((CompLevel) TieredStopAtLevel, CompLevel_highest_tier)) {</span>
1008     tty-&gt;print_cr(&quot;WB error: invalid compilation level %d&quot;, comp_level);
1009     return false;
1010   }
1011   if (comp == NULL) {
1012     tty-&gt;print_cr(&quot;WB error: no compiler for requested compilation level %d&quot;, comp_level);
1013     return false;
1014   }
1015 
1016   // Check if compilation is blocking
1017   methodHandle mh(THREAD, method);
1018   DirectiveSet* directive = DirectivesStack::getMatchingDirective(mh, comp);
1019   bool is_blocking = !directive-&gt;BackgroundCompilationOption;
1020   DirectivesStack::release(directive);
1021 
1022   // Compile method and check result
1023   nmethod* nm = CompileBroker::compile_method(mh, bci, comp_level, mh, mh-&gt;invocation_count(), CompileTask::Reason_Whitebox, THREAD);
1024   MutexLocker mu(THREAD, Compile_lock);
1025   bool is_queued = mh-&gt;queued_for_compilation();
1026   if ((!is_blocking &amp;&amp; is_queued) || nm != NULL) {
1027     return true;
</pre>
<hr />
<pre>
1114   int result = m-&gt;matches(mh);
1115   delete m;
1116   assert(result == 0 || result == 1, &quot;Result out of range&quot;);
1117   return result;
1118 WB_END
1119 
1120 WB_ENTRY(void, WB_MarkMethodProfiled(JNIEnv* env, jobject o, jobject method))
1121   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1122   CHECK_JNI_EXCEPTION(env);
1123   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1124 
1125   MethodData* mdo = mh-&gt;method_data();
1126   if (mdo == NULL) {
1127     Method::build_interpreter_method_data(mh, CHECK_AND_CLEAR);
1128     mdo = mh-&gt;method_data();
1129   }
1130   mdo-&gt;init();
1131   InvocationCounter* icnt = mdo-&gt;invocation_counter();
1132   InvocationCounter* bcnt = mdo-&gt;backedge_counter();
1133   // set i-counter according to TieredThresholdPolicy::is_method_profiled
<span class="line-modified">1134   icnt-&gt;set(InvocationCounter::wait_for_compile, Tier4MinInvocationThreshold);</span>
<span class="line-modified">1135   bcnt-&gt;set(InvocationCounter::wait_for_compile, Tier4CompileThreshold);</span>
1136 WB_END
1137 
1138 WB_ENTRY(void, WB_ClearMethodState(JNIEnv* env, jobject o, jobject method))
1139   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1140   CHECK_JNI_EXCEPTION(env);
1141   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1142   MutexLocker mu(THREAD, Compile_lock);
1143   MethodData* mdo = mh-&gt;method_data();
1144   MethodCounters* mcs = mh-&gt;method_counters();
1145 
1146   if (mdo != NULL) {
1147     mdo-&gt;init();
1148     ResourceMark rm(THREAD);
1149     int arg_count = mdo-&gt;method()-&gt;size_of_parameters();
1150     for (int i = 0; i &lt; arg_count; i++) {
1151       mdo-&gt;set_arg_modified(i, 0);
1152     }
1153     MutexLocker mu(THREAD, mdo-&gt;extra_data_lock());
1154     mdo-&gt;clean_method_data(/*always_clean*/true);
1155   }
</pre>
<hr />
<pre>
1467 
1468 CodeHeap* WhiteBox::get_code_heap(int blob_type) {
1469   guarantee(WhiteBoxAPI, &quot;internal testing API :: WhiteBox has to be enabled&quot;);
1470   return CodeCache::get_code_heap(blob_type);
1471 }
1472 
1473 struct CodeBlobStub {
1474   CodeBlobStub(const CodeBlob* blob) :
1475       name(os::strdup(blob-&gt;name())),
1476       size(blob-&gt;size()),
1477       blob_type(WhiteBox::get_blob_type(blob)),
1478       address((jlong) blob) { }
1479   ~CodeBlobStub() { os::free((void*) name); }
1480   const char* const name;
1481   const jint        size;
1482   const jint        blob_type;
1483   const jlong       address;
1484 };
1485 
1486 static jobjectArray codeBlob2objectArray(JavaThread* thread, JNIEnv* env, CodeBlobStub* cb) {

1487   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1488   CHECK_JNI_EXCEPTION_(env, NULL);
1489   jobjectArray result = env-&gt;NewObjectArray(4, clazz, NULL);
1490 
1491   jstring name = env-&gt;NewStringUTF(cb-&gt;name);
1492   CHECK_JNI_EXCEPTION_(env, NULL);
1493   env-&gt;SetObjectArrayElement(result, 0, name);
1494 
1495   jobject obj = integerBox(thread, env, cb-&gt;size);
1496   CHECK_JNI_EXCEPTION_(env, NULL);
1497   env-&gt;SetObjectArrayElement(result, 1, obj);
1498 
1499   obj = integerBox(thread, env, cb-&gt;blob_type);
1500   CHECK_JNI_EXCEPTION_(env, NULL);
1501   env-&gt;SetObjectArrayElement(result, 2, obj);
1502 
1503   obj = longBox(thread, env, cb-&gt;address);
1504   CHECK_JNI_EXCEPTION_(env, NULL);
1505   env-&gt;SetObjectArrayElement(result, 3, obj);
1506 
</pre>
<hr />
<pre>
1957   } else {
1958     return NULL;
1959   }
1960 WB_END
1961 
1962 WB_ENTRY(void, WB_LinkClass(JNIEnv* env, jobject wb, jclass clazz))
1963   Klass *k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1964   if (!k-&gt;is_instance_klass()) {
1965     return;
1966   }
1967   InstanceKlass *ik = InstanceKlass::cast(k);
1968   ik-&gt;link_class(THREAD); // may throw verification error
1969 WB_END
1970 
1971 WB_ENTRY(jboolean, WB_AreOpenArchiveHeapObjectsMapped(JNIEnv* env))
1972   return HeapShared::open_archive_heap_region_mapped();
1973 WB_END
1974 
1975 WB_ENTRY(jboolean, WB_IsCDSIncludedInVmBuild(JNIEnv* env))
1976 #if INCLUDE_CDS
<span class="line-removed">1977 # ifdef _LP64</span>
<span class="line-removed">1978     if (!UseCompressedOops || !UseCompressedClassPointers) {</span>
<span class="line-removed">1979       // On 64-bit VMs, CDS is supported only with compressed oops/pointers</span>
<span class="line-removed">1980       return false;</span>
<span class="line-removed">1981     }</span>
<span class="line-removed">1982 # endif // _LP64</span>
1983   return true;
1984 #else
1985   return false;
1986 #endif // INCLUDE_CDS
1987 WB_END
1988 
1989 WB_ENTRY(jboolean, WB_isC2OrJVMCIIncludedInVmBuild(JNIEnv* env))
1990 #if COMPILER2_OR_JVMCI
1991   return true;
1992 #else
1993   return false;
1994 #endif
1995 WB_END
1996 
1997 WB_ENTRY(jboolean, WB_IsJavaHeapArchiveSupported(JNIEnv* env))
1998   return HeapShared::is_heap_object_archiving_allowed();
1999 WB_END
2000 
2001 
2002 WB_ENTRY(jboolean, WB_IsJFRIncludedInVmBuild(JNIEnv* env))
</pre>
<hr />
<pre>
2156 
2157 // Checks that the library libfile has the noexecstack bit set.
2158 WB_ENTRY(jboolean, WB_CheckLibSpecifiesNoexecstack(JNIEnv* env, jobject o, jstring libfile))
2159   jboolean ret = false;
2160 #ifdef LINUX
2161   // Can&#39;t be in VM when we call JNI.
2162   ThreadToNativeFromVM ttnfv(thread);
2163   const char* lf = env-&gt;GetStringUTFChars(libfile, NULL);
2164   CHECK_JNI_EXCEPTION_(env, 0);
2165   ret = (jboolean) ElfFile::specifies_noexecstack(lf);
2166   env-&gt;ReleaseStringUTFChars(libfile, lf);
2167 #endif
2168   return ret;
2169 WB_END
2170 
2171 WB_ENTRY(jboolean, WB_IsContainerized(JNIEnv* env, jobject o))
2172   LINUX_ONLY(return OSContainer::is_containerized();)
2173   return false;
2174 WB_END
2175 

























2176 WB_ENTRY(void, WB_PrintOsInfo(JNIEnv* env, jobject o))
2177   os::print_os_info(tty);
2178 WB_END
2179 
2180 // Elf decoder
2181 WB_ENTRY(void, WB_DisableElfSectionCache(JNIEnv* env))
2182 #if !defined(_WINDOWS) &amp;&amp; !defined(__APPLE__) &amp;&amp; !defined(_AIX)
2183   ElfFile::_do_not_cache_elf_section = true;
2184 #endif
2185 WB_END
2186 
2187 WB_ENTRY(jlong, WB_ResolvedMethodItemsCount(JNIEnv* env, jobject o))
2188   return (jlong) ResolvedMethodTable::items_count();
2189 WB_END
2190 
2191 WB_ENTRY(jint, WB_ProtectionDomainRemovedCount(JNIEnv* env, jobject o))
2192   return (jint) SystemDictionary::pd_cache_table()-&gt;removed_entries_count();
2193 WB_END
2194 
2195 WB_ENTRY(jint, WB_AotLibrariesCount(JNIEnv* env, jobject o))
</pre>
<hr />
<pre>
2420   {CC&quot;isShared&quot;,           CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_IsShared },
2421   {CC&quot;isSharedClass&quot;,      CC&quot;(Ljava/lang/Class;)Z&quot;,  (void*)&amp;WB_IsSharedClass },
2422   {CC&quot;areSharedStringsIgnored&quot;,           CC&quot;()Z&quot;,    (void*)&amp;WB_AreSharedStringsIgnored },
2423   {CC&quot;getResolvedReferences&quot;, CC&quot;(Ljava/lang/Class;)Ljava/lang/Object;&quot;, (void*)&amp;WB_GetResolvedReferences},
2424   {CC&quot;linkClass&quot;,          CC&quot;(Ljava/lang/Class;)V&quot;,  (void*)&amp;WB_LinkClass},
2425   {CC&quot;areOpenArchiveHeapObjectsMapped&quot;,   CC&quot;()Z&quot;,    (void*)&amp;WB_AreOpenArchiveHeapObjectsMapped},
2426   {CC&quot;isCDSIncludedInVmBuild&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_IsCDSIncludedInVmBuild },
2427   {CC&quot;isJFRIncludedInVmBuild&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_IsJFRIncludedInVmBuild },
2428   {CC&quot;isC2OrJVMCIIncludedInVmBuild&quot;,      CC&quot;()Z&quot;,    (void*)&amp;WB_isC2OrJVMCIIncludedInVmBuild },
2429   {CC&quot;isJavaHeapArchiveSupported&quot;,        CC&quot;()Z&quot;,    (void*)&amp;WB_IsJavaHeapArchiveSupported },
2430   {CC&quot;cdsMemoryMappingFailed&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_CDSMemoryMappingFailed },
2431 
2432   {CC&quot;clearInlineCaches0&quot;,  CC&quot;(Z)V&quot;,                 (void*)&amp;WB_ClearInlineCaches },
2433   {CC&quot;handshakeWalkStack&quot;, CC&quot;(Ljava/lang/Thread;Z)I&quot;, (void*)&amp;WB_HandshakeWalkStack },
2434   {CC&quot;addCompilerDirective&quot;,    CC&quot;(Ljava/lang/String;)I&quot;,
2435                                                       (void*)&amp;WB_AddCompilerDirective },
2436   {CC&quot;removeCompilerDirective&quot;,   CC&quot;(I)V&quot;,           (void*)&amp;WB_RemoveCompilerDirective },
2437   {CC&quot;isGCSupported&quot;,             CC&quot;(I)Z&quot;,           (void*)&amp;WB_IsGCSupported},
2438   {CC&quot;isGCSelected&quot;,              CC&quot;(I)Z&quot;,           (void*)&amp;WB_IsGCSelected},
2439   {CC&quot;isGCSelectedErgonomically&quot;, CC&quot;()Z&quot;,            (void*)&amp;WB_IsGCSelectedErgonomically},
<span class="line-modified">2440   {CC&quot;supportsConcurrentGCPhaseControl&quot;, CC&quot;()Z&quot;,     (void*)&amp;WB_SupportsConcurrentGCPhaseControl},</span>
<span class="line-modified">2441   {CC&quot;requestConcurrentGCPhase0&quot;, CC&quot;(Ljava/lang/String;)Z&quot;,</span>
<span class="line-modified">2442                                                       (void*)&amp;WB_RequestConcurrentGCPhase},</span>



2443   {CC&quot;checkLibSpecifiesNoexecstack&quot;, CC&quot;(Ljava/lang/String;)Z&quot;,
2444                                                       (void*)&amp;WB_CheckLibSpecifiesNoexecstack},
2445   {CC&quot;isContainerized&quot;,           CC&quot;()Z&quot;,            (void*)&amp;WB_IsContainerized },



2446   {CC&quot;printOsInfo&quot;,               CC&quot;()V&quot;,            (void*)&amp;WB_PrintOsInfo },
2447   {CC&quot;disableElfSectionCache&quot;,    CC&quot;()V&quot;,            (void*)&amp;WB_DisableElfSectionCache },
2448   {CC&quot;resolvedMethodItemsCount&quot;,  CC&quot;()J&quot;,            (void*)&amp;WB_ResolvedMethodItemsCount },
2449   {CC&quot;protectionDomainRemovedCount&quot;,   CC&quot;()I&quot;,       (void*)&amp;WB_ProtectionDomainRemovedCount },
2450   {CC&quot;aotLibrariesCount&quot;, CC&quot;()I&quot;,                    (void*)&amp;WB_AotLibrariesCount },
2451   {CC&quot;getKlassMetadataSize&quot;, CC&quot;(Ljava/lang/Class;)I&quot;,(void*)&amp;WB_GetKlassMetadataSize},
2452 };
2453 
2454 
2455 #undef CC
2456 
2457 JVM_ENTRY(void, JVM_RegisterWhiteBoxMethods(JNIEnv* env, jclass wbclass))
2458   {
2459     if (WhiteBoxAPI) {
2460       // Make sure that wbclass is loaded by the null classloader
2461       InstanceKlass* ik = InstanceKlass::cast(JNIHandles::resolve(wbclass)-&gt;klass());
2462       Handle loader(THREAD, ik-&gt;class_loader());
2463       if (loader.is_null()) {
2464         WhiteBox::register_methods(env, wbclass, thread, methods, sizeof(methods) / sizeof(methods[0]));
2465         WhiteBox::set_used();
</pre>
</td>
<td>
<hr />
<pre>
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 
  27 #include &lt;new&gt;
  28 
  29 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  30 #include &quot;classfile/modules.hpp&quot;
  31 #include &quot;classfile/protectionDomainCache.hpp&quot;
  32 #include &quot;classfile/stringTable.hpp&quot;
  33 #include &quot;classfile/symbolTable.hpp&quot;
  34 #include &quot;code/codeCache.hpp&quot;
  35 #include &quot;compiler/compilationPolicy.hpp&quot;
  36 #include &quot;compiler/methodMatcher.hpp&quot;
  37 #include &quot;compiler/directivesParser.hpp&quot;
<span class="line-added">  38 #include &quot;gc/shared/concurrentGCBreakpoints.hpp&quot;</span>
  39 #include &quot;gc/shared/gcConfig.hpp&quot;
  40 #include &quot;gc/shared/genArguments.hpp&quot;
  41 #include &quot;gc/shared/genCollectedHeap.hpp&quot;
  42 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
  43 #include &quot;memory/filemap.hpp&quot;
  44 #include &quot;memory/heapShared.inline.hpp&quot;
  45 #include &quot;memory/metaspaceShared.hpp&quot;
  46 #include &quot;memory/metadataFactory.hpp&quot;
  47 #include &quot;memory/iterator.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;memory/oopFactory.hpp&quot;
  51 #include &quot;oops/array.hpp&quot;
  52 #include &quot;oops/compressedOops.hpp&quot;
  53 #include &quot;oops/constantPool.inline.hpp&quot;
  54 #include &quot;oops/method.inline.hpp&quot;
  55 #include &quot;oops/objArrayKlass.hpp&quot;
  56 #include &quot;oops/objArrayOop.inline.hpp&quot;
  57 #include &quot;oops/oop.inline.hpp&quot;
  58 #include &quot;oops/typeArrayOop.inline.hpp&quot;
</pre>
<hr />
<pre>
  90 #include &quot;gc/g1/g1ConcurrentMark.hpp&quot;
  91 #include &quot;gc/g1/g1ConcurrentMarkThread.hpp&quot;
  92 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  93 #include &quot;gc/g1/heterogeneousHeapRegionManager.hpp&quot;
  94 #endif // INCLUDE_G1GC
  95 #if INCLUDE_PARALLELGC
  96 #include &quot;gc/parallel/parallelScavengeHeap.inline.hpp&quot;
  97 #include &quot;gc/parallel/adjoiningGenerations.hpp&quot;
  98 #endif // INCLUDE_PARALLELGC
  99 #if INCLUDE_NMT
 100 #include &quot;services/mallocSiteTable.hpp&quot;
 101 #include &quot;services/memTracker.hpp&quot;
 102 #include &quot;utilities/nativeCallStack.hpp&quot;
 103 #endif // INCLUDE_NMT
 104 #if INCLUDE_AOT
 105 #include &quot;aot/aotLoader.hpp&quot;
 106 #endif // INCLUDE_AOT
 107 
 108 #ifdef LINUX
 109 #include &quot;osContainer_linux.hpp&quot;
<span class="line-added"> 110 #include &quot;cgroupSubsystem_linux.hpp&quot;</span>
 111 #endif
 112 
 113 #define SIZE_T_MAX_VALUE ((size_t) -1)
 114 
 115 #define CHECK_JNI_EXCEPTION_(env, value)                               \
 116   do {                                                                 \
 117     JavaThread* THREAD = JavaThread::thread_from_jni_environment(env); \
 118     THREAD-&gt;clear_pending_jni_exception_check();                       \
 119     if (HAS_PENDING_EXCEPTION) {                                       \
 120       return(value);                                                   \
 121     }                                                                  \
 122   } while (0)
 123 
 124 #define CHECK_JNI_EXCEPTION(env)                                       \
 125   do {                                                                 \
 126     JavaThread* THREAD = JavaThread::thread_from_jni_environment(env); \
 127     THREAD-&gt;clear_pending_jni_exception_check();                       \
 128     if (HAS_PENDING_EXCEPTION) {                                       \
 129       return;                                                          \
 130     }                                                                  \
</pre>
<hr />
<pre>
 379     return Universe::heap()-&gt;is_in(p);
 380   }
 381 #endif
 382   GenCollectedHeap* gch = GenCollectedHeap::heap();
 383   return !gch-&gt;is_in_young(p);
 384 WB_END
 385 
 386 WB_ENTRY(jlong, WB_GetObjectSize(JNIEnv* env, jobject o, jobject obj))
 387   oop p = JNIHandles::resolve(obj);
 388   return Universe::heap()-&gt;obj_size(p) * HeapWordSize;
 389 WB_END
 390 
 391 WB_ENTRY(jlong, WB_GetHeapSpaceAlignment(JNIEnv* env, jobject o))
 392   return (jlong)SpaceAlignment;
 393 WB_END
 394 
 395 WB_ENTRY(jlong, WB_GetHeapAlignment(JNIEnv* env, jobject o))
 396   return (jlong)HeapAlignment;
 397 WB_END
 398 
<span class="line-modified"> 399 WB_ENTRY(jboolean, WB_SupportsConcurrentGCBreakpoints(JNIEnv* env, jobject o))</span>
<span class="line-modified"> 400   return Universe::heap()-&gt;supports_concurrent_gc_breakpoints();</span>
 401 WB_END
 402 
<span class="line-modified"> 403 WB_ENTRY(void, WB_ConcurrentGCAcquireControl(JNIEnv* env, jobject o))</span>
<span class="line-modified"> 404   ConcurrentGCBreakpoints::acquire_control();</span>
<span class="line-added"> 405 WB_END</span>
<span class="line-added"> 406 </span>
<span class="line-added"> 407 WB_ENTRY(void, WB_ConcurrentGCReleaseControl(JNIEnv* env, jobject o))</span>
<span class="line-added"> 408   ConcurrentGCBreakpoints::release_control();</span>
<span class="line-added"> 409 WB_END</span>
<span class="line-added"> 410 </span>
<span class="line-added"> 411 WB_ENTRY(void, WB_ConcurrentGCRunToIdle(JNIEnv* env, jobject o))</span>
<span class="line-added"> 412   ConcurrentGCBreakpoints::run_to_idle();</span>
<span class="line-added"> 413 WB_END</span>
<span class="line-added"> 414 </span>
<span class="line-added"> 415 WB_ENTRY(jboolean, WB_ConcurrentGCRunTo(JNIEnv* env, jobject o, jobject at))</span>
<span class="line-added"> 416   Handle h_name(THREAD, JNIHandles::resolve(at));</span>
 417   ResourceMark rm;
 418   const char* c_name = java_lang_String::as_utf8_string(h_name());
<span class="line-modified"> 419   return ConcurrentGCBreakpoints::run_to(c_name);</span>
 420 WB_END
 421 
 422 #if INCLUDE_G1GC
 423 
 424 WB_ENTRY(jboolean, WB_G1IsHumongous(JNIEnv* env, jobject o, jobject obj))
 425   if (UseG1GC) {
 426     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 427     oop result = JNIHandles::resolve(obj);
 428     const HeapRegion* hr = g1h-&gt;heap_region_containing(result);
 429     return hr-&gt;is_humongous();
 430   }
 431   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1IsHumongous: G1 GC is not enabled&quot;);
 432 WB_END
 433 
 434 WB_ENTRY(jboolean, WB_G1BelongsToHumongousRegion(JNIEnv* env, jobject o, jlong addr))
 435   if (UseG1GC) {
 436     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 437     const HeapRegion* hr = g1h-&gt;heap_region_containing((void*) addr);
 438     return hr-&gt;is_humongous();
 439   }
</pre>
<hr />
<pre>
 818   return (jlong)arena;
 819 WB_END
 820 
 821 WB_ENTRY(void, WB_NMTFreeArena(JNIEnv* env, jobject o, jlong arena))
 822   Arena* a = (Arena*)arena;
 823   delete a;
 824 WB_END
 825 
 826 WB_ENTRY(void, WB_NMTArenaMalloc(JNIEnv* env, jobject o, jlong arena, jlong size))
 827   Arena* a = (Arena*)arena;
 828   a-&gt;Amalloc(size_t(size));
 829 WB_END
 830 #endif // INCLUDE_NMT
 831 
 832 static jmethodID reflected_method_to_jmid(JavaThread* thread, JNIEnv* env, jobject method) {
 833   assert(method != NULL, &quot;method should not be null&quot;);
 834   ThreadToNativeFromVM ttn(thread);
 835   return env-&gt;FromReflectedMethod(method);
 836 }
 837 
<span class="line-added"> 838 static CompLevel highestCompLevel() {</span>
<span class="line-added"> 839   return TieredCompilation ? MIN2((CompLevel) TieredStopAtLevel, CompLevel_highest_tier) : CompLevel_highest_tier;</span>
<span class="line-added"> 840 }</span>
<span class="line-added"> 841 </span>
 842 // Deoptimizes all compiled frames and makes nmethods not entrant if it&#39;s requested
 843 class VM_WhiteBoxDeoptimizeFrames : public VM_WhiteBoxOperation {
 844  private:
 845   int _result;
 846   const bool _make_not_entrant;
 847  public:
 848   VM_WhiteBoxDeoptimizeFrames(bool make_not_entrant) :
 849         _result(0), _make_not_entrant(make_not_entrant) { }
 850   int  result() const { return _result; }
 851 
 852   void doit() {
 853     for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
 854       if (t-&gt;has_last_Java_frame()) {
<span class="line-modified"> 855         for (StackFrameStream fst(t, false); !fst.is_done(); fst.next()) {</span>
 856           frame* f = fst.current();
 857           if (f-&gt;can_be_deoptimized() &amp;&amp; !f-&gt;is_deoptimized_frame()) {
<span class="line-modified"> 858             Deoptimization::deoptimize(t, *f);</span>

 859             if (_make_not_entrant) {
 860                 CompiledMethod* cm = CodeCache::find_compiled(f-&gt;pc());
 861                 assert(cm != NULL, &quot;sanity check&quot;);
 862                 cm-&gt;make_not_entrant();
 863             }
 864             ++_result;
 865           }
 866         }
 867       }
 868     }
 869   }
 870 };
 871 
 872 WB_ENTRY(jint, WB_DeoptimizeFrames(JNIEnv* env, jobject o, jboolean make_not_entrant))
 873   VM_WhiteBoxDeoptimizeFrames op(make_not_entrant == JNI_TRUE);
 874   VMThread::execute(&amp;op);
 875   return op.result();
 876 WB_END
 877 
 878 WB_ENTRY(void, WB_DeoptimizeAll(JNIEnv* env, jobject o))
</pre>
<hr />
<pre>
 895   result += CodeCache::mark_for_deoptimization(mh());
 896   if (result &gt; 0) {
 897     Deoptimization::deoptimize_all_marked();
 898   }
 899   return result;
 900 WB_END
 901 
 902 WB_ENTRY(jboolean, WB_IsMethodCompiled(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 903   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 904   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 905   MutexLocker mu(Compile_lock);
 906   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 907   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
 908   if (code == NULL) {
 909     return JNI_FALSE;
 910   }
 911   return (code-&gt;is_alive() &amp;&amp; !code-&gt;is_marked_for_deoptimization());
 912 WB_END
 913 
 914 WB_ENTRY(jboolean, WB_IsMethodCompilable(JNIEnv* env, jobject o, jobject method, jint comp_level, jboolean is_osr))
<span class="line-modified"> 915   if (method == NULL || comp_level &gt; highestCompLevel()) {</span>
 916     return false;
 917   }
 918   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 919   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 920   MutexLocker mu(Compile_lock);
 921   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 922   if (is_osr) {
 923     return CompilationPolicy::can_be_osr_compiled(mh, comp_level);
 924   } else {
 925     return CompilationPolicy::can_be_compiled(mh, comp_level);
 926   }
 927 WB_END
 928 
 929 WB_ENTRY(jboolean, WB_IsMethodQueuedForCompilation(JNIEnv* env, jobject o, jobject method))
 930   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 931   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 932   MutexLocker mu(Compile_lock);
 933   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 934   return mh-&gt;queued_for_compilation();
 935 WB_END
 936 
 937 WB_ENTRY(jboolean, WB_IsIntrinsicAvailable(JNIEnv* env, jobject o, jobject method, jobject compilation_context, jint compLevel))
<span class="line-modified"> 938   if (compLevel &lt; CompLevel_none || compLevel &gt; highestCompLevel()) {</span>
 939     return false; // Intrinsic is not available on a non-existent compilation level.
 940   }
 941   jmethodID method_id, compilation_context_id;
 942   method_id = reflected_method_to_jmid(thread, env, method);
 943   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 944   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(method_id));
 945 
 946   DirectiveSet* directive;
 947   AbstractCompiler* comp = CompileBroker::compiler((int)compLevel);
 948   assert(comp != NULL, &quot;compiler not available&quot;);
 949   if (compilation_context != NULL) {
 950     compilation_context_id = reflected_method_to_jmid(thread, env, compilation_context);
 951     CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 952     methodHandle cch(THREAD, Method::checked_resolve_jmethod_id(compilation_context_id));
 953     directive = DirectivesStack::getMatchingDirective(cch, comp);
 954   } else {
 955     // Calling with NULL matches default directive
 956     directive = DirectivesStack::getDefaultDirective(comp);
 957   }
 958   bool result = comp-&gt;is_intrinsic_available(mh, directive);
</pre>
<hr />
<pre>
 997 WB_END
 998 
 999 WB_ENTRY(jint, WB_GetCompileQueueSize(JNIEnv* env, jobject o, jint comp_level))
1000   if (comp_level == CompLevel_any) {
1001     return CompileBroker::queue_size(CompLevel_full_optimization) /* C2 */ +
1002         CompileBroker::queue_size(CompLevel_full_profile) /* C1 */;
1003   } else {
1004     return CompileBroker::queue_size(comp_level);
1005   }
1006 WB_END
1007 
1008 WB_ENTRY(jboolean, WB_TestSetForceInlineMethod(JNIEnv* env, jobject o, jobject method, jboolean value))
1009   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1010   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1011   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1012   bool result = mh-&gt;force_inline();
1013   mh-&gt;set_force_inline(value == JNI_TRUE);
1014   return result;
1015 WB_END
1016 
<span class="line-added">1017 #ifdef LINUX</span>
<span class="line-added">1018 bool WhiteBox::validate_cgroup(const char* proc_cgroups,</span>
<span class="line-added">1019                                const char* proc_self_cgroup,</span>
<span class="line-added">1020                                const char* proc_self_mountinfo,</span>
<span class="line-added">1021                                u1* cg_flags) {</span>
<span class="line-added">1022   CgroupInfo cg_infos[4];</span>
<span class="line-added">1023   return CgroupSubsystemFactory::determine_type(cg_infos, proc_cgroups,</span>
<span class="line-added">1024                                                     proc_self_cgroup,</span>
<span class="line-added">1025                                                     proc_self_mountinfo, cg_flags);</span>
<span class="line-added">1026 }</span>
<span class="line-added">1027 #endif</span>
<span class="line-added">1028 </span>
1029 bool WhiteBox::compile_method(Method* method, int comp_level, int bci, Thread* THREAD) {
1030   // Screen for unavailable/bad comp level or null method
1031   AbstractCompiler* comp = CompileBroker::compiler(comp_level);
1032   if (method == NULL) {
1033     tty-&gt;print_cr(&quot;WB error: request to compile NULL method&quot;);
1034     return false;
1035   }
<span class="line-modified">1036   if (comp_level &gt; highestCompLevel()) {</span>
1037     tty-&gt;print_cr(&quot;WB error: invalid compilation level %d&quot;, comp_level);
1038     return false;
1039   }
1040   if (comp == NULL) {
1041     tty-&gt;print_cr(&quot;WB error: no compiler for requested compilation level %d&quot;, comp_level);
1042     return false;
1043   }
1044 
1045   // Check if compilation is blocking
1046   methodHandle mh(THREAD, method);
1047   DirectiveSet* directive = DirectivesStack::getMatchingDirective(mh, comp);
1048   bool is_blocking = !directive-&gt;BackgroundCompilationOption;
1049   DirectivesStack::release(directive);
1050 
1051   // Compile method and check result
1052   nmethod* nm = CompileBroker::compile_method(mh, bci, comp_level, mh, mh-&gt;invocation_count(), CompileTask::Reason_Whitebox, THREAD);
1053   MutexLocker mu(THREAD, Compile_lock);
1054   bool is_queued = mh-&gt;queued_for_compilation();
1055   if ((!is_blocking &amp;&amp; is_queued) || nm != NULL) {
1056     return true;
</pre>
<hr />
<pre>
1143   int result = m-&gt;matches(mh);
1144   delete m;
1145   assert(result == 0 || result == 1, &quot;Result out of range&quot;);
1146   return result;
1147 WB_END
1148 
1149 WB_ENTRY(void, WB_MarkMethodProfiled(JNIEnv* env, jobject o, jobject method))
1150   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1151   CHECK_JNI_EXCEPTION(env);
1152   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1153 
1154   MethodData* mdo = mh-&gt;method_data();
1155   if (mdo == NULL) {
1156     Method::build_interpreter_method_data(mh, CHECK_AND_CLEAR);
1157     mdo = mh-&gt;method_data();
1158   }
1159   mdo-&gt;init();
1160   InvocationCounter* icnt = mdo-&gt;invocation_counter();
1161   InvocationCounter* bcnt = mdo-&gt;backedge_counter();
1162   // set i-counter according to TieredThresholdPolicy::is_method_profiled
<span class="line-modified">1163   icnt-&gt;set(Tier4MinInvocationThreshold);</span>
<span class="line-modified">1164   bcnt-&gt;set(Tier4CompileThreshold);</span>
1165 WB_END
1166 
1167 WB_ENTRY(void, WB_ClearMethodState(JNIEnv* env, jobject o, jobject method))
1168   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1169   CHECK_JNI_EXCEPTION(env);
1170   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1171   MutexLocker mu(THREAD, Compile_lock);
1172   MethodData* mdo = mh-&gt;method_data();
1173   MethodCounters* mcs = mh-&gt;method_counters();
1174 
1175   if (mdo != NULL) {
1176     mdo-&gt;init();
1177     ResourceMark rm(THREAD);
1178     int arg_count = mdo-&gt;method()-&gt;size_of_parameters();
1179     for (int i = 0; i &lt; arg_count; i++) {
1180       mdo-&gt;set_arg_modified(i, 0);
1181     }
1182     MutexLocker mu(THREAD, mdo-&gt;extra_data_lock());
1183     mdo-&gt;clean_method_data(/*always_clean*/true);
1184   }
</pre>
<hr />
<pre>
1496 
1497 CodeHeap* WhiteBox::get_code_heap(int blob_type) {
1498   guarantee(WhiteBoxAPI, &quot;internal testing API :: WhiteBox has to be enabled&quot;);
1499   return CodeCache::get_code_heap(blob_type);
1500 }
1501 
1502 struct CodeBlobStub {
1503   CodeBlobStub(const CodeBlob* blob) :
1504       name(os::strdup(blob-&gt;name())),
1505       size(blob-&gt;size()),
1506       blob_type(WhiteBox::get_blob_type(blob)),
1507       address((jlong) blob) { }
1508   ~CodeBlobStub() { os::free((void*) name); }
1509   const char* const name;
1510   const jint        size;
1511   const jint        blob_type;
1512   const jlong       address;
1513 };
1514 
1515 static jobjectArray codeBlob2objectArray(JavaThread* thread, JNIEnv* env, CodeBlobStub* cb) {
<span class="line-added">1516   ResourceMark rm;</span>
1517   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1518   CHECK_JNI_EXCEPTION_(env, NULL);
1519   jobjectArray result = env-&gt;NewObjectArray(4, clazz, NULL);
1520 
1521   jstring name = env-&gt;NewStringUTF(cb-&gt;name);
1522   CHECK_JNI_EXCEPTION_(env, NULL);
1523   env-&gt;SetObjectArrayElement(result, 0, name);
1524 
1525   jobject obj = integerBox(thread, env, cb-&gt;size);
1526   CHECK_JNI_EXCEPTION_(env, NULL);
1527   env-&gt;SetObjectArrayElement(result, 1, obj);
1528 
1529   obj = integerBox(thread, env, cb-&gt;blob_type);
1530   CHECK_JNI_EXCEPTION_(env, NULL);
1531   env-&gt;SetObjectArrayElement(result, 2, obj);
1532 
1533   obj = longBox(thread, env, cb-&gt;address);
1534   CHECK_JNI_EXCEPTION_(env, NULL);
1535   env-&gt;SetObjectArrayElement(result, 3, obj);
1536 
</pre>
<hr />
<pre>
1987   } else {
1988     return NULL;
1989   }
1990 WB_END
1991 
1992 WB_ENTRY(void, WB_LinkClass(JNIEnv* env, jobject wb, jclass clazz))
1993   Klass *k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1994   if (!k-&gt;is_instance_klass()) {
1995     return;
1996   }
1997   InstanceKlass *ik = InstanceKlass::cast(k);
1998   ik-&gt;link_class(THREAD); // may throw verification error
1999 WB_END
2000 
2001 WB_ENTRY(jboolean, WB_AreOpenArchiveHeapObjectsMapped(JNIEnv* env))
2002   return HeapShared::open_archive_heap_region_mapped();
2003 WB_END
2004 
2005 WB_ENTRY(jboolean, WB_IsCDSIncludedInVmBuild(JNIEnv* env))
2006 #if INCLUDE_CDS






2007   return true;
2008 #else
2009   return false;
2010 #endif // INCLUDE_CDS
2011 WB_END
2012 
2013 WB_ENTRY(jboolean, WB_isC2OrJVMCIIncludedInVmBuild(JNIEnv* env))
2014 #if COMPILER2_OR_JVMCI
2015   return true;
2016 #else
2017   return false;
2018 #endif
2019 WB_END
2020 
2021 WB_ENTRY(jboolean, WB_IsJavaHeapArchiveSupported(JNIEnv* env))
2022   return HeapShared::is_heap_object_archiving_allowed();
2023 WB_END
2024 
2025 
2026 WB_ENTRY(jboolean, WB_IsJFRIncludedInVmBuild(JNIEnv* env))
</pre>
<hr />
<pre>
2180 
2181 // Checks that the library libfile has the noexecstack bit set.
2182 WB_ENTRY(jboolean, WB_CheckLibSpecifiesNoexecstack(JNIEnv* env, jobject o, jstring libfile))
2183   jboolean ret = false;
2184 #ifdef LINUX
2185   // Can&#39;t be in VM when we call JNI.
2186   ThreadToNativeFromVM ttnfv(thread);
2187   const char* lf = env-&gt;GetStringUTFChars(libfile, NULL);
2188   CHECK_JNI_EXCEPTION_(env, 0);
2189   ret = (jboolean) ElfFile::specifies_noexecstack(lf);
2190   env-&gt;ReleaseStringUTFChars(libfile, lf);
2191 #endif
2192   return ret;
2193 WB_END
2194 
2195 WB_ENTRY(jboolean, WB_IsContainerized(JNIEnv* env, jobject o))
2196   LINUX_ONLY(return OSContainer::is_containerized();)
2197   return false;
2198 WB_END
2199 
<span class="line-added">2200 WB_ENTRY(jint, WB_ValidateCgroup(JNIEnv* env,</span>
<span class="line-added">2201                                     jobject o,</span>
<span class="line-added">2202                                     jstring proc_cgroups,</span>
<span class="line-added">2203                                     jstring proc_self_cgroup,</span>
<span class="line-added">2204                                     jstring proc_self_mountinfo))</span>
<span class="line-added">2205   jint ret = 0;</span>
<span class="line-added">2206 #ifdef LINUX</span>
<span class="line-added">2207   ThreadToNativeFromVM ttnfv(thread);</span>
<span class="line-added">2208   const char* p_cgroups = env-&gt;GetStringUTFChars(proc_cgroups, NULL);</span>
<span class="line-added">2209   CHECK_JNI_EXCEPTION_(env, 0);</span>
<span class="line-added">2210   const char* p_s_cgroup = env-&gt;GetStringUTFChars(proc_self_cgroup, NULL);</span>
<span class="line-added">2211   CHECK_JNI_EXCEPTION_(env, 0);</span>
<span class="line-added">2212   const char* p_s_mountinfo = env-&gt;GetStringUTFChars(proc_self_mountinfo, NULL);</span>
<span class="line-added">2213   CHECK_JNI_EXCEPTION_(env, 0);</span>
<span class="line-added">2214   u1 cg_type_flags = 0;</span>
<span class="line-added">2215   // This sets cg_type_flags</span>
<span class="line-added">2216   WhiteBox::validate_cgroup(p_cgroups, p_s_cgroup, p_s_mountinfo, &amp;cg_type_flags);</span>
<span class="line-added">2217   ret = (jint)cg_type_flags;</span>
<span class="line-added">2218   env-&gt;ReleaseStringUTFChars(proc_cgroups, p_cgroups);</span>
<span class="line-added">2219   env-&gt;ReleaseStringUTFChars(proc_self_cgroup, p_s_cgroup);</span>
<span class="line-added">2220   env-&gt;ReleaseStringUTFChars(proc_self_mountinfo, p_s_mountinfo);</span>
<span class="line-added">2221 #endif</span>
<span class="line-added">2222   return ret;</span>
<span class="line-added">2223 WB_END</span>
<span class="line-added">2224 </span>
2225 WB_ENTRY(void, WB_PrintOsInfo(JNIEnv* env, jobject o))
2226   os::print_os_info(tty);
2227 WB_END
2228 
2229 // Elf decoder
2230 WB_ENTRY(void, WB_DisableElfSectionCache(JNIEnv* env))
2231 #if !defined(_WINDOWS) &amp;&amp; !defined(__APPLE__) &amp;&amp; !defined(_AIX)
2232   ElfFile::_do_not_cache_elf_section = true;
2233 #endif
2234 WB_END
2235 
2236 WB_ENTRY(jlong, WB_ResolvedMethodItemsCount(JNIEnv* env, jobject o))
2237   return (jlong) ResolvedMethodTable::items_count();
2238 WB_END
2239 
2240 WB_ENTRY(jint, WB_ProtectionDomainRemovedCount(JNIEnv* env, jobject o))
2241   return (jint) SystemDictionary::pd_cache_table()-&gt;removed_entries_count();
2242 WB_END
2243 
2244 WB_ENTRY(jint, WB_AotLibrariesCount(JNIEnv* env, jobject o))
</pre>
<hr />
<pre>
2469   {CC&quot;isShared&quot;,           CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_IsShared },
2470   {CC&quot;isSharedClass&quot;,      CC&quot;(Ljava/lang/Class;)Z&quot;,  (void*)&amp;WB_IsSharedClass },
2471   {CC&quot;areSharedStringsIgnored&quot;,           CC&quot;()Z&quot;,    (void*)&amp;WB_AreSharedStringsIgnored },
2472   {CC&quot;getResolvedReferences&quot;, CC&quot;(Ljava/lang/Class;)Ljava/lang/Object;&quot;, (void*)&amp;WB_GetResolvedReferences},
2473   {CC&quot;linkClass&quot;,          CC&quot;(Ljava/lang/Class;)V&quot;,  (void*)&amp;WB_LinkClass},
2474   {CC&quot;areOpenArchiveHeapObjectsMapped&quot;,   CC&quot;()Z&quot;,    (void*)&amp;WB_AreOpenArchiveHeapObjectsMapped},
2475   {CC&quot;isCDSIncludedInVmBuild&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_IsCDSIncludedInVmBuild },
2476   {CC&quot;isJFRIncludedInVmBuild&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_IsJFRIncludedInVmBuild },
2477   {CC&quot;isC2OrJVMCIIncludedInVmBuild&quot;,      CC&quot;()Z&quot;,    (void*)&amp;WB_isC2OrJVMCIIncludedInVmBuild },
2478   {CC&quot;isJavaHeapArchiveSupported&quot;,        CC&quot;()Z&quot;,    (void*)&amp;WB_IsJavaHeapArchiveSupported },
2479   {CC&quot;cdsMemoryMappingFailed&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_CDSMemoryMappingFailed },
2480 
2481   {CC&quot;clearInlineCaches0&quot;,  CC&quot;(Z)V&quot;,                 (void*)&amp;WB_ClearInlineCaches },
2482   {CC&quot;handshakeWalkStack&quot;, CC&quot;(Ljava/lang/Thread;Z)I&quot;, (void*)&amp;WB_HandshakeWalkStack },
2483   {CC&quot;addCompilerDirective&quot;,    CC&quot;(Ljava/lang/String;)I&quot;,
2484                                                       (void*)&amp;WB_AddCompilerDirective },
2485   {CC&quot;removeCompilerDirective&quot;,   CC&quot;(I)V&quot;,           (void*)&amp;WB_RemoveCompilerDirective },
2486   {CC&quot;isGCSupported&quot;,             CC&quot;(I)Z&quot;,           (void*)&amp;WB_IsGCSupported},
2487   {CC&quot;isGCSelected&quot;,              CC&quot;(I)Z&quot;,           (void*)&amp;WB_IsGCSelected},
2488   {CC&quot;isGCSelectedErgonomically&quot;, CC&quot;()Z&quot;,            (void*)&amp;WB_IsGCSelectedErgonomically},
<span class="line-modified">2489   {CC&quot;supportsConcurrentGCBreakpoints&quot;, CC&quot;()Z&quot;,      (void*)&amp;WB_SupportsConcurrentGCBreakpoints},</span>
<span class="line-modified">2490   {CC&quot;concurrentGCAcquireControl0&quot;, CC&quot;()V&quot;,          (void*)&amp;WB_ConcurrentGCAcquireControl},</span>
<span class="line-modified">2491   {CC&quot;concurrentGCReleaseControl0&quot;, CC&quot;()V&quot;,          (void*)&amp;WB_ConcurrentGCReleaseControl},</span>
<span class="line-added">2492   {CC&quot;concurrentGCRunToIdle0&quot;,    CC&quot;()V&quot;,            (void*)&amp;WB_ConcurrentGCRunToIdle},</span>
<span class="line-added">2493   {CC&quot;concurrentGCRunTo0&quot;,        CC&quot;(Ljava/lang/String;)Z&quot;,</span>
<span class="line-added">2494                                                       (void*)&amp;WB_ConcurrentGCRunTo},</span>
2495   {CC&quot;checkLibSpecifiesNoexecstack&quot;, CC&quot;(Ljava/lang/String;)Z&quot;,
2496                                                       (void*)&amp;WB_CheckLibSpecifiesNoexecstack},
2497   {CC&quot;isContainerized&quot;,           CC&quot;()Z&quot;,            (void*)&amp;WB_IsContainerized },
<span class="line-added">2498   {CC&quot;validateCgroup&quot;,</span>
<span class="line-added">2499       CC&quot;(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)I&quot;,</span>
<span class="line-added">2500                                                       (void*)&amp;WB_ValidateCgroup },</span>
2501   {CC&quot;printOsInfo&quot;,               CC&quot;()V&quot;,            (void*)&amp;WB_PrintOsInfo },
2502   {CC&quot;disableElfSectionCache&quot;,    CC&quot;()V&quot;,            (void*)&amp;WB_DisableElfSectionCache },
2503   {CC&quot;resolvedMethodItemsCount&quot;,  CC&quot;()J&quot;,            (void*)&amp;WB_ResolvedMethodItemsCount },
2504   {CC&quot;protectionDomainRemovedCount&quot;,   CC&quot;()I&quot;,       (void*)&amp;WB_ProtectionDomainRemovedCount },
2505   {CC&quot;aotLibrariesCount&quot;, CC&quot;()I&quot;,                    (void*)&amp;WB_AotLibrariesCount },
2506   {CC&quot;getKlassMetadataSize&quot;, CC&quot;(Ljava/lang/Class;)I&quot;,(void*)&amp;WB_GetKlassMetadataSize},
2507 };
2508 
2509 
2510 #undef CC
2511 
2512 JVM_ENTRY(void, JVM_RegisterWhiteBoxMethods(JNIEnv* env, jclass wbclass))
2513   {
2514     if (WhiteBoxAPI) {
2515       // Make sure that wbclass is loaded by the null classloader
2516       InstanceKlass* ik = InstanceKlass::cast(JNIHandles::resolve(wbclass)-&gt;klass());
2517       Handle loader(THREAD, ik-&gt;class_loader());
2518       if (loader.is_null()) {
2519         WhiteBox::register_methods(env, wbclass, thread, methods, sizeof(methods) / sizeof(methods[0]));
2520         WhiteBox::set_used();
</pre>
</td>
</tr>
</table>
<center><a href="stackwalk.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="whitebox.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
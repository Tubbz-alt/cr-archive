<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/oops/symbol.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="symbol.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../opto/arraycopynode.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/symbol.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 95,28 ***</span>
  // type without virtual functions.
  class ClassLoaderData;
  
  // Set _refcount to PERM_REFCOUNT to prevent the Symbol from being freed.
  #ifndef PERM_REFCOUNT
<span class="line-modified">! #define PERM_REFCOUNT ((1 &lt;&lt; 16) - 1)</span>
  #endif
  
  class Symbol : public MetaspaceObj {
    friend class VMStructs;
    friend class SymbolTable;
  
   private:
  
<span class="line-modified">!   // This is an int because it needs atomic operation on the refcount.  Mask length</span>
    // in high half word. length is the number of UTF8 characters in the symbol
<span class="line-modified">!   volatile uint32_t _length_and_refcount;</span>
<span class="line-modified">!   short _identity_hash;</span>
    u1 _body[2];
  
    enum {
<span class="line-modified">!     // max_symbol_length must fit into the top 16 bits of _length_and_refcount</span>
<span class="line-removed">-     max_symbol_length = (1 &lt;&lt; 16) -1</span>
    };
  
    static int byte_size(int length) {
      // minimum number of natural words needed to hold these bits (no non-heap version)
      return (int)(sizeof(Symbol) + (length &gt; 2 ? length - 2 : 0));
<span class="line-new-header">--- 95,27 ---</span>
  // type without virtual functions.
  class ClassLoaderData;
  
  // Set _refcount to PERM_REFCOUNT to prevent the Symbol from being freed.
  #ifndef PERM_REFCOUNT
<span class="line-modified">! #define PERM_REFCOUNT 0xffff</span>
  #endif
  
  class Symbol : public MetaspaceObj {
    friend class VMStructs;
    friend class SymbolTable;
  
   private:
  
<span class="line-modified">!   // This is an int because it needs atomic operation on the refcount.  Mask hash</span>
    // in high half word. length is the number of UTF8 characters in the symbol
<span class="line-modified">!   volatile uint32_t _hash_and_refcount;</span>
<span class="line-modified">!   u2 _length;</span>
    u1 _body[2];
  
    enum {
<span class="line-modified">!     max_symbol_length = 0xffff</span>
    };
  
    static int byte_size(int length) {
      // minimum number of natural words needed to hold these bits (no non-heap version)
      return (int)(sizeof(Symbol) + (length &gt; 2 ? length - 2 : 0));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 135,15 ***</span>
    void* operator new(size_t size, int len) throw();
    void* operator new(size_t size, int len, Arena* arena) throw();
  
    void  operator delete(void* p);
  
<span class="line-modified">!   static int extract_length(uint32_t value)   { return value &gt;&gt; 16; }</span>
    static int extract_refcount(uint32_t value) { return value &amp; 0xffff; }
<span class="line-modified">!   static uint32_t pack_length_and_refcount(int length, int refcount);</span>
  
<span class="line-modified">!   int length() const   { return extract_length(_length_and_refcount); }</span>
  
   public:
    // Low-level access (used with care, since not GC-safe)
    const u1* base() const { return &amp;_body[0]; }
  
<span class="line-new-header">--- 134,15 ---</span>
    void* operator new(size_t size, int len) throw();
    void* operator new(size_t size, int len, Arena* arena) throw();
  
    void  operator delete(void* p);
  
<span class="line-modified">!   static short extract_hash(uint32_t value)   { return (short)(value &gt;&gt; 16); }</span>
    static int extract_refcount(uint32_t value) { return value &amp; 0xffff; }
<span class="line-modified">!   static uint32_t pack_hash_and_refcount(short hash, int refcount);</span>
  
<span class="line-modified">!   int length() const   { return _length; }</span>
  
   public:
    // Low-level access (used with care, since not GC-safe)
    const u1* base() const { return &amp;_body[0]; }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 155,20 ***</span>
  
    // Returns the largest size symbol we can safely hold.
    static int max_length() { return max_symbol_length; }
    unsigned identity_hash() const {
      unsigned addr_bits = (unsigned)((uintptr_t)this &gt;&gt; (LogMinObjAlignmentInBytes + 3));
<span class="line-modified">!     return ((unsigned)_identity_hash &amp; 0xffff) |</span>
             ((addr_bits ^ (length() &lt;&lt; 8) ^ (( _body[0] &lt;&lt; 8) | _body[1])) &lt;&lt; 16);
    }
  
    // Reference counting.  See comments above this class for when to use.
<span class="line-modified">!   int refcount() const { return extract_refcount(_length_and_refcount); }</span>
    bool try_increment_refcount();
    void increment_refcount();
    void decrement_refcount();
<span class="line-modified">!   bool is_permanent() {</span>
      return (refcount() == PERM_REFCOUNT);
    }
    void set_permanent();
    void make_permanent();
  
<span class="line-new-header">--- 154,20 ---</span>
  
    // Returns the largest size symbol we can safely hold.
    static int max_length() { return max_symbol_length; }
    unsigned identity_hash() const {
      unsigned addr_bits = (unsigned)((uintptr_t)this &gt;&gt; (LogMinObjAlignmentInBytes + 3));
<span class="line-modified">!     return ((unsigned)extract_hash(_hash_and_refcount) &amp; 0xffff) |</span>
             ((addr_bits ^ (length() &lt;&lt; 8) ^ (( _body[0] &lt;&lt; 8) | _body[1])) &lt;&lt; 16);
    }
  
    // Reference counting.  See comments above this class for when to use.
<span class="line-modified">!   int refcount() const { return extract_refcount(_hash_and_refcount); }</span>
    bool try_increment_refcount();
    void increment_refcount();
    void decrement_refcount();
<span class="line-modified">!   bool is_permanent() const {</span>
      return (refcount() == PERM_REFCOUNT);
    }
    void set_permanent();
    void make_permanent();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 209,16 ***</span>
    }
    bool ends_with(const char* suffix) const {
      return ends_with(suffix, (int) strlen(suffix));
    }
    bool ends_with(int suffix_char) const {
<span class="line-modified">!     return contains_byte_at(utf8_length()-1, suffix_char);</span>
    }
    // Tests if the symbol contains the given utf8 substring
<span class="line-modified">!   // or byte at the given byte position.</span>
<span class="line-modified">!   bool contains_utf8_at(int position, const char* substring, int len) const;</span>
<span class="line-modified">!   bool contains_byte_at(int position, char code_byte) const;</span>
  
    // Tests if the symbol starts with the given prefix.
    int index_of_at(int i, const char* str, int len) const;
  
    // Three-way compare for sorting; returns -1/0/1 if receiver is &lt;/==/&gt; than arg
<span class="line-new-header">--- 208,28 ---</span>
    }
    bool ends_with(const char* suffix) const {
      return ends_with(suffix, (int) strlen(suffix));
    }
    bool ends_with(int suffix_char) const {
<span class="line-modified">!     return contains_byte_at(utf8_length() - 1, suffix_char);</span>
    }
<span class="line-added">+ </span>
    // Tests if the symbol contains the given utf8 substring
<span class="line-modified">!   // at the given byte position.</span>
<span class="line-modified">!   bool contains_utf8_at(int position, const char* substring, int len) const {</span>
<span class="line-modified">!     assert(len &gt;= 0 &amp;&amp; substring != NULL, &quot;substring must be valid&quot;);</span>
<span class="line-added">+     if (position &lt; 0)  return false;  // can happen with ends_with</span>
<span class="line-added">+     if (position + len &gt; utf8_length()) return false;</span>
<span class="line-added">+     return (memcmp((char*)base() + position, substring, len) == 0);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Tests if the symbol contains the given byte at the given position.</span>
<span class="line-added">+   bool contains_byte_at(int position, char code_byte) const {</span>
<span class="line-added">+     if (position &lt; 0)  return false;  // can happen with ends_with</span>
<span class="line-added">+     if (position &gt;= utf8_length()) return false;</span>
<span class="line-added">+     return code_byte == char_at(position);</span>
<span class="line-added">+   }</span>
  
    // Tests if the symbol starts with the given prefix.
    int index_of_at(int i, const char* str, int len) const;
  
    // Three-way compare for sorting; returns -1/0/1 if receiver is &lt;/==/&gt; than arg
</pre>
<center><a href="symbol.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../opto/arraycopynode.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
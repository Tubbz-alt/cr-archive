<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;jvm.h&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classFileParser.hpp&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/classLoader.hpp&quot;
  30 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  31 #include &quot;classfile/defaultMethods.hpp&quot;
  32 #include &quot;classfile/dictionary.hpp&quot;
  33 #include &quot;classfile/fieldLayoutBuilder.hpp&quot;
  34 #include &quot;classfile/javaClasses.inline.hpp&quot;
  35 #include &quot;classfile/moduleEntry.hpp&quot;
  36 #include &quot;classfile/packageEntry.hpp&quot;
  37 #include &quot;classfile/symbolTable.hpp&quot;
  38 #include &quot;classfile/systemDictionary.hpp&quot;
  39 #include &quot;classfile/verificationType.hpp&quot;
  40 #include &quot;classfile/verifier.hpp&quot;
  41 #include &quot;classfile/vmSymbols.hpp&quot;
  42 #include &quot;logging/log.hpp&quot;
  43 #include &quot;logging/logStream.hpp&quot;
  44 #include &quot;memory/allocation.hpp&quot;
  45 #include &quot;memory/metadataFactory.hpp&quot;
  46 #include &quot;memory/oopFactory.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/annotations.hpp&quot;
  50 #include &quot;oops/constantPool.inline.hpp&quot;
  51 #include &quot;oops/fieldStreams.inline.hpp&quot;
  52 #include &quot;oops/instanceKlass.hpp&quot;
  53 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  54 #include &quot;oops/klass.inline.hpp&quot;
  55 #include &quot;oops/klassVtable.hpp&quot;
  56 #include &quot;oops/metadata.hpp&quot;
  57 #include &quot;oops/method.inline.hpp&quot;
  58 #include &quot;oops/oop.inline.hpp&quot;
  59 #include &quot;oops/recordComponent.hpp&quot;
  60 #include &quot;oops/symbol.hpp&quot;
  61 #include &quot;prims/jvmtiExport.hpp&quot;
  62 #include &quot;prims/jvmtiThreadState.hpp&quot;
  63 #include &quot;runtime/arguments.hpp&quot;
  64 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  65 #include &quot;runtime/handles.inline.hpp&quot;
  66 #include &quot;runtime/javaCalls.hpp&quot;
  67 #include &quot;runtime/os.hpp&quot;
  68 #include &quot;runtime/perfData.hpp&quot;
  69 #include &quot;runtime/reflection.hpp&quot;
  70 #include &quot;runtime/safepointVerifiers.hpp&quot;
  71 #include &quot;runtime/signature.hpp&quot;
  72 #include &quot;runtime/timer.hpp&quot;
  73 #include &quot;services/classLoadingService.hpp&quot;
  74 #include &quot;services/threadService.hpp&quot;
  75 #include &quot;utilities/align.hpp&quot;
  76 #include &quot;utilities/bitMap.inline.hpp&quot;
  77 #include &quot;utilities/copy.hpp&quot;
  78 #include &quot;utilities/exceptions.hpp&quot;
  79 #include &quot;utilities/globalDefinitions.hpp&quot;
  80 #include &quot;utilities/growableArray.hpp&quot;
  81 #include &quot;utilities/macros.hpp&quot;
  82 #include &quot;utilities/ostream.hpp&quot;
  83 #include &quot;utilities/resourceHash.hpp&quot;
  84 #include &quot;utilities/utf8.hpp&quot;
  85 
  86 #if INCLUDE_CDS
  87 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  88 #endif
  89 #if INCLUDE_JFR
  90 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
  91 #endif
  92 
  93 // We generally try to create the oops directly when parsing, rather than
  94 // allocating temporary data structures and copying the bytes twice. A
  95 // temporary area is only needed when parsing utf8 entries in the constant
  96 // pool and when parsing line number tables.
  97 
  98 // We add assert in debug mode when class format is not checked.
  99 
 100 #define JAVA_CLASSFILE_MAGIC              0xCAFEBABE
 101 #define JAVA_MIN_SUPPORTED_VERSION        45
 102 #define JAVA_PREVIEW_MINOR_VERSION        65535
 103 
 104 // Used for two backward compatibility reasons:
 105 // - to check for new additions to the class file format in JDK1.5
 106 // - to check for bug fixes in the format checker in JDK1.5
 107 #define JAVA_1_5_VERSION                  49
 108 
 109 // Used for backward compatibility reasons:
 110 // - to check for javac bug fixes that happened after 1.5
 111 // - also used as the max version when running in jdk6
 112 #define JAVA_6_VERSION                    50
 113 
 114 // Used for backward compatibility reasons:
 115 // - to disallow argument and require ACC_STATIC for &lt;clinit&gt; methods
 116 #define JAVA_7_VERSION                    51
 117 
 118 // Extension method support.
 119 #define JAVA_8_VERSION                    52
 120 
 121 #define JAVA_9_VERSION                    53
 122 
 123 #define JAVA_10_VERSION                   54
 124 
 125 #define JAVA_11_VERSION                   55
 126 
 127 #define JAVA_12_VERSION                   56
 128 
 129 #define JAVA_13_VERSION                   57
 130 
 131 #define JAVA_14_VERSION                   58
 132 
 133 #define JAVA_15_VERSION                   59
 134 
 135 void ClassFileParser::set_class_bad_constant_seen(short bad_constant) {
 136   assert((bad_constant == JVM_CONSTANT_Module ||
 137           bad_constant == JVM_CONSTANT_Package) &amp;&amp; _major_version &gt;= JAVA_9_VERSION,
 138          &quot;Unexpected bad constant pool entry&quot;);
 139   if (_bad_constant_seen == 0) _bad_constant_seen = bad_constant;
 140 }
 141 
 142 void ClassFileParser::parse_constant_pool_entries(const ClassFileStream* const stream,
 143                                                   ConstantPool* cp,
 144                                                   const int length,
 145                                                   TRAPS) {
 146   assert(stream != NULL, &quot;invariant&quot;);
 147   assert(cp != NULL, &quot;invariant&quot;);
 148 
 149   // Use a local copy of ClassFileStream. It helps the C++ compiler to optimize
 150   // this function (_current can be allocated in a register, with scalar
 151   // replacement of aggregates). The _current pointer is copied back to
 152   // stream() when this function returns. DON&#39;T call another method within
 153   // this method that uses stream().
 154   const ClassFileStream cfs1 = *stream;
 155   const ClassFileStream* const cfs = &amp;cfs1;
 156 
 157   assert(cfs-&gt;allocated_on_stack(), &quot;should be local&quot;);
 158   debug_only(const u1* const old_current = stream-&gt;current();)
 159 
 160   // Used for batching symbol allocations.
 161   const char* names[SymbolTable::symbol_alloc_batch_size];
 162   int lengths[SymbolTable::symbol_alloc_batch_size];
 163   int indices[SymbolTable::symbol_alloc_batch_size];
 164   unsigned int hashValues[SymbolTable::symbol_alloc_batch_size];
 165   int names_count = 0;
 166 
 167   // parsing  Index 0 is unused
 168   for (int index = 1; index &lt; length; index++) {
 169     // Each of the following case guarantees one more byte in the stream
 170     // for the following tag or the access_flags following constant pool,
 171     // so we don&#39;t need bounds-check for reading tag.
 172     const u1 tag = cfs-&gt;get_u1_fast();
 173     switch (tag) {
 174       case JVM_CONSTANT_Class : {
 175         cfs-&gt;guarantee_more(3, CHECK);  // name_index, tag/access_flags
 176         const u2 name_index = cfs-&gt;get_u2_fast();
 177         cp-&gt;klass_index_at_put(index, name_index);
 178         break;
 179       }
 180       case JVM_CONSTANT_Fieldref: {
 181         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 182         const u2 class_index = cfs-&gt;get_u2_fast();
 183         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 184         cp-&gt;field_at_put(index, class_index, name_and_type_index);
 185         break;
 186       }
 187       case JVM_CONSTANT_Methodref: {
 188         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 189         const u2 class_index = cfs-&gt;get_u2_fast();
 190         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 191         cp-&gt;method_at_put(index, class_index, name_and_type_index);
 192         break;
 193       }
 194       case JVM_CONSTANT_InterfaceMethodref: {
 195         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 196         const u2 class_index = cfs-&gt;get_u2_fast();
 197         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 198         cp-&gt;interface_method_at_put(index, class_index, name_and_type_index);
 199         break;
 200       }
 201       case JVM_CONSTANT_String : {
 202         cfs-&gt;guarantee_more(3, CHECK);  // string_index, tag/access_flags
 203         const u2 string_index = cfs-&gt;get_u2_fast();
 204         cp-&gt;string_index_at_put(index, string_index);
 205         break;
 206       }
 207       case JVM_CONSTANT_MethodHandle :
 208       case JVM_CONSTANT_MethodType: {
 209         if (_major_version &lt; Verifier::INVOKEDYNAMIC_MAJOR_VERSION) {
 210           classfile_parse_error(
 211             &quot;Class file version does not support constant tag %u in class file %s&quot;,
 212             tag, CHECK);
 213         }
 214         if (tag == JVM_CONSTANT_MethodHandle) {
 215           cfs-&gt;guarantee_more(4, CHECK);  // ref_kind, method_index, tag/access_flags
 216           const u1 ref_kind = cfs-&gt;get_u1_fast();
 217           const u2 method_index = cfs-&gt;get_u2_fast();
 218           cp-&gt;method_handle_index_at_put(index, ref_kind, method_index);
 219         }
 220         else if (tag == JVM_CONSTANT_MethodType) {
 221           cfs-&gt;guarantee_more(3, CHECK);  // signature_index, tag/access_flags
 222           const u2 signature_index = cfs-&gt;get_u2_fast();
 223           cp-&gt;method_type_index_at_put(index, signature_index);
 224         }
 225         else {
 226           ShouldNotReachHere();
 227         }
 228         break;
 229       }
 230       case JVM_CONSTANT_Dynamic : {
 231         if (_major_version &lt; Verifier::DYNAMICCONSTANT_MAJOR_VERSION) {
 232           classfile_parse_error(
 233               &quot;Class file version does not support constant tag %u in class file %s&quot;,
 234               tag, CHECK);
 235         }
 236         cfs-&gt;guarantee_more(5, CHECK);  // bsm_index, nt, tag/access_flags
 237         const u2 bootstrap_specifier_index = cfs-&gt;get_u2_fast();
 238         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 239         if (_max_bootstrap_specifier_index &lt; (int) bootstrap_specifier_index) {
 240           _max_bootstrap_specifier_index = (int) bootstrap_specifier_index;  // collect for later
 241         }
 242         cp-&gt;dynamic_constant_at_put(index, bootstrap_specifier_index, name_and_type_index);
 243         break;
 244       }
 245       case JVM_CONSTANT_InvokeDynamic : {
 246         if (_major_version &lt; Verifier::INVOKEDYNAMIC_MAJOR_VERSION) {
 247           classfile_parse_error(
 248               &quot;Class file version does not support constant tag %u in class file %s&quot;,
 249               tag, CHECK);
 250         }
 251         cfs-&gt;guarantee_more(5, CHECK);  // bsm_index, nt, tag/access_flags
 252         const u2 bootstrap_specifier_index = cfs-&gt;get_u2_fast();
 253         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 254         if (_max_bootstrap_specifier_index &lt; (int) bootstrap_specifier_index) {
 255           _max_bootstrap_specifier_index = (int) bootstrap_specifier_index;  // collect for later
 256         }
 257         cp-&gt;invoke_dynamic_at_put(index, bootstrap_specifier_index, name_and_type_index);
 258         break;
 259       }
 260       case JVM_CONSTANT_Integer: {
 261         cfs-&gt;guarantee_more(5, CHECK);  // bytes, tag/access_flags
 262         const u4 bytes = cfs-&gt;get_u4_fast();
 263         cp-&gt;int_at_put(index, (jint)bytes);
 264         break;
 265       }
 266       case JVM_CONSTANT_Float: {
 267         cfs-&gt;guarantee_more(5, CHECK);  // bytes, tag/access_flags
 268         const u4 bytes = cfs-&gt;get_u4_fast();
 269         cp-&gt;float_at_put(index, *(jfloat*)&amp;bytes);
 270         break;
 271       }
 272       case JVM_CONSTANT_Long: {
 273         // A mangled type might cause you to overrun allocated memory
 274         guarantee_property(index + 1 &lt; length,
 275                            &quot;Invalid constant pool entry %u in class file %s&quot;,
 276                            index,
 277                            CHECK);
 278         cfs-&gt;guarantee_more(9, CHECK);  // bytes, tag/access_flags
 279         const u8 bytes = cfs-&gt;get_u8_fast();
 280         cp-&gt;long_at_put(index, bytes);
 281         index++;   // Skip entry following eigth-byte constant, see JVM book p. 98
 282         break;
 283       }
 284       case JVM_CONSTANT_Double: {
 285         // A mangled type might cause you to overrun allocated memory
 286         guarantee_property(index+1 &lt; length,
 287                            &quot;Invalid constant pool entry %u in class file %s&quot;,
 288                            index,
 289                            CHECK);
 290         cfs-&gt;guarantee_more(9, CHECK);  // bytes, tag/access_flags
 291         const u8 bytes = cfs-&gt;get_u8_fast();
 292         cp-&gt;double_at_put(index, *(jdouble*)&amp;bytes);
 293         index++;   // Skip entry following eigth-byte constant, see JVM book p. 98
 294         break;
 295       }
 296       case JVM_CONSTANT_NameAndType: {
 297         cfs-&gt;guarantee_more(5, CHECK);  // name_index, signature_index, tag/access_flags
 298         const u2 name_index = cfs-&gt;get_u2_fast();
 299         const u2 signature_index = cfs-&gt;get_u2_fast();
 300         cp-&gt;name_and_type_at_put(index, name_index, signature_index);
 301         break;
 302       }
 303       case JVM_CONSTANT_Utf8 : {
 304         cfs-&gt;guarantee_more(2, CHECK);  // utf8_length
 305         u2  utf8_length = cfs-&gt;get_u2_fast();
 306         const u1* utf8_buffer = cfs-&gt;current();
 307         assert(utf8_buffer != NULL, &quot;null utf8 buffer&quot;);
 308         // Got utf8 string, guarantee utf8_length+1 bytes, set stream position forward.
 309         cfs-&gt;guarantee_more(utf8_length+1, CHECK);  // utf8 string, tag/access_flags
 310         cfs-&gt;skip_u1_fast(utf8_length);
 311 
 312         // Before storing the symbol, make sure it&#39;s legal
 313         if (_need_verify) {
 314           verify_legal_utf8(utf8_buffer, utf8_length, CHECK);
 315         }
 316 
 317         if (has_cp_patch_at(index)) {
 318           Handle patch = clear_cp_patch_at(index);
 319           guarantee_property(java_lang_String::is_instance(patch()),
 320                              &quot;Illegal utf8 patch at %d in class file %s&quot;,
 321                              index,
 322                              CHECK);
 323           const char* const str = java_lang_String::as_utf8_string(patch());
 324           // (could use java_lang_String::as_symbol instead, but might as well batch them)
 325           utf8_buffer = (const u1*) str;
 326           utf8_length = (u2) strlen(str);
 327         }
 328 
 329         unsigned int hash;
 330         Symbol* const result = SymbolTable::lookup_only((const char*)utf8_buffer,
 331                                                         utf8_length,
 332                                                         hash);
 333         if (result == NULL) {
 334           names[names_count] = (const char*)utf8_buffer;
 335           lengths[names_count] = utf8_length;
 336           indices[names_count] = index;
 337           hashValues[names_count++] = hash;
 338           if (names_count == SymbolTable::symbol_alloc_batch_size) {
 339             SymbolTable::new_symbols(_loader_data,
 340                                      constantPoolHandle(THREAD, cp),
 341                                      names_count,
 342                                      names,
 343                                      lengths,
 344                                      indices,
 345                                      hashValues);
 346             names_count = 0;
 347           }
 348         } else {
 349           cp-&gt;symbol_at_put(index, result);
 350         }
 351         break;
 352       }
 353       case JVM_CONSTANT_Module:
 354       case JVM_CONSTANT_Package: {
 355         // Record that an error occurred in these two cases but keep parsing so
 356         // that ACC_Module can be checked for in the access_flags.  Need to
 357         // throw NoClassDefFoundError in that case.
 358         if (_major_version &gt;= JAVA_9_VERSION) {
 359           cfs-&gt;guarantee_more(3, CHECK);
 360           cfs-&gt;get_u2_fast();
 361           set_class_bad_constant_seen(tag);
 362           break;
 363         }
 364       }
 365       default: {
 366         classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;,
 367                               tag,
 368                               CHECK);
 369         break;
 370       }
 371     } // end of switch(tag)
 372   } // end of for
 373 
 374   // Allocate the remaining symbols
 375   if (names_count &gt; 0) {
 376     SymbolTable::new_symbols(_loader_data,
 377                              constantPoolHandle(THREAD, cp),
 378                              names_count,
 379                              names,
 380                              lengths,
 381                              indices,
 382                              hashValues);
 383   }
 384 
 385   // Copy _current pointer of local copy back to stream.
 386   assert(stream-&gt;current() == old_current, &quot;non-exclusive use of stream&quot;);
 387   stream-&gt;set_current(cfs1.current());
 388 
 389 }
 390 
 391 static inline bool valid_cp_range(int index, int length) {
 392   return (index &gt; 0 &amp;&amp; index &lt; length);
 393 }
 394 
 395 static inline Symbol* check_symbol_at(const ConstantPool* cp, int index) {
 396   assert(cp != NULL, &quot;invariant&quot;);
 397   if (valid_cp_range(index, cp-&gt;length()) &amp;&amp; cp-&gt;tag_at(index).is_utf8()) {
 398     return cp-&gt;symbol_at(index);
 399   }
 400   return NULL;
 401 }
 402 
 403 #ifdef ASSERT
 404 PRAGMA_DIAG_PUSH
 405 PRAGMA_FORMAT_NONLITERAL_IGNORED
 406 void ClassFileParser::report_assert_property_failure(const char* msg, TRAPS) const {
 407   ResourceMark rm(THREAD);
 408   fatal(msg, _class_name-&gt;as_C_string());
 409 }
 410 
 411 void ClassFileParser::report_assert_property_failure(const char* msg,
 412                                                      int index,
 413                                                      TRAPS) const {
 414   ResourceMark rm(THREAD);
 415   fatal(msg, index, _class_name-&gt;as_C_string());
 416 }
 417 PRAGMA_DIAG_POP
 418 #endif
 419 
 420 void ClassFileParser::parse_constant_pool(const ClassFileStream* const stream,
 421                                          ConstantPool* const cp,
 422                                          const int length,
 423                                          TRAPS) {
 424   assert(cp != NULL, &quot;invariant&quot;);
 425   assert(stream != NULL, &quot;invariant&quot;);
 426 
 427   // parsing constant pool entries
 428   parse_constant_pool_entries(stream, cp, length, CHECK);
 429   if (class_bad_constant_seen() != 0) {
 430     // a bad CP entry has been detected previously so stop parsing and just return.
 431     return;
 432   }
 433 
 434   int index = 1;  // declared outside of loops for portability
 435   int num_klasses = 0;
 436 
 437   // first verification pass - validate cross references
 438   // and fixup class and string constants
 439   for (index = 1; index &lt; length; index++) {          // Index 0 is unused
 440     const jbyte tag = cp-&gt;tag_at(index).value();
 441     switch (tag) {
 442       case JVM_CONSTANT_Class: {
 443         ShouldNotReachHere();     // Only JVM_CONSTANT_ClassIndex should be present
 444         break;
 445       }
 446       case JVM_CONSTANT_Fieldref:
 447         // fall through
 448       case JVM_CONSTANT_Methodref:
 449         // fall through
 450       case JVM_CONSTANT_InterfaceMethodref: {
 451         if (!_need_verify) break;
 452         const int klass_ref_index = cp-&gt;klass_ref_index_at(index);
 453         const int name_and_type_ref_index = cp-&gt;name_and_type_ref_index_at(index);
 454         check_property(valid_klass_reference_at(klass_ref_index),
 455                        &quot;Invalid constant pool index %u in class file %s&quot;,
 456                        klass_ref_index, CHECK);
 457         check_property(valid_cp_range(name_and_type_ref_index, length) &amp;&amp;
 458           cp-&gt;tag_at(name_and_type_ref_index).is_name_and_type(),
 459           &quot;Invalid constant pool index %u in class file %s&quot;,
 460           name_and_type_ref_index, CHECK);
 461         break;
 462       }
 463       case JVM_CONSTANT_String: {
 464         ShouldNotReachHere();     // Only JVM_CONSTANT_StringIndex should be present
 465         break;
 466       }
 467       case JVM_CONSTANT_Integer:
 468         break;
 469       case JVM_CONSTANT_Float:
 470         break;
 471       case JVM_CONSTANT_Long:
 472       case JVM_CONSTANT_Double: {
 473         index++;
 474         check_property(
 475           (index &lt; length &amp;&amp; cp-&gt;tag_at(index).is_invalid()),
 476           &quot;Improper constant pool long/double index %u in class file %s&quot;,
 477           index, CHECK);
 478         break;
 479       }
 480       case JVM_CONSTANT_NameAndType: {
 481         if (!_need_verify) break;
 482         const int name_ref_index = cp-&gt;name_ref_index_at(index);
 483         const int signature_ref_index = cp-&gt;signature_ref_index_at(index);
 484         check_property(valid_symbol_at(name_ref_index),
 485           &quot;Invalid constant pool index %u in class file %s&quot;,
 486           name_ref_index, CHECK);
 487         check_property(valid_symbol_at(signature_ref_index),
 488           &quot;Invalid constant pool index %u in class file %s&quot;,
 489           signature_ref_index, CHECK);
 490         break;
 491       }
 492       case JVM_CONSTANT_Utf8:
 493         break;
 494       case JVM_CONSTANT_UnresolvedClass:         // fall-through
 495       case JVM_CONSTANT_UnresolvedClassInError: {
 496         ShouldNotReachHere();     // Only JVM_CONSTANT_ClassIndex should be present
 497         break;
 498       }
 499       case JVM_CONSTANT_ClassIndex: {
 500         const int class_index = cp-&gt;klass_index_at(index);
 501         check_property(valid_symbol_at(class_index),
 502           &quot;Invalid constant pool index %u in class file %s&quot;,
 503           class_index, CHECK);
 504         cp-&gt;unresolved_klass_at_put(index, class_index, num_klasses++);
 505         break;
 506       }
 507       case JVM_CONSTANT_StringIndex: {
 508         const int string_index = cp-&gt;string_index_at(index);
 509         check_property(valid_symbol_at(string_index),
 510           &quot;Invalid constant pool index %u in class file %s&quot;,
 511           string_index, CHECK);
 512         Symbol* const sym = cp-&gt;symbol_at(string_index);
 513         cp-&gt;unresolved_string_at_put(index, sym);
 514         break;
 515       }
 516       case JVM_CONSTANT_MethodHandle: {
 517         const int ref_index = cp-&gt;method_handle_index_at(index);
 518         check_property(valid_cp_range(ref_index, length),
 519           &quot;Invalid constant pool index %u in class file %s&quot;,
 520           ref_index, CHECK);
 521         const constantTag tag = cp-&gt;tag_at(ref_index);
 522         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 523 
 524         switch (ref_kind) {
 525           case JVM_REF_getField:
 526           case JVM_REF_getStatic:
 527           case JVM_REF_putField:
 528           case JVM_REF_putStatic: {
 529             check_property(
 530               tag.is_field(),
 531               &quot;Invalid constant pool index %u in class file %s (not a field)&quot;,
 532               ref_index, CHECK);
 533             break;
 534           }
 535           case JVM_REF_invokeVirtual:
 536           case JVM_REF_newInvokeSpecial: {
 537             check_property(
 538               tag.is_method(),
 539               &quot;Invalid constant pool index %u in class file %s (not a method)&quot;,
 540               ref_index, CHECK);
 541             break;
 542           }
 543           case JVM_REF_invokeStatic:
 544           case JVM_REF_invokeSpecial: {
 545             check_property(
 546               tag.is_method() ||
 547               ((_major_version &gt;= JAVA_8_VERSION) &amp;&amp; tag.is_interface_method()),
 548               &quot;Invalid constant pool index %u in class file %s (not a method)&quot;,
 549               ref_index, CHECK);
 550             break;
 551           }
 552           case JVM_REF_invokeInterface: {
 553             check_property(
 554               tag.is_interface_method(),
 555               &quot;Invalid constant pool index %u in class file %s (not an interface method)&quot;,
 556               ref_index, CHECK);
 557             break;
 558           }
 559           default: {
 560             classfile_parse_error(
 561               &quot;Bad method handle kind at constant pool index %u in class file %s&quot;,
 562               index, CHECK);
 563           }
 564         } // switch(refkind)
 565         // Keep the ref_index unchanged.  It will be indirected at link-time.
 566         break;
 567       } // case MethodHandle
 568       case JVM_CONSTANT_MethodType: {
 569         const int ref_index = cp-&gt;method_type_index_at(index);
 570         check_property(valid_symbol_at(ref_index),
 571           &quot;Invalid constant pool index %u in class file %s&quot;,
 572           ref_index, CHECK);
 573         break;
 574       }
 575       case JVM_CONSTANT_Dynamic: {
 576         const int name_and_type_ref_index =
 577           cp-&gt;bootstrap_name_and_type_ref_index_at(index);
 578 
 579         check_property(valid_cp_range(name_and_type_ref_index, length) &amp;&amp;
 580           cp-&gt;tag_at(name_and_type_ref_index).is_name_and_type(),
 581           &quot;Invalid constant pool index %u in class file %s&quot;,
 582           name_and_type_ref_index, CHECK);
 583         // bootstrap specifier index must be checked later,
 584         // when BootstrapMethods attr is available
 585 
 586         // Mark the constant pool as having a CONSTANT_Dynamic_info structure
 587         cp-&gt;set_has_dynamic_constant();
 588         break;
 589       }
 590       case JVM_CONSTANT_InvokeDynamic: {
 591         const int name_and_type_ref_index =
 592           cp-&gt;bootstrap_name_and_type_ref_index_at(index);
 593 
 594         check_property(valid_cp_range(name_and_type_ref_index, length) &amp;&amp;
 595           cp-&gt;tag_at(name_and_type_ref_index).is_name_and_type(),
 596           &quot;Invalid constant pool index %u in class file %s&quot;,
 597           name_and_type_ref_index, CHECK);
 598         // bootstrap specifier index must be checked later,
 599         // when BootstrapMethods attr is available
 600         break;
 601       }
 602       default: {
 603         fatal(&quot;bad constant pool tag value %u&quot;, cp-&gt;tag_at(index).value());
 604         ShouldNotReachHere();
 605         break;
 606       }
 607     } // switch(tag)
 608   } // end of for
 609 
 610   _first_patched_klass_resolved_index = num_klasses;
 611   cp-&gt;allocate_resolved_klasses(_loader_data, num_klasses + _max_num_patched_klasses, CHECK);
 612 
 613   if (_cp_patches != NULL) {
 614     // need to treat this_class specially...
 615 
 616     // Add dummy utf8 entries in the space reserved for names of patched classes. We&#39;ll use &quot;*&quot;
 617     // for now. These will be replaced with actual names of the patched classes in patch_class().
 618     Symbol* s = vmSymbols::star_name();
 619     for (int n=_orig_cp_size; n&lt;cp-&gt;length(); n++) {
 620       cp-&gt;symbol_at_put(n, s);
 621     }
 622 
 623     int this_class_index;
 624     {
 625       stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
 626       const u1* const mark = stream-&gt;current();
 627       stream-&gt;skip_u2_fast(1); // skip flags
 628       this_class_index = stream-&gt;get_u2_fast();
 629       stream-&gt;set_current(mark);  // revert to mark
 630     }
 631 
 632     for (index = 1; index &lt; length; index++) {          // Index 0 is unused
 633       if (has_cp_patch_at(index)) {
 634         guarantee_property(index != this_class_index,
 635           &quot;Illegal constant pool patch to self at %d in class file %s&quot;,
 636           index, CHECK);
 637         patch_constant_pool(cp, index, cp_patch_at(index), CHECK);
 638       }
 639     }
 640   }
 641 
 642   if (!_need_verify) {
 643     return;
 644   }
 645 
 646   // second verification pass - checks the strings are of the right format.
 647   // but not yet to the other entries
 648   for (index = 1; index &lt; length; index++) {
 649     const jbyte tag = cp-&gt;tag_at(index).value();
 650     switch (tag) {
 651       case JVM_CONSTANT_UnresolvedClass: {
 652         const Symbol* const class_name = cp-&gt;klass_name_at(index);
 653         // check the name, even if _cp_patches will overwrite it
 654         verify_legal_class_name(class_name, CHECK);
 655         break;
 656       }
 657       case JVM_CONSTANT_NameAndType: {
 658         if (_need_verify) {
 659           const int sig_index = cp-&gt;signature_ref_index_at(index);
 660           const int name_index = cp-&gt;name_ref_index_at(index);
 661           const Symbol* const name = cp-&gt;symbol_at(name_index);
 662           const Symbol* const sig = cp-&gt;symbol_at(sig_index);
 663           guarantee_property(sig-&gt;utf8_length() != 0,
 664             &quot;Illegal zero length constant pool entry at %d in class %s&quot;,
 665             sig_index, CHECK);
 666           guarantee_property(name-&gt;utf8_length() != 0,
 667             &quot;Illegal zero length constant pool entry at %d in class %s&quot;,
 668             name_index, CHECK);
 669 
 670           if (Signature::is_method(sig)) {
 671             // Format check method name and signature
 672             verify_legal_method_name(name, CHECK);
 673             verify_legal_method_signature(name, sig, CHECK);
 674           } else {
 675             // Format check field name and signature
 676             verify_legal_field_name(name, CHECK);
 677             verify_legal_field_signature(name, sig, CHECK);
 678           }
 679         }
 680         break;
 681       }
 682       case JVM_CONSTANT_Dynamic: {
 683         const int name_and_type_ref_index =
 684           cp-&gt;name_and_type_ref_index_at(index);
 685         // already verified to be utf8
 686         const int name_ref_index =
 687           cp-&gt;name_ref_index_at(name_and_type_ref_index);
 688         // already verified to be utf8
 689         const int signature_ref_index =
 690           cp-&gt;signature_ref_index_at(name_and_type_ref_index);
 691         const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
 692         const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);
 693         if (_need_verify) {
 694           // CONSTANT_Dynamic&#39;s name and signature are verified above, when iterating NameAndType_info.
 695           // Need only to be sure signature is the right type.
 696           if (Signature::is_method(signature)) {
 697             throwIllegalSignature(&quot;CONSTANT_Dynamic&quot;, name, signature, CHECK);
 698           }
 699         }
 700         break;
 701       }
 702       case JVM_CONSTANT_InvokeDynamic:
 703       case JVM_CONSTANT_Fieldref:
 704       case JVM_CONSTANT_Methodref:
 705       case JVM_CONSTANT_InterfaceMethodref: {
 706         const int name_and_type_ref_index =
 707           cp-&gt;name_and_type_ref_index_at(index);
 708         // already verified to be utf8
 709         const int name_ref_index =
 710           cp-&gt;name_ref_index_at(name_and_type_ref_index);
 711         // already verified to be utf8
 712         const int signature_ref_index =
 713           cp-&gt;signature_ref_index_at(name_and_type_ref_index);
 714         const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
 715         const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);
 716         if (tag == JVM_CONSTANT_Fieldref) {
 717           if (_need_verify) {
 718             // Field name and signature are verified above, when iterating NameAndType_info.
 719             // Need only to be sure signature is non-zero length and the right type.
 720             if (Signature::is_method(signature)) {
 721               throwIllegalSignature(&quot;Field&quot;, name, signature, CHECK);
 722             }
 723           }
 724         } else {
 725           if (_need_verify) {
 726             // Method name and signature are verified above, when iterating NameAndType_info.
 727             // Need only to be sure signature is non-zero length and the right type.
 728             if (!Signature::is_method(signature)) {
 729               throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK);
 730             }
 731           }
 732           // 4509014: If a class method name begins with &#39;&lt;&#39;, it must be &quot;&lt;init&gt;&quot;
 733           const unsigned int name_len = name-&gt;utf8_length();
 734           if (tag == JVM_CONSTANT_Methodref &amp;&amp;
 735               name_len != 0 &amp;&amp;
 736               name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL &amp;&amp;
 737               name != vmSymbols::object_initializer_name()) {
 738             classfile_parse_error(
 739               &quot;Bad method name at constant pool index %u in class file %s&quot;,
 740               name_ref_index, CHECK);
 741           }
 742         }
 743         break;
 744       }
 745       case JVM_CONSTANT_MethodHandle: {
 746         const int ref_index = cp-&gt;method_handle_index_at(index);
 747         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 748         switch (ref_kind) {
 749           case JVM_REF_invokeVirtual:
 750           case JVM_REF_invokeStatic:
 751           case JVM_REF_invokeSpecial:
 752           case JVM_REF_newInvokeSpecial: {
 753             const int name_and_type_ref_index =
 754               cp-&gt;name_and_type_ref_index_at(ref_index);
 755             const int name_ref_index =
 756               cp-&gt;name_ref_index_at(name_and_type_ref_index);
 757             const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
 758             if (ref_kind == JVM_REF_newInvokeSpecial) {
 759               if (name != vmSymbols::object_initializer_name()) {
 760                 classfile_parse_error(
 761                   &quot;Bad constructor name at constant pool index %u in class file %s&quot;,
 762                     name_ref_index, CHECK);
 763               }
 764             } else {
 765               if (name == vmSymbols::object_initializer_name()) {
 766                 classfile_parse_error(
 767                   &quot;Bad method name at constant pool index %u in class file %s&quot;,
 768                   name_ref_index, CHECK);
 769               }
 770             }
 771             break;
 772           }
 773           // Other ref_kinds are already fully checked in previous pass.
 774         } // switch(ref_kind)
 775         break;
 776       }
 777       case JVM_CONSTANT_MethodType: {
 778         const Symbol* const no_name = vmSymbols::type_name(); // place holder
 779         const Symbol* const signature = cp-&gt;method_type_signature_at(index);
 780         verify_legal_method_signature(no_name, signature, CHECK);
 781         break;
 782       }
 783       case JVM_CONSTANT_Utf8: {
 784         assert(cp-&gt;symbol_at(index)-&gt;refcount() != 0, &quot;count corrupted&quot;);
 785       }
 786     }  // switch(tag)
 787   }  // end of for
 788 }
 789 
 790 Handle ClassFileParser::clear_cp_patch_at(int index) {
 791   Handle patch = cp_patch_at(index);
 792   _cp_patches-&gt;at_put(index, Handle());
 793   assert(!has_cp_patch_at(index), &quot;&quot;);
 794   return patch;
 795 }
 796 
 797 void ClassFileParser::patch_class(ConstantPool* cp, int class_index, Klass* k, Symbol* name) {
 798   int name_index = _orig_cp_size + _num_patched_klasses;
 799   int resolved_klass_index = _first_patched_klass_resolved_index + _num_patched_klasses;
 800 
 801   cp-&gt;klass_at_put(class_index, name_index, resolved_klass_index, k, name);
 802   _num_patched_klasses ++;
 803 }
 804 
 805 void ClassFileParser::patch_constant_pool(ConstantPool* cp,
 806                                           int index,
 807                                           Handle patch,
 808                                           TRAPS) {
 809   assert(cp != NULL, &quot;invariant&quot;);
 810 
 811   BasicType patch_type = T_VOID;
 812 
 813   switch (cp-&gt;tag_at(index).value()) {
 814 
 815     case JVM_CONSTANT_UnresolvedClass: {
 816       // Patching a class means pre-resolving it.
 817       // The name in the constant pool is ignored.
 818       if (java_lang_Class::is_instance(patch())) {
 819         guarantee_property(!java_lang_Class::is_primitive(patch()),
 820                            &quot;Illegal class patch at %d in class file %s&quot;,
 821                            index, CHECK);
 822         Klass* k = java_lang_Class::as_Klass(patch());
 823         patch_class(cp, index, k, k-&gt;name());
 824       } else {
 825         guarantee_property(java_lang_String::is_instance(patch()),
 826                            &quot;Illegal class patch at %d in class file %s&quot;,
 827                            index, CHECK);
 828         Symbol* const name = java_lang_String::as_symbol(patch());
 829         patch_class(cp, index, NULL, name);
 830       }
 831       break;
 832     }
 833 
 834     case JVM_CONSTANT_String: {
 835       // skip this patch and don&#39;t clear it.  Needs the oop array for resolved
 836       // references to be created first.
 837       return;
 838     }
 839     case JVM_CONSTANT_Integer: patch_type = T_INT;    goto patch_prim;
 840     case JVM_CONSTANT_Float:   patch_type = T_FLOAT;  goto patch_prim;
 841     case JVM_CONSTANT_Long:    patch_type = T_LONG;   goto patch_prim;
 842     case JVM_CONSTANT_Double:  patch_type = T_DOUBLE; goto patch_prim;
 843     patch_prim:
 844     {
 845       jvalue value;
 846       BasicType value_type = java_lang_boxing_object::get_value(patch(), &amp;value);
 847       guarantee_property(value_type == patch_type,
 848                          &quot;Illegal primitive patch at %d in class file %s&quot;,
 849                          index, CHECK);
 850       switch (value_type) {
 851         case T_INT:    cp-&gt;int_at_put(index,   value.i); break;
 852         case T_FLOAT:  cp-&gt;float_at_put(index, value.f); break;
 853         case T_LONG:   cp-&gt;long_at_put(index,  value.j); break;
 854         case T_DOUBLE: cp-&gt;double_at_put(index, value.d); break;
 855         default:       assert(false, &quot;&quot;);
 856       }
 857     } // end patch_prim label
 858     break;
 859 
 860     default: {
 861       // %%% TODO: put method handles into CONSTANT_InterfaceMethodref, etc.
 862       guarantee_property(!has_cp_patch_at(index),
 863                          &quot;Illegal unexpected patch at %d in class file %s&quot;,
 864                          index, CHECK);
 865       return;
 866     }
 867   } // end of switch(tag)
 868 
 869   // On fall-through, mark the patch as used.
 870   clear_cp_patch_at(index);
 871 }
 872 class NameSigHash: public ResourceObj {
 873  public:
 874   const Symbol*       _name;       // name
 875   const Symbol*       _sig;        // signature
 876   NameSigHash*  _next;             // Next entry in hash table
 877 };
 878 
 879 static const int HASH_ROW_SIZE = 256;
 880 
 881 static unsigned int hash(const Symbol* name, const Symbol* sig) {
 882   unsigned int raw_hash = 0;
 883   raw_hash += ((unsigned int)(uintptr_t)name) &gt;&gt; (LogHeapWordSize + 2);
 884   raw_hash += ((unsigned int)(uintptr_t)sig) &gt;&gt; LogHeapWordSize;
 885 
 886   return (raw_hash + (unsigned int)(uintptr_t)name) % HASH_ROW_SIZE;
 887 }
 888 
 889 
 890 static void initialize_hashtable(NameSigHash** table) {
 891   memset((void*)table, 0, sizeof(NameSigHash*) * HASH_ROW_SIZE);
 892 }
 893 // Return false if the name/sig combination is found in table.
 894 // Return true if no duplicate is found. And name/sig is added as a new entry in table.
 895 // The old format checker uses heap sort to find duplicates.
 896 // NOTE: caller should guarantee that GC doesn&#39;t happen during the life cycle
 897 // of table since we don&#39;t expect Symbol*&#39;s to move.
 898 static bool put_after_lookup(const Symbol* name, const Symbol* sig, NameSigHash** table) {
 899   assert(name != NULL, &quot;name in constant pool is NULL&quot;);
 900 
 901   // First lookup for duplicates
 902   int index = hash(name, sig);
 903   NameSigHash* entry = table[index];
 904   while (entry != NULL) {
 905     if (entry-&gt;_name == name &amp;&amp; entry-&gt;_sig == sig) {
 906       return false;
 907     }
 908     entry = entry-&gt;_next;
 909   }
 910 
 911   // No duplicate is found, allocate a new entry and fill it.
 912   entry = new NameSigHash();
 913   entry-&gt;_name = name;
 914   entry-&gt;_sig = sig;
 915 
 916   // Insert into hash table
 917   entry-&gt;_next = table[index];
 918   table[index] = entry;
 919 
 920   return true;
 921 }
 922 
 923 // Side-effects: populates the _local_interfaces field
 924 void ClassFileParser::parse_interfaces(const ClassFileStream* const stream,
 925                                        const int itfs_len,
 926                                        ConstantPool* const cp,
 927                                        bool* const has_nonstatic_concrete_methods,
 928                                        TRAPS) {
 929   assert(stream != NULL, &quot;invariant&quot;);
 930   assert(cp != NULL, &quot;invariant&quot;);
 931   assert(has_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
 932 
 933   if (itfs_len == 0) {
 934     _local_interfaces = Universe::the_empty_instance_klass_array();
 935   } else {
 936     assert(itfs_len &gt; 0, &quot;only called for len&gt;0&quot;);
 937     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);
 938 
 939     int index;
 940     for (index = 0; index &lt; itfs_len; index++) {
 941       const u2 interface_index = stream-&gt;get_u2(CHECK);
 942       Klass* interf;
 943       check_property(
 944         valid_klass_reference_at(interface_index),
 945         &quot;Interface name has bad constant pool index %u in class file %s&quot;,
 946         interface_index, CHECK);
 947       if (cp-&gt;tag_at(interface_index).is_klass()) {
 948         interf = cp-&gt;resolved_klass_at(interface_index);
 949       } else {
 950         Symbol* const unresolved_klass  = cp-&gt;klass_name_at(interface_index);
 951 
 952         // Don&#39;t need to check legal name because it&#39;s checked when parsing constant pool.
 953         // But need to make sure it&#39;s not an array type.
 954         guarantee_property(unresolved_klass-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
 955                            &quot;Bad interface name in class file %s&quot;, CHECK);
 956 
 957         // Call resolve_super so classcircularity is checked
 958         interf = SystemDictionary::resolve_super_or_fail(
 959                                                   _class_name,
 960                                                   unresolved_klass,
 961                                                   Handle(THREAD, _loader_data-&gt;class_loader()),
 962                                                   _protection_domain,
 963                                                   false,
 964                                                   CHECK);
 965       }
 966 
 967       if (!interf-&gt;is_interface()) {
 968         THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),
 969                   err_msg(&quot;class %s can not implement %s, because it is not an interface (%s)&quot;,
 970                           _class_name-&gt;as_klass_external_name(),
 971                           interf-&gt;external_name(),
 972                           interf-&gt;class_in_module_of_loader()));
 973       }
 974 
 975       if (InstanceKlass::cast(interf)-&gt;has_nonstatic_concrete_methods()) {
 976         *has_nonstatic_concrete_methods = true;
 977       }
 978       _local_interfaces-&gt;at_put(index, InstanceKlass::cast(interf));
 979     }
 980 
 981     if (!_need_verify || itfs_len &lt;= 1) {
 982       return;
 983     }
 984 
 985     // Check if there&#39;s any duplicates in interfaces
 986     ResourceMark rm(THREAD);
 987     NameSigHash** interface_names = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
 988                                                                  NameSigHash*,
 989                                                                  HASH_ROW_SIZE);
 990     initialize_hashtable(interface_names);
 991     bool dup = false;
 992     const Symbol* name = NULL;
 993     {
 994       debug_only(NoSafepointVerifier nsv;)
 995       for (index = 0; index &lt; itfs_len; index++) {
 996         const InstanceKlass* const k = _local_interfaces-&gt;at(index);
 997         name = k-&gt;name();
 998         // If no duplicates, add (name, NULL) in hashtable interface_names.
 999         if (!put_after_lookup(name, NULL, interface_names)) {
1000           dup = true;
1001           break;
1002         }
1003       }
1004     }
1005     if (dup) {
1006       classfile_parse_error(&quot;Duplicate interface name \&quot;%s\&quot; in class file %s&quot;,
1007                              name-&gt;as_C_string(), CHECK);
1008     }
1009   }
1010 }
1011 
1012 void ClassFileParser::verify_constantvalue(const ConstantPool* const cp,
1013                                            int constantvalue_index,
1014                                            int signature_index,
1015                                            TRAPS) const {
1016   // Make sure the constant pool entry is of a type appropriate to this field
1017   guarantee_property(
1018     (constantvalue_index &gt; 0 &amp;&amp;
1019       constantvalue_index &lt; cp-&gt;length()),
1020     &quot;Bad initial value index %u in ConstantValue attribute in class file %s&quot;,
1021     constantvalue_index, CHECK);
1022 
1023   const constantTag value_type = cp-&gt;tag_at(constantvalue_index);
1024   switch(cp-&gt;basic_type_for_signature_at(signature_index)) {
1025     case T_LONG: {
1026       guarantee_property(value_type.is_long(),
1027                          &quot;Inconsistent constant value type in class file %s&quot;,
1028                          CHECK);
1029       break;
1030     }
1031     case T_FLOAT: {
1032       guarantee_property(value_type.is_float(),
1033                          &quot;Inconsistent constant value type in class file %s&quot;,
1034                          CHECK);
1035       break;
1036     }
1037     case T_DOUBLE: {
1038       guarantee_property(value_type.is_double(),
1039                          &quot;Inconsistent constant value type in class file %s&quot;,
1040                          CHECK);
1041       break;
1042     }
1043     case T_BYTE:
1044     case T_CHAR:
1045     case T_SHORT:
1046     case T_BOOLEAN:
1047     case T_INT: {
1048       guarantee_property(value_type.is_int(),
1049                          &quot;Inconsistent constant value type in class file %s&quot;,
1050                          CHECK);
1051       break;
1052     }
1053     case T_OBJECT: {
1054       guarantee_property((cp-&gt;symbol_at(signature_index)-&gt;equals(&quot;Ljava/lang/String;&quot;)
1055                          &amp;&amp; value_type.is_string()),
1056                          &quot;Bad string initial value in class file %s&quot;,
1057                          CHECK);
1058       break;
1059     }
1060     default: {
1061       classfile_parse_error(&quot;Unable to set initial value %u in class file %s&quot;,
1062                              constantvalue_index,
1063                              CHECK);
1064     }
1065   }
1066 }
1067 
1068 class AnnotationCollector : public ResourceObj{
1069 public:
1070   enum Location { _in_field, _in_method, _in_class };
1071   enum ID {
1072     _unknown = 0,
1073     _method_CallerSensitive,
1074     _method_ForceInline,
1075     _method_DontInline,
1076     _method_InjectedProfile,
1077     _method_LambdaForm_Compiled,
1078     _method_Hidden,
1079     _method_HotSpotIntrinsicCandidate,
1080     _jdk_internal_vm_annotation_Contended,
1081     _field_Stable,
1082     _jdk_internal_vm_annotation_ReservedStackAccess,
1083     _annotation_LIMIT
1084   };
1085   const Location _location;
1086   int _annotations_present;
1087   u2 _contended_group;
1088 
1089   AnnotationCollector(Location location)
1090     : _location(location), _annotations_present(0)
1091   {
1092     assert((int)_annotation_LIMIT &lt;= (int)sizeof(_annotations_present) * BitsPerByte, &quot;&quot;);
1093   }
1094   // If this annotation name has an ID, report it (or _none).
1095   ID annotation_index(const ClassLoaderData* loader_data, const Symbol* name);
1096   // Set the annotation name:
1097   void set_annotation(ID id) {
1098     assert((int)id &gt;= 0 &amp;&amp; (int)id &lt; (int)_annotation_LIMIT, &quot;oob&quot;);
1099     _annotations_present |= nth_bit((int)id);
1100   }
1101 
1102   void remove_annotation(ID id) {
1103     assert((int)id &gt;= 0 &amp;&amp; (int)id &lt; (int)_annotation_LIMIT, &quot;oob&quot;);
1104     _annotations_present &amp;= ~nth_bit((int)id);
1105   }
1106 
1107   // Report if the annotation is present.
1108   bool has_any_annotations() const { return _annotations_present != 0; }
1109   bool has_annotation(ID id) const { return (nth_bit((int)id) &amp; _annotations_present) != 0; }
1110 
1111   void set_contended_group(u2 group) { _contended_group = group; }
1112   u2 contended_group() const { return _contended_group; }
1113 
1114   bool is_contended() const { return has_annotation(_jdk_internal_vm_annotation_Contended); }
1115 
1116   void set_stable(bool stable) { set_annotation(_field_Stable); }
1117   bool is_stable() const { return has_annotation(_field_Stable); }
1118 };
1119 
1120 // This class also doubles as a holder for metadata cleanup.
1121 class ClassFileParser::FieldAnnotationCollector : public AnnotationCollector {
1122 private:
1123   ClassLoaderData* _loader_data;
1124   AnnotationArray* _field_annotations;
1125   AnnotationArray* _field_type_annotations;
1126 public:
1127   FieldAnnotationCollector(ClassLoaderData* loader_data) :
1128     AnnotationCollector(_in_field),
1129     _loader_data(loader_data),
1130     _field_annotations(NULL),
1131     _field_type_annotations(NULL) {}
1132   ~FieldAnnotationCollector();
1133   void apply_to(FieldInfo* f);
1134   AnnotationArray* field_annotations()      { return _field_annotations; }
1135   AnnotationArray* field_type_annotations() { return _field_type_annotations; }
1136 
1137   void set_field_annotations(AnnotationArray* a)      { _field_annotations = a; }
1138   void set_field_type_annotations(AnnotationArray* a) { _field_type_annotations = a; }
1139 };
1140 
1141 class MethodAnnotationCollector : public AnnotationCollector{
1142 public:
1143   MethodAnnotationCollector() : AnnotationCollector(_in_method) { }
1144   void apply_to(const methodHandle&amp; m);
1145 };
1146 
1147 class ClassFileParser::ClassAnnotationCollector : public AnnotationCollector{
1148 public:
1149   ClassAnnotationCollector() : AnnotationCollector(_in_class) { }
1150   void apply_to(InstanceKlass* ik);
1151 };
1152 
1153 
1154 static int skip_annotation_value(const u1*, int, int); // fwd decl
1155 
1156 // Safely increment index by val if does not pass limit
1157 #define SAFE_ADD(index, limit, val) \
1158 if (index &gt;= limit - val) return limit; \
1159 index += val;
1160 
1161 // Skip an annotation.  Return &gt;=limit if there is any problem.
1162 static int skip_annotation(const u1* buffer, int limit, int index) {
1163   assert(buffer != NULL, &quot;invariant&quot;);
1164   // annotation := atype:u2 do(nmem:u2) {member:u2 value}
1165   // value := switch (tag:u1) { ... }
1166   SAFE_ADD(index, limit, 4); // skip atype and read nmem
1167   int nmem = Bytes::get_Java_u2((address)buffer + index - 2);
1168   while (--nmem &gt;= 0 &amp;&amp; index &lt; limit) {
1169     SAFE_ADD(index, limit, 2); // skip member
1170     index = skip_annotation_value(buffer, limit, index);
1171   }
1172   return index;
1173 }
1174 
1175 // Skip an annotation value.  Return &gt;=limit if there is any problem.
1176 static int skip_annotation_value(const u1* buffer, int limit, int index) {
1177   assert(buffer != NULL, &quot;invariant&quot;);
1178 
1179   // value := switch (tag:u1) {
1180   //   case B, C, I, S, Z, D, F, J, c: con:u2;
1181   //   case e: e_class:u2 e_name:u2;
1182   //   case s: s_con:u2;
1183   //   case [: do(nval:u2) {value};
1184   //   case @: annotation;
1185   //   case s: s_con:u2;
1186   // }
1187   SAFE_ADD(index, limit, 1); // read tag
1188   const u1 tag = buffer[index - 1];
1189   switch (tag) {
1190     case &#39;B&#39;:
1191     case &#39;C&#39;:
1192     case &#39;I&#39;:
1193     case &#39;S&#39;:
1194     case &#39;Z&#39;:
1195     case &#39;D&#39;:
1196     case &#39;F&#39;:
1197     case &#39;J&#39;:
1198     case &#39;c&#39;:
1199     case &#39;s&#39;:
1200       SAFE_ADD(index, limit, 2);  // skip con or s_con
1201       break;
1202     case &#39;e&#39;:
1203       SAFE_ADD(index, limit, 4);  // skip e_class, e_name
1204       break;
1205     case &#39;[&#39;:
1206     {
1207       SAFE_ADD(index, limit, 2); // read nval
1208       int nval = Bytes::get_Java_u2((address)buffer + index - 2);
1209       while (--nval &gt;= 0 &amp;&amp; index &lt; limit) {
1210         index = skip_annotation_value(buffer, limit, index);
1211       }
1212     }
1213     break;
1214     case &#39;@&#39;:
1215       index = skip_annotation(buffer, limit, index);
1216       break;
1217     default:
1218       return limit;  //  bad tag byte
1219   }
1220   return index;
1221 }
1222 
1223 // Sift through annotations, looking for those significant to the VM:
1224 static void parse_annotations(const ConstantPool* const cp,
1225                               const u1* buffer, int limit,
1226                               AnnotationCollector* coll,
1227                               ClassLoaderData* loader_data,
1228                               TRAPS) {
1229 
1230   assert(cp != NULL, &quot;invariant&quot;);
1231   assert(buffer != NULL, &quot;invariant&quot;);
1232   assert(coll != NULL, &quot;invariant&quot;);
1233   assert(loader_data != NULL, &quot;invariant&quot;);
1234 
1235   // annotations := do(nann:u2) {annotation}
1236   int index = 2; // read nann
1237   if (index &gt;= limit)  return;
1238   int nann = Bytes::get_Java_u2((address)buffer + index - 2);
1239   enum {  // initial annotation layout
1240     atype_off = 0,      // utf8 such as &#39;Ljava/lang/annotation/Retention;&#39;
1241     count_off = 2,      // u2   such as 1 (one value)
1242     member_off = 4,     // utf8 such as &#39;value&#39;
1243     tag_off = 6,        // u1   such as &#39;c&#39; (type) or &#39;e&#39; (enum)
1244     e_tag_val = &#39;e&#39;,
1245     e_type_off = 7,   // utf8 such as &#39;Ljava/lang/annotation/RetentionPolicy;&#39;
1246     e_con_off = 9,    // utf8 payload, such as &#39;SOURCE&#39;, &#39;CLASS&#39;, &#39;RUNTIME&#39;
1247     e_size = 11,     // end of &#39;e&#39; annotation
1248     c_tag_val = &#39;c&#39;,    // payload is type
1249     c_con_off = 7,    // utf8 payload, such as &#39;I&#39;
1250     c_size = 9,       // end of &#39;c&#39; annotation
1251     s_tag_val = &#39;s&#39;,    // payload is String
1252     s_con_off = 7,    // utf8 payload, such as &#39;Ljava/lang/String;&#39;
1253     s_size = 9,
1254     min_size = 6        // smallest possible size (zero members)
1255   };
1256   // Cannot add min_size to index in case of overflow MAX_INT
1257   while ((--nann) &gt;= 0 &amp;&amp; (index - 2 &lt;= limit - min_size)) {
1258     int index0 = index;
1259     index = skip_annotation(buffer, limit, index);
1260     const u1* const abase = buffer + index0;
1261     const int atype = Bytes::get_Java_u2((address)abase + atype_off);
1262     const int count = Bytes::get_Java_u2((address)abase + count_off);
1263     const Symbol* const aname = check_symbol_at(cp, atype);
1264     if (aname == NULL)  break;  // invalid annotation name
1265     const Symbol* member = NULL;
1266     if (count &gt;= 1) {
1267       const int member_index = Bytes::get_Java_u2((address)abase + member_off);
1268       member = check_symbol_at(cp, member_index);
1269       if (member == NULL)  break;  // invalid member name
1270     }
1271 
1272     // Here is where parsing particular annotations will take place.
1273     AnnotationCollector::ID id = coll-&gt;annotation_index(loader_data, aname);
1274     if (AnnotationCollector::_unknown == id)  continue;
1275     coll-&gt;set_annotation(id);
1276 
1277     if (AnnotationCollector::_jdk_internal_vm_annotation_Contended == id) {
1278       // @Contended can optionally specify the contention group.
1279       //
1280       // Contended group defines the equivalence class over the fields:
1281       // the fields within the same contended group are not treated distinct.
1282       // The only exception is default group, which does not incur the
1283       // equivalence. Naturally, contention group for classes is meaningless.
1284       //
1285       // While the contention group is specified as String, annotation
1286       // values are already interned, and we might as well use the constant
1287       // pool index as the group tag.
1288       //
1289       u2 group_index = 0; // default contended group
1290       if (count == 1
1291         &amp;&amp; s_size == (index - index0)  // match size
1292         &amp;&amp; s_tag_val == *(abase + tag_off)
1293         &amp;&amp; member == vmSymbols::value_name()) {
1294         group_index = Bytes::get_Java_u2((address)abase + s_con_off);
1295         if (cp-&gt;symbol_at(group_index)-&gt;utf8_length() == 0) {
1296           group_index = 0; // default contended group
1297         }
1298       }
1299       coll-&gt;set_contended_group(group_index);
1300     }
1301   }
1302 }
1303 
1304 
1305 // Parse attributes for a field.
1306 void ClassFileParser::parse_field_attributes(const ClassFileStream* const cfs,
1307                                              u2 attributes_count,
1308                                              bool is_static, u2 signature_index,
1309                                              u2* const constantvalue_index_addr,
1310                                              bool* const is_synthetic_addr,
1311                                              u2* const generic_signature_index_addr,
1312                                              ClassFileParser::FieldAnnotationCollector* parsed_annotations,
1313                                              TRAPS) {
1314   assert(cfs != NULL, &quot;invariant&quot;);
1315   assert(constantvalue_index_addr != NULL, &quot;invariant&quot;);
1316   assert(is_synthetic_addr != NULL, &quot;invariant&quot;);
1317   assert(generic_signature_index_addr != NULL, &quot;invariant&quot;);
1318   assert(parsed_annotations != NULL, &quot;invariant&quot;);
1319   assert(attributes_count &gt; 0, &quot;attributes_count should be greater than 0&quot;);
1320 
1321   u2 constantvalue_index = 0;
1322   u2 generic_signature_index = 0;
1323   bool is_synthetic = false;
1324   const u1* runtime_visible_annotations = NULL;
1325   int runtime_visible_annotations_length = 0;
1326   const u1* runtime_invisible_annotations = NULL;
1327   int runtime_invisible_annotations_length = 0;
1328   const u1* runtime_visible_type_annotations = NULL;
1329   int runtime_visible_type_annotations_length = 0;
1330   const u1* runtime_invisible_type_annotations = NULL;
1331   int runtime_invisible_type_annotations_length = 0;
1332   bool runtime_invisible_annotations_exists = false;
1333   bool runtime_invisible_type_annotations_exists = false;
1334   const ConstantPool* const cp = _cp;
1335 
1336   while (attributes_count--) {
1337     cfs-&gt;guarantee_more(6, CHECK);  // attribute_name_index, attribute_length
1338     const u2 attribute_name_index = cfs-&gt;get_u2_fast();
1339     const u4 attribute_length = cfs-&gt;get_u4_fast();
1340     check_property(valid_symbol_at(attribute_name_index),
1341                    &quot;Invalid field attribute index %u in class file %s&quot;,
1342                    attribute_name_index,
1343                    CHECK);
1344 
1345     const Symbol* const attribute_name = cp-&gt;symbol_at(attribute_name_index);
1346     if (is_static &amp;&amp; attribute_name == vmSymbols::tag_constant_value()) {
1347       // ignore if non-static
1348       if (constantvalue_index != 0) {
1349         classfile_parse_error(&quot;Duplicate ConstantValue attribute in class file %s&quot;, CHECK);
1350       }
1351       check_property(
1352         attribute_length == 2,
1353         &quot;Invalid ConstantValue field attribute length %u in class file %s&quot;,
1354         attribute_length, CHECK);
1355 
1356       constantvalue_index = cfs-&gt;get_u2(CHECK);
1357       if (_need_verify) {
1358         verify_constantvalue(cp, constantvalue_index, signature_index, CHECK);
1359       }
1360     } else if (attribute_name == vmSymbols::tag_synthetic()) {
1361       if (attribute_length != 0) {
1362         classfile_parse_error(
1363           &quot;Invalid Synthetic field attribute length %u in class file %s&quot;,
1364           attribute_length, CHECK);
1365       }
1366       is_synthetic = true;
1367     } else if (attribute_name == vmSymbols::tag_deprecated()) { // 4276120
1368       if (attribute_length != 0) {
1369         classfile_parse_error(
1370           &quot;Invalid Deprecated field attribute length %u in class file %s&quot;,
1371           attribute_length, CHECK);
1372       }
1373     } else if (_major_version &gt;= JAVA_1_5_VERSION) {
1374       if (attribute_name == vmSymbols::tag_signature()) {
1375         if (generic_signature_index != 0) {
1376           classfile_parse_error(
1377             &quot;Multiple Signature attributes for field in class file %s&quot;, CHECK);
1378         }
1379         if (attribute_length != 2) {
1380           classfile_parse_error(
1381             &quot;Wrong size %u for field&#39;s Signature attribute in class file %s&quot;,
1382             attribute_length, CHECK);
1383         }
1384         generic_signature_index = parse_generic_signature_attribute(cfs, CHECK);
1385       } else if (attribute_name == vmSymbols::tag_runtime_visible_annotations()) {
1386         if (runtime_visible_annotations != NULL) {
1387           classfile_parse_error(
1388             &quot;Multiple RuntimeVisibleAnnotations attributes for field in class file %s&quot;, CHECK);
1389         }
1390         runtime_visible_annotations_length = attribute_length;
1391         runtime_visible_annotations = cfs-&gt;current();
1392         assert(runtime_visible_annotations != NULL, &quot;null visible annotations&quot;);
1393         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK);
1394         parse_annotations(cp,
1395                           runtime_visible_annotations,
1396                           runtime_visible_annotations_length,
1397                           parsed_annotations,
1398                           _loader_data,
1399                           CHECK);
1400         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
1401       } else if (attribute_name == vmSymbols::tag_runtime_invisible_annotations()) {
1402         if (runtime_invisible_annotations_exists) {
1403           classfile_parse_error(
1404             &quot;Multiple RuntimeInvisibleAnnotations attributes for field in class file %s&quot;, CHECK);
1405         }
1406         runtime_invisible_annotations_exists = true;
1407         if (PreserveAllAnnotations) {
1408           runtime_invisible_annotations_length = attribute_length;
1409           runtime_invisible_annotations = cfs-&gt;current();
1410           assert(runtime_invisible_annotations != NULL, &quot;null invisible annotations&quot;);
1411         }
1412         cfs-&gt;skip_u1(attribute_length, CHECK);
1413       } else if (attribute_name == vmSymbols::tag_runtime_visible_type_annotations()) {
1414         if (runtime_visible_type_annotations != NULL) {
1415           classfile_parse_error(
1416             &quot;Multiple RuntimeVisibleTypeAnnotations attributes for field in class file %s&quot;, CHECK);
1417         }
1418         runtime_visible_type_annotations_length = attribute_length;
1419         runtime_visible_type_annotations = cfs-&gt;current();
1420         assert(runtime_visible_type_annotations != NULL, &quot;null visible type annotations&quot;);
1421         cfs-&gt;skip_u1(runtime_visible_type_annotations_length, CHECK);
1422       } else if (attribute_name == vmSymbols::tag_runtime_invisible_type_annotations()) {
1423         if (runtime_invisible_type_annotations_exists) {
1424           classfile_parse_error(
1425             &quot;Multiple RuntimeInvisibleTypeAnnotations attributes for field in class file %s&quot;, CHECK);
1426         } else {
1427           runtime_invisible_type_annotations_exists = true;
1428         }
1429         if (PreserveAllAnnotations) {
1430           runtime_invisible_type_annotations_length = attribute_length;
1431           runtime_invisible_type_annotations = cfs-&gt;current();
1432           assert(runtime_invisible_type_annotations != NULL, &quot;null invisible type annotations&quot;);
1433         }
1434         cfs-&gt;skip_u1(attribute_length, CHECK);
1435       } else {
1436         cfs-&gt;skip_u1(attribute_length, CHECK);  // Skip unknown attributes
1437       }
1438     } else {
1439       cfs-&gt;skip_u1(attribute_length, CHECK);  // Skip unknown attributes
1440     }
1441   }
1442 
1443   *constantvalue_index_addr = constantvalue_index;
1444   *is_synthetic_addr = is_synthetic;
1445   *generic_signature_index_addr = generic_signature_index;
1446   AnnotationArray* a = assemble_annotations(runtime_visible_annotations,
1447                                             runtime_visible_annotations_length,
1448                                             runtime_invisible_annotations,
1449                                             runtime_invisible_annotations_length,
1450                                             CHECK);
1451   parsed_annotations-&gt;set_field_annotations(a);
1452   a = assemble_annotations(runtime_visible_type_annotations,
1453                            runtime_visible_type_annotations_length,
1454                            runtime_invisible_type_annotations,
1455                            runtime_invisible_type_annotations_length,
1456                            CHECK);
1457   parsed_annotations-&gt;set_field_type_annotations(a);
1458   return;
1459 }
1460 
1461 
1462 // Field allocation types. Used for computing field offsets.
1463 
1464 enum FieldAllocationType {
1465   STATIC_OOP,           // Oops
1466   STATIC_BYTE,          // Boolean, Byte, char
1467   STATIC_SHORT,         // shorts
1468   STATIC_WORD,          // ints
1469   STATIC_DOUBLE,        // aligned long or double
1470   NONSTATIC_OOP,
1471   NONSTATIC_BYTE,
1472   NONSTATIC_SHORT,
1473   NONSTATIC_WORD,
1474   NONSTATIC_DOUBLE,
1475   MAX_FIELD_ALLOCATION_TYPE,
1476   BAD_ALLOCATION_TYPE = -1
1477 };
1478 
1479 static FieldAllocationType _basic_type_to_atype[2 * (T_CONFLICT + 1)] = {
1480   BAD_ALLOCATION_TYPE, // 0
1481   BAD_ALLOCATION_TYPE, // 1
1482   BAD_ALLOCATION_TYPE, // 2
1483   BAD_ALLOCATION_TYPE, // 3
1484   NONSTATIC_BYTE ,     // T_BOOLEAN     =  4,
1485   NONSTATIC_SHORT,     // T_CHAR        =  5,
1486   NONSTATIC_WORD,      // T_FLOAT       =  6,
1487   NONSTATIC_DOUBLE,    // T_DOUBLE      =  7,
1488   NONSTATIC_BYTE,      // T_BYTE        =  8,
1489   NONSTATIC_SHORT,     // T_SHORT       =  9,
1490   NONSTATIC_WORD,      // T_INT         = 10,
1491   NONSTATIC_DOUBLE,    // T_LONG        = 11,
1492   NONSTATIC_OOP,       // T_OBJECT      = 12,
1493   NONSTATIC_OOP,       // T_ARRAY       = 13,
1494   BAD_ALLOCATION_TYPE, // T_VOID        = 14,
1495   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 15,
1496   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 16,
1497   BAD_ALLOCATION_TYPE, // T_METADATA    = 17,
1498   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 18,
1499   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 19,
1500   BAD_ALLOCATION_TYPE, // 0
1501   BAD_ALLOCATION_TYPE, // 1
1502   BAD_ALLOCATION_TYPE, // 2
1503   BAD_ALLOCATION_TYPE, // 3
1504   STATIC_BYTE ,        // T_BOOLEAN     =  4,
1505   STATIC_SHORT,        // T_CHAR        =  5,
1506   STATIC_WORD,         // T_FLOAT       =  6,
1507   STATIC_DOUBLE,       // T_DOUBLE      =  7,
1508   STATIC_BYTE,         // T_BYTE        =  8,
1509   STATIC_SHORT,        // T_SHORT       =  9,
1510   STATIC_WORD,         // T_INT         = 10,
1511   STATIC_DOUBLE,       // T_LONG        = 11,
1512   STATIC_OOP,          // T_OBJECT      = 12,
1513   STATIC_OOP,          // T_ARRAY       = 13,
1514   BAD_ALLOCATION_TYPE, // T_VOID        = 14,
1515   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 15,
1516   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 16,
1517   BAD_ALLOCATION_TYPE, // T_METADATA    = 17,
1518   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 18,
1519   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 19,
1520 };
1521 
1522 static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type) {
1523   assert(type &gt;= T_BOOLEAN &amp;&amp; type &lt; T_VOID, &quot;only allowable values&quot;);
1524   FieldAllocationType result = _basic_type_to_atype[type + (is_static ? (T_CONFLICT + 1) : 0)];
1525   assert(result != BAD_ALLOCATION_TYPE, &quot;bad type&quot;);
1526   return result;
1527 }
1528 
1529 class ClassFileParser::FieldAllocationCount : public ResourceObj {
1530  public:
1531   u2 count[MAX_FIELD_ALLOCATION_TYPE];
1532 
1533   FieldAllocationCount() {
1534     for (int i = 0; i &lt; MAX_FIELD_ALLOCATION_TYPE; i++) {
1535       count[i] = 0;
1536     }
1537   }
1538 
1539   FieldAllocationType update(bool is_static, BasicType type) {
1540     FieldAllocationType atype = basic_type_to_atype(is_static, type);
1541     if (atype != BAD_ALLOCATION_TYPE) {
1542       // Make sure there is no overflow with injected fields.
1543       assert(count[atype] &lt; 0xFFFF, &quot;More than 65535 fields&quot;);
1544       count[atype]++;
1545     }
1546     return atype;
1547   }
1548 };
1549 
1550 // Side-effects: populates the _fields, _fields_annotations,
1551 // _fields_type_annotations fields
1552 void ClassFileParser::parse_fields(const ClassFileStream* const cfs,
1553                                    bool is_interface,
1554                                    FieldAllocationCount* const fac,
1555                                    ConstantPool* cp,
1556                                    const int cp_size,
1557                                    u2* const java_fields_count_ptr,
1558                                    TRAPS) {
1559 
1560   assert(cfs != NULL, &quot;invariant&quot;);
1561   assert(fac != NULL, &quot;invariant&quot;);
1562   assert(cp != NULL, &quot;invariant&quot;);
1563   assert(java_fields_count_ptr != NULL, &quot;invariant&quot;);
1564 
1565   assert(NULL == _fields, &quot;invariant&quot;);
1566   assert(NULL == _fields_annotations, &quot;invariant&quot;);
1567   assert(NULL == _fields_type_annotations, &quot;invariant&quot;);
1568 
1569   cfs-&gt;guarantee_more(2, CHECK);  // length
1570   const u2 length = cfs-&gt;get_u2_fast();
1571   *java_fields_count_ptr = length;
1572 
1573   int num_injected = 0;
1574   const InjectedField* const injected = JavaClasses::get_injected(_class_name,
1575                                                                   &amp;num_injected);
1576   const int total_fields = length + num_injected;
1577 
1578   // The field array starts with tuples of shorts
1579   // [access, name index, sig index, initial value index, byte offset].
1580   // A generic signature slot only exists for field with generic
1581   // signature attribute. And the access flag is set with
1582   // JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE for that field. The generic
1583   // signature slots are at the end of the field array and after all
1584   // other fields data.
1585   //
1586   //   f1: [access, name index, sig index, initial value index, low_offset, high_offset]
1587   //   f2: [access, name index, sig index, initial value index, low_offset, high_offset]
1588   //       ...
1589   //   fn: [access, name index, sig index, initial value index, low_offset, high_offset]
1590   //       [generic signature index]
1591   //       [generic signature index]
1592   //       ...
1593   //
1594   // Allocate a temporary resource array for field data. For each field,
1595   // a slot is reserved in the temporary array for the generic signature
1596   // index. After parsing all fields, the data are copied to a permanent
1597   // array and any unused slots will be discarded.
1598   ResourceMark rm(THREAD);
1599   u2* const fa = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1600                                               u2,
1601                                               total_fields * (FieldInfo::field_slots + 1));
1602 
1603   // The generic signature slots start after all other fields&#39; data.
1604   int generic_signature_slot = total_fields * FieldInfo::field_slots;
1605   int num_generic_signature = 0;
1606   for (int n = 0; n &lt; length; n++) {
1607     // access_flags, name_index, descriptor_index, attributes_count
1608     cfs-&gt;guarantee_more(8, CHECK);
1609 
1610     AccessFlags access_flags;
1611     const jint flags = cfs-&gt;get_u2_fast() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
1612     verify_legal_field_modifiers(flags, is_interface, CHECK);
1613     access_flags.set_flags(flags);
1614 
1615     const u2 name_index = cfs-&gt;get_u2_fast();
1616     check_property(valid_symbol_at(name_index),
1617       &quot;Invalid constant pool index %u for field name in class file %s&quot;,
1618       name_index, CHECK);
1619     const Symbol* const name = cp-&gt;symbol_at(name_index);
1620     verify_legal_field_name(name, CHECK);
1621 
1622     const u2 signature_index = cfs-&gt;get_u2_fast();
1623     check_property(valid_symbol_at(signature_index),
1624       &quot;Invalid constant pool index %u for field signature in class file %s&quot;,
1625       signature_index, CHECK);
1626     const Symbol* const sig = cp-&gt;symbol_at(signature_index);
1627     verify_legal_field_signature(name, sig, CHECK);
1628 
1629     u2 constantvalue_index = 0;
1630     bool is_synthetic = false;
1631     u2 generic_signature_index = 0;
1632     const bool is_static = access_flags.is_static();
1633     FieldAnnotationCollector parsed_annotations(_loader_data);
1634 
1635     const u2 attributes_count = cfs-&gt;get_u2_fast();
1636     if (attributes_count &gt; 0) {
1637       parse_field_attributes(cfs,
1638                              attributes_count,
1639                              is_static,
1640                              signature_index,
1641                              &amp;constantvalue_index,
1642                              &amp;is_synthetic,
1643                              &amp;generic_signature_index,
1644                              &amp;parsed_annotations,
1645                              CHECK);
1646 
1647       if (parsed_annotations.field_annotations() != NULL) {
1648         if (_fields_annotations == NULL) {
1649           _fields_annotations = MetadataFactory::new_array&lt;AnnotationArray*&gt;(
1650                                              _loader_data, length, NULL,
1651                                              CHECK);
1652         }
1653         _fields_annotations-&gt;at_put(n, parsed_annotations.field_annotations());
1654         parsed_annotations.set_field_annotations(NULL);
1655       }
1656       if (parsed_annotations.field_type_annotations() != NULL) {
1657         if (_fields_type_annotations == NULL) {
1658           _fields_type_annotations =
1659             MetadataFactory::new_array&lt;AnnotationArray*&gt;(_loader_data,
1660                                                          length,
1661                                                          NULL,
1662                                                          CHECK);
1663         }
1664         _fields_type_annotations-&gt;at_put(n, parsed_annotations.field_type_annotations());
1665         parsed_annotations.set_field_type_annotations(NULL);
1666       }
1667 
1668       if (is_synthetic) {
1669         access_flags.set_is_synthetic();
1670       }
1671       if (generic_signature_index != 0) {
1672         access_flags.set_field_has_generic_signature();
1673         fa[generic_signature_slot] = generic_signature_index;
1674         generic_signature_slot ++;
1675         num_generic_signature ++;
1676       }
1677     }
1678 
1679     FieldInfo* const field = FieldInfo::from_field_array(fa, n);
1680     field-&gt;initialize(access_flags.as_short(),
1681                       name_index,
1682                       signature_index,
1683                       constantvalue_index);
1684     const BasicType type = cp-&gt;basic_type_for_signature_at(signature_index);
1685 
1686     // Remember how many oops we encountered and compute allocation type
1687     const FieldAllocationType atype = fac-&gt;update(is_static, type);
1688     field-&gt;set_allocation_type(atype);
1689 
1690     // After field is initialized with type, we can augment it with aux info
1691     if (parsed_annotations.has_any_annotations()) {
1692       parsed_annotations.apply_to(field);
1693       if (field-&gt;is_contended()) {
1694         _has_contended_fields = true;
1695       }
1696     }
1697   }
1698 
1699   int index = length;
1700   if (num_injected != 0) {
1701     for (int n = 0; n &lt; num_injected; n++) {
1702       // Check for duplicates
1703       if (injected[n].may_be_java) {
1704         const Symbol* const name      = injected[n].name();
1705         const Symbol* const signature = injected[n].signature();
1706         bool duplicate = false;
1707         for (int i = 0; i &lt; length; i++) {
1708           const FieldInfo* const f = FieldInfo::from_field_array(fa, i);
1709           if (name      == cp-&gt;symbol_at(f-&gt;name_index()) &amp;&amp;
1710               signature == cp-&gt;symbol_at(f-&gt;signature_index())) {
1711             // Symbol is desclared in Java so skip this one
1712             duplicate = true;
1713             break;
1714           }
1715         }
1716         if (duplicate) {
1717           // These will be removed from the field array at the end
1718           continue;
1719         }
1720       }
1721 
1722       // Injected field
1723       FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1724       field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1725                         injected[n].name_index,
1726                         injected[n].signature_index,
1727                         0);
1728 
1729       const BasicType type = Signature::basic_type(injected[n].signature());
1730 
1731       // Remember how many oops we encountered and compute allocation type
1732       const FieldAllocationType atype = fac-&gt;update(false, type);
1733       field-&gt;set_allocation_type(atype);
1734       index++;
1735     }
1736   }
1737 
1738   assert(NULL == _fields, &quot;invariant&quot;);
1739 
1740   _fields =
1741     MetadataFactory::new_array&lt;u2&gt;(_loader_data,
1742                                    index * FieldInfo::field_slots + num_generic_signature,
1743                                    CHECK);
1744   // Sometimes injected fields already exist in the Java source so
1745   // the fields array could be too long.  In that case the
1746   // fields array is trimed. Also unused slots that were reserved
1747   // for generic signature indexes are discarded.
1748   {
1749     int i = 0;
1750     for (; i &lt; index * FieldInfo::field_slots; i++) {
1751       _fields-&gt;at_put(i, fa[i]);
1752     }
1753     for (int j = total_fields * FieldInfo::field_slots;
1754          j &lt; generic_signature_slot; j++) {
1755       _fields-&gt;at_put(i++, fa[j]);
1756     }
1757     assert(_fields-&gt;length() == i, &quot;&quot;);
1758   }
1759 
1760   if (_need_verify &amp;&amp; length &gt; 1) {
1761     // Check duplicated fields
1762     ResourceMark rm(THREAD);
1763     NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(
1764       THREAD, NameSigHash*, HASH_ROW_SIZE);
1765     initialize_hashtable(names_and_sigs);
1766     bool dup = false;
1767     const Symbol* name = NULL;
1768     const Symbol* sig = NULL;
1769     {
1770       debug_only(NoSafepointVerifier nsv;)
1771       for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
1772         name = fs.name();
1773         sig = fs.signature();
1774         // If no duplicates, add name/signature in hashtable names_and_sigs.
1775         if (!put_after_lookup(name, sig, names_and_sigs)) {
1776           dup = true;
1777           break;
1778         }
1779       }
1780     }
1781     if (dup) {
1782       classfile_parse_error(&quot;Duplicate field name \&quot;%s\&quot; with signature \&quot;%s\&quot; in class file %s&quot;,
1783                              name-&gt;as_C_string(), sig-&gt;as_klass_external_name(), CHECK);
1784     }
1785   }
1786 }
1787 
1788 
1789 const ClassFileParser::unsafe_u2* ClassFileParser::parse_exception_table(const ClassFileStream* const cfs,
1790                                                                          u4 code_length,
1791                                                                          u4 exception_table_length,
1792                                                                          TRAPS) {
1793   assert(cfs != NULL, &quot;invariant&quot;);
1794 
1795   const unsafe_u2* const exception_table_start = cfs-&gt;current();
1796   assert(exception_table_start != NULL, &quot;null exception table&quot;);
1797 
1798   cfs-&gt;guarantee_more(8 * exception_table_length, CHECK_NULL); // start_pc,
1799                                                                // end_pc,
1800                                                                // handler_pc,
1801                                                                // catch_type_index
1802 
1803   // Will check legal target after parsing code array in verifier.
1804   if (_need_verify) {
1805     for (unsigned int i = 0; i &lt; exception_table_length; i++) {
1806       const u2 start_pc = cfs-&gt;get_u2_fast();
1807       const u2 end_pc = cfs-&gt;get_u2_fast();
1808       const u2 handler_pc = cfs-&gt;get_u2_fast();
1809       const u2 catch_type_index = cfs-&gt;get_u2_fast();
1810       guarantee_property((start_pc &lt; end_pc) &amp;&amp; (end_pc &lt;= code_length),
1811                          &quot;Illegal exception table range in class file %s&quot;,
1812                          CHECK_NULL);
1813       guarantee_property(handler_pc &lt; code_length,
1814                          &quot;Illegal exception table handler in class file %s&quot;,
1815                          CHECK_NULL);
1816       if (catch_type_index != 0) {
1817         guarantee_property(valid_klass_reference_at(catch_type_index),
1818                            &quot;Catch type in exception table has bad constant type in class file %s&quot;, CHECK_NULL);
1819       }
1820     }
1821   } else {
1822     cfs-&gt;skip_u2_fast(exception_table_length * 4);
1823   }
1824   return exception_table_start;
1825 }
1826 
1827 void ClassFileParser::parse_linenumber_table(u4 code_attribute_length,
1828                                              u4 code_length,
1829                                              CompressedLineNumberWriteStream**const write_stream,
1830                                              TRAPS) {
1831 
1832   const ClassFileStream* const cfs = _stream;
1833   unsigned int num_entries = cfs-&gt;get_u2(CHECK);
1834 
1835   // Each entry is a u2 start_pc, and a u2 line_number
1836   const unsigned int length_in_bytes = num_entries * (sizeof(u2) * 2);
1837 
1838   // Verify line number attribute and table length
1839   check_property(
1840     code_attribute_length == sizeof(u2) + length_in_bytes,
1841     &quot;LineNumberTable attribute has wrong length in class file %s&quot;, CHECK);
1842 
1843   cfs-&gt;guarantee_more(length_in_bytes, CHECK);
1844 
1845   if ((*write_stream) == NULL) {
1846     if (length_in_bytes &gt; fixed_buffer_size) {
1847       (*write_stream) = new CompressedLineNumberWriteStream(length_in_bytes);
1848     } else {
1849       (*write_stream) = new CompressedLineNumberWriteStream(
1850         _linenumbertable_buffer, fixed_buffer_size);
1851     }
1852   }
1853 
1854   while (num_entries-- &gt; 0) {
1855     const u2 bci  = cfs-&gt;get_u2_fast(); // start_pc
1856     const u2 line = cfs-&gt;get_u2_fast(); // line_number
1857     guarantee_property(bci &lt; code_length,
1858         &quot;Invalid pc in LineNumberTable in class file %s&quot;, CHECK);
1859     (*write_stream)-&gt;write_pair(bci, line);
1860   }
1861 }
1862 
1863 
1864 class LVT_Hash : public AllStatic {
1865  public:
1866 
1867   static bool equals(LocalVariableTableElement const&amp; e0, LocalVariableTableElement const&amp; e1) {
1868   /*
1869    * 3-tuple start_bci/length/slot has to be unique key,
1870    * so the following comparison seems to be redundant:
1871    *       &amp;&amp; elem-&gt;name_cp_index == entry-&gt;_elem-&gt;name_cp_index
1872    */
1873     return (e0.start_bci     == e1.start_bci &amp;&amp;
1874             e0.length        == e1.length &amp;&amp;
1875             e0.name_cp_index == e1.name_cp_index &amp;&amp;
1876             e0.slot          == e1.slot);
1877   }
1878 
1879   static unsigned int hash(LocalVariableTableElement const&amp; e0) {
1880     unsigned int raw_hash = e0.start_bci;
1881 
1882     raw_hash = e0.length        + raw_hash * 37;
1883     raw_hash = e0.name_cp_index + raw_hash * 37;
1884     raw_hash = e0.slot          + raw_hash * 37;
1885 
1886     return raw_hash;
1887   }
1888 };
1889 
1890 
1891 // Class file LocalVariableTable elements.
1892 class Classfile_LVT_Element {
1893  public:
1894   u2 start_bci;
1895   u2 length;
1896   u2 name_cp_index;
1897   u2 descriptor_cp_index;
1898   u2 slot;
1899 };
1900 
1901 static void copy_lvt_element(const Classfile_LVT_Element* const src,
1902                              LocalVariableTableElement* const lvt) {
1903   lvt-&gt;start_bci           = Bytes::get_Java_u2((u1*) &amp;src-&gt;start_bci);
1904   lvt-&gt;length              = Bytes::get_Java_u2((u1*) &amp;src-&gt;length);
1905   lvt-&gt;name_cp_index       = Bytes::get_Java_u2((u1*) &amp;src-&gt;name_cp_index);
1906   lvt-&gt;descriptor_cp_index = Bytes::get_Java_u2((u1*) &amp;src-&gt;descriptor_cp_index);
1907   lvt-&gt;signature_cp_index  = 0;
1908   lvt-&gt;slot                = Bytes::get_Java_u2((u1*) &amp;src-&gt;slot);
1909 }
1910 
1911 // Function is used to parse both attributes:
1912 // LocalVariableTable (LVT) and LocalVariableTypeTable (LVTT)
1913 const ClassFileParser::unsafe_u2* ClassFileParser::parse_localvariable_table(const ClassFileStream* cfs,
1914                                                                              u4 code_length,
1915                                                                              u2 max_locals,
1916                                                                              u4 code_attribute_length,
1917                                                                              u2* const localvariable_table_length,
1918                                                                              bool isLVTT,
1919                                                                              TRAPS) {
1920   const char* const tbl_name = (isLVTT) ? &quot;LocalVariableTypeTable&quot; : &quot;LocalVariableTable&quot;;
1921   *localvariable_table_length = cfs-&gt;get_u2(CHECK_NULL);
1922   const unsigned int size =
1923     (*localvariable_table_length) * sizeof(Classfile_LVT_Element) / sizeof(u2);
1924 
1925   const ConstantPool* const cp = _cp;
1926 
1927   // Verify local variable table attribute has right length
1928   if (_need_verify) {
1929     guarantee_property(code_attribute_length == (sizeof(*localvariable_table_length) + size * sizeof(u2)),
1930                        &quot;%s has wrong length in class file %s&quot;, tbl_name, CHECK_NULL);
1931   }
1932 
1933   const unsafe_u2* const localvariable_table_start = cfs-&gt;current();
1934   assert(localvariable_table_start != NULL, &quot;null local variable table&quot;);
1935   if (!_need_verify) {
1936     cfs-&gt;skip_u2_fast(size);
1937   } else {
1938     cfs-&gt;guarantee_more(size * 2, CHECK_NULL);
1939     for(int i = 0; i &lt; (*localvariable_table_length); i++) {
1940       const u2 start_pc = cfs-&gt;get_u2_fast();
1941       const u2 length = cfs-&gt;get_u2_fast();
1942       const u2 name_index = cfs-&gt;get_u2_fast();
1943       const u2 descriptor_index = cfs-&gt;get_u2_fast();
1944       const u2 index = cfs-&gt;get_u2_fast();
1945       // Assign to a u4 to avoid overflow
1946       const u4 end_pc = (u4)start_pc + (u4)length;
1947 
1948       if (start_pc &gt;= code_length) {
1949         classfile_parse_error(
1950           &quot;Invalid start_pc %u in %s in class file %s&quot;,
1951           start_pc, tbl_name, CHECK_NULL);
1952       }
1953       if (end_pc &gt; code_length) {
1954         classfile_parse_error(
1955           &quot;Invalid length %u in %s in class file %s&quot;,
1956           length, tbl_name, CHECK_NULL);
1957       }
1958       const int cp_size = cp-&gt;length();
1959       guarantee_property(valid_symbol_at(name_index),
1960         &quot;Name index %u in %s has bad constant type in class file %s&quot;,
1961         name_index, tbl_name, CHECK_NULL);
1962       guarantee_property(valid_symbol_at(descriptor_index),
1963         &quot;Signature index %u in %s has bad constant type in class file %s&quot;,
1964         descriptor_index, tbl_name, CHECK_NULL);
1965 
1966       const Symbol* const name = cp-&gt;symbol_at(name_index);
1967       const Symbol* const sig = cp-&gt;symbol_at(descriptor_index);
1968       verify_legal_field_name(name, CHECK_NULL);
1969       u2 extra_slot = 0;
1970       if (!isLVTT) {
1971         verify_legal_field_signature(name, sig, CHECK_NULL);
1972 
1973         // 4894874: check special cases for double and long local variables
1974         if (sig == vmSymbols::type_signature(T_DOUBLE) ||
1975             sig == vmSymbols::type_signature(T_LONG)) {
1976           extra_slot = 1;
1977         }
1978       }
1979       guarantee_property((index + extra_slot) &lt; max_locals,
1980                           &quot;Invalid index %u in %s in class file %s&quot;,
1981                           index, tbl_name, CHECK_NULL);
1982     }
1983   }
1984   return localvariable_table_start;
1985 }
1986 
1987 static const u1* parse_stackmap_table(const ClassFileStream* const cfs,
1988                                       u4 code_attribute_length,
1989                                       bool need_verify,
1990                                       TRAPS) {
1991   assert(cfs != NULL, &quot;invariant&quot;);
1992 
1993   if (0 == code_attribute_length) {
1994     return NULL;
1995   }
1996 
1997   const u1* const stackmap_table_start = cfs-&gt;current();
1998   assert(stackmap_table_start != NULL, &quot;null stackmap table&quot;);
1999 
2000   // check code_attribute_length first
2001   cfs-&gt;skip_u1(code_attribute_length, CHECK_NULL);
2002 
2003   if (!need_verify &amp;&amp; !DumpSharedSpaces) {
2004     return NULL;
2005   }
2006   return stackmap_table_start;
2007 }
2008 
2009 const ClassFileParser::unsafe_u2* ClassFileParser::parse_checked_exceptions(const ClassFileStream* const cfs,
2010                                                                             u2* const checked_exceptions_length,
2011                                                                             u4 method_attribute_length,
2012                                                                             TRAPS) {
2013   assert(cfs != NULL, &quot;invariant&quot;);
2014   assert(checked_exceptions_length != NULL, &quot;invariant&quot;);
2015 
2016   cfs-&gt;guarantee_more(2, CHECK_NULL);  // checked_exceptions_length
2017   *checked_exceptions_length = cfs-&gt;get_u2_fast();
2018   const unsigned int size =
2019     (*checked_exceptions_length) * sizeof(CheckedExceptionElement) / sizeof(u2);
2020   const unsafe_u2* const checked_exceptions_start = cfs-&gt;current();
2021   assert(checked_exceptions_start != NULL, &quot;null checked exceptions&quot;);
2022   if (!_need_verify) {
2023     cfs-&gt;skip_u2_fast(size);
2024   } else {
2025     // Verify each value in the checked exception table
2026     u2 checked_exception;
2027     const u2 len = *checked_exceptions_length;
2028     cfs-&gt;guarantee_more(2 * len, CHECK_NULL);
2029     for (int i = 0; i &lt; len; i++) {
2030       checked_exception = cfs-&gt;get_u2_fast();
2031       check_property(
2032         valid_klass_reference_at(checked_exception),
2033         &quot;Exception name has bad type at constant pool %u in class file %s&quot;,
2034         checked_exception, CHECK_NULL);
2035     }
2036   }
2037   // check exceptions attribute length
2038   if (_need_verify) {
2039     guarantee_property(method_attribute_length == (sizeof(*checked_exceptions_length) +
2040                                                    sizeof(u2) * size),
2041                       &quot;Exceptions attribute has wrong length in class file %s&quot;, CHECK_NULL);
2042   }
2043   return checked_exceptions_start;
2044 }
2045 
2046 void ClassFileParser::throwIllegalSignature(const char* type,
2047                                             const Symbol* name,
2048                                             const Symbol* sig,
2049                                             TRAPS) const {
2050   assert(name != NULL, &quot;invariant&quot;);
2051   assert(sig != NULL, &quot;invariant&quot;);
2052 
2053   ResourceMark rm(THREAD);
2054   Exceptions::fthrow(THREAD_AND_LOCATION,
2055       vmSymbols::java_lang_ClassFormatError(),
2056       &quot;%s \&quot;%s\&quot; in class %s has illegal signature \&quot;%s\&quot;&quot;, type,
2057       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), sig-&gt;as_C_string());
2058 }
2059 
2060 AnnotationCollector::ID
2061 AnnotationCollector::annotation_index(const ClassLoaderData* loader_data,
2062                                       const Symbol* name) {
2063   const vmSymbols::SID sid = vmSymbols::find_sid(name);
2064   // Privileged code can use all annotations.  Other code silently drops some.
2065   const bool privileged = loader_data-&gt;is_the_null_class_loader_data() ||
2066                           loader_data-&gt;is_platform_class_loader_data() ||
2067                           loader_data-&gt;is_unsafe_anonymous();
2068   switch (sid) {
2069     case vmSymbols::VM_SYMBOL_ENUM_NAME(reflect_CallerSensitive_signature): {
2070       if (_location != _in_method)  break;  // only allow for methods
2071       if (!privileged)              break;  // only allow in privileged code
2072       return _method_CallerSensitive;
2073     }
2074     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ForceInline_signature): {
2075       if (_location != _in_method)  break;  // only allow for methods
2076       if (!privileged)              break;  // only allow in privileged code
2077       return _method_ForceInline;
2078     }
2079     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_DontInline_signature): {
2080       if (_location != _in_method)  break;  // only allow for methods
2081       if (!privileged)              break;  // only allow in privileged code
2082       return _method_DontInline;
2083     }
2084     case vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_InjectedProfile_signature): {
2085       if (_location != _in_method)  break;  // only allow for methods
2086       if (!privileged)              break;  // only allow in privileged code
2087       return _method_InjectedProfile;
2088     }
2089     case vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_LambdaForm_Compiled_signature): {
2090       if (_location != _in_method)  break;  // only allow for methods
2091       if (!privileged)              break;  // only allow in privileged code
2092       return _method_LambdaForm_Compiled;
2093     }
2094     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Hidden_signature): {
2095       if (_location != _in_method)  break;  // only allow for methods
2096       if (!privileged)              break;  // only allow in privileged code
2097       return _method_Hidden;
2098     }
2099     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_HotSpotIntrinsicCandidate_signature): {
2100       if (_location != _in_method)  break;  // only allow for methods
2101       if (!privileged)              break;  // only allow in privileged code
2102       return _method_HotSpotIntrinsicCandidate;
2103     }
2104     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Stable_signature): {
2105       if (_location != _in_field)   break;  // only allow for fields
2106       if (!privileged)              break;  // only allow in privileged code
2107       return _field_Stable;
2108     }
2109     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Contended_signature): {
2110       if (_location != _in_field &amp;&amp; _location != _in_class) {
2111         break;  // only allow for fields and classes
2112       }
2113       if (!EnableContended || (RestrictContended &amp;&amp; !privileged)) {
2114         break;  // honor privileges
2115       }
2116       return _jdk_internal_vm_annotation_Contended;
2117     }
2118     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ReservedStackAccess_signature): {
2119       if (_location != _in_method)  break;  // only allow for methods
2120       if (RestrictReservedStack &amp;&amp; !privileged) break; // honor privileges
2121       return _jdk_internal_vm_annotation_ReservedStackAccess;
2122     }
2123     default: {
2124       break;
2125     }
2126   }
2127   return AnnotationCollector::_unknown;
2128 }
2129 
2130 void ClassFileParser::FieldAnnotationCollector::apply_to(FieldInfo* f) {
2131   if (is_contended())
2132     f-&gt;set_contended_group(contended_group());
2133   if (is_stable())
2134     f-&gt;set_stable(true);
2135 }
2136 
2137 ClassFileParser::FieldAnnotationCollector::~FieldAnnotationCollector() {
2138   // If there&#39;s an error deallocate metadata for field annotations
2139   MetadataFactory::free_array&lt;u1&gt;(_loader_data, _field_annotations);
2140   MetadataFactory::free_array&lt;u1&gt;(_loader_data, _field_type_annotations);
2141 }
2142 
2143 void MethodAnnotationCollector::apply_to(const methodHandle&amp; m) {
2144   if (has_annotation(_method_CallerSensitive))
2145     m-&gt;set_caller_sensitive(true);
2146   if (has_annotation(_method_ForceInline))
2147     m-&gt;set_force_inline(true);
2148   if (has_annotation(_method_DontInline))
2149     m-&gt;set_dont_inline(true);
2150   if (has_annotation(_method_InjectedProfile))
2151     m-&gt;set_has_injected_profile(true);
2152   if (has_annotation(_method_LambdaForm_Compiled) &amp;&amp; m-&gt;intrinsic_id() == vmIntrinsics::_none)
2153     m-&gt;set_intrinsic_id(vmIntrinsics::_compiledLambdaForm);
2154   if (has_annotation(_method_Hidden))
2155     m-&gt;set_hidden(true);
2156   if (has_annotation(_method_HotSpotIntrinsicCandidate) &amp;&amp; !m-&gt;is_synthetic())
2157     m-&gt;set_intrinsic_candidate(true);
2158   if (has_annotation(_jdk_internal_vm_annotation_ReservedStackAccess))
2159     m-&gt;set_has_reserved_stack_access(true);
2160 }
2161 
2162 void ClassFileParser::ClassAnnotationCollector::apply_to(InstanceKlass* ik) {
2163   assert(ik != NULL, &quot;invariant&quot;);
2164   ik-&gt;set_is_contended(is_contended());
2165 }
2166 
2167 #define MAX_ARGS_SIZE 255
2168 #define MAX_CODE_SIZE 65535
2169 #define INITIAL_MAX_LVT_NUMBER 256
2170 
2171 /* Copy class file LVT&#39;s/LVTT&#39;s into the HotSpot internal LVT.
2172  *
2173  * Rules for LVT&#39;s and LVTT&#39;s are:
2174  *   - There can be any number of LVT&#39;s and LVTT&#39;s.
2175  *   - If there are n LVT&#39;s, it is the same as if there was just
2176  *     one LVT containing all the entries from the n LVT&#39;s.
2177  *   - There may be no more than one LVT entry per local variable.
2178  *     Two LVT entries are &#39;equal&#39; if these fields are the same:
2179  *        start_pc, length, name, slot
2180  *   - There may be no more than one LVTT entry per each LVT entry.
2181  *     Each LVTT entry has to match some LVT entry.
2182  *   - HotSpot internal LVT keeps natural ordering of class file LVT entries.
2183  */
2184 void ClassFileParser::copy_localvariable_table(const ConstMethod* cm,
2185                                                int lvt_cnt,
2186                                                u2* const localvariable_table_length,
2187                                                const unsafe_u2** const localvariable_table_start,
2188                                                int lvtt_cnt,
2189                                                u2* const localvariable_type_table_length,
2190                                                const unsafe_u2** const localvariable_type_table_start,
2191                                                TRAPS) {
2192 
2193   ResourceMark rm(THREAD);
2194 
2195   typedef ResourceHashtable&lt;LocalVariableTableElement, LocalVariableTableElement*,
2196                             &amp;LVT_Hash::hash, &amp;LVT_Hash::equals&gt; LVT_HashTable;
2197 
2198   LVT_HashTable* const table = new LVT_HashTable();
2199 
2200   // To fill LocalVariableTable in
2201   const Classfile_LVT_Element* cf_lvt;
2202   LocalVariableTableElement* lvt = cm-&gt;localvariable_table_start();
2203 
2204   for (int tbl_no = 0; tbl_no &lt; lvt_cnt; tbl_no++) {
2205     cf_lvt = (Classfile_LVT_Element *) localvariable_table_start[tbl_no];
2206     for (int idx = 0; idx &lt; localvariable_table_length[tbl_no]; idx++, lvt++) {
2207       copy_lvt_element(&amp;cf_lvt[idx], lvt);
2208       // If no duplicates, add LVT elem in hashtable.
2209       if (table-&gt;put(*lvt, lvt) == false
2210           &amp;&amp; _need_verify
2211           &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
2212         classfile_parse_error(&quot;Duplicated LocalVariableTable attribute &quot;
2213                               &quot;entry for &#39;%s&#39; in class file %s&quot;,
2214                                _cp-&gt;symbol_at(lvt-&gt;name_cp_index)-&gt;as_utf8(),
2215                                CHECK);
2216       }
2217     }
2218   }
2219 
2220   // To merge LocalVariableTable and LocalVariableTypeTable
2221   const Classfile_LVT_Element* cf_lvtt;
2222   LocalVariableTableElement lvtt_elem;
2223 
2224   for (int tbl_no = 0; tbl_no &lt; lvtt_cnt; tbl_no++) {
2225     cf_lvtt = (Classfile_LVT_Element *) localvariable_type_table_start[tbl_no];
2226     for (int idx = 0; idx &lt; localvariable_type_table_length[tbl_no]; idx++) {
2227       copy_lvt_element(&amp;cf_lvtt[idx], &amp;lvtt_elem);
2228       LocalVariableTableElement** entry = table-&gt;get(lvtt_elem);
2229       if (entry == NULL) {
2230         if (_need_verify) {
2231           classfile_parse_error(&quot;LVTT entry for &#39;%s&#39; in class file %s &quot;
2232                                 &quot;does not match any LVT entry&quot;,
2233                                  _cp-&gt;symbol_at(lvtt_elem.name_cp_index)-&gt;as_utf8(),
2234                                  CHECK);
2235         }
2236       } else if ((*entry)-&gt;signature_cp_index != 0 &amp;&amp; _need_verify) {
2237         classfile_parse_error(&quot;Duplicated LocalVariableTypeTable attribute &quot;
2238                               &quot;entry for &#39;%s&#39; in class file %s&quot;,
2239                                _cp-&gt;symbol_at(lvtt_elem.name_cp_index)-&gt;as_utf8(),
2240                                CHECK);
2241       } else {
2242         // to add generic signatures into LocalVariableTable
2243         (*entry)-&gt;signature_cp_index = lvtt_elem.descriptor_cp_index;
2244       }
2245     }
2246   }
2247 }
2248 
2249 
2250 void ClassFileParser::copy_method_annotations(ConstMethod* cm,
2251                                        const u1* runtime_visible_annotations,
2252                                        int runtime_visible_annotations_length,
2253                                        const u1* runtime_invisible_annotations,
2254                                        int runtime_invisible_annotations_length,
2255                                        const u1* runtime_visible_parameter_annotations,
2256                                        int runtime_visible_parameter_annotations_length,
2257                                        const u1* runtime_invisible_parameter_annotations,
2258                                        int runtime_invisible_parameter_annotations_length,
2259                                        const u1* runtime_visible_type_annotations,
2260                                        int runtime_visible_type_annotations_length,
2261                                        const u1* runtime_invisible_type_annotations,
2262                                        int runtime_invisible_type_annotations_length,
2263                                        const u1* annotation_default,
2264                                        int annotation_default_length,
2265                                        TRAPS) {
2266 
2267   AnnotationArray* a;
2268 
2269   if (runtime_visible_annotations_length +
2270       runtime_invisible_annotations_length &gt; 0) {
2271      a = assemble_annotations(runtime_visible_annotations,
2272                               runtime_visible_annotations_length,
2273                               runtime_invisible_annotations,
2274                               runtime_invisible_annotations_length,
2275                               CHECK);
2276      cm-&gt;set_method_annotations(a);
2277   }
2278 
2279   if (runtime_visible_parameter_annotations_length +
2280       runtime_invisible_parameter_annotations_length &gt; 0) {
2281     a = assemble_annotations(runtime_visible_parameter_annotations,
2282                              runtime_visible_parameter_annotations_length,
2283                              runtime_invisible_parameter_annotations,
2284                              runtime_invisible_parameter_annotations_length,
2285                              CHECK);
2286     cm-&gt;set_parameter_annotations(a);
2287   }
2288 
2289   if (annotation_default_length &gt; 0) {
2290     a = assemble_annotations(annotation_default,
2291                              annotation_default_length,
2292                              NULL,
2293                              0,
2294                              CHECK);
2295     cm-&gt;set_default_annotations(a);
2296   }
2297 
2298   if (runtime_visible_type_annotations_length +
2299       runtime_invisible_type_annotations_length &gt; 0) {
2300     a = assemble_annotations(runtime_visible_type_annotations,
2301                              runtime_visible_type_annotations_length,
2302                              runtime_invisible_type_annotations,
2303                              runtime_invisible_type_annotations_length,
2304                              CHECK);
2305     cm-&gt;set_type_annotations(a);
2306   }
2307 }
2308 
2309 
2310 // Note: the parse_method below is big and clunky because all parsing of the code and exceptions
2311 // attribute is inlined. This is cumbersome to avoid since we inline most of the parts in the
2312 // Method* to save footprint, so we only know the size of the resulting Method* when the
2313 // entire method attribute is parsed.
2314 //
2315 // The promoted_flags parameter is used to pass relevant access_flags
2316 // from the method back up to the containing klass. These flag values
2317 // are added to klass&#39;s access_flags.
2318 
2319 Method* ClassFileParser::parse_method(const ClassFileStream* const cfs,
2320                                       bool is_interface,
2321                                       const ConstantPool* cp,
2322                                       AccessFlags* const promoted_flags,
2323                                       TRAPS) {
2324   assert(cfs != NULL, &quot;invariant&quot;);
2325   assert(cp != NULL, &quot;invariant&quot;);
2326   assert(promoted_flags != NULL, &quot;invariant&quot;);
2327 
2328   ResourceMark rm(THREAD);
2329   // Parse fixed parts:
2330   // access_flags, name_index, descriptor_index, attributes_count
2331   cfs-&gt;guarantee_more(8, CHECK_NULL);
2332 
2333   int flags = cfs-&gt;get_u2_fast();
2334   const u2 name_index = cfs-&gt;get_u2_fast();
2335   const int cp_size = cp-&gt;length();
2336   check_property(
2337     valid_symbol_at(name_index),
2338     &quot;Illegal constant pool index %u for method name in class file %s&quot;,
2339     name_index, CHECK_NULL);
2340   const Symbol* const name = cp-&gt;symbol_at(name_index);
2341   verify_legal_method_name(name, CHECK_NULL);
2342 
2343   const u2 signature_index = cfs-&gt;get_u2_fast();
2344   guarantee_property(
2345     valid_symbol_at(signature_index),
2346     &quot;Illegal constant pool index %u for method signature in class file %s&quot;,
2347     signature_index, CHECK_NULL);
2348   const Symbol* const signature = cp-&gt;symbol_at(signature_index);
2349 
2350   if (name == vmSymbols::class_initializer_name()) {
2351     // We ignore the other access flags for a valid class initializer.
2352     // (JVM Spec 2nd ed., chapter 4.6)
2353     if (_major_version &lt; 51) { // backward compatibility
2354       flags = JVM_ACC_STATIC;
2355     } else if ((flags &amp; JVM_ACC_STATIC) == JVM_ACC_STATIC) {
2356       flags &amp;= JVM_ACC_STATIC | JVM_ACC_STRICT;
2357     } else {
2358       classfile_parse_error(&quot;Method &lt;clinit&gt; is not static in class file %s&quot;, CHECK_NULL);
2359     }
2360   } else {
2361     verify_legal_method_modifiers(flags, is_interface, name, CHECK_NULL);
2362   }
2363 
2364   if (name == vmSymbols::object_initializer_name() &amp;&amp; is_interface) {
2365     classfile_parse_error(&quot;Interface cannot have a method named &lt;init&gt;, class file %s&quot;, CHECK_NULL);
2366   }
2367 
2368   int args_size = -1;  // only used when _need_verify is true
2369   if (_need_verify) {
2370     args_size = ((flags &amp; JVM_ACC_STATIC) ? 0 : 1) +
2371                  verify_legal_method_signature(name, signature, CHECK_NULL);
2372     if (args_size &gt; MAX_ARGS_SIZE) {
2373       classfile_parse_error(&quot;Too many arguments in method signature in class file %s&quot;, CHECK_NULL);
2374     }
2375   }
2376 
2377   AccessFlags access_flags(flags &amp; JVM_RECOGNIZED_METHOD_MODIFIERS);
2378 
2379   // Default values for code and exceptions attribute elements
2380   u2 max_stack = 0;
2381   u2 max_locals = 0;
2382   u4 code_length = 0;
2383   const u1* code_start = 0;
2384   u2 exception_table_length = 0;
2385   const unsafe_u2* exception_table_start = NULL; // (potentially unaligned) pointer to array of u2 elements
2386   Array&lt;int&gt;* exception_handlers = Universe::the_empty_int_array();
2387   u2 checked_exceptions_length = 0;
2388   const unsafe_u2* checked_exceptions_start = NULL; // (potentially unaligned) pointer to array of u2 elements
2389   CompressedLineNumberWriteStream* linenumber_table = NULL;
2390   int linenumber_table_length = 0;
2391   int total_lvt_length = 0;
2392   u2 lvt_cnt = 0;
2393   u2 lvtt_cnt = 0;
2394   bool lvt_allocated = false;
2395   u2 max_lvt_cnt = INITIAL_MAX_LVT_NUMBER;
2396   u2 max_lvtt_cnt = INITIAL_MAX_LVT_NUMBER;
2397   u2* localvariable_table_length = NULL;
2398   const unsafe_u2** localvariable_table_start = NULL; // (potentially unaligned) pointer to array of LVT attributes
2399   u2* localvariable_type_table_length = NULL;
2400   const unsafe_u2** localvariable_type_table_start = NULL; // (potentially unaligned) pointer to LVTT attributes
2401   int method_parameters_length = -1;
2402   const u1* method_parameters_data = NULL;
2403   bool method_parameters_seen = false;
2404   bool parsed_code_attribute = false;
2405   bool parsed_checked_exceptions_attribute = false;
2406   bool parsed_stackmap_attribute = false;
2407   // stackmap attribute - JDK1.5
2408   const u1* stackmap_data = NULL;
2409   int stackmap_data_length = 0;
2410   u2 generic_signature_index = 0;
2411   MethodAnnotationCollector parsed_annotations;
2412   const u1* runtime_visible_annotations = NULL;
2413   int runtime_visible_annotations_length = 0;
2414   const u1* runtime_invisible_annotations = NULL;
2415   int runtime_invisible_annotations_length = 0;
2416   const u1* runtime_visible_parameter_annotations = NULL;
2417   int runtime_visible_parameter_annotations_length = 0;
2418   const u1* runtime_invisible_parameter_annotations = NULL;
2419   int runtime_invisible_parameter_annotations_length = 0;
2420   const u1* runtime_visible_type_annotations = NULL;
2421   int runtime_visible_type_annotations_length = 0;
2422   const u1* runtime_invisible_type_annotations = NULL;
2423   int runtime_invisible_type_annotations_length = 0;
2424   bool runtime_invisible_annotations_exists = false;
2425   bool runtime_invisible_type_annotations_exists = false;
2426   bool runtime_invisible_parameter_annotations_exists = false;
2427   const u1* annotation_default = NULL;
2428   int annotation_default_length = 0;
2429 
2430   // Parse code and exceptions attribute
2431   u2 method_attributes_count = cfs-&gt;get_u2_fast();
2432   while (method_attributes_count--) {
2433     cfs-&gt;guarantee_more(6, CHECK_NULL);  // method_attribute_name_index, method_attribute_length
2434     const u2 method_attribute_name_index = cfs-&gt;get_u2_fast();
2435     const u4 method_attribute_length = cfs-&gt;get_u4_fast();
2436     check_property(
2437       valid_symbol_at(method_attribute_name_index),
2438       &quot;Invalid method attribute name index %u in class file %s&quot;,
2439       method_attribute_name_index, CHECK_NULL);
2440 
2441     const Symbol* const method_attribute_name = cp-&gt;symbol_at(method_attribute_name_index);
2442     if (method_attribute_name == vmSymbols::tag_code()) {
2443       // Parse Code attribute
2444       if (_need_verify) {
2445         guarantee_property(
2446             !access_flags.is_native() &amp;&amp; !access_flags.is_abstract(),
2447                         &quot;Code attribute in native or abstract methods in class file %s&quot;,
2448                          CHECK_NULL);
2449       }
2450       if (parsed_code_attribute) {
2451         classfile_parse_error(&quot;Multiple Code attributes in class file %s&quot;,
2452                               CHECK_NULL);
2453       }
2454       parsed_code_attribute = true;
2455 
2456       // Stack size, locals size, and code size
2457       cfs-&gt;guarantee_more(8, CHECK_NULL);
2458       max_stack = cfs-&gt;get_u2_fast();
2459       max_locals = cfs-&gt;get_u2_fast();
2460       code_length = cfs-&gt;get_u4_fast();
2461       if (_need_verify) {
2462         guarantee_property(args_size &lt;= max_locals,
2463                            &quot;Arguments can&#39;t fit into locals in class file %s&quot;,
2464                            CHECK_NULL);
2465         guarantee_property(code_length &gt; 0 &amp;&amp; code_length &lt;= MAX_CODE_SIZE,
2466                            &quot;Invalid method Code length %u in class file %s&quot;,
2467                            code_length, CHECK_NULL);
2468       }
2469       // Code pointer
2470       code_start = cfs-&gt;current();
2471       assert(code_start != NULL, &quot;null code start&quot;);
2472       cfs-&gt;guarantee_more(code_length, CHECK_NULL);
2473       cfs-&gt;skip_u1_fast(code_length);
2474 
2475       // Exception handler table
2476       cfs-&gt;guarantee_more(2, CHECK_NULL);  // exception_table_length
2477       exception_table_length = cfs-&gt;get_u2_fast();
2478       if (exception_table_length &gt; 0) {
2479         exception_table_start = parse_exception_table(cfs,
2480                                                       code_length,
2481                                                       exception_table_length,
2482                                                       CHECK_NULL);
2483       }
2484 
2485       // Parse additional attributes in code attribute
2486       cfs-&gt;guarantee_more(2, CHECK_NULL);  // code_attributes_count
2487       u2 code_attributes_count = cfs-&gt;get_u2_fast();
2488 
2489       unsigned int calculated_attribute_length = 0;
2490 
2491       calculated_attribute_length =
2492           sizeof(max_stack) + sizeof(max_locals) + sizeof(code_length);
2493       calculated_attribute_length +=
2494         code_length +
2495         sizeof(exception_table_length) +
2496         sizeof(code_attributes_count) +
2497         exception_table_length *
2498             ( sizeof(u2) +   // start_pc
2499               sizeof(u2) +   // end_pc
2500               sizeof(u2) +   // handler_pc
2501               sizeof(u2) );  // catch_type_index
2502 
2503       while (code_attributes_count--) {
2504         cfs-&gt;guarantee_more(6, CHECK_NULL);  // code_attribute_name_index, code_attribute_length
2505         const u2 code_attribute_name_index = cfs-&gt;get_u2_fast();
2506         const u4 code_attribute_length = cfs-&gt;get_u4_fast();
2507         calculated_attribute_length += code_attribute_length +
2508                                        sizeof(code_attribute_name_index) +
2509                                        sizeof(code_attribute_length);
2510         check_property(valid_symbol_at(code_attribute_name_index),
2511                        &quot;Invalid code attribute name index %u in class file %s&quot;,
2512                        code_attribute_name_index,
2513                        CHECK_NULL);
2514         if (LoadLineNumberTables &amp;&amp;
2515             cp-&gt;symbol_at(code_attribute_name_index) == vmSymbols::tag_line_number_table()) {
2516           // Parse and compress line number table
2517           parse_linenumber_table(code_attribute_length,
2518                                  code_length,
2519                                  &amp;linenumber_table,
2520                                  CHECK_NULL);
2521 
2522         } else if (LoadLocalVariableTables &amp;&amp;
2523                    cp-&gt;symbol_at(code_attribute_name_index) == vmSymbols::tag_local_variable_table()) {
2524           // Parse local variable table
2525           if (!lvt_allocated) {
2526             localvariable_table_length = NEW_RESOURCE_ARRAY_IN_THREAD(
2527               THREAD, u2,  INITIAL_MAX_LVT_NUMBER);
2528             localvariable_table_start = NEW_RESOURCE_ARRAY_IN_THREAD(
2529               THREAD, const unsafe_u2*, INITIAL_MAX_LVT_NUMBER);
2530             localvariable_type_table_length = NEW_RESOURCE_ARRAY_IN_THREAD(
2531               THREAD, u2,  INITIAL_MAX_LVT_NUMBER);
2532             localvariable_type_table_start = NEW_RESOURCE_ARRAY_IN_THREAD(
2533               THREAD, const unsafe_u2*, INITIAL_MAX_LVT_NUMBER);
2534             lvt_allocated = true;
2535           }
2536           if (lvt_cnt == max_lvt_cnt) {
2537             max_lvt_cnt &lt;&lt;= 1;
2538             localvariable_table_length = REALLOC_RESOURCE_ARRAY(u2, localvariable_table_length, lvt_cnt, max_lvt_cnt);
2539             localvariable_table_start  = REALLOC_RESOURCE_ARRAY(const unsafe_u2*, localvariable_table_start, lvt_cnt, max_lvt_cnt);
2540           }
2541           localvariable_table_start[lvt_cnt] =
2542             parse_localvariable_table(cfs,
2543                                       code_length,
2544                                       max_locals,
2545                                       code_attribute_length,
2546                                       &amp;localvariable_table_length[lvt_cnt],
2547                                       false,    // is not LVTT
2548                                       CHECK_NULL);
2549           total_lvt_length += localvariable_table_length[lvt_cnt];
2550           lvt_cnt++;
2551         } else if (LoadLocalVariableTypeTables &amp;&amp;
2552                    _major_version &gt;= JAVA_1_5_VERSION &amp;&amp;
2553                    cp-&gt;symbol_at(code_attribute_name_index) == vmSymbols::tag_local_variable_type_table()) {
2554           if (!lvt_allocated) {
2555             localvariable_table_length = NEW_RESOURCE_ARRAY_IN_THREAD(
2556               THREAD, u2,  INITIAL_MAX_LVT_NUMBER);
2557             localvariable_table_start = NEW_RESOURCE_ARRAY_IN_THREAD(
2558               THREAD, const unsafe_u2*, INITIAL_MAX_LVT_NUMBER);
2559             localvariable_type_table_length = NEW_RESOURCE_ARRAY_IN_THREAD(
2560               THREAD, u2,  INITIAL_MAX_LVT_NUMBER);
2561             localvariable_type_table_start = NEW_RESOURCE_ARRAY_IN_THREAD(
2562               THREAD, const unsafe_u2*, INITIAL_MAX_LVT_NUMBER);
2563             lvt_allocated = true;
2564           }
2565           // Parse local variable type table
2566           if (lvtt_cnt == max_lvtt_cnt) {
2567             max_lvtt_cnt &lt;&lt;= 1;
2568             localvariable_type_table_length = REALLOC_RESOURCE_ARRAY(u2, localvariable_type_table_length, lvtt_cnt, max_lvtt_cnt);
2569             localvariable_type_table_start  = REALLOC_RESOURCE_ARRAY(const unsafe_u2*, localvariable_type_table_start, lvtt_cnt, max_lvtt_cnt);
2570           }
2571           localvariable_type_table_start[lvtt_cnt] =
2572             parse_localvariable_table(cfs,
2573                                       code_length,
2574                                       max_locals,
2575                                       code_attribute_length,
2576                                       &amp;localvariable_type_table_length[lvtt_cnt],
2577                                       true,     // is LVTT
2578                                       CHECK_NULL);
2579           lvtt_cnt++;
2580         } else if (_major_version &gt;= Verifier::STACKMAP_ATTRIBUTE_MAJOR_VERSION &amp;&amp;
2581                    cp-&gt;symbol_at(code_attribute_name_index) == vmSymbols::tag_stack_map_table()) {
2582           // Stack map is only needed by the new verifier in JDK1.5.
2583           if (parsed_stackmap_attribute) {
2584             classfile_parse_error(&quot;Multiple StackMapTable attributes in class file %s&quot;, CHECK_NULL);
2585           }
2586           stackmap_data = parse_stackmap_table(cfs, code_attribute_length, _need_verify, CHECK_NULL);
2587           stackmap_data_length = code_attribute_length;
2588           parsed_stackmap_attribute = true;
2589         } else {
2590           // Skip unknown attributes
2591           cfs-&gt;skip_u1(code_attribute_length, CHECK_NULL);
2592         }
2593       }
2594       // check method attribute length
2595       if (_need_verify) {
2596         guarantee_property(method_attribute_length == calculated_attribute_length,
2597                            &quot;Code segment has wrong length in class file %s&quot;,
2598                            CHECK_NULL);
2599       }
2600     } else if (method_attribute_name == vmSymbols::tag_exceptions()) {
2601       // Parse Exceptions attribute
2602       if (parsed_checked_exceptions_attribute) {
2603         classfile_parse_error(&quot;Multiple Exceptions attributes in class file %s&quot;,
2604                               CHECK_NULL);
2605       }
2606       parsed_checked_exceptions_attribute = true;
2607       checked_exceptions_start =
2608             parse_checked_exceptions(cfs,
2609                                      &amp;checked_exceptions_length,
2610                                      method_attribute_length,
2611                                      CHECK_NULL);
2612     } else if (method_attribute_name == vmSymbols::tag_method_parameters()) {
2613       // reject multiple method parameters
2614       if (method_parameters_seen) {
2615         classfile_parse_error(&quot;Multiple MethodParameters attributes in class file %s&quot;,
2616                               CHECK_NULL);
2617       }
2618       method_parameters_seen = true;
2619       method_parameters_length = cfs-&gt;get_u1_fast();
2620       const u2 real_length = (method_parameters_length * 4u) + 1u;
2621       if (method_attribute_length != real_length) {
2622         classfile_parse_error(
2623           &quot;Invalid MethodParameters method attribute length %u in class file&quot;,
2624           method_attribute_length, CHECK_NULL);
2625       }
2626       method_parameters_data = cfs-&gt;current();
2627       cfs-&gt;skip_u2_fast(method_parameters_length);
2628       cfs-&gt;skip_u2_fast(method_parameters_length);
2629       // ignore this attribute if it cannot be reflected
2630       if (!SystemDictionary::Parameter_klass_loaded())
2631         method_parameters_length = -1;
2632     } else if (method_attribute_name == vmSymbols::tag_synthetic()) {
2633       if (method_attribute_length != 0) {
2634         classfile_parse_error(
2635           &quot;Invalid Synthetic method attribute length %u in class file %s&quot;,
2636           method_attribute_length, CHECK_NULL);
2637       }
2638       // Should we check that there hasn&#39;t already been a synthetic attribute?
2639       access_flags.set_is_synthetic();
2640     } else if (method_attribute_name == vmSymbols::tag_deprecated()) { // 4276120
2641       if (method_attribute_length != 0) {
2642         classfile_parse_error(
2643           &quot;Invalid Deprecated method attribute length %u in class file %s&quot;,
2644           method_attribute_length, CHECK_NULL);
2645       }
2646     } else if (_major_version &gt;= JAVA_1_5_VERSION) {
2647       if (method_attribute_name == vmSymbols::tag_signature()) {
2648         if (generic_signature_index != 0) {
2649           classfile_parse_error(
2650             &quot;Multiple Signature attributes for method in class file %s&quot;,
2651             CHECK_NULL);
2652         }
2653         if (method_attribute_length != 2) {
2654           classfile_parse_error(
2655             &quot;Invalid Signature attribute length %u in class file %s&quot;,
2656             method_attribute_length, CHECK_NULL);
2657         }
2658         generic_signature_index = parse_generic_signature_attribute(cfs, CHECK_NULL);
2659       } else if (method_attribute_name == vmSymbols::tag_runtime_visible_annotations()) {
2660         if (runtime_visible_annotations != NULL) {
2661           classfile_parse_error(
2662             &quot;Multiple RuntimeVisibleAnnotations attributes for method in class file %s&quot;,
2663             CHECK_NULL);
2664         }
2665         runtime_visible_annotations_length = method_attribute_length;
2666         runtime_visible_annotations = cfs-&gt;current();
2667         assert(runtime_visible_annotations != NULL, &quot;null visible annotations&quot;);
2668         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK_NULL);
2669         parse_annotations(cp,
2670                           runtime_visible_annotations,
2671                           runtime_visible_annotations_length,
2672                           &amp;parsed_annotations,
2673                           _loader_data,
2674                           CHECK_NULL);
2675         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
2676       } else if (method_attribute_name == vmSymbols::tag_runtime_invisible_annotations()) {
2677         if (runtime_invisible_annotations_exists) {
2678           classfile_parse_error(
2679             &quot;Multiple RuntimeInvisibleAnnotations attributes for method in class file %s&quot;,
2680             CHECK_NULL);
2681         }
2682         runtime_invisible_annotations_exists = true;
2683         if (PreserveAllAnnotations) {
2684           runtime_invisible_annotations_length = method_attribute_length;
2685           runtime_invisible_annotations = cfs-&gt;current();
2686           assert(runtime_invisible_annotations != NULL, &quot;null invisible annotations&quot;);
2687         }
2688         cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2689       } else if (method_attribute_name == vmSymbols::tag_runtime_visible_parameter_annotations()) {
2690         if (runtime_visible_parameter_annotations != NULL) {
2691           classfile_parse_error(
2692             &quot;Multiple RuntimeVisibleParameterAnnotations attributes for method in class file %s&quot;,
2693             CHECK_NULL);
2694         }
2695         runtime_visible_parameter_annotations_length = method_attribute_length;
2696         runtime_visible_parameter_annotations = cfs-&gt;current();
2697         assert(runtime_visible_parameter_annotations != NULL, &quot;null visible parameter annotations&quot;);
2698         cfs-&gt;skip_u1(runtime_visible_parameter_annotations_length, CHECK_NULL);
2699       } else if (method_attribute_name == vmSymbols::tag_runtime_invisible_parameter_annotations()) {
2700         if (runtime_invisible_parameter_annotations_exists) {
2701           classfile_parse_error(
2702             &quot;Multiple RuntimeInvisibleParameterAnnotations attributes for method in class file %s&quot;,
2703             CHECK_NULL);
2704         }
2705         runtime_invisible_parameter_annotations_exists = true;
2706         if (PreserveAllAnnotations) {
2707           runtime_invisible_parameter_annotations_length = method_attribute_length;
2708           runtime_invisible_parameter_annotations = cfs-&gt;current();
2709           assert(runtime_invisible_parameter_annotations != NULL,
2710             &quot;null invisible parameter annotations&quot;);
2711         }
2712         cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2713       } else if (method_attribute_name == vmSymbols::tag_annotation_default()) {
2714         if (annotation_default != NULL) {
2715           classfile_parse_error(
2716             &quot;Multiple AnnotationDefault attributes for method in class file %s&quot;,
2717             CHECK_NULL);
2718         }
2719         annotation_default_length = method_attribute_length;
2720         annotation_default = cfs-&gt;current();
2721         assert(annotation_default != NULL, &quot;null annotation default&quot;);
2722         cfs-&gt;skip_u1(annotation_default_length, CHECK_NULL);
2723       } else if (method_attribute_name == vmSymbols::tag_runtime_visible_type_annotations()) {
2724         if (runtime_visible_type_annotations != NULL) {
2725           classfile_parse_error(
2726             &quot;Multiple RuntimeVisibleTypeAnnotations attributes for method in class file %s&quot;,
2727             CHECK_NULL);
2728         }
2729         runtime_visible_type_annotations_length = method_attribute_length;
2730         runtime_visible_type_annotations = cfs-&gt;current();
2731         assert(runtime_visible_type_annotations != NULL, &quot;null visible type annotations&quot;);
2732         // No need for the VM to parse Type annotations
2733         cfs-&gt;skip_u1(runtime_visible_type_annotations_length, CHECK_NULL);
2734       } else if (method_attribute_name == vmSymbols::tag_runtime_invisible_type_annotations()) {
2735         if (runtime_invisible_type_annotations_exists) {
2736           classfile_parse_error(
2737             &quot;Multiple RuntimeInvisibleTypeAnnotations attributes for method in class file %s&quot;,
2738             CHECK_NULL);
2739         } else {
2740           runtime_invisible_type_annotations_exists = true;
2741         }
2742         if (PreserveAllAnnotations) {
2743           runtime_invisible_type_annotations_length = method_attribute_length;
2744           runtime_invisible_type_annotations = cfs-&gt;current();
2745           assert(runtime_invisible_type_annotations != NULL, &quot;null invisible type annotations&quot;);
2746         }
2747         cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2748       } else {
2749         // Skip unknown attributes
2750         cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2751       }
2752     } else {
2753       // Skip unknown attributes
2754       cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2755     }
2756   }
2757 
2758   if (linenumber_table != NULL) {
2759     linenumber_table-&gt;write_terminator();
2760     linenumber_table_length = linenumber_table-&gt;position();
2761   }
2762 
2763   // Make sure there&#39;s at least one Code attribute in non-native/non-abstract method
2764   if (_need_verify) {
2765     guarantee_property(access_flags.is_native() ||
2766                        access_flags.is_abstract() ||
2767                        parsed_code_attribute,
2768                        &quot;Absent Code attribute in method that is not native or abstract in class file %s&quot;,
2769                        CHECK_NULL);
2770   }
2771 
2772   // All sizing information for a Method* is finally available, now create it
2773   InlineTableSizes sizes(
2774       total_lvt_length,
2775       linenumber_table_length,
2776       exception_table_length,
2777       checked_exceptions_length,
2778       method_parameters_length,
2779       generic_signature_index,
2780       runtime_visible_annotations_length +
2781            runtime_invisible_annotations_length,
2782       runtime_visible_parameter_annotations_length +
2783            runtime_invisible_parameter_annotations_length,
2784       runtime_visible_type_annotations_length +
2785            runtime_invisible_type_annotations_length,
2786       annotation_default_length,
2787       0);
2788 
2789   Method* const m = Method::allocate(_loader_data,
2790                                      code_length,
2791                                      access_flags,
2792                                      &amp;sizes,
2793                                      ConstMethod::NORMAL,
2794                                      CHECK_NULL);
2795 
2796   ClassLoadingService::add_class_method_size(m-&gt;size()*wordSize);
2797 
2798   // Fill in information from fixed part (access_flags already set)
2799   m-&gt;set_constants(_cp);
2800   m-&gt;set_name_index(name_index);
2801   m-&gt;set_signature_index(signature_index);
2802   m-&gt;compute_from_signature(cp-&gt;symbol_at(signature_index));
2803   assert(args_size &lt; 0 || args_size == m-&gt;size_of_parameters(), &quot;&quot;);
2804 
2805   // Fill in code attribute information
2806   m-&gt;set_max_stack(max_stack);
2807   m-&gt;set_max_locals(max_locals);
2808   if (stackmap_data != NULL) {
2809     m-&gt;constMethod()-&gt;copy_stackmap_data(_loader_data,
2810                                          (u1*)stackmap_data,
2811                                          stackmap_data_length,
2812                                          CHECK_NULL);
2813   }
2814 
2815   // Copy byte codes
2816   m-&gt;set_code((u1*)code_start);
2817 
2818   // Copy line number table
2819   if (linenumber_table != NULL) {
2820     memcpy(m-&gt;compressed_linenumber_table(),
2821            linenumber_table-&gt;buffer(),
2822            linenumber_table_length);
2823   }
2824 
2825   // Copy exception table
2826   if (exception_table_length &gt; 0) {
2827     Copy::conjoint_swap_if_needed&lt;Endian::JAVA&gt;(exception_table_start,
2828                                                 m-&gt;exception_table_start(),
2829                                                 exception_table_length * sizeof(ExceptionTableElement),
2830                                                 sizeof(u2));
2831   }
2832 
2833   // Copy method parameters
2834   if (method_parameters_length &gt; 0) {
2835     MethodParametersElement* elem = m-&gt;constMethod()-&gt;method_parameters_start();
2836     for (int i = 0; i &lt; method_parameters_length; i++) {
2837       elem[i].name_cp_index = Bytes::get_Java_u2((address)method_parameters_data);
2838       method_parameters_data += 2;
2839       elem[i].flags = Bytes::get_Java_u2((address)method_parameters_data);
2840       method_parameters_data += 2;
2841     }
2842   }
2843 
2844   // Copy checked exceptions
2845   if (checked_exceptions_length &gt; 0) {
2846     Copy::conjoint_swap_if_needed&lt;Endian::JAVA&gt;(checked_exceptions_start,
2847                                                 m-&gt;checked_exceptions_start(),
2848                                                 checked_exceptions_length * sizeof(CheckedExceptionElement),
2849                                                 sizeof(u2));
2850   }
2851 
2852   // Copy class file LVT&#39;s/LVTT&#39;s into the HotSpot internal LVT.
2853   if (total_lvt_length &gt; 0) {
2854     promoted_flags-&gt;set_has_localvariable_table();
2855     copy_localvariable_table(m-&gt;constMethod(),
2856                              lvt_cnt,
2857                              localvariable_table_length,
2858                              localvariable_table_start,
2859                              lvtt_cnt,
2860                              localvariable_type_table_length,
2861                              localvariable_type_table_start,
2862                              CHECK_NULL);
2863   }
2864 
2865   if (parsed_annotations.has_any_annotations())
2866     parsed_annotations.apply_to(methodHandle(THREAD, m));
2867 
2868   // Copy annotations
2869   copy_method_annotations(m-&gt;constMethod(),
2870                           runtime_visible_annotations,
2871                           runtime_visible_annotations_length,
2872                           runtime_invisible_annotations,
2873                           runtime_invisible_annotations_length,
2874                           runtime_visible_parameter_annotations,
2875                           runtime_visible_parameter_annotations_length,
2876                           runtime_invisible_parameter_annotations,
2877                           runtime_invisible_parameter_annotations_length,
2878                           runtime_visible_type_annotations,
2879                           runtime_visible_type_annotations_length,
2880                           runtime_invisible_type_annotations,
2881                           runtime_invisible_type_annotations_length,
2882                           annotation_default,
2883                           annotation_default_length,
2884                           CHECK_NULL);
2885 
2886   if (name == vmSymbols::finalize_method_name() &amp;&amp;
2887       signature == vmSymbols::void_method_signature()) {
2888     if (m-&gt;is_empty_method()) {
2889       _has_empty_finalizer = true;
2890     } else {
2891       _has_finalizer = true;
2892     }
2893   }
2894   if (name == vmSymbols::object_initializer_name() &amp;&amp;
2895       signature == vmSymbols::void_method_signature() &amp;&amp;
2896       m-&gt;is_vanilla_constructor()) {
2897     _has_vanilla_constructor = true;
2898   }
2899 
2900   NOT_PRODUCT(m-&gt;verify());
2901   return m;
2902 }
2903 
2904 
2905 // The promoted_flags parameter is used to pass relevant access_flags
2906 // from the methods back up to the containing klass. These flag values
2907 // are added to klass&#39;s access_flags.
2908 // Side-effects: populates the _methods field in the parser
2909 void ClassFileParser::parse_methods(const ClassFileStream* const cfs,
2910                                     bool is_interface,
2911                                     AccessFlags* promoted_flags,
2912                                     bool* has_final_method,
2913                                     bool* declares_nonstatic_concrete_methods,
2914                                     TRAPS) {
2915   assert(cfs != NULL, &quot;invariant&quot;);
2916   assert(promoted_flags != NULL, &quot;invariant&quot;);
2917   assert(has_final_method != NULL, &quot;invariant&quot;);
2918   assert(declares_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
2919 
2920   assert(NULL == _methods, &quot;invariant&quot;);
2921 
2922   cfs-&gt;guarantee_more(2, CHECK);  // length
2923   const u2 length = cfs-&gt;get_u2_fast();
2924   if (length == 0) {
2925     _methods = Universe::the_empty_method_array();
2926   } else {
2927     _methods = MetadataFactory::new_array&lt;Method*&gt;(_loader_data,
2928                                                    length,
2929                                                    NULL,
2930                                                    CHECK);
2931 
2932     for (int index = 0; index &lt; length; index++) {
2933       Method* method = parse_method(cfs,
2934                                     is_interface,
2935                                     _cp,
2936                                     promoted_flags,
2937                                     CHECK);
2938 
2939       if (method-&gt;is_final()) {
2940         *has_final_method = true;
2941       }
2942       // declares_nonstatic_concrete_methods: declares concrete instance methods, any access flags
2943       // used for interface initialization, and default method inheritance analysis
2944       if (is_interface &amp;&amp; !(*declares_nonstatic_concrete_methods)
2945         &amp;&amp; !method-&gt;is_abstract() &amp;&amp; !method-&gt;is_static()) {
2946         *declares_nonstatic_concrete_methods = true;
2947       }
2948       _methods-&gt;at_put(index, method);
2949     }
2950 
2951     if (_need_verify &amp;&amp; length &gt; 1) {
2952       // Check duplicated methods
2953       ResourceMark rm(THREAD);
2954       NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(
2955         THREAD, NameSigHash*, HASH_ROW_SIZE);
2956       initialize_hashtable(names_and_sigs);
2957       bool dup = false;
2958       const Symbol* name = NULL;
2959       const Symbol* sig = NULL;
2960       {
2961         debug_only(NoSafepointVerifier nsv;)
2962         for (int i = 0; i &lt; length; i++) {
2963           const Method* const m = _methods-&gt;at(i);
2964           name = m-&gt;name();
2965           sig = m-&gt;signature();
2966           // If no duplicates, add name/signature in hashtable names_and_sigs.
2967           if (!put_after_lookup(name, sig, names_and_sigs)) {
2968             dup = true;
2969             break;
2970           }
2971         }
2972       }
2973       if (dup) {
2974         classfile_parse_error(&quot;Duplicate method name \&quot;%s\&quot; with signature \&quot;%s\&quot; in class file %s&quot;,
2975                                name-&gt;as_C_string(), sig-&gt;as_klass_external_name(), CHECK);
2976       }
2977     }
2978   }
2979 }
2980 
2981 static const intArray* sort_methods(Array&lt;Method*&gt;* methods) {
2982   const int length = methods-&gt;length();
2983   // If JVMTI original method ordering or sharing is enabled we have to
2984   // remember the original class file ordering.
2985   // We temporarily use the vtable_index field in the Method* to store the
2986   // class file index, so we can read in after calling qsort.
2987   // Put the method ordering in the shared archive.
2988   if (JvmtiExport::can_maintain_original_method_order() || Arguments::is_dumping_archive()) {
2989     for (int index = 0; index &lt; length; index++) {
2990       Method* const m = methods-&gt;at(index);
2991       assert(!m-&gt;valid_vtable_index(), &quot;vtable index should not be set&quot;);
2992       m-&gt;set_vtable_index(index);
2993     }
2994   }
2995   // Sort method array by ascending method name (for faster lookups &amp; vtable construction)
2996   // Note that the ordering is not alphabetical, see Symbol::fast_compare
2997   Method::sort_methods(methods);
2998 
2999   intArray* method_ordering = NULL;
3000   // If JVMTI original method ordering or sharing is enabled construct int
3001   // array remembering the original ordering
3002   if (JvmtiExport::can_maintain_original_method_order() || Arguments::is_dumping_archive()) {
3003     method_ordering = new intArray(length, length, -1);
3004     for (int index = 0; index &lt; length; index++) {
3005       Method* const m = methods-&gt;at(index);
3006       const int old_index = m-&gt;vtable_index();
3007       assert(old_index &gt;= 0 &amp;&amp; old_index &lt; length, &quot;invalid method index&quot;);
3008       method_ordering-&gt;at_put(index, old_index);
3009       m-&gt;set_vtable_index(Method::invalid_vtable_index);
3010     }
3011   }
3012   return method_ordering;
3013 }
3014 
3015 // Parse generic_signature attribute for methods and fields
3016 u2 ClassFileParser::parse_generic_signature_attribute(const ClassFileStream* const cfs,
3017                                                       TRAPS) {
3018   assert(cfs != NULL, &quot;invariant&quot;);
3019 
3020   cfs-&gt;guarantee_more(2, CHECK_0);  // generic_signature_index
3021   const u2 generic_signature_index = cfs-&gt;get_u2_fast();
3022   check_property(
3023     valid_symbol_at(generic_signature_index),
3024     &quot;Invalid Signature attribute at constant pool index %u in class file %s&quot;,
3025     generic_signature_index, CHECK_0);
3026   return generic_signature_index;
3027 }
3028 
3029 void ClassFileParser::parse_classfile_sourcefile_attribute(const ClassFileStream* const cfs,
3030                                                            TRAPS) {
3031 
3032   assert(cfs != NULL, &quot;invariant&quot;);
3033 
3034   cfs-&gt;guarantee_more(2, CHECK);  // sourcefile_index
3035   const u2 sourcefile_index = cfs-&gt;get_u2_fast();
3036   check_property(
3037     valid_symbol_at(sourcefile_index),
3038     &quot;Invalid SourceFile attribute at constant pool index %u in class file %s&quot;,
3039     sourcefile_index, CHECK);
3040   set_class_sourcefile_index(sourcefile_index);
3041 }
3042 
3043 void ClassFileParser::parse_classfile_source_debug_extension_attribute(const ClassFileStream* const cfs,
3044                                                                        int length,
3045                                                                        TRAPS) {
3046   assert(cfs != NULL, &quot;invariant&quot;);
3047 
3048   const u1* const sde_buffer = cfs-&gt;current();
3049   assert(sde_buffer != NULL, &quot;null sde buffer&quot;);
3050 
3051   // Don&#39;t bother storing it if there is no way to retrieve it
3052   if (JvmtiExport::can_get_source_debug_extension()) {
3053     assert((length+1) &gt; length, &quot;Overflow checking&quot;);
3054     u1* const sde = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, u1, length+1);
3055     for (int i = 0; i &lt; length; i++) {
3056       sde[i] = sde_buffer[i];
3057     }
3058     sde[length] = &#39;\0&#39;;
3059     set_class_sde_buffer((const char*)sde, length);
3060   }
3061   // Got utf8 string, set stream position forward
3062   cfs-&gt;skip_u1(length, CHECK);
3063 }
3064 
3065 
3066 // Inner classes can be static, private or protected (classic VM does this)
3067 #define RECOGNIZED_INNER_CLASS_MODIFIERS ( JVM_RECOGNIZED_CLASS_MODIFIERS | \
3068                                            JVM_ACC_PRIVATE |                \
3069                                            JVM_ACC_PROTECTED |              \
3070                                            JVM_ACC_STATIC                   \
3071                                          )
3072 
3073 // Return number of classes in the inner classes attribute table
3074 u2 ClassFileParser::parse_classfile_inner_classes_attribute(const ClassFileStream* const cfs,
3075                                                             const u1* const inner_classes_attribute_start,
3076                                                             bool parsed_enclosingmethod_attribute,
3077                                                             u2 enclosing_method_class_index,
3078                                                             u2 enclosing_method_method_index,
3079                                                             TRAPS) {
3080   const u1* const current_mark = cfs-&gt;current();
3081   u2 length = 0;
3082   if (inner_classes_attribute_start != NULL) {
3083     cfs-&gt;set_current(inner_classes_attribute_start);
3084     cfs-&gt;guarantee_more(2, CHECK_0);  // length
3085     length = cfs-&gt;get_u2_fast();
3086   }
3087 
3088   // 4-tuples of shorts of inner classes data and 2 shorts of enclosing
3089   // method data:
3090   //   [inner_class_info_index,
3091   //    outer_class_info_index,
3092   //    inner_name_index,
3093   //    inner_class_access_flags,
3094   //    ...
3095   //    enclosing_method_class_index,
3096   //    enclosing_method_method_index]
3097   const int size = length * 4 + (parsed_enclosingmethod_attribute ? 2 : 0);
3098   Array&lt;u2&gt;* const inner_classes = MetadataFactory::new_array&lt;u2&gt;(_loader_data, size, CHECK_0);
3099   _inner_classes = inner_classes;
3100 
3101   int index = 0;
3102   cfs-&gt;guarantee_more(8 * length, CHECK_0);  // 4-tuples of u2
3103   for (int n = 0; n &lt; length; n++) {
3104     // Inner class index
3105     const u2 inner_class_info_index = cfs-&gt;get_u2_fast();
3106     check_property(
3107       valid_klass_reference_at(inner_class_info_index),
3108       &quot;inner_class_info_index %u has bad constant type in class file %s&quot;,
3109       inner_class_info_index, CHECK_0);
3110     // Outer class index
3111     const u2 outer_class_info_index = cfs-&gt;get_u2_fast();
3112     check_property(
3113       outer_class_info_index == 0 ||
3114         valid_klass_reference_at(outer_class_info_index),
3115       &quot;outer_class_info_index %u has bad constant type in class file %s&quot;,
3116       outer_class_info_index, CHECK_0);
3117     // Inner class name
3118     const u2 inner_name_index = cfs-&gt;get_u2_fast();
3119     check_property(
3120       inner_name_index == 0 || valid_symbol_at(inner_name_index),
3121       &quot;inner_name_index %u has bad constant type in class file %s&quot;,
3122       inner_name_index, CHECK_0);
3123     if (_need_verify) {
3124       guarantee_property(inner_class_info_index != outer_class_info_index,
3125                          &quot;Class is both outer and inner class in class file %s&quot;, CHECK_0);
3126     }
3127     // Access flags
3128     jint flags;
3129     // JVM_ACC_MODULE is defined in JDK-9 and later.
3130     if (_major_version &gt;= JAVA_9_VERSION) {
3131       flags = cfs-&gt;get_u2_fast() &amp; (RECOGNIZED_INNER_CLASS_MODIFIERS | JVM_ACC_MODULE);
3132     } else {
3133       flags = cfs-&gt;get_u2_fast() &amp; RECOGNIZED_INNER_CLASS_MODIFIERS;
3134     }
3135     if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
3136       // Set abstract bit for old class files for backward compatibility
3137       flags |= JVM_ACC_ABSTRACT;
3138     }
3139     verify_legal_class_modifiers(flags, CHECK_0);
3140     AccessFlags inner_access_flags(flags);
3141 
3142     inner_classes-&gt;at_put(index++, inner_class_info_index);
3143     inner_classes-&gt;at_put(index++, outer_class_info_index);
3144     inner_classes-&gt;at_put(index++, inner_name_index);
3145     inner_classes-&gt;at_put(index++, inner_access_flags.as_short());
3146   }
3147 
3148   // 4347400: make sure there&#39;s no duplicate entry in the classes array
3149   if (_need_verify &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
3150     for(int i = 0; i &lt; length * 4; i += 4) {
3151       for(int j = i + 4; j &lt; length * 4; j += 4) {
3152         guarantee_property((inner_classes-&gt;at(i)   != inner_classes-&gt;at(j) ||
3153                             inner_classes-&gt;at(i+1) != inner_classes-&gt;at(j+1) ||
3154                             inner_classes-&gt;at(i+2) != inner_classes-&gt;at(j+2) ||
3155                             inner_classes-&gt;at(i+3) != inner_classes-&gt;at(j+3)),
3156                             &quot;Duplicate entry in InnerClasses in class file %s&quot;,
3157                             CHECK_0);
3158       }
3159     }
3160   }
3161 
3162   // Set EnclosingMethod class and method indexes.
3163   if (parsed_enclosingmethod_attribute) {
3164     inner_classes-&gt;at_put(index++, enclosing_method_class_index);
3165     inner_classes-&gt;at_put(index++, enclosing_method_method_index);
3166   }
3167   assert(index == size, &quot;wrong size&quot;);
3168 
3169   // Restore buffer&#39;s current position.
3170   cfs-&gt;set_current(current_mark);
3171 
3172   return length;
3173 }
3174 
3175 u2 ClassFileParser::parse_classfile_nest_members_attribute(const ClassFileStream* const cfs,
3176                                                            const u1* const nest_members_attribute_start,
3177                                                            TRAPS) {
3178   const u1* const current_mark = cfs-&gt;current();
3179   u2 length = 0;
3180   if (nest_members_attribute_start != NULL) {
3181     cfs-&gt;set_current(nest_members_attribute_start);
3182     cfs-&gt;guarantee_more(2, CHECK_0);  // length
3183     length = cfs-&gt;get_u2_fast();
3184   }
3185   const int size = length;
3186   Array&lt;u2&gt;* const nest_members = MetadataFactory::new_array&lt;u2&gt;(_loader_data, size, CHECK_0);
3187   _nest_members = nest_members;
3188 
3189   int index = 0;
3190   cfs-&gt;guarantee_more(2 * length, CHECK_0);
3191   for (int n = 0; n &lt; length; n++) {
3192     const u2 class_info_index = cfs-&gt;get_u2_fast();
3193     check_property(
3194       valid_klass_reference_at(class_info_index),
3195       &quot;Nest member class_info_index %u has bad constant type in class file %s&quot;,
3196       class_info_index, CHECK_0);
3197     nest_members-&gt;at_put(index++, class_info_index);
3198   }
3199   assert(index == size, &quot;wrong size&quot;);
3200 
3201   // Restore buffer&#39;s current position.
3202   cfs-&gt;set_current(current_mark);
3203 
3204   return length;
3205 }
3206 
3207 //  Record {
3208 //    u2 attribute_name_index;
3209 //    u4 attribute_length;
3210 //    u2 components_count;
3211 //    component_info components[components_count];
3212 //  }
3213 //  component_info {
3214 //    u2 name_index;
3215 //    u2 descriptor_index
3216 //    u2 attributes_count;
3217 //    attribute_info_attributes[attributes_count];
3218 //  }
3219 u2 ClassFileParser::parse_classfile_record_attribute(const ClassFileStream* const cfs,
3220                                                      const ConstantPool* cp,
3221                                                      const u1* const record_attribute_start,
3222                                                      TRAPS) {
3223   const u1* const current_mark = cfs-&gt;current();
3224   int components_count = 0;
3225   unsigned int calculate_attr_size = 0;
3226   if (record_attribute_start != NULL) {
3227     cfs-&gt;set_current(record_attribute_start);
3228     cfs-&gt;guarantee_more(2, CHECK_0);  // num of components
3229     components_count = (int)cfs-&gt;get_u2_fast();
3230     calculate_attr_size = 2;
3231   }
3232 
3233   Array&lt;RecordComponent*&gt;* const record_components =
3234     MetadataFactory::new_array&lt;RecordComponent*&gt;(_loader_data, components_count, NULL, CHECK_0);
3235   _record_components = record_components;
3236 
3237   for (int x = 0; x &lt; components_count; x++) {
3238     cfs-&gt;guarantee_more(6, CHECK_0); // name_index, descriptor_index, attributes_count
3239 
3240     const u2 name_index = cfs-&gt;get_u2_fast();
3241     check_property(valid_symbol_at(name_index),
3242       &quot;Invalid constant pool index %u for name in Record attribute in class file %s&quot;,
3243       name_index, CHECK_0);
3244     const Symbol* const name = cp-&gt;symbol_at(name_index);
3245     verify_legal_field_name(name, CHECK_0);
3246 
3247     const u2 descriptor_index = cfs-&gt;get_u2_fast();
3248     check_property(valid_symbol_at(descriptor_index),
3249       &quot;Invalid constant pool index %u for descriptor in Record attribute in class file %s&quot;,
3250       descriptor_index, CHECK_0);
3251     const Symbol* const descr = cp-&gt;symbol_at(descriptor_index);
3252     verify_legal_field_signature(name, descr, CHECK_0);
3253 
3254     const u2 attributes_count = cfs-&gt;get_u2_fast();
3255     calculate_attr_size += 6;
3256     u2 generic_sig_index = 0;
3257     const u1* runtime_visible_annotations = NULL;
3258     int runtime_visible_annotations_length = 0;
3259     const u1* runtime_invisible_annotations = NULL;
3260     int runtime_invisible_annotations_length = 0;
3261     bool runtime_invisible_annotations_exists = false;
3262     const u1* runtime_visible_type_annotations = NULL;
3263     int runtime_visible_type_annotations_length = 0;
3264     const u1* runtime_invisible_type_annotations = NULL;
3265     int runtime_invisible_type_annotations_length = 0;
3266     bool runtime_invisible_type_annotations_exists = false;
3267 
3268     // Expected attributes for record components are Signature, Runtime(In)VisibleAnnotations,
3269     // and Runtime(In)VisibleTypeAnnotations.  Other attributes are ignored.
3270     for (int y = 0; y &lt; attributes_count; y++) {
3271       cfs-&gt;guarantee_more(6, CHECK_0);  // attribute_name_index, attribute_length
3272       const u2 attribute_name_index = cfs-&gt;get_u2_fast();
3273       const u4 attribute_length = cfs-&gt;get_u4_fast();
3274       calculate_attr_size += 6;
3275       check_property(
3276         valid_symbol_at(attribute_name_index),
3277         &quot;Invalid Record attribute name index %u in class file %s&quot;,
3278         attribute_name_index, CHECK_0);
3279 
3280       const Symbol* const attribute_name = cp-&gt;symbol_at(attribute_name_index);
3281       if (attribute_name == vmSymbols::tag_signature()) {
3282         if (generic_sig_index != 0) {
3283           classfile_parse_error(
3284             &quot;Multiple Signature attributes for Record component in class file %s&quot;,
3285             CHECK_0);
3286         }
3287         if (attribute_length != 2) {
3288           classfile_parse_error(
3289             &quot;Invalid Signature attribute length %u in Record component in class file %s&quot;,
3290             attribute_length, CHECK_0);
3291         }
3292         generic_sig_index = parse_generic_signature_attribute(cfs, CHECK_0);
3293 
3294       } else if (attribute_name == vmSymbols::tag_runtime_visible_annotations()) {
3295         if (runtime_visible_annotations != NULL) {
3296           classfile_parse_error(
3297             &quot;Multiple RuntimeVisibleAnnotations attributes for Record component in class file %s&quot;, CHECK_0);
3298         }
3299         runtime_visible_annotations_length = attribute_length;
3300         runtime_visible_annotations = cfs-&gt;current();
3301 
3302         assert(runtime_visible_annotations != NULL, &quot;null record component visible annotation&quot;);
3303         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK_0);
3304         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
3305 
3306       } else if (attribute_name == vmSymbols::tag_runtime_invisible_annotations()) {
3307         if (runtime_invisible_annotations_exists) {
3308           classfile_parse_error(
3309             &quot;Multiple RuntimeInvisibleAnnotations attributes for Record component in class file %s&quot;, CHECK_0);
3310         }
3311         runtime_invisible_annotations_exists = true;
3312         if (PreserveAllAnnotations) {
3313           runtime_invisible_annotations_length = attribute_length;
3314           runtime_invisible_annotations = cfs-&gt;current();
3315           assert(runtime_invisible_annotations != NULL, &quot;null record component invisible annotation&quot;);
3316         }
3317         cfs-&gt;skip_u1(attribute_length, CHECK_0);
3318 
3319       } else if (attribute_name == vmSymbols::tag_runtime_visible_type_annotations()) {
3320         if (runtime_visible_type_annotations != NULL) {
3321           classfile_parse_error(
3322             &quot;Multiple RuntimeVisibleTypeAnnotations attributes for Record component in class file %s&quot;, CHECK_0);
3323         }
3324         runtime_visible_type_annotations_length = attribute_length;
3325         runtime_visible_type_annotations = cfs-&gt;current();
3326 
3327         assert(runtime_visible_type_annotations != NULL, &quot;null record component visible type annotation&quot;);
3328         cfs-&gt;guarantee_more(runtime_visible_type_annotations_length, CHECK_0);
3329         cfs-&gt;skip_u1_fast(runtime_visible_type_annotations_length);
3330 
3331       } else if (attribute_name == vmSymbols::tag_runtime_invisible_type_annotations()) {
3332         if (runtime_invisible_type_annotations_exists) {
3333           classfile_parse_error(
3334             &quot;Multiple RuntimeInvisibleTypeAnnotations attributes for Record component in class file %s&quot;, CHECK_0);
3335         }
3336         runtime_invisible_type_annotations_exists = true;
3337         if (PreserveAllAnnotations) {
3338           runtime_invisible_type_annotations_length = attribute_length;
3339           runtime_invisible_type_annotations = cfs-&gt;current();
3340           assert(runtime_invisible_type_annotations != NULL, &quot;null record component invisible type annotation&quot;);
3341         }
3342         cfs-&gt;skip_u1(attribute_length, CHECK_0);
3343 
3344       } else {
3345         // Skip unknown attributes
3346         cfs-&gt;skip_u1(attribute_length, CHECK_0);
3347       }
3348       calculate_attr_size += attribute_length;
3349     } // End of attributes For loop
3350 
3351     AnnotationArray* annotations = assemble_annotations(runtime_visible_annotations,
3352                                                         runtime_visible_annotations_length,
3353                                                         runtime_invisible_annotations,
3354                                                         runtime_invisible_annotations_length,
3355                                                         CHECK_0);
3356     AnnotationArray* type_annotations = assemble_annotations(runtime_visible_type_annotations,
3357                                                              runtime_visible_type_annotations_length,
3358                                                              runtime_invisible_type_annotations,
3359                                                              runtime_invisible_type_annotations_length,
3360                                                              CHECK_0);
3361 
3362     RecordComponent* record_component =
3363       RecordComponent::allocate(_loader_data, name_index, descriptor_index,
3364                                 attributes_count, generic_sig_index,
3365                                 annotations, type_annotations, CHECK_0);
3366     record_components-&gt;at_put(x, record_component);
3367   }  // End of component processing loop
3368 
3369   // Restore buffer&#39;s current position.
3370   cfs-&gt;set_current(current_mark);
3371   return calculate_attr_size;
3372 }
3373 
3374 void ClassFileParser::parse_classfile_synthetic_attribute(TRAPS) {
3375   set_class_synthetic_flag(true);
3376 }
3377 
3378 void ClassFileParser::parse_classfile_signature_attribute(const ClassFileStream* const cfs, TRAPS) {
3379   assert(cfs != NULL, &quot;invariant&quot;);
3380 
3381   const u2 signature_index = cfs-&gt;get_u2(CHECK);
3382   check_property(
3383     valid_symbol_at(signature_index),
3384     &quot;Invalid constant pool index %u in Signature attribute in class file %s&quot;,
3385     signature_index, CHECK);
3386   set_class_generic_signature_index(signature_index);
3387 }
3388 
3389 void ClassFileParser::parse_classfile_bootstrap_methods_attribute(const ClassFileStream* const cfs,
3390                                                                   ConstantPool* cp,
3391                                                                   u4 attribute_byte_length,
3392                                                                   TRAPS) {
3393   assert(cfs != NULL, &quot;invariant&quot;);
3394   assert(cp != NULL, &quot;invariant&quot;);
3395 
3396   const u1* const current_start = cfs-&gt;current();
3397 
3398   guarantee_property(attribute_byte_length &gt;= sizeof(u2),
3399                      &quot;Invalid BootstrapMethods attribute length %u in class file %s&quot;,
3400                      attribute_byte_length,
3401                      CHECK);
3402 
3403   cfs-&gt;guarantee_more(attribute_byte_length, CHECK);
3404 
3405   const int attribute_array_length = cfs-&gt;get_u2_fast();
3406 
3407   guarantee_property(_max_bootstrap_specifier_index &lt; attribute_array_length,
3408                      &quot;Short length on BootstrapMethods in class file %s&quot;,
3409                      CHECK);
3410 
3411 
3412   // The attribute contains a counted array of counted tuples of shorts,
3413   // represending bootstrap specifiers:
3414   //    length*{bootstrap_method_index, argument_count*{argument_index}}
3415   const int operand_count = (attribute_byte_length - sizeof(u2)) / sizeof(u2);
3416   // operand_count = number of shorts in attr, except for leading length
3417 
3418   // The attribute is copied into a short[] array.
3419   // The array begins with a series of short[2] pairs, one for each tuple.
3420   const int index_size = (attribute_array_length * 2);
3421 
3422   Array&lt;u2&gt;* const operands =
3423     MetadataFactory::new_array&lt;u2&gt;(_loader_data, index_size + operand_count, CHECK);
3424 
3425   // Eagerly assign operands so they will be deallocated with the constant
3426   // pool if there is an error.
3427   cp-&gt;set_operands(operands);
3428 
3429   int operand_fill_index = index_size;
3430   const int cp_size = cp-&gt;length();
3431 
3432   for (int n = 0; n &lt; attribute_array_length; n++) {
3433     // Store a 32-bit offset into the header of the operand array.
3434     ConstantPool::operand_offset_at_put(operands, n, operand_fill_index);
3435 
3436     // Read a bootstrap specifier.
3437     cfs-&gt;guarantee_more(sizeof(u2) * 2, CHECK);  // bsm, argc
3438     const u2 bootstrap_method_index = cfs-&gt;get_u2_fast();
3439     const u2 argument_count = cfs-&gt;get_u2_fast();
3440     check_property(
3441       valid_cp_range(bootstrap_method_index, cp_size) &amp;&amp;
3442       cp-&gt;tag_at(bootstrap_method_index).is_method_handle(),
3443       &quot;bootstrap_method_index %u has bad constant type in class file %s&quot;,
3444       bootstrap_method_index,
3445       CHECK);
3446 
3447     guarantee_property((operand_fill_index + 1 + argument_count) &lt; operands-&gt;length(),
3448       &quot;Invalid BootstrapMethods num_bootstrap_methods or num_bootstrap_arguments value in class file %s&quot;,
3449       CHECK);
3450 
3451     operands-&gt;at_put(operand_fill_index++, bootstrap_method_index);
3452     operands-&gt;at_put(operand_fill_index++, argument_count);
3453 
3454     cfs-&gt;guarantee_more(sizeof(u2) * argument_count, CHECK);  // argv[argc]
3455     for (int j = 0; j &lt; argument_count; j++) {
3456       const u2 argument_index = cfs-&gt;get_u2_fast();
3457       check_property(
3458         valid_cp_range(argument_index, cp_size) &amp;&amp;
3459         cp-&gt;tag_at(argument_index).is_loadable_constant(),
3460         &quot;argument_index %u has bad constant type in class file %s&quot;,
3461         argument_index,
3462         CHECK);
3463       operands-&gt;at_put(operand_fill_index++, argument_index);
3464     }
3465   }
3466   guarantee_property(current_start + attribute_byte_length == cfs-&gt;current(),
3467                      &quot;Bad length on BootstrapMethods in class file %s&quot;,
3468                      CHECK);
3469 }
3470 
3471 bool ClassFileParser::supports_records() {
3472   return _major_version == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
3473     _minor_version == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
3474     Arguments::enable_preview();
3475 }
3476 
3477 void ClassFileParser::parse_classfile_attributes(const ClassFileStream* const cfs,
3478                                                  ConstantPool* cp,
3479                  ClassFileParser::ClassAnnotationCollector* parsed_annotations,
3480                                                  TRAPS) {
3481   assert(cfs != NULL, &quot;invariant&quot;);
3482   assert(cp != NULL, &quot;invariant&quot;);
3483   assert(parsed_annotations != NULL, &quot;invariant&quot;);
3484 
3485   // Set inner classes attribute to default sentinel
3486   _inner_classes = Universe::the_empty_short_array();
3487   // Set nest members attribute to default sentinel
3488   _nest_members = Universe::the_empty_short_array();
3489   cfs-&gt;guarantee_more(2, CHECK);  // attributes_count
3490   u2 attributes_count = cfs-&gt;get_u2_fast();
3491   bool parsed_sourcefile_attribute = false;
3492   bool parsed_innerclasses_attribute = false;
3493   bool parsed_nest_members_attribute = false;
3494   bool parsed_nest_host_attribute = false;
3495   bool parsed_record_attribute = false;
3496   bool parsed_enclosingmethod_attribute = false;
3497   bool parsed_bootstrap_methods_attribute = false;
3498   const u1* runtime_visible_annotations = NULL;
3499   int runtime_visible_annotations_length = 0;
3500   const u1* runtime_invisible_annotations = NULL;
3501   int runtime_invisible_annotations_length = 0;
3502   const u1* runtime_visible_type_annotations = NULL;
3503   int runtime_visible_type_annotations_length = 0;
3504   const u1* runtime_invisible_type_annotations = NULL;
3505   int runtime_invisible_type_annotations_length = 0;
3506   bool runtime_invisible_type_annotations_exists = false;
3507   bool runtime_invisible_annotations_exists = false;
3508   bool parsed_source_debug_ext_annotations_exist = false;
3509   const u1* inner_classes_attribute_start = NULL;
3510   u4  inner_classes_attribute_length = 0;
3511   u2  enclosing_method_class_index = 0;
3512   u2  enclosing_method_method_index = 0;
3513   const u1* nest_members_attribute_start = NULL;
3514   u4  nest_members_attribute_length = 0;
3515   const u1* record_attribute_start = NULL;
3516   u4  record_attribute_length = 0;
3517 
3518   // Iterate over attributes
3519   while (attributes_count--) {
3520     cfs-&gt;guarantee_more(6, CHECK);  // attribute_name_index, attribute_length
3521     const u2 attribute_name_index = cfs-&gt;get_u2_fast();
3522     const u4 attribute_length = cfs-&gt;get_u4_fast();
3523     check_property(
3524       valid_symbol_at(attribute_name_index),
3525       &quot;Attribute name has bad constant pool index %u in class file %s&quot;,
3526       attribute_name_index, CHECK);
3527     const Symbol* const tag = cp-&gt;symbol_at(attribute_name_index);
3528     if (tag == vmSymbols::tag_source_file()) {
3529       // Check for SourceFile tag
3530       if (_need_verify) {
3531         guarantee_property(attribute_length == 2, &quot;Wrong SourceFile attribute length in class file %s&quot;, CHECK);
3532       }
3533       if (parsed_sourcefile_attribute) {
3534         classfile_parse_error(&quot;Multiple SourceFile attributes in class file %s&quot;, CHECK);
3535       } else {
3536         parsed_sourcefile_attribute = true;
3537       }
3538       parse_classfile_sourcefile_attribute(cfs, CHECK);
3539     } else if (tag == vmSymbols::tag_source_debug_extension()) {
3540       // Check for SourceDebugExtension tag
3541       if (parsed_source_debug_ext_annotations_exist) {
3542           classfile_parse_error(
3543             &quot;Multiple SourceDebugExtension attributes in class file %s&quot;, CHECK);
3544       }
3545       parsed_source_debug_ext_annotations_exist = true;
3546       parse_classfile_source_debug_extension_attribute(cfs, (int)attribute_length, CHECK);
3547     } else if (tag == vmSymbols::tag_inner_classes()) {
3548       // Check for InnerClasses tag
3549       if (parsed_innerclasses_attribute) {
3550         classfile_parse_error(&quot;Multiple InnerClasses attributes in class file %s&quot;, CHECK);
3551       } else {
3552         parsed_innerclasses_attribute = true;
3553       }
3554       inner_classes_attribute_start = cfs-&gt;current();
3555       inner_classes_attribute_length = attribute_length;
3556       cfs-&gt;skip_u1(inner_classes_attribute_length, CHECK);
3557     } else if (tag == vmSymbols::tag_synthetic()) {
3558       // Check for Synthetic tag
3559       // Shouldn&#39;t we check that the synthetic flags wasn&#39;t already set? - not required in spec
3560       if (attribute_length != 0) {
3561         classfile_parse_error(
3562           &quot;Invalid Synthetic classfile attribute length %u in class file %s&quot;,
3563           attribute_length, CHECK);
3564       }
3565       parse_classfile_synthetic_attribute(CHECK);
3566     } else if (tag == vmSymbols::tag_deprecated()) {
3567       // Check for Deprecatd tag - 4276120
3568       if (attribute_length != 0) {
3569         classfile_parse_error(
3570           &quot;Invalid Deprecated classfile attribute length %u in class file %s&quot;,
3571           attribute_length, CHECK);
3572       }
3573     } else if (_major_version &gt;= JAVA_1_5_VERSION) {
3574       if (tag == vmSymbols::tag_signature()) {
3575         if (_generic_signature_index != 0) {
3576           classfile_parse_error(
3577             &quot;Multiple Signature attributes in class file %s&quot;, CHECK);
3578         }
3579         if (attribute_length != 2) {
3580           classfile_parse_error(
3581             &quot;Wrong Signature attribute length %u in class file %s&quot;,
3582             attribute_length, CHECK);
3583         }
3584         parse_classfile_signature_attribute(cfs, CHECK);
3585       } else if (tag == vmSymbols::tag_runtime_visible_annotations()) {
3586         if (runtime_visible_annotations != NULL) {
3587           classfile_parse_error(
3588             &quot;Multiple RuntimeVisibleAnnotations attributes in class file %s&quot;, CHECK);
3589         }
3590         runtime_visible_annotations_length = attribute_length;
3591         runtime_visible_annotations = cfs-&gt;current();
3592         assert(runtime_visible_annotations != NULL, &quot;null visible annotations&quot;);
3593         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK);
3594         parse_annotations(cp,
3595                           runtime_visible_annotations,
3596                           runtime_visible_annotations_length,
3597                           parsed_annotations,
3598                           _loader_data,
3599                           CHECK);
3600         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
3601       } else if (tag == vmSymbols::tag_runtime_invisible_annotations()) {
3602         if (runtime_invisible_annotations_exists) {
3603           classfile_parse_error(
3604             &quot;Multiple RuntimeInvisibleAnnotations attributes in class file %s&quot;, CHECK);
3605         }
3606         runtime_invisible_annotations_exists = true;
3607         if (PreserveAllAnnotations) {
3608           runtime_invisible_annotations_length = attribute_length;
3609           runtime_invisible_annotations = cfs-&gt;current();
3610           assert(runtime_invisible_annotations != NULL, &quot;null invisible annotations&quot;);
3611         }
3612         cfs-&gt;skip_u1(attribute_length, CHECK);
3613       } else if (tag == vmSymbols::tag_enclosing_method()) {
3614         if (parsed_enclosingmethod_attribute) {
3615           classfile_parse_error(&quot;Multiple EnclosingMethod attributes in class file %s&quot;, CHECK);
3616         } else {
3617           parsed_enclosingmethod_attribute = true;
3618         }
3619         guarantee_property(attribute_length == 4,
3620           &quot;Wrong EnclosingMethod attribute length %u in class file %s&quot;,
3621           attribute_length, CHECK);
3622         cfs-&gt;guarantee_more(4, CHECK);  // class_index, method_index
3623         enclosing_method_class_index  = cfs-&gt;get_u2_fast();
3624         enclosing_method_method_index = cfs-&gt;get_u2_fast();
3625         if (enclosing_method_class_index == 0) {
3626           classfile_parse_error(&quot;Invalid class index in EnclosingMethod attribute in class file %s&quot;, CHECK);
3627         }
3628         // Validate the constant pool indices and types
3629         check_property(valid_klass_reference_at(enclosing_method_class_index),
3630           &quot;Invalid or out-of-bounds class index in EnclosingMethod attribute in class file %s&quot;, CHECK);
3631         if (enclosing_method_method_index != 0 &amp;&amp;
3632             (!cp-&gt;is_within_bounds(enclosing_method_method_index) ||
3633              !cp-&gt;tag_at(enclosing_method_method_index).is_name_and_type())) {
3634           classfile_parse_error(&quot;Invalid or out-of-bounds method index in EnclosingMethod attribute in class file %s&quot;, CHECK);
3635         }
3636       } else if (tag == vmSymbols::tag_bootstrap_methods() &amp;&amp;
3637                  _major_version &gt;= Verifier::INVOKEDYNAMIC_MAJOR_VERSION) {
3638         if (parsed_bootstrap_methods_attribute) {
3639           classfile_parse_error(&quot;Multiple BootstrapMethods attributes in class file %s&quot;, CHECK);
3640         }
3641         parsed_bootstrap_methods_attribute = true;
3642         parse_classfile_bootstrap_methods_attribute(cfs, cp, attribute_length, CHECK);
3643       } else if (tag == vmSymbols::tag_runtime_visible_type_annotations()) {
3644         if (runtime_visible_type_annotations != NULL) {
3645           classfile_parse_error(
3646             &quot;Multiple RuntimeVisibleTypeAnnotations attributes in class file %s&quot;, CHECK);
3647         }
3648         runtime_visible_type_annotations_length = attribute_length;
3649         runtime_visible_type_annotations = cfs-&gt;current();
3650         assert(runtime_visible_type_annotations != NULL, &quot;null visible type annotations&quot;);
3651         // No need for the VM to parse Type annotations
3652         cfs-&gt;skip_u1(runtime_visible_type_annotations_length, CHECK);
3653       } else if (tag == vmSymbols::tag_runtime_invisible_type_annotations()) {
3654         if (runtime_invisible_type_annotations_exists) {
3655           classfile_parse_error(
3656             &quot;Multiple RuntimeInvisibleTypeAnnotations attributes in class file %s&quot;, CHECK);
3657         } else {
3658           runtime_invisible_type_annotations_exists = true;
3659         }
3660         if (PreserveAllAnnotations) {
3661           runtime_invisible_type_annotations_length = attribute_length;
3662           runtime_invisible_type_annotations = cfs-&gt;current();
3663           assert(runtime_invisible_type_annotations != NULL, &quot;null invisible type annotations&quot;);
3664         }
3665         cfs-&gt;skip_u1(attribute_length, CHECK);
3666       } else if (_major_version &gt;= JAVA_11_VERSION) {
3667         if (tag == vmSymbols::tag_nest_members()) {
3668           // Check for NestMembers tag
3669           if (parsed_nest_members_attribute) {
3670             classfile_parse_error(&quot;Multiple NestMembers attributes in class file %s&quot;, CHECK);
3671           } else {
3672             parsed_nest_members_attribute = true;
3673           }
3674           if (parsed_nest_host_attribute) {
3675             classfile_parse_error(&quot;Conflicting NestHost and NestMembers attributes in class file %s&quot;, CHECK);
3676           }
3677           nest_members_attribute_start = cfs-&gt;current();
3678           nest_members_attribute_length = attribute_length;
3679           cfs-&gt;skip_u1(nest_members_attribute_length, CHECK);
3680         } else if (tag == vmSymbols::tag_nest_host()) {
3681           if (parsed_nest_host_attribute) {
3682             classfile_parse_error(&quot;Multiple NestHost attributes in class file %s&quot;, CHECK);
3683           } else {
3684             parsed_nest_host_attribute = true;
3685           }
3686           if (parsed_nest_members_attribute) {
3687             classfile_parse_error(&quot;Conflicting NestMembers and NestHost attributes in class file %s&quot;, CHECK);
3688           }
3689           if (_need_verify) {
3690             guarantee_property(attribute_length == 2, &quot;Wrong NestHost attribute length in class file %s&quot;, CHECK);
3691           }
3692           cfs-&gt;guarantee_more(2, CHECK);
3693           u2 class_info_index = cfs-&gt;get_u2_fast();
3694           check_property(
3695                          valid_klass_reference_at(class_info_index),
3696                          &quot;Nest-host class_info_index %u has bad constant type in class file %s&quot;,
3697                          class_info_index, CHECK);
3698           _nest_host = class_info_index;
3699         } else if (_major_version &gt;= JAVA_14_VERSION) {
3700           if (tag == vmSymbols::tag_record()) {
3701             // Skip over Record attribute if not supported or if super class is
3702             // not java.lang.Record.
3703             if (supports_records() &amp;&amp;
3704                 cp-&gt;klass_name_at(_super_class_index) == vmSymbols::java_lang_Record()) {
3705               if (parsed_record_attribute) {
3706                 classfile_parse_error(&quot;Multiple Record attributes in class file %s&quot;, CHECK);
3707               }
3708               // Check that class is final and not abstract.
3709               if (!_access_flags.is_final() || _access_flags.is_abstract()) {
3710                 classfile_parse_error(&quot;Record attribute in non-final or abstract class file %s&quot;, CHECK);
3711               }
3712               parsed_record_attribute = true;
3713               record_attribute_start = cfs-&gt;current();
3714               record_attribute_length = attribute_length;
3715             } else if (log_is_enabled(Info, class, record)) {
3716               // Log why the Record attribute was ignored.  Note that if the
3717               // class file version is JVM_CLASSFILE_MAJOR_VERSION.65535 and
3718               // --enable-preview wasn&#39;t specified then a java.lang.UnsupportedClassVersionError
3719               // exception would have been thrown.
3720               ResourceMark rm(THREAD);
3721               if (supports_records()) {
3722                 log_info(class, record)(
3723                   &quot;Ignoring Record attribute in class %s because super type is not java.lang.Record&quot;,
3724                   _class_name-&gt;as_C_string());
3725               } else {
3726                 log_info(class, record)(
3727                   &quot;Ignoring Record attribute in class %s because class file version is not %d.65535&quot;,
3728                    _class_name-&gt;as_C_string(), JVM_CLASSFILE_MAJOR_VERSION);
3729               }
3730             }
3731             cfs-&gt;skip_u1(attribute_length, CHECK);
3732           } else {
3733             // Unknown attribute
3734             cfs-&gt;skip_u1(attribute_length, CHECK);
3735           }
3736         } else {
3737           // Unknown attribute
3738           cfs-&gt;skip_u1(attribute_length, CHECK);
3739         }
3740       } else {
3741         // Unknown attribute
3742         cfs-&gt;skip_u1(attribute_length, CHECK);
3743       }
3744     } else {
3745       // Unknown attribute
3746       cfs-&gt;skip_u1(attribute_length, CHECK);
3747     }
3748   }
3749   _class_annotations = assemble_annotations(runtime_visible_annotations,
3750                                             runtime_visible_annotations_length,
3751                                             runtime_invisible_annotations,
3752                                             runtime_invisible_annotations_length,
3753                                             CHECK);
3754   _class_type_annotations = assemble_annotations(runtime_visible_type_annotations,
3755                                                  runtime_visible_type_annotations_length,
3756                                                  runtime_invisible_type_annotations,
3757                                                  runtime_invisible_type_annotations_length,
3758                                                  CHECK);
3759 
3760   if (parsed_innerclasses_attribute || parsed_enclosingmethod_attribute) {
3761     const u2 num_of_classes = parse_classfile_inner_classes_attribute(
3762                             cfs,
3763                             inner_classes_attribute_start,
3764                             parsed_innerclasses_attribute,
3765                             enclosing_method_class_index,
3766                             enclosing_method_method_index,
3767                             CHECK);
3768     if (parsed_innerclasses_attribute &amp;&amp; _need_verify &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
3769       guarantee_property(
3770         inner_classes_attribute_length == sizeof(num_of_classes) + 4 * sizeof(u2) * num_of_classes,
3771         &quot;Wrong InnerClasses attribute length in class file %s&quot;, CHECK);
3772     }
3773   }
3774 
3775   if (parsed_nest_members_attribute) {
3776     const u2 num_of_classes = parse_classfile_nest_members_attribute(
3777                             cfs,
3778                             nest_members_attribute_start,
3779                             CHECK);
3780     if (_need_verify) {
3781       guarantee_property(
3782         nest_members_attribute_length == sizeof(num_of_classes) + sizeof(u2) * num_of_classes,
3783         &quot;Wrong NestMembers attribute length in class file %s&quot;, CHECK);
3784     }
3785   }
3786 
3787   if (parsed_record_attribute) {
3788     const unsigned int calculated_attr_length = parse_classfile_record_attribute(
3789                             cfs,
3790                             cp,
3791                             record_attribute_start,
3792                             CHECK);
3793     if (_need_verify) {
3794       guarantee_property(record_attribute_length == calculated_attr_length,
3795                          &quot;Record attribute has wrong length in class file %s&quot;,
3796                          CHECK);
3797     }
3798   }
3799 
3800   if (_max_bootstrap_specifier_index &gt;= 0) {
3801     guarantee_property(parsed_bootstrap_methods_attribute,
3802                        &quot;Missing BootstrapMethods attribute in class file %s&quot;, CHECK);
3803   }
3804 }
3805 
3806 void ClassFileParser::apply_parsed_class_attributes(InstanceKlass* k) {
3807   assert(k != NULL, &quot;invariant&quot;);
3808 
3809   if (_synthetic_flag)
3810     k-&gt;set_is_synthetic();
3811   if (_sourcefile_index != 0) {
3812     k-&gt;set_source_file_name_index(_sourcefile_index);
3813   }
3814   if (_generic_signature_index != 0) {
3815     k-&gt;set_generic_signature_index(_generic_signature_index);
3816   }
3817   if (_sde_buffer != NULL) {
3818     k-&gt;set_source_debug_extension(_sde_buffer, _sde_length);
3819   }
3820 }
3821 
3822 // Create the Annotations object that will
3823 // hold the annotations array for the Klass.
3824 void ClassFileParser::create_combined_annotations(TRAPS) {
3825     if (_class_annotations == NULL &amp;&amp;
3826         _class_type_annotations == NULL &amp;&amp;
3827         _fields_annotations == NULL &amp;&amp;
3828         _fields_type_annotations == NULL) {
3829       // Don&#39;t create the Annotations object unnecessarily.
3830       return;
3831     }
3832 
3833     Annotations* const annotations = Annotations::allocate(_loader_data, CHECK);
3834     annotations-&gt;set_class_annotations(_class_annotations);
3835     annotations-&gt;set_class_type_annotations(_class_type_annotations);
3836     annotations-&gt;set_fields_annotations(_fields_annotations);
3837     annotations-&gt;set_fields_type_annotations(_fields_type_annotations);
3838 
3839     // This is the Annotations object that will be
3840     // assigned to InstanceKlass being constructed.
3841     _combined_annotations = annotations;
3842 
3843     // The annotations arrays below has been transfered the
3844     // _combined_annotations so these fields can now be cleared.
3845     _class_annotations       = NULL;
3846     _class_type_annotations  = NULL;
3847     _fields_annotations      = NULL;
3848     _fields_type_annotations = NULL;
3849 }
3850 
3851 // Transfer ownership of metadata allocated to the InstanceKlass.
3852 void ClassFileParser::apply_parsed_class_metadata(
3853                                             InstanceKlass* this_klass,
3854                                             int java_fields_count,
3855                                             TRAPS) {
3856   assert(this_klass != NULL, &quot;invariant&quot;);
3857 
3858   _cp-&gt;set_pool_holder(this_klass);
3859   this_klass-&gt;set_constants(_cp);
3860   this_klass-&gt;set_fields(_fields, java_fields_count);
3861   this_klass-&gt;set_methods(_methods);
3862   this_klass-&gt;set_inner_classes(_inner_classes);
3863   this_klass-&gt;set_nest_members(_nest_members);
3864   this_klass-&gt;set_nest_host_index(_nest_host);
3865   this_klass-&gt;set_local_interfaces(_local_interfaces);
3866   this_klass-&gt;set_annotations(_combined_annotations);
3867   this_klass-&gt;set_record_components(_record_components);
3868   // Delay the setting of _transitive_interfaces until after initialize_supers() in
3869   // fill_instance_klass(). It is because the _transitive_interfaces may be shared with
3870   // its _super. If an OOM occurs while loading the current klass, its _super field
3871   // may not have been set. When GC tries to free the klass, the _transitive_interfaces
3872   // may be deallocated mistakenly in InstanceKlass::deallocate_interfaces(). Subsequent
3873   // dereferences to the deallocated _transitive_interfaces will result in a crash.
3874 
3875   // Clear out these fields so they don&#39;t get deallocated by the destructor
3876   clear_class_metadata();
3877 }
3878 
3879 AnnotationArray* ClassFileParser::assemble_annotations(const u1* const runtime_visible_annotations,
3880                                                        int runtime_visible_annotations_length,
3881                                                        const u1* const runtime_invisible_annotations,
3882                                                        int runtime_invisible_annotations_length,
3883                                                        TRAPS) {
3884   AnnotationArray* annotations = NULL;
3885   if (runtime_visible_annotations != NULL ||
3886       runtime_invisible_annotations != NULL) {
3887     annotations = MetadataFactory::new_array&lt;u1&gt;(_loader_data,
3888                                           runtime_visible_annotations_length +
3889                                           runtime_invisible_annotations_length,
3890                                           CHECK_(annotations));
3891     if (runtime_visible_annotations != NULL) {
3892       for (int i = 0; i &lt; runtime_visible_annotations_length; i++) {
3893         annotations-&gt;at_put(i, runtime_visible_annotations[i]);
3894       }
3895     }
3896     if (runtime_invisible_annotations != NULL) {
3897       for (int i = 0; i &lt; runtime_invisible_annotations_length; i++) {
3898         int append = runtime_visible_annotations_length+i;
3899         annotations-&gt;at_put(append, runtime_invisible_annotations[i]);
3900       }
3901     }
3902   }
3903   return annotations;
3904 }
3905 
3906 const InstanceKlass* ClassFileParser::parse_super_class(ConstantPool* const cp,
3907                                                         const int super_class_index,
3908                                                         const bool need_verify,
3909                                                         TRAPS) {
3910   assert(cp != NULL, &quot;invariant&quot;);
3911   const InstanceKlass* super_klass = NULL;
3912 
3913   if (super_class_index == 0) {
3914     check_property(_class_name == vmSymbols::java_lang_Object(),
3915                    &quot;Invalid superclass index %u in class file %s&quot;,
3916                    super_class_index,
3917                    CHECK_NULL);
3918   } else {
3919     check_property(valid_klass_reference_at(super_class_index),
3920                    &quot;Invalid superclass index %u in class file %s&quot;,
3921                    super_class_index,
3922                    CHECK_NULL);
3923     // The class name should be legal because it is checked when parsing constant pool.
3924     // However, make sure it is not an array type.
3925     bool is_array = false;
3926     if (cp-&gt;tag_at(super_class_index).is_klass()) {
3927       super_klass = InstanceKlass::cast(cp-&gt;resolved_klass_at(super_class_index));
3928       if (need_verify)
3929         is_array = super_klass-&gt;is_array_klass();
3930     } else if (need_verify) {
3931       is_array = (cp-&gt;klass_name_at(super_class_index)-&gt;char_at(0) == JVM_SIGNATURE_ARRAY);
3932     }
3933     if (need_verify) {
3934       guarantee_property(!is_array,
3935                         &quot;Bad superclass name in class file %s&quot;, CHECK_NULL);
3936     }
3937   }
3938   return super_klass;
3939 }
3940 
3941 #ifndef PRODUCT
3942 static void print_field_layout(const Symbol* name,
3943                                Array&lt;u2&gt;* fields,
3944                                ConstantPool* cp,
3945                                int instance_size,
3946                                int instance_fields_start,
3947                                int instance_fields_end,
3948                                int static_fields_end) {
3949 
3950   assert(name != NULL, &quot;invariant&quot;);
3951 
3952   tty-&gt;print(&quot;%s: field layout\n&quot;, name-&gt;as_klass_external_name());
3953   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_fields_start, &quot;--- instance fields start ---&quot;);
3954   for (AllFieldStream fs(fields, cp); !fs.done(); fs.next()) {
3955     if (!fs.access_flags().is_static()) {
3956       tty-&gt;print(&quot;  @%3d \&quot;%s\&quot; %s\n&quot;,
3957         fs.offset(),
3958         fs.name()-&gt;as_klass_external_name(),
3959         fs.signature()-&gt;as_klass_external_name());
3960     }
3961   }
3962   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_fields_end, &quot;--- instance fields end ---&quot;);
3963   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_size * wordSize, &quot;--- instance ends ---&quot;);
3964   tty-&gt;print(&quot;  @%3d %s\n&quot;, InstanceMirrorKlass::offset_of_static_fields(), &quot;--- static fields start ---&quot;);
3965   for (AllFieldStream fs(fields, cp); !fs.done(); fs.next()) {
3966     if (fs.access_flags().is_static()) {
3967       tty-&gt;print(&quot;  @%3d \&quot;%s\&quot; %s\n&quot;,
3968         fs.offset(),
3969         fs.name()-&gt;as_klass_external_name(),
3970         fs.signature()-&gt;as_klass_external_name());
3971     }
3972   }
3973   tty-&gt;print(&quot;  @%3d %s\n&quot;, static_fields_end, &quot;--- static fields end ---&quot;);
3974   tty-&gt;print(&quot;\n&quot;);
3975 }
3976 #endif
3977 
3978 OopMapBlocksBuilder::OopMapBlocksBuilder(unsigned int max_blocks) {
3979   _max_nonstatic_oop_maps = max_blocks;
3980   _nonstatic_oop_map_count = 0;
3981   if (max_blocks == 0) {
3982     _nonstatic_oop_maps = NULL;
3983   } else {
3984     _nonstatic_oop_maps =
3985         NEW_RESOURCE_ARRAY(OopMapBlock, _max_nonstatic_oop_maps);
3986     memset(_nonstatic_oop_maps, 0, sizeof(OopMapBlock) * max_blocks);
3987   }
3988 }
3989 
3990 OopMapBlock* OopMapBlocksBuilder::last_oop_map() const {
3991   assert(_nonstatic_oop_map_count &gt; 0, &quot;Has no oop maps&quot;);
3992   return _nonstatic_oop_maps + (_nonstatic_oop_map_count - 1);
3993 }
3994 
3995 // addition of super oop maps
3996 void OopMapBlocksBuilder::initialize_inherited_blocks(OopMapBlock* blocks, unsigned int nof_blocks) {
3997   assert(nof_blocks &amp;&amp; _nonstatic_oop_map_count == 0 &amp;&amp;
3998          nof_blocks &lt;= _max_nonstatic_oop_maps, &quot;invariant&quot;);
3999 
4000   memcpy(_nonstatic_oop_maps, blocks, sizeof(OopMapBlock) * nof_blocks);
4001   _nonstatic_oop_map_count += nof_blocks;
4002 }
4003 
4004 // collection of oops
4005 void OopMapBlocksBuilder::add(int offset, int count) {
4006   if (_nonstatic_oop_map_count == 0) {
4007     _nonstatic_oop_map_count++;
4008   }
4009   OopMapBlock* nonstatic_oop_map = last_oop_map();
4010   if (nonstatic_oop_map-&gt;count() == 0) {  // Unused map, set it up
4011     nonstatic_oop_map-&gt;set_offset(offset);
4012     nonstatic_oop_map-&gt;set_count(count);
4013   } else if (nonstatic_oop_map-&gt;is_contiguous(offset)) { // contiguous, add
4014     nonstatic_oop_map-&gt;increment_count(count);
4015   } else { // Need a new one...
4016     _nonstatic_oop_map_count++;
4017     assert(_nonstatic_oop_map_count &lt;= _max_nonstatic_oop_maps, &quot;range check&quot;);
4018     nonstatic_oop_map = last_oop_map();
4019     nonstatic_oop_map-&gt;set_offset(offset);
4020     nonstatic_oop_map-&gt;set_count(count);
4021   }
4022 }
4023 
4024 // general purpose copy, e.g. into allocated instanceKlass
4025 void OopMapBlocksBuilder::copy(OopMapBlock* dst) {
4026   if (_nonstatic_oop_map_count != 0) {
4027     memcpy(dst, _nonstatic_oop_maps, sizeof(OopMapBlock) * _nonstatic_oop_map_count);
4028   }
4029 }
4030 
4031 // Sort and compact adjacent blocks
4032 void OopMapBlocksBuilder::compact() {
4033   if (_nonstatic_oop_map_count &lt;= 1) {
4034     return;
4035   }
4036   /*
4037    * Since field layout sneeks in oops before values, we will be able to condense
4038    * blocks. There is potential to compact between super, own refs and values
4039    * containing refs.
4040    *
4041    * Currently compaction is slightly limited due to values being 8 byte aligned.
4042    * This may well change: FixMe if it doesn&#39;t, the code below is fairly general purpose
4043    * and maybe it doesn&#39;t need to be.
4044    */
4045   qsort(_nonstatic_oop_maps, _nonstatic_oop_map_count, sizeof(OopMapBlock),
4046         (_sort_Fn)OopMapBlock::compare_offset);
4047   if (_nonstatic_oop_map_count &lt; 2) {
4048     return;
4049   }
4050 
4051   // Make a temp copy, and iterate through and copy back into the original
4052   ResourceMark rm;
4053   OopMapBlock* oop_maps_copy =
4054       NEW_RESOURCE_ARRAY(OopMapBlock, _nonstatic_oop_map_count);
4055   OopMapBlock* oop_maps_copy_end = oop_maps_copy + _nonstatic_oop_map_count;
4056   copy(oop_maps_copy);
4057   OopMapBlock* nonstatic_oop_map = _nonstatic_oop_maps;
4058   unsigned int new_count = 1;
4059   oop_maps_copy++;
4060   while(oop_maps_copy &lt; oop_maps_copy_end) {
4061     assert(nonstatic_oop_map-&gt;offset() &lt; oop_maps_copy-&gt;offset(), &quot;invariant&quot;);
4062     if (nonstatic_oop_map-&gt;is_contiguous(oop_maps_copy-&gt;offset())) {
4063       nonstatic_oop_map-&gt;increment_count(oop_maps_copy-&gt;count());
4064     } else {
4065       nonstatic_oop_map++;
4066       new_count++;
4067       nonstatic_oop_map-&gt;set_offset(oop_maps_copy-&gt;offset());
4068       nonstatic_oop_map-&gt;set_count(oop_maps_copy-&gt;count());
4069     }
4070     oop_maps_copy++;
4071   }
4072   assert(new_count &lt;= _nonstatic_oop_map_count, &quot;end up with more maps after compact() ?&quot;);
4073   _nonstatic_oop_map_count = new_count;
4074 }
4075 
4076 void OopMapBlocksBuilder::print_on(outputStream* st) const {
4077   st-&gt;print_cr(&quot;  OopMapBlocks: %3d  /%3d&quot;, _nonstatic_oop_map_count, _max_nonstatic_oop_maps);
4078   if (_nonstatic_oop_map_count &gt; 0) {
4079     OopMapBlock* map = _nonstatic_oop_maps;
4080     OopMapBlock* last_map = last_oop_map();
4081     assert(map &lt;= last_map, &quot;Last less than first&quot;);
4082     while (map &lt;= last_map) {
4083       st-&gt;print_cr(&quot;    Offset: %3d  -%3d Count: %3d&quot;, map-&gt;offset(),
4084                    map-&gt;offset() + map-&gt;offset_span() - heapOopSize, map-&gt;count());
4085       map++;
4086     }
4087   }
4088 }
4089 
4090 void OopMapBlocksBuilder::print_value_on(outputStream* st) const {
4091   print_on(st);
4092 }
4093 
4094 // Layout fields and fill in FieldLayoutInfo.  Could use more refactoring!
4095 void ClassFileParser::layout_fields(ConstantPool* cp,
4096                                     const FieldAllocationCount* fac,
4097                                     const ClassAnnotationCollector* parsed_annotations,
4098                                     FieldLayoutInfo* info,
4099                                     TRAPS) {
4100 
4101   assert(cp != NULL, &quot;invariant&quot;);
4102 
4103   // Field size and offset computation
4104   int nonstatic_field_size = _super_klass == NULL ? 0 :
4105                                _super_klass-&gt;nonstatic_field_size();
4106 
4107   // Count the contended fields by type.
4108   //
4109   // We ignore static fields, because @Contended is not supported for them.
4110   // The layout code below will also ignore the static fields.
4111   int nonstatic_contended_count = 0;
4112   FieldAllocationCount fac_contended;
4113   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4114     FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();
4115     if (fs.is_contended()) {
4116       fac_contended.count[atype]++;
4117       if (!fs.access_flags().is_static()) {
4118         nonstatic_contended_count++;
4119       }
4120     }
4121   }
4122 
4123 
4124   // Calculate the starting byte offsets
4125   int next_static_oop_offset    = InstanceMirrorKlass::offset_of_static_fields();
4126   int next_static_double_offset = next_static_oop_offset +
4127                                       ((fac-&gt;count[STATIC_OOP]) * heapOopSize);
4128   if (fac-&gt;count[STATIC_DOUBLE]) {
4129     next_static_double_offset = align_up(next_static_double_offset, BytesPerLong);
4130   }
4131 
4132   int next_static_word_offset   = next_static_double_offset +
4133                                     ((fac-&gt;count[STATIC_DOUBLE]) * BytesPerLong);
4134   int next_static_short_offset  = next_static_word_offset +
4135                                     ((fac-&gt;count[STATIC_WORD]) * BytesPerInt);
4136   int next_static_byte_offset   = next_static_short_offset +
4137                                   ((fac-&gt;count[STATIC_SHORT]) * BytesPerShort);
4138 
4139   int nonstatic_fields_start  = instanceOopDesc::base_offset_in_bytes() +
4140                                 nonstatic_field_size * heapOopSize;
4141 
4142   int next_nonstatic_field_offset = nonstatic_fields_start;
4143 
4144   const bool is_contended_class     = parsed_annotations-&gt;is_contended();
4145 
4146   // Class is contended, pad before all the fields
4147   if (is_contended_class) {
4148     next_nonstatic_field_offset += ContendedPaddingWidth;
4149   }
4150 
4151   // Compute the non-contended fields count.
4152   // The packing code below relies on these counts to determine if some field
4153   // can be squeezed into the alignment gap. Contended fields are obviously
4154   // exempt from that.
4155   unsigned int nonstatic_double_count = fac-&gt;count[NONSTATIC_DOUBLE] - fac_contended.count[NONSTATIC_DOUBLE];
4156   unsigned int nonstatic_word_count   = fac-&gt;count[NONSTATIC_WORD]   - fac_contended.count[NONSTATIC_WORD];
4157   unsigned int nonstatic_short_count  = fac-&gt;count[NONSTATIC_SHORT]  - fac_contended.count[NONSTATIC_SHORT];
4158   unsigned int nonstatic_byte_count   = fac-&gt;count[NONSTATIC_BYTE]   - fac_contended.count[NONSTATIC_BYTE];
4159   unsigned int nonstatic_oop_count    = fac-&gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];
4160 
4161   // Total non-static fields count, including every contended field
4162   unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +
4163                                         fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +
4164                                         fac-&gt;count[NONSTATIC_OOP];
4165 
4166   const bool super_has_nonstatic_fields =
4167           (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());
4168   const bool has_nonstatic_fields =
4169     super_has_nonstatic_fields || (nonstatic_fields_count != 0);
4170 
4171 
4172   // Prepare list of oops for oop map generation.
4173   //
4174   // &quot;offset&quot; and &quot;count&quot; lists are describing the set of contiguous oop
4175   // regions. offset[i] is the start of the i-th region, which then has
4176   // count[i] oops following. Before we know how many regions are required,
4177   // we pessimistically allocate the maps to fit all the oops into the
4178   // distinct regions.
4179 
4180   int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass-&gt;nonstatic_oop_map_count();
4181   int max_oop_map_count = super_oop_map_count + fac-&gt;count[NONSTATIC_OOP];
4182 
4183   OopMapBlocksBuilder* nonstatic_oop_maps = new OopMapBlocksBuilder(max_oop_map_count);
4184   if (super_oop_map_count &gt; 0) {
4185     nonstatic_oop_maps-&gt;initialize_inherited_blocks(_super_klass-&gt;start_of_nonstatic_oop_maps(),
4186                                                     _super_klass-&gt;nonstatic_oop_map_count());
4187   }
4188 
4189   int first_nonstatic_oop_offset = 0; // will be set for first oop field
4190 
4191   bool compact_fields  = true;
4192   bool allocate_oops_first = false;
4193 
4194   // The next classes have predefined hard-coded fields offsets
4195   // (see in JavaClasses::compute_hard_coded_offsets()).
4196   // Use default fields allocation order for them.
4197   if (_loader_data-&gt;class_loader() == NULL &amp;&amp;
4198       (_class_name == vmSymbols::java_lang_ref_Reference() ||
4199        _class_name == vmSymbols::java_lang_Boolean() ||
4200        _class_name == vmSymbols::java_lang_Character() ||
4201        _class_name == vmSymbols::java_lang_Float() ||
4202        _class_name == vmSymbols::java_lang_Double() ||
4203        _class_name == vmSymbols::java_lang_Byte() ||
4204        _class_name == vmSymbols::java_lang_Short() ||
4205        _class_name == vmSymbols::java_lang_Integer() ||
4206        _class_name == vmSymbols::java_lang_Long())) {
4207     allocate_oops_first = true;     // Allocate oops first
4208     compact_fields   = false; // Don&#39;t compact fields
4209   }
4210 
4211   int next_nonstatic_oop_offset = 0;
4212   int next_nonstatic_double_offset = 0;
4213 
4214   // Rearrange fields for a given allocation style
4215   if (allocate_oops_first) {
4216     // Fields order: oops, longs/doubles, ints, shorts/chars, bytes, padded fields
4217     next_nonstatic_oop_offset    = next_nonstatic_field_offset;
4218     next_nonstatic_double_offset = next_nonstatic_oop_offset +
4219                                     (nonstatic_oop_count * heapOopSize);
4220   } else {
4221     // Fields order: longs/doubles, ints, shorts/chars, bytes, oops, padded fields
4222     next_nonstatic_double_offset = next_nonstatic_field_offset;
4223   }
4224 
4225   int nonstatic_oop_space_count   = 0;
4226   int nonstatic_word_space_count  = 0;
4227   int nonstatic_short_space_count = 0;
4228   int nonstatic_byte_space_count  = 0;
4229   int nonstatic_oop_space_offset = 0;
4230   int nonstatic_word_space_offset = 0;
4231   int nonstatic_short_space_offset = 0;
4232   int nonstatic_byte_space_offset = 0;
4233 
4234   // Try to squeeze some of the fields into the gaps due to
4235   // long/double alignment.
4236   if (nonstatic_double_count &gt; 0) {
4237     int offset = next_nonstatic_double_offset;
4238     next_nonstatic_double_offset = align_up(offset, BytesPerLong);
4239     if (compact_fields &amp;&amp; offset != next_nonstatic_double_offset) {
4240       // Allocate available fields into the gap before double field.
4241       int length = next_nonstatic_double_offset - offset;
4242       assert(length == BytesPerInt, &quot;&quot;);
4243       nonstatic_word_space_offset = offset;
4244       if (nonstatic_word_count &gt; 0) {
4245         nonstatic_word_count      -= 1;
4246         nonstatic_word_space_count = 1; // Only one will fit
4247         length -= BytesPerInt;
4248         offset += BytesPerInt;
4249       }
4250       nonstatic_short_space_offset = offset;
4251       while (length &gt;= BytesPerShort &amp;&amp; nonstatic_short_count &gt; 0) {
4252         nonstatic_short_count       -= 1;
4253         nonstatic_short_space_count += 1;
4254         length -= BytesPerShort;
4255         offset += BytesPerShort;
4256       }
4257       nonstatic_byte_space_offset = offset;
4258       while (length &gt; 0 &amp;&amp; nonstatic_byte_count &gt; 0) {
4259         nonstatic_byte_count       -= 1;
4260         nonstatic_byte_space_count += 1;
4261         length -= 1;
4262       }
4263       // Allocate oop field in the gap if there are no other fields for that.
4264       nonstatic_oop_space_offset = offset;
4265       if (length &gt;= heapOopSize &amp;&amp; nonstatic_oop_count &gt; 0 &amp;&amp;
4266           !allocate_oops_first) { // when oop fields not first
4267         nonstatic_oop_count      -= 1;
4268         nonstatic_oop_space_count = 1; // Only one will fit
4269         length -= heapOopSize;
4270         offset += heapOopSize;
4271       }
4272     }
4273   }
4274 
4275   int next_nonstatic_word_offset = next_nonstatic_double_offset +
4276                                      (nonstatic_double_count * BytesPerLong);
4277   int next_nonstatic_short_offset = next_nonstatic_word_offset +
4278                                       (nonstatic_word_count * BytesPerInt);
4279   int next_nonstatic_byte_offset = next_nonstatic_short_offset +
4280                                      (nonstatic_short_count * BytesPerShort);
4281   int next_nonstatic_padded_offset = next_nonstatic_byte_offset +
4282                                        nonstatic_byte_count;
4283 
4284   // let oops jump before padding with this allocation style
4285   if (!allocate_oops_first) {
4286     next_nonstatic_oop_offset = next_nonstatic_padded_offset;
4287     if( nonstatic_oop_count &gt; 0 ) {
4288       next_nonstatic_oop_offset = align_up(next_nonstatic_oop_offset, heapOopSize);
4289     }
4290     next_nonstatic_padded_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);
4291   }
4292 
4293   // Iterate over fields again and compute correct offsets.
4294   // The field allocation type was temporarily stored in the offset slot.
4295   // oop fields are located before non-oop fields (static and non-static).
4296   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4297 
4298     // skip already laid out fields
4299     if (fs.is_offset_set()) continue;
4300 
4301     // contended instance fields are handled below
4302     if (fs.is_contended() &amp;&amp; !fs.access_flags().is_static()) continue;
4303 
4304     int real_offset = 0;
4305     const FieldAllocationType atype = (const FieldAllocationType) fs.allocation_type();
4306 
4307     // pack the rest of the fields
4308     switch (atype) {
4309       case STATIC_OOP:
4310         real_offset = next_static_oop_offset;
4311         next_static_oop_offset += heapOopSize;
4312         break;
4313       case STATIC_BYTE:
4314         real_offset = next_static_byte_offset;
4315         next_static_byte_offset += 1;
4316         break;
4317       case STATIC_SHORT:
4318         real_offset = next_static_short_offset;
4319         next_static_short_offset += BytesPerShort;
4320         break;
4321       case STATIC_WORD:
4322         real_offset = next_static_word_offset;
4323         next_static_word_offset += BytesPerInt;
4324         break;
4325       case STATIC_DOUBLE:
4326         real_offset = next_static_double_offset;
4327         next_static_double_offset += BytesPerLong;
4328         break;
4329       case NONSTATIC_OOP:
4330         if( nonstatic_oop_space_count &gt; 0 ) {
4331           real_offset = nonstatic_oop_space_offset;
4332           nonstatic_oop_space_offset += heapOopSize;
4333           nonstatic_oop_space_count  -= 1;
4334         } else {
4335           real_offset = next_nonstatic_oop_offset;
4336           next_nonstatic_oop_offset += heapOopSize;
4337         }
4338         nonstatic_oop_maps-&gt;add(real_offset, 1);
4339         break;
4340       case NONSTATIC_BYTE:
4341         if( nonstatic_byte_space_count &gt; 0 ) {
4342           real_offset = nonstatic_byte_space_offset;
4343           nonstatic_byte_space_offset += 1;
4344           nonstatic_byte_space_count  -= 1;
4345         } else {
4346           real_offset = next_nonstatic_byte_offset;
4347           next_nonstatic_byte_offset += 1;
4348         }
4349         break;
4350       case NONSTATIC_SHORT:
4351         if( nonstatic_short_space_count &gt; 0 ) {
4352           real_offset = nonstatic_short_space_offset;
4353           nonstatic_short_space_offset += BytesPerShort;
4354           nonstatic_short_space_count  -= 1;
4355         } else {
4356           real_offset = next_nonstatic_short_offset;
4357           next_nonstatic_short_offset += BytesPerShort;
4358         }
4359         break;
4360       case NONSTATIC_WORD:
4361         if( nonstatic_word_space_count &gt; 0 ) {
4362           real_offset = nonstatic_word_space_offset;
4363           nonstatic_word_space_offset += BytesPerInt;
4364           nonstatic_word_space_count  -= 1;
4365         } else {
4366           real_offset = next_nonstatic_word_offset;
4367           next_nonstatic_word_offset += BytesPerInt;
4368         }
4369         break;
4370       case NONSTATIC_DOUBLE:
4371         real_offset = next_nonstatic_double_offset;
4372         next_nonstatic_double_offset += BytesPerLong;
4373         break;
4374       default:
4375         ShouldNotReachHere();
4376     }
4377     fs.set_offset(real_offset);
4378   }
4379 
4380 
4381   // Handle the contended cases.
4382   //
4383   // Each contended field should not intersect the cache line with another contended field.
4384   // In the absence of alignment information, we end up with pessimistically separating
4385   // the fields with full-width padding.
4386   //
4387   // Additionally, this should not break alignment for the fields, so we round the alignment up
4388   // for each field.
4389   if (nonstatic_contended_count &gt; 0) {
4390 
4391     // if there is at least one contended field, we need to have pre-padding for them
4392     next_nonstatic_padded_offset += ContendedPaddingWidth;
4393 
4394     // collect all contended groups
4395     ResourceBitMap bm(cp-&gt;size());
4396     for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4397       // skip already laid out fields
4398       if (fs.is_offset_set()) continue;
4399 
4400       if (fs.is_contended()) {
4401         bm.set_bit(fs.contended_group());
4402       }
4403     }
4404 
4405     int current_group = -1;
4406     while ((current_group = (int)bm.get_next_one_offset(current_group + 1)) != (int)bm.size()) {
4407 
4408       for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4409 
4410         // skip already laid out fields
4411         if (fs.is_offset_set()) continue;
4412 
4413         // skip non-contended fields and fields from different group
4414         if (!fs.is_contended() || (fs.contended_group() != current_group)) continue;
4415 
4416         // handle statics below
4417         if (fs.access_flags().is_static()) continue;
4418 
4419         int real_offset = 0;
4420         FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();
4421 
4422         switch (atype) {
4423           case NONSTATIC_BYTE:
4424             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, 1);
4425             real_offset = next_nonstatic_padded_offset;
4426             next_nonstatic_padded_offset += 1;
4427             break;
4428 
4429           case NONSTATIC_SHORT:
4430             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerShort);
4431             real_offset = next_nonstatic_padded_offset;
4432             next_nonstatic_padded_offset += BytesPerShort;
4433             break;
4434 
4435           case NONSTATIC_WORD:
4436             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerInt);
4437             real_offset = next_nonstatic_padded_offset;
4438             next_nonstatic_padded_offset += BytesPerInt;
4439             break;
4440 
4441           case NONSTATIC_DOUBLE:
4442             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
4443             real_offset = next_nonstatic_padded_offset;
4444             next_nonstatic_padded_offset += BytesPerLong;
4445             break;
4446 
4447           case NONSTATIC_OOP:
4448             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, heapOopSize);
4449             real_offset = next_nonstatic_padded_offset;
4450             next_nonstatic_padded_offset += heapOopSize;
4451             nonstatic_oop_maps-&gt;add(real_offset, 1);
4452             break;
4453 
4454           default:
4455             ShouldNotReachHere();
4456         }
4457 
4458         if (fs.contended_group() == 0) {
4459           // Contended group defines the equivalence class over the fields:
4460           // the fields within the same contended group are not inter-padded.
4461           // The only exception is default group, which does not incur the
4462           // equivalence, and so requires intra-padding.
4463           next_nonstatic_padded_offset += ContendedPaddingWidth;
4464         }
4465 
4466         fs.set_offset(real_offset);
4467       } // for
4468 
4469       // Start laying out the next group.
4470       // Note that this will effectively pad the last group in the back;
4471       // this is expected to alleviate memory contention effects for
4472       // subclass fields and/or adjacent object.
4473       // If this was the default group, the padding is already in place.
4474       if (current_group != 0) {
4475         next_nonstatic_padded_offset += ContendedPaddingWidth;
4476       }
4477     }
4478 
4479     // handle static fields
4480   }
4481 
4482   // Entire class is contended, pad in the back.
4483   // This helps to alleviate memory contention effects for subclass fields
4484   // and/or adjacent object.
4485   if (is_contended_class) {
4486     next_nonstatic_padded_offset += ContendedPaddingWidth;
4487   }
4488 
4489   int notaligned_nonstatic_fields_end = next_nonstatic_padded_offset;
4490 
4491   int nonstatic_fields_end      = align_up(notaligned_nonstatic_fields_end, heapOopSize);
4492   int instance_end              = align_up(notaligned_nonstatic_fields_end, wordSize);
4493   int static_fields_end         = align_up(next_static_byte_offset, wordSize);
4494 
4495   int static_field_size         = (static_fields_end -
4496                                    InstanceMirrorKlass::offset_of_static_fields()) / wordSize;
4497   nonstatic_field_size          = nonstatic_field_size +
4498                                   (nonstatic_fields_end - nonstatic_fields_start) / heapOopSize;
4499 
4500   int instance_size             = align_object_size(instance_end / wordSize);
4501 
4502   assert(instance_size == align_object_size(align_up(
4503          (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize),
4504           wordSize) / wordSize), &quot;consistent layout helper value&quot;);
4505 
4506   // Invariant: nonstatic_field end/start should only change if there are
4507   // nonstatic fields in the class, or if the class is contended. We compare
4508   // against the non-aligned value, so that end alignment will not fail the
4509   // assert without actually having the fields.
4510   assert((notaligned_nonstatic_fields_end == nonstatic_fields_start) ||
4511          is_contended_class ||
4512          (nonstatic_fields_count &gt; 0), &quot;double-check nonstatic start/end&quot;);
4513 
4514   // Number of non-static oop map blocks allocated at end of klass.
4515   nonstatic_oop_maps-&gt;compact();
4516 
4517 #ifndef PRODUCT
4518   if (PrintFieldLayout) {
4519     print_field_layout(_class_name,
4520           _fields,
4521           cp,
4522           instance_size,
4523           nonstatic_fields_start,
4524           nonstatic_fields_end,
4525           static_fields_end);
4526   }
4527 
4528 #endif
4529   // Pass back information needed for InstanceKlass creation
4530   info-&gt;oop_map_blocks = nonstatic_oop_maps;
4531   info-&gt;_instance_size = instance_size;
4532   info-&gt;_static_field_size = static_field_size;
4533   info-&gt;_nonstatic_field_size = nonstatic_field_size;
4534   info-&gt;_has_nonstatic_fields = has_nonstatic_fields;
4535 }
4536 
4537 void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
4538   assert(ik != NULL, &quot;invariant&quot;);
4539 
4540   const Klass* const super = ik-&gt;super();
4541 
4542   // Check if this klass has an empty finalize method (i.e. one with return bytecode only),
4543   // in which case we don&#39;t have to register objects as finalizable
4544   if (!_has_empty_finalizer) {
4545     if (_has_finalizer ||
4546         (super != NULL &amp;&amp; super-&gt;has_finalizer())) {
4547       ik-&gt;set_has_finalizer();
4548     }
4549   }
4550 
4551 #ifdef ASSERT
4552   bool f = false;
4553   const Method* const m = ik-&gt;lookup_method(vmSymbols::finalize_method_name(),
4554                                            vmSymbols::void_method_signature());
4555   if (m != NULL &amp;&amp; !m-&gt;is_empty_method()) {
4556       f = true;
4557   }
4558 
4559   // Spec doesn&#39;t prevent agent from redefinition of empty finalizer.
4560   // Despite the fact that it&#39;s generally bad idea and redefined finalizer
4561   // will not work as expected we shouldn&#39;t abort vm in this case
4562   if (!ik-&gt;has_redefined_this_or_super()) {
4563     assert(ik-&gt;has_finalizer() == f, &quot;inconsistent has_finalizer&quot;);
4564   }
4565 #endif
4566 
4567   // Check if this klass supports the java.lang.Cloneable interface
4568   if (SystemDictionary::Cloneable_klass_loaded()) {
4569     if (ik-&gt;is_subtype_of(SystemDictionary::Cloneable_klass())) {
4570       ik-&gt;set_is_cloneable();
4571     }
4572   }
4573 
4574   // Check if this klass has a vanilla default constructor
4575   if (super == NULL) {
4576     // java.lang.Object has empty default constructor
4577     ik-&gt;set_has_vanilla_constructor();
4578   } else {
4579     if (super-&gt;has_vanilla_constructor() &amp;&amp;
4580         _has_vanilla_constructor) {
4581       ik-&gt;set_has_vanilla_constructor();
4582     }
4583 #ifdef ASSERT
4584     bool v = false;
4585     if (super-&gt;has_vanilla_constructor()) {
4586       const Method* const constructor =
4587         ik-&gt;find_method(vmSymbols::object_initializer_name(),
4588                        vmSymbols::void_method_signature());
4589       if (constructor != NULL &amp;&amp; constructor-&gt;is_vanilla_constructor()) {
4590         v = true;
4591       }
4592     }
4593     assert(v == ik-&gt;has_vanilla_constructor(), &quot;inconsistent has_vanilla_constructor&quot;);
4594 #endif
4595   }
4596 
4597   // If it cannot be fast-path allocated, set a bit in the layout helper.
4598   // See documentation of InstanceKlass::can_be_fastpath_allocated().
4599   assert(ik-&gt;size_helper() &gt; 0, &quot;layout_helper is initialized&quot;);
4600   if ((!RegisterFinalizersAtInit &amp;&amp; ik-&gt;has_finalizer())
4601       || ik-&gt;is_abstract() || ik-&gt;is_interface()
4602       || (ik-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp; ik-&gt;class_loader() == NULL)
4603       || ik-&gt;size_helper() &gt;= FastAllocateSizeLimit) {
4604     // Forbid fast-path allocation.
4605     const jint lh = Klass::instance_layout_helper(ik-&gt;size_helper(), true);
4606     ik-&gt;set_layout_helper(lh);
4607   }
4608 }
4609 
4610 // utility methods for appending an array with check for duplicates
4611 
4612 static void append_interfaces(GrowableArray&lt;InstanceKlass*&gt;* result,
4613                               const Array&lt;InstanceKlass*&gt;* const ifs) {
4614   // iterate over new interfaces
4615   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
4616     InstanceKlass* const e = ifs-&gt;at(i);
4617     assert(e-&gt;is_klass() &amp;&amp; e-&gt;is_interface(), &quot;just checking&quot;);
4618     // add new interface
4619     result-&gt;append_if_missing(e);
4620   }
4621 }
4622 
4623 static Array&lt;InstanceKlass*&gt;* compute_transitive_interfaces(const InstanceKlass* super,
4624                                                             Array&lt;InstanceKlass*&gt;* local_ifs,
4625                                                             ClassLoaderData* loader_data,
4626                                                             TRAPS) {
4627   assert(local_ifs != NULL, &quot;invariant&quot;);
4628   assert(loader_data != NULL, &quot;invariant&quot;);
4629 
4630   // Compute maximum size for transitive interfaces
4631   int max_transitive_size = 0;
4632   int super_size = 0;
4633   // Add superclass transitive interfaces size
4634   if (super != NULL) {
4635     super_size = super-&gt;transitive_interfaces()-&gt;length();
4636     max_transitive_size += super_size;
4637   }
4638   // Add local interfaces&#39; super interfaces
4639   const int local_size = local_ifs-&gt;length();
4640   for (int i = 0; i &lt; local_size; i++) {
4641     InstanceKlass* const l = local_ifs-&gt;at(i);
4642     max_transitive_size += l-&gt;transitive_interfaces()-&gt;length();
4643   }
4644   // Finally add local interfaces
4645   max_transitive_size += local_size;
4646   // Construct array
4647   if (max_transitive_size == 0) {
4648     // no interfaces, use canonicalized array
4649     return Universe::the_empty_instance_klass_array();
4650   } else if (max_transitive_size == super_size) {
4651     // no new local interfaces added, share superklass&#39; transitive interface array
4652     return super-&gt;transitive_interfaces();
4653   } else if (max_transitive_size == local_size) {
4654     // only local interfaces added, share local interface array
4655     return local_ifs;
4656   } else {
4657     ResourceMark rm;
4658     GrowableArray&lt;InstanceKlass*&gt;* const result = new GrowableArray&lt;InstanceKlass*&gt;(max_transitive_size);
4659 
4660     // Copy down from superclass
4661     if (super != NULL) {
4662       append_interfaces(result, super-&gt;transitive_interfaces());
4663     }
4664 
4665     // Copy down from local interfaces&#39; superinterfaces
4666     for (int i = 0; i &lt; local_size; i++) {
4667       InstanceKlass* const l = local_ifs-&gt;at(i);
4668       append_interfaces(result, l-&gt;transitive_interfaces());
4669     }
4670     // Finally add local interfaces
4671     append_interfaces(result, local_ifs);
4672 
4673     // length will be less than the max_transitive_size if duplicates were removed
4674     const int length = result-&gt;length();
4675     assert(length &lt;= max_transitive_size, &quot;just checking&quot;);
4676     Array&lt;InstanceKlass*&gt;* const new_result =
4677       MetadataFactory::new_array&lt;InstanceKlass*&gt;(loader_data, length, CHECK_NULL);
4678     for (int i = 0; i &lt; length; i++) {
4679       InstanceKlass* const e = result-&gt;at(i);
4680       assert(e != NULL, &quot;just checking&quot;);
4681       new_result-&gt;at_put(i, e);
4682     }
4683     return new_result;
4684   }
4685 }
4686 
4687 static void check_super_class_access(const InstanceKlass* this_klass, TRAPS) {
4688   assert(this_klass != NULL, &quot;invariant&quot;);
4689   const Klass* const super = this_klass-&gt;super();
4690 
4691   if (super != NULL) {
4692 
4693     // If the loader is not the boot loader then throw an exception if its
4694     // superclass is in package jdk.internal.reflect and its loader is not a
4695     // special reflection class loader
4696     if (!this_klass-&gt;class_loader_data()-&gt;is_the_null_class_loader_data()) {
4697       assert(super-&gt;is_instance_klass(), &quot;super is not instance klass&quot;);
4698       PackageEntry* super_package = super-&gt;package();
4699       if (super_package != NULL &amp;&amp;
4700           super_package-&gt;name()-&gt;fast_compare(vmSymbols::jdk_internal_reflect()) == 0 &amp;&amp;
4701           !java_lang_ClassLoader::is_reflection_class_loader(this_klass-&gt;class_loader())) {
4702         ResourceMark rm(THREAD);
4703         Exceptions::fthrow(
4704           THREAD_AND_LOCATION,
4705           vmSymbols::java_lang_IllegalAccessError(),
4706           &quot;class %s loaded by %s cannot access jdk/internal/reflect superclass %s&quot;,
4707           this_klass-&gt;external_name(),
4708           this_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
4709           super-&gt;external_name());
4710         return;
4711       }
4712     }
4713 
4714     Reflection::VerifyClassAccessResults vca_result =
4715       Reflection::verify_class_access(this_klass, InstanceKlass::cast(super), false);
4716     if (vca_result != Reflection::ACCESS_OK) {
4717       ResourceMark rm(THREAD);
4718       char* msg = Reflection::verify_class_access_msg(this_klass,
4719                                                       InstanceKlass::cast(super),
4720                                                       vca_result);
4721       if (msg == NULL) {
4722         bool same_module = (this_klass-&gt;module() == super-&gt;module());
4723         Exceptions::fthrow(
4724           THREAD_AND_LOCATION,
4725           vmSymbols::java_lang_IllegalAccessError(),
4726           &quot;class %s cannot access its %ssuperclass %s (%s%s%s)&quot;,
4727           this_klass-&gt;external_name(),
4728           super-&gt;is_abstract() ? &quot;abstract &quot; : &quot;&quot;,
4729           super-&gt;external_name(),
4730           (same_module) ? this_klass-&gt;joint_in_module_of_loader(super) : this_klass-&gt;class_in_module_of_loader(),
4731           (same_module) ? &quot;&quot; : &quot;; &quot;,
4732           (same_module) ? &quot;&quot; : super-&gt;class_in_module_of_loader());
4733       } else {
4734         // Add additional message content.
4735         Exceptions::fthrow(
4736           THREAD_AND_LOCATION,
4737           vmSymbols::java_lang_IllegalAccessError(),
4738           &quot;superclass access check failed: %s&quot;,
4739           msg);
4740       }
4741     }
4742   }
4743 }
4744 
4745 
4746 static void check_super_interface_access(const InstanceKlass* this_klass, TRAPS) {
4747   assert(this_klass != NULL, &quot;invariant&quot;);
4748   const Array&lt;InstanceKlass*&gt;* const local_interfaces = this_klass-&gt;local_interfaces();
4749   const int lng = local_interfaces-&gt;length();
4750   for (int i = lng - 1; i &gt;= 0; i--) {
4751     InstanceKlass* const k = local_interfaces-&gt;at(i);
4752     assert (k != NULL &amp;&amp; k-&gt;is_interface(), &quot;invalid interface&quot;);
4753     Reflection::VerifyClassAccessResults vca_result =
4754       Reflection::verify_class_access(this_klass, k, false);
4755     if (vca_result != Reflection::ACCESS_OK) {
4756       ResourceMark rm(THREAD);
4757       char* msg = Reflection::verify_class_access_msg(this_klass,
4758                                                       k,
4759                                                       vca_result);
4760       if (msg == NULL) {
4761         bool same_module = (this_klass-&gt;module() == k-&gt;module());
4762         Exceptions::fthrow(
4763           THREAD_AND_LOCATION,
4764           vmSymbols::java_lang_IllegalAccessError(),
4765           &quot;class %s cannot access its superinterface %s (%s%s%s)&quot;,
4766           this_klass-&gt;external_name(),
4767           k-&gt;external_name(),
4768           (same_module) ? this_klass-&gt;joint_in_module_of_loader(k) : this_klass-&gt;class_in_module_of_loader(),
4769           (same_module) ? &quot;&quot; : &quot;; &quot;,
4770           (same_module) ? &quot;&quot; : k-&gt;class_in_module_of_loader());
4771       } else {
4772         // Add additional message content.
4773         Exceptions::fthrow(
4774           THREAD_AND_LOCATION,
4775           vmSymbols::java_lang_IllegalAccessError(),
4776           &quot;superinterface check failed: %s&quot;,
4777           msg);
4778       }
4779     }
4780   }
4781 }
4782 
4783 
4784 static void check_final_method_override(const InstanceKlass* this_klass, TRAPS) {
4785   assert(this_klass != NULL, &quot;invariant&quot;);
4786   const Array&lt;Method*&gt;* const methods = this_klass-&gt;methods();
4787   const int num_methods = methods-&gt;length();
4788 
4789   // go thru each method and check if it overrides a final method
4790   for (int index = 0; index &lt; num_methods; index++) {
4791     const Method* const m = methods-&gt;at(index);
4792 
4793     // skip private, static, and &lt;init&gt; methods
4794     if ((!m-&gt;is_private() &amp;&amp; !m-&gt;is_static()) &amp;&amp;
4795         (m-&gt;name() != vmSymbols::object_initializer_name())) {
4796 
4797       const Symbol* const name = m-&gt;name();
4798       const Symbol* const signature = m-&gt;signature();
4799       const Klass* k = this_klass-&gt;super();
4800       const Method* super_m = NULL;
4801       while (k != NULL) {
4802         // skip supers that don&#39;t have final methods.
4803         if (k-&gt;has_final_method()) {
4804           // lookup a matching method in the super class hierarchy
4805           super_m = InstanceKlass::cast(k)-&gt;lookup_method(name, signature);
4806           if (super_m == NULL) {
4807             break; // didn&#39;t find any match; get out
4808           }
4809 
4810           if (super_m-&gt;is_final() &amp;&amp; !super_m-&gt;is_static() &amp;&amp;
4811               !super_m-&gt;access_flags().is_private()) {
4812             // matching method in super is final, and not static or private
4813             bool can_access = Reflection::verify_member_access(this_klass,
4814                                                                super_m-&gt;method_holder(),
4815                                                                super_m-&gt;method_holder(),
4816                                                                super_m-&gt;access_flags(),
4817                                                               false, false, CHECK);
4818             if (can_access) {
4819               // this class can access super final method and therefore override
4820               ResourceMark rm(THREAD);
4821               Exceptions::fthrow(THREAD_AND_LOCATION,
4822                                  vmSymbols::java_lang_VerifyError(),
4823                                  &quot;class %s overrides final method %s.%s%s&quot;,
4824                                  this_klass-&gt;external_name(),
4825                                  super_m-&gt;method_holder()-&gt;external_name(),
4826                                  name-&gt;as_C_string(),
4827                                  signature-&gt;as_C_string()
4828                                  );
4829               return;
4830             }
4831           }
4832 
4833           // continue to look from super_m&#39;s holder&#39;s super.
4834           k = super_m-&gt;method_holder()-&gt;super();
4835           continue;
4836         }
4837 
4838         k = k-&gt;super();
4839       }
4840     }
4841   }
4842 }
4843 
4844 
4845 // assumes that this_klass is an interface
4846 static void check_illegal_static_method(const InstanceKlass* this_klass, TRAPS) {
4847   assert(this_klass != NULL, &quot;invariant&quot;);
4848   assert(this_klass-&gt;is_interface(), &quot;not an interface&quot;);
4849   const Array&lt;Method*&gt;* methods = this_klass-&gt;methods();
4850   const int num_methods = methods-&gt;length();
4851 
4852   for (int index = 0; index &lt; num_methods; index++) {
4853     const Method* const m = methods-&gt;at(index);
4854     // if m is static and not the init method, throw a verify error
4855     if ((m-&gt;is_static()) &amp;&amp; (m-&gt;name() != vmSymbols::class_initializer_name())) {
4856       ResourceMark rm(THREAD);
4857       Exceptions::fthrow(
4858         THREAD_AND_LOCATION,
4859         vmSymbols::java_lang_VerifyError(),
4860         &quot;Illegal static method %s in interface %s&quot;,
4861         m-&gt;name()-&gt;as_C_string(),
4862         this_klass-&gt;external_name()
4863       );
4864       return;
4865     }
4866   }
4867 }
4868 
4869 // utility methods for format checking
4870 
4871 void ClassFileParser::verify_legal_class_modifiers(jint flags, TRAPS) const {
4872   const bool is_module = (flags &amp; JVM_ACC_MODULE) != 0;
4873   assert(_major_version &gt;= JAVA_9_VERSION || !is_module, &quot;JVM_ACC_MODULE should not be set&quot;);
4874   if (is_module) {
4875     ResourceMark rm(THREAD);
4876     Exceptions::fthrow(
4877       THREAD_AND_LOCATION,
4878       vmSymbols::java_lang_NoClassDefFoundError(),
4879       &quot;%s is not a class because access_flag ACC_MODULE is set&quot;,
4880       _class_name-&gt;as_C_string());
4881     return;
4882   }
4883 
4884   if (!_need_verify) { return; }
4885 
4886   const bool is_interface  = (flags &amp; JVM_ACC_INTERFACE)  != 0;
4887   const bool is_abstract   = (flags &amp; JVM_ACC_ABSTRACT)   != 0;
4888   const bool is_final      = (flags &amp; JVM_ACC_FINAL)      != 0;
4889   const bool is_super      = (flags &amp; JVM_ACC_SUPER)      != 0;
4890   const bool is_enum       = (flags &amp; JVM_ACC_ENUM)       != 0;
4891   const bool is_annotation = (flags &amp; JVM_ACC_ANNOTATION) != 0;
4892   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
4893   const bool major_gte_14  = _major_version &gt;= JAVA_14_VERSION;
4894 
4895   if ((is_abstract &amp;&amp; is_final) ||
4896       (is_interface &amp;&amp; !is_abstract) ||
4897       (is_interface &amp;&amp; major_gte_1_5 &amp;&amp; (is_super || is_enum)) ||
4898       (!is_interface &amp;&amp; major_gte_1_5 &amp;&amp; is_annotation)) {
4899     ResourceMark rm(THREAD);
4900     Exceptions::fthrow(
4901       THREAD_AND_LOCATION,
4902       vmSymbols::java_lang_ClassFormatError(),
4903       &quot;Illegal class modifiers in class %s: 0x%X&quot;,
4904       _class_name-&gt;as_C_string(), flags
4905     );
4906     return;
4907   }
4908 }
4909 
4910 static bool has_illegal_visibility(jint flags) {
4911   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
4912   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
4913   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
4914 
4915   return ((is_public &amp;&amp; is_protected) ||
4916           (is_public &amp;&amp; is_private) ||
4917           (is_protected &amp;&amp; is_private));
4918 }
4919 
4920 // A legal major_version.minor_version must be one of the following:
4921 //
4922 //  Major_version &gt;= 45 and major_version &lt; 56, any minor_version.
4923 //  Major_version &gt;= 56 and major_version &lt;= JVM_CLASSFILE_MAJOR_VERSION and minor_version = 0.
4924 //  Major_version = JVM_CLASSFILE_MAJOR_VERSION and minor_version = 65535 and --enable-preview is present.
4925 //
4926 static void verify_class_version(u2 major, u2 minor, Symbol* class_name, TRAPS){
4927   ResourceMark rm(THREAD);
4928   const u2 max_version = JVM_CLASSFILE_MAJOR_VERSION;
4929   if (major &lt; JAVA_MIN_SUPPORTED_VERSION) {
4930     Exceptions::fthrow(
4931       THREAD_AND_LOCATION,
4932       vmSymbols::java_lang_UnsupportedClassVersionError(),
4933       &quot;%s (class file version %u.%u) was compiled with an invalid major version&quot;,
4934       class_name-&gt;as_C_string(), major, minor);
4935     return;
4936   }
4937 
4938   if (major &gt; max_version) {
4939     Exceptions::fthrow(
4940       THREAD_AND_LOCATION,
4941       vmSymbols::java_lang_UnsupportedClassVersionError(),
4942       &quot;%s has been compiled by a more recent version of the Java Runtime (class file version %u.%u), &quot;
4943       &quot;this version of the Java Runtime only recognizes class file versions up to %u.0&quot;,
4944       class_name-&gt;as_C_string(), major, minor, JVM_CLASSFILE_MAJOR_VERSION);
4945     return;
4946   }
4947 
4948   if (major &lt; JAVA_12_VERSION || minor == 0) {
4949     return;
4950   }
4951 
4952   if (minor == JAVA_PREVIEW_MINOR_VERSION) {
4953     if (major != max_version) {
4954       Exceptions::fthrow(
4955         THREAD_AND_LOCATION,
4956         vmSymbols::java_lang_UnsupportedClassVersionError(),
4957         &quot;%s (class file version %u.%u) was compiled with preview features that are unsupported. &quot;
4958         &quot;This version of the Java Runtime only recognizes preview features for class file version %u.%u&quot;,
4959         class_name-&gt;as_C_string(), major, minor, JVM_CLASSFILE_MAJOR_VERSION, JAVA_PREVIEW_MINOR_VERSION);
4960       return;
4961     }
4962 
4963     if (!Arguments::enable_preview()) {
4964       Exceptions::fthrow(
4965         THREAD_AND_LOCATION,
4966         vmSymbols::java_lang_UnsupportedClassVersionError(),
4967         &quot;Preview features are not enabled for %s (class file version %u.%u). Try running with &#39;--enable-preview&#39;&quot;,
4968         class_name-&gt;as_C_string(), major, minor);
4969       return;
4970     }
4971 
4972   } else { // minor != JAVA_PREVIEW_MINOR_VERSION
4973     Exceptions::fthrow(
4974         THREAD_AND_LOCATION,
4975         vmSymbols::java_lang_UnsupportedClassVersionError(),
4976         &quot;%s (class file version %u.%u) was compiled with an invalid non-zero minor version&quot;,
4977         class_name-&gt;as_C_string(), major, minor);
4978   }
4979 }
4980 
4981 void ClassFileParser::verify_legal_field_modifiers(jint flags,
4982                                                    bool is_interface,
4983                                                    TRAPS) const {
4984   if (!_need_verify) { return; }
4985 
4986   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
4987   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
4988   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
4989   const bool is_static    = (flags &amp; JVM_ACC_STATIC)    != 0;
4990   const bool is_final     = (flags &amp; JVM_ACC_FINAL)     != 0;
4991   const bool is_volatile  = (flags &amp; JVM_ACC_VOLATILE)  != 0;
4992   const bool is_transient = (flags &amp; JVM_ACC_TRANSIENT) != 0;
4993   const bool is_enum      = (flags &amp; JVM_ACC_ENUM)      != 0;
4994   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
4995 
4996   bool is_illegal = false;
4997 
4998   if (is_interface) {
4999     if (!is_public || !is_static || !is_final || is_private ||
5000         is_protected || is_volatile || is_transient ||
5001         (major_gte_1_5 &amp;&amp; is_enum)) {
5002       is_illegal = true;
5003     }
5004   } else { // not interface
5005     if (has_illegal_visibility(flags) || (is_final &amp;&amp; is_volatile)) {
5006       is_illegal = true;
5007     }
5008   }
5009 
5010   if (is_illegal) {
5011     ResourceMark rm(THREAD);
5012     Exceptions::fthrow(
5013       THREAD_AND_LOCATION,
5014       vmSymbols::java_lang_ClassFormatError(),
5015       &quot;Illegal field modifiers in class %s: 0x%X&quot;,
5016       _class_name-&gt;as_C_string(), flags);
5017     return;
5018   }
5019 }
5020 
5021 void ClassFileParser::verify_legal_method_modifiers(jint flags,
5022                                                     bool is_interface,
5023                                                     const Symbol* name,
5024                                                     TRAPS) const {
5025   if (!_need_verify) { return; }
5026 
5027   const bool is_public       = (flags &amp; JVM_ACC_PUBLIC)       != 0;
5028   const bool is_private      = (flags &amp; JVM_ACC_PRIVATE)      != 0;
5029   const bool is_static       = (flags &amp; JVM_ACC_STATIC)       != 0;
5030   const bool is_final        = (flags &amp; JVM_ACC_FINAL)        != 0;
5031   const bool is_native       = (flags &amp; JVM_ACC_NATIVE)       != 0;
5032   const bool is_abstract     = (flags &amp; JVM_ACC_ABSTRACT)     != 0;
5033   const bool is_bridge       = (flags &amp; JVM_ACC_BRIDGE)       != 0;
5034   const bool is_strict       = (flags &amp; JVM_ACC_STRICT)       != 0;
5035   const bool is_synchronized = (flags &amp; JVM_ACC_SYNCHRONIZED) != 0;
5036   const bool is_protected    = (flags &amp; JVM_ACC_PROTECTED)    != 0;
5037   const bool major_gte_1_5   = _major_version &gt;= JAVA_1_5_VERSION;
5038   const bool major_gte_8     = _major_version &gt;= JAVA_8_VERSION;
5039   const bool is_initializer  = (name == vmSymbols::object_initializer_name());
5040 
5041   bool is_illegal = false;
5042 
5043   if (is_interface) {
5044     if (major_gte_8) {
5045       // Class file version is JAVA_8_VERSION or later Methods of
5046       // interfaces may set any of the flags except ACC_PROTECTED,
5047       // ACC_FINAL, ACC_NATIVE, and ACC_SYNCHRONIZED; they must
5048       // have exactly one of the ACC_PUBLIC or ACC_PRIVATE flags set.
5049       if ((is_public == is_private) || /* Only one of private and public should be true - XNOR */
5050           (is_native || is_protected || is_final || is_synchronized) ||
5051           // If a specific method of a class or interface has its
5052           // ACC_ABSTRACT flag set, it must not have any of its
5053           // ACC_FINAL, ACC_NATIVE, ACC_PRIVATE, ACC_STATIC,
5054           // ACC_STRICT, or ACC_SYNCHRONIZED flags set.  No need to
5055           // check for ACC_FINAL, ACC_NATIVE or ACC_SYNCHRONIZED as
5056           // those flags are illegal irrespective of ACC_ABSTRACT being set or not.
5057           (is_abstract &amp;&amp; (is_private || is_static || is_strict))) {
5058         is_illegal = true;
5059       }
5060     } else if (major_gte_1_5) {
5061       // Class file version in the interval [JAVA_1_5_VERSION, JAVA_8_VERSION)
5062       if (!is_public || is_private || is_protected || is_static || is_final ||
5063           is_synchronized || is_native || !is_abstract || is_strict) {
5064         is_illegal = true;
5065       }
5066     } else {
5067       // Class file version is pre-JAVA_1_5_VERSION
5068       if (!is_public || is_static || is_final || is_native || !is_abstract) {
5069         is_illegal = true;
5070       }
5071     }
5072   } else { // not interface
5073     if (has_illegal_visibility(flags)) {
5074       is_illegal = true;
5075     } else {
5076       if (is_initializer) {
5077         if (is_static || is_final || is_synchronized || is_native ||
5078             is_abstract || (major_gte_1_5 &amp;&amp; is_bridge)) {
5079           is_illegal = true;
5080         }
5081       } else { // not initializer
5082         if (is_abstract) {
5083           if ((is_final || is_native || is_private || is_static ||
5084               (major_gte_1_5 &amp;&amp; (is_synchronized || is_strict)))) {
5085             is_illegal = true;
5086           }
5087         }
5088       }
5089     }
5090   }
5091 
5092   if (is_illegal) {
5093     ResourceMark rm(THREAD);
5094     Exceptions::fthrow(
5095       THREAD_AND_LOCATION,
5096       vmSymbols::java_lang_ClassFormatError(),
5097       &quot;Method %s in class %s has illegal modifiers: 0x%X&quot;,
5098       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), flags);
5099     return;
5100   }
5101 }
5102 
5103 void ClassFileParser::verify_legal_utf8(const unsigned char* buffer,
5104                                         int length,
5105                                         TRAPS) const {
5106   assert(_need_verify, &quot;only called when _need_verify is true&quot;);
5107   if (!UTF8::is_legal_utf8(buffer, length, _major_version &lt;= 47)) {
5108     classfile_parse_error(&quot;Illegal UTF8 string in constant pool in class file %s&quot;, CHECK);
5109   }
5110 }
5111 
5112 // Unqualified names may not contain the characters &#39;.&#39;, &#39;;&#39;, &#39;[&#39;, or &#39;/&#39;.
5113 // In class names, &#39;/&#39; separates unqualified names.  This is verified in this function also.
5114 // Method names also may not contain the characters &#39;&lt;&#39; or &#39;&gt;&#39;, unless &lt;init&gt;
5115 // or &lt;clinit&gt;.  Note that method names may not be &lt;init&gt; or &lt;clinit&gt; in this
5116 // method.  Because these names have been checked as special cases before
5117 // calling this method in verify_legal_method_name.
5118 //
5119 // This method is also called from the modular system APIs in modules.cpp
5120 // to verify the validity of module and package names.
5121 bool ClassFileParser::verify_unqualified_name(const char* name,
5122                                               unsigned int length,
5123                                               int type) {
5124   if (length == 0) return false;  // Must have at least one char.
5125   for (const char* p = name; p != name + length; p++) {
5126     switch(*p) {
5127       case JVM_SIGNATURE_DOT:
5128       case JVM_SIGNATURE_ENDCLASS:
5129       case JVM_SIGNATURE_ARRAY:
5130         // do not permit &#39;.&#39;, &#39;;&#39;, or &#39;[&#39;
5131         return false;
5132       case JVM_SIGNATURE_SLASH:
5133         // check for &#39;//&#39; or leading or trailing &#39;/&#39; which are not legal
5134         // unqualified name must not be empty
5135         if (type == ClassFileParser::LegalClass) {
5136           if (p == name || p+1 &gt;= name+length ||
5137               *(p+1) == JVM_SIGNATURE_SLASH) {
5138             return false;
5139           }
5140         } else {
5141           return false;   // do not permit &#39;/&#39; unless it&#39;s class name
5142         }
5143         break;
5144       case JVM_SIGNATURE_SPECIAL:
5145       case JVM_SIGNATURE_ENDSPECIAL:
5146         // do not permit &#39;&lt;&#39; or &#39;&gt;&#39; in method names
5147         if (type == ClassFileParser::LegalMethod) {
5148           return false;
5149         }
5150     }
5151   }
5152   return true;
5153 }
5154 
5155 // Take pointer to a UTF8 byte string (not NUL-terminated).
5156 // Skip over the longest part of the string that could
5157 // be taken as a fieldname. Allow &#39;/&#39; if slash_ok is true.
5158 // Return a pointer to just past the fieldname.
5159 // Return NULL if no fieldname at all was found, or in the case of slash_ok
5160 // being true, we saw consecutive slashes (meaning we were looking for a
5161 // qualified path but found something that was badly-formed).
5162 static const char* skip_over_field_name(const char* const name,
5163                                         bool slash_ok,
5164                                         unsigned int length) {
5165   const char* p;
5166   jboolean last_is_slash = false;
5167   jboolean not_first_ch = false;
5168 
5169   for (p = name; p != name + length; not_first_ch = true) {
5170     const char* old_p = p;
5171     jchar ch = *p;
5172     if (ch &lt; 128) {
5173       p++;
5174       // quick check for ascii
5175       if ((ch &gt;= &#39;a&#39; &amp;&amp; ch &lt;= &#39;z&#39;) ||
5176         (ch &gt;= &#39;A&#39; &amp;&amp; ch &lt;= &#39;Z&#39;) ||
5177         (ch == &#39;_&#39; || ch == &#39;$&#39;) ||
5178         (not_first_ch &amp;&amp; ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)) {
5179         last_is_slash = false;
5180         continue;
5181       }
5182       if (slash_ok &amp;&amp; ch == JVM_SIGNATURE_SLASH) {
5183         if (last_is_slash) {
5184           return NULL;  // Don&#39;t permit consecutive slashes
5185         }
5186         last_is_slash = true;
5187         continue;
5188       }
5189     }
5190     else {
5191       jint unicode_ch;
5192       char* tmp_p = UTF8::next_character(p, &amp;unicode_ch);
5193       p = tmp_p;
5194       last_is_slash = false;
5195       // Check if ch is Java identifier start or is Java identifier part
5196       // 4672820: call java.lang.Character methods directly without generating separate tables.
5197       EXCEPTION_MARK;
5198       // return value
5199       JavaValue result(T_BOOLEAN);
5200       // Set up the arguments to isJavaIdentifierStart or isJavaIdentifierPart
5201       JavaCallArguments args;
5202       args.push_int(unicode_ch);
5203 
5204       if (not_first_ch) {
5205         // public static boolean isJavaIdentifierPart(char ch);
5206         JavaCalls::call_static(&amp;result,
5207           SystemDictionary::Character_klass(),
5208           vmSymbols::isJavaIdentifierPart_name(),
5209           vmSymbols::int_bool_signature(),
5210           &amp;args,
5211           THREAD);
5212       } else {
5213         // public static boolean isJavaIdentifierStart(char ch);
5214         JavaCalls::call_static(&amp;result,
5215           SystemDictionary::Character_klass(),
5216           vmSymbols::isJavaIdentifierStart_name(),
5217           vmSymbols::int_bool_signature(),
5218           &amp;args,
5219           THREAD);
5220       }
5221       if (HAS_PENDING_EXCEPTION) {
5222         CLEAR_PENDING_EXCEPTION;
5223         return NULL;
5224       }
5225       if(result.get_jboolean()) {
5226         continue;
5227       }
5228     }
5229     return (not_first_ch) ? old_p : NULL;
5230   }
5231   return (not_first_ch) ? p : NULL;
5232 }
5233 
5234 // Take pointer to a UTF8 byte string (not NUL-terminated).
5235 // Skip over the longest part of the string that could
5236 // be taken as a field signature. Allow &quot;void&quot; if void_ok.
5237 // Return a pointer to just past the signature.
5238 // Return NULL if no legal signature is found.
5239 const char* ClassFileParser::skip_over_field_signature(const char* signature,
5240                                                        bool void_ok,
5241                                                        unsigned int length,
5242                                                        TRAPS) const {
5243   unsigned int array_dim = 0;
5244   while (length &gt; 0) {
5245     switch (signature[0]) {
5246     case JVM_SIGNATURE_VOID: if (!void_ok) { return NULL; }
5247     case JVM_SIGNATURE_BOOLEAN:
5248     case JVM_SIGNATURE_BYTE:
5249     case JVM_SIGNATURE_CHAR:
5250     case JVM_SIGNATURE_SHORT:
5251     case JVM_SIGNATURE_INT:
5252     case JVM_SIGNATURE_FLOAT:
5253     case JVM_SIGNATURE_LONG:
5254     case JVM_SIGNATURE_DOUBLE:
5255       return signature + 1;
5256     case JVM_SIGNATURE_CLASS: {
5257       if (_major_version &lt; JAVA_1_5_VERSION) {
5258         // Skip over the class name if one is there
5259         const char* const p = skip_over_field_name(signature + 1, true, --length);
5260 
5261         // The next character better be a semicolon
5262         if (p &amp;&amp; (p - signature) &gt; 1 &amp;&amp; p[0] == JVM_SIGNATURE_ENDCLASS) {
5263           return p + 1;
5264         }
5265       }
5266       else {
5267         // Skip leading &#39;L&#39; and ignore first appearance of &#39;;&#39;
5268         signature++;
5269         const char* c = (const char*) memchr(signature, JVM_SIGNATURE_ENDCLASS, length - 1);
5270         // Format check signature
5271         if (c != NULL) {
5272           int newlen = c - (char*) signature;
5273           bool legal = verify_unqualified_name(signature, newlen, LegalClass);
5274           if (!legal) {
5275             classfile_parse_error(&quot;Class name is empty or contains illegal character &quot;
5276                                   &quot;in descriptor in class file %s&quot;,
<a name="1" id="anc1"></a><span class="line-modified">5277                                   CHECK_NULL);</span>
5278             return NULL;
5279           }
5280           return signature + newlen + 1;
5281         }
5282       }
5283       return NULL;
5284     }
5285     case JVM_SIGNATURE_ARRAY:
5286       array_dim++;
5287       if (array_dim &gt; 255) {
5288         // 4277370: array descriptor is valid only if it represents 255 or fewer dimensions.
<a name="2" id="anc2"></a><span class="line-modified">5289         classfile_parse_error(&quot;Array type descriptor has more than 255 dimensions in class file %s&quot;, CHECK_NULL);</span>
5290       }
5291       // The rest of what&#39;s there better be a legal signature
5292       signature++;
5293       length--;
5294       void_ok = false;
5295       break;
5296     default:
5297       return NULL;
5298     }
5299   }
5300   return NULL;
5301 }
5302 
5303 // Checks if name is a legal class name.
5304 void ClassFileParser::verify_legal_class_name(const Symbol* name, TRAPS) const {
5305   if (!_need_verify || _relax_verify) { return; }
5306 
5307   assert(name-&gt;refcount() &gt; 0, &quot;symbol must be kept alive&quot;);
5308   char* bytes = (char*)name-&gt;bytes();
5309   unsigned int length = name-&gt;utf8_length();
5310   bool legal = false;
5311 
5312   if (length &gt; 0) {
5313     const char* p;
5314     if (bytes[0] == JVM_SIGNATURE_ARRAY) {
5315       p = skip_over_field_signature(bytes, false, length, CHECK);
5316       legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5317     } else if (_major_version &lt; JAVA_1_5_VERSION) {
5318       if (bytes[0] != JVM_SIGNATURE_SPECIAL) {
5319         p = skip_over_field_name(bytes, true, length);
5320         legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5321       }
5322     } else {
5323       // 4900761: relax the constraints based on JSR202 spec
5324       // Class names may be drawn from the entire Unicode character set.
5325       // Identifiers between &#39;/&#39; must be unqualified names.
5326       // The utf8 string has been verified when parsing cpool entries.
5327       legal = verify_unqualified_name(bytes, length, LegalClass);
5328     }
5329   }
5330   if (!legal) {
5331     ResourceMark rm(THREAD);
5332     assert(_class_name != NULL, &quot;invariant&quot;);
5333     Exceptions::fthrow(
5334       THREAD_AND_LOCATION,
5335       vmSymbols::java_lang_ClassFormatError(),
5336       &quot;Illegal class name \&quot;%.*s\&quot; in class file %s&quot;, length, bytes,
5337       _class_name-&gt;as_C_string()
5338     );
5339     return;
5340   }
5341 }
5342 
5343 // Checks if name is a legal field name.
5344 void ClassFileParser::verify_legal_field_name(const Symbol* name, TRAPS) const {
5345   if (!_need_verify || _relax_verify) { return; }
5346 
5347   char* bytes = (char*)name-&gt;bytes();
5348   unsigned int length = name-&gt;utf8_length();
5349   bool legal = false;
5350 
5351   if (length &gt; 0) {
5352     if (_major_version &lt; JAVA_1_5_VERSION) {
5353       if (bytes[0] != JVM_SIGNATURE_SPECIAL) {
5354         const char* p = skip_over_field_name(bytes, false, length);
5355         legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5356       }
5357     } else {
5358       // 4881221: relax the constraints based on JSR202 spec
5359       legal = verify_unqualified_name(bytes, length, LegalField);
5360     }
5361   }
5362 
5363   if (!legal) {
5364     ResourceMark rm(THREAD);
5365     assert(_class_name != NULL, &quot;invariant&quot;);
5366     Exceptions::fthrow(
5367       THREAD_AND_LOCATION,
5368       vmSymbols::java_lang_ClassFormatError(),
5369       &quot;Illegal field name \&quot;%.*s\&quot; in class %s&quot;, length, bytes,
5370       _class_name-&gt;as_C_string()
5371     );
5372     return;
5373   }
5374 }
5375 
5376 // Checks if name is a legal method name.
5377 void ClassFileParser::verify_legal_method_name(const Symbol* name, TRAPS) const {
5378   if (!_need_verify || _relax_verify) { return; }
5379 
5380   assert(name != NULL, &quot;method name is null&quot;);
5381   char* bytes = (char*)name-&gt;bytes();
5382   unsigned int length = name-&gt;utf8_length();
5383   bool legal = false;
5384 
5385   if (length &gt; 0) {
5386     if (bytes[0] == JVM_SIGNATURE_SPECIAL) {
5387       if (name == vmSymbols::object_initializer_name() || name == vmSymbols::class_initializer_name()) {
5388         legal = true;
5389       }
5390     } else if (_major_version &lt; JAVA_1_5_VERSION) {
5391       const char* p;
5392       p = skip_over_field_name(bytes, false, length);
5393       legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5394     } else {
5395       // 4881221: relax the constraints based on JSR202 spec
5396       legal = verify_unqualified_name(bytes, length, LegalMethod);
5397     }
5398   }
5399 
5400   if (!legal) {
5401     ResourceMark rm(THREAD);
5402     assert(_class_name != NULL, &quot;invariant&quot;);
5403     Exceptions::fthrow(
5404       THREAD_AND_LOCATION,
5405       vmSymbols::java_lang_ClassFormatError(),
5406       &quot;Illegal method name \&quot;%.*s\&quot; in class %s&quot;, length, bytes,
5407       _class_name-&gt;as_C_string()
5408     );
5409     return;
5410   }
5411 }
5412 
5413 
5414 // Checks if signature is a legal field signature.
5415 void ClassFileParser::verify_legal_field_signature(const Symbol* name,
5416                                                    const Symbol* signature,
5417                                                    TRAPS) const {
5418   if (!_need_verify) { return; }
5419 
5420   const char* const bytes = (const char* const)signature-&gt;bytes();
5421   const unsigned int length = signature-&gt;utf8_length();
5422   const char* const p = skip_over_field_signature(bytes, false, length, CHECK);
5423 
5424   if (p == NULL || (p - bytes) != (int)length) {
5425     throwIllegalSignature(&quot;Field&quot;, name, signature, CHECK);
5426   }
5427 }
5428 
5429 // Checks if signature is a legal method signature.
5430 // Returns number of parameters
5431 int ClassFileParser::verify_legal_method_signature(const Symbol* name,
5432                                                    const Symbol* signature,
5433                                                    TRAPS) const {
5434   if (!_need_verify) {
5435     // make sure caller&#39;s args_size will be less than 0 even for non-static
5436     // method so it will be recomputed in compute_size_of_parameters().
5437     return -2;
5438   }
5439 
5440   // Class initializers cannot have args for class format version &gt;= 51.
5441   if (name == vmSymbols::class_initializer_name() &amp;&amp;
5442       signature != vmSymbols::void_method_signature() &amp;&amp;
5443       _major_version &gt;= JAVA_7_VERSION) {
5444     throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
5445     return 0;
5446   }
5447 
5448   unsigned int args_size = 0;
5449   const char* p = (const char*)signature-&gt;bytes();
5450   unsigned int length = signature-&gt;utf8_length();
5451   const char* nextp;
5452 
5453   // The first character must be a &#39;(&#39;
5454   if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_FUNC)) {
5455     length--;
5456     // Skip over legal field signatures
5457     nextp = skip_over_field_signature(p, false, length, CHECK_0);
5458     while ((length &gt; 0) &amp;&amp; (nextp != NULL)) {
5459       args_size++;
5460       if (p[0] == &#39;J&#39; || p[0] == &#39;D&#39;) {
5461         args_size++;
5462       }
5463       length -= nextp - p;
5464       p = nextp;
5465       nextp = skip_over_field_signature(p, false, length, CHECK_0);
5466     }
5467     // The first non-signature thing better be a &#39;)&#39;
5468     if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_ENDFUNC)) {
5469       length--;
5470       if (name-&gt;utf8_length() &gt; 0 &amp;&amp; name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {
5471         // All internal methods must return void
5472         if ((length == 1) &amp;&amp; (p[0] == JVM_SIGNATURE_VOID)) {
5473           return args_size;
5474         }
5475       } else {
5476         // Now we better just have a return value
5477         nextp = skip_over_field_signature(p, true, length, CHECK_0);
5478         if (nextp &amp;&amp; ((int)length == (nextp - p))) {
5479           return args_size;
5480         }
5481       }
5482     }
5483   }
5484   // Report error
5485   throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
5486   return 0;
5487 }
5488 
5489 int ClassFileParser::static_field_size() const {
5490   assert(_field_info != NULL, &quot;invariant&quot;);
5491   return _field_info-&gt;_static_field_size;
5492 }
5493 
5494 int ClassFileParser::total_oop_map_count() const {
5495   assert(_field_info != NULL, &quot;invariant&quot;);
5496   return _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count;
5497 }
5498 
5499 jint ClassFileParser::layout_size() const {
5500   assert(_field_info != NULL, &quot;invariant&quot;);
5501   return _field_info-&gt;_instance_size;
5502 }
5503 
5504 static void check_methods_for_intrinsics(const InstanceKlass* ik,
5505                                          const Array&lt;Method*&gt;* methods) {
5506   assert(ik != NULL, &quot;invariant&quot;);
5507   assert(methods != NULL, &quot;invariant&quot;);
5508 
5509   // Set up Method*::intrinsic_id as soon as we know the names of methods.
5510   // (We used to do this lazily, but now we query it in Rewriter,
5511   // which is eagerly done for every method, so we might as well do it now,
5512   // when everything is fresh in memory.)
5513   const vmSymbols::SID klass_id = Method::klass_id_for_intrinsics(ik);
5514 
5515   if (klass_id != vmSymbols::NO_SID) {
5516     for (int j = 0; j &lt; methods-&gt;length(); ++j) {
5517       Method* method = methods-&gt;at(j);
5518       method-&gt;init_intrinsic_id();
5519 
5520       if (CheckIntrinsics) {
5521         // Check if an intrinsic is defined for method &#39;method&#39;,
5522         // but the method is not annotated with @HotSpotIntrinsicCandidate.
5523         if (method-&gt;intrinsic_id() != vmIntrinsics::_none &amp;&amp;
5524             !method-&gt;intrinsic_candidate()) {
5525               tty-&gt;print(&quot;Compiler intrinsic is defined for method [%s], &quot;
5526               &quot;but the method is not annotated with @HotSpotIntrinsicCandidate.%s&quot;,
5527               method-&gt;name_and_sig_as_C_string(),
5528               NOT_DEBUG(&quot; Method will not be inlined.&quot;) DEBUG_ONLY(&quot; Exiting.&quot;)
5529             );
5530           tty-&gt;cr();
5531           DEBUG_ONLY(vm_exit(1));
5532         }
5533         // Check is the method &#39;method&#39; is annotated with @HotSpotIntrinsicCandidate,
5534         // but there is no intrinsic available for it.
5535         if (method-&gt;intrinsic_candidate() &amp;&amp;
5536           method-&gt;intrinsic_id() == vmIntrinsics::_none) {
5537             tty-&gt;print(&quot;Method [%s] is annotated with @HotSpotIntrinsicCandidate, &quot;
5538               &quot;but no compiler intrinsic is defined for the method.%s&quot;,
5539               method-&gt;name_and_sig_as_C_string(),
5540               NOT_DEBUG(&quot;&quot;) DEBUG_ONLY(&quot; Exiting.&quot;)
5541             );
5542           tty-&gt;cr();
5543           DEBUG_ONLY(vm_exit(1));
5544         }
5545       }
5546     } // end for
5547 
5548 #ifdef ASSERT
5549     if (CheckIntrinsics) {
5550       // Check for orphan methods in the current class. A method m
5551       // of a class C is orphan if an intrinsic is defined for method m,
5552       // but class C does not declare m.
5553       // The check is potentially expensive, therefore it is available
5554       // only in debug builds.
5555 
5556       for (int id = vmIntrinsics::FIRST_ID; id &lt; (int)vmIntrinsics::ID_LIMIT; ++id) {
5557         if (vmIntrinsics::_compiledLambdaForm == id) {
5558           // The _compiledLamdbdaForm intrinsic is a special marker for bytecode
5559           // generated for the JVM from a LambdaForm and therefore no method
5560           // is defined for it.
5561           continue;
5562         }
5563 
5564         if (vmIntrinsics::class_for(vmIntrinsics::ID_from(id)) == klass_id) {
5565           // Check if the current class contains a method with the same
5566           // name, flags, signature.
5567           bool match = false;
5568           for (int j = 0; j &lt; methods-&gt;length(); ++j) {
5569             const Method* method = methods-&gt;at(j);
5570             if (method-&gt;intrinsic_id() == id) {
5571               match = true;
5572               break;
5573             }
5574           }
5575 
5576           if (!match) {
5577             char buf[1000];
5578             tty-&gt;print(&quot;Compiler intrinsic is defined for method [%s], &quot;
5579                        &quot;but the method is not available in class [%s].%s&quot;,
5580                         vmIntrinsics::short_name_as_C_string(vmIntrinsics::ID_from(id),
5581                                                              buf, sizeof(buf)),
5582                         ik-&gt;name()-&gt;as_C_string(),
5583                         NOT_DEBUG(&quot;&quot;) DEBUG_ONLY(&quot; Exiting.&quot;)
5584             );
5585             tty-&gt;cr();
5586             DEBUG_ONLY(vm_exit(1));
5587           }
5588         }
5589       } // end for
5590     } // CheckIntrinsics
5591 #endif // ASSERT
5592   }
5593 }
5594 
5595 InstanceKlass* ClassFileParser::create_instance_klass(bool changed_by_loadhook, TRAPS) {
5596   if (_klass != NULL) {
5597     return _klass;
5598   }
5599 
5600   InstanceKlass* const ik =
5601     InstanceKlass::allocate_instance_klass(*this, CHECK_NULL);
5602 
5603   fill_instance_klass(ik, changed_by_loadhook, CHECK_NULL);
5604 
5605   assert(_klass == ik, &quot;invariant&quot;);
5606 
5607 
5608   if (ik-&gt;should_store_fingerprint()) {
5609     ik-&gt;store_fingerprint(_stream-&gt;compute_fingerprint());
5610   }
5611 
5612   ik-&gt;set_has_passed_fingerprint_check(false);
5613   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
5614     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
5615     uint64_t fp = ik-&gt;has_stored_fingerprint() ? ik-&gt;get_stored_fingerprint() : _stream-&gt;compute_fingerprint();
5616     if (aot_fp != 0 &amp;&amp; aot_fp == fp) {
5617       // This class matches with a class saved in an AOT library
5618       ik-&gt;set_has_passed_fingerprint_check(true);
5619     } else {
5620       ResourceMark rm;
5621       log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT,
5622                                  ik-&gt;external_name(), aot_fp, _stream-&gt;compute_fingerprint());
5623     }
5624   }
5625 
5626   return ik;
5627 }
5628 
5629 void ClassFileParser::fill_instance_klass(InstanceKlass* ik, bool changed_by_loadhook, TRAPS) {
5630   assert(ik != NULL, &quot;invariant&quot;);
5631 
5632   // Set name and CLD before adding to CLD
5633   ik-&gt;set_class_loader_data(_loader_data);
5634   ik-&gt;set_name(_class_name);
5635 
5636   // Add all classes to our internal class loader list here,
5637   // including classes in the bootstrap (NULL) class loader.
5638   const bool publicize = !is_internal();
5639 
5640   _loader_data-&gt;add_class(ik, publicize);
5641 
5642   set_klass_to_deallocate(ik);
5643 
5644   assert(_field_info != NULL, &quot;invariant&quot;);
5645   assert(ik-&gt;static_field_size() == _field_info-&gt;_static_field_size, &quot;sanity&quot;);
5646   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count,
5647          &quot;sanity&quot;);
5648 
5649   assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
5650   assert(ik-&gt;size_helper() == _field_info-&gt;_instance_size, &quot;sanity&quot;);
5651 
5652   // Fill in information already parsed
5653   ik-&gt;set_should_verify_class(_need_verify);
5654 
5655   // Not yet: supers are done below to support the new subtype-checking fields
5656   ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);
5657   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);
5658   assert(_fac != NULL, &quot;invariant&quot;);
5659   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP]);
5660 
5661   // this transfers ownership of a lot of arrays from
5662   // the parser onto the InstanceKlass*
5663   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
5664 
5665   // note that is not safe to use the fields in the parser from this point on
5666   assert(NULL == _cp, &quot;invariant&quot;);
5667   assert(NULL == _fields, &quot;invariant&quot;);
5668   assert(NULL == _methods, &quot;invariant&quot;);
5669   assert(NULL == _inner_classes, &quot;invariant&quot;);
5670   assert(NULL == _nest_members, &quot;invariant&quot;);
5671   assert(NULL == _local_interfaces, &quot;invariant&quot;);
5672   assert(NULL == _combined_annotations, &quot;invariant&quot;);
5673   assert(NULL == _record_components, &quot;invariant&quot;);
5674 
5675   if (_has_final_method) {
5676     ik-&gt;set_has_final_method();
5677   }
5678 
5679   ik-&gt;copy_method_ordering(_method_ordering, CHECK);
5680   // The InstanceKlass::_methods_jmethod_ids cache
5681   // is managed on the assumption that the initial cache
5682   // size is equal to the number of methods in the class. If
5683   // that changes, then InstanceKlass::idnum_can_increment()
5684   // has to be changed accordingly.
5685   ik-&gt;set_initial_method_idnum(ik-&gt;methods()-&gt;length());
5686 
5687   ik-&gt;set_this_class_index(_this_class_index);
5688 
5689   if (is_unsafe_anonymous()) {
5690     // _this_class_index is a CONSTANT_Class entry that refers to this
5691     // anonymous class itself. If this class needs to refer to its own methods or
5692     // fields, it would use a CONSTANT_MethodRef, etc, which would reference
5693     // _this_class_index. However, because this class is anonymous (it&#39;s
5694     // not stored in SystemDictionary), _this_class_index cannot be resolved
5695     // with ConstantPool::klass_at_impl, which does a SystemDictionary lookup.
5696     // Therefore, we must eagerly resolve _this_class_index now.
5697     ik-&gt;constants()-&gt;klass_at_put(_this_class_index, ik);
5698   }
5699 
5700   ik-&gt;set_minor_version(_minor_version);
5701   ik-&gt;set_major_version(_major_version);
5702   ik-&gt;set_has_nonstatic_concrete_methods(_has_nonstatic_concrete_methods);
5703   ik-&gt;set_declares_nonstatic_concrete_methods(_declares_nonstatic_concrete_methods);
5704 
5705   if (_unsafe_anonymous_host != NULL) {
5706     assert (ik-&gt;is_unsafe_anonymous(), &quot;should be the same&quot;);
5707     ik-&gt;set_unsafe_anonymous_host(_unsafe_anonymous_host);
5708   }
5709 
5710   // Set PackageEntry for this_klass
5711   oop cl = ik-&gt;class_loader();
5712   Handle clh = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(cl));
5713   ClassLoaderData* cld = ClassLoaderData::class_loader_data_or_null(clh());
5714   ik-&gt;set_package(cld, CHECK);
5715 
5716   const Array&lt;Method*&gt;* const methods = ik-&gt;methods();
5717   assert(methods != NULL, &quot;invariant&quot;);
5718   const int methods_len = methods-&gt;length();
5719 
5720   check_methods_for_intrinsics(ik, methods);
5721 
5722   // Fill in field values obtained by parse_classfile_attributes
5723   if (_parsed_annotations-&gt;has_any_annotations()) {
5724     _parsed_annotations-&gt;apply_to(ik);
5725   }
5726 
5727   apply_parsed_class_attributes(ik);
5728 
5729   // Miranda methods
5730   if ((_num_miranda_methods &gt; 0) ||
5731       // if this class introduced new miranda methods or
5732       (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_miranda_methods())
5733         // super class exists and this class inherited miranda methods
5734      ) {
5735        ik-&gt;set_has_miranda_methods(); // then set a flag
5736   }
5737 
5738   // Fill in information needed to compute superclasses.
5739   ik-&gt;initialize_supers(const_cast&lt;InstanceKlass*&gt;(_super_klass), _transitive_interfaces, CHECK);
5740   ik-&gt;set_transitive_interfaces(_transitive_interfaces);
5741   _transitive_interfaces = NULL;
5742 
5743   // Initialize itable offset tables
5744   klassItable::setup_itable_offset_table(ik);
5745 
5746   // Compute transitive closure of interfaces this class implements
5747   // Do final class setup
5748   OopMapBlocksBuilder* oop_map_blocks = _field_info-&gt;oop_map_blocks;
5749   if (oop_map_blocks-&gt;_nonstatic_oop_map_count &gt; 0) {
5750     oop_map_blocks-&gt;copy(ik-&gt;start_of_nonstatic_oop_maps());
5751   }
5752 
5753   if (_has_contended_fields || _parsed_annotations-&gt;is_contended() ||
5754       ( _super_klass != NULL &amp;&amp; _super_klass-&gt;has_contended_annotations())) {
5755     ik-&gt;set_has_contended_annotations(true);
5756   }
5757 
5758   // Fill in has_finalizer, has_vanilla_constructor, and layout_helper
5759   set_precomputed_flags(ik);
5760 
5761   // check if this class can access its super class
5762   check_super_class_access(ik, CHECK);
5763 
5764   // check if this class can access its superinterfaces
5765   check_super_interface_access(ik, CHECK);
5766 
5767   // check if this class overrides any final method
5768   check_final_method_override(ik, CHECK);
5769 
5770   // reject static interface methods prior to Java 8
5771   if (ik-&gt;is_interface() &amp;&amp; _major_version &lt; JAVA_8_VERSION) {
5772     check_illegal_static_method(ik, CHECK);
5773   }
5774 
5775   // Obtain this_klass&#39; module entry
5776   ModuleEntry* module_entry = ik-&gt;module();
5777   assert(module_entry != NULL, &quot;module_entry should always be set&quot;);
5778 
5779   // Obtain java.lang.Module
5780   Handle module_handle(THREAD, module_entry-&gt;module());
5781 
5782   // Allocate mirror and initialize static fields
5783   // The create_mirror() call will also call compute_modifiers()
5784   java_lang_Class::create_mirror(ik,
5785                                  Handle(THREAD, _loader_data-&gt;class_loader()),
5786                                  module_handle,
5787                                  _protection_domain,
5788                                  CHECK);
5789 
5790   assert(_all_mirandas != NULL, &quot;invariant&quot;);
5791 
5792   // Generate any default methods - default methods are public interface methods
5793   // that have a default implementation.  This is new with Java 8.
5794   if (_has_nonstatic_concrete_methods) {
5795     DefaultMethods::generate_default_methods(ik,
5796                                              _all_mirandas,
5797                                              CHECK);
5798   }
5799 
5800   // Add read edges to the unnamed modules of the bootstrap and app class loaders.
5801   if (changed_by_loadhook &amp;&amp; !module_handle.is_null() &amp;&amp; module_entry-&gt;is_named() &amp;&amp;
5802       !module_entry-&gt;has_default_read_edges()) {
5803     if (!module_entry-&gt;set_has_default_read_edges()) {
5804       // We won a potential race
5805       JvmtiExport::add_default_read_edges(module_handle, THREAD);
5806     }
5807   }
5808 
5809   ClassLoadingService::notify_class_loaded(ik, false /* not shared class */);
5810 
5811   if (!is_internal()) {
5812     if (log_is_enabled(Info, class, load)) {
5813       ResourceMark rm;
5814       const char* module_name = (module_entry-&gt;name() == NULL) ? UNNAMED_MODULE : module_entry-&gt;name()-&gt;as_C_string();
5815       ik-&gt;print_class_load_logging(_loader_data, module_name, _stream);
5816     }
5817 
5818     if (ik-&gt;minor_version() == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
5819         ik-&gt;major_version() == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
5820         log_is_enabled(Info, class, preview)) {
5821       ResourceMark rm;
5822       log_info(class, preview)(&quot;Loading class %s that depends on preview features (class file version %d.65535)&quot;,
5823                                ik-&gt;external_name(), JVM_CLASSFILE_MAJOR_VERSION);
5824     }
5825 
5826     if (log_is_enabled(Debug, class, resolve))  {
5827       ResourceMark rm;
5828       // print out the superclass.
5829       const char * from = ik-&gt;external_name();
5830       if (ik-&gt;java_super() != NULL) {
5831         log_debug(class, resolve)(&quot;%s %s (super)&quot;,
5832                    from,
5833                    ik-&gt;java_super()-&gt;external_name());
5834       }
5835       // print out each of the interface classes referred to by this class.
5836       const Array&lt;InstanceKlass*&gt;* const local_interfaces = ik-&gt;local_interfaces();
5837       if (local_interfaces != NULL) {
5838         const int length = local_interfaces-&gt;length();
5839         for (int i = 0; i &lt; length; i++) {
5840           const InstanceKlass* const k = local_interfaces-&gt;at(i);
5841           const char * to = k-&gt;external_name();
5842           log_debug(class, resolve)(&quot;%s %s (interface)&quot;, from, to);
5843         }
5844       }
5845     }
5846   }
5847 
5848   JFR_ONLY(INIT_ID(ik);)
5849 
5850   // If we reach here, all is well.
5851   // Now remove the InstanceKlass* from the _klass_to_deallocate field
5852   // in order for it to not be destroyed in the ClassFileParser destructor.
5853   set_klass_to_deallocate(NULL);
5854 
5855   // it&#39;s official
5856   set_klass(ik);
5857 
5858   debug_only(ik-&gt;verify();)
5859 }
5860 
5861 void ClassFileParser::update_class_name(Symbol* new_class_name) {
5862   // Decrement the refcount in the old name, since we&#39;re clobbering it.
5863   _class_name-&gt;decrement_refcount();
5864 
5865   _class_name = new_class_name;
5866   // Increment the refcount of the new name.
5867   // Now the ClassFileParser owns this name and will decrement in
5868   // the destructor.
5869   _class_name-&gt;increment_refcount();
5870 }
5871 
5872 
5873 // For an unsafe anonymous class that is in the unnamed package, move it to its host class&#39;s
5874 // package by prepending its host class&#39;s package name to its class name and setting
5875 // its _class_name field.
5876 void ClassFileParser::prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS) {
5877   ResourceMark rm(THREAD);
5878   assert(strrchr(_class_name-&gt;as_C_string(), JVM_SIGNATURE_SLASH) == NULL,
5879          &quot;Unsafe anonymous class should not be in a package&quot;);
5880   const char* host_pkg_name =
5881     ClassLoader::package_from_name(unsafe_anonymous_host-&gt;name()-&gt;as_C_string(), NULL);
5882 
5883   if (host_pkg_name != NULL) {
5884     int host_pkg_len = (int)strlen(host_pkg_name);
5885     int class_name_len = _class_name-&gt;utf8_length();
5886     int symbol_len = host_pkg_len + 1 + class_name_len;
5887     char* new_anon_name = NEW_RESOURCE_ARRAY(char, symbol_len + 1);
5888     int n = os::snprintf(new_anon_name, symbol_len + 1, &quot;%s/%.*s&quot;,
5889                          host_pkg_name, class_name_len, _class_name-&gt;base());
5890     assert(n == symbol_len, &quot;Unexpected number of characters in string&quot;);
5891 
5892     // Decrement old _class_name to avoid leaking.
5893     _class_name-&gt;decrement_refcount();
5894 
5895     // Create a symbol and update the anonymous class name.
5896     // The new class name is created with a refcount of one. When installed into the InstanceKlass,
5897     // it&#39;ll be two and when the ClassFileParser destructor runs, it&#39;ll go back to one and get deleted
5898     // when the class is unloaded.
5899     _class_name = SymbolTable::new_symbol(new_anon_name, symbol_len);
5900   }
5901 }
5902 
5903 // If the host class and the anonymous class are in the same package then do
5904 // nothing.  If the anonymous class is in the unnamed package then move it to its
5905 // host&#39;s package.  If the classes are in different packages then throw an IAE
5906 // exception.
5907 void ClassFileParser::fix_unsafe_anonymous_class_name(TRAPS) {
5908   assert(_unsafe_anonymous_host != NULL, &quot;Expected an unsafe anonymous class&quot;);
5909 
5910   const jbyte* anon_last_slash = UTF8::strrchr((const jbyte*)_class_name-&gt;base(),
5911                                                _class_name-&gt;utf8_length(), JVM_SIGNATURE_SLASH);
5912   if (anon_last_slash == NULL) {  // Unnamed package
5913     prepend_host_package_name(_unsafe_anonymous_host, CHECK);
5914   } else {
5915     if (!_unsafe_anonymous_host-&gt;is_same_class_package(_unsafe_anonymous_host-&gt;class_loader(), _class_name)) {
5916       ResourceMark rm(THREAD);
5917       THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
5918         err_msg(&quot;Host class %s and anonymous class %s are in different packages&quot;,
5919         _unsafe_anonymous_host-&gt;name()-&gt;as_C_string(), _class_name-&gt;as_C_string()));
5920     }
5921   }
5922 }
5923 
5924 static bool relax_format_check_for(ClassLoaderData* loader_data) {
5925   bool trusted = (loader_data-&gt;is_the_null_class_loader_data() ||
5926                   SystemDictionary::is_platform_class_loader(loader_data-&gt;class_loader()));
5927   bool need_verify =
5928     // verifyAll
5929     (BytecodeVerificationLocal &amp;&amp; BytecodeVerificationRemote) ||
5930     // verifyRemote
5931     (!BytecodeVerificationLocal &amp;&amp; BytecodeVerificationRemote &amp;&amp; !trusted);
5932   return !need_verify;
5933 }
5934 
5935 ClassFileParser::ClassFileParser(ClassFileStream* stream,
5936                                  Symbol* name,
5937                                  ClassLoaderData* loader_data,
5938                                  Handle protection_domain,
5939                                  const InstanceKlass* unsafe_anonymous_host,
5940                                  GrowableArray&lt;Handle&gt;* cp_patches,
5941                                  Publicity pub_level,
5942                                  TRAPS) :
5943   _stream(stream),
5944   _requested_name(name),
5945   _class_name(NULL),
5946   _loader_data(loader_data),
5947   _unsafe_anonymous_host(unsafe_anonymous_host),
5948   _cp_patches(cp_patches),
5949   _num_patched_klasses(0),
5950   _max_num_patched_klasses(0),
5951   _orig_cp_size(0),
5952   _first_patched_klass_resolved_index(0),
5953   _super_klass(),
5954   _cp(NULL),
5955   _fields(NULL),
5956   _methods(NULL),
5957   _inner_classes(NULL),
5958   _nest_members(NULL),
5959   _nest_host(0),
5960   _record_components(NULL),
5961   _local_interfaces(NULL),
5962   _transitive_interfaces(NULL),
5963   _combined_annotations(NULL),
5964   _class_annotations(NULL),
5965   _class_type_annotations(NULL),
5966   _fields_annotations(NULL),
5967   _fields_type_annotations(NULL),
5968   _klass(NULL),
5969   _klass_to_deallocate(NULL),
5970   _parsed_annotations(NULL),
5971   _fac(NULL),
5972   _field_info(NULL),
5973   _method_ordering(NULL),
5974   _all_mirandas(NULL),
5975   _vtable_size(0),
5976   _itable_size(0),
5977   _num_miranda_methods(0),
5978   _rt(REF_NONE),
5979   _protection_domain(protection_domain),
5980   _access_flags(),
5981   _pub_level(pub_level),
5982   _bad_constant_seen(0),
5983   _synthetic_flag(false),
5984   _sde_length(false),
5985   _sde_buffer(NULL),
5986   _sourcefile_index(0),
5987   _generic_signature_index(0),
5988   _major_version(0),
5989   _minor_version(0),
5990   _this_class_index(0),
5991   _super_class_index(0),
5992   _itfs_len(0),
5993   _java_fields_count(0),
5994   _need_verify(false),
5995   _relax_verify(false),
5996   _has_nonstatic_concrete_methods(false),
5997   _declares_nonstatic_concrete_methods(false),
5998   _has_final_method(false),
5999   _has_contended_fields(false),
6000   _has_finalizer(false),
6001   _has_empty_finalizer(false),
6002   _has_vanilla_constructor(false),
6003   _max_bootstrap_specifier_index(-1) {
6004 
6005   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
6006   _class_name-&gt;increment_refcount();
6007 
6008   assert(THREAD-&gt;is_Java_thread(), &quot;invariant&quot;);
6009   assert(_loader_data != NULL, &quot;invariant&quot;);
6010   assert(stream != NULL, &quot;invariant&quot;);
6011   assert(_stream != NULL, &quot;invariant&quot;);
6012   assert(_stream-&gt;buffer() == _stream-&gt;current(), &quot;invariant&quot;);
6013   assert(_class_name != NULL, &quot;invariant&quot;);
6014   assert(0 == _access_flags.as_int(), &quot;invariant&quot;);
6015 
6016   // Figure out whether we can skip format checking (matching classic VM behavior)
6017   if (DumpSharedSpaces) {
6018     // verify == true means it&#39;s a &#39;remote&#39; class (i.e., non-boot class)
6019     // Verification decision is based on BytecodeVerificationRemote flag
6020     // for those classes.
6021     _need_verify = (stream-&gt;need_verify()) ? BytecodeVerificationRemote :
6022                                               BytecodeVerificationLocal;
6023   }
6024   else {
6025     _need_verify = Verifier::should_verify_for(_loader_data-&gt;class_loader(),
6026                                                stream-&gt;need_verify());
6027   }
6028   if (_cp_patches != NULL) {
6029     int len = _cp_patches-&gt;length();
6030     for (int i=0; i&lt;len; i++) {
6031       if (has_cp_patch_at(i)) {
6032         Handle patch = cp_patch_at(i);
6033         if (java_lang_String::is_instance(patch()) || java_lang_Class::is_instance(patch())) {
6034           // We need to append the names of the patched classes to the end of the constant pool,
6035           // because a patched class may have a Utf8 name that&#39;s not already included in the
6036           // original constant pool. These class names are used when patch_constant_pool()
6037           // calls patch_class().
6038           //
6039           // Note that a String in cp_patch_at(i) may be used to patch a Utf8, a String, or a Class.
6040           // At this point, we don&#39;t know the tag for index i yet, because we haven&#39;t parsed the
6041           // constant pool. So we can only assume the worst -- every String is used to patch a Class.
6042           _max_num_patched_klasses++;
6043         }
6044       }
6045     }
6046   }
6047 
6048   // synch back verification state to stream
6049   stream-&gt;set_verify(_need_verify);
6050 
6051   // Check if verification needs to be relaxed for this class file
6052   // Do not restrict it to jdk1.0 or jdk1.1 to maintain backward compatibility (4982376)
6053   _relax_verify = relax_format_check_for(_loader_data);
6054 
6055   parse_stream(stream, CHECK);
6056 
6057   post_process_parsed_stream(stream, _cp, CHECK);
6058 }
6059 
6060 void ClassFileParser::clear_class_metadata() {
6061   // metadata created before the instance klass is created.  Must be
6062   // deallocated if classfile parsing returns an error.
6063   _cp = NULL;
6064   _fields = NULL;
6065   _methods = NULL;
6066   _inner_classes = NULL;
6067   _nest_members = NULL;
6068   _local_interfaces = NULL;
6069   _combined_annotations = NULL;
6070   _class_annotations = _class_type_annotations = NULL;
6071   _fields_annotations = _fields_type_annotations = NULL;
6072   _record_components = NULL;
6073 }
6074 
6075 // Destructor to clean up
6076 ClassFileParser::~ClassFileParser() {
6077   _class_name-&gt;decrement_refcount();
6078 
6079   if (_cp != NULL) {
6080     MetadataFactory::free_metadata(_loader_data, _cp);
6081   }
6082   if (_fields != NULL) {
6083     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _fields);
6084   }
6085 
6086   if (_methods != NULL) {
6087     // Free methods
6088     InstanceKlass::deallocate_methods(_loader_data, _methods);
6089   }
6090 
6091   // beware of the Universe::empty_blah_array!!
6092   if (_inner_classes != NULL &amp;&amp; _inner_classes != Universe::the_empty_short_array()) {
6093     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _inner_classes);
6094   }
6095 
6096   if (_nest_members != NULL &amp;&amp; _nest_members != Universe::the_empty_short_array()) {
6097     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _nest_members);
6098   }
6099 
6100   if (_record_components != NULL) {
6101     InstanceKlass::deallocate_record_components(_loader_data, _record_components);
6102   }
6103 
6104   // Free interfaces
6105   InstanceKlass::deallocate_interfaces(_loader_data, _super_klass,
6106                                        _local_interfaces, _transitive_interfaces);
6107 
6108   if (_combined_annotations != NULL) {
6109     // After all annotations arrays have been created, they are installed into the
6110     // Annotations object that will be assigned to the InstanceKlass being created.
6111 
6112     // Deallocate the Annotations object and the installed annotations arrays.
6113     _combined_annotations-&gt;deallocate_contents(_loader_data);
6114 
6115     // If the _combined_annotations pointer is non-NULL,
6116     // then the other annotations fields should have been cleared.
6117     assert(_class_annotations       == NULL, &quot;Should have been cleared&quot;);
6118     assert(_class_type_annotations  == NULL, &quot;Should have been cleared&quot;);
6119     assert(_fields_annotations      == NULL, &quot;Should have been cleared&quot;);
6120     assert(_fields_type_annotations == NULL, &quot;Should have been cleared&quot;);
6121   } else {
6122     // If the annotations arrays were not installed into the Annotations object,
6123     // then they have to be deallocated explicitly.
6124     MetadataFactory::free_array&lt;u1&gt;(_loader_data, _class_annotations);
6125     MetadataFactory::free_array&lt;u1&gt;(_loader_data, _class_type_annotations);
6126     Annotations::free_contents(_loader_data, _fields_annotations);
6127     Annotations::free_contents(_loader_data, _fields_type_annotations);
6128   }
6129 
6130   clear_class_metadata();
6131   _transitive_interfaces = NULL;
6132 
6133   // deallocate the klass if already created.  Don&#39;t directly deallocate, but add
6134   // to the deallocate list so that the klass is removed from the CLD::_klasses list
6135   // at a safepoint.
6136   if (_klass_to_deallocate != NULL) {
6137     _loader_data-&gt;add_to_deallocate_list(_klass_to_deallocate);
6138   }
6139 }
6140 
6141 void ClassFileParser::parse_stream(const ClassFileStream* const stream,
6142                                    TRAPS) {
6143 
6144   assert(stream != NULL, &quot;invariant&quot;);
6145   assert(_class_name != NULL, &quot;invariant&quot;);
6146 
6147   // BEGIN STREAM PARSING
6148   stream-&gt;guarantee_more(8, CHECK);  // magic, major, minor
6149   // Magic value
6150   const u4 magic = stream-&gt;get_u4_fast();
6151   guarantee_property(magic == JAVA_CLASSFILE_MAGIC,
6152                      &quot;Incompatible magic value %u in class file %s&quot;,
6153                      magic, CHECK);
6154 
6155   // Version numbers
6156   _minor_version = stream-&gt;get_u2_fast();
6157   _major_version = stream-&gt;get_u2_fast();
6158 
6159   if (DumpSharedSpaces &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
6160     ResourceMark rm;
6161     warning(&quot;Pre JDK 6 class not supported by CDS: %u.%u %s&quot;,
6162             _major_version,  _minor_version, _class_name-&gt;as_C_string());
6163     Exceptions::fthrow(
6164       THREAD_AND_LOCATION,
6165       vmSymbols::java_lang_UnsupportedClassVersionError(),
6166       &quot;Unsupported major.minor version for dump time %u.%u&quot;,
6167       _major_version,
6168       _minor_version);
6169   }
6170 
6171   // Check version numbers - we check this even with verifier off
6172   verify_class_version(_major_version, _minor_version, _class_name, CHECK);
6173 
6174   stream-&gt;guarantee_more(3, CHECK); // length, first cp tag
6175   u2 cp_size = stream-&gt;get_u2_fast();
6176 
6177   guarantee_property(
6178     cp_size &gt;= 1, &quot;Illegal constant pool size %u in class file %s&quot;,
6179     cp_size, CHECK);
6180 
6181   _orig_cp_size = cp_size;
6182   if (int(cp_size) + _max_num_patched_klasses &gt; 0xffff) {
6183     THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;not enough space for patched classes&quot;);
6184   }
6185   cp_size += _max_num_patched_klasses;
6186 
6187   _cp = ConstantPool::allocate(_loader_data,
6188                                cp_size,
6189                                CHECK);
6190 
6191   ConstantPool* const cp = _cp;
6192 
6193   parse_constant_pool(stream, cp, _orig_cp_size, CHECK);
6194 
6195   assert(cp_size == (const u2)cp-&gt;length(), &quot;invariant&quot;);
6196 
6197   // ACCESS FLAGS
6198   stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
6199 
6200   // Access flags
6201   jint flags;
6202   // JVM_ACC_MODULE is defined in JDK-9 and later.
6203   if (_major_version &gt;= JAVA_9_VERSION) {
6204     flags = stream-&gt;get_u2_fast() &amp; (JVM_RECOGNIZED_CLASS_MODIFIERS | JVM_ACC_MODULE);
6205   } else {
6206     flags = stream-&gt;get_u2_fast() &amp; JVM_RECOGNIZED_CLASS_MODIFIERS;
6207   }
6208 
6209   if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
6210     // Set abstract bit for old class files for backward compatibility
6211     flags |= JVM_ACC_ABSTRACT;
6212   }
6213 
6214   verify_legal_class_modifiers(flags, CHECK);
6215 
6216   short bad_constant = class_bad_constant_seen();
6217   if (bad_constant != 0) {
6218     // Do not throw CFE until after the access_flags are checked because if
6219     // ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.
6220     classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;, bad_constant, CHECK);
6221   }
6222 
6223   _access_flags.set_flags(flags);
6224 
6225   // This class and superclass
6226   _this_class_index = stream-&gt;get_u2_fast();
6227   check_property(
6228     valid_cp_range(_this_class_index, cp_size) &amp;&amp;
6229       cp-&gt;tag_at(_this_class_index).is_unresolved_klass(),
6230     &quot;Invalid this class index %u in constant pool in class file %s&quot;,
6231     _this_class_index, CHECK);
6232 
6233   Symbol* const class_name_in_cp = cp-&gt;klass_name_at(_this_class_index);
6234   assert(class_name_in_cp != NULL, &quot;class_name can&#39;t be null&quot;);
6235 
6236   // Update _class_name to reflect the name in the constant pool
6237   update_class_name(class_name_in_cp);
6238 
6239   // Don&#39;t need to check whether this class name is legal or not.
6240   // It has been checked when constant pool is parsed.
6241   // However, make sure it is not an array type.
6242   if (_need_verify) {
6243     guarantee_property(_class_name-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
6244                        &quot;Bad class name in class file %s&quot;,
6245                        CHECK);
6246   }
6247 
6248   // Checks if name in class file matches requested name
6249   if (_requested_name != NULL &amp;&amp; _requested_name != _class_name) {
6250     ResourceMark rm(THREAD);
6251     Exceptions::fthrow(
6252       THREAD_AND_LOCATION,
6253       vmSymbols::java_lang_NoClassDefFoundError(),
6254       &quot;%s (wrong name: %s)&quot;,
6255       _class_name-&gt;as_C_string(),
6256       _requested_name != NULL ? _requested_name-&gt;as_C_string() : &quot;NoName&quot;
6257     );
6258     return;
6259   }
6260 
6261   // if this is an anonymous class fix up its name if it&#39;s in the unnamed
6262   // package.  Otherwise, throw IAE if it is in a different package than
6263   // its host class.
6264   if (_unsafe_anonymous_host != NULL) {
6265     fix_unsafe_anonymous_class_name(CHECK);
6266   }
6267 
6268   // Verification prevents us from creating names with dots in them, this
6269   // asserts that that&#39;s the case.
6270   assert(is_internal_format(_class_name), &quot;external class name format used internally&quot;);
6271 
6272   if (!is_internal()) {
6273     LogTarget(Debug, class, preorder) lt;
6274     if (lt.is_enabled()){
6275       ResourceMark rm(THREAD);
6276       LogStream ls(lt);
6277       ls.print(&quot;%s&quot;, _class_name-&gt;as_klass_external_name());
6278       if (stream-&gt;source() != NULL) {
6279         ls.print(&quot; source: %s&quot;, stream-&gt;source());
6280       }
6281       ls.cr();
6282     }
6283 
6284 #if INCLUDE_CDS
6285     if (DumpLoadedClassList != NULL &amp;&amp; stream-&gt;source() != NULL &amp;&amp; classlist_file-&gt;is_open()) {
6286       if (!ClassLoader::has_jrt_entry()) {
6287         warning(&quot;DumpLoadedClassList and CDS are not supported in exploded build&quot;);
6288         DumpLoadedClassList = NULL;
6289       } else if (SystemDictionaryShared::is_sharing_possible(_loader_data) &amp;&amp;
6290                  _unsafe_anonymous_host == NULL) {
6291         // Only dump the classes that can be stored into CDS archive.
6292         // Unsafe anonymous classes such as generated LambdaForm classes are also not included.
6293         oop class_loader = _loader_data-&gt;class_loader();
6294         ResourceMark rm(THREAD);
6295         bool skip = false;
6296         if (class_loader == NULL || SystemDictionary::is_platform_class_loader(class_loader)) {
6297           // For the boot and platform class loaders, skip classes that are not found in the
6298           // java runtime image, such as those found in the --patch-module entries.
6299           // These classes can&#39;t be loaded from the archive during runtime.
6300           if (!stream-&gt;from_boot_loader_modules_image() &amp;&amp; strncmp(stream-&gt;source(), &quot;jrt:&quot;, 4) != 0) {
6301             skip = true;
6302           }
6303 
6304           if (class_loader == NULL &amp;&amp; ClassLoader::contains_append_entry(stream-&gt;source())) {
6305             // .. but don&#39;t skip the boot classes that are loaded from -Xbootclasspath/a
6306             // as they can be loaded from the archive during runtime.
6307             skip = false;
6308           }
6309         }
6310         if (skip) {
6311           tty-&gt;print_cr(&quot;skip writing class %s from source %s to classlist file&quot;,
6312             _class_name-&gt;as_C_string(), stream-&gt;source());
6313         } else {
6314           classlist_file-&gt;print_cr(&quot;%s&quot;, _class_name-&gt;as_C_string());
6315           classlist_file-&gt;flush();
6316         }
6317       }
6318     }
6319 #endif
6320   }
6321 
6322   // SUPERKLASS
6323   _super_class_index = stream-&gt;get_u2_fast();
6324   _super_klass = parse_super_class(cp,
6325                                    _super_class_index,
6326                                    _need_verify,
6327                                    CHECK);
6328 
6329   // Interfaces
6330   _itfs_len = stream-&gt;get_u2_fast();
6331   parse_interfaces(stream,
6332                    _itfs_len,
6333                    cp,
6334                    &amp;_has_nonstatic_concrete_methods,
6335                    CHECK);
6336 
6337   assert(_local_interfaces != NULL, &quot;invariant&quot;);
6338 
6339   // Fields (offsets are filled in later)
6340   _fac = new FieldAllocationCount();
6341   parse_fields(stream,
6342                _access_flags.is_interface(),
6343                _fac,
6344                cp,
6345                cp_size,
6346                &amp;_java_fields_count,
6347                CHECK);
6348 
6349   assert(_fields != NULL, &quot;invariant&quot;);
6350 
6351   // Methods
6352   AccessFlags promoted_flags;
6353   parse_methods(stream,
6354                 _access_flags.is_interface(),
6355                 &amp;promoted_flags,
6356                 &amp;_has_final_method,
6357                 &amp;_declares_nonstatic_concrete_methods,
6358                 CHECK);
6359 
6360   assert(_methods != NULL, &quot;invariant&quot;);
6361 
6362   // promote flags from parse_methods() to the klass&#39; flags
6363   _access_flags.add_promoted_flags(promoted_flags.as_int());
6364 
6365   if (_declares_nonstatic_concrete_methods) {
6366     _has_nonstatic_concrete_methods = true;
6367   }
6368 
6369   // Additional attributes/annotations
6370   _parsed_annotations = new ClassAnnotationCollector();
6371   parse_classfile_attributes(stream, cp, _parsed_annotations, CHECK);
6372 
6373   assert(_inner_classes != NULL, &quot;invariant&quot;);
6374 
6375   // Finalize the Annotations metadata object,
6376   // now that all annotation arrays have been created.
6377   create_combined_annotations(CHECK);
6378 
6379   // Make sure this is the end of class file stream
6380   guarantee_property(stream-&gt;at_eos(),
6381                      &quot;Extra bytes at the end of class file %s&quot;,
6382                      CHECK);
6383 
6384   // all bytes in stream read and parsed
6385 }
6386 
6387 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
6388                                                  ConstantPool* cp,
6389                                                  TRAPS) {
6390   assert(stream != NULL, &quot;invariant&quot;);
6391   assert(stream-&gt;at_eos(), &quot;invariant&quot;);
6392   assert(cp != NULL, &quot;invariant&quot;);
6393   assert(_loader_data != NULL, &quot;invariant&quot;);
6394 
6395   if (_class_name == vmSymbols::java_lang_Object()) {
6396     check_property(_local_interfaces == Universe::the_empty_instance_klass_array(),
6397                    &quot;java.lang.Object cannot implement an interface in class file %s&quot;,
6398                    CHECK);
6399   }
6400   // We check super class after class file is parsed and format is checked
6401   if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) {
6402     Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index);
6403     if (_access_flags.is_interface()) {
6404       // Before attempting to resolve the superclass, check for class format
6405       // errors not checked yet.
6406       guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
6407         &quot;Interfaces must have java.lang.Object as superclass in class file %s&quot;,
6408         CHECK);
6409     }
6410     Handle loader(THREAD, _loader_data-&gt;class_loader());
6411     _super_klass = (const InstanceKlass*)
6412                        SystemDictionary::resolve_super_or_fail(_class_name,
6413                                                                super_class_name,
6414                                                                loader,
6415                                                                _protection_domain,
6416                                                                true,
6417                                                                CHECK);
6418   }
6419 
6420   if (_super_klass != NULL) {
6421     if (_super_klass-&gt;has_nonstatic_concrete_methods()) {
6422       _has_nonstatic_concrete_methods = true;
6423     }
6424 
6425     if (_super_klass-&gt;is_interface()) {
6426       ResourceMark rm(THREAD);
6427       Exceptions::fthrow(
6428         THREAD_AND_LOCATION,
6429         vmSymbols::java_lang_IncompatibleClassChangeError(),
6430         &quot;class %s has interface %s as super class&quot;,
6431         _class_name-&gt;as_klass_external_name(),
6432         _super_klass-&gt;external_name()
6433       );
6434       return;
6435     }
6436     // Make sure super class is not final
6437     if (_super_klass-&gt;is_final()) {
6438       THROW_MSG(vmSymbols::java_lang_VerifyError(), &quot;Cannot inherit from final class&quot;);
6439     }
6440   }
6441 
6442   // Compute the transitive list of all unique interfaces implemented by this class
6443   _transitive_interfaces =
6444     compute_transitive_interfaces(_super_klass,
6445                                   _local_interfaces,
6446                                   _loader_data,
6447                                   CHECK);
6448 
6449   assert(_transitive_interfaces != NULL, &quot;invariant&quot;);
6450 
6451   // sort methods
6452   _method_ordering = sort_methods(_methods);
6453 
6454   _all_mirandas = new GrowableArray&lt;Method*&gt;(20);
6455 
6456   Handle loader(THREAD, _loader_data-&gt;class_loader());
6457   klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size,
6458                                                     &amp;_num_miranda_methods,
6459                                                     _all_mirandas,
6460                                                     _super_klass,
6461                                                     _methods,
6462                                                     _access_flags,
6463                                                     _major_version,
6464                                                     loader,
6465                                                     _class_name,
6466                                                     _local_interfaces,
6467                                                     CHECK);
6468 
6469   // Size of Java itable (in words)
6470   _itable_size = _access_flags.is_interface() ? 0 :
6471     klassItable::compute_itable_size(_transitive_interfaces);
6472 
6473   assert(_fac != NULL, &quot;invariant&quot;);
6474   assert(_parsed_annotations != NULL, &quot;invariant&quot;);
6475 
6476   _field_info = new FieldLayoutInfo();
6477   if (UseNewFieldLayout) {
6478     FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,
6479                           _parsed_annotations-&gt;is_contended(), _field_info);
6480     lb.build_layout();
6481   } else {
6482     layout_fields(cp, _fac, _parsed_annotations, _field_info, CHECK);
6483   }
6484 
6485   // Compute reference typ
6486   _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();
6487 
6488 }
6489 
6490 void ClassFileParser::set_klass(InstanceKlass* klass) {
6491 
6492 #ifdef ASSERT
6493   if (klass != NULL) {
6494     assert(NULL == _klass, &quot;leaking?&quot;);
6495   }
6496 #endif
6497 
6498   _klass = klass;
6499 }
6500 
6501 void ClassFileParser::set_klass_to_deallocate(InstanceKlass* klass) {
6502 
6503 #ifdef ASSERT
6504   if (klass != NULL) {
6505     assert(NULL == _klass_to_deallocate, &quot;leaking?&quot;);
6506   }
6507 #endif
6508 
6509   _klass_to_deallocate = klass;
6510 }
6511 
6512 // Caller responsible for ResourceMark
6513 // clone stream with rewound position
6514 const ClassFileStream* ClassFileParser::clone_stream() const {
6515   assert(_stream != NULL, &quot;invariant&quot;);
6516 
6517   return _stream-&gt;clone();
6518 }
6519 // ----------------------------------------------------------------------------
6520 // debugging
6521 
6522 #ifdef ASSERT
6523 
6524 // return true if class_name contains no &#39;.&#39; (internal format is &#39;/&#39;)
6525 bool ClassFileParser::is_internal_format(Symbol* class_name) {
6526   if (class_name != NULL) {
6527     ResourceMark rm;
6528     char* name = class_name-&gt;as_C_string();
6529     return strchr(name, JVM_SIGNATURE_DOT) == NULL;
6530   } else {
6531     return true;
6532   }
6533 }
6534 
6535 #endif
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
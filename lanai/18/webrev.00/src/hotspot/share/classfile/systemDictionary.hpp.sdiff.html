<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/systemDictionary.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="systemDictionary.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionaryShared.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/systemDictionary.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
209   do_klass(Boolean_klass,                               java_lang_Boolean                                     ) \
210   do_klass(Character_klass,                             java_lang_Character                                   ) \
211   do_klass(Float_klass,                                 java_lang_Float                                       ) \
212   do_klass(Double_klass,                                java_lang_Double                                      ) \
213   do_klass(Byte_klass,                                  java_lang_Byte                                        ) \
214   do_klass(Short_klass,                                 java_lang_Short                                       ) \
215   do_klass(Integer_klass,                               java_lang_Integer                                     ) \
216   do_klass(Long_klass,                                  java_lang_Long                                        ) \
217                                                                                                                 \
218   /* force inline of iterators */                                                                               \
219   do_klass(Iterator_klass,                              java_util_Iterator                                    ) \
220                                                                                                                 \
221   /* support for records */                                                                                     \
222   do_klass(RecordComponent_klass,                       java_lang_reflect_RecordComponent                     ) \
223                                                                                                                 \
224   /*end*/
225 
226 class SystemDictionary : AllStatic {
227   friend class BootstrapInfo;
228   friend class VMStructs;
<span class="line-removed">229   friend class SystemDictionaryHandles;</span>
230 
231  public:
232   enum WKID {
233     NO_WKID = 0,
234 
235     #define WK_KLASS_ENUM(name, symbol) WK_KLASS_ENUM_NAME(name), WK_KLASS_ENUM_NAME(symbol) = WK_KLASS_ENUM_NAME(name),
236     WK_KLASSES_DO(WK_KLASS_ENUM)
237     #undef WK_KLASS_ENUM
238 
239     WKID_LIMIT,
240 
241     FIRST_WKID = NO_WKID + 1
242   };
243 
244   // Returns a class with a given class name and class loader.  Loads the
245   // class if needed. If not found a NoClassDefFoundError or a
246   // ClassNotFoundException is thrown, depending on the value on the
247   // throw_error flag.  For most uses the throw_error argument should be set
248   // to true.
249 
</pre>
<hr />
<pre>
370   // Verification
371   static void verify();
372 
373   // Initialization
374   static void initialize(TRAPS);
375 
376   // Checked fast access to the well-known classes -- so that you don&#39;t try to use them
377   // before they are resolved.
378   static InstanceKlass* check_klass(InstanceKlass* k) {
379     assert(k != NULL, &quot;klass not loaded&quot;);
380     return k;
381   }
382 
383   static bool resolve_wk_klass(WKID id, TRAPS);
384   static void resolve_wk_klasses_until(WKID limit_id, WKID &amp;start_id, TRAPS);
385   static void resolve_wk_klasses_through(WKID end_id, WKID &amp;start_id, TRAPS) {
386     int limit = (int)end_id + 1;
387     resolve_wk_klasses_until((WKID) limit, start_id, THREAD);
388   }
389 public:


390   #define WK_KLASS_DECLARE(name, symbol) \
391     static InstanceKlass* name() { return check_klass(_well_known_klasses[WK_KLASS_ENUM_NAME(name)]); } \
392     static InstanceKlass** name##_addr() {                                                              \
393       return &amp;_well_known_klasses[SystemDictionary::WK_KLASS_ENUM_NAME(name)];                          \
394     }                                                                                                   \
395     static bool name##_is_loaded() {                                                                    \
<span class="line-modified">396       return _well_known_klasses[SystemDictionary::WK_KLASS_ENUM_NAME(name)] != NULL;                   \</span>
397     }
398   WK_KLASSES_DO(WK_KLASS_DECLARE);
399   #undef WK_KLASS_DECLARE
400 
401   static InstanceKlass* well_known_klass(WKID id) {
402     assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
403     return _well_known_klasses[id];
404   }
405 
406   static InstanceKlass** well_known_klass_addr(WKID id) {
407     assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
408     return &amp;_well_known_klasses[id];
409   }
410   static void well_known_klasses_do(MetaspaceClosure* it);
411 
<span class="line-removed">412   // Local definition for direct access to the private array:</span>
<span class="line-removed">413   #define WK_KLASS(name) _well_known_klasses[SystemDictionary::WK_KLASS_ENUM_NAME(name)]</span>
<span class="line-removed">414 </span>
415   static InstanceKlass* box_klass(BasicType t) {
416     assert((uint)t &lt; T_VOID+1, &quot;range check&quot;);
417     return check_klass(_box_klasses[t]);
418   }
419   static BasicType box_klass_type(Klass* k);  // inverse of box_klass
420 #ifdef ASSERT
421   static bool is_well_known_klass(Klass* k) {
422     return is_well_known_klass(k-&gt;name());
423   }
424   static bool is_well_known_klass(Symbol* class_name);
425 #endif
426 
427 protected:
428   // Returns the class loader data to be used when looking up/updating the
429   // system dictionary.
430   static ClassLoaderData *class_loader_data(Handle class_loader) {
431     return ClassLoaderData::class_loader_data(class_loader());
432   }
433 




434 public:
<span class="line-modified">435   static bool Parameter_klass_loaded()      { return WK_KLASS(reflect_Parameter_klass) != NULL; }</span>
<span class="line-modified">436   static bool Class_klass_loaded()          { return WK_KLASS(Class_klass) != NULL; }</span>
<span class="line-modified">437   static bool Cloneable_klass_loaded()      { return WK_KLASS(Cloneable_klass) != NULL; }</span>
<span class="line-modified">438   static bool Object_klass_loaded()         { return WK_KLASS(Object_klass) != NULL; }</span>
<span class="line-modified">439   static bool ClassLoader_klass_loaded()    { return WK_KLASS(ClassLoader_klass) != NULL; }</span>
440 
441   // Returns java system loader
442   static oop java_system_loader();
443 
444   // Returns java platform loader
445   static oop java_platform_loader();
446 
447   // Compute the java system and platform loaders
448   static void compute_java_loaders(TRAPS);
449 
450   // Register a new class loader
451   static ClassLoaderData* register_loader(Handle class_loader);
452 protected:
453   // Mirrors for primitive classes (created eagerly)
454   static oop check_mirror(oop m) {
455     assert(m != NULL, &quot;mirror not initialized&quot;);
456     return m;
457   }
458 
459 public:
</pre>
<hr />
<pre>
574 
575   // Basic loading operations
576   static InstanceKlass* resolve_instance_class_or_null_helper(Symbol* name,
577                                                               Handle class_loader,
578                                                               Handle protection_domain,
579                                                               TRAPS);
580   static InstanceKlass* resolve_instance_class_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);
581   static Klass* resolve_array_class_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);
582   static InstanceKlass* handle_parallel_super_load(Symbol* class_name, Symbol* supername, Handle class_loader, Handle protection_domain, Handle lockObject, TRAPS);
583   // Wait on SystemDictionary_lock; unlocks lockObject before
584   // waiting; relocks lockObject with correct recursion count
585   // after waiting, but before reentering SystemDictionary_lock
586   // to preserve lock order semantics.
587   static void double_lock_wait(Handle lockObject, TRAPS);
588   static void define_instance_class(InstanceKlass* k, TRAPS);
589   static InstanceKlass* find_or_define_instance_class(Symbol* class_name,
590                                                 Handle class_loader,
591                                                 InstanceKlass* k, TRAPS);
592   static bool is_shared_class_visible(Symbol* class_name, InstanceKlass* ik,
593                                       Handle class_loader, TRAPS);





594   static InstanceKlass* load_shared_class(InstanceKlass* ik,
595                                           Handle class_loader,
596                                           Handle protection_domain,
597                                           const ClassFileStream *cfs,
598                                           TRAPS);


599   static InstanceKlass* load_shared_boot_class(Symbol* class_name,
600                                                TRAPS);
601   static InstanceKlass* load_instance_class(Symbol* class_name, Handle class_loader, TRAPS);
602   static Handle compute_loader_lock_object(Handle class_loader, TRAPS);
603   static void check_loader_lock_contention(Handle loader_lock, TRAPS);
604   static bool is_parallelCapable(Handle class_loader);
605   static bool is_parallelDefine(Handle class_loader);
606 
607 public:
608   static bool is_system_class_loader(oop class_loader);
609   static bool is_platform_class_loader(oop class_loader);
610 
611   // Returns TRUE if the method is a non-public member of class java.lang.Object.
612   static bool is_nonpublic_Object_method(Method* m) {
613     assert(m != NULL, &quot;Unexpected NULL Method*&quot;);
614     return !m-&gt;is_public() &amp;&amp; m-&gt;method_holder() == SystemDictionary::Object_klass();
615   }
616 
617 protected:
618   // Setup link to hierarchy
619   static void add_to_hierarchy(InstanceKlass* k, TRAPS);
620 
621   // Basic find on loaded classes
622   static InstanceKlass* find_class(unsigned int hash,
623                                    Symbol* name, Dictionary* dictionary);
624   static InstanceKlass* find_class(Symbol* class_name, ClassLoaderData* loader_data);
625 
626   // Basic find on classes in the midst of being loaded
627   static Symbol* find_placeholder(Symbol* name, ClassLoaderData* loader_data);
628 
629   // Resolve well-known classes so they can be used like SystemDictionary::String_klass()
630   static void resolve_well_known_classes(TRAPS);


631 
632   // Class loader constraints
633   static void check_constraints(unsigned int hash,
634                                 InstanceKlass* k, Handle loader,
635                                 bool defining, TRAPS);
636   static void update_dictionary(unsigned int d_hash,
637                                 int p_index, unsigned int p_hash,
638                                 InstanceKlass* k, Handle loader,
639                                 TRAPS);
640 
641   static InstanceKlass* _well_known_klasses[];
642 
643   // table of box klasses (int_klass, etc.)
644   static InstanceKlass* _box_klasses[T_VOID+1];
645 
646 private:
647   static oop  _java_system_loader;
648   static oop  _java_platform_loader;
649 
650 public:
</pre>
</td>
<td>
<hr />
<pre>
209   do_klass(Boolean_klass,                               java_lang_Boolean                                     ) \
210   do_klass(Character_klass,                             java_lang_Character                                   ) \
211   do_klass(Float_klass,                                 java_lang_Float                                       ) \
212   do_klass(Double_klass,                                java_lang_Double                                      ) \
213   do_klass(Byte_klass,                                  java_lang_Byte                                        ) \
214   do_klass(Short_klass,                                 java_lang_Short                                       ) \
215   do_klass(Integer_klass,                               java_lang_Integer                                     ) \
216   do_klass(Long_klass,                                  java_lang_Long                                        ) \
217                                                                                                                 \
218   /* force inline of iterators */                                                                               \
219   do_klass(Iterator_klass,                              java_util_Iterator                                    ) \
220                                                                                                                 \
221   /* support for records */                                                                                     \
222   do_klass(RecordComponent_klass,                       java_lang_reflect_RecordComponent                     ) \
223                                                                                                                 \
224   /*end*/
225 
226 class SystemDictionary : AllStatic {
227   friend class BootstrapInfo;
228   friend class VMStructs;

229 
230  public:
231   enum WKID {
232     NO_WKID = 0,
233 
234     #define WK_KLASS_ENUM(name, symbol) WK_KLASS_ENUM_NAME(name), WK_KLASS_ENUM_NAME(symbol) = WK_KLASS_ENUM_NAME(name),
235     WK_KLASSES_DO(WK_KLASS_ENUM)
236     #undef WK_KLASS_ENUM
237 
238     WKID_LIMIT,
239 
240     FIRST_WKID = NO_WKID + 1
241   };
242 
243   // Returns a class with a given class name and class loader.  Loads the
244   // class if needed. If not found a NoClassDefFoundError or a
245   // ClassNotFoundException is thrown, depending on the value on the
246   // throw_error flag.  For most uses the throw_error argument should be set
247   // to true.
248 
</pre>
<hr />
<pre>
369   // Verification
370   static void verify();
371 
372   // Initialization
373   static void initialize(TRAPS);
374 
375   // Checked fast access to the well-known classes -- so that you don&#39;t try to use them
376   // before they are resolved.
377   static InstanceKlass* check_klass(InstanceKlass* k) {
378     assert(k != NULL, &quot;klass not loaded&quot;);
379     return k;
380   }
381 
382   static bool resolve_wk_klass(WKID id, TRAPS);
383   static void resolve_wk_klasses_until(WKID limit_id, WKID &amp;start_id, TRAPS);
384   static void resolve_wk_klasses_through(WKID end_id, WKID &amp;start_id, TRAPS) {
385     int limit = (int)end_id + 1;
386     resolve_wk_klasses_until((WKID) limit, start_id, THREAD);
387   }
388 public:
<span class="line-added">389   #define WK_KLASS(name) _well_known_klasses[SystemDictionary::WK_KLASS_ENUM_NAME(name)]</span>
<span class="line-added">390 </span>
391   #define WK_KLASS_DECLARE(name, symbol) \
392     static InstanceKlass* name() { return check_klass(_well_known_klasses[WK_KLASS_ENUM_NAME(name)]); } \
393     static InstanceKlass** name##_addr() {                                                              \
394       return &amp;_well_known_klasses[SystemDictionary::WK_KLASS_ENUM_NAME(name)];                          \
395     }                                                                                                   \
396     static bool name##_is_loaded() {                                                                    \
<span class="line-modified">397       return is_wk_klass_loaded(WK_KLASS(name));                                                        \</span>
398     }
399   WK_KLASSES_DO(WK_KLASS_DECLARE);
400   #undef WK_KLASS_DECLARE
401 
402   static InstanceKlass* well_known_klass(WKID id) {
403     assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
404     return _well_known_klasses[id];
405   }
406 
407   static InstanceKlass** well_known_klass_addr(WKID id) {
408     assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
409     return &amp;_well_known_klasses[id];
410   }
411   static void well_known_klasses_do(MetaspaceClosure* it);
412 



413   static InstanceKlass* box_klass(BasicType t) {
414     assert((uint)t &lt; T_VOID+1, &quot;range check&quot;);
415     return check_klass(_box_klasses[t]);
416   }
417   static BasicType box_klass_type(Klass* k);  // inverse of box_klass
418 #ifdef ASSERT
419   static bool is_well_known_klass(Klass* k) {
420     return is_well_known_klass(k-&gt;name());
421   }
422   static bool is_well_known_klass(Symbol* class_name);
423 #endif
424 
425 protected:
426   // Returns the class loader data to be used when looking up/updating the
427   // system dictionary.
428   static ClassLoaderData *class_loader_data(Handle class_loader) {
429     return ClassLoaderData::class_loader_data(class_loader());
430   }
431 
<span class="line-added">432   static bool is_wk_klass_loaded(InstanceKlass* klass) {</span>
<span class="line-added">433     return !(klass == NULL || !klass-&gt;is_loaded());</span>
<span class="line-added">434   }</span>
<span class="line-added">435 </span>
436 public:
<span class="line-modified">437   static bool Object_klass_loaded()         { return is_wk_klass_loaded(WK_KLASS(Object_klass));             }</span>
<span class="line-modified">438   static bool Class_klass_loaded()          { return is_wk_klass_loaded(WK_KLASS(Class_klass));              }</span>
<span class="line-modified">439   static bool Cloneable_klass_loaded()      { return is_wk_klass_loaded(WK_KLASS(Cloneable_klass));          }</span>
<span class="line-modified">440   static bool Parameter_klass_loaded()      { return is_wk_klass_loaded(WK_KLASS(reflect_Parameter_klass));  }</span>
<span class="line-modified">441   static bool ClassLoader_klass_loaded()    { return is_wk_klass_loaded(WK_KLASS(ClassLoader_klass));        }</span>
442 
443   // Returns java system loader
444   static oop java_system_loader();
445 
446   // Returns java platform loader
447   static oop java_platform_loader();
448 
449   // Compute the java system and platform loaders
450   static void compute_java_loaders(TRAPS);
451 
452   // Register a new class loader
453   static ClassLoaderData* register_loader(Handle class_loader);
454 protected:
455   // Mirrors for primitive classes (created eagerly)
456   static oop check_mirror(oop m) {
457     assert(m != NULL, &quot;mirror not initialized&quot;);
458     return m;
459   }
460 
461 public:
</pre>
<hr />
<pre>
576 
577   // Basic loading operations
578   static InstanceKlass* resolve_instance_class_or_null_helper(Symbol* name,
579                                                               Handle class_loader,
580                                                               Handle protection_domain,
581                                                               TRAPS);
582   static InstanceKlass* resolve_instance_class_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);
583   static Klass* resolve_array_class_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);
584   static InstanceKlass* handle_parallel_super_load(Symbol* class_name, Symbol* supername, Handle class_loader, Handle protection_domain, Handle lockObject, TRAPS);
585   // Wait on SystemDictionary_lock; unlocks lockObject before
586   // waiting; relocks lockObject with correct recursion count
587   // after waiting, but before reentering SystemDictionary_lock
588   // to preserve lock order semantics.
589   static void double_lock_wait(Handle lockObject, TRAPS);
590   static void define_instance_class(InstanceKlass* k, TRAPS);
591   static InstanceKlass* find_or_define_instance_class(Symbol* class_name,
592                                                 Handle class_loader,
593                                                 InstanceKlass* k, TRAPS);
594   static bool is_shared_class_visible(Symbol* class_name, InstanceKlass* ik,
595                                       Handle class_loader, TRAPS);
<span class="line-added">596   static bool check_shared_class_super_type(InstanceKlass* child, InstanceKlass* super,</span>
<span class="line-added">597                                             Handle class_loader,  Handle protection_domain,</span>
<span class="line-added">598                                             bool is_superclass, TRAPS);</span>
<span class="line-added">599   static bool check_shared_class_super_types(InstanceKlass* ik, Handle class_loader,</span>
<span class="line-added">600                                                Handle protection_domain, TRAPS);</span>
601   static InstanceKlass* load_shared_class(InstanceKlass* ik,
602                                           Handle class_loader,
603                                           Handle protection_domain,
604                                           const ClassFileStream *cfs,
605                                           TRAPS);
<span class="line-added">606   // Second part of load_shared_class</span>
<span class="line-added">607   static void load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) NOT_CDS_RETURN;</span>
608   static InstanceKlass* load_shared_boot_class(Symbol* class_name,
609                                                TRAPS);
610   static InstanceKlass* load_instance_class(Symbol* class_name, Handle class_loader, TRAPS);
611   static Handle compute_loader_lock_object(Handle class_loader, TRAPS);
612   static void check_loader_lock_contention(Handle loader_lock, TRAPS);
613   static bool is_parallelCapable(Handle class_loader);
614   static bool is_parallelDefine(Handle class_loader);
615 
616 public:
617   static bool is_system_class_loader(oop class_loader);
618   static bool is_platform_class_loader(oop class_loader);
619 
620   // Returns TRUE if the method is a non-public member of class java.lang.Object.
621   static bool is_nonpublic_Object_method(Method* m) {
622     assert(m != NULL, &quot;Unexpected NULL Method*&quot;);
623     return !m-&gt;is_public() &amp;&amp; m-&gt;method_holder() == SystemDictionary::Object_klass();
624   }
625 
626 protected:
627   // Setup link to hierarchy
628   static void add_to_hierarchy(InstanceKlass* k, TRAPS);
629 
630   // Basic find on loaded classes
631   static InstanceKlass* find_class(unsigned int hash,
632                                    Symbol* name, Dictionary* dictionary);
633   static InstanceKlass* find_class(Symbol* class_name, ClassLoaderData* loader_data);
634 
635   // Basic find on classes in the midst of being loaded
636   static Symbol* find_placeholder(Symbol* name, ClassLoaderData* loader_data);
637 
638   // Resolve well-known classes so they can be used like SystemDictionary::String_klass()
639   static void resolve_well_known_classes(TRAPS);
<span class="line-added">640   // quick resolve using CDS for well-known classes only.</span>
<span class="line-added">641   static void quick_resolve(InstanceKlass* klass, ClassLoaderData* loader_data, Handle domain, TRAPS) NOT_CDS_RETURN;</span>
642 
643   // Class loader constraints
644   static void check_constraints(unsigned int hash,
645                                 InstanceKlass* k, Handle loader,
646                                 bool defining, TRAPS);
647   static void update_dictionary(unsigned int d_hash,
648                                 int p_index, unsigned int p_hash,
649                                 InstanceKlass* k, Handle loader,
650                                 TRAPS);
651 
652   static InstanceKlass* _well_known_klasses[];
653 
654   // table of box klasses (int_klass, etc.)
655   static InstanceKlass* _box_klasses[T_VOID+1];
656 
657 private:
658   static oop  _java_system_loader;
659   static oop  _java_platform_loader;
660 
661 public:
</pre>
</td>
</tr>
</table>
<center><a href="systemDictionary.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionaryShared.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
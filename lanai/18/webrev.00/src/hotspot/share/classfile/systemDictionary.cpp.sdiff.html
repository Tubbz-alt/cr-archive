<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/systemDictionary.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="symbolTable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/systemDictionary.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 952 
 953 // Look for a loaded instance or array klass by name.  Do not do any loading.
 954 // return NULL in case of error.
 955 Klass* SystemDictionary::find_instance_or_array_klass(Symbol* class_name,
 956                                                       Handle class_loader,
 957                                                       Handle protection_domain,
 958                                                       TRAPS) {
 959   Klass* k = NULL;
 960   assert(class_name != NULL, &quot;class name must be non NULL&quot;);
 961 
 962   if (Signature::is_array(class_name)) {
 963     // The name refers to an array.  Parse the name.
 964     // dimension and object_key in FieldArrayInfo are assigned as a
 965     // side-effect of this call
 966     SignatureStream ss(class_name, false);
 967     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
 968     BasicType t = ss.type();
 969     if (t != T_OBJECT) {
 970       k = Universe::typeArrayKlassObj(t);
 971     } else {
<span class="line-modified"> 972       Symbol* obj_class = ss.as_symbol();</span>
<span class="line-removed"> 973       k = SystemDictionary::find(obj_class, class_loader, protection_domain, THREAD);</span>
 974     }
 975     if (k != NULL) {
 976       k = k-&gt;array_klass_or_null(ndims);
 977     }
 978   } else {
 979     k = find(class_name, class_loader, protection_domain, THREAD);
 980   }
 981   return k;
 982 }
 983 
 984 // Note: this method is much like resolve_from_stream, but
 985 // does not publish the classes via the SystemDictionary.
 986 // Handles unsafe_DefineAnonymousClass and redefineclasses
 987 // RedefinedClasses do not add to the class hierarchy
 988 InstanceKlass* SystemDictionary::parse_stream(Symbol* class_name,
 989                                               Handle class_loader,
 990                                               Handle protection_domain,
 991                                               ClassFileStream* st,
 992                                               const InstanceKlass* unsafe_anonymous_host,
 993                                               GrowableArray&lt;Handle&gt;* cp_patches,
</pre>
<hr />
<pre>
1239     // 3. or, the class is from an unamed module
1240     if (!ent-&gt;is_modules_image() &amp;&amp; ik-&gt;is_shared_boot_class()) {
1241       // the class is from the -Xbootclasspath/a
1242       if (pkg_name == NULL ||
1243           pkg_entry == NULL ||
1244           pkg_entry-&gt;in_unnamed_module()) {
1245         assert(mod_entry == NULL ||
1246                mod_entry == loader_data-&gt;unnamed_module(),
1247                &quot;the unnamed module is not defined in the classloader&quot;);
1248         return true;
1249       }
1250     }
1251     return false;
1252   } else {
1253     bool res = SystemDictionaryShared::is_shared_class_visible_for_classloader(
1254               ik, class_loader, pkg_name, pkg_entry, mod_entry, CHECK_(false));
1255     return res;
1256   }
1257 }
1258 
<span class="line-modified">1259 InstanceKlass* SystemDictionary::load_shared_class(InstanceKlass* ik,</span>
<span class="line-modified">1260                                                    Handle class_loader,</span>
<span class="line-modified">1261                                                    Handle protection_domain,</span>
<span class="line-modified">1262                                                    const ClassFileStream *cfs,</span>
<span class="line-removed">1263                                                    TRAPS) {</span>
<span class="line-removed">1264   assert(ik != NULL, &quot;sanity&quot;);</span>
<span class="line-removed">1265   assert(!ik-&gt;is_unshareable_info_restored(), &quot;shared class can be loaded only once&quot;);</span>
<span class="line-removed">1266   Symbol* class_name = ik-&gt;name();</span>
1267 
<span class="line-modified">1268   bool visible = is_shared_class_visible(</span>
<span class="line-modified">1269                           class_name, ik, class_loader, CHECK_NULL);</span>
<span class="line-modified">1270   if (!visible) {</span>
<span class="line-modified">1271     return NULL;</span>




1272   }

1273 
<span class="line-modified">1274   // Resolve the superclass and interfaces. They must be the same</span>


1275   // as in dump time, because the layout of &lt;ik&gt; depends on
1276   // the specific layout of ik-&gt;super() and ik-&gt;local_interfaces().
1277   //
1278   // If unexpected superclass or interfaces are found, we cannot
1279   // load &lt;ik&gt; from the shared archive.
1280 
<span class="line-modified">1281   if (ik-&gt;super() != NULL) {</span>
<span class="line-modified">1282     Symbol*  cn = ik-&gt;super()-&gt;name();</span>
<span class="line-modified">1283     Klass *s = resolve_super_or_fail(class_name, cn,</span>
<span class="line-modified">1284                                      class_loader, protection_domain, true, CHECK_NULL);</span>
<span class="line-removed">1285     if (s != ik-&gt;super()) {</span>
<span class="line-removed">1286       // The dynamically resolved super class is not the same as the one we used during dump time,</span>
<span class="line-removed">1287       // so we cannot use ik.</span>
<span class="line-removed">1288       return NULL;</span>
<span class="line-removed">1289     } else {</span>
<span class="line-removed">1290       assert(s-&gt;is_shared(), &quot;must be&quot;);</span>
<span class="line-removed">1291     }</span>
1292   }
1293 
1294   Array&lt;InstanceKlass*&gt;* interfaces = ik-&gt;local_interfaces();
1295   int num_interfaces = interfaces-&gt;length();
1296   for (int index = 0; index &lt; num_interfaces; index++) {
<span class="line-modified">1297     InstanceKlass* k = interfaces-&gt;at(index);</span>
<span class="line-modified">1298     Symbol* name  = k-&gt;name();</span>
<span class="line-removed">1299     Klass* i = resolve_super_or_fail(class_name, name, class_loader, protection_domain, false, CHECK_NULL);</span>
<span class="line-removed">1300     if (k != i) {</span>
<span class="line-removed">1301       // The dynamically resolved interface class is not the same as the one we used during dump time,</span>
<span class="line-removed">1302       // so we cannot use ik.</span>
<span class="line-removed">1303       return NULL;</span>
<span class="line-removed">1304     } else {</span>
<span class="line-removed">1305       assert(i-&gt;is_shared(), &quot;must be&quot;);</span>
1306     }
1307   }
1308 






















1309   InstanceKlass* new_ik = KlassFactory::check_shared_class_file_load_hook(
1310       ik, class_name, class_loader, protection_domain, cfs, CHECK_NULL);
1311   if (new_ik != NULL) {
1312     // The class is changed by CFLH. Return the new class. The shared class is
1313     // not used.
1314     return new_ik;
1315   }
1316 
1317   // Adjust methods to recover missing data.  They need addresses for
1318   // interpreter entry points and their default native method address
1319   // must be reset.
1320 
1321   // Updating methods must be done under a lock so multiple
1322   // threads don&#39;t update these in parallel
1323   //
1324   // Shared classes are all currently loaded by either the bootstrap or
1325   // internal parallel class loaders, so this will never cause a deadlock
1326   // on a custom class loader lock.
1327 
1328   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());
1329   {
1330     HandleMark hm(THREAD);
1331     Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
1332     check_loader_lock_contention(lockObject, THREAD);
1333     ObjectLocker ol(lockObject, THREAD, true);
1334     // prohibited package check assumes all classes loaded from archive call
1335     // restore_unshareable_info which calls ik-&gt;set_package()
1336     ik-&gt;restore_unshareable_info(loader_data, protection_domain, CHECK_NULL);
1337   }
1338 





1339   ik-&gt;print_class_load_logging(loader_data, NULL, NULL);
1340 
1341   // For boot loader, ensure that GetSystemPackage knows that a class in this
1342   // package was loaded.
<span class="line-modified">1343   if (class_loader.is_null()) {</span>
1344     int path_index = ik-&gt;shared_classpath_index();
1345     ResourceMark rm(THREAD);
1346     ClassLoader::add_package(ik-&gt;name()-&gt;as_C_string(), path_index, THREAD);
1347   }
1348 
1349   if (DumpLoadedClassList != NULL &amp;&amp; classlist_file-&gt;is_open()) {
1350     // Only dump the classes that can be stored into CDS archive
1351     if (SystemDictionaryShared::is_sharing_possible(loader_data)) {
1352       ResourceMark rm(THREAD);
1353       classlist_file-&gt;print_cr(&quot;%s&quot;, ik-&gt;name()-&gt;as_C_string());
1354       classlist_file-&gt;flush();
1355     }
1356   }
1357 
1358   // notify a class loaded from shared object
1359   ClassLoadingService::notify_class_loaded(ik, true /* shared class */);
1360 
1361   ik-&gt;set_has_passed_fingerprint_check(false);
1362   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
1363     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
1364     uint64_t cds_fp = ik-&gt;get_stored_fingerprint();
1365     if (aot_fp != 0 &amp;&amp; aot_fp == cds_fp) {
1366       // This class matches with a class saved in an AOT library
1367       ik-&gt;set_has_passed_fingerprint_check(true);
1368     } else {
1369       if (log_is_enabled(Info, class, fingerprint)) {
1370         ResourceMark rm(THREAD);
1371         log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT, ik-&gt;external_name(), aot_fp, cds_fp);
1372       }
1373     }
1374   }

1375 
<span class="line-modified">1376   return ik;</span>




























1377 }
1378 #endif // INCLUDE_CDS
1379 
1380 InstanceKlass* SystemDictionary::load_instance_class(Symbol* class_name, Handle class_loader, TRAPS) {
1381 
1382   if (class_loader.is_null()) {
1383     ResourceMark rm(THREAD);
1384     PackageEntry* pkg_entry = NULL;
1385     bool search_only_bootloader_append = false;
1386     ClassLoaderData *loader_data = class_loader_data(class_loader);
1387 
1388     // Find the package in the boot loader&#39;s package entry table.
1389     TempNewSymbol pkg_name = InstanceKlass::package_from_name(class_name, CHECK_NULL);
1390     if (pkg_name != NULL) {
1391       pkg_entry = loader_data-&gt;packages()-&gt;lookup_only(pkg_name);
1392     }
1393 
1394     // Prior to attempting to load the class, enforce the boot loader&#39;s
1395     // visibility boundaries.
1396     if (!Universe::is_module_initialized()) {
</pre>
<hr />
<pre>
1768   guarantee(VerifyBeforeGC      ||
1769             VerifyDuringGC      ||
1770             VerifyBeforeExit    ||
1771             VerifyDuringStartup ||
1772             VerifyAfterGC, &quot;too expensive&quot;);
1773   #endif
1774 
1775   Dictionary* dictionary = loader_data-&gt;dictionary();
1776   unsigned int d_hash = dictionary-&gt;compute_hash(class_name);
1777   return find_class(d_hash, class_name, dictionary);
1778 }
1779 
1780 
1781 // ----------------------------------------------------------------------------
1782 // Update hierachy. This is done before the new klass has been added to the SystemDictionary. The Recompile_lock
1783 // is held, to ensure that the compiler is not using the class hierachy, and that deoptimization will kick in
1784 // before a new class is used.
1785 
1786 void SystemDictionary::add_to_hierarchy(InstanceKlass* k, TRAPS) {
1787   assert(k != NULL, &quot;just checking&quot;);
<span class="line-modified">1788   assert_locked_or_safepoint(Compile_lock);</span>


1789 
1790   k-&gt;set_init_state(InstanceKlass::loaded);
1791   // make sure init_state store is already done.
1792   // The compiler reads the hierarchy outside of the Compile_lock.
1793   // Access ordering is used to add to hierarchy.
1794 
1795   // Link into hierachy.
1796   k-&gt;append_to_sibling_list();                    // add to superklass/sibling list
1797   k-&gt;process_interfaces(THREAD);                  // handle all &quot;implements&quot; declarations
1798 
1799   // Now flush all code that depended on old class hierarchy.
1800   // Note: must be done *after* linking k into the hierarchy (was bug 12/9/97)
<span class="line-modified">1801   CodeCache::flush_dependents_on(k);</span>


1802 }
1803 
1804 // ----------------------------------------------------------------------------
1805 // GC support
1806 
1807 // Assumes classes in the SystemDictionary are only unloaded at a safepoint
1808 // Note: anonymous classes are not in the SD.
1809 bool SystemDictionary::do_unloading(GCTimer* gc_timer) {
1810 
1811   bool unloading_occurred;
1812   bool is_concurrent = !SafepointSynchronize::is_at_safepoint();
1813   {
1814     GCTraceTime(Debug, gc, phases) t(&quot;ClassLoaderData&quot;, gc_timer);
1815     assert_locked_or_safepoint(ClassLoaderDataGraph_lock);  // caller locks.
1816     // First, mark for unload all ClassLoaderData referencing a dead class loader.
1817     unloading_occurred = ClassLoaderDataGraph::do_unloading();
1818     if (unloading_occurred) {
1819       MutexLocker ml2(is_concurrent ? Module_lock : NULL);
1820       JFR_ONLY(Jfr::on_unloading_classes();)
1821 
</pre>
<hr />
<pre>
1900 
1901 #ifdef ASSERT
1902 bool SystemDictionary::is_well_known_klass(Symbol* class_name) {
1903   int sid;
1904   for (int i = 0; (sid = wk_init_info[i]) != 0; i++) {
1905     Symbol* symbol = vmSymbols::symbol_at((vmSymbols::SID)sid);
1906     if (class_name == symbol) {
1907       return true;
1908     }
1909   }
1910   return false;
1911 }
1912 #endif
1913 
1914 bool SystemDictionary::resolve_wk_klass(WKID id, TRAPS) {
1915   assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
1916   int sid = wk_init_info[id - FIRST_WKID];
1917   Symbol* symbol = vmSymbols::symbol_at((vmSymbols::SID)sid);
1918   InstanceKlass** klassp = &amp;_well_known_klasses[id];
1919 
<span class="line-modified">1920   if ((*klassp) == NULL) {</span>
<span class="line-modified">1921     Klass* k = resolve_or_fail(symbol, true, CHECK_0);</span>











1922     (*klassp) = InstanceKlass::cast(k);
1923   }
1924   return ((*klassp) != NULL);
1925 }
1926 
1927 void SystemDictionary::resolve_wk_klasses_until(WKID limit_id, WKID &amp;start_id, TRAPS) {
1928   assert((int)start_id &lt;= (int)limit_id, &quot;IDs are out of order!&quot;);
1929   for (int id = (int)start_id; id &lt; (int)limit_id; id++) {
1930     assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
1931     resolve_wk_klass((WKID)id, CHECK);
1932   }
1933 
1934   // move the starting value forward to the limit:
1935   start_id = limit_id;
1936 }
1937 
1938 void SystemDictionary::resolve_well_known_classes(TRAPS) {
<span class="line-modified">1939   assert(WK_KLASS(Object_klass) == NULL, &quot;well-known classes should only be initialized once&quot;);</span>
1940 
1941   // Create the ModuleEntry for java.base.  This call needs to be done here,
1942   // after vmSymbols::initialize() is called but before any classes are pre-loaded.
1943   ClassLoader::classLoader_init2(CHECK);
1944 
1945   // Preload commonly used klasses
1946   WKID scan = FIRST_WKID;
1947   // first do Object, then String, Class
1948 #if INCLUDE_CDS
1949   if (UseSharedSpaces) {
1950     resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Object_klass), scan, CHECK);
1951 
1952     // It&#39;s unsafe to access the archived heap regions before they
1953     // are fixed up, so we must do the fixup as early as possible
1954     // before the archived java objects are accessed by functions
1955     // such as java_lang_Class::restore_archived_mirror and
1956     // ConstantPool::restore_unshareable_info (restores the archived
1957     // resolved_references array object).
1958     //
1959     // HeapShared::fixup_mapped_heap_regions() fills the empty
</pre>
<hr />
<pre>
1967     // Initialize the constant pool for the Object_class
1968     assert(Object_klass()-&gt;is_shared(), &quot;must be&quot;);
1969     Object_klass()-&gt;constants()-&gt;restore_unshareable_info(CHECK);
1970     resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Class_klass), scan, CHECK);
1971   } else
1972 #endif
1973   {
1974     resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Class_klass), scan, CHECK);
1975   }
1976 
1977   assert(WK_KLASS(Object_klass) != NULL, &quot;well-known classes should now be initialized&quot;);
1978 
1979   java_lang_Object::register_natives(CHECK);
1980 
1981   // Calculate offsets for String and Class classes since they are loaded and
1982   // can be used after this point.
1983   java_lang_String::compute_offsets();
1984   java_lang_Class::compute_offsets();
1985 
1986   // Fixup mirrors for classes loaded before java.lang.Class.
<span class="line-removed">1987   // These calls iterate over the objects currently in the perm gen</span>
<span class="line-removed">1988   // so calling them at this point is matters (not before when there</span>
<span class="line-removed">1989   // are fewer objects and not later after there are more objects</span>
<span class="line-removed">1990   // in the perm gen.</span>
1991   Universe::initialize_basic_type_mirrors(CHECK);
1992   Universe::fixup_mirrors(CHECK);
1993 
1994   // do a bunch more:
1995   resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Reference_klass), scan, CHECK);
1996 
1997   // Preload ref klasses and set reference types
1998   WK_KLASS(Reference_klass)-&gt;set_reference_type(REF_OTHER);
1999   InstanceRefKlass::update_nonstatic_oop_maps(WK_KLASS(Reference_klass));
2000 
2001   resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(PhantomReference_klass), scan, CHECK);
2002   WK_KLASS(SoftReference_klass)-&gt;set_reference_type(REF_SOFT);
2003   WK_KLASS(WeakReference_klass)-&gt;set_reference_type(REF_WEAK);
2004   WK_KLASS(FinalReference_klass)-&gt;set_reference_type(REF_FINAL);
2005   WK_KLASS(PhantomReference_klass)-&gt;set_reference_type(REF_PHANTOM);
2006 
2007   // JSR 292 classes
2008   WKID jsr292_group_start = WK_KLASS_ENUM_NAME(MethodHandle_klass);
2009   WKID jsr292_group_end   = WK_KLASS_ENUM_NAME(VolatileCallSite_klass);
2010   resolve_wk_klasses_until(jsr292_group_start, scan, CHECK);
2011   resolve_wk_klasses_through(jsr292_group_end, scan, CHECK);
2012   WKID last = WKID_LIMIT;
2013   resolve_wk_klasses_until(last, scan, CHECK);
2014 
2015   _box_klasses[T_BOOLEAN] = WK_KLASS(Boolean_klass);
2016   _box_klasses[T_CHAR]    = WK_KLASS(Character_klass);
2017   _box_klasses[T_FLOAT]   = WK_KLASS(Float_klass);
2018   _box_klasses[T_DOUBLE]  = WK_KLASS(Double_klass);
2019   _box_klasses[T_BYTE]    = WK_KLASS(Byte_klass);
2020   _box_klasses[T_SHORT]   = WK_KLASS(Short_klass);
2021   _box_klasses[T_INT]     = WK_KLASS(Integer_klass);
2022   _box_klasses[T_LONG]    = WK_KLASS(Long_klass);
2023   //_box_klasses[T_OBJECT]  = WK_KLASS(object_klass);
2024   //_box_klasses[T_ARRAY]   = WK_KLASS(object_klass);
2025 
2026 #ifdef ASSERT
2027   if (UseSharedSpaces) {
<span class="line-modified">2028     assert(JvmtiExport::is_early_phase(),</span>
<span class="line-modified">2029            &quot;All well known classes must be resolved in JVMTI early phase&quot;);</span>
2030     for (int i = FIRST_WKID; i &lt; last; i++) {
2031       InstanceKlass* k = _well_known_klasses[i];
2032       assert(k-&gt;is_shared(), &quot;must not be replaced by JVMTI class file load hook&quot;);
2033     }
2034   }
2035 #endif
2036 }
2037 
2038 // Tells if a given klass is a box (wrapper class, such as java.lang.Integer).
2039 // If so, returns the basic type it holds.  If not, returns T_OBJECT.
2040 BasicType SystemDictionary::box_klass_type(Klass* k) {
2041   assert(k != NULL, &quot;&quot;);
2042   for (int i = T_BOOLEAN; i &lt; T_VOID+1; i++) {
2043     if (_box_klasses[i] == k)
2044       return (BasicType)i;
2045   }
2046   return T_OBJECT;
2047 }
2048 
2049 // Constraints on class loaders. The details of the algorithm can be
</pre>
<hr />
<pre>
2465 
2466 // Decide if we can globally cache a lookup of this class, to be returned to any client that asks.
2467 // We must ensure that all class loaders everywhere will reach this class, for any client.
2468 // This is a safe bet for public classes in java.lang, such as Object and String.
2469 // We also include public classes in java.lang.invoke, because they appear frequently in system-level method types.
2470 // Out of an abundance of caution, we do not include any other classes, not even for packages like java.util.
2471 static bool is_always_visible_class(oop mirror) {
2472   Klass* klass = java_lang_Class::as_Klass(mirror);
2473   if (klass-&gt;is_objArray_klass()) {
2474     klass = ObjArrayKlass::cast(klass)-&gt;bottom_klass(); // check element type
2475   }
2476   if (klass-&gt;is_typeArray_klass()) {
2477     return true; // primitive array
2478   }
2479   assert(klass-&gt;is_instance_klass(), &quot;%s&quot;, klass-&gt;external_name());
2480   return klass-&gt;is_public() &amp;&amp;
2481          (InstanceKlass::cast(klass)-&gt;is_same_class_package(SystemDictionary::Object_klass()) ||       // java.lang
2482           InstanceKlass::cast(klass)-&gt;is_same_class_package(SystemDictionary::MethodHandle_klass()));  // java.lang.invoke
2483 }
2484 
<span class="line-modified">2485 // Find or construct the Java mirror (java.lang.Class instance) for a</span>
<span class="line-modified">2486 // for the given field type signature, as interpreted relative to the</span>
2487 // given class loader.  Handles primitives, void, references, arrays,
2488 // and all other reflectable types, except method types.
2489 // N.B.  Code in reflection should use this entry point.
2490 Handle SystemDictionary::find_java_mirror_for_type(Symbol* signature,
2491                                                    Klass* accessing_klass,
2492                                                    Handle class_loader,
2493                                                    Handle protection_domain,
2494                                                    SignatureStream::FailureMode failure_mode,
2495                                                    TRAPS) {
<span class="line-removed">2496   Handle empty;</span>
<span class="line-removed">2497 </span>
2498   assert(accessing_klass == NULL || (class_loader.is_null() &amp;&amp; protection_domain.is_null()),
2499          &quot;one or the other, or perhaps neither&quot;);
2500 
<span class="line-removed">2501   SignatureStream ss(signature, false);</span>
<span class="line-removed">2502 </span>
2503   // What we have here must be a valid field descriptor,
2504   // and all valid field descriptors are supported.
2505   // Produce the same java.lang.Class that reflection reports.
<span class="line-modified">2506   if (ss.is_primitive() || (ss.type() == T_VOID)) {</span>
<span class="line-modified">2507 </span>
<span class="line-modified">2508     // It&#39;s a primitive.  (Void has a primitive mirror too.)</span>
<span class="line-modified">2509     return Handle(THREAD, java_lang_Class::primitive_mirror(ss.type()));</span>
<span class="line-modified">2510 </span>
<span class="line-modified">2511   } else if (ss.is_reference()) {</span>
<span class="line-modified">2512 </span>
<span class="line-modified">2513     // It&#39;s a reference type.</span>
<span class="line-modified">2514     if (accessing_klass != NULL) {</span>
<span class="line-modified">2515       class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());</span>
<span class="line-removed">2516       protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());</span>
<span class="line-removed">2517     }</span>
<span class="line-removed">2518     Klass* constant_type_klass;</span>
<span class="line-removed">2519     if (failure_mode == SignatureStream::ReturnNull) {</span>
<span class="line-removed">2520       constant_type_klass = resolve_or_null(signature, class_loader, protection_domain,</span>
<span class="line-removed">2521                                             CHECK_(empty));</span>
<span class="line-removed">2522     } else {</span>
<span class="line-removed">2523       bool throw_error = (failure_mode == SignatureStream::NCDFError);</span>
<span class="line-removed">2524       constant_type_klass = resolve_or_fail(signature, class_loader, protection_domain,</span>
<span class="line-removed">2525                                             throw_error, CHECK_(empty));</span>
<span class="line-removed">2526     }</span>
<span class="line-removed">2527     if (constant_type_klass == NULL) {</span>
<span class="line-removed">2528       return Handle();  // report failure this way</span>
<span class="line-removed">2529     }</span>
<span class="line-removed">2530     Handle mirror(THREAD, constant_type_klass-&gt;java_mirror());</span>
2531 

2532     // Check accessibility, emulating ConstantPool::verify_constant_pool_resolve.
<span class="line-modified">2533     if (accessing_klass != NULL) {</span>
<span class="line-modified">2534       Klass* sel_klass = constant_type_klass;</span>
2535       bool fold_type_to_class = true;
2536       LinkResolver::check_klass_accessability(accessing_klass, sel_klass,
<span class="line-modified">2537                                               fold_type_to_class, CHECK_(empty));</span>
2538     }
<span class="line-removed">2539 </span>
<span class="line-removed">2540     return mirror;</span>
<span class="line-removed">2541 </span>
2542   }
<span class="line-modified">2543 </span>
<span class="line-removed">2544   // Fall through to an error.</span>
<span class="line-removed">2545   assert(false, &quot;unsupported mirror syntax&quot;);</span>
<span class="line-removed">2546   THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;unsupported mirror syntax&quot;, empty);</span>
2547 }
2548 
2549 
2550 // Ask Java code to find or construct a java.lang.invoke.MethodType for the given
2551 // signature, as interpreted relative to the given class loader.
2552 // Because of class loader constraints, all method handle usage must be
2553 // consistent with this loader.
2554 Handle SystemDictionary::find_method_handle_type(Symbol* signature,
2555                                                  Klass* accessing_klass,
2556                                                  TRAPS) {
2557   Handle empty;
2558   vmIntrinsics::ID null_iid = vmIntrinsics::_none;  // distinct from all method handle invoker intrinsics
2559   unsigned int hash  = invoke_method_table()-&gt;compute_hash(signature, null_iid);
2560   int          index = invoke_method_table()-&gt;hash_to_index(hash);
2561   SymbolPropertyEntry* spe = invoke_method_table()-&gt;find_entry(index, hash, signature, null_iid);
2562   if (spe != NULL &amp;&amp; spe-&gt;method_type() != NULL) {
2563     assert(java_lang_invoke_MethodType::is_instance(spe-&gt;method_type()), &quot;&quot;);
2564     return Handle(THREAD, spe-&gt;method_type());
2565   } else if (!THREAD-&gt;can_call_java()) {
2566     warning(&quot;SystemDictionary::find_method_handle_type called from compiler thread&quot;);  // FIXME
</pre>
</td>
<td>
<hr />
<pre>
 952 
 953 // Look for a loaded instance or array klass by name.  Do not do any loading.
 954 // return NULL in case of error.
 955 Klass* SystemDictionary::find_instance_or_array_klass(Symbol* class_name,
 956                                                       Handle class_loader,
 957                                                       Handle protection_domain,
 958                                                       TRAPS) {
 959   Klass* k = NULL;
 960   assert(class_name != NULL, &quot;class name must be non NULL&quot;);
 961 
 962   if (Signature::is_array(class_name)) {
 963     // The name refers to an array.  Parse the name.
 964     // dimension and object_key in FieldArrayInfo are assigned as a
 965     // side-effect of this call
 966     SignatureStream ss(class_name, false);
 967     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
 968     BasicType t = ss.type();
 969     if (t != T_OBJECT) {
 970       k = Universe::typeArrayKlassObj(t);
 971     } else {
<span class="line-modified"> 972       k = SystemDictionary::find(ss.as_symbol(), class_loader, protection_domain, THREAD);</span>

 973     }
 974     if (k != NULL) {
 975       k = k-&gt;array_klass_or_null(ndims);
 976     }
 977   } else {
 978     k = find(class_name, class_loader, protection_domain, THREAD);
 979   }
 980   return k;
 981 }
 982 
 983 // Note: this method is much like resolve_from_stream, but
 984 // does not publish the classes via the SystemDictionary.
 985 // Handles unsafe_DefineAnonymousClass and redefineclasses
 986 // RedefinedClasses do not add to the class hierarchy
 987 InstanceKlass* SystemDictionary::parse_stream(Symbol* class_name,
 988                                               Handle class_loader,
 989                                               Handle protection_domain,
 990                                               ClassFileStream* st,
 991                                               const InstanceKlass* unsafe_anonymous_host,
 992                                               GrowableArray&lt;Handle&gt;* cp_patches,
</pre>
<hr />
<pre>
1238     // 3. or, the class is from an unamed module
1239     if (!ent-&gt;is_modules_image() &amp;&amp; ik-&gt;is_shared_boot_class()) {
1240       // the class is from the -Xbootclasspath/a
1241       if (pkg_name == NULL ||
1242           pkg_entry == NULL ||
1243           pkg_entry-&gt;in_unnamed_module()) {
1244         assert(mod_entry == NULL ||
1245                mod_entry == loader_data-&gt;unnamed_module(),
1246                &quot;the unnamed module is not defined in the classloader&quot;);
1247         return true;
1248       }
1249     }
1250     return false;
1251   } else {
1252     bool res = SystemDictionaryShared::is_shared_class_visible_for_classloader(
1253               ik, class_loader, pkg_name, pkg_entry, mod_entry, CHECK_(false));
1254     return res;
1255   }
1256 }
1257 
<span class="line-modified">1258 bool SystemDictionary::check_shared_class_super_type(InstanceKlass* child, InstanceKlass* super_type,</span>
<span class="line-modified">1259                                                      Handle class_loader,  Handle protection_domain,</span>
<span class="line-modified">1260                                                      bool is_superclass, TRAPS) {</span>
<span class="line-modified">1261   assert(super_type-&gt;is_shared(), &quot;must be&quot;);</span>




1262 
<span class="line-modified">1263   Klass *found = resolve_super_or_fail(child-&gt;name(), super_type-&gt;name(),</span>
<span class="line-modified">1264                                        class_loader, protection_domain, is_superclass, CHECK_0);</span>
<span class="line-modified">1265   if (found == super_type) {</span>
<span class="line-modified">1266     return true;</span>
<span class="line-added">1267   } else {</span>
<span class="line-added">1268     // The dynamically resolved super type is not the same as the one we used during dump time,</span>
<span class="line-added">1269     // so we cannot use the child class.</span>
<span class="line-added">1270     return false;</span>
1271   }
<span class="line-added">1272 }</span>
1273 
<span class="line-modified">1274 bool SystemDictionary::check_shared_class_super_types(InstanceKlass* ik, Handle class_loader,</span>
<span class="line-added">1275                                                       Handle protection_domain, TRAPS) {</span>
<span class="line-added">1276   // Check the superclass and interfaces. They must be the same</span>
1277   // as in dump time, because the layout of &lt;ik&gt; depends on
1278   // the specific layout of ik-&gt;super() and ik-&gt;local_interfaces().
1279   //
1280   // If unexpected superclass or interfaces are found, we cannot
1281   // load &lt;ik&gt; from the shared archive.
1282 
<span class="line-modified">1283   if (ik-&gt;super() != NULL &amp;&amp;</span>
<span class="line-modified">1284       !check_shared_class_super_type(ik, InstanceKlass::cast(ik-&gt;super()),</span>
<span class="line-modified">1285                                      class_loader, protection_domain, true, THREAD)) {</span>
<span class="line-modified">1286     return false;</span>







1287   }
1288 
1289   Array&lt;InstanceKlass*&gt;* interfaces = ik-&gt;local_interfaces();
1290   int num_interfaces = interfaces-&gt;length();
1291   for (int index = 0; index &lt; num_interfaces; index++) {
<span class="line-modified">1292     if (!check_shared_class_super_type(ik, interfaces-&gt;at(index), class_loader, protection_domain, false, THREAD)) {</span>
<span class="line-modified">1293       return false;</span>







1294     }
1295   }
1296 
<span class="line-added">1297   return true;</span>
<span class="line-added">1298 }</span>
<span class="line-added">1299 </span>
<span class="line-added">1300 InstanceKlass* SystemDictionary::load_shared_class(InstanceKlass* ik,</span>
<span class="line-added">1301                                                    Handle class_loader,</span>
<span class="line-added">1302                                                    Handle protection_domain,</span>
<span class="line-added">1303                                                    const ClassFileStream *cfs,</span>
<span class="line-added">1304                                                    TRAPS) {</span>
<span class="line-added">1305   assert(ik != NULL, &quot;sanity&quot;);</span>
<span class="line-added">1306   assert(!ik-&gt;is_unshareable_info_restored(), &quot;shared class can be loaded only once&quot;);</span>
<span class="line-added">1307   Symbol* class_name = ik-&gt;name();</span>
<span class="line-added">1308 </span>
<span class="line-added">1309   bool visible = is_shared_class_visible(</span>
<span class="line-added">1310                           class_name, ik, class_loader, CHECK_NULL);</span>
<span class="line-added">1311   if (!visible) {</span>
<span class="line-added">1312     return NULL;</span>
<span class="line-added">1313   }</span>
<span class="line-added">1314 </span>
<span class="line-added">1315   if (!check_shared_class_super_types(ik, class_loader, protection_domain, THREAD)) {</span>
<span class="line-added">1316     return NULL;</span>
<span class="line-added">1317   }</span>
<span class="line-added">1318 </span>
1319   InstanceKlass* new_ik = KlassFactory::check_shared_class_file_load_hook(
1320       ik, class_name, class_loader, protection_domain, cfs, CHECK_NULL);
1321   if (new_ik != NULL) {
1322     // The class is changed by CFLH. Return the new class. The shared class is
1323     // not used.
1324     return new_ik;
1325   }
1326 
1327   // Adjust methods to recover missing data.  They need addresses for
1328   // interpreter entry points and their default native method address
1329   // must be reset.
1330 
1331   // Updating methods must be done under a lock so multiple
1332   // threads don&#39;t update these in parallel
1333   //
1334   // Shared classes are all currently loaded by either the bootstrap or
1335   // internal parallel class loaders, so this will never cause a deadlock
1336   // on a custom class loader lock.
1337 
1338   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());
1339   {
1340     HandleMark hm(THREAD);
1341     Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
1342     check_loader_lock_contention(lockObject, THREAD);
1343     ObjectLocker ol(lockObject, THREAD, true);
1344     // prohibited package check assumes all classes loaded from archive call
1345     // restore_unshareable_info which calls ik-&gt;set_package()
1346     ik-&gt;restore_unshareable_info(loader_data, protection_domain, CHECK_NULL);
1347   }
1348 
<span class="line-added">1349   load_shared_class_misc(ik, loader_data, CHECK_NULL);</span>
<span class="line-added">1350   return ik;</span>
<span class="line-added">1351 }</span>
<span class="line-added">1352 </span>
<span class="line-added">1353 void SystemDictionary::load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) {</span>
1354   ik-&gt;print_class_load_logging(loader_data, NULL, NULL);
1355 
1356   // For boot loader, ensure that GetSystemPackage knows that a class in this
1357   // package was loaded.
<span class="line-modified">1358   if (loader_data-&gt;is_the_null_class_loader_data()) {</span>
1359     int path_index = ik-&gt;shared_classpath_index();
1360     ResourceMark rm(THREAD);
1361     ClassLoader::add_package(ik-&gt;name()-&gt;as_C_string(), path_index, THREAD);
1362   }
1363 
1364   if (DumpLoadedClassList != NULL &amp;&amp; classlist_file-&gt;is_open()) {
1365     // Only dump the classes that can be stored into CDS archive
1366     if (SystemDictionaryShared::is_sharing_possible(loader_data)) {
1367       ResourceMark rm(THREAD);
1368       classlist_file-&gt;print_cr(&quot;%s&quot;, ik-&gt;name()-&gt;as_C_string());
1369       classlist_file-&gt;flush();
1370     }
1371   }
1372 
1373   // notify a class loaded from shared object
1374   ClassLoadingService::notify_class_loaded(ik, true /* shared class */);
1375 
1376   ik-&gt;set_has_passed_fingerprint_check(false);
1377   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
1378     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
1379     uint64_t cds_fp = ik-&gt;get_stored_fingerprint();
1380     if (aot_fp != 0 &amp;&amp; aot_fp == cds_fp) {
1381       // This class matches with a class saved in an AOT library
1382       ik-&gt;set_has_passed_fingerprint_check(true);
1383     } else {
1384       if (log_is_enabled(Info, class, fingerprint)) {
1385         ResourceMark rm(THREAD);
1386         log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT, ik-&gt;external_name(), aot_fp, cds_fp);
1387       }
1388     }
1389   }
<span class="line-added">1390 }</span>
1391 
<span class="line-modified">1392 void SystemDictionary::quick_resolve(InstanceKlass* klass, ClassLoaderData* loader_data, Handle domain, TRAPS) {</span>
<span class="line-added">1393   assert(!Universe::is_fully_initialized(), &quot;We can make short cuts only during VM initialization&quot;);</span>
<span class="line-added">1394   assert(klass-&gt;is_shared(), &quot;Must be shared class&quot;);</span>
<span class="line-added">1395   if (klass-&gt;class_loader_data() != NULL) {</span>
<span class="line-added">1396     return;</span>
<span class="line-added">1397   }</span>
<span class="line-added">1398 </span>
<span class="line-added">1399   // add super and interfaces first</span>
<span class="line-added">1400   Klass* super = klass-&gt;super();</span>
<span class="line-added">1401   if (super != NULL &amp;&amp; super-&gt;class_loader_data() == NULL) {</span>
<span class="line-added">1402     assert(super-&gt;is_instance_klass(), &quot;Super should be instance klass&quot;);</span>
<span class="line-added">1403     quick_resolve(InstanceKlass::cast(super), loader_data, domain, CHECK);</span>
<span class="line-added">1404   }</span>
<span class="line-added">1405 </span>
<span class="line-added">1406   Array&lt;InstanceKlass*&gt;* ifs = klass-&gt;local_interfaces();</span>
<span class="line-added">1407   for (int i = 0; i &lt; ifs-&gt;length(); i++) {</span>
<span class="line-added">1408     InstanceKlass* ik = ifs-&gt;at(i);</span>
<span class="line-added">1409     if (ik-&gt;class_loader_data()  == NULL) {</span>
<span class="line-added">1410       quick_resolve(ik, loader_data, domain, CHECK);</span>
<span class="line-added">1411     }</span>
<span class="line-added">1412   }</span>
<span class="line-added">1413 </span>
<span class="line-added">1414   klass-&gt;restore_unshareable_info(loader_data, domain, THREAD);</span>
<span class="line-added">1415   load_shared_class_misc(klass, loader_data, CHECK);</span>
<span class="line-added">1416   Dictionary* dictionary = loader_data-&gt;dictionary();</span>
<span class="line-added">1417   unsigned int hash = dictionary-&gt;compute_hash(klass-&gt;name());</span>
<span class="line-added">1418   dictionary-&gt;add_klass(hash, klass-&gt;name(), klass);</span>
<span class="line-added">1419   add_to_hierarchy(klass, CHECK);</span>
<span class="line-added">1420   assert(klass-&gt;is_loaded(), &quot;Must be in at least loaded state&quot;);</span>
1421 }
1422 #endif // INCLUDE_CDS
1423 
1424 InstanceKlass* SystemDictionary::load_instance_class(Symbol* class_name, Handle class_loader, TRAPS) {
1425 
1426   if (class_loader.is_null()) {
1427     ResourceMark rm(THREAD);
1428     PackageEntry* pkg_entry = NULL;
1429     bool search_only_bootloader_append = false;
1430     ClassLoaderData *loader_data = class_loader_data(class_loader);
1431 
1432     // Find the package in the boot loader&#39;s package entry table.
1433     TempNewSymbol pkg_name = InstanceKlass::package_from_name(class_name, CHECK_NULL);
1434     if (pkg_name != NULL) {
1435       pkg_entry = loader_data-&gt;packages()-&gt;lookup_only(pkg_name);
1436     }
1437 
1438     // Prior to attempting to load the class, enforce the boot loader&#39;s
1439     // visibility boundaries.
1440     if (!Universe::is_module_initialized()) {
</pre>
<hr />
<pre>
1812   guarantee(VerifyBeforeGC      ||
1813             VerifyDuringGC      ||
1814             VerifyBeforeExit    ||
1815             VerifyDuringStartup ||
1816             VerifyAfterGC, &quot;too expensive&quot;);
1817   #endif
1818 
1819   Dictionary* dictionary = loader_data-&gt;dictionary();
1820   unsigned int d_hash = dictionary-&gt;compute_hash(class_name);
1821   return find_class(d_hash, class_name, dictionary);
1822 }
1823 
1824 
1825 // ----------------------------------------------------------------------------
1826 // Update hierachy. This is done before the new klass has been added to the SystemDictionary. The Recompile_lock
1827 // is held, to ensure that the compiler is not using the class hierachy, and that deoptimization will kick in
1828 // before a new class is used.
1829 
1830 void SystemDictionary::add_to_hierarchy(InstanceKlass* k, TRAPS) {
1831   assert(k != NULL, &quot;just checking&quot;);
<span class="line-modified">1832   if (Universe::is_fully_initialized()) {</span>
<span class="line-added">1833     assert_locked_or_safepoint(Compile_lock);</span>
<span class="line-added">1834   }</span>
1835 
1836   k-&gt;set_init_state(InstanceKlass::loaded);
1837   // make sure init_state store is already done.
1838   // The compiler reads the hierarchy outside of the Compile_lock.
1839   // Access ordering is used to add to hierarchy.
1840 
1841   // Link into hierachy.
1842   k-&gt;append_to_sibling_list();                    // add to superklass/sibling list
1843   k-&gt;process_interfaces(THREAD);                  // handle all &quot;implements&quot; declarations
1844 
1845   // Now flush all code that depended on old class hierarchy.
1846   // Note: must be done *after* linking k into the hierarchy (was bug 12/9/97)
<span class="line-modified">1847   if (Universe::is_fully_initialized()) {</span>
<span class="line-added">1848     CodeCache::flush_dependents_on(k);</span>
<span class="line-added">1849   }</span>
1850 }
1851 
1852 // ----------------------------------------------------------------------------
1853 // GC support
1854 
1855 // Assumes classes in the SystemDictionary are only unloaded at a safepoint
1856 // Note: anonymous classes are not in the SD.
1857 bool SystemDictionary::do_unloading(GCTimer* gc_timer) {
1858 
1859   bool unloading_occurred;
1860   bool is_concurrent = !SafepointSynchronize::is_at_safepoint();
1861   {
1862     GCTraceTime(Debug, gc, phases) t(&quot;ClassLoaderData&quot;, gc_timer);
1863     assert_locked_or_safepoint(ClassLoaderDataGraph_lock);  // caller locks.
1864     // First, mark for unload all ClassLoaderData referencing a dead class loader.
1865     unloading_occurred = ClassLoaderDataGraph::do_unloading();
1866     if (unloading_occurred) {
1867       MutexLocker ml2(is_concurrent ? Module_lock : NULL);
1868       JFR_ONLY(Jfr::on_unloading_classes();)
1869 
</pre>
<hr />
<pre>
1948 
1949 #ifdef ASSERT
1950 bool SystemDictionary::is_well_known_klass(Symbol* class_name) {
1951   int sid;
1952   for (int i = 0; (sid = wk_init_info[i]) != 0; i++) {
1953     Symbol* symbol = vmSymbols::symbol_at((vmSymbols::SID)sid);
1954     if (class_name == symbol) {
1955       return true;
1956     }
1957   }
1958   return false;
1959 }
1960 #endif
1961 
1962 bool SystemDictionary::resolve_wk_klass(WKID id, TRAPS) {
1963   assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
1964   int sid = wk_init_info[id - FIRST_WKID];
1965   Symbol* symbol = vmSymbols::symbol_at((vmSymbols::SID)sid);
1966   InstanceKlass** klassp = &amp;_well_known_klasses[id];
1967 
<span class="line-modified">1968 #if INCLUDE_CDS</span>
<span class="line-modified">1969   if (UseSharedSpaces &amp;&amp; !JvmtiExport::should_post_class_prepare()) {</span>
<span class="line-added">1970     InstanceKlass* k = *klassp;</span>
<span class="line-added">1971     assert(k-&gt;is_shared_boot_class(), &quot;must be&quot;);</span>
<span class="line-added">1972 </span>
<span class="line-added">1973     ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();</span>
<span class="line-added">1974     quick_resolve(k, loader_data, Handle(), CHECK_false);</span>
<span class="line-added">1975     return true;</span>
<span class="line-added">1976   }</span>
<span class="line-added">1977 #endif // INCLUDE_CDS</span>
<span class="line-added">1978 </span>
<span class="line-added">1979   if (!is_wk_klass_loaded(*klassp)) {</span>
<span class="line-added">1980     Klass* k = resolve_or_fail(symbol, true, CHECK_false);</span>
1981     (*klassp) = InstanceKlass::cast(k);
1982   }
1983   return ((*klassp) != NULL);
1984 }
1985 
1986 void SystemDictionary::resolve_wk_klasses_until(WKID limit_id, WKID &amp;start_id, TRAPS) {
1987   assert((int)start_id &lt;= (int)limit_id, &quot;IDs are out of order!&quot;);
1988   for (int id = (int)start_id; id &lt; (int)limit_id; id++) {
1989     assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
1990     resolve_wk_klass((WKID)id, CHECK);
1991   }
1992 
1993   // move the starting value forward to the limit:
1994   start_id = limit_id;
1995 }
1996 
1997 void SystemDictionary::resolve_well_known_classes(TRAPS) {
<span class="line-modified">1998   assert(!Object_klass_loaded(), &quot;well-known classes should only be initialized once&quot;);</span>
1999 
2000   // Create the ModuleEntry for java.base.  This call needs to be done here,
2001   // after vmSymbols::initialize() is called but before any classes are pre-loaded.
2002   ClassLoader::classLoader_init2(CHECK);
2003 
2004   // Preload commonly used klasses
2005   WKID scan = FIRST_WKID;
2006   // first do Object, then String, Class
2007 #if INCLUDE_CDS
2008   if (UseSharedSpaces) {
2009     resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Object_klass), scan, CHECK);
2010 
2011     // It&#39;s unsafe to access the archived heap regions before they
2012     // are fixed up, so we must do the fixup as early as possible
2013     // before the archived java objects are accessed by functions
2014     // such as java_lang_Class::restore_archived_mirror and
2015     // ConstantPool::restore_unshareable_info (restores the archived
2016     // resolved_references array object).
2017     //
2018     // HeapShared::fixup_mapped_heap_regions() fills the empty
</pre>
<hr />
<pre>
2026     // Initialize the constant pool for the Object_class
2027     assert(Object_klass()-&gt;is_shared(), &quot;must be&quot;);
2028     Object_klass()-&gt;constants()-&gt;restore_unshareable_info(CHECK);
2029     resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Class_klass), scan, CHECK);
2030   } else
2031 #endif
2032   {
2033     resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Class_klass), scan, CHECK);
2034   }
2035 
2036   assert(WK_KLASS(Object_klass) != NULL, &quot;well-known classes should now be initialized&quot;);
2037 
2038   java_lang_Object::register_natives(CHECK);
2039 
2040   // Calculate offsets for String and Class classes since they are loaded and
2041   // can be used after this point.
2042   java_lang_String::compute_offsets();
2043   java_lang_Class::compute_offsets();
2044 
2045   // Fixup mirrors for classes loaded before java.lang.Class.




2046   Universe::initialize_basic_type_mirrors(CHECK);
2047   Universe::fixup_mirrors(CHECK);
2048 
2049   // do a bunch more:
2050   resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Reference_klass), scan, CHECK);
2051 
2052   // Preload ref klasses and set reference types
2053   WK_KLASS(Reference_klass)-&gt;set_reference_type(REF_OTHER);
2054   InstanceRefKlass::update_nonstatic_oop_maps(WK_KLASS(Reference_klass));
2055 
2056   resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(PhantomReference_klass), scan, CHECK);
2057   WK_KLASS(SoftReference_klass)-&gt;set_reference_type(REF_SOFT);
2058   WK_KLASS(WeakReference_klass)-&gt;set_reference_type(REF_WEAK);
2059   WK_KLASS(FinalReference_klass)-&gt;set_reference_type(REF_FINAL);
2060   WK_KLASS(PhantomReference_klass)-&gt;set_reference_type(REF_PHANTOM);
2061 
2062   // JSR 292 classes
2063   WKID jsr292_group_start = WK_KLASS_ENUM_NAME(MethodHandle_klass);
2064   WKID jsr292_group_end   = WK_KLASS_ENUM_NAME(VolatileCallSite_klass);
2065   resolve_wk_klasses_until(jsr292_group_start, scan, CHECK);
2066   resolve_wk_klasses_through(jsr292_group_end, scan, CHECK);
2067   WKID last = WKID_LIMIT;
2068   resolve_wk_klasses_until(last, scan, CHECK);
2069 
2070   _box_klasses[T_BOOLEAN] = WK_KLASS(Boolean_klass);
2071   _box_klasses[T_CHAR]    = WK_KLASS(Character_klass);
2072   _box_klasses[T_FLOAT]   = WK_KLASS(Float_klass);
2073   _box_klasses[T_DOUBLE]  = WK_KLASS(Double_klass);
2074   _box_klasses[T_BYTE]    = WK_KLASS(Byte_klass);
2075   _box_klasses[T_SHORT]   = WK_KLASS(Short_klass);
2076   _box_klasses[T_INT]     = WK_KLASS(Integer_klass);
2077   _box_klasses[T_LONG]    = WK_KLASS(Long_klass);
2078   //_box_klasses[T_OBJECT]  = WK_KLASS(object_klass);
2079   //_box_klasses[T_ARRAY]   = WK_KLASS(object_klass);
2080 
2081 #ifdef ASSERT
2082   if (UseSharedSpaces) {
<span class="line-modified">2083     JVMTI_ONLY(assert(JvmtiExport::is_early_phase(),</span>
<span class="line-modified">2084                       &quot;All well known classes must be resolved in JVMTI early phase&quot;));</span>
2085     for (int i = FIRST_WKID; i &lt; last; i++) {
2086       InstanceKlass* k = _well_known_klasses[i];
2087       assert(k-&gt;is_shared(), &quot;must not be replaced by JVMTI class file load hook&quot;);
2088     }
2089   }
2090 #endif
2091 }
2092 
2093 // Tells if a given klass is a box (wrapper class, such as java.lang.Integer).
2094 // If so, returns the basic type it holds.  If not, returns T_OBJECT.
2095 BasicType SystemDictionary::box_klass_type(Klass* k) {
2096   assert(k != NULL, &quot;&quot;);
2097   for (int i = T_BOOLEAN; i &lt; T_VOID+1; i++) {
2098     if (_box_klasses[i] == k)
2099       return (BasicType)i;
2100   }
2101   return T_OBJECT;
2102 }
2103 
2104 // Constraints on class loaders. The details of the algorithm can be
</pre>
<hr />
<pre>
2520 
2521 // Decide if we can globally cache a lookup of this class, to be returned to any client that asks.
2522 // We must ensure that all class loaders everywhere will reach this class, for any client.
2523 // This is a safe bet for public classes in java.lang, such as Object and String.
2524 // We also include public classes in java.lang.invoke, because they appear frequently in system-level method types.
2525 // Out of an abundance of caution, we do not include any other classes, not even for packages like java.util.
2526 static bool is_always_visible_class(oop mirror) {
2527   Klass* klass = java_lang_Class::as_Klass(mirror);
2528   if (klass-&gt;is_objArray_klass()) {
2529     klass = ObjArrayKlass::cast(klass)-&gt;bottom_klass(); // check element type
2530   }
2531   if (klass-&gt;is_typeArray_klass()) {
2532     return true; // primitive array
2533   }
2534   assert(klass-&gt;is_instance_klass(), &quot;%s&quot;, klass-&gt;external_name());
2535   return klass-&gt;is_public() &amp;&amp;
2536          (InstanceKlass::cast(klass)-&gt;is_same_class_package(SystemDictionary::Object_klass()) ||       // java.lang
2537           InstanceKlass::cast(klass)-&gt;is_same_class_package(SystemDictionary::MethodHandle_klass()));  // java.lang.invoke
2538 }
2539 
<span class="line-modified">2540 // Find or construct the Java mirror (java.lang.Class instance) for</span>
<span class="line-modified">2541 // the given field type signature, as interpreted relative to the</span>
2542 // given class loader.  Handles primitives, void, references, arrays,
2543 // and all other reflectable types, except method types.
2544 // N.B.  Code in reflection should use this entry point.
2545 Handle SystemDictionary::find_java_mirror_for_type(Symbol* signature,
2546                                                    Klass* accessing_klass,
2547                                                    Handle class_loader,
2548                                                    Handle protection_domain,
2549                                                    SignatureStream::FailureMode failure_mode,
2550                                                    TRAPS) {


2551   assert(accessing_klass == NULL || (class_loader.is_null() &amp;&amp; protection_domain.is_null()),
2552          &quot;one or the other, or perhaps neither&quot;);
2553 


2554   // What we have here must be a valid field descriptor,
2555   // and all valid field descriptors are supported.
2556   // Produce the same java.lang.Class that reflection reports.
<span class="line-modified">2557   if (accessing_klass != NULL) {</span>
<span class="line-modified">2558     class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());</span>
<span class="line-modified">2559     protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());</span>
<span class="line-modified">2560   }</span>
<span class="line-modified">2561   ResolvingSignatureStream ss(signature, class_loader, protection_domain, false);</span>
<span class="line-modified">2562   oop mirror_oop = ss.as_java_mirror(failure_mode, CHECK_NH);</span>
<span class="line-modified">2563   if (mirror_oop == NULL) {</span>
<span class="line-modified">2564     return Handle();  // report failure this way</span>
<span class="line-modified">2565   }</span>
<span class="line-modified">2566   Handle mirror(THREAD, mirror_oop);</span>















2567 
<span class="line-added">2568   if (accessing_klass != NULL) {</span>
2569     // Check accessibility, emulating ConstantPool::verify_constant_pool_resolve.
<span class="line-modified">2570     Klass* sel_klass = java_lang_Class::as_Klass(mirror());</span>
<span class="line-modified">2571     if (sel_klass != NULL) {</span>
2572       bool fold_type_to_class = true;
2573       LinkResolver::check_klass_accessability(accessing_klass, sel_klass,
<span class="line-modified">2574                                               fold_type_to_class, CHECK_NH);</span>
2575     }



2576   }
<span class="line-modified">2577   return mirror;</span>



2578 }
2579 
2580 
2581 // Ask Java code to find or construct a java.lang.invoke.MethodType for the given
2582 // signature, as interpreted relative to the given class loader.
2583 // Because of class loader constraints, all method handle usage must be
2584 // consistent with this loader.
2585 Handle SystemDictionary::find_method_handle_type(Symbol* signature,
2586                                                  Klass* accessing_klass,
2587                                                  TRAPS) {
2588   Handle empty;
2589   vmIntrinsics::ID null_iid = vmIntrinsics::_none;  // distinct from all method handle invoker intrinsics
2590   unsigned int hash  = invoke_method_table()-&gt;compute_hash(signature, null_iid);
2591   int          index = invoke_method_table()-&gt;hash_to_index(hash);
2592   SymbolPropertyEntry* spe = invoke_method_table()-&gt;find_entry(index, hash, signature, null_iid);
2593   if (spe != NULL &amp;&amp; spe-&gt;method_type() != NULL) {
2594     assert(java_lang_invoke_MethodType::is_instance(spe-&gt;method_type()), &quot;&quot;);
2595     return Handle(THREAD, spe-&gt;method_type());
2596   } else if (!THREAD-&gt;can_call_java()) {
2597     warning(&quot;SystemDictionary::find_method_handle_type called from compiler thread&quot;);  // FIXME
</pre>
</td>
</tr>
</table>
<center><a href="symbolTable.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
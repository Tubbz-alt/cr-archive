<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/systemDictionaryShared.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="systemDictionary.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionaryShared.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/systemDictionaryShared.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  59 #include &quot;utilities/resourceHash.hpp&quot;
  60 #include &quot;utilities/stringUtils.hpp&quot;
  61 
  62 
  63 objArrayOop SystemDictionaryShared::_shared_protection_domains  =  NULL;
  64 objArrayOop SystemDictionaryShared::_shared_jar_urls            =  NULL;
  65 objArrayOop SystemDictionaryShared::_shared_jar_manifests       =  NULL;
  66 DEBUG_ONLY(bool SystemDictionaryShared::_no_class_loading_should_happen = false;)
  67 
  68 class DumpTimeSharedClassInfo: public CHeapObj&lt;mtClass&gt; {
  69   bool                         _excluded;
  70 public:
  71   struct DTConstraint {
  72     Symbol* _name;
  73     Symbol* _from_name;
  74     DTConstraint() : _name(NULL), _from_name(NULL) {}
  75     DTConstraint(Symbol* n, Symbol* fn) : _name(n), _from_name(fn) {}
  76   };
  77 
  78   InstanceKlass*               _klass;

  79   int                          _id;
  80   int                          _clsfile_size;
  81   int                          _clsfile_crc32;
  82   GrowableArray&lt;DTConstraint&gt;* _verifier_constraints;
  83   GrowableArray&lt;char&gt;*         _verifier_constraint_flags;
  84 
  85   DumpTimeSharedClassInfo() {
  86     _klass = NULL;

  87     _id = -1;
  88     _clsfile_size = -1;
  89     _clsfile_crc32 = -1;
  90     _excluded = false;
  91     _verifier_constraints = NULL;
  92     _verifier_constraint_flags = NULL;
  93   }
  94 
  95   void add_verification_constraint(InstanceKlass* k, Symbol* name,
  96          Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object);
  97 
  98   bool is_builtin() {
  99     return SystemDictionaryShared::is_builtin(_klass);
 100   }
 101 
 102   int num_constraints() {
 103     if (_verifier_constraint_flags != NULL) {
 104       return _verifier_constraint_flags-&gt;length();
 105     } else {
 106       return 0;
 107     }
 108   }
 109 
 110   void metaspace_pointers_do(MetaspaceClosure* it) {
 111     it-&gt;push(&amp;_klass);
 112     if (_verifier_constraints != NULL) {
 113       for (int i = 0; i &lt; _verifier_constraints-&gt;length(); i++) {
 114         DTConstraint* cons = _verifier_constraints-&gt;adr_at(i);
 115         it-&gt;push(&amp;cons-&gt;_name);
 116         it-&gt;push(&amp;cons-&gt;_from_name);
 117       }
 118     }
 119   }
 120 
 121   void set_excluded() {
 122     _excluded = true;
 123   }
 124 
 125   bool is_excluded() {
 126     // _klass may become NULL due to DynamicArchiveBuilder::set_to_null
<span class="line-modified"> 127     return _excluded || _klass == NULL;</span>








 128   }
 129 };
 130 
 131 class DumpTimeSharedClassTable: public ResourceHashtable&lt;
 132   InstanceKlass*,
 133   DumpTimeSharedClassInfo,
 134   primitive_hash&lt;InstanceKlass*&gt;,
 135   primitive_equals&lt;InstanceKlass*&gt;,
 136   15889, // prime number
 137   ResourceObj::C_HEAP&gt;
 138 {
 139   int _builtin_count;
 140   int _unregistered_count;
 141 public:
 142   DumpTimeSharedClassInfo* find_or_allocate_info_for(InstanceKlass* k) {
 143     DumpTimeSharedClassInfo* p = get(k);
 144     if (p == NULL) {
 145       assert(!SystemDictionaryShared::no_class_loading_should_happen(),
 146              &quot;no new classes can be loaded while dumping archive&quot;);
 147       put(k, DumpTimeSharedClassInfo());
</pre>
<hr />
<pre>
 962 }
 963 
 964 static ResourceHashtable&lt;
 965   Symbol*, bool,
 966   primitive_hash&lt;Symbol*&gt;,
 967   primitive_equals&lt;Symbol*&gt;,
 968   6661,                             // prime number
 969   ResourceObj::C_HEAP&gt; _loaded_unregistered_classes;
 970 
 971 bool SystemDictionaryShared::add_unregistered_class(InstanceKlass* k, TRAPS) {
 972   assert(DumpSharedSpaces, &quot;only when dumping&quot;);
 973 
 974   Symbol* name = k-&gt;name();
 975   if (_loaded_unregistered_classes.get(name) != NULL) {
 976     // We don&#39;t allow duplicated unregistered classes of the same name.
 977     return false;
 978   } else {
 979     bool isnew = _loaded_unregistered_classes.put(name, true);
 980     assert(isnew, &quot;sanity&quot;);
 981     MutexLocker mu_r(THREAD, Compile_lock); // add_to_hierarchy asserts this.
<span class="line-modified"> 982     SystemDictionary::add_to_hierarchy(k, CHECK_0);</span>
 983     return true;
 984   }
 985 }
 986 
 987 // This function is called to resolve the super/interfaces of shared classes for
 988 // non-built-in loaders. E.g., ChildClass in the below example
 989 // where &quot;super:&quot; (and optionally &quot;interface:&quot;) have been specified.
 990 //
 991 // java/lang/Object id: 0
 992 // Interface   id: 2 super: 0 source: cust.jar
 993 // ChildClass  id: 4 super: 0 interfaces: 2 source: cust.jar
 994 InstanceKlass* SystemDictionaryShared::dump_time_resolve_super_or_fail(
 995     Symbol* child_name, Symbol* class_name, Handle class_loader,
 996     Handle protection_domain, bool is_superclass, TRAPS) {
 997 
 998   assert(DumpSharedSpaces, &quot;only when dumping&quot;);
 999 
1000   ClassListParser* parser = ClassListParser::instance();
1001   if (parser == NULL) {
1002     // We&#39;re still loading the well-known classes, before the ClassListParser is created.
</pre>
<hr />
<pre>
1091     // agent during dump time).
1092     warn_excluded(k, &quot;Unsupported location&quot;);
1093     return true;
1094   }
1095   if (k-&gt;signers() != NULL) {
1096     // We cannot include signed classes in the archive because the certificates
1097     // used during dump time may be different than those used during
1098     // runtime (due to expiration, etc).
1099     warn_excluded(k, &quot;Signed JAR&quot;);
1100     return true;
1101   }
1102   if (is_jfr_event_class(k)) {
1103     // We cannot include JFR event classes because they need runtime-specific
1104     // instrumentation in order to work with -XX:FlightRecorderOptions=retransform=false.
1105     // There are only a small number of these classes, so it&#39;s not worthwhile to
1106     // support them and make CDS more complicated.
1107     warn_excluded(k, &quot;JFR event class&quot;);
1108     return true;
1109   }
1110   if (k-&gt;init_state() &lt; InstanceKlass::linked) {
<span class="line-modified">1111     // In static dumping, we will attempt to link all classes. Those that fail to link will</span>
<span class="line-modified">1112     // be marked as in error state.</span>
<span class="line-modified">1113     assert(DynamicDumpSharedSpaces, &quot;must be&quot;);</span>
1114 
1115     // TODO -- rethink how this can be handled.
1116     // We should try to link ik, however, we can&#39;t do it here because
1117     // 1. We are at VM exit
1118     // 2. linking a class may cause other classes to be loaded, which means
1119     //    a custom ClassLoader.loadClass() may be called, at a point where the
1120     //    class loader doesn&#39;t expect it.
<span class="line-modified">1121     warn_excluded(k, &quot;Not linked&quot;);</span>




1122     return true;
1123   }
1124   if (k-&gt;major_version() &lt; 50 /*JAVA_6_VERSION*/) {
1125     ResourceMark rm;
1126     log_warning(cds)(&quot;Pre JDK 6 class not supported by CDS: %u.%u %s&quot;,
1127                      k-&gt;major_version(),  k-&gt;minor_version(), k-&gt;name()-&gt;as_C_string());
1128     return true;
1129   }
1130 
1131   InstanceKlass* super = k-&gt;java_super();
1132   if (super != NULL &amp;&amp; should_be_excluded(super)) {
1133     ResourceMark rm;
1134     log_warning(cds)(&quot;Skipping %s: super class %s is excluded&quot;, k-&gt;name()-&gt;as_C_string(), super-&gt;name()-&gt;as_C_string());
1135     return true;
1136   }
1137 
1138   Array&lt;InstanceKlass*&gt;* interfaces = k-&gt;local_interfaces();
1139   int len = interfaces-&gt;length();
1140   for (int i = 0; i &lt; len; i++) {
1141     InstanceKlass* intf = interfaces-&gt;at(i);
1142     if (should_be_excluded(intf)) {
1143       log_warning(cds)(&quot;Skipping %s: interface %s is excluded&quot;, k-&gt;name()-&gt;as_C_string(), intf-&gt;name()-&gt;as_C_string());
1144       return true;
1145     }
1146   }
1147 
1148   return false;
1149 }
1150 
1151 // k is a class before relocating by ArchiveCompactor
1152 void SystemDictionaryShared::validate_before_archiving(InstanceKlass* k) {
1153   ResourceMark rm;
1154   const char* name = k-&gt;name()-&gt;as_C_string();
1155   DumpTimeSharedClassInfo* info = _dumptime_table-&gt;get(k);
1156   assert(_no_class_loading_should_happen, &quot;class loading must be disabled&quot;);
1157   guarantee(info != NULL, &quot;Class %s must be entered into _dumptime_table&quot;, name);
1158   guarantee(!info-&gt;is_excluded(), &quot;Should not attempt to archive excluded class %s&quot;, name);
1159   if (is_builtin(k)) {
<span class="line-modified">1160     guarantee(k-&gt;loader_type() != 0,</span>
1161               &quot;Class loader type must be set for BUILTIN class %s&quot;, name);
1162   } else {
<span class="line-modified">1163     guarantee(k-&gt;loader_type() == 0,</span>
1164               &quot;Class loader type must not be set for UNREGISTERED class %s&quot;, name);
1165   }
1166 }
1167 
1168 class ExcludeDumpTimeSharedClasses : StackObj {
1169 public:
1170   bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
1171     if (SystemDictionaryShared::should_be_excluded(k)) {
1172       info.set_excluded();
1173     }
1174     return true; // keep on iterating
1175   }
1176 };
1177 
1178 void SystemDictionaryShared::check_excluded_classes() {
1179   ExcludeDumpTimeSharedClasses excl;
1180   _dumptime_table-&gt;iterate(&amp;excl);
1181   _dumptime_table-&gt;update_counts();
1182 }
1183 
1184 bool SystemDictionaryShared::is_excluded_class(InstanceKlass* k) {
1185   assert(_no_class_loading_should_happen, &quot;sanity&quot;);
1186   Arguments::assert_is_dumping_archive();
1187   return find_or_allocate_info_for(k)-&gt;is_excluded();
1188 }
1189 
















1190 class IterateDumpTimeSharedClassTable : StackObj {
1191   MetaspaceClosure *_it;
1192 public:
1193   IterateDumpTimeSharedClassTable(MetaspaceClosure* it) : _it(it) {}
1194 
1195   bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
1196     if (!info.is_excluded()) {
1197       info.metaspace_pointers_do(_it);
1198     }
1199     return true; // keep on iterating
1200   }
1201 };
1202 
1203 void SystemDictionaryShared::dumptime_classes_do(class MetaspaceClosure* it) {
1204   IterateDumpTimeSharedClassTable iter(it);
1205   _dumptime_table-&gt;iterate(&amp;iter);
1206 }
1207 
1208 bool SystemDictionaryShared::add_verification_constraint(InstanceKlass* k, Symbol* name,
1209          Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object) {
</pre>
<hr />
<pre>
1393   if (is_static_archive) {
1394     write_dictionary(&amp;_builtin_dictionary, true);
1395     write_dictionary(&amp;_unregistered_dictionary, false);
1396   } else {
1397     write_dictionary(&amp;_dynamic_builtin_dictionary, true);
1398     write_dictionary(&amp;_dynamic_unregistered_dictionary, false);
1399   }
1400 }
1401 
1402 void SystemDictionaryShared::serialize_dictionary_headers(SerializeClosure* soc,
1403                                                           bool is_static_archive) {
1404   if (is_static_archive) {
1405     _builtin_dictionary.serialize_header(soc);
1406     _unregistered_dictionary.serialize_header(soc);
1407   } else {
1408     _dynamic_builtin_dictionary.serialize_header(soc);
1409     _dynamic_unregistered_dictionary.serialize_header(soc);
1410   }
1411 }
1412 






1413 const RunTimeSharedClassInfo*
1414 SystemDictionaryShared::find_record(RunTimeSharedDictionary* static_dict, RunTimeSharedDictionary* dynamic_dict, Symbol* name) {
1415   if (!UseSharedSpaces || !name-&gt;is_shared()) {
1416     // The names of all shared classes must also be a shared Symbol.
1417     return NULL;
1418   }
1419 
1420   unsigned int hash = SystemDictionaryShared::hash_for_shared_dictionary(name);
1421   const RunTimeSharedClassInfo* record = NULL;
1422   if (!MetaspaceShared::is_shared_dynamic(name)) {
1423     // The names of all shared classes in the static dict must also be in the
1424     // static archive
1425     record = static_dict-&gt;lookup(name, hash, 0);
1426   }
1427 
1428   if (record == NULL &amp;&amp; DynamicArchive::is_mapped()) {
1429     record = dynamic_dict-&gt;lookup(name, hash, 0);
1430   }
1431 
1432   return record;
</pre>
</td>
<td>
<hr />
<pre>
  59 #include &quot;utilities/resourceHash.hpp&quot;
  60 #include &quot;utilities/stringUtils.hpp&quot;
  61 
  62 
  63 objArrayOop SystemDictionaryShared::_shared_protection_domains  =  NULL;
  64 objArrayOop SystemDictionaryShared::_shared_jar_urls            =  NULL;
  65 objArrayOop SystemDictionaryShared::_shared_jar_manifests       =  NULL;
  66 DEBUG_ONLY(bool SystemDictionaryShared::_no_class_loading_should_happen = false;)
  67 
  68 class DumpTimeSharedClassInfo: public CHeapObj&lt;mtClass&gt; {
  69   bool                         _excluded;
  70 public:
  71   struct DTConstraint {
  72     Symbol* _name;
  73     Symbol* _from_name;
  74     DTConstraint() : _name(NULL), _from_name(NULL) {}
  75     DTConstraint(Symbol* n, Symbol* fn) : _name(n), _from_name(fn) {}
  76   };
  77 
  78   InstanceKlass*               _klass;
<span class="line-added">  79   bool                         _failed_verification;</span>
  80   int                          _id;
  81   int                          _clsfile_size;
  82   int                          _clsfile_crc32;
  83   GrowableArray&lt;DTConstraint&gt;* _verifier_constraints;
  84   GrowableArray&lt;char&gt;*         _verifier_constraint_flags;
  85 
  86   DumpTimeSharedClassInfo() {
  87     _klass = NULL;
<span class="line-added">  88     _failed_verification = false;</span>
  89     _id = -1;
  90     _clsfile_size = -1;
  91     _clsfile_crc32 = -1;
  92     _excluded = false;
  93     _verifier_constraints = NULL;
  94     _verifier_constraint_flags = NULL;
  95   }
  96 
  97   void add_verification_constraint(InstanceKlass* k, Symbol* name,
  98          Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object);
  99 
 100   bool is_builtin() {
 101     return SystemDictionaryShared::is_builtin(_klass);
 102   }
 103 
 104   int num_constraints() {
 105     if (_verifier_constraint_flags != NULL) {
 106       return _verifier_constraint_flags-&gt;length();
 107     } else {
 108       return 0;
 109     }
 110   }
 111 
 112   void metaspace_pointers_do(MetaspaceClosure* it) {
 113     it-&gt;push(&amp;_klass);
 114     if (_verifier_constraints != NULL) {
 115       for (int i = 0; i &lt; _verifier_constraints-&gt;length(); i++) {
 116         DTConstraint* cons = _verifier_constraints-&gt;adr_at(i);
 117         it-&gt;push(&amp;cons-&gt;_name);
 118         it-&gt;push(&amp;cons-&gt;_from_name);
 119       }
 120     }
 121   }
 122 
 123   void set_excluded() {
 124     _excluded = true;
 125   }
 126 
 127   bool is_excluded() {
 128     // _klass may become NULL due to DynamicArchiveBuilder::set_to_null
<span class="line-modified"> 129     return _excluded || _failed_verification || _klass == NULL;</span>
<span class="line-added"> 130   }</span>
<span class="line-added"> 131 </span>
<span class="line-added"> 132   void set_failed_verification() {</span>
<span class="line-added"> 133     _failed_verification = true;</span>
<span class="line-added"> 134   }</span>
<span class="line-added"> 135 </span>
<span class="line-added"> 136   bool failed_verification() {</span>
<span class="line-added"> 137     return _failed_verification;</span>
 138   }
 139 };
 140 
 141 class DumpTimeSharedClassTable: public ResourceHashtable&lt;
 142   InstanceKlass*,
 143   DumpTimeSharedClassInfo,
 144   primitive_hash&lt;InstanceKlass*&gt;,
 145   primitive_equals&lt;InstanceKlass*&gt;,
 146   15889, // prime number
 147   ResourceObj::C_HEAP&gt;
 148 {
 149   int _builtin_count;
 150   int _unregistered_count;
 151 public:
 152   DumpTimeSharedClassInfo* find_or_allocate_info_for(InstanceKlass* k) {
 153     DumpTimeSharedClassInfo* p = get(k);
 154     if (p == NULL) {
 155       assert(!SystemDictionaryShared::no_class_loading_should_happen(),
 156              &quot;no new classes can be loaded while dumping archive&quot;);
 157       put(k, DumpTimeSharedClassInfo());
</pre>
<hr />
<pre>
 972 }
 973 
 974 static ResourceHashtable&lt;
 975   Symbol*, bool,
 976   primitive_hash&lt;Symbol*&gt;,
 977   primitive_equals&lt;Symbol*&gt;,
 978   6661,                             // prime number
 979   ResourceObj::C_HEAP&gt; _loaded_unregistered_classes;
 980 
 981 bool SystemDictionaryShared::add_unregistered_class(InstanceKlass* k, TRAPS) {
 982   assert(DumpSharedSpaces, &quot;only when dumping&quot;);
 983 
 984   Symbol* name = k-&gt;name();
 985   if (_loaded_unregistered_classes.get(name) != NULL) {
 986     // We don&#39;t allow duplicated unregistered classes of the same name.
 987     return false;
 988   } else {
 989     bool isnew = _loaded_unregistered_classes.put(name, true);
 990     assert(isnew, &quot;sanity&quot;);
 991     MutexLocker mu_r(THREAD, Compile_lock); // add_to_hierarchy asserts this.
<span class="line-modified"> 992     SystemDictionary::add_to_hierarchy(k, CHECK_false);</span>
 993     return true;
 994   }
 995 }
 996 
 997 // This function is called to resolve the super/interfaces of shared classes for
 998 // non-built-in loaders. E.g., ChildClass in the below example
 999 // where &quot;super:&quot; (and optionally &quot;interface:&quot;) have been specified.
1000 //
1001 // java/lang/Object id: 0
1002 // Interface   id: 2 super: 0 source: cust.jar
1003 // ChildClass  id: 4 super: 0 interfaces: 2 source: cust.jar
1004 InstanceKlass* SystemDictionaryShared::dump_time_resolve_super_or_fail(
1005     Symbol* child_name, Symbol* class_name, Handle class_loader,
1006     Handle protection_domain, bool is_superclass, TRAPS) {
1007 
1008   assert(DumpSharedSpaces, &quot;only when dumping&quot;);
1009 
1010   ClassListParser* parser = ClassListParser::instance();
1011   if (parser == NULL) {
1012     // We&#39;re still loading the well-known classes, before the ClassListParser is created.
</pre>
<hr />
<pre>
1101     // agent during dump time).
1102     warn_excluded(k, &quot;Unsupported location&quot;);
1103     return true;
1104   }
1105   if (k-&gt;signers() != NULL) {
1106     // We cannot include signed classes in the archive because the certificates
1107     // used during dump time may be different than those used during
1108     // runtime (due to expiration, etc).
1109     warn_excluded(k, &quot;Signed JAR&quot;);
1110     return true;
1111   }
1112   if (is_jfr_event_class(k)) {
1113     // We cannot include JFR event classes because they need runtime-specific
1114     // instrumentation in order to work with -XX:FlightRecorderOptions=retransform=false.
1115     // There are only a small number of these classes, so it&#39;s not worthwhile to
1116     // support them and make CDS more complicated.
1117     warn_excluded(k, &quot;JFR event class&quot;);
1118     return true;
1119   }
1120   if (k-&gt;init_state() &lt; InstanceKlass::linked) {
<span class="line-modified">1121     // In CDS dumping, we will attempt to link all classes. Those that fail to link will</span>
<span class="line-modified">1122     // be recorded in DumpTimeSharedClassInfo.</span>
<span class="line-modified">1123     Arguments::assert_is_dumping_archive();</span>
1124 
1125     // TODO -- rethink how this can be handled.
1126     // We should try to link ik, however, we can&#39;t do it here because
1127     // 1. We are at VM exit
1128     // 2. linking a class may cause other classes to be loaded, which means
1129     //    a custom ClassLoader.loadClass() may be called, at a point where the
1130     //    class loader doesn&#39;t expect it.
<span class="line-modified">1131     if (has_class_failed_verification(k)) {</span>
<span class="line-added">1132       warn_excluded(k, &quot;Failed verification&quot;);</span>
<span class="line-added">1133     } else {</span>
<span class="line-added">1134       warn_excluded(k, &quot;Not linked&quot;);</span>
<span class="line-added">1135     }</span>
1136     return true;
1137   }
1138   if (k-&gt;major_version() &lt; 50 /*JAVA_6_VERSION*/) {
1139     ResourceMark rm;
1140     log_warning(cds)(&quot;Pre JDK 6 class not supported by CDS: %u.%u %s&quot;,
1141                      k-&gt;major_version(),  k-&gt;minor_version(), k-&gt;name()-&gt;as_C_string());
1142     return true;
1143   }
1144 
1145   InstanceKlass* super = k-&gt;java_super();
1146   if (super != NULL &amp;&amp; should_be_excluded(super)) {
1147     ResourceMark rm;
1148     log_warning(cds)(&quot;Skipping %s: super class %s is excluded&quot;, k-&gt;name()-&gt;as_C_string(), super-&gt;name()-&gt;as_C_string());
1149     return true;
1150   }
1151 
1152   Array&lt;InstanceKlass*&gt;* interfaces = k-&gt;local_interfaces();
1153   int len = interfaces-&gt;length();
1154   for (int i = 0; i &lt; len; i++) {
1155     InstanceKlass* intf = interfaces-&gt;at(i);
1156     if (should_be_excluded(intf)) {
1157       log_warning(cds)(&quot;Skipping %s: interface %s is excluded&quot;, k-&gt;name()-&gt;as_C_string(), intf-&gt;name()-&gt;as_C_string());
1158       return true;
1159     }
1160   }
1161 
1162   return false;
1163 }
1164 
1165 // k is a class before relocating by ArchiveCompactor
1166 void SystemDictionaryShared::validate_before_archiving(InstanceKlass* k) {
1167   ResourceMark rm;
1168   const char* name = k-&gt;name()-&gt;as_C_string();
1169   DumpTimeSharedClassInfo* info = _dumptime_table-&gt;get(k);
1170   assert(_no_class_loading_should_happen, &quot;class loading must be disabled&quot;);
1171   guarantee(info != NULL, &quot;Class %s must be entered into _dumptime_table&quot;, name);
1172   guarantee(!info-&gt;is_excluded(), &quot;Should not attempt to archive excluded class %s&quot;, name);
1173   if (is_builtin(k)) {
<span class="line-modified">1174     guarantee(!k-&gt;is_shared_unregistered_class(),</span>
1175               &quot;Class loader type must be set for BUILTIN class %s&quot;, name);
1176   } else {
<span class="line-modified">1177     guarantee(k-&gt;is_shared_unregistered_class(),</span>
1178               &quot;Class loader type must not be set for UNREGISTERED class %s&quot;, name);
1179   }
1180 }
1181 
1182 class ExcludeDumpTimeSharedClasses : StackObj {
1183 public:
1184   bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
1185     if (SystemDictionaryShared::should_be_excluded(k)) {
1186       info.set_excluded();
1187     }
1188     return true; // keep on iterating
1189   }
1190 };
1191 
1192 void SystemDictionaryShared::check_excluded_classes() {
1193   ExcludeDumpTimeSharedClasses excl;
1194   _dumptime_table-&gt;iterate(&amp;excl);
1195   _dumptime_table-&gt;update_counts();
1196 }
1197 
1198 bool SystemDictionaryShared::is_excluded_class(InstanceKlass* k) {
1199   assert(_no_class_loading_should_happen, &quot;sanity&quot;);
1200   Arguments::assert_is_dumping_archive();
1201   return find_or_allocate_info_for(k)-&gt;is_excluded();
1202 }
1203 
<span class="line-added">1204 void SystemDictionaryShared::set_class_has_failed_verification(InstanceKlass* ik) {</span>
<span class="line-added">1205   Arguments::assert_is_dumping_archive();</span>
<span class="line-added">1206   find_or_allocate_info_for(ik)-&gt;set_failed_verification();</span>
<span class="line-added">1207 }</span>
<span class="line-added">1208 </span>
<span class="line-added">1209 bool SystemDictionaryShared::has_class_failed_verification(InstanceKlass* ik) {</span>
<span class="line-added">1210   Arguments::assert_is_dumping_archive();</span>
<span class="line-added">1211   if (_dumptime_table == NULL) {</span>
<span class="line-added">1212     assert(DynamicDumpSharedSpaces, &quot;sanity&quot;);</span>
<span class="line-added">1213     assert(ik-&gt;is_shared(), &quot;must be a shared class in the static archive&quot;);</span>
<span class="line-added">1214     return false;</span>
<span class="line-added">1215   }</span>
<span class="line-added">1216   DumpTimeSharedClassInfo* p = _dumptime_table-&gt;get(ik);</span>
<span class="line-added">1217   return (p == NULL) ? false : p-&gt;failed_verification();</span>
<span class="line-added">1218 }</span>
<span class="line-added">1219 </span>
1220 class IterateDumpTimeSharedClassTable : StackObj {
1221   MetaspaceClosure *_it;
1222 public:
1223   IterateDumpTimeSharedClassTable(MetaspaceClosure* it) : _it(it) {}
1224 
1225   bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
1226     if (!info.is_excluded()) {
1227       info.metaspace_pointers_do(_it);
1228     }
1229     return true; // keep on iterating
1230   }
1231 };
1232 
1233 void SystemDictionaryShared::dumptime_classes_do(class MetaspaceClosure* it) {
1234   IterateDumpTimeSharedClassTable iter(it);
1235   _dumptime_table-&gt;iterate(&amp;iter);
1236 }
1237 
1238 bool SystemDictionaryShared::add_verification_constraint(InstanceKlass* k, Symbol* name,
1239          Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object) {
</pre>
<hr />
<pre>
1423   if (is_static_archive) {
1424     write_dictionary(&amp;_builtin_dictionary, true);
1425     write_dictionary(&amp;_unregistered_dictionary, false);
1426   } else {
1427     write_dictionary(&amp;_dynamic_builtin_dictionary, true);
1428     write_dictionary(&amp;_dynamic_unregistered_dictionary, false);
1429   }
1430 }
1431 
1432 void SystemDictionaryShared::serialize_dictionary_headers(SerializeClosure* soc,
1433                                                           bool is_static_archive) {
1434   if (is_static_archive) {
1435     _builtin_dictionary.serialize_header(soc);
1436     _unregistered_dictionary.serialize_header(soc);
1437   } else {
1438     _dynamic_builtin_dictionary.serialize_header(soc);
1439     _dynamic_unregistered_dictionary.serialize_header(soc);
1440   }
1441 }
1442 
<span class="line-added">1443 void SystemDictionaryShared::serialize_well_known_klasses(SerializeClosure* soc) {</span>
<span class="line-added">1444   for (int i = FIRST_WKID; i &lt; WKID_LIMIT; i++) {</span>
<span class="line-added">1445     soc-&gt;do_ptr((void**)&amp;_well_known_klasses[i]);</span>
<span class="line-added">1446   }</span>
<span class="line-added">1447 }</span>
<span class="line-added">1448 </span>
1449 const RunTimeSharedClassInfo*
1450 SystemDictionaryShared::find_record(RunTimeSharedDictionary* static_dict, RunTimeSharedDictionary* dynamic_dict, Symbol* name) {
1451   if (!UseSharedSpaces || !name-&gt;is_shared()) {
1452     // The names of all shared classes must also be a shared Symbol.
1453     return NULL;
1454   }
1455 
1456   unsigned int hash = SystemDictionaryShared::hash_for_shared_dictionary(name);
1457   const RunTimeSharedClassInfo* record = NULL;
1458   if (!MetaspaceShared::is_shared_dynamic(name)) {
1459     // The names of all shared classes in the static dict must also be in the
1460     // static archive
1461     record = static_dict-&gt;lookup(name, hash, 0);
1462   }
1463 
1464   if (record == NULL &amp;&amp; DynamicArchive::is_mapped()) {
1465     record = dynamic_dict-&gt;lookup(name, hash, 0);
1466   }
1467 
1468   return record;
</pre>
</td>
</tr>
</table>
<center><a href="systemDictionary.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionaryShared.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
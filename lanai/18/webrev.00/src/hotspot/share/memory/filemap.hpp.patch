diff a/src/hotspot/share/memory/filemap.hpp b/src/hotspot/share/memory/filemap.hpp
--- a/src/hotspot/share/memory/filemap.hpp
+++ b/src/hotspot/share/memory/filemap.hpp
@@ -93,10 +93,11 @@
   }
   void set_manifest(Array<u1>* manifest) {
     _manifest = manifest;
   }
   bool check_non_existent() const;
+  void copy_from(SharedClassPathEntry* ent, ClassLoaderData* loader_data, TRAPS);
 };
 
 struct ArchiveHeapOopmapInfo {
   address _oopmap;               // bitmap for relocating embedded oops
   size_t  _oopmap_size_in_bits;
@@ -185,10 +186,12 @@
   int    _narrow_oop_shift;         // compressed oop encoding shift
   bool   _compact_strings;          // value of CompactStrings
   uintx  _max_heap_size;            // java max heap size during dumping
   CompressedOops::Mode _narrow_oop_mode; // compressed oop encoding mode
   int     _narrow_klass_shift;      // save narrow klass base and shift
+  bool    _compressed_oops;         // save the flag UseCompressedOops
+  bool    _compressed_class_ptrs;   // save the flag UseCompressedClassPointers
   size_t  _cloned_vtables_offset;   // The address of the first cloned vtable
   size_t  _serialized_data_offset;  // Data accessed using {ReadClosure,WriteClosure}::serialize()
   size_t  _i2i_entry_code_buffers_offset;
   size_t  _i2i_entry_code_buffers_size;
   address _heap_end;                // heap end at dump time.
@@ -262,11 +265,12 @@
   size_t base_archive_name_size()          const { return _base_archive_name_size; }
   char* requested_base_address()           const { return _requested_base_address; }
   char* mapped_base_address()              const { return _mapped_base_address; }
   bool has_platform_or_app_classes()       const { return _has_platform_or_app_classes; }
   size_t ptrmap_size_in_bits()             const { return _ptrmap_size_in_bits; }
-
+  bool compressed_oops()                   const { return _compressed_oops; }
+  bool compressed_class_pointers()         const { return _compressed_class_ptrs; }
   // FIXME: These should really return int
   jshort max_used_path_index()             const { return _max_used_path_index; }
   jshort app_module_paths_start_index()    const { return _app_module_paths_start_index; }
   jshort app_class_paths_start_index()     const { return _app_class_paths_start_index; }
   jshort num_module_paths()                const { return _num_module_paths; }
@@ -330,10 +334,11 @@
   const char*    _base_archive_name;
   FileMapHeader* _header;
 
   // TODO: Probably change the following to be non-static
   static SharedPathTable       _shared_path_table;
+  static SharedPathTable       _saved_shared_path_table;
   static bool                  _validating_shared_path_table;
 
   // FileMapHeader describes the shared space data in the file to be
   // mapped.  This structure gets written to a file.  It is not a class, so
   // that the compilers don't add any compiler-private data to it.
@@ -351,13 +356,16 @@
                                                 int* size, char** base_archive_name);
   static bool check_archive(const char* archive_name, bool is_static);
   static SharedPathTable shared_path_table() {
     return _shared_path_table;
   }
-  void restore_shared_path_table();
+  static SharedPathTable saved_shared_path_table() {
+    return _saved_shared_path_table;
+  }
+
   bool init_from_file(int fd);
-  static void metaspace_pointers_do(MetaspaceClosure* it);
+  static void metaspace_pointers_do(MetaspaceClosure* it, bool use_copy = true);
 
   void log_paths(const char* msg, int start_idx, int end_idx);
 
   FileMapInfo(bool is_static);
   ~FileMapInfo();
@@ -477,10 +485,11 @@
 
   // Stop CDS sharing and unmap CDS regions.
   static void stop_sharing_and_unmap(const char* msg);
 
   static void allocate_shared_path_table();
+  static void copy_shared_path_table(ClassLoaderData* loader_data, Thread* THREAD);
   static int add_shared_classpaths(int i, const char* which, ClassPathEntry *cpe, TRAPS);
   static void check_nonempty_dir_in_shared_path_table();
   bool validate_shared_path_table();
   void validate_non_existent_class_paths();
   static void set_shared_path_table(FileMapInfo* info) {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/services/management.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jmm.h&quot;
  27 #include &quot;classfile/classLoader.hpp&quot;
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;compiler/compileBroker.hpp&quot;
  30 #include &quot;memory/allocation.inline.hpp&quot;
  31 #include &quot;memory/iterator.hpp&quot;
  32 #include &quot;memory/oopFactory.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
  34 #include &quot;memory/universe.hpp&quot;
  35 #include &quot;oops/klass.hpp&quot;
  36 #include &quot;oops/objArrayKlass.hpp&quot;
  37 #include &quot;oops/objArrayOop.inline.hpp&quot;
  38 #include &quot;oops/oop.inline.hpp&quot;
  39 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  40 #include &quot;runtime/arguments.hpp&quot;
  41 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  42 #include &quot;runtime/globals.hpp&quot;
  43 #include &quot;runtime/handles.inline.hpp&quot;
  44 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  45 #include &quot;runtime/javaCalls.hpp&quot;
  46 #include &quot;runtime/jniHandles.inline.hpp&quot;
  47 #include &quot;runtime/notificationThread.hpp&quot;
  48 #include &quot;runtime/os.hpp&quot;
  49 #include &quot;runtime/thread.inline.hpp&quot;
  50 #include &quot;runtime/threadSMR.hpp&quot;
  51 #include &quot;services/classLoadingService.hpp&quot;
  52 #include &quot;services/diagnosticCommand.hpp&quot;
  53 #include &quot;services/diagnosticFramework.hpp&quot;
  54 #include &quot;services/writeableFlags.hpp&quot;
  55 #include &quot;services/heapDumper.hpp&quot;
  56 #include &quot;services/lowMemoryDetector.hpp&quot;
  57 #include &quot;services/gcNotifier.hpp&quot;
  58 #include &quot;services/nmtDCmd.hpp&quot;
  59 #include &quot;services/management.hpp&quot;
  60 #include &quot;services/memoryManager.hpp&quot;
  61 #include &quot;services/memoryPool.hpp&quot;
  62 #include &quot;services/memoryService.hpp&quot;
  63 #include &quot;services/runtimeService.hpp&quot;
  64 #include &quot;services/threadService.hpp&quot;
  65 #include &quot;utilities/debug.hpp&quot;
  66 #include &quot;utilities/formatBuffer.hpp&quot;
  67 #include &quot;utilities/macros.hpp&quot;
  68 
  69 PerfVariable* Management::_begin_vm_creation_time = NULL;
  70 PerfVariable* Management::_end_vm_creation_time = NULL;
  71 PerfVariable* Management::_vm_init_done_time = NULL;
  72 
  73 InstanceKlass* Management::_diagnosticCommandImpl_klass = NULL;
  74 InstanceKlass* Management::_garbageCollectorExtImpl_klass = NULL;
  75 InstanceKlass* Management::_garbageCollectorMXBean_klass = NULL;
  76 InstanceKlass* Management::_gcInfo_klass = NULL;
  77 InstanceKlass* Management::_managementFactoryHelper_klass = NULL;
  78 InstanceKlass* Management::_memoryManagerMXBean_klass = NULL;
  79 InstanceKlass* Management::_memoryPoolMXBean_klass = NULL;
  80 InstanceKlass* Management::_memoryUsage_klass = NULL;
  81 InstanceKlass* Management::_sensor_klass = NULL;
  82 InstanceKlass* Management::_threadInfo_klass = NULL;
  83 
  84 jmmOptionalSupport Management::_optional_support = {0};
  85 TimeStamp Management::_stamp;
  86 
  87 void management_init() {
  88 #if INCLUDE_MANAGEMENT
  89   Management::init();
  90   ThreadService::init();
  91   RuntimeService::init();
  92   ClassLoadingService::init();
  93 #else
  94   ThreadService::init();
  95 #endif // INCLUDE_MANAGEMENT
  96 }
  97 
  98 #if INCLUDE_MANAGEMENT
  99 
 100 void Management::init() {
 101   EXCEPTION_MARK;
 102 
 103   // These counters are for java.lang.management API support.
 104   // They are created even if -XX:-UsePerfData is set and in
 105   // that case, they will be allocated on C heap.
 106 
 107   _begin_vm_creation_time =
 108             PerfDataManager::create_variable(SUN_RT, &quot;createVmBeginTime&quot;,
 109                                              PerfData::U_None, CHECK);
 110 
 111   _end_vm_creation_time =
 112             PerfDataManager::create_variable(SUN_RT, &quot;createVmEndTime&quot;,
 113                                              PerfData::U_None, CHECK);
 114 
 115   _vm_init_done_time =
 116             PerfDataManager::create_variable(SUN_RT, &quot;vmInitDoneTime&quot;,
 117                                              PerfData::U_None, CHECK);
 118 
 119   // Initialize optional support
 120   _optional_support.isLowMemoryDetectionSupported = 1;
 121   _optional_support.isCompilationTimeMonitoringSupported = 1;
 122   _optional_support.isThreadContentionMonitoringSupported = 1;
 123 
 124   if (os::is_thread_cpu_time_supported()) {
 125     _optional_support.isCurrentThreadCpuTimeSupported = 1;
 126     _optional_support.isOtherThreadCpuTimeSupported = 1;
 127   } else {
 128     _optional_support.isCurrentThreadCpuTimeSupported = 0;
 129     _optional_support.isOtherThreadCpuTimeSupported = 0;
 130   }
 131 
 132   _optional_support.isObjectMonitorUsageSupported = 1;
 133 #if INCLUDE_SERVICES
 134   // This depends on the heap inspector
 135   _optional_support.isSynchronizerUsageSupported = 1;
 136 #endif // INCLUDE_SERVICES
 137   _optional_support.isThreadAllocatedMemorySupported = 1;
 138   _optional_support.isRemoteDiagnosticCommandsSupported = 1;
 139 
 140   // Registration of the diagnostic commands
 141   DCmdRegistrant::register_dcmds();
 142   DCmdRegistrant::register_dcmds_ext();
 143   uint32_t full_export = DCmd_Source_Internal | DCmd_Source_AttachAPI
 144                          | DCmd_Source_MBean;
 145   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;NMTDCmd&gt;(full_export, true, false));
 146 }
 147 
 148 void Management::initialize(TRAPS) {
 149   if (UseNotificationThread) {
 150     NotificationThread::initialize();
 151   }
 152   if (ManagementServer) {
 153     ResourceMark rm(THREAD);
 154     HandleMark hm(THREAD);
 155 
 156     // Load and initialize the jdk.internal.agent.Agent class
 157     // invoke startAgent method to start the management server
 158     Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());
 159     Klass* k = SystemDictionary::resolve_or_null(vmSymbols::jdk_internal_agent_Agent(),
 160                                                    loader,
 161                                                    Handle(),
 162                                                    THREAD);
 163     if (k == NULL) {
 164       vm_exit_during_initialization(&quot;Management agent initialization failure: &quot;
 165           &quot;class jdk.internal.agent.Agent not found.&quot;);
 166     }
 167 
 168     JavaValue result(T_VOID);
 169     JavaCalls::call_static(&amp;result,
 170                            k,
 171                            vmSymbols::startAgent_name(),
 172                            vmSymbols::void_method_signature(),
 173                            CHECK);
 174   }
 175 }
 176 
 177 void Management::get_optional_support(jmmOptionalSupport* support) {
 178   memcpy(support, &amp;_optional_support, sizeof(jmmOptionalSupport));
 179 }
 180 
 181 InstanceKlass* Management::load_and_initialize_klass(Symbol* sh, TRAPS) {
 182   Klass* k = SystemDictionary::resolve_or_fail(sh, true, CHECK_NULL);
 183   return initialize_klass(k, THREAD);
 184 }
 185 
 186 InstanceKlass* Management::load_and_initialize_klass_or_null(Symbol* sh, TRAPS) {
 187   Klass* k = SystemDictionary::resolve_or_null(sh, CHECK_NULL);
 188   if (k == NULL) {
 189      return NULL;
 190   }
 191   return initialize_klass(k, THREAD);
 192 }
 193 
 194 InstanceKlass* Management::initialize_klass(Klass* k, TRAPS) {
 195   InstanceKlass* ik = InstanceKlass::cast(k);
 196   if (ik-&gt;should_be_initialized()) {
 197     ik-&gt;initialize(CHECK_NULL);
 198   }
 199   // If these classes change to not be owned by the boot loader, they need
 200   // to be walked to keep their class loader alive in oops_do.
 201   assert(ik-&gt;class_loader() == NULL, &quot;need to follow in oops_do&quot;);
 202   return ik;
 203 }
 204 
 205 void Management::record_vm_startup_time(jlong begin, jlong duration) {
 206   // if the performance counter is not initialized,
 207   // then vm initialization failed; simply return.
 208   if (_begin_vm_creation_time == NULL) return;
 209 
 210   _begin_vm_creation_time-&gt;set_value(begin);
 211   _end_vm_creation_time-&gt;set_value(begin + duration);
 212   PerfMemory::set_accessible(true);
 213 }
 214 
 215 jlong Management::timestamp() {
 216   TimeStamp t;
 217   t.update();
 218   return t.ticks() - _stamp.ticks();
 219 }
 220 
 221 void Management::oops_do(OopClosure* f) {
 222   MemoryService::oops_do(f);
 223   ThreadService::oops_do(f);
 224 }
 225 
 226 InstanceKlass* Management::java_lang_management_ThreadInfo_klass(TRAPS) {
 227   if (_threadInfo_klass == NULL) {
 228     _threadInfo_klass = load_and_initialize_klass(vmSymbols::java_lang_management_ThreadInfo(), CHECK_NULL);
 229   }
 230   return _threadInfo_klass;
 231 }
 232 
 233 InstanceKlass* Management::java_lang_management_MemoryUsage_klass(TRAPS) {
 234   if (_memoryUsage_klass == NULL) {
 235     _memoryUsage_klass = load_and_initialize_klass(vmSymbols::java_lang_management_MemoryUsage(), CHECK_NULL);
 236   }
 237   return _memoryUsage_klass;
 238 }
 239 
 240 InstanceKlass* Management::java_lang_management_MemoryPoolMXBean_klass(TRAPS) {
 241   if (_memoryPoolMXBean_klass == NULL) {
 242     _memoryPoolMXBean_klass = load_and_initialize_klass(vmSymbols::java_lang_management_MemoryPoolMXBean(), CHECK_NULL);
 243   }
 244   return _memoryPoolMXBean_klass;
 245 }
 246 
 247 InstanceKlass* Management::java_lang_management_MemoryManagerMXBean_klass(TRAPS) {
 248   if (_memoryManagerMXBean_klass == NULL) {
 249     _memoryManagerMXBean_klass = load_and_initialize_klass(vmSymbols::java_lang_management_MemoryManagerMXBean(), CHECK_NULL);
 250   }
 251   return _memoryManagerMXBean_klass;
 252 }
 253 
 254 InstanceKlass* Management::java_lang_management_GarbageCollectorMXBean_klass(TRAPS) {
 255   if (_garbageCollectorMXBean_klass == NULL) {
 256       _garbageCollectorMXBean_klass = load_and_initialize_klass(vmSymbols::java_lang_management_GarbageCollectorMXBean(), CHECK_NULL);
 257   }
 258   return _garbageCollectorMXBean_klass;
 259 }
 260 
 261 InstanceKlass* Management::sun_management_Sensor_klass(TRAPS) {
 262   if (_sensor_klass == NULL) {
 263     _sensor_klass = load_and_initialize_klass(vmSymbols::sun_management_Sensor(), CHECK_NULL);
 264   }
 265   return _sensor_klass;
 266 }
 267 
 268 InstanceKlass* Management::sun_management_ManagementFactoryHelper_klass(TRAPS) {
 269   if (_managementFactoryHelper_klass == NULL) {
 270     _managementFactoryHelper_klass = load_and_initialize_klass(vmSymbols::sun_management_ManagementFactoryHelper(), CHECK_NULL);
 271   }
 272   return _managementFactoryHelper_klass;
 273 }
 274 
 275 InstanceKlass* Management::com_sun_management_internal_GarbageCollectorExtImpl_klass(TRAPS) {
 276   if (_garbageCollectorExtImpl_klass == NULL) {
 277     _garbageCollectorExtImpl_klass =
 278                 load_and_initialize_klass_or_null(vmSymbols::com_sun_management_internal_GarbageCollectorExtImpl(), CHECK_NULL);
 279   }
 280   return _garbageCollectorExtImpl_klass;
 281 }
 282 
 283 InstanceKlass* Management::com_sun_management_GcInfo_klass(TRAPS) {
 284   if (_gcInfo_klass == NULL) {
 285     _gcInfo_klass = load_and_initialize_klass(vmSymbols::com_sun_management_GcInfo(), CHECK_NULL);
 286   }
 287   return _gcInfo_klass;
 288 }
 289 
 290 InstanceKlass* Management::com_sun_management_internal_DiagnosticCommandImpl_klass(TRAPS) {
 291   if (_diagnosticCommandImpl_klass == NULL) {
 292     _diagnosticCommandImpl_klass = load_and_initialize_klass(vmSymbols::com_sun_management_internal_DiagnosticCommandImpl(), CHECK_NULL);
 293   }
 294   return _diagnosticCommandImpl_klass;
 295 }
 296 
 297 static void initialize_ThreadInfo_constructor_arguments(JavaCallArguments* args, ThreadSnapshot* snapshot, TRAPS) {
 298   Handle snapshot_thread(THREAD, snapshot-&gt;threadObj());
 299 
 300   jlong contended_time;
 301   jlong waited_time;
 302   if (ThreadService::is_thread_monitoring_contention()) {
 303     contended_time = Management::ticks_to_ms(snapshot-&gt;contended_enter_ticks());
 304     waited_time = Management::ticks_to_ms(snapshot-&gt;monitor_wait_ticks() + snapshot-&gt;sleep_ticks());
 305   } else {
 306     // set them to -1 if thread contention monitoring is disabled.
 307     contended_time = max_julong;
 308     waited_time = max_julong;
 309   }
 310 
 311   int thread_status = snapshot-&gt;thread_status();
 312   assert((thread_status &amp; JMM_THREAD_STATE_FLAG_MASK) == 0, &quot;Flags already set in thread_status in Thread object&quot;);
 313   if (snapshot-&gt;is_ext_suspended()) {
 314     thread_status |= JMM_THREAD_STATE_FLAG_SUSPENDED;
 315   }
 316   if (snapshot-&gt;is_in_native()) {
 317     thread_status |= JMM_THREAD_STATE_FLAG_NATIVE;
 318   }
 319 
 320   ThreadStackTrace* st = snapshot-&gt;get_stack_trace();
 321   Handle stacktrace_h;
 322   if (st != NULL) {
 323     stacktrace_h = st-&gt;allocate_fill_stack_trace_element_array(CHECK);
 324   } else {
 325     stacktrace_h = Handle();
 326   }
 327 
 328   args-&gt;push_oop(snapshot_thread);
 329   args-&gt;push_int(thread_status);
 330   args-&gt;push_oop(Handle(THREAD, snapshot-&gt;blocker_object()));
 331   args-&gt;push_oop(Handle(THREAD, snapshot-&gt;blocker_object_owner()));
 332   args-&gt;push_long(snapshot-&gt;contended_enter_count());
 333   args-&gt;push_long(contended_time);
 334   args-&gt;push_long(snapshot-&gt;monitor_wait_count() + snapshot-&gt;sleep_count());
 335   args-&gt;push_long(waited_time);
 336   args-&gt;push_oop(stacktrace_h);
 337 }
 338 
 339 // Helper function to construct a ThreadInfo object
 340 instanceOop Management::create_thread_info_instance(ThreadSnapshot* snapshot, TRAPS) {
 341   InstanceKlass* ik = Management::java_lang_management_ThreadInfo_klass(CHECK_NULL);
 342   JavaCallArguments args(14);
 343 
 344   // initialize the arguments for the ThreadInfo constructor
 345   initialize_ThreadInfo_constructor_arguments(&amp;args, snapshot, CHECK_NULL);
 346 
 347   // Call ThreadInfo constructor with no locked monitors and synchronizers
 348   Handle element = JavaCalls::construct_new_instance(
 349                           ik,
 350                           vmSymbols::java_lang_management_ThreadInfo_constructor_signature(),
 351                           &amp;args,
 352                           CHECK_NULL);
 353   return (instanceOop) element();
 354 }
 355 
 356 instanceOop Management::create_thread_info_instance(ThreadSnapshot* snapshot,
 357                                                     objArrayHandle monitors_array,
 358                                                     typeArrayHandle depths_array,
 359                                                     objArrayHandle synchronizers_array,
 360                                                     TRAPS) {
 361   InstanceKlass* ik = Management::java_lang_management_ThreadInfo_klass(CHECK_NULL);
 362   JavaCallArguments args(17);
 363 
 364   // initialize the arguments for the ThreadInfo constructor
 365   initialize_ThreadInfo_constructor_arguments(&amp;args, snapshot, CHECK_NULL);
 366 
 367   // push the locked monitors and synchronizers in the arguments
 368   args.push_oop(monitors_array);
 369   args.push_oop(depths_array);
 370   args.push_oop(synchronizers_array);
 371 
 372   // Call ThreadInfo constructor with locked monitors and synchronizers
 373   Handle element = JavaCalls::construct_new_instance(
 374                           ik,
 375                           vmSymbols::java_lang_management_ThreadInfo_with_locks_constructor_signature(),
 376                           &amp;args,
 377                           CHECK_NULL);
 378   return (instanceOop) element();
 379 }
 380 
 381 
 382 static GCMemoryManager* get_gc_memory_manager_from_jobject(jobject mgr, TRAPS) {
 383   if (mgr == NULL) {
 384     THROW_(vmSymbols::java_lang_NullPointerException(), NULL);
 385   }
 386   oop mgr_obj = JNIHandles::resolve(mgr);
 387   instanceHandle h(THREAD, (instanceOop) mgr_obj);
 388 
 389   InstanceKlass* k = Management::java_lang_management_GarbageCollectorMXBean_klass(CHECK_NULL);
 390   if (!h-&gt;is_a(k)) {
 391     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
 392                &quot;the object is not an instance of java.lang.management.GarbageCollectorMXBean class&quot;,
 393                NULL);
 394   }
 395 
 396   MemoryManager* gc = MemoryService::get_memory_manager(h);
 397   if (gc == NULL || !gc-&gt;is_gc_memory_manager()) {
 398     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
 399                &quot;Invalid GC memory manager&quot;,
 400                NULL);
 401   }
 402   return (GCMemoryManager*) gc;
 403 }
 404 
 405 static MemoryPool* get_memory_pool_from_jobject(jobject obj, TRAPS) {
 406   if (obj == NULL) {
 407     THROW_(vmSymbols::java_lang_NullPointerException(), NULL);
 408   }
 409 
 410   oop pool_obj = JNIHandles::resolve(obj);
 411   assert(pool_obj-&gt;is_instance(), &quot;Should be an instanceOop&quot;);
 412   instanceHandle ph(THREAD, (instanceOop) pool_obj);
 413 
 414   return MemoryService::get_memory_pool(ph);
 415 }
 416 
 417 #endif // INCLUDE_MANAGEMENT
 418 
 419 static void validate_thread_id_array(typeArrayHandle ids_ah, TRAPS) {
 420   int num_threads = ids_ah-&gt;length();
 421 
 422   // Validate input thread IDs
 423   int i = 0;
 424   for (i = 0; i &lt; num_threads; i++) {
 425     jlong tid = ids_ah-&gt;long_at(i);
 426     if (tid &lt;= 0) {
 427       // throw exception if invalid thread id.
 428       THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
 429                 &quot;Invalid thread ID entry&quot;);
 430     }
 431   }
 432 }
 433 
 434 #if INCLUDE_MANAGEMENT
 435 
 436 static void validate_thread_info_array(objArrayHandle infoArray_h, TRAPS) {
 437   // check if the element of infoArray is of type ThreadInfo class
 438   Klass* threadinfo_klass = Management::java_lang_management_ThreadInfo_klass(CHECK);
 439   Klass* element_klass = ObjArrayKlass::cast(infoArray_h-&gt;klass())-&gt;element_klass();
 440   if (element_klass != threadinfo_klass) {
 441     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
 442               &quot;infoArray element type is not ThreadInfo class&quot;);
 443   }
 444 }
 445 
 446 
 447 static MemoryManager* get_memory_manager_from_jobject(jobject obj, TRAPS) {
 448   if (obj == NULL) {
 449     THROW_(vmSymbols::java_lang_NullPointerException(), NULL);
 450   }
 451 
 452   oop mgr_obj = JNIHandles::resolve(obj);
 453   assert(mgr_obj-&gt;is_instance(), &quot;Should be an instanceOop&quot;);
 454   instanceHandle mh(THREAD, (instanceOop) mgr_obj);
 455 
 456   return MemoryService::get_memory_manager(mh);
 457 }
 458 
 459 // Returns a version string and sets major and minor version if
 460 // the input parameters are non-null.
 461 JVM_LEAF(jint, jmm_GetVersion(JNIEnv *env))
 462   return JMM_VERSION;
 463 JVM_END
 464 
 465 // Gets the list of VM monitoring and management optional supports
 466 // Returns 0 if succeeded; otherwise returns non-zero.
 467 JVM_LEAF(jint, jmm_GetOptionalSupport(JNIEnv *env, jmmOptionalSupport* support))
 468   if (support == NULL) {
 469     return -1;
 470   }
 471   Management::get_optional_support(support);
 472   return 0;
 473 JVM_END
 474 
 475 // Returns an array of java/lang/management/MemoryPoolMXBean object
 476 // one for each memory pool if obj == null; otherwise returns
 477 // an array of memory pools for a given memory manager if
 478 // it is a valid memory manager.
 479 JVM_ENTRY(jobjectArray, jmm_GetMemoryPools(JNIEnv* env, jobject obj))
 480   ResourceMark rm(THREAD);
 481 
 482   int num_memory_pools;
 483   MemoryManager* mgr = NULL;
 484   if (obj == NULL) {
 485     num_memory_pools = MemoryService::num_memory_pools();
 486   } else {
 487     mgr = get_memory_manager_from_jobject(obj, CHECK_NULL);
 488     if (mgr == NULL) {
 489       return NULL;
 490     }
 491     num_memory_pools = mgr-&gt;num_memory_pools();
 492   }
 493 
 494   // Allocate the resulting MemoryPoolMXBean[] object
 495   InstanceKlass* ik = Management::java_lang_management_MemoryPoolMXBean_klass(CHECK_NULL);
 496   objArrayOop r = oopFactory::new_objArray(ik, num_memory_pools, CHECK_NULL);
 497   objArrayHandle poolArray(THREAD, r);
 498 
 499   if (mgr == NULL) {
 500     // Get all memory pools
 501     for (int i = 0; i &lt; num_memory_pools; i++) {
 502       MemoryPool* pool = MemoryService::get_memory_pool(i);
 503       instanceOop p = pool-&gt;get_memory_pool_instance(CHECK_NULL);
 504       instanceHandle ph(THREAD, p);
 505       poolArray-&gt;obj_at_put(i, ph());
 506     }
 507   } else {
 508     // Get memory pools managed by a given memory manager
 509     for (int i = 0; i &lt; num_memory_pools; i++) {
 510       MemoryPool* pool = mgr-&gt;get_memory_pool(i);
 511       instanceOop p = pool-&gt;get_memory_pool_instance(CHECK_NULL);
 512       instanceHandle ph(THREAD, p);
 513       poolArray-&gt;obj_at_put(i, ph());
 514     }
 515   }
 516   return (jobjectArray) JNIHandles::make_local(env, poolArray());
 517 JVM_END
 518 
 519 // Returns an array of java/lang/management/MemoryManagerMXBean object
 520 // one for each memory manager if obj == null; otherwise returns
 521 // an array of memory managers for a given memory pool if
 522 // it is a valid memory pool.
 523 JVM_ENTRY(jobjectArray, jmm_GetMemoryManagers(JNIEnv* env, jobject obj))
 524   ResourceMark rm(THREAD);
 525 
 526   int num_mgrs;
 527   MemoryPool* pool = NULL;
 528   if (obj == NULL) {
 529     num_mgrs = MemoryService::num_memory_managers();
 530   } else {
 531     pool = get_memory_pool_from_jobject(obj, CHECK_NULL);
 532     if (pool == NULL) {
 533       return NULL;
 534     }
 535     num_mgrs = pool-&gt;num_memory_managers();
 536   }
 537 
 538   // Allocate the resulting MemoryManagerMXBean[] object
 539   InstanceKlass* ik = Management::java_lang_management_MemoryManagerMXBean_klass(CHECK_NULL);
 540   objArrayOop r = oopFactory::new_objArray(ik, num_mgrs, CHECK_NULL);
 541   objArrayHandle mgrArray(THREAD, r);
 542 
 543   if (pool == NULL) {
 544     // Get all memory managers
 545     for (int i = 0; i &lt; num_mgrs; i++) {
 546       MemoryManager* mgr = MemoryService::get_memory_manager(i);
 547       instanceOop p = mgr-&gt;get_memory_manager_instance(CHECK_NULL);
 548       instanceHandle ph(THREAD, p);
 549       mgrArray-&gt;obj_at_put(i, ph());
 550     }
 551   } else {
 552     // Get memory managers for a given memory pool
 553     for (int i = 0; i &lt; num_mgrs; i++) {
 554       MemoryManager* mgr = pool-&gt;get_memory_manager(i);
 555       instanceOop p = mgr-&gt;get_memory_manager_instance(CHECK_NULL);
 556       instanceHandle ph(THREAD, p);
 557       mgrArray-&gt;obj_at_put(i, ph());
 558     }
 559   }
 560   return (jobjectArray) JNIHandles::make_local(env, mgrArray());
 561 JVM_END
 562 
 563 
 564 // Returns a java/lang/management/MemoryUsage object containing the memory usage
 565 // of a given memory pool.
 566 JVM_ENTRY(jobject, jmm_GetMemoryPoolUsage(JNIEnv* env, jobject obj))
 567   ResourceMark rm(THREAD);
 568 
 569   MemoryPool* pool = get_memory_pool_from_jobject(obj, CHECK_NULL);
 570   if (pool != NULL) {
 571     MemoryUsage usage = pool-&gt;get_memory_usage();
 572     Handle h = MemoryService::create_MemoryUsage_obj(usage, CHECK_NULL);
 573     return JNIHandles::make_local(env, h());
 574   } else {
 575     return NULL;
 576   }
 577 JVM_END
 578 
 579 // Returns a java/lang/management/MemoryUsage object containing the memory usage
 580 // of a given memory pool.
 581 JVM_ENTRY(jobject, jmm_GetPeakMemoryPoolUsage(JNIEnv* env, jobject obj))
 582   ResourceMark rm(THREAD);
 583 
 584   MemoryPool* pool = get_memory_pool_from_jobject(obj, CHECK_NULL);
 585   if (pool != NULL) {
 586     MemoryUsage usage = pool-&gt;get_peak_memory_usage();
 587     Handle h = MemoryService::create_MemoryUsage_obj(usage, CHECK_NULL);
 588     return JNIHandles::make_local(env, h());
 589   } else {
 590     return NULL;
 591   }
 592 JVM_END
 593 
 594 // Returns a java/lang/management/MemoryUsage object containing the memory usage
 595 // of a given memory pool after most recent GC.
 596 JVM_ENTRY(jobject, jmm_GetPoolCollectionUsage(JNIEnv* env, jobject obj))
 597   ResourceMark rm(THREAD);
 598 
 599   MemoryPool* pool = get_memory_pool_from_jobject(obj, CHECK_NULL);
 600   if (pool != NULL &amp;&amp; pool-&gt;is_collected_pool()) {
 601     MemoryUsage usage = pool-&gt;get_last_collection_usage();
 602     Handle h = MemoryService::create_MemoryUsage_obj(usage, CHECK_NULL);
 603     return JNIHandles::make_local(env, h());
 604   } else {
 605     return NULL;
 606   }
 607 JVM_END
 608 
 609 // Sets the memory pool sensor for a threshold type
 610 JVM_ENTRY(void, jmm_SetPoolSensor(JNIEnv* env, jobject obj, jmmThresholdType type, jobject sensorObj))
 611   if (obj == NULL || sensorObj == NULL) {
 612     THROW(vmSymbols::java_lang_NullPointerException());
 613   }
 614 
 615   InstanceKlass* sensor_klass = Management::sun_management_Sensor_klass(CHECK);
 616   oop s = JNIHandles::resolve(sensorObj);
 617   assert(s-&gt;is_instance(), &quot;Sensor should be an instanceOop&quot;);
 618   instanceHandle sensor_h(THREAD, (instanceOop) s);
 619   if (!sensor_h-&gt;is_a(sensor_klass)) {
 620     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
 621               &quot;Sensor is not an instance of sun.management.Sensor class&quot;);
 622   }
 623 
 624   MemoryPool* mpool = get_memory_pool_from_jobject(obj, CHECK);
 625   assert(mpool != NULL, &quot;MemoryPool should exist&quot;);
 626 
 627   switch (type) {
 628     case JMM_USAGE_THRESHOLD_HIGH:
 629     case JMM_USAGE_THRESHOLD_LOW:
 630       // have only one sensor for threshold high and low
 631       mpool-&gt;set_usage_sensor_obj(sensor_h);
 632       break;
 633     case JMM_COLLECTION_USAGE_THRESHOLD_HIGH:
 634     case JMM_COLLECTION_USAGE_THRESHOLD_LOW:
 635       // have only one sensor for threshold high and low
 636       mpool-&gt;set_gc_usage_sensor_obj(sensor_h);
 637       break;
 638     default:
 639       assert(false, &quot;Unrecognized type&quot;);
 640   }
 641 
 642 JVM_END
 643 
 644 
 645 // Sets the threshold of a given memory pool.
 646 // Returns the previous threshold.
 647 //
 648 // Input parameters:
 649 //   pool      - the MemoryPoolMXBean object
 650 //   type      - threshold type
 651 //   threshold - the new threshold (must not be negative)
 652 //
 653 JVM_ENTRY(jlong, jmm_SetPoolThreshold(JNIEnv* env, jobject obj, jmmThresholdType type, jlong threshold))
 654   if (threshold &lt; 0) {
 655     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
 656                &quot;Invalid threshold value&quot;,
 657                -1);
 658   }
 659 
 660   if ((size_t)threshold &gt; max_uintx) {
 661     stringStream st;
 662     st.print(&quot;Invalid valid threshold value. Threshold value (&quot; JLONG_FORMAT &quot;) &gt; max value of size_t (&quot; UINTX_FORMAT &quot;)&quot;, threshold, max_uintx);
 663     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(), st.as_string(), -1);
 664   }
 665 
 666   MemoryPool* pool = get_memory_pool_from_jobject(obj, CHECK_(0L));
 667   assert(pool != NULL, &quot;MemoryPool should exist&quot;);
 668 
 669   jlong prev = 0;
 670   switch (type) {
 671     case JMM_USAGE_THRESHOLD_HIGH:
 672       if (!pool-&gt;usage_threshold()-&gt;is_high_threshold_supported()) {
 673         return -1;
 674       }
 675       prev = pool-&gt;usage_threshold()-&gt;set_high_threshold((size_t) threshold);
 676       break;
 677 
 678     case JMM_USAGE_THRESHOLD_LOW:
 679       if (!pool-&gt;usage_threshold()-&gt;is_low_threshold_supported()) {
 680         return -1;
 681       }
 682       prev = pool-&gt;usage_threshold()-&gt;set_low_threshold((size_t) threshold);
 683       break;
 684 
 685     case JMM_COLLECTION_USAGE_THRESHOLD_HIGH:
 686       if (!pool-&gt;gc_usage_threshold()-&gt;is_high_threshold_supported()) {
 687         return -1;
 688       }
 689       // return and the new threshold is effective for the next GC
 690       return pool-&gt;gc_usage_threshold()-&gt;set_high_threshold((size_t) threshold);
 691 
 692     case JMM_COLLECTION_USAGE_THRESHOLD_LOW:
 693       if (!pool-&gt;gc_usage_threshold()-&gt;is_low_threshold_supported()) {
 694         return -1;
 695       }
 696       // return and the new threshold is effective for the next GC
 697       return pool-&gt;gc_usage_threshold()-&gt;set_low_threshold((size_t) threshold);
 698 
 699     default:
 700       assert(false, &quot;Unrecognized type&quot;);
 701       return -1;
 702   }
 703 
 704   // When the threshold is changed, reevaluate if the low memory
 705   // detection is enabled.
 706   if (prev != threshold) {
 707     LowMemoryDetector::recompute_enabled_for_collected_pools();
 708     LowMemoryDetector::detect_low_memory(pool);
 709   }
 710   return prev;
 711 JVM_END
 712 
 713 // Returns a java/lang/management/MemoryUsage object representing
 714 // the memory usage for the heap or non-heap memory.
 715 JVM_ENTRY(jobject, jmm_GetMemoryUsage(JNIEnv* env, jboolean heap))
 716   ResourceMark rm(THREAD);
 717 
 718   MemoryUsage usage;
 719 
 720   if (heap) {
 721     usage = Universe::heap()-&gt;memory_usage();
 722   } else {
 723     // Calculate the memory usage by summing up the pools.
 724     size_t total_init = 0;
 725     size_t total_used = 0;
 726     size_t total_committed = 0;
 727     size_t total_max = 0;
 728     bool   has_undefined_init_size = false;
 729     bool   has_undefined_max_size = false;
 730 
 731     for (int i = 0; i &lt; MemoryService::num_memory_pools(); i++) {
 732       MemoryPool* pool = MemoryService::get_memory_pool(i);
 733       if (pool-&gt;is_non_heap()) {
 734         MemoryUsage u = pool-&gt;get_memory_usage();
 735         total_used += u.used();
 736         total_committed += u.committed();
 737 
 738         if (u.init_size() == MemoryUsage::undefined_size()) {
 739           has_undefined_init_size = true;
 740         }
 741         if (!has_undefined_init_size) {
 742           total_init += u.init_size();
 743         }
 744 
 745         if (u.max_size() == MemoryUsage::undefined_size()) {
 746           has_undefined_max_size = true;
 747         }
 748         if (!has_undefined_max_size) {
 749           total_max += u.max_size();
 750         }
 751       }
 752     }
 753 
 754     // if any one of the memory pool has undefined init_size or max_size,
 755     // set it to MemoryUsage::undefined_size()
 756     if (has_undefined_init_size) {
 757       total_init = MemoryUsage::undefined_size();
 758     }
 759     if (has_undefined_max_size) {
 760       total_max = MemoryUsage::undefined_size();
 761     }
 762 
 763     usage = MemoryUsage(total_init, total_used, total_committed, total_max);
 764   }
 765 
 766   Handle obj = MemoryService::create_MemoryUsage_obj(usage, CHECK_NULL);
 767   return JNIHandles::make_local(env, obj());
 768 JVM_END
 769 
 770 // Returns the boolean value of a given attribute.
 771 JVM_LEAF(jboolean, jmm_GetBoolAttribute(JNIEnv *env, jmmBoolAttribute att))
 772   switch (att) {
 773   case JMM_VERBOSE_GC:
 774     return MemoryService::get_verbose();
 775   case JMM_VERBOSE_CLASS:
 776     return ClassLoadingService::get_verbose();
 777   case JMM_THREAD_CONTENTION_MONITORING:
 778     return ThreadService::is_thread_monitoring_contention();
 779   case JMM_THREAD_CPU_TIME:
 780     return ThreadService::is_thread_cpu_time_enabled();
 781   case JMM_THREAD_ALLOCATED_MEMORY:
 782     return ThreadService::is_thread_allocated_memory_enabled();
 783   default:
 784     assert(0, &quot;Unrecognized attribute&quot;);
 785     return false;
 786   }
 787 JVM_END
 788 
 789 // Sets the given boolean attribute and returns the previous value.
 790 JVM_ENTRY(jboolean, jmm_SetBoolAttribute(JNIEnv *env, jmmBoolAttribute att, jboolean flag))
 791   switch (att) {
 792   case JMM_VERBOSE_GC:
 793     return MemoryService::set_verbose(flag != 0);
 794   case JMM_VERBOSE_CLASS:
 795     return ClassLoadingService::set_verbose(flag != 0);
 796   case JMM_THREAD_CONTENTION_MONITORING:
 797     return ThreadService::set_thread_monitoring_contention(flag != 0);
 798   case JMM_THREAD_CPU_TIME:
 799     return ThreadService::set_thread_cpu_time_enabled(flag != 0);
 800   case JMM_THREAD_ALLOCATED_MEMORY:
 801     return ThreadService::set_thread_allocated_memory_enabled(flag != 0);
 802   default:
 803     assert(0, &quot;Unrecognized attribute&quot;);
 804     return false;
 805   }
 806 JVM_END
 807 
 808 
 809 static jlong get_gc_attribute(GCMemoryManager* mgr, jmmLongAttribute att) {
 810   switch (att) {
 811   case JMM_GC_TIME_MS:
 812     return mgr-&gt;gc_time_ms();
 813 
 814   case JMM_GC_COUNT:
 815     return mgr-&gt;gc_count();
 816 
 817   case JMM_GC_EXT_ATTRIBUTE_INFO_SIZE:
 818     // current implementation only has 1 ext attribute
 819     return 1;
 820 
 821   default:
 822     assert(0, &quot;Unrecognized GC attribute&quot;);
 823     return -1;
 824   }
 825 }
 826 
 827 class VmThreadCountClosure: public ThreadClosure {
 828  private:
 829   int _count;
 830  public:
 831   VmThreadCountClosure() : _count(0) {};
 832   void do_thread(Thread* thread);
 833   int count() { return _count; }
 834 };
 835 
 836 void VmThreadCountClosure::do_thread(Thread* thread) {
 837   // exclude externally visible JavaThreads
 838   if (thread-&gt;is_Java_thread() &amp;&amp; !thread-&gt;is_hidden_from_external_view()) {
 839     return;
 840   }
 841 
 842   _count++;
 843 }
 844 
 845 static jint get_vm_thread_count() {
 846   VmThreadCountClosure vmtcc;
 847   {
 848     MutexLocker ml(Threads_lock);
 849     Threads::threads_do(&amp;vmtcc);
 850   }
 851 
 852   return vmtcc.count();
 853 }
 854 
 855 static jint get_num_flags() {
 856   // last flag entry is always NULL, so subtract 1
 857   int nFlags = (int) JVMFlag::numFlags - 1;
 858   int count = 0;
 859   for (int i = 0; i &lt; nFlags; i++) {
 860     JVMFlag* flag = &amp;JVMFlag::flags[i];
 861     // Exclude the locked (diagnostic, experimental) flags
 862     if (flag-&gt;is_unlocked() || flag-&gt;is_unlocker()) {
 863       count++;
 864     }
 865   }
 866   return count;
 867 }
 868 
 869 static jlong get_long_attribute(jmmLongAttribute att) {
 870   switch (att) {
 871   case JMM_CLASS_LOADED_COUNT:
 872     return ClassLoadingService::loaded_class_count();
 873 
 874   case JMM_CLASS_UNLOADED_COUNT:
 875     return ClassLoadingService::unloaded_class_count();
 876 
 877   case JMM_THREAD_TOTAL_COUNT:
 878     return ThreadService::get_total_thread_count();
 879 
 880   case JMM_THREAD_LIVE_COUNT:
 881     return ThreadService::get_live_thread_count();
 882 
 883   case JMM_THREAD_PEAK_COUNT:
 884     return ThreadService::get_peak_thread_count();
 885 
 886   case JMM_THREAD_DAEMON_COUNT:
 887     return ThreadService::get_daemon_thread_count();
 888 
 889   case JMM_JVM_INIT_DONE_TIME_MS:
 890     return Management::vm_init_done_time();
 891 
 892   case JMM_JVM_UPTIME_MS:
 893     return Management::ticks_to_ms(os::elapsed_counter());
 894 
 895   case JMM_COMPILE_TOTAL_TIME_MS:
 896     return Management::ticks_to_ms(CompileBroker::total_compilation_ticks());
 897 
 898   case JMM_OS_PROCESS_ID:
 899     return os::current_process_id();
 900 
 901   // Hotspot-specific counters
 902   case JMM_CLASS_LOADED_BYTES:
 903     return ClassLoadingService::loaded_class_bytes();
 904 
 905   case JMM_CLASS_UNLOADED_BYTES:
 906     return ClassLoadingService::unloaded_class_bytes();
 907 
 908   case JMM_SHARED_CLASS_LOADED_COUNT:
 909     return ClassLoadingService::loaded_shared_class_count();
 910 
 911   case JMM_SHARED_CLASS_UNLOADED_COUNT:
 912     return ClassLoadingService::unloaded_shared_class_count();
 913 
 914 
 915   case JMM_SHARED_CLASS_LOADED_BYTES:
 916     return ClassLoadingService::loaded_shared_class_bytes();
 917 
 918   case JMM_SHARED_CLASS_UNLOADED_BYTES:
 919     return ClassLoadingService::unloaded_shared_class_bytes();
 920 
 921   case JMM_TOTAL_CLASSLOAD_TIME_MS:
 922     return ClassLoader::classloader_time_ms();
 923 
 924   case JMM_VM_GLOBAL_COUNT:
 925     return get_num_flags();
 926 
 927   case JMM_SAFEPOINT_COUNT:
 928     return RuntimeService::safepoint_count();
 929 
 930   case JMM_TOTAL_SAFEPOINTSYNC_TIME_MS:
 931     return RuntimeService::safepoint_sync_time_ms();
 932 
 933   case JMM_TOTAL_STOPPED_TIME_MS:
 934     return RuntimeService::safepoint_time_ms();
 935 
 936   case JMM_TOTAL_APP_TIME_MS:
 937     return RuntimeService::application_time_ms();
 938 
 939   case JMM_VM_THREAD_COUNT:
 940     return get_vm_thread_count();
 941 
 942   case JMM_CLASS_INIT_TOTAL_COUNT:
 943     return ClassLoader::class_init_count();
 944 
 945   case JMM_CLASS_INIT_TOTAL_TIME_MS:
 946     return ClassLoader::class_init_time_ms();
 947 
 948   case JMM_CLASS_VERIFY_TOTAL_TIME_MS:
 949     return ClassLoader::class_verify_time_ms();
 950 
 951   case JMM_METHOD_DATA_SIZE_BYTES:
 952     return ClassLoadingService::class_method_data_size();
 953 
 954   case JMM_OS_MEM_TOTAL_PHYSICAL_BYTES:
 955     return os::physical_memory();
 956 
 957   default:
 958     return -1;
 959   }
 960 }
 961 
 962 
 963 // Returns the long value of a given attribute.
 964 JVM_ENTRY(jlong, jmm_GetLongAttribute(JNIEnv *env, jobject obj, jmmLongAttribute att))
 965   if (obj == NULL) {
 966     return get_long_attribute(att);
 967   } else {
 968     GCMemoryManager* mgr = get_gc_memory_manager_from_jobject(obj, CHECK_(0L));
 969     if (mgr != NULL) {
 970       return get_gc_attribute(mgr, att);
 971     }
 972   }
 973   return -1;
 974 JVM_END
 975 
 976 // Gets the value of all attributes specified in the given array
 977 // and sets the value in the result array.
 978 // Returns the number of attributes found.
 979 JVM_ENTRY(jint, jmm_GetLongAttributes(JNIEnv *env,
 980                                       jobject obj,
 981                                       jmmLongAttribute* atts,
 982                                       jint count,
 983                                       jlong* result))
 984 
 985   int num_atts = 0;
 986   if (obj == NULL) {
 987     for (int i = 0; i &lt; count; i++) {
 988       result[i] = get_long_attribute(atts[i]);
 989       if (result[i] != -1) {
 990         num_atts++;
 991       }
 992     }
 993   } else {
 994     GCMemoryManager* mgr = get_gc_memory_manager_from_jobject(obj, CHECK_0);
 995     for (int i = 0; i &lt; count; i++) {
 996       result[i] = get_gc_attribute(mgr, atts[i]);
 997       if (result[i] != -1) {
 998         num_atts++;
 999       }
1000     }
1001   }
1002   return num_atts;
1003 JVM_END
1004 
1005 // Helper function to do thread dump for a specific list of threads
1006 static void do_thread_dump(ThreadDumpResult* dump_result,
1007                            typeArrayHandle ids_ah,  // array of thread ID (long[])
1008                            int num_threads,
1009                            int max_depth,
1010                            bool with_locked_monitors,
1011                            bool with_locked_synchronizers,
1012                            TRAPS) {
1013   // no need to actually perform thread dump if no TIDs are specified
1014   if (num_threads == 0) return;
1015 
1016   // First get an array of threadObj handles.
1017   // A JavaThread may terminate before we get the stack trace.
1018   GrowableArray&lt;instanceHandle&gt;* thread_handle_array = new GrowableArray&lt;instanceHandle&gt;(num_threads);
1019 
1020   {
1021     // Need this ThreadsListHandle for converting Java thread IDs into
1022     // threadObj handles; dump_result-&gt;set_t_list() is called in the
1023     // VM op below so we can&#39;t use it yet.
1024     ThreadsListHandle tlh;
1025     for (int i = 0; i &lt; num_threads; i++) {
1026       jlong tid = ids_ah-&gt;long_at(i);
1027       JavaThread* jt = tlh.list()-&gt;find_JavaThread_from_java_tid(tid);
1028       oop thread_obj = (jt != NULL ? jt-&gt;threadObj() : (oop)NULL);
1029       instanceHandle threadObj_h(THREAD, (instanceOop) thread_obj);
1030       thread_handle_array-&gt;append(threadObj_h);
1031     }
1032   }
1033 
1034   // Obtain thread dumps and thread snapshot information
1035   VM_ThreadDump op(dump_result,
1036                    thread_handle_array,
1037                    num_threads,
1038                    max_depth, /* stack depth */
1039                    with_locked_monitors,
1040                    with_locked_synchronizers);
1041   VMThread::execute(&amp;op);
1042 }
1043 
1044 // Gets an array of ThreadInfo objects. Each element is the ThreadInfo
1045 // for the thread ID specified in the corresponding entry in
1046 // the given array of thread IDs; or NULL if the thread does not exist
1047 // or has terminated.
1048 //
1049 // Input parameters:
1050 //   ids       - array of thread IDs
1051 //   maxDepth  - the maximum depth of stack traces to be dumped:
1052 //               maxDepth == -1 requests to dump entire stack trace.
1053 //               maxDepth == 0  requests no stack trace.
1054 //   infoArray - array of ThreadInfo objects
1055 //
1056 // QQQ - Why does this method return a value instead of void?
1057 JVM_ENTRY(jint, jmm_GetThreadInfo(JNIEnv *env, jlongArray ids, jint maxDepth, jobjectArray infoArray))
1058   // Check if threads is null
1059   if (ids == NULL || infoArray == NULL) {
1060     THROW_(vmSymbols::java_lang_NullPointerException(), -1);
1061   }
1062 
1063   if (maxDepth &lt; -1) {
1064     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
1065                &quot;Invalid maxDepth&quot;, -1);
1066   }
1067 
1068   ResourceMark rm(THREAD);
1069   typeArrayOop ta = typeArrayOop(JNIHandles::resolve_non_null(ids));
1070   typeArrayHandle ids_ah(THREAD, ta);
1071 
1072   oop infoArray_obj = JNIHandles::resolve_non_null(infoArray);
1073   objArrayOop oa = objArrayOop(infoArray_obj);
1074   objArrayHandle infoArray_h(THREAD, oa);
1075 
1076   // validate the thread id array
1077   validate_thread_id_array(ids_ah, CHECK_0);
1078 
1079   // validate the ThreadInfo[] parameters
1080   validate_thread_info_array(infoArray_h, CHECK_0);
1081 
1082   // infoArray must be of the same length as the given array of thread IDs
1083   int num_threads = ids_ah-&gt;length();
1084   if (num_threads != infoArray_h-&gt;length()) {
1085     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
1086                &quot;The length of the given ThreadInfo array does not match the length of the given array of thread IDs&quot;, -1);
1087   }
1088 
1089   // Must use ThreadDumpResult to store the ThreadSnapshot.
1090   // GC may occur after the thread snapshots are taken but before
1091   // this function returns. The threadObj and other oops kept
1092   // in the ThreadSnapshot are marked and adjusted during GC.
1093   ThreadDumpResult dump_result(num_threads);
1094 
1095   if (maxDepth == 0) {
1096     // No stack trace to dump so we do not need to stop the world.
1097     // Since we never do the VM op here we must set the threads list.
1098     dump_result.set_t_list();
1099     for (int i = 0; i &lt; num_threads; i++) {
1100       jlong tid = ids_ah-&gt;long_at(i);
1101       JavaThread* jt = dump_result.t_list()-&gt;find_JavaThread_from_java_tid(tid);
1102       if (jt == NULL) {
1103         // if the thread does not exist or now it is terminated,
1104         // create dummy snapshot
1105         dump_result.add_thread_snapshot();
1106       } else {
1107         dump_result.add_thread_snapshot(jt);
1108       }
1109     }
1110   } else {
1111     // obtain thread dump with the specific list of threads with stack trace
1112     do_thread_dump(&amp;dump_result,
1113                    ids_ah,
1114                    num_threads,
1115                    maxDepth,
1116                    false, /* no locked monitor */
1117                    false, /* no locked synchronizers */
1118                    CHECK_0);
1119   }
1120 
1121   int num_snapshots = dump_result.num_snapshots();
1122   assert(num_snapshots == num_threads, &quot;Must match the number of thread snapshots&quot;);
1123   assert(num_snapshots == 0 || dump_result.t_list_has_been_set(), &quot;ThreadsList must have been set if we have a snapshot&quot;);
1124   int index = 0;
1125   for (ThreadSnapshot* ts = dump_result.snapshots(); ts != NULL; index++, ts = ts-&gt;next()) {
1126     // For each thread, create an java/lang/management/ThreadInfo object
1127     // and fill with the thread information
1128 
1129     if (ts-&gt;threadObj() == NULL) {
1130      // if the thread does not exist or now it is terminated, set threadinfo to NULL
1131       infoArray_h-&gt;obj_at_put(index, NULL);
1132       continue;
1133     }
1134 
1135     // Create java.lang.management.ThreadInfo object
1136     instanceOop info_obj = Management::create_thread_info_instance(ts, CHECK_0);
1137     infoArray_h-&gt;obj_at_put(index, info_obj);
1138   }
1139   return 0;
1140 JVM_END
1141 
1142 // Dump thread info for the specified threads.
1143 // It returns an array of ThreadInfo objects. Each element is the ThreadInfo
1144 // for the thread ID specified in the corresponding entry in
1145 // the given array of thread IDs; or NULL if the thread does not exist
1146 // or has terminated.
1147 //
1148 // Input parameter:
1149 //    ids - array of thread IDs; NULL indicates all live threads
1150 //    locked_monitors - if true, dump locked object monitors
1151 //    locked_synchronizers - if true, dump locked JSR-166 synchronizers
1152 //
1153 JVM_ENTRY(jobjectArray, jmm_DumpThreads(JNIEnv *env, jlongArray thread_ids, jboolean locked_monitors,
1154                                         jboolean locked_synchronizers, jint maxDepth))
1155   ResourceMark rm(THREAD);
1156 
1157   typeArrayOop ta = typeArrayOop(JNIHandles::resolve(thread_ids));
1158   int num_threads = (ta != NULL ? ta-&gt;length() : 0);
1159   typeArrayHandle ids_ah(THREAD, ta);
1160 
1161   ThreadDumpResult dump_result(num_threads);  // can safepoint
1162 
1163   if (ids_ah() != NULL) {
1164 
1165     // validate the thread id array
1166     validate_thread_id_array(ids_ah, CHECK_NULL);
1167 
1168     // obtain thread dump of a specific list of threads
1169     do_thread_dump(&amp;dump_result,
1170                    ids_ah,
1171                    num_threads,
1172                    maxDepth, /* stack depth */
1173                    (locked_monitors ? true : false),      /* with locked monitors */
1174                    (locked_synchronizers ? true : false), /* with locked synchronizers */
1175                    CHECK_NULL);
1176   } else {
1177     // obtain thread dump of all threads
1178     VM_ThreadDump op(&amp;dump_result,
1179                      maxDepth, /* stack depth */
1180                      (locked_monitors ? true : false),     /* with locked monitors */
1181                      (locked_synchronizers ? true : false) /* with locked synchronizers */);
1182     VMThread::execute(&amp;op);
1183   }
1184 
1185   int num_snapshots = dump_result.num_snapshots();
1186   assert(num_snapshots == 0 || dump_result.t_list_has_been_set(), &quot;ThreadsList must have been set if we have a snapshot&quot;);
1187 
1188   // create the result ThreadInfo[] object
1189   InstanceKlass* ik = Management::java_lang_management_ThreadInfo_klass(CHECK_NULL);
1190   objArrayOop r = oopFactory::new_objArray(ik, num_snapshots, CHECK_NULL);
1191   objArrayHandle result_h(THREAD, r);
1192 
1193   int index = 0;
1194   for (ThreadSnapshot* ts = dump_result.snapshots(); ts != NULL; ts = ts-&gt;next(), index++) {
1195     if (ts-&gt;threadObj() == NULL) {
1196      // if the thread does not exist or now it is terminated, set threadinfo to NULL
1197       result_h-&gt;obj_at_put(index, NULL);
1198       continue;
1199     }
1200 
1201     ThreadStackTrace* stacktrace = ts-&gt;get_stack_trace();
1202     assert(stacktrace != NULL, &quot;Must have a stack trace dumped&quot;);
1203 
1204     // Create Object[] filled with locked monitors
1205     // Create int[] filled with the stack depth where a monitor was locked
1206     int num_frames = stacktrace-&gt;get_stack_depth();
1207     int num_locked_monitors = stacktrace-&gt;num_jni_locked_monitors();
1208 
1209     // Count the total number of locked monitors
1210     for (int i = 0; i &lt; num_frames; i++) {
1211       StackFrameInfo* frame = stacktrace-&gt;stack_frame_at(i);
1212       num_locked_monitors += frame-&gt;num_locked_monitors();
1213     }
1214 
1215     objArrayHandle monitors_array;
1216     typeArrayHandle depths_array;
1217     objArrayHandle synchronizers_array;
1218 
1219     if (locked_monitors) {
1220       // Constructs Object[] and int[] to contain the object monitor and the stack depth
1221       // where the thread locked it
1222       objArrayOop array = oopFactory::new_objArray(SystemDictionary::Object_klass(), num_locked_monitors, CHECK_NULL);
1223       objArrayHandle mh(THREAD, array);
1224       monitors_array = mh;
1225 
1226       typeArrayOop tarray = oopFactory::new_typeArray(T_INT, num_locked_monitors, CHECK_NULL);
1227       typeArrayHandle dh(THREAD, tarray);
1228       depths_array = dh;
1229 
1230       int count = 0;
1231       int j = 0;
1232       for (int depth = 0; depth &lt; num_frames; depth++) {
1233         StackFrameInfo* frame = stacktrace-&gt;stack_frame_at(depth);
1234         int len = frame-&gt;num_locked_monitors();
1235         GrowableArray&lt;oop&gt;* locked_monitors = frame-&gt;locked_monitors();
1236         for (j = 0; j &lt; len; j++) {
1237           oop monitor = locked_monitors-&gt;at(j);
1238           assert(monitor != NULL, &quot;must be a Java object&quot;);
1239           monitors_array-&gt;obj_at_put(count, monitor);
1240           depths_array-&gt;int_at_put(count, depth);
1241           count++;
1242         }
1243       }
1244 
1245       GrowableArray&lt;oop&gt;* jni_locked_monitors = stacktrace-&gt;jni_locked_monitors();
1246       for (j = 0; j &lt; jni_locked_monitors-&gt;length(); j++) {
1247         oop object = jni_locked_monitors-&gt;at(j);
1248         assert(object != NULL, &quot;must be a Java object&quot;);
1249         monitors_array-&gt;obj_at_put(count, object);
1250         // Monitor locked via JNI MonitorEnter call doesn&#39;t have stack depth info
1251         depths_array-&gt;int_at_put(count, -1);
1252         count++;
1253       }
1254       assert(count == num_locked_monitors, &quot;number of locked monitors doesn&#39;t match&quot;);
1255     }
1256 
1257     if (locked_synchronizers) {
1258       // Create Object[] filled with locked JSR-166 synchronizers
1259       assert(ts-&gt;threadObj() != NULL, &quot;Must be a valid JavaThread&quot;);
1260       ThreadConcurrentLocks* tcl = ts-&gt;get_concurrent_locks();
1261       GrowableArray&lt;instanceOop&gt;* locks = (tcl != NULL ? tcl-&gt;owned_locks() : NULL);
1262       int num_locked_synchronizers = (locks != NULL ? locks-&gt;length() : 0);
1263 
1264       objArrayOop array = oopFactory::new_objArray(SystemDictionary::Object_klass(), num_locked_synchronizers, CHECK_NULL);
1265       objArrayHandle sh(THREAD, array);
1266       synchronizers_array = sh;
1267 
1268       for (int k = 0; k &lt; num_locked_synchronizers; k++) {
1269         synchronizers_array-&gt;obj_at_put(k, locks-&gt;at(k));
1270       }
1271     }
1272 
1273     // Create java.lang.management.ThreadInfo object
1274     instanceOop info_obj = Management::create_thread_info_instance(ts,
1275                                                                    monitors_array,
1276                                                                    depths_array,
1277                                                                    synchronizers_array,
1278                                                                    CHECK_NULL);
1279     result_h-&gt;obj_at_put(index, info_obj);
1280   }
1281 
1282   return (jobjectArray) JNIHandles::make_local(env, result_h());
1283 JVM_END
1284 
1285 // Reset statistic.  Return true if the requested statistic is reset.
1286 // Otherwise, return false.
1287 //
1288 // Input parameters:
1289 //  obj  - specify which instance the statistic associated with to be reset
1290 //         For PEAK_POOL_USAGE stat, obj is required to be a memory pool object.
1291 //         For THREAD_CONTENTION_COUNT and TIME stat, obj is required to be a thread ID.
1292 //  type - the type of statistic to be reset
1293 //
1294 JVM_ENTRY(jboolean, jmm_ResetStatistic(JNIEnv *env, jvalue obj, jmmStatisticType type))
1295   ResourceMark rm(THREAD);
1296 
1297   switch (type) {
1298     case JMM_STAT_PEAK_THREAD_COUNT:
1299       ThreadService::reset_peak_thread_count();
1300       return true;
1301 
1302     case JMM_STAT_THREAD_CONTENTION_COUNT:
1303     case JMM_STAT_THREAD_CONTENTION_TIME: {
1304       jlong tid = obj.j;
1305       if (tid &lt; 0) {
1306         THROW_(vmSymbols::java_lang_IllegalArgumentException(), JNI_FALSE);
1307       }
1308 
1309       // Look for the JavaThread of this given tid
1310       JavaThreadIteratorWithHandle jtiwh;
1311       if (tid == 0) {
1312         // reset contention statistics for all threads if tid == 0
1313         for (; JavaThread *java_thread = jtiwh.next(); ) {
1314           if (type == JMM_STAT_THREAD_CONTENTION_COUNT) {
1315             ThreadService::reset_contention_count_stat(java_thread);
1316           } else {
1317             ThreadService::reset_contention_time_stat(java_thread);
1318           }
1319         }
1320       } else {
1321         // reset contention statistics for a given thread
1322         JavaThread* java_thread = jtiwh.list()-&gt;find_JavaThread_from_java_tid(tid);
1323         if (java_thread == NULL) {
1324           return false;
1325         }
1326 
1327         if (type == JMM_STAT_THREAD_CONTENTION_COUNT) {
1328           ThreadService::reset_contention_count_stat(java_thread);
1329         } else {
1330           ThreadService::reset_contention_time_stat(java_thread);
1331         }
1332       }
1333       return true;
1334       break;
1335     }
1336     case JMM_STAT_PEAK_POOL_USAGE: {
1337       jobject o = obj.l;
1338       if (o == NULL) {
1339         THROW_(vmSymbols::java_lang_NullPointerException(), JNI_FALSE);
1340       }
1341 
1342       oop pool_obj = JNIHandles::resolve(o);
1343       assert(pool_obj-&gt;is_instance(), &quot;Should be an instanceOop&quot;);
1344       instanceHandle ph(THREAD, (instanceOop) pool_obj);
1345 
1346       MemoryPool* pool = MemoryService::get_memory_pool(ph);
1347       if (pool != NULL) {
1348         pool-&gt;reset_peak_memory_usage();
1349         return true;
1350       }
1351       break;
1352     }
1353     case JMM_STAT_GC_STAT: {
1354       jobject o = obj.l;
1355       if (o == NULL) {
1356         THROW_(vmSymbols::java_lang_NullPointerException(), JNI_FALSE);
1357       }
1358 
<a name="1" id="anc1"></a><span class="line-modified">1359       GCMemoryManager* mgr = get_gc_memory_manager_from_jobject(o, CHECK_0);</span>
1360       if (mgr != NULL) {
1361         mgr-&gt;reset_gc_stat();
1362         return true;
1363       }
1364       break;
1365     }
1366     default:
1367       assert(0, &quot;Unknown Statistic Type&quot;);
1368   }
1369   return false;
1370 JVM_END
1371 
1372 // Returns the fast estimate of CPU time consumed by
1373 // a given thread (in nanoseconds).
1374 // If thread_id == 0, return CPU time for the current thread.
1375 JVM_ENTRY(jlong, jmm_GetThreadCpuTime(JNIEnv *env, jlong thread_id))
1376   if (!os::is_thread_cpu_time_supported()) {
1377     return -1;
1378   }
1379 
1380   if (thread_id &lt; 0) {
1381     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
1382                &quot;Invalid thread ID&quot;, -1);
1383   }
1384 
1385   JavaThread* java_thread = NULL;
1386   if (thread_id == 0) {
1387     // current thread
1388     return os::current_thread_cpu_time();
1389   } else {
1390     ThreadsListHandle tlh;
1391     java_thread = tlh.list()-&gt;find_JavaThread_from_java_tid(thread_id);
1392     if (java_thread != NULL) {
1393       return os::thread_cpu_time((Thread*) java_thread);
1394     }
1395   }
1396   return -1;
1397 JVM_END
1398 
1399 // Returns a String array of all VM global flag names
1400 JVM_ENTRY(jobjectArray, jmm_GetVMGlobalNames(JNIEnv *env))
1401   // last flag entry is always NULL, so subtract 1
1402   int nFlags = (int) JVMFlag::numFlags - 1;
1403   // allocate a temp array
1404   objArrayOop r = oopFactory::new_objArray(SystemDictionary::String_klass(),
<a name="2" id="anc2"></a><span class="line-modified">1405                                            nFlags, CHECK_0);</span>
1406   objArrayHandle flags_ah(THREAD, r);
1407   int num_entries = 0;
1408   for (int i = 0; i &lt; nFlags; i++) {
1409     JVMFlag* flag = &amp;JVMFlag::flags[i];
1410     // Exclude notproduct and develop flags in product builds.
1411     if (flag-&gt;is_constant_in_binary()) {
1412       continue;
1413     }
1414     // Exclude the locked (experimental, diagnostic) flags
1415     if (flag-&gt;is_unlocked() || flag-&gt;is_unlocker()) {
<a name="3" id="anc3"></a><span class="line-modified">1416       Handle s = java_lang_String::create_from_str(flag-&gt;_name, CHECK_0);</span>
1417       flags_ah-&gt;obj_at_put(num_entries, s());
1418       num_entries++;
1419     }
1420   }
1421 
1422   if (num_entries &lt; nFlags) {
1423     // Return array of right length
<a name="4" id="anc4"></a><span class="line-modified">1424     objArrayOop res = oopFactory::new_objArray(SystemDictionary::String_klass(), num_entries, CHECK_0);</span>
1425     for(int i = 0; i &lt; num_entries; i++) {
1426       res-&gt;obj_at_put(i, flags_ah-&gt;obj_at(i));
1427     }
1428     return (jobjectArray)JNIHandles::make_local(env, res);
1429   }
1430 
1431   return (jobjectArray)JNIHandles::make_local(env, flags_ah());
1432 JVM_END
1433 
1434 // Utility function used by jmm_GetVMGlobals.  Returns false if flag type
1435 // can&#39;t be determined, true otherwise.  If false is returned, then *global
1436 // will be incomplete and invalid.
1437 bool add_global_entry(JNIEnv* env, Handle name, jmmVMGlobal *global, JVMFlag *flag, TRAPS) {
1438   Handle flag_name;
1439   if (name() == NULL) {
1440     flag_name = java_lang_String::create_from_str(flag-&gt;_name, CHECK_false);
1441   } else {
1442     flag_name = name;
1443   }
1444   global-&gt;name = (jstring)JNIHandles::make_local(env, flag_name());
1445 
1446   if (flag-&gt;is_bool()) {
1447     global-&gt;value.z = flag-&gt;get_bool() ? JNI_TRUE : JNI_FALSE;
1448     global-&gt;type = JMM_VMGLOBAL_TYPE_JBOOLEAN;
1449   } else if (flag-&gt;is_int()) {
1450     global-&gt;value.j = (jlong)flag-&gt;get_int();
1451     global-&gt;type = JMM_VMGLOBAL_TYPE_JLONG;
1452   } else if (flag-&gt;is_uint()) {
1453     global-&gt;value.j = (jlong)flag-&gt;get_uint();
1454     global-&gt;type = JMM_VMGLOBAL_TYPE_JLONG;
1455   } else if (flag-&gt;is_intx()) {
1456     global-&gt;value.j = (jlong)flag-&gt;get_intx();
1457     global-&gt;type = JMM_VMGLOBAL_TYPE_JLONG;
1458   } else if (flag-&gt;is_uintx()) {
1459     global-&gt;value.j = (jlong)flag-&gt;get_uintx();
1460     global-&gt;type = JMM_VMGLOBAL_TYPE_JLONG;
1461   } else if (flag-&gt;is_uint64_t()) {
1462     global-&gt;value.j = (jlong)flag-&gt;get_uint64_t();
1463     global-&gt;type = JMM_VMGLOBAL_TYPE_JLONG;
1464   } else if (flag-&gt;is_double()) {
1465     global-&gt;value.d = (jdouble)flag-&gt;get_double();
1466     global-&gt;type = JMM_VMGLOBAL_TYPE_JDOUBLE;
1467   } else if (flag-&gt;is_size_t()) {
1468     global-&gt;value.j = (jlong)flag-&gt;get_size_t();
1469     global-&gt;type = JMM_VMGLOBAL_TYPE_JLONG;
1470   } else if (flag-&gt;is_ccstr()) {
1471     Handle str = java_lang_String::create_from_str(flag-&gt;get_ccstr(), CHECK_false);
1472     global-&gt;value.l = (jobject)JNIHandles::make_local(env, str());
1473     global-&gt;type = JMM_VMGLOBAL_TYPE_JSTRING;
1474   } else {
1475     global-&gt;type = JMM_VMGLOBAL_TYPE_UNKNOWN;
1476     return false;
1477   }
1478 
1479   global-&gt;writeable = flag-&gt;is_writeable();
1480   global-&gt;external = flag-&gt;is_external();
1481   switch (flag-&gt;get_origin()) {
1482     case JVMFlag::DEFAULT:
1483       global-&gt;origin = JMM_VMGLOBAL_ORIGIN_DEFAULT;
1484       break;
1485     case JVMFlag::COMMAND_LINE:
1486       global-&gt;origin = JMM_VMGLOBAL_ORIGIN_COMMAND_LINE;
1487       break;
1488     case JVMFlag::ENVIRON_VAR:
1489       global-&gt;origin = JMM_VMGLOBAL_ORIGIN_ENVIRON_VAR;
1490       break;
1491     case JVMFlag::CONFIG_FILE:
1492       global-&gt;origin = JMM_VMGLOBAL_ORIGIN_CONFIG_FILE;
1493       break;
1494     case JVMFlag::MANAGEMENT:
1495       global-&gt;origin = JMM_VMGLOBAL_ORIGIN_MANAGEMENT;
1496       break;
1497     case JVMFlag::ERGONOMIC:
1498       global-&gt;origin = JMM_VMGLOBAL_ORIGIN_ERGONOMIC;
1499       break;
1500     case JVMFlag::ATTACH_ON_DEMAND:
1501       global-&gt;origin = JMM_VMGLOBAL_ORIGIN_ATTACH_ON_DEMAND;
1502       break;
1503     default:
1504       global-&gt;origin = JMM_VMGLOBAL_ORIGIN_OTHER;
1505   }
1506 
1507   return true;
1508 }
1509 
1510 // Fill globals array of count length with jmmVMGlobal entries
1511 // specified by names. If names == NULL, fill globals array
1512 // with all Flags. Return value is number of entries
1513 // created in globals.
1514 // If a JVMFlag with a given name in an array element does not
1515 // exist, globals[i].name will be set to NULL.
1516 JVM_ENTRY(jint, jmm_GetVMGlobals(JNIEnv *env,
1517                                  jobjectArray names,
1518                                  jmmVMGlobal *globals,
1519                                  jint count))
1520 
1521 
1522   if (globals == NULL) {
1523     THROW_(vmSymbols::java_lang_NullPointerException(), 0);
1524   }
1525 
1526   ResourceMark rm(THREAD);
1527 
1528   if (names != NULL) {
1529     // return the requested globals
1530     objArrayOop ta = objArrayOop(JNIHandles::resolve_non_null(names));
1531     objArrayHandle names_ah(THREAD, ta);
1532     // Make sure we have a String array
1533     Klass* element_klass = ObjArrayKlass::cast(names_ah-&gt;klass())-&gt;element_klass();
1534     if (element_klass != SystemDictionary::String_klass()) {
1535       THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
1536                  &quot;Array element type is not String class&quot;, 0);
1537     }
1538 
1539     int names_length = names_ah-&gt;length();
1540     int num_entries = 0;
1541     for (int i = 0; i &lt; names_length &amp;&amp; i &lt; count; i++) {
1542       oop s = names_ah-&gt;obj_at(i);
1543       if (s == NULL) {
1544         THROW_(vmSymbols::java_lang_NullPointerException(), 0);
1545       }
1546 
1547       Handle sh(THREAD, s);
1548       char* str = java_lang_String::as_utf8_string(s);
1549       JVMFlag* flag = JVMFlag::find_flag(str);
1550       if (flag != NULL &amp;&amp;
1551           add_global_entry(env, sh, &amp;globals[i], flag, THREAD)) {
1552         num_entries++;
1553       } else {
1554         globals[i].name = NULL;
1555       }
1556     }
1557     return num_entries;
1558   } else {
1559     // return all globals if names == NULL
1560 
1561     // last flag entry is always NULL, so subtract 1
1562     int nFlags = (int) JVMFlag::numFlags - 1;
1563     Handle null_h;
1564     int num_entries = 0;
1565     for (int i = 0; i &lt; nFlags &amp;&amp; num_entries &lt; count;  i++) {
1566       JVMFlag* flag = &amp;JVMFlag::flags[i];
1567       // Exclude notproduct and develop flags in product builds.
1568       if (flag-&gt;is_constant_in_binary()) {
1569         continue;
1570       }
1571       // Exclude the locked (diagnostic, experimental) flags
1572       if ((flag-&gt;is_unlocked() || flag-&gt;is_unlocker()) &amp;&amp;
1573           add_global_entry(env, null_h, &amp;globals[num_entries], flag, THREAD)) {
1574         num_entries++;
1575       }
1576     }
1577     return num_entries;
1578   }
1579 JVM_END
1580 
1581 JVM_ENTRY(void, jmm_SetVMGlobal(JNIEnv *env, jstring flag_name, jvalue new_value))
1582   ResourceMark rm(THREAD);
1583 
1584   oop fn = JNIHandles::resolve_external_guard(flag_name);
1585   if (fn == NULL) {
1586     THROW_MSG(vmSymbols::java_lang_NullPointerException(),
1587               &quot;The flag name cannot be null.&quot;);
1588   }
1589   char* name = java_lang_String::as_utf8_string(fn);
1590 
1591   FormatBuffer&lt;80&gt; error_msg(&quot;%s&quot;, &quot;&quot;);
1592   int succeed = WriteableFlags::set_flag(name, new_value, JVMFlag::MANAGEMENT, error_msg);
1593 
1594   if (succeed != JVMFlag::SUCCESS) {
1595     if (succeed == JVMFlag::MISSING_VALUE) {
1596       // missing value causes NPE to be thrown
1597       THROW(vmSymbols::java_lang_NullPointerException());
1598     } else {
1599       // all the other errors are reported as IAE with the appropriate error message
1600       THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
1601                 error_msg.buffer());
1602     }
1603   }
1604   assert(succeed == JVMFlag::SUCCESS, &quot;Setting flag should succeed&quot;);
1605 JVM_END
1606 
1607 class ThreadTimesClosure: public ThreadClosure {
1608  private:
1609   objArrayHandle _names_strings;
1610   char **_names_chars;
1611   typeArrayHandle _times;
1612   int _names_len;
1613   int _times_len;
1614   int _count;
1615 
1616  public:
1617   ThreadTimesClosure(objArrayHandle names, typeArrayHandle times);
1618   ~ThreadTimesClosure();
1619   virtual void do_thread(Thread* thread);
1620   void do_unlocked();
1621   int count() { return _count; }
1622 };
1623 
1624 ThreadTimesClosure::ThreadTimesClosure(objArrayHandle names,
1625                                        typeArrayHandle times) {
1626   assert(names() != NULL, &quot;names was NULL&quot;);
1627   assert(times() != NULL, &quot;times was NULL&quot;);
1628   _names_strings = names;
1629   _names_len = names-&gt;length();
1630   _names_chars = NEW_C_HEAP_ARRAY(char*, _names_len, mtInternal);
1631   _times = times;
1632   _times_len = times-&gt;length();
1633   _count = 0;
1634 }
1635 
1636 //
1637 // Called with Threads_lock held
1638 //
1639 void ThreadTimesClosure::do_thread(Thread* thread) {
1640   assert(Threads_lock-&gt;owned_by_self(), &quot;Must hold Threads_lock&quot;);
1641   assert(thread != NULL, &quot;thread was NULL&quot;);
1642 
1643   // exclude externally visible JavaThreads
1644   if (thread-&gt;is_Java_thread() &amp;&amp; !thread-&gt;is_hidden_from_external_view()) {
1645     return;
1646   }
1647 
1648   if (_count &gt;= _names_len || _count &gt;= _times_len) {
1649     // skip if the result array is not big enough
1650     return;
1651   }
1652 
1653   EXCEPTION_MARK;
1654   ResourceMark rm(THREAD); // thread-&gt;name() uses ResourceArea
1655 
1656   assert(thread-&gt;name() != NULL, &quot;All threads should have a name&quot;);
1657   _names_chars[_count] = os::strdup(thread-&gt;name());
1658   _times-&gt;long_at_put(_count, os::is_thread_cpu_time_supported() ?
1659                         os::thread_cpu_time(thread) : -1);
1660   _count++;
1661 }
1662 
1663 // Called without Threads_lock, we can allocate String objects.
1664 void ThreadTimesClosure::do_unlocked() {
1665 
1666   EXCEPTION_MARK;
1667   for (int i = 0; i &lt; _count; i++) {
1668     Handle s = java_lang_String::create_from_str(_names_chars[i],  CHECK);
1669     _names_strings-&gt;obj_at_put(i, s());
1670   }
1671 }
1672 
1673 ThreadTimesClosure::~ThreadTimesClosure() {
1674   for (int i = 0; i &lt; _count; i++) {
1675     os::free(_names_chars[i]);
1676   }
1677   FREE_C_HEAP_ARRAY(char *, _names_chars);
1678 }
1679 
1680 // Fills names with VM internal thread names and times with the corresponding
1681 // CPU times.  If names or times is NULL, a NullPointerException is thrown.
1682 // If the element type of names is not String, an IllegalArgumentException is
1683 // thrown.
1684 // If an array is not large enough to hold all the entries, only the entries
1685 // that fit will be returned.  Return value is the number of VM internal
1686 // threads entries.
1687 JVM_ENTRY(jint, jmm_GetInternalThreadTimes(JNIEnv *env,
1688                                            jobjectArray names,
1689                                            jlongArray times))
1690   if (names == NULL || times == NULL) {
1691      THROW_(vmSymbols::java_lang_NullPointerException(), 0);
1692   }
1693   objArrayOop na = objArrayOop(JNIHandles::resolve_non_null(names));
1694   objArrayHandle names_ah(THREAD, na);
1695 
1696   // Make sure we have a String array
1697   Klass* element_klass = ObjArrayKlass::cast(names_ah-&gt;klass())-&gt;element_klass();
1698   if (element_klass != SystemDictionary::String_klass()) {
1699     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
1700                &quot;Array element type is not String class&quot;, 0);
1701   }
1702 
1703   typeArrayOop ta = typeArrayOop(JNIHandles::resolve_non_null(times));
1704   typeArrayHandle times_ah(THREAD, ta);
1705 
1706   ThreadTimesClosure ttc(names_ah, times_ah);
1707   {
1708     MutexLocker ml(THREAD, Threads_lock);
1709     Threads::threads_do(&amp;ttc);
1710   }
1711   ttc.do_unlocked();
1712   return ttc.count();
1713 JVM_END
1714 
1715 static Handle find_deadlocks(bool object_monitors_only, TRAPS) {
1716   ResourceMark rm(THREAD);
1717 
1718   VM_FindDeadlocks op(!object_monitors_only /* also check concurrent locks? */);
1719   VMThread::execute(&amp;op);
1720 
1721   DeadlockCycle* deadlocks = op.result();
1722   if (deadlocks == NULL) {
1723     // no deadlock found and return
1724     return Handle();
1725   }
1726 
1727   int num_threads = 0;
1728   DeadlockCycle* cycle;
1729   for (cycle = deadlocks; cycle != NULL; cycle = cycle-&gt;next()) {
1730     num_threads += cycle-&gt;num_threads();
1731   }
1732 
1733   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Thread_klass(), num_threads, CHECK_NH);
1734   objArrayHandle threads_ah(THREAD, r);
1735 
1736   int index = 0;
1737   for (cycle = deadlocks; cycle != NULL; cycle = cycle-&gt;next()) {
1738     GrowableArray&lt;JavaThread*&gt;* deadlock_threads = cycle-&gt;threads();
1739     int len = deadlock_threads-&gt;length();
1740     for (int i = 0; i &lt; len; i++) {
1741       threads_ah-&gt;obj_at_put(index, deadlock_threads-&gt;at(i)-&gt;threadObj());
1742       index++;
1743     }
1744   }
1745   return threads_ah;
1746 }
1747 
1748 // Finds cycles of threads that are deadlocked involved in object monitors
1749 // and JSR-166 synchronizers.
1750 // Returns an array of Thread objects which are in deadlock, if any.
1751 // Otherwise, returns NULL.
1752 //
1753 // Input parameter:
1754 //    object_monitors_only - if true, only check object monitors
1755 //
1756 JVM_ENTRY(jobjectArray, jmm_FindDeadlockedThreads(JNIEnv *env, jboolean object_monitors_only))
<a name="5" id="anc5"></a><span class="line-modified">1757   Handle result = find_deadlocks(object_monitors_only != 0, CHECK_0);</span>
1758   return (jobjectArray) JNIHandles::make_local(env, result());
1759 JVM_END
1760 
1761 // Finds cycles of threads that are deadlocked on monitor locks
1762 // Returns an array of Thread objects which are in deadlock, if any.
1763 // Otherwise, returns NULL.
1764 JVM_ENTRY(jobjectArray, jmm_FindMonitorDeadlockedThreads(JNIEnv *env))
<a name="6" id="anc6"></a><span class="line-modified">1765   Handle result = find_deadlocks(true, CHECK_0);</span>
1766   return (jobjectArray) JNIHandles::make_local(env, result());
1767 JVM_END
1768 
1769 // Gets the information about GC extension attributes including
1770 // the name of the attribute, its type, and a short description.
1771 //
1772 // Input parameters:
1773 //   mgr   - GC memory manager
1774 //   info  - caller allocated array of jmmExtAttributeInfo
1775 //   count - number of elements of the info array
1776 //
1777 // Returns the number of GC extension attributes filled in the info array; or
1778 // -1 if info is not big enough
1779 //
1780 JVM_ENTRY(jint, jmm_GetGCExtAttributeInfo(JNIEnv *env, jobject mgr, jmmExtAttributeInfo* info, jint count))
1781   // All GC memory managers have 1 attribute (number of GC threads)
1782   if (count == 0) {
1783     return 0;
1784   }
1785 
1786   if (info == NULL) {
1787    THROW_(vmSymbols::java_lang_NullPointerException(), 0);
1788   }
1789 
1790   info[0].name = &quot;GcThreadCount&quot;;
1791   info[0].type = &#39;I&#39;;
1792   info[0].description = &quot;Number of GC threads&quot;;
1793   return 1;
1794 JVM_END
1795 
1796 // verify the given array is an array of java/lang/management/MemoryUsage objects
1797 // of a given length and return the objArrayOop
1798 static objArrayOop get_memory_usage_objArray(jobjectArray array, int length, TRAPS) {
1799   if (array == NULL) {
1800     THROW_(vmSymbols::java_lang_NullPointerException(), 0);
1801   }
1802 
1803   objArrayOop oa = objArrayOop(JNIHandles::resolve_non_null(array));
1804   objArrayHandle array_h(THREAD, oa);
1805 
1806   // array must be of the given length
1807   if (length != array_h-&gt;length()) {
1808     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
1809                &quot;The length of the given MemoryUsage array does not match the number of memory pools.&quot;, 0);
1810   }
1811 
1812   // check if the element of array is of type MemoryUsage class
<a name="7" id="anc7"></a><span class="line-modified">1813   Klass* usage_klass = Management::java_lang_management_MemoryUsage_klass(CHECK_0);</span>
1814   Klass* element_klass = ObjArrayKlass::cast(array_h-&gt;klass())-&gt;element_klass();
1815   if (element_klass != usage_klass) {
1816     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
1817                &quot;The element type is not MemoryUsage class&quot;, 0);
1818   }
1819 
1820   return array_h();
1821 }
1822 
1823 // Gets the statistics of the last GC of a given GC memory manager.
1824 // Input parameters:
1825 //   obj     - GarbageCollectorMXBean object
1826 //   gc_stat - caller allocated jmmGCStat where:
1827 //     a. before_gc_usage - array of MemoryUsage objects
1828 //     b. after_gc_usage  - array of MemoryUsage objects
1829 //     c. gc_ext_attributes_values_size is set to the
1830 //        gc_ext_attribute_values array allocated
1831 //     d. gc_ext_attribute_values is a caller allocated array of jvalue.
1832 //
1833 // On return,
1834 //   gc_index == 0 indicates no GC statistics available
1835 //
1836 //   before_gc_usage and after_gc_usage - filled with per memory pool
1837 //      before and after GC usage in the same order as the memory pools
1838 //      returned by GetMemoryPools for a given GC memory manager.
1839 //   num_gc_ext_attributes indicates the number of elements in
1840 //      the gc_ext_attribute_values array is filled; or
1841 //      -1 if the gc_ext_attributes_values array is not big enough
1842 //
1843 JVM_ENTRY(void, jmm_GetLastGCStat(JNIEnv *env, jobject obj, jmmGCStat *gc_stat))
1844   ResourceMark rm(THREAD);
1845 
1846   if (gc_stat-&gt;gc_ext_attribute_values_size &gt; 0 &amp;&amp; gc_stat-&gt;gc_ext_attribute_values == NULL) {
1847     THROW(vmSymbols::java_lang_NullPointerException());
1848   }
1849 
1850   // Get the GCMemoryManager
1851   GCMemoryManager* mgr = get_gc_memory_manager_from_jobject(obj, CHECK);
1852 
1853   // Make a copy of the last GC statistics
1854   // GC may occur while constructing the last GC information
1855   int num_pools = MemoryService::num_memory_pools();
1856   GCStatInfo stat(num_pools);
1857   if (mgr-&gt;get_last_gc_stat(&amp;stat) == 0) {
1858     gc_stat-&gt;gc_index = 0;
1859     return;
1860   }
1861 
1862   gc_stat-&gt;gc_index = stat.gc_index();
1863   gc_stat-&gt;start_time = Management::ticks_to_ms(stat.start_time());
1864   gc_stat-&gt;end_time = Management::ticks_to_ms(stat.end_time());
1865 
1866   // Current implementation does not have GC extension attributes
1867   gc_stat-&gt;num_gc_ext_attributes = 0;
1868 
1869   // Fill the arrays of MemoryUsage objects with before and after GC
1870   // per pool memory usage
1871   objArrayOop bu = get_memory_usage_objArray(gc_stat-&gt;usage_before_gc,
1872                                              num_pools,
1873                                              CHECK);
1874   objArrayHandle usage_before_gc_ah(THREAD, bu);
1875 
1876   objArrayOop au = get_memory_usage_objArray(gc_stat-&gt;usage_after_gc,
1877                                              num_pools,
1878                                              CHECK);
1879   objArrayHandle usage_after_gc_ah(THREAD, au);
1880 
1881   for (int i = 0; i &lt; num_pools; i++) {
1882     Handle before_usage = MemoryService::create_MemoryUsage_obj(stat.before_gc_usage_for_pool(i), CHECK);
1883     Handle after_usage;
1884 
1885     MemoryUsage u = stat.after_gc_usage_for_pool(i);
1886     if (u.max_size() == 0 &amp;&amp; u.used() &gt; 0) {
1887       // If max size == 0, this pool is a survivor space.
1888       // Set max size = -1 since the pools will be swapped after GC.
1889       MemoryUsage usage(u.init_size(), u.used(), u.committed(), (size_t)-1);
1890       after_usage = MemoryService::create_MemoryUsage_obj(usage, CHECK);
1891     } else {
1892       after_usage = MemoryService::create_MemoryUsage_obj(stat.after_gc_usage_for_pool(i), CHECK);
1893     }
1894     usage_before_gc_ah-&gt;obj_at_put(i, before_usage());
1895     usage_after_gc_ah-&gt;obj_at_put(i, after_usage());
1896   }
1897 
1898   if (gc_stat-&gt;gc_ext_attribute_values_size &gt; 0) {
1899     // Current implementation only has 1 attribute (number of GC threads)
1900     // The type is &#39;I&#39;
1901     gc_stat-&gt;gc_ext_attribute_values[0].i = mgr-&gt;num_gc_threads();
1902   }
1903 JVM_END
1904 
1905 JVM_ENTRY(void, jmm_SetGCNotificationEnabled(JNIEnv *env, jobject obj, jboolean enabled))
1906   ResourceMark rm(THREAD);
1907   // Get the GCMemoryManager
1908   GCMemoryManager* mgr = get_gc_memory_manager_from_jobject(obj, CHECK);
1909   mgr-&gt;set_notification_enabled(enabled?true:false);
1910 JVM_END
1911 
1912 // Dump heap - Returns 0 if succeeds.
1913 JVM_ENTRY(jint, jmm_DumpHeap0(JNIEnv *env, jstring outputfile, jboolean live))
1914 #if INCLUDE_SERVICES
1915   ResourceMark rm(THREAD);
1916   oop on = JNIHandles::resolve_external_guard(outputfile);
1917   if (on == NULL) {
1918     THROW_MSG_(vmSymbols::java_lang_NullPointerException(),
1919                &quot;Output file name cannot be null.&quot;, -1);
1920   }
1921   Handle onhandle(THREAD, on);
1922   char* name = java_lang_String::as_platform_dependent_str(onhandle, CHECK_(-1));
1923   if (name == NULL) {
1924     THROW_MSG_(vmSymbols::java_lang_NullPointerException(),
1925                &quot;Output file name cannot be null.&quot;, -1);
1926   }
1927   HeapDumper dumper(live ? true : false);
1928   if (dumper.dump(name) != 0) {
1929     const char* errmsg = dumper.error_as_C_string();
1930     THROW_MSG_(vmSymbols::java_io_IOException(), errmsg, -1);
1931   }
1932   return 0;
1933 #else  // INCLUDE_SERVICES
1934   return -1;
1935 #endif // INCLUDE_SERVICES
1936 JVM_END
1937 
1938 JVM_ENTRY(jobjectArray, jmm_GetDiagnosticCommands(JNIEnv *env))
1939   ResourceMark rm(THREAD);
1940   GrowableArray&lt;const char *&gt;* dcmd_list = DCmdFactory::DCmd_list(DCmd_Source_MBean);
1941   objArrayOop cmd_array_oop = oopFactory::new_objArray(SystemDictionary::String_klass(),
1942           dcmd_list-&gt;length(), CHECK_NULL);
1943   objArrayHandle cmd_array(THREAD, cmd_array_oop);
1944   for (int i = 0; i &lt; dcmd_list-&gt;length(); i++) {
1945     oop cmd_name = java_lang_String::create_oop_from_str(dcmd_list-&gt;at(i), CHECK_NULL);
1946     cmd_array-&gt;obj_at_put(i, cmd_name);
1947   }
1948   return (jobjectArray) JNIHandles::make_local(env, cmd_array());
1949 JVM_END
1950 
1951 JVM_ENTRY(void, jmm_GetDiagnosticCommandInfo(JNIEnv *env, jobjectArray cmds,
1952           dcmdInfo* infoArray))
1953   if (cmds == NULL || infoArray == NULL) {
1954     THROW(vmSymbols::java_lang_NullPointerException());
1955   }
1956 
1957   ResourceMark rm(THREAD);
1958 
1959   objArrayOop ca = objArrayOop(JNIHandles::resolve_non_null(cmds));
1960   objArrayHandle cmds_ah(THREAD, ca);
1961 
1962   // Make sure we have a String array
1963   Klass* element_klass = ObjArrayKlass::cast(cmds_ah-&gt;klass())-&gt;element_klass();
1964   if (element_klass != SystemDictionary::String_klass()) {
1965     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
1966                &quot;Array element type is not String class&quot;);
1967   }
1968 
1969   GrowableArray&lt;DCmdInfo *&gt;* info_list = DCmdFactory::DCmdInfo_list(DCmd_Source_MBean);
1970 
1971   int num_cmds = cmds_ah-&gt;length();
1972   for (int i = 0; i &lt; num_cmds; i++) {
1973     oop cmd = cmds_ah-&gt;obj_at(i);
1974     if (cmd == NULL) {
1975         THROW_MSG(vmSymbols::java_lang_NullPointerException(),
1976                 &quot;Command name cannot be null.&quot;);
1977     }
1978     char* cmd_name = java_lang_String::as_utf8_string(cmd);
1979     if (cmd_name == NULL) {
1980         THROW_MSG(vmSymbols::java_lang_NullPointerException(),
1981                 &quot;Command name cannot be null.&quot;);
1982     }
1983     int pos = info_list-&gt;find((void*)cmd_name,DCmdInfo::by_name);
1984     if (pos == -1) {
1985         THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
1986              &quot;Unknown diagnostic command&quot;);
1987     }
1988     DCmdInfo* info = info_list-&gt;at(pos);
1989     infoArray[i].name = info-&gt;name();
1990     infoArray[i].description = info-&gt;description();
1991     infoArray[i].impact = info-&gt;impact();
1992     JavaPermission p = info-&gt;permission();
1993     infoArray[i].permission_class = p._class;
1994     infoArray[i].permission_name = p._name;
1995     infoArray[i].permission_action = p._action;
1996     infoArray[i].num_arguments = info-&gt;num_arguments();
1997     infoArray[i].enabled = info-&gt;is_enabled();
1998   }
1999 JVM_END
2000 
2001 JVM_ENTRY(void, jmm_GetDiagnosticCommandArgumentsInfo(JNIEnv *env,
2002           jstring command, dcmdArgInfo* infoArray))
2003   ResourceMark rm(THREAD);
2004   oop cmd = JNIHandles::resolve_external_guard(command);
2005   if (cmd == NULL) {
2006     THROW_MSG(vmSymbols::java_lang_NullPointerException(),
2007               &quot;Command line cannot be null.&quot;);
2008   }
2009   char* cmd_name = java_lang_String::as_utf8_string(cmd);
2010   if (cmd_name == NULL) {
2011     THROW_MSG(vmSymbols::java_lang_NullPointerException(),
2012               &quot;Command line content cannot be null.&quot;);
2013   }
2014   DCmd* dcmd = NULL;
2015   DCmdFactory*factory = DCmdFactory::factory(DCmd_Source_MBean, cmd_name,
2016                                              strlen(cmd_name));
2017   if (factory != NULL) {
2018     dcmd = factory-&gt;create_resource_instance(NULL);
2019   }
2020   if (dcmd == NULL) {
2021     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
2022               &quot;Unknown diagnostic command&quot;);
2023   }
2024   DCmdMark mark(dcmd);
2025   GrowableArray&lt;DCmdArgumentInfo*&gt;* array = dcmd-&gt;argument_info_array();
2026   if (array-&gt;length() == 0) {
2027     return;
2028   }
2029   for (int i = 0; i &lt; array-&gt;length(); i++) {
2030     infoArray[i].name = array-&gt;at(i)-&gt;name();
2031     infoArray[i].description = array-&gt;at(i)-&gt;description();
2032     infoArray[i].type = array-&gt;at(i)-&gt;type();
2033     infoArray[i].default_string = array-&gt;at(i)-&gt;default_string();
2034     infoArray[i].mandatory = array-&gt;at(i)-&gt;is_mandatory();
2035     infoArray[i].option = array-&gt;at(i)-&gt;is_option();
2036     infoArray[i].multiple = array-&gt;at(i)-&gt;is_multiple();
2037     infoArray[i].position = array-&gt;at(i)-&gt;position();
2038   }
2039   return;
2040 JVM_END
2041 
2042 JVM_ENTRY(jstring, jmm_ExecuteDiagnosticCommand(JNIEnv *env, jstring commandline))
2043   ResourceMark rm(THREAD);
2044   oop cmd = JNIHandles::resolve_external_guard(commandline);
2045   if (cmd == NULL) {
2046     THROW_MSG_NULL(vmSymbols::java_lang_NullPointerException(),
2047                    &quot;Command line cannot be null.&quot;);
2048   }
2049   char* cmdline = java_lang_String::as_utf8_string(cmd);
2050   if (cmdline == NULL) {
2051     THROW_MSG_NULL(vmSymbols::java_lang_NullPointerException(),
2052                    &quot;Command line content cannot be null.&quot;);
2053   }
2054   bufferedStream output;
2055   DCmd::parse_and_execute(DCmd_Source_MBean, &amp;output, cmdline, &#39; &#39;, CHECK_NULL);
2056   oop result = java_lang_String::create_oop_from_str(output.as_string(), CHECK_NULL);
2057   return (jstring) JNIHandles::make_local(env, result);
2058 JVM_END
2059 
2060 JVM_ENTRY(void, jmm_SetDiagnosticFrameworkNotificationEnabled(JNIEnv *env, jboolean enabled))
2061   DCmdFactory::set_jmx_notification_enabled(enabled?true:false);
2062 JVM_END
2063 
2064 jlong Management::ticks_to_ms(jlong ticks) {
2065   assert(os::elapsed_frequency() &gt; 0, &quot;Must be non-zero&quot;);
2066   return (jlong)(((double)ticks / (double)os::elapsed_frequency())
2067                  * (double)1000.0);
2068 }
2069 #endif // INCLUDE_MANAGEMENT
2070 
2071 // Gets the amount of memory allocated on the Java heap for a single thread.
2072 // Returns -1 if the thread does not exist or has terminated.
2073 JVM_ENTRY(jlong, jmm_GetOneThreadAllocatedMemory(JNIEnv *env, jlong thread_id))
2074   if (thread_id &lt; 0) {
2075     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
2076                &quot;Invalid thread ID&quot;, -1);
2077   }
2078 
2079   if (thread_id == 0) {
2080     // current thread
2081     if (THREAD-&gt;is_Java_thread()) {
2082       return ((JavaThread*)THREAD)-&gt;cooked_allocated_bytes();
2083     }
2084     return -1;
2085   }
2086 
2087   ThreadsListHandle tlh;
2088   JavaThread* java_thread = tlh.list()-&gt;find_JavaThread_from_java_tid(thread_id);
2089 
2090   if (java_thread != NULL) {
2091     return java_thread-&gt;cooked_allocated_bytes();
2092   }
2093   return -1;
2094 JVM_END
2095 
2096 // Gets an array containing the amount of memory allocated on the Java
2097 // heap for a set of threads (in bytes).  Each element of the array is
2098 // the amount of memory allocated for the thread ID specified in the
2099 // corresponding entry in the given array of thread IDs; or -1 if the
2100 // thread does not exist or has terminated.
2101 JVM_ENTRY(void, jmm_GetThreadAllocatedMemory(JNIEnv *env, jlongArray ids,
2102                                              jlongArray sizeArray))
2103   // Check if threads is null
2104   if (ids == NULL || sizeArray == NULL) {
2105     THROW(vmSymbols::java_lang_NullPointerException());
2106   }
2107 
2108   ResourceMark rm(THREAD);
2109   typeArrayOop ta = typeArrayOop(JNIHandles::resolve_non_null(ids));
2110   typeArrayHandle ids_ah(THREAD, ta);
2111 
2112   typeArrayOop sa = typeArrayOop(JNIHandles::resolve_non_null(sizeArray));
2113   typeArrayHandle sizeArray_h(THREAD, sa);
2114 
2115   // validate the thread id array
2116   validate_thread_id_array(ids_ah, CHECK);
2117 
2118   // sizeArray must be of the same length as the given array of thread IDs
2119   int num_threads = ids_ah-&gt;length();
2120   if (num_threads != sizeArray_h-&gt;length()) {
2121     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
2122               &quot;The length of the given long array does not match the length of &quot;
2123               &quot;the given array of thread IDs&quot;);
2124   }
2125 
2126   ThreadsListHandle tlh;
2127   for (int i = 0; i &lt; num_threads; i++) {
2128     JavaThread* java_thread = tlh.list()-&gt;find_JavaThread_from_java_tid(ids_ah-&gt;long_at(i));
2129     if (java_thread != NULL) {
2130       sizeArray_h-&gt;long_at_put(i, java_thread-&gt;cooked_allocated_bytes());
2131     }
2132   }
2133 JVM_END
2134 
2135 // Returns the CPU time consumed by a given thread (in nanoseconds).
2136 // If thread_id == 0, CPU time for the current thread is returned.
2137 // If user_sys_cpu_time = true, user level and system CPU time of
2138 // a given thread is returned; otherwise, only user level CPU time
2139 // is returned.
2140 JVM_ENTRY(jlong, jmm_GetThreadCpuTimeWithKind(JNIEnv *env, jlong thread_id, jboolean user_sys_cpu_time))
2141   if (!os::is_thread_cpu_time_supported()) {
2142     return -1;
2143   }
2144 
2145   if (thread_id &lt; 0) {
2146     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),
2147                &quot;Invalid thread ID&quot;, -1);
2148   }
2149 
2150   JavaThread* java_thread = NULL;
2151   if (thread_id == 0) {
2152     // current thread
2153     return os::current_thread_cpu_time(user_sys_cpu_time != 0);
2154   } else {
2155     ThreadsListHandle tlh;
2156     java_thread = tlh.list()-&gt;find_JavaThread_from_java_tid(thread_id);
2157     if (java_thread != NULL) {
2158       return os::thread_cpu_time((Thread*) java_thread, user_sys_cpu_time != 0);
2159     }
2160   }
2161   return -1;
2162 JVM_END
2163 
2164 // Gets an array containing the CPU times consumed by a set of threads
2165 // (in nanoseconds).  Each element of the array is the CPU time for the
2166 // thread ID specified in the corresponding entry in the given array
2167 // of thread IDs; or -1 if the thread does not exist or has terminated.
2168 // If user_sys_cpu_time = true, the sum of user level and system CPU time
2169 // for the given thread is returned; otherwise, only user level CPU time
2170 // is returned.
2171 JVM_ENTRY(void, jmm_GetThreadCpuTimesWithKind(JNIEnv *env, jlongArray ids,
2172                                               jlongArray timeArray,
2173                                               jboolean user_sys_cpu_time))
2174   // Check if threads is null
2175   if (ids == NULL || timeArray == NULL) {
2176     THROW(vmSymbols::java_lang_NullPointerException());
2177   }
2178 
2179   ResourceMark rm(THREAD);
2180   typeArrayOop ta = typeArrayOop(JNIHandles::resolve_non_null(ids));
2181   typeArrayHandle ids_ah(THREAD, ta);
2182 
2183   typeArrayOop tia = typeArrayOop(JNIHandles::resolve_non_null(timeArray));
2184   typeArrayHandle timeArray_h(THREAD, tia);
2185 
2186   // validate the thread id array
2187   validate_thread_id_array(ids_ah, CHECK);
2188 
2189   // timeArray must be of the same length as the given array of thread IDs
2190   int num_threads = ids_ah-&gt;length();
2191   if (num_threads != timeArray_h-&gt;length()) {
2192     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
2193               &quot;The length of the given long array does not match the length of &quot;
2194               &quot;the given array of thread IDs&quot;);
2195   }
2196 
2197   ThreadsListHandle tlh;
2198   for (int i = 0; i &lt; num_threads; i++) {
2199     JavaThread* java_thread = tlh.list()-&gt;find_JavaThread_from_java_tid(ids_ah-&gt;long_at(i));
2200     if (java_thread != NULL) {
2201       timeArray_h-&gt;long_at_put(i, os::thread_cpu_time((Thread*)java_thread,
2202                                                       user_sys_cpu_time != 0));
2203     }
2204   }
2205 JVM_END
2206 
2207 
2208 
2209 #if INCLUDE_MANAGEMENT
2210 const struct jmmInterface_1_ jmm_interface = {
2211   NULL,
2212   NULL,
2213   jmm_GetVersion,
2214   jmm_GetOptionalSupport,
2215   jmm_GetThreadInfo,
2216   jmm_GetMemoryPools,
2217   jmm_GetMemoryManagers,
2218   jmm_GetMemoryPoolUsage,
2219   jmm_GetPeakMemoryPoolUsage,
2220   jmm_GetOneThreadAllocatedMemory,
2221   jmm_GetThreadAllocatedMemory,
2222   jmm_GetMemoryUsage,
2223   jmm_GetLongAttribute,
2224   jmm_GetBoolAttribute,
2225   jmm_SetBoolAttribute,
2226   jmm_GetLongAttributes,
2227   jmm_FindMonitorDeadlockedThreads,
2228   jmm_GetThreadCpuTime,
2229   jmm_GetVMGlobalNames,
2230   jmm_GetVMGlobals,
2231   jmm_GetInternalThreadTimes,
2232   jmm_ResetStatistic,
2233   jmm_SetPoolSensor,
2234   jmm_SetPoolThreshold,
2235   jmm_GetPoolCollectionUsage,
2236   jmm_GetGCExtAttributeInfo,
2237   jmm_GetLastGCStat,
2238   jmm_GetThreadCpuTimeWithKind,
2239   jmm_GetThreadCpuTimesWithKind,
2240   jmm_DumpHeap0,
2241   jmm_FindDeadlockedThreads,
2242   jmm_SetVMGlobal,
2243   NULL,
2244   jmm_DumpThreads,
2245   jmm_SetGCNotificationEnabled,
2246   jmm_GetDiagnosticCommands,
2247   jmm_GetDiagnosticCommandInfo,
2248   jmm_GetDiagnosticCommandArgumentsInfo,
2249   jmm_ExecuteDiagnosticCommand,
2250   jmm_SetDiagnosticFrameworkNotificationEnabled
2251 };
2252 #endif // INCLUDE_MANAGEMENT
2253 
2254 void* Management::get_jmm_interface(int version) {
2255 #if INCLUDE_MANAGEMENT
2256   if (version == JMM_VERSION) {
2257     return (void*) &amp;jmm_interface;
2258   }
2259 #endif // INCLUDE_MANAGEMENT
2260   return NULL;
2261 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
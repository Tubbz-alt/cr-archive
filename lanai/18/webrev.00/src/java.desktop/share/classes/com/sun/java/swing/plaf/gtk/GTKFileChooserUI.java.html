<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/share/classes/com/sun/java/swing/plaf/gtk/GTKFileChooserUI.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.java.swing.plaf.gtk;
  27 
  28 import java.awt.AWTKeyStroke;
  29 import java.awt.BorderLayout;
  30 import java.awt.Component;
  31 import java.awt.Container;
  32 import java.awt.Dimension;
  33 import java.awt.FlowLayout;
  34 import java.awt.GridBagConstraints;
  35 import java.awt.GridBagLayout;
  36 import java.awt.GridLayout;
  37 import java.awt.Insets;
  38 import java.awt.KeyboardFocusManager;
  39 import java.awt.event.ActionEvent;
  40 import java.awt.event.KeyEvent;
  41 import java.awt.event.MouseAdapter;
  42 import java.awt.event.MouseEvent;
  43 import java.awt.event.MouseListener;
  44 import java.beans.PropertyChangeEvent;
  45 import java.beans.PropertyChangeListener;
  46 import java.io.File;
  47 import java.io.IOException;
  48 import java.text.MessageFormat;
  49 import java.util.ArrayList;
  50 import java.util.Comparator;
  51 import java.util.HashSet;
  52 import java.util.Locale;
  53 import java.util.Set;
  54 import java.util.Vector;
  55 
  56 import javax.accessibility.AccessibleContext;
  57 import javax.swing.AbstractAction;
  58 import javax.swing.AbstractListModel;
  59 import javax.swing.Action;
  60 import javax.swing.ActionMap;
  61 import javax.swing.Box;
  62 import javax.swing.BoxLayout;
  63 import javax.swing.ComboBoxModel;
  64 import javax.swing.DefaultListCellRenderer;
  65 import javax.swing.DefaultListSelectionModel;
  66 import javax.swing.Icon;
  67 import javax.swing.JButton;
  68 import javax.swing.JComboBox;
  69 import javax.swing.JComponent;
  70 import javax.swing.JFileChooser;
  71 import javax.swing.JLabel;
  72 import javax.swing.JList;
  73 import javax.swing.JOptionPane;
  74 import javax.swing.JPanel;
  75 import javax.swing.JRootPane;
  76 import javax.swing.JScrollPane;
  77 import javax.swing.JSplitPane;
  78 import javax.swing.JTextField;
  79 import javax.swing.KeyStroke;
  80 import javax.swing.ListSelectionModel;
  81 import javax.swing.SwingUtilities;
  82 import javax.swing.TransferHandler;
  83 import javax.swing.UIManager;
  84 import javax.swing.border.EmptyBorder;
  85 import javax.swing.event.ListDataEvent;
  86 import javax.swing.event.ListDataListener;
  87 import javax.swing.event.ListSelectionEvent;
  88 import javax.swing.event.ListSelectionListener;
  89 import javax.swing.filechooser.FileFilter;
  90 import javax.swing.filechooser.FileSystemView;
  91 import javax.swing.filechooser.FileView;
  92 import javax.swing.plaf.ActionMapUIResource;
  93 import javax.swing.plaf.ComponentUI;
  94 import javax.swing.plaf.basic.BasicDirectoryModel;
  95 import javax.swing.table.JTableHeader;
  96 import javax.swing.table.TableCellRenderer;
  97 
  98 import sun.awt.shell.ShellFolder;
  99 import sun.swing.FilePane;
 100 import sun.swing.SwingUtilities2;
 101 import sun.swing.plaf.synth.SynthFileChooserUI;
 102 
 103 /**
 104  * GTK FileChooserUI.
 105  *
 106  * @author Leif Samuelsson
 107  * @author Jeff Dinkins
 108  */
 109 class GTKFileChooserUI extends SynthFileChooserUI {
 110 
 111     // The accessoryPanel is a container to place the JFileChooser accessory component
 112     private JPanel accessoryPanel = null;
 113 
 114     private String newFolderButtonText = null;
 115     private String newFolderErrorSeparator = null;
 116     private String newFolderErrorText = null;
 117     private String newFolderDialogText = null;
 118     private String newFolderNoDirectoryErrorTitleText = null;
 119     private String newFolderNoDirectoryErrorText = null;
 120 
 121     private String deleteFileButtonText = null;
 122     private String renameFileButtonText = null;
 123 
 124     private String newFolderButtonToolTipText = null;
 125     private String deleteFileButtonToolTipText = null;
 126     private String renameFileButtonToolTipText = null;
 127 
 128     private int newFolderButtonMnemonic = 0;
 129     private int deleteFileButtonMnemonic = 0;
 130     private int renameFileButtonMnemonic = 0;
 131     private int foldersLabelMnemonic = 0;
 132     private int filesLabelMnemonic = 0;
 133 
 134     private String renameFileDialogText = null;
 135     private String renameFileErrorTitle = null;
 136     private String renameFileErrorText = null;
 137 
 138     private JComboBox&lt;FileFilter&gt; filterComboBox;
 139     private FilterComboBoxModel filterComboBoxModel;
 140 
 141     // From Motif
 142 
 143     private JPanel rightPanel;
 144     private JList&lt;File&gt; directoryList;
 145     private JList&lt;File&gt; fileList;
 146 
 147     private JLabel pathField;
 148     private JTextField fileNameTextField;
 149 
 150     private static final Dimension hstrut3 = new Dimension(3, 1);
 151     private static final Dimension vstrut10 = new Dimension(1, 10);
 152 
 153     private static Dimension prefListSize = new Dimension(75, 150);
 154 
 155     private static Dimension PREF_SIZE = new Dimension(435, 360);
 156     private static final int MIN_WIDTH = 200;
 157     private static final int MIN_HEIGHT = 300;
 158 
 159     private static Dimension ZERO_ACC_SIZE = new Dimension(1, 1);
 160 
 161     private static Dimension MAX_SIZE = new Dimension(Short.MAX_VALUE, Short.MAX_VALUE);
 162 
 163     private static final Insets buttonMargin = new Insets(3, 3, 3, 3);
 164 
 165     private String filesLabelText = null;
 166     private String foldersLabelText = null;
 167     private String pathLabelText = null;
 168     private String filterLabelText = null;
 169 
 170     private int pathLabelMnemonic = 0;
 171     private int filterLabelMnemonic = 0;
 172 
 173     private JComboBox&lt;File&gt; directoryComboBox;
 174     private DirectoryComboBoxModel directoryComboBoxModel;
 175     private Action directoryComboBoxAction = new DirectoryComboBoxAction();
 176     private JPanel bottomButtonPanel;
 177     private GTKDirectoryModel model = null;
 178     private Action newFolderAction;
 179     private boolean readOnly;
 180     private boolean showDirectoryIcons;
 181     private boolean showFileIcons;
 182     private GTKFileView fileView = new GTKFileView();
 183     private PropertyChangeListener gtkFCPropertyChangeListener;
 184     private Action approveSelectionAction = new GTKApproveSelectionAction();
 185     private GTKDirectoryListModel directoryListModel;
 186 
 187     public GTKFileChooserUI(JFileChooser filechooser) {
 188         super(filechooser);
 189     }
 190 
 191     protected ActionMap createActionMap() {
 192         ActionMap map = new ActionMapUIResource();
 193         map.put(&quot;approveSelection&quot;, getApproveSelectionAction());
 194         map.put(&quot;cancelSelection&quot;, getCancelSelectionAction());
 195         map.put(&quot;Go Up&quot;, getChangeToParentDirectoryAction());
 196         map.put(&quot;fileNameCompletion&quot;, getFileNameCompletionAction());
 197         return map;
 198     }
 199 
 200     @SuppressWarnings(&quot;deprecation&quot;)
 201     public String getFileName() {
 202         JFileChooser fc = getFileChooser();
 203         String typedInName = fileNameTextField != null ?
 204             fileNameTextField.getText() : null;
 205 
 206         if (!fc.isMultiSelectionEnabled()) {
 207             return typedInName;
 208         }
 209 
 210         int mode = fc.getFileSelectionMode();
 211         JList&lt;File&gt; list = mode == JFileChooser.DIRECTORIES_ONLY ?
 212             directoryList : fileList;
 213         Object[] files = list.getSelectedValues();
 214         int len = files.length;
 215         Vector&lt;String&gt; result = new Vector&lt;String&gt;(len + 1);
 216 
 217         // we return all selected file names
 218         for (int i = 0; i &lt; len; i++) {
 219             File file = (File)files[i];
 220             result.add(file.getName());
 221         }
 222         // plus the file name typed into the text field, if not already there
 223         if (typedInName != null &amp;&amp; !result.contains(typedInName)) {
 224             result.add(typedInName);
 225         }
 226 
 227         StringBuilder sb = new StringBuilder();
 228         len = result.size();
 229 
 230         // construct the resulting string
 231         for (int i=0; i&lt;len; i++) {
 232             if (i &gt; 0) {
 233                 sb.append(&quot; &quot;);
 234             }
 235             if (len &gt; 1) {
 236                 sb.append(&quot;\&quot;&quot;);
 237             }
 238             sb.append(result.get(i));
 239             if (len &gt; 1) {
 240                 sb.append(&quot;\&quot;&quot;);
 241             }
 242         }
 243         return sb.toString();
 244     }
 245 
 246     public void setFileName(String fileName) {
 247         if (fileNameTextField != null) {
 248             fileNameTextField.setText(fileName);
 249         }
 250     }
 251 
 252 //     public String getDirectoryName() {
 253 //      return pathField.getText();
 254 //     }
 255 
 256     public void setDirectoryName(String dirname) {
 257         pathField.setText(dirname);
 258     }
 259 
 260     public void ensureFileIsVisible(JFileChooser fc, File f) {
 261         // PENDING
 262     }
 263 
 264     public void rescanCurrentDirectory(JFileChooser fc) {
 265         getModel().validateFileCache();
 266     }
 267 
 268     public JPanel getAccessoryPanel() {
 269         return accessoryPanel;
 270     }
 271 
 272     // ***********************
 273     // * FileView operations *
 274     // ***********************
 275 
 276     public FileView getFileView(JFileChooser fc) {
 277         return fileView;
 278     }
 279 
 280     private class GTKFileView extends BasicFileView {
 281         public GTKFileView() {
 282             iconCache = null;
 283         }
 284 
 285         public void clearIconCache() {
 286         }
 287 
 288         public Icon getCachedIcon(File f) {
 289             return null;
 290         }
 291 
 292         public void cacheIcon(File f, Icon i) {
 293         }
 294 
 295         public Icon getIcon(File f) {
 296             return (f != null &amp;&amp; f.isDirectory()) ? directoryIcon : fileIcon;
 297         }
 298     }
 299 
 300 
 301     private void updateDefaultButton() {
 302         JFileChooser filechooser = getFileChooser();
 303         JRootPane root = SwingUtilities.getRootPane(filechooser);
 304         if (root == null) {
 305             return;
 306         }
 307 
 308         if (filechooser.getControlButtonsAreShown()) {
 309             if (root.getDefaultButton() == null) {
 310                 root.setDefaultButton(getApproveButton(filechooser));
 311                 getCancelButton(filechooser).setDefaultCapable(false);
 312             }
 313         } else {
 314             if (root.getDefaultButton() == getApproveButton(filechooser)) {
 315                 root.setDefaultButton(null);
 316             }
 317         }
 318     }
 319 
 320     protected void doSelectedFileChanged(PropertyChangeEvent e) {
 321         super.doSelectedFileChanged(e);
 322         File f = (File) e.getNewValue();
 323         if (f != null) {
 324             setFileName(getFileChooser().getName(f));
 325         }
 326     }
 327 
 328     protected void doDirectoryChanged(PropertyChangeEvent e) {
 329         directoryList.clearSelection();
 330         ListSelectionModel sm = directoryList.getSelectionModel();
 331         if (sm instanceof DefaultListSelectionModel) {
 332             ((DefaultListSelectionModel)sm).moveLeadSelectionIndex(0);
 333             sm.setAnchorSelectionIndex(0);
 334         }
 335         fileList.clearSelection();
 336         sm = fileList.getSelectionModel();
 337         if (sm instanceof DefaultListSelectionModel) {
 338             ((DefaultListSelectionModel)sm).moveLeadSelectionIndex(0);
 339             sm.setAnchorSelectionIndex(0);
 340         }
 341 
 342         File currentDirectory = getFileChooser().getCurrentDirectory();
 343         if (currentDirectory != null) {
 344             try {
 345                 setDirectoryName(ShellFolder.getNormalizedFile((File)e.getNewValue()).getPath());
 346             } catch (IOException ioe) {
 347                 setDirectoryName(((File)e.getNewValue()).getAbsolutePath());
 348             }
 349             if ((getFileChooser().getFileSelectionMode() == JFileChooser.DIRECTORIES_ONLY) &amp;&amp; !getFileChooser().isMultiSelectionEnabled()) {
 350                 setFileName(pathField.getText());
 351             }
 352             directoryComboBoxModel.addItem(currentDirectory);
 353             directoryListModel.directoryChanged();
 354         }
 355         super.doDirectoryChanged(e);
 356     }
 357 
 358     protected void doAccessoryChanged(PropertyChangeEvent e) {
 359         if (getAccessoryPanel() != null) {
 360             if (e.getOldValue() != null) {
 361                 getAccessoryPanel().remove((JComponent)e.getOldValue());
 362             }
 363             JComponent accessory = (JComponent)e.getNewValue();
 364             if (accessory != null) {
 365                 getAccessoryPanel().add(accessory, BorderLayout.CENTER);
 366                 getAccessoryPanel().setPreferredSize(accessory.getPreferredSize());
 367                 getAccessoryPanel().setMaximumSize(MAX_SIZE);
 368             } else {
 369                 getAccessoryPanel().setPreferredSize(ZERO_ACC_SIZE);
 370                 getAccessoryPanel().setMaximumSize(ZERO_ACC_SIZE);
 371             }
 372         }
 373     }
 374 
 375     protected void doFileSelectionModeChanged(PropertyChangeEvent e) {
 376         directoryList.clearSelection();
 377         rightPanel.setVisible(((Integer)e.getNewValue()).intValue() != JFileChooser.DIRECTORIES_ONLY);
 378 
 379         super.doFileSelectionModeChanged(e);
 380     }
 381 
 382     protected void doMultiSelectionChanged(PropertyChangeEvent e) {
 383         if (getFileChooser().isMultiSelectionEnabled()) {
 384             fileList.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
 385         } else {
 386             fileList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
 387             fileList.clearSelection();
 388         }
 389 
 390         super.doMultiSelectionChanged(e);
 391     }
 392 
 393     protected void doControlButtonsChanged(PropertyChangeEvent e) {
 394         super.doControlButtonsChanged(e);
 395 
 396         JFileChooser filechooser = getFileChooser();
 397         if (filechooser.getControlButtonsAreShown()) {
 398             filechooser.add(bottomButtonPanel, BorderLayout.SOUTH);
 399         } else {
 400             filechooser.remove(bottomButtonPanel);
 401         }
 402         updateDefaultButton();
 403     }
 404 
 405     protected void doAncestorChanged(PropertyChangeEvent e) {
 406         if (e.getOldValue() == null &amp;&amp; e.getNewValue() != null) {
 407             // Ancestor was added, set initial focus
 408             fileNameTextField.selectAll();
 409             fileNameTextField.requestFocus();
 410             updateDefaultButton();
 411         }
 412 
 413         super.doAncestorChanged(e);
 414     }
 415 
 416 
 417 
 418     // ********************************************
 419     // ************ Create Listeners **************
 420     // ********************************************
 421 
 422     public ListSelectionListener createListSelectionListener(JFileChooser fc) {
 423         return new SelectionListener();
 424     }
 425 
 426     class DoubleClickListener extends MouseAdapter {
 427         JList&lt;?&gt; list;
 428         public  DoubleClickListener(JList&lt;?&gt; list) {
 429             this.list = list;
 430         }
 431 
 432         public void mouseClicked(MouseEvent e) {
 433             if (SwingUtilities.isLeftMouseButton(e) &amp;&amp; e.getClickCount() == 2) {
 434                 int index = list.locationToIndex(e.getPoint());
 435                 if (index &gt;= 0) {
 436                     File f = (File) list.getModel().getElementAt(index);
 437                     try {
 438                         // Strip trailing &quot;..&quot;
 439                         f = ShellFolder.getNormalizedFile(f);
 440                     } catch (IOException ex) {
 441                         // That&#39;s ok, we&#39;ll use f as is
 442                     }
 443                     if (getFileChooser().isTraversable(f)) {
 444                         list.clearSelection();
 445                         if (getFileChooser().getCurrentDirectory().equals(f)){
 446                             rescanCurrentDirectory(getFileChooser());
 447                         } else {
 448                             getFileChooser().setCurrentDirectory(f);
 449                         }
 450                     } else {
 451                         getFileChooser().approveSelection();
 452                     }
 453                 }
 454             }
 455         }
 456 
 457         public void mouseEntered(MouseEvent evt) {
 458             if (list != null) {
 459                 TransferHandler th1 = getFileChooser().getTransferHandler();
 460                 TransferHandler th2 = list.getTransferHandler();
 461                 if (th1 != th2) {
 462                     list.setTransferHandler(th1);
 463                 }
 464                 if (getFileChooser().getDragEnabled() != list.getDragEnabled()) {
 465                     list.setDragEnabled(getFileChooser().getDragEnabled());
 466                 }
 467             }
 468         }
 469     }
 470 
 471     protected MouseListener createDoubleClickListener(JFileChooser fc, JList&lt;?&gt; list) {
 472         return new DoubleClickListener(list);
 473     }
 474 
 475 
 476 
 477     @SuppressWarnings(&quot;deprecation&quot;)
 478     protected class SelectionListener implements ListSelectionListener {
 479         public void valueChanged(ListSelectionEvent e) {
 480             if (!e.getValueIsAdjusting()) {
 481                 JFileChooser chooser = getFileChooser();
 482                 JList&lt;?&gt; list = (JList) e.getSource();
 483 
 484                 if (chooser.isMultiSelectionEnabled()) {
 485                     File[] files = null;
 486                     Object[] objects = list.getSelectedValues();
 487                     if (objects != null) {
 488                         if (objects.length == 1
 489                             &amp;&amp; ((File)objects[0]).isDirectory()
 490                             &amp;&amp; chooser.isTraversable(((File)objects[0]))
 491                             &amp;&amp; (chooser.getFileSelectionMode() != JFileChooser.DIRECTORIES_ONLY
 492                                 || !chooser.getFileSystemView().isFileSystem(((File)objects[0])))) {
 493                             setDirectorySelected(true);
 494                             setDirectory(((File)objects[0]));
 495                         } else {
 496                             ArrayList&lt;File&gt; fList = new ArrayList&lt;File&gt;(objects.length);
 497                             for (Object object : objects) {
 498                                 File f = (File) object;
 499                                 if ((chooser.isFileSelectionEnabled() &amp;&amp; f.isFile())
 500                                     || (chooser.isDirectorySelectionEnabled() &amp;&amp; f.isDirectory())) {
 501                                     fList.add(f);
 502                                 }
 503                             }
 504                             if (fList.size() &gt; 0) {
 505                                 files = fList.toArray(new File[fList.size()]);
 506                             }
 507                             setDirectorySelected(false);
 508                         }
 509                     }
 510                     chooser.setSelectedFiles(files);
 511                 } else {
 512                     File file = (File)list.getSelectedValue();
 513                     if (file != null
 514                         &amp;&amp; file.isDirectory()
 515                         &amp;&amp; chooser.isTraversable(file)
 516                         &amp;&amp; (chooser.getFileSelectionMode() == JFileChooser.FILES_ONLY
 517                             || !chooser.getFileSystemView().isFileSystem(file))) {
 518 
 519                         setDirectorySelected(true);
 520                         setDirectory(file);
 521                     } else {
 522                         setDirectorySelected(false);
 523                         if (file != null) {
 524                             chooser.setSelectedFile(file);
 525                         }
 526                     }
 527                 }
 528             }
 529         }
 530     }
 531 
 532 
 533     //
 534     // ComponentUI Interface Implementation methods
 535     //
 536     public static ComponentUI createUI(JComponent c) {
 537         return new GTKFileChooserUI((JFileChooser)c);
 538     }
 539 
 540     public void installUI(JComponent c) {
 541         accessoryPanel = new JPanel(new BorderLayout(10, 10));
 542         accessoryPanel.setName(&quot;GTKFileChooser.accessoryPanel&quot;);
 543 
 544         super.installUI(c);
 545     }
 546 
 547     public void uninstallUI(JComponent c) {
 548         c.removePropertyChangeListener(filterComboBoxModel);
 549         super.uninstallUI(c);
 550 
 551         if (accessoryPanel != null) {
 552             accessoryPanel.removeAll();
 553         }
 554         accessoryPanel = null;
 555         getFileChooser().removeAll();
 556     }
 557 
 558     public void installComponents(JFileChooser fc) {
 559         super.installComponents(fc);
 560 
 561         boolean leftToRight = fc.getComponentOrientation().isLeftToRight();
 562 
 563         fc.setLayout(new BorderLayout());
 564         fc.setAlignmentX(JComponent.CENTER_ALIGNMENT);
 565 
 566         // Top row of buttons
 567         JPanel topButtonPanel = new JPanel(new FlowLayout(FlowLayout.LEADING, 0, 0));
 568         topButtonPanel.setBorder(new EmptyBorder(10, 10, 0, 10));
 569         topButtonPanel.setName(&quot;GTKFileChooser.topButtonPanel&quot;);
 570 
 571         if (!UIManager.getBoolean(&quot;FileChooser.readOnly&quot;)) {
 572             JButton newFolderButton = new JButton(getNewFolderAction());
 573             newFolderButton.setName(&quot;GTKFileChooser.newFolderButton&quot;);
 574             newFolderButton.setMnemonic(newFolderButtonMnemonic);
 575             newFolderButton.setToolTipText(newFolderButtonToolTipText);
 576             newFolderButton.setText(newFolderButtonText);
 577             topButtonPanel.add(newFolderButton);
 578         }
 579         JButton deleteFileButton = new JButton(deleteFileButtonText);
 580         deleteFileButton.setName(&quot;GTKFileChooser.deleteFileButton&quot;);
 581         deleteFileButton.setMnemonic(deleteFileButtonMnemonic);
 582         deleteFileButton.setToolTipText(deleteFileButtonToolTipText);
 583         deleteFileButton.setEnabled(false);
 584         topButtonPanel.add(deleteFileButton);
 585 
 586         RenameFileAction rfa = new RenameFileAction();
 587         JButton renameFileButton = new JButton(rfa);
 588         if (readOnly) {
 589             rfa.setEnabled(false);
 590         }
 591         renameFileButton.setText(renameFileButtonText);
 592         renameFileButton.setName(&quot;GTKFileChooser.renameFileButton&quot;);
 593         renameFileButton.setMnemonic(renameFileButtonMnemonic);
 594         renameFileButton.setToolTipText(renameFileButtonToolTipText);
 595         topButtonPanel.add(renameFileButton);
 596 
 597         fc.add(topButtonPanel, BorderLayout.NORTH);
 598 
 599 
 600         JPanel interior = new JPanel();
 601         interior.setBorder(new EmptyBorder(0, 10, 10, 10));
 602         interior.setName(&quot;GTKFileChooser.interiorPanel&quot;);
 603         align(interior);
 604         interior.setLayout(new BoxLayout(interior, BoxLayout.PAGE_AXIS));
 605 
 606         fc.add(interior, BorderLayout.CENTER);
 607 
 608         @SuppressWarnings(&quot;serial&quot;) // anonymous class
 609         JPanel comboBoxPanel = new JPanel(new FlowLayout(FlowLayout.CENTER,
 610                                                          0, 0) {
 611             public void layoutContainer(Container target) {
 612                 super.layoutContainer(target);
 613                 JComboBox&lt;?&gt; comboBox = directoryComboBox;
 614                 if (comboBox.getWidth() &gt; target.getWidth()) {
 615                     comboBox.setBounds(0, comboBox.getY(), target.getWidth(),
 616                                        comboBox.getHeight());
 617                 }
 618             }
 619         });
 620         comboBoxPanel.setBorder(new EmptyBorder(0, 0, 4, 0));
 621         comboBoxPanel.setName(&quot;GTKFileChooser.directoryComboBoxPanel&quot;);
 622         // CurrentDir ComboBox
 623         directoryComboBoxModel = createDirectoryComboBoxModel(fc);
 624         directoryComboBox = new JComboBox&lt;&gt;(directoryComboBoxModel);
 625         directoryComboBox.setName(&quot;GTKFileChooser.directoryComboBox&quot;);
 626         directoryComboBox.putClientProperty( &quot;JComboBox.lightweightKeyboardNavigation&quot;, &quot;Lightweight&quot; );
 627         directoryComboBox.addActionListener(directoryComboBoxAction);
 628         directoryComboBox.setMaximumRowCount(8);
 629         comboBoxPanel.add(directoryComboBox);
 630         interior.add(comboBoxPanel);
 631 
 632 
 633         // CENTER: left, right, accessory
 634         JPanel centerPanel = new JPanel(new BorderLayout());
 635         centerPanel.setName(&quot;GTKFileChooser.centerPanel&quot;);
 636 
 637         // SPLIT PANEL: left, right
 638         JSplitPane splitPanel = new JSplitPane();
 639         splitPanel.setName(&quot;GTKFileChooser.splitPanel&quot;);
 640         splitPanel.setDividerLocation((PREF_SIZE.width-8)/2);
 641 
 642         // left panel - Filter &amp; directoryList
 643         JPanel leftPanel = new JPanel(new GridBagLayout());
 644         leftPanel.setName(&quot;GTKFileChooser.directoryListPanel&quot;);
 645 
 646         // Add the Directory List
 647         // Create a label that looks like button (should be a table header)
 648         TableCellRenderer headerRenderer = new JTableHeader().getDefaultRenderer();
 649         JLabel directoryListLabel =
 650             (JLabel)headerRenderer.getTableCellRendererComponent(null, foldersLabelText,
 651                                                                      false, false, 0, 0);
 652         directoryListLabel.setName(&quot;GTKFileChooser.directoryListLabel&quot;);
 653         leftPanel.add(directoryListLabel, new GridBagConstraints(
 654                           0, 0, 1, 1, 1, 0, GridBagConstraints.WEST,
 655                           GridBagConstraints.HORIZONTAL,
 656                           new Insets(0, 0, 0, 0), 0, 0));
 657         leftPanel.add(createDirectoryList(), new GridBagConstraints(
 658                           0, 1, 1, 1, 1, 1, GridBagConstraints.EAST,
 659                           GridBagConstraints.BOTH,
 660                           new Insets(0, 0, 0, 0), 0, 0));
 661         directoryListLabel.setDisplayedMnemonic(foldersLabelMnemonic);
 662         directoryListLabel.setLabelFor(directoryList);
 663 
 664         // create files list
 665         rightPanel = new JPanel(new GridBagLayout());
 666         rightPanel.setName(&quot;GTKFileChooser.fileListPanel&quot;);
 667 
 668         headerRenderer = new JTableHeader().getDefaultRenderer();
 669         JLabel fileListLabel =
 670             (JLabel)headerRenderer.getTableCellRendererComponent(null, filesLabelText,
 671                                                                      false, false, 0, 0);
 672         fileListLabel.setName(&quot;GTKFileChooser.fileListLabel&quot;);
 673         rightPanel.add(fileListLabel, new GridBagConstraints(
 674                           0, 0, 1, 1, 1, 0, GridBagConstraints.WEST,
 675                           GridBagConstraints.HORIZONTAL,
 676                           new Insets(0, 0, 0, 0), 0, 0));
 677         rightPanel.add(createFilesList(), new GridBagConstraints(
 678                           0, 1, 1, 1, 1, 1, GridBagConstraints.EAST,
 679                           GridBagConstraints.BOTH,
 680                           new Insets(0, 0, 0, 0), 0, 0));
 681         fileListLabel.setDisplayedMnemonic(filesLabelMnemonic);
 682         fileListLabel.setLabelFor(fileList);
 683 
 684         splitPanel.add(leftPanel,  leftToRight ? JSplitPane.LEFT : JSplitPane.RIGHT);
 685         splitPanel.add(rightPanel, leftToRight ? JSplitPane.RIGHT : JSplitPane.LEFT);
 686         centerPanel.add(splitPanel, BorderLayout.CENTER);
 687 
 688         JComponent accessoryPanel = getAccessoryPanel();
 689         JComponent accessory = fc.getAccessory();
 690         if (accessoryPanel != null) {
 691             if (accessory == null) {
 692                 accessoryPanel.setPreferredSize(ZERO_ACC_SIZE);
 693                 accessoryPanel.setMaximumSize(ZERO_ACC_SIZE);
 694             } else {
 695                 getAccessoryPanel().add(accessory, BorderLayout.CENTER);
 696                 accessoryPanel.setPreferredSize(accessory.getPreferredSize());
 697                 accessoryPanel.setMaximumSize(MAX_SIZE);
 698             }
 699             align(accessoryPanel);
 700             centerPanel.add(accessoryPanel, BorderLayout.AFTER_LINE_ENDS);
 701         }
 702         interior.add(centerPanel);
 703         interior.add(Box.createRigidArea(vstrut10));
 704 
 705         JPanel pathFieldPanel = new JPanel(new FlowLayout(FlowLayout.LEADING,
 706                                                           0, 0));
 707         pathFieldPanel.setBorder(new EmptyBorder(0, 0, 4, 0));
 708         JLabel pathFieldLabel = new JLabel(pathLabelText);
 709         pathFieldLabel.setName(&quot;GTKFileChooser.pathFieldLabel&quot;);
 710         pathFieldLabel.setDisplayedMnemonic(pathLabelMnemonic);
 711         align(pathFieldLabel);
 712         pathFieldPanel.add(pathFieldLabel);
 713         pathFieldPanel.add(Box.createRigidArea(hstrut3));
 714 
 715         File currentDirectory = fc.getCurrentDirectory();
 716         String curDirName = null;
 717         if (currentDirectory != null) {
 718             curDirName = currentDirectory.getPath();
 719         }
 720         @SuppressWarnings(&quot;serial&quot;) // anonymous class
 721         JLabel tmp = new JLabel(curDirName) {
 722             public Dimension getMaximumSize() {
 723                 Dimension d = super.getMaximumSize();
 724                 d.height = getPreferredSize().height;
 725                 return d;
 726             }
 727         };
 728         pathField =  tmp;
 729         pathField.setName(&quot;GTKFileChooser.pathField&quot;);
 730         align(pathField);
 731         pathFieldPanel.add(pathField);
 732         interior.add(pathFieldPanel);
 733 
 734         // add the fileName field
 735         @SuppressWarnings(&quot;serial&quot;) // anonymous class
 736         JTextField tmp2 = new JTextField() {
 737             public Dimension getMaximumSize() {
 738                 Dimension d = super.getMaximumSize();
 739                 d.height = getPreferredSize().height;
 740                 return d;
 741             }
 742         };
 743         fileNameTextField = tmp2;
 744 
 745         pathFieldLabel.setLabelFor(fileNameTextField);
 746 
 747         Set&lt;AWTKeyStroke&gt; forwardTraversalKeys = fileNameTextField.getFocusTraversalKeys(
 748             KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS);
 749         forwardTraversalKeys = new HashSet&lt;AWTKeyStroke&gt;(forwardTraversalKeys);
 750         forwardTraversalKeys.remove(KeyStroke.getKeyStroke(KeyEvent.VK_TAB, 0));
 751         fileNameTextField.setFocusTraversalKeys(KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, forwardTraversalKeys);
 752 
 753         fileNameTextField.setName(&quot;GTKFileChooser.fileNameTextField&quot;);
 754         fileNameTextField.getActionMap().put(&quot;fileNameCompletionAction&quot;, getFileNameCompletionAction());
 755         fileNameTextField.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_TAB, 0), &quot;fileNameCompletionAction&quot;);
 756         interior.add(fileNameTextField);
 757 
 758         // Add the filter combo box
 759         JPanel panel = new JPanel();
 760         panel.setLayout(new FlowLayout(FlowLayout.LEADING, 0, 0));
 761         panel.setBorder(new EmptyBorder(0, 0, 4, 0));
 762         JLabel filterLabel = new JLabel(filterLabelText);
 763         filterLabel.setName(&quot;GTKFileChooser.filterLabel&quot;);
 764         filterLabel.setDisplayedMnemonic(filterLabelMnemonic);
 765         panel.add(filterLabel);
 766 
 767         filterComboBoxModel = createFilterComboBoxModel();
 768         fc.addPropertyChangeListener(filterComboBoxModel);
 769         filterComboBox = new JComboBox&lt;&gt;(filterComboBoxModel);
 770         filterComboBox.setRenderer(createFilterComboBoxRenderer());
 771         filterLabel.setLabelFor(filterComboBox);
 772 
 773         interior.add(Box.createRigidArea(vstrut10));
 774         interior.add(panel);
 775         interior.add(filterComboBox);
 776 
 777         // Add buttons
 778         bottomButtonPanel = new JPanel(new FlowLayout(FlowLayout.TRAILING));
 779         bottomButtonPanel.setName(&quot;GTKFileChooser.bottomButtonPanel&quot;);
 780         align(bottomButtonPanel);
 781 
 782         JPanel pnButtons = new JPanel(new GridLayout(1, 2, 5, 0));
 783 
 784         JButton cancelButton = getCancelButton(fc);
 785         align(cancelButton);
 786         cancelButton.setMargin(buttonMargin);
 787         pnButtons.add(cancelButton);
 788 
 789         JButton approveButton = getApproveButton(fc);
 790         align(approveButton);
 791         approveButton.setMargin(buttonMargin);
 792         pnButtons.add(approveButton);
 793 
 794         bottomButtonPanel.add(pnButtons);
 795 
 796         if (fc.getControlButtonsAreShown()) {
 797             fc.add(bottomButtonPanel, BorderLayout.SOUTH);
 798         }
 799     }
 800 
 801     protected void installListeners(JFileChooser fc) {
 802         super.installListeners(fc);
 803 
 804         gtkFCPropertyChangeListener = new GTKFCPropertyChangeListener();
 805         fc.addPropertyChangeListener(gtkFCPropertyChangeListener);
 806     }
 807 
 808     private int getMnemonic(String key, Locale l) {
 809         return SwingUtilities2.getUIDefaultsInt(key, l);
 810     }
 811 
 812     protected void uninstallListeners(JFileChooser fc) {
 813         super.uninstallListeners(fc);
 814 
 815         if (gtkFCPropertyChangeListener != null) {
 816             fc.removePropertyChangeListener(gtkFCPropertyChangeListener);
 817         }
 818     }
 819 
 820     private class GTKFCPropertyChangeListener implements PropertyChangeListener {
 821         public void propertyChange(PropertyChangeEvent e) {
 822             String prop = e.getPropertyName();
 823             if (prop.equals(&quot;GTKFileChooser.showDirectoryIcons&quot;)) {
 824                 showDirectoryIcons = Boolean.TRUE.equals(e.getNewValue());
 825             } else if (prop.equals(&quot;GTKFileChooser.showFileIcons&quot;)) {
 826                 showFileIcons      = Boolean.TRUE.equals(e.getNewValue());
 827             }
 828         }
 829     }
 830 
 831     protected void installDefaults(JFileChooser fc) {
 832         super.installDefaults(fc);
 833         readOnly = UIManager.getBoolean(&quot;FileChooser.readOnly&quot;);
 834         showDirectoryIcons =
 835             Boolean.TRUE.equals(fc.getClientProperty(&quot;GTKFileChooser.showDirectoryIcons&quot;));
 836         showFileIcons =
 837             Boolean.TRUE.equals(fc.getClientProperty(&quot;GTKFileChooser.showFileIcons&quot;));
 838     }
 839 
 840     protected void installIcons(JFileChooser fc) {
 841         directoryIcon    = UIManager.getIcon(&quot;FileView.directoryIcon&quot;);
 842         fileIcon         = UIManager.getIcon(&quot;FileView.fileIcon&quot;);
 843     }
 844 
 845     protected void installStrings(JFileChooser fc) {
 846         super.installStrings(fc);
 847 
 848         Locale l = fc.getLocale();
 849 
 850         newFolderDialogText = UIManager.getString(&quot;FileChooser.newFolderDialogText&quot;, l);
 851         newFolderErrorText = UIManager.getString(&quot;FileChooser.newFolderErrorText&quot;,l);
 852         newFolderErrorSeparator = UIManager.getString(&quot;FileChooser.newFolderErrorSeparator&quot;,l);
 853         newFolderButtonText = UIManager.getString(&quot;FileChooser.newFolderButtonText&quot;, l);
 854         newFolderNoDirectoryErrorTitleText = UIManager.getString(&quot;FileChooser.newFolderNoDirectoryErrorTitleText&quot;, l);
 855         newFolderNoDirectoryErrorText = UIManager.getString(&quot;FileChooser.newFolderNoDirectoryErrorText&quot;, l);
 856         deleteFileButtonText = UIManager.getString(&quot;FileChooser.deleteFileButtonText&quot;, l);
 857         renameFileButtonText = UIManager.getString(&quot;FileChooser.renameFileButtonText&quot;, l);
 858 
 859         newFolderButtonMnemonic = getMnemonic(&quot;FileChooser.newFolderButtonMnemonic&quot;, l);
 860         deleteFileButtonMnemonic = getMnemonic(&quot;FileChooser.deleteFileButtonMnemonic&quot;, l);
 861         renameFileButtonMnemonic = getMnemonic(&quot;FileChooser.renameFileButtonMnemonic&quot;, l);
 862 
 863         newFolderButtonToolTipText = UIManager.getString(&quot;FileChooser.newFolderButtonToolTipText&quot;, l);
 864         deleteFileButtonToolTipText = UIManager.getString(&quot;FileChooser.deleteFileButtonToolTipText&quot;, l);
 865         renameFileButtonToolTipText = UIManager.getString(&quot;FileChooser.renameFileButtonToolTipText&quot;, l);
 866 
 867         renameFileDialogText = UIManager.getString(&quot;FileChooser.renameFileDialogText&quot;, l);
 868         renameFileErrorTitle = UIManager.getString(&quot;FileChooser.renameFileErrorTitle&quot;, l);
 869         renameFileErrorText = UIManager.getString(&quot;FileChooser.renameFileErrorText&quot;, l);
 870 
 871         foldersLabelText = UIManager.getString(&quot;FileChooser.foldersLabelText&quot;,l);
 872         foldersLabelMnemonic = getMnemonic(&quot;FileChooser.foldersLabelMnemonic&quot;, l);
 873 
 874         filesLabelText = UIManager.getString(&quot;FileChooser.filesLabelText&quot;,l);
 875         filesLabelMnemonic = getMnemonic(&quot;FileChooser.filesLabelMnemonic&quot;, l);
 876 
 877         pathLabelText = UIManager.getString(&quot;FileChooser.pathLabelText&quot;,l);
 878         pathLabelMnemonic = getMnemonic(&quot;FileChooser.pathLabelMnemonic&quot;, l);
 879 
 880         filterLabelText = UIManager.getString(&quot;FileChooser.filterLabelText&quot;, l);
 881         filterLabelMnemonic = UIManager.getInt(&quot;FileChooser.filterLabelMnemonic&quot;);
 882     }
 883 
 884     protected void uninstallStrings(JFileChooser fc) {
 885         super.uninstallStrings(fc);
 886 
 887         newFolderButtonText = null;
 888         deleteFileButtonText = null;
 889         renameFileButtonText = null;
 890 
 891         newFolderButtonToolTipText = null;
 892         deleteFileButtonToolTipText = null;
 893         renameFileButtonToolTipText = null;
 894 
 895         renameFileDialogText = null;
 896         renameFileErrorTitle = null;
 897         renameFileErrorText = null;
 898 
 899         foldersLabelText = null;
 900         filesLabelText = null;
 901 
 902         pathLabelText = null;
 903 
 904         newFolderDialogText = null;
 905         newFolderErrorText = null;
 906         newFolderErrorSeparator = null;
 907     }
 908 
 909     protected JScrollPane createFilesList() {
 910         fileList = new JList&lt;&gt;();
 911         fileList.setName(&quot;GTKFileChooser.fileList&quot;);
 912         fileList.putClientProperty(AccessibleContext.ACCESSIBLE_NAME_PROPERTY, filesLabelText);
 913 
 914         if (getFileChooser().isMultiSelectionEnabled()) {
 915             fileList.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
 916         } else {
 917             fileList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
 918         }
 919 
 920         fileList.setModel(new GTKFileListModel());
 921         fileList.getSelectionModel().removeSelectionInterval(0, 0);
 922         fileList.setCellRenderer(new FileCellRenderer());
 923         fileList.addListSelectionListener(createListSelectionListener(getFileChooser()));
 924         fileList.addMouseListener(createDoubleClickListener(getFileChooser(), fileList));
 925         align(fileList);
 926         JScrollPane scrollpane = new JScrollPane(fileList);
 927     scrollpane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
 928         scrollpane.setName(&quot;GTKFileChooser.fileListScrollPane&quot;);
 929         scrollpane.setPreferredSize(prefListSize);
 930         scrollpane.setMaximumSize(MAX_SIZE);
 931         align(scrollpane);
 932         return scrollpane;
 933     }
 934 
 935     protected JScrollPane createDirectoryList() {
 936         directoryList = new JList&lt;&gt;();
 937         directoryList.setName(&quot;GTKFileChooser.directoryList&quot;);
 938         directoryList.putClientProperty(AccessibleContext.ACCESSIBLE_NAME_PROPERTY, foldersLabelText);
 939         align(directoryList);
 940 
 941         directoryList.setCellRenderer(new DirectoryCellRenderer());
 942         directoryListModel = new GTKDirectoryListModel();
 943         directoryList.getSelectionModel().removeSelectionInterval(0, 0);
 944         directoryList.setModel(directoryListModel);
 945         directoryList.addMouseListener(createDoubleClickListener(getFileChooser(), directoryList));
 946         directoryList.addListSelectionListener(createListSelectionListener(getFileChooser()));
 947 
 948         JScrollPane scrollpane = new JScrollPane(directoryList);
 949     scrollpane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
 950         scrollpane.setName(&quot;GTKFileChooser.directoryListScrollPane&quot;);
 951         scrollpane.setMaximumSize(MAX_SIZE);
 952         scrollpane.setPreferredSize(prefListSize);
 953         align(scrollpane);
 954         return scrollpane;
 955     }
 956 
 957     protected void createModel() {
 958         model = new GTKDirectoryModel();
 959     }
 960 
 961     public BasicDirectoryModel getModel() {
 962         return model;
 963     }
 964 
 965     public Action getApproveSelectionAction() {
 966         return approveSelectionAction;
 967     }
 968 
 969     @SuppressWarnings(&quot;serial&quot;) // Superclass is not serializable across versions
 970     private final class GTKDirectoryModel extends BasicDirectoryModel {
 971         private GTKDirectoryModel() {
 972             super(getFileChooser());
 973         }
 974 
 975         protected void sort(Vector&lt;? extends File&gt; v) {
 976             FileSystemView fsv = getFileChooser().getFileSystemView();
 977             if (fsv == null) {
 978                 super.sort(v);
 979             } else {
 980                 v.sort(Comparator.comparing(fsv::getSystemDisplayName));
 981             }
 982         }
 983     }
 984 
 985     @SuppressWarnings(&quot;serial&quot;) // Superclass is not serializable across versions
 986     protected class GTKDirectoryListModel extends AbstractListModel&lt;File&gt; implements ListDataListener {
 987         File curDir;
 988         public GTKDirectoryListModel() {
 989             getModel().addListDataListener(this);
 990             directoryChanged();
 991         }
 992 
 993         public int getSize() {
 994             return getModel().getDirectories().size() + 1;
 995         }
 996 
 997         @Override
 998         public File getElementAt(int index) {
 999             return index &gt; 0 ? getModel().getDirectories().elementAt(index - 1):
1000                     curDir;
1001         }
1002 
1003         public void intervalAdded(ListDataEvent e) {
1004             fireIntervalAdded(this, e.getIndex0(), e.getIndex1());
1005         }
1006 
1007         public void intervalRemoved(ListDataEvent e) {
1008             fireIntervalRemoved(this, e.getIndex0(), e.getIndex1());
1009         }
1010 
1011         // PENDING - this is inefficient - should sent out
1012         // incremental adjustment values instead of saying that the
1013         // whole list has changed.
1014         public void fireContentsChanged() {
1015             fireContentsChanged(this, 0, getModel().getDirectories().size()-1);
1016         }
1017 
1018         // PENDING - fire the correct interval changed - currently sending
1019         // out that everything has changed
1020         public void contentsChanged(ListDataEvent e) {
1021             fireContentsChanged();
1022         }
1023 
1024         private void directoryChanged() {
1025             curDir = getFileChooser().getFileSystemView().createFileObject(
1026                     getFileChooser().getCurrentDirectory(), &quot;.&quot;);
1027         }
1028     }
1029 
1030     @SuppressWarnings(&quot;serial&quot;) // Superclass is not serializable across versions
1031     protected class GTKFileListModel extends AbstractListModel&lt;File&gt; implements ListDataListener {
1032         public GTKFileListModel() {
1033             getModel().addListDataListener(this);
1034         }
1035 
1036         public int getSize() {
1037             return getModel().getFiles().size();
1038         }
1039 
1040         public boolean contains(Object o) {
1041             return getModel().getFiles().contains(o);
1042         }
1043 
1044         public int indexOf(Object o) {
1045             return getModel().getFiles().indexOf(o);
1046         }
1047 
1048         @Override
1049         public File getElementAt(int index) {
1050             return getModel().getFiles().elementAt(index);
1051         }
1052 
1053         public void intervalAdded(ListDataEvent e) {
1054             fireIntervalAdded(this, e.getIndex0(), e.getIndex1());
1055         }
1056 
1057         public void intervalRemoved(ListDataEvent e) {
1058             fireIntervalRemoved(this, e.getIndex0(), e.getIndex1());
1059         }
1060 
1061         // PENDING - this is inefficient - should sent out
1062         // incremental adjustment values instead of saying that the
1063         // whole list has changed.
1064         public void fireContentsChanged() {
1065             fireContentsChanged(this, 0, getModel().getFiles().size()-1);
1066         }
1067 
1068         // PENDING - fire the interval changed
1069         public void contentsChanged(ListDataEvent e) {
1070             fireContentsChanged();
1071         }
1072     }
1073 
1074 
1075     @SuppressWarnings(&quot;serial&quot;) // Superclass is not serializable across versions
1076     protected class FileCellRenderer extends DefaultListCellRenderer  {
1077         public Component getListCellRendererComponent(JList&lt;?&gt; list, Object value, int index,
1078                                                       boolean isSelected, boolean cellHasFocus) {
1079 
1080             super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
1081             setText(getFileChooser().getName((File) value));
1082             if (showFileIcons) {
1083                 setIcon(getFileChooser().getIcon((File)value));
1084             }
1085             return this;
1086         }
1087     }
1088 
1089     @SuppressWarnings(&quot;serial&quot;) // Superclass is not serializable across versions
1090     protected class DirectoryCellRenderer extends DefaultListCellRenderer  {
1091         public Component getListCellRendererComponent(JList&lt;?&gt; list, Object value, int index,
1092                                                       boolean isSelected, boolean cellHasFocus) {
1093 
1094             super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
1095 
1096             if (showDirectoryIcons) {
1097                 setIcon(getFileChooser().getIcon((File)value));
1098                 setText(getFileChooser().getName((File)value));
1099             } else {
1100                 setText(getFileChooser().getName((File)value) + &quot;/&quot;);
1101             }
1102             return this;
1103         }
1104     }
1105 
1106     @Override
1107     public Dimension getPreferredSize(JComponent c) {
1108         Dimension prefSize = new Dimension(PREF_SIZE);
1109         JComponent accessory = getFileChooser().getAccessory();
1110         if (accessory != null) {
1111             prefSize.width += accessory.getPreferredSize().width + 20;
1112         }
1113         Dimension d = c.getLayout().preferredLayoutSize(c);
1114         if (d != null) {
1115             return new Dimension(d.width &lt; prefSize.width ? prefSize.width : d.width,
1116                                  d.height &lt; prefSize.height ? prefSize.height : d.height);
1117         } else {
1118             return prefSize;
1119         }
1120     }
1121 
1122     @Override
1123     public Dimension getMinimumSize(JComponent x) {
1124         return new Dimension(MIN_WIDTH, MIN_HEIGHT);
1125     }
1126 
1127     @Override
1128     public Dimension getMaximumSize(JComponent x) {
1129         return new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE);
1130     }
1131 
1132     protected void align(JComponent c) {
1133         c.setAlignmentX(JComponent.LEFT_ALIGNMENT);
1134         c.setAlignmentY(JComponent.TOP_ALIGNMENT);
1135     }
1136 
1137     public Action getNewFolderAction() {
1138         if (newFolderAction == null) {
1139             newFolderAction = new NewFolderAction();
1140             newFolderAction.setEnabled(!readOnly);
1141         }
1142         return newFolderAction;
1143     }
1144 
1145     //
1146     // DataModel for DirectoryComboxbox
1147     //
1148     protected DirectoryComboBoxModel createDirectoryComboBoxModel(JFileChooser fc) {
1149         return new DirectoryComboBoxModel();
1150     }
1151 
1152     /**
1153      * Data model for a type-face selection combo-box.
1154      */
1155     @SuppressWarnings(&quot;serial&quot;) // Superclass is not serializable across versions
1156     protected class DirectoryComboBoxModel extends AbstractListModel&lt;File&gt; implements ComboBoxModel&lt;File&gt; {
1157         Vector&lt;File&gt; directories = new Vector&lt;File&gt;();
1158         File selectedDirectory = null;
1159         JFileChooser chooser = getFileChooser();
1160         FileSystemView fsv = chooser.getFileSystemView();
1161 
1162         public DirectoryComboBoxModel() {
1163             // Add the current directory to the model, and make it the
1164             // selectedDirectory
1165             File dir = getFileChooser().getCurrentDirectory();
1166             if (dir != null) {
1167                 addItem(dir);
1168             }
1169         }
1170 
1171         /**
1172          * Adds the directory to the model and sets it to be selected,
1173          * additionally clears out the previous selected directory and
1174          * the paths leading up to it, if any.
1175          */
1176         private void addItem(File directory) {
1177 
1178             if (directory == null) {
1179                 return;
1180             }
1181 
1182             int oldSize = directories.size();
1183             directories.clear();
1184             if (oldSize &gt; 0) {
1185                 fireIntervalRemoved(this, 0, oldSize);
1186             }
1187 
1188             // Get the canonical (full) path. This has the side
1189             // benefit of removing extraneous chars from the path,
1190             // for example /foo/bar/ becomes /foo/bar
1191             File canonical;
1192             try {
1193                 canonical = fsv.createFileObject(ShellFolder.getNormalizedFile(directory).getPath());
1194             } catch (IOException e) {
1195                 // Maybe drive is not ready. Can&#39;t abort here.
1196                 canonical = directory;
1197             }
1198 
1199             // create File instances of each directory leading up to the top
1200             File f = canonical;
1201             do {
1202                 directories.add(f);
1203             } while ((f = f.getParentFile()) != null);
1204             int newSize = directories.size();
1205             if (newSize &gt; 0) {
1206                 fireIntervalAdded(this, 0, newSize);
1207             }
1208             setSelectedItem(canonical);
1209         }
1210 
1211         public void setSelectedItem(Object selectedDirectory) {
1212             this.selectedDirectory = (File)selectedDirectory;
1213             fireContentsChanged(this, -1, -1);
1214         }
1215 
1216         public Object getSelectedItem() {
1217             return selectedDirectory;
1218         }
1219 
1220         public int getSize() {
1221             return directories.size();
1222         }
1223 
1224         @Override
1225         public File getElementAt(int index) {
1226             return directories.elementAt(index);
1227         }
1228     }
1229 
1230     /**
1231      * Acts when DirectoryComboBox has changed the selected item.
1232      */
1233     @SuppressWarnings(&quot;serial&quot;) // Superclass is not serializable across versions
1234     protected class DirectoryComboBoxAction extends AbstractAction {
1235         protected DirectoryComboBoxAction() {
1236             super(&quot;DirectoryComboBoxAction&quot;);
1237         }
1238 
1239         public void actionPerformed(ActionEvent e) {
1240             File f = (File)directoryComboBox.getSelectedItem();
1241             getFileChooser().setCurrentDirectory(f);
1242         }
1243     }
1244 
1245     /**
1246      * Creates a new folder.
1247      */
1248     @SuppressWarnings(&quot;serial&quot;) // Superclass is not serializable across versions
1249     private class NewFolderAction extends AbstractAction {
1250         protected NewFolderAction() {
1251             super(FilePane.ACTION_NEW_FOLDER);
1252         }
1253         public void actionPerformed(ActionEvent e) {
1254             if (readOnly) {
1255                 return;
1256             }
1257             JFileChooser fc = getFileChooser();
1258             File currentDirectory = fc.getCurrentDirectory();
1259             String dirName = JOptionPane.showInputDialog(fc,
1260                     newFolderDialogText, newFolderButtonText,
1261                     JOptionPane.PLAIN_MESSAGE);
1262 
1263             if (dirName != null) {
1264                 if (!currentDirectory.exists()) {
1265                     JOptionPane.showMessageDialog(fc,
1266                             MessageFormat.format(newFolderNoDirectoryErrorText, dirName),
1267                             newFolderNoDirectoryErrorTitleText, JOptionPane.ERROR_MESSAGE);
1268                     return;
1269                 }
1270 
1271                 File newDir = fc.getFileSystemView().createFileObject
1272                         (currentDirectory, dirName);
1273                 if (newDir == null || !newDir.mkdir()) {
1274                     JOptionPane.showMessageDialog(fc,
1275                             newFolderErrorText + newFolderErrorSeparator + &quot; \&quot;&quot; +
1276                             dirName + &quot;\&quot;&quot;,
1277                             newFolderErrorText, JOptionPane.ERROR_MESSAGE);
1278                 }
1279                 fc.rescanCurrentDirectory();
1280             }
1281         }
1282     }
1283 
1284     @SuppressWarnings(&quot;serial&quot;) // Superclass is not serializable across versions
1285     private class GTKApproveSelectionAction extends ApproveSelectionAction {
1286         public void actionPerformed(ActionEvent e) {
1287             if (isDirectorySelected()) {
1288                 File dir = getDirectory();
1289                 try {
1290                     // Strip trailing &quot;..&quot;
1291                     if (dir != null) {
1292                         dir = ShellFolder.getNormalizedFile(dir);
1293                     }
1294                 } catch (IOException ex) {
1295                     // Ok, use f as is
1296                 }
1297                 if (getFileChooser().getCurrentDirectory().equals(dir)) {
1298                     directoryList.clearSelection();
1299                     fileList.clearSelection();
1300                     ListSelectionModel sm = fileList.getSelectionModel();
1301                     if (sm instanceof DefaultListSelectionModel) {
1302                         ((DefaultListSelectionModel)sm).moveLeadSelectionIndex(0);
1303                         sm.setAnchorSelectionIndex(0);
1304                     }
1305                     rescanCurrentDirectory(getFileChooser());
1306                     return;
1307                 }
1308             }
1309             super.actionPerformed(e);
1310         }
1311     }
1312 
1313     /**
1314      * Renames file
1315      */
1316     @SuppressWarnings(&quot;serial&quot;) // Superclass is not serializable across versions
1317     private class RenameFileAction extends AbstractAction {
1318         protected RenameFileAction() {
1319             super(FilePane.ACTION_EDIT_FILE_NAME);
1320         }
1321         public void actionPerformed(ActionEvent e) {
1322             if (getFileName().isEmpty()) {
1323                 return;
1324             }
1325             JFileChooser fc = getFileChooser();
1326             File currentDirectory = fc.getCurrentDirectory();
1327             String newFileName = (String) JOptionPane.showInputDialog
1328                    (fc, new MessageFormat(renameFileDialogText).format
1329                            (new Object[] { getFileName() }),
1330                            renameFileButtonText, JOptionPane.PLAIN_MESSAGE, null, null,
1331                            getFileName());
1332 
1333             if (newFileName != null) {
1334                 File oldFile = fc.getFileSystemView().createFileObject
1335                         (currentDirectory, getFileName());
1336                 File newFile = fc.getFileSystemView().createFileObject
1337                         (currentDirectory, newFileName);
1338                 if (oldFile == null || newFile == null ||
1339                         !getModel().renameFile(oldFile, newFile)) {
1340                     JOptionPane.showMessageDialog(fc,
1341                             new MessageFormat(renameFileErrorText).
1342                             format(new Object[] { getFileName(), newFileName}),
1343                             renameFileErrorTitle, JOptionPane.ERROR_MESSAGE);
1344                 } else {
1345                     setFileName(getFileChooser().getName(newFile));
1346                     fc.rescanCurrentDirectory();
1347                 }
1348             }
1349         }
1350     }
1351 
1352     //
1353     // Renderer for Filter ComboBox
1354     //
1355     protected FilterComboBoxRenderer createFilterComboBoxRenderer() {
1356         return new FilterComboBoxRenderer();
1357     }
1358 
1359     /**
1360      * Render different filters
1361      */
1362     @SuppressWarnings(&quot;serial&quot;) // Superclass is not serializable across versions
1363     public class FilterComboBoxRenderer extends DefaultListCellRenderer {
1364         public String getName() {
1365             // As SynthComboBoxRenderer&#39;s are asked for a size BEFORE they
1366             // are parented getName is overriden to force the name to be
1367             // ComboBox.renderer if it isn&#39;t set. If we didn&#39;t do this the
1368             // wrong style could be used for size calculations.
1369             String name = super.getName();
1370             if (name == null) {
1371                 return &quot;ComboBox.renderer&quot;;
1372             }
1373             return name;
1374         }
1375 
1376         public Component getListCellRendererComponent(JList&lt;?&gt; list, Object value,
1377                                                       int index, boolean isSelected,
1378                                                       boolean cellHasFocus) {
1379 
1380             super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
1381 
1382             setName(&quot;ComboBox.listRenderer&quot;);
1383 
1384             if (value != null) {
1385                 if (value instanceof FileFilter) {
1386                     setText(((FileFilter) value).getDescription());
1387                 }
1388             } else {
1389                 setText(&quot;&quot;);
1390             }
1391 
1392             return this;
1393         }
1394     }
1395 
1396     //
1397     // DataModel for Filter Combobox
1398     //
1399     protected FilterComboBoxModel createFilterComboBoxModel() {
1400         return new FilterComboBoxModel();
1401     }
1402 
1403     /**
1404      * Data model for filter combo-box.
1405      */
1406     @SuppressWarnings(&quot;serial&quot;) // JDK implementation class
1407     protected class FilterComboBoxModel extends AbstractListModel&lt;FileFilter&gt;
1408             implements ComboBoxModel&lt;FileFilter&gt;, PropertyChangeListener {
1409         protected FileFilter[] filters;
1410 
1411         protected FilterComboBoxModel() {
1412             super();
1413             filters = getFileChooser().getChoosableFileFilters();
1414         }
1415 
1416         public void propertyChange(PropertyChangeEvent e) {
1417             String prop = e.getPropertyName();
1418             if (prop == JFileChooser.CHOOSABLE_FILE_FILTER_CHANGED_PROPERTY) {
1419                 filters = (FileFilter[]) e.getNewValue();
1420                 fireContentsChanged(this, -1, -1);
1421             } else if (prop == JFileChooser.FILE_FILTER_CHANGED_PROPERTY) {
1422                 fireContentsChanged(this, -1, -1);
1423             }
1424         }
1425 
1426         public void setSelectedItem(Object filter) {
1427             if (filter != null) {
1428                 getFileChooser().setFileFilter((FileFilter) filter);
1429                 fireContentsChanged(this, -1, -1);
1430             }
1431         }
1432 
1433         public Object getSelectedItem() {
1434             // Ensure that the current filter is in the list.
1435             // NOTE: we shouldnt&#39; have to do this, since JFileChooser adds
1436             // the filter to the choosable filters list when the filter
1437             // is set. Lets be paranoid just in case someone overrides
1438             // setFileFilter in JFileChooser.
1439             FileFilter currentFilter = getFileChooser().getFileFilter();
1440             boolean found = false;
1441             if (currentFilter != null) {
1442                 for (FileFilter filter : filters) {
1443                     if (filter == currentFilter) {
1444                         found = true;
1445                     }
1446                 }
1447                 if (found == false) {
1448                     getFileChooser().addChoosableFileFilter(currentFilter);
1449                 }
1450             }
1451             return getFileChooser().getFileFilter();
1452         }
1453 
1454         public int getSize() {
1455             if (filters != null) {
1456                 return filters.length;
1457             } else {
1458                 return 0;
1459             }
1460         }
1461 
1462         @Override
1463         public FileFilter getElementAt(int index) {
1464             if (index &gt; getSize() - 1) {
1465                 // This shouldn&#39;t happen. Try to recover gracefully.
1466                 return getFileChooser().getFileFilter();
1467             }
1468             if (filters != null) {
1469                 return filters[index];
1470             } else {
1471                 return null;
1472             }
1473         }
1474     }
1475 }
    </pre>
  </body>
</html>
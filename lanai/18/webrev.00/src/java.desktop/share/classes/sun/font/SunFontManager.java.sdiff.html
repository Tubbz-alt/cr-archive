<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/classes/sun/font/SunFontManager.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../awt/ComponentFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TrueTypeFont.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/classes/sun/font/SunFontManager.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.font;
  27 
  28 import java.awt.Font;
  29 import java.awt.FontFormatException;
  30 import java.io.BufferedReader;
  31 import java.io.File;
  32 import java.io.FileInputStream;
  33 import java.io.FilenameFilter;
  34 import java.io.IOException;
  35 import java.io.InputStreamReader;
  36 import java.security.AccessController;
  37 import java.security.PrivilegedAction;
  38 import java.util.ArrayList;
  39 import java.util.HashMap;
  40 import java.util.HashSet;
  41 import java.util.Hashtable;
<span class="line-removed">  42 import java.util.Iterator;</span>
  43 import java.util.List;
  44 import java.util.Locale;
  45 import java.util.Map;
  46 import java.util.NoSuchElementException;
  47 import java.util.StringTokenizer;
  48 import java.util.TreeMap;
  49 import java.util.Vector;
  50 import java.util.concurrent.ConcurrentHashMap;
  51 
  52 import javax.swing.plaf.FontUIResource;
  53 
  54 import sun.awt.FontConfiguration;
  55 import sun.awt.SunToolkit;
  56 import sun.awt.util.ThreadGroupUtils;
  57 import sun.java2d.FontSupport;
  58 import sun.util.logging.PlatformLogger;
  59 
  60 /**
  61  * The base implementation of the {@link FontManager} interface. It implements
  62  * the platform independent, shared parts of OpenJDK&#39;s FontManager
</pre>
<hr />
<pre>
 114                     name.startsWith(&quot;.ttc&quot;, offset) ||
 115                     name.startsWith(&quot;.TTC&quot;, offset) ||
 116                     name.startsWith(&quot;.otf&quot;, offset) ||
 117                     name.startsWith(&quot;.OTF&quot;, offset);
 118                 if (isTT) {
 119                     return true;
 120                 } else if (noType1Font) {
 121                     return false;
 122                 } else {
 123                     return(name.startsWith(&quot;.pfa&quot;, offset) ||
 124                            name.startsWith(&quot;.pfb&quot;, offset) ||
 125                            name.startsWith(&quot;.PFA&quot;, offset) ||
 126                            name.startsWith(&quot;.PFB&quot;, offset));
 127                 }
 128             }
 129         }
 130     }
 131 
 132     private static Font2DHandle FONT_HANDLE_NULL = new Font2DHandle(null);
 133 
<span class="line-modified"> 134      public static final int FONTFORMAT_NONE = -1;</span>
<span class="line-modified"> 135      public static final int FONTFORMAT_TRUETYPE = 0;</span>
<span class="line-modified"> 136      public static final int FONTFORMAT_TYPE1 = 1;</span>
<span class="line-modified"> 137      public static final int FONTFORMAT_TTC = 2;</span>
<span class="line-modified"> 138      public static final int FONTFORMAT_COMPOSITE = 3;</span>
<span class="line-modified"> 139      public static final int FONTFORMAT_NATIVE = 4;</span>
<span class="line-modified"> 140 </span>
<span class="line-modified"> 141      /* Pool of 20 font file channels chosen because some UTF-8 locale</span>
<span class="line-modified"> 142       * composite fonts can use up to 16 platform fonts (including the</span>
<span class="line-modified"> 143       * Lucida fall back). This should prevent channel thrashing when</span>
<span class="line-modified"> 144       * dealing with one of these fonts.</span>
<span class="line-modified"> 145       * The pool array stores the fonts, rather than directly referencing</span>
<span class="line-modified"> 146       * the channels, as the font needs to do the open/close work.</span>
<span class="line-modified"> 147       */</span>
<span class="line-modified"> 148      // MACOSX begin -- need to access these in subclass</span>
<span class="line-modified"> 149      protected static final int CHANNELPOOLSIZE = 20;</span>
<span class="line-modified"> 150      protected FileFont[] fontFileCache = new FileFont[CHANNELPOOLSIZE];</span>
<span class="line-modified"> 151      // MACOSX end</span>
<span class="line-modified"> 152      private int lastPoolIndex = 0;</span>
 153 
 154     /* Need to implement a simple linked list scheme for fast
 155      * traversal and lookup.
 156      * Also want to &quot;fast path&quot; dialog so there&#39;s minimal overhead.
 157      */
 158     /* There are at exactly 20 composite fonts: 5 faces (but some are not
 159      * usually different), in 4 styles. The array may be auto-expanded
 160      * later if more are needed, eg for user-defined composites or locale
 161      * variants.
 162      */
 163     private int maxCompFont = 0;
 164     private CompositeFont [] compFonts = new CompositeFont[20];
 165     private ConcurrentHashMap&lt;String, CompositeFont&gt;
<span class="line-modified"> 166         compositeFonts = new ConcurrentHashMap&lt;String, CompositeFont&gt;();</span>
 167     private ConcurrentHashMap&lt;String, PhysicalFont&gt;
<span class="line-modified"> 168         physicalFonts = new ConcurrentHashMap&lt;String, PhysicalFont&gt;();</span>
 169     private ConcurrentHashMap&lt;String, PhysicalFont&gt;
<span class="line-modified"> 170         registeredFonts = new ConcurrentHashMap&lt;String, PhysicalFont&gt;();</span>
 171 
 172     /* given a full name find the Font. Remind: there&#39;s duplication
 173      * here in that this contains the content of compositeFonts +
 174      * physicalFonts.
 175      */
 176     // MACOSX begin -- need to access this in subclass
 177     protected ConcurrentHashMap&lt;String, Font2D&gt;
<span class="line-modified"> 178         fullNameToFont = new ConcurrentHashMap&lt;String, Font2D&gt;();</span>
 179     // MACOSX end
 180 
 181     /* TrueType fonts have localised names. Support searching all
 182      * of these before giving up on a name.
 183      */
 184     private HashMap&lt;String, TrueTypeFont&gt; localeFullNamesToFont;
 185 
 186     private PhysicalFont defaultPhysicalFont;
 187 
 188     static boolean longAddresses;
 189     private boolean loaded1dot0Fonts = false;
 190     boolean loadedAllFonts = false;
 191     boolean loadedAllFontFiles = false;
 192     String[] jreOtherFontFiles;
 193     boolean noOtherJREFontFiles = false; // initial assumption.
 194 
 195     public static String jreLibDirName;
 196     public static String jreFontDirName;
 197     private static HashSet&lt;String&gt; missingFontFiles = null;
 198     private String defaultFontName;
</pre>
<hr />
<pre>
 249         FontManager fm = FontManagerFactory.getInstance();
 250         return (SunFontManager) fm;
 251     }
 252 
 253     public FilenameFilter getTrueTypeFilter() {
 254         return ttFilter;
 255     }
 256 
 257     public FilenameFilter getType1Filter() {
 258         return t1Filter;
 259     }
 260 
 261     /* After we reach MAXSOFTREFCNT, use weak refs for created fonts.
 262      * This means that a small number of created fonts as used in a UI app
 263      * will not be eagerly collected, but an app that create many will
 264      * have them collected more frequently to reclaim storage.
 265      */
 266     private static int maxSoftRefCnt = 10;
 267 
 268     static {













 269 
<span class="line-modified"> 270         java.security.AccessController.doPrivileged(</span>
<span class="line-modified"> 271                                     new java.security.PrivilegedAction&lt;Object&gt;() {</span>
<span class="line-modified"> 272 </span>
<span class="line-removed"> 273            public Object run() {</span>
<span class="line-removed"> 274                FontManagerNativeLibrary.load();</span>
<span class="line-removed"> 275 </span>
<span class="line-removed"> 276                // JNI throws an exception if a class/method/field is not found,</span>
<span class="line-removed"> 277                // so there&#39;s no need to do anything explicit here.</span>
<span class="line-removed"> 278                initIDs();</span>
<span class="line-removed"> 279 </span>
<span class="line-removed"> 280                switch (StrikeCache.nativeAddressSize) {</span>
<span class="line-removed"> 281                case 8: longAddresses = true; break;</span>
<span class="line-removed"> 282                case 4: longAddresses = false; break;</span>
<span class="line-removed"> 283                default: throw new RuntimeException(&quot;Unexpected address size&quot;);</span>
<span class="line-removed"> 284                }</span>
<span class="line-removed"> 285 </span>
<span class="line-removed"> 286                noType1Font =</span>
<span class="line-removed"> 287                    &quot;true&quot;.equals(System.getProperty(&quot;sun.java2d.noType1Font&quot;));</span>
<span class="line-removed"> 288                jreLibDirName =</span>
<span class="line-removed"> 289                    System.getProperty(&quot;java.home&quot;,&quot;&quot;) + File.separator + &quot;lib&quot;;</span>
<span class="line-removed"> 290                jreFontDirName = jreLibDirName + File.separator + &quot;fonts&quot;;</span>
<span class="line-removed"> 291 </span>
<span class="line-removed"> 292                 maxSoftRefCnt =</span>
<span class="line-removed"> 293                     Integer.getInteger(&quot;sun.java2d.font.maxSoftRefs&quot;, 10);</span>
 294 
<span class="line-modified"> 295                return null;</span>
<span class="line-modified"> 296            }</span>

 297         });
 298     }
 299 
 300     /**
 301      * If the module image layout changes the location of JDK fonts,
 302      * this will be updated to reflect that.
 303      */
 304     public static final String getJDKFontDir() {
 305         return jreFontDirName;
 306     }
 307 
 308     public TrueTypeFont getEUDCFont() {
 309         // Overridden in Windows.
 310         return null;
 311     }
 312 
 313     /* Initialise ptrs used by JNI methods */
 314     private static native void initIDs();
 315 
<span class="line-removed"> 316     @SuppressWarnings(&quot;unchecked&quot;)</span>
 317     protected SunFontManager() {
<span class="line-modified"> 318 </span>
<span class="line-modified"> 319         java.security.AccessController.doPrivileged(</span>
<span class="line-modified"> 320                 new java.security.PrivilegedAction&lt;Object&gt;() {</span>
<span class="line-modified"> 321                     public Object run() {</span>
<span class="line-modified"> 322                         File badFontFile =</span>
<span class="line-modified"> 323                             new File(jreFontDirName + File.separator +</span>
<span class="line-modified"> 324                                      &quot;badfonts.txt&quot;);</span>
<span class="line-modified"> 325                         if (badFontFile.exists()) {</span>
<span class="line-modified"> 326                             FileInputStream fis = null;</span>
<span class="line-modified"> 327                             try {</span>
<span class="line-modified"> 328                                 badFonts = new ArrayList&lt;&gt;();</span>
<span class="line-modified"> 329                                 fis = new FileInputStream(badFontFile);</span>
<span class="line-modified"> 330                                 InputStreamReader isr = new InputStreamReader(fis);</span>
<span class="line-modified"> 331                                 BufferedReader br = new BufferedReader(isr);</span>
<span class="line-modified"> 332                                 while (true) {</span>
<span class="line-removed"> 333                                     String name = br.readLine();</span>
<span class="line-removed"> 334                                     if (name == null) {</span>
<span class="line-removed"> 335                                         break;</span>
<span class="line-removed"> 336                                     } else {</span>
<span class="line-removed"> 337                                         if (FontUtilities.debugFonts()) {</span>
<span class="line-removed"> 338                                             FontUtilities.getLogger().warning(&quot;read bad font: &quot; +</span>
<span class="line-removed"> 339                                                            name);</span>
<span class="line-removed"> 340                                         }</span>
<span class="line-removed"> 341                                         badFonts.add(name);</span>
<span class="line-removed"> 342                                     }</span>
<span class="line-removed"> 343                                 }</span>
<span class="line-removed"> 344                             } catch (IOException e) {</span>
<span class="line-removed"> 345                                 try {</span>
<span class="line-removed"> 346                                     if (fis != null) {</span>
<span class="line-removed"> 347                                         fis.close();</span>
<span class="line-removed"> 348                                     }</span>
<span class="line-removed"> 349                                 } catch (IOException ioe) {</span>
 350                                 }

 351                             }
 352                         }



 353 
<span class="line-modified"> 354                         /* Here we get the fonts in jre/lib/fonts and register</span>
<span class="line-modified"> 355                          * them so they are always available and preferred over</span>
<span class="line-modified"> 356                          * other fonts. This needs to be registered before the</span>
<span class="line-modified"> 357                          * composite fonts as otherwise some native font that</span>
<span class="line-modified"> 358                          * corresponds may be found as we don&#39;t have a way to</span>
<span class="line-modified"> 359                          * handle two fonts of the same name, so the JRE one</span>
<span class="line-modified"> 360                          * must be the first one registered. Pass &quot;true&quot; to</span>
<span class="line-modified"> 361                          * registerFonts method as on-screen these JRE fonts</span>
<span class="line-modified"> 362                          * always go through the JDK rasteriser.</span>
<span class="line-modified"> 363                          */</span>
<span class="line-modified"> 364                         if (FontUtilities.isLinux) {</span>
<span class="line-modified"> 365                             /* Linux font configuration uses these fonts */</span>
<span class="line-modified"> 366                             registerFontDir(jreFontDirName);</span>
<span class="line-modified"> 367                         }</span>
<span class="line-modified"> 368                         registerFontsInDir(jreFontDirName, true, Font2D.JRE_RANK,</span>
<span class="line-modified"> 369                                            true, false);</span>
 370 
<span class="line-modified"> 371                         /* Create the font configuration and get any font path</span>
<span class="line-modified"> 372                          * that might be specified.</span>
<span class="line-modified"> 373                          */</span>
<span class="line-modified"> 374                         fontConfig = createFontConfiguration();</span>
<span class="line-modified"> 375 </span>
<span class="line-modified"> 376                         String[] fontInfo = getDefaultPlatformFont();</span>
<span class="line-modified"> 377                         defaultFontName = fontInfo[0];</span>
<span class="line-modified"> 378                         defaultFontFileName = fontInfo[1];</span>
<span class="line-modified"> 379 </span>
<span class="line-modified"> 380                         String extraFontPath = fontConfig.getExtraFontPath();</span>
<span class="line-modified"> 381 </span>
<span class="line-modified"> 382                         /* In prior releases the debugging font path replaced</span>
<span class="line-modified"> 383                          * all normally located font directories except for the</span>
<span class="line-modified"> 384                          * JRE fonts dir. This directory is still always located</span>
<span class="line-modified"> 385                          * and placed at the head of the path but as an</span>
<span class="line-modified"> 386                          * augmentation to the previous behaviour the</span>
<span class="line-modified"> 387                          * changes below allow you to additionally append to</span>
<span class="line-modified"> 388                          * the font path by starting with append: or prepend by</span>
<span class="line-modified"> 389                          * starting with a prepend: sign. Eg: to append</span>
<span class="line-modified"> 390                          * -Dsun.java2d.fontpath=append:/usr/local/myfonts</span>
<span class="line-modified"> 391                          * and to prepend</span>
<span class="line-modified"> 392                          * -Dsun.java2d.fontpath=prepend:/usr/local/myfonts Disp</span>
<span class="line-modified"> 393                          *</span>
<span class="line-modified"> 394                          * If there is an appendedfontpath it in the font</span>
<span class="line-modified"> 395                          * configuration it is used instead of searching the</span>
<span class="line-modified"> 396                          * system for dirs.</span>
<span class="line-modified"> 397                          * The behaviour of append and prepend is then similar</span>
<span class="line-modified"> 398                          * to the normal case. ie it goes after what</span>
<span class="line-modified"> 399                          * you prepend and * before what you append. If the</span>
<span class="line-modified"> 400                          * sun.java2d.fontpath property is used, but it</span>
<span class="line-modified"> 401                          * neither the append or prepend syntaxes is used then</span>
<span class="line-modified"> 402                          * as except for the JRE dir the path is replaced and it</span>
<span class="line-modified"> 403                          * is up to you to make sure that all the right</span>
<span class="line-modified"> 404                          * directories are located. This is platform and</span>
<span class="line-modified"> 405                          * locale-specific so its almost impossible to get</span>
<span class="line-modified"> 406                          * right, so it should be used with caution.</span>
<span class="line-modified"> 407                          */</span>
<span class="line-modified"> 408                         boolean prependToPath = false;</span>
<span class="line-modified"> 409                         boolean appendToPath = false;</span>
<span class="line-modified"> 410                         String dbgFontPath =</span>
<span class="line-modified"> 411                             System.getProperty(&quot;sun.java2d.fontpath&quot;);</span>
<span class="line-modified"> 412 </span>
<span class="line-modified"> 413                         if (dbgFontPath != null) {</span>
<span class="line-modified"> 414                             if (dbgFontPath.startsWith(&quot;prepend:&quot;)) {</span>
<span class="line-modified"> 415                                 prependToPath = true;</span>
<span class="line-modified"> 416                                 dbgFontPath =</span>
<span class="line-modified"> 417                                     dbgFontPath.substring(&quot;prepend:&quot;.length());</span>
<span class="line-modified"> 418                             } else if (dbgFontPath.startsWith(&quot;append:&quot;)) {</span>
<span class="line-modified"> 419                                 appendToPath = true;</span>
<span class="line-modified"> 420                                 dbgFontPath =</span>
<span class="line-modified"> 421                                     dbgFontPath.substring(&quot;append:&quot;.length());</span>
<span class="line-modified"> 422                             }</span>
<span class="line-removed"> 423                         }</span>
 424 
<span class="line-modified"> 425                         if (FontUtilities.debugFonts()) {</span>
<span class="line-modified"> 426                             PlatformLogger logger = FontUtilities.getLogger();</span>
<span class="line-modified"> 427                             logger.info(&quot;JRE font directory: &quot; + jreFontDirName);</span>
<span class="line-modified"> 428                             logger.info(&quot;Extra font path: &quot; + extraFontPath);</span>
<span class="line-modified"> 429                             logger.info(&quot;Debug font path: &quot; + dbgFontPath);</span>
<span class="line-modified"> 430                         }</span>
 431 
<span class="line-modified"> 432                         if (dbgFontPath != null) {</span>
<span class="line-modified"> 433                             /* In debugging mode we register all the paths</span>
<span class="line-modified"> 434                              * Caution: this is a very expensive call on Solaris:-</span>
<span class="line-modified"> 435                              */</span>
<span class="line-modified"> 436                             fontPath = getPlatformFontPath(noType1Font);</span>
 437 
<span class="line-modified"> 438                             if (extraFontPath != null) {</span>
<span class="line-modified"> 439                                 fontPath =</span>
<span class="line-modified"> 440                                     extraFontPath + File.pathSeparator + fontPath;</span>
<span class="line-modified"> 441                             }</span>
<span class="line-modified"> 442                             if (appendToPath) {</span>
<span class="line-modified"> 443                                 fontPath =</span>
<span class="line-modified"> 444                                     fontPath + File.pathSeparator + dbgFontPath;</span>
<span class="line-modified"> 445                             } else if (prependToPath) {</span>
<span class="line-modified"> 446                                 fontPath =</span>
<span class="line-modified"> 447                                     dbgFontPath + File.pathSeparator + fontPath;</span>
<span class="line-modified"> 448                             } else {</span>
<span class="line-modified"> 449                                 fontPath = dbgFontPath;</span>
<span class="line-modified"> 450                             }</span>
<span class="line-modified"> 451                             registerFontDirs(fontPath);</span>
<span class="line-modified"> 452                         } else if (extraFontPath != null) {</span>
<span class="line-modified"> 453                             /* If the font configuration contains an</span>
<span class="line-modified"> 454                              * &quot;appendedfontpath&quot; entry, it is interpreted as a</span>
<span class="line-modified"> 455                              * set of locations that should always be registered.</span>
<span class="line-modified"> 456                              * It may be additional to locations normally found</span>
<span class="line-modified"> 457                              * for that place, or it may be locations that need</span>
<span class="line-modified"> 458                              * to have all their paths registered to locate all</span>
<span class="line-modified"> 459                              * the needed platform names.</span>
<span class="line-modified"> 460                              * This is typically when the same .TTF file is</span>
<span class="line-modified"> 461                              * referenced from multiple font.dir files and all</span>
<span class="line-modified"> 462                              * of these must be read to find all the native</span>
<span class="line-modified"> 463                              * (XLFD) names for the font, so that X11 font APIs</span>
<span class="line-modified"> 464                              * can be used for as many code points as possible.</span>
<span class="line-removed"> 465                              */</span>
<span class="line-removed"> 466                             registerFontDirs(extraFontPath);</span>
<span class="line-removed"> 467                         }</span>
 468 
<span class="line-modified"> 469                         /* On Solaris, we need to register the Japanese TrueType</span>
<span class="line-modified"> 470                          * directory so that we can find the corresponding</span>
<span class="line-modified"> 471                          * bitmap fonts. This could be done by listing the</span>
<span class="line-modified"> 472                          * directory in the font configuration file, but we</span>
<span class="line-modified"> 473                          * don&#39;t want to confuse users with this quirk. There</span>
<span class="line-modified"> 474                          * are no bitmap fonts for other writing systems that</span>
<span class="line-modified"> 475                          * correspond to TrueType fonts and have matching XLFDs.</span>
<span class="line-modified"> 476                          * We need to register the bitmap fonts only in</span>
<span class="line-modified"> 477                          * environments where they&#39;re on the X font path, i.e.,</span>
<span class="line-modified"> 478                          * in the Japanese locale. Note that if the X Toolkit</span>
<span class="line-modified"> 479                          * is in use the font path isn&#39;t set up by JDK, but</span>
<span class="line-modified"> 480                          * users of a JA locale should have it</span>
<span class="line-modified"> 481                          * set up already by their login environment.</span>
<span class="line-modified"> 482                          */</span>
<span class="line-modified"> 483                         if (FontUtilities.isSolaris &amp;&amp; Locale.JAPAN.equals(Locale.getDefault())) {</span>
<span class="line-modified"> 484                             registerFontDir(&quot;/usr/openwin/lib/locale/ja/X11/fonts/TT&quot;);</span>
<span class="line-modified"> 485                         }</span>
 486 
<span class="line-modified"> 487                         initCompositeFonts(fontConfig, null);</span>
 488 
<span class="line-modified"> 489                         return null;</span>
<span class="line-modified"> 490                     }</span>
<span class="line-modified"> 491                 });</span>
 492 
 493         boolean platformFont = AccessController.doPrivileged(
<span class="line-modified"> 494                         new PrivilegedAction&lt;Boolean&gt;() {</span>
<span class="line-modified"> 495                                 public Boolean run() {</span>
<span class="line-modified"> 496                                         String prop =</span>
<span class="line-modified"> 497                                                 System.getProperty(&quot;java2d.font.usePlatformFont&quot;);</span>
<span class="line-modified"> 498                                         String env = System.getenv(&quot;JAVA2D_USEPLATFORMFONT&quot;);</span>
<span class="line-modified"> 499                                         return &quot;true&quot;.equals(prop) || env != null;</span>
<span class="line-modified"> 500                                 }</span>
<span class="line-removed"> 501                         });</span>
 502 
 503         if (platformFont) {
 504             usePlatformFontMetrics = true;
 505             System.out.println(&quot;Enabling platform font metrics for win32. This is an unsupported option.&quot;);
 506             System.out.println(&quot;This yields incorrect composite font metrics as reported by 1.1.x releases.&quot;);
 507             System.out.println(&quot;It is appropriate only for use by applications which do not use any Java 2&quot;);
 508             System.out.println(&quot;functionality. This property will be removed in a later release.&quot;);
 509         }
 510     }
 511 
 512     public Font2DHandle getNewComposite(String family, int style,
 513                                         Font2DHandle handle) {
 514 
 515         if (!(handle.font2D instanceof CompositeFont)) {
 516             return handle;
 517         }
 518 
 519         CompositeFont oldComp = (CompositeFont)handle.font2D;
 520         PhysicalFont oldFont = oldComp.getSlotFont(0);
 521 
</pre>
<hr />
<pre>
 805 
 806     private static final class FontRegistrationInfo {
 807 
 808         String fontFilePath;
 809         String[] nativeNames;
 810         int fontFormat;
 811         boolean javaRasterizer;
 812         int fontRank;
 813 
 814         FontRegistrationInfo(String fontPath, String[] names, int format,
 815                              boolean useJavaRasterizer, int rank) {
 816             this.fontFilePath = fontPath;
 817             this.nativeNames = names;
 818             this.fontFormat = format;
 819             this.javaRasterizer = useJavaRasterizer;
 820             this.fontRank = rank;
 821         }
 822     }
 823 
 824     private final ConcurrentHashMap&lt;String, FontRegistrationInfo&gt;
<span class="line-modified"> 825         deferredFontFiles =</span>
<span class="line-removed"> 826         new ConcurrentHashMap&lt;String, FontRegistrationInfo&gt;();</span>
 827     private final ConcurrentHashMap&lt;String, Font2DHandle&gt;
<span class="line-modified"> 828         initialisedFonts = new ConcurrentHashMap&lt;String, Font2DHandle&gt;();</span>
 829 
 830     /* Remind: possibly enhance initialiseDeferredFonts() to be
 831      * optionally given a name and a style and it could stop when it
 832      * finds that font - but this would be a problem if two of the
 833      * fonts reference the same font face name (cf the Solaris
 834      * euro fonts).
 835      */
 836     protected synchronized void initialiseDeferredFonts() {
 837         for (String fileName : deferredFontFiles.keySet()) {
 838             initialiseDeferredFont(fileName);
 839         }
 840     }
 841 
 842     protected synchronized void registerDeferredJREFonts(String jreDir) {
 843         for (FontRegistrationInfo info : deferredFontFiles.values()) {
 844             if (info.fontFilePath != null &amp;&amp;
 845                 info.fontFilePath.startsWith(jreDir)) {
 846                 initialiseDeferredFont(info.fontFilePath);
 847             }
 848         }
</pre>
<hr />
<pre>
 850 
 851     public boolean isDeferredFont(String fileName) {
 852         return deferredFontFiles.containsKey(fileName);
 853     }
 854 
 855     PhysicalFont findJREDeferredFont(String name, int style) {
 856 
 857         /* Iterate over the deferred font files looking for any in the
 858          * jre directory that we didn&#39;t recognise, open each of these.
 859          * In almost all installations this will quickly fall through
 860          * because jreOtherFontFiles will be empty.
 861          * noOtherJREFontFiles is used so we can skip this block as soon
 862          * as its determined that it&#39;s not needed - almost always after the
 863          * very first time through.
 864          */
 865         if (noOtherJREFontFiles) {
 866             return null;
 867         }
 868         synchronized (jreFontDirName) {
 869             if (jreOtherFontFiles == null) {
<span class="line-modified"> 870                 HashSet&lt;String&gt; otherFontFiles = new HashSet&lt;String&gt;();</span>
 871                 for (String deferredFile : deferredFontFiles.keySet()) {
 872                     File file = new File(deferredFile);
 873                     String dir = file.getParent();
<span class="line-removed"> 874                     String fname = file.getName();</span>
 875                     /* skip names which aren&#39;t absolute, aren&#39;t in the JRE
 876                      * directory, or are known Lucida fonts.
 877                      */
 878                     if (dir == null || !dir.equals(jreFontDirName)) {
 879                         continue;
 880                     }
 881                     otherFontFiles.add(deferredFile);
 882                 }
 883                 jreOtherFontFiles = otherFontFiles.toArray(STR_ARRAY);
 884                 if (jreOtherFontFiles.length == 0) {
 885                     noOtherJREFontFiles = true;
 886                 }
 887             }
 888 
 889             for (int i=0; i&lt;jreOtherFontFiles.length;i++) {
 890                 String fileName = jreOtherFontFiles[i];
 891                 if (fileName == null) {
 892                     continue;
 893                 }
 894                 jreOtherFontFiles[i] = null;
</pre>
<hr />
<pre>
 989         return registeredFonts.get(name);
 990     }
 991 
 992     /* Note that the return value from this method is not always
 993      * derived from this file, and may be null. See addToFontList for
 994      * some explanation of this.
 995      */
 996     public PhysicalFont registerFontFile(String fileName,
 997                                          String[] nativeNames,
 998                                          int fontFormat,
 999                                          boolean useJavaRasterizer,
1000                                          int fontRank) {
1001 
1002         PhysicalFont regFont = registeredFonts.get(fileName);
1003         if (regFont != null) {
1004             return regFont;
1005         }
1006 
1007         PhysicalFont physicalFont = null;
1008         try {
<span class="line-removed">1009             String name;</span>
<span class="line-removed">1010 </span>
1011             switch (fontFormat) {
1012 
1013             case FONTFORMAT_TRUETYPE:
1014                 int fn = 0;
1015                 TrueTypeFont ttf;
1016                 do {
1017                     ttf = new TrueTypeFont(fileName, nativeNames, fn++,
1018                                            useJavaRasterizer);
1019                     PhysicalFont pf = addToFontList(ttf, fontRank);
1020                     if (physicalFont == null) {
1021                         physicalFont = pf;
1022                     }
1023                 }
1024                 while (fn &lt; ttf.getFontCount());
1025                 break;
1026 
1027             case FONTFORMAT_TYPE1:
1028                 Type1Font t1f = new Type1Font(fileName, nativeNames);
1029                 physicalFont = addToFontList(t1f, fontRank);
1030                 break;
</pre>
<hr />
<pre>
1156 
1157     /* Obtained from Platform APIs (windows only)
1158      * Map from a lower-case family name to a list of full names of
1159      * the member fonts, eg:
1160      * &quot;arial&quot; -&gt; [&quot;Arial&quot;, &quot;Arial Bold&quot;, &quot;Arial Italic&quot;,&quot;Arial Bold Italic&quot;]
1161      */
1162     private HashMap&lt;String,ArrayList&lt;String&gt;&gt; familyToFontListMap= null;
1163 
1164     /* The directories which contain platform fonts */
1165     private String[] pathDirs = null;
1166 
1167     private boolean haveCheckedUnreferencedFontFiles;
1168 
1169     private String[] getFontFilesFromPath(boolean noType1) {
1170         final FilenameFilter filter;
1171         if (noType1) {
1172             filter = ttFilter;
1173         } else {
1174             filter = new TTorT1Filter();
1175         }
<span class="line-modified">1176         return (String[])AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {</span>
<span class="line-modified">1177             public Object run() {</span>
1178                 if (pathDirs.length == 1) {
1179                     File dir = new File(pathDirs[0]);
1180                     String[] files = dir.list(filter);
1181                     if (files == null) {
1182                         return new String[0];
1183                     }
1184                     for (int f=0; f&lt;files.length; f++) {
1185                         files[f] = files[f].toLowerCase();
1186                     }
1187                     return files;
1188                 } else {
<span class="line-modified">1189                     ArrayList&lt;String&gt; fileList = new ArrayList&lt;String&gt;();</span>
1190                     for (int i = 0; i&lt; pathDirs.length; i++) {
1191                         File dir = new File(pathDirs[i]);
1192                         String[] files = dir.list(filter);
1193                         if (files == null) {
1194                             continue;
1195                         }
<span class="line-modified">1196                         for (int f=0; f&lt;files.length ; f++) {</span>
1197                             fileList.add(files[f].toLowerCase());
1198                         }
1199                     }
1200                     return fileList.toArray(STR_ARRAY);
1201                 }
1202             }
1203         });
1204     }
1205 
1206     /* This is needed since some windows registry names don&#39;t match
1207      * the font names.
1208      * - UPC styled font names have a double space, but the
1209      * registry entry mapping to a file doesn&#39;t.
1210      * - Marlett is in a hidden file not listed in the registry
1211      * - The registry advertises that the file david.ttf contains a
1212      * font with the full name &quot;David Regular&quot; when in fact its
1213      * just &quot;David&quot;.
1214      * Directly fix up these known cases as this is faster.
1215      * If a font which doesn&#39;t match these known cases has no file,
1216      * it may be a font that has been temporarily added to the known set
</pre>
<hr />
<pre>
1233                     String newName = font.replaceFirst(&quot;  &quot;, &quot; &quot;);
1234                     file = fontToFileMap.get(newName);
1235                     /* If this name exists and isn&#39;t for a valid name
1236                      * replace the mapping to the file with this font
1237                      */
1238                     if (file != null &amp;&amp;
1239                         !fontToFamilyNameMap.containsKey(newName)) {
1240                         fontToFileMap.remove(newName);
1241                         fontToFileMap.put(font, file);
1242                     }
1243                 } else if (font.equals(&quot;marlett&quot;)) {
1244                     fontToFileMap.put(font, &quot;marlett.ttf&quot;);
1245                 } else if (font.equals(&quot;david&quot;)) {
1246                     file = fontToFileMap.get(&quot;david regular&quot;);
1247                     if (file != null) {
1248                         fontToFileMap.remove(&quot;david regular&quot;);
1249                         fontToFileMap.put(&quot;david&quot;, file);
1250                     }
1251                 } else {
1252                     if (unmappedFontNames == null) {
<span class="line-modified">1253                         unmappedFontNames = new ArrayList&lt;String&gt;();</span>
1254                     }
1255                     unmappedFontNames.add(font);
1256                 }
1257             }
1258         }
1259 
1260         if (unmappedFontNames != null) {
<span class="line-modified">1261             HashSet&lt;String&gt; unmappedFontFiles = new HashSet&lt;String&gt;();</span>
1262 
1263             /* Every font key in fontToFileMap ought to correspond to a
1264              * font key in fontToFamilyNameMap. Entries that don&#39;t seem
1265              * to correspond are likely fonts that were named differently
1266              * by GDI than in the registry. One known cause of this is when
1267              * Windows has had its regional settings changed so that from
1268              * GDI we get a localised (eg Chinese or Japanese) name for the
1269              * font, but the registry retains the English version of the name
1270              * that corresponded to the &quot;install&quot; locale for windows.
1271              * Since we are in this code block because there are unmapped
1272              * font names, we can look to find unused font-&gt;file mappings
1273              * and then open the files to read the names. We don&#39;t generally
1274              * want to open font files, as its a performance hit, but this
1275              * occurs only for a small number of fonts on specific system
1276              * configs - ie is believed that a &quot;true&quot; Japanese windows would
1277              * have JA names in the registry too.
1278              * Clone fontToFileMap and remove from the clone all keys which
1279              * match a fontToFamilyNameMap key. What remains maps to the
1280              * files we want to open to find the fonts GDI returned.
1281              * A font in such a file is added to the fontToFileMap after
</pre>
<hr />
<pre>
1296                 ffmapCopy.remove(key);
1297             }
1298             for (String key : ffmapCopy.keySet()) {
1299                 unmappedFontFiles.add(ffmapCopy.get(key));
1300                 fontToFileMap.remove(key);
1301             }
1302 
1303             resolveFontFiles(unmappedFontFiles, unmappedFontNames);
1304 
1305             /* If there are still unmapped font names, this means there&#39;s
1306              * something that wasn&#39;t in the registry. We need to get all
1307              * the font files directly and look at the ones that weren&#39;t
1308              * found in the registry.
1309              */
1310             if (unmappedFontNames.size() &gt; 0) {
1311 
1312                 /* getFontFilesFromPath() returns all lower case names.
1313                  * To compare we also need lower case
1314                  * versions of the names from the registry.
1315                  */
<span class="line-modified">1316                 ArrayList&lt;String&gt; registryFiles = new ArrayList&lt;String&gt;();</span>
1317 
1318                 for (String regFile : fontToFileMap.values()) {
1319                     registryFiles.add(regFile.toLowerCase());
1320                 }
1321                 /* We don&#39;t look for Type1 files here as windows will
1322                  * not enumerate these, so aren&#39;t useful in reconciling
1323                  * GDI&#39;s unmapped files. We do find these later when
1324                  * we enumerate all fonts.
1325                  */
1326                 for (String pathFile : getFontFilesFromPath(true)) {
1327                     if (!registryFiles.contains(pathFile)) {
1328                         unmappedFontFiles.add(pathFile);
1329                     }
1330                 }
1331 
1332                 resolveFontFiles(unmappedFontFiles, unmappedFontNames);
1333             }
1334 
1335             /* remove from the set of names that will be returned to the
1336              * user any fonts that can&#39;t be mapped to files.
</pre>
<hr />
<pre>
1365      * only in getAllFonts/Families, so most searches for a specific
1366      * font that is satisfied by the GDI/registry calls don&#39;t take the
1367      * additional hit of listing the directory. This hit is small enough
1368      * that its not significant in these &#39;enumerate all the fonts&#39; cases.
1369      * The basic approach is to cross-reference the files windows found
1370      * with the ones in the directory listing approach, and for each
1371      * in the latter list that is missing from the former list, register it.
1372      */
1373     private synchronized void checkForUnreferencedFontFiles() {
1374         if (haveCheckedUnreferencedFontFiles) {
1375             return;
1376         }
1377         haveCheckedUnreferencedFontFiles = true;
1378         if (!FontUtilities.isWindows) {
1379             return;
1380         }
1381         /* getFontFilesFromPath() returns all lower case names.
1382          * To compare we also need lower case
1383          * versions of the names from the registry.
1384          */
<span class="line-modified">1385         ArrayList&lt;String&gt; registryFiles = new ArrayList&lt;String&gt;();</span>
1386         for (String regFile : fontToFileMap.values()) {
1387             registryFiles.add(regFile.toLowerCase());
1388         }
1389 
1390         /* To avoid any issues with concurrent modification, create
1391          * copies of the existing maps, add the new fonts into these
1392          * and then replace the references to the old ones with the
1393          * new maps. ConcurrentHashmap is another option but its a lot
1394          * more changes and with this exception, these maps are intended
1395          * to be static.
1396          */
1397         HashMap&lt;String,String&gt; fontToFileMap2 = null;
1398         HashMap&lt;String,String&gt; fontToFamilyNameMap2 = null;
1399         HashMap&lt;String,ArrayList&lt;String&gt;&gt; familyToFontListMap2 = null;;
1400 
1401         for (String pathFile : getFontFilesFromPath(false)) {
1402             if (!registryFiles.contains(pathFile)) {
1403                 if (FontUtilities.isLogging()) {
1404                     FontUtilities.getLogger()
1405                                  .info(&quot;Found non-registry file : &quot; + pathFile);
1406                 }
1407                 PhysicalFont f = registerFontFile(getPathName(pathFile));
1408                 if (f == null) {
1409                     continue;
1410                 }
1411                 if (fontToFileMap2 == null) {
<span class="line-modified">1412                     fontToFileMap2 = new HashMap&lt;String,String&gt;(fontToFileMap);</span>
<span class="line-modified">1413                     fontToFamilyNameMap2 =</span>
<span class="line-modified">1414                         new HashMap&lt;String,String&gt;(fontToFamilyNameMap);</span>
<span class="line-removed">1415                     familyToFontListMap2 = new</span>
<span class="line-removed">1416                         HashMap&lt;String,ArrayList&lt;String&gt;&gt;(familyToFontListMap);</span>
1417                 }
1418                 String fontName = f.getFontName(null);
1419                 String family = f.getFamilyName(null);
1420                 String familyLC = family.toLowerCase();
1421                 fontToFamilyNameMap2.put(fontName, family);
1422                 fontToFileMap2.put(fontName, pathFile);
1423                 ArrayList&lt;String&gt; fonts = familyToFontListMap2.get(familyLC);
1424                 if (fonts == null) {
<span class="line-modified">1425                     fonts = new ArrayList&lt;String&gt;();</span>
1426                 } else {
<span class="line-modified">1427                     fonts = new ArrayList&lt;String&gt;(fonts);</span>
1428                 }
1429                 fonts.add(fontName);
1430                 familyToFontListMap2.put(familyLC, fonts);
1431             }
1432         }
1433         if (fontToFileMap2 != null) {
1434             fontToFileMap = fontToFileMap2;
1435             familyToFontListMap = familyToFontListMap2;
1436             fontToFamilyNameMap = fontToFamilyNameMap2;
1437         }
1438     }
1439 
1440     private void resolveFontFiles(HashSet&lt;String&gt; unmappedFiles,
1441                                   ArrayList&lt;String&gt; unmappedFonts) {
1442 
1443         Locale l = SunToolkit.getStartupLocale();
1444 
1445         for (String file : unmappedFiles) {
1446             try {
1447                 int fn = 0;
</pre>
<hr />
<pre>
1485      * then registers the whole family, returning the right font.
1486      */
1487     public static class FamilyDescription {
1488         public String familyName;
1489         public String plainFullName;
1490         public String boldFullName;
1491         public String italicFullName;
1492         public String boldItalicFullName;
1493         public String plainFileName;
1494         public String boldFileName;
1495         public String italicFileName;
1496         public String boldItalicFileName;
1497     }
1498 
1499     static HashMap&lt;String, FamilyDescription&gt; platformFontMap;
1500 
1501     /**
1502      * default implementation does nothing.
1503      */
1504     public HashMap&lt;String, FamilyDescription&gt; populateHardcodedFileNameMap() {
<span class="line-modified">1505         return new HashMap&lt;String, FamilyDescription&gt;(0);</span>
1506     }
1507 
1508     Font2D findFontFromPlatformMap(String lcName, int style) {
1509         if (platformFontMap == null) {
1510             platformFontMap = populateHardcodedFileNameMap();
1511         }
1512 
1513         if (platformFontMap == null || platformFontMap.size() == 0) {
1514             return null;
1515         }
1516 
1517         int spaceIndex = lcName.indexOf(&#39; &#39;);
1518         String firstWord = lcName;
1519         if (spaceIndex &gt; 0) {
1520             firstWord = lcName.substring(0, spaceIndex);
1521         }
1522 
1523         FamilyDescription fd = platformFontMap.get(firstWord);
1524         if (fd == null) {
1525             return null;
</pre>
<hr />
<pre>
1580         if (fd.boldItalicFileName != null) {
1581             boldItalicFile = getPathName(fd.boldItalicFileName);
1582             if (boldItalicFile == null) {
1583                 failure = true;
1584             }
1585         }
1586 
1587         if (failure) {
1588             if (FontUtilities.isLogging()) {
1589                 FontUtilities.getLogger().
1590                     info(&quot;Hardcoded file missing looking for &quot; + lcName);
1591             }
1592             platformFontMap.remove(firstWord);
1593             return null;
1594         }
1595 
1596         /* Some of these may be null,as not all styles have to exist */
1597         final String[] files = {
1598             plainFile, boldFile, italicFile, boldItalicFile } ;
1599 
<span class="line-modified">1600         failure = java.security.AccessController.doPrivileged(</span>
<span class="line-modified">1601                  new java.security.PrivilegedAction&lt;Boolean&gt;() {</span>
<span class="line-modified">1602                      public Boolean run() {</span>
<span class="line-modified">1603                          for (int i=0; i&lt;files.length; i++) {</span>
<span class="line-modified">1604                              if (files[i] == null) {</span>
<span class="line-removed">1605                                  continue;</span>
<span class="line-removed">1606                              }</span>
<span class="line-removed">1607                              File f = new File(files[i]);</span>
<span class="line-removed">1608                              if (!f.exists()) {</span>
<span class="line-removed">1609                                  return Boolean.TRUE;</span>
<span class="line-removed">1610                              }</span>
<span class="line-removed">1611                          }</span>
<span class="line-removed">1612                          return Boolean.FALSE;</span>
1613                      }
<span class="line-modified">1614                  });</span>







1615 
1616         if (failure) {
1617             if (FontUtilities.isLogging()) {
1618                 FontUtilities.getLogger().
1619                     info(&quot;Hardcoded file missing looking for &quot; + lcName);
1620             }
1621             platformFontMap.remove(firstWord);
1622             return null;
1623         }
1624 
1625         /* If we reach here we know that we have all the files we
1626          * expect, so all should be fine so long as the contents
1627          * are what we&#39;d expect. Now on to registering the fonts.
1628          * Currently this code only looks for TrueType fonts, so format
1629          * and rank can be specified without looking at the filename.
1630          */
1631         Font2D font = null;
1632         for (int f=0;f&lt;files.length;f++) {
1633             if (files[f] == null) {
1634                 continue;
</pre>
<hr />
<pre>
1660                 font = fontFamily.getFont(style);
1661                 if (font == null) {
1662                     font = fontFamily.getClosestStyle(style);
1663                 }
1664             } else if (style &gt; 0 &amp;&amp; style != font.style) {
1665                 style |= font.style;
1666                 font = fontFamily.getFont(style);
1667                 if (font == null) {
1668                     font = fontFamily.getClosestStyle(style);
1669                 }
1670             }
1671         }
1672 
1673         return font;
1674     }
1675     private synchronized HashMap&lt;String,String&gt; getFullNameToFileMap() {
1676         if (fontToFileMap == null) {
1677 
1678             pathDirs = getPlatformFontDirs(noType1Font);
1679 
<span class="line-modified">1680             fontToFileMap = new HashMap&lt;String,String&gt;(100);</span>
<span class="line-modified">1681             fontToFamilyNameMap = new HashMap&lt;String,String&gt;(100);</span>
<span class="line-modified">1682             familyToFontListMap = new HashMap&lt;String,ArrayList&lt;String&gt;&gt;(50);</span>
1683             populateFontFileNameMap(fontToFileMap,
1684                                     fontToFamilyNameMap,
1685                                     familyToFontListMap,
1686                                     Locale.ENGLISH);
1687             if (FontUtilities.isWindows) {
1688                 resolveWindowsFonts();
1689             }
1690             if (FontUtilities.isLogging()) {
1691                 logPlatformFontInfo();
1692             }
1693         }
1694         return fontToFileMap;
1695     }
1696 
1697     private void logPlatformFontInfo() {
1698         PlatformLogger logger = FontUtilities.getLogger();
1699         for (int i=0; i&lt; pathDirs.length;i++) {
1700             logger.info(&quot;fontdir=&quot;+pathDirs[i]);
1701         }
1702         for (String keyName : fontToFileMap.keySet()) {
1703             logger.info(&quot;font=&quot;+keyName+&quot; file=&quot;+ fontToFileMap.get(keyName));
1704         }
1705         for (String keyName : fontToFamilyNameMap.keySet()) {
1706             logger.info(&quot;font=&quot;+keyName+&quot; family=&quot;+
1707                         fontToFamilyNameMap.get(keyName));
1708         }
1709         for (String keyName : familyToFontListMap.keySet()) {
1710             logger.info(&quot;family=&quot;+keyName+ &quot; fonts=&quot;+
1711                         familyToFontListMap.get(keyName));
1712         }
1713     }
1714 
1715     /* Note this return list excludes logical fonts and JRE fonts */
1716     protected String[] getFontNamesFromPlatform() {
1717         if (getFullNameToFileMap().size() == 0) {
1718             return null;
1719         }
1720         checkForUnreferencedFontFiles();
1721         /* This odd code with TreeMap is used to preserve a historical
1722          * behaviour wrt the sorting order .. */
<span class="line-modified">1723         ArrayList&lt;String&gt; fontNames = new ArrayList&lt;String&gt;();</span>
1724         for (ArrayList&lt;String&gt; a : familyToFontListMap.values()) {
1725             for (String s : a) {
1726                 fontNames.add(s);
1727             }
1728         }
1729         return fontNames.toArray(STR_ARRAY);
1730     }
1731 
1732     public boolean gotFontsFromPlatform() {
1733         return getFullNameToFileMap().size() != 0;
1734     }
1735 
1736     public String getFileNameForFontName(String fontName) {
1737         String fontNameLC = fontName.toLowerCase(Locale.ENGLISH);
1738         return fontToFileMap.get(fontNameLC);
1739     }
1740 
1741     private PhysicalFont registerFontFile(String file) {
1742         if (new File(file).isAbsolute() &amp;&amp;
1743             !registeredFonts.containsKey(file)) {
</pre>
<hr />
<pre>
1782         if (getFullNameToFileMap().size() == 0) {
1783             return false;
1784         }
1785         checkForUnreferencedFontFiles();
1786         for (String name : fontToFamilyNameMap.values()) {
1787             familyNames.put(name.toLowerCase(requestedLocale), name);
1788         }
1789         return true;
1790     }
1791 
1792     /* Path may be absolute or a base file name relative to one of
1793      * the platform font directories
1794      */
1795     private String getPathName(final String s) {
1796         File f = new File(s);
1797         if (f.isAbsolute()) {
1798             return s;
1799         } else if (pathDirs.length==1) {
1800             return pathDirs[0] + File.separator + s;
1801         } else {
<span class="line-modified">1802             String path = java.security.AccessController.doPrivileged(</span>
<span class="line-modified">1803                  new java.security.PrivilegedAction&lt;String&gt;() {</span>
1804                      public String run() {
<span class="line-modified">1805                          for (int p=0; p&lt;pathDirs.length; p++) {</span>
1806                              File f = new File(pathDirs[p] +File.separator+ s);
1807                              if (f.exists()) {
1808                                  return f.getAbsolutePath();
1809                              }
1810                          }
1811                          return null;
1812                      }
1813                 });
1814             if (path != null) {
1815                 return path;
1816             }
1817         }
1818         return s; // shouldn&#39;t happen, but harmless
1819     }
1820 
1821     /* lcName is required to be lower case for use as a key.
1822      * lcName may be a full name, or a family name, and style may
1823      * be specified in addition to either of these. So be sure to
1824      * get the right one. Since an app *could* ask for &quot;Foo Regular&quot;
1825      * and later ask for &quot;Foo Italic&quot;, if we don&#39;t register all the
</pre>
<hr />
<pre>
1913             registerFontFile(getPathName(fileName), null,
1914                              FONTFORMAT_TRUETYPE, false, Font2D.TTF_RANK);
1915         }
1916 
1917         Font2D font = null;
1918         FontFamily fontFamily = FontFamily.getFamily(familyName);
1919         /* Handle case where request &quot;MyFont Bold&quot;, style=Font.ITALIC */
1920         if (physicalFont != null) {
1921             style |= physicalFont.style;
1922         }
1923         if (fontFamily != null) {
1924             font = fontFamily.getFont(style);
1925             if (font == null) {
1926                 font = fontFamily.getClosestStyle(style);
1927             }
1928         }
1929         return font;
1930     }
1931 
1932     private ConcurrentHashMap&lt;String, Font2D&gt; fontNameCache =
<span class="line-modified">1933         new ConcurrentHashMap&lt;String, Font2D&gt;();</span>
1934 
1935     /*
1936      * The client supplies a name and a style.
1937      * The name could be a family name, or a full name.
1938      * A font may exist with the specified style, or it may
1939      * exist only in some other style. For non-native fonts the scaler
1940      * may be able to emulate the required style.
1941      */
1942     public Font2D findFont2D(String name, int style, int fallback) {
1943         String lowerCaseName = name.toLowerCase(Locale.ENGLISH);
1944         String mapName = lowerCaseName + dotStyleStr(style);
1945 
1946         /* If preferLocaleFonts() or preferProportionalFonts() has been
1947          * called we may be using an alternate set of composite fonts in this
1948          * app context. The presence of a pre-built name map indicates whether
1949          * this is so, and gives access to the alternate composite for the
1950          * name.
1951          */
1952         Font2D font = fontNameCache.get(mapName);
1953         if (font != null) {
</pre>
<hr />
<pre>
2283 
2284     public int getNumFonts() {
2285         return physicalFonts.size()+maxCompFont;
2286     }
2287 
2288     private static boolean fontSupportsEncoding(Font font, String encoding) {
2289         return FontUtilities.getFont2D(font).supportsEncoding(encoding);
2290     }
2291 
2292     protected abstract String getFontPath(boolean noType1Fonts);
2293 
2294     Thread fileCloser = null;
2295     Vector&lt;File&gt; tmpFontFiles = null;
2296 
2297     private int createdFontCount = 0;
2298 
2299     public Font2D[] createFont2D(File fontFile, int fontFormat, boolean all,
2300                                  boolean isCopy, CreatedFontTracker tracker)
2301     throws FontFormatException {
2302 
<span class="line-modified">2303         List&lt;Font2D&gt; fList = new ArrayList&lt;Font2D&gt;();</span>
2304         int cnt = 1;
2305         String fontFilePath = fontFile.getPath();
2306         FileFont font2D = null;
2307         final File fFile = fontFile;
2308         final CreatedFontTracker _tracker = tracker;
2309         boolean weakRefs = false;
2310         int maxStrikes = 0;
2311         synchronized (this) {
2312             if (createdFontCount &lt; maxSoftRefCnt) {
2313                 createdFontCount++;
2314             } else {
2315                   weakRefs = true;
2316                       maxStrikes = 10;
2317             }
2318         }
2319         try {
2320             switch (fontFormat) {
2321             case Font.TRUETYPE_FONT:
2322                 font2D = new TrueTypeFont(fontFilePath, null, 0, true);
2323                 font2D.setUseWeakRefs(weakRefs, maxStrikes);
</pre>
<hr />
<pre>
2326                     break;
2327                 }
2328                 cnt = ((TrueTypeFont)font2D).getFontCount();
2329                 int index = 1;
2330                 while (index &lt; cnt) {
2331                     font2D = new TrueTypeFont(fontFilePath, null, index++, true);
2332                     font2D.setUseWeakRefs(weakRefs, maxStrikes);
2333                     fList.add(font2D);
2334                 }
2335                 break;
2336             case Font.TYPE1_FONT:
2337                 font2D = new Type1Font(fontFilePath, null, isCopy);
2338                 font2D.setUseWeakRefs(weakRefs, maxStrikes);
2339                 fList.add(font2D);
2340                 break;
2341             default:
2342                 throw new FontFormatException(&quot;Unrecognised Font Format&quot;);
2343             }
2344         } catch (FontFormatException e) {
2345             if (isCopy) {
<span class="line-modified">2346                 java.security.AccessController.doPrivileged(</span>
<span class="line-modified">2347                      new java.security.PrivilegedAction&lt;Object&gt;() {</span>
<span class="line-modified">2348                           public Object run() {</span>
<span class="line-modified">2349                               if (_tracker != null) {</span>
<span class="line-modified">2350                                   _tracker.subBytes((int)fFile.length());</span>
<span class="line-modified">2351                               }</span>
<span class="line-modified">2352                               fFile.delete();</span>
<span class="line-modified">2353                               return null;</span>
<span class="line-removed">2354                           }</span>
2355                 });
2356             }
2357             throw(e);
2358         }
2359         if (isCopy) {
2360             FileFont.setFileToRemove(fList, fontFile, cnt, tracker);
2361             synchronized (FontManager.class) {
2362 
2363                 if (tmpFontFiles == null) {
2364                     tmpFontFiles = new Vector&lt;File&gt;();
2365                 }
2366                 tmpFontFiles.add(fontFile);
2367 
2368                 if (fileCloser == null) {
2369                     final Runnable fileCloserRunnable = new Runnable() {
<span class="line-modified">2370                       public void run() {</span>
<span class="line-modified">2371                          java.security.AccessController.doPrivileged(</span>
<span class="line-modified">2372                          new java.security.PrivilegedAction&lt;Object&gt;() {</span>
<span class="line-modified">2373                          public Object run() {</span>
<span class="line-modified">2374 </span>
<span class="line-modified">2375                             for (int i=0;i&lt;CHANNELPOOLSIZE;i++) {</span>
<span class="line-modified">2376                                 if (fontFileCache[i] != null) {</span>
<span class="line-modified">2377                                     try {</span>
<span class="line-modified">2378                                         fontFileCache[i].close();</span>
<span class="line-modified">2379                                     } catch (Exception e) {</span>
2380                                     }
<span class="line-modified">2381                                 }</span>
<span class="line-modified">2382                             }</span>
<span class="line-modified">2383                             if (tmpFontFiles != null) {</span>
<span class="line-modified">2384                                 File[] files = new File[tmpFontFiles.size()];</span>
<span class="line-modified">2385                                 files = tmpFontFiles.toArray(files);</span>
<span class="line-modified">2386                                 for (int f=0; f&lt;files.length;f++) {</span>
<span class="line-modified">2387                                     try {</span>
<span class="line-modified">2388                                         files[f].delete();</span>
<span class="line-modified">2389                                     } catch (Exception e) {</span>
2390                                     }

2391                                 }
<span class="line-modified">2392                             }</span>
<span class="line-modified">2393 </span>
<span class="line-removed">2394                             return null;</span>
<span class="line-removed">2395                           }</span>
<span class="line-removed">2396 </span>
<span class="line-removed">2397                           });</span>
<span class="line-removed">2398                       }</span>
2399                     };
2400                     AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
2401                         ThreadGroup rootTG = ThreadGroupUtils.getRootThreadGroup();
2402                         fileCloser = new Thread(rootTG, fileCloserRunnable,
2403                                                 &quot;FileCloser&quot;, 0, false);
2404                         fileCloser.setContextClassLoader(null);
2405                         Runtime.getRuntime().addShutdownHook(fileCloser);
2406                         return null;
2407                     });
2408                 }
2409             }
2410         }
2411         return fList.toArray(new Font2D[0]);
2412     }
2413 
2414     /* remind: used in X11GraphicsEnvironment and called often enough
2415      * that we ought to obsolete this code
2416      */
2417     public synchronized String getFullNameByFileName(String fileName) {
2418         PhysicalFont[] physFonts = getPhysicalFonts();
</pre>
<hr />
<pre>
2538              * we can live with the glitch that depending on how it was
2539              * initialised a composite may return different values for this.
2540              * Fixing the issues with composite glyph ids is tricky as
2541              * there are exclusion ranges and unlike other fonts even the
2542              * true &quot;numGlyphs&quot; isn&#39;t a contiguous range. Likely the only
2543              * solution is an API that returns an array of glyph ranges
2544              * which takes precedence over the existing API. That might
2545              * also need to address excluding ranges which represent a
2546              * code point supported by an earlier component.
2547              */
2548             if (newFont.getRank() &gt; Font2D.FONT_CONFIG_RANK) {
2549                 compFonts[i].replaceComponentFont(oldFont, newFont);
2550             }
2551         }
2552     }
2553 
2554     private synchronized void loadLocaleNames() {
2555         if (localeFullNamesToFont != null) {
2556             return;
2557         }
<span class="line-modified">2558         localeFullNamesToFont = new HashMap&lt;String, TrueTypeFont&gt;();</span>
2559         Font2D[] fonts = getRegisteredFonts();
2560         for (int i=0; i&lt;fonts.length; i++) {
2561             if (fonts[i] instanceof TrueTypeFont) {
2562                 TrueTypeFont ttf = (TrueTypeFont)fonts[i];
2563                 String[] fullNames = ttf.getAllFullNames();
2564                 for (int n=0; n&lt;fullNames.length; n++) {
2565                     localeFullNamesToFont.put(fullNames[n], ttf);
2566                 }
2567                 FontFamily family = FontFamily.getFamily(ttf.familyName);
2568                 if (family != null) {
2569                     FontFamily.addLocaleNames(family, ttf.getAllFamilyNames());
2570                 }
2571             }
2572         }
2573     }
2574 
2575     /* This replicate the core logic of findFont2D but operates on
2576      * all the locale names. This hasn&#39;t been merged into findFont2D to
2577      * keep the logic simpler and reduce overhead, since this case is
2578      * almost never used. The main case in which it is called is when
</pre>
<hr />
<pre>
2758          */
2759         if (!FontConfiguration.hasMonoToPropMap()) {
2760             return;
2761         }
2762         if (gPropPref == true) {
2763             return;
2764         }
2765         gPropPref = true;
2766         createCompositeFonts(fontNameCache, gLocalePref, gPropPref);
2767         _usingAlternateComposites = true;
2768     }
2769 
2770     private static HashSet&lt;String&gt; installedNames = null;
2771     private static HashSet&lt;String&gt; getInstalledNames() {
2772         if (installedNames == null) {
2773            Locale l = getSystemStartupLocale();
2774            SunFontManager fontManager = SunFontManager.getInstance();
2775            String[] installedFamilies =
2776                fontManager.getInstalledFontFamilyNames(l);
2777            Font[] installedFonts = fontManager.getAllInstalledFonts();
<span class="line-modified">2778            HashSet&lt;String&gt; names = new HashSet&lt;String&gt;();</span>
2779            for (int i=0; i&lt;installedFamilies.length; i++) {
2780                names.add(installedFamilies[i].toLowerCase(l));
2781            }
2782            for (int i=0; i&lt;installedFonts.length; i++) {
2783                names.add(installedFonts[i].getFontName(l).toLowerCase(l));
2784            }
2785            installedNames = names;
2786         }
2787         return installedNames;
2788     }
2789 
2790     private static final Object regFamilyLock  = new Object();
2791     private Hashtable&lt;String,FontFamily&gt; createdByFamilyName;
2792     private Hashtable&lt;String,Font2D&gt;     createdByFullName;
2793     private boolean fontsAreRegistered = false;
2794 
2795     public boolean registerFont(Font font) {
2796         /* This method should not be called with &quot;null&quot;.
2797          * It is the caller&#39;s responsibility to ensure that.
2798          */
</pre>
<hr />
<pre>
2920             Font[] fonts = new Font[nameTable.size()];
2921             int i=0;
2922             for (Font2D font2D : nameTable.values()) {
2923                 fonts[i++] = new Font(font2D.getFontName(l), Font.PLAIN, 1);
2924             }
2925             return fonts;
2926         }
2927     }
2928 
2929 
2930     protected String[] getPlatformFontDirs(boolean noType1Fonts) {
2931 
2932         /* First check if we already initialised path dirs */
2933         if (pathDirs != null) {
2934             return pathDirs;
2935         }
2936 
2937         String path = getPlatformFontPath(noType1Fonts);
2938         StringTokenizer parser =
2939             new StringTokenizer(path, File.pathSeparator);
<span class="line-modified">2940         ArrayList&lt;String&gt; pathList = new ArrayList&lt;String&gt;();</span>
2941         try {
2942             while (parser.hasMoreTokens()) {
2943                 pathList.add(parser.nextToken());
2944             }
2945         } catch (NoSuchElementException e) {
2946         }
2947         pathDirs = pathList.toArray(new String[0]);
2948         return pathDirs;
2949     }
2950 
2951     /**
2952      * Returns an array of two strings. The first element is the
2953      * name of the font. The second element is the file name.
2954      */
2955     protected abstract String[] getDefaultPlatformFont();
2956 
2957     // Begin: Refactored from SunGraphicsEnviroment.
2958 
2959     /*
2960      * helper function for registerFonts
</pre>
<hr />
<pre>
3050     public String getPlatformFontPath(boolean noType1Font) {
3051         if (fontPath == null) {
3052             fontPath = getFontPath(noType1Font);
3053         }
3054         return fontPath;
3055     }
3056 
3057     protected void loadFonts() {
3058         if (discoveredAllFonts) {
3059             return;
3060         }
3061         /* Use lock specific to the font system */
3062         synchronized (this) {
3063             if (FontUtilities.debugFonts()) {
3064                 Thread.dumpStack();
3065                 FontUtilities.getLogger()
3066                             .info(&quot;SunGraphicsEnvironment.loadFonts() called&quot;);
3067             }
3068             initialiseDeferredFonts();
3069 
<span class="line-modified">3070             java.security.AccessController.doPrivileged(</span>
<span class="line-modified">3071                                     new java.security.PrivilegedAction&lt;Object&gt;() {</span>
<span class="line-removed">3072                 public Object run() {</span>
3073                     if (fontPath == null) {
3074                         fontPath = getPlatformFontPath(noType1Font);
3075                         registerFontDirs(fontPath);
3076                     }
3077                     if (fontPath != null) {
3078                         // this will find all fonts including those already
3079                         // registered. But we have checks in place to prevent
3080                         // double registration.
3081                         if (! gotFontsFromPlatform()) {
3082                             registerFontsOnPath(fontPath, false,
3083                                                 Font2D.UNKNOWN_RANK,
3084                                                 false, true);
3085                             loadedAllFontFiles = true;
3086                         }
3087                     }
3088                     registerOtherFontFiles(registeredFontFiles);
3089                     discoveredAllFonts = true;
3090                     return null;
3091                 }
3092             });
</pre>
<hr />
<pre>
3167     /**
3168      * Returns face name for default font, or null if
3169      * no face names are used for CompositeFontDescriptors
3170      * for this platform.
3171      */
3172     public synchronized String getDefaultFontFaceName() {
3173         return defaultFontName;
3174     }
3175 
3176     public void loadFontFiles() {
3177         loadFonts();
3178         if (loadedAllFontFiles) {
3179             return;
3180         }
3181         /* Use lock specific to the font system */
3182         synchronized (this) {
3183             if (FontUtilities.debugFonts()) {
3184                 Thread.dumpStack();
3185                 FontUtilities.getLogger().info(&quot;loadAllFontFiles() called&quot;);
3186             }
<span class="line-modified">3187             java.security.AccessController.doPrivileged(</span>
<span class="line-modified">3188                                     new java.security.PrivilegedAction&lt;Object&gt;() {</span>
<span class="line-removed">3189                 public Object run() {</span>
3190                     if (fontPath == null) {
3191                         fontPath = getPlatformFontPath(noType1Font);
3192                     }
3193                     if (fontPath != null) {
3194                         // this will find all fonts including those already
3195                         // registered. But we have checks in place to prevent
3196                         // double registration.
3197                         registerFontsOnPath(fontPath, false,
3198                                             Font2D.UNKNOWN_RANK,
3199                                             false, true);
3200                     }
3201                     loadedAllFontFiles = true;
3202                     return null;
3203                 }
3204             });
3205         }
3206     }
3207 
3208     /*
3209      * This method asks the font configuration API for all platform names
</pre>
<hr />
<pre>
3358 
3359     protected void registerPlatformFontsUsedByFontConfiguration() {
3360     }
3361 
3362     /*
3363      * A GE may verify whether a font file used in a fontconfiguration
3364      * exists. If it doesn&#39;t then either we may substitute the default
3365      * font, or perhaps elide it altogether from the composite font.
3366      * This makes some sense on windows where the font file is only
3367      * likely to be in one place. But on other OSes, eg Linux, the file
3368      * can move around depending. So there we probably don&#39;t want to assume
3369      * its missing and so won&#39;t add it to this list.
3370      * If this list - missingFontFiles - is non-null then the composite
3371      * font initialisation logic tests to see if a font file is in that
3372      * set.
3373      * Only one thread should be able to add to this set so we don&#39;t
3374      * synchronize.
3375      */
3376     protected void addToMissingFontFileList(String fileName) {
3377         if (missingFontFiles == null) {
<span class="line-modified">3378             missingFontFiles = new HashSet&lt;String&gt;();</span>
3379         }
3380         missingFontFiles.add(fileName);
3381     }
3382 
3383     /*
3384      * This is for use only within getAllFonts().
3385      * Fonts listed in the fontconfig files for windows were all
3386      * on the &quot;deferred&quot; initialisation list. They were registered
3387      * either in the course of the application, or in the call to
3388      * loadFonts() within getAllFonts(). The fontconfig file specifies
3389      * the names of the fonts using the English names. If there&#39;s a
3390      * different name in the execution locale, then the platform will
3391      * report that, and we will construct the font with both names, and
3392      * thereby enumerate it twice. This happens for Japanese fonts listed
3393      * in the windows fontconfig, when run in the JA locale. The solution
3394      * is to rely (in this case) on the platform&#39;s font-&gt;file mapping to
3395      * determine that this name corresponds to a file we already registered.
3396      * This works because
3397      * - we know when we get here all deferred fonts are already initialised
3398      * - when we register a font file, we register all fonts in it.
</pre>
<hr />
<pre>
3525         // Add any native font family names here
3526         addNativeFontFamilyNames(familyNames, requestedLocale);
3527 
3528         String[] retval =  new String[familyNames.size()];
3529         Object [] keyNames = familyNames.keySet().toArray();
3530         for (int i=0; i &lt; keyNames.length; i++) {
3531             retval[i] = familyNames.get(keyNames[i]);
3532         }
3533         if (requestedLocale.equals(Locale.getDefault())) {
3534             lastDefaultLocale = requestedLocale;
3535             allFamilies = new String[retval.length];
3536             System.arraycopy(retval, 0, allFamilies, 0, allFamilies.length);
3537         }
3538         return retval;
3539     }
3540 
3541     // Provides an aperture to add native font family names to the map
3542     protected void addNativeFontFamilyNames(TreeMap&lt;String, String&gt; familyNames, Locale requestedLocale) { }
3543 
3544     public void register1dot0Fonts() {
<span class="line-modified">3545         java.security.AccessController.doPrivileged(</span>
<span class="line-modified">3546                             new java.security.PrivilegedAction&lt;Object&gt;() {</span>
<span class="line-removed">3547             public Object run() {</span>
3548                 String type1Dir = &quot;/usr/openwin/lib/X11/fonts/Type1&quot;;
3549                 registerFontsInDir(type1Dir, true, Font2D.TYPE1_RANK,
3550                                    false, false);
3551                 return null;
3552             }
3553         });
3554     }
3555 
3556     /* Really we need only the JRE fonts family names, but there&#39;s little
3557      * overhead in doing this the easy way by adding all the currently
3558      * known fonts.
3559      */
3560     protected void getJREFontFamilyNames(TreeMap&lt;String,String&gt; familyNames,
3561                                          Locale requestedLocale) {
3562         registerDeferredJREFonts(jreFontDirName);
3563         Font2D[] physicalfonts = getPhysicalFonts();
3564         for (int i=0; i &lt; physicalfonts.length; i++) {
3565             if (!(physicalfonts[i] instanceof NativeFont)) {
3566                 String name =
3567                     physicalfonts[i].getFamilyName(requestedLocale);
3568                 familyNames.put(name.toLowerCase(requestedLocale), name);
3569             }
3570         }
3571     }
3572 
3573     /**
3574      * Default locale can be changed but we need to know the initial locale
3575      * as that is what is used by native code. Changing Java default locale
3576      * doesn&#39;t affect that.
3577      * Returns the locale in use when using native code to communicate
3578      * with platform APIs. On windows this is known as the &quot;system&quot; locale,
3579      * and it is usually the same as the platform locale, but not always,
3580      * so this method also checks an implementation property used only
3581      * on windows and uses that if set.
3582      */
3583     private static Locale systemLocale = null;
3584     private static Locale getSystemStartupLocale() {
3585         if (systemLocale == null) {
<span class="line-modified">3586             systemLocale = (Locale)</span>
<span class="line-modified">3587                 java.security.AccessController.doPrivileged(</span>
<span class="line-modified">3588                                     new java.security.PrivilegedAction&lt;Object&gt;() {</span>
<span class="line-modified">3589             public Object run() {</span>
<span class="line-modified">3590                 /* On windows the system locale may be different than the</span>
<span class="line-modified">3591                  * user locale. This is an unsupported configuration, but</span>
<span class="line-modified">3592                  * in that case we want to return a dummy locale that will</span>
<span class="line-modified">3593                  * never cause a match in the usage of this API. This is</span>
<span class="line-modified">3594                  * important because Windows documents that the family</span>
<span class="line-modified">3595                  * names of fonts are enumerated using the language of</span>
<span class="line-modified">3596                  * the system locale. BY returning a dummy locale in that</span>
<span class="line-modified">3597                  * case we do not use the platform API which would not</span>
<span class="line-modified">3598                  * return us the names we want.</span>
<span class="line-modified">3599                  */</span>
<span class="line-modified">3600                 String fileEncoding = System.getProperty(&quot;file.encoding&quot;, &quot;&quot;);</span>
<span class="line-modified">3601                 String sysEncoding = System.getProperty(&quot;sun.jnu.encoding&quot;);</span>
<span class="line-modified">3602                 if (sysEncoding != null &amp;&amp; !sysEncoding.equals(fileEncoding)) {</span>
<span class="line-removed">3603                     return Locale.ROOT;</span>
<span class="line-removed">3604                 }</span>
3605 
<span class="line-modified">3606                 String language = System.getProperty(&quot;user.language&quot;, &quot;en&quot;);</span>
<span class="line-modified">3607                 String country  = System.getProperty(&quot;user.country&quot;,&quot;&quot;);</span>
<span class="line-modified">3608                 String variant  = System.getProperty(&quot;user.variant&quot;,&quot;&quot;);</span>
<span class="line-modified">3609                 return new Locale(language, country, variant);</span>
<span class="line-modified">3610             }</span>
<span class="line-modified">3611         });</span>
3612         }
3613         return systemLocale;
3614     }
3615 
3616     void addToPool(FileFont font) {
3617 
3618         FileFont fontFileToClose = null;
3619         int freeSlot = -1;
3620 
3621         synchronized (fontFileCache) {
3622             /* Avoid duplicate entries in the pool, and don&#39;t close() it,
3623              * since this method is called only from within open().
3624              * Seeing a duplicate is most likely to happen if the thread
3625              * was interrupted during a read, forcing perhaps repeated
3626              * close and open calls and it eventually it ends up pointing
3627              * at the same slot.
3628              */
3629             for (int i=0;i&lt;CHANNELPOOLSIZE;i++) {
3630                 if (fontFileCache[i] == font) {
3631                     return;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.font;
  27 
  28 import java.awt.Font;
  29 import java.awt.FontFormatException;
  30 import java.io.BufferedReader;
  31 import java.io.File;
  32 import java.io.FileInputStream;
  33 import java.io.FilenameFilter;
  34 import java.io.IOException;
  35 import java.io.InputStreamReader;
  36 import java.security.AccessController;
  37 import java.security.PrivilegedAction;
  38 import java.util.ArrayList;
  39 import java.util.HashMap;
  40 import java.util.HashSet;
  41 import java.util.Hashtable;

  42 import java.util.List;
  43 import java.util.Locale;
  44 import java.util.Map;
  45 import java.util.NoSuchElementException;
  46 import java.util.StringTokenizer;
  47 import java.util.TreeMap;
  48 import java.util.Vector;
  49 import java.util.concurrent.ConcurrentHashMap;
  50 
  51 import javax.swing.plaf.FontUIResource;
  52 
  53 import sun.awt.FontConfiguration;
  54 import sun.awt.SunToolkit;
  55 import sun.awt.util.ThreadGroupUtils;
  56 import sun.java2d.FontSupport;
  57 import sun.util.logging.PlatformLogger;
  58 
  59 /**
  60  * The base implementation of the {@link FontManager} interface. It implements
  61  * the platform independent, shared parts of OpenJDK&#39;s FontManager
</pre>
<hr />
<pre>
 113                     name.startsWith(&quot;.ttc&quot;, offset) ||
 114                     name.startsWith(&quot;.TTC&quot;, offset) ||
 115                     name.startsWith(&quot;.otf&quot;, offset) ||
 116                     name.startsWith(&quot;.OTF&quot;, offset);
 117                 if (isTT) {
 118                     return true;
 119                 } else if (noType1Font) {
 120                     return false;
 121                 } else {
 122                     return(name.startsWith(&quot;.pfa&quot;, offset) ||
 123                            name.startsWith(&quot;.pfb&quot;, offset) ||
 124                            name.startsWith(&quot;.PFA&quot;, offset) ||
 125                            name.startsWith(&quot;.PFB&quot;, offset));
 126                 }
 127             }
 128         }
 129     }
 130 
 131     private static Font2DHandle FONT_HANDLE_NULL = new Font2DHandle(null);
 132 
<span class="line-modified"> 133     public static final int FONTFORMAT_NONE = -1;</span>
<span class="line-modified"> 134     public static final int FONTFORMAT_TRUETYPE = 0;</span>
<span class="line-modified"> 135     public static final int FONTFORMAT_TYPE1 = 1;</span>
<span class="line-modified"> 136     public static final int FONTFORMAT_TTC = 2;</span>
<span class="line-modified"> 137     public static final int FONTFORMAT_COMPOSITE = 3;</span>
<span class="line-modified"> 138     public static final int FONTFORMAT_NATIVE = 4;</span>
<span class="line-modified"> 139 </span>
<span class="line-modified"> 140     /* Pool of 20 font file channels chosen because some UTF-8 locale</span>
<span class="line-modified"> 141      * composite fonts can use up to 16 platform fonts (including the</span>
<span class="line-modified"> 142      * Lucida fall back). This should prevent channel thrashing when</span>
<span class="line-modified"> 143      * dealing with one of these fonts.</span>
<span class="line-modified"> 144      * The pool array stores the fonts, rather than directly referencing</span>
<span class="line-modified"> 145      * the channels, as the font needs to do the open/close work.</span>
<span class="line-modified"> 146      */</span>
<span class="line-modified"> 147     // MACOSX begin -- need to access these in subclass</span>
<span class="line-modified"> 148     protected static final int CHANNELPOOLSIZE = 20;</span>
<span class="line-modified"> 149     protected FileFont[] fontFileCache = new FileFont[CHANNELPOOLSIZE];</span>
<span class="line-modified"> 150     // MACOSX end</span>
<span class="line-modified"> 151     private int lastPoolIndex = 0;</span>
 152 
 153     /* Need to implement a simple linked list scheme for fast
 154      * traversal and lookup.
 155      * Also want to &quot;fast path&quot; dialog so there&#39;s minimal overhead.
 156      */
 157     /* There are at exactly 20 composite fonts: 5 faces (but some are not
 158      * usually different), in 4 styles. The array may be auto-expanded
 159      * later if more are needed, eg for user-defined composites or locale
 160      * variants.
 161      */
 162     private int maxCompFont = 0;
 163     private CompositeFont [] compFonts = new CompositeFont[20];
 164     private ConcurrentHashMap&lt;String, CompositeFont&gt;
<span class="line-modified"> 165         compositeFonts = new ConcurrentHashMap&lt;&gt;();</span>
 166     private ConcurrentHashMap&lt;String, PhysicalFont&gt;
<span class="line-modified"> 167         physicalFonts = new ConcurrentHashMap&lt;&gt;();</span>
 168     private ConcurrentHashMap&lt;String, PhysicalFont&gt;
<span class="line-modified"> 169         registeredFonts = new ConcurrentHashMap&lt;&gt;();</span>
 170 
 171     /* given a full name find the Font. Remind: there&#39;s duplication
 172      * here in that this contains the content of compositeFonts +
 173      * physicalFonts.
 174      */
 175     // MACOSX begin -- need to access this in subclass
 176     protected ConcurrentHashMap&lt;String, Font2D&gt;
<span class="line-modified"> 177         fullNameToFont = new ConcurrentHashMap&lt;&gt;();</span>
 178     // MACOSX end
 179 
 180     /* TrueType fonts have localised names. Support searching all
 181      * of these before giving up on a name.
 182      */
 183     private HashMap&lt;String, TrueTypeFont&gt; localeFullNamesToFont;
 184 
 185     private PhysicalFont defaultPhysicalFont;
 186 
 187     static boolean longAddresses;
 188     private boolean loaded1dot0Fonts = false;
 189     boolean loadedAllFonts = false;
 190     boolean loadedAllFontFiles = false;
 191     String[] jreOtherFontFiles;
 192     boolean noOtherJREFontFiles = false; // initial assumption.
 193 
 194     public static String jreLibDirName;
 195     public static String jreFontDirName;
 196     private static HashSet&lt;String&gt; missingFontFiles = null;
 197     private String defaultFontName;
</pre>
<hr />
<pre>
 248         FontManager fm = FontManagerFactory.getInstance();
 249         return (SunFontManager) fm;
 250     }
 251 
 252     public FilenameFilter getTrueTypeFilter() {
 253         return ttFilter;
 254     }
 255 
 256     public FilenameFilter getType1Filter() {
 257         return t1Filter;
 258     }
 259 
 260     /* After we reach MAXSOFTREFCNT, use weak refs for created fonts.
 261      * This means that a small number of created fonts as used in a UI app
 262      * will not be eagerly collected, but an app that create many will
 263      * have them collected more frequently to reclaim storage.
 264      */
 265     private static int maxSoftRefCnt = 10;
 266 
 267     static {
<span class="line-added"> 268         AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
<span class="line-added"> 269             public Void run() {</span>
<span class="line-added"> 270                 FontManagerNativeLibrary.load();</span>
<span class="line-added"> 271 </span>
<span class="line-added"> 272                 // JNI throws an exception if a class/method/field is not found,</span>
<span class="line-added"> 273                 // so there&#39;s no need to do anything explicit here.</span>
<span class="line-added"> 274                 initIDs();</span>
<span class="line-added"> 275 </span>
<span class="line-added"> 276                 switch (StrikeCache.nativeAddressSize) {</span>
<span class="line-added"> 277                 case 8: longAddresses = true; break;</span>
<span class="line-added"> 278                 case 4: longAddresses = false; break;</span>
<span class="line-added"> 279                 default: throw new RuntimeException(&quot;Unexpected address size&quot;);</span>
<span class="line-added"> 280                 }</span>
 281 
<span class="line-modified"> 282                 noType1Font = &quot;true&quot;.equals(System.getProperty(&quot;sun.java2d.noType1Font&quot;));</span>
<span class="line-modified"> 283                 jreLibDirName = System.getProperty(&quot;java.home&quot;,&quot;&quot;) + File.separator + &quot;lib&quot;;</span>
<span class="line-modified"> 284                 jreFontDirName = jreLibDirName + File.separator + &quot;fonts&quot;;</span>





















 285 
<span class="line-modified"> 286                 maxSoftRefCnt = Integer.getInteger(&quot;sun.java2d.font.maxSoftRefs&quot;, 10);</span>
<span class="line-modified"> 287                 return null;</span>
<span class="line-added"> 288             }</span>
 289         });
 290     }
 291 
 292     /**
 293      * If the module image layout changes the location of JDK fonts,
 294      * this will be updated to reflect that.
 295      */
 296     public static final String getJDKFontDir() {
 297         return jreFontDirName;
 298     }
 299 
 300     public TrueTypeFont getEUDCFont() {
 301         // Overridden in Windows.
 302         return null;
 303     }
 304 
 305     /* Initialise ptrs used by JNI methods */
 306     private static native void initIDs();
 307 

 308     protected SunFontManager() {
<span class="line-modified"> 309         AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
<span class="line-modified"> 310             public Void run() {</span>
<span class="line-modified"> 311                 File badFontFile =</span>
<span class="line-modified"> 312                     new File(jreFontDirName + File.separator + &quot;badfonts.txt&quot;);</span>
<span class="line-modified"> 313                 if (badFontFile.exists()) {</span>
<span class="line-modified"> 314                     badFonts = new ArrayList&lt;&gt;();</span>
<span class="line-modified"> 315                     try (FileInputStream fis = new FileInputStream(badFontFile);</span>
<span class="line-modified"> 316                          BufferedReader br = new BufferedReader(new InputStreamReader(fis))) {</span>
<span class="line-modified"> 317                         while (true) {</span>
<span class="line-modified"> 318                             String name = br.readLine();</span>
<span class="line-modified"> 319                             if (name == null) {</span>
<span class="line-modified"> 320                                 break;</span>
<span class="line-modified"> 321                             } else {</span>
<span class="line-modified"> 322                                 if (FontUtilities.debugFonts()) {</span>
<span class="line-modified"> 323                                     FontUtilities.getLogger().warning(&quot;read bad font: &quot; + name);</span>

















 324                                 }
<span class="line-added"> 325                                 badFonts.add(name);</span>
 326                             }
 327                         }
<span class="line-added"> 328                     } catch (IOException e) {</span>
<span class="line-added"> 329                     }</span>
<span class="line-added"> 330                 }</span>
 331 
<span class="line-modified"> 332                 /* Here we get the fonts in jre/lib/fonts and register</span>
<span class="line-modified"> 333                  * them so they are always available and preferred over</span>
<span class="line-modified"> 334                  * other fonts. This needs to be registered before the</span>
<span class="line-modified"> 335                  * composite fonts as otherwise some native font that</span>
<span class="line-modified"> 336                  * corresponds may be found as we don&#39;t have a way to</span>
<span class="line-modified"> 337                  * handle two fonts of the same name, so the JRE one</span>
<span class="line-modified"> 338                  * must be the first one registered. Pass &quot;true&quot; to</span>
<span class="line-modified"> 339                  * registerFonts method as on-screen these JRE fonts</span>
<span class="line-modified"> 340                  * always go through the JDK rasteriser.</span>
<span class="line-modified"> 341                  */</span>
<span class="line-modified"> 342                 if (FontUtilities.isLinux) {</span>
<span class="line-modified"> 343                     /* Linux font configuration uses these fonts */</span>
<span class="line-modified"> 344                     registerFontDir(jreFontDirName);</span>
<span class="line-modified"> 345                 }</span>
<span class="line-modified"> 346                 registerFontsInDir(jreFontDirName, true, Font2D.JRE_RANK,</span>
<span class="line-modified"> 347                                    true, false);</span>
 348 
<span class="line-modified"> 349                 /* Create the font configuration and get any font path</span>
<span class="line-modified"> 350                  * that might be specified.</span>
<span class="line-modified"> 351                  */</span>
<span class="line-modified"> 352                 fontConfig = createFontConfiguration();</span>
<span class="line-modified"> 353 </span>
<span class="line-modified"> 354                 String[] fontInfo = getDefaultPlatformFont();</span>
<span class="line-modified"> 355                 defaultFontName = fontInfo[0];</span>
<span class="line-modified"> 356                 defaultFontFileName = fontInfo[1];</span>
<span class="line-modified"> 357 </span>
<span class="line-modified"> 358                 String extraFontPath = fontConfig.getExtraFontPath();</span>
<span class="line-modified"> 359 </span>
<span class="line-modified"> 360                 /* In prior releases the debugging font path replaced</span>
<span class="line-modified"> 361                  * all normally located font directories except for the</span>
<span class="line-modified"> 362                  * JRE fonts dir. This directory is still always located</span>
<span class="line-modified"> 363                  * and placed at the head of the path but as an</span>
<span class="line-modified"> 364                  * augmentation to the previous behaviour the</span>
<span class="line-modified"> 365                  * changes below allow you to additionally append to</span>
<span class="line-modified"> 366                  * the font path by starting with append: or prepend by</span>
<span class="line-modified"> 367                  * starting with a prepend: sign. Eg: to append</span>
<span class="line-modified"> 368                  * -Dsun.java2d.fontpath=append:/usr/local/myfonts</span>
<span class="line-modified"> 369                  * and to prepend</span>
<span class="line-modified"> 370                  * -Dsun.java2d.fontpath=prepend:/usr/local/myfonts Disp</span>
<span class="line-modified"> 371                  *</span>
<span class="line-modified"> 372                  * If there is an appendedfontpath it in the font</span>
<span class="line-modified"> 373                  * configuration it is used instead of searching the</span>
<span class="line-modified"> 374                  * system for dirs.</span>
<span class="line-modified"> 375                  * The behaviour of append and prepend is then similar</span>
<span class="line-modified"> 376                  * to the normal case. ie it goes after what</span>
<span class="line-modified"> 377                  * you prepend and * before what you append. If the</span>
<span class="line-modified"> 378                  * sun.java2d.fontpath property is used, but it</span>
<span class="line-modified"> 379                  * neither the append or prepend syntaxes is used then</span>
<span class="line-modified"> 380                  * as except for the JRE dir the path is replaced and it</span>
<span class="line-modified"> 381                  * is up to you to make sure that all the right</span>
<span class="line-modified"> 382                  * directories are located. This is platform and</span>
<span class="line-modified"> 383                  * locale-specific so its almost impossible to get</span>
<span class="line-modified"> 384                  * right, so it should be used with caution.</span>
<span class="line-modified"> 385                  */</span>
<span class="line-modified"> 386                 boolean prependToPath = false;</span>
<span class="line-modified"> 387                 boolean appendToPath = false;</span>
<span class="line-modified"> 388                 String dbgFontPath = System.getProperty(&quot;sun.java2d.fontpath&quot;);</span>
<span class="line-modified"> 389 </span>
<span class="line-modified"> 390                 if (dbgFontPath != null) {</span>
<span class="line-modified"> 391                     if (dbgFontPath.startsWith(&quot;prepend:&quot;)) {</span>
<span class="line-modified"> 392                         prependToPath = true;</span>
<span class="line-modified"> 393                         dbgFontPath =</span>
<span class="line-modified"> 394                             dbgFontPath.substring(&quot;prepend:&quot;.length());</span>
<span class="line-modified"> 395                     } else if (dbgFontPath.startsWith(&quot;append:&quot;)) {</span>
<span class="line-modified"> 396                         appendToPath = true;</span>
<span class="line-modified"> 397                         dbgFontPath =</span>
<span class="line-modified"> 398                             dbgFontPath.substring(&quot;append:&quot;.length());</span>
<span class="line-modified"> 399                     }</span>
<span class="line-modified"> 400                 }</span>

 401 
<span class="line-modified"> 402                 if (FontUtilities.debugFonts()) {</span>
<span class="line-modified"> 403                     PlatformLogger logger = FontUtilities.getLogger();</span>
<span class="line-modified"> 404                     logger.info(&quot;JRE font directory: &quot; + jreFontDirName);</span>
<span class="line-modified"> 405                     logger.info(&quot;Extra font path: &quot; + extraFontPath);</span>
<span class="line-modified"> 406                     logger.info(&quot;Debug font path: &quot; + dbgFontPath);</span>
<span class="line-modified"> 407                 }</span>
 408 
<span class="line-modified"> 409                 if (dbgFontPath != null) {</span>
<span class="line-modified"> 410                     /* In debugging mode we register all the paths</span>
<span class="line-modified"> 411                      * Caution: this is a very expensive call on Solaris:-</span>
<span class="line-modified"> 412                      */</span>
<span class="line-modified"> 413                     fontPath = getPlatformFontPath(noType1Font);</span>
 414 
<span class="line-modified"> 415                     if (extraFontPath != null) {</span>
<span class="line-modified"> 416                         fontPath = extraFontPath + File.pathSeparator + fontPath;</span>
<span class="line-modified"> 417                     }</span>
<span class="line-modified"> 418                     if (appendToPath) {</span>
<span class="line-modified"> 419                         fontPath += File.pathSeparator + dbgFontPath;</span>
<span class="line-modified"> 420                     } else if (prependToPath) {</span>
<span class="line-modified"> 421                         fontPath = dbgFontPath + File.pathSeparator + fontPath;</span>
<span class="line-modified"> 422                     } else {</span>
<span class="line-modified"> 423                         fontPath = dbgFontPath;</span>
<span class="line-modified"> 424                     }</span>
<span class="line-modified"> 425                     registerFontDirs(fontPath);</span>
<span class="line-modified"> 426                 } else if (extraFontPath != null) {</span>
<span class="line-modified"> 427                     /* If the font configuration contains an</span>
<span class="line-modified"> 428                      * &quot;appendedfontpath&quot; entry, it is interpreted as a</span>
<span class="line-modified"> 429                      * set of locations that should always be registered.</span>
<span class="line-modified"> 430                      * It may be additional to locations normally found</span>
<span class="line-modified"> 431                      * for that place, or it may be locations that need</span>
<span class="line-modified"> 432                      * to have all their paths registered to locate all</span>
<span class="line-modified"> 433                      * the needed platform names.</span>
<span class="line-modified"> 434                      * This is typically when the same .TTF file is</span>
<span class="line-modified"> 435                      * referenced from multiple font.dir files and all</span>
<span class="line-modified"> 436                      * of these must be read to find all the native</span>
<span class="line-modified"> 437                      * (XLFD) names for the font, so that X11 font APIs</span>
<span class="line-modified"> 438                      * can be used for as many code points as possible.</span>
<span class="line-modified"> 439                      */</span>
<span class="line-modified"> 440                     registerFontDirs(extraFontPath);</span>
<span class="line-modified"> 441                 }</span>



 442 
<span class="line-modified"> 443                 /* On Solaris, we need to register the Japanese TrueType</span>
<span class="line-modified"> 444                  * directory so that we can find the corresponding</span>
<span class="line-modified"> 445                  * bitmap fonts. This could be done by listing the</span>
<span class="line-modified"> 446                  * directory in the font configuration file, but we</span>
<span class="line-modified"> 447                  * don&#39;t want to confuse users with this quirk. There</span>
<span class="line-modified"> 448                  * are no bitmap fonts for other writing systems that</span>
<span class="line-modified"> 449                  * correspond to TrueType fonts and have matching XLFDs.</span>
<span class="line-modified"> 450                  * We need to register the bitmap fonts only in</span>
<span class="line-modified"> 451                  * environments where they&#39;re on the X font path, i.e.,</span>
<span class="line-modified"> 452                  * in the Japanese locale. Note that if the X Toolkit</span>
<span class="line-modified"> 453                  * is in use the font path isn&#39;t set up by JDK, but</span>
<span class="line-modified"> 454                  * users of a JA locale should have it</span>
<span class="line-modified"> 455                  * set up already by their login environment.</span>
<span class="line-modified"> 456                  */</span>
<span class="line-modified"> 457                 if (FontUtilities.isSolaris &amp;&amp; Locale.JAPAN.equals(Locale.getDefault())) {</span>
<span class="line-modified"> 458                     registerFontDir(&quot;/usr/openwin/lib/locale/ja/X11/fonts/TT&quot;);</span>
<span class="line-modified"> 459                 }</span>
 460 
<span class="line-modified"> 461                 initCompositeFonts(fontConfig, null);</span>
 462 
<span class="line-modified"> 463                 return null;</span>
<span class="line-modified"> 464             }</span>
<span class="line-modified"> 465         });</span>
 466 
 467         boolean platformFont = AccessController.doPrivileged(
<span class="line-modified"> 468             new PrivilegedAction&lt;Boolean&gt;() {</span>
<span class="line-modified"> 469                     public Boolean run() {</span>
<span class="line-modified"> 470                         String prop = System.getProperty(&quot;java2d.font.usePlatformFont&quot;);</span>
<span class="line-modified"> 471                         String env = System.getenv(&quot;JAVA2D_USEPLATFORMFONT&quot;);</span>
<span class="line-modified"> 472                         return &quot;true&quot;.equals(prop) || env != null;</span>
<span class="line-modified"> 473                     }</span>
<span class="line-modified"> 474             });</span>

 475 
 476         if (platformFont) {
 477             usePlatformFontMetrics = true;
 478             System.out.println(&quot;Enabling platform font metrics for win32. This is an unsupported option.&quot;);
 479             System.out.println(&quot;This yields incorrect composite font metrics as reported by 1.1.x releases.&quot;);
 480             System.out.println(&quot;It is appropriate only for use by applications which do not use any Java 2&quot;);
 481             System.out.println(&quot;functionality. This property will be removed in a later release.&quot;);
 482         }
 483     }
 484 
 485     public Font2DHandle getNewComposite(String family, int style,
 486                                         Font2DHandle handle) {
 487 
 488         if (!(handle.font2D instanceof CompositeFont)) {
 489             return handle;
 490         }
 491 
 492         CompositeFont oldComp = (CompositeFont)handle.font2D;
 493         PhysicalFont oldFont = oldComp.getSlotFont(0);
 494 
</pre>
<hr />
<pre>
 778 
 779     private static final class FontRegistrationInfo {
 780 
 781         String fontFilePath;
 782         String[] nativeNames;
 783         int fontFormat;
 784         boolean javaRasterizer;
 785         int fontRank;
 786 
 787         FontRegistrationInfo(String fontPath, String[] names, int format,
 788                              boolean useJavaRasterizer, int rank) {
 789             this.fontFilePath = fontPath;
 790             this.nativeNames = names;
 791             this.fontFormat = format;
 792             this.javaRasterizer = useJavaRasterizer;
 793             this.fontRank = rank;
 794         }
 795     }
 796 
 797     private final ConcurrentHashMap&lt;String, FontRegistrationInfo&gt;
<span class="line-modified"> 798         deferredFontFiles = new ConcurrentHashMap&lt;&gt;();</span>

 799     private final ConcurrentHashMap&lt;String, Font2DHandle&gt;
<span class="line-modified"> 800         initialisedFonts = new ConcurrentHashMap&lt;&gt;();</span>
 801 
 802     /* Remind: possibly enhance initialiseDeferredFonts() to be
 803      * optionally given a name and a style and it could stop when it
 804      * finds that font - but this would be a problem if two of the
 805      * fonts reference the same font face name (cf the Solaris
 806      * euro fonts).
 807      */
 808     protected synchronized void initialiseDeferredFonts() {
 809         for (String fileName : deferredFontFiles.keySet()) {
 810             initialiseDeferredFont(fileName);
 811         }
 812     }
 813 
 814     protected synchronized void registerDeferredJREFonts(String jreDir) {
 815         for (FontRegistrationInfo info : deferredFontFiles.values()) {
 816             if (info.fontFilePath != null &amp;&amp;
 817                 info.fontFilePath.startsWith(jreDir)) {
 818                 initialiseDeferredFont(info.fontFilePath);
 819             }
 820         }
</pre>
<hr />
<pre>
 822 
 823     public boolean isDeferredFont(String fileName) {
 824         return deferredFontFiles.containsKey(fileName);
 825     }
 826 
 827     PhysicalFont findJREDeferredFont(String name, int style) {
 828 
 829         /* Iterate over the deferred font files looking for any in the
 830          * jre directory that we didn&#39;t recognise, open each of these.
 831          * In almost all installations this will quickly fall through
 832          * because jreOtherFontFiles will be empty.
 833          * noOtherJREFontFiles is used so we can skip this block as soon
 834          * as its determined that it&#39;s not needed - almost always after the
 835          * very first time through.
 836          */
 837         if (noOtherJREFontFiles) {
 838             return null;
 839         }
 840         synchronized (jreFontDirName) {
 841             if (jreOtherFontFiles == null) {
<span class="line-modified"> 842                 HashSet&lt;String&gt; otherFontFiles = new HashSet&lt;&gt;();</span>
 843                 for (String deferredFile : deferredFontFiles.keySet()) {
 844                     File file = new File(deferredFile);
 845                     String dir = file.getParent();

 846                     /* skip names which aren&#39;t absolute, aren&#39;t in the JRE
 847                      * directory, or are known Lucida fonts.
 848                      */
 849                     if (dir == null || !dir.equals(jreFontDirName)) {
 850                         continue;
 851                     }
 852                     otherFontFiles.add(deferredFile);
 853                 }
 854                 jreOtherFontFiles = otherFontFiles.toArray(STR_ARRAY);
 855                 if (jreOtherFontFiles.length == 0) {
 856                     noOtherJREFontFiles = true;
 857                 }
 858             }
 859 
 860             for (int i=0; i&lt;jreOtherFontFiles.length;i++) {
 861                 String fileName = jreOtherFontFiles[i];
 862                 if (fileName == null) {
 863                     continue;
 864                 }
 865                 jreOtherFontFiles[i] = null;
</pre>
<hr />
<pre>
 960         return registeredFonts.get(name);
 961     }
 962 
 963     /* Note that the return value from this method is not always
 964      * derived from this file, and may be null. See addToFontList for
 965      * some explanation of this.
 966      */
 967     public PhysicalFont registerFontFile(String fileName,
 968                                          String[] nativeNames,
 969                                          int fontFormat,
 970                                          boolean useJavaRasterizer,
 971                                          int fontRank) {
 972 
 973         PhysicalFont regFont = registeredFonts.get(fileName);
 974         if (regFont != null) {
 975             return regFont;
 976         }
 977 
 978         PhysicalFont physicalFont = null;
 979         try {


 980             switch (fontFormat) {
 981 
 982             case FONTFORMAT_TRUETYPE:
 983                 int fn = 0;
 984                 TrueTypeFont ttf;
 985                 do {
 986                     ttf = new TrueTypeFont(fileName, nativeNames, fn++,
 987                                            useJavaRasterizer);
 988                     PhysicalFont pf = addToFontList(ttf, fontRank);
 989                     if (physicalFont == null) {
 990                         physicalFont = pf;
 991                     }
 992                 }
 993                 while (fn &lt; ttf.getFontCount());
 994                 break;
 995 
 996             case FONTFORMAT_TYPE1:
 997                 Type1Font t1f = new Type1Font(fileName, nativeNames);
 998                 physicalFont = addToFontList(t1f, fontRank);
 999                 break;
</pre>
<hr />
<pre>
1125 
1126     /* Obtained from Platform APIs (windows only)
1127      * Map from a lower-case family name to a list of full names of
1128      * the member fonts, eg:
1129      * &quot;arial&quot; -&gt; [&quot;Arial&quot;, &quot;Arial Bold&quot;, &quot;Arial Italic&quot;,&quot;Arial Bold Italic&quot;]
1130      */
1131     private HashMap&lt;String,ArrayList&lt;String&gt;&gt; familyToFontListMap= null;
1132 
1133     /* The directories which contain platform fonts */
1134     private String[] pathDirs = null;
1135 
1136     private boolean haveCheckedUnreferencedFontFiles;
1137 
1138     private String[] getFontFilesFromPath(boolean noType1) {
1139         final FilenameFilter filter;
1140         if (noType1) {
1141             filter = ttFilter;
1142         } else {
1143             filter = new TTorT1Filter();
1144         }
<span class="line-modified">1145         return AccessController.doPrivileged(new PrivilegedAction&lt;String[]&gt;() {</span>
<span class="line-modified">1146             public String[] run() {</span>
1147                 if (pathDirs.length == 1) {
1148                     File dir = new File(pathDirs[0]);
1149                     String[] files = dir.list(filter);
1150                     if (files == null) {
1151                         return new String[0];
1152                     }
1153                     for (int f=0; f&lt;files.length; f++) {
1154                         files[f] = files[f].toLowerCase();
1155                     }
1156                     return files;
1157                 } else {
<span class="line-modified">1158                     ArrayList&lt;String&gt; fileList = new ArrayList&lt;&gt;();</span>
1159                     for (int i = 0; i&lt; pathDirs.length; i++) {
1160                         File dir = new File(pathDirs[i]);
1161                         String[] files = dir.list(filter);
1162                         if (files == null) {
1163                             continue;
1164                         }
<span class="line-modified">1165                         for (int f = 0; f &lt; files.length ; f++) {</span>
1166                             fileList.add(files[f].toLowerCase());
1167                         }
1168                     }
1169                     return fileList.toArray(STR_ARRAY);
1170                 }
1171             }
1172         });
1173     }
1174 
1175     /* This is needed since some windows registry names don&#39;t match
1176      * the font names.
1177      * - UPC styled font names have a double space, but the
1178      * registry entry mapping to a file doesn&#39;t.
1179      * - Marlett is in a hidden file not listed in the registry
1180      * - The registry advertises that the file david.ttf contains a
1181      * font with the full name &quot;David Regular&quot; when in fact its
1182      * just &quot;David&quot;.
1183      * Directly fix up these known cases as this is faster.
1184      * If a font which doesn&#39;t match these known cases has no file,
1185      * it may be a font that has been temporarily added to the known set
</pre>
<hr />
<pre>
1202                     String newName = font.replaceFirst(&quot;  &quot;, &quot; &quot;);
1203                     file = fontToFileMap.get(newName);
1204                     /* If this name exists and isn&#39;t for a valid name
1205                      * replace the mapping to the file with this font
1206                      */
1207                     if (file != null &amp;&amp;
1208                         !fontToFamilyNameMap.containsKey(newName)) {
1209                         fontToFileMap.remove(newName);
1210                         fontToFileMap.put(font, file);
1211                     }
1212                 } else if (font.equals(&quot;marlett&quot;)) {
1213                     fontToFileMap.put(font, &quot;marlett.ttf&quot;);
1214                 } else if (font.equals(&quot;david&quot;)) {
1215                     file = fontToFileMap.get(&quot;david regular&quot;);
1216                     if (file != null) {
1217                         fontToFileMap.remove(&quot;david regular&quot;);
1218                         fontToFileMap.put(&quot;david&quot;, file);
1219                     }
1220                 } else {
1221                     if (unmappedFontNames == null) {
<span class="line-modified">1222                         unmappedFontNames = new ArrayList&lt;&gt;();</span>
1223                     }
1224                     unmappedFontNames.add(font);
1225                 }
1226             }
1227         }
1228 
1229         if (unmappedFontNames != null) {
<span class="line-modified">1230             HashSet&lt;String&gt; unmappedFontFiles = new HashSet&lt;&gt;();</span>
1231 
1232             /* Every font key in fontToFileMap ought to correspond to a
1233              * font key in fontToFamilyNameMap. Entries that don&#39;t seem
1234              * to correspond are likely fonts that were named differently
1235              * by GDI than in the registry. One known cause of this is when
1236              * Windows has had its regional settings changed so that from
1237              * GDI we get a localised (eg Chinese or Japanese) name for the
1238              * font, but the registry retains the English version of the name
1239              * that corresponded to the &quot;install&quot; locale for windows.
1240              * Since we are in this code block because there are unmapped
1241              * font names, we can look to find unused font-&gt;file mappings
1242              * and then open the files to read the names. We don&#39;t generally
1243              * want to open font files, as its a performance hit, but this
1244              * occurs only for a small number of fonts on specific system
1245              * configs - ie is believed that a &quot;true&quot; Japanese windows would
1246              * have JA names in the registry too.
1247              * Clone fontToFileMap and remove from the clone all keys which
1248              * match a fontToFamilyNameMap key. What remains maps to the
1249              * files we want to open to find the fonts GDI returned.
1250              * A font in such a file is added to the fontToFileMap after
</pre>
<hr />
<pre>
1265                 ffmapCopy.remove(key);
1266             }
1267             for (String key : ffmapCopy.keySet()) {
1268                 unmappedFontFiles.add(ffmapCopy.get(key));
1269                 fontToFileMap.remove(key);
1270             }
1271 
1272             resolveFontFiles(unmappedFontFiles, unmappedFontNames);
1273 
1274             /* If there are still unmapped font names, this means there&#39;s
1275              * something that wasn&#39;t in the registry. We need to get all
1276              * the font files directly and look at the ones that weren&#39;t
1277              * found in the registry.
1278              */
1279             if (unmappedFontNames.size() &gt; 0) {
1280 
1281                 /* getFontFilesFromPath() returns all lower case names.
1282                  * To compare we also need lower case
1283                  * versions of the names from the registry.
1284                  */
<span class="line-modified">1285                 ArrayList&lt;String&gt; registryFiles = new ArrayList&lt;&gt;();</span>
1286 
1287                 for (String regFile : fontToFileMap.values()) {
1288                     registryFiles.add(regFile.toLowerCase());
1289                 }
1290                 /* We don&#39;t look for Type1 files here as windows will
1291                  * not enumerate these, so aren&#39;t useful in reconciling
1292                  * GDI&#39;s unmapped files. We do find these later when
1293                  * we enumerate all fonts.
1294                  */
1295                 for (String pathFile : getFontFilesFromPath(true)) {
1296                     if (!registryFiles.contains(pathFile)) {
1297                         unmappedFontFiles.add(pathFile);
1298                     }
1299                 }
1300 
1301                 resolveFontFiles(unmappedFontFiles, unmappedFontNames);
1302             }
1303 
1304             /* remove from the set of names that will be returned to the
1305              * user any fonts that can&#39;t be mapped to files.
</pre>
<hr />
<pre>
1334      * only in getAllFonts/Families, so most searches for a specific
1335      * font that is satisfied by the GDI/registry calls don&#39;t take the
1336      * additional hit of listing the directory. This hit is small enough
1337      * that its not significant in these &#39;enumerate all the fonts&#39; cases.
1338      * The basic approach is to cross-reference the files windows found
1339      * with the ones in the directory listing approach, and for each
1340      * in the latter list that is missing from the former list, register it.
1341      */
1342     private synchronized void checkForUnreferencedFontFiles() {
1343         if (haveCheckedUnreferencedFontFiles) {
1344             return;
1345         }
1346         haveCheckedUnreferencedFontFiles = true;
1347         if (!FontUtilities.isWindows) {
1348             return;
1349         }
1350         /* getFontFilesFromPath() returns all lower case names.
1351          * To compare we also need lower case
1352          * versions of the names from the registry.
1353          */
<span class="line-modified">1354         ArrayList&lt;String&gt; registryFiles = new ArrayList&lt;&gt;();</span>
1355         for (String regFile : fontToFileMap.values()) {
1356             registryFiles.add(regFile.toLowerCase());
1357         }
1358 
1359         /* To avoid any issues with concurrent modification, create
1360          * copies of the existing maps, add the new fonts into these
1361          * and then replace the references to the old ones with the
1362          * new maps. ConcurrentHashmap is another option but its a lot
1363          * more changes and with this exception, these maps are intended
1364          * to be static.
1365          */
1366         HashMap&lt;String,String&gt; fontToFileMap2 = null;
1367         HashMap&lt;String,String&gt; fontToFamilyNameMap2 = null;
1368         HashMap&lt;String,ArrayList&lt;String&gt;&gt; familyToFontListMap2 = null;;
1369 
1370         for (String pathFile : getFontFilesFromPath(false)) {
1371             if (!registryFiles.contains(pathFile)) {
1372                 if (FontUtilities.isLogging()) {
1373                     FontUtilities.getLogger()
1374                                  .info(&quot;Found non-registry file : &quot; + pathFile);
1375                 }
1376                 PhysicalFont f = registerFontFile(getPathName(pathFile));
1377                 if (f == null) {
1378                     continue;
1379                 }
1380                 if (fontToFileMap2 == null) {
<span class="line-modified">1381                     fontToFileMap2 = new HashMap&lt;&gt;(fontToFileMap);</span>
<span class="line-modified">1382                     fontToFamilyNameMap2 = new HashMap&lt;&gt;(fontToFamilyNameMap);</span>
<span class="line-modified">1383                     familyToFontListMap2 = new HashMap&lt;&gt;(familyToFontListMap);</span>


1384                 }
1385                 String fontName = f.getFontName(null);
1386                 String family = f.getFamilyName(null);
1387                 String familyLC = family.toLowerCase();
1388                 fontToFamilyNameMap2.put(fontName, family);
1389                 fontToFileMap2.put(fontName, pathFile);
1390                 ArrayList&lt;String&gt; fonts = familyToFontListMap2.get(familyLC);
1391                 if (fonts == null) {
<span class="line-modified">1392                     fonts = new ArrayList&lt;&gt;();</span>
1393                 } else {
<span class="line-modified">1394                     fonts = new ArrayList&lt;&gt;(fonts);</span>
1395                 }
1396                 fonts.add(fontName);
1397                 familyToFontListMap2.put(familyLC, fonts);
1398             }
1399         }
1400         if (fontToFileMap2 != null) {
1401             fontToFileMap = fontToFileMap2;
1402             familyToFontListMap = familyToFontListMap2;
1403             fontToFamilyNameMap = fontToFamilyNameMap2;
1404         }
1405     }
1406 
1407     private void resolveFontFiles(HashSet&lt;String&gt; unmappedFiles,
1408                                   ArrayList&lt;String&gt; unmappedFonts) {
1409 
1410         Locale l = SunToolkit.getStartupLocale();
1411 
1412         for (String file : unmappedFiles) {
1413             try {
1414                 int fn = 0;
</pre>
<hr />
<pre>
1452      * then registers the whole family, returning the right font.
1453      */
1454     public static class FamilyDescription {
1455         public String familyName;
1456         public String plainFullName;
1457         public String boldFullName;
1458         public String italicFullName;
1459         public String boldItalicFullName;
1460         public String plainFileName;
1461         public String boldFileName;
1462         public String italicFileName;
1463         public String boldItalicFileName;
1464     }
1465 
1466     static HashMap&lt;String, FamilyDescription&gt; platformFontMap;
1467 
1468     /**
1469      * default implementation does nothing.
1470      */
1471     public HashMap&lt;String, FamilyDescription&gt; populateHardcodedFileNameMap() {
<span class="line-modified">1472         return new HashMap&lt;&gt;(0);</span>
1473     }
1474 
1475     Font2D findFontFromPlatformMap(String lcName, int style) {
1476         if (platformFontMap == null) {
1477             platformFontMap = populateHardcodedFileNameMap();
1478         }
1479 
1480         if (platformFontMap == null || platformFontMap.size() == 0) {
1481             return null;
1482         }
1483 
1484         int spaceIndex = lcName.indexOf(&#39; &#39;);
1485         String firstWord = lcName;
1486         if (spaceIndex &gt; 0) {
1487             firstWord = lcName.substring(0, spaceIndex);
1488         }
1489 
1490         FamilyDescription fd = platformFontMap.get(firstWord);
1491         if (fd == null) {
1492             return null;
</pre>
<hr />
<pre>
1547         if (fd.boldItalicFileName != null) {
1548             boldItalicFile = getPathName(fd.boldItalicFileName);
1549             if (boldItalicFile == null) {
1550                 failure = true;
1551             }
1552         }
1553 
1554         if (failure) {
1555             if (FontUtilities.isLogging()) {
1556                 FontUtilities.getLogger().
1557                     info(&quot;Hardcoded file missing looking for &quot; + lcName);
1558             }
1559             platformFontMap.remove(firstWord);
1560             return null;
1561         }
1562 
1563         /* Some of these may be null,as not all styles have to exist */
1564         final String[] files = {
1565             plainFile, boldFile, italicFile, boldItalicFile } ;
1566 
<span class="line-modified">1567         failure = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() {</span>
<span class="line-modified">1568              public Boolean run() {</span>
<span class="line-modified">1569                  for (int i=0; i&lt;files.length; i++) {</span>
<span class="line-modified">1570                      if (files[i] == null) {</span>
<span class="line-modified">1571                          continue;</span>








1572                      }
<span class="line-modified">1573                      File f = new File(files[i]);</span>
<span class="line-added">1574                      if (!f.exists()) {</span>
<span class="line-added">1575                          return Boolean.TRUE;</span>
<span class="line-added">1576                      }</span>
<span class="line-added">1577                  }</span>
<span class="line-added">1578                  return Boolean.FALSE;</span>
<span class="line-added">1579              }</span>
<span class="line-added">1580          });</span>
1581 
1582         if (failure) {
1583             if (FontUtilities.isLogging()) {
1584                 FontUtilities.getLogger().
1585                     info(&quot;Hardcoded file missing looking for &quot; + lcName);
1586             }
1587             platformFontMap.remove(firstWord);
1588             return null;
1589         }
1590 
1591         /* If we reach here we know that we have all the files we
1592          * expect, so all should be fine so long as the contents
1593          * are what we&#39;d expect. Now on to registering the fonts.
1594          * Currently this code only looks for TrueType fonts, so format
1595          * and rank can be specified without looking at the filename.
1596          */
1597         Font2D font = null;
1598         for (int f=0;f&lt;files.length;f++) {
1599             if (files[f] == null) {
1600                 continue;
</pre>
<hr />
<pre>
1626                 font = fontFamily.getFont(style);
1627                 if (font == null) {
1628                     font = fontFamily.getClosestStyle(style);
1629                 }
1630             } else if (style &gt; 0 &amp;&amp; style != font.style) {
1631                 style |= font.style;
1632                 font = fontFamily.getFont(style);
1633                 if (font == null) {
1634                     font = fontFamily.getClosestStyle(style);
1635                 }
1636             }
1637         }
1638 
1639         return font;
1640     }
1641     private synchronized HashMap&lt;String,String&gt; getFullNameToFileMap() {
1642         if (fontToFileMap == null) {
1643 
1644             pathDirs = getPlatformFontDirs(noType1Font);
1645 
<span class="line-modified">1646             fontToFileMap = new HashMap&lt;&gt;(100);</span>
<span class="line-modified">1647             fontToFamilyNameMap = new HashMap&lt;&gt;(100);</span>
<span class="line-modified">1648             familyToFontListMap = new HashMap&lt;&gt;(50);</span>
1649             populateFontFileNameMap(fontToFileMap,
1650                                     fontToFamilyNameMap,
1651                                     familyToFontListMap,
1652                                     Locale.ENGLISH);
1653             if (FontUtilities.isWindows) {
1654                 resolveWindowsFonts();
1655             }
1656             if (FontUtilities.isLogging()) {
1657                 logPlatformFontInfo();
1658             }
1659         }
1660         return fontToFileMap;
1661     }
1662 
1663     private void logPlatformFontInfo() {
1664         PlatformLogger logger = FontUtilities.getLogger();
1665         for (int i=0; i&lt; pathDirs.length;i++) {
1666             logger.info(&quot;fontdir=&quot;+pathDirs[i]);
1667         }
1668         for (String keyName : fontToFileMap.keySet()) {
1669             logger.info(&quot;font=&quot;+keyName+&quot; file=&quot;+ fontToFileMap.get(keyName));
1670         }
1671         for (String keyName : fontToFamilyNameMap.keySet()) {
1672             logger.info(&quot;font=&quot;+keyName+&quot; family=&quot;+
1673                         fontToFamilyNameMap.get(keyName));
1674         }
1675         for (String keyName : familyToFontListMap.keySet()) {
1676             logger.info(&quot;family=&quot;+keyName+ &quot; fonts=&quot;+
1677                         familyToFontListMap.get(keyName));
1678         }
1679     }
1680 
1681     /* Note this return list excludes logical fonts and JRE fonts */
1682     protected String[] getFontNamesFromPlatform() {
1683         if (getFullNameToFileMap().size() == 0) {
1684             return null;
1685         }
1686         checkForUnreferencedFontFiles();
1687         /* This odd code with TreeMap is used to preserve a historical
1688          * behaviour wrt the sorting order .. */
<span class="line-modified">1689         ArrayList&lt;String&gt; fontNames = new ArrayList&lt;&gt;();</span>
1690         for (ArrayList&lt;String&gt; a : familyToFontListMap.values()) {
1691             for (String s : a) {
1692                 fontNames.add(s);
1693             }
1694         }
1695         return fontNames.toArray(STR_ARRAY);
1696     }
1697 
1698     public boolean gotFontsFromPlatform() {
1699         return getFullNameToFileMap().size() != 0;
1700     }
1701 
1702     public String getFileNameForFontName(String fontName) {
1703         String fontNameLC = fontName.toLowerCase(Locale.ENGLISH);
1704         return fontToFileMap.get(fontNameLC);
1705     }
1706 
1707     private PhysicalFont registerFontFile(String file) {
1708         if (new File(file).isAbsolute() &amp;&amp;
1709             !registeredFonts.containsKey(file)) {
</pre>
<hr />
<pre>
1748         if (getFullNameToFileMap().size() == 0) {
1749             return false;
1750         }
1751         checkForUnreferencedFontFiles();
1752         for (String name : fontToFamilyNameMap.values()) {
1753             familyNames.put(name.toLowerCase(requestedLocale), name);
1754         }
1755         return true;
1756     }
1757 
1758     /* Path may be absolute or a base file name relative to one of
1759      * the platform font directories
1760      */
1761     private String getPathName(final String s) {
1762         File f = new File(s);
1763         if (f.isAbsolute()) {
1764             return s;
1765         } else if (pathDirs.length==1) {
1766             return pathDirs[0] + File.separator + s;
1767         } else {
<span class="line-modified">1768             String path = AccessController.doPrivileged(</span>
<span class="line-modified">1769                  new PrivilegedAction&lt;String&gt;() {</span>
1770                      public String run() {
<span class="line-modified">1771                          for (int p = 0; p &lt; pathDirs.length; p++) {</span>
1772                              File f = new File(pathDirs[p] +File.separator+ s);
1773                              if (f.exists()) {
1774                                  return f.getAbsolutePath();
1775                              }
1776                          }
1777                          return null;
1778                      }
1779                 });
1780             if (path != null) {
1781                 return path;
1782             }
1783         }
1784         return s; // shouldn&#39;t happen, but harmless
1785     }
1786 
1787     /* lcName is required to be lower case for use as a key.
1788      * lcName may be a full name, or a family name, and style may
1789      * be specified in addition to either of these. So be sure to
1790      * get the right one. Since an app *could* ask for &quot;Foo Regular&quot;
1791      * and later ask for &quot;Foo Italic&quot;, if we don&#39;t register all the
</pre>
<hr />
<pre>
1879             registerFontFile(getPathName(fileName), null,
1880                              FONTFORMAT_TRUETYPE, false, Font2D.TTF_RANK);
1881         }
1882 
1883         Font2D font = null;
1884         FontFamily fontFamily = FontFamily.getFamily(familyName);
1885         /* Handle case where request &quot;MyFont Bold&quot;, style=Font.ITALIC */
1886         if (physicalFont != null) {
1887             style |= physicalFont.style;
1888         }
1889         if (fontFamily != null) {
1890             font = fontFamily.getFont(style);
1891             if (font == null) {
1892                 font = fontFamily.getClosestStyle(style);
1893             }
1894         }
1895         return font;
1896     }
1897 
1898     private ConcurrentHashMap&lt;String, Font2D&gt; fontNameCache =
<span class="line-modified">1899         new ConcurrentHashMap&lt;&gt;();</span>
1900 
1901     /*
1902      * The client supplies a name and a style.
1903      * The name could be a family name, or a full name.
1904      * A font may exist with the specified style, or it may
1905      * exist only in some other style. For non-native fonts the scaler
1906      * may be able to emulate the required style.
1907      */
1908     public Font2D findFont2D(String name, int style, int fallback) {
1909         String lowerCaseName = name.toLowerCase(Locale.ENGLISH);
1910         String mapName = lowerCaseName + dotStyleStr(style);
1911 
1912         /* If preferLocaleFonts() or preferProportionalFonts() has been
1913          * called we may be using an alternate set of composite fonts in this
1914          * app context. The presence of a pre-built name map indicates whether
1915          * this is so, and gives access to the alternate composite for the
1916          * name.
1917          */
1918         Font2D font = fontNameCache.get(mapName);
1919         if (font != null) {
</pre>
<hr />
<pre>
2249 
2250     public int getNumFonts() {
2251         return physicalFonts.size()+maxCompFont;
2252     }
2253 
2254     private static boolean fontSupportsEncoding(Font font, String encoding) {
2255         return FontUtilities.getFont2D(font).supportsEncoding(encoding);
2256     }
2257 
2258     protected abstract String getFontPath(boolean noType1Fonts);
2259 
2260     Thread fileCloser = null;
2261     Vector&lt;File&gt; tmpFontFiles = null;
2262 
2263     private int createdFontCount = 0;
2264 
2265     public Font2D[] createFont2D(File fontFile, int fontFormat, boolean all,
2266                                  boolean isCopy, CreatedFontTracker tracker)
2267     throws FontFormatException {
2268 
<span class="line-modified">2269         List&lt;Font2D&gt; fList = new ArrayList&lt;&gt;();</span>
2270         int cnt = 1;
2271         String fontFilePath = fontFile.getPath();
2272         FileFont font2D = null;
2273         final File fFile = fontFile;
2274         final CreatedFontTracker _tracker = tracker;
2275         boolean weakRefs = false;
2276         int maxStrikes = 0;
2277         synchronized (this) {
2278             if (createdFontCount &lt; maxSoftRefCnt) {
2279                 createdFontCount++;
2280             } else {
2281                   weakRefs = true;
2282                       maxStrikes = 10;
2283             }
2284         }
2285         try {
2286             switch (fontFormat) {
2287             case Font.TRUETYPE_FONT:
2288                 font2D = new TrueTypeFont(fontFilePath, null, 0, true);
2289                 font2D.setUseWeakRefs(weakRefs, maxStrikes);
</pre>
<hr />
<pre>
2292                     break;
2293                 }
2294                 cnt = ((TrueTypeFont)font2D).getFontCount();
2295                 int index = 1;
2296                 while (index &lt; cnt) {
2297                     font2D = new TrueTypeFont(fontFilePath, null, index++, true);
2298                     font2D.setUseWeakRefs(weakRefs, maxStrikes);
2299                     fList.add(font2D);
2300                 }
2301                 break;
2302             case Font.TYPE1_FONT:
2303                 font2D = new Type1Font(fontFilePath, null, isCopy);
2304                 font2D.setUseWeakRefs(weakRefs, maxStrikes);
2305                 fList.add(font2D);
2306                 break;
2307             default:
2308                 throw new FontFormatException(&quot;Unrecognised Font Format&quot;);
2309             }
2310         } catch (FontFormatException e) {
2311             if (isCopy) {
<span class="line-modified">2312                 AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
<span class="line-modified">2313                     public Void run() {</span>
<span class="line-modified">2314                         if (_tracker != null) {</span>
<span class="line-modified">2315                             _tracker.subBytes((int)fFile.length());</span>
<span class="line-modified">2316                         }</span>
<span class="line-modified">2317                         fFile.delete();</span>
<span class="line-modified">2318                         return null;</span>
<span class="line-modified">2319                     }</span>

2320                 });
2321             }
2322             throw(e);
2323         }
2324         if (isCopy) {
2325             FileFont.setFileToRemove(fList, fontFile, cnt, tracker);
2326             synchronized (FontManager.class) {
2327 
2328                 if (tmpFontFiles == null) {
2329                     tmpFontFiles = new Vector&lt;File&gt;();
2330                 }
2331                 tmpFontFiles.add(fontFile);
2332 
2333                 if (fileCloser == null) {
2334                     final Runnable fileCloserRunnable = new Runnable() {
<span class="line-modified">2335                         public void run() {</span>
<span class="line-modified">2336                             AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
<span class="line-modified">2337                                 public Void run() {</span>
<span class="line-modified">2338                                     for (int i = 0;i &lt; CHANNELPOOLSIZE; i++) {</span>
<span class="line-modified">2339                                         if (fontFileCache[i] != null) {</span>
<span class="line-modified">2340                                             try {</span>
<span class="line-modified">2341                                                 fontFileCache[i].close();</span>
<span class="line-modified">2342                                             } catch (Exception e) {</span>
<span class="line-modified">2343                                             }</span>
<span class="line-modified">2344                                         }</span>
2345                                     }
<span class="line-modified">2346                                     if (tmpFontFiles != null) {</span>
<span class="line-modified">2347                                         File[] files = new File[tmpFontFiles.size()];</span>
<span class="line-modified">2348                                         files = tmpFontFiles.toArray(files);</span>
<span class="line-modified">2349                                         for (int f=0; f&lt;files.length;f++) {</span>
<span class="line-modified">2350                                             try {</span>
<span class="line-modified">2351                                                 files[f].delete();</span>
<span class="line-modified">2352                                             } catch (Exception e) {</span>
<span class="line-modified">2353                                             }</span>
<span class="line-modified">2354                                         }</span>
2355                                     }
<span class="line-added">2356                                     return null;</span>
2357                                 }
<span class="line-modified">2358                             });</span>
<span class="line-modified">2359                         }</span>





2360                     };
2361                     AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
2362                         ThreadGroup rootTG = ThreadGroupUtils.getRootThreadGroup();
2363                         fileCloser = new Thread(rootTG, fileCloserRunnable,
2364                                                 &quot;FileCloser&quot;, 0, false);
2365                         fileCloser.setContextClassLoader(null);
2366                         Runtime.getRuntime().addShutdownHook(fileCloser);
2367                         return null;
2368                     });
2369                 }
2370             }
2371         }
2372         return fList.toArray(new Font2D[0]);
2373     }
2374 
2375     /* remind: used in X11GraphicsEnvironment and called often enough
2376      * that we ought to obsolete this code
2377      */
2378     public synchronized String getFullNameByFileName(String fileName) {
2379         PhysicalFont[] physFonts = getPhysicalFonts();
</pre>
<hr />
<pre>
2499              * we can live with the glitch that depending on how it was
2500              * initialised a composite may return different values for this.
2501              * Fixing the issues with composite glyph ids is tricky as
2502              * there are exclusion ranges and unlike other fonts even the
2503              * true &quot;numGlyphs&quot; isn&#39;t a contiguous range. Likely the only
2504              * solution is an API that returns an array of glyph ranges
2505              * which takes precedence over the existing API. That might
2506              * also need to address excluding ranges which represent a
2507              * code point supported by an earlier component.
2508              */
2509             if (newFont.getRank() &gt; Font2D.FONT_CONFIG_RANK) {
2510                 compFonts[i].replaceComponentFont(oldFont, newFont);
2511             }
2512         }
2513     }
2514 
2515     private synchronized void loadLocaleNames() {
2516         if (localeFullNamesToFont != null) {
2517             return;
2518         }
<span class="line-modified">2519         localeFullNamesToFont = new HashMap&lt;&gt;();</span>
2520         Font2D[] fonts = getRegisteredFonts();
2521         for (int i=0; i&lt;fonts.length; i++) {
2522             if (fonts[i] instanceof TrueTypeFont) {
2523                 TrueTypeFont ttf = (TrueTypeFont)fonts[i];
2524                 String[] fullNames = ttf.getAllFullNames();
2525                 for (int n=0; n&lt;fullNames.length; n++) {
2526                     localeFullNamesToFont.put(fullNames[n], ttf);
2527                 }
2528                 FontFamily family = FontFamily.getFamily(ttf.familyName);
2529                 if (family != null) {
2530                     FontFamily.addLocaleNames(family, ttf.getAllFamilyNames());
2531                 }
2532             }
2533         }
2534     }
2535 
2536     /* This replicate the core logic of findFont2D but operates on
2537      * all the locale names. This hasn&#39;t been merged into findFont2D to
2538      * keep the logic simpler and reduce overhead, since this case is
2539      * almost never used. The main case in which it is called is when
</pre>
<hr />
<pre>
2719          */
2720         if (!FontConfiguration.hasMonoToPropMap()) {
2721             return;
2722         }
2723         if (gPropPref == true) {
2724             return;
2725         }
2726         gPropPref = true;
2727         createCompositeFonts(fontNameCache, gLocalePref, gPropPref);
2728         _usingAlternateComposites = true;
2729     }
2730 
2731     private static HashSet&lt;String&gt; installedNames = null;
2732     private static HashSet&lt;String&gt; getInstalledNames() {
2733         if (installedNames == null) {
2734            Locale l = getSystemStartupLocale();
2735            SunFontManager fontManager = SunFontManager.getInstance();
2736            String[] installedFamilies =
2737                fontManager.getInstalledFontFamilyNames(l);
2738            Font[] installedFonts = fontManager.getAllInstalledFonts();
<span class="line-modified">2739            HashSet&lt;String&gt; names = new HashSet&lt;&gt;();</span>
2740            for (int i=0; i&lt;installedFamilies.length; i++) {
2741                names.add(installedFamilies[i].toLowerCase(l));
2742            }
2743            for (int i=0; i&lt;installedFonts.length; i++) {
2744                names.add(installedFonts[i].getFontName(l).toLowerCase(l));
2745            }
2746            installedNames = names;
2747         }
2748         return installedNames;
2749     }
2750 
2751     private static final Object regFamilyLock  = new Object();
2752     private Hashtable&lt;String,FontFamily&gt; createdByFamilyName;
2753     private Hashtable&lt;String,Font2D&gt;     createdByFullName;
2754     private boolean fontsAreRegistered = false;
2755 
2756     public boolean registerFont(Font font) {
2757         /* This method should not be called with &quot;null&quot;.
2758          * It is the caller&#39;s responsibility to ensure that.
2759          */
</pre>
<hr />
<pre>
2881             Font[] fonts = new Font[nameTable.size()];
2882             int i=0;
2883             for (Font2D font2D : nameTable.values()) {
2884                 fonts[i++] = new Font(font2D.getFontName(l), Font.PLAIN, 1);
2885             }
2886             return fonts;
2887         }
2888     }
2889 
2890 
2891     protected String[] getPlatformFontDirs(boolean noType1Fonts) {
2892 
2893         /* First check if we already initialised path dirs */
2894         if (pathDirs != null) {
2895             return pathDirs;
2896         }
2897 
2898         String path = getPlatformFontPath(noType1Fonts);
2899         StringTokenizer parser =
2900             new StringTokenizer(path, File.pathSeparator);
<span class="line-modified">2901         ArrayList&lt;String&gt; pathList = new ArrayList&lt;&gt;();</span>
2902         try {
2903             while (parser.hasMoreTokens()) {
2904                 pathList.add(parser.nextToken());
2905             }
2906         } catch (NoSuchElementException e) {
2907         }
2908         pathDirs = pathList.toArray(new String[0]);
2909         return pathDirs;
2910     }
2911 
2912     /**
2913      * Returns an array of two strings. The first element is the
2914      * name of the font. The second element is the file name.
2915      */
2916     protected abstract String[] getDefaultPlatformFont();
2917 
2918     // Begin: Refactored from SunGraphicsEnviroment.
2919 
2920     /*
2921      * helper function for registerFonts
</pre>
<hr />
<pre>
3011     public String getPlatformFontPath(boolean noType1Font) {
3012         if (fontPath == null) {
3013             fontPath = getFontPath(noType1Font);
3014         }
3015         return fontPath;
3016     }
3017 
3018     protected void loadFonts() {
3019         if (discoveredAllFonts) {
3020             return;
3021         }
3022         /* Use lock specific to the font system */
3023         synchronized (this) {
3024             if (FontUtilities.debugFonts()) {
3025                 Thread.dumpStack();
3026                 FontUtilities.getLogger()
3027                             .info(&quot;SunGraphicsEnvironment.loadFonts() called&quot;);
3028             }
3029             initialiseDeferredFonts();
3030 
<span class="line-modified">3031             AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
<span class="line-modified">3032                 public Void run() {</span>

3033                     if (fontPath == null) {
3034                         fontPath = getPlatformFontPath(noType1Font);
3035                         registerFontDirs(fontPath);
3036                     }
3037                     if (fontPath != null) {
3038                         // this will find all fonts including those already
3039                         // registered. But we have checks in place to prevent
3040                         // double registration.
3041                         if (! gotFontsFromPlatform()) {
3042                             registerFontsOnPath(fontPath, false,
3043                                                 Font2D.UNKNOWN_RANK,
3044                                                 false, true);
3045                             loadedAllFontFiles = true;
3046                         }
3047                     }
3048                     registerOtherFontFiles(registeredFontFiles);
3049                     discoveredAllFonts = true;
3050                     return null;
3051                 }
3052             });
</pre>
<hr />
<pre>
3127     /**
3128      * Returns face name for default font, or null if
3129      * no face names are used for CompositeFontDescriptors
3130      * for this platform.
3131      */
3132     public synchronized String getDefaultFontFaceName() {
3133         return defaultFontName;
3134     }
3135 
3136     public void loadFontFiles() {
3137         loadFonts();
3138         if (loadedAllFontFiles) {
3139             return;
3140         }
3141         /* Use lock specific to the font system */
3142         synchronized (this) {
3143             if (FontUtilities.debugFonts()) {
3144                 Thread.dumpStack();
3145                 FontUtilities.getLogger().info(&quot;loadAllFontFiles() called&quot;);
3146             }
<span class="line-modified">3147             AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
<span class="line-modified">3148                 public Void run() {</span>

3149                     if (fontPath == null) {
3150                         fontPath = getPlatformFontPath(noType1Font);
3151                     }
3152                     if (fontPath != null) {
3153                         // this will find all fonts including those already
3154                         // registered. But we have checks in place to prevent
3155                         // double registration.
3156                         registerFontsOnPath(fontPath, false,
3157                                             Font2D.UNKNOWN_RANK,
3158                                             false, true);
3159                     }
3160                     loadedAllFontFiles = true;
3161                     return null;
3162                 }
3163             });
3164         }
3165     }
3166 
3167     /*
3168      * This method asks the font configuration API for all platform names
</pre>
<hr />
<pre>
3317 
3318     protected void registerPlatformFontsUsedByFontConfiguration() {
3319     }
3320 
3321     /*
3322      * A GE may verify whether a font file used in a fontconfiguration
3323      * exists. If it doesn&#39;t then either we may substitute the default
3324      * font, or perhaps elide it altogether from the composite font.
3325      * This makes some sense on windows where the font file is only
3326      * likely to be in one place. But on other OSes, eg Linux, the file
3327      * can move around depending. So there we probably don&#39;t want to assume
3328      * its missing and so won&#39;t add it to this list.
3329      * If this list - missingFontFiles - is non-null then the composite
3330      * font initialisation logic tests to see if a font file is in that
3331      * set.
3332      * Only one thread should be able to add to this set so we don&#39;t
3333      * synchronize.
3334      */
3335     protected void addToMissingFontFileList(String fileName) {
3336         if (missingFontFiles == null) {
<span class="line-modified">3337             missingFontFiles = new HashSet&lt;&gt;();</span>
3338         }
3339         missingFontFiles.add(fileName);
3340     }
3341 
3342     /*
3343      * This is for use only within getAllFonts().
3344      * Fonts listed in the fontconfig files for windows were all
3345      * on the &quot;deferred&quot; initialisation list. They were registered
3346      * either in the course of the application, or in the call to
3347      * loadFonts() within getAllFonts(). The fontconfig file specifies
3348      * the names of the fonts using the English names. If there&#39;s a
3349      * different name in the execution locale, then the platform will
3350      * report that, and we will construct the font with both names, and
3351      * thereby enumerate it twice. This happens for Japanese fonts listed
3352      * in the windows fontconfig, when run in the JA locale. The solution
3353      * is to rely (in this case) on the platform&#39;s font-&gt;file mapping to
3354      * determine that this name corresponds to a file we already registered.
3355      * This works because
3356      * - we know when we get here all deferred fonts are already initialised
3357      * - when we register a font file, we register all fonts in it.
</pre>
<hr />
<pre>
3484         // Add any native font family names here
3485         addNativeFontFamilyNames(familyNames, requestedLocale);
3486 
3487         String[] retval =  new String[familyNames.size()];
3488         Object [] keyNames = familyNames.keySet().toArray();
3489         for (int i=0; i &lt; keyNames.length; i++) {
3490             retval[i] = familyNames.get(keyNames[i]);
3491         }
3492         if (requestedLocale.equals(Locale.getDefault())) {
3493             lastDefaultLocale = requestedLocale;
3494             allFamilies = new String[retval.length];
3495             System.arraycopy(retval, 0, allFamilies, 0, allFamilies.length);
3496         }
3497         return retval;
3498     }
3499 
3500     // Provides an aperture to add native font family names to the map
3501     protected void addNativeFontFamilyNames(TreeMap&lt;String, String&gt; familyNames, Locale requestedLocale) { }
3502 
3503     public void register1dot0Fonts() {
<span class="line-modified">3504         AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
<span class="line-modified">3505             public Void run() {</span>

3506                 String type1Dir = &quot;/usr/openwin/lib/X11/fonts/Type1&quot;;
3507                 registerFontsInDir(type1Dir, true, Font2D.TYPE1_RANK,
3508                                    false, false);
3509                 return null;
3510             }
3511         });
3512     }
3513 
3514     /* Really we need only the JRE fonts family names, but there&#39;s little
3515      * overhead in doing this the easy way by adding all the currently
3516      * known fonts.
3517      */
3518     protected void getJREFontFamilyNames(TreeMap&lt;String,String&gt; familyNames,
3519                                          Locale requestedLocale) {
3520         registerDeferredJREFonts(jreFontDirName);
3521         Font2D[] physicalfonts = getPhysicalFonts();
3522         for (int i=0; i &lt; physicalfonts.length; i++) {
3523             if (!(physicalfonts[i] instanceof NativeFont)) {
3524                 String name =
3525                     physicalfonts[i].getFamilyName(requestedLocale);
3526                 familyNames.put(name.toLowerCase(requestedLocale), name);
3527             }
3528         }
3529     }
3530 
3531     /**
3532      * Default locale can be changed but we need to know the initial locale
3533      * as that is what is used by native code. Changing Java default locale
3534      * doesn&#39;t affect that.
3535      * Returns the locale in use when using native code to communicate
3536      * with platform APIs. On windows this is known as the &quot;system&quot; locale,
3537      * and it is usually the same as the platform locale, but not always,
3538      * so this method also checks an implementation property used only
3539      * on windows and uses that if set.
3540      */
3541     private static Locale systemLocale = null;
3542     private static Locale getSystemStartupLocale() {
3543         if (systemLocale == null) {
<span class="line-modified">3544             systemLocale = AccessController.doPrivileged(new PrivilegedAction&lt;Locale&gt;() {</span>
<span class="line-modified">3545                 public Locale run() {</span>
<span class="line-modified">3546                     /* On windows the system locale may be different than the</span>
<span class="line-modified">3547                      * user locale. This is an unsupported configuration, but</span>
<span class="line-modified">3548                      * in that case we want to return a dummy locale that will</span>
<span class="line-modified">3549                      * never cause a match in the usage of this API. This is</span>
<span class="line-modified">3550                      * important because Windows documents that the family</span>
<span class="line-modified">3551                      * names of fonts are enumerated using the language of</span>
<span class="line-modified">3552                      * the system locale. BY returning a dummy locale in that</span>
<span class="line-modified">3553                      * case we do not use the platform API which would not</span>
<span class="line-modified">3554                      * return us the names we want.</span>
<span class="line-modified">3555                      */</span>
<span class="line-modified">3556                     String fileEncoding = System.getProperty(&quot;file.encoding&quot;, &quot;&quot;);</span>
<span class="line-modified">3557                     String sysEncoding = System.getProperty(&quot;sun.jnu.encoding&quot;);</span>
<span class="line-modified">3558                     if (sysEncoding != null &amp;&amp; !sysEncoding.equals(fileEncoding)) {</span>
<span class="line-modified">3559                         return Locale.ROOT;</span>
<span class="line-modified">3560                     }</span>


3561 
<span class="line-modified">3562                     String language = System.getProperty(&quot;user.language&quot;, &quot;en&quot;);</span>
<span class="line-modified">3563                     String country  = System.getProperty(&quot;user.country&quot;,&quot;&quot;);</span>
<span class="line-modified">3564                     String variant  = System.getProperty(&quot;user.variant&quot;,&quot;&quot;);</span>
<span class="line-modified">3565                     return new Locale(language, country, variant);</span>
<span class="line-modified">3566                 }</span>
<span class="line-modified">3567             });</span>
3568         }
3569         return systemLocale;
3570     }
3571 
3572     void addToPool(FileFont font) {
3573 
3574         FileFont fontFileToClose = null;
3575         int freeSlot = -1;
3576 
3577         synchronized (fontFileCache) {
3578             /* Avoid duplicate entries in the pool, and don&#39;t close() it,
3579              * since this method is called only from within open().
3580              * Seeing a duplicate is most likely to happen if the thread
3581              * was interrupted during a read, forcing perhaps repeated
3582              * close and open calls and it eventually it ends up pointing
3583              * at the same slot.
3584              */
3585             for (int i=0;i&lt;CHANNELPOOLSIZE;i++) {
3586                 if (fontFileCache[i] == font) {
3587                     return;
</pre>
</td>
</tr>
</table>
<center><a href="../awt/ComponentFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="TrueTypeFont.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/macosx/classes/sun/lwawt/macosx/LWCToolkit.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.lwawt.macosx;
  27 
  28 import java.awt.AWTError;
<a name="2" id="anc2"></a><span class="line-added">  29 import java.awt.AWTException;</span>
  30 import java.awt.CheckboxMenuItem;
  31 import java.awt.Color;
  32 import java.awt.Component;
  33 import java.awt.Cursor;
  34 import java.awt.Desktop;
  35 import java.awt.Dialog;
  36 import java.awt.Dimension;
  37 import java.awt.Event;
  38 import java.awt.EventQueue;
  39 import java.awt.FileDialog;
  40 import java.awt.Frame;
  41 import java.awt.GraphicsConfiguration;
  42 import java.awt.GraphicsDevice;
  43 import java.awt.GraphicsEnvironment;
  44 import java.awt.HeadlessException;
  45 import java.awt.Image;
  46 import java.awt.Insets;
  47 import java.awt.Menu;
  48 import java.awt.MenuBar;
  49 import java.awt.MenuItem;
  50 import java.awt.Point;
  51 import java.awt.PopupMenu;
  52 import java.awt.RenderingHints;
<a name="3" id="anc3"></a>
  53 import java.awt.SystemTray;
  54 import java.awt.Taskbar;
  55 import java.awt.Toolkit;
  56 import java.awt.TrayIcon;
  57 import java.awt.Window;
  58 import java.awt.datatransfer.Clipboard;
  59 import java.awt.dnd.DragGestureEvent;
  60 import java.awt.dnd.DragGestureListener;
  61 import java.awt.dnd.DragGestureRecognizer;
  62 import java.awt.dnd.DragSource;
  63 import java.awt.dnd.DropTarget;
  64 import java.awt.dnd.InvalidDnDOperationException;
  65 import java.awt.dnd.MouseDragGestureRecognizer;
  66 import java.awt.dnd.peer.DragSourceContextPeer;
  67 import java.awt.event.InputEvent;
  68 import java.awt.event.InvocationEvent;
  69 import java.awt.event.KeyEvent;
  70 import java.awt.font.TextAttribute;
  71 import java.awt.im.InputMethodHighlight;
  72 import java.awt.im.spi.InputMethodDescriptor;
  73 import java.awt.peer.CheckboxMenuItemPeer;
  74 import java.awt.peer.DesktopPeer;
  75 import java.awt.peer.DialogPeer;
  76 import java.awt.peer.FileDialogPeer;
  77 import java.awt.peer.FontPeer;
  78 import java.awt.peer.MenuBarPeer;
  79 import java.awt.peer.MenuItemPeer;
  80 import java.awt.peer.MenuPeer;
  81 import java.awt.peer.PopupMenuPeer;
  82 import java.awt.peer.RobotPeer;
  83 import java.awt.peer.SystemTrayPeer;
  84 import java.awt.peer.TaskbarPeer;
  85 import java.awt.peer.TrayIconPeer;
  86 import java.lang.reflect.InvocationTargetException;
  87 import java.lang.reflect.UndeclaredThrowableException;
  88 import java.net.MalformedURLException;
  89 import java.net.URL;
  90 import java.security.AccessController;
  91 import java.security.PrivilegedAction;
  92 import java.util.HashMap;
  93 import java.util.Locale;
  94 import java.util.Map;
  95 import java.util.MissingResourceException;
  96 import java.util.Objects;
  97 import java.util.ResourceBundle;
  98 import java.util.concurrent.Callable;
  99 
 100 import javax.swing.UIManager;
 101 
 102 import com.apple.laf.AquaMenuBarUI;
 103 import sun.awt.AWTAccessor;
 104 import sun.awt.AppContext;
<a name="4" id="anc4"></a>
 105 import sun.awt.CGraphicsDevice;
 106 import sun.awt.LightweightFrame;
 107 import sun.awt.PlatformGraphicsInfo;
 108 import sun.awt.SunToolkit;
 109 import sun.awt.datatransfer.DataTransferer;
 110 import sun.awt.util.ThreadGroupUtils;
 111 import sun.java2d.macos.MacOSFlags;
 112 import sun.java2d.metal.MTLRenderQueue;
 113 import sun.java2d.opengl.OGLRenderQueue;
 114 import sun.lwawt.LWComponentPeer;
 115 import sun.lwawt.LWCursorManager;
 116 import sun.lwawt.LWToolkit;
 117 import sun.lwawt.LWWindowPeer;
 118 import sun.lwawt.LWWindowPeer.PeerType;
 119 import sun.lwawt.PlatformComponent;
 120 import sun.lwawt.PlatformDropTarget;
 121 import sun.lwawt.PlatformWindow;
 122 import sun.lwawt.SecurityWarningWindow;
 123 
 124 @SuppressWarnings(&quot;serial&quot;) // JDK implementation class
 125 final class NamedCursor extends Cursor {
 126     NamedCursor(String name) {
 127         super(name);
 128     }
 129 }
 130 
 131 /**
 132  * Mac OS X Cocoa-based AWT Toolkit.
 133  */
 134 public final class LWCToolkit extends LWToolkit {
 135     // While it is possible to enumerate all mouse devices
 136     // and query them for the number of buttons, the code
 137     // that does it is rather complex. Instead, we opt for
 138     // the easy way and just support up to 5 mouse buttons,
 139     // like Windows.
 140     private static final int BUTTONS = 5;
 141 
 142     private static native void initIDs();
 143     private static native void initAppkit(ThreadGroup appKitThreadGroup, boolean headless);
 144     private static CInputMethodDescriptor sInputMethodDescriptor;
 145 
 146     static {
 147         System.err.flush();
 148 
 149         ResourceBundle platformResources = java.security.AccessController.doPrivileged(
 150                 new java.security.PrivilegedAction&lt;ResourceBundle&gt;() {
 151             @Override
 152             public ResourceBundle run() {
 153                 ResourceBundle platformResources = null;
 154                 try {
 155                     platformResources = ResourceBundle.getBundle(&quot;sun.awt.resources.awtosx&quot;);
 156                 } catch (MissingResourceException e) {
 157                     // No resource file; defaults will be used.
 158                 }
 159 
 160                 System.loadLibrary(&quot;awt&quot;);
 161                 System.loadLibrary(&quot;fontmanager&quot;);
 162 
 163                 return platformResources;
 164             }
 165         });
 166 
 167         if (!GraphicsEnvironment.isHeadless() &amp;&amp;
 168             !PlatformGraphicsInfo.isInAquaSession())
 169         {
 170             throw new AWTError(&quot;WindowServer is not available&quot;);
 171         }
 172 
 173         AWTAccessor.getToolkitAccessor().setPlatformResources(platformResources);
 174 
 175         if (!GraphicsEnvironment.isHeadless()) {
 176             initIDs();
 177         }
 178         inAWT = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() {
 179             @Override
 180             public Boolean run() {
 181                 return !Boolean.parseBoolean(System.getProperty(&quot;javafx.embed.singleThread&quot;, &quot;false&quot;));
 182             }
 183         });
 184     }
 185 
 186     /*
 187      * If true  we operate in normal mode and nested runloop is executed in JavaRunLoopMode
 188      * If false we operate in singleThreaded FX/AWT interop mode and nested loop uses NSDefaultRunLoopMode
 189      */
 190     private static final boolean inAWT;
 191 
 192     public LWCToolkit() {
 193         final String extraButtons = &quot;sun.awt.enableExtraMouseButtons&quot;;
 194         AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
 195             areExtraMouseButtonsEnabled =
 196                  Boolean.parseBoolean(System.getProperty(extraButtons, &quot;true&quot;));
 197             //set system property if not yet assigned
 198             System.setProperty(extraButtons, &quot;&quot;+areExtraMouseButtonsEnabled);
 199             initAppkit(ThreadGroupUtils.getRootThreadGroup(),
 200                        GraphicsEnvironment.isHeadless());
 201             return null;
 202         });
 203     }
 204 
 205     /*
 206      * System colors with default initial values, overwritten by toolkit if system values differ and are available.
 207      */
 208     private static final int NUM_APPLE_COLORS = 3;
 209     public static final int KEYBOARD_FOCUS_COLOR = 0;
 210     public static final int INACTIVE_SELECTION_BACKGROUND_COLOR = 1;
 211     public static final int INACTIVE_SELECTION_FOREGROUND_COLOR = 2;
 212     private static int[] appleColors = {
 213         0xFF808080, // keyboardFocusColor = Color.gray;
 214         0xFFC0C0C0, // secondarySelectedControlColor
 215         0xFF303030, // controlDarkShadowColor
 216     };
 217 
 218     private native void loadNativeColors(final int[] systemColors, final int[] appleColors);
 219 
 220     @Override
 221     protected void loadSystemColors(final int[] systemColors) {
 222         if (systemColors == null) return;
 223         loadNativeColors(systemColors, appleColors);
 224     }
 225 
 226     @SuppressWarnings(&quot;serial&quot;) // JDK implementation class
 227     private static class AppleSpecificColor extends Color {
 228         private final int index;
 229         AppleSpecificColor(int index) {
 230             super(appleColors[index]);
 231             this.index = index;
 232         }
 233 
 234         @Override
 235         public int getRGB() {
 236             return appleColors[index];
 237         }
 238     }
 239 
 240     /**
 241      * Returns Apple specific colors that we may expose going forward.
 242      */
 243     public static Color getAppleColor(int color) {
 244         return new AppleSpecificColor(color);
 245     }
 246 
 247     // This is only called from native code.
 248     static void systemColorsChanged() {
 249         EventQueue.invokeLater(() -&gt; {
 250             AccessController.doPrivileged( (PrivilegedAction&lt;Object&gt;) () -&gt; {
 251                 AWTAccessor.getSystemColorAccessor().updateSystemColors();
 252                 return null;
 253             });
 254         });
 255     }
 256 
 257     public static LWCToolkit getLWCToolkit() {
 258         return (LWCToolkit)Toolkit.getDefaultToolkit();
 259     }
 260 
 261     @Override
 262     protected PlatformWindow createPlatformWindow(PeerType peerType) {
 263         if (peerType == PeerType.EMBEDDED_FRAME) {
 264             return new CPlatformEmbeddedFrame();
 265         } else if (peerType == PeerType.VIEW_EMBEDDED_FRAME) {
 266             return new CViewPlatformEmbeddedFrame();
 267         } else if (peerType == PeerType.LW_FRAME) {
 268             return new CPlatformLWWindow();
 269         } else {
 270             assert (peerType == PeerType.SIMPLEWINDOW
 271                     || peerType == PeerType.DIALOG
 272                     || peerType == PeerType.FRAME);
 273             return new CPlatformWindow();
 274         }
 275     }
 276 
 277     LWWindowPeer createEmbeddedFrame(CEmbeddedFrame target) {
 278         PlatformComponent platformComponent = createPlatformComponent();
 279         PlatformWindow platformWindow = createPlatformWindow(PeerType.EMBEDDED_FRAME);
 280         return createDelegatedPeer(target, platformComponent, platformWindow, PeerType.EMBEDDED_FRAME);
 281     }
 282 
 283     LWWindowPeer createEmbeddedFrame(CViewEmbeddedFrame target) {
 284         PlatformComponent platformComponent = createPlatformComponent();
 285         PlatformWindow platformWindow = createPlatformWindow(PeerType.VIEW_EMBEDDED_FRAME);
 286         return createDelegatedPeer(target, platformComponent, platformWindow, PeerType.VIEW_EMBEDDED_FRAME);
 287     }
 288 
 289     private CPrinterDialogPeer createCPrinterDialog(CPrinterDialog target) {
 290         PlatformComponent platformComponent = createPlatformComponent();
 291         PlatformWindow platformWindow = createPlatformWindow(PeerType.DIALOG);
 292         CPrinterDialogPeer peer = new CPrinterDialogPeer(target, platformComponent, platformWindow);
 293         targetCreatedPeer(target, peer);
 294         return peer;
 295     }
 296 
 297     @Override
 298     public DialogPeer createDialog(Dialog target) {
 299         if (target instanceof CPrinterDialog) {
 300             return createCPrinterDialog((CPrinterDialog)target);
 301         }
 302         return super.createDialog(target);
 303     }
 304 
 305     @Override
 306     protected SecurityWarningWindow createSecurityWarning(Window ownerWindow,
 307                                                           LWWindowPeer ownerPeer) {
 308         return new CWarningWindow(ownerWindow, ownerPeer);
 309     }
 310 
 311     @Override
 312     protected PlatformComponent createPlatformComponent() {
 313         return new CPlatformComponent();
 314     }
 315 
 316     @Override
 317     protected PlatformComponent createLwPlatformComponent() {
 318         return new CPlatformLWComponent();
 319     }
 320 
 321     @Override
 322     protected FileDialogPeer createFileDialogPeer(FileDialog target) {
 323         return new CFileDialog(target);
 324     }
 325 
 326     @Override
 327     public MenuPeer createMenu(Menu target) {
 328         MenuPeer peer = new CMenu(target);
 329         targetCreatedPeer(target, peer);
 330         return peer;
 331     }
 332 
 333     @Override
 334     public MenuBarPeer createMenuBar(MenuBar target) {
 335         MenuBarPeer peer = new CMenuBar(target);
 336         targetCreatedPeer(target, peer);
 337         return peer;
 338     }
 339 
 340     @Override
 341     public MenuItemPeer createMenuItem(MenuItem target) {
 342         MenuItemPeer peer = new CMenuItem(target);
 343         targetCreatedPeer(target, peer);
 344         return peer;
 345     }
 346 
 347     @Override
 348     public CheckboxMenuItemPeer createCheckboxMenuItem(CheckboxMenuItem target) {
 349         CheckboxMenuItemPeer peer = new CCheckboxMenuItem(target);
 350         targetCreatedPeer(target, peer);
 351         return peer;
 352     }
 353 
 354     @Override
 355     public PopupMenuPeer createPopupMenu(PopupMenu target) {
 356         PopupMenuPeer peer = new CPopupMenu(target);
 357         targetCreatedPeer(target, peer);
 358         return peer;
 359     }
 360 
 361     @Override
 362     public SystemTrayPeer createSystemTray(SystemTray target) {
 363         return new CSystemTray();
 364     }
 365 
 366     @Override
 367     public TrayIconPeer createTrayIcon(TrayIcon target) {
 368         TrayIconPeer peer = new CTrayIcon(target);
 369         targetCreatedPeer(target, peer);
 370         return peer;
 371     }
 372 
 373     @Override
 374     public DesktopPeer createDesktopPeer(Desktop target) {
 375         return new CDesktopPeer();
 376     }
 377 
 378     @Override
 379     public TaskbarPeer createTaskbarPeer(Taskbar target) {
 380         return new CTaskbarPeer();
 381     }
 382 
 383     @Override
 384     public LWCursorManager getCursorManager() {
 385         return CCursorManager.getInstance();
 386     }
 387 
 388     @Override
 389     public Cursor createCustomCursor(final Image cursor, final Point hotSpot,
 390                                      final String name)
 391             throws IndexOutOfBoundsException, HeadlessException {
 392         return new CCustomCursor(cursor, hotSpot, name);
 393     }
 394 
 395     @Override
 396     public Dimension getBestCursorSize(final int preferredWidth,
 397                                        final int preferredHeight)
 398             throws HeadlessException {
 399         return CCustomCursor.getBestCursorSize(preferredWidth, preferredHeight);
 400     }
 401 
 402     @Override
 403     protected void platformCleanup() {
 404         // TODO Auto-generated method stub
 405     }
 406 
 407     @Override
 408     protected void platformInit() {
 409         // TODO Auto-generated method stub
 410     }
 411 
 412     @Override
 413     protected void platformRunMessage() {
 414         // TODO Auto-generated method stub
 415     }
 416 
 417     @Override
 418     protected void platformShutdown() {
 419         // TODO Auto-generated method stub
 420     }
 421 
 422     class OSXPlatformFont extends sun.awt.PlatformFont
 423     {
 424         OSXPlatformFont(String name, int style)
 425         {
 426             super(name, style);
 427         }
 428         @Override
 429         protected char getMissingGlyphCharacter()
 430         {
 431             // Follow up for real implementation
 432             return (char)0xfff8; // see http://developer.apple.com/fonts/LastResortFont/
 433         }
 434     }
 435     @Override
 436     public FontPeer getFontPeer(String name, int style) {
 437         return new OSXPlatformFont(name, style);
 438     }
 439 
 440     @Override
 441     protected void initializeDesktopProperties() {
 442         super.initializeDesktopProperties();
 443         Map &lt;Object, Object&gt; fontHints = new HashMap&lt;&gt;();
 444         fontHints.put(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_HRGB);
 445         desktopProperties.put(SunToolkit.DESKTOPFONTHINTS, fontHints);
 446         desktopProperties.put(&quot;awt.mouse.numButtons&quot;, BUTTONS);
 447         desktopProperties.put(&quot;awt.multiClickInterval&quot;, getMultiClickTime());
 448 
 449         // These DnD properties must be set, otherwise Swing ends up spewing NPEs
 450         // all over the place. The values came straight off of MToolkit.
 451         desktopProperties.put(&quot;DnD.Autoscroll.initialDelay&quot;, Integer.valueOf(50));
 452         desktopProperties.put(&quot;DnD.Autoscroll.interval&quot;, Integer.valueOf(50));
 453         desktopProperties.put(&quot;DnD.Autoscroll.cursorHysteresis&quot;, Integer.valueOf(5));
 454 
 455         desktopProperties.put(&quot;DnD.isDragImageSupported&quot;, Boolean.TRUE);
 456 
 457         // Register DnD cursors
 458         desktopProperties.put(&quot;DnD.Cursor.CopyDrop&quot;, new NamedCursor(&quot;DnD.Cursor.CopyDrop&quot;));
 459         desktopProperties.put(&quot;DnD.Cursor.MoveDrop&quot;, new NamedCursor(&quot;DnD.Cursor.MoveDrop&quot;));
 460         desktopProperties.put(&quot;DnD.Cursor.LinkDrop&quot;, new NamedCursor(&quot;DnD.Cursor.LinkDrop&quot;));
 461         desktopProperties.put(&quot;DnD.Cursor.CopyNoDrop&quot;, new NamedCursor(&quot;DnD.Cursor.CopyNoDrop&quot;));
 462         desktopProperties.put(&quot;DnD.Cursor.MoveNoDrop&quot;, new NamedCursor(&quot;DnD.Cursor.MoveNoDrop&quot;));
 463         desktopProperties.put(&quot;DnD.Cursor.LinkNoDrop&quot;, new NamedCursor(&quot;DnD.Cursor.LinkNoDrop&quot;));
 464     }
 465 
 466     @Override
 467     protected boolean syncNativeQueue(long timeout) {
 468         return nativeSyncQueue(timeout);
 469     }
 470 
 471     @Override
 472     public native void beep();
 473 
 474     @Override
 475     public int getScreenResolution() throws HeadlessException {
 476         return (int) ((CGraphicsDevice) GraphicsEnvironment
 477                 .getLocalGraphicsEnvironment().getDefaultScreenDevice())
 478                 .getXResolution();
 479     }
 480 
 481     @Override
 482     public Insets getScreenInsets(final GraphicsConfiguration gc) {
<a name="5" id="anc5"></a><span class="line-modified"> 483         GraphicsDevice gd = gc.getDevice();</span>
<span class="line-added"> 484         if (!(gd instanceof CGraphicsDevice)) {</span>
<span class="line-added"> 485             return super.getScreenInsets(gc);</span>
<span class="line-added"> 486         }</span>
<span class="line-added"> 487         return ((CGraphicsDevice)gd).getScreenInsets();</span>
 488     }
 489 
 490     @Override
 491     public void sync() {
 492         // flush the OGL pipeline (this is a no-op if OGL is not enabled)
 493         if (MacOSFlags.isMetalEnabled()) {
 494             MTLRenderQueue.sync();
 495         } else {
 496             OGLRenderQueue.sync();
 497         }
 498         // setNeedsDisplay() selector was sent to the appropriate CALayer so now
 499         // we have to flush the native selectors queue.
 500         flushNativeSelectors();
 501     }
 502 
 503     @Override
<a name="6" id="anc6"></a><span class="line-modified"> 504     public RobotPeer createRobot(GraphicsDevice screen) throws AWTException {</span>
<span class="line-modified"> 505         if (screen instanceof CGraphicsDevice) {</span>
<span class="line-added"> 506             return new CRobot((CGraphicsDevice) screen);</span>
<span class="line-added"> 507         }</span>
<span class="line-added"> 508         return super.createRobot(screen);</span>
 509     }
 510 
 511     private native boolean isCapsLockOn();
 512 
 513     /*
 514      * NOTE: Among the keys this method is supposed to check,
 515      * only Caps Lock works as a true locking key with OS X.
 516      * There is no Scroll Lock key on modern Apple keyboards,
 517      * and with a PC keyboard plugged in Scroll Lock is simply
 518      * ignored: no LED lights up if you press it.
 519      * The key located at the same position on Apple keyboards
 520      * as Num Lock on PC keyboards is called Clear, doesn&#39;t lock
 521      * anything and is used for entirely different purpose.
 522      */
 523     @Override
 524     public boolean getLockingKeyState(int keyCode) throws UnsupportedOperationException {
 525         switch (keyCode) {
 526             case KeyEvent.VK_NUM_LOCK:
 527             case KeyEvent.VK_SCROLL_LOCK:
 528             case KeyEvent.VK_KANA_LOCK:
 529                 throw new UnsupportedOperationException(&quot;Toolkit.getLockingKeyState&quot;);
 530 
 531             case KeyEvent.VK_CAPS_LOCK:
 532                 return isCapsLockOn();
 533 
 534             default:
 535                 throw new IllegalArgumentException(&quot;invalid key for Toolkit.getLockingKeyState&quot;);
 536         }
 537     }
 538 
 539     //Is it allowed to generate events assigned to extra mouse buttons.
 540     //Set to true by default.
 541     private static boolean areExtraMouseButtonsEnabled = true;
 542 
 543     @Override
 544     public boolean areExtraMouseButtonsEnabled() throws HeadlessException {
 545         return areExtraMouseButtonsEnabled;
 546     }
 547 
 548     @Override
 549     public int getNumberOfButtons(){
 550         return BUTTONS;
 551     }
 552 
 553     /**
 554      * Returns the double-click time interval in ms.
 555      */
 556     private static native int getMultiClickTime();
 557 
 558     @Override
 559     public boolean isTraySupported() {
 560         return true;
 561     }
 562 
 563     @Override
 564     public DataTransferer getDataTransferer() {
 565         return CDataTransferer.getInstanceImpl();
 566     }
 567 
 568     @Override
 569     public boolean isAlwaysOnTopSupported() {
 570         return true;
 571     }
 572 
 573     private static final String APPKIT_THREAD_NAME = &quot;AppKit Thread&quot;;
 574 
 575     // Intended to be called from the LWCToolkit.m only.
 576     private static void installToolkitThreadInJava() {
 577         Thread.currentThread().setName(APPKIT_THREAD_NAME);
 578         AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
 579             Thread.currentThread().setContextClassLoader(null);
 580             return null;
 581         });
 582     }
 583 
 584     @Override
 585     public boolean isWindowOpacitySupported() {
 586         return true;
 587     }
 588 
 589     @Override
 590     public boolean isFrameStateSupported(int state) throws HeadlessException {
 591         switch (state) {
 592             case Frame.NORMAL:
 593             case Frame.ICONIFIED:
 594             case Frame.MAXIMIZED_BOTH:
 595                 return true;
 596             default:
 597                 return false;
 598         }
 599     }
 600 
 601     @Override
 602     @Deprecated(since = &quot;10&quot;)
 603     public int getMenuShortcutKeyMask() {
 604         return Event.META_MASK;
 605     }
 606 
 607     @Override
 608     public int getMenuShortcutKeyMaskEx() {
 609         return InputEvent.META_DOWN_MASK;
 610     }
 611 
 612     @Override
 613     public Image getImage(final String filename) {
 614         final Image nsImage = checkForNSImage(filename);
 615         if (nsImage != null) {
 616             return nsImage;
 617         }
 618 
 619         if (imageCached(filename)) {
 620             return super.getImage(filename);
 621         }
 622 
 623         String filename2x = getScaledImageName(filename);
 624         return (imageExists(filename2x))
 625                 ? getImageWithResolutionVariant(filename, filename2x)
 626                 : super.getImage(filename);
 627     }
 628 
 629     @Override
 630     public Image getImage(URL url) {
 631 
 632         if (imageCached(url)) {
 633             return super.getImage(url);
 634         }
 635 
 636         URL url2x = getScaledImageURL(url);
 637         return (imageExists(url2x))
 638                 ? getImageWithResolutionVariant(url, url2x) : super.getImage(url);
 639     }
 640 
 641     private static final String nsImagePrefix = &quot;NSImage://&quot;;
 642     private Image checkForNSImage(final String imageName) {
 643         if (imageName == null) return null;
 644         if (!imageName.startsWith(nsImagePrefix)) return null;
 645         return CImage.getCreator().createImageFromName(imageName.substring(nsImagePrefix.length()));
 646     }
 647 
 648     // Thread-safe Object.equals() called from native
 649     public static boolean doEquals(final Object a, final Object b, Component c) {
 650         if (a == b) return true;
 651 
 652         final boolean[] ret = new boolean[1];
 653 
 654         try {  invokeAndWait(new Runnable() { @Override
 655                                               public void run() { synchronized(ret) {
 656             ret[0] = a.equals(b);
 657         }}}, c); } catch (Exception e) { e.printStackTrace(); }
 658 
 659         synchronized(ret) { return ret[0]; }
 660     }
 661 
 662     public static &lt;T&gt; T invokeAndWait(final Callable&lt;T&gt; callable,
 663                                       Component component) throws Exception {
 664         final CallableWrapper&lt;T&gt; wrapper = new CallableWrapper&lt;&gt;(callable);
 665         invokeAndWait(wrapper, component);
 666         return wrapper.getResult();
 667     }
 668 
 669     static final class CallableWrapper&lt;T&gt; implements Runnable {
 670         final Callable&lt;T&gt; callable;
 671         T object;
 672         Exception e;
 673 
 674         CallableWrapper(final Callable&lt;T&gt; callable) {
 675             this.callable = callable;
 676         }
 677 
 678         @Override
 679         public void run() {
 680             try {
 681                 object = callable.call();
 682             } catch (final Exception e) {
 683                 this.e = e;
 684             }
 685         }
 686 
 687         public T getResult() throws Exception {
 688             if (e != null) throw e;
 689             return object;
 690         }
 691     }
 692 
 693     /**
 694      * Kicks an event over to the appropriate event queue and waits for it to
 695      * finish To avoid deadlocking, we manually run the NSRunLoop while waiting
 696      * Any selector invoked using ThreadUtilities performOnMainThread will be
 697      * processed in doAWTRunLoop The InvocationEvent will call
 698      * LWCToolkit.stopAWTRunLoop() when finished, which will stop our manual
 699      * run loop. Does not dispatch native events while in the loop
 700      */
 701     public static void invokeAndWait(Runnable runnable, Component component)
 702             throws InvocationTargetException {
 703         Objects.requireNonNull(component, &quot;Null component provided to invokeAndWait&quot;);
 704 
 705         long mediator = createAWTRunLoopMediator();
 706         InvocationEvent invocationEvent =
 707                 new InvocationEvent(component,
 708                         runnable,
 709                         () -&gt; {
 710                             if (mediator != 0) {
 711                                 stopAWTRunLoop(mediator);
 712                             }
 713                         },
 714                         true);
 715 
 716         AppContext appContext = SunToolkit.targetToAppContext(component);
 717         SunToolkit.postEvent(appContext, invocationEvent);
 718         // 3746956 - flush events from PostEventQueue to prevent them from getting stuck and causing a deadlock
 719         SunToolkit.flushPendingEvents(appContext);
 720         doAWTRunLoop(mediator, false);
 721 
 722         checkException(invocationEvent);
 723     }
 724 
 725     public static void invokeLater(Runnable event, Component component)
 726             throws InvocationTargetException {
 727         Objects.requireNonNull(component, &quot;Null component provided to invokeLater&quot;);
 728 
 729         InvocationEvent invocationEvent = new InvocationEvent(component, event);
 730 
 731         AppContext appContext = SunToolkit.targetToAppContext(component);
 732         SunToolkit.postEvent(SunToolkit.targetToAppContext(component), invocationEvent);
 733         // 3746956 - flush events from PostEventQueue to prevent them from getting stuck and causing a deadlock
 734         SunToolkit.flushPendingEvents(appContext);
 735 
 736         checkException(invocationEvent);
 737     }
 738 
 739     /**
 740      * Checks if exception occurred while {@code InvocationEvent} was processed and rethrows it as
 741      * an {@code InvocationTargetException}
 742      *
 743      * @param event the event to check for an exception
 744      * @throws InvocationTargetException if exception occurred when event was processed
 745      */
 746     private static void checkException(InvocationEvent event) throws InvocationTargetException {
 747         Throwable eventException = event.getException();
 748         if (eventException == null) return;
 749 
 750         if (eventException instanceof UndeclaredThrowableException) {
 751             eventException = ((UndeclaredThrowableException)eventException).getUndeclaredThrowable();
 752         }
 753         throw new InvocationTargetException(eventException);
 754     }
 755 
 756     /**
 757      * Schedules a {@code Runnable} execution on the Appkit thread after a delay
 758      * @param r a {@code Runnable} to execute
 759      * @param delay a delay in milliseconds
 760      */
 761     static native void performOnMainThreadAfterDelay(Runnable r, long delay);
 762 
 763 // DnD support
 764 
 765     @Override
 766     public DragSourceContextPeer createDragSourceContextPeer(
 767             DragGestureEvent dge) throws InvalidDnDOperationException {
 768         final LightweightFrame f = SunToolkit.getLightweightFrame(dge.getComponent());
 769         if (f != null) {
 770             return f.createDragSourceContextPeer(dge);
 771         }
 772 
 773         return CDragSourceContextPeer.createDragSourceContextPeer(dge);
 774     }
 775 
 776     @Override
 777     @SuppressWarnings(&quot;unchecked&quot;)
 778     public &lt;T extends DragGestureRecognizer&gt; T createDragGestureRecognizer(
 779             Class&lt;T&gt; abstractRecognizerClass, DragSource ds, Component c,
 780             int srcActions, DragGestureListener dgl) {
 781         final LightweightFrame f = SunToolkit.getLightweightFrame(c);
 782         if (f != null) {
 783             return f.createDragGestureRecognizer(abstractRecognizerClass, ds, c, srcActions, dgl);
 784         }
 785 
 786         DragGestureRecognizer dgr = null;
 787 
 788         // Create a new mouse drag gesture recognizer if we have a class match:
 789         if (MouseDragGestureRecognizer.class.equals(abstractRecognizerClass))
 790             dgr = new CMouseDragGestureRecognizer(ds, c, srcActions, dgl);
 791 
 792         return (T)dgr;
 793     }
 794 
 795     @Override
 796     protected PlatformDropTarget createDropTarget(DropTarget dropTarget,
 797                                                   Component component,
 798                                                   LWComponentPeer&lt;?, ?&gt; peer) {
 799         return new CDropTarget(dropTarget, component, peer);
 800     }
 801 
 802     // InputMethodSupport Method
 803     /**
 804      * Returns the default keyboard locale of the underlying operating system
 805      */
 806     @Override
 807     public Locale getDefaultKeyboardLocale() {
 808         Locale locale = CInputMethod.getNativeLocale();
 809 
 810         if (locale == null) {
 811             return super.getDefaultKeyboardLocale();
 812         }
 813 
 814         return locale;
 815     }
 816 
 817     public static boolean isLocaleUSInternationalPC(Locale locale) {
 818         return (locale != null ?
 819             locale.toString().equals(&quot;_US_UserDefined_15000&quot;) : false);
 820     }
 821 
 822     public static boolean isCharModifierKeyInUSInternationalPC(char ch) {
 823         // 5 characters: APOSTROPHE, QUOTATION MARK, ACCENT GRAVE, SMALL TILDE,
 824         // CIRCUMFLEX ACCENT
 825         final char[] modifierKeys = {&#39;\&#39;&#39;, &#39;&quot;&#39;, &#39;`&#39;, &#39;\u02DC&#39;, &#39;\u02C6&#39;};
 826         for (char modKey : modifierKeys) {
 827             if (modKey == ch) {
 828                 return true;
 829             }
 830         }
 831         return false;
 832     }
 833 
 834     @Override
 835     public InputMethodDescriptor getInputMethodAdapterDescriptor() {
 836         if (sInputMethodDescriptor == null)
 837             sInputMethodDescriptor = new CInputMethodDescriptor();
 838 
 839         return sInputMethodDescriptor;
 840     }
 841 
 842     /**
 843      * Returns a map of visual attributes for thelevel description
 844      * of the given input method highlight, or null if no mapping is found.
 845      * The style field of the input method highlight is ignored. The map
 846      * returned is unmodifiable.
 847      * @param highlight input method highlight
 848      * @return style attribute map, or null
 849      * @since 1.3
 850      */
 851     @Override
 852     public Map&lt;TextAttribute, ?&gt; mapInputMethodHighlight(InputMethodHighlight highlight) {
 853         return CInputMethod.mapInputMethodHighlight(highlight);
 854     }
 855 
 856     /**
 857      * Returns key modifiers used by Swing to set up a focus accelerator key
 858      * stroke.
 859      */
 860     @Override
 861     @SuppressWarnings(&quot;deprecation&quot;)
 862     public int getFocusAcceleratorKeyMask() {
 863         return InputEvent.CTRL_MASK | InputEvent.ALT_MASK;
 864     }
 865 
 866     /**
 867      * Tests whether specified key modifiers mask can be used to enter a
 868      * printable character.
 869      */
 870     @Override
 871     @SuppressWarnings(&quot;deprecation&quot;)
 872     public boolean isPrintableCharacterModifiersMask(int mods) {
 873         return ((mods &amp; (InputEvent.META_MASK | InputEvent.CTRL_MASK)) == 0);
 874     }
 875 
 876     /**
 877      * Returns whether popup is allowed to be shown above the task bar.
 878      */
 879     @Override
 880     public boolean canPopupOverlapTaskBar() {
 881         return false;
 882     }
 883 
 884     /*
 885      * Returns true if the application (one of its windows) owns keyboard focus.
 886      */
 887     native boolean isApplicationActive();
 888 
 889     /**
 890      * Returns true if AWT toolkit is embedded, false otherwise.
 891      *
 892      * @return true if AWT toolkit is embedded, false otherwise
 893      */
 894     public static native boolean isEmbedded();
 895 
 896     /*
 897      * Activates application ignoring other apps.
 898      */
 899     public native void activateApplicationIgnoringOtherApps();
 900 
 901     /************************
 902      * Native methods section
 903      ************************/
 904 
 905     static native long createAWTRunLoopMediator();
 906     /**
 907      * Method to run a nested run-loop. The nested loop is spinned in the javaRunLoop mode, so selectors sent
 908      * by [JNFRunLoop performOnMainThreadWaiting] are processed.
 909      * @param mediator a native pointer to the mediator object created by createAWTRunLoopMediator
 910      * @param processEvents if true - dispatches event while in the nested loop. Used in DnD.
 911      *                      Additional attention is needed when using this feature as we short-circuit normal event
 912      *                      processing which could break Appkit.
 913      *                      (One known example is when the window is resized with the mouse)
 914      *
 915      *                      if false - all events come after exit form the nested loop
 916      */
 917     static void doAWTRunLoop(long mediator, boolean processEvents) {
 918         doAWTRunLoopImpl(mediator, processEvents, inAWT);
 919     }
 920     private static native void doAWTRunLoopImpl(long mediator, boolean processEvents, boolean inAWT);
 921     static native void stopAWTRunLoop(long mediator);
 922 
 923     private native boolean nativeSyncQueue(long timeout);
 924 
 925     /**
 926      * Just spin a single empty block synchronously.
 927      */
 928     static native void flushNativeSelectors();
 929 
 930     @Override
 931     public Clipboard createPlatformClipboard() {
 932         return new CClipboard(&quot;System&quot;);
 933     }
 934 
 935     @Override
 936     public boolean isModalExclusionTypeSupported(Dialog.ModalExclusionType exclusionType) {
 937         return (exclusionType == null) ||
 938             (exclusionType == Dialog.ModalExclusionType.NO_EXCLUDE) ||
 939             (exclusionType == Dialog.ModalExclusionType.APPLICATION_EXCLUDE) ||
 940             (exclusionType == Dialog.ModalExclusionType.TOOLKIT_EXCLUDE);
 941     }
 942 
 943     @Override
 944     public boolean isModalityTypeSupported(Dialog.ModalityType modalityType) {
 945         //TODO: FileDialog blocks excluded windows...
 946         //TODO: Test: 2 file dialogs, separate AppContexts: a) Dialog 1 blocked, shouldn&#39;t be. Frame 4 blocked (shouldn&#39;t be).
 947         return (modalityType == null) ||
 948             (modalityType == Dialog.ModalityType.MODELESS) ||
 949             (modalityType == Dialog.ModalityType.DOCUMENT_MODAL) ||
 950             (modalityType == Dialog.ModalityType.APPLICATION_MODAL) ||
 951             (modalityType == Dialog.ModalityType.TOOLKIT_MODAL);
 952     }
 953 
 954     @Override
 955     public boolean isWindowShapingSupported() {
 956         return true;
 957     }
 958 
 959     @Override
 960     public boolean isWindowTranslucencySupported() {
 961         return true;
 962     }
 963 
 964     @Override
 965     public boolean isTranslucencyCapable(GraphicsConfiguration gc) {
 966         return true;
 967     }
 968 
 969     @Override
 970     public boolean isSwingBackbufferTranslucencySupported() {
 971         return true;
 972     }
 973 
 974     @Override
 975     public boolean enableInputMethodsForTextComponent() {
 976         return true;
 977     }
 978 
 979     private static URL getScaledImageURL(URL url) {
 980         try {
 981             String scaledImagePath = getScaledImageName(url.getPath());
 982             return scaledImagePath == null ? null : new URL(url.getProtocol(),
 983                     url.getHost(), url.getPort(), scaledImagePath);
 984         } catch (MalformedURLException e) {
 985             return null;
 986         }
 987     }
 988 
 989     private static String getScaledImageName(String path) {
 990         if (!isValidPath(path)) {
 991             return null;
 992         }
 993 
 994         int slash = path.lastIndexOf(&#39;/&#39;);
 995         String name = (slash &lt; 0) ? path : path.substring(slash + 1);
 996 
 997         if (name.contains(&quot;@2x&quot;)) {
 998             return null;
 999         }
1000 
1001         int dot = name.lastIndexOf(&#39;.&#39;);
1002         String name2x = (dot &lt; 0) ? name + &quot;@2x&quot;
1003                 : name.substring(0, dot) + &quot;@2x&quot; + name.substring(dot);
1004         return (slash &lt; 0) ? name2x : path.substring(0, slash + 1) + name2x;
1005     }
1006 
1007     private static boolean isValidPath(String path) {
1008         return path != null &amp;&amp;
1009                 !path.isEmpty() &amp;&amp;
1010                 !path.endsWith(&quot;/&quot;) &amp;&amp;
1011                 !path.endsWith(&quot;.&quot;);
1012     }
1013 
1014     @Override
1015     protected PlatformWindow getPlatformWindowUnderMouse() {
1016         return CPlatformWindow.nativeGetTopmostPlatformWindowUnderMouse();
1017     }
1018 
1019     @Override
1020     public void updateScreenMenuBarUI() {
1021         if (AquaMenuBarUI.getScreenMenuBarProperty())  {
1022             UIManager.put(&quot;MenuBarUI&quot;, &quot;com.apple.laf.AquaMenuBarUI&quot;);
1023         } else {
1024             UIManager.put(&quot;MenuBarUI&quot;, null);
1025         }
1026     }
1027 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
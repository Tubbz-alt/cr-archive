<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/unix/classes/sun/awt/X11/XToolkit.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.awt.X11;
  27 
  28 import java.awt.AWTError;
  29 import java.awt.AWTException;
  30 import java.awt.Button;
  31 import java.awt.Canvas;
  32 import java.awt.Checkbox;
  33 import java.awt.CheckboxMenuItem;
  34 import java.awt.Choice;
  35 import java.awt.Color;
  36 import java.awt.Component;
  37 import java.awt.Cursor;
  38 import java.awt.Desktop;
  39 import java.awt.Dialog;
  40 import java.awt.Dimension;
  41 import java.awt.EventQueue;
  42 import java.awt.FileDialog;
  43 import java.awt.Frame;
  44 import java.awt.GraphicsConfiguration;
  45 import java.awt.GraphicsDevice;
  46 import java.awt.GraphicsEnvironment;
  47 import java.awt.HeadlessException;
  48 import java.awt.Image;
  49 import java.awt.Insets;
  50 import java.awt.JobAttributes;
  51 import java.awt.Label;
  52 import java.awt.Menu;
  53 import java.awt.MenuBar;
  54 import java.awt.MenuItem;
  55 import java.awt.PageAttributes;
  56 import java.awt.Panel;
  57 import java.awt.Point;
  58 import java.awt.PopupMenu;
  59 import java.awt.PrintJob;
  60 import java.awt.Rectangle;
<a name="2" id="anc2"></a>
  61 import java.awt.ScrollPane;
  62 import java.awt.Scrollbar;
  63 import java.awt.SystemColor;
  64 import java.awt.SystemTray;
  65 import java.awt.Taskbar;
  66 import java.awt.TextArea;
  67 import java.awt.TextField;
  68 import java.awt.Toolkit;
  69 import java.awt.TrayIcon;
  70 import java.awt.Window;
  71 import java.awt.datatransfer.Clipboard;
  72 import java.awt.dnd.DragGestureEvent;
  73 import java.awt.dnd.DragGestureListener;
  74 import java.awt.dnd.DragGestureRecognizer;
  75 import java.awt.dnd.DragSource;
  76 import java.awt.dnd.InvalidDnDOperationException;
  77 import java.awt.dnd.MouseDragGestureRecognizer;
  78 import java.awt.dnd.peer.DragSourceContextPeer;
  79 import java.awt.event.InputEvent;
  80 import java.awt.event.KeyEvent;
  81 import java.awt.event.MouseEvent;
  82 import java.awt.font.TextAttribute;
  83 import java.awt.im.InputMethodHighlight;
  84 import java.awt.im.spi.InputMethodDescriptor;
  85 import java.awt.peer.ButtonPeer;
  86 import java.awt.peer.CanvasPeer;
  87 import java.awt.peer.CheckboxMenuItemPeer;
  88 import java.awt.peer.CheckboxPeer;
  89 import java.awt.peer.ChoicePeer;
  90 import java.awt.peer.DesktopPeer;
  91 import java.awt.peer.DialogPeer;
  92 import java.awt.peer.FileDialogPeer;
  93 import java.awt.peer.FontPeer;
  94 import java.awt.peer.FramePeer;
  95 import java.awt.peer.KeyboardFocusManagerPeer;
  96 import java.awt.peer.LabelPeer;
  97 import java.awt.peer.ListPeer;
  98 import java.awt.peer.MenuBarPeer;
  99 import java.awt.peer.MenuItemPeer;
 100 import java.awt.peer.MenuPeer;
 101 import java.awt.peer.MouseInfoPeer;
 102 import java.awt.peer.PanelPeer;
 103 import java.awt.peer.PopupMenuPeer;
 104 import java.awt.peer.RobotPeer;
 105 import java.awt.peer.ScrollPanePeer;
 106 import java.awt.peer.ScrollbarPeer;
 107 import java.awt.peer.SystemTrayPeer;
 108 import java.awt.peer.TaskbarPeer;
 109 import java.awt.peer.TextAreaPeer;
 110 import java.awt.peer.TextFieldPeer;
 111 import java.awt.peer.TrayIconPeer;
 112 import java.awt.peer.WindowPeer;
 113 import java.beans.PropertyChangeListener;
 114 import java.security.AccessController;
 115 import java.security.PrivilegedAction;
 116 import java.util.ArrayList;
 117 import java.util.Collection;
 118 import java.util.HashMap;
 119 import java.util.Iterator;
 120 import java.util.LinkedList;
 121 import java.util.Map;
 122 import java.util.NoSuchElementException;
 123 import java.util.Properties;
 124 import java.util.Set;
 125 import java.util.SortedMap;
 126 import java.util.TreeMap;
 127 import java.util.Vector;
 128 
 129 import javax.swing.LookAndFeel;
 130 import javax.swing.UIDefaults;
 131 
 132 import sun.awt.AWTAccessor;
 133 import sun.awt.AWTPermissions;
 134 import sun.awt.AppContext;
 135 import sun.awt.DisplayChangedListener;
 136 import sun.awt.LightweightFrame;
 137 import sun.awt.SunToolkit;
 138 import sun.awt.UNIXToolkit;
 139 import sun.awt.X11GraphicsConfig;
 140 import sun.awt.X11GraphicsDevice;
 141 import sun.awt.X11GraphicsEnvironment;
 142 import sun.awt.XSettings;
 143 import sun.awt.datatransfer.DataTransferer;
 144 import sun.awt.util.PerformanceLogger;
 145 import sun.awt.util.ThreadGroupUtils;
 146 import sun.font.FontConfigManager;
 147 import sun.java2d.SunGraphicsEnvironment;
 148 import sun.print.PrintJob2D;
 149 import sun.security.action.GetBooleanAction;
 150 import sun.security.action.GetPropertyAction;
 151 import sun.util.logging.PlatformLogger;
 152 
 153 import static sun.awt.X11.XlibUtil.scaleDown;
 154 
 155 public final class XToolkit extends UNIXToolkit implements Runnable {
 156     private static final PlatformLogger log = PlatformLogger.getLogger(&quot;sun.awt.X11.XToolkit&quot;);
 157     private static final PlatformLogger eventLog = PlatformLogger.getLogger(&quot;sun.awt.X11.event.XToolkit&quot;);
 158     private static final PlatformLogger timeoutTaskLog = PlatformLogger.getLogger(&quot;sun.awt.X11.timeoutTask.XToolkit&quot;);
 159     private static final PlatformLogger keyEventLog = PlatformLogger.getLogger(&quot;sun.awt.X11.kye.XToolkit&quot;);
 160     private static final PlatformLogger backingStoreLog = PlatformLogger.getLogger(&quot;sun.awt.X11.backingStore.XToolkit&quot;);
 161 
 162     //There is 400 ms is set by default on Windows and 500 by default on KDE and GNOME.
 163     //We use the same hardcoded constant.
 164     private static final int AWT_MULTICLICK_DEFAULT_TIME = 500;
 165 
 166     static final boolean PRIMARY_LOOP = false;
 167     static final boolean SECONDARY_LOOP = true;
 168 
 169     private static String awtAppClassName = null;
 170 
 171     // the system clipboard - CLIPBOARD selection
 172     XClipboard clipboard;
 173     // the system selection - PRIMARY selection
 174     XClipboard selection;
 175 
 176     // Dynamic Layout Resize client code setting
 177     protected static boolean dynamicLayoutSetting = false;
 178 
 179     //Is it allowed to generate events assigned to extra mouse buttons.
 180     //Set to true by default.
 181     private static boolean areExtraMouseButtonsEnabled = true;
 182 
 183     /**
 184      * True when the x settings have been loaded.
 185      */
 186     private boolean loadedXSettings;
 187 
 188     /**
 189     * XSETTINGS for the default screen.
 190      * &lt;p&gt;
 191      */
 192     private XSettings xs;
 193 
 194     private FontConfigManager fcManager = new FontConfigManager();
 195 
 196     static int arrowCursor;
 197     static TreeMap&lt;Long, XBaseWindow&gt; winMap = new TreeMap&lt;&gt;();
 198     static HashMap&lt;Object, Object&gt; specialPeerMap = new HashMap&lt;&gt;();
 199     static HashMap&lt;Long, Collection&lt;XEventDispatcher&gt;&gt; winToDispatcher = new HashMap&lt;&gt;();
 200     static UIDefaults uidefaults;
 201     static final X11GraphicsEnvironment localEnv;
 202     private static final X11GraphicsDevice device;
 203     private static final long display;
 204     static int awt_multiclick_time;
 205     static boolean securityWarningEnabled;
 206 
 207     /**
 208      * Dimensions of default virtual screen in pixels. These values are used to
 209      * limit the maximum size of the window.
 210      */
 211     private static volatile int maxWindowWidthInPixels = -1;
 212     private static volatile int maxWindowHeightInPixels = -1;
 213 
 214     static long awt_defaultFg; // Pixel
 215     private static XMouseInfoPeer xPeer;
 216 
 217     /**
 218      * Should we check &quot;_NET_WM_STRUT/_NET_WM_STRUT_PARTIAL&quot; during insets
 219      * calculation.
 220      */
 221     private static Boolean checkSTRUT;
 222 
 223     static {
 224         initSecurityWarning();
 225         if (GraphicsEnvironment.isHeadless()) {
 226             localEnv = null;
 227             device = null;
 228             display = 0;
 229         } else {
 230             localEnv = (X11GraphicsEnvironment) GraphicsEnvironment
 231                 .getLocalGraphicsEnvironment();
 232             device = (X11GraphicsDevice) localEnv.getDefaultScreenDevice();
 233             display = device.getDisplay();
 234             setupModifierMap();
 235             initIDs();
 236             setBackingStoreType();
 237         }
 238     }
 239 
 240     /*
 241      * Return (potentially) platform specific display timeout for the
 242      * tray icon
 243      */
 244     static native long getTrayIconDisplayTimeout();
 245 
 246     private static native void initIDs();
 247     static native void waitForEvents(long nextTaskTime);
 248     static Thread toolkitThread;
 249     static boolean isToolkitThread() {
 250         return Thread.currentThread() == toolkitThread;
 251     }
 252 
 253     static void initSecurityWarning() {
 254         // Enable warning only for internal builds
 255         String runtime = AccessController.doPrivileged(
 256                              new GetPropertyAction(&quot;java.runtime.version&quot;));
 257         securityWarningEnabled = (runtime != null &amp;&amp; runtime.contains(&quot;internal&quot;));
 258     }
 259 
 260     static boolean isSecurityWarningEnabled() {
 261         return securityWarningEnabled;
 262     }
 263 
 264     static native void awt_output_flush();
 265 
 266     static void  awtFUnlock() {
 267         awtUnlock();
 268         awt_output_flush();
 269     }
 270 
 271 
 272     private native void nativeLoadSystemColors(int[] systemColors);
 273 
 274     static UIDefaults getUIDefaults() {
 275         if (uidefaults == null) {
 276             initUIDefaults();
 277         }
 278         return uidefaults;
 279     }
 280 
 281     @Override
 282     public void loadSystemColors(int[] systemColors) {
 283         nativeLoadSystemColors(systemColors);
 284         MotifColorUtilities.loadSystemColors(systemColors);
 285     }
 286 
 287 
 288 
 289     static void initUIDefaults() {
 290         try {
 291             // Load Defaults from MotifLookAndFeel
 292 
 293             // This dummy load is necessary to get SystemColor initialized. !!!!!!
 294             Color c = SystemColor.text;
 295 
 296             LookAndFeel lnf = new XAWTLookAndFeel();
 297             uidefaults = lnf.getDefaults();
 298         }
 299         catch (Exception e)
 300         {
 301             e.printStackTrace();
 302         }
 303     }
 304 
 305     /**
 306      * Returns the X11 Display of the default screen device.
 307      *
 308      * @return X11 Display
 309      * @throws AWTError thrown if local GraphicsEnvironment is null, which
 310      *         means we are in the headless environment
 311      */
 312     public static long getDisplay() {
 313         if (localEnv == null) {
 314             throw new AWTError(&quot;Local GraphicsEnvironment must not be null&quot;);
 315         }
 316         return display;
 317     }
 318 
 319     public static long getDefaultRootWindow() {
 320         awtLock();
 321         try {
 322             long res = XlibWrapper.RootWindow(XToolkit.getDisplay(),
 323                 XlibWrapper.DefaultScreen(XToolkit.getDisplay()));
 324 
 325             if (res == 0) {
 326                throw new IllegalStateException(&quot;Root window must not be null&quot;);
 327             }
 328             return res;
 329         } finally {
 330             awtUnlock();
 331         }
 332     }
 333 
 334     void init() {
 335         awtLock();
 336         try {
 337             XlibWrapper.XSupportsLocale();
 338             if (XlibWrapper.XSetLocaleModifiers(&quot;&quot;) == null) {
 339                 log.finer(&quot;X locale modifiers are not supported, using default&quot;);
 340             }
 341             tryXKB();
 342 
 343             AwtScreenData defaultScreen = new AwtScreenData(XToolkit.getDefaultScreenData());
 344             awt_defaultFg = defaultScreen.get_blackpixel();
 345 
 346             arrowCursor = XlibWrapper.XCreateFontCursor(XToolkit.getDisplay(),
 347                 XCursorFontConstants.XC_arrow);
 348             final String extraButtons = &quot;sun.awt.enableExtraMouseButtons&quot;;
 349             AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
 350                 areExtraMouseButtonsEnabled =
 351                     Boolean.parseBoolean(System.getProperty(extraButtons, &quot;true&quot;));
 352                 //set system property if not yet assigned
 353                 System.setProperty(extraButtons, &quot;&quot;+areExtraMouseButtonsEnabled);
 354                 return null;
 355             });
 356             // Detect display mode changes
 357             XlibWrapper.XSelectInput(XToolkit.getDisplay(), XToolkit.getDefaultRootWindow(), XConstants.StructureNotifyMask);
 358             XToolkit.addEventDispatcher(XToolkit.getDefaultRootWindow(), new XEventDispatcher() {
 359                 @Override
 360                 public void dispatchEvent(XEvent ev) {
 361                     if (ev.get_type() == XConstants.ConfigureNotify) {
 362                         awtUnlock();
 363                         try {
 364                             ((X11GraphicsEnvironment)GraphicsEnvironment.
 365                              getLocalGraphicsEnvironment()).
 366                                 displayChanged();
 367                         } finally {
 368                             awtLock();
 369                         }
 370                     }
 371                 }
 372             });
 373         } finally {
 374             awtUnlock();
 375         }
 376         PrivilegedAction&lt;Void&gt; a = () -&gt; {
 377             Runnable r = () -&gt; {
 378                 XSystemTrayPeer peer = XSystemTrayPeer.getPeerInstance();
 379                 if (peer != null) {
 380                     peer.dispose();
 381                 }
 382                 if (xs != null) {
 383                     ((XAWTXSettings)xs).dispose();
 384                 }
 385                 freeXKB();
 386                 if (log.isLoggable(PlatformLogger.Level.FINE)) {
 387                     dumpPeers();
 388                 }
 389             };
 390             String name = &quot;XToolkt-Shutdown-Thread&quot;;
 391             Thread shutdownThread = new Thread(
 392                     ThreadGroupUtils.getRootThreadGroup(), r, name, 0, false);
 393             shutdownThread.setContextClassLoader(null);
 394             Runtime.getRuntime().addShutdownHook(shutdownThread);
 395             return null;
 396         };
 397         AccessController.doPrivileged(a);
 398     }
 399 
 400     static String getCorrectXIDString(String val) {
 401         if (val != null) {
 402             return val.replace(&#39;.&#39;, &#39;-&#39;);
 403         } else {
 404             return val;
 405         }
 406     }
 407 
 408     static native String getEnv(String key);
 409 
 410 
 411     static String getAWTAppClassName() {
 412         return awtAppClassName;
 413     }
 414 
 415     public XToolkit() {
 416         super();
 417         if (PerformanceLogger.loggingEnabled()) {
 418             PerformanceLogger.setTime(&quot;XToolkit construction&quot;);
 419         }
 420 
 421         if (!GraphicsEnvironment.isHeadless()) {
 422             String mainClassName = null;
 423 
 424             StackTraceElement[] trace = (new Throwable()).getStackTrace();
 425             int bottom = trace.length - 1;
 426             if (bottom &gt;= 0) {
 427                 mainClassName = trace[bottom].getClassName();
 428             }
 429             if (mainClassName == null || mainClassName.isEmpty()) {
 430                 mainClassName = &quot;AWT&quot;;
 431             }
 432             awtAppClassName = getCorrectXIDString(mainClassName);
 433 
 434             init();
 435             XWM.init();
 436 
 437             toolkitThread = AccessController.doPrivileged((PrivilegedAction&lt;Thread&gt;) () -&gt; {
 438                 String name = &quot;AWT-XAWT&quot;;
 439                 Thread thread = new Thread(
 440                         ThreadGroupUtils.getRootThreadGroup(), this, name,
 441                         0, false);
 442                 thread.setContextClassLoader(null);
 443                 thread.setPriority(Thread.NORM_PRIORITY + 1);
 444                 thread.setDaemon(true);
 445                 return thread;
 446             });
 447             toolkitThread.start();
 448         }
 449     }
 450 
 451     @Override
 452     public ButtonPeer createButton(Button target) {
 453         ButtonPeer peer = new XButtonPeer(target);
 454         targetCreatedPeer(target, peer);
 455         return peer;
 456     }
 457 
 458     @Override
 459     public FramePeer createLightweightFrame(LightweightFrame target) {
 460         FramePeer peer = new XLightweightFramePeer(target);
 461         targetCreatedPeer(target, peer);
 462         return peer;
 463     }
 464 
 465     @Override
 466     public FramePeer createFrame(Frame target) {
 467         FramePeer peer = new XFramePeer(target);
 468         targetCreatedPeer(target, peer);
 469         return peer;
 470     }
 471 
 472     static void addToWinMap(long window, XBaseWindow xwin)
 473     {
 474         synchronized(winMap) {
 475             winMap.put(Long.valueOf(window),xwin);
 476         }
 477     }
 478 
 479     static void removeFromWinMap(long window, XBaseWindow xwin) {
 480         synchronized(winMap) {
 481             winMap.remove(Long.valueOf(window));
 482         }
 483     }
 484     static XBaseWindow windowToXWindow(long window) {
 485         synchronized(winMap) {
 486             return winMap.get(Long.valueOf(window));
 487         }
 488     }
 489 
 490     static void addEventDispatcher(long window, XEventDispatcher dispatcher) {
 491         synchronized(winToDispatcher) {
 492             Long key = Long.valueOf(window);
 493             Collection&lt;XEventDispatcher&gt; dispatchers = winToDispatcher.get(key);
 494             if (dispatchers == null) {
 495                 dispatchers = new Vector&lt;&gt;();
 496                 winToDispatcher.put(key, dispatchers);
 497             }
 498             dispatchers.add(dispatcher);
 499         }
 500     }
 501     static void removeEventDispatcher(long window, XEventDispatcher dispatcher) {
 502         synchronized(winToDispatcher) {
 503             Long key = Long.valueOf(window);
 504             Collection&lt;XEventDispatcher&gt; dispatchers = winToDispatcher.get(key);
 505             if (dispatchers != null) {
 506                 dispatchers.remove(dispatcher);
 507             }
 508         }
 509     }
 510 
 511     private Point lastCursorPos;
 512 
 513     /**
 514      * Returns whether there is last remembered cursor position.  The
 515      * position is remembered from X mouse events on our peers.  The
 516      * position is stored in {@code p}.
 517      * @return true, if there is remembered last cursor position,
 518      * false otherwise
 519      */
 520     boolean getLastCursorPos(Point p) {
 521         awtLock();
 522         try {
 523             if (lastCursorPos == null) {
 524                 return false;
 525             }
 526             p.setLocation(lastCursorPos);
 527             return true;
 528         } finally {
 529             awtUnlock();
 530         }
 531     }
 532 
 533     private void processGlobalMotionEvent(XEvent e, XBaseWindow win) {
 534         // Only our windows guaranteely generate MotionNotify, so we
 535         // should track enter/leave, to catch the moment when to
 536         // switch to XQueryPointer
 537         if (e.get_type() == XConstants.MotionNotify) {
 538             XMotionEvent ev = e.get_xmotion();
 539             awtLock();
 540             try {
 541                 if (lastCursorPos == null) {
 542                     lastCursorPos = new Point(win.scaleDown(ev.get_x_root()),
 543                                               win.scaleDown(ev.get_y_root()));
 544                 } else {
 545                     lastCursorPos.setLocation(win.scaleDown(ev.get_x_root()),
 546                                               win.scaleDown(ev.get_y_root()));
 547                 }
 548             } finally {
 549                 awtUnlock();
 550             }
 551         } else if (e.get_type() == XConstants.LeaveNotify) {
 552             // Leave from our window
 553             awtLock();
 554             try {
 555                 lastCursorPos = null;
 556             } finally {
 557                 awtUnlock();
 558             }
 559         } else if (e.get_type() == XConstants.EnterNotify) {
 560             // Entrance into our window
 561             XCrossingEvent ev = e.get_xcrossing();
 562             awtLock();
 563             try {
 564                 if (lastCursorPos == null) {
 565                     lastCursorPos = new Point(win.scaleDown(ev.get_x_root()),
 566                                               win.scaleDown(ev.get_y_root()));
 567                 } else {
 568                     lastCursorPos.setLocation(win.scaleDown(ev.get_x_root()),
 569                                               win.scaleDown(ev.get_y_root()));
 570                 }
 571             } finally {
 572                 awtUnlock();
 573             }
 574         }
 575     }
 576 
 577     public interface XEventListener {
 578         public void eventProcessed(XEvent e);
 579     }
 580 
 581     private Collection&lt;XEventListener&gt; listeners = new LinkedList&lt;XEventListener&gt;();
 582 
 583     public void addXEventListener(XEventListener listener) {
 584         synchronized (listeners) {
 585             listeners.add(listener);
 586         }
 587     }
 588 
 589     private void notifyListeners(XEvent xev) {
 590         synchronized (listeners) {
 591             if (listeners.size() == 0) return;
 592 
 593             XEvent copy = xev.clone();
 594             try {
 595                 for (XEventListener listener : listeners) {
 596                     listener.eventProcessed(copy);
 597                 }
 598             } finally {
 599                 copy.dispose();
 600             }
 601         }
 602     }
 603 
 604     private void dispatchEvent(XEvent ev) {
 605         final XAnyEvent xany = ev.get_xany();
 606 
 607         XBaseWindow baseWindow = windowToXWindow(xany.get_window());
 608         if (baseWindow != null &amp;&amp; (ev.get_type() == XConstants.MotionNotify
 609                 || ev.get_type() == XConstants.EnterNotify
 610                 || ev.get_type() == XConstants.LeaveNotify)) {
 611             processGlobalMotionEvent(ev, baseWindow);
 612         }
 613 
 614         if( ev.get_type() == XConstants.MappingNotify ) {
 615             // The &#39;window&#39; field in this event is unused.
 616             // This application itself does nothing to initiate such an event
 617             // (no calls of XChangeKeyboardMapping etc.).
 618             // SunRay server sends this event to the application once on every
 619             // keyboard (not just layout) change which means, quite seldom.
 620             XlibWrapper.XRefreshKeyboardMapping(ev.pData);
 621             resetKeyboardSniffer();
 622             setupModifierMap();
 623         }
 624         XBaseWindow.dispatchToWindow(ev);
 625 
 626         Collection&lt;XEventDispatcher&gt; dispatchers = null;
 627         synchronized(winToDispatcher) {
 628             Long key = Long.valueOf(xany.get_window());
 629             dispatchers = winToDispatcher.get(key);
 630             if (dispatchers != null) { // Clone it to avoid synchronization during dispatching
 631                 dispatchers = new Vector&lt;&gt;(dispatchers);
 632             }
 633         }
 634         if (dispatchers != null) {
 635             Iterator&lt;XEventDispatcher&gt; iter = dispatchers.iterator();
 636             while (iter.hasNext()) {
 637                 XEventDispatcher disp = iter.next();
 638                 disp.dispatchEvent(ev);
 639             }
 640         }
 641         notifyListeners(ev);
 642     }
 643 
 644     static void processException(Throwable thr) {
 645         if (log.isLoggable(PlatformLogger.Level.WARNING)) {
 646             log.warning(&quot;Exception on Toolkit thread&quot;, thr);
 647         }
 648     }
 649 
 650     static native void awt_toolkit_init();
 651 
 652     @Override
 653     public void run() {
 654         awt_toolkit_init();
 655         run(PRIMARY_LOOP);
 656     }
 657 
 658     public void run(boolean loop)
 659     {
 660         XEvent ev = new XEvent();
 661         while(true) {
 662             // Fix for 6829923: we should gracefully handle toolkit thread interruption
 663             if (Thread.currentThread().isInterrupted()) {
 664                 // We expect interruption from the AppContext.dispose() method only.
 665                 // If the thread is interrupted from another place, let&#39;s skip it
 666                 // for compatibility reasons. Probably some time later we&#39;ll remove
 667                 // the check for AppContext.isDisposed() and will unconditionally
 668                 // break the loop here.
 669                 if (AppContext.getAppContext().isDisposed()) {
 670                     break;
 671                 }
 672             }
 673             awtLock();
 674             try {
 675                 if (loop == SECONDARY_LOOP) {
 676                     // In the secondary loop we may have already acquired awt_lock
 677                     // several times, so waitForEvents() might be unable to release
 678                     // the awt_lock and this causes lock up.
 679                     // For now, we just avoid waitForEvents in the secondary loop.
 680                     if (!XlibWrapper.XNextSecondaryLoopEvent(getDisplay(),ev.pData)) {
 681                         break;
 682                     }
 683                 } else {
 684                     callTimeoutTasks();
 685                     // If no events are queued, waitForEvents() causes calls to
 686                     // awtUnlock(), awtJNI_ThreadYield, poll, awtLock(),
 687                     // so it spends most of its time in poll, without holding the lock.
 688                     while ((XlibWrapper.XEventsQueued(getDisplay(), XConstants.QueuedAfterReading) == 0) &amp;&amp;
 689                            (XlibWrapper.XEventsQueued(getDisplay(), XConstants.QueuedAfterFlush) == 0)) {
 690                         callTimeoutTasks();
 691                         waitForEvents(getNextTaskTime());
 692                     }
 693                     XlibWrapper.XNextEvent(getDisplay(),ev.pData);
 694                 }
 695 
 696                 if (ev.get_type() != XConstants.NoExpose) {
 697                     eventNumber++;
 698                 }
 699                 if (awt_UseXKB_Calls &amp;&amp; ev.get_type() ==  awt_XKBBaseEventCode) {
 700                     processXkbChanges(ev);
 701                 }
 702 
 703                 if (XDropTargetEventProcessor.processEvent(ev) ||
 704                     XDragSourceContextPeer.processEvent(ev)) {
 705                     continue;
 706                 }
 707 
 708                 if (eventLog.isLoggable(PlatformLogger.Level.FINER)) {
 709                     eventLog.finer(&quot;{0}&quot;, ev);
 710                 }
 711 
 712                 // Check if input method consumes the event
 713                 long w = 0;
 714                 if (windowToXWindow(ev.get_xany().get_window()) != null) {
 715                     Component owner =
 716                         XKeyboardFocusManagerPeer.getInstance().getCurrentFocusOwner();
 717                     if (owner != null) {
 718                         XWindow ownerWindow = AWTAccessor.getComponentAccessor().getPeer(owner);
 719                         if (ownerWindow != null) {
 720                             w = ownerWindow.getContentWindow();
 721                         }
 722                     }
 723                 }
 724                 if (keyEventLog.isLoggable(PlatformLogger.Level.FINE) &amp;&amp; (
 725                         ev.get_type() == XConstants.KeyPress
 726                                 || ev.get_type() == XConstants.KeyRelease)) {
 727                     keyEventLog.fine(&quot;before XFilterEvent:&quot; + ev);
 728                 }
 729                 if (XlibWrapper.XFilterEvent(ev.getPData(), w)) {
 730                     continue;
 731                 }
 732                 if (keyEventLog.isLoggable(PlatformLogger.Level.FINE) &amp;&amp; (
 733                         ev.get_type() == XConstants.KeyPress
 734                                 || ev.get_type() == XConstants.KeyRelease)) {
 735                     keyEventLog.fine(
 736                             &quot;after XFilterEvent:&quot; + ev); // IS THIS CORRECT?
 737                 }
 738 
 739                 dispatchEvent(ev);
 740             } catch (ThreadDeath td) {
 741                 XBaseWindow.ungrabInput();
 742                 return;
 743             } catch (Throwable thr) {
 744                 XBaseWindow.ungrabInput();
 745                 processException(thr);
 746             } finally {
 747                 awtUnlock();
 748             }
 749         }
 750     }
 751 
 752     /**
 753      * Listener installed to detect display changes.
 754      */
 755     private static final DisplayChangedListener displayChangedHandler =
 756             new DisplayChangedListener() {
 757                 @Override
 758                 public void displayChanged() {
 759                     // 7045370: Reset the cached values
 760                     XToolkit.maxWindowWidthInPixels = -1;
 761                     XToolkit.maxWindowHeightInPixels = -1;
 762                 }
 763 
 764                 @Override
 765                 public void paletteChanged() {
 766                 }
 767             };
 768 
 769     static {
 770         GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
 771         if (ge instanceof SunGraphicsEnvironment) {
 772             ((SunGraphicsEnvironment) ge).addDisplayChangedListener(
 773                     displayChangedHandler);
 774         }
 775     }
 776 
 777     private static void initScreenSize() {
 778         if (maxWindowWidthInPixels == -1 || maxWindowHeightInPixels == -1) {
 779             awtLock();
 780             try {
 781                 XWindowAttributes pattr = new XWindowAttributes();
 782                 try {
 783                     XlibWrapper.XGetWindowAttributes(XToolkit.getDisplay(),
 784                                                      XToolkit.getDefaultRootWindow(),
 785                                                      pattr.pData);
 786                     maxWindowWidthInPixels = pattr.get_width();
 787                     maxWindowHeightInPixels = pattr.get_height();
 788                 } finally {
 789                     pattr.dispose();
 790                 }
 791             } finally {
 792                 awtUnlock();
 793             }
 794         }
 795     }
 796 
 797     static int getMaxWindowWidthInPixels() {
 798         initScreenSize();
 799         return maxWindowWidthInPixels;
 800     }
 801 
 802     static int getMaxWindowHeightInPixels() {
 803         initScreenSize();
 804         return maxWindowHeightInPixels;
 805     }
 806 
 807     private static Rectangle getWorkArea(long root, int scale)
 808     {
 809         XAtom XA_NET_WORKAREA = XAtom.get(&quot;_NET_WORKAREA&quot;);
 810 
 811         long native_ptr = Native.allocateLongArray(4);
 812         try
 813         {
 814             boolean workareaPresent = XA_NET_WORKAREA.getAtomData(root,
 815                 XAtom.XA_CARDINAL, native_ptr, 4);
 816             if (workareaPresent)
 817             {
 818                 int rootX = (int)Native.getLong(native_ptr, 0);
 819                 int rootY = (int)Native.getLong(native_ptr, 1);
 820                 int rootWidth = (int)Native.getLong(native_ptr, 2);
 821                 int rootHeight = (int)Native.getLong(native_ptr, 3);
 822 
 823                 return new Rectangle(scaleDown(rootX, scale),
 824                                      scaleDown(rootY, scale),
 825                                      scaleDown(rootWidth, scale),
 826                                      scaleDown(rootHeight, scale));
 827             }
 828         }
 829         finally
 830         {
 831             XlibWrapper.unsafe.freeMemory(native_ptr);
 832         }
 833 
 834         return null;
 835     }
 836 
 837     /*
 838      * If the current window manager supports _NET protocol then the screen
 839      * insets are calculated using _NET_WORKAREA property of the root window.
 840      * &lt;p&gt;
 841      * Note that _NET_WORKAREA is a rectangular area and it does not work
 842      * well in the Xinerama mode.
 843      * &lt;p&gt;
 844      * We will trust the part of this rectangular area only if it starts at the
 845      * requested graphics configuration. Below is an example when the
 846      * _NET_WORKAREA intersects with the requested graphics configuration but
 847      * produces wrong result.
 848      *
 849      *         //&lt;-x1,y1///////
 850      *         //            // ////////////////
 851      *         //  SCREEN1   // // SCREEN2    //
 852      *         // ********** // //     x2,y2-&gt;//
 853      *         //////////////// //            //
 854      *                          ////////////////
 855      *
 856      * When two screens overlap and the first contains a dock(*****), then
 857      * _NET_WORKAREA may start at point x1,y1 and end at point x2,y2.
 858      */
 859     @Override
<a name="3" id="anc3"></a><span class="line-modified"> 860     public Insets getScreenInsets(final GraphicsConfiguration gc) {</span>
<span class="line-modified"> 861         GraphicsDevice gd = gc.getDevice();</span>
<span class="line-modified"> 862         XNETProtocol np = XWM.getWM().getNETProtocol();</span>
<span class="line-modified"> 863         if (np == null || !(gd instanceof X11GraphicsDevice) || !np.active()) {</span>

 864             return super.getScreenInsets(gc);
 865         }
 866 
 867         XToolkit.awtLock();
 868         try
 869         {
 870             X11GraphicsEnvironment x11ge = (X11GraphicsEnvironment)
 871                     GraphicsEnvironment.getLocalGraphicsEnvironment();
 872             X11GraphicsConfig x11gc = (X11GraphicsConfig) gc;
 873             long root = XlibUtil.getRootWindow(x11gc.getDevice().getScreen());
 874             int scale = x11gc.getScale();
 875             if (x11ge.runningXinerama() &amp;&amp; checkSTRUT()) {
 876                 // implementation based on _NET_WM_STRUT/_NET_WM_STRUT_PARTIAL
 877                 Rectangle rootBounds = XlibUtil.getWindowGeometry(root, scale);
 878                 Insets insets = getScreenInsetsManually(root, rootBounds,
 879                                                         gc.getBounds(), scale);
 880                 if ((insets.left | insets.top | insets.bottom | insets.right) != 0
 881                         || rootBounds == null) {
 882                     return insets;
 883                 }
 884             }
 885             Rectangle workArea = XToolkit.getWorkArea(root, scale);
 886             Rectangle screen = gc.getBounds();
 887             if (workArea != null &amp;&amp; screen.contains(workArea.getLocation())) {
 888                 workArea = workArea.intersection(screen);
 889                 int top = workArea.y - screen.y;
 890                 int left = workArea.x - screen.x;
 891                 int bottom = screen.height - workArea.height - top;
 892                 int right = screen.width - workArea.width - left;
 893                 return new Insets(top, left, bottom, right);
 894             }
 895             // Note that it is better to return zeros than inadequate values
 896             return new Insets(0, 0, 0, 0);
 897         }
 898         finally
 899         {
 900             XToolkit.awtUnlock();
 901         }
 902     }
 903 
 904     /**
 905      * Returns the value of &quot;sun.awt.X11.checkSTRUT&quot; property. Default value is
 906      * {@code false}.
 907      */
 908     private static boolean checkSTRUT() {
 909         if (checkSTRUT == null) {
 910             checkSTRUT = AccessController.doPrivileged(
 911                     new GetBooleanAction(&quot;sun.awt.X11.checkSTRUT&quot;));
 912         }
 913         return checkSTRUT;
 914     }
 915 
 916     /*
 917      * Manual calculation of screen insets: get all the windows with
 918      * _NET_WM_STRUT/_NET_WM_STRUT_PARTIAL hints and add these
 919      * hints&#39; values to screen insets.
 920      *
 921      * This method should be called under XToolkit.awtLock()
 922      *
 923      * This method is unused by default because of two reasons:
 924      *  - Iteration over windows may be extremely slow, and execution of
 925      *    getScreenInsets() can be x100 slower than in one monitor config.
 926      *  - _NET_WM_STRUT/_NET_WM_STRUT_PARTIAL are hints for the applications.
 927      *    WM should take into account these hints when &quot;_NET_WORKAREA&quot; is
 928      *    calculated, but the system panels do not necessarily contain these
 929      *    hints(Gnome 3 for example).
 930      */
 931     private Insets getScreenInsetsManually(long root, Rectangle rootBounds,
 932                                            Rectangle screenBounds, int scale)
 933     {
 934         /*
 935          * During the manual calculation of screen insets we iterate
 936          * all the X windows hierarchy starting from root window. This
 937          * constant is the max level inspected in this hierarchy.
 938          * 3 is a heuristic value: I suppose any the toolbar-like
 939          * window is a child of either root or desktop window.
 940          */
 941         final int MAX_NESTED_LEVEL = 3;
 942 
 943         XAtom XA_NET_WM_STRUT = XAtom.get(&quot;_NET_WM_STRUT&quot;);
 944         XAtom XA_NET_WM_STRUT_PARTIAL = XAtom.get(&quot;_NET_WM_STRUT_PARTIAL&quot;);
 945 
 946         Insets insets = new Insets(0, 0, 0, 0);
 947 
 948         java.util.List&lt;Object&gt; search = new LinkedList&lt;&gt;();
 949         search.add(root);
 950         search.add(0);
 951         while (!search.isEmpty())
 952         {
 953             long window = (Long)search.remove(0);
 954             int windowLevel = (Integer)search.remove(0);
 955 
 956             /*
 957              * Note that most of the modern window managers unmap
 958              * application window if it is iconified. Thus, any
 959              * _NET_WM_STRUT[_PARTIAL] hints for iconified windows
 960              * are not included to the screen insets.
 961              */
 962             if (XlibUtil.getWindowMapState(window) == XConstants.IsUnmapped)
 963             {
 964                 continue;
 965             }
 966 
 967             long native_ptr = Native.allocateLongArray(4);
 968             try
 969             {
 970                 // first, check if _NET_WM_STRUT or _NET_WM_STRUT_PARTIAL are present
 971                 // if both are set on the window, _NET_WM_STRUT_PARTIAL is used (see _NET spec)
 972                 boolean strutPresent = XA_NET_WM_STRUT_PARTIAL.getAtomData(window, XAtom.XA_CARDINAL, native_ptr, 4);
 973                 if (!strutPresent)
 974                 {
 975                     strutPresent = XA_NET_WM_STRUT.getAtomData(window, XAtom.XA_CARDINAL, native_ptr, 4);
 976                 }
 977                 if (strutPresent)
 978                 {
 979                     // second, verify that window is located on the proper screen
 980                     Rectangle windowBounds = XlibUtil.getWindowGeometry(window,
 981                                                                         scale);
 982                     if (windowLevel &gt; 1)
 983                     {
 984                         windowBounds = XlibUtil.translateCoordinates(window, root,
 985                                                                      windowBounds,
 986                                                                      scale);
 987                     }
 988                     // if _NET_WM_STRUT_PARTIAL is present, we should use its values to detect
 989                     // if the struts area intersects with screenBounds, however some window
 990                     // managers don&#39;t set this hint correctly, so we just get intersection with windowBounds
 991                     if (windowBounds != null &amp;&amp; windowBounds.intersects(screenBounds))
 992                     {
 993                         int left = scaleDown((int)Native.getLong(native_ptr, 0), scale);
 994                         int right = scaleDown((int)Native.getLong(native_ptr, 1), scale);
 995                         int top = scaleDown((int)Native.getLong(native_ptr, 2), scale);
 996                         int bottom = scaleDown((int)Native.getLong(native_ptr, 3), scale);
 997 
 998                         /*
 999                          * struts could be relative to root window bounds, so
1000                          * make them relative to the screen bounds in this case
1001                          */
1002                         left = rootBounds.x + left &gt; screenBounds.x ?
1003                                 rootBounds.x + left - screenBounds.x : 0;
1004                         right = rootBounds.x + rootBounds.width - right &lt;
1005                                 screenBounds.x + screenBounds.width ?
1006                                 screenBounds.x + screenBounds.width -
1007                                 (rootBounds.x + rootBounds.width - right) : 0;
1008                         top = rootBounds.y + top &gt; screenBounds.y ?
1009                                 rootBounds.y + top - screenBounds.y : 0;
1010                         bottom = rootBounds.y + rootBounds.height - bottom &lt;
1011                                 screenBounds.y + screenBounds.height ?
1012                                 screenBounds.y + screenBounds.height -
1013                                 (rootBounds.y + rootBounds.height - bottom) : 0;
1014 
1015                         insets.left = Math.max(left, insets.left);
1016                         insets.right = Math.max(right, insets.right);
1017                         insets.top = Math.max(top, insets.top);
1018                         insets.bottom = Math.max(bottom, insets.bottom);
1019                     }
1020                 }
1021             }
1022             finally
1023             {
1024                 XlibWrapper.unsafe.freeMemory(native_ptr);
1025             }
1026 
1027             if (windowLevel &lt; MAX_NESTED_LEVEL)
1028             {
1029                 Set&lt;Long&gt; children = XlibUtil.getChildWindows(window);
1030                 for (long child : children)
1031                 {
1032                     search.add(child);
1033                     search.add(windowLevel + 1);
1034                 }
1035             }
1036         }
1037 
1038         return insets;
1039     }
1040 
1041     /*
1042      * The current implementation of disabling background erasing for
1043      * canvases is that we don&#39;t set any native background color
1044      * (with XSetWindowBackground) for the canvas window. However,
1045      * this color is set in the peer constructor - see
1046      * XWindow.postInit() for details. That&#39;s why this method from
1047      * SunToolkit is not overridden in XToolkit: it&#39;s too late to
1048      * disable background erasing :(
1049      */
1050     /*
1051     @Override
1052     public void disableBackgroundErase(Canvas canvas) {
1053         XCanvasPeer peer = (XCanvasPeer)canvas.getPeer();
1054         if (peer == null) {
1055             throw new IllegalStateException(&quot;Canvas must have a valid peer&quot;);
1056         }
1057         peer.disableBackgroundErase();
1058     }
1059     */
1060 
1061     // Need this for XMenuItemPeer.
1062     protected static Object targetToPeer(Object target) {
1063         Object p=null;
1064         if (target != null &amp;&amp; !GraphicsEnvironment.isHeadless()) {
1065             p = specialPeerMap.get(target);
1066         }
1067         if (p != null) return p;
1068         else
1069             return SunToolkit.targetToPeer(target);
1070     }
1071 
1072     // Need this for XMenuItemPeer.
1073     protected static void targetDisposedPeer(Object target, Object peer) {
1074         SunToolkit.targetDisposedPeer(target, peer);
1075     }
1076 
1077     @Override
<a name="4" id="anc4"></a><span class="line-modified">1078     public RobotPeer createRobot(GraphicsDevice screen) throws AWTException {</span>
<span class="line-modified">1079         if (screen instanceof X11GraphicsDevice) {</span>
<span class="line-added">1080             return new XRobotPeer((X11GraphicsDevice) screen);</span>
<span class="line-added">1081         }</span>
<span class="line-added">1082         return super.createRobot(screen);</span>
1083     }
1084 
<a name="5" id="anc5"></a>
1085   /*
1086      * On X, support for dynamic layout on resizing is governed by the
1087      * window manager.  If the window manager supports it, it happens
1088      * automatically.  The setter method for this property is
1089      * irrelevant on X.
1090      */
1091     @Override
1092     public void setDynamicLayout(boolean b) {
1093         dynamicLayoutSetting = b;
1094     }
1095 
1096     @Override
1097     protected boolean isDynamicLayoutSet() {
1098         return dynamicLayoutSetting;
1099     }
1100 
1101     /* Called from isDynamicLayoutActive() and from
1102      * lazilyLoadDynamicLayoutSupportedProperty()
1103      */
1104     protected boolean isDynamicLayoutSupported() {
1105         return XWM.getWM().supportsDynamicLayout();
1106     }
1107 
1108     @Override
1109     public boolean isDynamicLayoutActive() {
1110         return isDynamicLayoutSupported();
1111     }
1112 
1113     @Override
1114     public FontPeer getFontPeer(String name, int style){
1115         return new XFontPeer(name, style);
1116     }
1117 
1118     @Override
1119     public DragSourceContextPeer createDragSourceContextPeer(DragGestureEvent dge) throws InvalidDnDOperationException {
1120         final LightweightFrame f = SunToolkit.getLightweightFrame(dge.getComponent());
1121         if (f != null) {
1122             return f.createDragSourceContextPeer(dge);
1123         }
1124 
1125         return XDragSourceContextPeer.createDragSourceContextPeer(dge);
1126     }
1127 
1128     @Override
1129     @SuppressWarnings(&quot;unchecked&quot;)
1130     public &lt;T extends DragGestureRecognizer&gt; T
1131     createDragGestureRecognizer(Class&lt;T&gt; recognizerClass,
1132                     DragSource ds,
1133                     Component c,
1134                     int srcActions,
1135                     DragGestureListener dgl)
1136     {
1137         final LightweightFrame f = SunToolkit.getLightweightFrame(c);
1138         if (f != null) {
1139             return f.createDragGestureRecognizer(recognizerClass, ds, c, srcActions, dgl);
1140         }
1141 
1142         if (MouseDragGestureRecognizer.class.equals(recognizerClass))
1143             return (T)new XMouseDragGestureRecognizer(ds, c, srcActions, dgl);
1144         else
1145             return null;
1146     }
1147 
1148     @Override
1149     public CheckboxMenuItemPeer createCheckboxMenuItem(CheckboxMenuItem target) {
1150         XCheckboxMenuItemPeer peer = new XCheckboxMenuItemPeer(target);
1151         //vb157120: looks like we don&#39;t need to map menu items
1152         //in new menus implementation
1153         //targetCreatedPeer(target, peer);
1154         return peer;
1155     }
1156 
1157     @Override
1158     public MenuItemPeer createMenuItem(MenuItem target) {
1159         XMenuItemPeer peer = new XMenuItemPeer(target);
1160         //vb157120: looks like we don&#39;t need to map menu items
1161         //in new menus implementation
1162         //targetCreatedPeer(target, peer);
1163         return peer;
1164     }
1165 
1166     @Override
1167     public TextFieldPeer createTextField(TextField target) {
1168         TextFieldPeer  peer = new XTextFieldPeer(target);
1169         targetCreatedPeer(target, peer);
1170         return peer;
1171     }
1172 
1173     @Override
1174     public LabelPeer createLabel(Label target) {
1175         LabelPeer  peer = new XLabelPeer(target);
1176         targetCreatedPeer(target, peer);
1177         return peer;
1178     }
1179 
1180     @Override
1181     public ListPeer createList(java.awt.List target) {
1182         ListPeer peer = new XListPeer(target);
1183         targetCreatedPeer(target, peer);
1184         return peer;
1185     }
1186 
1187     @Override
1188     public CheckboxPeer createCheckbox(Checkbox target) {
1189         CheckboxPeer peer = new XCheckboxPeer(target);
1190         targetCreatedPeer(target, peer);
1191         return peer;
1192     }
1193 
1194     @Override
1195     public ScrollbarPeer createScrollbar(Scrollbar target) {
1196         XScrollbarPeer peer = new XScrollbarPeer(target);
1197         targetCreatedPeer(target, peer);
1198         return peer;
1199     }
1200 
1201     @Override
1202     public ScrollPanePeer createScrollPane(ScrollPane target) {
1203         XScrollPanePeer peer = new XScrollPanePeer(target);
1204         targetCreatedPeer(target, peer);
1205         return peer;
1206     }
1207 
1208     @Override
1209     public TextAreaPeer createTextArea(TextArea target) {
1210         TextAreaPeer peer = new XTextAreaPeer(target);
1211         targetCreatedPeer(target, peer);
1212         return peer;
1213     }
1214 
1215     @Override
1216     public ChoicePeer createChoice(Choice target) {
1217         XChoicePeer peer = new XChoicePeer(target);
1218         targetCreatedPeer(target, peer);
1219         return peer;
1220     }
1221 
1222     @Override
1223     public CanvasPeer createCanvas(Canvas target) {
1224         XCanvasPeer peer = (isXEmbedServerRequested() ? new XEmbedCanvasPeer(target) : new XCanvasPeer(target));
1225         targetCreatedPeer(target, peer);
1226         return peer;
1227     }
1228 
1229     @Override
1230     public PanelPeer createPanel(Panel target) {
1231         PanelPeer peer = new XPanelPeer(target);
1232         targetCreatedPeer(target, peer);
1233         return peer;
1234     }
1235 
1236     @Override
1237     public WindowPeer createWindow(Window target) {
1238         WindowPeer peer = new XWindowPeer(target);
1239         targetCreatedPeer(target, peer);
1240         return peer;
1241     }
1242 
1243     @Override
1244     public DialogPeer createDialog(Dialog target) {
1245         DialogPeer peer = new XDialogPeer(target);
1246         targetCreatedPeer(target, peer);
1247         return peer;
1248     }
1249 
1250     private static Boolean sunAwtDisableGtkFileDialogs = null;
1251 
1252     /**
1253      * Returns the value of &quot;sun.awt.disableGtkFileDialogs&quot; property. Default
1254      * value is {@code false}.
1255      */
1256     public static synchronized boolean getSunAwtDisableGtkFileDialogs() {
1257         if (sunAwtDisableGtkFileDialogs == null) {
1258             sunAwtDisableGtkFileDialogs = AccessController.doPrivileged(
1259                                               new GetBooleanAction(&quot;sun.awt.disableGtkFileDialogs&quot;));
1260         }
1261         return sunAwtDisableGtkFileDialogs.booleanValue();
1262     }
1263 
1264     @Override
1265     public FileDialogPeer createFileDialog(FileDialog target) {
1266         FileDialogPeer peer = null;
1267         // The current GtkFileChooser is available from GTK+ 2.4
1268         if (!getSunAwtDisableGtkFileDialogs() &amp;&amp;
1269                       (checkGtkVersion(2, 4, 0) || checkGtkVersion(3, 0, 0))) {
1270             peer = new GtkFileDialogPeer(target);
1271         } else {
1272             peer = new XFileDialogPeer(target);
1273         }
1274         targetCreatedPeer(target, peer);
1275         return peer;
1276     }
1277 
1278     @Override
1279     public MenuBarPeer createMenuBar(MenuBar target) {
1280         XMenuBarPeer peer = new XMenuBarPeer(target);
1281         targetCreatedPeer(target, peer);
1282         return peer;
1283     }
1284 
1285     @Override
1286     public MenuPeer createMenu(Menu target) {
1287         XMenuPeer peer = new XMenuPeer(target);
1288         //vb157120: looks like we don&#39;t need to map menu items
1289         //in new menus implementation
1290         //targetCreatedPeer(target, peer);
1291         return peer;
1292     }
1293 
1294     @Override
1295     public PopupMenuPeer createPopupMenu(PopupMenu target) {
1296         XPopupMenuPeer peer = new XPopupMenuPeer(target);
1297         targetCreatedPeer(target, peer);
1298         return peer;
1299     }
1300 
1301     @Override
1302     public synchronized MouseInfoPeer getMouseInfoPeer() {
1303         if (xPeer == null) {
1304             xPeer = new XMouseInfoPeer();
1305         }
1306         return xPeer;
1307     }
1308 
1309     public XEmbeddedFramePeer createEmbeddedFrame(XEmbeddedFrame target)
1310     {
1311         XEmbeddedFramePeer peer = new XEmbeddedFramePeer(target);
1312         targetCreatedPeer(target, peer);
1313         return peer;
1314     }
1315 
1316     XEmbedChildProxyPeer createEmbedProxy(XEmbedChildProxy target) {
1317         XEmbedChildProxyPeer peer = new XEmbedChildProxyPeer(target);
1318         targetCreatedPeer(target, peer);
1319         return peer;
1320     }
1321 
1322     @Override
1323     public KeyboardFocusManagerPeer getKeyboardFocusManagerPeer() throws HeadlessException {
1324         return XKeyboardFocusManagerPeer.getInstance();
1325     }
1326 
1327     /**
1328      * Returns a new custom cursor.
1329      */
1330     @Override
1331     public Cursor createCustomCursor(Image cursor, Point hotSpot, String name)
1332       throws IndexOutOfBoundsException {
1333         return new XCustomCursor(cursor, hotSpot, name);
1334     }
1335 
1336     @Override
1337     public TrayIconPeer createTrayIcon(TrayIcon target)
1338       throws HeadlessException, AWTException
1339     {
1340         TrayIconPeer peer = new XTrayIconPeer(target);
1341         targetCreatedPeer(target, peer);
1342         return peer;
1343     }
1344 
1345     @Override
1346     public SystemTrayPeer createSystemTray(SystemTray target) throws HeadlessException {
1347         SystemTrayPeer peer = new XSystemTrayPeer(target);
1348         return peer;
1349     }
1350 
1351     @Override
1352     public boolean isTraySupported() {
1353         XSystemTrayPeer peer = XSystemTrayPeer.getPeerInstance();
1354         if (peer != null) {
1355             return peer.isAvailable();
1356         }
1357         return false;
1358     }
1359 
1360     @Override
1361     public DataTransferer getDataTransferer() {
1362         return XDataTransferer.getInstanceImpl();
1363     }
1364 
1365     /**
1366      * Returns the supported cursor size
1367      */
1368     @Override
1369     public Dimension getBestCursorSize(int preferredWidth, int preferredHeight) {
1370         return XCustomCursor.getBestCursorSize(
1371                                                java.lang.Math.max(1,preferredWidth), java.lang.Math.max(1,preferredHeight));
1372     }
1373 
1374 
1375     @Override
1376     public int getMaximumCursorColors() {
1377         return 2;  // Black and white.
1378     }
1379 
1380     @Override
1381     public Map&lt;TextAttribute, ?&gt; mapInputMethodHighlight( InputMethodHighlight highlight) {
1382         return XInputMethod.mapInputMethodHighlight(highlight);
1383     }
1384     @Override
1385     public boolean getLockingKeyState(int key) {
1386         if (! (key == KeyEvent.VK_CAPS_LOCK || key == KeyEvent.VK_NUM_LOCK ||
1387                key == KeyEvent.VK_SCROLL_LOCK || key == KeyEvent.VK_KANA_LOCK)) {
1388             throw new IllegalArgumentException(&quot;invalid key for Toolkit.getLockingKeyState&quot;);
1389         }
1390         awtLock();
1391         try {
1392             return getModifierState( key );
1393         } finally {
1394             awtUnlock();
1395         }
1396     }
1397 
1398     @Override
1399     public  Clipboard getSystemClipboard() {
1400         SecurityManager security = System.getSecurityManager();
1401         if (security != null) {
1402             security.checkPermission(AWTPermissions.ACCESS_CLIPBOARD_PERMISSION);
1403         }
1404         synchronized (this) {
1405             if (clipboard == null) {
1406                 clipboard = new XClipboard(&quot;System&quot;, &quot;CLIPBOARD&quot;);
1407             }
1408         }
1409         return clipboard;
1410     }
1411 
1412     @Override
1413     public Clipboard getSystemSelection() {
1414         SecurityManager security = System.getSecurityManager();
1415         if (security != null) {
1416             security.checkPermission(AWTPermissions.ACCESS_CLIPBOARD_PERMISSION);
1417         }
1418         synchronized (this) {
1419             if (selection == null) {
1420                 selection = new XClipboard(&quot;Selection&quot;, &quot;PRIMARY&quot;);
1421             }
1422         }
1423         return selection;
1424     }
1425 
1426     @Override
1427     public void beep() {
1428         awtLock();
1429         try {
1430             XlibWrapper.XBell(getDisplay(), 0);
1431             XlibWrapper.XFlush(getDisplay());
1432         } finally {
1433             awtUnlock();
1434         }
1435     }
1436 
1437     @Override
1438     public PrintJob getPrintJob(final Frame frame, final String doctitle,
1439                                 final Properties props) {
1440 
1441         if (frame == null) {
1442             throw new NullPointerException(&quot;frame must not be null&quot;);
1443         }
1444 
1445         PrintJob2D printJob = new PrintJob2D(frame, doctitle, props);
1446 
1447         if (printJob.printDialog() == false) {
1448             printJob = null;
1449         }
1450         return printJob;
1451     }
1452 
1453     @Override
1454     public PrintJob getPrintJob(final Frame frame, final String doctitle,
1455                 final JobAttributes jobAttributes,
1456                 final PageAttributes pageAttributes)
1457     {
1458         if (frame == null) {
1459             throw new NullPointerException(&quot;frame must not be null&quot;);
1460         }
1461 
1462         PrintJob2D printJob = new PrintJob2D(frame, doctitle,
1463                                              jobAttributes, pageAttributes);
1464 
1465         if (printJob.printDialog() == false) {
1466             printJob = null;
1467         }
1468 
1469         return printJob;
1470     }
1471 
1472     static void XSync() {
1473         awtLock();
1474         try {
1475             XlibWrapper.XSync(getDisplay(),0);
1476         } finally {
1477             awtUnlock();
1478         }
1479     }
1480 
1481     @Override
1482     public int getScreenResolution() {
1483         long display = getDisplay();
1484         awtLock();
1485         try {
1486             return (int) ((XlibWrapper.DisplayWidth(display,
1487                 XlibWrapper.DefaultScreen(display)) * 25.4) /
1488                     XlibWrapper.DisplayWidthMM(display,
1489                 XlibWrapper.DefaultScreen(display)));
1490         } finally {
1491             awtUnlock();
1492         }
1493     }
1494 
1495     static native long getDefaultXColormap();
1496     static native long getDefaultScreenData();
1497 
1498     /**
1499      * Returns a new input method adapter descriptor for native input methods.
1500      */
1501     @Override
1502     public InputMethodDescriptor getInputMethodAdapterDescriptor() throws AWTException {
1503         return new XInputMethodDescriptor();
1504     }
1505 
1506     /**
1507      * Returns whether enableInputMethods should be set to true for peered
1508      * TextComponent instances on this platform. True by default.
1509      */
1510     @Override
1511     public boolean enableInputMethodsForTextComponent() {
1512         return true;
1513     }
1514 
1515     static int getMultiClickTime() {
1516         if (awt_multiclick_time == 0) {
1517             initializeMultiClickTime();
1518         }
1519         return awt_multiclick_time;
1520     }
1521     static void initializeMultiClickTime() {
1522         awtLock();
1523         try {
1524             try {
1525                 String multiclick_time_query = XlibWrapper.XGetDefault(XToolkit.getDisplay(), &quot;*&quot;, &quot;multiClickTime&quot;);
1526                 if (multiclick_time_query != null) {
1527                     awt_multiclick_time = (int)Long.parseLong(multiclick_time_query);
1528                 } else {
1529                     multiclick_time_query = XlibWrapper.XGetDefault(XToolkit.getDisplay(),
1530                                                                     &quot;OpenWindows&quot;, &quot;MultiClickTimeout&quot;);
1531                     if (multiclick_time_query != null) {
1532                         /* Note: OpenWindows.MultiClickTimeout is in tenths of
1533                            a second, so we need to multiply by 100 to convert to
1534                            milliseconds */
1535                         awt_multiclick_time = (int)Long.parseLong(multiclick_time_query) * 100;
1536                     } else {
1537                         awt_multiclick_time = AWT_MULTICLICK_DEFAULT_TIME;
1538                     }
1539                 }
1540             } catch (NumberFormatException nf) {
1541                 awt_multiclick_time = AWT_MULTICLICK_DEFAULT_TIME;
1542             } catch (NullPointerException npe) {
1543                 awt_multiclick_time = AWT_MULTICLICK_DEFAULT_TIME;
1544             }
1545         } finally {
1546             awtUnlock();
1547         }
1548         if (awt_multiclick_time == 0) {
1549             awt_multiclick_time = AWT_MULTICLICK_DEFAULT_TIME;
1550         }
1551     }
1552 
1553     @Override
1554     public boolean isFrameStateSupported(int state)
1555       throws HeadlessException
1556     {
1557         if (state == Frame.NORMAL || state == Frame.ICONIFIED) {
1558             return true;
1559         } else {
1560             return XWM.getWM().supportsExtendedState(state);
1561         }
1562     }
1563 
1564     static void dumpPeers() {
1565         if (log.isLoggable(PlatformLogger.Level.FINE)) {
1566             log.fine(&quot;Mapped windows:&quot;);
1567             winMap.forEach((k, v) -&gt; {
1568                 log.fine(k + &quot;-&gt;&quot; + v);
1569                 if (v instanceof XComponentPeer) {
1570                     Component target = (Component)((XComponentPeer)v).getTarget();
1571                     log.fine(&quot;\ttarget: &quot; + target);
1572                 }
1573             });
1574 
1575             SunToolkit.dumpPeers(log);
1576 
1577             log.fine(&quot;Mapped special peers:&quot;);
1578             specialPeerMap.forEach((k, v) -&gt; {
1579                 log.fine(k + &quot;-&gt;&quot; + v);
1580             });
1581 
1582             log.fine(&quot;Mapped dispatchers:&quot;);
1583             winToDispatcher.forEach((k, v) -&gt; {
1584                 log.fine(k + &quot;-&gt;&quot; + v);
1585             });
1586         }
1587     }
1588 
1589     /* Protected with awt_lock. */
1590     private static boolean initialized;
1591     private static boolean timeStampUpdated;
1592     private static long timeStamp;
1593 
1594     private static final XEventDispatcher timeFetcher =
1595     new XEventDispatcher() {
1596             @Override
1597             public void dispatchEvent(XEvent ev) {
1598                 switch (ev.get_type()) {
1599                   case XConstants.PropertyNotify:
1600                       XPropertyEvent xpe = ev.get_xproperty();
1601 
1602                       awtLock();
1603                       try {
1604                           timeStamp = xpe.get_time();
1605                           timeStampUpdated = true;
1606                           awtLockNotifyAll();
1607                       } finally {
1608                           awtUnlock();
1609                       }
1610 
1611                       break;
1612                 }
1613             }
1614         };
1615 
1616     private static XAtom _XA_JAVA_TIME_PROPERTY_ATOM;
1617 
1618     static long getCurrentServerTime() {
1619         awtLock();
1620         try {
1621             try {
1622                 if (!initialized) {
1623                     XToolkit.addEventDispatcher(XBaseWindow.getXAWTRootWindow().getWindow(),
1624                                                 timeFetcher);
1625                     _XA_JAVA_TIME_PROPERTY_ATOM = XAtom.get(&quot;_SUNW_JAVA_AWT_TIME&quot;);
1626                     initialized = true;
1627                 }
1628                 timeStampUpdated = false;
1629                 XlibWrapper.XChangeProperty(XToolkit.getDisplay(),
1630                                             XBaseWindow.getXAWTRootWindow().getWindow(),
1631                                             _XA_JAVA_TIME_PROPERTY_ATOM.getAtom(), XAtom.XA_ATOM, 32,
1632                                             XConstants.PropModeAppend,
1633                                             0, 0);
1634                 XlibWrapper.XFlush(XToolkit.getDisplay());
1635 
1636                 if (isToolkitThread()) {
1637                     XEvent event = new XEvent();
1638                     try {
1639                         XlibWrapper.XWindowEvent(XToolkit.getDisplay(),
1640                                                  XBaseWindow.getXAWTRootWindow().getWindow(),
1641                                                  XConstants.PropertyChangeMask,
1642                                                  event.pData);
1643                         timeFetcher.dispatchEvent(event);
1644                     }
1645                     finally {
1646                         event.dispose();
1647                     }
1648                 }
1649                 else {
1650                     while (!timeStampUpdated) {
1651                         awtLockWait();
1652                     }
1653                 }
1654             } catch (InterruptedException ie) {
1655             // Note: the returned timeStamp can be incorrect in this case.
1656                 if (log.isLoggable(PlatformLogger.Level.FINE)) {
1657                     log.fine(&quot;Catched exception, timeStamp may not be correct (ie = &quot; + ie + &quot;)&quot;);
1658                 }
1659             }
1660         } finally {
1661             awtUnlock();
1662         }
1663         return timeStamp;
1664     }
1665     @Override
1666     protected void initializeDesktopProperties() {
1667         desktopProperties.put(&quot;DnD.Autoscroll.initialDelay&quot;,
1668                               Integer.valueOf(50));
1669         desktopProperties.put(&quot;DnD.Autoscroll.interval&quot;,
1670                               Integer.valueOf(50));
1671         desktopProperties.put(&quot;DnD.Autoscroll.cursorHysteresis&quot;,
1672                               Integer.valueOf(5));
1673         desktopProperties.put(&quot;Shell.shellFolderManager&quot;,
1674                               &quot;sun.awt.shell.ShellFolderManager&quot;);
1675         // Don&#39;t want to call getMultiClickTime() if we are headless
1676         if (!GraphicsEnvironment.isHeadless()) {
1677             desktopProperties.put(&quot;awt.multiClickInterval&quot;,
1678                                   Integer.valueOf(getMultiClickTime()));
1679             desktopProperties.put(&quot;awt.mouse.numButtons&quot;,
1680                                   Integer.valueOf(getNumberOfButtons()));
1681             if(SunGraphicsEnvironment.isUIScaleEnabled()) {
1682                 addPropertyChangeListener(&quot;gnome.Xft/DPI&quot;, evt -&gt;
1683                                                      localEnv.displayChanged());
1684             }
1685         }
1686     }
1687 
1688     /**
1689      * This method runs through the XPointer and XExtendedPointer array.
1690      * XExtendedPointer has priority because on some systems XPointer
1691      * (which is assigned to the virtual pointer) reports the maximum
1692      * capabilities of the mouse pointer (i.e. 32 physical buttons).
1693      */
1694     private native int getNumberOfButtonsImpl();
1695 
1696     @Override
1697     public int getNumberOfButtons(){
1698         awtLock();
1699         try {
1700             if (numberOfButtons == 0) {
1701                 numberOfButtons = getNumberOfButtonsImpl();
1702                 numberOfButtons = (numberOfButtons &gt; MAX_BUTTONS_SUPPORTED)? MAX_BUTTONS_SUPPORTED : numberOfButtons;
1703                 //4th and 5th buttons are for wheel and shouldn&#39;t be reported as buttons.
1704                 //If we have more than 3 physical buttons and a wheel, we report N-2 buttons.
1705                 //If we have 3 physical buttons and a wheel, we report 3 buttons.
1706                 //If we have 1,2,3 physical buttons, we report it as is i.e. 1,2 or 3 respectively.
1707                 if (numberOfButtons &gt;=5) {
1708                     numberOfButtons -= 2;
1709                 } else if (numberOfButtons == 4 || numberOfButtons ==5){
1710                     numberOfButtons = 3;
1711                 }
1712             }
1713             //Assume don&#39;t have to re-query the number again and again.
1714             return numberOfButtons;
1715         } finally {
1716             awtUnlock();
1717         }
1718     }
1719 
1720     static int getNumberOfButtonsForMask() {
1721         return Math.min(XConstants.MAX_BUTTONS, ((SunToolkit) (Toolkit.getDefaultToolkit())).getNumberOfButtons());
1722     }
1723 
1724     private static final String prefix  = &quot;DnD.Cursor.&quot;;
1725     private static final String postfix = &quot;.32x32&quot;;
1726     private static final String dndPrefix  = &quot;DnD.&quot;;
1727 
1728     @Override
1729     protected Object lazilyLoadDesktopProperty(String name) {
1730         if (name.startsWith(prefix)) {
1731             String cursorName = name.substring(prefix.length(), name.length()) + postfix;
1732 
1733             try {
1734                 return Cursor.getSystemCustomCursor(cursorName);
1735             } catch (AWTException awte) {
1736                 throw new RuntimeException(&quot;cannot load system cursor: &quot; + cursorName, awte);
1737             }
1738         }
1739 
1740         if (name.equals(&quot;awt.dynamicLayoutSupported&quot;)) {
1741             return  Boolean.valueOf(isDynamicLayoutSupported());
1742         }
1743 
1744         if (initXSettingsIfNeeded(name)) {
1745             return desktopProperties.get(name);
1746         }
1747 
1748         return super.lazilyLoadDesktopProperty(name);
1749     }
1750 
1751     @Override
1752     public synchronized void addPropertyChangeListener(String name, PropertyChangeListener pcl) {
1753         if (name == null) {
1754             // See JavaDoc for the Toolkit.addPropertyChangeListener() method
1755             return;
1756         }
1757         initXSettingsIfNeeded(name);
1758         super.addPropertyChangeListener(name, pcl);
1759     }
1760 
1761     /**
1762      * Initializes XAWTXSettings if a property for a given property name is provided by
1763      * XSettings and they are not initialized yet.
1764      *
1765      * @return true if the method has initialized XAWTXSettings.
1766      */
1767     private boolean initXSettingsIfNeeded(final String propName) {
1768         if (!loadedXSettings &amp;&amp;
1769             (propName.startsWith(&quot;gnome.&quot;) ||
1770              propName.equals(SunToolkit.DESKTOPFONTHINTS) ||
1771              propName.startsWith(dndPrefix)))
1772         {
1773             loadedXSettings = true;
1774             if (!GraphicsEnvironment.isHeadless()) {
1775                 loadXSettings();
1776                 /* If no desktop font hint could be retrieved, check for
1777                  * KDE running KWin and retrieve settings from fontconfig.
1778                  * If that isn&#39;t found let SunToolkit will see if there&#39;s a
1779                  * system property set by a user.
1780                  */
1781                 if (desktopProperties.get(SunToolkit.DESKTOPFONTHINTS) == null) {
1782                     if (XWM.isKDE2()) {
1783                         Object hint = FontConfigManager.getFontConfigAAHint();
1784                         if (hint != null) {
1785                             /* set the fontconfig/KDE property so that
1786                              * getDesktopHints() below will see it
1787                              * and set the public property.
1788                              */
1789                             desktopProperties.put(UNIXToolkit.FONTCONFIGAAHINT,
1790                                                   hint);
1791                         }
1792                     }
1793                     desktopProperties.put(SunToolkit.DESKTOPFONTHINTS,
1794                                           SunToolkit.getDesktopFontHints());
1795                 }
1796 
1797                 return true;
1798             }
1799         }
1800         return false;
1801     }
1802 
1803     private void loadXSettings() {
1804        xs = new XAWTXSettings();
1805     }
1806 
1807     /**
1808      * Callback from the native side indicating some, or all, of the
1809      * desktop properties have changed and need to be reloaded.
1810      * {@code data} is the byte array directly from the x server and
1811      * may be in little endian format.
1812      * &lt;p&gt;
1813      * NB: This could be called from any thread if triggered by
1814      * {@code loadXSettings}.  It is called from the System EDT
1815      * if triggered by an XSETTINGS change.
1816      */
1817     void parseXSettings(int screen_XXX_ignored,Map&lt;String, Object&gt; updatedSettings) {
1818 
1819         if (updatedSettings == null || updatedSettings.isEmpty()) {
1820             return;
1821         }
1822 
1823         Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; i = updatedSettings.entrySet().iterator();
1824         while (i.hasNext()) {
1825             Map.Entry&lt;String, Object&gt; e = i.next();
1826             String name = e.getKey();
1827 
1828             name = &quot;gnome.&quot; + name;
1829             setDesktopProperty(name, e.getValue());
1830             if (log.isLoggable(PlatformLogger.Level.FINE)) {
1831                 log.fine(&quot;name = &quot; + name + &quot; value = &quot; + e.getValue());
1832             }
1833 
1834             // XXX: we probably want to do something smarter.  In
1835             // particular, &quot;Net&quot; properties are of interest to the
1836             // &quot;core&quot; AWT itself.  E.g.
1837             //
1838             // Net/DndDragThreshold -&gt; ???
1839             // Net/DoubleClickTime  -&gt; awt.multiClickInterval
1840         }
1841 
1842         setDesktopProperty(SunToolkit.DESKTOPFONTHINTS,
1843                            SunToolkit.getDesktopFontHints());
1844 
1845         Integer dragThreshold = null;
1846         synchronized (this) {
1847             dragThreshold = (Integer)desktopProperties.get(&quot;gnome.Net/DndDragThreshold&quot;);
1848         }
1849         if (dragThreshold != null) {
1850             setDesktopProperty(&quot;DnD.gestureMotionThreshold&quot;, dragThreshold);
1851         }
1852 
1853     }
1854 
1855 
1856 
1857     static int altMask;
1858     static int metaMask;
1859     static int numLockMask;
1860     static int modeSwitchMask;
1861     static int modLockIsShiftLock;
1862 
1863     /* Like XKeysymToKeycode, but ensures that keysym is the primary
1864     * symbol on the keycode returned.  Returns zero otherwise.
1865     */
1866     static int keysymToPrimaryKeycode(long sym) {
1867         awtLock();
1868         try {
1869             int code = XlibWrapper.XKeysymToKeycode(getDisplay(), sym);
1870             if (code == 0) {
1871                 return 0;
1872             }
1873             long primary = XlibWrapper.XKeycodeToKeysym(getDisplay(), code, 0);
1874             if (sym != primary) {
1875                 return 0;
1876             }
1877             return code;
1878         } finally {
1879             awtUnlock();
1880         }
1881     }
1882     static boolean getModifierState( int jkc ) {
1883         int iKeyMask = 0;
1884         long ks = XKeysym.javaKeycode2Keysym( jkc );
1885         int  kc = XlibWrapper.XKeysymToKeycode(getDisplay(), ks);
1886         if (kc == 0) {
1887             return false;
1888         }
1889         awtLock();
1890         try {
1891             XModifierKeymap modmap = new XModifierKeymap(
1892                  XlibWrapper.XGetModifierMapping(getDisplay()));
1893 
1894             int nkeys = modmap.get_max_keypermod();
1895 
1896             long map_ptr = modmap.get_modifiermap();
1897             for( int k = 0; k &lt; 8; k++ ) {
1898                 for (int i = 0; i &lt; nkeys; ++i) {
1899                     int keycode = Native.getUByte(map_ptr, k * nkeys + i);
1900                     if (keycode == 0) {
1901                         continue; // ignore zero keycode
1902                     }
1903                     if (kc == keycode) {
1904                         iKeyMask = 1 &lt;&lt; k;
1905                         break;
1906                     }
1907                 }
1908                 if( iKeyMask != 0 ) {
1909                     break;
1910                 }
1911             }
1912             XlibWrapper.XFreeModifiermap(modmap.pData);
1913             if (iKeyMask == 0 ) {
1914                 return false;
1915             }
1916             // Now we know to which modifier is assigned the keycode
1917             // correspondent to the keysym correspondent to the java
1918             // keycode. We are going to check a state of this modifier.
1919             // If a modifier is a weird one, we cannot help it.
1920             long window = 0;
1921             try{
1922                 // get any application window
1923                 window = winMap.firstKey().longValue();
1924             }catch(NoSuchElementException nex) {
1925                 // get root window
1926                 window = getDefaultRootWindow();
1927             }
1928             boolean res = XlibWrapper.XQueryPointer(getDisplay(), window,
1929                                             XlibWrapper.larg1, //root
1930                                             XlibWrapper.larg2, //child
1931                                             XlibWrapper.larg3, //root_x
1932                                             XlibWrapper.larg4, //root_y
1933                                             XlibWrapper.larg5, //child_x
1934                                             XlibWrapper.larg6, //child_y
1935                                             XlibWrapper.larg7);//mask
1936             int mask = Native.getInt(XlibWrapper.larg7);
1937             return ((mask &amp; iKeyMask) != 0);
1938         } finally {
1939             awtUnlock();
1940         }
1941     }
1942 
1943     /* Assign meaning - alt, meta, etc. - to X modifiers mod1 ... mod5.
1944      * Only consider primary symbols on keycodes attached to modifiers.
1945      */
1946     static void setupModifierMap() {
1947         final int metaL = keysymToPrimaryKeycode(XKeySymConstants.XK_Meta_L);
1948         final int metaR = keysymToPrimaryKeycode(XKeySymConstants.XK_Meta_R);
1949         final int altL = keysymToPrimaryKeycode(XKeySymConstants.XK_Alt_L);
1950         final int altR = keysymToPrimaryKeycode(XKeySymConstants.XK_Alt_R);
1951         final int numLock = keysymToPrimaryKeycode(XKeySymConstants.XK_Num_Lock);
1952         final int modeSwitch = keysymToPrimaryKeycode(XKeySymConstants.XK_Mode_switch);
1953         final int shiftLock = keysymToPrimaryKeycode(XKeySymConstants.XK_Shift_Lock);
1954         final int capsLock  = keysymToPrimaryKeycode(XKeySymConstants.XK_Caps_Lock);
1955 
1956         final int[] modmask = { XConstants.ShiftMask, XConstants.LockMask, XConstants.ControlMask, XConstants.Mod1Mask,
1957             XConstants.Mod2Mask, XConstants.Mod3Mask, XConstants.Mod4Mask, XConstants.Mod5Mask };
1958 
1959         log.fine(&quot;In setupModifierMap&quot;);
1960         awtLock();
1961         try {
1962             XModifierKeymap modmap = new XModifierKeymap(
1963                  XlibWrapper.XGetModifierMapping(getDisplay()));
1964 
1965             int nkeys = modmap.get_max_keypermod();
1966 
1967             long map_ptr = modmap.get_modifiermap();
1968 
1969             for (int modn = XConstants.Mod1MapIndex;
1970                  modn &lt;= XConstants.Mod5MapIndex;
1971                  ++modn)
1972             {
1973                 for (int i = 0; i &lt; nkeys; ++i) {
1974                     /* for each keycode attached to this modifier */
1975                     int keycode = Native.getUByte(map_ptr, modn * nkeys + i);
1976 
1977                     if (keycode == 0) {
1978                         break;
1979                     }
1980                     if (metaMask == 0 &amp;&amp;
1981                         (keycode == metaL || keycode == metaR))
1982                     {
1983                         metaMask = modmask[modn];
1984                         break;
1985                     }
1986                     if (altMask == 0 &amp;&amp; (keycode == altL || keycode == altR)) {
1987                         altMask = modmask[modn];
1988                         break;
1989                     }
1990                     if (numLockMask == 0 &amp;&amp; keycode == numLock) {
1991                         numLockMask = modmask[modn];
1992                         break;
1993                     }
1994                     if (modeSwitchMask == 0 &amp;&amp; keycode == modeSwitch) {
1995                         modeSwitchMask = modmask[modn];
1996                         break;
1997                     }
1998                     continue;
1999                 }
2000             }
2001             modLockIsShiftLock = 0;
2002             for (int j = 0; j &lt; nkeys; ++j) {
2003                 int keycode = Native.getUByte(map_ptr, XConstants.LockMapIndex * nkeys + j);
2004                 if (keycode == 0) {
2005                     break;
2006                 }
2007                 if (keycode == shiftLock) {
2008                     modLockIsShiftLock = 1;
2009                     break;
2010                 }
2011                 if (keycode == capsLock) {
2012                     break;
2013                 }
2014             }
2015             XlibWrapper.XFreeModifiermap(modmap.pData);
2016         } finally {
2017             awtUnlock();
2018         }
2019         if (log.isLoggable(PlatformLogger.Level.FINE)) {
2020             log.fine(&quot;metaMask = &quot; + metaMask);
2021             log.fine(&quot;altMask = &quot; + altMask);
2022             log.fine(&quot;numLockMask = &quot; + numLockMask);
2023             log.fine(&quot;modeSwitchMask = &quot; + modeSwitchMask);
2024             log.fine(&quot;modLockIsShiftLock = &quot; + modLockIsShiftLock);
2025         }
2026     }
2027 
2028 
2029     private static SortedMap&lt;Long, java.util.List&lt;Runnable&gt;&gt; timeoutTasks;
2030 
2031     /**
2032      * Removed the task from the list of waiting-to-be called tasks.
2033      * If the task has been scheduled several times removes only first one.
2034      */
2035     static void remove(Runnable task) {
2036         if (task == null) {
2037             throw new NullPointerException(&quot;task is null&quot;);
2038         }
2039         awtLock();
2040         try {
2041             if (timeoutTaskLog.isLoggable(PlatformLogger.Level.FINER)) {
2042                 timeoutTaskLog.finer(&quot;Removing task &quot; + task);
2043             }
2044             if (timeoutTasks == null) {
2045                 if (timeoutTaskLog.isLoggable(PlatformLogger.Level.FINER)) {
2046                     timeoutTaskLog.finer(&quot;Task is not scheduled&quot;);
2047                 }
2048                 return;
2049             }
2050             Collection&lt;java.util.List&lt;Runnable&gt;&gt; values = timeoutTasks.values();
2051             Iterator&lt;java.util.List&lt;Runnable&gt;&gt; iter = values.iterator();
2052             while (iter.hasNext()) {
2053                 java.util.List&lt;Runnable&gt; list = iter.next();
2054                 boolean removed = false;
2055                 if (list.contains(task)) {
2056                     list.remove(task);
2057                     if (list.isEmpty()) {
2058                         iter.remove();
2059                     }
2060                     break;
2061                 }
2062             }
2063         } finally {
2064             awtUnlock();
2065         }
2066     }
2067 
2068     static native void wakeup_poll();
2069 
2070     /**
2071      * Registers a Runnable which {@code run()} method will be called
2072      * once on the toolkit thread when a specified interval of time elapses.
2073      *
2074      * @param task a Runnable which {@code run} method will be called
2075      *        on the toolkit thread when {@code interval} milliseconds
2076      *        elapse
2077      * @param interval an interal in milliseconds
2078      *
2079      * @throws NullPointerException if {@code task} is {@code null}
2080      * @throws IllegalArgumentException if {@code interval} is not positive
2081      */
2082     static void schedule(Runnable task, long interval) {
2083         if (task == null) {
2084             throw new NullPointerException(&quot;task is null&quot;);
2085         }
2086         if (interval &lt;= 0) {
2087             throw new IllegalArgumentException(&quot;interval &quot; + interval + &quot; is not positive&quot;);
2088         }
2089 
2090         awtLock();
2091         try {
2092             if (timeoutTaskLog.isLoggable(PlatformLogger.Level.FINER)) {
2093                 timeoutTaskLog.finer(&quot;XToolkit.schedule(): current time={0}&quot; +
2094                                      &quot;;  interval={1}&quot; +
2095                                      &quot;;  task being added={2}&quot; + &quot;;  tasks before addition={3}&quot;,
2096                                      Long.valueOf(System.currentTimeMillis()), Long.valueOf(interval), task, timeoutTasks);
2097             }
2098 
2099             if (timeoutTasks == null) {
2100                 timeoutTasks = new TreeMap&lt;&gt;();
2101             }
2102 
2103             Long time = Long.valueOf(System.currentTimeMillis() + interval);
2104             java.util.List&lt;Runnable&gt; tasks = timeoutTasks.get(time);
2105             if (tasks == null) {
2106                 tasks = new ArrayList&lt;&gt;(1);
2107                 timeoutTasks.put(time, tasks);
2108             }
2109             tasks.add(task);
2110 
2111 
2112             if (timeoutTasks.get(timeoutTasks.firstKey()) == tasks &amp;&amp; tasks.size() == 1) {
2113                 // Added task became first task - poll won&#39;t know
2114                 // about it so we need to wake it up
2115                 wakeup_poll();
2116             }
2117         }  finally {
2118             awtUnlock();
2119         }
2120     }
2121 
2122     private long getNextTaskTime() {
2123         awtLock();
2124         try {
2125             if (timeoutTasks == null || timeoutTasks.isEmpty()) {
2126                 return -1L;
2127             }
2128             return timeoutTasks.firstKey();
2129         } finally {
2130             awtUnlock();
2131         }
2132     }
2133 
2134     /**
2135      * Executes mature timeout tasks registered with schedule().
2136      * Called from run() under awtLock.
2137      */
2138     private static void callTimeoutTasks() {
2139         if (timeoutTaskLog.isLoggable(PlatformLogger.Level.FINER)) {
2140             timeoutTaskLog.finer(&quot;XToolkit.callTimeoutTasks(): current time={0}&quot; +
2141                                  &quot;;  tasks={1}&quot;, Long.valueOf(System.currentTimeMillis()), timeoutTasks);
2142         }
2143 
2144         if (timeoutTasks == null || timeoutTasks.isEmpty()) {
2145             return;
2146         }
2147 
2148         Long currentTime = Long.valueOf(System.currentTimeMillis());
2149         Long time = timeoutTasks.firstKey();
2150 
2151         while (time.compareTo(currentTime) &lt;= 0) {
2152             java.util.List&lt;Runnable&gt; tasks = timeoutTasks.remove(time);
2153 
2154             for (Iterator&lt;Runnable&gt; iter = tasks.iterator(); iter.hasNext();) {
2155                 Runnable task = iter.next();
2156 
2157                 if (timeoutTaskLog.isLoggable(PlatformLogger.Level.FINER)) {
2158                     timeoutTaskLog.finer(&quot;XToolkit.callTimeoutTasks(): current time={0}&quot; +
2159                                          &quot;;  about to run task={1}&quot;, Long.valueOf(currentTime), task);
2160                 }
2161 
2162                 try {
2163                     task.run();
2164                 } catch (ThreadDeath td) {
2165                     throw td;
2166                 } catch (Throwable thr) {
2167                     processException(thr);
2168                 }
2169             }
2170 
2171             if (timeoutTasks.isEmpty()) {
2172                 break;
2173             }
2174             time = timeoutTasks.firstKey();
2175         }
2176     }
2177 
2178     static long getAwtDefaultFg() {
2179         return awt_defaultFg;
2180     }
2181 
2182     static boolean isLeftMouseButton(MouseEvent me) {
2183         switch (me.getID()) {
2184           case MouseEvent.MOUSE_PRESSED:
2185           case MouseEvent.MOUSE_RELEASED:
2186               return (me.getButton() == MouseEvent.BUTTON1);
2187           case MouseEvent.MOUSE_ENTERED:
2188           case MouseEvent.MOUSE_EXITED:
2189           case MouseEvent.MOUSE_CLICKED:
2190           case MouseEvent.MOUSE_DRAGGED:
2191               return ((me.getModifiersEx() &amp; InputEvent.BUTTON1_DOWN_MASK) != 0);
2192         }
2193         return false;
2194     }
2195 
2196     static boolean isRightMouseButton(MouseEvent me) {
2197         int numButtons = ((Integer)getDefaultToolkit().getDesktopProperty(&quot;awt.mouse.numButtons&quot;)).intValue();
2198         switch (me.getID()) {
2199           case MouseEvent.MOUSE_PRESSED:
2200           case MouseEvent.MOUSE_RELEASED:
2201               return ((numButtons == 2 &amp;&amp; me.getButton() == MouseEvent.BUTTON2) ||
2202                        (numButtons &gt; 2 &amp;&amp; me.getButton() == MouseEvent.BUTTON3));
2203           case MouseEvent.MOUSE_ENTERED:
2204           case MouseEvent.MOUSE_EXITED:
2205           case MouseEvent.MOUSE_CLICKED:
2206           case MouseEvent.MOUSE_DRAGGED:
2207               return ((numButtons == 2 &amp;&amp; (me.getModifiersEx() &amp; InputEvent.BUTTON2_DOWN_MASK) != 0) ||
2208                       (numButtons &gt; 2 &amp;&amp; (me.getModifiersEx() &amp; InputEvent.BUTTON3_DOWN_MASK) != 0));
2209         }
2210         return false;
2211     }
2212 
2213     static long reset_time_utc;
2214     static final long WRAP_TIME_MILLIS = 0x00000000FFFFFFFFL;
2215 
2216     /*
2217      * This function converts between the X server time (number of milliseconds
2218      * since the last server reset) and the UTC time for the &#39;when&#39; field of an
2219      * InputEvent (or another event type with a timestamp).
2220      */
2221     static long nowMillisUTC_offset(long server_offset) {
2222         // ported from awt_util.c
2223         /*
2224          * Because Time is of type &#39;unsigned long&#39;, it is possible that Time will
2225          * never wrap when using 64-bit Xlib. However, if a 64-bit client
2226          * connects to a 32-bit server, I suspect the values will still wrap. So
2227          * we should not attempt to remove the wrap checking even if _LP64 is
2228          * true.
2229          */
2230 
2231         long current_time_utc = System.currentTimeMillis();
2232         if (log.isLoggable(PlatformLogger.Level.FINER)) {
2233             log.finer(&quot;reset_time=&quot; + reset_time_utc + &quot;, current_time=&quot; + current_time_utc
2234                       + &quot;, server_offset=&quot; + server_offset + &quot;, wrap_time=&quot; + WRAP_TIME_MILLIS);
2235         }
2236 
2237         if ((current_time_utc - reset_time_utc) &gt; WRAP_TIME_MILLIS) {
2238             reset_time_utc = System.currentTimeMillis() - getCurrentServerTime();
2239         }
2240 
2241         if (log.isLoggable(PlatformLogger.Level.FINER)) {
2242             log.finer(&quot;result = &quot; + (reset_time_utc + server_offset));
2243         }
2244         return reset_time_utc + server_offset;
2245     }
2246 
2247     /**
2248      * @see sun.awt.SunToolkit#needsXEmbedImpl
2249      */
2250     @Override
2251     protected boolean needsXEmbedImpl() {
2252         // XToolkit implements supports for XEmbed-client protocol and
2253         // requires the supports from the embedding host for it to work.
2254         return true;
2255     }
2256 
2257     @Override
2258     public boolean isModalityTypeSupported(Dialog.ModalityType modalityType) {
2259         return (modalityType == null) ||
2260                (modalityType == Dialog.ModalityType.MODELESS) ||
2261                (modalityType == Dialog.ModalityType.DOCUMENT_MODAL) ||
2262                (modalityType == Dialog.ModalityType.APPLICATION_MODAL) ||
2263                (modalityType == Dialog.ModalityType.TOOLKIT_MODAL);
2264     }
2265 
2266     @Override
2267     public boolean isModalExclusionTypeSupported(Dialog.ModalExclusionType exclusionType) {
2268         return (exclusionType == null) ||
2269                (exclusionType == Dialog.ModalExclusionType.NO_EXCLUDE) ||
2270                (exclusionType == Dialog.ModalExclusionType.APPLICATION_EXCLUDE) ||
2271                (exclusionType == Dialog.ModalExclusionType.TOOLKIT_EXCLUDE);
2272     }
2273 
2274     static EventQueue getEventQueue(Object target) {
2275         AppContext appContext = targetToAppContext(target);
2276         if (appContext != null) {
2277             return (EventQueue)appContext.get(AppContext.EVENT_QUEUE_KEY);
2278         }
2279         return null;
2280     }
2281 
2282     static void removeSourceEvents(EventQueue queue,
2283                                    Object source,
2284                                    boolean removeAllEvents) {
2285         AWTAccessor.getEventQueueAccessor()
2286             .removeSourceEvents(queue, source, removeAllEvents);
2287     }
2288 
2289     @Override
2290     public boolean isAlwaysOnTopSupported() {
2291         for (XLayerProtocol proto : XWM.getWM().getProtocols(XLayerProtocol.class)) {
2292             if (proto.supportsLayer(XLayerProtocol.LAYER_ALWAYS_ON_TOP)) {
2293                 return true;
2294             }
2295         }
2296         return false;
2297     }
2298 
2299     @Override
2300     public boolean useBufferPerWindow() {
2301         return XToolkit.getBackingStoreType() == XConstants.NotUseful;
2302     }
2303 
2304     /**
2305      * Returns one of XConstants: NotUseful, WhenMapped or Always.
2306      * If backing store is not available on at least one screen, or
2307      * the string system property &quot;sun.awt.backingStore&quot; is neither &quot;Always&quot;
2308      * nor &quot;WhenMapped&quot;, then the method returns XConstants.NotUseful.
2309      * Otherwise, if the system property &quot;sun.awt.backingStore&quot; is &quot;WhenMapped&quot;,
2310      * then the method returns XConstants.WhenMapped.
2311      * Otherwise (i.e., if the system property &quot;sun.awt.backingStore&quot; is &quot;Always&quot;),
2312      * the method returns XConstants.Always.
2313      */
2314     static int getBackingStoreType() {
2315         return backingStoreType;
2316     }
2317 
2318     private static void setBackingStoreType() {
2319         String prop = AccessController.doPrivileged(
2320                 new sun.security.action.GetPropertyAction(&quot;sun.awt.backingStore&quot;));
2321 
2322         if (prop == null) {
2323             backingStoreType = XConstants.NotUseful;
2324             if (backingStoreLog.isLoggable(PlatformLogger.Level.CONFIG)) {
2325                 backingStoreLog.config(&quot;The system property sun.awt.backingStore is not set&quot; +
2326                                        &quot;, by default backingStore=NotUseful&quot;);
2327             }
2328             return;
2329         }
2330 
2331         if (backingStoreLog.isLoggable(PlatformLogger.Level.CONFIG)) {
2332             backingStoreLog.config(&quot;The system property sun.awt.backingStore is &quot; + prop);
2333         }
2334         prop = prop.toLowerCase();
2335         if (prop.equals(&quot;always&quot;)) {
2336             backingStoreType = XConstants.Always;
2337         } else if (prop.equals(&quot;whenmapped&quot;)) {
2338             backingStoreType = XConstants.WhenMapped;
2339         } else {
2340             backingStoreType = XConstants.NotUseful;
2341         }
2342 
2343         if (backingStoreLog.isLoggable(PlatformLogger.Level.CONFIG)) {
2344             backingStoreLog.config(&quot;backingStore(as provided by the system property)=&quot; +
2345                                    ( backingStoreType == XConstants.NotUseful ? &quot;NotUseful&quot;
2346                                      : backingStoreType == XConstants.WhenMapped ?
2347                                      &quot;WhenMapped&quot; : &quot;Always&quot;) );
2348         }
2349 
2350         awtLock();
2351         try {
2352             int screenCount = XlibWrapper.ScreenCount(getDisplay());
2353             for (int i = 0; i &lt; screenCount; i++) {
2354                 if (XlibWrapper.DoesBackingStore(XlibWrapper.ScreenOfDisplay(getDisplay(), i))
2355                         == XConstants.NotUseful) {
2356                     backingStoreType = XConstants.NotUseful;
2357 
2358                     if (backingStoreLog.isLoggable(PlatformLogger.Level.CONFIG)) {
2359                         backingStoreLog.config(&quot;Backing store is not available on the screen &quot; +
2360                                                i + &quot;, backingStore=NotUseful&quot;);
2361                     }
2362 
2363                     return;
2364                 }
2365             }
2366         } finally {
2367             awtUnlock();
2368         }
2369     }
2370 
2371     /**
2372      * One of XConstants: NotUseful, WhenMapped or Always.
2373      */
2374     private static int backingStoreType;
2375 
2376     static final int XSUN_KP_BEHAVIOR = 1;
2377     static final int XORG_KP_BEHAVIOR = 2;
2378     static final int    IS_SUN_KEYBOARD = 1;
2379     static final int IS_NONSUN_KEYBOARD = 2;
2380     static final int    IS_KANA_KEYBOARD = 1;
2381     static final int IS_NONKANA_KEYBOARD = 2;
2382 
2383 
2384     static int     awt_IsXsunKPBehavior = 0;
2385     static boolean awt_UseXKB         = false;
2386     static boolean awt_UseXKB_Calls   = false;
2387     static int     awt_XKBBaseEventCode = 0;
2388     static int     awt_XKBEffectiveGroup = 0; // so far, I don&#39;t use it leaving all calculations
2389                                               // to XkbTranslateKeyCode
2390     static long    awt_XKBDescPtr     = 0;
2391 
2392     /**
2393      * Check for Xsun convention regarding numpad keys.
2394      * Xsun and some other servers (i.e. derived from Xsun)
2395      * under certain conditions process numpad keys unlike Xorg.
2396      */
2397     static boolean isXsunKPBehavior() {
2398         awtLock();
2399         try {
2400             if( awt_IsXsunKPBehavior == 0 ) {
2401                 if( XlibWrapper.IsXsunKPBehavior(getDisplay()) ) {
2402                     awt_IsXsunKPBehavior = XSUN_KP_BEHAVIOR;
2403                 }else{
2404                     awt_IsXsunKPBehavior = XORG_KP_BEHAVIOR;
2405                 }
2406             }
2407             return awt_IsXsunKPBehavior == XSUN_KP_BEHAVIOR ? true : false;
2408         } finally {
2409             awtUnlock();
2410         }
2411     }
2412 
2413     static int  sunOrNotKeyboard = 0;
2414     static int kanaOrNotKeyboard = 0;
2415     static void resetKeyboardSniffer() {
2416         sunOrNotKeyboard  = 0;
2417         kanaOrNotKeyboard = 0;
2418     }
2419     static boolean isSunKeyboard() {
2420         if( sunOrNotKeyboard == 0 ) {
2421             if( XlibWrapper.IsSunKeyboard( getDisplay() )) {
2422                 sunOrNotKeyboard = IS_SUN_KEYBOARD;
2423             }else{
2424                 sunOrNotKeyboard = IS_NONSUN_KEYBOARD;
2425             }
2426         }
2427         return (sunOrNotKeyboard == IS_SUN_KEYBOARD);
2428     }
2429     static boolean isKanaKeyboard() {
2430         if( kanaOrNotKeyboard == 0 ) {
2431             if( XlibWrapper.IsKanaKeyboard( getDisplay() )) {
2432                 kanaOrNotKeyboard = IS_KANA_KEYBOARD;
2433             }else{
2434                 kanaOrNotKeyboard = IS_NONKANA_KEYBOARD;
2435             }
2436         }
2437         return (kanaOrNotKeyboard == IS_KANA_KEYBOARD);
2438     }
2439     static boolean isXKBenabled() {
2440         awtLock();
2441         try {
2442             return awt_UseXKB;
2443         } finally {
2444             awtUnlock();
2445         }
2446     }
2447 
2448     /**
2449       Query XKEYBOARD extension.
2450       If possible, initialize xkb library.
2451     */
2452     static boolean tryXKB() {
2453         awtLock();
2454         try {
2455             String name = &quot;XKEYBOARD&quot;;
2456             // First, if there is extension at all.
2457             awt_UseXKB = XlibWrapper.XQueryExtension( getDisplay(), name, XlibWrapper.larg1, XlibWrapper.larg2, XlibWrapper.larg3);
2458             if( awt_UseXKB ) {
2459                 // There is a keyboard extension. Check if a client library is compatible.
2460                 // If not, don&#39;t use xkb calls.
2461                 // In this case we still may be Xkb-capable application.
2462                 awt_UseXKB_Calls = XlibWrapper.XkbLibraryVersion( XlibWrapper.larg1, XlibWrapper.larg2);
2463                 if( awt_UseXKB_Calls ) {
2464                     awt_UseXKB_Calls = XlibWrapper.XkbQueryExtension( getDisplay(),  XlibWrapper.larg1, XlibWrapper.larg2,
2465                                      XlibWrapper.larg3, XlibWrapper.larg4, XlibWrapper.larg5);
2466                     if( awt_UseXKB_Calls ) {
2467                         awt_XKBBaseEventCode = Native.getInt(XlibWrapper.larg2);
2468                         XlibWrapper.XkbSelectEvents (getDisplay(),
2469                                          XConstants.XkbUseCoreKbd,
2470                                          XConstants.XkbNewKeyboardNotifyMask |
2471                                                  XConstants.XkbMapNotifyMask ,//|
2472                                                  //XConstants.XkbStateNotifyMask,
2473                                          XConstants.XkbNewKeyboardNotifyMask |
2474                                                  XConstants.XkbMapNotifyMask );//|
2475                                                  //XConstants.XkbStateNotifyMask);
2476 
2477                         XlibWrapper.XkbSelectEventDetails(getDisplay(), XConstants.XkbUseCoreKbd,
2478                                                      XConstants.XkbStateNotify,
2479                                                      XConstants.XkbGroupStateMask,
2480                                                      XConstants.XkbGroupStateMask);
2481                                                      //XXX ? XkbGroupLockMask last, XkbAllStateComponentsMask before last?
2482                         awt_XKBDescPtr = XlibWrapper.XkbGetMap(getDisplay(),
2483                                                      XConstants.XkbKeyTypesMask    |
2484                                                      XConstants.XkbKeySymsMask     |
2485                                                      XConstants.XkbModifierMapMask |
2486                                                      XConstants.XkbVirtualModsMask,
2487                                                      XConstants.XkbUseCoreKbd);
2488 
2489                         XlibWrapper.XkbSetDetectableAutoRepeat(getDisplay(), true);
2490                     }
2491                 }
2492             }
2493             return awt_UseXKB;
2494         } finally {
2495             awtUnlock();
2496         }
2497     }
2498     static boolean canUseXKBCalls() {
2499         awtLock();
2500         try {
2501             return awt_UseXKB_Calls;
2502         } finally {
2503             awtUnlock();
2504         }
2505     }
2506     static int getXKBEffectiveGroup() {
2507         awtLock();
2508         try {
2509             return awt_XKBEffectiveGroup;
2510         } finally {
2511             awtUnlock();
2512         }
2513     }
2514     static int getXKBBaseEventCode() {
2515         awtLock();
2516         try {
2517             return awt_XKBBaseEventCode;
2518         } finally {
2519             awtUnlock();
2520         }
2521     }
2522     static long getXKBKbdDesc() {
2523         awtLock();
2524         try {
2525             return awt_XKBDescPtr;
2526         } finally {
2527             awtUnlock();
2528         }
2529     }
2530     void freeXKB() {
2531         awtLock();
2532         try {
2533             if (awt_UseXKB_Calls &amp;&amp; awt_XKBDescPtr != 0) {
2534                 XlibWrapper.XkbFreeKeyboard(awt_XKBDescPtr, 0xFF, true);
2535                 awt_XKBDescPtr = 0;
2536             }
2537         } finally {
2538             awtUnlock();
2539         }
2540     }
2541     private void processXkbChanges(XEvent ev) {
2542         // mapping change --&gt; refresh kbd map
2543         // state change --&gt; get a new effective group; do I really need it
2544         //  or that should be left for XkbTranslateKeyCode?
2545         XkbEvent xke = new XkbEvent( ev.getPData() );
2546         int xkb_type = xke.get_any().get_xkb_type();
2547         switch( xkb_type ) {
2548             case XConstants.XkbNewKeyboardNotify :
2549                  if( awt_XKBDescPtr != 0 ) {
2550                      freeXKB();
2551                  }
2552                  awt_XKBDescPtr = XlibWrapper.XkbGetMap(getDisplay(),
2553                                               XConstants.XkbKeyTypesMask    |
2554                                               XConstants.XkbKeySymsMask     |
2555                                               XConstants.XkbModifierMapMask |
2556                                               XConstants.XkbVirtualModsMask,
2557                                               XConstants.XkbUseCoreKbd);
2558                  //System.out.println(&quot;XkbNewKeyboard:&quot;+(xke.get_new_kbd()));
2559                  break;
2560             case XConstants.XkbMapNotify :
2561                  if (awt_XKBDescPtr != 0) {
2562                     //TODO: provide a simple unit test.
2563                     XlibWrapper.XkbGetUpdatedMap(getDisplay(),
2564                                                  XConstants.XkbKeyTypesMask    |
2565                                                  XConstants.XkbKeySymsMask     |
2566                                                  XConstants.XkbModifierMapMask |
2567                                                  XConstants.XkbVirtualModsMask,
2568                                                  awt_XKBDescPtr);
2569                  }
2570                 //System.out.println(&quot;XkbMap:&quot;+(xke.get_map()));
2571                  break;
2572             case XConstants.XkbStateNotify :
2573                  // May use it later e.g. to obtain an effective group etc.
2574                  //System.out.println(&quot;XkbState:&quot;+(xke.get_state()));
2575                  break;
2576             default:
2577                  //System.out.println(&quot;XkbEvent of xkb_type &quot;+xkb_type);
2578                  break;
2579         }
2580     }
2581 
2582     private static long eventNumber;
2583     public static long getEventNumber() {
2584         awtLock();
2585         try {
2586             return eventNumber;
2587         } finally {
2588             awtUnlock();
2589         }
2590     }
2591 
2592     private static XEventDispatcher oops_waiter;
2593     private static boolean oops_updated;
2594     private static int oops_position = 0;
2595 
2596     /**
2597      * @inheritDoc
2598      */
2599     @Override
2600     protected boolean syncNativeQueue(final long timeout) {
2601         XBaseWindow win = XBaseWindow.getXAWTRootWindow();
2602 
2603         if (oops_waiter == null) {
2604             oops_waiter = new XEventDispatcher() {
2605                     @Override
2606                     public void dispatchEvent(XEvent e) {
2607                         if (e.get_type() == XConstants.ConfigureNotify) {
2608                             // OOPS ConfigureNotify event catched
2609                             oops_updated = true;
2610                             awtLockNotifyAll();
2611                         }
2612                     }
2613                 };
2614         }
2615 
2616         awtLock();
2617         try {
2618             addEventDispatcher(win.getWindow(), oops_waiter);
2619 
2620             oops_updated = false;
2621             long event_number = getEventNumber();
2622             // Generate OOPS ConfigureNotify event
2623             XlibWrapper.XMoveWindow(getDisplay(), win.getWindow(),
2624                                     win.scaleUp(++oops_position), 0);
2625             // Change win position each time to avoid system optimization
2626             if (oops_position &gt; 50) {
2627                 oops_position = 0;
2628             }
2629 
2630             XSync();
2631 
2632             eventLog.finer(&quot;Generated OOPS ConfigureNotify event&quot;);
2633 
2634             long start = System.currentTimeMillis();
2635             while (!oops_updated) {
2636                 try {
2637                     // Wait for OOPS ConfigureNotify event
2638                     awtLockWait(timeout);
2639                 } catch (InterruptedException e) {
2640                     throw new RuntimeException(e);
2641                 }
2642                 // This &quot;while&quot; is a protection from spurious
2643                 // wake-ups.  However, we shouldn&#39;t wait for too long
2644                 if ((System.currentTimeMillis() - start &gt; timeout) &amp;&amp; timeout &gt;= 0) {
2645                     throw new OperationTimedOut(Long.toString(System.currentTimeMillis() - start));
2646                 }
2647             }
2648             // Don&#39;t take into account OOPS ConfigureNotify event
2649             return getEventNumber() - event_number &gt; 1;
2650         } finally {
2651             removeEventDispatcher(win.getWindow(), oops_waiter);
2652             eventLog.finer(&quot;Exiting syncNativeQueue&quot;);
2653             awtUnlock();
2654         }
2655     }
2656     @Override
2657     public void grab(Window w) {
2658         final Object peer = AWTAccessor.getComponentAccessor().getPeer(w);
2659         if (peer != null) {
2660             ((XWindowPeer) peer).setGrab(true);
2661         }
2662     }
2663 
2664     @Override
2665     public void ungrab(Window w) {
2666         final Object peer = AWTAccessor.getComponentAccessor().getPeer(w);
2667         if (peer != null) {
2668             ((XWindowPeer) peer).setGrab(false);
2669         }
2670     }
2671     /**
2672      * Returns if the java.awt.Desktop class is supported on the current
2673      * desktop.
2674      * &lt;p&gt;
2675      * The methods of java.awt.Desktop class are supported on the Gnome desktop.
2676      * Check if the running desktop is Gnome by checking the window manager.
2677      */
2678     @Override
2679     public boolean isDesktopSupported(){
2680         return XDesktopPeer.isDesktopSupported();
2681     }
2682 
2683     @Override
2684     public DesktopPeer createDesktopPeer(Desktop target){
2685         return new XDesktopPeer();
2686     }
2687 
2688     @Override
2689     public boolean isTaskbarSupported(){
2690         return XTaskbarPeer.isTaskbarSupported();
2691     }
2692 
2693     @Override
2694     public TaskbarPeer createTaskbarPeer(Taskbar target){
2695         return new XTaskbarPeer();
2696     }
2697 
2698     @Override
2699     public boolean areExtraMouseButtonsEnabled() throws HeadlessException {
2700         return areExtraMouseButtonsEnabled;
2701     }
2702 
2703     @Override
2704     public boolean isWindowOpacitySupported() {
2705         XNETProtocol net_protocol = XWM.getWM().getNETProtocol();
2706 
2707         if (net_protocol == null) {
2708             return false;
2709         }
2710 
2711         return net_protocol.doOpacityProtocol();
2712     }
2713 
2714     @Override
2715     public boolean isWindowShapingSupported() {
2716         return XlibUtil.isShapingSupported();
2717     }
2718 
2719     @Override
2720     public boolean isWindowTranslucencySupported() {
2721         //NOTE: it may not be supported. The actual check is being performed
2722         //      at java.awt.GraphicsDevice. In X11 we need to check
2723         //      whether there&#39;s any translucency-capable GC available.
2724         return true;
2725     }
2726 
2727     @Override
2728     public boolean isTranslucencyCapable(GraphicsConfiguration gc) {
2729         if (!(gc instanceof X11GraphicsConfig)) {
2730             return false;
2731         }
2732         return ((X11GraphicsConfig)gc).isTranslucencyCapable();
2733     }
2734 
2735     /**
2736      * Returns the value of &quot;sun.awt.disablegrab&quot; property. Default
2737      * value is {@code false}.
2738      */
2739     public static boolean getSunAwtDisableGrab() {
2740         return AccessController.doPrivileged(new GetBooleanAction(&quot;sun.awt.disablegrab&quot;));
2741     }
2742 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
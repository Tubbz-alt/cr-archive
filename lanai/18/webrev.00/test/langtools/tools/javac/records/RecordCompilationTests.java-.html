<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/langtools/tools/javac/records/RecordCompilationTests.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /**
 27  * RecordCompilationTests
 28  *
 29  * @test
 30  * @summary Negative compilation tests, and positive compilation (smoke) tests for records
 31  * @library /lib/combo /tools/lib /tools/javac/lib
 32  * @modules
 33  *      jdk.compiler/com.sun.tools.javac.code
 34  *      jdk.compiler/com.sun.tools.javac.util
 35  *      jdk.jdeps/com.sun.tools.classfile
 36  * @build JavacTestingAbstractProcessor
 37  * @compile --enable-preview -source ${jdk.version} RecordCompilationTests.java
 38  * @run testng/othervm --enable-preview RecordCompilationTests
 39  */
 40 
 41 import java.io.File;
 42 
 43 import java.lang.annotation.ElementType;
 44 import java.util.Arrays;
 45 import java.util.EnumMap;
 46 import java.util.EnumSet;
 47 import java.util.HashSet;
 48 import java.util.List;
 49 import java.util.Map;
 50 import java.util.Set;
 51 import java.util.stream.Collectors;
 52 import java.util.stream.Stream;
 53 
 54 
 55 import com.sun.tools.javac.util.Assert;
 56 
 57 import javax.annotation.processing.RoundEnvironment;
 58 import javax.annotation.processing.SupportedAnnotationTypes;
 59 
 60 import javax.lang.model.element.AnnotationMirror;
 61 import javax.lang.model.element.AnnotationValue;
 62 import javax.lang.model.element.Element;
 63 import javax.lang.model.element.ElementKind;
 64 import javax.lang.model.element.ExecutableElement;
 65 import javax.lang.model.element.RecordComponentElement;
 66 import javax.lang.model.element.TypeElement;
 67 import javax.lang.model.element.VariableElement;
 68 
 69 import javax.lang.model.type.ArrayType;
 70 import javax.lang.model.type.TypeMirror;
 71 
 72 import com.sun.tools.classfile.Annotation;
 73 import com.sun.tools.classfile.Attribute;
 74 import com.sun.tools.classfile.Attributes;
 75 import com.sun.tools.classfile.ClassFile;
 76 import com.sun.tools.classfile.ConstantPool;
 77 import com.sun.tools.classfile.ConstantPool.CPInfo;
 78 import com.sun.tools.classfile.Field;
 79 import com.sun.tools.classfile.Method;
 80 import com.sun.tools.classfile.Record_attribute;
 81 import com.sun.tools.classfile.Record_attribute.ComponentInfo;
 82 import com.sun.tools.classfile.RuntimeAnnotations_attribute;
 83 import com.sun.tools.classfile.RuntimeTypeAnnotations_attribute;
 84 import com.sun.tools.classfile.RuntimeVisibleAnnotations_attribute;
 85 import com.sun.tools.classfile.RuntimeVisibleParameterAnnotations_attribute;
 86 import com.sun.tools.classfile.RuntimeVisibleTypeAnnotations_attribute;
 87 import com.sun.tools.classfile.TypeAnnotation;
 88 
 89 import com.sun.tools.javac.code.Attribute.TypeCompound;
 90 import com.sun.tools.javac.code.Symbol;
 91 import com.sun.tools.javac.code.Symbol.VarSymbol;
 92 
 93 import org.testng.annotations.Test;
 94 import tools.javac.combo.CompilationTestCase;
 95 
 96 import static java.lang.annotation.ElementType.*;
 97 import static org.testng.Assert.assertEquals;
 98 
 99 @Test
100 public class RecordCompilationTests extends CompilationTestCase {
101 
102     // @@@ When records become a permanent feature, we don&#39;t need these any more
103     private static String[] PREVIEW_OPTIONS = {&quot;--enable-preview&quot;, &quot;-source&quot;,
104                                                Integer.toString(Runtime.version().feature())};
105 
106     private static final List&lt;String&gt; BAD_COMPONENT_NAMES = List.of(
107             &quot;clone&quot;, &quot;finalize&quot;, &quot;getClass&quot;, &quot;hashCode&quot;,
108             &quot;notify&quot;, &quot;notifyAll&quot;, &quot;toString&quot;, &quot;wait&quot;);
109 
110     {
111         setDefaultFilename(&quot;R.java&quot;);
112         setCompileOptions(PREVIEW_OPTIONS);
113     }
114 
115     public void testMalformedDeclarations() {
116         assertFail(&quot;compiler.err.premature.eof&quot;, &quot;record R()&quot;);
117         assertFail(&quot;compiler.err.premature.eof&quot;, &quot;record R();&quot;);
118         assertFail(&quot;compiler.err.illegal.start.of.type&quot;, &quot;record R(,) { }&quot;);
119         assertFail(&quot;compiler.err.illegal.start.of.type&quot;, &quot;record R((int x)) { }&quot;);
120         assertFail(&quot;compiler.err.record.header.expected&quot;, &quot;record R { }&quot;);
121         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(foo) { }&quot;);
122         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(int int) { }&quot;);
123         assertFail(&quot;compiler.err.mod.not.allowed.here&quot;, &quot;abstract record R(String foo) { }&quot;);
124         //assertFail(&quot;compiler.err.illegal.combination.of.modifiers&quot;, &quot;non-sealed record R(String foo) { }&quot;);
125         assertFail(&quot;compiler.err.repeated.modifier&quot;, &quot;public public record R(String foo) { }&quot;);
126         assertFail(&quot;compiler.err.repeated.modifier&quot;, &quot;private private record R(String foo) { }&quot;);
127         assertFail(&quot;compiler.err.already.defined&quot;, &quot;record R(int x, int x) {}&quot;);
128         for (String s : List.of(&quot;var&quot;, &quot;record&quot;))
129             assertFail(&quot;compiler.err.restricted.type.not.allowed.here&quot;, &quot;record R(# x) { }&quot;, s);
130         for (String s : List.of(&quot;public&quot;, &quot;private&quot;, &quot;volatile&quot;, &quot;final&quot;))
131             assertFail(&quot;compiler.err.record.cant.declare.field.modifiers&quot;, &quot;record R(# String foo) { }&quot;, s);
132         assertFail(&quot;compiler.err.varargs.must.be.last&quot;, &quot;record R(int... x, int... y) {}&quot;);
133         assertFail(&quot;compiler.err.instance.initializer.not.allowed.in.records&quot;, &quot;record R(int i) { {} }&quot;);
134     }
135 
136     public void testGoodDeclarations() {
137         assertOK(&quot;public record R() { }&quot;);
138         assertOK(&quot;record R() { }&quot;);
139         assertOK(&quot;record R() implements java.io.Serializable, Runnable { public void run() { } }&quot;);
140         assertOK(&quot;record R(int x) { }&quot;);
141         assertOK(&quot;record R(int x, int y) { }&quot;);
142         assertOK(&quot;record R(int... xs) { }&quot;);
143         assertOK(&quot;record R(String... ss) { }&quot;);
144         assertOK(&quot;@Deprecated record R(int x, int y) { }&quot;);
145         assertOK(&quot;record R(@Deprecated int x, int y) { }&quot;);
146         assertOK(&quot;record R&lt;T&gt;(T x, T y) { }&quot;);
147     }
148 
149     public void testGoodMemberDeclarations() {
150         String template = &quot;public record R(int x) {\n&quot;
151                 + &quot;    public R(int x) { this.x = x; }\n&quot;
152                 + &quot;    public int x() { return x; }\n&quot;
153                 + &quot;    public boolean equals(Object o) { return true; }\n&quot;
154                 + &quot;    public int hashCode() { return 0; }\n&quot;
155                 + &quot;    public String toString() { return null; }\n&quot;
156                 + &quot;}&quot;;
157         assertOK(template);
158     }
159 
160     public void testBadComponentNames() {
161         for (String s : BAD_COMPONENT_NAMES)
162             assertFail(&quot;compiler.err.illegal.record.component.name&quot;, &quot;record R(int #) { } &quot;, s);
163     }
164 
165     public void testRestrictedIdentifiers() {
166         for (String s : List.of(&quot;interface record { void m(); }&quot;,
167                 &quot;@interface record { }&quot;,
168                 &quot;class record { }&quot;,
169                 &quot;record record(int x) { }&quot;,
170                 &quot;enum record { A, B }&quot;,
171                 &quot;class R&lt;record&gt; { }&quot;)) {
172             assertFail(&quot;compiler.err.restricted.type.not.allowed&quot;, s);
173         }
174     }
175 
176     public void testValidMembers() {
177         for (String s : List.of(&quot;record X(int j) { }&quot;,
178                 &quot;interface I { }&quot;,
179                 &quot;static { }&quot;,
180                 &quot;enum E { A, B }&quot;,
181                 &quot;class C { }&quot;
182         )) {
183             assertOK(&quot;record R(int i) { # }&quot;, s);
184         }
185     }
186 
187     public void testCyclic() {
188         // Cyclic records are OK, but cyclic inline records would not be
189         assertOK(&quot;record R(R r) { }&quot;);
190     }
191 
192     public void testBadExtends() {
193         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(int x) extends Object { }&quot;);
194         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(int x) {}\n&quot;
195                 + &quot;record R2(int x) extends R { }&quot;);
196         assertFail(&quot;compiler.err.cant.inherit.from.final&quot;, &quot;record R(int x) {}\n&quot;
197                 + &quot;class C extends R { }&quot;);
198     }
199 
200     public void testNoExtendRecord() {
201         assertFail(&quot;compiler.err.invalid.supertype.record&quot;,
202                    &quot;class R extends Record { public String toString() { return null; } public int hashCode() { return 0; } public boolean equals(Object o) { return false; } } }&quot;);
203     }
204 
205     public void testFieldDeclarations() {
206         // static fields are OK
207         assertOK(&quot;public record R(int x) {\n&quot; +
208                 &quot;    static int I = 1;\n&quot; +
209                 &quot;    static final String S = \&quot;Hello World!\&quot;;\n&quot; +
210                 &quot;    static private Object O = null;\n&quot; +
211                 &quot;    static protected Object O2 = null;\n&quot; +
212                 &quot;}&quot;);
213 
214         // instance fields are not
215         assertFail(&quot;compiler.err.record.cannot.declare.instance.fields&quot;,
216                 &quot;public record R(int x) {\n&quot; +
217                         &quot;    private final int y = 0;&quot; +
218                         &quot;}&quot;);
219 
220         // mutable instance fields definitely not
221         assertFail(&quot;compiler.err.record.cannot.declare.instance.fields&quot;,
222                 &quot;public record R(int x) {\n&quot; +
223                         &quot;    private int y = 0;&quot; +
224                         &quot;}&quot;);
225 
226         // redeclaring components also not
227         assertFail(&quot;compiler.err.record.cannot.declare.instance.fields&quot;,
228                 &quot;public record R(int x) {\n&quot; +
229                         &quot;    private final int x;&quot; +
230                         &quot;}&quot;);
231     }
232 
233     public void testAccessorRedeclaration() {
234         assertOK(&quot;public record R(int x) {\n&quot; +
235                 &quot;    public int x() { return x; };&quot; +
236                 &quot;}&quot;);
237 
238         assertOK(&quot;public record R(int x) {\n&quot; +
239                 &quot;    public final int x() { return 0; };&quot; +
240                 &quot;}&quot;);
241 
242         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
243                 &quot;public record R(int x) {\n&quot; +
244                         &quot;    final int x() { return 0; };&quot; +
245                         &quot;}&quot;);
246 
247         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
248                 &quot;public record R(int x) {\n&quot; +
249                         &quot;    int x() { return 0; };&quot; +
250                         &quot;}&quot;);
251 
252         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
253                 &quot;public record R(int x) {\n&quot; +
254                         &quot;    private int x() { return 0; };&quot; +
255                         &quot;}&quot;);
256 
257         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
258                    &quot;public record R(int x) {\n&quot; +
259                    &quot;    public int x() throws Exception { return 0; };&quot; +
260                    &quot;}&quot;);
261 
262         for (String s : List.of(&quot;List&quot;, &quot;List&lt;?&gt;&quot;, &quot;Object&quot;, &quot;ArrayList&lt;String&gt;&quot;, &quot;int&quot;))
263             assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
264                     &quot;import java.util.*;\n&quot; +
265                             &quot;public record R(List&lt;String&gt; x) {\n&quot; +
266                             &quot;    public # x() { return null; };&quot; +
267                             &quot;}&quot;, s);
268 
269         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
270                 &quot;public record R(int x) {\n&quot; +
271                         &quot;    public &lt;T&gt; int x() { return x; };&quot; +
272                         &quot;}&quot;);
273 
274         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
275                 &quot;public record R(int x) {\n&quot; +
276                         &quot;    static private final j = 0;&quot; +
277                         &quot;    static public int x() { return j; };&quot; +
278                         &quot;}&quot;);
279     }
280 
281     public void testConstructorRedeclaration() {
282         for (String goodCtor : List.of(
283                 &quot;public R(int x) { this(x, 0); }&quot;,
284                 &quot;public R(int x, int y) { this.x = x; this.y = y; }&quot;,
285                 &quot;public R { }&quot;,
286                 &quot;public R { this.x = 0; }&quot;))
287             assertOK(&quot;record R(int x, int y) { # }&quot;, goodCtor);
288 
289         assertOK(&quot;import java.util.*; record R(String x, String y) {  public R { Objects.requireNonNull(x); Objects.requireNonNull(y); } }&quot;);
290 
291         // Not OK to redeclare canonical without DA
292         assertFail(&quot;compiler.err.var.might.not.have.been.initialized&quot;, &quot;record R(int x, int y) { # }&quot;,
293                    &quot;public R(int x, int y) { this.x = x; }&quot;);
294 
295         // Not OK to rearrange or change names
296         for (String s : List.of(&quot;public R(int y, int x) { this.x = x; this.y = y; }&quot;,
297                                 &quot;public R(int _x, int _y) { this.x = _x; this.y = _y; }&quot;))
298             assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x, int y) { # }&quot;, s);
299 
300         // canonical ctor must be public
301         for (String s : List.of(&quot;&quot;, &quot;protected&quot;, &quot;private&quot;))
302             assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x, int y) { # }&quot;,
303                        &quot;# R(int x, int y) { this.x = x; this.y = y; }&quot;,
304                        s);
305 
306         // ctor args must match types
307         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
308                 &quot;import java.util.*;\n&quot; +
309                         &quot;record R(List&lt;String&gt; list) { # }&quot;,
310                 &quot;R(List list) { this.list = list; }&quot;);
311 
312         // ctor should not add checked exceptions
313         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
314                    &quot;record R() { # }&quot;,
315                    &quot;public R() throws Exception { }&quot;);
316 
317         // not even checked exceptions
318         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
319                 &quot;record R() { # }&quot;,
320                  &quot;public R() throws IllegalArgumentException { }&quot;);
321 
322         // If types match, names must match
323         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
324                    &quot;record R(int x, int y) { public R(int y, int x) { this.x = this.y = 0; }}&quot;);
325 
326         // first invocation should be one to the canonical
327         assertFail(&quot;compiler.err.first.statement.must.be.call.to.another.constructor&quot;,
328                 &quot;record R(int x, int y) { public R(int y, int x, int z) { this.x = this.y = 0; } }&quot;);
329 
330         assertOK(&quot;record R(int x, int y) { &quot; +
331                  &quot;    public R(int x, int y, int z) { this(x, y); } &quot; +
332                  &quot;}&quot;);
333 
334         assertOK(&quot;record R(int x) { &quot; +
335                 &quot;    public R(int x, int y) { this(x, y, 0); } &quot; +
336                 &quot;    public R(int x, int y, int z) { this(x); } &quot; +
337                 &quot;}&quot;);
338 
339         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
340                 &quot;record R&lt;T&gt;(T a) { # }&quot;,
341                 &quot;public &lt;T&gt; R {}&quot;);
342 
343         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
344                 &quot;record R(int i) { # }&quot;,
345                 &quot;public &lt;T&gt; R(int i) { this.i = i; }&quot;);
346 
347         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
348                 &quot;record R&lt;T&gt;(T a) { # }&quot;,
349                 &quot;public &lt;T&gt; R(T a) { this.a = a; }&quot;);
350 
351         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
352                 &quot;record R(int a) { # }&quot;,
353                 &quot;public R(int a) { super(); this.a = a; }&quot;);
354     }
355 
356     public void testAnnotationCriteria() {
357         String imports = &quot;import java.lang.annotation.*;\n&quot;;
358         String template = &quot;@Target({ # }) @interface A {}\n&quot;;
359         EnumMap&lt;ElementType, String&gt; annotations = new EnumMap&lt;&gt;(ElementType.class);
360         for (ElementType e : values())
361             annotations.put(e, template.replace(&quot;#&quot;, &quot;ElementType.&quot; + e.name()));
362         EnumSet&lt;ElementType&gt; goodSet = EnumSet.of(RECORD_COMPONENT, FIELD, METHOD, PARAMETER, TYPE_USE);
363         EnumSet&lt;ElementType&gt; badSet = EnumSet.of(CONSTRUCTOR, PACKAGE, TYPE, LOCAL_VARIABLE, ANNOTATION_TYPE, TYPE_PARAMETER, MODULE);
364 
365         assertEquals(goodSet.size() + badSet.size(), values().length);
366         String A_GOOD = template.replace(&quot;#&quot;,
367                                          goodSet.stream().map(ElementType::name).map(s -&gt; &quot;ElementType.&quot; + s).collect(Collectors.joining(&quot;,&quot;)));
368         String A_BAD = template.replace(&quot;#&quot;,
369                                         badSet.stream().map(ElementType::name).map(s -&gt; &quot;ElementType.&quot; + s).collect(Collectors.joining(&quot;,&quot;)));
370         String A_ALL = template.replace(&quot;#&quot;,
371                                         Stream.of(ElementType.values()).map(ElementType::name).map(s -&gt; &quot;ElementType.&quot; + s).collect(Collectors.joining(&quot;,&quot;)));
372         String A_NONE = &quot;@interface A {}&quot;;
373 
374         for (ElementType e : goodSet)
375             assertOK(imports + annotations.get(e) + &quot;record R(@A int x) { }&quot;);
376         assertOK(imports + A_GOOD + &quot;record R(@A int x) { }&quot;);
377         assertOK(imports + A_ALL + &quot;record R(@A int x) { }&quot;);
378         assertOK(imports + A_NONE);
379 
380         for (ElementType e : badSet) {
381             assertFail(&quot;compiler.err.annotation.type.not.applicable&quot;, imports + annotations.get(e) + &quot;record R(@A int x) { }&quot;);
382         }
383 
384         assertFail(&quot;compiler.err.annotation.type.not.applicable&quot;, imports + A_BAD + &quot;record R(@A int x) { }&quot;);
385 
386         // TODO: OK to redeclare with or without same annos
387     }
388 
389     public void testNestedRecords() {
390         String template = &quot;class R { \n&quot; +
391                           &quot;    # record RR(int a) { }\n&quot; +
392                           &quot;}&quot;;
393 
394         for (String s : List.of(&quot;&quot;, &quot;static&quot;, &quot;final&quot;,
395                                 &quot;private&quot;, &quot;public&quot;, &quot;protected&quot;,
396                                 &quot;private static&quot;, &quot;public static&quot;, &quot;private static final&quot;))
397             assertOK(template, s);
398 
399         for (String s : List.of(&quot;class C { }&quot;,
400                                 &quot;static class C { }&quot;,
401                                 &quot;enum X { A; }&quot;,
402                                 &quot;interface I { }&quot;,
403                                 &quot;record RR(int y) { }&quot;))
404             assertOK(&quot;record R(int x) { # }&quot;, s);
405     }
406 
407     public void testDuplicatedMember() {
408         String template
409                 = &quot;    record R(int i) {\n&quot; +
410                   &quot;        public int i() { return i; }\n&quot; +
411                   &quot;        public int i() { return i; }\n&quot; +
412                   &quot;    }&quot;;
413         assertFail(&quot;compiler.err.already.defined&quot;, template);
414     }
415 
416     public void testLocalRecords() {
417         assertOK(&quot;class R { \n&quot; +
418                 &quot;    void m() { \n&quot; +
419                 &quot;        record RR(int x) { };\n&quot; +
420                 &quot;    }\n&quot; +
421                 &quot;}&quot;);
422 
423         // local records can also be final
424         assertOK(&quot;class R { \n&quot; +
425                 &quot;    void m() { \n&quot; +
426                 &quot;        final record RR(int x) { };\n&quot; +
427                 &quot;    }\n&quot; +
428                 &quot;}&quot;);
429 
430         // Cant capture locals
431         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
432                 &quot;class R { \n&quot; +
433                         &quot;    void m(int y) { \n&quot; +
434                         &quot;        record RR(int x) { public int x() { return y; }};\n&quot; +
435                         &quot;    }\n&quot; +
436                         &quot;}&quot;);
437 
438         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
439                 &quot;class R { \n&quot; +
440                         &quot;    void m() {\n&quot; +
441                         &quot;        int y;\n&quot; +
442                         &quot;        record RR(int x) { public int x() { return y; }};\n&quot; +
443                         &quot;    }\n&quot; +
444                         &quot;}&quot;);
445 
446         // instance fields
447         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
448                 &quot;class R { \n&quot; +
449                         &quot;    int z = 0;\n&quot; +
450                         &quot;    void m() { \n&quot; +
451                         &quot;        record RR(int x) { public int x() { return z; }};\n&quot; +
452                         &quot;    }\n&quot; +
453                         &quot;}&quot;);
454 
455         // or type variables
456         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
457                 &quot;class R&lt;T&gt; { \n&quot; +
458                         &quot;    void m() { \n&quot; +
459                         &quot;        record RR(T t) {};\n&quot; +
460                         &quot;    }\n&quot; +
461                         &quot;}&quot;);
462 
463         // but static fields are OK
464         assertOK(&quot;class R { \n&quot; +
465                 &quot;    static int z = 0;\n&quot; +
466                 &quot;    void m() { \n&quot; +
467                 &quot;        record RR(int x) { public int x() { return z; }};\n&quot; +
468                 &quot;    }\n&quot; +
469                 &quot;}&quot;);
470         // can be contained inside a lambda
471         assertOK(&quot;&quot;&quot;
472                 class Outer {
473                     Runnable run = () -&gt; {
474                         record TestRecord(int i) {}
475                     };
476                 }
477                 &quot;&quot;&quot;);
478 
479         // Can&#39;t self-shadow
480         assertFail(&quot;compiler.err.already.defined&quot;,
481                    &quot;class R { \n&quot; +
482                    &quot;    void m() { \n&quot; +
483                    &quot;        record R(int x) { };\n&quot; +
484                    &quot;    }\n&quot; +
485                    &quot;}&quot;);
486     }
487 
488     public void testCompactDADU() {
489         // trivial cases
490         assertOK(&quot;record R() { public R {} }&quot;);
491         assertOK(&quot;record R(int x) { public R {} }&quot;);
492 
493         // throwing an unchecked exception
494         assertOK(&quot;record R(int x) { public R { if (x &lt; 0) { this.x = x; throw new RuntimeException(); }} }&quot;);
495 
496         assertOK(&quot;record R(int x) { public R { if (x &lt; 0) { this.x = x; throw new RuntimeException(); }} }&quot;);
497 
498         // x is not DA nor DU in the body of the constructor hence error
499         assertFail(&quot;compiler.err.var.might.not.have.been.initialized&quot;, &quot;record R(int x) { # }&quot;,
500                 &quot;public R { if (x &lt; 0) { this.x = -x; } }&quot;);
501 
502         // if static fields are not DA then error
503         assertFail(&quot;compiler.err.var.might.not.have.been.initialized&quot;,
504                 &quot;record R() { # }&quot;, &quot;static final String x;&quot;);
505 
506         // ditto
507         assertFail(&quot;compiler.err.var.might.not.have.been.initialized&quot;,
508                 &quot;record R() { # }&quot;, &quot;static final String x; public R {}&quot;);
509 
510         // ditto
511         assertFail(&quot;compiler.err.var.might.not.have.been.initialized&quot;,
512                 &quot;record R(int i) { # }&quot;, &quot;static final String x; public R {}&quot;);
513     }
514 
515     public void testReturnInCanonical_Compact() {
516         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x) { # }&quot;,
517                 &quot;public R { return; }&quot;);
518         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x) { # }&quot;,
519                 &quot;public R { if (i &lt; 0) { return; }}&quot;);
520         assertOK(&quot;record R(int x) { public R(int x) { this.x = x; return; } }&quot;);
521         assertOK(&quot;record R(int x) { public R { Runnable r = () -&gt; { return; };} }&quot;);
522     }
523 
524     public void testArgumentsAreNotFinalInCompact() {
525         assertOK(
526                 &quot;&quot;&quot;
527                 record R(int x) {
528                     public R {
529                         x++;
530                     }
531                 }
532                 &quot;&quot;&quot;);
533     }
534 
535     public void testNoNativeMethods() {
536         assertFail(&quot;compiler.err.mod.not.allowed.here&quot;, &quot;record R(int x) { # }&quot;,
537                 &quot;public native R {}&quot;);
538         assertFail(&quot;compiler.err.mod.not.allowed.here&quot;, &quot;record R(int x) { # }&quot;,
539                 &quot;public native void m();&quot;);
540     }
541 
542     public void testRecordsInsideInner() {
543         assertFail(&quot;compiler.err.record.declaration.not.allowed.in.inner.classes&quot;,
544                 &quot;class Outer {\n&quot; +
545                 &quot;    class Inner {\n&quot; +
546                 &quot;        record R(int a) {}\n&quot; +
547                 &quot;    }\n&quot; +
548                 &quot;}&quot;);
549         assertFail(&quot;compiler.err.record.declaration.not.allowed.in.inner.classes&quot;,
550                 &quot;&quot;&quot;
551                 class Outer {
552                     public void test() {
553                         class Inner extends Outer {
554                             record R(int i) {}
555                         }
556                     }
557                 }
558                 &quot;&quot;&quot;);
559         assertFail(&quot;compiler.err.record.declaration.not.allowed.in.inner.classes&quot;,
560                 &quot;&quot;&quot;
561                 class Outer {
562                     Runnable run = new Runnable() {
563                         record TestRecord(int i) {}
564                         public void run() {}
565                     };
566                 }
567                 &quot;&quot;&quot;);
568         assertFail(&quot;compiler.err.record.declaration.not.allowed.in.inner.classes&quot;,
569                 &quot;&quot;&quot;
570                 class Outer {
571                     void m() {
572                         record A() {
573                             record B() { }
574                         }
575                     }
576                 }
577                 &quot;&quot;&quot;);
578     }
579 
580     public void testReceiverParameter() {
581         assertFail(&quot;compiler.err.receiver.parameter.not.applicable.constructor.toplevel.class&quot;,
582                 &quot;&quot;&quot;
583                 record R(int i) {
584                     public R(R this, int i) {
585                         this.i = i;
586                     }
587                 }
588                 &quot;&quot;&quot;);
589         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
590                 &quot;&quot;&quot;
591                 class Outer {
592                     record R(int i) {
593                         public R(Outer Outer.this, int i) {
594                             this.i = i;
595                         }
596                     }
597                 }
598                 &quot;&quot;&quot;);
599         assertOK(
600                 &quot;&quot;&quot;
601                 record R(int i) {
602                     void m(R this) {}
603                     public int i(R this) { return i; }
604                 }
605                 &quot;&quot;&quot;);
606     }
607 
608     public void testOnlyOneFieldRef() throws Exception {
609         int numberOfFieldRefs = 0;
610         File dir = assertOK(true, &quot;record R(int recordComponent) {}&quot;);
611         for (final File fileEntry : dir.listFiles()) {
612             if (fileEntry.getName().equals(&quot;R.class&quot;)) {
613                 ClassFile classFile = ClassFile.read(fileEntry);
614                 for (CPInfo cpInfo : classFile.constant_pool.entries()) {
615                     if (cpInfo instanceof ConstantPool.CONSTANT_Fieldref_info) {
616                         numberOfFieldRefs++;
617                         ConstantPool.CONSTANT_NameAndType_info nameAndType =
618                                 (ConstantPool.CONSTANT_NameAndType_info)classFile.constant_pool
619                                         .get(((ConstantPool.CONSTANT_Fieldref_info)cpInfo).name_and_type_index);
620                         Assert.check(nameAndType.getName().equals(&quot;recordComponent&quot;));
621                     }
622                 }
623             }
624         }
625         Assert.check(numberOfFieldRefs == 1);
626     }
627 
628     public void testAcceptRecordId() {
629         String[] testOptions = {/* no options */};
630         setCompileOptions(testOptions);
631         assertOKWithWarning(&quot;compiler.warn.restricted.type.not.allowed.preview&quot;,
632                 &quot;class R {\n&quot; +
633                 &quot;    record RR(int i) {\n&quot; +
634                 &quot;        return null;\n&quot; +
635                 &quot;    }\n&quot; +
636                 &quot;    class record {}\n&quot; +
637                 &quot;}&quot;);
638         setCompileOptions(PREVIEW_OPTIONS);
639     }
640 
641     public void testAnnos() throws Exception {
642         String srcTemplate =
643                 &quot;&quot;&quot;
644                     import java.lang.annotation.*;
645                     @Target({#TARGET})
646                     @Retention(RetentionPolicy.RUNTIME)
647                     @interface Anno { }
648 
649                     record R(@Anno String s) {}
650                 &quot;&quot;&quot;;
651 
652         // testing several combinations, adding even more combinations won&#39;t add too much value
653         List&lt;String&gt; annoApplicableTargets = List.of(
654                 &quot;ElementType.FIELD&quot;,
655                 &quot;ElementType.METHOD&quot;,
656                 &quot;ElementType.PARAMETER&quot;,
657                 &quot;ElementType.RECORD_COMPONENT&quot;,
658                 &quot;ElementType.TYPE_USE&quot;,
659                 &quot;ElementType.TYPE_USE,ElementType.FIELD&quot;,
660                 &quot;ElementType.TYPE_USE,ElementType.METHOD&quot;,
661                 &quot;ElementType.TYPE_USE,ElementType.PARAMETER&quot;,
662                 &quot;ElementType.TYPE_USE,ElementType.RECORD_COMPONENT&quot;,
663                 &quot;ElementType.TYPE_USE,ElementType.FIELD,ElementType.METHOD&quot;,
664                 &quot;ElementType.TYPE_USE,ElementType.FIELD,ElementType.PARAMETER&quot;,
665                 &quot;ElementType.TYPE_USE,ElementType.FIELD,ElementType.RECORD_COMPONENT&quot;,
666                 &quot;ElementType.FIELD,ElementType.TYPE_USE&quot;,
667                 &quot;ElementType.METHOD,ElementType.TYPE_USE&quot;,
668                 &quot;ElementType.PARAMETER,ElementType.TYPE_USE&quot;,
669                 &quot;ElementType.RECORD_COMPONENT,ElementType.TYPE_USE&quot;,
670                 &quot;ElementType.FIELD,ElementType.METHOD,ElementType.TYPE_USE&quot;,
671                 &quot;ElementType.FIELD,ElementType.PARAMETER,ElementType.TYPE_USE&quot;,
672                 &quot;ElementType.FIELD,ElementType.RECORD_COMPONENT,ElementType.TYPE_USE&quot;
673         );
674 
675         String[] generalOptions = {
676                 &quot;--enable-preview&quot;,
677                 &quot;-source&quot;, Integer.toString(Runtime.version().feature()),
678                 &quot;-processor&quot;, Processor.class.getName(),
679                 &quot;-Atargets=&quot;
680         };
681 
682         for (String target : annoApplicableTargets) {
683             String code = srcTemplate.replaceFirst(&quot;#TARGET&quot;, target);
684             String[] testOptions = generalOptions.clone();
685             testOptions[testOptions.length - 1] = testOptions[testOptions.length - 1] + target;
686             setCompileOptions(testOptions);
687 
688             File dir = assertOK(true, code);
689 
690             ClassFile classFile = ClassFile.read(findClassFileOrFail(dir, &quot;R.class&quot;));
691 
692             // field first
693             Assert.check(classFile.fields.length == 1);
694             Field field = classFile.fields[0];
695             /* if FIELD is one of the targets then there must be a declaration annotation applied to the field, apart from
696              * the type annotation
697              */
698             if (target.contains(&quot;FIELD&quot;)) {
699                 checkAnno(classFile,
700                         (RuntimeAnnotations_attribute)findAttributeOrFail(
701                                 field.attributes,
702                                 RuntimeVisibleAnnotations_attribute.class),
703                         &quot;Anno&quot;);
704             } else {
705                 assertAttributeNotPresent(field.attributes, RuntimeVisibleAnnotations_attribute.class);
706             }
707 
708             // lets check now for the type annotation
709             if (target.contains(&quot;TYPE_USE&quot;)) {
710                 checkTypeAnno(
711                         classFile,
712                         (RuntimeVisibleTypeAnnotations_attribute)findAttributeOrFail(field.attributes, RuntimeVisibleTypeAnnotations_attribute.class),
713                         &quot;FIELD&quot;,
714                         &quot;Anno&quot;);
715             } else {
716                 assertAttributeNotPresent(field.attributes, RuntimeVisibleTypeAnnotations_attribute.class);
717             }
718 
719             // checking for the annotation on the corresponding parameter of the canonical constructor
720             Method init = findMethodOrFail(classFile, &quot;&lt;init&gt;&quot;);
721             /* if PARAMETER is one of the targets then there must be a declaration annotation applied to the parameter, apart from
722              * the type annotation
723              */
724             if (target.contains(&quot;PARAMETER&quot;)) {
725                 checkParameterAnno(classFile,
726                         (RuntimeVisibleParameterAnnotations_attribute)findAttributeOrFail(
727                                 init.attributes,
728                                 RuntimeVisibleParameterAnnotations_attribute.class),
729                         &quot;Anno&quot;);
730             } else {
731                 assertAttributeNotPresent(init.attributes, RuntimeVisibleAnnotations_attribute.class);
732             }
733             // let&#39;s check now for the type annotation
734             if (target.contains(&quot;TYPE_USE&quot;)) {
735                 checkTypeAnno(
736                         classFile,
737                         (RuntimeVisibleTypeAnnotations_attribute) findAttributeOrFail(init.attributes, RuntimeVisibleTypeAnnotations_attribute.class),
738                         &quot;METHOD_FORMAL_PARAMETER&quot;, &quot;Anno&quot;);
739             } else {
740                 assertAttributeNotPresent(init.attributes, RuntimeVisibleTypeAnnotations_attribute.class);
741             }
742 
743             // checking for the annotation in the accessor
744             Method accessor = findMethodOrFail(classFile, &quot;s&quot;);
745             /* if METHOD is one of the targets then there must be a declaration annotation applied to the accessor, apart from
746              * the type annotation
747              */
748             if (target.contains(&quot;METHOD&quot;)) {
749                 checkAnno(classFile,
750                         (RuntimeAnnotations_attribute)findAttributeOrFail(
751                                 accessor.attributes,
752                                 RuntimeVisibleAnnotations_attribute.class),
753                         &quot;Anno&quot;);
754             } else {
755                 assertAttributeNotPresent(accessor.attributes, RuntimeVisibleAnnotations_attribute.class);
756             }
757             // let&#39;s check now for the type annotation
758             if (target.contains(&quot;TYPE_USE&quot;)) {
759                 checkTypeAnno(
760                         classFile,
761                         (RuntimeVisibleTypeAnnotations_attribute)findAttributeOrFail(accessor.attributes, RuntimeVisibleTypeAnnotations_attribute.class),
762                         &quot;METHOD_RETURN&quot;, &quot;Anno&quot;);
763             } else {
764                 assertAttributeNotPresent(accessor.attributes, RuntimeVisibleTypeAnnotations_attribute.class);
765             }
766 
767             // checking for the annotation in the Record attribute
768             Record_attribute record = (Record_attribute)findAttributeOrFail(classFile.attributes, Record_attribute.class);
769             Assert.check(record.component_count == 1);
770             /* if RECORD_COMPONENT is one of the targets then there must be a declaration annotation applied to the
771              * field, apart from the type annotation
772              */
773             if (target.contains(&quot;RECORD_COMPONENT&quot;)) {
774                 checkAnno(classFile,
775                         (RuntimeAnnotations_attribute)findAttributeOrFail(
776                                 record.component_info_arr[0].attributes,
777                                 RuntimeVisibleAnnotations_attribute.class),
778                         &quot;Anno&quot;);
779             } else {
780                 assertAttributeNotPresent(record.component_info_arr[0].attributes, RuntimeVisibleAnnotations_attribute.class);
781             }
782             // lets check now for the type annotation
783             if (target.contains(&quot;TYPE_USE&quot;)) {
784                 checkTypeAnno(
785                         classFile,
786                         (RuntimeVisibleTypeAnnotations_attribute)findAttributeOrFail(
787                                 record.component_info_arr[0].attributes,
788                                 RuntimeVisibleTypeAnnotations_attribute.class),
789                         &quot;FIELD&quot;, &quot;Anno&quot;);
790             } else {
791                 assertAttributeNotPresent(record.component_info_arr[0].attributes, RuntimeVisibleTypeAnnotations_attribute.class);
792             }
793         }
794 
795         // let&#39;s reset the default compiler options for other tests
796         setCompileOptions(PREVIEW_OPTIONS);
797     }
798 
799     private void checkTypeAnno(ClassFile classFile,
800                                RuntimeTypeAnnotations_attribute rtAnnos,
801                                String positionType,
802                                String annoName) throws Exception {
803         // containing only one type annotation
804         Assert.check(rtAnnos.annotations.length == 1);
805         TypeAnnotation tAnno = (TypeAnnotation)rtAnnos.annotations[0];
806         Assert.check(tAnno.position.type.toString().equals(positionType));
807         String annotationName = classFile.constant_pool.getUTF8Value(tAnno.annotation.type_index).toString().substring(1);
808         Assert.check(annotationName.startsWith(annoName));
809     }
810 
811     private void checkAnno(ClassFile classFile,
812                            RuntimeAnnotations_attribute rAnnos,
813                            String annoName) throws Exception {
814         // containing only one type annotation
815         Assert.check(rAnnos.annotations.length == 1);
816         Annotation anno = (Annotation)rAnnos.annotations[0];
817         String annotationName = classFile.constant_pool.getUTF8Value(anno.type_index).toString().substring(1);
818         Assert.check(annotationName.startsWith(annoName));
819     }
820 
821     // special case for parameter annotations
822     private void checkParameterAnno(ClassFile classFile,
823                            RuntimeVisibleParameterAnnotations_attribute rAnnos,
824                            String annoName) throws Exception {
825         // containing only one type annotation
826         Assert.check(rAnnos.parameter_annotations.length == 1);
827         Assert.check(rAnnos.parameter_annotations[0].length == 1);
828         Annotation anno = (Annotation)rAnnos.parameter_annotations[0][0];
829         String annotationName = classFile.constant_pool.getUTF8Value(anno.type_index).toString().substring(1);
830         Assert.check(annotationName.startsWith(annoName));
831     }
832 
833     private File findClassFileOrFail(File dir, String name) {
834         for (final File fileEntry : dir.listFiles()) {
835             if (fileEntry.getName().equals(&quot;R.class&quot;)) {
836                 return fileEntry;
837             }
838         }
839         throw new AssertionError(&quot;file not found&quot;);
840     }
841 
842     private Method findMethodOrFail(ClassFile classFile, String name) throws Exception {
843         for (Method method : classFile.methods) {
844             if (method.getName(classFile.constant_pool).equals(name)) {
845                 return method;
846             }
847         }
848         throw new AssertionError(&quot;method not found&quot;);
849     }
850 
851     private Attribute findAttributeOrFail(Attributes attributes, Class&lt;? extends Attribute&gt; attrClass) {
852         for (Attribute attribute : attributes) {
853             if (attribute.getClass() == attrClass) {
854                 return attribute;
855             }
856         }
857         throw new AssertionError(&quot;attribute not found&quot;);
858     }
859 
860     private void assertAttributeNotPresent(Attributes attributes, Class&lt;? extends Attribute&gt; attrClass) {
861         for (Attribute attribute : attributes) {
862             if (attribute.getClass() == attrClass) {
863                 throw new AssertionError(&quot;attribute not expected&quot;);
864             }
865         }
866     }
867 
868     @SupportedAnnotationTypes(&quot;*&quot;)
869     public static final class Processor extends JavacTestingAbstractProcessor {
870 
871         String targets;
872         int numberOfTypeAnnotations;
873 
874         @Override
875         public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
876             targets = processingEnv.getOptions().get(&quot;targets&quot;);
877             for (TypeElement te : annotations) {
878                 if (te.toString().equals(&quot;Anno&quot;)) {
879                     checkElements(te, roundEnv, targets);
880                     if (targets.contains(&quot;TYPE_USE&quot;)) {
881                         Element element = processingEnv.getElementUtils().getTypeElement(&quot;R&quot;);
882                         numberOfTypeAnnotations = 0;
883                         checkTypeAnnotations(element);
884                         Assert.check(numberOfTypeAnnotations == 4);
885                     }
886                 }
887             }
888             return true;
889         }
890 
891         void checkElements(TypeElement te, RoundEnvironment renv, String targets) {
892             Set&lt;? extends Element&gt; annoElements = renv.getElementsAnnotatedWith(te);
893             Set&lt;String&gt; targetSet = new HashSet&lt;&gt;(Arrays.asList(targets.split(&quot;,&quot;)));
894             // we will check for type annotation in another method
895             targetSet.remove(&quot;ElementType.TYPE_USE&quot;);
896             for (Element e : annoElements) {
897                 Symbol s = (Symbol) e;
898                 switch (s.getKind()) {
899                     case FIELD:
900                         Assert.check(targetSet.contains(&quot;ElementType.FIELD&quot;));
901                         targetSet.remove(&quot;ElementType.FIELD&quot;);
902                         break;
903                     case METHOD:
904                         Assert.check(targetSet.contains(&quot;ElementType.METHOD&quot;));
905                         targetSet.remove(&quot;ElementType.METHOD&quot;);
906                         break;
907                     case PARAMETER:
908                         Assert.check(targetSet.contains(&quot;ElementType.PARAMETER&quot;));
909                         targetSet.remove(&quot;ElementType.PARAMETER&quot;);
910                         break;
911                     case RECORD_COMPONENT:
912                         Assert.check(targetSet.contains(&quot;ElementType.RECORD_COMPONENT&quot;));
913                         targetSet.remove(&quot;ElementType.RECORD_COMPONENT&quot;);
914                         break;
915                     default:
916                         throw new AssertionError(&quot;unexpected element kind&quot;);
917                 }
918             }
919             Assert.check(targetSet.isEmpty(), targetSet.toString());
920         }
921 
922         private void checkTypeAnnotations(Element rootElement) {
923             new ElementScanner&lt;Void, Void&gt;() {
924                 @Override public Void visitVariable(VariableElement e, Void p) {
925                     Symbol s = (Symbol) e;
926                     if (s.getKind() == ElementKind.FIELD ||
927                             s.getKind() == ElementKind.PARAMETER &amp;&amp;
928                             s.name.toString().equals(&quot;s&quot;)) {
929                         int currentTAs = numberOfTypeAnnotations;
930                         verifyTypeAnnotations(e.asType().getAnnotationMirrors());
931                         Assert.check(currentTAs + 1 == numberOfTypeAnnotations);
932                     }
933                     return null;
934                 }
935                 @Override
936                 public Void visitExecutable(ExecutableElement e, Void p) {
937                     Symbol s = (Symbol) e;
938                     if (s.getKind() == ElementKind.METHOD &amp;&amp;
939                                     s.name.toString().equals(&quot;s&quot;)) {
940                         int currentTAs = numberOfTypeAnnotations;
941                         verifyTypeAnnotations(e.getReturnType().getAnnotationMirrors());
942                         Assert.check(currentTAs + 1 == numberOfTypeAnnotations);
943                     }
944                     scan(e.getParameters(), p);
945                     return null;
946                 }
947                 @Override public Void visitRecordComponent(RecordComponentElement e, Void p) {
948                     int currentTAs = numberOfTypeAnnotations;
949                     verifyTypeAnnotations(e.asType().getAnnotationMirrors());
950                     Assert.check(currentTAs + 1 == numberOfTypeAnnotations);
951                     return null;
952                 }
953             }.scan(rootElement, null);
954         }
955 
956         private void verifyTypeAnnotations(Iterable&lt;? extends AnnotationMirror&gt; annotations) {
957             for (AnnotationMirror mirror : annotations) {
958                 Assert.check(mirror.toString().startsWith(&quot;@Anno&quot;));
959                 if (mirror instanceof TypeCompound) {
960                     numberOfTypeAnnotations++;
961                 }
962             }
963         }
964 
965     }
966 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/net/httpclient/HandshakeFailureTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
<a name="2" id="anc2"></a><span class="line-modified"> 24 import static java.lang.System.out;</span>
<span class="line-modified"> 25 import static java.net.http.HttpResponse.BodyHandlers.discarding;</span>
<span class="line-modified"> 26 </span>


 27 import java.io.DataInputStream;
 28 import java.io.IOException;
 29 import java.io.UncheckedIOException;
 30 import java.net.InetAddress;
 31 import java.net.InetSocketAddress;
 32 import java.net.ServerSocket;
 33 import java.net.Socket;
 34 import java.net.URI;
<a name="3" id="anc3"></a>


 35 import java.net.http.HttpClient;
 36 import java.net.http.HttpClient.Version;
<a name="4" id="anc4"></a>
 37 import java.net.http.HttpRequest;
<a name="5" id="anc5"></a><span class="line-modified"> 38 import java.net.http.HttpResponse;</span>
<span class="line-modified"> 39 import java.util.List;</span>
<span class="line-added"> 40 import java.util.Locale;</span>
<span class="line-added"> 41 import java.util.concurrent.CompletableFuture;</span>
<span class="line-added"> 42 import java.util.concurrent.CompletionException;</span>
<span class="line-added"> 43 </span>
<span class="line-added"> 44 import javax.net.ServerSocketFactory;</span>
<span class="line-added"> 45 import javax.net.ssl.SSLContext;</span>
<span class="line-added"> 46 import javax.net.ssl.SSLHandshakeException;</span>
<span class="line-added"> 47 import javax.net.ssl.SSLParameters;</span>
<span class="line-added"> 48 import javax.net.ssl.SSLSocket;</span>
 49 
 50 /**
 51  * @test
<a name="6" id="anc6"></a><span class="line-modified"> 52  * @bug 8238990</span>
<span class="line-added"> 53  * @run main/othervm -Djdk.internal.httpclient.debug=true HandshakeFailureTest TLSv1.2</span>
<span class="line-added"> 54  * @run main/othervm -Djdk.internal.httpclient.debug=true HandshakeFailureTest TLSv1.3</span>
 55  * @summary Verify SSLHandshakeException is received when the handshake fails,
<a name="7" id="anc7"></a><span class="line-modified"> 56  * either because the server closes (EOF) the connection during handshaking,</span>
<span class="line-modified"> 57  * or no cipher suite can be negotiated (TLSv1.2) or no available authentication</span>
<span class="line-added"> 58  * scheme (TLSv1.3).</span>
 59  */
 60 // To switch on debugging use:
 61 // @run main/othervm -Djdk.internal.httpclient.debug=true HandshakeFailureTest
 62 public class HandshakeFailureTest {
 63 
 64     // The number of iterations each testXXXClient performs. Can be increased
 65     // when running standalone testing.
 66     static final int TIMES = 10;
 67 
<a name="8" id="anc8"></a><span class="line-added"> 68     private static String tlsProtocol;</span>
<span class="line-added"> 69     private static int maxWsaeConnAborted;</span>
<span class="line-added"> 70 </span>
<span class="line-added"> 71     // On Microsoft Windows, a WSAECONNABORTED error could be raised</span>
<span class="line-added"> 72     // if the client side fails to retransmit a TCP packet.</span>
<span class="line-added"> 73     // This could happen if for instance, the server stops reading and</span>
<span class="line-added"> 74     // close the socket while the client is still trying to push</span>
<span class="line-added"> 75     // data through.</span>
<span class="line-added"> 76     // With TLSv1.3, and our dummy SSLServer implementation below,</span>
<span class="line-added"> 77     // this can occur quite often.</span>
<span class="line-added"> 78     // Our HTTP stack should automatically wrap such exceptions</span>
<span class="line-added"> 79     // in SSLHandshakeException if they are raised while the handshake</span>
<span class="line-added"> 80     // in progress. So it would be an error to receive WSAECONNABORTED</span>
<span class="line-added"> 81     // here. This test has some special code to handle WSAECONNABORTED</span>
<span class="line-added"> 82     // and fail if they reach the test code.</span>
<span class="line-added"> 83     public static final String WSAECONNABORTED_MSG =</span>
<span class="line-added"> 84             &quot;An established connection was aborted by the software in your host machine&quot;;</span>
<span class="line-added"> 85     public static final boolean isWindows = System.getProperty(&quot;os.name&quot;, &quot;&quot;)</span>
<span class="line-added"> 86             .toLowerCase(Locale.ROOT).contains(&quot;win&quot;);</span>
<span class="line-added"> 87     public enum ExpectedExceptionType {</span>
<span class="line-added"> 88         HANDSHAKE_FAILURE,</span>
<span class="line-added"> 89         WSAECONNABORTED</span>
<span class="line-added"> 90     }</span>
<span class="line-added"> 91 </span>
<span class="line-added"> 92     // The exception checker is used to record how many WSAECONNABORTED</span>
<span class="line-added"> 93     // have reached the test code. There should be none:</span>
<span class="line-added"> 94     // (usually max should be 0)</span>
<span class="line-added"> 95     static final class ExceptionChecker {</span>
<span class="line-added"> 96         int count;</span>
<span class="line-added"> 97         Throwable aborted = null;</span>
<span class="line-added"> 98         public void check(Throwable expected) {</span>
<span class="line-added"> 99             if (ExpectedExceptionType.WSAECONNABORTED == checkExceptionOrCause(expected)) {</span>
<span class="line-added">100                 count++;</span>
<span class="line-added">101                 aborted = expected;</span>
<span class="line-added">102             }</span>
<span class="line-added">103         }</span>
<span class="line-added">104         public void check(int max) {</span>
<span class="line-added">105             if (count &gt; max) {</span>
<span class="line-added">106                 out.println(&quot;WSAECONNABORTED received too many times: &quot; + count);</span>
<span class="line-added">107                 aborted.printStackTrace(out);</span>
<span class="line-added">108                 throw new AssertionError(&quot;WSAECONNABORTED received too many times: &quot; + count, aborted);</span>
<span class="line-added">109             }</span>
<span class="line-added">110         }</span>
<span class="line-added">111     }</span>
<span class="line-added">112 </span>
113     public static void main(String[] args) throws Exception {
<a name="9" id="anc9"></a><span class="line-added">114         tlsProtocol = args[0];</span>
<span class="line-added">115         // At this time, all WSAECONNABORTED exception raised during</span>
<span class="line-added">116         // the handshake should have been wrapped in SSLHandshakeException,</span>
<span class="line-added">117         // so we allow none to reach here.</span>
<span class="line-added">118         maxWsaeConnAborted = 0;</span>
<span class="line-added">119 </span>
120         HandshakeFailureTest test = new HandshakeFailureTest();
<a name="10" id="anc10"></a><span class="line-modified">121         List&lt;AbstractServer&gt; servers = List.of(new PlainServer(), new SSLServer());</span>
122 
123         for (AbstractServer server : servers) {
124             try (server) {
125                 out.format(&quot;%n%n------ Testing with server:%s ------%n&quot;, server);
<a name="11" id="anc11"></a><span class="line-modified">126                 URI uri = new URI(&quot;https://&quot; + server.getAuthority() + &quot;/&quot;);</span>
127 
128                 test.testSyncSameClient(uri, Version.HTTP_1_1);
129                 test.testSyncSameClient(uri, Version.HTTP_2);
130                 test.testSyncDiffClient(uri, Version.HTTP_1_1);
131                 test.testSyncDiffClient(uri, Version.HTTP_2);
132 
133                 test.testAsyncSameClient(uri, Version.HTTP_1_1);
134                 test.testAsyncSameClient(uri, Version.HTTP_2);
135                 test.testAsyncDiffClient(uri, Version.HTTP_1_1);
136                 test.testAsyncDiffClient(uri, Version.HTTP_2);
137             }
138         }
139     }
140 
141     static HttpClient getClient() {
142         SSLParameters params = new SSLParameters();
<a name="12" id="anc12"></a><span class="line-modified">143         params.setProtocols(new String[] { tlsProtocol });</span>
144         return HttpClient.newBuilder()
145                 .sslParameters(params)
146                 .build();
147     }
148 
149     void testSyncSameClient(URI uri, Version version) throws Exception {
150         out.printf(&quot;%n--- testSyncSameClient %s ---%n&quot;, version);
151         HttpClient client = getClient();
<a name="13" id="anc13"></a><span class="line-added">152         ExceptionChecker exceptionChecker = new ExceptionChecker();</span>
153         for (int i = 0; i &lt; TIMES; i++) {
154             out.printf(&quot;iteration %d%n&quot;, i);
155             HttpRequest request = HttpRequest.newBuilder(uri)
156                                              .version(version)
157                                              .build();
158             try {
159                 HttpResponse&lt;Void&gt; response = client.send(request, discarding());
160                 String msg = String.format(&quot;UNEXPECTED response=%s%n&quot;, response);
161                 throw new RuntimeException(msg);
162             } catch (IOException expected) {
163                 out.printf(&quot;Client: caught expected exception: %s%n&quot;, expected);
<a name="14" id="anc14"></a><span class="line-modified">164                 exceptionChecker.check(expected);</span>
165             }
166         }
<a name="15" id="anc15"></a><span class="line-added">167         exceptionChecker.check(maxWsaeConnAborted);</span>
168     }
169 
170     void testSyncDiffClient(URI uri, Version version) throws Exception {
171         out.printf(&quot;%n--- testSyncDiffClient %s ---%n&quot;, version);
<a name="16" id="anc16"></a><span class="line-added">172         ExceptionChecker exceptionChecker = new ExceptionChecker();</span>
173         for (int i = 0; i &lt; TIMES; i++) {
174             out.printf(&quot;iteration %d%n&quot;, i);
175             // a new client each time
176             HttpClient client = getClient();
177             HttpRequest request = HttpRequest.newBuilder(uri)
178                                              .version(version)
179                                              .build();
180             try {
181                 HttpResponse&lt;Void&gt; response = client.send(request, discarding());
182                 String msg = String.format(&quot;UNEXPECTED response=%s%n&quot;, response);
183                 throw new RuntimeException(msg);
184             } catch (IOException expected) {
185                 out.printf(&quot;Client: caught expected exception: %s%n&quot;, expected);
<a name="17" id="anc17"></a><span class="line-modified">186                 exceptionChecker.check(expected);</span>
187             }
188         }
<a name="18" id="anc18"></a><span class="line-added">189         exceptionChecker.check(maxWsaeConnAborted);</span>
190     }
191 
192     void testAsyncSameClient(URI uri, Version version) throws Exception {
193         out.printf(&quot;%n--- testAsyncSameClient %s ---%n&quot;, version);
194         HttpClient client = getClient();
<a name="19" id="anc19"></a><span class="line-added">195         ExceptionChecker exceptionChecker = new ExceptionChecker();</span>
196         for (int i = 0; i &lt; TIMES; i++) {
197             out.printf(&quot;iteration %d%n&quot;, i);
198             HttpRequest request = HttpRequest.newBuilder(uri)
199                                              .version(version)
200                                              .build();
201             CompletableFuture&lt;HttpResponse&lt;Void&gt;&gt; response =
202                         client.sendAsync(request, discarding());
203             try {
204                 response.join();
205                 String msg = String.format(&quot;UNEXPECTED response=%s%n&quot;, response);
206                 throw new RuntimeException(msg);
207             } catch (CompletionException ce) {
208                 Throwable expected = ce.getCause();
209                 out.printf(&quot;Client: caught expected exception: %s%n&quot;, expected);
<a name="20" id="anc20"></a><span class="line-modified">210                 exceptionChecker.check(expected);</span>
211             }
212         }
<a name="21" id="anc21"></a><span class="line-added">213         exceptionChecker.check(maxWsaeConnAborted);</span>
214     }
215 
216     void testAsyncDiffClient(URI uri, Version version) throws Exception {
217         out.printf(&quot;%n--- testAsyncDiffClient %s ---%n&quot;, version);
<a name="22" id="anc22"></a><span class="line-added">218         ExceptionChecker exceptionChecker = new ExceptionChecker();</span>
219         for (int i = 0; i &lt; TIMES; i++) {
220             out.printf(&quot;iteration %d%n&quot;, i);
221             // a new client each time
222             HttpClient client = getClient();
223             HttpRequest request = HttpRequest.newBuilder(uri)
224                                              .version(version)
225                                              .build();
226             CompletableFuture&lt;HttpResponse&lt;Void&gt;&gt; response =
227                     client.sendAsync(request, discarding());
228             try {
229                 response.join();
230                 String msg = String.format(&quot;UNEXPECTED response=%s%n&quot;, response);
231                 throw new RuntimeException(msg);
232             } catch (CompletionException ce) {
233                 ce.printStackTrace(out);
234                 Throwable expected = ce.getCause();
235                 out.printf(&quot;Client: caught expected exception: %s%n&quot;, expected);
<a name="23" id="anc23"></a><span class="line-modified">236                 exceptionChecker.check(expected);</span>
237             }
238         }
<a name="24" id="anc24"></a><span class="line-added">239         exceptionChecker.check(maxWsaeConnAborted);</span>
240     }
241 
<a name="25" id="anc25"></a><span class="line-modified">242     // Tells whether this exception was raised from a WSAECONNABORTED</span>
<span class="line-added">243     // error raised in the native code.</span>
<span class="line-added">244     static boolean isWsaeConnAborted(Throwable t) {</span>
<span class="line-added">245         return t instanceof IOException &amp;&amp; WSAECONNABORTED_MSG.equalsIgnoreCase(t.getMessage());</span>
<span class="line-added">246     }</span>
<span class="line-added">247 </span>
<span class="line-added">248     // We might allow some spurious WSAECONNABORTED exception.</span>
<span class="line-added">249     // The decision whether to allow such errors or not is taken by</span>
<span class="line-added">250     // the ExceptionChecker</span>
<span class="line-added">251     static ExpectedExceptionType checkExceptionOrCause(Throwable t) {</span>
252         final Throwable original = t;
253         do {
<a name="26" id="anc26"></a><span class="line-modified">254             if (SSLHandshakeException.class.isInstance(t)) {</span>
<span class="line-added">255                 // For TLSv1.3, possibly the server is (being) closed when</span>
<span class="line-added">256                 // the client read the input alert. In this case, the client</span>
<span class="line-added">257                 // just gets SocketException instead of SSLHandshakeException.</span>
258                 System.out.println(&quot;Found expected exception/cause: &quot; + t);
<a name="27" id="anc27"></a><span class="line-modified">259                 return ExpectedExceptionType.HANDSHAKE_FAILURE;</span>
<span class="line-added">260             }</span>
<span class="line-added">261             if (isWindows &amp;&amp; isWsaeConnAborted(t)) {</span>
<span class="line-added">262                 System.out.println(&quot;Found WSAECONNABORTED: &quot; + t);</span>
<span class="line-added">263                 return ExpectedExceptionType.WSAECONNABORTED;</span>
264             }
265         } while ((t = t.getCause()) != null);
266         original.printStackTrace(System.out);
<a name="28" id="anc28"></a><span class="line-modified">267         throw new RuntimeException(</span>
<span class="line-added">268                 &quot;Not found expected SSLHandshakeException in &quot;</span>
<span class="line-added">269                         + original);</span>
270     }
271 
<a name="29" id="anc29"></a><span class="line-modified">272     /** Common super type for PlainServer and SSLServer. */</span>
273     static abstract class AbstractServer extends Thread implements AutoCloseable {
274         protected final ServerSocket ss;
275         protected volatile boolean closed;
276 
277         AbstractServer(String name, ServerSocket ss) throws IOException {
278             super(name);
279             ss.setReuseAddress(false);
280             ss.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));
281             this.ss = ss;
282             this.start();
283         }
284 
285         int getPort() { return ss.getLocalPort(); }
286 
<a name="30" id="anc30"></a><span class="line-added">287         String getAuthority() {</span>
<span class="line-added">288             String address = ss.getInetAddress().getHostAddress();</span>
<span class="line-added">289             if (address.contains(&quot;:&quot;)) address = &quot;[&quot; + address + &quot;]&quot;;</span>
<span class="line-added">290             return address + &quot;:&quot; + ss.getLocalPort();</span>
<span class="line-added">291         }</span>
<span class="line-added">292 </span>
293         @Override
294         public void close() {
295             if (closed)
296                 return;
297             closed = true;
298             try {
299                 ss.close();
300             } catch (IOException e) {
301                 throw new UncheckedIOException(&quot;Unexpected&quot;, e);
302             }
303         }
304     }
305 
306     /** Emulates a server-side, using plain cleartext Sockets, that just closes
307      * the connection, after a small variable delay. */
308     static class PlainServer extends AbstractServer {
309         private volatile int count;
310 
311         PlainServer() throws IOException {
312             super(&quot;PlainServer&quot;, new ServerSocket());
313         }
314 
315         @Override
316         public void run() {
317             while (!closed) {
318                 try (Socket s = ss.accept()) {
319                     count++;
320 
321                     /*   SSL record layer - contains the client hello
322                     struct {
323                         uint8 major, minor;
324                     } ProtocolVersion;
325 
326                     enum {
327                         change_cipher_spec(20), alert(21), handshake(22),
328                         application_data(23), (255)
329                     } ContentType;
330 
331                     struct {
332                         ContentType type;
333                         ProtocolVersion version;
334                         uint16 length;
335                         opaque fragment[SSLPlaintext.length];
336                     } SSLPlaintext;   */
337                     DataInputStream din =  new DataInputStream(s.getInputStream());
338                     int contentType = din.read();
339                     out.println(&quot;ContentType:&quot; + contentType);
340                     int majorVersion = din.read();
341                     out.println(&quot;Major:&quot; + majorVersion);
342                     int minorVersion = din.read();
343                     out.println(&quot;Minor:&quot; + minorVersion);
344                     int length = din.readShort();
345                     out.println(&quot;length:&quot; + length);
346                     byte[] ba = new byte[length];
347                     din.readFully(ba);
348 
349                     // simulate various delays in response
350                     Thread.sleep(10 * (count % 10));
351                     s.close(); // close without giving any reply
352                 } catch (IOException e) {
<a name="31" id="anc31"></a><span class="line-modified">353                     if (!closed) {</span>
<span class="line-modified">354                         out.println(&quot;PlainServer: unexpected &quot; + e);</span>
<span class="line-added">355                         e.printStackTrace(out);</span>
<span class="line-added">356                     }</span>
357                 } catch (InterruptedException e) {
<a name="32" id="anc32"></a><span class="line-modified">358                     if (!closed) {</span>
<span class="line-added">359                         out.println(&quot;PlainServer: unexpected &quot; + e);</span>
<span class="line-added">360                         e.printStackTrace(out);</span>
<span class="line-added">361                         throw new RuntimeException(e);</span>
<span class="line-added">362                     }</span>
<span class="line-added">363                     break;</span>
<span class="line-added">364                 } catch (Error | RuntimeException e) {</span>
<span class="line-added">365                     if (!closed) {</span>
<span class="line-added">366                         out.println(&quot;PlainServer: unexpected &quot; + e);</span>
<span class="line-added">367                         e.printStackTrace(out);</span>
<span class="line-added">368                         throw new RuntimeException(e);</span>
<span class="line-added">369                     }</span>
<span class="line-added">370                     break;</span>
371                 }
372             }
373         }
374     }
375 
376     /** Emulates a server-side, using SSL Sockets, that will fail during
<a name="33" id="anc33"></a><span class="line-modified">377      * handshaking, as there are no cipher suites in common (TLSv1.2)</span>
<span class="line-added">378      * or no available authentication scheme (TLSv1.3). */</span>
379     static class SSLServer extends AbstractServer {
380         static final SSLContext sslContext = createUntrustingContext();
381         static final ServerSocketFactory factory = sslContext.getServerSocketFactory();
382 
383         static SSLContext createUntrustingContext() {
384             try {
<a name="34" id="anc34"></a><span class="line-modified">385                 SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);</span>
386                 sslContext.init(null, null, null);
387                 return sslContext;
388             } catch (Throwable t) {
389                 throw new AssertionError(t);
390             }
391         }
392 
393         SSLServer() throws IOException {
394             super(&quot;SSLServer&quot;, factory.createServerSocket());
395         }
396 
397         @Override
398         public void run() {
399             while (!closed) {
400                 try (SSLSocket s = (SSLSocket)ss.accept()) {
401                     s.getInputStream().read();  // will throw SHE here
402 
403                     throw new AssertionError(&quot;Should not reach here&quot;);
404                 } catch (SSLHandshakeException expected) {
<a name="35" id="anc35"></a><span class="line-modified">405                     // Expected: SSLHandshakeException: no cipher suites in common (TLSv1.2)</span>
<span class="line-modified">406                     // or no available authentication scheme (TLSv1.3)</span>
<span class="line-added">407                     out.printf(&quot;SSLServer: caught expected exception: %s%n&quot;, expected);</span>
408                 } catch (IOException e) {
<a name="36" id="anc36"></a><span class="line-modified">409                     if (!closed) {</span>
<span class="line-modified">410                         out.println(&quot;SSLServer: unexpected &quot; + e);</span>
<span class="line-added">411                         e.printStackTrace(out);</span>
<span class="line-added">412                     }</span>
<span class="line-added">413                 } catch (Error | RuntimeException e) {</span>
<span class="line-added">414                     if (!closed) {</span>
<span class="line-added">415                         out.println(&quot;SSLServer: unexpected &quot; + e);</span>
<span class="line-added">416                         e.printStackTrace(out);</span>
<span class="line-added">417                         throw new RuntimeException(e);</span>
<span class="line-added">418                     }</span>
<span class="line-added">419                     break;</span>
420                 }
421             }
422         }
423     }
424 }
<a name="37" id="anc37"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="37" type="hidden" />
</body>
</html>
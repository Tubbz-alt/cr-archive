<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/util/regex/RegExTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /**
  25  * @test
  26  * @summary tests RegExp framework (use -Dseed=X to set PRNG seed)
  27  * @author Mike McCloskey
  28  * @bug 4481568 4482696 4495089 4504687 4527731 4599621 4631553 4619345
  29  * 4630911 4672616 4711773 4727935 4750573 4792284 4803197 4757029 4808962
  30  * 4872664 4803179 4892980 4900747 4945394 4938995 4979006 4994840 4997476
  31  * 5013885 5003322 4988891 5098443 5110268 6173522 4829857 5027748 6376940
  32  * 6358731 6178785 6284152 6231989 6497148 6486934 6233084 6504326 6635133
  33  * 6350801 6676425 6878475 6919132 6931676 6948903 6990617 7014645 7039066
  34  * 7067045 7014640 7189363 8007395 8013252 8013254 8012646 8023647 6559590
  35  * 8027645 8035076 8039124 8035975 8074678 6854417 8143854 8147531 7071819
  36  * 8151481 4867170 7080302 6728861 6995635 6736245 4916384 6328855 6192895
  37  * 6345469 6988218 6693451 7006761 8140212 8143282 8158482 8176029 8184706
  38  * 8194667 8197462 8184692 8221431 8224789 8228352 8230829 8236034 8235812
  39  * 8216332 8214245
  40  *
  41  * @library /test/lib
  42  * @library /lib/testlibrary/java/lang
  43  * @build jdk.test.lib.RandomFactory
  44  * @run main RegExTest
  45  * @key randomness
  46  */
  47 
  48 import java.io.BufferedReader;
  49 import java.io.ByteArrayInputStream;
  50 import java.io.ByteArrayOutputStream;
  51 import java.io.File;
  52 import java.io.FileInputStream;
  53 import java.io.InputStreamReader;
  54 import java.io.ObjectInputStream;
  55 import java.io.ObjectOutputStream;
  56 import java.math.BigInteger;
  57 import java.nio.CharBuffer;
  58 import java.nio.file.Files;
  59 import java.nio.file.Path;
  60 import java.nio.file.Paths;
  61 import java.util.ArrayList;
  62 import java.util.Arrays;
  63 import java.util.HashMap;
  64 import java.util.List;
  65 import java.util.Map;
  66 import java.util.Random;
  67 import java.util.Scanner;
  68 import java.util.function.Function;
  69 import java.util.function.Predicate;
  70 import java.util.regex.Matcher;
  71 import java.util.regex.MatchResult;
  72 import java.util.regex.Pattern;
  73 import java.util.regex.PatternSyntaxException;
  74 import java.util.stream.Stream;
  75 
  76 import jdk.test.lib.RandomFactory;
  77 
  78 /**
  79  * This is a test class created to check the operation of
  80  * the Pattern and Matcher classes.
  81  */
  82 public class RegExTest {
  83 
  84     private static Random generator = RandomFactory.getRandom();
  85     private static boolean failure = false;
  86     private static int failCount = 0;
  87     private static String firstFailure = null;
  88 
  89     /**
  90      * Main to interpret arguments and run several tests.
  91      *
  92      */
  93     public static void main(String[] args) throws Exception {
  94         // Most of the tests are in a file
  95         processFile(&quot;TestCases.txt&quot;);
  96         //processFile(&quot;PerlCases.txt&quot;);
  97         processFile(&quot;BMPTestCases.txt&quot;);
  98         processFile(&quot;SupplementaryTestCases.txt&quot;);
  99 
 100         // These test many randomly generated char patterns
 101         bm();
 102         slice();
 103 
 104         // These are hard to put into the file
 105         escapes();
 106         blankInput();
 107 
 108         // Substitition tests on randomly generated sequences
 109         globalSubstitute();
 110         stringbufferSubstitute();
 111         stringbuilderSubstitute();
 112 
 113         substitutionBasher();
 114         substitutionBasher2();
 115 
 116         // Canonical Equivalence
 117         ceTest();
 118 
 119         // Anchors
 120         anchorTest();
 121 
 122         // boolean match calls
 123         matchesTest();
 124         lookingAtTest();
 125 
 126         // Pattern API
 127         patternMatchesTest();
 128 
 129         // Misc
 130         lookbehindTest();
 131         nullArgumentTest();
 132         backRefTest();
 133         groupCaptureTest();
 134         caretTest();
 135         charClassTest();
 136         emptyPatternTest();
 137         findIntTest();
 138         group0Test();
 139         longPatternTest();
 140         octalTest();
 141         ampersandTest();
 142         negationTest();
 143         splitTest();
 144         appendTest();
 145         caseFoldingTest();
 146         commentsTest();
 147         unixLinesTest();
 148         replaceFirstTest();
 149         gTest();
 150         zTest();
 151         serializeTest();
 152         reluctantRepetitionTest();
 153         multilineDollarTest();
 154         dollarAtEndTest();
 155         caretBetweenTerminatorsTest();
 156         // This RFE rejected in Tiger numOccurrencesTest();
 157         javaCharClassTest();
 158         nonCaptureRepetitionTest();
 159         notCapturedGroupCurlyMatchTest();
 160         escapedSegmentTest();
 161         literalPatternTest();
 162         literalReplacementTest();
 163         regionTest();
 164         toStringTest();
 165         negatedCharClassTest();
 166         findFromTest();
 167         boundsTest();
 168         unicodeWordBoundsTest();
 169         caretAtEndTest();
 170         wordSearchTest();
 171         hitEndTest();
 172         toMatchResultTest();
 173         toMatchResultTest2();
 174         surrogatesInClassTest();
 175         removeQEQuotingTest();
 176         namedGroupCaptureTest();
 177         nonBmpClassComplementTest();
 178         unicodePropertiesTest();
 179         unicodeHexNotationTest();
 180         unicodeClassesTest();
 181         unicodeCharacterNameTest();
 182         horizontalAndVerticalWSTest();
 183         linebreakTest();
 184         branchTest();
 185         groupCurlyNotFoundSuppTest();
 186         groupCurlyBackoffTest();
 187         patternAsPredicate();
 188         patternAsMatchPredicate();
 189         invalidFlags();
 190         embeddedFlags();
 191         grapheme();
 192         expoBacktracking();
 193         invalidGroupName();
 194         illegalRepetitionRange();
 195         surrogatePairWithCanonEq();
 196         lineBreakWithQuantifier();
 197         caseInsensitivePMatch();
 198 
 199         if (failure) {
 200             throw new
 201                 RuntimeException(&quot;RegExTest failed, 1st failure: &quot; +
 202                                  firstFailure);
 203         } else {
 204             System.err.println(&quot;OKAY: All tests passed.&quot;);
 205         }
 206     }
 207 
 208     // Utility functions
 209 
 210     private static String getRandomAlphaString(int length) {
 211         StringBuffer buf = new StringBuffer(length);
 212         for (int i=0; i&lt;length; i++) {
 213             char randChar = (char)(97 + generator.nextInt(26));
 214             buf.append(randChar);
 215         }
 216         return buf.toString();
 217     }
 218 
 219     private static void check(Matcher m, String expected) {
 220         m.find();
 221         if (!m.group().equals(expected))
 222             failCount++;
 223     }
 224 
 225     private static void check(Matcher m, String result, boolean expected) {
 226         m.find();
 227         if (m.group().equals(result) != expected)
 228             failCount++;
 229     }
 230 
 231     private static void check(Pattern p, String s, boolean expected) {
 232         if (p.matcher(s).find() != expected)
 233             failCount++;
 234     }
 235 
 236     private static void check(String p, String s, boolean expected) {
 237         Matcher matcher = Pattern.compile(p).matcher(s);
 238         if (matcher.find() != expected)
 239             failCount++;
 240     }
 241 
 242     private static void check(String p, char c, boolean expected) {
 243         String propertyPattern = expected ? &quot;\\p&quot; + p : &quot;\\P&quot; + p;
 244         Pattern pattern = Pattern.compile(propertyPattern);
 245         char[] ca = new char[1]; ca[0] = c;
 246         Matcher matcher = pattern.matcher(new String(ca));
 247         if (!matcher.find())
 248             failCount++;
 249     }
 250 
 251     private static void check(String p, int codePoint, boolean expected) {
 252         String propertyPattern = expected ? &quot;\\p&quot; + p : &quot;\\P&quot; + p;
 253         Pattern pattern = Pattern.compile(propertyPattern);
 254         char[] ca = Character.toChars(codePoint);
 255         Matcher matcher = pattern.matcher(new String(ca));
 256         if (!matcher.find())
 257             failCount++;
 258     }
 259 
 260     private static void check(String p, int flag, String input, String s,
 261                               boolean expected)
 262     {
 263         Pattern pattern = Pattern.compile(p, flag);
 264         Matcher matcher = pattern.matcher(input);
 265         if (expected)
 266             check(matcher, s, expected);
 267         else
 268             check(pattern, input, false);
 269     }
 270 
 271     private static void report(String testName) {
 272         int spacesToAdd = 30 - testName.length();
 273         StringBuffer paddedNameBuffer = new StringBuffer(testName);
 274         for (int i=0; i&lt;spacesToAdd; i++)
 275             paddedNameBuffer.append(&quot; &quot;);
 276         String paddedName = paddedNameBuffer.toString();
 277         System.err.println(paddedName + &quot;: &quot; +
 278                            (failCount==0 ? &quot;Passed&quot;:&quot;Failed(&quot;+failCount+&quot;)&quot;));
 279         if (failCount &gt; 0) {
 280             failure = true;
 281 
 282             if (firstFailure == null) {
 283                 firstFailure = testName;
 284             }
 285         }
 286 
 287         failCount = 0;
 288     }
 289 
 290     /**
 291      * Converts ASCII alphabet characters [A-Za-z] in the given &#39;s&#39; to
 292      * supplementary characters. This method does NOT fully take care
 293      * of the regex syntax.
 294      */
 295     private static String toSupplementaries(String s) {
 296         int length = s.length();
 297         StringBuffer sb = new StringBuffer(length * 2);
 298 
 299         for (int i = 0; i &lt; length; ) {
 300             char c = s.charAt(i++);
 301             if (c == &#39;\\&#39;) {
 302                 sb.append(c);
 303                 if (i &lt; length) {
 304                     c = s.charAt(i++);
 305                     sb.append(c);
 306                     if (c == &#39;u&#39;) {
 307                         // assume no syntax error
 308                         sb.append(s.charAt(i++));
 309                         sb.append(s.charAt(i++));
 310                         sb.append(s.charAt(i++));
 311                         sb.append(s.charAt(i++));
 312                     }
 313                 }
 314             } else if ((c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;) || (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;)) {
 315                 sb.append(&#39;\ud800&#39;).append((char)(&#39;\udc00&#39;+c));
 316             } else {
 317                 sb.append(c);
 318             }
 319         }
 320         return sb.toString();
 321     }
 322 
 323     // Regular expression tests
 324 
 325     // This is for bug 6178785
 326     // Test if an expected NPE gets thrown when passing in a null argument
 327     private static boolean check(Runnable test) {
 328         try {
 329             test.run();
 330             failCount++;
 331             return false;
 332         } catch (NullPointerException npe) {
 333             return true;
 334         }
 335     }
 336 
 337     private static void nullArgumentTest() {
 338         check(() -&gt; Pattern.compile(null));
 339         check(() -&gt; Pattern.matches(null, null));
 340         check(() -&gt; Pattern.matches(&quot;xyz&quot;, null));
 341         check(() -&gt; Pattern.quote(null));
 342         check(() -&gt; Pattern.compile(&quot;xyz&quot;).split(null));
 343         check(() -&gt; Pattern.compile(&quot;xyz&quot;).matcher(null));
 344 
 345         final Matcher m = Pattern.compile(&quot;xyz&quot;).matcher(&quot;xyz&quot;);
 346         m.matches();
 347         check(() -&gt; m.appendTail((StringBuffer) null));
 348         check(() -&gt; m.appendTail((StringBuilder)null));
 349         check(() -&gt; m.replaceAll((String) null));
 350         check(() -&gt; m.replaceAll((Function&lt;MatchResult, String&gt;)null));
 351         check(() -&gt; m.replaceFirst((String)null));
 352         check(() -&gt; m.replaceFirst((Function&lt;MatchResult, String&gt;) null));
 353         check(() -&gt; m.appendReplacement((StringBuffer)null, null));
 354         check(() -&gt; m.appendReplacement((StringBuilder)null, null));
 355         check(() -&gt; m.reset(null));
 356         check(() -&gt; Matcher.quoteReplacement(null));
 357         //check(() -&gt; m.usePattern(null));
 358 
 359         report(&quot;Null Argument&quot;);
 360     }
 361 
 362     // This is for bug6635133
 363     // Test if surrogate pair in Unicode escapes can be handled correctly.
 364     private static void surrogatesInClassTest() throws Exception {
 365         Pattern pattern = Pattern.compile(&quot;[\\ud834\\udd21-\\ud834\\udd24]&quot;);
 366         Matcher matcher = pattern.matcher(&quot;\ud834\udd22&quot;);
 367         if (!matcher.find())
 368             failCount++;
 369 
 370         report(&quot;Surrogate pair in Unicode escape&quot;);
 371     }
 372 
 373     // This is for bug6990617
 374     // Test if Pattern.RemoveQEQuoting works correctly if the octal unicode
 375     // char encoding is only 2 or 3 digits instead of 4 and the first quoted
 376     // char is an octal digit.
 377     private static void removeQEQuotingTest() throws Exception {
 378         Pattern pattern =
 379             Pattern.compile(&quot;\\011\\Q1sometext\\E\\011\\Q2sometext\\E&quot;);
 380         Matcher matcher = pattern.matcher(&quot;\t1sometext\t2sometext&quot;);
 381         if (!matcher.find())
 382             failCount++;
 383 
 384         report(&quot;Remove Q/E Quoting&quot;);
 385     }
 386 
 387     // This is for bug 4988891
 388     // Test toMatchResult to see that it is a copy of the Matcher
 389     // that is not affected by subsequent operations on the original
 390     private static void toMatchResultTest() throws Exception {
 391         Pattern pattern = Pattern.compile(&quot;squid&quot;);
 392         Matcher matcher = pattern.matcher(
 393             &quot;agiantsquidofdestinyasmallsquidoffate&quot;);
 394         matcher.find();
 395         int matcherStart1 = matcher.start();
 396         MatchResult mr = matcher.toMatchResult();
 397         if (mr == matcher)
 398             failCount++;
 399         int resultStart1 = mr.start();
 400         if (matcherStart1 != resultStart1)
 401             failCount++;
 402         matcher.find();
 403         int matcherStart2 = matcher.start();
 404         int resultStart2 = mr.start();
 405         if (matcherStart2 == resultStart2)
 406             failCount++;
 407         if (resultStart1 != resultStart2)
 408             failCount++;
 409         MatchResult mr2 = matcher.toMatchResult();
 410         if (mr == mr2)
 411             failCount++;
 412         if (mr2.start() != matcherStart2)
 413             failCount++;
 414         report(&quot;toMatchResult is a copy&quot;);
 415     }
 416 
 417     private static void checkExpectedISE(Runnable test) {
 418         try {
 419             test.run();
 420             failCount++;
 421         } catch (IllegalStateException x) {
 422         } catch (IndexOutOfBoundsException xx) {
 423             failCount++;
 424         }
 425     }
 426 
 427     private static void checkExpectedIOOE(Runnable test) {
 428         try {
 429             test.run();
 430             failCount++;
 431         } catch (IndexOutOfBoundsException x) {}
 432     }
 433 
 434     // This is for bug 8074678
 435     // Test the result of toMatchResult throws ISE if no match is availble
 436     private static void toMatchResultTest2() throws Exception {
 437         Matcher matcher = Pattern.compile(&quot;nomatch&quot;).matcher(&quot;hello world&quot;);
 438         matcher.find();
 439         MatchResult mr = matcher.toMatchResult();
 440 
 441         checkExpectedISE(() -&gt; mr.start());
 442         checkExpectedISE(() -&gt; mr.start(2));
 443         checkExpectedISE(() -&gt; mr.end());
 444         checkExpectedISE(() -&gt; mr.end(2));
 445         checkExpectedISE(() -&gt; mr.group());
 446         checkExpectedISE(() -&gt; mr.group(2));
 447 
 448         matcher = Pattern.compile(&quot;(match)&quot;).matcher(&quot;there is a match&quot;);
 449         matcher.find();
 450         MatchResult mr2 = matcher.toMatchResult();
 451         checkExpectedIOOE(() -&gt; mr2.start(2));
 452         checkExpectedIOOE(() -&gt; mr2.end(2));
 453         checkExpectedIOOE(() -&gt; mr2.group(2));
 454 
 455         report(&quot;toMatchResult2 appropriate exceptions&quot;);
 456     }
 457 
 458     // This is for bug 5013885
 459     // Must test a slice to see if it reports hitEnd correctly
 460     private static void hitEndTest() throws Exception {
 461         // Basic test of Slice node
 462         Pattern p = Pattern.compile(&quot;^squidattack&quot;);
 463         Matcher m = p.matcher(&quot;squack&quot;);
 464         m.find();
 465         if (m.hitEnd())
 466             failCount++;
 467         m.reset(&quot;squid&quot;);
 468         m.find();
 469         if (!m.hitEnd())
 470             failCount++;
 471 
 472         // Test Slice, SliceA and SliceU nodes
 473         for (int i=0; i&lt;3; i++) {
 474             int flags = 0;
 475             if (i==1) flags = Pattern.CASE_INSENSITIVE;
 476             if (i==2) flags = Pattern.UNICODE_CASE;
 477             p = Pattern.compile(&quot;^abc&quot;, flags);
 478             m = p.matcher(&quot;ad&quot;);
 479             m.find();
 480             if (m.hitEnd())
 481                 failCount++;
 482             m.reset(&quot;ab&quot;);
 483             m.find();
 484             if (!m.hitEnd())
 485                 failCount++;
 486         }
 487 
 488         // Test Boyer-Moore node
 489         p = Pattern.compile(&quot;catattack&quot;);
 490         m = p.matcher(&quot;attack&quot;);
 491         m.find();
 492         if (!m.hitEnd())
 493             failCount++;
 494 
 495         p = Pattern.compile(&quot;catattack&quot;);
 496         m = p.matcher(&quot;attackattackattackcatatta&quot;);
 497         m.find();
 498         if (!m.hitEnd())
 499             failCount++;
 500 
 501         // 8184706: Matching u+0d at EOL against \R should hit-end
 502         p = Pattern.compile(&quot;...\\R&quot;);
 503         m = p.matcher(&quot;cat&quot; + (char)0x0a);
 504         m.find();
 505         if (m.hitEnd())
 506             failCount++;
 507 
 508         m = p.matcher(&quot;cat&quot; + (char)0x0d);
 509         m.find();
 510         if (!m.hitEnd())
 511             failCount++;
 512 
 513         m = p.matcher(&quot;cat&quot; + (char)0x0d + (char)0x0a);
 514         m.find();
 515         if (m.hitEnd())
 516             failCount++;
 517 
 518         report(&quot;hitEnd&quot;);
 519     }
 520 
 521     // This is for bug 4997476
 522     // It is weird code submitted by customer demonstrating a regression
 523     private static void wordSearchTest() throws Exception {
 524         String testString = new String(&quot;word1 word2 word3&quot;);
 525         Pattern p = Pattern.compile(&quot;\\b&quot;);
 526         Matcher m = p.matcher(testString);
 527         int position = 0;
 528         int start = 0;
 529         while (m.find(position)) {
 530             start = m.start();
 531             if (start == testString.length())
 532                 break;
 533             if (m.find(start+1)) {
 534                 position = m.start();
 535             } else {
 536                 position = testString.length();
 537             }
 538             if (testString.substring(start, position).equals(&quot; &quot;))
 539                 continue;
 540             if (!testString.substring(start, position-1).startsWith(&quot;word&quot;))
 541                 failCount++;
 542         }
 543         report(&quot;Customer word search&quot;);
 544     }
 545 
 546     // This is for bug 4994840
 547     private static void caretAtEndTest() throws Exception {
 548         // Problem only occurs with multiline patterns
 549         // containing a beginning-of-line caret &quot;^&quot; followed
 550         // by an expression that also matches the empty string.
 551         Pattern pattern = Pattern.compile(&quot;^x?&quot;, Pattern.MULTILINE);
 552         Matcher matcher = pattern.matcher(&quot;\r&quot;);
 553         matcher.find();
 554         matcher.find();
 555         report(&quot;Caret at end&quot;);
 556     }
 557 
 558     // This test is for 4979006
 559     // Check to see if word boundary construct properly handles unicode
 560     // non spacing marks
 561     private static void unicodeWordBoundsTest() throws Exception {
 562         String spaces = &quot;  &quot;;
 563         String wordChar = &quot;a&quot;;
 564         String nsm = &quot;\u030a&quot;;
 565 
 566         assert (Character.getType(&#39;\u030a&#39;) == Character.NON_SPACING_MARK);
 567 
 568         Pattern pattern = Pattern.compile(&quot;\\b&quot;);
 569         Matcher matcher = pattern.matcher(&quot;&quot;);
 570         // S=other B=word character N=non spacing mark .=word boundary
 571         // SS.BB.SS
 572         String input = spaces + wordChar + wordChar + spaces;
 573         twoFindIndexes(input, matcher, 2, 4);
 574         // SS.BBN.SS
 575         input = spaces + wordChar +wordChar + nsm + spaces;
 576         twoFindIndexes(input, matcher, 2, 5);
 577         // SS.BN.SS
 578         input = spaces + wordChar + nsm + spaces;
 579         twoFindIndexes(input, matcher, 2, 4);
 580         // SS.BNN.SS
 581         input = spaces + wordChar + nsm + nsm + spaces;
 582         twoFindIndexes(input, matcher, 2, 5);
 583         // SSN.BB.SS
 584         input = spaces + nsm + wordChar + wordChar + spaces;
 585         twoFindIndexes(input, matcher, 3, 5);
 586         // SS.BNB.SS
 587         input = spaces + wordChar + nsm + wordChar + spaces;
 588         twoFindIndexes(input, matcher, 2, 5);
 589         // SSNNSS
 590         input = spaces + nsm + nsm + spaces;
 591         matcher.reset(input);
 592         if (matcher.find())
 593             failCount++;
 594         // SSN.BBN.SS
 595         input = spaces + nsm + wordChar + wordChar + nsm + spaces;
 596         twoFindIndexes(input, matcher, 3, 6);
 597 
 598         report(&quot;Unicode word boundary&quot;);
 599     }
 600 
 601     private static void twoFindIndexes(String input, Matcher matcher, int a,
 602                                        int b) throws Exception
 603     {
 604         matcher.reset(input);
 605         matcher.find();
 606         if (matcher.start() != a)
 607             failCount++;
 608         matcher.find();
 609         if (matcher.start() != b)
 610             failCount++;
 611     }
 612 
 613     // This test is for 6284152
 614     static void check(String regex, String input, String[] expected) {
 615         List&lt;String&gt; result = new ArrayList&lt;String&gt;();
 616         Pattern p = Pattern.compile(regex);
 617         Matcher m = p.matcher(input);
 618         while (m.find()) {
 619             result.add(m.group());
 620         }
 621         if (!Arrays.asList(expected).equals(result))
 622             failCount++;
 623     }
 624 
 625     private static void lookbehindTest() throws Exception {
 626         //Positive
 627         check(&quot;(?&lt;=%.{0,5})foo\\d&quot;,
 628               &quot;%foo1\n%bar foo2\n%bar  foo3\n%blahblah foo4\nfoo5&quot;,
 629               new String[]{&quot;foo1&quot;, &quot;foo2&quot;, &quot;foo3&quot;});
 630 
 631         //boundary at end of the lookbehind sub-regex should work consistently
 632         //with the boundary just after the lookbehind sub-regex
 633         check(&quot;(?&lt;=.*\\b)foo&quot;, &quot;abcd foo&quot;, new String[]{&quot;foo&quot;});
 634         check(&quot;(?&lt;=.*)\\bfoo&quot;, &quot;abcd foo&quot;, new String[]{&quot;foo&quot;});
 635         check(&quot;(?&lt;!abc )\\bfoo&quot;, &quot;abc foo&quot;, new String[0]);
 636         check(&quot;(?&lt;!abc \\b)foo&quot;, &quot;abc foo&quot;, new String[0]);
 637 
 638         //Negative
 639         check(&quot;(?&lt;!%.{0,5})foo\\d&quot;,
 640               &quot;%foo1\n%bar foo2\n%bar  foo3\n%blahblah foo4\nfoo5&quot;,
 641               new String[] {&quot;foo4&quot;, &quot;foo5&quot;});
 642 
 643         //Positive greedy
 644         check(&quot;(?&lt;=%b{1,4})foo&quot;, &quot;%bbbbfoo&quot;, new String[] {&quot;foo&quot;});
 645 
 646         //Positive reluctant
 647         check(&quot;(?&lt;=%b{1,4}?)foo&quot;, &quot;%bbbbfoo&quot;, new String[] {&quot;foo&quot;});
 648 
 649         //supplementary
 650         check(&quot;(?&lt;=%b{1,4})fo\ud800\udc00o&quot;, &quot;%bbbbfo\ud800\udc00o&quot;,
 651               new String[] {&quot;fo\ud800\udc00o&quot;});
 652         check(&quot;(?&lt;=%b{1,4}?)fo\ud800\udc00o&quot;, &quot;%bbbbfo\ud800\udc00o&quot;,
 653               new String[] {&quot;fo\ud800\udc00o&quot;});
 654         check(&quot;(?&lt;!%b{1,4})fo\ud800\udc00o&quot;, &quot;%afo\ud800\udc00o&quot;,
 655               new String[] {&quot;fo\ud800\udc00o&quot;});
 656         check(&quot;(?&lt;!%b{1,4}?)fo\ud800\udc00o&quot;, &quot;%afo\ud800\udc00o&quot;,
 657               new String[] {&quot;fo\ud800\udc00o&quot;});
 658         report(&quot;Lookbehind&quot;);
 659     }
 660 
 661     // This test is for 4938995
 662     // Check to see if weak region boundaries are transparent to
 663     // lookahead and lookbehind constructs
 664     private static void boundsTest() throws Exception {
 665         String fullMessage = &quot;catdogcat&quot;;
 666         Pattern pattern = Pattern.compile(&quot;(?&lt;=cat)dog(?=cat)&quot;);
 667         Matcher matcher = pattern.matcher(&quot;catdogca&quot;);
 668         matcher.useTransparentBounds(true);
 669         if (matcher.find())
 670             failCount++;
 671         matcher.reset(&quot;atdogcat&quot;);
 672         if (matcher.find())
 673             failCount++;
 674         matcher.reset(fullMessage);
 675         if (!matcher.find())
 676             failCount++;
 677         matcher.reset(fullMessage);
 678         matcher.region(0,9);
 679         if (!matcher.find())
 680             failCount++;
 681         matcher.reset(fullMessage);
 682         matcher.region(0,6);
 683         if (!matcher.find())
 684             failCount++;
 685         matcher.reset(fullMessage);
 686         matcher.region(3,6);
 687         if (!matcher.find())
 688             failCount++;
 689         matcher.useTransparentBounds(false);
 690         if (matcher.find())
 691             failCount++;
 692 
 693         // Negative lookahead/lookbehind
 694         pattern = Pattern.compile(&quot;(?&lt;!cat)dog(?!cat)&quot;);
 695         matcher = pattern.matcher(&quot;dogcat&quot;);
 696         matcher.useTransparentBounds(true);
 697         matcher.region(0,3);
 698         if (matcher.find())
 699             failCount++;
 700         matcher.reset(&quot;catdog&quot;);
 701         matcher.region(3,6);
 702         if (matcher.find())
 703             failCount++;
 704         matcher.useTransparentBounds(false);
 705         matcher.reset(&quot;dogcat&quot;);
 706         matcher.region(0,3);
 707         if (!matcher.find())
 708             failCount++;
 709         matcher.reset(&quot;catdog&quot;);
 710         matcher.region(3,6);
 711         if (!matcher.find())
 712             failCount++;
 713 
 714         report(&quot;Region bounds transparency&quot;);
 715     }
 716 
 717     // This test is for 4945394
 718     private static void findFromTest() throws Exception {
 719         String message = &quot;This is 40 $0 message.&quot;;
 720         Pattern pat = Pattern.compile(&quot;\\$0&quot;);
 721         Matcher match = pat.matcher(message);
 722         if (!match.find())
 723             failCount++;
 724         if (match.find())
 725             failCount++;
 726         if (match.find())
 727             failCount++;
 728         report(&quot;Check for alternating find&quot;);
 729     }
 730 
 731     // This test is for 4872664 and 4892980
 732     private static void negatedCharClassTest() throws Exception {
 733         Pattern pattern = Pattern.compile(&quot;[^&gt;]&quot;);
 734         Matcher matcher = pattern.matcher(&quot;\u203A&quot;);
 735         if (!matcher.matches())
 736             failCount++;
 737         pattern = Pattern.compile(&quot;[^fr]&quot;);
 738         matcher = pattern.matcher(&quot;a&quot;);
 739         if (!matcher.find())
 740             failCount++;
 741         matcher.reset(&quot;\u203A&quot;);
 742         if (!matcher.find())
 743             failCount++;
 744         String s = &quot;for&quot;;
 745         String result[] = s.split(&quot;[^fr]&quot;);
 746         if (!result[0].equals(&quot;f&quot;))
 747             failCount++;
 748         if (!result[1].equals(&quot;r&quot;))
 749             failCount++;
 750         s = &quot;f\u203Ar&quot;;
 751         result = s.split(&quot;[^fr]&quot;);
 752         if (!result[0].equals(&quot;f&quot;))
 753             failCount++;
 754         if (!result[1].equals(&quot;r&quot;))
 755             failCount++;
 756 
 757         // Test adding to bits, subtracting a node, then adding to bits again
 758         pattern = Pattern.compile(&quot;[^f\u203Ar]&quot;);
 759         matcher = pattern.matcher(&quot;a&quot;);
 760         if (!matcher.find())
 761             failCount++;
 762         matcher.reset(&quot;f&quot;);
 763         if (matcher.find())
 764             failCount++;
 765         matcher.reset(&quot;\u203A&quot;);
 766         if (matcher.find())
 767             failCount++;
 768         matcher.reset(&quot;r&quot;);
 769         if (matcher.find())
 770             failCount++;
 771         matcher.reset(&quot;\u203B&quot;);
 772         if (!matcher.find())
 773             failCount++;
 774 
 775         // Test subtracting a node, adding to bits, subtracting again
 776         pattern = Pattern.compile(&quot;[^\u203Ar\u203B]&quot;);
 777         matcher = pattern.matcher(&quot;a&quot;);
 778         if (!matcher.find())
 779             failCount++;
 780         matcher.reset(&quot;\u203A&quot;);
 781         if (matcher.find())
 782             failCount++;
 783         matcher.reset(&quot;r&quot;);
 784         if (matcher.find())
 785             failCount++;
 786         matcher.reset(&quot;\u203B&quot;);
 787         if (matcher.find())
 788             failCount++;
 789         matcher.reset(&quot;\u203C&quot;);
 790         if (!matcher.find())
 791             failCount++;
 792 
 793         report(&quot;Negated Character Class&quot;);
 794     }
 795 
 796     // This test is for 4628291
 797     private static void toStringTest() throws Exception {
 798         Pattern pattern = Pattern.compile(&quot;b+&quot;);
 799         if (pattern.toString() != &quot;b+&quot;)
 800             failCount++;
 801         Matcher matcher = pattern.matcher(&quot;aaabbbccc&quot;);
 802         String matcherString = matcher.toString(); // unspecified
 803         matcher.find();
 804         matcherString = matcher.toString(); // unspecified
 805         matcher.region(0,3);
 806         matcherString = matcher.toString(); // unspecified
 807         matcher.reset();
 808         matcherString = matcher.toString(); // unspecified
 809         report(&quot;toString&quot;);
 810     }
 811 
 812     // This test is for 4808962
 813     private static void literalPatternTest() throws Exception {
 814         int flags = Pattern.LITERAL;
 815 
 816         Pattern pattern = Pattern.compile(&quot;abc\\t$^&quot;, flags);
 817         check(pattern, &quot;abc\\t$^&quot;, true);
 818 
 819         pattern = Pattern.compile(Pattern.quote(&quot;abc\\t$^&quot;));
 820         check(pattern, &quot;abc\\t$^&quot;, true);
 821 
 822         pattern = Pattern.compile(&quot;\\Qa^$bcabc\\E&quot;, flags);
 823         check(pattern, &quot;\\Qa^$bcabc\\E&quot;, true);
 824         check(pattern, &quot;a^$bcabc&quot;, false);
 825 
 826         pattern = Pattern.compile(&quot;\\\\Q\\\\E&quot;);
 827         check(pattern, &quot;\\Q\\E&quot;, true);
 828 
 829         pattern = Pattern.compile(&quot;\\Qabc\\Eefg\\\\Q\\\\Ehij&quot;);
 830         check(pattern, &quot;abcefg\\Q\\Ehij&quot;, true);
 831 
 832         pattern = Pattern.compile(&quot;\\\\\\Q\\\\E&quot;);
 833         check(pattern, &quot;\\\\\\\\&quot;, true);
 834 
 835         pattern = Pattern.compile(Pattern.quote(&quot;\\Qa^$bcabc\\E&quot;));
 836         check(pattern, &quot;\\Qa^$bcabc\\E&quot;, true);
 837         check(pattern, &quot;a^$bcabc&quot;, false);
 838 
 839         pattern = Pattern.compile(Pattern.quote(&quot;\\Qabc\\Edef&quot;));
 840         check(pattern, &quot;\\Qabc\\Edef&quot;, true);
 841         check(pattern, &quot;abcdef&quot;, false);
 842 
 843         pattern = Pattern.compile(Pattern.quote(&quot;abc\\Edef&quot;));
 844         check(pattern, &quot;abc\\Edef&quot;, true);
 845         check(pattern, &quot;abcdef&quot;, false);
 846 
 847         pattern = Pattern.compile(Pattern.quote(&quot;\\E&quot;));
 848         check(pattern, &quot;\\E&quot;, true);
 849 
 850         pattern = Pattern.compile(&quot;((((abc.+?:)&quot;, flags);
 851         check(pattern, &quot;((((abc.+?:)&quot;, true);
 852 
 853         flags |= Pattern.MULTILINE;
 854 
 855         pattern = Pattern.compile(&quot;^cat$&quot;, flags);
 856         check(pattern, &quot;abc^cat$def&quot;, true);
 857         check(pattern, &quot;cat&quot;, false);
 858 
 859         flags |= Pattern.CASE_INSENSITIVE;
 860 
 861         pattern = Pattern.compile(&quot;abcdef&quot;, flags);
 862         check(pattern, &quot;ABCDEF&quot;, true);
 863         check(pattern, &quot;AbCdEf&quot;, true);
 864 
 865         flags |= Pattern.DOTALL;
 866 
 867         pattern = Pattern.compile(&quot;a...b&quot;, flags);
 868         check(pattern, &quot;A...b&quot;, true);
 869         check(pattern, &quot;Axxxb&quot;, false);
 870 
 871         flags |= Pattern.CANON_EQ;
 872 
 873         Pattern p = Pattern.compile(&quot;testa\u030a&quot;, flags);
 874         check(pattern, &quot;testa\u030a&quot;, false);
 875         check(pattern, &quot;test\u00e5&quot;, false);
 876 
 877         // Supplementary character test
 878         flags = Pattern.LITERAL;
 879 
 880         pattern = Pattern.compile(toSupplementaries(&quot;abc\\t$^&quot;), flags);
 881         check(pattern, toSupplementaries(&quot;abc\\t$^&quot;), true);
 882 
 883         pattern = Pattern.compile(Pattern.quote(toSupplementaries(&quot;abc\\t$^&quot;)));
 884         check(pattern, toSupplementaries(&quot;abc\\t$^&quot;), true);
 885 
 886         pattern = Pattern.compile(toSupplementaries(&quot;\\Qa^$bcabc\\E&quot;), flags);
 887         check(pattern, toSupplementaries(&quot;\\Qa^$bcabc\\E&quot;), true);
 888         check(pattern, toSupplementaries(&quot;a^$bcabc&quot;), false);
 889 
 890         pattern = Pattern.compile(Pattern.quote(toSupplementaries(&quot;\\Qa^$bcabc\\E&quot;)));
 891         check(pattern, toSupplementaries(&quot;\\Qa^$bcabc\\E&quot;), true);
 892         check(pattern, toSupplementaries(&quot;a^$bcabc&quot;), false);
 893 
 894         pattern = Pattern.compile(Pattern.quote(toSupplementaries(&quot;\\Qabc\\Edef&quot;)));
 895         check(pattern, toSupplementaries(&quot;\\Qabc\\Edef&quot;), true);
 896         check(pattern, toSupplementaries(&quot;abcdef&quot;), false);
 897 
 898         pattern = Pattern.compile(Pattern.quote(toSupplementaries(&quot;abc\\Edef&quot;)));
 899         check(pattern, toSupplementaries(&quot;abc\\Edef&quot;), true);
 900         check(pattern, toSupplementaries(&quot;abcdef&quot;), false);
 901 
 902         pattern = Pattern.compile(toSupplementaries(&quot;((((abc.+?:)&quot;), flags);
 903         check(pattern, toSupplementaries(&quot;((((abc.+?:)&quot;), true);
 904 
 905         flags |= Pattern.MULTILINE;
 906 
 907         pattern = Pattern.compile(toSupplementaries(&quot;^cat$&quot;), flags);
 908         check(pattern, toSupplementaries(&quot;abc^cat$def&quot;), true);
 909         check(pattern, toSupplementaries(&quot;cat&quot;), false);
 910 
 911         flags |= Pattern.DOTALL;
 912 
 913         // note: this is case-sensitive.
 914         pattern = Pattern.compile(toSupplementaries(&quot;a...b&quot;), flags);
 915         check(pattern, toSupplementaries(&quot;a...b&quot;), true);
 916         check(pattern, toSupplementaries(&quot;axxxb&quot;), false);
 917 
 918         flags |= Pattern.CANON_EQ;
 919 
 920         String t = toSupplementaries(&quot;test&quot;);
 921         p = Pattern.compile(t + &quot;a\u030a&quot;, flags);
 922         check(pattern, t + &quot;a\u030a&quot;, false);
 923         check(pattern, t + &quot;\u00e5&quot;, false);
 924 
 925         report(&quot;Literal pattern&quot;);
 926     }
 927 
 928     // This test is for 4803179
 929     // This test is also for 4808962, replacement parts
 930     private static void literalReplacementTest() throws Exception {
 931         int flags = Pattern.LITERAL;
 932 
 933         Pattern pattern = Pattern.compile(&quot;abc&quot;, flags);
 934         Matcher matcher = pattern.matcher(&quot;zzzabczzz&quot;);
 935         String replaceTest = &quot;$0&quot;;
 936         String result = matcher.replaceAll(replaceTest);
 937         if (!result.equals(&quot;zzzabczzz&quot;))
 938             failCount++;
 939 
 940         matcher.reset();
 941         String literalReplacement = matcher.quoteReplacement(replaceTest);
 942         result = matcher.replaceAll(literalReplacement);
 943         if (!result.equals(&quot;zzz$0zzz&quot;))
 944             failCount++;
 945 
 946         matcher.reset();
 947         replaceTest = &quot;\\t$\\$&quot;;
 948         literalReplacement = matcher.quoteReplacement(replaceTest);
 949         result = matcher.replaceAll(literalReplacement);
 950         if (!result.equals(&quot;zzz\\t$\\$zzz&quot;))
 951             failCount++;
 952 
 953         // Supplementary character test
 954         pattern = Pattern.compile(toSupplementaries(&quot;abc&quot;), flags);
 955         matcher = pattern.matcher(toSupplementaries(&quot;zzzabczzz&quot;));
 956         replaceTest = &quot;$0&quot;;
 957         result = matcher.replaceAll(replaceTest);
 958         if (!result.equals(toSupplementaries(&quot;zzzabczzz&quot;)))
 959             failCount++;
 960 
 961         matcher.reset();
 962         literalReplacement = matcher.quoteReplacement(replaceTest);
 963         result = matcher.replaceAll(literalReplacement);
 964         if (!result.equals(toSupplementaries(&quot;zzz$0zzz&quot;)))
 965             failCount++;
 966 
 967         matcher.reset();
 968         replaceTest = &quot;\\t$\\$&quot;;
 969         literalReplacement = matcher.quoteReplacement(replaceTest);
 970         result = matcher.replaceAll(literalReplacement);
 971         if (!result.equals(toSupplementaries(&quot;zzz\\t$\\$zzz&quot;)))
 972             failCount++;
 973 
 974         // IAE should be thrown if backslash or &#39;$&#39; is the last character
 975         // in replacement string
 976         try {
 977             &quot;\uac00&quot;.replaceAll(&quot;\uac00&quot;, &quot;$&quot;);
 978             failCount++;
 979         } catch (IllegalArgumentException iie) {
 980         } catch (Exception e) {
 981             failCount++;
 982         }
 983         try {
 984             &quot;\uac00&quot;.replaceAll(&quot;\uac00&quot;, &quot;\\&quot;);
 985             failCount++;
 986         } catch (IllegalArgumentException iie) {
 987         } catch (Exception e) {
 988             failCount++;
 989         }
 990         report(&quot;Literal replacement&quot;);
 991     }
 992 
 993     // This test is for 4757029
 994     private static void regionTest() throws Exception {
 995         Pattern pattern = Pattern.compile(&quot;abc&quot;);
 996         Matcher matcher = pattern.matcher(&quot;abcdefabc&quot;);
 997 
 998         matcher.region(0,9);
 999         if (!matcher.find())
1000             failCount++;
1001         if (!matcher.find())
1002             failCount++;
1003         matcher.region(0,3);
1004         if (!matcher.find())
1005            failCount++;
1006         matcher.region(3,6);
1007         if (matcher.find())
1008            failCount++;
1009         matcher.region(0,2);
1010         if (matcher.find())
1011            failCount++;
1012 
1013         expectRegionFail(matcher, 1, -1);
1014         expectRegionFail(matcher, -1, -1);
1015         expectRegionFail(matcher, -1, 1);
1016         expectRegionFail(matcher, 5, 3);
1017         expectRegionFail(matcher, 5, 12);
1018         expectRegionFail(matcher, 12, 12);
1019 
1020         pattern = Pattern.compile(&quot;^abc$&quot;);
1021         matcher = pattern.matcher(&quot;zzzabczzz&quot;);
1022         matcher.region(0,9);
1023         if (matcher.find())
1024             failCount++;
1025         matcher.region(3,6);
1026         if (!matcher.find())
1027            failCount++;
1028         matcher.region(3,6);
1029         matcher.useAnchoringBounds(false);
1030         if (matcher.find())
1031            failCount++;
1032 
1033         // Supplementary character test
1034         pattern = Pattern.compile(toSupplementaries(&quot;abc&quot;));
1035         matcher = pattern.matcher(toSupplementaries(&quot;abcdefabc&quot;));
1036         matcher.region(0,9*2);
1037         if (!matcher.find())
1038             failCount++;
1039         if (!matcher.find())
1040             failCount++;
1041         matcher.region(0,3*2);
1042         if (!matcher.find())
1043            failCount++;
1044         matcher.region(1,3*2);
1045         if (matcher.find())
1046            failCount++;
1047         matcher.region(3*2,6*2);
1048         if (matcher.find())
1049            failCount++;
1050         matcher.region(0,2*2);
1051         if (matcher.find())
1052            failCount++;
1053         matcher.region(0,2*2+1);
1054         if (matcher.find())
1055            failCount++;
1056 
1057         expectRegionFail(matcher, 1*2, -1);
1058         expectRegionFail(matcher, -1, -1);
1059         expectRegionFail(matcher, -1, 1*2);
1060         expectRegionFail(matcher, 5*2, 3*2);
1061         expectRegionFail(matcher, 5*2, 12*2);
1062         expectRegionFail(matcher, 12*2, 12*2);
1063 
1064         pattern = Pattern.compile(toSupplementaries(&quot;^abc$&quot;));
1065         matcher = pattern.matcher(toSupplementaries(&quot;zzzabczzz&quot;));
1066         matcher.region(0,9*2);
1067         if (matcher.find())
1068             failCount++;
1069         matcher.region(3*2,6*2);
1070         if (!matcher.find())
1071            failCount++;
1072         matcher.region(3*2+1,6*2);
1073         if (matcher.find())
1074            failCount++;
1075         matcher.region(3*2,6*2-1);
1076         if (matcher.find())
1077            failCount++;
1078         matcher.region(3*2,6*2);
1079         matcher.useAnchoringBounds(false);
1080         if (matcher.find())
1081            failCount++;
1082 
1083         // JDK-8230829
1084         pattern = Pattern.compile(&quot;\\ud800\\udc61&quot;);
1085         matcher = pattern.matcher(&quot;\ud800\udc61&quot;);
1086         matcher.region(0, 1);
1087         if (matcher.find()) {
1088             failCount++;
1089             System.out.println(&quot;Matched a surrogate pair&quot; +
1090                     &quot; that crosses border of region&quot;);
1091         }
1092         if (!matcher.hitEnd()) {
1093             failCount++;
1094             System.out.println(&quot;Expected to hit the end when&quot; +
1095                     &quot; matching a surrogate pair crossing region&quot;);
1096         }
1097 
1098         report(&quot;Regions&quot;);
1099     }
1100 
1101     private static void expectRegionFail(Matcher matcher, int index1,
1102                                          int index2)
1103     {
1104         try {
1105             matcher.region(index1, index2);
1106             failCount++;
1107         } catch (IndexOutOfBoundsException ioobe) {
1108             // Correct result
1109         } catch (IllegalStateException ise) {
1110             // Correct result
1111         }
1112     }
1113 
1114     // This test is for 4803197
1115     private static void escapedSegmentTest() throws Exception {
1116 
1117         Pattern pattern = Pattern.compile(&quot;\\Qdir1\\dir2\\E&quot;);
1118         check(pattern, &quot;dir1\\dir2&quot;, true);
1119 
1120         pattern = Pattern.compile(&quot;\\Qdir1\\dir2\\\\E&quot;);
1121         check(pattern, &quot;dir1\\dir2\\&quot;, true);
1122 
1123         pattern = Pattern.compile(&quot;(\\Qdir1\\dir2\\\\E)&quot;);
1124         check(pattern, &quot;dir1\\dir2\\&quot;, true);
1125 
1126         // Supplementary character test
1127         pattern = Pattern.compile(toSupplementaries(&quot;\\Qdir1\\dir2\\E&quot;));
1128         check(pattern, toSupplementaries(&quot;dir1\\dir2&quot;), true);
1129 
1130         pattern = Pattern.compile(toSupplementaries(&quot;\\Qdir1\\dir2&quot;)+&quot;\\\\E&quot;);
1131         check(pattern, toSupplementaries(&quot;dir1\\dir2\\&quot;), true);
1132 
1133         pattern = Pattern.compile(toSupplementaries(&quot;(\\Qdir1\\dir2&quot;)+&quot;\\\\E)&quot;);
1134         check(pattern, toSupplementaries(&quot;dir1\\dir2\\&quot;), true);
1135 
1136         report(&quot;Escaped segment&quot;);
1137     }
1138 
1139     // This test is for 4792284
1140     private static void nonCaptureRepetitionTest() throws Exception {
1141         String input = &quot;abcdefgh;&quot;;
1142 
1143         String[] patterns = new String[] {
1144             &quot;(?:\\w{4})+;&quot;,
1145             &quot;(?:\\w{8})*;&quot;,
1146             &quot;(?:\\w{2}){2,4};&quot;,
1147             &quot;(?:\\w{4}){2,};&quot;,   // only matches the
1148             &quot;.*?(?:\\w{5})+;&quot;,   //     specified minimum
1149             &quot;.*?(?:\\w{9})*;&quot;,   //     number of reps - OK
1150             &quot;(?:\\w{4})+?;&quot;,     // lazy repetition - OK
1151             &quot;(?:\\w{4})++;&quot;,     // possessive repetition - OK
1152             &quot;(?:\\w{2,}?)+;&quot;,    // non-deterministic - OK
1153             &quot;(\\w{4})+;&quot;,        // capturing group - OK
1154         };
1155 
1156         for (int i = 0; i &lt; patterns.length; i++) {
1157             // Check find()
1158             check(patterns[i], 0, input, input, true);
1159             // Check matches()
1160             Pattern p = Pattern.compile(patterns[i]);
1161             Matcher m = p.matcher(input);
1162 
1163             if (m.matches()) {
1164                 if (!m.group(0).equals(input))
1165                     failCount++;
1166             } else {
1167                 failCount++;
1168             }
1169         }
1170 
1171         report(&quot;Non capturing repetition&quot;);
1172     }
1173 
1174     // This test is for 6358731
1175     private static void notCapturedGroupCurlyMatchTest() throws Exception {
1176         Pattern pattern = Pattern.compile(&quot;(abc)+|(abcd)+&quot;);
1177         Matcher matcher = pattern.matcher(&quot;abcd&quot;);
1178         if (!matcher.matches() ||
1179              matcher.group(1) != null ||
1180              !matcher.group(2).equals(&quot;abcd&quot;)) {
1181             failCount++;
1182         }
1183         report(&quot;Not captured GroupCurly&quot;);
1184     }
1185 
1186     // This test is for 4706545
1187     private static void javaCharClassTest() throws Exception {
1188         for (int i=0; i&lt;1000; i++) {
1189             char c = (char)generator.nextInt();
1190             check(&quot;{javaLowerCase}&quot;, c, Character.isLowerCase(c));
1191             check(&quot;{javaUpperCase}&quot;, c, Character.isUpperCase(c));
1192             check(&quot;{javaUpperCase}+&quot;, c, Character.isUpperCase(c));
1193             check(&quot;{javaTitleCase}&quot;, c, Character.isTitleCase(c));
1194             check(&quot;{javaDigit}&quot;, c, Character.isDigit(c));
1195             check(&quot;{javaDefined}&quot;, c, Character.isDefined(c));
1196             check(&quot;{javaLetter}&quot;, c, Character.isLetter(c));
1197             check(&quot;{javaLetterOrDigit}&quot;, c, Character.isLetterOrDigit(c));
1198             check(&quot;{javaJavaIdentifierStart}&quot;, c,
1199                   Character.isJavaIdentifierStart(c));
1200             check(&quot;{javaJavaIdentifierPart}&quot;, c,
1201                   Character.isJavaIdentifierPart(c));
1202             check(&quot;{javaUnicodeIdentifierStart}&quot;, c,
1203                   Character.isUnicodeIdentifierStart(c));
1204             check(&quot;{javaUnicodeIdentifierPart}&quot;, c,
1205                   Character.isUnicodeIdentifierPart(c));
1206             check(&quot;{javaIdentifierIgnorable}&quot;, c,
1207                   Character.isIdentifierIgnorable(c));
1208             check(&quot;{javaSpaceChar}&quot;, c, Character.isSpaceChar(c));
1209             check(&quot;{javaWhitespace}&quot;, c, Character.isWhitespace(c));
1210             check(&quot;{javaISOControl}&quot;, c, Character.isISOControl(c));
1211             check(&quot;{javaMirrored}&quot;, c, Character.isMirrored(c));
1212 
1213         }
1214 
1215         // Supplementary character test
1216         for (int i=0; i&lt;1000; i++) {
1217             int c = generator.nextInt(Character.MAX_CODE_POINT
1218                                       - Character.MIN_SUPPLEMENTARY_CODE_POINT)
1219                         + Character.MIN_SUPPLEMENTARY_CODE_POINT;
1220             check(&quot;{javaLowerCase}&quot;, c, Character.isLowerCase(c));
1221             check(&quot;{javaUpperCase}&quot;, c, Character.isUpperCase(c));
1222             check(&quot;{javaUpperCase}+&quot;, c, Character.isUpperCase(c));
1223             check(&quot;{javaTitleCase}&quot;, c, Character.isTitleCase(c));
1224             check(&quot;{javaDigit}&quot;, c, Character.isDigit(c));
1225             check(&quot;{javaDefined}&quot;, c, Character.isDefined(c));
1226             check(&quot;{javaLetter}&quot;, c, Character.isLetter(c));
1227             check(&quot;{javaLetterOrDigit}&quot;, c, Character.isLetterOrDigit(c));
1228             check(&quot;{javaJavaIdentifierStart}&quot;, c,
1229                   Character.isJavaIdentifierStart(c));
1230             check(&quot;{javaJavaIdentifierPart}&quot;, c,
1231                   Character.isJavaIdentifierPart(c));
1232             check(&quot;{javaUnicodeIdentifierStart}&quot;, c,
1233                   Character.isUnicodeIdentifierStart(c));
1234             check(&quot;{javaUnicodeIdentifierPart}&quot;, c,
1235                   Character.isUnicodeIdentifierPart(c));
1236             check(&quot;{javaIdentifierIgnorable}&quot;, c,
1237                   Character.isIdentifierIgnorable(c));
1238             check(&quot;{javaSpaceChar}&quot;, c, Character.isSpaceChar(c));
1239             check(&quot;{javaWhitespace}&quot;, c, Character.isWhitespace(c));
1240             check(&quot;{javaISOControl}&quot;, c, Character.isISOControl(c));
1241             check(&quot;{javaMirrored}&quot;, c, Character.isMirrored(c));
1242         }
1243 
1244         report(&quot;Java character classes&quot;);
1245     }
1246 
1247     // This test is for 4523620
1248     /*
1249     private static void numOccurrencesTest() throws Exception {
1250         Pattern pattern = Pattern.compile(&quot;aaa&quot;);
1251 
1252         if (pattern.numOccurrences(&quot;aaaaaa&quot;, false) != 2)
1253             failCount++;
1254         if (pattern.numOccurrences(&quot;aaaaaa&quot;, true) != 4)
1255             failCount++;
1256 
1257         pattern = Pattern.compile(&quot;^&quot;);
1258         if (pattern.numOccurrences(&quot;aaaaaa&quot;, false) != 1)
1259             failCount++;
1260         if (pattern.numOccurrences(&quot;aaaaaa&quot;, true) != 1)
1261             failCount++;
1262 
1263         report(&quot;Number of Occurrences&quot;);
1264     }
1265     */
1266 
1267     // This test is for 4776374
1268     private static void caretBetweenTerminatorsTest() throws Exception {
1269         int flags1 = Pattern.DOTALL;
1270         int flags2 = Pattern.DOTALL | Pattern.UNIX_LINES;
1271         int flags3 = Pattern.DOTALL | Pattern.UNIX_LINES | Pattern.MULTILINE;
1272         int flags4 = Pattern.DOTALL | Pattern.MULTILINE;
1273 
1274         check(&quot;^....&quot;, flags1, &quot;test\ntest&quot;, &quot;test&quot;, true);
1275         check(&quot;.....^&quot;, flags1, &quot;test\ntest&quot;, &quot;test&quot;, false);
1276         check(&quot;.....^&quot;, flags1, &quot;test\n&quot;, &quot;test&quot;, false);
1277         check(&quot;....^&quot;, flags1, &quot;test\r\n&quot;, &quot;test&quot;, false);
1278 
1279         check(&quot;^....&quot;, flags2, &quot;test\ntest&quot;, &quot;test&quot;, true);
1280         check(&quot;....^&quot;, flags2, &quot;test\ntest&quot;, &quot;test&quot;, false);
1281         check(&quot;.....^&quot;, flags2, &quot;test\n&quot;, &quot;test&quot;, false);
1282         check(&quot;....^&quot;, flags2, &quot;test\r\n&quot;, &quot;test&quot;, false);
1283 
1284         check(&quot;^....&quot;, flags3, &quot;test\ntest&quot;, &quot;test&quot;, true);
1285         check(&quot;.....^&quot;, flags3, &quot;test\ntest&quot;, &quot;test\n&quot;, true);
1286         check(&quot;.....^&quot;, flags3, &quot;test\u0085test&quot;, &quot;test\u0085&quot;, false);
1287         check(&quot;.....^&quot;, flags3, &quot;test\n&quot;, &quot;test&quot;, false);
1288         check(&quot;.....^&quot;, flags3, &quot;test\r\n&quot;, &quot;test&quot;, false);
1289         check(&quot;......^&quot;, flags3, &quot;test\r\ntest&quot;, &quot;test\r\n&quot;, true);
1290 
1291         check(&quot;^....&quot;, flags4, &quot;test\ntest&quot;, &quot;test&quot;, true);
1292         check(&quot;.....^&quot;, flags3, &quot;test\ntest&quot;, &quot;test\n&quot;, true);
1293         check(&quot;.....^&quot;, flags4, &quot;test\u0085test&quot;, &quot;test\u0085&quot;, true);
1294         check(&quot;.....^&quot;, flags4, &quot;test\n&quot;, &quot;test\n&quot;, false);
1295         check(&quot;.....^&quot;, flags4, &quot;test\r\n&quot;, &quot;test\r&quot;, false);
1296 
1297         // Supplementary character test
1298         String t = toSupplementaries(&quot;test&quot;);
1299         check(&quot;^....&quot;, flags1, t+&quot;\n&quot;+t, t, true);
1300         check(&quot;.....^&quot;, flags1, t+&quot;\n&quot;+t, t, false);
1301         check(&quot;.....^&quot;, flags1, t+&quot;\n&quot;, t, false);
1302         check(&quot;....^&quot;, flags1, t+&quot;\r\n&quot;, t, false);
1303 
1304         check(&quot;^....&quot;, flags2, t+&quot;\n&quot;+t, t, true);
1305         check(&quot;....^&quot;, flags2, t+&quot;\n&quot;+t, t, false);
1306         check(&quot;.....^&quot;, flags2, t+&quot;\n&quot;, t, false);
1307         check(&quot;....^&quot;, flags2, t+&quot;\r\n&quot;, t, false);
1308 
1309         check(&quot;^....&quot;, flags3, t+&quot;\n&quot;+t, t, true);
1310         check(&quot;.....^&quot;, flags3, t+&quot;\n&quot;+t, t+&quot;\n&quot;, true);
1311         check(&quot;.....^&quot;, flags3, t+&quot;\u0085&quot;+t, t+&quot;\u0085&quot;, false);
1312         check(&quot;.....^&quot;, flags3, t+&quot;\n&quot;, t, false);
1313         check(&quot;.....^&quot;, flags3, t+&quot;\r\n&quot;, t, false);
1314         check(&quot;......^&quot;, flags3, t+&quot;\r\n&quot;+t, t+&quot;\r\n&quot;, true);
1315 
1316         check(&quot;^....&quot;, flags4, t+&quot;\n&quot;+t, t, true);
1317         check(&quot;.....^&quot;, flags3, t+&quot;\n&quot;+t, t+&quot;\n&quot;, true);
1318         check(&quot;.....^&quot;, flags4, t+&quot;\u0085&quot;+t, t+&quot;\u0085&quot;, true);
1319         check(&quot;.....^&quot;, flags4, t+&quot;\n&quot;, t+&quot;\n&quot;, false);
1320         check(&quot;.....^&quot;, flags4, t+&quot;\r\n&quot;, t+&quot;\r&quot;, false);
1321 
1322         report(&quot;Caret between terminators&quot;);
1323     }
1324 
1325     // This test is for 4727935
1326     private static void dollarAtEndTest() throws Exception {
1327         int flags1 = Pattern.DOTALL;
1328         int flags2 = Pattern.DOTALL | Pattern.UNIX_LINES;
1329         int flags3 = Pattern.DOTALL | Pattern.MULTILINE;
1330 
1331         check(&quot;....$&quot;, flags1, &quot;test\n&quot;, &quot;test&quot;, true);
1332         check(&quot;....$&quot;, flags1, &quot;test\r\n&quot;, &quot;test&quot;, true);
1333         check(&quot;.....$&quot;, flags1, &quot;test\n&quot;, &quot;test\n&quot;, true);
1334         check(&quot;.....$&quot;, flags1, &quot;test\u0085&quot;, &quot;test\u0085&quot;, true);
1335         check(&quot;....$&quot;, flags1, &quot;test\u0085&quot;, &quot;test&quot;, true);
1336 
1337         check(&quot;....$&quot;, flags2, &quot;test\n&quot;, &quot;test&quot;, true);
1338         check(&quot;.....$&quot;, flags2, &quot;test\n&quot;, &quot;test\n&quot;, true);
1339         check(&quot;.....$&quot;, flags2, &quot;test\u0085&quot;, &quot;test\u0085&quot;, true);
1340         check(&quot;....$&quot;, flags2, &quot;test\u0085&quot;, &quot;est\u0085&quot;, true);
1341 
1342         check(&quot;....$.blah&quot;, flags3, &quot;test\nblah&quot;, &quot;test\nblah&quot;, true);
1343         check(&quot;.....$.blah&quot;, flags3, &quot;test\n\nblah&quot;, &quot;test\n\nblah&quot;, true);
1344         check(&quot;....$blah&quot;, flags3, &quot;test\nblah&quot;, &quot;!!!!&quot;, false);
1345         check(&quot;.....$blah&quot;, flags3, &quot;test\nblah&quot;, &quot;!!!!&quot;, false);
1346 
1347         // Supplementary character test
1348         String t = toSupplementaries(&quot;test&quot;);
1349         String b = toSupplementaries(&quot;blah&quot;);
1350         check(&quot;....$&quot;, flags1, t+&quot;\n&quot;, t, true);
1351         check(&quot;....$&quot;, flags1, t+&quot;\r\n&quot;, t, true);
1352         check(&quot;.....$&quot;, flags1, t+&quot;\n&quot;, t+&quot;\n&quot;, true);
1353         check(&quot;.....$&quot;, flags1, t+&quot;\u0085&quot;, t+&quot;\u0085&quot;, true);
1354         check(&quot;....$&quot;, flags1, t+&quot;\u0085&quot;, t, true);
1355 
1356         check(&quot;....$&quot;, flags2, t+&quot;\n&quot;, t, true);
1357         check(&quot;.....$&quot;, flags2, t+&quot;\n&quot;, t+&quot;\n&quot;, true);
1358         check(&quot;.....$&quot;, flags2, t+&quot;\u0085&quot;, t+&quot;\u0085&quot;, true);
1359         check(&quot;....$&quot;, flags2, t+&quot;\u0085&quot;, toSupplementaries(&quot;est\u0085&quot;), true);
1360 
1361         check(&quot;....$.&quot;+b, flags3, t+&quot;\n&quot;+b, t+&quot;\n&quot;+b, true);
1362         check(&quot;.....$.&quot;+b, flags3, t+&quot;\n\n&quot;+b, t+&quot;\n\n&quot;+b, true);
1363         check(&quot;....$&quot;+b, flags3, t+&quot;\n&quot;+b, &quot;!!!!&quot;, false);
1364         check(&quot;.....$&quot;+b, flags3, t+&quot;\n&quot;+b, &quot;!!!!&quot;, false);
1365 
1366         report(&quot;Dollar at End&quot;);
1367     }
1368 
1369     // This test is for 4711773
1370     private static void multilineDollarTest() throws Exception {
1371         Pattern findCR = Pattern.compile(&quot;$&quot;, Pattern.MULTILINE);
1372         Matcher matcher = findCR.matcher(&quot;first bit\nsecond bit&quot;);
1373         matcher.find();
1374         if (matcher.start(0) != 9)
1375             failCount++;
1376         matcher.find();
1377         if (matcher.start(0) != 20)
1378             failCount++;
1379 
1380         // Supplementary character test
1381         matcher = findCR.matcher(toSupplementaries(&quot;first  bit\n second  bit&quot;)); // double BMP chars
1382         matcher.find();
1383         if (matcher.start(0) != 9*2)
1384             failCount++;
1385         matcher.find();
1386         if (matcher.start(0) != 20*2)
1387             failCount++;
1388 
1389         report(&quot;Multiline Dollar&quot;);
1390     }
1391 
1392     private static void reluctantRepetitionTest() throws Exception {
1393         Pattern p = Pattern.compile(&quot;1(\\s\\S+?){1,3}?[\\s,]2&quot;);
1394         check(p, &quot;1 word word word 2&quot;, true);
1395         check(p, &quot;1 wor wo w 2&quot;, true);
1396         check(p, &quot;1 word word 2&quot;, true);
1397         check(p, &quot;1 word 2&quot;, true);
1398         check(p, &quot;1 wo w w 2&quot;, true);
1399         check(p, &quot;1 wo w 2&quot;, true);
1400         check(p, &quot;1 wor w 2&quot;, true);
1401 
1402         p = Pattern.compile(&quot;([a-z])+?c&quot;);
1403         Matcher m = p.matcher(&quot;ababcdefdec&quot;);
1404         check(m, &quot;ababc&quot;);
1405 
1406         // Supplementary character test
1407         p = Pattern.compile(toSupplementaries(&quot;([a-z])+?c&quot;));
1408         m = p.matcher(toSupplementaries(&quot;ababcdefdec&quot;));
1409         check(m, toSupplementaries(&quot;ababc&quot;));
1410 
1411         report(&quot;Reluctant Repetition&quot;);
1412     }
1413 
1414     private static Pattern serializedPattern(Pattern p) throws Exception {
1415         ByteArrayOutputStream baos = new ByteArrayOutputStream();
1416         ObjectOutputStream oos = new ObjectOutputStream(baos);
1417         oos.writeObject(p);
1418         oos.close();
1419         try (ObjectInputStream ois = new ObjectInputStream(
1420                 new ByteArrayInputStream(baos.toByteArray()))) {
1421             return (Pattern)ois.readObject();
1422         }
1423     }
1424 
1425     private static void serializeTest() throws Exception {
1426         String patternStr = &quot;(b)&quot;;
1427         String matchStr = &quot;b&quot;;
1428         Pattern pattern = Pattern.compile(patternStr);
1429         Pattern serializedPattern = serializedPattern(pattern);
1430         Matcher matcher = serializedPattern.matcher(matchStr);
1431         if (!matcher.matches())
1432             failCount++;
1433         if (matcher.groupCount() != 1)
1434             failCount++;
1435 
1436         pattern = Pattern.compile(&quot;a(?-i)b&quot;, Pattern.CASE_INSENSITIVE);
1437         serializedPattern = serializedPattern(pattern);
1438         if (!serializedPattern.matcher(&quot;Ab&quot;).matches())
1439             failCount++;
1440         if (serializedPattern.matcher(&quot;AB&quot;).matches())
1441             failCount++;
1442 
1443         report(&quot;Serialization&quot;);
1444     }
1445 
1446     private static void gTest() {
1447         Pattern pattern = Pattern.compile(&quot;\\G\\w&quot;);
1448         Matcher matcher = pattern.matcher(&quot;abc#x#x&quot;);
1449         matcher.find();
1450         matcher.find();
1451         matcher.find();
1452         if (matcher.find())
1453             failCount++;
1454 
1455         pattern = Pattern.compile(&quot;\\GA*&quot;);
1456         matcher = pattern.matcher(&quot;1A2AA3&quot;);
1457         matcher.find();
1458         if (matcher.find())
1459             failCount++;
1460 
1461         pattern = Pattern.compile(&quot;\\GA*&quot;);
1462         matcher = pattern.matcher(&quot;1A2AA3&quot;);
1463         if (!matcher.find(1))
1464             failCount++;
1465         matcher.find();
1466         if (matcher.find())
1467             failCount++;
1468 
1469         report(&quot;\\G&quot;);
1470     }
1471 
1472     private static void zTest() {
1473         Pattern pattern = Pattern.compile(&quot;foo\\Z&quot;);
1474         // Positives
1475         check(pattern, &quot;foo\u0085&quot;, true);
1476         check(pattern, &quot;foo\u2028&quot;, true);
1477         check(pattern, &quot;foo\u2029&quot;, true);
1478         check(pattern, &quot;foo\n&quot;, true);
1479         check(pattern, &quot;foo\r&quot;, true);
1480         check(pattern, &quot;foo\r\n&quot;, true);
1481         // Negatives
1482         check(pattern, &quot;fooo&quot;, false);
1483         check(pattern, &quot;foo\n\r&quot;, false);
1484 
1485         pattern = Pattern.compile(&quot;foo\\Z&quot;, Pattern.UNIX_LINES);
1486         // Positives
1487         check(pattern, &quot;foo&quot;, true);
1488         check(pattern, &quot;foo\n&quot;, true);
1489         // Negatives
1490         check(pattern, &quot;foo\r&quot;, false);
1491         check(pattern, &quot;foo\u0085&quot;, false);
1492         check(pattern, &quot;foo\u2028&quot;, false);
1493         check(pattern, &quot;foo\u2029&quot;, false);
1494 
1495         report(&quot;\\Z&quot;);
1496     }
1497 
1498     private static void replaceFirstTest() {
1499         Pattern pattern = Pattern.compile(&quot;(ab)(c*)&quot;);
1500         Matcher matcher = pattern.matcher(&quot;abccczzzabcczzzabccc&quot;);
1501         if (!matcher.replaceFirst(&quot;test&quot;).equals(&quot;testzzzabcczzzabccc&quot;))
1502             failCount++;
1503 
1504         matcher.reset(&quot;zzzabccczzzabcczzzabccczzz&quot;);
1505         if (!matcher.replaceFirst(&quot;test&quot;).equals(&quot;zzztestzzzabcczzzabccczzz&quot;))
1506             failCount++;
1507 
1508         matcher.reset(&quot;zzzabccczzzabcczzzabccczzz&quot;);
1509         String result = matcher.replaceFirst(&quot;$1&quot;);
1510         if (!result.equals(&quot;zzzabzzzabcczzzabccczzz&quot;))
1511             failCount++;
1512 
1513         matcher.reset(&quot;zzzabccczzzabcczzzabccczzz&quot;);
1514         result = matcher.replaceFirst(&quot;$2&quot;);
1515         if (!result.equals(&quot;zzzccczzzabcczzzabccczzz&quot;))
1516             failCount++;
1517 
1518         pattern = Pattern.compile(&quot;a*&quot;);
1519         matcher = pattern.matcher(&quot;aaaaaaaaaa&quot;);
1520         if (!matcher.replaceFirst(&quot;test&quot;).equals(&quot;test&quot;))
1521             failCount++;
1522 
1523         pattern = Pattern.compile(&quot;a+&quot;);
1524         matcher = pattern.matcher(&quot;zzzaaaaaaaaaa&quot;);
1525         if (!matcher.replaceFirst(&quot;test&quot;).equals(&quot;zzztest&quot;))
1526             failCount++;
1527 
1528         // Supplementary character test
1529         pattern = Pattern.compile(toSupplementaries(&quot;(ab)(c*)&quot;));
1530         matcher = pattern.matcher(toSupplementaries(&quot;abccczzzabcczzzabccc&quot;));
1531         if (!matcher.replaceFirst(toSupplementaries(&quot;test&quot;))
1532                 .equals(toSupplementaries(&quot;testzzzabcczzzabccc&quot;)))
1533             failCount++;
1534 
1535         matcher.reset(toSupplementaries(&quot;zzzabccczzzabcczzzabccczzz&quot;));
1536         if (!matcher.replaceFirst(toSupplementaries(&quot;test&quot;)).
1537             equals(toSupplementaries(&quot;zzztestzzzabcczzzabccczzz&quot;)))
1538             failCount++;
1539 
1540         matcher.reset(toSupplementaries(&quot;zzzabccczzzabcczzzabccczzz&quot;));
1541         result = matcher.replaceFirst(&quot;$1&quot;);
1542         if (!result.equals(toSupplementaries(&quot;zzzabzzzabcczzzabccczzz&quot;)))
1543             failCount++;
1544 
1545         matcher.reset(toSupplementaries(&quot;zzzabccczzzabcczzzabccczzz&quot;));
1546         result = matcher.replaceFirst(&quot;$2&quot;);
1547         if (!result.equals(toSupplementaries(&quot;zzzccczzzabcczzzabccczzz&quot;)))
1548             failCount++;
1549 
1550         pattern = Pattern.compile(toSupplementaries(&quot;a*&quot;));
1551         matcher = pattern.matcher(toSupplementaries(&quot;aaaaaaaaaa&quot;));
1552         if (!matcher.replaceFirst(toSupplementaries(&quot;test&quot;)).equals(toSupplementaries(&quot;test&quot;)))
1553             failCount++;
1554 
1555         pattern = Pattern.compile(toSupplementaries(&quot;a+&quot;));
1556         matcher = pattern.matcher(toSupplementaries(&quot;zzzaaaaaaaaaa&quot;));
1557         if (!matcher.replaceFirst(toSupplementaries(&quot;test&quot;)).equals(toSupplementaries(&quot;zzztest&quot;)))
1558             failCount++;
1559 
1560         report(&quot;Replace First&quot;);
1561     }
1562 
1563     private static void unixLinesTest() {
1564         Pattern pattern = Pattern.compile(&quot;.*&quot;);
1565         Matcher matcher = pattern.matcher(&quot;aa\u2028blah&quot;);
1566         matcher.find();
1567         if (!matcher.group(0).equals(&quot;aa&quot;))
1568             failCount++;
1569 
1570         pattern = Pattern.compile(&quot;.*&quot;, Pattern.UNIX_LINES);
1571         matcher = pattern.matcher(&quot;aa\u2028blah&quot;);
1572         matcher.find();
1573         if (!matcher.group(0).equals(&quot;aa\u2028blah&quot;))
1574             failCount++;
1575 
1576         pattern = Pattern.compile(&quot;[az]$&quot;,
1577                                   Pattern.MULTILINE | Pattern.UNIX_LINES);
1578         matcher = pattern.matcher(&quot;aa\u2028zz&quot;);
1579         check(matcher, &quot;a\u2028&quot;, false);
1580 
1581         // Supplementary character test
1582         pattern = Pattern.compile(&quot;.*&quot;);
1583         matcher = pattern.matcher(toSupplementaries(&quot;aa\u2028blah&quot;));
1584         matcher.find();
1585         if (!matcher.group(0).equals(toSupplementaries(&quot;aa&quot;)))
1586             failCount++;
1587 
1588         pattern = Pattern.compile(&quot;.*&quot;, Pattern.UNIX_LINES);
1589         matcher = pattern.matcher(toSupplementaries(&quot;aa\u2028blah&quot;));
1590         matcher.find();
1591         if (!matcher.group(0).equals(toSupplementaries(&quot;aa\u2028blah&quot;)))
1592             failCount++;
1593 
1594         pattern = Pattern.compile(toSupplementaries(&quot;[az]$&quot;),
1595                                   Pattern.MULTILINE | Pattern.UNIX_LINES);
1596         matcher = pattern.matcher(toSupplementaries(&quot;aa\u2028zz&quot;));
1597         check(matcher, toSupplementaries(&quot;a\u2028&quot;), false);
1598 
1599         report(&quot;Unix Lines&quot;);
1600     }
1601 
1602     private static void commentsTest() {
1603         int flags = Pattern.COMMENTS;
1604 
1605         Pattern pattern = Pattern.compile(&quot;aa \\# aa&quot;, flags);
1606         Matcher matcher = pattern.matcher(&quot;aa#aa&quot;);
1607         if (!matcher.matches())
1608             failCount++;
1609 
1610         pattern = Pattern.compile(&quot;aa  # blah&quot;, flags);
1611         matcher = pattern.matcher(&quot;aa&quot;);
1612         if (!matcher.matches())
1613             failCount++;
1614 
1615         pattern = Pattern.compile(&quot;aa blah&quot;, flags);
1616         matcher = pattern.matcher(&quot;aablah&quot;);
1617         if (!matcher.matches())
1618              failCount++;
1619 
1620         pattern = Pattern.compile(&quot;aa  # blah blech  &quot;, flags);
1621         matcher = pattern.matcher(&quot;aa&quot;);
1622         if (!matcher.matches())
1623             failCount++;
1624 
1625         pattern = Pattern.compile(&quot;aa  # blah\n  &quot;, flags);
1626         matcher = pattern.matcher(&quot;aa&quot;);
1627         if (!matcher.matches())
1628             failCount++;
1629 
1630         pattern = Pattern.compile(&quot;aa  # blah\nbc # blech&quot;, flags);
1631         matcher = pattern.matcher(&quot;aabc&quot;);
1632         if (!matcher.matches())
1633              failCount++;
1634 
1635         pattern = Pattern.compile(&quot;aa  # blah\nbc# blech&quot;, flags);
1636         matcher = pattern.matcher(&quot;aabc&quot;);
1637         if (!matcher.matches())
1638              failCount++;
1639 
1640         pattern = Pattern.compile(&quot;aa  # blah\nbc\\# blech&quot;, flags);
1641         matcher = pattern.matcher(&quot;aabc#blech&quot;);
1642         if (!matcher.matches())
1643              failCount++;
1644 
1645         // Supplementary character test
1646         pattern = Pattern.compile(toSupplementaries(&quot;aa \\# aa&quot;), flags);
1647         matcher = pattern.matcher(toSupplementaries(&quot;aa#aa&quot;));
1648         if (!matcher.matches())
1649             failCount++;
1650 
1651         pattern = Pattern.compile(toSupplementaries(&quot;aa  # blah&quot;), flags);
1652         matcher = pattern.matcher(toSupplementaries(&quot;aa&quot;));
1653         if (!matcher.matches())
1654             failCount++;
1655 
1656         pattern = Pattern.compile(toSupplementaries(&quot;aa blah&quot;), flags);
1657         matcher = pattern.matcher(toSupplementaries(&quot;aablah&quot;));
1658         if (!matcher.matches())
1659              failCount++;
1660 
1661         pattern = Pattern.compile(toSupplementaries(&quot;aa  # blah blech  &quot;), flags);
1662         matcher = pattern.matcher(toSupplementaries(&quot;aa&quot;));
1663         if (!matcher.matches())
1664             failCount++;
1665 
1666         pattern = Pattern.compile(toSupplementaries(&quot;aa  # blah\n  &quot;), flags);
1667         matcher = pattern.matcher(toSupplementaries(&quot;aa&quot;));
1668         if (!matcher.matches())
1669             failCount++;
1670 
1671         pattern = Pattern.compile(toSupplementaries(&quot;aa  # blah\nbc # blech&quot;), flags);
1672         matcher = pattern.matcher(toSupplementaries(&quot;aabc&quot;));
1673         if (!matcher.matches())
1674              failCount++;
1675 
1676         pattern = Pattern.compile(toSupplementaries(&quot;aa  # blah\nbc# blech&quot;), flags);
1677         matcher = pattern.matcher(toSupplementaries(&quot;aabc&quot;));
1678         if (!matcher.matches())
1679              failCount++;
1680 
1681         pattern = Pattern.compile(toSupplementaries(&quot;aa  # blah\nbc\\# blech&quot;), flags);
1682         matcher = pattern.matcher(toSupplementaries(&quot;aabc#blech&quot;));
1683         if (!matcher.matches())
1684              failCount++;
1685 
1686         report(&quot;Comments&quot;);
1687     }
1688 
1689     private static void caseFoldingTest() { // bug 4504687
1690         int flags = Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE;
1691         Pattern pattern = Pattern.compile(&quot;aa&quot;, flags);
1692         Matcher matcher = pattern.matcher(&quot;ab&quot;);
1693         if (matcher.matches())
1694             failCount++;
1695 
1696         pattern = Pattern.compile(&quot;aA&quot;, flags);
1697         matcher = pattern.matcher(&quot;ab&quot;);
1698         if (matcher.matches())
1699             failCount++;
1700 
1701         pattern = Pattern.compile(&quot;aa&quot;, flags);
1702         matcher = pattern.matcher(&quot;aB&quot;);
1703         if (matcher.matches())
1704             failCount++;
1705         matcher = pattern.matcher(&quot;Ab&quot;);
1706         if (matcher.matches())
1707             failCount++;
1708 
1709         // ASCII               &quot;a&quot;
1710         // Latin-1 Supplement  &quot;a&quot; + grave
1711         // Cyrillic            &quot;a&quot;
1712         String[] patterns = new String[] {
1713             //single
1714             &quot;a&quot;, &quot;\u00e0&quot;, &quot;\u0430&quot;,
1715             //slice
1716             &quot;ab&quot;, &quot;\u00e0\u00e1&quot;, &quot;\u0430\u0431&quot;,
1717             //class single
1718             &quot;[a]&quot;, &quot;[\u00e0]&quot;, &quot;[\u0430]&quot;,
1719             //class range
1720             &quot;[a-b]&quot;, &quot;[\u00e0-\u00e5]&quot;, &quot;[\u0430-\u0431]&quot;,
1721             //back reference
1722             &quot;(a)\\1&quot;, &quot;(\u00e0)\\1&quot;, &quot;(\u0430)\\1&quot;
1723         };
1724 
1725         String[] texts = new String[] {
1726             &quot;A&quot;, &quot;\u00c0&quot;, &quot;\u0410&quot;,
1727             &quot;AB&quot;, &quot;\u00c0\u00c1&quot;, &quot;\u0410\u0411&quot;,
1728             &quot;A&quot;, &quot;\u00c0&quot;, &quot;\u0410&quot;,
1729             &quot;B&quot;, &quot;\u00c2&quot;, &quot;\u0411&quot;,
1730             &quot;aA&quot;, &quot;\u00e0\u00c0&quot;, &quot;\u0430\u0410&quot;
1731         };
1732 
1733         boolean[] expected = new boolean[] {
1734             true, false, false,
1735             true, false, false,
1736             true, false, false,
1737             true, false, false,
1738             true, false, false
1739         };
1740 
1741         flags = Pattern.CASE_INSENSITIVE;
1742         for (int i = 0; i &lt; patterns.length; i++) {
1743             pattern = Pattern.compile(patterns[i], flags);
1744             matcher = pattern.matcher(texts[i]);
1745             if (matcher.matches() != expected[i]) {
1746                 System.out.println(&quot;&lt;1&gt; Failed at &quot; + i);
1747                 failCount++;
1748             }
1749         }
1750 
1751         flags = Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE;
1752         for (int i = 0; i &lt; patterns.length; i++) {
1753             pattern = Pattern.compile(patterns[i], flags);
1754             matcher = pattern.matcher(texts[i]);
1755             if (!matcher.matches()) {
1756                 System.out.println(&quot;&lt;2&gt; Failed at &quot; + i);
1757                 failCount++;
1758             }
1759         }
1760         // flag unicode_case alone should do nothing
1761         flags = Pattern.UNICODE_CASE;
1762         for (int i = 0; i &lt; patterns.length; i++) {
1763             pattern = Pattern.compile(patterns[i], flags);
1764             matcher = pattern.matcher(texts[i]);
1765             if (matcher.matches()) {
1766                 System.out.println(&quot;&lt;3&gt; Failed at &quot; + i);
1767                 failCount++;
1768             }
1769         }
1770 
1771         // Special cases: i, I, u+0131 and u+0130
1772         flags = Pattern.UNICODE_CASE | Pattern.CASE_INSENSITIVE;
1773         pattern = Pattern.compile(&quot;[h-j]+&quot;, flags);
1774         if (!pattern.matcher(&quot;\u0131\u0130&quot;).matches())
1775             failCount++;
1776         report(&quot;Case Folding&quot;);
1777     }
1778 
1779     private static void appendTest() {
1780         Pattern pattern = Pattern.compile(&quot;(ab)(cd)&quot;);
1781         Matcher matcher = pattern.matcher(&quot;abcd&quot;);
1782         String result = matcher.replaceAll(&quot;$2$1&quot;);
1783         if (!result.equals(&quot;cdab&quot;))
1784             failCount++;
1785 
1786         String  s1 = &quot;Swap all: first = 123, second = 456&quot;;
1787         String  s2 = &quot;Swap one: first = 123, second = 456&quot;;
1788         String  r  = &quot;$3$2$1&quot;;
1789         pattern = Pattern.compile(&quot;([a-z]+)( *= *)([0-9]+)&quot;);
1790         matcher = pattern.matcher(s1);
1791 
1792         result = matcher.replaceAll(r);
1793         if (!result.equals(&quot;Swap all: 123 = first, 456 = second&quot;))
1794             failCount++;
1795 
1796         matcher = pattern.matcher(s2);
1797 
1798         if (matcher.find()) {
1799             StringBuffer sb = new StringBuffer();
1800             matcher.appendReplacement(sb, r);
1801             matcher.appendTail(sb);
1802             result = sb.toString();
1803             if (!result.equals(&quot;Swap one: 123 = first, second = 456&quot;))
1804                 failCount++;
1805         }
1806 
1807         // Supplementary character test
1808         pattern = Pattern.compile(toSupplementaries(&quot;(ab)(cd)&quot;));
1809         matcher = pattern.matcher(toSupplementaries(&quot;abcd&quot;));
1810         result = matcher.replaceAll(&quot;$2$1&quot;);
1811         if (!result.equals(toSupplementaries(&quot;cdab&quot;)))
1812             failCount++;
1813 
1814         s1 = toSupplementaries(&quot;Swap all: first = 123, second = 456&quot;);
1815         s2 = toSupplementaries(&quot;Swap one: first = 123, second = 456&quot;);
1816         r  = toSupplementaries(&quot;$3$2$1&quot;);
1817         pattern = Pattern.compile(toSupplementaries(&quot;([a-z]+)( *= *)([0-9]+)&quot;));
1818         matcher = pattern.matcher(s1);
1819 
1820         result = matcher.replaceAll(r);
1821         if (!result.equals(toSupplementaries(&quot;Swap all: 123 = first, 456 = second&quot;)))
1822             failCount++;
1823 
1824         matcher = pattern.matcher(s2);
1825 
1826         if (matcher.find()) {
1827             StringBuffer sb = new StringBuffer();
1828             matcher.appendReplacement(sb, r);
1829             matcher.appendTail(sb);
1830             result = sb.toString();
1831             if (!result.equals(toSupplementaries(&quot;Swap one: 123 = first, second = 456&quot;)))
1832                 failCount++;
1833         }
1834         report(&quot;Append&quot;);
1835     }
1836 
1837     private static void splitTest() {
1838         Pattern pattern = Pattern.compile(&quot;:&quot;);
1839         String[] result = pattern.split(&quot;foo:and:boo&quot;, 2);
1840         if (!result[0].equals(&quot;foo&quot;))
1841             failCount++;
1842         if (!result[1].equals(&quot;and:boo&quot;))
1843             failCount++;
1844         // Supplementary character test
1845         Pattern patternX = Pattern.compile(toSupplementaries(&quot;X&quot;));
1846         result = patternX.split(toSupplementaries(&quot;fooXandXboo&quot;), 2);
1847         if (!result[0].equals(toSupplementaries(&quot;foo&quot;)))
1848             failCount++;
1849         if (!result[1].equals(toSupplementaries(&quot;andXboo&quot;)))
1850             failCount++;
1851 
1852         CharBuffer cb = CharBuffer.allocate(100);
1853         cb.put(&quot;foo:and:boo&quot;);
1854         cb.flip();
1855         result = pattern.split(cb);
1856         if (!result[0].equals(&quot;foo&quot;))
1857             failCount++;
1858         if (!result[1].equals(&quot;and&quot;))
1859             failCount++;
1860         if (!result[2].equals(&quot;boo&quot;))
1861             failCount++;
1862 
1863         // Supplementary character test
1864         CharBuffer cbs = CharBuffer.allocate(100);
1865         cbs.put(toSupplementaries(&quot;fooXandXboo&quot;));
1866         cbs.flip();
1867         result = patternX.split(cbs);
1868         if (!result[0].equals(toSupplementaries(&quot;foo&quot;)))
1869             failCount++;
1870         if (!result[1].equals(toSupplementaries(&quot;and&quot;)))
1871             failCount++;
1872         if (!result[2].equals(toSupplementaries(&quot;boo&quot;)))
1873             failCount++;
1874 
1875         String source = &quot;0123456789&quot;;
1876         for (int limit=-2; limit&lt;3; limit++) {
1877             for (int x=0; x&lt;10; x++) {
1878                 result = source.split(Integer.toString(x), limit);
1879                 int expectedLength = limit &lt; 1 ? 2 : limit;
1880 
1881                 if ((limit == 0) &amp;&amp; (x == 9)) {
1882                     // expected dropping of &quot;&quot;
1883                     if (result.length != 1)
1884                         failCount++;
1885                     if (!result[0].equals(&quot;012345678&quot;)) {
1886                         failCount++;
1887                     }
1888                 } else {
1889                     if (result.length != expectedLength) {
1890                         failCount++;
1891                     }
1892                     if (!result[0].equals(source.substring(0,x))) {
1893                         if (limit != 1) {
1894                             failCount++;
1895                         } else {
1896                             if (!result[0].equals(source.substring(0,10))) {
1897                                 failCount++;
1898                             }
1899                         }
1900                     }
1901                     if (expectedLength &gt; 1) { // Check segment 2
1902                         if (!result[1].equals(source.substring(x+1,10)))
1903                             failCount++;
1904                     }
1905                 }
1906             }
1907         }
1908         // Check the case for no match found
1909         for (int limit=-2; limit&lt;3; limit++) {
1910             result = source.split(&quot;e&quot;, limit);
1911             if (result.length != 1)
1912                 failCount++;
1913             if (!result[0].equals(source))
1914                 failCount++;
1915         }
1916         // Check the case for limit == 0, source = &quot;&quot;;
1917         // split() now returns 0-length for empty source &quot;&quot; see #6559590
1918         source = &quot;&quot;;
1919         result = source.split(&quot;e&quot;, 0);
1920         if (result.length != 1)
1921             failCount++;
1922         if (!result[0].equals(source))
1923             failCount++;
1924 
1925         // Check both split() and splitAsStraem(), especially for zero-lenth
1926         // input and zero-lenth match cases
1927         String[][] input = new String[][] {
1928             { &quot; &quot;,           &quot;Abc Efg Hij&quot; },   // normal non-zero-match
1929             { &quot; &quot;,           &quot; Abc Efg Hij&quot; },  // leading empty str for non-zero-match
1930             { &quot; &quot;,           &quot;Abc  Efg Hij&quot; },  // non-zero-match in the middle
1931             { &quot;(?=\\p{Lu})&quot;, &quot;AbcEfgHij&quot; },     // no leading empty str for zero-match
1932             { &quot;(?=\\p{Lu})&quot;, &quot;AbcEfg&quot; },
1933             { &quot;(?=\\p{Lu})&quot;, &quot;Abc&quot; },
1934             { &quot; &quot;,           &quot;&quot; },              // zero-length input
1935             { &quot;.*&quot;,          &quot;&quot; },
1936 
1937             // some tests from PatternStreamTest.java
1938             { &quot;4&quot;,       &quot;awgqwefg1fefw4vssv1vvv1&quot; },
1939             { &quot;\u00a3a&quot;, &quot;afbfq\u00a3abgwgb\u00a3awngnwggw\u00a3a\u00a3ahjrnhneerh&quot; },
1940             { &quot;1&quot;,       &quot;awgqwefg1fefw4vssv1vvv1&quot; },
1941             { &quot;1&quot;,       &quot;a\u4ebafg1fefw\u4eba4\u9f9cvssv\u9f9c1v\u672c\u672cvv&quot; },
1942             { &quot;\u56da&quot;,  &quot;1\u56da23\u56da456\u56da7890&quot; },
1943             { &quot;\u56da&quot;,  &quot;1\u56da23\u9f9c\u672c\u672c\u56da456\u56da\u9f9c\u672c7890&quot; },
1944             { &quot;\u56da&quot;,  &quot;&quot; },
1945             { &quot;[ \t,:.]&quot;,&quot;This is,testing: with\tdifferent separators.&quot; }, //multiple septs
1946             { &quot;o&quot;,       &quot;boo:and:foo&quot; },
1947             { &quot;o&quot;,       &quot;booooo:and:fooooo&quot; },
1948             { &quot;o&quot;,       &quot;fooooo:&quot; },
1949         };
1950 
1951         String[][] expected = new String[][] {
1952             { &quot;Abc&quot;, &quot;Efg&quot;, &quot;Hij&quot; },
1953             { &quot;&quot;, &quot;Abc&quot;, &quot;Efg&quot;, &quot;Hij&quot; },
1954             { &quot;Abc&quot;, &quot;&quot;, &quot;Efg&quot;, &quot;Hij&quot; },
1955             { &quot;Abc&quot;, &quot;Efg&quot;, &quot;Hij&quot; },
1956             { &quot;Abc&quot;, &quot;Efg&quot; },
1957             { &quot;Abc&quot; },
1958             { &quot;&quot; },
1959             { &quot;&quot; },
1960 
1961             { &quot;awgqwefg1fefw&quot;, &quot;vssv1vvv1&quot; },
1962             { &quot;afbfq&quot;, &quot;bgwgb&quot;, &quot;wngnwggw&quot;, &quot;&quot;, &quot;hjrnhneerh&quot; },
1963             { &quot;awgqwefg&quot;, &quot;fefw4vssv&quot;, &quot;vvv&quot; },
1964             { &quot;a\u4ebafg&quot;, &quot;fefw\u4eba4\u9f9cvssv\u9f9c&quot;, &quot;v\u672c\u672cvv&quot; },
1965             { &quot;1&quot;, &quot;23&quot;, &quot;456&quot;, &quot;7890&quot; },
1966             { &quot;1&quot;, &quot;23\u9f9c\u672c\u672c&quot;, &quot;456&quot;, &quot;\u9f9c\u672c7890&quot; },
1967             { &quot;&quot; },
1968             { &quot;This&quot;, &quot;is&quot;, &quot;testing&quot;, &quot;&quot;, &quot;with&quot;, &quot;different&quot;, &quot;separators&quot; },
1969             { &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot; },
1970             { &quot;b&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;:and:f&quot; },
1971             { &quot;f&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;:&quot; },
1972         };
1973         for (int i = 0; i &lt; input.length; i++) {
1974             pattern = Pattern.compile(input[i][0]);
1975             if (!Arrays.equals(pattern.split(input[i][1]), expected[i])) {
1976                 failCount++;
1977             }
1978             if (input[i][1].length() &gt; 0 &amp;&amp;  // splitAsStream() return empty resulting
1979                                              // array for zero-length input for now
1980                 !Arrays.equals(pattern.splitAsStream(input[i][1]).toArray(),
1981                                expected[i])) {
1982                 failCount++;
1983             }
1984         }
1985         report(&quot;Split&quot;);
1986     }
1987 
1988     private static void negationTest() {
1989         Pattern pattern = Pattern.compile(&quot;[\\[@^]+&quot;);
1990         Matcher matcher = pattern.matcher(&quot;@@@@[[[[^^^^&quot;);
1991         if (!matcher.find())
1992             failCount++;
1993         if (!matcher.group(0).equals(&quot;@@@@[[[[^^^^&quot;))
1994             failCount++;
1995         pattern = Pattern.compile(&quot;[@\\[^]+&quot;);
1996         matcher = pattern.matcher(&quot;@@@@[[[[^^^^&quot;);
1997         if (!matcher.find())
1998             failCount++;
1999         if (!matcher.group(0).equals(&quot;@@@@[[[[^^^^&quot;))
2000             failCount++;
2001         pattern = Pattern.compile(&quot;[@\\[^@]+&quot;);
2002         matcher = pattern.matcher(&quot;@@@@[[[[^^^^&quot;);
2003         if (!matcher.find())
2004             failCount++;
2005         if (!matcher.group(0).equals(&quot;@@@@[[[[^^^^&quot;))
2006             failCount++;
2007 
2008         pattern = Pattern.compile(&quot;\\)&quot;);
2009         matcher = pattern.matcher(&quot;xxx)xxx&quot;);
2010         if (!matcher.find())
2011             failCount++;
2012 
2013         report(&quot;Negation&quot;);
2014     }
2015 
2016     private static void ampersandTest() {
2017         Pattern pattern = Pattern.compile(&quot;[&amp;@]+&quot;);
2018         check(pattern, &quot;@@@@&amp;&amp;&amp;&amp;&quot;, true);
2019 
2020         pattern = Pattern.compile(&quot;[@&amp;]+&quot;);
2021         check(pattern, &quot;@@@@&amp;&amp;&amp;&amp;&quot;, true);
2022 
2023         pattern = Pattern.compile(&quot;[@\\&amp;]+&quot;);
2024         check(pattern, &quot;@@@@&amp;&amp;&amp;&amp;&quot;, true);
2025 
2026         report(&quot;Ampersand&quot;);
2027     }
2028 
2029     private static void octalTest() throws Exception {
2030         Pattern pattern = Pattern.compile(&quot;\\u0007&quot;);
2031         Matcher matcher = pattern.matcher(&quot;\u0007&quot;);
2032         if (!matcher.matches())
2033             failCount++;
2034         pattern = Pattern.compile(&quot;\\07&quot;);
2035         matcher = pattern.matcher(&quot;\u0007&quot;);
2036         if (!matcher.matches())
2037             failCount++;
2038         pattern = Pattern.compile(&quot;\\007&quot;);
2039         matcher = pattern.matcher(&quot;\u0007&quot;);
2040         if (!matcher.matches())
2041             failCount++;
2042         pattern = Pattern.compile(&quot;\\0007&quot;);
2043         matcher = pattern.matcher(&quot;\u0007&quot;);
2044         if (!matcher.matches())
2045             failCount++;
2046         pattern = Pattern.compile(&quot;\\040&quot;);
2047         matcher = pattern.matcher(&quot;\u0020&quot;);
2048         if (!matcher.matches())
2049             failCount++;
2050         pattern = Pattern.compile(&quot;\\0403&quot;);
2051         matcher = pattern.matcher(&quot;\u00203&quot;);
2052         if (!matcher.matches())
2053             failCount++;
2054         pattern = Pattern.compile(&quot;\\0103&quot;);
2055         matcher = pattern.matcher(&quot;\u0043&quot;);
2056         if (!matcher.matches())
2057             failCount++;
2058 
2059         report(&quot;Octal&quot;);
2060     }
2061 
2062     private static void longPatternTest() throws Exception {
2063         try {
2064             Pattern pattern = Pattern.compile(
2065                 &quot;a 32-character-long pattern xxxx&quot;);
2066             pattern = Pattern.compile(&quot;a 33-character-long pattern xxxxx&quot;);
2067             pattern = Pattern.compile(&quot;a thirty four character long regex&quot;);
2068             StringBuffer patternToBe = new StringBuffer(101);
2069             for (int i=0; i&lt;100; i++)
2070                 patternToBe.append((char)(97 + i%26));
2071             pattern = Pattern.compile(patternToBe.toString());
2072         } catch (PatternSyntaxException e) {
2073             failCount++;
2074         }
2075 
2076         // Supplementary character test
2077         try {
2078             Pattern pattern = Pattern.compile(
2079                 toSupplementaries(&quot;a 32-character-long pattern xxxx&quot;));
2080             pattern = Pattern.compile(toSupplementaries(&quot;a 33-character-long pattern xxxxx&quot;));
2081             pattern = Pattern.compile(toSupplementaries(&quot;a thirty four character long regex&quot;));
2082             StringBuffer patternToBe = new StringBuffer(101*2);
2083             for (int i=0; i&lt;100; i++)
2084                 patternToBe.append(Character.toChars(Character.MIN_SUPPLEMENTARY_CODE_POINT
2085                                                      + 97 + i%26));
2086             pattern = Pattern.compile(patternToBe.toString());
2087         } catch (PatternSyntaxException e) {
2088             failCount++;
2089         }
2090         report(&quot;LongPattern&quot;);
2091     }
2092 
2093     private static void group0Test() throws Exception {
2094         Pattern pattern = Pattern.compile(&quot;(tes)ting&quot;);
2095         Matcher matcher = pattern.matcher(&quot;testing&quot;);
2096         check(matcher, &quot;testing&quot;);
2097 
2098         matcher.reset(&quot;testing&quot;);
2099         if (matcher.lookingAt()) {
2100             if (!matcher.group(0).equals(&quot;testing&quot;))
2101                 failCount++;
2102         } else {
2103             failCount++;
2104         }
2105 
2106         matcher.reset(&quot;testing&quot;);
2107         if (matcher.matches()) {
2108             if (!matcher.group(0).equals(&quot;testing&quot;))
2109                 failCount++;
2110         } else {
2111             failCount++;
2112         }
2113 
2114         pattern = Pattern.compile(&quot;(tes)ting&quot;);
2115         matcher = pattern.matcher(&quot;testing&quot;);
2116         if (matcher.lookingAt()) {
2117             if (!matcher.group(0).equals(&quot;testing&quot;))
2118                 failCount++;
2119         } else {
2120             failCount++;
2121         }
2122 
2123         pattern = Pattern.compile(&quot;^(tes)ting&quot;);
2124         matcher = pattern.matcher(&quot;testing&quot;);
2125         if (matcher.matches()) {
2126             if (!matcher.group(0).equals(&quot;testing&quot;))
2127                 failCount++;
2128         } else {
2129             failCount++;
2130         }
2131 
2132         // Supplementary character test
2133         pattern = Pattern.compile(toSupplementaries(&quot;(tes)ting&quot;));
2134         matcher = pattern.matcher(toSupplementaries(&quot;testing&quot;));
2135         check(matcher, toSupplementaries(&quot;testing&quot;));
2136 
2137         matcher.reset(toSupplementaries(&quot;testing&quot;));
2138         if (matcher.lookingAt()) {
2139             if (!matcher.group(0).equals(toSupplementaries(&quot;testing&quot;)))
2140                 failCount++;
2141         } else {
2142             failCount++;
2143         }
2144 
2145         matcher.reset(toSupplementaries(&quot;testing&quot;));
2146         if (matcher.matches()) {
2147             if (!matcher.group(0).equals(toSupplementaries(&quot;testing&quot;)))
2148                 failCount++;
2149         } else {
2150             failCount++;
2151         }
2152 
2153         pattern = Pattern.compile(toSupplementaries(&quot;(tes)ting&quot;));
2154         matcher = pattern.matcher(toSupplementaries(&quot;testing&quot;));
2155         if (matcher.lookingAt()) {
2156             if (!matcher.group(0).equals(toSupplementaries(&quot;testing&quot;)))
2157                 failCount++;
2158         } else {
2159             failCount++;
2160         }
2161 
2162         pattern = Pattern.compile(toSupplementaries(&quot;^(tes)ting&quot;));
2163         matcher = pattern.matcher(toSupplementaries(&quot;testing&quot;));
2164         if (matcher.matches()) {
2165             if (!matcher.group(0).equals(toSupplementaries(&quot;testing&quot;)))
2166                 failCount++;
2167         } else {
2168             failCount++;
2169         }
2170 
2171         report(&quot;Group0&quot;);
2172     }
2173 
2174     private static void findIntTest() throws Exception {
2175         Pattern p = Pattern.compile(&quot;blah&quot;);
2176         Matcher m = p.matcher(&quot;zzzzblahzzzzzblah&quot;);
2177         boolean result = m.find(2);
2178         if (!result)
2179             failCount++;
2180 
2181         p = Pattern.compile(&quot;$&quot;);
2182         m = p.matcher(&quot;1234567890&quot;);
2183         result = m.find(10);
2184         if (!result)
2185             failCount++;
2186         try {
2187             result = m.find(11);
2188             failCount++;
2189         } catch (IndexOutOfBoundsException e) {
2190             // correct result
2191         }
2192 
2193         // Supplementary character test
2194         p = Pattern.compile(toSupplementaries(&quot;blah&quot;));
2195         m = p.matcher(toSupplementaries(&quot;zzzzblahzzzzzblah&quot;));
2196         result = m.find(2);
2197         if (!result)
2198             failCount++;
2199 
2200         report(&quot;FindInt&quot;);
2201     }
2202 
2203     private static void emptyPatternTest() throws Exception {
2204         Pattern p = Pattern.compile(&quot;&quot;);
2205         Matcher m = p.matcher(&quot;foo&quot;);
2206 
2207         // Should find empty pattern at beginning of input
2208         boolean result = m.find();
2209         if (result != true)
2210             failCount++;
2211         if (m.start() != 0)
2212             failCount++;
2213 
2214         // Should not match entire input if input is not empty
2215         m.reset();
2216         result = m.matches();
2217         if (result == true)
2218             failCount++;
2219 
2220         try {
2221             m.start(0);
2222             failCount++;
2223         } catch (IllegalStateException e) {
2224             // Correct result
2225         }
2226 
2227         // Should match entire input if input is empty
2228         m.reset(&quot;&quot;);
2229         result = m.matches();
2230         if (result != true)
2231             failCount++;
2232 
2233         result = Pattern.matches(&quot;&quot;, &quot;&quot;);
2234         if (result != true)
2235             failCount++;
2236 
2237         result = Pattern.matches(&quot;&quot;, &quot;foo&quot;);
2238         if (result == true)
2239             failCount++;
2240         report(&quot;EmptyPattern&quot;);
2241     }
2242 
2243     private static void charClassTest() throws Exception {
2244         Pattern pattern = Pattern.compile(&quot;blah[ab]]blech&quot;);
2245         check(pattern, &quot;blahb]blech&quot;, true);
2246 
2247         pattern = Pattern.compile(&quot;[abc[def]]&quot;);
2248         check(pattern, &quot;b&quot;, true);
2249 
2250         // Supplementary character tests
2251         pattern = Pattern.compile(toSupplementaries(&quot;blah[ab]]blech&quot;));
2252         check(pattern, toSupplementaries(&quot;blahb]blech&quot;), true);
2253 
2254         pattern = Pattern.compile(toSupplementaries(&quot;[abc[def]]&quot;));
2255         check(pattern, toSupplementaries(&quot;b&quot;), true);
2256 
2257         try {
2258             // u00ff when UNICODE_CASE
2259             pattern = Pattern.compile(&quot;[ab\u00ffcd]&quot;,
2260                                       Pattern.CASE_INSENSITIVE|
2261                                       Pattern.UNICODE_CASE);
2262             check(pattern, &quot;ab\u00ffcd&quot;, true);
2263             check(pattern, &quot;Ab\u0178Cd&quot;, true);
2264 
2265             // u00b5 when UNICODE_CASE
2266             pattern = Pattern.compile(&quot;[ab\u00b5cd]&quot;,
2267                                       Pattern.CASE_INSENSITIVE|
2268                                       Pattern.UNICODE_CASE);
2269             check(pattern, &quot;ab\u00b5cd&quot;, true);
2270             check(pattern, &quot;Ab\u039cCd&quot;, true);
2271         } catch (Exception e) { failCount++; }
2272 
2273         /* Special cases
2274            (1)LatinSmallLetterLongS u+017f
2275            (2)LatinSmallLetterDotlessI u+0131
2276            (3)LatineCapitalLetterIWithDotAbove u+0130
2277            (4)KelvinSign u+212a
2278            (5)AngstromSign u+212b
2279         */
2280         int flags = Pattern.UNICODE_CASE | Pattern.CASE_INSENSITIVE;
2281         pattern = Pattern.compile(&quot;[sik\u00c5]+&quot;, flags);
2282         if (!pattern.matcher(&quot;\u017f\u0130\u0131\u212a\u212b&quot;).matches())
2283             failCount++;
2284 
2285         report(&quot;CharClass&quot;);
2286     }
2287 
2288     private static void caretTest() throws Exception {
2289         Pattern pattern = Pattern.compile(&quot;\\w*&quot;);
2290         Matcher matcher = pattern.matcher(&quot;a#bc#def##g&quot;);
2291         check(matcher, &quot;a&quot;);
2292         check(matcher, &quot;&quot;);
2293         check(matcher, &quot;bc&quot;);
2294         check(matcher, &quot;&quot;);
2295         check(matcher, &quot;def&quot;);
2296         check(matcher, &quot;&quot;);
2297         check(matcher, &quot;&quot;);
2298         check(matcher, &quot;g&quot;);
2299         check(matcher, &quot;&quot;);
2300         if (matcher.find())
2301             failCount++;
2302 
2303         pattern = Pattern.compile(&quot;^\\w*&quot;);
2304         matcher = pattern.matcher(&quot;a#bc#def##g&quot;);
2305         check(matcher, &quot;a&quot;);
2306         if (matcher.find())
2307             failCount++;
2308 
2309         pattern = Pattern.compile(&quot;\\w&quot;);
2310         matcher = pattern.matcher(&quot;abc##x&quot;);
2311         check(matcher, &quot;a&quot;);
2312         check(matcher, &quot;b&quot;);
2313         check(matcher, &quot;c&quot;);
2314         check(matcher, &quot;x&quot;);
2315         if (matcher.find())
2316             failCount++;
2317 
2318         pattern = Pattern.compile(&quot;^\\w&quot;);
2319         matcher = pattern.matcher(&quot;abc##x&quot;);
2320         check(matcher, &quot;a&quot;);
2321         if (matcher.find())
2322             failCount++;
2323 
2324         pattern = Pattern.compile(&quot;\\A\\p{Alpha}{3}&quot;);
2325         matcher = pattern.matcher(&quot;abcdef-ghi\njklmno&quot;);
2326         check(matcher, &quot;abc&quot;);
2327         if (matcher.find())
2328             failCount++;
2329 
2330         pattern = Pattern.compile(&quot;^\\p{Alpha}{3}&quot;, Pattern.MULTILINE);
2331         matcher = pattern.matcher(&quot;abcdef-ghi\njklmno&quot;);
2332         check(matcher, &quot;abc&quot;);
2333         check(matcher, &quot;jkl&quot;);
2334         if (matcher.find())
2335             failCount++;
2336 
2337         pattern = Pattern.compile(&quot;^&quot;, Pattern.MULTILINE);
2338         matcher = pattern.matcher(&quot;this is some text&quot;);
2339         String result = matcher.replaceAll(&quot;X&quot;);
2340         if (!result.equals(&quot;Xthis is some text&quot;))
2341             failCount++;
2342 
2343         pattern = Pattern.compile(&quot;^&quot;);
2344         matcher = pattern.matcher(&quot;this is some text&quot;);
2345         result = matcher.replaceAll(&quot;X&quot;);
2346         if (!result.equals(&quot;Xthis is some text&quot;))
2347             failCount++;
2348 
2349         pattern = Pattern.compile(&quot;^&quot;, Pattern.MULTILINE | Pattern.UNIX_LINES);
2350         matcher = pattern.matcher(&quot;this is some text\n&quot;);
2351         result = matcher.replaceAll(&quot;X&quot;);
2352         if (!result.equals(&quot;Xthis is some text\n&quot;))
2353             failCount++;
2354 
2355         report(&quot;Caret&quot;);
2356     }
2357 
2358     private static void groupCaptureTest() throws Exception {
2359         // Independent group
2360         Pattern pattern = Pattern.compile(&quot;x+(?&gt;y+)z+&quot;);
2361         Matcher matcher = pattern.matcher(&quot;xxxyyyzzz&quot;);
2362         matcher.find();
2363         try {
2364             String blah = matcher.group(1);
2365             failCount++;
2366         } catch (IndexOutOfBoundsException ioobe) {
2367             // Good result
2368         }
2369         // Pure group
2370         pattern = Pattern.compile(&quot;x+(?:y+)z+&quot;);
2371         matcher = pattern.matcher(&quot;xxxyyyzzz&quot;);
2372         matcher.find();
2373         try {
2374             String blah = matcher.group(1);
2375             failCount++;
2376         } catch (IndexOutOfBoundsException ioobe) {
2377             // Good result
2378         }
2379 
2380         // Supplementary character tests
2381         // Independent group
2382         pattern = Pattern.compile(toSupplementaries(&quot;x+(?&gt;y+)z+&quot;));
2383         matcher = pattern.matcher(toSupplementaries(&quot;xxxyyyzzz&quot;));
2384         matcher.find();
2385         try {
2386             String blah = matcher.group(1);
2387             failCount++;
2388         } catch (IndexOutOfBoundsException ioobe) {
2389             // Good result
2390         }
2391         // Pure group
2392         pattern = Pattern.compile(toSupplementaries(&quot;x+(?:y+)z+&quot;));
2393         matcher = pattern.matcher(toSupplementaries(&quot;xxxyyyzzz&quot;));
2394         matcher.find();
2395         try {
2396             String blah = matcher.group(1);
2397             failCount++;
2398         } catch (IndexOutOfBoundsException ioobe) {
2399             // Good result
2400         }
2401 
2402         report(&quot;GroupCapture&quot;);
2403     }
2404 
2405     private static void backRefTest() throws Exception {
2406         Pattern pattern = Pattern.compile(&quot;(a*)bc\\1&quot;);
2407         check(pattern, &quot;zzzaabcazzz&quot;, true);
2408 
2409         pattern = Pattern.compile(&quot;(a*)bc\\1&quot;);
2410         check(pattern, &quot;zzzaabcaazzz&quot;, true);
2411 
2412         pattern = Pattern.compile(&quot;(abc)(def)\\1&quot;);
2413         check(pattern, &quot;abcdefabc&quot;, true);
2414 
2415         pattern = Pattern.compile(&quot;(abc)(def)\\3&quot;);
2416         check(pattern, &quot;abcdefabc&quot;, false);
2417 
2418         try {
2419             for (int i = 1; i &lt; 10; i++) {
2420                 // Make sure backref 1-9 are always accepted
2421                 pattern = Pattern.compile(&quot;abcdef\\&quot; + i);
2422                 // and fail to match if the target group does not exit
2423                 check(pattern, &quot;abcdef&quot;, false);
2424             }
2425         } catch(PatternSyntaxException e) {
2426             failCount++;
2427         }
2428 
2429         pattern = Pattern.compile(&quot;(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)\\11&quot;);
2430         check(pattern, &quot;abcdefghija&quot;, false);
2431         check(pattern, &quot;abcdefghija1&quot;, true);
2432 
2433         pattern = Pattern.compile(&quot;(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)\\11&quot;);
2434         check(pattern, &quot;abcdefghijkk&quot;, true);
2435 
2436         pattern = Pattern.compile(&quot;(a)bcdefghij\\11&quot;);
2437         check(pattern, &quot;abcdefghija1&quot;, true);
2438 
2439         // Supplementary character tests
2440         pattern = Pattern.compile(toSupplementaries(&quot;(a*)bc\\1&quot;));
2441         check(pattern, toSupplementaries(&quot;zzzaabcazzz&quot;), true);
2442 
2443         pattern = Pattern.compile(toSupplementaries(&quot;(a*)bc\\1&quot;));
2444         check(pattern, toSupplementaries(&quot;zzzaabcaazzz&quot;), true);
2445 
2446         pattern = Pattern.compile(toSupplementaries(&quot;(abc)(def)\\1&quot;));
2447         check(pattern, toSupplementaries(&quot;abcdefabc&quot;), true);
2448 
2449         pattern = Pattern.compile(toSupplementaries(&quot;(abc)(def)\\3&quot;));
2450         check(pattern, toSupplementaries(&quot;abcdefabc&quot;), false);
2451 
2452         pattern = Pattern.compile(toSupplementaries(&quot;(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)\\11&quot;));
2453         check(pattern, toSupplementaries(&quot;abcdefghija&quot;), false);
2454         check(pattern, toSupplementaries(&quot;abcdefghija1&quot;), true);
2455 
2456         pattern = Pattern.compile(toSupplementaries(&quot;(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)\\11&quot;));
2457         check(pattern, toSupplementaries(&quot;abcdefghijkk&quot;), true);
2458 
2459         report(&quot;BackRef&quot;);
2460     }
2461 
2462     /**
2463      * Unicode Technical Report #18, section 2.6 End of Line
2464      * There is no empty line to be matched in the sequence \u000D\u000A
2465      * but there is an empty line in the sequence \u000A\u000D.
2466      */
2467     private static void anchorTest() throws Exception {
2468         Pattern p = Pattern.compile(&quot;^.*$&quot;, Pattern.MULTILINE);
2469         Matcher m = p.matcher(&quot;blah1\r\nblah2&quot;);
2470         m.find();
2471         m.find();
2472         if (!m.group().equals(&quot;blah2&quot;))
2473             failCount++;
2474 
2475         m.reset(&quot;blah1\n\rblah2&quot;);
2476         m.find();
2477         m.find();
2478         m.find();
2479         if (!m.group().equals(&quot;blah2&quot;))
2480             failCount++;
2481 
2482         // Test behavior of $ with \r\n at end of input
2483         p = Pattern.compile(&quot;.+$&quot;);
2484         m = p.matcher(&quot;blah1\r\n&quot;);
2485         if (!m.find())
2486             failCount++;
2487        if (!m.group().equals(&quot;blah1&quot;))
2488             failCount++;
2489         if (m.find())
2490             failCount++;
2491 
2492         // Test behavior of $ with \r\n at end of input in multiline
2493         p = Pattern.compile(&quot;.+$&quot;, Pattern.MULTILINE);
2494         m = p.matcher(&quot;blah1\r\n&quot;);
2495         if (!m.find())
2496             failCount++;
2497         if (m.find())
2498             failCount++;
2499 
2500         // Test for $ recognition of \u0085 for bug 4527731
2501         p = Pattern.compile(&quot;.+$&quot;, Pattern.MULTILINE);
2502         m = p.matcher(&quot;blah1\u0085&quot;);
2503         if (!m.find())
2504             failCount++;
2505 
2506         // Supplementary character test
2507         p = Pattern.compile(&quot;^.*$&quot;, Pattern.MULTILINE);
2508         m = p.matcher(toSupplementaries(&quot;blah1\r\nblah2&quot;));
2509         m.find();
2510         m.find();
2511         if (!m.group().equals(toSupplementaries(&quot;blah2&quot;)))
2512             failCount++;
2513 
2514         m.reset(toSupplementaries(&quot;blah1\n\rblah2&quot;));
2515         m.find();
2516         m.find();
2517         m.find();
2518         if (!m.group().equals(toSupplementaries(&quot;blah2&quot;)))
2519             failCount++;
2520 
2521         // Test behavior of $ with \r\n at end of input
2522         p = Pattern.compile(&quot;.+$&quot;);
2523         m = p.matcher(toSupplementaries(&quot;blah1\r\n&quot;));
2524         if (!m.find())
2525             failCount++;
2526         if (!m.group().equals(toSupplementaries(&quot;blah1&quot;)))
2527             failCount++;
2528         if (m.find())
2529             failCount++;
2530 
2531         // Test behavior of $ with \r\n at end of input in multiline
2532         p = Pattern.compile(&quot;.+$&quot;, Pattern.MULTILINE);
2533         m = p.matcher(toSupplementaries(&quot;blah1\r\n&quot;));
2534         if (!m.find())
2535             failCount++;
2536         if (m.find())
2537             failCount++;
2538 
2539         // Test for $ recognition of \u0085 for bug 4527731
2540         p = Pattern.compile(&quot;.+$&quot;, Pattern.MULTILINE);
2541         m = p.matcher(toSupplementaries(&quot;blah1\u0085&quot;));
2542         if (!m.find())
2543             failCount++;
2544 
2545         report(&quot;Anchors&quot;);
2546     }
2547 
2548     /**
2549      * A basic sanity test of Matcher.lookingAt().
2550      */
2551     private static void lookingAtTest() throws Exception {
2552         Pattern p = Pattern.compile(&quot;(ab)(c*)&quot;);
2553         Matcher m = p.matcher(&quot;abccczzzabcczzzabccc&quot;);
2554 
2555         if (!m.lookingAt())
2556             failCount++;
2557 
2558         if (!m.group().equals(m.group(0)))
2559             failCount++;
2560 
2561         m = p.matcher(&quot;zzzabccczzzabcczzzabccczzz&quot;);
2562         if (m.lookingAt())
2563             failCount++;
2564 
2565         // Supplementary character test
2566         p = Pattern.compile(toSupplementaries(&quot;(ab)(c*)&quot;));
2567         m = p.matcher(toSupplementaries(&quot;abccczzzabcczzzabccc&quot;));
2568 
2569         if (!m.lookingAt())
2570             failCount++;
2571 
2572         if (!m.group().equals(m.group(0)))
2573             failCount++;
2574 
2575         m = p.matcher(toSupplementaries(&quot;zzzabccczzzabcczzzabccczzz&quot;));
2576         if (m.lookingAt())
2577             failCount++;
2578 
2579         report(&quot;Looking At&quot;);
2580     }
2581 
2582     /**
2583      * A basic sanity test of Matcher.matches().
2584      */
2585     private static void matchesTest() throws Exception {
2586         // matches()
2587         Pattern p = Pattern.compile(&quot;ulb(c*)&quot;);
2588         Matcher m = p.matcher(&quot;ulbcccccc&quot;);
2589         if (!m.matches())
2590             failCount++;
2591 
2592         // find() but not matches()
2593         m.reset(&quot;zzzulbcccccc&quot;);
2594         if (m.matches())
2595             failCount++;
2596 
2597         // lookingAt() but not matches()
2598         m.reset(&quot;ulbccccccdef&quot;);
2599         if (m.matches())
2600             failCount++;
2601 
2602         // matches()
2603         p = Pattern.compile(&quot;a|ad&quot;);
2604         m = p.matcher(&quot;ad&quot;);
2605         if (!m.matches())
2606             failCount++;
2607 
2608         // Supplementary character test
2609         // matches()
2610         p = Pattern.compile(toSupplementaries(&quot;ulb(c*)&quot;));
2611         m = p.matcher(toSupplementaries(&quot;ulbcccccc&quot;));
2612         if (!m.matches())
2613             failCount++;
2614 
2615         // find() but not matches()
2616         m.reset(toSupplementaries(&quot;zzzulbcccccc&quot;));
2617         if (m.matches())
2618             failCount++;
2619 
2620         // lookingAt() but not matches()
2621         m.reset(toSupplementaries(&quot;ulbccccccdef&quot;));
2622         if (m.matches())
2623             failCount++;
2624 
2625         // matches()
2626         p = Pattern.compile(toSupplementaries(&quot;a|ad&quot;));
2627         m = p.matcher(toSupplementaries(&quot;ad&quot;));
2628         if (!m.matches())
2629             failCount++;
2630 
2631         report(&quot;Matches&quot;);
2632     }
2633 
2634     /**
2635      * A basic sanity test of Pattern.matches().
2636      */
2637     private static void patternMatchesTest() throws Exception {
2638         // matches()
2639         if (!Pattern.matches(toSupplementaries(&quot;ulb(c*)&quot;),
2640                              toSupplementaries(&quot;ulbcccccc&quot;)))
2641             failCount++;
2642 
2643         // find() but not matches()
2644         if (Pattern.matches(toSupplementaries(&quot;ulb(c*)&quot;),
2645                             toSupplementaries(&quot;zzzulbcccccc&quot;)))
2646             failCount++;
2647 
2648         // lookingAt() but not matches()
2649         if (Pattern.matches(toSupplementaries(&quot;ulb(c*)&quot;),
2650                             toSupplementaries(&quot;ulbccccccdef&quot;)))
2651             failCount++;
2652 
2653         // Supplementary character test
2654         // matches()
2655         if (!Pattern.matches(toSupplementaries(&quot;ulb(c*)&quot;),
2656                              toSupplementaries(&quot;ulbcccccc&quot;)))
2657             failCount++;
2658 
2659         // find() but not matches()
2660         if (Pattern.matches(toSupplementaries(&quot;ulb(c*)&quot;),
2661                             toSupplementaries(&quot;zzzulbcccccc&quot;)))
2662             failCount++;
2663 
2664         // lookingAt() but not matches()
2665         if (Pattern.matches(toSupplementaries(&quot;ulb(c*)&quot;),
2666                             toSupplementaries(&quot;ulbccccccdef&quot;)))
2667             failCount++;
2668 
2669         report(&quot;Pattern Matches&quot;);
2670     }
2671 
2672     /**
2673      * Canonical equivalence testing. Tests the ability of the engine
2674      * to match sequences that are not explicitly specified in the
2675      * pattern when they are considered equivalent by the Unicode Standard.
2676      */
2677     private static void ceTest() throws Exception {
2678         // Decomposed char outside char classes
2679         Pattern p = Pattern.compile(&quot;testa\u030a&quot;, Pattern.CANON_EQ);
2680         Matcher m = p.matcher(&quot;test\u00e5&quot;);
2681         if (!m.matches())
2682             failCount++;
2683 
2684         m.reset(&quot;testa\u030a&quot;);
2685         if (!m.matches())
2686             failCount++;
2687 
2688         // Composed char outside char classes
2689         p = Pattern.compile(&quot;test\u00e5&quot;, Pattern.CANON_EQ);
2690         m = p.matcher(&quot;test\u00e5&quot;);
2691         if (!m.matches())
2692             failCount++;
2693 
2694         m.reset(&quot;testa\u030a&quot;);
2695         if (!m.find())
2696             failCount++;
2697 
2698         // Decomposed char inside a char class
2699         p = Pattern.compile(&quot;test[abca\u030a]&quot;, Pattern.CANON_EQ);
2700         m = p.matcher(&quot;test\u00e5&quot;);
2701         if (!m.find())
2702             failCount++;
2703 
2704         m.reset(&quot;testa\u030a&quot;);
2705         if (!m.find())
2706             failCount++;
2707 
2708         // Composed char inside a char class
2709         p = Pattern.compile(&quot;test[abc\u00e5def\u00e0]&quot;, Pattern.CANON_EQ);
2710         m = p.matcher(&quot;test\u00e5&quot;);
2711         if (!m.find())
2712             failCount++;
2713 
2714         m.reset(&quot;testa\u0300&quot;);
2715         if (!m.find())
2716             failCount++;
2717 
2718         m.reset(&quot;testa\u030a&quot;);
2719         if (!m.find())
2720             failCount++;
2721 
2722         // Marks that cannot legally change order and be equivalent
2723         p = Pattern.compile(&quot;testa\u0308\u0300&quot;, Pattern.CANON_EQ);
2724         check(p, &quot;testa\u0308\u0300&quot;, true);
2725         check(p, &quot;testa\u0300\u0308&quot;, false);
2726 
2727         // Marks that can legally change order and be equivalent
2728         p = Pattern.compile(&quot;testa\u0308\u0323&quot;, Pattern.CANON_EQ);
2729         check(p, &quot;testa\u0308\u0323&quot;, true);
2730         check(p, &quot;testa\u0323\u0308&quot;, true);
2731 
2732         // Test all equivalences of the sequence a\u0308\u0323\u0300
2733         p = Pattern.compile(&quot;testa\u0308\u0323\u0300&quot;, Pattern.CANON_EQ);
2734         check(p, &quot;testa\u0308\u0323\u0300&quot;, true);
2735         check(p, &quot;testa\u0323\u0308\u0300&quot;, true);
2736         check(p, &quot;testa\u0308\u0300\u0323&quot;, true);
2737         check(p, &quot;test\u00e4\u0323\u0300&quot;, true);
2738         check(p, &quot;test\u00e4\u0300\u0323&quot;, true);
2739 
2740         Object[][] data = new Object[][] {
2741 
2742         // JDK-4867170
2743         { &quot;[\u1f80-\u1f82]&quot;, &quot;ab\u1f80cd&quot;,             &quot;f&quot;, true },
2744         { &quot;[\u1f80-\u1f82]&quot;, &quot;ab\u1f81cd&quot;,             &quot;f&quot;, true },
2745         { &quot;[\u1f80-\u1f82]&quot;, &quot;ab\u1f82cd&quot;,             &quot;f&quot;, true },
2746         { &quot;[\u1f80-\u1f82]&quot;, &quot;ab\u03b1\u0314\u0345cd&quot;, &quot;f&quot;, true },
2747         { &quot;[\u1f80-\u1f82]&quot;, &quot;ab\u03b1\u0345\u0314cd&quot;, &quot;f&quot;, true },
2748         { &quot;[\u1f80-\u1f82]&quot;, &quot;ab\u1f01\u0345cd&quot;,       &quot;f&quot;, true },
2749         { &quot;[\u1f80-\u1f82]&quot;, &quot;ab\u1f00\u0345cd&quot;,       &quot;f&quot;, true },
2750 
2751         { &quot;\\p{IsGreek}&quot;,    &quot;ab\u1f80cd&quot;,             &quot;f&quot;, true },
2752         { &quot;\\p{IsGreek}&quot;,    &quot;ab\u1f81cd&quot;,             &quot;f&quot;, true },
2753         { &quot;\\p{IsGreek}&quot;,    &quot;ab\u1f82cd&quot;,             &quot;f&quot;, true },
2754         { &quot;\\p{IsGreek}&quot;,    &quot;ab\u03b1\u0314\u0345cd&quot;, &quot;f&quot;, true },
2755         { &quot;\\p{IsGreek}&quot;,    &quot;ab\u1f01\u0345cd&quot;,       &quot;f&quot;, true },
2756 
2757         // backtracking, force to match &quot;\u1f80&quot;, instead of \u1f82&quot;
2758         { &quot;ab\\p{IsGreek}\u0300cd&quot;, &quot;ab\u03b1\u0313\u0345\u0300cd&quot;, &quot;m&quot;, true },
2759 
2760         { &quot;[\\p{IsGreek}]&quot;,  &quot;\u03b1\u0314\u0345&quot;,     &quot;m&quot;, true },
2761         { &quot;\\p{IsGreek}&quot;,    &quot;\u03b1\u0314\u0345&quot;,     &quot;m&quot;, true },
2762 
2763         { &quot;[^\u1f80-\u1f82]&quot;,&quot;\u1f81&quot;,                 &quot;m&quot;, false },
2764         { &quot;[^\u1f80-\u1f82]&quot;,&quot;\u03b1\u0314\u0345&quot;,     &quot;m&quot;, false },
2765         { &quot;[^\u1f01\u0345]&quot;, &quot;\u1f81&quot;,                 &quot;f&quot;, false },
2766 
2767         { &quot;[^\u1f81]+&quot;,      &quot;\u1f80\u1f82&quot;,           &quot;f&quot;, true },
2768         { &quot;[\u1f80]&quot;,        &quot;ab\u1f80cd&quot;,             &quot;f&quot;, true },
2769         { &quot;\u1f80&quot;,          &quot;ab\u1f80cd&quot;,             &quot;f&quot;, true },
2770         { &quot;\u1f00\u0345\u0300&quot;,  &quot;\u1f82&quot;, &quot;m&quot;, true },
2771         { &quot;\u1f80&quot;,          &quot;-\u1f00\u0345\u0300-&quot;,   &quot;f&quot;, true },
2772         { &quot;\u1f82&quot;,          &quot;\u1f00\u0345\u0300&quot;,     &quot;m&quot;, true },
2773         { &quot;\u1f82&quot;,          &quot;\u1f80\u0300&quot;,           &quot;m&quot;, true },
2774 
2775         // JDK-7080302       # compile failed
2776         { &quot;a(\u0041\u0301\u0328)&quot;, &quot;a\u0041\u0301\u0328&quot;, &quot;m&quot;, true},
2777 
2778         // JDK-6728861, same cause as above one
2779         { &quot;\u00e9\u00e9n&quot;, &quot;e\u0301e\u0301n&quot;, &quot;m&quot;, true},
2780 
2781         // JDK-6995635
2782         { &quot;(\u00e9)&quot;, &quot;e\u0301&quot;, &quot;m&quot;, true },
2783 
2784         // JDK-6736245
2785         // intereting special case, nfc(u2add+u0338) -&gt; u2add+u0338) NOT u2adc
2786         { &quot;\u2ADC&quot;, &quot;\u2ADC&quot;, &quot;m&quot;, true},          // NFC
2787         { &quot;\u2ADC&quot;, &quot;\u2ADD\u0338&quot;, &quot;m&quot;, true},    // NFD
2788 
2789         //  4916384.
2790         // Decomposed hangul (jamos) works inside clazz
2791         { &quot;[\u1100\u1161]&quot;, &quot;\u1100\u1161&quot;, &quot;m&quot;, true},
2792         { &quot;[\u1100\u1161]&quot;, &quot;\uac00&quot;, &quot;m&quot;, true},
2793 
2794         { &quot;[\uac00]&quot;, &quot;\u1100\u1161&quot;, &quot;m&quot;, true},
2795         { &quot;[\uac00]&quot;, &quot;\uac00&quot;, &quot;m&quot;, true},
2796 
2797         // Decomposed hangul (jamos)
2798         { &quot;\u1100\u1161&quot;, &quot;\u1100\u1161&quot;, &quot;m&quot;, true},
2799         { &quot;\u1100\u1161&quot;, &quot;\uac00&quot;, &quot;m&quot;, true},
2800 
2801         // Composed hangul
2802         { &quot;\uac00&quot;,  &quot;\u1100\u1161&quot;, &quot;m&quot;, true },
2803         { &quot;\uac00&quot;,  &quot;\uac00&quot;, &quot;m&quot;, true },
2804 
2805         /* Need a NFDSlice to nfd the source to solve this issue
2806            u+1d1c0 -&gt; nfd: &lt;u+1d1ba&gt;&lt;u+1d165&gt;&lt;u+1d16f&gt;  -&gt; nfc: &lt;u+1d1ba&gt;&lt;u+1d165&gt;&lt;u+1d16f&gt;
2807            u+1d1bc -&gt; nfd: &lt;u+1d1ba&gt;&lt;u+1d165&gt;           -&gt; nfc: &lt;u+1d1ba&gt;&lt;u+1d165&gt;
2808            &lt;u+1d1bc&gt;&lt;u+1d16f&gt; -&gt; nfd: &lt;u+1d1ba&gt;&lt;u+1d165&gt;&lt;u+1d16f&gt; -&gt; nfc: &lt;u+1d1ba&gt;&lt;u+1d165&gt;&lt;u+1d16f&gt;
2809 
2810         // Decomposed supplementary outside char classes
2811         // { &quot;test\ud834\uddbc\ud834\udd6f&quot;, &quot;test\ud834\uddc0&quot;, &quot;m&quot;, true },
2812         // Composed supplementary outside char classes
2813         // { &quot;test\ud834\uddc0&quot;, &quot;test\ud834\uddbc\ud834\udd6f&quot;, &quot;m&quot;, true },
2814         */
2815         { &quot;test\ud834\uddbc\ud834\udd6f&quot;, &quot;test\ud834\uddbc\ud834\udd6f&quot;, &quot;m&quot;, true },
2816         { &quot;test\ud834\uddc0&quot;,             &quot;test\ud834\uddbc\ud834\udd6f&quot;, &quot;m&quot;, true },
2817 
2818         { &quot;test\ud834\uddc0&quot;,             &quot;test\ud834\uddc0&quot;,             &quot;m&quot;, true },
2819         { &quot;test\ud834\uddbc\ud834\udd6f&quot;, &quot;test\ud834\uddc0&quot;,             &quot;m&quot;, true },
2820         };
2821 
2822         int failCount = 0;
2823         for (Object[] d : data) {
2824             String pn = (String)d[0];
2825             String tt = (String)d[1];
2826             boolean isFind = &quot;f&quot;.equals(((String)d[2]));
2827             boolean expected = (boolean)d[3];
2828             boolean ret = isFind ? Pattern.compile(pn, Pattern.CANON_EQ).matcher(tt).find()
2829                                  : Pattern.compile(pn, Pattern.CANON_EQ).matcher(tt).matches();
2830             if (ret != expected) {
2831                 failCount++;
2832                 continue;
2833             }
2834         }
2835         report(&quot;Canonical Equivalence&quot;);
2836     }
2837 
2838     /**
2839      * A basic sanity test of Matcher.replaceAll().
2840      */
2841     private static void globalSubstitute() throws Exception {
2842         // Global substitution with a literal
2843         Pattern p = Pattern.compile(&quot;(ab)(c*)&quot;);
2844         Matcher m = p.matcher(&quot;abccczzzabcczzzabccc&quot;);
2845         if (!m.replaceAll(&quot;test&quot;).equals(&quot;testzzztestzzztest&quot;))
2846             failCount++;
2847 
2848         m.reset(&quot;zzzabccczzzabcczzzabccczzz&quot;);
2849         if (!m.replaceAll(&quot;test&quot;).equals(&quot;zzztestzzztestzzztestzzz&quot;))
2850             failCount++;
2851 
2852         // Global substitution with groups
2853         m.reset(&quot;zzzabccczzzabcczzzabccczzz&quot;);
2854         String result = m.replaceAll(&quot;$1&quot;);
2855         if (!result.equals(&quot;zzzabzzzabzzzabzzz&quot;))
2856             failCount++;
2857 
2858         // Supplementary character test
2859         // Global substitution with a literal
2860         p = Pattern.compile(toSupplementaries(&quot;(ab)(c*)&quot;));
2861         m = p.matcher(toSupplementaries(&quot;abccczzzabcczzzabccc&quot;));
2862         if (!m.replaceAll(toSupplementaries(&quot;test&quot;)).
2863             equals(toSupplementaries(&quot;testzzztestzzztest&quot;)))
2864             failCount++;
2865 
2866         m.reset(toSupplementaries(&quot;zzzabccczzzabcczzzabccczzz&quot;));
2867         if (!m.replaceAll(toSupplementaries(&quot;test&quot;)).
2868             equals(toSupplementaries(&quot;zzztestzzztestzzztestzzz&quot;)))
2869             failCount++;
2870 
2871         // Global substitution with groups
2872         m.reset(toSupplementaries(&quot;zzzabccczzzabcczzzabccczzz&quot;));
2873         result = m.replaceAll(&quot;$1&quot;);
2874         if (!result.equals(toSupplementaries(&quot;zzzabzzzabzzzabzzz&quot;)))
2875             failCount++;
2876 
2877         report(&quot;Global Substitution&quot;);
2878     }
2879 
2880     /**
2881      * Tests the usage of Matcher.appendReplacement() with literal
2882      * and group substitutions.
2883      */
2884     private static void stringbufferSubstitute() throws Exception {
2885         // SB substitution with literal
2886         String blah = &quot;zzzblahzzz&quot;;
2887         Pattern p = Pattern.compile(&quot;blah&quot;);
2888         Matcher m = p.matcher(blah);
2889         StringBuffer result = new StringBuffer();
2890         try {
2891             m.appendReplacement(result, &quot;blech&quot;);
2892             failCount++;
2893         } catch (IllegalStateException e) {
2894         }
2895         m.find();
2896         m.appendReplacement(result, &quot;blech&quot;);
2897         if (!result.toString().equals(&quot;zzzblech&quot;))
2898             failCount++;
2899 
2900         m.appendTail(result);
2901         if (!result.toString().equals(&quot;zzzblechzzz&quot;))
2902             failCount++;
2903 
2904         // SB substitution with groups
2905         blah = &quot;zzzabcdzzz&quot;;
2906         p = Pattern.compile(&quot;(ab)(cd)*&quot;);
2907         m = p.matcher(blah);
2908         result = new StringBuffer();
2909         try {
2910             m.appendReplacement(result, &quot;$1&quot;);
2911             failCount++;
2912         } catch (IllegalStateException e) {
2913         }
2914         m.find();
2915         m.appendReplacement(result, &quot;$1&quot;);
2916         if (!result.toString().equals(&quot;zzzab&quot;))
2917             failCount++;
2918 
2919         m.appendTail(result);
2920         if (!result.toString().equals(&quot;zzzabzzz&quot;))
2921             failCount++;
2922 
2923         // SB substitution with 3 groups
2924         blah = &quot;zzzabcdcdefzzz&quot;;
2925         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
2926         m = p.matcher(blah);
2927         result = new StringBuffer();
2928         try {
2929             m.appendReplacement(result, &quot;$1w$2w$3&quot;);
2930             failCount++;
2931         } catch (IllegalStateException e) {
2932         }
2933         m.find();
2934         m.appendReplacement(result, &quot;$1w$2w$3&quot;);
2935         if (!result.toString().equals(&quot;zzzabwcdwef&quot;))
2936             failCount++;
2937 
2938         m.appendTail(result);
2939         if (!result.toString().equals(&quot;zzzabwcdwefzzz&quot;))
2940             failCount++;
2941 
2942         // SB substitution with groups and three matches
2943         // skipping middle match
2944         blah = &quot;zzzabcdzzzabcddzzzabcdzzz&quot;;
2945         p = Pattern.compile(&quot;(ab)(cd*)&quot;);
2946         m = p.matcher(blah);
2947         result = new StringBuffer();
2948         try {
2949             m.appendReplacement(result, &quot;$1&quot;);
2950             failCount++;
2951         } catch (IllegalStateException e) {
2952         }
2953         m.find();
2954         m.appendReplacement(result, &quot;$1&quot;);
2955         if (!result.toString().equals(&quot;zzzab&quot;))
2956             failCount++;
2957 
2958         m.find();
2959         m.find();
2960         m.appendReplacement(result, &quot;$2&quot;);
2961         if (!result.toString().equals(&quot;zzzabzzzabcddzzzcd&quot;))
2962             failCount++;
2963 
2964         m.appendTail(result);
2965         if (!result.toString().equals(&quot;zzzabzzzabcddzzzcdzzz&quot;))
2966             failCount++;
2967 
2968         // Check to make sure escaped $ is ignored
2969         blah = &quot;zzzabcdcdefzzz&quot;;
2970         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
2971         m = p.matcher(blah);
2972         result = new StringBuffer();
2973         m.find();
2974         m.appendReplacement(result, &quot;$1w\\$2w$3&quot;);
2975         if (!result.toString().equals(&quot;zzzabw$2wef&quot;))
2976             failCount++;
2977 
2978         m.appendTail(result);
2979         if (!result.toString().equals(&quot;zzzabw$2wefzzz&quot;))
2980             failCount++;
2981 
2982         // Check to make sure a reference to nonexistent group causes error
2983         blah = &quot;zzzabcdcdefzzz&quot;;
2984         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
2985         m = p.matcher(blah);
2986         result = new StringBuffer();
2987         m.find();
2988         try {
2989             m.appendReplacement(result, &quot;$1w$5w$3&quot;);
2990             failCount++;
2991         } catch (IndexOutOfBoundsException ioobe) {
2992             // Correct result
2993         }
2994 
2995         // Check double digit group references
2996         blah = &quot;zzz123456789101112zzz&quot;;
2997         p = Pattern.compile(&quot;(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)&quot;);
2998         m = p.matcher(blah);
2999         result = new StringBuffer();
3000         m.find();
3001         m.appendReplacement(result, &quot;$1w$11w$3&quot;);
3002         if (!result.toString().equals(&quot;zzz1w11w3&quot;))
3003             failCount++;
3004 
3005         // Check to make sure it backs off $15 to $1 if only three groups
3006         blah = &quot;zzzabcdcdefzzz&quot;;
3007         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
3008         m = p.matcher(blah);
3009         result = new StringBuffer();
3010         m.find();
3011         m.appendReplacement(result, &quot;$1w$15w$3&quot;);
3012         if (!result.toString().equals(&quot;zzzabwab5wef&quot;))
3013             failCount++;
3014 
3015 
3016         // Supplementary character test
3017         // SB substitution with literal
3018         blah = toSupplementaries(&quot;zzzblahzzz&quot;);
3019         p = Pattern.compile(toSupplementaries(&quot;blah&quot;));
3020         m = p.matcher(blah);
3021         result = new StringBuffer();
3022         try {
3023             m.appendReplacement(result, toSupplementaries(&quot;blech&quot;));
3024             failCount++;
3025         } catch (IllegalStateException e) {
3026         }
3027         m.find();
3028         m.appendReplacement(result, toSupplementaries(&quot;blech&quot;));
3029         if (!result.toString().equals(toSupplementaries(&quot;zzzblech&quot;)))
3030             failCount++;
3031 
3032         m.appendTail(result);
3033         if (!result.toString().equals(toSupplementaries(&quot;zzzblechzzz&quot;)))
3034             failCount++;
3035 
3036         // SB substitution with groups
3037         blah = toSupplementaries(&quot;zzzabcdzzz&quot;);
3038         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*&quot;));
3039         m = p.matcher(blah);
3040         result = new StringBuffer();
3041         try {
3042             m.appendReplacement(result, &quot;$1&quot;);
3043             failCount++;
3044         } catch (IllegalStateException e) {
3045         }
3046         m.find();
3047         m.appendReplacement(result, &quot;$1&quot;);
3048         if (!result.toString().equals(toSupplementaries(&quot;zzzab&quot;)))
3049             failCount++;
3050 
3051         m.appendTail(result);
3052         if (!result.toString().equals(toSupplementaries(&quot;zzzabzzz&quot;)))
3053             failCount++;
3054 
3055         // SB substitution with 3 groups
3056         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3057         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3058         m = p.matcher(blah);
3059         result = new StringBuffer();
3060         try {
3061             m.appendReplacement(result, toSupplementaries(&quot;$1w$2w$3&quot;));
3062             failCount++;
3063         } catch (IllegalStateException e) {
3064         }
3065         m.find();
3066         m.appendReplacement(result, toSupplementaries(&quot;$1w$2w$3&quot;));
3067         if (!result.toString().equals(toSupplementaries(&quot;zzzabwcdwef&quot;)))
3068             failCount++;
3069 
3070         m.appendTail(result);
3071         if (!result.toString().equals(toSupplementaries(&quot;zzzabwcdwefzzz&quot;)))
3072             failCount++;
3073 
3074         // SB substitution with groups and three matches
3075         // skipping middle match
3076         blah = toSupplementaries(&quot;zzzabcdzzzabcddzzzabcdzzz&quot;);
3077         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd*)&quot;));
3078         m = p.matcher(blah);
3079         result = new StringBuffer();
3080         try {
3081             m.appendReplacement(result, &quot;$1&quot;);
3082             failCount++;
3083         } catch (IllegalStateException e) {
3084         }
3085         m.find();
3086         m.appendReplacement(result, &quot;$1&quot;);
3087         if (!result.toString().equals(toSupplementaries(&quot;zzzab&quot;)))
3088             failCount++;
3089 
3090         m.find();
3091         m.find();
3092         m.appendReplacement(result, &quot;$2&quot;);
3093         if (!result.toString().equals(toSupplementaries(&quot;zzzabzzzabcddzzzcd&quot;)))
3094             failCount++;
3095 
3096         m.appendTail(result);
3097         if (!result.toString().equals(toSupplementaries(&quot;zzzabzzzabcddzzzcdzzz&quot;)))
3098             failCount++;
3099 
3100         // Check to make sure escaped $ is ignored
3101         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3102         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3103         m = p.matcher(blah);
3104         result = new StringBuffer();
3105         m.find();
3106         m.appendReplacement(result, toSupplementaries(&quot;$1w\\$2w$3&quot;));
3107         if (!result.toString().equals(toSupplementaries(&quot;zzzabw$2wef&quot;)))
3108             failCount++;
3109 
3110         m.appendTail(result);
3111         if (!result.toString().equals(toSupplementaries(&quot;zzzabw$2wefzzz&quot;)))
3112             failCount++;
3113 
3114         // Check to make sure a reference to nonexistent group causes error
3115         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3116         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3117         m = p.matcher(blah);
3118         result = new StringBuffer();
3119         m.find();
3120         try {
3121             m.appendReplacement(result, toSupplementaries(&quot;$1w$5w$3&quot;));
3122             failCount++;
3123         } catch (IndexOutOfBoundsException ioobe) {
3124             // Correct result
3125         }
3126 
3127         // Check double digit group references
3128         blah = toSupplementaries(&quot;zzz123456789101112zzz&quot;);
3129         p = Pattern.compile(&quot;(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)&quot;);
3130         m = p.matcher(blah);
3131         result = new StringBuffer();
3132         m.find();
3133         m.appendReplacement(result, toSupplementaries(&quot;$1w$11w$3&quot;));
3134         if (!result.toString().equals(toSupplementaries(&quot;zzz1w11w3&quot;)))
3135             failCount++;
3136 
3137         // Check to make sure it backs off $15 to $1 if only three groups
3138         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3139         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3140         m = p.matcher(blah);
3141         result = new StringBuffer();
3142         m.find();
3143         m.appendReplacement(result, toSupplementaries(&quot;$1w$15w$3&quot;));
3144         if (!result.toString().equals(toSupplementaries(&quot;zzzabwab5wef&quot;)))
3145             failCount++;
3146 
3147         // Check nothing has been appended into the output buffer if
3148         // the replacement string triggers IllegalArgumentException.
3149         p = Pattern.compile(&quot;(abc)&quot;);
3150         m = p.matcher(&quot;abcd&quot;);
3151         result = new StringBuffer();
3152         m.find();
3153         try {
3154             m.appendReplacement(result, (&quot;xyz$g&quot;));
3155             failCount++;
3156         } catch (IllegalArgumentException iae) {
3157             if (result.length() != 0)
3158                 failCount++;
3159         }
3160 
3161         report(&quot;SB Substitution&quot;);
3162     }
3163 
3164     /**
3165      * Tests the usage of Matcher.appendReplacement() with literal
3166      * and group substitutions.
3167      */
3168     private static void stringbuilderSubstitute() throws Exception {
3169         // SB substitution with literal
3170         String blah = &quot;zzzblahzzz&quot;;
3171         Pattern p = Pattern.compile(&quot;blah&quot;);
3172         Matcher m = p.matcher(blah);
3173         StringBuilder result = new StringBuilder();
3174         try {
3175             m.appendReplacement(result, &quot;blech&quot;);
3176             failCount++;
3177         } catch (IllegalStateException e) {
3178         }
3179         m.find();
3180         m.appendReplacement(result, &quot;blech&quot;);
3181         if (!result.toString().equals(&quot;zzzblech&quot;))
3182             failCount++;
3183 
3184         m.appendTail(result);
3185         if (!result.toString().equals(&quot;zzzblechzzz&quot;))
3186             failCount++;
3187 
3188         // SB substitution with groups
3189         blah = &quot;zzzabcdzzz&quot;;
3190         p = Pattern.compile(&quot;(ab)(cd)*&quot;);
3191         m = p.matcher(blah);
3192         result = new StringBuilder();
3193         try {
3194             m.appendReplacement(result, &quot;$1&quot;);
3195             failCount++;
3196         } catch (IllegalStateException e) {
3197         }
3198         m.find();
3199         m.appendReplacement(result, &quot;$1&quot;);
3200         if (!result.toString().equals(&quot;zzzab&quot;))
3201             failCount++;
3202 
3203         m.appendTail(result);
3204         if (!result.toString().equals(&quot;zzzabzzz&quot;))
3205             failCount++;
3206 
3207         // SB substitution with 3 groups
3208         blah = &quot;zzzabcdcdefzzz&quot;;
3209         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
3210         m = p.matcher(blah);
3211         result = new StringBuilder();
3212         try {
3213             m.appendReplacement(result, &quot;$1w$2w$3&quot;);
3214             failCount++;
3215         } catch (IllegalStateException e) {
3216         }
3217         m.find();
3218         m.appendReplacement(result, &quot;$1w$2w$3&quot;);
3219         if (!result.toString().equals(&quot;zzzabwcdwef&quot;))
3220             failCount++;
3221 
3222         m.appendTail(result);
3223         if (!result.toString().equals(&quot;zzzabwcdwefzzz&quot;))
3224             failCount++;
3225 
3226         // SB substitution with groups and three matches
3227         // skipping middle match
3228         blah = &quot;zzzabcdzzzabcddzzzabcdzzz&quot;;
3229         p = Pattern.compile(&quot;(ab)(cd*)&quot;);
3230         m = p.matcher(blah);
3231         result = new StringBuilder();
3232         try {
3233             m.appendReplacement(result, &quot;$1&quot;);
3234             failCount++;
3235         } catch (IllegalStateException e) {
3236         }
3237         m.find();
3238         m.appendReplacement(result, &quot;$1&quot;);
3239         if (!result.toString().equals(&quot;zzzab&quot;))
3240             failCount++;
3241 
3242         m.find();
3243         m.find();
3244         m.appendReplacement(result, &quot;$2&quot;);
3245         if (!result.toString().equals(&quot;zzzabzzzabcddzzzcd&quot;))
3246             failCount++;
3247 
3248         m.appendTail(result);
3249         if (!result.toString().equals(&quot;zzzabzzzabcddzzzcdzzz&quot;))
3250             failCount++;
3251 
3252         // Check to make sure escaped $ is ignored
3253         blah = &quot;zzzabcdcdefzzz&quot;;
3254         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
3255         m = p.matcher(blah);
3256         result = new StringBuilder();
3257         m.find();
3258         m.appendReplacement(result, &quot;$1w\\$2w$3&quot;);
3259         if (!result.toString().equals(&quot;zzzabw$2wef&quot;))
3260             failCount++;
3261 
3262         m.appendTail(result);
3263         if (!result.toString().equals(&quot;zzzabw$2wefzzz&quot;))
3264             failCount++;
3265 
3266         // Check to make sure a reference to nonexistent group causes error
3267         blah = &quot;zzzabcdcdefzzz&quot;;
3268         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
3269         m = p.matcher(blah);
3270         result = new StringBuilder();
3271         m.find();
3272         try {
3273             m.appendReplacement(result, &quot;$1w$5w$3&quot;);
3274             failCount++;
3275         } catch (IndexOutOfBoundsException ioobe) {
3276             // Correct result
3277         }
3278 
3279         // Check double digit group references
3280         blah = &quot;zzz123456789101112zzz&quot;;
3281         p = Pattern.compile(&quot;(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)&quot;);
3282         m = p.matcher(blah);
3283         result = new StringBuilder();
3284         m.find();
3285         m.appendReplacement(result, &quot;$1w$11w$3&quot;);
3286         if (!result.toString().equals(&quot;zzz1w11w3&quot;))
3287             failCount++;
3288 
3289         // Check to make sure it backs off $15 to $1 if only three groups
3290         blah = &quot;zzzabcdcdefzzz&quot;;
3291         p = Pattern.compile(&quot;(ab)(cd)*(ef)&quot;);
3292         m = p.matcher(blah);
3293         result = new StringBuilder();
3294         m.find();
3295         m.appendReplacement(result, &quot;$1w$15w$3&quot;);
3296         if (!result.toString().equals(&quot;zzzabwab5wef&quot;))
3297             failCount++;
3298 
3299 
3300         // Supplementary character test
3301         // SB substitution with literal
3302         blah = toSupplementaries(&quot;zzzblahzzz&quot;);
3303         p = Pattern.compile(toSupplementaries(&quot;blah&quot;));
3304         m = p.matcher(blah);
3305         result = new StringBuilder();
3306         try {
3307             m.appendReplacement(result, toSupplementaries(&quot;blech&quot;));
3308             failCount++;
3309         } catch (IllegalStateException e) {
3310         }
3311         m.find();
3312         m.appendReplacement(result, toSupplementaries(&quot;blech&quot;));
3313         if (!result.toString().equals(toSupplementaries(&quot;zzzblech&quot;)))
3314             failCount++;
3315         m.appendTail(result);
3316         if (!result.toString().equals(toSupplementaries(&quot;zzzblechzzz&quot;)))
3317             failCount++;
3318 
3319         // SB substitution with groups
3320         blah = toSupplementaries(&quot;zzzabcdzzz&quot;);
3321         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*&quot;));
3322         m = p.matcher(blah);
3323         result = new StringBuilder();
3324         try {
3325             m.appendReplacement(result, &quot;$1&quot;);
3326             failCount++;
3327         } catch (IllegalStateException e) {
3328         }
3329         m.find();
3330         m.appendReplacement(result, &quot;$1&quot;);
3331         if (!result.toString().equals(toSupplementaries(&quot;zzzab&quot;)))
3332             failCount++;
3333 
3334         m.appendTail(result);
3335         if (!result.toString().equals(toSupplementaries(&quot;zzzabzzz&quot;)))
3336             failCount++;
3337 
3338         // SB substitution with 3 groups
3339         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3340         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3341         m = p.matcher(blah);
3342         result = new StringBuilder();
3343         try {
3344             m.appendReplacement(result, toSupplementaries(&quot;$1w$2w$3&quot;));
3345             failCount++;
3346         } catch (IllegalStateException e) {
3347         }
3348         m.find();
3349         m.appendReplacement(result, toSupplementaries(&quot;$1w$2w$3&quot;));
3350         if (!result.toString().equals(toSupplementaries(&quot;zzzabwcdwef&quot;)))
3351             failCount++;
3352 
3353         m.appendTail(result);
3354         if (!result.toString().equals(toSupplementaries(&quot;zzzabwcdwefzzz&quot;)))
3355             failCount++;
3356 
3357         // SB substitution with groups and three matches
3358         // skipping middle match
3359         blah = toSupplementaries(&quot;zzzabcdzzzabcddzzzabcdzzz&quot;);
3360         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd*)&quot;));
3361         m = p.matcher(blah);
3362         result = new StringBuilder();
3363         try {
3364             m.appendReplacement(result, &quot;$1&quot;);
3365             failCount++;
3366         } catch (IllegalStateException e) {
3367         }
3368         m.find();
3369         m.appendReplacement(result, &quot;$1&quot;);
3370         if (!result.toString().equals(toSupplementaries(&quot;zzzab&quot;)))
3371             failCount++;
3372 
3373         m.find();
3374         m.find();
3375         m.appendReplacement(result, &quot;$2&quot;);
3376         if (!result.toString().equals(toSupplementaries(&quot;zzzabzzzabcddzzzcd&quot;)))
3377             failCount++;
3378 
3379         m.appendTail(result);
3380         if (!result.toString().equals(toSupplementaries(&quot;zzzabzzzabcddzzzcdzzz&quot;)))
3381             failCount++;
3382 
3383         // Check to make sure escaped $ is ignored
3384         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3385         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3386         m = p.matcher(blah);
3387         result = new StringBuilder();
3388         m.find();
3389         m.appendReplacement(result, toSupplementaries(&quot;$1w\\$2w$3&quot;));
3390         if (!result.toString().equals(toSupplementaries(&quot;zzzabw$2wef&quot;)))
3391             failCount++;
3392 
3393         m.appendTail(result);
3394         if (!result.toString().equals(toSupplementaries(&quot;zzzabw$2wefzzz&quot;)))
3395             failCount++;
3396 
3397         // Check to make sure a reference to nonexistent group causes error
3398         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3399         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3400         m = p.matcher(blah);
3401         result = new StringBuilder();
3402         m.find();
3403         try {
3404             m.appendReplacement(result, toSupplementaries(&quot;$1w$5w$3&quot;));
3405             failCount++;
3406         } catch (IndexOutOfBoundsException ioobe) {
3407             // Correct result
3408         }
3409         // Check double digit group references
3410         blah = toSupplementaries(&quot;zzz123456789101112zzz&quot;);
3411         p = Pattern.compile(&quot;(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)&quot;);
3412         m = p.matcher(blah);
3413         result = new StringBuilder();
3414         m.find();
3415         m.appendReplacement(result, toSupplementaries(&quot;$1w$11w$3&quot;));
3416         if (!result.toString().equals(toSupplementaries(&quot;zzz1w11w3&quot;)))
3417             failCount++;
3418 
3419         // Check to make sure it backs off $15 to $1 if only three groups
3420         blah = toSupplementaries(&quot;zzzabcdcdefzzz&quot;);
3421         p = Pattern.compile(toSupplementaries(&quot;(ab)(cd)*(ef)&quot;));
3422         m = p.matcher(blah);
3423         result = new StringBuilder();
3424         m.find();
3425         m.appendReplacement(result, toSupplementaries(&quot;$1w$15w$3&quot;));
3426         if (!result.toString().equals(toSupplementaries(&quot;zzzabwab5wef&quot;)))
3427             failCount++;
3428         // Check nothing has been appended into the output buffer if
3429         // the replacement string triggers IllegalArgumentException.
3430         p = Pattern.compile(&quot;(abc)&quot;);
3431         m = p.matcher(&quot;abcd&quot;);
3432         result = new StringBuilder();
3433         m.find();
3434         try {
3435             m.appendReplacement(result, (&quot;xyz$g&quot;));
3436             failCount++;
3437         } catch (IllegalArgumentException iae) {
3438             if (result.length() != 0)
3439                 failCount++;
3440         }
3441         report(&quot;SB Substitution 2&quot;);
3442     }
3443 
3444     /*
3445      * 5 groups of characters are created to make a substitution string.
3446      * A base string will be created including random lead chars, the
3447      * substitution string, and random trailing chars.
3448      * A pattern containing the 5 groups is searched for and replaced with:
3449      * random group + random string + random group.
3450      * The results are checked for correctness.
3451      */
3452     private static void substitutionBasher() {
3453         for (int runs = 0; runs&lt;1000; runs++) {
3454             // Create a base string to work in
3455             int leadingChars = generator.nextInt(10);
3456             StringBuffer baseBuffer = new StringBuffer(100);
3457             String leadingString = getRandomAlphaString(leadingChars);
3458             baseBuffer.append(leadingString);
3459 
3460             // Create 5 groups of random number of random chars
3461             // Create the string to substitute
3462             // Create the pattern string to search for
3463             StringBuffer bufferToSub = new StringBuffer(25);
3464             StringBuffer bufferToPat = new StringBuffer(50);
3465             String[] groups = new String[5];
3466             for(int i=0; i&lt;5; i++) {
3467                 int aGroupSize = generator.nextInt(5)+1;
3468                 groups[i] = getRandomAlphaString(aGroupSize);
3469                 bufferToSub.append(groups[i]);
3470                 bufferToPat.append(&#39;(&#39;);
3471                 bufferToPat.append(groups[i]);
3472                 bufferToPat.append(&#39;)&#39;);
3473             }
3474             String stringToSub = bufferToSub.toString();
3475             String pattern = bufferToPat.toString();
3476 
3477             // Place sub string into working string at random index
3478             baseBuffer.append(stringToSub);
3479 
3480             // Append random chars to end
3481             int trailingChars = generator.nextInt(10);
3482             String trailingString = getRandomAlphaString(trailingChars);
3483             baseBuffer.append(trailingString);
3484             String baseString = baseBuffer.toString();
3485 
3486             // Create test pattern and matcher
3487             Pattern p = Pattern.compile(pattern);
3488             Matcher m = p.matcher(baseString);
3489 
3490             // Reject candidate if pattern happens to start early
3491             m.find();
3492             if (m.start() &lt; leadingChars)
3493                 continue;
3494 
3495             // Reject candidate if more than one match
3496             if (m.find())
3497                 continue;
3498 
3499             // Construct a replacement string with :
3500             // random group + random string + random group
3501             StringBuffer bufferToRep = new StringBuffer();
3502             int groupIndex1 = generator.nextInt(5);
3503             bufferToRep.append(&quot;$&quot; + (groupIndex1 + 1));
3504             String randomMidString = getRandomAlphaString(5);
3505             bufferToRep.append(randomMidString);
3506             int groupIndex2 = generator.nextInt(5);
3507             bufferToRep.append(&quot;$&quot; + (groupIndex2 + 1));
3508             String replacement = bufferToRep.toString();
3509 
3510             // Do the replacement
3511             String result = m.replaceAll(replacement);
3512 
3513             // Construct expected result
3514             StringBuffer bufferToRes = new StringBuffer();
3515             bufferToRes.append(leadingString);
3516             bufferToRes.append(groups[groupIndex1]);
3517             bufferToRes.append(randomMidString);
3518             bufferToRes.append(groups[groupIndex2]);
3519             bufferToRes.append(trailingString);
3520             String expectedResult = bufferToRes.toString();
3521 
3522             // Check results
3523             if (!result.equals(expectedResult))
3524                 failCount++;
3525         }
3526 
3527         report(&quot;Substitution Basher&quot;);
3528     }
3529 
3530     /*
3531      * 5 groups of characters are created to make a substitution string.
3532      * A base string will be created including random lead chars, the
3533      * substitution string, and random trailing chars.
3534      * A pattern containing the 5 groups is searched for and replaced with:
3535      * random group + random string + random group.
3536      * The results are checked for correctness.
3537      */
3538     private static void substitutionBasher2() {
3539         for (int runs = 0; runs&lt;1000; runs++) {
3540             // Create a base string to work in
3541             int leadingChars = generator.nextInt(10);
3542             StringBuilder baseBuffer = new StringBuilder(100);
3543             String leadingString = getRandomAlphaString(leadingChars);
3544             baseBuffer.append(leadingString);
3545 
3546             // Create 5 groups of random number of random chars
3547             // Create the string to substitute
3548             // Create the pattern string to search for
3549             StringBuilder bufferToSub = new StringBuilder(25);
3550             StringBuilder bufferToPat = new StringBuilder(50);
3551             String[] groups = new String[5];
3552             for(int i=0; i&lt;5; i++) {
3553                 int aGroupSize = generator.nextInt(5)+1;
3554                 groups[i] = getRandomAlphaString(aGroupSize);
3555                 bufferToSub.append(groups[i]);
3556                 bufferToPat.append(&#39;(&#39;);
3557                 bufferToPat.append(groups[i]);
3558                 bufferToPat.append(&#39;)&#39;);
3559             }
3560             String stringToSub = bufferToSub.toString();
3561             String pattern = bufferToPat.toString();
3562 
3563             // Place sub string into working string at random index
3564             baseBuffer.append(stringToSub);
3565 
3566             // Append random chars to end
3567             int trailingChars = generator.nextInt(10);
3568             String trailingString = getRandomAlphaString(trailingChars);
3569             baseBuffer.append(trailingString);
3570             String baseString = baseBuffer.toString();
3571 
3572             // Create test pattern and matcher
3573             Pattern p = Pattern.compile(pattern);
3574             Matcher m = p.matcher(baseString);
3575 
3576             // Reject candidate if pattern happens to start early
3577             m.find();
3578             if (m.start() &lt; leadingChars)
3579                 continue;
3580 
3581             // Reject candidate if more than one match
3582             if (m.find())
3583                 continue;
3584 
3585             // Construct a replacement string with :
3586             // random group + random string + random group
3587             StringBuilder bufferToRep = new StringBuilder();
3588             int groupIndex1 = generator.nextInt(5);
3589             bufferToRep.append(&quot;$&quot; + (groupIndex1 + 1));
3590             String randomMidString = getRandomAlphaString(5);
3591             bufferToRep.append(randomMidString);
3592             int groupIndex2 = generator.nextInt(5);
3593             bufferToRep.append(&quot;$&quot; + (groupIndex2 + 1));
3594             String replacement = bufferToRep.toString();
3595 
3596             // Do the replacement
3597             String result = m.replaceAll(replacement);
3598 
3599             // Construct expected result
3600             StringBuilder bufferToRes = new StringBuilder();
3601             bufferToRes.append(leadingString);
3602             bufferToRes.append(groups[groupIndex1]);
3603             bufferToRes.append(randomMidString);
3604             bufferToRes.append(groups[groupIndex2]);
3605             bufferToRes.append(trailingString);
3606             String expectedResult = bufferToRes.toString();
3607 
3608             // Check results
3609             if (!result.equals(expectedResult)) {
3610                 failCount++;
3611             }
3612         }
3613 
3614         report(&quot;Substitution Basher 2&quot;);
3615     }
3616 
3617     /**
3618      * Checks the handling of some escape sequences that the Pattern
3619      * class should process instead of the java compiler. These are
3620      * not in the file because the escapes should be be processed
3621      * by the Pattern class when the regex is compiled.
3622      */
3623     private static void escapes() throws Exception {
3624         Pattern p = Pattern.compile(&quot;\\043&quot;);
3625         Matcher m = p.matcher(&quot;#&quot;);
3626         if (!m.find())
3627             failCount++;
3628 
3629         p = Pattern.compile(&quot;\\x23&quot;);
3630         m = p.matcher(&quot;#&quot;);
3631         if (!m.find())
3632             failCount++;
3633 
3634         p = Pattern.compile(&quot;\\u0023&quot;);
3635         m = p.matcher(&quot;#&quot;);
3636         if (!m.find())
3637             failCount++;
3638 
3639         report(&quot;Escape sequences&quot;);
3640     }
3641 
3642     /**
3643      * Checks the handling of blank input situations. These
3644      * tests are incompatible with my test file format.
3645      */
3646     private static void blankInput() throws Exception {
3647         Pattern p = Pattern.compile(&quot;abc&quot;, Pattern.CASE_INSENSITIVE);
3648         Matcher m = p.matcher(&quot;&quot;);
3649         if (m.find())
3650             failCount++;
3651 
3652         p = Pattern.compile(&quot;a*&quot;, Pattern.CASE_INSENSITIVE);
3653         m = p.matcher(&quot;&quot;);
3654         if (!m.find())
3655             failCount++;
3656 
3657         p = Pattern.compile(&quot;abc&quot;);
3658         m = p.matcher(&quot;&quot;);
3659         if (m.find())
3660             failCount++;
3661 
3662         p = Pattern.compile(&quot;a*&quot;);
3663         m = p.matcher(&quot;&quot;);
3664         if (!m.find())
3665             failCount++;
3666 
3667         report(&quot;Blank input&quot;);
3668     }
3669 
3670     /**
3671      * Tests the Boyer-Moore pattern matching of a character sequence
3672      * on randomly generated patterns.
3673      */
3674     private static void bm() throws Exception {
3675         doBnM(&#39;a&#39;);
3676         report(&quot;Boyer Moore (ASCII)&quot;);
3677 
3678         doBnM(Character.MIN_SUPPLEMENTARY_CODE_POINT - 10);
3679         report(&quot;Boyer Moore (Supplementary)&quot;);
3680     }
3681 
3682     private static void doBnM(int baseCharacter) throws Exception {
3683         int achar=0;
3684 
3685         for (int i=0; i&lt;100; i++) {
3686             // Create a short pattern to search for
3687             int patternLength = generator.nextInt(7) + 4;
3688             StringBuffer patternBuffer = new StringBuffer(patternLength);
3689             String pattern;
3690             retry: for (;;) {
3691                 for (int x=0; x&lt;patternLength; x++) {
3692                     int ch = baseCharacter + generator.nextInt(26);
3693                     if (Character.isSupplementaryCodePoint(ch)) {
3694                         patternBuffer.append(Character.toChars(ch));
3695                     } else {
3696                         patternBuffer.append((char)ch);
3697                     }
3698                 }
3699                 pattern = patternBuffer.toString();
3700 
3701                 // Avoid patterns that start and end with the same substring
3702                 // See JDK-6854417
3703                 for (int x=1; x &lt; pattern.length(); x++) {
3704                     if (pattern.startsWith(pattern.substring(x)))
3705                         continue retry;
3706                 }
3707                 break;
3708             }
3709             Pattern p = Pattern.compile(pattern);
3710 
3711             // Create a buffer with random ASCII chars that does
3712             // not match the sample
3713             String toSearch = null;
3714             StringBuffer s = null;
3715             Matcher m = p.matcher(&quot;&quot;);
3716             do {
3717                 s = new StringBuffer(100);
3718                 for (int x=0; x&lt;100; x++) {
3719                     int ch = baseCharacter + generator.nextInt(26);
3720                     if (Character.isSupplementaryCodePoint(ch)) {
3721                         s.append(Character.toChars(ch));
3722                     } else {
3723                         s.append((char)ch);
3724                     }
3725                 }
3726                 toSearch = s.toString();
3727                 m.reset(toSearch);
3728             } while (m.find());
3729 
3730             // Insert the pattern at a random spot
3731             int insertIndex = generator.nextInt(99);
3732             if (Character.isLowSurrogate(s.charAt(insertIndex)))
3733                 insertIndex++;
3734             s = s.insert(insertIndex, pattern);
3735             toSearch = s.toString();
3736 
3737             // Make sure that the pattern is found
3738             m.reset(toSearch);
3739             if (!m.find())
3740                 failCount++;
3741 
3742             // Make sure that the match text is the pattern
3743             if (!m.group().equals(pattern))
3744                 failCount++;
3745 
3746             // Make sure match occured at insertion point
3747             if (m.start() != insertIndex)
3748                 failCount++;
3749         }
3750     }
3751 
3752     /**
3753      * Tests the matching of slices on randomly generated patterns.
3754      * The Boyer-Moore optimization is not done on these patterns
3755      * because it uses unicode case folding.
3756      */
3757     private static void slice() throws Exception {
3758         doSlice(Character.MAX_VALUE);
3759         report(&quot;Slice&quot;);
3760 
3761         doSlice(Character.MAX_CODE_POINT);
3762         report(&quot;Slice (Supplementary)&quot;);
3763     }
3764 
3765     private static void doSlice(int maxCharacter) throws Exception {
3766         Random generator = new Random();
3767         int achar=0;
3768 
3769         for (int i=0; i&lt;100; i++) {
3770             // Create a short pattern to search for
3771             int patternLength = generator.nextInt(7) + 4;
3772             StringBuffer patternBuffer = new StringBuffer(patternLength);
3773             for (int x=0; x&lt;patternLength; x++) {
3774                 int randomChar = 0;
3775                 while (!Character.isLetterOrDigit(randomChar))
3776                     randomChar = generator.nextInt(maxCharacter);
3777                 if (Character.isSupplementaryCodePoint(randomChar)) {
3778                     patternBuffer.append(Character.toChars(randomChar));
3779                 } else {
3780                     patternBuffer.append((char) randomChar);
3781                 }
3782             }
3783             String pattern =  patternBuffer.toString();
3784             Pattern p = Pattern.compile(pattern, Pattern.UNICODE_CASE);
3785 
3786             // Create a buffer with random chars that does not match the sample
3787             String toSearch = null;
3788             StringBuffer s = null;
3789             Matcher m = p.matcher(&quot;&quot;);
3790             do {
3791                 s = new StringBuffer(100);
3792                 for (int x=0; x&lt;100; x++) {
3793                     int randomChar = 0;
3794                     while (!Character.isLetterOrDigit(randomChar))
3795                         randomChar = generator.nextInt(maxCharacter);
3796                     if (Character.isSupplementaryCodePoint(randomChar)) {
3797                         s.append(Character.toChars(randomChar));
3798                     } else {
3799                         s.append((char) randomChar);
3800                     }
3801                 }
3802                 toSearch = s.toString();
3803                 m.reset(toSearch);
3804             } while (m.find());
3805 
3806             // Insert the pattern at a random spot
3807             int insertIndex = generator.nextInt(99);
3808             if (Character.isLowSurrogate(s.charAt(insertIndex)))
3809                 insertIndex++;
3810             s = s.insert(insertIndex, pattern);
3811             toSearch = s.toString();
3812 
3813             // Make sure that the pattern is found
3814             m.reset(toSearch);
3815             if (!m.find())
3816                 failCount++;
3817 
3818             // Make sure that the match text is the pattern
3819             if (!m.group().equals(pattern))
3820                 failCount++;
3821 
3822             // Make sure match occured at insertion point
3823             if (m.start() != insertIndex)
3824                 failCount++;
3825         }
3826     }
3827 
3828     private static void explainFailure(String pattern, String data,
3829                                        String expected, String actual) {
3830         System.err.println(&quot;----------------------------------------&quot;);
3831         System.err.println(&quot;Pattern = &quot;+pattern);
3832         System.err.println(&quot;Data = &quot;+data);
3833         System.err.println(&quot;Expected = &quot; + expected);
3834         System.err.println(&quot;Actual   = &quot; + actual);
3835     }
3836 
3837     private static void explainFailure(String pattern, String data,
3838                                        Throwable t) {
3839         System.err.println(&quot;----------------------------------------&quot;);
3840         System.err.println(&quot;Pattern = &quot;+pattern);
3841         System.err.println(&quot;Data = &quot;+data);
3842         t.printStackTrace(System.err);
3843     }
3844 
3845     // Testing examples from a file
3846 
3847     /**
3848      * Goes through the file &quot;TestCases.txt&quot; and creates many patterns
3849      * described in the file, matching the patterns against input lines in
3850      * the file, and comparing the results against the correct results
3851      * also found in the file. The file format is described in comments
3852      * at the head of the file.
3853      */
3854     private static void processFile(String fileName) throws Exception {
3855         File testCases = new File(System.getProperty(&quot;test.src&quot;, &quot;.&quot;),
3856                                   fileName);
3857         FileInputStream in = new FileInputStream(testCases);
3858         BufferedReader r = new BufferedReader(new InputStreamReader(in));
3859 
3860         // Process next test case.
3861         String aLine;
3862         while((aLine = r.readLine()) != null) {
3863             // Read a line for pattern
3864             String patternString = grabLine(r);
3865             Pattern p = null;
3866             try {
3867                 p = compileTestPattern(patternString);
3868             } catch (PatternSyntaxException e) {
3869                 String dataString = grabLine(r);
3870                 String expectedResult = grabLine(r);
3871                 if (expectedResult.startsWith(&quot;error&quot;))
3872                     continue;
3873                 explainFailure(patternString, dataString, e);
3874                 failCount++;
3875                 continue;
3876             }
3877 
3878             // Read a line for input string
3879             String dataString = grabLine(r);
3880             Matcher m = p.matcher(dataString);
3881             StringBuffer result = new StringBuffer();
3882 
3883             // Check for IllegalStateExceptions before a match
3884             failCount += preMatchInvariants(m);
3885 
3886             boolean found = m.find();
3887 
3888             if (found)
3889                 failCount += postTrueMatchInvariants(m);
3890             else
3891                 failCount += postFalseMatchInvariants(m);
3892 
3893             if (found) {
3894                 result.append(&quot;true &quot;);
3895                 result.append(m.group(0) + &quot; &quot;);
3896             } else {
3897                 result.append(&quot;false &quot;);
3898             }
3899 
3900             result.append(m.groupCount());
3901 
3902             if (found) {
3903                 for (int i=1; i&lt;m.groupCount()+1; i++)
3904                     if (m.group(i) != null)
3905                         result.append(&quot; &quot; +m.group(i));
3906             }
3907 
3908             // Read a line for the expected result
3909             String expectedResult = grabLine(r);
3910 
3911             if (!result.toString().equals(expectedResult)) {
3912                 explainFailure(patternString, dataString, expectedResult, result.toString());
3913                 failCount++;
3914             }
3915         }
3916 
3917         report(fileName);
3918     }
3919 
3920     private static int preMatchInvariants(Matcher m) {
3921         int failCount = 0;
3922         try {
3923             m.start();
3924             failCount++;
3925         } catch (IllegalStateException ise) {}
3926         try {
3927             m.end();
3928             failCount++;
3929         } catch (IllegalStateException ise) {}
3930         try {
3931             m.group();
3932             failCount++;
3933         } catch (IllegalStateException ise) {}
3934         return failCount;
3935     }
3936 
3937     private static int postFalseMatchInvariants(Matcher m) {
3938         int failCount = 0;
3939         try {
3940             m.group();
3941             failCount++;
3942         } catch (IllegalStateException ise) {}
3943         try {
3944             m.start();
3945             failCount++;
3946         } catch (IllegalStateException ise) {}
3947         try {
3948             m.end();
3949             failCount++;
3950         } catch (IllegalStateException ise) {}
3951         return failCount;
3952     }
3953 
3954     private static int postTrueMatchInvariants(Matcher m) {
3955         int failCount = 0;
3956         //assert(m.start() = m.start(0);
3957         if (m.start() != m.start(0))
3958             failCount++;
3959         //assert(m.end() = m.end(0);
3960         if (m.start() != m.start(0))
3961             failCount++;
3962         //assert(m.group() = m.group(0);
3963         if (!m.group().equals(m.group(0)))
3964             failCount++;
3965         try {
3966             m.group(50);
3967             failCount++;
3968         } catch (IndexOutOfBoundsException ise) {}
3969 
3970         return failCount;
3971     }
3972 
3973     private static Pattern compileTestPattern(String patternString) {
3974         if (!patternString.startsWith(&quot;&#39;&quot;)) {
3975             return Pattern.compile(patternString);
3976         }
3977         int break1 = patternString.lastIndexOf(&quot;&#39;&quot;);
3978         String flagString = patternString.substring(
3979                                           break1+1, patternString.length());
3980         patternString = patternString.substring(1, break1);
3981 
3982         if (flagString.equals(&quot;i&quot;))
3983             return Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);
3984 
3985         if (flagString.equals(&quot;m&quot;))
3986             return Pattern.compile(patternString, Pattern.MULTILINE);
3987 
3988         return Pattern.compile(patternString);
3989     }
3990 
3991     /**
3992      * Reads a line from the input file. Keeps reading lines until a non
3993      * empty non comment line is read. If the line contains a \n then
3994      * these two characters are replaced by a newline char. If a \\uxxxx
3995      * sequence is read then the sequence is replaced by the unicode char.
3996      */
3997     private static String grabLine(BufferedReader r) throws Exception {
3998         int index = 0;
3999         String line = r.readLine();
4000         while (line.startsWith(&quot;//&quot;) || line.length() &lt; 1)
4001             line = r.readLine();
4002         while ((index = line.indexOf(&quot;\\n&quot;)) != -1) {
4003             StringBuffer temp = new StringBuffer(line);
4004             temp.replace(index, index+2, &quot;\n&quot;);
4005             line = temp.toString();
4006         }
4007         while ((index = line.indexOf(&quot;\\u&quot;)) != -1) {
4008             StringBuffer temp = new StringBuffer(line);
4009             String value = temp.substring(index+2, index+6);
4010             char aChar = (char)Integer.parseInt(value, 16);
4011             String unicodeChar = &quot;&quot; + aChar;
4012             temp.replace(index, index+6, unicodeChar);
4013             line = temp.toString();
4014         }
4015 
4016         return line;
4017     }
4018 
4019     private static void check(Pattern p, String s, String g, String expected) {
4020         Matcher m = p.matcher(s);
4021         m.find();
4022         if (!m.group(g).equals(expected) ||
4023             s.charAt(m.start(g)) != expected.charAt(0) ||
4024             s.charAt(m.end(g) - 1) != expected.charAt(expected.length() - 1))
4025             failCount++;
4026     }
4027 
4028     private static void checkReplaceFirst(String p, String s, String r, String expected)
4029     {
4030         if (!expected.equals(Pattern.compile(p)
4031                                     .matcher(s)
4032                                     .replaceFirst(r)))
4033             failCount++;
4034     }
4035 
4036     private static void checkReplaceAll(String p, String s, String r, String expected)
4037     {
4038         if (!expected.equals(Pattern.compile(p)
4039                                     .matcher(s)
4040                                     .replaceAll(r)))
4041             failCount++;
4042     }
4043 
4044     private static void checkExpectedFail(String p) {
4045         try {
4046             Pattern.compile(p);
4047         } catch (PatternSyntaxException pse) {
4048             //pse.printStackTrace();
4049             return;
4050         }
4051         failCount++;
4052     }
4053 
4054     private static void checkExpectedIAE(Matcher m, String g) {
4055         m.find();
4056         try {
4057             m.group(g);
4058         } catch (IllegalArgumentException x) {
4059             //iae.printStackTrace();
4060             try {
4061                 m.start(g);
4062             } catch (IllegalArgumentException xx) {
4063                 try {
4064                     m.start(g);
4065                 } catch (IllegalArgumentException xxx) {
4066                     return;
4067                 }
4068             }
4069         }
4070         failCount++;
4071     }
4072 
4073     private static void checkExpectedNPE(Matcher m) {
4074         m.find();
4075         try {
4076             m.group(null);
4077         } catch (NullPointerException x) {
4078             try {
4079                 m.start(null);
4080             } catch (NullPointerException xx) {
4081                 try {
4082                     m.end(null);
4083                 } catch (NullPointerException xxx) {
4084                     return;
4085                 }
4086             }
4087         }
4088         failCount++;
4089     }
4090 
4091     private static void namedGroupCaptureTest() throws Exception {
4092         check(Pattern.compile(&quot;x+(?&lt;gname&gt;y+)z+&quot;),
4093               &quot;xxxyyyzzz&quot;,
4094               &quot;gname&quot;,
4095               &quot;yyy&quot;);
4096 
4097         check(Pattern.compile(&quot;x+(?&lt;gname8&gt;y+)z+&quot;),
4098               &quot;xxxyyyzzz&quot;,
4099               &quot;gname8&quot;,
4100               &quot;yyy&quot;);
4101 
4102         //backref
4103         Pattern pattern = Pattern.compile(&quot;(a*)bc\\1&quot;);
4104         check(pattern, &quot;zzzaabcazzz&quot;, true);  // found &quot;abca&quot;
4105 
4106         check(Pattern.compile(&quot;(?&lt;gname&gt;a*)bc\\k&lt;gname&gt;&quot;),
4107               &quot;zzzaabcaazzz&quot;, true);
4108 
4109         check(Pattern.compile(&quot;(?&lt;gname&gt;abc)(def)\\k&lt;gname&gt;&quot;),
4110               &quot;abcdefabc&quot;, true);
4111 
4112         check(Pattern.compile(&quot;(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(?&lt;gname&gt;k)\\k&lt;gname&gt;&quot;),
4113               &quot;abcdefghijkk&quot;, true);
4114 
4115         // Supplementary character tests
4116         check(Pattern.compile(&quot;(?&lt;gname&gt;&quot; + toSupplementaries(&quot;a*)bc&quot;) + &quot;\\k&lt;gname&gt;&quot;),
4117               toSupplementaries(&quot;zzzaabcazzz&quot;), true);
4118 
4119         check(Pattern.compile(&quot;(?&lt;gname&gt;&quot; + toSupplementaries(&quot;a*)bc&quot;) + &quot;\\k&lt;gname&gt;&quot;),
4120               toSupplementaries(&quot;zzzaabcaazzz&quot;), true);
4121 
4122         check(Pattern.compile(&quot;(?&lt;gname&gt;&quot; + toSupplementaries(&quot;abc)(def)&quot;) + &quot;\\k&lt;gname&gt;&quot;),
4123               toSupplementaries(&quot;abcdefabc&quot;), true);
4124 
4125         check(Pattern.compile(toSupplementaries(&quot;(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)&quot;) +
4126                               &quot;(?&lt;gname&gt;&quot; +
4127                               toSupplementaries(&quot;k)&quot;) + &quot;\\k&lt;gname&gt;&quot;),
4128               toSupplementaries(&quot;abcdefghijkk&quot;), true);
4129 
4130         check(Pattern.compile(&quot;x+(?&lt;gname&gt;y+)z+\\k&lt;gname&gt;&quot;),
4131               &quot;xxxyyyzzzyyy&quot;,
4132               &quot;gname&quot;,
4133               &quot;yyy&quot;);
4134 
4135         //replaceFirst/All
4136         checkReplaceFirst(&quot;(?&lt;gn&gt;ab)(c*)&quot;,
4137                           &quot;abccczzzabcczzzabccc&quot;,
4138                           &quot;${gn}&quot;,
4139                           &quot;abzzzabcczzzabccc&quot;);
4140 
4141         checkReplaceAll(&quot;(?&lt;gn&gt;ab)(c*)&quot;,
4142                         &quot;abccczzzabcczzzabccc&quot;,
4143                         &quot;${gn}&quot;,
4144                         &quot;abzzzabzzzab&quot;);
4145 
4146 
4147         checkReplaceFirst(&quot;(?&lt;gn&gt;ab)(c*)&quot;,
4148                           &quot;zzzabccczzzabcczzzabccczzz&quot;,
4149                           &quot;${gn}&quot;,
4150                           &quot;zzzabzzzabcczzzabccczzz&quot;);
4151 
4152         checkReplaceAll(&quot;(?&lt;gn&gt;ab)(c*)&quot;,
4153                         &quot;zzzabccczzzabcczzzabccczzz&quot;,
4154                         &quot;${gn}&quot;,
4155                         &quot;zzzabzzzabzzzabzzz&quot;);
4156 
4157         checkReplaceFirst(&quot;(?&lt;gn1&gt;ab)(?&lt;gn2&gt;c*)&quot;,
4158                           &quot;zzzabccczzzabcczzzabccczzz&quot;,
4159                           &quot;${gn2}&quot;,
4160                           &quot;zzzccczzzabcczzzabccczzz&quot;);
4161 
4162         checkReplaceAll(&quot;(?&lt;gn1&gt;ab)(?&lt;gn2&gt;c*)&quot;,
4163                         &quot;zzzabccczzzabcczzzabccczzz&quot;,
4164                         &quot;${gn2}&quot;,
4165                         &quot;zzzccczzzcczzzccczzz&quot;);
4166 
4167         //toSupplementaries(&quot;(ab)(c*)&quot;));
4168         checkReplaceFirst(&quot;(?&lt;gn1&gt;&quot; + toSupplementaries(&quot;ab&quot;) +
4169                            &quot;)(?&lt;gn2&gt;&quot; + toSupplementaries(&quot;c&quot;) + &quot;*)&quot;,
4170                           toSupplementaries(&quot;abccczzzabcczzzabccc&quot;),
4171                           &quot;${gn1}&quot;,
4172                           toSupplementaries(&quot;abzzzabcczzzabccc&quot;));
4173 
4174 
4175         checkReplaceAll(&quot;(?&lt;gn1&gt;&quot; + toSupplementaries(&quot;ab&quot;) +
4176                         &quot;)(?&lt;gn2&gt;&quot; + toSupplementaries(&quot;c&quot;) + &quot;*)&quot;,
4177                         toSupplementaries(&quot;abccczzzabcczzzabccc&quot;),
4178                         &quot;${gn1}&quot;,
4179                         toSupplementaries(&quot;abzzzabzzzab&quot;));
4180 
4181         checkReplaceFirst(&quot;(?&lt;gn1&gt;&quot; + toSupplementaries(&quot;ab&quot;) +
4182                            &quot;)(?&lt;gn2&gt;&quot; + toSupplementaries(&quot;c&quot;) + &quot;*)&quot;,
4183                           toSupplementaries(&quot;abccczzzabcczzzabccc&quot;),
4184                           &quot;${gn2}&quot;,
4185                           toSupplementaries(&quot;ccczzzabcczzzabccc&quot;));
4186 
4187 
4188         checkReplaceAll(&quot;(?&lt;gn1&gt;&quot; + toSupplementaries(&quot;ab&quot;) +
4189                         &quot;)(?&lt;gn2&gt;&quot; + toSupplementaries(&quot;c&quot;) + &quot;*)&quot;,
4190                         toSupplementaries(&quot;abccczzzabcczzzabccc&quot;),
4191                         &quot;${gn2}&quot;,
4192                         toSupplementaries(&quot;ccczzzcczzzccc&quot;));
4193 
4194         checkReplaceFirst(&quot;(?&lt;dog&gt;Dog)AndCat&quot;,
4195                           &quot;zzzDogAndCatzzzDogAndCatzzz&quot;,
4196                           &quot;${dog}&quot;,
4197                           &quot;zzzDogzzzDogAndCatzzz&quot;);
4198 
4199 
4200         checkReplaceAll(&quot;(?&lt;dog&gt;Dog)AndCat&quot;,
4201                           &quot;zzzDogAndCatzzzDogAndCatzzz&quot;,
4202                           &quot;${dog}&quot;,
4203                           &quot;zzzDogzzzDogzzz&quot;);
4204 
4205         // backref in Matcher &amp; String
4206         if (!&quot;abcdefghij&quot;.replaceFirst(&quot;cd(?&lt;gn&gt;ef)gh&quot;, &quot;${gn}&quot;).equals(&quot;abefij&quot;) ||
4207             !&quot;abbbcbdbefgh&quot;.replaceAll(&quot;(?&lt;gn&gt;[a-e])b&quot;, &quot;${gn}&quot;).equals(&quot;abcdefgh&quot;))
4208             failCount++;
4209 
4210         // negative
4211         checkExpectedFail(&quot;(?&lt;groupnamehasnoascii.in&gt;abc)(def)&quot;);
4212         checkExpectedFail(&quot;(?&lt;groupnamehasnoascii_in&gt;abc)(def)&quot;);
4213         checkExpectedFail(&quot;(?&lt;6groupnamestartswithdigit&gt;abc)(def)&quot;);
4214         checkExpectedFail(&quot;(?&lt;gname&gt;abc)(def)\\k&lt;gnameX&gt;&quot;);
4215         checkExpectedFail(&quot;(?&lt;gname&gt;abc)(?&lt;gname&gt;def)\\k&lt;gnameX&gt;&quot;);
4216         checkExpectedIAE(Pattern.compile(&quot;(?&lt;gname&gt;abc)(def)&quot;).matcher(&quot;abcdef&quot;),
4217                          &quot;gnameX&quot;);
4218         checkExpectedNPE(Pattern.compile(&quot;(?&lt;gname&gt;abc)(def)&quot;).matcher(&quot;abcdef&quot;));
4219         report(&quot;NamedGroupCapture&quot;);
4220     }
4221 
4222     // This is for bug 6919132
4223     private static void nonBmpClassComplementTest() throws Exception {
4224         Pattern p = Pattern.compile(&quot;\\P{Lu}&quot;);
4225         Matcher m = p.matcher(new String(new int[] {0x1d400}, 0, 1));
4226 
4227         if (m.find() &amp;&amp; m.start() == 1)
4228             failCount++;
4229 
4230         // from a unicode category
4231         p = Pattern.compile(&quot;\\P{Lu}&quot;);
4232         m = p.matcher(new String(new int[] {0x1d400}, 0, 1));
4233         if (m.find())
4234             failCount++;
4235         if (!m.hitEnd())
4236             failCount++;
4237 
4238         // block
4239         p = Pattern.compile(&quot;\\P{InMathematicalAlphanumericSymbols}&quot;);
4240         m = p.matcher(new String(new int[] {0x1d400}, 0, 1));
4241         if (m.find() &amp;&amp; m.start() == 1)
4242             failCount++;
4243 
4244         p = Pattern.compile(&quot;\\P{sc=GRANTHA}&quot;);
4245         m = p.matcher(new String(new int[] {0x11350}, 0, 1));
4246         if (m.find() &amp;&amp; m.start() == 1)
4247             failCount++;
4248 
4249         report(&quot;NonBmpClassComplement&quot;);
4250     }
4251 
4252     private static void unicodePropertiesTest() throws Exception {
4253         // different forms
4254         if (!Pattern.compile(&quot;\\p{IsLu}&quot;).matcher(&quot;A&quot;).matches() ||
4255             !Pattern.compile(&quot;\\p{Lu}&quot;).matcher(&quot;A&quot;).matches() ||
4256             !Pattern.compile(&quot;\\p{gc=Lu}&quot;).matcher(&quot;A&quot;).matches() ||
4257             !Pattern.compile(&quot;\\p{general_category=Lu}&quot;).matcher(&quot;A&quot;).matches() ||
4258             !Pattern.compile(&quot;\\p{IsLatin}&quot;).matcher(&quot;B&quot;).matches() ||
4259             !Pattern.compile(&quot;\\p{sc=Latin}&quot;).matcher(&quot;B&quot;).matches() ||
4260             !Pattern.compile(&quot;\\p{script=Latin}&quot;).matcher(&quot;B&quot;).matches() ||
4261             !Pattern.compile(&quot;\\p{InBasicLatin}&quot;).matcher(&quot;c&quot;).matches() ||
4262             !Pattern.compile(&quot;\\p{blk=BasicLatin}&quot;).matcher(&quot;c&quot;).matches() ||
4263             !Pattern.compile(&quot;\\p{block=BasicLatin}&quot;).matcher(&quot;c&quot;).matches())
4264             failCount++;
4265 
4266         Matcher common  = Pattern.compile(&quot;\\p{script=Common}&quot;).matcher(&quot;&quot;);
4267         Matcher unknown = Pattern.compile(&quot;\\p{IsUnknown}&quot;).matcher(&quot;&quot;);
4268         Matcher lastSM  = common;
4269         Character.UnicodeScript lastScript = Character.UnicodeScript.of(0);
4270 
4271         Matcher latin  = Pattern.compile(&quot;\\p{block=basic_latin}&quot;).matcher(&quot;&quot;);
4272         Matcher greek  = Pattern.compile(&quot;\\p{InGreek}&quot;).matcher(&quot;&quot;);
4273         Matcher lastBM = latin;
4274         Character.UnicodeBlock lastBlock = Character.UnicodeBlock.of(0);
4275 
4276         for (int cp = 1; cp &lt; Character.MAX_CODE_POINT; cp++) {
4277             if (cp &gt;= 0x30000 &amp;&amp; (cp &amp; 0x70) == 0){
4278                 continue;  // only pick couple code points, they are the same
4279             }
4280 
4281             // Unicode Script
4282             Character.UnicodeScript script = Character.UnicodeScript.of(cp);
4283             Matcher m;
4284             String str = new String(Character.toChars(cp));
4285             if (script == lastScript) {
4286                  m = lastSM;
4287                  m.reset(str);
4288             } else {
4289                  m  = Pattern.compile(&quot;\\p{Is&quot; + script.name() + &quot;}&quot;).matcher(str);
4290             }
4291             if (!m.matches()) {
4292                 failCount++;
4293             }
4294             Matcher other = (script == Character.UnicodeScript.COMMON)? unknown : common;
4295             other.reset(str);
4296             if (other.matches()) {
4297                 failCount++;
4298             }
4299             lastSM = m;
4300             lastScript = script;
4301 
4302             // Unicode Block
4303             Character.UnicodeBlock block = Character.UnicodeBlock.of(cp);
4304             if (block == null) {
4305                 //System.out.printf(&quot;Not a Block: cp=%x%n&quot;, cp);
4306                 continue;
4307             }
4308             if (block == lastBlock) {
4309                  m = lastBM;
4310                  m.reset(str);
4311             } else {
4312                  m  = Pattern.compile(&quot;\\p{block=&quot; + block.toString() + &quot;}&quot;).matcher(str);
4313             }
4314             if (!m.matches()) {
4315                 failCount++;
4316             }
4317             other = (block == Character.UnicodeBlock.BASIC_LATIN)? greek : latin;
4318             other.reset(str);
4319             if (other.matches()) {
4320                 failCount++;
4321             }
4322             lastBM = m;
4323             lastBlock = block;
4324         }
4325         report(&quot;unicodeProperties&quot;);
4326     }
4327 
4328     private static void unicodeHexNotationTest() throws Exception {
4329 
4330         // negative
4331         checkExpectedFail(&quot;\\x{-23}&quot;);
4332         checkExpectedFail(&quot;\\x{110000}&quot;);
4333         checkExpectedFail(&quot;\\x{}&quot;);
4334         checkExpectedFail(&quot;\\x{AB[ef]&quot;);
4335 
4336         // codepoint
4337         check(&quot;^\\x{1033c}$&quot;,              &quot;\uD800\uDF3C&quot;, true);
4338         check(&quot;^\\xF0\\x90\\x8C\\xBC$&quot;,    &quot;\uD800\uDF3C&quot;, false);
4339         check(&quot;^\\x{D800}\\x{DF3c}+$&quot;,     &quot;\uD800\uDF3C&quot;, false);
4340         check(&quot;^\\xF0\\x90\\x8C\\xBC$&quot;,    &quot;\uD800\uDF3C&quot;, false);
4341 
4342         // in class
4343         check(&quot;^[\\x{D800}\\x{DF3c}]+$&quot;,   &quot;\uD800\uDF3C&quot;, false);
4344         check(&quot;^[\\xF0\\x90\\x8C\\xBC]+$&quot;, &quot;\uD800\uDF3C&quot;, false);
4345         check(&quot;^[\\x{D800}\\x{DF3C}]+$&quot;,   &quot;\uD800\uDF3C&quot;, false);
4346         check(&quot;^[\\x{DF3C}\\x{D800}]+$&quot;,   &quot;\uD800\uDF3C&quot;, false);
4347         check(&quot;^[\\x{D800}\\x{DF3C}]+$&quot;,   &quot;\uDF3C\uD800&quot;, true);
4348         check(&quot;^[\\x{DF3C}\\x{D800}]+$&quot;,   &quot;\uDF3C\uD800&quot;, true);
4349 
4350         for (int cp = 0; cp &lt;= 0x10FFFF; cp++) {
4351              String s = &quot;A&quot; + new String(Character.toChars(cp)) + &quot;B&quot;;
4352              String hexUTF16 = (cp &lt;= 0xFFFF)? String.format(&quot;\\u%04x&quot;, cp)
4353                                              : String.format(&quot;\\u%04x\\u%04x&quot;,
4354                                                (int) Character.toChars(cp)[0],
4355                                                (int) Character.toChars(cp)[1]);
4356              String hexCodePoint = &quot;\\x{&quot; + Integer.toHexString(cp) + &quot;}&quot;;
4357              if (!Pattern.matches(&quot;A&quot; + hexUTF16 + &quot;B&quot;, s))
4358                  failCount++;
4359              if (!Pattern.matches(&quot;A[&quot; + hexUTF16 + &quot;]B&quot;, s))
4360                  failCount++;
4361              if (!Pattern.matches(&quot;A&quot; + hexCodePoint + &quot;B&quot;, s))
4362                  failCount++;
4363              if (!Pattern.matches(&quot;A[&quot; + hexCodePoint + &quot;]B&quot;, s))
4364                  failCount++;
4365          }
4366          report(&quot;unicodeHexNotation&quot;);
4367     }
4368 
4369     private static void unicodeClassesTest() throws Exception {
4370 
4371         Matcher lower  = Pattern.compile(&quot;\\p{Lower}&quot;).matcher(&quot;&quot;);
4372         Matcher upper  = Pattern.compile(&quot;\\p{Upper}&quot;).matcher(&quot;&quot;);
4373         Matcher ASCII  = Pattern.compile(&quot;\\p{ASCII}&quot;).matcher(&quot;&quot;);
4374         Matcher alpha  = Pattern.compile(&quot;\\p{Alpha}&quot;).matcher(&quot;&quot;);
4375         Matcher digit  = Pattern.compile(&quot;\\p{Digit}&quot;).matcher(&quot;&quot;);
4376         Matcher alnum  = Pattern.compile(&quot;\\p{Alnum}&quot;).matcher(&quot;&quot;);
4377         Matcher punct  = Pattern.compile(&quot;\\p{Punct}&quot;).matcher(&quot;&quot;);
4378         Matcher graph  = Pattern.compile(&quot;\\p{Graph}&quot;).matcher(&quot;&quot;);
4379         Matcher print  = Pattern.compile(&quot;\\p{Print}&quot;).matcher(&quot;&quot;);
4380         Matcher blank  = Pattern.compile(&quot;\\p{Blank}&quot;).matcher(&quot;&quot;);
4381         Matcher cntrl  = Pattern.compile(&quot;\\p{Cntrl}&quot;).matcher(&quot;&quot;);
4382         Matcher xdigit = Pattern.compile(&quot;\\p{XDigit}&quot;).matcher(&quot;&quot;);
4383         Matcher space  = Pattern.compile(&quot;\\p{Space}&quot;).matcher(&quot;&quot;);
4384         Matcher bound  = Pattern.compile(&quot;\\b&quot;).matcher(&quot;&quot;);
4385         Matcher word   = Pattern.compile(&quot;\\w++&quot;).matcher(&quot;&quot;);
4386         // UNICODE_CHARACTER_CLASS
4387         Matcher lowerU  = Pattern.compile(&quot;\\p{Lower}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4388         Matcher upperU  = Pattern.compile(&quot;\\p{Upper}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4389         Matcher ASCIIU  = Pattern.compile(&quot;\\p{ASCII}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4390         Matcher alphaU  = Pattern.compile(&quot;\\p{Alpha}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4391         Matcher digitU  = Pattern.compile(&quot;\\p{Digit}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4392         Matcher alnumU  = Pattern.compile(&quot;\\p{Alnum}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4393         Matcher punctU  = Pattern.compile(&quot;\\p{Punct}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4394         Matcher graphU  = Pattern.compile(&quot;\\p{Graph}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4395         Matcher printU  = Pattern.compile(&quot;\\p{Print}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4396         Matcher blankU  = Pattern.compile(&quot;\\p{Blank}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4397         Matcher cntrlU  = Pattern.compile(&quot;\\p{Cntrl}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4398         Matcher xdigitU = Pattern.compile(&quot;\\p{XDigit}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4399         Matcher spaceU  = Pattern.compile(&quot;\\p{Space}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4400         Matcher boundU  = Pattern.compile(&quot;\\b&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4401         Matcher wordU   = Pattern.compile(&quot;\\w&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4402         // embedded flag (?U)
4403         Matcher lowerEU  = Pattern.compile(&quot;(?U)\\p{Lower}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4404         Matcher graphEU  = Pattern.compile(&quot;(?U)\\p{Graph}&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4405         Matcher wordEU   = Pattern.compile(&quot;(?U)\\w&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4406 
4407         Matcher bwb    = Pattern.compile(&quot;\\b\\w\\b&quot;).matcher(&quot;&quot;);
4408         Matcher bwbU   = Pattern.compile(&quot;\\b\\w++\\b&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4409         Matcher bwbEU  = Pattern.compile(&quot;(?U)\\b\\w++\\b&quot;, Pattern.UNICODE_CHARACTER_CLASS).matcher(&quot;&quot;);
4410         // properties
4411         Matcher lowerP  = Pattern.compile(&quot;\\p{IsLowerCase}&quot;).matcher(&quot;&quot;);
4412         Matcher upperP  = Pattern.compile(&quot;\\p{IsUpperCase}&quot;).matcher(&quot;&quot;);
4413         Matcher titleP  = Pattern.compile(&quot;\\p{IsTitleCase}&quot;).matcher(&quot;&quot;);
4414         Matcher letterP = Pattern.compile(&quot;\\p{IsLetter}&quot;).matcher(&quot;&quot;);
4415         Matcher alphaP  = Pattern.compile(&quot;\\p{IsAlphabetic}&quot;).matcher(&quot;&quot;);
4416         Matcher ideogP  = Pattern.compile(&quot;\\p{IsIdeographic}&quot;).matcher(&quot;&quot;);
4417         Matcher cntrlP  = Pattern.compile(&quot;\\p{IsControl}&quot;).matcher(&quot;&quot;);
4418         Matcher spaceP  = Pattern.compile(&quot;\\p{IsWhiteSpace}&quot;).matcher(&quot;&quot;);
4419         Matcher definedP = Pattern.compile(&quot;\\p{IsAssigned}&quot;).matcher(&quot;&quot;);
4420         Matcher nonCCPP = Pattern.compile(&quot;\\p{IsNoncharacterCodePoint}&quot;).matcher(&quot;&quot;);
4421         Matcher joinCrtl = Pattern.compile(&quot;\\p{IsJoinControl}&quot;).matcher(&quot;&quot;);
4422         // javaMethod
4423         Matcher lowerJ  = Pattern.compile(&quot;\\p{javaLowerCase}&quot;).matcher(&quot;&quot;);
4424         Matcher upperJ  = Pattern.compile(&quot;\\p{javaUpperCase}&quot;).matcher(&quot;&quot;);
4425         Matcher alphaJ  = Pattern.compile(&quot;\\p{javaAlphabetic}&quot;).matcher(&quot;&quot;);
4426         Matcher ideogJ  = Pattern.compile(&quot;\\p{javaIdeographic}&quot;).matcher(&quot;&quot;);
4427         // GC/C
4428         Matcher gcC  = Pattern.compile(&quot;\\p{C}&quot;).matcher(&quot;&quot;);
4429 
4430         for (int cp = 1; cp &lt; 0x30000; cp++) {
4431             String str = new String(Character.toChars(cp));
4432             int type = Character.getType(cp);
4433             if (// lower
4434                 POSIX_ASCII.isLower(cp)   != lower.reset(str).matches()  ||
4435                 Character.isLowerCase(cp) != lowerU.reset(str).matches() ||
4436                 Character.isLowerCase(cp) != lowerP.reset(str).matches() ||
4437                 Character.isLowerCase(cp) != lowerEU.reset(str).matches()||
4438                 Character.isLowerCase(cp) != lowerJ.reset(str).matches()||
4439                 // upper
4440                 POSIX_ASCII.isUpper(cp)   != upper.reset(str).matches()  ||
4441                 POSIX_Unicode.isUpper(cp) != upperU.reset(str).matches() ||
4442                 Character.isUpperCase(cp) != upperP.reset(str).matches() ||
4443                 Character.isUpperCase(cp) != upperJ.reset(str).matches() ||
4444                 // alpha
4445                 POSIX_ASCII.isAlpha(cp)   != alpha.reset(str).matches()  ||
4446                 POSIX_Unicode.isAlpha(cp) != alphaU.reset(str).matches() ||
4447                 Character.isAlphabetic(cp)!= alphaP.reset(str).matches() ||
4448                 Character.isAlphabetic(cp)!= alphaJ.reset(str).matches() ||
4449                 // digit
4450                 POSIX_ASCII.isDigit(cp)   != digit.reset(str).matches()  ||
4451                 Character.isDigit(cp)     != digitU.reset(str).matches() ||
4452                 // alnum
4453                 POSIX_ASCII.isAlnum(cp)   != alnum.reset(str).matches()  ||
4454                 POSIX_Unicode.isAlnum(cp) != alnumU.reset(str).matches() ||
4455                 // punct
4456                 POSIX_ASCII.isPunct(cp)   != punct.reset(str).matches()  ||
4457                 POSIX_Unicode.isPunct(cp) != punctU.reset(str).matches() ||
4458                 // graph
4459                 POSIX_ASCII.isGraph(cp)   != graph.reset(str).matches()  ||
4460                 POSIX_Unicode.isGraph(cp) != graphU.reset(str).matches() ||
4461                 POSIX_Unicode.isGraph(cp) != graphEU.reset(str).matches()||
4462                 // blank
4463                 POSIX_ASCII.isType(cp, POSIX_ASCII.BLANK)
4464                                           != blank.reset(str).matches()  ||
4465                 POSIX_Unicode.isBlank(cp) != blankU.reset(str).matches() ||
4466                 // print
4467                 POSIX_ASCII.isPrint(cp)   != print.reset(str).matches()  ||
4468                 POSIX_Unicode.isPrint(cp) != printU.reset(str).matches() ||
4469                 // cntrl
4470                 POSIX_ASCII.isCntrl(cp)   != cntrl.reset(str).matches()  ||
4471                 POSIX_Unicode.isCntrl(cp) != cntrlU.reset(str).matches() ||
4472                 (Character.CONTROL == type) != cntrlP.reset(str).matches() ||
4473                 // hexdigit
4474                 POSIX_ASCII.isHexDigit(cp)   != xdigit.reset(str).matches()  ||
4475                 POSIX_Unicode.isHexDigit(cp) != xdigitU.reset(str).matches() ||
4476                 // space
4477                 POSIX_ASCII.isSpace(cp)   != space.reset(str).matches()  ||
4478                 POSIX_Unicode.isSpace(cp) != spaceU.reset(str).matches() ||
4479                 POSIX_Unicode.isSpace(cp) != spaceP.reset(str).matches() ||
4480                 // word
4481                 POSIX_ASCII.isWord(cp)   != word.reset(str).matches()  ||
4482                 POSIX_Unicode.isWord(cp) != wordU.reset(str).matches() ||
4483                 POSIX_Unicode.isWord(cp) != wordEU.reset(str).matches()||
4484                 // bwordb
4485                 POSIX_ASCII.isWord(cp) != bwb.reset(str).matches() ||
4486                 POSIX_Unicode.isWord(cp) != bwbU.reset(str).matches() ||
4487                 // properties
4488                 Character.isTitleCase(cp) != titleP.reset(str).matches() ||
4489                 Character.isLetter(cp)    != letterP.reset(str).matches()||
4490                 Character.isIdeographic(cp) != ideogP.reset(str).matches() ||
4491                 Character.isIdeographic(cp) != ideogJ.reset(str).matches() ||
4492                 (Character.UNASSIGNED == type) == definedP.reset(str).matches() ||
4493                 POSIX_Unicode.isNoncharacterCodePoint(cp) != nonCCPP.reset(str).matches() ||
4494                 POSIX_Unicode.isJoinControl(cp) != joinCrtl.reset(str).matches() ||
4495                 // gc_C
4496                 (Character.CONTROL == type || Character.FORMAT == type ||
4497                  Character.PRIVATE_USE == type || Character.SURROGATE == type ||
4498                  Character.UNASSIGNED == type)
4499                 != gcC.reset(str).matches()) {
4500                 failCount++;
4501             }
4502         }
4503 
4504         // bounds/word align
4505         twoFindIndexes(&quot; \u0180sherman\u0400 &quot;, bound, 1, 10);
4506         if (!bwbU.reset(&quot;\u0180sherman\u0400&quot;).matches())
4507             failCount++;
4508         twoFindIndexes(&quot; \u0180sh\u0345erman\u0400 &quot;, bound, 1, 11);
4509         if (!bwbU.reset(&quot;\u0180sh\u0345erman\u0400&quot;).matches())
4510             failCount++;
4511         twoFindIndexes(&quot; \u0724\u0739\u0724 &quot;, bound, 1, 4);
4512         if (!bwbU.reset(&quot;\u0724\u0739\u0724&quot;).matches())
4513             failCount++;
4514         if (!bwbEU.reset(&quot;\u0724\u0739\u0724&quot;).matches())
4515             failCount++;
4516         report(&quot;unicodePredefinedClasses&quot;);
4517     }
4518 
4519     private static void unicodeCharacterNameTest() throws Exception {
4520 
4521         for (int cp = 0; cp &lt; Character.MAX_CODE_POINT; cp++) {
4522             if (!Character.isValidCodePoint(cp) ||
4523                 Character.getType(cp) == Character.UNASSIGNED)
4524                 continue;
4525             String str = new String(Character.toChars(cp));
4526             // single
4527             String p = &quot;\\N{&quot; + Character.getName(cp) + &quot;}&quot;;
4528             if (!Pattern.compile(p).matcher(str).matches()) {
4529                 failCount++;
4530             }
4531             // class[c]
4532             p = &quot;[\\N{&quot; + Character.getName(cp) + &quot;}]&quot;;
4533             if (!Pattern.compile(p).matcher(str).matches()) {
4534                 failCount++;
4535             }
4536         }
4537 
4538         // range
4539         for (int i = 0; i &lt; 10; i++) {
4540             int start = generator.nextInt(20);
4541             int end = start + generator.nextInt(200);
4542             String p = &quot;[\\N{&quot; + Character.getName(start) + &quot;}-\\N{&quot; + Character.getName(end) + &quot;}]&quot;;
4543             String str;
4544             for (int cp = start; cp &lt; end; cp++) {
4545                 str = new String(Character.toChars(cp));
4546                 if (!Pattern.compile(p).matcher(str).matches()) {
4547                     failCount++;
4548                 }
4549             }
4550             str = new String(Character.toChars(end + 10));
4551             if (Pattern.compile(p).matcher(str).matches()) {
4552                 failCount++;
4553             }
4554         }
4555 
4556         // slice
4557         for (int i = 0; i &lt; 10; i++) {
4558             int n = generator.nextInt(256);
4559             int[] buf = new int[n];
4560             StringBuffer sb = new StringBuffer(1024);
4561             for (int j = 0; j &lt; n; j++) {
4562                 int cp = generator.nextInt(1000);
4563                 if (!Character.isValidCodePoint(cp) ||
4564                     Character.getType(cp) == Character.UNASSIGNED)
4565                     cp = 0x4e00;    // just use 4e00
4566                 sb.append(&quot;\\N{&quot; + Character.getName(cp) + &quot;}&quot;);
4567                 buf[j] = cp;
4568             }
4569             String p = sb.toString();
4570             String str = new String(buf, 0, buf.length);
4571             if (!Pattern.compile(p).matcher(str).matches()) {
4572                 failCount++;
4573             }
4574         }
4575         report(&quot;unicodeCharacterName&quot;);
4576     }
4577 
4578     private static void horizontalAndVerticalWSTest() throws Exception {
4579         String hws = new String (new char[] {
4580                                      0x09, 0x20, 0xa0, 0x1680, 0x180e,
4581                                      0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005,
4582                                      0x2006, 0x2007, 0x2008, 0x2009, 0x200a,
4583                                      0x202f, 0x205f, 0x3000 });
4584         String vws = new String (new char[] {
4585                                      0x0a, 0x0b, 0x0c, 0x0d, 0x85, 0x2028, 0x2029 });
4586         if (!Pattern.compile(&quot;\\h+&quot;).matcher(hws).matches() ||
4587             !Pattern.compile(&quot;[\\h]+&quot;).matcher(hws).matches())
4588             failCount++;
4589         if (Pattern.compile(&quot;\\H&quot;).matcher(hws).find() ||
4590             Pattern.compile(&quot;[\\H]&quot;).matcher(hws).find())
4591             failCount++;
4592         if (!Pattern.compile(&quot;\\v+&quot;).matcher(vws).matches() ||
4593             !Pattern.compile(&quot;[\\v]+&quot;).matcher(vws).matches())
4594             failCount++;
4595         if (Pattern.compile(&quot;\\V&quot;).matcher(vws).find() ||
4596             Pattern.compile(&quot;[\\V]&quot;).matcher(vws).find())
4597             failCount++;
4598         String prefix = &quot;abcd&quot;;
4599         String suffix = &quot;efgh&quot;;
4600         String ng = &quot;A&quot;;
4601         for (int i = 0; i &lt; hws.length(); i++) {
4602             String c = String.valueOf(hws.charAt(i));
4603             Matcher m = Pattern.compile(&quot;\\h&quot;).matcher(prefix + c + suffix);
4604             if (!m.find() || !c.equals(m.group()))
4605                 failCount++;
4606             m = Pattern.compile(&quot;[\\h]&quot;).matcher(prefix + c + suffix);
4607             if (!m.find() || !c.equals(m.group()))
4608                 failCount++;
4609 
4610             m = Pattern.compile(&quot;\\H&quot;).matcher(hws.substring(0, i) + ng + hws.substring(i));
4611             if (!m.find() || !ng.equals(m.group()))
4612                 failCount++;
4613             m = Pattern.compile(&quot;[\\H]&quot;).matcher(hws.substring(0, i) + ng + hws.substring(i));
4614             if (!m.find() || !ng.equals(m.group()))
4615                 failCount++;
4616         }
4617         for (int i = 0; i &lt; vws.length(); i++) {
4618             String c = String.valueOf(vws.charAt(i));
4619             Matcher m = Pattern.compile(&quot;\\v&quot;).matcher(prefix + c + suffix);
4620             if (!m.find() || !c.equals(m.group()))
4621                 failCount++;
4622             m = Pattern.compile(&quot;[\\v]&quot;).matcher(prefix + c + suffix);
4623             if (!m.find() || !c.equals(m.group()))
4624                 failCount++;
4625 
4626             m = Pattern.compile(&quot;\\V&quot;).matcher(vws.substring(0, i) + ng + vws.substring(i));
4627             if (!m.find() || !ng.equals(m.group()))
4628                 failCount++;
4629             m = Pattern.compile(&quot;[\\V]&quot;).matcher(vws.substring(0, i) + ng + vws.substring(i));
4630             if (!m.find() || !ng.equals(m.group()))
4631                 failCount++;
4632         }
4633         // \v in range is interpreted as 0x0B. This is the undocumented behavior
4634         if (!Pattern.compile(&quot;[\\v-\\v]&quot;).matcher(String.valueOf((char)0x0B)).matches())
4635             failCount++;
4636         report(&quot;horizontalAndVerticalWSTest&quot;);
4637     }
4638 
4639     private static void linebreakTest() throws Exception {
4640         String linebreaks = new String (new char[] {
4641             0x0A, 0x0B, 0x0C, 0x0D, 0x85, 0x2028, 0x2029 });
4642         String crnl = &quot;\r\n&quot;;
4643         if (!(Pattern.compile(&quot;\\R+&quot;).matcher(linebreaks).matches() &amp;&amp;
4644               Pattern.compile(&quot;\\R&quot;).matcher(crnl).matches() &amp;&amp;
4645               Pattern.compile(&quot;\\Rabc&quot;).matcher(crnl + &quot;abc&quot;).matches() &amp;&amp;
4646               Pattern.compile(&quot;\\Rabc&quot;).matcher(&quot;\rabc&quot;).matches() &amp;&amp;
4647               Pattern.compile(&quot;\\R\\R&quot;).matcher(crnl).matches() &amp;&amp;  // backtracking
4648               Pattern.compile(&quot;\\R\\n&quot;).matcher(crnl).matches()) &amp;&amp; // backtracking
4649               !Pattern.compile(&quot;((?&lt;!\\R)\\s)*&quot;).matcher(crnl).matches()) { // #8176029
4650             failCount++;
4651         }
4652         report(&quot;linebreakTest&quot;);
4653     }
4654 
4655     // #7189363
4656     private static void branchTest() throws Exception {
4657         if (!Pattern.compile(&quot;(a)?bc|d&quot;).matcher(&quot;d&quot;).find() ||     // greedy
4658             !Pattern.compile(&quot;(a)+bc|d&quot;).matcher(&quot;d&quot;).find() ||
4659             !Pattern.compile(&quot;(a)*bc|d&quot;).matcher(&quot;d&quot;).find() ||
4660             !Pattern.compile(&quot;(a)??bc|d&quot;).matcher(&quot;d&quot;).find() ||    // reluctant
4661             !Pattern.compile(&quot;(a)+?bc|d&quot;).matcher(&quot;d&quot;).find() ||
4662             !Pattern.compile(&quot;(a)*?bc|d&quot;).matcher(&quot;d&quot;).find() ||
4663             !Pattern.compile(&quot;(a)?+bc|d&quot;).matcher(&quot;d&quot;).find() ||    // possessive
4664             !Pattern.compile(&quot;(a)++bc|d&quot;).matcher(&quot;d&quot;).find() ||
4665             !Pattern.compile(&quot;(a)*+bc|d&quot;).matcher(&quot;d&quot;).find() ||
4666             !Pattern.compile(&quot;(a)?bc|d&quot;).matcher(&quot;d&quot;).matches() ||  // greedy
4667             !Pattern.compile(&quot;(a)+bc|d&quot;).matcher(&quot;d&quot;).matches() ||
4668             !Pattern.compile(&quot;(a)*bc|d&quot;).matcher(&quot;d&quot;).matches() ||
4669             !Pattern.compile(&quot;(a)??bc|d&quot;).matcher(&quot;d&quot;).matches() || // reluctant
4670             !Pattern.compile(&quot;(a)+?bc|d&quot;).matcher(&quot;d&quot;).matches() ||
4671             !Pattern.compile(&quot;(a)*?bc|d&quot;).matcher(&quot;d&quot;).matches() ||
4672             !Pattern.compile(&quot;(a)?+bc|d&quot;).matcher(&quot;d&quot;).matches() || // possessive
4673             !Pattern.compile(&quot;(a)++bc|d&quot;).matcher(&quot;d&quot;).matches() ||
4674             !Pattern.compile(&quot;(a)*+bc|d&quot;).matcher(&quot;d&quot;).matches() ||
4675             !Pattern.compile(&quot;(a)?bc|de&quot;).matcher(&quot;de&quot;).find() ||   // others
4676             !Pattern.compile(&quot;(a)??bc|de&quot;).matcher(&quot;de&quot;).find() ||
4677             !Pattern.compile(&quot;(a)?bc|de&quot;).matcher(&quot;de&quot;).matches() ||
4678             !Pattern.compile(&quot;(a)??bc|de&quot;).matcher(&quot;de&quot;).matches())
4679             failCount++;
4680         report(&quot;branchTest&quot;);
4681     }
4682 
4683     // This test is for 8007395
4684     private static void groupCurlyNotFoundSuppTest() throws Exception {
4685         String input = &quot;test this as \ud83d\ude0d&quot;;
4686         for (String pStr : new String[] { &quot;test(.)+(@[a-zA-Z.]+)&quot;,
4687                                           &quot;test(.)*(@[a-zA-Z.]+)&quot;,
4688                                           &quot;test([^B])+(@[a-zA-Z.]+)&quot;,
4689                                           &quot;test([^B])*(@[a-zA-Z.]+)&quot;,
4690                                           &quot;test(\\P{IsControl})+(@[a-zA-Z.]+)&quot;,
4691                                           &quot;test(\\P{IsControl})*(@[a-zA-Z.]+)&quot;,
4692                                         }) {
4693             Matcher m = Pattern.compile(pStr, Pattern.CASE_INSENSITIVE)
4694                                .matcher(input);
4695             try {
4696                 if (m.find()) {
4697                     failCount++;
4698                 }
4699             } catch (Exception x) {
4700                 failCount++;
4701             }
4702         }
4703         report(&quot;GroupCurly NotFoundSupp&quot;);
4704     }
4705 
4706     // This test is for 8023647
4707     private static void groupCurlyBackoffTest() throws Exception {
4708         if (!&quot;abc1c&quot;.matches(&quot;(\\w)+1\\1&quot;) ||
4709             &quot;abc11&quot;.matches(&quot;(\\w)+1\\1&quot;)) {
4710             failCount++;
4711         }
4712         report(&quot;GroupCurly backoff&quot;);
4713     }
4714 
4715     // This test is for 8012646
4716     private static void patternAsPredicate() throws Exception {
4717         Predicate&lt;String&gt; p = Pattern.compile(&quot;[a-z]+&quot;).asPredicate();
4718 
4719         if (p.test(&quot;&quot;)) {
4720             failCount++;
4721         }
4722         if (!p.test(&quot;word&quot;)) {
4723             failCount++;
4724         }
4725         if (p.test(&quot;1234&quot;)) {
4726             failCount++;
4727         }
4728         if (!p.test(&quot;word1234&quot;)) {
4729             failCount++;
4730         }
4731         report(&quot;Pattern.asPredicate&quot;);
4732     }
4733 
4734     // This test is for 8184692
4735     private static void patternAsMatchPredicate() throws Exception {
4736         Predicate&lt;String&gt; p = Pattern.compile(&quot;[a-z]+&quot;).asMatchPredicate();
4737 
4738         if (p.test(&quot;&quot;)) {
4739             failCount++;
4740         }
4741         if (!p.test(&quot;word&quot;)) {
4742             failCount++;
4743         }
4744         if (p.test(&quot;1234word&quot;)) {
4745             failCount++;
4746         }
4747         if (p.test(&quot;1234&quot;)) {
4748             failCount++;
4749         }
4750         report(&quot;Pattern.asMatchPredicate&quot;);
4751     }
4752 
4753 
4754     // This test is for 8035975
4755     private static void invalidFlags() throws Exception {
4756         for (int flag = 1; flag != 0; flag &lt;&lt;= 1) {
4757             switch (flag) {
4758             case Pattern.CASE_INSENSITIVE:
4759             case Pattern.MULTILINE:
4760             case Pattern.DOTALL:
4761             case Pattern.UNICODE_CASE:
4762             case Pattern.CANON_EQ:
4763             case Pattern.UNIX_LINES:
4764             case Pattern.LITERAL:
4765             case Pattern.UNICODE_CHARACTER_CLASS:
4766             case Pattern.COMMENTS:
4767                 // valid flag, continue
4768                 break;
4769             default:
4770                 try {
4771                     Pattern.compile(&quot;.&quot;, flag);
4772                     failCount++;
4773                 } catch (IllegalArgumentException expected) {
4774                 }
4775             }
4776         }
4777         report(&quot;Invalid compile flags&quot;);
4778     }
4779 
4780     // This test is for 8158482
4781     private static void embeddedFlags() throws Exception {
4782         try {
4783             Pattern.compile(&quot;(?i).(?-i).&quot;);
4784             Pattern.compile(&quot;(?m).(?-m).&quot;);
4785             Pattern.compile(&quot;(?s).(?-s).&quot;);
4786             Pattern.compile(&quot;(?d).(?-d).&quot;);
4787             Pattern.compile(&quot;(?u).(?-u).&quot;);
4788             Pattern.compile(&quot;(?c).(?-c).&quot;);
4789             Pattern.compile(&quot;(?x).(?-x).&quot;);
4790             Pattern.compile(&quot;(?U).(?-U).&quot;);
4791             Pattern.compile(&quot;(?imsducxU).(?-imsducxU).&quot;);
4792         } catch (PatternSyntaxException x) {
4793             failCount++;
4794         }
4795         report(&quot;Embedded flags&quot;);
4796     }
4797 
4798     private static void grapheme() throws Exception {
4799         Stream.concat(Files.lines(UCDFiles.GRAPHEME_BREAK_TEST),
4800                 Files.lines(Paths.get(System.getProperty(&quot;test.src&quot;, &quot;.&quot;), &quot;GraphemeTestCases.txt&quot;)))
4801             .filter( ln -&gt; ln.length() != 0 &amp;&amp; !ln.startsWith(&quot;#&quot;) )
4802             .forEach( ln -&gt; {
4803                 ln = ln.replaceAll(&quot;\\s+|\\([a-zA-Z]+\\)|\\[[a-zA-Z]]+\\]|#.*&quot;, &quot;&quot;);
4804                 // System.out.println(str);
4805                 String[] strs = ln.split(&quot;\u00f7|\u00d7&quot;);
4806                 StringBuilder src = new StringBuilder();
4807                 ArrayList&lt;String&gt; graphemes = new ArrayList&lt;&gt;();
4808                 StringBuilder buf = new StringBuilder();
4809                 int offBk = 0;
4810                 for (String str : strs) {
4811                     if (str.length() == 0)  // first empty str
4812                         continue;
4813                     int cp = Integer.parseInt(str, 16);
4814                     src.appendCodePoint(cp);
4815                     buf.appendCodePoint(cp);
4816                     offBk += (str.length() + 1);
4817                     if (ln.charAt(offBk) == &#39;\u00f7&#39;) {    // DIV
4818                         graphemes.add(buf.toString());
4819                         buf = new StringBuilder();
4820                     }
4821                 }
4822                 Pattern p = Pattern.compile(&quot;\\X&quot;);
4823                 Matcher m = p.matcher(src.toString());
4824                 Scanner s = new Scanner(src.toString()).useDelimiter(&quot;\\b{g}&quot;);
4825                 for (String g : graphemes) {
4826                     // System.out.printf(&quot;     grapheme:=[%s]%n&quot;, g);
4827                     // (1) test \\X directly
4828                     if (!m.find() || !m.group().equals(g)) {
4829                         System.out.println(&quot;Failed \\X [&quot; + ln + &quot;] : &quot; + g);
4830                         failCount++;
4831                     }
4832                     // (2) test \\b{g} + \\X  via Scanner
4833                     boolean hasNext = s.hasNext(p);
4834                     // if (!s.hasNext() || !s.next().equals(next)) {
4835                     if (!s.hasNext(p) || !s.next(p).equals(g)) {
4836                         System.out.println(&quot;Failed b{g} [&quot; + ln + &quot;] : &quot; + g);
4837                         failCount++;
4838                     }
4839                 }
4840             });
4841         // some sanity checks
4842         if (!Pattern.compile(&quot;\\X{10}&quot;).matcher(&quot;abcdefghij&quot;).matches() ||
4843             !Pattern.compile(&quot;\\b{g}(?:\\X\\b{g}){5}\\b{g}&quot;).matcher(&quot;abcde&quot;).matches() ||
4844             !Pattern.compile(&quot;(?:\\X\\b{g}){2}&quot;).matcher(&quot;\ud800\udc00\ud801\udc02&quot;).matches())
4845             failCount++;
4846         // make sure &quot;\b{n}&quot; still works
4847         if (!Pattern.compile(&quot;\\b{1}hello\\b{1} \\b{1}world\\b{1}&quot;).matcher(&quot;hello world&quot;).matches())
4848             failCount++;
4849         report(&quot;Unicode extended grapheme cluster&quot;);
4850     }
4851 
4852     // hangup/timeout if go into exponential backtracking
4853     private static void expoBacktracking() throws Exception {
4854 
4855         Object[][] patternMatchers = {
4856             // 6328855
4857             { &quot;(.*\n*)*&quot;,
4858               &quot;this little fine string lets\r\njava.lang.String.matches\r\ncrash\r\n(We don&#39;t know why but adding \r* to the regex makes it work again)&quot;,
4859               false },
4860             // 6192895
4861             { &quot; *([a-zA-Z0-9/\\-\\?:\\(\\)\\.,&#39;\\+\\{\\}]+ *)+&quot;,
4862               &quot;Hello World this is a test this is a test this is a test A&quot;,
4863               true },
4864             { &quot; *([a-zA-Z0-9/\\-\\?:\\(\\)\\.,&#39;\\+\\{\\}]+ *)+&quot;,
4865               &quot;Hello World this is a test this is a test this is a test \u4e00 &quot;,
4866               false },
4867             { &quot; *([a-z0-9]+ *)+&quot;,
4868               &quot;hello world this is a test this is a test this is a test A&quot;,
4869               false },
4870             // 4771934 [FIXED] #5013651?
4871             { &quot;^(\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,4})+[,;]?)+$&quot;,
4872               &quot;abc@efg.abc,efg@abc.abc,abc@xyz.mno;abc@sdfsd.com&quot;,
4873               true },
4874             // 4866249 [FIXED]
4875             { &quot;&lt;\\s*&quot; + &quot;(meta|META)&quot; + &quot;(\\s|[^&gt;])+&quot; + &quot;(CHARSET|charset)=&quot; + &quot;(\\s|[^&gt;])+&gt;&quot;,
4876               &quot;&lt;META http-equiv=\&quot;Content-Type\&quot; content=\&quot;text/html; charset=ISO-8859-5\&quot;&gt;&quot;,
4877               true },
4878             { &quot;^(\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,4})+[,;]?)+$&quot;,
4879               &quot;abc@efg.abc,efg@abc.abc,abc@xyz.mno;sdfsd.com&quot;,
4880               false },
4881             // 6345469
4882             { &quot;((&lt;[^&gt;]+&gt;)?(((\\s)?)*(\\&amp;nbsp;)?)*((\\s)?)*)+&quot;,
4883               &quot;&amp;nbsp;&amp;nbsp; &lt; br/&gt; &amp;nbsp; &lt; / p&gt; &lt;p&gt; &lt;html&gt; &lt;adfasfdasdf&gt;&amp;nbsp; &lt;/p&gt;&quot;,
4884               true }, // --&gt; matched
4885             { &quot;((&lt;[^&gt;]+&gt;)?(((\\s)?)*(\\&amp;nbsp;)?)*((\\s)?)*)+&quot;,
4886               &quot;&amp;nbsp;&amp;nbsp; &lt; br/&gt; &amp;nbsp; &lt; / p&gt; &lt;p&gt; &lt;html&gt; &lt;adfasfdasdf&gt;&amp;nbsp; p &lt;/p&gt;&quot;,
4887               false },
4888             // 5026912
4889             { &quot;^\\s*&quot; + &quot;(\\w|\\d|[\\xC0-\\xFF]|/)+&quot; + &quot;\\s+|$&quot;,
4890               &quot;156580451111112225588087755221111111566969655555555&quot;,
4891               false},
4892             // 6988218
4893             { &quot;^([+-]?((0[xX](\\p{XDigit}+))|(((\\p{Digit}+)(\\.)?((\\p{Digit}+)?)([eE][+-]?(\\p{Digit}+))?)|(\\.((\\p{Digit}+))([eE][+-]?(\\p{Digit}+))?)))|[n|N]?&#39;([^&#39;]*(?:&#39;&#39;)*[^&#39;]*)*&#39;)&quot;,
4894               &quot;&#39;%)) order by ANGEBOT.ID&quot;,
4895               false},    // find
4896             // 6693451
4897             { &quot;^(\\s*foo\\s*)*$&quot;,
4898               &quot;foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo&quot;,
4899               true },
4900             { &quot;^(\\s*foo\\s*)*$&quot;,
4901               &quot;foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo fo&quot;,
4902               false
4903             },
4904             // 7006761
4905             { &quot;(([0-9A-Z]+)([_]?+)*)*&quot;, &quot;FOOOOO_BAAAR_FOOOOOOOOO_BA_&quot;, true},
4906             { &quot;(([0-9A-Z]+)([_]?+)*)*&quot;, &quot;FOOOOO_BAAAR_FOOOOOOOOO_BA_ &quot;, false},
4907             // 8140212
4908             { &quot;(?&lt;before&gt;.*)\\{(?&lt;reflection&gt;\\w+):(?&lt;innerMethod&gt;\\w+(\\.?\\w+(\\(((?&lt;args&gt;((&#39;[^&#39;]*&#39;)|((/|\\w)+))(,((&#39;[^&#39;]*&#39;)|((/|\\w)+)))*))?\\))?)*)\\}(?&lt;after&gt;.*)&quot;,
4909               &quot;{CeGlobal:getSodCutoff.getGui.getAmqp.getSimpleModeEnabled()&quot;,
4910               false
4911             },
4912             { &quot;^(a+)+$&quot;, &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;, true},
4913             { &quot;^(a+)+$&quot;, &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa!&quot;, false},
4914 
4915             { &quot;(x+)*y&quot;,  &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxy&quot;, true },
4916             { &quot;(x+)*y&quot;,  &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz&quot;, false},
4917 
4918             { &quot;(x+x+)+y&quot;, &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxy&quot;, true},
4919             { &quot;(x+x+)+y&quot;, &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz&quot;, false},
4920 
4921             { &quot;(([0-9A-Z]+)([_]?+)*)*&quot;, &quot;--------------------------------------&quot;, false},
4922 
4923             /* not fixed
4924             //8132141   ---&gt;    second level exponential backtracking
4925             { &quot;(h|h|ih(((i|a|c|c|a|i|i|j|b|a|i|b|a|a|j))+h)ahbfhba|c|i)*&quot;,
4926               &quot;hchcchicihcchciiicichhcichcihcchiihichiciiiihhcchicchhcihchcihiihciichhccciccichcichiihcchcihhicchcciicchcccihiiihhihihihichicihhcciccchihhhcchichchciihiicihciihcccciciccicciiiiiiiiicihhhiiiihchccchchhhhiiihchihcccchhhiiiiiiiicicichicihcciciihichhhhchihciiihhiccccccciciihhichiccchhicchicihihccichicciihcichccihhiciccccccccichhhhihihhcchchihihiihhihihihicichihiiiihhhhihhhchhichiicihhiiiiihchccccchichci&quot; },
4927             */
4928         };
4929 
4930         for (Object[] pm : patternMatchers) {
4931             String p = (String)pm[0];
4932             String s = (String)pm[1];
4933             boolean r = (Boolean)pm[2];
4934             if (r != Pattern.compile(p).matcher(s).matches()) {
4935                 failCount++;
4936             }
4937         }
4938     }
4939 
4940     private static void invalidGroupName() {
4941         // Invalid start of a group name
4942         for (String groupName : List.of(&quot;&quot;, &quot;.&quot;, &quot;0&quot;, &quot;\u0040&quot;, &quot;\u005b&quot;,
4943                 &quot;\u0060&quot;, &quot;\u007b&quot;, &quot;\u0416&quot;)) {
4944             for (String pat : List.of(&quot;(?&lt;&quot; + groupName + &quot;&gt;)&quot;,
4945                     &quot;\\k&lt;&quot; + groupName + &quot;&gt;&quot;)) {
4946                 try {
4947                     Pattern.compile(pat);
4948                     failCount++;
4949                 } catch (PatternSyntaxException e) {
4950                     if (!e.getMessage().startsWith(
4951                             &quot;capturing group name does not start with a&quot;
4952                             + &quot; Latin letter&quot;)) {
4953                         failCount++;
4954                     }
4955                 }
4956             }
4957         }
4958         // Invalid char in a group name
4959         for (String groupName : List.of(&quot;a.&quot;, &quot;b\u0040&quot;, &quot;c\u005b&quot;,
4960                 &quot;d\u0060&quot;, &quot;e\u007b&quot;, &quot;f\u0416&quot;)) {
4961             for (String pat : List.of(&quot;(?&lt;&quot; + groupName + &quot;&gt;)&quot;,
4962                     &quot;\\k&lt;&quot; + groupName + &quot;&gt;&quot;)) {
4963                 try {
4964                     Pattern.compile(pat);
4965                     failCount++;
4966                 } catch (PatternSyntaxException e) {
4967                     if (!e.getMessage().startsWith(
4968                             &quot;named capturing group is missing trailing &#39;&gt;&#39;&quot;)) {
4969                         failCount++;
4970                     }
4971                 }
4972             }
4973         }
4974         report(&quot;Invalid capturing group names&quot;);
4975     }
4976 
4977     private static void illegalRepetitionRange() {
4978         // huge integers &gt; (2^31 - 1)
4979         String n = BigInteger.valueOf(1L &lt;&lt; 32)
4980             .toString();
4981         String m = BigInteger.valueOf(1L &lt;&lt; 31)
4982             .add(new BigInteger(80, generator))
4983             .toString();
4984         for (String rep : List.of(&quot;&quot;, &quot;x&quot;, &quot;.&quot;, &quot;,&quot;, &quot;-1&quot;, &quot;2,1&quot;,
4985                 n, n + &quot;,&quot;, &quot;0,&quot; + n, n + &quot;,&quot; + m, m, m + &quot;,&quot;, &quot;0,&quot; + m)) {
4986             String pat = &quot;.{&quot; + rep + &quot;}&quot;;
4987             try {
4988                 Pattern.compile(pat);
4989                 failCount++;
4990                 System.out.println(&quot;Expected to fail. Pattern: &quot; + pat);
4991             } catch (PatternSyntaxException e) {
4992                 if (!e.getMessage().startsWith(&quot;Illegal repetition&quot;)) {
4993                     failCount++;
4994                     System.out.println(&quot;Unexpected error message: &quot; + e.getMessage());
4995                 }
4996             } catch (Throwable t) {
4997                 failCount++;
4998                 System.out.println(&quot;Unexpected exception: &quot; + t);
4999             }
5000         }
5001         report(&quot;illegalRepetitionRange&quot;);
5002     }
5003 
5004     private static void surrogatePairWithCanonEq() {
5005         try {
5006             Pattern.compile(&quot;\ud834\udd21&quot;, Pattern.CANON_EQ);
5007         } catch (Throwable t) {
5008             failCount++;
5009             System.out.println(&quot;Unexpected exception: &quot; + t);
5010         }
5011         report(&quot;surrogatePairWithCanonEq&quot;);
5012     }
5013 
5014     // This test is for 8235812
5015     private static void lineBreakWithQuantifier() {
5016         // key:    pattern
5017         // value:  lengths of input that must match the pattern
5018         Map&lt;String, List&lt;Integer&gt;&gt; cases = Map.ofEntries(
5019             Map.entry(&quot;\\R?&quot;,      List.of(0, 1)),
5020             Map.entry(&quot;\\R*&quot;,      List.of(0, 1, 2, 3)),
5021             Map.entry(&quot;\\R+&quot;,      List.of(1, 2, 3)),
5022             Map.entry(&quot;\\R{0}&quot;,    List.of(0)),
5023             Map.entry(&quot;\\R{1}&quot;,    List.of(1)),
5024             Map.entry(&quot;\\R{2}&quot;,    List.of(2)),
5025             Map.entry(&quot;\\R{3}&quot;,    List.of(3)),
5026             Map.entry(&quot;\\R{0,}&quot;,   List.of(0, 1, 2, 3)),
5027             Map.entry(&quot;\\R{1,}&quot;,   List.of(1, 2, 3)),
5028             Map.entry(&quot;\\R{2,}&quot;,   List.of(2, 3)),
5029             Map.entry(&quot;\\R{3,}&quot;,   List.of(3)),
5030             Map.entry(&quot;\\R{0,0}&quot;,  List.of(0)),
5031             Map.entry(&quot;\\R{0,1}&quot;,  List.of(0, 1)),
5032             Map.entry(&quot;\\R{0,2}&quot;,  List.of(0, 1, 2)),
5033             Map.entry(&quot;\\R{0,3}&quot;,  List.of(0, 1, 2, 3)),
5034             Map.entry(&quot;\\R{1,1}&quot;,  List.of(1)),
5035             Map.entry(&quot;\\R{1,2}&quot;,  List.of(1, 2)),
5036             Map.entry(&quot;\\R{1,3}&quot;,  List.of(1, 2, 3)),
5037             Map.entry(&quot;\\R{2,2}&quot;,  List.of(2)),
5038             Map.entry(&quot;\\R{2,3}&quot;,  List.of(2, 3)),
5039             Map.entry(&quot;\\R{3,3}&quot;,  List.of(3)),
5040             Map.entry(&quot;\\R&quot;,       List.of(1)),
5041             Map.entry(&quot;\\R\\R&quot;,    List.of(2)),
5042             Map.entry(&quot;\\R\\R\\R&quot;, List.of(3))
5043         );
5044 
5045         // key:    length of input
5046         // value:  all possible inputs of given length
5047         Map&lt;Integer, List&lt;String&gt;&gt; inputs = new HashMap&lt;&gt;();
5048         String[] Rs = { &quot;\r\n&quot;, &quot;\r&quot;, &quot;\n&quot;,
5049                         &quot;\u000B&quot;, &quot;\u000C&quot;, &quot;\u0085&quot;, &quot;\u2028&quot;, &quot;\u2029&quot; };
5050         StringBuilder sb = new StringBuilder();
5051         for (int len = 0; len &lt;= 3; ++len) {
5052             int[] idx = new int[len + 1];
5053             do {
5054                 sb.setLength(0);
5055                 for (int j = 0; j &lt; len; ++j)
5056                     sb.append(Rs[idx[j]]);
5057                 inputs.computeIfAbsent(len, ArrayList::new).add(sb.toString());
5058                 idx[0]++;
5059                 for (int j = 0; j &lt; len; ++j) {
5060                     if (idx[j] &lt; Rs.length)
5061                         break;
5062                     idx[j] = 0;
5063                     idx[j+1]++;
5064                 }
5065             } while (idx[len] == 0);
5066         }
5067 
5068         // exhaustive testing
5069         for (String patStr : cases.keySet()) {
5070             Pattern[] pats = patStr.endsWith(&quot;R&quot;)
5071                 ? new Pattern[] { Pattern.compile(patStr) }  // no quantifiers
5072                 : new Pattern[] { Pattern.compile(patStr),          // greedy
5073                                   Pattern.compile(patStr + &quot;?&quot;) };  // reluctant
5074             Matcher m = pats[0].matcher(&quot;&quot;);
5075             for (Pattern p : pats) {
5076                 m.usePattern(p);
5077                 for (int len : cases.get(patStr)) {
5078                     for (String in : inputs.get(len)) {
5079                         if (!m.reset(in).matches()) {
5080                             failCount++;
5081                             System.err.println(&quot;Expected to match &#39;&quot; +
5082                                     in + &quot;&#39; =~ /&quot; + p + &quot;/&quot;);
5083                         }
5084                     }
5085                 }
5086             }
5087         }
5088         report(&quot;lineBreakWithQuantifier&quot;);
5089     }
5090 
5091     // This test is for 8214245
5092     private static void caseInsensitivePMatch() {
5093         for (String input : List.of(&quot;abcd&quot;, &quot;AbCd&quot;, &quot;ABCD&quot;)) {
5094             for (String pattern : List.of(&quot;abcd&quot;, &quot;aBcD&quot;, &quot;[a-d]{4}&quot;,
5095                     &quot;(?:a|b|c|d){4}&quot;, &quot;\\p{Lower}{4}&quot;, &quot;\\p{Ll}{4}&quot;,
5096                     &quot;\\p{IsLl}{4}&quot;, &quot;\\p{gc=Ll}{4}&quot;,
5097                     &quot;\\p{general_category=Ll}{4}&quot;, &quot;\\p{IsLowercase}{4}&quot;,
5098                     &quot;\\p{javaLowerCase}{4}&quot;, &quot;\\p{Upper}{4}&quot;, &quot;\\p{Lu}{4}&quot;,
5099                     &quot;\\p{IsLu}{4}&quot;, &quot;\\p{gc=Lu}{4}&quot;, &quot;\\p{general_category=Lu}{4}&quot;,
5100                     &quot;\\p{IsUppercase}{4}&quot;, &quot;\\p{javaUpperCase}{4}&quot;,
5101                     &quot;\\p{Lt}{4}&quot;, &quot;\\p{IsLt}{4}&quot;, &quot;\\p{gc=Lt}{4}&quot;,
5102                     &quot;\\p{general_category=Lt}{4}&quot;, &quot;\\p{IsTitlecase}{4}&quot;,
5103                     &quot;\\p{javaTitleCase}{4}&quot;, &quot;[\\p{Lower}]{4}&quot;, &quot;[\\p{Ll}]{4}&quot;,
5104                     &quot;[\\p{IsLl}]{4}&quot;, &quot;[\\p{gc=Ll}]{4}&quot;,
5105                     &quot;[\\p{general_category=Ll}]{4}&quot;, &quot;[\\p{IsLowercase}]{4}&quot;,
5106                     &quot;[\\p{javaLowerCase}]{4}&quot;, &quot;[\\p{Upper}]{4}&quot;, &quot;[\\p{Lu}]{4}&quot;,
5107                     &quot;[\\p{IsLu}]{4}&quot;, &quot;[\\p{gc=Lu}]{4}&quot;,
5108                     &quot;[\\p{general_category=Lu}]{4}&quot;, &quot;[\\p{IsUppercase}]{4}&quot;,
5109                     &quot;[\\p{javaUpperCase}]{4}&quot;, &quot;[\\p{Lt}]{4}&quot;, &quot;[\\p{IsLt}]{4}&quot;,
5110                     &quot;[\\p{gc=Lt}]{4}&quot;, &quot;[\\p{general_category=Lt}]{4}&quot;,
5111                     &quot;[\\p{IsTitlecase}]{4}&quot;, &quot;[\\p{javaTitleCase}]{4}&quot;))
5112             {
5113                 if (!Pattern.compile(pattern, Pattern.CASE_INSENSITIVE)
5114                             .matcher(input)
5115                             .matches())
5116                 {
5117                     failCount++;
5118                     System.err.println(&quot;Expected to match: &quot; +
5119                                        &quot;&#39;&quot; + input + &quot;&#39; =~ /&quot; + pattern + &quot;/&quot;);
5120                 }
5121             }
5122         }
5123 
5124         for (String input : List.of(&quot;\u01c7&quot;, &quot;\u01c8&quot;, &quot;\u01c9&quot;)) {
5125             for (String pattern : List.of(&quot;\u01c7&quot;, &quot;\u01c8&quot;, &quot;\u01c9&quot;,
5126                     &quot;[\u01c7\u01c8]&quot;, &quot;[\u01c7\u01c9]&quot;, &quot;[\u01c8\u01c9]&quot;,
5127                     &quot;[\u01c7-\u01c8]&quot;, &quot;[\u01c8-\u01c9]&quot;, &quot;[\u01c7-\u01c9]&quot;,
5128                     &quot;\\p{Lower}&quot;, &quot;\\p{Ll}&quot;, &quot;\\p{IsLl}&quot;, &quot;\\p{gc=Ll}&quot;,
5129                     &quot;\\p{general_category=Ll}&quot;, &quot;\\p{IsLowercase}&quot;,
5130                     &quot;\\p{javaLowerCase}&quot;, &quot;\\p{Upper}&quot;, &quot;\\p{Lu}&quot;,
5131                     &quot;\\p{IsLu}&quot;, &quot;\\p{gc=Lu}&quot;, &quot;\\p{general_category=Lu}&quot;,
5132                     &quot;\\p{IsUppercase}&quot;, &quot;\\p{javaUpperCase}&quot;,
5133                     &quot;\\p{Lt}&quot;, &quot;\\p{IsLt}&quot;, &quot;\\p{gc=Lt}&quot;,
5134                     &quot;\\p{general_category=Lt}&quot;, &quot;\\p{IsTitlecase}&quot;,
5135                     &quot;\\p{javaTitleCase}&quot;, &quot;[\\p{Lower}]&quot;, &quot;[\\p{Ll}]&quot;,
5136                     &quot;[\\p{IsLl}]&quot;, &quot;[\\p{gc=Ll}]&quot;,
5137                     &quot;[\\p{general_category=Ll}]&quot;, &quot;[\\p{IsLowercase}]&quot;,
5138                     &quot;[\\p{javaLowerCase}]&quot;, &quot;[\\p{Upper}]&quot;, &quot;[\\p{Lu}]&quot;,
5139                     &quot;[\\p{IsLu}]&quot;, &quot;[\\p{gc=Lu}]&quot;,
5140                     &quot;[\\p{general_category=Lu}]&quot;, &quot;[\\p{IsUppercase}]&quot;,
5141                     &quot;[\\p{javaUpperCase}]&quot;, &quot;[\\p{Lt}]&quot;, &quot;[\\p{IsLt}]&quot;,
5142                     &quot;[\\p{gc=Lt}]&quot;, &quot;[\\p{general_category=Lt}]&quot;,
5143                     &quot;[\\p{IsTitlecase}]&quot;, &quot;[\\p{javaTitleCase}]&quot;))
5144             {
5145                 if (!Pattern.compile(pattern, Pattern.CASE_INSENSITIVE
5146                                             | Pattern.UNICODE_CHARACTER_CLASS)
5147                             .matcher(input)
5148                             .matches())
5149                 {
5150                     failCount++;
5151                     System.err.println(&quot;Expected to match: &quot; +
5152                                        &quot;&#39;&quot; + input + &quot;&#39; =~ /&quot; + pattern + &quot;/&quot;);
5153                 }
5154             }
5155         }
5156         report(&quot;caseInsensitivePMatch&quot;);
5157     }
5158 }
    </pre>
  </body>
</html>
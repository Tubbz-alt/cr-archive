<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/jdk/nio/zipfs/testng/test/ManifestOrderTest.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 package test;
 25 
 26 import org.testng.annotations.BeforeSuite;
 27 import org.testng.annotations.Test;
 28 import util.ZipFsBaseTest;
 29 
 30 import java.io.InputStream;
 31 import java.io.OutputStream;
 32 import java.nio.file.*;
 33 import java.util.Arrays;
 34 import java.util.HashMap;
 35 import java.util.Map;
 36 import java.util.jar.*;
 37 import java.util.jar.Attributes.Name;
 38 import java.util.spi.ToolProvider;
 39 import java.util.stream.Collectors;
 40 import java.util.zip.ZipEntry;
 41 
 42 import static org.testng.Assert.*;
 43 
 44 /**
 45  * @test
 46  * @bug 8211917
 47  * @summary Validate that Zip FS will always add META-INF/MANIFEST.MF to the
 48  * beginning of a Zip file allowing the Manifest be found and processed
 49  * by java.util.jar.JarInputStream.
 50 
 51  */
 52 public class ManifestOrderTest extends ZipFsBaseTest {
 53 
 54     // Manifest PATH within a JAR
 55     public static final String MANIFEST_NAME = &quot;META-INF/MANIFEST.MF&quot;;
 56 
 57     // Manifests used by the tests
 58     private static String MANIFEST_ENTRY;
 59     private static String MANIFEST_ENTRY2;
 60 
 61     // Manifest Attributes used by the tests
 62     private static Map&lt;Name, String&gt; MANIFEST_ATTRS;
 63     private static Map&lt;Name, String&gt; MANIFEST_ATTRS2;
 64 
 65     //  Used when the test does not expect to find a Manifest
 66     private static final Map&lt;Name, String&gt; NO_ATTRIBUTES = Map.of();
 67 
 68     // JAR Tool via ToolProvider API
 69     private static final ToolProvider JAR_TOOL = ToolProvider.findFirst(&quot;jar&quot;)
 70             .orElseThrow(() -&gt; new RuntimeException(&quot;jar tool not found&quot;)
 71             );
 72 
 73     /**
 74      * Create the Manifests and Map of attributes included in the Manifests
 75      */
 76     @BeforeSuite
 77     public void setup() {
 78         String jdkVendor = System.getProperty(&quot;java.vendor&quot;);
 79         String jdkVersion = System.getProperty(&quot;java.version&quot;);
 80         String attributeKey = &quot;Player&quot;;
 81         String attributeValue = &quot;Rafael Nadal&quot;;
 82         String attributeKey2 = &quot;Country&quot;;
 83         String attributeValue2 = &quot;Spain&quot;;
 84         String jdkVendorVersion = jdkVersion + &quot; (&quot; + jdkVendor + &quot;)&quot;;
 85         MANIFEST_ENTRY = &quot;Manifest-Version: 1.0&quot;
 86                 + System.lineSeparator()
 87                 + &quot;Created-By: &quot; + jdkVendorVersion
 88                 + System.lineSeparator()
 89                 + attributeKey + &quot;: &quot; + attributeValue
 90                 + System.lineSeparator();
 91         MANIFEST_ENTRY2 = MANIFEST_ENTRY
 92                 + attributeKey2 + &quot;: &quot; + attributeValue2
 93                 + System.lineSeparator();
 94 
 95         MANIFEST_ATTRS =
 96                 Map.of(Name.MANIFEST_VERSION, &quot;1.0&quot;,
 97                         new Name(&quot;Created-By&quot;), jdkVendorVersion,
 98                         new Name(attributeKey), attributeValue);
 99         MANIFEST_ATTRS2 = new HashMap&lt;&gt;();
100         MANIFEST_ATTRS.forEach(MANIFEST_ATTRS2::put);
101         MANIFEST_ATTRS2.put(new Name(attributeKey2), attributeValue2);
102     }
103 
104     /**
105      * Validate that JarInputStream can find META-INF/MANIFEST.MF when its written
106      * as the first entry within a JAR using Zip FS
107      *
108      * @param env         Zip FS properties to use when creating the Zip File
109      * @param compression The compression used when writing the entries
110      * @throws Exception If an error occurs
111      */
112     @Test(dataProvider = &quot;zipfsMap&quot;)
113     public void testJarWithManifestAddedFirst(final Map&lt;String, String&gt; env,
114                                               final int compression)
115             throws Exception {
116         final Path jarPath = generatePath(HERE, &quot;test&quot;, &quot;.jar&quot;);
117         Files.deleteIfExists(jarPath);
118         // Create the initial JAR writing out the Manifest first
119         final Entry[] entries = newEntries(compression);
120         Entry manifest = Entry.of(MANIFEST_NAME, compression, MANIFEST_ENTRY);
121         zip(jarPath, env, manifest, entries[0], entries[1], entries[2]);
122         verify(jarPath, MANIFEST_ATTRS, compression, entries);
123 
124         // Add an additional entry and re-verify
125         Entry e00 = Entry.of(&quot;Entry-00&quot;, compression, &quot;Roger Federer&quot;);
126         zip(jarPath, Map.of(&quot;noCompression&quot;, compression == ZipEntry.STORED),
127                 e00);
128         verify(jarPath, MANIFEST_ATTRS, compression, entries[0], entries[1],
129                 entries[2], e00);
130     }
131 
132     /**
133      * Validate that JarInputStream can find META-INF/MANIFEST.MF when its written
134      * as the last entry within a JAR using Zip FS
135      *
136      * @param env         Zip FS properties to use when creating the Zip File
137      * @param compression The compression used when writing the entries
138      * @throws Exception If an error occurs
139      */
140     @Test(dataProvider = &quot;zipfsMap&quot;)
141     public void testJarWithManifestAddedLast(final Map&lt;String, String&gt; env,
142                                              final int compression) throws Exception {
143         final Path jarPath = generatePath(HERE, &quot;test&quot;, &quot;.jar&quot;);
144         Files.deleteIfExists(jarPath);
145         // Create the initial JAR writing out the Manifest last
146         final Entry[] entries = newEntries(compression);
147         Entry manifest = Entry.of(MANIFEST_NAME, compression, MANIFEST_ENTRY);
148         zip(jarPath, env, entries[0], entries[1], entries[2], manifest);
149         verify(jarPath, MANIFEST_ATTRS, compression, entries);
150 
151         // Add an additional entry and re-verify
152         Entry e00 = Entry.of(&quot;Entry-00&quot;, compression, &quot;Roger Federer&quot;);
153         zip(jarPath, Map.of(&quot;noCompression&quot;, compression == ZipEntry.STORED),
154                 e00);
155         verify(jarPath, MANIFEST_ATTRS, compression, entries[0], entries[1],
156                 entries[2], e00);
157     }
158 
159     /**
160      * Validate that JarInputStream can find META-INF/MANIFEST.MF when its written
161      * between other entries within a JAR using Zip FS
162      *
163      * @param env         Zip FS properties to use when creating the Zip File
164      * @param compression The compression used when writing the entries
165      * @throws Exception If an error occurs
166      */
167     @Test(dataProvider = &quot;zipfsMap&quot;)
168     public void testJarWithManifestAddedInBetween(final Map&lt;String, String&gt; env,
169                                                   final int compression)
170             throws Exception {
171         final Path jarPath = generatePath(HERE, &quot;test&quot;, &quot;.jar&quot;);
172         Files.deleteIfExists(jarPath);
173         // Create the initial JAR writing out the Manifest in between other entries
174         final Entry[] entries = newEntries(compression);
175         Entry manifest = Entry.of(MANIFEST_NAME, compression, MANIFEST_ENTRY);
176         zip(jarPath, env, entries[0], entries[1], manifest, entries[2]);
177         verify(jarPath, MANIFEST_ATTRS, compression, entries);
178 
179         // Add an additional entry and re-verify
180         Entry e00 = Entry.of(&quot;Entry-00&quot;, compression, &quot;Roger Federer&quot;);
181         zip(jarPath, Map.of(&quot;noCompression&quot;, compression == ZipEntry.STORED),
182                 e00);
183         verify(jarPath, MANIFEST_ATTRS, compression, entries[0], entries[1],
184                 entries[2], e00);
185     }
186 
187     /**
188      * Validate that JarInputStream can read all entries from a JAR created
189      * using Zip FS without adding a Manifest
190      *
191      * @param env         Zip FS properties to use when creating the Zip File
192      * @param compression The compression used when writing the entries
193      * @throws Exception If an error occurs
194      */
195     @Test(dataProvider = &quot;zipfsMap&quot;)
196     public void testJarWithNoManifest(final Map&lt;String, String&gt; env,
197                                       final int compression) throws Exception {
198         final Path jarPath = generatePath(HERE, &quot;test&quot;, &quot;.jar&quot;);
199         Files.deleteIfExists(jarPath);
200         // Create the initial JAR writing without a Manifest
201         final Entry[] entries = newEntries(compression);
202         zip(jarPath, env, entries[0], entries[1], entries[2]);
203         verify(jarPath, NO_ATTRIBUTES, compression, entries);
204 
205         // Add an additional entry and re-verify
206         Entry e00 = Entry.of(&quot;Entry-00&quot;, compression, &quot;Roger Federer&quot;);
207         zip(jarPath, Map.of(&quot;noCompression&quot;, compression == ZipEntry.STORED),
208                 e00);
209         verify(jarPath, NO_ATTRIBUTES, compression, entries[0], entries[1],
210                 entries[2], e00);
211     }
212 
213     /**
214      * Validate that JarInputStream can read META-INF/MANIFEST.MF when the
215      * the Manfiest is copied to the JAR using Files::copy
216      *
217      * @param env         Zip FS properties to use when creating the Zip File
218      * @param compression The compression used when writing the entries
219      * @throws Exception If an error occurs
220      */
221     @Test(dataProvider = &quot;zipfsMap&quot;)
222     public void testManifestCopiedFromOSFile(final Map&lt;String, String&gt; env,
223                                              final int compression) throws Exception {
224         final Path jarPath = generatePath(HERE, &quot;test&quot;, &quot;.jar&quot;);
225         Files.deleteIfExists(jarPath);
226         final Path manifest = Paths.get(&quot;.&quot;, &quot;test-MANIFEST.MF&quot;);
227         Files.deleteIfExists(manifest);
228 
229         // Create initial JAR without a Manifest
230         Files.writeString(manifest, MANIFEST_ENTRY);
231         final Entry[] entries = newEntries(compression);
232         zip(jarPath, env, entries[0], entries[1], entries[2]);
233         verify(jarPath, NO_ATTRIBUTES, compression, entries);
234 
235         // Add the Manifest via Files::copy and verify
236         try (FileSystem zipfs =
237                      FileSystems.newFileSystem(jarPath, env)) {
238             Files.copy(manifest, zipfs.getPath(&quot;META-INF&quot;, &quot;MANIFEST.MF&quot;));
239         }
240         verify(jarPath, MANIFEST_ATTRS, compression, entries);
241     }
242 
243     /**
244      * Validate that JarInputStream can find META-INF/MANIFEST.MF when the
245      * entries are copied from one JAR to another JAR using Zip FS and Files::copy
246      *
247      * @param env         Zip FS properties to use when creating the Zip File
248      * @param compression The compression used when writing the entries
249      * @throws Exception If an error occurs
250      */
251     @Test(dataProvider = &quot;zipfsMap&quot;)
252     public void copyJarToJarTest(final Map&lt;String, String&gt; env, final int compression)
253             throws Exception {
254         final Path jarPath = generatePath(HERE, &quot;test&quot;, &quot;.jar&quot;);
255         final Path jarPath2 = generatePath(HERE, &quot;test&quot;, &quot;.jar&quot;);
256         Files.deleteIfExists(jarPath);
257         Files.deleteIfExists(jarPath2);
258 
259         // Create initial JAR with a Manifest
260         final Entry[] entries = newEntries(compression);
261         Entry manifest = Entry.of(MANIFEST_NAME, compression, MANIFEST_ENTRY);
262         zip(jarPath, env, manifest, entries[0], entries[1], entries[2]);
263         verify(jarPath, MANIFEST_ATTRS, compression, entries);
264 
265         // Create the another JAR via Files::copy and verify
266         try (FileSystem zipfs = FileSystems.newFileSystem(jarPath, env);
267              FileSystem zipfsTarget = FileSystems.newFileSystem(jarPath2,
268                      Map.of(&quot;create&quot;, &quot;true&quot;, &quot;noCompression&quot;,
269                              compression == ZipEntry.STORED))) {
270             Path mPath = zipfsTarget.getPath(manifest.name);
271             if (mPath.getParent() != null) {
272                 Files.createDirectories(mPath.getParent());
273             }
274             Files.copy(zipfs.getPath(manifest.name), mPath);
275             for (Entry e : entries) {
276                 Path target = zipfsTarget.getPath(e.name);
277                 if (target.getParent() != null) {
278                     Files.createDirectories(target.getParent());
279                 }
280                 Files.copy(zipfs.getPath(e.name), target);
281             }
282         }
283         verify(jarPath2, MANIFEST_ATTRS, compression, entries);
284     }
285 
286     /**
287      * Validate a JAR created using the jar tool and is updated using Zip FS
288      * contains the expected entries and Manifest
289      *
290      * @param compression The compression used when writing the entries
291      * @throws Exception If an error occurs
292      */
293     @Test(dataProvider = &quot;compressionMethods&quot;)
294     public void testJarToolGeneratedJarWithManifest(final int compression)
295             throws Exception {
296 
297         final Path jarPath = generatePath(HERE, &quot;test&quot;, &quot;.jar&quot;);
298         Files.deleteIfExists(jarPath);
299         final Entry[] entries = newEntries(compression);
300         final Path tmpdir = Paths.get(&quot;tmp&quot;);
301         rmdir(tmpdir);
302         Files.createDirectory(tmpdir);
303         // Create a directory to hold the files to bad added to the JAR
304         for (final Entry entry : entries) {
305             Path p = Path.of(&quot;tmp&quot;, entry.name);
306             if (p.getParent() != null) {
307                 Files.createDirectories(p.getParent());
308             }
309             Files.write(Path.of(&quot;tmp&quot;, entry.name), entry.bytes);
310         }
311         // Create a file containing the Manifest
312         final Path manifestFile = Paths.get(&quot;.&quot;, &quot;test-jar-MANIFEST.MF&quot;);
313         Files.deleteIfExists(manifestFile);
314         Files.writeString(manifestFile, MANIFEST_ENTRY);
315 
316         // Create a JAR via the jar tool and verify
317         final int exitCode = JAR_TOOL.run(System.out, System.err, &quot;cvfm&quot;
318                         + (compression == ZipEntry.STORED ? &quot;0&quot; : &quot;&quot;),
319                 jarPath.getFileName().toString(),
320                 manifestFile.toAbsolutePath().toString(),
321                 &quot;-C&quot;, tmpdir.toAbsolutePath().toString(), &quot;.&quot;);
322         assertEquals(exitCode, 0, &quot;jar tool exited with failure&quot;);
323         verify(jarPath, MANIFEST_ATTRS, compression, entries);
324 
325         // Add an additional entry and re-verify
326         Entry e00 = Entry.of(&quot;Entry-00&quot;, compression, &quot;Roger Federer&quot;);
327         zip(jarPath, Map.of(&quot;noCompression&quot;, compression == ZipEntry.STORED),
328                 entries[0], entries[1], e00, entries[2]);
329         verify(jarPath, MANIFEST_ATTRS, compression, entries[0], entries[1],
330                 e00, entries[2]);
331     }
332 
333     /**
334      * Validate that JarInputStream can read all entries from a JAR created
335      * using Zip FS with a Manifest created by java.util.jar.Manifest
336      *
337      * @param env         Zip FS properties to use when creating the Zip File
338      * @param compression The compression used when writing the entries
339      * @throws Exception If an error occurs
340      */
341     @Test(dataProvider = &quot;zipfsMap&quot;)
342     public void createWithManifestTest(final Map&lt;String, String&gt; env,
343                                        final int compression) throws Exception {
344         Path jarPath = generatePath(HERE, &quot;test&quot;, &quot;.jar&quot;);
345         Files.deleteIfExists(jarPath);
346 
347         // Create the JAR and verify
348         Entry e00 = Entry.of(&quot;Entry-00&quot;, compression, &quot;Indian Wells&quot;);
349         try (FileSystem zipfs = FileSystems.newFileSystem(jarPath, env)) {
350             // Add our Manifest using Manifest::write
351             Path manifestPath = zipfs.getPath(&quot;META-INF&quot;, &quot;MANIFEST.MF&quot;);
352             if (manifestPath.getParent() != null) {
353                 Files.createDirectories(manifestPath.getParent());
354             }
355             try (final OutputStream os = Files.newOutputStream(manifestPath)) {
356                 final Manifest manifest = new Manifest();
357                 final Attributes attributes = manifest.getMainAttributes();
358                 // Populate the Manifest Attributes
359                 MANIFEST_ATTRS.forEach(attributes::put);
360                 manifest.write(os);
361             }
362             Files.write(zipfs.getPath(e00.name), e00.bytes);
363 
364         }
365         verify(jarPath, MANIFEST_ATTRS, compression, e00);
366     }
367 
368     /**
369      * Validate that JarInputStream can find META-INF/MANIFEST.MF when it has
370      * been updated by Zip FS
371      *
372      * @param env         Zip FS properties to use when creating the Zip File
373      * @param compression The compression used when writing the entries
374      * @throws Exception If an error occurs
375      */
376     @Test(dataProvider = &quot;zipfsMap&quot;)
377     public void updateManifestTest(final Map&lt;String, String&gt; env,
378                                    final int compression) throws Exception {
379         final Path jarPath = generatePath(HERE, &quot;test&quot;, &quot;.jar&quot;);
380         Files.deleteIfExists(jarPath);
381         // Create the initial JAR with a Manifest
382         final Entry[] entries = newEntries(compression);
383         Entry manifest = Entry.of(MANIFEST_NAME, compression, MANIFEST_ENTRY);
384         zip(jarPath, env, manifest, entries[0], entries[1], entries[2]);
385         verify(jarPath, MANIFEST_ATTRS, compression, entries);
386 
387         // Add an additional entry, update the Manifest and re-verify
388         Entry e00 = Entry.of(&quot;Entry-00&quot;, compression, &quot;Roger Federer&quot;);
389         Entry revisedManifest = manifest.content(MANIFEST_ENTRY2);
390         zip(jarPath, Map.of(&quot;noCompression&quot;, compression == ZipEntry.STORED),
391                 revisedManifest, e00);
392         verify(jarPath, MANIFEST_ATTRS2, compression, entries[0], entries[1],
393                 entries[2], e00);
394     }
395 
396     /**
397      * Create an Entry array used when creating a JAR using Zip FS
398      *
399      * @param compressionMethod The compression method used by the test
400      * @return the Entry array
401      */
402     private static Entry[] newEntries(final int compressionMethod) {
403         return new Entry[]{new Entry(&quot;hello.txt&quot;, compressionMethod, &quot;hello&quot;),
404                 new Entry(&quot;META-INF/bar/world.txt&quot;, compressionMethod, &quot;world&quot;),
405                 new Entry(&quot;META-INF/greeting.txt&quot;, compressionMethod, &quot;greeting&quot;)};
406     }
407 
408     /**
409      * Verify the entries including the Manifest in a JAR
410      *
411      * @param jar         Path to the JAR
412      * @param attributes  A Map containing the attributes expected in the Manifest;
413      *                    otherwise empty
414      * @param entries     Entries to validate in the JAR
415      * @param compression The compression used when writing the entries
416      * @throws Exception If an error occurs
417      */
418     private static void verify(final Path jar, final Map&lt;?, ?&gt; attributes,
419                                final int compression, Entry... entries)
420             throws Exception {
421         // If the compression method is not STORED, then use JarInputStream
422         // to validate the entries in the JAR.  The current JAR/ZipInputStream
423         // implementation supports PKZIP version 2.04g which only supports
424         // bit 8 for DEFLATED entries(JDK-8143613).  Zip FS will set this bit
425         // for STORED entries as is now allowed by the PKZIP spec, resulting
426         // in the error &quot;only DEFLATED entries can have EXT descriptor&quot;
427         if (ZipEntry.STORED != compression) {
428             try (final JarInputStream jis =
429                          new JarInputStream(Files.newInputStream(jar))) {
430                 // Verify the Manifest
431                 validateManifest(attributes, jis.getManifest());
432                 // Verify the rest of the expected entries are present
433                 final Map&lt;String, Entry&gt; expected = Arrays.stream(entries)
434                         .collect(Collectors.toMap(entry -&gt; entry.name, entry -&gt; entry));
435                 JarEntry je = jis.getNextJarEntry();
436                 assertNotNull(je, &quot;Jar is empty&quot;);
437                 while (je != null) {
438                     if (je.isDirectory()) {
439                         // skip directories
440                         je = jis.getNextJarEntry();
441                         continue;
442                     }
443                     final Entry e = expected.remove(je.getName());
444                     assertNotNull(e, &quot;Unexpected entry in jar &quot;);
445                     assertEquals(je.getMethod(), e.method, &quot;Compression method mismatch&quot;);
446                     assertEquals(jis.readAllBytes(), e.bytes);
447 
448                     je = jis.getNextJarEntry();
449                 }
450                 assertEquals(expected.size(), 0, &quot;Missing entries in jar!&quot;);
451             }
452         }
453 
454         // Verify using JarFile
455         try (final JarFile jf = new JarFile(jar.toFile())) {
456             // Validate Manifest
457             validateManifest(attributes, jf.getManifest());
458             for (Entry e : entries) {
459                 JarEntry je = jf.getJarEntry(e.name);
460                 assertNotNull(je, &quot;Entry does not exist&quot;);
461                 if (DEBUG) {
462                     System.out.printf(&quot;Entry Name: %s, method: %s, Expected Method: %s%n&quot;,
463                             e.name, je.getMethod(), e.method);
464                 }
465                 assertEquals(e.method, je.getMethod(), &quot;Compression methods mismatch&quot;);
466                 try (InputStream in = jf.getInputStream(je)) {
467                     byte[] bytes = in.readAllBytes();
468                     if (DEBUG) {
469                         System.out.printf(&quot;bytes= %s, actual=%s%n&quot;,
470                                 new String(bytes), new String(e.bytes));
471                     }
472                     assertTrue(Arrays.equals(bytes, e.bytes), &quot;Entries do not match&quot;);
473                 }
474             }
475         }
476 
477         // Check entries with FileSystem API
478         try (FileSystem fs = FileSystems.newFileSystem(jar)) {
479             // Check entry count
480             Path top = fs.getPath(&quot;/&quot;);
481             long count = Files.find(top, Integer.MAX_VALUE,
482                     (path, attrs) -&gt; attrs.isRegularFile()).count();
483             assertEquals(entries.length + (!attributes.isEmpty() ? 1 : 0), count);
484             Path mf = fs.getPath(&quot;META-INF&quot;, &quot;MANIFEST.MF&quot;);
485             Manifest m = null;
486 
487             if (!attributes.isEmpty()) {
488                 assertTrue(Files.exists(mf));
489                 m = new Manifest(Files.newInputStream(mf));
490             }
491             validateManifest(attributes, m);
492 
493             // Check content of each entry
494             for (Entry e : entries) {
495                 Path file = fs.getPath(e.name);
496                 if (DEBUG) {
497                     System.out.printf(&quot;Entry name = %s, bytes= %s, actual=%s%n&quot;, e.name,
498                             new String(Files.readAllBytes(file)), new String(e.bytes));
499                 }
500                 assertEquals(Files.readAllBytes(file), e.bytes);
501             }
502         }
503     }
504 
505     /**
506      * Validate whether the Manifest contains the expected attributes
507      *
508      * @param attributes A Map containing the attributes expected in the Manifest;
509      *                   otherwise empty
510      * @param m          The Manifest to validate
511      */
512     private static void validateManifest(Map&lt;?, ?&gt; attributes, Manifest m) {
513         if (!attributes.isEmpty()) {
514             assertNotNull(m, &quot;Manifest is missing!&quot;);
515             Attributes attrs = m.getMainAttributes();
516             attributes.forEach((k, v) -&gt;
517             {
518                 if (DEBUG) {
519                     System.out.printf(&quot;Key: %s, Value: %s%n&quot;, k, v);
520                 }
521                 assertTrue(attrs.containsKey(k));
522                 assertEquals(v, attrs.get(k));
523             });
524         } else {
525             assertNull(m, &quot;Manifest was found!&quot;);
526         }
527     }
528 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames make/jdk/src/classes/build/tools/cldrconverter/Bundle.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package build.tools.cldrconverter;
 27 
 28 import java.util.ArrayList;
 29 import java.util.Arrays;
 30 import java.util.EnumSet;
 31 import java.util.HashMap;
 32 import java.util.Iterator;
 33 import java.util.List;
 34 import java.util.Map;
 35 import java.util.Objects;
 36 import java.util.Optional;
 37 import java.util.stream.IntStream;
 38 
 39 class Bundle {
 40     static enum Type {
 41         LOCALENAMES, CURRENCYNAMES, TIMEZONENAMES, CALENDARDATA, FORMATDATA;
 42 
 43         static EnumSet&lt;Type&gt; ALL_TYPES = EnumSet.of(LOCALENAMES,
 44                                                     CURRENCYNAMES,
 45                                                     TIMEZONENAMES,
 46                                                     CALENDARDATA,
 47                                                     FORMATDATA);
 48     }
 49 
 50     private final static Map&lt;String, Bundle&gt; bundles = new HashMap&lt;&gt;();
 51 
 52     private final static String[] NUMBER_PATTERN_KEYS = {
 53         &quot;NumberPatterns/decimal&quot;,
 54         &quot;NumberPatterns/currency&quot;,
 55         &quot;NumberPatterns/percent&quot;,
 56         &quot;NumberPatterns/accounting&quot;
 57     };
 58 
 59     private final static String[] COMPACT_NUMBER_PATTERN_KEYS = {
 60             &quot;short.CompactNumberPatterns&quot;,
 61             &quot;long.CompactNumberPatterns&quot;
 62     };
 63 
 64     private final static String[] NUMBER_ELEMENT_KEYS = {
 65         &quot;NumberElements/decimal&quot;,
 66         &quot;NumberElements/group&quot;,
 67         &quot;NumberElements/list&quot;,
 68         &quot;NumberElements/percent&quot;,
 69         &quot;NumberElements/zero&quot;,
 70         &quot;NumberElements/pattern&quot;,
 71         &quot;NumberElements/minus&quot;,
 72         &quot;NumberElements/exponential&quot;,
 73         &quot;NumberElements/permille&quot;,
 74         &quot;NumberElements/infinity&quot;,
 75         &quot;NumberElements/nan&quot;,
 76         &quot;NumberElements/currencyDecimal&quot;,
 77         &quot;NumberElements/currencyGroup&quot;,
 78     };
 79 
 80     private final static String[] TIME_PATTERN_KEYS = {
 81         &quot;DateTimePatterns/full-time&quot;,
 82         &quot;DateTimePatterns/long-time&quot;,
 83         &quot;DateTimePatterns/medium-time&quot;,
 84         &quot;DateTimePatterns/short-time&quot;,
 85     };
 86 
 87     private final static String[] DATE_PATTERN_KEYS = {
 88         &quot;DateTimePatterns/full-date&quot;,
 89         &quot;DateTimePatterns/long-date&quot;,
 90         &quot;DateTimePatterns/medium-date&quot;,
 91         &quot;DateTimePatterns/short-date&quot;,
 92     };
 93 
 94     private final static String[] DATETIME_PATTERN_KEYS = {
 95         &quot;DateTimePatterns/full-dateTime&quot;,
 96         &quot;DateTimePatterns/long-dateTime&quot;,
 97         &quot;DateTimePatterns/medium-dateTime&quot;,
 98         &quot;DateTimePatterns/short-dateTime&quot;,
 99     };
100 
101     private final static String[] ERA_KEYS = {
102         &quot;long.Eras&quot;,
103         &quot;Eras&quot;,
104         &quot;narrow.Eras&quot;
105     };
106 
107     // Keys for individual time zone names
108     private final static String TZ_GEN_LONG_KEY = &quot;timezone.displayname.generic.long&quot;;
109     private final static String TZ_GEN_SHORT_KEY = &quot;timezone.displayname.generic.short&quot;;
110     private final static String TZ_STD_LONG_KEY = &quot;timezone.displayname.standard.long&quot;;
111     private final static String TZ_STD_SHORT_KEY = &quot;timezone.displayname.standard.short&quot;;
112     private final static String TZ_DST_LONG_KEY = &quot;timezone.displayname.daylight.long&quot;;
113     private final static String TZ_DST_SHORT_KEY = &quot;timezone.displayname.daylight.short&quot;;
114     private final static String[] ZONE_NAME_KEYS = {
115         TZ_STD_LONG_KEY,
116         TZ_STD_SHORT_KEY,
117         TZ_DST_LONG_KEY,
118         TZ_DST_SHORT_KEY,
119         TZ_GEN_LONG_KEY,
120         TZ_GEN_SHORT_KEY
121     };
122 
123     private final String id;
124     private final String cldrPath;
125     private final EnumSet&lt;Type&gt; bundleTypes;
126     private final String currencies;
127     private Map&lt;String, Object&gt; targetMap;
128 
129     static Bundle getBundle(String id) {
130         return bundles.get(id);
131     }
132 
133     @SuppressWarnings(&quot;ConvertToStringSwitch&quot;)
134     Bundle(String id, String cldrPath, String bundles, String currencies) {
135         this.id = id;
136         this.cldrPath = cldrPath;
137         if (&quot;localenames&quot;.equals(bundles)) {
138             bundleTypes = EnumSet.of(Type.LOCALENAMES);
139         } else if (&quot;currencynames&quot;.equals(bundles)) {
140             bundleTypes = EnumSet.of(Type.CURRENCYNAMES);
141         } else {
142             bundleTypes = Type.ALL_TYPES;
143         }
144         if (currencies == null) {
145             currencies = &quot;local&quot;;
146         }
147         this.currencies = currencies;
148         addBundle();
149     }
150 
151     private void addBundle() {
152         Bundle.bundles.put(id, this);
153     }
154 
155     String getID() {
156         return id;
157     }
158 
159     String getJavaID() {
160         // Tweak ISO compatibility for bundle generation
161         return id.replaceFirst(&quot;^he&quot;, &quot;iw&quot;)
162             .replaceFirst(&quot;^id&quot;, &quot;in&quot;)
163             .replaceFirst(&quot;^yi&quot;, &quot;ji&quot;);
164     }
165 
166     boolean isRoot() {
167         return &quot;root&quot;.equals(id);
168     }
169 
170     String getCLDRPath() {
171         return cldrPath;
172     }
173 
174     EnumSet&lt;Type&gt; getBundleTypes() {
175         return bundleTypes;
176     }
177 
178     String getCurrencies() {
179         return currencies;
180     }
181 
182     /**
183      * Generate a map that contains all the data that should be
184      * visible for the bundle&#39;s locale
185      */
186     Map&lt;String, Object&gt; getTargetMap() throws Exception {
187         if (targetMap != null) {
188             return targetMap;
189         }
190 
191         String[] cldrBundles = getCLDRPath().split(&quot;,&quot;);
192 
193         // myMap contains resources for id.
194         Map&lt;String, Object&gt; myMap = new HashMap&lt;&gt;();
195         int index;
196         for (index = 0; index &lt; cldrBundles.length; index++) {
197             if (cldrBundles[index].equals(id)) {
198                 myMap.putAll(CLDRConverter.getCLDRBundle(cldrBundles[index]));
199                 break;
200             }
201         }
202 
203         // parentsMap contains resources from id&#39;s parents.
204         Map&lt;String, Object&gt; parentsMap = new HashMap&lt;&gt;();
205         for (int i = cldrBundles.length - 1; i &gt; index; i--) {
206             if (!(&quot;no&quot;.equals(cldrBundles[i]) || cldrBundles[i].startsWith(&quot;no_&quot;))) {
207                 parentsMap.putAll(CLDRConverter.getCLDRBundle(cldrBundles[i]));
208             }
209         }
210         // Duplicate myMap as parentsMap for &quot;root&quot; so that the
211         // fallback works. This is a hack, though.
212         if (&quot;root&quot;.equals(cldrBundles[0])) {
213             assert parentsMap.isEmpty();
214             parentsMap.putAll(myMap);
215         }
216 
217         // merge individual strings into arrays
218 
219         // if myMap has any of the NumberPatterns/NumberElements members, create a
220         // complete array of patterns/elements.
221         @SuppressWarnings(&quot;unchecked&quot;)
222         List&lt;String&gt; scripts = (List&lt;String&gt;) myMap.get(&quot;numberingScripts&quot;);
223         if (scripts != null) {
224             for (String script : scripts) {
225                 myMap.put(script + &quot;.NumberPatterns&quot;,
226                         createNumberArray(myMap, parentsMap, NUMBER_PATTERN_KEYS, script));
227                 myMap.put(script + &quot;.NumberElements&quot;,
228                         createNumberArray(myMap, parentsMap, NUMBER_ELEMENT_KEYS, script));
229             }
230         }
231 
232         for (String k : COMPACT_NUMBER_PATTERN_KEYS) {
233             List&lt;String&gt; patterns = (List&lt;String&gt;) myMap.remove(k);
234             if (patterns != null) {
235                 // Convert the map value from List&lt;String&gt; to String[], replacing any missing
236                 // entry from the parents map, if any.
237                 final List&lt;String&gt; pList = (List&lt;String&gt;)parentsMap.get(k);
238                 int size = patterns.size();
239                 int psize = pList != null ? pList.size() : 0;
240                 String[] arrPatterns = IntStream.range(0, Math.max(size, psize))
241                     .mapToObj(i -&gt; {
242                         String pattern;
243                         // first try itself.
244                         if (i &lt; size) {
245                             pattern = patterns.get(i);
246                             if (!pattern.isEmpty()) {
247                                 return &quot;{&quot; + pattern + &quot;}&quot;;
248                             }
249                         }
250                         // if not found, try parent
251                         if (i &lt; psize) {
252                             pattern = pList.get(i);
253                             if (!pattern.isEmpty()) {
254                                 return &quot;{&quot; + pattern + &quot;}&quot;;
255                             }
256                         }
257                         // bail out with empty string
258                         return &quot;&quot;;
259                     })
260                     .toArray(String[]::new);
261                 myMap.put(k, arrPatterns);
262             }
263         }
264 
265         // Processes aliases here
266         CLDRConverter.handleAliases(myMap);
267 
268         // another hack: parentsMap is not used for date-time resources.
269         if (&quot;root&quot;.equals(id)) {
270             parentsMap = null;
271         }
272 
273         for (CalendarType calendarType : CalendarType.values()) {
274             String calendarPrefix = calendarType.keyElementName();
275             // handle multiple inheritance for month and day names
276             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;MonthNames&quot;);
277             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;MonthAbbreviations&quot;);
278             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;MonthNarrows&quot;);
279             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;DayNames&quot;);
280             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;DayAbbreviations&quot;);
281             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;DayNarrows&quot;);
282             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;AmPmMarkers&quot;);
283             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;narrow.AmPmMarkers&quot;);
284             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;abbreviated.AmPmMarkers&quot;);
285             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;QuarterNames&quot;);
286             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;QuarterAbbreviations&quot;);
287             handleMultipleInheritance(myMap, parentsMap, calendarPrefix + &quot;QuarterNarrows&quot;);
288 
<a name="1" id="anc1"></a><span class="line-modified">289             adjustEraNames(myMap, parentsMap, calendarType);</span>
290 
291             handleDateTimeFormatPatterns(TIME_PATTERN_KEYS, myMap, parentsMap, calendarType, &quot;TimePatterns&quot;);
292             handleDateTimeFormatPatterns(DATE_PATTERN_KEYS, myMap, parentsMap, calendarType, &quot;DatePatterns&quot;);
293             handleDateTimeFormatPatterns(DATETIME_PATTERN_KEYS, myMap, parentsMap, calendarType, &quot;DateTimePatterns&quot;);
294         }
295 
296         // First, weed out any empty timezone or metazone names from myMap.
<a name="2" id="anc2"></a>
297         for (Iterator&lt;String&gt; it = myMap.keySet().iterator(); it.hasNext();) {
298             String key = it.next();
299             if (key.startsWith(CLDRConverter.TIMEZONE_ID_PREFIX)
300                     || key.startsWith(CLDRConverter.METAZONE_ID_PREFIX)) {
301                 @SuppressWarnings(&quot;unchecked&quot;)
302                 Map&lt;String, String&gt; nameMap = (Map&lt;String, String&gt;) myMap.get(key);
303                 if (nameMap.isEmpty()) {
304                     // Some zones have only exemplarCity, which become empty.
305                     // Remove those from the map.
306                     it.remove();
307                     continue;
308                 }
<a name="3" id="anc3"></a>



309             }
310         }
311         for (Iterator&lt;String&gt; it = myMap.keySet().iterator(); it.hasNext();) {
312             String key = it.next();
313                 if (key.startsWith(CLDRConverter.TIMEZONE_ID_PREFIX)
314                     || key.startsWith(CLDRConverter.METAZONE_ID_PREFIX)) {
315                 @SuppressWarnings(&quot;unchecked&quot;)
316                 Map&lt;String, String&gt; nameMap = (Map&lt;String, String&gt;) myMap.get(key);
317 
318                 // Convert key/value pairs to an array.
319                 String[] names = new String[ZONE_NAME_KEYS.length];
320                 int ix = 0;
321                 for (String nameKey : ZONE_NAME_KEYS) {
322                     String name = nameMap.get(nameKey);
323                     if (name == null &amp;&amp; parentsMap != null) {
324                         @SuppressWarnings(&quot;unchecked&quot;)
325                         Map&lt;String, String&gt; parentNames = (Map&lt;String, String&gt;) parentsMap.get(key);
326                         if (parentNames != null) {
327                             name = parentNames.get(nameKey);
328                         }
329                     }
330                     names[ix++] = name;
331                 }
332                 if (hasNulls(names)) {
333                     String metaKey = toMetaZoneKey(key);
334                     if (metaKey != null) {
335                         Object obj = myMap.get(metaKey);
336                         if (obj instanceof String[]) {
337                             String[] metaNames = (String[]) obj;
338                             for (int i = 0; i &lt; names.length; i++) {
339                                 if (names[i] == null) {
340                                     names[i] = metaNames[i];
341                                 }
342                             }
343                         } else if (obj instanceof Map) {
344                             @SuppressWarnings(&quot;unchecked&quot;)
345                             Map&lt;String, String&gt; m = (Map&lt;String, String&gt;) obj;
346                             for (int i = 0; i &lt; names.length; i++) {
347                                 if (names[i] == null) {
348                                     names[i] = m.get(ZONE_NAME_KEYS[i]);
349                                 }
350                             }
351                         }
352                     }
353                 }
354                 // replace the Map with the array
355                 if (names != null) {
356                     myMap.put(key, names);
357                 } else {
358                     it.remove();
359                 }
360             }
361         }
362         // replace empty era names with parentMap era names
363         for (String key : ERA_KEYS) {
364             Object value = myMap.get(key);
365             if (value != null &amp;&amp; value instanceof String[]) {
366                 String[] eraStrings = (String[]) value;
367                 for (String eraString : eraStrings) {
368                     if (eraString == null || eraString.isEmpty()) {
369                         fillInElements(parentsMap, key, value);
370                     }
371                 }
372             }
373         }
374 
375         // Remove all duplicates
376         if (Objects.nonNull(parentsMap)) {
377             for (Iterator&lt;String&gt; it = myMap.keySet().iterator(); it.hasNext();) {
378                 String key = it.next();
379                 if (!key.equals(&quot;numberingScripts&quot;) &amp;&amp; // real body &quot;NumberElements&quot; may differ
380                     Objects.deepEquals(parentsMap.get(key), myMap.get(key))) {
381                     it.remove();
382                 }
383             }
384         }
385 
386         targetMap = myMap;
387         return myMap;
388     }
389 
390     private void handleMultipleInheritance(Map&lt;String, Object&gt; map, Map&lt;String, Object&gt; parents, String key) {
391         String formatMapKey = key + &quot;/format&quot;;
392         Object format = map.get(formatMapKey);
393         if (format != null) {
394             map.remove(formatMapKey);
395             map.put(key, format);
396             if (fillInElements(parents, formatMapKey, format)) {
397                 map.remove(key);
398             }
399         }
400         String standaloneMapKey = key + &quot;/stand-alone&quot;;
401         Object standalone = map.get(standaloneMapKey);
402         if (standalone != null) {
403             map.remove(standaloneMapKey);
404             String standaloneResourceKey = &quot;standalone.&quot; + key;
405             map.put(standaloneResourceKey, standalone);
406             if (fillInElements(parents, standaloneMapKey, standalone)) {
407                 map.remove(standaloneResourceKey);
408             }
409         }
410     }
411 
412     /**
<a name="4" id="anc4"></a><span class="line-modified">413      * Fills in any empty elements with its parent element, falling back to</span>
<span class="line-modified">414      * aliased one if parent element is not found. Returns true if the resulting</span>
<span class="line-added">415      * array is identical to its parent array.</span>
416      *
417      * @param parents
418      * @param key
419      * @param value
420      * @return true if the resulting array is identical to its parent array.
421      */
422     private boolean fillInElements(Map&lt;String, Object&gt; parents, String key, Object value) {
423         if (parents == null) {
424             return false;
425         }
426         if (value instanceof String[]) {
<a name="5" id="anc5"></a><span class="line-modified">427             Object pvalue = parents.getOrDefault(key, parents.get(CLDRConverter.aliases.get(key)));</span>
428             if (pvalue != null &amp;&amp; pvalue instanceof String[]) {
429                 String[] strings = (String[]) value;
430                 String[] pstrings = (String[]) pvalue;
431                 for (int i = 0; i &lt; strings.length; i++) {
432                     if (strings[i] == null || strings[i].length() == 0) {
433                         strings[i] = pstrings[i];
434                     }
435                 }
436                 return Arrays.equals(strings, pstrings);
437             }
438         }
439         return false;
440     }
441 
442     /*
443      * Adjusts String[] for era names because JRE&#39;s Calendars use different
444      * ERA value indexes in the Buddhist, Japanese Imperial, and Islamic calendars.
445      */
<a name="6" id="anc6"></a><span class="line-modified">446     private void adjustEraNames(Map&lt;String, Object&gt; map, Map&lt;String, Object&gt; pMap, CalendarType type) {</span>
447         String[][] eraNames = new String[ERA_KEYS.length][];
448         String[] realKeys = new String[ERA_KEYS.length];
449         int index = 0;
450         for (String key : ERA_KEYS) {
451             String realKey = type.keyElementName() + key;
452             String[] value = (String[]) map.get(realKey);
453             if (value != null) {
<a name="7" id="anc7"></a><span class="line-added">454                 // first fill in missing elements from parents map.</span>
<span class="line-added">455                 fillInElements(pMap, realKey, value);</span>
<span class="line-added">456 </span>
457                 switch (type) {
458                 case GREGORIAN:
459                     break;
460 
461                 case JAPANESE:
462                     {
463                         String[] newValue = new String[value.length + 1];
464                         String[] julianEras = (String[]) map.get(key);
465                         if (julianEras != null &amp;&amp; julianEras.length &gt;= 2) {
466                             newValue[0] = julianEras[1];
467                         } else {
468                             newValue[0] = &quot;&quot;;
469                         }
470                         System.arraycopy(value, 0, newValue, 1, value.length);
471                         value = newValue;
472 
473                         // fix up &#39;Reiwa&#39; era, which can be missing in some locales
474                         if (value[value.length - 1] == null) {
475                             value[value.length - 1] = (key.startsWith(&quot;narrow.&quot;) ? &quot;R&quot; : &quot;Reiwa&quot;);
476                         }
477                     }
478                     break;
479 
480                 case BUDDHIST:
481                     // Replace the value
482                     value = new String[] {&quot;BC&quot;, value[0]};
483                     break;
484 
485                 case ISLAMIC:
486                     // Replace the value
487                     value = new String[] {&quot;&quot;, value[0]};
488                     break;
489                 }
490                 if (!key.equals(realKey)) {
491                     map.put(realKey, value);
492                     map.put(&quot;java.time.&quot; + realKey, value);
493                 }
494             }
495             realKeys[index] = realKey;
496             eraNames[index++] = value;
497         }
498         for (int i = 0; i &lt; eraNames.length; i++) {
499             if (eraNames[i] == null) {
500                 map.put(realKeys[i], null);
501             }
502         }
503     }
504 
505     private void handleDateTimeFormatPatterns(String[] patternKeys, Map&lt;String, Object&gt; myMap, Map&lt;String, Object&gt; parentsMap,
506                                               CalendarType calendarType, String name) {
507         String calendarPrefix = calendarType.keyElementName();
508         for (String k : patternKeys) {
509             if (myMap.containsKey(calendarPrefix + k)) {
510                 int len = patternKeys.length;
511                 List&lt;String&gt; dateTimePatterns = new ArrayList&lt;&gt;(len);
512                 List&lt;String&gt; sdfPatterns = new ArrayList&lt;&gt;(len);
513                 for (int i = 0; i &lt; len; i++) {
514                     String key = calendarPrefix + patternKeys[i];
515                     String pattern = (String) myMap.remove(key);
516                     if (pattern == null) {
517                         pattern = (String) parentsMap.remove(key);
518                     }
519                     if (pattern != null) {
520                         // Perform date-time format pattern conversion which is
521                         // applicable to both SimpleDateFormat and j.t.f.DateTimeFormatter.
522                         // For example, character &#39;B&#39; is mapped with &#39;a&#39;, as &#39;B&#39; is not
523                         // supported in either SimpleDateFormat or j.t.f.DateTimeFormatter
524                         String transPattern = translateDateFormatLetters(calendarType, pattern, this::convertDateTimePatternLetter);
525                         dateTimePatterns.add(i, transPattern);
526                         // Additionally, perform SDF specific date-time format pattern conversion
527                         sdfPatterns.add(i, translateDateFormatLetters(calendarType, transPattern, this::convertSDFLetter));
528                     } else {
529                         dateTimePatterns.add(i, null);
530                         sdfPatterns.add(i, null);
531                     }
532                 }
533                 // If empty, discard patterns
534                 if (sdfPatterns.isEmpty()) {
535                     return;
536                 }
537                 String key = calendarPrefix + name;
538 
539                 // If additional changes are made in the SDF specific conversion,
540                 // keep the commonly converted patterns as java.time patterns
541                 if (!dateTimePatterns.equals(sdfPatterns)) {
542                     myMap.put(&quot;java.time.&quot; + key, dateTimePatterns.toArray(String[]::new));
543                 }
544                 myMap.put(key, sdfPatterns.toArray(new String[len]));
545                 break;
546             }
547         }
548     }
549 
550     private String translateDateFormatLetters(CalendarType calendarType, String cldrFormat, ConvertDateTimeLetters converter) {
551         String pattern = cldrFormat;
552         int length = pattern.length();
553         boolean inQuote = false;
554         StringBuilder jrePattern = new StringBuilder(length);
555         int count = 0;
556         char lastLetter = 0;
557 
558         for (int i = 0; i &lt; length; i++) {
559             char c = pattern.charAt(i);
560 
561             if (c == &#39;\&#39;&#39;) {
562                 // &#39;&#39; is treated as a single quote regardless of being
563                 // in a quoted section.
564                 if ((i + 1) &lt; length) {
565                     char nextc = pattern.charAt(i + 1);
566                     if (nextc == &#39;\&#39;&#39;) {
567                         i++;
568                         if (count != 0) {
569                             converter.convert(calendarType, lastLetter, count, jrePattern);
570                             lastLetter = 0;
571                             count = 0;
572                         }
573                         jrePattern.append(&quot;&#39;&#39;&quot;);
574                         continue;
575                     }
576                 }
577                 if (!inQuote) {
578                     if (count != 0) {
579                         converter.convert(calendarType, lastLetter, count, jrePattern);
580                         lastLetter = 0;
581                         count = 0;
582                     }
583                     inQuote = true;
584                 } else {
585                     inQuote = false;
586                 }
587                 jrePattern.append(c);
588                 continue;
589             }
590             if (inQuote) {
591                 jrePattern.append(c);
592                 continue;
593             }
594             if (!(c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39; || c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;)) {
595                 if (count != 0) {
596                     converter.convert(calendarType, lastLetter, count, jrePattern);
597                     lastLetter = 0;
598                     count = 0;
599                 }
600                 jrePattern.append(c);
601                 continue;
602             }
603 
604             if (lastLetter == 0 || lastLetter == c) {
605                 lastLetter = c;
606                 count++;
607                 continue;
608             }
609             converter.convert(calendarType, lastLetter, count, jrePattern);
610             lastLetter = c;
611             count = 1;
612         }
613 
614         if (inQuote) {
615             throw new InternalError(&quot;Unterminated quote in date-time pattern: &quot; + cldrFormat);
616         }
617 
618         if (count != 0) {
619             converter.convert(calendarType, lastLetter, count, jrePattern);
620         }
621         if (cldrFormat.contentEquals(jrePattern)) {
622             return cldrFormat;
623         }
624         return jrePattern.toString();
625     }
626 
627     private String toMetaZoneKey(String tzKey) {
628         if (tzKey.startsWith(CLDRConverter.TIMEZONE_ID_PREFIX)) {
629             String tz = tzKey.substring(CLDRConverter.TIMEZONE_ID_PREFIX.length());
630             String meta = CLDRConverter.handlerMetaZones.get(tz);
631             if (meta != null) {
632                 return CLDRConverter.METAZONE_ID_PREFIX + meta;
633             }
634         }
635         return null;
636     }
637 
<a name="8" id="anc8"></a>



































638     /**
639      * Perform a generic conversion of CLDR date-time format pattern letter based
640      * on the support given by the SimpleDateFormat and the j.t.f.DateTimeFormatter
641      * for date-time formatting.
642      */
643     private void convertDateTimePatternLetter(CalendarType calendarType, char cldrLetter, int count, StringBuilder sb) {
644         switch (cldrLetter) {
645             case &#39;u&#39;:
646                 // Change cldr letter &#39;u&#39; to &#39;y&#39;, as &#39;u&#39; is interpreted as
647                 // &quot;Extended year (numeric)&quot; in CLDR/LDML,
648                 // which is not supported in SimpleDateFormat and
649                 // j.t.f.DateTimeFormatter, so it is replaced with &#39;y&#39;
650                 // as the best approximation
651                 appendN(&#39;y&#39;, count, sb);
652                 break;
653             case &#39;B&#39;:
654                 // &#39;B&#39; character (day period) is not supported by
655                 // SimpleDateFormat and j.t.f.DateTimeFormatter,
656                 // this is a workaround in which &#39;B&#39; character
657                 // appearing in CLDR date-time pattern is replaced
658                 // with &#39;a&#39; character and hence resolved with am/pm strings.
659                 // This workaround is based on the the fallback mechanism
660                 // specified in LDML spec for &#39;B&#39; character, when a locale
661                 // does not have data for day period (&#39;B&#39;)
662                 appendN(&#39;a&#39;, count, sb);
663                 break;
664             default:
665                 appendN(cldrLetter, count, sb);
666                 break;
667 
668         }
669     }
670 
671     /**
672      * Perform a conversion of CLDR date-time format pattern letter which is
673      * specific to the SimpleDateFormat.
674      */
675     private void convertSDFLetter(CalendarType calendarType, char cldrLetter, int count, StringBuilder sb) {
676         switch (cldrLetter) {
677             case &#39;G&#39;:
678                 if (calendarType != CalendarType.GREGORIAN) {
679                     // Adjust the number of &#39;G&#39;s for JRE SimpleDateFormat
680                     if (count == 5) {
681                         // CLDR narrow -&gt; JRE short
682                         count = 1;
683                     } else if (count == 1) {
684                         // CLDR abbr -&gt; JRE long
685                         count = 4;
686                     }
687                 }
688                 appendN(cldrLetter, count, sb);
689                 break;
690 
691             // TODO: support &#39;c&#39; and &#39;e&#39; in JRE SimpleDateFormat
692             // Use &#39;u&#39; and &#39;E&#39; for now.
693             case &#39;c&#39;:
694             case &#39;e&#39;:
695                 switch (count) {
696                     case 1:
697                         sb.append(&#39;u&#39;);
698                         break;
699                     case 3:
700                     case 4:
701                         appendN(&#39;E&#39;, count, sb);
702                         break;
703                     case 5:
704                         appendN(&#39;E&#39;, 3, sb);
705                         break;
706                 }
707                 break;
708 
709             case &#39;v&#39;:
710             case &#39;V&#39;:
711                 appendN(&#39;z&#39;, count, sb);
712                 break;
713 
714             case &#39;Z&#39;:
715                 if (count == 4 || count == 5) {
716                     sb.append(&quot;XXX&quot;);
717                 }
718                 break;
719 
720             default:
721                 appendN(cldrLetter, count, sb);
722                 break;
723         }
724     }
725 
726     private void appendN(char c, int n, StringBuilder sb) {
727         for (int i = 0; i &lt; n; i++) {
728             sb.append(c);
729         }
730     }
731 
732     private static boolean hasNulls(Object[] array) {
733         for (int i = 0; i &lt; array.length; i++) {
734             if (array[i] == null) {
735                 return true;
736             }
737         }
738         return false;
739     }
740 
741     @FunctionalInterface
742     private interface ConvertDateTimeLetters {
743         void convert(CalendarType calendarType, char cldrLetter, int count, StringBuilder sb);
744     }
745 
746     /**
747      * Returns a complete string array for NumberElements or NumberPatterns. If any
748      * array element is missing, it will fall back to parents map, as well as
749      * numbering script fallback.
750      */
751     private String[] createNumberArray(Map&lt;String, Object&gt; myMap, Map&lt;String, Object&gt;parentsMap,
752                                         String[] keys, String script) {
753         String[] numArray = new String[keys.length];
754         for (int i = 0; i &lt; keys.length; i++) {
755             String key = script + &quot;.&quot; + keys[i];
756             final int idx = i;
757             Optional.ofNullable(
758                 myMap.getOrDefault(key,
759                     // if value not found in myMap, search for parentsMap
760                     parentsMap.getOrDefault(key,
761                         parentsMap.getOrDefault(keys[i],
762                             // the last resort is &quot;latn&quot;
763                             parentsMap.get(&quot;latn.&quot; + keys[i])))))
764                 .ifPresentOrElse(v -&gt; numArray[idx] = (String)v, () -&gt; {
765                     if (keys == NUMBER_PATTERN_KEYS) {
766                         // NumberPatterns
767                         if (!key.endsWith(&quot;accounting&quot;)) {
768                             // throw error unless it is for &quot;accounting&quot;,
769                             // which may be missing.
770                             throw new InternalError(&quot;NumberPatterns: null for &quot; +
771                                                     key + &quot;, id: &quot; + id);
772                         }
773                     } else {
774                         // NumberElements
775                         assert keys == NUMBER_ELEMENT_KEYS;
776                         if (key.endsWith(&quot;/pattern&quot;)) {
777                             numArray[idx] = &quot;#&quot;;
778                         } else if (!key.endsWith(&quot;currencyDecimal&quot;) &amp;&amp;
779                                    !key.endsWith(&quot;currencyGroup&quot;)) {
780                             // throw error unless it is for &quot;currencyDecimal/Group&quot;,
781                             // which may be missing.
782                             throw new InternalError(&quot;NumberElements: null for &quot; +
783                                                     key + &quot;, id: &quot; + id);
784                         }
785                     }});
786         }
787         return numArray;
788     }
789 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames make/jdk/src/classes/build/tools/cldrconverter/CLDRConverter.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package build.tools.cldrconverter;
  27 
<a name="2" id="anc2"></a><span class="line-removed">  28 import static build.tools.cldrconverter.Bundle.jreTimeZoneNames;</span>
  29 import build.tools.cldrconverter.BundleGenerator.BundleType;
  30 import java.io.File;
  31 import java.io.IOException;
  32 import java.io.UncheckedIOException;
  33 import java.nio.file.*;
  34 import java.text.MessageFormat;
  35 import java.time.*;
  36 import java.util.*;
  37 import java.util.ResourceBundle.Control;
  38 import java.util.logging.Level;
  39 import java.util.logging.Logger;
  40 import java.util.stream.Collectors;
  41 import java.util.stream.IntStream;
  42 import java.util.stream.Stream;
  43 import javax.xml.parsers.SAXParser;
  44 import javax.xml.parsers.SAXParserFactory;
  45 import org.xml.sax.SAXNotRecognizedException;
  46 import org.xml.sax.SAXNotSupportedException;
  47 
  48 
  49 /**
  50  * Converts locale data from &quot;Locale Data Markup Language&quot; format to
  51  * JRE resource bundle format. LDML is the format used by the Common
  52  * Locale Data Repository maintained by the Unicode Consortium.
  53  */
  54 public class CLDRConverter {
  55 
  56     static final String LDML_DTD_SYSTEM_ID = &quot;http://www.unicode.org/cldr/dtd/2.0/ldml.dtd&quot;;
  57     static final String SPPL_LDML_DTD_SYSTEM_ID = &quot;http://www.unicode.org/cldr/dtd/2.0/ldmlSupplemental.dtd&quot;;
  58     static final String BCP47_LDML_DTD_SYSTEM_ID = &quot;http://www.unicode.org/cldr/dtd/2.0/ldmlBCP47.dtd&quot;;
  59 
  60 
  61     private static String CLDR_BASE;
  62     static String LOCAL_LDML_DTD;
  63     static String LOCAL_SPPL_LDML_DTD;
  64     static String LOCAL_BCP47_LDML_DTD;
  65     private static String SOURCE_FILE_DIR;
  66     private static String SPPL_SOURCE_FILE;
  67     private static String SPPL_META_SOURCE_FILE;
  68     private static String NUMBERING_SOURCE_FILE;
  69     private static String METAZONES_SOURCE_FILE;
  70     private static String LIKELYSUBTAGS_SOURCE_FILE;
  71     private static String TIMEZONE_SOURCE_FILE;
  72     private static String WINZONES_SOURCE_FILE;
  73     private static String PLURALS_SOURCE_FILE;
  74     static String DESTINATION_DIR = &quot;build/gensrc&quot;;
  75 
  76     static final String LOCALE_NAME_PREFIX = &quot;locale.displayname.&quot;;
  77     static final String LOCALE_SEPARATOR = LOCALE_NAME_PREFIX + &quot;separator&quot;;
  78     static final String LOCALE_KEYTYPE = LOCALE_NAME_PREFIX + &quot;keytype&quot;;
  79     static final String LOCALE_KEY_PREFIX = LOCALE_NAME_PREFIX + &quot;key.&quot;;
  80     static final String LOCALE_TYPE_PREFIX = LOCALE_NAME_PREFIX + &quot;type.&quot;;
  81     static final String LOCALE_TYPE_PREFIX_CA = LOCALE_TYPE_PREFIX + &quot;ca.&quot;;
  82     static final String CURRENCY_SYMBOL_PREFIX = &quot;currency.symbol.&quot;;
  83     static final String CURRENCY_NAME_PREFIX = &quot;currency.displayname.&quot;;
  84     static final String CALENDAR_NAME_PREFIX = &quot;calendarname.&quot;;
  85     static final String CALENDAR_FIRSTDAY_PREFIX = &quot;firstDay.&quot;;
  86     static final String CALENDAR_MINDAYS_PREFIX = &quot;minDays.&quot;;
  87     static final String TIMEZONE_ID_PREFIX = &quot;timezone.id.&quot;;
  88     static final String EXEMPLAR_CITY_PREFIX = &quot;timezone.excity.&quot;;
  89     static final String ZONE_NAME_PREFIX = &quot;timezone.displayname.&quot;;
  90     static final String METAZONE_ID_PREFIX = &quot;metazone.id.&quot;;
  91     static final String PARENT_LOCALE_PREFIX = &quot;parentLocale.&quot;;
<a name="3" id="anc3"></a>
  92     static final String[] EMPTY_ZONE = {&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;};
<a name="4" id="anc4"></a>
  93 
  94     private static SupplementDataParseHandler handlerSuppl;
  95     private static LikelySubtagsParseHandler handlerLikelySubtags;
  96     private static WinZonesParseHandler handlerWinZones;
  97     static PluralsParseHandler handlerPlurals;
  98     static SupplementalMetadataParseHandler handlerSupplMeta;
  99     static NumberingSystemsParseHandler handlerNumbering;
 100     static MetaZonesParseHandler handlerMetaZones;
 101     static TimeZoneParseHandler handlerTimeZone;
 102     private static BundleGenerator bundleGenerator;
 103 
 104     // java.base module related
 105     static boolean isBaseModule = false;
 106     static final Set&lt;Locale&gt; BASE_LOCALES = new HashSet&lt;&gt;();
 107 
 108     // &quot;parentLocales&quot; map
 109     private static final Map&lt;String, SortedSet&lt;String&gt;&gt; parentLocalesMap = new HashMap&lt;&gt;();
 110     private static final ResourceBundle.Control defCon =
 111         ResourceBundle.Control.getControl(ResourceBundle.Control.FORMAT_DEFAULT);
 112 
 113     private static Set&lt;String&gt; AVAILABLE_TZIDS;
 114     private static String zoneNameTempFile;
 115     private static String tzDataDir;
 116     private static final Map&lt;String, String&gt; canonicalTZMap = new HashMap&lt;&gt;();
 117 
 118     static enum DraftType {
 119         UNCONFIRMED,
 120         PROVISIONAL,
 121         CONTRIBUTED,
 122         APPROVED;
 123 
 124         private static final Map&lt;String, DraftType&gt; map = new HashMap&lt;&gt;();
 125         static {
 126             for (DraftType dt : values()) {
 127                 map.put(dt.getKeyword(), dt);
 128             }
 129         }
 130         static private DraftType defaultType = CONTRIBUTED;
 131 
 132         private final String keyword;
 133 
 134         private DraftType() {
 135             keyword = this.name().toLowerCase(Locale.ROOT);
 136 
 137         }
 138 
 139         static DraftType forKeyword(String keyword) {
 140             return map.get(keyword);
 141         }
 142 
 143         static DraftType getDefault() {
 144             return defaultType;
 145         }
 146 
 147         static void setDefault(String keyword) {
 148             defaultType = Objects.requireNonNull(forKeyword(keyword));
 149         }
 150 
 151         String getKeyword() {
 152             return keyword;
 153         }
 154     }
 155 
 156     static boolean USE_UTF8 = false;
 157     private static boolean verbose;
 158 
 159     private CLDRConverter() {
 160        // no instantiation
 161     }
 162 
 163     @SuppressWarnings(&quot;AssignmentToForLoopParameter&quot;)
 164     public static void main(String[] args) throws Exception {
 165         if (args.length != 0) {
 166             String currentArg = null;
 167             try {
 168                 for (int i = 0; i &lt; args.length; i++) {
 169                     currentArg = args[i];
 170                     switch (currentArg) {
 171                     case &quot;-draft&quot;:
 172                         String draftDataType = args[++i];
 173                         try {
 174                             DraftType.setDefault(draftDataType);
 175                         } catch (NullPointerException e) {
 176                             severe(&quot;Error: incorrect draft value: %s%n&quot;, draftDataType);
 177                             System.exit(1);
 178                         }
 179                         info(&quot;Using the specified data type: %s%n&quot;, draftDataType);
 180                         break;
 181 
 182                     case &quot;-base&quot;:
 183                         // base directory for input files
 184                         CLDR_BASE = args[++i];
 185                         if (!CLDR_BASE.endsWith(&quot;/&quot;)) {
 186                             CLDR_BASE += &quot;/&quot;;
 187                         }
 188                         break;
 189 
 190                     case &quot;-baselocales&quot;:
 191                         // base locales
 192                         setupBaseLocales(args[++i]);
 193                         break;
 194 
 195                     case &quot;-basemodule&quot;:
 196                         // indicates java.base module resource generation
 197                         isBaseModule = true;
 198                         break;
 199 
 200                     case &quot;-o&quot;:
 201                         // output directory
 202                         DESTINATION_DIR = args[++i];
 203                         break;
 204 
 205                     case &quot;-utf8&quot;:
 206                         USE_UTF8 = true;
 207                         break;
 208 
 209                     case &quot;-verbose&quot;:
 210                         verbose = true;
 211                         break;
 212 
 213                     case &quot;-zntempfile&quot;:
 214                         zoneNameTempFile = args[++i];
 215                         break;
 216 
 217                     case &quot;-tzdatadir&quot;:
 218                         tzDataDir = args[++i];
 219                         break;
 220 
 221                     case &quot;-help&quot;:
 222                         usage();
 223                         System.exit(0);
 224                         break;
 225 
 226                     default:
 227                         throw new RuntimeException();
 228                     }
 229                 }
 230             } catch (RuntimeException e) {
 231                 severe(&quot;unknown or imcomplete arg(s): &quot; + currentArg);
 232                 usage();
 233                 System.exit(1);
 234             }
 235         }
 236 
 237         // Set up path names
 238         LOCAL_LDML_DTD = CLDR_BASE + &quot;/dtd/ldml.dtd&quot;;
 239         LOCAL_SPPL_LDML_DTD = CLDR_BASE + &quot;/dtd/ldmlSupplemental.dtd&quot;;
 240         LOCAL_BCP47_LDML_DTD = CLDR_BASE + &quot;/dtd/ldmlBCP47.dtd&quot;;
 241         SOURCE_FILE_DIR = CLDR_BASE + &quot;/main&quot;;
 242         SPPL_SOURCE_FILE = CLDR_BASE + &quot;/supplemental/supplementalData.xml&quot;;
 243         LIKELYSUBTAGS_SOURCE_FILE = CLDR_BASE + &quot;/supplemental/likelySubtags.xml&quot;;
 244         NUMBERING_SOURCE_FILE = CLDR_BASE + &quot;/supplemental/numberingSystems.xml&quot;;
 245         METAZONES_SOURCE_FILE = CLDR_BASE + &quot;/supplemental/metaZones.xml&quot;;
 246         TIMEZONE_SOURCE_FILE = CLDR_BASE + &quot;/bcp47/timezone.xml&quot;;
 247         SPPL_META_SOURCE_FILE = CLDR_BASE + &quot;/supplemental/supplementalMetadata.xml&quot;;
 248         WINZONES_SOURCE_FILE = CLDR_BASE + &quot;/supplemental/windowsZones.xml&quot;;
 249         PLURALS_SOURCE_FILE = CLDR_BASE + &quot;/supplemental/plurals.xml&quot;;
 250 
 251         if (BASE_LOCALES.isEmpty()) {
 252             setupBaseLocales(&quot;en-US&quot;);
 253         }
 254 
 255         bundleGenerator = new ResourceBundleGenerator();
 256 
 257         // Parse data independent of locales
 258         parseSupplemental();
 259         parseBCP47();
 260 
 261         List&lt;Bundle&gt; bundles = readBundleList();
 262         convertBundles(bundles);
 263 
 264         if (isBaseModule) {
 265             // Generate java.time.format.ZoneName.java
 266             generateZoneName();
 267 
 268             // Generate Windows tzmappings
 269             generateWindowsTZMappings();
 270 
 271             // Generate Plural rules
 272             generatePluralRules();
 273         }
 274     }
 275 
 276     private static void usage() {
 277         errout(&quot;Usage: java CLDRConverter [options]%n&quot;
 278                 + &quot;\t-help          output this usage message and exit%n&quot;
 279                 + &quot;\t-verbose       output information%n&quot;
 280                 + &quot;\t-draft [contributed | approved | provisional | unconfirmed]%n&quot;
 281                 + &quot;\t\t       draft level for using data (default: contributed)%n&quot;
 282                 + &quot;\t-base dir      base directory for CLDR input files%n&quot;
 283                 + &quot;\t-basemodule    generates bundles that go into java.base module%n&quot;
 284                 + &quot;\t-baselocales loc(,loc)*      locales that go into the base module%n&quot;
 285                 + &quot;\t-o dir         output directory (default: ./build/gensrc)%n&quot;
 286                 + &quot;\t-zntempfile    template file for java.time.format.ZoneName.java%n&quot;
 287                 + &quot;\t-tzdatadir     tzdata directory for java.time.format.ZoneName.java%n&quot;
 288                 + &quot;\t-utf8          use UTF-8 rather than \\uxxxx (for debug)%n&quot;);
 289     }
 290 
 291     static void info(String fmt, Object... args) {
 292         if (verbose) {
 293             System.out.printf(fmt, args);
 294         }
 295     }
 296 
 297     static void info(String msg) {
 298         if (verbose) {
 299             System.out.println(msg);
 300         }
 301     }
 302 
 303     static void warning(String fmt, Object... args) {
 304         System.err.print(&quot;Warning: &quot;);
 305         System.err.printf(fmt, args);
 306     }
 307 
 308     static void warning(String msg) {
 309         System.err.print(&quot;Warning: &quot;);
 310         errout(msg);
 311     }
 312 
 313     static void severe(String fmt, Object... args) {
 314         System.err.print(&quot;Error: &quot;);
 315         System.err.printf(fmt, args);
 316     }
 317 
 318     static void severe(String msg) {
 319         System.err.print(&quot;Error: &quot;);
 320         errout(msg);
 321     }
 322 
 323     private static void errout(String msg) {
 324         if (msg.contains(&quot;%n&quot;)) {
 325             System.err.printf(msg);
 326         } else {
 327             System.err.println(msg);
 328         }
 329     }
 330 
 331     /**
 332      * Configure the parser to allow access to DTDs on the file system.
 333      */
 334     private static void enableFileAccess(SAXParser parser) throws SAXNotSupportedException {
 335         try {
 336             parser.setProperty(&quot;http://javax.xml.XMLConstants/property/accessExternalDTD&quot;, &quot;file&quot;);
 337         } catch (SAXNotRecognizedException ignore) {
 338             // property requires &gt;= JAXP 1.5
 339         }
 340     }
 341 
 342     private static List&lt;Bundle&gt; readBundleList() throws Exception {
 343         List&lt;Bundle&gt; retList = new ArrayList&lt;&gt;();
 344         Path path = FileSystems.getDefault().getPath(SOURCE_FILE_DIR);
 345         try (DirectoryStream&lt;Path&gt; dirStr = Files.newDirectoryStream(path)) {
 346             for (Path entry : dirStr) {
 347                 String fileName = entry.getFileName().toString();
 348                 if (fileName.endsWith(&quot;.xml&quot;)) {
 349                     String id = fileName.substring(0, fileName.indexOf(&#39;.&#39;));
 350                     Locale cldrLoc = Locale.forLanguageTag(toLanguageTag(id));
 351                     StringBuilder sb = getCandLocales(cldrLoc);
 352                     if (sb.indexOf(&quot;root&quot;) == -1) {
 353                         sb.append(&quot;root&quot;);
 354                     }
 355                     retList.add(new Bundle(id, sb.toString(), null, null));
 356                 }
 357             }
 358         }
 359 
 360         // Sort the bundles based on id. This will make sure all the parent bundles are
 361         // processed first, e.g., for en_GB bundle, en_001, and &quot;root&quot; comes before
 362         // en_GB. In order for &quot;root&quot; to come at the beginning, &quot;root&quot; is replaced with
 363         // empty string on comparison.
 364         retList.sort((o1, o2) -&gt; {
 365             String id1 = o1.getID();
 366             String id2 = o2.getID();
 367             if(id1.equals(&quot;root&quot;)) {
 368                 id1 = &quot;&quot;;
 369             }
 370             if(id2.equals(&quot;root&quot;)) {
 371                 id2 = &quot;&quot;;
 372             }
 373             return id1.compareTo(id2);
 374         });
 375         return retList;
 376     }
 377 
 378     private static final Map&lt;String, Map&lt;String, Object&gt;&gt; cldrBundles = new HashMap&lt;&gt;();
 379 
 380     private static Map&lt;String, SortedSet&lt;String&gt;&gt; metaInfo = new HashMap&lt;&gt;();
 381 
 382     static {
 383         // For generating information on supported locales.
 384         metaInfo.put(&quot;AvailableLocales&quot;, new TreeSet&lt;&gt;());
 385     }
 386 
 387     static Map&lt;String, Object&gt; getCLDRBundle(String id) throws Exception {
 388         Map&lt;String, Object&gt; bundle = cldrBundles.get(id);
 389         if (bundle != null) {
 390             return bundle;
 391         }
 392         File file = new File(SOURCE_FILE_DIR + File.separator + id + &quot;.xml&quot;);
 393         if (!file.exists()) {
 394             // Skip if the file doesn&#39;t exist.
 395             return Collections.emptyMap();
 396         }
 397 
 398         info(&quot;..... main directory .....&quot;);
 399         LDMLParseHandler handler = new LDMLParseHandler(id);
 400         parseLDMLFile(file, handler);
 401 
 402         bundle = handler.getData();
 403         cldrBundles.put(id, bundle);
 404 
 405         if (id.equals(&quot;root&quot;)) {
 406             // Calendar data (firstDayOfWeek &amp; minDaysInFirstWeek)
 407             bundle = handlerSuppl.getData(&quot;root&quot;);
 408             if (bundle != null) {
 409                 //merge two maps into one map
 410                 Map&lt;String, Object&gt; temp = cldrBundles.remove(id);
 411                 bundle.putAll(temp);
 412                 cldrBundles.put(id, bundle);
 413             }
 414         }
 415         return bundle;
 416     }
 417 
 418     // Parsers for data in &quot;supplemental&quot; directory
 419     //
 420     private static void parseSupplemental() throws Exception {
 421         // Parse SupplementalData file and store the information in the HashMap
 422         // Calendar information such as firstDay and minDay are stored in
 423         // supplementalData.xml as of CLDR1.4. Individual territory is listed
 424         // with its ISO 3166 country code while default is listed using UNM49
 425         // region and composition numerical code (001 for World.)
 426         //
 427         // SupplementalData file also provides the &quot;parent&quot; locales which
 428         // are othrwise not to be fallen back. Process them here as well.
 429         //
 430         handlerSuppl = new SupplementDataParseHandler();
 431         parseLDMLFile(new File(SPPL_SOURCE_FILE), handlerSuppl);
 432         Map&lt;String, Object&gt; parentData = handlerSuppl.getData(&quot;root&quot;);
 433         parentData.keySet().stream()
 434                 .filter(key -&gt; key.startsWith(PARENT_LOCALE_PREFIX))
 435                 .forEach(key -&gt; {
 436                 parentLocalesMap.put(key, new TreeSet(
 437                     Arrays.asList(((String)parentData.get(key)).split(&quot; &quot;))));
 438             });
 439 
 440         // Parse numberingSystems to get digit zero character information.
 441         handlerNumbering = new NumberingSystemsParseHandler();
 442         parseLDMLFile(new File(NUMBERING_SOURCE_FILE), handlerNumbering);
 443 
 444         // Parse metaZones to create mappings between Olson tzids and CLDR meta zone names
 445         handlerMetaZones = new MetaZonesParseHandler();
 446         parseLDMLFile(new File(METAZONES_SOURCE_FILE), handlerMetaZones);
 447 
 448         // Parse likelySubtags
 449         handlerLikelySubtags = new LikelySubtagsParseHandler();
 450         parseLDMLFile(new File(LIKELYSUBTAGS_SOURCE_FILE), handlerLikelySubtags);
 451 
 452         // Parse supplementalMetadata
 453         // Currently interested in deprecated time zone ids and language aliases.
 454         handlerSupplMeta = new SupplementalMetadataParseHandler();
 455         parseLDMLFile(new File(SPPL_META_SOURCE_FILE), handlerSupplMeta);
 456 
 457         // Parse windowsZones
 458         handlerWinZones = new WinZonesParseHandler();
 459         parseLDMLFile(new File(WINZONES_SOURCE_FILE), handlerWinZones);
 460 
 461         // Parse plurals
 462         handlerPlurals = new PluralsParseHandler();
 463         parseLDMLFile(new File(PLURALS_SOURCE_FILE), handlerPlurals);
 464     }
 465 
 466     // Parsers for data in &quot;bcp47&quot; directory
 467     //
 468     private static void parseBCP47() throws Exception {
 469         // Parse timezone
 470         handlerTimeZone = new TimeZoneParseHandler();
 471         parseLDMLFile(new File(TIMEZONE_SOURCE_FILE), handlerTimeZone);
 472 
 473         // canonical tz name map
 474         // alias -&gt; primary
 475         handlerTimeZone.getData().forEach((k, v) -&gt; {
 476             String[] ids = ((String)v).split(&quot;\\s&quot;);
 477             for (int i = 1; i &lt; ids.length; i++) {
 478                 canonicalTZMap.put(ids[i], ids[0]);
 479             }
 480         });
 481     }
 482 
 483     private static void parseLDMLFile(File srcfile, AbstractLDMLHandler handler) throws Exception {
 484         info(&quot;..... Parsing &quot; + srcfile.getName() + &quot; .....&quot;);
 485         SAXParserFactory pf = SAXParserFactory.newInstance();
 486         pf.setValidating(true);
 487         SAXParser parser = pf.newSAXParser();
 488         enableFileAccess(parser);
 489         parser.parse(srcfile, handler);
 490     }
 491 
 492     private static StringBuilder getCandLocales(Locale cldrLoc) {
 493         List&lt;Locale&gt; candList = getCandidateLocales(cldrLoc);
 494         StringBuilder sb = new StringBuilder();
 495         for (Locale loc : candList) {
 496             if (!loc.equals(Locale.ROOT)) {
 497                 sb.append(toLocaleName(loc.toLanguageTag()));
 498                 sb.append(&quot;,&quot;);
 499             }
 500         }
 501         return sb;
 502     }
 503 
 504     private static List&lt;Locale&gt; getCandidateLocales(Locale cldrLoc) {
 505         List&lt;Locale&gt; candList = new ArrayList&lt;&gt;();
 506         candList = applyParentLocales(&quot;&quot;, defCon.getCandidateLocales(&quot;&quot;,  cldrLoc));
 507         return candList;
 508     }
 509 
 510     private static void convertBundles(List&lt;Bundle&gt; bundles) throws Exception {
 511         // parent locales map. The mappings are put in base metaInfo file
 512         // for now.
 513         if (isBaseModule) {
 514             metaInfo.putAll(parentLocalesMap);
 515         }
 516 
 517         for (Bundle bundle : bundles) {
 518             // Get the target map, which contains all the data that should be
 519             // visible for the bundle&#39;s locale
 520 
 521             Map&lt;String, Object&gt; targetMap = bundle.getTargetMap();
 522 
 523             EnumSet&lt;Bundle.Type&gt; bundleTypes = bundle.getBundleTypes();
 524 
 525             if (bundle.isRoot()) {
 526                 // Add DateTimePatternChars because CLDR no longer supports localized patterns.
 527                 targetMap.put(&quot;DateTimePatternChars&quot;, &quot;GyMdkHmsSEDFwWahKzZ&quot;);
 528             }
 529 
 530             // Now the map contains just the entries that need to be in the resources bundles.
 531             // Go ahead and generate them.
 532             if (bundleTypes.contains(Bundle.Type.LOCALENAMES)) {
 533                 Map&lt;String, Object&gt; localeNamesMap = extractLocaleNames(targetMap, bundle.getID());
 534                 if (!localeNamesMap.isEmpty() || bundle.isRoot()) {
 535                     bundleGenerator.generateBundle(&quot;util&quot;, &quot;LocaleNames&quot;, bundle.getJavaID(), true, localeNamesMap, BundleType.OPEN);
 536                 }
 537             }
 538             if (bundleTypes.contains(Bundle.Type.CURRENCYNAMES)) {
 539                 Map&lt;String, Object&gt; currencyNamesMap = extractCurrencyNames(targetMap, bundle.getID(), bundle.getCurrencies());
 540                 if (!currencyNamesMap.isEmpty() || bundle.isRoot()) {
 541                     bundleGenerator.generateBundle(&quot;util&quot;, &quot;CurrencyNames&quot;, bundle.getJavaID(), true, currencyNamesMap, BundleType.OPEN);
 542                 }
 543             }
 544             if (bundleTypes.contains(Bundle.Type.TIMEZONENAMES)) {
 545                 Map&lt;String, Object&gt; zoneNamesMap = extractZoneNames(targetMap, bundle.getID());
 546                 if (!zoneNamesMap.isEmpty() || bundle.isRoot()) {
 547                     bundleGenerator.generateBundle(&quot;util&quot;, &quot;TimeZoneNames&quot;, bundle.getJavaID(), true, zoneNamesMap, BundleType.TIMEZONE);
 548                 }
 549             }
 550             if (bundleTypes.contains(Bundle.Type.CALENDARDATA)) {
 551                 Map&lt;String, Object&gt; calendarDataMap = extractCalendarData(targetMap, bundle.getID());
 552                 if (!calendarDataMap.isEmpty() || bundle.isRoot()) {
 553                     bundleGenerator.generateBundle(&quot;util&quot;, &quot;CalendarData&quot;, bundle.getJavaID(), true, calendarDataMap, BundleType.PLAIN);
 554                 }
 555             }
 556             if (bundleTypes.contains(Bundle.Type.FORMATDATA)) {
 557                 Map&lt;String, Object&gt; formatDataMap = extractFormatData(targetMap, bundle.getID());
 558                 if (!formatDataMap.isEmpty() || bundle.isRoot()) {
 559                     bundleGenerator.generateBundle(&quot;text&quot;, &quot;FormatData&quot;, bundle.getJavaID(), true, formatDataMap, BundleType.PLAIN);
 560                 }
 561             }
 562 
 563             // For AvailableLocales
 564             metaInfo.get(&quot;AvailableLocales&quot;).add(toLanguageTag(bundle.getID()));
 565             addLikelySubtags(metaInfo, &quot;AvailableLocales&quot;, bundle.getID());
 566         }
 567         bundleGenerator.generateMetaInfo(metaInfo);
 568     }
 569 
 570     static final Map&lt;String, String&gt; aliases = new HashMap&lt;&gt;();
 571 
 572     /**
 573      * Translate the aliases into the real entries in the bundle map.
 574      */
 575     static void handleAliases(Map&lt;String, Object&gt; bundleMap) {
 576         Set bundleKeys = bundleMap.keySet();
 577         try {
 578             for (String key : aliases.keySet()) {
 579                 String targetKey = aliases.get(key);
 580                 if (bundleKeys.contains(targetKey)) {
 581                     bundleMap.putIfAbsent(key, bundleMap.get(targetKey));
 582                 }
 583             }
 584         } catch (Exception ex) {
 585             Logger.getLogger(CLDRConverter.class.getName()).log(Level.SEVERE, null, ex);
 586         }
 587     }
 588 
 589     /*
 590      * Returns the language portion of the given id.
 591      * If id is &quot;root&quot;, &quot;&quot; is returned.
 592      */
 593     static String getLanguageCode(String id) {
 594         return &quot;root&quot;.equals(id) ? &quot;&quot; : Locale.forLanguageTag(id.replaceAll(&quot;_&quot;, &quot;-&quot;)).getLanguage();
 595     }
 596 
 597     /**
 598      * Examine if the id includes the country (territory) code. If it does, it returns
 599      * the country code.
 600      * Otherwise, it returns null. eg. when the id is &quot;zh_Hans_SG&quot;, it return &quot;SG&quot;.
 601      * It does NOT return UN M.49 code, e.g., &#39;001&#39;, as those three digit numbers cannot
 602      * be translated into package names.
 603      */
 604     static String getCountryCode(String id) {
 605         String rgn = getRegionCode(id);
 606         return rgn.length() == 2 ? rgn: null;
 607     }
 608 
 609     /**
 610      * Examine if the id includes the region code. If it does, it returns
 611      * the region code.
 612      * Otherwise, it returns null. eg. when the id is &quot;zh_Hans_SG&quot;, it return &quot;SG&quot;.
 613      * It DOES return UN M.49 code, e.g., &#39;001&#39;, as well as ISO 3166 two letter country codes.
 614      */
 615     static String getRegionCode(String id) {
 616         return Locale.forLanguageTag(id.replaceAll(&quot;_&quot;, &quot;-&quot;)).getCountry();
 617     }
 618 
 619     private static class KeyComparator implements Comparator&lt;String&gt; {
 620         static KeyComparator INSTANCE = new KeyComparator();
 621 
 622         private KeyComparator() {
 623         }
 624 
 625         @Override
 626         public int compare(String o1, String o2) {
 627             int len1 = o1.length();
 628             int len2 = o2.length();
 629             if (!isDigit(o1.charAt(0)) &amp;&amp; !isDigit(o2.charAt(0))) {
 630                 // Shorter string comes first unless either starts with a digit.
 631                 if (len1 &lt; len2) {
 632                     return -1;
 633                 }
 634                 if (len1 &gt; len2) {
 635                     return 1;
 636                 }
 637             }
 638             return o1.compareTo(o2);
 639         }
 640 
 641         private boolean isDigit(char c) {
 642             return c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;;
 643         }
 644     }
 645 
 646     private static Map&lt;String, Object&gt; extractLocaleNames(Map&lt;String, Object&gt; map, String id) {
 647         Map&lt;String, Object&gt; localeNames = new TreeMap&lt;&gt;(KeyComparator.INSTANCE);
 648         for (String key : map.keySet()) {
 649             if (key.startsWith(LOCALE_NAME_PREFIX)) {
 650                 switch (key) {
 651                     case LOCALE_SEPARATOR:
 652                         localeNames.put(&quot;ListCompositionPattern&quot;, map.get(key));
 653                         break;
 654                     case LOCALE_KEYTYPE:
 655                         localeNames.put(&quot;ListKeyTypePattern&quot;, map.get(key));
 656                         break;
 657                     default:
 658                         localeNames.put(key.substring(LOCALE_NAME_PREFIX.length()), map.get(key));
 659                         break;
 660                 }
 661             }
 662         }
 663 
 664         if (id.equals(&quot;root&quot;)) {
 665             // Add display name pattern, which is not in CLDR
 666             localeNames.put(&quot;DisplayNamePattern&quot;, &quot;{0,choice,0#|1#{1}|2#{1} ({2})}&quot;);
 667         }
 668 
 669         return localeNames;
 670     }
 671 
 672     @SuppressWarnings(&quot;AssignmentToForLoopParameter&quot;)
 673     private static Map&lt;String, Object&gt; extractCurrencyNames(Map&lt;String, Object&gt; map, String id, String names)
 674             throws Exception {
 675         Map&lt;String, Object&gt; currencyNames = new TreeMap&lt;&gt;(KeyComparator.INSTANCE);
 676         for (String key : map.keySet()) {
 677             if (key.startsWith(CURRENCY_NAME_PREFIX)) {
 678                 currencyNames.put(key.substring(CURRENCY_NAME_PREFIX.length()), map.get(key));
 679             } else if (key.startsWith(CURRENCY_SYMBOL_PREFIX)) {
 680                 currencyNames.put(key.substring(CURRENCY_SYMBOL_PREFIX.length()), map.get(key));
 681             }
 682         }
 683         return currencyNames;
 684     }
 685 
 686     private static Map&lt;String, Object&gt; extractZoneNames(Map&lt;String, Object&gt; map, String id) {
<a name="5" id="anc5"></a><span class="line-modified"> 687         Map&lt;String, Object&gt; names = new HashMap&lt;&gt;();</span>
<span class="line-removed"> 688 </span>
<span class="line-removed"> 689         // Copy over missing time zone ids from JRE for English locale</span>
<span class="line-removed"> 690         if (id.equals(&quot;en&quot;)) {</span>
<span class="line-removed"> 691             Map&lt;String[], String&gt; jreMetaMap = new HashMap&lt;&gt;();</span>
<span class="line-removed"> 692             jreTimeZoneNames.stream().forEach(e -&gt; {</span>
<span class="line-removed"> 693                 String tzid = (String)e[0];</span>
<span class="line-removed"> 694                 String[] data = (String[])e[1];</span>
<span class="line-removed"> 695 </span>
<span class="line-removed"> 696                 if (map.get(TIMEZONE_ID_PREFIX + tzid) == null &amp;&amp;</span>
<span class="line-removed"> 697                     handlerMetaZones.get(tzid) == null ||</span>
<span class="line-removed"> 698                     handlerMetaZones.get(tzid) != null &amp;&amp;</span>
<span class="line-removed"> 699                     map.get(METAZONE_ID_PREFIX + handlerMetaZones.get(tzid)) == null) {</span>
<span class="line-removed"> 700 </span>
<span class="line-removed"> 701                     // First, check the alias</span>
<span class="line-removed"> 702                     String canonID = canonicalTZMap.get(tzid);</span>
<span class="line-removed"> 703                     if (canonID != null &amp;&amp; !tzid.equals(canonID)) {</span>
<span class="line-removed"> 704                         Object value = map.get(TIMEZONE_ID_PREFIX + canonID);</span>
<span class="line-removed"> 705                         if (value != null) {</span>
<span class="line-removed"> 706                             names.put(tzid, value);</span>
<span class="line-removed"> 707                             return;</span>
<span class="line-removed"> 708                         } else {</span>
<span class="line-removed"> 709                             String meta = handlerMetaZones.get(canonID);</span>
<span class="line-removed"> 710                             if (meta != null) {</span>
<span class="line-removed"> 711                                 value = map.get(METAZONE_ID_PREFIX + meta);</span>
<span class="line-removed"> 712                                 if (value != null) {</span>
<span class="line-removed"> 713                                     names.put(tzid, meta);</span>
<span class="line-removed"> 714                                     return;</span>
<span class="line-removed"> 715                                 }</span>
<span class="line-removed"> 716                             }</span>
<span class="line-removed"> 717                         }</span>
<span class="line-removed"> 718                     }</span>
<span class="line-removed"> 719 </span>
<span class="line-removed"> 720                     // Check the CLDR meta key</span>
<span class="line-removed"> 721                     Optional&lt;Map.Entry&lt;String, String&gt;&gt; cldrMeta =</span>
<span class="line-removed"> 722                         handlerMetaZones.getData().entrySet().stream()</span>
<span class="line-removed"> 723                             .filter(me -&gt;</span>
<span class="line-removed"> 724                                 Arrays.deepEquals(data,</span>
<span class="line-removed"> 725                                     (String[])map.get(METAZONE_ID_PREFIX + me.getValue())))</span>
<span class="line-removed"> 726                             .findAny();</span>
<span class="line-removed"> 727                     cldrMeta.ifPresentOrElse(meta -&gt; names.put(tzid, meta.getValue()), () -&gt; {</span>
<span class="line-removed"> 728                         // Check the JRE meta key, add if there is not.</span>
<span class="line-removed"> 729                         Optional&lt;Map.Entry&lt;String[], String&gt;&gt; jreMeta =</span>
<span class="line-removed"> 730                             jreMetaMap.entrySet().stream()</span>
<span class="line-removed"> 731                                 .filter(jm -&gt; Arrays.deepEquals(data, jm.getKey()))</span>
<span class="line-removed"> 732                                 .findAny();</span>
<span class="line-removed"> 733                         jreMeta.ifPresentOrElse(meta -&gt; names.put(tzid, meta.getValue()), () -&gt; {</span>
<span class="line-removed"> 734                                 String metaName = &quot;JRE_&quot; + tzid.replaceAll(&quot;[/-]&quot;, &quot;_&quot;);</span>
<span class="line-removed"> 735                                 names.put(METAZONE_ID_PREFIX + metaName, data);</span>
<span class="line-removed"> 736                                 names.put(tzid, metaName);</span>
<span class="line-removed"> 737                         });</span>
<span class="line-removed"> 738                     });</span>
<span class="line-removed"> 739                 }</span>
<span class="line-removed"> 740             });</span>
<span class="line-removed"> 741         }</span>
 742 
 743         getAvailableZoneIds().stream().forEach(tzid -&gt; {
 744             // If the tzid is deprecated, get the data for the replacement id
 745             String tzKey = Optional.ofNullable((String)handlerSupplMeta.get(tzid))
 746                                    .orElse(tzid);
 747             Object data = map.get(TIMEZONE_ID_PREFIX + tzKey);
 748 
 749             if (data instanceof String[]) {
<a name="6" id="anc6"></a><span class="line-modified"> 750                 names.put(tzid, data);</span>







 751             } else {
 752                 String meta = handlerMetaZones.get(tzKey);
 753                 if (meta != null) {
 754                     String metaKey = METAZONE_ID_PREFIX + meta;
 755                     data = map.get(metaKey);
 756                     if (data instanceof String[]) {
 757                         // Keep the metazone prefix here.
 758                         names.put(metaKey, data);
 759                         names.put(tzid, meta);
 760                     }
 761                 }
 762             }
 763         });
 764 
 765         // exemplar cities.
 766         Map&lt;String, Object&gt; exCities = map.entrySet().stream()
<a name="7" id="anc7"></a><span class="line-modified"> 767                 .filter(e -&gt; e.getKey().startsWith(CLDRConverter.EXEMPLAR_CITY_PREFIX))</span>
<span class="line-modified"> 768                 .collect(Collectors</span>
<span class="line-removed"> 769                         .toMap(Map.Entry::getKey, Map.Entry::getValue));</span>
 770         names.putAll(exCities);
 771 
<a name="8" id="anc8"></a><span class="line-modified"> 772         if (!id.equals(&quot;en&quot;) &amp;&amp;</span>
<span class="line-modified"> 773             !names.isEmpty()) {</span>
<span class="line-modified"> 774             // CLDR does not have UTC entry, so add it here.</span>
<span class="line-modified"> 775             names.put(&quot;UTC&quot;, EMPTY_ZONE);</span>
<span class="line-removed"> 776 </span>
<span class="line-removed"> 777             // no metazone zones</span>
<span class="line-removed"> 778             Arrays.asList(handlerMetaZones.get(MetaZonesParseHandler.NO_METAZONE_KEY)</span>
<span class="line-removed"> 779                 .split(&quot;\\s&quot;)).stream()</span>
<span class="line-removed"> 780                 .forEach(tz -&gt; {</span>
<span class="line-removed"> 781                     names.put(tz, EMPTY_ZONE);</span>
<span class="line-removed"> 782                 });</span>
 783         }
 784 
<a name="9" id="anc9"></a>






 785         return names;
 786     }
 787 
 788     /**
 789      * Extracts the language independent calendar data. Each of the two keys,
 790      * &quot;firstDayOfWeek&quot; and &quot;minimalDaysInFirstWeek&quot; has a string value consists of
 791      * one or multiple occurrences of:
 792      *  i: rg1 rg2 ... rgn;
 793      * where &quot;i&quot; is the data for the following regions (delimited by a space) after
 794      * &quot;:&quot;, and ends with a &quot;;&quot;.
 795      */
 796     private static Map&lt;String, Object&gt; extractCalendarData(Map&lt;String, Object&gt; map, String id) {
 797         Map&lt;String, Object&gt; calendarData = new LinkedHashMap&lt;&gt;();
 798         if (id.equals(&quot;root&quot;)) {
 799             calendarData.put(&quot;firstDayOfWeek&quot;,
 800                 IntStream.range(1, 8)
 801                     .mapToObj(String::valueOf)
 802                     .filter(d -&gt; map.keySet().contains(CALENDAR_FIRSTDAY_PREFIX + d))
 803                     .map(d -&gt; d + &quot;: &quot; + map.get(CALENDAR_FIRSTDAY_PREFIX + d))
 804                     .collect(Collectors.joining(&quot;;&quot;)));
 805             calendarData.put(&quot;minimalDaysInFirstWeek&quot;,
 806                 IntStream.range(0, 7)
 807                     .mapToObj(String::valueOf)
 808                     .filter(d -&gt; map.keySet().contains(CALENDAR_MINDAYS_PREFIX + d))
 809                     .map(d -&gt; d + &quot;: &quot; + map.get(CALENDAR_MINDAYS_PREFIX + d))
 810                     .collect(Collectors.joining(&quot;;&quot;)));
 811         }
 812         return calendarData;
 813     }
 814 
 815     static final String[] FORMAT_DATA_ELEMENTS = {
 816         &quot;MonthNames&quot;,
 817         &quot;standalone.MonthNames&quot;,
 818         &quot;MonthAbbreviations&quot;,
 819         &quot;standalone.MonthAbbreviations&quot;,
 820         &quot;MonthNarrows&quot;,
 821         &quot;standalone.MonthNarrows&quot;,
 822         &quot;DayNames&quot;,
 823         &quot;standalone.DayNames&quot;,
 824         &quot;DayAbbreviations&quot;,
 825         &quot;standalone.DayAbbreviations&quot;,
 826         &quot;DayNarrows&quot;,
 827         &quot;standalone.DayNarrows&quot;,
 828         &quot;QuarterNames&quot;,
 829         &quot;standalone.QuarterNames&quot;,
 830         &quot;QuarterAbbreviations&quot;,
 831         &quot;standalone.QuarterAbbreviations&quot;,
 832         &quot;QuarterNarrows&quot;,
 833         &quot;standalone.QuarterNarrows&quot;,
 834         &quot;AmPmMarkers&quot;,
 835         &quot;narrow.AmPmMarkers&quot;,
 836         &quot;abbreviated.AmPmMarkers&quot;,
 837         &quot;long.Eras&quot;,
 838         &quot;Eras&quot;,
 839         &quot;narrow.Eras&quot;,
 840         &quot;field.era&quot;,
 841         &quot;field.year&quot;,
 842         &quot;field.month&quot;,
 843         &quot;field.week&quot;,
 844         &quot;field.weekday&quot;,
 845         &quot;field.dayperiod&quot;,
 846         &quot;field.hour&quot;,
 847         &quot;timezone.hourFormat&quot;,
 848         &quot;timezone.gmtFormat&quot;,
 849         &quot;timezone.gmtZeroFormat&quot;,
 850         &quot;timezone.regionFormat&quot;,
 851         &quot;timezone.regionFormat.daylight&quot;,
 852         &quot;timezone.regionFormat.standard&quot;,
 853         &quot;field.minute&quot;,
 854         &quot;field.second&quot;,
 855         &quot;field.zone&quot;,
 856         &quot;TimePatterns&quot;,
 857         &quot;DatePatterns&quot;,
 858         &quot;DateTimePatterns&quot;,
 859         &quot;DateTimePatternChars&quot;
 860     };
 861 
 862     private static Map&lt;String, Object&gt; extractFormatData(Map&lt;String, Object&gt; map, String id) {
 863         Map&lt;String, Object&gt; formatData = new LinkedHashMap&lt;&gt;();
 864         for (CalendarType calendarType : CalendarType.values()) {
 865             if (calendarType == CalendarType.GENERIC) {
 866                 continue;
 867             }
 868             String prefix = calendarType.keyElementName();
 869             for (String element : FORMAT_DATA_ELEMENTS) {
 870                 String key = prefix + element;
 871                 copyIfPresent(map, &quot;java.time.&quot; + key, formatData);
 872                 copyIfPresent(map, key, formatData);
 873             }
 874         }
 875 
 876         for (String key : map.keySet()) {
 877             // Copy available calendar names
 878             if (key.startsWith(CLDRConverter.LOCALE_TYPE_PREFIX_CA)) {
 879                 String type = key.substring(CLDRConverter.LOCALE_TYPE_PREFIX_CA.length());
 880                 for (CalendarType calendarType : CalendarType.values()) {
 881                     if (calendarType == CalendarType.GENERIC) {
 882                         continue;
 883                     }
 884                     if (type.equals(calendarType.lname())) {
 885                         Object value = map.get(key);
 886                         String dataKey = key.replace(LOCALE_TYPE_PREFIX_CA,
 887                                 CALENDAR_NAME_PREFIX);
 888                         formatData.put(dataKey, value);
 889                         String ukey = CALENDAR_NAME_PREFIX + calendarType.uname();
 890                         if (!dataKey.equals(ukey)) {
 891                             formatData.put(ukey, value);
 892                         }
 893                     }
 894                 }
 895             }
 896         }
 897 
 898         copyIfPresent(map, &quot;DefaultNumberingSystem&quot;, formatData);
 899 
 900         @SuppressWarnings(&quot;unchecked&quot;)
 901         List&lt;String&gt; numberingScripts = (List&lt;String&gt;) map.remove(&quot;numberingScripts&quot;);
 902         if (numberingScripts != null) {
 903             for (String script : numberingScripts) {
 904                 copyIfPresent(map, script + &quot;.NumberElements&quot;, formatData);
 905                 copyIfPresent(map, script + &quot;.NumberPatterns&quot;, formatData);
 906             }
 907         } else {
 908             copyIfPresent(map, &quot;NumberElements&quot;, formatData);
 909             copyIfPresent(map, &quot;NumberPatterns&quot;, formatData);
 910         }
 911         copyIfPresent(map, &quot;short.CompactNumberPatterns&quot;, formatData);
 912         copyIfPresent(map, &quot;long.CompactNumberPatterns&quot;, formatData);
 913 
 914         // put extra number elements for available scripts into formatData, if it is &quot;root&quot;
 915         if (id.equals(&quot;root&quot;)) {
 916             handlerNumbering.keySet().stream()
 917                 .filter(k -&gt; !numberingScripts.contains(k))
 918                 .forEach(k -&gt; {
 919                     String[] ne = (String[])map.get(&quot;latn.NumberElements&quot;);
 920                     String[] neNew = Arrays.copyOf(ne, ne.length);
 921                     neNew[4] = handlerNumbering.get(k).substring(0, 1);
 922                     formatData.put(k + &quot;.NumberElements&quot;, neNew);
 923                 });
 924         }
 925         return formatData;
 926     }
 927 
 928     private static void copyIfPresent(Map&lt;String, Object&gt; src, String key, Map&lt;String, Object&gt; dest) {
 929         Object value = src.get(key);
 930         if (value != null) {
 931             dest.put(key, value);
 932         }
 933     }
 934 
 935     // --- code below here is adapted from java.util.Properties ---
 936     private static final String specialSaveCharsJava = &quot;\&quot;&quot;;
 937     private static final String specialSaveCharsProperties = &quot;=: \t\r\n\f#!&quot;;
 938 
 939     /*
 940      * Converts unicodes to encoded &amp;#92;uxxxx
 941      * and writes out any of the characters in specialSaveChars
 942      * with a preceding slash
 943      */
 944     static String saveConvert(String theString, boolean useJava) {
 945         if (theString == null) {
 946             return &quot;&quot;;
 947         }
 948 
 949         String specialSaveChars;
 950         if (useJava) {
 951             specialSaveChars = specialSaveCharsJava;
 952         } else {
 953             specialSaveChars = specialSaveCharsProperties;
 954         }
 955         boolean escapeSpace = false;
 956 
 957         int len = theString.length();
 958         StringBuilder outBuffer = new StringBuilder(len * 2);
 959         Formatter formatter = new Formatter(outBuffer, Locale.ROOT);
 960 
 961         for (int x = 0; x &lt; len; x++) {
 962             char aChar = theString.charAt(x);
 963             switch (aChar) {
 964             case &#39; &#39;:
 965                 if (x == 0 || escapeSpace) {
 966                     outBuffer.append(&#39;\\&#39;);
 967                 }
 968                 outBuffer.append(&#39; &#39;);
 969                 break;
 970             case &#39;\\&#39;:
 971                 outBuffer.append(&#39;\\&#39;);
 972                 outBuffer.append(&#39;\\&#39;);
 973                 break;
 974             case &#39;\t&#39;:
 975                 outBuffer.append(&#39;\\&#39;);
 976                 outBuffer.append(&#39;t&#39;);
 977                 break;
 978             case &#39;\n&#39;:
 979                 outBuffer.append(&#39;\\&#39;);
 980                 outBuffer.append(&#39;n&#39;);
 981                 break;
 982             case &#39;\r&#39;:
 983                 outBuffer.append(&#39;\\&#39;);
 984                 outBuffer.append(&#39;r&#39;);
 985                 break;
 986             case &#39;\f&#39;:
 987                 outBuffer.append(&#39;\\&#39;);
 988                 outBuffer.append(&#39;f&#39;);
 989                 break;
 990             default:
 991                 if (aChar &lt; 0x0020 || (!USE_UTF8 &amp;&amp; aChar &gt; 0x007e)) {
 992                     formatter.format(&quot;\\u%04x&quot;, (int)aChar);
 993                 } else {
 994                     if (specialSaveChars.indexOf(aChar) != -1) {
 995                         outBuffer.append(&#39;\\&#39;);
 996                     }
 997                     outBuffer.append(aChar);
 998                 }
 999             }
1000         }
1001         return outBuffer.toString();
1002     }
1003 
1004     private static String toLanguageTag(String locName) {
1005         if (locName.indexOf(&#39;_&#39;) == -1) {
1006             return locName;
1007         }
1008         String tag = locName.replaceAll(&quot;_&quot;, &quot;-&quot;);
1009         Locale loc = Locale.forLanguageTag(tag);
1010         return loc.toLanguageTag();
1011     }
1012 
1013     private static void addLikelySubtags(Map&lt;String, SortedSet&lt;String&gt;&gt; metaInfo, String category, String id) {
1014         String likelySubtag = handlerLikelySubtags.get(id);
1015         if (likelySubtag != null) {
1016             // Remove Script for now
1017             metaInfo.get(category).add(toLanguageTag(likelySubtag).replaceFirst(&quot;-[A-Z][a-z]{3}&quot;, &quot;&quot;));
1018         }
1019     }
1020 
1021     private static String toLocaleName(String tag) {
1022         if (tag.indexOf(&#39;-&#39;) == -1) {
1023             return tag;
1024         }
1025         return tag.replaceAll(&quot;-&quot;, &quot;_&quot;);
1026     }
1027 
1028     private static void setupBaseLocales(String localeList) {
1029         Arrays.stream(localeList.split(&quot;,&quot;))
1030             .map(Locale::forLanguageTag)
1031             .map(l -&gt; Control.getControl(Control.FORMAT_DEFAULT)
1032                              .getCandidateLocales(&quot;&quot;, l))
1033             .forEach(BASE_LOCALES::addAll);
1034     }
1035 
1036     // applying parent locale rules to the passed candidates list
1037     // This has to match with the one in sun.util.cldr.CLDRLocaleProviderAdapter
1038     private static Map&lt;Locale, Locale&gt; childToParentLocaleMap = null;
1039     private static List&lt;Locale&gt; applyParentLocales(String baseName, List&lt;Locale&gt; candidates) {
1040         if (Objects.isNull(childToParentLocaleMap)) {
1041             childToParentLocaleMap = new HashMap&lt;&gt;();
1042             parentLocalesMap.keySet().forEach(key -&gt; {
1043                 String parent = key.substring(PARENT_LOCALE_PREFIX.length()).replaceAll(&quot;_&quot;, &quot;-&quot;);
1044                 parentLocalesMap.get(key).stream().forEach(child -&gt; {
1045                     childToParentLocaleMap.put(Locale.forLanguageTag(child),
1046                         &quot;root&quot;.equals(parent) ? Locale.ROOT : Locale.forLanguageTag(parent));
1047                 });
1048             });
1049         }
1050 
1051         // check irregular parents
1052         for (int i = 0; i &lt; candidates.size(); i++) {
1053             Locale l = candidates.get(i);
1054             Locale p = childToParentLocaleMap.get(l);
1055             if (!l.equals(Locale.ROOT) &amp;&amp;
1056                 Objects.nonNull(p) &amp;&amp;
1057                 !candidates.get(i+1).equals(p)) {
1058                 List&lt;Locale&gt; applied = candidates.subList(0, i+1);
1059                 applied.addAll(applyParentLocales(baseName, defCon.getCandidateLocales(baseName, p)));
1060                 return applied;
1061             }
1062         }
1063 
1064         return candidates;
1065     }
1066 
1067     private static void generateZoneName() throws Exception {
1068         Files.createDirectories(Paths.get(DESTINATION_DIR, &quot;java&quot;, &quot;time&quot;, &quot;format&quot;));
1069         Files.write(Paths.get(DESTINATION_DIR, &quot;java&quot;, &quot;time&quot;, &quot;format&quot;, &quot;ZoneName.java&quot;),
1070             Files.lines(Paths.get(zoneNameTempFile))
1071                 .flatMap(l -&gt; {
1072                     if (l.equals(&quot;%%%%ZIDMAP%%%%&quot;)) {
1073                         return zidMapEntry();
1074                     } else if (l.equals(&quot;%%%%MZONEMAP%%%%&quot;)) {
1075                         return handlerMetaZones.mzoneMapEntry();
1076                     } else if (l.equals(&quot;%%%%DEPRECATED%%%%&quot;)) {
1077                         return handlerSupplMeta.deprecatedMap();
1078                     } else if (l.equals(&quot;%%%%TZDATALINK%%%%&quot;)) {
1079                         return tzDataLinkEntry();
1080                     } else {
1081                         return Stream.of(l);
1082                     }
1083                 })
1084                 .collect(Collectors.toList()),
1085             StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
1086     }
1087 
1088     // This method assumes handlerMetaZones is already initialized
1089     private static Set&lt;String&gt; getAvailableZoneIds() {
1090         assert handlerMetaZones != null;
1091         if (AVAILABLE_TZIDS == null) {
1092             AVAILABLE_TZIDS = new HashSet&lt;&gt;(ZoneId.getAvailableZoneIds());
1093             AVAILABLE_TZIDS.addAll(handlerMetaZones.keySet());
1094             AVAILABLE_TZIDS.remove(MetaZonesParseHandler.NO_METAZONE_KEY);
1095         }
1096 
1097         return AVAILABLE_TZIDS;
1098     }
1099 
1100     private static Stream&lt;String&gt; zidMapEntry() {
1101         return getAvailableZoneIds().stream()
1102                 .map(id -&gt; {
1103                     String canonId = canonicalTZMap.getOrDefault(id, id);
1104                     String meta = handlerMetaZones.get(canonId);
1105                     String zone001 = handlerMetaZones.zidMap().get(meta);
1106                     return zone001 == null ? &quot;&quot; :
1107                             String.format(&quot;        \&quot;%s\&quot;, \&quot;%s\&quot;, \&quot;%s\&quot;,&quot;,
1108                                             id, meta, zone001);
1109                 })
1110                 .filter(s -&gt; !s.isEmpty())
1111                 .sorted();
1112     }
1113 
1114     private static Stream&lt;String&gt; tzDataLinkEntry() {
1115         try {
1116             return Files.walk(Paths.get(tzDataDir), 1)
1117                 .filter(p -&gt; !Files.isDirectory(p))
1118                 .flatMap(CLDRConverter::extractLinks)
1119                 .sorted();
1120         } catch (IOException e) {
1121             throw new UncheckedIOException(e);
1122         }
1123     }
1124 
1125     private static Stream&lt;String&gt; extractLinks(Path tzFile) {
1126         try {
1127             return Files.lines(tzFile)
1128                 .filter(l -&gt; l.startsWith(&quot;Link&quot;))
1129                 .map(l -&gt; l.replaceFirst(&quot;^Link[\\s]+(\\S+)\\s+(\\S+).*&quot;,
1130                                          &quot;        \&quot;$2\&quot;, \&quot;$1\&quot;,&quot;));
1131         } catch (IOException e) {
1132             throw new UncheckedIOException(e);
1133         }
1134     }
1135 
1136     // Generate tzmappings for Windows. The format is:
1137     //
1138     // (Windows Zone Name):(REGION):(Java TZID)
1139     //
1140     // where:
1141     //   Windows Zone Name: arbitrary time zone name string used in Windows
1142     //   REGION: ISO3166 or UN M.49 code
1143     //   Java TZID: Java&#39;s time zone ID
1144     //
1145     // Note: the entries are alphabetically sorted, *except* the &quot;world&quot; region
1146     // code, i.e., &quot;001&quot;. It should be the last entry for the same windows time
1147     // zone name entries. (cf. TimeZone_md.c)
1148     private static void generateWindowsTZMappings() throws Exception {
1149         Files.createDirectories(Paths.get(DESTINATION_DIR, &quot;windows&quot;, &quot;conf&quot;));
1150         Files.write(Paths.get(DESTINATION_DIR, &quot;windows&quot;, &quot;conf&quot;, &quot;tzmappings&quot;),
1151             handlerWinZones.keySet().stream()
1152                 .map(k -&gt; k + &quot;:&quot; + handlerWinZones.get(k) + &quot;:&quot;)
1153                 .sorted(new Comparator&lt;String&gt;() {
1154                     public int compare(String t1, String t2) {
1155                         String[] s1 = t1.split(&quot;:&quot;);
1156                         String[] s2 = t2.split(&quot;:&quot;);
1157                         if (s1[0].equals(s2[0])) {
1158                             if (s1[1].equals(&quot;001&quot;)) {
1159                                 return 1;
1160                             } else if (s2[1].equals(&quot;001&quot;)) {
1161                                 return -1;
1162                             } else {
1163                                 return s1[1].compareTo(s2[1]);
1164                             }
1165                         } else {
1166                             return s1[0].compareTo(s2[0]);
1167                         }
1168                     }
1169                 })
1170                 .collect(Collectors.toList()),
1171             StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
1172     }
1173 
1174     /**
1175      * Generate ResourceBundle source file for plural rules. The generated
1176      * class is {@code sun.text.resources.PluralRules} which has one public
1177      * two dimensional array {@code rulesArray}. Each array element consists
1178      * of two elements that designate the locale and the locale&#39;s plural rules
1179      * string. The latter has the syntax from Unicode Consortium&#39;s
1180      * &lt;a href=&quot;http://unicode.org/reports/tr35/tr35-numbers.html#Plural_rules_syntax&quot;&gt;
1181      * Plural rules syntax&lt;/a&gt;. {@code samples} and {@code &quot;other&quot;} are being ommited.
1182      *
1183      * @throws Exception
1184      */
1185     private static void generatePluralRules() throws Exception {
1186         Files.createDirectories(Paths.get(DESTINATION_DIR, &quot;sun&quot;, &quot;text&quot;, &quot;resources&quot;));
1187         Files.write(Paths.get(DESTINATION_DIR, &quot;sun&quot;, &quot;text&quot;, &quot;resources&quot;, &quot;PluralRules.java&quot;),
1188             Stream.concat(
1189                 Stream.concat(
1190                     Stream.of(
1191                         &quot;package sun.text.resources;&quot;,
1192                         &quot;public final class PluralRules {&quot;,
1193                         &quot;    public static final String[][] rulesArray = {&quot;
1194                     ),
1195                     pluralRulesStream().sorted()
1196                 ),
1197                 Stream.of(
1198                     &quot;    };&quot;,
1199                     &quot;}&quot;
1200                 )
1201             )
1202             .collect(Collectors.toList()),
1203         StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
1204     }
1205 
1206     private static Stream&lt;String&gt; pluralRulesStream() {
1207         return handlerPlurals.getData().entrySet().stream()
1208             .filter(e -&gt; !((Map&lt;String, String&gt;)e.getValue()).isEmpty())
1209             .map(e -&gt; {
1210                 String loc = e.getKey();
1211                 Map&lt;String, String&gt; rules = (Map&lt;String, String&gt;)e.getValue();
1212                 return &quot;        {\&quot;&quot; + loc + &quot;\&quot;, \&quot;&quot; +
1213                     rules.entrySet().stream()
1214                         .map(rule -&gt; rule.getKey() + &quot;:&quot; + rule.getValue().replaceFirst(&quot;@.*&quot;, &quot;&quot;))
1215                         .map(String::trim)
1216                         .collect(Collectors.joining(&quot;;&quot;)) + &quot;\&quot;},&quot;;
1217             });
1218     }
1219 
1220     // for debug
1221     static void dumpMap(Map&lt;String, Object&gt; map) {
1222         map.entrySet().stream()
1223             .sorted(Map.Entry.comparingByKey())
1224             .map(e -&gt; {
1225                 Object val = e.getValue();
1226                 String valStr = null;
1227 
1228                 if (val instanceof String[]) {
1229                     valStr = Arrays.asList((String[])val).toString();
1230                 } else if (val != null) {
1231                     valStr = val.toString();
1232                 }
1233                 return e.getKey() + &quot; = &quot; + valStr;
1234             })
1235             .forEach(System.out::println);
1236     }
1237 }
1238 
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
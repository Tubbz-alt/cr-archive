<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff make/autoconf/toolchain_windows.m4</title>
    <link rel="stylesheet" href="../../style.css" />
  </head>
<body>
<center><a href="toolchain.m4.sdiff.html" target="_top">&lt; prev</a> <a href="../../index.html" target="_top">index</a> <a href="../common/FindTests.gmk.sdiff.html" target="_top">next &gt;</a></center>    <h2>make/autoconf/toolchain_windows.m4</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 95 VS_MSVCP_2019=msvcp140.dll
 96 VS_ENVVAR_2019=&quot;VS160COMNTOOLS&quot;
 97 VS_USE_UCRT_2019=&quot;true&quot;
 98 VS_VS_INSTALLDIR_2019=&quot;Microsoft Visual Studio/2019&quot;
 99 VS_EDITIONS_2019=&quot;BuildTools Community Professional Enterprise&quot;
100 VS_SDK_INSTALLDIR_2019=
101 VS_VS_PLATFORM_NAME_2019=&quot;v142&quot;
102 VS_SDK_PLATFORM_NAME_2019=
103 VS_SUPPORTED_2019=false
104 VS_TOOLSET_SUPPORTED_2019=false
105 
106 ################################################################################
107 
108 AC_DEFUN([TOOLCHAIN_CHECK_POSSIBLE_VISUAL_STUDIO_ROOT],
109 [
110   if test &quot;x$VS_ENV_CMD&quot; = x; then
111     VS_VERSION=&quot;$1&quot;
112     VS_BASE=&quot;$2&quot;
113     METHOD=&quot;$3&quot;
114 
<span class="line-modified">115     BASIC_WINDOWS_REWRITE_AS_UNIX_PATH(VS_BASE)</span>
116     # In VS 2017 and VS 2019, the default installation is in a subdir named after the edition.
117     # Find the first one present and use that.
118     if test &quot;x$VS_EDITIONS&quot; != x; then
119       for edition in $VS_EDITIONS; do
120         if test -d &quot;$VS_BASE/$edition&quot;; then
121           VS_BASE=&quot;$VS_BASE/$edition&quot;
122           break
123         fi
124       done
125     fi
126 
127     if test -d &quot;$VS_BASE&quot;; then
128       AC_MSG_NOTICE([Found Visual Studio installation at $VS_BASE using $METHOD])
129       if test &quot;x$OPENJDK_TARGET_CPU_BITS&quot; = x32; then
130         VCVARSFILES=&quot;vc/bin/vcvars32.bat vc/auxiliary/build/vcvars32.bat&quot;
131       else
132         VCVARSFILES=&quot;vc/bin/amd64/vcvars64.bat vc/bin/x86_amd64/vcvarsx86_amd64.bat \
133             VC/Auxiliary/Build/vcvarsx86_amd64.bat VC/Auxiliary/Build/vcvars64.bat&quot;
134       fi
135 
</pre>
<hr />
<pre>
143       if test &quot;x$VS_ENV_CMD&quot; = x; then
144         AC_MSG_NOTICE([Warning: None of $VCVARSFILES were found, Visual Studio installation not recognized. Ignoring])
145       else
146         # PLATFORM_TOOLSET is used during the compilation of the freetype sources
147         # (see &#39;LIB_BUILD_FREETYPE&#39; in libraries.m4) and must be one of &#39;v100&#39;,
148         # &#39;v110&#39; or &#39;v120&#39; for VS 2010, 2012 or VS2013
149         eval PLATFORM_TOOLSET=&quot;\${VS_VS_PLATFORM_NAME_${VS_VERSION}}&quot;
150       fi
151     fi
152   fi
153 ])
154 
155 ################################################################################
156 
157 AC_DEFUN([TOOLCHAIN_CHECK_POSSIBLE_WIN_SDK_ROOT],
158 [
159   if test &quot;x$VS_ENV_CMD&quot; = x; then
160     VS_VERSION=&quot;$1&quot;
161     WIN_SDK_BASE=&quot;$2&quot;
162     METHOD=&quot;$3&quot;
<span class="line-modified">163     BASIC_WINDOWS_REWRITE_AS_UNIX_PATH(WIN_SDK_BASE)</span>
164     if test -d &quot;$WIN_SDK_BASE&quot;; then
165       # There have been cases of partial or broken SDK installations. A missing
166       # lib dir is not going to work.
167       if test ! -d &quot;$WIN_SDK_BASE/lib&quot;; then
168         AC_MSG_NOTICE([Found Windows SDK installation at $WIN_SDK_BASE using $METHOD])
169         AC_MSG_NOTICE([Warning: Installation is broken, lib dir is missing. Ignoring])
170       elif test -f &quot;$WIN_SDK_BASE/Bin/SetEnv.Cmd&quot;; then
171         AC_MSG_NOTICE([Found Windows SDK installation at $WIN_SDK_BASE using $METHOD])
172         VS_ENV_CMD=&quot;$WIN_SDK_BASE/Bin/SetEnv.Cmd&quot;
173         if test &quot;x$OPENJDK_TARGET_CPU_BITS&quot; = x32; then
174           VS_ENV_ARGS=&quot;/x86&quot;
175         else
176           VS_ENV_ARGS=&quot;/x64&quot;
177         fi
178         # PLATFORM_TOOLSET is used during the compilation of the freetype sources (see
179         # &#39;LIB_BUILD_FREETYPE&#39; in libraries.m4) and must be &#39;Windows7.1SDK&#39; for Windows7.1SDK
180         # TODO: improve detection for other versions of SDK
181         eval PLATFORM_TOOLSET=&quot;\${VS_SDK_PLATFORM_NAME_${VS_VERSION}}&quot;
182       else
183         AC_MSG_NOTICE([Found Windows SDK installation at $WIN_SDK_BASE using $METHOD])
</pre>
<hr />
<pre>
296     VS_DESCRIPTION=&quot;$DEVKIT_NAME&quot;
297     if test &quot;x$VS_DESCRIPTION&quot; = x; then
298       eval VS_DESCRIPTION=&quot;\${VS_DESCRIPTION_${VS_VERSION}}&quot;
299     fi
300     eval VS_VERSION_INTERNAL=&quot;\${VS_VERSION_INTERNAL_${VS_VERSION}}&quot;
301     eval MSVCR_NAME=&quot;\${VS_MSVCR_${VS_VERSION}}&quot;
302     eval MSVCP_NAME=&quot;\${VS_MSVCP_${VS_VERSION}}&quot;
303     eval USE_UCRT=&quot;\${VS_USE_UCRT_${VS_VERSION}}&quot;
304     eval VS_SUPPORTED=&quot;\${VS_SUPPORTED_${VS_VERSION}}&quot;
305     eval PLATFORM_TOOLSET=&quot;\${VS_VS_PLATFORM_NAME_${VS_VERSION}}&quot;
306 
307     # The TOOLCHAIN_PATH from a devkit is in Unix format. In WSL we need a
308     # windows version of the complete VS_PATH as VS_PATH_WINDOWS
309     if test &quot;x$OPENJDK_BUILD_OS_ENV&quot; = &quot;xwindows.wsl&quot;; then
310       # Convert the toolchain path
311       OLDIFS=&quot;$IFS&quot;
312       IFS=&quot;:&quot;
313       VS_PATH_WINDOWS=&quot;&quot;
314       for i in $TOOLCHAIN_PATH; do
315         path=$i
<span class="line-modified">316         BASIC_WINDOWS_REWRITE_AS_WINDOWS_MIXED_PATH([path])</span>
317         VS_PATH_WINDOWS=&quot;$VS_PATH_WINDOWS;$path&quot;
318       done
319       IFS=&quot;$OLDIFS&quot;
320       # Append the current path from Windows env
321       WINDOWS_PATH=&quot;`$CMD /c echo %PATH%`&quot;
322       VS_PATH_WINDOWS=&quot;$VS_PATH_WINDOWS;$WINDOWS_PATH&quot;
323     else
324       VS_PATH=&quot;$TOOLCHAIN_PATH:$PATH&quot;
325     fi
326 
327     # Convert DEVKIT_VS_INCLUDE into windows style VS_INCLUDE so that it
328     # can still be exported as INCLUDE for compiler invocations without
329     # SYSROOT_CFLAGS
330     OLDIFS=&quot;$IFS&quot;
331     IFS=&quot;;&quot;
332     for i in $DEVKIT_VS_INCLUDE; do
333       ipath=$i
<span class="line-modified">334       BASIC_WINDOWS_REWRITE_AS_WINDOWS_MIXED_PATH([ipath])</span>
335       VS_INCLUDE=&quot;$VS_INCLUDE;$ipath&quot;
336     done
337     # Convert DEVKIT_VS_LIB into VS_LIB so that it can still be exported
338     # as LIB for compiler invocations without SYSROOT_LDFLAGS
339     for i in $DEVKIT_VS_LIB; do
340       libpath=$i
<span class="line-modified">341       BASIC_WINDOWS_REWRITE_AS_WINDOWS_MIXED_PATH([libpath])</span>
342       VS_LIB=&quot;$VS_LIB;$libpath&quot;
343     done
344     IFS=&quot;$OLDIFS&quot;
345 
346     AC_MSG_NOTICE([Found devkit $VS_DESCRIPTION])
347 
348   elif test &quot;x$with_toolchain_version&quot; != x; then
349     # User override; check that it is valid
350     if test &quot;x${VALID_VS_VERSIONS/$with_toolchain_version/}&quot; = &quot;x${VALID_VS_VERSIONS}&quot;; then
351       AC_MSG_NOTICE([Visual Studio version $with_toolchain_version is not valid.])
352       AC_MSG_NOTICE([Valid Visual Studio versions: $VALID_VS_VERSIONS.])
353       AC_MSG_ERROR([Cannot continue.])
354     fi
355     VS_VERSIONS_PROBE_LIST=&quot;$with_toolchain_version&quot;
356   else
357     # No flag given, use default
358     VS_VERSIONS_PROBE_LIST=&quot;$VALID_VS_VERSIONS&quot;
359   fi
360 
361   for VS_VERSION in $VS_VERSIONS_PROBE_LIST; do
</pre>
<hr />
<pre>
391   AC_PATH_PROG(CYGWIN_LINK, link.exe)
392   if test &quot;x$CYGWIN_LINK&quot; != x; then
393     AC_MSG_CHECKING([if the first found link.exe is actually the Cygwin link tool])
394     &quot;$CYGWIN_LINK&quot; --version &gt; /dev/null
395     if test $? -eq 0 ; then
396       AC_MSG_RESULT([yes])
397     else
398       AC_MSG_RESULT([no])
399       # This might be the VS linker. Don&#39;t exclude it later on.
400       CYGWIN_LINK=&quot;&quot;
401     fi
402   fi
403 
404   # First-hand choice is to locate and run the vsvars bat file.
405   TOOLCHAIN_FIND_VISUAL_STUDIO
406 
407   # If we have a devkit, skip all of the below.
408   if test &quot;x$DEVKIT_VS_VERSION&quot; = x; then
409     if test &quot;x$VS_ENV_CMD&quot; != x; then
410       # We have found a Visual Studio environment on disk, let&#39;s extract variables from the vsvars bat file.
<span class="line-modified">411       BASIC_FIXUP_EXECUTABLE(VS_ENV_CMD)</span>
412 
413       # Lets extract the variables that are set by vcvarsall.bat/vsvars32.bat/vsvars64.bat
414       AC_MSG_NOTICE([Trying to extract Visual Studio environment variables])
415 
416       # We need to create a couple of temporary files.
417       VS_ENV_TMP_DIR=&quot;$CONFIGURESUPPORT_OUTPUTDIR/vs-env&quot;
418       $MKDIR -p $VS_ENV_TMP_DIR
419 
420       # Cannot use the VS10 setup script directly (since it only updates the DOS subshell environment).
421       # Instead create a shell script which will set the relevant variables when run.
422       WINPATH_VS_ENV_CMD=&quot;$VS_ENV_CMD&quot;
<span class="line-modified">423       BASIC_WINDOWS_REWRITE_AS_WINDOWS_MIXED_PATH([WINPATH_VS_ENV_CMD])</span>
424 
425       if test &quot;x$OPENJDK_BUILD_OS_ENV&quot; = &quot;xwindows.wsl&quot;; then
426         WINPATH_BASH=&quot;bash&quot;
427       else
428         WINPATH_BASH=&quot;$BASH&quot;
<span class="line-modified">429         BASIC_WINDOWS_REWRITE_AS_WINDOWS_MIXED_PATH([WINPATH_BASH])</span>
430       fi
431 
432       # Generate a DOS batch file which runs $VS_ENV_CMD, and then creates a shell
433       # script (executable by bash) that will setup the important variables.
434       EXTRACT_VC_ENV_BAT_FILE=&quot;$VS_ENV_TMP_DIR/extract-vs-env.bat&quot;
435       $ECHO &quot;@echo off&quot; &gt;  $EXTRACT_VC_ENV_BAT_FILE
436       # This will end up something like:
437       # call C:/progra~2/micros~2.0/vc/bin/amd64/vcvars64.bat
438       $ECHO &quot;call \&quot;$WINPATH_VS_ENV_CMD\&quot; $VS_ENV_ARGS&quot; &gt;&gt; $EXTRACT_VC_ENV_BAT_FILE
439       # In some cases, the VS_ENV_CMD will change directory, change back so
440       # the set-vs-env.sh ends up in the right place.
441       $ECHO &#39;cd %~dp0&#39; &gt;&gt; $EXTRACT_VC_ENV_BAT_FILE
442       if test &quot;x$OPENJDK_BUILD_OS_ENV&quot; = &quot;xwindows.wsl&quot;; then
443         # These will end up something like:
444         # echo VS_PATH=\&quot;$PATH\&quot; &gt; set-vs-env.sh
445         # The trailing space for everyone except PATH is no typo, but is needed due
446         # to trailing \ in the Windows paths. These will be stripped later.
447         # Trying pure CMD extract. This results in windows paths that need to
448         # be converted post extraction, but a simpler script.
449         $ECHO &#39;echo VS_PATH=&quot;%PATH%&quot; &gt; set-vs-env.sh&#39; \
</pre>
<hr />
<pre>
504       . $VS_ENV_TMP_DIR/set-vs-env.sh
505       # Now we have VS_PATH, VS_INCLUDE, VS_LIB. For further checking, we
506       # also define VCINSTALLDIR, WindowsSdkDir and WINDOWSSDKDIR.
507 
508       # In WSL, the extracted VS_PATH is Windows style. This needs to be
509       # rewritten as Unix style and the Windows style version is saved
510       # in VS_PATH_WINDOWS.
511       if test &quot;x$OPENJDK_BUILD_OS_ENV&quot; = &quot;xwindows.wsl&quot;; then
512         OLDIFS=&quot;$IFS&quot;
513         IFS=&quot;;&quot;
514         # Convert VS_PATH to unix style
515         VS_PATH_WINDOWS=&quot;$VS_PATH&quot;
516         VS_PATH=&quot;&quot;
517         for i in $VS_PATH_WINDOWS; do
518           path=$i
519           # Only process non-empty elements
520           if test &quot;x$path&quot; != x; then
521             IFS=&quot;$OLDIFS&quot;
522             # Check that directory exists before calling fixup_path
523             testpath=$path
<span class="line-modified">524             BASIC_WINDOWS_REWRITE_AS_UNIX_PATH([testpath])</span>
525             if test -d &quot;$testpath&quot;; then
<span class="line-modified">526               BASIC_FIXUP_PATH([path])</span>
<span class="line-modified">527               BASIC_APPEND_TO_PATH(VS_PATH, $path)</span>
528             fi
529             IFS=&quot;;&quot;
530           fi
531         done
532         IFS=&quot;$OLDIFS&quot;
533       fi
534 
535     else
536       # We did not find a vsvars bat file, let&#39;s hope we are run from a VS command prompt.
537       AC_MSG_NOTICE([Cannot locate a valid Visual Studio installation, checking current environment])
538     fi
539   fi
540 
541   # At this point, we should have correct variables in the environment, or we can&#39;t continue.
542   AC_MSG_CHECKING([for Visual Studio variables])
543 
544   if test &quot;x$VCINSTALLDIR&quot; != x || test &quot;x$WindowsSDKDir&quot; != x \
545       || test &quot;x$WINDOWSSDKDIR&quot; != x || test &quot;x$DEVKIT_NAME&quot; != x; then
546     if test &quot;x$VS_INCLUDE&quot; = x || test &quot;x$VS_LIB&quot; = x; then
547       AC_MSG_RESULT([present but broken])
</pre>
<hr />
<pre>
559         WINDOWSSDKDIR=&quot;$WindowsSdkDir&quot;
560       fi
561       # Remove any paths containing # (typically F#) as that messes up make. This
562       # is needed if visual studio was installed with F# support.
563       VS_PATH=`$ECHO &quot;$VS_PATH&quot; | $SED &#39;s/[[^:#]]*#[^:]*://g&#39;`
564 
565       AC_SUBST(VS_PATH)
566       AC_SUBST(VS_INCLUDE)
567       AC_SUBST(VS_LIB)
568 
569       # Convert VS_INCLUDE into SYSROOT_CFLAGS
570       OLDIFS=&quot;$IFS&quot;
571       IFS=&quot;;&quot;
572       for i in $VS_INCLUDE; do
573         ipath=$i
574         # Only process non-empty elements
575         if test &quot;x$ipath&quot; != x; then
576           IFS=&quot;$OLDIFS&quot;
577           # Check that directory exists before calling fixup_path
578           testpath=$ipath
<span class="line-modified">579           BASIC_WINDOWS_REWRITE_AS_UNIX_PATH([testpath])</span>
580           if test -d &quot;$testpath&quot;; then
<span class="line-modified">581             BASIC_FIXUP_PATH([ipath])</span>
582             SYSROOT_CFLAGS=&quot;$SYSROOT_CFLAGS -I$ipath&quot;
583           fi
584           IFS=&quot;;&quot;
585         fi
586       done
587       # Convert VS_LIB into SYSROOT_LDFLAGS
588       for i in $VS_LIB; do
589         libpath=$i
590         # Only process non-empty elements
591         if test &quot;x$libpath&quot; != x; then
592           IFS=&quot;$OLDIFS&quot;
593           # Check that directory exists before calling fixup_path
594           testpath=$libpath
<span class="line-modified">595           BASIC_WINDOWS_REWRITE_AS_UNIX_PATH([testpath])</span>
596           if test -d &quot;$testpath&quot;; then
<span class="line-modified">597             BASIC_FIXUP_PATH([libpath])</span>
598             SYSROOT_LDFLAGS=&quot;$SYSROOT_LDFLAGS -libpath:$libpath&quot;
599           fi
600           IFS=&quot;;&quot;
601         fi
602       done
603       IFS=&quot;$OLDIFS&quot;
604 
605       AC_SUBST(VS_PATH_WINDOWS)
606     fi
607   else
608     AC_MSG_RESULT([not found])
609 
610     if test &quot;x$VS_ENV_CMD&quot; = x; then
611       AC_MSG_NOTICE([Cannot locate a valid Visual Studio or Windows SDK installation on disk,])
612       AC_MSG_NOTICE([nor is this script run from a Visual Studio command prompt.])
613     else
614       AC_MSG_NOTICE([Running the extraction script failed.])
615     fi
616     AC_MSG_NOTICE([Try setting --with-tools-dir to the VC/bin directory within the VS installation])
617     AC_MSG_NOTICE([or run &quot;bash.exe -l&quot; from a VS command prompt and then run configure from there.])
</pre>
<hr />
<pre>
648     if $ECHO &quot;$MSVC_DLL_FILETYPE&quot; | $GREP &quot;$CORRECT_MSVCR_ARCH&quot; 2&gt;&amp;1 &gt; /dev/null; then
649       AC_MSG_RESULT([ok])
650       MSVC_DLL=&quot;$POSSIBLE_MSVC_DLL&quot;
651       AC_MSG_CHECKING([for $DLL_NAME])
652       AC_MSG_RESULT([$MSVC_DLL])
653     else
654       AC_MSG_RESULT([incorrect, ignoring])
655       AC_MSG_NOTICE([The file type of the located $DLL_NAME is $MSVC_DLL_FILETYPE])
656     fi
657   fi
658 ])
659 
660 AC_DEFUN([TOOLCHAIN_SETUP_MSVC_DLL],
661 [
662   DLL_NAME=&quot;$1&quot;
663   MSVC_DLL=
664 
665   if test &quot;x$MSVC_DLL&quot; = x; then
666     if test &quot;x$VCINSTALLDIR&quot; != x; then
667       CYGWIN_VC_INSTALL_DIR=&quot;$VCINSTALLDIR&quot;
<span class="line-modified">668       BASIC_FIXUP_PATH(CYGWIN_VC_INSTALL_DIR)</span>
669       if test &quot;$VS_VERSION&quot; -lt 2017; then
670         # Probe: Using well-known location from Visual Studio 12.0 and older
671         if test &quot;x$OPENJDK_TARGET_CPU_BITS&quot; = x64; then
672           POSSIBLE_MSVC_DLL=&quot;$CYGWIN_VC_INSTALL_DIR/redist/x64/Microsoft.VC${VS_VERSION_INTERNAL}.CRT/$DLL_NAME&quot;
673         else
674           POSSIBLE_MSVC_DLL=&quot;$CYGWIN_VC_INSTALL_DIR/redist/x86/Microsoft.VC${VS_VERSION_INTERNAL}.CRT/$DLL_NAME&quot;
675         fi
676       else
677         CYGWIN_VC_TOOLS_REDIST_DIR=&quot;$VCToolsRedistDir&quot;
<span class="line-modified">678         BASIC_FIXUP_PATH(CYGWIN_VC_TOOLS_REDIST_DIR)</span>
679         # Probe: Using well-known location from VS 2017 and VS 2019
680         if test &quot;x$OPENJDK_TARGET_CPU_BITS&quot; = x64; then
681           POSSIBLE_MSVC_DLL=&quot;`ls $CYGWIN_VC_TOOLS_REDIST_DIR/x64/Microsoft.VC${VS_VERSION_INTERNAL}.CRT/$DLL_NAME`&quot;
682         else
683           POSSIBLE_MSVC_DLL=&quot;`ls $CYGWIN_VC_TOOLS_REDIST_DIR/x86/Microsoft.VC${VS_VERSION_INTERNAL}.CRT/$DLL_NAME`&quot;
684         fi
685       fi
686       # In case any of the above finds more than one file, loop over them.
687       for possible_msvc_dll in $POSSIBLE_MSVC_DLL; do
688         $ECHO &quot;POSSIBLE_MSVC_DLL $possible_msvc_dll&quot;
689         TOOLCHAIN_CHECK_POSSIBLE_MSVC_DLL([$DLL_NAME], [$possible_msvc_dll],
690             [well-known location in VCINSTALLDIR])
691       done
692     fi
693   fi
694 
695   if test &quot;x$MSVC_DLL&quot; = x; then
696     # Probe: Check in the Boot JDK directory.
697     POSSIBLE_MSVC_DLL=&quot;$BOOT_JDK/bin/$DLL_NAME&quot;
698     TOOLCHAIN_CHECK_POSSIBLE_MSVC_DLL([$DLL_NAME], [$POSSIBLE_MSVC_DLL],
699         [well-known location in Boot JDK])
700   fi
701 
702   if test &quot;x$MSVC_DLL&quot; = x; then
703     # Probe: Look in the Windows system32 directory
704     CYGWIN_SYSTEMROOT=&quot;$SYSTEMROOT&quot;
<span class="line-modified">705     BASIC_WINDOWS_REWRITE_AS_UNIX_PATH(CYGWIN_SYSTEMROOT)</span>
706     POSSIBLE_MSVC_DLL=&quot;$CYGWIN_SYSTEMROOT/system32/$DLL_NAME&quot;
707     TOOLCHAIN_CHECK_POSSIBLE_MSVC_DLL([$DLL_NAME], [$POSSIBLE_MSVC_DLL],
708         [well-known location in SYSTEMROOT])
709   fi
710 
711   if test &quot;x$MSVC_DLL&quot; = x; then
712     # Probe: If Visual Studio Express is installed, there is usually one with the debugger
713     if test &quot;x$VS100COMNTOOLS&quot; != x; then
714       CYGWIN_VS_TOOLS_DIR=&quot;$VS100COMNTOOLS/..&quot;
<span class="line-modified">715       BASIC_WINDOWS_REWRITE_AS_UNIX_PATH(CYGWIN_VS_TOOLS_DIR)</span>
716       if test &quot;x$OPENJDK_TARGET_CPU_BITS&quot; = x64; then
717         POSSIBLE_MSVC_DLL=`$FIND &quot;$CYGWIN_VS_TOOLS_DIR&quot; -name $DLL_NAME \
718         | $GREP -i /x64/ | $HEAD --lines 1`
719       else
720         POSSIBLE_MSVC_DLL=`$FIND &quot;$CYGWIN_VS_TOOLS_DIR&quot; -name $DLL_NAME \
721         | $GREP -i /x86/ | $HEAD --lines 1`
722       fi
723       TOOLCHAIN_CHECK_POSSIBLE_MSVC_DLL([$DLL_NAME], [$POSSIBLE_MSVC_DLL],
724           [search of VS100COMNTOOLS])
725     fi
726   fi
727 
728   if test &quot;x$MSVC_DLL&quot; = x; then
729     # Probe: Search wildly in the VCINSTALLDIR. We&#39;ve probably lost by now.
730     # (This was the original behaviour; kept since it might turn something up)
731     if test &quot;x$CYGWIN_VC_INSTALL_DIR&quot; != x; then
732       if test &quot;x$OPENJDK_TARGET_CPU_BITS&quot; = x64; then
733         POSSIBLE_MSVC_DLL=`$FIND &quot;$CYGWIN_VC_INSTALL_DIR&quot; -name $DLL_NAME \
734         | $GREP x64 | $HEAD --lines 1`
735       else
</pre>
<hr />
<pre>
797       MSVCP_DLL=&quot;$MSVC_DLL&quot;
798     else
799       TOOLCHAIN_SETUP_MSVC_DLL([${MSVCP_NAME}])
800       MSVCP_DLL=&quot;$MSVC_DLL&quot;
801     fi
802     AC_SUBST(MSVCP_DLL)
803   fi
804 
805   AC_ARG_WITH(ucrt-dll-dir, [AS_HELP_STRING([--with-ucrt-dll-dir],
806       [path to Microsoft Windows Kit UCRT DLL dir (Windows only) @&lt;:@probed@:&gt;@])])
807 
808   if test &quot;x$USE_UCRT&quot; = &quot;xtrue&quot;; then
809     AC_MSG_CHECKING([for UCRT DLL dir])
810     if test &quot;x$with_ucrt_dll_dir&quot; != x; then
811       if test -z &quot;$(ls -d &quot;$with_ucrt_dll_dir/&quot;*.dll 2&gt; /dev/null)&quot;; then
812         AC_MSG_RESULT([no])
813         AC_MSG_ERROR([Could not find any dlls in $with_ucrt_dll_dir])
814       else
815         AC_MSG_RESULT([$with_ucrt_dll_dir])
816         UCRT_DLL_DIR=&quot;$with_ucrt_dll_dir&quot;
<span class="line-modified">817         BASIC_FIXUP_PATH([UCRT_DLL_DIR])</span>
818       fi
819     elif test &quot;x$DEVKIT_UCRT_DLL_DIR&quot; != &quot;x&quot;; then
820       UCRT_DLL_DIR=&quot;$DEVKIT_UCRT_DLL_DIR&quot;
821       AC_MSG_RESULT($UCRT_DLL_DIR)
822     else
823       CYGWIN_WINDOWSSDKDIR=&quot;${WINDOWSSDKDIR}&quot;
<span class="line-modified">824       BASIC_FIXUP_PATH([CYGWIN_WINDOWSSDKDIR])</span>
825       dll_subdir=$OPENJDK_TARGET_CPU
826       if test &quot;x$dll_subdir&quot; = &quot;xx86_64&quot;; then
827         dll_subdir=&quot;x64&quot;
828       fi
829       UCRT_DLL_DIR=&quot;$CYGWIN_WINDOWSSDKDIR/Redist/ucrt/DLLs/$dll_subdir&quot;
830       if test -z &quot;$(ls -d &quot;$UCRT_DLL_DIR/&quot;*.dll 2&gt; /dev/null)&quot;; then
831         # Try with version subdir
832         UCRT_DLL_DIR=&quot;`ls -d $CYGWIN_WINDOWSSDKDIR/Redist/*/ucrt/DLLs/$dll_subdir \
833             2&gt; /dev/null | $SORT -d | $HEAD -n1`&quot;
834         if test -z &quot;$UCRT_DLL_DIR&quot; \
835             || test -z &quot;$(ls -d &quot;$UCRT_DLL_DIR/&quot;*.dll 2&gt; /dev/null)&quot;; then
836           AC_MSG_RESULT([no])
837           AC_MSG_ERROR([Could not find any dlls in $UCRT_DLL_DIR])
838         else
839           AC_MSG_RESULT($UCRT_DLL_DIR)
840         fi
841       else
842         AC_MSG_RESULT($UCRT_DLL_DIR)
843       fi
844     fi
</pre>
</td>
<td>
<hr />
<pre>
 95 VS_MSVCP_2019=msvcp140.dll
 96 VS_ENVVAR_2019=&quot;VS160COMNTOOLS&quot;
 97 VS_USE_UCRT_2019=&quot;true&quot;
 98 VS_VS_INSTALLDIR_2019=&quot;Microsoft Visual Studio/2019&quot;
 99 VS_EDITIONS_2019=&quot;BuildTools Community Professional Enterprise&quot;
100 VS_SDK_INSTALLDIR_2019=
101 VS_VS_PLATFORM_NAME_2019=&quot;v142&quot;
102 VS_SDK_PLATFORM_NAME_2019=
103 VS_SUPPORTED_2019=false
104 VS_TOOLSET_SUPPORTED_2019=false
105 
106 ################################################################################
107 
108 AC_DEFUN([TOOLCHAIN_CHECK_POSSIBLE_VISUAL_STUDIO_ROOT],
109 [
110   if test &quot;x$VS_ENV_CMD&quot; = x; then
111     VS_VERSION=&quot;$1&quot;
112     VS_BASE=&quot;$2&quot;
113     METHOD=&quot;$3&quot;
114 
<span class="line-modified">115     UTIL_REWRITE_AS_UNIX_PATH(VS_BASE)</span>
116     # In VS 2017 and VS 2019, the default installation is in a subdir named after the edition.
117     # Find the first one present and use that.
118     if test &quot;x$VS_EDITIONS&quot; != x; then
119       for edition in $VS_EDITIONS; do
120         if test -d &quot;$VS_BASE/$edition&quot;; then
121           VS_BASE=&quot;$VS_BASE/$edition&quot;
122           break
123         fi
124       done
125     fi
126 
127     if test -d &quot;$VS_BASE&quot;; then
128       AC_MSG_NOTICE([Found Visual Studio installation at $VS_BASE using $METHOD])
129       if test &quot;x$OPENJDK_TARGET_CPU_BITS&quot; = x32; then
130         VCVARSFILES=&quot;vc/bin/vcvars32.bat vc/auxiliary/build/vcvars32.bat&quot;
131       else
132         VCVARSFILES=&quot;vc/bin/amd64/vcvars64.bat vc/bin/x86_amd64/vcvarsx86_amd64.bat \
133             VC/Auxiliary/Build/vcvarsx86_amd64.bat VC/Auxiliary/Build/vcvars64.bat&quot;
134       fi
135 
</pre>
<hr />
<pre>
143       if test &quot;x$VS_ENV_CMD&quot; = x; then
144         AC_MSG_NOTICE([Warning: None of $VCVARSFILES were found, Visual Studio installation not recognized. Ignoring])
145       else
146         # PLATFORM_TOOLSET is used during the compilation of the freetype sources
147         # (see &#39;LIB_BUILD_FREETYPE&#39; in libraries.m4) and must be one of &#39;v100&#39;,
148         # &#39;v110&#39; or &#39;v120&#39; for VS 2010, 2012 or VS2013
149         eval PLATFORM_TOOLSET=&quot;\${VS_VS_PLATFORM_NAME_${VS_VERSION}}&quot;
150       fi
151     fi
152   fi
153 ])
154 
155 ################################################################################
156 
157 AC_DEFUN([TOOLCHAIN_CHECK_POSSIBLE_WIN_SDK_ROOT],
158 [
159   if test &quot;x$VS_ENV_CMD&quot; = x; then
160     VS_VERSION=&quot;$1&quot;
161     WIN_SDK_BASE=&quot;$2&quot;
162     METHOD=&quot;$3&quot;
<span class="line-modified">163     UTIL_REWRITE_AS_UNIX_PATH(WIN_SDK_BASE)</span>
164     if test -d &quot;$WIN_SDK_BASE&quot;; then
165       # There have been cases of partial or broken SDK installations. A missing
166       # lib dir is not going to work.
167       if test ! -d &quot;$WIN_SDK_BASE/lib&quot;; then
168         AC_MSG_NOTICE([Found Windows SDK installation at $WIN_SDK_BASE using $METHOD])
169         AC_MSG_NOTICE([Warning: Installation is broken, lib dir is missing. Ignoring])
170       elif test -f &quot;$WIN_SDK_BASE/Bin/SetEnv.Cmd&quot;; then
171         AC_MSG_NOTICE([Found Windows SDK installation at $WIN_SDK_BASE using $METHOD])
172         VS_ENV_CMD=&quot;$WIN_SDK_BASE/Bin/SetEnv.Cmd&quot;
173         if test &quot;x$OPENJDK_TARGET_CPU_BITS&quot; = x32; then
174           VS_ENV_ARGS=&quot;/x86&quot;
175         else
176           VS_ENV_ARGS=&quot;/x64&quot;
177         fi
178         # PLATFORM_TOOLSET is used during the compilation of the freetype sources (see
179         # &#39;LIB_BUILD_FREETYPE&#39; in libraries.m4) and must be &#39;Windows7.1SDK&#39; for Windows7.1SDK
180         # TODO: improve detection for other versions of SDK
181         eval PLATFORM_TOOLSET=&quot;\${VS_SDK_PLATFORM_NAME_${VS_VERSION}}&quot;
182       else
183         AC_MSG_NOTICE([Found Windows SDK installation at $WIN_SDK_BASE using $METHOD])
</pre>
<hr />
<pre>
296     VS_DESCRIPTION=&quot;$DEVKIT_NAME&quot;
297     if test &quot;x$VS_DESCRIPTION&quot; = x; then
298       eval VS_DESCRIPTION=&quot;\${VS_DESCRIPTION_${VS_VERSION}}&quot;
299     fi
300     eval VS_VERSION_INTERNAL=&quot;\${VS_VERSION_INTERNAL_${VS_VERSION}}&quot;
301     eval MSVCR_NAME=&quot;\${VS_MSVCR_${VS_VERSION}}&quot;
302     eval MSVCP_NAME=&quot;\${VS_MSVCP_${VS_VERSION}}&quot;
303     eval USE_UCRT=&quot;\${VS_USE_UCRT_${VS_VERSION}}&quot;
304     eval VS_SUPPORTED=&quot;\${VS_SUPPORTED_${VS_VERSION}}&quot;
305     eval PLATFORM_TOOLSET=&quot;\${VS_VS_PLATFORM_NAME_${VS_VERSION}}&quot;
306 
307     # The TOOLCHAIN_PATH from a devkit is in Unix format. In WSL we need a
308     # windows version of the complete VS_PATH as VS_PATH_WINDOWS
309     if test &quot;x$OPENJDK_BUILD_OS_ENV&quot; = &quot;xwindows.wsl&quot;; then
310       # Convert the toolchain path
311       OLDIFS=&quot;$IFS&quot;
312       IFS=&quot;:&quot;
313       VS_PATH_WINDOWS=&quot;&quot;
314       for i in $TOOLCHAIN_PATH; do
315         path=$i
<span class="line-modified">316         UTIL_REWRITE_AS_WINDOWS_MIXED_PATH([path])</span>
317         VS_PATH_WINDOWS=&quot;$VS_PATH_WINDOWS;$path&quot;
318       done
319       IFS=&quot;$OLDIFS&quot;
320       # Append the current path from Windows env
321       WINDOWS_PATH=&quot;`$CMD /c echo %PATH%`&quot;
322       VS_PATH_WINDOWS=&quot;$VS_PATH_WINDOWS;$WINDOWS_PATH&quot;
323     else
324       VS_PATH=&quot;$TOOLCHAIN_PATH:$PATH&quot;
325     fi
326 
327     # Convert DEVKIT_VS_INCLUDE into windows style VS_INCLUDE so that it
328     # can still be exported as INCLUDE for compiler invocations without
329     # SYSROOT_CFLAGS
330     OLDIFS=&quot;$IFS&quot;
331     IFS=&quot;;&quot;
332     for i in $DEVKIT_VS_INCLUDE; do
333       ipath=$i
<span class="line-modified">334       UTIL_REWRITE_AS_WINDOWS_MIXED_PATH([ipath])</span>
335       VS_INCLUDE=&quot;$VS_INCLUDE;$ipath&quot;
336     done
337     # Convert DEVKIT_VS_LIB into VS_LIB so that it can still be exported
338     # as LIB for compiler invocations without SYSROOT_LDFLAGS
339     for i in $DEVKIT_VS_LIB; do
340       libpath=$i
<span class="line-modified">341       UTIL_REWRITE_AS_WINDOWS_MIXED_PATH([libpath])</span>
342       VS_LIB=&quot;$VS_LIB;$libpath&quot;
343     done
344     IFS=&quot;$OLDIFS&quot;
345 
346     AC_MSG_NOTICE([Found devkit $VS_DESCRIPTION])
347 
348   elif test &quot;x$with_toolchain_version&quot; != x; then
349     # User override; check that it is valid
350     if test &quot;x${VALID_VS_VERSIONS/$with_toolchain_version/}&quot; = &quot;x${VALID_VS_VERSIONS}&quot;; then
351       AC_MSG_NOTICE([Visual Studio version $with_toolchain_version is not valid.])
352       AC_MSG_NOTICE([Valid Visual Studio versions: $VALID_VS_VERSIONS.])
353       AC_MSG_ERROR([Cannot continue.])
354     fi
355     VS_VERSIONS_PROBE_LIST=&quot;$with_toolchain_version&quot;
356   else
357     # No flag given, use default
358     VS_VERSIONS_PROBE_LIST=&quot;$VALID_VS_VERSIONS&quot;
359   fi
360 
361   for VS_VERSION in $VS_VERSIONS_PROBE_LIST; do
</pre>
<hr />
<pre>
391   AC_PATH_PROG(CYGWIN_LINK, link.exe)
392   if test &quot;x$CYGWIN_LINK&quot; != x; then
393     AC_MSG_CHECKING([if the first found link.exe is actually the Cygwin link tool])
394     &quot;$CYGWIN_LINK&quot; --version &gt; /dev/null
395     if test $? -eq 0 ; then
396       AC_MSG_RESULT([yes])
397     else
398       AC_MSG_RESULT([no])
399       # This might be the VS linker. Don&#39;t exclude it later on.
400       CYGWIN_LINK=&quot;&quot;
401     fi
402   fi
403 
404   # First-hand choice is to locate and run the vsvars bat file.
405   TOOLCHAIN_FIND_VISUAL_STUDIO
406 
407   # If we have a devkit, skip all of the below.
408   if test &quot;x$DEVKIT_VS_VERSION&quot; = x; then
409     if test &quot;x$VS_ENV_CMD&quot; != x; then
410       # We have found a Visual Studio environment on disk, let&#39;s extract variables from the vsvars bat file.
<span class="line-modified">411       UTIL_FIXUP_EXECUTABLE(VS_ENV_CMD)</span>
412 
413       # Lets extract the variables that are set by vcvarsall.bat/vsvars32.bat/vsvars64.bat
414       AC_MSG_NOTICE([Trying to extract Visual Studio environment variables])
415 
416       # We need to create a couple of temporary files.
417       VS_ENV_TMP_DIR=&quot;$CONFIGURESUPPORT_OUTPUTDIR/vs-env&quot;
418       $MKDIR -p $VS_ENV_TMP_DIR
419 
420       # Cannot use the VS10 setup script directly (since it only updates the DOS subshell environment).
421       # Instead create a shell script which will set the relevant variables when run.
422       WINPATH_VS_ENV_CMD=&quot;$VS_ENV_CMD&quot;
<span class="line-modified">423       UTIL_REWRITE_AS_WINDOWS_MIXED_PATH([WINPATH_VS_ENV_CMD])</span>
424 
425       if test &quot;x$OPENJDK_BUILD_OS_ENV&quot; = &quot;xwindows.wsl&quot;; then
426         WINPATH_BASH=&quot;bash&quot;
427       else
428         WINPATH_BASH=&quot;$BASH&quot;
<span class="line-modified">429         UTIL_REWRITE_AS_WINDOWS_MIXED_PATH([WINPATH_BASH])</span>
430       fi
431 
432       # Generate a DOS batch file which runs $VS_ENV_CMD, and then creates a shell
433       # script (executable by bash) that will setup the important variables.
434       EXTRACT_VC_ENV_BAT_FILE=&quot;$VS_ENV_TMP_DIR/extract-vs-env.bat&quot;
435       $ECHO &quot;@echo off&quot; &gt;  $EXTRACT_VC_ENV_BAT_FILE
436       # This will end up something like:
437       # call C:/progra~2/micros~2.0/vc/bin/amd64/vcvars64.bat
438       $ECHO &quot;call \&quot;$WINPATH_VS_ENV_CMD\&quot; $VS_ENV_ARGS&quot; &gt;&gt; $EXTRACT_VC_ENV_BAT_FILE
439       # In some cases, the VS_ENV_CMD will change directory, change back so
440       # the set-vs-env.sh ends up in the right place.
441       $ECHO &#39;cd %~dp0&#39; &gt;&gt; $EXTRACT_VC_ENV_BAT_FILE
442       if test &quot;x$OPENJDK_BUILD_OS_ENV&quot; = &quot;xwindows.wsl&quot;; then
443         # These will end up something like:
444         # echo VS_PATH=\&quot;$PATH\&quot; &gt; set-vs-env.sh
445         # The trailing space for everyone except PATH is no typo, but is needed due
446         # to trailing \ in the Windows paths. These will be stripped later.
447         # Trying pure CMD extract. This results in windows paths that need to
448         # be converted post extraction, but a simpler script.
449         $ECHO &#39;echo VS_PATH=&quot;%PATH%&quot; &gt; set-vs-env.sh&#39; \
</pre>
<hr />
<pre>
504       . $VS_ENV_TMP_DIR/set-vs-env.sh
505       # Now we have VS_PATH, VS_INCLUDE, VS_LIB. For further checking, we
506       # also define VCINSTALLDIR, WindowsSdkDir and WINDOWSSDKDIR.
507 
508       # In WSL, the extracted VS_PATH is Windows style. This needs to be
509       # rewritten as Unix style and the Windows style version is saved
510       # in VS_PATH_WINDOWS.
511       if test &quot;x$OPENJDK_BUILD_OS_ENV&quot; = &quot;xwindows.wsl&quot;; then
512         OLDIFS=&quot;$IFS&quot;
513         IFS=&quot;;&quot;
514         # Convert VS_PATH to unix style
515         VS_PATH_WINDOWS=&quot;$VS_PATH&quot;
516         VS_PATH=&quot;&quot;
517         for i in $VS_PATH_WINDOWS; do
518           path=$i
519           # Only process non-empty elements
520           if test &quot;x$path&quot; != x; then
521             IFS=&quot;$OLDIFS&quot;
522             # Check that directory exists before calling fixup_path
523             testpath=$path
<span class="line-modified">524             UTIL_REWRITE_AS_UNIX_PATH([testpath])</span>
525             if test -d &quot;$testpath&quot;; then
<span class="line-modified">526               UTIL_FIXUP_PATH([path])</span>
<span class="line-modified">527               UTIL_APPEND_TO_PATH(VS_PATH, $path)</span>
528             fi
529             IFS=&quot;;&quot;
530           fi
531         done
532         IFS=&quot;$OLDIFS&quot;
533       fi
534 
535     else
536       # We did not find a vsvars bat file, let&#39;s hope we are run from a VS command prompt.
537       AC_MSG_NOTICE([Cannot locate a valid Visual Studio installation, checking current environment])
538     fi
539   fi
540 
541   # At this point, we should have correct variables in the environment, or we can&#39;t continue.
542   AC_MSG_CHECKING([for Visual Studio variables])
543 
544   if test &quot;x$VCINSTALLDIR&quot; != x || test &quot;x$WindowsSDKDir&quot; != x \
545       || test &quot;x$WINDOWSSDKDIR&quot; != x || test &quot;x$DEVKIT_NAME&quot; != x; then
546     if test &quot;x$VS_INCLUDE&quot; = x || test &quot;x$VS_LIB&quot; = x; then
547       AC_MSG_RESULT([present but broken])
</pre>
<hr />
<pre>
559         WINDOWSSDKDIR=&quot;$WindowsSdkDir&quot;
560       fi
561       # Remove any paths containing # (typically F#) as that messes up make. This
562       # is needed if visual studio was installed with F# support.
563       VS_PATH=`$ECHO &quot;$VS_PATH&quot; | $SED &#39;s/[[^:#]]*#[^:]*://g&#39;`
564 
565       AC_SUBST(VS_PATH)
566       AC_SUBST(VS_INCLUDE)
567       AC_SUBST(VS_LIB)
568 
569       # Convert VS_INCLUDE into SYSROOT_CFLAGS
570       OLDIFS=&quot;$IFS&quot;
571       IFS=&quot;;&quot;
572       for i in $VS_INCLUDE; do
573         ipath=$i
574         # Only process non-empty elements
575         if test &quot;x$ipath&quot; != x; then
576           IFS=&quot;$OLDIFS&quot;
577           # Check that directory exists before calling fixup_path
578           testpath=$ipath
<span class="line-modified">579           UTIL_REWRITE_AS_UNIX_PATH([testpath])</span>
580           if test -d &quot;$testpath&quot;; then
<span class="line-modified">581             UTIL_FIXUP_PATH([ipath])</span>
582             SYSROOT_CFLAGS=&quot;$SYSROOT_CFLAGS -I$ipath&quot;
583           fi
584           IFS=&quot;;&quot;
585         fi
586       done
587       # Convert VS_LIB into SYSROOT_LDFLAGS
588       for i in $VS_LIB; do
589         libpath=$i
590         # Only process non-empty elements
591         if test &quot;x$libpath&quot; != x; then
592           IFS=&quot;$OLDIFS&quot;
593           # Check that directory exists before calling fixup_path
594           testpath=$libpath
<span class="line-modified">595           UTIL_REWRITE_AS_UNIX_PATH([testpath])</span>
596           if test -d &quot;$testpath&quot;; then
<span class="line-modified">597             UTIL_FIXUP_PATH([libpath])</span>
598             SYSROOT_LDFLAGS=&quot;$SYSROOT_LDFLAGS -libpath:$libpath&quot;
599           fi
600           IFS=&quot;;&quot;
601         fi
602       done
603       IFS=&quot;$OLDIFS&quot;
604 
605       AC_SUBST(VS_PATH_WINDOWS)
606     fi
607   else
608     AC_MSG_RESULT([not found])
609 
610     if test &quot;x$VS_ENV_CMD&quot; = x; then
611       AC_MSG_NOTICE([Cannot locate a valid Visual Studio or Windows SDK installation on disk,])
612       AC_MSG_NOTICE([nor is this script run from a Visual Studio command prompt.])
613     else
614       AC_MSG_NOTICE([Running the extraction script failed.])
615     fi
616     AC_MSG_NOTICE([Try setting --with-tools-dir to the VC/bin directory within the VS installation])
617     AC_MSG_NOTICE([or run &quot;bash.exe -l&quot; from a VS command prompt and then run configure from there.])
</pre>
<hr />
<pre>
648     if $ECHO &quot;$MSVC_DLL_FILETYPE&quot; | $GREP &quot;$CORRECT_MSVCR_ARCH&quot; 2&gt;&amp;1 &gt; /dev/null; then
649       AC_MSG_RESULT([ok])
650       MSVC_DLL=&quot;$POSSIBLE_MSVC_DLL&quot;
651       AC_MSG_CHECKING([for $DLL_NAME])
652       AC_MSG_RESULT([$MSVC_DLL])
653     else
654       AC_MSG_RESULT([incorrect, ignoring])
655       AC_MSG_NOTICE([The file type of the located $DLL_NAME is $MSVC_DLL_FILETYPE])
656     fi
657   fi
658 ])
659 
660 AC_DEFUN([TOOLCHAIN_SETUP_MSVC_DLL],
661 [
662   DLL_NAME=&quot;$1&quot;
663   MSVC_DLL=
664 
665   if test &quot;x$MSVC_DLL&quot; = x; then
666     if test &quot;x$VCINSTALLDIR&quot; != x; then
667       CYGWIN_VC_INSTALL_DIR=&quot;$VCINSTALLDIR&quot;
<span class="line-modified">668       UTIL_FIXUP_PATH(CYGWIN_VC_INSTALL_DIR)</span>
669       if test &quot;$VS_VERSION&quot; -lt 2017; then
670         # Probe: Using well-known location from Visual Studio 12.0 and older
671         if test &quot;x$OPENJDK_TARGET_CPU_BITS&quot; = x64; then
672           POSSIBLE_MSVC_DLL=&quot;$CYGWIN_VC_INSTALL_DIR/redist/x64/Microsoft.VC${VS_VERSION_INTERNAL}.CRT/$DLL_NAME&quot;
673         else
674           POSSIBLE_MSVC_DLL=&quot;$CYGWIN_VC_INSTALL_DIR/redist/x86/Microsoft.VC${VS_VERSION_INTERNAL}.CRT/$DLL_NAME&quot;
675         fi
676       else
677         CYGWIN_VC_TOOLS_REDIST_DIR=&quot;$VCToolsRedistDir&quot;
<span class="line-modified">678         UTIL_FIXUP_PATH(CYGWIN_VC_TOOLS_REDIST_DIR)</span>
679         # Probe: Using well-known location from VS 2017 and VS 2019
680         if test &quot;x$OPENJDK_TARGET_CPU_BITS&quot; = x64; then
681           POSSIBLE_MSVC_DLL=&quot;`ls $CYGWIN_VC_TOOLS_REDIST_DIR/x64/Microsoft.VC${VS_VERSION_INTERNAL}.CRT/$DLL_NAME`&quot;
682         else
683           POSSIBLE_MSVC_DLL=&quot;`ls $CYGWIN_VC_TOOLS_REDIST_DIR/x86/Microsoft.VC${VS_VERSION_INTERNAL}.CRT/$DLL_NAME`&quot;
684         fi
685       fi
686       # In case any of the above finds more than one file, loop over them.
687       for possible_msvc_dll in $POSSIBLE_MSVC_DLL; do
688         $ECHO &quot;POSSIBLE_MSVC_DLL $possible_msvc_dll&quot;
689         TOOLCHAIN_CHECK_POSSIBLE_MSVC_DLL([$DLL_NAME], [$possible_msvc_dll],
690             [well-known location in VCINSTALLDIR])
691       done
692     fi
693   fi
694 
695   if test &quot;x$MSVC_DLL&quot; = x; then
696     # Probe: Check in the Boot JDK directory.
697     POSSIBLE_MSVC_DLL=&quot;$BOOT_JDK/bin/$DLL_NAME&quot;
698     TOOLCHAIN_CHECK_POSSIBLE_MSVC_DLL([$DLL_NAME], [$POSSIBLE_MSVC_DLL],
699         [well-known location in Boot JDK])
700   fi
701 
702   if test &quot;x$MSVC_DLL&quot; = x; then
703     # Probe: Look in the Windows system32 directory
704     CYGWIN_SYSTEMROOT=&quot;$SYSTEMROOT&quot;
<span class="line-modified">705     UTIL_REWRITE_AS_UNIX_PATH(CYGWIN_SYSTEMROOT)</span>
706     POSSIBLE_MSVC_DLL=&quot;$CYGWIN_SYSTEMROOT/system32/$DLL_NAME&quot;
707     TOOLCHAIN_CHECK_POSSIBLE_MSVC_DLL([$DLL_NAME], [$POSSIBLE_MSVC_DLL],
708         [well-known location in SYSTEMROOT])
709   fi
710 
711   if test &quot;x$MSVC_DLL&quot; = x; then
712     # Probe: If Visual Studio Express is installed, there is usually one with the debugger
713     if test &quot;x$VS100COMNTOOLS&quot; != x; then
714       CYGWIN_VS_TOOLS_DIR=&quot;$VS100COMNTOOLS/..&quot;
<span class="line-modified">715       UTIL_REWRITE_AS_UNIX_PATH(CYGWIN_VS_TOOLS_DIR)</span>
716       if test &quot;x$OPENJDK_TARGET_CPU_BITS&quot; = x64; then
717         POSSIBLE_MSVC_DLL=`$FIND &quot;$CYGWIN_VS_TOOLS_DIR&quot; -name $DLL_NAME \
718         | $GREP -i /x64/ | $HEAD --lines 1`
719       else
720         POSSIBLE_MSVC_DLL=`$FIND &quot;$CYGWIN_VS_TOOLS_DIR&quot; -name $DLL_NAME \
721         | $GREP -i /x86/ | $HEAD --lines 1`
722       fi
723       TOOLCHAIN_CHECK_POSSIBLE_MSVC_DLL([$DLL_NAME], [$POSSIBLE_MSVC_DLL],
724           [search of VS100COMNTOOLS])
725     fi
726   fi
727 
728   if test &quot;x$MSVC_DLL&quot; = x; then
729     # Probe: Search wildly in the VCINSTALLDIR. We&#39;ve probably lost by now.
730     # (This was the original behaviour; kept since it might turn something up)
731     if test &quot;x$CYGWIN_VC_INSTALL_DIR&quot; != x; then
732       if test &quot;x$OPENJDK_TARGET_CPU_BITS&quot; = x64; then
733         POSSIBLE_MSVC_DLL=`$FIND &quot;$CYGWIN_VC_INSTALL_DIR&quot; -name $DLL_NAME \
734         | $GREP x64 | $HEAD --lines 1`
735       else
</pre>
<hr />
<pre>
797       MSVCP_DLL=&quot;$MSVC_DLL&quot;
798     else
799       TOOLCHAIN_SETUP_MSVC_DLL([${MSVCP_NAME}])
800       MSVCP_DLL=&quot;$MSVC_DLL&quot;
801     fi
802     AC_SUBST(MSVCP_DLL)
803   fi
804 
805   AC_ARG_WITH(ucrt-dll-dir, [AS_HELP_STRING([--with-ucrt-dll-dir],
806       [path to Microsoft Windows Kit UCRT DLL dir (Windows only) @&lt;:@probed@:&gt;@])])
807 
808   if test &quot;x$USE_UCRT&quot; = &quot;xtrue&quot;; then
809     AC_MSG_CHECKING([for UCRT DLL dir])
810     if test &quot;x$with_ucrt_dll_dir&quot; != x; then
811       if test -z &quot;$(ls -d &quot;$with_ucrt_dll_dir/&quot;*.dll 2&gt; /dev/null)&quot;; then
812         AC_MSG_RESULT([no])
813         AC_MSG_ERROR([Could not find any dlls in $with_ucrt_dll_dir])
814       else
815         AC_MSG_RESULT([$with_ucrt_dll_dir])
816         UCRT_DLL_DIR=&quot;$with_ucrt_dll_dir&quot;
<span class="line-modified">817         UTIL_FIXUP_PATH([UCRT_DLL_DIR])</span>
818       fi
819     elif test &quot;x$DEVKIT_UCRT_DLL_DIR&quot; != &quot;x&quot;; then
820       UCRT_DLL_DIR=&quot;$DEVKIT_UCRT_DLL_DIR&quot;
821       AC_MSG_RESULT($UCRT_DLL_DIR)
822     else
823       CYGWIN_WINDOWSSDKDIR=&quot;${WINDOWSSDKDIR}&quot;
<span class="line-modified">824       UTIL_FIXUP_PATH([CYGWIN_WINDOWSSDKDIR])</span>
825       dll_subdir=$OPENJDK_TARGET_CPU
826       if test &quot;x$dll_subdir&quot; = &quot;xx86_64&quot;; then
827         dll_subdir=&quot;x64&quot;
828       fi
829       UCRT_DLL_DIR=&quot;$CYGWIN_WINDOWSSDKDIR/Redist/ucrt/DLLs/$dll_subdir&quot;
830       if test -z &quot;$(ls -d &quot;$UCRT_DLL_DIR/&quot;*.dll 2&gt; /dev/null)&quot;; then
831         # Try with version subdir
832         UCRT_DLL_DIR=&quot;`ls -d $CYGWIN_WINDOWSSDKDIR/Redist/*/ucrt/DLLs/$dll_subdir \
833             2&gt; /dev/null | $SORT -d | $HEAD -n1`&quot;
834         if test -z &quot;$UCRT_DLL_DIR&quot; \
835             || test -z &quot;$(ls -d &quot;$UCRT_DLL_DIR/&quot;*.dll 2&gt; /dev/null)&quot;; then
836           AC_MSG_RESULT([no])
837           AC_MSG_ERROR([Could not find any dlls in $UCRT_DLL_DIR])
838         else
839           AC_MSG_RESULT($UCRT_DLL_DIR)
840         fi
841       else
842         AC_MSG_RESULT($UCRT_DLL_DIR)
843       fi
844     fi
</pre>
</td>
</tr>
</table>
<center><a href="toolchain.m4.sdiff.html" target="_top">&lt; prev</a> <a href="../../index.html" target="_top">index</a> <a href="../common/FindTests.gmk.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
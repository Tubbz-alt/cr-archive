diff a/make/autoconf/spec.gmk.in b/make/autoconf/spec.gmk.in
--- a/make/autoconf/spec.gmk.in
+++ b/make/autoconf/spec.gmk.in
@@ -563,10 +563,12 @@
 OBJDUMP:=@OBJDUMP@
 CXXFILT:=@CXXFILT@
 
 LIPO:=@LIPO@
 INSTALL_NAME_TOOL:=@INSTALL_NAME_TOOL@
+METAL := @METAL@
+METALLIB := @METALLIB@
 
 # Options to linker to specify a mapfile.
 # (Note absence of := assignment, because we do not want to evaluate the macro body here)
 SET_SHARED_LIBRARY_MAPFILE=@SET_SHARED_LIBRARY_MAPFILE@
 
diff a/make/autoconf/toolchain.m4 b/make/autoconf/toolchain.m4
--- a/make/autoconf/toolchain.m4
+++ b/make/autoconf/toolchain.m4
@@ -805,10 +805,36 @@
     UTIL_FIXUP_EXECUTABLE(LIPO)
     UTIL_REQUIRE_PROGS(OTOOL, otool)
     UTIL_FIXUP_EXECUTABLE(OTOOL)
     UTIL_REQUIRE_PROGS(INSTALL_NAME_TOOL, install_name_tool)
     UTIL_FIXUP_EXECUTABLE(INSTALL_NAME_TOOL)
+
+    UTIL_PATH_PROGS(METAL, metal)
+    if test "x$METAL" = x; then
+      AC_MSG_CHECKING([if metal can be run using xcrun])
+      METAL="xcrun -sdk macosx metal"
+      test_metal=`$METAL --version 2>&1`
+      if test $? -ne 0; then
+        AC_MSG_RESULT([no])
+        AC_MSG_ERROR([XCode tool 'metal' neither found in path nor with xcrun])
+      else
+        AC_MSG_RESULT([yes, will be using '$METAL'])
+      fi
+    fi
+
+    UTIL_PATH_PROGS(METALLIB, metallib)
+    if test "x$METALLIB" = x; then
+      AC_MSG_CHECKING([if metallib can be run using xcrun])
+      METALLIB="xcrun -sdk macosx metallib"
+      test_metallib=`$METALLIB --version 2>&1`
+      if test $? -ne 0; then
+        AC_MSG_RESULT([no])
+        AC_MSG_ERROR([XCode tool 'metallib' neither found in path nor with xcrun])
+      else
+        AC_MSG_RESULT([yes, will be using '$METALLIB'])
+      fi
+    fi
   fi
 
   if test "x$TOOLCHAIN_TYPE" = xmicrosoft; then
     AC_CHECK_PROG([MT], [mt$EXE_SUFFIX], [mt$EXE_SUFFIX],,, [/usr/bin/mt])
     UTIL_FIXUP_EXECUTABLE(MT)
diff a/src/java.desktop/macosx/classes/sun/awt/CGraphicsDevice.java b/src/java.desktop/macosx/classes/sun/awt/CGraphicsDevice.java
--- a/src/java.desktop/macosx/classes/sun/awt/CGraphicsDevice.java
+++ b/src/java.desktop/macosx/classes/sun/awt/CGraphicsDevice.java
@@ -35,10 +35,12 @@
 import java.awt.geom.Rectangle2D;
 import java.awt.peer.WindowPeer;
 import java.util.Objects;
 
 import sun.java2d.SunGraphicsEnvironment;
+import sun.java2d.macos.MacOSFlags;
+import sun.java2d.metal.MTLGraphicsConfig;
 import sun.java2d.opengl.CGLGraphicsConfig;
 
 import static java.awt.peer.ComponentPeer.SET_BOUNDS;
 
 public final class CGraphicsDevice extends GraphicsDevice
@@ -61,11 +63,13 @@
     // Save/restore DisplayMode for the Full Screen mode
     private DisplayMode originalMode;
 
     public CGraphicsDevice(final int displayID) {
         this.displayID = displayID;
-        config = CGLGraphicsConfig.getConfig(this);
+        config = MacOSFlags.isMetalEnabled() ?
+                MTLGraphicsConfig.getConfig(this, displayID, 0) :
+                CGLGraphicsConfig.getConfig(this);
         // initializes default device state, might be redundant step since we
         // call "displayChanged()" later anyway, but we do not want to leave the
         // device in an inconsistent state after construction
         displayChanged();
     }
diff a/src/java.desktop/macosx/classes/sun/java2d/opengl/CGLGraphicsConfig.java b/src/java.desktop/macosx/classes/sun/java2d/opengl/CGLGraphicsConfig.java
--- a/src/java.desktop/macosx/classes/sun/java2d/opengl/CGLGraphicsConfig.java
+++ b/src/java.desktop/macosx/classes/sun/java2d/opengl/CGLGraphicsConfig.java
@@ -53,18 +53,19 @@
 import sun.java2d.opengl.OGLContext.OGLContextCaps;
 import sun.java2d.pipe.hw.AccelSurface;
 import sun.java2d.pipe.hw.AccelTypedVolatileImage;
 import sun.java2d.pipe.hw.ContextCapabilities;
 import sun.lwawt.LWComponentPeer;
+import sun.lwawt.macosx.CFRetainedResource;
 
 import static sun.java2d.opengl.OGLContext.OGLContextCaps.CAPS_DOUBLEBUFFERED;
 import static sun.java2d.opengl.OGLContext.OGLContextCaps.CAPS_EXT_FBOBJECT;
 import static sun.java2d.opengl.OGLSurfaceData.FBOBJECT;
 import static sun.java2d.opengl.OGLSurfaceData.TEXTURE;
 
 public final class CGLGraphicsConfig extends CGraphicsConfig
-    implements OGLGraphicsConfig
+        implements OGLGraphicsConfig
 {
     private static boolean cglAvailable;
     private static ImageCapabilities imageCaps = new CGLImageCaps();
 
     private BufferCapabilities bufferCaps;
@@ -99,24 +100,24 @@
         context = new OGLContext(OGLRenderQueue.getInstance());
 
         // add a record to the Disposer so that we destroy the native
         // CGLGraphicsConfigInfo data when this object goes away
         Disposer.addRecord(disposerReferent,
-                           new CGLGCDisposerRecord(pConfigInfo));
+                new CGLGCDisposerRecord(pConfigInfo));
     }
 
     @Override
     public Object getProxyKey() {
         return this;
     }
 
     @Override
     public SurfaceData createManagedSurface(int w, int h, int transparency) {
         return CGLSurfaceData.createData(this, w, h,
-                                         getColorModel(transparency),
-                                         null,
-                                         OGLSurfaceData.TEXTURE);
+                getColorModel(transparency),
+                null,
+                OGLSurfaceData.TEXTURE);
     }
 
     public static CGLGraphicsConfig getConfig(CGraphicsDevice device)
     {
         if (!cglAvailable) {
@@ -182,31 +183,31 @@
 
     @Override
     public BufferedImage createCompatibleImage(int width, int height) {
         ColorModel model = new DirectColorModel(24, 0xff0000, 0xff00, 0xff);
         WritableRaster
-            raster = model.createCompatibleWritableRaster(width, height);
+                raster = model.createCompatibleWritableRaster(width, height);
         return new BufferedImage(model, raster, model.isAlphaPremultiplied(),
-                                 null);
+                null);
     }
 
     @Override
     public ColorModel getColorModel(int transparency) {
         switch (transparency) {
-        case Transparency.OPAQUE:
-            // REMIND: once the ColorModel spec is changed, this should be
-            //         an opaque premultiplied DCM...
-            return new DirectColorModel(24, 0xff0000, 0xff00, 0xff);
-        case Transparency.BITMASK:
-            return new DirectColorModel(25, 0xff0000, 0xff00, 0xff, 0x1000000);
-        case Transparency.TRANSLUCENT:
-            ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_sRGB);
-            return new DirectColorModel(cs, 32,
-                                        0xff0000, 0xff00, 0xff, 0xff000000,
-                                        true, DataBuffer.TYPE_INT);
-        default:
-            return null;
+            case Transparency.OPAQUE:
+                // REMIND: once the ColorModel spec is changed, this should be
+                //         an opaque premultiplied DCM...
+                return new DirectColorModel(24, 0xff0000, 0xff00, 0xff);
+            case Transparency.BITMASK:
+                return new DirectColorModel(25, 0xff0000, 0xff00, 0xff, 0x1000000);
+            case Transparency.TRANSLUCENT:
+                ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_sRGB);
+                return new DirectColorModel(cs, 32,
+                        0xff0000, 0xff00, 0xff, 0xff000000,
+                        true, DataBuffer.TYPE_INT);
+            default:
+                return null;
         }
     }
 
     public boolean isDoubleBuffered() {
         return isCapPresent(CAPS_DOUBLEBUFFERED);
@@ -246,22 +247,22 @@
     public String toString() {
         return ("CGLGraphicsConfig[" + getDevice().getIDstring() + "]");
     }
 
     @Override
-    public SurfaceData createSurfaceData(CGLLayer layer) {
-        return CGLSurfaceData.createData(layer);
+    public SurfaceData createSurfaceData(CFRetainedResource layer) {
+        return CGLSurfaceData.createData((CGLLayer) layer);
     }
 
     @Override
     public Image createAcceleratedImage(Component target,
                                         int width, int height)
     {
         ColorModel model = getColorModel(Transparency.OPAQUE);
         WritableRaster wr = model.createCompatibleWritableRaster(width, height);
         return new OffScreenImage(target, model, wr,
-                                  model.isAlphaPremultiplied());
+                model.isAlphaPremultiplied());
     }
 
     @Override
     public void assertOperationSupported(final int numBuffers,
                                          final BufferCapabilities caps)
@@ -288,11 +289,11 @@
         // It is possible for the component to have size 0x0, adjust it to
         // be at least 1x1 to avoid IAE
         final int w = Math.max(1, r.width);
         final int h = Math.max(1, r.height);
         final int transparency = peer.isTranslucent() ? Transparency.TRANSLUCENT
-                                                      : Transparency.OPAQUE;
+                : Transparency.OPAQUE;
         return new SunVolatileImage(this, w, h, transparency, null);
     }
 
     @Override
     public void destroyBackBuffer(final Image backBuffer) {
@@ -314,21 +315,21 @@
         if (flipAction == BufferCapabilities.FlipContents.BACKGROUND) {
             final Graphics2D bg = (Graphics2D) backBuffer.getGraphics();
             try {
                 bg.setBackground(peer.getBackground());
                 bg.clearRect(0, 0, backBuffer.getWidth(null),
-                             backBuffer.getHeight(null));
+                        backBuffer.getHeight(null));
             } finally {
                 bg.dispose();
             }
         }
     }
 
     private static class CGLBufferCaps extends BufferCapabilities {
         public CGLBufferCaps(boolean dblBuf) {
             super(imageCaps, imageCaps,
-                  dblBuf ? FlipContents.UNDEFINED : null);
+                    dblBuf ? FlipContents.UNDEFINED : null);
         }
     }
 
     @Override
     public BufferCapabilities getBufferCapabilities() {
@@ -360,14 +361,14 @@
                 || transparency == Transparency.BITMASK
                 || type == FBOBJECT && !isCapPresent(CAPS_EXT_FBOBJECT)) {
             return null;
         }
         SunVolatileImage vi = new AccelTypedVolatileImage(this, width, height,
-                                                          transparency, type);
+                transparency, type);
         Surface sd = vi.getDestSurface();
         if (!(sd instanceof AccelSurface) ||
-            ((AccelSurface)sd).getType() != type)
+                ((AccelSurface)sd).getType() != type)
         {
             vi.flush();
             vi = null;
         }
 
@@ -380,14 +381,14 @@
     }
 
     @Override
     public int getMaxTextureWidth() {
         return Math.max(maxTextureSize / getDevice().getScaleFactor(),
-                        getBounds().width);
+                getBounds().width);
     }
 
     @Override
     public int getMaxTextureHeight() {
         return Math.max(maxTextureSize / getDevice().getScaleFactor(),
-                        getBounds().height);
+                getBounds().height);
     }
 }
diff a/src/java.desktop/macosx/classes/sun/lwawt/macosx/LWCToolkit.java b/src/java.desktop/macosx/classes/sun/lwawt/macosx/LWCToolkit.java
--- a/src/java.desktop/macosx/classes/sun/lwawt/macosx/LWCToolkit.java
+++ b/src/java.desktop/macosx/classes/sun/lwawt/macosx/LWCToolkit.java
@@ -106,10 +106,12 @@
 import sun.awt.LightweightFrame;
 import sun.awt.PlatformGraphicsInfo;
 import sun.awt.SunToolkit;
 import sun.awt.datatransfer.DataTransferer;
 import sun.awt.util.ThreadGroupUtils;
+import sun.java2d.macos.MacOSFlags;
+import sun.java2d.metal.MTLRenderQueue;
 import sun.java2d.opengl.OGLRenderQueue;
 import sun.lwawt.LWComponentPeer;
 import sun.lwawt.LWCursorManager;
 import sun.lwawt.LWToolkit;
 import sun.lwawt.LWWindowPeer;
@@ -486,11 +488,15 @@
     }
 
     @Override
     public void sync() {
         // flush the OGL pipeline (this is a no-op if OGL is not enabled)
-        OGLRenderQueue.sync();
+        if (MacOSFlags.isMetalEnabled()) {
+            MTLRenderQueue.sync();
+        } else {
+            OGLRenderQueue.sync();
+        }
         // setNeedsDisplay() selector was sent to the appropriate CALayer so now
         // we have to flush the native selectors queue.
         flushNativeSelectors();
     }
 

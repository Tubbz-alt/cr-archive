<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/macosx/classes/sun/java2d/opengl/CGLGraphicsConfig.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../awt/CGraphicsDevice.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../lwawt/macosx/LWCToolkit.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/macosx/classes/sun/java2d/opengl/CGLGraphicsConfig.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 38 import java.awt.image.BufferedImage;
 39 import java.awt.image.ColorModel;
 40 import java.awt.image.DataBuffer;
 41 import java.awt.image.DirectColorModel;
 42 import java.awt.image.VolatileImage;
 43 import java.awt.image.WritableRaster;
 44 
 45 import sun.awt.CGraphicsConfig;
 46 import sun.awt.CGraphicsDevice;
 47 import sun.awt.image.OffScreenImage;
 48 import sun.awt.image.SunVolatileImage;
 49 import sun.java2d.Disposer;
 50 import sun.java2d.DisposerRecord;
 51 import sun.java2d.Surface;
 52 import sun.java2d.SurfaceData;
 53 import sun.java2d.opengl.OGLContext.OGLContextCaps;
 54 import sun.java2d.pipe.hw.AccelSurface;
 55 import sun.java2d.pipe.hw.AccelTypedVolatileImage;
 56 import sun.java2d.pipe.hw.ContextCapabilities;
 57 import sun.lwawt.LWComponentPeer;

 58 
 59 import static sun.java2d.opengl.OGLContext.OGLContextCaps.CAPS_DOUBLEBUFFERED;
 60 import static sun.java2d.opengl.OGLContext.OGLContextCaps.CAPS_EXT_FBOBJECT;
 61 import static sun.java2d.opengl.OGLSurfaceData.FBOBJECT;
 62 import static sun.java2d.opengl.OGLSurfaceData.TEXTURE;
 63 
 64 public final class CGLGraphicsConfig extends CGraphicsConfig
<span class="line-modified"> 65     implements OGLGraphicsConfig</span>
 66 {
 67     private static boolean cglAvailable;
 68     private static ImageCapabilities imageCaps = new CGLImageCaps();
 69 
 70     private BufferCapabilities bufferCaps;
 71     private long pConfigInfo;
 72     private ContextCapabilities oglCaps;
 73     private final OGLContext context;
 74     private final Object disposerReferent = new Object();
 75     private final int maxTextureSize;
 76 
 77     private static native boolean initCGL();
 78     private static native long getCGLConfigInfo();
 79     private static native int getOGLCapabilities(long configInfo);
 80 
 81     /**
 82      * Returns GL_MAX_TEXTURE_SIZE from the shared opengl context. Must be
 83      * called under OGLRQ lock, because this method change current context.
 84      *
 85      * @return GL_MAX_TEXTURE_SIZE
 86      */
 87     private static native int nativeGetMaxTextureSize();
 88 
 89     static {
 90         cglAvailable = initCGL();
 91     }
 92 
 93     private CGLGraphicsConfig(CGraphicsDevice device, long configInfo,
 94                               int maxTextureSize, ContextCapabilities oglCaps) {
 95         super(device);
 96         this.pConfigInfo = configInfo;
 97         this.oglCaps = oglCaps;
 98         this.maxTextureSize = maxTextureSize;
 99         context = new OGLContext(OGLRenderQueue.getInstance());
100 
101         // add a record to the Disposer so that we destroy the native
102         // CGLGraphicsConfigInfo data when this object goes away
103         Disposer.addRecord(disposerReferent,
<span class="line-modified">104                            new CGLGCDisposerRecord(pConfigInfo));</span>
105     }
106 
107     @Override
108     public Object getProxyKey() {
109         return this;
110     }
111 
112     @Override
113     public SurfaceData createManagedSurface(int w, int h, int transparency) {
114         return CGLSurfaceData.createData(this, w, h,
<span class="line-modified">115                                          getColorModel(transparency),</span>
<span class="line-modified">116                                          null,</span>
<span class="line-modified">117                                          OGLSurfaceData.TEXTURE);</span>
118     }
119 
120     public static CGLGraphicsConfig getConfig(CGraphicsDevice device)
121     {
122         if (!cglAvailable) {
123             return null;
124         }
125 
126         long cfginfo = 0;
127         int textureSize = 0;
128         final String[] ids = new String[1];
129         OGLRenderQueue rq = OGLRenderQueue.getInstance();
130         rq.lock();
131         try {
132             // getCGLConfigInfo() creates and destroys temporary
133             // surfaces/contexts, so we should first invalidate the current
134             // Java-level context and flush the queue...
135             OGLContext.invalidateCurrentContext();
136             cfginfo = getCGLConfigInfo();
137             if (cfginfo != 0L) {
</pre>
<hr />
<pre>
167      */
168     @Override
169     public boolean isCapPresent(int cap) {
170         return ((oglCaps.getCaps() &amp; cap) != 0);
171     }
172 
173     @Override
174     public long getNativeConfigInfo() {
175         return pConfigInfo;
176     }
177 
178     @Override
179     public OGLContext getContext() {
180         return context;
181     }
182 
183     @Override
184     public BufferedImage createCompatibleImage(int width, int height) {
185         ColorModel model = new DirectColorModel(24, 0xff0000, 0xff00, 0xff);
186         WritableRaster
<span class="line-modified">187             raster = model.createCompatibleWritableRaster(width, height);</span>
188         return new BufferedImage(model, raster, model.isAlphaPremultiplied(),
<span class="line-modified">189                                  null);</span>
190     }
191 
192     @Override
193     public ColorModel getColorModel(int transparency) {
194         switch (transparency) {
<span class="line-modified">195         case Transparency.OPAQUE:</span>
<span class="line-modified">196             // REMIND: once the ColorModel spec is changed, this should be</span>
<span class="line-modified">197             //         an opaque premultiplied DCM...</span>
<span class="line-modified">198             return new DirectColorModel(24, 0xff0000, 0xff00, 0xff);</span>
<span class="line-modified">199         case Transparency.BITMASK:</span>
<span class="line-modified">200             return new DirectColorModel(25, 0xff0000, 0xff00, 0xff, 0x1000000);</span>
<span class="line-modified">201         case Transparency.TRANSLUCENT:</span>
<span class="line-modified">202             ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_sRGB);</span>
<span class="line-modified">203             return new DirectColorModel(cs, 32,</span>
<span class="line-modified">204                                         0xff0000, 0xff00, 0xff, 0xff000000,</span>
<span class="line-modified">205                                         true, DataBuffer.TYPE_INT);</span>
<span class="line-modified">206         default:</span>
<span class="line-modified">207             return null;</span>
208         }
209     }
210 
211     public boolean isDoubleBuffered() {
212         return isCapPresent(CAPS_DOUBLEBUFFERED);
213     }
214 
215     private static class CGLGCDisposerRecord implements DisposerRecord {
216         private long pCfgInfo;
217         public CGLGCDisposerRecord(long pCfgInfo) {
218             this.pCfgInfo = pCfgInfo;
219         }
220         public void dispose() {
221             if (pCfgInfo != 0) {
222                 OGLRenderQueue.disposeGraphicsConfig(pCfgInfo);
223                 pCfgInfo = 0;
224             }
225         }
226     }
227 
</pre>
<hr />
<pre>
231         //super.displayChanged();
232 
233         // the context could hold a reference to a CGLSurfaceData, which in
234         // turn has a reference back to this CGLGraphicsConfig, so in order
235         // for this instance to be disposed we need to break the connection
236         OGLRenderQueue rq = OGLRenderQueue.getInstance();
237         rq.lock();
238         try {
239             OGLContext.invalidateCurrentContext();
240         } finally {
241             rq.unlock();
242         }
243     }
244 
245     @Override
246     public String toString() {
247         return (&quot;CGLGraphicsConfig[&quot; + getDevice().getIDstring() + &quot;]&quot;);
248     }
249 
250     @Override
<span class="line-modified">251     public SurfaceData createSurfaceData(CGLLayer layer) {</span>
<span class="line-modified">252         return CGLSurfaceData.createData(layer);</span>
253     }
254 
255     @Override
256     public Image createAcceleratedImage(Component target,
257                                         int width, int height)
258     {
259         ColorModel model = getColorModel(Transparency.OPAQUE);
260         WritableRaster wr = model.createCompatibleWritableRaster(width, height);
261         return new OffScreenImage(target, model, wr,
<span class="line-modified">262                                   model.isAlphaPremultiplied());</span>
263     }
264 
265     @Override
266     public void assertOperationSupported(final int numBuffers,
267                                          final BufferCapabilities caps)
268             throws AWTException {
269         // Assume this method is never called with numBuffers != 2, as 0 is
270         // unsupported, and 1 corresponds to a SingleBufferStrategy which
271         // doesn&#39;t depend on the peer. Screen is considered as a separate
272         // &quot;buffer&quot;.
273         if (numBuffers != 2) {
274             throw new AWTException(&quot;Only double buffering is supported&quot;);
275         }
276         final BufferCapabilities configCaps = getBufferCapabilities();
277         if (!configCaps.isPageFlipping()) {
278             throw new AWTException(&quot;Page flipping is not supported&quot;);
279         }
280         if (caps.getFlipContents() == BufferCapabilities.FlipContents.PRIOR) {
281             throw new AWTException(&quot;FlipContents.PRIOR is not supported&quot;);
282         }
283     }
284 
285     @Override
286     public Image createBackBuffer(final LWComponentPeer&lt;?, ?&gt; peer) {
287         final Rectangle r = peer.getBounds();
288         // It is possible for the component to have size 0x0, adjust it to
289         // be at least 1x1 to avoid IAE
290         final int w = Math.max(1, r.width);
291         final int h = Math.max(1, r.height);
292         final int transparency = peer.isTranslucent() ? Transparency.TRANSLUCENT
<span class="line-modified">293                                                       : Transparency.OPAQUE;</span>
294         return new SunVolatileImage(this, w, h, transparency, null);
295     }
296 
297     @Override
298     public void destroyBackBuffer(final Image backBuffer) {
299         if (backBuffer != null) {
300             backBuffer.flush();
301         }
302     }
303 
304     @Override
305     public void flip(final LWComponentPeer&lt;?, ?&gt; peer, final Image backBuffer,
306                      final int x1, final int y1, final int x2, final int y2,
307                      final BufferCapabilities.FlipContents flipAction) {
308         final Graphics g = peer.getGraphics();
309         try {
310             g.drawImage(backBuffer, x1, y1, x2, y2, x1, y1, x2, y2, null);
311         } finally {
312             g.dispose();
313         }
314         if (flipAction == BufferCapabilities.FlipContents.BACKGROUND) {
315             final Graphics2D bg = (Graphics2D) backBuffer.getGraphics();
316             try {
317                 bg.setBackground(peer.getBackground());
318                 bg.clearRect(0, 0, backBuffer.getWidth(null),
<span class="line-modified">319                              backBuffer.getHeight(null));</span>
320             } finally {
321                 bg.dispose();
322             }
323         }
324     }
325 
326     private static class CGLBufferCaps extends BufferCapabilities {
327         public CGLBufferCaps(boolean dblBuf) {
328             super(imageCaps, imageCaps,
<span class="line-modified">329                   dblBuf ? FlipContents.UNDEFINED : null);</span>
330         }
331     }
332 
333     @Override
334     public BufferCapabilities getBufferCapabilities() {
335         if (bufferCaps == null) {
336             bufferCaps = new CGLBufferCaps(isDoubleBuffered());
337         }
338         return bufferCaps;
339     }
340 
341     private static class CGLImageCaps extends ImageCapabilities {
342         private CGLImageCaps() {
343             super(true);
344         }
345         public boolean isTrueVolatile() {
346             return true;
347         }
348     }
349 
350     @Override
351     public ImageCapabilities getImageCapabilities() {
352         return imageCaps;
353     }
354 
355     @Override
356     public VolatileImage createCompatibleVolatileImage(int width, int height,
357                                                        int transparency,
358                                                        int type) {
359         if ((type != FBOBJECT &amp;&amp; type != TEXTURE)
360                 || transparency == Transparency.BITMASK
361                 || type == FBOBJECT &amp;&amp; !isCapPresent(CAPS_EXT_FBOBJECT)) {
362             return null;
363         }
364         SunVolatileImage vi = new AccelTypedVolatileImage(this, width, height,
<span class="line-modified">365                                                           transparency, type);</span>
366         Surface sd = vi.getDestSurface();
367         if (!(sd instanceof AccelSurface) ||
<span class="line-modified">368             ((AccelSurface)sd).getType() != type)</span>
369         {
370             vi.flush();
371             vi = null;
372         }
373 
374         return vi;
375     }
376 
377     @Override
378     public ContextCapabilities getContextCapabilities() {
379         return oglCaps;
380     }
381 
382     @Override
383     public int getMaxTextureWidth() {
384         return Math.max(maxTextureSize / getDevice().getScaleFactor(),
<span class="line-modified">385                         getBounds().width);</span>
386     }
387 
388     @Override
389     public int getMaxTextureHeight() {
390         return Math.max(maxTextureSize / getDevice().getScaleFactor(),
<span class="line-modified">391                         getBounds().height);</span>
392     }
393 }
</pre>
</td>
<td>
<hr />
<pre>
 38 import java.awt.image.BufferedImage;
 39 import java.awt.image.ColorModel;
 40 import java.awt.image.DataBuffer;
 41 import java.awt.image.DirectColorModel;
 42 import java.awt.image.VolatileImage;
 43 import java.awt.image.WritableRaster;
 44 
 45 import sun.awt.CGraphicsConfig;
 46 import sun.awt.CGraphicsDevice;
 47 import sun.awt.image.OffScreenImage;
 48 import sun.awt.image.SunVolatileImage;
 49 import sun.java2d.Disposer;
 50 import sun.java2d.DisposerRecord;
 51 import sun.java2d.Surface;
 52 import sun.java2d.SurfaceData;
 53 import sun.java2d.opengl.OGLContext.OGLContextCaps;
 54 import sun.java2d.pipe.hw.AccelSurface;
 55 import sun.java2d.pipe.hw.AccelTypedVolatileImage;
 56 import sun.java2d.pipe.hw.ContextCapabilities;
 57 import sun.lwawt.LWComponentPeer;
<span class="line-added"> 58 import sun.lwawt.macosx.CFRetainedResource;</span>
 59 
 60 import static sun.java2d.opengl.OGLContext.OGLContextCaps.CAPS_DOUBLEBUFFERED;
 61 import static sun.java2d.opengl.OGLContext.OGLContextCaps.CAPS_EXT_FBOBJECT;
 62 import static sun.java2d.opengl.OGLSurfaceData.FBOBJECT;
 63 import static sun.java2d.opengl.OGLSurfaceData.TEXTURE;
 64 
 65 public final class CGLGraphicsConfig extends CGraphicsConfig
<span class="line-modified"> 66         implements OGLGraphicsConfig</span>
 67 {
 68     private static boolean cglAvailable;
 69     private static ImageCapabilities imageCaps = new CGLImageCaps();
 70 
 71     private BufferCapabilities bufferCaps;
 72     private long pConfigInfo;
 73     private ContextCapabilities oglCaps;
 74     private final OGLContext context;
 75     private final Object disposerReferent = new Object();
 76     private final int maxTextureSize;
 77 
 78     private static native boolean initCGL();
 79     private static native long getCGLConfigInfo();
 80     private static native int getOGLCapabilities(long configInfo);
 81 
 82     /**
 83      * Returns GL_MAX_TEXTURE_SIZE from the shared opengl context. Must be
 84      * called under OGLRQ lock, because this method change current context.
 85      *
 86      * @return GL_MAX_TEXTURE_SIZE
 87      */
 88     private static native int nativeGetMaxTextureSize();
 89 
 90     static {
 91         cglAvailable = initCGL();
 92     }
 93 
 94     private CGLGraphicsConfig(CGraphicsDevice device, long configInfo,
 95                               int maxTextureSize, ContextCapabilities oglCaps) {
 96         super(device);
 97         this.pConfigInfo = configInfo;
 98         this.oglCaps = oglCaps;
 99         this.maxTextureSize = maxTextureSize;
100         context = new OGLContext(OGLRenderQueue.getInstance());
101 
102         // add a record to the Disposer so that we destroy the native
103         // CGLGraphicsConfigInfo data when this object goes away
104         Disposer.addRecord(disposerReferent,
<span class="line-modified">105                 new CGLGCDisposerRecord(pConfigInfo));</span>
106     }
107 
108     @Override
109     public Object getProxyKey() {
110         return this;
111     }
112 
113     @Override
114     public SurfaceData createManagedSurface(int w, int h, int transparency) {
115         return CGLSurfaceData.createData(this, w, h,
<span class="line-modified">116                 getColorModel(transparency),</span>
<span class="line-modified">117                 null,</span>
<span class="line-modified">118                 OGLSurfaceData.TEXTURE);</span>
119     }
120 
121     public static CGLGraphicsConfig getConfig(CGraphicsDevice device)
122     {
123         if (!cglAvailable) {
124             return null;
125         }
126 
127         long cfginfo = 0;
128         int textureSize = 0;
129         final String[] ids = new String[1];
130         OGLRenderQueue rq = OGLRenderQueue.getInstance();
131         rq.lock();
132         try {
133             // getCGLConfigInfo() creates and destroys temporary
134             // surfaces/contexts, so we should first invalidate the current
135             // Java-level context and flush the queue...
136             OGLContext.invalidateCurrentContext();
137             cfginfo = getCGLConfigInfo();
138             if (cfginfo != 0L) {
</pre>
<hr />
<pre>
168      */
169     @Override
170     public boolean isCapPresent(int cap) {
171         return ((oglCaps.getCaps() &amp; cap) != 0);
172     }
173 
174     @Override
175     public long getNativeConfigInfo() {
176         return pConfigInfo;
177     }
178 
179     @Override
180     public OGLContext getContext() {
181         return context;
182     }
183 
184     @Override
185     public BufferedImage createCompatibleImage(int width, int height) {
186         ColorModel model = new DirectColorModel(24, 0xff0000, 0xff00, 0xff);
187         WritableRaster
<span class="line-modified">188                 raster = model.createCompatibleWritableRaster(width, height);</span>
189         return new BufferedImage(model, raster, model.isAlphaPremultiplied(),
<span class="line-modified">190                 null);</span>
191     }
192 
193     @Override
194     public ColorModel getColorModel(int transparency) {
195         switch (transparency) {
<span class="line-modified">196             case Transparency.OPAQUE:</span>
<span class="line-modified">197                 // REMIND: once the ColorModel spec is changed, this should be</span>
<span class="line-modified">198                 //         an opaque premultiplied DCM...</span>
<span class="line-modified">199                 return new DirectColorModel(24, 0xff0000, 0xff00, 0xff);</span>
<span class="line-modified">200             case Transparency.BITMASK:</span>
<span class="line-modified">201                 return new DirectColorModel(25, 0xff0000, 0xff00, 0xff, 0x1000000);</span>
<span class="line-modified">202             case Transparency.TRANSLUCENT:</span>
<span class="line-modified">203                 ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_sRGB);</span>
<span class="line-modified">204                 return new DirectColorModel(cs, 32,</span>
<span class="line-modified">205                         0xff0000, 0xff00, 0xff, 0xff000000,</span>
<span class="line-modified">206                         true, DataBuffer.TYPE_INT);</span>
<span class="line-modified">207             default:</span>
<span class="line-modified">208                 return null;</span>
209         }
210     }
211 
212     public boolean isDoubleBuffered() {
213         return isCapPresent(CAPS_DOUBLEBUFFERED);
214     }
215 
216     private static class CGLGCDisposerRecord implements DisposerRecord {
217         private long pCfgInfo;
218         public CGLGCDisposerRecord(long pCfgInfo) {
219             this.pCfgInfo = pCfgInfo;
220         }
221         public void dispose() {
222             if (pCfgInfo != 0) {
223                 OGLRenderQueue.disposeGraphicsConfig(pCfgInfo);
224                 pCfgInfo = 0;
225             }
226         }
227     }
228 
</pre>
<hr />
<pre>
232         //super.displayChanged();
233 
234         // the context could hold a reference to a CGLSurfaceData, which in
235         // turn has a reference back to this CGLGraphicsConfig, so in order
236         // for this instance to be disposed we need to break the connection
237         OGLRenderQueue rq = OGLRenderQueue.getInstance();
238         rq.lock();
239         try {
240             OGLContext.invalidateCurrentContext();
241         } finally {
242             rq.unlock();
243         }
244     }
245 
246     @Override
247     public String toString() {
248         return (&quot;CGLGraphicsConfig[&quot; + getDevice().getIDstring() + &quot;]&quot;);
249     }
250 
251     @Override
<span class="line-modified">252     public SurfaceData createSurfaceData(CFRetainedResource layer) {</span>
<span class="line-modified">253         return CGLSurfaceData.createData((CGLLayer) layer);</span>
254     }
255 
256     @Override
257     public Image createAcceleratedImage(Component target,
258                                         int width, int height)
259     {
260         ColorModel model = getColorModel(Transparency.OPAQUE);
261         WritableRaster wr = model.createCompatibleWritableRaster(width, height);
262         return new OffScreenImage(target, model, wr,
<span class="line-modified">263                 model.isAlphaPremultiplied());</span>
264     }
265 
266     @Override
267     public void assertOperationSupported(final int numBuffers,
268                                          final BufferCapabilities caps)
269             throws AWTException {
270         // Assume this method is never called with numBuffers != 2, as 0 is
271         // unsupported, and 1 corresponds to a SingleBufferStrategy which
272         // doesn&#39;t depend on the peer. Screen is considered as a separate
273         // &quot;buffer&quot;.
274         if (numBuffers != 2) {
275             throw new AWTException(&quot;Only double buffering is supported&quot;);
276         }
277         final BufferCapabilities configCaps = getBufferCapabilities();
278         if (!configCaps.isPageFlipping()) {
279             throw new AWTException(&quot;Page flipping is not supported&quot;);
280         }
281         if (caps.getFlipContents() == BufferCapabilities.FlipContents.PRIOR) {
282             throw new AWTException(&quot;FlipContents.PRIOR is not supported&quot;);
283         }
284     }
285 
286     @Override
287     public Image createBackBuffer(final LWComponentPeer&lt;?, ?&gt; peer) {
288         final Rectangle r = peer.getBounds();
289         // It is possible for the component to have size 0x0, adjust it to
290         // be at least 1x1 to avoid IAE
291         final int w = Math.max(1, r.width);
292         final int h = Math.max(1, r.height);
293         final int transparency = peer.isTranslucent() ? Transparency.TRANSLUCENT
<span class="line-modified">294                 : Transparency.OPAQUE;</span>
295         return new SunVolatileImage(this, w, h, transparency, null);
296     }
297 
298     @Override
299     public void destroyBackBuffer(final Image backBuffer) {
300         if (backBuffer != null) {
301             backBuffer.flush();
302         }
303     }
304 
305     @Override
306     public void flip(final LWComponentPeer&lt;?, ?&gt; peer, final Image backBuffer,
307                      final int x1, final int y1, final int x2, final int y2,
308                      final BufferCapabilities.FlipContents flipAction) {
309         final Graphics g = peer.getGraphics();
310         try {
311             g.drawImage(backBuffer, x1, y1, x2, y2, x1, y1, x2, y2, null);
312         } finally {
313             g.dispose();
314         }
315         if (flipAction == BufferCapabilities.FlipContents.BACKGROUND) {
316             final Graphics2D bg = (Graphics2D) backBuffer.getGraphics();
317             try {
318                 bg.setBackground(peer.getBackground());
319                 bg.clearRect(0, 0, backBuffer.getWidth(null),
<span class="line-modified">320                         backBuffer.getHeight(null));</span>
321             } finally {
322                 bg.dispose();
323             }
324         }
325     }
326 
327     private static class CGLBufferCaps extends BufferCapabilities {
328         public CGLBufferCaps(boolean dblBuf) {
329             super(imageCaps, imageCaps,
<span class="line-modified">330                     dblBuf ? FlipContents.UNDEFINED : null);</span>
331         }
332     }
333 
334     @Override
335     public BufferCapabilities getBufferCapabilities() {
336         if (bufferCaps == null) {
337             bufferCaps = new CGLBufferCaps(isDoubleBuffered());
338         }
339         return bufferCaps;
340     }
341 
342     private static class CGLImageCaps extends ImageCapabilities {
343         private CGLImageCaps() {
344             super(true);
345         }
346         public boolean isTrueVolatile() {
347             return true;
348         }
349     }
350 
351     @Override
352     public ImageCapabilities getImageCapabilities() {
353         return imageCaps;
354     }
355 
356     @Override
357     public VolatileImage createCompatibleVolatileImage(int width, int height,
358                                                        int transparency,
359                                                        int type) {
360         if ((type != FBOBJECT &amp;&amp; type != TEXTURE)
361                 || transparency == Transparency.BITMASK
362                 || type == FBOBJECT &amp;&amp; !isCapPresent(CAPS_EXT_FBOBJECT)) {
363             return null;
364         }
365         SunVolatileImage vi = new AccelTypedVolatileImage(this, width, height,
<span class="line-modified">366                 transparency, type);</span>
367         Surface sd = vi.getDestSurface();
368         if (!(sd instanceof AccelSurface) ||
<span class="line-modified">369                 ((AccelSurface)sd).getType() != type)</span>
370         {
371             vi.flush();
372             vi = null;
373         }
374 
375         return vi;
376     }
377 
378     @Override
379     public ContextCapabilities getContextCapabilities() {
380         return oglCaps;
381     }
382 
383     @Override
384     public int getMaxTextureWidth() {
385         return Math.max(maxTextureSize / getDevice().getScaleFactor(),
<span class="line-modified">386                 getBounds().width);</span>
387     }
388 
389     @Override
390     public int getMaxTextureHeight() {
391         return Math.max(maxTextureSize / getDevice().getScaleFactor(),
<span class="line-modified">392                 getBounds().height);</span>
393     }
394 }
</pre>
</td>
</tr>
</table>
<center><a href="../../awt/CGraphicsDevice.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../lwawt/macosx/LWCToolkit.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
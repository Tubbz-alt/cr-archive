<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLRenderQueue.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MTLRenderQueue.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLRenderQueue.m</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 300                 strcpy(opName, &quot;DISABLE_LOOKUP_OP&quot;);
 301             }
 302             break;
 303         default:
 304             strcpy(opName, &quot;UNKNOWN&quot;);
 305             break;
 306         }
 307     return opName;
 308 }
 309 
 310 void MTLRenderQueue_CheckPreviousOp(jint op) {
 311 
 312     if (mtlPreviousOp == op) {
 313         // The op is the same as last time, so we can return immediately.
 314         return;
 315     }
 316 
 317     J2dTraceLn1(J2D_TRACE_VERBOSE,
 318                 &quot;MTLRenderQueue_CheckPreviousOp: new op=%d&quot;, op);
 319 




 320     if (mtlPreviousOp == MTL_OP_INIT) {
 321         mtlPreviousOp = op;
 322         return;
 323     }
 324 
 325     if (mtlc != NULL) {
 326         [mtlc.encoderManager endEncoder];
 327     }
 328     mtlPreviousOp = op;
 329 }
 330 
 331 JNIEXPORT void JNICALL
 332 Java_sun_java2d_metal_MTLRenderQueue_flushBuffer
 333     (JNIEnv *env, jobject mtlrq,
 334      jlong buf, jint limit)
 335 {
 336     jboolean sync = JNI_FALSE;
 337     unsigned char *b, *end;
 338 
 339     J2dTraceLn1(J2D_TRACE_INFO,
</pre>
<hr />
<pre>
 813             {
 814                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 815                 jlong window = NEXT_LONG(b);
 816                 MTLSD_SwapBuffers(env, window);
 817             }
 818             break;
 819 
 820         // special no-op (mainly used for achieving 8-byte alignment)
 821         case sun_java2d_pipe_BufferedOpCodes_NOOP:
 822             break;
 823 
 824         // paint-related ops
 825         case sun_java2d_pipe_BufferedOpCodes_RESET_PAINT:
 826             {
 827               CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 828               [mtlc resetPaint];
 829             }
 830             break;
 831         case sun_java2d_pipe_BufferedOpCodes_SET_COLOR:
 832             {
<span class="line-modified"> 833                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);</span>
 834                 jint pixel = NEXT_INT(b);
 835                 [mtlc setColorPaint:pixel];
 836             }
 837             break;
 838         case sun_java2d_pipe_BufferedOpCodes_SET_GRADIENT_PAINT:
 839             {
 840                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 841                 jboolean useMask= NEXT_BOOLEAN(b);
 842                 jboolean cyclic = NEXT_BOOLEAN(b);
 843                 jdouble p0      = NEXT_DOUBLE(b);
 844                 jdouble p1      = NEXT_DOUBLE(b);
 845                 jdouble p3      = NEXT_DOUBLE(b);
 846                 jint pixel1     = NEXT_INT(b);
 847                 jint pixel2     = NEXT_INT(b);
 848                 [mtlc setGradientPaintUseMask:useMask
 849                                     cyclic:cyclic
 850                                         p0:p0
 851                                         p1:p1
 852                                         p3:p3
 853                                     pixel1:pixel1
</pre>
<hr />
<pre>
 986                 MTLBufImgOps_EnableLookupOp(mtlc, pSrc, nonPremult, shortData,
 987                                             numBands, bandLength, offset,
 988                                             tableValues);
 989                 SKIP_BYTES(b, numBands * bandLength * bytesPerElem);
 990             }
 991             break;
 992         case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:
 993             {
 994                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 995                 MTLBufImgOps_DisableLookupOp(mtlc);
 996             }
 997             break;
 998 
 999         default:
1000             J2dRlsTraceLn1(J2D_TRACE_ERROR,
1001                 &quot;MTLRenderQueue_flushBuffer: invalid opcode=%d&quot;, opcode);
1002             return;
1003         }
1004     }
1005 
<span class="line-removed">1006     CHECK_PREVIOUS_OP(MTL_OP_INIT);</span>
1007     if (mtlc != NULL) {
1008         [mtlc.encoderManager endEncoder];
1009         MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];
1010         id&lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
1011         [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
1012             [cbwrapper release];
1013         }];
1014         [commandbuf commit];
1015         if (sync) {
1016             [commandbuf waitUntilCompleted];
1017         }
1018         BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
1019         if (dstOps != NULL) {
1020             MTLSDOps *dstMTLOps = (MTLSDOps *)dstOps-&gt;privOps;
1021             MTLLayer *layer = (MTLLayer*)dstMTLOps-&gt;layer;
1022             if (layer != NULL) {
1023                 [JNFRunLoop performOnMainThreadWaiting:NO withBlock:^(){
1024                     AWT_ASSERT_APPKIT_THREAD;
1025                     [layer setNeedsDisplay];
1026                 }];
1027             }
1028         }
1029     }

1030 }
1031 
1032 /**
1033  * Returns a pointer to the &quot;current&quot; context, as set by the last SET_SURFACES
1034  * or SET_SCRATCH_SURFACE operation.
1035  */
1036 MTLContext *
1037 MTLRenderQueue_GetCurrentContext()
1038 {
1039     return mtlc;
1040 }
1041 
1042 /**
1043  * Returns a pointer to the &quot;current&quot; destination surface, as set by the last
1044  * SET_SURFACES operation.
1045  */
1046 BMTLSDOps *
1047 MTLRenderQueue_GetCurrentDestination()
1048 {
1049     return dstOps;
</pre>
</td>
<td>
<hr />
<pre>
 300                 strcpy(opName, &quot;DISABLE_LOOKUP_OP&quot;);
 301             }
 302             break;
 303         default:
 304             strcpy(opName, &quot;UNKNOWN&quot;);
 305             break;
 306         }
 307     return opName;
 308 }
 309 
 310 void MTLRenderQueue_CheckPreviousOp(jint op) {
 311 
 312     if (mtlPreviousOp == op) {
 313         // The op is the same as last time, so we can return immediately.
 314         return;
 315     }
 316 
 317     J2dTraceLn1(J2D_TRACE_VERBOSE,
 318                 &quot;MTLRenderQueue_CheckPreviousOp: new op=%d&quot;, op);
 319 
<span class="line-added"> 320     if (op == MTL_OP_SET_COLOR) {</span>
<span class="line-added"> 321         return; // SET_COLOR should not cause endEncoder</span>
<span class="line-added"> 322     }</span>
<span class="line-added"> 323 </span>
 324     if (mtlPreviousOp == MTL_OP_INIT) {
 325         mtlPreviousOp = op;
 326         return;
 327     }
 328 
 329     if (mtlc != NULL) {
 330         [mtlc.encoderManager endEncoder];
 331     }
 332     mtlPreviousOp = op;
 333 }
 334 
 335 JNIEXPORT void JNICALL
 336 Java_sun_java2d_metal_MTLRenderQueue_flushBuffer
 337     (JNIEnv *env, jobject mtlrq,
 338      jlong buf, jint limit)
 339 {
 340     jboolean sync = JNI_FALSE;
 341     unsigned char *b, *end;
 342 
 343     J2dTraceLn1(J2D_TRACE_INFO,
</pre>
<hr />
<pre>
 817             {
 818                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 819                 jlong window = NEXT_LONG(b);
 820                 MTLSD_SwapBuffers(env, window);
 821             }
 822             break;
 823 
 824         // special no-op (mainly used for achieving 8-byte alignment)
 825         case sun_java2d_pipe_BufferedOpCodes_NOOP:
 826             break;
 827 
 828         // paint-related ops
 829         case sun_java2d_pipe_BufferedOpCodes_RESET_PAINT:
 830             {
 831               CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 832               [mtlc resetPaint];
 833             }
 834             break;
 835         case sun_java2d_pipe_BufferedOpCodes_SET_COLOR:
 836             {
<span class="line-modified"> 837                 CHECK_PREVIOUS_OP(MTL_OP_SET_COLOR);</span>
 838                 jint pixel = NEXT_INT(b);
 839                 [mtlc setColorPaint:pixel];
 840             }
 841             break;
 842         case sun_java2d_pipe_BufferedOpCodes_SET_GRADIENT_PAINT:
 843             {
 844                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 845                 jboolean useMask= NEXT_BOOLEAN(b);
 846                 jboolean cyclic = NEXT_BOOLEAN(b);
 847                 jdouble p0      = NEXT_DOUBLE(b);
 848                 jdouble p1      = NEXT_DOUBLE(b);
 849                 jdouble p3      = NEXT_DOUBLE(b);
 850                 jint pixel1     = NEXT_INT(b);
 851                 jint pixel2     = NEXT_INT(b);
 852                 [mtlc setGradientPaintUseMask:useMask
 853                                     cyclic:cyclic
 854                                         p0:p0
 855                                         p1:p1
 856                                         p3:p3
 857                                     pixel1:pixel1
</pre>
<hr />
<pre>
 990                 MTLBufImgOps_EnableLookupOp(mtlc, pSrc, nonPremult, shortData,
 991                                             numBands, bandLength, offset,
 992                                             tableValues);
 993                 SKIP_BYTES(b, numBands * bandLength * bytesPerElem);
 994             }
 995             break;
 996         case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:
 997             {
 998                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 999                 MTLBufImgOps_DisableLookupOp(mtlc);
1000             }
1001             break;
1002 
1003         default:
1004             J2dRlsTraceLn1(J2D_TRACE_ERROR,
1005                 &quot;MTLRenderQueue_flushBuffer: invalid opcode=%d&quot;, opcode);
1006             return;
1007         }
1008     }
1009 

1010     if (mtlc != NULL) {
1011         [mtlc.encoderManager endEncoder];
1012         MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];
1013         id&lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
1014         [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
1015             [cbwrapper release];
1016         }];
1017         [commandbuf commit];
1018         if (sync) {
1019             [commandbuf waitUntilCompleted];
1020         }
1021         BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
1022         if (dstOps != NULL) {
1023             MTLSDOps *dstMTLOps = (MTLSDOps *)dstOps-&gt;privOps;
1024             MTLLayer *layer = (MTLLayer*)dstMTLOps-&gt;layer;
1025             if (layer != NULL) {
1026                 [JNFRunLoop performOnMainThreadWaiting:NO withBlock:^(){
1027                     AWT_ASSERT_APPKIT_THREAD;
1028                     [layer setNeedsDisplay];
1029                 }];
1030             }
1031         }
1032     }
<span class="line-added">1033     RESET_PREVIOUS_OP();</span>
1034 }
1035 
1036 /**
1037  * Returns a pointer to the &quot;current&quot; context, as set by the last SET_SURFACES
1038  * or SET_SCRATCH_SURFACE operation.
1039  */
1040 MTLContext *
1041 MTLRenderQueue_GetCurrentContext()
1042 {
1043     return mtlc;
1044 }
1045 
1046 /**
1047  * Returns a pointer to the &quot;current&quot; destination surface, as set by the last
1048  * SET_SURFACES operation.
1049  */
1050 BMTLSDOps *
1051 MTLRenderQueue_GetCurrentDestination()
1052 {
1053     return dstOps;
</pre>
</td>
</tr>
</table>
<center><a href="MTLRenderQueue.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
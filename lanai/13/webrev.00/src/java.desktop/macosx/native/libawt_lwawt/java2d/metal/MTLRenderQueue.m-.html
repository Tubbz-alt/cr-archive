<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLRenderQueue.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #ifndef HEADLESS
  27 
  28 #include &lt;stdlib.h&gt;
  29 
  30 #include &quot;sun_java2d_pipe_BufferedOpCodes.h&quot;
  31 
  32 #include &quot;jlong.h&quot;
  33 #include &quot;MTLBlitLoops.h&quot;
  34 #include &quot;MTLBufImgOps.h&quot;
  35 #include &quot;MTLMaskBlit.h&quot;
  36 #include &quot;MTLMaskFill.h&quot;
  37 #include &quot;MTLPaints.h&quot;
  38 #include &quot;MTLRenderQueue.h&quot;
  39 #include &quot;MTLRenderer.h&quot;
  40 #include &quot;MTLTextRenderer.h&quot;
  41 #import &quot;ThreadUtilities.h&quot;
  42 
  43 /**
  44  * References to the &quot;current&quot; context and destination surface.
  45  */
  46 static MTLContext *mtlc = NULL;
  47 static BMTLSDOps *dstOps = NULL;
  48 jint mtlPreviousOp = MTL_OP_INIT;
  49 
  50 /**
  51  * The following methods are implemented in the windowing system (i.e. GLX
  52  * and WGL) source files.
  53  */
  54 extern void MTLGC_DestroyMTLGraphicsConfig(jlong pConfigInfo);
  55 extern void MTLSD_SwapBuffers(JNIEnv *env, jlong window);
  56 
  57 // TODO : Debug logic added for opcode verification,
  58 // should be removed later.
  59 static char *getOpcodeString(jint opcode) {
  60     static char opName[30];
  61     switch (opcode) {
  62         case sun_java2d_pipe_BufferedOpCodes_DRAW_LINE:
  63             {
  64                 strcpy(opName, &quot;DRAW_LINE&quot;);
  65             }
  66             break;
  67         case sun_java2d_pipe_BufferedOpCodes_DRAW_RECT:
  68             {
  69                 strcpy(opName, &quot;DRAW_RECT&quot;);
  70             }
  71             break;
  72         case sun_java2d_pipe_BufferedOpCodes_DRAW_POLY:
  73             {
  74                 strcpy(opName, &quot;DRAW_POLY&quot;);
  75             }
  76             break;
  77         case sun_java2d_pipe_BufferedOpCodes_DRAW_PIXEL:
  78             {
  79                 strcpy(opName, &quot;DRAW_PIXEL&quot;);
  80             }
  81             break;
  82         case sun_java2d_pipe_BufferedOpCodes_DRAW_SCANLINES:
  83             {
  84                 strcpy(opName, &quot;DRAW_SCANLINES&quot;);
  85             }
  86             break;
  87         case sun_java2d_pipe_BufferedOpCodes_DRAW_PARALLELOGRAM:
  88             {
  89                 strcpy(opName, &quot;DRAW_PARALLELOGRAM&quot;);
  90             }
  91             break;
  92         case sun_java2d_pipe_BufferedOpCodes_DRAW_AAPARALLELOGRAM:
  93             {
  94                 strcpy(opName, &quot;DRAW_AAPARALLELOGRAM&quot;);
  95             }
  96             break;
  97         case sun_java2d_pipe_BufferedOpCodes_FILL_RECT:
  98             {
  99                 strcpy(opName, &quot;FILL_RECT&quot;);
 100             }
 101             break;
 102         case sun_java2d_pipe_BufferedOpCodes_FILL_SPANS:
 103             {
 104                 strcpy(opName, &quot;FILL_SPANS&quot;);
 105             }
 106             break;
 107         case sun_java2d_pipe_BufferedOpCodes_FILL_PARALLELOGRAM:
 108             {
 109                 strcpy(opName, &quot;FILL_PARALLELOGRAM&quot;);
 110             }
 111             break;
 112         case sun_java2d_pipe_BufferedOpCodes_FILL_AAPARALLELOGRAM:
 113             {
 114                 strcpy(opName, &quot;FILL_AAPARALLELOGRAM&quot;);
 115             }
 116             break;
 117         case sun_java2d_pipe_BufferedOpCodes_DRAW_GLYPH_LIST:
 118             {
 119                 strcpy(opName, &quot;DRAW_GLYPH_LIST&quot;);
 120             }
 121             break;
 122         case sun_java2d_pipe_BufferedOpCodes_COPY_AREA:
 123             {
 124                 strcpy(opName, &quot;COPY_AREA&quot;);
 125             }
 126             break;
 127         case sun_java2d_pipe_BufferedOpCodes_BLIT:
 128             {
 129                 strcpy(opName, &quot;BLIT&quot;);
 130             }
 131             break;
 132         case sun_java2d_pipe_BufferedOpCodes_SURFACE_TO_SW_BLIT:
 133             {
 134                 strcpy(opName, &quot;SURFACE_TO_SW_BLIT&quot;);
 135             }
 136             break;
 137         case sun_java2d_pipe_BufferedOpCodes_MASK_FILL:
 138             {
 139                 strcpy(opName, &quot;MASK_FILL&quot;);
 140             }
 141             break;
 142         case sun_java2d_pipe_BufferedOpCodes_MASK_BLIT:
 143             {
 144 
 145                 strcpy(opName, &quot;MASK_BLIT&quot;);
 146             }
 147             break;
 148         case sun_java2d_pipe_BufferedOpCodes_SET_RECT_CLIP:
 149             {
 150                 strcpy(opName, &quot;SET_RECT_CLIP&quot;);
 151             }
 152             break;
 153         case sun_java2d_pipe_BufferedOpCodes_BEGIN_SHAPE_CLIP:
 154             {
 155                 strcpy(opName, &quot;BEGIN_SHAPE_CLIP&quot;);
 156             }
 157             break;
 158         case sun_java2d_pipe_BufferedOpCodes_SET_SHAPE_CLIP_SPANS:
 159             {
 160                 strcpy(opName, &quot;SET_SHAPE_CLIP_SPANS&quot;);
 161             }
 162             break;
 163         case sun_java2d_pipe_BufferedOpCodes_END_SHAPE_CLIP:
 164             {
 165                 strcpy(opName, &quot;END_SHAPE_CLIP&quot;);
 166             }
 167             break;
 168         case sun_java2d_pipe_BufferedOpCodes_RESET_CLIP:
 169             {
 170                 strcpy(opName, &quot;RESET_CLIP&quot;);
 171             }
 172             break;
 173         case sun_java2d_pipe_BufferedOpCodes_SET_ALPHA_COMPOSITE:
 174             {
 175                 strcpy(opName, &quot;SET_ALPHA_COMPOSITE&quot;);
 176             }
 177             break;
 178         case sun_java2d_pipe_BufferedOpCodes_SET_XOR_COMPOSITE:
 179             {
 180                 strcpy(opName, &quot;SET_XOR_COMPOSITE&quot;);
 181             }
 182             break;
 183         case sun_java2d_pipe_BufferedOpCodes_RESET_COMPOSITE:
 184             {
 185                 strcpy(opName, &quot;RESET_COMPOSITE&quot;);
 186             }
 187             break;
 188         case sun_java2d_pipe_BufferedOpCodes_SET_TRANSFORM:
 189             {
 190                 strcpy(opName, &quot;SET_TRANSFORM&quot;);
 191             }
 192             break;
 193         case sun_java2d_pipe_BufferedOpCodes_RESET_TRANSFORM:
 194             {
 195                 strcpy(opName, &quot;RESET_TRANSFORM&quot;);
 196             }
 197             break;
 198         case sun_java2d_pipe_BufferedOpCodes_SET_SURFACES:
 199             {
 200 
 201                 strcpy(opName, &quot;SET_SURFACES&quot;);
 202             }
 203             break;
 204         case sun_java2d_pipe_BufferedOpCodes_SET_SCRATCH_SURFACE:
 205             {
 206                 strcpy(opName, &quot;SET_SCRATCH_SURFACE&quot;);
 207             }
 208             break;
 209         case sun_java2d_pipe_BufferedOpCodes_FLUSH_SURFACE:
 210             {
 211                 strcpy(opName, &quot;FLUSH_SURFACE&quot;);
 212             }
 213             break;
 214         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_SURFACE:
 215             {
 216                 strcpy(opName, &quot;DISPOSE_SURFACE&quot;);
 217             }
 218             break;
 219         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_CONFIG:
 220             {
 221                 strcpy(opName, &quot;DISPOSE_CONFIG&quot;);
 222             }
 223             break;
 224         case sun_java2d_pipe_BufferedOpCodes_INVALIDATE_CONTEXT:
 225             {
 226                 strcpy(opName, &quot;INVALIDATE_CONTEXT&quot;);
 227             }
 228             break;
 229         case sun_java2d_pipe_BufferedOpCodes_SYNC:
 230             {
 231                 strcpy(opName, &quot;SYNC&quot;);
 232 
 233             }
 234             break;
 235         case sun_java2d_pipe_BufferedOpCodes_SWAP_BUFFERS:
 236             {
 237                 strcpy(opName, &quot;SWAP_BUFFERS&quot;);
 238             }
 239             break;
 240         case sun_java2d_pipe_BufferedOpCodes_NOOP:
 241             strcpy(opName, &quot;NOOP&quot;);
 242             break;
 243         case sun_java2d_pipe_BufferedOpCodes_RESET_PAINT:
 244             {
 245                 strcpy(opName, &quot;RESET_PAINT&quot;);
 246             }
 247             break;
 248         case sun_java2d_pipe_BufferedOpCodes_SET_COLOR:
 249             {
 250                 strcpy(opName, &quot;SET_COLOR&quot;);
 251             }
 252             break;
 253         case sun_java2d_pipe_BufferedOpCodes_SET_GRADIENT_PAINT:
 254             {
 255                 strcpy(opName, &quot;SET_GRADIENT_PAINT&quot;);
 256             }
 257             break;
 258         case sun_java2d_pipe_BufferedOpCodes_SET_LINEAR_GRADIENT_PAINT:
 259             {
 260                 strcpy(opName, &quot;SET_LINEAR_GRADIENT_PAINT&quot;);
 261             }
 262             break;
 263         case sun_java2d_pipe_BufferedOpCodes_SET_RADIAL_GRADIENT_PAINT:
 264             {
 265                 strcpy(opName, &quot;SET_RADIAL_GRADIENT_PAINT&quot;);
 266             }
 267             break;
 268         case sun_java2d_pipe_BufferedOpCodes_SET_TEXTURE_PAINT:
 269             {
 270                 strcpy(opName, &quot;SET_TEXTURE_PAINT&quot;);
 271             }
 272             break;
 273         case sun_java2d_pipe_BufferedOpCodes_ENABLE_CONVOLVE_OP:
 274             {
 275                 strcpy(opName, &quot;ENABLE_CONVOLVE_OP&quot;);
 276             }
 277             break;
 278         case sun_java2d_pipe_BufferedOpCodes_DISABLE_CONVOLVE_OP:
 279             {
 280                 strcpy(opName, &quot;DISABLE_CONVOLVE_OP&quot;);
 281             }
 282             break;
 283         case sun_java2d_pipe_BufferedOpCodes_ENABLE_RESCALE_OP:
 284             {
 285                 strcpy(opName, &quot;ENABLE_RESCALE_OP&quot;);
 286             }
 287             break;
 288         case sun_java2d_pipe_BufferedOpCodes_DISABLE_RESCALE_OP:
 289             {
 290                  strcpy(opName, &quot;DISABLE_RESCALE_OP&quot;);
 291             }
 292             break;
 293         case sun_java2d_pipe_BufferedOpCodes_ENABLE_LOOKUP_OP:
 294             {
 295                 strcpy(opName, &quot;ENABLE_LOOKUP_OP&quot;);
 296             }
 297             break;
 298         case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:
 299             {
 300                 strcpy(opName, &quot;DISABLE_LOOKUP_OP&quot;);
 301             }
 302             break;
 303         default:
 304             strcpy(opName, &quot;UNKNOWN&quot;);
 305             break;
 306         }
 307     return opName;
 308 }
 309 
 310 void MTLRenderQueue_CheckPreviousOp(jint op) {
 311 
 312     if (mtlPreviousOp == op) {
 313         // The op is the same as last time, so we can return immediately.
 314         return;
 315     }
 316 
 317     J2dTraceLn1(J2D_TRACE_VERBOSE,
 318                 &quot;MTLRenderQueue_CheckPreviousOp: new op=%d&quot;, op);
 319 
 320     if (mtlPreviousOp == MTL_OP_INIT) {
 321         mtlPreviousOp = op;
 322         return;
 323     }
 324 
 325     if (mtlc != NULL) {
 326         [mtlc.encoderManager endEncoder];
 327     }
 328     mtlPreviousOp = op;
 329 }
 330 
 331 JNIEXPORT void JNICALL
 332 Java_sun_java2d_metal_MTLRenderQueue_flushBuffer
 333     (JNIEnv *env, jobject mtlrq,
 334      jlong buf, jint limit)
 335 {
 336     jboolean sync = JNI_FALSE;
 337     unsigned char *b, *end;
 338 
 339     J2dTraceLn1(J2D_TRACE_INFO,
 340                 &quot;MTLRenderQueue_flushBuffer: limit=%d&quot;, limit);
 341 
 342     b = (unsigned char *)jlong_to_ptr(buf);
 343     if (b == NULL) {
 344         J2dRlsTraceLn(J2D_TRACE_ERROR,
 345             &quot;MTLRenderQueue_flushBuffer: cannot get direct buffer address&quot;);
 346         return;
 347     }
 348 
 349     end = b + limit;
 350 
 351     jboolean DEBUG_LOG = JNI_FALSE;
 352     while (b &lt; end) {
 353         jint opcode = NEXT_INT(b);
 354 
 355         if (DEBUG_LOG) {
 356             J2dTraceLn2(J2D_TRACE_ERROR,
 357                     &quot;MTLRenderQueue_flushBuffer: opcode_name = %s, rem=%d&quot;,
 358                     getOpcodeString(opcode), (end-b));
 359         } else {
 360             J2dTraceLn2(J2D_TRACE_VERBOSE,
 361                     &quot;MTLRenderQueue_flushBuffer: opcode=%d, rem=%d&quot;,
 362                     opcode, (end-b));
 363         }
 364 
 365         switch (opcode) {
 366 
 367         // draw ops
 368         case sun_java2d_pipe_BufferedOpCodes_DRAW_LINE:
 369             {
 370                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 371                 J2dTraceLn(J2D_TRACE_VERBOSE, &quot;sun_java2d_pipe_BufferedOpCodes_DRAW_LINE&quot;);
 372                 jint x1 = NEXT_INT(b);
 373                 jint y1 = NEXT_INT(b);
 374                 jint x2 = NEXT_INT(b);
 375                 jint y2 = NEXT_INT(b);
 376                 MTLRenderer_DrawLine(mtlc, dstOps, x1, y1, x2, y2);
 377             }
 378             break;
 379         case sun_java2d_pipe_BufferedOpCodes_DRAW_RECT:
 380             {
 381                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 382                 jint x = NEXT_INT(b);
 383                 jint y = NEXT_INT(b);
 384                 jint w = NEXT_INT(b);
 385                 jint h = NEXT_INT(b);
 386                 MTLRenderer_DrawRect(mtlc, dstOps, x, y, w, h);
 387             }
 388             break;
 389         case sun_java2d_pipe_BufferedOpCodes_DRAW_POLY:
 390             {
 391                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 392                 jint nPoints      = NEXT_INT(b);
 393                 jboolean isClosed = NEXT_BOOLEAN(b);
 394                 jint transX       = NEXT_INT(b);
 395                 jint transY       = NEXT_INT(b);
 396                 jint *xPoints = (jint *)b;
 397                 jint *yPoints = ((jint *)b) + nPoints;
 398                 MTLRenderer_DrawPoly(mtlc, dstOps, nPoints, isClosed, transX, transY, xPoints, yPoints);
 399                 SKIP_BYTES(b, nPoints * BYTES_PER_POLY_POINT);
 400             }
 401             break;
 402         case sun_java2d_pipe_BufferedOpCodes_DRAW_PIXEL:
 403             {
 404                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 405                 jint x = NEXT_INT(b);
 406                 jint y = NEXT_INT(b);
 407                 CONTINUE_IF_NULL(mtlc);
 408                 //TODO
 409                 J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLRenderQueue_DRAW_PIXEL -- :TODO&quot;);
 410             }
 411             break;
 412         case sun_java2d_pipe_BufferedOpCodes_DRAW_SCANLINES:
 413             {
 414                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 415                 jint count = NEXT_INT(b);
 416                 MTLRenderer_DrawScanlines(mtlc, dstOps, count, (jint *)b);
 417 
 418                 SKIP_BYTES(b, count * BYTES_PER_SCANLINE);
 419             }
 420             break;
 421         case sun_java2d_pipe_BufferedOpCodes_DRAW_PARALLELOGRAM:
 422             {
 423                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 424                 jfloat x11 = NEXT_FLOAT(b);
 425                 jfloat y11 = NEXT_FLOAT(b);
 426                 jfloat dx21 = NEXT_FLOAT(b);
 427                 jfloat dy21 = NEXT_FLOAT(b);
 428                 jfloat dx12 = NEXT_FLOAT(b);
 429                 jfloat dy12 = NEXT_FLOAT(b);
 430                 jfloat lwr21 = NEXT_FLOAT(b);
 431                 jfloat lwr12 = NEXT_FLOAT(b);
 432 
 433                 MTLRenderer_DrawParallelogram(mtlc, dstOps,
 434                                               x11, y11,
 435                                               dx21, dy21,
 436                                               dx12, dy12,
 437                                               lwr21, lwr12);
 438             }
 439             break;
 440         case sun_java2d_pipe_BufferedOpCodes_DRAW_AAPARALLELOGRAM:
 441             {
 442                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 443                 jfloat x11 = NEXT_FLOAT(b);
 444                 jfloat y11 = NEXT_FLOAT(b);
 445                 jfloat dx21 = NEXT_FLOAT(b);
 446                 jfloat dy21 = NEXT_FLOAT(b);
 447                 jfloat dx12 = NEXT_FLOAT(b);
 448                 jfloat dy12 = NEXT_FLOAT(b);
 449                 jfloat lwr21 = NEXT_FLOAT(b);
 450                 jfloat lwr12 = NEXT_FLOAT(b);
 451 
 452                 MTLRenderer_DrawAAParallelogram(mtlc, dstOps,
 453                                                 x11, y11,
 454                                                 dx21, dy21,
 455                                                 dx12, dy12,
 456                                                 lwr21, lwr12);
 457             }
 458             break;
 459 
 460         // fill ops
 461         case sun_java2d_pipe_BufferedOpCodes_FILL_RECT:
 462             {
 463                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 464                 jint x = NEXT_INT(b);
 465                 jint y = NEXT_INT(b);
 466                 jint w = NEXT_INT(b);
 467                 jint h = NEXT_INT(b);
 468                 MTLRenderer_FillRect(mtlc, dstOps, x, y, w, h);
 469             }
 470             break;
 471         case sun_java2d_pipe_BufferedOpCodes_FILL_SPANS:
 472             {
 473                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 474                 jint count = NEXT_INT(b);
 475                 MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);
 476                 SKIP_BYTES(b, count * BYTES_PER_SPAN);
 477             }
 478             break;
 479         case sun_java2d_pipe_BufferedOpCodes_FILL_PARALLELOGRAM:
 480             {
 481                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 482                 jfloat x11 = NEXT_FLOAT(b);
 483                 jfloat y11 = NEXT_FLOAT(b);
 484                 jfloat dx21 = NEXT_FLOAT(b);
 485                 jfloat dy21 = NEXT_FLOAT(b);
 486                 jfloat dx12 = NEXT_FLOAT(b);
 487                 jfloat dy12 = NEXT_FLOAT(b);
 488                 MTLRenderer_FillParallelogram(mtlc, dstOps,
 489                                               x11, y11,
 490                                               dx21, dy21,
 491                                               dx12, dy12);
 492             }
 493             break;
 494         case sun_java2d_pipe_BufferedOpCodes_FILL_AAPARALLELOGRAM:
 495             {
 496                 CHECK_PREVIOUS_OP(MTL_OP_AA);
 497                 jfloat x11 = NEXT_FLOAT(b);
 498                 jfloat y11 = NEXT_FLOAT(b);
 499                 jfloat dx21 = NEXT_FLOAT(b);
 500                 jfloat dy21 = NEXT_FLOAT(b);
 501                 jfloat dx12 = NEXT_FLOAT(b);
 502                 jfloat dy12 = NEXT_FLOAT(b);
 503                 MTLRenderer_FillAAParallelogram(mtlc, dstOps,
 504                                                 x11, y11,
 505                                                 dx21, dy21,
 506                                                 dx12, dy12);
 507             }
 508             break;
 509 
 510         // text-related ops
 511         case sun_java2d_pipe_BufferedOpCodes_DRAW_GLYPH_LIST:
 512             {
 513                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 514                 jint numGlyphs        = NEXT_INT(b);
 515                 jint packedParams     = NEXT_INT(b);
 516                 jfloat glyphListOrigX = NEXT_FLOAT(b);
 517                 jfloat glyphListOrigY = NEXT_FLOAT(b);
 518                 jboolean usePositions = EXTRACT_BOOLEAN(packedParams,
 519                                                         OFFSET_POSITIONS);
 520                 jboolean subPixPos    = EXTRACT_BOOLEAN(packedParams,
 521                                                         OFFSET_SUBPIXPOS);
 522                 jboolean rgbOrder     = EXTRACT_BOOLEAN(packedParams,
 523                                                         OFFSET_RGBORDER);
 524                 jint lcdContrast      = EXTRACT_BYTE(packedParams,
 525                                                      OFFSET_CONTRAST);
 526                 unsigned char *images = b;
 527                 unsigned char *positions;
 528                 jint bytesPerGlyph;
 529                 if (usePositions) {
 530                     positions = (b + numGlyphs * BYTES_PER_GLYPH_IMAGE);
 531                     bytesPerGlyph = BYTES_PER_POSITIONED_GLYPH;
 532                 } else {
 533                     positions = NULL;
 534                     bytesPerGlyph = BYTES_PER_GLYPH_IMAGE;
 535                 }
 536                 MTLTR_DrawGlyphList(env, mtlc, dstOps,
 537                                     numGlyphs, usePositions,
 538                                     subPixPos, rgbOrder, lcdContrast,
 539                                     glyphListOrigX, glyphListOrigY,
 540                                     images, positions);
 541                 SKIP_BYTES(b, numGlyphs * bytesPerGlyph);
 542             }
 543             break;
 544 
 545         // copy-related ops
 546         case sun_java2d_pipe_BufferedOpCodes_COPY_AREA:
 547             {
 548                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 549                 jint x  = NEXT_INT(b);
 550                 jint y  = NEXT_INT(b);
 551                 jint w  = NEXT_INT(b);
 552                 jint h  = NEXT_INT(b);
 553                 jint dx = NEXT_INT(b);
 554                 jint dy = NEXT_INT(b);
 555                 MTLBlitLoops_CopyArea(env, mtlc, dstOps,
 556                                       x, y, w, h, dx, dy);
 557             }
 558             break;
 559         case sun_java2d_pipe_BufferedOpCodes_BLIT:
 560             {
 561                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 562                 jint packedParams = NEXT_INT(b);
 563                 jint sx1          = NEXT_INT(b);
 564                 jint sy1          = NEXT_INT(b);
 565                 jint sx2          = NEXT_INT(b);
 566                 jint sy2          = NEXT_INT(b);
 567                 jdouble dx1       = NEXT_DOUBLE(b);
 568                 jdouble dy1       = NEXT_DOUBLE(b);
 569                 jdouble dx2       = NEXT_DOUBLE(b);
 570                 jdouble dy2       = NEXT_DOUBLE(b);
 571                 jlong pSrc        = NEXT_LONG(b);
 572                 jlong pDst        = NEXT_LONG(b);
 573                 jint hint         = EXTRACT_BYTE(packedParams, OFFSET_HINT);
 574                 jboolean texture  = EXTRACT_BOOLEAN(packedParams,
 575                                                     OFFSET_TEXTURE);
 576                 jboolean xform    = EXTRACT_BOOLEAN(packedParams,
 577                                                     OFFSET_XFORM);
 578                 jboolean isoblit  = EXTRACT_BOOLEAN(packedParams,
 579                                                     OFFSET_ISOBLIT);
 580                 if (isoblit) {
 581                     MTLBlitLoops_IsoBlit(env, mtlc, pSrc, pDst,
 582                                          xform, hint, texture,
 583                                          sx1, sy1, sx2, sy2,
 584                                          dx1, dy1, dx2, dy2);
 585                 } else {
 586                     jint srctype = EXTRACT_BYTE(packedParams, OFFSET_SRCTYPE);
 587                     MTLBlitLoops_Blit(env, mtlc, pSrc, pDst,
 588                                       xform, hint, srctype, texture,
 589                                       sx1, sy1, sx2, sy2,
 590                                       dx1, dy1, dx2, dy2);
 591                 }
 592             }
 593             break;
 594         case sun_java2d_pipe_BufferedOpCodes_SURFACE_TO_SW_BLIT:
 595             {
 596                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 597                 jint sx      = NEXT_INT(b);
 598                 jint sy      = NEXT_INT(b);
 599                 jint dx      = NEXT_INT(b);
 600                 jint dy      = NEXT_INT(b);
 601                 jint w       = NEXT_INT(b);
 602                 jint h       = NEXT_INT(b);
 603                 jint dsttype = NEXT_INT(b);
 604                 jlong pSrc   = NEXT_LONG(b);
 605                 jlong pDst   = NEXT_LONG(b);
 606                 MTLBlitLoops_SurfaceToSwBlit(env, mtlc,
 607                                              pSrc, pDst, dsttype,
 608                                              sx, sy, dx, dy, w, h);
 609             }
 610             break;
 611         case sun_java2d_pipe_BufferedOpCodes_MASK_FILL:
 612             {
 613                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 614                 jint x        = NEXT_INT(b);
 615                 jint y        = NEXT_INT(b);
 616                 jint w        = NEXT_INT(b);
 617                 jint h        = NEXT_INT(b);
 618                 jint maskoff  = NEXT_INT(b);
 619                 jint maskscan = NEXT_INT(b);
 620                 jint masklen  = NEXT_INT(b);
 621                 unsigned char *pMask = (masklen &gt; 0) ? b : NULL;
 622                 MTLMaskFill_MaskFill(mtlc, dstOps, x, y, w, h,
 623                                      maskoff, maskscan, masklen, pMask);
 624                 SKIP_BYTES(b, masklen);
 625             }
 626             break;
 627         case sun_java2d_pipe_BufferedOpCodes_MASK_BLIT:
 628             {
 629                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 630                 jint dstx     = NEXT_INT(b);
 631                 jint dsty     = NEXT_INT(b);
 632                 jint width    = NEXT_INT(b);
 633                 jint height   = NEXT_INT(b);
 634                 jint masklen  = width * height * sizeof(jint);
 635                 MTLMaskBlit_MaskBlit(env, mtlc, dstOps,
 636                                      dstx, dsty, width, height, b);
 637                 SKIP_BYTES(b, masklen);
 638             }
 639             break;
 640 
 641         // state-related ops
 642         case sun_java2d_pipe_BufferedOpCodes_SET_RECT_CLIP:
 643             {
 644                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 645                 jint x1 = NEXT_INT(b);
 646                 jint y1 = NEXT_INT(b);
 647                 jint x2 = NEXT_INT(b);
 648                 jint y2 = NEXT_INT(b);
 649                 [mtlc setClipRectX1:x1 Y1:y1 X2:x2 Y2:y2];
 650             }
 651             break;
 652         case sun_java2d_pipe_BufferedOpCodes_BEGIN_SHAPE_CLIP:
 653             {
 654                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 655                 [mtlc beginShapeClip:dstOps];
 656             }
 657             break;
 658         case sun_java2d_pipe_BufferedOpCodes_SET_SHAPE_CLIP_SPANS:
 659             {
 660                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 661                 // This results in creation of new render encoder with
 662                 // stencil buffer set as render target
 663                 jint count = NEXT_INT(b);
 664                 MTLRenderer_FillSpans(mtlc, dstOps, count, (jint *)b);
 665                 SKIP_BYTES(b, count * BYTES_PER_SPAN);
 666             }
 667             break;
 668         case sun_java2d_pipe_BufferedOpCodes_END_SHAPE_CLIP:
 669             {
 670                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 671                 [mtlc endShapeClip:dstOps];
 672             }
 673             break;
 674         case sun_java2d_pipe_BufferedOpCodes_RESET_CLIP:
 675             {
 676                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 677                 [mtlc resetClip];
 678             }
 679             break;
 680         case sun_java2d_pipe_BufferedOpCodes_SET_ALPHA_COMPOSITE:
 681             {
 682                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 683                 jint rule         = NEXT_INT(b);
 684                 jfloat extraAlpha = NEXT_FLOAT(b);
 685                 jint flags        = NEXT_INT(b);
 686                 [mtlc setAlphaCompositeRule:rule extraAlpha:extraAlpha flags:flags];
 687             }
 688             break;
 689         case sun_java2d_pipe_BufferedOpCodes_SET_XOR_COMPOSITE:
 690             {
 691                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 692                 jint xorPixel = NEXT_INT(b);
 693                 [mtlc setXorComposite:xorPixel];
 694             }
 695             break;
 696         case sun_java2d_pipe_BufferedOpCodes_RESET_COMPOSITE:
 697             {
 698                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 699                 [mtlc resetComposite];
 700             }
 701             break;
 702         case sun_java2d_pipe_BufferedOpCodes_SET_TRANSFORM:
 703             {
 704                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 705                 jdouble m00 = NEXT_DOUBLE(b);
 706                 jdouble m10 = NEXT_DOUBLE(b);
 707                 jdouble m01 = NEXT_DOUBLE(b);
 708                 jdouble m11 = NEXT_DOUBLE(b);
 709                 jdouble m02 = NEXT_DOUBLE(b);
 710                 jdouble m12 = NEXT_DOUBLE(b);
 711                 [mtlc setTransformM00:m00 M10:m10 M01:m01 M11:m11 M02:m02 M12:m12];
 712             }
 713             break;
 714         case sun_java2d_pipe_BufferedOpCodes_RESET_TRANSFORM:
 715             {
 716                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 717                 [mtlc resetTransform];
 718             }
 719             break;
 720 
 721         // context-related ops
 722         case sun_java2d_pipe_BufferedOpCodes_SET_SURFACES:
 723             {
 724                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 725                 jlong pSrc = NEXT_LONG(b);
 726                 jlong pDst = NEXT_LONG(b);
 727 
 728                 dstOps = (BMTLSDOps *)jlong_to_ptr(pDst);
 729                 mtlc = [MTLContext setSurfacesEnv:env src:pSrc dst:pDst];
 730             }
 731             break;
 732         case sun_java2d_pipe_BufferedOpCodes_SET_SCRATCH_SURFACE:
 733             {
 734                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 735                 jlong pConfigInfo = NEXT_LONG(b);
 736                 MTLGraphicsConfigInfo *mtlInfo =
 737                         (MTLGraphicsConfigInfo *)jlong_to_ptr(pConfigInfo);
 738 
 739                 if (mtlInfo == NULL) {
 740 
 741                 } else {
 742                     MTLContext *newMtlc = mtlInfo-&gt;context;
 743                     if (newMtlc == NULL) {
 744 
 745                     } else {
 746                         mtlc = newMtlc;
 747                         dstOps = NULL;
 748                     }
 749                 }
 750             }
 751             break;
 752         case sun_java2d_pipe_BufferedOpCodes_FLUSH_SURFACE:
 753             {
 754                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 755                 jlong pData = NEXT_LONG(b);
 756                 BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);
 757                 if (mtlsdo != NULL) {
 758                     CONTINUE_IF_NULL(mtlc);
 759                     MTLSD_Delete(env, mtlsdo);
 760                 }
 761             }
 762             break;
 763         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_SURFACE:
 764             {
 765                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 766                 jlong pData = NEXT_LONG(b);
 767                 BMTLSDOps *mtlsdo = (BMTLSDOps *)jlong_to_ptr(pData);
 768                 if (mtlsdo != NULL) {
 769                     CONTINUE_IF_NULL(mtlc);
 770                     MTLSD_Delete(env, mtlsdo);
 771                     if (mtlsdo-&gt;privOps != NULL) {
 772                         free(mtlsdo-&gt;privOps);
 773                     }
 774                 }
 775             }
 776             break;
 777         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_CONFIG:
 778             {
 779                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 780                 jlong pConfigInfo = NEXT_LONG(b);
 781                 CONTINUE_IF_NULL(mtlc);
 782                 MTLGC_DestroyMTLGraphicsConfig(pConfigInfo);
 783 
 784                 // the previous method will call glX/wglMakeCurrent(None),
 785                 // so we should nullify the current mtlc and dstOps to avoid
 786                 // calling glFlush() (or similar) while no context is current
 787                 mtlc = NULL;
 788              //   dstOps = NULL;
 789             }
 790             break;
 791         case sun_java2d_pipe_BufferedOpCodes_INVALIDATE_CONTEXT:
 792             {
 793                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 794                 // invalidate the references to the current context and
 795                 // destination surface that are maintained at the native level
 796                 mtlc = NULL;
 797             //    dstOps = NULL;
 798             }
 799             break;
 800         case sun_java2d_pipe_BufferedOpCodes_SYNC:
 801             {
 802                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 803                 sync = JNI_TRUE;
 804 
 805                 // TODO
 806                 J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLRenderQueue_SYNC -- :TODO&quot;);
 807 
 808             }
 809             break;
 810 
 811         // multibuffering ops
 812         case sun_java2d_pipe_BufferedOpCodes_SWAP_BUFFERS:
 813             {
 814                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 815                 jlong window = NEXT_LONG(b);
 816                 MTLSD_SwapBuffers(env, window);
 817             }
 818             break;
 819 
 820         // special no-op (mainly used for achieving 8-byte alignment)
 821         case sun_java2d_pipe_BufferedOpCodes_NOOP:
 822             break;
 823 
 824         // paint-related ops
 825         case sun_java2d_pipe_BufferedOpCodes_RESET_PAINT:
 826             {
 827               CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 828               [mtlc resetPaint];
 829             }
 830             break;
 831         case sun_java2d_pipe_BufferedOpCodes_SET_COLOR:
 832             {
 833                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 834                 jint pixel = NEXT_INT(b);
 835                 [mtlc setColorPaint:pixel];
 836             }
 837             break;
 838         case sun_java2d_pipe_BufferedOpCodes_SET_GRADIENT_PAINT:
 839             {
 840                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 841                 jboolean useMask= NEXT_BOOLEAN(b);
 842                 jboolean cyclic = NEXT_BOOLEAN(b);
 843                 jdouble p0      = NEXT_DOUBLE(b);
 844                 jdouble p1      = NEXT_DOUBLE(b);
 845                 jdouble p3      = NEXT_DOUBLE(b);
 846                 jint pixel1     = NEXT_INT(b);
 847                 jint pixel2     = NEXT_INT(b);
 848                 [mtlc setGradientPaintUseMask:useMask
 849                                     cyclic:cyclic
 850                                         p0:p0
 851                                         p1:p1
 852                                         p3:p3
 853                                     pixel1:pixel1
 854                                     pixel2:pixel2];
 855             }
 856             break;
 857         case sun_java2d_pipe_BufferedOpCodes_SET_LINEAR_GRADIENT_PAINT:
 858             {
 859                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 860                 jboolean useMask = NEXT_BOOLEAN(b);
 861                 jboolean linear  = NEXT_BOOLEAN(b);
 862                 jint cycleMethod = NEXT_INT(b);
 863                 jint numStops    = NEXT_INT(b);
 864                 jfloat p0        = NEXT_FLOAT(b);
 865                 jfloat p1        = NEXT_FLOAT(b);
 866                 jfloat p3        = NEXT_FLOAT(b);
 867                 void *fractions, *pixels;
 868                 fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));
 869                 pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));
 870                 [mtlc setLinearGradientPaint:useMask
 871                                       linear:linear
 872                                  cycleMethod:cycleMethod
 873                                     numStops:numStops
 874                                           p0:p0
 875                                           p1:p1
 876                                           p3:p3
 877                                    fractions:fractions
 878                                       pixels:pixels];
 879             }
 880             break;
 881         case sun_java2d_pipe_BufferedOpCodes_SET_RADIAL_GRADIENT_PAINT:
 882             {
 883                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 884                 jboolean useMask = NEXT_BOOLEAN(b);
 885                 jboolean linear  = NEXT_BOOLEAN(b);
 886                 jint numStops    = NEXT_INT(b);
 887                 jint cycleMethod = NEXT_INT(b);
 888                 jfloat m00       = NEXT_FLOAT(b);
 889                 jfloat m01       = NEXT_FLOAT(b);
 890                 jfloat m02       = NEXT_FLOAT(b);
 891                 jfloat m10       = NEXT_FLOAT(b);
 892                 jfloat m11       = NEXT_FLOAT(b);
 893                 jfloat m12       = NEXT_FLOAT(b);
 894                 jfloat focusX    = NEXT_FLOAT(b);
 895                 void *fractions, *pixels;
 896                 fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));
 897                 pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));
 898                 [mtlc setRadialGradientPaint:useMask
 899                                       linear:linear
 900                                  cycleMethod:cycleMethod
 901                                     numStops:numStops
 902                                          m00:m00
 903                                          m01:m01
 904                                          m02:m02
 905                                          m10:m10
 906                                          m11:m11
 907                                          m12:m12
 908                                       focusX:focusX
 909                                    fractions:fractions
 910                                       pixels:pixels];
 911             }
 912             break;
 913         case sun_java2d_pipe_BufferedOpCodes_SET_TEXTURE_PAINT:
 914             {
 915                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 916                 jboolean useMask= NEXT_BOOLEAN(b);
 917                 jboolean filter = NEXT_BOOLEAN(b);
 918                 jlong pSrc      = NEXT_LONG(b);
 919                 jdouble xp0     = NEXT_DOUBLE(b);
 920                 jdouble xp1     = NEXT_DOUBLE(b);
 921                 jdouble xp3     = NEXT_DOUBLE(b);
 922                 jdouble yp0     = NEXT_DOUBLE(b);
 923                 jdouble yp1     = NEXT_DOUBLE(b);
 924                 jdouble yp3     = NEXT_DOUBLE(b);
 925                 [mtlc setTexturePaint:useMask
 926                               pSrcOps:pSrc
 927                                filter:filter
 928                                   xp0:xp0
 929                                   xp1:xp1
 930                                   xp3:xp3
 931                                   yp0:yp0
 932                                   yp1:yp1
 933                                   yp3:yp3];
 934             }
 935             break;
 936 
 937         // BufferedImageOp-related ops
 938         case sun_java2d_pipe_BufferedOpCodes_ENABLE_CONVOLVE_OP:
 939             {
 940                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 941                 jlong pSrc        = NEXT_LONG(b);
 942                 jboolean edgeZero = NEXT_BOOLEAN(b);
 943                 jint kernelWidth  = NEXT_INT(b);
 944                 jint kernelHeight = NEXT_INT(b);
 945                 MTLBufImgOps_EnableConvolveOp(mtlc, pSrc, edgeZero,
 946                                               kernelWidth, kernelHeight, b);
 947                 SKIP_BYTES(b, kernelWidth * kernelHeight * sizeof(jfloat));
 948             }
 949             break;
 950         case sun_java2d_pipe_BufferedOpCodes_DISABLE_CONVOLVE_OP:
 951             {
 952                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 953                 MTLBufImgOps_DisableConvolveOp(mtlc);
 954             }
 955             break;
 956         case sun_java2d_pipe_BufferedOpCodes_ENABLE_RESCALE_OP:
 957             {
 958                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 959                 jlong pSrc          = NEXT_LONG(b);
 960                 jboolean nonPremult = NEXT_BOOLEAN(b);
 961                 jint numFactors     = 4;
 962                 unsigned char *scaleFactors = b;
 963                 unsigned char *offsets = (b + numFactors * sizeof(jfloat));
 964                 MTLBufImgOps_EnableRescaleOp(mtlc, pSrc, nonPremult,
 965                                              scaleFactors, offsets);
 966                 SKIP_BYTES(b, numFactors * sizeof(jfloat) * 2);
 967             }
 968             break;
 969         case sun_java2d_pipe_BufferedOpCodes_DISABLE_RESCALE_OP:
 970             {
 971                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 972                 MTLBufImgOps_DisableRescaleOp(mtlc);
 973             }
 974             break;
 975         case sun_java2d_pipe_BufferedOpCodes_ENABLE_LOOKUP_OP:
 976             {
 977                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 978                 jlong pSrc          = NEXT_LONG(b);
 979                 jboolean nonPremult = NEXT_BOOLEAN(b);
 980                 jboolean shortData  = NEXT_BOOLEAN(b);
 981                 jint numBands       = NEXT_INT(b);
 982                 jint bandLength     = NEXT_INT(b);
 983                 jint offset         = NEXT_INT(b);
 984                 jint bytesPerElem = shortData ? sizeof(jshort):sizeof(jbyte);
 985                 void *tableValues = b;
 986                 MTLBufImgOps_EnableLookupOp(mtlc, pSrc, nonPremult, shortData,
 987                                             numBands, bandLength, offset,
 988                                             tableValues);
 989                 SKIP_BYTES(b, numBands * bandLength * bytesPerElem);
 990             }
 991             break;
 992         case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:
 993             {
 994                 CHECK_PREVIOUS_OP(MTL_OP_OTHER);
 995                 MTLBufImgOps_DisableLookupOp(mtlc);
 996             }
 997             break;
 998 
 999         default:
1000             J2dRlsTraceLn1(J2D_TRACE_ERROR,
1001                 &quot;MTLRenderQueue_flushBuffer: invalid opcode=%d&quot;, opcode);
1002             return;
1003         }
1004     }
1005 
1006     CHECK_PREVIOUS_OP(MTL_OP_INIT);
1007     if (mtlc != NULL) {
1008         [mtlc.encoderManager endEncoder];
1009         MTLCommandBufferWrapper * cbwrapper = [mtlc pullCommandBufferWrapper];
1010         id&lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
1011         [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
1012             [cbwrapper release];
1013         }];
1014         [commandbuf commit];
1015         if (sync) {
1016             [commandbuf waitUntilCompleted];
1017         }
1018         BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();
1019         if (dstOps != NULL) {
1020             MTLSDOps *dstMTLOps = (MTLSDOps *)dstOps-&gt;privOps;
1021             MTLLayer *layer = (MTLLayer*)dstMTLOps-&gt;layer;
1022             if (layer != NULL) {
1023                 [JNFRunLoop performOnMainThreadWaiting:NO withBlock:^(){
1024                     AWT_ASSERT_APPKIT_THREAD;
1025                     [layer setNeedsDisplay];
1026                 }];
1027             }
1028         }
1029     }
1030 }
1031 
1032 /**
1033  * Returns a pointer to the &quot;current&quot; context, as set by the last SET_SURFACES
1034  * or SET_SCRATCH_SURFACE operation.
1035  */
1036 MTLContext *
1037 MTLRenderQueue_GetCurrentContext()
1038 {
1039     return mtlc;
1040 }
1041 
1042 /**
1043  * Returns a pointer to the &quot;current&quot; destination surface, as set by the last
1044  * SET_SURFACES operation.
1045  */
1046 BMTLSDOps *
1047 MTLRenderQueue_GetCurrentDestination()
1048 {
1049     return dstOps;
1050 }
1051 
1052 #endif /* !HEADLESS */
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLTextRenderer.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLTextRenderer.m</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 235 id&lt;MTLTexture&gt;
 236 MTLTR_GetGlyphCacheTexture()
 237 {
 238     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_GetGlyphCacheTexture&quot;);
 239     if (glyphCacheAA != NULL) {
 240         return glyphCacheAA-&gt;texture;
 241     }
 242     return NULL;
 243 }
 244 
 245 /**
 246  * Adds the given glyph to the glyph cache (texture and data structure)
 247  * associated with the given MTLContext.
 248  */
 249 static void
 250 MTLTR_AddToGlyphCache(GlyphInfo *glyph, MTLContext *mtlc,
 251                       MTLPixelFormat pixelFormat)
 252 {
 253     MTLCacheCellInfo *ccinfo;
 254     MTLGlyphCacheInfo *gcinfo;



 255 
 256     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_AddToGlyphCache&quot;);
 257     if (pixelFormat == MTLPixelFormatA8Unorm) {
 258         gcinfo = glyphCacheAA;
 259     } else {
 260         gcinfo = glyphCacheLCD;

 261     }
 262 
 263     if ((gcinfo == NULL) || (glyph-&gt;image == NULL)) {
 264         return;
 265     }
 266 
 267     bool isCacheFull = MTLGlyphCache_IsCacheFull(gcinfo, glyph);
 268     if (isCacheFull) {
 269         MTLGlyphCache_Free(gcinfo);
<span class="line-modified"> 270         if (pixelFormat == MTLPixelFormatA8Unorm) {</span>
 271             MTLTR_InitGlyphCache(mtlc, JNI_FALSE);

 272         } else {
 273             MTLTR_InitGlyphCache(mtlc, JNI_TRUE);

 274         }
<span class="line-removed"> 275         gcinfo = glyphCacheAA;</span>
 276     }
 277     MTLGlyphCache_AddGlyph(gcinfo, glyph);
 278     ccinfo = (MTLCacheCellInfo *) glyph-&gt;cellInfo;
 279 
 280     if (ccinfo != NULL) {
 281         // store glyph image in texture cell
 282         MTLRegion region = {
 283                 {ccinfo-&gt;x,  ccinfo-&gt;y,   0},
<span class="line-modified"> 284                 {glyph-&gt;width, glyph-&gt;height, 1}</span>
 285         };
<span class="line-modified"> 286         NSUInteger bytesPerRow = 1 * glyph-&gt;width;</span>
<span class="line-modified"> 287         [gcinfo-&gt;texture replaceRegion:region</span>
<span class="line-modified"> 288                          mipmapLevel:0</span>
<span class="line-modified"> 289                          withBytes:glyph-&gt;image</span>
<span class="line-modified"> 290                          bytesPerRow:bytesPerRow];</span>





















 291     }
 292 }
 293 
 294 static MTLRenderPipelineDescriptor * templateRenderPipelineDesc = nil;
 295 static MTLRenderPipelineDescriptor * templateLCDPipelineDesc = nil;
 296 
 297 /**
 298  * Enables the LCD text shader and updates any related state, such as the
 299  * gamma lookup table textures.
 300  */
 301 static jboolean
 302 MTLTR_EnableLCDGlyphModeState(id&lt;MTLRenderCommandEncoder&gt; encoder,
 303                               MTLContext *mtlc, 
 304                               MTLSDOps *dstOps,
 305                               jint contrast)
 306 {
 307     // create the LCD text shader, if necessary
 308     if (templateLCDPipelineDesc == nil) {
 309 
 310         MTLVertexDescriptor *vertDesc = [[MTLVertexDescriptor new] autorelease];
</pre>
<hr />
<pre>
 785 
 786     [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];
 787 
 788     vertexCacheIndex = 0;
 789     [mtlc.encoderManager endEncoder];
 790     [blitTexture release];
 791 
 792     MTLCommandBufferWrapper* cbwrapper = [mtlc pullCommandBufferWrapper];
 793 
 794     id&lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
 795     [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
 796         [cbwrapper release];
 797     }];
 798 
 799     [commandbuf commit];
 800     [commandbuf waitUntilCompleted];
 801 
 802     return JNI_TRUE;
 803 }
 804 
<span class="line-removed"> 805 static jboolean</span>
<span class="line-removed"> 806 MTLTR_DrawColorGlyphNoCache(MTLContext *mtlc, GlyphInfo *ginfo, jint x, jint y)</span>
<span class="line-removed"> 807 {</span>
<span class="line-removed"> 808     //TODO</span>
<span class="line-removed"> 809     return JNI_TRUE;</span>
<span class="line-removed"> 810 }</span>
<span class="line-removed"> 811 </span>
<span class="line-removed"> 812 </span>
 813 // see DrawGlyphList.c for more on this macro...
 814 #define FLOOR_ASSIGN(l, r) \
 815     if ((r)&lt;0) (l) = ((int)floor(r)); else (l) = ((int)(r))
 816 
 817 void
 818 MTLTR_DrawGlyphList(JNIEnv *env, MTLContext *mtlc, BMTLSDOps *dstOps,
 819                     jint totalGlyphs, jboolean usePositions,
 820                     jboolean subPixPos, jboolean rgbOrder, jint lcdContrast,
 821                     jfloat glyphListOrigX, jfloat glyphListOrigY,
 822                     unsigned char *images, unsigned char *positions)
 823 {
 824     int glyphCounter;
 825 
 826     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList&quot;);
 827 
 828     RETURN_IF_NULL(mtlc);
 829     RETURN_IF_NULL(dstOps);
 830     RETURN_IF_NULL(images);
 831     if (usePositions) {
 832         RETURN_IF_NULL(positions);
</pre>
</td>
<td>
<hr />
<pre>
 235 id&lt;MTLTexture&gt;
 236 MTLTR_GetGlyphCacheTexture()
 237 {
 238     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_GetGlyphCacheTexture&quot;);
 239     if (glyphCacheAA != NULL) {
 240         return glyphCacheAA-&gt;texture;
 241     }
 242     return NULL;
 243 }
 244 
 245 /**
 246  * Adds the given glyph to the glyph cache (texture and data structure)
 247  * associated with the given MTLContext.
 248  */
 249 static void
 250 MTLTR_AddToGlyphCache(GlyphInfo *glyph, MTLContext *mtlc,
 251                       MTLPixelFormat pixelFormat)
 252 {
 253     MTLCacheCellInfo *ccinfo;
 254     MTLGlyphCacheInfo *gcinfo;
<span class="line-added"> 255     jboolean isLCD = JNI_FALSE;</span>
<span class="line-added"> 256     jint w = glyph-&gt;width;</span>
<span class="line-added"> 257     jint h = glyph-&gt;height;</span>
 258 
 259     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_AddToGlyphCache&quot;);
 260     if (pixelFormat == MTLPixelFormatA8Unorm) {
 261         gcinfo = glyphCacheAA;
 262     } else {
 263         gcinfo = glyphCacheLCD;
<span class="line-added"> 264         isLCD = JNI_TRUE;</span>
 265     }
 266 
 267     if ((gcinfo == NULL) || (glyph-&gt;image == NULL)) {
 268         return;
 269     }
 270 
 271     bool isCacheFull = MTLGlyphCache_IsCacheFull(gcinfo, glyph);
 272     if (isCacheFull) {
 273         MTLGlyphCache_Free(gcinfo);
<span class="line-modified"> 274         if (!isLCD) {</span>
 275             MTLTR_InitGlyphCache(mtlc, JNI_FALSE);
<span class="line-added"> 276             gcinfo = glyphCacheAA;</span>
 277         } else {
 278             MTLTR_InitGlyphCache(mtlc, JNI_TRUE);
<span class="line-added"> 279             gcinfo = glyphCacheLCD;</span>
 280         }

 281     }
 282     MTLGlyphCache_AddGlyph(gcinfo, glyph);
 283     ccinfo = (MTLCacheCellInfo *) glyph-&gt;cellInfo;
 284 
 285     if (ccinfo != NULL) {
 286         // store glyph image in texture cell
 287         MTLRegion region = {
 288                 {ccinfo-&gt;x,  ccinfo-&gt;y,   0},
<span class="line-modified"> 289                 {w, h, 1}</span>
 290         };
<span class="line-modified"> 291         if (!isLCD) {</span>
<span class="line-modified"> 292             NSUInteger bytesPerRow = 1 * w;</span>
<span class="line-modified"> 293             [gcinfo-&gt;texture replaceRegion:region</span>
<span class="line-modified"> 294                              mipmapLevel:0</span>
<span class="line-modified"> 295                              withBytes:glyph-&gt;image</span>
<span class="line-added"> 296                              bytesPerRow:bytesPerRow];</span>
<span class="line-added"> 297         } else {</span>
<span class="line-added"> 298             unsigned int imageBytes = w * h * 4;</span>
<span class="line-added"> 299             unsigned char imageData[imageBytes];</span>
<span class="line-added"> 300             memset(&amp;imageData, 0, sizeof(imageData));</span>
<span class="line-added"> 301 </span>
<span class="line-added"> 302             for (int i = 0; i &lt; h; i++) {</span>
<span class="line-added"> 303                 for (int j = 0; j &lt; w; j++) {</span>
<span class="line-added"> 304                     imageData[(i * w * 4) + j * 4] = glyph-&gt;image[(i * w * 3) + j * 3];</span>
<span class="line-added"> 305                     imageData[(i * w * 4) + j * 4 + 1] = glyph-&gt;image[(i * w * 3) + j * 3 + 1];</span>
<span class="line-added"> 306                     imageData[(i * w * 4) + j * 4 + 2] = glyph-&gt;image[(i * w * 3) + j * 3 + 2];</span>
<span class="line-added"> 307                     imageData[(i * w * 4) + j * 4 + 3] = 0xFF;</span>
<span class="line-added"> 308                 }</span>
<span class="line-added"> 309             }</span>
<span class="line-added"> 310 </span>
<span class="line-added"> 311             NSUInteger bytesPerRow = 4 * w;</span>
<span class="line-added"> 312             [gcinfo-&gt;texture replaceRegion:region</span>
<span class="line-added"> 313                              mipmapLevel:0</span>
<span class="line-added"> 314                              withBytes:imageData</span>
<span class="line-added"> 315                              bytesPerRow:bytesPerRow];</span>
<span class="line-added"> 316         }</span>
 317     }
 318 }
 319 
 320 static MTLRenderPipelineDescriptor * templateRenderPipelineDesc = nil;
 321 static MTLRenderPipelineDescriptor * templateLCDPipelineDesc = nil;
 322 
 323 /**
 324  * Enables the LCD text shader and updates any related state, such as the
 325  * gamma lookup table textures.
 326  */
 327 static jboolean
 328 MTLTR_EnableLCDGlyphModeState(id&lt;MTLRenderCommandEncoder&gt; encoder,
 329                               MTLContext *mtlc, 
 330                               MTLSDOps *dstOps,
 331                               jint contrast)
 332 {
 333     // create the LCD text shader, if necessary
 334     if (templateLCDPipelineDesc == nil) {
 335 
 336         MTLVertexDescriptor *vertDesc = [[MTLVertexDescriptor new] autorelease];
</pre>
<hr />
<pre>
 811 
 812     [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];
 813 
 814     vertexCacheIndex = 0;
 815     [mtlc.encoderManager endEncoder];
 816     [blitTexture release];
 817 
 818     MTLCommandBufferWrapper* cbwrapper = [mtlc pullCommandBufferWrapper];
 819 
 820     id&lt;MTLCommandBuffer&gt; commandbuf = [cbwrapper getCommandBuffer];
 821     [commandbuf addCompletedHandler:^(id &lt;MTLCommandBuffer&gt; commandbuf) {
 822         [cbwrapper release];
 823     }];
 824 
 825     [commandbuf commit];
 826     [commandbuf waitUntilCompleted];
 827 
 828     return JNI_TRUE;
 829 }
 830 








 831 // see DrawGlyphList.c for more on this macro...
 832 #define FLOOR_ASSIGN(l, r) \
 833     if ((r)&lt;0) (l) = ((int)floor(r)); else (l) = ((int)(r))
 834 
 835 void
 836 MTLTR_DrawGlyphList(JNIEnv *env, MTLContext *mtlc, BMTLSDOps *dstOps,
 837                     jint totalGlyphs, jboolean usePositions,
 838                     jboolean subPixPos, jboolean rgbOrder, jint lcdContrast,
 839                     jfloat glyphListOrigX, jfloat glyphListOrigY,
 840                     unsigned char *images, unsigned char *positions)
 841 {
 842     int glyphCounter;
 843 
 844     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLTR_DrawGlyphList&quot;);
 845 
 846     RETURN_IF_NULL(mtlc);
 847     RETURN_IF_NULL(dstOps);
 848     RETURN_IF_NULL(images);
 849     if (usePositions) {
 850         RETURN_IF_NULL(positions);
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/macosx/native/libawt_lwawt/java2d/metal/MTLVertexCache.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef HEADLESS
 27 
 28 #include &lt;stdlib.h&gt;
 29 #include &lt;string.h&gt;
 30 
 31 #include &quot;sun_java2d_SunGraphics2D.h&quot;
 32 
 33 #include &quot;MTLPaints.h&quot;
 34 #include &quot;MTLVertexCache.h&quot;
 35 #include &quot;MTLTexturePool.h&quot;
 36 #include &quot;MTLTextRenderer.h&quot;
 37 #include &quot;common.h&quot;
 38 
 39 typedef struct _J2DVertex {
 40     float position[2];
 41     float txtpos[2];
 42 } J2DVertex;
 43 
 44 static J2DVertex *vertexCache = NULL;
 45 static jint vertexCacheIndex = 0;
 46 
 47 static MTLPooledTextureHandle * maskCacheTex = NULL;
 48 static jint maskCacheIndex = 0;
 49 static id&lt;MTLRenderCommandEncoder&gt; encoder = NULL;
 50 
 51 #define MTLVC_ADD_VERTEX(TX, TY, DX, DY, DZ) \
 52     do { \
 53         J2DVertex *v = &amp;vertexCache[vertexCacheIndex++]; \
 54         v-&gt;txtpos[0] = TX; \
 55         v-&gt;txtpos[1] = TY; \
 56         v-&gt;position[0]= DX; \
 57         v-&gt;position[1] = DY; \
 58     } while (0)
 59 
 60 #define MTLVC_ADD_TRIANGLES(TX1, TY1, TX2, TY2, DX1, DY1, DX2, DY2) \
 61     do { \
 62         MTLVC_ADD_VERTEX(TX1, TY1, DX1, DY1, 0); \
 63         MTLVC_ADD_VERTEX(TX2, TY1, DX2, DY1, 0); \
 64         MTLVC_ADD_VERTEX(TX2, TY2, DX2, DY2, 0); \
 65         MTLVC_ADD_VERTEX(TX2, TY2, DX2, DY2, 0); \
 66         MTLVC_ADD_VERTEX(TX1, TY2, DX1, DY2, 0); \
 67         MTLVC_ADD_VERTEX(TX1, TY1, DX1, DY1, 0); \
 68     } while (0)
 69 
 70 jboolean
 71 MTLVertexCache_InitVertexCache()
 72 {
 73     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLVertexCache_InitVertexCache&quot;);
 74 
 75     if (vertexCache == NULL) {
 76         J2dTraceLn(J2D_TRACE_INFO, &quot;MTLVertexCache_InitVertexCache : vertexCache == NULL&quot;);
 77         vertexCache = (J2DVertex *)malloc(MTLVC_MAX_INDEX * sizeof(J2DVertex));
 78         if (vertexCache == NULL) {
 79             return JNI_FALSE;
 80         }
 81     }
 82 
 83     return JNI_TRUE;
 84 }
 85 
 86 void
 87 MTLVertexCache_FlushVertexCache(MTLContext *mtlc)
 88 {
 89     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLVertexCache_FlushVertexCache&quot;);
 90 
 91     if (vertexCacheIndex &gt; 0) {
 92         [encoder setVertexBytes: vertexCache length:vertexCacheIndex * sizeof(J2DVertex)
 93                                                 atIndex:MeshVertexBuffer];
 94 
 95         [encoder setFragmentTexture:maskCacheTex.texture atIndex: 0];
<a name="1" id="anc1"></a><span class="line-modified"> 96         for (int i = 0; i &lt; maskCacheIndex; i++) {</span>
<span class="line-modified"> 97             J2dTraceLn1(J2D_TRACE_INFO, &quot;MTLVertexCache_FlushVertexCache : draw texture at index %d&quot;, i);</span>
<span class="line-modified"> 98             [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:i*6 vertexCount:6];</span>
<span class="line-removed"> 99         }</span>
100     }
101     vertexCacheIndex = 0;
102     maskCacheIndex = 0;
103 
104     if (maskCacheTex != nil) {
105         [[mtlc getCommandBufferWrapper] registerPooledTexture:maskCacheTex];
106         [maskCacheTex release];
107         maskCacheTex = nil;
108     }
109 }
110 
111 void
112 MTLVertexCache_FlushGlyphVertexCache()
113 {
114     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLVertexCache_FlushGlyphVertexCache&quot;);
115 
116     if (vertexCacheIndex &gt; 0) {
117         [encoder setVertexBytes: vertexCache length:vertexCacheIndex * sizeof(J2DVertex)
118                                                 atIndex:MeshVertexBuffer];
119         id&lt;MTLTexture&gt; glyphCacheTex = MTLTR_GetGlyphCacheTexture();
120         [encoder setFragmentTexture:glyphCacheTex atIndex: 0];
<a name="2" id="anc2"></a><span class="line-modified">121         for (int i = 0; i &lt; vertexCacheIndex; i = i + 6) {</span>
<span class="line-modified">122             J2dTraceLn1(J2D_TRACE_INFO, &quot;MTLVertexCache_FlushGlyphVertexCache : draw texture at index %d&quot;, (int)(i + 1)/6);</span>
<span class="line-modified">123             [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:i vertexCount:6];</span>
<span class="line-removed">124         }</span>
125     }
126     vertexCacheIndex = 0;
127 }
128 
129 void MTLVertexCache_FreeVertexCache()
130 {
131     free(vertexCache);
132     vertexCache = NULL;
133 }
134 
135 /**
136  * This method is somewhat hacky, but necessary for the foreseeable future.
137  * The problem is the way OpenGL handles color values in vertex arrays.  When
138  * a vertex in a vertex array contains a color, and then the vertex array
139  * is rendered via glDrawArrays(), the global OpenGL color state is actually
140  * modified each time a vertex is rendered.  This means that after all
141  * vertices have been flushed, the global OpenGL color state will be set to
142  * the color of the most recently rendered element in the vertex array.
143  *
144  * The reason this is a problem for us is that we do not want to flush the
145  * vertex array (in the case of mask/glyph operations) or issue a glEnd()
146  * (in the case of non-antialiased primitives) everytime the current color
147  * changes, which would defeat any benefit from batching in the first place.
148  * We handle this in practice by not calling CHECK/RESET_PREVIOUS_OP() when
149  * the simple color state is changing in MTLPaints_SetColor().  This is
150  * problematic for vertex caching because we may end up with the following
151  * situation, for example:
152  *   SET_COLOR (orange)
153  *   MASK_FILL
154  *   MASK_FILL
155  *   SET_COLOR (blue; remember, this won&#39;t cause a flush)
156  *   FILL_RECT (this will cause the vertex array to be flushed)
157  *
158  * In this case, we would actually end up rendering an orange FILL_RECT,
159  * not a blue one as intended, because flushing the vertex cache flush would
160  * override the color state from the most recent SET_COLOR call.
161  *
162  * Long story short, the easiest way to resolve this problem is to call
163  * this method just after disabling the mask/glyph cache, which will ensure
164  * that the appropriate color state is restored.
165  */
166 void
167 MTLVertexCache_RestoreColorState(MTLContext *mtlc)
168 {
169 //    TODO
170 //    if (mtlc.paint.paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {
171 //        //mtlc.paint.color = mtlc.paint.pixel;
172 //    }
173 }
174 
175 static jboolean
176 MTLVertexCache_InitMaskCache(MTLContext *mtlc) {
177     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLVertexCache_InitMaskCache&quot;);
178     // TODO : We are creating mask cache only of type MTLPixelFormatA8Unorm
179     // when we need more than 1 byte to store a pixel(LCD) we need to update
180     // below code.
181     if (maskCacheTex == NULL) {
182         maskCacheTex = [mtlc.texturePool getTexture:MTLVC_MASK_CACHE_WIDTH_IN_TEXELS
183                                              height:MTLVC_MASK_CACHE_HEIGHT_IN_TEXELS
184                                              format:MTLPixelFormatA8Unorm];
185         if (maskCacheTex == nil) {
186             J2dTraceLn(J2D_TRACE_ERROR, &quot;MTLVertexCache_InitMaskCache: can&#39;t obtain temporary texture object from pool&quot;);
187             return JNI_FALSE;
188         }
189     }
190     // init special fully opaque tile in the upper-right corner of
191     // the mask cache texture
192 
193     char tile[MTLVC_MASK_CACHE_TILE_SIZE];
194     memset(tile, 0xff, MTLVC_MASK_CACHE_TILE_SIZE);
195 
196     jint texx = MTLVC_MASK_CACHE_TILE_WIDTH * (MTLVC_MASK_CACHE_WIDTH_IN_TILES - 1);
197 
198     jint texy = MTLVC_MASK_CACHE_TILE_HEIGHT * (MTLVC_MASK_CACHE_HEIGHT_IN_TILES - 1);
199 
200     NSUInteger bytesPerRow = 1 * MTLVC_MASK_CACHE_TILE_WIDTH;
201 
202     MTLRegion region = {
203             {texx,  texy,   0},
204             {MTLVC_MASK_CACHE_TILE_WIDTH, MTLVC_MASK_CACHE_TILE_HEIGHT, 1}
205     };
206 
207 
208     // do we really need this??
209     [maskCacheTex.texture replaceRegion:region
210                     mipmapLevel:0
211                       withBytes:tile
212                     bytesPerRow:bytesPerRow];
213 
214     return JNI_TRUE;
215 }
216 
217 void
218 MTLVertexCache_EnableMaskCache(MTLContext *mtlc, BMTLSDOps *dstOps)
219 {
220     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLVertexCache_EnableMaskCache&quot;);
221 
222     if (!MTLVertexCache_InitVertexCache()) {
223         return;
224     }
225 
226     if (maskCacheTex == NULL) {
227         if (!MTLVertexCache_InitMaskCache(mtlc)) {
228             return;
229         }
230     }
231     MTLVertexCache_CreateSamplingEncoder(mtlc, dstOps);
232 }
233 
234 void
235 MTLVertexCache_DisableMaskCache(MTLContext *mtlc)
236 {
237     // TODO : Once we enable check_previous_op
238     // we will start using DisableMaskCache until then
239     // we are force flusging vertexcache.
240     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLVertexCache_DisableMaskCache&quot;);
241     MTLVertexCache_FlushVertexCache(mtlc);
242     MTLVertexCache_RestoreColorState(mtlc);
243     if (maskCacheTex != nil) {
244         [[mtlc getCommandBufferWrapper] registerPooledTexture:maskCacheTex];
245         [maskCacheTex release];
246         maskCacheTex = nil;
247     }
248     maskCacheIndex = 0;
249     free(vertexCache);
250     vertexCache = NULL;
251 }
252 
253 void
254 MTLVertexCache_CreateSamplingEncoder(MTLContext *mtlc, BMTLSDOps *dstOps) {
255     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLVertexCache_CreateSamplingEncoder&quot;);
256     encoder = [mtlc.encoderManager getTextureEncoder:dstOps isSrcOpaque:NO];
257 }
258 
259 void
260 MTLVertexCache_AddMaskQuad(MTLContext *mtlc,
261                            jint srcx, jint srcy,
262                            jint dstx, jint dsty,
263                            jint width, jint height,
264                            jint maskscan, void *mask,
265                            BMTLSDOps *dstOps,
266                            jint fullwidth)
267 {
268     jfloat tx1, ty1, tx2, ty2;
269     jfloat dx1, dy1, dx2, dy2;
270 
271     J2dTraceLn1(J2D_TRACE_INFO, &quot;MTLVertexCache_AddMaskQuad: %d&quot;,
272                 maskCacheIndex);
273 
274     if (maskCacheIndex &gt;= MTLVC_MASK_CACHE_MAX_INDEX)
275     {
276         J2dTraceLn2(J2D_TRACE_INFO, &quot;maskCacheIndex = %d, vertexCacheIndex = %d&quot;, maskCacheIndex, vertexCacheIndex);
277         MTLVertexCache_FlushVertexCache(mtlc);
278         // TODO : Since we are not committing command buffer
279         // in FlushVertexCache we need to create new maskcache
280         // after present cache is full. Check whether we can
281         // avoid multiple cache creation.
282         MTLVertexCache_EnableMaskCache(mtlc, dstOps);
283         maskCacheIndex = 0;
284     }
285 
286     if (mask != NULL) {
287         jint texx = MTLVC_MASK_CACHE_TILE_WIDTH *
288                     (maskCacheIndex % MTLVC_MASK_CACHE_WIDTH_IN_TILES);
289         jint texy = MTLVC_MASK_CACHE_TILE_HEIGHT *
290                     (maskCacheIndex / MTLVC_MASK_CACHE_WIDTH_IN_TILES);
291         J2dTraceLn5(J2D_TRACE_INFO, &quot;texx = %d texy = %d width = %d height = %d fullwidth = %d&quot;, texx, texy, width,
292                     height, fullwidth);
293         NSUInteger bytesPerRow = 1 * width;
294         NSUInteger slice = bytesPerRow * srcy + srcx;
295         MTLRegion region = {
296                 {texx,  texy,   0},
297                 {width, height, 1}
298         };
299 
300         // Whenever we have source stride bigger that destination stride
301         // we need to pick appropriate source subtexture. In repalceRegion
302         // we can give destination subtexturing properly but we can&#39;t
303         // subtexture from system memory glyph we have. So in such
304         // cases we are creating seperate tile and scan the source
305         // stride into destination using memcpy. In case of OpenGL we
306         // can update source pointers, in case of D3D we ar doing memcpy.
307         // We can use MTLBuffer and then copy source subtexture but that
308         // adds extra blitting logic.
309         // TODO : Research more and try removing memcpy logic.
310         if (fullwidth &lt;= width) {
311             int height_offset = bytesPerRow * srcy;
312             [maskCacheTex.texture replaceRegion:region
313                             mipmapLevel:0
314                               withBytes:mask + height_offset
315                             bytesPerRow:bytesPerRow];
316         } else {
317             int dst_offset, src_offset;
318             int size = 1 * width * height;
319             char tile[size];
320             dst_offset = 0;
321             for (int i = srcy; i &lt; srcy + height; i++) {
322                 J2dTraceLn2(J2D_TRACE_INFO, &quot;srcx = %d srcy = %d&quot;, srcx, srcy);
323                 src_offset = fullwidth * i + srcx;
324                 J2dTraceLn2(J2D_TRACE_INFO, &quot;src_offset = %d dst_offset = %d&quot;, src_offset, dst_offset);
325                 memcpy(tile + dst_offset, mask + src_offset, width);
326                 dst_offset = dst_offset + width;
327             }
328             [maskCacheTex.texture replaceRegion:region
329                             mipmapLevel:0
330                               withBytes:tile
331                             bytesPerRow:bytesPerRow];
332         }
333 
334         tx1 = ((jfloat) texx) / MTLVC_MASK_CACHE_WIDTH_IN_TEXELS;
335         ty1 = ((jfloat) texy) / MTLVC_MASK_CACHE_HEIGHT_IN_TEXELS;
336     } else {
337         tx1 = ((jfloat)MTLVC_MASK_CACHE_SPECIAL_TILE_X) /
338               MTLVC_MASK_CACHE_WIDTH_IN_TEXELS;
339         ty1 = ((jfloat)MTLVC_MASK_CACHE_SPECIAL_TILE_Y) /
340               MTLVC_MASK_CACHE_HEIGHT_IN_TEXELS;
341     }
342     maskCacheIndex++;
343 
344     tx2 = tx1 + (((jfloat)width) / MTLVC_MASK_CACHE_WIDTH_IN_TEXELS);
345     ty2 = ty1 + (((jfloat)height) / MTLVC_MASK_CACHE_HEIGHT_IN_TEXELS);
346 
347     dx1 = (jfloat)dstx;
348     dy1 = (jfloat)dsty;
349     dx2 = dx1 + width;
350     dy2 = dy1 + height;
351 
352     J2dTraceLn8(J2D_TRACE_INFO, &quot;tx1 = %f ty1 = %f tx2 = %f ty2 = %f dx1 = %f dy1 = %f dx2 = %f dy2 = %f&quot;, tx1, ty1, tx2, ty2, dx1, dy1, dx2, dy2);
353     MTLVC_ADD_TRIANGLES(tx1, ty1, tx2, ty2,
354                         dx1, dy1, dx2, dy2);
355 }
356 
357 void
358 MTLVertexCache_AddGlyphQuad(MTLContext *mtlc,
359                             jfloat tx1, jfloat ty1, jfloat tx2, jfloat ty2,
360                             jfloat dx1, jfloat dy1, jfloat dx2, jfloat dy2)
361 {
362     J2dTraceLn(J2D_TRACE_INFO, &quot;MTLVertexCache_AddGlyphQuad&quot;);
363 
364     if (vertexCacheIndex &gt;= MTLVC_MAX_INDEX)
365     {
366         J2dTraceLn2(J2D_TRACE_INFO, &quot;maskCacheIndex = %d, vertexCacheIndex = %d&quot;, maskCacheIndex, vertexCacheIndex);
367         MTLVertexCache_FlushGlyphVertexCache();
368     }
369 
370     MTLVC_ADD_TRIANGLES(tx1, ty1, tx2, ty2,
371                         dx1, dy1, dx2, dy2);
372 }
373 
374 #endif /* !HEADLESS */
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
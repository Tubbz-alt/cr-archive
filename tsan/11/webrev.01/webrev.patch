diff a/src/hotspot/cpu/aarch64/templateTable_aarch64.cpp b/src/hotspot/cpu/aarch64/templateTable_aarch64.cpp
--- a/src/hotspot/cpu/aarch64/templateTable_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/templateTable_aarch64.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
@@ -751,10 +751,72 @@
   __ mov(rscratch1, Interpreter::_throw_ArrayIndexOutOfBoundsException_entry);
   __ br(rscratch1);
   __ bind(ok);
 }
 
+#if INCLUDE_TSAN
+
+void TemplateTable::tsan_observe_get_or_put(const Address &field,
+                                            Register flags,
+                                            TsanMemoryReadWriteFunction tsan_function,
+                                            TosState tos) {
+  assert(ThreadSanitizer, "ThreadSanitizer should be set");
+
+  TsanMemoryReleaseAcquireFunction releaseAcquireFunction =
+      tsan_release_acquire_method(tsan_function);
+
+  Label done, notAcquireRelease;
+
+  // We could save some instructions by only saving the registers we need.
+  __ pusha();
+  // pusha() doesn't save v0, which tsan_function clobbers and the
+  // interpreter still needs.
+  // This really only needs to be done for some of the float/double accesses,
+  // but it's here because it's cleaner.
+  __ push_d(v0);
+  // For volatile reads/writes use an acquire/release.
+  // If a reference is annotated to be ignored, assume it's safe to
+  // access the object it's referring to and create a happens-before relation
+  // between the accesses to this reference.
+  if (tos == atos) {
+    int32_t acquire_release_mask = 1 << ConstantPoolCacheEntry::is_volatile_shift |
+      1 << ConstantPoolCacheEntry::is_tsan_ignore_shift;
+    __ mov(rscratch1, acquire_release_mask);
+    __ tst(flags, rscratch1);
+    __ br(Assembler::EQ, notAcquireRelease);
+  } else {
+    __ tbz(flags, ConstantPoolCacheEntry::is_volatile_shift, notAcquireRelease);
+  }
+
+  __ lea(c_rarg0, field);
+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, releaseAcquireFunction), c_rarg0);
+  if (ThreadSanitizerJavaMemory) {
+    __ b(done);
+    __ bind(notAcquireRelease);
+
+    // Ignore reads/writes to final fields. They can't be racy.
+    __ tbnz(flags, ConstantPoolCacheEntry::is_final_shift, done);
+
+    // Don't report races on tsan ignored fields.
+    __ tbnz(flags, ConstantPoolCacheEntry::is_tsan_ignore_shift, done);
+
+    __ lea(c_rarg0, field);
+    __ get_method(c_rarg1);
+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, tsan_function),
+                    c_rarg0 /* addr */, c_rarg1 /* method */, rbcp /* bcp */);
+
+    __ bind(done);
+  } else {
+    __ bind(notAcquireRelease);
+  }
+  __ pop_d(v0);
+  __ popa();
+}
+
+
+#endif
+
 void TemplateTable::iaload()
 {
   transition(itos, itos);
   __ mov(r1, r0);
   __ pop_ptr(r0);
@@ -2376,10 +2438,29 @@
     __ ldr(obj, Address(cache, in_bytes(cp_base_offset +
                                         ConstantPoolCacheEntry::f1_offset())));
     const int mirror_offset = in_bytes(Klass::java_mirror_offset());
     __ ldr(obj, Address(obj, mirror_offset));
     __ resolve_oop_handle(obj);
+    TSAN_RUNTIME_ONLY(
+      // Draw a happens-before edge from the class's static initializer to
+      // this lookup.
+
+      // java_lang_Class::_init_lock_offset may not have been initialized
+      // when generating code. It will be initialized at runtime though.
+      // So calculate its address and read from it at runtime.
+      __ pusha();
+      __ mov(c_rarg0, obj);
+      Address init_lock_offset_address((address) java_lang_Class::init_lock_offset_addr(),
+                                       relocInfo::none);
+      __ lea(rscratch1, init_lock_offset_address);
+      __ ldrw(rscratch1, Address(rscratch1, 0));
+      __ add(c_rarg0, c_rarg0, rscratch1);
+      __ call_VM_leaf(CAST_FROM_FN_PTR(address,
+                                       SharedRuntime::tsan_acquire),
+                                       c_rarg0);
+      __ popa();
+    );
   }
 }
 
 void TemplateTable::load_invoke_cp_cache_entry(int byte_no,
                                                Register method,
@@ -2511,10 +2592,11 @@
   if (is_static) rc = may_not_rewrite;
 
   // btos
   __ access_load_at(T_BYTE, IN_HEAP, r0, field, noreg, noreg);
   __ push(btos);
+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read1, btos));
   // Rewrite bytecode to be faster
   if (rc == may_rewrite) {
     patch_bytecode(Bytecodes::_fast_bgetfield, bc, r1);
   }
   __ b(Done);
@@ -2524,10 +2606,11 @@
   __ br(Assembler::NE, notBool);
 
   // ztos (same code as btos)
   __ access_load_at(T_BOOLEAN, IN_HEAP, r0, field, noreg, noreg);
   __ push(ztos);
+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read1, ztos));
   // Rewrite bytecode to be faster
   if (rc == may_rewrite) {
     // use btos rewriting, no truncating to t/f bit is needed for getfield.
     patch_bytecode(Bytecodes::_fast_bgetfield, bc, r1);
   }
@@ -2537,10 +2620,15 @@
   __ cmp(flags, (u1)atos);
   __ br(Assembler::NE, notObj);
   // atos
   do_oop_load(_masm, field, r0, IN_HEAP);
   __ push(atos);
+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field,
+                                            raw_flags,
+                                            UseCompressedOops ? SharedRuntime::tsan_read4
+                                                              : SharedRuntime::tsan_read8,
+                                            atos));
   if (rc == may_rewrite) {
     patch_bytecode(Bytecodes::_fast_agetfield, bc, r1);
   }
   __ b(Done);
 
@@ -2548,10 +2636,11 @@
   __ cmp(flags, (u1)itos);
   __ br(Assembler::NE, notInt);
   // itos
   __ access_load_at(T_INT, IN_HEAP, r0, field, noreg, noreg);
   __ push(itos);
+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read4, itos));
   // Rewrite bytecode to be faster
   if (rc == may_rewrite) {
     patch_bytecode(Bytecodes::_fast_igetfield, bc, r1);
   }
   __ b(Done);
@@ -2560,10 +2649,11 @@
   __ cmp(flags, (u1)ctos);
   __ br(Assembler::NE, notChar);
   // ctos
   __ access_load_at(T_CHAR, IN_HEAP, r0, field, noreg, noreg);
   __ push(ctos);
+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read2, ctos));
   // Rewrite bytecode to be faster
   if (rc == may_rewrite) {
     patch_bytecode(Bytecodes::_fast_cgetfield, bc, r1);
   }
   __ b(Done);
@@ -2572,10 +2662,11 @@
   __ cmp(flags, (u1)stos);
   __ br(Assembler::NE, notShort);
   // stos
   __ access_load_at(T_SHORT, IN_HEAP, r0, field, noreg, noreg);
   __ push(stos);
+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read2, stos));
   // Rewrite bytecode to be faster
   if (rc == may_rewrite) {
     patch_bytecode(Bytecodes::_fast_sgetfield, bc, r1);
   }
   __ b(Done);
@@ -2584,10 +2675,11 @@
   __ cmp(flags, (u1)ltos);
   __ br(Assembler::NE, notLong);
   // ltos
   __ access_load_at(T_LONG, IN_HEAP, r0, field, noreg, noreg);
   __ push(ltos);
+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read8, ltos));
   // Rewrite bytecode to be faster
   if (rc == may_rewrite) {
     patch_bytecode(Bytecodes::_fast_lgetfield, bc, r1);
   }
   __ b(Done);
@@ -2596,10 +2688,11 @@
   __ cmp(flags, (u1)ftos);
   __ br(Assembler::NE, notFloat);
   // ftos
   __ access_load_at(T_FLOAT, IN_HEAP, noreg /* ftos */, field, noreg, noreg);
   __ push(ftos);
+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read4, ftos));
   // Rewrite bytecode to be faster
   if (rc == may_rewrite) {
     patch_bytecode(Bytecodes::_fast_fgetfield, bc, r1);
   }
   __ b(Done);
@@ -2610,10 +2703,11 @@
   __ br(Assembler::NE, notDouble);
 #endif
   // dtos
   __ access_load_at(T_DOUBLE, IN_HEAP, noreg /* ftos */, field, noreg, noreg);
   __ push(dtos);
+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read8, dtos));
   // Rewrite bytecode to be faster
   if (rc == may_rewrite) {
     patch_bytecode(Bytecodes::_fast_dgetfield, bc, r1);
   }
 #ifdef ASSERT
@@ -2717,10 +2811,11 @@
   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
   jvmti_post_field_mod(cache, index, is_static);
   load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);
 
   Label Done;
+  // save raw flags in r5
   __ mov(r5, flags);
 
   {
     Label notVolatile;
     __ tbz(r5, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);
@@ -2746,10 +2841,11 @@
 
   // btos
   {
     __ pop(btos);
     if (!is_static) pop_and_check_object(obj);
+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write1, btos));
     __ access_store_at(T_BYTE, IN_HEAP, field, r0, noreg, noreg);
     if (rc == may_rewrite) {
       patch_bytecode(Bytecodes::_fast_bputfield, bc, r1, true, byte_no);
     }
     __ b(Done);
@@ -2761,10 +2857,11 @@
 
   // ztos
   {
     __ pop(ztos);
     if (!is_static) pop_and_check_object(obj);
+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write1, ztos));
     __ access_store_at(T_BOOLEAN, IN_HEAP, field, r0, noreg, noreg);
     if (rc == may_rewrite) {
       patch_bytecode(Bytecodes::_fast_zputfield, bc, r1, true, byte_no);
     }
     __ b(Done);
@@ -2776,10 +2873,15 @@
 
   // atos
   {
     __ pop(atos);
     if (!is_static) pop_and_check_object(obj);
+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field,
+                                              r5,
+                                              UseCompressedOops ? SharedRuntime::tsan_write4
+                                                                : SharedRuntime::tsan_write8,
+                                              atos));
     // Store into the field
     do_oop_store(_masm, field, r0, IN_HEAP);
     if (rc == may_rewrite) {
       patch_bytecode(Bytecodes::_fast_aputfield, bc, r1, true, byte_no);
     }
@@ -2792,10 +2894,11 @@
 
   // itos
   {
     __ pop(itos);
     if (!is_static) pop_and_check_object(obj);
+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write4, itos));
     __ access_store_at(T_INT, IN_HEAP, field, r0, noreg, noreg);
     if (rc == may_rewrite) {
       patch_bytecode(Bytecodes::_fast_iputfield, bc, r1, true, byte_no);
     }
     __ b(Done);
@@ -2807,10 +2910,11 @@
 
   // ctos
   {
     __ pop(ctos);
     if (!is_static) pop_and_check_object(obj);
+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write2, ctos));
     __ access_store_at(T_CHAR, IN_HEAP, field, r0, noreg, noreg);
     if (rc == may_rewrite) {
       patch_bytecode(Bytecodes::_fast_cputfield, bc, r1, true, byte_no);
     }
     __ b(Done);
@@ -2822,10 +2926,11 @@
 
   // stos
   {
     __ pop(stos);
     if (!is_static) pop_and_check_object(obj);
+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write2, stos));
     __ access_store_at(T_SHORT, IN_HEAP, field, r0, noreg, noreg);
     if (rc == may_rewrite) {
       patch_bytecode(Bytecodes::_fast_sputfield, bc, r1, true, byte_no);
     }
     __ b(Done);
@@ -2837,10 +2942,11 @@
 
   // ltos
   {
     __ pop(ltos);
     if (!is_static) pop_and_check_object(obj);
+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write8, ltos));
     __ access_store_at(T_LONG, IN_HEAP, field, r0, noreg, noreg);
     if (rc == may_rewrite) {
       patch_bytecode(Bytecodes::_fast_lputfield, bc, r1, true, byte_no);
     }
     __ b(Done);
@@ -2852,10 +2958,11 @@
 
   // ftos
   {
     __ pop(ftos);
     if (!is_static) pop_and_check_object(obj);
+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write4, ftos));
     __ access_store_at(T_FLOAT, IN_HEAP, field, noreg /* ftos */, noreg, noreg);
     if (rc == may_rewrite) {
       patch_bytecode(Bytecodes::_fast_fputfield, bc, r1, true, byte_no);
     }
     __ b(Done);
@@ -2869,10 +2976,11 @@
 
   // dtos
   {
     __ pop(dtos);
     if (!is_static) pop_and_check_object(obj);
+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write8, dtos));
     __ access_store_at(T_DOUBLE, IN_HEAP, field, noreg /* dtos */, noreg, noreg);
     if (rc == may_rewrite) {
       patch_bytecode(Bytecodes::_fast_dputfield, bc, r1, true, byte_no);
     }
   }
diff a/src/hotspot/cpu/x86/templateTable_x86.cpp b/src/hotspot/cpu/x86/templateTable_x86.cpp
--- a/src/hotspot/cpu/x86/templateTable_x86.cpp
+++ b/src/hotspot/cpu/x86/templateTable_x86.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -767,27 +767,10 @@
   __ bind(skip);
 }
 
 #if INCLUDE_TSAN
 
-TemplateTable::TsanMemoryReleaseAcquireFunction TemplateTable::tsan_release_acquire_method(
-    TsanMemoryReadWriteFunction tsan_function) {
-  if (tsan_function == SharedRuntime::tsan_read1
-      || tsan_function == SharedRuntime::tsan_read2
-      || tsan_function == SharedRuntime::tsan_read4
-      || tsan_function == SharedRuntime::tsan_read8) {
-    return SharedRuntime::tsan_acquire;
-  } else if (tsan_function == SharedRuntime::tsan_write1
-      || tsan_function == SharedRuntime::tsan_write2
-      || tsan_function == SharedRuntime::tsan_write4
-      || tsan_function == SharedRuntime::tsan_write8) {
-    return SharedRuntime::tsan_release;
-  }
-  ShouldNotReachHere();
-  return NULL;
-}
-
 void TemplateTable::tsan_observe_get_or_put(
     const Address &field,
     Register flags,
     TsanMemoryReadWriteFunction tsan_function,
     TosState tos) {
diff a/src/hotspot/cpu/x86/templateTable_x86.hpp b/src/hotspot/cpu/x86/templateTable_x86.hpp
--- a/src/hotspot/cpu/x86/templateTable_x86.hpp
+++ b/src/hotspot/cpu/x86/templateTable_x86.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -41,42 +41,7 @@
 
   static void putfield_or_static_helper(int byte_no, bool is_static, RewriteControl rc,
                                         Register obj, Register off, Register flags);
   static void fast_storefield_helper(Address field, Register rax);
 
-#if INCLUDE_TSAN
-  typedef void (*TsanMemoryReleaseAcquireFunction)(void* /* address */);
-  typedef void (*TsanMemoryReadWriteFunction)(void* /* address */,
-                                              Method* /* method */,
-                                              address /* bcp */);
-
-  // The corresponding tsan_acquire/release function for a
-  // TsanMemoryReadWriteFunction.
-  static TsanMemoryReleaseAcquireFunction tsan_release_acquire_method(
-      TsanMemoryReadWriteFunction tsan_function);
-
-  // Tell tsan that a member/static variable has been read from or written to.
-  // tsan_function must be one of the SharedRuntime::tsan_read/write*
-  // functions.
-  // Flags is the register that contains the field cache entry flags bitfield.
-  // Because the field may be volatile, for a write, this function must be
-  // called before the write; for a read, this function must be called after
-  // the read. This way the acquire/release is ordered correctly relative to the
-  // read/write.
-  static void tsan_observe_get_or_put(
-      const Address &field,
-      Register flags,
-      TsanMemoryReadWriteFunction tsan_function,
-      TosState tos);
-
-  // Tell tsan that an array has been read from or written to.
-  // tsan_function must be one of the SharedRuntime::tsan_read/write*
-  // functions.
-  // Unlike tsan_observe_get_or_put(), the ordering relative to the
-  // read/write does not matter since array loads/stores are never volatile.
-  static void tsan_observe_load_or_store(
-      const Address& address,
-      TsanMemoryReadWriteFunction tsan_function);
-
-#endif  // INCLUDE_TSAN
 
 #endif // CPU_X86_TEMPLATETABLE_X86_HPP
diff a/src/hotspot/share/interpreter/templateTable.cpp b/src/hotspot/share/interpreter/templateTable.cpp
--- a/src/hotspot/share/interpreter/templateTable.cpp
+++ b/src/hotspot/share/interpreter/templateTable.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -25,10 +25,13 @@
 #include "precompiled.hpp"
 #include "gc/shared/barrierSet.hpp"
 #include "interpreter/interp_masm.hpp"
 #include "interpreter/templateTable.hpp"
 #include "runtime/timerTrace.hpp"
+#if INCLUDE_TSAN
+#include "runtime/sharedRuntime.hpp"
+#endif
 
 #ifdef CC_INTERP
 
 void templateTable_init() {
 }
@@ -66,10 +69,31 @@
 
 
 //----------------------------------------------------------------------------------------------------
 // Implementation of TemplateTable: Platform-independent helper routines
 
+#if INCLUDE_TSAN
+
+TemplateTable::TsanMemoryReleaseAcquireFunction TemplateTable::tsan_release_acquire_method(
+    TsanMemoryReadWriteFunction tsan_function) {
+  if (tsan_function == SharedRuntime::tsan_read1
+      || tsan_function == SharedRuntime::tsan_read2
+      || tsan_function == SharedRuntime::tsan_read4
+      || tsan_function == SharedRuntime::tsan_read8) {
+    return SharedRuntime::tsan_acquire;
+  } else if (tsan_function == SharedRuntime::tsan_write1
+      || tsan_function == SharedRuntime::tsan_write2
+      || tsan_function == SharedRuntime::tsan_write4
+      || tsan_function == SharedRuntime::tsan_write8) {
+    return SharedRuntime::tsan_release;
+  }
+  ShouldNotReachHere();
+  return NULL;
+}
+
+#endif
+
 void TemplateTable::call_VM(Register oop_result, address entry_point) {
   assert(_desc->calls_vm(), "inconsistent calls_vm information");
   _masm->call_VM(oop_result, entry_point);
 }
 
diff a/src/hotspot/share/interpreter/templateTable.hpp b/src/hotspot/share/interpreter/templateTable.hpp
--- a/src/hotspot/share/interpreter/templateTable.hpp
+++ b/src/hotspot/share/interpreter/templateTable.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -349,10 +349,46 @@
 
   // Templates
   static Template* template_for     (Bytecodes::Code code)  { Bytecodes::check     (code); return &_template_table     [code]; }
   static Template* template_for_wide(Bytecodes::Code code)  { Bytecodes::wide_check(code); return &_template_table_wide[code]; }
 
+#if INCLUDE_TSAN
+   typedef void (*TsanMemoryReleaseAcquireFunction)(void* /* address */);
+
+   typedef void (*TsanMemoryReadWriteFunction)(void* /* address */,
+                                               Method* /* method */,
+                                               address /* bcp */);
+
+   // The corresponding tsan_acquire/release function for a
+   // TsanMemoryReadWriteFunction.
+   static TsanMemoryReleaseAcquireFunction tsan_release_acquire_method(
+       TsanMemoryReadWriteFunction tsan_function);
+
+   // Tell tsan that a member/static variable has been read from or written to.
+   // tsan_function must be one of the SharedRuntime::tsan_read/write*
+   // functions.
+   // Flags is the register that contains the field cache entry flags bitfield.
+   // Because the field may be volatile, for a write, this function must be
+   // called before the write; for a read, this function must be called after
+   // the read. This way the acquire/release is ordered correctly relative to the
+   // read/write.
+   static void tsan_observe_get_or_put(
+       const Address &field,
+       Register flags,
+       TsanMemoryReadWriteFunction tsan_function,
+       TosState tos);
+
+   // Tell tsan that an array has been read from or written to.
+   // tsan_function must be one of the SharedRuntime::tsan_read/write*
+   // functions.
+   // Unlike tsan_observe_get_or_put(), the ordering relative to the
+   // read/write does not matter since array loads/stores are never volatile.
+   static void tsan_observe_load_or_store(
+       const Address& address,
+       TsanMemoryReadWriteFunction tsan_function);
+#endif
+
   // Platform specifics
 #include CPU_HEADER(templateTable)
 
 };
 #endif /* !CC_INTERP */

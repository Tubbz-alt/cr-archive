<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/x86/templateTable_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;compiler/disassembler.hpp&quot;
  28 #include &quot;interpreter/interpreter.hpp&quot;
  29 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  30 #include &quot;interpreter/interp_masm.hpp&quot;
  31 #include &quot;interpreter/templateTable.hpp&quot;
  32 #include &quot;memory/universe.hpp&quot;
  33 #include &quot;oops/methodData.hpp&quot;
  34 #include &quot;oops/objArrayKlass.hpp&quot;
  35 #include &quot;oops/oop.inline.hpp&quot;
  36 #include &quot;prims/methodHandles.hpp&quot;
  37 #include &quot;runtime/frame.inline.hpp&quot;
  38 #include &quot;runtime/safepointMechanism.hpp&quot;
  39 #include &quot;runtime/sharedRuntime.hpp&quot;
  40 #include &quot;runtime/stubRoutines.hpp&quot;
  41 #include &quot;runtime/synchronizer.hpp&quot;
  42 #include &quot;utilities/macros.hpp&quot;
  43 
  44 #define __ Disassembler::hook&lt;InterpreterMacroAssembler&gt;(__FILE__, __LINE__, _masm)-&gt;
  45 
  46 // Global Register Names
  47 static const Register rbcp     = LP64_ONLY(r13) NOT_LP64(rsi);
  48 static const Register rlocals  = LP64_ONLY(r14) NOT_LP64(rdi);
  49 
  50 // Platform-dependent initialization
  51 void TemplateTable::pd_initialize() {
  52   // No x86 specific initialization
  53 }
  54 
  55 // Address Computation: local variables
  56 static inline Address iaddress(int n) {
  57   return Address(rlocals, Interpreter::local_offset_in_bytes(n));
  58 }
  59 
  60 static inline Address laddress(int n) {
  61   return iaddress(n + 1);
  62 }
  63 
  64 #ifndef _LP64
  65 static inline Address haddress(int n) {
  66   return iaddress(n + 0);
  67 }
  68 #endif
  69 
  70 static inline Address faddress(int n) {
  71   return iaddress(n);
  72 }
  73 
  74 static inline Address daddress(int n) {
  75   return laddress(n);
  76 }
  77 
  78 static inline Address aaddress(int n) {
  79   return iaddress(n);
  80 }
  81 
  82 static inline Address iaddress(Register r) {
  83   return Address(rlocals, r, Address::times_ptr);
  84 }
  85 
  86 static inline Address laddress(Register r) {
  87   return Address(rlocals, r, Address::times_ptr, Interpreter::local_offset_in_bytes(1));
  88 }
  89 
  90 #ifndef _LP64
  91 static inline Address haddress(Register r)       {
  92   return Address(rlocals, r, Interpreter::stackElementScale(), Interpreter::local_offset_in_bytes(0));
  93 }
  94 #endif
  95 
  96 static inline Address faddress(Register r) {
  97   return iaddress(r);
  98 }
  99 
 100 static inline Address daddress(Register r) {
 101   return laddress(r);
 102 }
 103 
 104 static inline Address aaddress(Register r) {
 105   return iaddress(r);
 106 }
 107 
 108 
 109 // expression stack
 110 // (Note: Must not use symmetric equivalents at_rsp_m1/2 since they store
 111 // data beyond the rsp which is potentially unsafe in an MT environment;
 112 // an interrupt may overwrite that data.)
 113 static inline Address at_rsp   () {
 114   return Address(rsp, 0);
 115 }
 116 
 117 // At top of Java expression stack which may be different than esp().  It
 118 // isn&#39;t for category 1 objects.
 119 static inline Address at_tos   () {
 120   return Address(rsp,  Interpreter::expr_offset_in_bytes(0));
 121 }
 122 
 123 static inline Address at_tos_p1() {
 124   return Address(rsp,  Interpreter::expr_offset_in_bytes(1));
 125 }
 126 
 127 static inline Address at_tos_p2() {
 128   return Address(rsp,  Interpreter::expr_offset_in_bytes(2));
 129 }
 130 
 131 // Condition conversion
 132 static Assembler::Condition j_not(TemplateTable::Condition cc) {
 133   switch (cc) {
 134   case TemplateTable::equal        : return Assembler::notEqual;
 135   case TemplateTable::not_equal    : return Assembler::equal;
 136   case TemplateTable::less         : return Assembler::greaterEqual;
 137   case TemplateTable::less_equal   : return Assembler::greater;
 138   case TemplateTable::greater      : return Assembler::lessEqual;
 139   case TemplateTable::greater_equal: return Assembler::less;
 140   }
 141   ShouldNotReachHere();
 142   return Assembler::zero;
 143 }
 144 
 145 
 146 
 147 // Miscelaneous helper routines
 148 // Store an oop (or NULL) at the address described by obj.
 149 // If val == noreg this means store a NULL
 150 
 151 
 152 static void do_oop_store(InterpreterMacroAssembler* _masm,
 153                          Address dst,
 154                          Register val,
 155                          DecoratorSet decorators = 0) {
 156   assert(val == noreg || val == rax, &quot;parameter is just for looks&quot;);
 157   __ store_heap_oop(dst, val, rdx, rbx, decorators);
 158 }
 159 
 160 static void do_oop_load(InterpreterMacroAssembler* _masm,
 161                         Address src,
 162                         Register dst,
 163                         DecoratorSet decorators = 0) {
 164   __ load_heap_oop(dst, src, rdx, rbx, decorators);
 165 }
 166 
 167 Address TemplateTable::at_bcp(int offset) {
 168   assert(_desc-&gt;uses_bcp(), &quot;inconsistent uses_bcp information&quot;);
 169   return Address(rbcp, offset);
 170 }
 171 
 172 
 173 void TemplateTable::patch_bytecode(Bytecodes::Code bc, Register bc_reg,
 174                                    Register temp_reg, bool load_bc_into_bc_reg/*=true*/,
 175                                    int byte_no) {
 176   if (!RewriteBytecodes)  return;
 177   Label L_patch_done;
 178 
 179   switch (bc) {
 180   case Bytecodes::_fast_aputfield:
 181   case Bytecodes::_fast_bputfield:
 182   case Bytecodes::_fast_zputfield:
 183   case Bytecodes::_fast_cputfield:
 184   case Bytecodes::_fast_dputfield:
 185   case Bytecodes::_fast_fputfield:
 186   case Bytecodes::_fast_iputfield:
 187   case Bytecodes::_fast_lputfield:
 188   case Bytecodes::_fast_sputfield:
 189     {
 190       // We skip bytecode quickening for putfield instructions when
 191       // the put_code written to the constant pool cache is zero.
 192       // This is required so that every execution of this instruction
 193       // calls out to InterpreterRuntime::resolve_get_put to do
 194       // additional, required work.
 195       assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
 196       assert(load_bc_into_bc_reg, &quot;we use bc_reg as temp&quot;);
 197       __ get_cache_and_index_and_bytecode_at_bcp(temp_reg, bc_reg, temp_reg, byte_no, 1);
 198       __ movl(bc_reg, bc);
 199       __ cmpl(temp_reg, (int) 0);
 200       __ jcc(Assembler::zero, L_patch_done);  // don&#39;t patch
 201     }
 202     break;
 203   default:
 204     assert(byte_no == -1, &quot;sanity&quot;);
 205     // the pair bytecodes have already done the load.
 206     if (load_bc_into_bc_reg) {
 207       __ movl(bc_reg, bc);
 208     }
 209   }
 210 
 211   if (JvmtiExport::can_post_breakpoint()) {
 212     Label L_fast_patch;
 213     // if a breakpoint is present we can&#39;t rewrite the stream directly
 214     __ movzbl(temp_reg, at_bcp(0));
 215     __ cmpl(temp_reg, Bytecodes::_breakpoint);
 216     __ jcc(Assembler::notEqual, L_fast_patch);
 217     __ get_method(temp_reg);
 218     // Let breakpoint table handling rewrite to quicker bytecode
 219     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::set_original_bytecode_at), temp_reg, rbcp, bc_reg);
 220 #ifndef ASSERT
 221     __ jmpb(L_patch_done);
 222 #else
 223     __ jmp(L_patch_done);
 224 #endif
 225     __ bind(L_fast_patch);
 226   }
 227 
 228 #ifdef ASSERT
 229   Label L_okay;
 230   __ load_unsigned_byte(temp_reg, at_bcp(0));
 231   __ cmpl(temp_reg, (int) Bytecodes::java_code(bc));
 232   __ jcc(Assembler::equal, L_okay);
 233   __ cmpl(temp_reg, bc_reg);
 234   __ jcc(Assembler::equal, L_okay);
 235   __ stop(&quot;patching the wrong bytecode&quot;);
 236   __ bind(L_okay);
 237 #endif
 238 
 239   // patch bytecode
 240   __ movb(at_bcp(0), bc_reg);
 241   __ bind(L_patch_done);
 242 }
 243 // Individual instructions
 244 
 245 
 246 void TemplateTable::nop() {
 247   transition(vtos, vtos);
 248   // nothing to do
 249 }
 250 
 251 void TemplateTable::shouldnotreachhere() {
 252   transition(vtos, vtos);
 253   __ stop(&quot;shouldnotreachhere bytecode&quot;);
 254 }
 255 
 256 void TemplateTable::aconst_null() {
 257   transition(vtos, atos);
 258   __ xorl(rax, rax);
 259 }
 260 
 261 void TemplateTable::iconst(int value) {
 262   transition(vtos, itos);
 263   if (value == 0) {
 264     __ xorl(rax, rax);
 265   } else {
 266     __ movl(rax, value);
 267   }
 268 }
 269 
 270 void TemplateTable::lconst(int value) {
 271   transition(vtos, ltos);
 272   if (value == 0) {
 273     __ xorl(rax, rax);
 274   } else {
 275     __ movl(rax, value);
 276   }
 277 #ifndef _LP64
 278   assert(value &gt;= 0, &quot;check this code&quot;);
 279   __ xorptr(rdx, rdx);
 280 #endif
 281 }
 282 
 283 
 284 
 285 void TemplateTable::fconst(int value) {
 286   transition(vtos, ftos);
 287   if (UseSSE &gt;= 1) {
 288     static float one = 1.0f, two = 2.0f;
 289     switch (value) {
 290     case 0:
 291       __ xorps(xmm0, xmm0);
 292       break;
 293     case 1:
 294       __ movflt(xmm0, ExternalAddress((address) &amp;one));
 295       break;
 296     case 2:
 297       __ movflt(xmm0, ExternalAddress((address) &amp;two));
 298       break;
 299     default:
 300       ShouldNotReachHere();
 301       break;
 302     }
 303   } else {
 304 #ifdef _LP64
 305     ShouldNotReachHere();
 306 #else
 307            if (value == 0) { __ fldz();
 308     } else if (value == 1) { __ fld1();
 309     } else if (value == 2) { __ fld1(); __ fld1(); __ faddp(); // should do a better solution here
 310     } else                 { ShouldNotReachHere();
 311     }
 312 #endif // _LP64
 313   }
 314 }
 315 
 316 void TemplateTable::dconst(int value) {
 317   transition(vtos, dtos);
 318   if (UseSSE &gt;= 2) {
 319     static double one = 1.0;
 320     switch (value) {
 321     case 0:
 322       __ xorpd(xmm0, xmm0);
 323       break;
 324     case 1:
 325       __ movdbl(xmm0, ExternalAddress((address) &amp;one));
 326       break;
 327     default:
 328       ShouldNotReachHere();
 329       break;
 330     }
 331   } else {
 332 #ifdef _LP64
 333     ShouldNotReachHere();
 334 #else
 335            if (value == 0) { __ fldz();
 336     } else if (value == 1) { __ fld1();
 337     } else                 { ShouldNotReachHere();
 338     }
 339 #endif
 340   }
 341 }
 342 
 343 void TemplateTable::bipush() {
 344   transition(vtos, itos);
 345   __ load_signed_byte(rax, at_bcp(1));
 346 }
 347 
 348 void TemplateTable::sipush() {
 349   transition(vtos, itos);
 350   __ load_unsigned_short(rax, at_bcp(1));
 351   __ bswapl(rax);
 352   __ sarl(rax, 16);
 353 }
 354 
 355 void TemplateTable::ldc(bool wide) {
 356   transition(vtos, vtos);
 357   Register rarg = NOT_LP64(rcx) LP64_ONLY(c_rarg1);
 358   Label call_ldc, notFloat, notClass, notInt, Done;
 359 
 360   if (wide) {
 361     __ get_unsigned_2_byte_index_at_bcp(rbx, 1);
 362   } else {
 363     __ load_unsigned_byte(rbx, at_bcp(1));
 364   }
 365 
 366   __ get_cpool_and_tags(rcx, rax);
 367   const int base_offset = ConstantPool::header_size() * wordSize;
 368   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
 369 
 370   // get type
 371   __ movzbl(rdx, Address(rax, rbx, Address::times_1, tags_offset));
 372 
 373   // unresolved class - get the resolved class
 374   __ cmpl(rdx, JVM_CONSTANT_UnresolvedClass);
 375   __ jccb(Assembler::equal, call_ldc);
 376 
 377   // unresolved class in error state - call into runtime to throw the error
 378   // from the first resolution attempt
 379   __ cmpl(rdx, JVM_CONSTANT_UnresolvedClassInError);
 380   __ jccb(Assembler::equal, call_ldc);
 381 
 382   // resolved class - need to call vm to get java mirror of the class
 383   __ cmpl(rdx, JVM_CONSTANT_Class);
 384   __ jcc(Assembler::notEqual, notClass);
 385 
 386   __ bind(call_ldc);
 387 
 388   __ movl(rarg, wide);
 389   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::ldc), rarg);
 390 
 391   __ push(atos);
 392   __ jmp(Done);
 393 
 394   __ bind(notClass);
 395   __ cmpl(rdx, JVM_CONSTANT_Float);
 396   __ jccb(Assembler::notEqual, notFloat);
 397 
 398   // ftos
 399   __ load_float(Address(rcx, rbx, Address::times_ptr, base_offset));
 400   __ push(ftos);
 401   __ jmp(Done);
 402 
 403   __ bind(notFloat);
 404   __ cmpl(rdx, JVM_CONSTANT_Integer);
 405   __ jccb(Assembler::notEqual, notInt);
 406 
 407   // itos
 408   __ movl(rax, Address(rcx, rbx, Address::times_ptr, base_offset));
 409   __ push(itos);
 410   __ jmp(Done);
 411 
 412   // assume the tag is for condy; if not, the VM runtime will tell us
 413   __ bind(notInt);
 414   condy_helper(Done);
 415 
 416   __ bind(Done);
 417 }
 418 
 419 // Fast path for caching oop constants.
 420 void TemplateTable::fast_aldc(bool wide) {
 421   transition(vtos, atos);
 422 
 423   Register result = rax;
 424   Register tmp = rdx;
 425   Register rarg = NOT_LP64(rcx) LP64_ONLY(c_rarg1);
 426   int index_size = wide ? sizeof(u2) : sizeof(u1);
 427 
 428   Label resolved;
 429 
 430   // We are resolved if the resolved reference cache entry contains a
 431   // non-null object (String, MethodType, etc.)
 432   assert_different_registers(result, tmp);
 433   __ get_cache_index_at_bcp(tmp, 1, index_size);
 434   __ load_resolved_reference_at_index(result, tmp);
 435   __ testptr(result, result);
 436   __ jcc(Assembler::notZero, resolved);
 437 
 438   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_ldc);
 439 
 440   // first time invocation - must resolve first
 441   __ movl(rarg, (int)bytecode());
 442   __ call_VM(result, entry, rarg);
 443   __ bind(resolved);
 444 
 445   { // Check for the null sentinel.
 446     // If we just called the VM, it already did the mapping for us,
 447     // but it&#39;s harmless to retry.
 448     Label notNull;
 449     ExternalAddress null_sentinel((address)Universe::the_null_sentinel_addr());
 450     __ movptr(tmp, null_sentinel);
 451     __ cmpoop(tmp, result);
 452     __ jccb(Assembler::notEqual, notNull);
 453     __ xorptr(result, result);  // NULL object reference
 454     __ bind(notNull);
 455   }
 456 
 457   if (VerifyOops) {
 458     __ verify_oop(result);
 459   }
 460 }
 461 
 462 void TemplateTable::ldc2_w() {
 463   transition(vtos, vtos);
 464   Label notDouble, notLong, Done;
 465   __ get_unsigned_2_byte_index_at_bcp(rbx, 1);
 466 
 467   __ get_cpool_and_tags(rcx, rax);
 468   const int base_offset = ConstantPool::header_size() * wordSize;
 469   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
 470 
 471   // get type
 472   __ movzbl(rdx, Address(rax, rbx, Address::times_1, tags_offset));
 473   __ cmpl(rdx, JVM_CONSTANT_Double);
 474   __ jccb(Assembler::notEqual, notDouble);
 475 
 476   // dtos
 477   __ load_double(Address(rcx, rbx, Address::times_ptr, base_offset));
 478   __ push(dtos);
 479 
 480   __ jmp(Done);
 481   __ bind(notDouble);
 482   __ cmpl(rdx, JVM_CONSTANT_Long);
 483   __ jccb(Assembler::notEqual, notLong);
 484 
 485   // ltos
 486   __ movptr(rax, Address(rcx, rbx, Address::times_ptr, base_offset + 0 * wordSize));
 487   NOT_LP64(__ movptr(rdx, Address(rcx, rbx, Address::times_ptr, base_offset + 1 * wordSize)));
 488   __ push(ltos);
 489   __ jmp(Done);
 490 
 491   __ bind(notLong);
 492   condy_helper(Done);
 493 
 494   __ bind(Done);
 495 }
 496 
 497 void TemplateTable::condy_helper(Label&amp; Done) {
 498   const Register obj = rax;
 499   const Register off = rbx;
 500   const Register flags = rcx;
 501   const Register rarg = NOT_LP64(rcx) LP64_ONLY(c_rarg1);
 502   __ movl(rarg, (int)bytecode());
 503   call_VM(obj, CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_ldc), rarg);
 504 #ifndef _LP64
 505   // borrow rdi from locals
 506   __ get_thread(rdi);
 507   __ get_vm_result_2(flags, rdi);
 508   __ restore_locals();
 509 #else
 510   __ get_vm_result_2(flags, r15_thread);
 511 #endif
 512   // VMr = obj = base address to find primitive value to push
 513   // VMr2 = flags = (tos, off) using format of CPCE::_flags
 514   __ movl(off, flags);
 515   __ andl(off, ConstantPoolCacheEntry::field_index_mask);
 516   const Address field(obj, off, Address::times_1, 0*wordSize);
 517 
 518   // What sort of thing are we loading?
 519   __ shrl(flags, ConstantPoolCacheEntry::tos_state_shift);
 520   __ andl(flags, ConstantPoolCacheEntry::tos_state_mask);
 521 
 522   switch (bytecode()) {
 523   case Bytecodes::_ldc:
 524   case Bytecodes::_ldc_w:
 525     {
 526       // tos in (itos, ftos, stos, btos, ctos, ztos)
 527       Label notInt, notFloat, notShort, notByte, notChar, notBool;
 528       __ cmpl(flags, itos);
 529       __ jcc(Assembler::notEqual, notInt);
 530       // itos
 531       __ movl(rax, field);
 532       __ push(itos);
 533       __ jmp(Done);
 534 
 535       __ bind(notInt);
 536       __ cmpl(flags, ftos);
 537       __ jcc(Assembler::notEqual, notFloat);
 538       // ftos
 539       __ load_float(field);
 540       __ push(ftos);
 541       __ jmp(Done);
 542 
 543       __ bind(notFloat);
 544       __ cmpl(flags, stos);
 545       __ jcc(Assembler::notEqual, notShort);
 546       // stos
 547       __ load_signed_short(rax, field);
 548       __ push(stos);
 549       __ jmp(Done);
 550 
 551       __ bind(notShort);
 552       __ cmpl(flags, btos);
 553       __ jcc(Assembler::notEqual, notByte);
 554       // btos
 555       __ load_signed_byte(rax, field);
 556       __ push(btos);
 557       __ jmp(Done);
 558 
 559       __ bind(notByte);
 560       __ cmpl(flags, ctos);
 561       __ jcc(Assembler::notEqual, notChar);
 562       // ctos
 563       __ load_unsigned_short(rax, field);
 564       __ push(ctos);
 565       __ jmp(Done);
 566 
 567       __ bind(notChar);
 568       __ cmpl(flags, ztos);
 569       __ jcc(Assembler::notEqual, notBool);
 570       // ztos
 571       __ load_signed_byte(rax, field);
 572       __ push(ztos);
 573       __ jmp(Done);
 574 
 575       __ bind(notBool);
 576       break;
 577     }
 578 
 579   case Bytecodes::_ldc2_w:
 580     {
 581       Label notLong, notDouble;
 582       __ cmpl(flags, ltos);
 583       __ jcc(Assembler::notEqual, notLong);
 584       // ltos
 585       // Loading high word first because movptr clobbers rax
 586       NOT_LP64(__ movptr(rdx, field.plus_disp(4)));
 587       __ movptr(rax, field);
 588       __ push(ltos);
 589       __ jmp(Done);
 590 
 591       __ bind(notLong);
 592       __ cmpl(flags, dtos);
 593       __ jcc(Assembler::notEqual, notDouble);
 594       // dtos
 595       __ load_double(field);
 596       __ push(dtos);
 597       __ jmp(Done);
 598 
 599       __ bind(notDouble);
 600       break;
 601     }
 602 
 603   default:
 604     ShouldNotReachHere();
 605   }
 606 
 607   __ stop(&quot;bad ldc/condy&quot;);
 608 }
 609 
 610 void TemplateTable::locals_index(Register reg, int offset) {
 611   __ load_unsigned_byte(reg, at_bcp(offset));
 612   __ negptr(reg);
 613 }
 614 
 615 void TemplateTable::iload() {
 616   iload_internal();
 617 }
 618 
 619 void TemplateTable::nofast_iload() {
 620   iload_internal(may_not_rewrite);
 621 }
 622 
 623 void TemplateTable::iload_internal(RewriteControl rc) {
 624   transition(vtos, itos);
 625   if (RewriteFrequentPairs &amp;&amp; rc == may_rewrite) {
 626     Label rewrite, done;
 627     const Register bc = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
 628     LP64_ONLY(assert(rbx != bc, &quot;register damaged&quot;));
 629 
 630     // get next byte
 631     __ load_unsigned_byte(rbx,
 632                           at_bcp(Bytecodes::length_for(Bytecodes::_iload)));
 633     // if _iload, wait to rewrite to iload2.  We only want to rewrite the
 634     // last two iloads in a pair.  Comparing against fast_iload means that
 635     // the next bytecode is neither an iload or a caload, and therefore
 636     // an iload pair.
 637     __ cmpl(rbx, Bytecodes::_iload);
 638     __ jcc(Assembler::equal, done);
 639 
 640     __ cmpl(rbx, Bytecodes::_fast_iload);
 641     __ movl(bc, Bytecodes::_fast_iload2);
 642 
 643     __ jccb(Assembler::equal, rewrite);
 644 
 645     // if _caload, rewrite to fast_icaload
 646     __ cmpl(rbx, Bytecodes::_caload);
 647     __ movl(bc, Bytecodes::_fast_icaload);
 648     __ jccb(Assembler::equal, rewrite);
 649 
 650     // rewrite so iload doesn&#39;t check again.
 651     __ movl(bc, Bytecodes::_fast_iload);
 652 
 653     // rewrite
 654     // bc: fast bytecode
 655     __ bind(rewrite);
 656     patch_bytecode(Bytecodes::_iload, bc, rbx, false);
 657     __ bind(done);
 658   }
 659 
 660   // Get the local value into tos
 661   locals_index(rbx);
 662   __ movl(rax, iaddress(rbx));
 663 }
 664 
 665 void TemplateTable::fast_iload2() {
 666   transition(vtos, itos);
 667   locals_index(rbx);
 668   __ movl(rax, iaddress(rbx));
 669   __ push(itos);
 670   locals_index(rbx, 3);
 671   __ movl(rax, iaddress(rbx));
 672 }
 673 
 674 void TemplateTable::fast_iload() {
 675   transition(vtos, itos);
 676   locals_index(rbx);
 677   __ movl(rax, iaddress(rbx));
 678 }
 679 
 680 void TemplateTable::lload() {
 681   transition(vtos, ltos);
 682   locals_index(rbx);
 683   __ movptr(rax, laddress(rbx));
 684   NOT_LP64(__ movl(rdx, haddress(rbx)));
 685 }
 686 
 687 void TemplateTable::fload() {
 688   transition(vtos, ftos);
 689   locals_index(rbx);
 690   __ load_float(faddress(rbx));
 691 }
 692 
 693 void TemplateTable::dload() {
 694   transition(vtos, dtos);
 695   locals_index(rbx);
 696   __ load_double(daddress(rbx));
 697 }
 698 
 699 void TemplateTable::aload() {
 700   transition(vtos, atos);
 701   locals_index(rbx);
 702   __ movptr(rax, aaddress(rbx));
 703 }
 704 
 705 void TemplateTable::locals_index_wide(Register reg) {
 706   __ load_unsigned_short(reg, at_bcp(2));
 707   __ bswapl(reg);
 708   __ shrl(reg, 16);
 709   __ negptr(reg);
 710 }
 711 
 712 void TemplateTable::wide_iload() {
 713   transition(vtos, itos);
 714   locals_index_wide(rbx);
 715   __ movl(rax, iaddress(rbx));
 716 }
 717 
 718 void TemplateTable::wide_lload() {
 719   transition(vtos, ltos);
 720   locals_index_wide(rbx);
 721   __ movptr(rax, laddress(rbx));
 722   NOT_LP64(__ movl(rdx, haddress(rbx)));
 723 }
 724 
 725 void TemplateTable::wide_fload() {
 726   transition(vtos, ftos);
 727   locals_index_wide(rbx);
 728   __ load_float(faddress(rbx));
 729 }
 730 
 731 void TemplateTable::wide_dload() {
 732   transition(vtos, dtos);
 733   locals_index_wide(rbx);
 734   __ load_double(daddress(rbx));
 735 }
 736 
 737 void TemplateTable::wide_aload() {
 738   transition(vtos, atos);
 739   locals_index_wide(rbx);
 740   __ movptr(rax, aaddress(rbx));
 741 }
 742 
 743 void TemplateTable::index_check(Register array, Register index) {
 744   // Pop ptr into array
 745   __ pop_ptr(array);
 746   index_check_without_pop(array, index);
 747 }
 748 
 749 void TemplateTable::index_check_without_pop(Register array, Register index) {
 750   // destroys rbx
 751   // check array
 752   __ null_check(array, arrayOopDesc::length_offset_in_bytes());
 753   // sign extend index for use by indexed load
 754   __ movl2ptr(index, index);
 755   // check index
 756   __ cmpl(index, Address(array, arrayOopDesc::length_offset_in_bytes()));
 757   if (index != rbx) {
 758     // ??? convention: move aberrant index into rbx for exception message
 759     assert(rbx != array, &quot;different registers&quot;);
 760     __ movl(rbx, index);
 761   }
 762   Label skip;
 763   __ jccb(Assembler::below, skip);
 764   // Pass array to create more detailed exceptions.
 765   __ mov(NOT_LP64(rax) LP64_ONLY(c_rarg1), array);
 766   __ jump(ExternalAddress(Interpreter::_throw_ArrayIndexOutOfBoundsException_entry));
 767   __ bind(skip);
 768 }
 769 
 770 #if INCLUDE_TSAN
 771 
 772 void TemplateTable::tsan_observe_get_or_put(
 773     const Address &amp;field,
 774     Register flags,
 775     TsanMemoryReadWriteFunction tsan_function,
 776     TosState tos) {
 777   assert(flags == rdx, &quot;flags should be in rdx register&quot;);
 778   assert(ThreadSanitizer, &quot;ThreadSanitizer should be set&quot;);
 779 
 780   TsanMemoryReleaseAcquireFunction releaseAcquireFunction =
 781       tsan_release_acquire_method(tsan_function);
 782 
 783   Label done, notAcquireRelease;
 784 
 785   // We could save some instructions by only saving the registers we need.
 786   __ pusha();
 787   // pusha() doesn&#39;t save xmm0, which tsan_function clobbers and the
 788   // interpreter still needs.
 789   // This really only needs to be done for some of the float/double accesses,
 790   // but it&#39;s here because it&#39;s cleaner.
 791   __ push_d(xmm0);
 792   DEBUG_ONLY(
 793     __ pusha();
 794     __ movptr(c_rarg0, field.base());
 795     __ leaq(c_rarg1, field);
 796     __ subq(c_rarg1, field.base());
 797     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::verify_oop_index),
 798                     c_rarg0 /* oop */, c_rarg1 /* index */);
 799     __ popa();
 800   );
 801   // For volatile reads/writes use an acquire/release.
 802   // If a reference is annotated to be ignored, assume it&#39;s safe to
 803   // access the object it&#39;s referring to and create a happens-before relation
 804   // between the accesses to this reference.
 805   int32_t acquire_release_mask = 1 &lt;&lt; ConstantPoolCacheEntry::is_volatile_shift |
 806       ((tos == atos) ? 1 &lt;&lt; ConstantPoolCacheEntry::is_tsan_ignore_shift : 0);
 807   __ testl(flags, acquire_release_mask);
 808   __ jcc(Assembler::zero, notAcquireRelease);
 809 
 810   __ leaq(c_rarg0, field);
 811   __ call_VM_leaf(CAST_FROM_FN_PTR(address, releaseAcquireFunction), c_rarg0);
 812   if (ThreadSanitizerJavaMemory) {
 813     __ jmp(done);
 814 
 815     __ bind(notAcquireRelease);
 816     // Ignore reads/writes to final fields. They can&#39;t be racy.
 817     int32_t ignore_mask = 1 &lt;&lt; ConstantPoolCacheEntry::is_final_shift |
 818         1 &lt;&lt; ConstantPoolCacheEntry::is_tsan_ignore_shift;
 819     __ testl(flags, ignore_mask);
 820     __ jcc(Assembler::notZero, done);
 821 
 822     __ leaq(c_rarg0, field);
 823     __ get_method(c_rarg1);
 824     __ call_VM_leaf(CAST_FROM_FN_PTR(address, tsan_function),
 825                     c_rarg0 /* addr */, c_rarg1 /* method */, rbcp /* bcp */);
 826 
 827     __ bind(done);
 828   } else {
 829     __ bind(notAcquireRelease);
 830   }
 831   __ pop_d(xmm0);
 832   __ popa();
 833 }
 834 
 835 void TemplateTable::tsan_observe_load_or_store(
 836     const Address&amp; field, TsanMemoryReadWriteFunction tsan_function) {
 837   assert(ThreadSanitizer, &quot;ThreadSanitizer should be set&quot;);
 838   if (!ThreadSanitizerJavaMemory) {
 839     return;
 840   }
 841   // We could save some instructions by only saving the registers we need.
 842   __ pusha();
 843   // pusha() doesn&#39;t save xmm0, which tsan_function clobbers and the
 844   // interpreter still needs.
 845   // This really only needs to be done for some of the float/double accesses,
 846   // but it&#39;s here because it&#39;s cleaner.
 847   __ push_d(xmm0);
 848   DEBUG_ONLY(
 849     __ pusha();
 850     __ movptr(c_rarg0, field.base());
 851     __ leaq(c_rarg1, field);
 852     __ subq(c_rarg1, field.base());
 853     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::verify_oop_index),
 854                     c_rarg0 /* oop */, c_rarg1 /* index */);
 855     __ popa();
 856   );
 857   __ leaq(c_rarg0, field);
 858   __ get_method(c_rarg1);
 859   __ call_VM_leaf(CAST_FROM_FN_PTR(address, tsan_function),
 860                   c_rarg0 /* addr */, c_rarg1 /* method */, rbcp /* bcp */);
 861   __ pop_d(xmm0);
 862   __ popa();
 863 }
 864 
 865 #endif  // INCLUDE_TSAN
 866 
 867 void TemplateTable::iaload() {
 868   transition(itos, itos);
 869   // rax: index
 870   // rdx: array
 871   index_check(rdx, rax); // kills rbx
 872   Address addr(rdx, rax, Address::times_4,
 873                arrayOopDesc::base_offset_in_bytes(T_INT));
 874   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read4));
 875   __ access_load_at(T_INT, IN_HEAP | IS_ARRAY, rax, addr, noreg, noreg);
 876 }
 877 
 878 void TemplateTable::laload() {
 879   transition(itos, ltos);
 880   // rax: index
 881   // rdx: array
 882   index_check(rdx, rax); // kills rbx
 883   NOT_LP64(__ mov(rbx, rax));
 884   // rbx,: index
 885   Address addr(rdx, rbx, Address::times_8,
 886                arrayOopDesc::base_offset_in_bytes(T_LONG));
 887   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read8));
 888   __ access_load_at(T_LONG, IN_HEAP | IS_ARRAY, noreg /* ltos */, addr, noreg,
 889                     noreg);
 890 }
 891 
 892 
 893 
 894 void TemplateTable::faload() {
 895   transition(itos, ftos);
 896   // rax: index
 897   // rdx: array
 898   index_check(rdx, rax); // kills rbx
 899   Address addr(rdx, rax, Address::times_4,
 900                arrayOopDesc::base_offset_in_bytes(T_FLOAT));
 901   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read4));
 902   __ access_load_at(T_FLOAT, IN_HEAP | IS_ARRAY, noreg /* ftos */, addr, noreg,
 903                     noreg);
 904 }
 905 
 906 void TemplateTable::daload() {
 907   transition(itos, dtos);
 908   // rax: index
 909   // rdx: array
 910   index_check(rdx, rax); // kills rbx
 911   Address addr(rdx, rax, Address::times_8,
 912                arrayOopDesc::base_offset_in_bytes(T_DOUBLE));
 913   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read8));
 914   __ access_load_at(T_DOUBLE, IN_HEAP | IS_ARRAY, noreg /* dtos */, addr, noreg,
 915                     noreg);
 916 }
 917 
 918 void TemplateTable::aaload() {
 919   transition(itos, atos);
 920   // rax: index
 921   // rdx: array
 922   index_check(rdx, rax); // kills rbx
 923   Address addr(rdx, rax,
 924                UseCompressedOops ? Address::times_4 : Address::times_ptr,
 925                arrayOopDesc::base_offset_in_bytes(T_OBJECT));
 926   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(
 927       addr, UseCompressedOops ? SharedRuntime::tsan_read4
 928                               : SharedRuntime::tsan_read8));
 929   do_oop_load(_masm, addr, rax, IS_ARRAY);
 930 }
 931 
 932 void TemplateTable::baload() {
 933   transition(itos, itos);
 934   // rax: index
 935   // rdx: array
 936   index_check(rdx, rax); // kills rbx
 937   Address addr(rdx, rax, Address::times_1,
 938                arrayOopDesc::base_offset_in_bytes(T_BYTE));
 939   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read1));
 940   __ access_load_at(T_BYTE, IN_HEAP | IS_ARRAY, rax, addr, noreg, noreg);
 941 }
 942 
 943 void TemplateTable::caload() {
 944   transition(itos, itos);
 945   // rax: index
 946   // rdx: array
 947   index_check(rdx, rax); // kills rbx
 948   Address addr(rdx, rax, Address::times_2,
 949                arrayOopDesc::base_offset_in_bytes(T_CHAR));
 950   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read2));
 951   __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, rax, addr, noreg, noreg);
 952 }
 953 
 954 // iload followed by caload frequent pair
 955 void TemplateTable::fast_icaload() {
 956   transition(vtos, itos);
 957   // load index out of locals
 958   locals_index(rbx);
 959   __ movl(rax, iaddress(rbx));
 960 
 961   // rax: index
 962   // rdx: array
 963   index_check(rdx, rax); // kills rbx
 964   __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, rax,
 965                     Address(rdx, rax, Address::times_2, arrayOopDesc::base_offset_in_bytes(T_CHAR)),
 966                     noreg, noreg);
 967 }
 968 
 969 
 970 void TemplateTable::saload() {
 971   transition(itos, itos);
 972   // rax: index
 973   // rdx: array
 974   index_check(rdx, rax); // kills rbx
 975   Address addr(rdx, rax, Address::times_2,
 976                arrayOopDesc::base_offset_in_bytes(T_SHORT));
 977   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read2));
 978   __ access_load_at(T_SHORT, IN_HEAP | IS_ARRAY, rax, addr, noreg, noreg);
 979 }
 980 
 981 void TemplateTable::iload(int n) {
 982   transition(vtos, itos);
 983   __ movl(rax, iaddress(n));
 984 }
 985 
 986 void TemplateTable::lload(int n) {
 987   transition(vtos, ltos);
 988   __ movptr(rax, laddress(n));
 989   NOT_LP64(__ movptr(rdx, haddress(n)));
 990 }
 991 
 992 void TemplateTable::fload(int n) {
 993   transition(vtos, ftos);
 994   __ load_float(faddress(n));
 995 }
 996 
 997 void TemplateTable::dload(int n) {
 998   transition(vtos, dtos);
 999   __ load_double(daddress(n));
1000 }
1001 
1002 void TemplateTable::aload(int n) {
1003   transition(vtos, atos);
1004   __ movptr(rax, aaddress(n));
1005 }
1006 
1007 void TemplateTable::aload_0() {
1008   aload_0_internal();
1009 }
1010 
1011 void TemplateTable::nofast_aload_0() {
1012   aload_0_internal(may_not_rewrite);
1013 }
1014 
1015 void TemplateTable::aload_0_internal(RewriteControl rc) {
1016   transition(vtos, atos);
1017   // According to bytecode histograms, the pairs:
1018   //
1019   // _aload_0, _fast_igetfield
1020   // _aload_0, _fast_agetfield
1021   // _aload_0, _fast_fgetfield
1022   //
1023   // occur frequently. If RewriteFrequentPairs is set, the (slow)
1024   // _aload_0 bytecode checks if the next bytecode is either
1025   // _fast_igetfield, _fast_agetfield or _fast_fgetfield and then
1026   // rewrites the current bytecode into a pair bytecode; otherwise it
1027   // rewrites the current bytecode into _fast_aload_0 that doesn&#39;t do
1028   // the pair check anymore.
1029   //
1030   // Note: If the next bytecode is _getfield, the rewrite must be
1031   //       delayed, otherwise we may miss an opportunity for a pair.
1032   //
1033   // Also rewrite frequent pairs
1034   //   aload_0, aload_1
1035   //   aload_0, iload_1
1036   // These bytecodes with a small amount of code are most profitable
1037   // to rewrite
1038   if (RewriteFrequentPairs &amp;&amp; rc == may_rewrite) {
1039     Label rewrite, done;
1040 
1041     const Register bc = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
1042     LP64_ONLY(assert(rbx != bc, &quot;register damaged&quot;));
1043 
1044     // get next byte
1045     __ load_unsigned_byte(rbx, at_bcp(Bytecodes::length_for(Bytecodes::_aload_0)));
1046 
1047     // if _getfield then wait with rewrite
1048     __ cmpl(rbx, Bytecodes::_getfield);
1049     __ jcc(Assembler::equal, done);
1050 
1051     // if _igetfield then rewrite to _fast_iaccess_0
1052     assert(Bytecodes::java_code(Bytecodes::_fast_iaccess_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
1053     __ cmpl(rbx, Bytecodes::_fast_igetfield);
1054     __ movl(bc, Bytecodes::_fast_iaccess_0);
1055     __ jccb(Assembler::equal, rewrite);
1056 
1057     // if _agetfield then rewrite to _fast_aaccess_0
1058     assert(Bytecodes::java_code(Bytecodes::_fast_aaccess_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
1059     __ cmpl(rbx, Bytecodes::_fast_agetfield);
1060     __ movl(bc, Bytecodes::_fast_aaccess_0);
1061     __ jccb(Assembler::equal, rewrite);
1062 
1063     // if _fgetfield then rewrite to _fast_faccess_0
1064     assert(Bytecodes::java_code(Bytecodes::_fast_faccess_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
1065     __ cmpl(rbx, Bytecodes::_fast_fgetfield);
1066     __ movl(bc, Bytecodes::_fast_faccess_0);
1067     __ jccb(Assembler::equal, rewrite);
1068 
1069     // else rewrite to _fast_aload0
1070     assert(Bytecodes::java_code(Bytecodes::_fast_aload_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
1071     __ movl(bc, Bytecodes::_fast_aload_0);
1072 
1073     // rewrite
1074     // bc: fast bytecode
1075     __ bind(rewrite);
1076     patch_bytecode(Bytecodes::_aload_0, bc, rbx, false);
1077 
1078     __ bind(done);
1079   }
1080 
1081   // Do actual aload_0 (must do this after patch_bytecode which might call VM and GC might change oop).
1082   aload(0);
1083 }
1084 
1085 void TemplateTable::istore() {
1086   transition(itos, vtos);
1087   locals_index(rbx);
1088   __ movl(iaddress(rbx), rax);
1089 }
1090 
1091 
1092 void TemplateTable::lstore() {
1093   transition(ltos, vtos);
1094   locals_index(rbx);
1095   __ movptr(laddress(rbx), rax);
1096   NOT_LP64(__ movptr(haddress(rbx), rdx));
1097 }
1098 
1099 void TemplateTable::fstore() {
1100   transition(ftos, vtos);
1101   locals_index(rbx);
1102   __ store_float(faddress(rbx));
1103 }
1104 
1105 void TemplateTable::dstore() {
1106   transition(dtos, vtos);
1107   locals_index(rbx);
1108   __ store_double(daddress(rbx));
1109 }
1110 
1111 void TemplateTable::astore() {
1112   transition(vtos, vtos);
1113   __ pop_ptr(rax);
1114   locals_index(rbx);
1115   __ movptr(aaddress(rbx), rax);
1116 }
1117 
1118 void TemplateTable::wide_istore() {
1119   transition(vtos, vtos);
1120   __ pop_i();
1121   locals_index_wide(rbx);
1122   __ movl(iaddress(rbx), rax);
1123 }
1124 
1125 void TemplateTable::wide_lstore() {
1126   transition(vtos, vtos);
1127   NOT_LP64(__ pop_l(rax, rdx));
1128   LP64_ONLY(__ pop_l());
1129   locals_index_wide(rbx);
1130   __ movptr(laddress(rbx), rax);
1131   NOT_LP64(__ movl(haddress(rbx), rdx));
1132 }
1133 
1134 void TemplateTable::wide_fstore() {
1135 #ifdef _LP64
1136   transition(vtos, vtos);
1137   __ pop_f(xmm0);
1138   locals_index_wide(rbx);
1139   __ movflt(faddress(rbx), xmm0);
1140 #else
1141   wide_istore();
1142 #endif
1143 }
1144 
1145 void TemplateTable::wide_dstore() {
1146 #ifdef _LP64
1147   transition(vtos, vtos);
1148   __ pop_d(xmm0);
1149   locals_index_wide(rbx);
1150   __ movdbl(daddress(rbx), xmm0);
1151 #else
1152   wide_lstore();
1153 #endif
1154 }
1155 
1156 void TemplateTable::wide_astore() {
1157   transition(vtos, vtos);
1158   __ pop_ptr(rax);
1159   locals_index_wide(rbx);
1160   __ movptr(aaddress(rbx), rax);
1161 }
1162 
1163 void TemplateTable::iastore() {
1164   transition(itos, vtos);
1165   __ pop_i(rbx);
1166   // rax: value
1167   // rbx: index
1168   // rdx: array
1169   index_check(rdx, rbx); // prefer index in rbx
1170   Address addr(rdx, rbx, Address::times_4,
1171                arrayOopDesc::base_offset_in_bytes(T_INT));
1172   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write4));
1173   __ access_store_at(T_INT, IN_HEAP | IS_ARRAY, addr, rax, noreg, noreg);
1174 }
1175 
1176 void TemplateTable::lastore() {
1177   transition(ltos, vtos);
1178   __ pop_i(rbx);
1179   // rax,: low(value)
1180   // rcx: array
1181   // rdx: high(value)
1182   index_check(rcx, rbx);  // prefer index in rbx,
1183   // rbx,: index
1184   Address addr(rcx, rbx, Address::times_8,
1185                arrayOopDesc::base_offset_in_bytes(T_LONG));
1186   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write8));
1187   __ access_store_at(T_LONG, IN_HEAP | IS_ARRAY, addr, noreg /* ltos */, noreg,
1188                      noreg);
1189 }
1190 
1191 
1192 void TemplateTable::fastore() {
1193   transition(ftos, vtos);
1194   __ pop_i(rbx);
1195   // value is in UseSSE &gt;= 1 ? xmm0 : ST(0)
1196   // rbx:  index
1197   // rdx:  array
1198   index_check(rdx, rbx); // prefer index in rbx
1199   Address addr(rdx, rbx, Address::times_4,
1200                arrayOopDesc::base_offset_in_bytes(T_FLOAT));
1201   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write4));
1202   __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY, addr, noreg /* ftos */, noreg,
1203                      noreg);
1204 }
1205 
1206 void TemplateTable::dastore() {
1207   transition(dtos, vtos);
1208   __ pop_i(rbx);
1209   // value is in UseSSE &gt;= 2 ? xmm0 : ST(0)
1210   // rbx:  index
1211   // rdx:  array
1212   index_check(rdx, rbx); // prefer index in rbx
1213   Address addr(rdx, rbx, Address::times_8,
1214                arrayOopDesc::base_offset_in_bytes(T_DOUBLE));
1215   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write8));
1216   __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY, addr, noreg /* dtos */,
1217                      noreg, noreg);
1218 }
1219 
1220 void TemplateTable::aastore() {
1221   Label is_null, ok_is_subtype, done;
1222   transition(vtos, vtos);
1223   // stack: ..., array, index, value
1224   __ movptr(rax, at_tos());    // value
1225   __ movl(rcx, at_tos_p1()); // index
1226   __ movptr(rdx, at_tos_p2()); // array
1227 
1228   Address element_address(rdx, rcx,
1229                           UseCompressedOops? Address::times_4 : Address::times_ptr,
1230                           arrayOopDesc::base_offset_in_bytes(T_OBJECT));
1231 
1232   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(
1233       element_address, UseCompressedOops ? SharedRuntime::tsan_write4
1234                                          : SharedRuntime::tsan_write8));
1235 
1236   index_check_without_pop(rdx, rcx);     // kills rbx
1237   __ testptr(rax, rax);
1238   __ jcc(Assembler::zero, is_null);
1239 
1240   // Move subklass into rbx
1241   __ load_klass(rbx, rax);
1242   // Move superklass into rax
1243   __ load_klass(rax, rdx);
1244   __ movptr(rax, Address(rax,
1245                          ObjArrayKlass::element_klass_offset()));
1246 
1247   // Generate subtype check.  Blows rcx, rdi
1248   // Superklass in rax.  Subklass in rbx.
1249   __ gen_subtype_check(rbx, ok_is_subtype);
1250 
1251   // Come here on failure
1252   // object is at TOS
1253   __ jump(ExternalAddress(Interpreter::_throw_ArrayStoreException_entry));
1254 
1255   // Come here on success
1256   __ bind(ok_is_subtype);
1257 
1258   // Get the value we will store
1259   __ movptr(rax, at_tos());
1260   __ movl(rcx, at_tos_p1()); // index
1261   // Now store using the appropriate barrier
1262   do_oop_store(_masm, element_address, rax, IS_ARRAY);
1263   __ jmp(done);
1264 
1265   // Have a NULL in rax, rdx=array, ecx=index.  Store NULL at ary[idx]
1266   __ bind(is_null);
1267   __ profile_null_seen(rbx);
1268 
1269   // Store a NULL
1270   do_oop_store(_masm, element_address, noreg, IS_ARRAY);
1271 
1272   // Pop stack arguments
1273   __ bind(done);
1274   __ addptr(rsp, 3 * Interpreter::stackElementSize);
1275 }
1276 
1277 void TemplateTable::bastore() {
1278   transition(itos, vtos);
1279   __ pop_i(rbx);
1280   // rax: value
1281   // rbx: index
1282   // rdx: array
1283   index_check(rdx, rbx); // prefer index in rbx
1284   // Need to check whether array is boolean or byte
1285   // since both types share the bastore bytecode.
1286   __ load_klass(rcx, rdx);
1287   __ movl(rcx, Address(rcx, Klass::layout_helper_offset()));
1288   int diffbit = Klass::layout_helper_boolean_diffbit();
1289   __ testl(rcx, diffbit);
1290   Label L_skip;
1291   __ jccb(Assembler::zero, L_skip);
1292   __ andl(rax, 1);  // if it is a T_BOOLEAN array, mask the stored value to 0/1
1293   __ bind(L_skip);
1294   Address addr(rdx, rbx, Address::times_1,
1295                arrayOopDesc::base_offset_in_bytes(T_BYTE));
1296   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write1));
1297   __ access_store_at(T_BYTE, IN_HEAP | IS_ARRAY, addr, rax, noreg, noreg);
1298 }
1299 
1300 void TemplateTable::castore() {
1301   transition(itos, vtos);
1302   __ pop_i(rbx);
1303   // rax: value
1304   // rbx: index
1305   // rdx: array
1306   index_check(rdx, rbx);  // prefer index in rbx
1307   Address addr(rdx, rbx, Address::times_2,
1308                arrayOopDesc::base_offset_in_bytes(T_CHAR));
1309   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write2));
1310   __ access_store_at(T_CHAR, IN_HEAP | IS_ARRAY, addr, rax, noreg, noreg);
1311 }
1312 
1313 
1314 void TemplateTable::sastore() {
1315   castore();
1316 }
1317 
1318 void TemplateTable::istore(int n) {
1319   transition(itos, vtos);
1320   __ movl(iaddress(n), rax);
1321 }
1322 
1323 void TemplateTable::lstore(int n) {
1324   transition(ltos, vtos);
1325   __ movptr(laddress(n), rax);
1326   NOT_LP64(__ movptr(haddress(n), rdx));
1327 }
1328 
1329 void TemplateTable::fstore(int n) {
1330   transition(ftos, vtos);
1331   __ store_float(faddress(n));
1332 }
1333 
1334 void TemplateTable::dstore(int n) {
1335   transition(dtos, vtos);
1336   __ store_double(daddress(n));
1337 }
1338 
1339 
1340 void TemplateTable::astore(int n) {
1341   transition(vtos, vtos);
1342   __ pop_ptr(rax);
1343   __ movptr(aaddress(n), rax);
1344 }
1345 
1346 void TemplateTable::pop() {
1347   transition(vtos, vtos);
1348   __ addptr(rsp, Interpreter::stackElementSize);
1349 }
1350 
1351 void TemplateTable::pop2() {
1352   transition(vtos, vtos);
1353   __ addptr(rsp, 2 * Interpreter::stackElementSize);
1354 }
1355 
1356 
1357 void TemplateTable::dup() {
1358   transition(vtos, vtos);
1359   __ load_ptr(0, rax);
1360   __ push_ptr(rax);
1361   // stack: ..., a, a
1362 }
1363 
1364 void TemplateTable::dup_x1() {
1365   transition(vtos, vtos);
1366   // stack: ..., a, b
1367   __ load_ptr( 0, rax);  // load b
1368   __ load_ptr( 1, rcx);  // load a
1369   __ store_ptr(1, rax);  // store b
1370   __ store_ptr(0, rcx);  // store a
1371   __ push_ptr(rax);      // push b
1372   // stack: ..., b, a, b
1373 }
1374 
1375 void TemplateTable::dup_x2() {
1376   transition(vtos, vtos);
1377   // stack: ..., a, b, c
1378   __ load_ptr( 0, rax);  // load c
1379   __ load_ptr( 2, rcx);  // load a
1380   __ store_ptr(2, rax);  // store c in a
1381   __ push_ptr(rax);      // push c
1382   // stack: ..., c, b, c, c
1383   __ load_ptr( 2, rax);  // load b
1384   __ store_ptr(2, rcx);  // store a in b
1385   // stack: ..., c, a, c, c
1386   __ store_ptr(1, rax);  // store b in c
1387   // stack: ..., c, a, b, c
1388 }
1389 
1390 void TemplateTable::dup2() {
1391   transition(vtos, vtos);
1392   // stack: ..., a, b
1393   __ load_ptr(1, rax);  // load a
1394   __ push_ptr(rax);     // push a
1395   __ load_ptr(1, rax);  // load b
1396   __ push_ptr(rax);     // push b
1397   // stack: ..., a, b, a, b
1398 }
1399 
1400 
1401 void TemplateTable::dup2_x1() {
1402   transition(vtos, vtos);
1403   // stack: ..., a, b, c
1404   __ load_ptr( 0, rcx);  // load c
1405   __ load_ptr( 1, rax);  // load b
1406   __ push_ptr(rax);      // push b
1407   __ push_ptr(rcx);      // push c
1408   // stack: ..., a, b, c, b, c
1409   __ store_ptr(3, rcx);  // store c in b
1410   // stack: ..., a, c, c, b, c
1411   __ load_ptr( 4, rcx);  // load a
1412   __ store_ptr(2, rcx);  // store a in 2nd c
1413   // stack: ..., a, c, a, b, c
1414   __ store_ptr(4, rax);  // store b in a
1415   // stack: ..., b, c, a, b, c
1416 }
1417 
1418 void TemplateTable::dup2_x2() {
1419   transition(vtos, vtos);
1420   // stack: ..., a, b, c, d
1421   __ load_ptr( 0, rcx);  // load d
1422   __ load_ptr( 1, rax);  // load c
1423   __ push_ptr(rax);      // push c
1424   __ push_ptr(rcx);      // push d
1425   // stack: ..., a, b, c, d, c, d
1426   __ load_ptr( 4, rax);  // load b
1427   __ store_ptr(2, rax);  // store b in d
1428   __ store_ptr(4, rcx);  // store d in b
1429   // stack: ..., a, d, c, b, c, d
1430   __ load_ptr( 5, rcx);  // load a
1431   __ load_ptr( 3, rax);  // load c
1432   __ store_ptr(3, rcx);  // store a in c
1433   __ store_ptr(5, rax);  // store c in a
1434   // stack: ..., c, d, a, b, c, d
1435 }
1436 
1437 void TemplateTable::swap() {
1438   transition(vtos, vtos);
1439   // stack: ..., a, b
1440   __ load_ptr( 1, rcx);  // load a
1441   __ load_ptr( 0, rax);  // load b
1442   __ store_ptr(0, rcx);  // store a in b
1443   __ store_ptr(1, rax);  // store b in a
1444   // stack: ..., b, a
1445 }
1446 
1447 void TemplateTable::iop2(Operation op) {
1448   transition(itos, itos);
1449   switch (op) {
1450   case add  :                    __ pop_i(rdx); __ addl (rax, rdx); break;
1451   case sub  : __ movl(rdx, rax); __ pop_i(rax); __ subl (rax, rdx); break;
1452   case mul  :                    __ pop_i(rdx); __ imull(rax, rdx); break;
1453   case _and :                    __ pop_i(rdx); __ andl (rax, rdx); break;
1454   case _or  :                    __ pop_i(rdx); __ orl  (rax, rdx); break;
1455   case _xor :                    __ pop_i(rdx); __ xorl (rax, rdx); break;
1456   case shl  : __ movl(rcx, rax); __ pop_i(rax); __ shll (rax);      break;
1457   case shr  : __ movl(rcx, rax); __ pop_i(rax); __ sarl (rax);      break;
1458   case ushr : __ movl(rcx, rax); __ pop_i(rax); __ shrl (rax);      break;
1459   default   : ShouldNotReachHere();
1460   }
1461 }
1462 
1463 void TemplateTable::lop2(Operation op) {
1464   transition(ltos, ltos);
1465 #ifdef _LP64
1466   switch (op) {
1467   case add  :                    __ pop_l(rdx); __ addptr(rax, rdx); break;
1468   case sub  : __ mov(rdx, rax);  __ pop_l(rax); __ subptr(rax, rdx); break;
1469   case _and :                    __ pop_l(rdx); __ andptr(rax, rdx); break;
1470   case _or  :                    __ pop_l(rdx); __ orptr (rax, rdx); break;
1471   case _xor :                    __ pop_l(rdx); __ xorptr(rax, rdx); break;
1472   default   : ShouldNotReachHere();
1473   }
1474 #else
1475   __ pop_l(rbx, rcx);
1476   switch (op) {
1477     case add  : __ addl(rax, rbx); __ adcl(rdx, rcx); break;
1478     case sub  : __ subl(rbx, rax); __ sbbl(rcx, rdx);
1479                 __ mov (rax, rbx); __ mov (rdx, rcx); break;
1480     case _and : __ andl(rax, rbx); __ andl(rdx, rcx); break;
1481     case _or  : __ orl (rax, rbx); __ orl (rdx, rcx); break;
1482     case _xor : __ xorl(rax, rbx); __ xorl(rdx, rcx); break;
1483     default   : ShouldNotReachHere();
1484   }
1485 #endif
1486 }
1487 
1488 void TemplateTable::idiv() {
1489   transition(itos, itos);
1490   __ movl(rcx, rax);
1491   __ pop_i(rax);
1492   // Note: could xor rax and ecx and compare with (-1 ^ min_int). If
1493   //       they are not equal, one could do a normal division (no correction
1494   //       needed), which may speed up this implementation for the common case.
1495   //       (see also JVM spec., p.243 &amp; p.271)
1496   __ corrected_idivl(rcx);
1497 }
1498 
1499 void TemplateTable::irem() {
1500   transition(itos, itos);
1501   __ movl(rcx, rax);
1502   __ pop_i(rax);
1503   // Note: could xor rax and ecx and compare with (-1 ^ min_int). If
1504   //       they are not equal, one could do a normal division (no correction
1505   //       needed), which may speed up this implementation for the common case.
1506   //       (see also JVM spec., p.243 &amp; p.271)
1507   __ corrected_idivl(rcx);
1508   __ movl(rax, rdx);
1509 }
1510 
1511 void TemplateTable::lmul() {
1512   transition(ltos, ltos);
1513 #ifdef _LP64
1514   __ pop_l(rdx);
1515   __ imulq(rax, rdx);
1516 #else
1517   __ pop_l(rbx, rcx);
1518   __ push(rcx); __ push(rbx);
1519   __ push(rdx); __ push(rax);
1520   __ lmul(2 * wordSize, 0);
1521   __ addptr(rsp, 4 * wordSize);  // take off temporaries
1522 #endif
1523 }
1524 
1525 void TemplateTable::ldiv() {
1526   transition(ltos, ltos);
1527 #ifdef _LP64
1528   __ mov(rcx, rax);
1529   __ pop_l(rax);
1530   // generate explicit div0 check
1531   __ testq(rcx, rcx);
1532   __ jump_cc(Assembler::zero,
1533              ExternalAddress(Interpreter::_throw_ArithmeticException_entry));
1534   // Note: could xor rax and rcx and compare with (-1 ^ min_int). If
1535   //       they are not equal, one could do a normal division (no correction
1536   //       needed), which may speed up this implementation for the common case.
1537   //       (see also JVM spec., p.243 &amp; p.271)
1538   __ corrected_idivq(rcx); // kills rbx
1539 #else
1540   __ pop_l(rbx, rcx);
1541   __ push(rcx); __ push(rbx);
1542   __ push(rdx); __ push(rax);
1543   // check if y = 0
1544   __ orl(rax, rdx);
1545   __ jump_cc(Assembler::zero,
1546              ExternalAddress(Interpreter::_throw_ArithmeticException_entry));
1547   __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::ldiv));
1548   __ addptr(rsp, 4 * wordSize);  // take off temporaries
1549 #endif
1550 }
1551 
1552 void TemplateTable::lrem() {
1553   transition(ltos, ltos);
1554 #ifdef _LP64
1555   __ mov(rcx, rax);
1556   __ pop_l(rax);
1557   __ testq(rcx, rcx);
1558   __ jump_cc(Assembler::zero,
1559              ExternalAddress(Interpreter::_throw_ArithmeticException_entry));
1560   // Note: could xor rax and rcx and compare with (-1 ^ min_int). If
1561   //       they are not equal, one could do a normal division (no correction
1562   //       needed), which may speed up this implementation for the common case.
1563   //       (see also JVM spec., p.243 &amp; p.271)
1564   __ corrected_idivq(rcx); // kills rbx
1565   __ mov(rax, rdx);
1566 #else
1567   __ pop_l(rbx, rcx);
1568   __ push(rcx); __ push(rbx);
1569   __ push(rdx); __ push(rax);
1570   // check if y = 0
1571   __ orl(rax, rdx);
1572   __ jump_cc(Assembler::zero,
1573              ExternalAddress(Interpreter::_throw_ArithmeticException_entry));
1574   __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::lrem));
1575   __ addptr(rsp, 4 * wordSize);
1576 #endif
1577 }
1578 
1579 void TemplateTable::lshl() {
1580   transition(itos, ltos);
1581   __ movl(rcx, rax);                             // get shift count
1582   #ifdef _LP64
1583   __ pop_l(rax);                                 // get shift value
1584   __ shlq(rax);
1585 #else
1586   __ pop_l(rax, rdx);                            // get shift value
1587   __ lshl(rdx, rax);
1588 #endif
1589 }
1590 
1591 void TemplateTable::lshr() {
1592 #ifdef _LP64
1593   transition(itos, ltos);
1594   __ movl(rcx, rax);                             // get shift count
1595   __ pop_l(rax);                                 // get shift value
1596   __ sarq(rax);
1597 #else
1598   transition(itos, ltos);
1599   __ mov(rcx, rax);                              // get shift count
1600   __ pop_l(rax, rdx);                            // get shift value
1601   __ lshr(rdx, rax, true);
1602 #endif
1603 }
1604 
1605 void TemplateTable::lushr() {
1606   transition(itos, ltos);
1607 #ifdef _LP64
1608   __ movl(rcx, rax);                             // get shift count
1609   __ pop_l(rax);                                 // get shift value
1610   __ shrq(rax);
1611 #else
1612   __ mov(rcx, rax);                              // get shift count
1613   __ pop_l(rax, rdx);                            // get shift value
1614   __ lshr(rdx, rax);
1615 #endif
1616 }
1617 
1618 void TemplateTable::fop2(Operation op) {
1619   transition(ftos, ftos);
1620 
1621   if (UseSSE &gt;= 1) {
1622     switch (op) {
1623     case add:
1624       __ addss(xmm0, at_rsp());
1625       __ addptr(rsp, Interpreter::stackElementSize);
1626       break;
1627     case sub:
1628       __ movflt(xmm1, xmm0);
1629       __ pop_f(xmm0);
1630       __ subss(xmm0, xmm1);
1631       break;
1632     case mul:
1633       __ mulss(xmm0, at_rsp());
1634       __ addptr(rsp, Interpreter::stackElementSize);
1635       break;
1636     case div:
1637       __ movflt(xmm1, xmm0);
1638       __ pop_f(xmm0);
1639       __ divss(xmm0, xmm1);
1640       break;
1641     case rem:
1642       // On x86_64 platforms the SharedRuntime::frem method is called to perform the
1643       // modulo operation. The frem method calls the function
1644       // double fmod(double x, double y) in math.h. The documentation of fmod states:
1645       // &quot;If x or y is a NaN, a NaN is returned.&quot; without specifying what type of NaN
1646       // (signalling or quiet) is returned.
1647       //
1648       // On x86_32 platforms the FPU is used to perform the modulo operation. The
1649       // reason is that on 32-bit Windows the sign of modulo operations diverges from
1650       // what is considered the standard (e.g., -0.0f % -3.14f is 0.0f (and not -0.0f).
1651       // The fprem instruction used on x86_32 is functionally equivalent to
1652       // SharedRuntime::frem in that it returns a NaN.
1653 #ifdef _LP64
1654       __ movflt(xmm1, xmm0);
1655       __ pop_f(xmm0);
1656       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::frem), 2);
1657 #else
1658       __ push_f(xmm0);
1659       __ pop_f();
1660       __ fld_s(at_rsp());
1661       __ fremr(rax);
1662       __ f2ieee();
1663       __ pop(rax);  // pop second operand off the stack
1664       __ push_f();
1665       __ pop_f(xmm0);
1666 #endif
1667       break;
1668     default:
1669       ShouldNotReachHere();
1670       break;
1671     }
1672   } else {
1673 #ifdef _LP64
1674     ShouldNotReachHere();
1675 #else
1676     switch (op) {
1677     case add: __ fadd_s (at_rsp());                break;
1678     case sub: __ fsubr_s(at_rsp());                break;
1679     case mul: __ fmul_s (at_rsp());                break;
1680     case div: __ fdivr_s(at_rsp());                break;
1681     case rem: __ fld_s  (at_rsp()); __ fremr(rax); break;
1682     default : ShouldNotReachHere();
1683     }
1684     __ f2ieee();
1685     __ pop(rax);  // pop second operand off the stack
1686 #endif // _LP64
1687   }
1688 }
1689 
1690 void TemplateTable::dop2(Operation op) {
1691   transition(dtos, dtos);
1692   if (UseSSE &gt;= 2) {
1693     switch (op) {
1694     case add:
1695       __ addsd(xmm0, at_rsp());
1696       __ addptr(rsp, 2 * Interpreter::stackElementSize);
1697       break;
1698     case sub:
1699       __ movdbl(xmm1, xmm0);
1700       __ pop_d(xmm0);
1701       __ subsd(xmm0, xmm1);
1702       break;
1703     case mul:
1704       __ mulsd(xmm0, at_rsp());
1705       __ addptr(rsp, 2 * Interpreter::stackElementSize);
1706       break;
1707     case div:
1708       __ movdbl(xmm1, xmm0);
1709       __ pop_d(xmm0);
1710       __ divsd(xmm0, xmm1);
1711       break;
1712     case rem:
1713       // Similar to fop2(), the modulo operation is performed using the
1714       // SharedRuntime::drem method (on x86_64 platforms) or using the
1715       // FPU (on x86_32 platforms) for the same reasons as mentioned in fop2().
1716 #ifdef _LP64
1717       __ movdbl(xmm1, xmm0);
1718       __ pop_d(xmm0);
1719       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::drem), 2);
1720 #else
1721       __ push_d(xmm0);
1722       __ pop_d();
1723       __ fld_d(at_rsp());
1724       __ fremr(rax);
1725       __ d2ieee();
1726       __ pop(rax);
1727       __ pop(rdx);
1728       __ push_d();
1729       __ pop_d(xmm0);
1730 #endif
1731       break;
1732     default:
1733       ShouldNotReachHere();
1734       break;
1735     }
1736   } else {
1737 #ifdef _LP64
1738     ShouldNotReachHere();
1739 #else
1740     switch (op) {
1741     case add: __ fadd_d (at_rsp());                break;
1742     case sub: __ fsubr_d(at_rsp());                break;
1743     case mul: {
1744       Label L_strict;
1745       Label L_join;
1746       const Address access_flags      (rcx, Method::access_flags_offset());
1747       __ get_method(rcx);
1748       __ movl(rcx, access_flags);
1749       __ testl(rcx, JVM_ACC_STRICT);
1750       __ jccb(Assembler::notZero, L_strict);
1751       __ fmul_d (at_rsp());
1752       __ jmpb(L_join);
1753       __ bind(L_strict);
1754       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias1()));
1755       __ fmulp();
1756       __ fmul_d (at_rsp());
1757       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias2()));
1758       __ fmulp();
1759       __ bind(L_join);
1760       break;
1761     }
1762     case div: {
1763       Label L_strict;
1764       Label L_join;
1765       const Address access_flags      (rcx, Method::access_flags_offset());
1766       __ get_method(rcx);
1767       __ movl(rcx, access_flags);
1768       __ testl(rcx, JVM_ACC_STRICT);
1769       __ jccb(Assembler::notZero, L_strict);
1770       __ fdivr_d(at_rsp());
1771       __ jmp(L_join);
1772       __ bind(L_strict);
1773       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias1()));
1774       __ fmul_d (at_rsp());
1775       __ fdivrp();
1776       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias2()));
1777       __ fmulp();
1778       __ bind(L_join);
1779       break;
1780     }
1781     case rem: __ fld_d  (at_rsp()); __ fremr(rax); break;
1782     default : ShouldNotReachHere();
1783     }
1784     __ d2ieee();
1785     // Pop double precision number from rsp.
1786     __ pop(rax);
1787     __ pop(rdx);
1788 #endif
1789   }
1790 }
1791 
1792 void TemplateTable::ineg() {
1793   transition(itos, itos);
1794   __ negl(rax);
1795 }
1796 
1797 void TemplateTable::lneg() {
1798   transition(ltos, ltos);
1799   LP64_ONLY(__ negq(rax));
1800   NOT_LP64(__ lneg(rdx, rax));
1801 }
1802 
1803 // Note: &#39;double&#39; and &#39;long long&#39; have 32-bits alignment on x86.
1804 static jlong* double_quadword(jlong *adr, jlong lo, jlong hi) {
1805   // Use the expression (adr)&amp;(~0xF) to provide 128-bits aligned address
1806   // of 128-bits operands for SSE instructions.
1807   jlong *operand = (jlong*)(((intptr_t)adr)&amp;((intptr_t)(~0xF)));
1808   // Store the value to a 128-bits operand.
1809   operand[0] = lo;
1810   operand[1] = hi;
1811   return operand;
1812 }
1813 
1814 // Buffer for 128-bits masks used by SSE instructions.
1815 static jlong float_signflip_pool[2*2];
1816 static jlong double_signflip_pool[2*2];
1817 
1818 void TemplateTable::fneg() {
1819   transition(ftos, ftos);
1820   if (UseSSE &gt;= 1) {
1821     static jlong *float_signflip  = double_quadword(&amp;float_signflip_pool[1],  CONST64(0x8000000080000000),  CONST64(0x8000000080000000));
1822     __ xorps(xmm0, ExternalAddress((address) float_signflip));
1823   } else {
1824     LP64_ONLY(ShouldNotReachHere());
1825     NOT_LP64(__ fchs());
1826   }
1827 }
1828 
1829 void TemplateTable::dneg() {
1830   transition(dtos, dtos);
1831   if (UseSSE &gt;= 2) {
1832     static jlong *double_signflip =
1833       double_quadword(&amp;double_signflip_pool[1], CONST64(0x8000000000000000), CONST64(0x8000000000000000));
1834     __ xorpd(xmm0, ExternalAddress((address) double_signflip));
1835   } else {
1836 #ifdef _LP64
1837     ShouldNotReachHere();
1838 #else
1839     __ fchs();
1840 #endif
1841   }
1842 }
1843 
1844 void TemplateTable::iinc() {
1845   transition(vtos, vtos);
1846   __ load_signed_byte(rdx, at_bcp(2)); // get constant
1847   locals_index(rbx);
1848   __ addl(iaddress(rbx), rdx);
1849 }
1850 
1851 void TemplateTable::wide_iinc() {
1852   transition(vtos, vtos);
1853   __ movl(rdx, at_bcp(4)); // get constant
1854   locals_index_wide(rbx);
1855   __ bswapl(rdx); // swap bytes &amp; sign-extend constant
1856   __ sarl(rdx, 16);
1857   __ addl(iaddress(rbx), rdx);
1858   // Note: should probably use only one movl to get both
1859   //       the index and the constant -&gt; fix this
1860 }
1861 
1862 void TemplateTable::convert() {
1863 #ifdef _LP64
1864   // Checking
1865 #ifdef ASSERT
1866   {
1867     TosState tos_in  = ilgl;
1868     TosState tos_out = ilgl;
1869     switch (bytecode()) {
1870     case Bytecodes::_i2l: // fall through
1871     case Bytecodes::_i2f: // fall through
1872     case Bytecodes::_i2d: // fall through
1873     case Bytecodes::_i2b: // fall through
1874     case Bytecodes::_i2c: // fall through
1875     case Bytecodes::_i2s: tos_in = itos; break;
1876     case Bytecodes::_l2i: // fall through
1877     case Bytecodes::_l2f: // fall through
1878     case Bytecodes::_l2d: tos_in = ltos; break;
1879     case Bytecodes::_f2i: // fall through
1880     case Bytecodes::_f2l: // fall through
1881     case Bytecodes::_f2d: tos_in = ftos; break;
1882     case Bytecodes::_d2i: // fall through
1883     case Bytecodes::_d2l: // fall through
1884     case Bytecodes::_d2f: tos_in = dtos; break;
1885     default             : ShouldNotReachHere();
1886     }
1887     switch (bytecode()) {
1888     case Bytecodes::_l2i: // fall through
1889     case Bytecodes::_f2i: // fall through
1890     case Bytecodes::_d2i: // fall through
1891     case Bytecodes::_i2b: // fall through
1892     case Bytecodes::_i2c: // fall through
1893     case Bytecodes::_i2s: tos_out = itos; break;
1894     case Bytecodes::_i2l: // fall through
1895     case Bytecodes::_f2l: // fall through
1896     case Bytecodes::_d2l: tos_out = ltos; break;
1897     case Bytecodes::_i2f: // fall through
1898     case Bytecodes::_l2f: // fall through
1899     case Bytecodes::_d2f: tos_out = ftos; break;
1900     case Bytecodes::_i2d: // fall through
1901     case Bytecodes::_l2d: // fall through
1902     case Bytecodes::_f2d: tos_out = dtos; break;
1903     default             : ShouldNotReachHere();
1904     }
1905     transition(tos_in, tos_out);
1906   }
1907 #endif // ASSERT
1908 
1909   static const int64_t is_nan = 0x8000000000000000L;
1910 
1911   // Conversion
1912   switch (bytecode()) {
1913   case Bytecodes::_i2l:
1914     __ movslq(rax, rax);
1915     break;
1916   case Bytecodes::_i2f:
1917     __ cvtsi2ssl(xmm0, rax);
1918     break;
1919   case Bytecodes::_i2d:
1920     __ cvtsi2sdl(xmm0, rax);
1921     break;
1922   case Bytecodes::_i2b:
1923     __ movsbl(rax, rax);
1924     break;
1925   case Bytecodes::_i2c:
1926     __ movzwl(rax, rax);
1927     break;
1928   case Bytecodes::_i2s:
1929     __ movswl(rax, rax);
1930     break;
1931   case Bytecodes::_l2i:
1932     __ movl(rax, rax);
1933     break;
1934   case Bytecodes::_l2f:
1935     __ cvtsi2ssq(xmm0, rax);
1936     break;
1937   case Bytecodes::_l2d:
1938     __ cvtsi2sdq(xmm0, rax);
1939     break;
1940   case Bytecodes::_f2i:
1941   {
1942     Label L;
1943     __ cvttss2sil(rax, xmm0);
1944     __ cmpl(rax, 0x80000000); // NaN or overflow/underflow?
1945     __ jcc(Assembler::notEqual, L);
1946     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::f2i), 1);
1947     __ bind(L);
1948   }
1949     break;
1950   case Bytecodes::_f2l:
1951   {
1952     Label L;
1953     __ cvttss2siq(rax, xmm0);
1954     // NaN or overflow/underflow?
1955     __ cmp64(rax, ExternalAddress((address) &amp;is_nan));
1956     __ jcc(Assembler::notEqual, L);
1957     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::f2l), 1);
1958     __ bind(L);
1959   }
1960     break;
1961   case Bytecodes::_f2d:
1962     __ cvtss2sd(xmm0, xmm0);
1963     break;
1964   case Bytecodes::_d2i:
1965   {
1966     Label L;
1967     __ cvttsd2sil(rax, xmm0);
1968     __ cmpl(rax, 0x80000000); // NaN or overflow/underflow?
1969     __ jcc(Assembler::notEqual, L);
1970     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::d2i), 1);
1971     __ bind(L);
1972   }
1973     break;
1974   case Bytecodes::_d2l:
1975   {
1976     Label L;
1977     __ cvttsd2siq(rax, xmm0);
1978     // NaN or overflow/underflow?
1979     __ cmp64(rax, ExternalAddress((address) &amp;is_nan));
1980     __ jcc(Assembler::notEqual, L);
1981     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::d2l), 1);
1982     __ bind(L);
1983   }
1984     break;
1985   case Bytecodes::_d2f:
1986     __ cvtsd2ss(xmm0, xmm0);
1987     break;
1988   default:
1989     ShouldNotReachHere();
1990   }
1991 #else
1992   // Checking
1993 #ifdef ASSERT
1994   { TosState tos_in  = ilgl;
1995     TosState tos_out = ilgl;
1996     switch (bytecode()) {
1997       case Bytecodes::_i2l: // fall through
1998       case Bytecodes::_i2f: // fall through
1999       case Bytecodes::_i2d: // fall through
2000       case Bytecodes::_i2b: // fall through
2001       case Bytecodes::_i2c: // fall through
2002       case Bytecodes::_i2s: tos_in = itos; break;
2003       case Bytecodes::_l2i: // fall through
2004       case Bytecodes::_l2f: // fall through
2005       case Bytecodes::_l2d: tos_in = ltos; break;
2006       case Bytecodes::_f2i: // fall through
2007       case Bytecodes::_f2l: // fall through
2008       case Bytecodes::_f2d: tos_in = ftos; break;
2009       case Bytecodes::_d2i: // fall through
2010       case Bytecodes::_d2l: // fall through
2011       case Bytecodes::_d2f: tos_in = dtos; break;
2012       default             : ShouldNotReachHere();
2013     }
2014     switch (bytecode()) {
2015       case Bytecodes::_l2i: // fall through
2016       case Bytecodes::_f2i: // fall through
2017       case Bytecodes::_d2i: // fall through
2018       case Bytecodes::_i2b: // fall through
2019       case Bytecodes::_i2c: // fall through
2020       case Bytecodes::_i2s: tos_out = itos; break;
2021       case Bytecodes::_i2l: // fall through
2022       case Bytecodes::_f2l: // fall through
2023       case Bytecodes::_d2l: tos_out = ltos; break;
2024       case Bytecodes::_i2f: // fall through
2025       case Bytecodes::_l2f: // fall through
2026       case Bytecodes::_d2f: tos_out = ftos; break;
2027       case Bytecodes::_i2d: // fall through
2028       case Bytecodes::_l2d: // fall through
2029       case Bytecodes::_f2d: tos_out = dtos; break;
2030       default             : ShouldNotReachHere();
2031     }
2032     transition(tos_in, tos_out);
2033   }
2034 #endif // ASSERT
2035 
2036   // Conversion
2037   // (Note: use push(rcx)/pop(rcx) for 1/2-word stack-ptr manipulation)
2038   switch (bytecode()) {
2039     case Bytecodes::_i2l:
2040       __ extend_sign(rdx, rax);
2041       break;
2042     case Bytecodes::_i2f:
2043       if (UseSSE &gt;= 1) {
2044         __ cvtsi2ssl(xmm0, rax);
2045       } else {
2046         __ push(rax);          // store int on tos
2047         __ fild_s(at_rsp());   // load int to ST0
2048         __ f2ieee();           // truncate to float size
2049         __ pop(rcx);           // adjust rsp
2050       }
2051       break;
2052     case Bytecodes::_i2d:
2053       if (UseSSE &gt;= 2) {
2054         __ cvtsi2sdl(xmm0, rax);
2055       } else {
2056       __ push(rax);          // add one slot for d2ieee()
2057       __ push(rax);          // store int on tos
2058       __ fild_s(at_rsp());   // load int to ST0
2059       __ d2ieee();           // truncate to double size
2060       __ pop(rcx);           // adjust rsp
2061       __ pop(rcx);
2062       }
2063       break;
2064     case Bytecodes::_i2b:
2065       __ shll(rax, 24);      // truncate upper 24 bits
2066       __ sarl(rax, 24);      // and sign-extend byte
2067       LP64_ONLY(__ movsbl(rax, rax));
2068       break;
2069     case Bytecodes::_i2c:
2070       __ andl(rax, 0xFFFF);  // truncate upper 16 bits
2071       LP64_ONLY(__ movzwl(rax, rax));
2072       break;
2073     case Bytecodes::_i2s:
2074       __ shll(rax, 16);      // truncate upper 16 bits
2075       __ sarl(rax, 16);      // and sign-extend short
2076       LP64_ONLY(__ movswl(rax, rax));
2077       break;
2078     case Bytecodes::_l2i:
2079       /* nothing to do */
2080       break;
2081     case Bytecodes::_l2f:
2082       // On 64-bit platforms, the cvtsi2ssq instruction is used to convert
2083       // 64-bit long values to floats. On 32-bit platforms it is not possible
2084       // to use that instruction with 64-bit operands, therefore the FPU is
2085       // used to perform the conversion.
2086       __ push(rdx);          // store long on tos
2087       __ push(rax);
2088       __ fild_d(at_rsp());   // load long to ST0
2089       __ f2ieee();           // truncate to float size
2090       __ pop(rcx);           // adjust rsp
2091       __ pop(rcx);
2092       if (UseSSE &gt;= 1) {
2093         __ push_f();
2094         __ pop_f(xmm0);
2095       }
2096       break;
2097     case Bytecodes::_l2d:
2098       // On 32-bit platforms the FPU is used for conversion because on
2099       // 32-bit platforms it is not not possible to use the cvtsi2sdq
2100       // instruction with 64-bit operands.
2101       __ push(rdx);          // store long on tos
2102       __ push(rax);
2103       __ fild_d(at_rsp());   // load long to ST0
2104       __ d2ieee();           // truncate to double size
2105       __ pop(rcx);           // adjust rsp
2106       __ pop(rcx);
2107       if (UseSSE &gt;= 2) {
2108         __ push_d();
2109         __ pop_d(xmm0);
2110       }
2111       break;
2112     case Bytecodes::_f2i:
2113       // SharedRuntime::f2i does not differentiate between sNaNs and qNaNs
2114       // as it returns 0 for any NaN.
2115       if (UseSSE &gt;= 1) {
2116         __ push_f(xmm0);
2117       } else {
2118         __ push(rcx);          // reserve space for argument
2119         __ fstp_s(at_rsp());   // pass float argument on stack
2120       }
2121       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::f2i), 1);
2122       break;
2123     case Bytecodes::_f2l:
2124       // SharedRuntime::f2l does not differentiate between sNaNs and qNaNs
2125       // as it returns 0 for any NaN.
2126       if (UseSSE &gt;= 1) {
2127        __ push_f(xmm0);
2128       } else {
2129         __ push(rcx);          // reserve space for argument
2130         __ fstp_s(at_rsp());   // pass float argument on stack
2131       }
2132       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::f2l), 1);
2133       break;
2134     case Bytecodes::_f2d:
2135       if (UseSSE &lt; 1) {
2136         /* nothing to do */
2137       } else if (UseSSE == 1) {
2138         __ push_f(xmm0);
2139         __ pop_f();
2140       } else { // UseSSE &gt;= 2
2141         __ cvtss2sd(xmm0, xmm0);
2142       }
2143       break;
2144     case Bytecodes::_d2i:
2145       if (UseSSE &gt;= 2) {
2146         __ push_d(xmm0);
2147       } else {
2148         __ push(rcx);          // reserve space for argument
2149         __ push(rcx);
2150         __ fstp_d(at_rsp());   // pass double argument on stack
2151       }
2152       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::d2i), 2);
2153       break;
2154     case Bytecodes::_d2l:
2155       if (UseSSE &gt;= 2) {
2156         __ push_d(xmm0);
2157       } else {
2158         __ push(rcx);          // reserve space for argument
2159         __ push(rcx);
2160         __ fstp_d(at_rsp());   // pass double argument on stack
2161       }
2162       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::d2l), 2);
2163       break;
2164     case Bytecodes::_d2f:
2165       if (UseSSE &lt;= 1) {
2166         __ push(rcx);          // reserve space for f2ieee()
2167         __ f2ieee();           // truncate to float size
2168         __ pop(rcx);           // adjust rsp
2169         if (UseSSE == 1) {
2170           // The cvtsd2ss instruction is not available if UseSSE==1, therefore
2171           // the conversion is performed using the FPU in this case.
2172           __ push_f();
2173           __ pop_f(xmm0);
2174         }
2175       } else { // UseSSE &gt;= 2
2176         __ cvtsd2ss(xmm0, xmm0);
2177       }
2178       break;
2179     default             :
2180       ShouldNotReachHere();
2181   }
2182 #endif
2183 }
2184 
2185 void TemplateTable::lcmp() {
2186   transition(ltos, itos);
2187 #ifdef _LP64
2188   Label done;
2189   __ pop_l(rdx);
2190   __ cmpq(rdx, rax);
2191   __ movl(rax, -1);
2192   __ jccb(Assembler::less, done);
2193   __ setb(Assembler::notEqual, rax);
2194   __ movzbl(rax, rax);
2195   __ bind(done);
2196 #else
2197 
2198   // y = rdx:rax
2199   __ pop_l(rbx, rcx);             // get x = rcx:rbx
2200   __ lcmp2int(rcx, rbx, rdx, rax);// rcx := cmp(x, y)
2201   __ mov(rax, rcx);
2202 #endif
2203 }
2204 
2205 void TemplateTable::float_cmp(bool is_float, int unordered_result) {
2206   if ((is_float &amp;&amp; UseSSE &gt;= 1) ||
2207       (!is_float &amp;&amp; UseSSE &gt;= 2)) {
2208     Label done;
2209     if (is_float) {
2210       // XXX get rid of pop here, use ... reg, mem32
2211       __ pop_f(xmm1);
2212       __ ucomiss(xmm1, xmm0);
2213     } else {
2214       // XXX get rid of pop here, use ... reg, mem64
2215       __ pop_d(xmm1);
2216       __ ucomisd(xmm1, xmm0);
2217     }
2218     if (unordered_result &lt; 0) {
2219       __ movl(rax, -1);
2220       __ jccb(Assembler::parity, done);
2221       __ jccb(Assembler::below, done);
2222       __ setb(Assembler::notEqual, rdx);
2223       __ movzbl(rax, rdx);
2224     } else {
2225       __ movl(rax, 1);
2226       __ jccb(Assembler::parity, done);
2227       __ jccb(Assembler::above, done);
2228       __ movl(rax, 0);
2229       __ jccb(Assembler::equal, done);
2230       __ decrementl(rax);
2231     }
2232     __ bind(done);
2233   } else {
2234 #ifdef _LP64
2235     ShouldNotReachHere();
2236 #else
2237     if (is_float) {
2238       __ fld_s(at_rsp());
2239     } else {
2240       __ fld_d(at_rsp());
2241       __ pop(rdx);
2242     }
2243     __ pop(rcx);
2244     __ fcmp2int(rax, unordered_result &lt; 0);
2245 #endif // _LP64
2246   }
2247 }
2248 
2249 void TemplateTable::branch(bool is_jsr, bool is_wide) {
2250   __ get_method(rcx); // rcx holds method
2251   __ profile_taken_branch(rax, rbx); // rax holds updated MDP, rbx
2252                                      // holds bumped taken count
2253 
2254   const ByteSize be_offset = MethodCounters::backedge_counter_offset() +
2255                              InvocationCounter::counter_offset();
2256   const ByteSize inv_offset = MethodCounters::invocation_counter_offset() +
2257                               InvocationCounter::counter_offset();
2258 
2259   // Load up edx with the branch displacement
2260   if (is_wide) {
2261     __ movl(rdx, at_bcp(1));
2262   } else {
2263     __ load_signed_short(rdx, at_bcp(1));
2264   }
2265   __ bswapl(rdx);
2266 
2267   if (!is_wide) {
2268     __ sarl(rdx, 16);
2269   }
2270   LP64_ONLY(__ movl2ptr(rdx, rdx));
2271 
2272   // Handle all the JSR stuff here, then exit.
2273   // It&#39;s much shorter and cleaner than intermingling with the non-JSR
2274   // normal-branch stuff occurring below.
2275   if (is_jsr) {
2276     // Pre-load the next target bytecode into rbx
2277     __ load_unsigned_byte(rbx, Address(rbcp, rdx, Address::times_1, 0));
2278 
2279     // compute return address as bci in rax
2280     __ lea(rax, at_bcp((is_wide ? 5 : 3) -
2281                         in_bytes(ConstMethod::codes_offset())));
2282     __ subptr(rax, Address(rcx, Method::const_offset()));
2283     // Adjust the bcp in r13 by the displacement in rdx
2284     __ addptr(rbcp, rdx);
2285     // jsr returns atos that is not an oop
2286     __ push_i(rax);
2287     __ dispatch_only(vtos, true);
2288     return;
2289   }
2290 
2291   // Normal (non-jsr) branch handling
2292 
2293   // Adjust the bcp in r13 by the displacement in rdx
2294   __ addptr(rbcp, rdx);
2295 
2296   assert(UseLoopCounter || !UseOnStackReplacement,
2297          &quot;on-stack-replacement requires loop counters&quot;);
2298   Label backedge_counter_overflow;
2299   Label profile_method;
2300   Label dispatch;
2301   if (UseLoopCounter) {
2302     // increment backedge counter for backward branches
2303     // rax: MDO
2304     // rbx: MDO bumped taken-count
2305     // rcx: method
2306     // rdx: target offset
2307     // r13: target bcp
2308     // r14: locals pointer
2309     __ testl(rdx, rdx);             // check if forward or backward branch
2310     __ jcc(Assembler::positive, dispatch); // count only if backward branch
2311 
2312     // check if MethodCounters exists
2313     Label has_counters;
2314     __ movptr(rax, Address(rcx, Method::method_counters_offset()));
2315     __ testptr(rax, rax);
2316     __ jcc(Assembler::notZero, has_counters);
2317     __ push(rdx);
2318     __ push(rcx);
2319     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::build_method_counters),
2320                rcx);
2321     __ pop(rcx);
2322     __ pop(rdx);
2323     __ movptr(rax, Address(rcx, Method::method_counters_offset()));
2324     __ testptr(rax, rax);
2325     __ jcc(Assembler::zero, dispatch);
2326     __ bind(has_counters);
2327 
2328     if (TieredCompilation) {
2329       Label no_mdo;
2330       int increment = InvocationCounter::count_increment;
2331       if (ProfileInterpreter) {
2332         // Are we profiling?
2333         __ movptr(rbx, Address(rcx, in_bytes(Method::method_data_offset())));
2334         __ testptr(rbx, rbx);
2335         __ jccb(Assembler::zero, no_mdo);
2336         // Increment the MDO backedge counter
2337         const Address mdo_backedge_counter(rbx, in_bytes(MethodData::backedge_counter_offset()) +
2338                                            in_bytes(InvocationCounter::counter_offset()));
2339         const Address mask(rbx, in_bytes(MethodData::backedge_mask_offset()));
2340         __ increment_mask_and_jump(mdo_backedge_counter, increment, mask, rax, false, Assembler::zero,
2341                                    UseOnStackReplacement ? &amp;backedge_counter_overflow : NULL);
2342         __ jmp(dispatch);
2343       }
2344       __ bind(no_mdo);
2345       // Increment backedge counter in MethodCounters*
2346       __ movptr(rcx, Address(rcx, Method::method_counters_offset()));
2347       const Address mask(rcx, in_bytes(MethodCounters::backedge_mask_offset()));
2348       __ increment_mask_and_jump(Address(rcx, be_offset), increment, mask,
2349                                  rax, false, Assembler::zero,
2350                                  UseOnStackReplacement ? &amp;backedge_counter_overflow : NULL);
2351     } else { // not TieredCompilation
2352       // increment counter
2353       __ movptr(rcx, Address(rcx, Method::method_counters_offset()));
2354       __ movl(rax, Address(rcx, be_offset));        // load backedge counter
2355       __ incrementl(rax, InvocationCounter::count_increment); // increment counter
2356       __ movl(Address(rcx, be_offset), rax);        // store counter
2357 
2358       __ movl(rax, Address(rcx, inv_offset));    // load invocation counter
2359 
2360       __ andl(rax, InvocationCounter::count_mask_value); // and the status bits
2361       __ addl(rax, Address(rcx, be_offset));        // add both counters
2362 
2363       if (ProfileInterpreter) {
2364         // Test to see if we should create a method data oop
2365         __ cmp32(rax, Address(rcx, in_bytes(MethodCounters::interpreter_profile_limit_offset())));
2366         __ jcc(Assembler::less, dispatch);
2367 
2368         // if no method data exists, go to profile method
2369         __ test_method_data_pointer(rax, profile_method);
2370 
2371         if (UseOnStackReplacement) {
2372           // check for overflow against rbx which is the MDO taken count
2373           __ cmp32(rbx, Address(rcx, in_bytes(MethodCounters::interpreter_backward_branch_limit_offset())));
2374           __ jcc(Assembler::below, dispatch);
2375 
2376           // When ProfileInterpreter is on, the backedge_count comes
2377           // from the MethodData*, which value does not get reset on
2378           // the call to frequency_counter_overflow().  To avoid
2379           // excessive calls to the overflow routine while the method is
2380           // being compiled, add a second test to make sure the overflow
2381           // function is called only once every overflow_frequency.
2382           const int overflow_frequency = 1024;
2383           __ andl(rbx, overflow_frequency - 1);
2384           __ jcc(Assembler::zero, backedge_counter_overflow);
2385 
2386         }
2387       } else {
2388         if (UseOnStackReplacement) {
2389           // check for overflow against rax, which is the sum of the
2390           // counters
2391           __ cmp32(rax, Address(rcx, in_bytes(MethodCounters::interpreter_backward_branch_limit_offset())));
2392           __ jcc(Assembler::aboveEqual, backedge_counter_overflow);
2393 
2394         }
2395       }
2396     }
2397     __ bind(dispatch);
2398   }
2399 
2400   // Pre-load the next target bytecode into rbx
2401   __ load_unsigned_byte(rbx, Address(rbcp, 0));
2402 
2403   // continue with the bytecode @ target
2404   // rax: return bci for jsr&#39;s, unused otherwise
2405   // rbx: target bytecode
2406   // r13: target bcp
2407   __ dispatch_only(vtos, true);
2408 
2409   if (UseLoopCounter) {
2410     if (ProfileInterpreter) {
2411       // Out-of-line code to allocate method data oop.
2412       __ bind(profile_method);
2413       __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::profile_method));
2414       __ set_method_data_pointer_for_bcp();
2415       __ jmp(dispatch);
2416     }
2417 
2418     if (UseOnStackReplacement) {
2419       // invocation counter overflow
2420       __ bind(backedge_counter_overflow);
2421       __ negptr(rdx);
2422       __ addptr(rdx, rbcp); // branch bcp
2423       // IcoResult frequency_counter_overflow([JavaThread*], address branch_bcp)
2424       __ call_VM(noreg,
2425                  CAST_FROM_FN_PTR(address,
2426                                   InterpreterRuntime::frequency_counter_overflow),
2427                  rdx);
2428 
2429       // rax: osr nmethod (osr ok) or NULL (osr not possible)
2430       // rdx: scratch
2431       // r14: locals pointer
2432       // r13: bcp
2433       __ testptr(rax, rax);                        // test result
2434       __ jcc(Assembler::zero, dispatch);         // no osr if null
2435       // nmethod may have been invalidated (VM may block upon call_VM return)
2436       __ cmpb(Address(rax, nmethod::state_offset()), nmethod::in_use);
2437       __ jcc(Assembler::notEqual, dispatch);
2438 
2439       // We have the address of an on stack replacement routine in rax.
2440       // In preparation of invoking it, first we must migrate the locals
2441       // and monitors from off the interpreter frame on the stack.
2442       // Ensure to save the osr nmethod over the migration call,
2443       // it will be preserved in rbx.
2444       __ mov(rbx, rax);
2445 
2446       NOT_LP64(__ get_thread(rcx));
2447 
2448       call_VM(noreg, CAST_FROM_FN_PTR(address, SharedRuntime::OSR_migration_begin));
2449 
2450       // rax is OSR buffer, move it to expected parameter location
2451       LP64_ONLY(__ mov(j_rarg0, rax));
2452       NOT_LP64(__ mov(rcx, rax));
2453       // We use j_rarg definitions here so that registers don&#39;t conflict as parameter
2454       // registers change across platforms as we are in the midst of a calling
2455       // sequence to the OSR nmethod and we don&#39;t want collision. These are NOT parameters.
2456 
2457       const Register retaddr   = LP64_ONLY(j_rarg2) NOT_LP64(rdi);
2458       const Register sender_sp = LP64_ONLY(j_rarg1) NOT_LP64(rdx);
2459 
2460       // pop the interpreter frame
2461       __ movptr(sender_sp, Address(rbp, frame::interpreter_frame_sender_sp_offset * wordSize)); // get sender sp
2462       __ leave();                                // remove frame anchor
2463       __ pop(retaddr);                           // get return address
2464       __ mov(rsp, sender_sp);                   // set sp to sender sp
2465       // Ensure compiled code always sees stack at proper alignment
2466       __ andptr(rsp, -(StackAlignmentInBytes));
2467 
2468       // unlike x86 we need no specialized return from compiled code
2469       // to the interpreter or the call stub.
2470 
2471       // push the return address
2472       __ push(retaddr);
2473 
2474       // and begin the OSR nmethod
2475       __ jmp(Address(rbx, nmethod::osr_entry_point_offset()));
2476     }
2477   }
2478 }
2479 
2480 void TemplateTable::if_0cmp(Condition cc) {
2481   transition(itos, vtos);
2482   // assume branch is more often taken than not (loops use backward branches)
2483   Label not_taken;
2484   __ testl(rax, rax);
2485   __ jcc(j_not(cc), not_taken);
2486   branch(false, false);
2487   __ bind(not_taken);
2488   __ profile_not_taken_branch(rax);
2489 }
2490 
2491 void TemplateTable::if_icmp(Condition cc) {
2492   transition(itos, vtos);
2493   // assume branch is more often taken than not (loops use backward branches)
2494   Label not_taken;
2495   __ pop_i(rdx);
2496   __ cmpl(rdx, rax);
2497   __ jcc(j_not(cc), not_taken);
2498   branch(false, false);
2499   __ bind(not_taken);
2500   __ profile_not_taken_branch(rax);
2501 }
2502 
2503 void TemplateTable::if_nullcmp(Condition cc) {
2504   transition(atos, vtos);
2505   // assume branch is more often taken than not (loops use backward branches)
2506   Label not_taken;
2507   __ testptr(rax, rax);
2508   __ jcc(j_not(cc), not_taken);
2509   branch(false, false);
2510   __ bind(not_taken);
2511   __ profile_not_taken_branch(rax);
2512 }
2513 
2514 void TemplateTable::if_acmp(Condition cc) {
2515   transition(atos, vtos);
2516   // assume branch is more often taken than not (loops use backward branches)
2517   Label not_taken;
2518   __ pop_ptr(rdx);
2519   __ cmpoop(rdx, rax);
2520   __ jcc(j_not(cc), not_taken);
2521   branch(false, false);
2522   __ bind(not_taken);
2523   __ profile_not_taken_branch(rax);
2524 }
2525 
2526 void TemplateTable::ret() {
2527   transition(vtos, vtos);
2528   locals_index(rbx);
2529   LP64_ONLY(__ movslq(rbx, iaddress(rbx))); // get return bci, compute return bcp
2530   NOT_LP64(__ movptr(rbx, iaddress(rbx)));
2531   __ profile_ret(rbx, rcx);
2532   __ get_method(rax);
2533   __ movptr(rbcp, Address(rax, Method::const_offset()));
2534   __ lea(rbcp, Address(rbcp, rbx, Address::times_1,
2535                       ConstMethod::codes_offset()));
2536   __ dispatch_next(vtos, 0, true);
2537 }
2538 
2539 void TemplateTable::wide_ret() {
2540   transition(vtos, vtos);
2541   locals_index_wide(rbx);
2542   __ movptr(rbx, aaddress(rbx)); // get return bci, compute return bcp
2543   __ profile_ret(rbx, rcx);
2544   __ get_method(rax);
2545   __ movptr(rbcp, Address(rax, Method::const_offset()));
2546   __ lea(rbcp, Address(rbcp, rbx, Address::times_1, ConstMethod::codes_offset()));
2547   __ dispatch_next(vtos, 0, true);
2548 }
2549 
2550 void TemplateTable::tableswitch() {
2551   Label default_case, continue_execution;
2552   transition(itos, vtos);
2553 
2554   // align r13/rsi
2555   __ lea(rbx, at_bcp(BytesPerInt));
2556   __ andptr(rbx, -BytesPerInt);
2557   // load lo &amp; hi
2558   __ movl(rcx, Address(rbx, BytesPerInt));
2559   __ movl(rdx, Address(rbx, 2 * BytesPerInt));
2560   __ bswapl(rcx);
2561   __ bswapl(rdx);
2562   // check against lo &amp; hi
2563   __ cmpl(rax, rcx);
2564   __ jcc(Assembler::less, default_case);
2565   __ cmpl(rax, rdx);
2566   __ jcc(Assembler::greater, default_case);
2567   // lookup dispatch offset
2568   __ subl(rax, rcx);
2569   __ movl(rdx, Address(rbx, rax, Address::times_4, 3 * BytesPerInt));
2570   __ profile_switch_case(rax, rbx, rcx);
2571   // continue execution
2572   __ bind(continue_execution);
2573   __ bswapl(rdx);
2574   LP64_ONLY(__ movl2ptr(rdx, rdx));
2575   __ load_unsigned_byte(rbx, Address(rbcp, rdx, Address::times_1));
2576   __ addptr(rbcp, rdx);
2577   __ dispatch_only(vtos, true);
2578   // handle default
2579   __ bind(default_case);
2580   __ profile_switch_default(rax);
2581   __ movl(rdx, Address(rbx, 0));
2582   __ jmp(continue_execution);
2583 }
2584 
2585 void TemplateTable::lookupswitch() {
2586   transition(itos, itos);
2587   __ stop(&quot;lookupswitch bytecode should have been rewritten&quot;);
2588 }
2589 
2590 void TemplateTable::fast_linearswitch() {
2591   transition(itos, vtos);
2592   Label loop_entry, loop, found, continue_execution;
2593   // bswap rax so we can avoid bswapping the table entries
2594   __ bswapl(rax);
2595   // align r13
2596   __ lea(rbx, at_bcp(BytesPerInt)); // btw: should be able to get rid of
2597                                     // this instruction (change offsets
2598                                     // below)
2599   __ andptr(rbx, -BytesPerInt);
2600   // set counter
2601   __ movl(rcx, Address(rbx, BytesPerInt));
2602   __ bswapl(rcx);
2603   __ jmpb(loop_entry);
2604   // table search
2605   __ bind(loop);
2606   __ cmpl(rax, Address(rbx, rcx, Address::times_8, 2 * BytesPerInt));
2607   __ jcc(Assembler::equal, found);
2608   __ bind(loop_entry);
2609   __ decrementl(rcx);
2610   __ jcc(Assembler::greaterEqual, loop);
2611   // default case
2612   __ profile_switch_default(rax);
2613   __ movl(rdx, Address(rbx, 0));
2614   __ jmp(continue_execution);
2615   // entry found -&gt; get offset
2616   __ bind(found);
2617   __ movl(rdx, Address(rbx, rcx, Address::times_8, 3 * BytesPerInt));
2618   __ profile_switch_case(rcx, rax, rbx);
2619   // continue execution
2620   __ bind(continue_execution);
2621   __ bswapl(rdx);
2622   __ movl2ptr(rdx, rdx);
2623   __ load_unsigned_byte(rbx, Address(rbcp, rdx, Address::times_1));
2624   __ addptr(rbcp, rdx);
2625   __ dispatch_only(vtos, true);
2626 }
2627 
2628 void TemplateTable::fast_binaryswitch() {
2629   transition(itos, vtos);
2630   // Implementation using the following core algorithm:
2631   //
2632   // int binary_search(int key, LookupswitchPair* array, int n) {
2633   //   // Binary search according to &quot;Methodik des Programmierens&quot; by
2634   //   // Edsger W. Dijkstra and W.H.J. Feijen, Addison Wesley Germany 1985.
2635   //   int i = 0;
2636   //   int j = n;
2637   //   while (i+1 &lt; j) {
2638   //     // invariant P: 0 &lt;= i &lt; j &lt;= n and (a[i] &lt;= key &lt; a[j] or Q)
2639   //     // with      Q: for all i: 0 &lt;= i &lt; n: key &lt; a[i]
2640   //     // where a stands for the array and assuming that the (inexisting)
2641   //     // element a[n] is infinitely big.
2642   //     int h = (i + j) &gt;&gt; 1;
2643   //     // i &lt; h &lt; j
2644   //     if (key &lt; array[h].fast_match()) {
2645   //       j = h;
2646   //     } else {
2647   //       i = h;
2648   //     }
2649   //   }
2650   //   // R: a[i] &lt;= key &lt; a[i+1] or Q
2651   //   // (i.e., if key is within array, i is the correct index)
2652   //   return i;
2653   // }
2654 
2655   // Register allocation
2656   const Register key   = rax; // already set (tosca)
2657   const Register array = rbx;
2658   const Register i     = rcx;
2659   const Register j     = rdx;
2660   const Register h     = rdi;
2661   const Register temp  = rsi;
2662 
2663   // Find array start
2664   NOT_LP64(__ save_bcp());
2665 
2666   __ lea(array, at_bcp(3 * BytesPerInt)); // btw: should be able to
2667                                           // get rid of this
2668                                           // instruction (change
2669                                           // offsets below)
2670   __ andptr(array, -BytesPerInt);
2671 
2672   // Initialize i &amp; j
2673   __ xorl(i, i);                            // i = 0;
2674   __ movl(j, Address(array, -BytesPerInt)); // j = length(array);
2675 
2676   // Convert j into native byteordering
2677   __ bswapl(j);
2678 
2679   // And start
2680   Label entry;
2681   __ jmp(entry);
2682 
2683   // binary search loop
2684   {
2685     Label loop;
2686     __ bind(loop);
2687     // int h = (i + j) &gt;&gt; 1;
2688     __ leal(h, Address(i, j, Address::times_1)); // h = i + j;
2689     __ sarl(h, 1);                               // h = (i + j) &gt;&gt; 1;
2690     // if (key &lt; array[h].fast_match()) {
2691     //   j = h;
2692     // } else {
2693     //   i = h;
2694     // }
2695     // Convert array[h].match to native byte-ordering before compare
2696     __ movl(temp, Address(array, h, Address::times_8));
2697     __ bswapl(temp);
2698     __ cmpl(key, temp);
2699     // j = h if (key &lt;  array[h].fast_match())
2700     __ cmov32(Assembler::less, j, h);
2701     // i = h if (key &gt;= array[h].fast_match())
2702     __ cmov32(Assembler::greaterEqual, i, h);
2703     // while (i+1 &lt; j)
2704     __ bind(entry);
2705     __ leal(h, Address(i, 1)); // i+1
2706     __ cmpl(h, j);             // i+1 &lt; j
2707     __ jcc(Assembler::less, loop);
2708   }
2709 
2710   // end of binary search, result index is i (must check again!)
2711   Label default_case;
2712   // Convert array[i].match to native byte-ordering before compare
2713   __ movl(temp, Address(array, i, Address::times_8));
2714   __ bswapl(temp);
2715   __ cmpl(key, temp);
2716   __ jcc(Assembler::notEqual, default_case);
2717 
2718   // entry found -&gt; j = offset
2719   __ movl(j , Address(array, i, Address::times_8, BytesPerInt));
2720   __ profile_switch_case(i, key, array);
2721   __ bswapl(j);
2722   LP64_ONLY(__ movslq(j, j));
2723 
2724   NOT_LP64(__ restore_bcp());
2725   NOT_LP64(__ restore_locals());                           // restore rdi
2726 
2727   __ load_unsigned_byte(rbx, Address(rbcp, j, Address::times_1));
2728   __ addptr(rbcp, j);
2729   __ dispatch_only(vtos, true);
2730 
2731   // default case -&gt; j = default offset
2732   __ bind(default_case);
2733   __ profile_switch_default(i);
2734   __ movl(j, Address(array, -2 * BytesPerInt));
2735   __ bswapl(j);
2736   LP64_ONLY(__ movslq(j, j));
2737 
2738   NOT_LP64(__ restore_bcp());
2739   NOT_LP64(__ restore_locals());
2740 
2741   __ load_unsigned_byte(rbx, Address(rbcp, j, Address::times_1));
2742   __ addptr(rbcp, j);
2743   __ dispatch_only(vtos, true);
2744 }
2745 
2746 void TemplateTable::_return(TosState state) {
2747   transition(state, state);
2748 
2749   assert(_desc-&gt;calls_vm(),
2750          &quot;inconsistent calls_vm information&quot;); // call in remove_activation
2751 
2752   if (_desc-&gt;bytecode() == Bytecodes::_return_register_finalizer) {
2753     assert(state == vtos, &quot;only valid state&quot;);
2754     Register robj = LP64_ONLY(c_rarg1) NOT_LP64(rax);
2755     __ movptr(robj, aaddress(0));
2756     __ load_klass(rdi, robj);
2757     __ movl(rdi, Address(rdi, Klass::access_flags_offset()));
2758     __ testl(rdi, JVM_ACC_HAS_FINALIZER);
2759     Label skip_register_finalizer;
2760     __ jcc(Assembler::zero, skip_register_finalizer);
2761 
2762     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::register_finalizer), robj);
2763 
2764     __ bind(skip_register_finalizer);
2765   }
2766 
2767   if (SafepointMechanism::uses_thread_local_poll() &amp;&amp; _desc-&gt;bytecode() != Bytecodes::_return_register_finalizer) {
2768     Label no_safepoint;
2769     NOT_PRODUCT(__ block_comment(&quot;Thread-local Safepoint poll&quot;));
2770 #ifdef _LP64
2771     __ testb(Address(r15_thread, Thread::polling_page_offset()), SafepointMechanism::poll_bit());
2772 #else
2773     const Register thread = rdi;
2774     __ get_thread(thread);
2775     __ testb(Address(thread, Thread::polling_page_offset()), SafepointMechanism::poll_bit());
2776 #endif
2777     __ jcc(Assembler::zero, no_safepoint);
2778     __ push(state);
2779     __ call_VM(noreg, CAST_FROM_FN_PTR(address,
2780                                     InterpreterRuntime::at_safepoint));
2781     __ pop(state);
2782     __ bind(no_safepoint);
2783   }
2784 
2785   // Narrow result if state is itos but result type is smaller.
2786   // Need to narrow in the return bytecode rather than in generate_return_entry
2787   // since compiled code callers expect the result to already be narrowed.
2788   if (state == itos) {
2789     __ narrow(rax);
2790   }
2791   __ remove_activation(state, rbcp);
2792 
2793   __ jmp(rbcp);
2794 }
2795 
2796 // ----------------------------------------------------------------------------
2797 // Volatile variables demand their effects be made known to all CPU&#39;s
2798 // in order.  Store buffers on most chips allow reads &amp; writes to
2799 // reorder; the JMM&#39;s ReadAfterWrite.java test fails in -Xint mode
2800 // without some kind of memory barrier (i.e., it&#39;s not sufficient that
2801 // the interpreter does not reorder volatile references, the hardware
2802 // also must not reorder them).
2803 //
2804 // According to the new Java Memory Model (JMM):
2805 // (1) All volatiles are serialized wrt to each other.  ALSO reads &amp;
2806 //     writes act as aquire &amp; release, so:
2807 // (2) A read cannot let unrelated NON-volatile memory refs that
2808 //     happen after the read float up to before the read.  It&#39;s OK for
2809 //     non-volatile memory refs that happen before the volatile read to
2810 //     float down below it.
2811 // (3) Similar a volatile write cannot let unrelated NON-volatile
2812 //     memory refs that happen BEFORE the write float down to after the
2813 //     write.  It&#39;s OK for non-volatile memory refs that happen after the
2814 //     volatile write to float up before it.
2815 //
2816 // We only put in barriers around volatile refs (they are expensive),
2817 // not _between_ memory refs (that would require us to track the
2818 // flavor of the previous memory refs).  Requirements (2) and (3)
2819 // require some barriers before volatile stores and after volatile
2820 // loads.  These nearly cover requirement (1) but miss the
2821 // volatile-store-volatile-load case.  This final case is placed after
2822 // volatile-stores although it could just as well go before
2823 // volatile-loads.
2824 
2825 void TemplateTable::volatile_barrier(Assembler::Membar_mask_bits order_constraint ) {
2826   // Helper function to insert a is-volatile test and memory barrier
2827   __ membar(order_constraint);
2828 }
2829 
2830 void TemplateTable::resolve_cache_and_index(int byte_no,
2831                                             Register cache,
2832                                             Register index,
2833                                             size_t index_size) {
2834   const Register temp = rbx;
2835   assert_different_registers(cache, index, temp);
2836 
2837   Label L_clinit_barrier_slow;
2838   Label resolved;
2839 
2840   Bytecodes::Code code = bytecode();
2841   switch (code) {
2842   case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;
2843   case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;
2844   default: break;
2845   }
2846 
2847   assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
2848   __ get_cache_and_index_and_bytecode_at_bcp(cache, index, temp, byte_no, 1, index_size);
2849   __ cmpl(temp, code);  // have we resolved this bytecode?
2850   __ jcc(Assembler::equal, resolved);
2851 
2852   // resolve first time through
2853   // Class initialization barrier slow path lands here as well.
2854   __ bind(L_clinit_barrier_slow);
2855   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);
2856   __ movl(temp, code);
2857   __ call_VM(noreg, entry, temp);
2858   // Update registers with resolved info
2859   __ get_cache_and_index_at_bcp(cache, index, 1, index_size);
2860 
2861   __ bind(resolved);
2862 
2863   // Class initialization barrier for static methods
2864   if (VM_Version::supports_fast_class_init_checks() &amp;&amp; bytecode() == Bytecodes::_invokestatic) {
2865     const Register method = temp;
2866     const Register klass  = temp;
2867     const Register thread = LP64_ONLY(r15_thread) NOT_LP64(noreg);
2868     assert(thread != noreg, &quot;x86_32 not supported&quot;);
2869 
2870     __ load_resolved_method_at_index(byte_no, method, cache, index);
2871     __ load_method_holder(klass, method);
2872     __ clinit_barrier(klass, thread, NULL /*L_fast_path*/, &amp;L_clinit_barrier_slow);
2873   }
2874 }
2875 
2876 // The cache and index registers must be set before call
2877 void TemplateTable::load_field_cp_cache_entry(Register obj,
2878                                               Register cache,
2879                                               Register index,
2880                                               Register off,
2881                                               Register flags,
2882                                               bool is_static = false) {
2883   assert_different_registers(cache, index, flags, off);
2884 
2885   ByteSize cp_base_offset = ConstantPoolCache::base_offset();
2886   // Field offset
2887   __ movptr(off, Address(cache, index, Address::times_ptr,
2888                          in_bytes(cp_base_offset +
2889                                   ConstantPoolCacheEntry::f2_offset())));
2890   // Flags
2891   __ movl(flags, Address(cache, index, Address::times_ptr,
2892                          in_bytes(cp_base_offset +
2893                                   ConstantPoolCacheEntry::flags_offset())));
2894 
2895   // klass overwrite register
2896   if (is_static) {
2897     __ movptr(obj, Address(cache, index, Address::times_ptr,
2898                            in_bytes(cp_base_offset +
2899                                     ConstantPoolCacheEntry::f1_offset())));
2900     const int mirror_offset = in_bytes(Klass::java_mirror_offset());
2901     __ movptr(obj, Address(obj, mirror_offset));
2902     __ resolve_oop_handle(obj);
2903     TSAN_RUNTIME_ONLY(
2904       // Draw a happens-before edge from the class&#39;s static initializer to
2905       // this lookup.
2906 
2907       // java_lang_Class::_init_lock_offset may not have been initialized
2908       // when generating code. It will be initialized at runtime though.
2909       // So calculate its address and read from it at runtime.
2910       __ pusha();
2911       __ movq(c_rarg0, obj);
2912       AddressLiteral init_lock_offset_address(
2913           (address) java_lang_Class::init_lock_offset_addr(),
2914           relocInfo::none);
2915       __ lea(rax, init_lock_offset_address);
2916       __ movl(rax, Address(rax, 0));
2917       __ addq(c_rarg0, rax);
2918       __ call_VM_leaf(CAST_FROM_FN_PTR(address,
2919                                        SharedRuntime::tsan_acquire),
2920                       c_rarg0);
2921       __ popa();
2922     );
2923   }
2924 }
2925 
2926 void TemplateTable::load_invoke_cp_cache_entry(int byte_no,
2927                                                Register method,
2928                                                Register itable_index,
2929                                                Register flags,
2930                                                bool is_invokevirtual,
2931                                                bool is_invokevfinal, /*unused*/
2932                                                bool is_invokedynamic) {
2933   // setup registers
2934   const Register cache = rcx;
2935   const Register index = rdx;
2936   assert_different_registers(method, flags);
2937   assert_different_registers(method, cache, index);
2938   assert_different_registers(itable_index, flags);
2939   assert_different_registers(itable_index, cache, index);
2940   // determine constant pool cache field offsets
2941   assert(is_invokevirtual == (byte_no == f2_byte), &quot;is_invokevirtual flag redundant&quot;);
2942   const int flags_offset = in_bytes(ConstantPoolCache::base_offset() +
2943                                     ConstantPoolCacheEntry::flags_offset());
2944   // access constant pool cache fields
2945   const int index_offset = in_bytes(ConstantPoolCache::base_offset() +
2946                                     ConstantPoolCacheEntry::f2_offset());
2947 
2948   size_t index_size = (is_invokedynamic ? sizeof(u4) : sizeof(u2));
2949   resolve_cache_and_index(byte_no, cache, index, index_size);
2950   __ load_resolved_method_at_index(byte_no, method, cache, index);
2951 
2952   if (itable_index != noreg) {
2953     // pick up itable or appendix index from f2 also:
2954     __ movptr(itable_index, Address(cache, index, Address::times_ptr, index_offset));
2955   }
2956   __ movl(flags, Address(cache, index, Address::times_ptr, flags_offset));
2957 }
2958 
2959 // The registers cache and index expected to be set before call.
2960 // Correct values of the cache and index registers are preserved.
2961 void TemplateTable::jvmti_post_field_access(Register cache,
2962                                             Register index,
2963                                             bool is_static,
2964                                             bool has_tos) {
2965   if (JvmtiExport::can_post_field_access()) {
2966     // Check to see if a field access watch has been set before we take
2967     // the time to call into the VM.
2968     Label L1;
2969     assert_different_registers(cache, index, rax);
2970     __ mov32(rax, ExternalAddress((address) JvmtiExport::get_field_access_count_addr()));
2971     __ testl(rax,rax);
2972     __ jcc(Assembler::zero, L1);
2973 
2974     // cache entry pointer
2975     __ addptr(cache, in_bytes(ConstantPoolCache::base_offset()));
2976     __ shll(index, LogBytesPerWord);
2977     __ addptr(cache, index);
2978     if (is_static) {
2979       __ xorptr(rax, rax);      // NULL object reference
2980     } else {
2981       __ pop(atos);         // Get the object
2982       __ verify_oop(rax);
2983       __ push(atos);        // Restore stack state
2984     }
2985     // rax,:   object pointer or NULL
2986     // cache: cache entry pointer
2987     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_access),
2988                rax, cache);
2989     __ get_cache_and_index_at_bcp(cache, index, 1);
2990     __ bind(L1);
2991   }
2992 }
2993 
2994 void TemplateTable::pop_and_check_object(Register r) {
2995   __ pop_ptr(r);
2996   __ null_check(r);  // for field access must check obj.
2997   __ verify_oop(r);
2998 }
2999 
3000 void TemplateTable::getfield_or_static(int byte_no, bool is_static, RewriteControl rc) {
3001   transition(vtos, vtos);
3002 
3003   const Register cache = rcx;
3004   const Register index = rdx;
3005   const Register obj   = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
3006   const Register off   = rbx;
3007   const Register flags = rax;
3008   const Register bc    = LP64_ONLY(c_rarg3) NOT_LP64(rcx); // uses same reg as obj, so don&#39;t mix them
3009 
3010   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
3011   jvmti_post_field_access(cache, index, is_static, false);
3012   load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);
3013 
3014   if (!is_static) pop_and_check_object(obj);
3015 
3016   const Address field(obj, off, Address::times_1, 0*wordSize);
3017 
3018   // During a TSAN instrumented run, move flags into rdx so we can later
3019   // examine whether the field is volatile or has been annotated to be ignored
3020   // by Tsan.
3021   TSAN_RUNTIME_ONLY(__ movl(rdx, flags));
3022 
3023   Label Done, notByte, notBool, notInt, notShort, notChar, notLong, notFloat, notObj;
3024 
3025   __ shrl(flags, ConstantPoolCacheEntry::tos_state_shift);
3026   // Make sure we don&#39;t need to mask edx after the above shift
3027   assert(btos == 0, &quot;change code, btos != 0&quot;);
3028 
3029   __ andl(flags, ConstantPoolCacheEntry::tos_state_mask);
3030 
3031   __ jcc(Assembler::notZero, notByte);
3032   // btos
3033   __ access_load_at(T_BYTE, IN_HEAP, rax, field, noreg, noreg);
3034   __ push(btos);
3035   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(
3036       field, rdx, SharedRuntime::tsan_read1, btos));
3037   // Rewrite bytecode to be faster
3038   if (!is_static &amp;&amp; rc == may_rewrite) {
3039     patch_bytecode(Bytecodes::_fast_bgetfield, bc, rbx);
3040   }
3041   __ jmp(Done);
3042 
3043   __ bind(notByte);
3044   __ cmpl(flags, ztos);
3045   __ jcc(Assembler::notEqual, notBool);
3046 
3047   // ztos (same code as btos)
3048   __ access_load_at(T_BOOLEAN, IN_HEAP, rax, field, noreg, noreg);
3049   __ push(ztos);
3050   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(
3051       field, rdx, SharedRuntime::tsan_read1, ztos));
3052   // Rewrite bytecode to be faster
3053   if (!is_static &amp;&amp; rc == may_rewrite) {
3054     // use btos rewriting, no truncating to t/f bit is needed for getfield.
3055     patch_bytecode(Bytecodes::_fast_bgetfield, bc, rbx);
3056   }
3057   __ jmp(Done);
3058 
3059   __ bind(notBool);
3060   __ cmpl(flags, atos);
3061   __ jcc(Assembler::notEqual, notObj);
3062   // atos
3063   do_oop_load(_masm, field, rax);
3064   __ push(atos);
3065   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(
3066       field, rdx, UseCompressedOops ? SharedRuntime::tsan_read4
3067                                     : SharedRuntime::tsan_read8,
3068       atos));
3069   if (!is_static &amp;&amp; rc == may_rewrite) {
3070     patch_bytecode(Bytecodes::_fast_agetfield, bc, rbx);
3071   }
3072   __ jmp(Done);
3073 
3074   __ bind(notObj);
3075   __ cmpl(flags, itos);
3076   __ jcc(Assembler::notEqual, notInt);
3077   // itos
3078   __ access_load_at(T_INT, IN_HEAP, rax, field, noreg, noreg);
3079   __ push(itos);
3080   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(
3081       field, rdx, SharedRuntime::tsan_read4, itos));
3082   // Rewrite bytecode to be faster
3083   if (!is_static &amp;&amp; rc == may_rewrite) {
3084     patch_bytecode(Bytecodes::_fast_igetfield, bc, rbx);
3085   }
3086   __ jmp(Done);
3087 
3088   __ bind(notInt);
3089   __ cmpl(flags, ctos);
3090   __ jcc(Assembler::notEqual, notChar);
3091   // ctos
3092   __ access_load_at(T_CHAR, IN_HEAP, rax, field, noreg, noreg);
3093   __ push(ctos);
3094   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(
3095       field, rdx, SharedRuntime::tsan_read2, ctos));
3096   // Rewrite bytecode to be faster
3097   if (!is_static &amp;&amp; rc == may_rewrite) {
3098     patch_bytecode(Bytecodes::_fast_cgetfield, bc, rbx);
3099   }
3100   __ jmp(Done);
3101 
3102   __ bind(notChar);
3103   __ cmpl(flags, stos);
3104   __ jcc(Assembler::notEqual, notShort);
3105   // stos
3106   __ access_load_at(T_SHORT, IN_HEAP, rax, field, noreg, noreg);
3107   __ push(stos);
3108   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(
3109       field, rdx, SharedRuntime::tsan_read2, stos));
3110   // Rewrite bytecode to be faster
3111   if (!is_static &amp;&amp; rc == may_rewrite) {
3112     patch_bytecode(Bytecodes::_fast_sgetfield, bc, rbx);
3113   }
3114   __ jmp(Done);
3115 
3116   __ bind(notShort);
3117   __ cmpl(flags, ltos);
3118   __ jcc(Assembler::notEqual, notLong);
3119   // ltos
3120     // Generate code as if volatile (x86_32).  There just aren&#39;t enough registers to
3121     // save that information and this code is faster than the test.
3122   __ access_load_at(T_LONG, IN_HEAP | MO_RELAXED, noreg /* ltos */, field, noreg, noreg);
3123   __ push(ltos);
3124   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(
3125       field, rdx, SharedRuntime::tsan_read8, ltos));
3126   // Rewrite bytecode to be faster
3127   LP64_ONLY(if (!is_static &amp;&amp; rc == may_rewrite) patch_bytecode(Bytecodes::_fast_lgetfield, bc, rbx));
3128   __ jmp(Done);
3129 
3130   __ bind(notLong);
3131   __ cmpl(flags, ftos);
3132   __ jcc(Assembler::notEqual, notFloat);
3133   // ftos
3134 
3135   __ access_load_at(T_FLOAT, IN_HEAP, noreg /* ftos */, field, noreg, noreg);
3136   __ push(ftos);
3137   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(
3138       field, rdx, SharedRuntime::tsan_read4, ftos));
3139   // Rewrite bytecode to be faster
3140   if (!is_static &amp;&amp; rc == may_rewrite) {
3141     patch_bytecode(Bytecodes::_fast_fgetfield, bc, rbx);
3142   }
3143   __ jmp(Done);
3144 
3145   __ bind(notFloat);
3146 #ifdef ASSERT
3147   Label notDouble;
3148   __ cmpl(flags, dtos);
3149   __ jcc(Assembler::notEqual, notDouble);
3150 #endif
3151   // dtos
3152   // MO_RELAXED: for the case of volatile field, in fact it adds no extra work for the underlying implementation
3153   __ access_load_at(T_DOUBLE, IN_HEAP | MO_RELAXED, noreg /* dtos */, field, noreg, noreg);
3154   __ push(dtos);
3155   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(
3156       field, rdx, SharedRuntime::tsan_read8, dtos));
3157   // Rewrite bytecode to be faster
3158   if (!is_static &amp;&amp; rc == may_rewrite) {
3159     patch_bytecode(Bytecodes::_fast_dgetfield, bc, rbx);
3160   }
3161 #ifdef ASSERT
3162   __ jmp(Done);
3163 
3164   __ bind(notDouble);
3165   __ stop(&quot;Bad state&quot;);
3166 #endif
3167 
3168   __ bind(Done);
3169   // [jk] not needed currently
3170   // volatile_barrier(Assembler::Membar_mask_bits(Assembler::LoadLoad |
3171   //                                              Assembler::LoadStore));
3172 }
3173 
3174 void TemplateTable::getfield(int byte_no) {
3175   getfield_or_static(byte_no, false);
3176 }
3177 
3178 void TemplateTable::nofast_getfield(int byte_no) {
3179   getfield_or_static(byte_no, false, may_not_rewrite);
3180 }
3181 
3182 void TemplateTable::getstatic(int byte_no) {
3183   getfield_or_static(byte_no, true);
3184 }
3185 
3186 
3187 // The registers cache and index expected to be set before call.
3188 // The function may destroy various registers, just not the cache and index registers.
3189 void TemplateTable::jvmti_post_field_mod(Register cache, Register index, bool is_static) {
3190 
3191   const Register robj = LP64_ONLY(c_rarg2)   NOT_LP64(rax);
3192   const Register RBX  = LP64_ONLY(c_rarg1)   NOT_LP64(rbx);
3193   const Register RCX  = LP64_ONLY(c_rarg3)   NOT_LP64(rcx);
3194   const Register RDX  = LP64_ONLY(rscratch1) NOT_LP64(rdx);
3195 
3196   ByteSize cp_base_offset = ConstantPoolCache::base_offset();
3197 
3198   if (JvmtiExport::can_post_field_modification()) {
3199     // Check to see if a field modification watch has been set before
3200     // we take the time to call into the VM.
3201     Label L1;
3202     assert_different_registers(cache, index, rax);
3203     __ mov32(rax, ExternalAddress((address)JvmtiExport::get_field_modification_count_addr()));
3204     __ testl(rax, rax);
3205     __ jcc(Assembler::zero, L1);
3206 
3207     __ get_cache_and_index_at_bcp(robj, RDX, 1);
3208 
3209 
3210     if (is_static) {
3211       // Life is simple.  Null out the object pointer.
3212       __ xorl(RBX, RBX);
3213 
3214     } else {
3215       // Life is harder. The stack holds the value on top, followed by
3216       // the object.  We don&#39;t know the size of the value, though; it
3217       // could be one or two words depending on its type. As a result,
3218       // we must find the type to determine where the object is.
3219 #ifndef _LP64
3220       Label two_word, valsize_known;
3221 #endif
3222       __ movl(RCX, Address(robj, RDX,
3223                            Address::times_ptr,
3224                            in_bytes(cp_base_offset +
3225                                      ConstantPoolCacheEntry::flags_offset())));
3226       NOT_LP64(__ mov(rbx, rsp));
3227       __ shrl(RCX, ConstantPoolCacheEntry::tos_state_shift);
3228 
3229       // Make sure we don&#39;t need to mask rcx after the above shift
3230       ConstantPoolCacheEntry::verify_tos_state_shift();
3231 #ifdef _LP64
3232       __ movptr(c_rarg1, at_tos_p1());  // initially assume a one word jvalue
3233       __ cmpl(c_rarg3, ltos);
3234       __ cmovptr(Assembler::equal,
3235                  c_rarg1, at_tos_p2()); // ltos (two word jvalue)
3236       __ cmpl(c_rarg3, dtos);
3237       __ cmovptr(Assembler::equal,
3238                  c_rarg1, at_tos_p2()); // dtos (two word jvalue)
3239 #else
3240       __ cmpl(rcx, ltos);
3241       __ jccb(Assembler::equal, two_word);
3242       __ cmpl(rcx, dtos);
3243       __ jccb(Assembler::equal, two_word);
3244       __ addptr(rbx, Interpreter::expr_offset_in_bytes(1)); // one word jvalue (not ltos, dtos)
3245       __ jmpb(valsize_known);
3246 
3247       __ bind(two_word);
3248       __ addptr(rbx, Interpreter::expr_offset_in_bytes(2)); // two words jvalue
3249 
3250       __ bind(valsize_known);
3251       // setup object pointer
3252       __ movptr(rbx, Address(rbx, 0));
3253 #endif
3254     }
3255     // cache entry pointer
3256     __ addptr(robj, in_bytes(cp_base_offset));
3257     __ shll(RDX, LogBytesPerWord);
3258     __ addptr(robj, RDX);
3259     // object (tos)
3260     __ mov(RCX, rsp);
3261     // c_rarg1: object pointer set up above (NULL if static)
3262     // c_rarg2: cache entry pointer
3263     // c_rarg3: jvalue object on the stack
3264     __ call_VM(noreg,
3265                CAST_FROM_FN_PTR(address,
3266                                 InterpreterRuntime::post_field_modification),
3267                RBX, robj, RCX);
3268     __ get_cache_and_index_at_bcp(cache, index, 1);
3269     __ bind(L1);
3270   }
3271 }
3272 
3273 void TemplateTable::putfield_or_static(int byte_no, bool is_static, RewriteControl rc) {
3274   transition(vtos, vtos);
3275 
3276   const Register cache = rcx;
3277   const Register index = rdx;
3278   const Register obj   = rcx;
3279   const Register off   = rbx;
3280   const Register flags = rax;
3281 
3282   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
3283   jvmti_post_field_mod(cache, index, is_static);
3284   load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);
3285 
3286   // [jk] not needed currently
3287   // volatile_barrier(Assembler::Membar_mask_bits(Assembler::LoadStore |
3288   //                                              Assembler::StoreStore));
3289 
3290   Label notVolatile, Done;
3291   __ movl(rdx, flags);
3292 
3293   // Check for volatile store
3294   __ testl(rdx, 1 &lt;&lt; ConstantPoolCacheEntry::is_volatile_shift);
3295   __ jcc(Assembler::zero, notVolatile);
3296 
3297   putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags);
3298   volatile_barrier(Assembler::Membar_mask_bits(Assembler::StoreLoad |
3299                                                Assembler::StoreStore));
3300   __ jmp(Done);
3301   __ bind(notVolatile);
3302 
3303   putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags);
3304 
3305   __ bind(Done);
3306 }
3307 
3308 void TemplateTable::putfield_or_static_helper(int byte_no, bool is_static, RewriteControl rc,
3309                                               Register obj, Register off, Register flags) {
3310 
3311   // field addresses
3312   const Address field(obj, off, Address::times_1, 0*wordSize);
3313   NOT_LP64( const Address hi(obj, off, Address::times_1, 1*wordSize);)
3314 
3315   Label notByte, notBool, notInt, notShort, notChar,
3316         notLong, notFloat, notObj;
3317   Label Done;
3318 
3319   const Register bc    = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
3320 
3321   __ shrl(flags, ConstantPoolCacheEntry::tos_state_shift);
3322 
3323   assert(btos == 0, &quot;change code, btos != 0&quot;);
3324   __ andl(flags, ConstantPoolCacheEntry::tos_state_mask);
3325   __ jcc(Assembler::notZero, notByte);
3326 
3327   // btos
3328   {
3329     __ pop(btos);
3330     if (!is_static) pop_and_check_object(obj);
3331     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(
3332         field, rdx, SharedRuntime::tsan_write1, btos));
3333     __ access_store_at(T_BYTE, IN_HEAP, field, rax, noreg, noreg);
3334     if (!is_static &amp;&amp; rc == may_rewrite) {
3335       patch_bytecode(Bytecodes::_fast_bputfield, bc, rbx, true, byte_no);
3336     }
3337     __ jmp(Done);
3338   }
3339 
3340   __ bind(notByte);
3341   __ cmpl(flags, ztos);
3342   __ jcc(Assembler::notEqual, notBool);
3343 
3344   // ztos
3345   {
3346     __ pop(ztos);
3347     if (!is_static) pop_and_check_object(obj);
3348     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(
3349         field, rdx, SharedRuntime::tsan_write1, ztos));
3350     __ access_store_at(T_BOOLEAN, IN_HEAP, field, rax, noreg, noreg);
3351     if (!is_static &amp;&amp; rc == may_rewrite) {
3352       patch_bytecode(Bytecodes::_fast_zputfield, bc, rbx, true, byte_no);
3353     }
3354     __ jmp(Done);
3355   }
3356 
3357   __ bind(notBool);
3358   __ cmpl(flags, atos);
3359   __ jcc(Assembler::notEqual, notObj);
3360 
3361   // atos
3362   {
3363     __ pop(atos);
3364     if (!is_static) pop_and_check_object(obj);
3365     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, rdx,
3366         UseCompressedOops ? SharedRuntime::tsan_write4
3367                           : SharedRuntime::tsan_write8,
3368         atos));
3369     // Store into the field
3370     do_oop_store(_masm, field, rax);
3371     if (!is_static &amp;&amp; rc == may_rewrite) {
3372       patch_bytecode(Bytecodes::_fast_aputfield, bc, rbx, true, byte_no);
3373     }
3374     __ jmp(Done);
3375   }
3376 
3377   __ bind(notObj);
3378   __ cmpl(flags, itos);
3379   __ jcc(Assembler::notEqual, notInt);
3380 
3381   // itos
3382   {
3383     __ pop(itos);
3384     if (!is_static) pop_and_check_object(obj);
3385     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(
3386         field, rdx, SharedRuntime::tsan_write4, itos));
3387     __ access_store_at(T_INT, IN_HEAP, field, rax, noreg, noreg);
3388     if (!is_static &amp;&amp; rc == may_rewrite) {
3389       patch_bytecode(Bytecodes::_fast_iputfield, bc, rbx, true, byte_no);
3390     }
3391     __ jmp(Done);
3392   }
3393 
3394   __ bind(notInt);
3395   __ cmpl(flags, ctos);
3396   __ jcc(Assembler::notEqual, notChar);
3397 
3398   // ctos
3399   {
3400     __ pop(ctos);
3401     if (!is_static) pop_and_check_object(obj);
3402     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(
3403         field, rdx, SharedRuntime::tsan_write2, ctos));
3404     __ access_store_at(T_CHAR, IN_HEAP, field, rax, noreg, noreg);
3405     if (!is_static &amp;&amp; rc == may_rewrite) {
3406       patch_bytecode(Bytecodes::_fast_cputfield, bc, rbx, true, byte_no);
3407     }
3408     __ jmp(Done);
3409   }
3410 
3411   __ bind(notChar);
3412   __ cmpl(flags, stos);
3413   __ jcc(Assembler::notEqual, notShort);
3414 
3415   // stos
3416   {
3417     __ pop(stos);
3418     if (!is_static) pop_and_check_object(obj);
3419     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(
3420         field, rdx, SharedRuntime::tsan_write2, stos));
3421     __ access_store_at(T_SHORT, IN_HEAP, field, rax, noreg, noreg);
3422     if (!is_static &amp;&amp; rc == may_rewrite) {
3423       patch_bytecode(Bytecodes::_fast_sputfield, bc, rbx, true, byte_no);
3424     }
3425     __ jmp(Done);
3426   }
3427 
3428   __ bind(notShort);
3429   __ cmpl(flags, ltos);
3430   __ jcc(Assembler::notEqual, notLong);
3431 
3432   // ltos
3433   {
3434     __ pop(ltos);
3435     if (!is_static) pop_and_check_object(obj);
3436     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(
3437         field, rdx, SharedRuntime::tsan_write8, ltos));
3438     // MO_RELAXED: generate atomic store for the case of volatile field (important for x86_32)
3439     __ access_store_at(T_LONG, IN_HEAP | MO_RELAXED, field, noreg /* ltos*/, noreg, noreg);
3440 #ifdef _LP64
3441     if (!is_static &amp;&amp; rc == may_rewrite) {
3442       patch_bytecode(Bytecodes::_fast_lputfield, bc, rbx, true, byte_no);
3443     }
3444 #endif // _LP64
3445     __ jmp(Done);
3446   }
3447 
3448   __ bind(notLong);
3449   __ cmpl(flags, ftos);
3450   __ jcc(Assembler::notEqual, notFloat);
3451 
3452   // ftos
3453   {
3454     __ pop(ftos);
3455     if (!is_static) pop_and_check_object(obj);
3456     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(
3457         field, rdx, SharedRuntime::tsan_write4, ftos));
3458     __ access_store_at(T_FLOAT, IN_HEAP, field, noreg /* ftos */, noreg, noreg);
3459     if (!is_static &amp;&amp; rc == may_rewrite) {
3460       patch_bytecode(Bytecodes::_fast_fputfield, bc, rbx, true, byte_no);
3461     }
3462     __ jmp(Done);
3463   }
3464 
3465   __ bind(notFloat);
3466 #ifdef ASSERT
3467   Label notDouble;
3468   __ cmpl(flags, dtos);
3469   __ jcc(Assembler::notEqual, notDouble);
3470 #endif
3471 
3472   // dtos
3473   {
3474     __ pop(dtos);
3475     if (!is_static) pop_and_check_object(obj);
3476     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(
3477         field, rdx, SharedRuntime::tsan_write8, dtos));
3478     // MO_RELAXED: for the case of volatile field, in fact it adds no extra work for the underlying implementation
3479     __ access_store_at(T_DOUBLE, IN_HEAP | MO_RELAXED, field, noreg /* dtos */, noreg, noreg);
3480     if (!is_static &amp;&amp; rc == may_rewrite) {
3481       patch_bytecode(Bytecodes::_fast_dputfield, bc, rbx, true, byte_no);
3482     }
3483   }
3484 
3485 #ifdef ASSERT
3486   __ jmp(Done);
3487 
3488   __ bind(notDouble);
3489   __ stop(&quot;Bad state&quot;);
3490 #endif
3491 
3492   __ bind(Done);
3493 }
3494 
3495 void TemplateTable::putfield(int byte_no) {
3496   putfield_or_static(byte_no, false);
3497 }
3498 
3499 void TemplateTable::nofast_putfield(int byte_no) {
3500   putfield_or_static(byte_no, false, may_not_rewrite);
3501 }
3502 
3503 void TemplateTable::putstatic(int byte_no) {
3504   putfield_or_static(byte_no, true);
3505 }
3506 
3507 void TemplateTable::jvmti_post_fast_field_mod() {
3508 
3509   const Register scratch = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
3510 
3511   if (JvmtiExport::can_post_field_modification()) {
3512     // Check to see if a field modification watch has been set before
3513     // we take the time to call into the VM.
3514     Label L2;
3515     __ mov32(scratch, ExternalAddress((address)JvmtiExport::get_field_modification_count_addr()));
3516     __ testl(scratch, scratch);
3517     __ jcc(Assembler::zero, L2);
3518     __ pop_ptr(rbx);                  // copy the object pointer from tos
3519     __ verify_oop(rbx);
3520     __ push_ptr(rbx);                 // put the object pointer back on tos
3521     // Save tos values before call_VM() clobbers them. Since we have
3522     // to do it for every data type, we use the saved values as the
3523     // jvalue object.
3524     switch (bytecode()) {          // load values into the jvalue object
3525     case Bytecodes::_fast_aputfield: __ push_ptr(rax); break;
3526     case Bytecodes::_fast_bputfield: // fall through
3527     case Bytecodes::_fast_zputfield: // fall through
3528     case Bytecodes::_fast_sputfield: // fall through
3529     case Bytecodes::_fast_cputfield: // fall through
3530     case Bytecodes::_fast_iputfield: __ push_i(rax); break;
3531     case Bytecodes::_fast_dputfield: __ push(dtos); break;
3532     case Bytecodes::_fast_fputfield: __ push(ftos); break;
3533     case Bytecodes::_fast_lputfield: __ push_l(rax); break;
3534 
3535     default:
3536       ShouldNotReachHere();
3537     }
3538     __ mov(scratch, rsp);             // points to jvalue on the stack
3539     // access constant pool cache entry
3540     LP64_ONLY(__ get_cache_entry_pointer_at_bcp(c_rarg2, rax, 1));
3541     NOT_LP64(__ get_cache_entry_pointer_at_bcp(rax, rdx, 1));
3542     __ verify_oop(rbx);
3543     // rbx: object pointer copied above
3544     // c_rarg2: cache entry pointer
3545     // c_rarg3: jvalue object on the stack
3546     LP64_ONLY(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_modification), rbx, c_rarg2, c_rarg3));
3547     NOT_LP64(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_modification), rbx, rax, rcx));
3548 
3549     switch (bytecode()) {             // restore tos values
3550     case Bytecodes::_fast_aputfield: __ pop_ptr(rax); break;
3551     case Bytecodes::_fast_bputfield: // fall through
3552     case Bytecodes::_fast_zputfield: // fall through
3553     case Bytecodes::_fast_sputfield: // fall through
3554     case Bytecodes::_fast_cputfield: // fall through
3555     case Bytecodes::_fast_iputfield: __ pop_i(rax); break;
3556     case Bytecodes::_fast_dputfield: __ pop(dtos); break;
3557     case Bytecodes::_fast_fputfield: __ pop(ftos); break;
3558     case Bytecodes::_fast_lputfield: __ pop_l(rax); break;
3559     default: break;
3560     }
3561     __ bind(L2);
3562   }
3563 }
3564 
3565 void TemplateTable::fast_storefield(TosState state) {
3566   transition(state, vtos);
3567 
3568   ByteSize base = ConstantPoolCache::base_offset();
3569 
3570   jvmti_post_fast_field_mod();
3571 
3572   // access constant pool cache
3573   __ get_cache_and_index_at_bcp(rcx, rbx, 1);
3574 
3575   // test for volatile with rdx but rdx is tos register for lputfield.
3576   __ movl(rdx, Address(rcx, rbx, Address::times_ptr,
3577                        in_bytes(base +
3578                                 ConstantPoolCacheEntry::flags_offset())));
3579 
3580   // replace index with field offset from cache entry
3581   __ movptr(rbx, Address(rcx, rbx, Address::times_ptr,
3582                          in_bytes(base + ConstantPoolCacheEntry::f2_offset())));
3583 
3584   // [jk] not needed currently
3585   // volatile_barrier(Assembler::Membar_mask_bits(Assembler::LoadStore |
3586   //                                              Assembler::StoreStore));
3587 
3588   Label notVolatile, Done;
3589   __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);
3590   __ andl(rdx, 0x1);
3591 
3592   // Get object from stack
3593   pop_and_check_object(rcx);
3594 
3595   // field address
3596   const Address field(rcx, rbx, Address::times_1);
3597 
3598   // Check for volatile store
3599   __ testl(rdx, rdx);
3600   __ jcc(Assembler::zero, notVolatile);
3601 
3602   fast_storefield_helper(field, rax);
3603   volatile_barrier(Assembler::Membar_mask_bits(Assembler::StoreLoad |
3604                                                Assembler::StoreStore));
3605   __ jmp(Done);
3606   __ bind(notVolatile);
3607 
3608   fast_storefield_helper(field, rax);
3609 
3610   __ bind(Done);
3611 }
3612 
3613 void TemplateTable::fast_storefield_helper(Address field, Register rax) {
3614 
3615   // access field
3616   switch (bytecode()) {
3617   case Bytecodes::_fast_aputfield:
3618     do_oop_store(_masm, field, rax);
3619     break;
3620   case Bytecodes::_fast_lputfield:
3621 #ifdef _LP64
3622     __ access_store_at(T_LONG, IN_HEAP, field, noreg /* ltos */, noreg, noreg);
3623 #else
3624   __ stop(&quot;should not be rewritten&quot;);
3625 #endif
3626     break;
3627   case Bytecodes::_fast_iputfield:
3628     __ access_store_at(T_INT, IN_HEAP, field, rax, noreg, noreg);
3629     break;
3630   case Bytecodes::_fast_zputfield:
3631     __ access_store_at(T_BOOLEAN, IN_HEAP, field, rax, noreg, noreg);
3632     break;
3633   case Bytecodes::_fast_bputfield:
3634     __ access_store_at(T_BYTE, IN_HEAP, field, rax, noreg, noreg);
3635     break;
3636   case Bytecodes::_fast_sputfield:
3637     __ access_store_at(T_SHORT, IN_HEAP, field, rax, noreg, noreg);
3638     break;
3639   case Bytecodes::_fast_cputfield:
3640     __ access_store_at(T_CHAR, IN_HEAP, field, rax, noreg, noreg);
3641     break;
3642   case Bytecodes::_fast_fputfield:
3643     __ access_store_at(T_FLOAT, IN_HEAP, field, noreg /* ftos*/, noreg, noreg);
3644     break;
3645   case Bytecodes::_fast_dputfield:
3646     __ access_store_at(T_DOUBLE, IN_HEAP, field, noreg /* dtos*/, noreg, noreg);
3647     break;
3648   default:
3649     ShouldNotReachHere();
3650   }
3651 }
3652 
3653 void TemplateTable::fast_accessfield(TosState state) {
3654   transition(atos, state);
3655 
3656   // Do the JVMTI work here to avoid disturbing the register state below
3657   if (JvmtiExport::can_post_field_access()) {
3658     // Check to see if a field access watch has been set before we
3659     // take the time to call into the VM.
3660     Label L1;
3661     __ mov32(rcx, ExternalAddress((address) JvmtiExport::get_field_access_count_addr()));
3662     __ testl(rcx, rcx);
3663     __ jcc(Assembler::zero, L1);
3664     // access constant pool cache entry
3665     LP64_ONLY(__ get_cache_entry_pointer_at_bcp(c_rarg2, rcx, 1));
3666     NOT_LP64(__ get_cache_entry_pointer_at_bcp(rcx, rdx, 1));
3667     __ verify_oop(rax);
3668     __ push_ptr(rax);  // save object pointer before call_VM() clobbers it
3669     LP64_ONLY(__ mov(c_rarg1, rax));
3670     // c_rarg1: object pointer copied above
3671     // c_rarg2: cache entry pointer
3672     LP64_ONLY(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_access), c_rarg1, c_rarg2));
3673     NOT_LP64(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_access), rax, rcx));
3674     __ pop_ptr(rax); // restore object pointer
3675     __ bind(L1);
3676   }
3677 
3678   // access constant pool cache
3679   __ get_cache_and_index_at_bcp(rcx, rbx, 1);
3680   // replace index with field offset from cache entry
3681   // [jk] not needed currently
3682   // __ movl(rdx, Address(rcx, rbx, Address::times_8,
3683   //                      in_bytes(ConstantPoolCache::base_offset() +
3684   //                               ConstantPoolCacheEntry::flags_offset())));
3685   // __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);
3686   // __ andl(rdx, 0x1);
3687   //
3688   __ movptr(rbx, Address(rcx, rbx, Address::times_ptr,
3689                          in_bytes(ConstantPoolCache::base_offset() +
3690                                   ConstantPoolCacheEntry::f2_offset())));
3691 
3692   // rax: object
3693   __ verify_oop(rax);
3694   __ null_check(rax);
3695   Address field(rax, rbx, Address::times_1);
3696 
3697   // access field
3698   switch (bytecode()) {
3699   case Bytecodes::_fast_agetfield:
3700     do_oop_load(_masm, field, rax);
3701     __ verify_oop(rax);
3702     break;
3703   case Bytecodes::_fast_lgetfield:
3704 #ifdef _LP64
3705     __ access_load_at(T_LONG, IN_HEAP, noreg /* ltos */, field, noreg, noreg);
3706 #else
3707   __ stop(&quot;should not be rewritten&quot;);
3708 #endif
3709     break;
3710   case Bytecodes::_fast_igetfield:
3711     __ access_load_at(T_INT, IN_HEAP, rax, field, noreg, noreg);
3712     break;
3713   case Bytecodes::_fast_bgetfield:
3714     __ access_load_at(T_BYTE, IN_HEAP, rax, field, noreg, noreg);
3715     break;
3716   case Bytecodes::_fast_sgetfield:
3717     __ access_load_at(T_SHORT, IN_HEAP, rax, field, noreg, noreg);
3718     break;
3719   case Bytecodes::_fast_cgetfield:
3720     __ access_load_at(T_CHAR, IN_HEAP, rax, field, noreg, noreg);
3721     break;
3722   case Bytecodes::_fast_fgetfield:
3723     __ access_load_at(T_FLOAT, IN_HEAP, noreg /* ftos */, field, noreg, noreg);
3724     break;
3725   case Bytecodes::_fast_dgetfield:
3726     __ access_load_at(T_DOUBLE, IN_HEAP, noreg /* dtos */, field, noreg, noreg);
3727     break;
3728   default:
3729     ShouldNotReachHere();
3730   }
3731   // [jk] not needed currently
3732   //   Label notVolatile;
3733   //   __ testl(rdx, rdx);
3734   //   __ jcc(Assembler::zero, notVolatile);
3735   //   __ membar(Assembler::LoadLoad);
3736   //   __ bind(notVolatile);
3737 }
3738 
3739 void TemplateTable::fast_xaccess(TosState state) {
3740   transition(vtos, state);
3741 
3742   // get receiver
3743   __ movptr(rax, aaddress(0));
3744   // access constant pool cache
3745   __ get_cache_and_index_at_bcp(rcx, rdx, 2);
3746   __ movptr(rbx,
3747             Address(rcx, rdx, Address::times_ptr,
3748                     in_bytes(ConstantPoolCache::base_offset() +
3749                              ConstantPoolCacheEntry::f2_offset())));
3750   // make sure exception is reported in correct bcp range (getfield is
3751   // next instruction)
3752   __ increment(rbcp);
3753   __ null_check(rax);
3754   const Address field = Address(rax, rbx, Address::times_1, 0*wordSize);
3755   switch (state) {
3756   case itos:
3757     __ access_load_at(T_INT, IN_HEAP, rax, field, noreg, noreg);
3758     break;
3759   case atos:
3760     do_oop_load(_masm, field, rax);
3761     __ verify_oop(rax);
3762     break;
3763   case ftos:
3764     __ access_load_at(T_FLOAT, IN_HEAP, noreg /* ftos */, field, noreg, noreg);
3765     break;
3766   default:
3767     ShouldNotReachHere();
3768   }
3769 
3770   // [jk] not needed currently
3771   // Label notVolatile;
3772   // __ movl(rdx, Address(rcx, rdx, Address::times_8,
3773   //                      in_bytes(ConstantPoolCache::base_offset() +
3774   //                               ConstantPoolCacheEntry::flags_offset())));
3775   // __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);
3776   // __ testl(rdx, 0x1);
3777   // __ jcc(Assembler::zero, notVolatile);
3778   // __ membar(Assembler::LoadLoad);
3779   // __ bind(notVolatile);
3780 
3781   __ decrement(rbcp);
3782 }
3783 
3784 //-----------------------------------------------------------------------------
3785 // Calls
3786 
3787 void TemplateTable::count_calls(Register method, Register temp) {
3788   // implemented elsewhere
3789   ShouldNotReachHere();
3790 }
3791 
3792 void TemplateTable::prepare_invoke(int byte_no,
3793                                    Register method,  // linked method (or i-klass)
3794                                    Register index,   // itable index, MethodType, etc.
3795                                    Register recv,    // if caller wants to see it
3796                                    Register flags    // if caller wants to test it
3797                                    ) {
3798   // determine flags
3799   const Bytecodes::Code code = bytecode();
3800   const bool is_invokeinterface  = code == Bytecodes::_invokeinterface;
3801   const bool is_invokedynamic    = code == Bytecodes::_invokedynamic;
3802   const bool is_invokehandle     = code == Bytecodes::_invokehandle;
3803   const bool is_invokevirtual    = code == Bytecodes::_invokevirtual;
3804   const bool is_invokespecial    = code == Bytecodes::_invokespecial;
3805   const bool load_receiver       = (recv  != noreg);
3806   const bool save_flags          = (flags != noreg);
3807   assert(load_receiver == (code != Bytecodes::_invokestatic &amp;&amp; code != Bytecodes::_invokedynamic), &quot;&quot;);
3808   assert(save_flags    == (is_invokeinterface || is_invokevirtual), &quot;need flags for vfinal&quot;);
3809   assert(flags == noreg || flags == rdx, &quot;&quot;);
3810   assert(recv  == noreg || recv  == rcx, &quot;&quot;);
3811 
3812   // setup registers &amp; access constant pool cache
3813   if (recv  == noreg)  recv  = rcx;
3814   if (flags == noreg)  flags = rdx;
3815   assert_different_registers(method, index, recv, flags);
3816 
3817   // save &#39;interpreter return address&#39;
3818   __ save_bcp();
3819 
3820   load_invoke_cp_cache_entry(byte_no, method, index, flags, is_invokevirtual, false, is_invokedynamic);
3821 
3822   // maybe push appendix to arguments (just before return address)
3823   if (is_invokedynamic || is_invokehandle) {
3824     Label L_no_push;
3825     __ testl(flags, (1 &lt;&lt; ConstantPoolCacheEntry::has_appendix_shift));
3826     __ jcc(Assembler::zero, L_no_push);
3827     // Push the appendix as a trailing parameter.
3828     // This must be done before we get the receiver,
3829     // since the parameter_size includes it.
3830     __ push(rbx);
3831     __ mov(rbx, index);
3832     __ load_resolved_reference_at_index(index, rbx);
3833     __ pop(rbx);
3834     __ push(index);  // push appendix (MethodType, CallSite, etc.)
3835     __ bind(L_no_push);
3836   }
3837 
3838   // load receiver if needed (after appendix is pushed so parameter size is correct)
3839   // Note: no return address pushed yet
3840   if (load_receiver) {
3841     __ movl(recv, flags);
3842     __ andl(recv, ConstantPoolCacheEntry::parameter_size_mask);
3843     const int no_return_pc_pushed_yet = -1;  // argument slot correction before we push return address
3844     const int receiver_is_at_end      = -1;  // back off one slot to get receiver
3845     Address recv_addr = __ argument_address(recv, no_return_pc_pushed_yet + receiver_is_at_end);
3846     __ movptr(recv, recv_addr);
3847     __ verify_oop(recv);
3848   }
3849 
3850   if (save_flags) {
3851     __ movl(rbcp, flags);
3852   }
3853 
3854   // compute return type
3855   __ shrl(flags, ConstantPoolCacheEntry::tos_state_shift);
3856   // Make sure we don&#39;t need to mask flags after the above shift
3857   ConstantPoolCacheEntry::verify_tos_state_shift();
3858   // load return address
3859   {
3860     const address table_addr = (address) Interpreter::invoke_return_entry_table_for(code);
3861     ExternalAddress table(table_addr);
3862     LP64_ONLY(__ lea(rscratch1, table));
3863     LP64_ONLY(__ movptr(flags, Address(rscratch1, flags, Address::times_ptr)));
3864     NOT_LP64(__ movptr(flags, ArrayAddress(table, Address(noreg, flags, Address::times_ptr))));
3865   }
3866 
3867   // push return address
3868   __ push(flags);
3869 
3870   // Restore flags value from the constant pool cache, and restore rsi
3871   // for later null checks.  r13 is the bytecode pointer
3872   if (save_flags) {
3873     __ movl(flags, rbcp);
3874     __ restore_bcp();
3875   }
3876 }
3877 
3878 void TemplateTable::invokevirtual_helper(Register index,
3879                                          Register recv,
3880                                          Register flags) {
3881   // Uses temporary registers rax, rdx
3882   assert_different_registers(index, recv, rax, rdx);
3883   assert(index == rbx, &quot;&quot;);
3884   assert(recv  == rcx, &quot;&quot;);
3885 
3886   // Test for an invoke of a final method
3887   Label notFinal;
3888   __ movl(rax, flags);
3889   __ andl(rax, (1 &lt;&lt; ConstantPoolCacheEntry::is_vfinal_shift));
3890   __ jcc(Assembler::zero, notFinal);
3891 
3892   const Register method = index;  // method must be rbx
3893   assert(method == rbx,
3894          &quot;Method* must be rbx for interpreter calling convention&quot;);
3895 
3896   // do the call - the index is actually the method to call
3897   // that is, f2 is a vtable index if !is_vfinal, else f2 is a Method*
3898 
3899   // It&#39;s final, need a null check here!
3900   __ null_check(recv);
3901 
3902   // profile this call
3903   __ profile_final_call(rax);
3904   __ profile_arguments_type(rax, method, rbcp, true);
3905 
3906   __ jump_from_interpreted(method, rax);
3907 
3908   __ bind(notFinal);
3909 
3910   // get receiver klass
3911   __ null_check(recv, oopDesc::klass_offset_in_bytes());
3912   __ load_klass(rax, recv);
3913 
3914   // profile this call
3915   __ profile_virtual_call(rax, rlocals, rdx);
3916   // get target Method* &amp; entry point
3917   __ lookup_virtual_method(rax, index, method);
3918   __ profile_called_method(method, rdx, rbcp);
3919 
3920   __ profile_arguments_type(rdx, method, rbcp, true);
3921   __ jump_from_interpreted(method, rdx);
3922 }
3923 
3924 void TemplateTable::invokevirtual(int byte_no) {
3925   transition(vtos, vtos);
3926   assert(byte_no == f2_byte, &quot;use this argument&quot;);
3927   prepare_invoke(byte_no,
3928                  rbx,    // method or vtable index
3929                  noreg,  // unused itable index
3930                  rcx, rdx); // recv, flags
3931 
3932   // rbx: index
3933   // rcx: receiver
3934   // rdx: flags
3935 
3936   invokevirtual_helper(rbx, rcx, rdx);
3937 }
3938 
3939 void TemplateTable::invokespecial(int byte_no) {
3940   transition(vtos, vtos);
3941   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3942   prepare_invoke(byte_no, rbx, noreg,  // get f1 Method*
3943                  rcx);  // get receiver also for null check
3944   __ verify_oop(rcx);
3945   __ null_check(rcx);
3946   // do the call
3947   __ profile_call(rax);
3948   __ profile_arguments_type(rax, rbx, rbcp, false);
3949   __ jump_from_interpreted(rbx, rax);
3950 }
3951 
3952 void TemplateTable::invokestatic(int byte_no) {
3953   transition(vtos, vtos);
3954   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3955   prepare_invoke(byte_no, rbx);  // get f1 Method*
3956   // do the call
3957   __ profile_call(rax);
3958   __ profile_arguments_type(rax, rbx, rbcp, false);
3959   __ jump_from_interpreted(rbx, rax);
3960 }
3961 
3962 
3963 void TemplateTable::fast_invokevfinal(int byte_no) {
3964   transition(vtos, vtos);
3965   assert(byte_no == f2_byte, &quot;use this argument&quot;);
3966   __ stop(&quot;fast_invokevfinal not used on x86&quot;);
3967 }
3968 
3969 
3970 void TemplateTable::invokeinterface(int byte_no) {
3971   transition(vtos, vtos);
3972   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3973   prepare_invoke(byte_no, rax, rbx,  // get f1 Klass*, f2 Method*
3974                  rcx, rdx); // recv, flags
3975 
3976   // rax: reference klass (from f1) if interface method
3977   // rbx: method (from f2)
3978   // rcx: receiver
3979   // rdx: flags
3980 
3981   // First check for Object case, then private interface method,
3982   // then regular interface method.
3983 
3984   // Special case of invokeinterface called for virtual method of
3985   // java.lang.Object.  See cpCache.cpp for details.
3986   Label notObjectMethod;
3987   __ movl(rlocals, rdx);
3988   __ andl(rlocals, (1 &lt;&lt; ConstantPoolCacheEntry::is_forced_virtual_shift));
3989   __ jcc(Assembler::zero, notObjectMethod);
3990   invokevirtual_helper(rbx, rcx, rdx);
3991   // no return from above
3992   __ bind(notObjectMethod);
3993 
3994   Label no_such_interface; // for receiver subtype check
3995   Register recvKlass; // used for exception processing
3996 
3997   // Check for private method invocation - indicated by vfinal
3998   Label notVFinal;
3999   __ movl(rlocals, rdx);
4000   __ andl(rlocals, (1 &lt;&lt; ConstantPoolCacheEntry::is_vfinal_shift));
4001   __ jcc(Assembler::zero, notVFinal);
4002 
4003   // Get receiver klass into rlocals - also a null check
4004   __ null_check(rcx, oopDesc::klass_offset_in_bytes());
4005   __ load_klass(rlocals, rcx);
4006 
4007   Label subtype;
4008   __ check_klass_subtype(rlocals, rax, rbcp, subtype);
4009   // If we get here the typecheck failed
4010   recvKlass = rdx;
4011   __ mov(recvKlass, rlocals); // shuffle receiver class for exception use
4012   __ jmp(no_such_interface);
4013 
4014   __ bind(subtype);
4015 
4016   // do the call - rbx is actually the method to call
4017 
4018   __ profile_final_call(rdx);
4019   __ profile_arguments_type(rdx, rbx, rbcp, true);
4020 
4021   __ jump_from_interpreted(rbx, rdx);
4022   // no return from above
4023   __ bind(notVFinal);
4024 
4025   // Get receiver klass into rdx - also a null check
4026   __ restore_locals();  // restore r14
4027   __ null_check(rcx, oopDesc::klass_offset_in_bytes());
4028   __ load_klass(rdx, rcx);
4029 
4030   Label no_such_method;
4031 
4032   // Preserve method for throw_AbstractMethodErrorVerbose.
4033   __ mov(rcx, rbx);
4034   // Receiver subtype check against REFC.
4035   // Superklass in rax. Subklass in rdx. Blows rcx, rdi.
4036   __ lookup_interface_method(// inputs: rec. class, interface, itable index
4037                              rdx, rax, noreg,
4038                              // outputs: scan temp. reg, scan temp. reg
4039                              rbcp, rlocals,
4040                              no_such_interface,
4041                              /*return_method=*/false);
4042 
4043   // profile this call
4044   __ restore_bcp(); // rbcp was destroyed by receiver type check
4045   __ profile_virtual_call(rdx, rbcp, rlocals);
4046 
4047   // Get declaring interface class from method, and itable index
4048   __ load_method_holder(rax, rbx);
4049   __ movl(rbx, Address(rbx, Method::itable_index_offset()));
4050   __ subl(rbx, Method::itable_index_max);
4051   __ negl(rbx);
4052 
4053   // Preserve recvKlass for throw_AbstractMethodErrorVerbose.
4054   __ mov(rlocals, rdx);
4055   __ lookup_interface_method(// inputs: rec. class, interface, itable index
4056                              rlocals, rax, rbx,
4057                              // outputs: method, scan temp. reg
4058                              rbx, rbcp,
4059                              no_such_interface);
4060 
4061   // rbx: Method* to call
4062   // rcx: receiver
4063   // Check for abstract method error
4064   // Note: This should be done more efficiently via a throw_abstract_method_error
4065   //       interpreter entry point and a conditional jump to it in case of a null
4066   //       method.
4067   __ testptr(rbx, rbx);
4068   __ jcc(Assembler::zero, no_such_method);
4069 
4070   __ profile_called_method(rbx, rbcp, rdx);
4071   __ profile_arguments_type(rdx, rbx, rbcp, true);
4072 
4073   // do the call
4074   // rcx: receiver
4075   // rbx,: Method*
4076   __ jump_from_interpreted(rbx, rdx);
4077   __ should_not_reach_here();
4078 
4079   // exception handling code follows...
4080   // note: must restore interpreter registers to canonical
4081   //       state for exception handling to work correctly!
4082 
4083   __ bind(no_such_method);
4084   // throw exception
4085   __ pop(rbx);           // pop return address (pushed by prepare_invoke)
4086   __ restore_bcp();      // rbcp must be correct for exception handler   (was destroyed)
4087   __ restore_locals();   // make sure locals pointer is correct as well (was destroyed)
4088   // Pass arguments for generating a verbose error message.
4089 #ifdef _LP64
4090   recvKlass = c_rarg1;
4091   Register method    = c_rarg2;
4092   if (recvKlass != rdx) { __ movq(recvKlass, rdx); }
4093   if (method != rcx)    { __ movq(method, rcx);    }
4094 #else
4095   recvKlass = rdx;
4096   Register method    = rcx;
4097 #endif
4098   __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_AbstractMethodErrorVerbose),
4099              recvKlass, method);
4100   // The call_VM checks for exception, so we should never return here.
4101   __ should_not_reach_here();
4102 
4103   __ bind(no_such_interface);
4104   // throw exception
4105   __ pop(rbx);           // pop return address (pushed by prepare_invoke)
4106   __ restore_bcp();      // rbcp must be correct for exception handler   (was destroyed)
4107   __ restore_locals();   // make sure locals pointer is correct as well (was destroyed)
4108   // Pass arguments for generating a verbose error message.
4109   LP64_ONLY( if (recvKlass != rdx) { __ movq(recvKlass, rdx); } )
4110   __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_IncompatibleClassChangeErrorVerbose),
4111              recvKlass, rax);
4112   // the call_VM checks for exception, so we should never return here.
4113   __ should_not_reach_here();
4114 }
4115 
4116 void TemplateTable::invokehandle(int byte_no) {
4117   transition(vtos, vtos);
4118   assert(byte_no == f1_byte, &quot;use this argument&quot;);
4119   const Register rbx_method = rbx;
4120   const Register rax_mtype  = rax;
4121   const Register rcx_recv   = rcx;
4122   const Register rdx_flags  = rdx;
4123 
4124   prepare_invoke(byte_no, rbx_method, rax_mtype, rcx_recv);
4125   __ verify_method_ptr(rbx_method);
4126   __ verify_oop(rcx_recv);
4127   __ null_check(rcx_recv);
4128 
4129   // rax: MethodType object (from cpool-&gt;resolved_references[f1], if necessary)
4130   // rbx: MH.invokeExact_MT method (from f2)
4131 
4132   // Note:  rax_mtype is already pushed (if necessary) by prepare_invoke
4133 
4134   // FIXME: profile the LambdaForm also
4135   __ profile_final_call(rax);
4136   __ profile_arguments_type(rdx, rbx_method, rbcp, true);
4137 
4138   __ jump_from_interpreted(rbx_method, rdx);
4139 }
4140 
4141 void TemplateTable::invokedynamic(int byte_no) {
4142   transition(vtos, vtos);
4143   assert(byte_no == f1_byte, &quot;use this argument&quot;);
4144 
4145   const Register rbx_method   = rbx;
4146   const Register rax_callsite = rax;
4147 
4148   prepare_invoke(byte_no, rbx_method, rax_callsite);
4149 
4150   // rax: CallSite object (from cpool-&gt;resolved_references[f1])
4151   // rbx: MH.linkToCallSite method (from f2)
4152 
4153   // Note:  rax_callsite is already pushed by prepare_invoke
4154 
4155   // %%% should make a type profile for any invokedynamic that takes a ref argument
4156   // profile this call
4157   __ profile_call(rbcp);
4158   __ profile_arguments_type(rdx, rbx_method, rbcp, false);
4159 
4160   __ verify_oop(rax_callsite);
4161 
4162   __ jump_from_interpreted(rbx_method, rdx);
4163 }
4164 
4165 //-----------------------------------------------------------------------------
4166 // Allocation
4167 
4168 void TemplateTable::_new() {
4169   transition(vtos, atos);
4170   __ get_unsigned_2_byte_index_at_bcp(rdx, 1);
4171   Label slow_case;
4172   Label slow_case_no_pop;
4173   Label done;
4174   Label initialize_header;
4175   Label initialize_object;  // including clearing the fields
4176 
4177   __ get_cpool_and_tags(rcx, rax);
4178 
4179   // Make sure the class we&#39;re about to instantiate has been resolved.
4180   // This is done before loading InstanceKlass to be consistent with the order
4181   // how Constant Pool is updated (see ConstantPool::klass_at_put)
4182   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
4183   __ cmpb(Address(rax, rdx, Address::times_1, tags_offset), JVM_CONSTANT_Class);
4184   __ jcc(Assembler::notEqual, slow_case_no_pop);
4185 
4186   // get InstanceKlass
4187   __ load_resolved_klass_at_index(rcx, rcx, rdx);
4188   __ push(rcx);  // save the contexts of klass for initializing the header
4189 
4190   // make sure klass is initialized &amp; doesn&#39;t have finalizer
4191   // make sure klass is fully initialized
4192   __ cmpb(Address(rcx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
4193   __ jcc(Assembler::notEqual, slow_case);
4194 
4195   // get instance_size in InstanceKlass (scaled to a count of bytes)
4196   __ movl(rdx, Address(rcx, Klass::layout_helper_offset()));
4197   // test to see if it has a finalizer or is malformed in some way
4198   __ testl(rdx, Klass::_lh_instance_slow_path_bit);
4199   __ jcc(Assembler::notZero, slow_case);
4200 
4201   // Allocate the instance:
4202   //  If TLAB is enabled:
4203   //    Try to allocate in the TLAB.
4204   //    If fails, go to the slow path.
4205   //  Else If inline contiguous allocations are enabled:
4206   //    Try to allocate in eden.
4207   //    If fails due to heap end, go to slow path.
4208   //
4209   //  If TLAB is enabled OR inline contiguous is enabled:
4210   //    Initialize the allocation.
4211   //    Exit.
4212   //
4213   //  Go to slow path.
4214 
4215   const bool allow_shared_alloc =
4216     Universe::heap()-&gt;supports_inline_contig_alloc();
4217 
4218   const Register thread = LP64_ONLY(r15_thread) NOT_LP64(rcx);
4219 #ifndef _LP64
4220   if (UseTLAB || allow_shared_alloc) {
4221     __ get_thread(thread);
4222   }
4223 #endif // _LP64
4224 
4225   if (UseTLAB) {
4226     __ tlab_allocate(thread, rax, rdx, 0, rcx, rbx, slow_case);
4227     if (ZeroTLAB) {
4228       // the fields have been already cleared
4229       __ jmp(initialize_header);
4230     } else {
4231       // initialize both the header and fields
4232       __ jmp(initialize_object);
4233     }
4234   } else {
4235     // Allocation in the shared Eden, if allowed.
4236     //
4237     // rdx: instance size in bytes
4238     __ eden_allocate(thread, rax, rdx, 0, rbx, slow_case);
4239   }
4240 
4241   // If UseTLAB or allow_shared_alloc are true, the object is created above and
4242   // there is an initialize need. Otherwise, skip and go to the slow path.
4243   if (UseTLAB || allow_shared_alloc) {
4244     // The object is initialized before the header.  If the object size is
4245     // zero, go directly to the header initialization.
4246     __ bind(initialize_object);
4247     __ decrement(rdx, sizeof(oopDesc));
4248     __ jcc(Assembler::zero, initialize_header);
4249 
4250     // Initialize topmost object field, divide rdx by 8, check if odd and
4251     // test if zero.
4252     __ xorl(rcx, rcx);    // use zero reg to clear memory (shorter code)
4253     __ shrl(rdx, LogBytesPerLong); // divide by 2*oopSize and set carry flag if odd
4254 
4255     // rdx must have been multiple of 8
4256 #ifdef ASSERT
4257     // make sure rdx was multiple of 8
4258     Label L;
4259     // Ignore partial flag stall after shrl() since it is debug VM
4260     __ jcc(Assembler::carryClear, L);
4261     __ stop(&quot;object size is not multiple of 2 - adjust this code&quot;);
4262     __ bind(L);
4263     // rdx must be &gt; 0, no extra check needed here
4264 #endif
4265 
4266     // initialize remaining object fields: rdx was a multiple of 8
4267     { Label loop;
4268     __ bind(loop);
4269     __ movptr(Address(rax, rdx, Address::times_8, sizeof(oopDesc) - 1*oopSize), rcx);
4270     NOT_LP64(__ movptr(Address(rax, rdx, Address::times_8, sizeof(oopDesc) - 2*oopSize), rcx));
4271     __ decrement(rdx);
4272     __ jcc(Assembler::notZero, loop);
4273     }
4274 
4275     // initialize object header only.
4276     __ bind(initialize_header);
4277     if (UseBiasedLocking) {
4278       __ pop(rcx);   // get saved klass back in the register.
4279       __ movptr(rbx, Address(rcx, Klass::prototype_header_offset()));
4280       __ movptr(Address(rax, oopDesc::mark_offset_in_bytes ()), rbx);
4281     } else {
4282       __ movptr(Address(rax, oopDesc::mark_offset_in_bytes ()),
4283                 (intptr_t)markWord::prototype().value()); // header
4284       __ pop(rcx);   // get saved klass back in the register.
4285     }
4286 #ifdef _LP64
4287     __ xorl(rsi, rsi); // use zero reg to clear memory (shorter code)
4288     __ store_klass_gap(rax, rsi);  // zero klass gap for compressed oops
4289 #endif
4290     __ store_klass(rax, rcx);  // klass
4291 
4292     {
4293       SkipIfEqual skip_if(_masm, &amp;DTraceAllocProbes, 0);
4294       // Trigger dtrace event for fastpath
4295       __ push(atos);
4296       __ call_VM_leaf(
4297            CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc), rax);
4298       __ pop(atos);
4299     }
4300 
4301     TSAN_RUNTIME_ONLY(
4302       // return value of new oop is in rax.
4303       __ push(atos);
4304       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::tsan_track_obj),
4305                       rax);
4306       __ pop(atos);
4307     );
4308 
4309     __ jmp(done);
4310   }
4311 
4312   // slow case
4313   __ bind(slow_case);
4314   __ pop(rcx);   // restore stack pointer to what it was when we came in.
4315   __ bind(slow_case_no_pop);
4316 
4317   Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rax);
4318   Register rarg2 = LP64_ONLY(c_rarg2) NOT_LP64(rdx);
4319 
4320   __ get_constant_pool(rarg1);
4321   __ get_unsigned_2_byte_index_at_bcp(rarg2, 1);
4322   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), rarg1, rarg2);
4323    __ verify_oop(rax);
4324 
4325   // continue
4326   __ bind(done);
4327 }
4328 
4329 void TemplateTable::newarray() {
4330   transition(itos, atos);
4331   Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rdx);
4332   __ load_unsigned_byte(rarg1, at_bcp(1));
4333   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::newarray),
4334           rarg1, rax);
4335 }
4336 
4337 void TemplateTable::anewarray() {
4338   transition(itos, atos);
4339 
4340   Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rcx);
4341   Register rarg2 = LP64_ONLY(c_rarg2) NOT_LP64(rdx);
4342 
4343   __ get_unsigned_2_byte_index_at_bcp(rarg2, 1);
4344   __ get_constant_pool(rarg1);
4345   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::anewarray),
4346           rarg1, rarg2, rax);
4347 }
4348 
4349 void TemplateTable::arraylength() {
4350   transition(atos, itos);
4351   __ null_check(rax, arrayOopDesc::length_offset_in_bytes());
4352   __ movl(rax, Address(rax, arrayOopDesc::length_offset_in_bytes()));
4353 }
4354 
4355 void TemplateTable::checkcast() {
4356   transition(atos, atos);
4357   Label done, is_null, ok_is_subtype, quicked, resolved;
4358   __ testptr(rax, rax); // object is in rax
4359   __ jcc(Assembler::zero, is_null);
4360 
4361   // Get cpool &amp; tags index
4362   __ get_cpool_and_tags(rcx, rdx); // rcx=cpool, rdx=tags array
4363   __ get_unsigned_2_byte_index_at_bcp(rbx, 1); // rbx=index
4364   // See if bytecode has already been quicked
4365   __ cmpb(Address(rdx, rbx,
4366                   Address::times_1,
4367                   Array&lt;u1&gt;::base_offset_in_bytes()),
4368           JVM_CONSTANT_Class);
4369   __ jcc(Assembler::equal, quicked);
4370   __ push(atos); // save receiver for result, and for GC
4371   call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
4372 
4373   // vm_result_2 has metadata result
4374 #ifndef _LP64
4375   // borrow rdi from locals
4376   __ get_thread(rdi);
4377   __ get_vm_result_2(rax, rdi);
4378   __ restore_locals();
4379 #else
4380   __ get_vm_result_2(rax, r15_thread);
4381 #endif
4382 
4383   __ pop_ptr(rdx); // restore receiver
4384   __ jmpb(resolved);
4385 
4386   // Get superklass in rax and subklass in rbx
4387   __ bind(quicked);
4388   __ mov(rdx, rax); // Save object in rdx; rax needed for subtype check
4389   __ load_resolved_klass_at_index(rax, rcx, rbx);
4390 
4391   __ bind(resolved);
4392   __ load_klass(rbx, rdx);
4393 
4394   // Generate subtype check.  Blows rcx, rdi.  Object in rdx.
4395   // Superklass in rax.  Subklass in rbx.
4396   __ gen_subtype_check(rbx, ok_is_subtype);
4397 
4398   // Come here on failure
4399   __ push_ptr(rdx);
4400   // object is at TOS
4401   __ jump(ExternalAddress(Interpreter::_throw_ClassCastException_entry));
4402 
4403   // Come here on success
4404   __ bind(ok_is_subtype);
4405   __ mov(rax, rdx); // Restore object in rdx
4406 
4407   // Collect counts on whether this check-cast sees NULLs a lot or not.
4408   if (ProfileInterpreter) {
4409     __ jmp(done);
4410     __ bind(is_null);
4411     __ profile_null_seen(rcx);
4412   } else {
4413     __ bind(is_null);   // same as &#39;done&#39;
4414   }
4415   __ bind(done);
4416 }
4417 
4418 void TemplateTable::instanceof() {
4419   transition(atos, itos);
4420   Label done, is_null, ok_is_subtype, quicked, resolved;
4421   __ testptr(rax, rax);
4422   __ jcc(Assembler::zero, is_null);
4423 
4424   // Get cpool &amp; tags index
4425   __ get_cpool_and_tags(rcx, rdx); // rcx=cpool, rdx=tags array
4426   __ get_unsigned_2_byte_index_at_bcp(rbx, 1); // rbx=index
4427   // See if bytecode has already been quicked
4428   __ cmpb(Address(rdx, rbx,
4429                   Address::times_1,
4430                   Array&lt;u1&gt;::base_offset_in_bytes()),
4431           JVM_CONSTANT_Class);
4432   __ jcc(Assembler::equal, quicked);
4433 
4434   __ push(atos); // save receiver for result, and for GC
4435   call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
4436   // vm_result_2 has metadata result
4437 
4438 #ifndef _LP64
4439   // borrow rdi from locals
4440   __ get_thread(rdi);
4441   __ get_vm_result_2(rax, rdi);
4442   __ restore_locals();
4443 #else
4444   __ get_vm_result_2(rax, r15_thread);
4445 #endif
4446 
4447   __ pop_ptr(rdx); // restore receiver
4448   __ verify_oop(rdx);
4449   __ load_klass(rdx, rdx);
4450   __ jmpb(resolved);
4451 
4452   // Get superklass in rax and subklass in rdx
4453   __ bind(quicked);
4454   __ load_klass(rdx, rax);
4455   __ load_resolved_klass_at_index(rax, rcx, rbx);
4456 
4457   __ bind(resolved);
4458 
4459   // Generate subtype check.  Blows rcx, rdi
4460   // Superklass in rax.  Subklass in rdx.
4461   __ gen_subtype_check(rdx, ok_is_subtype);
4462 
4463   // Come here on failure
4464   __ xorl(rax, rax);
4465   __ jmpb(done);
4466   // Come here on success
4467   __ bind(ok_is_subtype);
4468   __ movl(rax, 1);
4469 
4470   // Collect counts on whether this test sees NULLs a lot or not.
4471   if (ProfileInterpreter) {
4472     __ jmp(done);
4473     __ bind(is_null);
4474     __ profile_null_seen(rcx);
4475   } else {
4476     __ bind(is_null);   // same as &#39;done&#39;
4477   }
4478   __ bind(done);
4479   // rax = 0: obj == NULL or  obj is not an instanceof the specified klass
4480   // rax = 1: obj != NULL and obj is     an instanceof the specified klass
4481 }
4482 
4483 
4484 //----------------------------------------------------------------------------------------------------
4485 // Breakpoints
4486 void TemplateTable::_breakpoint() {
4487   // Note: We get here even if we are single stepping..
4488   // jbug insists on setting breakpoints at every bytecode
4489   // even if we are in single step mode.
4490 
4491   transition(vtos, vtos);
4492 
4493   Register rarg = LP64_ONLY(c_rarg1) NOT_LP64(rcx);
4494 
4495   // get the unpatched byte code
4496   __ get_method(rarg);
4497   __ call_VM(noreg,
4498              CAST_FROM_FN_PTR(address,
4499                               InterpreterRuntime::get_original_bytecode_at),
4500              rarg, rbcp);
4501   __ mov(rbx, rax);  // why?
4502 
4503   // post the breakpoint event
4504   __ get_method(rarg);
4505   __ call_VM(noreg,
4506              CAST_FROM_FN_PTR(address, InterpreterRuntime::_breakpoint),
4507              rarg, rbcp);
4508 
4509   // complete the execution of original bytecode
4510   __ dispatch_only_normal(vtos);
4511 }
4512 
4513 //-----------------------------------------------------------------------------
4514 // Exceptions
4515 
4516 void TemplateTable::athrow() {
4517   transition(atos, vtos);
4518   __ null_check(rax);
4519   __ jump(ExternalAddress(Interpreter::throw_exception_entry()));
4520 }
4521 
4522 //-----------------------------------------------------------------------------
4523 // Synchronization
4524 //
4525 // Note: monitorenter &amp; exit are symmetric routines; which is reflected
4526 //       in the assembly code structure as well
4527 //
4528 // Stack layout:
4529 //
4530 // [expressions  ] &lt;--- rsp               = expression stack top
4531 // ..
4532 // [expressions  ]
4533 // [monitor entry] &lt;--- monitor block top = expression stack bot
4534 // ..
4535 // [monitor entry]
4536 // [frame data   ] &lt;--- monitor block bot
4537 // ...
4538 // [saved rbp    ] &lt;--- rbp
4539 void TemplateTable::monitorenter() {
4540   transition(atos, vtos);
4541 
4542   // check for NULL object
4543   __ null_check(rax);
4544 
4545   __ resolve(IS_NOT_NULL, rax);
4546 
4547   const Address monitor_block_top(
4548         rbp, frame::interpreter_frame_monitor_block_top_offset * wordSize);
4549   const Address monitor_block_bot(
4550         rbp, frame::interpreter_frame_initial_sp_offset * wordSize);
4551   const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
4552 
4553   Label allocated;
4554 
4555   Register rtop = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
4556   Register rbot = LP64_ONLY(c_rarg2) NOT_LP64(rbx);
4557   Register rmon = LP64_ONLY(c_rarg1) NOT_LP64(rdx);
4558 
4559   // initialize entry pointer
4560   __ xorl(rmon, rmon); // points to free slot or NULL
4561 
4562   // find a free slot in the monitor block (result in rmon)
4563   {
4564     Label entry, loop, exit;
4565     __ movptr(rtop, monitor_block_top); // points to current entry,
4566                                         // starting with top-most entry
4567     __ lea(rbot, monitor_block_bot);    // points to word before bottom
4568                                         // of monitor block
4569     __ jmpb(entry);
4570 
4571     __ bind(loop);
4572     // check if current entry is used
4573     __ cmpptr(Address(rtop, BasicObjectLock::obj_offset_in_bytes()), (int32_t) NULL_WORD);
4574     // if not used then remember entry in rmon
4575     __ cmovptr(Assembler::equal, rmon, rtop);   // cmov =&gt; cmovptr
4576     // check if current entry is for same object
4577     __ cmpptr(rax, Address(rtop, BasicObjectLock::obj_offset_in_bytes()));
4578     // if same object then stop searching
4579     __ jccb(Assembler::equal, exit);
4580     // otherwise advance to next entry
4581     __ addptr(rtop, entry_size);
4582     __ bind(entry);
4583     // check if bottom reached
4584     __ cmpptr(rtop, rbot);
4585     // if not at bottom then check this entry
4586     __ jcc(Assembler::notEqual, loop);
4587     __ bind(exit);
4588   }
4589 
4590   __ testptr(rmon, rmon); // check if a slot has been found
4591   __ jcc(Assembler::notZero, allocated); // if found, continue with that one
4592 
4593   // allocate one if there&#39;s no free slot
4594   {
4595     Label entry, loop;
4596     // 1. compute new pointers          // rsp: old expression stack top
4597     __ movptr(rmon, monitor_block_bot); // rmon: old expression stack bottom
4598     __ subptr(rsp, entry_size);         // move expression stack top
4599     __ subptr(rmon, entry_size);        // move expression stack bottom
4600     __ mov(rtop, rsp);                  // set start value for copy loop
4601     __ movptr(monitor_block_bot, rmon); // set new monitor block bottom
4602     __ jmp(entry);
4603     // 2. move expression stack contents
4604     __ bind(loop);
4605     __ movptr(rbot, Address(rtop, entry_size)); // load expression stack
4606                                                 // word from old location
4607     __ movptr(Address(rtop, 0), rbot);          // and store it at new location
4608     __ addptr(rtop, wordSize);                  // advance to next word
4609     __ bind(entry);
4610     __ cmpptr(rtop, rmon);                      // check if bottom reached
4611     __ jcc(Assembler::notEqual, loop);          // if not at bottom then
4612                                                 // copy next word
4613   }
4614 
4615   // call run-time routine
4616   // rmon: points to monitor entry
4617   __ bind(allocated);
4618 
4619   // Increment bcp to point to the next bytecode, so exception
4620   // handling for async. exceptions work correctly.
4621   // The object has already been poped from the stack, so the
4622   // expression stack looks correct.
4623   __ increment(rbcp);
4624 
4625   // store object
4626   __ movptr(Address(rmon, BasicObjectLock::obj_offset_in_bytes()), rax);
4627   __ lock_object(rmon);
4628 
4629   // check to make sure this monitor doesn&#39;t cause stack overflow after locking
4630   __ save_bcp();  // in case of exception
4631   __ generate_stack_overflow_check(0);
4632 
4633   // The bcp has already been incremented. Just need to dispatch to
4634   // next instruction.
4635   __ dispatch_next(vtos);
4636 }
4637 
4638 void TemplateTable::monitorexit() {
4639   transition(atos, vtos);
4640 
4641   // check for NULL object
4642   __ null_check(rax);
4643 
4644   __ resolve(IS_NOT_NULL, rax);
4645 
4646   const Address monitor_block_top(
4647         rbp, frame::interpreter_frame_monitor_block_top_offset * wordSize);
4648   const Address monitor_block_bot(
4649         rbp, frame::interpreter_frame_initial_sp_offset * wordSize);
4650   const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
4651 
4652   Register rtop = LP64_ONLY(c_rarg1) NOT_LP64(rdx);
4653   Register rbot = LP64_ONLY(c_rarg2) NOT_LP64(rbx);
4654 
4655   Label found;
4656 
4657   // find matching slot
4658   {
4659     Label entry, loop;
4660     __ movptr(rtop, monitor_block_top); // points to current entry,
4661                                         // starting with top-most entry
4662     __ lea(rbot, monitor_block_bot);    // points to word before bottom
4663                                         // of monitor block
4664     __ jmpb(entry);
4665 
4666     __ bind(loop);
4667     // check if current entry is for same object
4668     __ cmpptr(rax, Address(rtop, BasicObjectLock::obj_offset_in_bytes()));
4669     // if same object then stop searching
4670     __ jcc(Assembler::equal, found);
4671     // otherwise advance to next entry
4672     __ addptr(rtop, entry_size);
4673     __ bind(entry);
4674     // check if bottom reached
4675     __ cmpptr(rtop, rbot);
4676     // if not at bottom then check this entry
4677     __ jcc(Assembler::notEqual, loop);
4678   }
4679 
4680   // error handling. Unlocking was not block-structured
4681   __ call_VM(noreg, CAST_FROM_FN_PTR(address,
4682                    InterpreterRuntime::throw_illegal_monitor_state_exception));
4683   __ should_not_reach_here();
4684 
4685   // call run-time routine
4686   __ bind(found);
4687   __ push_ptr(rax); // make sure object is on stack (contract with oopMaps)
4688   __ unlock_object(rtop);
4689   __ pop_ptr(rax); // discard object
4690 }
4691 
4692 // Wide instructions
4693 void TemplateTable::wide() {
4694   transition(vtos, vtos);
4695   __ load_unsigned_byte(rbx, at_bcp(1));
4696   ExternalAddress wtable((address)Interpreter::_wentry_point);
4697   __ jump(ArrayAddress(wtable, Address(noreg, rbx, Address::times_ptr)));
4698   // Note: the rbcp increment step is part of the individual wide bytecode implementations
4699 }
4700 
4701 // Multi arrays
4702 void TemplateTable::multianewarray() {
4703   transition(vtos, atos);
4704 
4705   Register rarg = LP64_ONLY(c_rarg1) NOT_LP64(rax);
4706   __ load_unsigned_byte(rax, at_bcp(3)); // get number of dimensions
4707   // last dim is on top of stack; we want address of first one:
4708   // first_addr = last_addr + (ndims - 1) * stackElementSize - 1*wordsize
4709   // the latter wordSize to point to the beginning of the array.
4710   __ lea(rarg, Address(rsp, rax, Interpreter::stackElementScale(), -wordSize));
4711   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::multianewarray), rarg);
4712   __ load_unsigned_byte(rbx, at_bcp(3));
4713   __ lea(rsp, Address(rsp, rbx, Interpreter::stackElementScale()));  // get rid of counts
4714 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/include/jvm.h</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #ifndef _JAVASOFT_JVM_H_
  27 #define _JAVASOFT_JVM_H_
  28 
  29 #include &lt;sys/stat.h&gt;
  30 
  31 #include &quot;jni.h&quot;
  32 #include &quot;jvm_md.h&quot;
  33 
  34 #ifdef __cplusplus
  35 extern &quot;C&quot; {
  36 #endif
  37 
  38 /*
  39  * This file contains additional functions exported from the VM.
  40  * These functions are complementary to the standard JNI support.
  41  * There are three parts to this file:
  42  *
  43  * First, this file contains the VM-related functions needed by native
  44  * libraries in the standard Java API. For example, the java.lang.Object
  45  * class needs VM-level functions that wait for and notify monitors.
  46  *
  47  * Second, this file contains the functions and constant definitions
  48  * needed by the byte code verifier and class file format checker.
  49  * These functions allow the verifier and format checker to be written
  50  * in a VM-independent way.
  51  *
  52  * Third, this file contains various I/O and network operations needed
  53  * by the standard Java I/O and network APIs.
  54  */
  55 
  56 /*
  57  * Bump the version number when either of the following happens:
  58  *
  59  * 1. There is a change in JVM_* functions.
  60  *
  61  * 2. There is a change in the contract between VM and Java classes.
  62  *    For example, if the VM relies on a new private field in Thread
  63  *    class.
  64  */
  65 
  66 #define JVM_INTERFACE_VERSION 6
  67 
  68 JNIEXPORT jint JNICALL
  69 JVM_GetInterfaceVersion(void);
  70 
  71 /*************************************************************************
  72  PART 1: Functions for Native Libraries
  73  ************************************************************************/
  74 /*
  75  * java.lang.Object
  76  */
  77 JNIEXPORT jint JNICALL
  78 JVM_IHashCode(JNIEnv *env, jobject obj);
  79 
  80 JNIEXPORT void JNICALL
  81 JVM_MonitorWait(JNIEnv *env, jobject obj, jlong ms);
  82 
  83 JNIEXPORT void JNICALL
  84 JVM_MonitorNotify(JNIEnv *env, jobject obj);
  85 
  86 JNIEXPORT void JNICALL
  87 JVM_MonitorNotifyAll(JNIEnv *env, jobject obj);
  88 
  89 JNIEXPORT jobject JNICALL
  90 JVM_Clone(JNIEnv *env, jobject obj);
  91 
  92 /*
  93  * java.lang.String
  94  */
  95 JNIEXPORT jstring JNICALL
  96 JVM_InternString(JNIEnv *env, jstring str);
  97 
  98 /*
  99  * java.lang.System
 100  */
 101 JNIEXPORT jlong JNICALL
 102 JVM_CurrentTimeMillis(JNIEnv *env, jclass ignored);
 103 
 104 JNIEXPORT jlong JNICALL
 105 JVM_NanoTime(JNIEnv *env, jclass ignored);
 106 
 107 JNIEXPORT jlong JNICALL
 108 JVM_GetNanoTimeAdjustment(JNIEnv *env, jclass ignored, jlong offset_secs);
 109 
 110 JNIEXPORT void JNICALL
 111 JVM_ArrayCopy(JNIEnv *env, jclass ignored, jobject src, jint src_pos,
 112               jobject dst, jint dst_pos, jint length);
 113 
 114 /*
 115  * Return an array of all properties as alternating name and value pairs.
 116  */
 117 JNIEXPORT jobjectArray JNICALL
 118 JVM_GetProperties(JNIEnv *env);
 119 
 120 /*
 121  * java.lang.Runtime
 122  */
 123 JNIEXPORT void JNICALL
 124 JVM_BeforeHalt();
 125 
 126 JNIEXPORT void JNICALL
 127 JVM_Halt(jint code);
 128 
 129 JNIEXPORT void JNICALL
 130 JVM_GC(void);
 131 
 132 /* Returns the number of real-time milliseconds that have elapsed since the
 133  * least-recently-inspected heap object was last inspected by the garbage
 134  * collector.
 135  *
 136  * For simple stop-the-world collectors this value is just the time
 137  * since the most recent collection.  For generational collectors it is the
 138  * time since the oldest generation was most recently collected.  Other
 139  * collectors are free to return a pessimistic estimate of the elapsed time, or
 140  * simply the time since the last full collection was performed.
 141  *
 142  * Note that in the presence of reference objects, a given object that is no
 143  * longer strongly reachable may have to be inspected multiple times before it
 144  * can be reclaimed.
 145  */
 146 JNIEXPORT jlong JNICALL
 147 JVM_MaxObjectInspectionAge(void);
 148 
 149 JNIEXPORT jlong JNICALL
 150 JVM_TotalMemory(void);
 151 
 152 JNIEXPORT jlong JNICALL
 153 JVM_FreeMemory(void);
 154 
 155 JNIEXPORT jlong JNICALL
 156 JVM_MaxMemory(void);
 157 
 158 JNIEXPORT jint JNICALL
 159 JVM_ActiveProcessorCount(void);
 160 
 161 JNIEXPORT void * JNICALL
 162 JVM_LoadLibrary(const char *name);
 163 
 164 JNIEXPORT void JNICALL
 165 JVM_UnloadLibrary(void * handle);
 166 
 167 JNIEXPORT void * JNICALL
 168 JVM_FindLibraryEntry(void *handle, const char *name);
 169 
 170 JNIEXPORT jboolean JNICALL
 171 JVM_IsSupportedJNIVersion(jint version);
 172 
 173 JNIEXPORT jobjectArray JNICALL
 174 JVM_GetVmArguments(JNIEnv *env);
 175 
 176 JNIEXPORT void JNICALL
 177 JVM_InitializeFromArchive(JNIEnv* env, jclass cls);
 178 
 179 /*
 180  * java.lang.Throwable
 181  */
 182 JNIEXPORT void JNICALL
 183 JVM_FillInStackTrace(JNIEnv *env, jobject throwable);
 184 
 185 /*
 186  * java.lang.StackTraceElement
 187  */
 188 JNIEXPORT void JNICALL
 189 JVM_InitStackTraceElementArray(JNIEnv *env, jobjectArray elements, jobject throwable);
 190 
 191 JNIEXPORT void JNICALL
 192 JVM_InitStackTraceElement(JNIEnv* env, jobject element, jobject stackFrameInfo);
 193 
 194 /*
 195  * java.lang.NullPointerException
 196  */
 197 
 198 JNIEXPORT jstring JNICALL
 199 JVM_GetExtendedNPEMessage(JNIEnv *env, jthrowable throwable);
 200 
 201 /*
 202  * java.lang.StackWalker
 203  */
 204 enum {
 205   JVM_STACKWALK_FILL_CLASS_REFS_ONLY       = 0x2,
 206   JVM_STACKWALK_GET_CALLER_CLASS           = 0x04,
 207   JVM_STACKWALK_SHOW_HIDDEN_FRAMES         = 0x20,
 208   JVM_STACKWALK_FILL_LIVE_STACK_FRAMES     = 0x100
 209 };
 210 
 211 JNIEXPORT jobject JNICALL
 212 JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jlong mode,
 213                   jint skip_frames, jint frame_count, jint start_index,
 214                   jobjectArray frames);
 215 
 216 JNIEXPORT jint JNICALL
 217 JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jlong mode, jlong anchor,
 218                   jint frame_count, jint start_index,
 219                   jobjectArray frames);
 220 
 221 /*
 222  * java.lang.Thread
 223  */
 224 JNIEXPORT void JNICALL
 225 JVM_StartThread(JNIEnv *env, jobject thread);
 226 
 227 JNIEXPORT void JNICALL
 228 JVM_StopThread(JNIEnv *env, jobject thread, jobject exception);
 229 
 230 JNIEXPORT jboolean JNICALL
 231 JVM_IsThreadAlive(JNIEnv *env, jobject thread);
 232 
 233 JNIEXPORT void JNICALL
 234 JVM_SuspendThread(JNIEnv *env, jobject thread);
 235 
 236 JNIEXPORT void JNICALL
 237 JVM_ResumeThread(JNIEnv *env, jobject thread);
 238 
 239 JNIEXPORT void JNICALL
 240 JVM_SetThreadPriority(JNIEnv *env, jobject thread, jint prio);
 241 
 242 JNIEXPORT void JNICALL
 243 JVM_Yield(JNIEnv *env, jclass threadClass);
 244 
 245 JNIEXPORT void JNICALL
 246 JVM_Sleep(JNIEnv *env, jclass threadClass, jlong millis);
 247 
 248 JNIEXPORT jobject JNICALL
 249 JVM_CurrentThread(JNIEnv *env, jclass threadClass);
 250 
 251 JNIEXPORT void JNICALL
 252 JVM_Interrupt(JNIEnv *env, jobject thread);
 253 
 254 JNIEXPORT jboolean JNICALL
 255 JVM_HoldsLock(JNIEnv *env, jclass threadClass, jobject obj);
 256 
 257 JNIEXPORT void JNICALL
 258 JVM_DumpAllStacks(JNIEnv *env, jclass unused);
 259 
 260 JNIEXPORT jobjectArray JNICALL
 261 JVM_GetAllThreads(JNIEnv *env, jclass dummy);
 262 
 263 JNIEXPORT void JNICALL
 264 JVM_SetNativeThreadName(JNIEnv *env, jobject jthread, jstring name);
 265 
 266 /* getStackTrace() and getAllStackTraces() method */
 267 JNIEXPORT jobjectArray JNICALL
 268 JVM_DumpThreads(JNIEnv *env, jclass threadClass, jobjectArray threads);
 269 
 270 /*
 271  * java.lang.SecurityManager
 272  */
 273 JNIEXPORT jobjectArray JNICALL
 274 JVM_GetClassContext(JNIEnv *env);
 275 
 276 /*
 277  * java.lang.Package
 278  */
 279 JNIEXPORT jstring JNICALL
 280 JVM_GetSystemPackage(JNIEnv *env, jstring name);
 281 
 282 JNIEXPORT jobjectArray JNICALL
 283 JVM_GetSystemPackages(JNIEnv *env);
 284 
<a name="1" id="anc1"></a>





 285 /*
 286  * java.lang.ref.Reference
 287  */
 288 JNIEXPORT jobject JNICALL
 289 JVM_GetAndClearReferencePendingList(JNIEnv *env);
 290 
 291 JNIEXPORT jboolean JNICALL
 292 JVM_HasReferencePendingList(JNIEnv *env);
 293 
 294 JNIEXPORT void JNICALL
 295 JVM_WaitForReferencePendingList(JNIEnv *env);
 296 
 297 /*
 298  * java.io.ObjectInputStream
 299  */
 300 JNIEXPORT jobject JNICALL
 301 JVM_LatestUserDefinedLoader(JNIEnv *env);
 302 
 303 /*
 304  * java.lang.reflect.Array
 305  */
 306 JNIEXPORT jint JNICALL
 307 JVM_GetArrayLength(JNIEnv *env, jobject arr);
 308 
 309 JNIEXPORT jobject JNICALL
 310 JVM_GetArrayElement(JNIEnv *env, jobject arr, jint index);
 311 
 312 JNIEXPORT jvalue JNICALL
 313 JVM_GetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jint wCode);
 314 
 315 JNIEXPORT void JNICALL
 316 JVM_SetArrayElement(JNIEnv *env, jobject arr, jint index, jobject val);
 317 
 318 JNIEXPORT void JNICALL
 319 JVM_SetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jvalue v,
 320                              unsigned char vCode);
 321 
 322 JNIEXPORT jobject JNICALL
 323 JVM_NewArray(JNIEnv *env, jclass eltClass, jint length);
 324 
 325 JNIEXPORT jobject JNICALL
 326 JVM_NewMultiArray(JNIEnv *env, jclass eltClass, jintArray dim);
 327 
 328 
 329 /*
 330  * Returns the immediate caller class of the native method invoking
 331  * JVM_GetCallerClass.  The Method.invoke and other frames due to
 332  * reflection machinery are skipped.
 333  *
 334  * The caller is expected to be marked with
 335  * jdk.internal.reflect.CallerSensitive. The JVM will throw an
 336  * error if it is not marked properly.
 337  */
 338 JNIEXPORT jclass JNICALL
 339 JVM_GetCallerClass(JNIEnv *env);
 340 
 341 
 342 /*
 343  * Find primitive classes
 344  * utf: class name
 345  */
 346 JNIEXPORT jclass JNICALL
 347 JVM_FindPrimitiveClass(JNIEnv *env, const char *utf);
 348 
 349 
 350 /*
 351  * Find a class from a boot class loader. Returns NULL if class not found.
 352  */
 353 JNIEXPORT jclass JNICALL
 354 JVM_FindClassFromBootLoader(JNIEnv *env, const char *name);
 355 
 356 /*
 357  * Find a class from a given class loader.  Throws ClassNotFoundException.
 358  *  name:   name of class
 359  *  init:   whether initialization is done
 360  *  loader: class loader to look up the class. This may not be the same as the caller&#39;s
 361  *          class loader.
 362  *  caller: initiating class. The initiating class may be null when a security
 363  *          manager is not installed.
 364  */
 365 JNIEXPORT jclass JNICALL
 366 JVM_FindClassFromCaller(JNIEnv *env, const char *name, jboolean init,
 367                         jobject loader, jclass caller);
 368 
 369 /*
 370  * Find a class from a given class.
 371  */
 372 JNIEXPORT jclass JNICALL
 373 JVM_FindClassFromClass(JNIEnv *env, const char *name, jboolean init,
 374                              jclass from);
 375 
 376 /* Find a loaded class cached by the VM */
 377 JNIEXPORT jclass JNICALL
 378 JVM_FindLoadedClass(JNIEnv *env, jobject loader, jstring name);
 379 
 380 /* Define a class */
 381 JNIEXPORT jclass JNICALL
 382 JVM_DefineClass(JNIEnv *env, const char *name, jobject loader, const jbyte *buf,
 383                 jsize len, jobject pd);
 384 
 385 /* Define a class with a source (added in JDK1.5) */
 386 JNIEXPORT jclass JNICALL
 387 JVM_DefineClassWithSource(JNIEnv *env, const char *name, jobject loader,
 388                           const jbyte *buf, jsize len, jobject pd,
 389                           const char *source);
 390 
 391 /*
 392  * Module support funcions
 393  */
 394 
 395 /*
 396  * Define a module with the specified packages and bind the module to the
 397  * given class loader.
 398  *  module:       module to define
 399  *  is_open:      specifies if module is open (currently ignored)
 400  *  version:      the module version
 401  *  location:     the module location
 402  *  packages:     list of packages in the module
 403  *  num_packages: number of packages in the module
 404  */
 405 JNIEXPORT void JNICALL
 406 JVM_DefineModule(JNIEnv *env, jobject module, jboolean is_open, jstring version,
 407                  jstring location, const char* const* packages, jsize num_packages);
 408 
 409 /*
 410  * Set the boot loader&#39;s unnamed module.
 411  *  module: boot loader&#39;s unnamed module
 412  */
 413 JNIEXPORT void JNICALL
 414 JVM_SetBootLoaderUnnamedModule(JNIEnv *env, jobject module);
 415 
 416 /*
 417  * Do a qualified export of a package.
 418  *  from_module: module containing the package to export
 419  *  package:     name of the package to export
 420  *  to_module:   module to export the package to
 421  */
 422 JNIEXPORT void JNICALL
 423 JVM_AddModuleExports(JNIEnv *env, jobject from_module, const char* package, jobject to_module);
 424 
 425 /*
 426  * Do an export of a package to all unnamed modules.
 427  *  from_module: module containing the package to export
 428  *  package:     name of the package to export to all unnamed modules
 429  */
 430 JNIEXPORT void JNICALL
 431 JVM_AddModuleExportsToAllUnnamed(JNIEnv *env, jobject from_module, const char* package);
 432 
 433 /*
 434  * Do an unqualified export of a package.
 435  *  from_module: module containing the package to export
 436  *  package:     name of the package to export
 437  */
 438 JNIEXPORT void JNICALL
 439 JVM_AddModuleExportsToAll(JNIEnv *env, jobject from_module, const char* package);
 440 
 441 /*
 442  * Add a module to the list of modules that a given module can read.
 443  *  from_module:   module requesting read access
 444  *  source_module: module that from_module wants to read
 445  */
 446 JNIEXPORT void JNICALL
 447 JVM_AddReadsModule(JNIEnv *env, jobject from_module, jobject source_module);
 448 
 449 /*
 450  * Reflection support functions
 451  */
 452 
 453 JNIEXPORT jstring JNICALL
 454 JVM_InitClassName(JNIEnv *env, jclass cls);
 455 
 456 JNIEXPORT jobjectArray JNICALL
 457 JVM_GetClassInterfaces(JNIEnv *env, jclass cls);
 458 
 459 JNIEXPORT jboolean JNICALL
 460 JVM_IsInterface(JNIEnv *env, jclass cls);
 461 
 462 JNIEXPORT jobjectArray JNICALL
 463 JVM_GetClassSigners(JNIEnv *env, jclass cls);
 464 
 465 JNIEXPORT void JNICALL
 466 JVM_SetClassSigners(JNIEnv *env, jclass cls, jobjectArray signers);
 467 
 468 JNIEXPORT jobject JNICALL
 469 JVM_GetProtectionDomain(JNIEnv *env, jclass cls);
 470 
 471 JNIEXPORT jboolean JNICALL
 472 JVM_IsArrayClass(JNIEnv *env, jclass cls);
 473 
 474 JNIEXPORT jboolean JNICALL
 475 JVM_IsPrimitiveClass(JNIEnv *env, jclass cls);
 476 
 477 JNIEXPORT jint JNICALL
 478 JVM_GetClassModifiers(JNIEnv *env, jclass cls);
 479 
 480 JNIEXPORT jobjectArray JNICALL
 481 JVM_GetDeclaredClasses(JNIEnv *env, jclass ofClass);
 482 
 483 JNIEXPORT jclass JNICALL
 484 JVM_GetDeclaringClass(JNIEnv *env, jclass ofClass);
 485 
 486 JNIEXPORT jstring JNICALL
 487 JVM_GetSimpleBinaryName(JNIEnv *env, jclass ofClass);
 488 
 489 /* Generics support (JDK 1.5) */
 490 JNIEXPORT jstring JNICALL
 491 JVM_GetClassSignature(JNIEnv *env, jclass cls);
 492 
 493 /* Annotations support (JDK 1.5) */
 494 JNIEXPORT jbyteArray JNICALL
 495 JVM_GetClassAnnotations(JNIEnv *env, jclass cls);
 496 
 497 /* Type use annotations support (JDK 1.8) */
 498 
 499 JNIEXPORT jbyteArray JNICALL
 500 JVM_GetClassTypeAnnotations(JNIEnv *env, jclass cls);
 501 
 502 JNIEXPORT jbyteArray JNICALL
 503 JVM_GetFieldTypeAnnotations(JNIEnv *env, jobject field);
 504 
 505 JNIEXPORT jbyteArray JNICALL
 506 JVM_GetMethodTypeAnnotations(JNIEnv *env, jobject method);
 507 
 508 /*
 509  * New (JDK 1.4) reflection implementation
 510  */
 511 
 512 JNIEXPORT jobjectArray JNICALL
 513 JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 514 
 515 JNIEXPORT jobjectArray JNICALL
 516 JVM_GetClassDeclaredFields(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 517 
 518 JNIEXPORT jobjectArray JNICALL
 519 JVM_GetClassDeclaredConstructors(JNIEnv *env, jclass ofClass, jboolean publicOnly);
 520 
 521 
 522 /* Differs from JVM_GetClassModifiers in treatment of inner classes.
 523    This returns the access flags for the class as specified in the
 524    class file rather than searching the InnerClasses attribute (if
 525    present) to find the source-level access flags. Only the values of
 526    the low 13 bits (i.e., a mask of 0x1FFF) are guaranteed to be
 527    valid. */
 528 JNIEXPORT jint JNICALL
 529 JVM_GetClassAccessFlags(JNIEnv *env, jclass cls);
 530 
 531 /* Nestmates - since JDK 11 */
 532 
 533 JNIEXPORT jboolean JNICALL
 534 JVM_AreNestMates(JNIEnv *env, jclass current, jclass member);
 535 
 536 JNIEXPORT jclass JNICALL
 537 JVM_GetNestHost(JNIEnv *env, jclass current);
 538 
 539 JNIEXPORT jobjectArray JNICALL
 540 JVM_GetNestMembers(JNIEnv *env, jclass current);
 541 
 542 /* Records - since JDK 14 */
 543 
 544 JNIEXPORT jboolean JNICALL
 545 JVM_IsRecord(JNIEnv *env, jclass cls);
 546 
 547 JNIEXPORT jobjectArray JNICALL
 548 JVM_GetRecordComponents(JNIEnv *env, jclass ofClass);
 549 
 550 /* The following two reflection routines are still needed due to startup time issues */
 551 /*
 552  * java.lang.reflect.Method
 553  */
 554 JNIEXPORT jobject JNICALL
 555 JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0);
 556 
 557 /*
 558  * java.lang.reflect.Constructor
 559  */
 560 JNIEXPORT jobject JNICALL
 561 JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0);
 562 
 563 /*
 564  * Constant pool access; currently used to implement reflective access to annotations (JDK 1.5)
 565  */
 566 
 567 JNIEXPORT jobject JNICALL
 568 JVM_GetClassConstantPool(JNIEnv *env, jclass cls);
 569 
 570 JNIEXPORT jint JNICALL JVM_ConstantPoolGetSize
 571 (JNIEnv *env, jobject unused, jobject jcpool);
 572 
 573 JNIEXPORT jclass JNICALL JVM_ConstantPoolGetClassAt
 574 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 575 
 576 JNIEXPORT jclass JNICALL JVM_ConstantPoolGetClassAtIfLoaded
 577 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 578 
 579 JNIEXPORT jint JNICALL JVM_ConstantPoolGetClassRefIndexAt
 580 (JNIEnv *env, jobject obj, jobject unused, jint index);
 581 
 582 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetMethodAt
 583 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 584 
 585 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetMethodAtIfLoaded
 586 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 587 
 588 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetFieldAt
 589 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 590 
 591 JNIEXPORT jobject JNICALL JVM_ConstantPoolGetFieldAtIfLoaded
 592 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 593 
 594 JNIEXPORT jobjectArray JNICALL JVM_ConstantPoolGetMemberRefInfoAt
 595 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 596 
 597 JNIEXPORT jint JNICALL JVM_ConstantPoolGetNameAndTypeRefIndexAt
 598 (JNIEnv *env, jobject obj, jobject unused, jint index);
 599 
 600 JNIEXPORT jobjectArray JNICALL JVM_ConstantPoolGetNameAndTypeRefInfoAt
 601 (JNIEnv *env, jobject obj, jobject unused, jint index);
 602 
 603 JNIEXPORT jint JNICALL JVM_ConstantPoolGetIntAt
 604 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 605 
 606 JNIEXPORT jlong JNICALL JVM_ConstantPoolGetLongAt
 607 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 608 
 609 JNIEXPORT jfloat JNICALL JVM_ConstantPoolGetFloatAt
 610 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 611 
 612 JNIEXPORT jdouble JNICALL JVM_ConstantPoolGetDoubleAt
 613 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 614 
 615 JNIEXPORT jstring JNICALL JVM_ConstantPoolGetStringAt
 616 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 617 
 618 JNIEXPORT jstring JNICALL JVM_ConstantPoolGetUTF8At
 619 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 620 
 621 JNIEXPORT jbyte JNICALL JVM_ConstantPoolGetTagAt
 622 (JNIEnv *env, jobject unused, jobject jcpool, jint index);
 623 
 624 /*
 625  * Parameter reflection
 626  */
 627 
 628 JNIEXPORT jobjectArray JNICALL
 629 JVM_GetMethodParameters(JNIEnv *env, jobject method);
 630 
 631 /*
 632  * java.security.*
 633  */
 634 
 635 JNIEXPORT jobject JNICALL
 636 JVM_GetInheritedAccessControlContext(JNIEnv *env, jclass cls);
 637 
 638 /*
 639  * Ensure that code doing a stackwalk and using javaVFrame::locals() to
 640  * get the value will see a materialized value and not a scalar-replaced
 641  * null value.
 642  */
 643 #define JVM_EnsureMaterializedForStackWalk(env, value) \
 644     do {} while(0) // Nothing to do.  The fact that the value escaped
 645                    // through a native method is enough.
 646 
 647 JNIEXPORT jobject JNICALL
 648 JVM_GetStackAccessControlContext(JNIEnv *env, jclass cls);
 649 
 650 /*
 651  * Signal support, used to implement the shutdown sequence.  Every VM must
 652  * support JVM_SIGINT and JVM_SIGTERM, raising the former for user interrupts
 653  * (^C) and the latter for external termination (kill, system shutdown, etc.).
 654  * Other platform-dependent signal values may also be supported.
 655  */
 656 
 657 JNIEXPORT void * JNICALL
 658 JVM_RegisterSignal(jint sig, void *handler);
 659 
 660 JNIEXPORT jboolean JNICALL
 661 JVM_RaiseSignal(jint sig);
 662 
 663 JNIEXPORT jint JNICALL
 664 JVM_FindSignal(const char *name);
 665 
 666 /*
 667  * Retrieve the assertion directives for the specified class.
 668  */
 669 JNIEXPORT jboolean JNICALL
 670 JVM_DesiredAssertionStatus(JNIEnv *env, jclass unused, jclass cls);
 671 
 672 /*
 673  * Retrieve the assertion directives from the VM.
 674  */
 675 JNIEXPORT jobject JNICALL
 676 JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused);
 677 
 678 /*
 679  * java.util.concurrent.atomic.AtomicLong
 680  */
 681 JNIEXPORT jboolean JNICALL
 682 JVM_SupportsCX8(void);
 683 
 684 /*
 685  * com.sun.dtrace.jsdt support
 686  */
 687 
 688 #define JVM_TRACING_DTRACE_VERSION 1
 689 
 690 /*
 691  * Structure to pass one probe description to JVM
 692  */
 693 typedef struct {
 694     jmethodID method;
 695     jstring   function;
 696     jstring   name;
 697     void*            reserved[4];     // for future use
 698 } JVM_DTraceProbe;
 699 
 700 /**
 701  * Encapsulates the stability ratings for a DTrace provider field
 702  */
 703 typedef struct {
 704     jint nameStability;
 705     jint dataStability;
 706     jint dependencyClass;
 707 } JVM_DTraceInterfaceAttributes;
 708 
 709 /*
 710  * Structure to pass one provider description to JVM
 711  */
 712 typedef struct {
 713     jstring                       name;
 714     JVM_DTraceProbe*              probes;
 715     jint                          probe_count;
 716     JVM_DTraceInterfaceAttributes providerAttributes;
 717     JVM_DTraceInterfaceAttributes moduleAttributes;
 718     JVM_DTraceInterfaceAttributes functionAttributes;
 719     JVM_DTraceInterfaceAttributes nameAttributes;
 720     JVM_DTraceInterfaceAttributes argsAttributes;
 721     void*                         reserved[4]; // for future use
 722 } JVM_DTraceProvider;
 723 
 724 /*
 725  * Get the version number the JVM was built with
 726  */
 727 JNIEXPORT jint JNICALL
 728 JVM_DTraceGetVersion(JNIEnv* env);
 729 
 730 /*
 731  * Register new probe with given signature, return global handle
 732  *
 733  * The version passed in is the version that the library code was
 734  * built with.
 735  */
 736 JNIEXPORT jlong JNICALL
 737 JVM_DTraceActivate(JNIEnv* env, jint version, jstring module_name,
 738   jint providers_count, JVM_DTraceProvider* providers);
 739 
 740 /*
 741  * Check JSDT probe
 742  */
 743 JNIEXPORT jboolean JNICALL
 744 JVM_DTraceIsProbeEnabled(JNIEnv* env, jmethodID method);
 745 
 746 /*
 747  * Destroy custom DOF
 748  */
 749 JNIEXPORT void JNICALL
 750 JVM_DTraceDispose(JNIEnv* env, jlong activation_handle);
 751 
 752 /*
 753  * Check to see if DTrace is supported by OS
 754  */
 755 JNIEXPORT jboolean JNICALL
 756 JVM_DTraceIsSupported(JNIEnv* env);
 757 
 758 /*************************************************************************
 759  PART 2: Support for the Verifier and Class File Format Checker
 760  ************************************************************************/
 761 /*
 762  * Return the class name in UTF format. The result is valid
 763  * until JVM_ReleaseUTf is called.
 764  *
 765  * The caller must treat the string as a constant and not modify it
 766  * in any way.
 767  */
 768 JNIEXPORT const char * JNICALL
 769 JVM_GetClassNameUTF(JNIEnv *env, jclass cb);
 770 
 771 /*
 772  * Returns the constant pool types in the buffer provided by &quot;types.&quot;
 773  */
 774 JNIEXPORT void JNICALL
 775 JVM_GetClassCPTypes(JNIEnv *env, jclass cb, unsigned char *types);
 776 
 777 /*
 778  * Returns the number of Constant Pool entries.
 779  */
 780 JNIEXPORT jint JNICALL
 781 JVM_GetClassCPEntriesCount(JNIEnv *env, jclass cb);
 782 
 783 /*
 784  * Returns the number of *declared* fields or methods.
 785  */
 786 JNIEXPORT jint JNICALL
 787 JVM_GetClassFieldsCount(JNIEnv *env, jclass cb);
 788 
 789 JNIEXPORT jint JNICALL
 790 JVM_GetClassMethodsCount(JNIEnv *env, jclass cb);
 791 
 792 /*
 793  * Returns the CP indexes of exceptions raised by a given method.
 794  * Places the result in the given buffer.
 795  *
 796  * The method is identified by method_index.
 797  */
 798 JNIEXPORT void JNICALL
 799 JVM_GetMethodIxExceptionIndexes(JNIEnv *env, jclass cb, jint method_index,
 800                                 unsigned short *exceptions);
 801 /*
 802  * Returns the number of exceptions raised by a given method.
 803  * The method is identified by method_index.
 804  */
 805 JNIEXPORT jint JNICALL
 806 JVM_GetMethodIxExceptionsCount(JNIEnv *env, jclass cb, jint method_index);
 807 
 808 /*
 809  * Returns the byte code sequence of a given method.
 810  * Places the result in the given buffer.
 811  *
 812  * The method is identified by method_index.
 813  */
 814 JNIEXPORT void JNICALL
 815 JVM_GetMethodIxByteCode(JNIEnv *env, jclass cb, jint method_index,
 816                         unsigned char *code);
 817 
 818 /*
 819  * Returns the length of the byte code sequence of a given method.
 820  * The method is identified by method_index.
 821  */
 822 JNIEXPORT jint JNICALL
 823 JVM_GetMethodIxByteCodeLength(JNIEnv *env, jclass cb, jint method_index);
 824 
 825 /*
 826  * A structure used to a capture exception table entry in a Java method.
 827  */
 828 typedef struct {
 829     jint start_pc;
 830     jint end_pc;
 831     jint handler_pc;
 832     jint catchType;
 833 } JVM_ExceptionTableEntryType;
 834 
 835 /*
 836  * Returns the exception table entry at entry_index of a given method.
 837  * Places the result in the given buffer.
 838  *
 839  * The method is identified by method_index.
 840  */
 841 JNIEXPORT void JNICALL
 842 JVM_GetMethodIxExceptionTableEntry(JNIEnv *env, jclass cb, jint method_index,
 843                                    jint entry_index,
 844                                    JVM_ExceptionTableEntryType *entry);
 845 
 846 /*
 847  * Returns the length of the exception table of a given method.
 848  * The method is identified by method_index.
 849  */
 850 JNIEXPORT jint JNICALL
 851 JVM_GetMethodIxExceptionTableLength(JNIEnv *env, jclass cb, int index);
 852 
 853 /*
 854  * Returns the modifiers of a given field.
 855  * The field is identified by field_index.
 856  */
 857 JNIEXPORT jint JNICALL
 858 JVM_GetFieldIxModifiers(JNIEnv *env, jclass cb, int index);
 859 
 860 /*
 861  * Returns the modifiers of a given method.
 862  * The method is identified by method_index.
 863  */
 864 JNIEXPORT jint JNICALL
 865 JVM_GetMethodIxModifiers(JNIEnv *env, jclass cb, int index);
 866 
 867 /*
 868  * Returns the number of local variables of a given method.
 869  * The method is identified by method_index.
 870  */
 871 JNIEXPORT jint JNICALL
 872 JVM_GetMethodIxLocalsCount(JNIEnv *env, jclass cb, int index);
 873 
 874 /*
 875  * Returns the number of arguments (including this pointer) of a given method.
 876  * The method is identified by method_index.
 877  */
 878 JNIEXPORT jint JNICALL
 879 JVM_GetMethodIxArgsSize(JNIEnv *env, jclass cb, int index);
 880 
 881 /*
 882  * Returns the maximum amount of stack (in words) used by a given method.
 883  * The method is identified by method_index.
 884  */
 885 JNIEXPORT jint JNICALL
 886 JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cb, int index);
 887 
 888 /*
 889  * Is a given method a constructor.
 890  * The method is identified by method_index.
 891  */
 892 JNIEXPORT jboolean JNICALL
 893 JVM_IsConstructorIx(JNIEnv *env, jclass cb, int index);
 894 
 895 /*
 896  * Is the given method generated by the VM.
 897  * The method is identified by method_index.
 898  */
 899 JNIEXPORT jboolean JNICALL
 900 JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cb, int index);
 901 
 902 /*
 903  * Returns the name of a given method in UTF format.
 904  * The result remains valid until JVM_ReleaseUTF is called.
 905  *
 906  * The caller must treat the string as a constant and not modify it
 907  * in any way.
 908  */
 909 JNIEXPORT const char * JNICALL
 910 JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cb, jint index);
 911 
 912 /*
 913  * Returns the signature of a given method in UTF format.
 914  * The result remains valid until JVM_ReleaseUTF is called.
 915  *
 916  * The caller must treat the string as a constant and not modify it
 917  * in any way.
 918  */
 919 JNIEXPORT const char * JNICALL
 920 JVM_GetMethodIxSignatureUTF(JNIEnv *env, jclass cb, jint index);
 921 
 922 /*
 923  * Returns the name of the field referred to at a given constant pool
 924  * index.
 925  *
 926  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 927  * is called.
 928  *
 929  * The caller must treat the string as a constant and not modify it
 930  * in any way.
 931  */
 932 JNIEXPORT const char * JNICALL
 933 JVM_GetCPFieldNameUTF(JNIEnv *env, jclass cb, jint index);
 934 
 935 /*
 936  * Returns the name of the method referred to at a given constant pool
 937  * index.
 938  *
 939  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 940  * is called.
 941  *
 942  * The caller must treat the string as a constant and not modify it
 943  * in any way.
 944  */
 945 JNIEXPORT const char * JNICALL
 946 JVM_GetCPMethodNameUTF(JNIEnv *env, jclass cb, jint index);
 947 
 948 /*
 949  * Returns the signature of the method referred to at a given constant pool
 950  * index.
 951  *
 952  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 953  * is called.
 954  *
 955  * The caller must treat the string as a constant and not modify it
 956  * in any way.
 957  */
 958 JNIEXPORT const char * JNICALL
 959 JVM_GetCPMethodSignatureUTF(JNIEnv *env, jclass cb, jint index);
 960 
 961 /*
 962  * Returns the signature of the field referred to at a given constant pool
 963  * index.
 964  *
 965  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 966  * is called.
 967  *
 968  * The caller must treat the string as a constant and not modify it
 969  * in any way.
 970  */
 971 JNIEXPORT const char * JNICALL
 972 JVM_GetCPFieldSignatureUTF(JNIEnv *env, jclass cb, jint index);
 973 
 974 /*
 975  * Returns the class name referred to at a given constant pool index.
 976  *
 977  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 978  * is called.
 979  *
 980  * The caller must treat the string as a constant and not modify it
 981  * in any way.
 982  */
 983 JNIEXPORT const char * JNICALL
 984 JVM_GetCPClassNameUTF(JNIEnv *env, jclass cb, jint index);
 985 
 986 /*
 987  * Returns the class name referred to at a given constant pool index.
 988  *
 989  * The constant pool entry must refer to a CONSTANT_Fieldref.
 990  *
 991  * The result is in UTF format and remains valid until JVM_ReleaseUTF
 992  * is called.
 993  *
 994  * The caller must treat the string as a constant and not modify it
 995  * in any way.
 996  */
 997 JNIEXPORT const char * JNICALL
 998 JVM_GetCPFieldClassNameUTF(JNIEnv *env, jclass cb, jint index);
 999 
1000 /*
1001  * Returns the class name referred to at a given constant pool index.
1002  *
1003  * The constant pool entry must refer to CONSTANT_Methodref or
1004  * CONSTANT_InterfaceMethodref.
1005  *
1006  * The result is in UTF format and remains valid until JVM_ReleaseUTF
1007  * is called.
1008  *
1009  * The caller must treat the string as a constant and not modify it
1010  * in any way.
1011  */
1012 JNIEXPORT const char * JNICALL
1013 JVM_GetCPMethodClassNameUTF(JNIEnv *env, jclass cb, jint index);
1014 
1015 /*
1016  * Returns the modifiers of a field in calledClass. The field is
1017  * referred to in class cb at constant pool entry index.
1018  *
1019  * The caller must treat the string as a constant and not modify it
1020  * in any way.
1021  *
1022  * Returns -1 if the field does not exist in calledClass.
1023  */
1024 JNIEXPORT jint JNICALL
1025 JVM_GetCPFieldModifiers(JNIEnv *env, jclass cb, int index, jclass calledClass);
1026 
1027 /*
1028  * Returns the modifiers of a method in calledClass. The method is
1029  * referred to in class cb at constant pool entry index.
1030  *
1031  * Returns -1 if the method does not exist in calledClass.
1032  */
1033 JNIEXPORT jint JNICALL
1034 JVM_GetCPMethodModifiers(JNIEnv *env, jclass cb, int index, jclass calledClass);
1035 
1036 /*
1037  * Releases the UTF string obtained from the VM.
1038  */
1039 JNIEXPORT void JNICALL
1040 JVM_ReleaseUTF(const char *utf);
1041 
1042 /*
1043  * Compare if two classes are in the same package.
1044  */
1045 JNIEXPORT jboolean JNICALL
1046 JVM_IsSameClassPackage(JNIEnv *env, jclass class1, jclass class2);
1047 
1048 /* Get classfile constants */
1049 #include &quot;classfile_constants.h&quot;
1050 
1051 /*
1052  * Support for a VM-independent class format checker.
1053  */
1054 typedef struct {
1055     unsigned long code;    /* byte code */
1056     unsigned long excs;    /* exceptions */
1057     unsigned long etab;    /* catch table */
1058     unsigned long lnum;    /* line number */
1059     unsigned long lvar;    /* local vars */
1060 } method_size_info;
1061 
1062 typedef struct {
1063     unsigned int constants;    /* constant pool */
1064     unsigned int fields;
1065     unsigned int methods;
1066     unsigned int interfaces;
1067     unsigned int fields2;      /* number of static 2-word fields */
1068     unsigned int innerclasses; /* # of records in InnerClasses attr */
1069 
1070     method_size_info clinit;   /* memory used in clinit */
1071     method_size_info main;     /* used everywhere else */
1072 } class_size_info;
1073 
1074 #define JVM_RECOGNIZED_CLASS_MODIFIERS (JVM_ACC_PUBLIC | \
1075                                         JVM_ACC_FINAL | \
1076                                         JVM_ACC_SUPER | \
1077                                         JVM_ACC_INTERFACE | \
1078                                         JVM_ACC_ABSTRACT | \
1079                                         JVM_ACC_ANNOTATION | \
1080                                         JVM_ACC_ENUM | \
1081                                         JVM_ACC_SYNTHETIC)
1082 
1083 #define JVM_RECOGNIZED_FIELD_MODIFIERS (JVM_ACC_PUBLIC | \
1084                                         JVM_ACC_PRIVATE | \
1085                                         JVM_ACC_PROTECTED | \
1086                                         JVM_ACC_STATIC | \
1087                                         JVM_ACC_FINAL | \
1088                                         JVM_ACC_VOLATILE | \
1089                                         JVM_ACC_TRANSIENT | \
1090                                         JVM_ACC_ENUM | \
1091                                         JVM_ACC_SYNTHETIC)
1092 
1093 #define JVM_RECOGNIZED_METHOD_MODIFIERS (JVM_ACC_PUBLIC | \
1094                                          JVM_ACC_PRIVATE | \
1095                                          JVM_ACC_PROTECTED | \
1096                                          JVM_ACC_STATIC | \
1097                                          JVM_ACC_FINAL | \
1098                                          JVM_ACC_SYNCHRONIZED | \
1099                                          JVM_ACC_BRIDGE | \
1100                                          JVM_ACC_VARARGS | \
1101                                          JVM_ACC_NATIVE | \
1102                                          JVM_ACC_ABSTRACT | \
1103                                          JVM_ACC_STRICT | \
1104                                          JVM_ACC_SYNTHETIC)
1105 
1106 
1107 /*************************************************************************
1108  PART 3: I/O and Network Support
1109  ************************************************************************/
1110 
1111 /*
1112  * Convert a pathname into native format.  This function does syntactic
1113  * cleanup, such as removing redundant separator characters.  It modifies
1114  * the given pathname string in place.
1115  */
1116 JNIEXPORT char * JNICALL
1117 JVM_NativePath(char *);
1118 
1119 /*
1120  * The standard printing functions supported by the Java VM. (Should they
1121  * be renamed to JVM_* in the future?
1122  */
1123 
1124 /* jio_snprintf() and jio_vsnprintf() behave like snprintf(3) and vsnprintf(3),
1125  *  respectively, with the following differences:
1126  * - The string written to str is always zero-terminated, also in case of
1127  *   truncation (count is too small to hold the result string), unless count
1128  *   is 0. In case of truncation count-1 characters are written and &#39;\0&#39;
1129  *   appendend.
1130  * - If count is too small to hold the whole string, -1 is returned across
1131  *   all platforms. */
1132 
1133 JNIEXPORT int
1134 jio_vsnprintf(char *str, size_t count, const char *fmt, va_list args);
1135 
1136 JNIEXPORT int
1137 jio_snprintf(char *str, size_t count, const char *fmt, ...);
1138 
1139 JNIEXPORT int
1140 jio_fprintf(FILE *, const char *fmt, ...);
1141 
1142 JNIEXPORT int
1143 jio_vfprintf(FILE *, const char *fmt, va_list args);
1144 
1145 
1146 JNIEXPORT void * JNICALL
1147 JVM_RawMonitorCreate(void);
1148 
1149 JNIEXPORT void JNICALL
1150 JVM_RawMonitorDestroy(void *mon);
1151 
1152 JNIEXPORT jint JNICALL
1153 JVM_RawMonitorEnter(void *mon);
1154 
1155 JNIEXPORT void JNICALL
1156 JVM_RawMonitorExit(void *mon);
1157 
1158 /*
1159  * java.lang.management support
1160  */
1161 JNIEXPORT void* JNICALL
1162 JVM_GetManagement(jint version);
1163 
1164 /*
1165  * com.sun.tools.attach.VirtualMachine support
1166  *
1167  * Initialize the agent properties with the properties maintained in the VM.
1168  */
1169 JNIEXPORT jobject JNICALL
1170 JVM_InitAgentProperties(JNIEnv *env, jobject agent_props);
1171 
1172 JNIEXPORT jstring JNICALL
1173 JVM_GetTemporaryDirectory(JNIEnv *env);
1174 
1175 /* Generics reflection support.
1176  *
1177  * Returns information about the given class&#39;s EnclosingMethod
1178  * attribute, if present, or null if the class had no enclosing
1179  * method.
1180  *
1181  * If non-null, the returned array contains three elements. Element 0
1182  * is the java.lang.Class of which the enclosing method is a member,
1183  * and elements 1 and 2 are the java.lang.Strings for the enclosing
1184  * method&#39;s name and descriptor, respectively.
1185  */
1186 JNIEXPORT jobjectArray JNICALL
1187 JVM_GetEnclosingMethodInfo(JNIEnv* env, jclass ofClass);
1188 
1189 /*
1190  * This structure is used by the launcher to get the default thread
1191  * stack size from the VM using JNI_GetDefaultJavaVMInitArgs() with a
1192  * version of 1.1.  As it is not supported otherwise, it has been removed
1193  * from jni.h
1194  */
1195 typedef struct JDK1_1InitArgs {
1196     jint version;
1197 
1198     char **properties;
1199     jint checkSource;
1200     jint nativeStackSize;
1201     jint javaStackSize;
1202     jint minHeapSize;
1203     jint maxHeapSize;
1204     jint verifyMode;
1205     char *classpath;
1206 
1207     jint (JNICALL *vfprintf)(FILE *fp, const char *format, va_list args);
1208     void (JNICALL *exit)(jint code);
1209     void (JNICALL *abort)(void);
1210 
1211     jint enableClassGC;
1212     jint enableVerboseGC;
1213     jint disableAsyncGC;
1214     jint verbose;
1215     jboolean debugging;
1216     jint debugPort;
1217 } JDK1_1InitArgs;
1218 
1219 
1220 #ifdef __cplusplus
1221 } /* extern &quot;C&quot; */
1222 
1223 #endif /* __cplusplus */
1224 
1225 #endif /* !_JAVASOFT_JVM_H_ */
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
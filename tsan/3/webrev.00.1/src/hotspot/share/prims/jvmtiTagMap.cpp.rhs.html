<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/jvmtiTagMap.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  27 #include &quot;classfile/javaClasses.inline.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;classfile/vmSymbols.hpp&quot;
  31 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
  32 #include &quot;logging/log.hpp&quot;
  33 #include &quot;memory/allocation.inline.hpp&quot;
  34 #include &quot;memory/resourceArea.hpp&quot;
  35 #include &quot;memory/universe.hpp&quot;
  36 #include &quot;oops/access.inline.hpp&quot;
  37 #include &quot;oops/arrayOop.inline.hpp&quot;
  38 #include &quot;oops/constantPool.inline.hpp&quot;
  39 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  40 #include &quot;oops/objArrayKlass.hpp&quot;
  41 #include &quot;oops/objArrayOop.inline.hpp&quot;
  42 #include &quot;oops/oop.inline.hpp&quot;
  43 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  44 #include &quot;prims/jvmtiEventController.hpp&quot;
  45 #include &quot;prims/jvmtiEventController.inline.hpp&quot;
  46 #include &quot;prims/jvmtiExport.hpp&quot;
  47 #include &quot;prims/jvmtiImpl.hpp&quot;
  48 #include &quot;prims/jvmtiTagMap.hpp&quot;
  49 #include &quot;runtime/biasedLocking.hpp&quot;
  50 #include &quot;runtime/frame.inline.hpp&quot;
  51 #include &quot;runtime/handles.inline.hpp&quot;
  52 #include &quot;runtime/javaCalls.hpp&quot;
  53 #include &quot;runtime/jniHandles.inline.hpp&quot;
  54 #include &quot;runtime/mutex.hpp&quot;
  55 #include &quot;runtime/mutexLocker.hpp&quot;
  56 #include &quot;runtime/reflectionUtils.hpp&quot;
  57 #include &quot;runtime/thread.inline.hpp&quot;
  58 #include &quot;runtime/threadSMR.hpp&quot;
  59 #include &quot;runtime/vframe.hpp&quot;
  60 #include &quot;runtime/vmThread.hpp&quot;
  61 #include &quot;runtime/vmOperations.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added">  62 #if INCLUDE_TSAN</span>
<span class="line-added">  63 #include &quot;tsan/tsan.hpp&quot;</span>
<span class="line-added">  64 #endif  // INCLUDE_TSAN</span>
  65 #include &quot;utilities/macros.hpp&quot;
  66 #if INCLUDE_ZGC
  67 #include &quot;gc/z/zGlobals.hpp&quot;
  68 #endif
  69 
  70 // JvmtiTagHashmapEntry
  71 //
  72 // Each entry encapsulates a reference to the tagged object
  73 // and the tag value. In addition an entry includes a next pointer which
  74 // is used to chain entries together.
  75 
  76 class JvmtiTagHashmapEntry : public CHeapObj&lt;mtInternal&gt; {
  77  private:
  78   friend class JvmtiTagMap;
  79 
  80   oop _object;                          // tagged object
  81   jlong _tag;                           // the tag
  82   JvmtiTagHashmapEntry* _next;          // next on the list
  83 
  84   inline void init(oop object, jlong tag) {
  85     _object = object;
  86     _tag = tag;
  87     _next = NULL;
  88   }
  89 
  90   // constructor
  91   JvmtiTagHashmapEntry(oop object, jlong tag) { init(object, tag); }
  92 
  93  public:
  94 
  95   // accessor methods
  96   inline oop* object_addr() { return &amp;_object; }
  97   inline oop object()       { return NativeAccess&lt;ON_PHANTOM_OOP_REF&gt;::oop_load(object_addr()); }
  98   // Peek at the object without keeping it alive. The returned object must be
  99   // kept alive using a normal access if it leaks out of a thread transition from VM.
 100   inline oop object_peek()  {
 101     return NativeAccess&lt;ON_PHANTOM_OOP_REF | AS_NO_KEEPALIVE&gt;::oop_load(object_addr());
 102   }
 103 
 104   inline oop object_raw() {
 105     return RawAccess&lt;&gt;::oop_load(object_addr());
 106   }
 107 
 108   inline jlong tag() const  { return _tag; }
 109 
 110   inline void set_tag(jlong tag) {
 111     assert(tag != 0, &quot;can&#39;t be zero&quot;);
 112     _tag = tag;
 113   }
 114 
 115   inline bool equals(oop object) {
 116     return object == object_peek();
 117   }
 118 
 119   inline JvmtiTagHashmapEntry* next() const        { return _next; }
 120   inline void set_next(JvmtiTagHashmapEntry* next) { _next = next; }
 121 };
 122 
 123 
 124 // JvmtiTagHashmap
 125 //
 126 // A hashmap is essentially a table of pointers to entries. Entries
 127 // are hashed to a location, or position in the table, and then
 128 // chained from that location. The &quot;key&quot; for hashing is address of
 129 // the object, or oop. The &quot;value&quot; is the tag value.
 130 //
 131 // A hashmap maintains a count of the number entries in the hashmap
 132 // and resizes if the number of entries exceeds a given threshold.
 133 // The threshold is specified as a percentage of the size - for
 134 // example a threshold of 0.75 will trigger the hashmap to resize
 135 // if the number of entries is &gt;75% of table size.
 136 //
 137 // A hashmap provides functions for adding, removing, and finding
 138 // entries. It also provides a function to iterate over all entries
 139 // in the hashmap.
 140 
 141 class JvmtiTagHashmap : public CHeapObj&lt;mtInternal&gt; {
 142  private:
 143   friend class JvmtiTagMap;
 144 
 145   enum {
 146     small_trace_threshold  = 10000,                  // threshold for tracing
 147     medium_trace_threshold = 100000,
 148     large_trace_threshold  = 1000000,
 149     initial_trace_threshold = small_trace_threshold
 150   };
 151 
 152   static int _sizes[];                  // array of possible hashmap sizes
 153   int _size;                            // actual size of the table
 154   int _size_index;                      // index into size table
 155 
 156   int _entry_count;                     // number of entries in the hashmap
 157 
 158   float _load_factor;                   // load factor as a % of the size
 159   int _resize_threshold;                // computed threshold to trigger resizing.
 160   bool _resizing_enabled;               // indicates if hashmap can resize
 161 
 162   int _trace_threshold;                 // threshold for trace messages
 163 
 164   JvmtiTagHashmapEntry** _table;        // the table of entries.
 165 
 166   // private accessors
 167   int resize_threshold() const                  { return _resize_threshold; }
 168   int trace_threshold() const                   { return _trace_threshold; }
 169 
 170   // initialize the hashmap
 171   void init(int size_index=0, float load_factor=4.0f) {
 172     int initial_size =  _sizes[size_index];
 173     _size_index = size_index;
 174     _size = initial_size;
 175     _entry_count = 0;
 176     _trace_threshold = initial_trace_threshold;
 177     _load_factor = load_factor;
 178     _resize_threshold = (int)(_load_factor * _size);
 179     _resizing_enabled = true;
 180     size_t s = initial_size * sizeof(JvmtiTagHashmapEntry*);
 181     _table = (JvmtiTagHashmapEntry**)os::malloc(s, mtInternal);
 182     if (_table == NULL) {
 183       vm_exit_out_of_memory(s, OOM_MALLOC_ERROR,
 184         &quot;unable to allocate initial hashtable for jvmti object tags&quot;);
 185     }
 186     for (int i=0; i&lt;initial_size; i++) {
 187       _table[i] = NULL;
 188     }
 189   }
 190 
 191   // hash a given key (oop) with the specified size
 192   static unsigned int hash(oop key, int size) {
 193     const oop obj = Access&lt;&gt;::resolve(key);
 194     const unsigned int hash = Universe::heap()-&gt;hash_oop(obj);
 195     return hash % size;
 196   }
 197 
 198   // hash a given key (oop)
 199   unsigned int hash(oop key) {
 200     return hash(key, _size);
 201   }
 202 
 203   // resize the hashmap - allocates a large table and re-hashes
 204   // all entries into the new table.
 205   void resize() {
 206     int new_size_index = _size_index+1;
 207     int new_size = _sizes[new_size_index];
 208     if (new_size &lt; 0) {
 209       // hashmap already at maximum capacity
 210       return;
 211     }
 212 
 213     // allocate new table
 214     size_t s = new_size * sizeof(JvmtiTagHashmapEntry*);
 215     JvmtiTagHashmapEntry** new_table = (JvmtiTagHashmapEntry**)os::malloc(s, mtInternal);
 216     if (new_table == NULL) {
 217       warning(&quot;unable to allocate larger hashtable for jvmti object tags&quot;);
 218       set_resizing_enabled(false);
 219       return;
 220     }
 221 
 222     // initialize new table
 223     int i;
 224     for (i=0; i&lt;new_size; i++) {
 225       new_table[i] = NULL;
 226     }
 227 
 228     // rehash all entries into the new table
 229     for (i=0; i&lt;_size; i++) {
 230       JvmtiTagHashmapEntry* entry = _table[i];
 231       while (entry != NULL) {
 232         JvmtiTagHashmapEntry* next = entry-&gt;next();
 233         oop key = entry-&gt;object_peek();
 234         assert(key != NULL, &quot;jni weak reference cleared!!&quot;);
 235         unsigned int h = hash(key, new_size);
 236         JvmtiTagHashmapEntry* anchor = new_table[h];
 237         if (anchor == NULL) {
 238           new_table[h] = entry;
 239           entry-&gt;set_next(NULL);
 240         } else {
 241           entry-&gt;set_next(anchor);
 242           new_table[h] = entry;
 243         }
 244         entry = next;
 245       }
 246     }
 247 
 248     // free old table and update settings.
 249     os::free((void*)_table);
 250     _table = new_table;
 251     _size_index = new_size_index;
 252     _size = new_size;
 253 
 254     // compute new resize threshold
 255     _resize_threshold = (int)(_load_factor * _size);
 256   }
 257 
 258 
 259   // internal remove function - remove an entry at a given position in the
 260   // table.
 261   inline void remove(JvmtiTagHashmapEntry* prev, int pos, JvmtiTagHashmapEntry* entry) {
 262     assert(pos &gt;= 0 &amp;&amp; pos &lt; _size, &quot;out of range&quot;);
 263     if (prev == NULL) {
 264       _table[pos] = entry-&gt;next();
 265     } else {
 266       prev-&gt;set_next(entry-&gt;next());
 267     }
 268     assert(_entry_count &gt; 0, &quot;checking&quot;);
 269     _entry_count--;
 270   }
 271 
 272   // resizing switch
 273   bool is_resizing_enabled() const          { return _resizing_enabled; }
 274   void set_resizing_enabled(bool enable)    { _resizing_enabled = enable; }
 275 
 276   // debugging
 277   void print_memory_usage();
 278   void compute_next_trace_threshold();
 279 
 280  public:
 281 
 282   // create a JvmtiTagHashmap of a preferred size and optionally a load factor.
 283   // The preferred size is rounded down to an actual size.
 284   JvmtiTagHashmap(int size, float load_factor=0.0f) {
 285     int i=0;
 286     while (_sizes[i] &lt; size) {
 287       if (_sizes[i] &lt; 0) {
 288         assert(i &gt; 0, &quot;sanity check&quot;);
 289         i--;
 290         break;
 291       }
 292       i++;
 293     }
 294 
 295     // if a load factor is specified then use it, otherwise use default
 296     if (load_factor &gt; 0.01f) {
 297       init(i, load_factor);
 298     } else {
 299       init(i);
 300     }
 301   }
 302 
 303   // create a JvmtiTagHashmap with default settings
 304   JvmtiTagHashmap() {
 305     init();
 306   }
 307 
 308   // release table when JvmtiTagHashmap destroyed
 309   ~JvmtiTagHashmap() {
 310     if (_table != NULL) {
 311       os::free((void*)_table);
 312       _table = NULL;
 313     }
 314   }
 315 
 316   // accessors
 317   int size() const                              { return _size; }
 318   JvmtiTagHashmapEntry** table() const          { return _table; }
 319   int entry_count() const                       { return _entry_count; }
 320 
 321   // find an entry in the hashmap, returns NULL if not found.
 322   inline JvmtiTagHashmapEntry* find(oop key) {
 323     unsigned int h = hash(key);
 324     JvmtiTagHashmapEntry* entry = _table[h];
 325     while (entry != NULL) {
 326       if (entry-&gt;equals(key)) {
 327          return entry;
 328       }
 329       entry = entry-&gt;next();
 330     }
 331     return NULL;
 332   }
 333 
 334 
 335   // add a new entry to hashmap
 336   inline void add(oop key, JvmtiTagHashmapEntry* entry) {
 337     assert(key != NULL, &quot;checking&quot;);
 338     assert(find(key) == NULL, &quot;duplicate detected&quot;);
 339     unsigned int h = hash(key);
 340     JvmtiTagHashmapEntry* anchor = _table[h];
 341     if (anchor == NULL) {
 342       _table[h] = entry;
 343       entry-&gt;set_next(NULL);
 344     } else {
 345       entry-&gt;set_next(anchor);
 346       _table[h] = entry;
 347     }
 348 
 349     _entry_count++;
 350     if (log_is_enabled(Debug, jvmti, objecttagging) &amp;&amp; entry_count() &gt;= trace_threshold()) {
 351       print_memory_usage();
 352       compute_next_trace_threshold();
 353     }
 354 
 355     // if the number of entries exceed the threshold then resize
 356     if (entry_count() &gt; resize_threshold() &amp;&amp; is_resizing_enabled()) {
 357       resize();
 358     }
 359   }
 360 
 361   // remove an entry with the given key.
 362   inline JvmtiTagHashmapEntry* remove(oop key) {
 363     unsigned int h = hash(key);
 364     JvmtiTagHashmapEntry* entry = _table[h];
 365     JvmtiTagHashmapEntry* prev = NULL;
 366     while (entry != NULL) {
 367       if (entry-&gt;equals(key)) {
 368         break;
 369       }
 370       prev = entry;
 371       entry = entry-&gt;next();
 372     }
 373     if (entry != NULL) {
 374       remove(prev, h, entry);
 375     }
 376     return entry;
 377   }
 378 
 379   // iterate over all entries in the hashmap
 380   void entry_iterate(JvmtiTagHashmapEntryClosure* closure);
 381 };
 382 
<a name="2" id="anc2"></a><span class="line-added"> 383 // Tsan should know that the JVMTI TagMap is protected by a mutex.</span>
<span class="line-added"> 384 class TsanMutexScope : public StackObj {</span>
<span class="line-added"> 385  private:</span>
<span class="line-added"> 386   Mutex *_lock;  // Keep my own reference, for destructor.</span>
<span class="line-added"> 387 </span>
<span class="line-added"> 388  public:</span>
<span class="line-added"> 389   // Don&#39;t actually lock it, just tell tsan we did.</span>
<span class="line-added"> 390   TsanMutexScope(Mutex* mutex) : _lock(mutex) {</span>
<span class="line-added"> 391     TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(_lock));</span>
<span class="line-added"> 392   }</span>
<span class="line-added"> 393 </span>
<span class="line-added"> 394   ~TsanMutexScope() {</span>
<span class="line-added"> 395     TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(_lock));</span>
<span class="line-added"> 396   }</span>
<span class="line-added"> 397 };</span>
<span class="line-added"> 398 </span>
 399 // possible hashmap sizes - odd primes that roughly double in size.
 400 // To avoid excessive resizing the odd primes from 4801-76831 and
 401 // 76831-307261 have been removed. The list must be terminated by -1.
 402 int JvmtiTagHashmap::_sizes[] =  { 4801, 76831, 307261, 614563, 1228891,
 403     2457733, 4915219, 9830479, 19660831, 39321619, 78643219, -1 };
 404 
 405 
 406 // A supporting class for iterating over all entries in Hashmap
 407 class JvmtiTagHashmapEntryClosure {
 408  public:
 409   virtual void do_entry(JvmtiTagHashmapEntry* entry) = 0;
 410 };
 411 
 412 
 413 // iterate over all entries in the hashmap
 414 void JvmtiTagHashmap::entry_iterate(JvmtiTagHashmapEntryClosure* closure) {
 415   for (int i=0; i&lt;_size; i++) {
 416     JvmtiTagHashmapEntry* entry = _table[i];
 417     JvmtiTagHashmapEntry* prev = NULL;
 418     while (entry != NULL) {
 419       // obtain the next entry before invoking do_entry - this is
 420       // necessary because do_entry may remove the entry from the
 421       // hashmap.
 422       JvmtiTagHashmapEntry* next = entry-&gt;next();
 423       closure-&gt;do_entry(entry);
 424       entry = next;
 425      }
 426   }
 427 }
 428 
 429 // debugging
 430 void JvmtiTagHashmap::print_memory_usage() {
 431   intptr_t p = (intptr_t)this;
 432   tty-&gt;print(&quot;[JvmtiTagHashmap @ &quot; INTPTR_FORMAT, p);
 433 
 434   // table + entries in KB
 435   int hashmap_usage = (size()*sizeof(JvmtiTagHashmapEntry*) +
 436     entry_count()*sizeof(JvmtiTagHashmapEntry))/K;
 437 
 438   int weak_globals_usage = (int)(JNIHandles::weak_global_handle_memory_usage()/K);
 439   tty-&gt;print_cr(&quot;, %d entries (%d KB) &lt;JNI weak globals: %d KB&gt;]&quot;,
 440     entry_count(), hashmap_usage, weak_globals_usage);
 441 }
 442 
 443 // compute threshold for the next trace message
 444 void JvmtiTagHashmap::compute_next_trace_threshold() {
 445   _trace_threshold = entry_count();
 446   if (trace_threshold() &lt; medium_trace_threshold) {
 447     _trace_threshold += small_trace_threshold;
 448   } else {
 449     if (trace_threshold() &lt; large_trace_threshold) {
 450       _trace_threshold += medium_trace_threshold;
 451     } else {
 452       _trace_threshold += large_trace_threshold;
 453     }
 454   }
 455 }
 456 
 457 // create a JvmtiTagMap
 458 JvmtiTagMap::JvmtiTagMap(JvmtiEnv* env) :
 459   _env(env),
 460   _lock(Mutex::nonleaf+2, &quot;JvmtiTagMap._lock&quot;, false),
 461   _free_entries(NULL),
 462   _free_entries_count(0)
 463 {
 464   assert(JvmtiThreadState_lock-&gt;is_locked(), &quot;sanity check&quot;);
 465   assert(((JvmtiEnvBase *)env)-&gt;tag_map() == NULL, &quot;tag map already exists for environment&quot;);
 466 
<a name="3" id="anc3"></a><span class="line-added"> 467   // TSAN Note: we cannot tell TSAN about the creation of this lock due to</span>
<span class="line-added"> 468   // this being seen as racy though is not really.</span>
<span class="line-added"> 469   //</span>
<span class="line-added"> 470   // The JvmtiTagMap gets created by the first thread to call tag_map_for; which</span>
<span class="line-added"> 471   // uses a lock to create it if need be.</span>
<span class="line-added"> 472   //</span>
<span class="line-added"> 473   // This means that this lock is created under a mutex but then,</span>
<span class="line-added"> 474   // subsequent uses do not have a lock to protect it (because not</span>
<span class="line-added"> 475   // needed in this case), however TSAN sees it as being needed because:</span>
<span class="line-added"> 476   //  - Another thread can come and get the newly created JvmtiTagMap without a</span>
<span class="line-added"> 477   //  lock and acquire the lock.</span>
<span class="line-added"> 478   //  - This provokes a race for TSAN on the lock itself, though there is no</span>
<span class="line-added"> 479   //  real issue.</span>
<span class="line-added"> 480   //</span>
<span class="line-added"> 481   //  Not creating the lock or having a fence mechanism to tell TSAN this is</span>
<span class="line-added"> 482   //  safe (a fake lock around this lock for example) seem to be the only</span>
<span class="line-added"> 483   //  solutions.</span>
<span class="line-added"> 484 </span>
 485   _hashmap = new JvmtiTagHashmap();
 486 
 487   // finally add us to the environment
 488   ((JvmtiEnvBase *)env)-&gt;release_set_tag_map(this);
 489 }
 490 
 491 
 492 // destroy a JvmtiTagMap
 493 JvmtiTagMap::~JvmtiTagMap() {
<a name="4" id="anc4"></a>
 494   // no lock acquired as we assume the enclosing environment is
 495   // also being destroryed.
 496   ((JvmtiEnvBase *)_env)-&gt;set_tag_map(NULL);
 497 
 498   JvmtiTagHashmapEntry** table = _hashmap-&gt;table();
 499   for (int j = 0; j &lt; _hashmap-&gt;size(); j++) {
 500     JvmtiTagHashmapEntry* entry = table[j];
 501     while (entry != NULL) {
 502       JvmtiTagHashmapEntry* next = entry-&gt;next();
 503       delete entry;
 504       entry = next;
 505     }
 506   }
 507 
 508   // finally destroy the hashmap
 509   delete _hashmap;
 510   _hashmap = NULL;
 511 
 512   // remove any entries on the free list
 513   JvmtiTagHashmapEntry* entry = _free_entries;
 514   while (entry != NULL) {
 515     JvmtiTagHashmapEntry* next = entry-&gt;next();
 516     delete entry;
 517     entry = next;
 518   }
 519   _free_entries = NULL;
<a name="5" id="anc5"></a><span class="line-added"> 520 </span>
<span class="line-added"> 521   // TSAN Note: see above for the Tsan creation note.</span>
 522 }
 523 
 524 // create a hashmap entry
 525 // - if there&#39;s an entry on the (per-environment) free list then this
 526 // is returned. Otherwise an new entry is allocated.
 527 JvmtiTagHashmapEntry* JvmtiTagMap::create_entry(oop ref, jlong tag) {
 528   assert(Thread::current()-&gt;is_VM_thread() || is_locked(), &quot;checking&quot;);
 529 
 530   // ref was read with AS_NO_KEEPALIVE, or equivalent.
 531   // The object needs to be kept alive when it is published.
 532   Universe::heap()-&gt;keep_alive(ref);
 533 
 534   JvmtiTagHashmapEntry* entry;
 535   if (_free_entries == NULL) {
 536     entry = new JvmtiTagHashmapEntry(ref, tag);
 537   } else {
 538     assert(_free_entries_count &gt; 0, &quot;mismatched _free_entries_count&quot;);
 539     _free_entries_count--;
 540     entry = _free_entries;
 541     _free_entries = entry-&gt;next();
 542     entry-&gt;init(ref, tag);
 543   }
 544   return entry;
 545 }
 546 
 547 // destroy an entry by returning it to the free list
 548 void JvmtiTagMap::destroy_entry(JvmtiTagHashmapEntry* entry) {
 549   assert(SafepointSynchronize::is_at_safepoint() || is_locked(), &quot;checking&quot;);
 550   // limit the size of the free list
 551   if (_free_entries_count &gt;= max_free_entries) {
 552     delete entry;
 553   } else {
 554     entry-&gt;set_next(_free_entries);
 555     _free_entries = entry;
 556     _free_entries_count++;
 557   }
 558 }
 559 
 560 // returns the tag map for the given environments. If the tag map
 561 // doesn&#39;t exist then it is created.
 562 JvmtiTagMap* JvmtiTagMap::tag_map_for(JvmtiEnv* env) {
 563   JvmtiTagMap* tag_map = ((JvmtiEnvBase*)env)-&gt;tag_map_acquire();
 564   if (tag_map == NULL) {
 565     MutexLocker mu(JvmtiThreadState_lock);
 566     tag_map = ((JvmtiEnvBase*)env)-&gt;tag_map();
 567     if (tag_map == NULL) {
 568       tag_map = new JvmtiTagMap(env);
 569     }
 570   } else {
 571     DEBUG_ONLY(Thread::current()-&gt;check_possible_safepoint());
 572   }
 573   return tag_map;
 574 }
 575 
 576 // iterate over all entries in the tag map.
 577 void JvmtiTagMap::entry_iterate(JvmtiTagHashmapEntryClosure* closure) {
 578   hashmap()-&gt;entry_iterate(closure);
 579 }
 580 
 581 // returns true if the hashmaps are empty
 582 bool JvmtiTagMap::is_empty() {
 583   assert(SafepointSynchronize::is_at_safepoint() || is_locked(), &quot;checking&quot;);
 584   return hashmap()-&gt;entry_count() == 0;
 585 }
 586 
 587 
 588 // Return the tag value for an object, or 0 if the object is
 589 // not tagged
 590 //
 591 static inline jlong tag_for(JvmtiTagMap* tag_map, oop o) {
 592   JvmtiTagHashmapEntry* entry = tag_map-&gt;hashmap()-&gt;find(o);
 593   if (entry == NULL) {
 594     return 0;
 595   } else {
 596     return entry-&gt;tag();
 597   }
 598 }
 599 
 600 
 601 // A CallbackWrapper is a support class for querying and tagging an object
 602 // around a callback to a profiler. The constructor does pre-callback
 603 // work to get the tag value, klass tag value, ... and the destructor
 604 // does the post-callback work of tagging or untagging the object.
 605 //
 606 // {
 607 //   CallbackWrapper wrapper(tag_map, o);
 608 //
 609 //   (*callback)(wrapper.klass_tag(), wrapper.obj_size(), wrapper.obj_tag_p(), ...)
 610 //
 611 // } // wrapper goes out of scope here which results in the destructor
 612 //      checking to see if the object has been tagged, untagged, or the
 613 //      tag value has changed.
 614 //
 615 class CallbackWrapper : public StackObj {
 616  private:
 617   JvmtiTagMap* _tag_map;
 618   JvmtiTagHashmap* _hashmap;
 619   JvmtiTagHashmapEntry* _entry;
 620   oop _o;
 621   jlong _obj_size;
 622   jlong _obj_tag;
 623   jlong _klass_tag;
 624 
 625  protected:
 626   JvmtiTagMap* tag_map() const      { return _tag_map; }
 627 
 628   // invoked post-callback to tag, untag, or update the tag of an object
 629   void inline post_callback_tag_update(oop o, JvmtiTagHashmap* hashmap,
 630                                        JvmtiTagHashmapEntry* entry, jlong obj_tag);
 631  public:
 632   CallbackWrapper(JvmtiTagMap* tag_map, oop o) {
 633     assert(Thread::current()-&gt;is_VM_thread() || tag_map-&gt;is_locked(),
 634            &quot;MT unsafe or must be VM thread&quot;);
 635 
 636     // object to tag
 637     _o = o;
 638 
 639     // object size
 640     _obj_size = (jlong)_o-&gt;size() * wordSize;
 641 
 642     // record the context
 643     _tag_map = tag_map;
 644     _hashmap = tag_map-&gt;hashmap();
 645     _entry = _hashmap-&gt;find(_o);
 646 
 647     // get object tag
 648     _obj_tag = (_entry == NULL) ? 0 : _entry-&gt;tag();
 649 
 650     // get the class and the class&#39;s tag value
 651     assert(SystemDictionary::Class_klass()-&gt;is_mirror_instance_klass(), &quot;Is not?&quot;);
 652 
 653     _klass_tag = tag_for(tag_map, _o-&gt;klass()-&gt;java_mirror());
 654   }
 655 
 656   ~CallbackWrapper() {
 657     post_callback_tag_update(_o, _hashmap, _entry, _obj_tag);
 658   }
 659 
 660   inline jlong* obj_tag_p()                     { return &amp;_obj_tag; }
 661   inline jlong obj_size() const                 { return _obj_size; }
 662   inline jlong obj_tag() const                  { return _obj_tag; }
 663   inline jlong klass_tag() const                { return _klass_tag; }
 664 };
 665 
 666 
 667 
 668 // callback post-callback to tag, untag, or update the tag of an object
 669 void inline CallbackWrapper::post_callback_tag_update(oop o,
 670                                                       JvmtiTagHashmap* hashmap,
 671                                                       JvmtiTagHashmapEntry* entry,
 672                                                       jlong obj_tag) {
 673   if (entry == NULL) {
 674     if (obj_tag != 0) {
 675       // callback has tagged the object
 676       assert(Thread::current()-&gt;is_VM_thread(), &quot;must be VMThread&quot;);
 677       entry = tag_map()-&gt;create_entry(o, obj_tag);
 678       hashmap-&gt;add(o, entry);
 679     }
 680   } else {
 681     // object was previously tagged - the callback may have untagged
 682     // the object or changed the tag value
 683     if (obj_tag == 0) {
 684 
 685       JvmtiTagHashmapEntry* entry_removed = hashmap-&gt;remove(o);
 686       assert(entry_removed == entry, &quot;checking&quot;);
 687       tag_map()-&gt;destroy_entry(entry);
 688 
 689     } else {
 690       if (obj_tag != entry-&gt;tag()) {
 691          entry-&gt;set_tag(obj_tag);
 692       }
 693     }
 694   }
 695 }
 696 
 697 // An extended CallbackWrapper used when reporting an object reference
 698 // to the agent.
 699 //
 700 // {
 701 //   TwoOopCallbackWrapper wrapper(tag_map, referrer, o);
 702 //
 703 //   (*callback)(wrapper.klass_tag(),
 704 //               wrapper.obj_size(),
 705 //               wrapper.obj_tag_p()
 706 //               wrapper.referrer_tag_p(), ...)
 707 //
 708 // } // wrapper goes out of scope here which results in the destructor
 709 //      checking to see if the referrer object has been tagged, untagged,
 710 //      or the tag value has changed.
 711 //
 712 class TwoOopCallbackWrapper : public CallbackWrapper {
 713  private:
 714   bool _is_reference_to_self;
 715   JvmtiTagHashmap* _referrer_hashmap;
 716   JvmtiTagHashmapEntry* _referrer_entry;
 717   oop _referrer;
 718   jlong _referrer_obj_tag;
 719   jlong _referrer_klass_tag;
 720   jlong* _referrer_tag_p;
 721 
 722   bool is_reference_to_self() const             { return _is_reference_to_self; }
 723 
 724  public:
 725   TwoOopCallbackWrapper(JvmtiTagMap* tag_map, oop referrer, oop o) :
 726     CallbackWrapper(tag_map, o)
 727   {
 728     // self reference needs to be handled in a special way
 729     _is_reference_to_self = (referrer == o);
 730 
 731     if (_is_reference_to_self) {
 732       _referrer_klass_tag = klass_tag();
 733       _referrer_tag_p = obj_tag_p();
 734     } else {
 735       _referrer = referrer;
 736       // record the context
 737       _referrer_hashmap = tag_map-&gt;hashmap();
 738       _referrer_entry = _referrer_hashmap-&gt;find(_referrer);
 739 
 740       // get object tag
 741       _referrer_obj_tag = (_referrer_entry == NULL) ? 0 : _referrer_entry-&gt;tag();
 742       _referrer_tag_p = &amp;_referrer_obj_tag;
 743 
 744       // get referrer class tag.
 745       _referrer_klass_tag = tag_for(tag_map, _referrer-&gt;klass()-&gt;java_mirror());
 746     }
 747   }
 748 
 749   ~TwoOopCallbackWrapper() {
 750     if (!is_reference_to_self()){
 751       post_callback_tag_update(_referrer,
 752                                _referrer_hashmap,
 753                                _referrer_entry,
 754                                _referrer_obj_tag);
 755     }
 756   }
 757 
 758   // address of referrer tag
 759   // (for a self reference this will return the same thing as obj_tag_p())
 760   inline jlong* referrer_tag_p()        { return _referrer_tag_p; }
 761 
 762   // referrer&#39;s class tag
 763   inline jlong referrer_klass_tag()     { return _referrer_klass_tag; }
 764 };
 765 
 766 // tag an object
 767 //
 768 // This function is performance critical. If many threads attempt to tag objects
 769 // around the same time then it&#39;s possible that the Mutex associated with the
 770 // tag map will be a hot lock.
 771 void JvmtiTagMap::set_tag(jobject object, jlong tag) {
 772   MutexLocker ml(lock());
<a name="6" id="anc6"></a><span class="line-added"> 773   TSAN_ONLY(TsanMutexScope tms(lock()));</span>
 774 
 775   // resolve the object
 776   oop o = JNIHandles::resolve_non_null(object);
 777 
 778   // see if the object is already tagged
 779   JvmtiTagHashmap* hashmap = _hashmap;
 780   JvmtiTagHashmapEntry* entry = hashmap-&gt;find(o);
 781 
 782   // if the object is not already tagged then we tag it
 783   if (entry == NULL) {
 784     if (tag != 0) {
 785       entry = create_entry(o, tag);
 786       hashmap-&gt;add(o, entry);
 787     } else {
 788       // no-op
 789     }
 790   } else {
 791     // if the object is already tagged then we either update
 792     // the tag (if a new tag value has been provided)
 793     // or remove the object if the new tag value is 0.
 794     if (tag == 0) {
 795       hashmap-&gt;remove(o);
 796       destroy_entry(entry);
 797     } else {
 798       entry-&gt;set_tag(tag);
 799     }
 800   }
 801 }
 802 
 803 // get the tag for an object
 804 jlong JvmtiTagMap::get_tag(jobject object) {
 805   MutexLocker ml(lock());
<a name="7" id="anc7"></a><span class="line-added"> 806   TSAN_ONLY(TsanMutexScope tms(lock()));</span>
 807 
 808   // resolve the object
 809   oop o = JNIHandles::resolve_non_null(object);
 810 
 811   return tag_for(this, o);
 812 }
 813 
 814 
 815 // Helper class used to describe the static or instance fields of a class.
 816 // For each field it holds the field index (as defined by the JVMTI specification),
 817 // the field type, and the offset.
 818 
 819 class ClassFieldDescriptor: public CHeapObj&lt;mtInternal&gt; {
 820  private:
 821   int _field_index;
 822   int _field_offset;
 823   char _field_type;
 824  public:
 825   ClassFieldDescriptor(int index, char type, int offset) :
 826     _field_index(index), _field_offset(offset), _field_type(type) {
 827   }
 828   int field_index()  const  { return _field_index; }
 829   char field_type()  const  { return _field_type; }
 830   int field_offset() const  { return _field_offset; }
 831 };
 832 
 833 class ClassFieldMap: public CHeapObj&lt;mtInternal&gt; {
 834  private:
 835   enum {
 836     initial_field_count = 5
 837   };
 838 
 839   // list of field descriptors
 840   GrowableArray&lt;ClassFieldDescriptor*&gt;* _fields;
 841 
 842   // constructor
 843   ClassFieldMap();
 844 
 845   // add a field
 846   void add(int index, char type, int offset);
 847 
 848   // returns the field count for the given class
 849   static int compute_field_count(InstanceKlass* ik);
 850 
 851  public:
 852   ~ClassFieldMap();
 853 
 854   // access
 855   int field_count()                     { return _fields-&gt;length(); }
 856   ClassFieldDescriptor* field_at(int i) { return _fields-&gt;at(i); }
 857 
 858   // functions to create maps of static or instance fields
 859   static ClassFieldMap* create_map_of_static_fields(Klass* k);
 860   static ClassFieldMap* create_map_of_instance_fields(oop obj);
 861 };
 862 
 863 ClassFieldMap::ClassFieldMap() {
 864   _fields = new (ResourceObj::C_HEAP, mtInternal)
 865     GrowableArray&lt;ClassFieldDescriptor*&gt;(initial_field_count, true);
 866 }
 867 
 868 ClassFieldMap::~ClassFieldMap() {
 869   for (int i=0; i&lt;_fields-&gt;length(); i++) {
 870     delete _fields-&gt;at(i);
 871   }
 872   delete _fields;
 873 }
 874 
 875 void ClassFieldMap::add(int index, char type, int offset) {
 876   ClassFieldDescriptor* field = new ClassFieldDescriptor(index, type, offset);
 877   _fields-&gt;append(field);
 878 }
 879 
 880 // Returns a heap allocated ClassFieldMap to describe the static fields
 881 // of the given class.
 882 //
 883 ClassFieldMap* ClassFieldMap::create_map_of_static_fields(Klass* k) {
 884   HandleMark hm;
 885   InstanceKlass* ik = InstanceKlass::cast(k);
 886 
 887   // create the field map
 888   ClassFieldMap* field_map = new ClassFieldMap();
 889 
 890   FilteredFieldStream f(ik, false, false);
 891   int max_field_index = f.field_count()-1;
 892 
 893   int index = 0;
 894   for (FilteredFieldStream fld(ik, true, true); !fld.eos(); fld.next(), index++) {
 895     // ignore instance fields
 896     if (!fld.access_flags().is_static()) {
 897       continue;
 898     }
 899     field_map-&gt;add(max_field_index - index, fld.signature()-&gt;char_at(0), fld.offset());
 900   }
 901   return field_map;
 902 }
 903 
 904 // Returns a heap allocated ClassFieldMap to describe the instance fields
 905 // of the given class. All instance fields are included (this means public
 906 // and private fields declared in superclasses and superinterfaces too).
 907 //
 908 ClassFieldMap* ClassFieldMap::create_map_of_instance_fields(oop obj) {
 909   HandleMark hm;
 910   InstanceKlass* ik = InstanceKlass::cast(obj-&gt;klass());
 911 
 912   // create the field map
 913   ClassFieldMap* field_map = new ClassFieldMap();
 914 
 915   FilteredFieldStream f(ik, false, false);
 916 
 917   int max_field_index = f.field_count()-1;
 918 
 919   int index = 0;
 920   for (FilteredFieldStream fld(ik, false, false); !fld.eos(); fld.next(), index++) {
 921     // ignore static fields
 922     if (fld.access_flags().is_static()) {
 923       continue;
 924     }
 925     field_map-&gt;add(max_field_index - index, fld.signature()-&gt;char_at(0), fld.offset());
 926   }
 927 
 928   return field_map;
 929 }
 930 
 931 // Helper class used to cache a ClassFileMap for the instance fields of
 932 // a cache. A JvmtiCachedClassFieldMap can be cached by an InstanceKlass during
 933 // heap iteration and avoid creating a field map for each object in the heap
 934 // (only need to create the map when the first instance of a class is encountered).
 935 //
 936 class JvmtiCachedClassFieldMap : public CHeapObj&lt;mtInternal&gt; {
 937  private:
 938    enum {
 939      initial_class_count = 200
 940    };
 941   ClassFieldMap* _field_map;
 942 
 943   ClassFieldMap* field_map() const          { return _field_map; }
 944 
 945   JvmtiCachedClassFieldMap(ClassFieldMap* field_map);
 946   ~JvmtiCachedClassFieldMap();
 947 
 948   static GrowableArray&lt;InstanceKlass*&gt;* _class_list;
 949   static void add_to_class_list(InstanceKlass* ik);
 950 
 951  public:
 952   // returns the field map for a given object (returning map cached
 953   // by InstanceKlass if possible
 954   static ClassFieldMap* get_map_of_instance_fields(oop obj);
 955 
 956   // removes the field map from all instanceKlasses - should be
 957   // called before VM operation completes
 958   static void clear_cache();
 959 
 960   // returns the number of ClassFieldMap cached by instanceKlasses
 961   static int cached_field_map_count();
 962 };
 963 
 964 GrowableArray&lt;InstanceKlass*&gt;* JvmtiCachedClassFieldMap::_class_list;
 965 
 966 JvmtiCachedClassFieldMap::JvmtiCachedClassFieldMap(ClassFieldMap* field_map) {
 967   _field_map = field_map;
 968 }
 969 
 970 JvmtiCachedClassFieldMap::~JvmtiCachedClassFieldMap() {
 971   if (_field_map != NULL) {
 972     delete _field_map;
 973   }
 974 }
 975 
 976 // Marker class to ensure that the class file map cache is only used in a defined
 977 // scope.
 978 class ClassFieldMapCacheMark : public StackObj {
 979  private:
 980    static bool _is_active;
 981  public:
 982    ClassFieldMapCacheMark() {
 983      assert(Thread::current()-&gt;is_VM_thread(), &quot;must be VMThread&quot;);
 984      assert(JvmtiCachedClassFieldMap::cached_field_map_count() == 0, &quot;cache not empty&quot;);
 985      assert(!_is_active, &quot;ClassFieldMapCacheMark cannot be nested&quot;);
 986      _is_active = true;
 987    }
 988    ~ClassFieldMapCacheMark() {
 989      JvmtiCachedClassFieldMap::clear_cache();
 990      _is_active = false;
 991    }
 992    static bool is_active() { return _is_active; }
 993 };
 994 
 995 bool ClassFieldMapCacheMark::_is_active;
 996 
 997 
 998 // record that the given InstanceKlass is caching a field map
 999 void JvmtiCachedClassFieldMap::add_to_class_list(InstanceKlass* ik) {
1000   if (_class_list == NULL) {
1001     _class_list = new (ResourceObj::C_HEAP, mtInternal)
1002       GrowableArray&lt;InstanceKlass*&gt;(initial_class_count, true);
1003   }
1004   _class_list-&gt;push(ik);
1005 }
1006 
1007 // returns the instance field map for the given object
1008 // (returns field map cached by the InstanceKlass if possible)
1009 ClassFieldMap* JvmtiCachedClassFieldMap::get_map_of_instance_fields(oop obj) {
1010   assert(Thread::current()-&gt;is_VM_thread(), &quot;must be VMThread&quot;);
1011   assert(ClassFieldMapCacheMark::is_active(), &quot;ClassFieldMapCacheMark not active&quot;);
1012 
1013   Klass* k = obj-&gt;klass();
1014   InstanceKlass* ik = InstanceKlass::cast(k);
1015 
1016   // return cached map if possible
1017   JvmtiCachedClassFieldMap* cached_map = ik-&gt;jvmti_cached_class_field_map();
1018   if (cached_map != NULL) {
1019     assert(cached_map-&gt;field_map() != NULL, &quot;missing field list&quot;);
1020     return cached_map-&gt;field_map();
1021   } else {
1022     ClassFieldMap* field_map = ClassFieldMap::create_map_of_instance_fields(obj);
1023     cached_map = new JvmtiCachedClassFieldMap(field_map);
1024     ik-&gt;set_jvmti_cached_class_field_map(cached_map);
1025     add_to_class_list(ik);
1026     return field_map;
1027   }
1028 }
1029 
1030 // remove the fields maps cached from all instanceKlasses
1031 void JvmtiCachedClassFieldMap::clear_cache() {
1032   assert(Thread::current()-&gt;is_VM_thread(), &quot;must be VMThread&quot;);
1033   if (_class_list != NULL) {
1034     for (int i = 0; i &lt; _class_list-&gt;length(); i++) {
1035       InstanceKlass* ik = _class_list-&gt;at(i);
1036       JvmtiCachedClassFieldMap* cached_map = ik-&gt;jvmti_cached_class_field_map();
1037       assert(cached_map != NULL, &quot;should not be NULL&quot;);
1038       ik-&gt;set_jvmti_cached_class_field_map(NULL);
1039       delete cached_map;  // deletes the encapsulated field map
1040     }
1041     delete _class_list;
1042     _class_list = NULL;
1043   }
1044 }
1045 
1046 // returns the number of ClassFieldMap cached by instanceKlasses
1047 int JvmtiCachedClassFieldMap::cached_field_map_count() {
1048   return (_class_list == NULL) ? 0 : _class_list-&gt;length();
1049 }
1050 
1051 // helper function to indicate if an object is filtered by its tag or class tag
1052 static inline bool is_filtered_by_heap_filter(jlong obj_tag,
1053                                               jlong klass_tag,
1054                                               int heap_filter) {
1055   // apply the heap filter
1056   if (obj_tag != 0) {
1057     // filter out tagged objects
1058     if (heap_filter &amp; JVMTI_HEAP_FILTER_TAGGED) return true;
1059   } else {
1060     // filter out untagged objects
1061     if (heap_filter &amp; JVMTI_HEAP_FILTER_UNTAGGED) return true;
1062   }
1063   if (klass_tag != 0) {
1064     // filter out objects with tagged classes
1065     if (heap_filter &amp; JVMTI_HEAP_FILTER_CLASS_TAGGED) return true;
1066   } else {
1067     // filter out objects with untagged classes.
1068     if (heap_filter &amp; JVMTI_HEAP_FILTER_CLASS_UNTAGGED) return true;
1069   }
1070   return false;
1071 }
1072 
1073 // helper function to indicate if an object is filtered by a klass filter
1074 static inline bool is_filtered_by_klass_filter(oop obj, Klass* klass_filter) {
1075   if (klass_filter != NULL) {
1076     if (obj-&gt;klass() != klass_filter) {
1077       return true;
1078     }
1079   }
1080   return false;
1081 }
1082 
1083 // helper function to tell if a field is a primitive field or not
1084 static inline bool is_primitive_field_type(char type) {
1085   return (type != JVM_SIGNATURE_CLASS &amp;&amp; type != JVM_SIGNATURE_ARRAY);
1086 }
1087 
1088 // helper function to copy the value from location addr to jvalue.
1089 static inline void copy_to_jvalue(jvalue *v, address addr, jvmtiPrimitiveType value_type) {
1090   switch (value_type) {
1091     case JVMTI_PRIMITIVE_TYPE_BOOLEAN : { v-&gt;z = *(jboolean*)addr; break; }
1092     case JVMTI_PRIMITIVE_TYPE_BYTE    : { v-&gt;b = *(jbyte*)addr;    break; }
1093     case JVMTI_PRIMITIVE_TYPE_CHAR    : { v-&gt;c = *(jchar*)addr;    break; }
1094     case JVMTI_PRIMITIVE_TYPE_SHORT   : { v-&gt;s = *(jshort*)addr;   break; }
1095     case JVMTI_PRIMITIVE_TYPE_INT     : { v-&gt;i = *(jint*)addr;     break; }
1096     case JVMTI_PRIMITIVE_TYPE_LONG    : { v-&gt;j = *(jlong*)addr;    break; }
1097     case JVMTI_PRIMITIVE_TYPE_FLOAT   : { v-&gt;f = *(jfloat*)addr;   break; }
1098     case JVMTI_PRIMITIVE_TYPE_DOUBLE  : { v-&gt;d = *(jdouble*)addr;  break; }
1099     default: ShouldNotReachHere();
1100   }
1101 }
1102 
1103 // helper function to invoke string primitive value callback
1104 // returns visit control flags
1105 static jint invoke_string_value_callback(jvmtiStringPrimitiveValueCallback cb,
1106                                          CallbackWrapper* wrapper,
1107                                          oop str,
1108                                          void* user_data)
1109 {
1110   assert(str-&gt;klass() == SystemDictionary::String_klass(), &quot;not a string&quot;);
1111 
1112   typeArrayOop s_value = java_lang_String::value(str);
1113 
1114   // JDK-6584008: the value field may be null if a String instance is
1115   // partially constructed.
1116   if (s_value == NULL) {
1117     return 0;
1118   }
1119   // get the string value and length
1120   // (string value may be offset from the base)
1121   int s_len = java_lang_String::length(str);
1122   bool is_latin1 = java_lang_String::is_latin1(str);
1123   jchar* value;
1124   if (s_len &gt; 0) {
1125     if (!is_latin1) {
1126       value = s_value-&gt;char_at_addr(0);
1127     } else {
1128       // Inflate latin1 encoded string to UTF16
1129       jchar* buf = NEW_C_HEAP_ARRAY(jchar, s_len, mtInternal);
1130       for (int i = 0; i &lt; s_len; i++) {
1131         buf[i] = ((jchar) s_value-&gt;byte_at(i)) &amp; 0xff;
1132       }
1133       value = &amp;buf[0];
1134     }
1135   } else {
1136     // Don&#39;t use char_at_addr(0) if length is 0
1137     value = (jchar*) s_value-&gt;base(T_CHAR);
1138   }
1139 
1140   // invoke the callback
1141   jint res = (*cb)(wrapper-&gt;klass_tag(),
1142                    wrapper-&gt;obj_size(),
1143                    wrapper-&gt;obj_tag_p(),
1144                    value,
1145                    (jint)s_len,
1146                    user_data);
1147 
1148   if (is_latin1 &amp;&amp; s_len &gt; 0) {
1149     FREE_C_HEAP_ARRAY(jchar, value);
1150   }
1151   return res;
1152 }
1153 
1154 // helper function to invoke string primitive value callback
1155 // returns visit control flags
1156 static jint invoke_array_primitive_value_callback(jvmtiArrayPrimitiveValueCallback cb,
1157                                                   CallbackWrapper* wrapper,
1158                                                   oop obj,
1159                                                   void* user_data)
1160 {
1161   assert(obj-&gt;is_typeArray(), &quot;not a primitive array&quot;);
1162 
1163   // get base address of first element
1164   typeArrayOop array = typeArrayOop(obj);
1165   BasicType type = TypeArrayKlass::cast(array-&gt;klass())-&gt;element_type();
1166   void* elements = array-&gt;base(type);
1167 
1168   // jvmtiPrimitiveType is defined so this mapping is always correct
1169   jvmtiPrimitiveType elem_type = (jvmtiPrimitiveType)type2char(type);
1170 
1171   return (*cb)(wrapper-&gt;klass_tag(),
1172                wrapper-&gt;obj_size(),
1173                wrapper-&gt;obj_tag_p(),
1174                (jint)array-&gt;length(),
1175                elem_type,
1176                elements,
1177                user_data);
1178 }
1179 
1180 // helper function to invoke the primitive field callback for all static fields
1181 // of a given class
1182 static jint invoke_primitive_field_callback_for_static_fields
1183   (CallbackWrapper* wrapper,
1184    oop obj,
1185    jvmtiPrimitiveFieldCallback cb,
1186    void* user_data)
1187 {
1188   // for static fields only the index will be set
1189   static jvmtiHeapReferenceInfo reference_info = { 0 };
1190 
1191   assert(obj-&gt;klass() == SystemDictionary::Class_klass(), &quot;not a class&quot;);
1192   if (java_lang_Class::is_primitive(obj)) {
1193     return 0;
1194   }
1195   Klass* klass = java_lang_Class::as_Klass(obj);
1196 
1197   // ignore classes for object and type arrays
1198   if (!klass-&gt;is_instance_klass()) {
1199     return 0;
1200   }
1201 
1202   // ignore classes which aren&#39;t linked yet
1203   InstanceKlass* ik = InstanceKlass::cast(klass);
1204   if (!ik-&gt;is_linked()) {
1205     return 0;
1206   }
1207 
1208   // get the field map
1209   ClassFieldMap* field_map = ClassFieldMap::create_map_of_static_fields(klass);
1210 
1211   // invoke the callback for each static primitive field
1212   for (int i=0; i&lt;field_map-&gt;field_count(); i++) {
1213     ClassFieldDescriptor* field = field_map-&gt;field_at(i);
1214 
1215     // ignore non-primitive fields
1216     char type = field-&gt;field_type();
1217     if (!is_primitive_field_type(type)) {
1218       continue;
1219     }
1220     // one-to-one mapping
1221     jvmtiPrimitiveType value_type = (jvmtiPrimitiveType)type;
1222 
1223     // get offset and field value
1224     int offset = field-&gt;field_offset();
1225     address addr = cast_from_oop&lt;address&gt;(klass-&gt;java_mirror()) + offset;
1226     jvalue value;
1227     copy_to_jvalue(&amp;value, addr, value_type);
1228 
1229     // field index
1230     reference_info.field.index = field-&gt;field_index();
1231 
1232     // invoke the callback
1233     jint res = (*cb)(JVMTI_HEAP_REFERENCE_STATIC_FIELD,
1234                      &amp;reference_info,
1235                      wrapper-&gt;klass_tag(),
1236                      wrapper-&gt;obj_tag_p(),
1237                      value,
1238                      value_type,
1239                      user_data);
1240     if (res &amp; JVMTI_VISIT_ABORT) {
1241       delete field_map;
1242       return res;
1243     }
1244   }
1245 
1246   delete field_map;
1247   return 0;
1248 }
1249 
1250 // helper function to invoke the primitive field callback for all instance fields
1251 // of a given object
1252 static jint invoke_primitive_field_callback_for_instance_fields(
1253   CallbackWrapper* wrapper,
1254   oop obj,
1255   jvmtiPrimitiveFieldCallback cb,
1256   void* user_data)
1257 {
1258   // for instance fields only the index will be set
1259   static jvmtiHeapReferenceInfo reference_info = { 0 };
1260 
1261   // get the map of the instance fields
1262   ClassFieldMap* fields = JvmtiCachedClassFieldMap::get_map_of_instance_fields(obj);
1263 
1264   // invoke the callback for each instance primitive field
1265   for (int i=0; i&lt;fields-&gt;field_count(); i++) {
1266     ClassFieldDescriptor* field = fields-&gt;field_at(i);
1267 
1268     // ignore non-primitive fields
1269     char type = field-&gt;field_type();
1270     if (!is_primitive_field_type(type)) {
1271       continue;
1272     }
1273     // one-to-one mapping
1274     jvmtiPrimitiveType value_type = (jvmtiPrimitiveType)type;
1275 
1276     // get offset and field value
1277     int offset = field-&gt;field_offset();
1278     address addr = cast_from_oop&lt;address&gt;(obj) + offset;
1279     jvalue value;
1280     copy_to_jvalue(&amp;value, addr, value_type);
1281 
1282     // field index
1283     reference_info.field.index = field-&gt;field_index();
1284 
1285     // invoke the callback
1286     jint res = (*cb)(JVMTI_HEAP_REFERENCE_FIELD,
1287                      &amp;reference_info,
1288                      wrapper-&gt;klass_tag(),
1289                      wrapper-&gt;obj_tag_p(),
1290                      value,
1291                      value_type,
1292                      user_data);
1293     if (res &amp; JVMTI_VISIT_ABORT) {
1294       return res;
1295     }
1296   }
1297   return 0;
1298 }
1299 
1300 
1301 // VM operation to iterate over all objects in the heap (both reachable
1302 // and unreachable)
1303 class VM_HeapIterateOperation: public VM_Operation {
1304  private:
1305   ObjectClosure* _blk;
<a name="8" id="anc8"></a><span class="line-added">1306   JvmtiTagMap* _tag_map;</span>
<span class="line-added">1307 </span>
1308  public:
<a name="9" id="anc9"></a><span class="line-modified">1309   VM_HeapIterateOperation(ObjectClosure* blk, JvmtiTagMap* tag_map) {</span>
<span class="line-added">1310     _blk = blk;</span>
<span class="line-added">1311     _tag_map = tag_map;</span>
<span class="line-added">1312   }</span>
1313 
1314   VMOp_Type type() const { return VMOp_HeapIterateOperation; }
1315   void doit() {
<a name="10" id="anc10"></a><span class="line-added">1316     // Simulates barrier synchronization on safepoint.</span>
<span class="line-added">1317     // This annotation is reasonably minimal in number of tsan callbacks.</span>
<span class="line-added">1318     // By passing the lock directly, we are not actually locking it, just</span>
<span class="line-added">1319     // telling TSAN we are to &quot;simulate&quot; the lock.</span>
<span class="line-added">1320     TSAN_ONLY(TsanMutexScope tms(_tag_map-&gt;lock()));</span>
<span class="line-added">1321 </span>
1322     // allows class files maps to be cached during iteration
1323     ClassFieldMapCacheMark cm;
1324 
1325     // make sure that heap is parsable (fills TLABs with filler objects)
1326     Universe::heap()-&gt;ensure_parsability(false);  // no need to retire TLABs
1327 
1328     // Verify heap before iteration - if the heap gets corrupted then
1329     // JVMTI&#39;s IterateOverHeap will crash.
1330     if (VerifyBeforeIteration) {
1331       Universe::verify();
1332     }
1333 
1334     // do the iteration
1335     Universe::heap()-&gt;object_iterate(_blk);
1336   }
1337 
1338 };
1339 
1340 
1341 // An ObjectClosure used to support the deprecated IterateOverHeap and
1342 // IterateOverInstancesOfClass functions
1343 class IterateOverHeapObjectClosure: public ObjectClosure {
1344  private:
1345   JvmtiTagMap* _tag_map;
1346   Klass* _klass;
1347   jvmtiHeapObjectFilter _object_filter;
1348   jvmtiHeapObjectCallback _heap_object_callback;
1349   const void* _user_data;
1350 
1351   // accessors
1352   JvmtiTagMap* tag_map() const                    { return _tag_map; }
1353   jvmtiHeapObjectFilter object_filter() const     { return _object_filter; }
1354   jvmtiHeapObjectCallback object_callback() const { return _heap_object_callback; }
1355   Klass* klass() const                            { return _klass; }
1356   const void* user_data() const                   { return _user_data; }
1357 
1358   // indicates if iteration has been aborted
1359   bool _iteration_aborted;
1360   bool is_iteration_aborted() const               { return _iteration_aborted; }
1361   void set_iteration_aborted(bool aborted)        { _iteration_aborted = aborted; }
1362 
1363  public:
1364   IterateOverHeapObjectClosure(JvmtiTagMap* tag_map,
1365                                Klass* klass,
1366                                jvmtiHeapObjectFilter object_filter,
1367                                jvmtiHeapObjectCallback heap_object_callback,
1368                                const void* user_data) :
1369     _tag_map(tag_map),
1370     _klass(klass),
1371     _object_filter(object_filter),
1372     _heap_object_callback(heap_object_callback),
1373     _user_data(user_data),
1374     _iteration_aborted(false)
1375   {
1376   }
1377 
1378   void do_object(oop o);
1379 };
1380 
1381 // invoked for each object in the heap
1382 void IterateOverHeapObjectClosure::do_object(oop o) {
1383   // check if iteration has been halted
1384   if (is_iteration_aborted()) return;
1385 
1386   // instanceof check when filtering by klass
1387   if (klass() != NULL &amp;&amp; !o-&gt;is_a(klass())) {
1388     return;
1389   }
1390   // prepare for the calllback
1391   CallbackWrapper wrapper(tag_map(), o);
1392 
1393   // if the object is tagged and we&#39;re only interested in untagged objects
1394   // then don&#39;t invoke the callback. Similiarly, if the object is untagged
1395   // and we&#39;re only interested in tagged objects we skip the callback.
1396   if (wrapper.obj_tag() != 0) {
1397     if (object_filter() == JVMTI_HEAP_OBJECT_UNTAGGED) return;
1398   } else {
1399     if (object_filter() == JVMTI_HEAP_OBJECT_TAGGED) return;
1400   }
1401 
1402   // invoke the agent&#39;s callback
1403   jvmtiIterationControl control = (*object_callback())(wrapper.klass_tag(),
1404                                                        wrapper.obj_size(),
1405                                                        wrapper.obj_tag_p(),
1406                                                        (void*)user_data());
1407   if (control == JVMTI_ITERATION_ABORT) {
1408     set_iteration_aborted(true);
1409   }
1410 }
1411 
1412 // An ObjectClosure used to support the IterateThroughHeap function
1413 class IterateThroughHeapObjectClosure: public ObjectClosure {
1414  private:
1415   JvmtiTagMap* _tag_map;
1416   Klass* _klass;
1417   int _heap_filter;
1418   const jvmtiHeapCallbacks* _callbacks;
1419   const void* _user_data;
1420 
1421   // accessor functions
1422   JvmtiTagMap* tag_map() const                     { return _tag_map; }
1423   int heap_filter() const                          { return _heap_filter; }
1424   const jvmtiHeapCallbacks* callbacks() const      { return _callbacks; }
1425   Klass* klass() const                             { return _klass; }
1426   const void* user_data() const                    { return _user_data; }
1427 
1428   // indicates if the iteration has been aborted
1429   bool _iteration_aborted;
1430   bool is_iteration_aborted() const                { return _iteration_aborted; }
1431 
1432   // used to check the visit control flags. If the abort flag is set
1433   // then we set the iteration aborted flag so that the iteration completes
1434   // without processing any further objects
1435   bool check_flags_for_abort(jint flags) {
1436     bool is_abort = (flags &amp; JVMTI_VISIT_ABORT) != 0;
1437     if (is_abort) {
1438       _iteration_aborted = true;
1439     }
1440     return is_abort;
1441   }
1442 
1443  public:
1444   IterateThroughHeapObjectClosure(JvmtiTagMap* tag_map,
1445                                   Klass* klass,
1446                                   int heap_filter,
1447                                   const jvmtiHeapCallbacks* heap_callbacks,
1448                                   const void* user_data) :
1449     _tag_map(tag_map),
1450     _klass(klass),
1451     _heap_filter(heap_filter),
1452     _callbacks(heap_callbacks),
1453     _user_data(user_data),
1454     _iteration_aborted(false)
1455   {
1456   }
1457 
1458   void do_object(oop o);
1459 };
1460 
1461 // invoked for each object in the heap
1462 void IterateThroughHeapObjectClosure::do_object(oop obj) {
1463   // check if iteration has been halted
1464   if (is_iteration_aborted()) return;
1465 
1466   // apply class filter
1467   if (is_filtered_by_klass_filter(obj, klass())) return;
1468 
1469   // prepare for callback
1470   CallbackWrapper wrapper(tag_map(), obj);
1471 
1472   // check if filtered by the heap filter
1473   if (is_filtered_by_heap_filter(wrapper.obj_tag(), wrapper.klass_tag(), heap_filter())) {
1474     return;
1475   }
1476 
1477   // for arrays we need the length, otherwise -1
1478   bool is_array = obj-&gt;is_array();
1479   int len = is_array ? arrayOop(obj)-&gt;length() : -1;
1480 
1481   // invoke the object callback (if callback is provided)
1482   if (callbacks()-&gt;heap_iteration_callback != NULL) {
1483     jvmtiHeapIterationCallback cb = callbacks()-&gt;heap_iteration_callback;
1484     jint res = (*cb)(wrapper.klass_tag(),
1485                      wrapper.obj_size(),
1486                      wrapper.obj_tag_p(),
1487                      (jint)len,
1488                      (void*)user_data());
1489     if (check_flags_for_abort(res)) return;
1490   }
1491 
1492   // for objects and classes we report primitive fields if callback provided
1493   if (callbacks()-&gt;primitive_field_callback != NULL &amp;&amp; obj-&gt;is_instance()) {
1494     jint res;
1495     jvmtiPrimitiveFieldCallback cb = callbacks()-&gt;primitive_field_callback;
1496     if (obj-&gt;klass() == SystemDictionary::Class_klass()) {
1497       res = invoke_primitive_field_callback_for_static_fields(&amp;wrapper,
1498                                                                     obj,
1499                                                                     cb,
1500                                                                     (void*)user_data());
1501     } else {
1502       res = invoke_primitive_field_callback_for_instance_fields(&amp;wrapper,
1503                                                                       obj,
1504                                                                       cb,
1505                                                                       (void*)user_data());
1506     }
1507     if (check_flags_for_abort(res)) return;
1508   }
1509 
1510   // string callback
1511   if (!is_array &amp;&amp;
1512       callbacks()-&gt;string_primitive_value_callback != NULL &amp;&amp;
1513       obj-&gt;klass() == SystemDictionary::String_klass()) {
1514     jint res = invoke_string_value_callback(
1515                 callbacks()-&gt;string_primitive_value_callback,
1516                 &amp;wrapper,
1517                 obj,
1518                 (void*)user_data() );
1519     if (check_flags_for_abort(res)) return;
1520   }
1521 
1522   // array callback
1523   if (is_array &amp;&amp;
1524       callbacks()-&gt;array_primitive_value_callback != NULL &amp;&amp;
1525       obj-&gt;is_typeArray()) {
1526     jint res = invoke_array_primitive_value_callback(
1527                callbacks()-&gt;array_primitive_value_callback,
1528                &amp;wrapper,
1529                obj,
1530                (void*)user_data() );
1531     if (check_flags_for_abort(res)) return;
1532   }
1533 };
1534 
1535 
1536 // Deprecated function to iterate over all objects in the heap
1537 void JvmtiTagMap::iterate_over_heap(jvmtiHeapObjectFilter object_filter,
1538                                     Klass* klass,
1539                                     jvmtiHeapObjectCallback heap_object_callback,
1540                                     const void* user_data)
1541 {
1542   MutexLocker ml(Heap_lock);
1543   IterateOverHeapObjectClosure blk(this,
1544                                    klass,
1545                                    object_filter,
1546                                    heap_object_callback,
1547                                    user_data);
<a name="11" id="anc11"></a><span class="line-modified">1548   VM_HeapIterateOperation op(&amp;blk, this);</span>
1549   VMThread::execute(&amp;op);
1550 }
1551 
1552 
1553 // Iterates over all objects in the heap
1554 void JvmtiTagMap::iterate_through_heap(jint heap_filter,
1555                                        Klass* klass,
1556                                        const jvmtiHeapCallbacks* callbacks,
1557                                        const void* user_data)
1558 {
1559   MutexLocker ml(Heap_lock);
1560   IterateThroughHeapObjectClosure blk(this,
1561                                       klass,
1562                                       heap_filter,
1563                                       callbacks,
1564                                       user_data);
<a name="12" id="anc12"></a><span class="line-modified">1565   VM_HeapIterateOperation op(&amp;blk, this);</span>
1566   VMThread::execute(&amp;op);
1567 }
1568 
1569 // support class for get_objects_with_tags
1570 
1571 class TagObjectCollector : public JvmtiTagHashmapEntryClosure {
1572  private:
1573   JvmtiEnv* _env;
1574   jlong* _tags;
1575   jint _tag_count;
1576 
1577   GrowableArray&lt;jobject&gt;* _object_results;  // collected objects (JNI weak refs)
1578   GrowableArray&lt;uint64_t&gt;* _tag_results;    // collected tags
1579 
1580  public:
1581   TagObjectCollector(JvmtiEnv* env, const jlong* tags, jint tag_count) {
1582     _env = env;
1583     _tags = (jlong*)tags;
1584     _tag_count = tag_count;
1585     _object_results = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;jobject&gt;(1,true);
1586     _tag_results = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;uint64_t&gt;(1,true);
1587   }
1588 
1589   ~TagObjectCollector() {
1590     delete _object_results;
1591     delete _tag_results;
1592   }
1593 
1594   // for each tagged object check if the tag value matches
1595   // - if it matches then we create a JNI local reference to the object
1596   // and record the reference and tag value.
1597   //
1598   void do_entry(JvmtiTagHashmapEntry* entry) {
1599     for (int i=0; i&lt;_tag_count; i++) {
1600       if (_tags[i] == entry-&gt;tag()) {
1601         // The reference in this tag map could be the only (implicitly weak)
1602         // reference to that object. If we hand it out, we need to keep it live wrt
1603         // SATB marking similar to other j.l.ref.Reference referents. This is
1604         // achieved by using a phantom load in the object() accessor.
1605         oop o = entry-&gt;object();
1606         assert(o != NULL &amp;&amp; Universe::heap()-&gt;is_in(o), &quot;sanity check&quot;);
1607         jobject ref = JNIHandles::make_local(JavaThread::current(), o);
1608         _object_results-&gt;append(ref);
1609         _tag_results-&gt;append((uint64_t)entry-&gt;tag());
1610       }
1611     }
1612   }
1613 
1614   // return the results from the collection
1615   //
1616   jvmtiError result(jint* count_ptr, jobject** object_result_ptr, jlong** tag_result_ptr) {
1617     jvmtiError error;
1618     int count = _object_results-&gt;length();
1619     assert(count &gt;= 0, &quot;sanity check&quot;);
1620 
1621     // if object_result_ptr is not NULL then allocate the result and copy
1622     // in the object references.
1623     if (object_result_ptr != NULL) {
1624       error = _env-&gt;Allocate(count * sizeof(jobject), (unsigned char**)object_result_ptr);
1625       if (error != JVMTI_ERROR_NONE) {
1626         return error;
1627       }
1628       for (int i=0; i&lt;count; i++) {
1629         (*object_result_ptr)[i] = _object_results-&gt;at(i);
1630       }
1631     }
1632 
1633     // if tag_result_ptr is not NULL then allocate the result and copy
1634     // in the tag values.
1635     if (tag_result_ptr != NULL) {
1636       error = _env-&gt;Allocate(count * sizeof(jlong), (unsigned char**)tag_result_ptr);
1637       if (error != JVMTI_ERROR_NONE) {
1638         if (object_result_ptr != NULL) {
1639           _env-&gt;Deallocate((unsigned char*)object_result_ptr);
1640         }
1641         return error;
1642       }
1643       for (int i=0; i&lt;count; i++) {
1644         (*tag_result_ptr)[i] = (jlong)_tag_results-&gt;at(i);
1645       }
1646     }
1647 
1648     *count_ptr = count;
1649     return JVMTI_ERROR_NONE;
1650   }
1651 };
1652 
1653 // return the list of objects with the specified tags
1654 jvmtiError JvmtiTagMap::get_objects_with_tags(const jlong* tags,
1655   jint count, jint* count_ptr, jobject** object_result_ptr, jlong** tag_result_ptr) {
1656 
1657   TagObjectCollector collector(env(), tags, count);
1658   {
1659     // iterate over all tagged objects
1660     MutexLocker ml(lock());
<a name="13" id="anc13"></a><span class="line-added">1661     TSAN_ONLY(TsanMutexScope tms(lock()));</span>
1662     entry_iterate(&amp;collector);
1663   }
1664   return collector.result(count_ptr, object_result_ptr, tag_result_ptr);
1665 }
1666 
1667 
1668 // ObjectMarker is used to support the marking objects when walking the
1669 // heap.
1670 //
1671 // This implementation uses the existing mark bits in an object for
1672 // marking. Objects that are marked must later have their headers restored.
1673 // As most objects are unlocked and don&#39;t have their identity hash computed
1674 // we don&#39;t have to save their headers. Instead we save the headers that
1675 // are &quot;interesting&quot;. Later when the headers are restored this implementation
1676 // restores all headers to their initial value and then restores the few
1677 // objects that had interesting headers.
1678 //
1679 // Future work: This implementation currently uses growable arrays to save
1680 // the oop and header of interesting objects. As an optimization we could
1681 // use the same technique as the GC and make use of the unused area
1682 // between top() and end().
1683 //
1684 
1685 // An ObjectClosure used to restore the mark bits of an object
1686 class RestoreMarksClosure : public ObjectClosure {
1687  public:
1688   void do_object(oop o) {
1689     if (o != NULL) {
1690       markWord mark = o-&gt;mark();
1691       if (mark.is_marked()) {
1692         o-&gt;init_mark();
1693       }
1694     }
1695   }
1696 };
1697 
1698 // ObjectMarker provides the mark and visited functions
1699 class ObjectMarker : AllStatic {
1700  private:
1701   // saved headers
1702   static GrowableArray&lt;oop&gt;* _saved_oop_stack;
1703   static GrowableArray&lt;markWord&gt;* _saved_mark_stack;
1704   static bool _needs_reset;                  // do we need to reset mark bits?
1705 
1706  public:
1707   static void init();                       // initialize
1708   static void done();                       // clean-up
1709 
1710   static inline void mark(oop o);           // mark an object
1711   static inline bool visited(oop o);        // check if object has been visited
1712 
1713   static inline bool needs_reset()            { return _needs_reset; }
1714   static inline void set_needs_reset(bool v)  { _needs_reset = v; }
1715 };
1716 
1717 GrowableArray&lt;oop&gt;* ObjectMarker::_saved_oop_stack = NULL;
1718 GrowableArray&lt;markWord&gt;* ObjectMarker::_saved_mark_stack = NULL;
1719 bool ObjectMarker::_needs_reset = true;  // need to reset mark bits by default
1720 
1721 // initialize ObjectMarker - prepares for object marking
1722 void ObjectMarker::init() {
1723   assert(Thread::current()-&gt;is_VM_thread(), &quot;must be VMThread&quot;);
1724 
1725   // prepare heap for iteration
1726   Universe::heap()-&gt;ensure_parsability(false);  // no need to retire TLABs
1727 
1728   // create stacks for interesting headers
1729   _saved_mark_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;markWord&gt;(4000, true);
1730   _saved_oop_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;oop&gt;(4000, true);
1731 
1732   if (UseBiasedLocking) {
1733     BiasedLocking::preserve_marks();
1734   }
1735 }
1736 
1737 // Object marking is done so restore object headers
1738 void ObjectMarker::done() {
1739   // iterate over all objects and restore the mark bits to
1740   // their initial value
1741   RestoreMarksClosure blk;
1742   if (needs_reset()) {
1743     Universe::heap()-&gt;object_iterate(&amp;blk);
1744   } else {
1745     // We don&#39;t need to reset mark bits on this call, but reset the
1746     // flag to the default for the next call.
1747     set_needs_reset(true);
1748   }
1749 
1750   // now restore the interesting headers
1751   for (int i = 0; i &lt; _saved_oop_stack-&gt;length(); i++) {
1752     oop o = _saved_oop_stack-&gt;at(i);
1753     markWord mark = _saved_mark_stack-&gt;at(i);
1754     o-&gt;set_mark(mark);
1755   }
1756 
1757   if (UseBiasedLocking) {
1758     BiasedLocking::restore_marks();
1759   }
1760 
1761   // free the stacks
1762   delete _saved_oop_stack;
1763   delete _saved_mark_stack;
1764 }
1765 
1766 // mark an object
1767 inline void ObjectMarker::mark(oop o) {
1768   assert(Universe::heap()-&gt;is_in(o), &quot;sanity check&quot;);
1769   assert(!o-&gt;mark().is_marked(), &quot;should only mark an object once&quot;);
1770 
1771   // object&#39;s mark word
1772   markWord mark = o-&gt;mark();
1773 
1774   if (o-&gt;mark_must_be_preserved(mark)) {
1775     _saved_mark_stack-&gt;push(mark);
1776     _saved_oop_stack-&gt;push(o);
1777   }
1778 
1779   // mark the object
1780   o-&gt;set_mark(markWord::prototype().set_marked());
1781 }
1782 
1783 // return true if object is marked
1784 inline bool ObjectMarker::visited(oop o) {
1785   return o-&gt;mark().is_marked();
1786 }
1787 
1788 // Stack allocated class to help ensure that ObjectMarker is used
1789 // correctly. Constructor initializes ObjectMarker, destructor calls
1790 // ObjectMarker&#39;s done() function to restore object headers.
1791 class ObjectMarkerController : public StackObj {
1792  public:
1793   ObjectMarkerController() {
1794     ObjectMarker::init();
1795   }
1796   ~ObjectMarkerController() {
1797     ObjectMarker::done();
1798   }
1799 };
1800 
1801 
1802 // helper to map a jvmtiHeapReferenceKind to an old style jvmtiHeapRootKind
1803 // (not performance critical as only used for roots)
1804 static jvmtiHeapRootKind toJvmtiHeapRootKind(jvmtiHeapReferenceKind kind) {
1805   switch (kind) {
1806     case JVMTI_HEAP_REFERENCE_JNI_GLOBAL:   return JVMTI_HEAP_ROOT_JNI_GLOBAL;
1807     case JVMTI_HEAP_REFERENCE_SYSTEM_CLASS: return JVMTI_HEAP_ROOT_SYSTEM_CLASS;
1808     case JVMTI_HEAP_REFERENCE_MONITOR:      return JVMTI_HEAP_ROOT_MONITOR;
1809     case JVMTI_HEAP_REFERENCE_STACK_LOCAL:  return JVMTI_HEAP_ROOT_STACK_LOCAL;
1810     case JVMTI_HEAP_REFERENCE_JNI_LOCAL:    return JVMTI_HEAP_ROOT_JNI_LOCAL;
1811     case JVMTI_HEAP_REFERENCE_THREAD:       return JVMTI_HEAP_ROOT_THREAD;
1812     case JVMTI_HEAP_REFERENCE_OTHER:        return JVMTI_HEAP_ROOT_OTHER;
1813     default: ShouldNotReachHere();          return JVMTI_HEAP_ROOT_OTHER;
1814   }
1815 }
1816 
1817 // Base class for all heap walk contexts. The base class maintains a flag
1818 // to indicate if the context is valid or not.
1819 class HeapWalkContext {
1820  private:
1821   bool _valid;
1822  public:
1823   HeapWalkContext(bool valid)                   { _valid = valid; }
1824   void invalidate()                             { _valid = false; }
1825   bool is_valid() const                         { return _valid; }
1826 };
1827 
1828 // A basic heap walk context for the deprecated heap walking functions.
1829 // The context for a basic heap walk are the callbacks and fields used by
1830 // the referrer caching scheme.
1831 class BasicHeapWalkContext: public HeapWalkContext {
1832  private:
1833   jvmtiHeapRootCallback _heap_root_callback;
1834   jvmtiStackReferenceCallback _stack_ref_callback;
1835   jvmtiObjectReferenceCallback _object_ref_callback;
1836 
1837   // used for caching
1838   oop _last_referrer;
1839   jlong _last_referrer_tag;
1840 
1841  public:
1842   BasicHeapWalkContext() : HeapWalkContext(false) { }
1843 
1844   BasicHeapWalkContext(jvmtiHeapRootCallback heap_root_callback,
1845                        jvmtiStackReferenceCallback stack_ref_callback,
1846                        jvmtiObjectReferenceCallback object_ref_callback) :
1847     HeapWalkContext(true),
1848     _heap_root_callback(heap_root_callback),
1849     _stack_ref_callback(stack_ref_callback),
1850     _object_ref_callback(object_ref_callback),
1851     _last_referrer(NULL),
1852     _last_referrer_tag(0) {
1853   }
1854 
1855   // accessors
1856   jvmtiHeapRootCallback heap_root_callback() const         { return _heap_root_callback; }
1857   jvmtiStackReferenceCallback stack_ref_callback() const   { return _stack_ref_callback; }
1858   jvmtiObjectReferenceCallback object_ref_callback() const { return _object_ref_callback;  }
1859 
1860   oop last_referrer() const               { return _last_referrer; }
1861   void set_last_referrer(oop referrer)    { _last_referrer = referrer; }
1862   jlong last_referrer_tag() const         { return _last_referrer_tag; }
1863   void set_last_referrer_tag(jlong value) { _last_referrer_tag = value; }
1864 };
1865 
1866 // The advanced heap walk context for the FollowReferences functions.
1867 // The context is the callbacks, and the fields used for filtering.
1868 class AdvancedHeapWalkContext: public HeapWalkContext {
1869  private:
1870   jint _heap_filter;
1871   Klass* _klass_filter;
1872   const jvmtiHeapCallbacks* _heap_callbacks;
1873 
1874  public:
1875   AdvancedHeapWalkContext() : HeapWalkContext(false) { }
1876 
1877   AdvancedHeapWalkContext(jint heap_filter,
1878                            Klass* klass_filter,
1879                            const jvmtiHeapCallbacks* heap_callbacks) :
1880     HeapWalkContext(true),
1881     _heap_filter(heap_filter),
1882     _klass_filter(klass_filter),
1883     _heap_callbacks(heap_callbacks) {
1884   }
1885 
1886   // accessors
1887   jint heap_filter() const         { return _heap_filter; }
1888   Klass* klass_filter() const      { return _klass_filter; }
1889 
1890   const jvmtiHeapReferenceCallback heap_reference_callback() const {
1891     return _heap_callbacks-&gt;heap_reference_callback;
1892   };
1893   const jvmtiPrimitiveFieldCallback primitive_field_callback() const {
1894     return _heap_callbacks-&gt;primitive_field_callback;
1895   }
1896   const jvmtiArrayPrimitiveValueCallback array_primitive_value_callback() const {
1897     return _heap_callbacks-&gt;array_primitive_value_callback;
1898   }
1899   const jvmtiStringPrimitiveValueCallback string_primitive_value_callback() const {
1900     return _heap_callbacks-&gt;string_primitive_value_callback;
1901   }
1902 };
1903 
1904 // The CallbackInvoker is a class with static functions that the heap walk can call
1905 // into to invoke callbacks. It works in one of two modes. The &quot;basic&quot; mode is
1906 // used for the deprecated IterateOverReachableObjects functions. The &quot;advanced&quot;
1907 // mode is for the newer FollowReferences function which supports a lot of
1908 // additional callbacks.
1909 class CallbackInvoker : AllStatic {
1910  private:
1911   // heap walk styles
1912   enum { basic, advanced };
1913   static int _heap_walk_type;
1914   static bool is_basic_heap_walk()           { return _heap_walk_type == basic; }
1915   static bool is_advanced_heap_walk()        { return _heap_walk_type == advanced; }
1916 
1917   // context for basic style heap walk
1918   static BasicHeapWalkContext _basic_context;
1919   static BasicHeapWalkContext* basic_context() {
1920     assert(_basic_context.is_valid(), &quot;invalid&quot;);
1921     return &amp;_basic_context;
1922   }
1923 
1924   // context for advanced style heap walk
1925   static AdvancedHeapWalkContext _advanced_context;
1926   static AdvancedHeapWalkContext* advanced_context() {
1927     assert(_advanced_context.is_valid(), &quot;invalid&quot;);
1928     return &amp;_advanced_context;
1929   }
1930 
1931   // context needed for all heap walks
1932   static JvmtiTagMap* _tag_map;
1933   static const void* _user_data;
1934   static GrowableArray&lt;oop&gt;* _visit_stack;
1935 
1936   // accessors
1937   static JvmtiTagMap* tag_map()                        { return _tag_map; }
1938   static const void* user_data()                       { return _user_data; }
1939   static GrowableArray&lt;oop&gt;* visit_stack()             { return _visit_stack; }
1940 
1941   // if the object hasn&#39;t been visited then push it onto the visit stack
1942   // so that it will be visited later
1943   static inline bool check_for_visit(oop obj) {
1944     if (!ObjectMarker::visited(obj)) visit_stack()-&gt;push(obj);
1945     return true;
1946   }
1947 
1948   // invoke basic style callbacks
1949   static inline bool invoke_basic_heap_root_callback
1950     (jvmtiHeapRootKind root_kind, oop obj);
1951   static inline bool invoke_basic_stack_ref_callback
1952     (jvmtiHeapRootKind root_kind, jlong thread_tag, jint depth, jmethodID method,
1953      int slot, oop obj);
1954   static inline bool invoke_basic_object_reference_callback
1955     (jvmtiObjectReferenceKind ref_kind, oop referrer, oop referree, jint index);
1956 
1957   // invoke advanced style callbacks
1958   static inline bool invoke_advanced_heap_root_callback
1959     (jvmtiHeapReferenceKind ref_kind, oop obj);
1960   static inline bool invoke_advanced_stack_ref_callback
1961     (jvmtiHeapReferenceKind ref_kind, jlong thread_tag, jlong tid, int depth,
1962      jmethodID method, jlocation bci, jint slot, oop obj);
1963   static inline bool invoke_advanced_object_reference_callback
1964     (jvmtiHeapReferenceKind ref_kind, oop referrer, oop referree, jint index);
1965 
1966   // used to report the value of primitive fields
1967   static inline bool report_primitive_field
1968     (jvmtiHeapReferenceKind ref_kind, oop obj, jint index, address addr, char type);
1969 
1970  public:
1971   // initialize for basic mode
1972   static void initialize_for_basic_heap_walk(JvmtiTagMap* tag_map,
1973                                              GrowableArray&lt;oop&gt;* visit_stack,
1974                                              const void* user_data,
1975                                              BasicHeapWalkContext context);
1976 
1977   // initialize for advanced mode
1978   static void initialize_for_advanced_heap_walk(JvmtiTagMap* tag_map,
1979                                                 GrowableArray&lt;oop&gt;* visit_stack,
1980                                                 const void* user_data,
1981                                                 AdvancedHeapWalkContext context);
1982 
1983    // functions to report roots
1984   static inline bool report_simple_root(jvmtiHeapReferenceKind kind, oop o);
1985   static inline bool report_jni_local_root(jlong thread_tag, jlong tid, jint depth,
1986     jmethodID m, oop o);
1987   static inline bool report_stack_ref_root(jlong thread_tag, jlong tid, jint depth,
1988     jmethodID method, jlocation bci, jint slot, oop o);
1989 
1990   // functions to report references
1991   static inline bool report_array_element_reference(oop referrer, oop referree, jint index);
1992   static inline bool report_class_reference(oop referrer, oop referree);
1993   static inline bool report_class_loader_reference(oop referrer, oop referree);
1994   static inline bool report_signers_reference(oop referrer, oop referree);
1995   static inline bool report_protection_domain_reference(oop referrer, oop referree);
1996   static inline bool report_superclass_reference(oop referrer, oop referree);
1997   static inline bool report_interface_reference(oop referrer, oop referree);
1998   static inline bool report_static_field_reference(oop referrer, oop referree, jint slot);
1999   static inline bool report_field_reference(oop referrer, oop referree, jint slot);
2000   static inline bool report_constant_pool_reference(oop referrer, oop referree, jint index);
2001   static inline bool report_primitive_array_values(oop array);
2002   static inline bool report_string_value(oop str);
2003   static inline bool report_primitive_instance_field(oop o, jint index, address value, char type);
2004   static inline bool report_primitive_static_field(oop o, jint index, address value, char type);
2005 };
2006 
2007 // statics
2008 int CallbackInvoker::_heap_walk_type;
2009 BasicHeapWalkContext CallbackInvoker::_basic_context;
2010 AdvancedHeapWalkContext CallbackInvoker::_advanced_context;
2011 JvmtiTagMap* CallbackInvoker::_tag_map;
2012 const void* CallbackInvoker::_user_data;
2013 GrowableArray&lt;oop&gt;* CallbackInvoker::_visit_stack;
2014 
2015 // initialize for basic heap walk (IterateOverReachableObjects et al)
2016 void CallbackInvoker::initialize_for_basic_heap_walk(JvmtiTagMap* tag_map,
2017                                                      GrowableArray&lt;oop&gt;* visit_stack,
2018                                                      const void* user_data,
2019                                                      BasicHeapWalkContext context) {
2020   _tag_map = tag_map;
2021   _visit_stack = visit_stack;
2022   _user_data = user_data;
2023   _basic_context = context;
2024   _advanced_context.invalidate();       // will trigger assertion if used
2025   _heap_walk_type = basic;
2026 }
2027 
2028 // initialize for advanced heap walk (FollowReferences)
2029 void CallbackInvoker::initialize_for_advanced_heap_walk(JvmtiTagMap* tag_map,
2030                                                         GrowableArray&lt;oop&gt;* visit_stack,
2031                                                         const void* user_data,
2032                                                         AdvancedHeapWalkContext context) {
2033   _tag_map = tag_map;
2034   _visit_stack = visit_stack;
2035   _user_data = user_data;
2036   _advanced_context = context;
2037   _basic_context.invalidate();      // will trigger assertion if used
2038   _heap_walk_type = advanced;
2039 }
2040 
2041 
2042 // invoke basic style heap root callback
2043 inline bool CallbackInvoker::invoke_basic_heap_root_callback(jvmtiHeapRootKind root_kind, oop obj) {
2044   // if we heap roots should be reported
2045   jvmtiHeapRootCallback cb = basic_context()-&gt;heap_root_callback();
2046   if (cb == NULL) {
2047     return check_for_visit(obj);
2048   }
2049 
2050   CallbackWrapper wrapper(tag_map(), obj);
2051   jvmtiIterationControl control = (*cb)(root_kind,
2052                                         wrapper.klass_tag(),
2053                                         wrapper.obj_size(),
2054                                         wrapper.obj_tag_p(),
2055                                         (void*)user_data());
2056   // push root to visit stack when following references
2057   if (control == JVMTI_ITERATION_CONTINUE &amp;&amp;
2058       basic_context()-&gt;object_ref_callback() != NULL) {
2059     visit_stack()-&gt;push(obj);
2060   }
2061   return control != JVMTI_ITERATION_ABORT;
2062 }
2063 
2064 // invoke basic style stack ref callback
2065 inline bool CallbackInvoker::invoke_basic_stack_ref_callback(jvmtiHeapRootKind root_kind,
2066                                                              jlong thread_tag,
2067                                                              jint depth,
2068                                                              jmethodID method,
2069                                                              int slot,
2070                                                              oop obj) {
2071   // if we stack refs should be reported
2072   jvmtiStackReferenceCallback cb = basic_context()-&gt;stack_ref_callback();
2073   if (cb == NULL) {
2074     return check_for_visit(obj);
2075   }
2076 
2077   CallbackWrapper wrapper(tag_map(), obj);
2078   jvmtiIterationControl control = (*cb)(root_kind,
2079                                         wrapper.klass_tag(),
2080                                         wrapper.obj_size(),
2081                                         wrapper.obj_tag_p(),
2082                                         thread_tag,
2083                                         depth,
2084                                         method,
2085                                         slot,
2086                                         (void*)user_data());
2087   // push root to visit stack when following references
2088   if (control == JVMTI_ITERATION_CONTINUE &amp;&amp;
2089       basic_context()-&gt;object_ref_callback() != NULL) {
2090     visit_stack()-&gt;push(obj);
2091   }
2092   return control != JVMTI_ITERATION_ABORT;
2093 }
2094 
2095 // invoke basic style object reference callback
2096 inline bool CallbackInvoker::invoke_basic_object_reference_callback(jvmtiObjectReferenceKind ref_kind,
2097                                                                     oop referrer,
2098                                                                     oop referree,
2099                                                                     jint index) {
2100 
2101   BasicHeapWalkContext* context = basic_context();
2102 
2103   // callback requires the referrer&#39;s tag. If it&#39;s the same referrer
2104   // as the last call then we use the cached value.
2105   jlong referrer_tag;
2106   if (referrer == context-&gt;last_referrer()) {
2107     referrer_tag = context-&gt;last_referrer_tag();
2108   } else {
2109     referrer_tag = tag_for(tag_map(), referrer);
2110   }
2111 
2112   // do the callback
2113   CallbackWrapper wrapper(tag_map(), referree);
2114   jvmtiObjectReferenceCallback cb = context-&gt;object_ref_callback();
2115   jvmtiIterationControl control = (*cb)(ref_kind,
2116                                         wrapper.klass_tag(),
2117                                         wrapper.obj_size(),
2118                                         wrapper.obj_tag_p(),
2119                                         referrer_tag,
2120                                         index,
2121                                         (void*)user_data());
2122 
2123   // record referrer and referrer tag. For self-references record the
2124   // tag value from the callback as this might differ from referrer_tag.
2125   context-&gt;set_last_referrer(referrer);
2126   if (referrer == referree) {
2127     context-&gt;set_last_referrer_tag(*wrapper.obj_tag_p());
2128   } else {
2129     context-&gt;set_last_referrer_tag(referrer_tag);
2130   }
2131 
2132   if (control == JVMTI_ITERATION_CONTINUE) {
2133     return check_for_visit(referree);
2134   } else {
2135     return control != JVMTI_ITERATION_ABORT;
2136   }
2137 }
2138 
2139 // invoke advanced style heap root callback
2140 inline bool CallbackInvoker::invoke_advanced_heap_root_callback(jvmtiHeapReferenceKind ref_kind,
2141                                                                 oop obj) {
2142   AdvancedHeapWalkContext* context = advanced_context();
2143 
2144   // check that callback is provided
2145   jvmtiHeapReferenceCallback cb = context-&gt;heap_reference_callback();
2146   if (cb == NULL) {
2147     return check_for_visit(obj);
2148   }
2149 
2150   // apply class filter
2151   if (is_filtered_by_klass_filter(obj, context-&gt;klass_filter())) {
2152     return check_for_visit(obj);
2153   }
2154 
2155   // setup the callback wrapper
2156   CallbackWrapper wrapper(tag_map(), obj);
2157 
2158   // apply tag filter
2159   if (is_filtered_by_heap_filter(wrapper.obj_tag(),
2160                                  wrapper.klass_tag(),
2161                                  context-&gt;heap_filter())) {
2162     return check_for_visit(obj);
2163   }
2164 
2165   // for arrays we need the length, otherwise -1
2166   jint len = (jint)(obj-&gt;is_array() ? arrayOop(obj)-&gt;length() : -1);
2167 
2168   // invoke the callback
2169   jint res  = (*cb)(ref_kind,
2170                     NULL, // referrer info
2171                     wrapper.klass_tag(),
2172                     0,    // referrer_class_tag is 0 for heap root
2173                     wrapper.obj_size(),
2174                     wrapper.obj_tag_p(),
2175                     NULL, // referrer_tag_p
2176                     len,
2177                     (void*)user_data());
2178   if (res &amp; JVMTI_VISIT_ABORT) {
2179     return false;// referrer class tag
2180   }
2181   if (res &amp; JVMTI_VISIT_OBJECTS) {
2182     check_for_visit(obj);
2183   }
2184   return true;
2185 }
2186 
2187 // report a reference from a thread stack to an object
2188 inline bool CallbackInvoker::invoke_advanced_stack_ref_callback(jvmtiHeapReferenceKind ref_kind,
2189                                                                 jlong thread_tag,
2190                                                                 jlong tid,
2191                                                                 int depth,
2192                                                                 jmethodID method,
2193                                                                 jlocation bci,
2194                                                                 jint slot,
2195                                                                 oop obj) {
2196   AdvancedHeapWalkContext* context = advanced_context();
2197 
2198   // check that callback is provider
2199   jvmtiHeapReferenceCallback cb = context-&gt;heap_reference_callback();
2200   if (cb == NULL) {
2201     return check_for_visit(obj);
2202   }
2203 
2204   // apply class filter
2205   if (is_filtered_by_klass_filter(obj, context-&gt;klass_filter())) {
2206     return check_for_visit(obj);
2207   }
2208 
2209   // setup the callback wrapper
2210   CallbackWrapper wrapper(tag_map(), obj);
2211 
2212   // apply tag filter
2213   if (is_filtered_by_heap_filter(wrapper.obj_tag(),
2214                                  wrapper.klass_tag(),
2215                                  context-&gt;heap_filter())) {
2216     return check_for_visit(obj);
2217   }
2218 
2219   // setup the referrer info
2220   jvmtiHeapReferenceInfo reference_info;
2221   reference_info.stack_local.thread_tag = thread_tag;
2222   reference_info.stack_local.thread_id = tid;
2223   reference_info.stack_local.depth = depth;
2224   reference_info.stack_local.method = method;
2225   reference_info.stack_local.location = bci;
2226   reference_info.stack_local.slot = slot;
2227 
2228   // for arrays we need the length, otherwise -1
2229   jint len = (jint)(obj-&gt;is_array() ? arrayOop(obj)-&gt;length() : -1);
2230 
2231   // call into the agent
2232   int res = (*cb)(ref_kind,
2233                   &amp;reference_info,
2234                   wrapper.klass_tag(),
2235                   0,    // referrer_class_tag is 0 for heap root (stack)
2236                   wrapper.obj_size(),
2237                   wrapper.obj_tag_p(),
2238                   NULL, // referrer_tag is 0 for root
2239                   len,
2240                   (void*)user_data());
2241 
2242   if (res &amp; JVMTI_VISIT_ABORT) {
2243     return false;
2244   }
2245   if (res &amp; JVMTI_VISIT_OBJECTS) {
2246     check_for_visit(obj);
2247   }
2248   return true;
2249 }
2250 
2251 // This mask is used to pass reference_info to a jvmtiHeapReferenceCallback
2252 // only for ref_kinds defined by the JVM TI spec. Otherwise, NULL is passed.
2253 #define REF_INFO_MASK  ((1 &lt;&lt; JVMTI_HEAP_REFERENCE_FIELD)         \
2254                       | (1 &lt;&lt; JVMTI_HEAP_REFERENCE_STATIC_FIELD)  \
2255                       | (1 &lt;&lt; JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT) \
2256                       | (1 &lt;&lt; JVMTI_HEAP_REFERENCE_CONSTANT_POOL) \
2257                       | (1 &lt;&lt; JVMTI_HEAP_REFERENCE_STACK_LOCAL)   \
2258                       | (1 &lt;&lt; JVMTI_HEAP_REFERENCE_JNI_LOCAL))
2259 
2260 // invoke the object reference callback to report a reference
2261 inline bool CallbackInvoker::invoke_advanced_object_reference_callback(jvmtiHeapReferenceKind ref_kind,
2262                                                                        oop referrer,
2263                                                                        oop obj,
2264                                                                        jint index)
2265 {
2266   // field index is only valid field in reference_info
2267   static jvmtiHeapReferenceInfo reference_info = { 0 };
2268 
2269   AdvancedHeapWalkContext* context = advanced_context();
2270 
2271   // check that callback is provider
2272   jvmtiHeapReferenceCallback cb = context-&gt;heap_reference_callback();
2273   if (cb == NULL) {
2274     return check_for_visit(obj);
2275   }
2276 
2277   // apply class filter
2278   if (is_filtered_by_klass_filter(obj, context-&gt;klass_filter())) {
2279     return check_for_visit(obj);
2280   }
2281 
2282   // setup the callback wrapper
2283   TwoOopCallbackWrapper wrapper(tag_map(), referrer, obj);
2284 
2285   // apply tag filter
2286   if (is_filtered_by_heap_filter(wrapper.obj_tag(),
2287                                  wrapper.klass_tag(),
2288                                  context-&gt;heap_filter())) {
2289     return check_for_visit(obj);
2290   }
2291 
2292   // field index is only valid field in reference_info
2293   reference_info.field.index = index;
2294 
2295   // for arrays we need the length, otherwise -1
2296   jint len = (jint)(obj-&gt;is_array() ? arrayOop(obj)-&gt;length() : -1);
2297 
2298   // invoke the callback
2299   int res = (*cb)(ref_kind,
2300                   (REF_INFO_MASK &amp; (1 &lt;&lt; ref_kind)) ? &amp;reference_info : NULL,
2301                   wrapper.klass_tag(),
2302                   wrapper.referrer_klass_tag(),
2303                   wrapper.obj_size(),
2304                   wrapper.obj_tag_p(),
2305                   wrapper.referrer_tag_p(),
2306                   len,
2307                   (void*)user_data());
2308 
2309   if (res &amp; JVMTI_VISIT_ABORT) {
2310     return false;
2311   }
2312   if (res &amp; JVMTI_VISIT_OBJECTS) {
2313     check_for_visit(obj);
2314   }
2315   return true;
2316 }
2317 
2318 // report a &quot;simple root&quot;
2319 inline bool CallbackInvoker::report_simple_root(jvmtiHeapReferenceKind kind, oop obj) {
2320   assert(kind != JVMTI_HEAP_REFERENCE_STACK_LOCAL &amp;&amp;
2321          kind != JVMTI_HEAP_REFERENCE_JNI_LOCAL, &quot;not a simple root&quot;);
2322 
2323   if (is_basic_heap_walk()) {
2324     // map to old style root kind
2325     jvmtiHeapRootKind root_kind = toJvmtiHeapRootKind(kind);
2326     return invoke_basic_heap_root_callback(root_kind, obj);
2327   } else {
2328     assert(is_advanced_heap_walk(), &quot;wrong heap walk type&quot;);
2329     return invoke_advanced_heap_root_callback(kind, obj);
2330   }
2331 }
2332 
2333 
2334 // invoke the primitive array values
2335 inline bool CallbackInvoker::report_primitive_array_values(oop obj) {
2336   assert(obj-&gt;is_typeArray(), &quot;not a primitive array&quot;);
2337 
2338   AdvancedHeapWalkContext* context = advanced_context();
2339   assert(context-&gt;array_primitive_value_callback() != NULL, &quot;no callback&quot;);
2340 
2341   // apply class filter
2342   if (is_filtered_by_klass_filter(obj, context-&gt;klass_filter())) {
2343     return true;
2344   }
2345 
2346   CallbackWrapper wrapper(tag_map(), obj);
2347 
2348   // apply tag filter
2349   if (is_filtered_by_heap_filter(wrapper.obj_tag(),
2350                                  wrapper.klass_tag(),
2351                                  context-&gt;heap_filter())) {
2352     return true;
2353   }
2354 
2355   // invoke the callback
2356   int res = invoke_array_primitive_value_callback(context-&gt;array_primitive_value_callback(),
2357                                                   &amp;wrapper,
2358                                                   obj,
2359                                                   (void*)user_data());
2360   return (!(res &amp; JVMTI_VISIT_ABORT));
2361 }
2362 
2363 // invoke the string value callback
2364 inline bool CallbackInvoker::report_string_value(oop str) {
2365   assert(str-&gt;klass() == SystemDictionary::String_klass(), &quot;not a string&quot;);
2366 
2367   AdvancedHeapWalkContext* context = advanced_context();
2368   assert(context-&gt;string_primitive_value_callback() != NULL, &quot;no callback&quot;);
2369 
2370   // apply class filter
2371   if (is_filtered_by_klass_filter(str, context-&gt;klass_filter())) {
2372     return true;
2373   }
2374 
2375   CallbackWrapper wrapper(tag_map(), str);
2376 
2377   // apply tag filter
2378   if (is_filtered_by_heap_filter(wrapper.obj_tag(),
2379                                  wrapper.klass_tag(),
2380                                  context-&gt;heap_filter())) {
2381     return true;
2382   }
2383 
2384   // invoke the callback
2385   int res = invoke_string_value_callback(context-&gt;string_primitive_value_callback(),
2386                                          &amp;wrapper,
2387                                          str,
2388                                          (void*)user_data());
2389   return (!(res &amp; JVMTI_VISIT_ABORT));
2390 }
2391 
2392 // invoke the primitive field callback
2393 inline bool CallbackInvoker::report_primitive_field(jvmtiHeapReferenceKind ref_kind,
2394                                                     oop obj,
2395                                                     jint index,
2396                                                     address addr,
2397                                                     char type)
2398 {
2399   // for primitive fields only the index will be set
2400   static jvmtiHeapReferenceInfo reference_info = { 0 };
2401 
2402   AdvancedHeapWalkContext* context = advanced_context();
2403   assert(context-&gt;primitive_field_callback() != NULL, &quot;no callback&quot;);
2404 
2405   // apply class filter
2406   if (is_filtered_by_klass_filter(obj, context-&gt;klass_filter())) {
2407     return true;
2408   }
2409 
2410   CallbackWrapper wrapper(tag_map(), obj);
2411 
2412   // apply tag filter
2413   if (is_filtered_by_heap_filter(wrapper.obj_tag(),
2414                                  wrapper.klass_tag(),
2415                                  context-&gt;heap_filter())) {
2416     return true;
2417   }
2418 
2419   // the field index in the referrer
2420   reference_info.field.index = index;
2421 
2422   // map the type
2423   jvmtiPrimitiveType value_type = (jvmtiPrimitiveType)type;
2424 
2425   // setup the jvalue
2426   jvalue value;
2427   copy_to_jvalue(&amp;value, addr, value_type);
2428 
2429   jvmtiPrimitiveFieldCallback cb = context-&gt;primitive_field_callback();
2430   int res = (*cb)(ref_kind,
2431                   &amp;reference_info,
2432                   wrapper.klass_tag(),
2433                   wrapper.obj_tag_p(),
2434                   value,
2435                   value_type,
2436                   (void*)user_data());
2437   return (!(res &amp; JVMTI_VISIT_ABORT));
2438 }
2439 
2440 
2441 // instance field
2442 inline bool CallbackInvoker::report_primitive_instance_field(oop obj,
2443                                                              jint index,
2444                                                              address value,
2445                                                              char type) {
2446   return report_primitive_field(JVMTI_HEAP_REFERENCE_FIELD,
2447                                 obj,
2448                                 index,
2449                                 value,
2450                                 type);
2451 }
2452 
2453 // static field
2454 inline bool CallbackInvoker::report_primitive_static_field(oop obj,
2455                                                            jint index,
2456                                                            address value,
2457                                                            char type) {
2458   return report_primitive_field(JVMTI_HEAP_REFERENCE_STATIC_FIELD,
2459                                 obj,
2460                                 index,
2461                                 value,
2462                                 type);
2463 }
2464 
2465 // report a JNI local (root object) to the profiler
2466 inline bool CallbackInvoker::report_jni_local_root(jlong thread_tag, jlong tid, jint depth, jmethodID m, oop obj) {
2467   if (is_basic_heap_walk()) {
2468     return invoke_basic_stack_ref_callback(JVMTI_HEAP_ROOT_JNI_LOCAL,
2469                                            thread_tag,
2470                                            depth,
2471                                            m,
2472                                            -1,
2473                                            obj);
2474   } else {
2475     return invoke_advanced_stack_ref_callback(JVMTI_HEAP_REFERENCE_JNI_LOCAL,
2476                                               thread_tag, tid,
2477                                               depth,
2478                                               m,
2479                                               (jlocation)-1,
2480                                               -1,
2481                                               obj);
2482   }
2483 }
2484 
2485 
2486 // report a local (stack reference, root object)
2487 inline bool CallbackInvoker::report_stack_ref_root(jlong thread_tag,
2488                                                    jlong tid,
2489                                                    jint depth,
2490                                                    jmethodID method,
2491                                                    jlocation bci,
2492                                                    jint slot,
2493                                                    oop obj) {
2494   if (is_basic_heap_walk()) {
2495     return invoke_basic_stack_ref_callback(JVMTI_HEAP_ROOT_STACK_LOCAL,
2496                                            thread_tag,
2497                                            depth,
2498                                            method,
2499                                            slot,
2500                                            obj);
2501   } else {
2502     return invoke_advanced_stack_ref_callback(JVMTI_HEAP_REFERENCE_STACK_LOCAL,
2503                                               thread_tag,
2504                                               tid,
2505                                               depth,
2506                                               method,
2507                                               bci,
2508                                               slot,
2509                                               obj);
2510   }
2511 }
2512 
2513 // report an object referencing a class.
2514 inline bool CallbackInvoker::report_class_reference(oop referrer, oop referree) {
2515   if (is_basic_heap_walk()) {
2516     return invoke_basic_object_reference_callback(JVMTI_REFERENCE_CLASS, referrer, referree, -1);
2517   } else {
2518     return invoke_advanced_object_reference_callback(JVMTI_HEAP_REFERENCE_CLASS, referrer, referree, -1);
2519   }
2520 }
2521 
2522 // report a class referencing its class loader.
2523 inline bool CallbackInvoker::report_class_loader_reference(oop referrer, oop referree) {
2524   if (is_basic_heap_walk()) {
2525     return invoke_basic_object_reference_callback(JVMTI_REFERENCE_CLASS_LOADER, referrer, referree, -1);
2526   } else {
2527     return invoke_advanced_object_reference_callback(JVMTI_HEAP_REFERENCE_CLASS_LOADER, referrer, referree, -1);
2528   }
2529 }
2530 
2531 // report a class referencing its signers.
2532 inline bool CallbackInvoker::report_signers_reference(oop referrer, oop referree) {
2533   if (is_basic_heap_walk()) {
2534     return invoke_basic_object_reference_callback(JVMTI_REFERENCE_SIGNERS, referrer, referree, -1);
2535   } else {
2536     return invoke_advanced_object_reference_callback(JVMTI_HEAP_REFERENCE_SIGNERS, referrer, referree, -1);
2537   }
2538 }
2539 
2540 // report a class referencing its protection domain..
2541 inline bool CallbackInvoker::report_protection_domain_reference(oop referrer, oop referree) {
2542   if (is_basic_heap_walk()) {
2543     return invoke_basic_object_reference_callback(JVMTI_REFERENCE_PROTECTION_DOMAIN, referrer, referree, -1);
2544   } else {
2545     return invoke_advanced_object_reference_callback(JVMTI_HEAP_REFERENCE_PROTECTION_DOMAIN, referrer, referree, -1);
2546   }
2547 }
2548 
2549 // report a class referencing its superclass.
2550 inline bool CallbackInvoker::report_superclass_reference(oop referrer, oop referree) {
2551   if (is_basic_heap_walk()) {
2552     // Send this to be consistent with past implementation
2553     return invoke_basic_object_reference_callback(JVMTI_REFERENCE_CLASS, referrer, referree, -1);
2554   } else {
2555     return invoke_advanced_object_reference_callback(JVMTI_HEAP_REFERENCE_SUPERCLASS, referrer, referree, -1);
2556   }
2557 }
2558 
2559 // report a class referencing one of its interfaces.
2560 inline bool CallbackInvoker::report_interface_reference(oop referrer, oop referree) {
2561   if (is_basic_heap_walk()) {
2562     return invoke_basic_object_reference_callback(JVMTI_REFERENCE_INTERFACE, referrer, referree, -1);
2563   } else {
2564     return invoke_advanced_object_reference_callback(JVMTI_HEAP_REFERENCE_INTERFACE, referrer, referree, -1);
2565   }
2566 }
2567 
2568 // report a class referencing one of its static fields.
2569 inline bool CallbackInvoker::report_static_field_reference(oop referrer, oop referree, jint slot) {
2570   if (is_basic_heap_walk()) {
2571     return invoke_basic_object_reference_callback(JVMTI_REFERENCE_STATIC_FIELD, referrer, referree, slot);
2572   } else {
2573     return invoke_advanced_object_reference_callback(JVMTI_HEAP_REFERENCE_STATIC_FIELD, referrer, referree, slot);
2574   }
2575 }
2576 
2577 // report an array referencing an element object
2578 inline bool CallbackInvoker::report_array_element_reference(oop referrer, oop referree, jint index) {
2579   if (is_basic_heap_walk()) {
2580     return invoke_basic_object_reference_callback(JVMTI_REFERENCE_ARRAY_ELEMENT, referrer, referree, index);
2581   } else {
2582     return invoke_advanced_object_reference_callback(JVMTI_HEAP_REFERENCE_ARRAY_ELEMENT, referrer, referree, index);
2583   }
2584 }
2585 
2586 // report an object referencing an instance field object
2587 inline bool CallbackInvoker::report_field_reference(oop referrer, oop referree, jint slot) {
2588   if (is_basic_heap_walk()) {
2589     return invoke_basic_object_reference_callback(JVMTI_REFERENCE_FIELD, referrer, referree, slot);
2590   } else {
2591     return invoke_advanced_object_reference_callback(JVMTI_HEAP_REFERENCE_FIELD, referrer, referree, slot);
2592   }
2593 }
2594 
2595 // report an array referencing an element object
2596 inline bool CallbackInvoker::report_constant_pool_reference(oop referrer, oop referree, jint index) {
2597   if (is_basic_heap_walk()) {
2598     return invoke_basic_object_reference_callback(JVMTI_REFERENCE_CONSTANT_POOL, referrer, referree, index);
2599   } else {
2600     return invoke_advanced_object_reference_callback(JVMTI_HEAP_REFERENCE_CONSTANT_POOL, referrer, referree, index);
2601   }
2602 }
2603 
2604 // A supporting closure used to process simple roots
2605 class SimpleRootsClosure : public OopClosure {
2606  private:
2607   jvmtiHeapReferenceKind _kind;
2608   bool _continue;
2609 
2610   jvmtiHeapReferenceKind root_kind()    { return _kind; }
2611 
2612  public:
2613   void set_kind(jvmtiHeapReferenceKind kind) {
2614     _kind = kind;
2615     _continue = true;
2616   }
2617 
2618   inline bool stopped() {
2619     return !_continue;
2620   }
2621 
2622   void do_oop(oop* obj_p) {
2623     // iteration has terminated
2624     if (stopped()) {
2625       return;
2626     }
2627 
2628     oop o = NativeAccess&lt;AS_NO_KEEPALIVE&gt;::oop_load(obj_p);
2629     // ignore null
2630     if (o == NULL) {
2631       return;
2632     }
2633 
2634     assert(Universe::heap()-&gt;is_in(o), &quot;should be impossible&quot;);
2635 
2636     jvmtiHeapReferenceKind kind = root_kind();
2637     if (kind == JVMTI_HEAP_REFERENCE_SYSTEM_CLASS) {
2638       // SystemDictionary::oops_do reports the application
2639       // class loader as a root. We want this root to be reported as
2640       // a root kind of &quot;OTHER&quot; rather than &quot;SYSTEM_CLASS&quot;.
2641       if (!o-&gt;is_instance() || !InstanceKlass::cast(o-&gt;klass())-&gt;is_mirror_instance_klass()) {
2642         kind = JVMTI_HEAP_REFERENCE_OTHER;
2643       }
2644     }
2645 
2646     // invoke the callback
2647     _continue = CallbackInvoker::report_simple_root(kind, o);
2648 
2649   }
2650   virtual void do_oop(narrowOop* obj_p) { ShouldNotReachHere(); }
2651 };
2652 
2653 // A supporting closure used to process JNI locals
2654 class JNILocalRootsClosure : public OopClosure {
2655  private:
2656   jlong _thread_tag;
2657   jlong _tid;
2658   jint _depth;
2659   jmethodID _method;
2660   bool _continue;
2661  public:
2662   void set_context(jlong thread_tag, jlong tid, jint depth, jmethodID method) {
2663     _thread_tag = thread_tag;
2664     _tid = tid;
2665     _depth = depth;
2666     _method = method;
2667     _continue = true;
2668   }
2669 
2670   inline bool stopped() {
2671     return !_continue;
2672   }
2673 
2674   void do_oop(oop* obj_p) {
2675     // iteration has terminated
2676     if (stopped()) {
2677       return;
2678     }
2679 
2680     oop o = *obj_p;
2681     // ignore null
2682     if (o == NULL) {
2683       return;
2684     }
2685 
2686     // invoke the callback
2687     _continue = CallbackInvoker::report_jni_local_root(_thread_tag, _tid, _depth, _method, o);
2688   }
2689   virtual void do_oop(narrowOop* obj_p) { ShouldNotReachHere(); }
2690 };
2691 
2692 
2693 // A VM operation to iterate over objects that are reachable from
2694 // a set of roots or an initial object.
2695 //
2696 // For VM_HeapWalkOperation the set of roots used is :-
2697 //
2698 // - All JNI global references
2699 // - All inflated monitors
2700 // - All classes loaded by the boot class loader (or all classes
2701 //     in the event that class unloading is disabled)
2702 // - All java threads
2703 // - For each java thread then all locals and JNI local references
2704 //      on the thread&#39;s execution stack
2705 // - All visible/explainable objects from Universes::oops_do
2706 //
2707 class VM_HeapWalkOperation: public VM_Operation {
2708  private:
2709   enum {
2710     initial_visit_stack_size = 4000
2711   };
2712 
2713   bool _is_advanced_heap_walk;                      // indicates FollowReferences
2714   JvmtiTagMap* _tag_map;
2715   Handle _initial_object;
2716   GrowableArray&lt;oop&gt;* _visit_stack;                 // the visit stack
2717 
2718   bool _collecting_heap_roots;                      // are we collecting roots
2719   bool _following_object_refs;                      // are we following object references
2720 
2721   bool _reporting_primitive_fields;                 // optional reporting
2722   bool _reporting_primitive_array_values;
2723   bool _reporting_string_values;
2724 
2725   GrowableArray&lt;oop&gt;* create_visit_stack() {
2726     return new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;oop&gt;(initial_visit_stack_size, true);
2727   }
2728 
2729   // accessors
2730   bool is_advanced_heap_walk() const               { return _is_advanced_heap_walk; }
2731   JvmtiTagMap* tag_map() const                     { return _tag_map; }
2732   Handle initial_object() const                    { return _initial_object; }
2733 
2734   bool is_following_references() const             { return _following_object_refs; }
2735 
2736   bool is_reporting_primitive_fields()  const      { return _reporting_primitive_fields; }
2737   bool is_reporting_primitive_array_values() const { return _reporting_primitive_array_values; }
2738   bool is_reporting_string_values() const          { return _reporting_string_values; }
2739 
2740   GrowableArray&lt;oop&gt;* visit_stack() const          { return _visit_stack; }
2741 
2742   // iterate over the various object types
2743   inline bool iterate_over_array(oop o);
2744   inline bool iterate_over_type_array(oop o);
2745   inline bool iterate_over_class(oop o);
2746   inline bool iterate_over_object(oop o);
2747 
2748   // root collection
2749   inline bool collect_simple_roots();
2750   inline bool collect_stack_roots();
2751   inline bool collect_stack_roots(JavaThread* java_thread, JNILocalRootsClosure* blk);
2752 
2753   // visit an object
2754   inline bool visit(oop o);
2755 
2756  public:
2757   VM_HeapWalkOperation(JvmtiTagMap* tag_map,
2758                        Handle initial_object,
2759                        BasicHeapWalkContext callbacks,
2760                        const void* user_data);
2761 
2762   VM_HeapWalkOperation(JvmtiTagMap* tag_map,
2763                        Handle initial_object,
2764                        AdvancedHeapWalkContext callbacks,
2765                        const void* user_data);
2766 
2767   ~VM_HeapWalkOperation();
2768 
2769   VMOp_Type type() const { return VMOp_HeapWalkOperation; }
2770   void doit();
2771 };
2772 
2773 
2774 VM_HeapWalkOperation::VM_HeapWalkOperation(JvmtiTagMap* tag_map,
2775                                            Handle initial_object,
2776                                            BasicHeapWalkContext callbacks,
2777                                            const void* user_data) {
2778   _is_advanced_heap_walk = false;
2779   _tag_map = tag_map;
2780   _initial_object = initial_object;
2781   _following_object_refs = (callbacks.object_ref_callback() != NULL);
2782   _reporting_primitive_fields = false;
2783   _reporting_primitive_array_values = false;
2784   _reporting_string_values = false;
2785   _visit_stack = create_visit_stack();
2786 
2787 
2788   CallbackInvoker::initialize_for_basic_heap_walk(tag_map, _visit_stack, user_data, callbacks);
2789 }
2790 
2791 VM_HeapWalkOperation::VM_HeapWalkOperation(JvmtiTagMap* tag_map,
2792                                            Handle initial_object,
2793                                            AdvancedHeapWalkContext callbacks,
2794                                            const void* user_data) {
2795   _is_advanced_heap_walk = true;
2796   _tag_map = tag_map;
2797   _initial_object = initial_object;
2798   _following_object_refs = true;
2799   _reporting_primitive_fields = (callbacks.primitive_field_callback() != NULL);;
2800   _reporting_primitive_array_values = (callbacks.array_primitive_value_callback() != NULL);;
2801   _reporting_string_values = (callbacks.string_primitive_value_callback() != NULL);;
2802   _visit_stack = create_visit_stack();
2803 
2804   CallbackInvoker::initialize_for_advanced_heap_walk(tag_map, _visit_stack, user_data, callbacks);
2805 }
2806 
2807 VM_HeapWalkOperation::~VM_HeapWalkOperation() {
2808   if (_following_object_refs) {
2809     assert(_visit_stack != NULL, &quot;checking&quot;);
2810     delete _visit_stack;
2811     _visit_stack = NULL;
2812   }
2813 }
2814 
2815 // an array references its class and has a reference to
2816 // each element in the array
2817 inline bool VM_HeapWalkOperation::iterate_over_array(oop o) {
2818   objArrayOop array = objArrayOop(o);
2819 
2820   // array reference to its class
2821   oop mirror = ObjArrayKlass::cast(array-&gt;klass())-&gt;java_mirror();
2822   if (!CallbackInvoker::report_class_reference(o, mirror)) {
2823     return false;
2824   }
2825 
2826   // iterate over the array and report each reference to a
2827   // non-null element
2828   for (int index=0; index&lt;array-&gt;length(); index++) {
2829     oop elem = array-&gt;obj_at(index);
2830     if (elem == NULL) {
2831       continue;
2832     }
2833 
2834     // report the array reference o[index] = elem
2835     if (!CallbackInvoker::report_array_element_reference(o, elem, index)) {
2836       return false;
2837     }
2838   }
2839   return true;
2840 }
2841 
2842 // a type array references its class
2843 inline bool VM_HeapWalkOperation::iterate_over_type_array(oop o) {
2844   Klass* k = o-&gt;klass();
2845   oop mirror = k-&gt;java_mirror();
2846   if (!CallbackInvoker::report_class_reference(o, mirror)) {
2847     return false;
2848   }
2849 
2850   // report the array contents if required
2851   if (is_reporting_primitive_array_values()) {
2852     if (!CallbackInvoker::report_primitive_array_values(o)) {
2853       return false;
2854     }
2855   }
2856   return true;
2857 }
2858 
2859 #ifdef ASSERT
2860 // verify that a static oop field is in range
2861 static inline bool verify_static_oop(InstanceKlass* ik,
2862                                      oop mirror, int offset) {
2863   address obj_p = cast_from_oop&lt;address&gt;(mirror) + offset;
2864   address start = (address)InstanceMirrorKlass::start_of_static_fields(mirror);
2865   address end = start + (java_lang_Class::static_oop_field_count(mirror) * heapOopSize);
2866   assert(end &gt;= start, &quot;sanity check&quot;);
2867 
2868   if (obj_p &gt;= start &amp;&amp; obj_p &lt; end) {
2869     return true;
2870   } else {
2871     return false;
2872   }
2873 }
2874 #endif // #ifdef ASSERT
2875 
2876 // a class references its super class, interfaces, class loader, ...
2877 // and finally its static fields
2878 inline bool VM_HeapWalkOperation::iterate_over_class(oop java_class) {
2879   int i;
2880   Klass* klass = java_lang_Class::as_Klass(java_class);
2881 
2882   if (klass-&gt;is_instance_klass()) {
2883     InstanceKlass* ik = InstanceKlass::cast(klass);
2884 
2885     // Ignore the class if it hasn&#39;t been initialized yet
2886     if (!ik-&gt;is_linked()) {
2887       return true;
2888     }
2889 
2890     // get the java mirror
2891     oop mirror = klass-&gt;java_mirror();
2892 
2893     // super (only if something more interesting than java.lang.Object)
2894     InstanceKlass* java_super = ik-&gt;java_super();
2895     if (java_super != NULL &amp;&amp; java_super != SystemDictionary::Object_klass()) {
2896       oop super = java_super-&gt;java_mirror();
2897       if (!CallbackInvoker::report_superclass_reference(mirror, super)) {
2898         return false;
2899       }
2900     }
2901 
2902     // class loader
2903     oop cl = ik-&gt;class_loader();
2904     if (cl != NULL) {
2905       if (!CallbackInvoker::report_class_loader_reference(mirror, cl)) {
2906         return false;
2907       }
2908     }
2909 
2910     // protection domain
2911     oop pd = ik-&gt;protection_domain();
2912     if (pd != NULL) {
2913       if (!CallbackInvoker::report_protection_domain_reference(mirror, pd)) {
2914         return false;
2915       }
2916     }
2917 
2918     // signers
2919     oop signers = ik-&gt;signers();
2920     if (signers != NULL) {
2921       if (!CallbackInvoker::report_signers_reference(mirror, signers)) {
2922         return false;
2923       }
2924     }
2925 
2926     // references from the constant pool
2927     {
2928       ConstantPool* pool = ik-&gt;constants();
2929       for (int i = 1; i &lt; pool-&gt;length(); i++) {
2930         constantTag tag = pool-&gt;tag_at(i).value();
2931         if (tag.is_string() || tag.is_klass() || tag.is_unresolved_klass()) {
2932           oop entry;
2933           if (tag.is_string()) {
2934             entry = pool-&gt;resolved_string_at(i);
2935             // If the entry is non-null it is resolved.
2936             if (entry == NULL) {
2937               continue;
2938             }
2939           } else if (tag.is_klass()) {
2940             entry = pool-&gt;resolved_klass_at(i)-&gt;java_mirror();
2941           } else {
2942             // Code generated by JIT and AOT compilers might not resolve constant
2943             // pool entries.  Treat them as resolved if they are loaded.
2944             assert(tag.is_unresolved_klass(), &quot;must be&quot;);
2945             constantPoolHandle cp(Thread::current(), pool);
2946             Klass* klass = ConstantPool::klass_at_if_loaded(cp, i);
2947             if (klass == NULL) {
2948               continue;
2949             }
2950             entry = klass-&gt;java_mirror();
2951           }
2952           if (!CallbackInvoker::report_constant_pool_reference(mirror, entry, (jint)i)) {
2953             return false;
2954           }
2955         }
2956       }
2957     }
2958 
2959     // interfaces
2960     // (These will already have been reported as references from the constant pool
2961     //  but are specified by IterateOverReachableObjects and must be reported).
2962     Array&lt;InstanceKlass*&gt;* interfaces = ik-&gt;local_interfaces();
2963     for (i = 0; i &lt; interfaces-&gt;length(); i++) {
2964       oop interf = interfaces-&gt;at(i)-&gt;java_mirror();
2965       if (interf == NULL) {
2966         continue;
2967       }
2968       if (!CallbackInvoker::report_interface_reference(mirror, interf)) {
2969         return false;
2970       }
2971     }
2972 
2973     // iterate over the static fields
2974 
2975     ClassFieldMap* field_map = ClassFieldMap::create_map_of_static_fields(klass);
2976     for (i=0; i&lt;field_map-&gt;field_count(); i++) {
2977       ClassFieldDescriptor* field = field_map-&gt;field_at(i);
2978       char type = field-&gt;field_type();
2979       if (!is_primitive_field_type(type)) {
2980         oop fld_o = mirror-&gt;obj_field(field-&gt;field_offset());
2981         assert(verify_static_oop(ik, mirror, field-&gt;field_offset()), &quot;sanity check&quot;);
2982         if (fld_o != NULL) {
2983           int slot = field-&gt;field_index();
2984           if (!CallbackInvoker::report_static_field_reference(mirror, fld_o, slot)) {
2985             delete field_map;
2986             return false;
2987           }
2988         }
2989       } else {
2990          if (is_reporting_primitive_fields()) {
2991            address addr = cast_from_oop&lt;address&gt;(mirror) + field-&gt;field_offset();
2992            int slot = field-&gt;field_index();
2993            if (!CallbackInvoker::report_primitive_static_field(mirror, slot, addr, type)) {
2994              delete field_map;
2995              return false;
2996           }
2997         }
2998       }
2999     }
3000     delete field_map;
3001 
3002     return true;
3003   }
3004 
3005   return true;
3006 }
3007 
3008 // an object references a class and its instance fields
3009 // (static fields are ignored here as we report these as
3010 // references from the class).
3011 inline bool VM_HeapWalkOperation::iterate_over_object(oop o) {
3012   // reference to the class
3013   if (!CallbackInvoker::report_class_reference(o, o-&gt;klass()-&gt;java_mirror())) {
3014     return false;
3015   }
3016 
3017   // iterate over instance fields
3018   ClassFieldMap* field_map = JvmtiCachedClassFieldMap::get_map_of_instance_fields(o);
3019   for (int i=0; i&lt;field_map-&gt;field_count(); i++) {
3020     ClassFieldDescriptor* field = field_map-&gt;field_at(i);
3021     char type = field-&gt;field_type();
3022     if (!is_primitive_field_type(type)) {
3023       oop fld_o = o-&gt;obj_field_access&lt;AS_NO_KEEPALIVE | ON_UNKNOWN_OOP_REF&gt;(field-&gt;field_offset());
3024       // ignore any objects that aren&#39;t visible to profiler
3025       if (fld_o != NULL) {
3026         assert(Universe::heap()-&gt;is_in(fld_o), &quot;unsafe code should not &quot;
3027                &quot;have references to Klass* anymore&quot;);
3028         int slot = field-&gt;field_index();
3029         if (!CallbackInvoker::report_field_reference(o, fld_o, slot)) {
3030           return false;
3031         }
3032       }
3033     } else {
3034       if (is_reporting_primitive_fields()) {
3035         // primitive instance field
3036         address addr = cast_from_oop&lt;address&gt;(o) + field-&gt;field_offset();
3037         int slot = field-&gt;field_index();
3038         if (!CallbackInvoker::report_primitive_instance_field(o, slot, addr, type)) {
3039           return false;
3040         }
3041       }
3042     }
3043   }
3044 
3045   // if the object is a java.lang.String
3046   if (is_reporting_string_values() &amp;&amp;
3047       o-&gt;klass() == SystemDictionary::String_klass()) {
3048     if (!CallbackInvoker::report_string_value(o)) {
3049       return false;
3050     }
3051   }
3052   return true;
3053 }
3054 
3055 
3056 // Collects all simple (non-stack) roots except for threads;
3057 // threads are handled in collect_stack_roots() as an optimization.
3058 // if there&#39;s a heap root callback provided then the callback is
3059 // invoked for each simple root.
3060 // if an object reference callback is provided then all simple
3061 // roots are pushed onto the marking stack so that they can be
3062 // processed later
3063 //
3064 inline bool VM_HeapWalkOperation::collect_simple_roots() {
3065   SimpleRootsClosure blk;
3066 
3067   // JNI globals
3068   blk.set_kind(JVMTI_HEAP_REFERENCE_JNI_GLOBAL);
3069   JNIHandles::oops_do(&amp;blk);
3070   if (blk.stopped()) {
3071     return false;
3072   }
3073 
3074   // Preloaded classes and loader from the system dictionary
3075   blk.set_kind(JVMTI_HEAP_REFERENCE_SYSTEM_CLASS);
3076   SystemDictionary::oops_do(&amp;blk);
3077   CLDToOopClosure cld_closure(&amp;blk, false);
3078   ClassLoaderDataGraph::always_strong_cld_do(&amp;cld_closure);
3079   if (blk.stopped()) {
3080     return false;
3081   }
3082 
3083   // Inflated monitors
3084   blk.set_kind(JVMTI_HEAP_REFERENCE_MONITOR);
3085   ObjectSynchronizer::oops_do(&amp;blk);
3086   if (blk.stopped()) {
3087     return false;
3088   }
3089 
3090   // threads are now handled in collect_stack_roots()
3091 
3092   // Other kinds of roots maintained by HotSpot
3093   // Many of these won&#39;t be visible but others (such as instances of important
3094   // exceptions) will be visible.
3095   blk.set_kind(JVMTI_HEAP_REFERENCE_OTHER);
3096   Universe::oops_do(&amp;blk);
3097   if (blk.stopped()) {
3098     return false;
3099   }
3100 
3101   return true;
3102 }
3103 
3104 // Walk the stack of a given thread and find all references (locals
3105 // and JNI calls) and report these as stack references
3106 inline bool VM_HeapWalkOperation::collect_stack_roots(JavaThread* java_thread,
3107                                                       JNILocalRootsClosure* blk)
3108 {
3109   oop threadObj = java_thread-&gt;threadObj();
3110   assert(threadObj != NULL, &quot;sanity check&quot;);
3111 
3112   // only need to get the thread&#39;s tag once per thread
3113   jlong thread_tag = tag_for(_tag_map, threadObj);
3114 
3115   // also need the thread id
3116   jlong tid = java_lang_Thread::thread_id(threadObj);
3117 
3118 
3119   if (java_thread-&gt;has_last_Java_frame()) {
3120 
3121     // vframes are resource allocated
3122     Thread* current_thread = Thread::current();
3123     ResourceMark rm(current_thread);
3124     HandleMark hm(current_thread);
3125 
3126     RegisterMap reg_map(java_thread);
3127     frame f = java_thread-&gt;last_frame();
3128     vframe* vf = vframe::new_vframe(&amp;f, &amp;reg_map, java_thread);
3129 
3130     bool is_top_frame = true;
3131     int depth = 0;
3132     frame* last_entry_frame = NULL;
3133 
3134     while (vf != NULL) {
3135       if (vf-&gt;is_java_frame()) {
3136 
3137         // java frame (interpreted, compiled, ...)
3138         javaVFrame *jvf = javaVFrame::cast(vf);
3139 
3140         // the jmethodID
3141         jmethodID method = jvf-&gt;method()-&gt;jmethod_id();
3142 
3143         if (!(jvf-&gt;method()-&gt;is_native())) {
3144           jlocation bci = (jlocation)jvf-&gt;bci();
3145           StackValueCollection* locals = jvf-&gt;locals();
3146           for (int slot=0; slot&lt;locals-&gt;size(); slot++) {
3147             if (locals-&gt;at(slot)-&gt;type() == T_OBJECT) {
3148               oop o = locals-&gt;obj_at(slot)();
3149               if (o == NULL) {
3150                 continue;
3151               }
3152 
3153               // stack reference
3154               if (!CallbackInvoker::report_stack_ref_root(thread_tag, tid, depth, method,
3155                                                    bci, slot, o)) {
3156                 return false;
3157               }
3158             }
3159           }
3160 
3161           StackValueCollection* exprs = jvf-&gt;expressions();
3162           for (int index=0; index &lt; exprs-&gt;size(); index++) {
3163             if (exprs-&gt;at(index)-&gt;type() == T_OBJECT) {
3164               oop o = exprs-&gt;obj_at(index)();
3165               if (o == NULL) {
3166                 continue;
3167               }
3168 
3169               // stack reference
3170               if (!CallbackInvoker::report_stack_ref_root(thread_tag, tid, depth, method,
3171                                                    bci, locals-&gt;size() + index, o)) {
3172                 return false;
3173               }
3174             }
3175           }
3176 
3177           // Follow oops from compiled nmethod
3178           if (jvf-&gt;cb() != NULL &amp;&amp; jvf-&gt;cb()-&gt;is_nmethod()) {
3179             blk-&gt;set_context(thread_tag, tid, depth, method);
3180             jvf-&gt;cb()-&gt;as_nmethod()-&gt;oops_do(blk);
3181           }
3182         } else {
3183           blk-&gt;set_context(thread_tag, tid, depth, method);
3184           if (is_top_frame) {
3185             // JNI locals for the top frame.
3186             java_thread-&gt;active_handles()-&gt;oops_do(blk);
3187           } else {
3188             if (last_entry_frame != NULL) {
3189               // JNI locals for the entry frame
3190               assert(last_entry_frame-&gt;is_entry_frame(), &quot;checking&quot;);
3191               last_entry_frame-&gt;entry_frame_call_wrapper()-&gt;handles()-&gt;oops_do(blk);
3192             }
3193           }
3194         }
3195         last_entry_frame = NULL;
3196         depth++;
3197       } else {
3198         // externalVFrame - for an entry frame then we report the JNI locals
3199         // when we find the corresponding javaVFrame
3200         frame* fr = vf-&gt;frame_pointer();
3201         assert(fr != NULL, &quot;sanity check&quot;);
3202         if (fr-&gt;is_entry_frame()) {
3203           last_entry_frame = fr;
3204         }
3205       }
3206 
3207       vf = vf-&gt;sender();
3208       is_top_frame = false;
3209     }
3210   } else {
3211     // no last java frame but there may be JNI locals
3212     blk-&gt;set_context(thread_tag, tid, 0, (jmethodID)NULL);
3213     java_thread-&gt;active_handles()-&gt;oops_do(blk);
3214   }
3215   return true;
3216 }
3217 
3218 
3219 // Collects the simple roots for all threads and collects all
3220 // stack roots - for each thread it walks the execution
3221 // stack to find all references and local JNI refs.
3222 inline bool VM_HeapWalkOperation::collect_stack_roots() {
3223   JNILocalRootsClosure blk;
3224   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {
3225     oop threadObj = thread-&gt;threadObj();
3226     if (threadObj != NULL &amp;&amp; !thread-&gt;is_exiting() &amp;&amp; !thread-&gt;is_hidden_from_external_view()) {
3227       // Collect the simple root for this thread before we
3228       // collect its stack roots
3229       if (!CallbackInvoker::report_simple_root(JVMTI_HEAP_REFERENCE_THREAD,
3230                                                threadObj)) {
3231         return false;
3232       }
3233       if (!collect_stack_roots(thread, &amp;blk)) {
3234         return false;
3235       }
3236     }
3237   }
3238   return true;
3239 }
3240 
3241 // visit an object
3242 // first mark the object as visited
3243 // second get all the outbound references from this object (in other words, all
3244 // the objects referenced by this object).
3245 //
3246 bool VM_HeapWalkOperation::visit(oop o) {
3247   // mark object as visited
3248   assert(!ObjectMarker::visited(o), &quot;can&#39;t visit same object more than once&quot;);
3249   ObjectMarker::mark(o);
3250 
3251   // instance
3252   if (o-&gt;is_instance()) {
3253     if (o-&gt;klass() == SystemDictionary::Class_klass()) {
3254       if (!java_lang_Class::is_primitive(o)) {
3255         // a java.lang.Class
3256         return iterate_over_class(o);
3257       }
3258     } else {
3259       return iterate_over_object(o);
3260     }
3261   }
3262 
3263   // object array
3264   if (o-&gt;is_objArray()) {
3265     return iterate_over_array(o);
3266   }
3267 
3268   // type array
3269   if (o-&gt;is_typeArray()) {
3270     return iterate_over_type_array(o);
3271   }
3272 
3273   return true;
3274 }
3275 
3276 void VM_HeapWalkOperation::doit() {
<a name="14" id="anc14"></a><span class="line-added">3277   // This annotation is reasonably minimal in number of tsan callbacks.</span>
<span class="line-added">3278   // By passing the lock directly, we are not actually locking it, just</span>
<span class="line-added">3279   // telling TSAN we are to &quot;simulate&quot; the lock.</span>
<span class="line-added">3280   TSAN_ONLY(TsanMutexScope tms(_tag_map-&gt;lock()));</span>
<span class="line-added">3281 </span>
3282   ResourceMark rm;
3283   ObjectMarkerController marker;
3284   ClassFieldMapCacheMark cm;
3285 
3286   assert(visit_stack()-&gt;is_empty(), &quot;visit stack must be empty&quot;);
3287 
3288   // the heap walk starts with an initial object or the heap roots
3289   if (initial_object().is_null()) {
3290     // If either collect_stack_roots() or collect_simple_roots()
3291     // returns false at this point, then there are no mark bits
3292     // to reset.
3293     ObjectMarker::set_needs_reset(false);
3294 
3295     // Calling collect_stack_roots() before collect_simple_roots()
3296     // can result in a big performance boost for an agent that is
3297     // focused on analyzing references in the thread stacks.
3298     if (!collect_stack_roots()) return;
3299 
3300     if (!collect_simple_roots()) return;
3301 
3302     // no early return so enable heap traversal to reset the mark bits
3303     ObjectMarker::set_needs_reset(true);
3304   } else {
3305     visit_stack()-&gt;push(initial_object()());
3306   }
3307 
3308   // object references required
3309   if (is_following_references()) {
3310 
3311     // visit each object until all reachable objects have been
3312     // visited or the callback asked to terminate the iteration.
3313     while (!visit_stack()-&gt;is_empty()) {
3314       oop o = visit_stack()-&gt;pop();
3315       if (!ObjectMarker::visited(o)) {
3316         if (!visit(o)) {
3317           break;
3318         }
3319       }
3320     }
3321   }
3322 }
3323 
3324 // iterate over all objects that are reachable from a set of roots
3325 void JvmtiTagMap::iterate_over_reachable_objects(jvmtiHeapRootCallback heap_root_callback,
3326                                                  jvmtiStackReferenceCallback stack_ref_callback,
3327                                                  jvmtiObjectReferenceCallback object_ref_callback,
3328                                                  const void* user_data) {
3329   MutexLocker ml(Heap_lock);
3330   BasicHeapWalkContext context(heap_root_callback, stack_ref_callback, object_ref_callback);
3331   VM_HeapWalkOperation op(this, Handle(), context, user_data);
3332   VMThread::execute(&amp;op);
3333 }
3334 
3335 // iterate over all objects that are reachable from a given object
3336 void JvmtiTagMap::iterate_over_objects_reachable_from_object(jobject object,
3337                                                              jvmtiObjectReferenceCallback object_ref_callback,
3338                                                              const void* user_data) {
3339   oop obj = JNIHandles::resolve(object);
3340   Handle initial_object(Thread::current(), obj);
3341 
3342   MutexLocker ml(Heap_lock);
3343   BasicHeapWalkContext context(NULL, NULL, object_ref_callback);
3344   VM_HeapWalkOperation op(this, initial_object, context, user_data);
3345   VMThread::execute(&amp;op);
3346 }
3347 
3348 // follow references from an initial object or the GC roots
3349 void JvmtiTagMap::follow_references(jint heap_filter,
3350                                     Klass* klass,
3351                                     jobject object,
3352                                     const jvmtiHeapCallbacks* callbacks,
3353                                     const void* user_data)
3354 {
3355   oop obj = JNIHandles::resolve(object);
3356   Handle initial_object(Thread::current(), obj);
3357 
3358   MutexLocker ml(Heap_lock);
3359   AdvancedHeapWalkContext context(heap_filter, klass, callbacks);
3360   VM_HeapWalkOperation op(this, initial_object, context, user_data);
3361   VMThread::execute(&amp;op);
3362 }
3363 
3364 
3365 void JvmtiTagMap::weak_oops_do(BoolObjectClosure* is_alive, OopClosure* f) {
3366   // No locks during VM bring-up (0 threads) and no safepoints after main
3367   // thread creation and before VMThread creation (1 thread); initial GC
3368   // verification can happen in that window which gets to here.
3369   assert(Threads::number_of_threads() &lt;= 1 ||
3370          SafepointSynchronize::is_at_safepoint(),
3371          &quot;must be executed at a safepoint&quot;);
3372   if (JvmtiEnv::environments_might_exist()) {
3373     JvmtiEnvIterator it;
3374     for (JvmtiEnvBase* env = it.first(); env != NULL; env = it.next(env)) {
3375       JvmtiTagMap* tag_map = env-&gt;tag_map_acquire();
3376       if (tag_map != NULL &amp;&amp; !tag_map-&gt;is_empty()) {
3377         tag_map-&gt;do_weak_oops(is_alive, f);
3378       }
3379     }
3380   }
3381 }
3382 
3383 void JvmtiTagMap::do_weak_oops(BoolObjectClosure* is_alive, OopClosure* f) {
3384 
3385   // does this environment have the OBJECT_FREE event enabled
3386   bool post_object_free = env()-&gt;is_enabled(JVMTI_EVENT_OBJECT_FREE);
3387 
3388   // counters used for trace message
3389   int freed = 0;
3390   int moved = 0;
3391 
3392   JvmtiTagHashmap* hashmap = this-&gt;hashmap();
3393 
3394   // reenable sizing (if disabled)
3395   hashmap-&gt;set_resizing_enabled(true);
3396 
3397   // if the hashmap is empty then we can skip it
3398   if (hashmap-&gt;_entry_count == 0) {
3399     return;
3400   }
3401 
3402   // now iterate through each entry in the table
3403 
3404   JvmtiTagHashmapEntry** table = hashmap-&gt;table();
3405   int size = hashmap-&gt;size();
3406 
3407   JvmtiTagHashmapEntry* delayed_add = NULL;
3408 
3409   for (int pos = 0; pos &lt; size; ++pos) {
3410     JvmtiTagHashmapEntry* entry = table[pos];
3411     JvmtiTagHashmapEntry* prev = NULL;
3412 
3413     while (entry != NULL) {
3414       JvmtiTagHashmapEntry* next = entry-&gt;next();
3415 
3416       // has object been GC&#39;ed
3417       if (!is_alive-&gt;do_object_b(entry-&gt;object_raw())) {
3418         // grab the tag
3419         jlong tag = entry-&gt;tag();
3420         guarantee(tag != 0, &quot;checking&quot;);
3421 
3422         // remove GC&#39;ed entry from hashmap and return the
3423         // entry to the free list
3424         hashmap-&gt;remove(prev, pos, entry);
3425         destroy_entry(entry);
3426 
3427         // post the event to the profiler
3428         if (post_object_free) {
3429           JvmtiExport::post_object_free(env(), tag);
3430         }
3431 
3432         ++freed;
3433       } else {
3434         f-&gt;do_oop(entry-&gt;object_addr());
3435         oop new_oop = entry-&gt;object_raw();
3436 
3437         // if the object has moved then re-hash it and move its
3438         // entry to its new location.
3439         unsigned int new_pos = JvmtiTagHashmap::hash(new_oop, size);
3440         if (new_pos != (unsigned int)pos) {
3441           if (prev == NULL) {
3442             table[pos] = next;
3443           } else {
3444             prev-&gt;set_next(next);
3445           }
3446           if (new_pos &lt; (unsigned int)pos) {
3447             entry-&gt;set_next(table[new_pos]);
3448             table[new_pos] = entry;
3449           } else {
3450             // Delay adding this entry to it&#39;s new position as we&#39;d end up
3451             // hitting it again during this iteration.
3452             entry-&gt;set_next(delayed_add);
3453             delayed_add = entry;
3454           }
3455           moved++;
3456         } else {
3457           // object didn&#39;t move
3458           prev = entry;
3459         }
3460       }
3461 
3462       entry = next;
3463     }
3464   }
3465 
3466   // Re-add all the entries which were kept aside
3467   while (delayed_add != NULL) {
3468     JvmtiTagHashmapEntry* next = delayed_add-&gt;next();
3469     unsigned int pos = JvmtiTagHashmap::hash(delayed_add-&gt;object_raw(), size);
3470     delayed_add-&gt;set_next(table[pos]);
3471     table[pos] = delayed_add;
3472     delayed_add = next;
3473   }
3474 
3475   log_debug(jvmti, objecttagging)(&quot;(%d-&gt;%d, %d freed, %d total moves)&quot;,
3476                                   hashmap-&gt;_entry_count + freed, hashmap-&gt;_entry_count, freed, moved);
3477 }
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/prims/jvmtiTagMap.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiRawMonitor.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiTagMap.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiTagMap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 57,10 ***</span>
<span class="line-new-header">--- 57,13 ---</span>
  #include &quot;runtime/thread.inline.hpp&quot;
  #include &quot;runtime/threadSMR.hpp&quot;
  #include &quot;runtime/vframe.hpp&quot;
  #include &quot;runtime/vmThread.hpp&quot;
  #include &quot;runtime/vmOperations.hpp&quot;
<span class="line-added">+ #if INCLUDE_TSAN</span>
<span class="line-added">+ #include &quot;tsan/tsan.hpp&quot;</span>
<span class="line-added">+ #endif  // INCLUDE_TSAN</span>
  #include &quot;utilities/macros.hpp&quot;
  #if INCLUDE_ZGC
  #include &quot;gc/z/zGlobals.hpp&quot;
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 375,10 ***</span>
<span class="line-new-header">--- 378,26 ---</span>
  
    // iterate over all entries in the hashmap
    void entry_iterate(JvmtiTagHashmapEntryClosure* closure);
  };
  
<span class="line-added">+ // Tsan should know that the JVMTI TagMap is protected by a mutex.</span>
<span class="line-added">+ class TsanMutexScope : public StackObj {</span>
<span class="line-added">+  private:</span>
<span class="line-added">+   Mutex *_lock;  // Keep my own reference, for destructor.</span>
<span class="line-added">+ </span>
<span class="line-added">+  public:</span>
<span class="line-added">+   // Don&#39;t actually lock it, just tell tsan we did.</span>
<span class="line-added">+   TsanMutexScope(Mutex* mutex) : _lock(mutex) {</span>
<span class="line-added">+     TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(_lock));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   ~TsanMutexScope() {</span>
<span class="line-added">+     TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(_lock));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
  // possible hashmap sizes - odd primes that roughly double in size.
  // To avoid excessive resizing the odd primes from 4801-76831 and
  // 76831-307261 have been removed. The list must be terminated by -1.
  int JvmtiTagHashmap::_sizes[] =  { 4801, 76831, 307261, 614563, 1228891,
      2457733, 4915219, 9830479, 19660831, 39321619, 78643219, -1 };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 443,20 ***</span>
    _free_entries_count(0)
  {
    assert(JvmtiThreadState_lock-&gt;is_locked(), &quot;sanity check&quot;);
    assert(((JvmtiEnvBase *)env)-&gt;tag_map() == NULL, &quot;tag map already exists for environment&quot;);
  
    _hashmap = new JvmtiTagHashmap();
  
    // finally add us to the environment
    ((JvmtiEnvBase *)env)-&gt;release_set_tag_map(this);
  }
  
  
  // destroy a JvmtiTagMap
  JvmtiTagMap::~JvmtiTagMap() {
<span class="line-removed">- </span>
    // no lock acquired as we assume the enclosing environment is
    // also being destroryed.
    ((JvmtiEnvBase *)_env)-&gt;set_tag_map(NULL);
  
    JvmtiTagHashmapEntry** table = _hashmap-&gt;table();
<span class="line-new-header">--- 462,37 ---</span>
    _free_entries_count(0)
  {
    assert(JvmtiThreadState_lock-&gt;is_locked(), &quot;sanity check&quot;);
    assert(((JvmtiEnvBase *)env)-&gt;tag_map() == NULL, &quot;tag map already exists for environment&quot;);
  
<span class="line-added">+   // TSAN Note: we cannot tell TSAN about the creation of this lock due to</span>
<span class="line-added">+   // this being seen as racy though is not really.</span>
<span class="line-added">+   //</span>
<span class="line-added">+   // The JvmtiTagMap gets created by the first thread to call tag_map_for; which</span>
<span class="line-added">+   // uses a lock to create it if need be.</span>
<span class="line-added">+   //</span>
<span class="line-added">+   // This means that this lock is created under a mutex but then,</span>
<span class="line-added">+   // subsequent uses do not have a lock to protect it (because not</span>
<span class="line-added">+   // needed in this case), however TSAN sees it as being needed because:</span>
<span class="line-added">+   //  - Another thread can come and get the newly created JvmtiTagMap without a</span>
<span class="line-added">+   //  lock and acquire the lock.</span>
<span class="line-added">+   //  - This provokes a race for TSAN on the lock itself, though there is no</span>
<span class="line-added">+   //  real issue.</span>
<span class="line-added">+   //</span>
<span class="line-added">+   //  Not creating the lock or having a fence mechanism to tell TSAN this is</span>
<span class="line-added">+   //  safe (a fake lock around this lock for example) seem to be the only</span>
<span class="line-added">+   //  solutions.</span>
<span class="line-added">+ </span>
    _hashmap = new JvmtiTagHashmap();
  
    // finally add us to the environment
    ((JvmtiEnvBase *)env)-&gt;release_set_tag_map(this);
  }
  
  
  // destroy a JvmtiTagMap
  JvmtiTagMap::~JvmtiTagMap() {
    // no lock acquired as we assume the enclosing environment is
    // also being destroryed.
    ((JvmtiEnvBase *)_env)-&gt;set_tag_map(NULL);
  
    JvmtiTagHashmapEntry** table = _hashmap-&gt;table();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 479,10 ***</span>
<span class="line-new-header">--- 515,12 ---</span>
      JvmtiTagHashmapEntry* next = entry-&gt;next();
      delete entry;
      entry = next;
    }
    _free_entries = NULL;
<span class="line-added">+ </span>
<span class="line-added">+   // TSAN Note: see above for the Tsan creation note.</span>
  }
  
  // create a hashmap entry
  // - if there&#39;s an entry on the (per-environment) free list then this
  // is returned. Otherwise an new entry is allocated.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 730,10 ***</span>
<span class="line-new-header">--- 768,11 ---</span>
  // This function is performance critical. If many threads attempt to tag objects
  // around the same time then it&#39;s possible that the Mutex associated with the
  // tag map will be a hot lock.
  void JvmtiTagMap::set_tag(jobject object, jlong tag) {
    MutexLocker ml(lock());
<span class="line-added">+   TSAN_ONLY(TsanMutexScope tms(lock()));</span>
  
    // resolve the object
    oop o = JNIHandles::resolve_non_null(object);
  
    // see if the object is already tagged
</pre>
<hr />
<pre>
<span class="line-old-header">*** 762,10 ***</span>
<span class="line-new-header">--- 801,11 ---</span>
  }
  
  // get the tag for an object
  jlong JvmtiTagMap::get_tag(jobject object) {
    MutexLocker ml(lock());
<span class="line-added">+   TSAN_ONLY(TsanMutexScope tms(lock()));</span>
  
    // resolve the object
    oop o = JNIHandles::resolve_non_null(object);
  
    return tag_for(this, o);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1261,15 ***</span>
  // VM operation to iterate over all objects in the heap (both reachable
  // and unreachable)
  class VM_HeapIterateOperation: public VM_Operation {
   private:
    ObjectClosure* _blk;
   public:
<span class="line-modified">!   VM_HeapIterateOperation(ObjectClosure* blk) { _blk = blk; }</span>
  
    VMOp_Type type() const { return VMOp_HeapIterateOperation; }
    void doit() {
      // allows class files maps to be cached during iteration
      ClassFieldMapCacheMark cm;
  
      // make sure that heap is parsable (fills TLABs with filler objects)
      Universe::heap()-&gt;ensure_parsability(false);  // no need to retire TLABs
<span class="line-new-header">--- 1301,26 ---</span>
  // VM operation to iterate over all objects in the heap (both reachable
  // and unreachable)
  class VM_HeapIterateOperation: public VM_Operation {
   private:
    ObjectClosure* _blk;
<span class="line-added">+   JvmtiTagMap* _tag_map;</span>
<span class="line-added">+ </span>
   public:
<span class="line-modified">!   VM_HeapIterateOperation(ObjectClosure* blk, JvmtiTagMap* tag_map) {</span>
<span class="line-added">+     _blk = blk;</span>
<span class="line-added">+     _tag_map = tag_map;</span>
<span class="line-added">+   }</span>
  
    VMOp_Type type() const { return VMOp_HeapIterateOperation; }
    void doit() {
<span class="line-added">+     // Simulates barrier synchronization on safepoint.</span>
<span class="line-added">+     // This annotation is reasonably minimal in number of tsan callbacks.</span>
<span class="line-added">+     // By passing the lock directly, we are not actually locking it, just</span>
<span class="line-added">+     // telling TSAN we are to &quot;simulate&quot; the lock.</span>
<span class="line-added">+     TSAN_ONLY(TsanMutexScope tms(_tag_map-&gt;lock()));</span>
<span class="line-added">+ </span>
      // allows class files maps to be cached during iteration
      ClassFieldMapCacheMark cm;
  
      // make sure that heap is parsable (fills TLABs with filler objects)
      Universe::heap()-&gt;ensure_parsability(false);  // no need to retire TLABs
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1492,11 ***</span>
    IterateOverHeapObjectClosure blk(this,
                                     klass,
                                     object_filter,
                                     heap_object_callback,
                                     user_data);
<span class="line-modified">!   VM_HeapIterateOperation op(&amp;blk);</span>
    VMThread::execute(&amp;op);
  }
  
  
  // Iterates over all objects in the heap
<span class="line-new-header">--- 1543,11 ---</span>
    IterateOverHeapObjectClosure blk(this,
                                     klass,
                                     object_filter,
                                     heap_object_callback,
                                     user_data);
<span class="line-modified">!   VM_HeapIterateOperation op(&amp;blk, this);</span>
    VMThread::execute(&amp;op);
  }
  
  
  // Iterates over all objects in the heap
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1509,11 ***</span>
    IterateThroughHeapObjectClosure blk(this,
                                        klass,
                                        heap_filter,
                                        callbacks,
                                        user_data);
<span class="line-modified">!   VM_HeapIterateOperation op(&amp;blk);</span>
    VMThread::execute(&amp;op);
  }
  
  // support class for get_objects_with_tags
  
<span class="line-new-header">--- 1560,11 ---</span>
    IterateThroughHeapObjectClosure blk(this,
                                        klass,
                                        heap_filter,
                                        callbacks,
                                        user_data);
<span class="line-modified">!   VM_HeapIterateOperation op(&amp;blk, this);</span>
    VMThread::execute(&amp;op);
  }
  
  // support class for get_objects_with_tags
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1605,10 ***</span>
<span class="line-new-header">--- 1656,11 ---</span>
  
    TagObjectCollector collector(env(), tags, count);
    {
      // iterate over all tagged objects
      MutexLocker ml(lock());
<span class="line-added">+     TSAN_ONLY(TsanMutexScope tms(lock()));</span>
      entry_iterate(&amp;collector);
    }
    return collector.result(count_ptr, object_result_ptr, tag_result_ptr);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3220,10 ***</span>
<span class="line-new-header">--- 3272,15 ---</span>
  
    return true;
  }
  
  void VM_HeapWalkOperation::doit() {
<span class="line-added">+   // This annotation is reasonably minimal in number of tsan callbacks.</span>
<span class="line-added">+   // By passing the lock directly, we are not actually locking it, just</span>
<span class="line-added">+   // telling TSAN we are to &quot;simulate&quot; the lock.</span>
<span class="line-added">+   TSAN_ONLY(TsanMutexScope tms(_tag_map-&gt;lock()));</span>
<span class="line-added">+ </span>
    ResourceMark rm;
    ObjectMarkerController marker;
    ClassFieldMapCacheMark cm;
  
    assert(visit_stack()-&gt;is_empty(), &quot;visit stack must be empty&quot;);
</pre>
<center><a href="jvmtiRawMonitor.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiTagMap.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
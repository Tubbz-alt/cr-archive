<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/sharedRuntime.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="sharedRuntime.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="synchronizer.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/sharedRuntime.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
261   static void throw_and_post_jvmti_exception(JavaThread *thread, Handle h_exception);
262   static void throw_and_post_jvmti_exception(JavaThread *thread, Symbol* name, const char *message = NULL);
263 
264   // RedefineClasses() tracing support for obsolete method entry
265   static int rc_trace_method_entry(JavaThread* thread, Method* m);
266 
267   // To be used as the entry point for unresolved native methods.
268   static address native_method_throw_unsatisfied_link_error_entry();
269   static address native_method_throw_unsupported_operation_exception_entry();
270 
271   static oop retrieve_receiver(Symbol* sig, frame caller);
272 
273   static void register_finalizer(JavaThread* thread, oopDesc* obj);
274 
275   // dtrace notifications
276   static int dtrace_object_alloc(oopDesc* o, int size);
277   static int dtrace_object_alloc_base(Thread* thread, oopDesc* o, int size);
278   static int dtrace_method_entry(JavaThread* thread, Method* m);
279   static int dtrace_method_exit(JavaThread* thread, Method* m);
280 













































































281   // Utility method for retrieving the Java thread id, returns 0 if the
282   // thread is not a well formed Java thread.
283   static jlong get_java_tid(Thread* thread);
284 
285 
286   // used by native wrappers to reenable yellow if overflow happened in native code
287   static void reguard_yellow_pages();
288 
289   // Fill in the &quot;X cannot be cast to a Y&quot; message for ClassCastException
290   //
291   // @param thr the current thread
292   // @param caster_klass the class of the object we are casting
293   // @return the dynamically allocated exception message (must be freed
294   // by the caller using a resource mark)
295   //
296   // BCP must refer to the current &#39;checkcast&#39; opcode for the frame
297   // on top of the stack.
298   // The caller (or one of its callers) must use a ResourceMark
299   // in order to correctly free the result.
300   //
</pre>
</td>
<td>
<hr />
<pre>
261   static void throw_and_post_jvmti_exception(JavaThread *thread, Handle h_exception);
262   static void throw_and_post_jvmti_exception(JavaThread *thread, Symbol* name, const char *message = NULL);
263 
264   // RedefineClasses() tracing support for obsolete method entry
265   static int rc_trace_method_entry(JavaThread* thread, Method* m);
266 
267   // To be used as the entry point for unresolved native methods.
268   static address native_method_throw_unsatisfied_link_error_entry();
269   static address native_method_throw_unsupported_operation_exception_entry();
270 
271   static oop retrieve_receiver(Symbol* sig, frame caller);
272 
273   static void register_finalizer(JavaThread* thread, oopDesc* obj);
274 
275   // dtrace notifications
276   static int dtrace_object_alloc(oopDesc* o, int size);
277   static int dtrace_object_alloc_base(Thread* thread, oopDesc* o, int size);
278   static int dtrace_method_entry(JavaThread* thread, Method* m);
279   static int dtrace_method_exit(JavaThread* thread, Method* m);
280 
<span class="line-added">281 #if INCLUDE_TSAN</span>
<span class="line-added">282   // TSAN instrumentation</span>
<span class="line-added">283 </span>
<span class="line-added">284   // TSAN uses a 64-bit value to identify code location.</span>
<span class="line-added">285   // TSAN uses the uppermost 3 bits (63:61) for the internal purposes.</span>
<span class="line-added">286   // If bit 60 is set, TSAN recognizes that the code location belongs to the</span>
<span class="line-added">287   // JVM, and will call __tsan_symbolize_external_ex() for symbolization rather</span>
<span class="line-added">288   // than TSAN&#39;s own symbolizer. See __sanitizer::kExternalPCBit and</span>
<span class="line-added">289   // __tsan::__tsan_symbolize_external_ex() in TSAN for more details.</span>
<span class="line-added">290   // The lower 60 bits may contain either a packed bytecode location, or an</span>
<span class="line-added">291   // instruction address inside the code generated by JIT compiler.</span>
<span class="line-added">292   // A packed code location has the method ID in bits 59:16 and the bytecode</span>
<span class="line-added">293   //offset within method in bits 15:0. 44 bits (59:16) are enough to encode any</span>
<span class="line-added">294   // 47-bit 8-byte-aligned address, which is the maximum address space TSAN</span>
<span class="line-added">295   // allows. The next 16 bits are used for storing the bci.</span>
<span class="line-added">296   // | Tsan: 3 | TsanJava: 1 | jmethodID: 44 | BCI: 16 |</span>
<span class="line-added">297   static const int tsan_method_id_alignment_bits = 3;</span>
<span class="line-added">298   static const int tsan_bci_bits = 16;</span>
<span class="line-added">299   static const u8 tsan_bci_mask = right_n_bits(tsan_bci_bits);</span>
<span class="line-added">300   static const int tsan_method_id_shift = tsan_bci_bits -</span>
<span class="line-added">301       tsan_method_id_alignment_bits;</span>
<span class="line-added">302   static const u8 tsan_fake_pc_bit = 1L &lt;&lt; 60;</span>
<span class="line-added">303   static void * tsan_code_location(jmethodID jmethod_id_ptr, u2 bci) {</span>
<span class="line-added">304     return (void *)(tsan_fake_pc_bit |</span>
<span class="line-added">305       (((u8)(jmethod_id_ptr)) &lt;&lt; tsan_method_id_shift) | bci);</span>
<span class="line-added">306   }</span>
<span class="line-added">307   static jmethodID tsan_method_id_from_code_location(u8 loc) {</span>
<span class="line-added">308     return (jmethodID)(</span>
<span class="line-added">309         (loc &amp; ~(tsan_fake_pc_bit | tsan_bci_mask)) &gt;&gt; tsan_method_id_shift);</span>
<span class="line-added">310   }</span>
<span class="line-added">311   static u2 tsan_bci_from_code_location(u8 loc) {</span>
<span class="line-added">312     return (u2)(loc &amp; tsan_bci_mask);</span>
<span class="line-added">313   }</span>
<span class="line-added">314 </span>
<span class="line-added">315   // These functions are wrappers around TSAN callbacks,</span>
<span class="line-added">316   // which are listed in tsanExternalDecls.hpp. The VM uses only these</span>
<span class="line-added">317   // functions to push events to ThreadSanitizer.</span>
<span class="line-added">318 </span>
<span class="line-added">319   // Verify that an oop is valid and that the index is within the object size.</span>
<span class="line-added">320   static void verify_oop_index(oopDesc* obj, int index);</span>
<span class="line-added">321 </span>
<span class="line-added">322   // Java method entry/exit from code run by template interpreter</span>
<span class="line-added">323   static void tsan_interp_method_entry(JavaThread *thread);</span>
<span class="line-added">324   static void tsan_interp_method_exit();</span>
<span class="line-added">325 </span>
<span class="line-added">326   // Monitor acquire/release in VM code</span>
<span class="line-added">327   // (e.g., generated native method wrapper, JNI heavyweight locks)</span>
<span class="line-added">328   static void tsan_oop_lock(Thread* thread, oop obj);</span>
<span class="line-added">329   static void tsan_oop_unlock(Thread* thread, oop obj);</span>
<span class="line-added">330   // Monitor acquire/release in VM code; recursive lock variant (e.g., wait())</span>
<span class="line-added">331   static void tsan_oop_rec_lock(Thread* thread, oop obj, int rec);</span>
<span class="line-added">332   static int tsan_oop_rec_unlock(Thread* thread, oop obj);</span>
<span class="line-added">333 </span>
<span class="line-added">334   // Monitor acquire/release from code run by template interpreter</span>
<span class="line-added">335   static void tsan_interp_lock(JavaThread* thread, BasicObjectLock* elem);</span>
<span class="line-added">336   static void tsan_interp_unlock(JavaThread* thread, BasicObjectLock* elem);</span>
<span class="line-added">337 </span>
<span class="line-added">338   // Address must point to an object in the Java heap.</span>
<span class="line-added">339   static void tsan_acquire(void* address);</span>
<span class="line-added">340   static void tsan_release(void* address);</span>
<span class="line-added">341 </span>
<span class="line-added">342   // Called whenever an obj is created.</span>
<span class="line-added">343   static void tsan_track_obj_with_size(oopDesc* obj, int size);</span>
<span class="line-added">344   static void tsan_track_obj(oopDesc* obj);</span>
<span class="line-added">345 </span>
<span class="line-added">346   // Memory reads/writes from code run by template interpreter</span>
<span class="line-added">347   static void tsan_read1(void* addr, Method* method, address bcp);</span>
<span class="line-added">348   static void tsan_read2(void* addr, Method* method, address bcp);</span>
<span class="line-added">349   static void tsan_read4(void* addr, Method* method, address bcp);</span>
<span class="line-added">350   static void tsan_read8(void* addr, Method* method, address bcp);</span>
<span class="line-added">351   static void tsan_write1(void* addr, Method* method, address bcp);</span>
<span class="line-added">352   static void tsan_write2(void* addr, Method* method, address bcp);</span>
<span class="line-added">353   static void tsan_write4(void* addr, Method* method, address bcp);</span>
<span class="line-added">354   static void tsan_write8(void* addr, Method* method, address bcp);</span>
<span class="line-added">355 </span>
<span class="line-added">356 #endif // INCLUDE_TSAN</span>
<span class="line-added">357 </span>
358   // Utility method for retrieving the Java thread id, returns 0 if the
359   // thread is not a well formed Java thread.
360   static jlong get_java_tid(Thread* thread);
361 
362 
363   // used by native wrappers to reenable yellow if overflow happened in native code
364   static void reguard_yellow_pages();
365 
366   // Fill in the &quot;X cannot be cast to a Y&quot; message for ClassCastException
367   //
368   // @param thr the current thread
369   // @param caster_klass the class of the object we are casting
370   // @return the dynamically allocated exception message (must be freed
371   // by the caller using a resource mark)
372   //
373   // BCP must refer to the current &#39;checkcast&#39; opcode for the frame
374   // on top of the stack.
375   // The caller (or one of its callers) must use a ResourceMark
376   // in order to correctly free the result.
377   //
</pre>
</td>
</tr>
</table>
<center><a href="sharedRuntime.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="synchronizer.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/synchronizer.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="sharedRuntime.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../utilities/macros.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/synchronizer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 594       return;
 595     }
 596   }
 597 
 598   // We have to take the slow-path of possible inflation and then exit.
 599   inflate(THREAD, object, inflate_cause_vm_internal)-&gt;exit(true, THREAD);
 600 }
 601 
 602 // -----------------------------------------------------------------------------
 603 // Class Loader  support to workaround deadlocks on the class loader lock objects
 604 // Also used by GC
 605 // complete_exit()/reenter() are used to wait on a nested lock
 606 // i.e. to give up an outer lock completely and then re-enter
 607 // Used when holding nested locks - lock acquisition order: lock1 then lock2
 608 //  1) complete_exit lock1 - saving recursion count
 609 //  2) wait on lock2
 610 //  3) when notified on lock2, unlock lock2
 611 //  4) reenter lock1 with original recursion count
 612 //  5) lock lock2
 613 // NOTE: must use heavy weight monitor to handle complete_exit/reenter()








 614 intx ObjectSynchronizer::complete_exit(Handle obj, TRAPS) {
 615   if (UseBiasedLocking) {
 616     BiasedLocking::revoke(obj, THREAD);
 617     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 618   }
 619 
 620   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);
 621 
 622   return monitor-&gt;complete_exit(THREAD);
 623 }
 624 
 625 // NOTE: must use heavy weight monitor to handle complete_exit/reenter()
 626 void ObjectSynchronizer::reenter(Handle obj, intx recursions, TRAPS) {
 627   if (UseBiasedLocking) {
 628     BiasedLocking::revoke(obj, THREAD);
 629     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 630   }
 631 
 632   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);
 633 
 634   monitor-&gt;reenter(recursions, THREAD);
 635 }
 636 // -----------------------------------------------------------------------------
 637 // JNI locks on java objects
 638 // NOTE: must use heavy weight monitor to handle jni monitor enter
 639 void ObjectSynchronizer::jni_enter(Handle obj, TRAPS) {
 640   // the current locking is from JNI instead of Java code
 641   if (UseBiasedLocking) {
 642     BiasedLocking::revoke(obj, THREAD);
 643     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 644   }
 645   THREAD-&gt;set_current_pending_monitor_is_from_java(false);
 646   inflate(THREAD, obj(), inflate_cause_jni_enter)-&gt;enter(THREAD);
 647   THREAD-&gt;set_current_pending_monitor_is_from_java(true);

 648 }
 649 
 650 // NOTE: must use heavy weight monitor to handle jni monitor exit
 651 void ObjectSynchronizer::jni_exit(oop obj, Thread* THREAD) {
 652   if (UseBiasedLocking) {
 653     Handle h_obj(THREAD, obj);
 654     BiasedLocking::revoke(h_obj, THREAD);
 655     obj = h_obj();
 656   }
 657   assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 658 
 659   ObjectMonitor* monitor = inflate(THREAD, obj, inflate_cause_jni_exit);
 660   // If this thread has locked the object, exit the monitor. We
 661   // intentionally do not use CHECK here because we must exit the
 662   // monitor even if an exception is pending.
 663   if (monitor-&gt;check_owner(THREAD)) {

 664     monitor-&gt;exit(true, THREAD);
 665   }
 666 }
 667 
 668 // -----------------------------------------------------------------------------
 669 // Internal VM locks on java objects
 670 // standard constructor, allows locking failures
 671 ObjectLocker::ObjectLocker(Handle obj, Thread* thread, bool do_lock) {
 672   _dolock = do_lock;
 673   _thread = thread;
 674   _thread-&gt;check_for_valid_safepoint_state();
 675   _obj = obj;
 676 
 677   if (_dolock) {
 678     ObjectSynchronizer::enter(_obj, &amp;_lock, _thread);

 679   }
 680 }
 681 
 682 ObjectLocker::~ObjectLocker() {
 683   if (_dolock) {

 684     ObjectSynchronizer::exit(_obj(), &amp;_lock, _thread);
 685   }
 686 }
 687 
 688 
 689 // -----------------------------------------------------------------------------
 690 //  Wait/Notify/NotifyAll
 691 // NOTE: must use heavy weight monitor to handle wait()
 692 int ObjectSynchronizer::wait(Handle obj, jlong millis, TRAPS) {
 693   if (UseBiasedLocking) {
 694     BiasedLocking::revoke(obj, THREAD);
 695     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 696   }
 697   if (millis &lt; 0) {
 698     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
 699   }
 700   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_wait);
 701 
 702   DTRACE_MONITOR_WAIT_PROBE(monitor, obj(), THREAD, millis);







 703   monitor-&gt;wait(millis, true, THREAD);
 704 


 705   // This dummy call is in place to get around dtrace bug 6254741.  Once
 706   // that&#39;s fixed we can uncomment the following line, remove the call
 707   // and change this function back into a &quot;void&quot; func.
 708   // DTRACE_MONITOR_PROBE(waited, monitor, obj(), THREAD);
 709   return dtrace_waited_probe(monitor, obj, THREAD);
 710 }
 711 
 712 void ObjectSynchronizer::wait_uninterruptibly(Handle obj, jlong millis, TRAPS) {
 713   if (UseBiasedLocking) {
 714     BiasedLocking::revoke(obj, THREAD);
 715     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 716   }
 717   if (millis &lt; 0) {
 718     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
 719   }
<span class="line-modified"> 720   inflate(THREAD, obj(), inflate_cause_wait)-&gt;wait(millis, false, THREAD);</span>







 721 }
 722 
 723 void ObjectSynchronizer::notify(Handle obj, TRAPS) {
 724   if (UseBiasedLocking) {
 725     BiasedLocking::revoke(obj, THREAD);
 726     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 727   }
 728 
 729   markWord mark = obj-&gt;mark();
 730   if (mark.has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark.locker())) {
 731     return;
 732   }
 733   inflate(THREAD, obj(), inflate_cause_notify)-&gt;notify(THREAD);
 734 }
 735 
 736 // NOTE: see comment of notify()
 737 void ObjectSynchronizer::notifyall(Handle obj, TRAPS) {
 738   if (UseBiasedLocking) {
 739     BiasedLocking::revoke(obj, THREAD);
 740     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
</pre>
<hr />
<pre>
2074     ls = &amp;lsh_info;
2075   }
2076   if (ls != NULL) {
2077     ls-&gt;print_cr(&quot;jt=&quot; INTPTR_FORMAT &quot;: deflating per-thread idle monitors, %3.7f secs, %d monitors&quot;, p2i(thread), timer.seconds(), deflated_count);
2078   }
2079 }
2080 
2081 // Monitor cleanup on JavaThread::exit
2082 
2083 // Iterate through monitor cache and attempt to release thread&#39;s monitors
2084 // Gives up on a particular monitor if an exception occurs, but continues
2085 // the overall iteration, swallowing the exception.
2086 class ReleaseJavaMonitorsClosure: public MonitorClosure {
2087  private:
2088   TRAPS;
2089 
2090  public:
2091   ReleaseJavaMonitorsClosure(Thread* thread) : THREAD(thread) {}
2092   void do_monitor(ObjectMonitor* mid) {
2093     if (mid-&gt;owner() == THREAD) {




2094       (void)mid-&gt;complete_exit(CHECK);
2095     }
2096   }
2097 };
2098 
2099 // Release all inflated monitors owned by THREAD.  Lightweight monitors are
2100 // ignored.  This is meant to be called during JNI thread detach which assumes
2101 // all remaining monitors are heavyweight.  All exceptions are swallowed.
2102 // Scanning the extant monitor list can be time consuming.
2103 // A simple optimization is to add a per-thread flag that indicates a thread
2104 // called jni_monitorenter() during its lifetime.
2105 //
2106 // Instead of No_Savepoint_Verifier it might be cheaper to
2107 // use an idiom of the form:
2108 //   auto int tmp = SafepointSynchronize::_safepoint_counter ;
2109 //   &lt;code that must not run at safepoint&gt;
2110 //   guarantee (((tmp ^ _safepoint_counter) | (tmp &amp; 1)) == 0) ;
2111 // Since the tests are extremely cheap we could leave them enabled
2112 // for normal product builds.
2113 
</pre>
</td>
<td>
<hr />
<pre>
 594       return;
 595     }
 596   }
 597 
 598   // We have to take the slow-path of possible inflation and then exit.
 599   inflate(THREAD, object, inflate_cause_vm_internal)-&gt;exit(true, THREAD);
 600 }
 601 
 602 // -----------------------------------------------------------------------------
 603 // Class Loader  support to workaround deadlocks on the class loader lock objects
 604 // Also used by GC
 605 // complete_exit()/reenter() are used to wait on a nested lock
 606 // i.e. to give up an outer lock completely and then re-enter
 607 // Used when holding nested locks - lock acquisition order: lock1 then lock2
 608 //  1) complete_exit lock1 - saving recursion count
 609 //  2) wait on lock2
 610 //  3) when notified on lock2, unlock lock2
 611 //  4) reenter lock1 with original recursion count
 612 //  5) lock lock2
 613 // NOTE: must use heavy weight monitor to handle complete_exit/reenter()
<span class="line-added"> 614 // NOTE(TSAN): We cannot instrument complete_exit/reenter in ObjectSynchronizer</span>
<span class="line-added"> 615 //             in a manner similar to wait and waitUninterruptibly, because</span>
<span class="line-added"> 616 //             (1) recursion count stored by inflated monitor is different from</span>
<span class="line-added"> 617 //             the absolute recursion count tracked by Tsan, and (2) in the</span>
<span class="line-added"> 618 //             general case, we cannot merely store Tsan&#39;s recursion count</span>
<span class="line-added"> 619 //             once: we must track it for *each invocation* of complete_exit.</span>
<span class="line-added"> 620 //             Hence, the best place to instrument for Tsan is at the call site</span>
<span class="line-added"> 621 //             for complete_exit/reenter. Luckily, there is only one call site.</span>
 622 intx ObjectSynchronizer::complete_exit(Handle obj, TRAPS) {
 623   if (UseBiasedLocking) {
 624     BiasedLocking::revoke(obj, THREAD);
 625     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 626   }
 627 
 628   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);
 629 
 630   return monitor-&gt;complete_exit(THREAD);
 631 }
 632 
 633 // NOTE: must use heavy weight monitor to handle complete_exit/reenter()
 634 void ObjectSynchronizer::reenter(Handle obj, intx recursions, TRAPS) {
 635   if (UseBiasedLocking) {
 636     BiasedLocking::revoke(obj, THREAD);
 637     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 638   }
 639 
 640   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);
 641 
 642   monitor-&gt;reenter(recursions, THREAD);
 643 }
 644 // -----------------------------------------------------------------------------
 645 // JNI locks on java objects
 646 // NOTE: must use heavy weight monitor to handle jni monitor enter
 647 void ObjectSynchronizer::jni_enter(Handle obj, TRAPS) {
 648   // the current locking is from JNI instead of Java code
 649   if (UseBiasedLocking) {
 650     BiasedLocking::revoke(obj, THREAD);
 651     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 652   }
 653   THREAD-&gt;set_current_pending_monitor_is_from_java(false);
 654   inflate(THREAD, obj(), inflate_cause_jni_enter)-&gt;enter(THREAD);
 655   THREAD-&gt;set_current_pending_monitor_is_from_java(true);
<span class="line-added"> 656   TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_lock(THREAD, obj()));</span>
 657 }
 658 
 659 // NOTE: must use heavy weight monitor to handle jni monitor exit
 660 void ObjectSynchronizer::jni_exit(oop obj, Thread* THREAD) {
 661   if (UseBiasedLocking) {
 662     Handle h_obj(THREAD, obj);
 663     BiasedLocking::revoke(h_obj, THREAD);
 664     obj = h_obj();
 665   }
 666   assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 667 
 668   ObjectMonitor* monitor = inflate(THREAD, obj, inflate_cause_jni_exit);
 669   // If this thread has locked the object, exit the monitor. We
 670   // intentionally do not use CHECK here because we must exit the
 671   // monitor even if an exception is pending.
 672   if (monitor-&gt;check_owner(THREAD)) {
<span class="line-added"> 673     TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_unlock(THREAD, obj));</span>
 674     monitor-&gt;exit(true, THREAD);
 675   }
 676 }
 677 
 678 // -----------------------------------------------------------------------------
 679 // Internal VM locks on java objects
 680 // standard constructor, allows locking failures
 681 ObjectLocker::ObjectLocker(Handle obj, Thread* thread, bool do_lock) {
 682   _dolock = do_lock;
 683   _thread = thread;
 684   _thread-&gt;check_for_valid_safepoint_state();
 685   _obj = obj;
 686 
 687   if (_dolock) {
 688     ObjectSynchronizer::enter(_obj, &amp;_lock, _thread);
<span class="line-added"> 689     TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_lock(_thread, _obj()));</span>
 690   }
 691 }
 692 
 693 ObjectLocker::~ObjectLocker() {
 694   if (_dolock) {
<span class="line-added"> 695     TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_unlock(_thread, _obj()));</span>
 696     ObjectSynchronizer::exit(_obj(), &amp;_lock, _thread);
 697   }
 698 }
 699 
 700 
 701 // -----------------------------------------------------------------------------
 702 //  Wait/Notify/NotifyAll
 703 // NOTE: must use heavy weight monitor to handle wait()
 704 int ObjectSynchronizer::wait(Handle obj, jlong millis, TRAPS) {
 705   if (UseBiasedLocking) {
 706     BiasedLocking::revoke(obj, THREAD);
 707     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 708   }
 709   if (millis &lt; 0) {
 710     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
 711   }
 712   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_wait);
 713 
 714   DTRACE_MONITOR_WAIT_PROBE(monitor, obj(), THREAD, millis);
<span class="line-added"> 715 </span>
<span class="line-added"> 716   TSAN_ONLY(int tsan_rec = 0;)</span>
<span class="line-added"> 717   TSAN_RUNTIME_ONLY(</span>
<span class="line-added"> 718     tsan_rec = SharedRuntime::tsan_oop_rec_unlock(THREAD, obj());</span>
<span class="line-added"> 719     assert(tsan_rec &gt; 0, &quot;tsan: unlocking unlocked mutex&quot;);</span>
<span class="line-added"> 720   );</span>
<span class="line-added"> 721 </span>
 722   monitor-&gt;wait(millis, true, THREAD);
 723 
<span class="line-added"> 724   TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_lock(THREAD, obj(), tsan_rec));</span>
<span class="line-added"> 725 </span>
 726   // This dummy call is in place to get around dtrace bug 6254741.  Once
 727   // that&#39;s fixed we can uncomment the following line, remove the call
 728   // and change this function back into a &quot;void&quot; func.
 729   // DTRACE_MONITOR_PROBE(waited, monitor, obj(), THREAD);
 730   return dtrace_waited_probe(monitor, obj, THREAD);
 731 }
 732 
 733 void ObjectSynchronizer::wait_uninterruptibly(Handle obj, jlong millis, TRAPS) {
 734   if (UseBiasedLocking) {
 735     BiasedLocking::revoke(obj, THREAD);
 736     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 737   }
 738   if (millis &lt; 0) {
 739     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
 740   }
<span class="line-modified"> 741   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_wait);</span>
<span class="line-added"> 742   TSAN_ONLY(int tsan_rec;)</span>
<span class="line-added"> 743   TSAN_RUNTIME_ONLY(</span>
<span class="line-added"> 744     tsan_rec = SharedRuntime::tsan_oop_rec_unlock(THREAD, obj());</span>
<span class="line-added"> 745     assert(tsan_rec &gt; 0, &quot;tsan: unlocking unlocked mutex&quot;);</span>
<span class="line-added"> 746   );</span>
<span class="line-added"> 747   monitor-&gt;wait(millis, false, THREAD);</span>
<span class="line-added"> 748   TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_lock(THREAD, obj(), tsan_rec));</span>
 749 }
 750 
 751 void ObjectSynchronizer::notify(Handle obj, TRAPS) {
 752   if (UseBiasedLocking) {
 753     BiasedLocking::revoke(obj, THREAD);
 754     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
 755   }
 756 
 757   markWord mark = obj-&gt;mark();
 758   if (mark.has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark.locker())) {
 759     return;
 760   }
 761   inflate(THREAD, obj(), inflate_cause_notify)-&gt;notify(THREAD);
 762 }
 763 
 764 // NOTE: see comment of notify()
 765 void ObjectSynchronizer::notifyall(Handle obj, TRAPS) {
 766   if (UseBiasedLocking) {
 767     BiasedLocking::revoke(obj, THREAD);
 768     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
</pre>
<hr />
<pre>
2102     ls = &amp;lsh_info;
2103   }
2104   if (ls != NULL) {
2105     ls-&gt;print_cr(&quot;jt=&quot; INTPTR_FORMAT &quot;: deflating per-thread idle monitors, %3.7f secs, %d monitors&quot;, p2i(thread), timer.seconds(), deflated_count);
2106   }
2107 }
2108 
2109 // Monitor cleanup on JavaThread::exit
2110 
2111 // Iterate through monitor cache and attempt to release thread&#39;s monitors
2112 // Gives up on a particular monitor if an exception occurs, but continues
2113 // the overall iteration, swallowing the exception.
2114 class ReleaseJavaMonitorsClosure: public MonitorClosure {
2115  private:
2116   TRAPS;
2117 
2118  public:
2119   ReleaseJavaMonitorsClosure(Thread* thread) : THREAD(thread) {}
2120   void do_monitor(ObjectMonitor* mid) {
2121     if (mid-&gt;owner() == THREAD) {
<span class="line-added">2122       // Note well -- this occurs ONLY on thread exit, and is a last ditch</span>
<span class="line-added">2123       // effort to release all locks. Hence, we don&#39;t need to record tsan&#39;s</span>
<span class="line-added">2124       // recursion count -- it will never be locked again.</span>
<span class="line-added">2125       TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_unlock(THREAD, (oop)mid-&gt;object()));</span>
2126       (void)mid-&gt;complete_exit(CHECK);
2127     }
2128   }
2129 };
2130 
2131 // Release all inflated monitors owned by THREAD.  Lightweight monitors are
2132 // ignored.  This is meant to be called during JNI thread detach which assumes
2133 // all remaining monitors are heavyweight.  All exceptions are swallowed.
2134 // Scanning the extant monitor list can be time consuming.
2135 // A simple optimization is to add a per-thread flag that indicates a thread
2136 // called jni_monitorenter() during its lifetime.
2137 //
2138 // Instead of No_Savepoint_Verifier it might be cheaper to
2139 // use an idiom of the form:
2140 //   auto int tmp = SafepointSynchronize::_safepoint_counter ;
2141 //   &lt;code that must not run at safepoint&gt;
2142 //   guarantee (((tmp ^ _safepoint_counter) | (tmp &amp; 1)) == 0) ;
2143 // Since the tests are extremely cheap we could leave them enabled
2144 // for normal product builds.
2145 
</pre>
</td>
</tr>
</table>
<center><a href="sharedRuntime.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../utilities/macros.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
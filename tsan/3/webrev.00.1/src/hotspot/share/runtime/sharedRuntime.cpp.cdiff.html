<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/runtime/sharedRuntime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="mutexLocker.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/sharedRuntime.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 74,10 ***</span>
<span class="line-new-header">--- 74,14 ---</span>
  #include &quot;utilities/macros.hpp&quot;
  #include &quot;utilities/xmlstream.hpp&quot;
  #ifdef COMPILER1
  #include &quot;c1/c1_Runtime1.hpp&quot;
  #endif
<span class="line-added">+ #if INCLUDE_TSAN</span>
<span class="line-added">+ #include &quot;tsan/tsanExternalDecls.hpp&quot;</span>
<span class="line-added">+ #include &quot;tsan/tsanOopMap.hpp&quot;</span>
<span class="line-added">+ #endif</span>
  
  // Shared stub locations
  RuntimeStub*        SharedRuntime::_wrong_method_blob;
  RuntimeStub*        SharedRuntime::_wrong_method_abstract_blob;
  RuntimeStub*        SharedRuntime::_ic_miss_blob;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1006,10 ***</span>
<span class="line-new-header">--- 1010,180 ---</span>
        (char *) name-&gt;bytes(), name-&gt;utf8_length(),
        (char *) sig-&gt;bytes(), sig-&gt;utf8_length());
    return 0;
  JRT_END
  
<span class="line-added">+ #if INCLUDE_TSAN</span>
<span class="line-added">+ </span>
<span class="line-added">+ JRT_LEAF(void, SharedRuntime::verify_oop_index(oopDesc* obj, int index))</span>
<span class="line-added">+   assert(oopDesc::is_oop(obj), &quot;invalid oop&quot;);</span>
<span class="line-added">+   assert(index &gt;= 0, &quot;index is less than 0&quot;);</span>
<span class="line-added">+   int obj_size_in_bytes = obj-&gt;size() * HeapWordSize;</span>
<span class="line-added">+   assert(index &lt; obj_size_in_bytes, &quot;index %d &gt;= obj size %d&quot;, index, obj_size_in_bytes);</span>
<span class="line-added">+ JRT_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ // TSAN: method entry callback from interpreter</span>
<span class="line-added">+ // (1) In order to have the line numbers in the call stack, we use the caller</span>
<span class="line-added">+ //     address instead of the method that&#39;s being called. This also matches</span>
<span class="line-added">+ //     the entry/exit convention that TSAN uses for C++.</span>
<span class="line-added">+ // We use JRT_ENTRY since call_VM_leaf doesn&#39;t set _last_Java_sp that we need.</span>
<span class="line-added">+ JRT_ENTRY(void, SharedRuntime::tsan_interp_method_entry(JavaThread *thread))</span>
<span class="line-added">+   DEBUG_ONLY(NoSafepointVerifier nsv;)</span>
<span class="line-added">+   DEBUG_ONLY(NoHandleMark nhm;)</span>
<span class="line-added">+   assert(ThreadSanitizer, &quot;Need -XX:+ThreadSanitizer&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   RegisterMap unused_reg_map(thread, false);</span>
<span class="line-added">+ </span>
<span class="line-added">+   // These asserts should be removed once</span>
<span class="line-added">+   // we support more than just the interpreter for TSAN.</span>
<span class="line-added">+   assert(!thread-&gt;last_frame().is_compiled_frame(),</span>
<span class="line-added">+          &quot;Current frame should not be a compiled frame&quot;);</span>
<span class="line-added">+   const frame sender = thread-&gt;last_frame().real_sender(&amp;unused_reg_map);</span>
<span class="line-added">+   assert(!sender.is_compiled_frame(), &quot;Sender should not be a compiled frame&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   jmethodID jmethod_id = 0;</span>
<span class="line-added">+   u2 bci = 0;</span>
<span class="line-added">+   // TODO: is (0, 0) really the best we can do</span>
<span class="line-added">+   // when the sender isn&#39;t an interpreted frame?</span>
<span class="line-added">+   if (sender.is_interpreted_frame()) {</span>
<span class="line-added">+     jmethod_id = sender.interpreter_frame_method()-&gt;find_jmethod_id_or_null();</span>
<span class="line-added">+     bci = sender.interpreter_frame_bci();</span>
<span class="line-added">+   }</span>
<span class="line-added">+   __tsan_func_entry(tsan_code_location(jmethod_id, bci));</span>
<span class="line-added">+ JRT_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ // TSAN: method exit callback from interpreter</span>
<span class="line-added">+ JRT_LEAF(void, SharedRuntime::tsan_interp_method_exit())</span>
<span class="line-added">+   assert(ThreadSanitizer, &quot;Need -XX:+ThreadSanitizer&quot;);</span>
<span class="line-added">+   __tsan_func_exit();</span>
<span class="line-added">+ JRT_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ void SharedRuntime::tsan_oop_lock(Thread* thread, oop obj) {</span>
<span class="line-added">+   DEBUG_ONLY(NoSafepointVerifier nsv;)</span>
<span class="line-added">+   assert(ThreadSanitizer, &quot;Need -XX:+ThreadSanitizer&quot;);</span>
<span class="line-added">+   assert(thread != NULL, &quot;null thread&quot;);</span>
<span class="line-added">+   assert(obj != NULL, &quot;null oop&quot;);</span>
<span class="line-added">+   assert(oopDesc::is_oop(obj), &quot;invalid oop&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   TsanOopMap::add_oop(obj);</span>
<span class="line-added">+   __tsan_java_mutex_lock((julong)(oopDesc*)obj);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void SharedRuntime::tsan_oop_unlock(Thread *thread, oop obj) {</span>
<span class="line-added">+   DEBUG_ONLY(NoSafepointVerifier nsv;)</span>
<span class="line-added">+   assert(ThreadSanitizer, &quot;Need -XX:+ThreadSanitizer&quot;);</span>
<span class="line-added">+   assert(thread != NULL, &quot;null thread&quot;);</span>
<span class="line-added">+   assert(obj != NULL, &quot;null oop&quot;);</span>
<span class="line-added">+   assert(oopDesc::is_oop(obj), &quot;invalid oop&quot;);</span>
<span class="line-added">+   assert(TsanOopMap::exists(obj), &quot;oop seen in unlock but not tracked&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   __tsan_java_mutex_unlock((julong)(oopDesc*)obj);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void SharedRuntime::tsan_oop_rec_lock(Thread* thread, oop obj, int rec) {</span>
<span class="line-added">+   DEBUG_ONLY(NoSafepointVerifier nsv;)</span>
<span class="line-added">+   assert(ThreadSanitizer, &quot;Need -XX:+ThreadSanitizer&quot;);</span>
<span class="line-added">+   assert(thread != NULL, &quot;null thread&quot;);</span>
<span class="line-added">+   assert(obj != NULL, &quot;null oop&quot;);</span>
<span class="line-added">+   assert(oopDesc::is_oop(obj), &quot;invalid oop&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   TsanOopMap::add_oop(obj);</span>
<span class="line-added">+   __tsan_java_mutex_lock_rec((julong)(oopDesc*)obj, rec);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ int SharedRuntime::tsan_oop_rec_unlock(Thread *thread, oop obj) {</span>
<span class="line-added">+   DEBUG_ONLY(NoSafepointVerifier nsv;)</span>
<span class="line-added">+   assert(ThreadSanitizer, &quot;Need -XX:+ThreadSanitizer&quot;);</span>
<span class="line-added">+   assert(thread != NULL, &quot;null thread&quot;);</span>
<span class="line-added">+   assert(obj != NULL, &quot;null oop&quot;);</span>
<span class="line-added">+   assert(oopDesc::is_oop(obj), &quot;invalid oop&quot;);</span>
<span class="line-added">+   assert(TsanOopMap::exists(obj), &quot;oop seen in unlock but not tracked&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   return __tsan_java_mutex_unlock_rec((julong)(oopDesc*)obj);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JRT_LEAF(void, SharedRuntime::tsan_interp_lock(JavaThread* thread,</span>
<span class="line-added">+                                                BasicObjectLock* elem))</span>
<span class="line-added">+   DEBUG_ONLY(thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);)</span>
<span class="line-added">+   assert(elem != NULL, &quot;null elem&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   oop obj = elem-&gt;obj();</span>
<span class="line-added">+   tsan_oop_lock(thread, obj);</span>
<span class="line-added">+ </span>
<span class="line-added">+   assert(obj == elem-&gt;obj(), &quot;oop changed&quot;);</span>
<span class="line-added">+   DEBUG_ONLY(thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);)</span>
<span class="line-added">+ JRT_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ JRT_LEAF(void, SharedRuntime::tsan_interp_unlock(JavaThread* thread,</span>
<span class="line-added">+                                                  BasicObjectLock* elem))</span>
<span class="line-added">+   DEBUG_ONLY(thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);)</span>
<span class="line-added">+   assert(elem != NULL, &quot;null elem&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   oop obj = elem-&gt;obj();</span>
<span class="line-added">+   tsan_oop_unlock(thread, obj);</span>
<span class="line-added">+ </span>
<span class="line-added">+   assert(obj == elem-&gt;obj(), &quot;oop changed&quot;);</span>
<span class="line-added">+   DEBUG_ONLY(thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);)</span>
<span class="line-added">+ JRT_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Should be JRT_LEAF, but this is called very early during VM startup, so we</span>
<span class="line-added">+ // are sometimes in &#39;_thread_in_vm&#39; state.</span>
<span class="line-added">+ // NOTE: DO NOT add operations that can safepoint, enter GC, or throw an</span>
<span class="line-added">+ // exception!</span>
<span class="line-added">+ void SharedRuntime::tsan_track_obj_with_size(oopDesc* obj, int size) {</span>
<span class="line-added">+   assert(ThreadSanitizer, &quot;Need -XX:+ThreadSanitizer&quot;);</span>
<span class="line-added">+   assert(oopDesc::is_oop(obj), &quot;Bad oopDesc passed to tsan_track_obj_with_size().&quot;);</span>
<span class="line-added">+   TsanOopMap::add_oop_with_size(obj, size);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ JRT_LEAF(void, SharedRuntime::tsan_track_obj(oopDesc* obj))</span>
<span class="line-added">+   assert(ThreadSanitizer, &quot;Need -XX:+ThreadSanitizer&quot;);</span>
<span class="line-added">+   assert(oopDesc::is_oop(obj), &quot;Bad oopDesc passed to tsan_track_obj().&quot;);</span>
<span class="line-added">+   TsanOopMap::add_oop(obj);</span>
<span class="line-added">+ JRT_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ // TODO: Make tsan_acquire/release JRT_LEAF</span>
<span class="line-added">+ // Currently it can&#39;t be JRT_LEAF because there are calls from the VM</span>
<span class="line-added">+ // (instanceKlass.cpp), and JRT_LEAF only allows calls from Java/native code.</span>
<span class="line-added">+ // We need to figure out a better way of being able to call TSAN functions from</span>
<span class="line-added">+ // the VM.</span>
<span class="line-added">+ void SharedRuntime::tsan_acquire(void* address) {</span>
<span class="line-added">+   DEBUG_ONLY(NoSafepointVerifier nsv;)</span>
<span class="line-added">+   assert(ThreadSanitizer, &quot;Need -XX:+ThreadSanitizer&quot;);</span>
<span class="line-added">+   assert(address != NULL, &quot;Cannot acquire at address 0&quot;);</span>
<span class="line-added">+   __tsan_java_acquire(address);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void SharedRuntime::tsan_release(void* address) {</span>
<span class="line-added">+   DEBUG_ONLY(NoSafepointVerifier nsv;)</span>
<span class="line-added">+   assert(ThreadSanitizer, &quot;Need -XX:+ThreadSanitizer&quot;);</span>
<span class="line-added">+   assert(address != NULL, &quot;Cannot release at address 0&quot;);</span>
<span class="line-added">+   __tsan_java_release(address);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define TSAN_MEMORY_ACCESS(name)                                               \</span>
<span class="line-added">+   JRT_LEAF(void, SharedRuntime::tsan_##name(                                   \</span>
<span class="line-added">+       void* addr,                                                              \</span>
<span class="line-added">+       Method* method,                                                          \</span>
<span class="line-added">+       address bcp))                                                            \</span>
<span class="line-added">+     assert(ThreadSanitizer, &quot;Need -XX:+ThreadSanitizer&quot;);                      \</span>
<span class="line-added">+     assert(ThreadSanitizerJavaMemory, &quot;Need -XX:+ThreadSanitizerJavaMemory&quot;);  \</span>
<span class="line-added">+     jmethodID mid = method-&gt;find_jmethod_id_or_null();                         \</span>
<span class="line-added">+     int bci = method-&gt;bci_from(bcp);                                           \</span>
<span class="line-added">+     __tsan_##name##_pc(addr, tsan_code_location(mid, bci));                    \</span>
<span class="line-added">+   JRT_END</span>
<span class="line-added">+ </span>
<span class="line-added">+ TSAN_MEMORY_ACCESS(read1)</span>
<span class="line-added">+ TSAN_MEMORY_ACCESS(read2)</span>
<span class="line-added">+ TSAN_MEMORY_ACCESS(read4)</span>
<span class="line-added">+ TSAN_MEMORY_ACCESS(read8)</span>
<span class="line-added">+ TSAN_MEMORY_ACCESS(write1)</span>
<span class="line-added">+ TSAN_MEMORY_ACCESS(write2)</span>
<span class="line-added">+ TSAN_MEMORY_ACCESS(write4)</span>
<span class="line-added">+ TSAN_MEMORY_ACCESS(write8)</span>
<span class="line-added">+ </span>
<span class="line-added">+ #endif // INCLUDE_TSAN</span>
  
  // Finds receiver, CallInfo (i.e. receiver method), and calling bytecode)
  // for a call current in progress, i.e., arguments has been pushed on stack
  // put callee has not been invoked yet.  Used by: resolve virtual/static,
  // vtable updates, etc.  Caller frame must be compiled.
</pre>
<center><a href="mutexLocker.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
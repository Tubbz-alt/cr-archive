<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/runtime/synchronizer.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="sharedRuntime.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../utilities/macros.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/synchronizer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -609,10 +609,18 @@</span>
  //  2) wait on lock2
  //  3) when notified on lock2, unlock lock2
  //  4) reenter lock1 with original recursion count
  //  5) lock lock2
  // NOTE: must use heavy weight monitor to handle complete_exit/reenter()
<span class="udiff-line-added">+ // NOTE(TSAN): We cannot instrument complete_exit/reenter in ObjectSynchronizer</span>
<span class="udiff-line-added">+ //             in a manner similar to wait and waitUninterruptibly, because</span>
<span class="udiff-line-added">+ //             (1) recursion count stored by inflated monitor is different from</span>
<span class="udiff-line-added">+ //             the absolute recursion count tracked by Tsan, and (2) in the</span>
<span class="udiff-line-added">+ //             general case, we cannot merely store Tsan&#39;s recursion count</span>
<span class="udiff-line-added">+ //             once: we must track it for *each invocation* of complete_exit.</span>
<span class="udiff-line-added">+ //             Hence, the best place to instrument for Tsan is at the call site</span>
<span class="udiff-line-added">+ //             for complete_exit/reenter. Luckily, there is only one call site.</span>
  intx ObjectSynchronizer::complete_exit(Handle obj, TRAPS) {
    if (UseBiasedLocking) {
      BiasedLocking::revoke(obj, THREAD);
      assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -643,10 +651,11 @@</span>
      assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
    }
    THREAD-&gt;set_current_pending_monitor_is_from_java(false);
    inflate(THREAD, obj(), inflate_cause_jni_enter)-&gt;enter(THREAD);
    THREAD-&gt;set_current_pending_monitor_is_from_java(true);
<span class="udiff-line-added">+   TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_lock(THREAD, obj()));</span>
  }
  
  // NOTE: must use heavy weight monitor to handle jni monitor exit
  void ObjectSynchronizer::jni_exit(oop obj, Thread* THREAD) {
    if (UseBiasedLocking) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -659,10 +668,11 @@</span>
    ObjectMonitor* monitor = inflate(THREAD, obj, inflate_cause_jni_exit);
    // If this thread has locked the object, exit the monitor. We
    // intentionally do not use CHECK here because we must exit the
    // monitor even if an exception is pending.
    if (monitor-&gt;check_owner(THREAD)) {
<span class="udiff-line-added">+     TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_unlock(THREAD, obj));</span>
      monitor-&gt;exit(true, THREAD);
    }
  }
  
  // -----------------------------------------------------------------------------
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -674,15 +684,17 @@</span>
    _thread-&gt;check_for_valid_safepoint_state();
    _obj = obj;
  
    if (_dolock) {
      ObjectSynchronizer::enter(_obj, &amp;_lock, _thread);
<span class="udiff-line-added">+     TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_lock(_thread, _obj()));</span>
    }
  }
  
  ObjectLocker::~ObjectLocker() {
    if (_dolock) {
<span class="udiff-line-added">+     TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_unlock(_thread, _obj()));</span>
      ObjectSynchronizer::exit(_obj(), &amp;_lock, _thread);
    }
  }
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -698,12 +710,21 @@</span>
      THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
    }
    ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_wait);
  
    DTRACE_MONITOR_WAIT_PROBE(monitor, obj(), THREAD, millis);
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   TSAN_ONLY(int tsan_rec = 0;)</span>
<span class="udiff-line-added">+   TSAN_RUNTIME_ONLY(</span>
<span class="udiff-line-added">+     tsan_rec = SharedRuntime::tsan_oop_rec_unlock(THREAD, obj());</span>
<span class="udiff-line-added">+     assert(tsan_rec &gt; 0, &quot;tsan: unlocking unlocked mutex&quot;);</span>
<span class="udiff-line-added">+   );</span>
<span class="udiff-line-added">+ </span>
    monitor-&gt;wait(millis, true, THREAD);
  
<span class="udiff-line-added">+   TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_lock(THREAD, obj(), tsan_rec));</span>
<span class="udiff-line-added">+ </span>
    // This dummy call is in place to get around dtrace bug 6254741.  Once
    // that&#39;s fixed we can uncomment the following line, remove the call
    // and change this function back into a &quot;void&quot; func.
    // DTRACE_MONITOR_PROBE(waited, monitor, obj(), THREAD);
    return dtrace_waited_probe(monitor, obj, THREAD);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -715,11 +736,18 @@</span>
      assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
    }
    if (millis &lt; 0) {
      THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
    }
<span class="udiff-line-modified-removed">-   inflate(THREAD, obj(), inflate_cause_wait)-&gt;wait(millis, false, THREAD);</span>
<span class="udiff-line-modified-added">+   ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_wait);</span>
<span class="udiff-line-added">+   TSAN_ONLY(int tsan_rec;)</span>
<span class="udiff-line-added">+   TSAN_RUNTIME_ONLY(</span>
<span class="udiff-line-added">+     tsan_rec = SharedRuntime::tsan_oop_rec_unlock(THREAD, obj());</span>
<span class="udiff-line-added">+     assert(tsan_rec &gt; 0, &quot;tsan: unlocking unlocked mutex&quot;);</span>
<span class="udiff-line-added">+   );</span>
<span class="udiff-line-added">+   monitor-&gt;wait(millis, false, THREAD);</span>
<span class="udiff-line-added">+   TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_lock(THREAD, obj(), tsan_rec));</span>
  }
  
  void ObjectSynchronizer::notify(Handle obj, TRAPS) {
    if (UseBiasedLocking) {
      BiasedLocking::revoke(obj, THREAD);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2089,10 +2117,14 @@</span>
  
   public:
    ReleaseJavaMonitorsClosure(Thread* thread) : THREAD(thread) {}
    void do_monitor(ObjectMonitor* mid) {
      if (mid-&gt;owner() == THREAD) {
<span class="udiff-line-added">+       // Note well -- this occurs ONLY on thread exit, and is a last ditch</span>
<span class="udiff-line-added">+       // effort to release all locks. Hence, we don&#39;t need to record tsan&#39;s</span>
<span class="udiff-line-added">+       // recursion count -- it will never be locked again.</span>
<span class="udiff-line-added">+       TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_unlock(THREAD, (oop)mid-&gt;object()));</span>
        (void)mid-&gt;complete_exit(CHECK);
      }
    }
  };
  
</pre>
<center><a href="sharedRuntime.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../utilities/macros.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
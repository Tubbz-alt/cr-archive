<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/runtime/sharedRuntime.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="sharedRuntime.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="synchronizer.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/sharedRuntime.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -276,10 +276,87 @@</span>
    static int dtrace_object_alloc(oopDesc* o, int size);
    static int dtrace_object_alloc_base(Thread* thread, oopDesc* o, int size);
    static int dtrace_method_entry(JavaThread* thread, Method* m);
    static int dtrace_method_exit(JavaThread* thread, Method* m);
  
<span class="udiff-line-added">+ #if INCLUDE_TSAN</span>
<span class="udiff-line-added">+   // TSAN instrumentation</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // TSAN uses a 64-bit value to identify code location.</span>
<span class="udiff-line-added">+   // TSAN uses the uppermost 3 bits (63:61) for the internal purposes.</span>
<span class="udiff-line-added">+   // If bit 60 is set, TSAN recognizes that the code location belongs to the</span>
<span class="udiff-line-added">+   // JVM, and will call __tsan_symbolize_external_ex() for symbolization rather</span>
<span class="udiff-line-added">+   // than TSAN&#39;s own symbolizer. See __sanitizer::kExternalPCBit and</span>
<span class="udiff-line-added">+   // __tsan::__tsan_symbolize_external_ex() in TSAN for more details.</span>
<span class="udiff-line-added">+   // The lower 60 bits may contain either a packed bytecode location, or an</span>
<span class="udiff-line-added">+   // instruction address inside the code generated by JIT compiler.</span>
<span class="udiff-line-added">+   // A packed code location has the method ID in bits 59:16 and the bytecode</span>
<span class="udiff-line-added">+   //offset within method in bits 15:0. 44 bits (59:16) are enough to encode any</span>
<span class="udiff-line-added">+   // 47-bit 8-byte-aligned address, which is the maximum address space TSAN</span>
<span class="udiff-line-added">+   // allows. The next 16 bits are used for storing the bci.</span>
<span class="udiff-line-added">+   // | Tsan: 3 | TsanJava: 1 | jmethodID: 44 | BCI: 16 |</span>
<span class="udiff-line-added">+   static const int tsan_method_id_alignment_bits = 3;</span>
<span class="udiff-line-added">+   static const int tsan_bci_bits = 16;</span>
<span class="udiff-line-added">+   static const u8 tsan_bci_mask = right_n_bits(tsan_bci_bits);</span>
<span class="udiff-line-added">+   static const int tsan_method_id_shift = tsan_bci_bits -</span>
<span class="udiff-line-added">+       tsan_method_id_alignment_bits;</span>
<span class="udiff-line-added">+   static const u8 tsan_fake_pc_bit = 1L &lt;&lt; 60;</span>
<span class="udiff-line-added">+   static void * tsan_code_location(jmethodID jmethod_id_ptr, u2 bci) {</span>
<span class="udiff-line-added">+     return (void *)(tsan_fake_pc_bit |</span>
<span class="udiff-line-added">+       (((u8)(jmethod_id_ptr)) &lt;&lt; tsan_method_id_shift) | bci);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   static jmethodID tsan_method_id_from_code_location(u8 loc) {</span>
<span class="udiff-line-added">+     return (jmethodID)(</span>
<span class="udiff-line-added">+         (loc &amp; ~(tsan_fake_pc_bit | tsan_bci_mask)) &gt;&gt; tsan_method_id_shift);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   static u2 tsan_bci_from_code_location(u8 loc) {</span>
<span class="udiff-line-added">+     return (u2)(loc &amp; tsan_bci_mask);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // These functions are wrappers around TSAN callbacks,</span>
<span class="udiff-line-added">+   // which are listed in tsanExternalDecls.hpp. The VM uses only these</span>
<span class="udiff-line-added">+   // functions to push events to ThreadSanitizer.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Verify that an oop is valid and that the index is within the object size.</span>
<span class="udiff-line-added">+   static void verify_oop_index(oopDesc* obj, int index);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Java method entry/exit from code run by template interpreter</span>
<span class="udiff-line-added">+   static void tsan_interp_method_entry(JavaThread *thread);</span>
<span class="udiff-line-added">+   static void tsan_interp_method_exit();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Monitor acquire/release in VM code</span>
<span class="udiff-line-added">+   // (e.g., generated native method wrapper, JNI heavyweight locks)</span>
<span class="udiff-line-added">+   static void tsan_oop_lock(Thread* thread, oop obj);</span>
<span class="udiff-line-added">+   static void tsan_oop_unlock(Thread* thread, oop obj);</span>
<span class="udiff-line-added">+   // Monitor acquire/release in VM code; recursive lock variant (e.g., wait())</span>
<span class="udiff-line-added">+   static void tsan_oop_rec_lock(Thread* thread, oop obj, int rec);</span>
<span class="udiff-line-added">+   static int tsan_oop_rec_unlock(Thread* thread, oop obj);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Monitor acquire/release from code run by template interpreter</span>
<span class="udiff-line-added">+   static void tsan_interp_lock(JavaThread* thread, BasicObjectLock* elem);</span>
<span class="udiff-line-added">+   static void tsan_interp_unlock(JavaThread* thread, BasicObjectLock* elem);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Address must point to an object in the Java heap.</span>
<span class="udiff-line-added">+   static void tsan_acquire(void* address);</span>
<span class="udiff-line-added">+   static void tsan_release(void* address);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Called whenever an obj is created.</span>
<span class="udiff-line-added">+   static void tsan_track_obj_with_size(oopDesc* obj, int size);</span>
<span class="udiff-line-added">+   static void tsan_track_obj(oopDesc* obj);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Memory reads/writes from code run by template interpreter</span>
<span class="udiff-line-added">+   static void tsan_read1(void* addr, Method* method, address bcp);</span>
<span class="udiff-line-added">+   static void tsan_read2(void* addr, Method* method, address bcp);</span>
<span class="udiff-line-added">+   static void tsan_read4(void* addr, Method* method, address bcp);</span>
<span class="udiff-line-added">+   static void tsan_read8(void* addr, Method* method, address bcp);</span>
<span class="udiff-line-added">+   static void tsan_write1(void* addr, Method* method, address bcp);</span>
<span class="udiff-line-added">+   static void tsan_write2(void* addr, Method* method, address bcp);</span>
<span class="udiff-line-added">+   static void tsan_write4(void* addr, Method* method, address bcp);</span>
<span class="udiff-line-added">+   static void tsan_write8(void* addr, Method* method, address bcp);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #endif // INCLUDE_TSAN</span>
<span class="udiff-line-added">+ </span>
    // Utility method for retrieving the Java thread id, returns 0 if the
    // thread is not a well formed Java thread.
    static jlong get_java_tid(Thread* thread);
  
  
</pre>
<center><a href="sharedRuntime.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="synchronizer.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
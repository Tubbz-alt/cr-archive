diff a/src/hotspot/share/runtime/sharedRuntime.hpp b/src/hotspot/share/runtime/sharedRuntime.hpp
--- a/src/hotspot/share/runtime/sharedRuntime.hpp
+++ b/src/hotspot/share/runtime/sharedRuntime.hpp
@@ -276,10 +276,87 @@
   static int dtrace_object_alloc(oopDesc* o, int size);
   static int dtrace_object_alloc_base(Thread* thread, oopDesc* o, int size);
   static int dtrace_method_entry(JavaThread* thread, Method* m);
   static int dtrace_method_exit(JavaThread* thread, Method* m);
 
+#if INCLUDE_TSAN
+  // TSAN instrumentation
+
+  // TSAN uses a 64-bit value to identify code location.
+  // TSAN uses the uppermost 3 bits (63:61) for the internal purposes.
+  // If bit 60 is set, TSAN recognizes that the code location belongs to the
+  // JVM, and will call __tsan_symbolize_external_ex() for symbolization rather
+  // than TSAN's own symbolizer. See __sanitizer::kExternalPCBit and
+  // __tsan::__tsan_symbolize_external_ex() in TSAN for more details.
+  // The lower 60 bits may contain either a packed bytecode location, or an
+  // instruction address inside the code generated by JIT compiler.
+  // A packed code location has the method ID in bits 59:16 and the bytecode
+  //offset within method in bits 15:0. 44 bits (59:16) are enough to encode any
+  // 47-bit 8-byte-aligned address, which is the maximum address space TSAN
+  // allows. The next 16 bits are used for storing the bci.
+  // | Tsan: 3 | TsanJava: 1 | jmethodID: 44 | BCI: 16 |
+  static const int tsan_method_id_alignment_bits = 3;
+  static const int tsan_bci_bits = 16;
+  static const u8 tsan_bci_mask = right_n_bits(tsan_bci_bits);
+  static const int tsan_method_id_shift = tsan_bci_bits -
+      tsan_method_id_alignment_bits;
+  static const u8 tsan_fake_pc_bit = 1L << 60;
+  static void * tsan_code_location(jmethodID jmethod_id_ptr, u2 bci) {
+    return (void *)(tsan_fake_pc_bit |
+      (((u8)(jmethod_id_ptr)) << tsan_method_id_shift) | bci);
+  }
+  static jmethodID tsan_method_id_from_code_location(u8 loc) {
+    return (jmethodID)(
+        (loc & ~(tsan_fake_pc_bit | tsan_bci_mask)) >> tsan_method_id_shift);
+  }
+  static u2 tsan_bci_from_code_location(u8 loc) {
+    return (u2)(loc & tsan_bci_mask);
+  }
+
+  // These functions are wrappers around TSAN callbacks,
+  // which are listed in tsanExternalDecls.hpp. The VM uses only these
+  // functions to push events to ThreadSanitizer.
+
+  // Verify that an oop is valid and that the index is within the object size.
+  static void verify_oop_index(oopDesc* obj, int index);
+
+  // Java method entry/exit from code run by template interpreter
+  static void tsan_interp_method_entry(JavaThread *thread);
+  static void tsan_interp_method_exit();
+
+  // Monitor acquire/release in VM code
+  // (e.g., generated native method wrapper, JNI heavyweight locks)
+  static void tsan_oop_lock(Thread* thread, oop obj);
+  static void tsan_oop_unlock(Thread* thread, oop obj);
+  // Monitor acquire/release in VM code; recursive lock variant (e.g., wait())
+  static void tsan_oop_rec_lock(Thread* thread, oop obj, int rec);
+  static int tsan_oop_rec_unlock(Thread* thread, oop obj);
+
+  // Monitor acquire/release from code run by template interpreter
+  static void tsan_interp_lock(JavaThread* thread, BasicObjectLock* elem);
+  static void tsan_interp_unlock(JavaThread* thread, BasicObjectLock* elem);
+
+  // Address must point to an object in the Java heap.
+  static void tsan_acquire(void* address);
+  static void tsan_release(void* address);
+
+  // Called whenever an obj is created.
+  static void tsan_track_obj_with_size(oopDesc* obj, int size);
+  static void tsan_track_obj(oopDesc* obj);
+
+  // Memory reads/writes from code run by template interpreter
+  static void tsan_read1(void* addr, Method* method, address bcp);
+  static void tsan_read2(void* addr, Method* method, address bcp);
+  static void tsan_read4(void* addr, Method* method, address bcp);
+  static void tsan_read8(void* addr, Method* method, address bcp);
+  static void tsan_write1(void* addr, Method* method, address bcp);
+  static void tsan_write2(void* addr, Method* method, address bcp);
+  static void tsan_write4(void* addr, Method* method, address bcp);
+  static void tsan_write8(void* addr, Method* method, address bcp);
+
+#endif // INCLUDE_TSAN
+
   // Utility method for retrieving the Java thread id, returns 0 if the
   // thread is not a well formed Java thread.
   static jlong get_java_tid(Thread* thread);
 
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/interpreter/interpreterRuntime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../include/jvm.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../oops/cpCache.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/interpreterRuntime.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 722   //
 723   // Also, we need to delay resolving getstatic and putstatic instructions until the
 724   // class is initialized.  This is required so that access to the static
 725   // field will call the initialization function every time until the class
 726   // is completely initialized ala. in 2.17.5 in JVM Specification.
 727   InstanceKlass* klass = info.field_holder();
 728   bool uninitialized_static = is_static &amp;&amp; !klass-&gt;is_initialized();
 729   bool has_initialized_final_update = info.field_holder()-&gt;major_version() &gt;= 53 &amp;&amp;
 730                                       info.has_initialized_final_update();
 731   assert(!(has_initialized_final_update &amp;&amp; !info.access_flags().is_final()), &quot;Fields with initialized final updates must be final&quot;);
 732 
 733   Bytecodes::Code get_code = (Bytecodes::Code)0;
 734   Bytecodes::Code put_code = (Bytecodes::Code)0;
 735   if (!uninitialized_static) {
 736     get_code = ((is_static) ? Bytecodes::_getstatic : Bytecodes::_getfield);
 737     if ((is_put &amp;&amp; !has_initialized_final_update) || !info.access_flags().is_final()) {
 738       put_code = ((is_static) ? Bytecodes::_putstatic : Bytecodes::_putfield);
 739     }
 740   }
 741 





 742   cp_cache_entry-&gt;set_field(
 743     get_code,
 744     put_code,
 745     info.field_holder(),
 746     info.index(),
 747     info.offset(),
 748     state,
 749     info.access_flags().is_final(),
 750     info.access_flags().is_volatile(),

 751     pool-&gt;pool_holder()
 752   );
 753 }
 754 
 755 
 756 //------------------------------------------------------------------------------------------------------------------------
 757 // Synchronization
 758 //
 759 // The interpreter&#39;s synchronization code is factored out so that it can
 760 // be shared by method invocation and synchronized blocks.
 761 //%note synchronization_3
 762 
 763 //%note monitor_1
 764 JRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))
 765 #ifdef ASSERT
 766   thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);
 767 #endif
 768   if (PrintBiasedLockingStatistics) {
 769     Atomic::inc(BiasedLocking::slow_path_entry_count_addr());
 770   }
</pre>
</td>
<td>
<hr />
<pre>
 722   //
 723   // Also, we need to delay resolving getstatic and putstatic instructions until the
 724   // class is initialized.  This is required so that access to the static
 725   // field will call the initialization function every time until the class
 726   // is completely initialized ala. in 2.17.5 in JVM Specification.
 727   InstanceKlass* klass = info.field_holder();
 728   bool uninitialized_static = is_static &amp;&amp; !klass-&gt;is_initialized();
 729   bool has_initialized_final_update = info.field_holder()-&gt;major_version() &gt;= 53 &amp;&amp;
 730                                       info.has_initialized_final_update();
 731   assert(!(has_initialized_final_update &amp;&amp; !info.access_flags().is_final()), &quot;Fields with initialized final updates must be final&quot;);
 732 
 733   Bytecodes::Code get_code = (Bytecodes::Code)0;
 734   Bytecodes::Code put_code = (Bytecodes::Code)0;
 735   if (!uninitialized_static) {
 736     get_code = ((is_static) ? Bytecodes::_getstatic : Bytecodes::_getfield);
 737     if ((is_put &amp;&amp; !has_initialized_final_update) || !info.access_flags().is_final()) {
 738       put_code = ((is_static) ? Bytecodes::_putstatic : Bytecodes::_putfield);
 739     }
 740   }
 741 
<span class="line-added"> 742   bool is_tsan_ignore = false;</span>
<span class="line-added"> 743 #if INCLUDE_TSAN</span>
<span class="line-added"> 744   is_tsan_ignore = info.access_flags().is_stable() || info.access_flags().is_tsan_ignore();</span>
<span class="line-added"> 745 #endif  // INCLUDE_TSAN</span>
<span class="line-added"> 746 </span>
 747   cp_cache_entry-&gt;set_field(
 748     get_code,
 749     put_code,
 750     info.field_holder(),
 751     info.index(),
 752     info.offset(),
 753     state,
 754     info.access_flags().is_final(),
 755     info.access_flags().is_volatile(),
<span class="line-added"> 756     is_tsan_ignore,</span>
 757     pool-&gt;pool_holder()
 758   );
 759 }
 760 
 761 
 762 //------------------------------------------------------------------------------------------------------------------------
 763 // Synchronization
 764 //
 765 // The interpreter&#39;s synchronization code is factored out so that it can
 766 // be shared by method invocation and synchronized blocks.
 767 //%note synchronization_3
 768 
 769 //%note monitor_1
 770 JRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))
 771 #ifdef ASSERT
 772   thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);
 773 #endif
 774   if (PrintBiasedLockingStatistics) {
 775     Atomic::inc(BiasedLocking::slow_path_entry_count_addr());
 776   }
</pre>
</td>
</tr>
</table>
<center><a href="../include/jvm.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../oops/cpCache.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/systemDictionary.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="javaClasses.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmSymbols.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/systemDictionary.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 521 // lockObject must be held.
 522 // Complicated dance due to lock ordering:
 523 // Must first release the classloader object lock to
 524 // allow initial definer to complete the class definition
 525 // and to avoid deadlock
 526 // Reclaim classloader lock object with same original recursion count
 527 // Must release SystemDictionary_lock after notify, since
 528 // class loader lock must be claimed before SystemDictionary_lock
 529 // to prevent deadlocks
 530 //
 531 // The notify allows applications that did an untimed wait() on
 532 // the classloader object lock to not hang.
 533 void SystemDictionary::double_lock_wait(Handle lockObject, TRAPS) {
 534   assert_lock_strong(SystemDictionary_lock);
 535 
 536   bool calledholdinglock
 537       = ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD, lockObject);
 538   assert(calledholdinglock,&quot;must hold lock for notify&quot;);
 539   assert((lockObject() != _system_loader_lock_obj &amp;&amp; !is_parallelCapable(lockObject)), &quot;unexpected double_lock_wait&quot;);
 540   ObjectSynchronizer::notifyall(lockObject, THREAD);






 541   intx recursions =  ObjectSynchronizer::complete_exit(lockObject, THREAD);
 542   SystemDictionary_lock-&gt;wait();
 543   SystemDictionary_lock-&gt;unlock();
 544   ObjectSynchronizer::reenter(lockObject, recursions, THREAD);

 545   SystemDictionary_lock-&gt;lock();
 546 }
 547 
 548 // If the class in is in the placeholder table, class loading is in progress
 549 // For cases where the application changes threads to load classes, it
 550 // is critical to ClassCircularity detection that we try loading
 551 // the superclass on the same thread internally, so we do parallel
 552 // super class loading here.
 553 // This also is critical in cases where the original thread gets stalled
 554 // even in non-circularity situations.
 555 // Note: must call resolve_super_or_fail even if null super -
 556 // to force placeholder entry creation for this class for circularity detection
 557 // Caller must check for pending exception
 558 // Returns non-null Klass* if other thread has completed load
 559 // and we are done,
 560 // If return null Klass* and no pending exception, the caller must load the class
 561 InstanceKlass* SystemDictionary::handle_parallel_super_load(
 562     Symbol* name, Symbol* superclassname, Handle class_loader,
 563     Handle protection_domain, Handle lockObject, TRAPS) {
 564 
</pre>
</td>
<td>
<hr />
<pre>
 521 // lockObject must be held.
 522 // Complicated dance due to lock ordering:
 523 // Must first release the classloader object lock to
 524 // allow initial definer to complete the class definition
 525 // and to avoid deadlock
 526 // Reclaim classloader lock object with same original recursion count
 527 // Must release SystemDictionary_lock after notify, since
 528 // class loader lock must be claimed before SystemDictionary_lock
 529 // to prevent deadlocks
 530 //
 531 // The notify allows applications that did an untimed wait() on
 532 // the classloader object lock to not hang.
 533 void SystemDictionary::double_lock_wait(Handle lockObject, TRAPS) {
 534   assert_lock_strong(SystemDictionary_lock);
 535 
 536   bool calledholdinglock
 537       = ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD, lockObject);
 538   assert(calledholdinglock,&quot;must hold lock for notify&quot;);
 539   assert((lockObject() != _system_loader_lock_obj &amp;&amp; !is_parallelCapable(lockObject)), &quot;unexpected double_lock_wait&quot;);
 540   ObjectSynchronizer::notifyall(lockObject, THREAD);
<span class="line-added"> 541 </span>
<span class="line-added"> 542   TSAN_ONLY(int tsan_rec = 0;)</span>
<span class="line-added"> 543   TSAN_RUNTIME_ONLY(</span>
<span class="line-added"> 544     tsan_rec = SharedRuntime::tsan_oop_rec_unlock(THREAD, lockObject());</span>
<span class="line-added"> 545     assert(tsan_rec &gt; 0, &quot;tsan: unlocking unlocked mutex&quot;);</span>
<span class="line-added"> 546   );</span>
 547   intx recursions =  ObjectSynchronizer::complete_exit(lockObject, THREAD);
 548   SystemDictionary_lock-&gt;wait();
 549   SystemDictionary_lock-&gt;unlock();
 550   ObjectSynchronizer::reenter(lockObject, recursions, THREAD);
<span class="line-added"> 551   TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_lock(THREAD, lockObject(), tsan_rec));</span>
 552   SystemDictionary_lock-&gt;lock();
 553 }
 554 
 555 // If the class in is in the placeholder table, class loading is in progress
 556 // For cases where the application changes threads to load classes, it
 557 // is critical to ClassCircularity detection that we try loading
 558 // the superclass on the same thread internally, so we do parallel
 559 // super class loading here.
 560 // This also is critical in cases where the original thread gets stalled
 561 // even in non-circularity situations.
 562 // Note: must call resolve_super_or_fail even if null super -
 563 // to force placeholder entry creation for this class for circularity detection
 564 // Caller must check for pending exception
 565 // Returns non-null Klass* if other thread has completed load
 566 // and we are done,
 567 // If return null Klass* and no pending exception, the caller must load the class
 568 InstanceKlass* SystemDictionary::handle_parallel_super_load(
 569     Symbol* name, Symbol* superclassname, Handle class_loader,
 570     Handle protection_domain, Handle lockObject, TRAPS) {
 571 
</pre>
</td>
</tr>
</table>
<center><a href="javaClasses.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmSymbols.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
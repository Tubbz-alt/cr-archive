<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../os_cpu/linux_x86/os_linux_x86.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 34,10 ***</span>
<span class="line-new-header">--- 34,13 ---</span>
  #include &quot;classfile/javaClasses.inline.hpp&quot;
  #include &quot;classfile/moduleEntry.hpp&quot;
  #include &quot;classfile/packageEntry.hpp&quot;
  #include &quot;classfile/symbolTable.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
<span class="line-added">+ #if INCLUDE_TSAN</span>
<span class="line-added">+ #include &quot;classfile/tsanIgnoreList.hpp&quot;</span>
<span class="line-added">+ #endif // INCLUDE_TSAN</span>
  #include &quot;classfile/verificationType.hpp&quot;
  #include &quot;classfile/verifier.hpp&quot;
  #include &quot;classfile/vmSymbols.hpp&quot;
  #include &quot;logging/log.hpp&quot;
  #include &quot;logging/logStream.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1077,10 ***</span>
<span class="line-new-header">--- 1080,11 ---</span>
      _method_LambdaForm_Compiled,
      _method_Hidden,
      _method_HotSpotIntrinsicCandidate,
      _jdk_internal_vm_annotation_Contended,
      _field_Stable,
<span class="line-added">+     _field_TsanIgnore,</span>
      _jdk_internal_vm_annotation_ReservedStackAccess,
      _annotation_LIMIT
    };
    const Location _location;
    int _annotations_present;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1113,10 ***</span>
<span class="line-new-header">--- 1117,15 ---</span>
  
    bool is_contended() const { return has_annotation(_jdk_internal_vm_annotation_Contended); }
  
    void set_stable(bool stable) { set_annotation(_field_Stable); }
    bool is_stable() const { return has_annotation(_field_Stable); }
<span class="line-added">+ </span>
<span class="line-added">+ #if INCLUDE_TSAN</span>
<span class="line-added">+   void set_tsan_ignore(bool tsan_ignore) { set_annotation(_field_TsanIgnore); }</span>
<span class="line-added">+   bool is_tsan_ignore() const { return has_annotation(_field_TsanIgnore); }</span>
<span class="line-added">+ #endif  // INCLUDE_TSAN</span>
  };
  
  // This class also doubles as a holder for metadata cleanup.
  class ClassFileParser::FieldAnnotationCollector : public AnnotationCollector {
  private:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1685,10 ***</span>
<span class="line-new-header">--- 1694,17 ---</span>
  
      // Remember how many oops we encountered and compute allocation type
      const FieldAllocationType atype = fac-&gt;update(is_static, type);
      field-&gt;set_allocation_type(atype);
  
<span class="line-added">+     TSAN_RUNTIME_ONLY(</span>
<span class="line-added">+       if (ThreadSanitizerIgnoreFile != NULL &amp;&amp;</span>
<span class="line-added">+           TsanIgnoreList::match(_class_name, name, type)) {</span>
<span class="line-added">+         parsed_annotations.set_tsan_ignore(true);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     );</span>
<span class="line-added">+ </span>
      // After field is initialized with type, we can augment it with aux info
      if (parsed_annotations.has_any_annotations()) {
        parsed_annotations.apply_to(field);
        if (field-&gt;is_contended()) {
          _has_contended_fields = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2118,10 ***</span>
<span class="line-new-header">--- 2134,18 ---</span>
      case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ReservedStackAccess_signature): {
        if (_location != _in_method)  break;  // only allow for methods
        if (RestrictReservedStack &amp;&amp; !privileged) break; // honor privileges
        return _jdk_internal_vm_annotation_ReservedStackAccess;
      }
<span class="line-added">+ #if INCLUDE_TSAN</span>
<span class="line-added">+     case vmSymbols::VM_SYMBOL_ENUM_NAME(java_util_concurrent_annotation_LazyInit): {</span>
<span class="line-added">+       if (_location != _in_field) {</span>
<span class="line-added">+         break;  // only allow for fields</span>
<span class="line-added">+       }</span>
<span class="line-added">+       return _field_TsanIgnore;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #endif  // INCLUDE_TSAN</span>
      default: {
        break;
      }
    }
    return AnnotationCollector::_unknown;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2130,10 ***</span>
<span class="line-new-header">--- 2154,15 ---</span>
  void ClassFileParser::FieldAnnotationCollector::apply_to(FieldInfo* f) {
    if (is_contended())
      f-&gt;set_contended_group(contended_group());
    if (is_stable())
      f-&gt;set_stable(true);
<span class="line-added">+   TSAN_RUNTIME_ONLY(</span>
<span class="line-added">+     if (is_tsan_ignore())</span>
<span class="line-added">+       f-&gt;set_tsan_ignore(true);</span>
<span class="line-added">+   );</span>
<span class="line-added">+ </span>
  }
  
  ClassFileParser::FieldAnnotationCollector::~FieldAnnotationCollector() {
    // If there&#39;s an error deallocate metadata for field annotations
    MetadataFactory::free_array&lt;u1&gt;(_loader_data, _field_annotations);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5806,10 ***</span>
<span class="line-new-header">--- 5835,27 ---</span>
      }
    }
  
    ClassLoadingService::notify_class_loaded(ik, false /* not shared class */);
  
<span class="line-added">+ #if INCLUDE_TSAN</span>
<span class="line-added">+   if (ThreadSanitizer &amp;&amp; !ik-&gt;is_interface()) {</span>
<span class="line-added">+     ik-&gt;ensure_space_for_methodids(0);</span>
<span class="line-added">+     int num_methods = ik-&gt;methods()-&gt;length();</span>
<span class="line-added">+     for (int index = 0; index &lt; num_methods; index++) {</span>
<span class="line-added">+       // Make sure each method has a jmethodID.</span>
<span class="line-added">+       // This allows us to avoid allocating jmethodIDs during program execution.</span>
<span class="line-added">+       jmethodID id = ik-&gt;methods()-&gt;at(index)-&gt;jmethod_id();</span>
<span class="line-added">+ #ifdef ASSERT</span>
<span class="line-added">+       u8 id_u8 = reinterpret_cast&lt;u8&gt;(id);</span>
<span class="line-added">+       assert((id_u8 &amp; right_n_bits(3)) == 0, &quot;jmethodID is not aligned&quot;);</span>
<span class="line-added">+       assert((id_u8 &amp; left_n_bits(17)) == 0, &quot;jmethodID is not aligned&quot;);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ #endif // INCLUDE_TSAN</span>
<span class="line-added">+ </span>
    if (!is_internal()) {
      if (log_is_enabled(Info, class, load)) {
        ResourceMark rm;
        const char* module_name = (module_entry-&gt;name() == NULL) ? UNNAMED_MODULE : module_entry-&gt;name()-&gt;as_C_string();
        ik-&gt;print_class_load_logging(_loader_data, module_name, _stream);
</pre>
<center><a href="../../os_cpu/linux_x86/os_linux_x86.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
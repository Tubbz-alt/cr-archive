diff a/src/hotspot/share/gc/shared/weakProcessorPhases.cpp b/src/hotspot/share/gc/shared/weakProcessorPhases.cpp
--- a/src/hotspot/share/gc/shared/weakProcessorPhases.cpp
+++ b/src/hotspot/share/gc/shared/weakProcessorPhases.cpp
@@ -34,15 +34,19 @@
 
 #if INCLUDE_JVMTI
 #include "prims/jvmtiExport.hpp"
 #endif // INCLUDE_JVMTI
 
+#if INCLUDE_TSAN
+#include "tsan/tsanOopMap.hpp"
+#endif // INCLUDE_TSAN
+
 // serial_phase_count is 0 if JFR and JVMTI are both not built,
 // requiring some code to be careful to avoid tautological checks
 // that some compilers warn about.
 
-#define HAVE_SERIAL_PHASES (INCLUDE_JVMTI || INCLUDE_JFR)
+#define HAVE_SERIAL_PHASES (INCLUDE_JVMTI || INCLUDE_JFR || INCLUDE_TSAN)
 
 WeakProcessorPhases::Phase WeakProcessorPhases::serial_phase(uint value) {
 #if HAVE_SERIAL_PHASES
   assert(value < serial_phase_count, "Invalid serial phase value %u", value);
   return static_cast<Phase>(value + serial_phase_start);
@@ -109,20 +113,22 @@
 
 const char* WeakProcessorPhases::description(Phase phase) {
   switch (phase) {
   JVMTI_ONLY(case jvmti: return "JVMTI weak processing";)
   JFR_ONLY(case jfr: return "JFR weak processing";)
+  TSAN_ONLY(case tsan: return "TSAN weak processing";)
   default:
     ShouldNotReachHere();
     return "Invalid serial weak processing phase";
   }
 }
 
 WeakProcessorPhases::Processor WeakProcessorPhases::processor(Phase phase) {
   switch (phase) {
   JVMTI_ONLY(case jvmti: return &JvmtiExport::weak_oops_do;)
   JFR_ONLY(case jfr: return &Jfr::weak_oops_do;)
+  TSAN_ONLY(case tsan: return &TsanOopMap::weak_oops_do;)
   default:
     ShouldNotReachHere();
     return NULL;
   }
 }

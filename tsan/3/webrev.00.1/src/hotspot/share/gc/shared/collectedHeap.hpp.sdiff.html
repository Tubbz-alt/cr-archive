<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/collectedHeap.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../../classfile/vmSymbols.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="memAllocator.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/collectedHeap.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
186   virtual const char* name() const = 0;
187 
188   /**
189    * Returns JNI error code JNI_ENOMEM if memory could not be allocated,
190    * and JNI_OK on success.
191    */
192   virtual jint initialize() = 0;
193 
194   // In many heaps, there will be a need to perform some initialization activities
195   // after the Universe is fully formed, but before general heap allocation is allowed.
196   // This is the correct place to place such initialization methods.
197   virtual void post_initialize();
198 
199   // Stop any onging concurrent work and prepare for exit.
200   virtual void stop() {}
201 
202   // Stop and resume concurrent GC threads interfering with safepoint operations
203   virtual void safepoint_synchronize_begin() {}
204   virtual void safepoint_synchronize_end() {}
205 




206   void initialize_reserved_region(const ReservedHeapSpace&amp; rs);
207 
208   virtual size_t capacity() const = 0;
209   virtual size_t used() const = 0;
210 
211   // Returns unused capacity.
212   virtual size_t unused() const;
213 
214   // Return &quot;true&quot; if the part of the heap that allocates Java
215   // objects has reached the maximal committed limit that it can
216   // reach, without a garbage collection.
217   virtual bool is_maximal_no_gc() const = 0;
218 
219   // Support for java.lang.Runtime.maxMemory():  return the maximum amount of
220   // memory that the vm could make available for storing &#39;normal&#39; java objects.
221   // This is based on the reserved address space, but should not include space
222   // that the vm uses internally for bookkeeping or temporary storage
223   // (e.g., in the case of the young gen, one of the survivor
224   // spaces).
225   virtual size_t max_capacity() const = 0;
</pre>
</td>
<td>
<hr />
<pre>
186   virtual const char* name() const = 0;
187 
188   /**
189    * Returns JNI error code JNI_ENOMEM if memory could not be allocated,
190    * and JNI_OK on success.
191    */
192   virtual jint initialize() = 0;
193 
194   // In many heaps, there will be a need to perform some initialization activities
195   // after the Universe is fully formed, but before general heap allocation is allowed.
196   // This is the correct place to place such initialization methods.
197   virtual void post_initialize();
198 
199   // Stop any onging concurrent work and prepare for exit.
200   virtual void stop() {}
201 
202   // Stop and resume concurrent GC threads interfering with safepoint operations
203   virtual void safepoint_synchronize_begin() {}
204   virtual void safepoint_synchronize_end() {}
205 
<span class="line-added">206   // TODO(tsan): _reserved MemRegion is not available to all collectors.</span>
<span class="line-added">207   // Should we support collectors without _reserved MemRegion? See 8224815.</span>
<span class="line-added">208   TSAN_ONLY(MemRegion reserved_region() const { return _reserved; })</span>
<span class="line-added">209 </span>
210   void initialize_reserved_region(const ReservedHeapSpace&amp; rs);
211 
212   virtual size_t capacity() const = 0;
213   virtual size_t used() const = 0;
214 
215   // Returns unused capacity.
216   virtual size_t unused() const;
217 
218   // Return &quot;true&quot; if the part of the heap that allocates Java
219   // objects has reached the maximal committed limit that it can
220   // reach, without a garbage collection.
221   virtual bool is_maximal_no_gc() const = 0;
222 
223   // Support for java.lang.Runtime.maxMemory():  return the maximum amount of
224   // memory that the vm could make available for storing &#39;normal&#39; java objects.
225   // This is based on the reserved address space, but should not include space
226   // that the vm uses internally for bookkeeping or temporary storage
227   // (e.g., in the case of the young gen, one of the survivor
228   // spaces).
229   virtual size_t max_capacity() const = 0;
</pre>
</td>
</tr>
</table>
<center><a href="../../classfile/vmSymbols.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="memAllocator.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
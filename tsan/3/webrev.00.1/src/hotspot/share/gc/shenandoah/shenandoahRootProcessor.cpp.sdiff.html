<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahRootProcessor.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahPhaseTimings.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahRootProcessor.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahRootProcessor.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 25 #include &quot;precompiled.hpp&quot;
 26 
 27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
 28 #include &quot;classfile/stringTable.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;code/codeCache.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahClosures.inline.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahConcurrentRoots.hpp&quot;
 33 #include &quot;gc/shenandoah/shenandoahRootProcessor.inline.hpp&quot;
 34 #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;
 35 #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
 36 #include &quot;gc/shenandoah/shenandoahStringDedup.hpp&quot;
 37 #include &quot;gc/shenandoah/shenandoahTimingTracker.hpp&quot;
 38 #include &quot;gc/shenandoah/shenandoahVMOperations.hpp&quot;
 39 #include &quot;jfr/jfr.hpp&quot;
 40 #include &quot;memory/iterator.hpp&quot;
 41 #include &quot;memory/resourceArea.hpp&quot;
 42 #include &quot;memory/universe.hpp&quot;
 43 #include &quot;runtime/thread.hpp&quot;
 44 #include &quot;services/management.hpp&quot;

 45 
 46 ShenandoahSerialRoot::ShenandoahSerialRoot(ShenandoahSerialRoot::OopsDo oops_do, ShenandoahPhaseTimings::GCParPhases phase) :
 47   _oops_do(oops_do), _phase(phase) {
 48 }
 49 
 50 void ShenandoahSerialRoot::oops_do(OopClosure* cl, uint worker_id) {
 51   if (_claimed.try_set()) {
 52     ShenandoahWorkerTimings* worker_times = ShenandoahHeap::heap()-&gt;phase_timings()-&gt;worker_times();
 53     ShenandoahWorkerTimingsTracker timer(worker_times, _phase, worker_id);
 54     _oops_do(cl);
 55   }
 56 }
 57 
 58 // Overwrite the second argument for SD::oops_do, don&#39;t include vm global oop storage.
 59 static void system_dictionary_oops_do(OopClosure* cl) {
 60   SystemDictionary::oops_do(cl, false);
 61 }
 62 
 63 ShenandoahSerialRoots::ShenandoahSerialRoots() :
 64   _universe_root(&amp;Universe::oops_do, ShenandoahPhaseTimings::UniverseRoots),
</pre>
<hr />
<pre>
 83 void ShenandoahWeakSerialRoot::weak_oops_do(BoolObjectClosure* is_alive, OopClosure* keep_alive, uint worker_id) {
 84   if (_claimed.try_set()) {
 85     ShenandoahWorkerTimings* worker_times = ShenandoahHeap::heap()-&gt;phase_timings()-&gt;worker_times();
 86     ShenandoahWorkerTimingsTracker timer(worker_times, _phase, worker_id);
 87     _weak_oops_do(is_alive, keep_alive);
 88   }
 89 }
 90 
 91 #if INCLUDE_JVMTI
 92 ShenandoahJVMTIWeakRoot::ShenandoahJVMTIWeakRoot() :
 93   ShenandoahWeakSerialRoot(&amp;JvmtiExport::weak_oops_do, ShenandoahPhaseTimings::JVMTIWeakRoots) {
 94 }
 95 #endif // INCLUDE_JVMTI
 96 
 97 #if INCLUDE_JFR
 98 ShenandoahJFRWeakRoot::ShenandoahJFRWeakRoot() :
 99   ShenandoahWeakSerialRoot(&amp;Jfr::weak_oops_do, ShenandoahPhaseTimings::JFRWeakRoots) {
100 }
101 #endif // INCLUDE_JFR
102 






103 void ShenandoahSerialWeakRoots::weak_oops_do(BoolObjectClosure* is_alive, OopClosure* keep_alive, uint worker_id) {
104   JVMTI_ONLY(_jvmti_weak_roots.weak_oops_do(is_alive, keep_alive, worker_id);)
105   JFR_ONLY(_jfr_weak_roots.weak_oops_do(is_alive, keep_alive, worker_id);)

106 }
107 
108 void ShenandoahSerialWeakRoots::weak_oops_do(OopClosure* cl, uint worker_id) {
109   AlwaysTrueClosure always_true;
110   weak_oops_do(&amp;always_true, cl, worker_id);
111 }
112 
113 ShenandoahThreadRoots::ShenandoahThreadRoots(bool is_par) : _is_par(is_par) {
114   Threads::change_thread_claim_token();
115 }
116 
117 void ShenandoahThreadRoots::oops_do(OopClosure* oops_cl, CodeBlobClosure* code_cl, uint worker_id) {
118   ShenandoahWorkerTimings* worker_times = ShenandoahHeap::heap()-&gt;phase_timings()-&gt;worker_times();
119   ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::ThreadRoots, worker_id);
120   ResourceMark rm;
121   Threads::possibly_parallel_oops_do(_is_par, oops_cl, code_cl);
122 }
123 
124 void ShenandoahThreadRoots::threads_do(ThreadClosure* tc, uint worker_id) {
125   ShenandoahWorkerTimings* worker_times = ShenandoahHeap::heap()-&gt;phase_timings()-&gt;worker_times();
</pre>
</td>
<td>
<hr />
<pre>
 25 #include &quot;precompiled.hpp&quot;
 26 
 27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
 28 #include &quot;classfile/stringTable.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;code/codeCache.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahClosures.inline.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahConcurrentRoots.hpp&quot;
 33 #include &quot;gc/shenandoah/shenandoahRootProcessor.inline.hpp&quot;
 34 #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;
 35 #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
 36 #include &quot;gc/shenandoah/shenandoahStringDedup.hpp&quot;
 37 #include &quot;gc/shenandoah/shenandoahTimingTracker.hpp&quot;
 38 #include &quot;gc/shenandoah/shenandoahVMOperations.hpp&quot;
 39 #include &quot;jfr/jfr.hpp&quot;
 40 #include &quot;memory/iterator.hpp&quot;
 41 #include &quot;memory/resourceArea.hpp&quot;
 42 #include &quot;memory/universe.hpp&quot;
 43 #include &quot;runtime/thread.hpp&quot;
 44 #include &quot;services/management.hpp&quot;
<span class="line-added"> 45 #include &quot;tsan/tsanOopMap.hpp&quot;</span>
 46 
 47 ShenandoahSerialRoot::ShenandoahSerialRoot(ShenandoahSerialRoot::OopsDo oops_do, ShenandoahPhaseTimings::GCParPhases phase) :
 48   _oops_do(oops_do), _phase(phase) {
 49 }
 50 
 51 void ShenandoahSerialRoot::oops_do(OopClosure* cl, uint worker_id) {
 52   if (_claimed.try_set()) {
 53     ShenandoahWorkerTimings* worker_times = ShenandoahHeap::heap()-&gt;phase_timings()-&gt;worker_times();
 54     ShenandoahWorkerTimingsTracker timer(worker_times, _phase, worker_id);
 55     _oops_do(cl);
 56   }
 57 }
 58 
 59 // Overwrite the second argument for SD::oops_do, don&#39;t include vm global oop storage.
 60 static void system_dictionary_oops_do(OopClosure* cl) {
 61   SystemDictionary::oops_do(cl, false);
 62 }
 63 
 64 ShenandoahSerialRoots::ShenandoahSerialRoots() :
 65   _universe_root(&amp;Universe::oops_do, ShenandoahPhaseTimings::UniverseRoots),
</pre>
<hr />
<pre>
 84 void ShenandoahWeakSerialRoot::weak_oops_do(BoolObjectClosure* is_alive, OopClosure* keep_alive, uint worker_id) {
 85   if (_claimed.try_set()) {
 86     ShenandoahWorkerTimings* worker_times = ShenandoahHeap::heap()-&gt;phase_timings()-&gt;worker_times();
 87     ShenandoahWorkerTimingsTracker timer(worker_times, _phase, worker_id);
 88     _weak_oops_do(is_alive, keep_alive);
 89   }
 90 }
 91 
 92 #if INCLUDE_JVMTI
 93 ShenandoahJVMTIWeakRoot::ShenandoahJVMTIWeakRoot() :
 94   ShenandoahWeakSerialRoot(&amp;JvmtiExport::weak_oops_do, ShenandoahPhaseTimings::JVMTIWeakRoots) {
 95 }
 96 #endif // INCLUDE_JVMTI
 97 
 98 #if INCLUDE_JFR
 99 ShenandoahJFRWeakRoot::ShenandoahJFRWeakRoot() :
100   ShenandoahWeakSerialRoot(&amp;Jfr::weak_oops_do, ShenandoahPhaseTimings::JFRWeakRoots) {
101 }
102 #endif // INCLUDE_JFR
103 
<span class="line-added">104 #if INCLUDE_TSAN</span>
<span class="line-added">105 ShenandoahTSANWeakRoot::ShenandoahTSANWeakRoot() :</span>
<span class="line-added">106   ShenandoahWeakSerialRoot(&amp;TsanOopMap::weak_oops_do, ShenandoahPhaseTimings::TSANWeakRoots) {</span>
<span class="line-added">107 }</span>
<span class="line-added">108 #endif // INCLUDE_TSAN</span>
<span class="line-added">109 </span>
110 void ShenandoahSerialWeakRoots::weak_oops_do(BoolObjectClosure* is_alive, OopClosure* keep_alive, uint worker_id) {
111   JVMTI_ONLY(_jvmti_weak_roots.weak_oops_do(is_alive, keep_alive, worker_id);)
112   JFR_ONLY(_jfr_weak_roots.weak_oops_do(is_alive, keep_alive, worker_id);)
<span class="line-added">113   TSAN_ONLY(_tsan_weak_roots.weak_oops_do(is_alive, keep_alive, worker_id);)</span>
114 }
115 
116 void ShenandoahSerialWeakRoots::weak_oops_do(OopClosure* cl, uint worker_id) {
117   AlwaysTrueClosure always_true;
118   weak_oops_do(&amp;always_true, cl, worker_id);
119 }
120 
121 ShenandoahThreadRoots::ShenandoahThreadRoots(bool is_par) : _is_par(is_par) {
122   Threads::change_thread_claim_token();
123 }
124 
125 void ShenandoahThreadRoots::oops_do(OopClosure* oops_cl, CodeBlobClosure* code_cl, uint worker_id) {
126   ShenandoahWorkerTimings* worker_times = ShenandoahHeap::heap()-&gt;phase_timings()-&gt;worker_times();
127   ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::ThreadRoots, worker_id);
128   ResourceMark rm;
129   Threads::possibly_parallel_oops_do(_is_par, oops_cl, code_cl);
130 }
131 
132 void ShenandoahThreadRoots::threads_do(ThreadClosure* tc, uint worker_id) {
133   ShenandoahWorkerTimings* worker_times = ShenandoahHeap::heap()-&gt;phase_timings()-&gt;worker_times();
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahPhaseTimings.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahRootProcessor.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
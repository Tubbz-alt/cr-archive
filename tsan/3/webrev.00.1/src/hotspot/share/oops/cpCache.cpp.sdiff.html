<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/cpCache.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../interpreter/interpreterRuntime.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="cpCache.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/cpCache.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
115   Atomic::release_store(&amp;_f1, f1);
116 }
117 
118 void ConstantPoolCacheEntry::set_indy_resolution_failed() {
119   Atomic::release_store(&amp;_flags, _flags | (1 &lt;&lt; indy_resolution_failed_shift));
120 }
121 
122 // Note that concurrent update of both bytecodes can leave one of them
123 // reset to zero.  This is harmless; the interpreter will simply re-resolve
124 // the damaged entry.  More seriously, the memory synchronization is needed
125 // to flush other fields (f1, f2) completely to memory before the bytecodes
126 // are updated, lest other processors see a non-zero bytecode but zero f1/f2.
127 void ConstantPoolCacheEntry::set_field(Bytecodes::Code get_code,
128                                        Bytecodes::Code put_code,
129                                        Klass* field_holder,
130                                        int field_index,
131                                        int field_offset,
132                                        TosState field_type,
133                                        bool is_final,
134                                        bool is_volatile,

135                                        Klass* root_klass) {
136   set_f1(field_holder);
137   set_f2(field_offset);
138   assert((field_index &amp; field_index_mask) == field_index,
139          &quot;field index does not fit in low flag bits&quot;);
140   set_field_flags(field_type,
141                   ((is_volatile ? 1 : 0) &lt;&lt; is_volatile_shift) |
<span class="line-modified">142                   ((is_final    ? 1 : 0) &lt;&lt; is_final_shift),</span>

143                   field_index);
144   set_bytecode_1(get_code);
145   set_bytecode_2(put_code);
146   NOT_PRODUCT(verify(tty));
147 }
148 
149 void ConstantPoolCacheEntry::set_parameter_size(int value) {
150   // This routine is called only in corner cases where the CPCE is not yet initialized.
151   // See AbstractInterpreter::deopt_continue_after_entry.
152   assert(_flags == 0 || parameter_size() == 0 || parameter_size() == value,
153          &quot;size must not change: parameter_size=%d, value=%d&quot;, parameter_size(), value);
154   // Setting the parameter size by itself is only safe if the
155   // current value of _flags is 0, otherwise another thread may have
156   // updated it and we don&#39;t want to overwrite that value.  Don&#39;t
157   // bother trying to update it once it&#39;s nonzero but always make
158   // sure that the final parameter size agrees with what was passed.
159   if (_flags == 0) {
160     intx newflags = (value &amp; parameter_size_mask);
161     Atomic::cmpxchg(&amp;_flags, (intx)0, newflags);
162   }
</pre>
</td>
<td>
<hr />
<pre>
115   Atomic::release_store(&amp;_f1, f1);
116 }
117 
118 void ConstantPoolCacheEntry::set_indy_resolution_failed() {
119   Atomic::release_store(&amp;_flags, _flags | (1 &lt;&lt; indy_resolution_failed_shift));
120 }
121 
122 // Note that concurrent update of both bytecodes can leave one of them
123 // reset to zero.  This is harmless; the interpreter will simply re-resolve
124 // the damaged entry.  More seriously, the memory synchronization is needed
125 // to flush other fields (f1, f2) completely to memory before the bytecodes
126 // are updated, lest other processors see a non-zero bytecode but zero f1/f2.
127 void ConstantPoolCacheEntry::set_field(Bytecodes::Code get_code,
128                                        Bytecodes::Code put_code,
129                                        Klass* field_holder,
130                                        int field_index,
131                                        int field_offset,
132                                        TosState field_type,
133                                        bool is_final,
134                                        bool is_volatile,
<span class="line-added">135                                        bool is_tsan_ignore,</span>
136                                        Klass* root_klass) {
137   set_f1(field_holder);
138   set_f2(field_offset);
139   assert((field_index &amp; field_index_mask) == field_index,
140          &quot;field index does not fit in low flag bits&quot;);
141   set_field_flags(field_type,
142                   ((is_volatile ? 1 : 0) &lt;&lt; is_volatile_shift) |
<span class="line-modified">143                   ((is_final    ? 1 : 0) &lt;&lt; is_final_shift) |</span>
<span class="line-added">144                   ((is_tsan_ignore ? 1 : 0) &lt;&lt; is_tsan_ignore_shift),</span>
145                   field_index);
146   set_bytecode_1(get_code);
147   set_bytecode_2(put_code);
148   NOT_PRODUCT(verify(tty));
149 }
150 
151 void ConstantPoolCacheEntry::set_parameter_size(int value) {
152   // This routine is called only in corner cases where the CPCE is not yet initialized.
153   // See AbstractInterpreter::deopt_continue_after_entry.
154   assert(_flags == 0 || parameter_size() == 0 || parameter_size() == value,
155          &quot;size must not change: parameter_size=%d, value=%d&quot;, parameter_size(), value);
156   // Setting the parameter size by itself is only safe if the
157   // current value of _flags is 0, otherwise another thread may have
158   // updated it and we don&#39;t want to overwrite that value.  Don&#39;t
159   // bother trying to update it once it&#39;s nonzero but always make
160   // sure that the final parameter size agrees with what was passed.
161   if (_flags == 0) {
162     intx newflags = (value &amp; parameter_size_mask);
163     Atomic::cmpxchg(&amp;_flags, (intx)0, newflags);
164   }
</pre>
</td>
</tr>
</table>
<center><a href="../interpreter/interpreterRuntime.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="cpCache.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/oops/instanceKlass.cpp b/src/hotspot/share/oops/instanceKlass.cpp
--- a/src/hotspot/share/oops/instanceKlass.cpp
+++ b/src/hotspot/share/oops/instanceKlass.cpp
@@ -86,10 +86,13 @@
 #include "c1/c1_Compiler.hpp"
 #endif
 #if INCLUDE_JFR
 #include "jfr/jfrEvents.hpp"
 #endif
+#if INCLUDE_TSAN
+#include "runtime/sharedRuntime.hpp"
+#endif
 
 
 #ifdef DTRACE_ENABLED
 
 
@@ -712,10 +715,17 @@
     // progress, whereas here we might just be spinning in place.
     if (old_state != _init_state)
       set_init_state(old_state);
   } else {
     // linking successfull, mark class as initialized
+    TSAN_RUNTIME_ONLY(
+      // Construct a happens-before edge between the write of _init_state to
+      // fully_initialized and the later checking if it's initialized.
+      void* const lock_address = reinterpret_cast<void*>(
+          java_lang_Class::init_lock_addr(java_mirror()));
+      SharedRuntime::tsan_release(lock_address);
+    );
     set_init_state(fully_initialized);
     fence_and_clear_init_lock();
     // trace
     if (log_is_enabled(Info, class, init)) {
       ResourceMark rm(THREAD);
@@ -733,10 +743,17 @@
     initialize_impl(CHECK);
     // Note: at this point the class may be initialized
     //       OR it may be in the state of being initialized
     //       in case of recursive initialization!
   } else {
+    TSAN_RUNTIME_ONLY(
+      // Construct a happens-before edge between the write of _init_state to
+      // fully_initialized and here.
+      void* const lock_address = reinterpret_cast<void*>(
+          java_lang_Class::init_lock_addr(java_mirror()));
+      SharedRuntime::tsan_acquire(lock_address);
+    );
     assert(is_initialized(), "sanity check");
   }
 }
 
 
@@ -1093,10 +1110,17 @@
 
 void InstanceKlass::set_initialization_state_and_notify(ClassState state, TRAPS) {
   Handle h_init_lock(THREAD, init_lock());
   if (h_init_lock() != NULL) {
     ObjectLocker ol(h_init_lock, THREAD);
+    TSAN_RUNTIME_ONLY(
+      // Construct a happens-before edge between the write of _init_state to
+      // fully_initialized and the later checking if it's initialized.
+      void* const lock_address = reinterpret_cast<void*>(
+          java_lang_Class::init_lock_addr(java_mirror()));
+      SharedRuntime::tsan_release(lock_address);
+    );
     set_init_thread(NULL); // reset _init_thread before changing _init_state
     set_init_state(state);
     fence_and_clear_init_lock();
     ol.notify_all(CHECK);
   } else {

diff a/src/hotspot/cpu/x86/interp_masm_x86.cpp b/src/hotspot/cpu/x86/interp_masm_x86.cpp
--- a/src/hotspot/cpu/x86/interp_masm_x86.cpp
+++ b/src/hotspot/cpu/x86/interp_masm_x86.cpp
@@ -1172,10 +1172,11 @@
 //      rax, rbx
 void InterpreterMacroAssembler::lock_object(Register lock_reg) {
   assert(lock_reg == LP64_ONLY(c_rarg1) NOT_LP64(rdx),
          "The argument is only for looks. It must be c_rarg1");
 
+  TSAN_RUNTIME_ONLY(push_ptr(lock_reg));
   if (UseHeavyMonitors) {
     call_VM(noreg,
             CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),
             lock_reg);
   } else {
@@ -1250,10 +1251,19 @@
             CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),
             lock_reg);
 
     bind(done);
   }
+
+  TSAN_RUNTIME_ONLY(
+    pop_ptr(lock_reg);
+    pusha();
+    call_VM(noreg,
+            CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_lock),
+            lock_reg);
+    popa();
+  );
 }
 
 
 // Unlocks an object. Used in monitorexit bytecode and
 // remove_activation.  Throws an IllegalMonitorException if object is
@@ -1269,10 +1279,18 @@
 // rax, rbx, rcx, rdx
 void InterpreterMacroAssembler::unlock_object(Register lock_reg) {
   assert(lock_reg == LP64_ONLY(c_rarg1) NOT_LP64(rdx),
          "The argument is only for looks. It must be c_rarg1");
 
+  TSAN_RUNTIME_ONLY(
+    pusha();
+    call_VM(noreg,
+            CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_unlock),
+            lock_reg);
+    popa();
+  );
+
   if (UseHeavyMonitors) {
     call_VM(noreg,
             CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit),
             lock_reg);
   } else {
@@ -2013,10 +2031,14 @@
     get_method(rarg);
     call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_entry),
                  rthread, rarg);
   }
 
+  TSAN_RUNTIME_ONLY(call_VM(noreg,
+                            CAST_FROM_FN_PTR(address,
+                                             SharedRuntime::tsan_interp_method_entry)));
+
   // RedefineClasses() tracing support for obsolete method entry
   if (log_is_enabled(Trace, redefine, class, obsolete)) {
     NOT_LP64(get_thread(rthread);)
     get_method(rarg);
     call_VM_leaf(
@@ -2050,10 +2072,17 @@
             CAST_FROM_FN_PTR(address, InterpreterRuntime::post_method_exit));
     bind(L);
     pop(state);
   }
 
+  TSAN_RUNTIME_ONLY(
+    push(state);
+    call_VM_leaf(CAST_FROM_FN_PTR(address,
+                                  SharedRuntime::tsan_interp_method_exit));
+    pop(state);
+  );
+
   {
     SkipIfEqual skip(this, &DTraceMethodProbes, false);
     push(state);
     NOT_LP64(get_thread(rthread);)
     get_method(rarg);

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/templateTable_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;compiler/disassembler.hpp&quot;
  28 #include &quot;interpreter/interpreter.hpp&quot;
  29 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  30 #include &quot;interpreter/interp_masm.hpp&quot;
  31 #include &quot;interpreter/templateTable.hpp&quot;
  32 #include &quot;memory/universe.hpp&quot;
  33 #include &quot;oops/methodData.hpp&quot;
  34 #include &quot;oops/objArrayKlass.hpp&quot;
  35 #include &quot;oops/oop.inline.hpp&quot;
  36 #include &quot;prims/methodHandles.hpp&quot;
  37 #include &quot;runtime/frame.inline.hpp&quot;
  38 #include &quot;runtime/safepointMechanism.hpp&quot;
  39 #include &quot;runtime/sharedRuntime.hpp&quot;
  40 #include &quot;runtime/stubRoutines.hpp&quot;
  41 #include &quot;runtime/synchronizer.hpp&quot;
  42 #include &quot;utilities/macros.hpp&quot;
  43 
  44 #define __ Disassembler::hook&lt;InterpreterMacroAssembler&gt;(__FILE__, __LINE__, _masm)-&gt;
  45 
  46 // Global Register Names
  47 static const Register rbcp     = LP64_ONLY(r13) NOT_LP64(rsi);
  48 static const Register rlocals  = LP64_ONLY(r14) NOT_LP64(rdi);
  49 
  50 // Platform-dependent initialization
  51 void TemplateTable::pd_initialize() {
  52   // No x86 specific initialization
  53 }
  54 
  55 // Address Computation: local variables
  56 static inline Address iaddress(int n) {
  57   return Address(rlocals, Interpreter::local_offset_in_bytes(n));
  58 }
  59 
  60 static inline Address laddress(int n) {
  61   return iaddress(n + 1);
  62 }
  63 
  64 #ifndef _LP64
  65 static inline Address haddress(int n) {
  66   return iaddress(n + 0);
  67 }
  68 #endif
  69 
  70 static inline Address faddress(int n) {
  71   return iaddress(n);
  72 }
  73 
  74 static inline Address daddress(int n) {
  75   return laddress(n);
  76 }
  77 
  78 static inline Address aaddress(int n) {
  79   return iaddress(n);
  80 }
  81 
  82 static inline Address iaddress(Register r) {
  83   return Address(rlocals, r, Address::times_ptr);
  84 }
  85 
  86 static inline Address laddress(Register r) {
  87   return Address(rlocals, r, Address::times_ptr, Interpreter::local_offset_in_bytes(1));
  88 }
  89 
  90 #ifndef _LP64
  91 static inline Address haddress(Register r)       {
  92   return Address(rlocals, r, Interpreter::stackElementScale(), Interpreter::local_offset_in_bytes(0));
  93 }
  94 #endif
  95 
  96 static inline Address faddress(Register r) {
  97   return iaddress(r);
  98 }
  99 
 100 static inline Address daddress(Register r) {
 101   return laddress(r);
 102 }
 103 
 104 static inline Address aaddress(Register r) {
 105   return iaddress(r);
 106 }
 107 
 108 
 109 // expression stack
 110 // (Note: Must not use symmetric equivalents at_rsp_m1/2 since they store
 111 // data beyond the rsp which is potentially unsafe in an MT environment;
 112 // an interrupt may overwrite that data.)
 113 static inline Address at_rsp   () {
 114   return Address(rsp, 0);
 115 }
 116 
 117 // At top of Java expression stack which may be different than esp().  It
 118 // isn&#39;t for category 1 objects.
 119 static inline Address at_tos   () {
 120   return Address(rsp,  Interpreter::expr_offset_in_bytes(0));
 121 }
 122 
 123 static inline Address at_tos_p1() {
 124   return Address(rsp,  Interpreter::expr_offset_in_bytes(1));
 125 }
 126 
 127 static inline Address at_tos_p2() {
 128   return Address(rsp,  Interpreter::expr_offset_in_bytes(2));
 129 }
 130 
 131 // Condition conversion
 132 static Assembler::Condition j_not(TemplateTable::Condition cc) {
 133   switch (cc) {
 134   case TemplateTable::equal        : return Assembler::notEqual;
 135   case TemplateTable::not_equal    : return Assembler::equal;
 136   case TemplateTable::less         : return Assembler::greaterEqual;
 137   case TemplateTable::less_equal   : return Assembler::greater;
 138   case TemplateTable::greater      : return Assembler::lessEqual;
 139   case TemplateTable::greater_equal: return Assembler::less;
 140   }
 141   ShouldNotReachHere();
 142   return Assembler::zero;
 143 }
 144 
 145 
 146 
 147 // Miscelaneous helper routines
 148 // Store an oop (or NULL) at the address described by obj.
 149 // If val == noreg this means store a NULL
 150 
 151 
 152 static void do_oop_store(InterpreterMacroAssembler* _masm,
 153                          Address dst,
 154                          Register val,
 155                          DecoratorSet decorators = 0) {
 156   assert(val == noreg || val == rax, &quot;parameter is just for looks&quot;);
 157   __ store_heap_oop(dst, val, rdx, rbx, decorators);
 158 }
 159 
 160 static void do_oop_load(InterpreterMacroAssembler* _masm,
 161                         Address src,
 162                         Register dst,
 163                         DecoratorSet decorators = 0) {
 164   __ load_heap_oop(dst, src, rdx, rbx, decorators);
 165 }
 166 
 167 Address TemplateTable::at_bcp(int offset) {
 168   assert(_desc-&gt;uses_bcp(), &quot;inconsistent uses_bcp information&quot;);
 169   return Address(rbcp, offset);
 170 }
 171 
 172 
 173 void TemplateTable::patch_bytecode(Bytecodes::Code bc, Register bc_reg,
 174                                    Register temp_reg, bool load_bc_into_bc_reg/*=true*/,
 175                                    int byte_no) {
 176   if (!RewriteBytecodes)  return;
 177   Label L_patch_done;
 178 
 179   switch (bc) {
 180   case Bytecodes::_fast_aputfield:
 181   case Bytecodes::_fast_bputfield:
 182   case Bytecodes::_fast_zputfield:
 183   case Bytecodes::_fast_cputfield:
 184   case Bytecodes::_fast_dputfield:
 185   case Bytecodes::_fast_fputfield:
 186   case Bytecodes::_fast_iputfield:
 187   case Bytecodes::_fast_lputfield:
 188   case Bytecodes::_fast_sputfield:
 189     {
 190       // We skip bytecode quickening for putfield instructions when
 191       // the put_code written to the constant pool cache is zero.
 192       // This is required so that every execution of this instruction
 193       // calls out to InterpreterRuntime::resolve_get_put to do
 194       // additional, required work.
 195       assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
 196       assert(load_bc_into_bc_reg, &quot;we use bc_reg as temp&quot;);
 197       __ get_cache_and_index_and_bytecode_at_bcp(temp_reg, bc_reg, temp_reg, byte_no, 1);
 198       __ movl(bc_reg, bc);
 199       __ cmpl(temp_reg, (int) 0);
 200       __ jcc(Assembler::zero, L_patch_done);  // don&#39;t patch
 201     }
 202     break;
 203   default:
 204     assert(byte_no == -1, &quot;sanity&quot;);
 205     // the pair bytecodes have already done the load.
 206     if (load_bc_into_bc_reg) {
 207       __ movl(bc_reg, bc);
 208     }
 209   }
 210 
 211   if (JvmtiExport::can_post_breakpoint()) {
 212     Label L_fast_patch;
 213     // if a breakpoint is present we can&#39;t rewrite the stream directly
 214     __ movzbl(temp_reg, at_bcp(0));
 215     __ cmpl(temp_reg, Bytecodes::_breakpoint);
 216     __ jcc(Assembler::notEqual, L_fast_patch);
 217     __ get_method(temp_reg);
 218     // Let breakpoint table handling rewrite to quicker bytecode
 219     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::set_original_bytecode_at), temp_reg, rbcp, bc_reg);
 220 #ifndef ASSERT
 221     __ jmpb(L_patch_done);
 222 #else
 223     __ jmp(L_patch_done);
 224 #endif
 225     __ bind(L_fast_patch);
 226   }
 227 
 228 #ifdef ASSERT
 229   Label L_okay;
 230   __ load_unsigned_byte(temp_reg, at_bcp(0));
 231   __ cmpl(temp_reg, (int) Bytecodes::java_code(bc));
 232   __ jcc(Assembler::equal, L_okay);
 233   __ cmpl(temp_reg, bc_reg);
 234   __ jcc(Assembler::equal, L_okay);
 235   __ stop(&quot;patching the wrong bytecode&quot;);
 236   __ bind(L_okay);
 237 #endif
 238 
 239   // patch bytecode
 240   __ movb(at_bcp(0), bc_reg);
 241   __ bind(L_patch_done);
 242 }
 243 // Individual instructions
 244 
 245 
 246 void TemplateTable::nop() {
 247   transition(vtos, vtos);
 248   // nothing to do
 249 }
 250 
 251 void TemplateTable::shouldnotreachhere() {
 252   transition(vtos, vtos);
 253   __ stop(&quot;shouldnotreachhere bytecode&quot;);
 254 }
 255 
 256 void TemplateTable::aconst_null() {
 257   transition(vtos, atos);
 258   __ xorl(rax, rax);
 259 }
 260 
 261 void TemplateTable::iconst(int value) {
 262   transition(vtos, itos);
 263   if (value == 0) {
 264     __ xorl(rax, rax);
 265   } else {
 266     __ movl(rax, value);
 267   }
 268 }
 269 
 270 void TemplateTable::lconst(int value) {
 271   transition(vtos, ltos);
 272   if (value == 0) {
 273     __ xorl(rax, rax);
 274   } else {
 275     __ movl(rax, value);
 276   }
 277 #ifndef _LP64
 278   assert(value &gt;= 0, &quot;check this code&quot;);
 279   __ xorptr(rdx, rdx);
 280 #endif
 281 }
 282 
 283 
 284 
 285 void TemplateTable::fconst(int value) {
 286   transition(vtos, ftos);
 287   if (UseSSE &gt;= 1) {
 288     static float one = 1.0f, two = 2.0f;
 289     switch (value) {
 290     case 0:
 291       __ xorps(xmm0, xmm0);
 292       break;
 293     case 1:
 294       __ movflt(xmm0, ExternalAddress((address) &amp;one));
 295       break;
 296     case 2:
 297       __ movflt(xmm0, ExternalAddress((address) &amp;two));
 298       break;
 299     default:
 300       ShouldNotReachHere();
 301       break;
 302     }
 303   } else {
 304 #ifdef _LP64
 305     ShouldNotReachHere();
 306 #else
 307            if (value == 0) { __ fldz();
 308     } else if (value == 1) { __ fld1();
 309     } else if (value == 2) { __ fld1(); __ fld1(); __ faddp(); // should do a better solution here
 310     } else                 { ShouldNotReachHere();
 311     }
 312 #endif // _LP64
 313   }
 314 }
 315 
 316 void TemplateTable::dconst(int value) {
 317   transition(vtos, dtos);
 318   if (UseSSE &gt;= 2) {
 319     static double one = 1.0;
 320     switch (value) {
 321     case 0:
 322       __ xorpd(xmm0, xmm0);
 323       break;
 324     case 1:
 325       __ movdbl(xmm0, ExternalAddress((address) &amp;one));
 326       break;
 327     default:
 328       ShouldNotReachHere();
 329       break;
 330     }
 331   } else {
 332 #ifdef _LP64
 333     ShouldNotReachHere();
 334 #else
 335            if (value == 0) { __ fldz();
 336     } else if (value == 1) { __ fld1();
 337     } else                 { ShouldNotReachHere();
 338     }
 339 #endif
 340   }
 341 }
 342 
 343 void TemplateTable::bipush() {
 344   transition(vtos, itos);
 345   __ load_signed_byte(rax, at_bcp(1));
 346 }
 347 
 348 void TemplateTable::sipush() {
 349   transition(vtos, itos);
 350   __ load_unsigned_short(rax, at_bcp(1));
 351   __ bswapl(rax);
 352   __ sarl(rax, 16);
 353 }
 354 
 355 void TemplateTable::ldc(bool wide) {
 356   transition(vtos, vtos);
 357   Register rarg = NOT_LP64(rcx) LP64_ONLY(c_rarg1);
 358   Label call_ldc, notFloat, notClass, notInt, Done;
 359 
 360   if (wide) {
 361     __ get_unsigned_2_byte_index_at_bcp(rbx, 1);
 362   } else {
 363     __ load_unsigned_byte(rbx, at_bcp(1));
 364   }
 365 
 366   __ get_cpool_and_tags(rcx, rax);
 367   const int base_offset = ConstantPool::header_size() * wordSize;
 368   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
 369 
 370   // get type
 371   __ movzbl(rdx, Address(rax, rbx, Address::times_1, tags_offset));
 372 
 373   // unresolved class - get the resolved class
 374   __ cmpl(rdx, JVM_CONSTANT_UnresolvedClass);
 375   __ jccb(Assembler::equal, call_ldc);
 376 
 377   // unresolved class in error state - call into runtime to throw the error
 378   // from the first resolution attempt
 379   __ cmpl(rdx, JVM_CONSTANT_UnresolvedClassInError);
 380   __ jccb(Assembler::equal, call_ldc);
 381 
 382   // resolved class - need to call vm to get java mirror of the class
 383   __ cmpl(rdx, JVM_CONSTANT_Class);
 384   __ jcc(Assembler::notEqual, notClass);
 385 
 386   __ bind(call_ldc);
 387 
 388   __ movl(rarg, wide);
 389   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::ldc), rarg);
 390 
 391   __ push(atos);
 392   __ jmp(Done);
 393 
 394   __ bind(notClass);
 395   __ cmpl(rdx, JVM_CONSTANT_Float);
 396   __ jccb(Assembler::notEqual, notFloat);
 397 
 398   // ftos
 399   __ load_float(Address(rcx, rbx, Address::times_ptr, base_offset));
 400   __ push(ftos);
 401   __ jmp(Done);
 402 
 403   __ bind(notFloat);
 404   __ cmpl(rdx, JVM_CONSTANT_Integer);
 405   __ jccb(Assembler::notEqual, notInt);
 406 
 407   // itos
 408   __ movl(rax, Address(rcx, rbx, Address::times_ptr, base_offset));
 409   __ push(itos);
 410   __ jmp(Done);
 411 
 412   // assume the tag is for condy; if not, the VM runtime will tell us
 413   __ bind(notInt);
 414   condy_helper(Done);
 415 
 416   __ bind(Done);
 417 }
 418 
 419 // Fast path for caching oop constants.
 420 void TemplateTable::fast_aldc(bool wide) {
 421   transition(vtos, atos);
 422 
 423   Register result = rax;
 424   Register tmp = rdx;
 425   Register rarg = NOT_LP64(rcx) LP64_ONLY(c_rarg1);
 426   int index_size = wide ? sizeof(u2) : sizeof(u1);
 427 
 428   Label resolved;
 429 
 430   // We are resolved if the resolved reference cache entry contains a
 431   // non-null object (String, MethodType, etc.)
 432   assert_different_registers(result, tmp);
 433   __ get_cache_index_at_bcp(tmp, 1, index_size);
 434   __ load_resolved_reference_at_index(result, tmp);
 435   __ testptr(result, result);
 436   __ jcc(Assembler::notZero, resolved);
 437 
 438   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_ldc);
 439 
 440   // first time invocation - must resolve first
 441   __ movl(rarg, (int)bytecode());
 442   __ call_VM(result, entry, rarg);
 443   __ bind(resolved);
 444 
 445   { // Check for the null sentinel.
 446     // If we just called the VM, it already did the mapping for us,
 447     // but it&#39;s harmless to retry.
 448     Label notNull;
 449     ExternalAddress null_sentinel((address)Universe::the_null_sentinel_addr());
 450     __ movptr(tmp, null_sentinel);
 451     __ cmpoop(tmp, result);
 452     __ jccb(Assembler::notEqual, notNull);
 453     __ xorptr(result, result);  // NULL object reference
 454     __ bind(notNull);
 455   }
 456 
 457   if (VerifyOops) {
 458     __ verify_oop(result);
 459   }
 460 }
 461 
 462 void TemplateTable::ldc2_w() {
 463   transition(vtos, vtos);
 464   Label notDouble, notLong, Done;
 465   __ get_unsigned_2_byte_index_at_bcp(rbx, 1);
 466 
 467   __ get_cpool_and_tags(rcx, rax);
 468   const int base_offset = ConstantPool::header_size() * wordSize;
 469   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
 470 
 471   // get type
 472   __ movzbl(rdx, Address(rax, rbx, Address::times_1, tags_offset));
 473   __ cmpl(rdx, JVM_CONSTANT_Double);
 474   __ jccb(Assembler::notEqual, notDouble);
 475 
 476   // dtos
 477   __ load_double(Address(rcx, rbx, Address::times_ptr, base_offset));
 478   __ push(dtos);
 479 
 480   __ jmp(Done);
 481   __ bind(notDouble);
 482   __ cmpl(rdx, JVM_CONSTANT_Long);
 483   __ jccb(Assembler::notEqual, notLong);
 484 
 485   // ltos
 486   __ movptr(rax, Address(rcx, rbx, Address::times_ptr, base_offset + 0 * wordSize));
 487   NOT_LP64(__ movptr(rdx, Address(rcx, rbx, Address::times_ptr, base_offset + 1 * wordSize)));
 488   __ push(ltos);
 489   __ jmp(Done);
 490 
 491   __ bind(notLong);
 492   condy_helper(Done);
 493 
 494   __ bind(Done);
 495 }
 496 
 497 void TemplateTable::condy_helper(Label&amp; Done) {
 498   const Register obj = rax;
 499   const Register off = rbx;
 500   const Register flags = rcx;
 501   const Register rarg = NOT_LP64(rcx) LP64_ONLY(c_rarg1);
 502   __ movl(rarg, (int)bytecode());
 503   call_VM(obj, CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_ldc), rarg);
 504 #ifndef _LP64
 505   // borrow rdi from locals
 506   __ get_thread(rdi);
 507   __ get_vm_result_2(flags, rdi);
 508   __ restore_locals();
 509 #else
 510   __ get_vm_result_2(flags, r15_thread);
 511 #endif
 512   // VMr = obj = base address to find primitive value to push
 513   // VMr2 = flags = (tos, off) using format of CPCE::_flags
 514   __ movl(off, flags);
 515   __ andl(off, ConstantPoolCacheEntry::field_index_mask);
 516   const Address field(obj, off, Address::times_1, 0*wordSize);
 517 
 518   // What sort of thing are we loading?
 519   __ shrl(flags, ConstantPoolCacheEntry::tos_state_shift);
 520   __ andl(flags, ConstantPoolCacheEntry::tos_state_mask);
 521 
 522   switch (bytecode()) {
 523   case Bytecodes::_ldc:
 524   case Bytecodes::_ldc_w:
 525     {
 526       // tos in (itos, ftos, stos, btos, ctos, ztos)
 527       Label notInt, notFloat, notShort, notByte, notChar, notBool;
 528       __ cmpl(flags, itos);
 529       __ jcc(Assembler::notEqual, notInt);
 530       // itos
 531       __ movl(rax, field);
 532       __ push(itos);
 533       __ jmp(Done);
 534 
 535       __ bind(notInt);
 536       __ cmpl(flags, ftos);
 537       __ jcc(Assembler::notEqual, notFloat);
 538       // ftos
 539       __ load_float(field);
 540       __ push(ftos);
 541       __ jmp(Done);
 542 
 543       __ bind(notFloat);
 544       __ cmpl(flags, stos);
 545       __ jcc(Assembler::notEqual, notShort);
 546       // stos
 547       __ load_signed_short(rax, field);
 548       __ push(stos);
 549       __ jmp(Done);
 550 
 551       __ bind(notShort);
 552       __ cmpl(flags, btos);
 553       __ jcc(Assembler::notEqual, notByte);
 554       // btos
 555       __ load_signed_byte(rax, field);
 556       __ push(btos);
 557       __ jmp(Done);
 558 
 559       __ bind(notByte);
 560       __ cmpl(flags, ctos);
 561       __ jcc(Assembler::notEqual, notChar);
 562       // ctos
 563       __ load_unsigned_short(rax, field);
 564       __ push(ctos);
 565       __ jmp(Done);
 566 
 567       __ bind(notChar);
 568       __ cmpl(flags, ztos);
 569       __ jcc(Assembler::notEqual, notBool);
 570       // ztos
 571       __ load_signed_byte(rax, field);
 572       __ push(ztos);
 573       __ jmp(Done);
 574 
 575       __ bind(notBool);
 576       break;
 577     }
 578 
 579   case Bytecodes::_ldc2_w:
 580     {
 581       Label notLong, notDouble;
 582       __ cmpl(flags, ltos);
 583       __ jcc(Assembler::notEqual, notLong);
 584       // ltos
 585       // Loading high word first because movptr clobbers rax
 586       NOT_LP64(__ movptr(rdx, field.plus_disp(4)));
 587       __ movptr(rax, field);
 588       __ push(ltos);
 589       __ jmp(Done);
 590 
 591       __ bind(notLong);
 592       __ cmpl(flags, dtos);
 593       __ jcc(Assembler::notEqual, notDouble);
 594       // dtos
 595       __ load_double(field);
 596       __ push(dtos);
 597       __ jmp(Done);
 598 
 599       __ bind(notDouble);
 600       break;
 601     }
 602 
 603   default:
 604     ShouldNotReachHere();
 605   }
 606 
 607   __ stop(&quot;bad ldc/condy&quot;);
 608 }
 609 
 610 void TemplateTable::locals_index(Register reg, int offset) {
 611   __ load_unsigned_byte(reg, at_bcp(offset));
 612   __ negptr(reg);
 613 }
 614 
 615 void TemplateTable::iload() {
 616   iload_internal();
 617 }
 618 
 619 void TemplateTable::nofast_iload() {
 620   iload_internal(may_not_rewrite);
 621 }
 622 
 623 void TemplateTable::iload_internal(RewriteControl rc) {
 624   transition(vtos, itos);
 625   if (RewriteFrequentPairs &amp;&amp; rc == may_rewrite) {
 626     Label rewrite, done;
 627     const Register bc = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
 628     LP64_ONLY(assert(rbx != bc, &quot;register damaged&quot;));
 629 
 630     // get next byte
 631     __ load_unsigned_byte(rbx,
 632                           at_bcp(Bytecodes::length_for(Bytecodes::_iload)));
 633     // if _iload, wait to rewrite to iload2.  We only want to rewrite the
 634     // last two iloads in a pair.  Comparing against fast_iload means that
 635     // the next bytecode is neither an iload or a caload, and therefore
 636     // an iload pair.
 637     __ cmpl(rbx, Bytecodes::_iload);
 638     __ jcc(Assembler::equal, done);
 639 
 640     __ cmpl(rbx, Bytecodes::_fast_iload);
 641     __ movl(bc, Bytecodes::_fast_iload2);
 642 
 643     __ jccb(Assembler::equal, rewrite);
 644 
 645     // if _caload, rewrite to fast_icaload
 646     __ cmpl(rbx, Bytecodes::_caload);
 647     __ movl(bc, Bytecodes::_fast_icaload);
 648     __ jccb(Assembler::equal, rewrite);
 649 
 650     // rewrite so iload doesn&#39;t check again.
 651     __ movl(bc, Bytecodes::_fast_iload);
 652 
 653     // rewrite
 654     // bc: fast bytecode
 655     __ bind(rewrite);
 656     patch_bytecode(Bytecodes::_iload, bc, rbx, false);
 657     __ bind(done);
 658   }
 659 
 660   // Get the local value into tos
 661   locals_index(rbx);
 662   __ movl(rax, iaddress(rbx));
 663 }
 664 
 665 void TemplateTable::fast_iload2() {
 666   transition(vtos, itos);
 667   locals_index(rbx);
 668   __ movl(rax, iaddress(rbx));
 669   __ push(itos);
 670   locals_index(rbx, 3);
 671   __ movl(rax, iaddress(rbx));
 672 }
 673 
 674 void TemplateTable::fast_iload() {
 675   transition(vtos, itos);
 676   locals_index(rbx);
 677   __ movl(rax, iaddress(rbx));
 678 }
 679 
 680 void TemplateTable::lload() {
 681   transition(vtos, ltos);
 682   locals_index(rbx);
 683   __ movptr(rax, laddress(rbx));
 684   NOT_LP64(__ movl(rdx, haddress(rbx)));
 685 }
 686 
 687 void TemplateTable::fload() {
 688   transition(vtos, ftos);
 689   locals_index(rbx);
 690   __ load_float(faddress(rbx));
 691 }
 692 
 693 void TemplateTable::dload() {
 694   transition(vtos, dtos);
 695   locals_index(rbx);
 696   __ load_double(daddress(rbx));
 697 }
 698 
 699 void TemplateTable::aload() {
 700   transition(vtos, atos);
 701   locals_index(rbx);
 702   __ movptr(rax, aaddress(rbx));
 703 }
 704 
 705 void TemplateTable::locals_index_wide(Register reg) {
 706   __ load_unsigned_short(reg, at_bcp(2));
 707   __ bswapl(reg);
 708   __ shrl(reg, 16);
 709   __ negptr(reg);
 710 }
 711 
 712 void TemplateTable::wide_iload() {
 713   transition(vtos, itos);
 714   locals_index_wide(rbx);
 715   __ movl(rax, iaddress(rbx));
 716 }
 717 
 718 void TemplateTable::wide_lload() {
 719   transition(vtos, ltos);
 720   locals_index_wide(rbx);
 721   __ movptr(rax, laddress(rbx));
 722   NOT_LP64(__ movl(rdx, haddress(rbx)));
 723 }
 724 
 725 void TemplateTable::wide_fload() {
 726   transition(vtos, ftos);
 727   locals_index_wide(rbx);
 728   __ load_float(faddress(rbx));
 729 }
 730 
 731 void TemplateTable::wide_dload() {
 732   transition(vtos, dtos);
 733   locals_index_wide(rbx);
 734   __ load_double(daddress(rbx));
 735 }
 736 
 737 void TemplateTable::wide_aload() {
 738   transition(vtos, atos);
 739   locals_index_wide(rbx);
 740   __ movptr(rax, aaddress(rbx));
 741 }
 742 
 743 void TemplateTable::index_check(Register array, Register index) {
 744   // Pop ptr into array
 745   __ pop_ptr(array);
 746   index_check_without_pop(array, index);
 747 }
 748 
 749 void TemplateTable::index_check_without_pop(Register array, Register index) {
 750   // destroys rbx
 751   // check array
 752   __ null_check(array, arrayOopDesc::length_offset_in_bytes());
 753   // sign extend index for use by indexed load
 754   __ movl2ptr(index, index);
 755   // check index
 756   __ cmpl(index, Address(array, arrayOopDesc::length_offset_in_bytes()));
 757   if (index != rbx) {
 758     // ??? convention: move aberrant index into rbx for exception message
 759     assert(rbx != array, &quot;different registers&quot;);
 760     __ movl(rbx, index);
 761   }
 762   Label skip;
 763   __ jccb(Assembler::below, skip);
 764   // Pass array to create more detailed exceptions.
 765   __ mov(NOT_LP64(rax) LP64_ONLY(c_rarg1), array);
 766   __ jump(ExternalAddress(Interpreter::_throw_ArrayIndexOutOfBoundsException_entry));
 767   __ bind(skip);
 768 }
 769 
<a name="1" id="anc1"></a><span class="line-added"> 770 #if INCLUDE_TSAN</span>
<span class="line-added"> 771 </span>
<span class="line-added"> 772 TemplateTable::TsanMemoryReleaseAcquireFunction TemplateTable::tsan_release_acquire_method(</span>
<span class="line-added"> 773     TsanMemoryReadWriteFunction tsan_function) {</span>
<span class="line-added"> 774   if (tsan_function == SharedRuntime::tsan_read1</span>
<span class="line-added"> 775       || tsan_function == SharedRuntime::tsan_read2</span>
<span class="line-added"> 776       || tsan_function == SharedRuntime::tsan_read4</span>
<span class="line-added"> 777       || tsan_function == SharedRuntime::tsan_read8) {</span>
<span class="line-added"> 778     return SharedRuntime::tsan_acquire;</span>
<span class="line-added"> 779   } else if (tsan_function == SharedRuntime::tsan_write1</span>
<span class="line-added"> 780       || tsan_function == SharedRuntime::tsan_write2</span>
<span class="line-added"> 781       || tsan_function == SharedRuntime::tsan_write4</span>
<span class="line-added"> 782       || tsan_function == SharedRuntime::tsan_write8) {</span>
<span class="line-added"> 783     return SharedRuntime::tsan_release;</span>
<span class="line-added"> 784   }</span>
<span class="line-added"> 785   ShouldNotReachHere();</span>
<span class="line-added"> 786   return NULL;</span>
<span class="line-added"> 787 }</span>
<span class="line-added"> 788 </span>
<span class="line-added"> 789 void TemplateTable::tsan_observe_get_or_put(</span>
<span class="line-added"> 790     const Address &amp;field,</span>
<span class="line-added"> 791     Register flags,</span>
<span class="line-added"> 792     TsanMemoryReadWriteFunction tsan_function,</span>
<span class="line-added"> 793     TosState tos) {</span>
<span class="line-added"> 794   assert(flags == rdx, &quot;flags should be in rdx register&quot;);</span>
<span class="line-added"> 795   assert(ThreadSanitizer, &quot;ThreadSanitizer should be set&quot;);</span>
<span class="line-added"> 796 </span>
<span class="line-added"> 797   TsanMemoryReleaseAcquireFunction releaseAcquireFunction =</span>
<span class="line-added"> 798       tsan_release_acquire_method(tsan_function);</span>
<span class="line-added"> 799 </span>
<span class="line-added"> 800   Label done, notAcquireRelease;</span>
<span class="line-added"> 801 </span>
<span class="line-added"> 802   // We could save some instructions by only saving the registers we need.</span>
<span class="line-added"> 803   __ pusha();</span>
<span class="line-added"> 804   // pusha() doesn&#39;t save xmm0, which tsan_function clobbers and the</span>
<span class="line-added"> 805   // interpreter still needs.</span>
<span class="line-added"> 806   // This really only needs to be done for some of the float/double accesses,</span>
<span class="line-added"> 807   // but it&#39;s here because it&#39;s cleaner.</span>
<span class="line-added"> 808   __ push_d(xmm0);</span>
<span class="line-added"> 809   DEBUG_ONLY(</span>
<span class="line-added"> 810     __ pusha();</span>
<span class="line-added"> 811     __ movptr(c_rarg0, field.base());</span>
<span class="line-added"> 812     __ leaq(c_rarg1, field);</span>
<span class="line-added"> 813     __ subq(c_rarg1, field.base());</span>
<span class="line-added"> 814     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::verify_oop_index),</span>
<span class="line-added"> 815                     c_rarg0 /* oop */, c_rarg1 /* index */);</span>
<span class="line-added"> 816     __ popa();</span>
<span class="line-added"> 817   );</span>
<span class="line-added"> 818   // For volatile reads/writes use an acquire/release.</span>
<span class="line-added"> 819   // If a reference is annotated to be ignored, assume it&#39;s safe to</span>
<span class="line-added"> 820   // access the object it&#39;s referring to and create a happens-before relation</span>
<span class="line-added"> 821   // between the accesses to this reference.</span>
<span class="line-added"> 822   int32_t acquire_release_mask = 1 &lt;&lt; ConstantPoolCacheEntry::is_volatile_shift |</span>
<span class="line-added"> 823       ((tos == atos) ? 1 &lt;&lt; ConstantPoolCacheEntry::is_tsan_ignore_shift : 0);</span>
<span class="line-added"> 824   __ testl(flags, acquire_release_mask);</span>
<span class="line-added"> 825   __ jcc(Assembler::zero, notAcquireRelease);</span>
<span class="line-added"> 826 </span>
<span class="line-added"> 827   __ leaq(c_rarg0, field);</span>
<span class="line-added"> 828   __ call_VM_leaf(CAST_FROM_FN_PTR(address, releaseAcquireFunction), c_rarg0);</span>
<span class="line-added"> 829   if (ThreadSanitizerJavaMemory) {</span>
<span class="line-added"> 830     __ jmp(done);</span>
<span class="line-added"> 831 </span>
<span class="line-added"> 832     __ bind(notAcquireRelease);</span>
<span class="line-added"> 833     // Ignore reads/writes to final fields. They can&#39;t be racy.</span>
<span class="line-added"> 834     int32_t ignore_mask = 1 &lt;&lt; ConstantPoolCacheEntry::is_final_shift |</span>
<span class="line-added"> 835         1 &lt;&lt; ConstantPoolCacheEntry::is_tsan_ignore_shift;</span>
<span class="line-added"> 836     __ testl(flags, ignore_mask);</span>
<span class="line-added"> 837     __ jcc(Assembler::notZero, done);</span>
<span class="line-added"> 838 </span>
<span class="line-added"> 839     __ leaq(c_rarg0, field);</span>
<span class="line-added"> 840     __ get_method(c_rarg1);</span>
<span class="line-added"> 841     __ call_VM_leaf(CAST_FROM_FN_PTR(address, tsan_function),</span>
<span class="line-added"> 842                     c_rarg0 /* addr */, c_rarg1 /* method */, rbcp /* bcp */);</span>
<span class="line-added"> 843 </span>
<span class="line-added"> 844     __ bind(done);</span>
<span class="line-added"> 845   } else {</span>
<span class="line-added"> 846     __ bind(notAcquireRelease);</span>
<span class="line-added"> 847   }</span>
<span class="line-added"> 848   __ pop_d(xmm0);</span>
<span class="line-added"> 849   __ popa();</span>
<span class="line-added"> 850 }</span>
<span class="line-added"> 851 </span>
<span class="line-added"> 852 void TemplateTable::tsan_observe_load_or_store(</span>
<span class="line-added"> 853     const Address&amp; field, TsanMemoryReadWriteFunction tsan_function) {</span>
<span class="line-added"> 854   assert(ThreadSanitizer, &quot;ThreadSanitizer should be set&quot;);</span>
<span class="line-added"> 855   if (!ThreadSanitizerJavaMemory) {</span>
<span class="line-added"> 856     return;</span>
<span class="line-added"> 857   }</span>
<span class="line-added"> 858   // We could save some instructions by only saving the registers we need.</span>
<span class="line-added"> 859   __ pusha();</span>
<span class="line-added"> 860   // pusha() doesn&#39;t save xmm0, which tsan_function clobbers and the</span>
<span class="line-added"> 861   // interpreter still needs.</span>
<span class="line-added"> 862   // This really only needs to be done for some of the float/double accesses,</span>
<span class="line-added"> 863   // but it&#39;s here because it&#39;s cleaner.</span>
<span class="line-added"> 864   __ push_d(xmm0);</span>
<span class="line-added"> 865   DEBUG_ONLY(</span>
<span class="line-added"> 866     __ pusha();</span>
<span class="line-added"> 867     __ movptr(c_rarg0, field.base());</span>
<span class="line-added"> 868     __ leaq(c_rarg1, field);</span>
<span class="line-added"> 869     __ subq(c_rarg1, field.base());</span>
<span class="line-added"> 870     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::verify_oop_index),</span>
<span class="line-added"> 871                     c_rarg0 /* oop */, c_rarg1 /* index */);</span>
<span class="line-added"> 872     __ popa();</span>
<span class="line-added"> 873   );</span>
<span class="line-added"> 874   __ leaq(c_rarg0, field);</span>
<span class="line-added"> 875   __ get_method(c_rarg1);</span>
<span class="line-added"> 876   __ call_VM_leaf(CAST_FROM_FN_PTR(address, tsan_function),</span>
<span class="line-added"> 877                   c_rarg0 /* addr */, c_rarg1 /* method */, rbcp /* bcp */);</span>
<span class="line-added"> 878   __ pop_d(xmm0);</span>
<span class="line-added"> 879   __ popa();</span>
<span class="line-added"> 880 }</span>
<span class="line-added"> 881 </span>
<span class="line-added"> 882 #endif  // INCLUDE_TSAN</span>
<span class="line-added"> 883 </span>
 884 void TemplateTable::iaload() {
 885   transition(itos, itos);
 886   // rax: index
 887   // rdx: array
 888   index_check(rdx, rax); // kills rbx
<a name="2" id="anc2"></a><span class="line-modified"> 889   Address addr(rdx, rax, Address::times_4,</span>
<span class="line-modified"> 890                arrayOopDesc::base_offset_in_bytes(T_INT));</span>
<span class="line-modified"> 891   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read4));</span>
<span class="line-modified"> 892   __ access_load_at(T_INT, IN_HEAP | IS_ARRAY, rax, addr, noreg, noreg);</span>
 893 }
 894 
 895 void TemplateTable::laload() {
 896   transition(itos, ltos);
 897   // rax: index
 898   // rdx: array
 899   index_check(rdx, rax); // kills rbx
 900   NOT_LP64(__ mov(rbx, rax));
 901   // rbx,: index
<a name="3" id="anc3"></a><span class="line-modified"> 902   Address addr(rdx, rbx, Address::times_8,</span>
<span class="line-modified"> 903                arrayOopDesc::base_offset_in_bytes(T_LONG));</span>
<span class="line-modified"> 904   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read8));</span>
<span class="line-modified"> 905   __ access_load_at(T_LONG, IN_HEAP | IS_ARRAY, noreg /* ltos */, addr, noreg,</span>
<span class="line-added"> 906                     noreg);</span>
 907 }
 908 
 909 
 910 
 911 void TemplateTable::faload() {
 912   transition(itos, ftos);
 913   // rax: index
 914   // rdx: array
 915   index_check(rdx, rax); // kills rbx
<a name="4" id="anc4"></a><span class="line-modified"> 916   Address addr(rdx, rax, Address::times_4,</span>
<span class="line-modified"> 917                arrayOopDesc::base_offset_in_bytes(T_FLOAT));</span>
<span class="line-modified"> 918   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read4));</span>
<span class="line-modified"> 919   __ access_load_at(T_FLOAT, IN_HEAP | IS_ARRAY, noreg /* ftos */, addr, noreg,</span>
<span class="line-modified"> 920                     noreg);</span>
 921 }
 922 
 923 void TemplateTable::daload() {
 924   transition(itos, dtos);
 925   // rax: index
 926   // rdx: array
 927   index_check(rdx, rax); // kills rbx
<a name="5" id="anc5"></a><span class="line-modified"> 928   Address addr(rdx, rax, Address::times_8,</span>
<span class="line-modified"> 929                arrayOopDesc::base_offset_in_bytes(T_DOUBLE));</span>
<span class="line-modified"> 930   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read8));</span>
<span class="line-modified"> 931   __ access_load_at(T_DOUBLE, IN_HEAP | IS_ARRAY, noreg /* dtos */, addr, noreg,</span>
<span class="line-modified"> 932                     noreg);</span>
 933 }
 934 
 935 void TemplateTable::aaload() {
 936   transition(itos, atos);
 937   // rax: index
 938   // rdx: array
 939   index_check(rdx, rax); // kills rbx
<a name="6" id="anc6"></a><span class="line-modified"> 940   Address addr(rdx, rax,</span>
<span class="line-modified"> 941                UseCompressedOops ? Address::times_4 : Address::times_ptr,</span>
<span class="line-modified"> 942                arrayOopDesc::base_offset_in_bytes(T_OBJECT));</span>
<span class="line-modified"> 943   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(</span>
<span class="line-modified"> 944       addr, UseCompressedOops ? SharedRuntime::tsan_read4</span>
<span class="line-modified"> 945                               : SharedRuntime::tsan_read8));</span>
<span class="line-added"> 946   do_oop_load(_masm, addr, rax, IS_ARRAY);</span>
 947 }
 948 
 949 void TemplateTable::baload() {
 950   transition(itos, itos);
 951   // rax: index
 952   // rdx: array
 953   index_check(rdx, rax); // kills rbx
<a name="7" id="anc7"></a><span class="line-modified"> 954   Address addr(rdx, rax, Address::times_1,</span>
<span class="line-modified"> 955                arrayOopDesc::base_offset_in_bytes(T_BYTE));</span>
<span class="line-modified"> 956   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read1));</span>
<span class="line-added"> 957   __ access_load_at(T_BYTE, IN_HEAP | IS_ARRAY, rax, addr, noreg, noreg);</span>
 958 }
 959 
 960 void TemplateTable::caload() {
 961   transition(itos, itos);
 962   // rax: index
 963   // rdx: array
 964   index_check(rdx, rax); // kills rbx
<a name="8" id="anc8"></a><span class="line-modified"> 965   Address addr(rdx, rax, Address::times_2,</span>
<span class="line-modified"> 966                arrayOopDesc::base_offset_in_bytes(T_CHAR));</span>
<span class="line-modified"> 967   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read2));</span>
<span class="line-added"> 968   __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, rax, addr, noreg, noreg);</span>
 969 }
 970 
 971 // iload followed by caload frequent pair
 972 void TemplateTable::fast_icaload() {
 973   transition(vtos, itos);
 974   // load index out of locals
 975   locals_index(rbx);
 976   __ movl(rax, iaddress(rbx));
 977 
 978   // rax: index
 979   // rdx: array
 980   index_check(rdx, rax); // kills rbx
 981   __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, rax,
 982                     Address(rdx, rax, Address::times_2, arrayOopDesc::base_offset_in_bytes(T_CHAR)),
 983                     noreg, noreg);
 984 }
 985 
 986 
 987 void TemplateTable::saload() {
 988   transition(itos, itos);
 989   // rax: index
 990   // rdx: array
 991   index_check(rdx, rax); // kills rbx
<a name="9" id="anc9"></a><span class="line-modified"> 992   Address addr(rdx, rax, Address::times_2,</span>
<span class="line-modified"> 993                arrayOopDesc::base_offset_in_bytes(T_SHORT));</span>
<span class="line-modified"> 994   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read2));</span>
<span class="line-added"> 995   __ access_load_at(T_SHORT, IN_HEAP | IS_ARRAY, rax, addr, noreg, noreg);</span>
 996 }
 997 
 998 void TemplateTable::iload(int n) {
 999   transition(vtos, itos);
1000   __ movl(rax, iaddress(n));
1001 }
1002 
1003 void TemplateTable::lload(int n) {
1004   transition(vtos, ltos);
1005   __ movptr(rax, laddress(n));
1006   NOT_LP64(__ movptr(rdx, haddress(n)));
1007 }
1008 
1009 void TemplateTable::fload(int n) {
1010   transition(vtos, ftos);
1011   __ load_float(faddress(n));
1012 }
1013 
1014 void TemplateTable::dload(int n) {
1015   transition(vtos, dtos);
1016   __ load_double(daddress(n));
1017 }
1018 
1019 void TemplateTable::aload(int n) {
1020   transition(vtos, atos);
1021   __ movptr(rax, aaddress(n));
1022 }
1023 
1024 void TemplateTable::aload_0() {
1025   aload_0_internal();
1026 }
1027 
1028 void TemplateTable::nofast_aload_0() {
1029   aload_0_internal(may_not_rewrite);
1030 }
1031 
1032 void TemplateTable::aload_0_internal(RewriteControl rc) {
1033   transition(vtos, atos);
1034   // According to bytecode histograms, the pairs:
1035   //
1036   // _aload_0, _fast_igetfield
1037   // _aload_0, _fast_agetfield
1038   // _aload_0, _fast_fgetfield
1039   //
1040   // occur frequently. If RewriteFrequentPairs is set, the (slow)
1041   // _aload_0 bytecode checks if the next bytecode is either
1042   // _fast_igetfield, _fast_agetfield or _fast_fgetfield and then
1043   // rewrites the current bytecode into a pair bytecode; otherwise it
1044   // rewrites the current bytecode into _fast_aload_0 that doesn&#39;t do
1045   // the pair check anymore.
1046   //
1047   // Note: If the next bytecode is _getfield, the rewrite must be
1048   //       delayed, otherwise we may miss an opportunity for a pair.
1049   //
1050   // Also rewrite frequent pairs
1051   //   aload_0, aload_1
1052   //   aload_0, iload_1
1053   // These bytecodes with a small amount of code are most profitable
1054   // to rewrite
1055   if (RewriteFrequentPairs &amp;&amp; rc == may_rewrite) {
1056     Label rewrite, done;
1057 
1058     const Register bc = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
1059     LP64_ONLY(assert(rbx != bc, &quot;register damaged&quot;));
1060 
1061     // get next byte
1062     __ load_unsigned_byte(rbx, at_bcp(Bytecodes::length_for(Bytecodes::_aload_0)));
1063 
1064     // if _getfield then wait with rewrite
1065     __ cmpl(rbx, Bytecodes::_getfield);
1066     __ jcc(Assembler::equal, done);
1067 
1068     // if _igetfield then rewrite to _fast_iaccess_0
1069     assert(Bytecodes::java_code(Bytecodes::_fast_iaccess_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
1070     __ cmpl(rbx, Bytecodes::_fast_igetfield);
1071     __ movl(bc, Bytecodes::_fast_iaccess_0);
1072     __ jccb(Assembler::equal, rewrite);
1073 
1074     // if _agetfield then rewrite to _fast_aaccess_0
1075     assert(Bytecodes::java_code(Bytecodes::_fast_aaccess_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
1076     __ cmpl(rbx, Bytecodes::_fast_agetfield);
1077     __ movl(bc, Bytecodes::_fast_aaccess_0);
1078     __ jccb(Assembler::equal, rewrite);
1079 
1080     // if _fgetfield then rewrite to _fast_faccess_0
1081     assert(Bytecodes::java_code(Bytecodes::_fast_faccess_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
1082     __ cmpl(rbx, Bytecodes::_fast_fgetfield);
1083     __ movl(bc, Bytecodes::_fast_faccess_0);
1084     __ jccb(Assembler::equal, rewrite);
1085 
1086     // else rewrite to _fast_aload0
1087     assert(Bytecodes::java_code(Bytecodes::_fast_aload_0) == Bytecodes::_aload_0, &quot;fix bytecode definition&quot;);
1088     __ movl(bc, Bytecodes::_fast_aload_0);
1089 
1090     // rewrite
1091     // bc: fast bytecode
1092     __ bind(rewrite);
1093     patch_bytecode(Bytecodes::_aload_0, bc, rbx, false);
1094 
1095     __ bind(done);
1096   }
1097 
1098   // Do actual aload_0 (must do this after patch_bytecode which might call VM and GC might change oop).
1099   aload(0);
1100 }
1101 
1102 void TemplateTable::istore() {
1103   transition(itos, vtos);
1104   locals_index(rbx);
1105   __ movl(iaddress(rbx), rax);
1106 }
1107 
1108 
1109 void TemplateTable::lstore() {
1110   transition(ltos, vtos);
1111   locals_index(rbx);
1112   __ movptr(laddress(rbx), rax);
1113   NOT_LP64(__ movptr(haddress(rbx), rdx));
1114 }
1115 
1116 void TemplateTable::fstore() {
1117   transition(ftos, vtos);
1118   locals_index(rbx);
1119   __ store_float(faddress(rbx));
1120 }
1121 
1122 void TemplateTable::dstore() {
1123   transition(dtos, vtos);
1124   locals_index(rbx);
1125   __ store_double(daddress(rbx));
1126 }
1127 
1128 void TemplateTable::astore() {
1129   transition(vtos, vtos);
1130   __ pop_ptr(rax);
1131   locals_index(rbx);
1132   __ movptr(aaddress(rbx), rax);
1133 }
1134 
1135 void TemplateTable::wide_istore() {
1136   transition(vtos, vtos);
1137   __ pop_i();
1138   locals_index_wide(rbx);
1139   __ movl(iaddress(rbx), rax);
1140 }
1141 
1142 void TemplateTable::wide_lstore() {
1143   transition(vtos, vtos);
1144   NOT_LP64(__ pop_l(rax, rdx));
1145   LP64_ONLY(__ pop_l());
1146   locals_index_wide(rbx);
1147   __ movptr(laddress(rbx), rax);
1148   NOT_LP64(__ movl(haddress(rbx), rdx));
1149 }
1150 
1151 void TemplateTable::wide_fstore() {
1152 #ifdef _LP64
1153   transition(vtos, vtos);
1154   __ pop_f(xmm0);
1155   locals_index_wide(rbx);
1156   __ movflt(faddress(rbx), xmm0);
1157 #else
1158   wide_istore();
1159 #endif
1160 }
1161 
1162 void TemplateTable::wide_dstore() {
1163 #ifdef _LP64
1164   transition(vtos, vtos);
1165   __ pop_d(xmm0);
1166   locals_index_wide(rbx);
1167   __ movdbl(daddress(rbx), xmm0);
1168 #else
1169   wide_lstore();
1170 #endif
1171 }
1172 
1173 void TemplateTable::wide_astore() {
1174   transition(vtos, vtos);
1175   __ pop_ptr(rax);
1176   locals_index_wide(rbx);
1177   __ movptr(aaddress(rbx), rax);
1178 }
1179 
1180 void TemplateTable::iastore() {
1181   transition(itos, vtos);
1182   __ pop_i(rbx);
1183   // rax: value
1184   // rbx: index
1185   // rdx: array
1186   index_check(rdx, rbx); // prefer index in rbx
<a name="10" id="anc10"></a><span class="line-modified">1187   Address addr(rdx, rbx, Address::times_4,</span>
<span class="line-modified">1188                arrayOopDesc::base_offset_in_bytes(T_INT));</span>
<span class="line-modified">1189   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write4));</span>
<span class="line-modified">1190   __ access_store_at(T_INT, IN_HEAP | IS_ARRAY, addr, rax, noreg, noreg);</span>
1191 }
1192 
1193 void TemplateTable::lastore() {
1194   transition(ltos, vtos);
1195   __ pop_i(rbx);
1196   // rax,: low(value)
1197   // rcx: array
1198   // rdx: high(value)
1199   index_check(rcx, rbx);  // prefer index in rbx,
1200   // rbx,: index
<a name="11" id="anc11"></a><span class="line-modified">1201   Address addr(rcx, rbx, Address::times_8,</span>
<span class="line-modified">1202                arrayOopDesc::base_offset_in_bytes(T_LONG));</span>
<span class="line-modified">1203   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write8));</span>
<span class="line-modified">1204   __ access_store_at(T_LONG, IN_HEAP | IS_ARRAY, addr, noreg /* ltos */, noreg,</span>
<span class="line-added">1205                      noreg);</span>
1206 }
1207 
1208 
1209 void TemplateTable::fastore() {
1210   transition(ftos, vtos);
1211   __ pop_i(rbx);
1212   // value is in UseSSE &gt;= 1 ? xmm0 : ST(0)
1213   // rbx:  index
1214   // rdx:  array
1215   index_check(rdx, rbx); // prefer index in rbx
<a name="12" id="anc12"></a><span class="line-modified">1216   Address addr(rdx, rbx, Address::times_4,</span>
<span class="line-modified">1217                arrayOopDesc::base_offset_in_bytes(T_FLOAT));</span>
<span class="line-modified">1218   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write4));</span>
<span class="line-modified">1219   __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY, addr, noreg /* ftos */, noreg,</span>
<span class="line-added">1220                      noreg);</span>
1221 }
1222 
1223 void TemplateTable::dastore() {
1224   transition(dtos, vtos);
1225   __ pop_i(rbx);
1226   // value is in UseSSE &gt;= 2 ? xmm0 : ST(0)
1227   // rbx:  index
1228   // rdx:  array
1229   index_check(rdx, rbx); // prefer index in rbx
<a name="13" id="anc13"></a><span class="line-modified">1230   Address addr(rdx, rbx, Address::times_8,</span>
<span class="line-modified">1231                arrayOopDesc::base_offset_in_bytes(T_DOUBLE));</span>
<span class="line-modified">1232   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write8));</span>
<span class="line-modified">1233   __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY, addr, noreg /* dtos */,</span>
<span class="line-added">1234                      noreg, noreg);</span>
1235 }
1236 
1237 void TemplateTable::aastore() {
1238   Label is_null, ok_is_subtype, done;
1239   transition(vtos, vtos);
1240   // stack: ..., array, index, value
1241   __ movptr(rax, at_tos());    // value
1242   __ movl(rcx, at_tos_p1()); // index
1243   __ movptr(rdx, at_tos_p2()); // array
1244 
1245   Address element_address(rdx, rcx,
1246                           UseCompressedOops? Address::times_4 : Address::times_ptr,
1247                           arrayOopDesc::base_offset_in_bytes(T_OBJECT));
1248 
<a name="14" id="anc14"></a><span class="line-added">1249   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(</span>
<span class="line-added">1250       element_address, UseCompressedOops ? SharedRuntime::tsan_write4</span>
<span class="line-added">1251                                          : SharedRuntime::tsan_write8));</span>
<span class="line-added">1252 </span>
1253   index_check_without_pop(rdx, rcx);     // kills rbx
1254   __ testptr(rax, rax);
1255   __ jcc(Assembler::zero, is_null);
1256 
1257   // Move subklass into rbx
1258   __ load_klass(rbx, rax);
1259   // Move superklass into rax
1260   __ load_klass(rax, rdx);
1261   __ movptr(rax, Address(rax,
1262                          ObjArrayKlass::element_klass_offset()));
1263 
1264   // Generate subtype check.  Blows rcx, rdi
1265   // Superklass in rax.  Subklass in rbx.
1266   __ gen_subtype_check(rbx, ok_is_subtype);
1267 
1268   // Come here on failure
1269   // object is at TOS
1270   __ jump(ExternalAddress(Interpreter::_throw_ArrayStoreException_entry));
1271 
1272   // Come here on success
1273   __ bind(ok_is_subtype);
1274 
1275   // Get the value we will store
1276   __ movptr(rax, at_tos());
1277   __ movl(rcx, at_tos_p1()); // index
1278   // Now store using the appropriate barrier
1279   do_oop_store(_masm, element_address, rax, IS_ARRAY);
1280   __ jmp(done);
1281 
1282   // Have a NULL in rax, rdx=array, ecx=index.  Store NULL at ary[idx]
1283   __ bind(is_null);
1284   __ profile_null_seen(rbx);
1285 
1286   // Store a NULL
1287   do_oop_store(_masm, element_address, noreg, IS_ARRAY);
1288 
1289   // Pop stack arguments
1290   __ bind(done);
1291   __ addptr(rsp, 3 * Interpreter::stackElementSize);
1292 }
1293 
1294 void TemplateTable::bastore() {
1295   transition(itos, vtos);
1296   __ pop_i(rbx);
1297   // rax: value
1298   // rbx: index
1299   // rdx: array
1300   index_check(rdx, rbx); // prefer index in rbx
1301   // Need to check whether array is boolean or byte
1302   // since both types share the bastore bytecode.
1303   __ load_klass(rcx, rdx);
1304   __ movl(rcx, Address(rcx, Klass::layout_helper_offset()));
1305   int diffbit = Klass::layout_helper_boolean_diffbit();
1306   __ testl(rcx, diffbit);
1307   Label L_skip;
1308   __ jccb(Assembler::zero, L_skip);
1309   __ andl(rax, 1);  // if it is a T_BOOLEAN array, mask the stored value to 0/1
1310   __ bind(L_skip);
<a name="15" id="anc15"></a><span class="line-modified">1311   Address addr(rdx, rbx, Address::times_1,</span>
<span class="line-modified">1312                arrayOopDesc::base_offset_in_bytes(T_BYTE));</span>
<span class="line-modified">1313   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write1));</span>
<span class="line-modified">1314   __ access_store_at(T_BYTE, IN_HEAP | IS_ARRAY, addr, rax, noreg, noreg);</span>
1315 }
1316 
1317 void TemplateTable::castore() {
1318   transition(itos, vtos);
1319   __ pop_i(rbx);
1320   // rax: value
1321   // rbx: index
1322   // rdx: array
1323   index_check(rdx, rbx);  // prefer index in rbx
<a name="16" id="anc16"></a><span class="line-modified">1324   Address addr(rdx, rbx, Address::times_2,</span>
<span class="line-modified">1325                arrayOopDesc::base_offset_in_bytes(T_CHAR));</span>
<span class="line-modified">1326   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write2));</span>
<span class="line-modified">1327   __ access_store_at(T_CHAR, IN_HEAP | IS_ARRAY, addr, rax, noreg, noreg);</span>
1328 }
1329 
1330 
1331 void TemplateTable::sastore() {
1332   castore();
1333 }
1334 
1335 void TemplateTable::istore(int n) {
1336   transition(itos, vtos);
1337   __ movl(iaddress(n), rax);
1338 }
1339 
1340 void TemplateTable::lstore(int n) {
1341   transition(ltos, vtos);
1342   __ movptr(laddress(n), rax);
1343   NOT_LP64(__ movptr(haddress(n), rdx));
1344 }
1345 
1346 void TemplateTable::fstore(int n) {
1347   transition(ftos, vtos);
1348   __ store_float(faddress(n));
1349 }
1350 
1351 void TemplateTable::dstore(int n) {
1352   transition(dtos, vtos);
1353   __ store_double(daddress(n));
1354 }
1355 
1356 
1357 void TemplateTable::astore(int n) {
1358   transition(vtos, vtos);
1359   __ pop_ptr(rax);
1360   __ movptr(aaddress(n), rax);
1361 }
1362 
1363 void TemplateTable::pop() {
1364   transition(vtos, vtos);
1365   __ addptr(rsp, Interpreter::stackElementSize);
1366 }
1367 
1368 void TemplateTable::pop2() {
1369   transition(vtos, vtos);
1370   __ addptr(rsp, 2 * Interpreter::stackElementSize);
1371 }
1372 
1373 
1374 void TemplateTable::dup() {
1375   transition(vtos, vtos);
1376   __ load_ptr(0, rax);
1377   __ push_ptr(rax);
1378   // stack: ..., a, a
1379 }
1380 
1381 void TemplateTable::dup_x1() {
1382   transition(vtos, vtos);
1383   // stack: ..., a, b
1384   __ load_ptr( 0, rax);  // load b
1385   __ load_ptr( 1, rcx);  // load a
1386   __ store_ptr(1, rax);  // store b
1387   __ store_ptr(0, rcx);  // store a
1388   __ push_ptr(rax);      // push b
1389   // stack: ..., b, a, b
1390 }
1391 
1392 void TemplateTable::dup_x2() {
1393   transition(vtos, vtos);
1394   // stack: ..., a, b, c
1395   __ load_ptr( 0, rax);  // load c
1396   __ load_ptr( 2, rcx);  // load a
1397   __ store_ptr(2, rax);  // store c in a
1398   __ push_ptr(rax);      // push c
1399   // stack: ..., c, b, c, c
1400   __ load_ptr( 2, rax);  // load b
1401   __ store_ptr(2, rcx);  // store a in b
1402   // stack: ..., c, a, c, c
1403   __ store_ptr(1, rax);  // store b in c
1404   // stack: ..., c, a, b, c
1405 }
1406 
1407 void TemplateTable::dup2() {
1408   transition(vtos, vtos);
1409   // stack: ..., a, b
1410   __ load_ptr(1, rax);  // load a
1411   __ push_ptr(rax);     // push a
1412   __ load_ptr(1, rax);  // load b
1413   __ push_ptr(rax);     // push b
1414   // stack: ..., a, b, a, b
1415 }
1416 
1417 
1418 void TemplateTable::dup2_x1() {
1419   transition(vtos, vtos);
1420   // stack: ..., a, b, c
1421   __ load_ptr( 0, rcx);  // load c
1422   __ load_ptr( 1, rax);  // load b
1423   __ push_ptr(rax);      // push b
1424   __ push_ptr(rcx);      // push c
1425   // stack: ..., a, b, c, b, c
1426   __ store_ptr(3, rcx);  // store c in b
1427   // stack: ..., a, c, c, b, c
1428   __ load_ptr( 4, rcx);  // load a
1429   __ store_ptr(2, rcx);  // store a in 2nd c
1430   // stack: ..., a, c, a, b, c
1431   __ store_ptr(4, rax);  // store b in a
1432   // stack: ..., b, c, a, b, c
1433 }
1434 
1435 void TemplateTable::dup2_x2() {
1436   transition(vtos, vtos);
1437   // stack: ..., a, b, c, d
1438   __ load_ptr( 0, rcx);  // load d
1439   __ load_ptr( 1, rax);  // load c
1440   __ push_ptr(rax);      // push c
1441   __ push_ptr(rcx);      // push d
1442   // stack: ..., a, b, c, d, c, d
1443   __ load_ptr( 4, rax);  // load b
1444   __ store_ptr(2, rax);  // store b in d
1445   __ store_ptr(4, rcx);  // store d in b
1446   // stack: ..., a, d, c, b, c, d
1447   __ load_ptr( 5, rcx);  // load a
1448   __ load_ptr( 3, rax);  // load c
1449   __ store_ptr(3, rcx);  // store a in c
1450   __ store_ptr(5, rax);  // store c in a
1451   // stack: ..., c, d, a, b, c, d
1452 }
1453 
1454 void TemplateTable::swap() {
1455   transition(vtos, vtos);
1456   // stack: ..., a, b
1457   __ load_ptr( 1, rcx);  // load a
1458   __ load_ptr( 0, rax);  // load b
1459   __ store_ptr(0, rcx);  // store a in b
1460   __ store_ptr(1, rax);  // store b in a
1461   // stack: ..., b, a
1462 }
1463 
1464 void TemplateTable::iop2(Operation op) {
1465   transition(itos, itos);
1466   switch (op) {
1467   case add  :                    __ pop_i(rdx); __ addl (rax, rdx); break;
1468   case sub  : __ movl(rdx, rax); __ pop_i(rax); __ subl (rax, rdx); break;
1469   case mul  :                    __ pop_i(rdx); __ imull(rax, rdx); break;
1470   case _and :                    __ pop_i(rdx); __ andl (rax, rdx); break;
1471   case _or  :                    __ pop_i(rdx); __ orl  (rax, rdx); break;
1472   case _xor :                    __ pop_i(rdx); __ xorl (rax, rdx); break;
1473   case shl  : __ movl(rcx, rax); __ pop_i(rax); __ shll (rax);      break;
1474   case shr  : __ movl(rcx, rax); __ pop_i(rax); __ sarl (rax);      break;
1475   case ushr : __ movl(rcx, rax); __ pop_i(rax); __ shrl (rax);      break;
1476   default   : ShouldNotReachHere();
1477   }
1478 }
1479 
1480 void TemplateTable::lop2(Operation op) {
1481   transition(ltos, ltos);
1482 #ifdef _LP64
1483   switch (op) {
1484   case add  :                    __ pop_l(rdx); __ addptr(rax, rdx); break;
1485   case sub  : __ mov(rdx, rax);  __ pop_l(rax); __ subptr(rax, rdx); break;
1486   case _and :                    __ pop_l(rdx); __ andptr(rax, rdx); break;
1487   case _or  :                    __ pop_l(rdx); __ orptr (rax, rdx); break;
1488   case _xor :                    __ pop_l(rdx); __ xorptr(rax, rdx); break;
1489   default   : ShouldNotReachHere();
1490   }
1491 #else
1492   __ pop_l(rbx, rcx);
1493   switch (op) {
1494     case add  : __ addl(rax, rbx); __ adcl(rdx, rcx); break;
1495     case sub  : __ subl(rbx, rax); __ sbbl(rcx, rdx);
1496                 __ mov (rax, rbx); __ mov (rdx, rcx); break;
1497     case _and : __ andl(rax, rbx); __ andl(rdx, rcx); break;
1498     case _or  : __ orl (rax, rbx); __ orl (rdx, rcx); break;
1499     case _xor : __ xorl(rax, rbx); __ xorl(rdx, rcx); break;
1500     default   : ShouldNotReachHere();
1501   }
1502 #endif
1503 }
1504 
1505 void TemplateTable::idiv() {
1506   transition(itos, itos);
1507   __ movl(rcx, rax);
1508   __ pop_i(rax);
1509   // Note: could xor rax and ecx and compare with (-1 ^ min_int). If
1510   //       they are not equal, one could do a normal division (no correction
1511   //       needed), which may speed up this implementation for the common case.
1512   //       (see also JVM spec., p.243 &amp; p.271)
1513   __ corrected_idivl(rcx);
1514 }
1515 
1516 void TemplateTable::irem() {
1517   transition(itos, itos);
1518   __ movl(rcx, rax);
1519   __ pop_i(rax);
1520   // Note: could xor rax and ecx and compare with (-1 ^ min_int). If
1521   //       they are not equal, one could do a normal division (no correction
1522   //       needed), which may speed up this implementation for the common case.
1523   //       (see also JVM spec., p.243 &amp; p.271)
1524   __ corrected_idivl(rcx);
1525   __ movl(rax, rdx);
1526 }
1527 
1528 void TemplateTable::lmul() {
1529   transition(ltos, ltos);
1530 #ifdef _LP64
1531   __ pop_l(rdx);
1532   __ imulq(rax, rdx);
1533 #else
1534   __ pop_l(rbx, rcx);
1535   __ push(rcx); __ push(rbx);
1536   __ push(rdx); __ push(rax);
1537   __ lmul(2 * wordSize, 0);
1538   __ addptr(rsp, 4 * wordSize);  // take off temporaries
1539 #endif
1540 }
1541 
1542 void TemplateTable::ldiv() {
1543   transition(ltos, ltos);
1544 #ifdef _LP64
1545   __ mov(rcx, rax);
1546   __ pop_l(rax);
1547   // generate explicit div0 check
1548   __ testq(rcx, rcx);
1549   __ jump_cc(Assembler::zero,
1550              ExternalAddress(Interpreter::_throw_ArithmeticException_entry));
1551   // Note: could xor rax and rcx and compare with (-1 ^ min_int). If
1552   //       they are not equal, one could do a normal division (no correction
1553   //       needed), which may speed up this implementation for the common case.
1554   //       (see also JVM spec., p.243 &amp; p.271)
1555   __ corrected_idivq(rcx); // kills rbx
1556 #else
1557   __ pop_l(rbx, rcx);
1558   __ push(rcx); __ push(rbx);
1559   __ push(rdx); __ push(rax);
1560   // check if y = 0
1561   __ orl(rax, rdx);
1562   __ jump_cc(Assembler::zero,
1563              ExternalAddress(Interpreter::_throw_ArithmeticException_entry));
1564   __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::ldiv));
1565   __ addptr(rsp, 4 * wordSize);  // take off temporaries
1566 #endif
1567 }
1568 
1569 void TemplateTable::lrem() {
1570   transition(ltos, ltos);
1571 #ifdef _LP64
1572   __ mov(rcx, rax);
1573   __ pop_l(rax);
1574   __ testq(rcx, rcx);
1575   __ jump_cc(Assembler::zero,
1576              ExternalAddress(Interpreter::_throw_ArithmeticException_entry));
1577   // Note: could xor rax and rcx and compare with (-1 ^ min_int). If
1578   //       they are not equal, one could do a normal division (no correction
1579   //       needed), which may speed up this implementation for the common case.
1580   //       (see also JVM spec., p.243 &amp; p.271)
1581   __ corrected_idivq(rcx); // kills rbx
1582   __ mov(rax, rdx);
1583 #else
1584   __ pop_l(rbx, rcx);
1585   __ push(rcx); __ push(rbx);
1586   __ push(rdx); __ push(rax);
1587   // check if y = 0
1588   __ orl(rax, rdx);
1589   __ jump_cc(Assembler::zero,
1590              ExternalAddress(Interpreter::_throw_ArithmeticException_entry));
1591   __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::lrem));
1592   __ addptr(rsp, 4 * wordSize);
1593 #endif
1594 }
1595 
1596 void TemplateTable::lshl() {
1597   transition(itos, ltos);
1598   __ movl(rcx, rax);                             // get shift count
1599   #ifdef _LP64
1600   __ pop_l(rax);                                 // get shift value
1601   __ shlq(rax);
1602 #else
1603   __ pop_l(rax, rdx);                            // get shift value
1604   __ lshl(rdx, rax);
1605 #endif
1606 }
1607 
1608 void TemplateTable::lshr() {
1609 #ifdef _LP64
1610   transition(itos, ltos);
1611   __ movl(rcx, rax);                             // get shift count
1612   __ pop_l(rax);                                 // get shift value
1613   __ sarq(rax);
1614 #else
1615   transition(itos, ltos);
1616   __ mov(rcx, rax);                              // get shift count
1617   __ pop_l(rax, rdx);                            // get shift value
1618   __ lshr(rdx, rax, true);
1619 #endif
1620 }
1621 
1622 void TemplateTable::lushr() {
1623   transition(itos, ltos);
1624 #ifdef _LP64
1625   __ movl(rcx, rax);                             // get shift count
1626   __ pop_l(rax);                                 // get shift value
1627   __ shrq(rax);
1628 #else
1629   __ mov(rcx, rax);                              // get shift count
1630   __ pop_l(rax, rdx);                            // get shift value
1631   __ lshr(rdx, rax);
1632 #endif
1633 }
1634 
1635 void TemplateTable::fop2(Operation op) {
1636   transition(ftos, ftos);
1637 
1638   if (UseSSE &gt;= 1) {
1639     switch (op) {
1640     case add:
1641       __ addss(xmm0, at_rsp());
1642       __ addptr(rsp, Interpreter::stackElementSize);
1643       break;
1644     case sub:
1645       __ movflt(xmm1, xmm0);
1646       __ pop_f(xmm0);
1647       __ subss(xmm0, xmm1);
1648       break;
1649     case mul:
1650       __ mulss(xmm0, at_rsp());
1651       __ addptr(rsp, Interpreter::stackElementSize);
1652       break;
1653     case div:
1654       __ movflt(xmm1, xmm0);
1655       __ pop_f(xmm0);
1656       __ divss(xmm0, xmm1);
1657       break;
1658     case rem:
1659       // On x86_64 platforms the SharedRuntime::frem method is called to perform the
1660       // modulo operation. The frem method calls the function
1661       // double fmod(double x, double y) in math.h. The documentation of fmod states:
1662       // &quot;If x or y is a NaN, a NaN is returned.&quot; without specifying what type of NaN
1663       // (signalling or quiet) is returned.
1664       //
1665       // On x86_32 platforms the FPU is used to perform the modulo operation. The
1666       // reason is that on 32-bit Windows the sign of modulo operations diverges from
1667       // what is considered the standard (e.g., -0.0f % -3.14f is 0.0f (and not -0.0f).
1668       // The fprem instruction used on x86_32 is functionally equivalent to
1669       // SharedRuntime::frem in that it returns a NaN.
1670 #ifdef _LP64
1671       __ movflt(xmm1, xmm0);
1672       __ pop_f(xmm0);
1673       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::frem), 2);
1674 #else
1675       __ push_f(xmm0);
1676       __ pop_f();
1677       __ fld_s(at_rsp());
1678       __ fremr(rax);
1679       __ f2ieee();
1680       __ pop(rax);  // pop second operand off the stack
1681       __ push_f();
1682       __ pop_f(xmm0);
1683 #endif
1684       break;
1685     default:
1686       ShouldNotReachHere();
1687       break;
1688     }
1689   } else {
1690 #ifdef _LP64
1691     ShouldNotReachHere();
1692 #else
1693     switch (op) {
1694     case add: __ fadd_s (at_rsp());                break;
1695     case sub: __ fsubr_s(at_rsp());                break;
1696     case mul: __ fmul_s (at_rsp());                break;
1697     case div: __ fdivr_s(at_rsp());                break;
1698     case rem: __ fld_s  (at_rsp()); __ fremr(rax); break;
1699     default : ShouldNotReachHere();
1700     }
1701     __ f2ieee();
1702     __ pop(rax);  // pop second operand off the stack
1703 #endif // _LP64
1704   }
1705 }
1706 
1707 void TemplateTable::dop2(Operation op) {
1708   transition(dtos, dtos);
1709   if (UseSSE &gt;= 2) {
1710     switch (op) {
1711     case add:
1712       __ addsd(xmm0, at_rsp());
1713       __ addptr(rsp, 2 * Interpreter::stackElementSize);
1714       break;
1715     case sub:
1716       __ movdbl(xmm1, xmm0);
1717       __ pop_d(xmm0);
1718       __ subsd(xmm0, xmm1);
1719       break;
1720     case mul:
1721       __ mulsd(xmm0, at_rsp());
1722       __ addptr(rsp, 2 * Interpreter::stackElementSize);
1723       break;
1724     case div:
1725       __ movdbl(xmm1, xmm0);
1726       __ pop_d(xmm0);
1727       __ divsd(xmm0, xmm1);
1728       break;
1729     case rem:
1730       // Similar to fop2(), the modulo operation is performed using the
1731       // SharedRuntime::drem method (on x86_64 platforms) or using the
1732       // FPU (on x86_32 platforms) for the same reasons as mentioned in fop2().
1733 #ifdef _LP64
1734       __ movdbl(xmm1, xmm0);
1735       __ pop_d(xmm0);
1736       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::drem), 2);
1737 #else
1738       __ push_d(xmm0);
1739       __ pop_d();
1740       __ fld_d(at_rsp());
1741       __ fremr(rax);
1742       __ d2ieee();
1743       __ pop(rax);
1744       __ pop(rdx);
1745       __ push_d();
1746       __ pop_d(xmm0);
1747 #endif
1748       break;
1749     default:
1750       ShouldNotReachHere();
1751       break;
1752     }
1753   } else {
1754 #ifdef _LP64
1755     ShouldNotReachHere();
1756 #else
1757     switch (op) {
1758     case add: __ fadd_d (at_rsp());                break;
1759     case sub: __ fsubr_d(at_rsp());                break;
1760     case mul: {
1761       Label L_strict;
1762       Label L_join;
1763       const Address access_flags      (rcx, Method::access_flags_offset());
1764       __ get_method(rcx);
1765       __ movl(rcx, access_flags);
1766       __ testl(rcx, JVM_ACC_STRICT);
1767       __ jccb(Assembler::notZero, L_strict);
1768       __ fmul_d (at_rsp());
1769       __ jmpb(L_join);
1770       __ bind(L_strict);
1771       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias1()));
1772       __ fmulp();
1773       __ fmul_d (at_rsp());
1774       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias2()));
1775       __ fmulp();
1776       __ bind(L_join);
1777       break;
1778     }
1779     case div: {
1780       Label L_strict;
1781       Label L_join;
1782       const Address access_flags      (rcx, Method::access_flags_offset());
1783       __ get_method(rcx);
1784       __ movl(rcx, access_flags);
1785       __ testl(rcx, JVM_ACC_STRICT);
1786       __ jccb(Assembler::notZero, L_strict);
1787       __ fdivr_d(at_rsp());
1788       __ jmp(L_join);
1789       __ bind(L_strict);
1790       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias1()));
1791       __ fmul_d (at_rsp());
1792       __ fdivrp();
1793       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias2()));
1794       __ fmulp();
1795       __ bind(L_join);
1796       break;
1797     }
1798     case rem: __ fld_d  (at_rsp()); __ fremr(rax); break;
1799     default : ShouldNotReachHere();
1800     }
1801     __ d2ieee();
1802     // Pop double precision number from rsp.
1803     __ pop(rax);
1804     __ pop(rdx);
1805 #endif
1806   }
1807 }
1808 
1809 void TemplateTable::ineg() {
1810   transition(itos, itos);
1811   __ negl(rax);
1812 }
1813 
1814 void TemplateTable::lneg() {
1815   transition(ltos, ltos);
1816   LP64_ONLY(__ negq(rax));
1817   NOT_LP64(__ lneg(rdx, rax));
1818 }
1819 
1820 // Note: &#39;double&#39; and &#39;long long&#39; have 32-bits alignment on x86.
1821 static jlong* double_quadword(jlong *adr, jlong lo, jlong hi) {
1822   // Use the expression (adr)&amp;(~0xF) to provide 128-bits aligned address
1823   // of 128-bits operands for SSE instructions.
1824   jlong *operand = (jlong*)(((intptr_t)adr)&amp;((intptr_t)(~0xF)));
1825   // Store the value to a 128-bits operand.
1826   operand[0] = lo;
1827   operand[1] = hi;
1828   return operand;
1829 }
1830 
1831 // Buffer for 128-bits masks used by SSE instructions.
1832 static jlong float_signflip_pool[2*2];
1833 static jlong double_signflip_pool[2*2];
1834 
1835 void TemplateTable::fneg() {
1836   transition(ftos, ftos);
1837   if (UseSSE &gt;= 1) {
1838     static jlong *float_signflip  = double_quadword(&amp;float_signflip_pool[1],  CONST64(0x8000000080000000),  CONST64(0x8000000080000000));
1839     __ xorps(xmm0, ExternalAddress((address) float_signflip));
1840   } else {
1841     LP64_ONLY(ShouldNotReachHere());
1842     NOT_LP64(__ fchs());
1843   }
1844 }
1845 
1846 void TemplateTable::dneg() {
1847   transition(dtos, dtos);
1848   if (UseSSE &gt;= 2) {
1849     static jlong *double_signflip =
1850       double_quadword(&amp;double_signflip_pool[1], CONST64(0x8000000000000000), CONST64(0x8000000000000000));
1851     __ xorpd(xmm0, ExternalAddress((address) double_signflip));
1852   } else {
1853 #ifdef _LP64
1854     ShouldNotReachHere();
1855 #else
1856     __ fchs();
1857 #endif
1858   }
1859 }
1860 
1861 void TemplateTable::iinc() {
1862   transition(vtos, vtos);
1863   __ load_signed_byte(rdx, at_bcp(2)); // get constant
1864   locals_index(rbx);
1865   __ addl(iaddress(rbx), rdx);
1866 }
1867 
1868 void TemplateTable::wide_iinc() {
1869   transition(vtos, vtos);
1870   __ movl(rdx, at_bcp(4)); // get constant
1871   locals_index_wide(rbx);
1872   __ bswapl(rdx); // swap bytes &amp; sign-extend constant
1873   __ sarl(rdx, 16);
1874   __ addl(iaddress(rbx), rdx);
1875   // Note: should probably use only one movl to get both
1876   //       the index and the constant -&gt; fix this
1877 }
1878 
1879 void TemplateTable::convert() {
1880 #ifdef _LP64
1881   // Checking
1882 #ifdef ASSERT
1883   {
1884     TosState tos_in  = ilgl;
1885     TosState tos_out = ilgl;
1886     switch (bytecode()) {
1887     case Bytecodes::_i2l: // fall through
1888     case Bytecodes::_i2f: // fall through
1889     case Bytecodes::_i2d: // fall through
1890     case Bytecodes::_i2b: // fall through
1891     case Bytecodes::_i2c: // fall through
1892     case Bytecodes::_i2s: tos_in = itos; break;
1893     case Bytecodes::_l2i: // fall through
1894     case Bytecodes::_l2f: // fall through
1895     case Bytecodes::_l2d: tos_in = ltos; break;
1896     case Bytecodes::_f2i: // fall through
1897     case Bytecodes::_f2l: // fall through
1898     case Bytecodes::_f2d: tos_in = ftos; break;
1899     case Bytecodes::_d2i: // fall through
1900     case Bytecodes::_d2l: // fall through
1901     case Bytecodes::_d2f: tos_in = dtos; break;
1902     default             : ShouldNotReachHere();
1903     }
1904     switch (bytecode()) {
1905     case Bytecodes::_l2i: // fall through
1906     case Bytecodes::_f2i: // fall through
1907     case Bytecodes::_d2i: // fall through
1908     case Bytecodes::_i2b: // fall through
1909     case Bytecodes::_i2c: // fall through
1910     case Bytecodes::_i2s: tos_out = itos; break;
1911     case Bytecodes::_i2l: // fall through
1912     case Bytecodes::_f2l: // fall through
1913     case Bytecodes::_d2l: tos_out = ltos; break;
1914     case Bytecodes::_i2f: // fall through
1915     case Bytecodes::_l2f: // fall through
1916     case Bytecodes::_d2f: tos_out = ftos; break;
1917     case Bytecodes::_i2d: // fall through
1918     case Bytecodes::_l2d: // fall through
1919     case Bytecodes::_f2d: tos_out = dtos; break;
1920     default             : ShouldNotReachHere();
1921     }
1922     transition(tos_in, tos_out);
1923   }
1924 #endif // ASSERT
1925 
1926   static const int64_t is_nan = 0x8000000000000000L;
1927 
1928   // Conversion
1929   switch (bytecode()) {
1930   case Bytecodes::_i2l:
1931     __ movslq(rax, rax);
1932     break;
1933   case Bytecodes::_i2f:
1934     __ cvtsi2ssl(xmm0, rax);
1935     break;
1936   case Bytecodes::_i2d:
1937     __ cvtsi2sdl(xmm0, rax);
1938     break;
1939   case Bytecodes::_i2b:
1940     __ movsbl(rax, rax);
1941     break;
1942   case Bytecodes::_i2c:
1943     __ movzwl(rax, rax);
1944     break;
1945   case Bytecodes::_i2s:
1946     __ movswl(rax, rax);
1947     break;
1948   case Bytecodes::_l2i:
1949     __ movl(rax, rax);
1950     break;
1951   case Bytecodes::_l2f:
1952     __ cvtsi2ssq(xmm0, rax);
1953     break;
1954   case Bytecodes::_l2d:
1955     __ cvtsi2sdq(xmm0, rax);
1956     break;
1957   case Bytecodes::_f2i:
1958   {
1959     Label L;
1960     __ cvttss2sil(rax, xmm0);
1961     __ cmpl(rax, 0x80000000); // NaN or overflow/underflow?
1962     __ jcc(Assembler::notEqual, L);
1963     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::f2i), 1);
1964     __ bind(L);
1965   }
1966     break;
1967   case Bytecodes::_f2l:
1968   {
1969     Label L;
1970     __ cvttss2siq(rax, xmm0);
1971     // NaN or overflow/underflow?
1972     __ cmp64(rax, ExternalAddress((address) &amp;is_nan));
1973     __ jcc(Assembler::notEqual, L);
1974     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::f2l), 1);
1975     __ bind(L);
1976   }
1977     break;
1978   case Bytecodes::_f2d:
1979     __ cvtss2sd(xmm0, xmm0);
1980     break;
1981   case Bytecodes::_d2i:
1982   {
1983     Label L;
1984     __ cvttsd2sil(rax, xmm0);
1985     __ cmpl(rax, 0x80000000); // NaN or overflow/underflow?
1986     __ jcc(Assembler::notEqual, L);
1987     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::d2i), 1);
1988     __ bind(L);
1989   }
1990     break;
1991   case Bytecodes::_d2l:
1992   {
1993     Label L;
1994     __ cvttsd2siq(rax, xmm0);
1995     // NaN or overflow/underflow?
1996     __ cmp64(rax, ExternalAddress((address) &amp;is_nan));
1997     __ jcc(Assembler::notEqual, L);
1998     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::d2l), 1);
1999     __ bind(L);
2000   }
2001     break;
2002   case Bytecodes::_d2f:
2003     __ cvtsd2ss(xmm0, xmm0);
2004     break;
2005   default:
2006     ShouldNotReachHere();
2007   }
2008 #else
2009   // Checking
2010 #ifdef ASSERT
2011   { TosState tos_in  = ilgl;
2012     TosState tos_out = ilgl;
2013     switch (bytecode()) {
2014       case Bytecodes::_i2l: // fall through
2015       case Bytecodes::_i2f: // fall through
2016       case Bytecodes::_i2d: // fall through
2017       case Bytecodes::_i2b: // fall through
2018       case Bytecodes::_i2c: // fall through
2019       case Bytecodes::_i2s: tos_in = itos; break;
2020       case Bytecodes::_l2i: // fall through
2021       case Bytecodes::_l2f: // fall through
2022       case Bytecodes::_l2d: tos_in = ltos; break;
2023       case Bytecodes::_f2i: // fall through
2024       case Bytecodes::_f2l: // fall through
2025       case Bytecodes::_f2d: tos_in = ftos; break;
2026       case Bytecodes::_d2i: // fall through
2027       case Bytecodes::_d2l: // fall through
2028       case Bytecodes::_d2f: tos_in = dtos; break;
2029       default             : ShouldNotReachHere();
2030     }
2031     switch (bytecode()) {
2032       case Bytecodes::_l2i: // fall through
2033       case Bytecodes::_f2i: // fall through
2034       case Bytecodes::_d2i: // fall through
2035       case Bytecodes::_i2b: // fall through
2036       case Bytecodes::_i2c: // fall through
2037       case Bytecodes::_i2s: tos_out = itos; break;
2038       case Bytecodes::_i2l: // fall through
2039       case Bytecodes::_f2l: // fall through
2040       case Bytecodes::_d2l: tos_out = ltos; break;
2041       case Bytecodes::_i2f: // fall through
2042       case Bytecodes::_l2f: // fall through
2043       case Bytecodes::_d2f: tos_out = ftos; break;
2044       case Bytecodes::_i2d: // fall through
2045       case Bytecodes::_l2d: // fall through
2046       case Bytecodes::_f2d: tos_out = dtos; break;
2047       default             : ShouldNotReachHere();
2048     }
2049     transition(tos_in, tos_out);
2050   }
2051 #endif // ASSERT
2052 
2053   // Conversion
2054   // (Note: use push(rcx)/pop(rcx) for 1/2-word stack-ptr manipulation)
2055   switch (bytecode()) {
2056     case Bytecodes::_i2l:
2057       __ extend_sign(rdx, rax);
2058       break;
2059     case Bytecodes::_i2f:
2060       if (UseSSE &gt;= 1) {
2061         __ cvtsi2ssl(xmm0, rax);
2062       } else {
2063         __ push(rax);          // store int on tos
2064         __ fild_s(at_rsp());   // load int to ST0
2065         __ f2ieee();           // truncate to float size
2066         __ pop(rcx);           // adjust rsp
2067       }
2068       break;
2069     case Bytecodes::_i2d:
2070       if (UseSSE &gt;= 2) {
2071         __ cvtsi2sdl(xmm0, rax);
2072       } else {
2073       __ push(rax);          // add one slot for d2ieee()
2074       __ push(rax);          // store int on tos
2075       __ fild_s(at_rsp());   // load int to ST0
2076       __ d2ieee();           // truncate to double size
2077       __ pop(rcx);           // adjust rsp
2078       __ pop(rcx);
2079       }
2080       break;
2081     case Bytecodes::_i2b:
2082       __ shll(rax, 24);      // truncate upper 24 bits
2083       __ sarl(rax, 24);      // and sign-extend byte
2084       LP64_ONLY(__ movsbl(rax, rax));
2085       break;
2086     case Bytecodes::_i2c:
2087       __ andl(rax, 0xFFFF);  // truncate upper 16 bits
2088       LP64_ONLY(__ movzwl(rax, rax));
2089       break;
2090     case Bytecodes::_i2s:
2091       __ shll(rax, 16);      // truncate upper 16 bits
2092       __ sarl(rax, 16);      // and sign-extend short
2093       LP64_ONLY(__ movswl(rax, rax));
2094       break;
2095     case Bytecodes::_l2i:
2096       /* nothing to do */
2097       break;
2098     case Bytecodes::_l2f:
2099       // On 64-bit platforms, the cvtsi2ssq instruction is used to convert
2100       // 64-bit long values to floats. On 32-bit platforms it is not possible
2101       // to use that instruction with 64-bit operands, therefore the FPU is
2102       // used to perform the conversion.
2103       __ push(rdx);          // store long on tos
2104       __ push(rax);
2105       __ fild_d(at_rsp());   // load long to ST0
2106       __ f2ieee();           // truncate to float size
2107       __ pop(rcx);           // adjust rsp
2108       __ pop(rcx);
2109       if (UseSSE &gt;= 1) {
2110         __ push_f();
2111         __ pop_f(xmm0);
2112       }
2113       break;
2114     case Bytecodes::_l2d:
2115       // On 32-bit platforms the FPU is used for conversion because on
2116       // 32-bit platforms it is not not possible to use the cvtsi2sdq
2117       // instruction with 64-bit operands.
2118       __ push(rdx);          // store long on tos
2119       __ push(rax);
2120       __ fild_d(at_rsp());   // load long to ST0
2121       __ d2ieee();           // truncate to double size
2122       __ pop(rcx);           // adjust rsp
2123       __ pop(rcx);
2124       if (UseSSE &gt;= 2) {
2125         __ push_d();
2126         __ pop_d(xmm0);
2127       }
2128       break;
2129     case Bytecodes::_f2i:
2130       // SharedRuntime::f2i does not differentiate between sNaNs and qNaNs
2131       // as it returns 0 for any NaN.
2132       if (UseSSE &gt;= 1) {
2133         __ push_f(xmm0);
2134       } else {
2135         __ push(rcx);          // reserve space for argument
2136         __ fstp_s(at_rsp());   // pass float argument on stack
2137       }
2138       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::f2i), 1);
2139       break;
2140     case Bytecodes::_f2l:
2141       // SharedRuntime::f2l does not differentiate between sNaNs and qNaNs
2142       // as it returns 0 for any NaN.
2143       if (UseSSE &gt;= 1) {
2144        __ push_f(xmm0);
2145       } else {
2146         __ push(rcx);          // reserve space for argument
2147         __ fstp_s(at_rsp());   // pass float argument on stack
2148       }
2149       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::f2l), 1);
2150       break;
2151     case Bytecodes::_f2d:
2152       if (UseSSE &lt; 1) {
2153         /* nothing to do */
2154       } else if (UseSSE == 1) {
2155         __ push_f(xmm0);
2156         __ pop_f();
2157       } else { // UseSSE &gt;= 2
2158         __ cvtss2sd(xmm0, xmm0);
2159       }
2160       break;
2161     case Bytecodes::_d2i:
2162       if (UseSSE &gt;= 2) {
2163         __ push_d(xmm0);
2164       } else {
2165         __ push(rcx);          // reserve space for argument
2166         __ push(rcx);
2167         __ fstp_d(at_rsp());   // pass double argument on stack
2168       }
2169       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::d2i), 2);
2170       break;
2171     case Bytecodes::_d2l:
2172       if (UseSSE &gt;= 2) {
2173         __ push_d(xmm0);
2174       } else {
2175         __ push(rcx);          // reserve space for argument
2176         __ push(rcx);
2177         __ fstp_d(at_rsp());   // pass double argument on stack
2178       }
2179       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::d2l), 2);
2180       break;
2181     case Bytecodes::_d2f:
2182       if (UseSSE &lt;= 1) {
2183         __ push(rcx);          // reserve space for f2ieee()
2184         __ f2ieee();           // truncate to float size
2185         __ pop(rcx);           // adjust rsp
2186         if (UseSSE == 1) {
2187           // The cvtsd2ss instruction is not available if UseSSE==1, therefore
2188           // the conversion is performed using the FPU in this case.
2189           __ push_f();
2190           __ pop_f(xmm0);
2191         }
2192       } else { // UseSSE &gt;= 2
2193         __ cvtsd2ss(xmm0, xmm0);
2194       }
2195       break;
2196     default             :
2197       ShouldNotReachHere();
2198   }
2199 #endif
2200 }
2201 
2202 void TemplateTable::lcmp() {
2203   transition(ltos, itos);
2204 #ifdef _LP64
2205   Label done;
2206   __ pop_l(rdx);
2207   __ cmpq(rdx, rax);
2208   __ movl(rax, -1);
2209   __ jccb(Assembler::less, done);
2210   __ setb(Assembler::notEqual, rax);
2211   __ movzbl(rax, rax);
2212   __ bind(done);
2213 #else
2214 
2215   // y = rdx:rax
2216   __ pop_l(rbx, rcx);             // get x = rcx:rbx
2217   __ lcmp2int(rcx, rbx, rdx, rax);// rcx := cmp(x, y)
2218   __ mov(rax, rcx);
2219 #endif
2220 }
2221 
2222 void TemplateTable::float_cmp(bool is_float, int unordered_result) {
2223   if ((is_float &amp;&amp; UseSSE &gt;= 1) ||
2224       (!is_float &amp;&amp; UseSSE &gt;= 2)) {
2225     Label done;
2226     if (is_float) {
2227       // XXX get rid of pop here, use ... reg, mem32
2228       __ pop_f(xmm1);
2229       __ ucomiss(xmm1, xmm0);
2230     } else {
2231       // XXX get rid of pop here, use ... reg, mem64
2232       __ pop_d(xmm1);
2233       __ ucomisd(xmm1, xmm0);
2234     }
2235     if (unordered_result &lt; 0) {
2236       __ movl(rax, -1);
2237       __ jccb(Assembler::parity, done);
2238       __ jccb(Assembler::below, done);
2239       __ setb(Assembler::notEqual, rdx);
2240       __ movzbl(rax, rdx);
2241     } else {
2242       __ movl(rax, 1);
2243       __ jccb(Assembler::parity, done);
2244       __ jccb(Assembler::above, done);
2245       __ movl(rax, 0);
2246       __ jccb(Assembler::equal, done);
2247       __ decrementl(rax);
2248     }
2249     __ bind(done);
2250   } else {
2251 #ifdef _LP64
2252     ShouldNotReachHere();
2253 #else
2254     if (is_float) {
2255       __ fld_s(at_rsp());
2256     } else {
2257       __ fld_d(at_rsp());
2258       __ pop(rdx);
2259     }
2260     __ pop(rcx);
2261     __ fcmp2int(rax, unordered_result &lt; 0);
2262 #endif // _LP64
2263   }
2264 }
2265 
2266 void TemplateTable::branch(bool is_jsr, bool is_wide) {
2267   __ get_method(rcx); // rcx holds method
2268   __ profile_taken_branch(rax, rbx); // rax holds updated MDP, rbx
2269                                      // holds bumped taken count
2270 
2271   const ByteSize be_offset = MethodCounters::backedge_counter_offset() +
2272                              InvocationCounter::counter_offset();
2273   const ByteSize inv_offset = MethodCounters::invocation_counter_offset() +
2274                               InvocationCounter::counter_offset();
2275 
2276   // Load up edx with the branch displacement
2277   if (is_wide) {
2278     __ movl(rdx, at_bcp(1));
2279   } else {
2280     __ load_signed_short(rdx, at_bcp(1));
2281   }
2282   __ bswapl(rdx);
2283 
2284   if (!is_wide) {
2285     __ sarl(rdx, 16);
2286   }
2287   LP64_ONLY(__ movl2ptr(rdx, rdx));
2288 
2289   // Handle all the JSR stuff here, then exit.
2290   // It&#39;s much shorter and cleaner than intermingling with the non-JSR
2291   // normal-branch stuff occurring below.
2292   if (is_jsr) {
2293     // Pre-load the next target bytecode into rbx
2294     __ load_unsigned_byte(rbx, Address(rbcp, rdx, Address::times_1, 0));
2295 
2296     // compute return address as bci in rax
2297     __ lea(rax, at_bcp((is_wide ? 5 : 3) -
2298                         in_bytes(ConstMethod::codes_offset())));
2299     __ subptr(rax, Address(rcx, Method::const_offset()));
2300     // Adjust the bcp in r13 by the displacement in rdx
2301     __ addptr(rbcp, rdx);
2302     // jsr returns atos that is not an oop
2303     __ push_i(rax);
2304     __ dispatch_only(vtos, true);
2305     return;
2306   }
2307 
2308   // Normal (non-jsr) branch handling
2309 
2310   // Adjust the bcp in r13 by the displacement in rdx
2311   __ addptr(rbcp, rdx);
2312 
2313   assert(UseLoopCounter || !UseOnStackReplacement,
2314          &quot;on-stack-replacement requires loop counters&quot;);
2315   Label backedge_counter_overflow;
2316   Label profile_method;
2317   Label dispatch;
2318   if (UseLoopCounter) {
2319     // increment backedge counter for backward branches
2320     // rax: MDO
2321     // rbx: MDO bumped taken-count
2322     // rcx: method
2323     // rdx: target offset
2324     // r13: target bcp
2325     // r14: locals pointer
2326     __ testl(rdx, rdx);             // check if forward or backward branch
2327     __ jcc(Assembler::positive, dispatch); // count only if backward branch
2328 
2329     // check if MethodCounters exists
2330     Label has_counters;
2331     __ movptr(rax, Address(rcx, Method::method_counters_offset()));
2332     __ testptr(rax, rax);
2333     __ jcc(Assembler::notZero, has_counters);
2334     __ push(rdx);
2335     __ push(rcx);
2336     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::build_method_counters),
2337                rcx);
2338     __ pop(rcx);
2339     __ pop(rdx);
2340     __ movptr(rax, Address(rcx, Method::method_counters_offset()));
2341     __ testptr(rax, rax);
2342     __ jcc(Assembler::zero, dispatch);
2343     __ bind(has_counters);
2344 
2345     if (TieredCompilation) {
2346       Label no_mdo;
2347       int increment = InvocationCounter::count_increment;
2348       if (ProfileInterpreter) {
2349         // Are we profiling?
2350         __ movptr(rbx, Address(rcx, in_bytes(Method::method_data_offset())));
2351         __ testptr(rbx, rbx);
2352         __ jccb(Assembler::zero, no_mdo);
2353         // Increment the MDO backedge counter
2354         const Address mdo_backedge_counter(rbx, in_bytes(MethodData::backedge_counter_offset()) +
2355                                            in_bytes(InvocationCounter::counter_offset()));
2356         const Address mask(rbx, in_bytes(MethodData::backedge_mask_offset()));
2357         __ increment_mask_and_jump(mdo_backedge_counter, increment, mask, rax, false, Assembler::zero,
2358                                    UseOnStackReplacement ? &amp;backedge_counter_overflow : NULL);
2359         __ jmp(dispatch);
2360       }
2361       __ bind(no_mdo);
2362       // Increment backedge counter in MethodCounters*
2363       __ movptr(rcx, Address(rcx, Method::method_counters_offset()));
2364       const Address mask(rcx, in_bytes(MethodCounters::backedge_mask_offset()));
2365       __ increment_mask_and_jump(Address(rcx, be_offset), increment, mask,
2366                                  rax, false, Assembler::zero,
2367                                  UseOnStackReplacement ? &amp;backedge_counter_overflow : NULL);
2368     } else { // not TieredCompilation
2369       // increment counter
2370       __ movptr(rcx, Address(rcx, Method::method_counters_offset()));
2371       __ movl(rax, Address(rcx, be_offset));        // load backedge counter
2372       __ incrementl(rax, InvocationCounter::count_increment); // increment counter
2373       __ movl(Address(rcx, be_offset), rax);        // store counter
2374 
2375       __ movl(rax, Address(rcx, inv_offset));    // load invocation counter
2376 
2377       __ andl(rax, InvocationCounter::count_mask_value); // and the status bits
2378       __ addl(rax, Address(rcx, be_offset));        // add both counters
2379 
2380       if (ProfileInterpreter) {
2381         // Test to see if we should create a method data oop
2382         __ cmp32(rax, Address(rcx, in_bytes(MethodCounters::interpreter_profile_limit_offset())));
2383         __ jcc(Assembler::less, dispatch);
2384 
2385         // if no method data exists, go to profile method
2386         __ test_method_data_pointer(rax, profile_method);
2387 
2388         if (UseOnStackReplacement) {
2389           // check for overflow against rbx which is the MDO taken count
2390           __ cmp32(rbx, Address(rcx, in_bytes(MethodCounters::interpreter_backward_branch_limit_offset())));
2391           __ jcc(Assembler::below, dispatch);
2392 
2393           // When ProfileInterpreter is on, the backedge_count comes
2394           // from the MethodData*, which value does not get reset on
2395           // the call to frequency_counter_overflow().  To avoid
2396           // excessive calls to the overflow routine while the method is
2397           // being compiled, add a second test to make sure the overflow
2398           // function is called only once every overflow_frequency.
2399           const int overflow_frequency = 1024;
2400           __ andl(rbx, overflow_frequency - 1);
2401           __ jcc(Assembler::zero, backedge_counter_overflow);
2402 
2403         }
2404       } else {
2405         if (UseOnStackReplacement) {
2406           // check for overflow against rax, which is the sum of the
2407           // counters
2408           __ cmp32(rax, Address(rcx, in_bytes(MethodCounters::interpreter_backward_branch_limit_offset())));
2409           __ jcc(Assembler::aboveEqual, backedge_counter_overflow);
2410 
2411         }
2412       }
2413     }
2414     __ bind(dispatch);
2415   }
2416 
2417   // Pre-load the next target bytecode into rbx
2418   __ load_unsigned_byte(rbx, Address(rbcp, 0));
2419 
2420   // continue with the bytecode @ target
2421   // rax: return bci for jsr&#39;s, unused otherwise
2422   // rbx: target bytecode
2423   // r13: target bcp
2424   __ dispatch_only(vtos, true);
2425 
2426   if (UseLoopCounter) {
2427     if (ProfileInterpreter) {
2428       // Out-of-line code to allocate method data oop.
2429       __ bind(profile_method);
2430       __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::profile_method));
2431       __ set_method_data_pointer_for_bcp();
2432       __ jmp(dispatch);
2433     }
2434 
2435     if (UseOnStackReplacement) {
2436       // invocation counter overflow
2437       __ bind(backedge_counter_overflow);
2438       __ negptr(rdx);
2439       __ addptr(rdx, rbcp); // branch bcp
2440       // IcoResult frequency_counter_overflow([JavaThread*], address branch_bcp)
2441       __ call_VM(noreg,
2442                  CAST_FROM_FN_PTR(address,
2443                                   InterpreterRuntime::frequency_counter_overflow),
2444                  rdx);
2445 
2446       // rax: osr nmethod (osr ok) or NULL (osr not possible)
2447       // rdx: scratch
2448       // r14: locals pointer
2449       // r13: bcp
2450       __ testptr(rax, rax);                        // test result
2451       __ jcc(Assembler::zero, dispatch);         // no osr if null
2452       // nmethod may have been invalidated (VM may block upon call_VM return)
2453       __ cmpb(Address(rax, nmethod::state_offset()), nmethod::in_use);
2454       __ jcc(Assembler::notEqual, dispatch);
2455 
2456       // We have the address of an on stack replacement routine in rax.
2457       // In preparation of invoking it, first we must migrate the locals
2458       // and monitors from off the interpreter frame on the stack.
2459       // Ensure to save the osr nmethod over the migration call,
2460       // it will be preserved in rbx.
2461       __ mov(rbx, rax);
2462 
2463       NOT_LP64(__ get_thread(rcx));
2464 
2465       call_VM(noreg, CAST_FROM_FN_PTR(address, SharedRuntime::OSR_migration_begin));
2466 
2467       // rax is OSR buffer, move it to expected parameter location
2468       LP64_ONLY(__ mov(j_rarg0, rax));
2469       NOT_LP64(__ mov(rcx, rax));
2470       // We use j_rarg definitions here so that registers don&#39;t conflict as parameter
2471       // registers change across platforms as we are in the midst of a calling
2472       // sequence to the OSR nmethod and we don&#39;t want collision. These are NOT parameters.
2473 
2474       const Register retaddr   = LP64_ONLY(j_rarg2) NOT_LP64(rdi);
2475       const Register sender_sp = LP64_ONLY(j_rarg1) NOT_LP64(rdx);
2476 
2477       // pop the interpreter frame
2478       __ movptr(sender_sp, Address(rbp, frame::interpreter_frame_sender_sp_offset * wordSize)); // get sender sp
2479       __ leave();                                // remove frame anchor
2480       __ pop(retaddr);                           // get return address
2481       __ mov(rsp, sender_sp);                   // set sp to sender sp
2482       // Ensure compiled code always sees stack at proper alignment
2483       __ andptr(rsp, -(StackAlignmentInBytes));
2484 
2485       // unlike x86 we need no specialized return from compiled code
2486       // to the interpreter or the call stub.
2487 
2488       // push the return address
2489       __ push(retaddr);
2490 
2491       // and begin the OSR nmethod
2492       __ jmp(Address(rbx, nmethod::osr_entry_point_offset()));
2493     }
2494   }
2495 }
2496 
2497 void TemplateTable::if_0cmp(Condition cc) {
2498   transition(itos, vtos);
2499   // assume branch is more often taken than not (loops use backward branches)
2500   Label not_taken;
2501   __ testl(rax, rax);
2502   __ jcc(j_not(cc), not_taken);
2503   branch(false, false);
2504   __ bind(not_taken);
2505   __ profile_not_taken_branch(rax);
2506 }
2507 
2508 void TemplateTable::if_icmp(Condition cc) {
2509   transition(itos, vtos);
2510   // assume branch is more often taken than not (loops use backward branches)
2511   Label not_taken;
2512   __ pop_i(rdx);
2513   __ cmpl(rdx, rax);
2514   __ jcc(j_not(cc), not_taken);
2515   branch(false, false);
2516   __ bind(not_taken);
2517   __ profile_not_taken_branch(rax);
2518 }
2519 
2520 void TemplateTable::if_nullcmp(Condition cc) {
2521   transition(atos, vtos);
2522   // assume branch is more often taken than not (loops use backward branches)
2523   Label not_taken;
2524   __ testptr(rax, rax);
2525   __ jcc(j_not(cc), not_taken);
2526   branch(false, false);
2527   __ bind(not_taken);
2528   __ profile_not_taken_branch(rax);
2529 }
2530 
2531 void TemplateTable::if_acmp(Condition cc) {
2532   transition(atos, vtos);
2533   // assume branch is more often taken than not (loops use backward branches)
2534   Label not_taken;
2535   __ pop_ptr(rdx);
2536   __ cmpoop(rdx, rax);
2537   __ jcc(j_not(cc), not_taken);
2538   branch(false, false);
2539   __ bind(not_taken);
2540   __ profile_not_taken_branch(rax);
2541 }
2542 
2543 void TemplateTable::ret() {
2544   transition(vtos, vtos);
2545   locals_index(rbx);
2546   LP64_ONLY(__ movslq(rbx, iaddress(rbx))); // get return bci, compute return bcp
2547   NOT_LP64(__ movptr(rbx, iaddress(rbx)));
2548   __ profile_ret(rbx, rcx);
2549   __ get_method(rax);
2550   __ movptr(rbcp, Address(rax, Method::const_offset()));
2551   __ lea(rbcp, Address(rbcp, rbx, Address::times_1,
2552                       ConstMethod::codes_offset()));
2553   __ dispatch_next(vtos, 0, true);
2554 }
2555 
2556 void TemplateTable::wide_ret() {
2557   transition(vtos, vtos);
2558   locals_index_wide(rbx);
2559   __ movptr(rbx, aaddress(rbx)); // get return bci, compute return bcp
2560   __ profile_ret(rbx, rcx);
2561   __ get_method(rax);
2562   __ movptr(rbcp, Address(rax, Method::const_offset()));
2563   __ lea(rbcp, Address(rbcp, rbx, Address::times_1, ConstMethod::codes_offset()));
2564   __ dispatch_next(vtos, 0, true);
2565 }
2566 
2567 void TemplateTable::tableswitch() {
2568   Label default_case, continue_execution;
2569   transition(itos, vtos);
2570 
2571   // align r13/rsi
2572   __ lea(rbx, at_bcp(BytesPerInt));
2573   __ andptr(rbx, -BytesPerInt);
2574   // load lo &amp; hi
2575   __ movl(rcx, Address(rbx, BytesPerInt));
2576   __ movl(rdx, Address(rbx, 2 * BytesPerInt));
2577   __ bswapl(rcx);
2578   __ bswapl(rdx);
2579   // check against lo &amp; hi
2580   __ cmpl(rax, rcx);
2581   __ jcc(Assembler::less, default_case);
2582   __ cmpl(rax, rdx);
2583   __ jcc(Assembler::greater, default_case);
2584   // lookup dispatch offset
2585   __ subl(rax, rcx);
2586   __ movl(rdx, Address(rbx, rax, Address::times_4, 3 * BytesPerInt));
2587   __ profile_switch_case(rax, rbx, rcx);
2588   // continue execution
2589   __ bind(continue_execution);
2590   __ bswapl(rdx);
2591   LP64_ONLY(__ movl2ptr(rdx, rdx));
2592   __ load_unsigned_byte(rbx, Address(rbcp, rdx, Address::times_1));
2593   __ addptr(rbcp, rdx);
2594   __ dispatch_only(vtos, true);
2595   // handle default
2596   __ bind(default_case);
2597   __ profile_switch_default(rax);
2598   __ movl(rdx, Address(rbx, 0));
2599   __ jmp(continue_execution);
2600 }
2601 
2602 void TemplateTable::lookupswitch() {
2603   transition(itos, itos);
2604   __ stop(&quot;lookupswitch bytecode should have been rewritten&quot;);
2605 }
2606 
2607 void TemplateTable::fast_linearswitch() {
2608   transition(itos, vtos);
2609   Label loop_entry, loop, found, continue_execution;
2610   // bswap rax so we can avoid bswapping the table entries
2611   __ bswapl(rax);
2612   // align r13
2613   __ lea(rbx, at_bcp(BytesPerInt)); // btw: should be able to get rid of
2614                                     // this instruction (change offsets
2615                                     // below)
2616   __ andptr(rbx, -BytesPerInt);
2617   // set counter
2618   __ movl(rcx, Address(rbx, BytesPerInt));
2619   __ bswapl(rcx);
2620   __ jmpb(loop_entry);
2621   // table search
2622   __ bind(loop);
2623   __ cmpl(rax, Address(rbx, rcx, Address::times_8, 2 * BytesPerInt));
2624   __ jcc(Assembler::equal, found);
2625   __ bind(loop_entry);
2626   __ decrementl(rcx);
2627   __ jcc(Assembler::greaterEqual, loop);
2628   // default case
2629   __ profile_switch_default(rax);
2630   __ movl(rdx, Address(rbx, 0));
2631   __ jmp(continue_execution);
2632   // entry found -&gt; get offset
2633   __ bind(found);
2634   __ movl(rdx, Address(rbx, rcx, Address::times_8, 3 * BytesPerInt));
2635   __ profile_switch_case(rcx, rax, rbx);
2636   // continue execution
2637   __ bind(continue_execution);
2638   __ bswapl(rdx);
2639   __ movl2ptr(rdx, rdx);
2640   __ load_unsigned_byte(rbx, Address(rbcp, rdx, Address::times_1));
2641   __ addptr(rbcp, rdx);
2642   __ dispatch_only(vtos, true);
2643 }
2644 
2645 void TemplateTable::fast_binaryswitch() {
2646   transition(itos, vtos);
2647   // Implementation using the following core algorithm:
2648   //
2649   // int binary_search(int key, LookupswitchPair* array, int n) {
2650   //   // Binary search according to &quot;Methodik des Programmierens&quot; by
2651   //   // Edsger W. Dijkstra and W.H.J. Feijen, Addison Wesley Germany 1985.
2652   //   int i = 0;
2653   //   int j = n;
2654   //   while (i+1 &lt; j) {
2655   //     // invariant P: 0 &lt;= i &lt; j &lt;= n and (a[i] &lt;= key &lt; a[j] or Q)
2656   //     // with      Q: for all i: 0 &lt;= i &lt; n: key &lt; a[i]
2657   //     // where a stands for the array and assuming that the (inexisting)
2658   //     // element a[n] is infinitely big.
2659   //     int h = (i + j) &gt;&gt; 1;
2660   //     // i &lt; h &lt; j
2661   //     if (key &lt; array[h].fast_match()) {
2662   //       j = h;
2663   //     } else {
2664   //       i = h;
2665   //     }
2666   //   }
2667   //   // R: a[i] &lt;= key &lt; a[i+1] or Q
2668   //   // (i.e., if key is within array, i is the correct index)
2669   //   return i;
2670   // }
2671 
2672   // Register allocation
2673   const Register key   = rax; // already set (tosca)
2674   const Register array = rbx;
2675   const Register i     = rcx;
2676   const Register j     = rdx;
2677   const Register h     = rdi;
2678   const Register temp  = rsi;
2679 
2680   // Find array start
2681   NOT_LP64(__ save_bcp());
2682 
2683   __ lea(array, at_bcp(3 * BytesPerInt)); // btw: should be able to
2684                                           // get rid of this
2685                                           // instruction (change
2686                                           // offsets below)
2687   __ andptr(array, -BytesPerInt);
2688 
2689   // Initialize i &amp; j
2690   __ xorl(i, i);                            // i = 0;
2691   __ movl(j, Address(array, -BytesPerInt)); // j = length(array);
2692 
2693   // Convert j into native byteordering
2694   __ bswapl(j);
2695 
2696   // And start
2697   Label entry;
2698   __ jmp(entry);
2699 
2700   // binary search loop
2701   {
2702     Label loop;
2703     __ bind(loop);
2704     // int h = (i + j) &gt;&gt; 1;
2705     __ leal(h, Address(i, j, Address::times_1)); // h = i + j;
2706     __ sarl(h, 1);                               // h = (i + j) &gt;&gt; 1;
2707     // if (key &lt; array[h].fast_match()) {
2708     //   j = h;
2709     // } else {
2710     //   i = h;
2711     // }
2712     // Convert array[h].match to native byte-ordering before compare
2713     __ movl(temp, Address(array, h, Address::times_8));
2714     __ bswapl(temp);
2715     __ cmpl(key, temp);
2716     // j = h if (key &lt;  array[h].fast_match())
2717     __ cmov32(Assembler::less, j, h);
2718     // i = h if (key &gt;= array[h].fast_match())
2719     __ cmov32(Assembler::greaterEqual, i, h);
2720     // while (i+1 &lt; j)
2721     __ bind(entry);
2722     __ leal(h, Address(i, 1)); // i+1
2723     __ cmpl(h, j);             // i+1 &lt; j
2724     __ jcc(Assembler::less, loop);
2725   }
2726 
2727   // end of binary search, result index is i (must check again!)
2728   Label default_case;
2729   // Convert array[i].match to native byte-ordering before compare
2730   __ movl(temp, Address(array, i, Address::times_8));
2731   __ bswapl(temp);
2732   __ cmpl(key, temp);
2733   __ jcc(Assembler::notEqual, default_case);
2734 
2735   // entry found -&gt; j = offset
2736   __ movl(j , Address(array, i, Address::times_8, BytesPerInt));
2737   __ profile_switch_case(i, key, array);
2738   __ bswapl(j);
2739   LP64_ONLY(__ movslq(j, j));
2740 
2741   NOT_LP64(__ restore_bcp());
2742   NOT_LP64(__ restore_locals());                           // restore rdi
2743 
2744   __ load_unsigned_byte(rbx, Address(rbcp, j, Address::times_1));
2745   __ addptr(rbcp, j);
2746   __ dispatch_only(vtos, true);
2747 
2748   // default case -&gt; j = default offset
2749   __ bind(default_case);
2750   __ profile_switch_default(i);
2751   __ movl(j, Address(array, -2 * BytesPerInt));
2752   __ bswapl(j);
2753   LP64_ONLY(__ movslq(j, j));
2754 
2755   NOT_LP64(__ restore_bcp());
2756   NOT_LP64(__ restore_locals());
2757 
2758   __ load_unsigned_byte(rbx, Address(rbcp, j, Address::times_1));
2759   __ addptr(rbcp, j);
2760   __ dispatch_only(vtos, true);
2761 }
2762 
2763 void TemplateTable::_return(TosState state) {
2764   transition(state, state);
2765 
2766   assert(_desc-&gt;calls_vm(),
2767          &quot;inconsistent calls_vm information&quot;); // call in remove_activation
2768 
2769   if (_desc-&gt;bytecode() == Bytecodes::_return_register_finalizer) {
2770     assert(state == vtos, &quot;only valid state&quot;);
2771     Register robj = LP64_ONLY(c_rarg1) NOT_LP64(rax);
2772     __ movptr(robj, aaddress(0));
2773     __ load_klass(rdi, robj);
2774     __ movl(rdi, Address(rdi, Klass::access_flags_offset()));
2775     __ testl(rdi, JVM_ACC_HAS_FINALIZER);
2776     Label skip_register_finalizer;
2777     __ jcc(Assembler::zero, skip_register_finalizer);
2778 
2779     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::register_finalizer), robj);
2780 
2781     __ bind(skip_register_finalizer);
2782   }
2783 
2784   if (SafepointMechanism::uses_thread_local_poll() &amp;&amp; _desc-&gt;bytecode() != Bytecodes::_return_register_finalizer) {
2785     Label no_safepoint;
2786     NOT_PRODUCT(__ block_comment(&quot;Thread-local Safepoint poll&quot;));
2787 #ifdef _LP64
2788     __ testb(Address(r15_thread, Thread::polling_page_offset()), SafepointMechanism::poll_bit());
2789 #else
2790     const Register thread = rdi;
2791     __ get_thread(thread);
2792     __ testb(Address(thread, Thread::polling_page_offset()), SafepointMechanism::poll_bit());
2793 #endif
2794     __ jcc(Assembler::zero, no_safepoint);
2795     __ push(state);
2796     __ call_VM(noreg, CAST_FROM_FN_PTR(address,
2797                                     InterpreterRuntime::at_safepoint));
2798     __ pop(state);
2799     __ bind(no_safepoint);
2800   }
2801 
2802   // Narrow result if state is itos but result type is smaller.
2803   // Need to narrow in the return bytecode rather than in generate_return_entry
2804   // since compiled code callers expect the result to already be narrowed.
2805   if (state == itos) {
2806     __ narrow(rax);
2807   }
2808   __ remove_activation(state, rbcp);
2809 
2810   __ jmp(rbcp);
2811 }
2812 
2813 // ----------------------------------------------------------------------------
2814 // Volatile variables demand their effects be made known to all CPU&#39;s
2815 // in order.  Store buffers on most chips allow reads &amp; writes to
2816 // reorder; the JMM&#39;s ReadAfterWrite.java test fails in -Xint mode
2817 // without some kind of memory barrier (i.e., it&#39;s not sufficient that
2818 // the interpreter does not reorder volatile references, the hardware
2819 // also must not reorder them).
2820 //
2821 // According to the new Java Memory Model (JMM):
2822 // (1) All volatiles are serialized wrt to each other.  ALSO reads &amp;
2823 //     writes act as aquire &amp; release, so:
2824 // (2) A read cannot let unrelated NON-volatile memory refs that
2825 //     happen after the read float up to before the read.  It&#39;s OK for
2826 //     non-volatile memory refs that happen before the volatile read to
2827 //     float down below it.
2828 // (3) Similar a volatile write cannot let unrelated NON-volatile
2829 //     memory refs that happen BEFORE the write float down to after the
2830 //     write.  It&#39;s OK for non-volatile memory refs that happen after the
2831 //     volatile write to float up before it.
2832 //
2833 // We only put in barriers around volatile refs (they are expensive),
2834 // not _between_ memory refs (that would require us to track the
2835 // flavor of the previous memory refs).  Requirements (2) and (3)
2836 // require some barriers before volatile stores and after volatile
2837 // loads.  These nearly cover requirement (1) but miss the
2838 // volatile-store-volatile-load case.  This final case is placed after
2839 // volatile-stores although it could just as well go before
2840 // volatile-loads.
2841 
2842 void TemplateTable::volatile_barrier(Assembler::Membar_mask_bits order_constraint ) {
2843   // Helper function to insert a is-volatile test and memory barrier
2844   __ membar(order_constraint);
2845 }
2846 
2847 void TemplateTable::resolve_cache_and_index(int byte_no,
2848                                             Register cache,
2849                                             Register index,
2850                                             size_t index_size) {
2851   const Register temp = rbx;
2852   assert_different_registers(cache, index, temp);
2853 
2854   Label L_clinit_barrier_slow;
2855   Label resolved;
2856 
2857   Bytecodes::Code code = bytecode();
2858   switch (code) {
2859   case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;
2860   case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;
2861   default: break;
2862   }
2863 
2864   assert(byte_no == f1_byte || byte_no == f2_byte, &quot;byte_no out of range&quot;);
2865   __ get_cache_and_index_and_bytecode_at_bcp(cache, index, temp, byte_no, 1, index_size);
2866   __ cmpl(temp, code);  // have we resolved this bytecode?
2867   __ jcc(Assembler::equal, resolved);
2868 
2869   // resolve first time through
2870   // Class initialization barrier slow path lands here as well.
2871   __ bind(L_clinit_barrier_slow);
2872   address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);
2873   __ movl(temp, code);
2874   __ call_VM(noreg, entry, temp);
2875   // Update registers with resolved info
2876   __ get_cache_and_index_at_bcp(cache, index, 1, index_size);
2877 
2878   __ bind(resolved);
2879 
2880   // Class initialization barrier for static methods
2881   if (VM_Version::supports_fast_class_init_checks() &amp;&amp; bytecode() == Bytecodes::_invokestatic) {
2882     const Register method = temp;
2883     const Register klass  = temp;
2884     const Register thread = LP64_ONLY(r15_thread) NOT_LP64(noreg);
2885     assert(thread != noreg, &quot;x86_32 not supported&quot;);
2886 
2887     __ load_resolved_method_at_index(byte_no, method, cache, index);
2888     __ load_method_holder(klass, method);
2889     __ clinit_barrier(klass, thread, NULL /*L_fast_path*/, &amp;L_clinit_barrier_slow);
2890   }
2891 }
2892 
2893 // The cache and index registers must be set before call
2894 void TemplateTable::load_field_cp_cache_entry(Register obj,
2895                                               Register cache,
2896                                               Register index,
2897                                               Register off,
2898                                               Register flags,
2899                                               bool is_static = false) {
2900   assert_different_registers(cache, index, flags, off);
2901 
2902   ByteSize cp_base_offset = ConstantPoolCache::base_offset();
2903   // Field offset
2904   __ movptr(off, Address(cache, index, Address::times_ptr,
2905                          in_bytes(cp_base_offset +
2906                                   ConstantPoolCacheEntry::f2_offset())));
2907   // Flags
2908   __ movl(flags, Address(cache, index, Address::times_ptr,
2909                          in_bytes(cp_base_offset +
2910                                   ConstantPoolCacheEntry::flags_offset())));
2911 
2912   // klass overwrite register
2913   if (is_static) {
2914     __ movptr(obj, Address(cache, index, Address::times_ptr,
2915                            in_bytes(cp_base_offset +
2916                                     ConstantPoolCacheEntry::f1_offset())));
2917     const int mirror_offset = in_bytes(Klass::java_mirror_offset());
2918     __ movptr(obj, Address(obj, mirror_offset));
2919     __ resolve_oop_handle(obj);
<a name="17" id="anc17"></a><span class="line-added">2920     TSAN_RUNTIME_ONLY(</span>
<span class="line-added">2921       // Draw a happens-before edge from the class&#39;s static initializer to</span>
<span class="line-added">2922       // this lookup.</span>
<span class="line-added">2923 </span>
<span class="line-added">2924       // java_lang_Class::_init_lock_offset may not have been initialized</span>
<span class="line-added">2925       // when generating code. It will be initialized at runtime though.</span>
<span class="line-added">2926       // So calculate its address and read from it at runtime.</span>
<span class="line-added">2927       __ pusha();</span>
<span class="line-added">2928       __ movq(c_rarg0, obj);</span>
<span class="line-added">2929       AddressLiteral init_lock_offset_address(</span>
<span class="line-added">2930           (address) java_lang_Class::init_lock_offset_addr(),</span>
<span class="line-added">2931           relocInfo::none);</span>
<span class="line-added">2932       __ lea(rax, init_lock_offset_address);</span>
<span class="line-added">2933       __ movl(rax, Address(rax, 0));</span>
<span class="line-added">2934       __ addq(c_rarg0, rax);</span>
<span class="line-added">2935       __ call_VM_leaf(CAST_FROM_FN_PTR(address,</span>
<span class="line-added">2936                                        SharedRuntime::tsan_acquire),</span>
<span class="line-added">2937                       c_rarg0);</span>
<span class="line-added">2938       __ popa();</span>
<span class="line-added">2939     );</span>
2940   }
2941 }
2942 
2943 void TemplateTable::load_invoke_cp_cache_entry(int byte_no,
2944                                                Register method,
2945                                                Register itable_index,
2946                                                Register flags,
2947                                                bool is_invokevirtual,
2948                                                bool is_invokevfinal, /*unused*/
2949                                                bool is_invokedynamic) {
2950   // setup registers
2951   const Register cache = rcx;
2952   const Register index = rdx;
2953   assert_different_registers(method, flags);
2954   assert_different_registers(method, cache, index);
2955   assert_different_registers(itable_index, flags);
2956   assert_different_registers(itable_index, cache, index);
2957   // determine constant pool cache field offsets
2958   assert(is_invokevirtual == (byte_no == f2_byte), &quot;is_invokevirtual flag redundant&quot;);
2959   const int flags_offset = in_bytes(ConstantPoolCache::base_offset() +
2960                                     ConstantPoolCacheEntry::flags_offset());
2961   // access constant pool cache fields
2962   const int index_offset = in_bytes(ConstantPoolCache::base_offset() +
2963                                     ConstantPoolCacheEntry::f2_offset());
2964 
2965   size_t index_size = (is_invokedynamic ? sizeof(u4) : sizeof(u2));
2966   resolve_cache_and_index(byte_no, cache, index, index_size);
2967   __ load_resolved_method_at_index(byte_no, method, cache, index);
2968 
2969   if (itable_index != noreg) {
2970     // pick up itable or appendix index from f2 also:
2971     __ movptr(itable_index, Address(cache, index, Address::times_ptr, index_offset));
2972   }
2973   __ movl(flags, Address(cache, index, Address::times_ptr, flags_offset));
2974 }
2975 
2976 // The registers cache and index expected to be set before call.
2977 // Correct values of the cache and index registers are preserved.
2978 void TemplateTable::jvmti_post_field_access(Register cache,
2979                                             Register index,
2980                                             bool is_static,
2981                                             bool has_tos) {
2982   if (JvmtiExport::can_post_field_access()) {
2983     // Check to see if a field access watch has been set before we take
2984     // the time to call into the VM.
2985     Label L1;
2986     assert_different_registers(cache, index, rax);
2987     __ mov32(rax, ExternalAddress((address) JvmtiExport::get_field_access_count_addr()));
2988     __ testl(rax,rax);
2989     __ jcc(Assembler::zero, L1);
2990 
2991     // cache entry pointer
2992     __ addptr(cache, in_bytes(ConstantPoolCache::base_offset()));
2993     __ shll(index, LogBytesPerWord);
2994     __ addptr(cache, index);
2995     if (is_static) {
2996       __ xorptr(rax, rax);      // NULL object reference
2997     } else {
2998       __ pop(atos);         // Get the object
2999       __ verify_oop(rax);
3000       __ push(atos);        // Restore stack state
3001     }
3002     // rax,:   object pointer or NULL
3003     // cache: cache entry pointer
3004     __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_access),
3005                rax, cache);
3006     __ get_cache_and_index_at_bcp(cache, index, 1);
3007     __ bind(L1);
3008   }
3009 }
3010 
3011 void TemplateTable::pop_and_check_object(Register r) {
3012   __ pop_ptr(r);
3013   __ null_check(r);  // for field access must check obj.
3014   __ verify_oop(r);
3015 }
3016 
3017 void TemplateTable::getfield_or_static(int byte_no, bool is_static, RewriteControl rc) {
3018   transition(vtos, vtos);
3019 
3020   const Register cache = rcx;
3021   const Register index = rdx;
3022   const Register obj   = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
3023   const Register off   = rbx;
3024   const Register flags = rax;
3025   const Register bc    = LP64_ONLY(c_rarg3) NOT_LP64(rcx); // uses same reg as obj, so don&#39;t mix them
3026 
3027   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
3028   jvmti_post_field_access(cache, index, is_static, false);
3029   load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);
3030 
3031   if (!is_static) pop_and_check_object(obj);
3032 
3033   const Address field(obj, off, Address::times_1, 0*wordSize);
3034 
<a name="18" id="anc18"></a><span class="line-added">3035   // During a TSAN instrumented run, move flags into rdx so we can later</span>
<span class="line-added">3036   // examine whether the field is volatile or has been annotated to be ignored</span>
<span class="line-added">3037   // by Tsan.</span>
<span class="line-added">3038   TSAN_RUNTIME_ONLY(__ movl(rdx, flags));</span>
<span class="line-added">3039 </span>
3040   Label Done, notByte, notBool, notInt, notShort, notChar, notLong, notFloat, notObj;
3041 
3042   __ shrl(flags, ConstantPoolCacheEntry::tos_state_shift);
3043   // Make sure we don&#39;t need to mask edx after the above shift
3044   assert(btos == 0, &quot;change code, btos != 0&quot;);
3045 
3046   __ andl(flags, ConstantPoolCacheEntry::tos_state_mask);
3047 
3048   __ jcc(Assembler::notZero, notByte);
3049   // btos
3050   __ access_load_at(T_BYTE, IN_HEAP, rax, field, noreg, noreg);
3051   __ push(btos);
<a name="19" id="anc19"></a><span class="line-added">3052   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">3053       field, rdx, SharedRuntime::tsan_read1, btos));</span>
3054   // Rewrite bytecode to be faster
3055   if (!is_static &amp;&amp; rc == may_rewrite) {
3056     patch_bytecode(Bytecodes::_fast_bgetfield, bc, rbx);
3057   }
3058   __ jmp(Done);
3059 
3060   __ bind(notByte);
3061   __ cmpl(flags, ztos);
3062   __ jcc(Assembler::notEqual, notBool);
3063 
3064   // ztos (same code as btos)
3065   __ access_load_at(T_BOOLEAN, IN_HEAP, rax, field, noreg, noreg);
3066   __ push(ztos);
<a name="20" id="anc20"></a><span class="line-added">3067   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">3068       field, rdx, SharedRuntime::tsan_read1, ztos));</span>
3069   // Rewrite bytecode to be faster
3070   if (!is_static &amp;&amp; rc == may_rewrite) {
3071     // use btos rewriting, no truncating to t/f bit is needed for getfield.
3072     patch_bytecode(Bytecodes::_fast_bgetfield, bc, rbx);
3073   }
3074   __ jmp(Done);
3075 
3076   __ bind(notBool);
3077   __ cmpl(flags, atos);
3078   __ jcc(Assembler::notEqual, notObj);
3079   // atos
3080   do_oop_load(_masm, field, rax);
3081   __ push(atos);
<a name="21" id="anc21"></a><span class="line-added">3082   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">3083       field, rdx, UseCompressedOops ? SharedRuntime::tsan_read4</span>
<span class="line-added">3084                                     : SharedRuntime::tsan_read8,</span>
<span class="line-added">3085       atos));</span>
3086   if (!is_static &amp;&amp; rc == may_rewrite) {
3087     patch_bytecode(Bytecodes::_fast_agetfield, bc, rbx);
3088   }
3089   __ jmp(Done);
3090 
3091   __ bind(notObj);
3092   __ cmpl(flags, itos);
3093   __ jcc(Assembler::notEqual, notInt);
3094   // itos
3095   __ access_load_at(T_INT, IN_HEAP, rax, field, noreg, noreg);
3096   __ push(itos);
<a name="22" id="anc22"></a><span class="line-added">3097   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">3098       field, rdx, SharedRuntime::tsan_read4, itos));</span>
3099   // Rewrite bytecode to be faster
3100   if (!is_static &amp;&amp; rc == may_rewrite) {
3101     patch_bytecode(Bytecodes::_fast_igetfield, bc, rbx);
3102   }
3103   __ jmp(Done);
3104 
3105   __ bind(notInt);
3106   __ cmpl(flags, ctos);
3107   __ jcc(Assembler::notEqual, notChar);
3108   // ctos
3109   __ access_load_at(T_CHAR, IN_HEAP, rax, field, noreg, noreg);
3110   __ push(ctos);
<a name="23" id="anc23"></a><span class="line-added">3111   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">3112       field, rdx, SharedRuntime::tsan_read2, ctos));</span>
3113   // Rewrite bytecode to be faster
3114   if (!is_static &amp;&amp; rc == may_rewrite) {
3115     patch_bytecode(Bytecodes::_fast_cgetfield, bc, rbx);
3116   }
3117   __ jmp(Done);
3118 
3119   __ bind(notChar);
3120   __ cmpl(flags, stos);
3121   __ jcc(Assembler::notEqual, notShort);
3122   // stos
3123   __ access_load_at(T_SHORT, IN_HEAP, rax, field, noreg, noreg);
3124   __ push(stos);
<a name="24" id="anc24"></a><span class="line-added">3125   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">3126       field, rdx, SharedRuntime::tsan_read2, stos));</span>
3127   // Rewrite bytecode to be faster
3128   if (!is_static &amp;&amp; rc == may_rewrite) {
3129     patch_bytecode(Bytecodes::_fast_sgetfield, bc, rbx);
3130   }
3131   __ jmp(Done);
3132 
3133   __ bind(notShort);
3134   __ cmpl(flags, ltos);
3135   __ jcc(Assembler::notEqual, notLong);
3136   // ltos
3137     // Generate code as if volatile (x86_32).  There just aren&#39;t enough registers to
3138     // save that information and this code is faster than the test.
3139   __ access_load_at(T_LONG, IN_HEAP | MO_RELAXED, noreg /* ltos */, field, noreg, noreg);
3140   __ push(ltos);
<a name="25" id="anc25"></a><span class="line-added">3141   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">3142       field, rdx, SharedRuntime::tsan_read8, ltos));</span>
3143   // Rewrite bytecode to be faster
3144   LP64_ONLY(if (!is_static &amp;&amp; rc == may_rewrite) patch_bytecode(Bytecodes::_fast_lgetfield, bc, rbx));
3145   __ jmp(Done);
3146 
3147   __ bind(notLong);
3148   __ cmpl(flags, ftos);
3149   __ jcc(Assembler::notEqual, notFloat);
3150   // ftos
3151 
3152   __ access_load_at(T_FLOAT, IN_HEAP, noreg /* ftos */, field, noreg, noreg);
3153   __ push(ftos);
<a name="26" id="anc26"></a><span class="line-added">3154   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">3155       field, rdx, SharedRuntime::tsan_read4, ftos));</span>
3156   // Rewrite bytecode to be faster
3157   if (!is_static &amp;&amp; rc == may_rewrite) {
3158     patch_bytecode(Bytecodes::_fast_fgetfield, bc, rbx);
3159   }
3160   __ jmp(Done);
3161 
3162   __ bind(notFloat);
3163 #ifdef ASSERT
3164   Label notDouble;
3165   __ cmpl(flags, dtos);
3166   __ jcc(Assembler::notEqual, notDouble);
3167 #endif
3168   // dtos
3169   // MO_RELAXED: for the case of volatile field, in fact it adds no extra work for the underlying implementation
3170   __ access_load_at(T_DOUBLE, IN_HEAP | MO_RELAXED, noreg /* dtos */, field, noreg, noreg);
3171   __ push(dtos);
<a name="27" id="anc27"></a><span class="line-added">3172   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">3173       field, rdx, SharedRuntime::tsan_read8, dtos));</span>
3174   // Rewrite bytecode to be faster
3175   if (!is_static &amp;&amp; rc == may_rewrite) {
3176     patch_bytecode(Bytecodes::_fast_dgetfield, bc, rbx);
3177   }
3178 #ifdef ASSERT
3179   __ jmp(Done);
3180 
3181   __ bind(notDouble);
3182   __ stop(&quot;Bad state&quot;);
3183 #endif
3184 
3185   __ bind(Done);
3186   // [jk] not needed currently
3187   // volatile_barrier(Assembler::Membar_mask_bits(Assembler::LoadLoad |
3188   //                                              Assembler::LoadStore));
3189 }
3190 
3191 void TemplateTable::getfield(int byte_no) {
3192   getfield_or_static(byte_no, false);
3193 }
3194 
3195 void TemplateTable::nofast_getfield(int byte_no) {
3196   getfield_or_static(byte_no, false, may_not_rewrite);
3197 }
3198 
3199 void TemplateTable::getstatic(int byte_no) {
3200   getfield_or_static(byte_no, true);
3201 }
3202 
3203 
3204 // The registers cache and index expected to be set before call.
3205 // The function may destroy various registers, just not the cache and index registers.
3206 void TemplateTable::jvmti_post_field_mod(Register cache, Register index, bool is_static) {
3207 
3208   const Register robj = LP64_ONLY(c_rarg2)   NOT_LP64(rax);
3209   const Register RBX  = LP64_ONLY(c_rarg1)   NOT_LP64(rbx);
3210   const Register RCX  = LP64_ONLY(c_rarg3)   NOT_LP64(rcx);
3211   const Register RDX  = LP64_ONLY(rscratch1) NOT_LP64(rdx);
3212 
3213   ByteSize cp_base_offset = ConstantPoolCache::base_offset();
3214 
3215   if (JvmtiExport::can_post_field_modification()) {
3216     // Check to see if a field modification watch has been set before
3217     // we take the time to call into the VM.
3218     Label L1;
3219     assert_different_registers(cache, index, rax);
3220     __ mov32(rax, ExternalAddress((address)JvmtiExport::get_field_modification_count_addr()));
3221     __ testl(rax, rax);
3222     __ jcc(Assembler::zero, L1);
3223 
3224     __ get_cache_and_index_at_bcp(robj, RDX, 1);
3225 
3226 
3227     if (is_static) {
3228       // Life is simple.  Null out the object pointer.
3229       __ xorl(RBX, RBX);
3230 
3231     } else {
3232       // Life is harder. The stack holds the value on top, followed by
3233       // the object.  We don&#39;t know the size of the value, though; it
3234       // could be one or two words depending on its type. As a result,
3235       // we must find the type to determine where the object is.
3236 #ifndef _LP64
3237       Label two_word, valsize_known;
3238 #endif
3239       __ movl(RCX, Address(robj, RDX,
3240                            Address::times_ptr,
3241                            in_bytes(cp_base_offset +
3242                                      ConstantPoolCacheEntry::flags_offset())));
3243       NOT_LP64(__ mov(rbx, rsp));
3244       __ shrl(RCX, ConstantPoolCacheEntry::tos_state_shift);
3245 
3246       // Make sure we don&#39;t need to mask rcx after the above shift
3247       ConstantPoolCacheEntry::verify_tos_state_shift();
3248 #ifdef _LP64
3249       __ movptr(c_rarg1, at_tos_p1());  // initially assume a one word jvalue
3250       __ cmpl(c_rarg3, ltos);
3251       __ cmovptr(Assembler::equal,
3252                  c_rarg1, at_tos_p2()); // ltos (two word jvalue)
3253       __ cmpl(c_rarg3, dtos);
3254       __ cmovptr(Assembler::equal,
3255                  c_rarg1, at_tos_p2()); // dtos (two word jvalue)
3256 #else
3257       __ cmpl(rcx, ltos);
3258       __ jccb(Assembler::equal, two_word);
3259       __ cmpl(rcx, dtos);
3260       __ jccb(Assembler::equal, two_word);
3261       __ addptr(rbx, Interpreter::expr_offset_in_bytes(1)); // one word jvalue (not ltos, dtos)
3262       __ jmpb(valsize_known);
3263 
3264       __ bind(two_word);
3265       __ addptr(rbx, Interpreter::expr_offset_in_bytes(2)); // two words jvalue
3266 
3267       __ bind(valsize_known);
3268       // setup object pointer
3269       __ movptr(rbx, Address(rbx, 0));
3270 #endif
3271     }
3272     // cache entry pointer
3273     __ addptr(robj, in_bytes(cp_base_offset));
3274     __ shll(RDX, LogBytesPerWord);
3275     __ addptr(robj, RDX);
3276     // object (tos)
3277     __ mov(RCX, rsp);
3278     // c_rarg1: object pointer set up above (NULL if static)
3279     // c_rarg2: cache entry pointer
3280     // c_rarg3: jvalue object on the stack
3281     __ call_VM(noreg,
3282                CAST_FROM_FN_PTR(address,
3283                                 InterpreterRuntime::post_field_modification),
3284                RBX, robj, RCX);
3285     __ get_cache_and_index_at_bcp(cache, index, 1);
3286     __ bind(L1);
3287   }
3288 }
3289 
3290 void TemplateTable::putfield_or_static(int byte_no, bool is_static, RewriteControl rc) {
3291   transition(vtos, vtos);
3292 
3293   const Register cache = rcx;
3294   const Register index = rdx;
3295   const Register obj   = rcx;
3296   const Register off   = rbx;
3297   const Register flags = rax;
3298 
3299   resolve_cache_and_index(byte_no, cache, index, sizeof(u2));
3300   jvmti_post_field_mod(cache, index, is_static);
3301   load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);
3302 
3303   // [jk] not needed currently
3304   // volatile_barrier(Assembler::Membar_mask_bits(Assembler::LoadStore |
3305   //                                              Assembler::StoreStore));
3306 
3307   Label notVolatile, Done;
3308   __ movl(rdx, flags);
<a name="28" id="anc28"></a>

3309 
3310   // Check for volatile store
3311   __ testl(rdx, rdx);
3312   __ jcc(Assembler::zero, notVolatile);
3313 
3314   putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags);
3315   volatile_barrier(Assembler::Membar_mask_bits(Assembler::StoreLoad |
3316                                                Assembler::StoreStore));
3317   __ jmp(Done);
3318   __ bind(notVolatile);
3319 
3320   putfield_or_static_helper(byte_no, is_static, rc, obj, off, flags);
3321 
3322   __ bind(Done);
3323 }
3324 
3325 void TemplateTable::putfield_or_static_helper(int byte_no, bool is_static, RewriteControl rc,
3326                                               Register obj, Register off, Register flags) {
3327 
3328   // field addresses
3329   const Address field(obj, off, Address::times_1, 0*wordSize);
3330   NOT_LP64( const Address hi(obj, off, Address::times_1, 1*wordSize);)
3331 
3332   Label notByte, notBool, notInt, notShort, notChar,
3333         notLong, notFloat, notObj;
3334   Label Done;
3335 
3336   const Register bc    = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
3337 
3338   __ shrl(flags, ConstantPoolCacheEntry::tos_state_shift);
3339 
3340   assert(btos == 0, &quot;change code, btos != 0&quot;);
3341   __ andl(flags, ConstantPoolCacheEntry::tos_state_mask);
3342   __ jcc(Assembler::notZero, notByte);
3343 
3344   // btos
3345   {
3346     __ pop(btos);
3347     if (!is_static) pop_and_check_object(obj);
<a name="29" id="anc29"></a><span class="line-added">3348     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">3349         field, rdx, SharedRuntime::tsan_write1, btos));</span>
3350     __ access_store_at(T_BYTE, IN_HEAP, field, rax, noreg, noreg);
3351     if (!is_static &amp;&amp; rc == may_rewrite) {
3352       patch_bytecode(Bytecodes::_fast_bputfield, bc, rbx, true, byte_no);
3353     }
3354     __ jmp(Done);
3355   }
3356 
3357   __ bind(notByte);
3358   __ cmpl(flags, ztos);
3359   __ jcc(Assembler::notEqual, notBool);
3360 
3361   // ztos
3362   {
3363     __ pop(ztos);
3364     if (!is_static) pop_and_check_object(obj);
<a name="30" id="anc30"></a><span class="line-added">3365     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">3366         field, rdx, SharedRuntime::tsan_write1, ztos));</span>
3367     __ access_store_at(T_BOOLEAN, IN_HEAP, field, rax, noreg, noreg);
3368     if (!is_static &amp;&amp; rc == may_rewrite) {
3369       patch_bytecode(Bytecodes::_fast_zputfield, bc, rbx, true, byte_no);
3370     }
3371     __ jmp(Done);
3372   }
3373 
3374   __ bind(notBool);
3375   __ cmpl(flags, atos);
3376   __ jcc(Assembler::notEqual, notObj);
3377 
3378   // atos
3379   {
3380     __ pop(atos);
3381     if (!is_static) pop_and_check_object(obj);
<a name="31" id="anc31"></a><span class="line-added">3382     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, rdx,</span>
<span class="line-added">3383         UseCompressedOops ? SharedRuntime::tsan_write4</span>
<span class="line-added">3384                           : SharedRuntime::tsan_write8,</span>
<span class="line-added">3385         atos));</span>
3386     // Store into the field
3387     do_oop_store(_masm, field, rax);
3388     if (!is_static &amp;&amp; rc == may_rewrite) {
3389       patch_bytecode(Bytecodes::_fast_aputfield, bc, rbx, true, byte_no);
3390     }
3391     __ jmp(Done);
3392   }
3393 
3394   __ bind(notObj);
3395   __ cmpl(flags, itos);
3396   __ jcc(Assembler::notEqual, notInt);
3397 
3398   // itos
3399   {
3400     __ pop(itos);
3401     if (!is_static) pop_and_check_object(obj);
<a name="32" id="anc32"></a><span class="line-added">3402     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">3403         field, rdx, SharedRuntime::tsan_write4, itos));</span>
3404     __ access_store_at(T_INT, IN_HEAP, field, rax, noreg, noreg);
3405     if (!is_static &amp;&amp; rc == may_rewrite) {
3406       patch_bytecode(Bytecodes::_fast_iputfield, bc, rbx, true, byte_no);
3407     }
3408     __ jmp(Done);
3409   }
3410 
3411   __ bind(notInt);
3412   __ cmpl(flags, ctos);
3413   __ jcc(Assembler::notEqual, notChar);
3414 
3415   // ctos
3416   {
3417     __ pop(ctos);
3418     if (!is_static) pop_and_check_object(obj);
<a name="33" id="anc33"></a><span class="line-added">3419     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">3420         field, rdx, SharedRuntime::tsan_write2, ctos));</span>
3421     __ access_store_at(T_CHAR, IN_HEAP, field, rax, noreg, noreg);
3422     if (!is_static &amp;&amp; rc == may_rewrite) {
3423       patch_bytecode(Bytecodes::_fast_cputfield, bc, rbx, true, byte_no);
3424     }
3425     __ jmp(Done);
3426   }
3427 
3428   __ bind(notChar);
3429   __ cmpl(flags, stos);
3430   __ jcc(Assembler::notEqual, notShort);
3431 
3432   // stos
3433   {
3434     __ pop(stos);
3435     if (!is_static) pop_and_check_object(obj);
<a name="34" id="anc34"></a><span class="line-added">3436     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">3437         field, rdx, SharedRuntime::tsan_write2, stos));</span>
3438     __ access_store_at(T_SHORT, IN_HEAP, field, rax, noreg, noreg);
3439     if (!is_static &amp;&amp; rc == may_rewrite) {
3440       patch_bytecode(Bytecodes::_fast_sputfield, bc, rbx, true, byte_no);
3441     }
3442     __ jmp(Done);
3443   }
3444 
3445   __ bind(notShort);
3446   __ cmpl(flags, ltos);
3447   __ jcc(Assembler::notEqual, notLong);
3448 
3449   // ltos
3450   {
3451     __ pop(ltos);
3452     if (!is_static) pop_and_check_object(obj);
<a name="35" id="anc35"></a><span class="line-added">3453     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">3454         field, rdx, SharedRuntime::tsan_write8, ltos));</span>
3455     // MO_RELAXED: generate atomic store for the case of volatile field (important for x86_32)
3456     __ access_store_at(T_LONG, IN_HEAP | MO_RELAXED, field, noreg /* ltos*/, noreg, noreg);
3457 #ifdef _LP64
3458     if (!is_static &amp;&amp; rc == may_rewrite) {
3459       patch_bytecode(Bytecodes::_fast_lputfield, bc, rbx, true, byte_no);
3460     }
3461 #endif // _LP64
3462     __ jmp(Done);
3463   }
3464 
3465   __ bind(notLong);
3466   __ cmpl(flags, ftos);
3467   __ jcc(Assembler::notEqual, notFloat);
3468 
3469   // ftos
3470   {
3471     __ pop(ftos);
3472     if (!is_static) pop_and_check_object(obj);
<a name="36" id="anc36"></a><span class="line-added">3473     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">3474         field, rdx, SharedRuntime::tsan_write4, ftos));</span>
3475     __ access_store_at(T_FLOAT, IN_HEAP, field, noreg /* ftos */, noreg, noreg);
3476     if (!is_static &amp;&amp; rc == may_rewrite) {
3477       patch_bytecode(Bytecodes::_fast_fputfield, bc, rbx, true, byte_no);
3478     }
3479     __ jmp(Done);
3480   }
3481 
3482   __ bind(notFloat);
3483 #ifdef ASSERT
3484   Label notDouble;
3485   __ cmpl(flags, dtos);
3486   __ jcc(Assembler::notEqual, notDouble);
3487 #endif
3488 
3489   // dtos
3490   {
3491     __ pop(dtos);
3492     if (!is_static) pop_and_check_object(obj);
<a name="37" id="anc37"></a><span class="line-added">3493     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">3494         field, rdx, SharedRuntime::tsan_write8, dtos));</span>
3495     // MO_RELAXED: for the case of volatile field, in fact it adds no extra work for the underlying implementation
3496     __ access_store_at(T_DOUBLE, IN_HEAP | MO_RELAXED, field, noreg /* dtos */, noreg, noreg);
3497     if (!is_static &amp;&amp; rc == may_rewrite) {
3498       patch_bytecode(Bytecodes::_fast_dputfield, bc, rbx, true, byte_no);
3499     }
3500   }
3501 
3502 #ifdef ASSERT
3503   __ jmp(Done);
3504 
3505   __ bind(notDouble);
3506   __ stop(&quot;Bad state&quot;);
3507 #endif
3508 
3509   __ bind(Done);
3510 }
3511 
3512 void TemplateTable::putfield(int byte_no) {
3513   putfield_or_static(byte_no, false);
3514 }
3515 
3516 void TemplateTable::nofast_putfield(int byte_no) {
3517   putfield_or_static(byte_no, false, may_not_rewrite);
3518 }
3519 
3520 void TemplateTable::putstatic(int byte_no) {
3521   putfield_or_static(byte_no, true);
3522 }
3523 
3524 void TemplateTable::jvmti_post_fast_field_mod() {
3525 
3526   const Register scratch = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
3527 
3528   if (JvmtiExport::can_post_field_modification()) {
3529     // Check to see if a field modification watch has been set before
3530     // we take the time to call into the VM.
3531     Label L2;
3532     __ mov32(scratch, ExternalAddress((address)JvmtiExport::get_field_modification_count_addr()));
3533     __ testl(scratch, scratch);
3534     __ jcc(Assembler::zero, L2);
3535     __ pop_ptr(rbx);                  // copy the object pointer from tos
3536     __ verify_oop(rbx);
3537     __ push_ptr(rbx);                 // put the object pointer back on tos
3538     // Save tos values before call_VM() clobbers them. Since we have
3539     // to do it for every data type, we use the saved values as the
3540     // jvalue object.
3541     switch (bytecode()) {          // load values into the jvalue object
3542     case Bytecodes::_fast_aputfield: __ push_ptr(rax); break;
3543     case Bytecodes::_fast_bputfield: // fall through
3544     case Bytecodes::_fast_zputfield: // fall through
3545     case Bytecodes::_fast_sputfield: // fall through
3546     case Bytecodes::_fast_cputfield: // fall through
3547     case Bytecodes::_fast_iputfield: __ push_i(rax); break;
3548     case Bytecodes::_fast_dputfield: __ push(dtos); break;
3549     case Bytecodes::_fast_fputfield: __ push(ftos); break;
3550     case Bytecodes::_fast_lputfield: __ push_l(rax); break;
3551 
3552     default:
3553       ShouldNotReachHere();
3554     }
3555     __ mov(scratch, rsp);             // points to jvalue on the stack
3556     // access constant pool cache entry
3557     LP64_ONLY(__ get_cache_entry_pointer_at_bcp(c_rarg2, rax, 1));
3558     NOT_LP64(__ get_cache_entry_pointer_at_bcp(rax, rdx, 1));
3559     __ verify_oop(rbx);
3560     // rbx: object pointer copied above
3561     // c_rarg2: cache entry pointer
3562     // c_rarg3: jvalue object on the stack
3563     LP64_ONLY(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_modification), rbx, c_rarg2, c_rarg3));
3564     NOT_LP64(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_modification), rbx, rax, rcx));
3565 
3566     switch (bytecode()) {             // restore tos values
3567     case Bytecodes::_fast_aputfield: __ pop_ptr(rax); break;
3568     case Bytecodes::_fast_bputfield: // fall through
3569     case Bytecodes::_fast_zputfield: // fall through
3570     case Bytecodes::_fast_sputfield: // fall through
3571     case Bytecodes::_fast_cputfield: // fall through
3572     case Bytecodes::_fast_iputfield: __ pop_i(rax); break;
3573     case Bytecodes::_fast_dputfield: __ pop(dtos); break;
3574     case Bytecodes::_fast_fputfield: __ pop(ftos); break;
3575     case Bytecodes::_fast_lputfield: __ pop_l(rax); break;
3576     default: break;
3577     }
3578     __ bind(L2);
3579   }
3580 }
3581 
3582 void TemplateTable::fast_storefield(TosState state) {
3583   transition(state, vtos);
3584 
3585   ByteSize base = ConstantPoolCache::base_offset();
3586 
3587   jvmti_post_fast_field_mod();
3588 
3589   // access constant pool cache
3590   __ get_cache_and_index_at_bcp(rcx, rbx, 1);
3591 
3592   // test for volatile with rdx but rdx is tos register for lputfield.
3593   __ movl(rdx, Address(rcx, rbx, Address::times_ptr,
3594                        in_bytes(base +
3595                                 ConstantPoolCacheEntry::flags_offset())));
3596 
3597   // replace index with field offset from cache entry
3598   __ movptr(rbx, Address(rcx, rbx, Address::times_ptr,
3599                          in_bytes(base + ConstantPoolCacheEntry::f2_offset())));
3600 
3601   // [jk] not needed currently
3602   // volatile_barrier(Assembler::Membar_mask_bits(Assembler::LoadStore |
3603   //                                              Assembler::StoreStore));
3604 
3605   Label notVolatile, Done;
3606   __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);
3607   __ andl(rdx, 0x1);
3608 
3609   // Get object from stack
3610   pop_and_check_object(rcx);
3611 
3612   // field address
3613   const Address field(rcx, rbx, Address::times_1);
3614 
3615   // Check for volatile store
3616   __ testl(rdx, rdx);
3617   __ jcc(Assembler::zero, notVolatile);
3618 
3619   fast_storefield_helper(field, rax);
3620   volatile_barrier(Assembler::Membar_mask_bits(Assembler::StoreLoad |
3621                                                Assembler::StoreStore));
3622   __ jmp(Done);
3623   __ bind(notVolatile);
3624 
3625   fast_storefield_helper(field, rax);
3626 
3627   __ bind(Done);
3628 }
3629 
3630 void TemplateTable::fast_storefield_helper(Address field, Register rax) {
3631 
3632   // access field
3633   switch (bytecode()) {
3634   case Bytecodes::_fast_aputfield:
3635     do_oop_store(_masm, field, rax);
3636     break;
3637   case Bytecodes::_fast_lputfield:
3638 #ifdef _LP64
3639     __ access_store_at(T_LONG, IN_HEAP, field, noreg /* ltos */, noreg, noreg);
3640 #else
3641   __ stop(&quot;should not be rewritten&quot;);
3642 #endif
3643     break;
3644   case Bytecodes::_fast_iputfield:
3645     __ access_store_at(T_INT, IN_HEAP, field, rax, noreg, noreg);
3646     break;
3647   case Bytecodes::_fast_zputfield:
3648     __ access_store_at(T_BOOLEAN, IN_HEAP, field, rax, noreg, noreg);
3649     break;
3650   case Bytecodes::_fast_bputfield:
3651     __ access_store_at(T_BYTE, IN_HEAP, field, rax, noreg, noreg);
3652     break;
3653   case Bytecodes::_fast_sputfield:
3654     __ access_store_at(T_SHORT, IN_HEAP, field, rax, noreg, noreg);
3655     break;
3656   case Bytecodes::_fast_cputfield:
3657     __ access_store_at(T_CHAR, IN_HEAP, field, rax, noreg, noreg);
3658     break;
3659   case Bytecodes::_fast_fputfield:
3660     __ access_store_at(T_FLOAT, IN_HEAP, field, noreg /* ftos*/, noreg, noreg);
3661     break;
3662   case Bytecodes::_fast_dputfield:
3663     __ access_store_at(T_DOUBLE, IN_HEAP, field, noreg /* dtos*/, noreg, noreg);
3664     break;
3665   default:
3666     ShouldNotReachHere();
3667   }
3668 }
3669 
3670 void TemplateTable::fast_accessfield(TosState state) {
3671   transition(atos, state);
3672 
3673   // Do the JVMTI work here to avoid disturbing the register state below
3674   if (JvmtiExport::can_post_field_access()) {
3675     // Check to see if a field access watch has been set before we
3676     // take the time to call into the VM.
3677     Label L1;
3678     __ mov32(rcx, ExternalAddress((address) JvmtiExport::get_field_access_count_addr()));
3679     __ testl(rcx, rcx);
3680     __ jcc(Assembler::zero, L1);
3681     // access constant pool cache entry
3682     LP64_ONLY(__ get_cache_entry_pointer_at_bcp(c_rarg2, rcx, 1));
3683     NOT_LP64(__ get_cache_entry_pointer_at_bcp(rcx, rdx, 1));
3684     __ verify_oop(rax);
3685     __ push_ptr(rax);  // save object pointer before call_VM() clobbers it
3686     LP64_ONLY(__ mov(c_rarg1, rax));
3687     // c_rarg1: object pointer copied above
3688     // c_rarg2: cache entry pointer
3689     LP64_ONLY(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_access), c_rarg1, c_rarg2));
3690     NOT_LP64(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_access), rax, rcx));
3691     __ pop_ptr(rax); // restore object pointer
3692     __ bind(L1);
3693   }
3694 
3695   // access constant pool cache
3696   __ get_cache_and_index_at_bcp(rcx, rbx, 1);
3697   // replace index with field offset from cache entry
3698   // [jk] not needed currently
3699   // __ movl(rdx, Address(rcx, rbx, Address::times_8,
3700   //                      in_bytes(ConstantPoolCache::base_offset() +
3701   //                               ConstantPoolCacheEntry::flags_offset())));
3702   // __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);
3703   // __ andl(rdx, 0x1);
3704   //
3705   __ movptr(rbx, Address(rcx, rbx, Address::times_ptr,
3706                          in_bytes(ConstantPoolCache::base_offset() +
3707                                   ConstantPoolCacheEntry::f2_offset())));
3708 
3709   // rax: object
3710   __ verify_oop(rax);
3711   __ null_check(rax);
3712   Address field(rax, rbx, Address::times_1);
3713 
3714   // access field
3715   switch (bytecode()) {
3716   case Bytecodes::_fast_agetfield:
3717     do_oop_load(_masm, field, rax);
3718     __ verify_oop(rax);
3719     break;
3720   case Bytecodes::_fast_lgetfield:
3721 #ifdef _LP64
3722     __ access_load_at(T_LONG, IN_HEAP, noreg /* ltos */, field, noreg, noreg);
3723 #else
3724   __ stop(&quot;should not be rewritten&quot;);
3725 #endif
3726     break;
3727   case Bytecodes::_fast_igetfield:
3728     __ access_load_at(T_INT, IN_HEAP, rax, field, noreg, noreg);
3729     break;
3730   case Bytecodes::_fast_bgetfield:
3731     __ access_load_at(T_BYTE, IN_HEAP, rax, field, noreg, noreg);
3732     break;
3733   case Bytecodes::_fast_sgetfield:
3734     __ access_load_at(T_SHORT, IN_HEAP, rax, field, noreg, noreg);
3735     break;
3736   case Bytecodes::_fast_cgetfield:
3737     __ access_load_at(T_CHAR, IN_HEAP, rax, field, noreg, noreg);
3738     break;
3739   case Bytecodes::_fast_fgetfield:
3740     __ access_load_at(T_FLOAT, IN_HEAP, noreg /* ftos */, field, noreg, noreg);
3741     break;
3742   case Bytecodes::_fast_dgetfield:
3743     __ access_load_at(T_DOUBLE, IN_HEAP, noreg /* dtos */, field, noreg, noreg);
3744     break;
3745   default:
3746     ShouldNotReachHere();
3747   }
3748   // [jk] not needed currently
3749   //   Label notVolatile;
3750   //   __ testl(rdx, rdx);
3751   //   __ jcc(Assembler::zero, notVolatile);
3752   //   __ membar(Assembler::LoadLoad);
3753   //   __ bind(notVolatile);
3754 }
3755 
3756 void TemplateTable::fast_xaccess(TosState state) {
3757   transition(vtos, state);
3758 
3759   // get receiver
3760   __ movptr(rax, aaddress(0));
3761   // access constant pool cache
3762   __ get_cache_and_index_at_bcp(rcx, rdx, 2);
3763   __ movptr(rbx,
3764             Address(rcx, rdx, Address::times_ptr,
3765                     in_bytes(ConstantPoolCache::base_offset() +
3766                              ConstantPoolCacheEntry::f2_offset())));
3767   // make sure exception is reported in correct bcp range (getfield is
3768   // next instruction)
3769   __ increment(rbcp);
3770   __ null_check(rax);
3771   const Address field = Address(rax, rbx, Address::times_1, 0*wordSize);
3772   switch (state) {
3773   case itos:
3774     __ access_load_at(T_INT, IN_HEAP, rax, field, noreg, noreg);
3775     break;
3776   case atos:
3777     do_oop_load(_masm, field, rax);
3778     __ verify_oop(rax);
3779     break;
3780   case ftos:
3781     __ access_load_at(T_FLOAT, IN_HEAP, noreg /* ftos */, field, noreg, noreg);
3782     break;
3783   default:
3784     ShouldNotReachHere();
3785   }
3786 
3787   // [jk] not needed currently
3788   // Label notVolatile;
3789   // __ movl(rdx, Address(rcx, rdx, Address::times_8,
3790   //                      in_bytes(ConstantPoolCache::base_offset() +
3791   //                               ConstantPoolCacheEntry::flags_offset())));
3792   // __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);
3793   // __ testl(rdx, 0x1);
3794   // __ jcc(Assembler::zero, notVolatile);
3795   // __ membar(Assembler::LoadLoad);
3796   // __ bind(notVolatile);
3797 
3798   __ decrement(rbcp);
3799 }
3800 
3801 //-----------------------------------------------------------------------------
3802 // Calls
3803 
3804 void TemplateTable::count_calls(Register method, Register temp) {
3805   // implemented elsewhere
3806   ShouldNotReachHere();
3807 }
3808 
3809 void TemplateTable::prepare_invoke(int byte_no,
3810                                    Register method,  // linked method (or i-klass)
3811                                    Register index,   // itable index, MethodType, etc.
3812                                    Register recv,    // if caller wants to see it
3813                                    Register flags    // if caller wants to test it
3814                                    ) {
3815   // determine flags
3816   const Bytecodes::Code code = bytecode();
3817   const bool is_invokeinterface  = code == Bytecodes::_invokeinterface;
3818   const bool is_invokedynamic    = code == Bytecodes::_invokedynamic;
3819   const bool is_invokehandle     = code == Bytecodes::_invokehandle;
3820   const bool is_invokevirtual    = code == Bytecodes::_invokevirtual;
3821   const bool is_invokespecial    = code == Bytecodes::_invokespecial;
3822   const bool load_receiver       = (recv  != noreg);
3823   const bool save_flags          = (flags != noreg);
3824   assert(load_receiver == (code != Bytecodes::_invokestatic &amp;&amp; code != Bytecodes::_invokedynamic), &quot;&quot;);
3825   assert(save_flags    == (is_invokeinterface || is_invokevirtual), &quot;need flags for vfinal&quot;);
3826   assert(flags == noreg || flags == rdx, &quot;&quot;);
3827   assert(recv  == noreg || recv  == rcx, &quot;&quot;);
3828 
3829   // setup registers &amp; access constant pool cache
3830   if (recv  == noreg)  recv  = rcx;
3831   if (flags == noreg)  flags = rdx;
3832   assert_different_registers(method, index, recv, flags);
3833 
3834   // save &#39;interpreter return address&#39;
3835   __ save_bcp();
3836 
3837   load_invoke_cp_cache_entry(byte_no, method, index, flags, is_invokevirtual, false, is_invokedynamic);
3838 
3839   // maybe push appendix to arguments (just before return address)
3840   if (is_invokedynamic || is_invokehandle) {
3841     Label L_no_push;
3842     __ testl(flags, (1 &lt;&lt; ConstantPoolCacheEntry::has_appendix_shift));
3843     __ jcc(Assembler::zero, L_no_push);
3844     // Push the appendix as a trailing parameter.
3845     // This must be done before we get the receiver,
3846     // since the parameter_size includes it.
3847     __ push(rbx);
3848     __ mov(rbx, index);
3849     __ load_resolved_reference_at_index(index, rbx);
3850     __ pop(rbx);
3851     __ push(index);  // push appendix (MethodType, CallSite, etc.)
3852     __ bind(L_no_push);
3853   }
3854 
3855   // load receiver if needed (after appendix is pushed so parameter size is correct)
3856   // Note: no return address pushed yet
3857   if (load_receiver) {
3858     __ movl(recv, flags);
3859     __ andl(recv, ConstantPoolCacheEntry::parameter_size_mask);
3860     const int no_return_pc_pushed_yet = -1;  // argument slot correction before we push return address
3861     const int receiver_is_at_end      = -1;  // back off one slot to get receiver
3862     Address recv_addr = __ argument_address(recv, no_return_pc_pushed_yet + receiver_is_at_end);
3863     __ movptr(recv, recv_addr);
3864     __ verify_oop(recv);
3865   }
3866 
3867   if (save_flags) {
3868     __ movl(rbcp, flags);
3869   }
3870 
3871   // compute return type
3872   __ shrl(flags, ConstantPoolCacheEntry::tos_state_shift);
3873   // Make sure we don&#39;t need to mask flags after the above shift
3874   ConstantPoolCacheEntry::verify_tos_state_shift();
3875   // load return address
3876   {
3877     const address table_addr = (address) Interpreter::invoke_return_entry_table_for(code);
3878     ExternalAddress table(table_addr);
3879     LP64_ONLY(__ lea(rscratch1, table));
3880     LP64_ONLY(__ movptr(flags, Address(rscratch1, flags, Address::times_ptr)));
3881     NOT_LP64(__ movptr(flags, ArrayAddress(table, Address(noreg, flags, Address::times_ptr))));
3882   }
3883 
3884   // push return address
3885   __ push(flags);
3886 
3887   // Restore flags value from the constant pool cache, and restore rsi
3888   // for later null checks.  r13 is the bytecode pointer
3889   if (save_flags) {
3890     __ movl(flags, rbcp);
3891     __ restore_bcp();
3892   }
3893 }
3894 
3895 void TemplateTable::invokevirtual_helper(Register index,
3896                                          Register recv,
3897                                          Register flags) {
3898   // Uses temporary registers rax, rdx
3899   assert_different_registers(index, recv, rax, rdx);
3900   assert(index == rbx, &quot;&quot;);
3901   assert(recv  == rcx, &quot;&quot;);
3902 
3903   // Test for an invoke of a final method
3904   Label notFinal;
3905   __ movl(rax, flags);
3906   __ andl(rax, (1 &lt;&lt; ConstantPoolCacheEntry::is_vfinal_shift));
3907   __ jcc(Assembler::zero, notFinal);
3908 
3909   const Register method = index;  // method must be rbx
3910   assert(method == rbx,
3911          &quot;Method* must be rbx for interpreter calling convention&quot;);
3912 
3913   // do the call - the index is actually the method to call
3914   // that is, f2 is a vtable index if !is_vfinal, else f2 is a Method*
3915 
3916   // It&#39;s final, need a null check here!
3917   __ null_check(recv);
3918 
3919   // profile this call
3920   __ profile_final_call(rax);
3921   __ profile_arguments_type(rax, method, rbcp, true);
3922 
3923   __ jump_from_interpreted(method, rax);
3924 
3925   __ bind(notFinal);
3926 
3927   // get receiver klass
3928   __ null_check(recv, oopDesc::klass_offset_in_bytes());
3929   __ load_klass(rax, recv);
3930 
3931   // profile this call
3932   __ profile_virtual_call(rax, rlocals, rdx);
3933   // get target Method* &amp; entry point
3934   __ lookup_virtual_method(rax, index, method);
3935   __ profile_called_method(method, rdx, rbcp);
3936 
3937   __ profile_arguments_type(rdx, method, rbcp, true);
3938   __ jump_from_interpreted(method, rdx);
3939 }
3940 
3941 void TemplateTable::invokevirtual(int byte_no) {
3942   transition(vtos, vtos);
3943   assert(byte_no == f2_byte, &quot;use this argument&quot;);
3944   prepare_invoke(byte_no,
3945                  rbx,    // method or vtable index
3946                  noreg,  // unused itable index
3947                  rcx, rdx); // recv, flags
3948 
3949   // rbx: index
3950   // rcx: receiver
3951   // rdx: flags
3952 
3953   invokevirtual_helper(rbx, rcx, rdx);
3954 }
3955 
3956 void TemplateTable::invokespecial(int byte_no) {
3957   transition(vtos, vtos);
3958   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3959   prepare_invoke(byte_no, rbx, noreg,  // get f1 Method*
3960                  rcx);  // get receiver also for null check
3961   __ verify_oop(rcx);
3962   __ null_check(rcx);
3963   // do the call
3964   __ profile_call(rax);
3965   __ profile_arguments_type(rax, rbx, rbcp, false);
3966   __ jump_from_interpreted(rbx, rax);
3967 }
3968 
3969 void TemplateTable::invokestatic(int byte_no) {
3970   transition(vtos, vtos);
3971   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3972   prepare_invoke(byte_no, rbx);  // get f1 Method*
3973   // do the call
3974   __ profile_call(rax);
3975   __ profile_arguments_type(rax, rbx, rbcp, false);
3976   __ jump_from_interpreted(rbx, rax);
3977 }
3978 
3979 
3980 void TemplateTable::fast_invokevfinal(int byte_no) {
3981   transition(vtos, vtos);
3982   assert(byte_no == f2_byte, &quot;use this argument&quot;);
3983   __ stop(&quot;fast_invokevfinal not used on x86&quot;);
3984 }
3985 
3986 
3987 void TemplateTable::invokeinterface(int byte_no) {
3988   transition(vtos, vtos);
3989   assert(byte_no == f1_byte, &quot;use this argument&quot;);
3990   prepare_invoke(byte_no, rax, rbx,  // get f1 Klass*, f2 Method*
3991                  rcx, rdx); // recv, flags
3992 
3993   // rax: reference klass (from f1) if interface method
3994   // rbx: method (from f2)
3995   // rcx: receiver
3996   // rdx: flags
3997 
3998   // First check for Object case, then private interface method,
3999   // then regular interface method.
4000 
4001   // Special case of invokeinterface called for virtual method of
4002   // java.lang.Object.  See cpCache.cpp for details.
4003   Label notObjectMethod;
4004   __ movl(rlocals, rdx);
4005   __ andl(rlocals, (1 &lt;&lt; ConstantPoolCacheEntry::is_forced_virtual_shift));
4006   __ jcc(Assembler::zero, notObjectMethod);
4007   invokevirtual_helper(rbx, rcx, rdx);
4008   // no return from above
4009   __ bind(notObjectMethod);
4010 
4011   Label no_such_interface; // for receiver subtype check
4012   Register recvKlass; // used for exception processing
4013 
4014   // Check for private method invocation - indicated by vfinal
4015   Label notVFinal;
4016   __ movl(rlocals, rdx);
4017   __ andl(rlocals, (1 &lt;&lt; ConstantPoolCacheEntry::is_vfinal_shift));
4018   __ jcc(Assembler::zero, notVFinal);
4019 
4020   // Get receiver klass into rlocals - also a null check
4021   __ null_check(rcx, oopDesc::klass_offset_in_bytes());
4022   __ load_klass(rlocals, rcx);
4023 
4024   Label subtype;
4025   __ check_klass_subtype(rlocals, rax, rbcp, subtype);
4026   // If we get here the typecheck failed
4027   recvKlass = rdx;
4028   __ mov(recvKlass, rlocals); // shuffle receiver class for exception use
4029   __ jmp(no_such_interface);
4030 
4031   __ bind(subtype);
4032 
4033   // do the call - rbx is actually the method to call
4034 
4035   __ profile_final_call(rdx);
4036   __ profile_arguments_type(rdx, rbx, rbcp, true);
4037 
4038   __ jump_from_interpreted(rbx, rdx);
4039   // no return from above
4040   __ bind(notVFinal);
4041 
4042   // Get receiver klass into rdx - also a null check
4043   __ restore_locals();  // restore r14
4044   __ null_check(rcx, oopDesc::klass_offset_in_bytes());
4045   __ load_klass(rdx, rcx);
4046 
4047   Label no_such_method;
4048 
4049   // Preserve method for throw_AbstractMethodErrorVerbose.
4050   __ mov(rcx, rbx);
4051   // Receiver subtype check against REFC.
4052   // Superklass in rax. Subklass in rdx. Blows rcx, rdi.
4053   __ lookup_interface_method(// inputs: rec. class, interface, itable index
4054                              rdx, rax, noreg,
4055                              // outputs: scan temp. reg, scan temp. reg
4056                              rbcp, rlocals,
4057                              no_such_interface,
4058                              /*return_method=*/false);
4059 
4060   // profile this call
4061   __ restore_bcp(); // rbcp was destroyed by receiver type check
4062   __ profile_virtual_call(rdx, rbcp, rlocals);
4063 
4064   // Get declaring interface class from method, and itable index
4065   __ load_method_holder(rax, rbx);
4066   __ movl(rbx, Address(rbx, Method::itable_index_offset()));
4067   __ subl(rbx, Method::itable_index_max);
4068   __ negl(rbx);
4069 
4070   // Preserve recvKlass for throw_AbstractMethodErrorVerbose.
4071   __ mov(rlocals, rdx);
4072   __ lookup_interface_method(// inputs: rec. class, interface, itable index
4073                              rlocals, rax, rbx,
4074                              // outputs: method, scan temp. reg
4075                              rbx, rbcp,
4076                              no_such_interface);
4077 
4078   // rbx: Method* to call
4079   // rcx: receiver
4080   // Check for abstract method error
4081   // Note: This should be done more efficiently via a throw_abstract_method_error
4082   //       interpreter entry point and a conditional jump to it in case of a null
4083   //       method.
4084   __ testptr(rbx, rbx);
4085   __ jcc(Assembler::zero, no_such_method);
4086 
4087   __ profile_called_method(rbx, rbcp, rdx);
4088   __ profile_arguments_type(rdx, rbx, rbcp, true);
4089 
4090   // do the call
4091   // rcx: receiver
4092   // rbx,: Method*
4093   __ jump_from_interpreted(rbx, rdx);
4094   __ should_not_reach_here();
4095 
4096   // exception handling code follows...
4097   // note: must restore interpreter registers to canonical
4098   //       state for exception handling to work correctly!
4099 
4100   __ bind(no_such_method);
4101   // throw exception
4102   __ pop(rbx);           // pop return address (pushed by prepare_invoke)
4103   __ restore_bcp();      // rbcp must be correct for exception handler   (was destroyed)
4104   __ restore_locals();   // make sure locals pointer is correct as well (was destroyed)
4105   // Pass arguments for generating a verbose error message.
4106 #ifdef _LP64
4107   recvKlass = c_rarg1;
4108   Register method    = c_rarg2;
4109   if (recvKlass != rdx) { __ movq(recvKlass, rdx); }
4110   if (method != rcx)    { __ movq(method, rcx);    }
4111 #else
4112   recvKlass = rdx;
4113   Register method    = rcx;
4114 #endif
4115   __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_AbstractMethodErrorVerbose),
4116              recvKlass, method);
4117   // The call_VM checks for exception, so we should never return here.
4118   __ should_not_reach_here();
4119 
4120   __ bind(no_such_interface);
4121   // throw exception
4122   __ pop(rbx);           // pop return address (pushed by prepare_invoke)
4123   __ restore_bcp();      // rbcp must be correct for exception handler   (was destroyed)
4124   __ restore_locals();   // make sure locals pointer is correct as well (was destroyed)
4125   // Pass arguments for generating a verbose error message.
4126   LP64_ONLY( if (recvKlass != rdx) { __ movq(recvKlass, rdx); } )
4127   __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_IncompatibleClassChangeErrorVerbose),
4128              recvKlass, rax);
4129   // the call_VM checks for exception, so we should never return here.
4130   __ should_not_reach_here();
4131 }
4132 
4133 void TemplateTable::invokehandle(int byte_no) {
4134   transition(vtos, vtos);
4135   assert(byte_no == f1_byte, &quot;use this argument&quot;);
4136   const Register rbx_method = rbx;
4137   const Register rax_mtype  = rax;
4138   const Register rcx_recv   = rcx;
4139   const Register rdx_flags  = rdx;
4140 
4141   prepare_invoke(byte_no, rbx_method, rax_mtype, rcx_recv);
4142   __ verify_method_ptr(rbx_method);
4143   __ verify_oop(rcx_recv);
4144   __ null_check(rcx_recv);
4145 
4146   // rax: MethodType object (from cpool-&gt;resolved_references[f1], if necessary)
4147   // rbx: MH.invokeExact_MT method (from f2)
4148 
4149   // Note:  rax_mtype is already pushed (if necessary) by prepare_invoke
4150 
4151   // FIXME: profile the LambdaForm also
4152   __ profile_final_call(rax);
4153   __ profile_arguments_type(rdx, rbx_method, rbcp, true);
4154 
4155   __ jump_from_interpreted(rbx_method, rdx);
4156 }
4157 
4158 void TemplateTable::invokedynamic(int byte_no) {
4159   transition(vtos, vtos);
4160   assert(byte_no == f1_byte, &quot;use this argument&quot;);
4161 
4162   const Register rbx_method   = rbx;
4163   const Register rax_callsite = rax;
4164 
4165   prepare_invoke(byte_no, rbx_method, rax_callsite);
4166 
4167   // rax: CallSite object (from cpool-&gt;resolved_references[f1])
4168   // rbx: MH.linkToCallSite method (from f2)
4169 
4170   // Note:  rax_callsite is already pushed by prepare_invoke
4171 
4172   // %%% should make a type profile for any invokedynamic that takes a ref argument
4173   // profile this call
4174   __ profile_call(rbcp);
4175   __ profile_arguments_type(rdx, rbx_method, rbcp, false);
4176 
4177   __ verify_oop(rax_callsite);
4178 
4179   __ jump_from_interpreted(rbx_method, rdx);
4180 }
4181 
4182 //-----------------------------------------------------------------------------
4183 // Allocation
4184 
4185 void TemplateTable::_new() {
4186   transition(vtos, atos);
4187   __ get_unsigned_2_byte_index_at_bcp(rdx, 1);
4188   Label slow_case;
4189   Label slow_case_no_pop;
4190   Label done;
4191   Label initialize_header;
4192   Label initialize_object;  // including clearing the fields
4193 
4194   __ get_cpool_and_tags(rcx, rax);
4195 
4196   // Make sure the class we&#39;re about to instantiate has been resolved.
4197   // This is done before loading InstanceKlass to be consistent with the order
4198   // how Constant Pool is updated (see ConstantPool::klass_at_put)
4199   const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes();
4200   __ cmpb(Address(rax, rdx, Address::times_1, tags_offset), JVM_CONSTANT_Class);
4201   __ jcc(Assembler::notEqual, slow_case_no_pop);
4202 
4203   // get InstanceKlass
4204   __ load_resolved_klass_at_index(rcx, rcx, rdx);
4205   __ push(rcx);  // save the contexts of klass for initializing the header
4206 
4207   // make sure klass is initialized &amp; doesn&#39;t have finalizer
4208   // make sure klass is fully initialized
4209   __ cmpb(Address(rcx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
4210   __ jcc(Assembler::notEqual, slow_case);
4211 
4212   // get instance_size in InstanceKlass (scaled to a count of bytes)
4213   __ movl(rdx, Address(rcx, Klass::layout_helper_offset()));
4214   // test to see if it has a finalizer or is malformed in some way
4215   __ testl(rdx, Klass::_lh_instance_slow_path_bit);
4216   __ jcc(Assembler::notZero, slow_case);
4217 
4218   // Allocate the instance:
4219   //  If TLAB is enabled:
4220   //    Try to allocate in the TLAB.
4221   //    If fails, go to the slow path.
4222   //  Else If inline contiguous allocations are enabled:
4223   //    Try to allocate in eden.
4224   //    If fails due to heap end, go to slow path.
4225   //
4226   //  If TLAB is enabled OR inline contiguous is enabled:
4227   //    Initialize the allocation.
4228   //    Exit.
4229   //
4230   //  Go to slow path.
4231 
4232   const bool allow_shared_alloc =
4233     Universe::heap()-&gt;supports_inline_contig_alloc();
4234 
4235   const Register thread = LP64_ONLY(r15_thread) NOT_LP64(rcx);
4236 #ifndef _LP64
4237   if (UseTLAB || allow_shared_alloc) {
4238     __ get_thread(thread);
4239   }
4240 #endif // _LP64
4241 
4242   if (UseTLAB) {
4243     __ tlab_allocate(thread, rax, rdx, 0, rcx, rbx, slow_case);
4244     if (ZeroTLAB) {
4245       // the fields have been already cleared
4246       __ jmp(initialize_header);
4247     } else {
4248       // initialize both the header and fields
4249       __ jmp(initialize_object);
4250     }
4251   } else {
4252     // Allocation in the shared Eden, if allowed.
4253     //
4254     // rdx: instance size in bytes
4255     __ eden_allocate(thread, rax, rdx, 0, rbx, slow_case);
4256   }
4257 
4258   // If UseTLAB or allow_shared_alloc are true, the object is created above and
4259   // there is an initialize need. Otherwise, skip and go to the slow path.
4260   if (UseTLAB || allow_shared_alloc) {
4261     // The object is initialized before the header.  If the object size is
4262     // zero, go directly to the header initialization.
4263     __ bind(initialize_object);
4264     __ decrement(rdx, sizeof(oopDesc));
4265     __ jcc(Assembler::zero, initialize_header);
4266 
4267     // Initialize topmost object field, divide rdx by 8, check if odd and
4268     // test if zero.
4269     __ xorl(rcx, rcx);    // use zero reg to clear memory (shorter code)
4270     __ shrl(rdx, LogBytesPerLong); // divide by 2*oopSize and set carry flag if odd
4271 
4272     // rdx must have been multiple of 8
4273 #ifdef ASSERT
4274     // make sure rdx was multiple of 8
4275     Label L;
4276     // Ignore partial flag stall after shrl() since it is debug VM
4277     __ jcc(Assembler::carryClear, L);
4278     __ stop(&quot;object size is not multiple of 2 - adjust this code&quot;);
4279     __ bind(L);
4280     // rdx must be &gt; 0, no extra check needed here
4281 #endif
4282 
4283     // initialize remaining object fields: rdx was a multiple of 8
4284     { Label loop;
4285     __ bind(loop);
4286     __ movptr(Address(rax, rdx, Address::times_8, sizeof(oopDesc) - 1*oopSize), rcx);
4287     NOT_LP64(__ movptr(Address(rax, rdx, Address::times_8, sizeof(oopDesc) - 2*oopSize), rcx));
4288     __ decrement(rdx);
4289     __ jcc(Assembler::notZero, loop);
4290     }
4291 
4292     // initialize object header only.
4293     __ bind(initialize_header);
4294     if (UseBiasedLocking) {
4295       __ pop(rcx);   // get saved klass back in the register.
4296       __ movptr(rbx, Address(rcx, Klass::prototype_header_offset()));
4297       __ movptr(Address(rax, oopDesc::mark_offset_in_bytes ()), rbx);
4298     } else {
4299       __ movptr(Address(rax, oopDesc::mark_offset_in_bytes ()),
4300                 (intptr_t)markWord::prototype().value()); // header
4301       __ pop(rcx);   // get saved klass back in the register.
4302     }
4303 #ifdef _LP64
4304     __ xorl(rsi, rsi); // use zero reg to clear memory (shorter code)
4305     __ store_klass_gap(rax, rsi);  // zero klass gap for compressed oops
4306 #endif
4307     __ store_klass(rax, rcx);  // klass
4308 
4309     {
4310       SkipIfEqual skip_if(_masm, &amp;DTraceAllocProbes, 0);
4311       // Trigger dtrace event for fastpath
4312       __ push(atos);
4313       __ call_VM_leaf(
4314            CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc), rax);
4315       __ pop(atos);
4316     }
4317 
<a name="38" id="anc38"></a><span class="line-added">4318     TSAN_RUNTIME_ONLY(</span>
<span class="line-added">4319       // return value of new oop is in rax.</span>
<span class="line-added">4320       __ push(atos);</span>
<span class="line-added">4321       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::tsan_track_obj),</span>
<span class="line-added">4322                       rax);</span>
<span class="line-added">4323       __ pop(atos);</span>
<span class="line-added">4324     );</span>
<span class="line-added">4325 </span>
4326     __ jmp(done);
4327   }
4328 
4329   // slow case
4330   __ bind(slow_case);
4331   __ pop(rcx);   // restore stack pointer to what it was when we came in.
4332   __ bind(slow_case_no_pop);
4333 
4334   Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rax);
4335   Register rarg2 = LP64_ONLY(c_rarg2) NOT_LP64(rdx);
4336 
4337   __ get_constant_pool(rarg1);
4338   __ get_unsigned_2_byte_index_at_bcp(rarg2, 1);
4339   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), rarg1, rarg2);
4340    __ verify_oop(rax);
4341 
4342   // continue
4343   __ bind(done);
4344 }
4345 
4346 void TemplateTable::newarray() {
4347   transition(itos, atos);
4348   Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rdx);
4349   __ load_unsigned_byte(rarg1, at_bcp(1));
4350   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::newarray),
4351           rarg1, rax);
4352 }
4353 
4354 void TemplateTable::anewarray() {
4355   transition(itos, atos);
4356 
4357   Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rcx);
4358   Register rarg2 = LP64_ONLY(c_rarg2) NOT_LP64(rdx);
4359 
4360   __ get_unsigned_2_byte_index_at_bcp(rarg2, 1);
4361   __ get_constant_pool(rarg1);
4362   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::anewarray),
4363           rarg1, rarg2, rax);
4364 }
4365 
4366 void TemplateTable::arraylength() {
4367   transition(atos, itos);
4368   __ null_check(rax, arrayOopDesc::length_offset_in_bytes());
4369   __ movl(rax, Address(rax, arrayOopDesc::length_offset_in_bytes()));
4370 }
4371 
4372 void TemplateTable::checkcast() {
4373   transition(atos, atos);
4374   Label done, is_null, ok_is_subtype, quicked, resolved;
4375   __ testptr(rax, rax); // object is in rax
4376   __ jcc(Assembler::zero, is_null);
4377 
4378   // Get cpool &amp; tags index
4379   __ get_cpool_and_tags(rcx, rdx); // rcx=cpool, rdx=tags array
4380   __ get_unsigned_2_byte_index_at_bcp(rbx, 1); // rbx=index
4381   // See if bytecode has already been quicked
4382   __ cmpb(Address(rdx, rbx,
4383                   Address::times_1,
4384                   Array&lt;u1&gt;::base_offset_in_bytes()),
4385           JVM_CONSTANT_Class);
4386   __ jcc(Assembler::equal, quicked);
4387   __ push(atos); // save receiver for result, and for GC
4388   call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
4389 
4390   // vm_result_2 has metadata result
4391 #ifndef _LP64
4392   // borrow rdi from locals
4393   __ get_thread(rdi);
4394   __ get_vm_result_2(rax, rdi);
4395   __ restore_locals();
4396 #else
4397   __ get_vm_result_2(rax, r15_thread);
4398 #endif
4399 
4400   __ pop_ptr(rdx); // restore receiver
4401   __ jmpb(resolved);
4402 
4403   // Get superklass in rax and subklass in rbx
4404   __ bind(quicked);
4405   __ mov(rdx, rax); // Save object in rdx; rax needed for subtype check
4406   __ load_resolved_klass_at_index(rax, rcx, rbx);
4407 
4408   __ bind(resolved);
4409   __ load_klass(rbx, rdx);
4410 
4411   // Generate subtype check.  Blows rcx, rdi.  Object in rdx.
4412   // Superklass in rax.  Subklass in rbx.
4413   __ gen_subtype_check(rbx, ok_is_subtype);
4414 
4415   // Come here on failure
4416   __ push_ptr(rdx);
4417   // object is at TOS
4418   __ jump(ExternalAddress(Interpreter::_throw_ClassCastException_entry));
4419 
4420   // Come here on success
4421   __ bind(ok_is_subtype);
4422   __ mov(rax, rdx); // Restore object in rdx
4423 
4424   // Collect counts on whether this check-cast sees NULLs a lot or not.
4425   if (ProfileInterpreter) {
4426     __ jmp(done);
4427     __ bind(is_null);
4428     __ profile_null_seen(rcx);
4429   } else {
4430     __ bind(is_null);   // same as &#39;done&#39;
4431   }
4432   __ bind(done);
4433 }
4434 
4435 void TemplateTable::instanceof() {
4436   transition(atos, itos);
4437   Label done, is_null, ok_is_subtype, quicked, resolved;
4438   __ testptr(rax, rax);
4439   __ jcc(Assembler::zero, is_null);
4440 
4441   // Get cpool &amp; tags index
4442   __ get_cpool_and_tags(rcx, rdx); // rcx=cpool, rdx=tags array
4443   __ get_unsigned_2_byte_index_at_bcp(rbx, 1); // rbx=index
4444   // See if bytecode has already been quicked
4445   __ cmpb(Address(rdx, rbx,
4446                   Address::times_1,
4447                   Array&lt;u1&gt;::base_offset_in_bytes()),
4448           JVM_CONSTANT_Class);
4449   __ jcc(Assembler::equal, quicked);
4450 
4451   __ push(atos); // save receiver for result, and for GC
4452   call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::quicken_io_cc));
4453   // vm_result_2 has metadata result
4454 
4455 #ifndef _LP64
4456   // borrow rdi from locals
4457   __ get_thread(rdi);
4458   __ get_vm_result_2(rax, rdi);
4459   __ restore_locals();
4460 #else
4461   __ get_vm_result_2(rax, r15_thread);
4462 #endif
4463 
4464   __ pop_ptr(rdx); // restore receiver
4465   __ verify_oop(rdx);
4466   __ load_klass(rdx, rdx);
4467   __ jmpb(resolved);
4468 
4469   // Get superklass in rax and subklass in rdx
4470   __ bind(quicked);
4471   __ load_klass(rdx, rax);
4472   __ load_resolved_klass_at_index(rax, rcx, rbx);
4473 
4474   __ bind(resolved);
4475 
4476   // Generate subtype check.  Blows rcx, rdi
4477   // Superklass in rax.  Subklass in rdx.
4478   __ gen_subtype_check(rdx, ok_is_subtype);
4479 
4480   // Come here on failure
4481   __ xorl(rax, rax);
4482   __ jmpb(done);
4483   // Come here on success
4484   __ bind(ok_is_subtype);
4485   __ movl(rax, 1);
4486 
4487   // Collect counts on whether this test sees NULLs a lot or not.
4488   if (ProfileInterpreter) {
4489     __ jmp(done);
4490     __ bind(is_null);
4491     __ profile_null_seen(rcx);
4492   } else {
4493     __ bind(is_null);   // same as &#39;done&#39;
4494   }
4495   __ bind(done);
4496   // rax = 0: obj == NULL or  obj is not an instanceof the specified klass
4497   // rax = 1: obj != NULL and obj is     an instanceof the specified klass
4498 }
4499 
4500 
4501 //----------------------------------------------------------------------------------------------------
4502 // Breakpoints
4503 void TemplateTable::_breakpoint() {
4504   // Note: We get here even if we are single stepping..
4505   // jbug insists on setting breakpoints at every bytecode
4506   // even if we are in single step mode.
4507 
4508   transition(vtos, vtos);
4509 
4510   Register rarg = LP64_ONLY(c_rarg1) NOT_LP64(rcx);
4511 
4512   // get the unpatched byte code
4513   __ get_method(rarg);
4514   __ call_VM(noreg,
4515              CAST_FROM_FN_PTR(address,
4516                               InterpreterRuntime::get_original_bytecode_at),
4517              rarg, rbcp);
4518   __ mov(rbx, rax);  // why?
4519 
4520   // post the breakpoint event
4521   __ get_method(rarg);
4522   __ call_VM(noreg,
4523              CAST_FROM_FN_PTR(address, InterpreterRuntime::_breakpoint),
4524              rarg, rbcp);
4525 
4526   // complete the execution of original bytecode
4527   __ dispatch_only_normal(vtos);
4528 }
4529 
4530 //-----------------------------------------------------------------------------
4531 // Exceptions
4532 
4533 void TemplateTable::athrow() {
4534   transition(atos, vtos);
4535   __ null_check(rax);
4536   __ jump(ExternalAddress(Interpreter::throw_exception_entry()));
4537 }
4538 
4539 //-----------------------------------------------------------------------------
4540 // Synchronization
4541 //
4542 // Note: monitorenter &amp; exit are symmetric routines; which is reflected
4543 //       in the assembly code structure as well
4544 //
4545 // Stack layout:
4546 //
4547 // [expressions  ] &lt;--- rsp               = expression stack top
4548 // ..
4549 // [expressions  ]
4550 // [monitor entry] &lt;--- monitor block top = expression stack bot
4551 // ..
4552 // [monitor entry]
4553 // [frame data   ] &lt;--- monitor block bot
4554 // ...
4555 // [saved rbp    ] &lt;--- rbp
4556 void TemplateTable::monitorenter() {
4557   transition(atos, vtos);
4558 
4559   // check for NULL object
4560   __ null_check(rax);
4561 
4562   __ resolve(IS_NOT_NULL, rax);
4563 
4564   const Address monitor_block_top(
4565         rbp, frame::interpreter_frame_monitor_block_top_offset * wordSize);
4566   const Address monitor_block_bot(
4567         rbp, frame::interpreter_frame_initial_sp_offset * wordSize);
4568   const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
4569 
4570   Label allocated;
4571 
4572   Register rtop = LP64_ONLY(c_rarg3) NOT_LP64(rcx);
4573   Register rbot = LP64_ONLY(c_rarg2) NOT_LP64(rbx);
4574   Register rmon = LP64_ONLY(c_rarg1) NOT_LP64(rdx);
4575 
4576   // initialize entry pointer
4577   __ xorl(rmon, rmon); // points to free slot or NULL
4578 
4579   // find a free slot in the monitor block (result in rmon)
4580   {
4581     Label entry, loop, exit;
4582     __ movptr(rtop, monitor_block_top); // points to current entry,
4583                                         // starting with top-most entry
4584     __ lea(rbot, monitor_block_bot);    // points to word before bottom
4585                                         // of monitor block
4586     __ jmpb(entry);
4587 
4588     __ bind(loop);
4589     // check if current entry is used
4590     __ cmpptr(Address(rtop, BasicObjectLock::obj_offset_in_bytes()), (int32_t) NULL_WORD);
4591     // if not used then remember entry in rmon
4592     __ cmovptr(Assembler::equal, rmon, rtop);   // cmov =&gt; cmovptr
4593     // check if current entry is for same object
4594     __ cmpptr(rax, Address(rtop, BasicObjectLock::obj_offset_in_bytes()));
4595     // if same object then stop searching
4596     __ jccb(Assembler::equal, exit);
4597     // otherwise advance to next entry
4598     __ addptr(rtop, entry_size);
4599     __ bind(entry);
4600     // check if bottom reached
4601     __ cmpptr(rtop, rbot);
4602     // if not at bottom then check this entry
4603     __ jcc(Assembler::notEqual, loop);
4604     __ bind(exit);
4605   }
4606 
4607   __ testptr(rmon, rmon); // check if a slot has been found
4608   __ jcc(Assembler::notZero, allocated); // if found, continue with that one
4609 
4610   // allocate one if there&#39;s no free slot
4611   {
4612     Label entry, loop;
4613     // 1. compute new pointers          // rsp: old expression stack top
4614     __ movptr(rmon, monitor_block_bot); // rmon: old expression stack bottom
4615     __ subptr(rsp, entry_size);         // move expression stack top
4616     __ subptr(rmon, entry_size);        // move expression stack bottom
4617     __ mov(rtop, rsp);                  // set start value for copy loop
4618     __ movptr(monitor_block_bot, rmon); // set new monitor block bottom
4619     __ jmp(entry);
4620     // 2. move expression stack contents
4621     __ bind(loop);
4622     __ movptr(rbot, Address(rtop, entry_size)); // load expression stack
4623                                                 // word from old location
4624     __ movptr(Address(rtop, 0), rbot);          // and store it at new location
4625     __ addptr(rtop, wordSize);                  // advance to next word
4626     __ bind(entry);
4627     __ cmpptr(rtop, rmon);                      // check if bottom reached
4628     __ jcc(Assembler::notEqual, loop);          // if not at bottom then
4629                                                 // copy next word
4630   }
4631 
4632   // call run-time routine
4633   // rmon: points to monitor entry
4634   __ bind(allocated);
4635 
4636   // Increment bcp to point to the next bytecode, so exception
4637   // handling for async. exceptions work correctly.
4638   // The object has already been poped from the stack, so the
4639   // expression stack looks correct.
4640   __ increment(rbcp);
4641 
4642   // store object
4643   __ movptr(Address(rmon, BasicObjectLock::obj_offset_in_bytes()), rax);
4644   __ lock_object(rmon);
4645 
4646   // check to make sure this monitor doesn&#39;t cause stack overflow after locking
4647   __ save_bcp();  // in case of exception
4648   __ generate_stack_overflow_check(0);
4649 
4650   // The bcp has already been incremented. Just need to dispatch to
4651   // next instruction.
4652   __ dispatch_next(vtos);
4653 }
4654 
4655 void TemplateTable::monitorexit() {
4656   transition(atos, vtos);
4657 
4658   // check for NULL object
4659   __ null_check(rax);
4660 
4661   __ resolve(IS_NOT_NULL, rax);
4662 
4663   const Address monitor_block_top(
4664         rbp, frame::interpreter_frame_monitor_block_top_offset * wordSize);
4665   const Address monitor_block_bot(
4666         rbp, frame::interpreter_frame_initial_sp_offset * wordSize);
4667   const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;
4668 
4669   Register rtop = LP64_ONLY(c_rarg1) NOT_LP64(rdx);
4670   Register rbot = LP64_ONLY(c_rarg2) NOT_LP64(rbx);
4671 
4672   Label found;
4673 
4674   // find matching slot
4675   {
4676     Label entry, loop;
4677     __ movptr(rtop, monitor_block_top); // points to current entry,
4678                                         // starting with top-most entry
4679     __ lea(rbot, monitor_block_bot);    // points to word before bottom
4680                                         // of monitor block
4681     __ jmpb(entry);
4682 
4683     __ bind(loop);
4684     // check if current entry is for same object
4685     __ cmpptr(rax, Address(rtop, BasicObjectLock::obj_offset_in_bytes()));
4686     // if same object then stop searching
4687     __ jcc(Assembler::equal, found);
4688     // otherwise advance to next entry
4689     __ addptr(rtop, entry_size);
4690     __ bind(entry);
4691     // check if bottom reached
4692     __ cmpptr(rtop, rbot);
4693     // if not at bottom then check this entry
4694     __ jcc(Assembler::notEqual, loop);
4695   }
4696 
4697   // error handling. Unlocking was not block-structured
4698   __ call_VM(noreg, CAST_FROM_FN_PTR(address,
4699                    InterpreterRuntime::throw_illegal_monitor_state_exception));
4700   __ should_not_reach_here();
4701 
4702   // call run-time routine
4703   __ bind(found);
4704   __ push_ptr(rax); // make sure object is on stack (contract with oopMaps)
4705   __ unlock_object(rtop);
4706   __ pop_ptr(rax); // discard object
4707 }
4708 
4709 // Wide instructions
4710 void TemplateTable::wide() {
4711   transition(vtos, vtos);
4712   __ load_unsigned_byte(rbx, at_bcp(1));
4713   ExternalAddress wtable((address)Interpreter::_wentry_point);
4714   __ jump(ArrayAddress(wtable, Address(noreg, rbx, Address::times_ptr)));
4715   // Note: the rbcp increment step is part of the individual wide bytecode implementations
4716 }
4717 
4718 // Multi arrays
4719 void TemplateTable::multianewarray() {
4720   transition(vtos, atos);
4721 
4722   Register rarg = LP64_ONLY(c_rarg1) NOT_LP64(rax);
4723   __ load_unsigned_byte(rax, at_bcp(3)); // get number of dimensions
4724   // last dim is on top of stack; we want address of first one:
4725   // first_addr = last_addr + (ndims - 1) * stackElementSize - 1*wordsize
4726   // the latter wordSize to point to the beginning of the array.
4727   __ lea(rarg, Address(rsp, rax, Interpreter::stackElementScale(), -wordSize));
4728   call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::multianewarray), rarg);
4729   __ load_unsigned_byte(rbx, at_bcp(3));
4730   __ lea(rsp, Address(rsp, rbx, Interpreter::stackElementScale()));  // get rid of counts
4731 }
<a name="39" id="anc39"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="39" type="hidden" />
</body>
</html>
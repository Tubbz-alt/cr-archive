<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/x86/templateTable_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="sharedRuntime_x86_64.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../os_cpu/linux_x86/os_linux_x86.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/templateTable_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 765,91 ***</span>
    __ mov(NOT_LP64(rax) LP64_ONLY(c_rarg1), array);
    __ jump(ExternalAddress(Interpreter::_throw_ArrayIndexOutOfBoundsException_entry));
    __ bind(skip);
  }
  
  void TemplateTable::iaload() {
    transition(itos, itos);
    // rax: index
    // rdx: array
    index_check(rdx, rax); // kills rbx
<span class="line-modified">!   __ access_load_at(T_INT, IN_HEAP | IS_ARRAY, rax,</span>
<span class="line-modified">!                     Address(rdx, rax, Address::times_4,</span>
<span class="line-modified">!                             arrayOopDesc::base_offset_in_bytes(T_INT)),</span>
<span class="line-modified">!                     noreg, noreg);</span>
  }
  
  void TemplateTable::laload() {
    transition(itos, ltos);
    // rax: index
    // rdx: array
    index_check(rdx, rax); // kills rbx
    NOT_LP64(__ mov(rbx, rax));
    // rbx,: index
<span class="line-modified">!   __ access_load_at(T_LONG, IN_HEAP | IS_ARRAY, noreg /* ltos */,</span>
<span class="line-modified">!                     Address(rdx, rbx, Address::times_8,</span>
<span class="line-modified">!                             arrayOopDesc::base_offset_in_bytes(T_LONG)),</span>
<span class="line-modified">!                     noreg, noreg);</span>
  }
  
  
  
  void TemplateTable::faload() {
    transition(itos, ftos);
    // rax: index
    // rdx: array
    index_check(rdx, rax); // kills rbx
<span class="line-modified">!   __ access_load_at(T_FLOAT, IN_HEAP | IS_ARRAY, noreg /* ftos */,</span>
<span class="line-modified">!                     Address(rdx, rax,</span>
<span class="line-modified">!                             Address::times_4,</span>
<span class="line-modified">!                             arrayOopDesc::base_offset_in_bytes(T_FLOAT)),</span>
<span class="line-modified">!                     noreg, noreg);</span>
  }
  
  void TemplateTable::daload() {
    transition(itos, dtos);
    // rax: index
    // rdx: array
    index_check(rdx, rax); // kills rbx
<span class="line-modified">!   __ access_load_at(T_DOUBLE, IN_HEAP | IS_ARRAY, noreg /* dtos */,</span>
<span class="line-modified">!                     Address(rdx, rax,</span>
<span class="line-modified">!                             Address::times_8,</span>
<span class="line-modified">!                             arrayOopDesc::base_offset_in_bytes(T_DOUBLE)),</span>
<span class="line-modified">!                     noreg, noreg);</span>
  }
  
  void TemplateTable::aaload() {
    transition(itos, atos);
    // rax: index
    // rdx: array
    index_check(rdx, rax); // kills rbx
<span class="line-modified">!   do_oop_load(_masm,</span>
<span class="line-modified">!               Address(rdx, rax,</span>
<span class="line-modified">!                       UseCompressedOops ? Address::times_4 : Address::times_ptr,</span>
<span class="line-modified">!                       arrayOopDesc::base_offset_in_bytes(T_OBJECT)),</span>
<span class="line-modified">!               rax,</span>
<span class="line-modified">!               IS_ARRAY);</span>
  }
  
  void TemplateTable::baload() {
    transition(itos, itos);
    // rax: index
    // rdx: array
    index_check(rdx, rax); // kills rbx
<span class="line-modified">!   __ access_load_at(T_BYTE, IN_HEAP | IS_ARRAY, rax,</span>
<span class="line-modified">!                     Address(rdx, rax, Address::times_1, arrayOopDesc::base_offset_in_bytes(T_BYTE)),</span>
<span class="line-modified">!                     noreg, noreg);</span>
  }
  
  void TemplateTable::caload() {
    transition(itos, itos);
    // rax: index
    // rdx: array
    index_check(rdx, rax); // kills rbx
<span class="line-modified">!   __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, rax,</span>
<span class="line-modified">!                     Address(rdx, rax, Address::times_2, arrayOopDesc::base_offset_in_bytes(T_CHAR)),</span>
<span class="line-modified">!                     noreg, noreg);</span>
  }
  
  // iload followed by caload frequent pair
  void TemplateTable::fast_icaload() {
    transition(vtos, itos);
<span class="line-new-header">--- 765,209 ---</span>
    __ mov(NOT_LP64(rax) LP64_ONLY(c_rarg1), array);
    __ jump(ExternalAddress(Interpreter::_throw_ArrayIndexOutOfBoundsException_entry));
    __ bind(skip);
  }
  
<span class="line-added">+ #if INCLUDE_TSAN</span>
<span class="line-added">+ </span>
<span class="line-added">+ TemplateTable::TsanMemoryReleaseAcquireFunction TemplateTable::tsan_release_acquire_method(</span>
<span class="line-added">+     TsanMemoryReadWriteFunction tsan_function) {</span>
<span class="line-added">+   if (tsan_function == SharedRuntime::tsan_read1</span>
<span class="line-added">+       || tsan_function == SharedRuntime::tsan_read2</span>
<span class="line-added">+       || tsan_function == SharedRuntime::tsan_read4</span>
<span class="line-added">+       || tsan_function == SharedRuntime::tsan_read8) {</span>
<span class="line-added">+     return SharedRuntime::tsan_acquire;</span>
<span class="line-added">+   } else if (tsan_function == SharedRuntime::tsan_write1</span>
<span class="line-added">+       || tsan_function == SharedRuntime::tsan_write2</span>
<span class="line-added">+       || tsan_function == SharedRuntime::tsan_write4</span>
<span class="line-added">+       || tsan_function == SharedRuntime::tsan_write8) {</span>
<span class="line-added">+     return SharedRuntime::tsan_release;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   ShouldNotReachHere();</span>
<span class="line-added">+   return NULL;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void TemplateTable::tsan_observe_get_or_put(</span>
<span class="line-added">+     const Address &amp;field,</span>
<span class="line-added">+     Register flags,</span>
<span class="line-added">+     TsanMemoryReadWriteFunction tsan_function,</span>
<span class="line-added">+     TosState tos) {</span>
<span class="line-added">+   assert(flags == rdx, &quot;flags should be in rdx register&quot;);</span>
<span class="line-added">+   assert(ThreadSanitizer, &quot;ThreadSanitizer should be set&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   TsanMemoryReleaseAcquireFunction releaseAcquireFunction =</span>
<span class="line-added">+       tsan_release_acquire_method(tsan_function);</span>
<span class="line-added">+ </span>
<span class="line-added">+   Label done, notAcquireRelease;</span>
<span class="line-added">+ </span>
<span class="line-added">+   // We could save some instructions by only saving the registers we need.</span>
<span class="line-added">+   __ pusha();</span>
<span class="line-added">+   // pusha() doesn&#39;t save xmm0, which tsan_function clobbers and the</span>
<span class="line-added">+   // interpreter still needs.</span>
<span class="line-added">+   // This really only needs to be done for some of the float/double accesses,</span>
<span class="line-added">+   // but it&#39;s here because it&#39;s cleaner.</span>
<span class="line-added">+   __ push_d(xmm0);</span>
<span class="line-added">+   DEBUG_ONLY(</span>
<span class="line-added">+     __ pusha();</span>
<span class="line-added">+     __ movptr(c_rarg0, field.base());</span>
<span class="line-added">+     __ leaq(c_rarg1, field);</span>
<span class="line-added">+     __ subq(c_rarg1, field.base());</span>
<span class="line-added">+     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::verify_oop_index),</span>
<span class="line-added">+                     c_rarg0 /* oop */, c_rarg1 /* index */);</span>
<span class="line-added">+     __ popa();</span>
<span class="line-added">+   );</span>
<span class="line-added">+   // For volatile reads/writes use an acquire/release.</span>
<span class="line-added">+   // If a reference is annotated to be ignored, assume it&#39;s safe to</span>
<span class="line-added">+   // access the object it&#39;s referring to and create a happens-before relation</span>
<span class="line-added">+   // between the accesses to this reference.</span>
<span class="line-added">+   int32_t acquire_release_mask = 1 &lt;&lt; ConstantPoolCacheEntry::is_volatile_shift |</span>
<span class="line-added">+       ((tos == atos) ? 1 &lt;&lt; ConstantPoolCacheEntry::is_tsan_ignore_shift : 0);</span>
<span class="line-added">+   __ testl(flags, acquire_release_mask);</span>
<span class="line-added">+   __ jcc(Assembler::zero, notAcquireRelease);</span>
<span class="line-added">+ </span>
<span class="line-added">+   __ leaq(c_rarg0, field);</span>
<span class="line-added">+   __ call_VM_leaf(CAST_FROM_FN_PTR(address, releaseAcquireFunction), c_rarg0);</span>
<span class="line-added">+   if (ThreadSanitizerJavaMemory) {</span>
<span class="line-added">+     __ jmp(done);</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ bind(notAcquireRelease);</span>
<span class="line-added">+     // Ignore reads/writes to final fields. They can&#39;t be racy.</span>
<span class="line-added">+     int32_t ignore_mask = 1 &lt;&lt; ConstantPoolCacheEntry::is_final_shift |</span>
<span class="line-added">+         1 &lt;&lt; ConstantPoolCacheEntry::is_tsan_ignore_shift;</span>
<span class="line-added">+     __ testl(flags, ignore_mask);</span>
<span class="line-added">+     __ jcc(Assembler::notZero, done);</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ leaq(c_rarg0, field);</span>
<span class="line-added">+     __ get_method(c_rarg1);</span>
<span class="line-added">+     __ call_VM_leaf(CAST_FROM_FN_PTR(address, tsan_function),</span>
<span class="line-added">+                     c_rarg0 /* addr */, c_rarg1 /* method */, rbcp /* bcp */);</span>
<span class="line-added">+ </span>
<span class="line-added">+     __ bind(done);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     __ bind(notAcquireRelease);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   __ pop_d(xmm0);</span>
<span class="line-added">+   __ popa();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void TemplateTable::tsan_observe_load_or_store(</span>
<span class="line-added">+     const Address&amp; field, TsanMemoryReadWriteFunction tsan_function) {</span>
<span class="line-added">+   assert(ThreadSanitizer, &quot;ThreadSanitizer should be set&quot;);</span>
<span class="line-added">+   if (!ThreadSanitizerJavaMemory) {</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   // We could save some instructions by only saving the registers we need.</span>
<span class="line-added">+   __ pusha();</span>
<span class="line-added">+   // pusha() doesn&#39;t save xmm0, which tsan_function clobbers and the</span>
<span class="line-added">+   // interpreter still needs.</span>
<span class="line-added">+   // This really only needs to be done for some of the float/double accesses,</span>
<span class="line-added">+   // but it&#39;s here because it&#39;s cleaner.</span>
<span class="line-added">+   __ push_d(xmm0);</span>
<span class="line-added">+   DEBUG_ONLY(</span>
<span class="line-added">+     __ pusha();</span>
<span class="line-added">+     __ movptr(c_rarg0, field.base());</span>
<span class="line-added">+     __ leaq(c_rarg1, field);</span>
<span class="line-added">+     __ subq(c_rarg1, field.base());</span>
<span class="line-added">+     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::verify_oop_index),</span>
<span class="line-added">+                     c_rarg0 /* oop */, c_rarg1 /* index */);</span>
<span class="line-added">+     __ popa();</span>
<span class="line-added">+   );</span>
<span class="line-added">+   __ leaq(c_rarg0, field);</span>
<span class="line-added">+   __ get_method(c_rarg1);</span>
<span class="line-added">+   __ call_VM_leaf(CAST_FROM_FN_PTR(address, tsan_function),</span>
<span class="line-added">+                   c_rarg0 /* addr */, c_rarg1 /* method */, rbcp /* bcp */);</span>
<span class="line-added">+   __ pop_d(xmm0);</span>
<span class="line-added">+   __ popa();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #endif  // INCLUDE_TSAN</span>
<span class="line-added">+ </span>
  void TemplateTable::iaload() {
    transition(itos, itos);
    // rax: index
    // rdx: array
    index_check(rdx, rax); // kills rbx
<span class="line-modified">!   Address addr(rdx, rax, Address::times_4,</span>
<span class="line-modified">!                arrayOopDesc::base_offset_in_bytes(T_INT));</span>
<span class="line-modified">!   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read4));</span>
<span class="line-modified">!   __ access_load_at(T_INT, IN_HEAP | IS_ARRAY, rax, addr, noreg, noreg);</span>
  }
  
  void TemplateTable::laload() {
    transition(itos, ltos);
    // rax: index
    // rdx: array
    index_check(rdx, rax); // kills rbx
    NOT_LP64(__ mov(rbx, rax));
    // rbx,: index
<span class="line-modified">!   Address addr(rdx, rbx, Address::times_8,</span>
<span class="line-modified">!                arrayOopDesc::base_offset_in_bytes(T_LONG));</span>
<span class="line-modified">!   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read8));</span>
<span class="line-modified">!   __ access_load_at(T_LONG, IN_HEAP | IS_ARRAY, noreg /* ltos */, addr, noreg,</span>
<span class="line-added">+                     noreg);</span>
  }
  
  
  
  void TemplateTable::faload() {
    transition(itos, ftos);
    // rax: index
    // rdx: array
    index_check(rdx, rax); // kills rbx
<span class="line-modified">!   Address addr(rdx, rax, Address::times_4,</span>
<span class="line-modified">!                arrayOopDesc::base_offset_in_bytes(T_FLOAT));</span>
<span class="line-modified">!   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read4));</span>
<span class="line-modified">!   __ access_load_at(T_FLOAT, IN_HEAP | IS_ARRAY, noreg /* ftos */, addr, noreg,</span>
<span class="line-modified">!                     noreg);</span>
  }
  
  void TemplateTable::daload() {
    transition(itos, dtos);
    // rax: index
    // rdx: array
    index_check(rdx, rax); // kills rbx
<span class="line-modified">!   Address addr(rdx, rax, Address::times_8,</span>
<span class="line-modified">!                arrayOopDesc::base_offset_in_bytes(T_DOUBLE));</span>
<span class="line-modified">!   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read8));</span>
<span class="line-modified">!   __ access_load_at(T_DOUBLE, IN_HEAP | IS_ARRAY, noreg /* dtos */, addr, noreg,</span>
<span class="line-modified">!                     noreg);</span>
  }
  
  void TemplateTable::aaload() {
    transition(itos, atos);
    // rax: index
    // rdx: array
    index_check(rdx, rax); // kills rbx
<span class="line-modified">!   Address addr(rdx, rax,</span>
<span class="line-modified">!                UseCompressedOops ? Address::times_4 : Address::times_ptr,</span>
<span class="line-modified">!                arrayOopDesc::base_offset_in_bytes(T_OBJECT));</span>
<span class="line-modified">!   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(</span>
<span class="line-modified">!       addr, UseCompressedOops ? SharedRuntime::tsan_read4</span>
<span class="line-modified">!                               : SharedRuntime::tsan_read8));</span>
<span class="line-added">+   do_oop_load(_masm, addr, rax, IS_ARRAY);</span>
  }
  
  void TemplateTable::baload() {
    transition(itos, itos);
    // rax: index
    // rdx: array
    index_check(rdx, rax); // kills rbx
<span class="line-modified">!   Address addr(rdx, rax, Address::times_1,</span>
<span class="line-modified">!                arrayOopDesc::base_offset_in_bytes(T_BYTE));</span>
<span class="line-modified">!   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read1));</span>
<span class="line-added">+   __ access_load_at(T_BYTE, IN_HEAP | IS_ARRAY, rax, addr, noreg, noreg);</span>
  }
  
  void TemplateTable::caload() {
    transition(itos, itos);
    // rax: index
    // rdx: array
    index_check(rdx, rax); // kills rbx
<span class="line-modified">!   Address addr(rdx, rax, Address::times_2,</span>
<span class="line-modified">!                arrayOopDesc::base_offset_in_bytes(T_CHAR));</span>
<span class="line-modified">!   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read2));</span>
<span class="line-added">+   __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, rax, addr, noreg, noreg);</span>
  }
  
  // iload followed by caload frequent pair
  void TemplateTable::fast_icaload() {
    transition(vtos, itos);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 869,13 ***</span>
  void TemplateTable::saload() {
    transition(itos, itos);
    // rax: index
    // rdx: array
    index_check(rdx, rax); // kills rbx
<span class="line-modified">!   __ access_load_at(T_SHORT, IN_HEAP | IS_ARRAY, rax,</span>
<span class="line-modified">!                     Address(rdx, rax, Address::times_2, arrayOopDesc::base_offset_in_bytes(T_SHORT)),</span>
<span class="line-modified">!                     noreg, noreg);</span>
  }
  
  void TemplateTable::iload(int n) {
    transition(vtos, itos);
    __ movl(rax, iaddress(n));
<span class="line-new-header">--- 987,14 ---</span>
  void TemplateTable::saload() {
    transition(itos, itos);
    // rax: index
    // rdx: array
    index_check(rdx, rax); // kills rbx
<span class="line-modified">!   Address addr(rdx, rax, Address::times_2,</span>
<span class="line-modified">!                arrayOopDesc::base_offset_in_bytes(T_SHORT));</span>
<span class="line-modified">!   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read2));</span>
<span class="line-added">+   __ access_load_at(T_SHORT, IN_HEAP | IS_ARRAY, rax, addr, noreg, noreg);</span>
  }
  
  void TemplateTable::iload(int n) {
    transition(vtos, itos);
    __ movl(rax, iaddress(n));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1063,55 ***</span>
    __ pop_i(rbx);
    // rax: value
    // rbx: index
    // rdx: array
    index_check(rdx, rbx); // prefer index in rbx
<span class="line-modified">!   __ access_store_at(T_INT, IN_HEAP | IS_ARRAY,</span>
<span class="line-modified">!                      Address(rdx, rbx, Address::times_4,</span>
<span class="line-modified">!                              arrayOopDesc::base_offset_in_bytes(T_INT)),</span>
<span class="line-modified">!                      rax, noreg, noreg);</span>
  }
  
  void TemplateTable::lastore() {
    transition(ltos, vtos);
    __ pop_i(rbx);
    // rax,: low(value)
    // rcx: array
    // rdx: high(value)
    index_check(rcx, rbx);  // prefer index in rbx,
    // rbx,: index
<span class="line-modified">!   __ access_store_at(T_LONG, IN_HEAP | IS_ARRAY,</span>
<span class="line-modified">!                      Address(rcx, rbx, Address::times_8,</span>
<span class="line-modified">!                              arrayOopDesc::base_offset_in_bytes(T_LONG)),</span>
<span class="line-modified">!                      noreg /* ltos */, noreg, noreg);</span>
  }
  
  
  void TemplateTable::fastore() {
    transition(ftos, vtos);
    __ pop_i(rbx);
    // value is in UseSSE &gt;= 1 ? xmm0 : ST(0)
    // rbx:  index
    // rdx:  array
    index_check(rdx, rbx); // prefer index in rbx
<span class="line-modified">!   __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY,</span>
<span class="line-modified">!                      Address(rdx, rbx, Address::times_4,</span>
<span class="line-modified">!                              arrayOopDesc::base_offset_in_bytes(T_FLOAT)),</span>
<span class="line-modified">!                      noreg /* ftos */, noreg, noreg);</span>
  }
  
  void TemplateTable::dastore() {
    transition(dtos, vtos);
    __ pop_i(rbx);
    // value is in UseSSE &gt;= 2 ? xmm0 : ST(0)
    // rbx:  index
    // rdx:  array
    index_check(rdx, rbx); // prefer index in rbx
<span class="line-modified">!   __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY,</span>
<span class="line-modified">!                      Address(rdx, rbx, Address::times_8,</span>
<span class="line-modified">!                              arrayOopDesc::base_offset_in_bytes(T_DOUBLE)),</span>
<span class="line-modified">!                      noreg /* dtos */, noreg, noreg);</span>
  }
  
  void TemplateTable::aastore() {
    Label is_null, ok_is_subtype, done;
    transition(vtos, vtos);
<span class="line-new-header">--- 1182,58 ---</span>
    __ pop_i(rbx);
    // rax: value
    // rbx: index
    // rdx: array
    index_check(rdx, rbx); // prefer index in rbx
<span class="line-modified">!   Address addr(rdx, rbx, Address::times_4,</span>
<span class="line-modified">!                arrayOopDesc::base_offset_in_bytes(T_INT));</span>
<span class="line-modified">!   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write4));</span>
<span class="line-modified">!   __ access_store_at(T_INT, IN_HEAP | IS_ARRAY, addr, rax, noreg, noreg);</span>
  }
  
  void TemplateTable::lastore() {
    transition(ltos, vtos);
    __ pop_i(rbx);
    // rax,: low(value)
    // rcx: array
    // rdx: high(value)
    index_check(rcx, rbx);  // prefer index in rbx,
    // rbx,: index
<span class="line-modified">!   Address addr(rcx, rbx, Address::times_8,</span>
<span class="line-modified">!                arrayOopDesc::base_offset_in_bytes(T_LONG));</span>
<span class="line-modified">!   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write8));</span>
<span class="line-modified">!   __ access_store_at(T_LONG, IN_HEAP | IS_ARRAY, addr, noreg /* ltos */, noreg,</span>
<span class="line-added">+                      noreg);</span>
  }
  
  
  void TemplateTable::fastore() {
    transition(ftos, vtos);
    __ pop_i(rbx);
    // value is in UseSSE &gt;= 1 ? xmm0 : ST(0)
    // rbx:  index
    // rdx:  array
    index_check(rdx, rbx); // prefer index in rbx
<span class="line-modified">!   Address addr(rdx, rbx, Address::times_4,</span>
<span class="line-modified">!                arrayOopDesc::base_offset_in_bytes(T_FLOAT));</span>
<span class="line-modified">!   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write4));</span>
<span class="line-modified">!   __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY, addr, noreg /* ftos */, noreg,</span>
<span class="line-added">+                      noreg);</span>
  }
  
  void TemplateTable::dastore() {
    transition(dtos, vtos);
    __ pop_i(rbx);
    // value is in UseSSE &gt;= 2 ? xmm0 : ST(0)
    // rbx:  index
    // rdx:  array
    index_check(rdx, rbx); // prefer index in rbx
<span class="line-modified">!   Address addr(rdx, rbx, Address::times_8,</span>
<span class="line-modified">!                arrayOopDesc::base_offset_in_bytes(T_DOUBLE));</span>
<span class="line-modified">!   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write8));</span>
<span class="line-modified">!   __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY, addr, noreg /* dtos */,</span>
<span class="line-added">+                      noreg, noreg);</span>
  }
  
  void TemplateTable::aastore() {
    Label is_null, ok_is_subtype, done;
    transition(vtos, vtos);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1122,10 ***</span>
<span class="line-new-header">--- 1244,14 ---</span>
  
    Address element_address(rdx, rcx,
                            UseCompressedOops? Address::times_4 : Address::times_ptr,
                            arrayOopDesc::base_offset_in_bytes(T_OBJECT));
  
<span class="line-added">+   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(</span>
<span class="line-added">+       element_address, UseCompressedOops ? SharedRuntime::tsan_write4</span>
<span class="line-added">+                                          : SharedRuntime::tsan_write8));</span>
<span class="line-added">+ </span>
    index_check_without_pop(rdx, rcx);     // kills rbx
    __ testptr(rax, rax);
    __ jcc(Assembler::zero, is_null);
  
    // Move subklass into rbx
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1180,27 ***</span>
    __ testl(rcx, diffbit);
    Label L_skip;
    __ jccb(Assembler::zero, L_skip);
    __ andl(rax, 1);  // if it is a T_BOOLEAN array, mask the stored value to 0/1
    __ bind(L_skip);
<span class="line-modified">!   __ access_store_at(T_BYTE, IN_HEAP | IS_ARRAY,</span>
<span class="line-modified">!                      Address(rdx, rbx,Address::times_1,</span>
<span class="line-modified">!                              arrayOopDesc::base_offset_in_bytes(T_BYTE)),</span>
<span class="line-modified">!                      rax, noreg, noreg);</span>
  }
  
  void TemplateTable::castore() {
    transition(itos, vtos);
    __ pop_i(rbx);
    // rax: value
    // rbx: index
    // rdx: array
    index_check(rdx, rbx);  // prefer index in rbx
<span class="line-modified">!   __ access_store_at(T_CHAR, IN_HEAP | IS_ARRAY,</span>
<span class="line-modified">!                      Address(rdx, rbx, Address::times_2,</span>
<span class="line-modified">!                              arrayOopDesc::base_offset_in_bytes(T_CHAR)),</span>
<span class="line-modified">!                      rax, noreg, noreg);</span>
  }
  
  
  void TemplateTable::sastore() {
    castore();
<span class="line-new-header">--- 1306,27 ---</span>
    __ testl(rcx, diffbit);
    Label L_skip;
    __ jccb(Assembler::zero, L_skip);
    __ andl(rax, 1);  // if it is a T_BOOLEAN array, mask the stored value to 0/1
    __ bind(L_skip);
<span class="line-modified">!   Address addr(rdx, rbx, Address::times_1,</span>
<span class="line-modified">!                arrayOopDesc::base_offset_in_bytes(T_BYTE));</span>
<span class="line-modified">!   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write1));</span>
<span class="line-modified">!   __ access_store_at(T_BYTE, IN_HEAP | IS_ARRAY, addr, rax, noreg, noreg);</span>
  }
  
  void TemplateTable::castore() {
    transition(itos, vtos);
    __ pop_i(rbx);
    // rax: value
    // rbx: index
    // rdx: array
    index_check(rdx, rbx);  // prefer index in rbx
<span class="line-modified">!   Address addr(rdx, rbx, Address::times_2,</span>
<span class="line-modified">!                arrayOopDesc::base_offset_in_bytes(T_CHAR));</span>
<span class="line-modified">!   TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write2));</span>
<span class="line-modified">!   __ access_store_at(T_CHAR, IN_HEAP | IS_ARRAY, addr, rax, noreg, noreg);</span>
  }
  
  
  void TemplateTable::sastore() {
    castore();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2789,10 ***</span>
<span class="line-new-header">--- 2915,30 ---</span>
                             in_bytes(cp_base_offset +
                                      ConstantPoolCacheEntry::f1_offset())));
      const int mirror_offset = in_bytes(Klass::java_mirror_offset());
      __ movptr(obj, Address(obj, mirror_offset));
      __ resolve_oop_handle(obj);
<span class="line-added">+     TSAN_RUNTIME_ONLY(</span>
<span class="line-added">+       // Draw a happens-before edge from the class&#39;s static initializer to</span>
<span class="line-added">+       // this lookup.</span>
<span class="line-added">+ </span>
<span class="line-added">+       // java_lang_Class::_init_lock_offset may not have been initialized</span>
<span class="line-added">+       // when generating code. It will be initialized at runtime though.</span>
<span class="line-added">+       // So calculate its address and read from it at runtime.</span>
<span class="line-added">+       __ pusha();</span>
<span class="line-added">+       __ movq(c_rarg0, obj);</span>
<span class="line-added">+       AddressLiteral init_lock_offset_address(</span>
<span class="line-added">+           (address) java_lang_Class::init_lock_offset_addr(),</span>
<span class="line-added">+           relocInfo::none);</span>
<span class="line-added">+       __ lea(rax, init_lock_offset_address);</span>
<span class="line-added">+       __ movl(rax, Address(rax, 0));</span>
<span class="line-added">+       __ addq(c_rarg0, rax);</span>
<span class="line-added">+       __ call_VM_leaf(CAST_FROM_FN_PTR(address,</span>
<span class="line-added">+                                        SharedRuntime::tsan_acquire),</span>
<span class="line-added">+                       c_rarg0);</span>
<span class="line-added">+       __ popa();</span>
<span class="line-added">+     );</span>
    }
  }
  
  void TemplateTable::load_invoke_cp_cache_entry(int byte_no,
                                                 Register method,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2884,10 ***</span>
<span class="line-new-header">--- 3030,15 ---</span>
  
    if (!is_static) pop_and_check_object(obj);
  
    const Address field(obj, off, Address::times_1, 0*wordSize);
  
<span class="line-added">+   // During a TSAN instrumented run, move flags into rdx so we can later</span>
<span class="line-added">+   // examine whether the field is volatile or has been annotated to be ignored</span>
<span class="line-added">+   // by Tsan.</span>
<span class="line-added">+   TSAN_RUNTIME_ONLY(__ movl(rdx, flags));</span>
<span class="line-added">+ </span>
    Label Done, notByte, notBool, notInt, notShort, notChar, notLong, notFloat, notObj;
  
    __ shrl(flags, ConstantPoolCacheEntry::tos_state_shift);
    // Make sure we don&#39;t need to mask edx after the above shift
    assert(btos == 0, &quot;change code, btos != 0&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2896,10 ***</span>
<span class="line-new-header">--- 3047,12 ---</span>
  
    __ jcc(Assembler::notZero, notByte);
    // btos
    __ access_load_at(T_BYTE, IN_HEAP, rax, field, noreg, noreg);
    __ push(btos);
<span class="line-added">+   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">+       field, rdx, SharedRuntime::tsan_read1, btos));</span>
    // Rewrite bytecode to be faster
    if (!is_static &amp;&amp; rc == may_rewrite) {
      patch_bytecode(Bytecodes::_fast_bgetfield, bc, rbx);
    }
    __ jmp(Done);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2909,10 ***</span>
<span class="line-new-header">--- 3062,12 ---</span>
    __ jcc(Assembler::notEqual, notBool);
  
    // ztos (same code as btos)
    __ access_load_at(T_BOOLEAN, IN_HEAP, rax, field, noreg, noreg);
    __ push(ztos);
<span class="line-added">+   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">+       field, rdx, SharedRuntime::tsan_read1, ztos));</span>
    // Rewrite bytecode to be faster
    if (!is_static &amp;&amp; rc == may_rewrite) {
      // use btos rewriting, no truncating to t/f bit is needed for getfield.
      patch_bytecode(Bytecodes::_fast_bgetfield, bc, rbx);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2922,10 ***</span>
<span class="line-new-header">--- 3077,14 ---</span>
    __ cmpl(flags, atos);
    __ jcc(Assembler::notEqual, notObj);
    // atos
    do_oop_load(_masm, field, rax);
    __ push(atos);
<span class="line-added">+   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">+       field, rdx, UseCompressedOops ? SharedRuntime::tsan_read4</span>
<span class="line-added">+                                     : SharedRuntime::tsan_read8,</span>
<span class="line-added">+       atos));</span>
    if (!is_static &amp;&amp; rc == may_rewrite) {
      patch_bytecode(Bytecodes::_fast_agetfield, bc, rbx);
    }
    __ jmp(Done);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2933,10 ***</span>
<span class="line-new-header">--- 3092,12 ---</span>
    __ cmpl(flags, itos);
    __ jcc(Assembler::notEqual, notInt);
    // itos
    __ access_load_at(T_INT, IN_HEAP, rax, field, noreg, noreg);
    __ push(itos);
<span class="line-added">+   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">+       field, rdx, SharedRuntime::tsan_read4, itos));</span>
    // Rewrite bytecode to be faster
    if (!is_static &amp;&amp; rc == may_rewrite) {
      patch_bytecode(Bytecodes::_fast_igetfield, bc, rbx);
    }
    __ jmp(Done);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2945,10 ***</span>
<span class="line-new-header">--- 3106,12 ---</span>
    __ cmpl(flags, ctos);
    __ jcc(Assembler::notEqual, notChar);
    // ctos
    __ access_load_at(T_CHAR, IN_HEAP, rax, field, noreg, noreg);
    __ push(ctos);
<span class="line-added">+   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">+       field, rdx, SharedRuntime::tsan_read2, ctos));</span>
    // Rewrite bytecode to be faster
    if (!is_static &amp;&amp; rc == may_rewrite) {
      patch_bytecode(Bytecodes::_fast_cgetfield, bc, rbx);
    }
    __ jmp(Done);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2957,10 ***</span>
<span class="line-new-header">--- 3120,12 ---</span>
    __ cmpl(flags, stos);
    __ jcc(Assembler::notEqual, notShort);
    // stos
    __ access_load_at(T_SHORT, IN_HEAP, rax, field, noreg, noreg);
    __ push(stos);
<span class="line-added">+   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">+       field, rdx, SharedRuntime::tsan_read2, stos));</span>
    // Rewrite bytecode to be faster
    if (!is_static &amp;&amp; rc == may_rewrite) {
      patch_bytecode(Bytecodes::_fast_sgetfield, bc, rbx);
    }
    __ jmp(Done);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2971,10 ***</span>
<span class="line-new-header">--- 3136,12 ---</span>
    // ltos
      // Generate code as if volatile (x86_32).  There just aren&#39;t enough registers to
      // save that information and this code is faster than the test.
    __ access_load_at(T_LONG, IN_HEAP | MO_RELAXED, noreg /* ltos */, field, noreg, noreg);
    __ push(ltos);
<span class="line-added">+   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">+       field, rdx, SharedRuntime::tsan_read8, ltos));</span>
    // Rewrite bytecode to be faster
    LP64_ONLY(if (!is_static &amp;&amp; rc == may_rewrite) patch_bytecode(Bytecodes::_fast_lgetfield, bc, rbx));
    __ jmp(Done);
  
    __ bind(notLong);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2982,10 ***</span>
<span class="line-new-header">--- 3149,12 ---</span>
    __ jcc(Assembler::notEqual, notFloat);
    // ftos
  
    __ access_load_at(T_FLOAT, IN_HEAP, noreg /* ftos */, field, noreg, noreg);
    __ push(ftos);
<span class="line-added">+   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">+       field, rdx, SharedRuntime::tsan_read4, ftos));</span>
    // Rewrite bytecode to be faster
    if (!is_static &amp;&amp; rc == may_rewrite) {
      patch_bytecode(Bytecodes::_fast_fgetfield, bc, rbx);
    }
    __ jmp(Done);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2998,10 ***</span>
<span class="line-new-header">--- 3167,12 ---</span>
  #endif
    // dtos
    // MO_RELAXED: for the case of volatile field, in fact it adds no extra work for the underlying implementation
    __ access_load_at(T_DOUBLE, IN_HEAP | MO_RELAXED, noreg /* dtos */, field, noreg, noreg);
    __ push(dtos);
<span class="line-added">+   TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">+       field, rdx, SharedRuntime::tsan_read8, dtos));</span>
    // Rewrite bytecode to be faster
    if (!is_static &amp;&amp; rc == may_rewrite) {
      patch_bytecode(Bytecodes::_fast_dgetfield, bc, rbx);
    }
  #ifdef ASSERT
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3133,12 ***</span>
    // volatile_barrier(Assembler::Membar_mask_bits(Assembler::LoadStore |
    //                                              Assembler::StoreStore));
  
    Label notVolatile, Done;
    __ movl(rdx, flags);
<span class="line-removed">-   __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);</span>
<span class="line-removed">-   __ andl(rdx, 0x1);</span>
  
    // Check for volatile store
    __ testl(rdx, rdx);
    __ jcc(Assembler::zero, notVolatile);
  
<span class="line-new-header">--- 3304,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3174,10 ***</span>
<span class="line-new-header">--- 3343,12 ---</span>
  
    // btos
    {
      __ pop(btos);
      if (!is_static) pop_and_check_object(obj);
<span class="line-added">+     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">+         field, rdx, SharedRuntime::tsan_write1, btos));</span>
      __ access_store_at(T_BYTE, IN_HEAP, field, rax, noreg, noreg);
      if (!is_static &amp;&amp; rc == may_rewrite) {
        patch_bytecode(Bytecodes::_fast_bputfield, bc, rbx, true, byte_no);
      }
      __ jmp(Done);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3189,10 ***</span>
<span class="line-new-header">--- 3360,12 ---</span>
  
    // ztos
    {
      __ pop(ztos);
      if (!is_static) pop_and_check_object(obj);
<span class="line-added">+     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">+         field, rdx, SharedRuntime::tsan_write1, ztos));</span>
      __ access_store_at(T_BOOLEAN, IN_HEAP, field, rax, noreg, noreg);
      if (!is_static &amp;&amp; rc == may_rewrite) {
        patch_bytecode(Bytecodes::_fast_zputfield, bc, rbx, true, byte_no);
      }
      __ jmp(Done);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3204,10 ***</span>
<span class="line-new-header">--- 3377,14 ---</span>
  
    // atos
    {
      __ pop(atos);
      if (!is_static) pop_and_check_object(obj);
<span class="line-added">+     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, rdx,</span>
<span class="line-added">+         UseCompressedOops ? SharedRuntime::tsan_write4</span>
<span class="line-added">+                           : SharedRuntime::tsan_write8,</span>
<span class="line-added">+         atos));</span>
      // Store into the field
      do_oop_store(_masm, field, rax);
      if (!is_static &amp;&amp; rc == may_rewrite) {
        patch_bytecode(Bytecodes::_fast_aputfield, bc, rbx, true, byte_no);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3220,10 ***</span>
<span class="line-new-header">--- 3397,12 ---</span>
  
    // itos
    {
      __ pop(itos);
      if (!is_static) pop_and_check_object(obj);
<span class="line-added">+     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">+         field, rdx, SharedRuntime::tsan_write4, itos));</span>
      __ access_store_at(T_INT, IN_HEAP, field, rax, noreg, noreg);
      if (!is_static &amp;&amp; rc == may_rewrite) {
        patch_bytecode(Bytecodes::_fast_iputfield, bc, rbx, true, byte_no);
      }
      __ jmp(Done);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3235,10 ***</span>
<span class="line-new-header">--- 3414,12 ---</span>
  
    // ctos
    {
      __ pop(ctos);
      if (!is_static) pop_and_check_object(obj);
<span class="line-added">+     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">+         field, rdx, SharedRuntime::tsan_write2, ctos));</span>
      __ access_store_at(T_CHAR, IN_HEAP, field, rax, noreg, noreg);
      if (!is_static &amp;&amp; rc == may_rewrite) {
        patch_bytecode(Bytecodes::_fast_cputfield, bc, rbx, true, byte_no);
      }
      __ jmp(Done);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3250,10 ***</span>
<span class="line-new-header">--- 3431,12 ---</span>
  
    // stos
    {
      __ pop(stos);
      if (!is_static) pop_and_check_object(obj);
<span class="line-added">+     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">+         field, rdx, SharedRuntime::tsan_write2, stos));</span>
      __ access_store_at(T_SHORT, IN_HEAP, field, rax, noreg, noreg);
      if (!is_static &amp;&amp; rc == may_rewrite) {
        patch_bytecode(Bytecodes::_fast_sputfield, bc, rbx, true, byte_no);
      }
      __ jmp(Done);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3265,10 ***</span>
<span class="line-new-header">--- 3448,12 ---</span>
  
    // ltos
    {
      __ pop(ltos);
      if (!is_static) pop_and_check_object(obj);
<span class="line-added">+     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">+         field, rdx, SharedRuntime::tsan_write8, ltos));</span>
      // MO_RELAXED: generate atomic store for the case of volatile field (important for x86_32)
      __ access_store_at(T_LONG, IN_HEAP | MO_RELAXED, field, noreg /* ltos*/, noreg, noreg);
  #ifdef _LP64
      if (!is_static &amp;&amp; rc == may_rewrite) {
        patch_bytecode(Bytecodes::_fast_lputfield, bc, rbx, true, byte_no);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3283,10 ***</span>
<span class="line-new-header">--- 3468,12 ---</span>
  
    // ftos
    {
      __ pop(ftos);
      if (!is_static) pop_and_check_object(obj);
<span class="line-added">+     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">+         field, rdx, SharedRuntime::tsan_write4, ftos));</span>
      __ access_store_at(T_FLOAT, IN_HEAP, field, noreg /* ftos */, noreg, noreg);
      if (!is_static &amp;&amp; rc == may_rewrite) {
        patch_bytecode(Bytecodes::_fast_fputfield, bc, rbx, true, byte_no);
      }
      __ jmp(Done);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3301,10 ***</span>
<span class="line-new-header">--- 3488,12 ---</span>
  
    // dtos
    {
      __ pop(dtos);
      if (!is_static) pop_and_check_object(obj);
<span class="line-added">+     TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(</span>
<span class="line-added">+         field, rdx, SharedRuntime::tsan_write8, dtos));</span>
      // MO_RELAXED: for the case of volatile field, in fact it adds no extra work for the underlying implementation
      __ access_store_at(T_DOUBLE, IN_HEAP | MO_RELAXED, field, noreg /* dtos */, noreg, noreg);
      if (!is_static &amp;&amp; rc == may_rewrite) {
        patch_bytecode(Bytecodes::_fast_dputfield, bc, rbx, true, byte_no);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4124,10 ***</span>
<span class="line-new-header">--- 4313,18 ---</span>
        __ call_VM_leaf(
             CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc), rax);
        __ pop(atos);
      }
  
<span class="line-added">+     TSAN_RUNTIME_ONLY(</span>
<span class="line-added">+       // return value of new oop is in rax.</span>
<span class="line-added">+       __ push(atos);</span>
<span class="line-added">+       __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::tsan_track_obj),</span>
<span class="line-added">+                       rax);</span>
<span class="line-added">+       __ pop(atos);</span>
<span class="line-added">+     );</span>
<span class="line-added">+ </span>
      __ jmp(done);
    }
  
    // slow case
    __ bind(slow_case);
</pre>
<center><a href="sharedRuntime_x86_64.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../os_cpu/linux_x86/os_linux_x86.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
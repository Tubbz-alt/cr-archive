<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/native/libjli/java.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /*
  27  * Shared source for &#39;java&#39; command line tool.
  28  *
  29  * If JAVA_ARGS is defined, then acts as a launcher for applications. For
  30  * instance, the JDK command line tools such as javac and javadoc (see
  31  * makefiles for more details) are built with this program.  Any arguments
  32  * prefixed with &#39;-J&#39; will be passed directly to the &#39;java&#39; command.
  33  */
  34 
  35 /*
  36  * One job of the launcher is to remove command line options which the
  37  * vm does not understand and will not process.  These options include
  38  * options which select which style of vm is run (e.g. -client and
  39  * -server) as well as options which select the data model to use.
  40  * Additionally, for tools which invoke an underlying vm &quot;-J-foo&quot;
  41  * options are turned into &quot;-foo&quot; options to the vm.  This option
  42  * filtering is handled in a number of places in the launcher, some of
  43  * it in machine-dependent code.  In this file, the function
  44  * CheckJvmType removes vm style options and TranslateApplicationArgs
  45  * removes &quot;-J&quot; prefixes.  The CreateExecutionEnvironment function processes
  46  * and removes -d&lt;n&gt; options. On unix, there is a possibility that the running
  47  * data model may not match to the desired data model, in this case an exec is
  48  * required to start the desired model. If the data models match, then
  49  * ParseArguments will remove the -d&lt;n&gt; flags. If the data models do not match
  50  * the CreateExecutionEnviroment will remove the -d&lt;n&gt; flags.
  51  */
  52 
  53 
  54 #include &quot;java.h&quot;
  55 #include &quot;jni.h&quot;
  56 
  57 /*
  58  * A NOTE TO DEVELOPERS: For performance reasons it is important that
  59  * the program image remain relatively small until after SelectVersion
  60  * CreateExecutionEnvironment have finished their possibly recursive
  61  * processing. Watch everything, but resist all temptations to use Java
  62  * interfaces.
  63  */
  64 
  65 #define USE_STDERR JNI_TRUE     /* we usually print to stderr */
  66 #define USE_STDOUT JNI_FALSE
  67 
  68 static jboolean printVersion = JNI_FALSE; /* print and exit */
  69 static jboolean showVersion = JNI_FALSE;  /* print but continue */
  70 static jboolean printUsage = JNI_FALSE;   /* print and exit*/
  71 static jboolean printTo = USE_STDERR;     /* where to print version/usage */
  72 static jboolean printXUsage = JNI_FALSE;  /* print and exit*/
  73 static jboolean dryRun = JNI_FALSE;       /* initialize VM and exit */
  74 static char     *showSettings = NULL;     /* print but continue */
  75 static jboolean showResolvedModules = JNI_FALSE;
  76 static jboolean listModules = JNI_FALSE;
  77 static char     *describeModule = NULL;
  78 static jboolean validateModules = JNI_FALSE;
  79 
  80 static const char *_program_name;
  81 static const char *_launcher_name;
  82 static jboolean _is_java_args = JNI_FALSE;
  83 static jboolean _have_classpath = JNI_FALSE;
  84 static const char *_fVersion;
  85 static jboolean _wc_enabled = JNI_FALSE;
  86 
  87 /*
  88  * Entries for splash screen environment variables.
  89  * putenv is performed in SelectVersion. We need
  90  * them in memory until UnsetEnv, so they are made static
  91  * global instead of auto local.
  92  */
  93 static char* splash_file_entry = NULL;
  94 static char* splash_jar_entry = NULL;
  95 
  96 /*
  97  * List of VM options to be specified when the VM is created.
  98  */
  99 static JavaVMOption *options;
 100 static int numOptions, maxOptions;
 101 
 102 /*
 103  * Prototypes for functions internal to launcher.
 104  */
<a name="1" id="anc1"></a><span class="line-added"> 105 static const char* GetFullVersion();</span>
<span class="line-added"> 106 static jboolean IsJavaArgs();</span>
<span class="line-added"> 107 static void SetJavaLauncherProp();</span>
 108 static void SetClassPath(const char *s);
 109 static void SetMainModule(const char *s);
 110 static void SelectVersion(int argc, char **argv, char **main_class);
 111 static void SetJvmEnvironment(int argc, char **argv);
 112 static jboolean ParseArguments(int *pargc, char ***pargv,
 113                                int *pmode, char **pwhat,
 114                                int *pret, const char *jrepath);
 115 static jboolean InitializeJVM(JavaVM **pvm, JNIEnv **penv,
 116                               InvocationFunctions *ifn);
 117 static jstring NewPlatformString(JNIEnv *env, char *s);
 118 static jclass LoadMainClass(JNIEnv *env, int mode, char *name);
 119 static jclass GetApplicationClass(JNIEnv *env);
 120 
 121 static void TranslateApplicationArgs(int jargc, const char **jargv, int *pargc, char ***pargv);
 122 static jboolean AddApplicationOptions(int cpathc, const char **cpathv);
 123 static void SetApplicationClassPath(const char**);
 124 
 125 static void PrintJavaVersion(JNIEnv *env, jboolean extraLF);
 126 static void PrintUsage(JNIEnv* env, jboolean doXUsage);
 127 static void ShowSettings(JNIEnv* env, char *optString);
 128 static void ShowResolvedModules(JNIEnv* env);
 129 static void ListModules(JNIEnv* env);
 130 static void DescribeModule(JNIEnv* env, char* optString);
 131 static jboolean ValidateModules(JNIEnv* env);
 132 
 133 static void SetPaths(int argc, char **argv);
 134 
 135 static void DumpState();
 136 
 137 enum OptionKind {
 138     LAUNCHER_OPTION = 0,
 139     LAUNCHER_OPTION_WITH_ARGUMENT,
 140     LAUNCHER_MAIN_OPTION,
 141     VM_LONG_OPTION,
 142     VM_LONG_OPTION_WITH_ARGUMENT,
 143     VM_OPTION
 144 };
 145 
 146 static int GetOpt(int *pargc, char ***pargv, char **poption, char **pvalue);
 147 static jboolean IsOptionWithArgument(int argc, char **argv);
 148 
 149 /* Maximum supported entries from jvm.cfg. */
 150 #define INIT_MAX_KNOWN_VMS      10
 151 
 152 /* Values for vmdesc.flag */
 153 enum vmdesc_flag {
 154     VM_UNKNOWN = -1,
 155     VM_KNOWN,
 156     VM_ALIASED_TO,
 157     VM_WARN,
 158     VM_ERROR,
 159     VM_IF_SERVER_CLASS,
 160     VM_IGNORE
 161 };
 162 
 163 struct vmdesc {
 164     char *name;
 165     int flag;
 166     char *alias;
 167     char *server_class;
 168 };
 169 static struct vmdesc *knownVMs = NULL;
 170 static int knownVMsCount = 0;
 171 static int knownVMsLimit = 0;
 172 
 173 static void GrowKnownVMs(int minimum);
 174 static int  KnownVMIndex(const char* name);
 175 static void FreeKnownVMs();
 176 static jboolean IsWildCardEnabled();
 177 
 178 
 179 #define SOURCE_LAUNCHER_MAIN_ENTRY &quot;jdk.compiler/com.sun.tools.javac.launcher.Main&quot;
 180 
 181 /*
 182  * This reports error.  VM will not be created and no usage is printed.
 183  */
 184 #define REPORT_ERROR(AC_ok, AC_failure_message, AC_questionable_arg) \
 185     do { \
 186         if (!AC_ok) { \
 187             JLI_ReportErrorMessage(AC_failure_message, AC_questionable_arg); \
 188             printUsage = JNI_FALSE; \
 189             *pret = 1; \
 190             return JNI_FALSE; \
 191         } \
 192     } while (JNI_FALSE)
 193 
 194 #define ARG_CHECK(AC_arg_count, AC_failure_message, AC_questionable_arg) \
 195     do { \
 196         if (AC_arg_count &lt; 1) { \
 197             JLI_ReportErrorMessage(AC_failure_message, AC_questionable_arg); \
 198             printUsage = JNI_TRUE; \
 199             *pret = 1; \
 200             return JNI_TRUE; \
 201         } \
 202     } while (JNI_FALSE)
 203 
 204 /*
 205  * Running Java code in primordial thread caused many problems. We will
 206  * create a new thread to invoke JVM. See 6316197 for more information.
 207  */
 208 static jlong threadStackSize    = 0;  /* stack size of the new thread */
 209 static jlong maxHeapSize        = 0;  /* max heap size */
<a name="2" id="anc2"></a><span class="line-modified"> 210 static jlong initialHeapSize    = 0;  /* initial heap size */</span>
 211 
 212 /*
<a name="3" id="anc3"></a><span class="line-modified"> 213  * A minimum initial-thread stack size suitable for most platforms.</span>
<span class="line-modified"> 214  * This is the minimum amount of stack needed to load the JVM such</span>
<span class="line-added"> 215  * that it can reject a too small -Xss value. If this is too small</span>
<span class="line-added"> 216  * JVM initialization would cause a StackOverflowError.</span>
<span class="line-added"> 217   */</span>
 218 #ifndef STACK_SIZE_MINIMUM
 219 #define STACK_SIZE_MINIMUM (64 * KB)
 220 #endif
 221 
 222 #ifdef INCLUDE_TSAN
 223 /*
 224  * Function pointer to JVM&#39;s TSAN symbolize function.
 225  */
 226 __attribute__((visibility(&quot;default&quot;)))
 227 TsanSymbolize_t tsan_symbolize_func = NULL;
 228 #endif
 229 
 230 /*
 231  * Entry point.
 232  */
 233 JNIEXPORT int JNICALL
 234 JLI_Launch(int argc, char ** argv,              /* main argc, argv */
 235         int jargc, const char** jargv,          /* java args */
 236         int appclassc, const char** appclassv,  /* app classpath */
 237         const char* fullversion,                /* full version defined */
 238         const char* dotversion,                 /* UNUSED dot version defined */
 239         const char* pname,                      /* program name */
 240         const char* lname,                      /* launcher name */
 241         jboolean javaargs,                      /* JAVA_ARGS */
 242         jboolean cpwildcard,                    /* classpath wildcard*/
 243         jboolean javaw,                         /* windows-only javaw */
 244         jint ergo                               /* unused */
 245 )
 246 {
 247     int mode = LM_UNKNOWN;
 248     char *what = NULL;
 249     char *main_class = NULL;
 250     int ret;
 251     InvocationFunctions ifn;
 252     jlong start, end;
 253     char jvmpath[MAXPATHLEN];
 254     char jrepath[MAXPATHLEN];
 255     char jvmcfg[MAXPATHLEN];
 256 
 257     _fVersion = fullversion;
 258     _launcher_name = lname;
 259     _program_name = pname;
 260     _is_java_args = javaargs;
 261     _wc_enabled = cpwildcard;
 262 
 263     InitLauncher(javaw);
 264     DumpState();
 265     if (JLI_IsTraceLauncher()) {
 266         int i;
 267         printf(&quot;Java args:\n&quot;);
 268         for (i = 0; i &lt; jargc ; i++) {
 269             printf(&quot;jargv[%d] = %s\n&quot;, i, jargv[i]);
 270         }
 271         printf(&quot;Command line args:\n&quot;);
 272         for (i = 0; i &lt; argc ; i++) {
 273             printf(&quot;argv[%d] = %s\n&quot;, i, argv[i]);
 274         }
 275         AddOption(&quot;-Dsun.java.launcher.diag=true&quot;, NULL);
 276     }
 277 
 278     /*
 279      * SelectVersion() has several responsibilities:
 280      *
 281      *  1) Disallow specification of another JRE.  With 1.9, another
 282      *     version of the JRE cannot be invoked.
 283      *  2) Allow for a JRE version to invoke JDK 1.9 or later.  Since
 284      *     all mJRE directives have been stripped from the request but
 285      *     the pre 1.9 JRE [ 1.6 thru 1.8 ], it is as if 1.9+ has been
 286      *     invoked from the command line.
 287      */
 288     SelectVersion(argc, argv, &amp;main_class);
 289 
 290     CreateExecutionEnvironment(&amp;argc, &amp;argv,
 291                                jrepath, sizeof(jrepath),
 292                                jvmpath, sizeof(jvmpath),
 293                                jvmcfg,  sizeof(jvmcfg));
 294 
 295     if (!IsJavaArgs()) {
 296         SetJvmEnvironment(argc,argv);
 297     }
 298 
 299     ifn.CreateJavaVM = 0;
 300     ifn.GetDefaultJavaVMInitArgs = 0;
 301 
 302     if (JLI_IsTraceLauncher()) {
 303         start = CounterGet();
 304     }
 305 
 306     if (!LoadJavaVM(jvmpath, &amp;ifn)) {
 307         return(6);
 308     }
 309 #ifdef INCLUDE_TSAN
 310     tsan_symbolize_func = ifn.TsanSymbolize;
 311 #endif
 312 
 313     if (JLI_IsTraceLauncher()) {
 314         end   = CounterGet();
 315     }
 316 
 317     JLI_TraceLauncher(&quot;%ld micro seconds to LoadJavaVM\n&quot;,
 318              (long)(jint)Counter2Micros(end-start));
 319 
 320     ++argv;
 321     --argc;
 322 
 323     if (IsJavaArgs()) {
 324         /* Preprocess wrapper arguments */
 325         TranslateApplicationArgs(jargc, jargv, &amp;argc, &amp;argv);
 326         if (!AddApplicationOptions(appclassc, appclassv)) {
 327             return(1);
 328         }
 329     } else {
 330         /* Set default CLASSPATH */
 331         char* cpath = getenv(&quot;CLASSPATH&quot;);
 332         if (cpath != NULL) {
 333             SetClassPath(cpath);
 334         }
 335     }
 336 
 337     /* Parse command line options; if the return value of
 338      * ParseArguments is false, the program should exit.
 339      */
 340     if (!ParseArguments(&amp;argc, &amp;argv, &amp;mode, &amp;what, &amp;ret, jrepath)) {
 341         return(ret);
 342     }
 343 
 344     /* Override class path if -jar flag was specified */
 345     if (mode == LM_JAR) {
 346         SetClassPath(what);     /* Override class path */
 347     }
 348 
 349     /* set the -Dsun.java.command pseudo property */
 350     SetJavaCommandLineProp(what, argc, argv);
 351 
 352     /* Set the -Dsun.java.launcher pseudo property */
 353     SetJavaLauncherProp();
 354 
<a name="4" id="anc4"></a>


 355     return JVMInit(&amp;ifn, threadStackSize, argc, argv, mode, what, ret);
 356 }
 357 /*
 358  * Always detach the main thread so that it appears to have ended when
 359  * the application&#39;s main method exits.  This will invoke the
 360  * uncaught exception handler machinery if main threw an
 361  * exception.  An uncaught exception handler cannot change the
 362  * launcher&#39;s return code except by calling System.exit.
 363  *
 364  * Wait for all non-daemon threads to end, then destroy the VM.
 365  * This will actually create a trivial new Java waiter thread
 366  * named &quot;DestroyJavaVM&quot;, but this will be seen as a different
 367  * thread from the one that executed main, even though they are
 368  * the same C thread.  This allows mainThread.join() and
 369  * mainThread.isAlive() to work as expected.
 370  */
 371 #define LEAVE() \
 372     do { \
 373         if ((*vm)-&gt;DetachCurrentThread(vm) != JNI_OK) { \
 374             JLI_ReportErrorMessage(JVM_ERROR2); \
 375             ret = 1; \
 376         } \
 377         if (JNI_TRUE) { \
 378             (*vm)-&gt;DestroyJavaVM(vm); \
 379             return ret; \
 380         } \
 381     } while (JNI_FALSE)
 382 
 383 #define CHECK_EXCEPTION_NULL_LEAVE(CENL_exception) \
 384     do { \
 385         if ((*env)-&gt;ExceptionOccurred(env)) { \
 386             JLI_ReportExceptionDescription(env); \
 387             LEAVE(); \
 388         } \
 389         if ((CENL_exception) == NULL) { \
 390             JLI_ReportErrorMessage(JNI_ERROR); \
 391             LEAVE(); \
 392         } \
 393     } while (JNI_FALSE)
 394 
 395 #define CHECK_EXCEPTION_LEAVE(CEL_return_value) \
 396     do { \
 397         if ((*env)-&gt;ExceptionOccurred(env)) { \
 398             JLI_ReportExceptionDescription(env); \
 399             ret = (CEL_return_value); \
 400             LEAVE(); \
 401         } \
 402     } while (JNI_FALSE)
 403 
 404 
 405 int
 406 JavaMain(void* _args)
 407 {
 408     JavaMainArgs *args = (JavaMainArgs *)_args;
 409     int argc = args-&gt;argc;
 410     char **argv = args-&gt;argv;
 411     int mode = args-&gt;mode;
 412     char *what = args-&gt;what;
 413     InvocationFunctions ifn = args-&gt;ifn;
 414 
 415     JavaVM *vm = 0;
 416     JNIEnv *env = 0;
 417     jclass mainClass = NULL;
 418     jclass appClass = NULL; // actual application class being launched
 419     jmethodID mainID;
 420     jobjectArray mainArgs;
 421     int ret = 0;
 422     jlong start, end;
 423 
 424     RegisterThread();
 425 
 426     /* Initialize the virtual machine */
 427     start = CounterGet();
 428     if (!InitializeJVM(&amp;vm, &amp;env, &amp;ifn)) {
 429         JLI_ReportErrorMessage(JVM_ERROR1);
 430         exit(1);
 431     }
 432 
 433     if (showSettings != NULL) {
 434         ShowSettings(env, showSettings);
 435         CHECK_EXCEPTION_LEAVE(1);
 436     }
 437 
 438     // show resolved modules and continue
 439     if (showResolvedModules) {
 440         ShowResolvedModules(env);
 441         CHECK_EXCEPTION_LEAVE(1);
 442     }
 443 
 444     // list observable modules, then exit
 445     if (listModules) {
 446         ListModules(env);
 447         CHECK_EXCEPTION_LEAVE(1);
 448         LEAVE();
 449     }
 450 
 451     // describe a module, then exit
 452     if (describeModule != NULL) {
 453         DescribeModule(env, describeModule);
 454         CHECK_EXCEPTION_LEAVE(1);
 455         LEAVE();
 456     }
 457 
 458     if (printVersion || showVersion) {
 459         PrintJavaVersion(env, showVersion);
 460         CHECK_EXCEPTION_LEAVE(0);
 461         if (printVersion) {
 462             LEAVE();
 463         }
 464     }
 465 
 466     // modules have been validated at startup so exit
 467     if (validateModules) {
 468         LEAVE();
 469     }
 470 
 471     /* If the user specified neither a class name nor a JAR file */
 472     if (printXUsage || printUsage || what == 0 || mode == LM_UNKNOWN) {
 473         PrintUsage(env, printXUsage);
 474         CHECK_EXCEPTION_LEAVE(1);
 475         LEAVE();
 476     }
 477 
 478     FreeKnownVMs(); /* after last possible PrintUsage */
 479 
 480     if (JLI_IsTraceLauncher()) {
 481         end = CounterGet();
 482         JLI_TraceLauncher(&quot;%ld micro seconds to InitializeJVM\n&quot;,
 483                (long)(jint)Counter2Micros(end-start));
 484     }
 485 
 486     /* At this stage, argc/argv have the application&#39;s arguments */
 487     if (JLI_IsTraceLauncher()){
 488         int i;
 489         printf(&quot;%s is &#39;%s&#39;\n&quot;, launchModeNames[mode], what);
 490         printf(&quot;App&#39;s argc is %d\n&quot;, argc);
 491         for (i=0; i &lt; argc; i++) {
 492             printf(&quot;    argv[%2d] = &#39;%s&#39;\n&quot;, i, argv[i]);
 493         }
 494     }
 495 
 496     ret = 1;
 497 
 498     /*
 499      * Get the application&#39;s main class. It also checks if the main
 500      * method exists.
 501      *
 502      * See bugid 5030265.  The Main-Class name has already been parsed
 503      * from the manifest, but not parsed properly for UTF-8 support.
 504      * Hence the code here ignores the value previously extracted and
 505      * uses the pre-existing code to reextract the value.  This is
 506      * possibly an end of release cycle expedient.  However, it has
 507      * also been discovered that passing some character sets through
 508      * the environment has &quot;strange&quot; behavior on some variants of
 509      * Windows.  Hence, maybe the manifest parsing code local to the
 510      * launcher should never be enhanced.
 511      *
 512      * Hence, future work should either:
 513      *     1)   Correct the local parsing code and verify that the
 514      *          Main-Class attribute gets properly passed through
 515      *          all environments,
 516      *     2)   Remove the vestages of maintaining main_class through
 517      *          the environment (and remove these comments).
 518      *
 519      * This method also correctly handles launching existing JavaFX
 520      * applications that may or may not have a Main-Class manifest entry.
 521      */
 522     mainClass = LoadMainClass(env, mode, what);
 523     CHECK_EXCEPTION_NULL_LEAVE(mainClass);
 524     /*
 525      * In some cases when launching an application that needs a helper, e.g., a
 526      * JavaFX application with no main method, the mainClass will not be the
 527      * applications own main class but rather a helper class. To keep things
 528      * consistent in the UI we need to track and report the application main class.
 529      */
 530     appClass = GetApplicationClass(env);
 531     NULL_CHECK_RETURN_VALUE(appClass, -1);
 532 
 533     /* Build platform specific argument array */
 534     mainArgs = CreateApplicationArgs(env, argv, argc);
 535     CHECK_EXCEPTION_NULL_LEAVE(mainArgs);
 536 
 537     if (dryRun) {
 538         ret = 0;
 539         LEAVE();
 540     }
 541 
 542     /*
 543      * PostJVMInit uses the class name as the application name for GUI purposes,
 544      * for example, on OSX this sets the application name in the menu bar for
 545      * both SWT and JavaFX. So we&#39;ll pass the actual application class here
 546      * instead of mainClass as that may be a launcher or helper class instead
 547      * of the application class.
 548      */
 549     PostJVMInit(env, appClass, vm);
 550     CHECK_EXCEPTION_LEAVE(1);
 551 
 552     /*
 553      * The LoadMainClass not only loads the main class, it will also ensure
 554      * that the main method&#39;s signature is correct, therefore further checking
 555      * is not required. The main method is invoked here so that extraneous java
 556      * stacks are not in the application stack trace.
 557      */
 558     mainID = (*env)-&gt;GetStaticMethodID(env, mainClass, &quot;main&quot;,
 559                                        &quot;([Ljava/lang/String;)V&quot;);
 560     CHECK_EXCEPTION_NULL_LEAVE(mainID);
 561 
 562     /* Invoke main method. */
 563     (*env)-&gt;CallStaticVoidMethod(env, mainClass, mainID, mainArgs);
 564 
 565     /*
 566      * The launcher&#39;s exit code (in the absence of calls to
 567      * System.exit) will be non-zero if main threw an exception.
 568      */
 569     ret = (*env)-&gt;ExceptionOccurred(env) == NULL ? 0 : 1;
 570 
 571     LEAVE();
 572 }
 573 
 574 /*
 575  * Test if the given name is one of the class path options.
 576  */
 577 static jboolean
 578 IsClassPathOption(const char* name) {
 579     return JLI_StrCmp(name, &quot;-classpath&quot;) == 0 ||
 580            JLI_StrCmp(name, &quot;-cp&quot;) == 0 ||
 581            JLI_StrCmp(name, &quot;--class-path&quot;) == 0;
 582 }
 583 
 584 /*
 585  * Test if the given name is a launcher option taking the main entry point.
 586  */
 587 static jboolean
 588 IsLauncherMainOption(const char* name) {
 589     return JLI_StrCmp(name, &quot;--module&quot;) == 0 ||
 590            JLI_StrCmp(name, &quot;-m&quot;) == 0;
 591 }
 592 
 593 /*
 594  * Test if the given name is a white-space launcher option.
 595  */
 596 static jboolean
 597 IsLauncherOption(const char* name) {
 598     return IsClassPathOption(name) ||
 599            IsLauncherMainOption(name) ||
 600            JLI_StrCmp(name, &quot;--describe-module&quot;) == 0 ||
 601            JLI_StrCmp(name, &quot;-d&quot;) == 0 ||
 602            JLI_StrCmp(name, &quot;--source&quot;) == 0;
 603 }
 604 
 605 /*
 606  * Test if the given name is a module-system white-space option that
 607  * will be passed to the VM with its corresponding long-form option
 608  * name and &quot;=&quot; delimiter.
 609  */
 610 static jboolean
 611 IsModuleOption(const char* name) {
 612     return JLI_StrCmp(name, &quot;--module-path&quot;) == 0 ||
 613            JLI_StrCmp(name, &quot;-p&quot;) == 0 ||
 614            JLI_StrCmp(name, &quot;--upgrade-module-path&quot;) == 0 ||
 615            JLI_StrCmp(name, &quot;--add-modules&quot;) == 0 ||
 616            JLI_StrCmp(name, &quot;--limit-modules&quot;) == 0 ||
 617            JLI_StrCmp(name, &quot;--add-exports&quot;) == 0 ||
 618            JLI_StrCmp(name, &quot;--add-opens&quot;) == 0 ||
 619            JLI_StrCmp(name, &quot;--add-reads&quot;) == 0 ||
 620            JLI_StrCmp(name, &quot;--patch-module&quot;) == 0;
 621 }
 622 
 623 static jboolean
 624 IsLongFormModuleOption(const char* name) {
 625     return JLI_StrCCmp(name, &quot;--module-path=&quot;) == 0 ||
 626            JLI_StrCCmp(name, &quot;--upgrade-module-path=&quot;) == 0 ||
 627            JLI_StrCCmp(name, &quot;--add-modules=&quot;) == 0 ||
 628            JLI_StrCCmp(name, &quot;--limit-modules=&quot;) == 0 ||
 629            JLI_StrCCmp(name, &quot;--add-exports=&quot;) == 0 ||
 630            JLI_StrCCmp(name, &quot;--add-reads=&quot;) == 0 ||
 631            JLI_StrCCmp(name, &quot;--patch-module=&quot;) == 0;
 632 }
 633 
 634 /*
 635  * Test if the given name has a white space option.
 636  */
 637 jboolean
 638 IsWhiteSpaceOption(const char* name) {
 639     return IsModuleOption(name) ||
 640            IsLauncherOption(name);
 641 }
 642 
 643 /*
 644  * Check if it is OK to set the mode.
 645  * If the mode was previously set, and should not be changed,
 646  * a fatal error is reported.
 647  */
 648 static int
 649 checkMode(int mode, int newMode, const char *arg) {
 650     if (mode == LM_SOURCE) {
 651         JLI_ReportErrorMessage(ARG_ERROR14, arg);
 652         exit(1);
 653     }
 654     return newMode;
 655 }
 656 
 657 /*
 658  * Test if an arg identifies a source file.
 659  */
<a name="5" id="anc5"></a><span class="line-modified"> 660 static jboolean IsSourceFile(const char *arg) {</span>

 661     struct stat st;
 662     return (JLI_HasSuffix(arg, &quot;.java&quot;) &amp;&amp; stat(arg, &amp;st) == 0);
 663 }
 664 
 665 /*
 666  * Checks the command line options to find which JVM type was
 667  * specified.  If no command line option was given for the JVM type,
 668  * the default type is used.  The environment variable
 669  * JDK_ALTERNATE_VM and the command line option -XXaltjvm= are also
 670  * checked as ways of specifying which JVM type to invoke.
 671  */
 672 char *
 673 CheckJvmType(int *pargc, char ***argv, jboolean speculative) {
 674     int i, argi;
 675     int argc;
 676     char **newArgv;
 677     int newArgvIdx = 0;
 678     int isVMType;
 679     int jvmidx = -1;
 680     char *jvmtype = getenv(&quot;JDK_ALTERNATE_VM&quot;);
 681 
 682     argc = *pargc;
 683 
 684     /* To make things simpler we always copy the argv array */
 685     newArgv = JLI_MemAlloc((argc + 1) * sizeof(char *));
 686 
 687     /* The program name is always present */
 688     newArgv[newArgvIdx++] = (*argv)[0];
 689 
 690     for (argi = 1; argi &lt; argc; argi++) {
 691         char *arg = (*argv)[argi];
 692         isVMType = 0;
 693 
 694         if (IsJavaArgs()) {
 695             if (arg[0] != &#39;-&#39;) {
 696                 newArgv[newArgvIdx++] = arg;
 697                 continue;
 698             }
 699         } else {
 700             if (IsWhiteSpaceOption(arg)) {
 701                 newArgv[newArgvIdx++] = arg;
 702                 argi++;
 703                 if (argi &lt; argc) {
 704                     newArgv[newArgvIdx++] = (*argv)[argi];
 705                 }
 706                 continue;
 707             }
 708             if (arg[0] != &#39;-&#39;) break;
 709         }
 710 
 711         /* Did the user pass an explicit VM type? */
 712         i = KnownVMIndex(arg);
 713         if (i &gt;= 0) {
 714             jvmtype = knownVMs[jvmidx = i].name + 1; /* skip the - */
 715             isVMType = 1;
 716             *pargc = *pargc - 1;
 717         }
 718 
 719         /* Did the user specify an &quot;alternate&quot; VM? */
 720         else if (JLI_StrCCmp(arg, &quot;-XXaltjvm=&quot;) == 0 || JLI_StrCCmp(arg, &quot;-J-XXaltjvm=&quot;) == 0) {
 721             isVMType = 1;
 722             jvmtype = arg+((arg[1]==&#39;X&#39;)? 10 : 12);
 723             jvmidx = -1;
 724         }
 725 
 726         if (!isVMType) {
 727             newArgv[newArgvIdx++] = arg;
 728         }
 729     }
 730 
 731     /*
 732      * Finish copying the arguments if we aborted the above loop.
 733      * NOTE that if we aborted via &quot;break&quot; then we did NOT copy the
 734      * last argument above, and in addition argi will be less than
 735      * argc.
 736      */
 737     while (argi &lt; argc) {
 738         newArgv[newArgvIdx++] = (*argv)[argi];
 739         argi++;
 740     }
 741 
 742     /* argv is null-terminated */
 743     newArgv[newArgvIdx] = 0;
 744 
 745     /* Copy back argv */
 746     *argv = newArgv;
 747     *pargc = newArgvIdx;
 748 
 749     /* use the default VM type if not specified (no alias processing) */
 750     if (jvmtype == NULL) {
 751       char* result = knownVMs[0].name+1;
 752       JLI_TraceLauncher(&quot;Default VM: %s\n&quot;, result);
 753       return result;
 754     }
 755 
 756     /* if using an alternate VM, no alias processing */
 757     if (jvmidx &lt; 0)
 758       return jvmtype;
 759 
 760     /* Resolve aliases first */
 761     {
 762       int loopCount = 0;
 763       while (knownVMs[jvmidx].flag == VM_ALIASED_TO) {
 764         int nextIdx = KnownVMIndex(knownVMs[jvmidx].alias);
 765 
 766         if (loopCount &gt; knownVMsCount) {
 767           if (!speculative) {
 768             JLI_ReportErrorMessage(CFG_ERROR1);
 769             exit(1);
 770           } else {
 771             return &quot;ERROR&quot;;
 772             /* break; */
 773           }
 774         }
 775 
 776         if (nextIdx &lt; 0) {
 777           if (!speculative) {
 778             JLI_ReportErrorMessage(CFG_ERROR2, knownVMs[jvmidx].alias);
 779             exit(1);
 780           } else {
 781             return &quot;ERROR&quot;;
 782           }
 783         }
 784         jvmidx = nextIdx;
 785         jvmtype = knownVMs[jvmidx].name+1;
 786         loopCount++;
 787       }
 788     }
 789 
 790     switch (knownVMs[jvmidx].flag) {
 791     case VM_WARN:
 792         if (!speculative) {
 793             JLI_ReportErrorMessage(CFG_WARN1, jvmtype, knownVMs[0].name + 1);
 794         }
 795         /* fall through */
 796     case VM_IGNORE:
 797         jvmtype = knownVMs[jvmidx=0].name + 1;
 798         /* fall through */
 799     case VM_KNOWN:
 800         break;
 801     case VM_ERROR:
 802         if (!speculative) {
 803             JLI_ReportErrorMessage(CFG_ERROR3, jvmtype);
 804             exit(1);
 805         } else {
 806             return &quot;ERROR&quot;;
 807         }
 808     }
 809 
 810     return jvmtype;
 811 }
 812 
 813 /*
 814  * This method must be called before the VM is loaded, primarily
 815  * used to parse and set any VM related options or env variables.
 816  * This function is non-destructive leaving the argument list intact.
 817  */
 818 static void
 819 SetJvmEnvironment(int argc, char **argv) {
 820 
 821     static const char*  NMT_Env_Name    = &quot;NMT_LEVEL_&quot;;
 822     int i;
 823     /* process only the launcher arguments */
 824     for (i = 0; i &lt; argc; i++) {
 825         char *arg = argv[i];
 826         /*
 827          * Since this must be a VM flag we stop processing once we see
 828          * an argument the launcher would not have processed beyond (such
 829          * as -version or -h), or an argument that indicates the following
 830          * arguments are for the application (i.e. the main class name, or
 831          * the -jar argument).
 832          */
 833         if (i &gt; 0) {
 834             char *prev = argv[i - 1];
 835             // skip non-dash arg preceded by class path specifiers
 836             if (*arg != &#39;-&#39; &amp;&amp; IsWhiteSpaceOption(prev)) {
 837                 continue;
 838             }
 839 
 840             if (*arg != &#39;-&#39; || isTerminalOpt(arg)) {
 841                 return;
 842             }
 843         }
 844         /*
 845          * The following case checks for &quot;-XX:NativeMemoryTracking=value&quot;.
 846          * If value is non null, an environmental variable set to this value
 847          * will be created to be used by the JVM.
 848          * The argument is passed to the JVM, which will check validity.
 849          * The JVM is responsible for removing the env variable.
 850          */
 851         if (JLI_StrCCmp(arg, &quot;-XX:NativeMemoryTracking=&quot;) == 0) {
 852             int retval;
 853             // get what follows this parameter, include &quot;=&quot;
 854             size_t pnlen = JLI_StrLen(&quot;-XX:NativeMemoryTracking=&quot;);
 855             if (JLI_StrLen(arg) &gt; pnlen) {
 856                 char* value = arg + pnlen;
 857                 size_t pbuflen = pnlen + JLI_StrLen(value) + 10; // 10 max pid digits
 858 
 859                 /*
 860                  * ensures that malloc successful
 861                  * DONT JLI_MemFree() pbuf.  JLI_PutEnv() uses system call
 862                  *   that could store the address.
 863                  */
 864                 char * pbuf = (char*)JLI_MemAlloc(pbuflen);
 865 
 866                 JLI_Snprintf(pbuf, pbuflen, &quot;%s%d=%s&quot;, NMT_Env_Name, JLI_GetPid(), value);
 867                 retval = JLI_PutEnv(pbuf);
 868                 if (JLI_IsTraceLauncher()) {
 869                     char* envName;
 870                     char* envBuf;
 871 
 872                     // ensures that malloc successful
 873                     envName = (char*)JLI_MemAlloc(pbuflen);
 874                     JLI_Snprintf(envName, pbuflen, &quot;%s%d&quot;, NMT_Env_Name, JLI_GetPid());
 875 
 876                     printf(&quot;TRACER_MARKER: NativeMemoryTracking: env var is %s\n&quot;,envName);
 877                     printf(&quot;TRACER_MARKER: NativeMemoryTracking: putenv arg %s\n&quot;,pbuf);
 878                     envBuf = getenv(envName);
 879                     printf(&quot;TRACER_MARKER: NativeMemoryTracking: got value %s\n&quot;,envBuf);
 880                     free(envName);
 881                 }
 882             }
 883         }
 884     }
 885 }
 886 
 887 /* copied from HotSpot function &quot;atomll()&quot; */
 888 static int
 889 parse_size(const char *s, jlong *result) {
 890   jlong n = 0;
 891   int args_read = sscanf(s, JLONG_FORMAT_SPECIFIER, &amp;n);
 892   if (args_read != 1) {
 893     return 0;
 894   }
 895   while (*s != &#39;\0&#39; &amp;&amp; *s &gt;= &#39;0&#39; &amp;&amp; *s &lt;= &#39;9&#39;) {
 896     s++;
 897   }
 898   // 4705540: illegal if more characters are found after the first non-digit
 899   if (JLI_StrLen(s) &gt; 1) {
 900     return 0;
 901   }
 902   switch (*s) {
 903     case &#39;T&#39;: case &#39;t&#39;:
 904       *result = n * GB * KB;
 905       return 1;
 906     case &#39;G&#39;: case &#39;g&#39;:
 907       *result = n * GB;
 908       return 1;
 909     case &#39;M&#39;: case &#39;m&#39;:
 910       *result = n * MB;
 911       return 1;
 912     case &#39;K&#39;: case &#39;k&#39;:
 913       *result = n * KB;
 914       return 1;
 915     case &#39;\0&#39;:
 916       *result = n;
 917       return 1;
 918     default:
 919       /* Create JVM with default stack and let VM handle malformed -Xss string*/
 920       return 0;
 921   }
 922 }
 923 
 924 /*
 925  * Adds a new VM option with the given name and value.
 926  */
 927 void
 928 AddOption(char *str, void *info)
 929 {
 930     /*
 931      * Expand options array if needed to accommodate at least one more
 932      * VM option.
 933      */
 934     if (numOptions &gt;= maxOptions) {
 935         if (options == 0) {
 936             maxOptions = 4;
 937             options = JLI_MemAlloc(maxOptions * sizeof(JavaVMOption));
 938         } else {
 939             JavaVMOption *tmp;
 940             maxOptions *= 2;
 941             tmp = JLI_MemAlloc(maxOptions * sizeof(JavaVMOption));
 942             memcpy(tmp, options, numOptions * sizeof(JavaVMOption));
 943             JLI_MemFree(options);
 944             options = tmp;
 945         }
 946     }
 947     options[numOptions].optionString = str;
 948     options[numOptions++].extraInfo = info;
 949 
<a name="6" id="anc6"></a><span class="line-added"> 950     /*</span>
<span class="line-added"> 951      * -Xss is used both by the JVM and here to establish the stack size of the thread</span>
<span class="line-added"> 952      * created to launch the JVM. In the latter case we need to ensure we don&#39;t go</span>
<span class="line-added"> 953      * below the minimum stack size allowed. If -Xss is zero that tells the JVM to use</span>
<span class="line-added"> 954      * &#39;default&#39; sizes (either from JVM or system configuration, e.g. &#39;ulimit -s&#39; on linux),</span>
<span class="line-added"> 955      * and is not itself a small stack size that will be rejected. So we ignore -Xss0 here.</span>
<span class="line-added"> 956      */</span>
 957     if (JLI_StrCCmp(str, &quot;-Xss&quot;) == 0) {
 958         jlong tmp;
 959         if (parse_size(str + 4, &amp;tmp)) {
 960             threadStackSize = tmp;
<a name="7" id="anc7"></a><span class="line-modified"> 961             if (threadStackSize &gt; 0 &amp;&amp; threadStackSize &lt; (jlong)STACK_SIZE_MINIMUM) {</span>





 962                 threadStackSize = STACK_SIZE_MINIMUM;
 963             }
 964         }
 965     }
 966 
 967     if (JLI_StrCCmp(str, &quot;-Xmx&quot;) == 0) {
 968         jlong tmp;
 969         if (parse_size(str + 4, &amp;tmp)) {
 970             maxHeapSize = tmp;
 971         }
 972     }
 973 
 974     if (JLI_StrCCmp(str, &quot;-Xms&quot;) == 0) {
 975         jlong tmp;
 976         if (parse_size(str + 4, &amp;tmp)) {
 977            initialHeapSize = tmp;
 978         }
 979     }
 980 }
 981 
 982 static void
 983 SetClassPath(const char *s)
 984 {
 985     char *def;
 986     const char *orig = s;
 987     static const char format[] = &quot;-Djava.class.path=%s&quot;;
 988     /*
 989      * usually we should not get a null pointer, but there are cases where
 990      * we might just get one, in which case we simply ignore it, and let the
 991      * caller deal with it
 992      */
 993     if (s == NULL)
 994         return;
 995     s = JLI_WildcardExpandClasspath(s);
 996     if (sizeof(format) - 2 + JLI_StrLen(s) &lt; JLI_StrLen(s))
 997         // s is became corrupted after expanding wildcards
 998         return;
 999     def = JLI_MemAlloc(sizeof(format)
1000                        - 2 /* strlen(&quot;%s&quot;) */
1001                        + JLI_StrLen(s));
1002     sprintf(def, format, s);
1003     AddOption(def, NULL);
1004     if (s != orig)
1005         JLI_MemFree((char *) s);
1006     _have_classpath = JNI_TRUE;
1007 }
1008 
1009 static void
1010 AddLongFormOption(const char *option, const char *arg)
1011 {
1012     static const char format[] = &quot;%s=%s&quot;;
1013     char *def;
1014     size_t def_len;
1015 
1016     def_len = JLI_StrLen(option) + 1 + JLI_StrLen(arg) + 1;
1017     def = JLI_MemAlloc(def_len);
1018     JLI_Snprintf(def, def_len, format, option, arg);
1019     AddOption(def, NULL);
1020 }
1021 
1022 static void
1023 SetMainModule(const char *s)
1024 {
1025     static const char format[] = &quot;-Djdk.module.main=%s&quot;;
1026     char* slash = JLI_StrChr(s, &#39;/&#39;);
1027     size_t s_len, def_len;
1028     char *def;
1029 
1030     /* value may be &lt;module&gt; or &lt;module&gt;/&lt;mainclass&gt; */
1031     if (slash == NULL) {
1032         s_len = JLI_StrLen(s);
1033     } else {
1034         s_len = (size_t) (slash - s);
1035     }
1036     def_len = sizeof(format)
1037                - 2 /* strlen(&quot;%s&quot;) */
1038                + s_len;
1039     def = JLI_MemAlloc(def_len);
1040     JLI_Snprintf(def, def_len, format, s);
1041     AddOption(def, NULL);
1042 }
1043 
1044 /*
1045  * The SelectVersion() routine ensures that an appropriate version of
1046  * the JRE is running.  The specification for the appropriate version
1047  * is obtained from either the manifest of a jar file (preferred) or
1048  * from command line options.
1049  * The routine also parses splash screen command line options and
1050  * passes on their values in private environment variables.
1051  */
1052 static void
1053 SelectVersion(int argc, char **argv, char **main_class)
1054 {
1055     char    *arg;
1056     char    *operand;
1057     char    *version = NULL;
1058     char    *jre = NULL;
1059     int     jarflag = 0;
1060     int     headlessflag = 0;
1061     int     restrict_search = -1;               /* -1 implies not known */
1062     manifest_info info;
1063     char    env_entry[MAXNAMELEN + 24] = ENV_ENTRY &quot;=&quot;;
1064     char    *splash_file_name = NULL;
1065     char    *splash_jar_name = NULL;
1066     char    *env_in;
1067     int     res;
1068     jboolean has_arg;
1069 
1070     /*
1071      * If the version has already been selected, set *main_class
1072      * with the value passed through the environment (if any) and
1073      * simply return.
1074      */
1075 
1076     /*
1077      * This environmental variable can be set by mJRE capable JREs
1078      * [ 1.5 thru 1.8 ].  All other aspects of mJRE processing have been
1079      * stripped by those JREs.  This environmental variable allows 1.9+
1080      * JREs to be started by these mJRE capable JREs.
1081      * Note that mJRE directives in the jar manifest file would have been
1082      * ignored for a JRE started by another JRE...
1083      * .. skipped for JRE 1.5 and beyond.
1084      * .. not even checked for pre 1.5.
1085      */
1086     if ((env_in = getenv(ENV_ENTRY)) != NULL) {
1087         if (*env_in != &#39;\0&#39;)
1088             *main_class = JLI_StringDup(env_in);
1089         return;
1090     }
1091 
1092     /*
1093      * Scan through the arguments for options relevant to multiple JRE
1094      * support.  Multiple JRE support existed in JRE versions 1.5 thru 1.8.
1095      *
1096      * This capability is no longer available with JRE versions 1.9 and later.
1097      * These command line options are reported as errors.
1098      */
1099 
1100     argc--;
1101     argv++;
1102     while ((arg = *argv) != 0 &amp;&amp; *arg == &#39;-&#39;) {
1103         has_arg = IsOptionWithArgument(argc, argv);
1104         if (JLI_StrCCmp(arg, &quot;-version:&quot;) == 0) {
1105             JLI_ReportErrorMessage(SPC_ERROR1);
1106         } else if (JLI_StrCmp(arg, &quot;-jre-restrict-search&quot;) == 0) {
1107             JLI_ReportErrorMessage(SPC_ERROR2);
1108         } else if (JLI_StrCmp(arg, &quot;-jre-no-restrict-search&quot;) == 0) {
1109             JLI_ReportErrorMessage(SPC_ERROR2);
1110         } else {
1111             if (JLI_StrCmp(arg, &quot;-jar&quot;) == 0)
1112                 jarflag = 1;
1113             if (IsWhiteSpaceOption(arg)) {
1114                 if (has_arg) {
1115                     argc--;
1116                     argv++;
1117                     arg = *argv;
1118                 }
1119             }
1120 
1121             /*
1122              * Checking for headless toolkit option in the some way as AWT does:
1123              * &quot;true&quot; means true and any other value means false
1124              */
1125             if (JLI_StrCmp(arg, &quot;-Djava.awt.headless=true&quot;) == 0) {
1126                 headlessflag = 1;
1127             } else if (JLI_StrCCmp(arg, &quot;-Djava.awt.headless=&quot;) == 0) {
1128                 headlessflag = 0;
1129             } else if (JLI_StrCCmp(arg, &quot;-splash:&quot;) == 0) {
1130                 splash_file_name = arg+8;
1131             }
1132         }
1133         argc--;
1134         argv++;
1135     }
1136     if (argc &lt;= 0) {    /* No operand? Possibly legit with -[full]version */
1137         operand = NULL;
1138     } else {
1139         argc--;
1140         operand = *argv++;
1141     }
1142 
1143     /*
1144      * If there is a jar file, read the manifest. If the jarfile can&#39;t be
1145      * read, the manifest can&#39;t be read from the jar file, or the manifest
1146      * is corrupt, issue the appropriate error messages and exit.
1147      *
1148      * Even if there isn&#39;t a jar file, construct a manifest_info structure
1149      * containing the command line information.  It&#39;s a convenient way to carry
1150      * this data around.
1151      */
1152     if (jarflag &amp;&amp; operand) {
1153         if ((res = JLI_ParseManifest(operand, &amp;info)) != 0) {
1154             if (res == -1)
1155                 JLI_ReportErrorMessage(JAR_ERROR2, operand);
1156             else
1157                 JLI_ReportErrorMessage(JAR_ERROR3, operand);
1158             exit(1);
1159         }
1160 
1161         /*
1162          * Command line splash screen option should have precedence
1163          * over the manifest, so the manifest data is used only if
1164          * splash_file_name has not been initialized above during command
1165          * line parsing
1166          */
1167         if (!headlessflag &amp;&amp; !splash_file_name &amp;&amp; info.splashscreen_image_file_name) {
1168             splash_file_name = info.splashscreen_image_file_name;
1169             splash_jar_name = operand;
1170         }
1171     } else {
1172         info.manifest_version = NULL;
1173         info.main_class = NULL;
1174         info.jre_version = NULL;
1175         info.jre_restrict_search = 0;
1176     }
1177 
1178     /*
1179      * Passing on splash screen info in environment variables
1180      */
1181     if (splash_file_name &amp;&amp; !headlessflag) {
<a name="8" id="anc8"></a><span class="line-modified">1182         splash_file_entry = JLI_MemAlloc(JLI_StrLen(SPLASH_FILE_ENV_ENTRY &quot;=&quot;)+JLI_StrLen(splash_file_name)+1);</span>
1183         JLI_StrCpy(splash_file_entry, SPLASH_FILE_ENV_ENTRY &quot;=&quot;);
1184         JLI_StrCat(splash_file_entry, splash_file_name);
1185         putenv(splash_file_entry);
1186     }
1187     if (splash_jar_name &amp;&amp; !headlessflag) {
<a name="9" id="anc9"></a><span class="line-modified">1188         splash_jar_entry = JLI_MemAlloc(JLI_StrLen(SPLASH_JAR_ENV_ENTRY &quot;=&quot;)+JLI_StrLen(splash_jar_name)+1);</span>
1189         JLI_StrCpy(splash_jar_entry, SPLASH_JAR_ENV_ENTRY &quot;=&quot;);
1190         JLI_StrCat(splash_jar_entry, splash_jar_name);
1191         putenv(splash_jar_entry);
1192     }
1193 
1194 
1195     /*
1196      * &quot;Valid&quot; returns (other than unrecoverable errors) follow.  Set
1197      * main_class as a side-effect of this routine.
1198      */
1199     if (info.main_class != NULL)
1200         *main_class = JLI_StringDup(info.main_class);
1201 
1202     if (info.jre_version == NULL) {
1203         JLI_FreeManifest();
1204         return;
1205     }
1206 
1207 }
1208 
1209 /*
1210  * Test if the current argv is an option, i.e. with a leading `-`
1211  * and followed with an argument without a leading `-`.
1212  */
1213 static jboolean
1214 IsOptionWithArgument(int argc, char** argv) {
1215     char* option;
1216     char* arg;
1217 
1218     if (argc &lt;= 1)
1219         return JNI_FALSE;
1220 
1221     option = *argv;
1222     arg = *(argv+1);
1223     return *option == &#39;-&#39; &amp;&amp; *arg != &#39;-&#39;;
1224 }
1225 
1226 /*
1227  * Gets the option, and its argument if the option has an argument.
1228  * It will update *pargc, **pargv to the next option.
1229  */
1230 static int
1231 GetOpt(int *pargc, char ***pargv, char **poption, char **pvalue) {
1232     int argc = *pargc;
1233     char** argv = *pargv;
1234     char* arg = *argv;
1235 
1236     char* option = arg;
1237     char* value = NULL;
1238     char* equals = NULL;
1239     int kind = LAUNCHER_OPTION;
1240     jboolean has_arg = JNI_FALSE;
1241 
1242     // check if this option may be a white-space option with an argument
1243     has_arg = IsOptionWithArgument(argc, argv);
1244 
1245     argv++; --argc;
1246     if (IsLauncherOption(arg)) {
1247         if (has_arg) {
1248             value = *argv;
1249             argv++; --argc;
1250         }
1251         kind = IsLauncherMainOption(arg) ? LAUNCHER_MAIN_OPTION
1252                                          : LAUNCHER_OPTION_WITH_ARGUMENT;
1253     } else if (IsModuleOption(arg)) {
1254         kind = VM_LONG_OPTION_WITH_ARGUMENT;
1255         if (has_arg) {
1256             value = *argv;
1257             argv++; --argc;
1258         }
1259 
1260         /*
1261          * Support short form alias
1262          */
1263         if (JLI_StrCmp(arg, &quot;-p&quot;) == 0) {
1264             option = &quot;--module-path&quot;;
1265         }
1266 
1267     } else if (JLI_StrCCmp(arg, &quot;--&quot;) == 0 &amp;&amp; (equals = JLI_StrChr(arg, &#39;=&#39;)) != NULL) {
1268         value = equals+1;
1269         if (JLI_StrCCmp(arg, &quot;--describe-module=&quot;) == 0 ||
1270             JLI_StrCCmp(arg, &quot;--module=&quot;) == 0 ||
1271             JLI_StrCCmp(arg, &quot;--class-path=&quot;) == 0||
1272             JLI_StrCCmp(arg, &quot;--source=&quot;) == 0) {
1273             kind = LAUNCHER_OPTION_WITH_ARGUMENT;
1274         } else {
1275             kind = VM_LONG_OPTION;
1276         }
1277     }
1278 
1279     *pargc = argc;
1280     *pargv = argv;
1281     *poption = option;
1282     *pvalue = value;
1283     return kind;
1284 }
1285 
1286 /*
1287  * Parses command line arguments.  Returns JNI_FALSE if launcher
1288  * should exit without starting vm, returns JNI_TRUE if vm needs
1289  * to be started to process given options.  *pret (the launcher
1290  * process return value) is set to 0 for a normal exit.
1291  */
1292 static jboolean
1293 ParseArguments(int *pargc, char ***pargv,
1294                int *pmode, char **pwhat,
1295                int *pret, const char *jrepath)
1296 {
1297     int argc = *pargc;
1298     char **argv = *pargv;
1299     int mode = LM_UNKNOWN;
1300     char *arg;
1301 
1302     *pret = 0;
1303 
1304     while ((arg = *argv) != 0 &amp;&amp; *arg == &#39;-&#39;) {
1305         char *option = NULL;
1306         char *value = NULL;
1307         int kind = GetOpt(&amp;argc, &amp;argv, &amp;option, &amp;value);
1308         jboolean has_arg = value != NULL &amp;&amp; JLI_StrLen(value) &gt; 0;
1309         jboolean has_arg_any_len = value != NULL;
1310 
1311 /*
1312  * Option to set main entry point
1313  */
1314         if (JLI_StrCmp(arg, &quot;-jar&quot;) == 0) {
1315             ARG_CHECK(argc, ARG_ERROR2, arg);
1316             mode = checkMode(mode, LM_JAR, arg);
1317         } else if (JLI_StrCmp(arg, &quot;--module&quot;) == 0 ||
1318                    JLI_StrCCmp(arg, &quot;--module=&quot;) == 0 ||
1319                    JLI_StrCmp(arg, &quot;-m&quot;) == 0) {
1320             REPORT_ERROR (has_arg, ARG_ERROR5, arg);
1321             SetMainModule(value);
1322             mode = checkMode(mode, LM_MODULE, arg);
1323             if (has_arg) {
1324                *pwhat = value;
1325                 break;
1326             }
1327         } else if (JLI_StrCmp(arg, &quot;--source&quot;) == 0 ||
1328                    JLI_StrCCmp(arg, &quot;--source=&quot;) == 0) {
1329             REPORT_ERROR (has_arg, ARG_ERROR13, arg);
1330             mode = LM_SOURCE;
1331             if (has_arg) {
1332                 const char *prop = &quot;-Djdk.internal.javac.source=&quot;;
1333                 size_t size = JLI_StrLen(prop) + JLI_StrLen(value) + 1;
1334                 char *propValue = (char *)JLI_MemAlloc(size);
1335                 JLI_Snprintf(propValue, size, &quot;%s%s&quot;, prop, value);
1336                 AddOption(propValue, NULL);
1337             }
1338         } else if (JLI_StrCmp(arg, &quot;--class-path&quot;) == 0 ||
1339                    JLI_StrCCmp(arg, &quot;--class-path=&quot;) == 0 ||
1340                    JLI_StrCmp(arg, &quot;-classpath&quot;) == 0 ||
1341                    JLI_StrCmp(arg, &quot;-cp&quot;) == 0) {
1342             REPORT_ERROR (has_arg_any_len, ARG_ERROR1, arg);
1343             SetClassPath(value);
1344             if (mode != LM_SOURCE) {
1345                 mode = LM_CLASS;
1346             }
1347         } else if (JLI_StrCmp(arg, &quot;--list-modules&quot;) == 0) {
1348             listModules = JNI_TRUE;
1349         } else if (JLI_StrCmp(arg, &quot;--show-resolved-modules&quot;) == 0) {
1350             showResolvedModules = JNI_TRUE;
1351         } else if (JLI_StrCmp(arg, &quot;--validate-modules&quot;) == 0) {
1352             AddOption(&quot;-Djdk.module.validation=true&quot;, NULL);
1353             validateModules = JNI_TRUE;
1354         } else if (JLI_StrCmp(arg, &quot;--describe-module&quot;) == 0 ||
1355                    JLI_StrCCmp(arg, &quot;--describe-module=&quot;) == 0 ||
1356                    JLI_StrCmp(arg, &quot;-d&quot;) == 0) {
1357             REPORT_ERROR (has_arg_any_len, ARG_ERROR12, arg);
1358             describeModule = value;
1359 /*
1360  * Parse white-space options
1361  */
1362         } else if (has_arg) {
1363             if (kind == VM_LONG_OPTION) {
1364                 AddOption(option, NULL);
1365             } else if (kind == VM_LONG_OPTION_WITH_ARGUMENT) {
1366                 AddLongFormOption(option, value);
1367             }
1368 /*
1369  * Error missing argument
1370  */
1371         } else if (!has_arg &amp;&amp; (JLI_StrCmp(arg, &quot;--module-path&quot;) == 0 ||
1372                                 JLI_StrCmp(arg, &quot;-p&quot;) == 0 ||
1373                                 JLI_StrCmp(arg, &quot;--upgrade-module-path&quot;) == 0)) {
1374             REPORT_ERROR (has_arg, ARG_ERROR4, arg);
1375 
1376         } else if (!has_arg &amp;&amp; (IsModuleOption(arg) || IsLongFormModuleOption(arg))) {
1377             REPORT_ERROR (has_arg, ARG_ERROR6, arg);
1378 /*
1379  * The following cases will cause the argument parsing to stop
1380  */
1381         } else if (JLI_StrCmp(arg, &quot;-help&quot;) == 0 ||
1382                    JLI_StrCmp(arg, &quot;-h&quot;) == 0 ||
1383                    JLI_StrCmp(arg, &quot;-?&quot;) == 0) {
1384             printUsage = JNI_TRUE;
1385             return JNI_TRUE;
1386         } else if (JLI_StrCmp(arg, &quot;--help&quot;) == 0) {
1387             printUsage = JNI_TRUE;
1388             printTo = USE_STDOUT;
1389             return JNI_TRUE;
1390         } else if (JLI_StrCmp(arg, &quot;-version&quot;) == 0) {
1391             printVersion = JNI_TRUE;
1392             return JNI_TRUE;
1393         } else if (JLI_StrCmp(arg, &quot;--version&quot;) == 0) {
1394             printVersion = JNI_TRUE;
1395             printTo = USE_STDOUT;
1396             return JNI_TRUE;
1397         } else if (JLI_StrCmp(arg, &quot;-showversion&quot;) == 0) {
1398             showVersion = JNI_TRUE;
1399         } else if (JLI_StrCmp(arg, &quot;--show-version&quot;) == 0) {
1400             showVersion = JNI_TRUE;
1401             printTo = USE_STDOUT;
1402         } else if (JLI_StrCmp(arg, &quot;--dry-run&quot;) == 0) {
1403             dryRun = JNI_TRUE;
1404         } else if (JLI_StrCmp(arg, &quot;-X&quot;) == 0) {
1405             printXUsage = JNI_TRUE;
1406             return JNI_TRUE;
1407         } else if (JLI_StrCmp(arg, &quot;--help-extra&quot;) == 0) {
1408             printXUsage = JNI_TRUE;
1409             printTo = USE_STDOUT;
1410             return JNI_TRUE;
1411 /*
1412  * The following case checks for -XshowSettings OR -XshowSetting:SUBOPT.
1413  * In the latter case, any SUBOPT value not recognized will default to &quot;all&quot;
1414  */
1415         } else if (JLI_StrCmp(arg, &quot;-XshowSettings&quot;) == 0 ||
1416                    JLI_StrCCmp(arg, &quot;-XshowSettings:&quot;) == 0) {
1417             showSettings = arg;
1418         } else if (JLI_StrCmp(arg, &quot;-Xdiag&quot;) == 0) {
1419             AddOption(&quot;-Dsun.java.launcher.diag=true&quot;, NULL);
1420         } else if (JLI_StrCmp(arg, &quot;--show-module-resolution&quot;) == 0) {
1421             AddOption(&quot;-Djdk.module.showModuleResolution=true&quot;, NULL);
1422 /*
1423  * The following case provide backward compatibility with old-style
1424  * command line options.
1425  */
1426         } else if (JLI_StrCmp(arg, &quot;-fullversion&quot;) == 0) {
1427             JLI_ReportMessage(&quot;%s full version \&quot;%s\&quot;&quot;, _launcher_name, GetFullVersion());
1428             return JNI_FALSE;
1429         } else if (JLI_StrCmp(arg, &quot;--full-version&quot;) == 0) {
1430             JLI_ShowMessage(&quot;%s %s&quot;, _launcher_name, GetFullVersion());
1431             return JNI_FALSE;
1432         } else if (JLI_StrCmp(arg, &quot;-verbosegc&quot;) == 0) {
1433             AddOption(&quot;-verbose:gc&quot;, NULL);
1434         } else if (JLI_StrCmp(arg, &quot;-t&quot;) == 0) {
1435             AddOption(&quot;-Xt&quot;, NULL);
1436         } else if (JLI_StrCmp(arg, &quot;-tm&quot;) == 0) {
1437             AddOption(&quot;-Xtm&quot;, NULL);
1438         } else if (JLI_StrCmp(arg, &quot;-debug&quot;) == 0) {
1439             AddOption(&quot;-Xdebug&quot;, NULL);
1440         } else if (JLI_StrCmp(arg, &quot;-noclassgc&quot;) == 0) {
1441             AddOption(&quot;-Xnoclassgc&quot;, NULL);
1442         } else if (JLI_StrCmp(arg, &quot;-Xfuture&quot;) == 0) {
<a name="10" id="anc10"></a><span class="line-added">1443             JLI_ReportErrorMessage(ARG_DEPRECATED, &quot;-Xfuture&quot;);</span>
1444             AddOption(&quot;-Xverify:all&quot;, NULL);
1445         } else if (JLI_StrCmp(arg, &quot;-verify&quot;) == 0) {
1446             AddOption(&quot;-Xverify:all&quot;, NULL);
1447         } else if (JLI_StrCmp(arg, &quot;-verifyremote&quot;) == 0) {
1448             AddOption(&quot;-Xverify:remote&quot;, NULL);
1449         } else if (JLI_StrCmp(arg, &quot;-noverify&quot;) == 0) {
<a name="11" id="anc11"></a><span class="line-added">1450             /*</span>
<span class="line-added">1451              * Note that no &#39;deprecated&#39; message is needed here because the VM</span>
<span class="line-added">1452              * issues &#39;deprecated&#39; messages for -noverify and -Xverify:none.</span>
<span class="line-added">1453              */</span>
1454             AddOption(&quot;-Xverify:none&quot;, NULL);
1455         } else if (JLI_StrCCmp(arg, &quot;-ss&quot;) == 0 ||
1456                    JLI_StrCCmp(arg, &quot;-oss&quot;) == 0 ||
1457                    JLI_StrCCmp(arg, &quot;-ms&quot;) == 0 ||
1458                    JLI_StrCCmp(arg, &quot;-mx&quot;) == 0) {
1459             char *tmp = JLI_MemAlloc(JLI_StrLen(arg) + 6);
1460             sprintf(tmp, &quot;-X%s&quot;, arg + 1); /* skip &#39;-&#39; */
1461             AddOption(tmp, NULL);
1462         } else if (JLI_StrCmp(arg, &quot;-checksource&quot;) == 0 ||
1463                    JLI_StrCmp(arg, &quot;-cs&quot;) == 0 ||
1464                    JLI_StrCmp(arg, &quot;-noasyncgc&quot;) == 0) {
1465             /* No longer supported */
1466             JLI_ReportErrorMessage(ARG_WARN, arg);
1467         } else if (JLI_StrCCmp(arg, &quot;-splash:&quot;) == 0) {
1468             ; /* Ignore machine independent options already handled */
1469         } else if (ProcessPlatformOption(arg)) {
1470             ; /* Processing of platform dependent options */
1471         } else {
1472             /* java.class.path set on the command line */
1473             if (JLI_StrCCmp(arg, &quot;-Djava.class.path=&quot;) == 0) {
1474                 _have_classpath = JNI_TRUE;
1475             }
1476             AddOption(arg, NULL);
1477         }
1478     }
1479 
1480     if (*pwhat == NULL &amp;&amp; --argc &gt;= 0) {
1481         *pwhat = *argv++;
1482     }
1483 
1484     if (*pwhat == NULL) {
1485         /* LM_UNKNOWN okay for options that exit */
1486         if (!listModules &amp;&amp; !describeModule &amp;&amp; !validateModules) {
1487             *pret = 1;
1488         }
1489     } else if (mode == LM_UNKNOWN) {
1490         /* default to LM_CLASS if -m, -jar and -cp options are
1491          * not specified */
1492         if (!_have_classpath) {
1493             SetClassPath(&quot;.&quot;);
1494         }
1495         mode = IsSourceFile(arg) ? LM_SOURCE : LM_CLASS;
1496     } else if (mode == LM_CLASS &amp;&amp; IsSourceFile(arg)) {
1497         /* override LM_CLASS mode if given a source file */
1498         mode = LM_SOURCE;
1499     }
1500 
1501     if (mode == LM_SOURCE) {
1502         AddOption(&quot;--add-modules=ALL-DEFAULT&quot;, NULL);
1503         *pwhat = SOURCE_LAUNCHER_MAIN_ENTRY;
1504         // adjust (argc, argv) so that the name of the source file
1505         // is included in the args passed to the source launcher
1506         // main entry class
1507         *pargc = argc + 1;
1508         *pargv = argv - 1;
1509     } else {
1510         if (argc &gt;= 0) {
1511             *pargc = argc;
1512             *pargv = argv;
1513         }
1514     }
1515 
1516     *pmode = mode;
1517 
1518     return JNI_TRUE;
1519 }
1520 
1521 /*
1522  * Initializes the Java Virtual Machine. Also frees options array when
1523  * finished.
1524  */
1525 static jboolean
1526 InitializeJVM(JavaVM **pvm, JNIEnv **penv, InvocationFunctions *ifn)
1527 {
1528     JavaVMInitArgs args;
1529     jint r;
1530 
1531     memset(&amp;args, 0, sizeof(args));
1532     args.version  = JNI_VERSION_1_2;
1533     args.nOptions = numOptions;
1534     args.options  = options;
1535     args.ignoreUnrecognized = JNI_FALSE;
1536 
1537     if (JLI_IsTraceLauncher()) {
1538         int i = 0;
1539         printf(&quot;JavaVM args:\n    &quot;);
1540         printf(&quot;version 0x%08lx, &quot;, (long)args.version);
1541         printf(&quot;ignoreUnrecognized is %s, &quot;,
1542                args.ignoreUnrecognized ? &quot;JNI_TRUE&quot; : &quot;JNI_FALSE&quot;);
1543         printf(&quot;nOptions is %ld\n&quot;, (long)args.nOptions);
1544         for (i = 0; i &lt; numOptions; i++)
1545             printf(&quot;    option[%2d] = &#39;%s&#39;\n&quot;,
1546                    i, args.options[i].optionString);
1547     }
1548 
1549     r = ifn-&gt;CreateJavaVM(pvm, (void **)penv, &amp;args);
1550     JLI_MemFree(options);
1551     return r == JNI_OK;
1552 }
1553 
1554 static jclass helperClass = NULL;
1555 
1556 jclass
1557 GetLauncherHelperClass(JNIEnv *env)
1558 {
1559     if (helperClass == NULL) {
1560         NULL_CHECK0(helperClass = FindBootStrapClass(env,
1561                 &quot;sun/launcher/LauncherHelper&quot;));
1562     }
1563     return helperClass;
1564 }
1565 
1566 static jmethodID makePlatformStringMID = NULL;
1567 /*
1568  * Returns a new Java string object for the specified platform string.
1569  */
1570 static jstring
1571 NewPlatformString(JNIEnv *env, char *s)
1572 {
1573     int len = (int)JLI_StrLen(s);
1574     jbyteArray ary;
1575     jclass cls = GetLauncherHelperClass(env);
1576     NULL_CHECK0(cls);
1577     if (s == NULL)
1578         return 0;
1579 
1580     ary = (*env)-&gt;NewByteArray(env, len);
1581     if (ary != 0) {
1582         jstring str = 0;
1583         (*env)-&gt;SetByteArrayRegion(env, ary, 0, len, (jbyte *)s);
1584         if (!(*env)-&gt;ExceptionOccurred(env)) {
1585             if (makePlatformStringMID == NULL) {
1586                 NULL_CHECK0(makePlatformStringMID = (*env)-&gt;GetStaticMethodID(env,
1587                         cls, &quot;makePlatformString&quot;, &quot;(Z[B)Ljava/lang/String;&quot;));
1588             }
1589             str = (*env)-&gt;CallStaticObjectMethod(env, cls,
1590                     makePlatformStringMID, USE_STDERR, ary);
1591             CHECK_EXCEPTION_RETURN_VALUE(0);
1592             (*env)-&gt;DeleteLocalRef(env, ary);
1593             return str;
1594         }
1595     }
1596     return 0;
1597 }
1598 
1599 /*
1600  * Returns a new array of Java string objects for the specified
1601  * array of platform strings.
1602  */
1603 jobjectArray
1604 NewPlatformStringArray(JNIEnv *env, char **strv, int strc)
1605 {
1606     jarray cls;
1607     jarray ary;
1608     int i;
1609 
1610     NULL_CHECK0(cls = FindBootStrapClass(env, &quot;java/lang/String&quot;));
1611     NULL_CHECK0(ary = (*env)-&gt;NewObjectArray(env, strc, cls, 0));
1612     CHECK_EXCEPTION_RETURN_VALUE(0);
1613     for (i = 0; i &lt; strc; i++) {
1614         jstring str = NewPlatformString(env, *strv++);
1615         NULL_CHECK0(str);
1616         (*env)-&gt;SetObjectArrayElement(env, ary, i, str);
1617         (*env)-&gt;DeleteLocalRef(env, str);
1618     }
1619     return ary;
1620 }
1621 
1622 /*
1623  * Loads a class and verifies that the main class is present and it is ok to
1624  * call it for more details refer to the java implementation.
1625  */
1626 static jclass
1627 LoadMainClass(JNIEnv *env, int mode, char *name)
1628 {
1629     jmethodID mid;
1630     jstring str;
1631     jobject result;
1632     jlong start, end;
1633     jclass cls = GetLauncherHelperClass(env);
1634     NULL_CHECK0(cls);
1635     if (JLI_IsTraceLauncher()) {
1636         start = CounterGet();
1637     }
1638     NULL_CHECK0(mid = (*env)-&gt;GetStaticMethodID(env, cls,
1639                 &quot;checkAndLoadMain&quot;,
1640                 &quot;(ZILjava/lang/String;)Ljava/lang/Class;&quot;));
1641 
1642     NULL_CHECK0(str = NewPlatformString(env, name));
1643     NULL_CHECK0(result = (*env)-&gt;CallStaticObjectMethod(env, cls, mid,
1644                                                         USE_STDERR, mode, str));
1645 
1646     if (JLI_IsTraceLauncher()) {
1647         end   = CounterGet();
1648         printf(&quot;%ld micro seconds to load main class\n&quot;,
1649                (long)(jint)Counter2Micros(end-start));
1650         printf(&quot;----%s----\n&quot;, JLDEBUG_ENV_ENTRY);
1651     }
1652 
1653     return (jclass)result;
1654 }
1655 
1656 static jclass
1657 GetApplicationClass(JNIEnv *env)
1658 {
1659     jmethodID mid;
1660     jclass appClass;
1661     jclass cls = GetLauncherHelperClass(env);
1662     NULL_CHECK0(cls);
1663     NULL_CHECK0(mid = (*env)-&gt;GetStaticMethodID(env, cls,
1664                 &quot;getApplicationClass&quot;,
1665                 &quot;()Ljava/lang/Class;&quot;));
1666 
1667     appClass = (*env)-&gt;CallStaticObjectMethod(env, cls, mid);
1668     CHECK_EXCEPTION_RETURN_VALUE(0);
1669     return appClass;
1670 }
1671 
1672 static char* expandWildcardOnLongOpt(char* arg) {
1673     char *p, *value;
1674     size_t optLen, valueLen;
1675     p = JLI_StrChr(arg, &#39;=&#39;);
1676 
1677     if (p == NULL || p[1] == &#39;\0&#39;) {
1678         JLI_ReportErrorMessage(ARG_ERROR1, arg);
1679         exit(1);
1680     }
1681     p++;
1682     value = (char *) JLI_WildcardExpandClasspath(p);
1683     if (p == value) {
1684         // no wildcard
1685         return arg;
1686     }
1687 
1688     optLen = p - arg;
1689     valueLen = JLI_StrLen(value);
1690     p = JLI_MemAlloc(optLen + valueLen + 1);
1691     memcpy(p, arg, optLen);
1692     memcpy(p + optLen, value, valueLen);
1693     p[optLen + valueLen] = &#39;\0&#39;;
1694     return p;
1695 }
1696 
1697 /*
1698  * For tools, convert command line args thus:
1699  *   javac -cp foo:foo/&quot;*&quot; -J-ms32m ...
1700  *   java -ms32m -cp JLI_WildcardExpandClasspath(foo:foo/&quot;*&quot;) ...
1701  *
1702  * Takes 4 parameters, and returns the populated arguments
1703  */
1704 static void
1705 TranslateApplicationArgs(int jargc, const char **jargv, int *pargc, char ***pargv)
1706 {
1707     int argc = *pargc;
1708     char **argv = *pargv;
1709     int nargc = argc + jargc;
1710     char **nargv = JLI_MemAlloc((nargc + 1) * sizeof(char *));
1711     int i;
1712 
1713     *pargc = nargc;
1714     *pargv = nargv;
1715 
1716     /* Copy the VM arguments (i.e. prefixed with -J) */
1717     for (i = 0; i &lt; jargc; i++) {
1718         const char *arg = jargv[i];
1719         if (arg[0] == &#39;-&#39; &amp;&amp; arg[1] == &#39;J&#39;) {
1720             *nargv++ = ((arg + 2) == NULL) ? NULL : JLI_StringDup(arg + 2);
1721         }
1722     }
1723 
1724     for (i = 0; i &lt; argc; i++) {
1725         char *arg = argv[i];
1726         if (arg[0] == &#39;-&#39; &amp;&amp; arg[1] == &#39;J&#39;) {
1727             if (arg[2] == &#39;\0&#39;) {
1728                 JLI_ReportErrorMessage(ARG_ERROR3);
1729                 exit(1);
1730             }
1731             *nargv++ = arg + 2;
1732         }
1733     }
1734 
1735     /* Copy the rest of the arguments */
1736     for (i = 0; i &lt; jargc ; i++) {
1737         const char *arg = jargv[i];
1738         if (arg[0] != &#39;-&#39; || arg[1] != &#39;J&#39;) {
1739             *nargv++ = (arg == NULL) ? NULL : JLI_StringDup(arg);
1740         }
1741     }
1742     for (i = 0; i &lt; argc; i++) {
1743         char *arg = argv[i];
1744         if (arg[0] == &#39;-&#39;) {
1745             if (arg[1] == &#39;J&#39;)
1746                 continue;
1747             if (IsWildCardEnabled()) {
1748                 if (IsClassPathOption(arg) &amp;&amp; i &lt; argc - 1) {
1749                     *nargv++ = arg;
1750                     *nargv++ = (char *) JLI_WildcardExpandClasspath(argv[i+1]);
1751                     i++;
1752                     continue;
1753                 }
1754                 if (JLI_StrCCmp(arg, &quot;--class-path=&quot;) == 0) {
1755                     *nargv++ = expandWildcardOnLongOpt(arg);
1756                     continue;
1757                 }
1758             }
1759         }
1760         *nargv++ = arg;
1761     }
1762     *nargv = 0;
1763 }
1764 
1765 /*
1766  * For our tools, we try to add 3 VM options:
1767  *      -Denv.class.path=&lt;envcp&gt;
1768  *      -Dapplication.home=&lt;apphome&gt;
1769  *      -Djava.class.path=&lt;appcp&gt;
1770  * &lt;envcp&gt;   is the user&#39;s setting of CLASSPATH -- for instance the user
1771  *           tells javac where to find binary classes through this environment
1772  *           variable.  Notice that users will be able to compile against our
1773  *           tools classes (sun.tools.javac.Main) only if they explicitly add
1774  *           tools.jar to CLASSPATH.
1775  * &lt;apphome&gt; is the directory where the application is installed.
1776  * &lt;appcp&gt;   is the classpath to where our apps&#39; classfiles are.
1777  */
1778 static jboolean
1779 AddApplicationOptions(int cpathc, const char **cpathv)
1780 {
1781     char *envcp, *appcp, *apphome;
1782     char home[MAXPATHLEN]; /* application home */
1783     char separator[] = { PATH_SEPARATOR, &#39;\0&#39; };
1784     int size, i;
1785 
1786     {
1787         const char *s = getenv(&quot;CLASSPATH&quot;);
1788         if (s) {
1789             s = (char *) JLI_WildcardExpandClasspath(s);
1790             /* 40 for -Denv.class.path= */
1791             if (JLI_StrLen(s) + 40 &gt; JLI_StrLen(s)) { // Safeguard from overflow
1792                 envcp = (char *)JLI_MemAlloc(JLI_StrLen(s) + 40);
1793                 sprintf(envcp, &quot;-Denv.class.path=%s&quot;, s);
1794                 AddOption(envcp, NULL);
1795             }
1796         }
1797     }
1798 
1799     if (!GetApplicationHome(home, sizeof(home))) {
1800         JLI_ReportErrorMessage(CFG_ERROR5);
1801         return JNI_FALSE;
1802     }
1803 
1804     /* 40 for &#39;-Dapplication.home=&#39; */
1805     apphome = (char *)JLI_MemAlloc(JLI_StrLen(home) + 40);
1806     sprintf(apphome, &quot;-Dapplication.home=%s&quot;, home);
1807     AddOption(apphome, NULL);
1808 
1809     /* How big is the application&#39;s classpath? */
1810     if (cpathc &gt; 0) {
1811         size = 40;                                 /* 40: &quot;-Djava.class.path=&quot; */
1812         for (i = 0; i &lt; cpathc; i++) {
1813             size += (int)JLI_StrLen(home) + (int)JLI_StrLen(cpathv[i]) + 1; /* 1: separator */
1814         }
1815         appcp = (char *)JLI_MemAlloc(size + 1);
1816         JLI_StrCpy(appcp, &quot;-Djava.class.path=&quot;);
1817         for (i = 0; i &lt; cpathc; i++) {
1818             JLI_StrCat(appcp, home);                        /* c:\program files\myapp */
1819             JLI_StrCat(appcp, cpathv[i]);           /* \lib\myapp.jar         */
1820             JLI_StrCat(appcp, separator);           /* ;                      */
1821         }
1822         appcp[JLI_StrLen(appcp)-1] = &#39;\0&#39;;  /* remove trailing path separator */
1823         AddOption(appcp, NULL);
1824     }
1825     return JNI_TRUE;
1826 }
1827 
1828 /*
1829  * inject the -Dsun.java.command pseudo property into the args structure
1830  * this pseudo property is used in the HotSpot VM to expose the
1831  * Java class name and arguments to the main method to the VM. The
1832  * HotSpot VM uses this pseudo property to store the Java class name
1833  * (or jar file name) and the arguments to the class&#39;s main method
1834  * to the instrumentation memory region. The sun.java.command pseudo
1835  * property is not exported by HotSpot to the Java layer.
1836  */
1837 void
1838 SetJavaCommandLineProp(char *what, int argc, char **argv)
1839 {
1840 
1841     int i = 0;
1842     size_t len = 0;
1843     char* javaCommand = NULL;
1844     char* dashDstr = &quot;-Dsun.java.command=&quot;;
1845 
1846     if (what == NULL) {
1847         /* unexpected, one of these should be set. just return without
1848          * setting the property
1849          */
1850         return;
1851     }
1852 
1853     /* determine the amount of memory to allocate assuming
1854      * the individual components will be space separated
1855      */
1856     len = JLI_StrLen(what);
1857     for (i = 0; i &lt; argc; i++) {
1858         len += JLI_StrLen(argv[i]) + 1;
1859     }
1860 
1861     /* allocate the memory */
1862     javaCommand = (char*) JLI_MemAlloc(len + JLI_StrLen(dashDstr) + 1);
1863 
1864     /* build the -D string */
1865     *javaCommand = &#39;\0&#39;;
1866     JLI_StrCat(javaCommand, dashDstr);
1867     JLI_StrCat(javaCommand, what);
1868 
1869     for (i = 0; i &lt; argc; i++) {
1870         /* the components of the string are space separated. In
1871          * the case of embedded white space, the relationship of
1872          * the white space separated components to their true
1873          * positional arguments will be ambiguous. This issue may
1874          * be addressed in a future release.
1875          */
1876         JLI_StrCat(javaCommand, &quot; &quot;);
1877         JLI_StrCat(javaCommand, argv[i]);
1878     }
1879 
1880     AddOption(javaCommand, NULL);
1881 }
1882 
1883 /*
1884  * JVM would like to know if it&#39;s created by a standard Sun launcher, or by
1885  * user native application, the following property indicates the former.
1886  */
<a name="12" id="anc12"></a><span class="line-modified">1887 static void SetJavaLauncherProp() {</span>

1888   AddOption(&quot;-Dsun.java.launcher=SUN_STANDARD&quot;, NULL);
1889 }
1890 
1891 /*
1892  * Prints the version information from the java.version and other properties.
1893  */
1894 static void
1895 PrintJavaVersion(JNIEnv *env, jboolean extraLF)
1896 {
1897     jclass ver;
1898     jmethodID print;
1899 
1900     NULL_CHECK(ver = FindBootStrapClass(env, &quot;java/lang/VersionProps&quot;));
1901     NULL_CHECK(print = (*env)-&gt;GetStaticMethodID(env,
1902                                                  ver,
1903                                                  (extraLF == JNI_TRUE) ? &quot;println&quot; : &quot;print&quot;,
1904                                                  &quot;(Z)V&quot;
1905                                                  )
1906               );
1907 
1908     (*env)-&gt;CallStaticVoidMethod(env, ver, print, printTo);
1909 }
1910 
1911 /*
1912  * Prints all the Java settings, see the java implementation for more details.
1913  */
1914 static void
1915 ShowSettings(JNIEnv *env, char *optString)
1916 {
1917     jmethodID showSettingsID;
1918     jstring joptString;
1919     jclass cls = GetLauncherHelperClass(env);
1920     NULL_CHECK(cls);
1921     NULL_CHECK(showSettingsID = (*env)-&gt;GetStaticMethodID(env, cls,
1922             &quot;showSettings&quot;, &quot;(ZLjava/lang/String;JJJ)V&quot;));
1923     NULL_CHECK(joptString = (*env)-&gt;NewStringUTF(env, optString));
1924     (*env)-&gt;CallStaticVoidMethod(env, cls, showSettingsID,
1925                                  USE_STDERR,
1926                                  joptString,
1927                                  (jlong)initialHeapSize,
1928                                  (jlong)maxHeapSize,
1929                                  (jlong)threadStackSize);
1930 }
1931 
1932 /**
1933  * Show resolved modules
1934  */
1935 static void
1936 ShowResolvedModules(JNIEnv *env)
1937 {
1938     jmethodID showResolvedModulesID;
1939     jclass cls = GetLauncherHelperClass(env);
1940     NULL_CHECK(cls);
1941     NULL_CHECK(showResolvedModulesID = (*env)-&gt;GetStaticMethodID(env, cls,
1942             &quot;showResolvedModules&quot;, &quot;()V&quot;));
1943     (*env)-&gt;CallStaticVoidMethod(env, cls, showResolvedModulesID);
1944 }
1945 
1946 /**
1947  * List observable modules
1948  */
1949 static void
1950 ListModules(JNIEnv *env)
1951 {
1952     jmethodID listModulesID;
1953     jclass cls = GetLauncherHelperClass(env);
1954     NULL_CHECK(cls);
1955     NULL_CHECK(listModulesID = (*env)-&gt;GetStaticMethodID(env, cls,
1956             &quot;listModules&quot;, &quot;()V&quot;));
1957     (*env)-&gt;CallStaticVoidMethod(env, cls, listModulesID);
1958 }
1959 
1960 /**
1961  * Describe a module
1962  */
1963 static void
1964 DescribeModule(JNIEnv *env, char *optString)
1965 {
1966     jmethodID describeModuleID;
1967     jstring joptString = NULL;
1968     jclass cls = GetLauncherHelperClass(env);
1969     NULL_CHECK(cls);
1970     NULL_CHECK(describeModuleID = (*env)-&gt;GetStaticMethodID(env, cls,
1971             &quot;describeModule&quot;, &quot;(Ljava/lang/String;)V&quot;));
1972     NULL_CHECK(joptString = (*env)-&gt;NewStringUTF(env, optString));
1973     (*env)-&gt;CallStaticVoidMethod(env, cls, describeModuleID, joptString);
1974 }
1975 
1976 /*
1977  * Prints default usage or the Xusage message, see sun.launcher.LauncherHelper.java
1978  */
1979 static void
1980 PrintUsage(JNIEnv* env, jboolean doXUsage)
1981 {
1982   jmethodID initHelp, vmSelect, vmSynonym, printHelp, printXUsageMessage;
1983   jstring jprogname, vm1, vm2;
1984   int i;
1985   jclass cls = GetLauncherHelperClass(env);
1986   NULL_CHECK(cls);
1987   if (doXUsage) {
1988     NULL_CHECK(printXUsageMessage = (*env)-&gt;GetStaticMethodID(env, cls,
1989                                         &quot;printXUsageMessage&quot;, &quot;(Z)V&quot;));
1990     (*env)-&gt;CallStaticVoidMethod(env, cls, printXUsageMessage, printTo);
1991   } else {
1992     NULL_CHECK(initHelp = (*env)-&gt;GetStaticMethodID(env, cls,
1993                                         &quot;initHelpMessage&quot;, &quot;(Ljava/lang/String;)V&quot;));
1994 
1995     NULL_CHECK(vmSelect = (*env)-&gt;GetStaticMethodID(env, cls, &quot;appendVmSelectMessage&quot;,
1996                                         &quot;(Ljava/lang/String;Ljava/lang/String;)V&quot;));
1997 
1998     NULL_CHECK(vmSynonym = (*env)-&gt;GetStaticMethodID(env, cls,
1999                                         &quot;appendVmSynonymMessage&quot;,
2000                                         &quot;(Ljava/lang/String;Ljava/lang/String;)V&quot;));
2001 
2002     NULL_CHECK(printHelp = (*env)-&gt;GetStaticMethodID(env, cls,
2003                                         &quot;printHelpMessage&quot;, &quot;(Z)V&quot;));
2004 
2005     NULL_CHECK(jprogname = (*env)-&gt;NewStringUTF(env, _program_name));
2006 
2007     /* Initialize the usage message with the usual preamble */
2008     (*env)-&gt;CallStaticVoidMethod(env, cls, initHelp, jprogname);
2009     CHECK_EXCEPTION_RETURN();
2010 
2011 
2012     /* Assemble the other variant part of the usage */
2013     for (i=1; i&lt;knownVMsCount; i++) {
2014       if (knownVMs[i].flag == VM_KNOWN) {
2015         NULL_CHECK(vm1 =  (*env)-&gt;NewStringUTF(env, knownVMs[i].name));
2016         NULL_CHECK(vm2 =  (*env)-&gt;NewStringUTF(env, knownVMs[i].name+1));
2017         (*env)-&gt;CallStaticVoidMethod(env, cls, vmSelect, vm1, vm2);
2018         CHECK_EXCEPTION_RETURN();
2019       }
2020     }
2021     for (i=1; i&lt;knownVMsCount; i++) {
2022       if (knownVMs[i].flag == VM_ALIASED_TO) {
2023         NULL_CHECK(vm1 =  (*env)-&gt;NewStringUTF(env, knownVMs[i].name));
2024         NULL_CHECK(vm2 =  (*env)-&gt;NewStringUTF(env, knownVMs[i].alias+1));
2025         (*env)-&gt;CallStaticVoidMethod(env, cls, vmSynonym, vm1, vm2);
2026         CHECK_EXCEPTION_RETURN();
2027       }
2028     }
2029 
2030     /* Complete the usage message and print to stderr*/
2031     (*env)-&gt;CallStaticVoidMethod(env, cls, printHelp, printTo);
2032   }
2033   return;
2034 }
2035 
2036 /*
2037  * Read the jvm.cfg file and fill the knownJVMs[] array.
2038  *
2039  * The functionality of the jvm.cfg file is subject to change without
2040  * notice and the mechanism will be removed in the future.
2041  *
2042  * The lexical structure of the jvm.cfg file is as follows:
2043  *
2044  *     jvmcfg         :=  { vmLine }
2045  *     vmLine         :=  knownLine
2046  *                    |   aliasLine
2047  *                    |   warnLine
2048  *                    |   ignoreLine
2049  *                    |   errorLine
2050  *                    |   predicateLine
2051  *                    |   commentLine
2052  *     knownLine      :=  flag  &quot;KNOWN&quot;                  EOL
2053  *     warnLine       :=  flag  &quot;WARN&quot;                   EOL
2054  *     ignoreLine     :=  flag  &quot;IGNORE&quot;                 EOL
2055  *     errorLine      :=  flag  &quot;ERROR&quot;                  EOL
2056  *     aliasLine      :=  flag  &quot;ALIASED_TO&quot;       flag  EOL
2057  *     predicateLine  :=  flag  &quot;IF_SERVER_CLASS&quot;  flag  EOL
2058  *     commentLine    :=  &quot;#&quot; text                       EOL
2059  *     flag           :=  &quot;-&quot; identifier
2060  *
2061  * The semantics are that when someone specifies a flag on the command line:
2062  * - if the flag appears on a knownLine, then the identifier is used as
2063  *   the name of the directory holding the JVM library (the name of the JVM).
2064  * - if the flag appears as the first flag on an aliasLine, the identifier
2065  *   of the second flag is used as the name of the JVM.
2066  * - if the flag appears on a warnLine, the identifier is used as the
2067  *   name of the JVM, but a warning is generated.
2068  * - if the flag appears on an ignoreLine, the identifier is recognized as the
2069  *   name of a JVM, but the identifier is ignored and the default vm used
2070  * - if the flag appears on an errorLine, an error is generated.
2071  * - if the flag appears as the first flag on a predicateLine, and
2072  *   the machine on which you are running passes the predicate indicated,
2073  *   then the identifier of the second flag is used as the name of the JVM,
2074  *   otherwise the identifier of the first flag is used as the name of the JVM.
2075  * If no flag is given on the command line, the first vmLine of the jvm.cfg
2076  * file determines the name of the JVM.
2077  * PredicateLines are only interpreted on first vmLine of a jvm.cfg file,
2078  * since they only make sense if someone hasn&#39;t specified the name of the
2079  * JVM on the command line.
2080  *
2081  * The intent of the jvm.cfg file is to allow several JVM libraries to
2082  * be installed in different subdirectories of a single JRE installation,
2083  * for space-savings and convenience in testing.
2084  * The intent is explicitly not to provide a full aliasing or predicate
2085  * mechanism.
2086  */
2087 jint
2088 ReadKnownVMs(const char *jvmCfgName, jboolean speculative)
2089 {
2090     FILE *jvmCfg;
2091     char line[MAXPATHLEN+20];
2092     int cnt = 0;
2093     int lineno = 0;
2094     jlong start, end;
2095     int vmType;
2096     char *tmpPtr;
2097     char *altVMName = NULL;
2098     char *serverClassVMName = NULL;
2099     static char *whiteSpace = &quot; \t&quot;;
2100     if (JLI_IsTraceLauncher()) {
2101         start = CounterGet();
2102     }
2103 
2104     jvmCfg = fopen(jvmCfgName, &quot;r&quot;);
2105     if (jvmCfg == NULL) {
2106       if (!speculative) {
2107         JLI_ReportErrorMessage(CFG_ERROR6, jvmCfgName);
2108         exit(1);
2109       } else {
2110         return -1;
2111       }
2112     }
2113     while (fgets(line, sizeof(line), jvmCfg) != NULL) {
2114         vmType = VM_UNKNOWN;
2115         lineno++;
2116         if (line[0] == &#39;#&#39;)
2117             continue;
2118         if (line[0] != &#39;-&#39;) {
2119             JLI_ReportErrorMessage(CFG_WARN2, lineno, jvmCfgName);
2120         }
2121         if (cnt &gt;= knownVMsLimit) {
2122             GrowKnownVMs(cnt);
2123         }
2124         line[JLI_StrLen(line)-1] = &#39;\0&#39;; /* remove trailing newline */
2125         tmpPtr = line + JLI_StrCSpn(line, whiteSpace);
2126         if (*tmpPtr == 0) {
2127             JLI_ReportErrorMessage(CFG_WARN3, lineno, jvmCfgName);
2128         } else {
2129             /* Null-terminate this string for JLI_StringDup below */
2130             *tmpPtr++ = 0;
2131             tmpPtr += JLI_StrSpn(tmpPtr, whiteSpace);
2132             if (*tmpPtr == 0) {
2133                 JLI_ReportErrorMessage(CFG_WARN3, lineno, jvmCfgName);
2134             } else {
2135                 if (!JLI_StrCCmp(tmpPtr, &quot;KNOWN&quot;)) {
2136                     vmType = VM_KNOWN;
2137                 } else if (!JLI_StrCCmp(tmpPtr, &quot;ALIASED_TO&quot;)) {
2138                     tmpPtr += JLI_StrCSpn(tmpPtr, whiteSpace);
2139                     if (*tmpPtr != 0) {
2140                         tmpPtr += JLI_StrSpn(tmpPtr, whiteSpace);
2141                     }
2142                     if (*tmpPtr == 0) {
2143                         JLI_ReportErrorMessage(CFG_WARN3, lineno, jvmCfgName);
2144                     } else {
2145                         /* Null terminate altVMName */
2146                         altVMName = tmpPtr;
2147                         tmpPtr += JLI_StrCSpn(tmpPtr, whiteSpace);
2148                         *tmpPtr = 0;
2149                         vmType = VM_ALIASED_TO;
2150                     }
2151                 } else if (!JLI_StrCCmp(tmpPtr, &quot;WARN&quot;)) {
2152                     vmType = VM_WARN;
2153                 } else if (!JLI_StrCCmp(tmpPtr, &quot;IGNORE&quot;)) {
2154                     vmType = VM_IGNORE;
2155                 } else if (!JLI_StrCCmp(tmpPtr, &quot;ERROR&quot;)) {
2156                     vmType = VM_ERROR;
2157                 } else if (!JLI_StrCCmp(tmpPtr, &quot;IF_SERVER_CLASS&quot;)) {
2158                     /* ignored */
2159                 } else {
2160                     JLI_ReportErrorMessage(CFG_WARN5, lineno, &amp;jvmCfgName[0]);
2161                     vmType = VM_KNOWN;
2162                 }
2163             }
2164         }
2165 
2166         JLI_TraceLauncher(&quot;jvm.cfg[%d] = -&gt;%s&lt;-\n&quot;, cnt, line);
2167         if (vmType != VM_UNKNOWN) {
2168             knownVMs[cnt].name = JLI_StringDup(line);
2169             knownVMs[cnt].flag = vmType;
2170             switch (vmType) {
2171             default:
2172                 break;
2173             case VM_ALIASED_TO:
2174                 knownVMs[cnt].alias = JLI_StringDup(altVMName);
2175                 JLI_TraceLauncher(&quot;    name: %s  vmType: %s  alias: %s\n&quot;,
2176                    knownVMs[cnt].name, &quot;VM_ALIASED_TO&quot;, knownVMs[cnt].alias);
2177                 break;
2178             }
2179             cnt++;
2180         }
2181     }
2182     fclose(jvmCfg);
2183     knownVMsCount = cnt;
2184 
2185     if (JLI_IsTraceLauncher()) {
2186         end   = CounterGet();
2187         printf(&quot;%ld micro seconds to parse jvm.cfg\n&quot;,
2188                (long)(jint)Counter2Micros(end-start));
2189     }
2190 
2191     return cnt;
2192 }
2193 
2194 
2195 static void
2196 GrowKnownVMs(int minimum)
2197 {
2198     struct vmdesc* newKnownVMs;
2199     int newMax;
2200 
2201     newMax = (knownVMsLimit == 0 ? INIT_MAX_KNOWN_VMS : (2 * knownVMsLimit));
2202     if (newMax &lt;= minimum) {
2203         newMax = minimum;
2204     }
2205     newKnownVMs = (struct vmdesc*) JLI_MemAlloc(newMax * sizeof(struct vmdesc));
2206     if (knownVMs != NULL) {
2207         memcpy(newKnownVMs, knownVMs, knownVMsLimit * sizeof(struct vmdesc));
2208     }
2209     JLI_MemFree(knownVMs);
2210     knownVMs = newKnownVMs;
2211     knownVMsLimit = newMax;
2212 }
2213 
2214 
2215 /* Returns index of VM or -1 if not found */
2216 static int
2217 KnownVMIndex(const char* name)
2218 {
2219     int i;
2220     if (JLI_StrCCmp(name, &quot;-J&quot;) == 0) name += 2;
2221     for (i = 0; i &lt; knownVMsCount; i++) {
2222         if (!JLI_StrCmp(name, knownVMs[i].name)) {
2223             return i;
2224         }
2225     }
2226     return -1;
2227 }
2228 
2229 static void
2230 FreeKnownVMs()
2231 {
2232     int i;
2233     for (i = 0; i &lt; knownVMsCount; i++) {
2234         JLI_MemFree(knownVMs[i].name);
2235         knownVMs[i].name = NULL;
2236     }
2237     JLI_MemFree(knownVMs);
2238 }
2239 
2240 /*
2241  * Displays the splash screen according to the jar file name
2242  * and image file names stored in environment variables
2243  */
2244 void
2245 ShowSplashScreen()
2246 {
2247     const char *jar_name = getenv(SPLASH_JAR_ENV_ENTRY);
2248     const char *file_name = getenv(SPLASH_FILE_ENV_ENTRY);
2249     int data_size;
2250     void *image_data = NULL;
2251     float scale_factor = 1;
2252     char *scaled_splash_name = NULL;
2253     jboolean isImageScaled = JNI_FALSE;
2254     size_t maxScaledImgNameLength = 0;
2255     if (file_name == NULL){
2256         return;
2257     }
<a name="13" id="anc13"></a><span class="line-added">2258 </span>
<span class="line-added">2259     if (!DoSplashInit()) {</span>
<span class="line-added">2260         goto exit;</span>
<span class="line-added">2261     }</span>
<span class="line-added">2262 </span>
2263     maxScaledImgNameLength = DoSplashGetScaledImgNameMaxPstfixLen(file_name);
2264 
2265     scaled_splash_name = JLI_MemAlloc(
2266                             maxScaledImgNameLength * sizeof(char));
2267     isImageScaled = DoSplashGetScaledImageName(jar_name, file_name,
2268                             &amp;scale_factor,
2269                             scaled_splash_name, maxScaledImgNameLength);
2270     if (jar_name) {
2271 
2272         if (isImageScaled) {
2273             image_data = JLI_JarUnpackFile(
2274                     jar_name, scaled_splash_name, &amp;data_size);
2275         }
2276 
2277         if (!image_data) {
2278             scale_factor = 1;
2279             image_data = JLI_JarUnpackFile(
2280                             jar_name, file_name, &amp;data_size);
2281         }
2282         if (image_data) {
<a name="14" id="anc14"></a>
2283             DoSplashSetScaleFactor(scale_factor);
2284             DoSplashLoadMemory(image_data, data_size);
2285             JLI_MemFree(image_data);
<a name="15" id="anc15"></a><span class="line-added">2286         } else {</span>
<span class="line-added">2287             DoSplashClose();</span>
2288         }
2289     } else {
<a name="16" id="anc16"></a>
2290         if (isImageScaled) {
2291             DoSplashSetScaleFactor(scale_factor);
2292             DoSplashLoadFile(scaled_splash_name);
2293         } else {
2294             DoSplashLoadFile(file_name);
2295         }
2296     }
2297     JLI_MemFree(scaled_splash_name);
2298 
2299     DoSplashSetFileJarName(file_name, jar_name);
2300 
<a name="17" id="anc17"></a><span class="line-added">2301     exit:</span>
2302     /*
2303      * Done with all command line processing and potential re-execs so
2304      * clean up the environment.
2305      */
2306     (void)UnsetEnv(ENV_ENTRY);
2307     (void)UnsetEnv(SPLASH_FILE_ENV_ENTRY);
2308     (void)UnsetEnv(SPLASH_JAR_ENV_ENTRY);
2309 
2310     JLI_MemFree(splash_jar_entry);
2311     JLI_MemFree(splash_file_entry);
2312 
2313 }
2314 
<a name="18" id="anc18"></a><span class="line-modified">2315 static const char* GetFullVersion()</span>

2316 {
2317     return _fVersion;
2318 }
2319 
<a name="19" id="anc19"></a><span class="line-modified">2320 static const char* GetProgramName()</span>

2321 {
2322     return _program_name;
2323 }
2324 
<a name="20" id="anc20"></a><span class="line-modified">2325 static const char* GetLauncherName()</span>

2326 {
2327     return _launcher_name;
2328 }
2329 
<a name="21" id="anc21"></a><span class="line-modified">2330 static jboolean IsJavaArgs()</span>

2331 {
2332     return _is_java_args;
2333 }
2334 
2335 static jboolean
2336 IsWildCardEnabled()
2337 {
2338     return _wc_enabled;
2339 }
2340 
2341 int
2342 ContinueInNewThread(InvocationFunctions* ifn, jlong threadStackSize,
2343                     int argc, char **argv,
2344                     int mode, char *what, int ret)
2345 {
<a name="22" id="anc22"></a><span class="line-modified">2346     if (threadStackSize == 0) {</span>
<span class="line-modified">2347         /*</span>
<span class="line-modified">2348          * If the user hasn&#39;t specified a non-zero stack size ask the JVM for its default.</span>
<span class="line-modified">2349          * A returned 0 means &#39;use the system default&#39; for a platform, e.g., Windows.</span>
<span class="line-modified">2350          * Note that HotSpot no longer supports JNI_VERSION_1_1 but it will</span>
<span class="line-modified">2351          * return its default stack size through the init args structure.</span>
<span class="line-modified">2352          */</span>
<span class="line-modified">2353         struct JDK1_1InitArgs args1_1;</span>
<span class="line-modified">2354         memset((void*)&amp;args1_1, 0, sizeof(args1_1));</span>
<span class="line-modified">2355         args1_1.version = JNI_VERSION_1_1;</span>
<span class="line-modified">2356         ifn-&gt;GetDefaultJavaVMInitArgs(&amp;args1_1);  /* ignore return value */</span>
<span class="line-modified">2357         if (args1_1.javaStackSize &gt; 0) {</span>
<span class="line-modified">2358             threadStackSize = args1_1.javaStackSize;</span>
2359         }
2360     }
2361 
2362     { /* Create a new thread to create JVM and invoke main method */
<a name="23" id="anc23"></a><span class="line-modified">2363         JavaMainArgs args;</span>
<span class="line-modified">2364         int rslt;</span>
<span class="line-modified">2365 </span>
<span class="line-modified">2366         args.argc = argc;</span>
<span class="line-modified">2367         args.argv = argv;</span>
<span class="line-modified">2368         args.mode = mode;</span>
<span class="line-modified">2369         args.what = what;</span>
<span class="line-modified">2370         args.ifn = *ifn;</span>
<span class="line-modified">2371 </span>
<span class="line-modified">2372         rslt = CallJavaMainInNewThread(threadStackSize, (void*)&amp;args);</span>
<span class="line-modified">2373         /* If the caller has deemed there is an error we</span>
<span class="line-modified">2374          * simply return that, otherwise we return the value of</span>
<span class="line-modified">2375          * the callee</span>
<span class="line-modified">2376          */</span>
<span class="line-modified">2377         return (ret != 0) ? ret : rslt;</span>
2378     }
2379 }
2380 
2381 static void
2382 DumpState()
2383 {
2384     if (!JLI_IsTraceLauncher()) return ;
2385     printf(&quot;Launcher state:\n&quot;);
2386     printf(&quot;\tFirst application arg index: %d\n&quot;, JLI_GetAppArgIndex());
2387     printf(&quot;\tdebug:%s\n&quot;, (JLI_IsTraceLauncher() == JNI_TRUE) ? &quot;on&quot; : &quot;off&quot;);
2388     printf(&quot;\tjavargs:%s\n&quot;, (_is_java_args == JNI_TRUE) ? &quot;on&quot; : &quot;off&quot;);
2389     printf(&quot;\tprogram name:%s\n&quot;, GetProgramName());
2390     printf(&quot;\tlauncher name:%s\n&quot;, GetLauncherName());
2391     printf(&quot;\tjavaw:%s\n&quot;, (IsJavaw() == JNI_TRUE) ? &quot;on&quot; : &quot;off&quot;);
2392     printf(&quot;\tfullversion:%s\n&quot;, GetFullVersion());
2393 }
2394 
2395 /*
2396  * A utility procedure to always print to stderr
2397  */
2398 JNIEXPORT void JNICALL
2399 JLI_ReportMessage(const char* fmt, ...)
2400 {
2401     va_list vl;
2402     va_start(vl, fmt);
2403     vfprintf(stderr, fmt, vl);
2404     fprintf(stderr, &quot;\n&quot;);
2405     va_end(vl);
2406 }
2407 
2408 /*
2409  * A utility procedure to always print to stdout
2410  */
2411 void
2412 JLI_ShowMessage(const char* fmt, ...)
2413 {
2414     va_list vl;
2415     va_start(vl, fmt);
2416     vfprintf(stdout, fmt, vl);
2417     fprintf(stdout, &quot;\n&quot;);
2418     va_end(vl);
2419 }
<a name="24" id="anc24"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="24" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/native/libjli/java.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../../classes/module-info.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="java.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/native/libjli/java.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  85 static jboolean _wc_enabled = JNI_FALSE;
  86 
  87 /*
  88  * Entries for splash screen environment variables.
  89  * putenv is performed in SelectVersion. We need
  90  * them in memory until UnsetEnv, so they are made static
  91  * global instead of auto local.
  92  */
  93 static char* splash_file_entry = NULL;
  94 static char* splash_jar_entry = NULL;
  95 
  96 /*
  97  * List of VM options to be specified when the VM is created.
  98  */
  99 static JavaVMOption *options;
 100 static int numOptions, maxOptions;
 101 
 102 /*
 103  * Prototypes for functions internal to launcher.
 104  */



 105 static void SetClassPath(const char *s);
 106 static void SetMainModule(const char *s);
 107 static void SelectVersion(int argc, char **argv, char **main_class);
 108 static void SetJvmEnvironment(int argc, char **argv);
 109 static jboolean ParseArguments(int *pargc, char ***pargv,
 110                                int *pmode, char **pwhat,
 111                                int *pret, const char *jrepath);
 112 static jboolean InitializeJVM(JavaVM **pvm, JNIEnv **penv,
 113                               InvocationFunctions *ifn);
 114 static jstring NewPlatformString(JNIEnv *env, char *s);
 115 static jclass LoadMainClass(JNIEnv *env, int mode, char *name);
 116 static jclass GetApplicationClass(JNIEnv *env);
 117 
 118 static void TranslateApplicationArgs(int jargc, const char **jargv, int *pargc, char ***pargv);
 119 static jboolean AddApplicationOptions(int cpathc, const char **cpathv);
 120 static void SetApplicationClassPath(const char**);
 121 
 122 static void PrintJavaVersion(JNIEnv *env, jboolean extraLF);
 123 static void PrintUsage(JNIEnv* env, jboolean doXUsage);
 124 static void ShowSettings(JNIEnv* env, char *optString);
</pre>
<hr />
<pre>
 187             return JNI_FALSE; \
 188         } \
 189     } while (JNI_FALSE)
 190 
 191 #define ARG_CHECK(AC_arg_count, AC_failure_message, AC_questionable_arg) \
 192     do { \
 193         if (AC_arg_count &lt; 1) { \
 194             JLI_ReportErrorMessage(AC_failure_message, AC_questionable_arg); \
 195             printUsage = JNI_TRUE; \
 196             *pret = 1; \
 197             return JNI_TRUE; \
 198         } \
 199     } while (JNI_FALSE)
 200 
 201 /*
 202  * Running Java code in primordial thread caused many problems. We will
 203  * create a new thread to invoke JVM. See 6316197 for more information.
 204  */
 205 static jlong threadStackSize    = 0;  /* stack size of the new thread */
 206 static jlong maxHeapSize        = 0;  /* max heap size */
<span class="line-modified"> 207 static jlong initialHeapSize    = 0;  /* inital heap size */</span>
 208 
 209 /*
<span class="line-modified"> 210  * A minimum -Xss stack size suitable for all platforms.</span>
<span class="line-modified"> 211  */</span>



 212 #ifndef STACK_SIZE_MINIMUM
 213 #define STACK_SIZE_MINIMUM (64 * KB)
 214 #endif
 215 
 216 #ifdef INCLUDE_TSAN
 217 /*
 218  * Function pointer to JVM&#39;s TSAN symbolize function.
 219  */
 220 __attribute__((visibility(&quot;default&quot;)))
 221 TsanSymbolize_t tsan_symbolize_func = NULL;
 222 #endif
 223 
 224 /*
 225  * Entry point.
 226  */
 227 JNIEXPORT int JNICALL
 228 JLI_Launch(int argc, char ** argv,              /* main argc, argv */
 229         int jargc, const char** jargv,          /* java args */
 230         int appclassc, const char** appclassv,  /* app classpath */
 231         const char* fullversion,                /* full version defined */
</pre>
<hr />
<pre>
 329     }
 330 
 331     /* Parse command line options; if the return value of
 332      * ParseArguments is false, the program should exit.
 333      */
 334     if (!ParseArguments(&amp;argc, &amp;argv, &amp;mode, &amp;what, &amp;ret, jrepath)) {
 335         return(ret);
 336     }
 337 
 338     /* Override class path if -jar flag was specified */
 339     if (mode == LM_JAR) {
 340         SetClassPath(what);     /* Override class path */
 341     }
 342 
 343     /* set the -Dsun.java.command pseudo property */
 344     SetJavaCommandLineProp(what, argc, argv);
 345 
 346     /* Set the -Dsun.java.launcher pseudo property */
 347     SetJavaLauncherProp();
 348 
<span class="line-removed"> 349     /* set the -Dsun.java.launcher.* platform properties */</span>
<span class="line-removed"> 350     SetJavaLauncherPlatformProps();</span>
<span class="line-removed"> 351 </span>
 352     return JVMInit(&amp;ifn, threadStackSize, argc, argv, mode, what, ret);
 353 }
 354 /*
 355  * Always detach the main thread so that it appears to have ended when
 356  * the application&#39;s main method exits.  This will invoke the
 357  * uncaught exception handler machinery if main threw an
 358  * exception.  An uncaught exception handler cannot change the
 359  * launcher&#39;s return code except by calling System.exit.
 360  *
 361  * Wait for all non-daemon threads to end, then destroy the VM.
 362  * This will actually create a trivial new Java waiter thread
 363  * named &quot;DestroyJavaVM&quot;, but this will be seen as a different
 364  * thread from the one that executed main, even though they are
 365  * the same C thread.  This allows mainThread.join() and
 366  * mainThread.isAlive() to work as expected.
 367  */
 368 #define LEAVE() \
 369     do { \
 370         if ((*vm)-&gt;DetachCurrentThread(vm) != JNI_OK) { \
 371             JLI_ReportErrorMessage(JVM_ERROR2); \
</pre>
<hr />
<pre>
 637            IsLauncherOption(name);
 638 }
 639 
 640 /*
 641  * Check if it is OK to set the mode.
 642  * If the mode was previously set, and should not be changed,
 643  * a fatal error is reported.
 644  */
 645 static int
 646 checkMode(int mode, int newMode, const char *arg) {
 647     if (mode == LM_SOURCE) {
 648         JLI_ReportErrorMessage(ARG_ERROR14, arg);
 649         exit(1);
 650     }
 651     return newMode;
 652 }
 653 
 654 /*
 655  * Test if an arg identifies a source file.
 656  */
<span class="line-modified"> 657 jboolean</span>
<span class="line-removed"> 658 IsSourceFile(const char *arg) {</span>
 659     struct stat st;
 660     return (JLI_HasSuffix(arg, &quot;.java&quot;) &amp;&amp; stat(arg, &amp;st) == 0);
 661 }
 662 
 663 /*
 664  * Checks the command line options to find which JVM type was
 665  * specified.  If no command line option was given for the JVM type,
 666  * the default type is used.  The environment variable
 667  * JDK_ALTERNATE_VM and the command line option -XXaltjvm= are also
 668  * checked as ways of specifying which JVM type to invoke.
 669  */
 670 char *
 671 CheckJvmType(int *pargc, char ***argv, jboolean speculative) {
 672     int i, argi;
 673     int argc;
 674     char **newArgv;
 675     int newArgvIdx = 0;
 676     int isVMType;
 677     int jvmidx = -1;
 678     char *jvmtype = getenv(&quot;JDK_ALTERNATE_VM&quot;);
</pre>
<hr />
<pre>
 928     /*
 929      * Expand options array if needed to accommodate at least one more
 930      * VM option.
 931      */
 932     if (numOptions &gt;= maxOptions) {
 933         if (options == 0) {
 934             maxOptions = 4;
 935             options = JLI_MemAlloc(maxOptions * sizeof(JavaVMOption));
 936         } else {
 937             JavaVMOption *tmp;
 938             maxOptions *= 2;
 939             tmp = JLI_MemAlloc(maxOptions * sizeof(JavaVMOption));
 940             memcpy(tmp, options, numOptions * sizeof(JavaVMOption));
 941             JLI_MemFree(options);
 942             options = tmp;
 943         }
 944     }
 945     options[numOptions].optionString = str;
 946     options[numOptions++].extraInfo = info;
 947 







 948     if (JLI_StrCCmp(str, &quot;-Xss&quot;) == 0) {
 949         jlong tmp;
 950         if (parse_size(str + 4, &amp;tmp)) {
 951             threadStackSize = tmp;
<span class="line-modified"> 952             /*</span>
<span class="line-removed"> 953              * Make sure the thread stack size is big enough that we won&#39;t get a stack</span>
<span class="line-removed"> 954              * overflow before the JVM startup code can check to make sure the stack</span>
<span class="line-removed"> 955              * is big enough.</span>
<span class="line-removed"> 956              */</span>
<span class="line-removed"> 957             if (threadStackSize &lt; (jlong)STACK_SIZE_MINIMUM) {</span>
 958                 threadStackSize = STACK_SIZE_MINIMUM;
 959             }
 960         }
 961     }
 962 
 963     if (JLI_StrCCmp(str, &quot;-Xmx&quot;) == 0) {
 964         jlong tmp;
 965         if (parse_size(str + 4, &amp;tmp)) {
 966             maxHeapSize = tmp;
 967         }
 968     }
 969 
 970     if (JLI_StrCCmp(str, &quot;-Xms&quot;) == 0) {
 971         jlong tmp;
 972         if (parse_size(str + 4, &amp;tmp)) {
 973            initialHeapSize = tmp;
 974         }
 975     }
 976 }
 977 
</pre>
<hr />
<pre>
1158          * Command line splash screen option should have precedence
1159          * over the manifest, so the manifest data is used only if
1160          * splash_file_name has not been initialized above during command
1161          * line parsing
1162          */
1163         if (!headlessflag &amp;&amp; !splash_file_name &amp;&amp; info.splashscreen_image_file_name) {
1164             splash_file_name = info.splashscreen_image_file_name;
1165             splash_jar_name = operand;
1166         }
1167     } else {
1168         info.manifest_version = NULL;
1169         info.main_class = NULL;
1170         info.jre_version = NULL;
1171         info.jre_restrict_search = 0;
1172     }
1173 
1174     /*
1175      * Passing on splash screen info in environment variables
1176      */
1177     if (splash_file_name &amp;&amp; !headlessflag) {
<span class="line-modified">1178         char* splash_file_entry = JLI_MemAlloc(JLI_StrLen(SPLASH_FILE_ENV_ENTRY &quot;=&quot;)+JLI_StrLen(splash_file_name)+1);</span>
1179         JLI_StrCpy(splash_file_entry, SPLASH_FILE_ENV_ENTRY &quot;=&quot;);
1180         JLI_StrCat(splash_file_entry, splash_file_name);
1181         putenv(splash_file_entry);
1182     }
1183     if (splash_jar_name &amp;&amp; !headlessflag) {
<span class="line-modified">1184         char* splash_jar_entry = JLI_MemAlloc(JLI_StrLen(SPLASH_JAR_ENV_ENTRY &quot;=&quot;)+JLI_StrLen(splash_jar_name)+1);</span>
1185         JLI_StrCpy(splash_jar_entry, SPLASH_JAR_ENV_ENTRY &quot;=&quot;);
1186         JLI_StrCat(splash_jar_entry, splash_jar_name);
1187         putenv(splash_jar_entry);
1188     }
1189 
1190 
1191     /*
1192      * &quot;Valid&quot; returns (other than unrecoverable errors) follow.  Set
1193      * main_class as a side-effect of this routine.
1194      */
1195     if (info.main_class != NULL)
1196         *main_class = JLI_StringDup(info.main_class);
1197 
1198     if (info.jre_version == NULL) {
1199         JLI_FreeManifest();
1200         return;
1201     }
1202 
1203 }
1204 
</pre>
<hr />
<pre>
1419  * The following case provide backward compatibility with old-style
1420  * command line options.
1421  */
1422         } else if (JLI_StrCmp(arg, &quot;-fullversion&quot;) == 0) {
1423             JLI_ReportMessage(&quot;%s full version \&quot;%s\&quot;&quot;, _launcher_name, GetFullVersion());
1424             return JNI_FALSE;
1425         } else if (JLI_StrCmp(arg, &quot;--full-version&quot;) == 0) {
1426             JLI_ShowMessage(&quot;%s %s&quot;, _launcher_name, GetFullVersion());
1427             return JNI_FALSE;
1428         } else if (JLI_StrCmp(arg, &quot;-verbosegc&quot;) == 0) {
1429             AddOption(&quot;-verbose:gc&quot;, NULL);
1430         } else if (JLI_StrCmp(arg, &quot;-t&quot;) == 0) {
1431             AddOption(&quot;-Xt&quot;, NULL);
1432         } else if (JLI_StrCmp(arg, &quot;-tm&quot;) == 0) {
1433             AddOption(&quot;-Xtm&quot;, NULL);
1434         } else if (JLI_StrCmp(arg, &quot;-debug&quot;) == 0) {
1435             AddOption(&quot;-Xdebug&quot;, NULL);
1436         } else if (JLI_StrCmp(arg, &quot;-noclassgc&quot;) == 0) {
1437             AddOption(&quot;-Xnoclassgc&quot;, NULL);
1438         } else if (JLI_StrCmp(arg, &quot;-Xfuture&quot;) == 0) {

1439             AddOption(&quot;-Xverify:all&quot;, NULL);
1440         } else if (JLI_StrCmp(arg, &quot;-verify&quot;) == 0) {
1441             AddOption(&quot;-Xverify:all&quot;, NULL);
1442         } else if (JLI_StrCmp(arg, &quot;-verifyremote&quot;) == 0) {
1443             AddOption(&quot;-Xverify:remote&quot;, NULL);
1444         } else if (JLI_StrCmp(arg, &quot;-noverify&quot;) == 0) {




1445             AddOption(&quot;-Xverify:none&quot;, NULL);
1446         } else if (JLI_StrCCmp(arg, &quot;-ss&quot;) == 0 ||
1447                    JLI_StrCCmp(arg, &quot;-oss&quot;) == 0 ||
1448                    JLI_StrCCmp(arg, &quot;-ms&quot;) == 0 ||
1449                    JLI_StrCCmp(arg, &quot;-mx&quot;) == 0) {
1450             char *tmp = JLI_MemAlloc(JLI_StrLen(arg) + 6);
1451             sprintf(tmp, &quot;-X%s&quot;, arg + 1); /* skip &#39;-&#39; */
1452             AddOption(tmp, NULL);
1453         } else if (JLI_StrCmp(arg, &quot;-checksource&quot;) == 0 ||
1454                    JLI_StrCmp(arg, &quot;-cs&quot;) == 0 ||
1455                    JLI_StrCmp(arg, &quot;-noasyncgc&quot;) == 0) {
1456             /* No longer supported */
1457             JLI_ReportErrorMessage(ARG_WARN, arg);
1458         } else if (JLI_StrCCmp(arg, &quot;-splash:&quot;) == 0) {
1459             ; /* Ignore machine independent options already handled */
1460         } else if (ProcessPlatformOption(arg)) {
1461             ; /* Processing of platform dependent options */
1462         } else {
1463             /* java.class.path set on the command line */
1464             if (JLI_StrCCmp(arg, &quot;-Djava.class.path=&quot;) == 0) {
</pre>
<hr />
<pre>
1858     JLI_StrCat(javaCommand, what);
1859 
1860     for (i = 0; i &lt; argc; i++) {
1861         /* the components of the string are space separated. In
1862          * the case of embedded white space, the relationship of
1863          * the white space separated components to their true
1864          * positional arguments will be ambiguous. This issue may
1865          * be addressed in a future release.
1866          */
1867         JLI_StrCat(javaCommand, &quot; &quot;);
1868         JLI_StrCat(javaCommand, argv[i]);
1869     }
1870 
1871     AddOption(javaCommand, NULL);
1872 }
1873 
1874 /*
1875  * JVM would like to know if it&#39;s created by a standard Sun launcher, or by
1876  * user native application, the following property indicates the former.
1877  */
<span class="line-modified">1878 void</span>
<span class="line-removed">1879 SetJavaLauncherProp() {</span>
1880   AddOption(&quot;-Dsun.java.launcher=SUN_STANDARD&quot;, NULL);
1881 }
1882 
1883 /*
1884  * Prints the version information from the java.version and other properties.
1885  */
1886 static void
1887 PrintJavaVersion(JNIEnv *env, jboolean extraLF)
1888 {
1889     jclass ver;
1890     jmethodID print;
1891 
1892     NULL_CHECK(ver = FindBootStrapClass(env, &quot;java/lang/VersionProps&quot;));
1893     NULL_CHECK(print = (*env)-&gt;GetStaticMethodID(env,
1894                                                  ver,
1895                                                  (extraLF == JNI_TRUE) ? &quot;println&quot; : &quot;print&quot;,
1896                                                  &quot;(Z)V&quot;
1897                                                  )
1898               );
1899 
</pre>
<hr />
<pre>
2230 }
2231 
2232 /*
2233  * Displays the splash screen according to the jar file name
2234  * and image file names stored in environment variables
2235  */
2236 void
2237 ShowSplashScreen()
2238 {
2239     const char *jar_name = getenv(SPLASH_JAR_ENV_ENTRY);
2240     const char *file_name = getenv(SPLASH_FILE_ENV_ENTRY);
2241     int data_size;
2242     void *image_data = NULL;
2243     float scale_factor = 1;
2244     char *scaled_splash_name = NULL;
2245     jboolean isImageScaled = JNI_FALSE;
2246     size_t maxScaledImgNameLength = 0;
2247     if (file_name == NULL){
2248         return;
2249     }





2250     maxScaledImgNameLength = DoSplashGetScaledImgNameMaxPstfixLen(file_name);
2251 
2252     scaled_splash_name = JLI_MemAlloc(
2253                             maxScaledImgNameLength * sizeof(char));
2254     isImageScaled = DoSplashGetScaledImageName(jar_name, file_name,
2255                             &amp;scale_factor,
2256                             scaled_splash_name, maxScaledImgNameLength);
2257     if (jar_name) {
2258 
2259         if (isImageScaled) {
2260             image_data = JLI_JarUnpackFile(
2261                     jar_name, scaled_splash_name, &amp;data_size);
2262         }
2263 
2264         if (!image_data) {
2265             scale_factor = 1;
2266             image_data = JLI_JarUnpackFile(
2267                             jar_name, file_name, &amp;data_size);
2268         }
2269         if (image_data) {
<span class="line-removed">2270             DoSplashInit();</span>
2271             DoSplashSetScaleFactor(scale_factor);
2272             DoSplashLoadMemory(image_data, data_size);
2273             JLI_MemFree(image_data);


2274         }
2275     } else {
<span class="line-removed">2276         DoSplashInit();</span>
2277         if (isImageScaled) {
2278             DoSplashSetScaleFactor(scale_factor);
2279             DoSplashLoadFile(scaled_splash_name);
2280         } else {
2281             DoSplashLoadFile(file_name);
2282         }
2283     }
2284     JLI_MemFree(scaled_splash_name);
2285 
2286     DoSplashSetFileJarName(file_name, jar_name);
2287 

2288     /*
2289      * Done with all command line processing and potential re-execs so
2290      * clean up the environment.
2291      */
2292     (void)UnsetEnv(ENV_ENTRY);
2293     (void)UnsetEnv(SPLASH_FILE_ENV_ENTRY);
2294     (void)UnsetEnv(SPLASH_JAR_ENV_ENTRY);
2295 
2296     JLI_MemFree(splash_jar_entry);
2297     JLI_MemFree(splash_file_entry);
2298 
2299 }
2300 
<span class="line-modified">2301 const char*</span>
<span class="line-removed">2302 GetFullVersion()</span>
2303 {
2304     return _fVersion;
2305 }
2306 
<span class="line-modified">2307 const char*</span>
<span class="line-removed">2308 GetProgramName()</span>
2309 {
2310     return _program_name;
2311 }
2312 
<span class="line-modified">2313 const char*</span>
<span class="line-removed">2314 GetLauncherName()</span>
2315 {
2316     return _launcher_name;
2317 }
2318 
<span class="line-modified">2319 jboolean</span>
<span class="line-removed">2320 IsJavaArgs()</span>
2321 {
2322     return _is_java_args;
2323 }
2324 
2325 static jboolean
2326 IsWildCardEnabled()
2327 {
2328     return _wc_enabled;
2329 }
2330 
2331 int
2332 ContinueInNewThread(InvocationFunctions* ifn, jlong threadStackSize,
2333                     int argc, char **argv,
2334                     int mode, char *what, int ret)
2335 {
<span class="line-modified">2336 </span>
<span class="line-modified">2337     /*</span>
<span class="line-modified">2338      * If user doesn&#39;t specify stack size, check if VM has a preference.</span>
<span class="line-modified">2339      * Note that HotSpot no longer supports JNI_VERSION_1_1 but it will</span>
<span class="line-modified">2340      * return its default stack size through the init args structure.</span>
<span class="line-modified">2341      */</span>
<span class="line-modified">2342     if (threadStackSize == 0) {</span>
<span class="line-modified">2343       struct JDK1_1InitArgs args1_1;</span>
<span class="line-modified">2344       memset((void*)&amp;args1_1, 0, sizeof(args1_1));</span>
<span class="line-modified">2345       args1_1.version = JNI_VERSION_1_1;</span>
<span class="line-modified">2346       ifn-&gt;GetDefaultJavaVMInitArgs(&amp;args1_1);  /* ignore return value */</span>
<span class="line-modified">2347       if (args1_1.javaStackSize &gt; 0) {</span>
<span class="line-modified">2348          threadStackSize = args1_1.javaStackSize;</span>
2349       }
2350     }
2351 
2352     { /* Create a new thread to create JVM and invoke main method */
<span class="line-modified">2353       JavaMainArgs args;</span>
<span class="line-modified">2354       int rslt;</span>
<span class="line-modified">2355 </span>
<span class="line-modified">2356       args.argc = argc;</span>
<span class="line-modified">2357       args.argv = argv;</span>
<span class="line-modified">2358       args.mode = mode;</span>
<span class="line-modified">2359       args.what = what;</span>
<span class="line-modified">2360       args.ifn = *ifn;</span>
<span class="line-modified">2361 </span>
<span class="line-modified">2362       rslt = CallJavaMainInNewThread(threadStackSize, (void*)&amp;args);</span>
<span class="line-modified">2363       /* If the caller has deemed there is an error we</span>
<span class="line-modified">2364        * simply return that, otherwise we return the value of</span>
<span class="line-modified">2365        * the callee</span>
<span class="line-modified">2366        */</span>
<span class="line-modified">2367       return (ret != 0) ? ret : rslt;</span>
2368     }
2369 }
2370 
2371 static void
2372 DumpState()
2373 {
2374     if (!JLI_IsTraceLauncher()) return ;
2375     printf(&quot;Launcher state:\n&quot;);
2376     printf(&quot;\tFirst application arg index: %d\n&quot;, JLI_GetAppArgIndex());
2377     printf(&quot;\tdebug:%s\n&quot;, (JLI_IsTraceLauncher() == JNI_TRUE) ? &quot;on&quot; : &quot;off&quot;);
2378     printf(&quot;\tjavargs:%s\n&quot;, (_is_java_args == JNI_TRUE) ? &quot;on&quot; : &quot;off&quot;);
2379     printf(&quot;\tprogram name:%s\n&quot;, GetProgramName());
2380     printf(&quot;\tlauncher name:%s\n&quot;, GetLauncherName());
2381     printf(&quot;\tjavaw:%s\n&quot;, (IsJavaw() == JNI_TRUE) ? &quot;on&quot; : &quot;off&quot;);
2382     printf(&quot;\tfullversion:%s\n&quot;, GetFullVersion());
2383 }
2384 
2385 /*
2386  * A utility procedure to always print to stderr
2387  */
</pre>
</td>
<td>
<hr />
<pre>
  85 static jboolean _wc_enabled = JNI_FALSE;
  86 
  87 /*
  88  * Entries for splash screen environment variables.
  89  * putenv is performed in SelectVersion. We need
  90  * them in memory until UnsetEnv, so they are made static
  91  * global instead of auto local.
  92  */
  93 static char* splash_file_entry = NULL;
  94 static char* splash_jar_entry = NULL;
  95 
  96 /*
  97  * List of VM options to be specified when the VM is created.
  98  */
  99 static JavaVMOption *options;
 100 static int numOptions, maxOptions;
 101 
 102 /*
 103  * Prototypes for functions internal to launcher.
 104  */
<span class="line-added"> 105 static const char* GetFullVersion();</span>
<span class="line-added"> 106 static jboolean IsJavaArgs();</span>
<span class="line-added"> 107 static void SetJavaLauncherProp();</span>
 108 static void SetClassPath(const char *s);
 109 static void SetMainModule(const char *s);
 110 static void SelectVersion(int argc, char **argv, char **main_class);
 111 static void SetJvmEnvironment(int argc, char **argv);
 112 static jboolean ParseArguments(int *pargc, char ***pargv,
 113                                int *pmode, char **pwhat,
 114                                int *pret, const char *jrepath);
 115 static jboolean InitializeJVM(JavaVM **pvm, JNIEnv **penv,
 116                               InvocationFunctions *ifn);
 117 static jstring NewPlatformString(JNIEnv *env, char *s);
 118 static jclass LoadMainClass(JNIEnv *env, int mode, char *name);
 119 static jclass GetApplicationClass(JNIEnv *env);
 120 
 121 static void TranslateApplicationArgs(int jargc, const char **jargv, int *pargc, char ***pargv);
 122 static jboolean AddApplicationOptions(int cpathc, const char **cpathv);
 123 static void SetApplicationClassPath(const char**);
 124 
 125 static void PrintJavaVersion(JNIEnv *env, jboolean extraLF);
 126 static void PrintUsage(JNIEnv* env, jboolean doXUsage);
 127 static void ShowSettings(JNIEnv* env, char *optString);
</pre>
<hr />
<pre>
 190             return JNI_FALSE; \
 191         } \
 192     } while (JNI_FALSE)
 193 
 194 #define ARG_CHECK(AC_arg_count, AC_failure_message, AC_questionable_arg) \
 195     do { \
 196         if (AC_arg_count &lt; 1) { \
 197             JLI_ReportErrorMessage(AC_failure_message, AC_questionable_arg); \
 198             printUsage = JNI_TRUE; \
 199             *pret = 1; \
 200             return JNI_TRUE; \
 201         } \
 202     } while (JNI_FALSE)
 203 
 204 /*
 205  * Running Java code in primordial thread caused many problems. We will
 206  * create a new thread to invoke JVM. See 6316197 for more information.
 207  */
 208 static jlong threadStackSize    = 0;  /* stack size of the new thread */
 209 static jlong maxHeapSize        = 0;  /* max heap size */
<span class="line-modified"> 210 static jlong initialHeapSize    = 0;  /* initial heap size */</span>
 211 
 212 /*
<span class="line-modified"> 213  * A minimum initial-thread stack size suitable for most platforms.</span>
<span class="line-modified"> 214  * This is the minimum amount of stack needed to load the JVM such</span>
<span class="line-added"> 215  * that it can reject a too small -Xss value. If this is too small</span>
<span class="line-added"> 216  * JVM initialization would cause a StackOverflowError.</span>
<span class="line-added"> 217   */</span>
 218 #ifndef STACK_SIZE_MINIMUM
 219 #define STACK_SIZE_MINIMUM (64 * KB)
 220 #endif
 221 
 222 #ifdef INCLUDE_TSAN
 223 /*
 224  * Function pointer to JVM&#39;s TSAN symbolize function.
 225  */
 226 __attribute__((visibility(&quot;default&quot;)))
 227 TsanSymbolize_t tsan_symbolize_func = NULL;
 228 #endif
 229 
 230 /*
 231  * Entry point.
 232  */
 233 JNIEXPORT int JNICALL
 234 JLI_Launch(int argc, char ** argv,              /* main argc, argv */
 235         int jargc, const char** jargv,          /* java args */
 236         int appclassc, const char** appclassv,  /* app classpath */
 237         const char* fullversion,                /* full version defined */
</pre>
<hr />
<pre>
 335     }
 336 
 337     /* Parse command line options; if the return value of
 338      * ParseArguments is false, the program should exit.
 339      */
 340     if (!ParseArguments(&amp;argc, &amp;argv, &amp;mode, &amp;what, &amp;ret, jrepath)) {
 341         return(ret);
 342     }
 343 
 344     /* Override class path if -jar flag was specified */
 345     if (mode == LM_JAR) {
 346         SetClassPath(what);     /* Override class path */
 347     }
 348 
 349     /* set the -Dsun.java.command pseudo property */
 350     SetJavaCommandLineProp(what, argc, argv);
 351 
 352     /* Set the -Dsun.java.launcher pseudo property */
 353     SetJavaLauncherProp();
 354 



 355     return JVMInit(&amp;ifn, threadStackSize, argc, argv, mode, what, ret);
 356 }
 357 /*
 358  * Always detach the main thread so that it appears to have ended when
 359  * the application&#39;s main method exits.  This will invoke the
 360  * uncaught exception handler machinery if main threw an
 361  * exception.  An uncaught exception handler cannot change the
 362  * launcher&#39;s return code except by calling System.exit.
 363  *
 364  * Wait for all non-daemon threads to end, then destroy the VM.
 365  * This will actually create a trivial new Java waiter thread
 366  * named &quot;DestroyJavaVM&quot;, but this will be seen as a different
 367  * thread from the one that executed main, even though they are
 368  * the same C thread.  This allows mainThread.join() and
 369  * mainThread.isAlive() to work as expected.
 370  */
 371 #define LEAVE() \
 372     do { \
 373         if ((*vm)-&gt;DetachCurrentThread(vm) != JNI_OK) { \
 374             JLI_ReportErrorMessage(JVM_ERROR2); \
</pre>
<hr />
<pre>
 640            IsLauncherOption(name);
 641 }
 642 
 643 /*
 644  * Check if it is OK to set the mode.
 645  * If the mode was previously set, and should not be changed,
 646  * a fatal error is reported.
 647  */
 648 static int
 649 checkMode(int mode, int newMode, const char *arg) {
 650     if (mode == LM_SOURCE) {
 651         JLI_ReportErrorMessage(ARG_ERROR14, arg);
 652         exit(1);
 653     }
 654     return newMode;
 655 }
 656 
 657 /*
 658  * Test if an arg identifies a source file.
 659  */
<span class="line-modified"> 660 static jboolean IsSourceFile(const char *arg) {</span>

 661     struct stat st;
 662     return (JLI_HasSuffix(arg, &quot;.java&quot;) &amp;&amp; stat(arg, &amp;st) == 0);
 663 }
 664 
 665 /*
 666  * Checks the command line options to find which JVM type was
 667  * specified.  If no command line option was given for the JVM type,
 668  * the default type is used.  The environment variable
 669  * JDK_ALTERNATE_VM and the command line option -XXaltjvm= are also
 670  * checked as ways of specifying which JVM type to invoke.
 671  */
 672 char *
 673 CheckJvmType(int *pargc, char ***argv, jboolean speculative) {
 674     int i, argi;
 675     int argc;
 676     char **newArgv;
 677     int newArgvIdx = 0;
 678     int isVMType;
 679     int jvmidx = -1;
 680     char *jvmtype = getenv(&quot;JDK_ALTERNATE_VM&quot;);
</pre>
<hr />
<pre>
 930     /*
 931      * Expand options array if needed to accommodate at least one more
 932      * VM option.
 933      */
 934     if (numOptions &gt;= maxOptions) {
 935         if (options == 0) {
 936             maxOptions = 4;
 937             options = JLI_MemAlloc(maxOptions * sizeof(JavaVMOption));
 938         } else {
 939             JavaVMOption *tmp;
 940             maxOptions *= 2;
 941             tmp = JLI_MemAlloc(maxOptions * sizeof(JavaVMOption));
 942             memcpy(tmp, options, numOptions * sizeof(JavaVMOption));
 943             JLI_MemFree(options);
 944             options = tmp;
 945         }
 946     }
 947     options[numOptions].optionString = str;
 948     options[numOptions++].extraInfo = info;
 949 
<span class="line-added"> 950     /*</span>
<span class="line-added"> 951      * -Xss is used both by the JVM and here to establish the stack size of the thread</span>
<span class="line-added"> 952      * created to launch the JVM. In the latter case we need to ensure we don&#39;t go</span>
<span class="line-added"> 953      * below the minimum stack size allowed. If -Xss is zero that tells the JVM to use</span>
<span class="line-added"> 954      * &#39;default&#39; sizes (either from JVM or system configuration, e.g. &#39;ulimit -s&#39; on linux),</span>
<span class="line-added"> 955      * and is not itself a small stack size that will be rejected. So we ignore -Xss0 here.</span>
<span class="line-added"> 956      */</span>
 957     if (JLI_StrCCmp(str, &quot;-Xss&quot;) == 0) {
 958         jlong tmp;
 959         if (parse_size(str + 4, &amp;tmp)) {
 960             threadStackSize = tmp;
<span class="line-modified"> 961             if (threadStackSize &gt; 0 &amp;&amp; threadStackSize &lt; (jlong)STACK_SIZE_MINIMUM) {</span>





 962                 threadStackSize = STACK_SIZE_MINIMUM;
 963             }
 964         }
 965     }
 966 
 967     if (JLI_StrCCmp(str, &quot;-Xmx&quot;) == 0) {
 968         jlong tmp;
 969         if (parse_size(str + 4, &amp;tmp)) {
 970             maxHeapSize = tmp;
 971         }
 972     }
 973 
 974     if (JLI_StrCCmp(str, &quot;-Xms&quot;) == 0) {
 975         jlong tmp;
 976         if (parse_size(str + 4, &amp;tmp)) {
 977            initialHeapSize = tmp;
 978         }
 979     }
 980 }
 981 
</pre>
<hr />
<pre>
1162          * Command line splash screen option should have precedence
1163          * over the manifest, so the manifest data is used only if
1164          * splash_file_name has not been initialized above during command
1165          * line parsing
1166          */
1167         if (!headlessflag &amp;&amp; !splash_file_name &amp;&amp; info.splashscreen_image_file_name) {
1168             splash_file_name = info.splashscreen_image_file_name;
1169             splash_jar_name = operand;
1170         }
1171     } else {
1172         info.manifest_version = NULL;
1173         info.main_class = NULL;
1174         info.jre_version = NULL;
1175         info.jre_restrict_search = 0;
1176     }
1177 
1178     /*
1179      * Passing on splash screen info in environment variables
1180      */
1181     if (splash_file_name &amp;&amp; !headlessflag) {
<span class="line-modified">1182         splash_file_entry = JLI_MemAlloc(JLI_StrLen(SPLASH_FILE_ENV_ENTRY &quot;=&quot;)+JLI_StrLen(splash_file_name)+1);</span>
1183         JLI_StrCpy(splash_file_entry, SPLASH_FILE_ENV_ENTRY &quot;=&quot;);
1184         JLI_StrCat(splash_file_entry, splash_file_name);
1185         putenv(splash_file_entry);
1186     }
1187     if (splash_jar_name &amp;&amp; !headlessflag) {
<span class="line-modified">1188         splash_jar_entry = JLI_MemAlloc(JLI_StrLen(SPLASH_JAR_ENV_ENTRY &quot;=&quot;)+JLI_StrLen(splash_jar_name)+1);</span>
1189         JLI_StrCpy(splash_jar_entry, SPLASH_JAR_ENV_ENTRY &quot;=&quot;);
1190         JLI_StrCat(splash_jar_entry, splash_jar_name);
1191         putenv(splash_jar_entry);
1192     }
1193 
1194 
1195     /*
1196      * &quot;Valid&quot; returns (other than unrecoverable errors) follow.  Set
1197      * main_class as a side-effect of this routine.
1198      */
1199     if (info.main_class != NULL)
1200         *main_class = JLI_StringDup(info.main_class);
1201 
1202     if (info.jre_version == NULL) {
1203         JLI_FreeManifest();
1204         return;
1205     }
1206 
1207 }
1208 
</pre>
<hr />
<pre>
1423  * The following case provide backward compatibility with old-style
1424  * command line options.
1425  */
1426         } else if (JLI_StrCmp(arg, &quot;-fullversion&quot;) == 0) {
1427             JLI_ReportMessage(&quot;%s full version \&quot;%s\&quot;&quot;, _launcher_name, GetFullVersion());
1428             return JNI_FALSE;
1429         } else if (JLI_StrCmp(arg, &quot;--full-version&quot;) == 0) {
1430             JLI_ShowMessage(&quot;%s %s&quot;, _launcher_name, GetFullVersion());
1431             return JNI_FALSE;
1432         } else if (JLI_StrCmp(arg, &quot;-verbosegc&quot;) == 0) {
1433             AddOption(&quot;-verbose:gc&quot;, NULL);
1434         } else if (JLI_StrCmp(arg, &quot;-t&quot;) == 0) {
1435             AddOption(&quot;-Xt&quot;, NULL);
1436         } else if (JLI_StrCmp(arg, &quot;-tm&quot;) == 0) {
1437             AddOption(&quot;-Xtm&quot;, NULL);
1438         } else if (JLI_StrCmp(arg, &quot;-debug&quot;) == 0) {
1439             AddOption(&quot;-Xdebug&quot;, NULL);
1440         } else if (JLI_StrCmp(arg, &quot;-noclassgc&quot;) == 0) {
1441             AddOption(&quot;-Xnoclassgc&quot;, NULL);
1442         } else if (JLI_StrCmp(arg, &quot;-Xfuture&quot;) == 0) {
<span class="line-added">1443             JLI_ReportErrorMessage(ARG_DEPRECATED, &quot;-Xfuture&quot;);</span>
1444             AddOption(&quot;-Xverify:all&quot;, NULL);
1445         } else if (JLI_StrCmp(arg, &quot;-verify&quot;) == 0) {
1446             AddOption(&quot;-Xverify:all&quot;, NULL);
1447         } else if (JLI_StrCmp(arg, &quot;-verifyremote&quot;) == 0) {
1448             AddOption(&quot;-Xverify:remote&quot;, NULL);
1449         } else if (JLI_StrCmp(arg, &quot;-noverify&quot;) == 0) {
<span class="line-added">1450             /*</span>
<span class="line-added">1451              * Note that no &#39;deprecated&#39; message is needed here because the VM</span>
<span class="line-added">1452              * issues &#39;deprecated&#39; messages for -noverify and -Xverify:none.</span>
<span class="line-added">1453              */</span>
1454             AddOption(&quot;-Xverify:none&quot;, NULL);
1455         } else if (JLI_StrCCmp(arg, &quot;-ss&quot;) == 0 ||
1456                    JLI_StrCCmp(arg, &quot;-oss&quot;) == 0 ||
1457                    JLI_StrCCmp(arg, &quot;-ms&quot;) == 0 ||
1458                    JLI_StrCCmp(arg, &quot;-mx&quot;) == 0) {
1459             char *tmp = JLI_MemAlloc(JLI_StrLen(arg) + 6);
1460             sprintf(tmp, &quot;-X%s&quot;, arg + 1); /* skip &#39;-&#39; */
1461             AddOption(tmp, NULL);
1462         } else if (JLI_StrCmp(arg, &quot;-checksource&quot;) == 0 ||
1463                    JLI_StrCmp(arg, &quot;-cs&quot;) == 0 ||
1464                    JLI_StrCmp(arg, &quot;-noasyncgc&quot;) == 0) {
1465             /* No longer supported */
1466             JLI_ReportErrorMessage(ARG_WARN, arg);
1467         } else if (JLI_StrCCmp(arg, &quot;-splash:&quot;) == 0) {
1468             ; /* Ignore machine independent options already handled */
1469         } else if (ProcessPlatformOption(arg)) {
1470             ; /* Processing of platform dependent options */
1471         } else {
1472             /* java.class.path set on the command line */
1473             if (JLI_StrCCmp(arg, &quot;-Djava.class.path=&quot;) == 0) {
</pre>
<hr />
<pre>
1867     JLI_StrCat(javaCommand, what);
1868 
1869     for (i = 0; i &lt; argc; i++) {
1870         /* the components of the string are space separated. In
1871          * the case of embedded white space, the relationship of
1872          * the white space separated components to their true
1873          * positional arguments will be ambiguous. This issue may
1874          * be addressed in a future release.
1875          */
1876         JLI_StrCat(javaCommand, &quot; &quot;);
1877         JLI_StrCat(javaCommand, argv[i]);
1878     }
1879 
1880     AddOption(javaCommand, NULL);
1881 }
1882 
1883 /*
1884  * JVM would like to know if it&#39;s created by a standard Sun launcher, or by
1885  * user native application, the following property indicates the former.
1886  */
<span class="line-modified">1887 static void SetJavaLauncherProp() {</span>

1888   AddOption(&quot;-Dsun.java.launcher=SUN_STANDARD&quot;, NULL);
1889 }
1890 
1891 /*
1892  * Prints the version information from the java.version and other properties.
1893  */
1894 static void
1895 PrintJavaVersion(JNIEnv *env, jboolean extraLF)
1896 {
1897     jclass ver;
1898     jmethodID print;
1899 
1900     NULL_CHECK(ver = FindBootStrapClass(env, &quot;java/lang/VersionProps&quot;));
1901     NULL_CHECK(print = (*env)-&gt;GetStaticMethodID(env,
1902                                                  ver,
1903                                                  (extraLF == JNI_TRUE) ? &quot;println&quot; : &quot;print&quot;,
1904                                                  &quot;(Z)V&quot;
1905                                                  )
1906               );
1907 
</pre>
<hr />
<pre>
2238 }
2239 
2240 /*
2241  * Displays the splash screen according to the jar file name
2242  * and image file names stored in environment variables
2243  */
2244 void
2245 ShowSplashScreen()
2246 {
2247     const char *jar_name = getenv(SPLASH_JAR_ENV_ENTRY);
2248     const char *file_name = getenv(SPLASH_FILE_ENV_ENTRY);
2249     int data_size;
2250     void *image_data = NULL;
2251     float scale_factor = 1;
2252     char *scaled_splash_name = NULL;
2253     jboolean isImageScaled = JNI_FALSE;
2254     size_t maxScaledImgNameLength = 0;
2255     if (file_name == NULL){
2256         return;
2257     }
<span class="line-added">2258 </span>
<span class="line-added">2259     if (!DoSplashInit()) {</span>
<span class="line-added">2260         goto exit;</span>
<span class="line-added">2261     }</span>
<span class="line-added">2262 </span>
2263     maxScaledImgNameLength = DoSplashGetScaledImgNameMaxPstfixLen(file_name);
2264 
2265     scaled_splash_name = JLI_MemAlloc(
2266                             maxScaledImgNameLength * sizeof(char));
2267     isImageScaled = DoSplashGetScaledImageName(jar_name, file_name,
2268                             &amp;scale_factor,
2269                             scaled_splash_name, maxScaledImgNameLength);
2270     if (jar_name) {
2271 
2272         if (isImageScaled) {
2273             image_data = JLI_JarUnpackFile(
2274                     jar_name, scaled_splash_name, &amp;data_size);
2275         }
2276 
2277         if (!image_data) {
2278             scale_factor = 1;
2279             image_data = JLI_JarUnpackFile(
2280                             jar_name, file_name, &amp;data_size);
2281         }
2282         if (image_data) {

2283             DoSplashSetScaleFactor(scale_factor);
2284             DoSplashLoadMemory(image_data, data_size);
2285             JLI_MemFree(image_data);
<span class="line-added">2286         } else {</span>
<span class="line-added">2287             DoSplashClose();</span>
2288         }
2289     } else {

2290         if (isImageScaled) {
2291             DoSplashSetScaleFactor(scale_factor);
2292             DoSplashLoadFile(scaled_splash_name);
2293         } else {
2294             DoSplashLoadFile(file_name);
2295         }
2296     }
2297     JLI_MemFree(scaled_splash_name);
2298 
2299     DoSplashSetFileJarName(file_name, jar_name);
2300 
<span class="line-added">2301     exit:</span>
2302     /*
2303      * Done with all command line processing and potential re-execs so
2304      * clean up the environment.
2305      */
2306     (void)UnsetEnv(ENV_ENTRY);
2307     (void)UnsetEnv(SPLASH_FILE_ENV_ENTRY);
2308     (void)UnsetEnv(SPLASH_JAR_ENV_ENTRY);
2309 
2310     JLI_MemFree(splash_jar_entry);
2311     JLI_MemFree(splash_file_entry);
2312 
2313 }
2314 
<span class="line-modified">2315 static const char* GetFullVersion()</span>

2316 {
2317     return _fVersion;
2318 }
2319 
<span class="line-modified">2320 static const char* GetProgramName()</span>

2321 {
2322     return _program_name;
2323 }
2324 
<span class="line-modified">2325 static const char* GetLauncherName()</span>

2326 {
2327     return _launcher_name;
2328 }
2329 
<span class="line-modified">2330 static jboolean IsJavaArgs()</span>

2331 {
2332     return _is_java_args;
2333 }
2334 
2335 static jboolean
2336 IsWildCardEnabled()
2337 {
2338     return _wc_enabled;
2339 }
2340 
2341 int
2342 ContinueInNewThread(InvocationFunctions* ifn, jlong threadStackSize,
2343                     int argc, char **argv,
2344                     int mode, char *what, int ret)
2345 {
<span class="line-modified">2346     if (threadStackSize == 0) {</span>
<span class="line-modified">2347         /*</span>
<span class="line-modified">2348          * If the user hasn&#39;t specified a non-zero stack size ask the JVM for its default.</span>
<span class="line-modified">2349          * A returned 0 means &#39;use the system default&#39; for a platform, e.g., Windows.</span>
<span class="line-modified">2350          * Note that HotSpot no longer supports JNI_VERSION_1_1 but it will</span>
<span class="line-modified">2351          * return its default stack size through the init args structure.</span>
<span class="line-modified">2352          */</span>
<span class="line-modified">2353         struct JDK1_1InitArgs args1_1;</span>
<span class="line-modified">2354         memset((void*)&amp;args1_1, 0, sizeof(args1_1));</span>
<span class="line-modified">2355         args1_1.version = JNI_VERSION_1_1;</span>
<span class="line-modified">2356         ifn-&gt;GetDefaultJavaVMInitArgs(&amp;args1_1);  /* ignore return value */</span>
<span class="line-modified">2357         if (args1_1.javaStackSize &gt; 0) {</span>
<span class="line-modified">2358             threadStackSize = args1_1.javaStackSize;</span>
2359         }
2360     }
2361 
2362     { /* Create a new thread to create JVM and invoke main method */
<span class="line-modified">2363         JavaMainArgs args;</span>
<span class="line-modified">2364         int rslt;</span>
<span class="line-modified">2365 </span>
<span class="line-modified">2366         args.argc = argc;</span>
<span class="line-modified">2367         args.argv = argv;</span>
<span class="line-modified">2368         args.mode = mode;</span>
<span class="line-modified">2369         args.what = what;</span>
<span class="line-modified">2370         args.ifn = *ifn;</span>
<span class="line-modified">2371 </span>
<span class="line-modified">2372         rslt = CallJavaMainInNewThread(threadStackSize, (void*)&amp;args);</span>
<span class="line-modified">2373         /* If the caller has deemed there is an error we</span>
<span class="line-modified">2374          * simply return that, otherwise we return the value of</span>
<span class="line-modified">2375          * the callee</span>
<span class="line-modified">2376          */</span>
<span class="line-modified">2377         return (ret != 0) ? ret : rslt;</span>
2378     }
2379 }
2380 
2381 static void
2382 DumpState()
2383 {
2384     if (!JLI_IsTraceLauncher()) return ;
2385     printf(&quot;Launcher state:\n&quot;);
2386     printf(&quot;\tFirst application arg index: %d\n&quot;, JLI_GetAppArgIndex());
2387     printf(&quot;\tdebug:%s\n&quot;, (JLI_IsTraceLauncher() == JNI_TRUE) ? &quot;on&quot; : &quot;off&quot;);
2388     printf(&quot;\tjavargs:%s\n&quot;, (_is_java_args == JNI_TRUE) ? &quot;on&quot; : &quot;off&quot;);
2389     printf(&quot;\tprogram name:%s\n&quot;, GetProgramName());
2390     printf(&quot;\tlauncher name:%s\n&quot;, GetLauncherName());
2391     printf(&quot;\tjavaw:%s\n&quot;, (IsJavaw() == JNI_TRUE) ? &quot;on&quot; : &quot;off&quot;);
2392     printf(&quot;\tfullversion:%s\n&quot;, GetFullVersion());
2393 }
2394 
2395 /*
2396  * A utility procedure to always print to stderr
2397  */
</pre>
</td>
</tr>
</table>
<center><a href="../../classes/module-info.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="java.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
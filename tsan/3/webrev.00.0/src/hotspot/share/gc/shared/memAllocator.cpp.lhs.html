<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shared/memAllocator.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/javaClasses.hpp&quot;
 27 #include &quot;gc/shared/allocTracer.hpp&quot;
 28 #include &quot;gc/shared/collectedHeap.hpp&quot;
 29 #include &quot;gc/shared/memAllocator.hpp&quot;
 30 #include &quot;gc/shared/threadLocalAllocBuffer.inline.hpp&quot;
 31 #include &quot;memory/universe.hpp&quot;
 32 #include &quot;oops/arrayOop.hpp&quot;
 33 #include &quot;oops/oop.inline.hpp&quot;
 34 #include &quot;prims/jvmtiExport.hpp&quot;
 35 #include &quot;runtime/sharedRuntime.hpp&quot;
 36 #include &quot;runtime/handles.inline.hpp&quot;
 37 #include &quot;runtime/thread.inline.hpp&quot;
 38 #include &quot;services/lowMemoryDetector.hpp&quot;
 39 #include &quot;utilities/align.hpp&quot;
 40 #include &quot;utilities/copy.hpp&quot;
 41 
 42 class MemAllocator::Allocation: StackObj {
 43   friend class MemAllocator;
 44 
 45   const MemAllocator&amp; _allocator;
 46   Thread*             _thread;
 47   oop*                _obj_ptr;
 48   bool                _overhead_limit_exceeded;
 49   bool                _allocated_outside_tlab;
 50   size_t              _allocated_tlab_size;
 51   bool                _tlab_end_reset_for_sample;
 52 
 53   bool check_out_of_memory();
 54   void verify_before();
 55   void verify_after();
 56   void notify_allocation();
 57   void notify_allocation_jvmti_allocation_event();
 58   void notify_allocation_jvmti_sampler();
 59   void notify_allocation_low_memory_detector();
 60   void notify_allocation_jfr_sampler();
 61   void notify_allocation_dtrace_sampler();
 62   void check_for_bad_heap_word_value() const;
 63 #ifdef ASSERT
 64   void check_for_valid_allocation_state() const;
 65 #endif
 66 
 67   class PreserveObj;
 68 
 69 public:
 70   Allocation(const MemAllocator&amp; allocator, oop* obj_ptr)
 71     : _allocator(allocator),
 72       _thread(Thread::current()),
 73       _obj_ptr(obj_ptr),
 74       _overhead_limit_exceeded(false),
 75       _allocated_outside_tlab(false),
 76       _allocated_tlab_size(0),
 77       _tlab_end_reset_for_sample(false)
 78   {
 79     verify_before();
 80   }
 81 
 82   ~Allocation() {
 83     if (!check_out_of_memory()) {
 84       verify_after();
 85       notify_allocation();
 86     }
 87   }
 88 
 89   oop obj() const { return *_obj_ptr; }
 90 };
 91 
 92 class MemAllocator::Allocation::PreserveObj: StackObj {
 93   HandleMark _handle_mark;
 94   Handle     _handle;
 95   oop* const _obj_ptr;
 96 
 97 public:
 98   PreserveObj(Thread* thread, oop* obj_ptr)
 99     : _handle_mark(thread),
100       _handle(thread, *obj_ptr),
101       _obj_ptr(obj_ptr)
102   {
103     *obj_ptr = NULL;
104   }
105 
106   ~PreserveObj() {
107     *_obj_ptr = _handle();
108   }
109 
110   oop operator()() const {
111     return _handle();
112   }
113 };
114 
115 bool MemAllocator::Allocation::check_out_of_memory() {
116   Thread* THREAD = _thread;
117   assert(!HAS_PENDING_EXCEPTION, &quot;Unexpected exception, will result in uninitialized storage&quot;);
118 
119   if (obj() != NULL) {
120     return false;
121   }
122 
123   const char* message = _overhead_limit_exceeded ? &quot;GC overhead limit exceeded&quot; : &quot;Java heap space&quot;;
124   if (!THREAD-&gt;in_retryable_allocation()) {
125     // -XX:+HeapDumpOnOutOfMemoryError and -XX:OnOutOfMemoryError support
126     report_java_out_of_memory(message);
127 
128     if (JvmtiExport::should_post_resource_exhausted()) {
129       JvmtiExport::post_resource_exhausted(
130         JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_JAVA_HEAP,
131         message);
132     }
133     oop exception = _overhead_limit_exceeded ?
134         Universe::out_of_memory_error_gc_overhead_limit() :
135         Universe::out_of_memory_error_java_heap();
136     THROW_OOP_(exception, true);
137   } else {
138     THROW_OOP_(Universe::out_of_memory_error_retry(), true);
139   }
140 }
141 
142 void MemAllocator::Allocation::verify_before() {
143   // Clear unhandled oops for memory allocation.  Memory allocation might
144   // not take out a lock if from tlab, so clear here.
145   Thread* THREAD = _thread;
<a name="2" id="anc2"></a><span class="line-removed">146   CHECK_UNHANDLED_OOPS_ONLY(THREAD-&gt;clear_unhandled_oops();)</span>
147   assert(!HAS_PENDING_EXCEPTION, &quot;Should not allocate with exception pending&quot;);
148   debug_only(check_for_valid_allocation_state());
149   assert(!Universe::heap()-&gt;is_gc_active(), &quot;Allocation during gc not allowed&quot;);
150 }
151 
152 void MemAllocator::Allocation::verify_after() {
153   NOT_PRODUCT(check_for_bad_heap_word_value();)
154 }
155 
156 void MemAllocator::Allocation::check_for_bad_heap_word_value() const {
157   MemRegion obj_range = _allocator.obj_memory_range(obj());
158   HeapWord* addr = obj_range.start();
159   size_t size = obj_range.word_size();
160   if (CheckMemoryInitialization &amp;&amp; ZapUnusedHeapArea) {
161     for (size_t slot = 0; slot &lt; size; slot += 1) {
162       assert((*(intptr_t*) (addr + slot)) != ((intptr_t) badHeapWordVal),
163              &quot;Found badHeapWordValue in post-allocation check&quot;);
164     }
165   }
166 }
167 
168 #ifdef ASSERT
169 void MemAllocator::Allocation::check_for_valid_allocation_state() const {
170   // How to choose between a pending exception and a potential
171   // OutOfMemoryError?  Don&#39;t allow pending exceptions.
172   // This is a VM policy failure, so how do we exhaustively test it?
173   assert(!_thread-&gt;has_pending_exception(),
174          &quot;shouldn&#39;t be allocating with pending exception&quot;);
<a name="3" id="anc3"></a><span class="line-modified">175   if (StrictSafepointChecks) {</span>
<span class="line-modified">176     assert(_thread-&gt;allow_allocation(),</span>
<span class="line-removed">177            &quot;Allocation done by thread for which allocation is blocked &quot;</span>
<span class="line-removed">178            &quot;by No_Allocation_Verifier!&quot;);</span>
<span class="line-removed">179     // Allocation of an oop can always invoke a safepoint,</span>
<span class="line-removed">180     // hence, the true argument</span>
<span class="line-removed">181     _thread-&gt;check_for_valid_safepoint_state(true);</span>
<span class="line-removed">182   }</span>
183 }
184 #endif
185 
186 void MemAllocator::Allocation::notify_allocation_jvmti_sampler() {
187   // support for JVMTI VMObjectAlloc event (no-op if not enabled)
188   JvmtiExport::vm_object_alloc_event_collector(obj());
189 
190   if (!JvmtiExport::should_post_sampled_object_alloc()) {
191     // Sampling disabled
192     return;
193   }
194 
195   if (!_allocated_outside_tlab &amp;&amp; _allocated_tlab_size == 0 &amp;&amp; !_tlab_end_reset_for_sample) {
196     // Sample if it&#39;s a non-TLAB allocation, or a TLAB allocation that either refills the TLAB
197     // or expands it due to taking a sampler induced slow path.
198     return;
199   }
200 
<a name="4" id="anc4"></a><span class="line-modified">201   if (JvmtiExport::should_post_sampled_object_alloc()) {</span>
<span class="line-modified">202     // If we want to be sampling, protect the allocated object with a Handle</span>
<span class="line-modified">203     // before doing the callback. The callback is done in the destructor of</span>
<span class="line-modified">204     // the JvmtiSampledObjectAllocEventCollector.</span>


205     PreserveObj obj_h(_thread, _obj_ptr);
206     JvmtiSampledObjectAllocEventCollector collector;
207     size_t size_in_bytes = _allocator._word_size * HeapWordSize;
208     ThreadLocalAllocBuffer&amp; tlab = _thread-&gt;tlab();
<a name="5" id="anc5"></a><span class="line-modified">209     size_t bytes_since_last = _allocated_outside_tlab ? 0 : tlab.bytes_since_last_sample_point();</span>




210     _thread-&gt;heap_sampler().check_for_sampling(obj_h(), size_in_bytes, bytes_since_last);
211   }
212 
213   if (_tlab_end_reset_for_sample || _allocated_tlab_size != 0) {
<a name="6" id="anc6"></a><span class="line-modified">214     _thread-&gt;tlab().set_sample_end();</span>

215   }
216 }
217 
218 void MemAllocator::Allocation::notify_allocation_low_memory_detector() {
219   // support low memory notifications (no-op if not enabled)
220   LowMemoryDetector::detect_low_memory_for_collected_pools();
221 }
222 
223 void MemAllocator::Allocation::notify_allocation_jfr_sampler() {
<a name="7" id="anc7"></a><span class="line-modified">224   HeapWord* mem = (HeapWord*)obj();</span>
225   size_t size_in_bytes = _allocator._word_size * HeapWordSize;
226 
227   if (_allocated_outside_tlab) {
<a name="8" id="anc8"></a><span class="line-modified">228     AllocTracer::send_allocation_outside_tlab(_allocator._klass, mem, size_in_bytes, _thread);</span>
229   } else if (_allocated_tlab_size != 0) {
230     // TLAB was refilled
<a name="9" id="anc9"></a><span class="line-modified">231     AllocTracer::send_allocation_in_new_tlab(_allocator._klass, mem, _allocated_tlab_size * HeapWordSize,</span>
232                                              size_in_bytes, _thread);
233   }
234 }
235 
236 void MemAllocator::Allocation::notify_allocation_dtrace_sampler() {
237   if (DTraceAllocProbes) {
238     // support for Dtrace object alloc event (no-op most of the time)
<a name="10" id="anc10"></a><span class="line-modified">239     Klass* klass = _allocator._klass;</span>
240     size_t word_size = _allocator._word_size;
241     if (klass != NULL &amp;&amp; klass-&gt;name() != NULL) {
242       SharedRuntime::dtrace_object_alloc(obj(), (int)word_size);
243     }
244   }
245 }
246 
247 void MemAllocator::Allocation::notify_allocation() {
248   notify_allocation_low_memory_detector();
249   notify_allocation_jfr_sampler();
250   notify_allocation_dtrace_sampler();
251   notify_allocation_jvmti_sampler();
252   TSAN_RUNTIME_ONLY(
253       SharedRuntime::tsan_track_obj_with_size(obj(), (int)_allocator._word_size);
254   );
255 }
256 
257 HeapWord* MemAllocator::allocate_outside_tlab(Allocation&amp; allocation) const {
258   allocation._allocated_outside_tlab = true;
<a name="11" id="anc11"></a><span class="line-modified">259   HeapWord* mem = _heap-&gt;mem_allocate(_word_size, &amp;allocation._overhead_limit_exceeded);</span>
260   if (mem == NULL) {
261     return mem;
262   }
263 
<a name="12" id="anc12"></a><span class="line-modified">264   NOT_PRODUCT(_heap-&gt;check_for_non_bad_heap_word_value(mem, _word_size));</span>
265   size_t size_in_bytes = _word_size * HeapWordSize;
266   _thread-&gt;incr_allocated_bytes(size_in_bytes);
267 
268   return mem;
269 }
270 
271 HeapWord* MemAllocator::allocate_inside_tlab(Allocation&amp; allocation) const {
272   assert(UseTLAB, &quot;should use UseTLAB&quot;);
273 
274   // Try allocating from an existing TLAB.
275   HeapWord* mem = _thread-&gt;tlab().allocate(_word_size);
276   if (mem != NULL) {
277     return mem;
278   }
279 
280   // Try refilling the TLAB and allocating the object in it.
281   return allocate_inside_tlab_slow(allocation);
282 }
283 
284 HeapWord* MemAllocator::allocate_inside_tlab_slow(Allocation&amp; allocation) const {
285   HeapWord* mem = NULL;
286   ThreadLocalAllocBuffer&amp; tlab = _thread-&gt;tlab();
287 
288   if (JvmtiExport::should_post_sampled_object_alloc()) {
<a name="13" id="anc13"></a><span class="line-removed">289     // Try to allocate the sampled object from TLAB, it is possible a sample</span>
<span class="line-removed">290     // point was put and the TLAB still has space.</span>
291     tlab.set_back_allocation_end();
292     mem = tlab.allocate(_word_size);
<a name="14" id="anc14"></a>




293     if (mem != NULL) {
<a name="15" id="anc15"></a><span class="line-removed">294       allocation._tlab_end_reset_for_sample = true;</span>
295       return mem;
296     }
297   }
298 
299   // Retain tlab and allocate object in shared space if
300   // the amount free in the tlab is too large to discard.
301   if (tlab.free() &gt; tlab.refill_waste_limit()) {
302     tlab.record_slow_allocation(_word_size);
303     return NULL;
304   }
305 
306   // Discard tlab and allocate a new one.
307   // To minimize fragmentation, the last TLAB may be smaller than the rest.
308   size_t new_tlab_size = tlab.compute_size(_word_size);
309 
310   tlab.retire_before_allocation();
311 
312   if (new_tlab_size == 0) {
313     return NULL;
314   }
315 
316   // Allocate a new TLAB requesting new_tlab_size. Any size
317   // between minimal and new_tlab_size is accepted.
318   size_t min_tlab_size = ThreadLocalAllocBuffer::compute_min_size(_word_size);
<a name="16" id="anc16"></a><span class="line-modified">319   mem = _heap-&gt;allocate_new_tlab(min_tlab_size, new_tlab_size, &amp;allocation._allocated_tlab_size);</span>
320   if (mem == NULL) {
321     assert(allocation._allocated_tlab_size == 0,
322            &quot;Allocation failed, but actual size was updated. min: &quot; SIZE_FORMAT
323            &quot;, desired: &quot; SIZE_FORMAT &quot;, actual: &quot; SIZE_FORMAT,
324            min_tlab_size, new_tlab_size, allocation._allocated_tlab_size);
325     return NULL;
326   }
327   assert(allocation._allocated_tlab_size != 0, &quot;Allocation succeeded but actual size not updated. mem at: &quot;
328          PTR_FORMAT &quot; min: &quot; SIZE_FORMAT &quot;, desired: &quot; SIZE_FORMAT,
329          p2i(mem), min_tlab_size, new_tlab_size);
330 
331   if (ZeroTLAB) {
332     // ..and clear it.
333     Copy::zero_to_words(mem, allocation._allocated_tlab_size);
334   } else {
335     // ...and zap just allocated object.
336 #ifdef ASSERT
337     // Skip mangling the space corresponding to the object header to
338     // ensure that the returned space is not considered parsable by
339     // any concurrent GC thread.
340     size_t hdr_size = oopDesc::header_size();
341     Copy::fill_to_words(mem + hdr_size, allocation._allocated_tlab_size - hdr_size, badHeapWordVal);
342 #endif // ASSERT
343   }
344 
345   tlab.fill(mem, mem + _word_size, allocation._allocated_tlab_size);
346   return mem;
347 }
348 
349 HeapWord* MemAllocator::mem_allocate(Allocation&amp; allocation) const {
350   if (UseTLAB) {
351     HeapWord* result = allocate_inside_tlab(allocation);
352     if (result != NULL) {
353       return result;
354     }
355   }
356 
357   return allocate_outside_tlab(allocation);
358 }
359 
360 oop MemAllocator::allocate() const {
361   oop obj = NULL;
362   {
363     Allocation allocation(*this, &amp;obj);
364     HeapWord* mem = mem_allocate(allocation);
365     if (mem != NULL) {
366       obj = initialize(mem);
<a name="17" id="anc17"></a>



367     }
368   }
369   return obj;
370 }
371 
372 void MemAllocator::mem_clear(HeapWord* mem) const {
373   assert(mem != NULL, &quot;cannot initialize NULL object&quot;);
374   const size_t hs = oopDesc::header_size();
375   assert(_word_size &gt;= hs, &quot;unexpected object size&quot;);
376   oopDesc::set_klass_gap(mem, 0);
377   Copy::fill_to_aligned_words(mem + hs, _word_size - hs);
378 }
379 
380 oop MemAllocator::finish(HeapWord* mem) const {
381   assert(mem != NULL, &quot;NULL object pointer&quot;);
382   if (UseBiasedLocking) {
383     oopDesc::set_mark_raw(mem, _klass-&gt;prototype_header());
384   } else {
385     // May be bootstrapping
<a name="18" id="anc18"></a><span class="line-modified">386     oopDesc::set_mark_raw(mem, markOopDesc::prototype());</span>
387   }
388   // Need a release store to ensure array/class length, mark word, and
389   // object zeroing are visible before setting the klass non-NULL, for
390   // concurrent collectors.
391   oopDesc::release_set_klass(mem, _klass);
392   return oop(mem);
393 }
394 
395 oop ObjAllocator::initialize(HeapWord* mem) const {
396   mem_clear(mem);
397   return finish(mem);
398 }
399 
400 MemRegion ObjArrayAllocator::obj_memory_range(oop obj) const {
401   if (_do_zero) {
402     return MemAllocator::obj_memory_range(obj);
403   }
404   ArrayKlass* array_klass = ArrayKlass::cast(_klass);
405   const size_t hs = arrayOopDesc::header_size(array_klass-&gt;element_type());
<a name="19" id="anc19"></a><span class="line-modified">406   return MemRegion(((HeapWord*)obj) + hs, _word_size - hs);</span>
407 }
408 
409 oop ObjArrayAllocator::initialize(HeapWord* mem) const {
410   // Set array length before setting the _klass field because a
411   // non-NULL klass field indicates that the object is parsable by
412   // concurrent GC.
413   assert(_length &gt;= 0, &quot;length should be non-negative&quot;);
414   if (_do_zero) {
415     mem_clear(mem);
416   }
417   arrayOopDesc::set_length(mem, _length);
418   return finish(mem);
419 }
420 
421 oop ClassAllocator::initialize(HeapWord* mem) const {
422   // Set oop_size field before setting the _klass field because a
423   // non-NULL _klass field indicates that the object is parsable by
424   // concurrent GC.
425   assert(_word_size &gt; 0, &quot;oop_size must be positive.&quot;);
426   mem_clear(mem);
427   java_lang_Class::set_oop_size(mem, (int)_word_size);
428   return finish(mem);
429 }
<a name="20" id="anc20"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="20" type="hidden" />
</body>
</html>
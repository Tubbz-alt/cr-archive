<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/collectedHeap.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../../classfile/vmSymbols.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="memAllocator.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/collectedHeap.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_COLLECTEDHEAP_HPP
 26 #define SHARE_GC_SHARED_COLLECTEDHEAP_HPP
 27 
 28 #include &quot;gc/shared/gcCause.hpp&quot;
 29 #include &quot;gc/shared/gcWhen.hpp&quot;

 30 #include &quot;memory/allocation.hpp&quot;
 31 #include &quot;runtime/handles.hpp&quot;
 32 #include &quot;runtime/perfData.hpp&quot;
 33 #include &quot;runtime/safepoint.hpp&quot;
 34 #include &quot;services/memoryUsage.hpp&quot;
 35 #include &quot;utilities/debug.hpp&quot;
 36 #include &quot;utilities/events.hpp&quot;
 37 #include &quot;utilities/formatBuffer.hpp&quot;
 38 #include &quot;utilities/growableArray.hpp&quot;
 39 
 40 // A &quot;CollectedHeap&quot; is an implementation of a java heap for HotSpot.  This
 41 // is an abstract class: there may be many different kinds of heaps.  This
 42 // class defines the functions that a heap must implement, and contains
 43 // infrastructure common to all heaps.
 44 
 45 class AdaptiveSizePolicy;
 46 class BarrierSet;
<span class="line-removed"> 47 class CollectorPolicy;</span>
 48 class GCHeapSummary;
 49 class GCTimer;
 50 class GCTracer;
 51 class GCMemoryManager;
 52 class MemoryPool;
 53 class MetaspaceSummary;

 54 class SoftRefPolicy;
 55 class Thread;
 56 class ThreadClosure;
 57 class VirtualSpaceSummary;
 58 class WorkGang;
 59 class nmethod;
 60 
 61 class GCMessage : public FormatBuffer&lt;1024&gt; {
 62  public:
 63   bool is_before;
 64 
 65  public:
 66   GCMessage() {}
 67 };
 68 
 69 class CollectedHeap;
 70 
 71 class GCHeapLog : public EventLogBase&lt;GCMessage&gt; {
 72  private:
 73   void log_heap(CollectedHeap* heap, bool before);
 74 
 75  public:
<span class="line-modified"> 76   GCHeapLog() : EventLogBase&lt;GCMessage&gt;(&quot;GC Heap History&quot;) {}</span>
 77 
 78   void log_heap_before(CollectedHeap* heap) {
 79     log_heap(heap, true);
 80   }
 81   void log_heap_after(CollectedHeap* heap) {
 82     log_heap(heap, false);
 83   }
 84 };
 85 
 86 //
 87 // CollectedHeap
 88 //   GenCollectedHeap
 89 //     SerialHeap
<span class="line-removed"> 90 //     CMSHeap</span>
 91 //   G1CollectedHeap
 92 //   ParallelScavengeHeap
 93 //   ShenandoahHeap
 94 //   ZCollectedHeap
 95 //
 96 class CollectedHeap : public CHeapObj&lt;mtInternal&gt; {
 97   friend class VMStructs;
 98   friend class JVMCIVMStructs;
 99   friend class IsGCActiveMark; // Block structured external access to _is_gc_active
100   friend class MemAllocator;
101 
102  private:
103   GCHeapLog* _gc_heap_log;
104 


105   MemRegion _reserved;
106 
<span class="line-removed">107  protected:</span>
108   bool _is_gc_active;
109 
110   // Used for filler objects (static, but initialized in ctor).
111   static size_t _filler_array_max_size;
112 
113   unsigned int _total_collections;          // ... started
114   unsigned int _total_full_collections;     // ... started
115   NOT_PRODUCT(volatile size_t _promotion_failure_alot_count;)
116   NOT_PRODUCT(volatile size_t _promotion_failure_alot_gc_number;)
117 
118   // Reason for current garbage collection.  Should be set to
119   // a value reflecting no collection between collections.
120   GCCause::Cause _gc_cause;
121   GCCause::Cause _gc_lastcause;
122   PerfStringVariable* _perf_gc_cause;
123   PerfStringVariable* _perf_gc_lastcause;
124 
125   // Constructor
126   CollectedHeap();
127 
</pre>
<hr />
<pre>
153 
154   // Fill with a single array; caller must ensure filler_array_min_size() &lt;=
155   // words &lt;= filler_array_max_size().
156   static inline void fill_with_array(HeapWord* start, size_t words, bool zap = true);
157 
158   // Fill with a single object (either an int array or a java.lang.Object).
159   static inline void fill_with_object_impl(HeapWord* start, size_t words, bool zap = true);
160 
161   virtual void trace_heap(GCWhen::Type when, const GCTracer* tracer);
162 
163   // Verification functions
164   virtual void check_for_non_bad_heap_word_value(HeapWord* addr, size_t size)
165     PRODUCT_RETURN;
166   debug_only(static void check_for_valid_allocation_state();)
167 
168  public:
169   enum Name {
170     None,
171     Serial,
172     Parallel,
<span class="line-removed">173     CMS,</span>
174     G1,
175     Epsilon,
176     Z,
177     Shenandoah
178   };
179 
180   static inline size_t filler_array_max_size() {
181     return _filler_array_max_size;
182   }
183 
184   virtual Name kind() const = 0;
185 
186   virtual const char* name() const = 0;
187 
188   /**
189    * Returns JNI error code JNI_ENOMEM if memory could not be allocated,
190    * and JNI_OK on success.
191    */
192   virtual jint initialize() = 0;
193 
194   // In many heaps, there will be a need to perform some initialization activities
195   // after the Universe is fully formed, but before general heap allocation is allowed.
196   // This is the correct place to place such initialization methods.
197   virtual void post_initialize();
198 
199   // Stop any onging concurrent work and prepare for exit.
200   virtual void stop() {}
201 
202   // Stop and resume concurrent GC threads interfering with safepoint operations
203   virtual void safepoint_synchronize_begin() {}
204   virtual void safepoint_synchronize_end() {}
205 
<span class="line-modified">206   void initialize_reserved_region(HeapWord *start, HeapWord *end);</span>
<span class="line-modified">207   MemRegion reserved_region() const { return _reserved; }</span>
<span class="line-modified">208   address base() const { return (address)reserved_region().start(); }</span>


209 
210   virtual size_t capacity() const = 0;
211   virtual size_t used() const = 0;
212 



213   // Return &quot;true&quot; if the part of the heap that allocates Java
214   // objects has reached the maximal committed limit that it can
215   // reach, without a garbage collection.
216   virtual bool is_maximal_no_gc() const = 0;
217 
218   // Support for java.lang.Runtime.maxMemory():  return the maximum amount of
219   // memory that the vm could make available for storing &#39;normal&#39; java objects.
220   // This is based on the reserved address space, but should not include space
221   // that the vm uses internally for bookkeeping or temporary storage
222   // (e.g., in the case of the young gen, one of the survivor
223   // spaces).
224   virtual size_t max_capacity() const = 0;
225 
<span class="line-removed">226   // Returns &quot;TRUE&quot; if &quot;p&quot; points into the reserved area of the heap.</span>
<span class="line-removed">227   bool is_in_reserved(const void* p) const {</span>
<span class="line-removed">228     return _reserved.contains(p);</span>
<span class="line-removed">229   }</span>
<span class="line-removed">230 </span>
<span class="line-removed">231   bool is_in_reserved_or_null(const void* p) const {</span>
<span class="line-removed">232     return p == NULL || is_in_reserved(p);</span>
<span class="line-removed">233   }</span>
<span class="line-removed">234 </span>
235   // Returns &quot;TRUE&quot; iff &quot;p&quot; points into the committed areas of the heap.
236   // This method can be expensive so avoid using it in performance critical
237   // code.
238   virtual bool is_in(const void* p) const = 0;
239 
240   DEBUG_ONLY(bool is_in_or_null(const void* p) const { return p == NULL || is_in(p); })
241 
<span class="line-modified">242   // Let&#39;s define some terms: a &quot;closed&quot; subset of a heap is one that</span>
<span class="line-removed">243   //</span>
<span class="line-removed">244   // 1) contains all currently-allocated objects, and</span>
<span class="line-removed">245   //</span>
<span class="line-removed">246   // 2) is closed under reference: no object in the closed subset</span>
<span class="line-removed">247   //    references one outside the closed subset.</span>
<span class="line-removed">248   //</span>
<span class="line-removed">249   // Membership in a heap&#39;s closed subset is useful for assertions.</span>
<span class="line-removed">250   // Clearly, the entire heap is a closed subset, so the default</span>
<span class="line-removed">251   // implementation is to use &quot;is_in_reserved&quot;.  But this may not be too</span>
<span class="line-removed">252   // liberal to perform useful checking.  Also, the &quot;is_in&quot; predicate</span>
<span class="line-removed">253   // defines a closed subset, but may be too expensive, since &quot;is_in&quot;</span>
<span class="line-removed">254   // verifies that its argument points to an object head.  The</span>
<span class="line-removed">255   // &quot;closed_subset&quot; method allows a heap to define an intermediate</span>
<span class="line-removed">256   // predicate, allowing more precise checking than &quot;is_in_reserved&quot; at</span>
<span class="line-removed">257   // lower cost than &quot;is_in.&quot;</span>
<span class="line-removed">258 </span>
<span class="line-removed">259   // One important case is a heap composed of disjoint contiguous spaces,</span>
<span class="line-removed">260   // such as the Garbage-First collector.  Such heaps have a convenient</span>
<span class="line-removed">261   // closed subset consisting of the allocated portions of those</span>
<span class="line-removed">262   // contiguous spaces.</span>
<span class="line-removed">263 </span>
<span class="line-removed">264   // Return &quot;TRUE&quot; iff the given pointer points into the heap&#39;s defined</span>
<span class="line-removed">265   // closed subset (which defaults to the entire heap).</span>
<span class="line-removed">266   virtual bool is_in_closed_subset(const void* p) const {</span>
<span class="line-removed">267     return is_in_reserved(p);</span>
<span class="line-removed">268   }</span>
<span class="line-removed">269 </span>
<span class="line-removed">270   bool is_in_closed_subset_or_null(const void* p) const {</span>
<span class="line-removed">271     return p == NULL || is_in_closed_subset(p);</span>
<span class="line-removed">272   }</span>
273 
274   void set_gc_cause(GCCause::Cause v) {
275      if (UsePerfData) {
276        _gc_lastcause = _gc_cause;
277        _perf_gc_lastcause-&gt;set_value(GCCause::to_string(_gc_lastcause));
278        _perf_gc_cause-&gt;set_value(GCCause::to_string(v));
279      }
280     _gc_cause = v;
281   }
282   GCCause::Cause gc_cause() { return _gc_cause; }
283 
<span class="line-modified">284   virtual oop obj_allocate(Klass* klass, int size, TRAPS);</span>
285   virtual oop array_allocate(Klass* klass, int size, int length, bool do_zero, TRAPS);
<span class="line-modified">286   virtual oop class_allocate(Klass* klass, int size, TRAPS);</span>
287 
288   // Utilities for turning raw memory into filler objects.
289   //
290   // min_fill_size() is the smallest region that can be filled.
291   // fill_with_objects() can fill arbitrary-sized regions of the heap using
292   // multiple objects.  fill_with_object() is for regions known to be smaller
293   // than the largest array of integers; it uses a single object to fill the
294   // region and has slightly less overhead.
295   static size_t min_fill_size() {
296     return size_t(align_object_size(oopDesc::header_size()));
297   }
298 
299   static void fill_with_objects(HeapWord* start, size_t words, bool zap = true);
300 
301   static void fill_with_object(HeapWord* start, size_t words, bool zap = true);
302   static void fill_with_object(MemRegion region, bool zap = true) {
303     fill_with_object(region.start(), region.word_size(), zap);
304   }
305   static void fill_with_object(HeapWord* start, HeapWord* end, bool zap = true) {
306     fill_with_object(start, pointer_delta(end, start), zap);
</pre>
<hr />
<pre>
388   // This interface assumes that it&#39;s being called by the
389   // vm thread. It collects the heap assuming that the
390   // heap lock is already held and that we are executing in
391   // the context of the vm thread.
392   virtual void collect_as_vm_thread(GCCause::Cause cause);
393 
394   virtual MetaWord* satisfy_failed_metadata_allocation(ClassLoaderData* loader_data,
395                                                        size_t size,
396                                                        Metaspace::MetadataType mdtype);
397 
398   // Returns &quot;true&quot; iff there is a stop-world GC in progress.  (I assume
399   // that it should answer &quot;false&quot; for the concurrent part of a concurrent
400   // collector -- dld).
401   bool is_gc_active() const { return _is_gc_active; }
402 
403   // Total number of GC collections (started)
404   unsigned int total_collections() const { return _total_collections; }
405   unsigned int total_full_collections() const { return _total_full_collections;}
406 
407   // Increment total number of GC collections (started)
<span class="line-removed">408   // Should be protected but used by PSMarkSweep - cleanup for 1.4.2</span>
409   void increment_total_collections(bool full = false) {
410     _total_collections++;
411     if (full) {
412       increment_total_full_collections();
413     }
414   }
415 
416   void increment_total_full_collections() { _total_full_collections++; }
417 
<span class="line-removed">418   // Return the CollectorPolicy for the heap</span>
<span class="line-removed">419   virtual CollectorPolicy* collector_policy() const = 0;</span>
<span class="line-removed">420 </span>
421   // Return the SoftRefPolicy for the heap;
422   virtual SoftRefPolicy* soft_ref_policy() = 0;
423 
424   virtual MemoryUsage memory_usage();
425   virtual GrowableArray&lt;GCMemoryManager*&gt; memory_managers() = 0;
426   virtual GrowableArray&lt;MemoryPool*&gt; memory_pools() = 0;
427 
428   // Iterate over all objects, calling &quot;cl.do_object&quot; on each.
429   virtual void object_iterate(ObjectClosure* cl) = 0;
430 
<span class="line-modified">431   // Similar to object_iterate() except iterates only</span>
<span class="line-modified">432   // over live objects.</span>
<span class="line-removed">433   virtual void safe_object_iterate(ObjectClosure* cl) = 0;</span>
<span class="line-removed">434 </span>
<span class="line-removed">435   // NOTE! There is no requirement that a collector implement these</span>
<span class="line-removed">436   // functions.</span>
<span class="line-removed">437   //</span>
<span class="line-removed">438   // A CollectedHeap is divided into a dense sequence of &quot;blocks&quot;; that is,</span>
<span class="line-removed">439   // each address in the (reserved) heap is a member of exactly</span>
<span class="line-removed">440   // one block.  The defining characteristic of a block is that it is</span>
<span class="line-removed">441   // possible to find its size, and thus to progress forward to the next</span>
<span class="line-removed">442   // block.  (Blocks may be of different sizes.)  Thus, blocks may</span>
<span class="line-removed">443   // represent Java objects, or they might be free blocks in a</span>
<span class="line-removed">444   // free-list-based heap (or subheap), as long as the two kinds are</span>
<span class="line-removed">445   // distinguishable and the size of each is determinable.</span>
<span class="line-removed">446 </span>
<span class="line-removed">447   // Returns the address of the start of the &quot;block&quot; that contains the</span>
<span class="line-removed">448   // address &quot;addr&quot;.  We say &quot;blocks&quot; instead of &quot;object&quot; since some heaps</span>
<span class="line-removed">449   // may not pack objects densely; a chunk may either be an object or a</span>
<span class="line-removed">450   // non-object.</span>
<span class="line-removed">451   virtual HeapWord* block_start(const void* addr) const = 0;</span>
<span class="line-removed">452 </span>
<span class="line-removed">453   // Requires &quot;addr&quot; to be the start of a block, and returns &quot;TRUE&quot; iff</span>
<span class="line-removed">454   // the block is an object.</span>
<span class="line-removed">455   virtual bool block_is_obj(const HeapWord* addr) const = 0;</span>
456 
457   // Returns the longest time (in ms) that has elapsed since the last
458   // time that any part of the heap was examined by a garbage collection.
459   virtual jlong millis_since_last_gc() = 0;
460 
461   // Perform any cleanup actions necessary before allowing a verification.
462   virtual void prepare_for_verify() = 0;
463 
464   // Generate any dumps preceding or following a full gc
465  private:
466   void full_gc_dump(GCTimer* timer, bool before);
467 
468   virtual void initialize_serviceability() = 0;
469 
470  public:
471   void pre_full_gc_dump(GCTimer* timer);
472   void post_full_gc_dump(GCTimer* timer);
473 
474   virtual VirtualSpaceSummary create_heap_space_summary();
475   GCHeapSummary create_heap_summary();
476 
477   MetaspaceSummary create_metaspace_summary();
478 
479   // Print heap information on the given outputStream.
480   virtual void print_on(outputStream* st) const = 0;
481   // The default behavior is to call print_on() on tty.
<span class="line-modified">482   virtual void print() const {</span>
<span class="line-modified">483     print_on(tty);</span>
<span class="line-removed">484   }</span>
485   // Print more detailed heap information on the given
486   // outputStream. The default behavior is to call print_on(). It is
487   // up to each subclass to override it and add any additional output
488   // it needs.
489   virtual void print_extended_on(outputStream* st) const {
490     print_on(st);
491   }
492 
493   virtual void print_on_error(outputStream* st) const;
494 



495   // Print all GC threads (other than the VM thread)
496   // used by this heap.
497   virtual void print_gc_threads_on(outputStream* st) const = 0;
498   // The default behavior is to call print_gc_threads_on() on tty.
499   void print_gc_threads() {
500     print_gc_threads_on(tty);
501   }
502   // Iterator for all GC threads (other than VM thread)
503   virtual void gc_threads_do(ThreadClosure* tc) const = 0;
504 
505   // Print any relevant tracing info that flags imply.
506   // Default implementation does nothing.
507   virtual void print_tracing_info() const = 0;
508 
509   void print_heap_before_gc();
510   void print_heap_after_gc();
511 
512   // Registering and unregistering an nmethod (compiled code) with the heap.
<span class="line-modified">513   // Override with specific mechanism for each specialized heap type.</span>
<span class="line-modified">514   virtual void register_nmethod(nmethod* nm) {}</span>
<span class="line-modified">515   virtual void unregister_nmethod(nmethod* nm) {}</span>
<span class="line-modified">516   virtual void flush_nmethod(nmethod* nm) {}</span>
<span class="line-modified">517   virtual void verify_nmethod(nmethod* nmethod) {}</span>
518 
519   void trace_heap_before_gc(const GCTracer* gc_tracer);
520   void trace_heap_after_gc(const GCTracer* gc_tracer);
521 
522   // Heap verification
523   virtual void verify(VerifyOption option) = 0;
524 
525   // Return true if concurrent phase control (via
526   // request_concurrent_phase_control) is supported by this collector.
527   // The default implementation returns false.
528   virtual bool supports_concurrent_phase_control() const;
529 
530   // Request the collector enter the indicated concurrent phase, and
531   // wait until it does so.  Supports WhiteBox testing.  Only one
532   // request may be active at a time.  Phases are designated by name;
533   // the set of names and their meaning is GC-specific.  Once the
534   // requested phase has been reached, the collector will attempt to
535   // avoid transitioning to a new phase until a new request is made.
536   // [Note: A collector might not be able to remain in a given phase.
537   // For example, a full collection might cancel an in-progress
</pre>
<hr />
<pre>
547   // it for use during safepoint cleanup. This is only possible
548   // if the GC can pause and resume concurrent work (e.g. G1
549   // concurrent marking) for an intermittent non-GC safepoint.
550   // If this method returns NULL, SafepointSynchronize will
551   // perform cleanup tasks serially in the VMThread.
552   virtual WorkGang* get_safepoint_workers() { return NULL; }
553 
554   // Support for object pinning. This is used by JNI Get*Critical()
555   // and Release*Critical() family of functions. If supported, the GC
556   // must guarantee that pinned objects never move.
557   virtual bool supports_object_pinning() const;
558   virtual oop pin_object(JavaThread* thread, oop obj);
559   virtual void unpin_object(JavaThread* thread, oop obj);
560 
561   // Deduplicate the string, iff the GC supports string deduplication.
562   virtual void deduplicate_string(oop str);
563 
564   virtual bool is_oop(oop object) const;
565 
566   virtual size_t obj_size(oop obj) const;
<span class="line-removed">567 </span>
<span class="line-removed">568   // Cells are memory slices allocated by the allocator. Objects are initialized</span>
<span class="line-removed">569   // in cells. The cell itself may have a header, found at a negative offset of</span>
<span class="line-removed">570   // oops. Usually, the size of the cell header is 0, but it may be larger.</span>
<span class="line-removed">571   virtual ptrdiff_t cell_header_size() const { return 0; }</span>
572 
573   // Non product verification and debugging.
574 #ifndef PRODUCT
575   // Support for PromotionFailureALot.  Return true if it&#39;s time to cause a
576   // promotion failure.  The no-argument version uses
577   // this-&gt;_promotion_failure_alot_count as the counter.
578   bool promotion_should_fail(volatile size_t* count);
579   bool promotion_should_fail();
580 
581   // Reset the PromotionFailureALot counters.  Should be called at the end of a
582   // GC in which promotion failure occurred.
583   void reset_promotion_should_fail(volatile size_t* count);
584   void reset_promotion_should_fail();
585 #endif  // #ifndef PRODUCT
586 };
587 
588 // Class to set and reset the GC cause for a CollectedHeap.
589 
590 class GCCauseSetter : StackObj {
591   CollectedHeap* _heap;
</pre>
</td>
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_SHARED_COLLECTEDHEAP_HPP
 26 #define SHARE_GC_SHARED_COLLECTEDHEAP_HPP
 27 
 28 #include &quot;gc/shared/gcCause.hpp&quot;
 29 #include &quot;gc/shared/gcWhen.hpp&quot;
<span class="line-added"> 30 #include &quot;gc/shared/verifyOption.hpp&quot;</span>
 31 #include &quot;memory/allocation.hpp&quot;
 32 #include &quot;runtime/handles.hpp&quot;
 33 #include &quot;runtime/perfData.hpp&quot;
 34 #include &quot;runtime/safepoint.hpp&quot;
 35 #include &quot;services/memoryUsage.hpp&quot;
 36 #include &quot;utilities/debug.hpp&quot;
 37 #include &quot;utilities/events.hpp&quot;
 38 #include &quot;utilities/formatBuffer.hpp&quot;
 39 #include &quot;utilities/growableArray.hpp&quot;
 40 
 41 // A &quot;CollectedHeap&quot; is an implementation of a java heap for HotSpot.  This
 42 // is an abstract class: there may be many different kinds of heaps.  This
 43 // class defines the functions that a heap must implement, and contains
 44 // infrastructure common to all heaps.
 45 
 46 class AdaptiveSizePolicy;
 47 class BarrierSet;

 48 class GCHeapSummary;
 49 class GCTimer;
 50 class GCTracer;
 51 class GCMemoryManager;
 52 class MemoryPool;
 53 class MetaspaceSummary;
<span class="line-added"> 54 class ReservedHeapSpace;</span>
 55 class SoftRefPolicy;
 56 class Thread;
 57 class ThreadClosure;
 58 class VirtualSpaceSummary;
 59 class WorkGang;
 60 class nmethod;
 61 
 62 class GCMessage : public FormatBuffer&lt;1024&gt; {
 63  public:
 64   bool is_before;
 65 
 66  public:
 67   GCMessage() {}
 68 };
 69 
 70 class CollectedHeap;
 71 
 72 class GCHeapLog : public EventLogBase&lt;GCMessage&gt; {
 73  private:
 74   void log_heap(CollectedHeap* heap, bool before);
 75 
 76  public:
<span class="line-modified"> 77   GCHeapLog() : EventLogBase&lt;GCMessage&gt;(&quot;GC Heap History&quot;, &quot;gc&quot;) {}</span>
 78 
 79   void log_heap_before(CollectedHeap* heap) {
 80     log_heap(heap, true);
 81   }
 82   void log_heap_after(CollectedHeap* heap) {
 83     log_heap(heap, false);
 84   }
 85 };
 86 
 87 //
 88 // CollectedHeap
 89 //   GenCollectedHeap
 90 //     SerialHeap

 91 //   G1CollectedHeap
 92 //   ParallelScavengeHeap
 93 //   ShenandoahHeap
 94 //   ZCollectedHeap
 95 //
 96 class CollectedHeap : public CHeapObj&lt;mtInternal&gt; {
 97   friend class VMStructs;
 98   friend class JVMCIVMStructs;
 99   friend class IsGCActiveMark; // Block structured external access to _is_gc_active
100   friend class MemAllocator;
101 
102  private:
103   GCHeapLog* _gc_heap_log;
104 
<span class="line-added">105  protected:</span>
<span class="line-added">106   // Not used by all GCs</span>
107   MemRegion _reserved;
108 

109   bool _is_gc_active;
110 
111   // Used for filler objects (static, but initialized in ctor).
112   static size_t _filler_array_max_size;
113 
114   unsigned int _total_collections;          // ... started
115   unsigned int _total_full_collections;     // ... started
116   NOT_PRODUCT(volatile size_t _promotion_failure_alot_count;)
117   NOT_PRODUCT(volatile size_t _promotion_failure_alot_gc_number;)
118 
119   // Reason for current garbage collection.  Should be set to
120   // a value reflecting no collection between collections.
121   GCCause::Cause _gc_cause;
122   GCCause::Cause _gc_lastcause;
123   PerfStringVariable* _perf_gc_cause;
124   PerfStringVariable* _perf_gc_lastcause;
125 
126   // Constructor
127   CollectedHeap();
128 
</pre>
<hr />
<pre>
154 
155   // Fill with a single array; caller must ensure filler_array_min_size() &lt;=
156   // words &lt;= filler_array_max_size().
157   static inline void fill_with_array(HeapWord* start, size_t words, bool zap = true);
158 
159   // Fill with a single object (either an int array or a java.lang.Object).
160   static inline void fill_with_object_impl(HeapWord* start, size_t words, bool zap = true);
161 
162   virtual void trace_heap(GCWhen::Type when, const GCTracer* tracer);
163 
164   // Verification functions
165   virtual void check_for_non_bad_heap_word_value(HeapWord* addr, size_t size)
166     PRODUCT_RETURN;
167   debug_only(static void check_for_valid_allocation_state();)
168 
169  public:
170   enum Name {
171     None,
172     Serial,
173     Parallel,

174     G1,
175     Epsilon,
176     Z,
177     Shenandoah
178   };
179 
180   static inline size_t filler_array_max_size() {
181     return _filler_array_max_size;
182   }
183 
184   virtual Name kind() const = 0;
185 
186   virtual const char* name() const = 0;
187 
188   /**
189    * Returns JNI error code JNI_ENOMEM if memory could not be allocated,
190    * and JNI_OK on success.
191    */
192   virtual jint initialize() = 0;
193 
194   // In many heaps, there will be a need to perform some initialization activities
195   // after the Universe is fully formed, but before general heap allocation is allowed.
196   // This is the correct place to place such initialization methods.
197   virtual void post_initialize();
198 
199   // Stop any onging concurrent work and prepare for exit.
200   virtual void stop() {}
201 
202   // Stop and resume concurrent GC threads interfering with safepoint operations
203   virtual void safepoint_synchronize_begin() {}
204   virtual void safepoint_synchronize_end() {}
205 
<span class="line-modified">206   // TODO(tsan): _reserved MemRegion is not available to all collectors.</span>
<span class="line-modified">207   // Should we support collectors without _reserved MemRegion? See 8224815.</span>
<span class="line-modified">208   TSAN_ONLY(MemRegion reserved_region() const { return _reserved; })</span>
<span class="line-added">209 </span>
<span class="line-added">210   void initialize_reserved_region(const ReservedHeapSpace&amp; rs);</span>
211 
212   virtual size_t capacity() const = 0;
213   virtual size_t used() const = 0;
214 
<span class="line-added">215   // Returns unused capacity.</span>
<span class="line-added">216   virtual size_t unused() const;</span>
<span class="line-added">217 </span>
218   // Return &quot;true&quot; if the part of the heap that allocates Java
219   // objects has reached the maximal committed limit that it can
220   // reach, without a garbage collection.
221   virtual bool is_maximal_no_gc() const = 0;
222 
223   // Support for java.lang.Runtime.maxMemory():  return the maximum amount of
224   // memory that the vm could make available for storing &#39;normal&#39; java objects.
225   // This is based on the reserved address space, but should not include space
226   // that the vm uses internally for bookkeeping or temporary storage
227   // (e.g., in the case of the young gen, one of the survivor
228   // spaces).
229   virtual size_t max_capacity() const = 0;
230 









231   // Returns &quot;TRUE&quot; iff &quot;p&quot; points into the committed areas of the heap.
232   // This method can be expensive so avoid using it in performance critical
233   // code.
234   virtual bool is_in(const void* p) const = 0;
235 
236   DEBUG_ONLY(bool is_in_or_null(const void* p) const { return p == NULL || is_in(p); })
237 
<span class="line-modified">238   virtual uint32_t hash_oop(oop obj) const;</span>






























239 
240   void set_gc_cause(GCCause::Cause v) {
241      if (UsePerfData) {
242        _gc_lastcause = _gc_cause;
243        _perf_gc_lastcause-&gt;set_value(GCCause::to_string(_gc_lastcause));
244        _perf_gc_cause-&gt;set_value(GCCause::to_string(v));
245      }
246     _gc_cause = v;
247   }
248   GCCause::Cause gc_cause() { return _gc_cause; }
249 
<span class="line-modified">250   oop obj_allocate(Klass* klass, int size, TRAPS);</span>
251   virtual oop array_allocate(Klass* klass, int size, int length, bool do_zero, TRAPS);
<span class="line-modified">252   oop class_allocate(Klass* klass, int size, TRAPS);</span>
253 
254   // Utilities for turning raw memory into filler objects.
255   //
256   // min_fill_size() is the smallest region that can be filled.
257   // fill_with_objects() can fill arbitrary-sized regions of the heap using
258   // multiple objects.  fill_with_object() is for regions known to be smaller
259   // than the largest array of integers; it uses a single object to fill the
260   // region and has slightly less overhead.
261   static size_t min_fill_size() {
262     return size_t(align_object_size(oopDesc::header_size()));
263   }
264 
265   static void fill_with_objects(HeapWord* start, size_t words, bool zap = true);
266 
267   static void fill_with_object(HeapWord* start, size_t words, bool zap = true);
268   static void fill_with_object(MemRegion region, bool zap = true) {
269     fill_with_object(region.start(), region.word_size(), zap);
270   }
271   static void fill_with_object(HeapWord* start, HeapWord* end, bool zap = true) {
272     fill_with_object(start, pointer_delta(end, start), zap);
</pre>
<hr />
<pre>
354   // This interface assumes that it&#39;s being called by the
355   // vm thread. It collects the heap assuming that the
356   // heap lock is already held and that we are executing in
357   // the context of the vm thread.
358   virtual void collect_as_vm_thread(GCCause::Cause cause);
359 
360   virtual MetaWord* satisfy_failed_metadata_allocation(ClassLoaderData* loader_data,
361                                                        size_t size,
362                                                        Metaspace::MetadataType mdtype);
363 
364   // Returns &quot;true&quot; iff there is a stop-world GC in progress.  (I assume
365   // that it should answer &quot;false&quot; for the concurrent part of a concurrent
366   // collector -- dld).
367   bool is_gc_active() const { return _is_gc_active; }
368 
369   // Total number of GC collections (started)
370   unsigned int total_collections() const { return _total_collections; }
371   unsigned int total_full_collections() const { return _total_full_collections;}
372 
373   // Increment total number of GC collections (started)

374   void increment_total_collections(bool full = false) {
375     _total_collections++;
376     if (full) {
377       increment_total_full_collections();
378     }
379   }
380 
381   void increment_total_full_collections() { _total_full_collections++; }
382 



383   // Return the SoftRefPolicy for the heap;
384   virtual SoftRefPolicy* soft_ref_policy() = 0;
385 
386   virtual MemoryUsage memory_usage();
387   virtual GrowableArray&lt;GCMemoryManager*&gt; memory_managers() = 0;
388   virtual GrowableArray&lt;MemoryPool*&gt; memory_pools() = 0;
389 
390   // Iterate over all objects, calling &quot;cl.do_object&quot; on each.
391   virtual void object_iterate(ObjectClosure* cl) = 0;
392 
<span class="line-modified">393   // Keep alive an object that was loaded with AS_NO_KEEPALIVE.</span>
<span class="line-modified">394   virtual void keep_alive(oop obj) {}</span>























395 
396   // Returns the longest time (in ms) that has elapsed since the last
397   // time that any part of the heap was examined by a garbage collection.
398   virtual jlong millis_since_last_gc() = 0;
399 
400   // Perform any cleanup actions necessary before allowing a verification.
401   virtual void prepare_for_verify() = 0;
402 
403   // Generate any dumps preceding or following a full gc
404  private:
405   void full_gc_dump(GCTimer* timer, bool before);
406 
407   virtual void initialize_serviceability() = 0;
408 
409  public:
410   void pre_full_gc_dump(GCTimer* timer);
411   void post_full_gc_dump(GCTimer* timer);
412 
413   virtual VirtualSpaceSummary create_heap_space_summary();
414   GCHeapSummary create_heap_summary();
415 
416   MetaspaceSummary create_metaspace_summary();
417 
418   // Print heap information on the given outputStream.
419   virtual void print_on(outputStream* st) const = 0;
420   // The default behavior is to call print_on() on tty.
<span class="line-modified">421   virtual void print() const;</span>
<span class="line-modified">422 </span>

423   // Print more detailed heap information on the given
424   // outputStream. The default behavior is to call print_on(). It is
425   // up to each subclass to override it and add any additional output
426   // it needs.
427   virtual void print_extended_on(outputStream* st) const {
428     print_on(st);
429   }
430 
431   virtual void print_on_error(outputStream* st) const;
432 
<span class="line-added">433   // Used to print information about locations in the hs_err file.</span>
<span class="line-added">434   virtual bool print_location(outputStream* st, void* addr) const = 0;</span>
<span class="line-added">435 </span>
436   // Print all GC threads (other than the VM thread)
437   // used by this heap.
438   virtual void print_gc_threads_on(outputStream* st) const = 0;
439   // The default behavior is to call print_gc_threads_on() on tty.
440   void print_gc_threads() {
441     print_gc_threads_on(tty);
442   }
443   // Iterator for all GC threads (other than VM thread)
444   virtual void gc_threads_do(ThreadClosure* tc) const = 0;
445 
446   // Print any relevant tracing info that flags imply.
447   // Default implementation does nothing.
448   virtual void print_tracing_info() const = 0;
449 
450   void print_heap_before_gc();
451   void print_heap_after_gc();
452 
453   // Registering and unregistering an nmethod (compiled code) with the heap.
<span class="line-modified">454   virtual void register_nmethod(nmethod* nm) = 0;</span>
<span class="line-modified">455   virtual void unregister_nmethod(nmethod* nm) = 0;</span>
<span class="line-modified">456   // Callback for when nmethod is about to be deleted.</span>
<span class="line-modified">457   virtual void flush_nmethod(nmethod* nm) = 0;</span>
<span class="line-modified">458   virtual void verify_nmethod(nmethod* nm) = 0;</span>
459 
460   void trace_heap_before_gc(const GCTracer* gc_tracer);
461   void trace_heap_after_gc(const GCTracer* gc_tracer);
462 
463   // Heap verification
464   virtual void verify(VerifyOption option) = 0;
465 
466   // Return true if concurrent phase control (via
467   // request_concurrent_phase_control) is supported by this collector.
468   // The default implementation returns false.
469   virtual bool supports_concurrent_phase_control() const;
470 
471   // Request the collector enter the indicated concurrent phase, and
472   // wait until it does so.  Supports WhiteBox testing.  Only one
473   // request may be active at a time.  Phases are designated by name;
474   // the set of names and their meaning is GC-specific.  Once the
475   // requested phase has been reached, the collector will attempt to
476   // avoid transitioning to a new phase until a new request is made.
477   // [Note: A collector might not be able to remain in a given phase.
478   // For example, a full collection might cancel an in-progress
</pre>
<hr />
<pre>
488   // it for use during safepoint cleanup. This is only possible
489   // if the GC can pause and resume concurrent work (e.g. G1
490   // concurrent marking) for an intermittent non-GC safepoint.
491   // If this method returns NULL, SafepointSynchronize will
492   // perform cleanup tasks serially in the VMThread.
493   virtual WorkGang* get_safepoint_workers() { return NULL; }
494 
495   // Support for object pinning. This is used by JNI Get*Critical()
496   // and Release*Critical() family of functions. If supported, the GC
497   // must guarantee that pinned objects never move.
498   virtual bool supports_object_pinning() const;
499   virtual oop pin_object(JavaThread* thread, oop obj);
500   virtual void unpin_object(JavaThread* thread, oop obj);
501 
502   // Deduplicate the string, iff the GC supports string deduplication.
503   virtual void deduplicate_string(oop str);
504 
505   virtual bool is_oop(oop object) const;
506 
507   virtual size_t obj_size(oop obj) const;





508 
509   // Non product verification and debugging.
510 #ifndef PRODUCT
511   // Support for PromotionFailureALot.  Return true if it&#39;s time to cause a
512   // promotion failure.  The no-argument version uses
513   // this-&gt;_promotion_failure_alot_count as the counter.
514   bool promotion_should_fail(volatile size_t* count);
515   bool promotion_should_fail();
516 
517   // Reset the PromotionFailureALot counters.  Should be called at the end of a
518   // GC in which promotion failure occurred.
519   void reset_promotion_should_fail(volatile size_t* count);
520   void reset_promotion_should_fail();
521 #endif  // #ifndef PRODUCT
522 };
523 
524 // Class to set and reset the GC cause for a CollectedHeap.
525 
526 class GCCauseSetter : StackObj {
527   CollectedHeap* _heap;
</pre>
</td>
</tr>
</table>
<center><a href="../../classfile/vmSymbols.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="memAllocator.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
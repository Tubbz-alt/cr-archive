diff a/src/hotspot/share/gc/shenandoah/shenandoahRootProcessor.cpp b/src/hotspot/share/gc/shenandoah/shenandoahRootProcessor.cpp
--- a/src/hotspot/share/gc/shenandoah/shenandoahRootProcessor.cpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahRootProcessor.cpp
@@ -1,7 +1,8 @@
 /*
- * Copyright (c) 2015, 2019, Red Hat, Inc. All rights reserved.
+ * Copyright (c) 2015, 2020, Red Hat, Inc. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
  *
@@ -25,290 +26,280 @@
 
 #include "classfile/classLoaderDataGraph.hpp"
 #include "classfile/stringTable.hpp"
 #include "classfile/systemDictionary.hpp"
 #include "code/codeCache.hpp"
-#include "gc/shenandoah/shenandoahRootProcessor.hpp"
+#include "gc/shenandoah/shenandoahClosures.inline.hpp"
+#include "gc/shenandoah/shenandoahConcurrentRoots.hpp"
+#include "gc/shenandoah/shenandoahRootProcessor.inline.hpp"
 #include "gc/shenandoah/shenandoahHeap.hpp"
 #include "gc/shenandoah/shenandoahPhaseTimings.hpp"
 #include "gc/shenandoah/shenandoahStringDedup.hpp"
 #include "gc/shenandoah/shenandoahTimingTracker.hpp"
-#include "gc/shenandoah/shenandoahUtils.hpp"
-#include "gc/shenandoah/shenandoahVMOperations.hpp"
-#include "gc/shared/weakProcessor.inline.hpp"
+#include "gc/shenandoah/shenandoahVMOperations.hpp"
 #include "memory/allocation.inline.hpp"
 #include "memory/iterator.hpp"
 #include "memory/resourceArea.hpp"
+#include "memory/universe.hpp"
 #include "runtime/thread.hpp"
 #include "services/management.hpp"
+#include "tsan/tsanOopMap.hpp"
 
-struct PhaseMap {
-  WeakProcessorPhases::Phase            _weak_processor_phase;
-  ShenandoahPhaseTimings::GCParPhases   _shenandoah_phase;
-};
-
-static const struct PhaseMap phase_mapping[] = {
-#if INCLUDE_JVMTI
-  {WeakProcessorPhases::jvmti,       ShenandoahPhaseTimings::JVMTIWeakRoots},
-#endif
-#if INCLUDE_JFR
-  {WeakProcessorPhases::jfr,         ShenandoahPhaseTimings::JFRWeakRoots},
-#endif
-#if INCLUDE_TSAN
-  {WeakProcessorPhases::tsan,        ShenandoahPhaseTimings::TSANWeakRoots},
-#endif
-  {WeakProcessorPhases::jni,         ShenandoahPhaseTimings::JNIWeakRoots},
-  {WeakProcessorPhases::stringtable, ShenandoahPhaseTimings::StringTableRoots},
-  {WeakProcessorPhases::vm,          ShenandoahPhaseTimings::VMWeakRoots}
-};
-
-STATIC_ASSERT(sizeof(phase_mapping) / sizeof(PhaseMap) == WeakProcessorPhases::phase_count);
-
-ShenandoahRootProcessor::ShenandoahRootProcessor(ShenandoahHeap* heap, uint n_workers,
-                                                 ShenandoahPhaseTimings::Phase phase) :
-  _process_strong_tasks(new SubTasksDone(SHENANDOAH_RP_PS_NumElements)),
-  _srs(n_workers),
-  _par_state_string(StringTable::weak_storage()),
-  _phase(phase),
-  _coderoots_all_iterator(ShenandoahCodeRoots::iterator()),
-  _weak_processor_timings(n_workers),
-  _weak_processor_task(&_weak_processor_timings, n_workers),
-  _processed_weak_roots(false) {
-  heap->phase_timings()->record_workers_start(_phase);
+ShenandoahSerialRoot::ShenandoahSerialRoot(ShenandoahSerialRoot::OopsDo oops_do, ShenandoahPhaseTimings::GCParPhases phase) :
+  _oops_do(oops_do), _phase(phase) {
+}
 
-  if (ShenandoahStringDedup::is_enabled()) {
-    StringDedup::gc_prologue(false);
+void ShenandoahSerialRoot::oops_do(OopClosure* cl, uint worker_id) {
+  if (_claimed.try_set()) {
+    ShenandoahWorkerTimings* worker_times = ShenandoahHeap::heap()->phase_timings()->worker_times();
+    ShenandoahWorkerTimingsTracker timer(worker_times, _phase, worker_id);
+    _oops_do(cl);
   }
 }
 
-ShenandoahRootProcessor::~ShenandoahRootProcessor() {
-  delete _process_strong_tasks;
-  if (ShenandoahStringDedup::is_enabled()) {
-    StringDedup::gc_epilogue();
-  }
+// Overwrite the second argument for SD::oops_do, don't include vm global oop storage.
+static void system_dictionary_oops_do(OopClosure* cl) {
+  SystemDictionary::oops_do(cl, false);
+}
 
-  ShenandoahWorkerTimings* worker_times = ShenandoahHeap::heap()->phase_timings()->worker_times();
+ShenandoahSerialRoots::ShenandoahSerialRoots() :
+  _universe_root(&Universe::oops_do, ShenandoahPhaseTimings::UniverseRoots),
+  _object_synchronizer_root(&ObjectSynchronizer::oops_do, ShenandoahPhaseTimings::ObjectSynchronizerRoots),
+  _management_root(&Management::oops_do, ShenandoahPhaseTimings::ManagementRoots),
+  _system_dictionary_root(&system_dictionary_oops_do, ShenandoahPhaseTimings::SystemDictionaryRoots),
+  _jvmti_root(&JvmtiExport::oops_do, ShenandoahPhaseTimings::JVMTIRoots) {
+}
 
-  if (_processed_weak_roots) {
-    assert(_weak_processor_timings.max_threads() == n_workers(), "Must match");
-    for (uint index = 0; index < WeakProcessorPhases::phase_count; index ++) {
-      weak_processor_timing_to_shenandoah_timing(phase_mapping[index]._weak_processor_phase,
-                                                 phase_mapping[index]._shenandoah_phase,
-                                                 worker_times);
-    }
-  }
+void ShenandoahSerialRoots::oops_do(OopClosure* cl, uint worker_id) {
+  _universe_root.oops_do(cl, worker_id);
+  _object_synchronizer_root.oops_do(cl, worker_id);
+  _management_root.oops_do(cl, worker_id);
+  _system_dictionary_root.oops_do(cl, worker_id);
+  _jvmti_root.oops_do(cl, worker_id);
+}
 
-  ShenandoahHeap::heap()->phase_timings()->record_workers_end(_phase);
+ShenandoahWeakSerialRoot::ShenandoahWeakSerialRoot(ShenandoahWeakSerialRoot::WeakOopsDo weak_oops_do, ShenandoahPhaseTimings::GCParPhases phase) :
+  _weak_oops_do(weak_oops_do), _phase(phase) {
 }
 
-void ShenandoahRootProcessor::weak_processor_timing_to_shenandoah_timing(const WeakProcessorPhases::Phase wpp,
-                                                                         const ShenandoahPhaseTimings::GCParPhases spp,
-                                                                         ShenandoahWorkerTimings* worker_times) const {
-  if (WeakProcessorPhases::is_serial(wpp)) {
-    worker_times->record_time_secs(spp, 0, _weak_processor_timings.phase_time_sec(wpp));
-  } else {
-    for (uint index = 0; index < _weak_processor_timings.max_threads(); index ++) {
-      worker_times->record_time_secs(spp, index, _weak_processor_timings.worker_time_sec(index, wpp));
-    }
+void ShenandoahWeakSerialRoot::weak_oops_do(BoolObjectClosure* is_alive, OopClosure* keep_alive, uint worker_id) {
+  if (_claimed.try_set()) {
+    ShenandoahWorkerTimings* worker_times = ShenandoahHeap::heap()->phase_timings()->worker_times();
+    ShenandoahWorkerTimingsTracker timer(worker_times, _phase, worker_id);
+    _weak_oops_do(is_alive, keep_alive);
   }
 }
 
-void ShenandoahRootProcessor::process_all_roots_slow(OopClosure* oops) {
-  CLDToOopClosure clds(oops, ClassLoaderData::_claim_strong);
-  CodeBlobToOopClosure blobs(oops, !CodeBlobToOopClosure::FixRelocations);
-
-  CodeCache::blobs_do(&blobs);
-  ClassLoaderDataGraph::cld_do(&clds);
-  Universe::oops_do(oops);
-  Management::oops_do(oops);
-  JvmtiExport::oops_do(oops);
-  JNIHandles::oops_do(oops);
-  WeakProcessor::oops_do(oops);
-  ObjectSynchronizer::oops_do(oops);
-  SystemDictionary::oops_do(oops);
-
-  if (ShenandoahStringDedup::is_enabled()) {
-    ShenandoahStringDedup::oops_do_slow(oops);
-  }
+#if INCLUDE_JVMTI
+ShenandoahJVMTIWeakRoot::ShenandoahJVMTIWeakRoot() :
+  ShenandoahWeakSerialRoot(&JvmtiExport::weak_oops_do, ShenandoahPhaseTimings::JVMTIWeakRoots) {
+}
+#endif // INCLUDE_JVMTI
 
-  // Do thread roots the last. This allows verification code to find
-  // any broken objects from those special roots first, not the accidental
-  // dangling reference from the thread root.
-  Threads::possibly_parallel_oops_do(false, oops, &blobs);
+#if INCLUDE_JFR
+ShenandoahJFRWeakRoot::ShenandoahJFRWeakRoot() :
+  ShenandoahWeakSerialRoot(&Jfr::weak_oops_do, ShenandoahPhaseTimings::JFRWeakRoots) {
 }
+#endif // INCLUDE_JFR
 
-void ShenandoahRootProcessor::process_strong_roots(OopClosure* oops,
-                                                   OopClosure* weak_oops,
-                                                   CLDClosure* clds,
-                                                   CLDClosure* weak_clds,
-                                                   CodeBlobClosure* blobs,
-                                                   ThreadClosure* thread_cl,
-                                                   uint worker_id) {
+#if INCLUDE_TSAN
+ShenandoahTSANWeakRoot::ShenandoahTSANWeakRoot() :
+  ShenandoahWeakSerialRoot(&TsanOopMap::weak_oops_do, ShenandoahPhaseTimings::TSANWeakRoots) {
+}
+#endif // INCLUDE_TSAN
 
-  process_java_roots(oops, clds, weak_clds, blobs, thread_cl, worker_id);
-  process_vm_roots(oops, NULL, weak_oops, worker_id);
+void ShenandoahSerialWeakRoots::weak_oops_do(BoolObjectClosure* is_alive, OopClosure* keep_alive, uint worker_id) {
+  JVMTI_ONLY(_jvmti_weak_roots.weak_oops_do(is_alive, keep_alive, worker_id);)
+  JFR_ONLY(_jfr_weak_roots.weak_oops_do(is_alive, keep_alive, worker_id);)
+  TSAN_ONLY(_tsan_weak_roots.weak_oops_do(is_alive, keep_alive, worker_id);)
+}
 
-  _process_strong_tasks->all_tasks_completed(n_workers());
+void ShenandoahSerialWeakRoots::weak_oops_do(OopClosure* cl, uint worker_id) {
+  AlwaysTrueClosure always_true;
+  weak_oops_do(&always_true, cl, worker_id);
 }
 
-void ShenandoahRootProcessor::process_all_roots(OopClosure* oops,
-                                                OopClosure* weak_oops,
-                                                CLDClosure* clds,
-                                                CodeBlobClosure* blobs,
-                                                ThreadClosure* thread_cl,
-                                                uint worker_id) {
+ShenandoahThreadRoots::ShenandoahThreadRoots(bool is_par) : _is_par(is_par) {
+  Threads::change_thread_claim_token();
+}
 
+void ShenandoahThreadRoots::oops_do(OopClosure* oops_cl, CodeBlobClosure* code_cl, uint worker_id) {
   ShenandoahWorkerTimings* worker_times = ShenandoahHeap::heap()->phase_timings()->worker_times();
-  process_java_roots(oops, clds, clds, blobs, thread_cl, worker_id);
-  process_vm_roots(oops, oops, weak_oops, worker_id);
+  ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::ThreadRoots, worker_id);
+  ResourceMark rm;
+  Threads::possibly_parallel_oops_do(_is_par, oops_cl, code_cl);
+}
 
-  if (blobs != NULL) {
-    ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::CodeCacheRoots, worker_id);
-    _coderoots_all_iterator.possibly_parallel_blobs_do(blobs);
-  }
+void ShenandoahThreadRoots::threads_do(ThreadClosure* tc, uint worker_id) {
+  ShenandoahWorkerTimings* worker_times = ShenandoahHeap::heap()->phase_timings()->worker_times();
+  ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::ThreadRoots, worker_id);
+  ResourceMark rm;
+  Threads::possibly_parallel_threads_do(_is_par, tc);
+}
 
-  _process_strong_tasks->all_tasks_completed(n_workers());
+ShenandoahThreadRoots::~ShenandoahThreadRoots() {
+  Threads::assert_all_threads_claimed();
 }
 
-class ShenandoahParallelOopsDoThreadClosure : public ThreadClosure {
-private:
-  OopClosure* _f;
-  CodeBlobClosure* _cf;
-  ThreadClosure* _thread_cl;
-public:
-  ShenandoahParallelOopsDoThreadClosure(OopClosure* f, CodeBlobClosure* cf, ThreadClosure* thread_cl) :
-    _f(f), _cf(cf), _thread_cl(thread_cl) {}
-
-  void do_thread(Thread* t) {
-    if (_thread_cl != NULL) {
-      _thread_cl->do_thread(t);
-    }
-    t->oops_do(_f, _cf);
-  }
-};
-
-void ShenandoahRootProcessor::process_java_roots(OopClosure* strong_roots,
-                                                 CLDClosure* strong_clds,
-                                                 CLDClosure* weak_clds,
-                                                 CodeBlobClosure* strong_code,
-                                                 ThreadClosure* thread_cl,
-                                                 uint worker_id)
-{
-  ShenandoahWorkerTimings* worker_times = ShenandoahHeap::heap()->phase_timings()->worker_times();
-  // Iterating over the CLDG and the Threads are done early to allow us to
-  // first process the strong CLDs and nmethods and then, after a barrier,
-  // let the thread process the weak CLDs and nmethods.
-  {
-    ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::CLDGRoots, worker_id);
-    _cld_iterator.root_cld_do(strong_clds, weak_clds);
+ShenandoahStringDedupRoots::ShenandoahStringDedupRoots() {
+  if (ShenandoahStringDedup::is_enabled()) {
+    StringDedup::gc_prologue(false);
   }
+}
 
-  {
-    ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::ThreadRoots, worker_id);
-    bool is_par = n_workers() > 1;
-    ResourceMark rm;
-    ShenandoahParallelOopsDoThreadClosure cl(strong_roots, strong_code, thread_cl);
-    Threads::possibly_parallel_threads_do(is_par, &cl);
+ShenandoahStringDedupRoots::~ShenandoahStringDedupRoots() {
+  if (ShenandoahStringDedup::is_enabled()) {
+    StringDedup::gc_epilogue();
   }
 }
 
-void ShenandoahRootProcessor::process_vm_roots(OopClosure* strong_roots,
-                                               OopClosure* weak_roots,
-                                               OopClosure* jni_weak_roots,
-                                               uint worker_id)
-{
-  ShenandoahWorkerTimings* worker_times = ShenandoahHeap::heap()->phase_timings()->worker_times();
-  if (_process_strong_tasks->try_claim_task(SHENANDOAH_RP_PS_Universe_oops_do)) {
-    ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::UniverseRoots, worker_id);
-    Universe::oops_do(strong_roots);
+void ShenandoahStringDedupRoots::oops_do(BoolObjectClosure* is_alive, OopClosure* keep_alive, uint worker_id) {
+  if (ShenandoahStringDedup::is_enabled()) {
+    ShenandoahStringDedup::parallel_oops_do(is_alive, keep_alive, worker_id);
   }
+}
 
-  if (_process_strong_tasks->try_claim_task(SHENANDOAH_RP_PS_JNIHandles_oops_do)) {
-    ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::JNIRoots, worker_id);
-    JNIHandles::oops_do(strong_roots);
-  }
-  if (_process_strong_tasks->try_claim_task(SHENANDOAH_RP_PS_Management_oops_do)) {
-    ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::ManagementRoots, worker_id);
-    Management::oops_do(strong_roots);
-  }
-  if (_process_strong_tasks->try_claim_task(SHENANDOAH_RP_PS_jvmti_oops_do)) {
-    ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::JVMTIRoots, worker_id);
-    JvmtiExport::oops_do(strong_roots);
-  }
-  if (_process_strong_tasks->try_claim_task(SHENANDOAH_RP_PS_SystemDictionary_oops_do)) {
-    ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::SystemDictionaryRoots, worker_id);
-    SystemDictionary::oops_do(strong_roots);
-  }
-  if (jni_weak_roots != NULL) {
-    AlwaysTrueClosure always_true;
-    _weak_processor_task.work<AlwaysTrueClosure, OopClosure>(worker_id, &always_true, jni_weak_roots);
-    _processed_weak_roots = true;
+ShenandoahConcurrentStringDedupRoots::ShenandoahConcurrentStringDedupRoots() {
+  if (ShenandoahStringDedup::is_enabled()) {
+    StringDedupTable_lock->lock_without_safepoint_check();
+    StringDedupQueue_lock->lock_without_safepoint_check();
+    StringDedup::gc_prologue(true);
   }
+}
 
-  if (ShenandoahStringDedup::is_enabled() && weak_roots != NULL) {
-    ShenandoahStringDedup::parallel_oops_do(weak_roots, worker_id);
+ShenandoahConcurrentStringDedupRoots::~ShenandoahConcurrentStringDedupRoots() {
+  if (ShenandoahStringDedup::is_enabled()) {
+    StringDedup::gc_epilogue();
+    StringDedupQueue_lock->unlock();
+    StringDedupTable_lock->unlock();
   }
+}
+
+void ShenandoahConcurrentStringDedupRoots::oops_do(BoolObjectClosure* is_alive, OopClosure* keep_alive, uint worker_id) {
+  if (ShenandoahStringDedup::is_enabled()) {
+    assert_locked_or_safepoint_weak(StringDedupQueue_lock);
+    assert_locked_or_safepoint_weak(StringDedupTable_lock);
 
-  {
-    ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::ObjectSynchronizerRoots, worker_id);
-    if (_process_strong_tasks->try_claim_task(SHENANDOAH_RP_PS_ObjectSynchronizer_oops_do)) {
-      ObjectSynchronizer::oops_do(strong_roots);
-    }
+    StringDedupUnlinkOrOopsDoClosure sd_cl(is_alive, keep_alive);
+    StringDedupQueue::unlink_or_oops_do(&sd_cl);
+    StringDedupTable::unlink_or_oops_do(&sd_cl, worker_id);
   }
 }
 
-uint ShenandoahRootProcessor::n_workers() const {
-  return _srs.n_threads();
+ShenandoahRootProcessor::ShenandoahRootProcessor(ShenandoahPhaseTimings::Phase phase) :
+  _heap(ShenandoahHeap::heap()),
+  _phase(phase) {
+  assert(SafepointSynchronize::is_at_safepoint(), "Must at safepoint");
+  _heap->phase_timings()->record_workers_start(_phase);
 }
 
-ShenandoahRootEvacuator::ShenandoahRootEvacuator(ShenandoahHeap* heap, uint n_workers, ShenandoahPhaseTimings::Phase phase) :
-  _evacuation_tasks(new SubTasksDone(SHENANDOAH_EVAC_NumElements)),
-  _srs(n_workers),
-  _phase(phase),
-  _coderoots_cset_iterator(ShenandoahCodeRoots::cset_iterator())
-{
-  heap->phase_timings()->record_workers_start(_phase);
+ShenandoahRootProcessor::~ShenandoahRootProcessor() {
+  assert(SafepointSynchronize::is_at_safepoint(), "Must at safepoint");
+  _heap->phase_timings()->record_workers_end(_phase);
 }
 
-ShenandoahRootEvacuator::~ShenandoahRootEvacuator() {
-  delete _evacuation_tasks;
-  ShenandoahHeap::heap()->phase_timings()->record_workers_end(_phase);
+ShenandoahRootEvacuator::ShenandoahRootEvacuator(uint n_workers,
+                                                 ShenandoahPhaseTimings::Phase phase,
+                                                 bool include_concurrent_roots,
+                                                 bool include_concurrent_code_roots) :
+  ShenandoahRootProcessor(phase),
+  _thread_roots(n_workers > 1),
+  _include_concurrent_roots(include_concurrent_roots),
+  _include_concurrent_code_roots(include_concurrent_code_roots) {
 }
 
-void ShenandoahRootEvacuator::process_evacuate_roots(OopClosure* oops,
-                                                     CodeBlobClosure* blobs,
-                                                     uint worker_id) {
-
-  ShenandoahWorkerTimings* worker_times = ShenandoahHeap::heap()->phase_timings()->worker_times();
-  {
-    bool is_par = n_workers() > 1;
-    ResourceMark rm;
-    ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::ThreadRoots, worker_id);
-
-    Threads::possibly_parallel_oops_do(is_par, oops, NULL);
-  }
-
-  if (blobs != NULL) {
-    ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::CodeCacheRoots, worker_id);
-    _coderoots_cset_iterator.possibly_parallel_blobs_do(blobs);
+void ShenandoahRootEvacuator::roots_do(uint worker_id, OopClosure* oops) {
+  MarkingCodeBlobClosure blobsCl(oops, CodeBlobToOopClosure::FixRelocations);
+  ShenandoahCodeBlobAndDisarmClosure blobs_and_disarm_Cl(oops);
+  CodeBlobToOopClosure* codes_cl = ShenandoahConcurrentRoots::can_do_concurrent_class_unloading() ?
+                                   static_cast<CodeBlobToOopClosure*>(&blobs_and_disarm_Cl) :
+                                   static_cast<CodeBlobToOopClosure*>(&blobsCl);
+  AlwaysTrueClosure always_true;
+
+  _serial_roots.oops_do(oops, worker_id);
+  _serial_weak_roots.weak_oops_do(oops, worker_id);
+  if (_include_concurrent_roots) {
+    CLDToOopClosure clds(oops, ClassLoaderData::_claim_strong);
+    _vm_roots.oops_do<OopClosure>(oops, worker_id);
+    _cld_roots.cld_do(&clds, worker_id);
+    _weak_roots.oops_do<OopClosure>(oops, worker_id);
+    _dedup_roots.oops_do(&always_true, oops, worker_id);
   }
 
-  if (_evacuation_tasks->try_claim_task(SHENANDOAH_EVAC_jvmti_oops_do)) {
-    ShenandoahForwardedIsAliveClosure is_alive;
-    ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::JVMTIRoots, worker_id);
-    JvmtiExport::weak_oops_do(&is_alive, oops);
+  if (_include_concurrent_code_roots) {
+    _code_roots.code_blobs_do(codes_cl, worker_id);
+    _thread_roots.oops_do(oops, NULL, worker_id);
+  } else {
+    _thread_roots.oops_do(oops, codes_cl, worker_id);
   }
 }
 
-uint ShenandoahRootEvacuator::n_workers() const {
-  return _srs.n_threads();
+ShenandoahRootUpdater::ShenandoahRootUpdater(uint n_workers, ShenandoahPhaseTimings::Phase phase) :
+  ShenandoahRootProcessor(phase),
+  _thread_roots(n_workers > 1) {
 }
 
-// Implemenation of ParallelCLDRootIterator
-ParallelCLDRootIterator::ParallelCLDRootIterator() {
-  assert(SafepointSynchronize::is_at_safepoint(), "Must at safepoint");
-  ClassLoaderDataGraph::clear_claimed_marks();
+ShenandoahRootAdjuster::ShenandoahRootAdjuster(uint n_workers, ShenandoahPhaseTimings::Phase phase) :
+  ShenandoahRootProcessor(phase),
+  _thread_roots(n_workers > 1) {
+  assert(ShenandoahHeap::heap()->is_full_gc_in_progress(), "Full GC only");
 }
 
-void ParallelCLDRootIterator::root_cld_do(CLDClosure* strong, CLDClosure* weak) {
-    ClassLoaderDataGraph::roots_cld_do(strong, weak);
+void ShenandoahRootAdjuster::roots_do(uint worker_id, OopClosure* oops) {
+  CodeBlobToOopClosure code_blob_cl(oops, CodeBlobToOopClosure::FixRelocations);
+  ShenandoahCodeBlobAndDisarmClosure blobs_and_disarm_Cl(oops);
+  CodeBlobToOopClosure* adjust_code_closure = ShenandoahConcurrentRoots::can_do_concurrent_class_unloading() ?
+                                              static_cast<CodeBlobToOopClosure*>(&blobs_and_disarm_Cl) :
+                                              static_cast<CodeBlobToOopClosure*>(&code_blob_cl);
+  CLDToOopClosure adjust_cld_closure(oops, ClassLoaderData::_claim_strong);
+  AlwaysTrueClosure always_true;
+
+  _serial_roots.oops_do(oops, worker_id);
+  _vm_roots.oops_do(oops, worker_id);
+
+  _thread_roots.oops_do(oops, NULL, worker_id);
+  _cld_roots.cld_do(&adjust_cld_closure, worker_id);
+  _code_roots.code_blobs_do(adjust_code_closure, worker_id);
+
+  _serial_weak_roots.weak_oops_do(oops, worker_id);
+  _weak_roots.oops_do<OopClosure>(oops, worker_id);
+  _dedup_roots.oops_do(&always_true, oops, worker_id);
 }
+
+ ShenandoahHeapIterationRootScanner::ShenandoahHeapIterationRootScanner() :
+   ShenandoahRootProcessor(ShenandoahPhaseTimings::_num_phases),
+   _thread_roots(false /*is par*/) {
+ }
+
+ void ShenandoahHeapIterationRootScanner::roots_do(OopClosure* oops) {
+   assert(Thread::current()->is_VM_thread(), "Only by VM thread");
+   // Must use _claim_none to avoid interfering with concurrent CLDG iteration
+   CLDToOopClosure clds(oops, ClassLoaderData::_claim_none);
+   MarkingCodeBlobClosure code(oops, !CodeBlobToOopClosure::FixRelocations);
+   ShenandoahParallelOopsDoThreadClosure tc_cl(oops, &code, NULL);
+   AlwaysTrueClosure always_true;
+   ResourceMark rm;
+
+   _serial_roots.oops_do(oops, 0);
+   _vm_roots.oops_do(oops, 0);
+   _cld_roots.cld_do(&clds, 0);
+   _thread_roots.threads_do(&tc_cl, 0);
+   _code_roots.code_blobs_do(&code, 0);
+
+   _serial_weak_roots.weak_oops_do(oops, 0);
+   _weak_roots.oops_do<OopClosure>(oops, 0);
+   _dedup_roots.oops_do(&always_true, oops, 0);
+ }
+
+ void ShenandoahHeapIterationRootScanner::strong_roots_do(OopClosure* oops) {
+   assert(Thread::current()->is_VM_thread(), "Only by VM thread");
+   // Must use _claim_none to avoid interfering with concurrent CLDG iteration
+   CLDToOopClosure clds(oops, ClassLoaderData::_claim_none);
+   MarkingCodeBlobClosure code(oops, !CodeBlobToOopClosure::FixRelocations);
+   ShenandoahParallelOopsDoThreadClosure tc_cl(oops, &code, NULL);
+   ResourceMark rm;
+
+   _serial_roots.oops_do(oops, 0);
+   _vm_roots.oops_do(oops, 0);
+   _cld_roots.always_strong_cld_do(&clds, 0);
+   _thread_roots.threads_do(&tc_cl, 0);
+ }

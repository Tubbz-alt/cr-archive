<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/classfile/javaClasses.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_CLASSFILE_JAVACLASSES_HPP
  26 #define SHARE_CLASSFILE_JAVACLASSES_HPP
  27 
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;jvmtifiles/jvmti.h&quot;
  30 #include &quot;oops/oop.hpp&quot;
  31 #include &quot;runtime/os.hpp&quot;
  32 
  33 class RecordComponent;
  34 
  35 // Interface for manipulating the basic Java classes.
  36 //
  37 // All dependencies on layout of actual Java classes should be kept here.
  38 // If the layout of any of the classes above changes the offsets must be adjusted.
  39 //
  40 // For most classes we hardwire the offsets for performance reasons. In certain
  41 // cases (e.g. java.security.AccessControlContext) we compute the offsets at
  42 // startup since the layout here differs between JDK1.2 and JDK1.3.
  43 //
  44 // Note that fields (static and non-static) are arranged with oops before non-oops
  45 // on a per class basis. The offsets below have to reflect this ordering.
  46 //
  47 // When editing the layouts please update the check_offset verification code
  48 // correspondingly. The names in the enums must be identical to the actual field
  49 // names in order for the verification code to work.
  50 
  51 #define BASIC_JAVA_CLASSES_DO_PART1(f) \
  52   f(java_lang_Class) \
  53   f(java_lang_String) \
  54   //end
  55 
  56 #define BASIC_JAVA_CLASSES_DO_PART2(f) \
  57   f(java_lang_System) \
  58   f(java_lang_ClassLoader) \
  59   f(java_lang_Throwable) \
  60   f(java_lang_Thread) \
  61   f(java_lang_ThreadGroup) \
  62   f(java_lang_AssertionStatusDirectives) \
  63   f(java_lang_ref_SoftReference) \
  64   f(java_lang_invoke_MethodHandle) \
  65   f(java_lang_invoke_DirectMethodHandle) \
  66   f(java_lang_invoke_MemberName) \
  67   f(java_lang_invoke_ResolvedMethodName) \
  68   f(java_lang_invoke_LambdaForm) \
  69   f(java_lang_invoke_MethodType) \
  70   f(java_lang_invoke_CallSite) \
  71   f(java_lang_invoke_ConstantCallSite) \
  72   f(java_lang_invoke_MethodHandleNatives_CallSiteContext) \
  73   f(java_security_AccessControlContext) \
  74   f(java_lang_reflect_AccessibleObject) \
  75   f(java_lang_reflect_Method) \
  76   f(java_lang_reflect_Constructor) \
  77   f(java_lang_reflect_Field) \
  78   f(java_lang_reflect_RecordComponent) \
  79   f(java_nio_Buffer) \
  80   f(reflect_ConstantPool) \
  81   f(reflect_UnsafeStaticFieldAccessorImpl) \
  82   f(java_lang_reflect_Parameter) \
  83   f(java_lang_Module) \
  84   f(java_lang_StackTraceElement) \
  85   f(java_lang_StackFrameInfo) \
  86   f(java_lang_LiveStackFrameInfo) \
  87   f(java_util_concurrent_locks_AbstractOwnableSynchronizer) \
  88   f(jdk_internal_misc_UnsafeConstants) \
  89   //end
  90 
  91 #define BASIC_JAVA_CLASSES_DO(f) \
  92         BASIC_JAVA_CLASSES_DO_PART1(f) \
  93         BASIC_JAVA_CLASSES_DO_PART2(f)
  94 
  95 // Interface to java.lang.Object objects
  96 
  97 class java_lang_Object : AllStatic {
  98  public:
  99   static void register_natives(TRAPS);
 100 };
 101 
 102 // Interface to java.lang.String objects
 103 
 104 class java_lang_String : AllStatic {
 105  private:
 106   static int value_offset;
 107   static int hash_offset;
 108   static int hashIsZero_offset;
 109   static int coder_offset;
 110 
 111   static bool initialized;
 112 
 113   static Handle basic_create(int length, bool byte_arr, TRAPS);
 114 
 115   static inline void set_coder(oop string, jbyte coder);
 116 
 117  public:
 118 
 119   // Coders
 120   enum Coder {
 121     CODER_LATIN1 =  0,
 122     CODER_UTF16  =  1
 123   };
 124 
 125   static void compute_offsets();
 126   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 127 
 128   // Instance creation
 129   static Handle create_from_unicode(const jchar* unicode, int len, TRAPS);
 130   static oop    create_oop_from_unicode(const jchar* unicode, int len, TRAPS);
 131   static Handle create_from_str(const char* utf8_str, TRAPS);
 132   static oop    create_oop_from_str(const char* utf8_str, TRAPS);
 133   static Handle create_from_symbol(Symbol* symbol, TRAPS);
 134   static Handle create_from_platform_dependent_str(const char* str, TRAPS);
 135   static Handle char_converter(Handle java_string, jchar from_char, jchar to_char, TRAPS);
 136 
 137   static void set_compact_strings(bool value);
 138 
 139   static int value_offset_in_bytes()  {
 140     assert(initialized &amp;&amp; (value_offset &gt; 0), &quot;Must be initialized&quot;);
 141     return value_offset;
 142   }
 143   static int hash_offset_in_bytes()   {
 144     assert(initialized &amp;&amp; (hash_offset &gt; 0), &quot;Must be initialized&quot;);
 145     return hash_offset;
 146   }
 147   static int hashIsZero_offset_in_bytes()   {
 148     assert(initialized &amp;&amp; (hashIsZero_offset &gt; 0), &quot;Must be initialized&quot;);
 149     return hashIsZero_offset;
 150   }
 151   static int coder_offset_in_bytes()   {
 152     assert(initialized &amp;&amp; (coder_offset &gt; 0), &quot;Must be initialized&quot;);
 153     return coder_offset;
 154   }
 155 
 156   static inline void set_value_raw(oop string, typeArrayOop buffer);
 157   static inline void set_value(oop string, typeArrayOop buffer);
 158 
 159   // Accessors
 160   static inline typeArrayOop value(oop java_string);
 161   static inline typeArrayOop value_no_keepalive(oop java_string);
 162   static inline bool hash_is_set(oop string);
 163   static inline bool is_latin1(oop java_string);
 164   static inline int length(oop java_string);
 165   static inline int length(oop java_string, typeArrayOop string_value);
 166   static int utf8_length(oop java_string);
 167   static int utf8_length(oop java_string, typeArrayOop string_value);
 168 
 169   // String converters
 170   static char*  as_utf8_string(oop java_string);
 171   static char*  as_utf8_string(oop java_string, char* buf, int buflen);
 172   static char*  as_utf8_string(oop java_string, int start, int len);
 173   static char*  as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen);
 174   static char*  as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, int buflen);
 175   static char*  as_platform_dependent_str(Handle java_string, TRAPS);
 176   static jchar* as_unicode_string(oop java_string, int&amp; length, TRAPS);
 177   // produce an ascii string with all other values quoted using \u####
 178   static char*  as_quoted_ascii(oop java_string);
 179 
 180   // Compute the hash value for a java.lang.String object which would
 181   // contain the characters passed in.
 182   //
 183   // As the hash value used by the String object itself, in
 184   // String.hashCode().  This value is normally calculated in Java code
 185   // in the String.hashCode method(), but is precomputed for String
 186   // objects in the shared archive file.
 187   // hash P(31) from Kernighan &amp; Ritchie
 188   //
 189   // For this reason, THIS ALGORITHM MUST MATCH String.hashCode().
 190   static unsigned int hash_code(const jchar* s, int len) {
 191     unsigned int h = 0;
 192     while (len-- &gt; 0) {
 193       h = 31*h + (unsigned int) *s;
 194       s++;
 195     }
 196     return h;
 197   }
 198 
 199   static unsigned int hash_code(const jbyte* s, int len) {
 200     unsigned int h = 0;
 201     while (len-- &gt; 0) {
 202       h = 31*h + (((unsigned int) *s) &amp; 0xFF);
 203       s++;
 204     }
 205     return h;
 206   }
 207 
 208   static unsigned int hash_code(oop java_string);
 209 
 210   static bool equals(oop java_string, const jchar* chars, int len);
 211   static bool equals(oop str1, oop str2);
 212   static inline bool value_equals(typeArrayOop str_value1, typeArrayOop str_value2);
 213 
 214   // Conversion between &#39;.&#39; and &#39;/&#39; formats
 215   static Handle externalize_classname(Handle java_string, TRAPS) {
 216     return char_converter(java_string, JVM_SIGNATURE_SLASH, JVM_SIGNATURE_DOT, THREAD);
 217   }
 218 
 219   // Conversion
 220   static Symbol* as_symbol(oop java_string);
 221   static Symbol* as_symbol_or_null(oop java_string);
 222 
 223   // Testers
 224   static bool is_instance(oop obj);
 225   static inline bool is_instance_inlined(oop obj);
 226 
 227   // Debugging
 228   static void print(oop java_string, outputStream* st);
 229   friend class JavaClasses;
 230   friend class StringTable;
 231 };
 232 
 233 
 234 // Interface to java.lang.Class objects
 235 
 236 #define CLASS_INJECTED_FIELDS(macro)                                       \
 237   macro(java_lang_Class, klass,                  intptr_signature,  false) \
 238   macro(java_lang_Class, array_klass,            intptr_signature,  false) \
 239   macro(java_lang_Class, oop_size,               int_signature,     false) \
 240   macro(java_lang_Class, static_oop_field_count, int_signature,     false) \
 241   macro(java_lang_Class, protection_domain,      object_signature,  false) \
 242   macro(java_lang_Class, signers,                object_signature,  false) \
 243   macro(java_lang_Class, source_file,            object_signature,  false) \
 244 
 245 class java_lang_Class : AllStatic {
 246   friend class VMStructs;
 247   friend class JVMCIVMStructs;
 248 
 249  private:
 250   // The fake offsets are added by the class loader when java.lang.Class is loaded
 251 
 252   static int _klass_offset;
 253   static int _array_klass_offset;
 254 
 255   static int _oop_size_offset;
 256   static int _static_oop_field_count_offset;
 257 
 258   static int _protection_domain_offset;
 259   static int _init_lock_offset;
 260   static int _signers_offset;
 261   static int _class_loader_offset;
 262   static int _module_offset;
 263   static int _component_mirror_offset;
 264   static int _name_offset;
 265   static int _source_file_offset;
 266 
 267   static bool offsets_computed;
 268   static int classRedefinedCount_offset;
 269 
 270   static GrowableArray&lt;Klass*&gt;* _fixup_mirror_list;
 271   static GrowableArray&lt;Klass*&gt;* _fixup_module_field_list;
 272 
 273   static void set_init_lock(oop java_class, oop init_lock);
 274   static void set_protection_domain(oop java_class, oop protection_domain);
 275   static void set_class_loader(oop java_class, oop class_loader);
 276   static void set_component_mirror(oop java_class, oop comp_mirror);
 277   static void initialize_mirror_fields(Klass* k, Handle mirror, Handle protection_domain, TRAPS);
 278   static void set_mirror_module_field(Klass* K, Handle mirror, Handle module, TRAPS);
 279  public:
 280   static void allocate_fixup_lists();
 281   static void compute_offsets();
 282 
 283   // Instance creation
 284   static void create_mirror(Klass* k, Handle class_loader, Handle module,
 285                             Handle protection_domain, TRAPS);
 286   static void fixup_mirror(Klass* k, TRAPS);
 287   static oop  create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS);
 288   static void update_archived_primitive_mirror_native_pointers(oop archived_mirror) NOT_CDS_JAVA_HEAP_RETURN;
 289   static void update_archived_mirror_native_pointers(oop archived_mirror) NOT_CDS_JAVA_HEAP_RETURN;
 290 
 291   // Archiving
 292   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 293   static void archive_basic_type_mirrors(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;
 294   static oop  archive_mirror(Klass* k, TRAPS) NOT_CDS_JAVA_HEAP_RETURN_(NULL);
 295   static oop  process_archived_mirror(Klass* k, oop mirror, oop archived_mirror, Thread *THREAD)
 296                                       NOT_CDS_JAVA_HEAP_RETURN_(NULL);
 297   static bool restore_archived_mirror(Klass *k, Handle class_loader, Handle module,
 298                                       Handle protection_domain,
 299                                       TRAPS) NOT_CDS_JAVA_HEAP_RETURN_(false);
 300 
 301   static void fixup_module_field(Klass* k, Handle module);
 302 
 303   // Conversion
 304   static Klass* as_Klass(oop java_class);
 305   static Klass* as_Klass_raw(oop java_class);
 306   static void set_klass(oop java_class, Klass* klass);
 307   static BasicType as_BasicType(oop java_class, Klass** reference_klass = NULL);
 308   static Symbol* as_signature(oop java_class, bool intern_if_not_found);
 309   static void print_signature(oop java_class, outputStream *st);
 310   static const char* as_external_name(oop java_class);
 311   // Testing
 312   static bool is_instance(oop obj);
 313 
 314   static bool is_primitive(oop java_class);
 315   static BasicType primitive_type(oop java_class);
 316   static oop primitive_mirror(BasicType t);
 317   // JVM_NewArray support
 318   static Klass* array_klass_acquire(oop java_class);
 319   static void release_set_array_klass(oop java_class, Klass* klass);
 320   // compiler support for class operations
 321   static int klass_offset_in_bytes()                { return _klass_offset; }
 322   static int array_klass_offset_in_bytes()          { return _array_klass_offset; }
 323   // Support for classRedefinedCount field
 324   static int classRedefinedCount(oop the_class_mirror);
 325   static void set_classRedefinedCount(oop the_class_mirror, int value);
 326 
 327   // Support for embedded per-class oops
 328   static oop  protection_domain(oop java_class);
 329   static oop  init_lock(oop java_class);
 330 #if INCLUDE_TSAN
 331   static oop* init_lock_addr(oop java_class);
 332   static const int* init_lock_offset_addr() { return &amp;_init_lock_offset; }
 333 #endif  // INCLUDE_TSAN
 334   static oop  component_mirror(oop java_class);
 335   static objArrayOop  signers(oop java_class);
 336   static void set_signers(oop java_class, objArrayOop signers);
 337 
 338   static oop class_loader(oop java_class);
 339   static void set_module(oop java_class, oop module);
 340   static oop module(oop java_class);
 341 
 342   static oop name(Handle java_class, TRAPS);
 343 
 344   static oop source_file(oop java_class);
 345   static void set_source_file(oop java_class, oop source_file);
 346 
 347   static int oop_size(oop java_class);
 348   static int oop_size_raw(oop java_class);
 349   static void set_oop_size(HeapWord* java_class, int size);
 350   static int static_oop_field_count(oop java_class);
 351   static int static_oop_field_count_raw(oop java_class);
 352   static void set_static_oop_field_count(oop java_class, int size);
 353 
 354   static GrowableArray&lt;Klass*&gt;* fixup_mirror_list() {
 355     return _fixup_mirror_list;
 356   }
 357   static void set_fixup_mirror_list(GrowableArray&lt;Klass*&gt;* v) {
 358     _fixup_mirror_list = v;
 359   }
 360 
 361   static GrowableArray&lt;Klass*&gt;* fixup_module_field_list() {
 362     return _fixup_module_field_list;
 363   }
 364   static void set_fixup_module_field_list(GrowableArray&lt;Klass*&gt;* v) {
 365     _fixup_module_field_list = v;
 366   }
 367 
 368   // Debugging
 369   friend class JavaClasses;
 370   friend class InstanceKlass;   // verification code accesses offsets
 371   friend class ClassFileParser; // access to number_of_fake_fields
 372 };
 373 
 374 // Interface to java.lang.Thread objects
 375 
 376 class java_lang_Thread : AllStatic {
 377  private:
 378   // Note that for this class the layout changed between JDK1.2 and JDK1.3,
 379   // so we compute the offsets at startup rather than hard-wiring them.
 380   static int _name_offset;
 381   static int _group_offset;
 382   static int _contextClassLoader_offset;
 383   static int _inheritedAccessControlContext_offset;
 384   static int _priority_offset;
 385   static int _eetop_offset;
 386   static int _interrupted_offset;
 387   static int _daemon_offset;
 388   static int _stillborn_offset;
 389   static int _stackSize_offset;
 390   static int _tid_offset;
 391   static int _thread_status_offset;
 392   static int _park_blocker_offset;
 393 
 394   static void compute_offsets();
 395 
 396  public:
 397   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 398 
 399   // Instance creation
 400   static oop create();
 401   // Returns the JavaThread associated with the thread obj
 402   static JavaThread* thread(oop java_thread);
 403   // Set JavaThread for instance
 404   static void set_thread(oop java_thread, JavaThread* thread);
 405   // Interrupted status
 406   static bool interrupted(oop java_thread);
 407   static void set_interrupted(oop java_thread, bool val);
 408   // Name
 409   static oop name(oop java_thread);
 410   static void set_name(oop java_thread, oop name);
 411   // Priority
 412   static ThreadPriority priority(oop java_thread);
 413   static void set_priority(oop java_thread, ThreadPriority priority);
 414   // Thread group
 415   static oop  threadGroup(oop java_thread);
 416   // Stillborn
 417   static bool is_stillborn(oop java_thread);
 418   static void set_stillborn(oop java_thread);
 419   // Alive (NOTE: this is not really a field, but provides the correct
 420   // definition without doing a Java call)
 421   static bool is_alive(oop java_thread);
 422   // Daemon
 423   static bool is_daemon(oop java_thread);
 424   static void set_daemon(oop java_thread);
 425   // Context ClassLoader
 426   static oop context_class_loader(oop java_thread);
 427   // Control context
 428   static oop inherited_access_control_context(oop java_thread);
 429   // Stack size hint
 430   static jlong stackSize(oop java_thread);
 431   // Thread ID
 432   static jlong thread_id(oop java_thread);
 433 
 434   // Blocker object responsible for thread parking
 435   static oop park_blocker(oop java_thread);
 436 
 437   // Java Thread Status for JVMTI and M&amp;M use.
 438   // This thread status info is saved in threadStatus field of
 439   // java.lang.Thread java class.
 440   enum ThreadStatus {
 441     NEW                      = 0,
 442     RUNNABLE                 = JVMTI_THREAD_STATE_ALIVE +          // runnable / running
 443                                JVMTI_THREAD_STATE_RUNNABLE,
 444     SLEEPING                 = JVMTI_THREAD_STATE_ALIVE +          // Thread.sleep()
 445                                JVMTI_THREAD_STATE_WAITING +
 446                                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
 447                                JVMTI_THREAD_STATE_SLEEPING,
 448     IN_OBJECT_WAIT           = JVMTI_THREAD_STATE_ALIVE +          // Object.wait()
 449                                JVMTI_THREAD_STATE_WAITING +
 450                                JVMTI_THREAD_STATE_WAITING_INDEFINITELY +
 451                                JVMTI_THREAD_STATE_IN_OBJECT_WAIT,
 452     IN_OBJECT_WAIT_TIMED     = JVMTI_THREAD_STATE_ALIVE +          // Object.wait(long)
 453                                JVMTI_THREAD_STATE_WAITING +
 454                                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
 455                                JVMTI_THREAD_STATE_IN_OBJECT_WAIT,
 456     PARKED                   = JVMTI_THREAD_STATE_ALIVE +          // LockSupport.park()
 457                                JVMTI_THREAD_STATE_WAITING +
 458                                JVMTI_THREAD_STATE_WAITING_INDEFINITELY +
 459                                JVMTI_THREAD_STATE_PARKED,
 460     PARKED_TIMED             = JVMTI_THREAD_STATE_ALIVE +          // LockSupport.park(long)
 461                                JVMTI_THREAD_STATE_WAITING +
 462                                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
 463                                JVMTI_THREAD_STATE_PARKED,
 464     BLOCKED_ON_MONITOR_ENTER = JVMTI_THREAD_STATE_ALIVE +          // (re-)entering a synchronization block
 465                                JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER,
 466     TERMINATED               = JVMTI_THREAD_STATE_TERMINATED
 467   };
 468   // Write thread status info to threadStatus field of java.lang.Thread.
 469   static void set_thread_status(oop java_thread_oop, ThreadStatus status);
 470   // Read thread status info from threadStatus field of java.lang.Thread.
 471   static ThreadStatus get_thread_status(oop java_thread_oop);
 472 
 473   static const char*  thread_status_name(oop java_thread_oop);
 474 
 475   // Debugging
 476   friend class JavaClasses;
 477 };
 478 
 479 // Interface to java.lang.ThreadGroup objects
 480 
 481 class java_lang_ThreadGroup : AllStatic {
 482  private:
 483   static int _parent_offset;
 484   static int _name_offset;
 485   static int _threads_offset;
 486   static int _groups_offset;
 487   static int _maxPriority_offset;
 488   static int _destroyed_offset;
 489   static int _daemon_offset;
 490   static int _nthreads_offset;
 491   static int _ngroups_offset;
 492 
 493   static void compute_offsets();
 494 
 495  public:
 496   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 497 
 498   // parent ThreadGroup
 499   static oop  parent(oop java_thread_group);
 500   // name
 501   static const char* name(oop java_thread_group);
 502   // (&quot;name as oop&quot; accessor is not necessary)
 503   // Number of threads in group
 504   static int nthreads(oop java_thread_group);
 505   // threads
 506   static objArrayOop threads(oop java_thread_group);
 507   // Number of threads in group
 508   static int ngroups(oop java_thread_group);
 509   // groups
 510   static objArrayOop groups(oop java_thread_group);
 511   // maxPriority in group
 512   static ThreadPriority maxPriority(oop java_thread_group);
 513   // Destroyed
 514   static bool is_destroyed(oop java_thread_group);
 515   // Daemon
 516   static bool is_daemon(oop java_thread_group);
 517   // Debugging
 518   friend class JavaClasses;
 519 };
 520 
 521 
 522 
 523 // Interface to java.lang.Throwable objects
 524 
 525 class java_lang_Throwable: AllStatic {
 526   friend class BacktraceBuilder;
 527   friend class BacktraceIterator;
 528 
 529  private:
 530   // Offsets
 531   enum {
 532     hc_backtrace_offset     =  0,
 533     hc_detailMessage_offset =  1,
 534     hc_cause_offset         =  2,  // New since 1.4
 535     hc_stackTrace_offset    =  3   // New since 1.4
 536   };
 537   // Trace constants
 538   enum {
 539     trace_methods_offset = 0,
 540     trace_bcis_offset    = 1,
 541     trace_mirrors_offset = 2,
 542     trace_names_offset   = 3,
 543     trace_next_offset    = 4,
 544     trace_hidden_offset  = 5,
 545     trace_size           = 6,
 546     trace_chunk_size     = 32
 547   };
 548 
 549   static int backtrace_offset;
 550   static int detailMessage_offset;
 551   static int stackTrace_offset;
 552   static int depth_offset;
 553   static int static_unassigned_stacktrace_offset;
 554 
 555   // StackTrace (programmatic access, new since 1.4)
 556   static void clear_stacktrace(oop throwable);
 557   // Stacktrace (post JDK 1.7.0 to allow immutability protocol to be followed)
 558   static void set_stacktrace(oop throwable, oop st_element_array);
 559   static oop unassigned_stacktrace();
 560 
 561  public:
 562   // Backtrace
 563   static oop backtrace(oop throwable);
 564   static void set_backtrace(oop throwable, oop value);
 565   static int depth(oop throwable);
 566   static void set_depth(oop throwable, int value);
 567   // Needed by JVMTI to filter out this internal field.
 568   static int get_backtrace_offset() { return backtrace_offset;}
 569   static int get_detailMessage_offset() { return detailMessage_offset;}
 570   // Message
 571   static oop message(oop throwable);
 572   static void set_message(oop throwable, oop value);
 573   static Symbol* detail_message(oop throwable);
 574   static void print_stack_element(outputStream *st, Method* method, int bci);
 575   static void print_stack_usage(Handle stream);
 576 
 577   static void compute_offsets();
 578   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 579 
 580   // Allocate space for backtrace (created but stack trace not filled in)
 581   static void allocate_backtrace(Handle throwable, TRAPS);
 582   // Fill in current stack trace for throwable with preallocated backtrace (no GC)
 583   static void fill_in_stack_trace_of_preallocated_backtrace(Handle throwable);
 584   // Fill in current stack trace, can cause GC
 585   static void fill_in_stack_trace(Handle throwable, const methodHandle&amp; method, TRAPS);
 586   static void fill_in_stack_trace(Handle throwable, const methodHandle&amp; method = methodHandle());
 587   // Programmatic access to stack trace
 588   static void get_stack_trace_elements(Handle throwable, objArrayHandle stack_trace, TRAPS);
 589   // Printing
 590   static void print(oop throwable, outputStream* st);
 591   static void print_stack_trace(Handle throwable, outputStream* st);
 592   static void java_printStackTrace(Handle throwable, TRAPS);
 593   // Debugging
 594   friend class JavaClasses;
 595   // Gets the method and bci of the top frame (TOS). Returns false if this failed.
 596   static bool get_top_method_and_bci(oop throwable, Method** method, int* bci);
 597 };
 598 
 599 
 600 // Interface to java.lang.reflect.AccessibleObject objects
 601 
 602 class java_lang_reflect_AccessibleObject: AllStatic {
 603  private:
 604   // Note that to reduce dependencies on the JDK we compute these
 605   // offsets at run-time.
 606   static int override_offset;
 607 
 608   static void compute_offsets();
 609 
 610  public:
 611   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 612 
 613   // Accessors
 614   static jboolean override(oop reflect);
 615   static void set_override(oop reflect, jboolean value);
 616 
 617   // Debugging
 618   friend class JavaClasses;
 619 };
 620 
 621 
 622 // Interface to java.lang.reflect.Method objects
 623 
 624 class java_lang_reflect_Method : public java_lang_reflect_AccessibleObject {
 625  private:
 626   // Note that to reduce dependencies on the JDK we compute these
 627   // offsets at run-time.
 628   static int clazz_offset;
 629   static int name_offset;
 630   static int returnType_offset;
 631   static int parameterTypes_offset;
 632   static int exceptionTypes_offset;
 633   static int slot_offset;
 634   static int modifiers_offset;
 635   static int signature_offset;
 636   static int annotations_offset;
 637   static int parameter_annotations_offset;
 638   static int annotation_default_offset;
 639 
 640   static void compute_offsets();
 641  public:
 642   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 643 
 644   // Allocation
 645   static Handle create(TRAPS);
 646 
 647   // Accessors
 648   static oop clazz(oop reflect);
 649   static void set_clazz(oop reflect, oop value);
 650 
 651   static void set_name(oop method, oop value);
 652 
 653   static oop return_type(oop method);
 654   static void set_return_type(oop method, oop value);
 655 
 656   static oop parameter_types(oop method);
 657   static void set_parameter_types(oop method, oop value);
 658 
 659   static int slot(oop reflect);
 660   static void set_slot(oop reflect, int value);
 661 
 662   static void set_exception_types(oop method, oop value);
 663   static void set_modifiers(oop method, int value);
 664   static void set_signature(oop method, oop value);
 665   static void set_annotations(oop method, oop value);
 666   static void set_parameter_annotations(oop method, oop value);
 667   static void set_annotation_default(oop method, oop value);
 668 
 669   // Debugging
 670   friend class JavaClasses;
 671 };
 672 
 673 
 674 // Interface to java.lang.reflect.Constructor objects
 675 
 676 class java_lang_reflect_Constructor : public java_lang_reflect_AccessibleObject {
 677  private:
 678   // Note that to reduce dependencies on the JDK we compute these
 679   // offsets at run-time.
 680   static int clazz_offset;
 681   static int parameterTypes_offset;
 682   static int exceptionTypes_offset;
 683   static int slot_offset;
 684   static int modifiers_offset;
 685   static int signature_offset;
 686   static int annotations_offset;
 687   static int parameter_annotations_offset;
 688 
 689   static void compute_offsets();
 690  public:
 691   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 692 
 693   // Allocation
 694   static Handle create(TRAPS);
 695 
 696   // Accessors
 697   static oop clazz(oop reflect);
 698   static void set_clazz(oop reflect, oop value);
 699 
 700   static oop parameter_types(oop constructor);
 701   static void set_parameter_types(oop constructor, oop value);
 702 
 703   static int slot(oop reflect);
 704   static void set_slot(oop reflect, int value);
 705 
 706   static void set_exception_types(oop constructor, oop value);
 707   static void set_modifiers(oop constructor, int value);
 708   static void set_signature(oop constructor, oop value);
 709   static void set_annotations(oop constructor, oop value);
 710   static void set_parameter_annotations(oop method, oop value);
 711 
 712   // Debugging
 713   friend class JavaClasses;
 714 };
 715 
 716 
 717 // Interface to java.lang.reflect.Field objects
 718 
 719 class java_lang_reflect_Field : public java_lang_reflect_AccessibleObject {
 720  private:
 721   // Note that to reduce dependencies on the JDK we compute these
 722   // offsets at run-time.
 723   static int clazz_offset;
 724   static int name_offset;
 725   static int type_offset;
 726   static int slot_offset;
 727   static int modifiers_offset;
 728   static int signature_offset;
 729   static int annotations_offset;
 730 
 731   static void compute_offsets();
 732 
 733  public:
 734   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 735 
 736   // Allocation
 737   static Handle create(TRAPS);
 738 
 739   // Accessors
 740   static oop clazz(oop reflect);
 741   static void set_clazz(oop reflect, oop value);
 742 
 743   static oop name(oop field);
 744   static void set_name(oop field, oop value);
 745 
 746   static oop type(oop field);
 747   static void set_type(oop field, oop value);
 748 
 749   static int slot(oop reflect);
 750   static void set_slot(oop reflect, int value);
 751 
 752   static int modifiers(oop field);
 753   static void set_modifiers(oop field, int value);
 754 
 755   static void set_signature(oop constructor, oop value);
 756   static void set_annotations(oop constructor, oop value);
 757   static void set_parameter_annotations(oop method, oop value);
 758   static void set_annotation_default(oop method, oop value);
 759 
 760   // Debugging
 761   friend class JavaClasses;
 762 };
 763 
 764 class java_lang_reflect_Parameter {
 765  private:
 766   // Note that to reduce dependencies on the JDK we compute these
 767   // offsets at run-time.
 768   static int name_offset;
 769   static int modifiers_offset;
 770   static int index_offset;
 771   static int executable_offset;
 772 
 773   static void compute_offsets();
 774 
 775  public:
 776   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 777 
 778   // Allocation
 779   static Handle create(TRAPS);
 780 
 781   // Accessors
 782   static oop name(oop field);
 783   static void set_name(oop field, oop value);
 784 
 785   static int index(oop reflect);
 786   static void set_index(oop reflect, int value);
 787 
 788   static int modifiers(oop reflect);
 789   static void set_modifiers(oop reflect, int value);
 790 
 791   static oop executable(oop constructor);
 792   static void set_executable(oop constructor, oop value);
 793 
 794   friend class JavaClasses;
 795 };
 796 
 797 #define MODULE_INJECTED_FIELDS(macro)                            \
 798   macro(java_lang_Module, module_entry, intptr_signature, false)
 799 
 800 class java_lang_Module {
 801   private:
 802     static int loader_offset;
 803     static int name_offset;
 804     static int _module_entry_offset;
 805     static void compute_offsets();
 806 
 807   public:
 808     static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 809 
 810     // Allocation
 811     static Handle create(Handle loader, Handle module_name, TRAPS);
 812 
 813     // Testers
 814     static bool is_instance(oop obj);
 815 
 816     // Accessors
 817     static oop loader(oop module);
 818     static void set_loader(oop module, oop value);
 819 
 820     static oop name(oop module);
 821     static void set_name(oop module, oop value);
 822 
 823     static ModuleEntry* module_entry(oop module);
 824     static void set_module_entry(oop module, ModuleEntry* module_entry);
 825 
 826   friend class JavaClasses;
 827 };
 828 
 829 // Interface to jdk.internal.reflect.ConstantPool objects
 830 class reflect_ConstantPool {
 831  private:
 832   // Note that to reduce dependencies on the JDK we compute these
 833   // offsets at run-time.
 834   static int _oop_offset;
 835 
 836   static void compute_offsets();
 837 
 838  public:
 839   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 840 
 841   // Allocation
 842   static Handle create(TRAPS);
 843 
 844   // Accessors
 845   static void set_cp(oop reflect, ConstantPool* value);
 846   static int oop_offset() {
 847     return _oop_offset;
 848   }
 849 
 850   static ConstantPool* get_cp(oop reflect);
 851 
 852   // Debugging
 853   friend class JavaClasses;
 854 };
 855 
 856 // Interface to jdk.internal.reflect.UnsafeStaticFieldAccessorImpl objects
 857 class reflect_UnsafeStaticFieldAccessorImpl {
 858  private:
 859   static int _base_offset;
 860   static void compute_offsets();
 861 
 862  public:
 863   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 864 
 865   static int base_offset() {
 866     return _base_offset;
 867   }
 868 
 869   // Debugging
 870   friend class JavaClasses;
 871 };
 872 
 873 // Interface to java.lang primitive type boxing objects:
 874 //  - java.lang.Boolean
 875 //  - java.lang.Character
 876 //  - java.lang.Float
 877 //  - java.lang.Double
 878 //  - java.lang.Byte
 879 //  - java.lang.Short
 880 //  - java.lang.Integer
 881 //  - java.lang.Long
 882 
 883 // This could be separated out into 8 individual classes.
 884 
 885 class java_lang_boxing_object: AllStatic {
 886  private:
 887   enum {
 888    hc_value_offset = 0
 889   };
 890   static int value_offset;
 891   static int long_value_offset;
 892 
 893   static oop initialize_and_allocate(BasicType type, TRAPS);
 894  public:
 895   // Allocation. Returns a boxed value, or NULL for invalid type.
 896   static oop create(BasicType type, jvalue* value, TRAPS);
 897   // Accessors. Returns the basic type being boxed, or T_ILLEGAL for invalid oop.
 898   static BasicType get_value(oop box, jvalue* value);
 899   static BasicType set_value(oop box, jvalue* value);
 900   static BasicType basic_type(oop box);
 901   static bool is_instance(oop box)                 { return basic_type(box) != T_ILLEGAL; }
 902   static bool is_instance(oop box, BasicType type) { return basic_type(box) == type; }
 903   static void print(oop box, outputStream* st)     { jvalue value;  print(get_value(box, &amp;value), &amp;value, st); }
 904   static void print(BasicType type, jvalue* value, outputStream* st);
 905 
 906   static int value_offset_in_bytes(BasicType type) {
 907     return ( type == T_LONG || type == T_DOUBLE ) ? long_value_offset :
 908                                                     value_offset;
 909   }
 910 
 911   // Debugging
 912   friend class JavaClasses;
 913 };
 914 
 915 
 916 
 917 // Interface to java.lang.ref.Reference objects
 918 
 919 class java_lang_ref_Reference: AllStatic {
 920  public:
 921   enum {
 922    hc_referent_offset   = 0,
 923    hc_queue_offset      = 1,
 924    hc_next_offset       = 2,
 925    hc_discovered_offset = 3  // Is not last, see SoftRefs.
 926   };
 927 
 928   static int referent_offset;
 929   static int queue_offset;
 930   static int next_offset;
 931   static int discovered_offset;
 932 
 933   // Accessors
 934   static inline oop referent(oop ref);
 935   static inline void set_referent(oop ref, oop value);
 936   static inline void set_referent_raw(oop ref, oop value);
 937   static inline HeapWord* referent_addr_raw(oop ref);
 938   static inline oop next(oop ref);
 939   static inline void set_next(oop ref, oop value);
 940   static inline void set_next_raw(oop ref, oop value);
 941   static inline HeapWord* next_addr_raw(oop ref);
 942   static inline oop discovered(oop ref);
 943   static inline void set_discovered(oop ref, oop value);
 944   static inline void set_discovered_raw(oop ref, oop value);
 945   static inline HeapWord* discovered_addr_raw(oop ref);
 946   static inline oop queue(oop ref);
 947   static inline void set_queue(oop ref, oop value);
 948   static bool is_referent_field(oop obj, ptrdiff_t offset);
 949   static inline bool is_final(oop ref);
 950   static inline bool is_phantom(oop ref);
 951 };
 952 
 953 
 954 // Interface to java.lang.ref.SoftReference objects
 955 
 956 class java_lang_ref_SoftReference: public java_lang_ref_Reference {
 957  public:
 958   static int timestamp_offset;
 959   static int static_clock_offset;
 960 
 961   // Accessors
 962   static jlong timestamp(oop ref);
 963 
 964   // Accessors for statics
 965   static jlong clock();
 966   static void set_clock(jlong value);
 967 
 968   static void compute_offsets();
 969   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 970 };
 971 
 972 // Interface to java.lang.invoke.MethodHandle objects
 973 
 974 class MethodHandleEntry;
 975 
 976 class java_lang_invoke_MethodHandle: AllStatic {
 977   friend class JavaClasses;
 978 
 979  private:
 980   static int _type_offset;               // the MethodType of this MH
 981   static int _form_offset;               // the LambdaForm of this MH
 982 
 983   static void compute_offsets();
 984 
 985  public:
 986   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 987 
 988   // Accessors
 989   static oop            type(oop mh);
 990   static void       set_type(oop mh, oop mtype);
 991 
 992   static oop            form(oop mh);
 993   static void       set_form(oop mh, oop lform);
 994 
 995   // Testers
 996   static bool is_subclass(Klass* klass) {
 997     return klass-&gt;is_subclass_of(SystemDictionary::MethodHandle_klass());
 998   }
 999   static bool is_instance(oop obj);
1000 
1001   // Accessors for code generation:
1002   static int type_offset_in_bytes()             { return _type_offset; }
1003   static int form_offset_in_bytes()             { return _form_offset; }
1004 };
1005 
1006 // Interface to java.lang.invoke.DirectMethodHandle objects
1007 
1008 class java_lang_invoke_DirectMethodHandle: AllStatic {
1009   friend class JavaClasses;
1010 
1011  private:
1012   static int _member_offset;               // the MemberName of this DMH
1013 
1014   static void compute_offsets();
1015 
1016  public:
1017   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1018 
1019   // Accessors
1020   static oop  member(oop mh);
1021 
1022   // Testers
1023   static bool is_subclass(Klass* klass) {
1024     return klass-&gt;is_subclass_of(SystemDictionary::DirectMethodHandle_klass());
1025   }
1026   static bool is_instance(oop obj);
1027 
1028   // Accessors for code generation:
1029   static int member_offset_in_bytes()           { return _member_offset; }
1030 };
1031 
1032 // Interface to java.lang.invoke.LambdaForm objects
1033 // (These are a private interface for managing adapter code generation.)
1034 
1035 class java_lang_invoke_LambdaForm: AllStatic {
1036   friend class JavaClasses;
1037 
1038  private:
1039   static int _vmentry_offset;  // type is MemberName
1040 
1041   static void compute_offsets();
1042 
1043  public:
1044   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1045 
1046   // Accessors
1047   static oop            vmentry(oop lform);
1048   static void       set_vmentry(oop lform, oop invoker);
1049 
1050   // Testers
1051   static bool is_subclass(Klass* klass) {
1052     return SystemDictionary::LambdaForm_klass() != NULL &amp;&amp;
1053       klass-&gt;is_subclass_of(SystemDictionary::LambdaForm_klass());
1054   }
1055   static bool is_instance(oop obj);
1056 
1057   // Accessors for code generation:
1058   static int vmentry_offset_in_bytes()          { return _vmentry_offset; }
1059 };
1060 
1061 
1062 // Interface to java.lang.invoke.MemberName objects
1063 // (These are a private interface for Java code to query the class hierarchy.)
1064 
1065 #define RESOLVEDMETHOD_INJECTED_FIELDS(macro)                                   \
1066   macro(java_lang_invoke_ResolvedMethodName, vmholder, object_signature, false) \
1067   macro(java_lang_invoke_ResolvedMethodName, vmtarget, intptr_signature, false)
1068 
1069 class java_lang_invoke_ResolvedMethodName : AllStatic {
1070   friend class JavaClasses;
1071 
1072   static int _vmtarget_offset;
1073   static int _vmholder_offset;
1074 
1075   static void compute_offsets();
1076  public:
1077   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1078 
1079   static int vmtarget_offset_in_bytes() { return _vmtarget_offset; }
1080 
1081   static Method* vmtarget(oop resolved_method);
1082   static void set_vmtarget(oop resolved_method, Method* method);
1083 
1084   static void set_vmholder(oop resolved_method, oop holder);
1085 
1086   // find or create resolved member name
1087   static oop find_resolved_method(const methodHandle&amp; m, TRAPS);
1088 
1089   static bool is_instance(oop resolved_method);
1090 };
1091 
1092 
1093 #define MEMBERNAME_INJECTED_FIELDS(macro)                               \
1094   macro(java_lang_invoke_MemberName, vmindex,  intptr_signature, false)
1095 
1096 
1097 class java_lang_invoke_MemberName: AllStatic {
1098   friend class JavaClasses;
1099 
1100  private:
1101   // From java.lang.invoke.MemberName:
1102   //    private Class&lt;?&gt;   clazz;       // class in which the method is defined
1103   //    private String     name;        // may be null if not yet materialized
1104   //    private Object     type;        // may be null if not yet materialized
1105   //    private int        flags;       // modifier bits; see reflect.Modifier
1106   //    private ResolvedMethodName method;    // holds VM-specific target value
1107   //    private intptr_t   vmindex;     // member index within class or interface
1108   static int _clazz_offset;
1109   static int _name_offset;
1110   static int _type_offset;
1111   static int _flags_offset;
1112   static int _method_offset;
1113   static int _vmindex_offset;
1114 
1115   static void compute_offsets();
1116 
1117  public:
1118   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1119   // Accessors
1120   static oop            clazz(oop mname);
1121   static void       set_clazz(oop mname, oop clazz);
1122 
1123   static oop            type(oop mname);
1124   static void       set_type(oop mname, oop type);
1125 
1126   static oop            name(oop mname);
1127   static void       set_name(oop mname, oop name);
1128 
1129   static int            flags(oop mname);
1130   static void       set_flags(oop mname, int flags);
1131 
1132   // Link through ResolvedMethodName field to get Method*
1133   static Method*        vmtarget(oop mname);
1134   static void       set_method(oop mname, oop method);
1135 
1136   static intptr_t       vmindex(oop mname);
1137   static void       set_vmindex(oop mname, intptr_t index);
1138 
1139   // Testers
1140   static bool is_subclass(Klass* klass) {
1141     return klass-&gt;is_subclass_of(SystemDictionary::MemberName_klass());
1142   }
1143   static bool is_instance(oop obj);
1144 
1145   static bool is_method(oop obj);
1146 
1147   // Relevant integer codes (keep these in synch. with MethodHandleNatives.Constants):
1148   enum {
1149     MN_IS_METHOD            = 0x00010000, // method (not constructor)
1150     MN_IS_CONSTRUCTOR       = 0x00020000, // constructor
1151     MN_IS_FIELD             = 0x00040000, // field
1152     MN_IS_TYPE              = 0x00080000, // nested type
1153     MN_CALLER_SENSITIVE     = 0x00100000, // @CallerSensitive annotation detected
1154     MN_REFERENCE_KIND_SHIFT = 24, // refKind
1155     MN_REFERENCE_KIND_MASK  = 0x0F000000 &gt;&gt; MN_REFERENCE_KIND_SHIFT,
1156     // The SEARCH_* bits are not for MN.flags but for the matchFlags argument of MHN.getMembers:
1157     MN_SEARCH_SUPERCLASSES  = 0x00100000, // walk super classes
1158     MN_SEARCH_INTERFACES    = 0x00200000  // walk implemented interfaces
1159   };
1160 
1161   // Accessors for code generation:
1162   static int clazz_offset_in_bytes()            { return _clazz_offset; }
1163   static int type_offset_in_bytes()             { return _type_offset; }
1164   static int name_offset_in_bytes()             { return _name_offset; }
1165   static int flags_offset_in_bytes()            { return _flags_offset; }
1166   static int method_offset_in_bytes()           { return _method_offset; }
1167   static int vmindex_offset_in_bytes()          { return _vmindex_offset; }
1168 };
1169 
1170 
1171 // Interface to java.lang.invoke.MethodType objects
1172 
1173 class java_lang_invoke_MethodType: AllStatic {
1174   friend class JavaClasses;
1175 
1176  private:
1177   static int _rtype_offset;
1178   static int _ptypes_offset;
1179 
1180   static void compute_offsets();
1181 
1182  public:
1183   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1184   // Accessors
1185   static oop            rtype(oop mt);
1186   static objArrayOop    ptypes(oop mt);
1187 
1188   static oop            ptype(oop mt, int index);
1189   static int            ptype_count(oop mt);
1190 
1191   static int            ptype_slot_count(oop mt);  // extra counts for long/double
1192   static int            rtype_slot_count(oop mt);  // extra counts for long/double
1193 
1194   static Symbol*        as_signature(oop mt, bool intern_if_not_found);
1195   static void           print_signature(oop mt, outputStream* st);
1196 
1197   static bool is_instance(oop obj);
1198 
1199   static bool equals(oop mt1, oop mt2);
1200 
1201   // Accessors for code generation:
1202   static int rtype_offset_in_bytes()            { return _rtype_offset; }
1203   static int ptypes_offset_in_bytes()           { return _ptypes_offset; }
1204 };
1205 
1206 
1207 // Interface to java.lang.invoke.CallSite objects
1208 
1209 class java_lang_invoke_CallSite: AllStatic {
1210   friend class JavaClasses;
1211 
1212 private:
1213   static int _target_offset;
1214   static int _context_offset;
1215 
1216   static void compute_offsets();
1217 
1218 public:
1219   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1220   // Accessors
1221   static oop              target(          oop site);
1222   static void         set_target(          oop site, oop target);
1223   static void         set_target_volatile( oop site, oop target);
1224 
1225   static oop context_no_keepalive(oop site);
1226 
1227   // Testers
1228   static bool is_subclass(Klass* klass) {
1229     return klass-&gt;is_subclass_of(SystemDictionary::CallSite_klass());
1230   }
1231   static bool is_instance(oop obj);
1232 
1233   // Accessors for code generation:
1234   static int target_offset_in_bytes()           { return _target_offset; }
1235 };
1236 
1237 // Interface to java.lang.invoke.ConstantCallSite objects
1238 
1239 class java_lang_invoke_ConstantCallSite: AllStatic {
1240   friend class JavaClasses;
1241 
1242 private:
1243   static int _is_frozen_offset;
1244 
1245   static void compute_offsets();
1246 
1247 public:
1248   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1249   // Accessors
1250   static jboolean is_frozen(oop site);
1251 
1252   // Testers
1253   static bool is_subclass(Klass* klass) {
1254     return klass-&gt;is_subclass_of(SystemDictionary::ConstantCallSite_klass());
1255   }
1256   static bool is_instance(oop obj);
1257 };
1258 
1259 // Interface to java.lang.invoke.MethodHandleNatives$CallSiteContext objects
1260 
1261 #define CALLSITECONTEXT_INJECTED_FIELDS(macro) \
1262   macro(java_lang_invoke_MethodHandleNatives_CallSiteContext, vmdependencies, intptr_signature, false) \
1263   macro(java_lang_invoke_MethodHandleNatives_CallSiteContext, last_cleanup, long_signature, false)
1264 
1265 class DependencyContext;
1266 
1267 class java_lang_invoke_MethodHandleNatives_CallSiteContext : AllStatic {
1268   friend class JavaClasses;
1269 
1270 private:
1271   static int _vmdependencies_offset;
1272   static int _last_cleanup_offset;
1273 
1274   static void compute_offsets();
1275 
1276 public:
1277   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1278   // Accessors
1279   static DependencyContext vmdependencies(oop context);
1280 
1281   // Testers
1282   static bool is_subclass(Klass* klass) {
1283     return klass-&gt;is_subclass_of(SystemDictionary::Context_klass());
1284   }
1285   static bool is_instance(oop obj);
1286 };
1287 
1288 // Interface to java.security.AccessControlContext objects
1289 
1290 class java_security_AccessControlContext: AllStatic {
1291  private:
1292   // Note that for this class the layout changed between JDK1.2 and JDK1.3,
1293   // so we compute the offsets at startup rather than hard-wiring them.
1294   static int _context_offset;
1295   static int _privilegedContext_offset;
1296   static int _isPrivileged_offset;
1297   static int _isAuthorized_offset;
1298 
1299   static void compute_offsets();
1300  public:
1301   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1302   static oop create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS);
1303 
1304   // Debugging/initialization
1305   friend class JavaClasses;
1306 };
1307 
1308 
1309 // Interface to java.lang.ClassLoader objects
1310 
1311 #define CLASSLOADER_INJECTED_FIELDS(macro)                            \
1312   macro(java_lang_ClassLoader, loader_data,  intptr_signature, false)
1313 
1314 class java_lang_ClassLoader : AllStatic {
1315  private:
1316   static int _loader_data_offset;
1317   static bool offsets_computed;
1318   static int parent_offset;
1319   static int parallelCapable_offset;
1320   static int name_offset;
1321   static int nameAndId_offset;
1322   static int unnamedModule_offset;
1323 
1324  public:
1325   static void compute_offsets();
1326   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1327 
1328   static ClassLoaderData* loader_data_acquire(oop loader);
1329   static ClassLoaderData* loader_data_raw(oop loader);
1330   static void release_set_loader_data(oop loader, ClassLoaderData* new_data);
1331 
1332   static oop parent(oop loader);
1333   static oop name(oop loader);
1334   static oop nameAndId(oop loader);
1335   static bool isAncestor(oop loader, oop cl);
1336 
1337   // Support for parallelCapable field
1338   static bool parallelCapable(oop the_class_mirror);
1339 
1340   static bool is_trusted_loader(oop loader);
1341 
1342   // Return true if this is one of the class loaders associated with
1343   // the generated bytecodes for reflection.
1344   static bool is_reflection_class_loader(oop loader);
1345 
1346   // Fix for 4474172
1347   static oop  non_reflection_class_loader(oop loader);
1348 
1349   // Testers
1350   static bool is_subclass(Klass* klass) {
1351     return klass-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass());
1352   }
1353   static bool is_instance(oop obj);
1354 
1355   static oop unnamedModule(oop loader);
1356 
1357   // Debugging
1358   friend class JavaClasses;
1359   friend class ClassFileParser; // access to number_of_fake_fields
1360 };
1361 
1362 
1363 // Interface to java.lang.System objects
1364 
1365 class java_lang_System : AllStatic {
1366  private:
1367   static int  static_in_offset;
1368   static int static_out_offset;
1369   static int static_err_offset;
1370   static int static_security_offset;
1371 
1372  public:
1373   static int  in_offset_in_bytes();
1374   static int out_offset_in_bytes();
1375   static int err_offset_in_bytes();
1376 
1377   static void compute_offsets();
1378   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1379 
1380   // Debugging
1381   friend class JavaClasses;
1382 };
1383 
1384 
1385 // Interface to java.lang.StackTraceElement objects
1386 
1387 class java_lang_StackTraceElement: AllStatic {
1388  private:
1389   static int declaringClassObject_offset;
1390   static int classLoaderName_offset;
1391   static int moduleName_offset;
1392   static int moduleVersion_offset;
1393   static int declaringClass_offset;
1394   static int methodName_offset;
1395   static int fileName_offset;
1396   static int lineNumber_offset;
1397 
1398   // Setters
1399   static void set_classLoaderName(oop element, oop value);
1400   static void set_moduleName(oop element, oop value);
1401   static void set_moduleVersion(oop element, oop value);
1402   static void set_declaringClass(oop element, oop value);
1403   static void set_methodName(oop element, oop value);
1404   static void set_fileName(oop element, oop value);
1405   static void set_lineNumber(oop element, int value);
1406   static void set_declaringClassObject(oop element, oop value);
1407 
1408   static void decode_file_and_line(Handle java_mirror, InstanceKlass* holder, int version,
1409                                    const methodHandle&amp; method, int bci,
1410                                    Symbol*&amp; source, oop&amp; source_file, int&amp; line_number, TRAPS);
1411 
1412  public:
1413   // Create an instance of StackTraceElement
1414   static oop create(const methodHandle&amp; method, int bci, TRAPS);
1415 
1416   static void fill_in(Handle element, InstanceKlass* holder, const methodHandle&amp; method,
1417                       int version, int bci, Symbol* name, TRAPS);
1418 
1419   static void compute_offsets();
1420   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1421 
1422 #if INCLUDE_JVMCI
1423   static void decode(const methodHandle&amp; method, int bci, Symbol*&amp; fileName, int&amp; lineNumber, TRAPS);
1424 #endif
1425 
1426   // Debugging
1427   friend class JavaClasses;
1428 };
1429 
1430 
1431 class Backtrace: AllStatic {
1432  public:
1433   // Helper backtrace functions to store bci|version together.
1434   static int merge_bci_and_version(int bci, int version);
1435   static int merge_mid_and_cpref(int mid, int cpref);
1436   static int bci_at(unsigned int merged);
1437   static int version_at(unsigned int merged);
1438   static int mid_at(unsigned int merged);
1439   static int cpref_at(unsigned int merged);
1440   static int get_line_number(Method* method, int bci);
1441   static Symbol* get_source_file_name(InstanceKlass* holder, int version);
1442 
1443   // Debugging
1444   friend class JavaClasses;
1445 };
1446 
1447 // Interface to java.lang.StackFrameInfo objects
1448 
1449 #define STACKFRAMEINFO_INJECTED_FIELDS(macro)                      \
1450   macro(java_lang_StackFrameInfo, version, short_signature, false)
1451 
1452 class java_lang_StackFrameInfo: AllStatic {
1453 private:
1454   static int _memberName_offset;
1455   static int _bci_offset;
1456   static int _version_offset;
1457 
1458   static Method* get_method(Handle stackFrame, InstanceKlass* holder, TRAPS);
1459 
1460 public:
1461   // Setters
1462   static void set_method_and_bci(Handle stackFrame, const methodHandle&amp; method, int bci, TRAPS);
1463   static void set_bci(oop info, int value);
1464 
1465   static void set_version(oop info, short value);
1466 
1467   static void compute_offsets();
1468   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1469 
1470   static void to_stack_trace_element(Handle stackFrame, Handle stack_trace_element, TRAPS);
1471 
1472   // Debugging
1473   friend class JavaClasses;
1474 };
1475 
1476 class java_lang_LiveStackFrameInfo: AllStatic {
1477  private:
1478   static int _monitors_offset;
1479   static int _locals_offset;
1480   static int _operands_offset;
1481   static int _mode_offset;
1482 
1483  public:
1484   static void set_monitors(oop info, oop value);
1485   static void set_locals(oop info, oop value);
1486   static void set_operands(oop info, oop value);
1487   static void set_mode(oop info, int value);
1488 
1489   static void compute_offsets();
1490   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1491 
1492   // Debugging
1493   friend class JavaClasses;
1494 };
1495 
1496 // Interface to java.lang.reflect.RecordComponent objects
1497 
1498 class java_lang_reflect_RecordComponent: AllStatic {
1499  private:
1500   static int clazz_offset;
1501   static int name_offset;
1502   static int type_offset;
1503   static int accessor_offset;
1504   static int signature_offset;
1505   static int annotations_offset;
1506   static int typeAnnotations_offset;
1507 
1508   // Setters
1509   static void set_clazz(oop element, oop value);
1510   static void set_name(oop element, oop value);
1511   static void set_type(oop element, oop value);
1512   static void set_accessor(oop element, oop value);
1513   static void set_signature(oop element, oop value);
1514   static void set_annotations(oop element, oop value);
1515   static void set_typeAnnotations(oop element, oop value);
1516 
1517  public:
1518   // Create an instance of RecordComponent
1519   static oop create(InstanceKlass* holder, RecordComponent* component, TRAPS);
1520 
1521   static void compute_offsets();
1522   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1523 
1524   // Debugging
1525   friend class JavaClasses;
1526 };
1527 
1528 
1529 // Interface to java.lang.AssertionStatusDirectives objects
1530 
1531 class java_lang_AssertionStatusDirectives: AllStatic {
1532  private:
1533   static int classes_offset;
1534   static int classEnabled_offset;
1535   static int packages_offset;
1536   static int packageEnabled_offset;
1537   static int deflt_offset;
1538 
1539  public:
1540   // Setters
1541   static void set_classes(oop obj, oop val);
1542   static void set_classEnabled(oop obj, oop val);
1543   static void set_packages(oop obj, oop val);
1544   static void set_packageEnabled(oop obj, oop val);
1545   static void set_deflt(oop obj, bool val);
1546 
1547   static void compute_offsets();
1548   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1549 
1550   // Debugging
1551   friend class JavaClasses;
1552 };
1553 
1554 
1555 class java_nio_Buffer: AllStatic {
1556  private:
1557   static int _limit_offset;
1558 
1559  public:
1560   static int  limit_offset();
1561   static void compute_offsets();
1562   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1563 };
1564 
1565 class java_util_concurrent_locks_AbstractOwnableSynchronizer : AllStatic {
1566  private:
1567   static int  _owner_offset;
1568  public:
1569   static void compute_offsets();
1570   static oop  get_owner_threadObj(oop obj);
1571   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1572 };
1573 
1574  // Interface to jdk.internal.misc.UnsafeConsants
1575 
1576 class jdk_internal_misc_UnsafeConstants : AllStatic {
1577  public:
1578   static void set_unsafe_constants();
1579   static void compute_offsets() { }
1580   static void serialize_offsets(SerializeClosure* f) { }
1581 };
1582 
1583 class java_lang_Integer : AllStatic {
1584 public:
1585   static jint value(oop obj);
1586 };
1587 
1588 class java_lang_Long : AllStatic {
1589 public:
1590   static jlong value(oop obj);
1591 };
1592 
1593 class java_lang_Character : AllStatic {
1594 public:
1595   static jchar value(oop obj);
1596 };
1597 
1598 class java_lang_Short : AllStatic {
1599 public:
1600   static jshort value(oop obj);
1601 };
1602 
1603 class java_lang_Byte : AllStatic {
1604 public:
1605   static jbyte value(oop obj);
1606 };
1607 
1608 class java_lang_Boolean : AllStatic {
1609  private:
1610   static int _static_TRUE_offset;
1611   static int _static_FALSE_offset;
1612  public:
1613   static Symbol* symbol();
1614   static void compute_offsets(InstanceKlass* k);
1615   static oop  get_TRUE(InstanceKlass *k);
1616   static oop  get_FALSE(InstanceKlass *k);
1617   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1618   static jboolean value(oop obj);
1619 };
1620 
1621 class java_lang_Integer_IntegerCache : AllStatic {
1622  private:
1623   static int _static_cache_offset;
1624  public:
1625   static Symbol* symbol();
1626   static void compute_offsets(InstanceKlass* k);
1627   static objArrayOop  cache(InstanceKlass *k);
1628   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1629 };
1630 
1631 class java_lang_Long_LongCache : AllStatic {
1632  private:
1633   static int _static_cache_offset;
1634  public:
1635   static Symbol* symbol();
1636   static void compute_offsets(InstanceKlass* k);
1637   static objArrayOop  cache(InstanceKlass *k);
1638   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1639 };
1640 
1641 class java_lang_Character_CharacterCache : AllStatic {
1642  private:
1643   static int _static_cache_offset;
1644  public:
1645   static Symbol* symbol();
1646   static void compute_offsets(InstanceKlass* k);
1647   static objArrayOop  cache(InstanceKlass *k);
1648   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1649 };
1650 
1651 class java_lang_Short_ShortCache : AllStatic {
1652  private:
1653   static int _static_cache_offset;
1654  public:
1655   static Symbol* symbol();
1656   static void compute_offsets(InstanceKlass* k);
1657   static objArrayOop  cache(InstanceKlass *k);
1658   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1659 };
1660 
1661 class java_lang_Byte_ByteCache : AllStatic {
1662  private:
1663   static int _static_cache_offset;
1664  public:
1665   static Symbol* symbol();
1666   static void compute_offsets(InstanceKlass* k);
1667   static objArrayOop  cache(InstanceKlass *k);
1668   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1669 };
1670 
1671 // Use to declare fields that need to be injected into Java classes
1672 // for the JVM to use.  The name_index and signature_index are
1673 // declared in vmSymbols.  The may_be_java flag is used to declare
1674 // fields that might already exist in Java but should be injected if
1675 // they don&#39;t.  Otherwise the field is unconditionally injected and
1676 // the JVM uses the injected one.  This is to ensure that name
1677 // collisions don&#39;t occur.  In general may_be_java should be false
1678 // unless there&#39;s a good reason.
1679 
1680 class InjectedField {
1681  public:
1682   const SystemDictionary::WKID klass_id;
1683   const vmSymbols::SID name_index;
1684   const vmSymbols::SID signature_index;
1685   const bool           may_be_java;
1686 
1687 
1688   Klass* klass() const    { return SystemDictionary::well_known_klass(klass_id); }
1689   Symbol* name() const      { return lookup_symbol(name_index); }
1690   Symbol* signature() const { return lookup_symbol(signature_index); }
1691 
1692   int compute_offset();
1693 
1694   // Find the Symbol for this index
1695   static Symbol* lookup_symbol(int symbol_index) {
1696     return vmSymbols::symbol_at((vmSymbols::SID)symbol_index);
1697   }
1698 };
1699 
1700 #define DECLARE_INJECTED_FIELD_ENUM(klass, name, signature, may_be_java) \
1701   klass##_##name##_enum,
1702 
1703 #define ALL_INJECTED_FIELDS(macro)          \
1704   CLASS_INJECTED_FIELDS(macro)              \
1705   CLASSLOADER_INJECTED_FIELDS(macro)        \
1706   RESOLVEDMETHOD_INJECTED_FIELDS(macro)     \
1707   MEMBERNAME_INJECTED_FIELDS(macro)         \
1708   CALLSITECONTEXT_INJECTED_FIELDS(macro)    \
1709   STACKFRAMEINFO_INJECTED_FIELDS(macro)     \
1710   MODULE_INJECTED_FIELDS(macro)
1711 
1712 // Interface to hard-coded offset checking
1713 
1714 class JavaClasses : AllStatic {
1715  private:
1716 
1717   static InjectedField _injected_fields[];
1718 
1719   static bool check_offset(const char *klass_name, int offset, const char *field_name, const char* field_sig) PRODUCT_RETURN0;
1720  public:
1721   enum InjectedFieldID {
1722     ALL_INJECTED_FIELDS(DECLARE_INJECTED_FIELD_ENUM)
1723     MAX_enum
1724   };
1725 
1726   static int compute_injected_offset(InjectedFieldID id);
1727 
1728   static void compute_hard_coded_offsets();
1729   static void compute_offsets();
1730   static void check_offsets() PRODUCT_RETURN;
1731   static void serialize_offsets(SerializeClosure* soc) NOT_CDS_RETURN;
1732   static InjectedField* get_injected(Symbol* class_name, int* field_count);
1733   static bool is_supported_for_archiving(oop obj) NOT_CDS_JAVA_HEAP_RETURN_(false);
1734 };
1735 
1736 #undef DECLARE_INJECTED_FIELD_ENUM
1737 
1738 #endif // SHARE_CLASSFILE_JAVACLASSES_HPP
    </pre>
  </body>
</html>